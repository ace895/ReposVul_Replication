{"index": 0, "cve_id": "CVE-2016-7115", "cwe_id": ["CWE-119"], "cve_language": "C", "cve_description": "Buffer overflow in the handle_packet function in mactelnet.c in the client in MAC-Telnet 0.4.3 and earlier allows remote TELNET servers to execute arbitrary code via a long string in an MT_CPTYPE_PASSSALT control packet.", "cvss": "9.8", "publish_date": "August 30, 2016", "AV": "NETWORK", "AC": "LOW", "PR": "NONE", "UI": "NONE", "S": "UNCHANGED", "C": "HIGH", "I": "HIGH", "A": "HIGH", "commit_id": "b69d11727d4f0f8cf719c79e3fb700f55ca03e9a", "commit_message": "Merge pull request #20 from eyalitki/master\n\n2nd round security fixes from eyalitki", "commit_date": "2016-08-30T09:27:39Z", "project": "haakonnessjoen/mac-telnet", "url": "https://api.github.com/repos/haakonnessjoen/MAC-Telnet/commits/b69d11727d4f0f8cf719c79e3fb700f55ca03e9a", "html_url": "https://github.com/haakonnessjoen/MAC-Telnet/commit/b69d11727d4f0f8cf719c79e3fb700f55ca03e9a", "windows_before": "", "windows_after": "", "parents": [{"commit_id_before": "b9cede3c19693b7663219691d8604e037cea673a", "url_before": "https://api.github.com/repos/haakonnessjoen/MAC-Telnet/commits/b9cede3c19693b7663219691d8604e037cea673a", "html_url_before": "https://github.com/haakonnessjoen/MAC-Telnet/commit/b9cede3c19693b7663219691d8604e037cea673a"}, {"commit_id_before": "9d946fa173acadcff7c80171d9b1186fab2e8daf", "url_before": "https://api.github.com/repos/haakonnessjoen/MAC-Telnet/commits/9d946fa173acadcff7c80171d9b1186fab2e8daf", "html_url_before": "https://github.com/haakonnessjoen/MAC-Telnet/commit/9d946fa173acadcff7c80171d9b1186fab2e8daf"}], "details": [{"raw_url": "https://github.com/haakonnessjoen/MAC-Telnet/raw/b69d11727d4f0f8cf719c79e3fb700f55ca03e9a/mactelnet.c", "patch": "@@ -96,7 +96,7 @@ static char autologin_path[255];\n \n static int keepalive_counter = 0;\n \n-static unsigned char pass_salt[17];\n+static unsigned char pass_salt[16];\n static char username[MT_MNDP_MAX_STRING_SIZE];\n static char password[MT_MNDP_MAX_STRING_SIZE];\n static char nonpriv_username[MT_MNDP_MAX_STRING_SIZE];\n@@ -212,23 +212,26 @@ static void send_auth(char *username, char *password) {\n \tchar *terminal = getenv(\"TERM\");\n \tchar md5data[100];\n \tunsigned char md5sum[17];\n-\tint plen;\n+\tint plen, act_pass_len;\n \tmd5_state_t state;\n \n #if defined(__linux__) && defined(_POSIX_MEMLOCK_RANGE)\n \tmlock(md5data, sizeof(md5data));\n \tmlock(md5sum, sizeof(md5data));\n #endif\n \n+\t/* calculate the actual password's length */\n+\tact_pass_len = strnlen(password, 82);\n+\n \t/* Concat string of 0 + password + pass_salt */\n \tmd5data[0] = 0;\n-\tstrncpy(md5data + 1, password, 82);\n-\tmd5data[83] = '\\0';\n-\tmemcpy(md5data + 1 + strlen(password), pass_salt, 16);\n+\tmemcpy(md5data + 1, password, act_pass_len);\n+\t/* in case that password is long, calculate only using the used-up parts */\n+\tmemcpy(md5data + 1 + act_pass_len, pass_salt, 16);\n \n \t/* Generate md5 sum of md5data with a leading 0 */\n \tmd5_init(&state);\n-\tmd5_append(&state, (const md5_byte_t *)md5data, strlen(password) + 17);\n+\tmd5_append(&state, (const md5_byte_t *)md5data, 1 + act_pass_len + 16);\n \tmd5_finish(&state, (md5_byte_t *)md5sum + 1);\n \tmd5sum[0] = 0;\n \n@@ -312,7 +315,11 @@ static int handle_packet(unsigned char *data, int data_len) {\n \n \t\t\t/* If we receive pass_salt, transmit auth data back */\n \t\t\tif (cpkt.cptype == MT_CPTYPE_PASSSALT) {\n-\t\t\t\tmemcpy(pass_salt, cpkt.data, cpkt.length);\n+\t\t\t\t/* check validity, server sends exactly 16 bytes */\n+\t\t\t\tif (cpkt.length != 16) {\n+\t\t\t\t\tfprintf(stderr, _(\"Invalid salt length: %d (instead of 16) received from server %s\\n\"), cpkt.length, ether_ntoa((struct ether_addr *)dstmac));\n+\t\t\t\t}\n+\t\t\t\tmemcpy(pass_salt, cpkt.data, 16);\n \t\t\t\tsend_auth(username, password);\n \t\t\t}\n ", "file_path": "files/2016_8\\1", "file_language": "c", "file_name": "mactelnet.c", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}, {"raw_url": "https://github.com/haakonnessjoen/MAC-Telnet/raw/b69d11727d4f0f8cf719c79e3fb700f55ca03e9a/mactelnetd.c", "patch": "@@ -407,6 +407,7 @@ static void user_login(struct mt_connection *curconn, struct mt_mactelnet_hdr *p\n \tchar md5data[100];\n \tstruct mt_credentials *user;\n \tchar *slavename;\n+\tint act_pass_len;\n \n \t/* Reparse user file before each login */\n \tread_userfile();\n@@ -421,14 +422,18 @@ static void user_login(struct mt_connection *curconn, struct mt_mactelnet_hdr *p\n \t\t}\n #endif\n \n+\t\t/* calculate the password's actual length */\n+\t\tact_pass_len = strlen(user->password);\n+\t\tact_pass_len = act_pass_len <= 82 ? act_pass_len : 82;\n+\n \t\t/* Concat string of 0 + password + pass_salt */\n \t\tmd5data[0] = 0;\n-\t\tstrncpy(md5data + 1, user->password, 82);\n-\t\tmemcpy(md5data + 1 + strlen(user->password), curconn->pass_salt, 16);\n+\t\tmemcpy(md5data + 1, user->password, act_pass_len);\n+\t\tmemcpy(md5data + 1 + act_pass_len, curconn->pass_salt, 16);\n \n \t\t/* Generate md5 sum of md5data with a leading 0 */\n \t\tmd5_init(&state);\n-\t\tmd5_append(&state, (const md5_byte_t *)md5data, strlen(user->password) + 17);\n+\t\tmd5_append(&state, (const md5_byte_t *)md5data, 1 + act_pass_len + 16);\n \t\tmd5_finish(&state, (md5_byte_t *)md5sum + 1);\n \t\tmd5sum[0] = 0;\n \n@@ -635,7 +640,7 @@ static void handle_data_packet(struct mt_connection *curconn, struct mt_mactelne\n \t\t\tmemcpy(curconn->terminal_type, cpkt.data, act_size = (cpkt.length > 30 - 1 ? 30 - 1 : cpkt.length));\n \t\t\tcurconn->terminal_type[act_size] = 0;\n \n-\t\t} else if (cpkt.cptype == MT_CPTYPE_PASSWORD) {\n+\t\t} else if (cpkt.cptype == MT_CPTYPE_PASSWORD && cpkt.length == 17) {\n \n #if defined(__linux__) && defined(_POSIX_MEMLOCK_RANGE)\n \t\t\tmlock(curconn->trypassword, 17);\n@@ -651,7 +656,7 @@ static void handle_data_packet(struct mt_connection *curconn, struct mt_mactelne\n \t\t\t}\n \n \t\t} else {\n-\t\t\tsyslog(LOG_WARNING, _(\"(%d) Unhandeled control packet type: %d\"), curconn->seskey, cpkt.cptype);\n+\t\t\tsyslog(LOG_WARNING, _(\"(%d) Unhandeled control packet type: %d, length: %d\"), curconn->seskey, cpkt.cptype, cpkt.length);\n \t\t}\n \n \t\t/* Parse next control packet */", "file_path": "files/2016_8\\2", "file_language": "c", "file_name": "mactelnetd.c", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}, {"raw_url": "https://github.com/haakonnessjoen/MAC-Telnet/raw/b69d11727d4f0f8cf719c79e3fb700f55ca03e9a/protocol.c", "patch": "@@ -84,8 +84,9 @@ int add_control_packet(struct mt_packet *packet, enum mt_cptype cptype, void *cp\n \tunsigned char *data = packet->data + packet->size;\n \tunsigned int act_size = data_len + (cptype == MT_CPTYPE_PLAINDATA ? 0 : MT_CPHEADER_LEN);\n \n-\t/* Something is really wrong. Packets should never become over 1500 bytes */\n-\tif (packet->size + act_size > MT_PACKET_LEN) {\n+\t/* Something is really wrong. Packets should never become over 1500 bytes,\n+       perform an Integer-Overflow safe check */\n+\tif (act_size > MT_PACKET_LEN - packet->size) {\n \t\tfprintf(stderr, _(\"add_control_packet: ERROR, too large packet. Exceeds %d bytes\\n\"), MT_PACKET_LEN);\n \t\treturn -1;\n \t\t//exit(1);\n@@ -149,7 +150,8 @@ int init_pongpacket(struct mt_packet *packet, unsigned char *srcmac, unsigned ch\n }\n \n int add_packetdata(struct mt_packet *packet, unsigned char *data, unsigned short length) {\n-\tif (packet->size + length > MT_PACKET_LEN) {\n+\t/* Integer-Overflow safe check */\n+\tif (length > MT_PACKET_LEN - packet->size) {\n \t\tfprintf(stderr, _(\"add_control_packet: ERROR, too large packet. Exceeds %d bytes\\n\"), MT_PACKET_LEN);\n \t\treturn -1;\n \t}\n@@ -272,7 +274,7 @@ int mndp_add_attribute(struct mt_packet *packet, enum mt_mndp_attrtype attrtype,\n \tunsigned short len = data_len;\n \n \t/* Something is really wrong. Packets should never become over 1500 bytes */\n-\tif (packet->size + 4 + data_len > MT_PACKET_LEN) {\n+\tif (data_len > MT_PACKET_LEN - 4 - packet->size) {\n \t\tfprintf(stderr, _(\"mndp_add_attribute: ERROR, too large packet. Exceeds %d bytes\\n\"), MT_PACKET_LEN);\n \t\treturn -1;\n \t}", "file_path": "files/2016_8\\3", "file_language": "c", "file_name": "protocol.c", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}], "outdated": 0}
{"index": 1, "cve_id": "CVE-2016-4069", "cwe_id": ["CWE-352"], "cve_language": "PHP", "cve_description": "Cross-site request forgery (CSRF) vulnerability in Roundcube Webmail before 1.1.5 allows remote attackers to hijack the authentication of users for requests that download attachments and cause a denial of service (disk consumption) via unspecified vectors.", "cvss": "8.8", "publish_date": "August 25, 2016", "AV": "NETWORK", "AC": "LOW", "PR": "NONE", "UI": "REQUIRED", "S": "UNCHANGED", "C": "HIGH", "I": "HIGH", "A": "HIGH", "commit_id": "4a408843b0ef816daf70a472a02b78cd6073a4d5", "commit_message": "Protect download urls against CSRF using unique request tokens (#1490642)\nSend X-Frame-Options headers with every HTTP response", "commit_date": "2016-03-06T13:31:07Z", "project": "roundcube/roundcubemail", "url": "https://api.github.com/repos/roundcube/roundcubemail/commits/4a408843b0ef816daf70a472a02b78cd6073a4d5", "html_url": "https://github.com/roundcube/roundcubemail/commit/4a408843b0ef816daf70a472a02b78cd6073a4d5", "windows_before": "", "windows_after": "", "parents": [{"commit_id_before": "d4df3748cfaacadf52b19eb37b2a476df80525a9", "url_before": "https://api.github.com/repos/roundcube/roundcubemail/commits/d4df3748cfaacadf52b19eb37b2a476df80525a9", "html_url_before": "https://github.com/roundcube/roundcubemail/commit/d4df3748cfaacadf52b19eb37b2a476df80525a9"}], "details": [{"raw_url": "https://github.com/roundcube/roundcubemail/raw/4a408843b0ef816daf70a472a02b78cd6073a4d5/plugins/enigma/enigma.js", "patch": "@@ -157,7 +157,7 @@ rcube_webmail.prototype.enigma_export = function(selected)\n     if (!keys.length)\n         return;\n \n-    this.goto_url('plugin.enigmakeys', {_a: 'export', _keys: keys});\n+    this.goto_url('plugin.enigmakeys', {_a: 'export', _keys: keys}, false, true);\n };\n \n // Submit key(s) import form", "file_path": "files/2016_8\\4", "file_language": "js", "file_name": "plugins/enigma/enigma.js", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}, {"raw_url": "https://github.com/roundcube/roundcubemail/raw/4a408843b0ef816daf70a472a02b78cd6073a4d5/plugins/enigma/lib/enigma_ui.php", "patch": "@@ -459,6 +459,8 @@ function tpl_key_data($attrib)\n      */\n     private function key_export()\n     {\n+        $this->rc->request_security_check(rcube_utils::INPUT_GET);\n+\n         $keys   = rcube_utils::get_input_value('_keys', rcube_utils::INPUT_GPC);\n         $engine = $this->enigma->load_engine();\n         $list   = $keys == '*' ? $engine->list_keys() : explode(',', $keys);", "file_path": "files/2016_8\\5", "file_language": "php", "file_name": "plugins/enigma/lib/enigma_ui.php", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}, {"raw_url": "https://github.com/roundcube/roundcubemail/raw/4a408843b0ef816daf70a472a02b78cd6073a4d5/plugins/managesieve/lib/Roundcube/rcube_sieve_engine.php", "patch": "@@ -397,6 +397,8 @@ function actions()\n                 }\n             }\n             else if ($action == 'setget') {\n+                $this->rc->request_security_check(rcube_utils::INPUT_GET);\n+\n                 $script_name = rcube_utils::get_input_value('_set', rcube_utils::INPUT_GPC, true);\n                 $script      = $this->sieve->get_script($script_name);\n ", "file_path": "files/2016_8\\6", "file_language": "php", "file_name": "plugins/managesieve/lib/Roundcube/rcube_sieve_engine.php", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}, {"raw_url": "https://github.com/roundcube/roundcubemail/raw/4a408843b0ef816daf70a472a02b78cd6073a4d5/plugins/managesieve/managesieve.js", "patch": "@@ -181,7 +181,7 @@ rcube_webmail.prototype.managesieve_setget = function()\n   var id = this.filtersets_list.get_single_selection(),\n     script = this.env.filtersets[id];\n \n-  location.href = this.env.comm_path+'&_action=plugin.managesieve-action&_act=setget&_set='+urlencode(script);\n+  this.goto_url('plugin.managesieve-action', {_act: 'setget', _set: script}, false, true);\n };\n \n // Set activate/deactivate request", "file_path": "files/2016_8\\7", "file_language": "js", "file_name": "plugins/managesieve/managesieve.js", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}, {"raw_url": "https://github.com/roundcube/roundcubemail/raw/4a408843b0ef816daf70a472a02b78cd6073a4d5/plugins/zipdownload/zipdownload.js", "patch": "@@ -54,7 +54,7 @@ function rcmail_zipdownload(mode)\n     // default .eml download of single message\n     if (mode == 'eml') {\n         var uid = rcmail.get_single_uid();\n-        rcmail.goto_url('viewsource', rcmail.params_from_uid(uid, {_save: 1}));\n+        rcmail.goto_url('viewsource', rcmail.params_from_uid(uid, {_save: 1}), false, true);\n         return;\n     }\n ", "file_path": "files/2016_8\\8", "file_language": "js", "file_name": "plugins/zipdownload/zipdownload.js", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}, {"raw_url": "https://github.com/roundcube/roundcubemail/raw/4a408843b0ef816daf70a472a02b78cd6073a4d5/plugins/zipdownload/zipdownload.php", "patch": "@@ -63,7 +63,7 @@ public function attachment_ziplink($p)\n                 '_action' => 'plugin.zipdownload.attachments',\n                 '_mbox'   => $rcmail->output->env['mailbox'],\n                 '_uid'    => $rcmail->output->env['uid'],\n-            ));\n+            ), false, false, true);\n \n             $link = html::a(array('href' => $href, 'class' => 'button zipdownload'),\n                 rcube::Q($this->gettext('downloadall'))\n@@ -120,6 +120,10 @@ public function download_menu()\n     public function download_attachments()\n     {\n         $rcmail    = rcmail::get_instance();\n+\n+        // require CSRF protected request\n+        $rcmail->request_security_check(rcube_utils::INPUT_GET);\n+\n         $imap      = $rcmail->get_storage();\n         $temp_dir  = $rcmail->config->get('temp_dir');\n         $tmpfname  = tempnam($temp_dir, 'zipdownload');", "file_path": "files/2016_8\\9", "file_language": "php", "file_name": "plugins/zipdownload/zipdownload.php", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}, {"raw_url": "https://github.com/roundcube/roundcubemail/raw/4a408843b0ef816daf70a472a02b78cd6073a4d5/program/include/rcmail.php", "patch": "@@ -840,6 +840,8 @@ public function url($p, $absolute = false, $full = false, $secure = false)\n             // this need to be full url to make redirects work\n             $absolute = true;\n         }\n+        else if ($secure && ($token = $this->get_request_token()))\n+            $url .= $delm . '_token=' . urlencode($token);\n \n         if ($absolute || $full) {\n             // add base path to this Roundcube installation", "file_path": "files/2016_8\\10", "file_language": "php", "file_name": "program/include/rcmail.php", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}, {"raw_url": "https://github.com/roundcube/roundcubemail/raw/4a408843b0ef816daf70a472a02b78cd6073a4d5/program/include/rcmail_output_html.php", "patch": "@@ -516,10 +516,10 @@ public function write($template = '')\n         // write all javascript commands\n         $this->add_script($commands, 'head_top');\n \n-        // send clickjacking protection headers\n+        // allow (legal) iframe content to be loaded\n         $iframe = $this->framed || $this->env['framed'];\n-        if (!headers_sent() && ($xframe = $this->app->config->get('x_frame_options', 'sameorigin'))) {\n-            header('X-Frame-Options: ' . ($iframe && $xframe == 'deny' ? 'sameorigin' : $xframe));\n+        if (!headers_sent() && $iframe && $this->app->config->get('x_frame_options', 'sameorigin') === 'deny') {\n+            header('X-Frame-Options: sameorigin', true);\n         }\n \n         // call super method", "file_path": "files/2016_8\\11", "file_language": "php", "file_name": "program/include/rcmail_output_html.php", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}, {"raw_url": "https://github.com/roundcube/roundcubemail/raw/4a408843b0ef816daf70a472a02b78cd6073a4d5/program/js/app.js", "patch": "@@ -1024,7 +1024,7 @@ function rcube_webmail()\n             break;\n         }\n \n-        this.goto_url('get', qstring+'&_download=1', false);\n+        this.goto_url('get', qstring+'&_download=1', false, true);\n         break;\n \n       case 'select-all':\n@@ -1230,10 +1230,10 @@ function rcube_webmail()\n \n       case 'download':\n         if (this.env.action == 'get') {\n-          location.href = location.href.replace(/_frame=/, '_download=');\n+          location.href = this.secure_url(location.href.replace(/_frame=/, '_download='));\n         }\n         else if (uid = this.get_single_uid()) {\n-          this.goto_url('viewsource', this.params_from_uid(uid, {_save: 1}));\n+          this.goto_url('viewsource', this.params_from_uid(uid, {_save: 1}), false, true);\n         }\n         break;\n \n@@ -1321,13 +1321,13 @@ function rcube_webmail()\n \n       case 'export':\n         if (this.contact_list.rowcount > 0) {\n-          this.goto_url('export', { _source: this.env.source, _gid: this.env.group, _search: this.env.search_request });\n+          this.goto_url('export', { _source: this.env.source, _gid: this.env.group, _search: this.env.search_request }, false, true);\n         }\n         break;\n \n       case 'export-selected':\n         if (this.contact_list.rowcount > 0) {\n-          this.goto_url('export', { _source: this.env.source, _gid: this.env.group, _cid: this.contact_list.get_selection().join(',') });\n+          this.goto_url('export', { _source: this.env.source, _gid: this.env.group, _cid: this.contact_list.get_selection().join(',') }, false, true);\n         }\n         break;\n \n@@ -1442,7 +1442,7 @@ function rcube_webmail()\n     if (task == 'mail')\n       url += '&_mbox=INBOX';\n     else if (task == 'logout' && !this.env.server_error) {\n-      url += '&_token=' + this.env.request_token;\n+      url = this.secure_url(url);\n       this.clear_compose_data();\n     }\n \n@@ -1491,6 +1491,12 @@ function rcube_webmail()\n     return url + '?' + name + '=' + value;\n   };\n \n+  // append CSRF protection token to the given url\n+  this.secure_url = function(url)\n+  {\n+    return this.add_url(url, '_token', this.env.request_token);\n+  },\n+\n   this.is_framed = function()\n   {\n     return this.env.framed && parent.rcmail && parent.rcmail != this && typeof parent.rcmail.command == 'function';\n@@ -7899,9 +7905,11 @@ function rcube_webmail()\n     }\n   };\n \n-  this.goto_url = function(action, query, lock)\n+  this.goto_url = function(action, query, lock, secure)\n   {\n-    this.redirect(this.url(action, query), lock);\n+    var url = this.url(action, query)\n+    if (secure) url = this.secure_url(url);\n+    this.redirect(url, lock);\n   };\n \n   this.location_href = function(url, target, frame)", "file_path": "files/2016_8\\12", "file_language": "js", "file_name": "program/js/app.js", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}, {"raw_url": "https://github.com/roundcube/roundcubemail/raw/4a408843b0ef816daf70a472a02b78cd6073a4d5/program/lib/Roundcube/rcube_message.php", "patch": "@@ -108,7 +108,8 @@ function __construct($uid, $folder = null, $is_safe = false)\n             'get_url'     => $this->app->url(array(\n                     'action' => 'get',\n                     'mbox'   => $this->folder,\n-                    'uid'    => $uid))\n+                    'uid'    => $uid),\n+                false, false, true)\n         );\n \n         if (!empty($this->headers->structure)) {", "file_path": "files/2016_8\\13", "file_language": "php", "file_name": "program/lib/Roundcube/rcube_message.php", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}, {"raw_url": "https://github.com/roundcube/roundcubemail/raw/4a408843b0ef816daf70a472a02b78cd6073a4d5/program/lib/Roundcube/rcube_output.php", "patch": "@@ -190,6 +190,11 @@ public function common_headers()\n \n         // Request browser to disable DNS prefetching (CVE-2010-0464)\n         header(\"X-DNS-Prefetch-Control: off\");\n+\n+        // send CSRF and clickjacking protection headers\n+        if ($xframe = $this->app->config->get('x_frame_options', 'sameorigin')) {\n+            header('X-Frame-Options: ' . $xframe);\n+        }\n     }\n \n     /**", "file_path": "files/2016_8\\14", "file_language": "php", "file_name": "program/lib/Roundcube/rcube_output.php", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}, {"raw_url": "https://github.com/roundcube/roundcubemail/raw/4a408843b0ef816daf70a472a02b78cd6073a4d5/program/steps/addressbook/export.inc", "patch": "@@ -21,6 +21,8 @@\n  +-----------------------------------------------------------------------+\n */\n \n+$RCMAIL->request_security_check(rcube_utils::INPUT_GET);\n+\n // Use search result\n if (!empty($_REQUEST['_search']) && isset($_SESSION['search'][$_REQUEST['_search']])) {\n     $sort_col = $RCMAIL->config->get('addressbook_sort_col', 'name');", "file_path": "files/2016_8\\15", "file_language": "inc", "file_name": "program/steps/addressbook/export.inc", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}, {"raw_url": "https://github.com/roundcube/roundcubemail/raw/4a408843b0ef816daf70a472a02b78cd6073a4d5/program/steps/mail/get.inc", "patch": "@@ -129,6 +129,10 @@ else if (strlen($part_id)) {\n             exit;\n         }\n \n+        // require CSRF protected url for downloads\n+        if ($plugin['download'])\n+            $RCMAIL->request_security_check(rcube_utils::INPUT_GET);\n+\n         // overwrite modified vars from plugin\n         $mimetype   = $plugin['mimetype'];\n         $extensions = rcube_mime::get_mime_extensions($mimetype);", "file_path": "files/2016_8\\16", "file_language": "inc", "file_name": "program/steps/mail/get.inc", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}, {"raw_url": "https://github.com/roundcube/roundcubemail/raw/4a408843b0ef816daf70a472a02b78cd6073a4d5/program/steps/mail/viewsource.inc", "patch": "@@ -19,6 +19,10 @@\n  +-----------------------------------------------------------------------+\n */\n \n+if (!empty($_GET['_save'])) {\n+    $RCMAIL->request_security_check(rcube_utils::INPUT_GET);\n+}\n+\n ob_end_clean();\n \n // similar code as in program/steps/mail/get.inc", "file_path": "files/2016_8\\17", "file_language": "inc", "file_name": "program/steps/mail/viewsource.inc", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}], "outdated": 0}
{"index": 2, "cve_id": "CVE-2016-4069", "cwe_id": ["CWE-352"], "cve_language": "PHP", "cve_description": "Cross-site request forgery (CSRF) vulnerability in Roundcube Webmail before 1.1.5 allows remote attackers to hijack the authentication of users for requests that download attachments and cause a denial of service (disk consumption) via unspecified vectors.", "cvss": "8.8", "publish_date": "August 25, 2016", "AV": "NETWORK", "AC": "LOW", "PR": "NONE", "UI": "REQUIRED", "S": "UNCHANGED", "C": "HIGH", "I": "HIGH", "A": "HIGH", "commit_id": "699af1e5206ed9114322adaa3c25c1c969640a53", "commit_message": "Protect download urls against CSRF using unique request tokens (#1490642)\nSend X-Frame-Options headers with every HTTP response\n\nConflicts:\n\tplugins/enigma/enigma.js\n\tplugins/enigma/lib/enigma_ui.php\n\tprogram/lib/Roundcube/rcube_message.php", "commit_date": "2016-03-06T13:35:48Z", "project": "roundcube/roundcubemail", "url": "https://api.github.com/repos/roundcube/roundcubemail/commits/699af1e5206ed9114322adaa3c25c1c969640a53", "html_url": "https://github.com/roundcube/roundcubemail/commit/699af1e5206ed9114322adaa3c25c1c969640a53", "windows_before": "", "windows_after": "", "parents": [{"commit_id_before": "b01689caf8e372d40112eda0f14a84eed41389d5", "url_before": "https://api.github.com/repos/roundcube/roundcubemail/commits/b01689caf8e372d40112eda0f14a84eed41389d5", "html_url_before": "https://github.com/roundcube/roundcubemail/commit/b01689caf8e372d40112eda0f14a84eed41389d5"}], "details": [{"raw_url": "https://github.com/roundcube/roundcubemail/raw/699af1e5206ed9114322adaa3c25c1c969640a53/plugins/managesieve/lib/Roundcube/rcube_sieve_engine.php", "patch": "@@ -397,6 +397,8 @@ function actions()\n                 }\n             }\n             else if ($action == 'setget') {\n+                $this->rc->request_security_check(rcube_utils::INPUT_GET);\n+\n                 $script_name = rcube_utils::get_input_value('_set', rcube_utils::INPUT_GPC, true);\n                 $script      = $this->sieve->get_script($script_name);\n ", "file_path": "files/2016_8\\18", "file_language": "php", "file_name": "plugins/managesieve/lib/Roundcube/rcube_sieve_engine.php", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}, {"raw_url": "https://github.com/roundcube/roundcubemail/raw/699af1e5206ed9114322adaa3c25c1c969640a53/plugins/managesieve/managesieve.js", "patch": "@@ -181,7 +181,7 @@ rcube_webmail.prototype.managesieve_setget = function()\n   var id = this.filtersets_list.get_single_selection(),\n     script = this.env.filtersets[id];\n \n-  location.href = this.env.comm_path+'&_action=plugin.managesieve-action&_act=setget&_set='+urlencode(script);\n+  this.goto_url('plugin.managesieve-action', {_act: 'setget', _set: script}, false, true);\n };\n \n // Set activate/deactivate request", "file_path": "files/2016_8\\19", "file_language": "js", "file_name": "plugins/managesieve/managesieve.js", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}, {"raw_url": "https://github.com/roundcube/roundcubemail/raw/699af1e5206ed9114322adaa3c25c1c969640a53/plugins/zipdownload/zipdownload.js", "patch": "@@ -54,7 +54,7 @@ function rcmail_zipdownload(mode)\n     // default .eml download of single message\n     if (mode == 'eml') {\n         var uid = rcmail.get_single_uid();\n-        rcmail.goto_url('viewsource', rcmail.params_from_uid(uid, {_save: 1}));\n+        rcmail.goto_url('viewsource', rcmail.params_from_uid(uid, {_save: 1}), false, true);\n         return;\n     }\n ", "file_path": "files/2016_8\\20", "file_language": "js", "file_name": "plugins/zipdownload/zipdownload.js", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}, {"raw_url": "https://github.com/roundcube/roundcubemail/raw/699af1e5206ed9114322adaa3c25c1c969640a53/plugins/zipdownload/zipdownload.php", "patch": "@@ -63,7 +63,7 @@ public function attachment_ziplink($p)\n                 '_action' => 'plugin.zipdownload.attachments',\n                 '_mbox'   => $rcmail->output->env['mailbox'],\n                 '_uid'    => $rcmail->output->env['uid'],\n-            ));\n+            ), false, false, true);\n \n             $link = html::a(array('href' => $href, 'class' => 'button zipdownload'),\n                 rcube::Q($this->gettext('downloadall'))\n@@ -120,6 +120,10 @@ public function download_menu()\n     public function download_attachments()\n     {\n         $rcmail    = rcmail::get_instance();\n+\n+        // require CSRF protected request\n+        $rcmail->request_security_check(rcube_utils::INPUT_GET);\n+\n         $imap      = $rcmail->get_storage();\n         $temp_dir  = $rcmail->config->get('temp_dir');\n         $tmpfname  = tempnam($temp_dir, 'zipdownload');", "file_path": "files/2016_8\\21", "file_language": "php", "file_name": "plugins/zipdownload/zipdownload.php", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}, {"raw_url": "https://github.com/roundcube/roundcubemail/raw/699af1e5206ed9114322adaa3c25c1c969640a53/program/include/rcmail.php", "patch": "@@ -813,6 +813,8 @@ public function url($p, $absolute = false, $full = false, $secure = false)\n             // this need to be full url to make redirects work\n             $absolute = true;\n         }\n+        else if ($secure && ($token = $this->get_request_token()))\n+            $url .= $delm . '_token=' . urlencode($token);\n \n         if ($absolute || $full) {\n             // add base path to this Roundcube installation", "file_path": "files/2016_8\\22", "file_language": "php", "file_name": "program/include/rcmail.php", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}, {"raw_url": "https://github.com/roundcube/roundcubemail/raw/699af1e5206ed9114322adaa3c25c1c969640a53/program/include/rcmail_output_html.php", "patch": "@@ -514,10 +514,10 @@ public function write($template = '')\n         // write all javascript commands\n         $this->add_script($commands, 'head_top');\n \n-        // send clickjacking protection headers\n+        // allow (legal) iframe content to be loaded\n         $iframe = $this->framed || $this->env['framed'];\n-        if (!headers_sent() && ($xframe = $this->app->config->get('x_frame_options', 'sameorigin'))) {\n-            header('X-Frame-Options: ' . ($iframe && $xframe == 'deny' ? 'sameorigin' : $xframe));\n+        if (!headers_sent() && $iframe && $this->app->config->get('x_frame_options', 'sameorigin') === 'deny') {\n+            header('X-Frame-Options: sameorigin', true);\n         }\n \n         // call super method", "file_path": "files/2016_8\\23", "file_language": "php", "file_name": "program/include/rcmail_output_html.php", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}, {"raw_url": "https://github.com/roundcube/roundcubemail/raw/699af1e5206ed9114322adaa3c25c1c969640a53/program/js/app.js", "patch": "@@ -999,7 +999,7 @@ function rcube_webmail()\n             break;\n         }\n \n-        this.goto_url('get', qstring+'&_download=1', false);\n+        this.goto_url('get', qstring+'&_download=1', false, true);\n         break;\n \n       case 'select-all':\n@@ -1205,10 +1205,10 @@ function rcube_webmail()\n \n       case 'download':\n         if (this.env.action == 'get') {\n-          location.href = location.href.replace(/_frame=/, '_download=');\n+          location.href = this.secure_url(location.href.replace(/_frame=/, '_download='));\n         }\n         else if (uid = this.get_single_uid()) {\n-          this.goto_url('viewsource', this.params_from_uid(uid, {_save: 1}));\n+          this.goto_url('viewsource', this.params_from_uid(uid, {_save: 1}), false, true);\n         }\n         break;\n \n@@ -1296,13 +1296,13 @@ function rcube_webmail()\n \n       case 'export':\n         if (this.contact_list.rowcount > 0) {\n-          this.goto_url('export', { _source: this.env.source, _gid: this.env.group, _search: this.env.search_request });\n+          this.goto_url('export', { _source: this.env.source, _gid: this.env.group, _search: this.env.search_request }, false, true);\n         }\n         break;\n \n       case 'export-selected':\n         if (this.contact_list.rowcount > 0) {\n-          this.goto_url('export', { _source: this.env.source, _gid: this.env.group, _cid: this.contact_list.get_selection().join(',') });\n+          this.goto_url('export', { _source: this.env.source, _gid: this.env.group, _cid: this.contact_list.get_selection().join(',') }, false, true);\n         }\n         break;\n \n@@ -1417,7 +1417,7 @@ function rcube_webmail()\n     if (task == 'mail')\n       url += '&_mbox=INBOX';\n     else if (task == 'logout' && !this.env.server_error) {\n-      url += '&_token=' + this.env.request_token;\n+      url = this.secure_url(url);\n       this.clear_compose_data();\n     }\n \n@@ -1466,6 +1466,12 @@ function rcube_webmail()\n     return url + '?' + name + '=' + value;\n   };\n \n+  // append CSRF protection token to the given url\n+  this.secure_url = function(url)\n+  {\n+    return this.add_url(url, '_token', this.env.request_token);\n+  },\n+\n   this.is_framed = function()\n   {\n     return this.env.framed && parent.rcmail && parent.rcmail != this && typeof parent.rcmail.command == 'function';\n@@ -7282,9 +7288,11 @@ function rcube_webmail()\n     }\n   };\n \n-  this.goto_url = function(action, query, lock)\n+  this.goto_url = function(action, query, lock, secure)\n   {\n-    this.redirect(this.url(action, query), lock);\n+    var url = this.url(action, query)\n+    if (secure) url = this.secure_url(url);\n+    this.redirect(url, lock);\n   };\n \n   this.location_href = function(url, target, frame)", "file_path": "files/2016_8\\24", "file_language": "js", "file_name": "program/js/app.js", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}, {"raw_url": "https://github.com/roundcube/roundcubemail/raw/699af1e5206ed9114322adaa3c25c1c969640a53/program/lib/Roundcube/rcube_message.php", "patch": "@@ -105,10 +105,11 @@ function __construct($uid, $folder = null)\n         $this->opt = array(\n             'safe' => $this->is_safe,\n             'prefer_html' => $this->app->config->get('prefer_html'),\n-            'get_url' => $this->app->url(array(\n-                'action' => 'get',\n-                'mbox'   => $this->storage->get_folder(),\n-                'uid'    => $uid))\n+            'get_url'     => $this->app->url(array(\n+                    'action' => 'get',\n+                    'mbox'   => $this->storage->get_folder(),\n+                    'uid'    => $uid),\n+                false, false, true)\n         );\n \n         if (!empty($this->headers->structure)) {", "file_path": "files/2016_8\\25", "file_language": "php", "file_name": "program/lib/Roundcube/rcube_message.php", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}, {"raw_url": "https://github.com/roundcube/roundcubemail/raw/699af1e5206ed9114322adaa3c25c1c969640a53/program/lib/Roundcube/rcube_output.php", "patch": "@@ -190,6 +190,11 @@ public function common_headers()\n \n         // Request browser to disable DNS prefetching (CVE-2010-0464)\n         header(\"X-DNS-Prefetch-Control: off\");\n+\n+        // send CSRF and clickjacking protection headers\n+        if ($xframe = $this->app->config->get('x_frame_options', 'sameorigin')) {\n+            header('X-Frame-Options: ' . $xframe);\n+        }\n     }\n \n     /**", "file_path": "files/2016_8\\26", "file_language": "php", "file_name": "program/lib/Roundcube/rcube_output.php", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}, {"raw_url": "https://github.com/roundcube/roundcubemail/raw/699af1e5206ed9114322adaa3c25c1c969640a53/program/steps/addressbook/export.inc", "patch": "@@ -21,6 +21,8 @@\n  +-----------------------------------------------------------------------+\n */\n \n+$RCMAIL->request_security_check(rcube_utils::INPUT_GET);\n+\n // Use search result\n if (!empty($_REQUEST['_search']) && isset($_SESSION['search'][$_REQUEST['_search']])) {\n     $sort_col = $RCMAIL->config->get('addressbook_sort_col', 'name');", "file_path": "files/2016_8\\27", "file_language": "inc", "file_name": "program/steps/addressbook/export.inc", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}, {"raw_url": "https://github.com/roundcube/roundcubemail/raw/699af1e5206ed9114322adaa3c25c1c969640a53/program/steps/mail/get.inc", "patch": "@@ -131,6 +131,10 @@ else if (strlen($part_id)) {\n             exit;\n         }\n \n+        // require CSRF protected url for downloads\n+        if ($plugin['download'])\n+            $RCMAIL->request_security_check(rcube_utils::INPUT_GET);\n+\n         // overwrite modified vars from plugin\n         $mimetype   = $plugin['mimetype'];\n         $extensions = rcube_mime::get_mime_extensions($mimetype);", "file_path": "files/2016_8\\28", "file_language": "inc", "file_name": "program/steps/mail/get.inc", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}, {"raw_url": "https://github.com/roundcube/roundcubemail/raw/699af1e5206ed9114322adaa3c25c1c969640a53/program/steps/mail/viewsource.inc", "patch": "@@ -19,6 +19,10 @@\n  +-----------------------------------------------------------------------+\n */\n \n+if (!empty($_GET['_save'])) {\n+    $RCMAIL->request_security_check(rcube_utils::INPUT_GET);\n+}\n+\n ob_end_clean();\n \n // similar code as in program/steps/mail/get.inc", "file_path": "files/2016_8\\29", "file_language": "inc", "file_name": "program/steps/mail/viewsource.inc", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}], "outdated": 0}
{"index": 3, "cve_id": "CVE-2015-8949", "cwe_id": ["CWE-416"], "cve_language": "C", "cve_description": "Use-after-free vulnerability in the my_login function in DBD::mysql before 4.033_01 allows attackers to have unspecified impact by leveraging a call to mysql_errno after a failure of my_login.", "cvss": "9.8", "publish_date": "August 19, 2016", "AV": "NETWORK", "AC": "LOW", "PR": "NONE", "UI": "NONE", "S": "UNCHANGED", "C": "HIGH", "I": "HIGH", "A": "HIGH", "commit_id": "cf0aa7751f6ef8445e9310a64b14dc81460ca156", "commit_message": "Merge pull request #45 from hannob/master\n\nFix use after free error.", "commit_date": "2015-11-22T14:22:05Z", "project": "perl5-dbi/dbd-mysql", "url": "https://api.github.com/repos/perl5-dbi/DBD-mysql/commits/cf0aa7751f6ef8445e9310a64b14dc81460ca156", "html_url": "https://github.com/perl5-dbi/DBD-mysql/commit/cf0aa7751f6ef8445e9310a64b14dc81460ca156", "windows_before": "", "windows_after": "", "parents": [{"commit_id_before": "90a5ab519805acb6c5d1ae91d8e3f494ec179db4", "url_before": "https://api.github.com/repos/perl5-dbi/DBD-mysql/commits/90a5ab519805acb6c5d1ae91d8e3f494ec179db4", "html_url_before": "https://github.com/perl5-dbi/DBD-mysql/commit/90a5ab519805acb6c5d1ae91d8e3f494ec179db4"}, {"commit_id_before": "2e1cbd0034cf0041f832ba81d07c24db886782d8", "url_before": "https://api.github.com/repos/perl5-dbi/DBD-mysql/commits/2e1cbd0034cf0041f832ba81d07c24db886782d8", "html_url_before": "https://github.com/perl5-dbi/DBD-mysql/commit/2e1cbd0034cf0041f832ba81d07c24db886782d8"}], "details": [{"raw_url": "https://github.com/perl5-dbi/DBD-mysql/raw/cf0aa7751f6ef8445e9310a64b14dc81460ca156/dbdimp.c", "patch": "@@ -2085,10 +2085,6 @@ static int my_login(pTHX_ SV* dbh, imp_dbh_t *imp_dbh)\n   }\n   result = mysql_dr_connect(dbh, imp_dbh->pmysql, mysql_socket, host, port, user,\n \t\t\t  password, dbname, imp_dbh) ? TRUE : FALSE;\n-  if (fresh && !result) {\n-      /* Prevent leaks, but do not free in case of a reconnect. See #97625 */\n-      Safefree(imp_dbh->pmysql);\n-  }\n   return result;\n }\n \n@@ -2142,9 +2138,12 @@ int dbd_db_login(SV* dbh, imp_dbh_t* imp_dbh, char* dbname, char* user,\n \n   if (!my_login(aTHX_ dbh, imp_dbh))\n   {\n-    if(imp_dbh->pmysql)\n+    if(imp_dbh->pmysql) {\n         do_error(dbh, mysql_errno(imp_dbh->pmysql),\n                 mysql_error(imp_dbh->pmysql) ,mysql_sqlstate(imp_dbh->pmysql));\n+        Safefree(imp_dbh->pmysql);\n+\n+    }\n     return FALSE;\n   }\n ", "file_path": "files/2016_8\\30", "file_language": "c", "file_name": "dbdimp.c", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}], "outdated": 0}
{"index": 4, "cve_id": "CVE-2014-9906", "cwe_id": ["CWE-416"], "cve_language": "C", "cve_description": "Use-after-free vulnerability in DBD::mysql before 4.029 allows attackers to cause a denial of service (program crash) or possibly execute arbitrary code via vectors related to a lost server connection.", "cvss": "9.8", "publish_date": "August 19, 2016", "AV": "NETWORK", "AC": "LOW", "PR": "NONE", "UI": "NONE", "S": "UNCHANGED", "C": "HIGH", "I": "HIGH", "A": "HIGH", "commit_id": "a56ae87a4c1c1fead7d09c3653905841ccccf1cc", "commit_message": "fix use-after-free crash in RT #97625", "commit_date": "2014-09-09T15:14:17Z", "project": "perl5-dbi/dbd-mysql", "url": "https://api.github.com/repos/perl5-dbi/DBD-mysql/commits/a56ae87a4c1c1fead7d09c3653905841ccccf1cc", "html_url": "https://github.com/perl5-dbi/DBD-mysql/commit/a56ae87a4c1c1fead7d09c3653905841ccccf1cc", "windows_before": "", "windows_after": "", "parents": [{"commit_id_before": "3e09017a24367d04156fce07f3f48a5fdb8c5db8", "url_before": "https://api.github.com/repos/perl5-dbi/DBD-mysql/commits/3e09017a24367d04156fce07f3f48a5fdb8c5db8", "html_url_before": "https://github.com/perl5-dbi/DBD-mysql/commit/3e09017a24367d04156fce07f3f48a5fdb8c5db8"}], "details": [{"raw_url": "https://github.com/perl5-dbi/DBD-mysql/raw/a56ae87a4c1c1fead7d09c3653905841ccccf1cc/dbdimp.c", "patch": "@@ -1996,6 +1996,7 @@ static int my_login(pTHX_ SV* dbh, imp_dbh_t *imp_dbh)\n   char* password;\n   char* mysql_socket;\n   int   result;\n+  int\tfresh = 0;\n   D_imp_xxh(dbh);\n \n   /* TODO- resolve this so that it is set only if DBI is 1.607 */\n@@ -2044,12 +2045,18 @@ static int my_login(pTHX_ SV* dbh, imp_dbh_t *imp_dbh)\n \t\t  port ? port : \"NULL\");\n \n   if (!imp_dbh->pmysql) {\n+     fresh = 1;\n      Newz(908, imp_dbh->pmysql, 1, MYSQL);\n   }\n   result = mysql_dr_connect(dbh, imp_dbh->pmysql, mysql_socket, host, port, user,\n \t\t\t  password, dbname, imp_dbh) ? TRUE : FALSE;\n-  if (!result)\n+  if (fresh && !result) {\n+      /* Prevent leaks, but do not free in case of a reconnect. See #97625 */\n+      do_error(dbh, mysql_errno(imp_dbh->pmysql),\n+              mysql_error(imp_dbh->pmysql) ,mysql_sqlstate(imp_dbh->pmysql));\n       Safefree(imp_dbh->pmysql);\n+      imp_dbh->pmysql = NULL;\n+  }\n   return result;\n }\n \n@@ -2102,8 +2109,9 @@ int dbd_db_login(SV* dbh, imp_dbh_t* imp_dbh, char* dbname, char* user,\n \n   if (!my_login(aTHX_ dbh, imp_dbh))\n   {\n-    do_error(dbh, mysql_errno(imp_dbh->pmysql),\n-            mysql_error(imp_dbh->pmysql) ,mysql_sqlstate(imp_dbh->pmysql));\n+    if(imp_dbh->pmysql)\n+        do_error(dbh, mysql_errno(imp_dbh->pmysql),\n+                mysql_error(imp_dbh->pmysql) ,mysql_sqlstate(imp_dbh->pmysql));\n     return FALSE;\n   }\n ", "file_path": "files/2016_8\\31", "file_language": "c", "file_name": "dbdimp.c", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}], "outdated": 0}
{"index": 5, "cve_id": "CVE-2016-6319", "cwe_id": ["CWE-79"], "cve_language": "Ruby", "cve_description": "Cross-site scripting (XSS) vulnerability in app/helpers/form_helper.rb in Foreman before 1.12.2, as used by Remote Execution and possibly other plugins, allows remote attackers to inject arbitrary web script or HTML via the label parameter.", "cvss": "6.1", "publish_date": "August 19, 2016", "AV": "NETWORK", "AC": "LOW", "PR": "NONE", "UI": "REQUIRED", "S": "CHANGED", "C": "LOW", "I": "LOW", "A": "NONE", "commit_id": "0f35fe14acf0d0d3b55e9337bc5e2b9640ff2372", "commit_message": "Fixes #16024 - escape labels of form fields", "commit_date": "2016-08-10T10:26:59Z", "project": "theforeman/foreman", "url": "https://api.github.com/repos/theforeman/foreman/commits/0f35fe14acf0d0d3b55e9337bc5e2b9640ff2372", "html_url": "https://github.com/theforeman/foreman/commit/0f35fe14acf0d0d3b55e9337bc5e2b9640ff2372", "windows_before": "", "windows_after": "", "parents": [{"commit_id_before": "e2a57bfe537f7a5f1ef6aca7087df2f1fdea5905", "url_before": "https://api.github.com/repos/theforeman/foreman/commits/e2a57bfe537f7a5f1ef6aca7087df2f1fdea5905", "html_url_before": "https://github.com/theforeman/foreman/commit/e2a57bfe537f7a5f1ef6aca7087df2f1fdea5905"}], "details": [{"raw_url": "https://github.com/theforeman/foreman/raw/0f35fe14acf0d0d3b55e9337bc5e2b9640ff2372/app/helpers/form_helper.rb", "patch": "@@ -283,7 +283,7 @@ def add_label options, f, attr\n     label = options[:label] == :none ? '' : options.delete(:label)\n     label ||= ((clazz = f.object.class).respond_to?(:gettext_translation_for_attribute_name) &&\n         s_(clazz.gettext_translation_for_attribute_name attr)) if f\n-    label = label.present? ? label_tag(attr, \"#{label}#{required_mark}\".html_safe, :class => label_size + \" control-label\") : ''\n+    label = label.present? ? label_tag(attr, \"#{label}#{required_mark}\", :class => label_size + \" control-label\") : ''\n     label\n   end\n ", "file_path": "files/2016_8\\32", "file_language": "rb", "file_name": "app/helpers/form_helper.rb", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}], "outdated": 0}
{"index": 6, "cve_id": "CVE-2016-6254", "cwe_id": ["CWE-119"], "cve_language": "C", "cve_description": "Heap-based buffer overflow in the parse_packet function in network.c in collectd before 5.4.3 and 5.x before 5.5.2 allows remote attackers to cause a denial of service (daemon crash) or possibly execute arbitrary code via a crafted network packet.", "cvss": "9.1", "publish_date": "August 19, 2016", "AV": "NETWORK", "AC": "LOW", "PR": "NONE", "UI": "NONE", "S": "UNCHANGED", "C": "NONE", "I": "HIGH", "A": "HIGH", "commit_id": "b589096f907052b3a4da2b9ccc9b0e2e888dfc18", "commit_message": "network plugin: Fix heap overflow in parse_packet().\n\nEmilien Gaspar has identified a heap overflow in parse_packet(), the\nfunction used by the network plugin to parse incoming network packets.\n\nThis is a vulnerability in collectd, though the scope is not clear at\nthis point. At the very least specially crafted network packets can be\nused to crash the daemon. We can't rule out a potential remote code\nexecution though.\n\nFixes: CVE-2016-6254", "commit_date": "2016-07-21T05:47:37Z", "project": "collectd/collectd", "url": "https://api.github.com/repos/collectd/collectd/commits/b589096f907052b3a4da2b9ccc9b0e2e888dfc18", "html_url": "https://github.com/collectd/collectd/commit/b589096f907052b3a4da2b9ccc9b0e2e888dfc18", "windows_before": "", "windows_after": "", "parents": [{"commit_id_before": "4371ef7f98f6f51ea3df34d5e26e175d6b44a328", "url_before": "https://api.github.com/repos/collectd/collectd/commits/4371ef7f98f6f51ea3df34d5e26e175d6b44a328", "html_url_before": "https://github.com/collectd/collectd/commit/4371ef7f98f6f51ea3df34d5e26e175d6b44a328"}], "details": [{"raw_url": "https://github.com/collectd/collectd/raw/b589096f907052b3a4da2b9ccc9b0e2e888dfc18/src/network.c", "patch": "@@ -1435,6 +1435,7 @@ static int parse_packet (sockent_t *se, /* {{{ */\n \t\t\t\tprinted_ignore_warning = 1;\n \t\t\t}\n \t\t\tbuffer = ((char *) buffer) + pkg_length;\n+\t\t\tbuffer_size -= (size_t) pkg_length;\n \t\t\tcontinue;\n \t\t}\n #endif /* HAVE_LIBGCRYPT */\n@@ -1462,6 +1463,7 @@ static int parse_packet (sockent_t *se, /* {{{ */\n \t\t\t\tprinted_ignore_warning = 1;\n \t\t\t}\n \t\t\tbuffer = ((char *) buffer) + pkg_length;\n+\t\t\tbuffer_size -= (size_t) pkg_length;\n \t\t\tcontinue;\n \t\t}\n #endif /* HAVE_LIBGCRYPT */\n@@ -1603,6 +1605,7 @@ static int parse_packet (sockent_t *se, /* {{{ */\n \t\t\tDEBUG (\"network plugin: parse_packet: Unknown part\"\n \t\t\t\t\t\" type: 0x%04hx\", pkg_type);\n \t\t\tbuffer = ((char *) buffer) + pkg_length;\n+\t\t\tbuffer_size -= (size_t) pkg_length;\n \t\t}\n \t} /* while (buffer_size > sizeof (part_header_t)) */\n ", "file_path": "files/2016_8\\33", "file_language": "c", "file_name": "src/network.c", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}], "outdated": 0}
{"index": 7, "cve_id": "CVE-2016-6214", "cwe_id": ["CWE-125"], "cve_language": "C", "cve_description": "gd_tga.c in the GD Graphics Library (aka libgd) before 2.2.3 allows remote attackers to cause a denial of service (out-of-bounds read) via a crafted TGA file.", "cvss": "6.5", "publish_date": "August 12, 2016", "AV": "NETWORK", "AC": "LOW", "PR": "NONE", "UI": "REQUIRED", "S": "UNCHANGED", "C": "NONE", "I": "NONE", "A": "HIGH", "commit_id": "10ef1dca63d62433fda13309b4a228782db823f7", "commit_message": "Unsupported TGA bpp/alphabit combinations should error gracefully\n\nCurrently, only 24bpp without alphabits and 32bpp with 8 alphabits are\nreally supported. All other combinations will be rejected with a warning.", "commit_date": "2016-07-12T18:46:33Z", "project": "libgd/libgd", "url": "https://api.github.com/repos/libgd/libgd/commits/10ef1dca63d62433fda13309b4a228782db823f7", "html_url": "https://github.com/libgd/libgd/commit/10ef1dca63d62433fda13309b4a228782db823f7", "windows_before": "", "windows_after": "", "parents": [{"commit_id_before": "e6399f5a470f50285cef173e438638ae5bc741e0", "url_before": "https://api.github.com/repos/libgd/libgd/commits/e6399f5a470f50285cef173e438638ae5bc741e0", "html_url_before": "https://github.com/libgd/libgd/commit/e6399f5a470f50285cef173e438638ae5bc741e0"}], "details": [{"raw_url": "https://github.com/libgd/libgd/raw/10ef1dca63d62433fda13309b4a228782db823f7/src/gd_tga.c", "patch": "@@ -99,7 +99,7 @@ BGD_DECLARE(gdImagePtr) gdImageCreateFromTgaCtx(gdIOCtx* ctx)\n \t\t\tif (tga->bits == TGA_BPP_24) {\n \t\t\t\t*tpix = gdTrueColor(tga->bitmap[bitmap_caret + 2], tga->bitmap[bitmap_caret + 1], tga->bitmap[bitmap_caret]);\n \t\t\t\tbitmap_caret += 3;\n-\t\t\t} else if (tga->bits == TGA_BPP_32 || tga->alphabits) {\n+\t\t\t} else if (tga->bits == TGA_BPP_32 && tga->alphabits) {\n \t\t\t\tregister int a = tga->bitmap[bitmap_caret + 3];\n \n \t\t\t\t*tpix = gdTrueColorAlpha(tga->bitmap[bitmap_caret + 2], tga->bitmap[bitmap_caret + 1], tga->bitmap[bitmap_caret], gdAlphaMax - (a >> 1));\n@@ -159,16 +159,12 @@ int read_header_tga(gdIOCtx *ctx, oTga *tga)\n \tprintf(\"wxh: %i %i\\n\", tga->width, tga->height);\n #endif\n \n-\tswitch(tga->bits) {\n-\tcase 8:\n-\tcase 16:\n-\tcase 24:\n-\tcase 32:\n-\t\tbreak;\n-\tdefault:\n-\t\tgd_error(\"bps %i not supported\", tga->bits);\n+\tif (!((tga->bits == TGA_BPP_24 && tga->alphabits == 0)\n+\t\t|| (tga->bits == TGA_BPP_32 && tga->alphabits == 8)))\n+\t{\n+\t\tgd_error_ex(GD_WARNING, \"gd-tga: %u bits per pixel with %u alpha bits not supported\\n\",\n+\t\t\ttga->bits, tga->alphabits);\n \t\treturn -1;\n-\t\tbreak;\n \t}\n \n \ttga->ident = NULL;", "file_path": "files/2016_8\\34", "file_language": "c", "file_name": "src/gd_tga.c", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}, {"raw_url": "https://github.com/libgd/libgd/raw/10ef1dca63d62433fda13309b4a228782db823f7/tests/tga/.gitignore", "patch": "@@ -1,3 +1,4 @@\n /bug00084\n /bug00247\n+/bug00247a\n /tga_null", "file_path": "files/2016_8\\35", "file_language": "gitignore", "file_name": "tests/tga/.gitignore", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}, {"raw_url": "https://github.com/libgd/libgd/raw/10ef1dca63d62433fda13309b4a228782db823f7/tests/tga/CMakeLists.txt", "patch": "@@ -2,6 +2,7 @@ LIST(APPEND TESTS_FILES\n \ttga_null\n \tbug00084\n \tbug00247\n+\tbug00247a\n )\n \n ADD_GD_TESTS()", "file_path": "files/2016_8\\36", "file_language": "txt", "file_name": "tests/tga/CMakeLists.txt", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}, {"raw_url": "https://github.com/libgd/libgd/raw/10ef1dca63d62433fda13309b4a228782db823f7/tests/tga/Makemodule.am", "patch": "@@ -1,9 +1,11 @@\n libgd_test_programs += \\\n \ttga/bug00084 \\\n \ttga/bug00247 \\\n+\ttag/bug00247a \\\n \ttga/tga_null\n \n EXTRA_DIST += \\\n \ttga/CMakeLists.txt \\\n \ttga/bug00084.tga \\\n-\ttga/bug00247.tga\n+\ttga/bug00247.tga \\\n+\ttga/bug00247a.tga", "file_path": "files/2016_8\\37", "file_language": "am", "file_name": "tests/tga/Makemodule.am", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}, {"raw_url": "https://github.com/libgd/libgd/raw/10ef1dca63d62433fda13309b4a228782db823f7/tests/tga/bug00247a.c", "patch": "@@ -0,0 +1,19 @@\n+/*\n+We test that a 8bpp TGA file will be gracefully rejected by\n+gdImageCreateFromTga().\n+*/\n+\n+#include <stdio.h>\n+\n+#include \"gd.h\"\n+#include \"gdtest.h\"\n+\n+int main(int argc, char **argv)\n+{\n+    gdImagePtr im;\n+    FILE *fp = gdTestFileOpen(\"tga/bug00247a.tga\");\n+    im = gdImageCreateFromTga(fp);\n+    gdTestAssert(im == NULL);\n+    fclose(fp);\n+    return gdNumFailures();\n+}", "file_path": "files/2016_8\\38", "file_language": "c", "file_name": "tests/tga/bug00247a.c", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}], "outdated": 0}
{"index": 8, "cve_id": "CVE-2016-5351", "cwe_id": ["CWE-20"], "cve_language": "C", "cve_description": "epan/crypt/airpdcap.c in the IEEE 802.11 dissector in Wireshark 1.12.x before 1.12.12 and 2.x before 2.0.4 mishandles the lack of an EAPOL_RSN_KEY, which allows remote attackers to cause a denial of service (application crash) via a crafted packet.", "cvss": "5.9", "publish_date": "August 7, 2016", "AV": "NETWORK", "AC": "HIGH", "PR": "NONE", "UI": "NONE", "S": "UNCHANGED", "C": "NONE", "I": "NONE", "A": "HIGH", "commit_id": "9b0b20b8d5f8c9f7839d58ff6c5900f7e19283b4", "commit_message": "Make sure EAPOL body is big enough for a EAPOL_RSN_KEY.\n\nA pointer to a EAPOL_RSN_KEY is set on the packet presuming the\nwhole EAPOL_RSN_KEY is there.  That's not always the case for\nfuzzed/malicious captures.\n\nBug: 11585\nChange-Id: Ib94b8aceef444c7820e43b969596efdb8dbecccd\nReviewed-on: https://code.wireshark.org/review/15540\nReviewed-by: Michael Mann <mmann78@netscape.net>\nPetri-Dish: Michael Mann <mmann78@netscape.net>\nTested-by: Petri Dish Buildbot <buildbot-no-reply@wireshark.org>\nReviewed-by: Anders Broman <a.broman58@gmail.com>", "commit_date": "2016-05-23T08:04:46Z", "project": "wireshark/wireshark", "url": "https://api.github.com/repos/wireshark/wireshark/commits/9b0b20b8d5f8c9f7839d58ff6c5900f7e19283b4", "html_url": "https://github.com/wireshark/wireshark/commit/9b0b20b8d5f8c9f7839d58ff6c5900f7e19283b4", "windows_before": "", "windows_after": "", "parents": [{"commit_id_before": "b831f251eff85c7cc32085bde5bc789f848a301f", "url_before": "https://api.github.com/repos/wireshark/wireshark/commits/b831f251eff85c7cc32085bde5bc789f848a301f", "html_url_before": "https://github.com/wireshark/wireshark/commit/b831f251eff85c7cc32085bde5bc789f848a301f"}], "details": [{"raw_url": "https://github.com/wireshark/wireshark/raw/9b0b20b8d5f8c9f7839d58ff6c5900f7e19283b4/epan/crypt/airpdcap.c", "patch": "@@ -571,7 +571,7 @@ static INT AirPDcapScanForKeys(\n \n         /* get and check the body length (IEEE 802.1X-2004, pg. 25) */\n         bodyLength=pntoh16(data+offset+2);\n-        if ((tot_len-offset-4) < bodyLength) { /* Only check if frame is long enough for eapol header, ignore tailing garbage, see bug 9065 */\n+        if (((tot_len-offset-4) < bodyLength) || (bodyLength < sizeof(EAPOL_RSN_KEY))) { /* Only check if frame is long enough for eapol header, ignore tailing garbage, see bug 9065 */\n             AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"EAPOL body too short\", AIRPDCAP_DEBUG_LEVEL_3);\n             return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n         }", "file_path": "files/2016_8\\40", "file_language": "c", "file_name": "epan/crypt/airpdcap.c", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}], "outdated": 0}
{"index": 9, "cve_id": "CVE-2016-5353", "cwe_id": ["CWE-20"], "cve_language": "C", "cve_description": "epan/dissectors/packet-umts_fp.c in the UMTS FP dissector in Wireshark 1.12.x before 1.12.12 and 2.x before 2.0.4 mishandles the reserved C/T value, which allows remote attackers to cause a denial of service (application crash) via a crafted packet.", "cvss": "5.9", "publish_date": "August 7, 2016", "AV": "NETWORK", "AC": "HIGH", "PR": "NONE", "UI": "NONE", "S": "UNCHANGED", "C": "NONE", "I": "NONE", "A": "HIGH", "commit_id": "7d7190695ce2ff269fdffb04e87139995cde21f4", "commit_message": "UMTS_FP: fix handling reserved C/T value\n\nThe spec puts the reserved value at 0xf but our internal table has 'unknown' at\n0; since all the other values seem to be offset-by-one, just take the modulus\n0xf to avoid running off the end of the table.\n\nBug: 12191\nChange-Id: I83c8fb66797bbdee52a2246fb1eea6e37cbc7eb0\nReviewed-on: https://code.wireshark.org/review/15722\nReviewed-by: Evan Huus <eapache@gmail.com>\nPetri-Dish: Evan Huus <eapache@gmail.com>\nTested-by: Petri Dish Buildbot <buildbot-no-reply@wireshark.org>\nReviewed-by: Michael Mann <mmann78@netscape.net>", "commit_date": "2016-06-05T02:39:31Z", "project": "wireshark/wireshark", "url": "https://api.github.com/repos/wireshark/wireshark/commits/7d7190695ce2ff269fdffb04e87139995cde21f4", "html_url": "https://github.com/wireshark/wireshark/commit/7d7190695ce2ff269fdffb04e87139995cde21f4", "windows_before": "", "windows_after": "", "parents": [{"commit_id_before": "b84b3f9f1d8577255a9d83c81277ebc53bcac68d", "url_before": "https://api.github.com/repos/wireshark/wireshark/commits/b84b3f9f1d8577255a9d83c81277ebc53bcac68d", "html_url_before": "https://github.com/wireshark/wireshark/commit/b84b3f9f1d8577255a9d83c81277ebc53bcac68d"}], "details": [{"raw_url": "https://github.com/wireshark/wireshark/raw/7d7190695ce2ff269fdffb04e87139995cde21f4/epan/dissectors/packet-umts_fp.c", "patch": "@@ -4098,11 +4098,11 @@ fp_set_per_packet_inf_from_conv(umts_fp_conversation_info_t *p_conv_data,\n \n                                 /* Peek at C/T, different RLC params for different logical channels */\n                                 /*C/T is 4 bits according to 3GPP TS 25.321, paragraph 9.2.1, from MAC header (not FP)*/\n-                                c_t = tvb_get_bits8(tvb, tb_bit_off/*(2+p_conv_data->num_dch_in_flow)*8*/, 4);    /* c_t = tvb_get_guint8(tvb, offset);*/\n-                                macinf->lchid[j+chan] = c_t+1;\n+                                c_t = (tvb_get_bits8(tvb, tb_bit_off/*(2+p_conv_data->num_dch_in_flow)*8*/, 4) + 1) % 0xf;    /* c_t = tvb_get_guint8(tvb, offset);*/\n+                                macinf->lchid[j+chan] = c_t;\n \n-                                macinf->content[j+chan] = lchId_type_table[c_t+1];    /*Base MAC content on logical channel id (Table is in packet-nbap.h)*/\n-                                rlcinf->mode[j+chan] = lchId_rlc_map[c_t+1];    /*Based RLC mode on logical channel id*/\n+                                macinf->content[j+chan] = lchId_type_table[c_t];    /*Base MAC content on logical channel id (Table is in packet-nbap.h)*/\n+                                rlcinf->mode[j+chan] = lchId_rlc_map[c_t];    /*Based RLC mode on logical channel id*/\n                             }\n                         } else {\n                             fake_lchid = make_fake_lchid(pinfo, p_conv_data->dchs_in_flow_list[chan]);", "file_path": "files/2016_8\\41", "file_language": "c", "file_name": "epan/dissectors/packet-umts_fp.c", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}], "outdated": 0}
{"index": 10, "cve_id": "CVE-2016-6635", "cwe_id": ["CWE-352"], "cve_language": "PHP", "cve_description": "Cross-site request forgery (CSRF) vulnerability in the wp_ajax_wp_compression_test function in wp-admin/includes/ajax-actions.php in WordPress before 4.5 allows remote attackers to hijack the authentication of administrators for requests that change the script compression option.", "cvss": "8.8", "publish_date": "August 7, 2016", "AV": "NETWORK", "AC": "LOW", "PR": "NONE", "UI": "REQUIRED", "S": "UNCHANGED", "C": "HIGH", "I": "HIGH", "A": "HIGH", "commit_id": "9b7a7754133c50b82bd9d976fb5b24094f658aab", "commit_message": "Add nonce to AJAX action for script compression setting\n\nBuilt from https://develop.svn.wordpress.org/trunk@37143\n\n\ngit-svn-id: http://core.svn.wordpress.org/trunk@37110 1a063a9b-81f0-0310-95a4-ce76da25c4cd", "commit_date": "2016-03-30T18:21:25Z", "project": "wordpress/wordpress", "url": "https://api.github.com/repos/WordPress/WordPress/commits/9b7a7754133c50b82bd9d976fb5b24094f658aab", "html_url": "https://github.com/WordPress/WordPress/commit/9b7a7754133c50b82bd9d976fb5b24094f658aab", "windows_before": "", "windows_after": "", "parents": [{"commit_id_before": "db47a4913ca550da030439b6d14169671ff20cc2", "url_before": "https://api.github.com/repos/WordPress/WordPress/commits/db47a4913ca550da030439b6d14169671ff20cc2", "html_url_before": "https://github.com/WordPress/WordPress/commit/db47a4913ca550da030439b6d14169671ff20cc2"}], "details": [{"raw_url": "https://github.com/WordPress/WordPress/raw/9b7a7754133c50b82bd9d976fb5b24094f658aab/wp-admin/includes/ajax-actions.php", "patch": "@@ -197,8 +197,10 @@ function wp_ajax_wp_compression_test() {\n \t\t\techo $out;\n \t\t\twp_die();\n \t\t} elseif ( 'no' == $_GET['test'] ) {\n+\t\t\tcheck_ajax_referer( 'update_can_compress_scripts' );\n \t\t\tupdate_site_option('can_compress_scripts', 0);\n \t\t} elseif ( 'yes' == $_GET['test'] ) {\n+\t\t\tcheck_ajax_referer( 'update_can_compress_scripts' );\n \t\t\tupdate_site_option('can_compress_scripts', 1);\n \t\t}\n \t}", "file_path": "files/2016_8\\42", "file_language": "php", "file_name": "wp-admin/includes/ajax-actions.php", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}, {"raw_url": "https://github.com/WordPress/WordPress/raw/9b7a7754133c50b82bd9d976fb5b24094f658aab/wp-admin/includes/template.php", "patch": "@@ -1789,6 +1789,7 @@ function _media_states( $post ) {\n function compression_test() {\n ?>\n \t<script type=\"text/javascript\">\n+\tvar compressionNonce = <?php echo wp_json_encode( wp_create_nonce( 'update_can_compress_scripts' ) ); ?>;\n \tvar testCompression = {\n \t\tget : function(test) {\n \t\t\tvar x;\n@@ -1808,7 +1809,7 @@ function compression_test() {\n \t\t\t\t\t}\n \t\t\t\t};\n \n-\t\t\t\tx.open('GET', ajaxurl + '?action=wp-compression-test&test='+test+'&'+(new Date()).getTime(), true);\n+\t\t\t\tx.open('GET', ajaxurl + '?action=wp-compression-test&test='+test+'&_ajax_nonce='+compressionNonce+'&'+(new Date()).getTime(), true);\n \t\t\t\tx.send('');\n \t\t\t}\n \t\t},", "file_path": "files/2016_8\\43", "file_language": "php", "file_name": "wp-admin/includes/template.php", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}, {"raw_url": "https://github.com/WordPress/WordPress/raw/9b7a7754133c50b82bd9d976fb5b24094f658aab/wp-includes/version.php", "patch": "@@ -4,7 +4,7 @@\n  *\n  * @global string $wp_version\n  */\n-$wp_version = '4.5-RC1-37135';\n+$wp_version = '4.5-RC1-37143';\n \n /**\n  * Holds the WordPress DB revision, increments when changes are made to the WordPress DB schema.", "file_path": "files/2016_8\\44", "file_language": "php", "file_name": "wp-includes/version.php", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}], "outdated": 0}
{"index": 11, "cve_id": "CVE-2016-5359", "cwe_id": ["CWE-119", "CWE-399"], "cve_language": "C", "cve_description": "epan/dissectors/packet-wbxml.c in the WBXML dissector in Wireshark 1.12.x before 1.12.12 mishandles offsets, which allows remote attackers to cause a denial of service (integer overflow and infinite loop) via a crafted packet.", "cvss": "5.9", "publish_date": "August 7, 2016", "AV": "NETWORK", "AC": "HIGH", "PR": "NONE", "UI": "NONE", "S": "UNCHANGED", "C": "NONE", "I": "NONE", "A": "HIGH", "commit_id": "b8e0d416898bb975a02c1b55883342edc5b4c9c0", "commit_message": "WBXML: add a basic sanity check for offset overflow\n\nThis is a naive approach allowing to detact that something went wrong,\nwithout the need to replace all proto_tree_add_text() calls as what was\ndone in master-2.0 branch.\n\nBug: 12408\nChange-Id: Ia14905005e17ae322c2fc639ad5e491fa08b0108\nReviewed-on: https://code.wireshark.org/review/15310\nReviewed-by: Michael Mann <mmann78@netscape.net>\nReviewed-by: Pascal Quantin <pascal.quantin@gmail.com>", "commit_date": "2016-05-10T08:42:16Z", "project": "wireshark/wireshark", "url": "https://api.github.com/repos/wireshark/wireshark/commits/b8e0d416898bb975a02c1b55883342edc5b4c9c0", "html_url": "https://github.com/wireshark/wireshark/commit/b8e0d416898bb975a02c1b55883342edc5b4c9c0", "windows_before": "", "windows_after": "", "parents": [{"commit_id_before": "0a8a44cea3db67962770d616cfed9f6aa66b662c", "url_before": "https://api.github.com/repos/wireshark/wireshark/commits/0a8a44cea3db67962770d616cfed9f6aa66b662c", "html_url_before": "https://github.com/wireshark/wireshark/commit/0a8a44cea3db67962770d616cfed9f6aa66b662c"}], "details": [{"raw_url": "https://github.com/wireshark/wireshark/raw/b8e0d416898bb975a02c1b55883342edc5b4c9c0/epan/dissectors/packet-wbxml.c", "patch": "@@ -7304,7 +7304,7 @@ parse_wbxml_tag_defined (proto_tree *tree, tvbuff_t *tvb, guint32 offset,\n \t\t\t const wbxml_decoding *map)\n {\n \tguint32     tvb_len  = tvb_reported_length (tvb);\n-\tguint32     off      = offset;\n+\tguint32     off      = offset, last_off;\n \tguint32     len;\n \tguint       str_len;\n \tguint32     ent;\n@@ -7323,6 +7323,7 @@ parse_wbxml_tag_defined (proto_tree *tree, tvbuff_t *tvb, guint32 offset,\n \ttag_save_literal = NULL;                 /* Prevents compiler warning */\n \n \tDebugLog((\"parse_wbxml_tag_defined (level = %u, offset = %u)\\n\", *level, offset));\n+\tlast_off = off;\n \twhile (off < tvb_len) {\n \t\tpeek = tvb_get_guint8 (tvb, off);\n \t\tDebugLog((\"STAG: (top of while) level = %3u, peek = 0x%02X, off = %u, tvb_len = %u\\n\", *level, peek, off, tvb_len));\n@@ -7694,6 +7695,10 @@ parse_wbxml_tag_defined (proto_tree *tree, tvbuff_t *tvb, guint32 offset,\n \t\t\t\t/* TODO: Do I have to reset code page here? */\n \t\t\t}\n \t\t} /* if (tag & 0x3F) >= 5 */\n+\t\tif (off < last_off) {\n+\t\t\tTHROW(ReportedBoundsError);\n+\t\t}\n+\t\tlast_off = off;\n \t} /* while */\n \tDebugLog((\"STAG: level = %u, Return: len = %u (end of function body)\\n\", *level, off - offset));\n \treturn (off - offset);\n@@ -7711,7 +7716,7 @@ parse_wbxml_tag (proto_tree *tree, tvbuff_t *tvb, guint32 offset,\n \t\t guint8 *codepage_stag, guint8 *codepage_attr)\n {\n \tguint32     tvb_len             = tvb_reported_length (tvb);\n-\tguint32     off                 = offset;\n+\tguint32     off                 = offset, last_off;\n \tguint32     len;\n \tguint       str_len;\n \tguint32     ent;\n@@ -7732,6 +7737,7 @@ parse_wbxml_tag (proto_tree *tree, tvbuff_t *tvb, guint32 offset,\n \ttag_save_literal = NULL;                 /* Prevents compiler warning */\n \n \tDebugLog((\"parse_wbxml_tag (level = %u, offset = %u)\\n\", *level, offset));\n+\tlast_off = off;\n \twhile (off < tvb_len) {\n \t\tpeek = tvb_get_guint8 (tvb, off);\n \t\tDebugLog((\"STAG: (top of while) level = %3u, peek = 0x%02X, off = %u, tvb_len = %u\\n\", *level, peek, off, tvb_len));\n@@ -8091,6 +8097,10 @@ parse_wbxml_tag (proto_tree *tree, tvbuff_t *tvb, guint32 offset,\n \t\t\t\t/* TODO: Do I have to reset code page here? */\n \t\t\t}\n \t\t} /* if (tag & 0x3F) >= 5 */\n+\t\tif (off < last_off) {\n+\t\t\tTHROW(ReportedBoundsError);\n+\t\t}\n+\t\tlast_off = off;\n \t} /* while */\n \tDebugLog((\"STAG: level = %u, Return: len = %u (end of function body)\\n\",\n \t\t  *level, off - offset));\n@@ -8126,7 +8136,7 @@ parse_wbxml_attribute_list_defined (proto_tree *tree, tvbuff_t *tvb,\n \t\t\t\t    const wbxml_decoding *map)\n {\n \tguint32     tvb_len = tvb_reported_length (tvb);\n-\tguint32     off     = offset;\n+\tguint32     off     = offset, last_off;\n \tguint32     len;\n \tguint       str_len;\n \tguint32     ent;\n@@ -8138,6 +8148,7 @@ parse_wbxml_attribute_list_defined (proto_tree *tree, tvbuff_t *tvb,\n \tDebugLog((\"parse_wbxml_attr_defined (level = %u, offset = %u)\\n\",\n \t\t  level, offset));\n \t/* Parse attributes */\n+\tlast_off = off;\n \twhile (off < tvb_len) {\n \t\tpeek = tvb_get_guint8 (tvb, off);\n \t\tDebugLog((\"ATTR: (top of while) level = %3u, peek = 0x%02X, \"\n@@ -8330,6 +8341,10 @@ parse_wbxml_attribute_list_defined (proto_tree *tree, tvbuff_t *tvb,\n \t\t\t\toff++;\n \t\t\t}\n \t\t}\n+\t\tif (off < last_off) {\n+\t\t\tTHROW(ReportedBoundsError);\n+\t\t}\n+\t\tlast_off = off;\n \t} /* End WHILE */\n \tDebugLog((\"ATTR: level = %u, Return: len = %u (end of function body)\\n\",\n \t\t  level, off - offset));\n@@ -8350,7 +8365,7 @@ parse_wbxml_attribute_list (proto_tree *tree, tvbuff_t *tvb,\n \t\t\t    guint32 offset, guint32 str_tbl, guint8 level, guint8 *codepage_attr)\n {\n \tguint32 tvb_len = tvb_reported_length (tvb);\n-\tguint32 off     = offset;\n+\tguint32 off     = offset, last_off;\n \tguint32 len;\n \tguint   str_len;\n \tguint32 ent;\n@@ -8359,6 +8374,7 @@ parse_wbxml_attribute_list (proto_tree *tree, tvbuff_t *tvb,\n \n \tDebugLog((\"parse_wbxml_attr (level = %u, offset = %u)\\n\", level, offset));\n \t/* Parse attributes */\n+\tlast_off = off;\n \twhile (off < tvb_len) {\n \t\tpeek = tvb_get_guint8 (tvb, off);\n \t\tDebugLog((\"ATTR: (top of while) level = %3u, peek = 0x%02X, \"\n@@ -8516,6 +8532,10 @@ parse_wbxml_attribute_list (proto_tree *tree, tvbuff_t *tvb,\n \t\t\t\toff++;\n \t\t\t}\n \t\t}\n+\t\tif (off < last_off) {\n+\t\t\tTHROW(ReportedBoundsError);\n+\t\t}\n+\t\tlast_off = off;\n \t} /* End WHILE */\n \tDebugLog((\"ATTR: level = %u, Return: len = %u (end of function body)\\n\",\n \t\t  level, off - offset));", "file_path": "files/2016_8\\45", "file_language": "c", "file_name": "epan/dissectors/packet-wbxml.c", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}], "outdated": 0}
{"index": 12, "cve_id": "CVE-2016-5350", "cwe_id": ["CWE-399"], "cve_language": "C", "cve_description": "epan/dissectors/packet-dcerpc-spoolss.c in the SPOOLS component in Wireshark 1.12.x before 1.12.12 and 2.x before 2.0.4 mishandles unexpected offsets, which allows remote attackers to cause a denial of service (infinite loop) via a crafted packet.", "cvss": "7.5", "publish_date": "August 7, 2016", "AV": "NETWORK", "AC": "LOW", "PR": "NONE", "UI": "NONE", "S": "UNCHANGED", "C": "NONE", "I": "NONE", "A": "HIGH", "commit_id": "b4d16b4495b732888e12baf5b8a7e9bf2665e22b", "commit_message": "SPOOLSS: Try to avoid an infinite loop.\n\nUse tvb_reported_length_remaining in dissect_spoolss_uint16uni. Make\nsure our offset always increments in dissect_spoolss_keybuffer.\n\nChange-Id: I7017c9685bb2fa27161d80a03b8fca4ef630e793\nReviewed-on: https://code.wireshark.org/review/14687\nReviewed-by: Gerald Combs <gerald@wireshark.org>\nPetri-Dish: Gerald Combs <gerald@wireshark.org>\nTested-by: Petri Dish Buildbot <buildbot-no-reply@wireshark.org>\nReviewed-by: Michael Mann <mmann78@netscape.net>", "commit_date": "2016-03-30T18:17:07Z", "project": "wireshark/wireshark", "url": "https://api.github.com/repos/wireshark/wireshark/commits/b4d16b4495b732888e12baf5b8a7e9bf2665e22b", "html_url": "https://github.com/wireshark/wireshark/commit/b4d16b4495b732888e12baf5b8a7e9bf2665e22b", "windows_before": "", "windows_after": "", "parents": [{"commit_id_before": "782191f7662c2cd2849524ba279aad0aafcba4de", "url_before": "https://api.github.com/repos/wireshark/wireshark/commits/782191f7662c2cd2849524ba279aad0aafcba4de", "html_url_before": "https://github.com/wireshark/wireshark/commit/782191f7662c2cd2849524ba279aad0aafcba4de"}], "details": [{"raw_url": "https://github.com/wireshark/wireshark/raw/b4d16b4495b732888e12baf5b8a7e9bf2665e22b/epan/dissectors/packet-dcerpc-spoolss.c", "patch": "@@ -1090,7 +1090,7 @@ dissect_spoolss_uint16uni(tvbuff_t *tvb, int offset, packet_info *pinfo _U_,\n \n \t/* Get remaining data in buffer as a string */\n \n-\tremaining = tvb_captured_length_remaining(tvb, offset);\n+\tremaining = tvb_reported_length_remaining(tvb, offset);\n \tif (remaining <= 0) {\n \t\tif (data)\n \t\t\t*data = g_strdup(\"\");\n@@ -6198,9 +6198,10 @@ dissect_spoolss_keybuffer(tvbuff_t *tvb, int offset, packet_info *pinfo,\n \t\tend_offset = tvb_reported_length_remaining(tvb, offset) + 1;\n \t}\n \n-\twhile (offset < end_offset)\n+\twhile (offset > 0 && offset < end_offset) {\n \t\toffset = dissect_spoolss_uint16uni(\n \t\t\ttvb, offset, pinfo, tree, drep, NULL, hf_keybuffer);\n+\t}\n \n \treturn offset;\n }", "file_path": "files/2016_8\\46", "file_language": "c", "file_name": "epan/dissectors/packet-dcerpc-spoolss.c", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}], "outdated": 0}
{"index": 13, "cve_id": "CVE-2016-5354", "cwe_id": ["CWE-476"], "cve_language": "C", "cve_description": "The USB subsystem in Wireshark 1.12.x before 1.12.12 and 2.x before 2.0.4 mishandles class types, which allows remote attackers to cause a denial of service (application crash) via a crafted packet.", "cvss": "5.9", "publish_date": "August 7, 2016", "AV": "NETWORK", "AC": "HIGH", "PR": "NONE", "UI": "NONE", "S": "UNCHANGED", "C": "NONE", "I": "NONE", "A": "HIGH", "commit_id": "2cb5985bf47bdc8bea78d28483ed224abdd33dc6", "commit_message": "Make class \"type\" for USB conversations.\n\nUSB dissectors can't assume that only their class type has been passed around in the conversation.  Make explicit check that class type expected matches the dissector and stop/prevent dissection if there isn't a match.\n\nBug: 12356\nChange-Id: Ib23973a4ebd0fbb51952ffc118daf95e3389a209\nReviewed-on: https://code.wireshark.org/review/15212\nPetri-Dish: Michael Mann <mmann78@netscape.net>\nReviewed-by: Martin Kaiser <wireshark@kaiser.cx>\nPetri-Dish: Martin Kaiser <wireshark@kaiser.cx>\nTested-by: Petri Dish Buildbot <buildbot-no-reply@wireshark.org>\nReviewed-by: Michael Mann <mmann78@netscape.net>", "commit_date": "2016-05-01T20:16:15Z", "project": "wireshark/wireshark", "url": "https://api.github.com/repos/wireshark/wireshark/commits/2cb5985bf47bdc8bea78d28483ed224abdd33dc6", "html_url": "https://github.com/wireshark/wireshark/commit/2cb5985bf47bdc8bea78d28483ed224abdd33dc6", "windows_before": "", "windows_after": "", "parents": [{"commit_id_before": "7c79da8c30e39aecb1cddab39f537d8f6a1da25f", "url_before": "https://api.github.com/repos/wireshark/wireshark/commits/7c79da8c30e39aecb1cddab39f537d8f6a1da25f", "html_url_before": "https://github.com/wireshark/wireshark/commit/7c79da8c30e39aecb1cddab39f537d8f6a1da25f"}], "details": [{"raw_url": "https://github.com/wireshark/wireshark/raw/2cb5985bf47bdc8bea78d28483ed224abdd33dc6/epan/dissectors/packet-u3v.c", "patch": "@@ -1683,6 +1683,10 @@ dissect_u3v(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)\n     if (!u3v_conv_info) {\n         u3v_conv_info = wmem_new0(wmem_file_scope(), u3v_conv_info_t);\n         usb_conv_info->class_data = u3v_conv_info;\n+        usb_conv_info->class_data_type = USB_CONV_U3V;\n+    } else if (usb_conv_info->class_data_type != USB_CONV_U3V) {\n+        /* Don't dissect if another USB type is in the conversation */\n+        return 0;\n     }\n \n     prefix = tvb_get_letohl(tvb, 0);", "file_path": "files/2016_8\\47", "file_language": "c", "file_name": "epan/dissectors/packet-u3v.c", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}, {"raw_url": "https://github.com/wireshark/wireshark/raw/2cb5985bf47bdc8bea78d28483ed224abdd33dc6/epan/dissectors/packet-usb-audio.c", "patch": "@@ -435,8 +435,12 @@ dissect_ac_if_hdr_body(tvbuff_t *tvb, gint offset, packet_info *pinfo _U_,\n     if(!audio_conv_info) {\n         audio_conv_info = wmem_new(wmem_file_scope(), audio_conv_info_t);\n         usb_conv_info->class_data = audio_conv_info;\n+        usb_conv_info->class_data_type = USB_CONV_AUDIO;\n         /* XXX - set reasonable default values for all components\n            that are not filled in by this function */\n+    } else if (usb_conv_info->class_data_type != USB_CONV_AUDIO) {\n+        /* Don't dissect if another USB type is in the conversation */\n+        return 0;\n     }\n     audio_conv_info->ver_major = ver_major;\n     offset += 2;", "file_path": "files/2016_8\\48", "file_language": "c", "file_name": "epan/dissectors/packet-usb-audio.c", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}, {"raw_url": "https://github.com/wireshark/wireshark/raw/2cb5985bf47bdc8bea78d28483ed224abdd33dc6/epan/dissectors/packet-usb-masstorage.c", "patch": "@@ -199,9 +199,12 @@ dissect_usb_ms_bulk(tvbuff_t *tvb, packet_info *pinfo, proto_tree *parent_tree,\n         usb_ms_conv_info->itl=wmem_tree_new(wmem_file_scope());\n         usb_ms_conv_info->itlq=wmem_tree_new(wmem_file_scope());\n         usb_conv_info->class_data=usb_ms_conv_info;\n+        usb_conv_info->class_data_type = USB_CONV_MASS_STORAGE;\n+    } else if (usb_conv_info->class_data_type != USB_CONV_MASS_STORAGE) {\n+        /* Don't dissect if another USB type is in the conversation */\n+        return 0;\n     }\n \n-\n     is_request=(pinfo->srcport==NO_ENDPOINT);\n \n     col_set_str(pinfo->cinfo, COL_PROTOCOL, \"USBMS\");", "file_path": "files/2016_8\\49", "file_language": "c", "file_name": "epan/dissectors/packet-usb-masstorage.c", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}, {"raw_url": "https://github.com/wireshark/wireshark/raw/2cb5985bf47bdc8bea78d28483ed224abdd33dc6/epan/dissectors/packet-usb-video.c", "patch": "@@ -1035,6 +1035,10 @@ dissect_usb_video_control_interface_descriptor(proto_tree *parent_tree, tvbuff_t\n             video_conv_info = wmem_new(wmem_file_scope(), video_conv_info_t);\n             video_conv_info->entities = wmem_tree_new(wmem_file_scope());\n             usb_conv_info->class_data = video_conv_info;\n+            usb_conv_info->class_data_type = USB_CONV_VIDEO;\n+        } else if (usb_conv_info->class_data_type != USB_CONV_VIDEO) {\n+            /* Stop dissection if another USB type is in the conversation */\n+            return descriptor_len;\n         }\n \n         entity = (video_entity_t*) wmem_tree_lookup32(video_conv_info->entities, entity_id);", "file_path": "files/2016_8\\50", "file_language": "c", "file_name": "epan/dissectors/packet-usb-video.c", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}, {"raw_url": "https://github.com/wireshark/wireshark/raw/2cb5985bf47bdc8bea78d28483ed224abdd33dc6/epan/dissectors/packet-usb.h", "patch": "@@ -90,6 +90,8 @@ typedef struct _usb_trans_info_t {\n     guint64 usb_id;\n } usb_trans_info_t;\n \n+enum usb_conv_class_data_type {USB_CONV_UNKNOWN = 0, USB_CONV_U3V, USB_CONV_AUDIO, USB_CONV_VIDEO, USB_CONV_MASS_STORAGE};\n+\n /* Conversation Structure\n  * there is one such structure for each device/endpoint conversation */\n struct _usb_conv_info_t {\n@@ -113,7 +115,8 @@ struct _usb_conv_info_t {\n     wmem_tree_t *transactions;\n     usb_trans_info_t *usb_trans_info; /* pointer to the current transaction */\n \n-    void *class_data;\t/* private class/id decode data */\n+    void *class_data;           /* private class/id decode data */\n+    enum usb_conv_class_data_type class_data_type;\n \n     wmem_array_t *alt_settings;\n };", "file_path": "files/2016_8\\51", "file_language": "h", "file_name": "epan/dissectors/packet-usb.h", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}], "outdated": 0}
{"index": 14, "cve_id": "CVE-2016-5355", "cwe_id": ["CWE-20"], "cve_language": "C", "cve_description": "wiretap/toshiba.c in the Toshiba file parser in Wireshark 1.12.x before 1.12.12 and 2.x before 2.0.4 mishandles sscanf unsigned-integer processing, which allows remote attackers to cause a denial of service (application crash) via a crafted file.", "cvss": "5.9", "publish_date": "August 7, 2016", "AV": "NETWORK", "AC": "HIGH", "PR": "NONE", "UI": "NONE", "S": "UNCHANGED", "C": "NONE", "I": "NONE", "A": "HIGH", "commit_id": "5efb45231671baa2db2011d8f67f9d6e72bc455b", "commit_message": "Fix packet length handling.\n\nTreat the packet length as unsigned - it shouldn't be negative in the\nfile.  If it is, that'll probably cause the sscanf to fail, so we'll\nreport the file as bad.\n\nCheck it against WTAP_MAX_PACKET_SIZE to make sure we don't try to\nallocate a huge amount of memory, just as we do in other file readers.\n\nUse the now-validated packet size as the length in\nws_buffer_assure_space(), so we are certain to have enough space, and\ndon't allocate too much space.\n\nBug: 12394\nChange-Id: Ifa023ce70f7a2697bf151009b035a6e6cf8d5d90\nReviewed-on: https://code.wireshark.org/review/15169\nReviewed-by: Guy Harris <guy@alum.mit.edu>", "commit_date": "2016-04-29T22:20:26Z", "project": "wireshark/wireshark", "url": "https://api.github.com/repos/wireshark/wireshark/commits/5efb45231671baa2db2011d8f67f9d6e72bc455b", "html_url": "https://github.com/wireshark/wireshark/commit/5efb45231671baa2db2011d8f67f9d6e72bc455b", "windows_before": "", "windows_after": "", "parents": [{"commit_id_before": "e61ed6729878cba5a3b65c95b3370bdd9841452d", "url_before": "https://api.github.com/repos/wireshark/wireshark/commits/e61ed6729878cba5a3b65c95b3370bdd9841452d", "html_url_before": "https://github.com/wireshark/wireshark/commit/e61ed6729878cba5a3b65c95b3370bdd9841452d"}], "details": [{"raw_url": "https://github.com/wireshark/wireshark/raw/5efb45231671baa2db2011d8f67f9d6e72bc455b/wiretap/toshiba.c", "patch": "@@ -98,11 +98,6 @@ static const char toshiba_hdr_magic[]  =\n static const char toshiba_rec_magic[]  = { '[', 'N', 'o', '.' };\n #define TOSHIBA_REC_MAGIC_SIZE  (sizeof toshiba_rec_magic  / sizeof toshiba_rec_magic[0])\n \n-/*\n- * XXX - is this the biggest packet we can get?\n- */\n-#define TOSHIBA_MAX_PACKET_LEN\t16384\n-\n static gboolean toshiba_read(wtap *wth, int *err, gchar **err_info,\n \tgint64 *data_offset);\n static gboolean toshiba_seek_read(wtap *wth, gint64 seek_off,\n@@ -253,7 +248,8 @@ parse_toshiba_packet(FILE_T fh, struct wtap_pkthdr *phdr, Buffer *buf,\n \tunion wtap_pseudo_header *pseudo_header = &phdr->pseudo_header;\n \tchar\tline[TOSHIBA_LINE_LENGTH];\n \tint\tnum_items_scanned;\n-\tint\tpkt_len, pktnum, hr, min, sec, csec;\n+\tguint\tpkt_len;\n+\tint\tpktnum, hr, min, sec, csec;\n \tchar\tchannel[10], direction[10];\n \tint\ti, hex_lines;\n \tguint8\t*pd;\n@@ -305,12 +301,22 @@ parse_toshiba_packet(FILE_T fh, struct wtap_pkthdr *phdr, Buffer *buf,\n \n \t} while (strcmp(line, \"OFFSET 0001-0203\") != 0);\n \n-\tnum_items_scanned = sscanf(line+64, \"LEN=%9d\", &pkt_len);\n+\tnum_items_scanned = sscanf(line+64, \"LEN=%9u\", &pkt_len);\n \tif (num_items_scanned != 1) {\n \t\t*err = WTAP_ERR_BAD_FILE;\n \t\t*err_info = g_strdup(\"toshiba: OFFSET line doesn't have valid LEN item\");\n \t\treturn FALSE;\n \t}\n+\tif (pkt_len > WTAP_MAX_PACKET_SIZE) {\n+\t\t/*\n+\t\t * Probably a corrupt capture file; don't blow up trying\n+\t\t * to allocate space for an immensely-large packet.\n+\t\t */\n+\t\t*err = WTAP_ERR_BAD_FILE;\n+\t\t*err_info = g_strdup_printf(\"toshiba: File has %u-byte packet, bigger than maximum of %u\",\n+\t\t    pkt_len, WTAP_MAX_PACKET_SIZE);\n+\t\treturn FALSE;\n+\t}\n \n \tphdr->rec_type = REC_TYPE_PACKET;\n \tphdr->presence_flags = WTAP_HAS_TS|WTAP_HAS_CAP_LEN;\n@@ -341,7 +347,7 @@ parse_toshiba_packet(FILE_T fh, struct wtap_pkthdr *phdr, Buffer *buf,\n \t}\n \n \t/* Make sure we have enough room for the packet */\n-\tws_buffer_assure_space(buf, TOSHIBA_MAX_PACKET_LEN);\n+\tws_buffer_assure_space(buf, pkt_len);\n \tpd = ws_buffer_start_ptr(buf);\n \n \t/* Calculate the number of hex dump lines, each", "file_path": "files/2016_8\\52", "file_language": "c", "file_name": "wiretap/toshiba.c", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}], "outdated": 0}
{"index": 15, "cve_id": "CVE-2016-5355", "cwe_id": ["CWE-20"], "cve_language": "C", "cve_description": "wiretap/toshiba.c in the Toshiba file parser in Wireshark 1.12.x before 1.12.12 and 2.x before 2.0.4 mishandles sscanf unsigned-integer processing, which allows remote attackers to cause a denial of service (application crash) via a crafted file.", "cvss": "5.9", "publish_date": "August 7, 2016", "AV": "NETWORK", "AC": "HIGH", "PR": "NONE", "UI": "NONE", "S": "UNCHANGED", "C": "NONE", "I": "NONE", "A": "HIGH", "commit_id": "3270dfac43da861c714df76513456b46765ff47f", "commit_message": "Don't treat the packet length as unsigned.\n\nThe scanf family of functions are as annoyingly bad at handling unsigned\nnumbers as strtoul() is - both of them are perfectly willing to accept a\nvalue beginning with a negative sign as an unsigned value.  When using\nstrtoul(), you can compensate for this by explicitly checking for a '-'\nas the first character of the string, but you can't do that with\nsscanf().\n\nSo revert to having pkt_len be signed, and scanning it with %d, but\ncheck for a negative value and fail if we see a negative value.\n\nBug: 12394\nChange-Id: I4b19b95f2e1ffc96dac5c91bff6698c246f52007\nReviewed-on: https://code.wireshark.org/review/15230\nReviewed-by: Guy Harris <guy@alum.mit.edu>", "commit_date": "2016-05-01T23:31:51Z", "project": "wireshark/wireshark", "url": "https://api.github.com/repos/wireshark/wireshark/commits/3270dfac43da861c714df76513456b46765ff47f", "html_url": "https://github.com/wireshark/wireshark/commit/3270dfac43da861c714df76513456b46765ff47f", "windows_before": "", "windows_after": "", "parents": [{"commit_id_before": "a66628e425db725df1ac52a3c573a03357060ddd", "url_before": "https://api.github.com/repos/wireshark/wireshark/commits/a66628e425db725df1ac52a3c573a03357060ddd", "html_url_before": "https://github.com/wireshark/wireshark/commit/a66628e425db725df1ac52a3c573a03357060ddd"}], "details": [{"raw_url": "https://github.com/wireshark/wireshark/raw/3270dfac43da861c714df76513456b46765ff47f/wiretap/toshiba.c", "patch": "@@ -248,8 +248,7 @@ parse_toshiba_packet(FILE_T fh, struct wtap_pkthdr *phdr, Buffer *buf,\n \tunion wtap_pseudo_header *pseudo_header = &phdr->pseudo_header;\n \tchar\tline[TOSHIBA_LINE_LENGTH];\n \tint\tnum_items_scanned;\n-\tguint\tpkt_len;\n-\tint\tpktnum, hr, min, sec, csec;\n+\tint\tpkt_len, pktnum, hr, min, sec, csec;\n \tchar\tchannel[10], direction[10];\n \tint\ti, hex_lines;\n \tguint8\t*pd;\n@@ -301,12 +300,17 @@ parse_toshiba_packet(FILE_T fh, struct wtap_pkthdr *phdr, Buffer *buf,\n \n \t} while (strcmp(line, \"OFFSET 0001-0203\") != 0);\n \n-\tnum_items_scanned = sscanf(line+64, \"LEN=%9u\", &pkt_len);\n+\tnum_items_scanned = sscanf(line+64, \"LEN=%9d\", &pkt_len);\n \tif (num_items_scanned != 1) {\n \t\t*err = WTAP_ERR_BAD_FILE;\n \t\t*err_info = g_strdup(\"toshiba: OFFSET line doesn't have valid LEN item\");\n \t\treturn FALSE;\n \t}\n+\tif (pkt_len < 0) {\n+\t\t*err = WTAP_ERR_BAD_FILE;\n+\t\t*err_info = g_strdup(\"toshiba: packet header has a negative packet length\");\n+\t\treturn FALSE;\n+\t}\n \tif (pkt_len > WTAP_MAX_PACKET_SIZE) {\n \t\t/*\n \t\t * Probably a corrupt capture file; don't blow up trying", "file_path": "files/2016_8\\53", "file_language": "c", "file_name": "wiretap/toshiba.c", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}], "outdated": 0}
{"index": 16, "cve_id": "CVE-2016-5356", "cwe_id": ["CWE-119"], "cve_language": "C", "cve_description": "wiretap/cosine.c in the CoSine file parser in Wireshark 1.12.x before 1.12.12 and 2.x before 2.0.4 mishandles sscanf unsigned-integer processing, which allows remote attackers to cause a denial of service (application crash) via a crafted file.", "cvss": "5.9", "publish_date": "August 7, 2016", "AV": "NETWORK", "AC": "HIGH", "PR": "NONE", "UI": "NONE", "S": "UNCHANGED", "C": "NONE", "I": "NONE", "A": "HIGH", "commit_id": "a66628e425db725df1ac52a3c573a03357060ddd", "commit_message": "Don't treat the packet length as unsigned.\n\nThe scanf family of functions are as annoyingly bad at handling unsigned\nnumbers as strtoul() is - both of them are perfectly willing to accept a\nvalue beginning with a negative sign as an unsigned value.  When using\nstrtoul(), you can compensate for this by explicitly checking for a '-'\nas the first character of the string, but you can't do that with\nsscanf().\n\nSo revert to having pkt_len be signed, and scanning it with %d, but\ncheck for a negative value and fail if we see a negative value.\n\nBug: 12395\nChange-Id: I43b458a73b0934e9a5c2c89d34eac5a8f21a7455\nReviewed-on: https://code.wireshark.org/review/15223\nReviewed-by: Guy Harris <guy@alum.mit.edu>", "commit_date": "2016-05-01T23:23:29Z", "project": "wireshark/wireshark", "url": "https://api.github.com/repos/wireshark/wireshark/commits/a66628e425db725df1ac52a3c573a03357060ddd", "html_url": "https://github.com/wireshark/wireshark/commit/a66628e425db725df1ac52a3c573a03357060ddd", "windows_before": "", "windows_after": "", "parents": [{"commit_id_before": "85d57b53e88cc1193c9259e13c531746b6f56c0e", "url_before": "https://api.github.com/repos/wireshark/wireshark/commits/85d57b53e88cc1193c9259e13c531746b6f56c0e", "html_url_before": "https://github.com/wireshark/wireshark/commit/85d57b53e88cc1193c9259e13c531746b6f56c0e"}], "details": [{"raw_url": "https://github.com/wireshark/wireshark/raw/a66628e425db725df1ac52a3c573a03357060ddd/wiretap/cosine.c", "patch": "@@ -330,8 +330,7 @@ parse_cosine_packet(FILE_T fh, struct wtap_pkthdr *phdr, Buffer *buf,\n {\n \tunion wtap_pseudo_header *pseudo_header = &phdr->pseudo_header;\n \tint\tnum_items_scanned;\n-\tint\tyy, mm, dd, hr, min, sec, csec;\n-\tguint\tpkt_len;\n+\tint\tyy, mm, dd, hr, min, sec, csec, pkt_len;\n \tint\tpro, off, pri, rm, error;\n \tguint\tcode1, code2;\n \tchar\tif_name[COSINE_MAX_IF_NAME_LEN] = \"\", direction[6] = \"\";\n@@ -343,7 +342,7 @@ parse_cosine_packet(FILE_T fh, struct wtap_pkthdr *phdr, Buffer *buf,\n \t\t   &yy, &mm, &dd, &hr, &min, &sec, &csec) == 7) {\n \t\t/* appears to be output to a control blade */\n \t\tnum_items_scanned = sscanf(line,\n-\t\t   \"%4d-%2d-%2d,%2d:%2d:%2d.%9d: %5s (%127[A-Za-z0-9/:]), Length:%9u, Pro:%9d, Off:%9d, Pri:%9d, RM:%9d, Err:%9d [%8x, %8x]\",\n+\t\t   \"%4d-%2d-%2d,%2d:%2d:%2d.%9d: %5s (%127[A-Za-z0-9/:]), Length:%9d, Pro:%9d, Off:%9d, Pri:%9d, RM:%9d, Err:%9d [%8x, %8x]\",\n \t\t\t&yy, &mm, &dd, &hr, &min, &sec, &csec,\n \t\t\t\t   direction, if_name, &pkt_len,\n \t\t\t\t   &pro, &off, &pri, &rm, &error,\n@@ -357,7 +356,7 @@ parse_cosine_packet(FILE_T fh, struct wtap_pkthdr *phdr, Buffer *buf,\n \t} else {\n \t\t/* appears to be output to PE */\n \t\tnum_items_scanned = sscanf(line,\n-\t\t   \"%5s (%127[A-Za-z0-9/:]), Length:%9u, Pro:%9d, Off:%9d, Pri:%9d, RM:%9d, Err:%9d [%8x, %8x]\",\n+\t\t   \"%5s (%127[A-Za-z0-9/:]), Length:%9d, Pro:%9d, Off:%9d, Pri:%9d, RM:%9d, Err:%9d [%8x, %8x]\",\n \t\t\t\t   direction, if_name, &pkt_len,\n \t\t\t\t   &pro, &off, &pri, &rm, &error,\n \t\t\t\t   &code1, &code2);\n@@ -369,6 +368,11 @@ parse_cosine_packet(FILE_T fh, struct wtap_pkthdr *phdr, Buffer *buf,\n \t\t}\n \t\tyy = mm = dd = hr = min = sec = csec = 0;\n \t}\n+\tif (pkt_len < 0) {\n+\t\t*err = WTAP_ERR_BAD_FILE;\n+\t\t*err_info = g_strdup(\"cosine: packet header has a negative packet length\");\n+\t\treturn FALSE;\n+\t}\n \tif (pkt_len > WTAP_MAX_PACKET_SIZE) {\n \t\t/*\n \t\t * Probably a corrupt capture file; don't blow up trying", "file_path": "files/2016_8\\54", "file_language": "c", "file_name": "wiretap/cosine.c", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}], "outdated": 0}
{"index": 17, "cve_id": "CVE-2016-5356", "cwe_id": ["CWE-119"], "cve_language": "C", "cve_description": "wiretap/cosine.c in the CoSine file parser in Wireshark 1.12.x before 1.12.12 and 2.x before 2.0.4 mishandles sscanf unsigned-integer processing, which allows remote attackers to cause a denial of service (application crash) via a crafted file.", "cvss": "5.9", "publish_date": "August 7, 2016", "AV": "NETWORK", "AC": "HIGH", "PR": "NONE", "UI": "NONE", "S": "UNCHANGED", "C": "NONE", "I": "NONE", "A": "HIGH", "commit_id": "f5ec0afb766f19519ea9623152cca3bbe2229500", "commit_message": "Fix packet length handling.\n\nTreat the packet length as unsigned - it shouldn't be negative in the\nfile.  If it is, that'll probably cause the sscanf to fail, so we'll\nreport the file as bad.\n\nCheck it against WTAP_MAX_PACKET_SIZE to make sure we don't try to\nallocate a huge amount of memory, just as we do in other file readers.\n\nUse the now-validated packet size as the length in\nws_buffer_assure_space(), so we are certain to have enough space, and\ndon't allocate too much space.\n\nMerge the header and packet data parsing routines while we're at it.\n\nBug: 12395\nChange-Id: Ia70f33b71ff28451190fcf144c333fd1362646b2\nReviewed-on: https://code.wireshark.org/review/15172\nReviewed-by: Guy Harris <guy@alum.mit.edu>", "commit_date": "2016-04-29T22:51:41Z", "project": "wireshark/wireshark", "url": "https://api.github.com/repos/wireshark/wireshark/commits/f5ec0afb766f19519ea9623152cca3bbe2229500", "html_url": "https://github.com/wireshark/wireshark/commit/f5ec0afb766f19519ea9623152cca3bbe2229500", "windows_before": "", "windows_after": "", "parents": [{"commit_id_before": "69714b7457dc02a80e7ca453b60d5f5432756158", "url_before": "https://api.github.com/repos/wireshark/wireshark/commits/69714b7457dc02a80e7ca453b60d5f5432756158", "html_url_before": "https://github.com/wireshark/wireshark/commit/69714b7457dc02a80e7ca453b60d5f5432756158"}], "details": [{"raw_url": "https://github.com/wireshark/wireshark/raw/f5ec0afb766f19519ea9623152cca3bbe2229500/wiretap/cosine.c", "patch": "@@ -157,8 +157,6 @@\n #define COSINE_HEADER_LINES_TO_CHECK\t200\n #define COSINE_LINE_LENGTH\t\t240\n \n-#define COSINE_MAX_PACKET_LEN\t65536\n-\n static gboolean empty_line(const gchar *line);\n static gint64 cosine_seek_next_packet(wtap *wth, int *err, gchar **err_info,\n \tchar *hdr);\n@@ -167,10 +165,8 @@ static gboolean cosine_read(wtap *wth, int *err, gchar **err_info,\n \tgint64 *data_offset);\n static gboolean cosine_seek_read(wtap *wth, gint64 seek_off,\n \tstruct wtap_pkthdr *phdr, Buffer *buf, int *err, gchar **err_info);\n-static int parse_cosine_rec_hdr(struct wtap_pkthdr *phdr, const char *line,\n-\tint *err, gchar **err_info);\n-static gboolean parse_cosine_hex_dump(FILE_T fh, struct wtap_pkthdr *phdr,\n-\tint pkt_len, Buffer* buf, int *err, gchar **err_info);\n+static int parse_cosine_packet(FILE_T fh, struct wtap_pkthdr *phdr, Buffer* buf,\n+\tchar *line, int *err, gchar **err_info);\n static int parse_single_hex_dump_line(char* rec, guint8 *buf,\n \tguint byte_offset);\n \n@@ -287,7 +283,6 @@ static gboolean cosine_read(wtap *wth, int *err, gchar **err_info,\n     gint64 *data_offset)\n {\n \tgint64\toffset;\n-\tint\tpkt_len;\n \tchar\tline[COSINE_LINE_LENGTH];\n \n \t/* Find the next packet */\n@@ -296,22 +291,16 @@ static gboolean cosine_read(wtap *wth, int *err, gchar **err_info,\n \t\treturn FALSE;\n \t*data_offset = offset;\n \n-\t/* Parse the header */\n-\tpkt_len = parse_cosine_rec_hdr(&wth->phdr, line, err, err_info);\n-\tif (pkt_len == -1)\n-\t\treturn FALSE;\n-\n-\t/* Convert the ASCII hex dump to binary data */\n-\treturn parse_cosine_hex_dump(wth->fh, &wth->phdr, pkt_len,\n-\t    wth->frame_buffer, err, err_info);\n+\t/* Parse the header and convert the ASCII hex dump to binary data */\n+\treturn parse_cosine_packet(wth->fh, &wth->phdr, wth->frame_buffer,\n+\t    line, err, err_info);\n }\n \n /* Used to read packets in random-access fashion */\n static gboolean\n cosine_seek_read(wtap *wth, gint64 seek_off, struct wtap_pkthdr *phdr,\n \tBuffer *buf, int *err, gchar **err_info)\n {\n-\tint\tpkt_len;\n \tchar\tline[COSINE_LINE_LENGTH];\n \n \tif (file_seek(wth->random_fh, seek_off, SEEK_SET, err) == -1)\n@@ -325,13 +314,8 @@ cosine_seek_read(wtap *wth, gint64 seek_off, struct wtap_pkthdr *phdr,\n \t\treturn FALSE;\n \t}\n \n-\t/* Parse the header */\n-\tpkt_len = parse_cosine_rec_hdr(phdr, line, err, err_info);\n-\tif (pkt_len == -1)\n-\t\treturn FALSE;\n-\n-\t/* Convert the ASCII hex dump to binary data */\n-\treturn parse_cosine_hex_dump(wth->random_fh, phdr, pkt_len, buf, err,\n+\t/* Parse the header and convert the ASCII hex dump to binary data */\n+\treturn parse_cosine_packet(wth->random_fh, phdr, buf, line, err,\n \t    err_info);\n }\n \n@@ -340,23 +324,26 @@ cosine_seek_read(wtap *wth, gint64 seek_off, struct wtap_pkthdr *phdr,\n         2002-5-10,20:1:31.4:  l2-tx (FR:3/7/1:1), Length:18, Pro:0, Off:0, Pri:0, RM:0, Err:0 [0x4000, 0x0]\n     2) output to PE without date and time\n         l2-tx (FR:3/7/1:1), Length:18, Pro:0, Off:0, Pri:0, RM:0, Err:0 [0x4000, 0x0] */\n-static int\n-parse_cosine_rec_hdr(struct wtap_pkthdr *phdr, const char *line,\n-     int *err, gchar **err_info)\n+static gboolean\n+parse_cosine_packet(FILE_T fh, struct wtap_pkthdr *phdr, Buffer *buf,\n+    char *line, int *err, gchar **err_info)\n {\n \tunion wtap_pseudo_header *pseudo_header = &phdr->pseudo_header;\n \tint\tnum_items_scanned;\n-\tint\tyy, mm, dd, hr, min, sec, csec, pkt_len;\n+\tint\tyy, mm, dd, hr, min, sec, csec;\n+\tguint\tpkt_len;\n \tint\tpro, off, pri, rm, error;\n \tguint\tcode1, code2;\n \tchar\tif_name[COSINE_MAX_IF_NAME_LEN] = \"\", direction[6] = \"\";\n \tstruct\ttm tm;\n+\tguint8 *pd;\n+\tint\ti, hex_lines, n, caplen = 0;\n \n \tif (sscanf(line, \"%4d-%2d-%2d,%2d:%2d:%2d.%9d:\",\n \t\t   &yy, &mm, &dd, &hr, &min, &sec, &csec) == 7) {\n \t\t/* appears to be output to a control blade */\n \t\tnum_items_scanned = sscanf(line,\n-\t\t   \"%4d-%2d-%2d,%2d:%2d:%2d.%9d: %5s (%127[A-Za-z0-9/:]), Length:%9d, Pro:%9d, Off:%9d, Pri:%9d, RM:%9d, Err:%9d [%8x, %8x]\",\n+\t\t   \"%4d-%2d-%2d,%2d:%2d:%2d.%9d: %5s (%127[A-Za-z0-9/:]), Length:%9u, Pro:%9d, Off:%9d, Pri:%9d, RM:%9d, Err:%9d [%8x, %8x]\",\n \t\t\t&yy, &mm, &dd, &hr, &min, &sec, &csec,\n \t\t\t\t   direction, if_name, &pkt_len,\n \t\t\t\t   &pro, &off, &pri, &rm, &error,\n@@ -365,23 +352,33 @@ parse_cosine_rec_hdr(struct wtap_pkthdr *phdr, const char *line,\n \t\tif (num_items_scanned != 17) {\n \t\t\t*err = WTAP_ERR_BAD_FILE;\n \t\t\t*err_info = g_strdup(\"cosine: purported control blade line doesn't have code values\");\n-\t\t\treturn -1;\n+\t\t\treturn FALSE;\n \t\t}\n \t} else {\n \t\t/* appears to be output to PE */\n \t\tnum_items_scanned = sscanf(line,\n-\t\t   \"%5s (%127[A-Za-z0-9/:]), Length:%9d, Pro:%9d, Off:%9d, Pri:%9d, RM:%9d, Err:%9d [%8x, %8x]\",\n+\t\t   \"%5s (%127[A-Za-z0-9/:]), Length:%9u, Pro:%9d, Off:%9d, Pri:%9d, RM:%9d, Err:%9d [%8x, %8x]\",\n \t\t\t\t   direction, if_name, &pkt_len,\n \t\t\t\t   &pro, &off, &pri, &rm, &error,\n \t\t\t\t   &code1, &code2);\n \n \t\tif (num_items_scanned != 10) {\n \t\t\t*err = WTAP_ERR_BAD_FILE;\n \t\t\t*err_info = g_strdup(\"cosine: header line is neither control blade nor PE output\");\n-\t\t\treturn -1;\n+\t\t\treturn FALSE;\n \t\t}\n \t\tyy = mm = dd = hr = min = sec = csec = 0;\n \t}\n+\tif (pkt_len > WTAP_MAX_PACKET_SIZE) {\n+\t\t/*\n+\t\t * Probably a corrupt capture file; don't blow up trying\n+\t\t * to allocate space for an immensely-large packet.\n+\t\t */\n+\t\t*err = WTAP_ERR_BAD_FILE;\n+\t\t*err_info = g_strdup_printf(\"cosine: File has %u-byte packet, bigger than maximum of %u\",\n+\t\t    pkt_len, WTAP_MAX_PACKET_SIZE);\n+\t\treturn FALSE;\n+\t}\n \n \tphdr->rec_type = REC_TYPE_PACKET;\n \tphdr->presence_flags = WTAP_HAS_TS|WTAP_HAS_CAP_LEN;\n@@ -430,21 +427,8 @@ parse_cosine_rec_hdr(struct wtap_pkthdr *phdr, const char *line,\n \tpseudo_header->cosine.rm = rm;\n \tpseudo_header->cosine.err = error;\n \n-\treturn pkt_len;\n-}\n-\n-/* Converts ASCII hex dump to binary data. Returns TRUE on success,\n-   FALSE if any error is encountered. */\n-static gboolean\n-parse_cosine_hex_dump(FILE_T fh, struct wtap_pkthdr *phdr, int pkt_len,\n-    Buffer* buf, int *err, gchar **err_info)\n-{\n-\tguint8 *pd;\n-\tgchar\tline[COSINE_LINE_LENGTH];\n-\tint\ti, hex_lines, n, caplen = 0;\n-\n \t/* Make sure we have enough room for the packet */\n-\tws_buffer_assure_space(buf, COSINE_MAX_PACKET_LEN);\n+\tws_buffer_assure_space(buf, pkt_len);\n \tpd = ws_buffer_start_ptr(buf);\n \n \t/* Calculate the number of hex dump lines, each\n@@ -473,7 +457,6 @@ parse_cosine_hex_dump(FILE_T fh, struct wtap_pkthdr *phdr, int pkt_len,\n \treturn TRUE;\n }\n \n-\n /* Take a string representing one line from a hex dump and converts\n  * the text to binary data. We place the bytes in the buffer at the\n  * specified offset.", "file_path": "files/2016_8\\55", "file_language": "c", "file_name": "wiretap/cosine.c", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}], "outdated": 0}
{"index": 18, "cve_id": "CVE-2016-5357", "cwe_id": ["CWE-20"], "cve_language": "C", "cve_description": "wiretap/netscreen.c in the NetScreen file parser in Wireshark 1.12.x before 1.12.12 and 2.x before 2.0.4 mishandles sscanf unsigned-integer processing, which allows remote attackers to cause a denial of service (application crash) via a crafted file.", "cvss": "5.9", "publish_date": "August 7, 2016", "AV": "NETWORK", "AC": "HIGH", "PR": "NONE", "UI": "NONE", "S": "UNCHANGED", "C": "NONE", "I": "NONE", "A": "HIGH", "commit_id": "11edc83b98a61e890d7bb01855389d40e984ea82", "commit_message": "Don't treat the packet length as unsigned.\n\nThe scanf family of functions are as annoyingly bad at handling unsigned\nnumbers as strtoul() is - both of them are perfectly willing to accept a\nvalue beginning with a negative sign as an unsigned value.  When using\nstrtoul(), you can compensate for this by explicitly checking for a '-'\nas the first character of the string, but you can't do that with\nsscanf().\n\nSo revert to having pkt_len be signed, and scanning it with %d, but\ncheck for a negative value and fail if we see a negative value.\n\nBug: 12396\nChange-Id: I54fe8f61f42c32b5ef33da633ece51bbcda8c95f\nReviewed-on: https://code.wireshark.org/review/15220\nReviewed-by: Guy Harris <guy@alum.mit.edu>", "commit_date": "2016-05-01T23:14:25Z", "project": "wireshark/wireshark", "url": "https://api.github.com/repos/wireshark/wireshark/commits/11edc83b98a61e890d7bb01855389d40e984ea82", "html_url": "https://github.com/wireshark/wireshark/commit/11edc83b98a61e890d7bb01855389d40e984ea82", "windows_before": "", "windows_after": "", "parents": [{"commit_id_before": "29c78db2a80a93653f32e4fd2f00b9b550432c43", "url_before": "https://api.github.com/repos/wireshark/wireshark/commits/29c78db2a80a93653f32e4fd2f00b9b550432c43", "html_url_before": "https://github.com/wireshark/wireshark/commit/29c78db2a80a93653f32e4fd2f00b9b550432c43"}], "details": [{"raw_url": "https://github.com/wireshark/wireshark/raw/11edc83b98a61e890d7bb01855389d40e984ea82/wiretap/netscreen.c", "patch": "@@ -263,28 +263,33 @@ static gboolean\n parse_netscreen_packet(FILE_T fh, struct wtap_pkthdr *phdr, Buffer* buf,\n     char *line, int *err, gchar **err_info)\n {\n+\tint\t\tpkt_len;\n \tint\t\tsec;\n \tint\t\tdsec;\n \tchar\t\tcap_int[NETSCREEN_MAX_INT_NAME_LENGTH];\n \tchar\t\tdirection[2];\n-\tguint\t\tpkt_len;\n \tchar\t\tcap_src[13];\n \tchar\t\tcap_dst[13];\n \tguint8\t\t*pd;\n \tgchar\t\t*p;\n \tint\t\tn, i = 0;\n-\tguint\t\toffset = 0;\n+\tint\t\toffset = 0;\n \tgchar\t\tdststr[13];\n \n \tphdr->rec_type = REC_TYPE_PACKET;\n \tphdr->presence_flags = WTAP_HAS_TS|WTAP_HAS_CAP_LEN;\n \n-\tif (sscanf(line, \"%9d.%9d: %15[a-z0-9/:.-](%1[io]) len=%9u:%12s->%12s/\",\n+\tif (sscanf(line, \"%9d.%9d: %15[a-z0-9/:.-](%1[io]) len=%9d:%12s->%12s/\",\n \t\t   &sec, &dsec, cap_int, direction, &pkt_len, cap_src, cap_dst) < 5) {\n \t\t*err = WTAP_ERR_BAD_FILE;\n \t\t*err_info = g_strdup(\"netscreen: Can't parse packet-header\");\n \t\treturn -1;\n \t}\n+\tif (pkt_len < 0) {\n+\t\t*err = WTAP_ERR_BAD_FILE;\n+\t\t*err_info = g_strdup(\"netscreen: packet header has a negative packet length\");\n+\t\treturn FALSE;\n+\t}\n \tif (pkt_len > WTAP_MAX_PACKET_SIZE) {\n \t\t/*\n \t\t * Probably a corrupt capture file; don't blow up trying", "file_path": "files/2016_8\\56", "file_language": "c", "file_name": "wiretap/netscreen.c", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}], "outdated": 0}
{"index": 19, "cve_id": "CVE-2016-5357", "cwe_id": ["CWE-20"], "cve_language": "C", "cve_description": "wiretap/netscreen.c in the NetScreen file parser in Wireshark 1.12.x before 1.12.12 and 2.x before 2.0.4 mishandles sscanf unsigned-integer processing, which allows remote attackers to cause a denial of service (application crash) via a crafted file.", "cvss": "5.9", "publish_date": "August 7, 2016", "AV": "NETWORK", "AC": "HIGH", "PR": "NONE", "UI": "NONE", "S": "UNCHANGED", "C": "NONE", "I": "NONE", "A": "HIGH", "commit_id": "6a140eca7b78b230f1f90a739a32257476513c78", "commit_message": "Fix packet length handling.\n\nTreat the packet length as unsigned - it shouldn't be negative in the\nfile.  If it is, that'll probably cause the sscanf to fail, so we'll\nreport the file as bad.\n\nCheck it against WTAP_MAX_PACKET_SIZE to make sure we don't try to\nallocate a huge amount of memory, just as we do in other file readers.\n\nUse the now-validated packet size as the length in\nws_buffer_assure_space(), so we are certain to have enough space, and\ndon't allocate too much space.\n\nMerge the header and packet data parsing routines while we're at it.\n\nBug: 12396\nChange-Id: I7f981f9cdcbea7ecdeb88bfff2f12d875de2244f\nReviewed-on: https://code.wireshark.org/review/15176\nReviewed-by: Guy Harris <guy@alum.mit.edu>", "commit_date": "2016-04-30T00:08:48Z", "project": "wireshark/wireshark", "url": "https://api.github.com/repos/wireshark/wireshark/commits/6a140eca7b78b230f1f90a739a32257476513c78", "html_url": "https://github.com/wireshark/wireshark/commit/6a140eca7b78b230f1f90a739a32257476513c78", "windows_before": "", "windows_after": "", "parents": [{"commit_id_before": "c245be94c514079d144340bf7847f23545d76e24", "url_before": "https://api.github.com/repos/wireshark/wireshark/commits/c245be94c514079d144340bf7847f23545d76e24", "html_url_before": "https://github.com/wireshark/wireshark/commit/c245be94c514079d144340bf7847f23545d76e24"}], "details": [{"raw_url": "https://github.com/wireshark/wireshark/raw/6a140eca7b78b230f1f90a739a32257476513c78/wiretap/netscreen.c", "patch": "@@ -69,12 +69,8 @@ static gboolean netscreen_read(wtap *wth, int *err, gchar **err_info,\n static gboolean netscreen_seek_read(wtap *wth, gint64 seek_off,\n \tstruct wtap_pkthdr *phdr, Buffer *buf,\n \tint *err, gchar **err_info);\n-static int parse_netscreen_rec_hdr(struct wtap_pkthdr *phdr, const char *line,\n-\tchar *cap_int, gboolean *cap_dir, char *cap_dst,\n-\tint *err, gchar **err_info);\n-static gboolean parse_netscreen_hex_dump(FILE_T fh, int pkt_len,\n-\tconst char *cap_int, const char *cap_dst, struct wtap_pkthdr *phdr,\n-\tBuffer* buf, int *err, gchar **err_info);\n+static gboolean parse_netscreen_packet(FILE_T fh, struct wtap_pkthdr *phdr,\n+\tBuffer* buf, char *line, int *err, gchar **err_info);\n static int parse_single_hex_dump_line(char* rec, guint8 *buf,\n \tguint byte_offset);\n \n@@ -191,27 +187,16 @@ static gboolean netscreen_read(wtap *wth, int *err, gchar **err_info,\n     gint64 *data_offset)\n {\n \tgint64\t\toffset;\n-\tint\t\tpkt_len;\n \tchar\t\tline[NETSCREEN_LINE_LENGTH];\n-\tchar\t\tcap_int[NETSCREEN_MAX_INT_NAME_LENGTH];\n-\tgboolean\tcap_dir;\n-\tchar\t\tcap_dst[13];\n \n \t/* Find the next packet */\n \toffset = netscreen_seek_next_packet(wth, err, err_info, line);\n \tif (offset < 0)\n \t\treturn FALSE;\n \n-\t/* Parse the header */\n-\tpkt_len = parse_netscreen_rec_hdr(&wth->phdr, line, cap_int, &cap_dir,\n-\t    cap_dst, err, err_info);\n-\tif (pkt_len == -1)\n-\t\treturn FALSE;\n-\n-\t/* Convert the ASCII hex dump to binary data, and fill in some\n-\t   struct wtap_pkthdr fields */\n-\tif (!parse_netscreen_hex_dump(wth->fh, pkt_len, cap_int,\n-\t    cap_dst, &wth->phdr, wth->frame_buffer, err, err_info))\n+\t/* Parse the header and convert the ASCII hex dump to binary data */\n+\tif (!parse_netscreen_packet(wth->fh, &wth->phdr,\n+\t    wth->frame_buffer, line, err, err_info))\n \t\treturn FALSE;\n \n \t/*\n@@ -239,11 +224,7 @@ netscreen_seek_read(wtap *wth, gint64 seek_off,\n \tstruct wtap_pkthdr *phdr, Buffer *buf,\n \tint *err, gchar **err_info)\n {\n-\tint\t\tpkt_len;\n \tchar\t\tline[NETSCREEN_LINE_LENGTH];\n-\tchar\t\tcap_int[NETSCREEN_MAX_INT_NAME_LENGTH];\n-\tgboolean\tcap_dir;\n-\tchar\t\tcap_dst[13];\n \n \tif (file_seek(wth->random_fh, seek_off, SEEK_SET, err) == -1) {\n \t\treturn FALSE;\n@@ -257,15 +238,8 @@ netscreen_seek_read(wtap *wth, gint64 seek_off,\n \t\treturn FALSE;\n \t}\n \n-\tpkt_len = parse_netscreen_rec_hdr(phdr, line, cap_int, &cap_dir,\n-\t    cap_dst, err, err_info);\n-\tif (pkt_len == -1)\n-\t\treturn FALSE;\n-\n-\tif (!parse_netscreen_hex_dump(wth->random_fh, pkt_len, cap_int,\n-\t    cap_dst, phdr, buf, err, err_info))\n-\t\treturn FALSE;\n-\treturn TRUE;\n+\treturn parse_netscreen_packet(wth->random_fh, phdr, buf, line,\n+\t    err, err_info);\n }\n \n /* Parses a packet record header. There are a few possible formats:\n@@ -285,49 +259,54 @@ netscreen_seek_read(wtap *wth, gint64 seek_off,\n \n \n  */\n-static int\n-parse_netscreen_rec_hdr(struct wtap_pkthdr *phdr, const char *line, char *cap_int,\n-    gboolean *cap_dir, char *cap_dst, int *err, gchar **err_info)\n+static gboolean\n+parse_netscreen_packet(FILE_T fh, struct wtap_pkthdr *phdr, Buffer* buf,\n+    char *line, int *err, gchar **err_info)\n {\n-\tint\tsec;\n-\tint\tdsec, pkt_len;\n-\tchar\tdirection[2];\n-\tchar\tcap_src[13];\n+\tint\t\tsec;\n+\tint\t\tdsec;\n+\tchar\t\tcap_int[NETSCREEN_MAX_INT_NAME_LENGTH];\n+\tchar\t\tdirection[2];\n+\tguint\t\tpkt_len;\n+\tchar\t\tcap_src[13];\n+\tchar\t\tcap_dst[13];\n+\tguint8\t\t*pd;\n+\tgchar\t\t*p;\n+\tint\t\tn, i = 0;\n+\tguint\t\toffset = 0;\n+\tgchar\t\tdststr[13];\n \n \tphdr->rec_type = REC_TYPE_PACKET;\n \tphdr->presence_flags = WTAP_HAS_TS|WTAP_HAS_CAP_LEN;\n \n-\tif (sscanf(line, \"%9d.%9d: %15[a-z0-9/:.-](%1[io]) len=%9d:%12s->%12s/\",\n+\tif (sscanf(line, \"%9d.%9d: %15[a-z0-9/:.-](%1[io]) len=%9u:%12s->%12s/\",\n \t\t   &sec, &dsec, cap_int, direction, &pkt_len, cap_src, cap_dst) < 5) {\n \t\t*err = WTAP_ERR_BAD_FILE;\n \t\t*err_info = g_strdup(\"netscreen: Can't parse packet-header\");\n \t\treturn -1;\n \t}\n+\tif (pkt_len > WTAP_MAX_PACKET_SIZE) {\n+\t\t/*\n+\t\t * Probably a corrupt capture file; don't blow up trying\n+\t\t * to allocate space for an immensely-large packet.\n+\t\t */\n+\t\t*err = WTAP_ERR_BAD_FILE;\n+\t\t*err_info = g_strdup_printf(\"netscreen: File has %u-byte packet, bigger than maximum of %u\",\n+\t\t    pkt_len, WTAP_MAX_PACKET_SIZE);\n+\t\treturn FALSE;\n+\t}\n \n-\t*cap_dir = (direction[0] == 'o' ? NETSCREEN_EGRESS : NETSCREEN_INGRESS);\n+\t/*\n+\t * If direction[0] is 'o', the direction is NETSCREEN_EGRESS,\n+\t * otherwise it's NETSCREEN_INGRESS.\n+\t */\n \n \tphdr->ts.secs  = sec;\n \tphdr->ts.nsecs = dsec * 100000000;\n \tphdr->len = pkt_len;\n \n-\treturn pkt_len;\n-}\n-\n-/* Converts ASCII hex dump to binary data, and fills in some struct\n-   wtap_pkthdr fields.  Returns TRUE on success and FALSE on any error. */\n-static gboolean\n-parse_netscreen_hex_dump(FILE_T fh, int pkt_len, const char *cap_int,\n-    const char *cap_dst, struct wtap_pkthdr *phdr, Buffer* buf,\n-    int *err, gchar **err_info)\n-{\n-\tguint8\t*pd;\n-\tgchar\tline[NETSCREEN_LINE_LENGTH];\n-\tgchar\t*p;\n-\tint\tn, i = 0, offset = 0;\n-\tgchar\tdststr[13];\n-\n \t/* Make sure we have enough room for the packet */\n-\tws_buffer_assure_space(buf, NETSCREEN_MAX_PACKET_LEN);\n+\tws_buffer_assure_space(buf, pkt_len);\n \tpd = ws_buffer_start_ptr(buf);\n \n \twhile(1) {\n@@ -373,7 +352,7 @@ parse_netscreen_hex_dump(FILE_T fh, int pkt_len, const char *cap_int,\n \t\t/* If there is no more data and the line was not empty,\n \t\t * then there must be an error in the file\n \t\t */\n-\t\tif(n == -1) {\n+\t\tif (n == -1) {\n \t\t\t*err = WTAP_ERR_BAD_FILE;\n \t\t\t*err_info = g_strdup(\"netscreen: cannot parse hex-data\");\n \t\t\treturn FALSE;\n@@ -385,7 +364,7 @@ parse_netscreen_hex_dump(FILE_T fh, int pkt_len, const char *cap_int,\n \t\t/* If there was more hex-data than was announced in the len=x\n \t\t * header, then then there must be an error in the file\n \t\t */\n-\t\tif(offset > pkt_len) {\n+\t\tif (offset > pkt_len) {\n \t\t\t*err = WTAP_ERR_BAD_FILE;\n \t\t\t*err_info = g_strdup(\"netscreen: too much hex-data\");\n \t\t\treturn FALSE;", "file_path": "files/2016_8\\57", "file_language": "c", "file_name": "wiretap/netscreen.c", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}, {"raw_url": "https://github.com/wireshark/wireshark/raw/6a140eca7b78b230f1f90a739a32257476513c78/wiretap/netscreen.h", "patch": "@@ -46,9 +46,6 @@\n #define NETSCREEN_INGRESS\t\tFALSE\n #define NETSCREEN_EGRESS\t\tTRUE\n \n-\n-#define NETSCREEN_MAX_PACKET_LEN\t65536\n-\n wtap_open_return_val netscreen_open(wtap *wth, int *err, gchar **err_info);\n \n #endif", "file_path": "files/2016_8\\58", "file_language": "h", "file_name": "wiretap/netscreen.h", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}], "outdated": 0}
{"index": 20, "cve_id": "CVE-2016-5352", "cwe_id": ["CWE-125"], "cve_language": "C", "cve_description": "epan/crypt/airpdcap.c in the IEEE 802.11 dissector in Wireshark 2.x before 2.0.4 mishandles certain length values, which allows remote attackers to cause a denial of service (application crash) via a crafted packet.", "cvss": "5.9", "publish_date": "August 7, 2016", "AV": "NETWORK", "AC": "HIGH", "PR": "NONE", "UI": "NONE", "S": "UNCHANGED", "C": "NONE", "I": "NONE", "A": "HIGH", "commit_id": "b6d838eebf4456192360654092e5587c5207f185", "commit_message": "Sanity check eapol_len in AirPDcapDecryptWPABroadcastKey\n\nBug: 12175\nChange-Id: Iaf977ba48f8668bf8095800a115ff9a3472dd893\nReviewed-on: https://code.wireshark.org/review/15326\nPetri-Dish: Michael Mann <mmann78@netscape.net>\nTested-by: Petri Dish Buildbot <buildbot-no-reply@wireshark.org>\nReviewed-by: Alexis La Goutte <alexis.lagoutte@gmail.com>\nReviewed-by: Peter Wu <peter@lekensteyn.nl>\nTested-by: Peter Wu <peter@lekensteyn.nl>", "commit_date": "2016-05-10T15:20:49Z", "project": "wireshark/wireshark", "url": "https://api.github.com/repos/wireshark/wireshark/commits/b6d838eebf4456192360654092e5587c5207f185", "html_url": "https://github.com/wireshark/wireshark/commit/b6d838eebf4456192360654092e5587c5207f185", "windows_before": "", "windows_after": "", "parents": [{"commit_id_before": "2bc2b3e686df39bb655c54b101b11537507fb5a3", "url_before": "https://api.github.com/repos/wireshark/wireshark/commits/2bc2b3e686df39bb655c54b101b11537507fb5a3", "html_url_before": "https://github.com/wireshark/wireshark/commit/2bc2b3e686df39bb655c54b101b11537507fb5a3"}], "details": [{"raw_url": "https://github.com/wireshark/wireshark/raw/b6d838eebf4456192360654092e5587c5207f185/epan/crypt/airpdcap.c", "patch": "@@ -351,7 +351,9 @@ AirPDcapDecryptWPABroadcastKey(const EAPOL_RSN_KEY *pEAPKey, guint8 *decryption_\n         }\n     }\n \n-    if (key_bytes_len < GROUP_KEY_MIN_LEN || key_bytes_len > eapol_len - sizeof(EAPOL_RSN_KEY)) {\n+    if ((key_bytes_len < GROUP_KEY_MIN_LEN) ||\n+        (eapol_len < sizeof(EAPOL_RSN_KEY)) ||\n+        (key_bytes_len > eapol_len - sizeof(EAPOL_RSN_KEY))) {\n         return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n     }\n ", "file_path": "files/2016_8\\59", "file_language": "c", "file_name": "epan/crypt/airpdcap.c", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}], "outdated": 0}
{"index": 21, "cve_id": "CVE-2016-5358", "cwe_id": ["CWE-20"], "cve_language": "C", "cve_description": "epan/dissectors/packet-pktap.c in the Ethernet dissector in Wireshark 2.x before 2.0.4 mishandles the packet-header data type, which allows remote attackers to cause a denial of service (application crash) via a crafted packet.", "cvss": "5.9", "publish_date": "August 7, 2016", "AV": "NETWORK", "AC": "HIGH", "PR": "NONE", "UI": "NONE", "S": "UNCHANGED", "C": "NONE", "I": "NONE", "A": "HIGH", "commit_id": "2c13e97d656c1c0ac4d76eb9d307664aae0e0cf7", "commit_message": "The WTAP_ENCAP_ETHERNET dissector needs to be passed a struct eth_phdr.\n\nWe now require that.  Make it so.\n\nBug: 12440\nChange-Id: Iffee520976b013800699bde3c6092a3e86be0d76\nReviewed-on: https://code.wireshark.org/review/15424\nReviewed-by: Guy Harris <guy@alum.mit.edu>", "commit_date": "2016-05-14T08:49:15Z", "project": "wireshark/wireshark", "url": "https://api.github.com/repos/wireshark/wireshark/commits/2c13e97d656c1c0ac4d76eb9d307664aae0e0cf7", "html_url": "https://github.com/wireshark/wireshark/commit/2c13e97d656c1c0ac4d76eb9d307664aae0e0cf7", "windows_before": "", "windows_after": "", "parents": [{"commit_id_before": "7d8c7230fe7f99a88b2fd27e53999c01c10bfa11", "url_before": "https://api.github.com/repos/wireshark/wireshark/commits/7d8c7230fe7f99a88b2fd27e53999c01c10bfa11", "html_url_before": "https://github.com/wireshark/wireshark/commit/7d8c7230fe7f99a88b2fd27e53999c01c10bfa11"}], "details": [{"raw_url": "https://github.com/wireshark/wireshark/raw/2c13e97d656c1c0ac4d76eb9d307664aae0e0cf7/epan/dissectors/packet-pktap.c", "patch": "@@ -135,6 +135,9 @@ dissect_pktap(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)\n \ttvbuff_t *next_tvb;\n \tint offset = 0;\n \tguint32 pkt_len, rectype, dlt;\n+\tint wtap_encap;\n+\tstruct eth_phdr eth;\n+\tvoid *phdr;\n \n \tcol_set_str(pinfo->cinfo, COL_PROTOCOL, \"PKTAP\");\n \tcol_clear(pinfo->cinfo, COL_INFO);\n@@ -202,8 +205,20 @@ dissect_pktap(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)\n \n \tif (rectype == PKT_REC_PACKET) {\n \t\tnext_tvb = tvb_new_subset_remaining(tvb, pkt_len);\n-\t\tdissector_try_uint(wtap_encap_dissector_table,\n-\t\t    wtap_pcap_encap_to_wtap_encap(dlt), next_tvb, pinfo, tree);\n+\t\twtap_encap = wtap_pcap_encap_to_wtap_encap(dlt);\n+\t\tswitch (wtap_encap) {\n+\n+\t\tcase WTAP_ENCAP_ETHERNET:\n+\t\t\teth.fcs_len = -1;    /* Unknown whether we have an FCS */\n+\t\t\tphdr = &eth;\n+\t\t\tbreak;\n+\n+\t\tdefault:\n+\t\t\tphdr = NULL;\n+\t\t\tbreak;\n+\t\t}\n+\t\tdissector_try_uint_new(wtap_encap_dissector_table,\n+\t\t    wtap_encap, next_tvb, pinfo, tree, TRUE, phdr);\n \t}\n }\n ", "file_path": "files/2016_8\\60", "file_language": "c", "file_name": "epan/dissectors/packet-pktap.c", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}, {"raw_url": "https://github.com/wireshark/wireshark/raw/2c13e97d656c1c0ac4d76eb9d307664aae0e0cf7/epan/dissectors/packet-ppi.c", "patch": "@@ -857,6 +857,9 @@ dissect_ppi(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)\n     guint          last_frame  = 0;\n     gint len_remain, /*pad_len = 0,*/ ampdu_len = 0;\n     struct ieee_802_11_phdr phdr;\n+    int            wtap_encap;\n+    struct eth_phdr eth;\n+    void          *phdrp;\n \n     col_set_str(pinfo->cinfo, COL_PROTOCOL, \"PPI\");\n     col_clear(pinfo->cinfo, COL_INFO);\n@@ -1137,8 +1140,20 @@ dissect_ppi(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)\n         call_dissector_with_data(ieee80211_radio_handle, next_tvb, pinfo, tree, &phdr);\n     } else {\n         /* Everything else.  This will pass a NULL data argument. */\n-        dissector_try_uint(wtap_encap_dissector_table,\n-            wtap_pcap_encap_to_wtap_encap(dlt), next_tvb, pinfo, tree);\n+        wtap_encap = wtap_pcap_encap_to_wtap_encap(dlt);\n+        switch (wtap_encap) {\n+\n+        case WTAP_ENCAP_ETHERNET:\n+            eth.fcs_len = -1;    /* Unknown whether we have an FCS */\n+            phdrp = &eth;\n+            break;\n+\n+        default:\n+            phdrp = NULL;\n+            break;\n+        }\n+        dissector_try_uint_new(wtap_encap_dissector_table,\n+            wtap_encap, next_tvb, pinfo, tree, TRUE, phdrp);\n     }\n }\n ", "file_path": "files/2016_8\\61", "file_language": "c", "file_name": "epan/dissectors/packet-ppi.c", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}, {"raw_url": "https://github.com/wireshark/wireshark/raw/2c13e97d656c1c0ac4d76eb9d307664aae0e0cf7/epan/dissectors/packet-rpcap.c", "patch": "@@ -838,6 +838,8 @@ dissect_rpcap_packet (tvbuff_t *tvb, packet_info *pinfo, proto_tree *top_tree,\n   tvbuff_t *new_tvb;\n   guint caplen, len, frame_no;\n   gint reported_length_remaining;\n+  struct eth_phdr eth;\n+  void *phdr;\n \n   ti = proto_tree_add_item (parent_tree, hf_packet, tvb, offset, 20, ENC_NA);\n   tree = proto_item_add_subtree (ti, ett_packet);\n@@ -874,7 +876,18 @@ dissect_rpcap_packet (tvbuff_t *tvb, packet_info *pinfo, proto_tree *top_tree,\n \n   new_tvb = tvb_new_subset (tvb, offset, caplen, len);\n   if (decode_content && linktype != WTAP_ENCAP_UNKNOWN) {\n-    dissector_try_uint(wtap_encap_dissector_table, linktype, new_tvb, pinfo, top_tree);\n+    switch (linktype) {\n+\n+    case WTAP_ENCAP_ETHERNET:\n+      eth.fcs_len = -1;    /* Unknown whether we have an FCS */\n+      phdr = &eth;\n+      break;\n+\n+    default:\n+      phdr = NULL;\n+      break;\n+    }\n+    dissector_try_uint_new(wtap_encap_dissector_table, linktype, new_tvb, pinfo, top_tree, TRUE, phdr);\n \n     if (!info_added) {\n       /* Only indicate when not added before */", "file_path": "files/2016_8\\62", "file_language": "c", "file_name": "epan/dissectors/packet-rpcap.c", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}], "outdated": 0}
{"index": 22, "cve_id": "CVE-2016-6128", "cwe_id": ["CWE-20"], "cve_language": "C", "cve_description": "The gdImageCropThreshold function in gd_crop.c in the GD Graphics Library (aka libgd) before 2.2.3, as used in PHP before 7.0.9, allows remote attackers to cause a denial of service (application crash) via an invalid color index.", "cvss": "7.5", "publish_date": "August 7, 2016", "AV": "NETWORK", "AC": "LOW", "PR": "NONE", "UI": "NONE", "S": "UNCHANGED", "C": "NONE", "I": "NONE", "A": "HIGH", "commit_id": "6ff72ae40c7c20ece939afb362d98cc37f4a1c96", "commit_message": "fix php 72494, invalid color index not handled, can lead to crash", "commit_date": "2016-06-27T04:42:44Z", "project": "libgd/libgd", "url": "https://api.github.com/repos/libgd/libgd/commits/6ff72ae40c7c20ece939afb362d98cc37f4a1c96", "html_url": "https://github.com/libgd/libgd/commit/6ff72ae40c7c20ece939afb362d98cc37f4a1c96", "windows_before": "", "windows_after": "", "parents": [{"commit_id_before": "bca12e4e11ecda8a0ea719472700ad5c2b36a0d6", "url_before": "https://api.github.com/repos/libgd/libgd/commits/bca12e4e11ecda8a0ea719472700ad5c2b36a0d6", "html_url_before": "https://github.com/libgd/libgd/commit/bca12e4e11ecda8a0ea719472700ad5c2b36a0d6"}], "details": [{"raw_url": "https://github.com/libgd/libgd/raw/6ff72ae40c7c20ece939afb362d98cc37f4a1c96/tests/gdimagecrop/php_bug_72494.c", "patch": "@@ -0,0 +1,23 @@\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include \"gd.h\"\n+\n+#include \"gdtest.h\"\n+\n+int main()\n+{\n+\tgdImagePtr im, exp;\n+\tint error = 0;\n+\n+\tim = gdImageCreate(50, 50);\n+\n+\tif (!im) {\n+\t\tgdTestErrorMsg(\"gdImageCreate failed.\\n\");\n+\t\treturn 1;\n+\t}\n+\n+\tgdImageCropThreshold(im, 1337, 0);\n+\tgdImageDestroy(im);\n+\t/* this bug tests a crash, it never reaches this point if the bug exists*/\n+\treturn 0;\n+}", "file_path": "files/2016_8\\63", "file_language": "c", "file_name": "tests/gdimagecrop/php_bug_72494.c", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}], "outdated": 0}
{"index": 23, "cve_id": "CVE-2016-6128", "cwe_id": ["CWE-20"], "cve_language": "C", "cve_description": "The gdImageCropThreshold function in gd_crop.c in the GD Graphics Library (aka libgd) before 2.2.3, as used in PHP before 7.0.9, allows remote attackers to cause a denial of service (application crash) via an invalid color index.", "cvss": "7.5", "publish_date": "August 7, 2016", "AV": "NETWORK", "AC": "LOW", "PR": "NONE", "UI": "NONE", "S": "UNCHANGED", "C": "NONE", "I": "NONE", "A": "HIGH", "commit_id": "1ccfe21e14c4d18336f9da8515cd17db88c3de61", "commit_message": "fix php 72494, invalid color index not handled, can lead to crash", "commit_date": "2016-06-27T04:41:40Z", "project": "libgd/libgd", "url": "https://api.github.com/repos/libgd/libgd/commits/1ccfe21e14c4d18336f9da8515cd17db88c3de61", "html_url": "https://github.com/libgd/libgd/commit/1ccfe21e14c4d18336f9da8515cd17db88c3de61", "windows_before": "", "windows_after": "", "parents": [{"commit_id_before": "3fe0a7128bac5000fdcfab888bd2a75ec0c9447d", "url_before": "https://api.github.com/repos/libgd/libgd/commits/3fe0a7128bac5000fdcfab888bd2a75ec0c9447d", "html_url_before": "https://github.com/libgd/libgd/commit/3fe0a7128bac5000fdcfab888bd2a75ec0c9447d"}], "details": [{"raw_url": "https://github.com/libgd/libgd/raw/1ccfe21e14c4d18336f9da8515cd17db88c3de61/src/gd_crop.c", "patch": "@@ -136,6 +136,10 @@ BGD_DECLARE(gdImagePtr) gdImageCropThreshold(gdImagePtr im, const unsigned int c\n \t\treturn NULL;\n \t}\n \n+\tif (color < 0 || (!gdImageTrueColor(im) && color >= gdImageColorsTotal(im))) {\n+\t\treturn NULL;\n+\t}\n+\n \t/* TODO: Add gdImageGetRowPtr and works with ptr at the row level\n \t * for the true color and palette images\n \t * new formats will simply work with ptr", "file_path": "files/2016_8\\64", "file_language": "c", "file_name": "src/gd_crop.c", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}, {"raw_url": "https://github.com/libgd/libgd/raw/1ccfe21e14c4d18336f9da8515cd17db88c3de61/tests/CMakeLists.txt", "patch": "@@ -31,6 +31,7 @@ if (BUILD_TEST)\n \t\tgdimagecolortransparent\n \t\tgdimagecopy\n \t\tgdimagecopyrotated\n+        gdimagecrop\n \t\tgdimagefile\n \t\tgdimagefill\n \t\tgdimagefilledellipse", "file_path": "files/2016_8\\65", "file_language": "txt", "file_name": "tests/CMakeLists.txt", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}, {"raw_url": "https://github.com/libgd/libgd/raw/1ccfe21e14c4d18336f9da8515cd17db88c3de61/tests/Makefile.am", "patch": "@@ -25,6 +25,7 @@ include gdimagecolorresolve/Makemodule.am\n include gdimagecolortransparent/Makemodule.am\n include gdimagecopy/Makemodule.am\n include gdimagecopyrotated/Makemodule.am\n+include gdimagecrop/Makemodule.am\n include gdimagefile/Makemodule.am\n include gdimagefill/Makemodule.am\n include gdimagefilledellipse/Makemodule.am", "file_path": "files/2016_8\\66", "file_language": "am", "file_name": "tests/Makefile.am", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}], "outdated": 0}
{"index": 24, "cve_id": "CVE-2016-5767", "cwe_id": ["CWE-190"], "cve_language": "C", "cve_description": "Integer overflow in the gdImageCreate function in gd.c in the GD Graphics Library (aka libgd) before 2.0.34RC1, as used in PHP before 5.5.37, 5.6.x before 5.6.23, and 7.x before 7.0.8, allows remote attackers to cause a denial of service (heap-based buffer overflow and application crash) or possibly have unspecified other impact via a crafted image dimensions.", "cvss": "8.8", "publish_date": "August 7, 2016", "AV": "NETWORK", "AC": "LOW", "PR": "NONE", "UI": "REQUIRED", "S": "UNCHANGED", "C": "HIGH", "I": "HIGH", "A": "HIGH", "commit_id": "7a1aac3343af85b4af4df5f8844946eaa27394ab", "commit_message": "Fixed bug #72227: imagescale out-of-bounds read\n\nPorted from https://github.com/libgd/libgd/commit/4f65a3e4eedaffa1efcf9ee1eb08f0b504fbc31a", "commit_date": "2016-05-23T07:34:35Z", "project": "php/php-src", "url": "https://api.github.com/repos/php/php-src/commits/7a1aac3343af85b4af4df5f8844946eaa27394ab", "html_url": "https://github.com/php/php-src/commit/7a1aac3343af85b4af4df5f8844946eaa27394ab", "windows_before": "", "windows_after": "", "parents": [{"commit_id_before": "97eff7eb57fc2320c267a949cffd622c38712484", "url_before": "https://api.github.com/repos/php/php-src/commits/97eff7eb57fc2320c267a949cffd622c38712484", "html_url_before": "https://github.com/php/php-src/commit/97eff7eb57fc2320c267a949cffd622c38712484"}], "details": [{"raw_url": "https://github.com/php/php-src/raw/7a1aac3343af85b4af4df5f8844946eaa27394ab/ext/gd/libgd/gd_interpolation.c", "patch": "@@ -39,8 +39,8 @@\n \tdownscaling using the fixed point implementations are usually much faster\n \tthan the existing gdImageCopyResampled while having a similar or better\n \tquality.\n-\t\n-\tFor image rotations, the optimized versions have a lazy antialiasing for \n+\n+\tFor image rotations, the optimized versions have a lazy antialiasing for\n \tthe edges of the images. For a much better antialiased result, the affine\n \tfunction is recommended.\n */\n@@ -633,7 +633,7 @@ static inline int _color_blend (const int dst, const int src)\n \t}\n }\n \n-static inline int _setEdgePixel(const gdImagePtr src, unsigned int x, unsigned int y, gdFixed coverage, const int bgColor) \n+static inline int _setEdgePixel(const gdImagePtr src, unsigned int x, unsigned int y, gdFixed coverage, const int bgColor)\n {\n \tconst gdFixed f_127 = gd_itofx(127);\n \tregister int c = src->tpixels[y][x];\n@@ -934,9 +934,6 @@ static inline LineContribType *_gdContributionsCalc(unsigned int line_size, unsi\n         double dTotalWeight = 0.0;\n \t\tint iSrc;\n \n-        res->ContribRow[u].Left = iLeft;\n-        res->ContribRow[u].Right = iRight;\n-\n         /* Cut edge points to fit in filter window in case of spill-off */\n         if (iRight - iLeft + 1 > windows_size)  {\n             if (iLeft < ((int)src_size - 1 / 2))  {\n@@ -946,6 +943,9 @@ static inline LineContribType *_gdContributionsCalc(unsigned int line_size, unsi\n             }\n         }\n \n+        res->ContribRow[u].Left = iLeft;\n+        res->ContribRow[u].Right = iRight;\n+\n         for (iSrc = iLeft; iSrc <= iRight; iSrc++) {\n             dTotalWeight += (res->ContribRow[u].Weights[iSrc-iLeft] =  scale_f_d * (*pFilter)(scale_f_d * (dCenter - (double)iSrc)));\n         }\n@@ -2273,7 +2273,7 @@ int gdTransformAffineGetImage(gdImagePtr *dst,\n \tif (!src->trueColor) {\n \t\tgdImagePaletteToTrueColor(src);\n \t}\n-\t\n+\n \t/* Translate to dst origin (0,0) */\n \tgdAffineTranslate(m, -bbox.x, -bbox.y);\n \tgdAffineConcat(m, affine, m);\n@@ -2332,7 +2332,7 @@ int gdTransformAffineCopy(gdImagePtr dst,\n \tif (src->interpolation_id == GD_BILINEAR_FIXED || src->interpolation_id == GD_BICUBIC_FIXED || src->interpolation_id == GD_NEAREST_NEIGHBOUR) {\n \t\tinterpolation_id_bak = src->interpolation_id;\n \t\tinterpolation_bak = src->interpolation;\n-\t\t\n+\n \t\tgdImageSetInterpolationMethod(src, GD_BICUBIC);\n \t}\n ", "file_path": "files/2016_8\\67", "file_language": "c", "file_name": "ext/gd/libgd/gd_interpolation.c", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}, {"raw_url": "https://github.com/php/php-src/raw/7a1aac3343af85b4af4df5f8844946eaa27394ab/ext/gd/tests/bug72227.phpt", "patch": "@@ -0,0 +1,15 @@\n+--TEST--\n+Bug #72227: imagescale out-of-bounds read\n+--SKIPIF--\n+<?php\n+\tif (!extension_loaded('gd')) die(\"skip gd extension not available\\n\");\n+?>\n+--FILE--\n+<?php\n+\n+$img = imagecreatetruecolor ( 100, 100);\n+imagescale($img, 13, 1, IMG_BICUBIC);\n+?>\n+DONE\n+--EXPECT--\n+DONE\n\\ No newline at end of file", "file_path": "files/2016_8\\68", "file_language": "phpt", "file_name": "ext/gd/tests/bug72227.phpt", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}], "outdated": 0}
{"index": 25, "cve_id": "CVE-2013-7456", "cwe_id": ["CWE-125"], "cve_language": "C", "cve_description": "gd_interpolation.c in the GD Graphics Library (aka libgd) before 2.1.1, as used in PHP before 5.5.36, 5.6.x before 5.6.22, and 7.x before 7.0.7, allows remote attackers to cause a denial of service (out-of-bounds read) or possibly have unspecified other impact via a crafted image that is mishandled by the imagescale function.", "cvss": "7.6", "publish_date": "August 7, 2016", "AV": "NETWORK", "AC": "LOW", "PR": "NONE", "UI": "REQUIRED", "S": "UNCHANGED", "C": "LOW", "I": "LOW", "A": "HIGH", "commit_id": "4f65a3e4eedaffa1efcf9ee1eb08f0b504fbc31a", "commit_message": "Fixed memory overrun bug in gdImageScaleTwoPass\n\n_gdContributionsCalc would compute a window size and then adjust\nthe left and right positions of the window to make a window within\nthat size.  However, it was storing the values in the struct *before*\nit made the adjustment.  This change fixes that.", "commit_date": "2013-09-23T22:03:08Z", "project": "libgd/libgd", "url": "https://api.github.com/repos/libgd/libgd/commits/4f65a3e4eedaffa1efcf9ee1eb08f0b504fbc31a", "html_url": "https://github.com/libgd/libgd/commit/4f65a3e4eedaffa1efcf9ee1eb08f0b504fbc31a", "windows_before": "", "windows_after": "", "parents": [{"commit_id_before": "3e76d309d00f15944da974287b058556c55b1748", "url_before": "https://api.github.com/repos/libgd/libgd/commits/3e76d309d00f15944da974287b058556c55b1748", "html_url_before": "https://github.com/libgd/libgd/commit/3e76d309d00f15944da974287b058556c55b1748"}], "details": [{"raw_url": "https://github.com/libgd/libgd/raw/4f65a3e4eedaffa1efcf9ee1eb08f0b504fbc31a/src/gd_interpolation.c", "patch": "@@ -953,9 +953,6 @@ static inline LineContribType *_gdContributionsCalc(unsigned int line_size, unsi\n \t\tdouble dTotalWeight = 0.0;\n \t\tint iSrc;\n \n-\t\tres->ContribRow[u].Left = iLeft;\n-\t\tres->ContribRow[u].Right = iRight;\n-\n \t\t/* Cut edge points to fit in filter window in case of spill-off */\n \t\tif (iRight - iLeft + 1 > windows_size)  {\n \t\t\tif (iLeft < ((int)src_size - 1 / 2))  {\n@@ -965,6 +962,9 @@ static inline LineContribType *_gdContributionsCalc(unsigned int line_size, unsi\n \t\t\t}\n \t\t}\n \n+\t\tres->ContribRow[u].Left = iLeft;\n+\t\tres->ContribRow[u].Right = iRight;\n+\n \t\tfor (iSrc = iLeft; iSrc <= iRight; iSrc++) {\n \t\t\tdTotalWeight += (res->ContribRow[u].Weights[iSrc-iLeft] =  scale_f_d * (*pFilter)(scale_f_d * (dCenter - (double)iSrc)));\n \t\t}", "file_path": "files/2016_8\\69", "file_language": "c", "file_name": "src/gd_interpolation.c", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}], "outdated": 0}
{"index": 26, "cve_id": "CVE-2016-5769", "cwe_id": ["CWE-190"], "cve_language": "C", "cve_description": "Multiple integer overflows in mcrypt.c in the mcrypt extension in PHP before 5.5.37, 5.6.x before 5.6.23, and 7.x before 7.0.8 allow remote attackers to cause a denial of service (heap-based buffer overflow and application crash) or possibly have unspecified other impact via a crafted length value, related to the (1) mcrypt_generic and (2) mdecrypt_generic functions.", "cvss": "9.8", "publish_date": "August 7, 2016", "AV": "NETWORK", "AC": "LOW", "PR": "NONE", "UI": "NONE", "S": "UNCHANGED", "C": "HIGH", "I": "HIGH", "A": "HIGH", "commit_id": "3b8d4de300854b3517c7acb239b84f7726c1353c", "commit_message": "Fix bug #71923 - integer overflow in ZipArchive::getFrom*", "commit_date": "2016-04-27T15:51:54Z", "project": "php/php-src", "url": "https://api.github.com/repos/php/php-src/commits/3b8d4de300854b3517c7acb239b84f7726c1353c", "html_url": "https://github.com/php/php-src/commit/3b8d4de300854b3517c7acb239b84f7726c1353c", "windows_before": "", "windows_after": "", "parents": [{"commit_id_before": "7133f28df57cef51076d5045b006c5c75c664728", "url_before": "https://api.github.com/repos/php/php-src/commits/7133f28df57cef51076d5045b006c5c75c664728", "html_url_before": "https://github.com/php/php-src/commit/7133f28df57cef51076d5045b006c5c75c664728"}], "details": [{"raw_url": "https://github.com/php/php-src/raw/3b8d4de300854b3517c7acb239b84f7726c1353c/ext/zip/php_zip.c", "patch": "@@ -1281,7 +1281,7 @@ static PHP_NAMED_FUNCTION(zif_zip_entry_read)\n \t}\n \n \tif (zr_rsrc->zf) {\n-\t\tbuffer = zend_string_alloc(len, 0);\n+\t\tbuffer = zend_string_safe_alloc(1, len, 0, 0);\n \t\tn = zip_fread(zr_rsrc->zf, ZSTR_VAL(buffer), ZSTR_LEN(buffer));\n \t\tif (n > 0) {\n \t\t\tZSTR_VAL(buffer)[n] = '\\0';\n@@ -2728,7 +2728,7 @@ static void php_zip_get_from(INTERNAL_FUNCTION_PARAMETERS, int type) /* {{{ */\n \t\tRETURN_FALSE;\n \t}\n \n-\tbuffer = zend_string_alloc(len, 0);\n+\tbuffer = zend_string_safe_alloc(1, len, 0, 0);\n \tn = zip_fread(zf, ZSTR_VAL(buffer), ZSTR_LEN(buffer));\n \tif (n < 1) {\n \t\tzend_string_free(buffer);", "file_path": "files/2016_8\\70", "file_language": "c", "file_name": "ext/zip/php_zip.c", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}], "outdated": 0}
{"index": 27, "cve_id": "CVE-2016-5771", "cwe_id": ["CWE-416"], "cve_language": "C", "cve_description": "spl_array.c in the SPL extension in PHP before 5.5.37 and 5.6.x before 5.6.23 improperly interacts with the unserialize implementation and garbage collection, which allows remote attackers to execute arbitrary code or cause a denial of service (use-after-free and application crash) via crafted serialized data.", "cvss": "9.8", "publish_date": "August 7, 2016", "AV": "NETWORK", "AC": "LOW", "PR": "NONE", "UI": "NONE", "S": "UNCHANGED", "C": "HIGH", "I": "HIGH", "A": "HIGH", "commit_id": "996faf964bba1aec06b153b370a7f20d3dd2bb8b", "commit_message": "Update header handling to RFC 7230", "commit_date": "2015-02-18T10:34:53Z", "project": "php/php-src", "url": "https://api.github.com/repos/php/php-src/commits/996faf964bba1aec06b153b370a7f20d3dd2bb8b", "html_url": "https://github.com/php/php-src/commit/996faf964bba1aec06b153b370a7f20d3dd2bb8b", "windows_before": "", "windows_after": "", "parents": [{"commit_id_before": "d8bc34942d4f94cecdcbc63aa0772c5717525279", "url_before": "https://api.github.com/repos/php/php-src/commits/d8bc34942d4f94cecdcbc63aa0772c5717525279", "html_url_before": "https://github.com/php/php-src/commit/d8bc34942d4f94cecdcbc63aa0772c5717525279"}], "details": [{"raw_url": "https://github.com/php/php-src/raw/996faf964bba1aec06b153b370a7f20d3dd2bb8b/ext/standard/tests/general_functions/bug60227_2.phpt", "patch": "@@ -1,14 +1,15 @@\n --TEST--\n Bug #60227 (header() cannot detect the multi-line header with CR), \\r before \\n\n+--INI--\n+expose_php=0\n --FILE--\n <?php\n header(\"X-foo: e\\n foo\");\n-header(\"X-Foo6: e\\rSet-Cookie: ID=123\\n d\");\n echo 'foo';\n ?>\n --EXPECTF--\n+\n Warning: Header may not contain more than a single header, new line detected in %s on line %d\n foo\n --EXPECTHEADERS--\n-X-foo: e\n-foo\n+Content-type: text/html; charset=UTF-8", "file_path": "files/2016_8\\71", "file_language": "phpt", "file_name": "ext/standard/tests/general_functions/bug60227_2.phpt", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}, {"raw_url": "https://github.com/php/php-src/raw/996faf964bba1aec06b153b370a7f20d3dd2bb8b/ext/standard/tests/general_functions/bug60227_3.phpt", "patch": "@@ -1,14 +1,14 @@\n --TEST--\n Bug #60227 (header() cannot detect the multi-line header with CR), \\0 before \\n\n+--INI--\n+expose_php=0\n --FILE--\n <?php\n-header(\"X-foo: e\\n foo\");\n header(\"X-Foo6: e\\0Set-Cookie: ID=\\n123\\n d\");\n echo 'foo';\n ?>\n --EXPECTF--\n Warning: Header may not contain NUL bytes in %s on line %d\n foo\n --EXPECTHEADERS--\n-X-foo: e\n-foo\n+Content-type: text/html; charset=UTF-8", "file_path": "files/2016_8\\72", "file_language": "phpt", "file_name": "ext/standard/tests/general_functions/bug60227_3.phpt", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}, {"raw_url": "https://github.com/php/php-src/raw/996faf964bba1aec06b153b370a7f20d3dd2bb8b/ext/standard/tests/general_functions/bug60227_4.phpt", "patch": "@@ -1,14 +1,14 @@\n --TEST--\n Bug #60227 (header() cannot detect the multi-line header with CR), CRLF\n+--INI--\n+expose_php=0\n --FILE--\n <?php\n-header(\"X-foo: e\\r\\n foo\");\n header(\"X-foo: e\\r\\nfoo\");\n echo 'foo';\n ?>\n --EXPECTF--\n Warning: Header may not contain more than a single header, new line detected in %s on line %d\n foo\n --EXPECTHEADERS--\n-X-foo: e\n- foo\n+Content-type: text/html; charset=UTF-8", "file_path": "files/2016_8\\73", "file_language": "phpt", "file_name": "ext/standard/tests/general_functions/bug60227_4.phpt", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}, {"raw_url": "https://github.com/php/php-src/raw/996faf964bba1aec06b153b370a7f20d3dd2bb8b/main/SAPI.c", "patch": "@@ -743,13 +743,8 @@ SAPI_API int sapi_header_op(sapi_header_op_enum op, void *arg TSRMLS_DC)\n \t\t/* new line/NUL character safety check */\n \t\tint i;\n \t\tfor (i = 0; i < header_line_len; i++) {\n-\t\t\t/* RFC 2616 allows new lines if followed by SP or HT */\n-\t\t\tint illegal_break =\n-\t\t\t\t\t(header_line[i+1] != ' ' && header_line[i+1] != '\\t')\n-\t\t\t\t\t&& (\n-\t\t\t\t\t\theader_line[i] == '\\n'\n-\t\t\t\t\t\t|| (header_line[i] == '\\r' && header_line[i+1] != '\\n'));\n-\t\t\tif (illegal_break) {\n+\t\t\t/* RFC 7230 ch. 3.2.4 deprecates folding support */\n+\t\t\tif (header_line[i] == '\\n' || header_line[i] == '\\r') {\n \t\t\t\tefree(header_line);\n \t\t\t\tsapi_module.sapi_error(E_WARNING, \"Header may not contain \"\n \t\t\t\t\t\t\"more than a single header, new line detected\");", "file_path": "files/2016_8\\74", "file_language": "c", "file_name": "main/SAPI.c", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}], "outdated": 0}
{"index": 28, "cve_id": "CVE-2016-3078", "cwe_id": ["CWE-190"], "cve_language": "C", "cve_description": "Multiple integer overflows in php_zip.c in the zip extension in PHP before 7.0.6 allow remote attackers to cause a denial of service (heap-based buffer overflow and application crash) or possibly have unspecified other impact via a crafted call to (1) getFromIndex or (2) getFromName in the ZipArchive class.", "cvss": "9.8", "publish_date": "August 7, 2016", "AV": "NETWORK", "AC": "LOW", "PR": "NONE", "UI": "NONE", "S": "UNCHANGED", "C": "HIGH", "I": "HIGH", "A": "HIGH", "commit_id": "97eff7eb57fc2320c267a949cffd622c38712484", "commit_message": "Fix bug #72241: get_icu_value_internal out-of-bounds read", "commit_date": "2016-05-23T00:49:02Z", "project": "php/php-src", "url": "https://api.github.com/repos/php/php-src/commits/97eff7eb57fc2320c267a949cffd622c38712484", "html_url": "https://github.com/php/php-src/commit/97eff7eb57fc2320c267a949cffd622c38712484", "windows_before": "", "windows_after": "", "parents": [{"commit_id_before": "0da8b8b801f9276359262f1ef8274c7812d3dfda", "url_before": "https://api.github.com/repos/php/php-src/commits/0da8b8b801f9276359262f1ef8274c7812d3dfda", "html_url_before": "https://github.com/php/php-src/commit/0da8b8b801f9276359262f1ef8274c7812d3dfda"}], "details": [{"raw_url": "https://github.com/php/php-src/raw/97eff7eb57fc2320c267a949cffd622c38712484/ext/intl/locale/locale_methods.c", "patch": "@@ -65,26 +65,26 @@ ZEND_EXTERN_MODULE_GLOBALS( intl )\n */\n static const char * const LOC_GRANDFATHERED[] = {\n \t\"art-lojban\",\t\t\"i-klingon\",\t\t\"i-lux\",\t\t\t\"i-navajo\",\t\t\"no-bok\",\t\t\"no-nyn\",\n-\t\"cel-gaulish\",\t\t\"en-GB-oed\",\t\t\"i-ami\", \t\t\n-\t\"i-bnn\",\t\t\"i-default\",\t\t\"i-enochian\",\t\n-\t\"i-mingo\",\t\t\"i-pwn\", \t\t\"i-tao\", \n+\t\"cel-gaulish\",\t\t\"en-GB-oed\",\t\t\"i-ami\",\n+\t\"i-bnn\",\t\t\"i-default\",\t\t\"i-enochian\",\n+\t\"i-mingo\",\t\t\"i-pwn\", \t\t\"i-tao\",\n \t\"i-tay\",\t\t\"i-tsu\",\t\t\"sgn-BE-fr\",\n \t\"sgn-BE-nl\",\t\t\"sgn-CH-de\", \t\t\"zh-cmn\",\n  \t\"zh-cmn-Hans\", \t\t\"zh-cmn-Hant\",\t\t\"zh-gan\" ,\n \t\"zh-guoyu\", \t\t\"zh-hakka\", \t\t\"zh-min\",\n-\t\"zh-min-nan\", \t\t\"zh-wuu\", \t\t\"zh-xiang\",\t\n+\t\"zh-min-nan\", \t\t\"zh-wuu\", \t\t\"zh-xiang\",\n \t\"zh-yue\",\t\tNULL\n };\n \n /* Based on IANA registry at the time of writing this code\n *  This array lists the preferred values for the grandfathered tags if applicable\n-*  This is in sync with the array LOC_GRANDFATHERED\t \n+*  This is in sync with the array LOC_GRANDFATHERED\n *  e.g. the offsets of the grandfathered tags match the offset of the preferred  value\n */\n static const int \t\tLOC_PREFERRED_GRANDFATHERED_LEN = 6;\n static const char * const \tLOC_PREFERRED_GRANDFATHERED[]  = {\n \t\"jbo\",\t\t\t\"tlh\",\t\t\t\"lb\",\n-\t\"nv\", \t\t\t\"nb\",\t\t\t\"nn\",\t\t\t\n+\t\"nv\", \t\t\t\"nb\",\t\t\t\"nn\",\n \tNULL\n };\n \n@@ -122,7 +122,7 @@ static int16_t findOffset(const char* const* list, const char* key)\n /*}}}*/\n \n static char* getPreferredTag(const char* gf_tag)\n-{ \n+{\n \tchar* result = NULL;\n \tint grOffset = 0;\n \n@@ -141,15 +141,15 @@ static char* getPreferredTag(const char* gf_tag)\n }\n \n /* {{{\n-* returns the position of next token for lookup \n+* returns the position of next token for lookup\n * or -1 if no token\n-* strtokr equivalent search for token in reverse direction \n+* strtokr equivalent search for token in reverse direction\n */\n static int getStrrtokenPos(char* str, int savedPos)\n {\n \tint result =-1;\n \tint i;\n-\t\n+\n \tfor(i=savedPos-1; i>=0; i--) {\n \t\tif(isIDSeparator(*(str+i)) ){\n \t\t\t/* delimiter found; check for singleton */\n@@ -171,7 +171,7 @@ static int getStrrtokenPos(char* str, int savedPos)\n /* }}} */\n \n /* {{{\n-* returns the position of a singleton if present \n+* returns the position of a singleton if present\n * returns -1 if no singleton\n * strtok equivalent search for singleton\n */\n@@ -180,7 +180,7 @@ static int getSingletonPos(const char* str)\n \tint result =-1;\n \tint i=0;\n \tint len = 0;\n-\t\n+\n \tif( str && ((len=strlen(str))>0) ){\n \t\tfor( i=0; i<len ; i++){\n \t\t\tif( isIDSeparator(*(str+i)) ){\n@@ -198,7 +198,7 @@ static int getSingletonPos(const char* str)\n \t\t\t\t}\n \t\t\t}\n \t\t}/* end of for */\n-\t\t\n+\n \t}\n \treturn result;\n }\n@@ -224,7 +224,7 @@ PHP_NAMED_FUNCTION(zif_locale_get_default)\n PHP_NAMED_FUNCTION(zif_locale_set_default)\n {\n \tchar* locale_name = NULL;\n-\tint   len=0;\t\n+\tint   len=0;\n \n \tif(zend_parse_parameters( ZEND_NUM_ARGS() TSRMLS_CC,  \"s\",\n \t\t&locale_name ,&len ) == FAILURE)\n@@ -240,14 +240,14 @@ PHP_NAMED_FUNCTION(zif_locale_set_default)\n \t\tlen = strlen(locale_name);\n \t}\n \n-\tzend_alter_ini_entry(LOCALE_INI_NAME, sizeof(LOCALE_INI_NAME), locale_name, len, PHP_INI_USER, PHP_INI_STAGE_RUNTIME);\t\n+\tzend_alter_ini_entry(LOCALE_INI_NAME, sizeof(LOCALE_INI_NAME), locale_name, len, PHP_INI_USER, PHP_INI_STAGE_RUNTIME);\n \n \tRETURN_TRUE;\n }\n /* }}} */\n \n /* {{{\n-* Gets the value from ICU \n+* Gets the value from ICU\n * common code shared by get_primary_language,get_script or get_region or get_variant\n * result = 0 if error, 1 if successful , -1 if no value\n */\n@@ -284,7 +284,7 @@ static char* get_icu_value_internal( const char* loc_name , char* tag_name, int*\n \t\t\t}\n \t\t}\n \n-\t\tsingletonPos = getSingletonPos( loc_name );\t\n+\t\tsingletonPos = getSingletonPos( loc_name );\n \t\tif( singletonPos == 0){\n \t\t\t/* singleton at start of script, region , variant etc.\n \t\t\t * or invalid singleton at start of language */\n@@ -299,7 +299,7 @@ static char* get_icu_value_internal( const char* loc_name , char* tag_name, int*\n \t} /* end of if != LOC_CANONICAL_TAG */\n \n \tif( mod_loc_name == NULL){\n-\t\tmod_loc_name = estrdup(loc_name );\t\n+\t\tmod_loc_name = estrdup(loc_name );\n \t}\n \n \t/* Proceed to ICU */\n@@ -326,6 +326,7 @@ static char* get_icu_value_internal( const char* loc_name , char* tag_name, int*\n \t\tif( U_FAILURE( status ) ) {\n \t\t\tif( status == U_BUFFER_OVERFLOW_ERROR ) {\n \t\t\t\tstatus = U_ZERO_ERROR;\n+\t\t\t\tbuflen++; /* add space for \\0 */\n \t\t\t\tcontinue;\n \t\t\t}\n \n@@ -366,7 +367,7 @@ static char* get_icu_value_internal( const char* loc_name , char* tag_name, int*\n * Gets the value from ICU , called when PHP userspace function is called\n * common code shared by get_primary_language,get_script or get_region or get_variant\n */\n-static void get_icu_value_src_php( char* tag_name, INTERNAL_FUNCTION_PARAMETERS) \n+static void get_icu_value_src_php( char* tag_name, INTERNAL_FUNCTION_PARAMETERS)\n {\n \n \tconst char* loc_name        \t= NULL;\n@@ -422,47 +423,47 @@ static void get_icu_value_src_php( char* tag_name, INTERNAL_FUNCTION_PARAMETERS)\n }\n /* }}} */\n \n-/* {{{ proto static string Locale::getScript($locale) \n- * gets the script for the $locale \n+/* {{{ proto static string Locale::getScript($locale)\n+ * gets the script for the $locale\n  }}} */\n-/* {{{ proto static string locale_get_script($locale) \n- * gets the script for the $locale \n+/* {{{ proto static string locale_get_script($locale)\n+ * gets the script for the $locale\n  */\n-PHP_FUNCTION( locale_get_script ) \n+PHP_FUNCTION( locale_get_script )\n {\n \tget_icu_value_src_php( LOC_SCRIPT_TAG , INTERNAL_FUNCTION_PARAM_PASSTHRU );\n }\n /* }}} */\n \n-/* {{{ proto static string Locale::getRegion($locale) \n- * gets the region for the $locale \n+/* {{{ proto static string Locale::getRegion($locale)\n+ * gets the region for the $locale\n  }}} */\n-/* {{{ proto static string locale_get_region($locale) \n- * gets the region for the $locale \n+/* {{{ proto static string locale_get_region($locale)\n+ * gets the region for the $locale\n  */\n-PHP_FUNCTION( locale_get_region ) \n+PHP_FUNCTION( locale_get_region )\n {\n \tget_icu_value_src_php( LOC_REGION_TAG , INTERNAL_FUNCTION_PARAM_PASSTHRU );\n }\n /* }}} */\n \n-/* {{{ proto static string Locale::getPrimaryLanguage($locale) \n- * gets the primary language for the $locale \n+/* {{{ proto static string Locale::getPrimaryLanguage($locale)\n+ * gets the primary language for the $locale\n  }}} */\n-/* {{{ proto static string locale_get_primary_language($locale) \n- * gets the primary language for the $locale \n+/* {{{ proto static string locale_get_primary_language($locale)\n+ * gets the primary language for the $locale\n  */\n-PHP_FUNCTION(locale_get_primary_language ) \n+PHP_FUNCTION(locale_get_primary_language )\n {\n \tget_icu_value_src_php( LOC_LANG_TAG , INTERNAL_FUNCTION_PARAM_PASSTHRU );\n }\n /* }}} */\n \n \n /* {{{\n- * common code shared by display_xyz functions to  get the value from ICU \n+ * common code shared by display_xyz functions to  get the value from ICU\n  }}} */\n-static void get_icu_disp_value_src_php( char* tag_name, INTERNAL_FUNCTION_PARAMETERS) \n+static void get_icu_disp_value_src_php( char* tag_name, INTERNAL_FUNCTION_PARAMETERS)\n {\n \tconst char* loc_name        \t= NULL;\n \tint         loc_name_len    \t= 0;\n@@ -488,7 +489,7 @@ static void get_icu_disp_value_src_php( char* tag_name, INTERNAL_FUNCTION_PARAME\n \tintl_error_reset( NULL TSRMLS_CC );\n \n \tif(zend_parse_parameters( ZEND_NUM_ARGS() TSRMLS_CC, \"s|s\",\n-\t\t&loc_name, &loc_name_len , \n+\t\t&loc_name, &loc_name_len ,\n \t\t&disp_loc_name ,&disp_loc_name_len ) == FAILURE)\n \t{\n \t\tspprintf(&msg , 0, \"locale_get_display_%s : unable to parse input params\", tag_name );\n@@ -525,7 +526,7 @@ static void get_icu_disp_value_src_php( char* tag_name, INTERNAL_FUNCTION_PARAME\n \tif( mod_loc_name==NULL ){\n \t\tmod_loc_name = estrdup( loc_name );\n \t}\n-\t\n+\n \t/* Check if disp_loc_name passed , if not use default locale */\n \tif( !disp_loc_name){\n \t\tdisp_loc_name = estrdup(intl_locale_get_default(TSRMLS_C));\n@@ -604,7 +605,7 @@ static void get_icu_disp_value_src_php( char* tag_name, INTERNAL_FUNCTION_PARAME\n /* {{{ proto static string get_display_name($locale[, $in_locale = null])\n * gets the name for the $locale in $in_locale or default_locale\n */\n-PHP_FUNCTION(locale_get_display_name) \n+PHP_FUNCTION(locale_get_display_name)\n {\n     get_icu_disp_value_src_php( DISP_NAME , INTERNAL_FUNCTION_PARAM_PASSTHRU );\n }\n@@ -616,7 +617,7 @@ PHP_FUNCTION(locale_get_display_name)\n /* {{{ proto static string get_display_language($locale[, $in_locale = null])\n * gets the language for the $locale in $in_locale or default_locale\n */\n-PHP_FUNCTION(locale_get_display_language) \n+PHP_FUNCTION(locale_get_display_language)\n {\n     get_icu_disp_value_src_php( LOC_LANG_TAG , INTERNAL_FUNCTION_PARAM_PASSTHRU );\n }\n@@ -628,7 +629,7 @@ PHP_FUNCTION(locale_get_display_language)\n /* {{{ proto static string get_display_script($locale, $in_locale = null)\n * gets the script for the $locale in $in_locale or default_locale\n */\n-PHP_FUNCTION(locale_get_display_script) \n+PHP_FUNCTION(locale_get_display_script)\n {\n     get_icu_disp_value_src_php( LOC_SCRIPT_TAG , INTERNAL_FUNCTION_PARAM_PASSTHRU );\n }\n@@ -640,7 +641,7 @@ PHP_FUNCTION(locale_get_display_script)\n /* {{{ proto static string get_display_region($locale, $in_locale = null)\n * gets the region for the $locale in $in_locale or default_locale\n */\n-PHP_FUNCTION(locale_get_display_region) \n+PHP_FUNCTION(locale_get_display_region)\n {\n     get_icu_disp_value_src_php( LOC_REGION_TAG , INTERNAL_FUNCTION_PARAM_PASSTHRU );\n }\n@@ -654,7 +655,7 @@ PHP_FUNCTION(locale_get_display_region)\n * proto static string get_display_variant($locale, $in_locale = null)\n * gets the variant for the $locale in $in_locale or default_locale\n */\n-PHP_FUNCTION(locale_get_display_variant) \n+PHP_FUNCTION(locale_get_display_variant)\n {\n     get_icu_disp_value_src_php( LOC_VARIANT_TAG , INTERNAL_FUNCTION_PARAM_PASSTHRU );\n }\n@@ -667,7 +668,7 @@ PHP_FUNCTION(locale_get_display_variant)\n  /* {{{ proto static array locale_get_keywords(string $locale) {\n  * return an associative array containing keyword-value\n  * pairs for this locale. The keys are keys to the array (doh!)\n- */ \n+ */\n PHP_FUNCTION( locale_get_keywords )\n {\n     UEnumeration*   e        = NULL;\n@@ -679,10 +680,10 @@ PHP_FUNCTION( locale_get_keywords )\n     const char*       \tloc_name        = NULL;\n     int        \t \tloc_name_len    = 0;\n \n-/* \n-\tICU expects the buffer to be allocated  before calling the function \n-\tand so the buffer size has been explicitly specified \n-\tICU uloc.h #define \tULOC_KEYWORD_AND_VALUES_CAPACITY   100 \n+/*\n+\tICU expects the buffer to be allocated  before calling the function\n+\tand so the buffer size has been explicitly specified\n+\tICU uloc.h #define \tULOC_KEYWORD_AND_VALUES_CAPACITY   100\n \thence the kw_value buffer size is 100\n */\n \tchar*\t \tkw_value        = NULL;\n@@ -721,7 +722,7 @@ PHP_FUNCTION( locale_get_keywords )\n \t\t\t\tkw_value_len=uloc_getKeywordValue( loc_name,kw_key, kw_value, kw_value_len+1 ,  &status );\n \t\t\t} else if(!U_FAILURE(status)) {\n \t\t\t\tkw_value = erealloc( kw_value , kw_value_len+1);\n-\t\t\t} \n+\t\t\t}\n \t\t\tif (U_FAILURE(status)) {\n \t        \t\tintl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR, \"locale_get_keywords: Error encountered while getting the keyword  value for the  keyword\", 0 TSRMLS_CC );\n \t\t\t\tif( kw_value){\n@@ -740,10 +741,10 @@ PHP_FUNCTION( locale_get_keywords )\n }\n /* }}} */\n \n- /* {{{ proto static string Locale::canonicalize($locale) \n- * @return string the canonicalized locale \n+ /* {{{ proto static string Locale::canonicalize($locale)\n+ * @return string the canonicalized locale\n  * }}} */\n- /* {{{ proto static string locale_canonicalize(Locale $loc, string $locale) \n+ /* {{{ proto static string locale_canonicalize(Locale $loc, string $locale)\n  * @param string $locale\tThe locale string to canonicalize\n  */\n PHP_FUNCTION(locale_canonicalize)\n@@ -752,10 +753,10 @@ PHP_FUNCTION(locale_canonicalize)\n }\n /* }}} */\n \n-/* {{{ append_key_value \n+/* {{{ append_key_value\n * Internal function which is called from locale_compose\n * gets the value for the key_name and appends to the loc_name\n-* returns 1 if successful , -1 if not found , \n+* returns 1 if successful , -1 if not found ,\n * 0 if array element is not a string , -2 if buffer-overflow\n */\n static int append_key_value(smart_str* loc_name, HashTable* hash_arr, char* key_name)\n@@ -767,7 +768,7 @@ static int append_key_value(smart_str* loc_name, HashTable* hash_arr, char* key_\n \t\t\t/* element value is not a string */\n \t\t\treturn FAILURE;\n \t\t}\n-\t\tif(strcmp(key_name, LOC_LANG_TAG) != 0 && \n+\t\tif(strcmp(key_name, LOC_LANG_TAG) != 0 &&\n \t\t   strcmp(key_name, LOC_GRANDFATHERED_LANG_TAG)!=0 ) {\n \t\t\t/* not lang or grandfathered tag */\n \t\t\tsmart_str_appendl(loc_name, SEPARATOR , sizeof(SEPARATOR)-1);\n@@ -792,11 +793,11 @@ static void add_prefix(smart_str* loc_name, char* key_name)\n }\n /* }}} */\n \n-/* {{{ append_multiple_key_values \n+/* {{{ append_multiple_key_values\n * Internal function which is called from locale_compose\n * gets the multiple values for the key_name and appends to the loc_name\n-* used for 'variant','extlang','private' \n-* returns 1 if successful , -1 if not found , \n+* used for 'variant','extlang','private'\n+* returns 1 if successful , -1 if not found ,\n * 0 if array element is not a string , -2 if buffer-overflow\n */\n static int append_multiple_key_values(smart_str* loc_name, HashTable* hash_arr, char* key_name TSRMLS_DC)\n@@ -850,8 +851,8 @@ static int append_multiple_key_values(smart_str* loc_name, HashTable* hash_arr,\n \n \t\t/* Multiple variant values as variant0, variant1 ,variant2 */\n \t\tisFirstSubtag = 0;\n-\t\tfor( i=0 ; i< max_value; i++ ){  \n-\t\t\tsnprintf( cur_key_name , 30, \"%s%d\", key_name , i);\t\n+\t\tfor( i=0 ; i< max_value; i++ ){\n+\t\t\tsnprintf( cur_key_name , 30, \"%s%d\", key_name , i);\n \t\t\tif( zend_hash_find( hash_arr , cur_key_name , strlen(cur_key_name) + 1,(void **)&ele_value ) == SUCCESS ){\n \t\t\t\tif( Z_TYPE_PP(ele_value)!= IS_STRING ){\n \t\t\t\t\t/* variant is not a string */\n@@ -873,7 +874,7 @@ static int append_multiple_key_values(smart_str* loc_name, HashTable* hash_arr,\n \n /*{{{\n * If applicable sets error message and aborts locale_compose gracefully\n-* returns 0  if locale_compose needs to be aborted \n+* returns 0  if locale_compose needs to be aborted\n * otherwise returns 1\n */\n static int handleAppendResult( int result, smart_str* loc_name TSRMLS_DC)\n@@ -890,11 +891,11 @@ static int handleAppendResult( int result, smart_str* loc_name TSRMLS_DC)\n /* }}} */\n \n #define RETURN_SMART_STR(s) smart_str_0((s)); RETURN_STRINGL((s)->c, (s)->len, 0)\n-/* {{{ proto static string Locale::composeLocale($array) \n-* Creates a locale by combining the parts of locale-ID passed\t\n+/* {{{ proto static string Locale::composeLocale($array)\n+* Creates a locale by combining the parts of locale-ID passed\n * }}} */\n-/* {{{ proto static string compose_locale($array) \n-* Creates a locale by combining the parts of locale-ID passed\t\n+/* {{{ proto static string compose_locale($array)\n+* Creates a locale by combining the parts of locale-ID passed\n * }}} */\n PHP_FUNCTION(locale_compose)\n {\n@@ -920,7 +921,7 @@ PHP_FUNCTION(locale_compose)\n \t\tRETURN_FALSE;\n \n \t/* Check for grandfathered first */\n-\tresult = append_key_value(loc_name, hash_arr,  LOC_GRANDFATHERED_LANG_TAG);\t\n+\tresult = append_key_value(loc_name, hash_arr,  LOC_GRANDFATHERED_LANG_TAG);\n \tif( result == SUCCESS){\n \t\tRETURN_SMART_STR(loc_name);\n \t}\n@@ -929,7 +930,7 @@ PHP_FUNCTION(locale_compose)\n \t}\n \n \t/* Not grandfathered */\n-\tresult = append_key_value(loc_name, hash_arr , LOC_LANG_TAG);\t\n+\tresult = append_key_value(loc_name, hash_arr , LOC_LANG_TAG);\n \tif( result == LOC_NOT_FOUND ){\n \t\tintl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,\n \t\t\"locale_compose: parameter array does not contain 'language' tag.\", 0 TSRMLS_CC );\n@@ -947,19 +948,19 @@ PHP_FUNCTION(locale_compose)\n \t}\n \n \t/* Script */\n-\tresult = append_key_value(loc_name, hash_arr , LOC_SCRIPT_TAG); \n+\tresult = append_key_value(loc_name, hash_arr , LOC_SCRIPT_TAG);\n \tif( !handleAppendResult( result, loc_name TSRMLS_CC)){\n \t\tRETURN_FALSE;\n \t}\n-\t\n+\n \t/* Region */\n \tresult = append_key_value( loc_name, hash_arr , LOC_REGION_TAG);\n \tif( !handleAppendResult( result, loc_name TSRMLS_CC)){\n \t\tRETURN_FALSE;\n \t}\n \n \t/* Variant */\n-\tresult = append_multiple_key_values( loc_name, hash_arr , LOC_VARIANT_TAG TSRMLS_CC); \n+\tresult = append_multiple_key_values( loc_name, hash_arr , LOC_VARIANT_TAG TSRMLS_CC);\n \tif( !handleAppendResult( result, loc_name TSRMLS_CC)){\n \t\tRETURN_FALSE;\n \t}\n@@ -985,16 +986,16 @@ static char* get_private_subtags(const char* loc_name)\n {\n \tchar* \tresult =NULL;\n \tint \tsingletonPos = 0;\n-\tint \tlen =0; \n+\tint \tlen =0;\n \tconst char* \tmod_loc_name =NULL;\n \n \tif( loc_name && (len = strlen(loc_name)>0 ) ){\n-\t\tmod_loc_name = loc_name ; \n+\t\tmod_loc_name = loc_name ;\n \t\tlen   = strlen(mod_loc_name);\n \t\twhile( (singletonPos = getSingletonPos(mod_loc_name))!= -1){\n \n-\t\t\tif( singletonPos!=-1){ \n-\t\t\t\tif( (*(mod_loc_name+singletonPos)=='x') || (*(mod_loc_name+singletonPos)=='X') ){\t\t\n+\t\t\tif( singletonPos!=-1){\n+\t\t\t\tif( (*(mod_loc_name+singletonPos)=='x') || (*(mod_loc_name+singletonPos)=='X') ){\n \t\t\t\t\t/* private subtag start found */\n \t\t\t\t\tif( singletonPos + 2 ==  len){\n \t\t\t\t\t\t/* loc_name ends with '-x-' ; return  NULL */\n@@ -1019,7 +1020,7 @@ static char* get_private_subtags(const char* loc_name)\n \n \t\t} /* end of while */\n \t}\n-\t\n+\n \treturn result;\n }\n /* }}} */\n@@ -1044,20 +1045,20 @@ static int add_array_entry(const char* loc_name, zval* hash_arr, char* key_name\n \t} else {\n \t\tkey_value = get_icu_value_internal( loc_name , key_name , &result,1 );\n \t}\n-\tif( (strcmp(key_name , LOC_PRIVATE_TAG)==0) || \n+\tif( (strcmp(key_name , LOC_PRIVATE_TAG)==0) ||\n \t\t( strcmp(key_name , LOC_VARIANT_TAG)==0) ){\n \t\tif( result > 0 && key_value){\n \t\t\t/* Tokenize on the \"_\" or \"-\"  */\n-\t\t\ttoken = php_strtok_r( key_value , DELIMITER ,&last_ptr);\t\n+\t\t\ttoken = php_strtok_r( key_value , DELIMITER ,&last_ptr);\n \t\t\tif( cur_key_name ){\n \t\t\t\tefree( cur_key_name);\n \t\t\t}\n \t\t\tcur_key_name = (char*)ecalloc( 25,  25);\n-\t\t\tsprintf( cur_key_name , \"%s%d\", key_name , cnt++);\t\n+\t\t\tsprintf( cur_key_name , \"%s%d\", key_name , cnt++);\n \t\t\tadd_assoc_string( hash_arr, cur_key_name , token ,TRUE );\n \t\t\t/* tokenize on the \"_\" or \"-\" and stop  at singleton if any */\n \t\t\twhile( (token = php_strtok_r(NULL , DELIMITER , &last_ptr)) && (strlen(token)>1) ){\n-\t\t\t\tsprintf( cur_key_name , \"%s%d\", key_name , cnt++);\t\n+\t\t\t\tsprintf( cur_key_name , \"%s%d\", key_name , cnt++);\n \t\t\t\tadd_assoc_string( hash_arr, cur_key_name , token , TRUE );\n \t\t\t}\n /*\n@@ -1077,16 +1078,16 @@ static int add_array_entry(const char* loc_name, zval* hash_arr, char* key_name\n \t}\n \t/*if( key_name != LOC_PRIVATE_TAG && key_value){*/\n \tif( key_value){\n-\t\tefree(key_value);\t\n+\t\tefree(key_value);\n \t}\n \treturn cur_result;\n }\n /* }}} */\n \n-/* {{{ proto static array Locale::parseLocale($locale) \n+/* {{{ proto static array Locale::parseLocale($locale)\n * parses a locale-id into an array the different parts of it\n  }}} */\n-/* {{{ proto static array parse_locale($locale) \n+/* {{{ proto static array parse_locale($locale)\n * parses a locale-id into an array the different parts of it\n */\n PHP_FUNCTION(locale_parse)\n@@ -1144,7 +1145,7 @@ PHP_FUNCTION(locale_get_all_variants)\n \tchar*\tsaved_ptr\t= NULL;\n \n \tintl_error_reset( NULL TSRMLS_CC );\n-\t\n+\n \tif(zend_parse_parameters( ZEND_NUM_ARGS() TSRMLS_CC, \"s\",\n \t&loc_name, &loc_name_len ) == FAILURE)\n \t{\n@@ -1162,15 +1163,15 @@ PHP_FUNCTION(locale_get_all_variants)\n \tarray_init( return_value );\n \n \t/* If the locale is grandfathered, stop, no variants */\n-\tif( findOffset( LOC_GRANDFATHERED , loc_name ) >=  0 ){ \n+\tif( findOffset( LOC_GRANDFATHERED , loc_name ) >=  0 ){\n \t\t/* (\"Grandfathered Tag. No variants.\"); */\n \t}\n-\telse {\t\n+\telse {\n \t/* Call ICU variant */\n \t\tvariant = get_icu_value_internal( loc_name , LOC_VARIANT_TAG , &result ,0);\n \t\tif( result > 0 && variant){\n \t\t\t/* Tokenize on the \"_\" or \"-\" */\n-\t\t\ttoken = php_strtok_r( variant , DELIMITER , &saved_ptr);\t\n+\t\t\ttoken = php_strtok_r( variant , DELIMITER , &saved_ptr);\n \t\t\tadd_next_index_stringl( return_value, token , strlen(token) ,TRUE );\n \t\t\t/* tokenize on the \"_\" or \"-\" and stop  at singleton if any\t*/\n \t\t\twhile( (token = php_strtok_r(NULL , DELIMITER, &saved_ptr)) && (strlen(token)>1) ){\n@@ -1181,7 +1182,7 @@ PHP_FUNCTION(locale_get_all_variants)\n \t\t\tefree( variant );\n \t\t}\n \t}\n-\t\t\t\n+\n \n }\n /* }}} */\n@@ -1220,11 +1221,11 @@ static int strToMatch(const char* str ,char *retstr)\n /* }}} */\n \n /* {{{ proto static boolean Locale::filterMatches(string $langtag, string $locale[, bool $canonicalize])\n-* Checks if a $langtag filter matches with $locale according to RFC 4647's basic filtering algorithm \n+* Checks if a $langtag filter matches with $locale according to RFC 4647's basic filtering algorithm\n */\n /* }}} */\n /* {{{ proto boolean locale_filter_matches(string $langtag, string $locale[, bool $canonicalize])\n-* Checks if a $langtag filter matches with $locale according to RFC 4647's basic filtering algorithm \n+* Checks if a $langtag filter matches with $locale according to RFC 4647's basic filtering algorithm\n */\n PHP_FUNCTION(locale_filter_matches)\n {\n@@ -1243,13 +1244,13 @@ PHP_FUNCTION(locale_filter_matches)\n \tchar*       \tcur_lang_tag    = NULL;\n \tchar*       \tcur_loc_range   = NULL;\n \n-\tzend_bool \tboolCanonical \t= 0;\t\n+\tzend_bool \tboolCanonical \t= 0;\n \tUErrorCode\tstatus\t\t= U_ZERO_ERROR;\n \n \tintl_error_reset( NULL TSRMLS_CC );\n-\t\n+\n \tif(zend_parse_parameters( ZEND_NUM_ARGS() TSRMLS_CC, \"ss|b\",\n-\t\t&lang_tag, &lang_tag_len , &loc_range , &loc_range_len , \n+\t\t&lang_tag, &lang_tag_len , &loc_range , &loc_range_len ,\n \t\t&boolCanonical) == FAILURE)\n \t{\n \t\tintl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,\n@@ -1270,15 +1271,15 @@ PHP_FUNCTION(locale_filter_matches)\n \t\t/* canonicalize loc_range */\n \t\tcan_loc_range=get_icu_value_internal( loc_range , LOC_CANONICALIZE_TAG , &result , 0);\n \t\tif( result ==0) {\n-\t\t\tintl_error_set( NULL, status, \n+\t\t\tintl_error_set( NULL, status,\n \t\t\t\t\"locale_filter_matches : unable to canonicalize loc_range\" , 0 TSRMLS_CC );\n \t\t\tRETURN_FALSE;\n \t\t}\n \n \t\t/* canonicalize lang_tag */\n \t\tcan_lang_tag = get_icu_value_internal( lang_tag , LOC_CANONICALIZE_TAG , &result ,  0);\n \t\tif( result ==0) {\n-\t\t\tintl_error_set( NULL, status, \n+\t\t\tintl_error_set( NULL, status,\n \t\t\t\t\"locale_filter_matches : unable to canonicalize lang_tag\" , 0 TSRMLS_CC );\n \t\t\tRETURN_FALSE;\n \t\t}\n@@ -1306,11 +1307,11 @@ PHP_FUNCTION(locale_filter_matches)\n \n \t\t/* check if prefix */\n \t\ttoken \t= strstr( cur_lang_tag , cur_loc_range );\n-\t\n+\n \t\tif( token && (token==cur_lang_tag) ){\n \t\t\t/* check if the char. after match is SEPARATOR */\n \t\t\tchrcheck = token + (strlen(cur_loc_range));\n-\t\t\tif( isIDSeparator(*chrcheck) || isEndOfTag(*chrcheck) ){ \n+\t\t\tif( isIDSeparator(*chrcheck) || isEndOfTag(*chrcheck) ){\n \t\t\t\tif( cur_lang_tag){\n \t\t\t\t\tefree( cur_lang_tag );\n \t\t\t\t}\n@@ -1346,7 +1347,7 @@ PHP_FUNCTION(locale_filter_matches)\n \telse{\n \t\t/* Convert to lower case for case-insensitive comparison */\n \t\tcur_lang_tag = ecalloc( 1, strlen(lang_tag ) + 1);\n-\t\t\n+\n \t\tresult = strToMatch( lang_tag , cur_lang_tag);\n \t\tif( result == 0) {\n \t\t\tefree( cur_lang_tag );\n@@ -1362,11 +1363,11 @@ PHP_FUNCTION(locale_filter_matches)\n \n \t\t/* check if prefix */\n \t\ttoken \t= strstr( cur_lang_tag , cur_loc_range );\n-\t\t\n+\n \t\tif( token && (token==cur_lang_tag) ){\n \t\t\t/* check if the char. after match is SEPARATOR */\n \t\t\tchrcheck = token + (strlen(cur_loc_range));\n-\t\t\tif( isIDSeparator(*chrcheck) || isEndOfTag(*chrcheck) ){ \n+\t\t\tif( isIDSeparator(*chrcheck) || isEndOfTag(*chrcheck) ){\n \t\t\t\tif( cur_lang_tag){\n \t\t\t\t\tefree( cur_lang_tag );\n \t\t\t\t}\n@@ -1393,7 +1394,7 @@ PHP_FUNCTION(locale_filter_matches)\n static void array_cleanup( char* arr[] , int arr_size)\n {\n \tint i=0;\n-\tfor( i=0; i< arr_size; i++ ){ \n+\tfor( i=0; i< arr_size; i++ ){\n \t\tif( arr[i*2] ){\n \t\t\tefree( arr[i*2]);\n \t\t}\n@@ -1403,7 +1404,7 @@ static void array_cleanup( char* arr[] , int arr_size)\n \n #define LOOKUP_CLEAN_RETURN(value)\tarray_cleanup(cur_arr, cur_arr_len); return (value)\n /* {{{\n-* returns the lookup result to lookup_loc_range_src_php \n+* returns the lookup result to lookup_loc_range_src_php\n * internal function\n */\n static char* lookup_loc_range(const char* loc_range, HashTable* hash_arr, int canonicalize  TSRMLS_DC)\n@@ -1427,7 +1428,7 @@ static char* lookup_loc_range(const char* loc_range, HashTable* hash_arr, int ca\n \tfor(zend_hash_internal_pointer_reset(hash_arr);\n \t\tzend_hash_has_more_elements(hash_arr) == SUCCESS;\n \t\tzend_hash_move_forward(hash_arr)) {\n-\t\t\n+\n \t\tif (zend_hash_get_current_data(hash_arr, (void**)&ele_value) == FAILURE) {\n \t\t\t/* Should never actually fail since the key is known to exist.*/\n \t\t\tcontinue;\n@@ -1436,20 +1437,20 @@ static char* lookup_loc_range(const char* loc_range, HashTable* hash_arr, int ca\n \t\t\t/* element value is not a string */\n \t\t\tintl_error_set(NULL, U_ILLEGAL_ARGUMENT_ERROR, \"lookup_loc_range: locale array element is not a string\", 0 TSRMLS_CC);\n \t\t\tLOOKUP_CLEAN_RETURN(NULL);\n-\t\t} \n+\t\t}\n \t\tcur_arr[cur_arr_len*2] = estrndup(Z_STRVAL_PP(ele_value), Z_STRLEN_PP(ele_value));\n \t\tresult = strToMatch(Z_STRVAL_PP(ele_value), cur_arr[cur_arr_len*2]);\n \t\tif(result == 0) {\n \t\t\tintl_error_set(NULL, U_ILLEGAL_ARGUMENT_ERROR, \"lookup_loc_range: unable to canonicalize lang_tag\", 0 TSRMLS_CC);\n \t\t\tLOOKUP_CLEAN_RETURN(NULL);\n \t\t}\n \t\tcur_arr[cur_arr_len*2+1] = Z_STRVAL_PP(ele_value);\n-\t\tcur_arr_len++ ; \n+\t\tcur_arr_len++ ;\n \t} /* end of for */\n \n \t/* Canonicalize array elements */\n \tif(canonicalize) {\n-\t\tfor(i=0; i<cur_arr_len; i++) { \n+\t\tfor(i=0; i<cur_arr_len; i++) {\n \t\t\tlang_tag = get_icu_value_internal(cur_arr[i*2], LOC_CANONICALIZE_TAG, &result, 0);\n \t\t\tif(result != 1 || lang_tag == NULL || !lang_tag[0]) {\n \t\t\t\tif(lang_tag) {\n@@ -1459,7 +1460,7 @@ static char* lookup_loc_range(const char* loc_range, HashTable* hash_arr, int ca\n \t\t\t\tLOOKUP_CLEAN_RETURN(NULL);\n \t\t\t}\n \t\t\tcur_arr[i*2] = erealloc(cur_arr[i*2], strlen(lang_tag)+1);\n-\t\t\tresult = strToMatch(lang_tag, cur_arr[i*2]);\t\n+\t\t\tresult = strToMatch(lang_tag, cur_arr[i*2]);\n \t\t\tefree(lang_tag);\n \t\t\tif(result == 0) {\n \t\t\t\tintl_error_set(NULL, U_ILLEGAL_ARGUMENT_ERROR, \"lookup_loc_range: unable to canonicalize lang_tag\" , 0 TSRMLS_CC);\n@@ -1482,11 +1483,11 @@ static char* lookup_loc_range(const char* loc_range, HashTable* hash_arr, int ca\n \t\t} else {\n \t\t\tloc_range = can_loc_range;\n \t\t}\n-\t} \n+\t}\n \n \tcur_loc_range = ecalloc(1, strlen(loc_range)+1);\n \t/* convert to lower and replace hyphens */\n-\tresult = strToMatch(loc_range, cur_loc_range);\t\n+\tresult = strToMatch(loc_range, cur_loc_range);\n \tif(can_loc_range) {\n \t\tefree(can_loc_range);\n \t}\n@@ -1498,8 +1499,8 @@ static char* lookup_loc_range(const char* loc_range, HashTable* hash_arr, int ca\n \t/* Lookup for the lang_tag match */\n \tsaved_pos = strlen(cur_loc_range);\n \twhile(saved_pos > 0) {\n-\t\tfor(i=0; i< cur_arr_len; i++){ \n-\t\t\tif(cur_arr[i*2] != NULL && strlen(cur_arr[i*2]) == saved_pos && strncmp(cur_loc_range, cur_arr[i*2], saved_pos) == 0) {\t\n+\t\tfor(i=0; i< cur_arr_len; i++){\n+\t\t\tif(cur_arr[i*2] != NULL && strlen(cur_arr[i*2]) == saved_pos && strncmp(cur_loc_range, cur_arr[i*2], saved_pos) == 0) {\n \t\t\t\t/* Match found */\n \t\t\t\treturn_value = estrdup(canonicalize?cur_arr[i*2]:cur_arr[i*2+1]);\n \t\t\t\tefree(cur_loc_range);\n@@ -1515,14 +1516,14 @@ static char* lookup_loc_range(const char* loc_range, HashTable* hash_arr, int ca\n }\n /* }}} */\n \n-/* {{{ proto string Locale::lookup(array $langtag, string $locale[, bool $canonicalize[, string $default = null]]) \n+/* {{{ proto string Locale::lookup(array $langtag, string $locale[, bool $canonicalize[, string $default = null]])\n * Searchs the items in $langtag for the best match to the language\n-* range \n+* range\n */\n /* }}} */\n /* {{{ proto string locale_lookup(array $langtag, string $locale[, bool $canonicalize[, string $default = null]])\n * Searchs the items in $langtag for the best match to the language\n-* range \n+* range\n */\n PHP_FUNCTION(locale_lookup)\n {\n@@ -1552,8 +1553,8 @@ PHP_FUNCTION(locale_lookup)\n \n \tif( !hash_arr || zend_hash_num_elements( hash_arr ) == 0 ) {\n \t\tRETURN_EMPTY_STRING();\n-\t} \n-\t\n+\t}\n+\n \tresult = lookup_loc_range(loc_range, hash_arr, boolCanonical TSRMLS_CC);\n \tif(result == NULL || result[0] == '\\0') {\n \t\tif( fallback_loc ) {\n@@ -1590,10 +1591,10 @@ PHP_FUNCTION(locale_accept_from_http)\n \t\t\"locale_accept_from_http: unable to parse input parameters\", 0 TSRMLS_CC );\n \t\tRETURN_FALSE;\n \t}\n-\t\n+\n \tavailable = ures_openAvailableLocales(NULL, &status);\n \tINTL_CHECK_STATUS(status, \"locale_accept_from_http: failed to retrieve locale list\");\n-\tlen = uloc_acceptLanguageFromHTTP(resultLocale, INTL_MAX_LOCALE_LEN, \n+\tlen = uloc_acceptLanguageFromHTTP(resultLocale, INTL_MAX_LOCALE_LEN,\n \t\t\t\t\t\t&outResult, http_accept, available, &status);\n \tuenum_close(available);\n \tINTL_CHECK_STATUS(status, \"locale_accept_from_http: failed to find acceptable locale\");", "file_path": "files/2016_8\\75", "file_language": "c", "file_name": "ext/intl/locale/locale_methods.c", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}, {"raw_url": "https://github.com/php/php-src/raw/97eff7eb57fc2320c267a949cffd622c38712484/ext/intl/tests/bug72241.phpt", "patch": "@@ -0,0 +1,14 @@\n+--TEST--\n+Bug #72241: get_icu_value_internal out-of-bounds read\n+--SKIPIF--\n+<?php if( !extension_loaded( 'intl' ) ) print 'skip'; ?>\n+--FILE--\n+<?php\n+$var1=str_repeat(\"A\", 1000);\n+$out = locale_get_primary_language($var1);\n+echo strlen($out) . PHP_EOL;\n+echo unpack('H*', $out)[1] . PHP_EOL;\n+--EXPECT--\n+1000\n+61616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161\n+", "file_path": "files/2016_8\\76", "file_language": "phpt", "file_name": "ext/intl/tests/bug72241.phpt", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}], "outdated": 0}
{"index": 29, "cve_id": "CVE-2016-5116", "cwe_id": ["CWE-119"], "cve_language": "C", "cve_description": "gd_xbm.c in the GD Graphics Library (aka libgd) before 2.2.0, as used in certain custom PHP 5.5.x configurations, allows context-dependent attackers to obtain sensitive information from process memory or cause a denial of service (stack-based buffer under-read and application crash) via a long name.", "cvss": "9.1", "publish_date": "August 7, 2016", "AV": "NETWORK", "AC": "LOW", "PR": "NONE", "UI": "NONE", "S": "UNCHANGED", "C": "HIGH", "I": "NONE", "A": "HIGH", "commit_id": "4dc1a2d7931017d3625f2d7cff70a17ce58b53b4", "commit_message": "xbm: avoid stack overflow (read) with large names #211\n\nWe use the name passed in to printf into a local stack buffer which is\nlimited to 4000 bytes.  So given a large enough value, lots of stack\ndata is leaked.  Rewrite the code to do simple memory copies with most\nof the strings to avoid that issue, and only use stack buffer for small\nnumbers of constant size.\n\nThis closes #211.", "commit_date": "2016-05-14T05:38:18Z", "project": "libgd/libgd", "url": "https://api.github.com/repos/libgd/libgd/commits/4dc1a2d7931017d3625f2d7cff70a17ce58b53b4", "html_url": "https://github.com/libgd/libgd/commit/4dc1a2d7931017d3625f2d7cff70a17ce58b53b4", "windows_before": "", "windows_after": "", "parents": [{"commit_id_before": "b083ec17ad9cba4ad9fe7fac1c6a168d90dd1a31", "url_before": "https://api.github.com/repos/libgd/libgd/commits/b083ec17ad9cba4ad9fe7fac1c6a168d90dd1a31", "html_url_before": "https://github.com/libgd/libgd/commit/b083ec17ad9cba4ad9fe7fac1c6a168d90dd1a31"}], "details": [{"raw_url": "https://github.com/libgd/libgd/raw/4dc1a2d7931017d3625f2d7cff70a17ce58b53b4/src/gd_xbm.c", "patch": "@@ -180,7 +180,7 @@ BGD_DECLARE(gdImagePtr) gdImageCreateFromXbm(FILE * fd)\n /* {{{ gdCtxPrintf */\n static void gdCtxPrintf(gdIOCtx * out, const char *format, ...)\n {\n-\tchar buf[4096];\n+\tchar buf[1024];\n \tint len;\n \tva_list args;\n \n@@ -191,6 +191,9 @@ static void gdCtxPrintf(gdIOCtx * out, const char *format, ...)\n }\n /* }}} */\n \n+/* The compiler will optimize strlen(constant) to a constant number. */\n+#define gdCtxPuts(out, s) out->putBuf(out, s, strlen(s))\n+\n /* {{{ gdImageXbmCtx */\n BGD_DECLARE(void) gdImageXbmCtx(gdImagePtr image, char* file_name, int fg, gdIOCtx * out)\n {\n@@ -215,9 +218,26 @@ BGD_DECLARE(void) gdImageXbmCtx(gdImagePtr image, char* file_name, int fg, gdIOC\n \t\t}\n \t}\n \n-\tgdCtxPrintf(out, \"#define %s_width %d\\n\", name, gdImageSX(image));\n-\tgdCtxPrintf(out, \"#define %s_height %d\\n\", name, gdImageSY(image));\n-\tgdCtxPrintf(out, \"static unsigned char %s_bits[] = {\\n  \", name);\n+\t/* Since \"name\" comes from the user, run it through a direct puts.\n+\t * Trying to printf it into a local buffer means we'd need a large\n+\t * or dynamic buffer to hold it all. */\n+\n+\t/* #define <name>_width 1234 */\n+\tgdCtxPuts(out, \"#define \");\n+\tgdCtxPuts(out, name);\n+\tgdCtxPuts(out, \"_width \");\n+\tgdCtxPrintf(out, \"%d\\n\", gdImageSX(image));\n+\n+\t/* #define <name>_height 1234 */\n+\tgdCtxPuts(out, \"#define \");\n+\tgdCtxPuts(out, name);\n+\tgdCtxPuts(out, \"_height \");\n+\tgdCtxPrintf(out, \"%d\\n\", gdImageSY(image));\n+\n+\t/* static unsigned char <name>_bits[] = {\\n */\n+\tgdCtxPuts(out, \"static unsigned char \");\n+\tgdCtxPuts(out, name);\n+\tgdCtxPuts(out, \"_bits[] = {\\n  \");\n \n \tfree(name);\n \n@@ -234,9 +254,9 @@ BGD_DECLARE(void) gdImageXbmCtx(gdImagePtr image, char* file_name, int fg, gdIOC\n \t\t\tif ((b == 128) || (x == sx && y == sy)) {\n \t\t\t\tb = 1;\n \t\t\t\tif (p) {\n-\t\t\t\t\tgdCtxPrintf(out, \", \");\n+\t\t\t\t\tgdCtxPuts(out, \", \");\n \t\t\t\t\tif (!(p%12)) {\n-\t\t\t\t\t\tgdCtxPrintf(out, \"\\n  \");\n+\t\t\t\t\t\tgdCtxPuts(out, \"\\n  \");\n \t\t\t\t\t\tp = 12;\n \t\t\t\t\t}\n \t\t\t\t}\n@@ -248,6 +268,6 @@ BGD_DECLARE(void) gdImageXbmCtx(gdImagePtr image, char* file_name, int fg, gdIOC\n \t\t\t}\n \t\t}\n \t}\n-\tgdCtxPrintf(out, \"};\\n\");\n+\tgdCtxPuts(out, \"};\\n\");\n }\n /* }}} */", "file_path": "files/2016_8\\77", "file_language": "c", "file_name": "src/gd_xbm.c", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}], "outdated": 0}
{"index": 30, "cve_id": "CVE-2016-5094", "cwe_id": ["CWE-190"], "cve_language": "C", "cve_description": "Integer overflow in the php_html_entities function in ext/standard/html.c in PHP before 5.5.36 and 5.6.x before 5.6.22 allows remote attackers to cause a denial of service or possibly have unspecified other impact by triggering a large output string from the htmlspecialchars function.", "cvss": "8.6", "publish_date": "August 7, 2016", "AV": "NETWORK", "AC": "LOW", "PR": "NONE", "UI": "NONE", "S": "UNCHANGED", "C": "LOW", "I": "LOW", "A": "HIGH", "commit_id": "0da8b8b801f9276359262f1ef8274c7812d3dfda", "commit_message": "Fix bug #72135 - don't create strings with lengths outside int range", "commit_date": "2016-05-16T06:26:51Z", "project": "php/php-src", "url": "https://api.github.com/repos/php/php-src/commits/0da8b8b801f9276359262f1ef8274c7812d3dfda", "html_url": "https://github.com/php/php-src/commit/0da8b8b801f9276359262f1ef8274c7812d3dfda", "windows_before": "", "windows_after": "", "parents": [{"commit_id_before": "41fc3c76e97a36ff3b505da7d704ca17bb171fdf", "url_before": "https://api.github.com/repos/php/php-src/commits/41fc3c76e97a36ff3b505da7d704ca17bb171fdf", "html_url_before": "https://github.com/php/php-src/commit/41fc3c76e97a36ff3b505da7d704ca17bb171fdf"}], "details": [{"raw_url": "https://github.com/php/php-src/raw/0da8b8b801f9276359262f1ef8274c7812d3dfda/ext/standard/html.c", "patch": "@@ -163,7 +163,7 @@ static inline unsigned int get_next_char(\n \t\t\t\t\telse\n \t\t\t\t\t\tMB_FAILURE(pos, 4);\n \t\t\t\t}\n-\t\t\t\t\n+\n \t\t\t\tthis_char = ((c & 0x07) << 18) | ((str[pos + 1] & 0x3f) << 12) | ((str[pos + 2] & 0x3f) << 6) | (str[pos + 3] & 0x3f);\n \t\t\t\tif (this_char < 0x10000 || this_char > 0x10FFFF) { /* non-shortest form or outside range */\n \t\t\t\t\tMB_FAILURE(pos, 4);\n@@ -437,7 +437,7 @@ static enum entity_charset determine_charset(char *charset_hint TSRMLS_DC)\n \n \tif (charset_hint) {\n \t\tint found = 0;\n-\t\t\n+\n \t\t/* now walk the charset map and look for the codeset */\n \t\tfor (i = 0; charset_map[i].codeset; i++) {\n \t\t\tif (len == strlen(charset_map[i].codeset) && strncasecmp(charset_hint, charset_map[i].codeset, len) == 0) {\n@@ -545,7 +545,7 @@ static inline unsigned char unimap_bsearch(const uni_to_enc *table, unsigned cod\n \t\treturn 0;\n \n \tcode_key = (unsigned short) code_key_a;\n-\t\n+\n \twhile (l <= h) {\n \t\tm = l + (h - l) / 2;\n \t\tif (code_key < m->un_code_point)\n@@ -571,7 +571,7 @@ static inline int map_from_unicode(unsigned code, enum entity_charset charset, u\n \t\t/* identity mapping of code points to unicode */\n \t\tif (code > 0xFF) {\n \t\t\treturn FAILURE;\n-\t\t} \n+\t\t}\n \t\t*res = code;\n \t\tbreak;\n \n@@ -590,7 +590,7 @@ static inline int map_from_unicode(unsigned code, enum entity_charset charset, u\n \t\t\treturn FAILURE;\n \t\t}\n \t\tbreak;\n-\t\t\n+\n \tcase cs_8859_15:\n \t\tif (code < 0xA4 || (code > 0xBE && code <= 0xFF)) {\n \t\t\t*res = code;\n@@ -634,7 +634,7 @@ static inline int map_from_unicode(unsigned code, enum entity_charset charset, u\n \tcase cs_cp866:\n \t\ttable = unimap_cp866;\n \t\ttable_size = sizeof(unimap_cp866) / sizeof(*unimap_cp866);\n-\t\t\n+\n table_over_7F:\n \t\tif (code <= 0x7F) {\n \t\t\t*res = code;\n@@ -710,7 +710,7 @@ static inline int unicode_cp_is_allowed(unsigned uni_cp, int document_type)\n \t * Not sure this is the relevant part for HTML 5, though. I opted to\n \t * disallow the characters that would result in a parse error when\n \t * preprocessing of the input stream. See also section 8.1.3.\n-\t * \n+\t *\n \t * It's unclear if XHTML 1.0 allows C1 characters. I'll opt to apply to\n \t * XHTML 1.0 the same rules as for XML 1.0.\n \t * See <http://cmsmcq.com/2007/C1.xml>.\n@@ -774,7 +774,7 @@ static inline int numeric_entity_is_allowed(unsigned uni_cp, int document_type)\n /* {{{ process_numeric_entity\n  * Auxiliary function to traverse_for_entities.\n  * On input, *buf should point to the first character after # and on output, it's the last\n- * byte read, no matter if there was success or insuccess. \n+ * byte read, no matter if there was success or insuccess.\n  */\n static inline int process_numeric_entity(const char **buf, unsigned *code_point)\n {\n@@ -784,7 +784,7 @@ static inline int process_numeric_entity(const char **buf, unsigned *code_point)\n \n \tif (hexadecimal && (**buf != '\\0'))\n \t\t(*buf)++;\n-\t\t\t\n+\n \t/* strtol allows whitespace and other stuff in the beginning\n \t\t* we're not interested */\n \tif ((hexadecimal && !isxdigit(**buf)) ||\n@@ -969,7 +969,7 @@ static void traverse_for_entities(\n \t\t\t\tgoto invalid_code;\n \n \t\t\t/* are we allowed to decode this entity in this document type?\n-\t\t\t * HTML 5 is the only that has a character that cannot be used in \n+\t\t\t * HTML 5 is the only that has a character that cannot be used in\n \t\t\t * a numeric entity but is allowed literally (U+000D). The\n \t\t\t * unoptimized version would be ... || !numeric_entity_is_allowed(code) */\n \t\t\tif (!unicode_cp_is_allowed(code, doctype) ||\n@@ -996,9 +996,9 @@ static void traverse_for_entities(\n \t\t\t\t}\n \t\t\t}\n \t\t}\n-\t\t\n+\n \t\tassert(*next == ';');\n-\t\t\n+\n \t\tif (((code == '\\'' && !(flags & ENT_HTML_QUOTE_SINGLE)) ||\n \t\t\t\t(code == '\"' && !(flags & ENT_HTML_QUOTE_DOUBLE)))\n \t\t\t\t/* && code2 == '\\0' always true for current maps */)\n@@ -1026,7 +1026,7 @@ static void traverse_for_entities(\n \t\t\t*(q++) = *p;\n \t\t}\n \t}\n-\t\n+\n \t*q = '\\0';\n \t*retlen = (size_t)(q - ret);\n }\n@@ -1066,7 +1066,7 @@ static entity_table_opt determine_entity_table(int all, int doctype)\n \tentity_table_opt retval = {NULL};\n \n \tassert(!(doctype == ENT_HTML_DOC_XML1 && all));\n-\t\n+\n \tif (all) {\n \t\tretval.ms_table = (doctype == ENT_HTML_DOC_HTML5) ?\n \t\t\tentity_ms_table_html5 : entity_ms_table_html4;\n@@ -1111,13 +1111,13 @@ PHPAPI char *php_unescape_html_entities(unsigned char *old, size_t oldlen, size_\n \tif (retlen == 0) {\n \t\tgoto empty_source;\n \t}\n-\t\n+\n \tinverse_map = unescape_inverse_map(all, flags);\n-\t\n+\n \t/* replace numeric entities */\n \ttraverse_for_entities(old, oldlen, ret, &retlen, all, flags, inverse_map, charset);\n \n-empty_source:\t\n+empty_source:\n \t*newlen = retlen;\n \treturn ret;\n }\n@@ -1141,7 +1141,7 @@ static inline void find_entity_for_char(\n {\n \tunsigned stage1_idx = ENT_STAGE1_INDEX(k);\n \tconst entity_stage3_row *c;\n-\t\n+\n \tif (stage1_idx > 0x1D) {\n \t\t*entity     = NULL;\n \t\t*entity_len = 0;\n@@ -1162,7 +1162,7 @@ static inline void find_entity_for_char(\n \t\tif (!(*cursor < oldlen))\n \t\t\tgoto no_suitable_2nd;\n \n-\t\tnext_char = get_next_char(charset, old, oldlen, cursor, &status); \n+\t\tnext_char = get_next_char(charset, old, oldlen, cursor, &status);\n \n \t\tif (status == FAILURE)\n \t\t\tgoto no_suitable_2nd;\n@@ -1187,7 +1187,7 @@ static inline void find_entity_for_char(\n \t\t*entity = (const unsigned char *)\n \t\t\tc->data.multicodepoint_table[0].leading_entry.default_entity;\n \t\t*entity_len = c->data.multicodepoint_table[0].leading_entry.default_entity_len;\n-\t}\t\n+\t}\n }\n /* }}} */\n \n@@ -1255,7 +1255,7 @@ PHPAPI char *php_escape_html_entities_ex(unsigned char *old, size_t oldlen, size\n \n \t/* initial estimate */\n \tif (oldlen < 64) {\n-\t\tmaxlen = 128;\t\n+\t\tmaxlen = 128;\n \t} else {\n \t\tmaxlen = 2 * oldlen;\n \t\tif (maxlen < oldlen) {\n@@ -1444,6 +1444,10 @@ static void php_html_entities(INTERNAL_FUNCTION_PARAMETERS, int all)\n \t}\n \n \treplaced = php_escape_html_entities_ex(str, str_len, &new_len, all, (int) flags, hint_charset, double_encode TSRMLS_CC);\n+\tif (new_len > INT_MAX) {\n+\t\tefree(replaced);\n+\t\tRETURN_FALSE;\n+\t}\n \tRETVAL_STRINGL(replaced, (int)new_len, 0);\n }\n /* }}} */\n@@ -1577,7 +1581,7 @@ static inline void write_s3row_data(\n \t\t\t} else {\n \t\t\t\tspe_cp = uni_cp;\n \t\t\t}\n-\t\t\t\n+\n \t\t\twritten_k2 = write_octet_sequence(&key[written_k1], charset, spe_cp);\n \t\t\tmemcpy(&entity[1], mcpr[i].normal_entry.entity, l);\n \t\t\tentity[l + 1] = ';';\n@@ -1615,7 +1619,7 @@ PHP_FUNCTION(get_html_translation_table)\n \tLIMIT_ALL(all, doctype, charset);\n \n \tarray_init(return_value);\n-\t\n+\n \tentity_table = determine_entity_table(all, doctype);\n \tif (all && !CHARSET_UNICODE_COMPAT(charset)) {\n \t\tto_uni_table = enc_to_uni_index[charset];", "file_path": "files/2016_8\\78", "file_language": "c", "file_name": "ext/standard/html.c", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}], "outdated": 0}
{"index": 31, "cve_id": "CVE-2016-5096", "cwe_id": ["CWE-190"], "cve_language": "C", "cve_description": "Integer overflow in the fread function in ext/standard/file.c in PHP before 5.5.36 and 5.6.x before 5.6.22 allows remote attackers to cause a denial of service or possibly have unspecified other impact via a large integer in the second argument.", "cvss": "8.6", "publish_date": "August 7, 2016", "AV": "NETWORK", "AC": "LOW", "PR": "NONE", "UI": "NONE", "S": "UNCHANGED", "C": "LOW", "I": "LOW", "A": "HIGH", "commit_id": "abd159cce48f3e34f08e4751c568e09677d5ec9c", "commit_message": "Fix bug #72114 - int/size_t confusion in fread", "commit_date": "2016-05-10T04:55:29Z", "project": "php/php-src", "url": "https://api.github.com/repos/php/php-src/commits/abd159cce48f3e34f08e4751c568e09677d5ec9c", "html_url": "https://github.com/php/php-src/commit/abd159cce48f3e34f08e4751c568e09677d5ec9c", "windows_before": "", "windows_after": "", "parents": [{"commit_id_before": "95ed19ae28009aa7b3ed42d5760478de82640560", "url_before": "https://api.github.com/repos/php/php-src/commits/95ed19ae28009aa7b3ed42d5760478de82640560", "html_url_before": "https://github.com/php/php-src/commit/95ed19ae28009aa7b3ed42d5760478de82640560"}], "details": [{"raw_url": "https://github.com/php/php-src/raw/abd159cce48f3e34f08e4751c568e09677d5ec9c/ext/standard/file.c", "patch": "@@ -1758,6 +1758,12 @@ PHPAPI PHP_FUNCTION(fread)\n \t\tRETURN_FALSE;\n \t}\n \n+\tif (len > INT_MAX) {\n+\t\t/* string length is int in 5.x so we can not read more than int */\n+\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Length parameter must be no more than %d\", INT_MAX);\n+\t\tRETURN_FALSE;\n+\t}\n+\n \tZ_STRVAL_P(return_value) = emalloc(len + 1);\n \tZ_STRLEN_P(return_value) = php_stream_read(stream, Z_STRVAL_P(return_value), len);\n ", "file_path": "files/2016_8\\79", "file_language": "c", "file_name": "ext/standard/file.c", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}, {"raw_url": "https://github.com/php/php-src/raw/abd159cce48f3e34f08e4751c568e09677d5ec9c/ext/standard/tests/file/bug72114.phpt", "patch": "@@ -0,0 +1,12 @@\n+--TEST--\n+Bug #72114 (Integer underflow / arbitrary null write in fread/gzread)\n+--FILE--\n+<?php\n+ini_set('memory_limit', \"2500M\");\n+$fp = fopen(\"/dev/zero\", \"r\");\n+fread($fp, 2147483648);\n+?>\n+Done\n+--EXPECTF--\n+Warning: fread(): Length parameter must be no more than 2147483647 in %s/bug72114.php on line %d\n+Done", "file_path": "files/2016_8\\80", "file_language": "phpt", "file_name": "ext/standard/tests/file/bug72114.phpt", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}], "outdated": 0}
{"index": 32, "cve_id": "CVE-2016-6515", "cwe_id": ["CWE-20"], "cve_language": "C", "cve_description": "The auth_password function in auth-passwd.c in sshd in OpenSSH before 7.3 does not limit password lengths for password authentication, which allows remote attackers to cause a denial of service (crypt CPU consumption) via a long string.", "cvss": "7.5", "publish_date": "August 6, 2016", "AV": "NETWORK", "AC": "LOW", "PR": "NONE", "UI": "NONE", "S": "UNCHANGED", "C": "NONE", "I": "NONE", "A": "HIGH", "commit_id": "fcd135c9df440bcd2d5870405ad3311743d78d97", "commit_message": "upstream commit\n\nSkip passwords longer than 1k in length so clients can't\neasily DoS sshd by sending very long passwords, causing it to spend CPU\nhashing them. feedback djm@, ok markus@.\n\nBrought to our attention by tomas.kuthan at oracle.com, shilei-c at\n360.cn and coredump at autistici.org\n\nUpstream-ID: d0af7d4a2190b63ba1d38eec502bc4be0be9e333", "commit_date": "2016-07-22T03:36:40Z", "project": "openssh/openssh-portable", "url": "https://api.github.com/repos/openssh/openssh-portable/commits/fcd135c9df440bcd2d5870405ad3311743d78d97", "html_url": "https://github.com/openssh/openssh-portable/commit/fcd135c9df440bcd2d5870405ad3311743d78d97", "windows_before": "", "windows_after": "", "parents": [{"commit_id_before": "324583e8fb3935690be58790425793df619c6d4d", "url_before": "https://api.github.com/repos/openssh/openssh-portable/commits/324583e8fb3935690be58790425793df619c6d4d", "html_url_before": "https://github.com/openssh/openssh-portable/commit/324583e8fb3935690be58790425793df619c6d4d"}], "details": [{"raw_url": "https://github.com/openssh/openssh-portable/raw/fcd135c9df440bcd2d5870405ad3311743d78d97/auth-passwd.c", "patch": "@@ -1,4 +1,4 @@\n-/* $OpenBSD: auth-passwd.c,v 1.44 2014/07/15 15:54:14 millert Exp $ */\n+/* $OpenBSD: auth-passwd.c,v 1.45 2016/07/21 01:39:35 dtucker Exp $ */\n /*\n  * Author: Tatu Ylonen <ylo@cs.hut.fi>\n  * Copyright (c) 1995 Tatu Ylonen <ylo@cs.hut.fi>, Espoo, Finland\n@@ -66,6 +66,8 @@ extern login_cap_t *lc;\n #define DAY\t\t(24L * 60 * 60) /* 1 day in seconds */\n #define TWO_WEEKS\t(2L * 7 * DAY)\t/* 2 weeks in seconds */\n \n+#define MAX_PASSWORD_LEN\t1024\n+\n void\n disable_forwarding(void)\n {\n@@ -87,6 +89,9 @@ auth_password(Authctxt *authctxt, const char *password)\n \tstatic int expire_checked = 0;\n #endif\n \n+\tif (strlen(password) > MAX_PASSWORD_LEN)\n+\t\treturn 0;\n+\n #ifndef HAVE_CYGWIN\n \tif (pw->pw_uid == 0 && options.permit_root_login != PERMIT_YES)\n \t\tok = 0;", "file_path": "files/2016_8\\81", "file_language": "c", "file_name": "auth-passwd.c", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}], "outdated": 0}
{"index": 33, "cve_id": "CVE-2016-3841", "cwe_id": ["CWE-264", "CWE-416"], "cve_language": "C", "cve_description": "The IPv6 stack in the Linux kernel before 4.3.3 mishandles options data, which allows local users to gain privileges or cause a denial of service (use-after-free and system crash) via a crafted sendmsg system call.", "cvss": "7.3", "publish_date": "August 6, 2016", "AV": "LOCAL", "AC": "LOW", "PR": "LOW", "UI": "REQUIRED", "S": "UNCHANGED", "C": "HIGH", "I": "HIGH", "A": "HIGH", "commit_id": "45f6fad84cc305103b28d73482b344d7f5b76f39", "commit_message": "ipv6: add complete rcu protection around np->opt\n\nThis patch addresses multiple problems :\n\nUDP/RAW sendmsg() need to get a stable struct ipv6_txoptions\nwhile socket is not locked : Other threads can change np->opt\nconcurrently. Dmitry posted a syzkaller\n(http://github.com/google/syzkaller) program desmonstrating\nuse-after-free.\n\nStarting with TCP/DCCP lockless listeners, tcp_v6_syn_recv_sock()\nand dccp_v6_request_recv_sock() also need to use RCU protection\nto dereference np->opt once (before calling ipv6_dup_options())\n\nThis patch adds full RCU protection to np->opt\n\nReported-by: Dmitry Vyukov <dvyukov@google.com>\nSigned-off-by: Eric Dumazet <edumazet@google.com>\nAcked-by: Hannes Frederic Sowa <hannes@stressinduktion.org>\nSigned-off-by: David S. Miller <davem@davemloft.net>", "commit_date": "2015-12-03T04:37:16Z", "project": "torvalds/linux", "url": "https://api.github.com/repos/torvalds/linux/commits/45f6fad84cc305103b28d73482b344d7f5b76f39", "html_url": "https://github.com/torvalds/linux/commit/45f6fad84cc305103b28d73482b344d7f5b76f39", "windows_before": "", "windows_after": "", "parents": [{"commit_id_before": "01b3f52157ff5a47d6d8d796f396a4b34a53c61d", "url_before": "https://api.github.com/repos/torvalds/linux/commits/01b3f52157ff5a47d6d8d796f396a4b34a53c61d", "html_url_before": "https://github.com/torvalds/linux/commit/01b3f52157ff5a47d6d8d796f396a4b34a53c61d"}], "details": [{"raw_url": "https://github.com/torvalds/linux/raw/45f6fad84cc305103b28d73482b344d7f5b76f39/include/linux/ipv6.h", "patch": "@@ -227,7 +227,7 @@ struct ipv6_pinfo {\n \tstruct ipv6_ac_socklist\t*ipv6_ac_list;\n \tstruct ipv6_fl_socklist __rcu *ipv6_fl_list;\n \n-\tstruct ipv6_txoptions\t*opt;\n+\tstruct ipv6_txoptions __rcu\t*opt;\n \tstruct sk_buff\t\t*pktoptions;\n \tstruct sk_buff\t\t*rxpmtu;\n \tstruct inet6_cork\tcork;", "file_path": "files/2016_8\\82", "file_language": "h", "file_name": "include/linux/ipv6.h", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}, {"raw_url": "https://github.com/torvalds/linux/raw/45f6fad84cc305103b28d73482b344d7f5b76f39/include/net/ipv6.h", "patch": "@@ -205,6 +205,7 @@ extern rwlock_t ip6_ra_lock;\n  */\n \n struct ipv6_txoptions {\n+\tatomic_t\t\trefcnt;\n \t/* Length of this structure */\n \tint\t\t\ttot_len;\n \n@@ -217,7 +218,7 @@ struct ipv6_txoptions {\n \tstruct ipv6_opt_hdr\t*dst0opt;\n \tstruct ipv6_rt_hdr\t*srcrt;\t/* Routing Header */\n \tstruct ipv6_opt_hdr\t*dst1opt;\n-\n+\tstruct rcu_head\t\trcu;\n \t/* Option buffer, as read by IPV6_PKTOPTIONS, starts here. */\n };\n \n@@ -252,6 +253,24 @@ struct ipv6_fl_socklist {\n \tstruct rcu_head\t\t\trcu;\n };\n \n+static inline struct ipv6_txoptions *txopt_get(const struct ipv6_pinfo *np)\n+{\n+\tstruct ipv6_txoptions *opt;\n+\n+\trcu_read_lock();\n+\topt = rcu_dereference(np->opt);\n+\tif (opt && !atomic_inc_not_zero(&opt->refcnt))\n+\t\topt = NULL;\n+\trcu_read_unlock();\n+\treturn opt;\n+}\n+\n+static inline void txopt_put(struct ipv6_txoptions *opt)\n+{\n+\tif (opt && atomic_dec_and_test(&opt->refcnt))\n+\t\tkfree_rcu(opt, rcu);\n+}\n+\n struct ip6_flowlabel *fl6_sock_lookup(struct sock *sk, __be32 label);\n struct ipv6_txoptions *fl6_merge_options(struct ipv6_txoptions *opt_space,\n \t\t\t\t\t struct ip6_flowlabel *fl,", "file_path": "files/2016_8\\83", "file_language": "h", "file_name": "include/net/ipv6.h", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}, {"raw_url": "https://github.com/torvalds/linux/raw/45f6fad84cc305103b28d73482b344d7f5b76f39/net/dccp/ipv6.c", "patch": "@@ -202,7 +202,9 @@ static int dccp_v6_send_response(const struct sock *sk, struct request_sock *req\n \tsecurity_req_classify_flow(req, flowi6_to_flowi(&fl6));\n \n \n-\tfinal_p = fl6_update_dst(&fl6, np->opt, &final);\n+\trcu_read_lock();\n+\tfinal_p = fl6_update_dst(&fl6, rcu_dereference(np->opt), &final);\n+\trcu_read_unlock();\n \n \tdst = ip6_dst_lookup_flow(sk, &fl6, final_p);\n \tif (IS_ERR(dst)) {\n@@ -219,7 +221,10 @@ static int dccp_v6_send_response(const struct sock *sk, struct request_sock *req\n \t\t\t\t\t\t\t &ireq->ir_v6_loc_addr,\n \t\t\t\t\t\t\t &ireq->ir_v6_rmt_addr);\n \t\tfl6.daddr = ireq->ir_v6_rmt_addr;\n-\t\terr = ip6_xmit(sk, skb, &fl6, np->opt, np->tclass);\n+\t\trcu_read_lock();\n+\t\terr = ip6_xmit(sk, skb, &fl6, rcu_dereference(np->opt),\n+\t\t\t       np->tclass);\n+\t\trcu_read_unlock();\n \t\terr = net_xmit_eval(err);\n \t}\n \n@@ -387,6 +392,7 @@ static struct sock *dccp_v6_request_recv_sock(const struct sock *sk,\n \tstruct inet_request_sock *ireq = inet_rsk(req);\n \tstruct ipv6_pinfo *newnp;\n \tconst struct ipv6_pinfo *np = inet6_sk(sk);\n+\tstruct ipv6_txoptions *opt;\n \tstruct inet_sock *newinet;\n \tstruct dccp6_sock *newdp6;\n \tstruct sock *newsk;\n@@ -488,13 +494,15 @@ static struct sock *dccp_v6_request_recv_sock(const struct sock *sk,\n \t * Yes, keeping reference count would be much more clever, but we make\n \t * one more one thing there: reattach optmem to newsk.\n \t */\n-\tif (np->opt != NULL)\n-\t\tnewnp->opt = ipv6_dup_options(newsk, np->opt);\n-\n+\topt = rcu_dereference(np->opt);\n+\tif (opt) {\n+\t\topt = ipv6_dup_options(newsk, opt);\n+\t\tRCU_INIT_POINTER(newnp->opt, opt);\n+\t}\n \tinet_csk(newsk)->icsk_ext_hdr_len = 0;\n-\tif (newnp->opt != NULL)\n-\t\tinet_csk(newsk)->icsk_ext_hdr_len = (newnp->opt->opt_nflen +\n-\t\t\t\t\t\t     newnp->opt->opt_flen);\n+\tif (opt)\n+\t\tinet_csk(newsk)->icsk_ext_hdr_len = opt->opt_nflen +\n+\t\t\t\t\t\t    opt->opt_flen;\n \n \tdccp_sync_mss(newsk, dst_mtu(dst));\n \n@@ -757,6 +765,7 @@ static int dccp_v6_connect(struct sock *sk, struct sockaddr *uaddr,\n \tstruct ipv6_pinfo *np = inet6_sk(sk);\n \tstruct dccp_sock *dp = dccp_sk(sk);\n \tstruct in6_addr *saddr = NULL, *final_p, final;\n+\tstruct ipv6_txoptions *opt;\n \tstruct flowi6 fl6;\n \tstruct dst_entry *dst;\n \tint addr_type;\n@@ -856,7 +865,8 @@ static int dccp_v6_connect(struct sock *sk, struct sockaddr *uaddr,\n \tfl6.fl6_sport = inet->inet_sport;\n \tsecurity_sk_classify_flow(sk, flowi6_to_flowi(&fl6));\n \n-\tfinal_p = fl6_update_dst(&fl6, np->opt, &final);\n+\topt = rcu_dereference_protected(np->opt, sock_owned_by_user(sk));\n+\tfinal_p = fl6_update_dst(&fl6, opt, &final);\n \n \tdst = ip6_dst_lookup_flow(sk, &fl6, final_p);\n \tif (IS_ERR(dst)) {\n@@ -876,9 +886,8 @@ static int dccp_v6_connect(struct sock *sk, struct sockaddr *uaddr,\n \t__ip6_dst_store(sk, dst, NULL, NULL);\n \n \ticsk->icsk_ext_hdr_len = 0;\n-\tif (np->opt != NULL)\n-\t\ticsk->icsk_ext_hdr_len = (np->opt->opt_flen +\n-\t\t\t\t\t  np->opt->opt_nflen);\n+\tif (opt)\n+\t\ticsk->icsk_ext_hdr_len = opt->opt_flen + opt->opt_nflen;\n \n \tinet->inet_dport = usin->sin6_port;\n ", "file_path": "files/2016_8\\84", "file_language": "c", "file_name": "net/dccp/ipv6.c", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}, {"raw_url": "https://github.com/torvalds/linux/raw/45f6fad84cc305103b28d73482b344d7f5b76f39/net/ipv6/af_inet6.c", "patch": "@@ -428,9 +428,11 @@ void inet6_destroy_sock(struct sock *sk)\n \n \t/* Free tx options */\n \n-\topt = xchg(&np->opt, NULL);\n-\tif (opt)\n-\t\tsock_kfree_s(sk, opt, opt->tot_len);\n+\topt = xchg((__force struct ipv6_txoptions **)&np->opt, NULL);\n+\tif (opt) {\n+\t\tatomic_sub(opt->tot_len, &sk->sk_omem_alloc);\n+\t\ttxopt_put(opt);\n+\t}\n }\n EXPORT_SYMBOL_GPL(inet6_destroy_sock);\n \n@@ -659,7 +661,10 @@ int inet6_sk_rebuild_header(struct sock *sk)\n \t\tfl6.fl6_sport = inet->inet_sport;\n \t\tsecurity_sk_classify_flow(sk, flowi6_to_flowi(&fl6));\n \n-\t\tfinal_p = fl6_update_dst(&fl6, np->opt, &final);\n+\t\trcu_read_lock();\n+\t\tfinal_p = fl6_update_dst(&fl6, rcu_dereference(np->opt),\n+\t\t\t\t\t &final);\n+\t\trcu_read_unlock();\n \n \t\tdst = ip6_dst_lookup_flow(sk, &fl6, final_p);\n \t\tif (IS_ERR(dst)) {", "file_path": "files/2016_8\\85", "file_language": "c", "file_name": "net/ipv6/af_inet6.c", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}, {"raw_url": "https://github.com/torvalds/linux/raw/45f6fad84cc305103b28d73482b344d7f5b76f39/net/ipv6/datagram.c", "patch": "@@ -167,8 +167,10 @@ static int __ip6_datagram_connect(struct sock *sk, struct sockaddr *uaddr, int a\n \n \tsecurity_sk_classify_flow(sk, flowi6_to_flowi(&fl6));\n \n-\topt = flowlabel ? flowlabel->opt : np->opt;\n+\trcu_read_lock();\n+\topt = flowlabel ? flowlabel->opt : rcu_dereference(np->opt);\n \tfinal_p = fl6_update_dst(&fl6, opt, &final);\n+\trcu_read_unlock();\n \n \tdst = ip6_dst_lookup_flow(sk, &fl6, final_p);\n \terr = 0;", "file_path": "files/2016_8\\86", "file_language": "c", "file_name": "net/ipv6/datagram.c", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}, {"raw_url": "https://github.com/torvalds/linux/raw/45f6fad84cc305103b28d73482b344d7f5b76f39/net/ipv6/exthdrs.c", "patch": "@@ -727,6 +727,7 @@ ipv6_dup_options(struct sock *sk, struct ipv6_txoptions *opt)\n \t\t\t*((char **)&opt2->dst1opt) += dif;\n \t\tif (opt2->srcrt)\n \t\t\t*((char **)&opt2->srcrt) += dif;\n+\t\tatomic_set(&opt2->refcnt, 1);\n \t}\n \treturn opt2;\n }\n@@ -790,7 +791,7 @@ ipv6_renew_options(struct sock *sk, struct ipv6_txoptions *opt,\n \t\treturn ERR_PTR(-ENOBUFS);\n \n \tmemset(opt2, 0, tot_len);\n-\n+\tatomic_set(&opt2->refcnt, 1);\n \topt2->tot_len = tot_len;\n \tp = (char *)(opt2 + 1);\n ", "file_path": "files/2016_8\\87", "file_language": "c", "file_name": "net/ipv6/exthdrs.c", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}, {"raw_url": "https://github.com/torvalds/linux/raw/45f6fad84cc305103b28d73482b344d7f5b76f39/net/ipv6/inet6_connection_sock.c", "patch": "@@ -78,7 +78,9 @@ struct dst_entry *inet6_csk_route_req(const struct sock *sk,\n \tmemset(fl6, 0, sizeof(*fl6));\n \tfl6->flowi6_proto = proto;\n \tfl6->daddr = ireq->ir_v6_rmt_addr;\n-\tfinal_p = fl6_update_dst(fl6, np->opt, &final);\n+\trcu_read_lock();\n+\tfinal_p = fl6_update_dst(fl6, rcu_dereference(np->opt), &final);\n+\trcu_read_unlock();\n \tfl6->saddr = ireq->ir_v6_loc_addr;\n \tfl6->flowi6_oif = ireq->ir_iif;\n \tfl6->flowi6_mark = ireq->ir_mark;\n@@ -142,7 +144,9 @@ static struct dst_entry *inet6_csk_route_socket(struct sock *sk,\n \tfl6->fl6_dport = inet->inet_dport;\n \tsecurity_sk_classify_flow(sk, flowi6_to_flowi(fl6));\n \n-\tfinal_p = fl6_update_dst(fl6, np->opt, &final);\n+\trcu_read_lock();\n+\tfinal_p = fl6_update_dst(fl6, rcu_dereference(np->opt), &final);\n+\trcu_read_unlock();\n \n \tdst = __inet6_csk_dst_check(sk, np->dst_cookie);\n \tif (!dst) {\n@@ -175,7 +179,8 @@ int inet6_csk_xmit(struct sock *sk, struct sk_buff *skb, struct flowi *fl_unused\n \t/* Restore final destination back after routing done */\n \tfl6.daddr = sk->sk_v6_daddr;\n \n-\tres = ip6_xmit(sk, skb, &fl6, np->opt, np->tclass);\n+\tres = ip6_xmit(sk, skb, &fl6, rcu_dereference(np->opt),\n+\t\t       np->tclass);\n \trcu_read_unlock();\n \treturn res;\n }", "file_path": "files/2016_8\\88", "file_language": "c", "file_name": "net/ipv6/inet6_connection_sock.c", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}, {"raw_url": "https://github.com/torvalds/linux/raw/45f6fad84cc305103b28d73482b344d7f5b76f39/net/ipv6/ipv6_sockglue.c", "patch": "@@ -111,7 +111,8 @@ struct ipv6_txoptions *ipv6_update_options(struct sock *sk,\n \t\t\ticsk->icsk_sync_mss(sk, icsk->icsk_pmtu_cookie);\n \t\t}\n \t}\n-\topt = xchg(&inet6_sk(sk)->opt, opt);\n+\topt = xchg((__force struct ipv6_txoptions **)&inet6_sk(sk)->opt,\n+\t\t   opt);\n \tsk_dst_reset(sk);\n \n \treturn opt;\n@@ -231,9 +232,12 @@ static int do_ipv6_setsockopt(struct sock *sk, int level, int optname,\n \t\t\t\tsk->sk_socket->ops = &inet_dgram_ops;\n \t\t\t\tsk->sk_family = PF_INET;\n \t\t\t}\n-\t\t\topt = xchg(&np->opt, NULL);\n-\t\t\tif (opt)\n-\t\t\t\tsock_kfree_s(sk, opt, opt->tot_len);\n+\t\t\topt = xchg((__force struct ipv6_txoptions **)&np->opt,\n+\t\t\t\t   NULL);\n+\t\t\tif (opt) {\n+\t\t\t\tatomic_sub(opt->tot_len, &sk->sk_omem_alloc);\n+\t\t\t\ttxopt_put(opt);\n+\t\t\t}\n \t\t\tpktopt = xchg(&np->pktoptions, NULL);\n \t\t\tkfree_skb(pktopt);\n \n@@ -403,7 +407,8 @@ static int do_ipv6_setsockopt(struct sock *sk, int level, int optname,\n \t\tif (optname != IPV6_RTHDR && !ns_capable(net->user_ns, CAP_NET_RAW))\n \t\t\tbreak;\n \n-\t\topt = ipv6_renew_options(sk, np->opt, optname,\n+\t\topt = rcu_dereference_protected(np->opt, sock_owned_by_user(sk));\n+\t\topt = ipv6_renew_options(sk, opt, optname,\n \t\t\t\t\t (struct ipv6_opt_hdr __user *)optval,\n \t\t\t\t\t optlen);\n \t\tif (IS_ERR(opt)) {\n@@ -432,8 +437,10 @@ static int do_ipv6_setsockopt(struct sock *sk, int level, int optname,\n \t\tretv = 0;\n \t\topt = ipv6_update_options(sk, opt);\n sticky_done:\n-\t\tif (opt)\n-\t\t\tsock_kfree_s(sk, opt, opt->tot_len);\n+\t\tif (opt) {\n+\t\t\tatomic_sub(opt->tot_len, &sk->sk_omem_alloc);\n+\t\t\ttxopt_put(opt);\n+\t\t}\n \t\tbreak;\n \t}\n \n@@ -486,6 +493,7 @@ static int do_ipv6_setsockopt(struct sock *sk, int level, int optname,\n \t\t\tbreak;\n \n \t\tmemset(opt, 0, sizeof(*opt));\n+\t\tatomic_set(&opt->refcnt, 1);\n \t\topt->tot_len = sizeof(*opt) + optlen;\n \t\tretv = -EFAULT;\n \t\tif (copy_from_user(opt+1, optval, optlen))\n@@ -502,8 +510,10 @@ static int do_ipv6_setsockopt(struct sock *sk, int level, int optname,\n \t\tretv = 0;\n \t\topt = ipv6_update_options(sk, opt);\n done:\n-\t\tif (opt)\n-\t\t\tsock_kfree_s(sk, opt, opt->tot_len);\n+\t\tif (opt) {\n+\t\t\tatomic_sub(opt->tot_len, &sk->sk_omem_alloc);\n+\t\t\ttxopt_put(opt);\n+\t\t}\n \t\tbreak;\n \t}\n \tcase IPV6_UNICAST_HOPS:\n@@ -1110,10 +1120,11 @@ static int do_ipv6_getsockopt(struct sock *sk, int level, int optname,\n \tcase IPV6_RTHDR:\n \tcase IPV6_DSTOPTS:\n \t{\n+\t\tstruct ipv6_txoptions *opt;\n \n \t\tlock_sock(sk);\n-\t\tlen = ipv6_getsockopt_sticky(sk, np->opt,\n-\t\t\t\t\t     optname, optval, len);\n+\t\topt = rcu_dereference_protected(np->opt, sock_owned_by_user(sk));\n+\t\tlen = ipv6_getsockopt_sticky(sk, opt, optname, optval, len);\n \t\trelease_sock(sk);\n \t\t/* check if ipv6_getsockopt_sticky() returns err code */\n \t\tif (len < 0)", "file_path": "files/2016_8\\89", "file_language": "c", "file_name": "net/ipv6/ipv6_sockglue.c", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}, {"raw_url": "https://github.com/torvalds/linux/raw/45f6fad84cc305103b28d73482b344d7f5b76f39/net/ipv6/raw.c", "patch": "@@ -733,6 +733,7 @@ static int raw6_getfrag(void *from, char *to, int offset, int len, int odd,\n \n static int rawv6_sendmsg(struct sock *sk, struct msghdr *msg, size_t len)\n {\n+\tstruct ipv6_txoptions *opt_to_free = NULL;\n \tstruct ipv6_txoptions opt_space;\n \tDECLARE_SOCKADDR(struct sockaddr_in6 *, sin6, msg->msg_name);\n \tstruct in6_addr *daddr, *final_p, final;\n@@ -839,8 +840,10 @@ static int rawv6_sendmsg(struct sock *sk, struct msghdr *msg, size_t len)\n \t\tif (!(opt->opt_nflen|opt->opt_flen))\n \t\t\topt = NULL;\n \t}\n-\tif (!opt)\n-\t\topt = np->opt;\n+\tif (!opt) {\n+\t\topt = txopt_get(np);\n+\t\topt_to_free = opt;\n+\t\t}\n \tif (flowlabel)\n \t\topt = fl6_merge_options(&opt_space, flowlabel, opt);\n \topt = ipv6_fixup_options(&opt_space, opt);\n@@ -906,6 +909,7 @@ static int rawv6_sendmsg(struct sock *sk, struct msghdr *msg, size_t len)\n \tdst_release(dst);\n out:\n \tfl6_sock_release(flowlabel);\n+\ttxopt_put(opt_to_free);\n \treturn err < 0 ? err : len;\n do_confirm:\n \tdst_confirm(dst);", "file_path": "files/2016_8\\90", "file_language": "c", "file_name": "net/ipv6/raw.c", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}, {"raw_url": "https://github.com/torvalds/linux/raw/45f6fad84cc305103b28d73482b344d7f5b76f39/net/ipv6/syncookies.c", "patch": "@@ -222,7 +222,7 @@ struct sock *cookie_v6_check(struct sock *sk, struct sk_buff *skb)\n \t\tmemset(&fl6, 0, sizeof(fl6));\n \t\tfl6.flowi6_proto = IPPROTO_TCP;\n \t\tfl6.daddr = ireq->ir_v6_rmt_addr;\n-\t\tfinal_p = fl6_update_dst(&fl6, np->opt, &final);\n+\t\tfinal_p = fl6_update_dst(&fl6, rcu_dereference(np->opt), &final);\n \t\tfl6.saddr = ireq->ir_v6_loc_addr;\n \t\tfl6.flowi6_oif = sk->sk_bound_dev_if;\n \t\tfl6.flowi6_mark = ireq->ir_mark;", "file_path": "files/2016_8\\91", "file_language": "c", "file_name": "net/ipv6/syncookies.c", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}, {"raw_url": "https://github.com/torvalds/linux/raw/45f6fad84cc305103b28d73482b344d7f5b76f39/net/ipv6/tcp_ipv6.c", "patch": "@@ -120,6 +120,7 @@ static int tcp_v6_connect(struct sock *sk, struct sockaddr *uaddr,\n \tstruct ipv6_pinfo *np = inet6_sk(sk);\n \tstruct tcp_sock *tp = tcp_sk(sk);\n \tstruct in6_addr *saddr = NULL, *final_p, final;\n+\tstruct ipv6_txoptions *opt;\n \tstruct flowi6 fl6;\n \tstruct dst_entry *dst;\n \tint addr_type;\n@@ -235,7 +236,8 @@ static int tcp_v6_connect(struct sock *sk, struct sockaddr *uaddr,\n \tfl6.fl6_dport = usin->sin6_port;\n \tfl6.fl6_sport = inet->inet_sport;\n \n-\tfinal_p = fl6_update_dst(&fl6, np->opt, &final);\n+\topt = rcu_dereference_protected(np->opt, sock_owned_by_user(sk));\n+\tfinal_p = fl6_update_dst(&fl6, opt, &final);\n \n \tsecurity_sk_classify_flow(sk, flowi6_to_flowi(&fl6));\n \n@@ -263,9 +265,9 @@ static int tcp_v6_connect(struct sock *sk, struct sockaddr *uaddr,\n \t\ttcp_fetch_timewait_stamp(sk, dst);\n \n \ticsk->icsk_ext_hdr_len = 0;\n-\tif (np->opt)\n-\t\ticsk->icsk_ext_hdr_len = (np->opt->opt_flen +\n-\t\t\t\t\t  np->opt->opt_nflen);\n+\tif (opt)\n+\t\ticsk->icsk_ext_hdr_len = opt->opt_flen +\n+\t\t\t\t\t opt->opt_nflen;\n \n \ttp->rx_opt.mss_clamp = IPV6_MIN_MTU - sizeof(struct tcphdr) - sizeof(struct ipv6hdr);\n \n@@ -461,7 +463,8 @@ static int tcp_v6_send_synack(const struct sock *sk, struct dst_entry *dst,\n \t\tif (np->repflow && ireq->pktopts)\n \t\t\tfl6->flowlabel = ip6_flowlabel(ipv6_hdr(ireq->pktopts));\n \n-\t\terr = ip6_xmit(sk, skb, fl6, np->opt, np->tclass);\n+\t\terr = ip6_xmit(sk, skb, fl6, rcu_dereference(np->opt),\n+\t\t\t       np->tclass);\n \t\terr = net_xmit_eval(err);\n \t}\n \n@@ -972,6 +975,7 @@ static struct sock *tcp_v6_syn_recv_sock(const struct sock *sk, struct sk_buff *\n \tstruct inet_request_sock *ireq;\n \tstruct ipv6_pinfo *newnp;\n \tconst struct ipv6_pinfo *np = inet6_sk(sk);\n+\tstruct ipv6_txoptions *opt;\n \tstruct tcp6_sock *newtcp6sk;\n \tstruct inet_sock *newinet;\n \tstruct tcp_sock *newtp;\n@@ -1098,13 +1102,15 @@ static struct sock *tcp_v6_syn_recv_sock(const struct sock *sk, struct sk_buff *\n \t   but we make one more one thing there: reattach optmem\n \t   to newsk.\n \t */\n-\tif (np->opt)\n-\t\tnewnp->opt = ipv6_dup_options(newsk, np->opt);\n-\n+\topt = rcu_dereference(np->opt);\n+\tif (opt) {\n+\t\topt = ipv6_dup_options(newsk, opt);\n+\t\tRCU_INIT_POINTER(newnp->opt, opt);\n+\t}\n \tinet_csk(newsk)->icsk_ext_hdr_len = 0;\n-\tif (newnp->opt)\n-\t\tinet_csk(newsk)->icsk_ext_hdr_len = (newnp->opt->opt_nflen +\n-\t\t\t\t\t\t     newnp->opt->opt_flen);\n+\tif (opt)\n+\t\tinet_csk(newsk)->icsk_ext_hdr_len = opt->opt_nflen +\n+\t\t\t\t\t\t    opt->opt_flen;\n \n \ttcp_ca_openreq_child(newsk, dst);\n ", "file_path": "files/2016_8\\92", "file_language": "c", "file_name": "net/ipv6/tcp_ipv6.c", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}, {"raw_url": "https://github.com/torvalds/linux/raw/45f6fad84cc305103b28d73482b344d7f5b76f39/net/ipv6/udp.c", "patch": "@@ -1110,6 +1110,7 @@ int udpv6_sendmsg(struct sock *sk, struct msghdr *msg, size_t len)\n \tDECLARE_SOCKADDR(struct sockaddr_in6 *, sin6, msg->msg_name);\n \tstruct in6_addr *daddr, *final_p, final;\n \tstruct ipv6_txoptions *opt = NULL;\n+\tstruct ipv6_txoptions *opt_to_free = NULL;\n \tstruct ip6_flowlabel *flowlabel = NULL;\n \tstruct flowi6 fl6;\n \tstruct dst_entry *dst;\n@@ -1263,8 +1264,10 @@ int udpv6_sendmsg(struct sock *sk, struct msghdr *msg, size_t len)\n \t\t\topt = NULL;\n \t\tconnected = 0;\n \t}\n-\tif (!opt)\n-\t\topt = np->opt;\n+\tif (!opt) {\n+\t\topt = txopt_get(np);\n+\t\topt_to_free = opt;\n+\t}\n \tif (flowlabel)\n \t\topt = fl6_merge_options(&opt_space, flowlabel, opt);\n \topt = ipv6_fixup_options(&opt_space, opt);\n@@ -1373,6 +1376,7 @@ int udpv6_sendmsg(struct sock *sk, struct msghdr *msg, size_t len)\n out:\n \tdst_release(dst);\n \tfl6_sock_release(flowlabel);\n+\ttxopt_put(opt_to_free);\n \tif (!err)\n \t\treturn len;\n \t/*", "file_path": "files/2016_8\\93", "file_language": "c", "file_name": "net/ipv6/udp.c", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}, {"raw_url": "https://github.com/torvalds/linux/raw/45f6fad84cc305103b28d73482b344d7f5b76f39/net/l2tp/l2tp_ip6.c", "patch": "@@ -486,6 +486,7 @@ static int l2tp_ip6_sendmsg(struct sock *sk, struct msghdr *msg, size_t len)\n \tDECLARE_SOCKADDR(struct sockaddr_l2tpip6 *, lsa, msg->msg_name);\n \tstruct in6_addr *daddr, *final_p, final;\n \tstruct ipv6_pinfo *np = inet6_sk(sk);\n+\tstruct ipv6_txoptions *opt_to_free = NULL;\n \tstruct ipv6_txoptions *opt = NULL;\n \tstruct ip6_flowlabel *flowlabel = NULL;\n \tstruct dst_entry *dst = NULL;\n@@ -575,8 +576,10 @@ static int l2tp_ip6_sendmsg(struct sock *sk, struct msghdr *msg, size_t len)\n \t\t\topt = NULL;\n \t}\n \n-\tif (opt == NULL)\n-\t\topt = np->opt;\n+\tif (!opt) {\n+\t\topt = txopt_get(np);\n+\t\topt_to_free = opt;\n+\t}\n \tif (flowlabel)\n \t\topt = fl6_merge_options(&opt_space, flowlabel, opt);\n \topt = ipv6_fixup_options(&opt_space, opt);\n@@ -631,6 +634,7 @@ static int l2tp_ip6_sendmsg(struct sock *sk, struct msghdr *msg, size_t len)\n \tdst_release(dst);\n out:\n \tfl6_sock_release(flowlabel);\n+\ttxopt_put(opt_to_free);\n \n \treturn err < 0 ? err : len;\n ", "file_path": "files/2016_8\\94", "file_language": "c", "file_name": "net/l2tp/l2tp_ip6.c", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}], "outdated": 0}
{"index": 34, "cve_id": "CVE-2016-6156", "cwe_id": ["CWE-362"], "cve_language": "C", "cve_description": "Race condition in the ec_device_ioctl_xcmd function in drivers/platform/chrome/cros_ec_dev.c in the Linux kernel before 4.7 allows local users to cause a denial of service (out-of-bounds array access) by changing a certain size value, aka a \"double fetch\" vulnerability.", "cvss": "5.1", "publish_date": "August 6, 2016", "AV": "LOCAL", "AC": "HIGH", "PR": "NONE", "UI": "NONE", "S": "UNCHANGED", "C": "NONE", "I": "NONE", "A": "HIGH", "commit_id": "096cdc6f52225835ff503f987a0d68ef770bb78e", "commit_message": "platform/chrome: cros_ec_dev - double fetch bug in ioctl\n\nWe verify \"u_cmd.outsize\" and \"u_cmd.insize\" but we need to make sure\nthat those values have not changed between the two copy_from_user()\ncalls.  Otherwise it could lead to a buffer overflow.\n\nAdditionally, cros_ec_cmd_xfer() can set s_cmd->insize to a lower value.\nWe should use the new smaller value so we don't copy too much data to\nthe user.\n\nReported-by: Pengfei Wang <wpengfeinudt@gmail.com>\nFixes: a841178445bb ('mfd: cros_ec: Use a zero-length array for command data')\nSigned-off-by: Dan Carpenter <dan.carpenter@oracle.com>\nReviewed-by: Kees Cook <keescook@chromium.org>\nTested-by: Gwendal Grignou <gwendal@chromium.org>\nCc: <stable@vger.kernel.org> # v4.2+\nSigned-off-by: Olof Johansson <olof@lixom.net>", "commit_date": "2016-07-05T21:01:52Z", "project": "torvalds/linux", "url": "https://api.github.com/repos/torvalds/linux/commits/096cdc6f52225835ff503f987a0d68ef770bb78e", "html_url": "https://github.com/torvalds/linux/commit/096cdc6f52225835ff503f987a0d68ef770bb78e", "windows_before": "", "windows_after": "", "parents": [{"commit_id_before": "33688abb2802ff3a230bd2441f765477b94cc89e", "url_before": "https://api.github.com/repos/torvalds/linux/commits/33688abb2802ff3a230bd2441f765477b94cc89e", "html_url_before": "https://github.com/torvalds/linux/commit/33688abb2802ff3a230bd2441f765477b94cc89e"}], "details": [{"raw_url": "https://github.com/torvalds/linux/raw/096cdc6f52225835ff503f987a0d68ef770bb78e/drivers/platform/chrome/cros_ec_dev.c", "patch": "@@ -151,13 +151,19 @@ static long ec_device_ioctl_xcmd(struct cros_ec_dev *ec, void __user *arg)\n \t\tgoto exit;\n \t}\n \n+\tif (u_cmd.outsize != s_cmd->outsize ||\n+\t    u_cmd.insize != s_cmd->insize) {\n+\t\tret = -EINVAL;\n+\t\tgoto exit;\n+\t}\n+\n \ts_cmd->command += ec->cmd_offset;\n \tret = cros_ec_cmd_xfer(ec->ec_dev, s_cmd);\n \t/* Only copy data to userland if data was received. */\n \tif (ret < 0)\n \t\tgoto exit;\n \n-\tif (copy_to_user(arg, s_cmd, sizeof(*s_cmd) + u_cmd.insize))\n+\tif (copy_to_user(arg, s_cmd, sizeof(*s_cmd) + s_cmd->insize))\n \t\tret = -EFAULT;\n exit:\n \tkfree(s_cmd);", "file_path": "files/2016_8\\95", "file_language": "c", "file_name": "drivers/platform/chrome/cros_ec_dev.c", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}], "outdated": 0}
{"index": 35, "cve_id": "CVE-2016-6187", "cwe_id": ["CWE-119", "CWE-264"], "cve_language": "C", "cve_description": "The apparmor_setprocattr function in security/apparmor/lsm.c in the Linux kernel before 4.6.5 does not validate the buffer size, which allows local users to gain privileges by triggering an AppArmor setprocattr hook.", "cvss": "7.8", "publish_date": "August 6, 2016", "AV": "LOCAL", "AC": "LOW", "PR": "LOW", "UI": "NONE", "S": "UNCHANGED", "C": "HIGH", "I": "HIGH", "A": "HIGH", "commit_id": "30a46a4647fd1df9cf52e43bf467f0d9265096ca", "commit_message": "apparmor: fix oops, validate buffer size in apparmor_setprocattr()\n\nWhen proc_pid_attr_write() was changed to use memdup_user apparmor's\n(interface violating) assumption that the setprocattr buffer was always\na single page was violated.\n\nThe size test is not strictly speaking needed as proc_pid_attr_write()\nwill reject anything larger, but for the sake of robustness we can keep\nit in.\n\nSMACK and SELinux look safe to me, but somebody else should probably\nhave a look just in case.\n\nBased on original patch from Vegard Nossum <vegard.nossum@oracle.com>\nmodified for the case that apparmor provides null termination.\n\nFixes: bb646cdb12e75d82258c2f2e7746d5952d3e321a\nReported-by: Vegard Nossum <vegard.nossum@oracle.com>\nCc: Al Viro <viro@zeniv.linux.org.uk>\nCc: John Johansen <john.johansen@canonical.com>\nCc: Paul Moore <paul@paul-moore.com>\nCc: Stephen Smalley <sds@tycho.nsa.gov>\nCc: Eric Paris <eparis@parisplace.org>\nCc: Casey Schaufler <casey@schaufler-ca.com>\nCc: stable@kernel.org\nSigned-off-by: John Johansen <john.johansen@canonical.com>\nReviewed-by: Tyler Hicks <tyhicks@canonical.com>\nSigned-off-by: James Morris <james.l.morris@oracle.com>", "commit_date": "2016-07-08T00:26:25Z", "project": "torvalds/linux", "url": "https://api.github.com/repos/torvalds/linux/commits/30a46a4647fd1df9cf52e43bf467f0d9265096ca", "html_url": "https://github.com/torvalds/linux/commit/30a46a4647fd1df9cf52e43bf467f0d9265096ca", "windows_before": "", "windows_after": "", "parents": [{"commit_id_before": "ac904ae6e6f0a56be7b9a1cf66fbd50dd025fb06", "url_before": "https://api.github.com/repos/torvalds/linux/commits/ac904ae6e6f0a56be7b9a1cf66fbd50dd025fb06", "html_url_before": "https://github.com/torvalds/linux/commit/ac904ae6e6f0a56be7b9a1cf66fbd50dd025fb06"}], "details": [{"raw_url": "https://github.com/torvalds/linux/raw/30a46a4647fd1df9cf52e43bf467f0d9265096ca/security/apparmor/lsm.c", "patch": "@@ -500,34 +500,34 @@ static int apparmor_setprocattr(struct task_struct *task, char *name,\n {\n \tstruct common_audit_data sa;\n \tstruct apparmor_audit_data aad = {0,};\n-\tchar *command, *args = value;\n+\tchar *command, *largs = NULL, *args = value;\n \tsize_t arg_size;\n \tint error;\n \n \tif (size == 0)\n \t\treturn -EINVAL;\n-\t/* args points to a PAGE_SIZE buffer, AppArmor requires that\n-\t * the buffer must be null terminated or have size <= PAGE_SIZE -1\n-\t * so that AppArmor can null terminate them\n-\t */\n-\tif (args[size - 1] != '\\0') {\n-\t\tif (size == PAGE_SIZE)\n-\t\t\treturn -EINVAL;\n-\t\targs[size] = '\\0';\n-\t}\n-\n \t/* task can only write its own attributes */\n \tif (current != task)\n \t\treturn -EACCES;\n \n-\targs = value;\n+\t/* AppArmor requires that the buffer must be null terminated atm */\n+\tif (args[size - 1] != '\\0') {\n+\t\t/* null terminate */\n+\t\tlargs = args = kmalloc(size + 1, GFP_KERNEL);\n+\t\tif (!args)\n+\t\t\treturn -ENOMEM;\n+\t\tmemcpy(args, value, size);\n+\t\targs[size] = '\\0';\n+\t}\n+\n+\terror = -EINVAL;\n \targs = strim(args);\n \tcommand = strsep(&args, \" \");\n \tif (!args)\n-\t\treturn -EINVAL;\n+\t\tgoto out;\n \targs = skip_spaces(args);\n \tif (!*args)\n-\t\treturn -EINVAL;\n+\t\tgoto out;\n \n \targ_size = size - (args - (char *) value);\n \tif (strcmp(name, \"current\") == 0) {\n@@ -553,10 +553,12 @@ static int apparmor_setprocattr(struct task_struct *task, char *name,\n \t\t\tgoto fail;\n \t} else\n \t\t/* only support the \"current\" and \"exec\" process attributes */\n-\t\treturn -EINVAL;\n+\t\tgoto fail;\n \n \tif (!error)\n \t\terror = size;\n+out:\n+\tkfree(largs);\n \treturn error;\n \n fail:\n@@ -565,9 +567,9 @@ static int apparmor_setprocattr(struct task_struct *task, char *name,\n \taad.profile = aa_current_profile();\n \taad.op = OP_SETPROCATTR;\n \taad.info = name;\n-\taad.error = -EINVAL;\n+\taad.error = error = -EINVAL;\n \taa_audit_msg(AUDIT_APPARMOR_DENIED, &sa, NULL);\n-\treturn -EINVAL;\n+\tgoto out;\n }\n \n static int apparmor_task_setrlimit(struct task_struct *task,", "file_path": "files/2016_8\\96", "file_language": "c", "file_name": "security/apparmor/lsm.c", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}], "outdated": 0}
{"index": 36, "cve_id": "CVE-2016-6198", "cwe_id": ["CWE-284"], "cve_language": "C", "cve_description": "The filesystem layer in the Linux kernel before 4.5.5 proceeds with post-rename operations after an OverlayFS file is renamed to a self-hardlink, which allows local users to cause a denial of service (system crash) via a rename system call, related to fs/namei.c and fs/open.c.", "cvss": "5.5", "publish_date": "August 6, 2016", "AV": "LOCAL", "AC": "LOW", "PR": "LOW", "UI": "NONE", "S": "UNCHANGED", "C": "NONE", "I": "NONE", "A": "HIGH", "commit_id": "54d5ca871e72f2bb172ec9323497f01cd5091ec7", "commit_message": "vfs: add vfs_select_inode() helper\n\nSigned-off-by: Miklos Szeredi <mszeredi@redhat.com>\nCc: <stable@vger.kernel.org> # v4.2+", "commit_date": "2016-05-11T03:55:01Z", "project": "torvalds/linux", "url": "https://api.github.com/repos/torvalds/linux/commits/54d5ca871e72f2bb172ec9323497f01cd5091ec7", "html_url": "https://github.com/torvalds/linux/commit/54d5ca871e72f2bb172ec9323497f01cd5091ec7", "windows_before": "", "windows_after": "", "parents": [{"commit_id_before": "44549e8f5eea4e0a41b487b63e616cb089922b99", "url_before": "https://api.github.com/repos/torvalds/linux/commits/44549e8f5eea4e0a41b487b63e616cb089922b99", "html_url_before": "https://github.com/torvalds/linux/commit/44549e8f5eea4e0a41b487b63e616cb089922b99"}], "details": [{"raw_url": "https://github.com/torvalds/linux/raw/54d5ca871e72f2bb172ec9323497f01cd5091ec7/fs/open.c", "patch": "@@ -840,16 +840,12 @@ EXPORT_SYMBOL(file_path);\n int vfs_open(const struct path *path, struct file *file,\n \t     const struct cred *cred)\n {\n-\tstruct dentry *dentry = path->dentry;\n-\tstruct inode *inode = dentry->d_inode;\n+\tstruct inode *inode = vfs_select_inode(path->dentry, file->f_flags);\n \n-\tfile->f_path = *path;\n-\tif (dentry->d_flags & DCACHE_OP_SELECT_INODE) {\n-\t\tinode = dentry->d_op->d_select_inode(dentry, file->f_flags);\n-\t\tif (IS_ERR(inode))\n-\t\t\treturn PTR_ERR(inode);\n-\t}\n+\tif (IS_ERR(inode))\n+\t\treturn PTR_ERR(inode);\n \n+\tfile->f_path = *path;\n \treturn do_dentry_open(file, inode, NULL, cred);\n }\n ", "file_path": "files/2016_8\\97", "file_language": "c", "file_name": "fs/open.c", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}, {"raw_url": "https://github.com/torvalds/linux/raw/54d5ca871e72f2bb172ec9323497f01cd5091ec7/include/linux/dcache.h", "patch": "@@ -565,4 +565,16 @@ static inline struct dentry *d_real(struct dentry *dentry)\n \t\treturn dentry;\n }\n \n+static inline struct inode *vfs_select_inode(struct dentry *dentry,\n+\t\t\t\t\t     unsigned open_flags)\n+{\n+\tstruct inode *inode = d_inode(dentry);\n+\n+\tif (inode && unlikely(dentry->d_flags & DCACHE_OP_SELECT_INODE))\n+\t\tinode = dentry->d_op->d_select_inode(dentry, open_flags);\n+\n+\treturn inode;\n+}\n+\n+\n #endif\t/* __LINUX_DCACHE_H */", "file_path": "files/2016_8\\98", "file_language": "h", "file_name": "include/linux/dcache.h", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}], "outdated": 0}
{"index": 37, "cve_id": "CVE-2016-6198", "cwe_id": ["CWE-284"], "cve_language": "C", "cve_description": "The filesystem layer in the Linux kernel before 4.5.5 proceeds with post-rename operations after an OverlayFS file is renamed to a self-hardlink, which allows local users to cause a denial of service (system crash) via a rename system call, related to fs/namei.c and fs/open.c.", "cvss": "5.5", "publish_date": "August 6, 2016", "AV": "LOCAL", "AC": "LOW", "PR": "LOW", "UI": "NONE", "S": "UNCHANGED", "C": "NONE", "I": "NONE", "A": "HIGH", "commit_id": "9409e22acdfc9153f88d9b1ed2bd2a5b34d2d3ca", "commit_message": "vfs: rename: check backing inode being equal\n\nIf a file is renamed to a hardlink of itself POSIX specifies that rename(2)\nshould do nothing and return success.\n\nThis condition is checked in vfs_rename().  However it won't detect hard\nlinks on overlayfs where these are given separate inodes on the overlayfs\nlayer.\n\nOverlayfs itself detects this condition and returns success without doing\nanything, but then vfs_rename() will proceed as if this was a successful\nrename (detach_mounts(), d_move()).\n\nThe correct thing to do is to detect this condition before even calling\ninto overlayfs.  This patch does this by calling vfs_select_inode() to get\nthe underlying inodes.\n\nSigned-off-by: Miklos Szeredi <mszeredi@redhat.com>\nCc: <stable@vger.kernel.org> # v4.2+", "commit_date": "2016-05-11T03:55:43Z", "project": "torvalds/linux", "url": "https://api.github.com/repos/torvalds/linux/commits/9409e22acdfc9153f88d9b1ed2bd2a5b34d2d3ca", "html_url": "https://github.com/torvalds/linux/commit/9409e22acdfc9153f88d9b1ed2bd2a5b34d2d3ca", "windows_before": "", "windows_after": "", "parents": [{"commit_id_before": "54d5ca871e72f2bb172ec9323497f01cd5091ec7", "url_before": "https://api.github.com/repos/torvalds/linux/commits/54d5ca871e72f2bb172ec9323497f01cd5091ec7", "html_url_before": "https://github.com/torvalds/linux/commit/54d5ca871e72f2bb172ec9323497f01cd5091ec7"}], "details": [{"raw_url": "https://github.com/torvalds/linux/raw/9409e22acdfc9153f88d9b1ed2bd2a5b34d2d3ca/fs/namei.c", "patch": "@@ -4213,7 +4213,11 @@ int vfs_rename(struct inode *old_dir, struct dentry *old_dentry,\n \tbool new_is_dir = false;\n \tunsigned max_links = new_dir->i_sb->s_max_links;\n \n-\tif (source == target)\n+\t/*\n+\t * Check source == target.\n+\t * On overlayfs need to look at underlying inodes.\n+\t */\n+\tif (vfs_select_inode(old_dentry, 0) == vfs_select_inode(new_dentry, 0))\n \t\treturn 0;\n \n \terror = may_delete(old_dir, old_dentry, is_dir);", "file_path": "files/2016_8\\99", "file_language": "c", "file_name": "fs/namei.c", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}], "outdated": 0}
{"index": 38, "cve_id": "CVE-2016-5400", "cwe_id": ["CWE-119"], "cve_language": "C", "cve_description": "Memory leak in the airspy_probe function in drivers/media/usb/airspy/airspy.c in the airspy USB driver in the Linux kernel before 4.7 allows local users to cause a denial of service (memory consumption) via a crafted USB device that emulates many VFL_TYPE_SDR or VFL_TYPE_SUBDEV devices and performs many connect and disconnect operations.", "cvss": "4.6", "publish_date": "August 6, 2016", "AV": "PHYSICAL", "AC": "LOW", "PR": "NONE", "UI": "NONE", "S": "UNCHANGED", "C": "NONE", "I": "NONE", "A": "HIGH", "commit_id": "aa93d1fee85c890a34f2510a310e55ee76a27848", "commit_message": "media: fix airspy usb probe error path\n\nFix a memory leak on probe error of the airspy usb device driver.\n\nThe problem is triggered when more than 64 usb devices register with\nv4l2 of type VFL_TYPE_SDR or VFL_TYPE_SUBDEV.\n\nThe memory leak is caused by the probe function of the airspy driver\nmishandeling errors and not freeing the corresponding control structures\nwhen an error occours registering the device to v4l2 core.\n\nA badusb device can emulate 64 of these devices, and then through\ncontinual emulated connect/disconnect of the 65th device, cause the\nkernel to run out of RAM and crash the kernel, thus causing a local DOS\nvulnerability.\n\nFixes CVE-2016-5400\n\nSigned-off-by: James Patrick-Evans <james@jmp-e.com>\nReviewed-by: Kees Cook <keescook@chromium.org>\nCc: stable@vger.kernel.org # 3.17+\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>", "commit_date": "2016-07-15T21:15:40Z", "project": "torvalds/linux", "url": "https://api.github.com/repos/torvalds/linux/commits/aa93d1fee85c890a34f2510a310e55ee76a27848", "html_url": "https://github.com/torvalds/linux/commit/aa93d1fee85c890a34f2510a310e55ee76a27848", "windows_before": "", "windows_after": "", "parents": [{"commit_id_before": "0ba169ac3600ae4032ee14b4192e6bf5d67723f5", "url_before": "https://api.github.com/repos/torvalds/linux/commits/0ba169ac3600ae4032ee14b4192e6bf5d67723f5", "html_url_before": "https://github.com/torvalds/linux/commit/0ba169ac3600ae4032ee14b4192e6bf5d67723f5"}], "details": [{"raw_url": "https://github.com/torvalds/linux/raw/aa93d1fee85c890a34f2510a310e55ee76a27848/drivers/media/usb/airspy/airspy.c", "patch": "@@ -1072,7 +1072,7 @@ static int airspy_probe(struct usb_interface *intf,\n \tif (ret) {\n \t\tdev_err(s->dev, \"Failed to register as video device (%d)\\n\",\n \t\t\t\tret);\n-\t\tgoto err_unregister_v4l2_dev;\n+\t\tgoto err_free_controls;\n \t}\n \tdev_info(s->dev, \"Registered as %s\\n\",\n \t\t\tvideo_device_node_name(&s->vdev));\n@@ -1081,7 +1081,6 @@ static int airspy_probe(struct usb_interface *intf,\n \n err_free_controls:\n \tv4l2_ctrl_handler_free(&s->hdl);\n-err_unregister_v4l2_dev:\n \tv4l2_device_unregister(&s->v4l2_dev);\n err_free_mem:\n \tkfree(s);", "file_path": "files/2016_8\\100", "file_language": "c", "file_name": "drivers/media/usb/airspy/airspy.c", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}], "outdated": 0}
{"index": 39, "cve_id": "CVE-2016-6197", "cwe_id": ["CWE-20"], "cve_language": "C", "cve_description": "fs/overlayfs/dir.c in the OverlayFS filesystem implementation in the Linux kernel before 4.6 does not properly verify the upper dentry before proceeding with unlink and rename system-call processing, which allows local users to cause a denial of service (system crash) via a rename system call that specifies a self-hardlink.", "cvss": "5.5", "publish_date": "August 6, 2016", "AV": "LOCAL", "AC": "LOW", "PR": "LOW", "UI": "NONE", "S": "UNCHANGED", "C": "NONE", "I": "NONE", "A": "HIGH", "commit_id": "11f3710417d026ea2f4fcf362d866342c5274185", "commit_message": "ovl: verify upper dentry before unlink and rename\n\nUnlink and rename in overlayfs checked the upper dentry for staleness by\nverifying upper->d_parent against upperdir.  However the dentry can go\nstale also by being unhashed, for example.\n\nExpand the verification to actually look up the name again (under parent\nlock) and check if it matches the upper dentry.  This matches what the VFS\ndoes before passing the dentry to filesytem's unlink/rename methods, which\nexcludes any inconsistency caused by overlayfs.\n\nSigned-off-by: Miklos Szeredi <mszeredi@redhat.com>", "commit_date": "2016-03-21T16:31:44Z", "project": "torvalds/linux", "url": "https://api.github.com/repos/torvalds/linux/commits/11f3710417d026ea2f4fcf362d866342c5274185", "html_url": "https://github.com/torvalds/linux/commit/11f3710417d026ea2f4fcf362d866342c5274185", "windows_before": "", "windows_after": "", "parents": [{"commit_id_before": "3c2de27d793bf55167804fc47954711e94f27be7", "url_before": "https://api.github.com/repos/torvalds/linux/commits/3c2de27d793bf55167804fc47954711e94f27be7", "html_url_before": "https://github.com/torvalds/linux/commit/3c2de27d793bf55167804fc47954711e94f27be7"}], "details": [{"raw_url": "https://github.com/torvalds/linux/raw/11f3710417d026ea2f4fcf362d866342c5274185/fs/overlayfs/dir.c", "patch": "@@ -596,21 +596,25 @@ static int ovl_remove_upper(struct dentry *dentry, bool is_dir)\n {\n \tstruct dentry *upperdir = ovl_dentry_upper(dentry->d_parent);\n \tstruct inode *dir = upperdir->d_inode;\n-\tstruct dentry *upper = ovl_dentry_upper(dentry);\n+\tstruct dentry *upper;\n \tint err;\n \n \tinode_lock_nested(dir, I_MUTEX_PARENT);\n+\tupper = lookup_one_len(dentry->d_name.name, upperdir,\n+\t\t\t       dentry->d_name.len);\n+\terr = PTR_ERR(upper);\n+\tif (IS_ERR(upper))\n+\t\tgoto out_unlock;\n+\n \terr = -ESTALE;\n-\tif (upper->d_parent == upperdir) {\n-\t\t/* Don't let d_delete() think it can reset d_inode */\n-\t\tdget(upper);\n+\tif (upper == ovl_dentry_upper(dentry)) {\n \t\tif (is_dir)\n \t\t\terr = vfs_rmdir(dir, upper);\n \t\telse\n \t\t\terr = vfs_unlink(dir, upper, NULL);\n-\t\tdput(upper);\n \t\tovl_dentry_version_inc(dentry->d_parent);\n \t}\n+\tdput(upper);\n \n \t/*\n \t * Keeping this dentry hashed would mean having to release\n@@ -620,6 +624,7 @@ static int ovl_remove_upper(struct dentry *dentry, bool is_dir)\n \t */\n \tif (!err)\n \t\td_drop(dentry);\n+out_unlock:\n \tinode_unlock(dir);\n \n \treturn err;\n@@ -840,29 +845,39 @@ static int ovl_rename2(struct inode *olddir, struct dentry *old,\n \n \ttrap = lock_rename(new_upperdir, old_upperdir);\n \n-\tolddentry = ovl_dentry_upper(old);\n-\tnewdentry = ovl_dentry_upper(new);\n-\tif (newdentry) {\n+\n+\tolddentry = lookup_one_len(old->d_name.name, old_upperdir,\n+\t\t\t\t   old->d_name.len);\n+\terr = PTR_ERR(olddentry);\n+\tif (IS_ERR(olddentry))\n+\t\tgoto out_unlock;\n+\n+\terr = -ESTALE;\n+\tif (olddentry != ovl_dentry_upper(old))\n+\t\tgoto out_dput_old;\n+\n+\tnewdentry = lookup_one_len(new->d_name.name, new_upperdir,\n+\t\t\t\t   new->d_name.len);\n+\terr = PTR_ERR(newdentry);\n+\tif (IS_ERR(newdentry))\n+\t\tgoto out_dput_old;\n+\n+\terr = -ESTALE;\n+\tif (ovl_dentry_upper(new)) {\n \t\tif (opaquedir) {\n-\t\t\tnewdentry = opaquedir;\n-\t\t\topaquedir = NULL;\n+\t\t\tif (newdentry != opaquedir)\n+\t\t\t\tgoto out_dput;\n \t\t} else {\n-\t\t\tdget(newdentry);\n+\t\t\tif (newdentry != ovl_dentry_upper(new))\n+\t\t\t\tgoto out_dput;\n \t\t}\n \t} else {\n \t\tnew_create = true;\n-\t\tnewdentry = lookup_one_len(new->d_name.name, new_upperdir,\n-\t\t\t\t\t   new->d_name.len);\n-\t\terr = PTR_ERR(newdentry);\n-\t\tif (IS_ERR(newdentry))\n-\t\t\tgoto out_unlock;\n+\t\tif (!d_is_negative(newdentry) &&\n+\t\t    (!new_opaque || !ovl_is_whiteout(newdentry)))\n+\t\t\tgoto out_dput;\n \t}\n \n-\terr = -ESTALE;\n-\tif (olddentry->d_parent != old_upperdir)\n-\t\tgoto out_dput;\n-\tif (newdentry->d_parent != new_upperdir)\n-\t\tgoto out_dput;\n \tif (olddentry == trap)\n \t\tgoto out_dput;\n \tif (newdentry == trap)\n@@ -925,6 +940,8 @@ static int ovl_rename2(struct inode *olddir, struct dentry *old,\n \n out_dput:\n \tdput(newdentry);\n+out_dput_old:\n+\tdput(olddentry);\n out_unlock:\n \tunlock_rename(new_upperdir, old_upperdir);\n out_revert_creds:", "file_path": "files/2016_8\\101", "file_language": "c", "file_name": "fs/overlayfs/dir.c", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}], "outdated": 0}
{"index": 40, "cve_id": "CVE-2016-5696", "cwe_id": ["CWE-200"], "cve_language": "C", "cve_description": "net/ipv4/tcp_input.c in the Linux kernel before 4.7 does not properly determine the rate of challenge ACK segments, which makes it easier for remote attackers to hijack TCP sessions via a blind in-window attack.", "cvss": "4.8", "publish_date": "August 6, 2016", "AV": "NETWORK", "AC": "HIGH", "PR": "NONE", "UI": "NONE", "S": "UNCHANGED", "C": "NONE", "I": "LOW", "A": "LOW", "commit_id": "75ff39ccc1bd5d3c455b6822ab09e533c551f758", "commit_message": "tcp: make challenge acks less predictable\n\nYue Cao claims that current host rate limiting of challenge ACKS\n(RFC 5961) could leak enough information to allow a patient attacker\nto hijack TCP sessions. He will soon provide details in an academic\npaper.\n\nThis patch increases the default limit from 100 to 1000, and adds\nsome randomization so that the attacker can no longer hijack\nsessions without spending a considerable amount of probes.\n\nBased on initial analysis and patch from Linus.\n\nNote that we also have per socket rate limiting, so it is tempting\nto remove the host limit in the future.\n\nv2: randomize the count of challenge acks per second, not the period.\n\nFixes: 282f23c6ee34 (\"tcp: implement RFC 5961 3.2\")\nReported-by: Yue Cao <ycao009@ucr.edu>\nSigned-off-by: Eric Dumazet <edumazet@google.com>\nSuggested-by: Linus Torvalds <torvalds@linux-foundation.org>\nCc: Yuchung Cheng <ycheng@google.com>\nCc: Neal Cardwell <ncardwell@google.com>\nAcked-by: Neal Cardwell <ncardwell@google.com>\nAcked-by: Yuchung Cheng <ycheng@google.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>", "commit_date": "2016-07-11T20:33:35Z", "project": "torvalds/linux", "url": "https://api.github.com/repos/torvalds/linux/commits/75ff39ccc1bd5d3c455b6822ab09e533c551f758", "html_url": "https://github.com/torvalds/linux/commit/75ff39ccc1bd5d3c455b6822ab09e533c551f758", "windows_before": "", "windows_after": "", "parents": [{"commit_id_before": "a612769774a30e4fc143c4cb6395c12573415660", "url_before": "https://api.github.com/repos/torvalds/linux/commits/a612769774a30e4fc143c4cb6395c12573415660", "html_url_before": "https://github.com/torvalds/linux/commit/a612769774a30e4fc143c4cb6395c12573415660"}], "details": [{"raw_url": "https://github.com/torvalds/linux/raw/75ff39ccc1bd5d3c455b6822ab09e533c551f758/net/ipv4/tcp_input.c", "patch": "@@ -87,7 +87,7 @@ int sysctl_tcp_adv_win_scale __read_mostly = 1;\n EXPORT_SYMBOL(sysctl_tcp_adv_win_scale);\n \n /* rfc5961 challenge ack rate limiting */\n-int sysctl_tcp_challenge_ack_limit = 100;\n+int sysctl_tcp_challenge_ack_limit = 1000;\n \n int sysctl_tcp_stdurg __read_mostly;\n int sysctl_tcp_rfc1337 __read_mostly;\n@@ -3458,21 +3458,26 @@ static void tcp_send_challenge_ack(struct sock *sk, const struct sk_buff *skb)\n \tstatic u32 challenge_timestamp;\n \tstatic unsigned int challenge_count;\n \tstruct tcp_sock *tp = tcp_sk(sk);\n-\tu32 now;\n+\tu32 count, now;\n \n \t/* First check our per-socket dupack rate limit. */\n \tif (tcp_oow_rate_limited(sock_net(sk), skb,\n \t\t\t\t LINUX_MIB_TCPACKSKIPPEDCHALLENGE,\n \t\t\t\t &tp->last_oow_ack_time))\n \t\treturn;\n \n-\t/* Then check the check host-wide RFC 5961 rate limit. */\n+\t/* Then check host-wide RFC 5961 rate limit. */\n \tnow = jiffies / HZ;\n \tif (now != challenge_timestamp) {\n+\t\tu32 half = (sysctl_tcp_challenge_ack_limit + 1) >> 1;\n+\n \t\tchallenge_timestamp = now;\n-\t\tchallenge_count = 0;\n+\t\tWRITE_ONCE(challenge_count, half +\n+\t\t\t   prandom_u32_max(sysctl_tcp_challenge_ack_limit));\n \t}\n-\tif (++challenge_count <= sysctl_tcp_challenge_ack_limit) {\n+\tcount = READ_ONCE(challenge_count);\n+\tif (count > 0) {\n+\t\tWRITE_ONCE(challenge_count, count - 1);\n \t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPCHALLENGEACK);\n \t\ttcp_send_ack(sk);\n \t}", "file_path": "files/2016_8\\102", "file_language": "c", "file_name": "net/ipv4/tcp_input.c", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}], "outdated": 0}
{"index": 41, "cve_id": "CVE-2016-5412", "cwe_id": ["CWE-399"], "cve_language": "C", "cve_description": "arch/powerpc/kvm/book3s_hv_rmhandlers.S in the Linux kernel through 4.7 on PowerPC platforms, when CONFIG_KVM_BOOK3S_64_HV is enabled, allows guest OS users to cause a denial of service (host OS infinite loop) by making a H_CEDE hypercall during the existence of a suspended transaction.", "cvss": "6.5", "publish_date": "August 6, 2016", "AV": "LOCAL", "AC": "LOW", "PR": "LOW", "UI": "NONE", "S": "CHANGED", "C": "NONE", "I": "NONE", "A": "HIGH", "commit_id": "f024ee098476a3e620232e4a78cfac505f121245", "commit_message": "KVM: PPC: Book3S HV: Pull out TM state save/restore into separate procedures\n\nThis moves the transactional memory state save and restore sequences\nout of the guest entry/exit paths into separate procedures.  This is\nso that these sequences can be used in going into and out of nap\nin a subsequent patch.\n\nThe only code changes here are (a) saving and restore LR on the\nstack, since these new procedures get called with a bl instruction,\n(b) explicitly saving r1 into the PACA instead of assuming that\nHSTATE_HOST_R1(r13) is already set, and (c) removing an unnecessary\nand redundant setting of MSR[TM] that should have been removed by\ncommit 9d4d0bdd9e0a (\"KVM: PPC: Book3S HV: Add transactional memory\nsupport\", 2013-09-24) but wasn't.\n\nCc: stable@vger.kernel.org # v3.15+\nSigned-off-by: Paul Mackerras <paulus@ozlabs.org>", "commit_date": "2016-07-28T06:09:34Z", "project": "torvalds/linux", "url": "https://api.github.com/repos/torvalds/linux/commits/f024ee098476a3e620232e4a78cfac505f121245", "html_url": "https://github.com/torvalds/linux/commit/f024ee098476a3e620232e4a78cfac505f121245", "windows_before": "", "windows_after": "", "parents": [{"commit_id_before": "912902ce78b0d48f717f9128e61fb9bffbd65f86", "url_before": "https://api.github.com/repos/torvalds/linux/commits/912902ce78b0d48f717f9128e61fb9bffbd65f86", "html_url_before": "https://github.com/torvalds/linux/commit/912902ce78b0d48f717f9128e61fb9bffbd65f86"}], "details": [{"raw_url": "https://github.com/torvalds/linux/raw/f024ee098476a3e620232e4a78cfac505f121245/arch/powerpc/kvm/book3s_hv_rmhandlers.S", "patch": "@@ -689,112 +689,8 @@ END_FTR_SECTION_IFCLR(CPU_FTR_ARCH_207S)\n \n #ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n BEGIN_FTR_SECTION\n-\tb\tskip_tm\n-END_FTR_SECTION_IFCLR(CPU_FTR_TM)\n-\n-\t/* Turn on TM/FP/VSX/VMX so we can restore them. */\n-\tmfmsr\tr5\n-\tli\tr6, MSR_TM >> 32\n-\tsldi\tr6, r6, 32\n-\tor\tr5, r5, r6\n-\tori\tr5, r5, MSR_FP\n-\toris\tr5, r5, (MSR_VEC | MSR_VSX)@h\n-\tmtmsrd\tr5\n-\n-\t/*\n-\t * The user may change these outside of a transaction, so they must\n-\t * always be context switched.\n-\t */\n-\tld\tr5, VCPU_TFHAR(r4)\n-\tld\tr6, VCPU_TFIAR(r4)\n-\tld\tr7, VCPU_TEXASR(r4)\n-\tmtspr\tSPRN_TFHAR, r5\n-\tmtspr\tSPRN_TFIAR, r6\n-\tmtspr\tSPRN_TEXASR, r7\n-\n-\tld\tr5, VCPU_MSR(r4)\n-\trldicl. r5, r5, 64 - MSR_TS_S_LG, 62\n-\tbeq\tskip_tm\t/* TM not active in guest */\n-\n-\t/* Make sure the failure summary is set, otherwise we'll program check\n-\t * when we trechkpt.  It's possible that this might have been not set\n-\t * on a kvmppc_set_one_reg() call but we shouldn't let this crash the\n-\t * host.\n-\t */\n-\toris\tr7, r7, (TEXASR_FS)@h\n-\tmtspr\tSPRN_TEXASR, r7\n-\n-\t/*\n-\t * We need to load up the checkpointed state for the guest.\n-\t * We need to do this early as it will blow away any GPRs, VSRs and\n-\t * some SPRs.\n-\t */\n-\n-\tmr\tr31, r4\n-\taddi\tr3, r31, VCPU_FPRS_TM\n-\tbl\tload_fp_state\n-\taddi\tr3, r31, VCPU_VRS_TM\n-\tbl\tload_vr_state\n-\tmr\tr4, r31\n-\tlwz\tr7, VCPU_VRSAVE_TM(r4)\n-\tmtspr\tSPRN_VRSAVE, r7\n-\n-\tld\tr5, VCPU_LR_TM(r4)\n-\tlwz\tr6, VCPU_CR_TM(r4)\n-\tld\tr7, VCPU_CTR_TM(r4)\n-\tld\tr8, VCPU_AMR_TM(r4)\n-\tld\tr9, VCPU_TAR_TM(r4)\n-\tmtlr\tr5\n-\tmtcr\tr6\n-\tmtctr\tr7\n-\tmtspr\tSPRN_AMR, r8\n-\tmtspr\tSPRN_TAR, r9\n-\n-\t/*\n-\t * Load up PPR and DSCR values but don't put them in the actual SPRs\n-\t * till the last moment to avoid running with userspace PPR and DSCR for\n-\t * too long.\n-\t */\n-\tld\tr29, VCPU_DSCR_TM(r4)\n-\tld\tr30, VCPU_PPR_TM(r4)\n-\n-\tstd\tr2, PACATMSCRATCH(r13) /* Save TOC */\n-\n-\t/* Clear the MSR RI since r1, r13 are all going to be foobar. */\n-\tli\tr5, 0\n-\tmtmsrd\tr5, 1\n-\n-\t/* Load GPRs r0-r28 */\n-\treg = 0\n-\t.rept\t29\n-\tld\treg, VCPU_GPRS_TM(reg)(r31)\n-\treg = reg + 1\n-\t.endr\n-\n-\tmtspr\tSPRN_DSCR, r29\n-\tmtspr\tSPRN_PPR, r30\n-\n-\t/* Load final GPRs */\n-\tld\t29, VCPU_GPRS_TM(29)(r31)\n-\tld\t30, VCPU_GPRS_TM(30)(r31)\n-\tld\t31, VCPU_GPRS_TM(31)(r31)\n-\n-\t/* TM checkpointed state is now setup.  All GPRs are now volatile. */\n-\tTRECHKPT\n-\n-\t/* Now let's get back the state we need. */\n-\tHMT_MEDIUM\n-\tGET_PACA(r13)\n-\tld\tr29, HSTATE_DSCR(r13)\n-\tmtspr\tSPRN_DSCR, r29\n-\tld\tr4, HSTATE_KVM_VCPU(r13)\n-\tld\tr1, HSTATE_HOST_R1(r13)\n-\tld\tr2, PACATMSCRATCH(r13)\n-\n-\t/* Set the MSR RI since we have our registers back. */\n-\tli\tr5, MSR_RI\n-\tmtmsrd\tr5, 1\n-skip_tm:\n+\tbl\tkvmppc_restore_tm\n+END_FTR_SECTION_IFSET(CPU_FTR_TM)\n #endif\n \n \t/* Load guest PMU registers */\n@@ -875,12 +771,6 @@ BEGIN_FTR_SECTION\n \t/* Skip next section on POWER7 */\n \tb\t8f\n END_FTR_SECTION_IFCLR(CPU_FTR_ARCH_207S)\n-\t/* Turn on TM so we can access TFHAR/TFIAR/TEXASR */\n-\tmfmsr\tr8\n-\tli\tr0, 1\n-\trldimi\tr8, r0, MSR_TM_LG, 63-MSR_TM_LG\n-\tmtmsrd\tr8\n-\n \t/* Load up POWER8-specific registers */\n \tld\tr5, VCPU_IAMR(r4)\n \tlwz\tr6, VCPU_PSPB(r4)\n@@ -1470,106 +1360,8 @@ END_FTR_SECTION_IFCLR(CPU_FTR_ARCH_207S)\n \n #ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n BEGIN_FTR_SECTION\n-\tb\t2f\n-END_FTR_SECTION_IFCLR(CPU_FTR_TM)\n-\t/* Turn on TM. */\n-\tmfmsr\tr8\n-\tli\tr0, 1\n-\trldimi\tr8, r0, MSR_TM_LG, 63-MSR_TM_LG\n-\tmtmsrd\tr8\n-\n-\tld\tr5, VCPU_MSR(r9)\n-\trldicl. r5, r5, 64 - MSR_TS_S_LG, 62\n-\tbeq\t1f\t/* TM not active in guest. */\n-\n-\tli\tr3, TM_CAUSE_KVM_RESCHED\n-\n-\t/* Clear the MSR RI since r1, r13 are all going to be foobar. */\n-\tli\tr5, 0\n-\tmtmsrd\tr5, 1\n-\n-\t/* All GPRs are volatile at this point. */\n-\tTRECLAIM(R3)\n-\n-\t/* Temporarily store r13 and r9 so we have some regs to play with */\n-\tSET_SCRATCH0(r13)\n-\tGET_PACA(r13)\n-\tstd\tr9, PACATMSCRATCH(r13)\n-\tld\tr9, HSTATE_KVM_VCPU(r13)\n-\n-\t/* Get a few more GPRs free. */\n-\tstd\tr29, VCPU_GPRS_TM(29)(r9)\n-\tstd\tr30, VCPU_GPRS_TM(30)(r9)\n-\tstd\tr31, VCPU_GPRS_TM(31)(r9)\n-\n-\t/* Save away PPR and DSCR soon so don't run with user values. */\n-\tmfspr\tr31, SPRN_PPR\n-\tHMT_MEDIUM\n-\tmfspr\tr30, SPRN_DSCR\n-\tld\tr29, HSTATE_DSCR(r13)\n-\tmtspr\tSPRN_DSCR, r29\n-\n-\t/* Save all but r9, r13 & r29-r31 */\n-\treg = 0\n-\t.rept\t29\n-\t.if (reg != 9) && (reg != 13)\n-\tstd\treg, VCPU_GPRS_TM(reg)(r9)\n-\t.endif\n-\treg = reg + 1\n-\t.endr\n-\t/* ... now save r13 */\n-\tGET_SCRATCH0(r4)\n-\tstd\tr4, VCPU_GPRS_TM(13)(r9)\n-\t/* ... and save r9 */\n-\tld\tr4, PACATMSCRATCH(r13)\n-\tstd\tr4, VCPU_GPRS_TM(9)(r9)\n-\n-\t/* Reload stack pointer and TOC. */\n-\tld\tr1, HSTATE_HOST_R1(r13)\n-\tld\tr2, PACATOC(r13)\n-\n-\t/* Set MSR RI now we have r1 and r13 back. */\n-\tli\tr5, MSR_RI\n-\tmtmsrd\tr5, 1\n-\n-\t/* Save away checkpinted SPRs. */\n-\tstd\tr31, VCPU_PPR_TM(r9)\n-\tstd\tr30, VCPU_DSCR_TM(r9)\n-\tmflr\tr5\n-\tmfcr\tr6\n-\tmfctr\tr7\n-\tmfspr\tr8, SPRN_AMR\n-\tmfspr\tr10, SPRN_TAR\n-\tstd\tr5, VCPU_LR_TM(r9)\n-\tstw\tr6, VCPU_CR_TM(r9)\n-\tstd\tr7, VCPU_CTR_TM(r9)\n-\tstd\tr8, VCPU_AMR_TM(r9)\n-\tstd\tr10, VCPU_TAR_TM(r9)\n-\n-\t/* Restore r12 as trap number. */\n-\tlwz\tr12, VCPU_TRAP(r9)\n-\n-\t/* Save FP/VSX. */\n-\taddi\tr3, r9, VCPU_FPRS_TM\n-\tbl\tstore_fp_state\n-\taddi\tr3, r9, VCPU_VRS_TM\n-\tbl\tstore_vr_state\n-\tmfspr\tr6, SPRN_VRSAVE\n-\tstw\tr6, VCPU_VRSAVE_TM(r9)\n-1:\n-\t/*\n-\t * We need to save these SPRs after the treclaim so that the software\n-\t * error code is recorded correctly in the TEXASR.  Also the user may\n-\t * change these outside of a transaction, so they must always be\n-\t * context switched.\n-\t */\n-\tmfspr\tr5, SPRN_TFHAR\n-\tmfspr\tr6, SPRN_TFIAR\n-\tmfspr\tr7, SPRN_TEXASR\n-\tstd\tr5, VCPU_TFHAR(r9)\n-\tstd\tr6, VCPU_TFIAR(r9)\n-\tstd\tr7, VCPU_TEXASR(r9)\n-2:\n+\tbl\tkvmppc_save_tm\n+END_FTR_SECTION_IFSET(CPU_FTR_TM)\n #endif\n \n \t/* Increment yield count if they have a VPA */\n@@ -2694,6 +2486,239 @@ END_FTR_SECTION_IFSET(CPU_FTR_ALTIVEC)\n \tmr\tr4,r31\n \tblr\n \n+#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n+/*\n+ * Save transactional state and TM-related registers.\n+ * Called with r9 pointing to the vcpu struct.\n+ * This can modify all checkpointed registers, but\n+ * restores r1, r2 and r9 (vcpu pointer) before exit.\n+ */\n+kvmppc_save_tm:\n+\tmflr\tr0\n+\tstd\tr0, PPC_LR_STKOFF(r1)\n+\n+\t/* Turn on TM. */\n+\tmfmsr\tr8\n+\tli\tr0, 1\n+\trldimi\tr8, r0, MSR_TM_LG, 63-MSR_TM_LG\n+\tmtmsrd\tr8\n+\n+\tld\tr5, VCPU_MSR(r9)\n+\trldicl. r5, r5, 64 - MSR_TS_S_LG, 62\n+\tbeq\t1f\t/* TM not active in guest. */\n+\n+\tstd\tr1, HSTATE_HOST_R1(r13)\n+\tli\tr3, TM_CAUSE_KVM_RESCHED\n+\n+\t/* Clear the MSR RI since r1, r13 are all going to be foobar. */\n+\tli\tr5, 0\n+\tmtmsrd\tr5, 1\n+\n+\t/* All GPRs are volatile at this point. */\n+\tTRECLAIM(R3)\n+\n+\t/* Temporarily store r13 and r9 so we have some regs to play with */\n+\tSET_SCRATCH0(r13)\n+\tGET_PACA(r13)\n+\tstd\tr9, PACATMSCRATCH(r13)\n+\tld\tr9, HSTATE_KVM_VCPU(r13)\n+\n+\t/* Get a few more GPRs free. */\n+\tstd\tr29, VCPU_GPRS_TM(29)(r9)\n+\tstd\tr30, VCPU_GPRS_TM(30)(r9)\n+\tstd\tr31, VCPU_GPRS_TM(31)(r9)\n+\n+\t/* Save away PPR and DSCR soon so don't run with user values. */\n+\tmfspr\tr31, SPRN_PPR\n+\tHMT_MEDIUM\n+\tmfspr\tr30, SPRN_DSCR\n+\tld\tr29, HSTATE_DSCR(r13)\n+\tmtspr\tSPRN_DSCR, r29\n+\n+\t/* Save all but r9, r13 & r29-r31 */\n+\treg = 0\n+\t.rept\t29\n+\t.if (reg != 9) && (reg != 13)\n+\tstd\treg, VCPU_GPRS_TM(reg)(r9)\n+\t.endif\n+\treg = reg + 1\n+\t.endr\n+\t/* ... now save r13 */\n+\tGET_SCRATCH0(r4)\n+\tstd\tr4, VCPU_GPRS_TM(13)(r9)\n+\t/* ... and save r9 */\n+\tld\tr4, PACATMSCRATCH(r13)\n+\tstd\tr4, VCPU_GPRS_TM(9)(r9)\n+\n+\t/* Reload stack pointer and TOC. */\n+\tld\tr1, HSTATE_HOST_R1(r13)\n+\tld\tr2, PACATOC(r13)\n+\n+\t/* Set MSR RI now we have r1 and r13 back. */\n+\tli\tr5, MSR_RI\n+\tmtmsrd\tr5, 1\n+\n+\t/* Save away checkpinted SPRs. */\n+\tstd\tr31, VCPU_PPR_TM(r9)\n+\tstd\tr30, VCPU_DSCR_TM(r9)\n+\tmflr\tr5\n+\tmfcr\tr6\n+\tmfctr\tr7\n+\tmfspr\tr8, SPRN_AMR\n+\tmfspr\tr10, SPRN_TAR\n+\tstd\tr5, VCPU_LR_TM(r9)\n+\tstw\tr6, VCPU_CR_TM(r9)\n+\tstd\tr7, VCPU_CTR_TM(r9)\n+\tstd\tr8, VCPU_AMR_TM(r9)\n+\tstd\tr10, VCPU_TAR_TM(r9)\n+\n+\t/* Restore r12 as trap number. */\n+\tlwz\tr12, VCPU_TRAP(r9)\n+\n+\t/* Save FP/VSX. */\n+\taddi\tr3, r9, VCPU_FPRS_TM\n+\tbl\tstore_fp_state\n+\taddi\tr3, r9, VCPU_VRS_TM\n+\tbl\tstore_vr_state\n+\tmfspr\tr6, SPRN_VRSAVE\n+\tstw\tr6, VCPU_VRSAVE_TM(r9)\n+1:\n+\t/*\n+\t * We need to save these SPRs after the treclaim so that the software\n+\t * error code is recorded correctly in the TEXASR.  Also the user may\n+\t * change these outside of a transaction, so they must always be\n+\t * context switched.\n+\t */\n+\tmfspr\tr5, SPRN_TFHAR\n+\tmfspr\tr6, SPRN_TFIAR\n+\tmfspr\tr7, SPRN_TEXASR\n+\tstd\tr5, VCPU_TFHAR(r9)\n+\tstd\tr6, VCPU_TFIAR(r9)\n+\tstd\tr7, VCPU_TEXASR(r9)\n+\n+\tld\tr0, PPC_LR_STKOFF(r1)\n+\tmtlr\tr0\n+\tblr\n+\n+/*\n+ * Restore transactional state and TM-related registers.\n+ * Called with r4 pointing to the vcpu struct.\n+ * This potentially modifies all checkpointed registers.\n+ * It restores r1, r2, r4 from the PACA.\n+ */\n+kvmppc_restore_tm:\n+\tmflr\tr0\n+\tstd\tr0, PPC_LR_STKOFF(r1)\n+\n+\t/* Turn on TM/FP/VSX/VMX so we can restore them. */\n+\tmfmsr\tr5\n+\tli\tr6, MSR_TM >> 32\n+\tsldi\tr6, r6, 32\n+\tor\tr5, r5, r6\n+\tori\tr5, r5, MSR_FP\n+\toris\tr5, r5, (MSR_VEC | MSR_VSX)@h\n+\tmtmsrd\tr5\n+\n+\t/*\n+\t * The user may change these outside of a transaction, so they must\n+\t * always be context switched.\n+\t */\n+\tld\tr5, VCPU_TFHAR(r4)\n+\tld\tr6, VCPU_TFIAR(r4)\n+\tld\tr7, VCPU_TEXASR(r4)\n+\tmtspr\tSPRN_TFHAR, r5\n+\tmtspr\tSPRN_TFIAR, r6\n+\tmtspr\tSPRN_TEXASR, r7\n+\n+\tld\tr5, VCPU_MSR(r4)\n+\trldicl. r5, r5, 64 - MSR_TS_S_LG, 62\n+\tbeqlr\t\t/* TM not active in guest */\n+\tstd\tr1, HSTATE_HOST_R1(r13)\n+\n+\t/* Make sure the failure summary is set, otherwise we'll program check\n+\t * when we trechkpt.  It's possible that this might have been not set\n+\t * on a kvmppc_set_one_reg() call but we shouldn't let this crash the\n+\t * host.\n+\t */\n+\toris\tr7, r7, (TEXASR_FS)@h\n+\tmtspr\tSPRN_TEXASR, r7\n+\n+\t/*\n+\t * We need to load up the checkpointed state for the guest.\n+\t * We need to do this early as it will blow away any GPRs, VSRs and\n+\t * some SPRs.\n+\t */\n+\n+\tmr\tr31, r4\n+\taddi\tr3, r31, VCPU_FPRS_TM\n+\tbl\tload_fp_state\n+\taddi\tr3, r31, VCPU_VRS_TM\n+\tbl\tload_vr_state\n+\tmr\tr4, r31\n+\tlwz\tr7, VCPU_VRSAVE_TM(r4)\n+\tmtspr\tSPRN_VRSAVE, r7\n+\n+\tld\tr5, VCPU_LR_TM(r4)\n+\tlwz\tr6, VCPU_CR_TM(r4)\n+\tld\tr7, VCPU_CTR_TM(r4)\n+\tld\tr8, VCPU_AMR_TM(r4)\n+\tld\tr9, VCPU_TAR_TM(r4)\n+\tmtlr\tr5\n+\tmtcr\tr6\n+\tmtctr\tr7\n+\tmtspr\tSPRN_AMR, r8\n+\tmtspr\tSPRN_TAR, r9\n+\n+\t/*\n+\t * Load up PPR and DSCR values but don't put them in the actual SPRs\n+\t * till the last moment to avoid running with userspace PPR and DSCR for\n+\t * too long.\n+\t */\n+\tld\tr29, VCPU_DSCR_TM(r4)\n+\tld\tr30, VCPU_PPR_TM(r4)\n+\n+\tstd\tr2, PACATMSCRATCH(r13) /* Save TOC */\n+\n+\t/* Clear the MSR RI since r1, r13 are all going to be foobar. */\n+\tli\tr5, 0\n+\tmtmsrd\tr5, 1\n+\n+\t/* Load GPRs r0-r28 */\n+\treg = 0\n+\t.rept\t29\n+\tld\treg, VCPU_GPRS_TM(reg)(r31)\n+\treg = reg + 1\n+\t.endr\n+\n+\tmtspr\tSPRN_DSCR, r29\n+\tmtspr\tSPRN_PPR, r30\n+\n+\t/* Load final GPRs */\n+\tld\t29, VCPU_GPRS_TM(29)(r31)\n+\tld\t30, VCPU_GPRS_TM(30)(r31)\n+\tld\t31, VCPU_GPRS_TM(31)(r31)\n+\n+\t/* TM checkpointed state is now setup.  All GPRs are now volatile. */\n+\tTRECHKPT\n+\n+\t/* Now let's get back the state we need. */\n+\tHMT_MEDIUM\n+\tGET_PACA(r13)\n+\tld\tr29, HSTATE_DSCR(r13)\n+\tmtspr\tSPRN_DSCR, r29\n+\tld\tr4, HSTATE_KVM_VCPU(r13)\n+\tld\tr1, HSTATE_HOST_R1(r13)\n+\tld\tr2, PACATMSCRATCH(r13)\n+\n+\t/* Set the MSR RI since we have our registers back. */\n+\tli\tr5, MSR_RI\n+\tmtmsrd\tr5, 1\n+\n+\tld\tr0, PPC_LR_STKOFF(r1)\n+\tmtlr\tr0\n+\tblr\n+#endif\n+\n /*\n  * We come here if we get any exception or interrupt while we are\n  * executing host real mode code while in guest MMU context.", "file_path": "files/2016_8\\103", "file_language": "S", "file_name": "arch/powerpc/kvm/book3s_hv_rmhandlers.S", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}], "outdated": 0}
{"index": 42, "cve_id": "CVE-2016-5412", "cwe_id": ["CWE-399"], "cve_language": "C", "cve_description": "arch/powerpc/kvm/book3s_hv_rmhandlers.S in the Linux kernel through 4.7 on PowerPC platforms, when CONFIG_KVM_BOOK3S_64_HV is enabled, allows guest OS users to cause a denial of service (host OS infinite loop) by making a H_CEDE hypercall during the existence of a suspended transaction.", "cvss": "6.5", "publish_date": "August 6, 2016", "AV": "LOCAL", "AC": "LOW", "PR": "LOW", "UI": "NONE", "S": "CHANGED", "C": "NONE", "I": "NONE", "A": "HIGH", "commit_id": "93d17397e4e2182fdaad503e2f9da46202c0f1c3", "commit_message": "KVM: PPC: Book3S HV: Save/restore TM state in H_CEDE\n\nIt turns out that if the guest does a H_CEDE while the CPU is in\na transactional state, and the H_CEDE does a nap, and the nap\nloses the architected state of the CPU (which is is allowed to do),\nthen we lose the checkpointed state of the virtual CPU.  In addition,\nthe transactional-memory state recorded in the MSR gets reset back\nto non-transactional, and when we try to return to the guest, we take\na TM bad thing type of program interrupt because we are trying to\ntransition from non-transactional to transactional with a hrfid\ninstruction, which is not permitted.\n\nThe result of the program interrupt occurring at that point is that\nthe host CPU will hang in an infinite loop with interrupts disabled.\nThus this is a denial of service vulnerability in the host which can\nbe triggered by any guest (and depending on the guest kernel, it can\npotentially triggered by unprivileged userspace in the guest).\n\nThis vulnerability has been assigned the ID CVE-2016-5412.\n\nTo fix this, we save the TM state before napping and restore it\non exit from the nap, when handling a H_CEDE in real mode.  The\ncase where H_CEDE exits to host virtual mode is already OK (as are\nother hcalls which exit to host virtual mode) because the exit\npath saves the TM state.\n\nCc: stable@vger.kernel.org # v3.15+\nSigned-off-by: Paul Mackerras <paulus@ozlabs.org>", "commit_date": "2016-07-28T06:10:07Z", "project": "torvalds/linux", "url": "https://api.github.com/repos/torvalds/linux/commits/93d17397e4e2182fdaad503e2f9da46202c0f1c3", "html_url": "https://github.com/torvalds/linux/commit/93d17397e4e2182fdaad503e2f9da46202c0f1c3", "windows_before": "", "windows_after": "", "parents": [{"commit_id_before": "f024ee098476a3e620232e4a78cfac505f121245", "url_before": "https://api.github.com/repos/torvalds/linux/commits/f024ee098476a3e620232e4a78cfac505f121245", "html_url_before": "https://github.com/torvalds/linux/commit/f024ee098476a3e620232e4a78cfac505f121245"}], "details": [{"raw_url": "https://github.com/torvalds/linux/raw/93d17397e4e2182fdaad503e2f9da46202c0f1c3/arch/powerpc/kvm/book3s_hv_rmhandlers.S", "patch": "@@ -2093,6 +2093,13 @@ _GLOBAL(kvmppc_h_cede)\t\t/* r3 = vcpu pointer, r11 = msr, r13 = paca */\n \t/* save FP state */\n \tbl\tkvmppc_save_fp\n \n+#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n+BEGIN_FTR_SECTION\n+\tld\tr9, HSTATE_KVM_VCPU(r13)\n+\tbl\tkvmppc_save_tm\n+END_FTR_SECTION_IFSET(CPU_FTR_TM)\n+#endif\n+\n \t/*\n \t * Set DEC to the smaller of DEC and HDEC, so that we wake\n \t * no later than the end of our timeslice (HDEC interrupts\n@@ -2169,6 +2176,12 @@ kvm_end_cede:\n \tbl\tkvmhv_accumulate_time\n #endif\n \n+#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n+BEGIN_FTR_SECTION\n+\tbl\tkvmppc_restore_tm\n+END_FTR_SECTION_IFSET(CPU_FTR_TM)\n+#endif\n+\n \t/* load up FP state */\n \tbl\tkvmppc_load_fp\n ", "file_path": "files/2016_8\\104", "file_language": "S", "file_name": "arch/powerpc/kvm/book3s_hv_rmhandlers.S", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}], "outdated": 0}
{"index": 43, "cve_id": "CVE-2016-6516", "cwe_id": ["CWE-119", "CWE-362"], "cve_language": "C", "cve_description": "Race condition in the ioctl_file_dedupe_range function in fs/ioctl.c in the Linux kernel through 4.7 allows local users to cause a denial of service (heap-based buffer overflow) or possibly gain privileges by changing a certain count value, aka a \"double fetch\" vulnerability.", "cvss": "7.4", "publish_date": "August 6, 2016", "AV": "LOCAL", "AC": "HIGH", "PR": "NONE", "UI": "NONE", "S": "UNCHANGED", "C": "HIGH", "I": "HIGH", "A": "HIGH", "commit_id": "10eec60ce79187686e052092e5383c99b4420a20", "commit_message": "vfs: ioctl: prevent double-fetch in dedupe ioctl\n\nThis prevents a double-fetch from user space that can lead to to an\nundersized allocation and heap overflow.\n\nFixes: 54dbc1517237 (\"vfs: hoist the btrfs deduplication ioctl to the vfs\")\nSigned-off-by: Scott Bauer <sbauer@plzdonthack.me>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>", "commit_date": "2016-07-28T22:23:12Z", "project": "torvalds/linux", "url": "https://api.github.com/repos/torvalds/linux/commits/10eec60ce79187686e052092e5383c99b4420a20", "html_url": "https://github.com/torvalds/linux/commit/10eec60ce79187686e052092e5383c99b4420a20", "windows_before": "", "windows_after": "", "parents": [{"commit_id_before": "884316deb4c9fdf9becfa31831a9e40717e3026c", "url_before": "https://api.github.com/repos/torvalds/linux/commits/884316deb4c9fdf9becfa31831a9e40717e3026c", "html_url_before": "https://github.com/torvalds/linux/commit/884316deb4c9fdf9becfa31831a9e40717e3026c"}], "details": [{"raw_url": "https://github.com/torvalds/linux/raw/10eec60ce79187686e052092e5383c99b4420a20/fs/ioctl.c", "patch": "@@ -590,6 +590,7 @@ static long ioctl_file_dedupe_range(struct file *file, void __user *arg)\n \t\tgoto out;\n \t}\n \n+\tsame->dest_count = count;\n \tret = vfs_dedupe_file_range(file, same);\n \tif (ret)\n \t\tgoto out;", "file_path": "files/2016_8\\105", "file_language": "c", "file_name": "fs/ioctl.c", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}], "outdated": 0}
{"index": 44, "cve_id": "CVE-2016-3070", "cwe_id": ["CWE-476"], "cve_language": "C", "cve_description": "The trace_writeback_dirty_page implementation in include/trace/events/writeback.h in the Linux kernel before 4.4 improperly interacts with mm/migrate.c, which allows local users to cause a denial of service (NULL pointer dereference and system crash) or possibly have unspecified other impact by triggering a certain page move.", "cvss": "7.8", "publish_date": "August 6, 2016", "AV": "LOCAL", "AC": "LOW", "PR": "LOW", "UI": "NONE", "S": "UNCHANGED", "C": "HIGH", "I": "HIGH", "A": "HIGH", "commit_id": "42cb14b110a5698ccf26ce59c4441722605a3743", "commit_message": "mm: migrate dirty page without clear_page_dirty_for_io etc\n\nclear_page_dirty_for_io() has accumulated writeback and memcg subtleties\nsince v2.6.16 first introduced page migration; and the set_page_dirty()\nwhich completed its migration of PageDirty, later had to be moderated to\n__set_page_dirty_nobuffers(); then PageSwapBacked had to skip that too.\n\nNo actual problems seen with this procedure recently, but if you look into\nwhat the clear_page_dirty_for_io(page)+set_page_dirty(newpage) is actually\nachieving, it turns out to be nothing more than moving the PageDirty flag,\nand its NR_FILE_DIRTY stat from one zone to another.\n\nIt would be good to avoid a pile of irrelevant decrementations and\nincrementations, and improper event counting, and unnecessary descent of\nthe radix_tree under tree_lock (to set the PAGECACHE_TAG_DIRTY which\nradix_tree_replace_slot() left in place anyway).\n\nDo the NR_FILE_DIRTY movement, like the other stats movements, while\ninterrupts still disabled in migrate_page_move_mapping(); and don't even\nbother if the zone is the same.  Do the PageDirty movement there under\ntree_lock too, where old page is frozen and newpage not yet visible:\nbearing in mind that as soon as newpage becomes visible in radix_tree, an\nun-page-locked set_page_dirty() might interfere (or perhaps that's just\nnot possible: anything doing so should already hold an additional\nreference to the old page, preventing its migration; but play safe).\n\nBut we do still need to transfer PageDirty in migrate_page_copy(), for\nthose who don't go the mapping route through migrate_page_move_mapping().\n\nSigned-off-by: Hugh Dickins <hughd@google.com>\nCc: Christoph Lameter <cl@linux.com>\nCc: \"Kirill A. Shutemov\" <kirill.shutemov@linux.intel.com>\nCc: Rik van Riel <riel@redhat.com>\nCc: Vlastimil Babka <vbabka@suse.cz>\nCc: Davidlohr Bueso <dave@stgolabs.net>\nCc: Oleg Nesterov <oleg@redhat.com>\nCc: Sasha Levin <sasha.levin@oracle.com>\nCc: Dmitry Vyukov <dvyukov@google.com>\nCc: KOSAKI Motohiro <kosaki.motohiro@jp.fujitsu.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>", "commit_date": "2015-11-06T03:34:48Z", "project": "torvalds/linux", "url": "https://api.github.com/repos/torvalds/linux/commits/42cb14b110a5698ccf26ce59c4441722605a3743", "html_url": "https://github.com/torvalds/linux/commit/42cb14b110a5698ccf26ce59c4441722605a3743", "windows_before": "", "windows_after": "", "parents": [{"commit_id_before": "cf4b769abb8aef01f887543cb8308c0d8671367c", "url_before": "https://api.github.com/repos/torvalds/linux/commits/cf4b769abb8aef01f887543cb8308c0d8671367c", "html_url_before": "https://github.com/torvalds/linux/commit/cf4b769abb8aef01f887543cb8308c0d8671367c"}], "details": [{"raw_url": "https://github.com/torvalds/linux/raw/42cb14b110a5698ccf26ce59c4441722605a3743/mm/migrate.c", "patch": "@@ -30,6 +30,7 @@\n #include <linux/mempolicy.h>\n #include <linux/vmalloc.h>\n #include <linux/security.h>\n+#include <linux/backing-dev.h>\n #include <linux/syscalls.h>\n #include <linux/hugetlb.h>\n #include <linux/hugetlb_cgroup.h>\n@@ -313,6 +314,8 @@ int migrate_page_move_mapping(struct address_space *mapping,\n \t\tstruct buffer_head *head, enum migrate_mode mode,\n \t\tint extra_count)\n {\n+\tstruct zone *oldzone, *newzone;\n+\tint dirty;\n \tint expected_count = 1 + extra_count;\n \tvoid **pslot;\n \n@@ -331,6 +334,9 @@ int migrate_page_move_mapping(struct address_space *mapping,\n \t\treturn MIGRATEPAGE_SUCCESS;\n \t}\n \n+\toldzone = page_zone(page);\n+\tnewzone = page_zone(newpage);\n+\n \tspin_lock_irq(&mapping->tree_lock);\n \n \tpslot = radix_tree_lookup_slot(&mapping->page_tree,\n@@ -378,6 +384,13 @@ int migrate_page_move_mapping(struct address_space *mapping,\n \t\tset_page_private(newpage, page_private(page));\n \t}\n \n+\t/* Move dirty while page refs frozen and newpage not yet exposed */\n+\tdirty = PageDirty(page);\n+\tif (dirty) {\n+\t\tClearPageDirty(page);\n+\t\tSetPageDirty(newpage);\n+\t}\n+\n \tradix_tree_replace_slot(pslot, newpage);\n \n \t/*\n@@ -387,6 +400,9 @@ int migrate_page_move_mapping(struct address_space *mapping,\n \t */\n \tpage_unfreeze_refs(page, expected_count - 1);\n \n+\tspin_unlock(&mapping->tree_lock);\n+\t/* Leave irq disabled to prevent preemption while updating stats */\n+\n \t/*\n \t * If moved to a different zone then also account\n \t * the page for that zone. Other VM counters will be\n@@ -397,13 +413,19 @@ int migrate_page_move_mapping(struct address_space *mapping,\n \t * via NR_FILE_PAGES and NR_ANON_PAGES if they\n \t * are mapped to swap space.\n \t */\n-\t__dec_zone_page_state(page, NR_FILE_PAGES);\n-\t__inc_zone_page_state(newpage, NR_FILE_PAGES);\n-\tif (!PageSwapCache(page) && PageSwapBacked(page)) {\n-\t\t__dec_zone_page_state(page, NR_SHMEM);\n-\t\t__inc_zone_page_state(newpage, NR_SHMEM);\n+\tif (newzone != oldzone) {\n+\t\t__dec_zone_state(oldzone, NR_FILE_PAGES);\n+\t\t__inc_zone_state(newzone, NR_FILE_PAGES);\n+\t\tif (PageSwapBacked(page) && !PageSwapCache(page)) {\n+\t\t\t__dec_zone_state(oldzone, NR_SHMEM);\n+\t\t\t__inc_zone_state(newzone, NR_SHMEM);\n+\t\t}\n+\t\tif (dirty && mapping_cap_account_dirty(mapping)) {\n+\t\t\t__dec_zone_state(oldzone, NR_FILE_DIRTY);\n+\t\t\t__inc_zone_state(newzone, NR_FILE_DIRTY);\n+\t\t}\n \t}\n-\tspin_unlock_irq(&mapping->tree_lock);\n+\tlocal_irq_enable();\n \n \treturn MIGRATEPAGE_SUCCESS;\n }\n@@ -524,20 +546,9 @@ void migrate_page_copy(struct page *newpage, struct page *page)\n \tif (PageMappedToDisk(page))\n \t\tSetPageMappedToDisk(newpage);\n \n-\tif (PageDirty(page)) {\n-\t\tclear_page_dirty_for_io(page);\n-\t\t/*\n-\t\t * Want to mark the page and the radix tree as dirty, and\n-\t\t * redo the accounting that clear_page_dirty_for_io undid,\n-\t\t * but we can't use set_page_dirty because that function\n-\t\t * is actually a signal that all of the page has become dirty.\n-\t\t * Whereas only part of our page may be dirty.\n-\t\t */\n-\t\tif (PageSwapBacked(page))\n-\t\t\tSetPageDirty(newpage);\n-\t\telse\n-\t\t\t__set_page_dirty_nobuffers(newpage);\n- \t}\n+\t/* Move dirty on pages not done by migrate_page_move_mapping() */\n+\tif (PageDirty(page))\n+\t\tSetPageDirty(newpage);\n \n \tif (page_is_young(page))\n \t\tset_page_young(newpage);", "file_path": "files/2016_8\\106", "file_language": "c", "file_name": "mm/migrate.c", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}], "outdated": 0}
{"index": 45, "cve_id": "CVE-2016-6136", "cwe_id": ["CWE-362"], "cve_language": "C", "cve_description": "Race condition in the audit_log_single_execve_arg function in kernel/auditsc.c in the Linux kernel through 4.7 allows local users to bypass intended character-set restrictions or disrupt system-call auditing by changing a certain string, aka a \"double fetch\" vulnerability.", "cvss": "4.7", "publish_date": "August 6, 2016", "AV": "LOCAL", "AC": "HIGH", "PR": "LOW", "UI": "NONE", "S": "UNCHANGED", "C": "NONE", "I": "HIGH", "A": "NONE", "commit_id": "43761473c254b45883a64441dd0bc85a42f3645c", "commit_message": "audit: fix a double fetch in audit_log_single_execve_arg()\n\nThere is a double fetch problem in audit_log_single_execve_arg()\nwhere we first check the execve(2) argumnets for any \"bad\" characters\nwhich would require hex encoding and then re-fetch the arguments for\nlogging in the audit record[1].  Of course this leaves a window of\nopportunity for an unsavory application to munge with the data.\n\nThis patch reworks things by only fetching the argument data once[2]\ninto a buffer where it is scanned and logged into the audit\nrecords(s).  In addition to fixing the double fetch, this patch\nimproves on the original code in a few other ways: better handling\nof large arguments which require encoding, stricter record length\nchecking, and some performance improvements (completely unverified,\nbut we got rid of some strlen() calls, that's got to be a good\nthing).\n\nAs part of the development of this patch, I've also created a basic\nregression test for the audit-testsuite, the test can be tracked on\nGitHub at the following link:\n\n * https://github.com/linux-audit/audit-testsuite/issues/25\n\n[1] If you pay careful attention, there is actually a triple fetch\nproblem due to a strnlen_user() call at the top of the function.\n\n[2] This is a tiny white lie, we do make a call to strnlen_user()\nprior to fetching the argument data.  I don't like it, but due to the\nway the audit record is structured we really have no choice unless we\ncopy the entire argument at once (which would require a rather\nwasteful allocation).  The good news is that with this patch the\nkernel no longer relies on this strnlen_user() value for anything\nbeyond recording it in the log, we also update it with a trustworthy\nvalue whenever possible.\n\nReported-by: Pengfei Wang <wpengfeinudt@gmail.com>\nCc: <stable@vger.kernel.org>\nSigned-off-by: Paul Moore <paul@paul-moore.com>", "commit_date": "2016-07-20T18:15:46Z", "project": "torvalds/linux", "url": "https://api.github.com/repos/torvalds/linux/commits/43761473c254b45883a64441dd0bc85a42f3645c", "html_url": "https://github.com/torvalds/linux/commit/43761473c254b45883a64441dd0bc85a42f3645c", "windows_before": "", "windows_after": "", "parents": [{"commit_id_before": "0b7a0fdb29715e38641beb39db4d01695b22b5aa", "url_before": "https://api.github.com/repos/torvalds/linux/commits/0b7a0fdb29715e38641beb39db4d01695b22b5aa", "html_url_before": "https://github.com/torvalds/linux/commit/0b7a0fdb29715e38641beb39db4d01695b22b5aa"}], "details": [{"raw_url": "https://github.com/torvalds/linux/raw/43761473c254b45883a64441dd0bc85a42f3645c/kernel/auditsc.c", "patch": "@@ -73,6 +73,7 @@\n #include <linux/compat.h>\n #include <linux/ctype.h>\n #include <linux/string.h>\n+#include <linux/uaccess.h>\n #include <uapi/linux/limits.h>\n \n #include \"audit.h\"\n@@ -82,7 +83,8 @@\n #define AUDITSC_SUCCESS 1\n #define AUDITSC_FAILURE 2\n \n-/* no execve audit message should be longer than this (userspace limits) */\n+/* no execve audit message should be longer than this (userspace limits),\n+ * see the note near the top of audit_log_execve_info() about this value */\n #define MAX_EXECVE_AUDIT_LEN 7500\n \n /* max length to print of cmdline/proctitle value during audit */\n@@ -992,184 +994,178 @@ static int audit_log_pid_context(struct audit_context *context, pid_t pid,\n \treturn rc;\n }\n \n-/*\n- * to_send and len_sent accounting are very loose estimates.  We aren't\n- * really worried about a hard cap to MAX_EXECVE_AUDIT_LEN so much as being\n- * within about 500 bytes (next page boundary)\n- *\n- * why snprintf?  an int is up to 12 digits long.  if we just assumed when\n- * logging that a[%d]= was going to be 16 characters long we would be wasting\n- * space in every audit message.  In one 7500 byte message we can log up to\n- * about 1000 min size arguments.  That comes down to about 50% waste of space\n- * if we didn't do the snprintf to find out how long arg_num_len was.\n- */\n-static int audit_log_single_execve_arg(struct audit_context *context,\n-\t\t\t\t\tstruct audit_buffer **ab,\n-\t\t\t\t\tint arg_num,\n-\t\t\t\t\tsize_t *len_sent,\n-\t\t\t\t\tconst char __user *p,\n-\t\t\t\t\tchar *buf)\n+static void audit_log_execve_info(struct audit_context *context,\n+\t\t\t\t  struct audit_buffer **ab)\n {\n-\tchar arg_num_len_buf[12];\n-\tconst char __user *tmp_p = p;\n-\t/* how many digits are in arg_num? 5 is the length of ' a=\"\"' */\n-\tsize_t arg_num_len = snprintf(arg_num_len_buf, 12, \"%d\", arg_num) + 5;\n-\tsize_t len, len_left, to_send;\n-\tsize_t max_execve_audit_len = MAX_EXECVE_AUDIT_LEN;\n-\tunsigned int i, has_cntl = 0, too_long = 0;\n-\tint ret;\n-\n-\t/* strnlen_user includes the null we don't want to send */\n-\tlen_left = len = strnlen_user(p, MAX_ARG_STRLEN) - 1;\n-\n-\t/*\n-\t * We just created this mm, if we can't find the strings\n-\t * we just copied into it something is _very_ wrong. Similar\n-\t * for strings that are too long, we should not have created\n-\t * any.\n-\t */\n-\tif (WARN_ON_ONCE(len < 0 || len > MAX_ARG_STRLEN - 1)) {\n-\t\tsend_sig(SIGKILL, current, 0);\n-\t\treturn -1;\n+\tlong len_max;\n+\tlong len_rem;\n+\tlong len_full;\n+\tlong len_buf;\n+\tlong len_abuf;\n+\tlong len_tmp;\n+\tbool require_data;\n+\tbool encode;\n+\tunsigned int iter;\n+\tunsigned int arg;\n+\tchar *buf_head;\n+\tchar *buf;\n+\tconst char __user *p = (const char __user *)current->mm->arg_start;\n+\n+\t/* NOTE: this buffer needs to be large enough to hold all the non-arg\n+\t *       data we put in the audit record for this argument (see the\n+\t *       code below) ... at this point in time 96 is plenty */\n+\tchar abuf[96];\n+\n+\t/* NOTE: we set MAX_EXECVE_AUDIT_LEN to a rather arbitrary limit, the\n+\t *       current value of 7500 is not as important as the fact that it\n+\t *       is less than 8k, a setting of 7500 gives us plenty of wiggle\n+\t *       room if we go over a little bit in the logging below */\n+\tWARN_ON_ONCE(MAX_EXECVE_AUDIT_LEN > 7500);\n+\tlen_max = MAX_EXECVE_AUDIT_LEN;\n+\n+\t/* scratch buffer to hold the userspace args */\n+\tbuf_head = kmalloc(MAX_EXECVE_AUDIT_LEN + 1, GFP_KERNEL);\n+\tif (!buf_head) {\n+\t\taudit_panic(\"out of memory for argv string\");\n+\t\treturn;\n \t}\n+\tbuf = buf_head;\n \n-\t/* walk the whole argument looking for non-ascii chars */\n+\taudit_log_format(*ab, \"argc=%d\", context->execve.argc);\n+\n+\tlen_rem = len_max;\n+\tlen_buf = 0;\n+\tlen_full = 0;\n+\trequire_data = true;\n+\tencode = false;\n+\titer = 0;\n+\targ = 0;\n \tdo {\n-\t\tif (len_left > MAX_EXECVE_AUDIT_LEN)\n-\t\t\tto_send = MAX_EXECVE_AUDIT_LEN;\n-\t\telse\n-\t\t\tto_send = len_left;\n-\t\tret = copy_from_user(buf, tmp_p, to_send);\n-\t\t/*\n-\t\t * There is no reason for this copy to be short. We just\n-\t\t * copied them here, and the mm hasn't been exposed to user-\n-\t\t * space yet.\n-\t\t */\n-\t\tif (ret) {\n-\t\t\tWARN_ON(1);\n-\t\t\tsend_sig(SIGKILL, current, 0);\n-\t\t\treturn -1;\n-\t\t}\n-\t\tbuf[to_send] = '\\0';\n-\t\thas_cntl = audit_string_contains_control(buf, to_send);\n-\t\tif (has_cntl) {\n-\t\t\t/*\n-\t\t\t * hex messages get logged as 2 bytes, so we can only\n-\t\t\t * send half as much in each message\n-\t\t\t */\n-\t\t\tmax_execve_audit_len = MAX_EXECVE_AUDIT_LEN / 2;\n-\t\t\tbreak;\n-\t\t}\n-\t\tlen_left -= to_send;\n-\t\ttmp_p += to_send;\n-\t} while (len_left > 0);\n-\n-\tlen_left = len;\n-\n-\tif (len > max_execve_audit_len)\n-\t\ttoo_long = 1;\n-\n-\t/* rewalk the argument actually logging the message */\n-\tfor (i = 0; len_left > 0; i++) {\n-\t\tint room_left;\n-\n-\t\tif (len_left > max_execve_audit_len)\n-\t\t\tto_send = max_execve_audit_len;\n-\t\telse\n-\t\t\tto_send = len_left;\n-\n-\t\t/* do we have space left to send this argument in this ab? */\n-\t\troom_left = MAX_EXECVE_AUDIT_LEN - arg_num_len - *len_sent;\n-\t\tif (has_cntl)\n-\t\t\troom_left -= (to_send * 2);\n-\t\telse\n-\t\t\troom_left -= to_send;\n-\t\tif (room_left < 0) {\n-\t\t\t*len_sent = 0;\n-\t\t\taudit_log_end(*ab);\n-\t\t\t*ab = audit_log_start(context, GFP_KERNEL, AUDIT_EXECVE);\n-\t\t\tif (!*ab)\n-\t\t\t\treturn 0;\n-\t\t}\n+\t\t/* NOTE: we don't ever want to trust this value for anything\n+\t\t *       serious, but the audit record format insists we\n+\t\t *       provide an argument length for really long arguments,\n+\t\t *       e.g. > MAX_EXECVE_AUDIT_LEN, so we have no choice but\n+\t\t *       to use strncpy_from_user() to obtain this value for\n+\t\t *       recording in the log, although we don't use it\n+\t\t *       anywhere here to avoid a double-fetch problem */\n+\t\tif (len_full == 0)\n+\t\t\tlen_full = strnlen_user(p, MAX_ARG_STRLEN) - 1;\n+\n+\t\t/* read more data from userspace */\n+\t\tif (require_data) {\n+\t\t\t/* can we make more room in the buffer? */\n+\t\t\tif (buf != buf_head) {\n+\t\t\t\tmemmove(buf_head, buf, len_buf);\n+\t\t\t\tbuf = buf_head;\n+\t\t\t}\n+\n+\t\t\t/* fetch as much as we can of the argument */\n+\t\t\tlen_tmp = strncpy_from_user(&buf_head[len_buf], p,\n+\t\t\t\t\t\t    len_max - len_buf);\n+\t\t\tif (len_tmp == -EFAULT) {\n+\t\t\t\t/* unable to copy from userspace */\n+\t\t\t\tsend_sig(SIGKILL, current, 0);\n+\t\t\t\tgoto out;\n+\t\t\t} else if (len_tmp == (len_max - len_buf)) {\n+\t\t\t\t/* buffer is not large enough */\n+\t\t\t\trequire_data = true;\n+\t\t\t\t/* NOTE: if we are going to span multiple\n+\t\t\t\t *       buffers force the encoding so we stand\n+\t\t\t\t *       a chance at a sane len_full value and\n+\t\t\t\t *       consistent record encoding */\n+\t\t\t\tencode = true;\n+\t\t\t\tlen_full = len_full * 2;\n+\t\t\t\tp += len_tmp;\n+\t\t\t} else {\n+\t\t\t\trequire_data = false;\n+\t\t\t\tif (!encode)\n+\t\t\t\t\tencode = audit_string_contains_control(\n+\t\t\t\t\t\t\t\tbuf, len_tmp);\n+\t\t\t\t/* try to use a trusted value for len_full */\n+\t\t\t\tif (len_full < len_max)\n+\t\t\t\t\tlen_full = (encode ?\n+\t\t\t\t\t\t    len_tmp * 2 : len_tmp);\n+\t\t\t\tp += len_tmp + 1;\n+\t\t\t}\n+\t\t\tlen_buf += len_tmp;\n+\t\t\tbuf_head[len_buf] = '\\0';\n \n-\t\t/*\n-\t\t * first record needs to say how long the original string was\n-\t\t * so we can be sure nothing was lost.\n-\t\t */\n-\t\tif ((i == 0) && (too_long))\n-\t\t\taudit_log_format(*ab, \" a%d_len=%zu\", arg_num,\n-\t\t\t\t\t has_cntl ? 2*len : len);\n-\n-\t\t/*\n-\t\t * normally arguments are small enough to fit and we already\n-\t\t * filled buf above when we checked for control characters\n-\t\t * so don't bother with another copy_from_user\n-\t\t */\n-\t\tif (len >= max_execve_audit_len)\n-\t\t\tret = copy_from_user(buf, p, to_send);\n-\t\telse\n-\t\t\tret = 0;\n-\t\tif (ret) {\n-\t\t\tWARN_ON(1);\n-\t\t\tsend_sig(SIGKILL, current, 0);\n-\t\t\treturn -1;\n+\t\t\t/* length of the buffer in the audit record? */\n+\t\t\tlen_abuf = (encode ? len_buf * 2 : len_buf + 2);\n \t\t}\n-\t\tbuf[to_send] = '\\0';\n-\n-\t\t/* actually log it */\n-\t\taudit_log_format(*ab, \" a%d\", arg_num);\n-\t\tif (too_long)\n-\t\t\taudit_log_format(*ab, \"[%d]\", i);\n-\t\taudit_log_format(*ab, \"=\");\n-\t\tif (has_cntl)\n-\t\t\taudit_log_n_hex(*ab, buf, to_send);\n-\t\telse\n-\t\t\taudit_log_string(*ab, buf);\n-\n-\t\tp += to_send;\n-\t\tlen_left -= to_send;\n-\t\t*len_sent += arg_num_len;\n-\t\tif (has_cntl)\n-\t\t\t*len_sent += to_send * 2;\n-\t\telse\n-\t\t\t*len_sent += to_send;\n-\t}\n-\t/* include the null we didn't log */\n-\treturn len + 1;\n-}\n \n-static void audit_log_execve_info(struct audit_context *context,\n-\t\t\t\t  struct audit_buffer **ab)\n-{\n-\tint i, len;\n-\tsize_t len_sent = 0;\n-\tconst char __user *p;\n-\tchar *buf;\n+\t\t/* write as much as we can to the audit log */\n+\t\tif (len_buf > 0) {\n+\t\t\t/* NOTE: some magic numbers here - basically if we\n+\t\t\t *       can't fit a reasonable amount of data into the\n+\t\t\t *       existing audit buffer, flush it and start with\n+\t\t\t *       a new buffer */\n+\t\t\tif ((sizeof(abuf) + 8) > len_rem) {\n+\t\t\t\tlen_rem = len_max;\n+\t\t\t\taudit_log_end(*ab);\n+\t\t\t\t*ab = audit_log_start(context,\n+\t\t\t\t\t\t      GFP_KERNEL, AUDIT_EXECVE);\n+\t\t\t\tif (!*ab)\n+\t\t\t\t\tgoto out;\n+\t\t\t}\n \n-\tp = (const char __user *)current->mm->arg_start;\n+\t\t\t/* create the non-arg portion of the arg record */\n+\t\t\tlen_tmp = 0;\n+\t\t\tif (require_data || (iter > 0) ||\n+\t\t\t    ((len_abuf + sizeof(abuf)) > len_rem)) {\n+\t\t\t\tif (iter == 0) {\n+\t\t\t\t\tlen_tmp += snprintf(&abuf[len_tmp],\n+\t\t\t\t\t\t\tsizeof(abuf) - len_tmp,\n+\t\t\t\t\t\t\t\" a%d_len=%lu\",\n+\t\t\t\t\t\t\targ, len_full);\n+\t\t\t\t}\n+\t\t\t\tlen_tmp += snprintf(&abuf[len_tmp],\n+\t\t\t\t\t\t    sizeof(abuf) - len_tmp,\n+\t\t\t\t\t\t    \" a%d[%d]=\", arg, iter++);\n+\t\t\t} else\n+\t\t\t\tlen_tmp += snprintf(&abuf[len_tmp],\n+\t\t\t\t\t\t    sizeof(abuf) - len_tmp,\n+\t\t\t\t\t\t    \" a%d=\", arg);\n+\t\t\tWARN_ON(len_tmp >= sizeof(abuf));\n+\t\t\tabuf[sizeof(abuf) - 1] = '\\0';\n+\n+\t\t\t/* log the arg in the audit record */\n+\t\t\taudit_log_format(*ab, \"%s\", abuf);\n+\t\t\tlen_rem -= len_tmp;\n+\t\t\tlen_tmp = len_buf;\n+\t\t\tif (encode) {\n+\t\t\t\tif (len_abuf > len_rem)\n+\t\t\t\t\tlen_tmp = len_rem / 2; /* encoding */\n+\t\t\t\taudit_log_n_hex(*ab, buf, len_tmp);\n+\t\t\t\tlen_rem -= len_tmp * 2;\n+\t\t\t\tlen_abuf -= len_tmp * 2;\n+\t\t\t} else {\n+\t\t\t\tif (len_abuf > len_rem)\n+\t\t\t\t\tlen_tmp = len_rem - 2; /* quotes */\n+\t\t\t\taudit_log_n_string(*ab, buf, len_tmp);\n+\t\t\t\tlen_rem -= len_tmp + 2;\n+\t\t\t\t/* don't subtract the \"2\" because we still need\n+\t\t\t\t * to add quotes to the remaining string */\n+\t\t\t\tlen_abuf -= len_tmp;\n+\t\t\t}\n+\t\t\tlen_buf -= len_tmp;\n+\t\t\tbuf += len_tmp;\n+\t\t}\n \n-\taudit_log_format(*ab, \"argc=%d\", context->execve.argc);\n+\t\t/* ready to move to the next argument? */\n+\t\tif ((len_buf == 0) && !require_data) {\n+\t\t\targ++;\n+\t\t\titer = 0;\n+\t\t\tlen_full = 0;\n+\t\t\trequire_data = true;\n+\t\t\tencode = false;\n+\t\t}\n+\t} while (arg < context->execve.argc);\n \n-\t/*\n-\t * we need some kernel buffer to hold the userspace args.  Just\n-\t * allocate one big one rather than allocating one of the right size\n-\t * for every single argument inside audit_log_single_execve_arg()\n-\t * should be <8k allocation so should be pretty safe.\n-\t */\n-\tbuf = kmalloc(MAX_EXECVE_AUDIT_LEN + 1, GFP_KERNEL);\n-\tif (!buf) {\n-\t\taudit_panic(\"out of memory for argv string\");\n-\t\treturn;\n-\t}\n+\t/* NOTE: the caller handles the final audit_log_end() call */\n \n-\tfor (i = 0; i < context->execve.argc; i++) {\n-\t\tlen = audit_log_single_execve_arg(context, ab, i,\n-\t\t\t\t\t\t  &len_sent, p, buf);\n-\t\tif (len <= 0)\n-\t\t\tbreak;\n-\t\tp += len;\n-\t}\n-\tkfree(buf);\n+out:\n+\tkfree(buf_head);\n }\n \n static void show_special(struct audit_context *context, int *call_panic)", "file_path": "files/2016_8\\107", "file_language": "c", "file_name": "kernel/auditsc.c", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}], "outdated": 0}
{"index": 46, "cve_id": "CVE-2014-9888", "cwe_id": ["CWE-264"], "cve_language": "C", "cve_description": "arch/arm/mm/dma-mapping.c in the Linux kernel before 3.13 on ARM platforms, as used in Android before 2016-08-05 on Nexus 5 and 7 (2013) devices, does not prevent executable DMA mappings, which might allow local users to gain privileges via a crafted application, aka Android internal bug 28803642 and Qualcomm internal bug CR642735.", "cvss": "7.8", "publish_date": "August 6, 2016", "AV": "LOCAL", "AC": "LOW", "PR": "LOW", "UI": "NONE", "S": "UNCHANGED", "C": "HIGH", "I": "HIGH", "A": "HIGH", "commit_id": "0ea1ec713f04bdfac343c9702b21cd3a7c711826", "commit_message": "ARM: dma-mapping: don't allow DMA mappings to be marked executable\n\nDMA mapping permissions were being derived from pgprot_kernel directly\nwithout using PAGE_KERNEL.  This causes them to be marked with executable\npermission, which is not what we want.  Fix this.\n\nSigned-off-by: Russell King <rmk+kernel@arm.linux.org.uk>", "commit_date": "2013-10-24T10:17:27Z", "project": "torvalds/linux", "url": "https://api.github.com/repos/torvalds/linux/commits/0ea1ec713f04bdfac343c9702b21cd3a7c711826", "html_url": "https://github.com/torvalds/linux/commit/0ea1ec713f04bdfac343c9702b21cd3a7c711826", "windows_before": "", "windows_after": "", "parents": [{"commit_id_before": "59fd3033b55642da97b4ecde0c85de78d7229675", "url_before": "https://api.github.com/repos/torvalds/linux/commits/59fd3033b55642da97b4ecde0c85de78d7229675", "html_url_before": "https://github.com/torvalds/linux/commit/59fd3033b55642da97b4ecde0c85de78d7229675"}], "details": [{"raw_url": "https://github.com/torvalds/linux/raw/0ea1ec713f04bdfac343c9702b21cd3a7c711826/arch/arm/mm/dma-mapping.c", "patch": "@@ -687,7 +687,7 @@ static void *__dma_alloc(struct device *dev, size_t size, dma_addr_t *handle,\n void *arm_dma_alloc(struct device *dev, size_t size, dma_addr_t *handle,\n \t\t    gfp_t gfp, struct dma_attrs *attrs)\n {\n-\tpgprot_t prot = __get_dma_pgprot(attrs, pgprot_kernel);\n+\tpgprot_t prot = __get_dma_pgprot(attrs, PAGE_KERNEL);\n \tvoid *memory;\n \n \tif (dma_alloc_from_coherent(dev, size, handle, &memory))\n@@ -700,7 +700,7 @@ void *arm_dma_alloc(struct device *dev, size_t size, dma_addr_t *handle,\n static void *arm_coherent_dma_alloc(struct device *dev, size_t size,\n \tdma_addr_t *handle, gfp_t gfp, struct dma_attrs *attrs)\n {\n-\tpgprot_t prot = __get_dma_pgprot(attrs, pgprot_kernel);\n+\tpgprot_t prot = __get_dma_pgprot(attrs, PAGE_KERNEL);\n \tvoid *memory;\n \n \tif (dma_alloc_from_coherent(dev, size, handle, &memory))", "file_path": "files/2016_8\\108", "file_language": "c", "file_name": "arch/arm/mm/dma-mapping.c", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}], "outdated": 0}
{"index": 47, "cve_id": "CVE-2014-9895", "cwe_id": ["CWE-200"], "cve_language": "C", "cve_description": "drivers/media/media-device.c in the Linux kernel before 3.11, as used in Android before 2016-08-05 on Nexus 5 and 7 (2013) devices, does not properly initialize certain data structures, which allows local users to obtain sensitive information via a crafted application, aka Android internal bug 28750150 and Qualcomm internal bug CR570757, a different vulnerability than CVE-2014-1739.", "cvss": "5.5", "publish_date": "August 6, 2016", "AV": "LOCAL", "AC": "LOW", "PR": "NONE", "UI": "REQUIRED", "S": "UNCHANGED", "C": "HIGH", "I": "NONE", "A": "NONE", "commit_id": "c88e739b1fad662240e99ecbd0bdaac871717987", "commit_message": "[media] media: info leak in __media_device_enum_links()\n\nThese structs have holes and reserved struct members which aren't\ncleared.  I've added a memset() so we don't leak stack information.\n\nSigned-off-by: Dan Carpenter <dan.carpenter@oracle.com>\nSigned-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>\nSigned-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>", "commit_date": "2013-06-12T21:52:45Z", "project": "torvalds/linux", "url": "https://api.github.com/repos/torvalds/linux/commits/c88e739b1fad662240e99ecbd0bdaac871717987", "html_url": "https://github.com/torvalds/linux/commit/c88e739b1fad662240e99ecbd0bdaac871717987", "windows_before": "", "windows_after": "", "parents": [{"commit_id_before": "fe905b8cc992edd3d1f729f4a88c4701e7c3b774", "url_before": "https://api.github.com/repos/torvalds/linux/commits/fe905b8cc992edd3d1f729f4a88c4701e7c3b774", "html_url_before": "https://github.com/torvalds/linux/commit/fe905b8cc992edd3d1f729f4a88c4701e7c3b774"}], "details": [{"raw_url": "https://github.com/torvalds/linux/raw/c88e739b1fad662240e99ecbd0bdaac871717987/drivers/media/media-device.c", "patch": "@@ -142,6 +142,8 @@ static long __media_device_enum_links(struct media_device *mdev,\n \n \t\tfor (p = 0; p < entity->num_pads; p++) {\n \t\t\tstruct media_pad_desc pad;\n+\n+\t\t\tmemset(&pad, 0, sizeof(pad));\n \t\t\tmedia_device_kpad_to_upad(&entity->pads[p], &pad);\n \t\t\tif (copy_to_user(&links->pads[p], &pad, sizeof(pad)))\n \t\t\t\treturn -EFAULT;\n@@ -159,6 +161,7 @@ static long __media_device_enum_links(struct media_device *mdev,\n \t\t\tif (entity->links[l].source->entity != entity)\n \t\t\t\tcontinue;\n \n+\t\t\tmemset(&link, 0, sizeof(link));\n \t\t\tmedia_device_kpad_to_upad(entity->links[l].source,\n \t\t\t\t\t\t  &link.source);\n \t\t\tmedia_device_kpad_to_upad(entity->links[l].sink,", "file_path": "files/2016_8\\109", "file_language": "c", "file_name": "drivers/media/media-device.c", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}], "outdated": 0}
{"index": 48, "cve_id": "CVE-2016-0782", "cwe_id": ["CWE-79"], "cve_language": "Java", "cve_description": "The administration web console in Apache ActiveMQ 5.x before 5.11.4, 5.12.x before 5.12.3, and 5.13.x before 5.13.2 allows remote authenticated users to conduct cross-site scripting (XSS) attacks and consequently obtain sensitive information from a Java memory dump via vectors related to creating a queue.", "cvss": "5.4", "publish_date": "August 5, 2016", "AV": "NETWORK", "AC": "LOW", "PR": "LOW", "UI": "REQUIRED", "S": "CHANGED", "C": "LOW", "I": "LOW", "A": "NONE", "commit_id": "0c9fdb5b4180c1ae800bbc8bae7a2c0620f6749b", "commit_message": "Turn off jolokia discovery by default.", "commit_date": "2016-02-17T07:48:09Z", "project": "apache/activemq", "url": "https://api.github.com/repos/apache/activemq/commits/0c9fdb5b4180c1ae800bbc8bae7a2c0620f6749b", "html_url": "https://github.com/apache/activemq/commit/0c9fdb5b4180c1ae800bbc8bae7a2c0620f6749b", "windows_before": "", "windows_after": "", "parents": [{"commit_id_before": "2061186a0a2486aebf26c4ceb8126933ed01826e", "url_before": "https://api.github.com/repos/apache/activemq/commits/2061186a0a2486aebf26c4ceb8126933ed01826e", "html_url_before": "https://github.com/apache/activemq/commit/2061186a0a2486aebf26c4ceb8126933ed01826e"}], "details": [{"raw_url": "https://github.com/apache/activemq/raw/0c9fdb5b4180c1ae800bbc8bae7a2c0620f6749b/assembly/src/release/webapps/api/WEB-INF/web.xml", "patch": "@@ -38,10 +38,11 @@\n \n     <servlet>\n         <servlet-name>jolokia-agent</servlet-name>\n-        <servlet-class>org.jolokia.http.AgentServlet</servlet-class>        \n+        <servlet-class>org.jolokia.http.AgentServlet</servlet-class>\n+        <!-- Uncomment this if you want jolokia multicast discovery to be enabled         \n         <init-param>\n           <param-name>discoveryEnabled</param-name>\n-          <param-value>false</param-value>\n+          <param-value>true</param-value>\n         </init-param>      \n         <init-param>\n           <param-name>discoveryAgentUrl</param-name>\n@@ -51,6 +52,7 @@\n           <param-name>agentDescription</param-name>\n           <param-value>Apache ActiveMQ</param-value>\n         </init-param>\n+        -->\n         <!-- turn off returning exceptions and stacktraces from jolokia -->\n         <init-param>\n           <param-name>allowErrorDetails</param-name>", "file_path": "files/2016_8\\110", "file_language": "xml", "file_name": "assembly/src/release/webapps/api/WEB-INF/web.xml", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}], "outdated": 0}
{"index": 49, "cve_id": "CVE-2016-0782", "cwe_id": ["CWE-79"], "cve_language": "Java", "cve_description": "The administration web console in Apache ActiveMQ 5.x before 5.11.4, 5.12.x before 5.12.3, and 5.13.x before 5.13.2 allows remote authenticated users to conduct cross-site scripting (XSS) attacks and consequently obtain sensitive information from a Java memory dump via vectors related to creating a queue.", "cvss": "5.4", "publish_date": "August 5, 2016", "AV": "NETWORK", "AC": "LOW", "PR": "LOW", "UI": "REQUIRED", "S": "CHANGED", "C": "LOW", "I": "LOW", "A": "NONE", "commit_id": "2061186a0a2486aebf26c4ceb8126933ed01826e", "commit_message": "Jolokia should not send back exceptions/error details by default", "commit_date": "2016-02-17T07:48:04Z", "project": "apache/activemq", "url": "https://api.github.com/repos/apache/activemq/commits/2061186a0a2486aebf26c4ceb8126933ed01826e", "html_url": "https://github.com/apache/activemq/commit/2061186a0a2486aebf26c4ceb8126933ed01826e", "windows_before": "", "windows_after": "", "parents": [{"commit_id_before": "7828069637acb2f1ca1710523f6a2b216c12c7f8", "url_before": "https://api.github.com/repos/apache/activemq/commits/7828069637acb2f1ca1710523f6a2b216c12c7f8", "html_url_before": "https://github.com/apache/activemq/commit/7828069637acb2f1ca1710523f6a2b216c12c7f8"}], "details": [{"raw_url": "https://github.com/apache/activemq/raw/2061186a0a2486aebf26c4ceb8126933ed01826e/assembly/src/release/webapps/api/WEB-INF/web.xml", "patch": "@@ -51,6 +51,11 @@\n           <param-name>agentDescription</param-name>\n           <param-value>Apache ActiveMQ</param-value>\n         </init-param>\n+        <!-- turn off returning exceptions and stacktraces from jolokia -->\n+        <init-param>\n+          <param-name>allowErrorDetails</param-name>\n+          <param-value>false</param-value>\n+        </init-param>\n         <load-on-startup>1</load-on-startup> \n     </servlet>\n ", "file_path": "files/2016_8\\111", "file_language": "xml", "file_name": "assembly/src/release/webapps/api/WEB-INF/web.xml", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}], "outdated": 0}
