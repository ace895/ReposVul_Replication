{"index": 7, "cve_id": "CVE-2016-6214", "cwe_id": ["CWE-125"], "cve_language": "C", "cve_description": "gd_tga.c in the GD Graphics Library (aka libgd) before 2.2.3 allows remote attackers to cause a denial of service (out-of-bounds read) via a crafted TGA file.", "cvss": "6.5", "publish_date": "August 12, 2016", "AV": "NETWORK", "AC": "LOW", "PR": "NONE", "UI": "REQUIRED", "S": "UNCHANGED", "C": "NONE", "I": "NONE", "A": "HIGH", "commit_id": "10ef1dca63d62433fda13309b4a228782db823f7", "commit_message": "Unsupported TGA bpp/alphabit combinations should error gracefully\n\nCurrently, only 24bpp without alphabits and 32bpp with 8 alphabits are\nreally supported. All other combinations will be rejected with a warning.", "commit_date": "2016-07-12T18:46:33Z", "project": "libgd/libgd", "url": "https://api.github.com/repos/libgd/libgd/commits/10ef1dca63d62433fda13309b4a228782db823f7", "html_url": "https://github.com/libgd/libgd/commit/10ef1dca63d62433fda13309b4a228782db823f7", "windows_before": "", "windows_after": "", "parents": [{"commit_id_before": "e6399f5a470f50285cef173e438638ae5bc741e0", "url_before": "https://api.github.com/repos/libgd/libgd/commits/e6399f5a470f50285cef173e438638ae5bc741e0", "html_url_before": "https://github.com/libgd/libgd/commit/e6399f5a470f50285cef173e438638ae5bc741e0"}], "details": [{"raw_url": "https://github.com/libgd/libgd/raw/10ef1dca63d62433fda13309b4a228782db823f7/src/gd_tga.c", "code": "#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif /* HAVE_CONFIG_H */\n\n#include <stdio.h>\n#include <stddef.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"gd_tga.h\"\n#include \"gd.h\"\n#include \"gd_errors.h\"\n#include \"gdhelpers.h\"\n\n/*!\t\\brief Creates a gdImage from a TGA file\n *\tCreates a gdImage from a TGA binary file via a gdIOCtx.\n *\t\\param infile Pointer to TGA binary file\n *\t\\return gdImagePtr\n */\nBGD_DECLARE(gdImagePtr) gdImageCreateFromTga(FILE *fp)\n{\n\tgdImagePtr image;\n\tgdIOCtx* in = gdNewFileCtx(fp);\n\tif (in == NULL) return NULL;\n\timage = gdImageCreateFromTgaCtx(in);\n\tin->gd_free( in );\n\treturn image;\n}\n\nBGD_DECLARE(gdImagePtr) gdImageCreateFromTgaPtr(int size, void *data)\n{\n\tgdImagePtr im;\n\tgdIOCtx *in = gdNewDynamicCtxEx (size, data, 0);\n\tif (in == NULL) return NULL;\n\tim = gdImageCreateFromTgaCtx(in);\n\tin->gd_free(in);\n\treturn im;\n}\n\n\n/*!\t\\brief Creates a gdImage from a gdIOCtx\n *\tCreates a gdImage from a gdIOCtx referencing a TGA binary file.\n *\t\\param ctx Pointer to a gdIOCtx structure\n *\t\\return gdImagePtr\n */\nBGD_DECLARE(gdImagePtr) gdImageCreateFromTgaCtx(gdIOCtx* ctx)\n{\n\tint bitmap_caret = 0;\n\toTga *tga = NULL;\n\t/*\tint pixel_block_size = 0;\n\t\tint image_block_size = 0; */\n\tvolatile gdImagePtr image = NULL;\n\tint x = 0;\n\tint y = 0;\n\n\ttga = (oTga *) gdMalloc(sizeof(oTga));\n\tif (!tga) {\n\t\treturn NULL;\n\t}\n\n\ttga->bitmap = NULL;\n\ttga->ident = NULL;\n\n\tif (read_header_tga(ctx, tga) < 0) {\n\t\tfree_tga(tga);\n\t\treturn NULL;\n\t}\n\n\t/*TODO: Will this be used?\n\t\tpixel_block_size = tga->bits / 8;\n\t\timage_block_size = (tga->width * tga->height) * pixel_block_size;\n\t*/\n\n\tif (read_image_tga(ctx, tga) < 0) {\n\t\tfree_tga(tga);\n\t\treturn NULL;\n\t}\n\n\timage = gdImageCreateTrueColor((int)tga->width, (int)tga->height );\n\n\tif (image == 0) {\n\t\tfree_tga( tga );\n\t\treturn NULL;\n\t}\n\n\t/*!\t\\brief Populate GD image object\n\t *  Copy the pixel data from our tga bitmap buffer into the GD image\n\t *  Disable blending and save the alpha channel per default\n\t */\n\tif (tga->alphabits) {\n\t\tgdImageAlphaBlending(image, 0);\n\t\tgdImageSaveAlpha(image, 1);\n\t}\n\n\t/* TODO: use alphabits as soon as we support 24bit and other alpha bps (ie != 8bits) */\n\tfor (y = 0; y < tga->height; y++) {\n\t\tregister int *tpix = image->tpixels[y];\n\t\tfor ( x = 0; x < tga->width; x++, tpix++) {\n\t\t\tif (tga->bits == TGA_BPP_24) {\n\t\t\t\t*tpix = gdTrueColor(tga->bitmap[bitmap_caret + 2], tga->bitmap[bitmap_caret + 1], tga->bitmap[bitmap_caret]);\n\t\t\t\tbitmap_caret += 3;\n\t\t\t} else if (tga->bits == TGA_BPP_32 && tga->alphabits) {\n\t\t\t\tregister int a = tga->bitmap[bitmap_caret + 3];\n\n\t\t\t\t*tpix = gdTrueColorAlpha(tga->bitmap[bitmap_caret + 2], tga->bitmap[bitmap_caret + 1], tga->bitmap[bitmap_caret], gdAlphaMax - (a >> 1));\n\t\t\t\tbitmap_caret += 4;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (tga->flipv && tga->fliph) {\n\t\tgdImageFlipBoth(image);\n\t} else if (tga->flipv) {\n\t\tgdImageFlipVertical(image);\n\t} else if (tga->fliph) {\n\t\tgdImageFlipHorizontal(image);\n\t}\n\n\tfree_tga(tga);\n\n\treturn image;\n}\n\n/*!\t\\brief Reads a TGA header.\n *\tReads the header block from a binary TGA file populating the referenced TGA structure.\n *\t\\param ctx Pointer to TGA binary file\n *\t\\param tga Pointer to TGA structure\n *\t\\return int 1 on sucess, -1 on failure\n */\nint read_header_tga(gdIOCtx *ctx, oTga *tga)\n{\n\n\tunsigned char header[18];\n\n\tif (gdGetBuf(header, sizeof(header), ctx) < 18) {\n\t\tgd_error(\"fail to read header\");\n\t\treturn -1;\n\t}\n\n\ttga->identsize = header[0];\n\ttga->colormaptype = header[1];\n\ttga->imagetype = header[2];\n\ttga->colormapstart = header[3] + (header[4] << 8);\n\ttga->colormaplength = header[5] + (header[6] << 8);\n\ttga->colormapbits = header[7];\n\ttga->xstart = header[8] + (header[9] << 8);\n\ttga->ystart = header[10] + (header[11] << 8);\n\ttga->width = header[12] + (header[13] << 8);\n\ttga->height = header[14] + (header[15] << 8);\n\ttga->bits = header[16];\n\ttga->alphabits = header[17] & 0x0f;\n\ttga->fliph = (header[17] & 0x10) ? 1 : 0;\n\ttga->flipv = (header[17] & 0x20) ? 0 : 1;\n\n#if DEBUG\n\tprintf(\"format bps: %i\\n\", tga->bits);\n\tprintf(\"flip h/v: %i / %i\\n\", tga->fliph, tga->flipv);\n\tprintf(\"alpha: %i\\n\", tga->alphabits);\n\tprintf(\"wxh: %i %i\\n\", tga->width, tga->height);\n#endif\n\n\tif (!((tga->bits == TGA_BPP_24 && tga->alphabits == 0)\n\t\t|| (tga->bits == TGA_BPP_32 && tga->alphabits == 8)))\n\t{\n\t\tgd_error_ex(GD_WARNING, \"gd-tga: %u bits per pixel with %u alpha bits not supported\\n\",\n\t\t\ttga->bits, tga->alphabits);\n\t\treturn -1;\n\t}\n\n\ttga->ident = NULL;\n\n\tif (tga->identsize > 0) {\n\t\ttga->ident = (char *) gdMalloc(tga->identsize * sizeof(char));\n\t\tif(tga->ident == NULL) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tgdGetBuf(tga->ident, tga->identsize, ctx);\n\t}\n\n\treturn 1;\n}\n\n/*!\t\\brief Reads a TGA image data into buffer.\n *\tReads the image data block from a binary TGA file populating the referenced TGA structure.\n *\t\\param ctx Pointer to TGA binary file\n *\t\\param tga Pointer to TGA structure\n *\t\\return int 0 on sucess, -1 on failure\n */\nint read_image_tga( gdIOCtx *ctx, oTga *tga )\n{\n\tint pixel_block_size = (tga->bits / 8);\n\tint image_block_size = (tga->width * tga->height) * pixel_block_size;\n\tuint8_t* decompression_buffer = NULL;\n\tunsigned char* conversion_buffer = NULL;\n\tint buffer_caret = 0;\n\tint bitmap_caret = 0;\n\tint i = 0;\n\tint j = 0;\n\tuint8_t encoded_pixels;\n\n\tif(overflow2(tga->width, tga->height)) {\n\t\treturn -1;\n\t}\n\n\tif(overflow2(tga->width * tga->height, pixel_block_size)) {\n\t\treturn -1;\n\t}\n\n\tif(overflow2(image_block_size, sizeof(int))) {\n\t\treturn -1;\n\t}\n\n\t/*! \\todo Add more image type support.\n\t */\n\tif (tga->imagetype != TGA_TYPE_RGB && tga->imagetype != TGA_TYPE_RGB_RLE)\n\t\treturn -1;\n\n\t/*!\t\\brief Allocate memmory for image block\n\t *  Allocate a chunk of memory for the image block to be passed into.\n\t */\n\ttga->bitmap = (int *) gdMalloc(image_block_size * sizeof(int));\n\tif (tga->bitmap == NULL)\n\t\treturn -1;\n\n\tswitch (tga->imagetype) {\n\tcase TGA_TYPE_RGB:\n\t\t/*! \\brief Read in uncompressed RGB TGA\n\t\t *  Chunk load the pixel data from an uncompressed RGB type TGA.\n\t\t */\n\t\tconversion_buffer = (unsigned char *) gdMalloc(image_block_size * sizeof(unsigned char));\n\t\tif (conversion_buffer == NULL) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (gdGetBuf(conversion_buffer, image_block_size, ctx) != image_block_size) {\n\t\t\tgd_error(\"gd-tga: premature end of image data\\n\");\n\t\t\tgdFree(conversion_buffer);\n\t\t\treturn -1;\n\t\t}\n\n\t\twhile (buffer_caret < image_block_size) {\n\t\t\ttga->bitmap[buffer_caret] = (int) conversion_buffer[buffer_caret];\n\t\t\tbuffer_caret++;\n\t\t}\n\n\t\tgdFree(conversion_buffer);\n\t\tbreak;\n\n\tcase TGA_TYPE_RGB_RLE:\n\t\t/*! \\brief Read in RLE compressed RGB TGA\n\t\t *  Chunk load the pixel data from an RLE compressed RGB type TGA.\n\t\t */\n\t\tdecompression_buffer = (uint8_t*) gdMalloc(image_block_size * sizeof(uint8_t));\n\t\tif (decompression_buffer == NULL) {\n\t\t\treturn -1;\n\t\t}\n\t\tconversion_buffer = (unsigned char *) gdMalloc(image_block_size * sizeof(unsigned char));\n\t\tif (conversion_buffer == NULL) {\n\t\t\tgd_error(\"gd-tga: premature end of image data\\n\");\n\t\t\tgdFree( decompression_buffer );\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (gdGetBuf(conversion_buffer, image_block_size, ctx) != image_block_size) {\n\t\t\tgdFree(conversion_buffer);\n\t\t\tgdFree(decompression_buffer);\n\t\t\treturn -1;\n\t\t}\n\n\t\tbuffer_caret = 0;\n\n\t\twhile( buffer_caret < image_block_size) {\n\t\t\tdecompression_buffer[buffer_caret] = (int)conversion_buffer[buffer_caret];\n\t\t\tbuffer_caret++;\n\t\t}\n\n\t\tbuffer_caret = 0;\n\n\t\twhile( bitmap_caret < image_block_size ) {\n\n\t\t\tif ((decompression_buffer[buffer_caret] & TGA_RLE_FLAG) == TGA_RLE_FLAG) {\n\t\t\t\tencoded_pixels = ( ( decompression_buffer[ buffer_caret ] & 127 ) + 1 );\n\t\t\t\tbuffer_caret++;\n\n\t\t\t\tfor (i = 0; i < encoded_pixels; i++) {\n\t\t\t\t\tfor (j = 0; j < pixel_block_size; j++, bitmap_caret++) {\n\t\t\t\t\t\ttga->bitmap[ bitmap_caret ] = decompression_buffer[ buffer_caret + j ];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbuffer_caret += pixel_block_size;\n\t\t\t} else {\n\t\t\t\tencoded_pixels = decompression_buffer[ buffer_caret ] + 1;\n\t\t\t\tbuffer_caret++;\n\n\t\t\t\tfor (i = 0; i < encoded_pixels; i++) {\n\t\t\t\t\tfor( j = 0; j < pixel_block_size; j++, bitmap_caret++ ) {\n\t\t\t\t\t\ttga->bitmap[ bitmap_caret ] = decompression_buffer[ buffer_caret + j ];\n\t\t\t\t\t}\n\t\t\t\t\tbuffer_caret += pixel_block_size;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tgdFree( decompression_buffer );\n\t\tgdFree( conversion_buffer );\n\t\tbreak;\n\t}\n\n\treturn 1;\n}\n\n/*!\t\\brief Cleans up a TGA structure.\n *\tDereferences the bitmap referenced in a TGA structure, then the structure itself\n *\t\\param tga Pointer to TGA structure\n */\nvoid free_tga(oTga * tga)\n{\n\tif (tga) {\n\t\tif (tga->ident)\n\t\t\tgdFree(tga->ident);\n\t\tif (tga->bitmap)\n\t\t\tgdFree(tga->bitmap);\n\t\tgdFree(tga);\n\t}\n}\n", "code_before": "/**\n * File: TGA Input\n *\n * Read TGA images.\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif /* HAVE_CONFIG_H */\n\n#include <stdio.h>\n#include <stddef.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"gd_tga.h\"\n#include \"gd.h\"\n#include \"gd_errors.h\"\n#include \"gdhelpers.h\"\n\n/*\n\tFunction: gdImageCreateFromTga\n\n\tCreates a gdImage from a TGA file\n\n\tParameters:\n\n\t\tinfile - Pointer to TGA binary file\n */\nBGD_DECLARE(gdImagePtr) gdImageCreateFromTga(FILE *fp)\n{\n\tgdImagePtr image;\n\tgdIOCtx* in = gdNewFileCtx(fp);\n\tif (in == NULL) return NULL;\n\timage = gdImageCreateFromTgaCtx(in);\n\tin->gd_free( in );\n\treturn image;\n}\n\n/*\n\tFunction: gdImageCreateFromTgaPtr\n*/\nBGD_DECLARE(gdImagePtr) gdImageCreateFromTgaPtr(int size, void *data)\n{\n\tgdImagePtr im;\n\tgdIOCtx *in = gdNewDynamicCtxEx (size, data, 0);\n\tif (in == NULL) return NULL;\n\tim = gdImageCreateFromTgaCtx(in);\n\tin->gd_free(in);\n\treturn im;\n}\n\n\n/*\n\tFunction: gdImageCreateFromTgaCtx\n\n\tCreates a gdImage from a gdIOCtx referencing a TGA binary file.\n\n\tParameters:\n\t\tctx - Pointer to a gdIOCtx structure\n */\nBGD_DECLARE(gdImagePtr) gdImageCreateFromTgaCtx(gdIOCtx* ctx)\n{\n\tint bitmap_caret = 0;\n\toTga *tga = NULL;\n\t/*\tint pixel_block_size = 0;\n\t\tint image_block_size = 0; */\n\tvolatile gdImagePtr image = NULL;\n\tint x = 0;\n\tint y = 0;\n\n\ttga = (oTga *) gdMalloc(sizeof(oTga));\n\tif (!tga) {\n\t\treturn NULL;\n\t}\n\n\ttga->bitmap = NULL;\n\ttga->ident = NULL;\n\n\tif (read_header_tga(ctx, tga) < 0) {\n\t\tfree_tga(tga);\n\t\treturn NULL;\n\t}\n\n\t/*TODO: Will this be used?\n\t\tpixel_block_size = tga->bits / 8;\n\t\timage_block_size = (tga->width * tga->height) * pixel_block_size;\n\t*/\n\n\tif (read_image_tga(ctx, tga) < 0) {\n\t\tfree_tga(tga);\n\t\treturn NULL;\n\t}\n\n\timage = gdImageCreateTrueColor((int)tga->width, (int)tga->height );\n\n\tif (image == 0) {\n\t\tfree_tga( tga );\n\t\treturn NULL;\n\t}\n\n\t/*!\t\\brief Populate GD image object\n\t *  Copy the pixel data from our tga bitmap buffer into the GD image\n\t *  Disable blending and save the alpha channel per default\n\t */\n\tif (tga->alphabits) {\n\t\tgdImageAlphaBlending(image, 0);\n\t\tgdImageSaveAlpha(image, 1);\n\t}\n\n\t/* TODO: use alphabits as soon as we support 24bit and other alpha bps (ie != 8bits) */\n\tfor (y = 0; y < tga->height; y++) {\n\t\tregister int *tpix = image->tpixels[y];\n\t\tfor ( x = 0; x < tga->width; x++, tpix++) {\n\t\t\tif (tga->bits == TGA_BPP_24) {\n\t\t\t\t*tpix = gdTrueColor(tga->bitmap[bitmap_caret + 2], tga->bitmap[bitmap_caret + 1], tga->bitmap[bitmap_caret]);\n\t\t\t\tbitmap_caret += 3;\n\t\t\t} else if (tga->bits == TGA_BPP_32 && tga->alphabits) {\n\t\t\t\tregister int a = tga->bitmap[bitmap_caret + 3];\n\n\t\t\t\t*tpix = gdTrueColorAlpha(tga->bitmap[bitmap_caret + 2], tga->bitmap[bitmap_caret + 1], tga->bitmap[bitmap_caret], gdAlphaMax - (a >> 1));\n\t\t\t\tbitmap_caret += 4;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (tga->flipv && tga->fliph) {\n\t\tgdImageFlipBoth(image);\n\t} else if (tga->flipv) {\n\t\tgdImageFlipVertical(image);\n\t} else if (tga->fliph) {\n\t\tgdImageFlipHorizontal(image);\n\t}\n\n\tfree_tga(tga);\n\n\treturn image;\n}\n\n/*!\t\\brief Reads a TGA header.\n *\tReads the header block from a binary TGA file populating the referenced TGA structure.\n *\t\\param ctx Pointer to TGA binary file\n *\t\\param tga Pointer to TGA structure\n *\t\\return int 1 on sucess, -1 on failure\n */\nint read_header_tga(gdIOCtx *ctx, oTga *tga)\n{\n\n\tunsigned char header[18];\n\n\tif (gdGetBuf(header, sizeof(header), ctx) < 18) {\n\t\tgd_error(\"fail to read header\");\n\t\treturn -1;\n\t}\n\n\ttga->identsize = header[0];\n\ttga->colormaptype = header[1];\n\ttga->imagetype = header[2];\n\ttga->colormapstart = header[3] + (header[4] << 8);\n\ttga->colormaplength = header[5] + (header[6] << 8);\n\ttga->colormapbits = header[7];\n\ttga->xstart = header[8] + (header[9] << 8);\n\ttga->ystart = header[10] + (header[11] << 8);\n\ttga->width = header[12] + (header[13] << 8);\n\ttga->height = header[14] + (header[15] << 8);\n\ttga->bits = header[16];\n\ttga->alphabits = header[17] & 0x0f;\n\ttga->fliph = (header[17] & 0x10) ? 1 : 0;\n\ttga->flipv = (header[17] & 0x20) ? 0 : 1;\n\n#if DEBUG\n\tprintf(\"format bps: %i\\n\", tga->bits);\n\tprintf(\"flip h/v: %i / %i\\n\", tga->fliph, tga->flipv);\n\tprintf(\"alpha: %i\\n\", tga->alphabits);\n\tprintf(\"wxh: %i %i\\n\", tga->width, tga->height);\n#endif\n\n\tif (!((tga->bits == TGA_BPP_24 && tga->alphabits == 0)\n\t\t|| (tga->bits == TGA_BPP_32 && tga->alphabits == 8)))\n\t{\n\t\tgd_error_ex(GD_WARNING, \"gd-tga: %u bits per pixel with %u alpha bits not supported\\n\",\n\t\t\ttga->bits, tga->alphabits);\n\t\treturn -1;\n\t}\n\n\ttga->ident = NULL;\n\n\tif (tga->identsize > 0) {\n\t\ttga->ident = (char *) gdMalloc(tga->identsize * sizeof(char));\n\t\tif(tga->ident == NULL) {\n\t\t\treturn -1;\n\t\t}\n\n\t\t\n\t\tif (gdGetBuf(tga->ident, tga->identsize, ctx) != tga->identsize) {\n\t\t\tgd_error(\"fail to read header ident\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 1;\n}\n\n/*!\t\\brief Reads a TGA image data into buffer.\n *\tReads the image data block from a binary TGA file populating the referenced TGA structure.\n *\t\\param ctx Pointer to TGA binary file\n *\t\\param tga Pointer to TGA structure\n *\t\\return int 0 on sucess, -1 on failure\n */\nint read_image_tga( gdIOCtx *ctx, oTga *tga )\n{\n\tint pixel_block_size = (tga->bits / 8);\n\tint image_block_size;\n\tint* decompression_buffer = NULL;\n\tunsigned char* conversion_buffer = NULL;\n\tint buffer_caret = 0;\n\tint bitmap_caret = 0;\n\tint i = 0;\n\tint encoded_pixels;\n\tint rle_size;\n\n\tif(overflow2(tga->width, tga->height)) {\n\t\treturn -1;\n\t}\n\n\tif(overflow2(tga->width * tga->height, pixel_block_size)) {\n\t\treturn -1;\n\t}\n\n\timage_block_size = (tga->width * tga->height) * pixel_block_size;\n\tif(overflow2(image_block_size, sizeof(int))) {\n\t\treturn -1;\n\t}\n\n\t/*! \\todo Add more image type support.\n\t */\n\tif (tga->imagetype != TGA_TYPE_RGB && tga->imagetype != TGA_TYPE_RGB_RLE)\n\t\treturn -1;\n\n\t/*!\t\\brief Allocate memmory for image block\n\t *  Allocate a chunk of memory for the image block to be passed into.\n\t */\n\ttga->bitmap = (int *) gdMalloc(image_block_size * sizeof(int));\n\tif (tga->bitmap == NULL)\n\t\treturn -1;\n\n\tswitch (tga->imagetype) {\n\tcase TGA_TYPE_RGB:\n\t\t/*! \\brief Read in uncompressed RGB TGA\n\t\t *  Chunk load the pixel data from an uncompressed RGB type TGA.\n\t\t */\n\t\tconversion_buffer = (unsigned char *) gdMalloc(image_block_size * sizeof(unsigned char));\n\t\tif (conversion_buffer == NULL) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (gdGetBuf(conversion_buffer, image_block_size, ctx) != image_block_size) {\n\t\t\tgd_error(\"gd-tga: premature end of image data\\n\");\n\t\t\tgdFree(conversion_buffer);\n\t\t\treturn -1;\n\t\t}\n\n\t\twhile (buffer_caret < image_block_size) {\n\t\t\ttga->bitmap[buffer_caret] = (int) conversion_buffer[buffer_caret];\n\t\t\tbuffer_caret++;\n\t\t}\n\n\t\tgdFree(conversion_buffer);\n\t\tbreak;\n\n\tcase TGA_TYPE_RGB_RLE:\n\t\t/*! \\brief Read in RLE compressed RGB TGA\n\t\t *  Chunk load the pixel data from an RLE compressed RGB type TGA.\n\t\t */\n\t\tdecompression_buffer = (int*) gdMalloc(image_block_size * sizeof(int));\n\t\tif (decompression_buffer == NULL) {\n\t\t\treturn -1;\n\t\t}\n\t\tconversion_buffer = (unsigned char *) gdMalloc(image_block_size * sizeof(unsigned char));\n\t\tif (conversion_buffer == NULL) {\n\t\t\tgd_error(\"gd-tga: premature end of image data\\n\");\n\t\t\tgdFree( decompression_buffer );\n\t\t\treturn -1;\n\t\t}\n\n\t\trle_size = gdGetBuf(conversion_buffer, image_block_size, ctx);\n\t\tif (rle_size <= 0) {\n\t\t\tgdFree(conversion_buffer);\n\t\t\tgdFree(decompression_buffer);\n\t\t\treturn -1;\n\t\t}\n\n\t\tbuffer_caret = 0;\n\n\t\twhile( buffer_caret < rle_size) {\n\t\t\tdecompression_buffer[buffer_caret] = (int)conversion_buffer[buffer_caret];\n\t\t\tbuffer_caret++;\n\t\t}\n\n\t\tbuffer_caret = 0;\n\n\t\twhile( bitmap_caret < image_block_size ) {\n\n\t\t\tif (buffer_caret + pixel_block_size > rle_size) {\n\t\t\t\tgdFree( decompression_buffer );\n\t\t\t\tgdFree( conversion_buffer );\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif ((decompression_buffer[buffer_caret] & TGA_RLE_FLAG) == TGA_RLE_FLAG) {\n\t\t\t\tencoded_pixels = ( ( decompression_buffer[ buffer_caret ] & ~TGA_RLE_FLAG ) + 1 );\n\t\t\t\tbuffer_caret++;\n\n\t\t\t\tif ((bitmap_caret + (encoded_pixels * pixel_block_size)) > image_block_size\n\t\t\t\t\t\t|| buffer_caret + pixel_block_size > rle_size) {\n\t\t\t\t\tgdFree( decompression_buffer );\n\t\t\t\t\tgdFree( conversion_buffer );\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\tfor (i = 0; i < encoded_pixels; i++) {\n\t\t\t\t\tmemcpy(tga->bitmap + bitmap_caret, decompression_buffer + buffer_caret, pixel_block_size * sizeof(int));\n\t\t\t\t\tbitmap_caret += pixel_block_size;\n\t\t\t\t}\n\t\t\t\tbuffer_caret += pixel_block_size;\n\n\t\t\t} else {\n\t\t\t\tencoded_pixels = decompression_buffer[ buffer_caret ] + 1;\n\t\t\t\tbuffer_caret++;\n\n\t\t\t\tif ((bitmap_caret + (encoded_pixels * pixel_block_size)) > image_block_size\n\t\t\t\t\t\t|| buffer_caret + (encoded_pixels * pixel_block_size) > rle_size) {\n\t\t\t\t\tgdFree( decompression_buffer );\n\t\t\t\t\tgdFree( conversion_buffer );\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\tmemcpy(tga->bitmap + bitmap_caret, decompression_buffer + buffer_caret, encoded_pixels * pixel_block_size * sizeof(int));\n\t\t\t\tbitmap_caret += (encoded_pixels * pixel_block_size);\n\t\t\t\tbuffer_caret += (encoded_pixels * pixel_block_size);\n\t\t\t}\n\t\t}\n\t\tgdFree( decompression_buffer );\n\t\tgdFree( conversion_buffer );\n\t\tbreak;\n\t}\n\n\treturn 1;\n}\n\n/*!\t\\brief Cleans up a TGA structure.\n *\tDereferences the bitmap referenced in a TGA structure, then the structure itself\n *\t\\param tga Pointer to TGA structure\n */\nvoid free_tga(oTga * tga)\n{\n\tif (tga) {\n\t\tif (tga->ident)\n\t\t\tgdFree(tga->ident);\n\t\tif (tga->bitmap)\n\t\t\tgdFree(tga->bitmap);\n\t\tgdFree(tga);\n\t}\n}\n", "patch": "@@ -99,7 +99,7 @@ BGD_DECLARE(gdImagePtr) gdImageCreateFromTgaCtx(gdIOCtx* ctx)\n \t\t\tif (tga->bits == TGA_BPP_24) {\n \t\t\t\t*tpix = gdTrueColor(tga->bitmap[bitmap_caret + 2], tga->bitmap[bitmap_caret + 1], tga->bitmap[bitmap_caret]);\n \t\t\t\tbitmap_caret += 3;\n-\t\t\t} else if (tga->bits == TGA_BPP_32 || tga->alphabits) {\n+\t\t\t} else if (tga->bits == TGA_BPP_32 && tga->alphabits) {\n \t\t\t\tregister int a = tga->bitmap[bitmap_caret + 3];\n \n \t\t\t\t*tpix = gdTrueColorAlpha(tga->bitmap[bitmap_caret + 2], tga->bitmap[bitmap_caret + 1], tga->bitmap[bitmap_caret], gdAlphaMax - (a >> 1));\n@@ -159,16 +159,12 @@ int read_header_tga(gdIOCtx *ctx, oTga *tga)\n \tprintf(\"wxh: %i %i\\n\", tga->width, tga->height);\n #endif\n \n-\tswitch(tga->bits) {\n-\tcase 8:\n-\tcase 16:\n-\tcase 24:\n-\tcase 32:\n-\t\tbreak;\n-\tdefault:\n-\t\tgd_error(\"bps %i not supported\", tga->bits);\n+\tif (!((tga->bits == TGA_BPP_24 && tga->alphabits == 0)\n+\t\t|| (tga->bits == TGA_BPP_32 && tga->alphabits == 8)))\n+\t{\n+\t\tgd_error_ex(GD_WARNING, \"gd-tga: %u bits per pixel with %u alpha bits not supported\\n\",\n+\t\t\ttga->bits, tga->alphabits);\n \t\treturn -1;\n-\t\tbreak;\n \t}\n \n \ttga->ident = NULL;", "file_path": "files/2016_8\\34", "file_language": "c", "file_name": "src/gd_tga.c", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}, {"raw_url": "https://github.com/libgd/libgd/raw/10ef1dca63d62433fda13309b4a228782db823f7/tests/tga/.gitignore", "code": "/bug00084\n/bug00247\n/bug00247a\n/tga_null\n", "code_before": "/bug00084\n/bug00247\n/bug00247a\n/bug00248\n/bug00248a\n/tga_null\n/tga_read\n", "patch": "@@ -1,3 +1,4 @@\n /bug00084\n /bug00247\n+/bug00247a\n /tga_null", "file_path": "files/2016_8\\35", "file_language": "gitignore", "file_name": "tests/tga/.gitignore", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}, {"raw_url": "https://github.com/libgd/libgd/raw/10ef1dca63d62433fda13309b4a228782db823f7/tests/tga/CMakeLists.txt", "code": "LIST(APPEND TESTS_FILES\n\ttga_null\n\tbug00084\n\tbug00247\n\tbug00247a\n)\n\nADD_GD_TESTS()\n", "code_before": "LIST(APPEND TESTS_FILES\n\ttga_null\n\tbug00084\n\tbug00247\n\tbug00247a\n\tbug00248\n\tbug00248a\n\theap_overflow\n\ttga_read\n)\n\nADD_GD_TESTS()\n", "patch": "@@ -2,6 +2,7 @@ LIST(APPEND TESTS_FILES\n \ttga_null\n \tbug00084\n \tbug00247\n+\tbug00247a\n )\n \n ADD_GD_TESTS()", "file_path": "files/2016_8\\36", "file_language": "txt", "file_name": "tests/tga/CMakeLists.txt", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}, {"raw_url": "https://github.com/libgd/libgd/raw/10ef1dca63d62433fda13309b4a228782db823f7/tests/tga/Makemodule.am", "code": "libgd_test_programs += \\\n\ttga/bug00084 \\\n\ttga/bug00247 \\\n\ttag/bug00247a \\\n\ttga/tga_null\n\nEXTRA_DIST += \\\n\ttga/CMakeLists.txt \\\n\ttga/bug00084.tga \\\n\ttga/bug00247.tga \\\n\ttga/bug00247a.tga\n", "code_before": "libgd_test_programs += \\\n\ttga/bug00084 \\\n\ttga/bug00247 \\\n\ttga/bug00247a \\\n\ttga/bug00248 \\\n\ttga/bug00248a \\\n\ttga/heap_overflow \\\n\ttga/tga_null \\\n\ttga/tga_read\n\nEXTRA_DIST += \\\n\ttga/CMakeLists.txt \\\n\ttga/bug00084.tga \\\n\ttga/bug00247.tga \\\n\ttga/bug00247a.tga \\\n\ttga/bug00248.tga \\\n\ttga/bug00248a.tga \\\n\ttga/heap_overflow_1.tga \\\n\ttga/heap_overflow_2.tga \\\n\ttga/tga_read_rgb.png \\\n\ttga/tga_read_rgb.tga \\\n\ttga/tga_read_rgb_rle.tga\n", "patch": "@@ -1,9 +1,11 @@\n libgd_test_programs += \\\n \ttga/bug00084 \\\n \ttga/bug00247 \\\n+\ttag/bug00247a \\\n \ttga/tga_null\n \n EXTRA_DIST += \\\n \ttga/CMakeLists.txt \\\n \ttga/bug00084.tga \\\n-\ttga/bug00247.tga\n+\ttga/bug00247.tga \\\n+\ttga/bug00247a.tga", "file_path": "files/2016_8\\37", "file_language": "am", "file_name": "tests/tga/Makemodule.am", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}, {"raw_url": "https://github.com/libgd/libgd/raw/10ef1dca63d62433fda13309b4a228782db823f7/tests/tga/bug00247a.c", "code": "/*\nWe test that a 8bpp TGA file will be gracefully rejected by\ngdImageCreateFromTga().\n*/\n\n#include <stdio.h>\n\n#include \"gd.h\"\n#include \"gdtest.h\"\n\nint main(int argc, char **argv)\n{\n    gdImagePtr im;\n    FILE *fp = gdTestFileOpen(\"tga/bug00247a.tga\");\n    im = gdImageCreateFromTga(fp);\n    gdTestAssert(im == NULL);\n    fclose(fp);\n    return gdNumFailures();\n}\n", "code_before": "/*\nWe test that a 8bpp TGA file will be gracefully rejected by\ngdImageCreateFromTga().\n*/\n\n#include <stdio.h>\n\n#include \"gd.h\"\n#include \"gdtest.h\"\n\nint main(int argc, char **argv)\n{\n    gdImagePtr im;\n    FILE *fp = gdTestFileOpen(\"tga/bug00247a.tga\");\n    im = gdImageCreateFromTga(fp);\n    gdTestAssert(im == NULL);\n    fclose(fp);\n    return gdNumFailures();\n}\n", "patch": "@@ -0,0 +1,19 @@\n+/*\n+We test that a 8bpp TGA file will be gracefully rejected by\n+gdImageCreateFromTga().\n+*/\n+\n+#include <stdio.h>\n+\n+#include \"gd.h\"\n+#include \"gdtest.h\"\n+\n+int main(int argc, char **argv)\n+{\n+    gdImagePtr im;\n+    FILE *fp = gdTestFileOpen(\"tga/bug00247a.tga\");\n+    im = gdImageCreateFromTga(fp);\n+    gdTestAssert(im == NULL);\n+    fclose(fp);\n+    return gdNumFailures();\n+}", "file_path": "files/2016_8\\38", "file_language": "c", "file_name": "tests/tga/bug00247a.c", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}], "outdated": 0}
{"index": 22, "cve_id": "CVE-2016-6128", "cwe_id": ["CWE-20"], "cve_language": "C", "cve_description": "The gdImageCropThreshold function in gd_crop.c in the GD Graphics Library (aka libgd) before 2.2.3, as used in PHP before 7.0.9, allows remote attackers to cause a denial of service (application crash) via an invalid color index.", "cvss": "7.5", "publish_date": "August 7, 2016", "AV": "NETWORK", "AC": "LOW", "PR": "NONE", "UI": "NONE", "S": "UNCHANGED", "C": "NONE", "I": "NONE", "A": "HIGH", "commit_id": "6ff72ae40c7c20ece939afb362d98cc37f4a1c96", "commit_message": "fix php 72494, invalid color index not handled, can lead to crash", "commit_date": "2016-06-27T04:42:44Z", "project": "libgd/libgd", "url": "https://api.github.com/repos/libgd/libgd/commits/6ff72ae40c7c20ece939afb362d98cc37f4a1c96", "html_url": "https://github.com/libgd/libgd/commit/6ff72ae40c7c20ece939afb362d98cc37f4a1c96", "windows_before": "", "windows_after": "", "parents": [{"commit_id_before": "bca12e4e11ecda8a0ea719472700ad5c2b36a0d6", "url_before": "https://api.github.com/repos/libgd/libgd/commits/bca12e4e11ecda8a0ea719472700ad5c2b36a0d6", "html_url_before": "https://github.com/libgd/libgd/commit/bca12e4e11ecda8a0ea719472700ad5c2b36a0d6"}], "details": [{"raw_url": "https://github.com/libgd/libgd/raw/6ff72ae40c7c20ece939afb362d98cc37f4a1c96/tests/gdimagecrop/php_bug_72494.c", "code": "#include <stdio.h>\n#include <stdlib.h>\n#include \"gd.h\"\n\n#include \"gdtest.h\"\n\nint main()\n{\n\tgdImagePtr im, exp;\n\tint error = 0;\n\n\tim = gdImageCreate(50, 50);\n\n\tif (!im) {\n\t\tgdTestErrorMsg(\"gdImageCreate failed.\\n\");\n\t\treturn 1;\n\t}\n\n\tgdImageCropThreshold(im, 1337, 0);\n\tgdImageDestroy(im);\n\t/* this bug tests a crash, it never reaches this point if the bug exists*/\n\treturn 0;\n}\n", "code_before": "#include <stdio.h>\n#include <stdlib.h>\n#include \"gd.h\"\n\n#include \"gdtest.h\"\n\nint main()\n{\n\tgdImagePtr im;\n\tint error = 0;\n\n\tim = gdImageCreate(50, 50);\n\n\tif (!im) {\n\t\tgdTestErrorMsg(\"gdImageCreate failed.\\n\");\n\t\treturn 1;\n\t}\n\n\tgdImageCropThreshold(im, 1337, 0);\n\tgdImageDestroy(im);\n\t/* this bug tests a crash, it never reaches this point if the bug exists*/\n\treturn 0;\n}\n", "patch": "@@ -0,0 +1,23 @@\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include \"gd.h\"\n+\n+#include \"gdtest.h\"\n+\n+int main()\n+{\n+\tgdImagePtr im, exp;\n+\tint error = 0;\n+\n+\tim = gdImageCreate(50, 50);\n+\n+\tif (!im) {\n+\t\tgdTestErrorMsg(\"gdImageCreate failed.\\n\");\n+\t\treturn 1;\n+\t}\n+\n+\tgdImageCropThreshold(im, 1337, 0);\n+\tgdImageDestroy(im);\n+\t/* this bug tests a crash, it never reaches this point if the bug exists*/\n+\treturn 0;\n+}", "file_path": "files/2016_8\\63", "file_language": "c", "file_name": "tests/gdimagecrop/php_bug_72494.c", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}], "outdated": 0}
{"index": 23, "cve_id": "CVE-2016-6128", "cwe_id": ["CWE-20"], "cve_language": "C", "cve_description": "The gdImageCropThreshold function in gd_crop.c in the GD Graphics Library (aka libgd) before 2.2.3, as used in PHP before 7.0.9, allows remote attackers to cause a denial of service (application crash) via an invalid color index.", "cvss": "7.5", "publish_date": "August 7, 2016", "AV": "NETWORK", "AC": "LOW", "PR": "NONE", "UI": "NONE", "S": "UNCHANGED", "C": "NONE", "I": "NONE", "A": "HIGH", "commit_id": "1ccfe21e14c4d18336f9da8515cd17db88c3de61", "commit_message": "fix php 72494, invalid color index not handled, can lead to crash", "commit_date": "2016-06-27T04:41:40Z", "project": "libgd/libgd", "url": "https://api.github.com/repos/libgd/libgd/commits/1ccfe21e14c4d18336f9da8515cd17db88c3de61", "html_url": "https://github.com/libgd/libgd/commit/1ccfe21e14c4d18336f9da8515cd17db88c3de61", "windows_before": "", "windows_after": "", "parents": [{"commit_id_before": "3fe0a7128bac5000fdcfab888bd2a75ec0c9447d", "url_before": "https://api.github.com/repos/libgd/libgd/commits/3fe0a7128bac5000fdcfab888bd2a75ec0c9447d", "html_url_before": "https://github.com/libgd/libgd/commit/3fe0a7128bac5000fdcfab888bd2a75ec0c9447d"}], "details": [{"raw_url": "https://github.com/libgd/libgd/raw/1ccfe21e14c4d18336f9da8515cd17db88c3de61/src/gd_crop.c", "code": "/* Crop support\n * manual crop using a gdRect or automatic crop using a background\n * color (automatic detections or using either the transparent color,\n * black or white).\n * An alternative method allows to crop using a given color and a\n * threshold. It works relatively well but it can be improved.\n * Maybe L*a*b* and Delta-E will give better results (and a better\n * granularity).\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <stdlib.h>\n#include \"gd.h\"\n#include \"gd_color.h\"\n\nstatic int gdGuessBackgroundColorFromCorners(gdImagePtr im, int *color);\n\nBGD_DECLARE(gdImagePtr) gdImageCrop(gdImagePtr src, const gdRect *crop)\n{\n\tgdImagePtr dst;\n\n\tdst = gdImageCreateTrueColor(crop->width, crop->height);\n\tif (!dst) return NULL;\n\tgdImageCopy(dst, src, 0, 0, crop->x, crop->y, crop->width, crop->height);\n\n\treturn dst;\n}\n\nBGD_DECLARE(gdImagePtr) gdImageCropAuto(gdImagePtr im, const unsigned int mode)\n{\n\tconst int width = gdImageSX(im);\n\tconst int height = gdImageSY(im);\n\n\tint x,y;\n\tint color, match;\n\tgdRect crop;\n\n\tcrop.x = 0;\n\tcrop.y = 0;\n\tcrop.width = 0;\n\tcrop.height = 0;\n\n\tswitch (mode) {\n\tcase GD_CROP_TRANSPARENT:\n\t\tcolor = gdImageGetTransparent(im);\n\t\tbreak;\n\n\tcase GD_CROP_BLACK:\n\t\tcolor = gdImageColorClosestAlpha(im, 0, 0, 0, 0);\n\t\tbreak;\n\n\tcase GD_CROP_WHITE:\n\t\tcolor = gdImageColorClosestAlpha(im, 255, 255, 255, 0);\n\t\tbreak;\n\n\tcase GD_CROP_SIDES:\n\t\tgdGuessBackgroundColorFromCorners(im, &color);\n\t\tbreak;\n\n\tcase GD_CROP_DEFAULT:\n\tdefault:\n\t\tcolor = gdImageGetTransparent(im);\n\t\tbreak;\n\t}\n\n\t/* TODO: Add gdImageGetRowPtr and works with ptr at the row level\n\t * for the true color and palette images\n\t * new formats will simply work with ptr\n\t */\n\tmatch = 1;\n\tfor (y = 0; match && y < height; y++) {\n\t\tfor (x = 0; match && x < width; x++) {\n\t\t\tmatch = (color == gdImageGetPixel(im, x,y));\n\t\t}\n\t}\n\n\t/* Nothing to do > bye\n\t * Duplicate the image?\n\t */\n\tif (y == height - 1) {\n\t\treturn NULL;\n\t}\n\n\tcrop.y = y -1;\n\tmatch = 1;\n\tfor (y = height - 1; match && y >= 0; y--) {\n\t\tfor (x = 0; match && x < width; x++) {\n\t\t\tmatch = (color == gdImageGetPixel(im, x,y));\n\t\t}\n\t}\n\n\tif (y == 0) {\n\t\tcrop.height = height - crop.y + 1;\n\t} else {\n\t\tcrop.height = y - crop.y + 2;\n\t}\n\n\tmatch = 1;\n\tfor (x = 0; match && x < width; x++) {\n\t\tfor (y = 0; match && y < crop.y + crop.height - 1; y++) {\n\t\t\tmatch = (color == gdImageGetPixel(im, x,y));\n\t\t}\n\t}\n\tcrop.x = x - 1;\n\n\tmatch = 1;\n\tfor (x = width - 1; match && x >= 0; x--) {\n\t\tfor (y = 0; match &&  y < crop.y + crop.height - 1; y++) {\n\t\t\tmatch = (color == gdImageGetPixel(im, x,y));\n\t\t}\n\t}\n\tcrop.width = x - crop.x + 2;\n\n\treturn gdImageCrop(im, &crop);\n}\n\nBGD_DECLARE(gdImagePtr) gdImageCropThreshold(gdImagePtr im, const unsigned int color, const float threshold)\n{\n\tconst int width = gdImageSX(im);\n\tconst int height = gdImageSY(im);\n\n\tint x,y;\n\tint match;\n\tgdRect crop;\n\n\tcrop.x = 0;\n\tcrop.y = 0;\n\tcrop.width = 0;\n\tcrop.height = 0;\n\n\t/* Pierre: crop everything sounds bad */\n\tif (threshold > 100.0) {\n\t\treturn NULL;\n\t}\n\n\tif (color < 0 || (!gdImageTrueColor(im) && color >= gdImageColorsTotal(im))) {\n\t\treturn NULL;\n\t}\n\n\t/* TODO: Add gdImageGetRowPtr and works with ptr at the row level\n\t * for the true color and palette images\n\t * new formats will simply work with ptr\n\t */\n\tmatch = 1;\n\tfor (y = 0; match && y < height; y++) {\n\t\tfor (x = 0; match && x < width; x++) {\n\t\t\tmatch = (gdColorMatch(im, color, gdImageGetPixel(im, x,y), threshold)) > 0;\n\t\t}\n\t}\n\n\t/* Pierre\n\t * Nothing to do > bye\n\t * Duplicate the image?\n\t */\n\tif (y == height - 1) {\n\t\treturn NULL;\n\t}\n\n\tcrop.y = y -1;\n\tmatch = 1;\n\tfor (y = height - 1; match && y >= 0; y--) {\n\t\tfor (x = 0; match && x < width; x++) {\n\t\t\tmatch = (gdColorMatch(im, color, gdImageGetPixel(im, x, y), threshold)) > 0;\n\t\t}\n\t}\n\n\tif (y == 0) {\n\t\tcrop.height = height - crop.y + 1;\n\t} else {\n\t\tcrop.height = y - crop.y + 2;\n\t}\n\n\tmatch = 1;\n\tfor (x = 0; match && x < width; x++) {\n\t\tfor (y = 0; match && y < crop.y + crop.height - 1; y++) {\n\t\t\tmatch = (gdColorMatch(im, color, gdImageGetPixel(im, x,y), threshold)) > 0;\n\t\t}\n\t}\n\tcrop.x = x - 1;\n\n\tmatch = 1;\n\tfor (x = width - 1; match && x >= 0; x--) {\n\t\tfor (y = 0; match &&  y < crop.y + crop.height - 1; y++) {\n\t\t\tmatch = (gdColorMatch(im, color, gdImageGetPixel(im, x,y), threshold)) > 0;\n\t\t}\n\t}\n\tcrop.width = x - crop.x + 2;\n\n\treturn gdImageCrop(im, &crop);\n}\n\n/* This algorithm comes from pnmcrop (http://netpbm.sourceforge.net/)\n * Three steps:\n *  - if 3 corners are equal.\n *  - if two are equal.\n *  - Last solution: average the colors\n */\nstatic int gdGuessBackgroundColorFromCorners(gdImagePtr im, int *color)\n{\n\tconst int tl = gdImageGetPixel(im, 0, 0);\n\tconst int tr = gdImageGetPixel(im, gdImageSX(im) - 1, 0);\n\tconst int bl = gdImageGetPixel(im, 0, gdImageSY(im) -1);\n\tconst int br = gdImageGetPixel(im, gdImageSX(im) - 1, gdImageSY(im) -1);\n\n\tif (tr == bl && tr == br) {\n\t\t*color = tr;\n\t\treturn 3;\n\t} else if (tl == bl && tl == br) {\n\t\t*color = tl;\n\t\treturn 3;\n\t} else if (tl == tr &&  tl == br) {\n\t\t*color = tl;\n\t\treturn 3;\n\t} else if (tl == tr &&  tl == bl) {\n\t\t*color = tl;\n\t\treturn 3;\n\t} else if (tl == tr  || tl == bl || tl == br) {\n\t\t*color = tl;\n\t\treturn 2;\n\t} else if (tr == bl) {\n\t\t*color = tr;\n\t\treturn 2;\n\t} else if (br == bl) {\n\t\t*color = bl;\n\t\treturn 2;\n\t} else {\n\t\tregister int r,b,g,a;\n\n\t\tr = (int)(0.5f + (gdImageRed(im, tl) + gdImageRed(im, tr) + gdImageRed(im, bl) + gdImageRed(im, br)) / 4);\n\t\tg = (int)(0.5f + (gdImageGreen(im, tl) + gdImageGreen(im, tr) + gdImageGreen(im, bl) + gdImageGreen(im, br)) / 4);\n\t\tb = (int)(0.5f + (gdImageBlue(im, tl) + gdImageBlue(im, tr) + gdImageBlue(im, bl) + gdImageBlue(im, br)) / 4);\n\t\ta = (int)(0.5f + (gdImageAlpha(im, tl) + gdImageAlpha(im, tr) + gdImageAlpha(im, bl) + gdImageAlpha(im, br)) / 4);\n\t\t*color = gdImageColorClosestAlpha(im, r, g, b, a);\n\t\treturn 0;\n\t}\n}\n", "code_before": "/**\n * File: Cropping\n *\n * Crop an image\n *\n * Some functions to crop images, automatically (auto detection of the border\n * color), using a given color (with or without tolerance) or using a given\n * rectangle.\n *\n * Example:\n *   (start code)\n *   im2 = gdImageAutoCrop(im, GD_CROP_SIDES);\n *   if (im2) {\n *       gdImageDestroy(im); // unless you need the original image subsequently\n *       // do something with the cropped image\n *   }\n *   gdImageDestroy(im2);\n *   (end code)\n */\n\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <stdlib.h>\n#include \"gd.h\"\n#include \"gd_color.h\"\n\nstatic int gdGuessBackgroundColorFromCorners(gdImagePtr im, int *color);\n\n/**\n * Function: gdImageCrop\n *\n * Crop an image to a given rectangle\n *\n * Parameters:\n *   src  - The image.\n *   crop - The cropping rectangle, see <gdRect>.\n *\n * Returns:\n *   The newly created cropped image, or NULL on failure.\n *\n * See also:\n *   - <gdImageCropAuto>\n *   - <gdImageCropThreshold>\n */\nBGD_DECLARE(gdImagePtr) gdImageCrop(gdImagePtr src, const gdRect *crop)\n{\n\tgdImagePtr dst;\n\tint alphaBlendingFlag;\n\n\tif (gdImageTrueColor(src)) {\n\t\tdst = gdImageCreateTrueColor(crop->width, crop->height);\n\t} else {\n\t\tdst = gdImageCreate(crop->width, crop->height);\n\t}\n\tif (!dst) return NULL;\n\talphaBlendingFlag = dst->alphaBlendingFlag;\n\tgdImageAlphaBlending(dst, gdEffectReplace);\n\tgdImageCopy(dst, src, 0, 0, crop->x, crop->y, crop->width, crop->height);\n\tgdImageAlphaBlending(dst, alphaBlendingFlag);\n\n\treturn dst;\n}\n\n/**\n * Function: gdImageCropAuto\n *\n * Crop an image automatically\n *\n * This function detects the cropping area according to the given _mode_.\n *\n * Parameters:\n *   im   - The image.\n *   mode - The cropping mode, see <gdCropMode>.\n *\n * Returns:\n *   The newly created cropped image, or NULL on failure.\n *\n * See also:\n *   - <gdImageCrop>\n *   - <gdImageCropThreshold>\n */\nBGD_DECLARE(gdImagePtr) gdImageCropAuto(gdImagePtr im, const unsigned int mode)\n{\n\tconst int width = gdImageSX(im);\n\tconst int height = gdImageSY(im);\n\n\tint x,y;\n\tint color, match;\n\tgdRect crop;\n\n\tcrop.x = 0;\n\tcrop.y = 0;\n\tcrop.width = 0;\n\tcrop.height = 0;\n\n\tswitch (mode) {\n\tcase GD_CROP_TRANSPARENT:\n\t\tcolor = gdImageGetTransparent(im);\n\t\tbreak;\n\n\tcase GD_CROP_BLACK:\n\t\tcolor = gdImageColorClosestAlpha(im, 0, 0, 0, 0);\n\t\tbreak;\n\n\tcase GD_CROP_WHITE:\n\t\tcolor = gdImageColorClosestAlpha(im, 255, 255, 255, 0);\n\t\tbreak;\n\n\tcase GD_CROP_SIDES:\n\t\tgdGuessBackgroundColorFromCorners(im, &color);\n\t\tbreak;\n\n\tcase GD_CROP_DEFAULT:\n\tdefault:\n\t\tcolor = gdImageGetTransparent(im);\n\t\tbreak;\n\t}\n\n\t/* TODO: Add gdImageGetRowPtr and works with ptr at the row level\n\t * for the true color and palette images\n\t * new formats will simply work with ptr\n\t */\n\tmatch = 1;\n\tfor (y = 0; match && y < height; y++) {\n\t\tfor (x = 0; match && x < width; x++) {\n\t\t\tmatch = (color == gdImageGetPixel(im, x,y));\n\t\t}\n\t}\n\n\t/* Whole image would be cropped > bye */\n\tif (match) {\n\t\treturn NULL;\n\t}\n\n\tcrop.y = y - 1;\n\n\tmatch = 1;\n\tfor (y = height - 1; match && y >= 0; y--) {\n\t\tfor (x = 0; match && x < width; x++) {\n\t\t\tmatch = (color == gdImageGetPixel(im, x,y));\n\t\t}\n\t}\n\tcrop.height = y - crop.y + 2;\n\n\tmatch = 1;\n\tfor (x = 0; match && x < width; x++) {\n\t\tfor (y = crop.y; match && y < crop.y + crop.height; y++) {\n\t\t\tmatch = (color == gdImageGetPixel(im, x,y));\n\t\t}\n\t}\n\tcrop.x = x - 1;\n\n\tmatch = 1;\n\tfor (x = width - 1; match && x >= 0; x--) {\n\t\tfor (y = crop.y; match &&  y < crop.y + crop.height; y++) {\n\t\t\tmatch = (color == gdImageGetPixel(im, x,y));\n\t\t}\n\t}\n\tcrop.width = x - crop.x + 2;\n\n\treturn gdImageCrop(im, &crop);\n}\n\n/**\n * Function: gdImageCropThreshold\n *\n * Crop an image using a given color\n *\n * The _threshold_ defines the tolerance to be used while comparing the image\n * color and the color to crop. The method used to calculate the color\n * difference is based on the color distance in the RGB(A) cube.\n *\n * Parameters:\n *   im        - The image.\n *   color     - The crop color.\n *   threshold - The crop threshold.\n *\n * Returns:\n *   The newly created cropped image, or NULL on failure.\n *\n * See also:\n *   - <gdImageCrop>\n *   - <gdImageCropAuto>\n */\nBGD_DECLARE(gdImagePtr) gdImageCropThreshold(gdImagePtr im, const unsigned int color, const float threshold)\n{\n\tconst int width = gdImageSX(im);\n\tconst int height = gdImageSY(im);\n\n\tint x,y;\n\tint match;\n\tgdRect crop;\n\n\tcrop.x = 0;\n\tcrop.y = 0;\n\tcrop.width = 0;\n\tcrop.height = 0;\n\n\t/* Pierre: crop everything sounds bad */\n\tif (threshold > 100.0) {\n\t\treturn NULL;\n\t}\n\n\tif (!gdImageTrueColor(im) && color >= gdImageColorsTotal(im)) {\n\t\treturn NULL;\n\t}\n\n\t/* TODO: Add gdImageGetRowPtr and works with ptr at the row level\n\t * for the true color and palette images\n\t * new formats will simply work with ptr\n\t */\n\tmatch = 1;\n\tfor (y = 0; match && y < height; y++) {\n\t\tfor (x = 0; match && x < width; x++) {\n\t\t\tmatch = (gdColorMatch(im, color, gdImageGetPixel(im, x,y), threshold)) > 0;\n\t\t}\n\t}\n\n\t/* Whole image would be cropped > bye */\n\tif (match) {\n\t\treturn NULL;\n\t}\n\n\tcrop.y = y - 1;\n\n\tmatch = 1;\n\tfor (y = height - 1; match && y >= 0; y--) {\n\t\tfor (x = 0; match && x < width; x++) {\n\t\t\tmatch = (gdColorMatch(im, color, gdImageGetPixel(im, x, y), threshold)) > 0;\n\t\t}\n\t}\n\tcrop.height = y - crop.y + 2;\n\n\tmatch = 1;\n\tfor (x = 0; match && x < width; x++) {\n\t\tfor (y = crop.y; match && y < crop.y + crop.height; y++) {\n\t\t\tmatch = (gdColorMatch(im, color, gdImageGetPixel(im, x,y), threshold)) > 0;\n\t\t}\n\t}\n\tcrop.x = x - 1;\n\n\tmatch = 1;\n\tfor (x = width - 1; match && x >= 0; x--) {\n\t\tfor (y = crop.y; match &&  y < crop.y + crop.height; y++) {\n\t\t\tmatch = (gdColorMatch(im, color, gdImageGetPixel(im, x,y), threshold)) > 0;\n\t\t}\n\t}\n\tcrop.width = x - crop.x + 2;\n\n\treturn gdImageCrop(im, &crop);\n}\n\n/* This algorithm comes from pnmcrop (http://netpbm.sourceforge.net/)\n * Three steps:\n *  - if 3 corners are equal.\n *  - if two are equal.\n *  - Last solution: average the colors\n */\nstatic int gdGuessBackgroundColorFromCorners(gdImagePtr im, int *color)\n{\n\tconst int tl = gdImageGetPixel(im, 0, 0);\n\tconst int tr = gdImageGetPixel(im, gdImageSX(im) - 1, 0);\n\tconst int bl = gdImageGetPixel(im, 0, gdImageSY(im) -1);\n\tconst int br = gdImageGetPixel(im, gdImageSX(im) - 1, gdImageSY(im) -1);\n\n\tif (tr == bl && tr == br) {\n\t\t*color = tr;\n\t\treturn 3;\n\t} else if (tl == bl && tl == br) {\n\t\t*color = tl;\n\t\treturn 3;\n\t} else if (tl == tr &&  tl == br) {\n\t\t*color = tl;\n\t\treturn 3;\n\t} else if (tl == tr &&  tl == bl) {\n\t\t*color = tl;\n\t\treturn 3;\n\t} else if (tl == tr  || tl == bl || tl == br) {\n\t\t*color = tl;\n\t\treturn 2;\n\t} else if (tr == bl || tr == br) {\n\t\t*color = tr;\n\t\treturn 2;\n\t} else if (br == bl) {\n\t\t*color = bl;\n\t\treturn 2;\n\t} else {\n\t\tregister int r,b,g,a;\n\n\t\tr = (2 + gdImageRed(im, tl) + gdImageRed(im, tr) + gdImageRed(im, bl) + gdImageRed(im, br)) / 4;\n\t\tg = (2 + gdImageGreen(im, tl) + gdImageGreen(im, tr) + gdImageGreen(im, bl) + gdImageGreen(im, br)) / 4;\n\t\tb = (2 + gdImageBlue(im, tl) + gdImageBlue(im, tr) + gdImageBlue(im, bl) + gdImageBlue(im, br)) / 4;\n\t\ta = (2 + gdImageAlpha(im, tl) + gdImageAlpha(im, tr) + gdImageAlpha(im, bl) + gdImageAlpha(im, br)) / 4;\n\t\t*color = gdImageColorClosestAlpha(im, r, g, b, a);\n\t\treturn 0;\n\t}\n}\n", "patch": "@@ -136,6 +136,10 @@ BGD_DECLARE(gdImagePtr) gdImageCropThreshold(gdImagePtr im, const unsigned int c\n \t\treturn NULL;\n \t}\n \n+\tif (color < 0 || (!gdImageTrueColor(im) && color >= gdImageColorsTotal(im))) {\n+\t\treturn NULL;\n+\t}\n+\n \t/* TODO: Add gdImageGetRowPtr and works with ptr at the row level\n \t * for the true color and palette images\n \t * new formats will simply work with ptr", "file_path": "files/2016_8\\64", "file_language": "c", "file_name": "src/gd_crop.c", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}, {"raw_url": "https://github.com/libgd/libgd/raw/1ccfe21e14c4d18336f9da8515cd17db88c3de61/tests/CMakeLists.txt", "code": "\nif (BUILD_TEST)\n\tSET(DART_TESTING_TIMEOUT 5)\n\n\tINCLUDE(Dart)\n\n\tset(GDTEST_SOURCE_DIR ${GD_SOURCE_DIR}/tests/gdtest)\n\n\tIF (ENABLE_GCOV AND CMAKE_COMPILER_IS_GNUCC)\n\t\tSET(CMAKE_BUILD_TYPE TESTINGGCOV)\n\t\tSET(CMAKE_CXX_FLAGS_TESTINGGCOV \"-g3 -O0\")\n\t\tSET(CMAKE_C_FLAGS_TESTINGGCOV \"-g3 -O0\")\n\tendif (ENABLE_GCOV AND CMAKE_COMPILER_IS_GNUCC)\n\n\tmessage(STATUS \"gd include dir: ${GD_INCLUDE_DIR}\" )\n\tmessage(STATUS \"gd libs dir: ${GD_LIBS_DIR}\" )\n\n\tinclude_directories (BEFORE ${GD_INCLUDE_DIR} \"${GDTEST_SOURCE_DIR}\" \"${CMAKE_BINARY_DIR}\" \"${CMAKE_BINARY_DIR}/tests/gdtest\")\n\n\tSET(TESTS_DIRS\n\t\tbmp\n\t\tfreetype\n\t\tgd\n\t\tgd2\n\t\tgdimagearc\n\t\tgdimagecolorclosest\n\t\tgdimagecolordeallocate\n\t\tgdimagecolorexact\n\t\tgdimagecolorreplace\n\t\tgdimagecolorresolve\n\t\tgdimagecolortransparent\n\t\tgdimagecopy\n\t\tgdimagecopyrotated\n        gdimagecrop\n\t\tgdimagefile\n\t\tgdimagefill\n\t\tgdimagefilledellipse\n\t\tgdimagefilledpolygon\n\t\tgdimagefilledrectangle\n\t\tgdimagefilltoborder\n\t\tgdimagefilter\n\t\tgdimageline\n\t\tgdimageopenpolygon\n\t\tgdimagepixelate\n\t\tgdimagepolygon\n\t\tgdimagerectangle\n\t\tgdimagerotate\n\t\tgdimagescale\n\t\tgdimagescatterex\n\t\tgdimagesetpixel\n\t\tgdimagestringft\n\t\tgdimagestringftex\n\t\tgdinterpolatedscale\n\t\tgdnewfilectx\n\t\tgdtest\n\t\tgdtiled\n\t\tgdtransformaffineboundingbox\n\t\tgif\n\t\tjpeg\n\t\tpng\n\t\ttga\n\t\ttiff\n\t\twbmp\n\t\twebp\n\t\txbm\n\t\txpm\n\t)\n\n\tFOREACH(test_dir ${TESTS_DIRS})\n\t\tadd_subdirectory (${test_dir})\n\tENDFOREACH(test_dir)\n\nendif (BUILD_TEST)\n", "code_before": "if (BUILD_TEST)\n\tSET(DART_TESTING_TIMEOUT 15)\n\n\tINCLUDE(Dart)\n\n\tset(GDTEST_SOURCE_DIR ${GD_SOURCE_DIR}/tests/gdtest)\n\n\tIF (ENABLE_GCOV AND CMAKE_COMPILER_IS_GNUCC)\n\t\tSET(CMAKE_BUILD_TYPE TESTINGGCOV)\n\t\tSET(CMAKE_CXX_FLAGS_TESTINGGCOV \"-g3 -O0\")\n\t\tSET(CMAKE_C_FLAGS_TESTINGGCOV \"-g3 -O0\")\n\tendif (ENABLE_GCOV AND CMAKE_COMPILER_IS_GNUCC)\n\n\tmessage(STATUS \"gd include dir: ${GD_INCLUDE_DIR}\" )\n\tmessage(STATUS \"gd libs dir: ${GD_LIBS_DIR}\" )\n\n\tinclude_directories (BEFORE ${GD_INCLUDE_DIR} \"${GDTEST_SOURCE_DIR}\" \"${CMAKE_BINARY_DIR}\" \"${CMAKE_BINARY_DIR}/tests/gdtest\")\n\n\tSET(TESTS_DIRS\n\t\tavif\n\t\tbmp\n\t\tfontconfig\n\t\tfreetype\n\t\tgd\n\t\tgd2\n\t\tgdcolormaplookup\n\t\tgdimagearc\n\t\tgdimagebrightness\n\t\tgdimageclone\n\t\tgdimagecolor\n\t\tgdimagecolorclosest\n\t\tgdimagecolorclosesthwb\n\t\tgdimagecolordeallocate\n\t\tgdimagecolorexact\n\t\tgdimagecolormatch\n\t\tgdimagecolorreplace\n\t\tgdimagecolorresolve\n\t\tgdimagecolortransparent\n\t\tgdimagecompare\n\t\tgdimagecontrast\n\t\tgdimageconvolution\n\t\tgdimagecopy\n\t\tgdimagecopymerge\n\t\tgdimagecopymergegray\n\t\tgdimagecopyresampled\n\t\tgdimagecopyresized\n\t\tgdimagecopyrotated\n\t\tgdimagecreate\n\t\tgdimagecrop\n\t\tgdimagefile\n\t\tgdimagefill\n\t\tgdimagefilledarc\n\t\tgdimagefilledellipse\n\t\tgdimagefilledpolygon\n\t\tgdimagefilledrectangle\n\t\tgdimagefilltoborder\n\t\tgdimagefilter\n\t\tgdimageflip\n\t\tgdimageellipse\n\t\tgdimagegrayscale\n\t\tgdimageline\n\t\tgdimagenegate\n\t\tgdimageopenpolygon\n\t\tgdimagepixelate\n\t\tgdimagepolygon\n\t\tgdimagerectangle\n\t\tgdimagerotate\n\t\tgdimagescale\n\t\tgdimagescatterex\n\t\tgdimagesetinterpolationmethod\n\t\tgdimagesetpixel\n\t\tgdimagesquaretocircle\n\t\tgdimagestring\n\t\tgdimagestring16\n\t\tgdimagestringft\n\t\tgdimagestringftex\n\t\tgdimagestringup\n\t\tgdimagestringup16\n\t\tgdimagetruecolortopalette\n\t\tgdinterpolatedscale\n\t\tgdmatrix\n\t\tgdnewfilectx\n\t\tgdtest\n\t\tgdtiled\n\t\tgdtransformaffineboundingbox\n\t\tgdtransformaffinecopy\n\t\tgif\n\t\theif\n\t\tjpeg\n\t\tpng\n\t\ttga\n\t\ttiff\n\t\twbmp\n\t\twebp\n\t\txbm\n\t\txpm\n\t)\n\n\tFOREACH(test_dir ${TESTS_DIRS})\n\t\tadd_subdirectory (${test_dir})\n\tENDFOREACH(test_dir)\nendif (BUILD_TEST)\n", "patch": "@@ -31,6 +31,7 @@ if (BUILD_TEST)\n \t\tgdimagecolortransparent\n \t\tgdimagecopy\n \t\tgdimagecopyrotated\n+        gdimagecrop\n \t\tgdimagefile\n \t\tgdimagefill\n \t\tgdimagefilledellipse", "file_path": "files/2016_8\\65", "file_language": "txt", "file_name": "tests/CMakeLists.txt", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}, {"raw_url": "https://github.com/libgd/libgd/raw/1ccfe21e14c4d18336f9da8515cd17db88c3de61/tests/Makefile.am", "code": "check_LIBRARIES = libgdtest.a\n\nlibgdtest_a_SOURCES = \\\n\tgdtest/gdtest.c \\\n\tgdtest/gdtest.h \\\n\tgdhelpers.c\n\n# Setup vars that subdirs will increment.\nlibgd_test_programs =\nlibgd_helper_programs =\nCLEANFILES =\nEXTRA_DIST =\nTESTS =\n\ninclude bmp/Makemodule.am\ninclude freetype/Makemodule.am\ninclude gd/Makemodule.am\ninclude gd2/Makemodule.am\ninclude gdimagearc/Makemodule.am\ninclude gdimagecolorclosest/Makemodule.am\ninclude gdimagecolordeallocate/Makemodule.am\ninclude gdimagecolorexact/Makemodule.am\ninclude gdimagecolorreplace/Makemodule.am\ninclude gdimagecolorresolve/Makemodule.am\ninclude gdimagecolortransparent/Makemodule.am\ninclude gdimagecopy/Makemodule.am\ninclude gdimagecopyrotated/Makemodule.am\ninclude gdimagecrop/Makemodule.am\ninclude gdimagefile/Makemodule.am\ninclude gdimagefill/Makemodule.am\ninclude gdimagefilledellipse/Makemodule.am\ninclude gdimagefilledpolygon/Makemodule.am\ninclude gdimagefilledrectangle/Makemodule.am\ninclude gdimagefilltoborder/Makemodule.am\ninclude gdimagefilter/Makemodule.am\ninclude gdimageline/Makemodule.am\ninclude gdimageopenpolygon/Makemodule.am\ninclude gdimagepixelate/Makemodule.am\ninclude gdimagepolygon/Makemodule.am\ninclude gdimagerectangle/Makemodule.am\ninclude gdimagerotate/Makemodule.am\ninclude gdimagescale/Makemodule.am\ninclude gdimagescatterex/Makemodule.am\ninclude gdimagesetpixel/Makemodule.am\ninclude gdimagestringft/Makemodule.am\ninclude gdimagestringftex/Makemodule.am\ninclude gdinterpolatedscale/Makemodule.am\ninclude gdnewfilectx/Makemodule.am\ninclude gdtest/Makemodule.am\ninclude gdtiled/Makemodule.am\ninclude gdtransformaffineboundingbox/Makemodule.am\ninclude gif/Makemodule.am\ninclude jpeg/Makemodule.am\ninclude png/Makemodule.am\ninclude tga/Makemodule.am\ninclude tiff/Makemodule.am\ninclude wbmp/Makemodule.am\ninclude webp/Makemodule.am\ninclude xbm/Makemodule.am\ninclude xpm/Makemodule.am\n\nLDADD = libgdtest.a ../src/libgd.la\nAM_CPPFLAGS = -I$(top_srcdir)/src -I $(top_srcdir)/tests/gdtest\n\ncheck_PROGRAMS = $(libgd_test_programs) $(libgd_helper_programs)\nTESTS += $(libgd_test_programs)\n\nEXTRA_DIST += \\\n\tCMakeLists.txt\n\n# We don't keep any media files in the top dir ... just generated outputs.\nCLEANFILES += \\\n\t*.bmp \\\n\t*.gd \\\n\t*.gd2 \\\n\t*.gif \\\n\t*.jpeg \\\n\t*.jpg \\\n\t*.png \\\n\t*.tga \\\n\t*.tiff \\\n\t*.ttf \\\n\t*.wbmp \\\n\t*.webp \\\n\t*.xbm \\\n\t*.xpm\n", "code_before": "check_LIBRARIES = libgdtest.a\n\nlibgdtest_a_SOURCES = \\\n\tgdtest/gdtest.c \\\n\tgdtest/gdtest.h \\\n\tgdhelpers.c\nlibgdtest_a_CPPFLAGS = $(AM_CPPFLAGS) -DGDTEST_TOP_DIR='\"$(srcdir)\"'\n\n# Setup vars that subdirs will increment.\nlibgd_test_programs =\nlibgd_helper_programs =\nCLEANFILES =\nEXTRA_DIST =\nTESTS =\n\ninclude avif/Makemodule.am\ninclude bmp/Makemodule.am\ninclude fontconfig/Makemodule.am\ninclude freetype/Makemodule.am\ninclude gd/Makemodule.am\ninclude gd2/Makemodule.am\ninclude gdcolormaplookup/Makemodule.am\ninclude gdimagearc/Makemodule.am\ninclude gdimagebrightness/Makemodule.am\ninclude gdimageclone/Makemodule.am\ninclude gdimagecolor/Makemodule.am\ninclude gdimagecolorclosest/Makemodule.am\ninclude gdimagecolorclosesthwb/Makemodule.am\ninclude gdimagecolordeallocate/Makemodule.am\ninclude gdimagecolorexact/Makemodule.am\ninclude gdimagecolormatch/Makemodule.am\ninclude gdimagecolorreplace/Makemodule.am\ninclude gdimagecolorresolve/Makemodule.am\ninclude gdimagecolortransparent/Makemodule.am\ninclude gdimagecompare/Makemodule.am\ninclude gdimagecontrast/Makemodule.am\ninclude gdimageconvolution/Makemodule.am\ninclude gdimagecopy/Makemodule.am\ninclude gdimagecopymerge/Makemodule.am\ninclude gdimagecopymergegray/Makemodule.am\ninclude gdimagecopyresampled/Makemodule.am\ninclude gdimagecopyresized/Makemodule.am\ninclude gdimagecopyrotated/Makemodule.am\ninclude gdimagecreate/Makemodule.am\ninclude gdimagecrop/Makemodule.am\ninclude gdimagefile/Makemodule.am\ninclude gdimagefill/Makemodule.am\ninclude gdimagefilledarc/Makemodule.am\ninclude gdimagefilledellipse/Makemodule.am\ninclude gdimagefilledpolygon/Makemodule.am\ninclude gdimagefilledrectangle/Makemodule.am\ninclude gdimagefilltoborder/Makemodule.am\ninclude gdimagefilter/Makemodule.am\ninclude gdimageflip/Makemodule.am\ninclude gdimageellipse/Makemodule.am\ninclude gdimagegrayscale/Makemodule.am\ninclude gdimageline/Makemodule.am\ninclude gdimagenegate/Makemodule.am\ninclude gdimageopenpolygon/Makemodule.am\ninclude gdimagepixelate/Makemodule.am\ninclude gdimagepolygon/Makemodule.am\ninclude gdimagerectangle/Makemodule.am\ninclude gdimagerotate/Makemodule.am\ninclude gdimagescale/Makemodule.am\ninclude gdimagescatterex/Makemodule.am\ninclude gdimagesetinterpolationmethod/Makemodule.am\ninclude gdimagesetpixel/Makemodule.am\ninclude gdimagesquaretocircle/Makemodule.am\ninclude gdimagestring/Makemodule.am\ninclude gdimagestring16/Makemodule.am\ninclude gdimagestringft/Makemodule.am\ninclude gdimagestringftex/Makemodule.am\ninclude gdimagestringup/Makemodule.am\ninclude gdimagestringup16/Makemodule.am\ninclude gdimagetruecolortopalette/Makemodule.am\ninclude gdinterpolatedscale/Makemodule.am\ninclude gdnewfilectx/Makemodule.am\ninclude gdtest/Makemodule.am\ninclude gdtiled/Makemodule.am\ninclude gdtransformaffineboundingbox/Makemodule.am\ninclude gdtransformaffinecopy/Makemodule.am\ninclude gif/Makemodule.am\ninclude heif/Makemodule.am\ninclude jpeg/Makemodule.am\ninclude png/Makemodule.am\ninclude tga/Makemodule.am\ninclude tiff/Makemodule.am\ninclude wbmp/Makemodule.am\ninclude webp/Makemodule.am\ninclude xbm/Makemodule.am\ninclude xpm/Makemodule.am\n\nLDADD = libgdtest.a ../src/libgd.la\nAM_CPPFLAGS = -I$(top_srcdir)/src -I$(top_srcdir)/tests/gdtest\n\ncheck_PROGRAMS = $(libgd_test_programs) $(libgd_helper_programs)\nTESTS += $(libgd_test_programs)\n\nEXTRA_DIST += \\\n\tCMakeLists.txt\n\n# We don't keep any media files in the top dir ... just generated outputs.\nCLEANFILES += \\\n\t*.avif \\\n\t*.bmp \\\n\t*.gd \\\n\t*.gd2 \\\n\t*.gif \\\n\t*.heif \\\n\t*.jpeg \\\n\t*.jpg \\\n\t*.png \\\n\t*.tga \\\n\t*.tiff \\\n\t*.ttf \\\n\t*.wbmp \\\n\t*.webp \\\n\t*.xbm \\\n\t*.xpm\n", "patch": "@@ -25,6 +25,7 @@ include gdimagecolorresolve/Makemodule.am\n include gdimagecolortransparent/Makemodule.am\n include gdimagecopy/Makemodule.am\n include gdimagecopyrotated/Makemodule.am\n+include gdimagecrop/Makemodule.am\n include gdimagefile/Makemodule.am\n include gdimagefill/Makemodule.am\n include gdimagefilledellipse/Makemodule.am", "file_path": "files/2016_8\\66", "file_language": "am", "file_name": "tests/Makefile.am", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}], "outdated": 0}
{"index": 25, "cve_id": "CVE-2013-7456", "cwe_id": ["CWE-125"], "cve_language": "C", "cve_description": "gd_interpolation.c in the GD Graphics Library (aka libgd) before 2.1.1, as used in PHP before 5.5.36, 5.6.x before 5.6.22, and 7.x before 7.0.7, allows remote attackers to cause a denial of service (out-of-bounds read) or possibly have unspecified other impact via a crafted image that is mishandled by the imagescale function.", "cvss": "7.6", "publish_date": "August 7, 2016", "AV": "NETWORK", "AC": "LOW", "PR": "NONE", "UI": "REQUIRED", "S": "UNCHANGED", "C": "LOW", "I": "LOW", "A": "HIGH", "commit_id": "4f65a3e4eedaffa1efcf9ee1eb08f0b504fbc31a", "commit_message": "Fixed memory overrun bug in gdImageScaleTwoPass\n\n_gdContributionsCalc would compute a window size and then adjust\nthe left and right positions of the window to make a window within\nthat size.  However, it was storing the values in the struct *before*\nit made the adjustment.  This change fixes that.", "commit_date": "2013-09-23T22:03:08Z", "project": "libgd/libgd", "url": "https://api.github.com/repos/libgd/libgd/commits/4f65a3e4eedaffa1efcf9ee1eb08f0b504fbc31a", "html_url": "https://github.com/libgd/libgd/commit/4f65a3e4eedaffa1efcf9ee1eb08f0b504fbc31a", "windows_before": "", "windows_after": "", "parents": [{"commit_id_before": "3e76d309d00f15944da974287b058556c55b1748", "url_before": "https://api.github.com/repos/libgd/libgd/commits/3e76d309d00f15944da974287b058556c55b1748", "html_url_before": "https://github.com/libgd/libgd/commit/3e76d309d00f15944da974287b058556c55b1748"}], "details": [{"raw_url": "https://github.com/libgd/libgd/raw/4f65a3e4eedaffa1efcf9ee1eb08f0b504fbc31a/src/gd_interpolation.c", "code": "/*\n * The two pass scaling function is based on:\n * Filtered Image Rescaling\n * Based on Gems III\n *  - Schumacher general filtered image rescaling\n * (pp. 414-424)\n * by Dale Schumacher\n *\n * \tAdditional changes by Ray Gardener, Daylon Graphics Ltd.\n * \tDecember 4, 1999\n *\n * \tPorted to libgd by Pierre Joye. Support for multiple channels\n * \tadded (argb for now).\n *\n * \tInitial sources code is avaibable in the Gems Source Code Packages:\n * \thttp://www.acm.org/pubs/tog/GraphicsGems/GGemsIII.tar.gz\n *\n */\n\n/*\n\tSummary:\n\n\t\t- Horizontal filter contributions are calculated on the fly,\n\t\t  as each column is mapped from src to dst image. This lets\n\t\t  us omit having to allocate a temporary full horizontal stretch\n\t\t  of the src image.\n\n\t\t- If none of the src pixels within a sampling region differ,\n\t\t  then the output pixel is forced to equal (any of) the source pixel.\n\t\t  This ensures that filters do not corrupt areas of constant color.\n\n\t\t- Filter weight contribution results, after summing, are\n\t\t  rounded to the nearest pixel color value instead of\n\t\t  being casted to ILubyte (usually an int or char). Otherwise,\n\t\t  artifacting occurs.\n\n*/\n\n/*\n\tAdditional functions are available for simple rotation or up/downscaling.\n\tdownscaling using the fixed point implementations are usually much faster\n\tthan the existing gdImageCopyResampled while having a similar or better\n\tquality.\n\t\n\tFor image rotations, the optimized versions have a lazy antialiasing for \n\tthe edges of the images. For a much better antialiased result, the affine\n\tfunction is recommended.\n*/\n\n/*\nTODO:\n - Optimize pixel accesses and loops once we have continuous buffer\n - Add scale support for a portion only of an image (equivalent of copyresized/resampled)\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif /* HAVE_CONFIG_H */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n\n#include \"gd.h\"\n#include \"gdhelpers.h\"\n\n#ifdef _MSC_VER\n# pragma optimize(\"t\", on)\n# include <emmintrin.h>\n#endif\n\n#ifndef MIN\n#define MIN(a,b) ((a)<(b)?(a):(b))\n#endif\n#define MIN3(a,b,c) ((a)<(b)?(MIN(a,c)):(MIN(b,c)))\n#ifndef MAX\n#define MAX(a,b) ((a)<(b)?(b):(a))\n#endif\n#define MAX3(a,b,c) ((a)<(b)?(MAX(b,c)):(MAX(a,c)))\n\n#define CLAMP(x, low, high)  (((x) > (high)) ? (high) : (((x) < (low)) ? (low) : (x)))\n\n/* only used here, let do a generic fixed point integers later if required by other\n   part of GD */\ntypedef long gdFixed;\n/* Integer to fixed point */\n#define gd_itofx(x) ((x) << 8)\n\n/* Float to fixed point */\n#define gd_ftofx(x) (long)((x) * 256)\n\n/*  Double to fixed point */\n#define gd_dtofx(x) (long)((x) * 256)\n\n/* Fixed point to integer */\n#define gd_fxtoi(x) ((x) >> 8)\n\n/* Fixed point to float */\n# define gd_fxtof(x) ((float)(x) / 256)\n\n/* Fixed point to double */\n#define gd_fxtod(x) ((double)(x) / 256)\n\n/* Multiply a fixed by a fixed */\n#define gd_mulfx(x,y) (((x) * (y)) >> 8)\n\n/* Divide a fixed by a fixed */\n#define gd_divfx(x,y) (((x) << 8) / (y))\n\ntypedef struct\n{\n\tdouble *Weights;  /* Normalized weights of neighboring pixels */\n\tint Left,Right;   /* Bounds of source pixels window */\n} ContributionType;  /* Contirbution information for a single pixel */\n\ntypedef struct\n{\n\tContributionType *ContribRow; /* Row (or column) of contribution weights */\n\tunsigned int WindowSize,      /* Filter window size (of affecting source pixels) */\n\t\t     LineLength;      /* Length of line (no. or rows / cols) */\n} LineContribType;\n\n/* Each core filter has its own radius */\n#define DEFAULT_FILTER_BICUBIC\t\t\t\t3.0\n#define DEFAULT_FILTER_BOX\t\t\t\t\t0.5\n#define DEFAULT_FILTER_GENERALIZED_CUBIC\t0.5\n#define DEFAULT_FILTER_RADIUS\t\t\t\t1.0\n#define DEFAULT_LANCZOS8_RADIUS\t\t\t\t8.0\n#define DEFAULT_LANCZOS3_RADIUS\t\t\t\t3.0\n#define DEFAULT_HERMITE_RADIUS\t\t\t\t1.0\n#define DEFAULT_BOX_RADIUS\t\t\t\t\t0.5\n#define DEFAULT_TRIANGLE_RADIUS\t\t\t\t1.0\n#define DEFAULT_BELL_RADIUS\t\t\t\t\t1.5\n#define DEFAULT_CUBICSPLINE_RADIUS\t\t\t2.0\n#define DEFAULT_MITCHELL_RADIUS\t\t\t\t2.0\n#define DEFAULT_COSINE_RADIUS\t\t\t\t1.0\n#define DEFAULT_CATMULLROM_RADIUS\t\t\t2.0\n#define DEFAULT_QUADRATIC_RADIUS\t\t\t1.5\n#define DEFAULT_QUADRATICBSPLINE_RADIUS\t\t1.5\n#define DEFAULT_CUBICCONVOLUTION_RADIUS\t\t3.0\n#define DEFAULT_GAUSSIAN_RADIUS\t\t\t\t1.0\n#define DEFAULT_HANNING_RADIUS\t\t\t\t1.0\n#define DEFAULT_HAMMING_RADIUS\t\t\t\t1.0\n#define DEFAULT_SINC_RADIUS\t\t\t\t\t1.0\n#define DEFAULT_WELSH_RADIUS\t\t\t\t1.0\n\nenum GD_RESIZE_FILTER_TYPE{\n\tFILTER_DEFAULT          = 0,\n\tFILTER_BELL,\n\tFILTER_BESSEL,\n\tFILTER_BLACKMAN,\n\tFILTER_BOX,\n\tFILTER_BSPLINE,\n\tFILTER_CATMULLROM,\n\tFILTER_COSINE,\n\tFILTER_CUBICCONVOLUTION,\n\tFILTER_CUBICSPLINE,\n\tFILTER_HERMITE,\n\tFILTER_LANCZOS3,\n\tFILTER_LANCZOS8,\n\tFILTER_MITCHELL,\n\tFILTER_QUADRATIC,\n\tFILTER_QUADRATICBSPLINE,\n\tFILTER_TRIANGLE,\n\tFILTER_GAUSSIAN,\n\tFILTER_HANNING,\n\tFILTER_HAMMING,\n\tFILTER_SINC,\n\tFILTER_WELSH,\n\n\tFILTER_CALLBACK        = 999\n};\n\ntypedef enum GD_RESIZE_FILTER_TYPE gdResizeFilterType;\n\nstatic double KernelBessel_J1(const double x)\n{\n\tdouble p, q;\n\n\tregister long i;\n\n\tstatic const double\n\tPone[] =\n\t{\n\t\t0.581199354001606143928050809e+21,\n\t\t-0.6672106568924916298020941484e+20,\n\t\t0.2316433580634002297931815435e+19,\n\t\t-0.3588817569910106050743641413e+17,\n\t\t0.2908795263834775409737601689e+15,\n\t\t-0.1322983480332126453125473247e+13,\n\t\t0.3413234182301700539091292655e+10,\n\t\t-0.4695753530642995859767162166e+7,\n\t\t0.270112271089232341485679099e+4\n\t},\n\tQone[] =\n\t{\n\t\t0.11623987080032122878585294e+22,\n\t\t0.1185770712190320999837113348e+20,\n\t\t0.6092061398917521746105196863e+17,\n\t\t0.2081661221307607351240184229e+15,\n\t\t0.5243710262167649715406728642e+12,\n\t\t0.1013863514358673989967045588e+10,\n\t\t0.1501793594998585505921097578e+7,\n\t\t0.1606931573481487801970916749e+4,\n\t\t0.1e+1\n\t};\n\n\tp = Pone[8];\n\tq = Qone[8];\n\tfor (i=7; i >= 0; i--)\n\t{\n\t\tp = p*x*x+Pone[i];\n\t\tq = q*x*x+Qone[i];\n\t}\n\treturn (double)(p/q);\n}\n\nstatic double KernelBessel_P1(const double x)\n{\n\tdouble p, q;\n\n\tregister long i;\n\n\tstatic const double\n\tPone[] =\n\t{\n\t\t0.352246649133679798341724373e+5,\n\t\t0.62758845247161281269005675e+5,\n\t\t0.313539631109159574238669888e+5,\n\t\t0.49854832060594338434500455e+4,\n\t\t0.2111529182853962382105718e+3,\n\t\t0.12571716929145341558495e+1\n\t},\n\tQone[] =\n\t{\n\t\t0.352246649133679798068390431e+5,\n\t\t0.626943469593560511888833731e+5,\n\t\t0.312404063819041039923015703e+5,\n\t\t0.4930396490181088979386097e+4,\n\t\t0.2030775189134759322293574e+3,\n\t\t0.1e+1\n\t};\n\n\tp = Pone[5];\n\tq = Qone[5];\n\tfor (i=4; i >= 0; i--)\n\t{\n\t\tp = p*(8.0/x)*(8.0/x)+Pone[i];\n\t\tq = q*(8.0/x)*(8.0/x)+Qone[i];\n\t}\n\treturn (double)(p/q);\n}\n\nstatic double KernelBessel_Q1(const double x)\n{\n\tdouble p, q;\n\n\tregister long i;\n\n\tstatic const double\n\tPone[] =\n\t{\n\t\t0.3511751914303552822533318e+3,\n\t\t0.7210391804904475039280863e+3,\n\t\t0.4259873011654442389886993e+3,\n\t\t0.831898957673850827325226e+2,\n\t\t0.45681716295512267064405e+1,\n\t\t0.3532840052740123642735e-1\n\t},\n\tQone[] =\n\t{\n\t\t0.74917374171809127714519505e+4,\n\t\t0.154141773392650970499848051e+5,\n\t\t0.91522317015169922705904727e+4,\n\t\t0.18111867005523513506724158e+4,\n\t\t0.1038187585462133728776636e+3,\n\t\t0.1e+1\n\t};\n\n\tp = Pone[5];\n\tq = Qone[5];\n\tfor (i=4; i >= 0; i--)\n\t{\n\t\tp = p*(8.0/x)*(8.0/x)+Pone[i];\n\t\tq = q*(8.0/x)*(8.0/x)+Qone[i];\n\t}\n\treturn (double)(p/q);\n}\n\nstatic double KernelBessel_Order1(double x)\n{\n\tdouble p, q;\n\t\n\tif (x == 0.0)\n\t\treturn (0.0f);\n\tp = x;\n\tif (x < 0.0)\n\t\tx=(-x);\n\tif (x < 8.0)\n\t\treturn (p*KernelBessel_J1(x));\n\tq = (double)sqrt(2.0f/(M_PI*x))*(double)(KernelBessel_P1(x)*(1.0f/sqrt(2.0f)*(sin(x)-cos(x)))-8.0f/x*KernelBessel_Q1(x)*\n\t\t(-1.0f/sqrt(2.0f)*(sin(x)+cos(x))));\n\tif (p < 0.0f)\n\t\tq = (-q);\n\treturn (q);\n}\n\nstatic double filter_bessel(const double x)\n{\n\tif (x == 0.0f)\n\t\treturn (double)(M_PI/4.0f);\n\treturn (KernelBessel_Order1((double)M_PI*x)/(2.0f*x));\n}\n\n\nstatic double filter_blackman(const double x)\n{\n\treturn (0.42f+0.5f*(double)cos(M_PI*x)+0.08f*(double)cos(2.0f*M_PI*x));\n}\n\n/**\n * Bicubic interpolation kernel (a=-1):\n  \\verbatim\n          /\n         | 1-2|t|**2+|t|**3          , if |t| < 1\n  h(t) = | 4-8|t|+5|t|**2-|t|**3     , if 1<=|t|<2\n         | 0                         , otherwise\n          \\\n  \\endverbatim\n * ***bd*** 2.2004\n */\nstatic double filter_bicubic(const double t)\n{\n\tconst double abs_t = (double)fabs(t);\n\tconst double abs_t_sq = abs_t * abs_t;\n\tif (abs_t<1) return 1-2*abs_t_sq+abs_t_sq*abs_t;\n\tif (abs_t<2) return 4 - 8*abs_t +5*abs_t_sq - abs_t_sq*abs_t;\n\treturn 0;\n}\n\n/**\n * Generalized cubic kernel (for a=-1 it is the same as BicubicKernel):\n  \\verbatim\n          /\n         | (a+2)|t|**3 - (a+3)|t|**2 + 1     , |t| <= 1\n  h(t) = | a|t|**3 - 5a|t|**2 + 8a|t| - 4a   , 1 < |t| <= 2\n         | 0                                 , otherwise\n          \\\n  \\endverbatim\n * Often used values for a are -1 and -1/2.\n */\nstatic double filter_generalized_cubic(const double t)\n{\n\tconst double a = -DEFAULT_FILTER_GENERALIZED_CUBIC;\n\tdouble abs_t = (double)fabs(t);\n\tdouble abs_t_sq = abs_t * abs_t;\n\tif (abs_t < 1) return (a + 2) * abs_t_sq * abs_t - (a + 3) * abs_t_sq + 1;\n\tif (abs_t < 2) return a * abs_t_sq * abs_t - 5 * a * abs_t_sq + 8 * a * abs_t - 4 * a;\n\treturn 0;\n}\n\n#ifdef FUNCTION_NOT_USED_YET\n/* CubicSpline filter, default radius 2 */\nstatic double filter_cubic_spline(const double x1)\n{\n\tconst double x = x1 < 0.0 ? -x1 : x1;\n\n\tif (x < 1.0 ) {\n\t\tconst double x2 = x*x;\n\n\t\treturn (0.5 * x2 * x - x2 + 2.0 / 3.0);\n\t}\n\tif (x < 2.0) {\n\t\treturn (pow(2.0 - x, 3.0)/6.0);\n\t}\n\treturn 0;\n}\n#endif\n\n#ifdef FUNCTION_NOT_USED_YET\n/* CubicConvolution filter, default radius 3 */\nstatic double filter_cubic_convolution(const double x1)\n{\n\tconst double x = x1 < 0.0 ? -x1 : x1;\n\tconst double x2 = x1 * x1;\n\tconst double x2_x = x2 * x;\n\n\tif (x <= 1.0) return ((4.0 / 3.0)* x2_x - (7.0 / 3.0) * x2 + 1.0);\n\tif (x <= 2.0) return (- (7.0 / 12.0) * x2_x + 3 * x2 - (59.0 / 12.0) * x + 2.5);\n\tif (x <= 3.0) return ( (1.0/12.0) * x2_x - (2.0 / 3.0) * x2 + 1.75 * x - 1.5);\n\treturn 0;\n}\n#endif\n\nstatic double filter_box(double x) {\n\tif (x < - DEFAULT_FILTER_BOX)\n\t\treturn 0.0f;\n\tif (x < DEFAULT_FILTER_BOX)\n\t\treturn 1.0f;\n\treturn 0.0f;\n}\n\nstatic double filter_catmullrom(const double x)\n{\n\tif (x < -2.0)\n\t\treturn(0.0f);\n\tif (x < -1.0)\n\t\treturn(0.5f*(4.0f+x*(8.0f+x*(5.0f+x))));\n\tif (x < 0.0)\n\t\treturn(0.5f*(2.0f+x*x*(-5.0f-3.0f*x)));\n\tif (x < 1.0)\n\t\treturn(0.5f*(2.0f+x*x*(-5.0f+3.0f*x)));\n\tif (x < 2.0)\n\t\treturn(0.5f*(4.0f+x*(-8.0f+x*(5.0f-x))));\n\treturn(0.0f);\n}\n\n#ifdef FUNCTION_NOT_USED_YET\nstatic double filter_filter(double t)\n{\n\t/* f(t) = 2|t|^3 - 3|t|^2 + 1, -1 <= t <= 1 */\n\tif(t < 0.0) t = -t;\n\tif(t < 1.0) return((2.0 * t - 3.0) * t * t + 1.0);\n\treturn(0.0);\n}\n#endif\n\n#ifdef FUNCTION_NOT_USED_YET\n/* Lanczos8 filter, default radius 8 */\nstatic double filter_lanczos8(const double x1)\n{\n\tconst double x = x1 < 0.0 ? -x1 : x1;\n#define R DEFAULT_LANCZOS8_RADIUS\n\n\tif ( x == 0.0) return 1;\n\n\tif ( x < R) {\n\t\treturn R * sin(x*M_PI) * sin(x * M_PI/ R) / (x * M_PI * x * M_PI);\n\t}\n\treturn 0.0;\n#undef R\n}\n#endif\n\n#ifdef FUNCTION_NOT_USED_YET\n/* Lanczos3 filter, default radius 3 */\nstatic double filter_lanczos3(const double x1)\n{\n\tconst double x = x1 < 0.0 ? -x1 : x1;\n#define R DEFAULT_LANCZOS3_RADIUS\n\n\tif ( x == 0.0) return 1;\n\n\tif ( x < R)\n\t{\n\t\treturn R * sin(x*M_PI) * sin(x * M_PI / R) / (x * M_PI * x * M_PI);\n\t}\n\treturn 0.0;\n#undef R\n}\n#endif\n\n/* Hermite filter, default radius 1 */\nstatic double filter_hermite(const double x1)\n{\n\tconst double x = x1 < 0.0 ? -x1 : x1;\n\n\tif (x < 1.0) return ((2.0 * x - 3) * x * x + 1.0 );\n\n\treturn 0.0;\n}\n\n/* Trangle filter, default radius 1 */\nstatic double filter_triangle(const double x1)\n{\n\tconst double x = x1 < 0.0 ? -x1 : x1;\n\tif (x < 1.0) return (1.0 - x);\n\treturn 0.0;\n}\n\n/* Bell filter, default radius 1.5 */\nstatic double filter_bell(const double x1)\n{\n\tconst double x = x1 < 0.0 ? -x1 : x1;\n\n\tif (x < 0.5) return (0.75 - x*x);\n\tif (x < 1.5) return (0.5 * pow(x - 1.5, 2.0));\n\treturn 0.0;\n}\n\n/* Mitchell filter, default radius 2.0 */\nstatic double filter_mitchell(const double x)\n{\n#define KM_B (1.0f/3.0f)\n#define KM_C (1.0f/3.0f)\n#define KM_P0 ((  6.0f - 2.0f * KM_B ) / 6.0f)\n#define KM_P2 ((-18.0f + 12.0f * KM_B + 6.0f * KM_C) / 6.0f)\n#define KM_P3 (( 12.0f - 9.0f  * KM_B - 6.0f * KM_C) / 6.0f)\n#define KM_Q0 ((  8.0f * KM_B + 24.0f * KM_C) / 6.0f)\n#define KM_Q1 ((-12.0f * KM_B - 48.0f * KM_C) / 6.0f)\n#define KM_Q2 ((  6.0f * KM_B + 30.0f * KM_C) / 6.0f)\n#define KM_Q3 (( -1.0f * KM_B -  6.0f * KM_C) / 6.0f)\n\n\tif (x < -2.0)\n\t\treturn(0.0f);\n\tif (x < -1.0)\n\t\treturn(KM_Q0-x*(KM_Q1-x*(KM_Q2-x*KM_Q3)));\n\tif (x < 0.0f)\n\t\treturn(KM_P0+x*x*(KM_P2-x*KM_P3));\n\tif (x < 1.0f)\n\t\treturn(KM_P0+x*x*(KM_P2+x*KM_P3));\n\tif (x < 2.0f)\n\t\treturn(KM_Q0+x*(KM_Q1+x*(KM_Q2+x*KM_Q3)));\n\treturn(0.0f);\n}\n\n\n\n#ifdef FUNCTION_NOT_USED_YET\n/* Cosine filter, default radius 1 */\nstatic double filter_cosine(const double x)\n{\n\tif ((x >= -1.0) && (x <= 1.0)) return ((cos(x * M_PI) + 1.0)/2.0);\n\n\treturn 0;\n}\n#endif\n\n/* Quadratic filter, default radius 1.5 */\nstatic double filter_quadratic(const double x1)\n{\n\tconst double x = x1 < 0.0 ? -x1 : x1;\n\n\tif (x <= 0.5) return (- 2.0 * x * x + 1);\n\tif (x <= 1.5) return (x * x - 2.5* x + 1.5);\n\treturn 0.0;\n}\n\nstatic double filter_bspline(const double x)\n{\n\tif (x>2.0f) {\n\t\treturn 0.0f;\n\t} else {\n\t\tdouble a, b, c, d;\n\t\t/* Was calculated anyway cause the \"if((x-1.0f) < 0)\" */\n\t\tconst double xm1 = x - 1.0f;\n\t\tconst double xp1 = x + 1.0f;\n\t\tconst double xp2 = x + 2.0f;\n\n\t\tif ((xp2) <= 0.0f) a = 0.0f; else a = xp2*xp2*xp2;\n\t\tif ((xp1) <= 0.0f) b = 0.0f; else b = xp1*xp1*xp1;\n\t\tif (x <= 0) c = 0.0f; else c = x*x*x;\n\t\tif ((xm1) <= 0.0f) d = 0.0f; else d = xm1*xm1*xm1;\n\n\t\treturn (0.16666666666666666667f * (a - (4.0f * b) + (6.0f * c) - (4.0f * d)));\n\t}\n}\n\n#ifdef FUNCTION_NOT_USED_YET\n/* QuadraticBSpline filter, default radius 1.5 */\nstatic double filter_quadratic_bspline(const double x1)\n{\n\tconst double x = x1 < 0.0 ? -x1 : x1;\n\n\tif (x <= 0.5) return (- x * x + 0.75);\n\tif (x <= 1.5) return (0.5 * x * x - 1.5 * x + 1.125);\n\treturn 0.0;\n}\n#endif\n\nstatic double filter_gaussian(const double x)\n{\n\t/* return(exp((double) (-2.0 * x * x)) * sqrt(2.0 / M_PI)); */\n\treturn (double)(exp(-2.0f * x * x) * 0.79788456080287f);\n}\n\nstatic double filter_hanning(const double x)\n{\n\t/* A Cosine windowing function */\n\treturn(0.5 + 0.5 * cos(M_PI * x));\n}\n\nstatic double filter_hamming(const double x)\n{\n\t/* should be\n\t(0.54+0.46*cos(M_PI*(double) x));\n\tbut this approximation is sufficient */\n\tif (x < -1.0f)\n\t\treturn 0.0f;\n\tif (x < 0.0f)\n\t\treturn 0.92f*(-2.0f*x-3.0f)*x*x+1.0f;\n\tif (x < 1.0f)\n\t\treturn 0.92f*(2.0f*x-3.0f)*x*x+1.0f;\n\treturn 0.0f;\n}\n\nstatic double filter_power(const double x)\n{\n\tconst double a = 2.0f;\n\tif (fabs(x)>1) return 0.0f;\n\treturn (1.0f - (double)fabs(pow(x,a)));\n}\n\nstatic double filter_sinc(const double x)\n{\n\t/* X-scaled Sinc(x) function. */\n\tif (x == 0.0) return(1.0);\n\treturn (sin(M_PI * (double) x) / (M_PI * (double) x));\n}\n\n#ifdef FUNCTION_NOT_USED_YET\nstatic double filter_welsh(const double x)\n{\n\t/* Welsh parabolic windowing filter */\n\tif (x <  1.0)\n\t\treturn(1 - x*x);\n\treturn(0.0);\n}\n#endif\n\n#if defined(_MSC_VER) && !defined(inline)\n# define inline __inline\n#endif \n\n/* Copied from upstream's libgd */\nstatic inline int _color_blend (const int dst, const int src)\n{\n\tconst int src_alpha = gdTrueColorGetAlpha(src);\n\n\tif( src_alpha == gdAlphaOpaque ) {\n\t\treturn src;\n\t} else {\n\t\tconst int dst_alpha = gdTrueColorGetAlpha(dst);\n\n\t\tif( src_alpha == gdAlphaTransparent ) return dst;\n\t\tif( dst_alpha == gdAlphaTransparent ) {\n\t\t\treturn src;\n\t\t} else {\n\t\t\tregister int alpha, red, green, blue;\n\t\t\tconst int src_weight = gdAlphaTransparent - src_alpha;\n\t\t\tconst int dst_weight = (gdAlphaTransparent - dst_alpha) * src_alpha / gdAlphaMax;\n\t\t\tconst int tot_weight = src_weight + dst_weight;\n\n\t\t\talpha = src_alpha * dst_alpha / gdAlphaMax;\n\n\t\t\tred = (gdTrueColorGetRed(src) * src_weight\n\t\t\t\t   + gdTrueColorGetRed(dst) * dst_weight) / tot_weight;\n\t\t\tgreen = (gdTrueColorGetGreen(src) * src_weight\n\t\t\t\t   + gdTrueColorGetGreen(dst) * dst_weight) / tot_weight;\n\t\t\tblue = (gdTrueColorGetBlue(src) * src_weight\n\t\t\t\t   + gdTrueColorGetBlue(dst) * dst_weight) / tot_weight;\n\n\t\t\treturn ((alpha << 24) + (red << 16) + (green << 8) + blue);\n\t\t}\n\t}\n}\n\nstatic inline int _setEdgePixel(const gdImagePtr src, unsigned int x, unsigned int y, gdFixed coverage, const int bgColor) \n{\n\tconst gdFixed f_127 = gd_itofx(127);\n\tregister int c = src->tpixels[y][x];\n\tc = c | (( (int) (gd_fxtof(gd_mulfx(coverage, f_127)) + 50.5f)) << 24);\n\treturn _color_blend(bgColor, c);\n}\n\nstatic inline int getPixelOverflowTC(gdImagePtr im, const int x, const int y, const int bgColor)\n{\n\tif (gdImageBoundsSafe(im, x, y)) {\n\t\tconst int c = im->tpixels[y][x];\n\t\tif (c == im->transparent) {\n\t\t\treturn bgColor == -1 ? gdTrueColorAlpha(0, 0, 0, 127) : bgColor;\n\t\t}\n\t\treturn c;\n\t} else {\n\t\tregister int border = 0;\n\n\t\tif (y < im->cy1) {\n\t\t\tborder = im->tpixels[0][im->cx1];\n\t\t\tgoto processborder;\n\t\t}\n\n\t\tif (y < im->cy1) {\n\t\t\tborder = im->tpixels[0][im->cx1];\n\t\t\tgoto processborder;\n\t\t}\n\n\t\tif (y > im->cy2) {\n\t\t\tif (x >= im->cx1 && x <= im->cx1) {\n\t\t\t\tborder = im->tpixels[im->cy2][x];\n\t\t\t\tgoto processborder;\n\t\t\t} else {\n\t\t\t\treturn gdTrueColorAlpha(0, 0, 0, 127);\n\t\t\t}\n\t\t}\n\n\t\t/* y is bound safe at this point */\n\t\tif (x < im->cx1) {\n\t\t\tborder = im->tpixels[y][im->cx1];\n\t\t\tgoto processborder;\n\t\t}\n\n\t\tif (x > im->cx2) {\n\t\t\tborder = im->tpixels[y][im->cx2];\n\t\t}\n\nprocessborder:\n\t\tif (border == im->transparent) {\n\t\t\treturn gdTrueColorAlpha(0, 0, 0, 127);\n\t\t} else{\n\t\t\treturn gdTrueColorAlpha(gdTrueColorGetRed(border), gdTrueColorGetGreen(border), gdTrueColorGetBlue(border), 127);\n\t\t}\n\t}\n}\n\n#define colorIndex2RGBA(c) gdTrueColorAlpha(im->red[(c)], im->green[(c)], im->blue[(c)], im->alpha[(c)])\n#define colorIndex2RGBcustomA(c, a) gdTrueColorAlpha(im->red[(c)], im->green[(c)], im->blue[(c)], im->alpha[(a)])\nstatic inline int getPixelOverflowPalette(gdImagePtr im, const int x, const int y, const int bgColor)\n{\n\tif (gdImageBoundsSafe(im, x, y)) {\n\t\tconst int c = im->pixels[y][x];\n\t\tif (c == im->transparent) {\n\t\t\treturn bgColor == -1 ? gdTrueColorAlpha(0, 0, 0, 127) : bgColor;\n\t\t}\n\t\treturn colorIndex2RGBA(c);\n\t} else {\n\t\tregister int border = 0;\n\t\tif (y < im->cy1) {\n\t\t\tborder = gdImageGetPixel(im, im->cx1, 0);\n\t\t\tgoto processborder;\n\t\t}\n\n\t\tif (y < im->cy1) {\n\t\t\tborder = gdImageGetPixel(im, im->cx1, 0);\n\t\t\tgoto processborder;\n\t\t}\n\n\t\tif (y > im->cy2) {\n\t\t\tif (x >= im->cx1 && x <= im->cx1) {\n\t\t\t\tborder = gdImageGetPixel(im, x,  im->cy2);\n\t\t\t\tgoto processborder;\n\t\t\t} else {\n\t\t\t\treturn gdTrueColorAlpha(0, 0, 0, 127);\n\t\t\t}\n\t\t}\n\n\t\t/* y is bound safe at this point */\n\t\tif (x < im->cx1) {\n\t\t\tborder = gdImageGetPixel(im, im->cx1, y);\n\t\t\tgoto processborder;\n\t\t}\n\n\t\tif (x > im->cx2) {\n\t\t\tborder = gdImageGetPixel(im, im->cx2, y);\n\t\t}\n\nprocessborder:\n\t\tif (border == im->transparent) {\n\t\t\treturn gdTrueColorAlpha(0, 0, 0, 127);\n\t\t} else{\n\t\t\treturn colorIndex2RGBcustomA(border, 127);\n\t\t}\n\t}\n}\n\nstatic int getPixelInterpolateWeight(gdImagePtr im, const double x, const double y, const int bgColor)\n{\n\t/* Closest pixel <= (xf,yf) */\n\tint sx = (int)(x);\n\tint sy = (int)(y);\n\tconst double xf = x - (double)sx;\n\tconst double yf = y - (double)sy;\n\tconst double nxf = (double) 1.0 - xf;\n\tconst double nyf = (double) 1.0 - yf;\n\tconst double m1 = xf * yf;\n\tconst double m2 = nxf * yf;\n\tconst double m3 = xf * nyf;\n\tconst double m4 = nxf * nyf;\n\n\t/* get color values of neighbouring pixels */\n\tconst int c1 = im->trueColor == 1 ? getPixelOverflowTC(im, sx, sy, bgColor)         : getPixelOverflowPalette(im, sx, sy, bgColor);\n\tconst int c2 = im->trueColor == 1 ? getPixelOverflowTC(im, sx - 1, sy, bgColor)     : getPixelOverflowPalette(im, sx - 1, sy, bgColor);\n\tconst int c3 = im->trueColor == 1 ? getPixelOverflowTC(im, sx, sy - 1, bgColor)     : getPixelOverflowPalette(im, sx, sy - 1, bgColor);\n\tconst int c4 = im->trueColor == 1 ? getPixelOverflowTC(im, sx - 1, sy - 1, bgColor) : getPixelOverflowPalette(im, sx, sy - 1, bgColor);\n\tint r, g, b, a;\n\n\tif (x < 0) sx--;\n\tif (y < 0) sy--;\n\n\t/* component-wise summing-up of color values */\n\tif (im->trueColor) {\n\t\tr = (int)(m1*gdTrueColorGetRed(c1)   + m2*gdTrueColorGetRed(c2)   + m3*gdTrueColorGetRed(c3)   + m4*gdTrueColorGetRed(c4));\n\t\tg = (int)(m1*gdTrueColorGetGreen(c1) + m2*gdTrueColorGetGreen(c2) + m3*gdTrueColorGetGreen(c3) + m4*gdTrueColorGetGreen(c4));\n\t\tb = (int)(m1*gdTrueColorGetBlue(c1)  + m2*gdTrueColorGetBlue(c2)  + m3*gdTrueColorGetBlue(c3)  + m4*gdTrueColorGetBlue(c4));\n\t\ta = (int)(m1*gdTrueColorGetAlpha(c1) + m2*gdTrueColorGetAlpha(c2) + m3*gdTrueColorGetAlpha(c3) + m4*gdTrueColorGetAlpha(c4));\n\t} else {\n\t\tr = (int)(m1*im->red[(c1)]   + m2*im->red[(c2)]   + m3*im->red[(c3)]   + m4*im->red[(c4)]);\n\t\tg = (int)(m1*im->green[(c1)] + m2*im->green[(c2)] + m3*im->green[(c3)] + m4*im->green[(c4)]);\n\t\tb = (int)(m1*im->blue[(c1)]  + m2*im->blue[(c2)]  + m3*im->blue[(c3)]  + m4*im->blue[(c4)]);\n\t\ta = (int)(m1*im->alpha[(c1)] + m2*im->alpha[(c2)] + m3*im->alpha[(c3)] + m4*im->alpha[(c4)]);\n\t}\n\n\tr = CLAMP(r, 0, 255);\n\tg = CLAMP(g, 0, 255);\n\tb = CLAMP(b, 0, 255);\n\ta = CLAMP(a, 0, gdAlphaMax);\n\treturn gdTrueColorAlpha(r, g, b, a);\n}\n\n/**\n * Function: getPixelInterpolated\n *  Returns the interpolated color value using the default interpolation\n *  method. The returned color is always in the ARGB format (truecolor).\n *\n * Parameters:\n * \tim - Image to set the default interpolation method\n *  y - X value of the ideal position\n *  y - Y value of the ideal position\n *  method - Interpolation method <gdInterpolationMethod>\n *\n * Returns:\n *  GD_TRUE if the affine is rectilinear or GD_FALSE\n *\n * See also:\n *  <gdSetInterpolationMethod>\n */\nint getPixelInterpolated(gdImagePtr im, const double x, const double y, const int bgColor)\n{\n\tconst int xi=(int)((x) < 0 ? x - 1: x);\n\tconst int yi=(int)((y) < 0 ? y - 1: y);\n\tint yii;\n\tint i;\n\tdouble kernel, kernel_cache_y;\n\tdouble kernel_x[12], kernel_y[4];\n\tdouble new_r = 0.0f, new_g = 0.0f, new_b = 0.0f, new_a = 0.0f;\n\n\t/* These methods use special implementations */\n\tif (im->interpolation_id == GD_BILINEAR_FIXED || im->interpolation_id == GD_BICUBIC_FIXED || im->interpolation_id == GD_NEAREST_NEIGHBOUR) {\n\t\treturn -1;\n\t}\n\n\tif (im->interpolation_id == GD_WEIGHTED4) {\n\t\treturn getPixelInterpolateWeight(im, x, y, bgColor);\n\t}\n\n\tif (im->interpolation_id == GD_NEAREST_NEIGHBOUR) {\n\t\tif (im->trueColor == 1) {\n\t\t\treturn getPixelOverflowTC(im, xi, yi, bgColor);\n\t\t} else {\n\t\t\treturn getPixelOverflowPalette(im, xi, yi, bgColor);\n\t\t}\n\t}\n\tif (im->interpolation) {\n\t\tfor (i=0; i<4; i++) {\n\t\t\tkernel_x[i] = (double) im->interpolation((double)(xi+i-1-x));\n\t\t\tkernel_y[i] = (double) im->interpolation((double)(yi+i-1-y));\n\t\t}\n\t} else {\n\t\treturn -1;\n\t}\n\n\t/*\n\t * TODO: use the known fast rgba multiplication implementation once\n\t * the new formats are in place\n\t */\n\tfor (yii = yi-1; yii < yi+3; yii++) {\n\t\tint xii;\n\t\tkernel_cache_y = kernel_y[yii-(yi-1)];\n\t\tif (im->trueColor) {\n\t\t\tfor (xii=xi-1; xii<xi+3; xii++) {\n\t\t\t\tconst int rgbs = getPixelOverflowTC(im, xii, yii, bgColor);\n\n\t\t\t\tkernel = kernel_cache_y * kernel_x[xii-(xi-1)];\n\t\t\t\tnew_r += kernel * gdTrueColorGetRed(rgbs);\n\t\t\t\tnew_g += kernel * gdTrueColorGetGreen(rgbs);\n\t\t\t\tnew_b += kernel * gdTrueColorGetBlue(rgbs);\n\t\t\t\tnew_a += kernel * gdTrueColorGetAlpha(rgbs);\n\t\t\t}\n\t\t} else {\n\t\t\tfor (xii=xi-1; xii<xi+3; xii++) {\n\t\t\t\tconst int rgbs = getPixelOverflowPalette(im, xii, yii, bgColor);\n\n\t\t\t\tkernel = kernel_cache_y * kernel_x[xii-(xi-1)];\n\t\t\t\tnew_r += kernel * gdTrueColorGetRed(rgbs);\n\t\t\t\tnew_g += kernel * gdTrueColorGetGreen(rgbs);\n\t\t\t\tnew_b += kernel * gdTrueColorGetBlue(rgbs);\n\t\t\t\tnew_a += kernel * gdTrueColorGetAlpha(rgbs);\n\t\t\t}\n\t\t}\n\t}\n\n\tnew_r = CLAMP(new_r, 0, 255);\n\tnew_g = CLAMP(new_g, 0, 255);\n\tnew_b = CLAMP(new_b, 0, 255);\n\tnew_a = CLAMP(new_a, 0, gdAlphaMax);\n\n\treturn gdTrueColorAlpha(((int)new_r), ((int)new_g), ((int)new_b), ((int)new_a));\n}\n\nstatic inline LineContribType * _gdContributionsAlloc(unsigned int line_length, unsigned int windows_size)\n{\n\tunsigned int u = 0;\n\tLineContribType *res;\n\n\tres = (LineContribType *) gdMalloc(sizeof(LineContribType));\n\tif (!res) {\n\t\treturn NULL;\n\t}\n\tres->WindowSize = windows_size;\n\tres->LineLength = line_length;\n\tres->ContribRow = (ContributionType *) gdMalloc(line_length * sizeof(ContributionType));\n\n\tfor (u = 0 ; u < line_length ; u++) {\n\t\tres->ContribRow[u].Weights = (double *) gdMalloc(windows_size * sizeof(double));\n\t}\n\treturn res;\n}\n\nstatic inline void _gdContributionsFree(LineContribType * p)\n{\n\tunsigned int u;\n\tfor (u = 0; u < p->LineLength; u++)  {\n\t\tgdFree(p->ContribRow[u].Weights);\n\t}\n\tgdFree(p->ContribRow);\n\tgdFree(p);\n}\n\nstatic inline LineContribType *_gdContributionsCalc(unsigned int line_size, unsigned int src_size, double scale_d,  const interpolation_method pFilter)\n{\n\tdouble width_d;\n\tdouble scale_f_d = 1.0;\n\tconst double filter_width_d = DEFAULT_BOX_RADIUS;\n\tint windows_size;\n\tunsigned int u;\n\tLineContribType *res;\n\n\tif (scale_d < 1.0) {\n\t\twidth_d = filter_width_d / scale_d;\n\t\tscale_f_d = scale_d;\n\t}  else {\n\t\twidth_d= filter_width_d;\n\t}\n\n\twindows_size = 2 * (int)ceil(width_d) + 1;\n\tres = _gdContributionsAlloc(line_size, windows_size);\n\n\tfor (u = 0; u < line_size; u++) {\n\t\tconst double dCenter = (double)u / scale_d;\n\t\t/* get the significant edge points affecting the pixel */\n\t\tregister int iLeft = MAX(0, (int)floor (dCenter - width_d));\n\t\tint iRight = MIN((int)ceil(dCenter + width_d), (int)src_size - 1);\n\t\tdouble dTotalWeight = 0.0;\n\t\tint iSrc;\n\n\t\t/* Cut edge points to fit in filter window in case of spill-off */\n\t\tif (iRight - iLeft + 1 > windows_size)  {\n\t\t\tif (iLeft < ((int)src_size - 1 / 2))  {\n\t\t\t\tiLeft++;\n\t\t\t} else {\n\t\t\t\tiRight--;\n\t\t\t}\n\t\t}\n\n\t\tres->ContribRow[u].Left = iLeft;\n\t\tres->ContribRow[u].Right = iRight;\n\n\t\tfor (iSrc = iLeft; iSrc <= iRight; iSrc++) {\n\t\t\tdTotalWeight += (res->ContribRow[u].Weights[iSrc-iLeft] =  scale_f_d * (*pFilter)(scale_f_d * (dCenter - (double)iSrc)));\n\t\t}\n\n\t\tif (dTotalWeight < 0.0) {\n\t\t\t_gdContributionsFree(res);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (dTotalWeight > 0.0) {\n\t\t\tfor (iSrc = iLeft; iSrc <= iRight; iSrc++) {\n\t\t\t\tres->ContribRow[u].Weights[iSrc-iLeft] /= dTotalWeight;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nstatic inline void _gdScaleRow(gdImagePtr pSrc,  unsigned int src_width, gdImagePtr dst, unsigned int dst_width, unsigned int row, LineContribType *contrib)\n{\n\tint *p_src_row = pSrc->tpixels[row];\n\tint *p_dst_row = dst->tpixels[row];\n\tunsigned int x;\n\n\tfor (x = 0; x < dst_width - 1; x++) {\n\t\tregister unsigned char r = 0, g = 0, b = 0, a = 0;\n\t\tconst int left = contrib->ContribRow[x].Left;\n\t\tconst int right = contrib->ContribRow[x].Right;\n\t\tint i;\n\n\t\t/* Accumulate each channel */\n\t\tfor (i = left; i <= right; i++) {\n\t\t\tconst int left_channel = i - left;\n\t\t\tr += (unsigned char)(contrib->ContribRow[x].Weights[left_channel] * (double)(gdTrueColorGetRed(p_src_row[i])));\n\t\t\tg += (unsigned char)(contrib->ContribRow[x].Weights[left_channel] * (double)(gdTrueColorGetGreen(p_src_row[i])));\n\t\t\tb += (unsigned char)(contrib->ContribRow[x].Weights[left_channel] * (double)(gdTrueColorGetBlue(p_src_row[i])));\n\t\t\ta += (unsigned char)(contrib->ContribRow[x].Weights[left_channel] * (double)(gdTrueColorGetAlpha(p_src_row[i])));\n\t\t}\n\t\tp_dst_row[x] = gdTrueColorAlpha(r, g, b, a);\n\t}\n}\n\nstatic inline void _gdScaleHoriz(gdImagePtr pSrc, unsigned int src_width, unsigned int src_height, gdImagePtr pDst,  unsigned int dst_width, unsigned int dst_height)\n{\n\tunsigned int u;\n\tLineContribType * contrib;\n\n\t/* same width, just copy it */\n\tif (dst_width == src_width) {\n\t\tunsigned int y;\n\t\tfor (y = 0; y < src_height - 1; ++y) {\n\t\t\tmemcpy(pDst->tpixels[y], pSrc->tpixels[y], src_width);\n\t\t}\n\t}\n\n\tcontrib = _gdContributionsCalc(dst_width, src_width, (double)dst_width / (double)src_width, pSrc->interpolation);\n\tif (contrib == NULL) {\n\t\treturn;\n\t}\n\t/* Scale each row */\n\tfor (u = 0; u < dst_height - 1; u++) {\n\t\t_gdScaleRow(pSrc, src_width, pDst, dst_width, u, contrib);\n\t}\n\t_gdContributionsFree (contrib);\n}\n\nstatic inline void _gdScaleCol (gdImagePtr pSrc,  unsigned int src_width, gdImagePtr pRes, unsigned int dst_width, unsigned int dst_height, unsigned int uCol, LineContribType *contrib)\n{\n\tunsigned int y;\n\tfor (y = 0; y < dst_height - 1; y++) {\n\t\tregister unsigned char r = 0, g = 0, b = 0, a = 0;\n\t\tconst int iLeft = contrib->ContribRow[y].Left;\n\t\tconst int iRight = contrib->ContribRow[y].Right;\n\t\tint i;\n\n\t\t/* Accumulate each channel */\n\t\tfor (i = iLeft; i <= iRight; i++) {\n\t\t\tconst int pCurSrc = pSrc->tpixels[i][uCol];\n\t\t\tconst int i_iLeft = i - iLeft;\n\t\t\tr += (unsigned char)(contrib->ContribRow[y].Weights[i_iLeft] * (double)(gdTrueColorGetRed(pCurSrc)));\n\t\t\tg += (unsigned char)(contrib->ContribRow[y].Weights[i_iLeft] * (double)(gdTrueColorGetGreen(pCurSrc)));\n\t\t\tb += (unsigned char)(contrib->ContribRow[y].Weights[i_iLeft] * (double)(gdTrueColorGetBlue(pCurSrc)));\n\t\t\ta += (unsigned char)(contrib->ContribRow[y].Weights[i_iLeft] * (double)(gdTrueColorGetAlpha(pCurSrc)));\n\t\t}\n\t\tpRes->tpixels[y][uCol] = gdTrueColorAlpha(r, g, b, a);\n\t}\n}\n\nstatic inline void _gdScaleVert (const gdImagePtr pSrc, const unsigned int src_width, const unsigned int src_height, const gdImagePtr pDst, const unsigned int dst_width, const unsigned int dst_height)\n{\n\tunsigned int u;\n\tLineContribType * contrib;\n\n\t/* same height, copy it */\n\tif (src_height == dst_height) {\n\t\tunsigned int y;\n\t\tfor (y = 0; y < src_height - 1; ++y) {\n\t\t\tmemcpy(pDst->tpixels[y], pSrc->tpixels[y], src_width);\n\t\t}\n\t}\n\n\tcontrib = _gdContributionsCalc(dst_height, src_height, (double)(dst_height) / (double)(src_height), pSrc->interpolation);\n\t/* scale each column */\n\tfor (u = 0; u < dst_width - 1; u++) {\n\t\t_gdScaleCol(pSrc, src_width, pDst, dst_width, dst_height, u, contrib);\n\t}\n\t_gdContributionsFree(contrib);\n}\n\ngdImagePtr gdImageScaleTwoPass(const gdImagePtr src, const unsigned int src_width, const unsigned int src_height, const unsigned int new_width, const unsigned int new_height)\n{\n\tgdImagePtr tmp_im;\n\tgdImagePtr dst;\n\n\ttmp_im = gdImageCreateTrueColor(new_width, src_height);\n\tif (tmp_im == NULL) {\n\t\treturn NULL;\n\t}\n\tgdImageSetInterpolationMethod(tmp_im, src->interpolation_id);\n\t_gdScaleHoriz(src, src_width, src_height, tmp_im, new_width, src_height);\n\n\tdst = gdImageCreateTrueColor(new_width, new_height);\n\tif (dst == NULL) {\n\t\tgdFree(tmp_im);\n\t\treturn NULL;\n\t}\n\t_gdScaleVert(tmp_im, new_width, src_height, dst, new_width, new_height);\n\tgdFree(tmp_im);\n\n\treturn dst;\n}\n\ngdImagePtr Scale(const gdImagePtr src, const unsigned int src_width, const unsigned int src_height, const gdImagePtr dst, const unsigned int new_width, const unsigned int new_height)\n{\n\tgdImagePtr tmp_im;\n\n\ttmp_im = gdImageCreateTrueColor(new_width, src_height);\n\tif (tmp_im == NULL) {\n\t\treturn NULL;\n\t}\n\t_gdScaleHoriz(src, src_width, src_height, tmp_im, new_width, src_height);\n\n\t_gdScaleVert(tmp_im, new_width, src_height, dst, new_width, new_height);\n\n\tgdFree(tmp_im);\n\treturn dst;\n}\n\n/*\n\tBilinearFixed, BicubicFixed and nearest implementations are rewamped versions of the implementation in CBitmapEx\n\thttp://www.codeproject.com/Articles/29121/CBitmapEx-Free-C-Bitmap-Manipulation-Class\n\tInteger only implementation, good to have for common usages like pre scale very large\n\timages before using another interpolation methods for the last step.\n*/\ngdImagePtr gdImageScaleNearestNeighbour(gdImagePtr im, const unsigned int width, const unsigned int height)\n{\n\tconst unsigned long new_width = MAX(1, width);\n\tconst unsigned long new_height = MAX(1, height);\n\tconst float dx = (float)im->sx / (float)new_width;\n\tconst float dy = (float)im->sy / (float)new_height;\n\tconst gdFixed f_dx = gd_ftofx(dx);\n\tconst gdFixed f_dy = gd_ftofx(dy);\n\n\tgdImagePtr dst_img;\n\tunsigned long  dst_offset_x;\n\tunsigned long  dst_offset_y = 0;\n\tunsigned int i;\n\n\tdst_img = gdImageCreateTrueColor(new_width, new_height);\n\n\tif (dst_img == NULL) {\n\t\treturn NULL;\n\t}\n\n\tfor (i=0; i<new_height; i++) {\n\t\tunsigned int j;\n\t\tdst_offset_x = 0;\n\t\tif (im->trueColor) {\n\t\t\tfor (j=0; j<new_width; j++) {\n\t\t\t\tconst gdFixed f_i = gd_itofx(i);\n\t\t\t\tconst gdFixed f_j = gd_itofx(j);\n\t\t\t\tconst gdFixed f_a = gd_mulfx(f_i, f_dy);\n\t\t\t\tconst gdFixed f_b = gd_mulfx(f_j, f_dx);\n\t\t\t\tconst long m = gd_fxtoi(f_a);\n\t\t\t\tconst long n = gd_fxtoi(f_b);\n\n\t\t\t\tdst_img->tpixels[dst_offset_y][dst_offset_x++] = im->tpixels[m][n];\n\t\t\t}\n\t\t} else {\n\t\t\tfor (j=0; j<new_width; j++) {\n\t\t\t\tconst gdFixed f_i = gd_itofx(i);\n\t\t\t\tconst gdFixed f_j = gd_itofx(j);\n\t\t\t\tconst gdFixed f_a = gd_mulfx(f_i, f_dy);\n\t\t\t\tconst gdFixed f_b = gd_mulfx(f_j, f_dx);\n\t\t\t\tconst long m = gd_fxtoi(f_a);\n\t\t\t\tconst long n = gd_fxtoi(f_b);\n\n\t\t\t\tdst_img->tpixels[dst_offset_y][dst_offset_x++] = colorIndex2RGBA(im->pixels[m][n]);\n\t\t\t}\n\t\t}\n\t\tdst_offset_y++;\n\t}\n\treturn dst_img;\n}\n\nstatic inline int getPixelOverflowColorTC(gdImagePtr im, const int x, const int y, const int color)\n{\n\tif (gdImageBoundsSafe(im, x, y)) {\n\t\tconst int c = im->tpixels[y][x];\n\t\tif (c == im->transparent) {\n\t\t\treturn gdTrueColorAlpha(0, 0, 0, 127);\n\t\t}\n\t\treturn c;\n\t} else {\n\t\tregister int border = 0;\n\t\tif (y < im->cy1) {\n\t\t\tborder = im->tpixels[0][im->cx1];\n\t\t\tgoto processborder;\n\t\t}\n\n\t\tif (y < im->cy1) {\n\t\t\tborder = im->tpixels[0][im->cx1];\n\t\t\tgoto processborder;\n\t\t}\n\n\t\tif (y > im->cy2) {\n\t\t\tif (x >= im->cx1 && x <= im->cx1) {\n\t\t\t\tborder = im->tpixels[im->cy2][x];\n\t\t\t\tgoto processborder;\n\t\t\t} else {\n\t\t\t\treturn gdTrueColorAlpha(0, 0, 0, 127);\n\t\t\t}\n\t\t}\n\n\t\t/* y is bound safe at this point */\n\t\tif (x < im->cx1) {\n\t\t\tborder = im->tpixels[y][im->cx1];\n\t\t\tgoto processborder;\n\t\t}\n\n\t\tif (x > im->cx2) {\n\t\t\tborder = im->tpixels[y][im->cx2];\n\t\t}\n\nprocessborder:\n\t\tif (border == im->transparent) {\n\t\t\treturn gdTrueColorAlpha(0, 0, 0, 127);\n\t\t} else{\n\t\t\treturn gdTrueColorAlpha(gdTrueColorGetRed(border), gdTrueColorGetGreen(border), gdTrueColorGetBlue(border), 127);\n\t\t}\n\t}\n}\n\nstatic gdImagePtr gdImageScaleBilinearPalette(gdImagePtr im, const unsigned int new_width, const unsigned int new_height)\n{\n\tlong _width = MAX(1, new_width);\n\tlong _height = MAX(1, new_height);\n\tfloat dx = (float)gdImageSX(im) / (float)_width;\n\tfloat dy = (float)gdImageSY(im) / (float)_height;\n\tgdFixed f_dx = gd_ftofx(dx);\n\tgdFixed f_dy = gd_ftofx(dy);\n\tgdFixed f_1 = gd_itofx(1);\n\n\tint dst_offset_h;\n\tint dst_offset_v = 0;\n\tlong i;\n\tgdImagePtr new_img;\n\tconst int transparent = im->transparent;\n\n\tnew_img = gdImageCreateTrueColor(new_width, new_height);\n\tif (new_img == NULL) {\n\t\treturn NULL;\n\t}\n\tnew_img->transparent = gdTrueColorAlpha(im->red[transparent], im->green[transparent], im->blue[transparent], im->alpha[transparent]);\n\n\tfor (i=0; i < _height; i++) {\n\t\tlong j;\n\t\tconst gdFixed f_i = gd_itofx(i);\n\t\tconst gdFixed f_a = gd_mulfx(f_i, f_dy);\n\t\tregister long m = gd_fxtoi(f_a);\n\n\t\tdst_offset_h = 0;\n\n\t\tfor (j=0; j < _width; j++) {\n\t\t\t/* Update bitmap */\n\t\t\tgdFixed f_j = gd_itofx(j);\n\t\t\tgdFixed f_b = gd_mulfx(f_j, f_dx);\n\n\t\t\tconst long n = gd_fxtoi(f_b);\n\t\t\tgdFixed f_f = f_a - gd_itofx(m);\n\t\t\tgdFixed f_g = f_b - gd_itofx(n);\n\n\t\t\tconst gdFixed f_w1 = gd_mulfx(f_1-f_f, f_1-f_g);\n\t\t\tconst gdFixed f_w2 = gd_mulfx(f_1-f_f, f_g);\n\t\t\tconst gdFixed f_w3 = gd_mulfx(f_f, f_1-f_g);\n\t\t\tconst gdFixed f_w4 = gd_mulfx(f_f, f_g);\n\t\t\tunsigned int pixel1;\n\t\t\tunsigned int pixel2;\n\t\t\tunsigned int pixel3;\n\t\t\tunsigned int pixel4;\n\t\t\tregister gdFixed f_r1, f_r2, f_r3, f_r4,\n\t\t\t\t\tf_g1, f_g2, f_g3, f_g4,\n\t\t\t\t\tf_b1, f_b2, f_b3, f_b4,\n\t\t\t\t\tf_a1, f_a2, f_a3, f_a4;\n\n\t\t\t/* zero for the background color, nothig gets outside anyway */\n\t\t\tpixel1 = getPixelOverflowPalette(im, n, m, 0);\n\t\t\tpixel2 = getPixelOverflowPalette(im, n + 1, m, 0);\n\t\t\tpixel3 = getPixelOverflowPalette(im, n, m + 1, 0);\n\t\t\tpixel4 = getPixelOverflowPalette(im, n + 1, m + 1, 0);\n\n\t\t\tf_r1 = gd_itofx(gdTrueColorGetRed(pixel1));\n\t\t\tf_r2 = gd_itofx(gdTrueColorGetRed(pixel2));\n\t\t\tf_r3 = gd_itofx(gdTrueColorGetRed(pixel3));\n\t\t\tf_r4 = gd_itofx(gdTrueColorGetRed(pixel4));\n\t\t\tf_g1 = gd_itofx(gdTrueColorGetGreen(pixel1));\n\t\t\tf_g2 = gd_itofx(gdTrueColorGetGreen(pixel2));\n\t\t\tf_g3 = gd_itofx(gdTrueColorGetGreen(pixel3));\n\t\t\tf_g4 = gd_itofx(gdTrueColorGetGreen(pixel4));\n\t\t\tf_b1 = gd_itofx(gdTrueColorGetBlue(pixel1));\n\t\t\tf_b2 = gd_itofx(gdTrueColorGetBlue(pixel2));\n\t\t\tf_b3 = gd_itofx(gdTrueColorGetBlue(pixel3));\n\t\t\tf_b4 = gd_itofx(gdTrueColorGetBlue(pixel4));\n\t\t\tf_a1 = gd_itofx(gdTrueColorGetAlpha(pixel1));\n\t\t\tf_a2 = gd_itofx(gdTrueColorGetAlpha(pixel2));\n\t\t\tf_a3 = gd_itofx(gdTrueColorGetAlpha(pixel3));\n\t\t\tf_a4 = gd_itofx(gdTrueColorGetAlpha(pixel4));\n\n\t\t\t{\n\t\t\t\tconst char red = (char) gd_fxtoi(gd_mulfx(f_w1, f_r1) + gd_mulfx(f_w2, f_r2) + gd_mulfx(f_w3, f_r3) + gd_mulfx(f_w4, f_r4));\n\t\t\t\tconst char green = (char) gd_fxtoi(gd_mulfx(f_w1, f_g1) + gd_mulfx(f_w2, f_g2) + gd_mulfx(f_w3, f_g3) + gd_mulfx(f_w4, f_g4));\n\t\t\t\tconst char blue = (char) gd_fxtoi(gd_mulfx(f_w1, f_b1) + gd_mulfx(f_w2, f_b2) + gd_mulfx(f_w3, f_b3) + gd_mulfx(f_w4, f_b4));\n\t\t\t\tconst char alpha = (char) gd_fxtoi(gd_mulfx(f_w1, f_a1) + gd_mulfx(f_w2, f_a2) + gd_mulfx(f_w3, f_a3) + gd_mulfx(f_w4, f_a4));\n\n\t\t\t\tnew_img->tpixels[dst_offset_v][dst_offset_h] = gdTrueColorAlpha(red, green, blue, alpha);\n\t\t\t}\n\n\t\t\tdst_offset_h++;\n\t\t}\n\n\t\tdst_offset_v++;\n\t}\n\treturn new_img;\n}\n\nstatic gdImagePtr gdImageScaleBilinearTC(gdImagePtr im, const unsigned int new_width, const unsigned int new_height)\n{\n\tlong dst_w = MAX(1, new_width);\n\tlong dst_h = MAX(1, new_height);\n\tfloat dx = (float)gdImageSX(im) / (float)dst_w;\n\tfloat dy = (float)gdImageSY(im) / (float)dst_h;\n\tgdFixed f_dx = gd_ftofx(dx);\n\tgdFixed f_dy = gd_ftofx(dy);\n\tgdFixed f_1 = gd_itofx(1);\n\n\tint dst_offset_h;\n\tint dst_offset_v = 0;\n\tlong i;\n\tgdImagePtr new_img;\n\n\tnew_img = gdImageCreateTrueColor(new_width, new_height);\n\tif (!new_img){\n\t\treturn NULL;\n\t}\n\n\tfor (i=0; i < dst_h; i++) {\n\t\tlong j;\n\t\tdst_offset_h = 0;\n\t\tfor (j=0; j < dst_w; j++) {\n\t\t\t/* Update bitmap */\n\t\t\tgdFixed f_i = gd_itofx(i);\n\t\t\tgdFixed f_j = gd_itofx(j);\n\t\t\tgdFixed f_a = gd_mulfx(f_i, f_dy);\n\t\t\tgdFixed f_b = gd_mulfx(f_j, f_dx);\n\t\t\tconst long m = gd_fxtoi(f_a);\n\t\t\tconst long n = gd_fxtoi(f_b);\n\t\t\tgdFixed f_f = f_a - gd_itofx(m);\n\t\t\tgdFixed f_g = f_b - gd_itofx(n);\n\n\t\t\tconst gdFixed f_w1 = gd_mulfx(f_1-f_f, f_1-f_g);\n\t\t\tconst gdFixed f_w2 = gd_mulfx(f_1-f_f, f_g);\n\t\t\tconst gdFixed f_w3 = gd_mulfx(f_f, f_1-f_g);\n\t\t\tconst gdFixed f_w4 = gd_mulfx(f_f, f_g);\n\t\t\tunsigned int pixel1;\n\t\t\tunsigned int pixel2;\n\t\t\tunsigned int pixel3;\n\t\t\tunsigned int pixel4;\n\t\t\tregister gdFixed f_r1, f_r2, f_r3, f_r4,\n\t\t\t\t\tf_g1, f_g2, f_g3, f_g4,\n\t\t\t\t\tf_b1, f_b2, f_b3, f_b4,\n\t\t\t\t\tf_a1, f_a2, f_a3, f_a4;\n\t\t\t/* 0 for bgColor, nothing gets outside anyway */\n\t\t\tpixel1 = getPixelOverflowTC(im, n, m, 0);\n\t\t\tpixel2 = getPixelOverflowTC(im, n + 1, m, 0);\n\t\t\tpixel3 = getPixelOverflowTC(im, n, m + 1, 0);\n\t\t\tpixel4 = getPixelOverflowTC(im, n + 1, m + 1, 0);\n\n\t\t\tf_r1 = gd_itofx(gdTrueColorGetRed(pixel1));\n\t\t\tf_r2 = gd_itofx(gdTrueColorGetRed(pixel2));\n\t\t\tf_r3 = gd_itofx(gdTrueColorGetRed(pixel3));\n\t\t\tf_r4 = gd_itofx(gdTrueColorGetRed(pixel4));\n\t\t\tf_g1 = gd_itofx(gdTrueColorGetGreen(pixel1));\n\t\t\tf_g2 = gd_itofx(gdTrueColorGetGreen(pixel2));\n\t\t\tf_g3 = gd_itofx(gdTrueColorGetGreen(pixel3));\n\t\t\tf_g4 = gd_itofx(gdTrueColorGetGreen(pixel4));\n\t\t\tf_b1 = gd_itofx(gdTrueColorGetBlue(pixel1));\n\t\t\tf_b2 = gd_itofx(gdTrueColorGetBlue(pixel2));\n\t\t\tf_b3 = gd_itofx(gdTrueColorGetBlue(pixel3));\n\t\t\tf_b4 = gd_itofx(gdTrueColorGetBlue(pixel4));\n\t\t\tf_a1 = gd_itofx(gdTrueColorGetAlpha(pixel1));\n\t\t\tf_a2 = gd_itofx(gdTrueColorGetAlpha(pixel2));\n\t\t\tf_a3 = gd_itofx(gdTrueColorGetAlpha(pixel3));\n\t\t\tf_a4 = gd_itofx(gdTrueColorGetAlpha(pixel4));\n\t\t\t{\n\t\t\t\tconst char red = (char) gd_fxtoi(gd_mulfx(f_w1, f_r1) + gd_mulfx(f_w2, f_r2) + gd_mulfx(f_w3, f_r3) + gd_mulfx(f_w4, f_r4));\n\t\t\t\tconst char green = (char) gd_fxtoi(gd_mulfx(f_w1, f_g1) + gd_mulfx(f_w2, f_g2) + gd_mulfx(f_w3, f_g3) + gd_mulfx(f_w4, f_g4));\n\t\t\t\tconst char blue = (char) gd_fxtoi(gd_mulfx(f_w1, f_b1) + gd_mulfx(f_w2, f_b2) + gd_mulfx(f_w3, f_b3) + gd_mulfx(f_w4, f_b4));\n\t\t\t\tconst char alpha = (char) gd_fxtoi(gd_mulfx(f_w1, f_a1) + gd_mulfx(f_w2, f_a2) + gd_mulfx(f_w3, f_a3) + gd_mulfx(f_w4, f_a4));\n\n\t\t\t\tnew_img->tpixels[dst_offset_v][dst_offset_h] = gdTrueColorAlpha(red, green, blue, alpha);\n\t\t\t}\n\n\t\t\tdst_offset_h++;\n\t\t}\n\n\t\tdst_offset_v++;\n\t}\n\treturn new_img;\n}\n\ngdImagePtr gdImageScaleBilinear(gdImagePtr im, const unsigned int new_width, const unsigned int new_height)\n{\n\tif (im->trueColor) {\n\t\treturn gdImageScaleBilinearTC(im, new_width, new_height);\n\t} else {\n\t\treturn gdImageScaleBilinearPalette(im, new_width, new_height);\n\t}\n}\n\ngdImagePtr gdImageScaleBicubicFixed(gdImagePtr src, const unsigned int width, const unsigned int height)\n{\n\tconst long new_width = MAX(1, width);\n\tconst long new_height = MAX(1, height);\n\tconst int src_w = gdImageSX(src);\n\tconst int src_h = gdImageSY(src);\n\tconst gdFixed f_dx = gd_ftofx((float)src_w / (float)new_width);\n\tconst gdFixed f_dy = gd_ftofx((float)src_h / (float)new_height);\n\tconst gdFixed f_1 = gd_itofx(1);\n\tconst gdFixed f_2 = gd_itofx(2);\n\tconst gdFixed f_4 = gd_itofx(4);\n\tconst gdFixed f_6 = gd_itofx(6);\n\tconst gdFixed f_gamma = gd_ftofx(1.04f);\n\tgdImagePtr dst;\n\n\tunsigned int dst_offset_x;\n\tunsigned int dst_offset_y = 0;\n\tlong i;\n\n\t/* impact perf a bit, but not that much. Implementation for palette\n\t   images can be done at a later point.\n\t*/\n\tif (src->trueColor == 0) {\n\t\tgdImagePaletteToTrueColor(src);\n\t}\n\n\tdst = gdImageCreateTrueColor(new_width, new_height);\n\tif (!dst) {\n\t\treturn NULL;\n\t}\n\n\tdst->saveAlphaFlag = 1;\n\n\tfor (i=0; i < new_height; i++) {\n\t\tlong j;\n\t\tdst_offset_x = 0;\n\n\t\tfor (j=0; j < new_width; j++) {\n\t\t\tconst gdFixed f_a = gd_mulfx(gd_itofx(i), f_dy);\n\t\t\tconst gdFixed f_b = gd_mulfx(gd_itofx(j), f_dx);\n\t\t\tconst long m = gd_fxtoi(f_a);\n\t\t\tconst long n = gd_fxtoi(f_b);\n\t\t\tconst gdFixed f_f = f_a - gd_itofx(m);\n\t\t\tconst gdFixed f_g = f_b - gd_itofx(n);\n\t\t\tunsigned int src_offset_x[16], src_offset_y[16];\n\t\t\tlong k;\n\t\t\tregister gdFixed f_red = 0, f_green = 0, f_blue = 0, f_alpha = 0;\n\t\t\tunsigned char red, green, blue, alpha = 0;\n\t\t\tint *dst_row = dst->tpixels[dst_offset_y];\n\n\t\t\tif ((m < 1) || (n < 1)) {\n\t\t\t\tsrc_offset_x[0] = n;\n\t\t\t\tsrc_offset_y[0] = m;\n\t\t\t} else {\n\t\t\t\tsrc_offset_x[0] = n - 1;\n\t\t\t\tsrc_offset_y[0] = m;\n\t\t\t}\n\n\t\t\tif (m < 1) {\n\t\t\t\tsrc_offset_x[1] = n;\n\t\t\t\tsrc_offset_y[1] = m;\n\t\t\t} else {\n\t\t\t\tsrc_offset_x[1] = n;\n\t\t\t\tsrc_offset_y[1] = m;\n\t\t\t}\n\n\t\t\tif ((m < 1) || (n >= src_w - 1)) {\n\t\t\t\tsrc_offset_x[2] = n;\n\t\t\t\tsrc_offset_y[2] = m;\n\t\t\t} else {\n\t\t\t\tsrc_offset_x[2] = n + 1;\n\t\t\t\tsrc_offset_y[2] = m;\n\t\t\t}\n\n\t\t\tif ((m < 1) || (n >= src_w - 2)) {\n\t\t\t\tsrc_offset_x[3] = n;\n\t\t\t\tsrc_offset_y[3] = m;\n\t\t\t} else {\n\t\t\t\tsrc_offset_x[3] = n + 1 + 1;\n\t\t\t\tsrc_offset_y[3] = m;\n\t\t\t}\n\n\t\t\tif (n < 1) {\n\t\t\t\tsrc_offset_x[4] = n;\n\t\t\t\tsrc_offset_y[4] = m;\n\t\t\t} else {\n\t\t\t\tsrc_offset_x[4] = n - 1;\n\t\t\t\tsrc_offset_y[4] = m;\n\t\t\t}\n\n\t\t\tsrc_offset_x[5] = n;\n\t\t\tsrc_offset_y[5] = m;\n\t\t\tif (n >= src_w-1) {\n\t\t\t\tsrc_offset_x[6] = n;\n\t\t\t\tsrc_offset_y[6] = m;\n\t\t\t} else {\n\t\t\t\tsrc_offset_x[6] = n + 1;\n\t\t\t\tsrc_offset_y[6] = m;\n\t\t\t}\n\n\t\t\tif (n >= src_w - 2) {\n\t\t\t\tsrc_offset_x[7] = n;\n\t\t\t\tsrc_offset_y[7] = m;\n\t\t\t} else {\n\t\t\t\tsrc_offset_x[7] = n + 1 + 1;\n\t\t\t\tsrc_offset_y[7] = m;\n\t\t\t}\n\n\t\t\tif ((m >= src_h - 1) || (n < 1)) {\n\t\t\t\tsrc_offset_x[8] = n;\n\t\t\t\tsrc_offset_y[8] = m;\n\t\t\t} else {\n\t\t\t\tsrc_offset_x[8] = n - 1;\n\t\t\t\tsrc_offset_y[8] = m;\n\t\t\t}\n\n\t\t\tif (m >= src_h - 1) {\n\t\t\t\tsrc_offset_x[8] = n;\n\t\t\t\tsrc_offset_y[8] = m;\n\t\t\t} else {\n\t\t\t\tsrc_offset_x[9] = n;\n\t\t\t\tsrc_offset_y[9] = m;\n\t\t\t}\n\n\t\t\tif ((m >= src_h-1) || (n >= src_w-1)) {\n\t\t\t\tsrc_offset_x[10] = n;\n\t\t\t\tsrc_offset_y[10] = m;\n\t\t\t} else {\n\t\t\t\tsrc_offset_x[10] = n + 1;\n\t\t\t\tsrc_offset_y[10] = m;\n\t\t\t}\n\n\t\t\tif ((m >= src_h - 1) || (n >= src_w - 2)) {\n\t\t\t\tsrc_offset_x[11] = n;\n\t\t\t\tsrc_offset_y[11] = m;\n\t\t\t} else {\n\t\t\t\tsrc_offset_x[11] = n + 1 + 1;\n\t\t\t\tsrc_offset_y[11] = m;\n\t\t\t}\n\n\t\t\tif ((m >= src_h - 2) || (n < 1)) {\n\t\t\t\tsrc_offset_x[12] = n;\n\t\t\t\tsrc_offset_y[12] = m;\n\t\t\t} else {\n\t\t\t\tsrc_offset_x[12] = n - 1;\n\t\t\t\tsrc_offset_y[12] = m;\n\t\t\t}\n\n\t\t\tif (m >= src_h - 2) {\n\t\t\t\tsrc_offset_x[13] = n;\n\t\t\t\tsrc_offset_y[13] = m;\n\t\t\t} else {\n\t\t\t\tsrc_offset_x[13] = n;\n\t\t\t\tsrc_offset_y[13] = m;\n\t\t\t}\n\n\t\t\tif ((m >= src_h - 2) || (n >= src_w - 1)) {\n\t\t\t\tsrc_offset_x[14] = n;\n\t\t\t\tsrc_offset_y[14] = m;\n\t\t\t} else {\n\t\t\t\tsrc_offset_x[14] = n + 1;\n\t\t\t\tsrc_offset_y[14] = m;\n\t\t\t}\n\n\t\t\tif ((m >= src_h - 2) || (n >= src_w - 2)) {\n\t\t\t\tsrc_offset_x[15] = n;\n\t\t\t\tsrc_offset_y[15] = m;\n\t\t\t} else {\n\t\t\t\tsrc_offset_x[15] = n  + 1 + 1;\n\t\t\t\tsrc_offset_y[15] = m;\n\t\t\t}\n\n\t\t\tfor (k = -1; k < 3; k++) {\n\t\t\t\tconst gdFixed f = gd_itofx(k)-f_f;\n\t\t\t\tconst gdFixed f_fm1 = f - f_1;\n\t\t\t\tconst gdFixed f_fp1 = f + f_1;\n\t\t\t\tconst gdFixed f_fp2 = f + f_2;\n\t\t\t\tregister gdFixed f_a = 0, f_b = 0, f_d = 0, f_c = 0;\n\t\t\t\tregister gdFixed f_RY;\n\t\t\t\tint l;\n\n\t\t\t\tif (f_fp2 > 0) f_a = gd_mulfx(f_fp2, gd_mulfx(f_fp2,f_fp2));\n\t\t\t\tif (f_fp1 > 0) f_b = gd_mulfx(f_fp1, gd_mulfx(f_fp1,f_fp1));\n\t\t\t\tif (f > 0)     f_c = gd_mulfx(f, gd_mulfx(f,f));\n\t\t\t\tif (f_fm1 > 0) f_d = gd_mulfx(f_fm1, gd_mulfx(f_fm1,f_fm1));\n\n\t\t\t\tf_RY = gd_divfx((f_a - gd_mulfx(f_4,f_b) + gd_mulfx(f_6,f_c) - gd_mulfx(f_4,f_d)),f_6);\n\n\t\t\t\tfor (l = -1; l < 3; l++) {\n\t\t\t\t\tconst gdFixed f = gd_itofx(l) - f_g;\n\t\t\t\t\tconst gdFixed f_fm1 = f - f_1;\n\t\t\t\t\tconst gdFixed f_fp1 = f + f_1;\n\t\t\t\t\tconst gdFixed f_fp2 = f + f_2;\n\t\t\t\t\tregister gdFixed f_a = 0, f_b = 0, f_c = 0, f_d = 0;\n\t\t\t\t\tregister gdFixed f_RX, f_R, f_rs, f_gs, f_bs, f_ba;\n\t\t\t\t\tregister int c;\n\t\t\t\t\tconst int _k = ((k+1)*4) + (l+1);\n\n\t\t\t\t\tif (f_fp2 > 0) f_a = gd_mulfx(f_fp2,gd_mulfx(f_fp2,f_fp2));\n\n\t\t\t\t\tif (f_fp1 > 0) f_b = gd_mulfx(f_fp1,gd_mulfx(f_fp1,f_fp1));\n\n\t\t\t\t\tif (f > 0) f_c = gd_mulfx(f,gd_mulfx(f,f));\n\n\t\t\t\t\tif (f_fm1 > 0) f_d = gd_mulfx(f_fm1,gd_mulfx(f_fm1,f_fm1));\n\n\t\t\t\t\tf_RX = gd_divfx((f_a-gd_mulfx(f_4,f_b)+gd_mulfx(f_6,f_c)-gd_mulfx(f_4,f_d)),f_6);\n\t\t\t\t\tf_R = gd_mulfx(f_RY,f_RX);\n\n\t\t\t\t\tc = src->tpixels[*(src_offset_y + _k)][*(src_offset_x + _k)];\n\t\t\t\t\tf_rs = gd_itofx(gdTrueColorGetRed(c));\n\t\t\t\t\tf_gs = gd_itofx(gdTrueColorGetGreen(c));\n\t\t\t\t\tf_bs = gd_itofx(gdTrueColorGetBlue(c));\n\t\t\t\t\tf_ba = gd_itofx(gdTrueColorGetAlpha(c));\n\n\t\t\t\t\tf_red += gd_mulfx(f_rs,f_R);\n\t\t\t\t\tf_green += gd_mulfx(f_gs,f_R);\n\t\t\t\t\tf_blue += gd_mulfx(f_bs,f_R);\n\t\t\t\t\tf_alpha += gd_mulfx(f_ba,f_R);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tred    = (unsigned char) CLAMP(gd_fxtoi(gd_mulfx(f_red,   f_gamma)),  0, 255);\n\t\t\tgreen  = (unsigned char) CLAMP(gd_fxtoi(gd_mulfx(f_green, f_gamma)),  0, 255);\n\t\t\tblue   = (unsigned char) CLAMP(gd_fxtoi(gd_mulfx(f_blue,  f_gamma)),  0, 255);\n\t\t\talpha  = (unsigned char) CLAMP(gd_fxtoi(gd_mulfx(f_alpha,  f_gamma)), 0, 127);\n\n\t\t\t*(dst_row + dst_offset_x) = gdTrueColorAlpha(red, green, blue, alpha);\n\n\t\t\tdst_offset_x++;\n\t\t}\n\t\tdst_offset_y++;\n\t}\n\treturn dst;\n}\n\nBGD_DECLARE(gdImagePtr) gdImageScale(const gdImagePtr src, const unsigned int new_width, const unsigned int new_height)\n{\n\tgdImagePtr im_scaled = NULL;\n\n\tif (src == NULL || src->interpolation_id < 0 || src->interpolation_id > GD_METHOD_COUNT) {\n\t\treturn 0;\n\t}\n\n\tswitch (src->interpolation_id) {\n\t\t/*Special cases, optimized implementations */\n\t\tcase GD_NEAREST_NEIGHBOUR:\n\t\t\tim_scaled = gdImageScaleNearestNeighbour(src, new_width, new_height);\n\t\t\tbreak;\n\n\t\tcase GD_BILINEAR_FIXED:\n\t\t\tim_scaled = gdImageScaleBilinear(src, new_width, new_height);\n\t\t\tbreak;\n\n\t\tcase GD_BICUBIC_FIXED:\n\t\t\tim_scaled = gdImageScaleBicubicFixed(src, new_width, new_height);\n\t\t\tbreak;\n\n\t\t/* generic */\n\t\tdefault:\n\t\t\tif (src->interpolation == NULL) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tim_scaled = gdImageScaleTwoPass(src, src->sx, src->sy, new_width, new_height);\n\t\t\tbreak;\n\t}\n\treturn im_scaled;\n}\n\ngdImagePtr gdImageRotateNearestNeighbour(gdImagePtr src, const float degrees, const int bgColor)\n{\n\tfloat _angle = ((float) (-degrees / 180.0f) * (float)M_PI);\n\tconst int src_w  = gdImageSX(src);\n\tconst int src_h = gdImageSY(src);\n\tconst unsigned int new_width = (unsigned int)(abs((int)(src_w * cos(_angle))) + abs((int)(src_h * sin(_angle))) + 0.5f);\n\tconst unsigned int new_height = (unsigned int)(abs((int)(src_w * sin(_angle))) + abs((int)(src_h * cos(_angle))) + 0.5f);\n\tconst gdFixed f_0_5 = gd_ftofx(0.5f);\n\tconst gdFixed f_H = gd_itofx(src_h/2);\n\tconst gdFixed f_W = gd_itofx(src_w/2);\n\tconst gdFixed f_cos = gd_ftofx(cos(-_angle));\n\tconst gdFixed f_sin = gd_ftofx(sin(-_angle));\n\n\tunsigned int dst_offset_x;\n\tunsigned int dst_offset_y = 0;\n\tunsigned int i;\n\tgdImagePtr dst;\n\n\t/* impact perf a bit, but not that much. Implementation for palette\n\t   images can be done at a later point.\n\t*/\n\tif (src->trueColor == 0) {\n\t\tgdImagePaletteToTrueColor(src);\n\t}\n\n\tdst = gdImageCreateTrueColor(new_width, new_height);\n\tif (!dst) {\n\t\treturn NULL;\n\t}\n\tdst->saveAlphaFlag = 1;\n\tfor (i = 0; i < new_height; i++) {\n\t\tunsigned int j;\n\t\tdst_offset_x = 0;\n\t\tfor (j = 0; j < new_width; j++) {\n\t\t\tgdFixed f_i = gd_itofx((int)i - (int)new_height / 2);\n\t\t\tgdFixed f_j = gd_itofx((int)j - (int)new_width  / 2);\n\t\t\tgdFixed f_m = gd_mulfx(f_j,f_sin) + gd_mulfx(f_i,f_cos) + f_0_5 + f_H;\n\t\t\tgdFixed f_n = gd_mulfx(f_j,f_cos) - gd_mulfx(f_i,f_sin) + f_0_5 + f_W;\n\t\t\tlong m = gd_fxtoi(f_m);\n\t\t\tlong n = gd_fxtoi(f_n);\n\n\t\t\tif ((m > 0) && (m < src_h-1) && (n > 0) && (n < src_w-1)) {\n\t\t\t\tif (dst_offset_y < new_height) {\n\t\t\t\t\tdst->tpixels[dst_offset_y][dst_offset_x++] = src->tpixels[m][n];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (dst_offset_y < new_height) {\n\t\t\t\t\tdst->tpixels[dst_offset_y][dst_offset_x++] = bgColor;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdst_offset_y++;\n\t}\n\treturn dst;\n}\n\ngdImagePtr gdImageRotateGeneric(gdImagePtr src, const float degrees, const int bgColor)\n{\n\tfloat _angle = ((float) (-degrees / 180.0f) * (float)M_PI);\n\tconst int src_w  = gdImageSX(src);\n\tconst int src_h = gdImageSY(src);\n\tconst unsigned int new_width = (unsigned int)(abs((int)(src_w * cos(_angle))) + abs((int)(src_h * sin(_angle))) + 0.5f);\n\tconst unsigned int new_height = (unsigned int)(abs((int)(src_w * sin(_angle))) + abs((int)(src_h * cos(_angle))) + 0.5f);\n\tconst gdFixed f_0_5 = gd_ftofx(0.5f);\n\tconst gdFixed f_H = gd_itofx(src_h/2);\n\tconst gdFixed f_W = gd_itofx(src_w/2);\n\tconst gdFixed f_cos = gd_ftofx(cos(-_angle));\n\tconst gdFixed f_sin = gd_ftofx(sin(-_angle));\n\n\tunsigned int dst_offset_x;\n\tunsigned int dst_offset_y = 0;\n\tunsigned int i;\n\tgdImagePtr dst;\n\n\tconst gdFixed f_slop_y = f_sin;\n\tconst gdFixed f_slop_x = f_cos;\n\tconst gdFixed f_slop = f_slop_x > 0 && f_slop_x > 0 ?\n\t\t\t\t\t\t\tf_slop_x > f_slop_y ? gd_divfx(f_slop_y, f_slop_x) : gd_divfx(f_slop_x, f_slop_y)\n\t\t\t\t\t\t: 0;\n\n\tif (bgColor < 0) {\n\t\treturn NULL;\n\t}\n\n\t/* impact perf a bit, but not that much. Implementation for palette\n\t   images can be done at a later point.\n\t*/\n\tif (src->trueColor == 0) {\n\t\tgdImagePaletteToTrueColor(src);\n\t}\n\n\tdst = gdImageCreateTrueColor(new_width, new_height);\n\tif (!dst) {\n\t\treturn NULL;\n\t}\n\tdst->saveAlphaFlag = 1;\n\n\tfor (i = 0; i < new_height; i++) {\n\t\tunsigned int j;\n\t\tdst_offset_x = 0;\n\t\tfor (j = 0; j < new_width; j++) {\n\t\t\tgdFixed f_i = gd_itofx((int)i - (int)new_height / 2);\n\t\t\tgdFixed f_j = gd_itofx((int)j - (int)new_width  / 2);\n\t\t\tgdFixed f_m = gd_mulfx(f_j,f_sin) + gd_mulfx(f_i,f_cos) + f_0_5 + f_H;\n\t\t\tgdFixed f_n = gd_mulfx(f_j,f_cos) - gd_mulfx(f_i,f_sin) + f_0_5 + f_W;\n\t\t\tlong m = gd_fxtoi(f_m);\n\t\t\tlong n = gd_fxtoi(f_n);\n\n\t\t\tif ((n <= 0) || (m <= 0) || (m >= src_h) || (n >= src_w)) {\n\t\t\t\tdst->tpixels[dst_offset_y][dst_offset_x++] = bgColor;\n\t\t\t} else if ((n <= 1) || (m <= 1) || (m >= src_h - 1) || (n >= src_w - 1)) {\n\t\t\t\tregister int c = getPixelInterpolated(src, n, m, bgColor);\n\t\t\t\tc = c | (( gdTrueColorGetAlpha(c) + ((int)(127* gd_fxtof(f_slop)))) << 24);\n\n\t\t\t\tdst->tpixels[dst_offset_y][dst_offset_x++] = _color_blend(bgColor, c);\n\t\t\t} else {\n\t\t\t\tdst->tpixels[dst_offset_y][dst_offset_x++] = getPixelInterpolated(src, n, m, bgColor);\n\t\t\t}\n\t\t}\n\t\tdst_offset_y++;\n\t}\n\treturn dst;\n}\n\ngdImagePtr gdImageRotateBilinear(gdImagePtr src, const float degrees, const int bgColor)\n{\n\tfloat _angle = (float)((- degrees / 180.0f) * M_PI);\n\tconst unsigned int src_w = gdImageSX(src);\n\tconst unsigned int src_h = gdImageSY(src);\n\tunsigned int new_width = abs((int)(src_w*cos(_angle))) + abs((int)(src_h*sin(_angle) + 0.5f));\n\tunsigned int new_height = abs((int)(src_w*sin(_angle))) + abs((int)(src_h*cos(_angle) + 0.5f));\n\tconst gdFixed f_0_5 = gd_ftofx(0.5f);\n\tconst gdFixed f_H = gd_itofx(src_h/2);\n\tconst gdFixed f_W = gd_itofx(src_w/2);\n\tconst gdFixed f_cos = gd_ftofx(cos(-_angle));\n\tconst gdFixed f_sin = gd_ftofx(sin(-_angle));\n\tconst gdFixed f_1 = gd_itofx(1);\n\tunsigned int i;\n\tunsigned int dst_offset_x;\n\tunsigned int dst_offset_y = 0;\n\tunsigned int src_offset_x, src_offset_y;\n\tgdImagePtr dst;\n\n\t/* impact perf a bit, but not that much. Implementation for palette\n\t   images can be done at a later point.\n\t*/\n\tif (src->trueColor == 0) {\n\t\tgdImagePaletteToTrueColor(src);\n\t}\n\n\tdst = gdImageCreateTrueColor(new_width, new_height);\n\tif (dst == NULL) {\n\t\treturn NULL;\n\t}\n\tdst->saveAlphaFlag = 1;\n\n\tfor (i = 0; i < new_height; i++) {\n\t\tunsigned int j;\n\t\tdst_offset_x = 0;\n\n\t\tfor (j=0; j < new_width; j++) {\n\t\t\tconst gdFixed f_i = gd_itofx((int)i - (int)new_height / 2);\n\t\t\tconst gdFixed f_j = gd_itofx((int)j - (int)new_width  / 2);\n\t\t\tconst gdFixed f_m = gd_mulfx(f_j,f_sin) + gd_mulfx(f_i,f_cos) + f_0_5 + f_H;\n\t\t\tconst gdFixed f_n = gd_mulfx(f_j,f_cos) - gd_mulfx(f_i,f_sin) + f_0_5 + f_W;\n\t\t\tconst unsigned int m = gd_fxtoi(f_m);\n\t\t\tconst unsigned int n = gd_fxtoi(f_n);\n\n\t\t\tif ((m > 0) && (m < src_h - 1) && (n > 0) && (n < src_w - 1)) {\n\t\t\t\tconst gdFixed f_f = f_m - gd_itofx(m);\n\t\t\t\tconst gdFixed f_g = f_n - gd_itofx(n);\n\t\t\t\tconst gdFixed f_w1 = gd_mulfx(f_1-f_f, f_1-f_g);\n\t\t\t\tconst gdFixed f_w2 = gd_mulfx(f_1-f_f, f_g);\n\t\t\t\tconst gdFixed f_w3 = gd_mulfx(f_f, f_1-f_g);\n\t\t\t\tconst gdFixed f_w4 = gd_mulfx(f_f, f_g);\n\n\t\t\t\tif (n < src_w - 1) {\n\t\t\t\t\tsrc_offset_x = n + 1;\n\t\t\t\t\tsrc_offset_y = m;\n\t\t\t\t}\n\n\t\t\t\tif (m < src_h - 1) {\n\t\t\t\t\tsrc_offset_x = n;\n\t\t\t\t\tsrc_offset_y = m + 1;\n\t\t\t\t}\n\n\t\t\t\tif (!((n >= src_w - 1) || (m >= src_h - 1))) {\n\t\t\t\t\tsrc_offset_x = n + 1;\n\t\t\t\t\tsrc_offset_y = m + 1;\n\t\t\t\t}\n\t\t\t\t{\n\t\t\t\t\tconst int pixel1 = src->tpixels[src_offset_y][src_offset_x];\n\t\t\t\t\tregister int pixel2, pixel3, pixel4;\n\n\t\t\t\t\tif (src_offset_y + 1 >= src_h) {\n\t\t\t\t\t\tpixel2 = bgColor;\n\t\t\t\t\t\tpixel3 = bgColor;\n\t\t\t\t\t\tpixel4 = bgColor;\n\t\t\t\t\t} else if (src_offset_x + 1 >= src_w) {\n\t\t\t\t\t\tpixel2 = bgColor;\n\t\t\t\t\t\tpixel3 = bgColor;\n\t\t\t\t\t\tpixel4 = bgColor;\n\t\t\t\t\t} else {\n\t\t\t\t\t    pixel2 = src->tpixels[src_offset_y][src_offset_x + 1];\n\t\t\t\t\t\tpixel3 = src->tpixels[src_offset_y + 1][src_offset_x];\n\t\t\t\t\t\tpixel4 = src->tpixels[src_offset_y + 1][src_offset_x + 1];\n\t\t\t\t\t}\n\t\t\t\t\t{\n\t\t\t\t\t\tconst gdFixed f_r1 = gd_itofx(gdTrueColorGetRed(pixel1));\n\t\t\t\t\t\tconst gdFixed f_r2 = gd_itofx(gdTrueColorGetRed(pixel2));\n\t\t\t\t\t\tconst gdFixed f_r3 = gd_itofx(gdTrueColorGetRed(pixel3));\n\t\t\t\t\t\tconst gdFixed f_r4 = gd_itofx(gdTrueColorGetRed(pixel4));\n\t\t\t\t\t\tconst gdFixed f_g1 = gd_itofx(gdTrueColorGetGreen(pixel1));\n\t\t\t\t\t\tconst gdFixed f_g2 = gd_itofx(gdTrueColorGetGreen(pixel2));\n\t\t\t\t\t\tconst gdFixed f_g3 = gd_itofx(gdTrueColorGetGreen(pixel3));\n\t\t\t\t\t\tconst gdFixed f_g4 = gd_itofx(gdTrueColorGetGreen(pixel4));\n\t\t\t\t\t\tconst gdFixed f_b1 = gd_itofx(gdTrueColorGetBlue(pixel1));\n\t\t\t\t\t\tconst gdFixed f_b2 = gd_itofx(gdTrueColorGetBlue(pixel2));\n\t\t\t\t\t\tconst gdFixed f_b3 = gd_itofx(gdTrueColorGetBlue(pixel3));\n\t\t\t\t\t\tconst gdFixed f_b4 = gd_itofx(gdTrueColorGetBlue(pixel4));\n\t\t\t\t\t\tconst gdFixed f_a1 = gd_itofx(gdTrueColorGetAlpha(pixel1));\n\t\t\t\t\t\tconst gdFixed f_a2 = gd_itofx(gdTrueColorGetAlpha(pixel2));\n\t\t\t\t\t\tconst gdFixed f_a3 = gd_itofx(gdTrueColorGetAlpha(pixel3));\n\t\t\t\t\t\tconst gdFixed f_a4 = gd_itofx(gdTrueColorGetAlpha(pixel4));\n\t\t\t\t\t\tconst gdFixed f_red = gd_mulfx(f_w1, f_r1) + gd_mulfx(f_w2, f_r2) + gd_mulfx(f_w3, f_r3) + gd_mulfx(f_w4, f_r4);\n\t\t\t\t\t\tconst gdFixed f_green = gd_mulfx(f_w1, f_g1) + gd_mulfx(f_w2, f_g2) + gd_mulfx(f_w3, f_g3) + gd_mulfx(f_w4, f_g4);\n\t\t\t\t\t\tconst gdFixed f_blue = gd_mulfx(f_w1, f_b1) + gd_mulfx(f_w2, f_b2) + gd_mulfx(f_w3, f_b3) + gd_mulfx(f_w4, f_b4);\n\t\t\t\t\t\tconst gdFixed f_alpha = gd_mulfx(f_w1, f_a1) + gd_mulfx(f_w2, f_a2) + gd_mulfx(f_w3, f_a3) + gd_mulfx(f_w4, f_a4);\n\n\t\t\t\t\t\tconst unsigned char red   = (unsigned char) CLAMP(gd_fxtoi(f_red),   0, 255);\n\t\t\t\t\t\tconst unsigned char green = (unsigned char) CLAMP(gd_fxtoi(f_green), 0, 255);\n\t\t\t\t\t\tconst unsigned char blue  = (unsigned char) CLAMP(gd_fxtoi(f_blue),  0, 255);\n\t\t\t\t\t\tconst unsigned char alpha = (unsigned char) CLAMP(gd_fxtoi(f_alpha), 0, 127);\n\n\t\t\t\t\t\tdst->tpixels[dst_offset_y][dst_offset_x++] = gdTrueColorAlpha(red, green, blue, alpha);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdst->tpixels[dst_offset_y][dst_offset_x++] = bgColor;\n\t\t\t}\n\t\t}\n\t\tdst_offset_y++;\n\t}\n\treturn dst;\n}\n\ngdImagePtr gdImageRotateBicubicFixed(gdImagePtr src, const float degrees, const int bgColor)\n{\n\tconst float _angle = (float)((- degrees / 180.0f) * M_PI);\n\tconst int src_w = gdImageSX(src);\n\tconst int src_h = gdImageSY(src);\n\tconst unsigned int new_width = abs((int)(src_w*cos(_angle))) + abs((int)(src_h*sin(_angle) + 0.5f));\n\tconst unsigned int new_height = abs((int)(src_w*sin(_angle))) + abs((int)(src_h*cos(_angle) + 0.5f));\n\tconst gdFixed f_0_5 = gd_ftofx(0.5f);\n\tconst gdFixed f_H = gd_itofx(src_h/2);\n\tconst gdFixed f_W = gd_itofx(src_w/2);\n\tconst gdFixed f_cos = gd_ftofx(cos(-_angle));\n\tconst gdFixed f_sin = gd_ftofx(sin(-_angle));\n\tconst gdFixed f_1 = gd_itofx(1);\n\tconst gdFixed f_2 = gd_itofx(2);\n\tconst gdFixed f_4 = gd_itofx(4);\n\tconst gdFixed f_6 = gd_itofx(6);\n\tconst gdFixed f_gama = gd_ftofx(1.04f);\n\n\tunsigned int dst_offset_x;\n\tunsigned int dst_offset_y = 0;\n\tunsigned int i;\n\tgdImagePtr dst;\n\n\t/* impact perf a bit, but not that much. Implementation for palette\n\t   images can be done at a later point.\n\t*/\n\tif (src->trueColor == 0) {\n\t\tgdImagePaletteToTrueColor(src);\n\t}\n\n\tdst = gdImageCreateTrueColor(new_width, new_height);\n\n\tif (dst == NULL) {\n\t\treturn NULL;\n\t}\n\tdst->saveAlphaFlag = 1;\n\n\tfor (i=0; i < new_height; i++) {\n\t\tunsigned int j;\n\t\tdst_offset_x = 0;\n\n\t\tfor (j=0; j < new_width; j++) {\n\t\t\tconst gdFixed f_i = gd_itofx((int)i - (int)new_height / 2);\n\t\t\tconst gdFixed f_j = gd_itofx((int)j - (int)new_width  / 2);\n\t\t\tconst gdFixed f_m = gd_mulfx(f_j,f_sin) + gd_mulfx(f_i,f_cos) + f_0_5 + f_H;\n\t\t\tconst gdFixed f_n = gd_mulfx(f_j,f_cos) - gd_mulfx(f_i,f_sin) + f_0_5 + f_W;\n\t\t\tconst int m = gd_fxtoi(f_m);\n\t\t\tconst int n = gd_fxtoi(f_n);\n\n\t\t\tif ((m > 0) && (m < src_h - 1) && (n > 0) && (n < src_w-1)) {\n\t\t\t\tconst gdFixed f_f = f_m - gd_itofx(m);\n\t\t\t\tconst gdFixed f_g = f_n - gd_itofx(n);\n\t\t\t\tunsigned int src_offset_x[16], src_offset_y[16];\n\t\t\t\tunsigned char red, green, blue, alpha;\n\t\t\t\tgdFixed f_red=0, f_green=0, f_blue=0, f_alpha=0;\n\t\t\t\tint k;\n\n\t\t\t\tif ((m < 1) || (n < 1)) {\n\t\t\t\t\tsrc_offset_x[0] = n;\n\t\t\t\t\tsrc_offset_y[0] = m;\n\t\t\t\t} else {\n\t\t\t\t\tsrc_offset_x[0] = n - 1;\n\t\t\t\t\tsrc_offset_y[0] = m;\n\t\t\t\t}\n\n\t\t\t\tif (m < 1) {\n\t\t\t\t\tsrc_offset_x[1] = n;\n\t\t\t\t\tsrc_offset_y[1] = m;\n\t\t\t\t} else {\n\t\t\t\t\tsrc_offset_x[1] = n;\n\t\t\t\t\tsrc_offset_y[1] = m ;\n\t\t\t\t}\n\n\t\t\t\tif ((m < 1) || (n >= src_w-1)) {\n\t\t\t\t\tsrc_offset_x[2] = - 1;\n\t\t\t\t\tsrc_offset_y[2] = - 1;\n\t\t\t\t} else {\n\t\t\t\t\tsrc_offset_x[2] = n + 1;\n\t\t\t\t\tsrc_offset_y[2] = m ;\n\t\t\t\t}\n\n\t\t\t\tif ((m < 1) || (n >= src_w-2)) {\n\t\t\t\t\tsrc_offset_x[3] = - 1;\n\t\t\t\t\tsrc_offset_y[3] = - 1;\n\t\t\t\t} else {\n\t\t\t\t\tsrc_offset_x[3] = n + 1 + 1;\n\t\t\t\t\tsrc_offset_y[3] = m ;\n\t\t\t\t}\n\n\t\t\t\tif (n < 1) {\n\t\t\t\t\tsrc_offset_x[4] = - 1;\n\t\t\t\t\tsrc_offset_y[4] = - 1;\n\t\t\t\t} else {\n\t\t\t\t\tsrc_offset_x[4] = n - 1;\n\t\t\t\t\tsrc_offset_y[4] = m;\n\t\t\t\t}\n\n\t\t\t\tsrc_offset_x[5] = n;\n\t\t\t\tsrc_offset_y[5] = m;\n\t\t\t\tif (n >= src_w-1) {\n\t\t\t\t\tsrc_offset_x[6] = - 1;\n\t\t\t\t\tsrc_offset_y[6] = - 1;\n\t\t\t\t} else {\n\t\t\t\t\tsrc_offset_x[6] = n + 1;\n\t\t\t\t\tsrc_offset_y[6] = m;\n\t\t\t\t}\n\n\t\t\t\tif (n >= src_w-2) {\n\t\t\t\t\tsrc_offset_x[7] = - 1;\n\t\t\t\t\tsrc_offset_y[7] = - 1;\n\t\t\t\t} else {\n\t\t\t\t\tsrc_offset_x[7] = n + 1 + 1;\n\t\t\t\t\tsrc_offset_y[7] = m;\n\t\t\t\t}\n\n\t\t\t\tif ((m >= src_h-1) || (n < 1)) {\n\t\t\t\t\tsrc_offset_x[8] = - 1;\n\t\t\t\t\tsrc_offset_y[8] = - 1;\n\t\t\t\t} else {\n\t\t\t\t\tsrc_offset_x[8] = n - 1;\n\t\t\t\t\tsrc_offset_y[8] = m;\n\t\t\t\t}\n\n\t\t\t\tif (m >= src_h-1) {\n\t\t\t\t\tsrc_offset_x[8] = - 1;\n\t\t\t\t\tsrc_offset_y[8] = - 1;\n\t\t\t\t} else {\n\t\t\t\t\tsrc_offset_x[9] = n;\n\t\t\t\t\tsrc_offset_y[9] = m;\n\t\t\t\t}\n\n\t\t\t\tif ((m >= src_h-1) || (n >= src_w-1)) {\n\t\t\t\t\tsrc_offset_x[10] = - 1;\n\t\t\t\t\tsrc_offset_y[10] = - 1;\n\t\t\t\t} else {\n\t\t\t\t\tsrc_offset_x[10] = n + 1;\n\t\t\t\t\tsrc_offset_y[10] = m;\n\t\t\t\t}\n\n\t\t\t\tif ((m >= src_h-1) || (n >= src_w-2)) {\n\t\t\t\t\tsrc_offset_x[11] = - 1;\n\t\t\t\t\tsrc_offset_y[11] = - 1;\n\t\t\t\t} else {\n\t\t\t\t\tsrc_offset_x[11] = n + 1 + 1;\n\t\t\t\t\tsrc_offset_y[11] = m;\n\t\t\t\t}\n\n\t\t\t\tif ((m >= src_h-2) || (n < 1)) {\n\t\t\t\t\tsrc_offset_x[12] = - 1;\n\t\t\t\t\tsrc_offset_y[12] = - 1;\n\t\t\t\t} else {\n\t\t\t\t\tsrc_offset_x[12] = n - 1;\n\t\t\t\t\tsrc_offset_y[12] = m;\n\t\t\t\t}\n\n\t\t\t\tif (m >= src_h-2) {\n\t\t\t\t\tsrc_offset_x[13] = - 1;\n\t\t\t\t\tsrc_offset_y[13] = - 1;\n\t\t\t\t} else {\n\t\t\t\t\tsrc_offset_x[13] = n;\n\t\t\t\t\tsrc_offset_y[13] = m;\n\t\t\t\t}\n\n\t\t\t\tif ((m >= src_h-2) || (n >= src_w - 1)) {\n\t\t\t\t\tsrc_offset_x[14] = - 1;\n\t\t\t\t\tsrc_offset_y[14] = - 1;\n\t\t\t\t} else {\n\t\t\t\t\tsrc_offset_x[14] = n + 1;\n\t\t\t\t\tsrc_offset_y[14] = m;\n\t\t\t\t}\n\n\t\t\t\tif ((m >= src_h-2) || (n >= src_w-2)) {\n\t\t\t\t\tsrc_offset_x[15] = - 1;\n\t\t\t\t\tsrc_offset_y[15] = - 1;\n\t\t\t\t} else {\n\t\t\t\t\tsrc_offset_x[15] = n  + 1 + 1;\n\t\t\t\t\tsrc_offset_y[15] = m;\n\t\t\t\t}\n\n\t\t\t\tfor (k=-1; k<3; k++) {\n\t\t\t\t\tconst gdFixed f = gd_itofx(k)-f_f;\n\t\t\t\t\tconst gdFixed f_fm1 = f - f_1;\n\t\t\t\t\tconst gdFixed f_fp1 = f + f_1;\n\t\t\t\t\tconst gdFixed f_fp2 = f + f_2;\n\t\t\t\t\tgdFixed f_a = 0, f_b = 0,f_c = 0, f_d = 0;\n\t\t\t\t\tgdFixed f_RY;\n\t\t\t\t\tint l;\n\n\t\t\t\t\tif (f_fp2 > 0) {\n\t\t\t\t\t\tf_a = gd_mulfx(f_fp2,gd_mulfx(f_fp2,f_fp2));\n\t\t\t\t\t}\n\n\t\t\t\t\tif (f_fp1 > 0) {\n\t\t\t\t\t\tf_b = gd_mulfx(f_fp1,gd_mulfx(f_fp1,f_fp1));\n\t\t\t\t\t}\n\n\t\t\t\t\tif (f > 0) {\n\t\t\t\t\t\tf_c = gd_mulfx(f,gd_mulfx(f,f));\n\t\t\t\t\t}\n\n\t\t\t\t\tif (f_fm1 > 0) {\n\t\t\t\t\t\tf_d = gd_mulfx(f_fm1,gd_mulfx(f_fm1,f_fm1));\n\t\t\t\t\t}\n\t\t\t\t\tf_RY = gd_divfx((f_a-gd_mulfx(f_4,f_b)+gd_mulfx(f_6,f_c)-gd_mulfx(f_4,f_d)),f_6);\n\n\t\t\t\t\tfor (l=-1;  l< 3; l++) {\n\t\t\t\t\t\tconst gdFixed f = gd_itofx(l) - f_g;\n\t\t\t\t\t\tconst gdFixed f_fm1 = f - f_1;\n\t\t\t\t\t\tconst gdFixed f_fp1 = f + f_1;\n\t\t\t\t\t\tconst gdFixed f_fp2 = f + f_2;\n\t\t\t\t\t\tgdFixed f_a = 0, f_b = 0, f_c = 0, f_d = 0;\n\t\t\t\t\t\tgdFixed f_RX, f_R;\n\t\t\t\t\t\tconst int _k = ((k + 1) * 4) + (l + 1);\n\t\t\t\t\t\tregister gdFixed f_rs, f_gs, f_bs, f_as;\n\t\t\t\t\t\tregister int c;\n\n\t\t\t\t\t\tif (f_fp2 > 0) {\n\t\t\t\t\t\t\tf_a = gd_mulfx(f_fp2,gd_mulfx(f_fp2,f_fp2));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (f_fp1 > 0) {\n\t\t\t\t\t\t\tf_b = gd_mulfx(f_fp1,gd_mulfx(f_fp1,f_fp1));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (f > 0) {\n\t\t\t\t\t\t\tf_c = gd_mulfx(f,gd_mulfx(f,f));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (f_fm1 > 0) {\n\t\t\t\t\t\t\tf_d = gd_mulfx(f_fm1,gd_mulfx(f_fm1,f_fm1));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tf_RX = gd_divfx((f_a - gd_mulfx(f_4, f_b) + gd_mulfx(f_6, f_c) - gd_mulfx(f_4, f_d)), f_6);\n\t\t\t\t\t\tf_R = gd_mulfx(f_RY, f_RX);\n\n\t\t\t\t\t\tif ((src_offset_x[_k] <= 0) || (src_offset_y[_k] <= 0) || (src_offset_y[_k] >= src_h) || (src_offset_x[_k] >= src_w)) {\n\t\t\t\t\t\t\tc = bgColor;\n\t\t\t\t\t\t} else if ((src_offset_x[_k] <= 1) || (src_offset_y[_k] <= 1) || (src_offset_y[_k] >= (int)src_h - 1) || (src_offset_x[_k] >= (int)src_w - 1)) {\n\t\t\t\t\t\t\tgdFixed f_127 = gd_itofx(127);\n\t\t\t\t\t\t\tc = src->tpixels[src_offset_y[_k]][src_offset_x[_k]];\n\t\t\t\t\t\t\tc = c | (( (int) (gd_fxtof(gd_mulfx(f_R, f_127)) + 50.5f)) << 24);\n\t\t\t\t\t\t\tc = _color_blend(bgColor, c);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tc = src->tpixels[src_offset_y[_k]][src_offset_x[_k]];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tf_rs = gd_itofx(gdTrueColorGetRed(c));\n\t\t\t\t\t\tf_gs = gd_itofx(gdTrueColorGetGreen(c));\n\t\t\t\t\t\tf_bs = gd_itofx(gdTrueColorGetBlue(c));\n\t\t\t\t\t\tf_as = gd_itofx(gdTrueColorGetAlpha(c));\n\n\t\t\t\t\t\tf_red   += gd_mulfx(f_rs, f_R);\n\t\t\t\t\t\tf_green += gd_mulfx(f_gs, f_R);\n\t\t\t\t\t\tf_blue  += gd_mulfx(f_bs, f_R);\n\t\t\t\t\t\tf_alpha += gd_mulfx(f_as, f_R);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tred   = (unsigned char) CLAMP(gd_fxtoi(gd_mulfx(f_red, f_gama)),   0, 255);\n\t\t\t\tgreen = (unsigned char) CLAMP(gd_fxtoi(gd_mulfx(f_green, f_gama)), 0, 255);\n\t\t\t\tblue  = (unsigned char) CLAMP(gd_fxtoi(gd_mulfx(f_blue, f_gama)),  0, 255);\n\t\t\t\talpha = (unsigned char) CLAMP(gd_fxtoi(gd_mulfx(f_alpha, f_gama)), 0, 127);\n\n\t\t\t\tdst->tpixels[dst_offset_y][dst_offset_x] =  gdTrueColorAlpha(red, green, blue, alpha);\n\t\t\t} else {\n\t\t\t\tdst->tpixels[dst_offset_y][dst_offset_x] =  bgColor;\n\t\t\t}\n\t\t\tdst_offset_x++;\n\t\t}\n\n\t\tdst_offset_y++;\n\t}\n\treturn dst;\n}\n\nBGD_DECLARE(gdImagePtr) gdImageRotateInterpolated(const gdImagePtr src, const float angle, int bgcolor)\n{\n\t/* round to two decimals and keep the 100x multiplication to use it in the common square angles \n\t   case later. Keep the two decimal precisions so smaller rotation steps can be done, useful for\n\t   slow animations, f.e. */\n\tconst int angle_rounded = fmod((int) floorf(angle * 100), 360 * 100);\n\n\tif (bgcolor < 0) {\n\t\treturn NULL;\n\t}\n\n\t/* 0 && 90 degrees multiple rotation, 0 rotation simply clones the return image and convert it\n\t   to truecolor, as we must return truecolor image. */\n\tswitch (angle_rounded) {\n\t\tcase    0: {\n\t\t\tgdImagePtr dst = gdImageClone(src);\n\n\t\t\tif (dst == NULL) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif (dst->trueColor == 0) {\n\t\t\t\tgdImagePaletteToTrueColor(dst);\n\t\t\t}\n\t\t\treturn dst;\n\t\t}\n\n\t\tcase -2700:\n\t\tcase   9000:\n\t\t\treturn gdImageRotate90(src, 0);\n\n\t\tcase -18000:\n\t\tcase  18000:\n\t\t\treturn gdImageRotate180(src, 0);\n\n\t\tcase  -9000:\n\t\tcase  27000:\n\t\t\treturn gdImageRotate270(src, 0);\n\t}\n\n\tif (src == NULL || src->interpolation_id < 1 || src->interpolation_id > GD_METHOD_COUNT) {\n\t\treturn NULL;\n\t}\n\n\tswitch (src->interpolation_id) {\n\t\tcase GD_NEAREST_NEIGHBOUR:\n\t\t\treturn gdImageRotateNearestNeighbour(src, angle, bgcolor);\n\t\t\tbreak;\n\n\t\tcase GD_BILINEAR_FIXED:\n\t\t\treturn gdImageRotateBilinear(src, angle, bgcolor);\n\t\t\tbreak;\n\n\t\tcase GD_BICUBIC_FIXED:\n\t\t\treturn gdImageRotateBicubicFixed(src, angle, bgcolor);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn gdImageRotateGeneric(src, angle, bgcolor);\n\t}\n\treturn NULL;\n}\n\n/**\n * Title: Affine transformation\n **/\n\n/**\n * Group: Transform\n **/\n\n static void gdImageClipRectangle(gdImagePtr im, gdRectPtr r)\n{\n\tint c1x, c1y, c2x, c2y;\n\tint x1,y1;\n\n\tgdImageGetClip(im, &c1x, &c1y, &c2x, &c2y);\n\tx1 = r->x + r->width - 1;\n\ty1 = r->y + r->height - 1;\n\tr->x = CLAMP(r->x, c1x, c2x);\n\tr->y = CLAMP(r->y, c1y, c2y);\n\tr->width = CLAMP(x1, c1x, c2x) - r->x + 1;\n\tr->height = CLAMP(y1, c1y, c2y) - r->y + 1;\n}\n\nvoid gdDumpRect(const char *msg, gdRectPtr r)\n{\n\tprintf(\"%s (%i, %i) (%i, %i)\\n\", msg, r->x, r->y, r->width, r->height);\n}\n\n/**\n * Function: gdTransformAffineGetImage\n *  Applies an affine transformation to a region and return an image\n *  containing the complete transformation.\n *\n * Parameters:\n * \tdst - Pointer to a gdImagePtr to store the created image, NULL when\n *        the creation or the transformation failed\n *  src - Source image\n *  src_area - rectangle defining the source region to transform\n *  dstY - Y position in the destination image\n *  affine - The desired affine transformation\n *\n * Returns:\n *  GD_TRUE if the affine is rectilinear or GD_FALSE\n */\nBGD_DECLARE(int) gdTransformAffineGetImage(gdImagePtr *dst,\n\t\t  const gdImagePtr src,\n\t\t  gdRectPtr src_area,\n\t\t  const double affine[6])\n{\n\tint res;\n\tdouble m[6];\n\tgdRect bbox;\n\tgdRect area_full;\n\n\tif (src_area == NULL) {\n\t\tarea_full.x = 0;\n\t\tarea_full.y = 0;\n\t\tarea_full.width  = gdImageSX(src);\n\t\tarea_full.height = gdImageSY(src);\n\t\tsrc_area = &area_full;\n\t}\n\n\tgdTransformAffineBoundingBox(src_area, affine, &bbox);\n\n\t*dst = gdImageCreateTrueColor(bbox.width, bbox.height);\n\tif (*dst == NULL) {\n\t\treturn GD_FALSE;\n\t}\n\t(*dst)->saveAlphaFlag = 1;\n\n\tif (!src->trueColor) {\n\t\tgdImagePaletteToTrueColor(src);\n\t}\n\t\n\t/* Translate to dst origin (0,0) */\n\tgdAffineTranslate(m, -bbox.x, -bbox.y);\n\tgdAffineConcat(m, affine, m);\n\n\tgdImageAlphaBlending(*dst, 0);\n\n\tres = gdTransformAffineCopy(*dst,\n\t\t  0,0,\n\t\t  src,\n\t\t  src_area,\n\t\t  m);\n\n\tif (res != GD_TRUE) {\n\t\tgdImageDestroy(*dst);\n\t\tdst = NULL;\n\t\treturn GD_FALSE;\n\t} else {\n\t\treturn GD_TRUE;\n\t}\n}\n\n/**\n * Function: gdTransformAffineCopy\n *  Applies an affine transformation to a region and copy the result\n *  in a destination to the given position.\n *\n * Parameters:\n * \tdst - Image to draw the transformed image\n *  src - Source image\n *  dstX - X position in the destination image\n *  dstY - Y position in the destination image\n *  src_area - Rectangular region to rotate in the src image\n *\n * Returns:\n *  GD_TRUE if the affine is rectilinear or GD_FALSE\n */\nBGD_DECLARE(int) gdTransformAffineCopy(gdImagePtr dst,\n\t\t  int dst_x, int dst_y,\n\t\t  const gdImagePtr src,\n\t\t  gdRectPtr src_region,\n\t\t  const double affine[6])\n{\n\tint c1x,c1y,c2x,c2y;\n\tint backclip = 0;\n\tint backup_clipx1, backup_clipy1, backup_clipx2, backup_clipy2;\n\tregister int x, y, src_offset_x, src_offset_y;\n\tdouble inv[6];\n\tint *dst_p;\n\tgdPointF pt, src_pt;\n\tgdRect bbox;\n\tint end_x, end_y;\n\tgdInterpolationMethod interpolation_id_bak = GD_DEFAULT;\n\n\t/* These methods use special implementations */\n\tif (src->interpolation_id == GD_BILINEAR_FIXED || src->interpolation_id == GD_BICUBIC_FIXED || src->interpolation_id == GD_NEAREST_NEIGHBOUR) {\n\t\tinterpolation_id_bak = src->interpolation_id;\n\t\t\n\t\tgdImageSetInterpolationMethod(src, GD_BICUBIC);\n\t}\n\n\n\tgdImageClipRectangle(src, src_region);\n\n\tif (src_region->x > 0 || src_region->y > 0\n\t\t|| src_region->width < gdImageSX(src)\n\t\t|| src_region->height < gdImageSY(src)) {\n\t\tbackclip = 1;\n\n\t\tgdImageGetClip(src, &backup_clipx1, &backup_clipy1,\n\t\t&backup_clipx2, &backup_clipy2);\n\n\t\tgdImageSetClip(src, src_region->x, src_region->y,\n\t\t\tsrc_region->x + src_region->width - 1,\n\t\t\tsrc_region->y + src_region->height - 1);\n\t}\n\n\tif (!gdTransformAffineBoundingBox(src_region, affine, &bbox)) {\n\t\tif (backclip) {\n\t\t\tgdImageSetClip(src, backup_clipx1, backup_clipy1,\n\t\t\t\t\tbackup_clipx2, backup_clipy2);\n\t\t}\n\t\tgdImageSetInterpolationMethod(src, interpolation_id_bak);\n\t\treturn GD_FALSE;\n\t}\n\n\tgdImageGetClip(dst, &c1x, &c1y, &c2x, &c2y);\n\n\tend_x = bbox.width  + (int) fabs(bbox.x);\n\tend_y = bbox.height + (int) fabs(bbox.y);\n\n\t/* Get inverse affine to let us work with destination -> source */\n\tgdAffineInvert(inv, affine);\n\n\tsrc_offset_x =  src_region->x;\n\tsrc_offset_y =  src_region->y;\n\n\tif (dst->alphaBlendingFlag) {\n\t\tfor (y = bbox.y; y <= end_y; y++) {\n\t\t\tpt.y = y + 0.5;\n\t\t\tfor (x = 0; x <= end_x; x++) {\n\t\t\t\tpt.x = x + 0.5;\n\t\t\t\tgdAffineApplyToPointF(&src_pt, &pt, inv);\n\t\t\t\tgdImageSetPixel(dst, dst_x + x, dst_y + y, getPixelInterpolated(src, src_offset_x + src_pt.x, src_offset_y + src_pt.y, 0));\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (y = 0; y <= end_y; y++) {\n\t\t\tpt.y = y + 0.5 + bbox.y;\n\t\t\tif ((dst_y + y) < 0 || ((dst_y + y) > gdImageSY(dst) -1)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdst_p = dst->tpixels[dst_y + y] + dst_x;\n\n\t\t\tfor (x = 0; x <= end_x; x++) {\n\t\t\t\tpt.x = x + 0.5 + bbox.x;\n\t\t\t\tgdAffineApplyToPointF(&src_pt, &pt, inv);\n\n\t\t\t\tif ((dst_x + x) < 0 || (dst_x + x) > (gdImageSX(dst) - 1)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t*(dst_p++) = getPixelInterpolated(src, src_offset_x + src_pt.x, src_offset_y + src_pt.y, -1);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Restore clip if required */\n\tif (backclip) {\n\t\tgdImageSetClip(src, backup_clipx1, backup_clipy1,\n\t\t\t\tbackup_clipx2, backup_clipy2);\n\t}\n\n\tgdImageSetInterpolationMethod(src, interpolation_id_bak);\n\treturn GD_TRUE;\n}\n\n/**\n * Function: gdTransformAffineBoundingBox\n *  Returns the bounding box of an affine transformation applied to a\n *  rectangular area <gdRect>\n *\n * Parameters:\n * \tsrc - Rectangular source area for the affine transformation\n *  affine - the affine transformation\n *  bbox - the resulting bounding box\n *\n * Returns:\n *  GD_TRUE if the affine is rectilinear or GD_FALSE\n */\nBGD_DECLARE(int) gdTransformAffineBoundingBox(gdRectPtr src, const double affine[6], gdRectPtr bbox)\n{\n\tgdPointF extent[4], min, max, point;\n\tint i;\n\n\textent[0].x=0.0;\n\textent[0].y=0.0;\n\textent[1].x=(double) src->width;\n\textent[1].y=0.0;\n\textent[2].x=(double) src->width;\n\textent[2].y=(double) src->height;\n\textent[3].x=0.0;\n\textent[3].y=(double) src->height;\n\n\tfor (i=0; i < 4; i++) {\n\t\tpoint=extent[i];\n\t\tif (gdAffineApplyToPointF(&extent[i], &point, affine) != GD_TRUE) {\n\t\t\treturn GD_FALSE;\n\t\t}\n\t}\n\tmin=extent[0];\n\tmax=extent[0];\n\n\tfor (i=1; i < 4; i++) {\n\t\tif (min.x > extent[i].x)\n\t\t\tmin.x=extent[i].x;\n\t\tif (min.y > extent[i].y)\n\t\t\tmin.y=extent[i].y;\n\t\tif (max.x < extent[i].x)\n\t\t\tmax.x=extent[i].x;\n\t\tif (max.y < extent[i].y)\n\t\t\tmax.y=extent[i].y;\n\t}\n\tbbox->x = (int) min.x;\n\tbbox->y = (int) min.y;\n\tbbox->width  = (int) floor(max.x - min.x) - 1;\n\tbbox->height = (int) floor(max.y - min.y);\n\treturn GD_TRUE;\n}\n\nBGD_DECLARE(int) gdImageSetInterpolationMethod(gdImagePtr im, gdInterpolationMethod id)\n{\n\tif (im == NULL || id < 0 || id > GD_METHOD_COUNT) {\n\t\treturn 0;\n\t}\n\n\tswitch (id) {\n\t\tcase GD_DEFAULT:\n\t\t\tim->interpolation_id = GD_BILINEAR_FIXED;\n\t\t\tim->interpolation = NULL;\n\t\t\tbreak;\n\n\t\t/* Optimized versions */\n\t\tcase GD_BILINEAR_FIXED:\n\t\tcase GD_BICUBIC_FIXED:\n\t\tcase GD_NEAREST_NEIGHBOUR:\n\t\tcase GD_WEIGHTED4:\n\t\t\tim->interpolation = NULL;\n\t\t\tbreak;\n\n\t\t/* generic versions*/\n\t\tcase GD_BELL:\n\t\t\tim->interpolation = filter_bell;\n\t\t\tbreak;\n\t\tcase GD_BESSEL:\n\t\t\tim->interpolation = filter_bessel;\n\t\t\tbreak;\n\t\tcase GD_BICUBIC:\n\t\t\tim->interpolation = filter_bicubic;\n\t\t\tbreak;\n\t\tcase GD_BLACKMAN:\n\t\t\tim->interpolation = filter_blackman;\n\t\t\tbreak;\n\t\tcase GD_BOX:\n\t\t\tim->interpolation = filter_box;\n\t\t\tbreak;\n\t\tcase GD_BSPLINE:\n\t\t\tim->interpolation = filter_bspline;\n\t\t\tbreak;\n\t\tcase GD_CATMULLROM:\n\t\t\tim->interpolation = filter_catmullrom;\n\t\t\tbreak;\n\t\tcase GD_GAUSSIAN:\n\t\t\tim->interpolation = filter_gaussian;\n\t\t\tbreak;\n\t\tcase GD_GENERALIZED_CUBIC:\n\t\t\tim->interpolation = filter_generalized_cubic;\n\t\t\tbreak;\n\t\tcase GD_HERMITE:\n\t\t\tim->interpolation = filter_hermite;\n\t\t\tbreak;\n\t\tcase GD_HAMMING:\n\t\t\tim->interpolation = filter_hamming;\n\t\t\tbreak;\n\t\tcase GD_HANNING:\n\t\t\tim->interpolation = filter_hanning;\n\t\t\tbreak;\n\t\tcase GD_MITCHELL:\n\t\t\tim->interpolation = filter_mitchell;\n\t\t\tbreak;\n\t\tcase GD_POWER:\n\t\t\tim->interpolation = filter_power;\n\t\t\tbreak;\n\t\tcase GD_QUADRATIC:\n\t\t\tim->interpolation = filter_quadratic;\n\t\t\tbreak;\n\t\tcase GD_SINC:\n\t\t\tim->interpolation = filter_sinc;\n\t\t\tbreak;\n\t\tcase GD_TRIANGLE:\n\t\t\tim->interpolation = filter_triangle;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn 0;\n\t\t\tbreak;\n\t}\n\tim->interpolation_id = id;\n\treturn 1;\n}\n\n#ifdef _MSC_VER\n# pragma optimize(\"\", on)\n#endif\n", "code_before": "/*\n * The two pass scaling function is based on:\n * Filtered Image Rescaling\n * Based on Gems III\n *  - Schumacher general filtered image rescaling\n * (pp. 414-424)\n * by Dale Schumacher\n *\n * \tAdditional changes by Ray Gardener, Daylon Graphics Ltd.\n * \tDecember 4, 1999\n *\n * \tPorted to libgd by Pierre Joye. Support for multiple channels\n * \tadded (argb for now).\n *\n * \tInitial sources code is avaibable in the Gems Source Code Packages:\n * \thttp://www.acm.org/pubs/tog/GraphicsGems/GGemsIII.tar.gz\n *\n */\n\n/*\n\tSummary:\n\n\t\t- Horizontal filter contributions are calculated on the fly,\n\t\t  as each column is mapped from src to dst image. This lets\n\t\t  us omit having to allocate a temporary full horizontal stretch\n\t\t  of the src image.\n\n\t\t- If none of the src pixels within a sampling region differ,\n\t\t  then the output pixel is forced to equal (any of) the source pixel.\n\t\t  This ensures that filters do not corrupt areas of constant color.\n\n\t\t- Filter weight contribution results, after summing, are\n\t\t  rounded to the nearest pixel color value instead of\n\t\t  being casted to ILubyte (usually an int or char). Otherwise,\n\t\t  artifacting occurs.\n*/\n\n/*\n\tAdditional functions are available for simple rotation or up/downscaling.\n\tdownscaling using the fixed point implementations are usually much faster\n\tthan the existing gdImageCopyResampled while having a similar or better\n\tquality.\n\n\tFor image rotations, the optimized versions have a lazy antialiasing for\n\tthe edges of the images. For a much better antialiased result, the affine\n\tfunction is recommended.\n*/\n\n/*\nTODO:\n - Optimize pixel accesses and loops once we have continuous buffer\n - Add scale support for a portion only of an image (equivalent of copyresized/resampled)\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif /* HAVE_CONFIG_H */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n\n#undef NDEBUG\n/* Comment out this line to enable asserts.\n * TODO: This logic really belongs in cmake and configure.\n */\n#define NDEBUG 1\n#include <assert.h>\n\n#include \"gd.h\"\n#include \"gdhelpers.h\"\n#include \"gd_intern.h\"\n\n#ifdef _MSC_VER\n# pragma optimize(\"t\", on)\n# include <intrin.h>\n#endif\n\nstatic gdImagePtr gdImageScaleBilinear(gdImagePtr im,\n                                       const unsigned int new_width,\n                                       const unsigned int new_height);\nstatic gdImagePtr gdImageScaleBicubicFixed(gdImagePtr src,\n                                           const unsigned int width,\n                                           const unsigned int height);\nstatic gdImagePtr gdImageScaleNearestNeighbour(gdImagePtr im,\n                                               const unsigned int width,\n                                               const unsigned int height);\nstatic gdImagePtr gdImageRotateNearestNeighbour(gdImagePtr src,\n                                                const float degrees,\n                                                const int bgColor);\nstatic gdImagePtr gdImageRotateGeneric(gdImagePtr src, const float degrees,\n                                       const int bgColor);\n\n/* only used here, let do a generic fixed point integers later if required by other\n   part of GD */\ntypedef long gdFixed;\n/* Integer to fixed point */\n#define gd_itofx(x) ((x) << 8)\n\n/* Float to fixed point */\n#define gd_ftofx(x) (long)((x) * 256)\n\n/*  Double to fixed point */\n#define gd_dtofx(x) (long)((x) * 256)\n\n/* Fixed point to integer */\n#define gd_fxtoi(x) ((x) >> 8)\n\n/* Fixed point to float */\n# define gd_fxtof(x) ((float)(x) / 256)\n\n/* Fixed point to double */\n#define gd_fxtod(x) ((double)(x) / 256)\n\n/* Multiply a fixed by a fixed */\n#define gd_mulfx(x,y) (((x) * (y)) >> 8)\n\n/* Divide a fixed by a fixed */\n#define gd_divfx(x,y) (((x) << 8) / (y))\n\ntypedef struct _FilterInfo\n{\n  double\n    (*function)(const double,const double),\n    support;\n} FilterInfo;\n\ntypedef struct\n{\n\tdouble *Weights;  /* Normalized weights of neighboring pixels */\n\tint Left,Right;   /* Bounds of source pixels window */\n} ContributionType;  /* Contirbution information for a single pixel */\n\ntypedef struct\n{\n\tContributionType *ContribRow; /* Row (or column) of contribution weights */\n\tunsigned int WindowSize,      /* Filter window size (of affecting source pixels) */\n\t\t     LineLength;      /* Length of line (no. or rows / cols) */\n} LineContribType;\n\nstatic double KernelBessel_J1(const double x)\n{\n\tdouble p, q;\n\n\tregister long i;\n\n\tstatic const double\n\tPone[] =\n\t{\n\t\t0.581199354001606143928050809e+21,\n\t\t-0.6672106568924916298020941484e+20,\n\t\t0.2316433580634002297931815435e+19,\n\t\t-0.3588817569910106050743641413e+17,\n\t\t0.2908795263834775409737601689e+15,\n\t\t-0.1322983480332126453125473247e+13,\n\t\t0.3413234182301700539091292655e+10,\n\t\t-0.4695753530642995859767162166e+7,\n\t\t0.270112271089232341485679099e+4\n\t},\n\tQone[] =\n\t{\n\t\t0.11623987080032122878585294e+22,\n\t\t0.1185770712190320999837113348e+20,\n\t\t0.6092061398917521746105196863e+17,\n\t\t0.2081661221307607351240184229e+15,\n\t\t0.5243710262167649715406728642e+12,\n\t\t0.1013863514358673989967045588e+10,\n\t\t0.1501793594998585505921097578e+7,\n\t\t0.1606931573481487801970916749e+4,\n\t\t0.1e+1\n\t};\n\n\tp = Pone[8];\n\tq = Qone[8];\n\tfor (i=7; i >= 0; i--)\n\t{\n\t\tp = p*x*x+Pone[i];\n\t\tq = q*x*x+Qone[i];\n\t}\n\treturn (double)(p/q);\n}\n\nstatic double KernelBessel_P1(const double x)\n{\n\tdouble p, q;\n\n\tregister long i;\n\n\tstatic const double\n\tPone[] =\n\t{\n\t\t0.352246649133679798341724373e+5,\n\t\t0.62758845247161281269005675e+5,\n\t\t0.313539631109159574238669888e+5,\n\t\t0.49854832060594338434500455e+4,\n\t\t0.2111529182853962382105718e+3,\n\t\t0.12571716929145341558495e+1\n\t},\n\tQone[] =\n\t{\n\t\t0.352246649133679798068390431e+5,\n\t\t0.626943469593560511888833731e+5,\n\t\t0.312404063819041039923015703e+5,\n\t\t0.4930396490181088979386097e+4,\n\t\t0.2030775189134759322293574e+3,\n\t\t0.1e+1\n\t};\n\n\tp = Pone[5];\n\tq = Qone[5];\n\tfor (i=4; i >= 0; i--)\n\t{\n\t\tp = p*(8.0/x)*(8.0/x)+Pone[i];\n\t\tq = q*(8.0/x)*(8.0/x)+Qone[i];\n\t}\n\treturn (double)(p/q);\n}\n\nstatic double KernelBessel_Q1(const double x)\n{\n\tdouble p, q;\n\n\tregister long i;\n\n\tstatic const double\n\tPone[] =\n\t{\n\t\t0.3511751914303552822533318e+3,\n\t\t0.7210391804904475039280863e+3,\n\t\t0.4259873011654442389886993e+3,\n\t\t0.831898957673850827325226e+2,\n\t\t0.45681716295512267064405e+1,\n\t\t0.3532840052740123642735e-1\n\t},\n\tQone[] =\n\t{\n\t\t0.74917374171809127714519505e+4,\n\t\t0.154141773392650970499848051e+5,\n\t\t0.91522317015169922705904727e+4,\n\t\t0.18111867005523513506724158e+4,\n\t\t0.1038187585462133728776636e+3,\n\t\t0.1e+1\n\t};\n\n\tp = Pone[5];\n\tq = Qone[5];\n\tfor (i=4; i >= 0; i--)\n\t{\n\t\tp = p*(8.0/x)*(8.0/x)+Pone[i];\n\t\tq = q*(8.0/x)*(8.0/x)+Qone[i];\n\t}\n\treturn (double)(p/q);\n}\n\nstatic double KernelBessel_Order1(double x)\n{\n\tdouble p, q;\n\n\tif (x == 0.0)\n\t\treturn (0.0f);\n\tp = x;\n\tif (x < 0.0)\n\t\tx=(-x);\n\tif (x < 8.0)\n\t\treturn (p*KernelBessel_J1(x));\n\tq = (double)sqrt(2.0f/(M_PI*x))*(double)(KernelBessel_P1(x)*(1.0f/sqrt(2.0f)*(sin(x)-cos(x)))-8.0f/x*KernelBessel_Q1(x)*\n\t\t(-1.0f/sqrt(2.0f)*(sin(x)+cos(x))));\n\tif (p < 0.0f)\n\t\tq = (-q);\n\treturn (q);\n}\n\nstatic double filter_sinc(const double x, const double support)\n{\n\tARG_NOT_USED(support);\n\t/* X-scaled Sinc(x) function. */\n\tif (x == 0.0) return(1.0);\n\treturn (sin(M_PI * (double) x) / (M_PI * (double) x));\n}\n\nstatic double filter_bessel(const double x, const double support)\n{\n\tARG_NOT_USED(support);\n\tif (x == 0.0f)\n\t\treturn (double)(M_PI/4.0f);\n\treturn (KernelBessel_Order1((double)M_PI*x)/(2.0f*x));\n}\n\n\nstatic double filter_blackman(const double x, const double support)\n{\n\tARG_NOT_USED(support);\n\treturn (0.42f+0.5f*(double)cos(M_PI*x)+0.08f*(double)cos(2.0f*M_PI*x));\n}\n\nstatic double filter_linear(const double x, const double support) {\n\tARG_NOT_USED(support);\n\tdouble ax = fabs(x);\n\tif (ax < 1.0f) {\n\t\treturn (1.0f - ax);\n\t}\n\treturn 0.0f;\n}\n\nstatic double filter_blackman_bessel(const double x, const double support)\n{\n\tARG_NOT_USED(support);\n\treturn(filter_blackman(x/support,support)*filter_bessel(x,support));\n}\n\nstatic double filter_blackman_sinc(const double x, const double support)\n{\n\tARG_NOT_USED(support);\n\treturn(filter_blackman(x/support,support)*filter_sinc(x,support));\n}\n\n/**\n * Generalized cubic kernel (for a=-1 it is the same as BicubicKernel):\n  \\verbatim\n          /\n         | (a+2)|t|**3 - (a+3)|t|**2 + 1     , |t| <= 1\n  h(t) = | a|t|**3 - 5a|t|**2 + 8a|t| - 4a   , 1 < |t| <= 2\n         | 0                                 , otherwise\n          \\\n  \\endverbatim\n * Often used values for a are -1 and -1/2.\n */\nstatic double filter_generalized_cubic(const double t, const double support)\n{\n\tconst double a = -support;\n\tdouble abs_t = (double)fabs(t);\n\tdouble abs_t_sq = abs_t * abs_t;\n\tif (abs_t < 1) return (a + 2) * abs_t_sq * abs_t - (a + 3) * abs_t_sq + 1;\n\tif (abs_t < 2) return a * abs_t_sq * abs_t - 5 * a * abs_t_sq + 8 * a * abs_t - 4 * a;\n\treturn 0;\n}\n\n/* CubicSpline filter, default radius 2 */\nstatic double filter_cubic_spline(const double x1, const double support)\n{\n\tARG_NOT_USED(support);\n\tconst double x = x1 < 0.0 ? -x1 : x1;\n\n\tif (x < 1.0 ) {\n\t\tconst double x2 = x*x;\n\n\t\treturn (0.5 * x2 * x - x2 + 2.0 / 3.0);\n\t}\n\tif (x < 2.0) {\n\t\treturn (pow(2.0 - x, 3.0)/6.0);\n\t}\n\treturn 0;\n}\n\n\n#ifdef FUNCTION_NOT_USED_YET\n/* CubicConvolution filter, default radius 3 */\nstatic double filter_cubic_convolution(const double x1, const double support)\n{\n\tconst double x = x1 < 0.0 ? -x1 : x1;\n\tconst double x2 = x1 * x1;\n\tconst double x2_x = x2 * x;\n\tARG_NOT_USED(support);\n\tif (x <= 1.0) return ((4.0 / 3.0)* x2_x - (7.0 / 3.0) * x2 + 1.0);\n\tif (x <= 2.0) return (- (7.0 / 12.0) * x2_x + 3 * x2 - (59.0 / 12.0) * x + 2.5);\n\tif (x <= 3.0) return ( (1.0/12.0) * x2_x - (2.0 / 3.0) * x2 + 1.75 * x - 1.5);\n\treturn 0;\n}\n#endif\n\nstatic double filter_box(double x, const double support) {\n\tif (x < - support)\n\t\treturn 0.0f;\n\tif (x < support)\n\t\treturn 1.0f;\n\treturn 0.0f;\n}\n\nstatic double filter_catmullrom(const double x, const double support)\n{\n\tARG_NOT_USED(support);\n\tif (x < -2.0)\n\t\treturn(0.0f);\n\tif (x < -1.0)\n\t\treturn(0.5f*(4.0f+x*(8.0f+x*(5.0f+x))));\n\tif (x < 0.0)\n\t\treturn(0.5f*(2.0f+x*x*(-5.0f-3.0f*x)));\n\tif (x < 1.0)\n\t\treturn(0.5f*(2.0f+x*x*(-5.0f+3.0f*x)));\n\tif (x < 2.0)\n\t\treturn(0.5f*(4.0f+x*(-8.0f+x*(5.0f-x))));\n\treturn(0.0f);\n}\n\n/* Lanczos8 filter, default radius 8 */\nstatic double filter_lanczos8(const double x1, const double support)\n{\n\tconst double x = x1 < 0.0 ? -x1 : x1;\n\n\tif ( x == 0.0) return 1;\n\n\tif ( x < support) {\n\t\treturn support * sin(x*M_PI) * sin(x * M_PI/ support) / (x * M_PI * x * M_PI);\n\t}\n\treturn 0.0;\n}\n\nstatic double filter_lanczos3(const double x1, const double support)\n{\n  if (x1 < -3.0)\n    return(0.0);\n  if (x1 < 0.0)\n    return(filter_sinc(-x1,support)*filter_sinc(-x1/3.0,support));\n  if (x1 < 3.0)\n    return(filter_sinc(x1,support)*filter_sinc(x1/3.0,support));\n  return(0.0);\n}\n\n/* Hermite filter, default radius 1 */\nstatic double filter_hermite(const double x1, const double support)\n{\n\tconst double x = x1 < 0.0 ? -x1 : x1;\n\tARG_NOT_USED(support);\n\n\tif (x < 1.0) return ((2.0 * x - 3) * x * x + 1.0 );\n\n\treturn 0.0;\n}\n\n/* Trangle filter, default radius 1 */\nstatic double filter_triangle(const double x1, const double support)\n{\n\tconst double x = x1 < 0.0 ? -x1 : x1;\n\tARG_NOT_USED(support);\n\n\tif (x < 1.0) return (1.0 - x);\n\treturn 0.0;\n}\n\n/* Bell filter, default radius 1.5 */\nstatic double filter_bell(const double x1, const double support)\n{\n\tconst double x = x1 < 0.0 ? -x1 : x1;\n\tARG_NOT_USED(support);\n\n\tif (x < 0.5) return (0.75 - x*x);\n\tif (x < 1.5) return (0.5 * pow(x - 1.5, 2.0));\n\treturn 0.0;\n}\n\n/* Mitchell filter, default radius 2.0 */\nstatic double filter_mitchell(const double x, const double support)\n{\n\tARG_NOT_USED(support);\n#define KM_B (1.0f/3.0f)\n#define KM_C (1.0f/3.0f)\n#define KM_P0 ((  6.0f - 2.0f * KM_B ) / 6.0f)\n#define KM_P2 ((-18.0f + 12.0f * KM_B + 6.0f * KM_C) / 6.0f)\n#define KM_P3 (( 12.0f - 9.0f  * KM_B - 6.0f * KM_C) / 6.0f)\n#define KM_Q0 ((  8.0f * KM_B + 24.0f * KM_C) / 6.0f)\n#define KM_Q1 ((-12.0f * KM_B - 48.0f * KM_C) / 6.0f)\n#define KM_Q2 ((  6.0f * KM_B + 30.0f * KM_C) / 6.0f)\n#define KM_Q3 (( -1.0f * KM_B -  6.0f * KM_C) / 6.0f)\n\n\tif (x < -2.0)\n\t\treturn(0.0f);\n\tif (x < -1.0)\n\t\treturn(KM_Q0-x*(KM_Q1-x*(KM_Q2-x*KM_Q3)));\n\tif (x < 0.0f)\n\t\treturn(KM_P0+x*x*(KM_P2-x*KM_P3));\n\tif (x < 1.0f)\n\t\treturn(KM_P0+x*x*(KM_P2+x*KM_P3));\n\tif (x < 2.0f)\n\t\treturn(KM_Q0+x*(KM_Q1+x*(KM_Q2+x*KM_Q3)));\n\n\treturn(0.0f);\n}\n\n/* Cosine filter, default radius 1 */\nstatic double filter_cosine(const double x, const double support)\n{\n\tARG_NOT_USED(support);\n\tif ((x >= -1.0) && (x <= 1.0)) return ((cos(x * M_PI) + 1.0)/2.0);\n\n\treturn 0;\n}\n\n\n/* Quadratic filter, default radius 1.5 */\nstatic double filter_quadratic(const double x1, const double support)\n{\n\tconst double x = x1 < 0.0 ? -x1 : x1;\n\tARG_NOT_USED(support);\n\tif (x <= 0.5) return (- 2.0 * x * x + 1);\n\tif (x <= 1.5) return (x * x - 2.5* x + 1.5);\n\treturn 0.0;\n}\n\nstatic double filter_bspline(const double x, const double support)\n{\n\tARG_NOT_USED(support);\n\tif (x>2.0f) {\n\t\treturn 0.0f;\n\t} else {\n\t\tdouble a, b, c, d;\n\t\t/* Was calculated anyway cause the \"if((x-1.0f) < 0)\" */\n\t\tconst double xm1 = x - 1.0f;\n\t\tconst double xp1 = x + 1.0f;\n\t\tconst double xp2 = x + 2.0f;\n\n\t\tif ((xp2) <= 0.0f) a = 0.0f; else a = xp2*xp2*xp2;\n\t\tif ((xp1) <= 0.0f) b = 0.0f; else b = xp1*xp1*xp1;\n\t\tif (x <= 0) c = 0.0f; else c = x*x*x;\n\t\tif ((xm1) <= 0.0f) d = 0.0f; else d = xm1*xm1*xm1;\n\n\t\treturn (0.16666666666666666667f * (a - (4.0f * b) + (6.0f * c) - (4.0f * d)));\n\t}\n}\n\n/* QuadraticBSpline filter, default radius 1.5 */\nstatic double filter_quadratic_bspline(const double x1, const double support)\n{\n\tconst double x = x1 < 0.0 ? -x1 : x1;\n\tARG_NOT_USED(support);\n\tif (x <= 0.5) return (- x * x + 0.75);\n\tif (x <= 1.5) return (0.5 * x * x - 1.5 * x + 1.125);\n\treturn 0.0;\n}\n\nstatic double filter_gaussian(const double x, const double support)\n{\n\tARG_NOT_USED(support);\n\t/* return(exp((double) (-2.0 * x * x)) * sqrt(2.0 / M_PI)); */\n\treturn (double)(exp(-2.0f * x * x) * 0.79788456080287f);\n}\n\nstatic double filter_hanning(const double x, const double support)\n{\n\tARG_NOT_USED(support);\n\t/* A Cosine windowing function */\n\treturn(0.5 + 0.5 * cos(M_PI * x));\n}\n\nstatic double filter_hamming(const double x, const double support)\n{\n\tARG_NOT_USED(support);\n\t/* should be\n\t(0.54+0.46*cos(M_PI*(double) x));\n\tbut this approximation is sufficient */\n\tif (x < -1.0f)\n\t\treturn 0.0f;\n\tif (x < 0.0f)\n\t\treturn 0.92f*(-2.0f*x-3.0f)*x*x+1.0f;\n\tif (x < 1.0f)\n\t\treturn 0.92f*(2.0f*x-3.0f)*x*x+1.0f;\n\treturn 0.0f;\n}\n\nstatic double filter_power(const double x, const double support)\n{\n\tARG_NOT_USED(support);\n\tconst double a = 2.0f;\n\tif (fabs(x)>1) return 0.0f;\n\treturn (1.0f - (double)fabs(pow(x,a)));\n}\n\nstatic double filter_welsh(const double x, const double support)\n{\n\tARG_NOT_USED(support);\n\t/* Welsh parabolic windowing filter */\n\tif (x <  1.0)\n\t\treturn(1 - x*x);\n\treturn(0.0);\n}\n\n#if defined(_MSC_VER) && !defined(inline)\n# define inline __inline\n#endif\n\n/* keep it for future usage for affine copy over an existing image, targetting fix for 2.2.2 */\n#ifdef FUNCTION_NOT_USED_YET\n/* Copied from upstream's libgd */\nstatic inline int _color_blend (const int dst, const int src)\n{\n\tconst int src_alpha = gdTrueColorGetAlpha(src);\n\n\tif( src_alpha == gdAlphaOpaque ) {\n\t\treturn src;\n\t} else {\n\t\tconst int dst_alpha = gdTrueColorGetAlpha(dst);\n\n\t\tif( src_alpha == gdAlphaTransparent ) return dst;\n\t\tif( dst_alpha == gdAlphaTransparent ) {\n\t\t\treturn src;\n\t\t} else {\n\t\t\tregister int alpha, red, green, blue;\n\t\t\tconst int src_weight = gdAlphaTransparent - src_alpha;\n\t\t\tconst int dst_weight = (gdAlphaTransparent - dst_alpha) * src_alpha / gdAlphaMax;\n\t\t\tconst int tot_weight = src_weight + dst_weight;\n\n\t\t\talpha = src_alpha * dst_alpha / gdAlphaMax;\n\n\t\t\tred = (gdTrueColorGetRed(src) * src_weight\n\t\t\t\t   + gdTrueColorGetRed(dst) * dst_weight) / tot_weight;\n\t\t\tgreen = (gdTrueColorGetGreen(src) * src_weight\n\t\t\t\t   + gdTrueColorGetGreen(dst) * dst_weight) / tot_weight;\n\t\t\tblue = (gdTrueColorGetBlue(src) * src_weight\n\t\t\t\t   + gdTrueColorGetBlue(dst) * dst_weight) / tot_weight;\n\n\t\t\treturn ((alpha << 24) + (red << 16) + (green << 8) + blue);\n\t\t}\n\t}\n}\n\nstatic inline int _setEdgePixel(const gdImagePtr src, unsigned int x, unsigned int y, gdFixed coverage, const int bgColor)\n{\n\tconst gdFixed f_127 = gd_itofx(127);\n\tregister int c = src->tpixels[y][x];\n\tc = c | (( (int) (gd_fxtof(gd_mulfx(coverage, f_127)) + 50.5f)) << 24);\n\treturn _color_blend(bgColor, c);\n}\n#endif\n\nstatic inline int getPixelOverflowTC(gdImagePtr im, const int x, const int y, const int bgColor /* 31bit ARGB TC */)\n{\n\tif (gdImageBoundsSafe(im, x, y)) {\n\t\tconst int c = im->tpixels[y][x];\n\t\tif (c == im->transparent) {\n\t\t\treturn bgColor == -1 ? gdTrueColorAlpha(0, 0, 0, 127) : bgColor;\n\t\t}\n\t\treturn c;  /* 31bit ARGB TC */\n\t} else {\n\t\treturn bgColor;  /* 31bit ARGB TC */\n\t}\n}\n\n#define colorIndex2RGBA(c) gdTrueColorAlpha(im->red[(c)], im->green[(c)], im->blue[(c)], im->alpha[(c)])\n#define colorIndex2RGBcustomA(c, a) gdTrueColorAlpha(im->red[(c)], im->green[(c)], im->blue[(c)], im->alpha[(a)])\nstatic inline int getPixelOverflowPalette(gdImagePtr im, const int x, const int y, const int bgColor  /* 31bit ARGB TC */)\n{\n\tif (gdImageBoundsSafe(im, x, y)) {\n\t\tconst int c = im->pixels[y][x];\n\t\tif (c == im->transparent) {\n\t\t\treturn bgColor == -1 ? gdTrueColorAlpha(0, 0, 0, 127) : bgColor;\n\t\t}\n\t\treturn colorIndex2RGBA(c);\n\t} else {\n\t\treturn bgColor;  /* 31bit ARGB TC */\n\t}\n}\n\nstatic int getPixelInterpolateWeight(gdImagePtr im, const double x, const double y, const int bgColor)\n{\n\t/* Closest pixel <= (xf,yf) */\n\tint sx = (int)(x);\n\tint sy = (int)(y);\n\tconst double xf = x - (double)sx;\n\tconst double yf = y - (double)sy;\n\tconst double nxf = (double) 1.0 - xf;\n\tconst double nyf = (double) 1.0 - yf;\n\tconst double m1 = xf * yf;\n\tconst double m2 = nxf * yf;\n\tconst double m3 = xf * nyf;\n\tconst double m4 = nxf * nyf;\n\n\t/* get color values of neighbouring pixels */\n\tconst int c1 = im->trueColor == 1 ? getPixelOverflowTC(im, sx, sy, bgColor)         : getPixelOverflowPalette(im, sx, sy, bgColor);\n\tconst int c2 = im->trueColor == 1 ? getPixelOverflowTC(im, sx - 1, sy, bgColor)     : getPixelOverflowPalette(im, sx - 1, sy, bgColor);\n\tconst int c3 = im->trueColor == 1 ? getPixelOverflowTC(im, sx, sy - 1, bgColor)     : getPixelOverflowPalette(im, sx, sy - 1, bgColor);\n\tconst int c4 = im->trueColor == 1 ? getPixelOverflowTC(im, sx - 1, sy - 1, bgColor) : getPixelOverflowPalette(im, sx, sy - 1, bgColor);\n\tint r, g, b, a;\n\n\tif (x < 0) sx--;\n\tif (y < 0) sy--;\n\n\t/* component-wise summing-up of color values */\n\tr = (int)(m1*gdTrueColorGetRed(c1)   + m2*gdTrueColorGetRed(c2)   + m3*gdTrueColorGetRed(c3)   + m4*gdTrueColorGetRed(c4));\n\tg = (int)(m1*gdTrueColorGetGreen(c1) + m2*gdTrueColorGetGreen(c2) + m3*gdTrueColorGetGreen(c3) + m4*gdTrueColorGetGreen(c4));\n\tb = (int)(m1*gdTrueColorGetBlue(c1)  + m2*gdTrueColorGetBlue(c2)  + m3*gdTrueColorGetBlue(c3)  + m4*gdTrueColorGetBlue(c4));\n\ta = (int)(m1*gdTrueColorGetAlpha(c1) + m2*gdTrueColorGetAlpha(c2) + m3*gdTrueColorGetAlpha(c3) + m4*gdTrueColorGetAlpha(c4));\n\n\tr = CLAMP(r, 0, 255);\n\tg = CLAMP(g, 0, 255);\n\tb = CLAMP(b, 0, 255);\n\ta = CLAMP(a, 0, gdAlphaMax);\n\treturn gdTrueColorAlpha(r, g, b, a);\n}\n\n/**\n * InternalFunction: getPixelInterpolated\n *  Returns the interpolated color value using the default interpolation\n *  method. The returned color is always in the ARGB format (truecolor).\n *\n * Parameters:\n * \tim - Image to set the default interpolation method\n *  y - X value of the ideal position\n *  y - Y value of the ideal position\n *  method - Interpolation method <gdInterpolationMethod>\n *\n * Returns:\n *  the interpolated color or -1 on error\n *\n * See also:\n *  <gdSetInterpolationMethod>\n */\nstatic int getPixelInterpolated(gdImagePtr im, const double x, const double y, const int bgColor)\n{\n\tconst int xi=(int)(x);\n\tconst int yi=(int)(y);\n\tint yii;\n\tint i;\n\tdouble kernel, kernel_cache_y;\n\tdouble kernel_x[12], kernel_y[4];\n\tdouble new_r = 0.0f, new_g = 0.0f, new_b = 0.0f, new_a = 0.0f;\n\n\t/* These methods use special implementations */\n\tif (im->interpolation_id == GD_NEAREST_NEIGHBOUR) {\n\t\treturn -1;\n\t}\n\n\tif (im->interpolation_id == GD_WEIGHTED4) {\n\t\treturn getPixelInterpolateWeight(im, x, y, bgColor);\n\t}\n\n\tif (im->interpolation) {\n\t\tfor (i=0; i<4; i++) {\n\t\t\tkernel_x[i] = (double) im->interpolation((double)(xi+i-1-x), 1.0);\n\t\t\tkernel_y[i] = (double) im->interpolation((double)(yi+i-1-y), 1.0);\n\t\t}\n\t} else {\n\t\treturn -1;\n\t}\n\n\t/*\n\t * TODO: use the known fast rgba multiplication implementation once\n\t * the new formats are in place\n\t */\n\tfor (yii = yi-1; yii < yi+3; yii++) {\n\t\tint xii;\n\t\tkernel_cache_y = kernel_y[yii-(yi-1)];\n\t\tif (im->trueColor) {\n\t\t\tfor (xii=xi-1; xii<xi+3; xii++) {\n\t\t\t\tconst int rgbs = getPixelOverflowTC(im, xii, yii, bgColor);\n\n\t\t\t\tkernel = kernel_cache_y * kernel_x[xii-(xi-1)];\n\t\t\t\tnew_r += kernel * gdTrueColorGetRed(rgbs);\n\t\t\t\tnew_g += kernel * gdTrueColorGetGreen(rgbs);\n\t\t\t\tnew_b += kernel * gdTrueColorGetBlue(rgbs);\n\t\t\t\tnew_a += kernel * gdTrueColorGetAlpha(rgbs);\n\t\t\t}\n\t\t} else {\n\t\t\tfor (xii=xi-1; xii<xi+3; xii++) {\n\t\t\t\tconst int rgbs = getPixelOverflowPalette(im, xii, yii, bgColor);\n\n\t\t\t\tkernel = kernel_cache_y * kernel_x[xii-(xi-1)];\n\t\t\t\tnew_r += kernel * gdTrueColorGetRed(rgbs);\n\t\t\t\tnew_g += kernel * gdTrueColorGetGreen(rgbs);\n\t\t\t\tnew_b += kernel * gdTrueColorGetBlue(rgbs);\n\t\t\t\tnew_a += kernel * gdTrueColorGetAlpha(rgbs);\n\t\t\t}\n\t\t}\n\t}\n\n\tnew_r = CLAMP(new_r, 0, 255);\n\tnew_g = CLAMP(new_g, 0, 255);\n\tnew_b = CLAMP(new_b, 0, 255);\n\tnew_a = CLAMP(new_a, 0, gdAlphaMax);\n\n\treturn gdTrueColorAlpha(((int)new_r), ((int)new_g), ((int)new_b), ((int)new_a));\n}\n\nstatic inline LineContribType * _gdContributionsAlloc(unsigned int line_length, unsigned int windows_size)\n{\n\tunsigned int u = 0;\n\tLineContribType *res;\n\tsize_t weights_size;\n\n\tif (overflow2(windows_size, sizeof(double))) {\n\t\treturn NULL;\n\t} else {\n\t\tweights_size = windows_size * sizeof(double);\n\t}\n\tres = (LineContribType *) gdMalloc(sizeof(LineContribType));\n\tif (!res) {\n\t\treturn NULL;\n\t}\n\tres->WindowSize = windows_size;\n\tres->LineLength = line_length;\n\tif (overflow2(line_length, sizeof(ContributionType))) {\n\t\tgdFree(res);\n\t\treturn NULL;\n\t}\n\tres->ContribRow = (ContributionType *) gdMalloc(line_length * sizeof(ContributionType));\n\tif (res->ContribRow == NULL) {\n\t\tgdFree(res);\n\t\treturn NULL;\n\t}\n\tfor (u = 0 ; u < line_length ; u++) {\n\t\tres->ContribRow[u].Weights = (double *) gdMalloc(weights_size);\n\t\tif (res->ContribRow[u].Weights == NULL) {\n\t\t\tunsigned int i;\n\n\t\t\tfor (i=0;i<u;i++) {\n\t\t\t\tgdFree(res->ContribRow[i].Weights);\n\t\t\t}\n\t\t\tgdFree(res->ContribRow);\n\t\t\tgdFree(res);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn res;\n}\n\nstatic inline void _gdContributionsFree(LineContribType * p)\n{\n\tunsigned int u;\n\tfor (u = 0; u < p->LineLength; u++)  {\n\t\tgdFree(p->ContribRow[u].Weights);\n\t}\n\tgdFree(p->ContribRow);\n\tgdFree(p);\n}\n\nstatic inline LineContribType *_gdContributionsCalc(unsigned int line_size, unsigned int src_size, double scale_d,   const double support, const interpolation_method pFilter)\n{\n\tdouble width_d;\n\tdouble scale_f_d = 1.0;\n\tconst double filter_width_d = support;\n\tint windows_size;\n\tunsigned int u;\n\tLineContribType *res;\n\n\tif (scale_d < 1.0) {\n\t\twidth_d = filter_width_d / scale_d;\n\t\tscale_f_d = scale_d;\n\t}  else {\n\t\twidth_d= filter_width_d;\n\t}\n\n\twindows_size = 2 * (int)ceil(width_d) + 1;\n\tres = _gdContributionsAlloc(line_size, windows_size);\n\tif (res == NULL) {\n\t\treturn NULL;\n\t}\n\tfor (u = 0; u < line_size; u++) {\n\t\tconst double dCenter = (double)u / scale_d;\n\t\t/* get the significant edge points affecting the pixel */\n\t\tregister int iLeft = MAX(0, (int)floor (dCenter - width_d));\n\t\tint iRight = MIN((int)ceil(dCenter + width_d), (int)src_size - 1);\n\t\tdouble dTotalWeight = 0.0;\n\t\tint iSrc;\n\n\t\t/* Cut edge points to fit in filter window in case of spill-off */\n\t\tif (iRight - iLeft + 1 > windows_size)  {\n\t\t\tif (iLeft < ((int)src_size - 1 / 2))  {\n\t\t\t\tiLeft++;\n\t\t\t} else {\n\t\t\t\tiRight--;\n\t\t\t}\n\t\t}\n\n\t\tres->ContribRow[u].Left = iLeft;\n\t\tres->ContribRow[u].Right = iRight;\n\n\t\tfor (iSrc = iLeft; iSrc <= iRight; iSrc++) {\n\t\t\tdTotalWeight += (res->ContribRow[u].Weights[iSrc-iLeft] =  scale_f_d * (*pFilter)(scale_f_d * (dCenter - (double)iSrc), support));\n\t\t}\n\n\t\tif (dTotalWeight < 0.0) {\n\t\t\t_gdContributionsFree(res);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (dTotalWeight > 0.0) {\n\t\t\tfor (iSrc = iLeft; iSrc <= iRight; iSrc++) {\n\t\t\t\tres->ContribRow[u].Weights[iSrc-iLeft] /= dTotalWeight;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\n\nstatic inline void\n_gdScaleOneAxis(gdImagePtr pSrc, gdImagePtr dst,\n\t\t\t\tunsigned int dst_len, unsigned int row, LineContribType *contrib,\n\t\t\t\tgdAxis axis)\n{\n\tunsigned int ndx;\n\n\tfor (ndx = 0; ndx < dst_len; ndx++) {\n\t\tdouble r = 0, g = 0, b = 0, a = 0;\n\t\tconst int left = contrib->ContribRow[ndx].Left;\n\t\tconst int right = contrib->ContribRow[ndx].Right;\n\t\tint *dest = (axis == HORIZONTAL) ?\n\t\t\t&dst->tpixels[row][ndx] :\n\t\t\t&dst->tpixels[ndx][row];\n\n\t\tint i;\n\n\t\t/* Accumulate each channel */\n\t\tfor (i = left; i <= right; i++) {\n\t\t\tconst int left_channel = i - left;\n\t\t\tconst int srcpx = (axis == HORIZONTAL) ?\n\t\t\t\tpSrc->tpixels[row][i] :\n\t\t\t\tpSrc->tpixels[i][row];\n\n\t\t\tr += contrib->ContribRow[ndx].Weights[left_channel]\n\t\t\t\t* (double)(gdTrueColorGetRed(srcpx));\n\t\t\tg += contrib->ContribRow[ndx].Weights[left_channel]\n\t\t\t\t* (double)(gdTrueColorGetGreen(srcpx));\n\t\t\tb += contrib->ContribRow[ndx].Weights[left_channel]\n\t\t\t\t* (double)(gdTrueColorGetBlue(srcpx));\n\t\t\ta += contrib->ContribRow[ndx].Weights[left_channel]\n\t\t\t\t* (double)(gdTrueColorGetAlpha(srcpx));\n\t\t}/* for */\n\n\t\t*dest = gdTrueColorAlpha(uchar_clamp(r, 0xFF), uchar_clamp(g, 0xFF),\n                                 uchar_clamp(b, 0xFF),\n                                 uchar_clamp(a, 0x7F)); /* alpha is 0..127 */\n\t}/* for */\n}/* _gdScaleOneAxis*/\n\n\nstatic inline int\n_gdScalePass(const gdImagePtr pSrc, const unsigned int src_len,\n             const gdImagePtr pDst, const unsigned int dst_len,\n             const unsigned int num_lines,\n             const gdAxis axis,\n\t\t\t const FilterInfo *filter)\n{\n\tunsigned int line_ndx;\n\tLineContribType * contrib;\n\n    /* Same dim, just copy it. */\n    assert(dst_len != src_len); // TODO: caller should handle this.\n\n\tcontrib = _gdContributionsCalc(dst_len, src_len,\n                                   (double)dst_len / (double)src_len,\n\t\t\t\t\t\t\t\t   filter->support,\n                                   filter->function);\n\tif (contrib == NULL) {\n\t\treturn 0;\n\t}\n\n\t/* Scale each line */\n    for (line_ndx = 0; line_ndx < num_lines; line_ndx++) {\n        _gdScaleOneAxis(pSrc, pDst, dst_len, line_ndx, contrib, axis);\n\t}\n\t_gdContributionsFree (contrib);\n    return 1;\n}/* _gdScalePass*/\n\nstatic const FilterInfo filters[GD_METHOD_COUNT+1] =\n{\n\t{ filter_box, 0.0 },\n\t{ filter_bell, 1.5 },\n\t{ filter_bessel, 0.0 },\n\t{ NULL, 0.0 }, /* NA bilenear/bilinear fixed */\n\t{ NULL, 0.0 }, /* NA bicubic */\n\t{ NULL, 0.0 }, /* NA bicubic fixed */\n\t{ filter_blackman, 1.0 },\n\t{ filter_box, 0.5 },\n\t{ filter_bspline, 1.5 },\n\t{ filter_catmullrom, 2.0 },\n\t{ filter_gaussian, 1.25 },\n\t{ filter_generalized_cubic, 0.5 },\n\t{ filter_hermite, 1.0 },\n\t{ filter_hamming, 1.0 },\n\t{ filter_hanning, 1.0 },\n\t{ filter_mitchell, 2.0 },\n\t{ NULL, 0.0}, /* NA Nearest */\n\t{ filter_power, 0.0 },\n\t{ filter_quadratic, 1.5 },\n\t{ filter_sinc, 1.0 },\n\t{ filter_triangle, 1.0 },\n\t{ NULL, 1.0 }, /* NA weighted4 */\n\t{ filter_linear, 1.0 },\n\t{ filter_lanczos3, 3.0 },\n\t{ filter_lanczos8, 8.0 },\n\t{ filter_blackman_bessel, 3.2383 },\n\t{ filter_blackman_sinc, 4.0 },\n\t{ filter_quadratic_bspline, 1.5},\n\t{ filter_cubic_spline, 0.0 },\n\t{ filter_cosine, 0.0},\n\t{ filter_welsh, 0.0},\n};\n\nstatic const FilterInfo* _get_filterinfo_for_id(gdInterpolationMethod id) {\n\t\n\tif (id >=GD_METHOD_COUNT) {\n\t\tid = GD_DEFAULT;\n\t}\n\treturn &filters[id];\n}\n\nstatic gdImagePtr\ngdImageScaleTwoPass(const gdImagePtr src, const unsigned int new_width,\n                    const unsigned int new_height)\n{\n    const unsigned int src_width = src->sx;\n    const unsigned int src_height = src->sy;\n\tgdImagePtr tmp_im = NULL;\n\tgdImagePtr dst = NULL;\n\tint scale_pass_res;\n\tconst FilterInfo *filter = _get_filterinfo_for_id(src->interpolation_id);\n\n    /* First, handle the trivial case. */\n    if (src_width == new_width && src_height == new_height) {\n        return gdImageClone(src);\n    }/* if */\n\n\t/* Convert to truecolor if it isn't; this code requires it. */\n\tif (!src->trueColor) {\n\t\tgdImagePaletteToTrueColor(src);\n\t}/* if */\n\n    /* Scale horizontally unless sizes are the same. */\n    if (src_width == new_width) {\n        tmp_im = src;\n    } else {\n\n        tmp_im = gdImageCreateTrueColor(new_width, src_height);\n        if (tmp_im == NULL) {\n            return NULL;\n        }\n        gdImageSetInterpolationMethod(tmp_im, src->interpolation_id);\n\n\t\tscale_pass_res = _gdScalePass(src, src_width, tmp_im, new_width, src_height, HORIZONTAL, filter);\n\t\tif (scale_pass_res != 1) {\n\t\t\tgdImageDestroy(tmp_im);\n\t\t\treturn NULL;\n\t\t}\n    }/* if .. else*/\n\n    /* If vertical sizes match, we're done. */\n    if (src_height == new_height) {\n        assert(tmp_im != src);\n        return tmp_im;\n    }/* if */\n\n    /* Otherwise, we need to scale vertically. */\n\tdst = gdImageCreateTrueColor(new_width, new_height);\n\tif (dst != NULL) {\n        gdImageSetInterpolationMethod(dst, src->interpolation_id);\n        scale_pass_res = _gdScalePass(tmp_im, src_height, dst, new_height, new_width, VERTICAL, filter);\n\t\tif (scale_pass_res != 1) {\n\t\t\tgdImageDestroy(dst);\n\t\t\tif (src != tmp_im) {\n\t\t\t\tgdImageDestroy(tmp_im);\n\t\t\t}\n\t\t\treturn NULL;\n\t   }\n    }/* if */\n\n\n\tif (src != tmp_im) {\n        gdImageDestroy(tmp_im);\n    }/* if */\n\n\treturn dst;\n}/* gdImageScaleTwoPass*/\n\n\n/*\n\tBilinearFixed, BicubicFixed and nearest implementations are\n\trewamped versions of the implementation in CBitmapEx\n\n\thttp://www.codeproject.com/Articles/29121/CBitmapEx-Free-C-Bitmap-Manipulation-Class\n\n\tInteger only implementation, good to have for common usages like\n\tpre scale very large images before using another interpolation\n\tmethods for the last step.\n*/\nstatic gdImagePtr\ngdImageScaleNearestNeighbour(gdImagePtr im, const unsigned int width, const unsigned int height)\n{\n\tconst unsigned long new_width = MAX(1, width);\n\tconst unsigned long new_height = MAX(1, height);\n\tconst float dx = (float)im->sx / (float)new_width;\n\tconst float dy = (float)im->sy / (float)new_height;\n\tconst gdFixed f_dx = gd_ftofx(dx);\n\tconst gdFixed f_dy = gd_ftofx(dy);\n\n\tgdImagePtr dst_img;\n\tunsigned long  dst_offset_x;\n\tunsigned long  dst_offset_y = 0;\n\tunsigned int i;\n\n\tdst_img = gdImageCreateTrueColor(new_width, new_height);\n\n\tif (dst_img == NULL) {\n\t\treturn NULL;\n\t}\n\n\tfor (i=0; i<new_height; i++) {\n\t\tunsigned int j;\n\t\tdst_offset_x = 0;\n\t\tif (im->trueColor) {\n\t\t\tfor (j=0; j<new_width; j++) {\n\t\t\t\tconst gdFixed f_i = gd_itofx(i);\n\t\t\t\tconst gdFixed f_j = gd_itofx(j);\n\t\t\t\tconst gdFixed f_a = gd_mulfx(f_i, f_dy);\n\t\t\t\tconst gdFixed f_b = gd_mulfx(f_j, f_dx);\n\t\t\t\tconst long m = gd_fxtoi(f_a);\n\t\t\t\tconst long n = gd_fxtoi(f_b);\n\n\t\t\t\tdst_img->tpixels[dst_offset_y][dst_offset_x++] = im->tpixels[m][n];\n\t\t\t}\n\t\t} else {\n\t\t\tfor (j=0; j<new_width; j++) {\n\t\t\t\tconst gdFixed f_i = gd_itofx(i);\n\t\t\t\tconst gdFixed f_j = gd_itofx(j);\n\t\t\t\tconst gdFixed f_a = gd_mulfx(f_i, f_dy);\n\t\t\t\tconst gdFixed f_b = gd_mulfx(f_j, f_dx);\n\t\t\t\tconst long m = gd_fxtoi(f_a);\n\t\t\t\tconst long n = gd_fxtoi(f_b);\n\n\t\t\t\tdst_img->tpixels[dst_offset_y][dst_offset_x++] = colorIndex2RGBA(im->pixels[m][n]);\n\t\t\t}\n\t\t}\n\t\tdst_offset_y++;\n\t}\n\treturn dst_img;\n}\n\n#if 0\nstatic inline int getPixelOverflowColorTC(gdImagePtr im, const int x, const int y, const int color)\n{\n\tif (gdImageBoundsSafe(im, x, y)) {\n\t\tconst int c = im->tpixels[y][x];\n\t\tif (c == im->transparent) {\n\t\t\treturn gdTrueColorAlpha(0, 0, 0, 127);\n\t\t}\n\t\treturn c;\n\t} else {\n\t\tregister int border = 0;\n\t\tif (y < im->cy1) {\n\t\t\tborder = im->tpixels[0][im->cx1];\n\t\t\tgoto processborder;\n\t\t}\n\n\t\tif (y < im->cy1) {\n\t\t\tborder = im->tpixels[0][im->cx1];\n\t\t\tgoto processborder;\n\t\t}\n\n\t\tif (y > im->cy2) {\n\t\t\tif (x >= im->cx1 && x <= im->cx1) {\n\t\t\t\tborder = im->tpixels[im->cy2][x];\n\t\t\t\tgoto processborder;\n\t\t\t} else {\n\t\t\t\treturn gdTrueColorAlpha(0, 0, 0, 127);\n\t\t\t}\n\t\t}\n\n\t\t/* y is bound safe at this point */\n\t\tif (x < im->cx1) {\n\t\t\tborder = im->tpixels[y][im->cx1];\n\t\t\tgoto processborder;\n\t\t}\n\n\t\tif (x > im->cx2) {\n\t\t\tborder = im->tpixels[y][im->cx2];\n\t\t}\n\nprocessborder:\n\t\tif (border == im->transparent) {\n\t\t\treturn gdTrueColorAlpha(0, 0, 0, 127);\n\t\t} else{\n\t\t\treturn gdTrueColorAlpha(gdTrueColorGetRed(border), gdTrueColorGetGreen(border), gdTrueColorGetBlue(border), 127);\n\t\t}\n\t}\n}\n#endif\n\nstatic gdImagePtr gdImageScaleBilinearPalette(gdImagePtr im, const unsigned int new_width, const unsigned int new_height)\n{\n\tlong _width = MAX(1, new_width);\n\tlong _height = MAX(1, new_height);\n\tfloat dx = (float)gdImageSX(im) / (float)_width;\n\tfloat dy = (float)gdImageSY(im) / (float)_height;\n\tgdFixed f_dx = gd_ftofx(dx);\n\tgdFixed f_dy = gd_ftofx(dy);\n\tgdFixed f_1 = gd_itofx(1);\n\n\tint dst_offset_h;\n\tint dst_offset_v = 0;\n\tlong i;\n\tgdImagePtr new_img;\n\tconst int transparent = im->transparent;\n\n\tnew_img = gdImageCreateTrueColor(new_width, new_height);\n\tif (new_img == NULL) {\n\t\treturn NULL;\n\t}\n\n\tif (transparent < 0) {\n\t\t/* uninitialized */\n\t\tnew_img->transparent = -1;\n\t} else {\n\t\tnew_img->transparent = gdTrueColorAlpha(im->red[transparent], im->green[transparent], im->blue[transparent], im->alpha[transparent]);\n\t}\n\n\tfor (i=0; i < _height; i++) {\n\t\tlong j;\n\t\tconst gdFixed f_i = gd_itofx(i);\n\t\tconst gdFixed f_a = gd_mulfx(f_i, f_dy);\n\t\tregister long m = gd_fxtoi(f_a);\n\n\t\tdst_offset_h = 0;\n\n\t\tfor (j=0; j < _width; j++) {\n\t\t\t/* Update bitmap */\n\t\t\tgdFixed f_j = gd_itofx(j);\n\t\t\tgdFixed f_b = gd_mulfx(f_j, f_dx);\n\n\t\t\tconst long n = gd_fxtoi(f_b);\n\t\t\tgdFixed f_f = f_a - gd_itofx(m);\n\t\t\tgdFixed f_g = f_b - gd_itofx(n);\n\n\t\t\tconst gdFixed f_w1 = gd_mulfx(f_1-f_f, f_1-f_g);\n\t\t\tconst gdFixed f_w2 = gd_mulfx(f_1-f_f, f_g);\n\t\t\tconst gdFixed f_w3 = gd_mulfx(f_f, f_1-f_g);\n\t\t\tconst gdFixed f_w4 = gd_mulfx(f_f, f_g);\n\t\t\tunsigned int pixel1;\n\t\t\tunsigned int pixel2;\n\t\t\tunsigned int pixel3;\n\t\t\tunsigned int pixel4;\n\t\t\tregister gdFixed f_r1, f_r2, f_r3, f_r4,\n\t\t\t\t\tf_g1, f_g2, f_g3, f_g4,\n\t\t\t\t\tf_b1, f_b2, f_b3, f_b4,\n\t\t\t\t\tf_a1, f_a2, f_a3, f_a4;\n\n\t\t\t/* 0 for bgColor; (n,m) is supposed to be valid anyway */\n\t\t\tpixel1 = getPixelOverflowPalette(im, n, m, 0);\n\t\t\tpixel2 = getPixelOverflowPalette(im, n + 1, m, pixel1);\n\t\t\tpixel3 = getPixelOverflowPalette(im, n, m + 1, pixel1);\n\t\t\tpixel4 = getPixelOverflowPalette(im, n + 1, m + 1, pixel1);\n\n\t\t\tf_r1 = gd_itofx(gdTrueColorGetRed(pixel1));\n\t\t\tf_r2 = gd_itofx(gdTrueColorGetRed(pixel2));\n\t\t\tf_r3 = gd_itofx(gdTrueColorGetRed(pixel3));\n\t\t\tf_r4 = gd_itofx(gdTrueColorGetRed(pixel4));\n\t\t\tf_g1 = gd_itofx(gdTrueColorGetGreen(pixel1));\n\t\t\tf_g2 = gd_itofx(gdTrueColorGetGreen(pixel2));\n\t\t\tf_g3 = gd_itofx(gdTrueColorGetGreen(pixel3));\n\t\t\tf_g4 = gd_itofx(gdTrueColorGetGreen(pixel4));\n\t\t\tf_b1 = gd_itofx(gdTrueColorGetBlue(pixel1));\n\t\t\tf_b2 = gd_itofx(gdTrueColorGetBlue(pixel2));\n\t\t\tf_b3 = gd_itofx(gdTrueColorGetBlue(pixel3));\n\t\t\tf_b4 = gd_itofx(gdTrueColorGetBlue(pixel4));\n\t\t\tf_a1 = gd_itofx(gdTrueColorGetAlpha(pixel1));\n\t\t\tf_a2 = gd_itofx(gdTrueColorGetAlpha(pixel2));\n\t\t\tf_a3 = gd_itofx(gdTrueColorGetAlpha(pixel3));\n\t\t\tf_a4 = gd_itofx(gdTrueColorGetAlpha(pixel4));\n\n\t\t\t{\n\t\t\t\tconst unsigned char red = (unsigned char) gd_fxtoi(gd_mulfx(f_w1, f_r1) + gd_mulfx(f_w2, f_r2) + gd_mulfx(f_w3, f_r3) + gd_mulfx(f_w4, f_r4));\n\t\t\t\tconst unsigned char green = (unsigned char) gd_fxtoi(gd_mulfx(f_w1, f_g1) + gd_mulfx(f_w2, f_g2) + gd_mulfx(f_w3, f_g3) + gd_mulfx(f_w4, f_g4));\n\t\t\t\tconst unsigned char blue = (unsigned char) gd_fxtoi(gd_mulfx(f_w1, f_b1) + gd_mulfx(f_w2, f_b2) + gd_mulfx(f_w3, f_b3) + gd_mulfx(f_w4, f_b4));\n\t\t\t\tconst unsigned char alpha = (unsigned char) gd_fxtoi(gd_mulfx(f_w1, f_a1) + gd_mulfx(f_w2, f_a2) + gd_mulfx(f_w3, f_a3) + gd_mulfx(f_w4, f_a4));\n\n\t\t\t\tnew_img->tpixels[dst_offset_v][dst_offset_h] = gdTrueColorAlpha(red, green, blue, alpha);\n\t\t\t}\n\n\t\t\tdst_offset_h++;\n\t\t}\n\n\t\tdst_offset_v++;\n\t}\n\treturn new_img;\n}\n\nstatic gdImagePtr gdImageScaleBilinearTC(gdImagePtr im, const unsigned int new_width, const unsigned int new_height)\n{\n\tlong dst_w = MAX(1, new_width);\n\tlong dst_h = MAX(1, new_height);\n\tfloat dx = (float)gdImageSX(im) / (float)dst_w;\n\tfloat dy = (float)gdImageSY(im) / (float)dst_h;\n\tgdFixed f_dx = gd_ftofx(dx);\n\tgdFixed f_dy = gd_ftofx(dy);\n\tgdFixed f_1 = gd_itofx(1);\n\n\tint dst_offset_h;\n\tint dst_offset_v = 0;\n\tlong i;\n\tgdImagePtr new_img;\n\n\tnew_img = gdImageCreateTrueColor(new_width, new_height);\n\tif (!new_img){\n\t\treturn NULL;\n\t}\n\n\tfor (i=0; i < dst_h; i++) {\n\t\tlong j;\n\t\tdst_offset_h = 0;\n\t\tfor (j=0; j < dst_w; j++) {\n\t\t\t/* Update bitmap */\n\t\t\tgdFixed f_i = gd_itofx(i);\n\t\t\tgdFixed f_j = gd_itofx(j);\n\t\t\tgdFixed f_a = gd_mulfx(f_i, f_dy);\n\t\t\tgdFixed f_b = gd_mulfx(f_j, f_dx);\n\t\t\tconst long m = gd_fxtoi(f_a);\n\t\t\tconst long n = gd_fxtoi(f_b);\n\t\t\tgdFixed f_f = f_a - gd_itofx(m);\n\t\t\tgdFixed f_g = f_b - gd_itofx(n);\n\n\t\t\tconst gdFixed f_w1 = gd_mulfx(f_1-f_f, f_1-f_g);\n\t\t\tconst gdFixed f_w2 = gd_mulfx(f_1-f_f, f_g);\n\t\t\tconst gdFixed f_w3 = gd_mulfx(f_f, f_1-f_g);\n\t\t\tconst gdFixed f_w4 = gd_mulfx(f_f, f_g);\n\t\t\tunsigned int pixel1;\n\t\t\tunsigned int pixel2;\n\t\t\tunsigned int pixel3;\n\t\t\tunsigned int pixel4;\n\t\t\tregister gdFixed f_r1, f_r2, f_r3, f_r4,\n\t\t\t\t\tf_g1, f_g2, f_g3, f_g4,\n\t\t\t\t\tf_b1, f_b2, f_b3, f_b4,\n\t\t\t\t\tf_a1, f_a2, f_a3, f_a4;\n\t\t\t/* 0 for bgColor; (n,m) is supposed to be valid anyway */\n\t\t\tpixel1 = getPixelOverflowTC(im, n, m, 0);\n\t\t\tpixel2 = getPixelOverflowTC(im, n + 1, m, pixel1);\n\t\t\tpixel3 = getPixelOverflowTC(im, n, m + 1, pixel1);\n\t\t\tpixel4 = getPixelOverflowTC(im, n + 1, m + 1, pixel1);\n\n\t\t\tf_r1 = gd_itofx(gdTrueColorGetRed(pixel1));\n\t\t\tf_r2 = gd_itofx(gdTrueColorGetRed(pixel2));\n\t\t\tf_r3 = gd_itofx(gdTrueColorGetRed(pixel3));\n\t\t\tf_r4 = gd_itofx(gdTrueColorGetRed(pixel4));\n\t\t\tf_g1 = gd_itofx(gdTrueColorGetGreen(pixel1));\n\t\t\tf_g2 = gd_itofx(gdTrueColorGetGreen(pixel2));\n\t\t\tf_g3 = gd_itofx(gdTrueColorGetGreen(pixel3));\n\t\t\tf_g4 = gd_itofx(gdTrueColorGetGreen(pixel4));\n\t\t\tf_b1 = gd_itofx(gdTrueColorGetBlue(pixel1));\n\t\t\tf_b2 = gd_itofx(gdTrueColorGetBlue(pixel2));\n\t\t\tf_b3 = gd_itofx(gdTrueColorGetBlue(pixel3));\n\t\t\tf_b4 = gd_itofx(gdTrueColorGetBlue(pixel4));\n\t\t\tf_a1 = gd_itofx(gdTrueColorGetAlpha(pixel1));\n\t\t\tf_a2 = gd_itofx(gdTrueColorGetAlpha(pixel2));\n\t\t\tf_a3 = gd_itofx(gdTrueColorGetAlpha(pixel3));\n\t\t\tf_a4 = gd_itofx(gdTrueColorGetAlpha(pixel4));\n\t\t\t{\n\t\t\t\tconst unsigned char red   = (unsigned char) gd_fxtoi(gd_mulfx(f_w1, f_r1) + gd_mulfx(f_w2, f_r2) + gd_mulfx(f_w3, f_r3) + gd_mulfx(f_w4, f_r4));\n\t\t\t\tconst unsigned char green = (unsigned char) gd_fxtoi(gd_mulfx(f_w1, f_g1) + gd_mulfx(f_w2, f_g2) + gd_mulfx(f_w3, f_g3) + gd_mulfx(f_w4, f_g4));\n\t\t\t\tconst unsigned char blue  = (unsigned char) gd_fxtoi(gd_mulfx(f_w1, f_b1) + gd_mulfx(f_w2, f_b2) + gd_mulfx(f_w3, f_b3) + gd_mulfx(f_w4, f_b4));\n\t\t\t\tconst unsigned char alpha = (unsigned char) gd_fxtoi(gd_mulfx(f_w1, f_a1) + gd_mulfx(f_w2, f_a2) + gd_mulfx(f_w3, f_a3) + gd_mulfx(f_w4, f_a4));\n\n\t\t\t\tnew_img->tpixels[dst_offset_v][dst_offset_h] = gdTrueColorAlpha(red, green, blue, alpha);\n\t\t\t}\n\n\t\t\tdst_offset_h++;\n\t\t}\n\n\t\tdst_offset_v++;\n\t}\n\treturn new_img;\n}\n\nstatic gdImagePtr\ngdImageScaleBilinear(gdImagePtr im, const unsigned int new_width,\n                     const unsigned int new_height)\n{\n\tif (im->trueColor) {\n\t\treturn gdImageScaleBilinearTC(im, new_width, new_height);\n\t} else {\n\t\treturn gdImageScaleBilinearPalette(im, new_width, new_height);\n\t}\n}\n\nstatic gdImagePtr\ngdImageScaleBicubicFixed(gdImagePtr src, const unsigned int width,\n                         const unsigned int height)\n{\n\tconst long new_width = MAX(1, width);\n\tconst long new_height = MAX(1, height);\n\tconst int src_w = gdImageSX(src);\n\tconst int src_h = gdImageSY(src);\n\tconst gdFixed f_dx = gd_ftofx((float)src_w / (float)new_width);\n\tconst gdFixed f_dy = gd_ftofx((float)src_h / (float)new_height);\n\tconst gdFixed f_1 = gd_itofx(1);\n\tconst gdFixed f_2 = gd_itofx(2);\n\tconst gdFixed f_4 = gd_itofx(4);\n\tconst gdFixed f_6 = gd_itofx(6);\n\tconst gdFixed f_gamma = gd_ftofx(1.04f);\n\tgdImagePtr dst;\n\n\tunsigned int dst_offset_x;\n\tunsigned int dst_offset_y = 0;\n\tlong i;\n\n\t/* impact perf a bit, but not that much. Implementation for palette\n\t   images can be done at a later point.\n\t*/\n\tif (src->trueColor == 0) {\n\t\tgdImagePaletteToTrueColor(src);\n\t}\n\n\tdst = gdImageCreateTrueColor(new_width, new_height);\n\tif (!dst) {\n\t\treturn NULL;\n\t}\n\n\tdst->saveAlphaFlag = 1;\n\n\tfor (i=0; i < new_height; i++) {\n\t\tlong j;\n\t\tdst_offset_x = 0;\n\n\t\tfor (j=0; j < new_width; j++) {\n\t\t\tconst gdFixed f_a = gd_mulfx(gd_itofx(i), f_dy);\n\t\t\tconst gdFixed f_b = gd_mulfx(gd_itofx(j), f_dx);\n\t\t\tconst long m = gd_fxtoi(f_a);\n\t\t\tconst long n = gd_fxtoi(f_b);\n\t\t\tconst gdFixed f_f = f_a - gd_itofx(m);\n\t\t\tconst gdFixed f_g = f_b - gd_itofx(n);\n\t\t\tunsigned int src_offset_x[16], src_offset_y[16];\n\t\t\tlong k;\n\t\t\tregister gdFixed f_red = 0, f_green = 0, f_blue = 0, f_alpha = 0;\n\t\t\tunsigned char red, green, blue, alpha = 0;\n\t\t\tint *dst_row = dst->tpixels[dst_offset_y];\n\n\t\t\tif ((m < 1) || (n < 1)) {\n\t\t\t\tsrc_offset_x[0] = n;\n\t\t\t\tsrc_offset_y[0] = m;\n\t\t\t} else {\n\t\t\t\tsrc_offset_x[0] = n - 1;\n\t\t\t\tsrc_offset_y[0] = m;\n\t\t\t}\n\n\t\t\tsrc_offset_x[1] = n;\n\t\t\tsrc_offset_y[1] = m;\n\n\t\t\tif ((m < 1) || (n >= src_w - 1)) {\n\t\t\t\tsrc_offset_x[2] = n;\n\t\t\t\tsrc_offset_y[2] = m;\n\t\t\t} else {\n\t\t\t\tsrc_offset_x[2] = n + 1;\n\t\t\t\tsrc_offset_y[2] = m;\n\t\t\t}\n\n\t\t\tif ((m < 1) || (n >= src_w - 2)) {\n\t\t\t\tsrc_offset_x[3] = n;\n\t\t\t\tsrc_offset_y[3] = m;\n\t\t\t} else {\n\t\t\t\tsrc_offset_x[3] = n + 1 + 1;\n\t\t\t\tsrc_offset_y[3] = m;\n\t\t\t}\n\n\t\t\tif (n < 1) {\n\t\t\t\tsrc_offset_x[4] = n;\n\t\t\t\tsrc_offset_y[4] = m;\n\t\t\t} else {\n\t\t\t\tsrc_offset_x[4] = n - 1;\n\t\t\t\tsrc_offset_y[4] = m;\n\t\t\t}\n\n\t\t\tsrc_offset_x[5] = n;\n\t\t\tsrc_offset_y[5] = m;\n\t\t\tif (n >= src_w-1) {\n\t\t\t\tsrc_offset_x[6] = n;\n\t\t\t\tsrc_offset_y[6] = m;\n\t\t\t} else {\n\t\t\t\tsrc_offset_x[6] = n + 1;\n\t\t\t\tsrc_offset_y[6] = m;\n\t\t\t}\n\n\t\t\tif (n >= src_w - 2) {\n\t\t\t\tsrc_offset_x[7] = n;\n\t\t\t\tsrc_offset_y[7] = m;\n\t\t\t} else {\n\t\t\t\tsrc_offset_x[7] = n + 1 + 1;\n\t\t\t\tsrc_offset_y[7] = m;\n\t\t\t}\n\n\t\t\tif ((m >= src_h - 1) || (n < 1)) {\n\t\t\t\tsrc_offset_x[8] = n;\n\t\t\t\tsrc_offset_y[8] = m;\n\t\t\t} else {\n\t\t\t\tsrc_offset_x[8] = n - 1;\n\t\t\t\tsrc_offset_y[8] = m;\n\t\t\t}\n\n\t\t\tsrc_offset_x[9] = n;\n\t\t\tsrc_offset_y[9] = m;\n\n\t\t\tif ((m >= src_h-1) || (n >= src_w-1)) {\n\t\t\t\tsrc_offset_x[10] = n;\n\t\t\t\tsrc_offset_y[10] = m;\n\t\t\t} else {\n\t\t\t\tsrc_offset_x[10] = n + 1;\n\t\t\t\tsrc_offset_y[10] = m;\n\t\t\t}\n\n\t\t\tif ((m >= src_h - 1) || (n >= src_w - 2)) {\n\t\t\t\tsrc_offset_x[11] = n;\n\t\t\t\tsrc_offset_y[11] = m;\n\t\t\t} else {\n\t\t\t\tsrc_offset_x[11] = n + 1 + 1;\n\t\t\t\tsrc_offset_y[11] = m;\n\t\t\t}\n\n\t\t\tif ((m >= src_h - 2) || (n < 1)) {\n\t\t\t\tsrc_offset_x[12] = n;\n\t\t\t\tsrc_offset_y[12] = m;\n\t\t\t} else {\n\t\t\t\tsrc_offset_x[12] = n - 1;\n\t\t\t\tsrc_offset_y[12] = m;\n\t\t\t}\n\n\t\t\tif (!(m >= src_h - 2)) {\n\t\t\t\tsrc_offset_x[13] = n;\n\t\t\t\tsrc_offset_y[13] = m;\n\t\t\t}\n\n\t\t\tif ((m >= src_h - 2) || (n >= src_w - 1)) {\n\t\t\t\tsrc_offset_x[14] = n;\n\t\t\t\tsrc_offset_y[14] = m;\n\t\t\t} else {\n\t\t\t\tsrc_offset_x[14] = n + 1;\n\t\t\t\tsrc_offset_y[14] = m;\n\t\t\t}\n\n\t\t\tif ((m >= src_h - 2) || (n >= src_w - 2)) {\n\t\t\t\tsrc_offset_x[15] = n;\n\t\t\t\tsrc_offset_y[15] = m;\n\t\t\t} else {\n\t\t\t\tsrc_offset_x[15] = n  + 1 + 1;\n\t\t\t\tsrc_offset_y[15] = m;\n\t\t\t}\n\n\t\t\tfor (k = -1; k < 3; k++) {\n\t\t\t\tconst gdFixed f = gd_itofx(k)-f_f;\n\t\t\t\tconst gdFixed f_fm1 = f - f_1;\n\t\t\t\tconst gdFixed f_fp1 = f + f_1;\n\t\t\t\tconst gdFixed f_fp2 = f + f_2;\n\t\t\t\tregister gdFixed f_a = 0, f_b = 0, f_d = 0, f_c = 0;\n\t\t\t\tregister gdFixed f_RY;\n\t\t\t\tint l;\n\n\t\t\t\tif (f_fp2 > 0) f_a = gd_mulfx(f_fp2, gd_mulfx(f_fp2,f_fp2));\n\t\t\t\tif (f_fp1 > 0) f_b = gd_mulfx(f_fp1, gd_mulfx(f_fp1,f_fp1));\n\t\t\t\tif (f > 0)     f_c = gd_mulfx(f, gd_mulfx(f,f));\n\t\t\t\tif (f_fm1 > 0) f_d = gd_mulfx(f_fm1, gd_mulfx(f_fm1,f_fm1));\n\n\t\t\t\tf_RY = gd_divfx((f_a - gd_mulfx(f_4,f_b) + gd_mulfx(f_6,f_c) - gd_mulfx(f_4,f_d)),f_6);\n\n\t\t\t\tfor (l = -1; l < 3; l++) {\n\t\t\t\t\tconst gdFixed f = gd_itofx(l) - f_g;\n\t\t\t\t\tconst gdFixed f_fm1 = f - f_1;\n\t\t\t\t\tconst gdFixed f_fp1 = f + f_1;\n\t\t\t\t\tconst gdFixed f_fp2 = f + f_2;\n\t\t\t\t\tregister gdFixed f_a = 0, f_b = 0, f_c = 0, f_d = 0;\n\t\t\t\t\tregister gdFixed f_RX, f_R, f_rs, f_gs, f_bs, f_ba;\n\t\t\t\t\tregister int c;\n\t\t\t\t\tconst int _k = ((k+1)*4) + (l+1);\n\n\t\t\t\t\tif (f_fp2 > 0) f_a = gd_mulfx(f_fp2,gd_mulfx(f_fp2,f_fp2));\n\n\t\t\t\t\tif (f_fp1 > 0) f_b = gd_mulfx(f_fp1,gd_mulfx(f_fp1,f_fp1));\n\n\t\t\t\t\tif (f > 0) f_c = gd_mulfx(f,gd_mulfx(f,f));\n\n\t\t\t\t\tif (f_fm1 > 0) f_d = gd_mulfx(f_fm1,gd_mulfx(f_fm1,f_fm1));\n\n\t\t\t\t\tf_RX = gd_divfx((f_a-gd_mulfx(f_4,f_b)+gd_mulfx(f_6,f_c)-gd_mulfx(f_4,f_d)),f_6);\n\t\t\t\t\tf_R = gd_mulfx(f_RY,f_RX);\n\n\t\t\t\t\tc = src->tpixels[*(src_offset_y + _k)][*(src_offset_x + _k)];\n\t\t\t\t\tf_rs = gd_itofx(gdTrueColorGetRed(c));\n\t\t\t\t\tf_gs = gd_itofx(gdTrueColorGetGreen(c));\n\t\t\t\t\tf_bs = gd_itofx(gdTrueColorGetBlue(c));\n\t\t\t\t\tf_ba = gd_itofx(gdTrueColorGetAlpha(c));\n\n\t\t\t\t\tf_red += gd_mulfx(f_rs,f_R);\n\t\t\t\t\tf_green += gd_mulfx(f_gs,f_R);\n\t\t\t\t\tf_blue += gd_mulfx(f_bs,f_R);\n\t\t\t\t\tf_alpha += gd_mulfx(f_ba,f_R);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tred    = (unsigned char) CLAMP(gd_fxtoi(gd_mulfx(f_red,   f_gamma)),  0, 255);\n\t\t\tgreen  = (unsigned char) CLAMP(gd_fxtoi(gd_mulfx(f_green, f_gamma)),  0, 255);\n\t\t\tblue   = (unsigned char) CLAMP(gd_fxtoi(gd_mulfx(f_blue,  f_gamma)),  0, 255);\n\t\t\talpha  = (unsigned char) CLAMP(gd_fxtoi(gd_mulfx(f_alpha,  f_gamma)), 0, 127);\n\n\t\t\t*(dst_row + dst_offset_x) = gdTrueColorAlpha(red, green, blue, alpha);\n\n\t\t\tdst_offset_x++;\n\t\t}\n\t\tdst_offset_y++;\n\t}\n\treturn dst;\n}\n\n/**\n * Function: gdImageScale\n *\n * Scale an image\n *\n * Creates a new image, scaled to the requested size using the current\n * <gdInterpolationMethod>.\n *\n * Note that GD_WEIGHTED4 is not yet supported by this function.\n *\n * Parameters:\n *   src        - The source image.\n *   new_width  - The new width.\n *   new_height - The new height.\n *\n * Returns:\n *   The scaled image on success, NULL on failure.\n *\n * See also:\n *   - <gdImageCopyResized>\n *   - <gdImageCopyResampled>\n */\nBGD_DECLARE(gdImagePtr) gdImageScale(const gdImagePtr src, const unsigned int new_width, const unsigned int new_height)\n{\n\tgdImagePtr im_scaled = NULL;\n\n\tif (src == NULL || (uintmax_t)src->interpolation_id >= GD_METHOD_COUNT) {\n\t\treturn NULL;\n\t}\n\n\tif (new_width == 0 || new_height == 0) {\n\t\treturn NULL;\n\t}\n\tif ((int)new_width == gdImageSX(src) && (int)new_height == gdImageSY(src)) {\n\t\treturn gdImageClone(src);\n\t}\n\tswitch (src->interpolation_id) {\n\t\t/*Special cases, optimized implementations */\n\t\tcase GD_NEAREST_NEIGHBOUR:\n\t\t\tim_scaled = gdImageScaleNearestNeighbour(src, new_width, new_height);\n\t\t\tbreak;\n\n\t\tcase GD_BILINEAR_FIXED:\n\t\tcase GD_LINEAR:\n\t\t\tim_scaled = gdImageScaleBilinear(src, new_width, new_height);\n\t\t\tbreak;\n\n\t\tcase GD_BICUBIC_FIXED:\n\t\tcase GD_BICUBIC:\n\t\t\tim_scaled = gdImageScaleBicubicFixed(src, new_width, new_height);\n\t\t\tbreak;\n\n\t\t/* generic */\n\t\tdefault:\n\t\t\tif (src->interpolation == NULL) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tim_scaled = gdImageScaleTwoPass(src, new_width, new_height);\n\t\t\tbreak;\n\t}\n\n\treturn im_scaled;\n}\n\nstatic int gdRotatedImageSize(gdImagePtr src, const float angle, gdRectPtr bbox)\n{\n    gdRect src_area;\n    double m[6];\n\n    gdAffineRotate(m, angle);\n    src_area.x = 0;\n    src_area.y = 0;\n    src_area.width = gdImageSX(src);\n    src_area.height = gdImageSY(src);\n    if (gdTransformAffineBoundingBox(&src_area, m, bbox) != GD_TRUE) {\n        return GD_FALSE;\n    }\n\n    return GD_TRUE;\n}\n\nstatic gdImagePtr\ngdImageRotateNearestNeighbour(gdImagePtr src, const float degrees,\n                              const int bgColor)\n{\n\tfloat _angle = ((float) (-degrees / 180.0f) * (float)M_PI);\n\tconst int src_w  = gdImageSX(src);\n\tconst int src_h = gdImageSY(src);\n\tconst gdFixed f_0_5 = gd_ftofx(0.5f);\n\tconst gdFixed f_H = gd_itofx(src_h/2);\n\tconst gdFixed f_W = gd_itofx(src_w/2);\n\tconst gdFixed f_cos = gd_ftofx(cos(-_angle));\n\tconst gdFixed f_sin = gd_ftofx(sin(-_angle));\n\n\tunsigned int dst_offset_x;\n\tunsigned int dst_offset_y = 0;\n\tunsigned int i;\n\tgdImagePtr dst;\n\tgdRect bbox;\n\tunsigned int new_height, new_width;\n\n    gdRotatedImageSize(src, degrees, &bbox);\n    new_width = bbox.width;\n    new_height = bbox.height;\n\n\tdst = gdImageCreateTrueColor(new_width, new_height);\n\tif (!dst) {\n\t\treturn NULL;\n\t}\n\tdst->saveAlphaFlag = 1;\n\tfor (i = 0; i < new_height; i++) {\n\t\tunsigned int j;\n\t\tdst_offset_x = 0;\n\t\tfor (j = 0; j < new_width; j++) {\n\t\t\tgdFixed f_i = gd_itofx((int)i - (int)new_height / 2);\n\t\t\tgdFixed f_j = gd_itofx((int)j - (int)new_width  / 2);\n\t\t\tgdFixed f_m = gd_mulfx(f_j,f_sin) + gd_mulfx(f_i,f_cos) + f_0_5 + f_H;\n\t\t\tgdFixed f_n = gd_mulfx(f_j,f_cos) - gd_mulfx(f_i,f_sin) + f_0_5 + f_W;\n\t\t\tlong m = gd_fxtoi(f_m);\n\t\t\tlong n = gd_fxtoi(f_n);\n\n\t\t\tif ((m > 0) && (m < src_h-1) && (n > 0) && (n < src_w-1)) {\n\t\t\t\tif (dst_offset_y < new_height) {\n\t\t\t\t\tdst->tpixels[dst_offset_y][dst_offset_x++] = src->tpixels[m][n];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (dst_offset_y < new_height) {\n\t\t\t\t\tdst->tpixels[dst_offset_y][dst_offset_x++] = bgColor;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdst_offset_y++;\n\t}\n\treturn dst;\n}\n\nstatic gdImagePtr\ngdImageRotateGeneric(gdImagePtr src, const float degrees, const int bgColor)\n{\n\tfloat _angle = ((float) (-degrees / 180.0f) * (float)M_PI);\n\tconst int src_w  = gdImageSX(src);\n\tconst int src_h = gdImageSY(src);\n\tconst gdFixed f_H = gd_itofx(src_h/2);\n\tconst gdFixed f_W = gd_itofx(src_w/2);\n\tconst gdFixed f_cos = gd_ftofx(cos(-_angle));\n\tconst gdFixed f_sin = gd_ftofx(sin(-_angle));\n\n\tunsigned int dst_offset_x;\n\tunsigned int dst_offset_y = 0;\n\tunsigned int i;\n\tgdImagePtr dst;\n\tunsigned int new_width, new_height;\n\tgdRect bbox;\n\n\tif (bgColor < 0) {\n\t\treturn NULL;\n\t}\n\n\tif (src->interpolation == NULL) {\n\t\tgdImageSetInterpolationMethod(src, GD_DEFAULT);\n\t}\n\n    gdRotatedImageSize(src, degrees, &bbox);\n    new_width = bbox.width;\n    new_height = bbox.height;\n\n\tdst = gdImageCreateTrueColor(new_width, new_height);\n\tif (!dst) {\n\t\treturn NULL;\n\t}\n\tdst->saveAlphaFlag = 1;\n\n\tfor (i = 0; i < new_height; i++) {\n\t\tunsigned int j;\n\t\tdst_offset_x = 0;\n\t\tfor (j = 0; j < new_width; j++) {\n\t\t\tgdFixed f_i = gd_itofx((int)i - (int)new_height / 2);\n\t\t\tgdFixed f_j = gd_itofx((int)j - (int)new_width  / 2);\n\t\t\tgdFixed f_m = gd_mulfx(f_j,f_sin) + gd_mulfx(f_i,f_cos) + f_H;\n\t\t\tgdFixed f_n = gd_mulfx(f_j,f_cos) - gd_mulfx(f_i,f_sin)  + f_W;\n\t\t\tlong m = gd_fxtoi(f_m);\n\t\t\tlong n = gd_fxtoi(f_n);\n\n\t\t\tif (m < -1 || n < -1 || m >= src_h || n >= src_w ) {\n\t\t\t\tdst->tpixels[dst_offset_y][dst_offset_x++] = bgColor;\n\t\t\t} else {\n\t\t\t\tdst->tpixels[dst_offset_y][dst_offset_x++] = getPixelInterpolated(src, gd_fxtod(f_n), gd_fxtod(f_m), bgColor);\n\t\t\t}\n\t\t}\n\t\tdst_offset_y++;\n\t}\n\treturn dst;\n}\n\n/**\n * Function: gdImageRotateInterpolated\n *\n * Rotate an image\n *\n * Creates a new image, counter-clockwise rotated by the requested angle\n * using the current <gdInterpolationMethod>. Non-square angles will add a\n * border with bgcolor.\n *\n * Parameters:\n *   src     - The source image.\n *   angle   - The angle in degrees.\n *   bgcolor - The color to fill the added background with.\n *\n * Returns:\n *   The rotated image on success, NULL on failure.\n *\n * See also:\n *   - <gdImageCopyRotated>\n */\nBGD_DECLARE(gdImagePtr) gdImageRotateInterpolated(const gdImagePtr src, const float angle, int bgcolor)\n{\n\t/* round to two decimals and keep the 100x multiplication to use it in the common square angles\n\t   case later. Keep the two decimal precisions so smaller rotation steps can be done, useful for\n\t   slow animations, f.e. */\n\tconst int angle_rounded = fmod((int) floorf(angle * 100), 360 * 100);\n\tgdImagePtr src_tc = src;\n\tint src_cloned = 0;\n\tif (src == NULL || bgcolor < 0) {\n\t\treturn NULL;\n\t}\n\n\tif (!gdImageTrueColor(src)) {\n\t\tif (bgcolor < gdMaxColors) {\n\t\t\tbgcolor =  gdTrueColorAlpha(src->red[bgcolor], src->green[bgcolor], src->blue[bgcolor], src->alpha[bgcolor]);\n\t\t}\n\t\tsrc_tc = gdImageClone(src);\n\t\tgdImagePaletteToTrueColor(src_tc);\n\t\tsrc_cloned = 1;\n\t}\n\n\t/* 0 && 90 degrees multiple rotation, 0 rotation simply clones the return image and convert it\n\t   to truecolor, as we must return truecolor image. */\n\tswitch (angle_rounded) {\n\t\tcase    0:\n\t\t\treturn src_cloned ? src_tc : gdImageClone(src);\n\n\t\tcase -27000:\n\t\tcase   9000:\n\t\t\tif (src_cloned) gdImageDestroy(src_tc);\n\t\t\treturn gdImageRotate90(src, 0);\n\n\t\tcase -18000:\n\t\tcase  18000:\n\t\t\tif (src_cloned) gdImageDestroy(src_tc);\n\t\t\treturn gdImageRotate180(src, 0);\n\n\t\tcase  -9000:\n\t\tcase  27000:\n\t\t\tif (src_cloned) gdImageDestroy(src_tc);\n\t\t\treturn gdImageRotate270(src, 0);\n\t}\n\n\tif (src->interpolation_id < 1 || src->interpolation_id > GD_METHOD_COUNT) {\n\t\tif (src_cloned) gdImageDestroy(src_tc);\n\t\treturn NULL;\n\t}\n\n\tswitch (src->interpolation_id) {\n\t\tcase GD_NEAREST_NEIGHBOUR: {\n\t\t\tgdImagePtr res = gdImageRotateNearestNeighbour(src_tc, angle, bgcolor);\n\t\t\tif (src_cloned) gdImageDestroy(src_tc);\n\t\t\treturn res;\n\t\t}\n\n\t\tcase GD_BILINEAR_FIXED:\n\t\tcase GD_BICUBIC_FIXED:\n\t\tdefault: {\n\t\t\tgdImagePtr res = gdImageRotateGeneric(src_tc, angle, bgcolor);\n\t\t\tif (src_cloned) gdImageDestroy(src_tc);\n\t\t\treturn res;\n\t\t}\n\t}\n\treturn NULL;\n}\n\n/**\n * Group: Affine Transformation\n **/\n\n static void gdImageClipRectangle(gdImagePtr im, gdRectPtr r)\n{\n\tint c1x, c1y, c2x, c2y;\n\tint x1,y1;\n\n\tgdImageGetClip(im, &c1x, &c1y, &c2x, &c2y);\n\tx1 = r->x + r->width - 1;\n\ty1 = r->y + r->height - 1;\n\tr->x = CLAMP(r->x, c1x, c2x);\n\tr->y = CLAMP(r->y, c1y, c2y);\n\tr->width = CLAMP(x1, c1x, c2x) - r->x + 1;\n\tr->height = CLAMP(y1, c1y, c2y) - r->y + 1;\n}\n\n/**\n * Function: gdTransformAffineGetImage\n *  Applies an affine transformation to a region and return an image\n *  containing the complete transformation.\n *\n * Parameters:\n * \tdst - Pointer to a gdImagePtr to store the created image, NULL when\n *        the creation or the transformation failed\n *  src - Source image\n *  src_area - rectangle defining the source region to transform\n *  dstY - Y position in the destination image\n *  affine - The desired affine transformation\n *\n * Returns:\n *  GD_TRUE if the affine is rectilinear or GD_FALSE\n */\nBGD_DECLARE(int) gdTransformAffineGetImage(gdImagePtr *dst,\n\t\t  const gdImagePtr src,\n\t\t  gdRectPtr src_area,\n\t\t  const double affine[6])\n{\n\tint res;\n\tdouble m[6];\n\tgdRect bbox;\n\tgdRect area_full;\n\n\tif (src_area == NULL) {\n\t\tarea_full.x = 0;\n\t\tarea_full.y = 0;\n\t\tarea_full.width  = gdImageSX(src);\n\t\tarea_full.height = gdImageSY(src);\n\t\tsrc_area = &area_full;\n\t}\n\n\tgdTransformAffineBoundingBox(src_area, affine, &bbox);\n\n\t*dst = gdImageCreateTrueColor(bbox.width, bbox.height);\n\tif (*dst == NULL) {\n\t\treturn GD_FALSE;\n\t}\n\t(*dst)->saveAlphaFlag = 1;\n\n\tif (!src->trueColor) {\n\t\tgdImagePaletteToTrueColor(src);\n\t}\n\n\t/* Translate to dst origin (0,0) */\n\tgdAffineTranslate(m, -bbox.x, -bbox.y);\n\tgdAffineConcat(m, affine, m);\n\n\tgdImageAlphaBlending(*dst, 0);\n\n\tres = gdTransformAffineCopy(*dst,\n\t\t  0,0,\n\t\t  src,\n\t\t  src_area,\n\t\t  m);\n\n\tif (res != GD_TRUE) {\n\t\tgdImageDestroy(*dst);\n\t\t*dst = NULL;\n\t\treturn GD_FALSE;\n\t} else {\n\t\treturn GD_TRUE;\n\t}\n}\n\n/** Function: getPixelRgbInterpolated\n *   get the index of the image's colors\n *\n * Parameters:\n *  im - Image to draw the transformed image\n *  tcolor - TrueColor\n *\n * Return:\n *  index of colors\n */\nstatic int getPixelRgbInterpolated(gdImagePtr im, const int tcolor)\n{\n\tunsigned char r, g, b, a;\n\tint ct;\n\tint i;\n\n\tb = (unsigned char)(tcolor);\n\tg = (unsigned char)(tcolor >> 8);\n\tr = (unsigned char)(tcolor >> 16);\n\ta = (unsigned char)(tcolor >> 24);\n\n\tfor (i = 0; i < im->colorsTotal; i++) {\n\t\tif (im->red[i] == r && im->green[i] == g && im->blue[i] == b && im->alpha[i] == a) {\n\t\t\treturn i;\n\t\t}\n\t}\n\n\tct = im->colorsTotal;\n\tif (ct == gdMaxColors) {\n\t\treturn -1;\n\t}\n\n\tim->colorsTotal++;\n\tim->red[ct] = r;\n\tim->green[ct] = g;\n\tim->blue[ct] = b;\n\tim->alpha[ct] = a;\n\tim->open[ct] = 0;\n\n\treturn ct;\n}\n/**\n * Function: gdTransformAffineCopy\n *  Applies an affine transformation to a region and copy the result\n *  in a destination to the given position.\n *\n * Parameters:\n * \tdst - Image to draw the transformed image\n *  src - Source image\n *  dstX - X position in the destination image\n *  dstY - Y position in the destination image\n *  src_area - Rectangular region to rotate in the src image\n *\n * Returns:\n *  GD_TRUE on success or GD_FALSE on failure\n */\nBGD_DECLARE(int) gdTransformAffineCopy(gdImagePtr dst,\n\t\t  int dst_x, int dst_y,\n\t\t  const gdImagePtr src,\n\t\t  gdRectPtr src_region,\n\t\t  const double affine[6])\n{\n\tint c1x,c1y,c2x,c2y;\n\tint backclip = 0;\n\tint backup_clipx1, backup_clipy1, backup_clipx2, backup_clipy2;\n\tregister int x, y, src_offset_x, src_offset_y;\n\tdouble inv[6];\n\tgdPointF pt, src_pt;\n\tgdRect bbox;\n\tint end_x, end_y;\n\tgdInterpolationMethod interpolation_id_bak = src->interpolation_id;\n\n\t/* These methods use special implementations */\n\tif (src->interpolation_id == GD_BILINEAR_FIXED || src->interpolation_id == GD_BICUBIC_FIXED || src->interpolation_id == GD_NEAREST_NEIGHBOUR) {\n\t\tgdImageSetInterpolationMethod(src, GD_BICUBIC);\n\t}\n\n\tgdImageClipRectangle(src, src_region);\n\tc1x = src_region->x;\n\tc1y = src_region->y;\n\tc2x = src_region->x + src_region->width -1;\n\tc2y = src_region->y + src_region->height -1;\n\n\tif (src_region->x > 0 || src_region->y > 0\n\t\t|| src_region->width < gdImageSX(src)\n\t\t|| src_region->height < gdImageSY(src)) {\n\t\tbackclip = 1;\n\n\t\tgdImageGetClip(src, &backup_clipx1, &backup_clipy1,\n\t\t&backup_clipx2, &backup_clipy2);\n\n\t\tgdImageSetClip(src, src_region->x, src_region->y,\n\t\t\tsrc_region->x + src_region->width - 1,\n\t\t\tsrc_region->y + src_region->height - 1);\n\t}\n\n\tif (!gdTransformAffineBoundingBox(src_region, affine, &bbox)) {\n\t\tif (backclip) {\n\t\t\tgdImageSetClip(src, backup_clipx1, backup_clipy1,\n\t\t\t\t\tbackup_clipx2, backup_clipy2);\n\t\t}\n\t\tgdImageSetInterpolationMethod(src, interpolation_id_bak);\n\t\treturn GD_FALSE;\n\t}\n\n\tend_x = bbox.width  + abs(bbox.x);\n\tend_y = bbox.height + abs(bbox.y);\n\n\t/* Get inverse affine to let us work with destination -> source */\n\tif (gdAffineInvert(inv, affine) == GD_FALSE) {\n\t\tgdImageSetInterpolationMethod(src, interpolation_id_bak);\n\t\treturn GD_FALSE;\n\t}\n\n\tsrc_offset_x =  src_region->x;\n\tsrc_offset_y =  src_region->y;\n\n\tif (dst->alphaBlendingFlag) {\n\t\tfor (y = bbox.y; y <= end_y; y++) {\n\t\t\tpt.y = y + 0.5;\n\t\t\tfor (x = bbox.x; x <= end_x; x++) {\n\t\t\t\tpt.x = x + 0.5;\n\t\t\t\tgdAffineApplyToPointF(&src_pt, &pt, inv);\n\t\t\t\tif (floor(src_offset_x + src_pt.x) < c1x\n\t\t\t\t\t|| floor(src_offset_x + src_pt.x) > c2x\n\t\t\t\t\t|| floor(src_offset_y + src_pt.y) < c1y\n\t\t\t\t\t|| floor(src_offset_y + src_pt.y) > c2y) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tgdImageSetPixel(dst, dst_x + x, dst_y + y, getPixelInterpolated(src, (int)(src_offset_x + src_pt.x), (int)(src_offset_y + src_pt.y), 0));\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (y = bbox.y; y <= end_y; y++) {\n\t\t\tunsigned char *dst_p = NULL;\n\t\t\tint *tdst_p = NULL;\n\n\t\t\tpt.y = y + 0.5;\n\t\t\tif ((dst_y + y) < 0 || ((dst_y + y) > gdImageSY(dst) -1)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (dst->trueColor) {\n\t\t\t\ttdst_p = dst->tpixels[dst_y + y] + dst_x;\n\t\t\t} else {\n\t\t\t\tdst_p = dst->pixels[dst_y + y] + dst_x;\n\t\t\t}\n\n\t\t\tfor (x = bbox.x; x <= end_x; x++) {\n\t\t\t\tpt.x = x + 0.5;\n\t\t\t\tgdAffineApplyToPointF(&src_pt, &pt, inv);\n\n\t\t\t\tif ((dst_x + x) < 0 || (dst_x + x) > (gdImageSX(dst) - 1)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (floor(src_offset_x + src_pt.x) < c1x\n\t\t\t\t\t|| floor(src_offset_x + src_pt.x) > c2x\n\t\t\t\t\t|| floor(src_offset_y + src_pt.y) < c1y\n\t\t\t\t\t|| floor(src_offset_y + src_pt.y) > c2y) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (dst->trueColor) {\n\t\t\t\t\t*(tdst_p + dst_x + x) = getPixelInterpolated(src, (int)(src_offset_x + src_pt.x), (int)(src_offset_y + src_pt.y), -1);\n\t\t\t\t} else {\n\t\t\t\t\t*(dst_p + dst_x + x) = getPixelRgbInterpolated(dst, getPixelInterpolated(src, (int)(src_offset_x + src_pt.x), (int)(src_offset_y + src_pt.y), -1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Restore clip if required */\n\tif (backclip) {\n\t\tgdImageSetClip(src, backup_clipx1, backup_clipy1,\n\t\t\t\tbackup_clipx2, backup_clipy2);\n\t}\n\n\tgdImageSetInterpolationMethod(src, interpolation_id_bak);\n\treturn GD_TRUE;\n}\n\n/**\n * Function: gdTransformAffineBoundingBox\n *  Returns the bounding box of an affine transformation applied to a\n *  rectangular area <gdRect>\n *\n * Parameters:\n * \tsrc - Rectangular source area for the affine transformation\n *  affine - the affine transformation\n *  bbox - the resulting bounding box\n *\n * Returns:\n *  GD_TRUE if the affine is rectilinear or GD_FALSE\n */\nBGD_DECLARE(int) gdTransformAffineBoundingBox(gdRectPtr src, const double affine[6], gdRectPtr bbox)\n{\n\tgdPointF extent[4], min, max, point;\n\tint i;\n\n\textent[0].x=0.0;\n\textent[0].y=0.0;\n\textent[1].x=(double) src->width;\n\textent[1].y=0.0;\n\textent[2].x=(double) src->width;\n\textent[2].y=(double) src->height;\n\textent[3].x=0.0;\n\textent[3].y=(double) src->height;\n\n\tfor (i=0; i < 4; i++) {\n\t\tpoint=extent[i];\n\t\tif (gdAffineApplyToPointF(&extent[i], &point, affine) != GD_TRUE) {\n\t\t\treturn GD_FALSE;\n\t\t}\n\t}\n\tmin=extent[0];\n\tmax=extent[0];\n\n\tfor (i=1; i < 4; i++) {\n\t\tif (min.x > extent[i].x)\n\t\t\tmin.x=extent[i].x;\n\t\tif (min.y > extent[i].y)\n\t\t\tmin.y=extent[i].y;\n\t\tif (max.x < extent[i].x)\n\t\t\tmax.x=extent[i].x;\n\t\tif (max.y < extent[i].y)\n\t\t\tmax.y=extent[i].y;\n\t}\n\tbbox->x = (int) min.x;\n\tbbox->y = (int) min.y;\n\tbbox->width  = (int) ceil((max.x - min.x));\n\tbbox->height = (int) ceil(max.y - min.y);\n\n\treturn GD_TRUE;\n}\n\n/**\n * Group: Interpolation Method\n */\n\n/**\n * Function: gdImageSetInterpolationMethod\n *\n * Set the interpolation method for subsequent operations\n *\n * Parameters:\n *   im - The image.\n *   id - The interpolation method.\n *\n * Returns:\n *   Non-zero on success, zero on failure.\n *\n * See also:\n *   - <gdInterpolationMethod>\n *   - <gdImageGetInterpolationMethod>\n */\nBGD_DECLARE(int) gdImageSetInterpolationMethod(gdImagePtr im, gdInterpolationMethod id)\n{\n\tif (im == NULL || (uintmax_t)id > GD_METHOD_COUNT) {\n\t\treturn 0;\n\t}\n\n\tswitch (id) {\n\t\tcase GD_NEAREST_NEIGHBOUR:\n\t\tcase GD_WEIGHTED4:\n\t\t\tim->interpolation = NULL;\n\t\t\tbreak;\n\n\t\t/* generic versions*/\n\t\t/* GD_BILINEAR_FIXED and GD_BICUBIC_FIXED are kept for BC reasons */\n\t\tcase GD_BILINEAR_FIXED:\n\t\tcase GD_LINEAR:\n\t\t\tim->interpolation = filter_linear;\n\t\t\tbreak;\n\t\tcase GD_BELL:\n\t\t\tim->interpolation = filter_bell;\n\t\t\tbreak;\n\t\tcase GD_BESSEL:\n\t\t\tim->interpolation = filter_bessel;\n\t\t\tbreak;\n\t\tcase GD_BICUBIC_FIXED:\n\t\tcase GD_BICUBIC:\n\t\t\t/* no interpolation as gdImageScale calls a dedicated function */\n\t\t\tim->interpolation = NULL;\n\t\t\tbreak;\n\t\tcase GD_BLACKMAN:\n\t\t\tim->interpolation = filter_blackman;\n\t\t\tbreak;\n\t\tcase GD_BOX:\n\t\t\tim->interpolation = filter_box;\n\t\t\tbreak;\n\t\tcase GD_BSPLINE:\n\t\t\tim->interpolation = filter_bspline;\n\t\t\tbreak;\n\t\tcase GD_CATMULLROM:\n\t\t\tim->interpolation = filter_catmullrom;\n\t\t\tbreak;\n\t\tcase GD_GAUSSIAN:\n\t\t\tim->interpolation = filter_gaussian;\n\t\t\tbreak;\n\t\tcase GD_GENERALIZED_CUBIC:\n\t\t\tim->interpolation = filter_generalized_cubic;\n\t\t\tbreak;\n\t\tcase GD_HERMITE:\n\t\t\tim->interpolation = filter_hermite;\n\t\t\tbreak;\n\t\tcase GD_HAMMING:\n\t\t\tim->interpolation = filter_hamming;\n\t\t\tbreak;\n\t\tcase GD_HANNING:\n\t\t\tim->interpolation = filter_hanning;\n\t\t\tbreak;\n\t\tcase GD_MITCHELL:\n\t\t\tim->interpolation = filter_mitchell;\n\t\t\tbreak;\n\t\tcase GD_POWER:\n\t\t\tim->interpolation = filter_power;\n\t\t\tbreak;\n\t\tcase GD_QUADRATIC:\n\t\t\tim->interpolation = filter_quadratic;\n\t\t\tbreak;\n\t\tcase GD_SINC:\n\t\t\tim->interpolation = filter_sinc;\n\t\t\tbreak;\n\t\tcase GD_TRIANGLE:\n\t\t\tim->interpolation = filter_triangle;\n\t\t\tbreak;\n\t\tcase GD_LANCZOS3:\n\t\t\tim->interpolation = filter_lanczos3;\n\t\t\tbreak;\n\t\tcase GD_LANCZOS8:\n\t\t\tim->interpolation = filter_lanczos8;\n\t\t\tbreak;\n\t\tcase GD_BLACKMAN_BESSEL:\n\t\t\tim->interpolation = filter_blackman_bessel;\n\t\t\tbreak;\n\t\tcase GD_BLACKMAN_SINC:\n\t\t\tim->interpolation = filter_blackman_sinc;\n\t\t\tbreak;\n\t\tcase GD_QUADRATIC_BSPLINE:\n\t\t\tim->interpolation = filter_quadratic_bspline;\n\t\t\tbreak;\n\t\tcase GD_CUBIC_SPLINE:\n\t\t\tim->interpolation = filter_cubic_spline;\n\t\t\tbreak;\n\t\tcase GD_COSINE:\n\t\t\tim->interpolation = filter_cosine;\n\t\t\tbreak;\n\t\tcase GD_WELSH:\n\t\t\tim->interpolation = filter_welsh;\n\t\t\tbreak;\n\t\tcase GD_DEFAULT:\n\t\t\tid = GD_LINEAR;\n\t\t\tim->interpolation = filter_linear;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn 0;\n\t}\n\tim->interpolation_id = id;\n\treturn 1;\n}\n\n/**\n * Function: gdImageGetInterpolationMethod\n *\n * Get the current interpolation method\n *\n * This is here so that the value can be read via a language or VM with an FFI\n * but no (portable) way to extract the value from the struct.\n *\n * Parameters:\n *   im - The image.\n *\n * Returns:\n *   The current interpolation method.\n *\n * See also:\n *   - <gdInterpolationMethod>\n *   - <gdImageSetInterpolationMethod>\n */\nBGD_DECLARE(gdInterpolationMethod) gdImageGetInterpolationMethod(gdImagePtr im)\n{\n    return im->interpolation_id;\n}\n\n#ifdef _MSC_VER\n# pragma optimize(\"\", on)\n#endif\n", "patch": "@@ -953,9 +953,6 @@ static inline LineContribType *_gdContributionsCalc(unsigned int line_size, unsi\n \t\tdouble dTotalWeight = 0.0;\n \t\tint iSrc;\n \n-\t\tres->ContribRow[u].Left = iLeft;\n-\t\tres->ContribRow[u].Right = iRight;\n-\n \t\t/* Cut edge points to fit in filter window in case of spill-off */\n \t\tif (iRight - iLeft + 1 > windows_size)  {\n \t\t\tif (iLeft < ((int)src_size - 1 / 2))  {\n@@ -965,6 +962,9 @@ static inline LineContribType *_gdContributionsCalc(unsigned int line_size, unsi\n \t\t\t}\n \t\t}\n \n+\t\tres->ContribRow[u].Left = iLeft;\n+\t\tres->ContribRow[u].Right = iRight;\n+\n \t\tfor (iSrc = iLeft; iSrc <= iRight; iSrc++) {\n \t\t\tdTotalWeight += (res->ContribRow[u].Weights[iSrc-iLeft] =  scale_f_d * (*pFilter)(scale_f_d * (dCenter - (double)iSrc)));\n \t\t}", "file_path": "files/2016_8\\69", "file_language": "c", "file_name": "src/gd_interpolation.c", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}], "outdated": 0}
{"index": 29, "cve_id": "CVE-2016-5116", "cwe_id": ["CWE-119"], "cve_language": "C", "cve_description": "gd_xbm.c in the GD Graphics Library (aka libgd) before 2.2.0, as used in certain custom PHP 5.5.x configurations, allows context-dependent attackers to obtain sensitive information from process memory or cause a denial of service (stack-based buffer under-read and application crash) via a long name.", "cvss": "9.1", "publish_date": "August 7, 2016", "AV": "NETWORK", "AC": "LOW", "PR": "NONE", "UI": "NONE", "S": "UNCHANGED", "C": "HIGH", "I": "NONE", "A": "HIGH", "commit_id": "4dc1a2d7931017d3625f2d7cff70a17ce58b53b4", "commit_message": "xbm: avoid stack overflow (read) with large names #211\n\nWe use the name passed in to printf into a local stack buffer which is\nlimited to 4000 bytes.  So given a large enough value, lots of stack\ndata is leaked.  Rewrite the code to do simple memory copies with most\nof the strings to avoid that issue, and only use stack buffer for small\nnumbers of constant size.\n\nThis closes #211.", "commit_date": "2016-05-14T05:38:18Z", "project": "libgd/libgd", "url": "https://api.github.com/repos/libgd/libgd/commits/4dc1a2d7931017d3625f2d7cff70a17ce58b53b4", "html_url": "https://github.com/libgd/libgd/commit/4dc1a2d7931017d3625f2d7cff70a17ce58b53b4", "windows_before": "", "windows_after": "", "parents": [{"commit_id_before": "b083ec17ad9cba4ad9fe7fac1c6a168d90dd1a31", "url_before": "https://api.github.com/repos/libgd/libgd/commits/b083ec17ad9cba4ad9fe7fac1c6a168d90dd1a31", "html_url_before": "https://github.com/libgd/libgd/commit/b083ec17ad9cba4ad9fe7fac1c6a168d90dd1a31"}], "details": [{"raw_url": "https://github.com/libgd/libgd/raw/4dc1a2d7931017d3625f2d7cff70a17ce58b53b4/src/gd_xbm.c", "code": "#ifdef HAVE_CONFIG_H\n#\tinclude \"config.h\"\n#endif\n\n#include <ctype.h>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include \"gd.h\"\n#include \"gd_errors.h\"\n#include \"gdhelpers.h\"\n\n#ifdef _MSC_VER\n# define strcasecmp _stricmp\n#endif\n\n#define MAX_XBM_LINE_SIZE 255\n\n\n/*\n  Function: gdImageCreateFromXbm\n\n    <gdImageCreateFromXbm> is called to load images from X bitmap\n    format files. Invoke <gdImageCreateFromXbm> with an already opened\n    pointer to a file containing the desired\n    image. <gdImageCreateFromXbm> returns a <gdImagePtr> to the new\n    image, or NULL if unable to load the image (most often because the\n    file is corrupt or does not contain an X bitmap format\n    image). <gdImageCreateFromXbm> does not close the file.\n\n    You can inspect the sx and sy members of the image to determine\n    its size. The image must eventually be destroyed using\n    <gdImageDestroy>.\n\n  Parameters:\n\n    fd - The input FILE pointer\n\n  Returns:\n\n    A pointer to the new image or NULL if an error occurred.\n\n  Example:\n\n    > gdImagePtr im;\n    > FILE *in;\n    > in = fopen(\"myxbm.xbm\", \"rb\");\n    > im = gdImageCreateFromXbm(in);\n    > fclose(in);\n    > // ... Use the image ...\n    > gdImageDestroy(im);\n*/\nBGD_DECLARE(gdImagePtr) gdImageCreateFromXbm(FILE * fd)\n{\n\tchar fline[MAX_XBM_LINE_SIZE];\n\tchar iname[MAX_XBM_LINE_SIZE];\n\tchar *type;\n\tint value;\n\tunsigned int width = 0, height = 0;\n\tint fail = 0;\n\tint max_bit = 0;\n\n\tgdImagePtr im;\n\tint bytes = 0, i;\n\tint bit, x = 0, y = 0;\n\tint ch;\n\tchar h[8];\n\tunsigned int b;\n\n\trewind(fd);\n\twhile (fgets(fline, MAX_XBM_LINE_SIZE, fd)) {\n\t\tfline[MAX_XBM_LINE_SIZE-1] = '\\0';\n\t\tif (strlen(fline) == MAX_XBM_LINE_SIZE-1) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (sscanf(fline, \"#define %s %d\", iname, &value) == 2) {\n\t\t\tif (!(type = strrchr(iname, '_'))) {\n\t\t\t\ttype = iname;\n\t\t\t} else {\n\t\t\t\ttype++;\n\t\t\t}\n\n\t\t\tif (!strcmp(\"width\", type)) {\n\t\t\t\twidth = (unsigned int) value;\n\t\t\t}\n\t\t\tif (!strcmp(\"height\", type)) {\n\t\t\t\theight = (unsigned int) value;\n\t\t\t}\n\t\t} else {\n\t\t\tif ( sscanf(fline, \"static unsigned char %s = {\", iname) == 1\n\t\t\t  || sscanf(fline, \"static char %s = {\", iname) == 1)\n\t\t\t{\n\t\t\t\tmax_bit = 128;\n\t\t\t} else if (sscanf(fline, \"static unsigned short %s = {\", iname) == 1\n\t\t\t\t\t|| sscanf(fline, \"static short %s = {\", iname) == 1)\n\t\t\t{\n\t\t\t\tmax_bit = 32768;\n\t\t\t}\n\t\t\tif (max_bit) {\n\t\t\t\tbytes = (width * height / 8) + 1;\n\t\t\t\tif (!bytes) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tif (!(type = strrchr(iname, '_'))) {\n\t\t\t\t\ttype = iname;\n\t\t\t\t} else {\n\t\t\t\t\ttype++;\n\t\t\t\t}\n\t\t\t\tif (!strcmp(\"bits[]\", type)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n \t\t}\n\t}\n\tif (!bytes || !max_bit) {\n\t\treturn 0;\n\t}\n\n\tif(!(im = gdImageCreate(width, height))) {\n\t\treturn 0;\n\t}\n\tgdImageColorAllocate(im, 255, 255, 255);\n\tgdImageColorAllocate(im, 0, 0, 0);\n\th[2] = '\\0';\n\th[4] = '\\0';\n\tfor (i = 0; i < bytes; i++) {\n\t\twhile (1) {\n\t\t\tif ((ch=getc(fd)) == EOF) {\n\t\t\t\tfail = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (ch == 'x') {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (fail) {\n\t\t\tbreak;\n\t\t}\n\t\t/* Get hex value */\n\t\tif ((ch=getc(fd)) == EOF) {\n\t\t\tbreak;\n\t\t}\n\t\th[0] = ch;\n\t\tif ((ch=getc(fd)) == EOF) {\n\t\t\tbreak;\n\t\t}\n\t\th[1] = ch;\n\t\tif (max_bit == 32768) {\n\t\t\tif ((ch=getc(fd)) == EOF) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\th[2] = ch;\n\t\t\tif ((ch=getc(fd)) == EOF) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\th[3] = ch;\n\t\t}\n\t\tsscanf(h, \"%x\", &b);\n\t\tfor (bit = 1; bit <= max_bit; bit = bit << 1) {\n\t\t\tgdImageSetPixel(im, x++, y, (b & bit) ? 1 : 0);\n\t\t\tif (x == im->sx) {\n\t\t\t\tx = 0;\n\t\t\t\ty++;\n\t\t\t\tif (y == im->sy) {\n\t\t\t\t\treturn im;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tgd_error(\"EOF before image was complete\");\n\tgdImageDestroy(im);\n\treturn 0;\n}\n\n\n/* {{{ gdCtxPrintf */\nstatic void gdCtxPrintf(gdIOCtx * out, const char *format, ...)\n{\n\tchar buf[1024];\n\tint len;\n\tva_list args;\n\n\tva_start(args, format);\n\tlen = vsnprintf(buf, sizeof(buf)-1, format, args);\n\tva_end(args);\n\tout->putBuf(out, buf, len);\n}\n/* }}} */\n\n/* The compiler will optimize strlen(constant) to a constant number. */\n#define gdCtxPuts(out, s) out->putBuf(out, s, strlen(s))\n\n/* {{{ gdImageXbmCtx */\nBGD_DECLARE(void) gdImageXbmCtx(gdImagePtr image, char* file_name, int fg, gdIOCtx * out)\n{\n\tint x, y, c, b, sx, sy, p;\n\tchar *name, *f;\n\tsize_t i, l;\n\n\tname = file_name;\n\tif ((f = strrchr(name, '/')) != NULL) name = f+1;\n\tif ((f = strrchr(name, '\\\\')) != NULL) name = f+1;\n\tname = strdup(name);\n\tif ((f = strrchr(name, '.')) != NULL && !strcasecmp(f, \".XBM\")) *f = '\\0';\n\tif ((l = strlen(name)) == 0) {\n\t\tfree(name);\n\t\tname = strdup(\"image\");\n\t} else {\n\t\tfor (i=0; i<l; i++) {\n\t\t\t/* only in C-locale isalnum() would work */\n\t\t\tif (!isupper(name[i]) && !islower(name[i]) && !isdigit(name[i])) {\n\t\t\t\tname[i] = '_';\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Since \"name\" comes from the user, run it through a direct puts.\n\t * Trying to printf it into a local buffer means we'd need a large\n\t * or dynamic buffer to hold it all. */\n\n\t/* #define <name>_width 1234 */\n\tgdCtxPuts(out, \"#define \");\n\tgdCtxPuts(out, name);\n\tgdCtxPuts(out, \"_width \");\n\tgdCtxPrintf(out, \"%d\\n\", gdImageSX(image));\n\n\t/* #define <name>_height 1234 */\n\tgdCtxPuts(out, \"#define \");\n\tgdCtxPuts(out, name);\n\tgdCtxPuts(out, \"_height \");\n\tgdCtxPrintf(out, \"%d\\n\", gdImageSY(image));\n\n\t/* static unsigned char <name>_bits[] = {\\n */\n\tgdCtxPuts(out, \"static unsigned char \");\n\tgdCtxPuts(out, name);\n\tgdCtxPuts(out, \"_bits[] = {\\n  \");\n\n\tfree(name);\n\n\tb = 1;\n\tp = 0;\n\tc = 0;\n\tsx = gdImageSX(image);\n\tsy = gdImageSY(image);\n\tfor (y = 0; y < sy; y++) {\n\t\tfor (x = 0; x < sx; x++) {\n\t\t\tif (gdImageGetPixel(image, x, y) == fg) {\n\t\t\t\tc |= b;\n\t\t\t}\n\t\t\tif ((b == 128) || (x == sx && y == sy)) {\n\t\t\t\tb = 1;\n\t\t\t\tif (p) {\n\t\t\t\t\tgdCtxPuts(out, \", \");\n\t\t\t\t\tif (!(p%12)) {\n\t\t\t\t\t\tgdCtxPuts(out, \"\\n  \");\n\t\t\t\t\t\tp = 12;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tp++;\n\t\t\t\tgdCtxPrintf(out, \"0x%02X\", c);\n\t\t\t\tc = 0;\n\t\t\t} else {\n\t\t\t\tb <<= 1;\n\t\t\t}\n\t\t}\n\t}\n\tgdCtxPuts(out, \"};\\n\");\n}\n/* }}} */\n", "code_before": "/**\n * File: XBM IO\n *\n * Read and write XBM images.\n */\n\n#ifdef HAVE_CONFIG_H\n#\tinclude \"config.h\"\n#endif\n\n#include <ctype.h>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include \"gd.h\"\n#include \"gd_errors.h\"\n#include \"gdhelpers.h\"\n\n#ifdef _MSC_VER\n# define strcasecmp _stricmp\n#endif\n\n#define MAX_XBM_LINE_SIZE 255\n\n\n/*\n  Function: gdImageCreateFromXbm\n\n    <gdImageCreateFromXbm> is called to load images from X bitmap\n    format files. Invoke <gdImageCreateFromXbm> with an already opened\n    pointer to a file containing the desired\n    image. <gdImageCreateFromXbm> returns a <gdImagePtr> to the new\n    image, or NULL if unable to load the image (most often because the\n    file is corrupt or does not contain an X bitmap format\n    image). <gdImageCreateFromXbm> does not close the file.\n\n    You can inspect the sx and sy members of the image to determine\n    its size. The image must eventually be destroyed using\n    <gdImageDestroy>.\n\n    X11 X bitmaps (which define a char[]) as well as X10 X bitmaps (which define\n    a short[]) are supported.\n\n  Parameters:\n\n    fd - The input FILE pointer\n\n  Returns:\n\n    A pointer to the new image or NULL if an error occurred.\n\n  Example:\n    (start code)\n\n    gdImagePtr im;\n    FILE *in;\n    in = fopen(\"myxbm.xbm\", \"rb\");\n    im = gdImageCreateFromXbm(in);\n    fclose(in);\n    // ... Use the image ...\n    gdImageDestroy(im);\n\n    (end code)\n*/\nBGD_DECLARE(gdImagePtr) gdImageCreateFromXbm(FILE * fd)\n{\n\tchar fline[MAX_XBM_LINE_SIZE];\n\tchar iname[MAX_XBM_LINE_SIZE];\n\tchar *type;\n\tint value;\n\tunsigned int width = 0, height = 0;\n\tint fail = 0;\n\tint max_bit = 0;\n\n\tgdImagePtr im;\n\tint bytes = 0, i;\n\tint bit, x = 0, y = 0;\n\tint ch;\n\tchar h[8];\n\tunsigned int b;\n\n\trewind(fd);\n\twhile (fgets(fline, MAX_XBM_LINE_SIZE, fd)) {\n\t\tfline[MAX_XBM_LINE_SIZE-1] = '\\0';\n\t\tif (strlen(fline) == MAX_XBM_LINE_SIZE-1) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (sscanf(fline, \"#define %s %d\", iname, &value) == 2) {\n\t\t\tif (!(type = strrchr(iname, '_'))) {\n\t\t\t\ttype = iname;\n\t\t\t} else {\n\t\t\t\ttype++;\n\t\t\t}\n\n\t\t\tif (!strcmp(\"width\", type)) {\n\t\t\t\twidth = (unsigned int) value;\n\t\t\t}\n\t\t\tif (!strcmp(\"height\", type)) {\n\t\t\t\theight = (unsigned int) value;\n\t\t\t}\n\t\t} else {\n\t\t\tif ( sscanf(fline, \"static unsigned char %s = {\", iname) == 1\n\t\t\t  || sscanf(fline, \"static char %s = {\", iname) == 1)\n\t\t\t{\n\t\t\t\tmax_bit = 128;\n\t\t\t} else if (sscanf(fline, \"static unsigned short %s = {\", iname) == 1\n\t\t\t\t\t|| sscanf(fline, \"static short %s = {\", iname) == 1)\n\t\t\t{\n\t\t\t\tmax_bit = 32768;\n\t\t\t}\n\t\t\tif (max_bit) {\n                bytes = (width + 7) / 8 * height;\n\t\t\t\tif (!bytes) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tif (!(type = strrchr(iname, '_'))) {\n\t\t\t\t\ttype = iname;\n\t\t\t\t} else {\n\t\t\t\t\ttype++;\n\t\t\t\t}\n\t\t\t\tif (!strcmp(\"bits[]\", type)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n \t\t}\n\t}\n\tif (!bytes || !max_bit) {\n\t\treturn 0;\n\t}\n\n\tif(!(im = gdImageCreate(width, height))) {\n\t\treturn 0;\n\t}\n\tgdImageColorAllocate(im, 255, 255, 255);\n\tgdImageColorAllocate(im, 0, 0, 0);\n\th[2] = '\\0';\n\th[4] = '\\0';\n\tfor (i = 0; i < bytes; i++) {\n\t\twhile (1) {\n\t\t\tif ((ch=getc(fd)) == EOF) {\n\t\t\t\tfail = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (ch == 'x') {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (fail) {\n\t\t\tbreak;\n\t\t}\n\t\t/* Get hex value */\n\t\tif ((ch=getc(fd)) == EOF) {\n\t\t\tbreak;\n\t\t}\n\t\th[0] = ch;\n\t\tif ((ch=getc(fd)) == EOF) {\n\t\t\tbreak;\n\t\t}\n\t\th[1] = ch;\n\t\tif (max_bit == 32768) {\n\t\t\tif ((ch=getc(fd)) == EOF) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\th[2] = ch;\n\t\t\tif ((ch=getc(fd)) == EOF) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\th[3] = ch;\n\t\t}\n\t\tif (sscanf(h, \"%x\", &b) != 1) {\n\t\t\tgd_error(\"invalid XBM\");\n\t\t\tgdImageDestroy(im);\n\t\t\treturn 0;\n\t\t}\n\t\tfor (bit = 1; bit <= max_bit; bit = bit << 1) {\n\t\t\tgdImageSetPixel(im, x++, y, (b & bit) ? 1 : 0);\n\t\t\tif (x == im->sx) {\n\t\t\t\tx = 0;\n\t\t\t\ty++;\n\t\t\t\tif (y == im->sy) {\n\t\t\t\t\treturn im;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tgd_error(\"EOF before image was complete\");\n\tgdImageDestroy(im);\n\treturn 0;\n}\n\n\n/* {{{ gdCtxPrintf */\nstatic void gdCtxPrintf(gdIOCtx * out, const char *format, ...)\n{\n\tchar buf[1024];\n\tint len;\n\tva_list args;\n\n\tva_start(args, format);\n\tlen = vsnprintf(buf, sizeof(buf)-1, format, args);\n\tva_end(args);\n\tout->putBuf(out, buf, len);\n}\n/* }}} */\n\n/* The compiler will optimize strlen(constant) to a constant number. */\n#define gdCtxPuts(out, s) out->putBuf(out, s, strlen(s))\n\n\n/**\n * Function: gdImageXbmCtx\n *\n *  Writes an image to an IO context in X11 bitmap format.\n *\n * Parameters:\n *\n *  image     - The <gdImagePtr> to write.\n *  file_name - The prefix of the XBM's identifiers. Illegal characters are\n *              automatically stripped.\n *  gd        - Which color to use as forground color. All pixels with another\n *              color are unset.\n *  out       - The <gdIOCtx> to write the image file to.\n *\n */\nBGD_DECLARE(void) gdImageXbmCtx(gdImagePtr image, char* file_name, int fg, gdIOCtx * out)\n{\n\tint x, y, c, b, sx, sy, p;\n\tchar *name, *f;\n\tsize_t i, l;\n\n\tname = file_name;\n\tif ((f = strrchr(name, '/')) != NULL) name = f+1;\n\tif ((f = strrchr(name, '\\\\')) != NULL) name = f+1;\n\tname = strdup(name);\n\tif ((f = strrchr(name, '.')) != NULL && !strcasecmp(f, \".XBM\")) *f = '\\0';\n\tif ((l = strlen(name)) == 0) {\n\t\tfree(name);\n\t\tname = strdup(\"image\");\n\t} else {\n\t\tfor (i=0; i<l; i++) {\n\t\t\t/* only in C-locale isalnum() would work */\n\t\t\tif (!isupper(name[i]) && !islower(name[i]) && !isdigit(name[i])) {\n\t\t\t\tname[i] = '_';\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Since \"name\" comes from the user, run it through a direct puts.\n\t * Trying to printf it into a local buffer means we'd need a large\n\t * or dynamic buffer to hold it all. */\n\n\t/* #define <name>_width 1234 */\n\tgdCtxPuts(out, \"#define \");\n\tgdCtxPuts(out, name);\n\tgdCtxPuts(out, \"_width \");\n\tgdCtxPrintf(out, \"%d\\n\", gdImageSX(image));\n\n\t/* #define <name>_height 1234 */\n\tgdCtxPuts(out, \"#define \");\n\tgdCtxPuts(out, name);\n\tgdCtxPuts(out, \"_height \");\n\tgdCtxPrintf(out, \"%d\\n\", gdImageSY(image));\n\n\t/* static unsigned char <name>_bits[] = {\\n */\n\tgdCtxPuts(out, \"static unsigned char \");\n\tgdCtxPuts(out, name);\n\tgdCtxPuts(out, \"_bits[] = {\\n  \");\n\n\tfree(name);\n\n\tb = 1;\n\tp = 0;\n\tc = 0;\n\tsx = gdImageSX(image);\n\tsy = gdImageSY(image);\n\tfor (y = 0; y < sy; y++) {\n\t\tfor (x = 0; x < sx; x++) {\n\t\t\tif (gdImageGetPixel(image, x, y) == fg) {\n\t\t\t\tc |= b;\n\t\t\t}\n\t\t\tif ((b == 128) || (x == sx - 1)) {\n\t\t\t\tb = 1;\n\t\t\t\tif (p) {\n\t\t\t\t\tgdCtxPuts(out, \", \");\n\t\t\t\t\tif (!(p%12)) {\n\t\t\t\t\t\tgdCtxPuts(out, \"\\n  \");\n\t\t\t\t\t\tp = 12;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tp++;\n\t\t\t\tgdCtxPrintf(out, \"0x%02X\", c);\n\t\t\t\tc = 0;\n\t\t\t} else {\n\t\t\t\tb <<= 1;\n\t\t\t}\n\t\t}\n\t}\n\tgdCtxPuts(out, \"};\\n\");\n}\n", "patch": "@@ -180,7 +180,7 @@ BGD_DECLARE(gdImagePtr) gdImageCreateFromXbm(FILE * fd)\n /* {{{ gdCtxPrintf */\n static void gdCtxPrintf(gdIOCtx * out, const char *format, ...)\n {\n-\tchar buf[4096];\n+\tchar buf[1024];\n \tint len;\n \tva_list args;\n \n@@ -191,6 +191,9 @@ static void gdCtxPrintf(gdIOCtx * out, const char *format, ...)\n }\n /* }}} */\n \n+/* The compiler will optimize strlen(constant) to a constant number. */\n+#define gdCtxPuts(out, s) out->putBuf(out, s, strlen(s))\n+\n /* {{{ gdImageXbmCtx */\n BGD_DECLARE(void) gdImageXbmCtx(gdImagePtr image, char* file_name, int fg, gdIOCtx * out)\n {\n@@ -215,9 +218,26 @@ BGD_DECLARE(void) gdImageXbmCtx(gdImagePtr image, char* file_name, int fg, gdIOC\n \t\t}\n \t}\n \n-\tgdCtxPrintf(out, \"#define %s_width %d\\n\", name, gdImageSX(image));\n-\tgdCtxPrintf(out, \"#define %s_height %d\\n\", name, gdImageSY(image));\n-\tgdCtxPrintf(out, \"static unsigned char %s_bits[] = {\\n  \", name);\n+\t/* Since \"name\" comes from the user, run it through a direct puts.\n+\t * Trying to printf it into a local buffer means we'd need a large\n+\t * or dynamic buffer to hold it all. */\n+\n+\t/* #define <name>_width 1234 */\n+\tgdCtxPuts(out, \"#define \");\n+\tgdCtxPuts(out, name);\n+\tgdCtxPuts(out, \"_width \");\n+\tgdCtxPrintf(out, \"%d\\n\", gdImageSX(image));\n+\n+\t/* #define <name>_height 1234 */\n+\tgdCtxPuts(out, \"#define \");\n+\tgdCtxPuts(out, name);\n+\tgdCtxPuts(out, \"_height \");\n+\tgdCtxPrintf(out, \"%d\\n\", gdImageSY(image));\n+\n+\t/* static unsigned char <name>_bits[] = {\\n */\n+\tgdCtxPuts(out, \"static unsigned char \");\n+\tgdCtxPuts(out, name);\n+\tgdCtxPuts(out, \"_bits[] = {\\n  \");\n \n \tfree(name);\n \n@@ -234,9 +254,9 @@ BGD_DECLARE(void) gdImageXbmCtx(gdImagePtr image, char* file_name, int fg, gdIOC\n \t\t\tif ((b == 128) || (x == sx && y == sy)) {\n \t\t\t\tb = 1;\n \t\t\t\tif (p) {\n-\t\t\t\t\tgdCtxPrintf(out, \", \");\n+\t\t\t\t\tgdCtxPuts(out, \", \");\n \t\t\t\t\tif (!(p%12)) {\n-\t\t\t\t\t\tgdCtxPrintf(out, \"\\n  \");\n+\t\t\t\t\t\tgdCtxPuts(out, \"\\n  \");\n \t\t\t\t\t\tp = 12;\n \t\t\t\t\t}\n \t\t\t\t}\n@@ -248,6 +268,6 @@ BGD_DECLARE(void) gdImageXbmCtx(gdImagePtr image, char* file_name, int fg, gdIOC\n \t\t\t}\n \t\t}\n \t}\n-\tgdCtxPrintf(out, \"};\\n\");\n+\tgdCtxPuts(out, \"};\\n\");\n }\n /* }}} */", "file_path": "files/2016_8\\77", "file_language": "c", "file_name": "src/gd_xbm.c", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}], "outdated": 0}
