{"index": 32, "cve_id": "CVE-2016-6515", "cwe_id": ["CWE-20"], "cve_language": "C", "cve_description": "The auth_password function in auth-passwd.c in sshd in OpenSSH before 7.3 does not limit password lengths for password authentication, which allows remote attackers to cause a denial of service (crypt CPU consumption) via a long string.", "cvss": "7.5", "publish_date": "August 6, 2016", "AV": "NETWORK", "AC": "LOW", "PR": "NONE", "UI": "NONE", "S": "UNCHANGED", "C": "NONE", "I": "NONE", "A": "HIGH", "commit_id": "fcd135c9df440bcd2d5870405ad3311743d78d97", "commit_message": "upstream commit\n\nSkip passwords longer than 1k in length so clients can't\neasily DoS sshd by sending very long passwords, causing it to spend CPU\nhashing them. feedback djm@, ok markus@.\n\nBrought to our attention by tomas.kuthan at oracle.com, shilei-c at\n360.cn and coredump at autistici.org\n\nUpstream-ID: d0af7d4a2190b63ba1d38eec502bc4be0be9e333", "commit_date": "2016-07-22T03:36:40Z", "project": "openssh/openssh-portable", "url": "https://api.github.com/repos/openssh/openssh-portable/commits/fcd135c9df440bcd2d5870405ad3311743d78d97", "html_url": "https://github.com/openssh/openssh-portable/commit/fcd135c9df440bcd2d5870405ad3311743d78d97", "windows_before": "", "windows_after": "", "parents": [{"commit_id_before": "324583e8fb3935690be58790425793df619c6d4d", "url_before": "https://api.github.com/repos/openssh/openssh-portable/commits/324583e8fb3935690be58790425793df619c6d4d", "html_url_before": "https://github.com/openssh/openssh-portable/commit/324583e8fb3935690be58790425793df619c6d4d"}], "details": [{"raw_url": "https://github.com/openssh/openssh-portable/raw/fcd135c9df440bcd2d5870405ad3311743d78d97/auth-passwd.c", "code": "/* $OpenBSD: auth-passwd.c,v 1.45 2016/07/21 01:39:35 dtucker Exp $ */\n/*\n * Author: Tatu Ylonen <ylo@cs.hut.fi>\n * Copyright (c) 1995 Tatu Ylonen <ylo@cs.hut.fi>, Espoo, Finland\n *                    All rights reserved\n * Password authentication.  This file contains the functions to check whether\n * the password is valid for the user.\n *\n * As far as I am concerned, the code I have written for this software\n * can be used freely for any purpose.  Any derived versions of this\n * software must be clearly marked as such, and if the derived work is\n * incompatible with the protocol description in the RFC file, it must be\n * called by a name other than \"ssh\" or \"Secure Shell\".\n *\n * Copyright (c) 1999 Dug Song.  All rights reserved.\n * Copyright (c) 2000 Markus Friedl.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"includes.h\"\n\n#include <sys/types.h>\n\n#include <pwd.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n\n#include \"packet.h\"\n#include \"buffer.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"servconf.h\"\n#include \"key.h\"\n#include \"hostfile.h\"\n#include \"auth.h\"\n#include \"auth-options.h\"\n\nextern Buffer loginmsg;\nextern ServerOptions options;\n\n#ifdef HAVE_LOGIN_CAP\nextern login_cap_t *lc;\n#endif\n\n\n#define DAY\t\t(24L * 60 * 60) /* 1 day in seconds */\n#define TWO_WEEKS\t(2L * 7 * DAY)\t/* 2 weeks in seconds */\n\n#define MAX_PASSWORD_LEN\t1024\n\nvoid\ndisable_forwarding(void)\n{\n\tno_port_forwarding_flag = 1;\n\tno_agent_forwarding_flag = 1;\n\tno_x11_forwarding_flag = 1;\n}\n\n/*\n * Tries to authenticate the user using password.  Returns true if\n * authentication succeeds.\n */\nint\nauth_password(Authctxt *authctxt, const char *password)\n{\n\tstruct passwd * pw = authctxt->pw;\n\tint result, ok = authctxt->valid;\n#if defined(USE_SHADOW) && defined(HAS_SHADOW_EXPIRE)\n\tstatic int expire_checked = 0;\n#endif\n\n\tif (strlen(password) > MAX_PASSWORD_LEN)\n\t\treturn 0;\n\n#ifndef HAVE_CYGWIN\n\tif (pw->pw_uid == 0 && options.permit_root_login != PERMIT_YES)\n\t\tok = 0;\n#endif\n\tif (*password == '\\0' && options.permit_empty_passwd == 0)\n\t\treturn 0;\n\n#ifdef KRB5\n\tif (options.kerberos_authentication == 1) {\n\t\tint ret = auth_krb5_password(authctxt, password);\n\t\tif (ret == 1 || ret == 0)\n\t\t\treturn ret && ok;\n\t\t/* Fall back to ordinary passwd authentication. */\n\t}\n#endif\n#ifdef HAVE_CYGWIN\n\t{\n\t\tHANDLE hToken = cygwin_logon_user(pw, password);\n\n\t\tif (hToken == INVALID_HANDLE_VALUE)\n\t\t\treturn 0;\n\t\tcygwin_set_impersonation_token(hToken);\n\t\treturn ok;\n\t}\n#endif\n#ifdef USE_PAM\n\tif (options.use_pam)\n\t\treturn (sshpam_auth_passwd(authctxt, password) && ok);\n#endif\n#if defined(USE_SHADOW) && defined(HAS_SHADOW_EXPIRE)\n\tif (!expire_checked) {\n\t\texpire_checked = 1;\n\t\tif (auth_shadow_pwexpired(authctxt))\n\t\t\tauthctxt->force_pwchange = 1;\n\t}\n#endif\n\tresult = sys_auth_passwd(authctxt, password);\n\tif (authctxt->force_pwchange)\n\t\tdisable_forwarding();\n\treturn (result && ok);\n}\n\n#ifdef BSD_AUTH\nstatic void\nwarn_expiry(Authctxt *authctxt, auth_session_t *as)\n{\n\tchar buf[256];\n\tquad_t pwtimeleft, actimeleft, daysleft, pwwarntime, acwarntime;\n\n\tpwwarntime = acwarntime = TWO_WEEKS;\n\n\tpwtimeleft = auth_check_change(as);\n\tactimeleft = auth_check_expire(as);\n#ifdef HAVE_LOGIN_CAP\n\tif (authctxt->valid) {\n\t\tpwwarntime = login_getcaptime(lc, \"password-warn\", TWO_WEEKS,\n\t\t    TWO_WEEKS);\n\t\tacwarntime = login_getcaptime(lc, \"expire-warn\", TWO_WEEKS,\n\t\t    TWO_WEEKS);\n\t}\n#endif\n\tif (pwtimeleft != 0 && pwtimeleft < pwwarntime) {\n\t\tdaysleft = pwtimeleft / DAY + 1;\n\t\tsnprintf(buf, sizeof(buf),\n\t\t    \"Your password will expire in %lld day%s.\\n\",\n\t\t    daysleft, daysleft == 1 ? \"\" : \"s\");\n\t\tbuffer_append(&loginmsg, buf, strlen(buf));\n\t}\n\tif (actimeleft != 0 && actimeleft < acwarntime) {\n\t\tdaysleft = actimeleft / DAY + 1;\n\t\tsnprintf(buf, sizeof(buf),\n\t\t    \"Your account will expire in %lld day%s.\\n\",\n\t\t    daysleft, daysleft == 1 ? \"\" : \"s\");\n\t\tbuffer_append(&loginmsg, buf, strlen(buf));\n\t}\n}\n\nint\nsys_auth_passwd(Authctxt *authctxt, const char *password)\n{\n\tstruct passwd *pw = authctxt->pw;\n\tauth_session_t *as;\n\tstatic int expire_checked = 0;\n\n\tas = auth_usercheck(pw->pw_name, authctxt->style, \"auth-ssh\",\n\t    (char *)password);\n\tif (as == NULL)\n\t\treturn (0);\n\tif (auth_getstate(as) & AUTH_PWEXPIRED) {\n\t\tauth_close(as);\n\t\tdisable_forwarding();\n\t\tauthctxt->force_pwchange = 1;\n\t\treturn (1);\n\t} else {\n\t\tif (!expire_checked) {\n\t\t\texpire_checked = 1;\n\t\t\twarn_expiry(authctxt, as);\n\t\t}\n\t\treturn (auth_close(as));\n\t}\n}\n#elif !defined(CUSTOM_SYS_AUTH_PASSWD)\nint\nsys_auth_passwd(Authctxt *authctxt, const char *password)\n{\n\tstruct passwd *pw = authctxt->pw;\n\tchar *encrypted_password, *salt = NULL;\n\n\t/* Just use the supplied fake password if authctxt is invalid */\n\tchar *pw_password = authctxt->valid ? shadow_pw(pw) : pw->pw_passwd;\n\n\t/* Check for users with no password. */\n\tif (strcmp(pw_password, \"\") == 0 && strcmp(password, \"\") == 0)\n\t\treturn (1);\n\n\t/*\n\t * Encrypt the candidate password using the proper salt, or pass a\n\t * NULL and let xcrypt pick one.\n\t */\n\tif (authctxt->valid && pw_password[0] && pw_password[1])\n\t\tsalt = pw_password;\n\tencrypted_password = xcrypt(password, salt);\n\n\t/*\n\t * Authentication is accepted if the encrypted passwords\n\t * are identical.\n\t */\n\treturn encrypted_password != NULL &&\n\t    strcmp(encrypted_password, pw_password) == 0;\n}\n#endif\n", "code_before": "/* $OpenBSD: auth-passwd.c,v 1.48 2020/10/18 11:32:01 djm Exp $ */\n/*\n * Author: Tatu Ylonen <ylo@cs.hut.fi>\n * Copyright (c) 1995 Tatu Ylonen <ylo@cs.hut.fi>, Espoo, Finland\n *                    All rights reserved\n * Password authentication.  This file contains the functions to check whether\n * the password is valid for the user.\n *\n * As far as I am concerned, the code I have written for this software\n * can be used freely for any purpose.  Any derived versions of this\n * software must be clearly marked as such, and if the derived work is\n * incompatible with the protocol description in the RFC file, it must be\n * called by a name other than \"ssh\" or \"Secure Shell\".\n *\n * Copyright (c) 1999 Dug Song.  All rights reserved.\n * Copyright (c) 2000 Markus Friedl.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"includes.h\"\n\n#include <sys/types.h>\n\n#include <pwd.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"servconf.h\"\n#include \"sshkey.h\"\n#include \"hostfile.h\"\n#include \"auth.h\"\n#include \"auth-options.h\"\n\nextern struct sshbuf *loginmsg;\nextern ServerOptions options;\n\n#ifdef HAVE_LOGIN_CAP\nextern login_cap_t *lc;\n#endif\n\n\n#define DAY\t\t(24L * 60 * 60) /* 1 day in seconds */\n#define TWO_WEEKS\t(2L * 7 * DAY)\t/* 2 weeks in seconds */\n\n#define MAX_PASSWORD_LEN\t1024\n\n/*\n * Tries to authenticate the user using password.  Returns true if\n * authentication succeeds.\n */\nint\nauth_password(struct ssh *ssh, const char *password)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tstruct passwd *pw = authctxt->pw;\n\tint result, ok = authctxt->valid;\n#if defined(USE_SHADOW) && defined(HAS_SHADOW_EXPIRE)\n\tstatic int expire_checked = 0;\n#endif\n\n\tif (strlen(password) > MAX_PASSWORD_LEN)\n\t\treturn 0;\n\n#ifndef HAVE_CYGWIN\n\tif (pw->pw_uid == 0 && options.permit_root_login != PERMIT_YES)\n\t\tok = 0;\n#endif\n\tif (*password == '\\0' && options.permit_empty_passwd == 0)\n\t\treturn 0;\n\n#ifdef KRB5\n\tif (options.kerberos_authentication == 1) {\n\t\tint ret = auth_krb5_password(authctxt, password);\n\t\tif (ret == 1 || ret == 0)\n\t\t\treturn ret && ok;\n\t\t/* Fall back to ordinary passwd authentication. */\n\t}\n#endif\n#ifdef HAVE_CYGWIN\n\t{\n\t\tHANDLE hToken = cygwin_logon_user(pw, password);\n\n\t\tif (hToken == INVALID_HANDLE_VALUE)\n\t\t\treturn 0;\n\t\tcygwin_set_impersonation_token(hToken);\n\t\treturn ok;\n\t}\n#endif\n#ifdef USE_PAM\n\tif (options.use_pam)\n\t\treturn (sshpam_auth_passwd(authctxt, password) && ok);\n#endif\n#if defined(USE_SHADOW) && defined(HAS_SHADOW_EXPIRE)\n\tif (!expire_checked) {\n\t\texpire_checked = 1;\n\t\tif (auth_shadow_pwexpired(authctxt))\n\t\t\tauthctxt->force_pwchange = 1;\n\t}\n#endif\n\tresult = sys_auth_passwd(ssh, password);\n\tif (authctxt->force_pwchange)\n\t\tauth_restrict_session(ssh);\n\treturn (result && ok);\n}\n\n#ifdef BSD_AUTH\nstatic void\nwarn_expiry(Authctxt *authctxt, auth_session_t *as)\n{\n\tint r;\n\tquad_t pwtimeleft, actimeleft, daysleft, pwwarntime, acwarntime;\n\n\tpwwarntime = acwarntime = TWO_WEEKS;\n\n\tpwtimeleft = auth_check_change(as);\n\tactimeleft = auth_check_expire(as);\n#ifdef HAVE_LOGIN_CAP\n\tif (authctxt->valid) {\n\t\tpwwarntime = login_getcaptime(lc, \"password-warn\", TWO_WEEKS,\n\t\t    TWO_WEEKS);\n\t\tacwarntime = login_getcaptime(lc, \"expire-warn\", TWO_WEEKS,\n\t\t    TWO_WEEKS);\n\t}\n#endif\n\tif (pwtimeleft != 0 && pwtimeleft < pwwarntime) {\n\t\tdaysleft = pwtimeleft / DAY + 1;\n\t\tif ((r = sshbuf_putf(loginmsg,\n\t\t    \"Your password will expire in %lld day%s.\\n\",\n\t\t    daysleft, daysleft == 1 ? \"\" : \"s\")) != 0)\n\t\t\tfatal_fr(r, \"buffer error\");\n\t}\n\tif (actimeleft != 0 && actimeleft < acwarntime) {\n\t\tdaysleft = actimeleft / DAY + 1;\n\t\tif ((r = sshbuf_putf(loginmsg,\n\t\t    \"Your account will expire in %lld day%s.\\n\",\n\t\t    daysleft, daysleft == 1 ? \"\" : \"s\")) != 0)\n\t\t\tfatal_fr(r, \"buffer error\");\n\t}\n}\n\nint\nsys_auth_passwd(struct ssh *ssh, const char *password)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tauth_session_t *as;\n\tstatic int expire_checked = 0;\n\n\tas = auth_usercheck(authctxt->pw->pw_name, authctxt->style, \"auth-ssh\",\n\t    (char *)password);\n\tif (as == NULL)\n\t\treturn (0);\n\tif (auth_getstate(as) & AUTH_PWEXPIRED) {\n\t\tauth_close(as);\n\t\tauth_restrict_session(ssh);\n\t\tauthctxt->force_pwchange = 1;\n\t\treturn (1);\n\t} else {\n\t\tif (!expire_checked) {\n\t\t\texpire_checked = 1;\n\t\t\twarn_expiry(authctxt, as);\n\t\t}\n\t\treturn (auth_close(as));\n\t}\n}\n#elif !defined(CUSTOM_SYS_AUTH_PASSWD)\nint\nsys_auth_passwd(struct ssh *ssh, const char *password)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tstruct passwd *pw = authctxt->pw;\n\tchar *encrypted_password, *salt = NULL;\n\n\t/* Just use the supplied fake password if authctxt is invalid */\n\tchar *pw_password = authctxt->valid ? shadow_pw(pw) : pw->pw_passwd;\n\n\tif (pw_password == NULL)\n\t\treturn 0;\n\n\t/* Check for users with no password. */\n\tif (strcmp(pw_password, \"\") == 0 && strcmp(password, \"\") == 0)\n\t\treturn (1);\n\n\t/*\n\t * Encrypt the candidate password using the proper salt, or pass a\n\t * NULL and let xcrypt pick one.\n\t */\n\tif (authctxt->valid && pw_password[0] && pw_password[1])\n\t\tsalt = pw_password;\n\tencrypted_password = xcrypt(password, salt);\n\n\t/*\n\t * Authentication is accepted if the encrypted passwords\n\t * are identical.\n\t */\n\treturn encrypted_password != NULL &&\n\t    strcmp(encrypted_password, pw_password) == 0;\n}\n#endif\n", "patch": "@@ -1,4 +1,4 @@\n-/* $OpenBSD: auth-passwd.c,v 1.44 2014/07/15 15:54:14 millert Exp $ */\n+/* $OpenBSD: auth-passwd.c,v 1.45 2016/07/21 01:39:35 dtucker Exp $ */\n /*\n  * Author: Tatu Ylonen <ylo@cs.hut.fi>\n  * Copyright (c) 1995 Tatu Ylonen <ylo@cs.hut.fi>, Espoo, Finland\n@@ -66,6 +66,8 @@ extern login_cap_t *lc;\n #define DAY\t\t(24L * 60 * 60) /* 1 day in seconds */\n #define TWO_WEEKS\t(2L * 7 * DAY)\t/* 2 weeks in seconds */\n \n+#define MAX_PASSWORD_LEN\t1024\n+\n void\n disable_forwarding(void)\n {\n@@ -87,6 +89,9 @@ auth_password(Authctxt *authctxt, const char *password)\n \tstatic int expire_checked = 0;\n #endif\n \n+\tif (strlen(password) > MAX_PASSWORD_LEN)\n+\t\treturn 0;\n+\n #ifndef HAVE_CYGWIN\n \tif (pw->pw_uid == 0 && options.permit_root_login != PERMIT_YES)\n \t\tok = 0;", "file_path": "files/2016_8\\81", "file_language": "c", "file_name": "auth-passwd.c", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}], "outdated": 0}
