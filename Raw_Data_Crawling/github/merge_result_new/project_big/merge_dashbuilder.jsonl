{"index": 51, "cve_id": "CVE-2016-4999", "cwe_id": ["CWE-89"], "cve_language": "Java", "cve_description": "SQL injection vulnerability in the getStringParameterSQL method in main/java/org/dashbuilder/dataprovider/sql/dialect/DefaultDialect.java in Dashbuilder before 0.6.0.Beta1 allows remote attackers to execute arbitrary SQL commands via a data set lookup filter in the (1) Data Set Authoring or (2) Displayer editor UI.", "cvss": "9.8", "publish_date": "August 5, 2016", "AV": "NETWORK", "AC": "LOW", "PR": "NONE", "UI": "NONE", "S": "UNCHANGED", "C": "HIGH", "I": "HIGH", "A": "HIGH", "commit_id": "8574899e3b6455547b534f570b2330ff772e524b", "commit_message": "DASHBUILDE-113: SQL Injection on data set lookup filters", "commit_date": "2016-06-27T16:05:57Z", "project": "dashbuilder/dashbuilder", "url": "https://api.github.com/repos/dashbuilder/dashbuilder/commits/8574899e3b6455547b534f570b2330ff772e524b", "html_url": "https://github.com/dashbuilder/dashbuilder/commit/8574899e3b6455547b534f570b2330ff772e524b", "windows_before": "", "windows_after": "", "parents": [{"commit_id_before": "469921ce5a31b91b95c93e410f5f0a2ba5fbbfc7", "url_before": "https://api.github.com/repos/dashbuilder/dashbuilder/commits/469921ce5a31b91b95c93e410f5f0a2ba5fbbfc7", "html_url_before": "https://github.com/dashbuilder/dashbuilder/commit/469921ce5a31b91b95c93e410f5f0a2ba5fbbfc7"}], "details": [{"raw_url": "https://github.com/dashbuilder/dashbuilder/raw/8574899e3b6455547b534f570b2330ff772e524b/dashbuilder-backend/dashbuilder-dataset-sql/src/main/java/org/dashbuilder/dataprovider/sql/dialect/DefaultDialect.java", "code": "/*\n * Copyright 2015 Red Hat, Inc. and/or its affiliates.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.dashbuilder.dataprovider.sql.dialect;\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.text.SimpleDateFormat;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Date;\nimport java.util.List;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.dashbuilder.dataprovider.sql.model.Column;\nimport org.dashbuilder.dataprovider.sql.model.Condition;\nimport org.dashbuilder.dataprovider.sql.model.CoreCondition;\nimport org.dashbuilder.dataprovider.sql.model.CreateTable;\nimport org.dashbuilder.dataprovider.sql.model.Delete;\nimport org.dashbuilder.dataprovider.sql.model.DynamicDateColumn;\nimport org.dashbuilder.dataprovider.sql.model.FixedDateColumn;\nimport org.dashbuilder.dataprovider.sql.model.FunctionColumn;\nimport org.dashbuilder.dataprovider.sql.model.Insert;\nimport org.dashbuilder.dataprovider.sql.model.LogicalCondition;\nimport org.dashbuilder.dataprovider.sql.model.SQLStatement;\nimport org.dashbuilder.dataprovider.sql.model.Select;\nimport org.dashbuilder.dataprovider.sql.model.SimpleColumn;\nimport org.dashbuilder.dataprovider.sql.model.SortColumn;\nimport org.dashbuilder.dataprovider.sql.model.Table;\nimport org.dashbuilder.dataset.ColumnType;\nimport org.dashbuilder.dataset.filter.CoreFunctionType;\nimport org.dashbuilder.dataset.filter.LogicalExprType;\nimport org.dashbuilder.dataset.group.AggregateFunctionType;\nimport org.dashbuilder.dataset.group.DateIntervalType;\nimport org.dashbuilder.dataset.sort.SortOrder;\n\nimport static org.dashbuilder.dataprovider.sql.SQLFactory.*;\n\npublic class DefaultDialect implements Dialect {\n\n    private static final String AND = \" AND \";\n\n    @Override\n    public String[] getExcludedColumns() {\n        return new String[] {};\n    }\n\n    @Override\n    public String getColumnSQL(Column column) {\n\n        if (column instanceof FunctionColumn) {\n            return getFunctionColumnSQL((FunctionColumn) column);\n        }\n        else if (column instanceof SortColumn) {\n            return getSortColumnSQL((SortColumn) column);\n        }\n        else if (column instanceof DynamicDateColumn) {\n            return getDynamicDateColumnSQL((DynamicDateColumn) column);\n        }\n        else if (column instanceof FixedDateColumn) {\n            return getFixedDateColumnSQL((FixedDateColumn) column);\n        }\n        else if (column instanceof SimpleColumn) {\n            return getSimpleColumnSQL((SimpleColumn) column);\n        }\n        else {\n            return getColumnNameSQL(column.getName());\n        }\n    }\n\n    @Override\n    public String getColumnTypeSQL(Column column) {\n        switch (column.getType()) {\n            case NUMBER: {\n                return \"NUMERIC(28,2)\";\n            }\n            case DATE: {\n                return \"TIMESTAMP\";\n            }\n            default: {\n                return \"VARCHAR(\" + column.getLength() + \")\";\n            }\n        }\n    }\n\n    @Override\n    public String convertToString(Object value) {\n        try {\n            return value == null ? null : (String) value;\n        } catch (ClassCastException e) {\n            return value.toString();\n        }\n    }\n\n    @Override\n    public Double convertToDouble(Object value) {\n        try {\n            return value == null ? null : ((Number) value).doubleValue();\n        } catch (ClassCastException e) {\n            return Double.parseDouble(value.toString());\n        }\n    }\n\n    @Override\n    public Date convertToDate(Object value) {\n        try {\n            return value == null ? null : (Date) value;\n        } catch (ClassCastException e) {\n            throw new IllegalArgumentException(\"Not a java.util.Date: \" + value + \" (\" + value.getClass().getName() + \")\");\n        }\n    }\n\n    @Override\n    public String getTableSQL(SQLStatement<?> stmt) {\n        Table table = stmt.getTable();\n        String name = getTableNameSQL(table.getName());\n        if (StringUtils.isBlank(table.getSchema())) {\n            return name;\n        } else{\n            return getSchemaNameSQL(table.getSchema()) + \".\" + name;\n        }\n    }\n\n    @Override\n    public String getTableNameSQL(String name) {\n        return name;\n    }\n\n    @Override\n    public String getSchemaNameSQL(String name) {\n        return name;\n    }\n\n    @Override\n    public String getSimpleColumnSQL(SimpleColumn column) {\n        String result = getColumnNameSQL(column.getName());\n        if (column.getFunctionType() != null) {\n            result = getColumnFunctionSQL(result, column.getFunctionType());\n        }\n        return result;\n    }\n\n    @Override\n    public String getFunctionColumnSQL(FunctionColumn column) {\n        if (FunctionColumn.LOWER.equals(column.getFunction())) {\n            return getLowerFunctionSQL(column.getColumns()[0]);\n        }\n        if (FunctionColumn.CONCAT.equals(column.getFunction())) {\n            return getConcatFunctionSQL(column.getColumns());\n        }\n        if (FunctionColumn.YEAR.equals(column.getFunction())) {\n            return getDatePartFunctionSQL(\"YEAR\", column.getColumns()[0]);\n        }\n        if (FunctionColumn.MONTH.equals(column.getFunction())) {\n            return getDatePartFunctionSQL(\"MONTH\", column.getColumns()[0]);\n        }\n        if (FunctionColumn.DAY.equals(column.getFunction())) {\n            return getDatePartFunctionSQL(\"DAY\", column.getColumns()[0]);\n        }\n        if (FunctionColumn.HOUR.equals(column.getFunction())) {\n            return getDatePartFunctionSQL(\"HOUR\", column.getColumns()[0]);\n        }\n        if (FunctionColumn.MINUTE.equals(column.getFunction())) {\n            return getDatePartFunctionSQL(\"MINUTE\", column.getColumns()[0]);\n        }\n        if (FunctionColumn.SECOND.equals(column.getFunction())) {\n            return getDatePartFunctionSQL(\"SECOND\", column.getColumns()[0]);\n        }\n        throw new IllegalArgumentException(\"Column function not supported: \" + column.getFunction());\n    }\n\n    @Override\n    public String getLowerFunctionSQL(Column column) {\n        String columnSQL = getColumnSQL(column);\n        return \"LOWER(\" + columnSQL + \")\";\n    }\n\n    @Override\n    public String getConcatFunctionSQL(Column[] columns) {\n        return getConcatFunctionSQL(columns, \"(\", \")\", \" || \");\n    }\n\n    public String getConcatFunctionSQL(Column[] columns, String begin, String end, String separator) {\n        StringBuilder out = new StringBuilder();\n        out.append(begin);\n        for (int i = 0; i < columns.length; i++) {\n            if (i > 0) out.append(separator);\n            Column column = columns[i];\n            ColumnType type = column.getType();\n            if (ColumnType.LABEL.equals(type) || ColumnType.TEXT.equals(type)) {\n                out.append(\"'\").append(column.getName()).append(\"'\");\n            } else {\n                // Cast needed\n                out.append(getColumnCastSQL(column));\n            }\n        }\n        out.append(end);\n        return out.toString();\n    }\n\n    public String getColumnCastSQL(Column column) {\n        String columnSQL = getColumnSQL(column);\n        return \"CAST(\" + columnSQL + \" AS VARCHAR)\";\n    }\n\n    @Override\n    public String getDatePartFunctionSQL(String part, Column column) {\n        String columnSQL = getColumnSQL(column);\n        return \"EXTRACT(\" + part + \" FROM \" + columnSQL + \")\";\n    }\n\n    @Override\n    public String getSortColumnSQL(SortColumn sortColumn) {\n\n        Column column = sortColumn.getSource();\n        String columnSQL = getColumnSQL(column);\n\n        // Always order by the alias (if any)\n        if (!StringUtils.isBlank(column.getAlias())) {\n            columnSQL = getAliasForStatementSQL(column.getAlias());\n        }\n        return columnSQL + \" \" + getSortOrderSQL(sortColumn.getOrder());\n    }\n\n    @Override\n    public String getSortOrderSQL(SortOrder order) {\n        if (SortOrder.ASCENDING.equals(order)) {\n            return \"ASC\";\n        }\n        if (SortOrder.DESCENDING.equals(order)) {\n            return \"DESC\";\n        }\n        throw new IllegalArgumentException(\"Sort order not supported: \" + order);\n    }\n\n    /**\n     * The text conversion of a date column is very DB specific.\n     * A mechanism combining  concat and extract functions is used by default.\n     * Depending on the DB dialect a more polished approach can be used.\n     * For instance, <ul>\n     * <li>In Oracle and Postgres the 'to_char' function is used.</li>\n     * <li>In Mysql, 'date_format'</li>\n     * <li>In H2, the 'to_char' function is not used as it's only available since version 1.3.175 and we do need to support older versions.</li>\n     * </ul>\n     */\n    @Override\n    public String getDynamicDateColumnSQL(DynamicDateColumn column) {\n        Column dateColumn = toChar(column);\n        return getColumnSQL(dateColumn);\n    }\n\n    public Column toChar(DynamicDateColumn column) {\n        Column target = column(column.getName());\n        DateIntervalType type = column.getDateType();\n        Column SEPARATOR_DATE = column(\"-\", ColumnType.TEXT, 3);\n        Column SEPARATOR_EMPTY = column(\" \", ColumnType.TEXT, 3);\n        Column SEPARATOR_TIME = column(\":\", ColumnType.TEXT, 3);\n\n        if (DateIntervalType.SECOND.equals(type)) {\n            return concat(target.year(), SEPARATOR_DATE,\n                    target.month(), SEPARATOR_DATE,\n                    target.day(), SEPARATOR_EMPTY,\n                    target.hour(), SEPARATOR_TIME,\n                    target.minute(), SEPARATOR_TIME,\n                    target.second());\n        }\n        if (DateIntervalType.MINUTE.equals(type)) {\n            return concat(target.year(), SEPARATOR_DATE,\n                    target.month(), SEPARATOR_DATE,\n                    target.day(), SEPARATOR_EMPTY,\n                    target.hour(), SEPARATOR_TIME,\n                    target.minute());\n        }\n        if (DateIntervalType.HOUR.equals(type)) {\n            return concat(target.year(), SEPARATOR_DATE,\n                    target.month(), SEPARATOR_DATE,\n                    target.day(), SEPARATOR_EMPTY,\n                    target.hour());\n        }\n        if (DateIntervalType.DAY.equals(type) || DateIntervalType.WEEK.equals(type)) {\n            return concat(target.year(), SEPARATOR_DATE,\n                    target.month(), SEPARATOR_DATE,\n                    target.day());\n        }\n        if (DateIntervalType.MONTH.equals(type)\n                || DateIntervalType.QUARTER.equals(type)) {\n\n            return concat(target.year(), SEPARATOR_DATE,\n                    target.month());\n        }\n        if (DateIntervalType.YEAR.equals(type)\n                || DateIntervalType.DECADE.equals(type)\n                || DateIntervalType.CENTURY.equals(type)\n                || DateIntervalType.MILLENIUM.equals(type)) {\n\n            return target.year();\n        }\n        throw new IllegalArgumentException(\"Group '\" + target.getName() +\n                \"' by the given date interval type is not supported: \" + type);\n    }\n\n    @Override\n    public String getFixedDateColumnSQL(FixedDateColumn column) {\n        Column target = column(column.getName());\n        DateIntervalType type = column.getDateType();\n        if (DateIntervalType.SECOND.equals(type)) {\n            return getColumnSQL(target.second());\n        }\n        if (DateIntervalType.MINUTE.equals(type)) {\n            return getColumnSQL(target.minute());\n        }\n        if (DateIntervalType.HOUR.equals(type)) {\n            return getColumnSQL(target.hour());\n        }\n        if (DateIntervalType.DAY_OF_WEEK.equals(type)) {\n            return getColumnSQL(target.day());\n        }\n        if (DateIntervalType.MONTH.equals(type)) {\n            return getColumnSQL(target.month());\n        }\n        if (DateIntervalType.QUARTER.equals(type)) {\n            // Emulated using month and converted to quarter during the data set post-processing\n            return getColumnSQL(target.month());\n        }\n        throw new IllegalArgumentException(\"Interval size '\" + type + \"' not supported for \" +\n                \"fixed date intervals. The only supported sizes are: \" +\n                StringUtils.join(DateIntervalType.FIXED_INTERVALS_SUPPORTED, \",\"));\n    }\n\n    @Override\n    public String getColumnNameSQL(String name) {\n        return name;\n    }\n\n    @Override\n    public String getColumnNameQuotedSQL(String name) {\n        return \"\\\"\" + name + \"\\\"\";\n    }\n\n    @Override\n    public String getAliasForColumnSQL(String alias) {\n        return \"\\\"\" + alias + \"\\\"\";\n    }\n\n    @Override\n    public String getAliasForStatementSQL(String alias) {\n        return \"\\\"\" + alias + \"\\\"\";\n    }\n\n    @Override\n    public String getConditionSQL(Condition condition) {\n        if (condition instanceof CoreCondition) {\n            return getCoreConditionSQL((CoreCondition) condition);\n        }\n        if (condition instanceof LogicalCondition) {\n            return getLogicalConditionSQL((LogicalCondition) condition);\n        }\n        throw new IllegalArgumentException(\"Condition type not supported: \" + condition);\n    }\n\n    @Override\n    public String getCoreConditionSQL(CoreCondition condition) {\n        String columnSQL = getColumnSQL(condition.getColumn());\n        CoreFunctionType type = condition.getFunction();\n        Object[] params = condition.getParameters();\n        if (CoreFunctionType.IS_NULL.equals(type)) {\n            return getIsNullConditionSQL(columnSQL);\n        }\n        if (CoreFunctionType.NOT_NULL.equals(type)) {\n            return getNotNullConditionSQL(columnSQL);\n        }\n        if (CoreFunctionType.EQUALS_TO.equals(type)) {\n            return getIsEqualsToConditionSQL(columnSQL, params[0]);\n        }\n        if (CoreFunctionType.NOT_EQUALS_TO.equals(type)) {\n            return getNotEqualsToConditionSQL(columnSQL, params[0]);\n        }\n        if (CoreFunctionType.NOT_EQUALS_TO.equals(type)) {\n            return getNotEqualsToConditionSQL(columnSQL, params[0]);\n        }\n        if (CoreFunctionType.LIKE_TO.equals(type)) {\n            return getLikeToConditionSQL(columnSQL, params[0]);\n        }\n        if (CoreFunctionType.GREATER_THAN.equals(type)) {\n            return getGreaterThanConditionSQL(columnSQL, params[0]);\n        }\n        if (CoreFunctionType.GREATER_OR_EQUALS_TO.equals(type)) {\n            return getGreaterOrEqualsConditionSQL(columnSQL, params[0]);\n        }\n        if (CoreFunctionType.LOWER_THAN.equals(type)) {\n            return getLowerThanConditionSQL(columnSQL, params[0]);\n        }\n        if (CoreFunctionType.LOWER_OR_EQUALS_TO.equals(type)) {\n            return getLowerOrEqualsConditionSQL(columnSQL, params[0]);\n        }\n        if (CoreFunctionType.BETWEEN.equals(type)) {\n            return getBetweenConditionSQL(columnSQL, params[0], params[1]);\n        }\n        if (CoreFunctionType.IN.equals(type)) {\n            return getInConditionSQL(columnSQL, params[0]);\n        }\n        if (CoreFunctionType.NOT_IN.equals(type)) {\n            return getNotInConditionSQL(columnSQL, params[0]);\n        }\n\n        throw new IllegalArgumentException(\"Core condition type not supported: \" + type);\n    }\n\n    @Override\n    public String getNotNullConditionSQL(String column) {\n        return column + \" IS NOT NULL\";\n    }\n\n    @Override\n    public String getIsNullConditionSQL(String column) {\n        return column + \" IS NULL\";\n    }\n\n    @Override\n    public String getIsEqualsToConditionSQL(String column, Object param) {\n        if (param == null) {\n            return getIsNullConditionSQL(column);\n        } else {\n            String paramStr = getParameterSQL(param);\n            return column + \" = \" + paramStr;\n        }\n    }\n\n    @Override\n    public String getNotEqualsToConditionSQL(String column, Object param) {\n        if (param == null) {\n            return getNotNullConditionSQL(column);\n        } else {\n            String paramStr = getParameterSQL(param);\n            return column + \" <> \" + paramStr;\n        }\n    }\n\n    @Override\n    public String getLikeToConditionSQL(String column, Object param) {\n        String paramStr = getParameterSQL(param);\n        return column + \" LIKE \" + paramStr;\n    }\n\n    @Override\n    public String getGreaterThanConditionSQL(String column, Object param) {\n        String paramStr = getParameterSQL(param);\n        return column + \" > \" + paramStr;\n    }\n\n    @Override\n    public String getGreaterOrEqualsConditionSQL(String column, Object param) {\n        String paramStr = getParameterSQL(param);\n        return column + \" >= \" + paramStr;\n    }\n\n    @Override\n    public String getLowerThanConditionSQL(String column, Object param) {\n        String paramStr = getParameterSQL(param);\n        return column + \" < \" + paramStr;\n    }\n\n    @Override\n    public String getLowerOrEqualsConditionSQL(String column, Object param) {\n        String paramStr = getParameterSQL(param);\n        return column + \" <= \" + paramStr;\n    }\n\n    @Override\n    public String getBetweenConditionSQL(String column, Object from, Object to) {\n        String fromStr = getParameterSQL(from);\n        String toStr = getParameterSQL(to);\n        return column + \" BETWEEN \" + fromStr + AND + toStr;\n    }\n\n    @Override\n    public String getInConditionSQL(String column, Object param) {\n        StringBuilder inStatement = new StringBuilder();\n        inStatement.append(column);\n        inStatement.append(\" IN (\");\n\n        for (Object p : (Collection<?>) param) {\n\n            inStatement.append(getParameterSQL(p) + \",\");\n        }\n        inStatement.deleteCharAt(inStatement.length()-1);\n        inStatement.append(\")\");\n        return inStatement.toString();\n    }\n\n    @Override\n    public String getNotInConditionSQL(String column, Object param) {\n        StringBuilder inStatement = new StringBuilder();\n        inStatement.append(column);\n        inStatement.append(\" NOT IN (\");\n\n        for (Object p : (Collection<?>) param) {\n\n            inStatement.append(getParameterSQL(p) + \",\");\n        }\n        inStatement.deleteCharAt(inStatement.length()-1);\n        inStatement.append(\")\");\n        return inStatement.toString();\n    }\n\n    @Override\n    public String getParameterSQL(Object param) {\n        if (param == null) {\n            return \"null\";\n        }\n        if (param instanceof Number) {\n            return getNumberParameterSQL((Number) param);\n        }\n        if (param instanceof Date) {\n            return getDateParameterSQL((Date) param);\n        }\n        return getStringParameterSQL(param.toString());\n    }\n\n\n    @Override\n    public String getNumberParameterSQL(Number param) {\n        return param.toString();\n    }\n\n    SimpleDateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss.S\");\n\n    @Override\n    public String getDateParameterSQL(Date param) {\n        // timestamp '2015-08-24 13:14:36.615'\n        return \"TIMESTAMP '\" + dateFormat.format(param) + \"'\";\n    }\n\n    @Override\n    public String getStringParameterSQL(String param) {\n        // DASHBUILDE-113: SQL Injection on data set lookup filters\n        String escapedParam = param.replaceAll(\"'\", \"''\");\n        return \"'\" + escapedParam + \"'\";\n    }\n\n    @Override\n    public String getLogicalConditionSQL(LogicalCondition condition) {\n        LogicalExprType type = condition.getType();\n        Condition[] conditions = condition.getConditions();\n        if (LogicalExprType.NOT.equals(type)) {\n            return getNotExprConditionSQL(conditions[0]);\n        }\n        if (LogicalExprType.AND.equals(type)) {\n            return getAndExprConditionSQL(conditions);\n        }\n        if (LogicalExprType.OR.equals(type)) {\n            return getOrExprConditionSQL(conditions);\n        }\n        throw new IllegalArgumentException(\"Logical condition type not supported: \" + type);\n    }\n\n    @Override\n    public String getNotExprConditionSQL(Condition condition) {\n        String conditionSQL = getConditionSQL(condition);\n        return \"NOT(\" + conditionSQL + \")\";\n    }\n\n    @Override\n    public String getAndExprConditionSQL(Condition[] conditions) {\n        return _getLogicalExprConditionSQL(conditions, \"AND\");\n    }\n\n    @Override\n    public String getOrExprConditionSQL(Condition[] conditions) {\n        return _getLogicalExprConditionSQL(conditions, \"OR\");\n    }\n\n    protected String _getLogicalExprConditionSQL(Condition[] conditions, String op) {\n        StringBuilder out = new StringBuilder();\n        out.append(\"(\");\n        for (int i = 0; i < conditions.length; i++) {\n            Condition condition = conditions[i];\n            String conditionSQL = getConditionSQL(condition);\n            if (i > 0) {\n                out.append(\" \").append(op).append(\" \");\n            }\n            out.append(conditionSQL);\n        }\n        out.append(\")\");\n        return out.toString();\n    }\n\n    @Override\n    public String getColumnFunctionSQL(String column, AggregateFunctionType function) {\n        switch (function) {\n            case SUM: {\n                return \"SUM(\" + column + \")\";\n            }\n            case MAX: {\n                return \"MAX(\" + column + \")\";\n            }\n            case MIN: {\n                return \"MIN(\" + column + \")\";\n            }\n            case AVERAGE: {\n                return \"AVG(\" + column + \")\";\n            }\n            case COUNT: {\n                return \"COUNT(\" + column + \")\";\n            }\n            case DISTINCT: {\n                return \"COUNT(DISTINCT \" + column + \")\";\n            }\n            default: {\n                throw new IllegalArgumentException(\"Function type not valid: \" + function);\n            }\n        }\n    }\n\n    @Override\n    public String getCountQuerySQL(Select select) {\n        List<SortColumn> sortColumns = new ArrayList<SortColumn>();\n        sortColumns.addAll(select.getOrderBys());\n        try {\n            // Remove ORDER BY for better performance\n            select.getOrderBys().clear();\n            return \"SELECT \"\n                    + getColumnFunctionSQL(\"*\", AggregateFunctionType.COUNT)\n                    + \" FROM (\" + select.getSQL() + \") \"\n                    + getAliasForColumnSQL(\"dbSQL\");\n        } finally {\n            select.orderBy(sortColumns);\n        }\n    }\n\n    @Override\n    public String getSQL(CreateTable create) {\n        StringBuilder sql = new StringBuilder(\"CREATE TABLE \");\n        List<String> pkeys = new ArrayList<String>();\n        String tname = getTableSQL(create);\n        sql.append(tname);\n\n        // Columns\n        boolean first = true;\n        sql.append(\" (\\n\");\n        for (Column column : create.getColumns()) {\n            if (!first) {\n                sql.append(\",\\n\");\n            }\n            String name = getColumnNameSQL(column.getName());\n            String type = getColumnTypeSQL(column);\n            sql.append(\" \").append(name).append(\" \").append(type);\n            if (create.getPrimaryKeys().contains(column)) {\n                sql.append(\" NOT NULL\");\n                pkeys.add(name);\n            }\n            first = false;\n        }\n        if (!create.getPrimaryKeys().isEmpty()) {\n            sql.append(\",\\n\");\n            sql.append(\" PRIMARY KEY(\");\n            sql.append(StringUtils.join(pkeys, \",\"));\n            sql.append(\")\\n\");\n        }\n        sql.append(\")\");\n        return sql.toString();\n    }\n\n    @Override\n    public String getSQL(Select select) {\n        // Select clause\n        StringBuilder sql = new StringBuilder();\n        String selectClause = getSelectSQL(select);\n        sql.append(selectClause);\n\n        // From clause (inner SQL or table)\n        sql.append(\" \").append(getFromSQL(select));\n\n        // Where clauses\n        List<Condition> wheres = select.getWheres();\n        if (!wheres.isEmpty()) {\n            sql.append(\" \").append(getWhereSQL(select));\n        }\n\n        // Group by\n        List<Column> groupBys = select.getGroupBys();\n        if (!groupBys.isEmpty()) {\n            sql.append(\" \").append(getGroupBySQL(select));\n        }\n\n        // Order by\n        List<SortColumn> orderBys = select.getOrderBys();\n        if (!orderBys.isEmpty()) {\n            sql.append(\" \").append(getOrderBySQL(select));\n        }\n\n        // Limits\n        int limit = select.getLimit();\n        int offset = select.getOffset();\n        if (limit > 0 || offset > 0) {\n            String limitSql = getOffsetLimitSQL(select);\n            if (!StringUtils.isBlank(limitSql)) {\n                sql.append(limitSql);\n            }\n        }\n        return sql.toString();\n    }\n\n    @Override\n    public String getSQL(Insert insert) {\n        // Insert clause\n        StringBuilder sql = new StringBuilder();\n        String insertClause = getInsertStatement(insert);\n        sql.append(insertClause);\n\n        // Table\n        sql.append(\" \").append(getTableSQL(insert));\n\n        // Columns\n        boolean first = true;\n        sql.append(\" (\");\n        for (Column column : insert.getColumns()) {\n            if (!first) {\n                sql.append(\",\");\n            }\n            String str = getColumnSQL(column);\n            sql.append(str);\n            first = false;\n        }\n        sql.append(\")\");\n\n        // Values\n        first = true;\n        sql.append(\" VALUES (\");\n        for (Object value : insert.getValues()) {\n            if (!first) {\n                sql.append(\",\");\n            }\n            String str = getParameterSQL(value);\n            sql.append(str);\n            first = false;\n        }\n        sql.append(\")\");\n        return sql.toString();\n    }\n\n    @Override\n    public String getSQL(Delete delete) {\n        // Delete clause\n        StringBuilder sql = new StringBuilder();\n        String deleteClause = getDeleteStatement(delete);\n        sql.append(deleteClause);\n\n        // From clause\n        sql.append(\" \").append(getTableSQL(delete));\n\n        // Where clauses\n        List<Condition> wheres = delete.getWheres();\n        if (!wheres.isEmpty()) {\n            sql.append(\" \").append(getWhereSQL(delete));\n        }\n\n        return sql.toString();\n    }\n\n    @Override\n    public String getSelectSQL(Select select) {\n        StringBuilder clause = new StringBuilder();\n        clause.append(getSelectStatement(select));\n\n        clause.append(\" \");\n        if (select.getColumns().isEmpty()) {\n            clause.append(\"*\");\n        } else {\n            boolean first = true;\n            for (Column column : select.getColumns()) {\n                if (!first) {\n                    clause.append(\", \");\n                }\n                String str = getColumnSQL(column);\n                boolean aliasNonEmpty = !StringUtils.isBlank(column.getAlias());\n                boolean isSimpleColumn = (column instanceof SimpleColumn) && !str.equals(getColumnNameSQL(column.getAlias()));\n\n                if (aliasNonEmpty && (allowAliasInStatements() || isSimpleColumn)) {\n                    str += \" \" + getAliasForColumnSQL(column.getAlias());\n                }\n                clause.append(str);\n                first = false;\n            }\n        }\n        return clause.toString();\n    }\n\n    @Override\n    public String getFromSQL(Select select) {\n        String fromSelect = select.getFromSelect();\n        Table fromTable = select.getFromTable();\n        String from = getFromStatement(select);\n\n        if (fromSelect != null) {\n            String alias = getAliasForColumnSQL(\"dbSQL\");\n            return from  + \" (\" + fromSelect + \") \" + alias;\n        }\n        else if (fromTable != null ){\n            String table = getTableSQL(select);\n            return from + \" \" + table;\n        }\n        return \"\";\n    }\n\n    @Override\n    public String getWhereSQL(Select select) {\n        StringBuilder sql = new StringBuilder();\n        List<Condition> wheres = select.getWheres();\n        boolean first = true;\n        for (Condition condition : wheres) {\n            if (first) {\n                sql.append(getWhereStatement(select)).append(\" \");\n            } else {\n                sql.append(AND);\n            }\n            String str = getConditionSQL(condition);\n            sql.append(str);\n            first = false;\n        }\n        return sql.toString();\n    }\n\n    @Override\n    public String getWhereSQL(Delete delete) {\n        StringBuilder sql = new StringBuilder();\n        List<Condition> wheres = delete.getWheres();\n        boolean first = true;\n        for (Condition condition : wheres) {\n            if (first) {\n                sql.append(getWhereStatement(delete)).append(\" \");\n            } else {\n                sql.append(AND);\n            }\n            String str = getConditionSQL(condition);\n            sql.append(str);\n            first = false;\n        }\n        return sql.toString();\n    }\n\n    @Override\n    public String getGroupBySQL(Select select) {\n        StringBuilder sql = new StringBuilder();\n        List<Column> groupBys = select.getGroupBys();\n        boolean first = true;\n        for (Column column : groupBys) {\n            if (first) {\n                sql.append(getGroupByStatement(select)).append(\" \");\n            } else {\n                sql.append(\", \");\n            }\n            Column aliasColumn = allowAliasInStatements() ? getAliasStatement(select, column) : null;\n            sql.append(aliasColumn != null ? getAliasForStatementSQL(aliasColumn.getAlias()) : getColumnSQL(column));\n            first = false;\n        }\n        return sql.toString();\n    }\n\n    @Override\n    public String getOrderBySQL(Select select) {\n        StringBuilder sql = new StringBuilder();\n        List<SortColumn> orderBys = select.getOrderBys();\n        boolean first = true;\n        for (SortColumn column : orderBys) {\n            if (first) {\n                sql.append(getOrderByStatement(select)).append(\" \");\n            } else {\n                sql.append(\", \");\n            }\n            Column aliasColumn = allowAliasInStatements() ? getAliasStatement(select, column.getSource()) : null;\n            if (aliasColumn != null) {\n                column = new SortColumn(aliasColumn, column.getOrder());\n            }\n            String str = getSortColumnSQL(column);\n            sql.append(str);\n            first = false;\n        }\n        return sql.toString();\n    }\n\n    @Override\n    public String getOffsetLimitSQL(Select select) {\n        int offset = select.getOffset();\n        int limit = select.getLimit();\n        StringBuilder out = new StringBuilder();\n        if (limit > 0) out.append(\" LIMIT \").append(limit);\n        if (offset > 0) out.append(\" OFFSET \").append(offset);\n        return out.toString();\n    }\n\n    @Override\n    public String getSelectStatement(Select select) {\n        return \"SELECT\";\n    }\n\n    @Override\n    public String getInsertStatement(Insert insert) {\n        return \"INSERT INTO\";\n    }\n\n    @Override\n    public String getDeleteStatement(Delete delete) {\n        return \"DELETE FROM\";\n    }\n\n    @Override\n    public String getFromStatement(Select select) {\n        return \"FROM\";\n    }\n\n    @Override\n    public String getWhereStatement(Select select) {\n        return \"WHERE\";\n    }\n\n    @Override\n    public String getWhereStatement(Delete delete) {\n        return \"WHERE\";\n    }\n\n    @Override\n    public String getGroupByStatement(Select select) {\n        return \"GROUP BY\";\n    }\n\n    @Override\n    public String getOrderByStatement(Select select) {\n        return \"ORDER BY\";\n    }\n\n    // Helper methods\n\n    protected Object invokeMethod(Object o, String methodName, Object[] params) {\n        Method methods[] = o.getClass().getMethods();\n        for (int i = 0; i < methods.length; ++i) {\n            if (methodName.equals(methods[i].getName())) {\n                try {\n                    methods[i].setAccessible(true);\n                    return methods[i].invoke(o, params);\n                }\n                catch (IllegalAccessException ex) {\n                    return null;\n                }\n                catch (InvocationTargetException ite) {\n                    return null;\n                }\n            }\n        }\n        return null;\n    }\n\n    public boolean areEquals(Column column1, Column column2) {\n        if (!column1.getName().equals(column2.getName())) {\n            return false;\n        }\n        if (!column1.getClass().getName().equals(column2.getClass().getName())) {\n            return false;\n        }\n        if (column1 instanceof DynamicDateColumn) {\n            DynamicDateColumn dd1 = (DynamicDateColumn) column1;\n            DynamicDateColumn dd2 = (DynamicDateColumn) column2;\n            if (!dd1.getDateType().equals(dd2.getDateType())) {\n                return false;\n            }\n        }\n        if (column1 instanceof FixedDateColumn) {\n            FixedDateColumn fd1 = (FixedDateColumn) column1;\n            FixedDateColumn fd2 = (FixedDateColumn) column2;\n            if (!fd1.getDateType().equals(fd2.getDateType())) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public boolean allowAliasInStatements() {\n        return false;\n    }\n\n    public Column getAliasStatement(Select select, Column target) {\n        for (Column column : select.getColumns()) {\n            if (!(column instanceof SimpleColumn) &&\n                    !StringUtils.isBlank(column.getAlias()) &&\n                    areEquals(column, target)) {\n\n                return column;\n            }\n        }\n        return null;\n    }\n}\n", "code_before": "/*\n * Copyright 2015 Red Hat, Inc. and/or its affiliates.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.dashbuilder.dataprovider.sql.dialect;\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.text.SimpleDateFormat;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Date;\nimport java.util.List;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.dashbuilder.dataprovider.sql.model.Column;\nimport org.dashbuilder.dataprovider.sql.model.Condition;\nimport org.dashbuilder.dataprovider.sql.model.CoreCondition;\nimport org.dashbuilder.dataprovider.sql.model.CreateTable;\nimport org.dashbuilder.dataprovider.sql.model.Delete;\nimport org.dashbuilder.dataprovider.sql.model.DynamicDateColumn;\nimport org.dashbuilder.dataprovider.sql.model.FixedDateColumn;\nimport org.dashbuilder.dataprovider.sql.model.FunctionColumn;\nimport org.dashbuilder.dataprovider.sql.model.Insert;\nimport org.dashbuilder.dataprovider.sql.model.LogicalCondition;\nimport org.dashbuilder.dataprovider.sql.model.SQLStatement;\nimport org.dashbuilder.dataprovider.sql.model.Select;\nimport org.dashbuilder.dataprovider.sql.model.SimpleColumn;\nimport org.dashbuilder.dataprovider.sql.model.SortColumn;\nimport org.dashbuilder.dataprovider.sql.model.Table;\nimport org.dashbuilder.dataset.ColumnType;\nimport org.dashbuilder.dataset.filter.CoreFunctionType;\nimport org.dashbuilder.dataset.filter.LogicalExprType;\nimport org.dashbuilder.dataset.group.AggregateFunctionType;\nimport org.dashbuilder.dataset.group.DateIntervalType;\nimport org.dashbuilder.dataset.sort.SortOrder;\n\nimport static org.dashbuilder.dataprovider.sql.SQLFactory.*;\n\npublic class DefaultDialect implements Dialect {\n\n    private static final String AND = \" AND \";\n\n    @Override\n    public String[] getExcludedColumns() {\n        return new String[] {};\n    }\n\n    @Override\n    public String getColumnSQL(Column column) {\n\n        if (column instanceof FunctionColumn) {\n            return getFunctionColumnSQL((FunctionColumn) column);\n        }\n        else if (column instanceof SortColumn) {\n            return getSortColumnSQL((SortColumn) column);\n        }\n        else if (column instanceof DynamicDateColumn) {\n            return getDynamicDateColumnSQL((DynamicDateColumn) column);\n        }\n        else if (column instanceof FixedDateColumn) {\n            return getFixedDateColumnSQL((FixedDateColumn) column);\n        }\n        else if (column instanceof SimpleColumn) {\n            return getSimpleColumnSQL((SimpleColumn) column);\n        }\n        else {\n            return getColumnNameSQL(column.getName());\n        }\n    }\n\n    @Override\n    public String getColumnTypeSQL(Column column) {\n        switch (column.getType()) {\n            case NUMBER: {\n                return \"NUMERIC(28,2)\";\n            }\n            case DATE: {\n                return \"TIMESTAMP\";\n            }\n            default: {\n                return \"VARCHAR(\" + column.getLength() + \")\";\n            }\n        }\n    }\n\n    @Override\n    public String convertToString(Object value) {\n        try {\n            return value == null ? null : (String) value;\n        } catch (ClassCastException e) {\n            return value.toString();\n        }\n    }\n\n    @Override\n    public Double convertToDouble(Object value) {\n        try {\n            return value == null ? null : ((Number) value).doubleValue();\n        } catch (ClassCastException e) {\n            return Double.parseDouble(value.toString());\n        }\n    }\n\n    @Override\n    public Date convertToDate(Object value) {\n        try {\n            return value == null ? null : (Date) value;\n        } catch (ClassCastException e) {\n            throw new IllegalArgumentException(\"Not a java.util.Date: \" + value + \" (\" + value.getClass().getName() + \")\");\n        }\n    }\n\n    @Override\n    public String getTableSQL(SQLStatement<?> stmt) {\n        Table table = stmt.getTable();\n        String name = getTableNameSQL(table.getName());\n        if (StringUtils.isBlank(table.getSchema())) {\n            return name;\n        } else{\n            return getSchemaNameSQL(table.getSchema()) + \".\" + name;\n        }\n    }\n\n    @Override\n    public String getTableNameSQL(String name) {\n        return name;\n    }\n\n    @Override\n    public String getSchemaNameSQL(String name) {\n        return name;\n    }\n\n    @Override\n    public String getSimpleColumnSQL(SimpleColumn column) {\n        String result = getColumnNameSQL(column.getName());\n        if (column.getFunctionType() != null) {\n            result = getColumnFunctionSQL(result, column.getFunctionType());\n        }\n        return result;\n    }\n\n    @Override\n    public String getFunctionColumnSQL(FunctionColumn column) {\n        if (FunctionColumn.LOWER.equals(column.getFunction())) {\n            return getLowerFunctionSQL(column.getColumns()[0]);\n        }\n        if (FunctionColumn.CONCAT.equals(column.getFunction())) {\n            return getConcatFunctionSQL(column.getColumns());\n        }\n        if (FunctionColumn.YEAR.equals(column.getFunction())) {\n            return getDatePartFunctionSQL(\"YEAR\", column.getColumns()[0]);\n        }\n        if (FunctionColumn.MONTH.equals(column.getFunction())) {\n            return getDatePartFunctionSQL(\"MONTH\", column.getColumns()[0]);\n        }\n        if (FunctionColumn.DAY.equals(column.getFunction())) {\n            return getDatePartFunctionSQL(\"DAY\", column.getColumns()[0]);\n        }\n        if (FunctionColumn.HOUR.equals(column.getFunction())) {\n            return getDatePartFunctionSQL(\"HOUR\", column.getColumns()[0]);\n        }\n        if (FunctionColumn.MINUTE.equals(column.getFunction())) {\n            return getDatePartFunctionSQL(\"MINUTE\", column.getColumns()[0]);\n        }\n        if (FunctionColumn.SECOND.equals(column.getFunction())) {\n            return getDatePartFunctionSQL(\"SECOND\", column.getColumns()[0]);\n        }\n        throw new IllegalArgumentException(\"Column function not supported: \" + column.getFunction());\n    }\n\n    @Override\n    public String getLowerFunctionSQL(Column column) {\n        String columnSQL = getColumnSQL(column);\n        return \"LOWER(\" + columnSQL + \")\";\n    }\n\n    @Override\n    public String getConcatFunctionSQL(Column[] columns) {\n        return getConcatFunctionSQL(columns, \"(\", \")\", \" || \");\n    }\n\n    public String getConcatFunctionSQL(Column[] columns, String begin, String end, String separator) {\n        StringBuilder out = new StringBuilder();\n        out.append(begin);\n        for (int i = 0; i < columns.length; i++) {\n            if (i > 0) out.append(separator);\n            Column column = columns[i];\n            ColumnType type = column.getType();\n            if (ColumnType.LABEL.equals(type) || ColumnType.TEXT.equals(type)) {\n                out.append(\"'\").append(column.getName()).append(\"'\");\n            } else {\n                // Cast needed\n                out.append(getColumnCastSQL(column));\n            }\n        }\n        out.append(end);\n        return out.toString();\n    }\n\n    public String getColumnCastSQL(Column column) {\n        String columnSQL = getColumnSQL(column);\n        return \"CAST(\" + columnSQL + \" AS VARCHAR)\";\n    }\n\n    @Override\n    public String getDatePartFunctionSQL(String part, Column column) {\n        String columnSQL = getColumnSQL(column);\n        return \"EXTRACT(\" + part + \" FROM \" + columnSQL + \")\";\n    }\n\n    @Override\n    public String getSortColumnSQL(SortColumn sortColumn) {\n\n        Column column = sortColumn.getSource();\n        String columnSQL = getColumnSQL(column);\n\n        // Always order by the alias (if any)\n        if (!StringUtils.isBlank(column.getAlias())) {\n            columnSQL = getAliasForStatementSQL(column.getAlias());\n        }\n        return columnSQL + \" \" + getSortOrderSQL(sortColumn.getOrder());\n    }\n\n    @Override\n    public String getSortOrderSQL(SortOrder order) {\n        if (SortOrder.ASCENDING.equals(order)) {\n            return \"ASC\";\n        }\n        if (SortOrder.DESCENDING.equals(order)) {\n            return \"DESC\";\n        }\n        throw new IllegalArgumentException(\"Sort order not supported: \" + order);\n    }\n\n    /**\n     * The text conversion of a date column is very DB specific.\n     * A mechanism combining  concat and extract functions is used by default.\n     * Depending on the DB dialect a more polished approach can be used.\n     * For instance, <ul>\n     * <li>In Oracle and Postgres the 'to_char' function is used.</li>\n     * <li>In Mysql, 'date_format'</li>\n     * <li>In H2, the 'to_char' function is not used as it's only available since version 1.3.175 and we do need to support older versions.</li>\n     * </ul>\n     */\n    @Override\n    public String getDynamicDateColumnSQL(DynamicDateColumn column) {\n        Column dateColumn = toChar(column);\n        return getColumnSQL(dateColumn);\n    }\n\n    public Column toChar(DynamicDateColumn column) {\n        Column target = column(column.getName());\n        DateIntervalType type = column.getDateType();\n        Column SEPARATOR_DATE = column(\"-\", ColumnType.TEXT, 3);\n        Column SEPARATOR_EMPTY = column(\" \", ColumnType.TEXT, 3);\n        Column SEPARATOR_TIME = column(\":\", ColumnType.TEXT, 3);\n\n        if (DateIntervalType.SECOND.equals(type)) {\n            return concat(target.year(), SEPARATOR_DATE,\n                    target.month(), SEPARATOR_DATE,\n                    target.day(), SEPARATOR_EMPTY,\n                    target.hour(), SEPARATOR_TIME,\n                    target.minute(), SEPARATOR_TIME,\n                    target.second());\n        }\n        if (DateIntervalType.MINUTE.equals(type)) {\n            return concat(target.year(), SEPARATOR_DATE,\n                    target.month(), SEPARATOR_DATE,\n                    target.day(), SEPARATOR_EMPTY,\n                    target.hour(), SEPARATOR_TIME,\n                    target.minute());\n        }\n        if (DateIntervalType.HOUR.equals(type)) {\n            return concat(target.year(), SEPARATOR_DATE,\n                    target.month(), SEPARATOR_DATE,\n                    target.day(), SEPARATOR_EMPTY,\n                    target.hour());\n        }\n        if (DateIntervalType.DAY.equals(type) || DateIntervalType.WEEK.equals(type)) {\n            return concat(target.year(), SEPARATOR_DATE,\n                    target.month(), SEPARATOR_DATE,\n                    target.day());\n        }\n        if (DateIntervalType.MONTH.equals(type)\n                || DateIntervalType.QUARTER.equals(type)) {\n\n            return concat(target.year(), SEPARATOR_DATE,\n                    target.month());\n        }\n        if (DateIntervalType.YEAR.equals(type)\n                || DateIntervalType.DECADE.equals(type)\n                || DateIntervalType.CENTURY.equals(type)\n                || DateIntervalType.MILLENIUM.equals(type)) {\n\n            return target.year();\n        }\n        throw new IllegalArgumentException(\"Group '\" + target.getName() +\n                \"' by the given date interval type is not supported: \" + type);\n    }\n\n    @Override\n    public String getFixedDateColumnSQL(FixedDateColumn column) {\n        Column target = column(column.getName());\n        DateIntervalType type = column.getDateType();\n        if (DateIntervalType.SECOND.equals(type)) {\n            return getColumnSQL(target.second());\n        }\n        if (DateIntervalType.MINUTE.equals(type)) {\n            return getColumnSQL(target.minute());\n        }\n        if (DateIntervalType.HOUR.equals(type)) {\n            return getColumnSQL(target.hour());\n        }\n        if (DateIntervalType.DAY_OF_WEEK.equals(type)) {\n            return getColumnSQL(target.day());\n        }\n        if (DateIntervalType.MONTH.equals(type)) {\n            return getColumnSQL(target.month());\n        }\n        if (DateIntervalType.QUARTER.equals(type)) {\n            // Emulated using month and converted to quarter during the data set post-processing\n            return getColumnSQL(target.month());\n        }\n        throw new IllegalArgumentException(\"Interval size '\" + type + \"' not supported for \" +\n                \"fixed date intervals. The only supported sizes are: \" +\n                StringUtils.join(DateIntervalType.FIXED_INTERVALS_SUPPORTED, \",\"));\n    }\n\n    @Override\n    public String getColumnNameSQL(String name) {\n        return name;\n    }\n\n    @Override\n    public String getColumnNameQuotedSQL(String name) {\n        return \"\\\"\" + name + \"\\\"\";\n    }\n\n    @Override\n    public String getAliasForColumnSQL(String alias) {\n        return \"\\\"\" + alias + \"\\\"\";\n    }\n\n    @Override\n    public String getAliasForStatementSQL(String alias) {\n        return \"\\\"\" + alias + \"\\\"\";\n    }\n\n    @Override\n    public String getConditionSQL(Condition condition) {\n        if (condition instanceof CoreCondition) {\n            return getCoreConditionSQL((CoreCondition) condition);\n        }\n        if (condition instanceof LogicalCondition) {\n            return getLogicalConditionSQL((LogicalCondition) condition);\n        }\n        throw new IllegalArgumentException(\"Condition type not supported: \" + condition);\n    }\n\n    @Override\n    public String getCoreConditionSQL(CoreCondition condition) {\n        String columnSQL = getColumnSQL(condition.getColumn());\n        CoreFunctionType type = condition.getFunction();\n        Object[] params = condition.getParameters();\n        if (CoreFunctionType.IS_NULL.equals(type)) {\n            return getIsNullConditionSQL(columnSQL);\n        }\n        if (CoreFunctionType.NOT_NULL.equals(type)) {\n            return getNotNullConditionSQL(columnSQL);\n        }\n        if (CoreFunctionType.EQUALS_TO.equals(type)) {\n            return getIsEqualsToConditionSQL(columnSQL, params[0]);\n        }\n        if (CoreFunctionType.NOT_EQUALS_TO.equals(type)) {\n            return getNotEqualsToConditionSQL(columnSQL, params[0]);\n        }\n        if (CoreFunctionType.NOT_EQUALS_TO.equals(type)) {\n            return getNotEqualsToConditionSQL(columnSQL, params[0]);\n        }\n        if (CoreFunctionType.LIKE_TO.equals(type)) {\n            return getLikeToConditionSQL(columnSQL, params[0]);\n        }\n        if (CoreFunctionType.GREATER_THAN.equals(type)) {\n            return getGreaterThanConditionSQL(columnSQL, params[0]);\n        }\n        if (CoreFunctionType.GREATER_OR_EQUALS_TO.equals(type)) {\n            return getGreaterOrEqualsConditionSQL(columnSQL, params[0]);\n        }\n        if (CoreFunctionType.LOWER_THAN.equals(type)) {\n            return getLowerThanConditionSQL(columnSQL, params[0]);\n        }\n        if (CoreFunctionType.LOWER_OR_EQUALS_TO.equals(type)) {\n            return getLowerOrEqualsConditionSQL(columnSQL, params[0]);\n        }\n        if (CoreFunctionType.BETWEEN.equals(type)) {\n            return getBetweenConditionSQL(columnSQL, params[0], params[1]);\n        }\n        if (CoreFunctionType.IN.equals(type)) {\n            return getInConditionSQL(columnSQL, params[0]);\n        }\n        if (CoreFunctionType.NOT_IN.equals(type)) {\n            return getNotInConditionSQL(columnSQL, params[0]);\n        }\n\n        throw new IllegalArgumentException(\"Core condition type not supported: \" + type);\n    }\n\n    @Override\n    public String getNotNullConditionSQL(String column) {\n        return column + \" IS NOT NULL\";\n    }\n\n    @Override\n    public String getIsNullConditionSQL(String column) {\n        return column + \" IS NULL\";\n    }\n\n    @Override\n    public String getIsEqualsToConditionSQL(String column, Object param) {\n        if (param == null) {\n            return getIsNullConditionSQL(column);\n        } else {\n            String paramStr = getParameterSQL(param);\n            return column + \" = \" + paramStr;\n        }\n    }\n\n    @Override\n    public String getNotEqualsToConditionSQL(String column, Object param) {\n        if (param == null) {\n            return getNotNullConditionSQL(column);\n        } else {\n            String paramStr = getParameterSQL(param);\n            return column + \" <> \" + paramStr;\n        }\n    }\n\n    @Override\n    public String getLikeToConditionSQL(String column, Object param) {\n        String paramStr = getParameterSQL(param);\n        return column + \" LIKE \" + paramStr;\n    }\n\n    @Override\n    public String getGreaterThanConditionSQL(String column, Object param) {\n        String paramStr = getParameterSQL(param);\n        return column + \" > \" + paramStr;\n    }\n\n    @Override\n    public String getGreaterOrEqualsConditionSQL(String column, Object param) {\n        String paramStr = getParameterSQL(param);\n        return column + \" >= \" + paramStr;\n    }\n\n    @Override\n    public String getLowerThanConditionSQL(String column, Object param) {\n        String paramStr = getParameterSQL(param);\n        return column + \" < \" + paramStr;\n    }\n\n    @Override\n    public String getLowerOrEqualsConditionSQL(String column, Object param) {\n        String paramStr = getParameterSQL(param);\n        return column + \" <= \" + paramStr;\n    }\n\n    @Override\n    public String getBetweenConditionSQL(String column, Object from, Object to) {\n        String fromStr = getParameterSQL(from);\n        String toStr = getParameterSQL(to);\n        return column + \" BETWEEN \" + fromStr + AND + toStr;\n    }\n\n    @Override\n    public String getInConditionSQL(String column, Object param) {\n        StringBuilder inStatement = new StringBuilder();\n        inStatement.append(column);\n        inStatement.append(\" IN (\");\n\n        for (Object p : (Collection<?>) param) {\n\n            inStatement.append(getParameterSQL(p) + \",\");\n        }\n        inStatement.deleteCharAt(inStatement.length()-1);\n        inStatement.append(\")\");\n        return inStatement.toString();\n    }\n\n    @Override\n    public String getNotInConditionSQL(String column, Object param) {\n        StringBuilder inStatement = new StringBuilder();\n        inStatement.append(column);\n        inStatement.append(\" NOT IN (\");\n\n        for (Object p : (Collection<?>) param) {\n\n            inStatement.append(getParameterSQL(p) + \",\");\n        }\n        inStatement.deleteCharAt(inStatement.length()-1);\n        inStatement.append(\")\");\n        return inStatement.toString();\n    }\n\n    @Override\n    public String getParameterSQL(Object param) {\n        if (param == null) {\n            return \"null\";\n        }\n        if (param instanceof Number) {\n            return getNumberParameterSQL((Number) param);\n        }\n        if (param instanceof Date) {\n            return getDateParameterSQL((Date) param);\n        }\n        return getStringParameterSQL(param.toString());\n    }\n\n\n    @Override\n    public String getNumberParameterSQL(Number param) {\n        return param.toString();\n    }\n\n    SimpleDateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss.S\");\n\n    @Override\n    public String getDateParameterSQL(Date param) {\n        // timestamp '2015-08-24 13:14:36.615'\n        return \"TIMESTAMP '\" + dateFormat.format(param) + \"'\";\n    }\n\n    @Override\n    public String getStringParameterSQL(String param) {\n        // DASHBUILDE-113: SQL Injection on data set lookup filters\n        String escapedParam = param.replaceAll(\"'\", \"''\");\n        return \"'\" + escapedParam + \"'\";\n    }\n\n    @Override\n    public String getLogicalConditionSQL(LogicalCondition condition) {\n        LogicalExprType type = condition.getType();\n        Condition[] conditions = condition.getConditions();\n        if (LogicalExprType.NOT.equals(type)) {\n            return getNotExprConditionSQL(conditions[0]);\n        }\n        if (LogicalExprType.AND.equals(type)) {\n            return getAndExprConditionSQL(conditions);\n        }\n        if (LogicalExprType.OR.equals(type)) {\n            return getOrExprConditionSQL(conditions);\n        }\n        throw new IllegalArgumentException(\"Logical condition type not supported: \" + type);\n    }\n\n    @Override\n    public String getNotExprConditionSQL(Condition condition) {\n        String conditionSQL = getConditionSQL(condition);\n        return \"NOT(\" + conditionSQL + \")\";\n    }\n\n    @Override\n    public String getAndExprConditionSQL(Condition[] conditions) {\n        return _getLogicalExprConditionSQL(conditions, \"AND\");\n    }\n\n    @Override\n    public String getOrExprConditionSQL(Condition[] conditions) {\n        return _getLogicalExprConditionSQL(conditions, \"OR\");\n    }\n\n    protected String _getLogicalExprConditionSQL(Condition[] conditions, String op) {\n        StringBuilder out = new StringBuilder();\n        out.append(\"(\");\n        for (int i = 0; i < conditions.length; i++) {\n            Condition condition = conditions[i];\n            String conditionSQL = getConditionSQL(condition);\n            if (i > 0) {\n                out.append(\" \").append(op).append(\" \");\n            }\n            out.append(conditionSQL);\n        }\n        out.append(\")\");\n        return out.toString();\n    }\n\n    @Override\n    public String getColumnFunctionSQL(String column, AggregateFunctionType function) {\n        switch (function) {\n            case SUM: {\n                return \"SUM(\" + column + \")\";\n            }\n            case MAX: {\n                return \"MAX(\" + column + \")\";\n            }\n            case MIN: {\n                return \"MIN(\" + column + \")\";\n            }\n            case AVERAGE: {\n                return \"AVG(\" + column + \")\";\n            }\n            case COUNT: {\n                return \"COUNT(\" + column + \")\";\n            }\n            case DISTINCT: {\n                return \"COUNT(DISTINCT \" + column + \")\";\n            }\n            default: {\n                throw new IllegalArgumentException(\"Function type not valid: \" + function);\n            }\n        }\n    }\n\n    @Override\n    public String getCountQuerySQL(Select select) {\n        List<SortColumn> sortColumns = new ArrayList<SortColumn>();\n        sortColumns.addAll(select.getOrderBys());\n        try {\n            // Remove ORDER BY for better performance\n            select.getOrderBys().clear();\n            return \"SELECT \"\n                    + getColumnFunctionSQL(\"*\", AggregateFunctionType.COUNT)\n                    + \" FROM (\" + select.getSQL() + \") \"\n                    + getAliasForColumnSQL(\"dbSQL\");\n        } finally {\n            select.orderBy(sortColumns);\n        }\n    }\n\n    @Override\n    public String getSQL(CreateTable create) {\n        StringBuilder sql = new StringBuilder(\"CREATE TABLE \");\n        List<String> pkeys = new ArrayList<String>();\n        String tname = getTableSQL(create);\n        sql.append(tname);\n\n        // Columns\n        boolean first = true;\n        sql.append(\" (\\n\");\n        for (Column column : create.getColumns()) {\n            if (!first) {\n                sql.append(\",\\n\");\n            }\n            String name = getColumnNameSQL(column.getName());\n            String type = getColumnTypeSQL(column);\n            sql.append(\" \").append(name).append(\" \").append(type);\n            if (create.getPrimaryKeys().contains(column)) {\n                sql.append(\" NOT NULL\");\n                pkeys.add(name);\n            }\n            first = false;\n        }\n        if (!create.getPrimaryKeys().isEmpty()) {\n            sql.append(\",\\n\");\n            sql.append(\" PRIMARY KEY(\");\n            sql.append(StringUtils.join(pkeys, \",\"));\n            sql.append(\")\\n\");\n        }\n        sql.append(\")\");\n        return sql.toString();\n    }\n\n    @Override\n    public String getSQL(Select select) {\n        // Select clause\n        StringBuilder sql = new StringBuilder();\n        String selectClause = getSelectSQL(select);\n        sql.append(selectClause);\n\n        // From clause (inner SQL or table)\n        sql.append(\" \").append(getFromSQL(select));\n\n        // Where clauses\n        List<Condition> wheres = select.getWheres();\n        if (!wheres.isEmpty()) {\n            sql.append(\" \").append(getWhereSQL(select));\n        }\n\n        // Group by\n        List<Column> groupBys = select.getGroupBys();\n        if (!groupBys.isEmpty()) {\n            sql.append(\" \").append(getGroupBySQL(select));\n        }\n\n        // Order by\n        List<SortColumn> orderBys = select.getOrderBys();\n        if (!orderBys.isEmpty()) {\n            sql.append(\" \").append(getOrderBySQL(select));\n        }\n\n        // Limits\n        int limit = select.getLimit();\n        int offset = select.getOffset();\n        if (limit > 0 || offset > 0) {\n            String limitSql = getOffsetLimitSQL(select);\n            if (!StringUtils.isBlank(limitSql)) {\n                sql.append(limitSql);\n            }\n        }\n        return sql.toString();\n    }\n\n    @Override\n    public String getSQL(Insert insert) {\n        // Insert clause\n        StringBuilder sql = new StringBuilder();\n        String insertClause = getInsertStatement(insert);\n        sql.append(insertClause);\n\n        // Table\n        sql.append(\" \").append(getTableSQL(insert));\n\n        // Columns\n        boolean first = true;\n        sql.append(\" (\");\n        for (Column column : insert.getColumns()) {\n            if (!first) {\n                sql.append(\",\");\n            }\n            String str = getColumnSQL(column);\n            sql.append(str);\n            first = false;\n        }\n        sql.append(\")\");\n\n        // Values\n        first = true;\n        sql.append(\" VALUES (\");\n        for (Object value : insert.getValues()) {\n            if (!first) {\n                sql.append(\",\");\n            }\n            String str = getParameterSQL(value);\n            sql.append(str);\n            first = false;\n        }\n        sql.append(\")\");\n        return sql.toString();\n    }\n\n    @Override\n    public String getSQL(Delete delete) {\n        // Delete clause\n        StringBuilder sql = new StringBuilder();\n        String deleteClause = getDeleteStatement(delete);\n        sql.append(deleteClause);\n\n        // From clause\n        sql.append(\" \").append(getTableSQL(delete));\n\n        // Where clauses\n        List<Condition> wheres = delete.getWheres();\n        if (!wheres.isEmpty()) {\n            sql.append(\" \").append(getWhereSQL(delete));\n        }\n\n        return sql.toString();\n    }\n\n    @Override\n    public String getSelectSQL(Select select) {\n        StringBuilder clause = new StringBuilder();\n        clause.append(getSelectStatement(select));\n\n        clause.append(\" \");\n        if (select.getColumns().isEmpty()) {\n            clause.append(\"*\");\n        } else {\n            boolean first = true;\n            for (Column column : select.getColumns()) {\n                if (!first) {\n                    clause.append(\", \");\n                }\n                String str = getColumnSQL(column);\n                boolean aliasNonEmpty = !StringUtils.isBlank(column.getAlias());\n                boolean isSimpleColumn = (column instanceof SimpleColumn) && !str.equals(getColumnNameSQL(column.getAlias()));\n\n                if (aliasNonEmpty && (allowAliasInStatements() || isSimpleColumn)) {\n                    str += \" \" + getAliasForColumnSQL(column.getAlias());\n                }\n                clause.append(str);\n                first = false;\n            }\n        }\n        return clause.toString();\n    }\n\n    @Override\n    public String getFromSQL(Select select) {\n        String fromSelect = select.getFromSelect();\n        Table fromTable = select.getFromTable();\n        String from = getFromStatement(select);\n\n        if (fromSelect != null) {\n            String alias = getAliasForColumnSQL(\"dbSQL\");\n            return from  + \" (\" + fromSelect + \") \" + alias;\n        }\n        else if (fromTable != null ){\n            String table = getTableSQL(select);\n            return from + \" \" + table;\n        }\n        return \"\";\n    }\n\n    @Override\n    public String getWhereSQL(Select select) {\n        StringBuilder sql = new StringBuilder();\n        List<Condition> wheres = select.getWheres();\n        boolean first = true;\n        for (Condition condition : wheres) {\n            if (first) {\n                sql.append(getWhereStatement(select)).append(\" \");\n            } else {\n                sql.append(AND);\n            }\n            String str = getConditionSQL(condition);\n            sql.append(str);\n            first = false;\n        }\n        return sql.toString();\n    }\n\n    @Override\n    public String getWhereSQL(Delete delete) {\n        StringBuilder sql = new StringBuilder();\n        List<Condition> wheres = delete.getWheres();\n        boolean first = true;\n        for (Condition condition : wheres) {\n            if (first) {\n                sql.append(getWhereStatement(delete)).append(\" \");\n            } else {\n                sql.append(AND);\n            }\n            String str = getConditionSQL(condition);\n            sql.append(str);\n            first = false;\n        }\n        return sql.toString();\n    }\n\n    @Override\n    public String getGroupBySQL(Select select) {\n        StringBuilder sql = new StringBuilder();\n        List<Column> groupBys = select.getGroupBys();\n        boolean first = true;\n        for (Column column : groupBys) {\n            if (first) {\n                sql.append(getGroupByStatement(select)).append(\" \");\n            } else {\n                sql.append(\", \");\n            }\n            Column aliasColumn = allowAliasInStatements() ? getAliasStatement(select, column) : null;\n            sql.append(aliasColumn != null ? getAliasForStatementSQL(aliasColumn.getAlias()) : getColumnSQL(column));\n            first = false;\n        }\n        return sql.toString();\n    }\n\n    @Override\n    public String getOrderBySQL(Select select) {\n        StringBuilder sql = new StringBuilder();\n        List<SortColumn> orderBys = select.getOrderBys();\n        boolean first = true;\n        for (SortColumn column : orderBys) {\n            if (first) {\n                sql.append(getOrderByStatement(select)).append(\" \");\n            } else {\n                sql.append(\", \");\n            }\n            Column aliasColumn = allowAliasInStatements() ? getAliasStatement(select, column.getSource()) : null;\n            if (aliasColumn != null) {\n                column = new SortColumn(aliasColumn, column.getOrder());\n            }\n            String str = getSortColumnSQL(column);\n            sql.append(str);\n            first = false;\n        }\n        return sql.toString();\n    }\n\n    @Override\n    public String getOffsetLimitSQL(Select select) {\n        int offset = select.getOffset();\n        int limit = select.getLimit();\n        StringBuilder out = new StringBuilder();\n        if (limit > 0) out.append(\" LIMIT \").append(limit);\n        if (offset > 0) out.append(\" OFFSET \").append(offset);\n        return out.toString();\n    }\n\n    @Override\n    public String getSelectStatement(Select select) {\n        return \"SELECT\";\n    }\n\n    @Override\n    public String getInsertStatement(Insert insert) {\n        return \"INSERT INTO\";\n    }\n\n    @Override\n    public String getDeleteStatement(Delete delete) {\n        return \"DELETE FROM\";\n    }\n\n    @Override\n    public String getFromStatement(Select select) {\n        return \"FROM\";\n    }\n\n    @Override\n    public String getWhereStatement(Select select) {\n        return \"WHERE\";\n    }\n\n    @Override\n    public String getWhereStatement(Delete delete) {\n        return \"WHERE\";\n    }\n\n    @Override\n    public String getGroupByStatement(Select select) {\n        return \"GROUP BY\";\n    }\n\n    @Override\n    public String getOrderByStatement(Select select) {\n        return \"ORDER BY\";\n    }\n\n    // Helper methods\n\n    protected Object invokeMethod(Object o, String methodName, Object[] params) {\n        Method methods[] = o.getClass().getMethods();\n        for (int i = 0; i < methods.length; ++i) {\n            if (methodName.equals(methods[i].getName())) {\n                try {\n                    methods[i].setAccessible(true);\n                    return methods[i].invoke(o, params);\n                }\n                catch (IllegalAccessException ex) {\n                    return null;\n                }\n                catch (InvocationTargetException ite) {\n                    return null;\n                }\n            }\n        }\n        return null;\n    }\n\n    public boolean areEquals(Column column1, Column column2) {\n        if (!column1.getName().equals(column2.getName())) {\n            return false;\n        }\n        if (!column1.getClass().getName().equals(column2.getClass().getName())) {\n            return false;\n        }\n        if (column1 instanceof DynamicDateColumn) {\n            DynamicDateColumn dd1 = (DynamicDateColumn) column1;\n            DynamicDateColumn dd2 = (DynamicDateColumn) column2;\n            if (!dd1.getDateType().equals(dd2.getDateType())) {\n                return false;\n            }\n        }\n        if (column1 instanceof FixedDateColumn) {\n            FixedDateColumn fd1 = (FixedDateColumn) column1;\n            FixedDateColumn fd2 = (FixedDateColumn) column2;\n            if (!fd1.getDateType().equals(fd2.getDateType())) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public boolean allowAliasInStatements() {\n        return false;\n    }\n\n    public Column getAliasStatement(Select select, Column target) {\n        for (Column column : select.getColumns()) {\n            if (!(column instanceof SimpleColumn) &&\n                    !StringUtils.isBlank(column.getAlias()) &&\n                    areEquals(column, target)) {\n\n                return column;\n            }\n        }\n        return null;\n    }\n}\n", "patch": "@@ -545,7 +545,9 @@ public String getDateParameterSQL(Date param) {\n \n     @Override\n     public String getStringParameterSQL(String param) {\n-        return \"'\" + param + \"'\";\n+        // DASHBUILDE-113: SQL Injection on data set lookup filters\n+        String escapedParam = param.replaceAll(\"'\", \"''\");\n+        return \"'\" + escapedParam + \"'\";\n     }\n \n     @Override", "file_path": "files/2016_8\\113", "file_language": "java", "file_name": "dashbuilder-backend/dashbuilder-dataset-sql/src/main/java/org/dashbuilder/dataprovider/sql/dialect/DefaultDialect.java", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}, {"raw_url": "https://github.com/dashbuilder/dashbuilder/raw/8574899e3b6455547b534f570b2330ff772e524b/dashbuilder-backend/dashbuilder-dataset-sql/src/test/java/org/dashbuilder/dataprovider/sql/SQLInjectionAttacksTest.java", "code": "/*\n * Copyright 2016 Red Hat, Inc. and/or its affiliates.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.dashbuilder.dataprovider.sql;\n\nimport org.dashbuilder.dataset.DataSet;\nimport org.dashbuilder.dataset.DataSetGroupTest;\nimport org.dashbuilder.dataset.DataSetLookupFactory;\nimport org.dashbuilder.dataset.filter.FilterFactory;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.mockito.Mock;\nimport org.mockito.runners.MockitoJUnitRunner;\nimport org.slf4j.Logger;\n\nimport static org.dashbuilder.dataset.ExpenseReportsData.*;\nimport static org.junit.Assert.*;\nimport static org.mockito.Mockito.*;\n\n@RunWith(MockitoJUnitRunner.class)\npublic class SQLInjectionAttacksTest extends SQLDataSetTestBase {\n\n    @Mock\n    Logger logger;\n\n    @Before\n    public void setUp() throws Exception{\n        super.setUp();\n\n        sqlDataSetProvider.log = logger;\n\n        doAnswer(invocationOnMock -> {\n                String sql = (String) invocationOnMock.getArguments()[0];\n                System.out.println(sql);\n                return null;\n        }).when(logger).debug(anyString());\n    }\n\n    @Override\n    public void testAll() throws Exception {\n        testStringFilterInjection();\n    }\n\n    public void testStringFilterInjection() throws Exception {\n        DataSet result = dataSetManager.lookupDataSet(\n                DataSetLookupFactory.newDataSetLookupBuilder()\n                        .dataset(DataSetGroupTest.EXPENSE_REPORTS)\n                        .filter(COLUMN_EMPLOYEE, FilterFactory.equalsTo(\"David' OR EMPLOYEE != 'Toni\"))\n                        .buildLookup());\n\n        assertEquals(result.getRowCount(), 0);\n\n        result = dataSetManager.lookupDataSet(\n                DataSetLookupFactory.newDataSetLookupBuilder()\n                        .dataset(DataSetGroupTest.EXPENSE_REPORTS)\n                        .filter(COLUMN_EMPLOYEE, FilterFactory.equalsTo(\"David\\\" OR EMPLOYEE != \\\"Toni\"))\n                        .buildLookup());\n\n        assertEquals(result.getRowCount(), 0);\n\n        result = dataSetManager.lookupDataSet(\n                DataSetLookupFactory.newDataSetLookupBuilder()\n                        .dataset(DataSetGroupTest.EXPENSE_REPORTS)\n                        .filter(COLUMN_EMPLOYEE, FilterFactory.equalsTo(\"David` OR EMPLOYEE != `Toni\"))\n                        .buildLookup());\n\n        assertEquals(result.getRowCount(), 0);\n\n    }\n\n    @Test\n    public void testDropTable() throws Exception {\n        DataSet result = dataSetManager.lookupDataSet(\n                DataSetLookupFactory.newDataSetLookupBuilder()\n                        .dataset(DataSetGroupTest.EXPENSE_REPORTS)\n                        .filter(COLUMN_EMPLOYEE, FilterFactory.equalsTo(\"David'; DROP TABLE 'EXPENSE_REPORTS; SELECT 'a' = 'a\"))\n                        .buildLookup());\n\n        result = dataSetManager.lookupDataSet(\n                DataSetLookupFactory.newDataSetLookupBuilder()\n                        .dataset(DataSetGroupTest.EXPENSE_REPORTS)\n                        .buildLookup());\n\n        assertEquals(result.getRowCount(), 50);\n    }\n}\n", "code_before": "/*\n * Copyright 2016 Red Hat, Inc. and/or its affiliates.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.dashbuilder.dataprovider.sql;\n\nimport org.dashbuilder.dataset.DataSet;\nimport org.dashbuilder.dataset.DataSetGroupTest;\nimport org.dashbuilder.dataset.DataSetLookupFactory;\nimport org.dashbuilder.dataset.filter.FilterFactory;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.mockito.Mock;\nimport org.mockito.runners.MockitoJUnitRunner;\nimport org.slf4j.Logger;\n\nimport static org.dashbuilder.dataset.ExpenseReportsData.*;\nimport static org.junit.Assert.*;\nimport static org.mockito.Mockito.*;\n\n@RunWith(MockitoJUnitRunner.class)\npublic class SQLInjectionAttacksTest extends SQLDataSetTestBase {\n\n    @Mock\n    Logger logger;\n\n    @Before\n    public void setUp() throws Exception{\n        super.setUp();\n\n        sqlDataSetProvider.log = logger;\n\n        doAnswer(invocationOnMock -> {\n                String sql = (String) invocationOnMock.getArguments()[0];\n                System.out.println(sql);\n                return null;\n        }).when(logger).debug(anyString());\n    }\n\n    @Override\n    public void testAll() throws Exception {\n        testStringFilterInjection();\n    }\n\n    public void testStringFilterInjection() throws Exception {\n        DataSet result = dataSetManager.lookupDataSet(\n                DataSetLookupFactory.newDataSetLookupBuilder()\n                        .dataset(DataSetGroupTest.EXPENSE_REPORTS)\n                        .filter(COLUMN_EMPLOYEE, FilterFactory.equalsTo(\"David' OR EMPLOYEE != 'Toni\"))\n                        .buildLookup());\n\n        assertEquals(result.getRowCount(), 0);\n\n        result = dataSetManager.lookupDataSet(\n                DataSetLookupFactory.newDataSetLookupBuilder()\n                        .dataset(DataSetGroupTest.EXPENSE_REPORTS)\n                        .filter(COLUMN_EMPLOYEE, FilterFactory.equalsTo(\"David\\\" OR EMPLOYEE != \\\"Toni\"))\n                        .buildLookup());\n\n        assertEquals(result.getRowCount(), 0);\n\n        result = dataSetManager.lookupDataSet(\n                DataSetLookupFactory.newDataSetLookupBuilder()\n                        .dataset(DataSetGroupTest.EXPENSE_REPORTS)\n                        .filter(COLUMN_EMPLOYEE, FilterFactory.equalsTo(\"David` OR EMPLOYEE != `Toni\"))\n                        .buildLookup());\n\n        assertEquals(result.getRowCount(), 0);\n\n    }\n\n    @Test\n    public void testDropTable() throws Exception {\n        DataSet result = dataSetManager.lookupDataSet(\n                DataSetLookupFactory.newDataSetLookupBuilder()\n                        .dataset(DataSetGroupTest.EXPENSE_REPORTS)\n                        .filter(COLUMN_EMPLOYEE, FilterFactory.equalsTo(\"David'; DROP TABLE 'EXPENSE_REPORTS; SELECT 'a' = 'a\"))\n                        .buildLookup());\n\n        result = dataSetManager.lookupDataSet(\n                DataSetLookupFactory.newDataSetLookupBuilder()\n                        .dataset(DataSetGroupTest.EXPENSE_REPORTS)\n                        .buildLookup());\n\n        assertEquals(result.getRowCount(), 50);\n    }\n}\n", "patch": "@@ -0,0 +1,99 @@\n+/*\n+ * Copyright 2016 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.dashbuilder.dataprovider.sql;\n+\n+import org.dashbuilder.dataset.DataSet;\n+import org.dashbuilder.dataset.DataSetGroupTest;\n+import org.dashbuilder.dataset.DataSetLookupFactory;\n+import org.dashbuilder.dataset.filter.FilterFactory;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mock;\n+import org.mockito.runners.MockitoJUnitRunner;\n+import org.slf4j.Logger;\n+\n+import static org.dashbuilder.dataset.ExpenseReportsData.*;\n+import static org.junit.Assert.*;\n+import static org.mockito.Mockito.*;\n+\n+@RunWith(MockitoJUnitRunner.class)\n+public class SQLInjectionAttacksTest extends SQLDataSetTestBase {\n+\n+    @Mock\n+    Logger logger;\n+\n+    @Before\n+    public void setUp() throws Exception{\n+        super.setUp();\n+\n+        sqlDataSetProvider.log = logger;\n+\n+        doAnswer(invocationOnMock -> {\n+                String sql = (String) invocationOnMock.getArguments()[0];\n+                System.out.println(sql);\n+                return null;\n+        }).when(logger).debug(anyString());\n+    }\n+\n+    @Override\n+    public void testAll() throws Exception {\n+        testStringFilterInjection();\n+    }\n+\n+    public void testStringFilterInjection() throws Exception {\n+        DataSet result = dataSetManager.lookupDataSet(\n+                DataSetLookupFactory.newDataSetLookupBuilder()\n+                        .dataset(DataSetGroupTest.EXPENSE_REPORTS)\n+                        .filter(COLUMN_EMPLOYEE, FilterFactory.equalsTo(\"David' OR EMPLOYEE != 'Toni\"))\n+                        .buildLookup());\n+\n+        assertEquals(result.getRowCount(), 0);\n+\n+        result = dataSetManager.lookupDataSet(\n+                DataSetLookupFactory.newDataSetLookupBuilder()\n+                        .dataset(DataSetGroupTest.EXPENSE_REPORTS)\n+                        .filter(COLUMN_EMPLOYEE, FilterFactory.equalsTo(\"David\\\" OR EMPLOYEE != \\\"Toni\"))\n+                        .buildLookup());\n+\n+        assertEquals(result.getRowCount(), 0);\n+\n+        result = dataSetManager.lookupDataSet(\n+                DataSetLookupFactory.newDataSetLookupBuilder()\n+                        .dataset(DataSetGroupTest.EXPENSE_REPORTS)\n+                        .filter(COLUMN_EMPLOYEE, FilterFactory.equalsTo(\"David` OR EMPLOYEE != `Toni\"))\n+                        .buildLookup());\n+\n+        assertEquals(result.getRowCount(), 0);\n+\n+    }\n+\n+    @Test\n+    public void testDropTable() throws Exception {\n+        DataSet result = dataSetManager.lookupDataSet(\n+                DataSetLookupFactory.newDataSetLookupBuilder()\n+                        .dataset(DataSetGroupTest.EXPENSE_REPORTS)\n+                        .filter(COLUMN_EMPLOYEE, FilterFactory.equalsTo(\"David'; DROP TABLE 'EXPENSE_REPORTS; SELECT 'a' = 'a\"))\n+                        .buildLookup());\n+\n+        result = dataSetManager.lookupDataSet(\n+                DataSetLookupFactory.newDataSetLookupBuilder()\n+                        .dataset(DataSetGroupTest.EXPENSE_REPORTS)\n+                        .buildLookup());\n+\n+        assertEquals(result.getRowCount(), 50);\n+    }\n+}", "file_path": "files/2016_8\\114", "file_language": "java", "file_name": "dashbuilder-backend/dashbuilder-dataset-sql/src/test/java/org/dashbuilder/dataprovider/sql/SQLInjectionAttacksTest.java", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}, {"raw_url": "https://github.com/dashbuilder/dashbuilder/raw/8574899e3b6455547b534f570b2330ff772e524b/dashbuilder-backend/dashbuilder-dataset-sql/src/test/java/org/dashbuilder/dataprovider/sql/SQLTestSuite.java", "code": "/*\n * Copyright 2015 Red Hat, Inc. and/or its affiliates.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.dashbuilder.dataprovider.sql;\n\nimport java.util.List;\nimport java.util.ArrayList;\n\nimport org.junit.Before;\n\npublic class SQLTestSuite extends SQLDataSetTestBase {\n\n    protected <T extends SQLDataSetTestBase> T setUp(T test) throws Exception {\n        test.testSettings = testSettings;\n        test.conn = conn;\n        return test;\n    }\n\n    protected List<SQLDataSetTestBase> sqlTestList = new ArrayList<SQLDataSetTestBase>();\n\n    @Before\n    public void setUp() throws Exception {\n        super.setUp();\n        sqlTestList.add(setUp(new SQLDataSetDefTest()));\n        sqlTestList.add(setUp(new SQLDataSetTrimTest()));\n        sqlTestList.add(setUp(new SQLTableDataSetLookupTest()));\n        sqlTestList.add(setUp(new SQLQueryDataSetLookupTest()));\n        sqlTestList.add(setUp(new SQLInjectionAttacksTest()));\n    }\n\n    public void testAll() throws Exception {\n        for (SQLDataSetTestBase testBase : sqlTestList) {\n            testBase.testAll();\n        }\n    }\n}\n", "code_before": "/*\n * Copyright 2015 Red Hat, Inc. and/or its affiliates.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.dashbuilder.dataprovider.sql;\n\nimport java.util.List;\nimport java.util.ArrayList;\n\nimport org.junit.Before;\n\npublic class SQLTestSuite extends SQLDataSetTestBase {\n\n    protected <T extends SQLDataSetTestBase> T setUp(T test) throws Exception {\n        test.testSettings = testSettings;\n        test.conn = conn;\n        return test;\n    }\n\n    protected List<SQLDataSetTestBase> sqlTestList = new ArrayList<SQLDataSetTestBase>();\n\n    @Before\n    public void setUp() throws Exception {\n        super.setUp();\n        sqlTestList.add(setUp(new SQLDataSetDefTest()));\n        sqlTestList.add(setUp(new SQLDataSetTrimTest()));\n        sqlTestList.add(setUp(new SQLTableDataSetLookupTest()));\n        sqlTestList.add(setUp(new SQLQueryDataSetLookupTest()));\n        sqlTestList.add(setUp(new SQLInjectionAttacksTest()));\n    }\n\n    public void testAll() throws Exception {\n        for (SQLDataSetTestBase testBase : sqlTestList) {\n            testBase.testAll();\n        }\n    }\n}\n", "patch": "@@ -37,6 +37,7 @@ public void setUp() throws Exception {\n         sqlTestList.add(setUp(new SQLDataSetTrimTest()));\n         sqlTestList.add(setUp(new SQLTableDataSetLookupTest()));\n         sqlTestList.add(setUp(new SQLQueryDataSetLookupTest()));\n+        sqlTestList.add(setUp(new SQLInjectionAttacksTest()));\n     }\n \n     public void testAll() throws Exception {", "file_path": "files/2016_8\\115", "file_language": "java", "file_name": "dashbuilder-backend/dashbuilder-dataset-sql/src/test/java/org/dashbuilder/dataprovider/sql/SQLTestSuite.java", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}], "outdated": 0}
