{"index": 24, "cve_id": "CVE-2016-5767", "cwe_id": ["CWE-190"], "cve_language": "C", "cve_description": "Integer overflow in the gdImageCreate function in gd.c in the GD Graphics Library (aka libgd) before 2.0.34RC1, as used in PHP before 5.5.37, 5.6.x before 5.6.23, and 7.x before 7.0.8, allows remote attackers to cause a denial of service (heap-based buffer overflow and application crash) or possibly have unspecified other impact via a crafted image dimensions.", "cvss": "8.8", "publish_date": "August 7, 2016", "AV": "NETWORK", "AC": "LOW", "PR": "NONE", "UI": "REQUIRED", "S": "UNCHANGED", "C": "HIGH", "I": "HIGH", "A": "HIGH", "commit_id": "7a1aac3343af85b4af4df5f8844946eaa27394ab", "commit_message": "Fixed bug #72227: imagescale out-of-bounds read\n\nPorted from https://github.com/libgd/libgd/commit/4f65a3e4eedaffa1efcf9ee1eb08f0b504fbc31a", "commit_date": "2016-05-23T07:34:35Z", "project": "php/php-src", "url": "https://api.github.com/repos/php/php-src/commits/7a1aac3343af85b4af4df5f8844946eaa27394ab", "html_url": "https://github.com/php/php-src/commit/7a1aac3343af85b4af4df5f8844946eaa27394ab", "windows_before": "", "windows_after": "", "parents": [{"commit_id_before": "97eff7eb57fc2320c267a949cffd622c38712484", "url_before": "https://api.github.com/repos/php/php-src/commits/97eff7eb57fc2320c267a949cffd622c38712484", "html_url_before": "https://github.com/php/php-src/commit/97eff7eb57fc2320c267a949cffd622c38712484"}], "details": [{"raw_url": "https://github.com/php/php-src/raw/7a1aac3343af85b4af4df5f8844946eaa27394ab/ext/gd/libgd/gd_interpolation.c", "code": "/*\n * Filtered Image Rescaling\n * Based on Gems III\n *  - Schumacher general filtered image rescaling\n * (pp. 414-424)\n * by Dale Schumacher\n *\n * \tAdditional changes by Ray Gardener, Daylon Graphics Ltd.\n * \tDecember 4, 1999\n *\n * \tPorted to libgd by Pierre Joye. Support for multiple channels\n * \tadded (argb for now).\n *\n * \tInitial sources code is avaibable in the Gems Source Code Packages:\n * \thttp://www.acm.org/pubs/tog/GraphicsGems/GGemsIII.tar.gz\n */\n\n/*\n\tSummary:\n\n\t\t- Horizontal filter contributions are calculated on the fly,\n\t\t  as each column is mapped from src to dst image. This lets\n\t\t  us omit having to allocate a temporary full horizontal stretch\n\t\t  of the src image.\n\n\t\t- If none of the src pixels within a sampling region differ,\n\t\t  then the output pixel is forced to equal (any of) the source pixel.\n\t\t  This ensures that filters do not corrupt areas of constant color.\n\n\t\t- Filter weight contribution results, after summing, are\n\t\t  rounded to the nearest pixel color value instead of\n\t\t  being casted to ILubyte (usually an int or char). Otherwise,\n\t\t  artifacting occurs.\n\n*/\n\n/*\n\tAdditional functions are available for simple rotation or up/downscaling.\n\tdownscaling using the fixed point implementations are usually much faster\n\tthan the existing gdImageCopyResampled while having a similar or better\n\tquality.\n\n\tFor image rotations, the optimized versions have a lazy antialiasing for\n\tthe edges of the images. For a much better antialiased result, the affine\n\tfunction is recommended.\n*/\n\n/*\nTODO:\n - Optimize pixel accesses and loops once we have continuous buffer\n - Add scale support for a portion only of an image (equivalent of copyresized/resampled)\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n\n#include <gd.h>\n#include \"gdhelpers.h\"\n\n#ifdef _MSC_VER\n# pragma optimize(\"t\", on)\n# include <emmintrin.h>\n#endif\n\n#ifndef MIN\n#define MIN(a,b) ((a)<(b)?(a):(b))\n#endif\n#define MIN3(a,b,c) ((a)<(b)?(MIN(a,c)):(MIN(b,c)))\n#ifndef MAX\n#define MAX(a,b) ((a)<(b)?(b):(a))\n#endif\n#define MAX3(a,b,c) ((a)<(b)?(MAX(b,c)):(MAX(a,c)))\n\n#define CLAMP(x, low, high)  (((x) > (high)) ? (high) : (((x) < (low)) ? (low) : (x)))\n\n/* only used here, let do a generic fixed point integers later if required by other\n   part of GD */\ntypedef long gdFixed;\n/* Integer to fixed point */\n#define gd_itofx(x) ((x) << 8)\n\n/* Float to fixed point */\n#define gd_ftofx(x) (long)((x) * 256)\n\n/*  Double to fixed point */\n#define gd_dtofx(x) (long)((x) * 256)\n\n/* Fixed point to integer */\n#define gd_fxtoi(x) ((x) >> 8)\n\n/* Fixed point to float */\n# define gd_fxtof(x) ((float)(x) / 256)\n\n/* Fixed point to double */\n#define gd_fxtod(x) ((double)(x) / 256)\n\n/* Multiply a fixed by a fixed */\n#define gd_mulfx(x,y) (((x) * (y)) >> 8)\n\n/* Divide a fixed by a fixed */\n#define gd_divfx(x,y) (((x) << 8) / (y))\n\ntypedef struct\n{\n   double *Weights;  /* Normalized weights of neighboring pixels */\n   int Left,Right;   /* Bounds of source pixels window */\n} ContributionType;  /* Contirbution information for a single pixel */\n\ntypedef struct\n{\n   ContributionType *ContribRow; /* Row (or column) of contribution weights */\n   unsigned int WindowSize,      /* Filter window size (of affecting source pixels) */\n\t\t\t\tLineLength;      /* Length of line (no. or rows / cols) */\n} LineContribType;\n\n/* Each core filter has its own radius */\n#define DEFAULT_FILTER_BICUBIC\t\t\t\t3.0\n#define DEFAULT_FILTER_BOX\t\t\t\t\t0.5\n#define DEFAULT_FILTER_GENERALIZED_CUBIC\t0.5\n#define DEFAULT_FILTER_RADIUS\t\t\t\t1.0\n#define DEFAULT_LANCZOS8_RADIUS\t\t\t\t8.0\n#define DEFAULT_LANCZOS3_RADIUS\t\t\t\t3.0\n#define DEFAULT_HERMITE_RADIUS\t\t\t\t1.0\n#define DEFAULT_BOX_RADIUS\t\t\t\t\t0.5\n#define DEFAULT_TRIANGLE_RADIUS\t\t\t\t1.0\n#define DEFAULT_BELL_RADIUS\t\t\t\t\t1.5\n#define DEFAULT_CUBICSPLINE_RADIUS\t\t\t2.0\n#define DEFAULT_MITCHELL_RADIUS\t\t\t\t2.0\n#define DEFAULT_COSINE_RADIUS\t\t\t\t1.0\n#define DEFAULT_CATMULLROM_RADIUS\t\t\t2.0\n#define DEFAULT_QUADRATIC_RADIUS\t\t\t1.5\n#define DEFAULT_QUADRATICBSPLINE_RADIUS\t\t1.5\n#define DEFAULT_CUBICCONVOLUTION_RADIUS\t\t3.0\n#define DEFAULT_GAUSSIAN_RADIUS\t\t\t\t1.0\n#define DEFAULT_HANNING_RADIUS\t\t\t\t1.0\n#define DEFAULT_HAMMING_RADIUS\t\t\t\t1.0\n#define DEFAULT_SINC_RADIUS\t\t\t\t\t1.0\n#define DEFAULT_WELSH_RADIUS\t\t\t\t1.0\n\nenum GD_RESIZE_FILTER_TYPE{\n\tFILTER_DEFAULT          = 0,\n\tFILTER_BELL,\n\tFILTER_BESSEL,\n\tFILTER_BLACKMAN,\n\tFILTER_BOX,\n\tFILTER_BSPLINE,\n\tFILTER_CATMULLROM,\n\tFILTER_COSINE,\n\tFILTER_CUBICCONVOLUTION,\n\tFILTER_CUBICSPLINE,\n\tFILTER_HERMITE,\n\tFILTER_LANCZOS3,\n\tFILTER_LANCZOS8,\n\tFILTER_MITCHELL,\n\tFILTER_QUADRATIC,\n\tFILTER_QUADRATICBSPLINE,\n\tFILTER_TRIANGLE,\n\tFILTER_GAUSSIAN,\n\tFILTER_HANNING,\n\tFILTER_HAMMING,\n\tFILTER_SINC,\n\tFILTER_WELSH,\n\n\tFILTER_CALLBACK        = 999\n};\n\ntypedef enum GD_RESIZE_FILTER_TYPE gdResizeFilterType;\n\nstatic double KernelBessel_J1(const double x)\n{\n\tdouble p, q;\n\n\tregister long i;\n\n\tstatic const double\n\tPone[] =\n\t{\n\t\t0.581199354001606143928050809e+21,\n\t\t-0.6672106568924916298020941484e+20,\n\t\t0.2316433580634002297931815435e+19,\n\t\t-0.3588817569910106050743641413e+17,\n\t\t0.2908795263834775409737601689e+15,\n\t\t-0.1322983480332126453125473247e+13,\n\t\t0.3413234182301700539091292655e+10,\n\t\t-0.4695753530642995859767162166e+7,\n\t\t0.270112271089232341485679099e+4\n\t},\n\tQone[] =\n\t{\n\t\t0.11623987080032122878585294e+22,\n\t\t0.1185770712190320999837113348e+20,\n\t\t0.6092061398917521746105196863e+17,\n\t\t0.2081661221307607351240184229e+15,\n\t\t0.5243710262167649715406728642e+12,\n\t\t0.1013863514358673989967045588e+10,\n\t\t0.1501793594998585505921097578e+7,\n\t\t0.1606931573481487801970916749e+4,\n\t\t0.1e+1\n\t};\n\n\tp = Pone[8];\n\tq = Qone[8];\n\tfor (i=7; i >= 0; i--)\n\t{\n\t\tp = p*x*x+Pone[i];\n\t\tq = q*x*x+Qone[i];\n\t}\n\treturn (double)(p/q);\n}\n\nstatic double KernelBessel_P1(const double x)\n{\n\tdouble p, q;\n\n\tregister long i;\n\n\tstatic const double\n\tPone[] =\n\t{\n\t\t0.352246649133679798341724373e+5,\n\t\t0.62758845247161281269005675e+5,\n\t\t0.313539631109159574238669888e+5,\n\t\t0.49854832060594338434500455e+4,\n\t\t0.2111529182853962382105718e+3,\n\t\t0.12571716929145341558495e+1\n\t},\n\tQone[] =\n\t{\n\t\t0.352246649133679798068390431e+5,\n\t\t0.626943469593560511888833731e+5,\n\t\t0.312404063819041039923015703e+5,\n\t\t0.4930396490181088979386097e+4,\n\t\t0.2030775189134759322293574e+3,\n\t\t0.1e+1\n\t};\n\n\tp = Pone[5];\n\tq = Qone[5];\n\tfor (i=4; i >= 0; i--)\n\t{\n\t\tp = p*(8.0/x)*(8.0/x)+Pone[i];\n\t\tq = q*(8.0/x)*(8.0/x)+Qone[i];\n\t}\n\treturn (double)(p/q);\n}\n\nstatic double KernelBessel_Q1(const double x)\n{\n\tdouble p, q;\n\n\tregister long i;\n\n\tstatic const double\n\tPone[] =\n\t{\n\t\t0.3511751914303552822533318e+3,\n\t\t0.7210391804904475039280863e+3,\n\t\t0.4259873011654442389886993e+3,\n\t\t0.831898957673850827325226e+2,\n\t\t0.45681716295512267064405e+1,\n\t\t0.3532840052740123642735e-1\n\t},\n\tQone[] =\n\t{\n\t\t0.74917374171809127714519505e+4,\n\t\t0.154141773392650970499848051e+5,\n\t\t0.91522317015169922705904727e+4,\n\t\t0.18111867005523513506724158e+4,\n\t\t0.1038187585462133728776636e+3,\n\t\t0.1e+1\n\t};\n\n\tp = Pone[5];\n\tq = Qone[5];\n\tfor (i=4; i >= 0; i--)\n\t{\n\t\tp = p*(8.0/x)*(8.0/x)+Pone[i];\n\t\tq = q*(8.0/x)*(8.0/x)+Qone[i];\n\t}\n\treturn (double)(p/q);\n}\n\nstatic double KernelBessel_Order1(double x)\n{\n\tdouble p, q;\n\n\tif (x == 0.0)\n\t\treturn (0.0f);\n\tp = x;\n\tif (x < 0.0)\n\t\tx=(-x);\n\tif (x < 8.0)\n\t\treturn (p*KernelBessel_J1(x));\n\tq = (double)sqrt(2.0f/(M_PI*x))*(double)(KernelBessel_P1(x)*(1.0f/sqrt(2.0f)*(sin(x)-cos(x)))-8.0f/x*KernelBessel_Q1(x)*\n\t\t(-1.0f/sqrt(2.0f)*(sin(x)+cos(x))));\n\tif (p < 0.0f)\n\t\tq = (-q);\n\treturn (q);\n}\n\nstatic double filter_bessel(const double x)\n{\n\tif (x == 0.0f)\n\t\treturn (double)(M_PI/4.0f);\n\treturn (KernelBessel_Order1((double)M_PI*x)/(2.0f*x));\n}\n\n\nstatic double filter_blackman(const double x)\n{\n\treturn (0.42f+0.5f*(double)cos(M_PI*x)+0.08f*(double)cos(2.0f*M_PI*x));\n}\n\n/**\n * Bicubic interpolation kernel (a=-1):\n  \\verbatim\n          /\n         | 1-2|t|**2+|t|**3          , if |t| < 1\n  h(t) = | 4-8|t|+5|t|**2-|t|**3     , if 1<=|t|<2\n         | 0                         , otherwise\n          \\\n  \\endverbatim\n * ***bd*** 2.2004\n */\nstatic double filter_bicubic(const double t)\n{\n  const double abs_t = (double)fabs(t);\n  const double abs_t_sq = abs_t * abs_t;\n  if (abs_t<1) return 1-2*abs_t_sq+abs_t_sq*abs_t;\n  if (abs_t<2) return 4 - 8*abs_t +5*abs_t_sq - abs_t_sq*abs_t;\n  return 0;\n}\n\n/**\n * Generalized cubic kernel (for a=-1 it is the same as BicubicKernel):\n  \\verbatim\n          /\n         | (a+2)|t|**3 - (a+3)|t|**2 + 1     , |t| <= 1\n  h(t) = | a|t|**3 - 5a|t|**2 + 8a|t| - 4a   , 1 < |t| <= 2\n         | 0                                 , otherwise\n          \\\n  \\endverbatim\n * Often used values for a are -1 and -1/2.\n */\nstatic double filter_generalized_cubic(const double t)\n{\n\tconst double a = -DEFAULT_FILTER_GENERALIZED_CUBIC;\n\tdouble abs_t = (double)fabs(t);\n\tdouble abs_t_sq = abs_t * abs_t;\n\tif (abs_t < 1) return (a + 2) * abs_t_sq * abs_t - (a + 3) * abs_t_sq + 1;\n\tif (abs_t < 2) return a * abs_t_sq * abs_t - 5 * a * abs_t_sq + 8 * a * abs_t - 4 * a;\n\treturn 0;\n}\n\n/* CubicSpline filter, default radius 2 */\nstatic double filter_cubic_spline(const double x1)\n{\n\tconst double x = x1 < 0.0 ? -x1 : x1;\n\n\tif (x < 1.0 ) {\n\t\tconst double x2 = x*x;\n\n\t\treturn (0.5 * x2 * x - x2 + 2.0 / 3.0);\n\t}\n\tif (x < 2.0) {\n\t\treturn (pow(2.0 - x, 3.0)/6.0);\n\t}\n\treturn 0;\n}\n\n/* CubicConvolution filter, default radius 3 */\nstatic double filter_cubic_convolution(const double x1)\n{\n\tconst double x = x1 < 0.0 ? -x1 : x1;\n\tconst double x2 = x1 * x1;\n\tconst double x2_x = x2 * x;\n\n\tif (x <= 1.0) return ((4.0 / 3.0)* x2_x - (7.0 / 3.0) * x2 + 1.0);\n\tif (x <= 2.0) return (- (7.0 / 12.0) * x2_x + 3 * x2 - (59.0 / 12.0) * x + 2.5);\n\tif (x <= 3.0) return ( (1.0/12.0) * x2_x - (2.0 / 3.0) * x2 + 1.75 * x - 1.5);\n\treturn 0;\n}\n\nstatic double filter_box(double x) {\n\tif (x < - DEFAULT_FILTER_BOX)\n\t\treturn 0.0f;\n\tif (x < DEFAULT_FILTER_BOX)\n\t\treturn 1.0f;\n\treturn 0.0f;\n}\n\nstatic double filter_catmullrom(const double x)\n{\n\tif (x < -2.0)\n\t\treturn(0.0f);\n\tif (x < -1.0)\n\t\treturn(0.5f*(4.0f+x*(8.0f+x*(5.0f+x))));\n\tif (x < 0.0)\n\t\treturn(0.5f*(2.0f+x*x*(-5.0f-3.0f*x)));\n\tif (x < 1.0)\n\t\treturn(0.5f*(2.0f+x*x*(-5.0f+3.0f*x)));\n\tif (x < 2.0)\n\t\treturn(0.5f*(4.0f+x*(-8.0f+x*(5.0f-x))));\n\treturn(0.0f);\n}\n\nstatic double filter_filter(double t)\n{\n\t/* f(t) = 2|t|^3 - 3|t|^2 + 1, -1 <= t <= 1 */\n\tif(t < 0.0) t = -t;\n\tif(t < 1.0) return((2.0 * t - 3.0) * t * t + 1.0);\n\treturn(0.0);\n}\n\n\n/* Lanczos8 filter, default radius 8 */\nstatic double filter_lanczos8(const double x1)\n{\n\tconst double x = x1 < 0.0 ? -x1 : x1;\n#define R DEFAULT_LANCZOS8_RADIUS\n\n\tif ( x == 0.0) return 1;\n\n\tif ( x < R) {\n\t\treturn R * sin(x*M_PI) * sin(x * M_PI/ R) / (x * M_PI * x * M_PI);\n\t}\n\treturn 0.0;\n#undef R\n}\n\n\n/* Lanczos3 filter, default radius 3 */\nstatic double filter_lanczos3(const double x1)\n{\n\tconst double x = x1 < 0.0 ? -x1 : x1;\n#define R DEFAULT_LANCZOS3_RADIUS\n\n\tif ( x == 0.0) return 1;\n\n\tif ( x < R)\n\t{\n\t\treturn R * sin(x*M_PI) * sin(x * M_PI / R) / (x * M_PI * x * M_PI);\n\t}\n\treturn 0.0;\n#undef R\n}\n\n/* Hermite filter, default radius 1 */\nstatic double filter_hermite(const double x1)\n{\n\tconst double x = x1 < 0.0 ? -x1 : x1;\n\n\tif (x < 1.0) return ((2.0 * x - 3) * x * x + 1.0 );\n\n\treturn 0.0;\n}\n\n/* Trangle filter, default radius 1 */\nstatic double filter_triangle(const double x1)\n{\n\tconst double x = x1 < 0.0 ? -x1 : x1;\n\tif (x < 1.0) return (1.0 - x);\n\treturn 0.0;\n}\n\n/* Bell filter, default radius 1.5 */\nstatic double filter_bell(const double x1)\n{\n\tconst double x = x1 < 0.0 ? -x1 : x1;\n\n\tif (x < 0.5) return (0.75 - x*x);\n\tif (x < 1.5) return (0.5 * pow(x - 1.5, 2.0));\n\treturn 0.0;\n}\n\n/* Mitchell filter, default radius 2.0 */\nstatic double filter_mitchell(const double x)\n{\n#define KM_B (1.0f/3.0f)\n#define KM_C (1.0f/3.0f)\n#define KM_P0 ((  6.0f - 2.0f * KM_B ) / 6.0f)\n#define KM_P2 ((-18.0f + 12.0f * KM_B + 6.0f * KM_C) / 6.0f)\n#define KM_P3 (( 12.0f - 9.0f  * KM_B - 6.0f * KM_C) / 6.0f)\n#define KM_Q0 ((  8.0f * KM_B + 24.0f * KM_C) / 6.0f)\n#define KM_Q1 ((-12.0f * KM_B - 48.0f * KM_C) / 6.0f)\n#define KM_Q2 ((  6.0f * KM_B + 30.0f * KM_C) / 6.0f)\n#define KM_Q3 (( -1.0f * KM_B -  6.0f * KM_C) / 6.0f)\n\n\tif (x < -2.0)\n\t\treturn(0.0f);\n\tif (x < -1.0)\n\t\treturn(KM_Q0-x*(KM_Q1-x*(KM_Q2-x*KM_Q3)));\n\tif (x < 0.0f)\n\t\treturn(KM_P0+x*x*(KM_P2-x*KM_P3));\n\tif (x < 1.0f)\n\t\treturn(KM_P0+x*x*(KM_P2+x*KM_P3));\n\tif (x < 2.0f)\n\t\treturn(KM_Q0+x*(KM_Q1+x*(KM_Q2+x*KM_Q3)));\n\treturn(0.0f);\n}\n\n\n\n/* Cosine filter, default radius 1 */\nstatic double filter_cosine(const double x)\n{\n\tif ((x >= -1.0) && (x <= 1.0)) return ((cos(x * M_PI) + 1.0)/2.0);\n\n\treturn 0;\n}\n\n/* Quadratic filter, default radius 1.5 */\nstatic double filter_quadratic(const double x1)\n{\n\tconst double x = x1 < 0.0 ? -x1 : x1;\n\n\tif (x <= 0.5) return (- 2.0 * x * x + 1);\n\tif (x <= 1.5) return (x * x - 2.5* x + 1.5);\n\treturn 0.0;\n}\n\nstatic double filter_bspline(const double x)\n{\n\tif (x>2.0f) {\n\t\treturn 0.0f;\n\t} else {\n\t\tdouble a, b, c, d;\n\t\t/* Was calculated anyway cause the \"if((x-1.0f) < 0)\" */\n\t\tconst double xm1 = x - 1.0f;\n\t\tconst double xp1 = x + 1.0f;\n\t\tconst double xp2 = x + 2.0f;\n\n\t\tif ((xp2) <= 0.0f) a = 0.0f; else a = xp2*xp2*xp2;\n\t\tif ((xp1) <= 0.0f) b = 0.0f; else b = xp1*xp1*xp1;\n\t\tif (x <= 0) c = 0.0f; else c = x*x*x;\n\t\tif ((xm1) <= 0.0f) d = 0.0f; else d = xm1*xm1*xm1;\n\n\t\treturn (0.16666666666666666667f * (a - (4.0f * b) + (6.0f * c) - (4.0f * d)));\n\t}\n}\n\n/* QuadraticBSpline filter, default radius 1.5 */\nstatic double filter_quadratic_bspline(const double x1)\n{\n\tconst double x = x1 < 0.0 ? -x1 : x1;\n\n\tif (x <= 0.5) return (- x * x + 0.75);\n\tif (x <= 1.5) return (0.5 * x * x - 1.5 * x + 1.125);\n\treturn 0.0;\n}\n\nstatic double filter_gaussian(const double x)\n{\n\t/* return(exp((double) (-2.0 * x * x)) * sqrt(2.0 / M_PI)); */\n\treturn (double)(exp(-2.0f * x * x) * 0.79788456080287f);\n}\n\nstatic double filter_hanning(const double x)\n{\n\t/* A Cosine windowing function */\n\treturn(0.5 + 0.5 * cos(M_PI * x));\n}\n\nstatic double filter_hamming(const double x)\n{\n\t/* should be\n\t(0.54+0.46*cos(M_PI*(double) x));\n\tbut this approximation is sufficient */\n\tif (x < -1.0f)\n\t\treturn 0.0f;\n\tif (x < 0.0f)\n\t\treturn 0.92f*(-2.0f*x-3.0f)*x*x+1.0f;\n\tif (x < 1.0f)\n\t\treturn 0.92f*(2.0f*x-3.0f)*x*x+1.0f;\n\treturn 0.0f;\n}\n\nstatic double filter_power(const double x)\n{\n\tconst double a = 2.0f;\n\tif (fabs(x)>1) return 0.0f;\n\treturn (1.0f - (double)fabs(pow(x,a)));\n}\n\nstatic double filter_sinc(const double x)\n{\n\t/* X-scaled Sinc(x) function. */\n\tif (x == 0.0) return(1.0);\n\treturn (sin(M_PI * (double) x) / (M_PI * (double) x));\n}\n\nstatic double filter_welsh(const double x)\n{\n\t/* Welsh parabolic windowing filter */\n\tif (x <  1.0)\n\t\treturn(1 - x*x);\n\treturn(0.0);\n}\n\n\n/* Copied from upstream's libgd */\nstatic inline int _color_blend (const int dst, const int src)\n{\n    const int src_alpha = gdTrueColorGetAlpha(src);\n\n    if( src_alpha == gdAlphaOpaque ) {\n\t\treturn src;\n\t} else {\n\t\tconst int dst_alpha = gdTrueColorGetAlpha(dst);\n\n\t\tif( src_alpha == gdAlphaTransparent ) return dst;\n\t\tif( dst_alpha == gdAlphaTransparent ) {\n\t\t\treturn src;\n\t\t} else {\n\t\t\tregister int alpha, red, green, blue;\n\t\t\tconst int src_weight = gdAlphaTransparent - src_alpha;\n\t\t\tconst int dst_weight = (gdAlphaTransparent - dst_alpha) * src_alpha / gdAlphaMax;\n\t\t\tconst int tot_weight = src_weight + dst_weight;\n\n\t\t\talpha = src_alpha * dst_alpha / gdAlphaMax;\n\n\t\t\tred = (gdTrueColorGetRed(src) * src_weight\n\t\t\t\t   + gdTrueColorGetRed(dst) * dst_weight) / tot_weight;\n\t\t\tgreen = (gdTrueColorGetGreen(src) * src_weight\n\t\t\t\t   + gdTrueColorGetGreen(dst) * dst_weight) / tot_weight;\n\t\t\tblue = (gdTrueColorGetBlue(src) * src_weight\n\t\t\t\t   + gdTrueColorGetBlue(dst) * dst_weight) / tot_weight;\n\n\t\t\treturn ((alpha << 24) + (red << 16) + (green << 8) + blue);\n\t\t}\n\t}\n}\n\nstatic inline int _setEdgePixel(const gdImagePtr src, unsigned int x, unsigned int y, gdFixed coverage, const int bgColor)\n{\n\tconst gdFixed f_127 = gd_itofx(127);\n\tregister int c = src->tpixels[y][x];\n\tc = c | (( (int) (gd_fxtof(gd_mulfx(coverage, f_127)) + 50.5f)) << 24);\n\treturn _color_blend(bgColor, c);\n}\n\nstatic inline int getPixelOverflowTC(gdImagePtr im, const int x, const int y, const int bgColor)\n{\n\tif (gdImageBoundsSafe(im, x, y)) {\n\t\tconst int c = im->tpixels[y][x];\n\t\tif (c == im->transparent) {\n\t\t\treturn bgColor == -1 ? gdTrueColorAlpha(0, 0, 0, 127) : bgColor;\n\t\t}\n\t\treturn c;\n\t} else {\n\t\tregister int border = 0;\n\n\t\tif (y < im->cy1) {\n\t\t\tborder = im->tpixels[0][im->cx1];\n\t\t\tgoto processborder;\n\t\t}\n\n\t\tif (y < im->cy1) {\n\t\t\tborder = im->tpixels[0][im->cx1];\n\t\t\tgoto processborder;\n\t\t}\n\n\t\tif (y > im->cy2) {\n\t\t\tif (x >= im->cx1 && x <= im->cx1) {\n\t\t\t\tborder = im->tpixels[im->cy2][x];\n\t\t\t\tgoto processborder;\n\t\t\t} else {\n\t\t\t\treturn gdTrueColorAlpha(0, 0, 0, 127);\n\t\t\t}\n\t\t}\n\n\t\t/* y is bound safe at this point */\n\t\tif (x < im->cx1) {\n\t\t\tborder = im->tpixels[y][im->cx1];\n\t\t\tgoto processborder;\n\t\t}\n\n\t\tif (x > im->cx2) {\n\t\t\tborder = im->tpixels[y][im->cx2];\n\t\t}\n\nprocessborder:\n\t\tif (border == im->transparent) {\n\t\t\treturn gdTrueColorAlpha(0, 0, 0, 127);\n\t\t} else{\n\t\t\treturn gdTrueColorAlpha(gdTrueColorGetRed(border), gdTrueColorGetGreen(border), gdTrueColorGetBlue(border), 127);\n\t\t}\n\t}\n}\n\n#define colorIndex2RGBA(c) gdTrueColorAlpha(im->red[(c)], im->green[(c)], im->blue[(c)], im->alpha[(c)])\n#define colorIndex2RGBcustomA(c, a) gdTrueColorAlpha(im->red[(c)], im->green[(c)], im->blue[(c)], im->alpha[(a)])\nstatic inline int getPixelOverflowPalette(gdImagePtr im, const int x, const int y, const int bgColor)\n{\n\tif (gdImageBoundsSafe(im, x, y)) {\n\t\tconst int c = im->pixels[y][x];\n\t\tif (c == im->transparent) {\n\t\t\treturn bgColor == -1 ? gdTrueColorAlpha(0, 0, 0, 127) : bgColor;\n\t\t}\n\t\treturn colorIndex2RGBA(c);\n\t} else {\n\t\tregister int border = 0;\n\t\tif (y < im->cy1) {\n\t\t\tborder = gdImageGetPixel(im, im->cx1, 0);\n\t\t\tgoto processborder;\n\t\t}\n\n\t\tif (y < im->cy1) {\n\t\t\tborder = gdImageGetPixel(im, im->cx1, 0);\n\t\t\tgoto processborder;\n\t\t}\n\n\t\tif (y > im->cy2) {\n\t\t\tif (x >= im->cx1 && x <= im->cx1) {\n\t\t\t\tborder = gdImageGetPixel(im, x,  im->cy2);\n\t\t\t\tgoto processborder;\n\t\t\t} else {\n\t\t\t\treturn gdTrueColorAlpha(0, 0, 0, 127);\n\t\t\t}\n\t\t}\n\n\t\t/* y is bound safe at this point */\n\t\tif (x < im->cx1) {\n\t\t\tborder = gdImageGetPixel(im, im->cx1, y);\n\t\t\tgoto processborder;\n\t\t}\n\n\t\tif (x > im->cx2) {\n\t\t\tborder = gdImageGetPixel(im, im->cx2, y);\n\t\t}\n\nprocessborder:\n\t\tif (border == im->transparent) {\n\t\t\treturn gdTrueColorAlpha(0, 0, 0, 127);\n\t\t} else{\n\t\t\treturn colorIndex2RGBcustomA(border, 127);\n\t\t}\n\t}\n}\n\nstatic int getPixelInterpolateWeight(gdImagePtr im, const double x, const double y, const int bgColor)\n{\n\t/* Closest pixel <= (xf,yf) */\n\tint sx = (int)(x);\n\tint sy = (int)(y);\n\tconst double xf = x - (double)sx;\n\tconst double yf = y - (double)sy;\n\tconst double nxf = (double) 1.0 - xf;\n\tconst double nyf = (double) 1.0 - yf;\n\tconst double m1 = xf * yf;\n\tconst double m2 = nxf * yf;\n\tconst double m3 = xf * nyf;\n\tconst double m4 = nxf * nyf;\n\n\t/* get color values of neighbouring pixels */\n\tconst int c1 = im->trueColor == 1 ? getPixelOverflowTC(im, sx, sy, bgColor)         : getPixelOverflowPalette(im, sx, sy, bgColor);\n\tconst int c2 = im->trueColor == 1 ? getPixelOverflowTC(im, sx - 1, sy, bgColor)     : getPixelOverflowPalette(im, sx - 1, sy, bgColor);\n\tconst int c3 = im->trueColor == 1 ? getPixelOverflowTC(im, sx, sy - 1, bgColor)     : getPixelOverflowPalette(im, sx, sy - 1, bgColor);\n\tconst int c4 = im->trueColor == 1 ? getPixelOverflowTC(im, sx - 1, sy - 1, bgColor) : getPixelOverflowPalette(im, sx, sy - 1, bgColor);\n\tint r, g, b, a;\n\n\tif (x < 0) sx--;\n\tif (y < 0) sy--;\n\n\t/* component-wise summing-up of color values */\n\tif (im->trueColor) {\n\t\tr = (int)(m1*gdTrueColorGetRed(c1)   + m2*gdTrueColorGetRed(c2)   + m3*gdTrueColorGetRed(c3)   + m4*gdTrueColorGetRed(c4));\n\t\tg = (int)(m1*gdTrueColorGetGreen(c1) + m2*gdTrueColorGetGreen(c2) + m3*gdTrueColorGetGreen(c3) + m4*gdTrueColorGetGreen(c4));\n\t\tb = (int)(m1*gdTrueColorGetBlue(c1)  + m2*gdTrueColorGetBlue(c2)  + m3*gdTrueColorGetBlue(c3)  + m4*gdTrueColorGetBlue(c4));\n\t\ta = (int)(m1*gdTrueColorGetAlpha(c1) + m2*gdTrueColorGetAlpha(c2) + m3*gdTrueColorGetAlpha(c3) + m4*gdTrueColorGetAlpha(c4));\n\t} else {\n\t\tr = (int)(m1*im->red[(c1)]   + m2*im->red[(c2)]   + m3*im->red[(c3)]   + m4*im->red[(c4)]);\n\t\tg = (int)(m1*im->green[(c1)] + m2*im->green[(c2)] + m3*im->green[(c3)] + m4*im->green[(c4)]);\n\t\tb = (int)(m1*im->blue[(c1)]  + m2*im->blue[(c2)]  + m3*im->blue[(c3)]  + m4*im->blue[(c4)]);\n\t\ta = (int)(m1*im->alpha[(c1)] + m2*im->alpha[(c2)] + m3*im->alpha[(c3)] + m4*im->alpha[(c4)]);\n\t}\n\n\tr = CLAMP(r, 0, 255);\n\tg = CLAMP(g, 0, 255);\n\tb = CLAMP(b, 0, 255);\n\ta = CLAMP(a, 0, gdAlphaMax);\n\treturn gdTrueColorAlpha(r, g, b, a);\n}\n\n/**\n * Function: getPixelInterpolated\n *  Returns the interpolated color value using the default interpolation\n *  method. The returned color is always in the ARGB format (truecolor).\n *\n * Parameters:\n * \tim - Image to set the default interpolation method\n *  y - X value of the ideal position\n *  y - Y value of the ideal position\n *  method - Interpolation method <gdInterpolationMethod>\n *\n * Returns:\n *  GD_TRUE if the affine is rectilinear or GD_FALSE\n *\n * See also:\n *  <gdSetInterpolationMethod>\n */\nint getPixelInterpolated(gdImagePtr im, const double x, const double y, const int bgColor)\n{\n\tconst int xi=(int)((x) < 0 ? x - 1: x);\n\tconst int yi=(int)((y) < 0 ? y - 1: y);\n\tint yii;\n\tint i;\n\tdouble kernel, kernel_cache_y;\n\tdouble kernel_x[12], kernel_y[4];\n\tdouble new_r = 0.0f, new_g = 0.0f, new_b = 0.0f, new_a = 0.0f;\n\n\t/* These methods use special implementations */\n\tif (im->interpolation_id == GD_BILINEAR_FIXED || im->interpolation_id == GD_BICUBIC_FIXED || im->interpolation_id == GD_NEAREST_NEIGHBOUR) {\n\t\treturn -1;\n\t}\n\n\t/* Default to full alpha */\n\tif (bgColor == -1) {\n\t}\n\n\tif (im->interpolation_id == GD_WEIGHTED4) {\n\t\treturn getPixelInterpolateWeight(im, x, y, bgColor);\n\t}\n\n\tif (im->interpolation_id == GD_NEAREST_NEIGHBOUR) {\n\t\tif (im->trueColor == 1) {\n\t\t\treturn getPixelOverflowTC(im, xi, yi, bgColor);\n\t\t} else {\n\t\t\treturn getPixelOverflowPalette(im, xi, yi, bgColor);\n\t\t}\n\t}\n\tif (im->interpolation) {\n\t\tfor (i=0; i<4; i++) {\n\t\t\tkernel_x[i] = (double) im->interpolation((double)(xi+i-1-x));\n\t\t\tkernel_y[i] = (double) im->interpolation((double)(yi+i-1-y));\n\t\t}\n\t} else {\n\t\treturn -1;\n\t}\n\n\t/*\n\t * TODO: use the known fast rgba multiplication implementation once\n\t * the new formats are in place\n\t */\n\tfor (yii = yi-1; yii < yi+3; yii++) {\n\t\tint xii;\n\t\tkernel_cache_y = kernel_y[yii-(yi-1)];\n\t\tif (im->trueColor) {\n\t\t\tfor (xii=xi-1; xii<xi+3; xii++) {\n\t\t\t\tconst int rgbs = getPixelOverflowTC(im, xii, yii, bgColor);\n\n\t\t\t\tkernel = kernel_cache_y * kernel_x[xii-(xi-1)];\n\t\t\t\tnew_r += kernel * gdTrueColorGetRed(rgbs);\n\t\t\t\tnew_g += kernel * gdTrueColorGetGreen(rgbs);\n\t\t\t\tnew_b += kernel * gdTrueColorGetBlue(rgbs);\n\t\t\t\tnew_a += kernel * gdTrueColorGetAlpha(rgbs);\n\t\t\t}\n\t\t} else {\n\t\t\tfor (xii=xi-1; xii<xi+3; xii++) {\n\t\t\t\tconst int rgbs = getPixelOverflowPalette(im, xii, yii, bgColor);\n\n\t\t\t\tkernel = kernel_cache_y * kernel_x[xii-(xi-1)];\n\t\t\t\tnew_r += kernel * gdTrueColorGetRed(rgbs);\n\t\t\t\tnew_g += kernel * gdTrueColorGetGreen(rgbs);\n\t\t\t\tnew_b += kernel * gdTrueColorGetBlue(rgbs);\n\t\t\t\tnew_a += kernel * gdTrueColorGetAlpha(rgbs);\n\t\t\t}\n\t\t}\n\t}\n\n\tnew_r = CLAMP(new_r, 0, 255);\n\tnew_g = CLAMP(new_g, 0, 255);\n\tnew_b = CLAMP(new_b, 0, 255);\n\tnew_a = CLAMP(new_a, 0, gdAlphaMax);\n\n\treturn gdTrueColorAlpha(((int)new_r), ((int)new_g), ((int)new_b), ((int)new_a));\n}\n\nstatic inline LineContribType * _gdContributionsAlloc(unsigned int line_length, unsigned int windows_size)\n{\n\tunsigned int u = 0;\n    LineContribType *res;\n\n\tres = (LineContribType *) gdMalloc(sizeof(LineContribType));\n\tif (!res) {\n\t\treturn NULL;\n\t}\n    res->WindowSize = windows_size;\n    res->LineLength = line_length;\n    res->ContribRow = (ContributionType *) gdMalloc(line_length * sizeof(ContributionType));\n\n    for (u = 0 ; u < line_length ; u++) {\n        res->ContribRow[u].Weights = (double *) gdMalloc(windows_size * sizeof(double));\n    }\n    return res;\n}\n\nstatic inline void _gdContributionsFree(LineContribType * p)\n{\n\tunsigned int u;\n\tfor (u = 0; u < p->LineLength; u++)  {\n\t\tgdFree(p->ContribRow[u].Weights);\n\t}\n\tgdFree(p->ContribRow);\n\tgdFree(p);\n}\n\nstatic inline LineContribType *_gdContributionsCalc(unsigned int line_size, unsigned int src_size, double scale_d,  const interpolation_method pFilter)\n{\n    double width_d;\n    double scale_f_d = 1.0;\n    const double filter_width_d = DEFAULT_BOX_RADIUS;\n\tint windows_size;\n\tunsigned int u;\n\tLineContribType *res;\n\n    if (scale_d < 1.0) {\n        width_d = filter_width_d / scale_d;\n        scale_f_d = scale_d;\n    }  else {\n        width_d= filter_width_d;\n    }\n\n    windows_size = 2 * (int)ceil(width_d) + 1;\n    res = _gdContributionsAlloc(line_size, windows_size);\n\n    for (u = 0; u < line_size; u++) {\n        const double dCenter = (double)u / scale_d;\n        /* get the significant edge points affecting the pixel */\n        register int iLeft = MAX(0, (int)floor (dCenter - width_d));\n        int iRight = MIN((int)ceil(dCenter + width_d), (int)src_size - 1);\n        double dTotalWeight = 0.0;\n\t\tint iSrc;\n\n        /* Cut edge points to fit in filter window in case of spill-off */\n        if (iRight - iLeft + 1 > windows_size)  {\n            if (iLeft < ((int)src_size - 1 / 2))  {\n                iLeft++;\n            } else {\n                iRight--;\n            }\n        }\n\n        res->ContribRow[u].Left = iLeft;\n        res->ContribRow[u].Right = iRight;\n\n        for (iSrc = iLeft; iSrc <= iRight; iSrc++) {\n            dTotalWeight += (res->ContribRow[u].Weights[iSrc-iLeft] =  scale_f_d * (*pFilter)(scale_f_d * (dCenter - (double)iSrc)));\n        }\n\n\t\tif (dTotalWeight < 0.0) {\n\t\t\t_gdContributionsFree(res);\n\t\t\treturn NULL;\n\t\t}\n\n        if (dTotalWeight > 0.0) {\n            for (iSrc = iLeft; iSrc <= iRight; iSrc++) {\n                res->ContribRow[u].Weights[iSrc-iLeft] /= dTotalWeight;\n            }\n        }\n   }\n   return res;\n}\n\nstatic inline void _gdScaleRow(gdImagePtr pSrc,  unsigned int src_width, gdImagePtr dst, unsigned int dst_width, unsigned int row, LineContribType *contrib)\n{\n    int *p_src_row = pSrc->tpixels[row];\n    int *p_dst_row = dst->tpixels[row];\n\tunsigned int x;\n\n    for (x = 0; x < dst_width - 1; x++) {\n\t\tregister unsigned char r = 0, g = 0, b = 0, a = 0;\n        const int left = contrib->ContribRow[x].Left;\n        const int right = contrib->ContribRow[x].Right;\n\t\tint i;\n\n\t\t/* Accumulate each channel */\n        for (i = left; i <= right; i++) {\n\t\t\tconst int left_channel = i - left;\n            r += (unsigned char)(contrib->ContribRow[x].Weights[left_channel] * (double)(gdTrueColorGetRed(p_src_row[i])));\n            g += (unsigned char)(contrib->ContribRow[x].Weights[left_channel] * (double)(gdTrueColorGetGreen(p_src_row[i])));\n            b += (unsigned char)(contrib->ContribRow[x].Weights[left_channel] * (double)(gdTrueColorGetBlue(p_src_row[i])));\n\t\t\ta += (unsigned char)(contrib->ContribRow[x].Weights[left_channel] * (double)(gdTrueColorGetAlpha(p_src_row[i])));\n        }\n        p_dst_row[x] = gdTrueColorAlpha(r, g, b, a);\n    }\n}\n\nstatic inline void _gdScaleHoriz(gdImagePtr pSrc, unsigned int src_width, unsigned int src_height, gdImagePtr pDst,  unsigned int dst_width, unsigned int dst_height)\n{\n\tunsigned int u;\n\tLineContribType * contrib;\n\n\t/* same width, just copy it */\n\tif (dst_width == src_width) {\n\t\tunsigned int y;\n\t\tfor (y = 0; y < src_height - 1; ++y) {\n\t\t\tmemcpy(pDst->tpixels[y], pSrc->tpixels[y], src_width);\n\t\t}\n\t}\n\n\tcontrib = _gdContributionsCalc(dst_width, src_width, (double)dst_width / (double)src_width, pSrc->interpolation);\n\tif (contrib == NULL) {\n\t\treturn;\n\t}\n\t/* Scale each row */\n\tfor (u = 0; u < dst_height - 1; u++) {\n\t\t_gdScaleRow(pSrc, src_width, pDst, dst_width, u, contrib);\n\t}\n\t_gdContributionsFree (contrib);\n}\n\nstatic inline void _gdScaleCol (gdImagePtr pSrc,  unsigned int src_width, gdImagePtr pRes, unsigned int dst_width, unsigned int dst_height, unsigned int uCol, LineContribType *contrib)\n{\n\tunsigned int y;\n\tfor (y = 0; y < dst_height - 1; y++) {\n\t\tregister unsigned char r = 0, g = 0, b = 0, a = 0;\n\t\tconst int iLeft = contrib->ContribRow[y].Left;\n\t\tconst int iRight = contrib->ContribRow[y].Right;\n\t\tint i;\n\t\tint *row = pRes->tpixels[y];\n\n\t\t/* Accumulate each channel */\n\t\tfor (i = iLeft; i <= iRight; i++) {\n\t\t\tconst int pCurSrc = pSrc->tpixels[i][uCol];\n\t\t\tconst int i_iLeft = i - iLeft;\n\t\t\tr += (unsigned char)(contrib->ContribRow[y].Weights[i_iLeft] * (double)(gdTrueColorGetRed(pCurSrc)));\n\t\t\tg += (unsigned char)(contrib->ContribRow[y].Weights[i_iLeft] * (double)(gdTrueColorGetGreen(pCurSrc)));\n\t\t\tb += (unsigned char)(contrib->ContribRow[y].Weights[i_iLeft] * (double)(gdTrueColorGetBlue(pCurSrc)));\n\t\t\ta += (unsigned char)(contrib->ContribRow[y].Weights[i_iLeft] * (double)(gdTrueColorGetAlpha(pCurSrc)));\n\t\t}\n\t\tpRes->tpixels[y][uCol] = gdTrueColorAlpha(r, g, b, a);\n\t}\n}\n\nstatic inline void _gdScaleVert (const gdImagePtr pSrc, const unsigned int src_width, const unsigned int src_height, const gdImagePtr pDst, const unsigned int dst_width, const unsigned int dst_height)\n{\n\tunsigned int u;\n\tLineContribType * contrib;\n\n\t/* same height, copy it */\n\tif (src_height == dst_height) {\n\t\tunsigned int y;\n\t\tfor (y = 0; y < src_height - 1; ++y) {\n\t\t\tmemcpy(pDst->tpixels[y], pSrc->tpixels[y], src_width);\n\t\t}\n\t}\n\n\tcontrib = _gdContributionsCalc(dst_height, src_height, (double)(dst_height) / (double)(src_height), pSrc->interpolation);\n\t/* scale each column */\n\tfor (u = 0; u < dst_width - 1; u++) {\n\t\t_gdScaleCol(pSrc, src_width, pDst, dst_width, dst_height, u, contrib);\n\t}\n\t_gdContributionsFree(contrib);\n}\n\ngdImagePtr gdImageScaleTwoPass(const gdImagePtr src, const unsigned int src_width, const unsigned int src_height, const unsigned int new_width, const unsigned int new_height)\n{\n\tgdImagePtr tmp_im;\n\tgdImagePtr dst;\n\n\ttmp_im = gdImageCreateTrueColor(new_width, src_height);\n\tif (tmp_im == NULL) {\n\t\treturn NULL;\n\t}\n\tgdImageSetInterpolationMethod(tmp_im, src->interpolation_id);\n\t_gdScaleHoriz(src, src_width, src_height, tmp_im, new_width, src_height);\n\n\tdst = gdImageCreateTrueColor(new_width, new_height);\n\tif (dst == NULL) {\n\t\tgdFree(tmp_im);\n\t\treturn NULL;\n\t}\n\tgdImageSetInterpolationMethod(dst, src->interpolation_id);\n\t_gdScaleVert(tmp_im, new_width, src_height, dst, new_width, new_height);\n\tgdFree(tmp_im);\n\n\treturn dst;\n}\n\ngdImagePtr Scale(const gdImagePtr src, const unsigned int src_width, const unsigned int src_height, const gdImagePtr dst, const unsigned int new_width, const unsigned int new_height)\n{\n\tgdImagePtr tmp_im;\n\n\ttmp_im = gdImageCreateTrueColor(new_width, src_height);\n\tif (tmp_im == NULL) {\n\t\treturn NULL;\n\t}\n\tgdImageSetInterpolationMethod(tmp_im, src->interpolation_id);\n\n\t_gdScaleHoriz(src, src_width, src_height, tmp_im, new_width, src_height);\n\t_gdScaleVert(tmp_im, new_width, src_height, dst, new_width, new_height);\n\n\tgdFree(tmp_im);\n\treturn dst;\n}\n\n/*\n\tBilinearFixed, BicubicFixed and nearest implementations are rewamped versions of the implementation in CBitmapEx\n\thttp://www.codeproject.com/Articles/29121/CBitmapEx-Free-C-Bitmap-Manipulation-Class\n\tInteger only implementation, good to have for common usages like pre scale very large\n\timages before using another interpolation methods for the last step.\n*/\ngdImagePtr gdImageScaleNearestNeighbour(gdImagePtr im, const unsigned int width, const unsigned int height)\n{\n\tconst unsigned long new_width = MAX(1, width);\n\tconst unsigned long new_height = MAX(1, height);\n\tconst float dx = (float)im->sx / (float)new_width;\n\tconst float dy = (float)im->sy / (float)new_height;\n\tconst gdFixed f_dx = gd_ftofx(dx);\n\tconst gdFixed f_dy = gd_ftofx(dy);\n\n\tgdImagePtr dst_img;\n\tunsigned long  dst_offset_x;\n\tunsigned long  dst_offset_y = 0;\n\tunsigned int i;\n\n\tdst_img = gdImageCreateTrueColor(new_width, new_height);\n\n\tif (dst_img == NULL) {\n\t\treturn NULL;\n\t}\n\n\tfor (i=0; i<new_height; i++) {\n\t\tunsigned int j;\n\t\tdst_offset_x = 0;\n\t\tif (im->trueColor) {\n\t\t\tfor (j=0; j<new_width; j++) {\n\t\t\t\tconst gdFixed f_i = gd_itofx(i);\n\t\t\t\tconst gdFixed f_j = gd_itofx(j);\n\t\t\t\tconst gdFixed f_a = gd_mulfx(f_i, f_dy);\n\t\t\t\tconst gdFixed f_b = gd_mulfx(f_j, f_dx);\n\t\t\t\tconst long m = gd_fxtoi(f_a);\n\t\t\t\tconst long n = gd_fxtoi(f_b);\n\n\t\t\t\tdst_img->tpixels[dst_offset_y][dst_offset_x++] = im->tpixels[m][n];\n\t\t\t}\n\t\t} else {\n\t\t\tfor (j=0; j<new_width; j++) {\n\t\t\t\tconst gdFixed f_i = gd_itofx(i);\n\t\t\t\tconst gdFixed f_j = gd_itofx(j);\n\t\t\t\tconst gdFixed f_a = gd_mulfx(f_i, f_dy);\n\t\t\t\tconst gdFixed f_b = gd_mulfx(f_j, f_dx);\n\t\t\t\tconst long m = gd_fxtoi(f_a);\n\t\t\t\tconst long n = gd_fxtoi(f_b);\n\n\t\t\t\tdst_img->tpixels[dst_offset_y][dst_offset_x++] = colorIndex2RGBA(im->pixels[m][n]);\n\t\t\t}\n\t\t}\n\t\tdst_offset_y++;\n\t}\n\treturn dst_img;\n}\n\nstatic inline int getPixelOverflowColorTC(gdImagePtr im, const int x, const int y, const int color)\n{\n\tif (gdImageBoundsSafe(im, x, y)) {\n\t\tconst int c = im->tpixels[y][x];\n\t\tif (c == im->transparent) {\n\t\t\treturn gdTrueColorAlpha(0, 0, 0, 127);\n\t\t}\n\t\treturn c;\n\t} else {\n\t\tregister int border = 0;\n\t\tif (y < im->cy1) {\n\t\t\tborder = im->tpixels[0][im->cx1];\n\t\t\tgoto processborder;\n\t\t}\n\n\t\tif (y < im->cy1) {\n\t\t\tborder = im->tpixels[0][im->cx1];\n\t\t\tgoto processborder;\n\t\t}\n\n\t\tif (y > im->cy2) {\n\t\t\tif (x >= im->cx1 && x <= im->cx1) {\n\t\t\t\tborder = im->tpixels[im->cy2][x];\n\t\t\t\tgoto processborder;\n\t\t\t} else {\n\t\t\t\treturn gdTrueColorAlpha(0, 0, 0, 127);\n\t\t\t}\n\t\t}\n\n\t\t/* y is bound safe at this point */\n\t\tif (x < im->cx1) {\n\t\t\tborder = im->tpixels[y][im->cx1];\n\t\t\tgoto processborder;\n\t\t}\n\n\t\tif (x > im->cx2) {\n\t\t\tborder = im->tpixels[y][im->cx2];\n\t\t}\n\nprocessborder:\n\t\tif (border == im->transparent) {\n\t\t\treturn gdTrueColorAlpha(0, 0, 0, 127);\n\t\t} else{\n\t\t\treturn gdTrueColorAlpha(gdTrueColorGetRed(border), gdTrueColorGetGreen(border), gdTrueColorGetBlue(border), 127);\n\t\t}\n\t}\n}\n\nstatic gdImagePtr gdImageScaleBilinearPalette(gdImagePtr im, const unsigned int new_width, const unsigned int new_height)\n{\n\tlong _width = MAX(1, new_width);\n\tlong _height = MAX(1, new_height);\n\tfloat dx = (float)gdImageSX(im) / (float)_width;\n\tfloat dy = (float)gdImageSY(im) / (float)_height;\n\tgdFixed f_dx = gd_ftofx(dx);\n\tgdFixed f_dy = gd_ftofx(dy);\n\tgdFixed f_1 = gd_itofx(1);\n\n\tint dst_offset_h;\n\tint dst_offset_v = 0;\n\tlong i;\n\tgdImagePtr new_img;\n\tconst int transparent = im->transparent;\n\n\tnew_img = gdImageCreateTrueColor(new_width, new_height);\n\tif (new_img == NULL) {\n\t\treturn NULL;\n\t}\n\tnew_img->transparent = gdTrueColorAlpha(im->red[transparent], im->green[transparent], im->blue[transparent], im->alpha[transparent]);\n\n\tfor (i=0; i < _height; i++) {\n\t\tlong j;\n\t\tconst gdFixed f_i = gd_itofx(i);\n\t\tconst gdFixed f_a = gd_mulfx(f_i, f_dy);\n\t\tregister long m = gd_fxtoi(f_a);\n\n\t\tdst_offset_h = 0;\n\n\t\tfor (j=0; j < _width; j++) {\n\t\t\t/* Update bitmap */\n\t\t\tgdFixed f_j = gd_itofx(j);\n\t\t\tgdFixed f_b = gd_mulfx(f_j, f_dx);\n\n\t\t\tconst long n = gd_fxtoi(f_b);\n\t\t\tgdFixed f_f = f_a - gd_itofx(m);\n\t\t\tgdFixed f_g = f_b - gd_itofx(n);\n\n\t\t\tconst gdFixed f_w1 = gd_mulfx(f_1-f_f, f_1-f_g);\n\t\t\tconst gdFixed f_w2 = gd_mulfx(f_1-f_f, f_g);\n\t\t\tconst gdFixed f_w3 = gd_mulfx(f_f, f_1-f_g);\n\t\t\tconst gdFixed f_w4 = gd_mulfx(f_f, f_g);\n\t\t\tunsigned int pixel1;\n\t\t\tunsigned int pixel2;\n\t\t\tunsigned int pixel3;\n\t\t\tunsigned int pixel4;\n\t\t\tregister gdFixed f_r1, f_r2, f_r3, f_r4,\n\t\t\t\t\tf_g1, f_g2, f_g3, f_g4,\n\t\t\t\t\tf_b1, f_b2, f_b3, f_b4,\n\t\t\t\t\tf_a1, f_a2, f_a3, f_a4;\n\n\t\t\t/* zero for the background color, nothig gets outside anyway */\n\t\t\tpixel1 = getPixelOverflowPalette(im, n, m, 0);\n\t\t\tpixel2 = getPixelOverflowPalette(im, n + 1, m, 0);\n\t\t\tpixel3 = getPixelOverflowPalette(im, n, m + 1, 0);\n\t\t\tpixel4 = getPixelOverflowPalette(im, n + 1, m + 1, 0);\n\n\t\t\tf_r1 = gd_itofx(gdTrueColorGetRed(pixel1));\n\t\t\tf_r2 = gd_itofx(gdTrueColorGetRed(pixel2));\n\t\t\tf_r3 = gd_itofx(gdTrueColorGetRed(pixel3));\n\t\t\tf_r4 = gd_itofx(gdTrueColorGetRed(pixel4));\n\t\t\tf_g1 = gd_itofx(gdTrueColorGetGreen(pixel1));\n\t\t\tf_g2 = gd_itofx(gdTrueColorGetGreen(pixel2));\n\t\t\tf_g3 = gd_itofx(gdTrueColorGetGreen(pixel3));\n\t\t\tf_g4 = gd_itofx(gdTrueColorGetGreen(pixel4));\n\t\t\tf_b1 = gd_itofx(gdTrueColorGetBlue(pixel1));\n\t\t\tf_b2 = gd_itofx(gdTrueColorGetBlue(pixel2));\n\t\t\tf_b3 = gd_itofx(gdTrueColorGetBlue(pixel3));\n\t\t\tf_b4 = gd_itofx(gdTrueColorGetBlue(pixel4));\n\t\t\tf_a1 = gd_itofx(gdTrueColorGetAlpha(pixel1));\n\t\t\tf_a2 = gd_itofx(gdTrueColorGetAlpha(pixel2));\n\t\t\tf_a3 = gd_itofx(gdTrueColorGetAlpha(pixel3));\n\t\t\tf_a4 = gd_itofx(gdTrueColorGetAlpha(pixel4));\n\n\t\t\t{\n\t\t\t\tconst char red = (char) gd_fxtoi(gd_mulfx(f_w1, f_r1) + gd_mulfx(f_w2, f_r2) + gd_mulfx(f_w3, f_r3) + gd_mulfx(f_w4, f_r4));\n\t\t\t\tconst char green = (char) gd_fxtoi(gd_mulfx(f_w1, f_g1) + gd_mulfx(f_w2, f_g2) + gd_mulfx(f_w3, f_g3) + gd_mulfx(f_w4, f_g4));\n\t\t\t\tconst char blue = (char) gd_fxtoi(gd_mulfx(f_w1, f_b1) + gd_mulfx(f_w2, f_b2) + gd_mulfx(f_w3, f_b3) + gd_mulfx(f_w4, f_b4));\n\t\t\t\tconst char alpha = (char) gd_fxtoi(gd_mulfx(f_w1, f_a1) + gd_mulfx(f_w2, f_a2) + gd_mulfx(f_w3, f_a3) + gd_mulfx(f_w4, f_a4));\n\n\t\t\t\tnew_img->tpixels[dst_offset_v][dst_offset_h] = gdTrueColorAlpha(red, green, blue, alpha);\n\t\t\t}\n\n\t\t\tdst_offset_h++;\n\t\t}\n\n\t\tdst_offset_v++;\n\t}\n\treturn new_img;\n}\n\nstatic gdImagePtr gdImageScaleBilinearTC(gdImagePtr im, const unsigned int new_width, const unsigned int new_height)\n{\n\tlong dst_w = MAX(1, new_width);\n\tlong dst_h = MAX(1, new_height);\n\tfloat dx = (float)gdImageSX(im) / (float)dst_w;\n\tfloat dy = (float)gdImageSY(im) / (float)dst_h;\n\tgdFixed f_dx = gd_ftofx(dx);\n\tgdFixed f_dy = gd_ftofx(dy);\n\tgdFixed f_1 = gd_itofx(1);\n\n\tint dst_offset_h;\n\tint dst_offset_v = 0;\n\tint dwSrcTotalOffset;\n\tlong i;\n\tgdImagePtr new_img;\n\n\tnew_img = gdImageCreateTrueColor(new_width, new_height);\n\tif (!new_img){\n\t\treturn NULL;\n\t}\n\n\tfor (i=0; i < dst_h; i++) {\n\t\tlong j;\n\t\tdst_offset_h = 0;\n\t\tfor (j=0; j < dst_w; j++) {\n\t\t\t/* Update bitmap */\n\t\t\tgdFixed f_i = gd_itofx(i);\n\t\t\tgdFixed f_j = gd_itofx(j);\n\t\t\tgdFixed f_a = gd_mulfx(f_i, f_dy);\n\t\t\tgdFixed f_b = gd_mulfx(f_j, f_dx);\n\t\t\tconst gdFixed m = gd_fxtoi(f_a);\n\t\t\tconst gdFixed n = gd_fxtoi(f_b);\n\t\t\tgdFixed f_f = f_a - gd_itofx(m);\n\t\t\tgdFixed f_g = f_b - gd_itofx(n);\n\n\t\t\tconst gdFixed f_w1 = gd_mulfx(f_1-f_f, f_1-f_g);\n\t\t\tconst gdFixed f_w2 = gd_mulfx(f_1-f_f, f_g);\n\t\t\tconst gdFixed f_w3 = gd_mulfx(f_f, f_1-f_g);\n\t\t\tconst gdFixed f_w4 = gd_mulfx(f_f, f_g);\n\t\t\tunsigned int pixel1;\n\t\t\tunsigned int pixel2;\n\t\t\tunsigned int pixel3;\n\t\t\tunsigned int pixel4;\n\t\t\tregister gdFixed f_r1, f_r2, f_r3, f_r4,\n\t\t\t\t\tf_g1, f_g2, f_g3, f_g4,\n\t\t\t\t\tf_b1, f_b2, f_b3, f_b4,\n\t\t\t\t\tf_a1, f_a2, f_a3, f_a4;\n\t\t\tdwSrcTotalOffset = m + n;\n\t\t\t/* 0 for bgColor, nothing gets outside anyway */\n\t\t\tpixel1 = getPixelOverflowTC(im, n, m, 0);\n\t\t\tpixel2 = getPixelOverflowTC(im, n + 1, m, 0);\n\t\t\tpixel3 = getPixelOverflowTC(im, n, m + 1, 0);\n\t\t\tpixel4 = getPixelOverflowTC(im, n + 1, m + 1, 0);\n\n\t\t\tf_r1 = gd_itofx(gdTrueColorGetRed(pixel1));\n\t\t\tf_r2 = gd_itofx(gdTrueColorGetRed(pixel2));\n\t\t\tf_r3 = gd_itofx(gdTrueColorGetRed(pixel3));\n\t\t\tf_r4 = gd_itofx(gdTrueColorGetRed(pixel4));\n\t\t\tf_g1 = gd_itofx(gdTrueColorGetGreen(pixel1));\n\t\t\tf_g2 = gd_itofx(gdTrueColorGetGreen(pixel2));\n\t\t\tf_g3 = gd_itofx(gdTrueColorGetGreen(pixel3));\n\t\t\tf_g4 = gd_itofx(gdTrueColorGetGreen(pixel4));\n\t\t\tf_b1 = gd_itofx(gdTrueColorGetBlue(pixel1));\n\t\t\tf_b2 = gd_itofx(gdTrueColorGetBlue(pixel2));\n\t\t\tf_b3 = gd_itofx(gdTrueColorGetBlue(pixel3));\n\t\t\tf_b4 = gd_itofx(gdTrueColorGetBlue(pixel4));\n\t\t\tf_a1 = gd_itofx(gdTrueColorGetAlpha(pixel1));\n\t\t\tf_a2 = gd_itofx(gdTrueColorGetAlpha(pixel2));\n\t\t\tf_a3 = gd_itofx(gdTrueColorGetAlpha(pixel3));\n\t\t\tf_a4 = gd_itofx(gdTrueColorGetAlpha(pixel4));\n\t\t\t{\n\t\t\t\tconst unsigned char red   = (unsigned char) gd_fxtoi(gd_mulfx(f_w1, f_r1) + gd_mulfx(f_w2, f_r2) + gd_mulfx(f_w3, f_r3) + gd_mulfx(f_w4, f_r4));\n\t\t\t\tconst unsigned char green = (unsigned char) gd_fxtoi(gd_mulfx(f_w1, f_g1) + gd_mulfx(f_w2, f_g2) + gd_mulfx(f_w3, f_g3) + gd_mulfx(f_w4, f_g4));\n\t\t\t\tconst unsigned char blue  = (unsigned char) gd_fxtoi(gd_mulfx(f_w1, f_b1) + gd_mulfx(f_w2, f_b2) + gd_mulfx(f_w3, f_b3) + gd_mulfx(f_w4, f_b4));\n\t\t\t\tconst unsigned char alpha = (unsigned char) gd_fxtoi(gd_mulfx(f_w1, f_a1) + gd_mulfx(f_w2, f_a2) + gd_mulfx(f_w3, f_a3) + gd_mulfx(f_w4, f_a4));\n\n\t\t\t\tnew_img->tpixels[dst_offset_v][dst_offset_h] = gdTrueColorAlpha(red, green, blue, alpha);\n\t\t\t}\n\n\t\t\tdst_offset_h++;\n\t\t}\n\n\t\tdst_offset_v++;\n\t}\n\treturn new_img;\n}\n\ngdImagePtr gdImageScaleBilinear(gdImagePtr im, const unsigned int new_width, const unsigned int new_height)\n{\n\tif (im->trueColor) {\n\t\treturn gdImageScaleBilinearTC(im, new_width, new_height);\n\t} else {\n\t\treturn gdImageScaleBilinearPalette(im, new_width, new_height);\n\t}\n}\n\ngdImagePtr gdImageScaleBicubicFixed(gdImagePtr src, const unsigned int width, const unsigned int height)\n{\n\tconst long new_width = MAX(1, width);\n\tconst long new_height = MAX(1, height);\n\tconst int src_w = gdImageSX(src);\n\tconst int src_h = gdImageSY(src);\n\tconst gdFixed f_dx = gd_ftofx((float)src_w / (float)new_width);\n\tconst gdFixed f_dy = gd_ftofx((float)src_h / (float)new_height);\n\tconst gdFixed f_1 = gd_itofx(1);\n\tconst gdFixed f_2 = gd_itofx(2);\n\tconst gdFixed f_4 = gd_itofx(4);\n\tconst gdFixed f_6 = gd_itofx(6);\n\tconst gdFixed f_gamma = gd_ftofx(1.04f);\n\tgdImagePtr dst;\n\n\tunsigned int dst_offset_x;\n\tunsigned int dst_offset_y = 0;\n\tlong i;\n\n\t/* impact perf a bit, but not that much. Implementation for palette\n\t   images can be done at a later point.\n\t*/\n\tif (src->trueColor == 0) {\n\t\tgdImagePaletteToTrueColor(src);\n\t}\n\n\tdst = gdImageCreateTrueColor(new_width, new_height);\n\tif (!dst) {\n\t\treturn NULL;\n\t}\n\n\tdst->saveAlphaFlag = 1;\n\n\tfor (i=0; i < new_height; i++) {\n\t\tlong j;\n\t\tdst_offset_x = 0;\n\n\t\tfor (j=0; j < new_width; j++) {\n\t\t\tconst gdFixed f_a = gd_mulfx(gd_itofx(i), f_dy);\n\t\t\tconst gdFixed f_b = gd_mulfx(gd_itofx(j), f_dx);\n\t\t\tconst long m = gd_fxtoi(f_a);\n\t\t\tconst long n = gd_fxtoi(f_b);\n\t\t\tconst gdFixed f_f = f_a - gd_itofx(m);\n\t\t\tconst gdFixed f_g = f_b - gd_itofx(n);\n\t\t\tunsigned int src_offset_x[16], src_offset_y[16];\n\t\t\tlong k;\n\t\t\tregister gdFixed f_red = 0, f_green = 0, f_blue = 0, f_alpha = 0;\n\t\t\tunsigned char red, green, blue, alpha = 0;\n\t\t\tint *dst_row = dst->tpixels[dst_offset_y];\n\n\t\t\tif ((m < 1) || (n < 1)) {\n\t\t\t\tsrc_offset_x[0] = n;\n\t\t\t\tsrc_offset_y[0] = m;\n\t\t\t} else {\n\t\t\t\tsrc_offset_x[0] = n - 1;\n\t\t\t\tsrc_offset_y[0] = m;\n\t\t\t}\n\n\t\t\tif (m < 1) {\n\t\t\t\tsrc_offset_x[1] = n;\n\t\t\t\tsrc_offset_y[1] = m;\n\t\t\t} else {\n\t\t\t\tsrc_offset_x[1] = n;\n\t\t\t\tsrc_offset_y[1] = m;\n\t\t\t}\n\n\t\t\tif ((m < 1) || (n >= src_w - 1)) {\n\t\t\t\tsrc_offset_x[2] = n;\n\t\t\t\tsrc_offset_y[2] = m;\n\t\t\t} else {\n\t\t\t\tsrc_offset_x[2] = n + 1;\n\t\t\t\tsrc_offset_y[2] = m;\n\t\t\t}\n\n\t\t\tif ((m < 1) || (n >= src_w - 2)) {\n\t\t\t\tsrc_offset_x[3] = n;\n\t\t\t\tsrc_offset_y[3] = m;\n\t\t\t} else {\n\t\t\t\tsrc_offset_x[3] = n + 1 + 1;\n\t\t\t\tsrc_offset_y[3] = m;\n\t\t\t}\n\n\t\t\tif (n < 1) {\n\t\t\t\tsrc_offset_x[4] = n;\n\t\t\t\tsrc_offset_y[4] = m;\n\t\t\t} else {\n\t\t\t\tsrc_offset_x[4] = n - 1;\n\t\t\t\tsrc_offset_y[4] = m;\n\t\t\t}\n\n\t\t\tsrc_offset_x[5] = n;\n\t\t\tsrc_offset_y[5] = m;\n\t\t\tif (n >= src_w-1) {\n\t\t\t\tsrc_offset_x[6] = n;\n\t\t\t\tsrc_offset_y[6] = m;\n\t\t\t} else {\n\t\t\t\tsrc_offset_x[6] = n + 1;\n\t\t\t\tsrc_offset_y[6] = m;\n\t\t\t}\n\n\t\t\tif (n >= src_w - 2) {\n\t\t\t\tsrc_offset_x[7] = n;\n\t\t\t\tsrc_offset_y[7] = m;\n\t\t\t} else {\n\t\t\t\tsrc_offset_x[7] = n + 1 + 1;\n\t\t\t\tsrc_offset_y[7] = m;\n\t\t\t}\n\n\t\t\tif ((m >= src_h - 1) || (n < 1)) {\n\t\t\t\tsrc_offset_x[8] = n;\n\t\t\t\tsrc_offset_y[8] = m;\n\t\t\t} else {\n\t\t\t\tsrc_offset_x[8] = n - 1;\n\t\t\t\tsrc_offset_y[8] = m;\n\t\t\t}\n\n\t\t\tif (m >= src_h - 1) {\n\t\t\t\tsrc_offset_x[8] = n;\n\t\t\t\tsrc_offset_y[8] = m;\n\t\t\t} else {\n\t\t\t\tsrc_offset_x[9] = n;\n\t\t\t\tsrc_offset_y[9] = m;\n\t\t\t}\n\n\t\t\tif ((m >= src_h-1) || (n >= src_w-1)) {\n\t\t\t\tsrc_offset_x[10] = n;\n\t\t\t\tsrc_offset_y[10] = m;\n\t\t\t} else {\n\t\t\t\tsrc_offset_x[10] = n + 1;\n\t\t\t\tsrc_offset_y[10] = m;\n\t\t\t}\n\n\t\t\tif ((m >= src_h - 1) || (n >= src_w - 2)) {\n\t\t\t\tsrc_offset_x[11] = n;\n\t\t\t\tsrc_offset_y[11] = m;\n\t\t\t} else {\n\t\t\t\tsrc_offset_x[11] = n + 1 + 1;\n\t\t\t\tsrc_offset_y[11] = m;\n\t\t\t}\n\n\t\t\tif ((m >= src_h - 2) || (n < 1)) {\n\t\t\t\tsrc_offset_x[12] = n;\n\t\t\t\tsrc_offset_y[12] = m;\n\t\t\t} else {\n\t\t\t\tsrc_offset_x[12] = n - 1;\n\t\t\t\tsrc_offset_y[12] = m;\n\t\t\t}\n\n\t\t\tif (m >= src_h - 2) {\n\t\t\t\tsrc_offset_x[13] = n;\n\t\t\t\tsrc_offset_y[13] = m;\n\t\t\t} else {\n\t\t\t\tsrc_offset_x[13] = n;\n\t\t\t\tsrc_offset_y[13] = m;\n\t\t\t}\n\n\t\t\tif ((m >= src_h - 2) || (n >= src_w - 1)) {\n\t\t\t\tsrc_offset_x[14] = n;\n\t\t\t\tsrc_offset_y[14] = m;\n\t\t\t} else {\n\t\t\t\tsrc_offset_x[14] = n + 1;\n\t\t\t\tsrc_offset_y[14] = m;\n\t\t\t}\n\n\t\t\tif ((m >= src_h - 2) || (n >= src_w - 2)) {\n\t\t\t\tsrc_offset_x[15] = n;\n\t\t\t\tsrc_offset_y[15] = m;\n\t\t\t} else {\n\t\t\t\tsrc_offset_x[15] = n  + 1 + 1;\n\t\t\t\tsrc_offset_y[15] = m;\n\t\t\t}\n\n\t\t\tfor (k = -1; k < 3; k++) {\n\t\t\t\tconst gdFixed f = gd_itofx(k)-f_f;\n\t\t\t\tconst gdFixed f_fm1 = f - f_1;\n\t\t\t\tconst gdFixed f_fp1 = f + f_1;\n\t\t\t\tconst gdFixed f_fp2 = f + f_2;\n\t\t\t\tregister gdFixed f_a = 0, f_b = 0, f_d = 0, f_c = 0;\n\t\t\t\tregister gdFixed f_RY;\n\t\t\t\tint l;\n\n\t\t\t\tif (f_fp2 > 0) f_a = gd_mulfx(f_fp2, gd_mulfx(f_fp2,f_fp2));\n\t\t\t\tif (f_fp1 > 0) f_b = gd_mulfx(f_fp1, gd_mulfx(f_fp1,f_fp1));\n\t\t\t\tif (f > 0)     f_c = gd_mulfx(f, gd_mulfx(f,f));\n\t\t\t\tif (f_fm1 > 0) f_d = gd_mulfx(f_fm1, gd_mulfx(f_fm1,f_fm1));\n\n\t\t\t\tf_RY = gd_divfx((f_a - gd_mulfx(f_4,f_b) + gd_mulfx(f_6,f_c) - gd_mulfx(f_4,f_d)),f_6);\n\n\t\t\t\tfor (l = -1; l < 3; l++) {\n\t\t\t\t\tconst gdFixed f = gd_itofx(l) - f_g;\n\t\t\t\t\tconst gdFixed f_fm1 = f - f_1;\n\t\t\t\t\tconst gdFixed f_fp1 = f + f_1;\n\t\t\t\t\tconst gdFixed f_fp2 = f + f_2;\n\t\t\t\t\tregister gdFixed f_a = 0, f_b = 0, f_c = 0, f_d = 0;\n\t\t\t\t\tregister gdFixed f_RX, f_R, f_rs, f_gs, f_bs, f_ba;\n\t\t\t\t\tregister int c;\n\t\t\t\t\tconst int _k = ((k+1)*4) + (l+1);\n\n\t\t\t\t\tif (f_fp2 > 0) f_a = gd_mulfx(f_fp2,gd_mulfx(f_fp2,f_fp2));\n\n\t\t\t\t\tif (f_fp1 > 0) f_b = gd_mulfx(f_fp1,gd_mulfx(f_fp1,f_fp1));\n\n\t\t\t\t\tif (f > 0) f_c = gd_mulfx(f,gd_mulfx(f,f));\n\n\t\t\t\t\tif (f_fm1 > 0) f_d = gd_mulfx(f_fm1,gd_mulfx(f_fm1,f_fm1));\n\n\t\t\t\t\tf_RX = gd_divfx((f_a-gd_mulfx(f_4,f_b)+gd_mulfx(f_6,f_c)-gd_mulfx(f_4,f_d)),f_6);\n\t\t\t\t\tf_R = gd_mulfx(f_RY,f_RX);\n\n\t\t\t\t\tc = src->tpixels[*(src_offset_y + _k)][*(src_offset_x + _k)];\n\t\t\t\t\tf_rs = gd_itofx(gdTrueColorGetRed(c));\n\t\t\t\t\tf_gs = gd_itofx(gdTrueColorGetGreen(c));\n\t\t\t\t\tf_bs = gd_itofx(gdTrueColorGetBlue(c));\n\t\t\t\t\tf_ba = gd_itofx(gdTrueColorGetAlpha(c));\n\n\t\t\t\t\tf_red += gd_mulfx(f_rs,f_R);\n\t\t\t\t\tf_green += gd_mulfx(f_gs,f_R);\n\t\t\t\t\tf_blue += gd_mulfx(f_bs,f_R);\n\t\t\t\t\tf_alpha += gd_mulfx(f_ba,f_R);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tred    = (unsigned char) CLAMP(gd_fxtoi(gd_mulfx(f_red,   f_gamma)),  0, 255);\n\t\t\tgreen  = (unsigned char) CLAMP(gd_fxtoi(gd_mulfx(f_green, f_gamma)),  0, 255);\n\t\t\tblue   = (unsigned char) CLAMP(gd_fxtoi(gd_mulfx(f_blue,  f_gamma)),  0, 255);\n\t\t\talpha  = (unsigned char) CLAMP(gd_fxtoi(gd_mulfx(f_alpha,  f_gamma)), 0, 127);\n\n\t\t\t*(dst_row + dst_offset_x) = gdTrueColorAlpha(red, green, blue, alpha);\n\n\t\t\tdst_offset_x++;\n\t\t}\n\t\tdst_offset_y++;\n\t}\n\treturn dst;\n}\n\ngdImagePtr gdImageScale(const gdImagePtr src, const unsigned int new_width, const unsigned int new_height)\n{\n\tgdImagePtr im_scaled = NULL;\n\n\tif (src == NULL || src->interpolation_id < 0 || src->interpolation_id > GD_METHOD_COUNT) {\n\t\treturn 0;\n\t}\n\n\tswitch (src->interpolation_id) {\n\t\t/*Special cases, optimized implementations */\n\t\tcase GD_NEAREST_NEIGHBOUR:\n\t\t\tim_scaled = gdImageScaleNearestNeighbour(src, new_width, new_height);\n\t\t\tbreak;\n\n\t\tcase GD_BILINEAR_FIXED:\n\t\t\tim_scaled = gdImageScaleBilinear(src, new_width, new_height);\n\t\t\tbreak;\n\n\t\tcase GD_BICUBIC_FIXED:\n\t\t\tim_scaled = gdImageScaleBicubicFixed(src, new_width, new_height);\n\t\t\tbreak;\n\n\t\t/* generic */\n\t\tdefault:\n\t\t\tif (src->interpolation == NULL) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tim_scaled = gdImageScaleTwoPass(src, src->sx, src->sy, new_width, new_height);\n\t\t\tbreak;\n\t}\n\treturn im_scaled;\n}\n\ngdImagePtr gdImageRotateNearestNeighbour(gdImagePtr src, const float degrees, const int bgColor)\n{\n\tfloat _angle = ((float) (-degrees / 180.0f) * (float)M_PI);\n\tconst int src_w  = gdImageSX(src);\n\tconst int src_h = gdImageSY(src);\n\tconst unsigned int new_width = (unsigned int)(abs((int)(src_w * cos(_angle))) + abs((int)(src_h * sin(_angle))) + 0.5f);\n\tconst unsigned int new_height = (unsigned int)(abs((int)(src_w * sin(_angle))) + abs((int)(src_h * cos(_angle))) + 0.5f);\n\tconst gdFixed f_0_5 = gd_ftofx(0.5f);\n\tconst gdFixed f_H = gd_itofx(src_h/2);\n\tconst gdFixed f_W = gd_itofx(src_w/2);\n\tconst gdFixed f_cos = gd_ftofx(cos(-_angle));\n\tconst gdFixed f_sin = gd_ftofx(sin(-_angle));\n\n\tunsigned int dst_offset_x;\n\tunsigned int dst_offset_y = 0;\n\tunsigned int i;\n\tgdImagePtr dst;\n\n\tdst = gdImageCreateTrueColor(new_width, new_height);\n\tif (!dst) {\n\t\treturn NULL;\n\t}\n\tdst->saveAlphaFlag = 1;\n\tfor (i = 0; i < new_height; i++) {\n\t\tunsigned int j;\n\t\tdst_offset_x = 0;\n\t\tfor (j = 0; j < new_width; j++) {\n\t\t\tgdFixed f_i = gd_itofx((int)i - (int)new_height/2);\n\t\t\tgdFixed f_j = gd_itofx((int)j - (int)new_width/2);\n\t\t\tgdFixed f_m = gd_mulfx(f_j,f_sin) + gd_mulfx(f_i,f_cos) + f_0_5 + f_H;\n\t\t\tgdFixed f_n = gd_mulfx(f_j,f_cos) - gd_mulfx(f_i,f_sin) + f_0_5 + f_W;\n\t\t\tlong m = gd_fxtoi(f_m);\n\t\t\tlong n = gd_fxtoi(f_n);\n\n\t\t\tif ((m > 0) && (m < src_h-1) && (n > 0) && (n < src_w-1)) {\n\t\t\t\tif (dst_offset_y < new_height) {\n\t\t\t\t\tdst->tpixels[dst_offset_y][dst_offset_x++] = src->tpixels[m][n];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (dst_offset_y < new_height) {\n\t\t\t\t\tdst->tpixels[dst_offset_y][dst_offset_x++] = bgColor;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdst_offset_y++;\n\t}\n\treturn dst;\n}\n\ngdImagePtr gdImageRotateGeneric(gdImagePtr src, const float degrees, const int bgColor)\n{\n\tfloat _angle = ((float) (-degrees / 180.0f) * (float)M_PI);\n\tconst int src_w  = gdImageSX(src);\n\tconst int src_h = gdImageSY(src);\n\tconst unsigned int new_width = (unsigned int)(abs((int)(src_w * cos(_angle))) + abs((int)(src_h * sin(_angle))) + 0.5f);\n\tconst unsigned int new_height = (unsigned int)(abs((int)(src_w * sin(_angle))) + abs((int)(src_h * cos(_angle))) + 0.5f);\n\tconst gdFixed f_0_5 = gd_ftofx(0.5f);\n\tconst gdFixed f_H = gd_itofx(src_h/2);\n\tconst gdFixed f_W = gd_itofx(src_w/2);\n\tconst gdFixed f_cos = gd_ftofx(cos(-_angle));\n\tconst gdFixed f_sin = gd_ftofx(sin(-_angle));\n\n\tunsigned int dst_offset_x;\n\tunsigned int dst_offset_y = 0;\n\tunsigned int i;\n\tgdImagePtr dst;\n\n\tconst gdFixed f_slop_y = f_sin;\n\tconst gdFixed f_slop_x = f_cos;\n\tconst gdFixed f_slop = f_slop_x > 0 && f_slop_x > 0 ?\n\t\t\t\t\t\t\tf_slop_x > f_slop_y ? gd_divfx(f_slop_y, f_slop_x) : gd_divfx(f_slop_x, f_slop_y)\n\t\t\t\t\t\t: 0;\n\n\n\tdst = gdImageCreateTrueColor(new_width, new_height);\n\tif (!dst) {\n\t\treturn NULL;\n\t}\n\tdst->saveAlphaFlag = 1;\n\n\tfor (i = 0; i < new_height; i++) {\n\t\tunsigned int j;\n\t\tdst_offset_x = 0;\n\t\tfor (j = 0; j < new_width; j++) {\n\t\t\tgdFixed f_i = gd_itofx((int)i - (int)new_height/ 2);\n\t\t\tgdFixed f_j = gd_itofx((int)j - (int)new_width / 2);\n\t\t\tgdFixed f_m = gd_mulfx(f_j,f_sin) + gd_mulfx(f_i,f_cos) + f_0_5 + f_H;\n\t\t\tgdFixed f_n = gd_mulfx(f_j,f_cos) - gd_mulfx(f_i,f_sin) + f_0_5 + f_W;\n\t\t\tlong m = gd_fxtoi(f_m);\n\t\t\tlong n = gd_fxtoi(f_n);\n\n\t\t\tif ((n <= 0) || (m <= 0) || (m >= src_h) || (n >= src_w)) {\n\t\t\t\tdst->tpixels[dst_offset_y][dst_offset_x++] = bgColor;\n\t\t\t} else if ((n <= 1) || (m <= 1) || (m >= src_h - 1) || (n >= src_w - 1)) {\n\t\t\t\tgdFixed f_127 = gd_itofx(127);\n\t\t\t\tregister int c = getPixelInterpolated(src, n, m, bgColor);\n\t\t\t\tc = c | (( gdTrueColorGetAlpha(c) + ((int)(127* gd_fxtof(f_slop)))) << 24);\n\n\t\t\t\tdst->tpixels[dst_offset_y][dst_offset_x++] = _color_blend(bgColor, c);\n\t\t\t} else {\n\t\t\t\tdst->tpixels[dst_offset_y][dst_offset_x++] = getPixelInterpolated(src, n, m, bgColor);\n\t\t\t}\n\t\t}\n\t\tdst_offset_y++;\n\t}\n\treturn dst;\n}\n\ngdImagePtr gdImageRotateBilinear(gdImagePtr src, const float degrees, const int bgColor)\n{\n\tfloat _angle = (float)((- degrees / 180.0f) * M_PI);\n\tconst unsigned int src_w = gdImageSX(src);\n\tconst unsigned int src_h = gdImageSY(src);\n\tunsigned int new_width = abs((int)(src_w*cos(_angle))) + abs((int)(src_h*sin(_angle) + 0.5f));\n\tunsigned int new_height = abs((int)(src_w*sin(_angle))) + abs((int)(src_h*cos(_angle) + 0.5f));\n\tconst gdFixed f_0_5 = gd_ftofx(0.5f);\n\tconst gdFixed f_H = gd_itofx(src_h/2);\n\tconst gdFixed f_W = gd_itofx(src_w/2);\n\tconst gdFixed f_cos = gd_ftofx(cos(-_angle));\n\tconst gdFixed f_sin = gd_ftofx(sin(-_angle));\n\tconst gdFixed f_1 = gd_itofx(1);\n\tunsigned int i;\n\tunsigned int dst_offset_x;\n\tunsigned int dst_offset_y = 0;\n\tunsigned int src_offset_x, src_offset_y;\n\tgdImagePtr dst;\n\n\tdst = gdImageCreateTrueColor(new_width, new_height);\n\tif (dst == NULL) {\n\t\treturn NULL;\n\t}\n\tdst->saveAlphaFlag = 1;\n\n\tfor (i = 0; i < new_height; i++) {\n\t\tunsigned int j;\n\t\tdst_offset_x = 0;\n\n\t\tfor (j=0; j < new_width; j++) {\n\t\t\tconst gdFixed f_i = gd_itofx((int)i - (int)new_height/2);\n\t\t\tconst gdFixed f_j = gd_itofx((int)j - (int)new_width/2);\n\t\t\tconst gdFixed f_m = gd_mulfx(f_j,f_sin) + gd_mulfx(f_i,f_cos) + f_0_5 + f_H;\n\t\t\tconst gdFixed f_n = gd_mulfx(f_j,f_cos) - gd_mulfx(f_i,f_sin) + f_0_5 + f_W;\n\t\t\tconst unsigned int m = gd_fxtoi(f_m);\n\t\t\tconst unsigned int n = gd_fxtoi(f_n);\n\n\t\t\tif ((m > 0) && (m < src_h - 1) && (n > 0) && (n < src_w - 1)) {\n\t\t\t\tconst gdFixed f_f = f_m - gd_itofx(m);\n\t\t\t\tconst gdFixed f_g = f_n - gd_itofx(n);\n\t\t\t\tconst gdFixed f_w1 = gd_mulfx(f_1-f_f, f_1-f_g);\n\t\t\t\tconst gdFixed f_w2 = gd_mulfx(f_1-f_f, f_g);\n\t\t\t\tconst gdFixed f_w3 = gd_mulfx(f_f, f_1-f_g);\n\t\t\t\tconst gdFixed f_w4 = gd_mulfx(f_f, f_g);\n\n\t\t\t\tif (n < src_w - 1) {\n\t\t\t\t\tsrc_offset_x = n + 1;\n\t\t\t\t\tsrc_offset_y = m;\n\t\t\t\t}\n\n\t\t\t\tif (m < src_h-1) {\n\t\t\t\t\tsrc_offset_x = n;\n\t\t\t\t\tsrc_offset_y = m + 1;\n\t\t\t\t}\n\n\t\t\t\tif (!((n >= src_w-1) || (m >= src_h-1))) {\n\t\t\t\t\tsrc_offset_x = n + 1;\n\t\t\t\t\tsrc_offset_y = m + 1;\n\t\t\t\t}\n\t\t\t\t{\n\t\t\t\t\tconst int pixel1 = src->tpixels[src_offset_y][src_offset_x];\n\t\t\t\t\tregister int pixel2, pixel3, pixel4;\n\n\t\t\t\t\tif (src_offset_y + 1 >= src_h) {\n\t\t\t\t\t\tpixel2 = bgColor;\n\t\t\t\t\t\tpixel3 = bgColor;\n\t\t\t\t\t\tpixel4 = bgColor;\n\t\t\t\t\t} else if (src_offset_x + 1 >= src_w) {\n\t\t\t\t\t\tpixel2 = bgColor;\n\t\t\t\t\t\tpixel3 = bgColor;\n\t\t\t\t\t\tpixel4 = bgColor;\n\t\t\t\t\t} else {\n\t\t\t\t\t    pixel2 = src->tpixels[src_offset_y][src_offset_x + 1];\n\t\t\t\t\t\tpixel3 = src->tpixels[src_offset_y + 1][src_offset_x];\n\t\t\t\t\t\tpixel4 = src->tpixels[src_offset_y + 1][src_offset_x + 1];\n\t\t\t\t\t}\n\t\t\t\t\t{\n\t\t\t\t\t\tconst gdFixed f_r1 = gd_itofx(gdTrueColorGetRed(pixel1));\n\t\t\t\t\t\tconst gdFixed f_r2 = gd_itofx(gdTrueColorGetRed(pixel2));\n\t\t\t\t\t\tconst gdFixed f_r3 = gd_itofx(gdTrueColorGetRed(pixel3));\n\t\t\t\t\t\tconst gdFixed f_r4 = gd_itofx(gdTrueColorGetRed(pixel4));\n\t\t\t\t\t\tconst gdFixed f_g1 = gd_itofx(gdTrueColorGetGreen(pixel1));\n\t\t\t\t\t\tconst gdFixed f_g2 = gd_itofx(gdTrueColorGetGreen(pixel2));\n\t\t\t\t\t\tconst gdFixed f_g3 = gd_itofx(gdTrueColorGetGreen(pixel3));\n\t\t\t\t\t\tconst gdFixed f_g4 = gd_itofx(gdTrueColorGetGreen(pixel4));\n\t\t\t\t\t\tconst gdFixed f_b1 = gd_itofx(gdTrueColorGetBlue(pixel1));\n\t\t\t\t\t\tconst gdFixed f_b2 = gd_itofx(gdTrueColorGetBlue(pixel2));\n\t\t\t\t\t\tconst gdFixed f_b3 = gd_itofx(gdTrueColorGetBlue(pixel3));\n\t\t\t\t\t\tconst gdFixed f_b4 = gd_itofx(gdTrueColorGetBlue(pixel4));\n\t\t\t\t\t\tconst gdFixed f_a1 = gd_itofx(gdTrueColorGetAlpha(pixel1));\n\t\t\t\t\t\tconst gdFixed f_a2 = gd_itofx(gdTrueColorGetAlpha(pixel2));\n\t\t\t\t\t\tconst gdFixed f_a3 = gd_itofx(gdTrueColorGetAlpha(pixel3));\n\t\t\t\t\t\tconst gdFixed f_a4 = gd_itofx(gdTrueColorGetAlpha(pixel4));\n\t\t\t\t\t\tconst gdFixed f_red = gd_mulfx(f_w1, f_r1) + gd_mulfx(f_w2, f_r2) + gd_mulfx(f_w3, f_r3) + gd_mulfx(f_w4, f_r4);\n\t\t\t\t\t\tconst gdFixed f_green = gd_mulfx(f_w1, f_g1) + gd_mulfx(f_w2, f_g2) + gd_mulfx(f_w3, f_g3) + gd_mulfx(f_w4, f_g4);\n\t\t\t\t\t\tconst gdFixed f_blue = gd_mulfx(f_w1, f_b1) + gd_mulfx(f_w2, f_b2) + gd_mulfx(f_w3, f_b3) + gd_mulfx(f_w4, f_b4);\n\t\t\t\t\t\tconst gdFixed f_alpha = gd_mulfx(f_w1, f_a1) + gd_mulfx(f_w2, f_a2) + gd_mulfx(f_w3, f_a3) + gd_mulfx(f_w4, f_a4);\n\n\t\t\t\t\t\tconst unsigned char red   = (unsigned char) CLAMP(gd_fxtoi(f_red),   0, 255);\n\t\t\t\t\t\tconst unsigned char green = (unsigned char) CLAMP(gd_fxtoi(f_green), 0, 255);\n\t\t\t\t\t\tconst unsigned char blue  = (unsigned char) CLAMP(gd_fxtoi(f_blue),  0, 255);\n\t\t\t\t\t\tconst unsigned char alpha = (unsigned char) CLAMP(gd_fxtoi(f_alpha), 0, 127);\n\n\t\t\t\t\t\tdst->tpixels[dst_offset_y][dst_offset_x++] = gdTrueColorAlpha(red, green, blue, alpha);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdst->tpixels[dst_offset_y][dst_offset_x++] = bgColor;\n\t\t\t}\n\t\t}\n\t\tdst_offset_y++;\n\t}\n\treturn dst;\n}\n\ngdImagePtr gdImageRotateBicubicFixed(gdImagePtr src, const float degrees, const int bgColor)\n{\n\tconst float _angle = (float)((- degrees / 180.0f) * M_PI);\n\tconst int src_w = gdImageSX(src);\n\tconst int src_h = gdImageSY(src);\n\tconst unsigned int new_width = abs((int)(src_w*cos(_angle))) + abs((int)(src_h*sin(_angle) + 0.5f));\n\tconst unsigned int new_height = abs((int)(src_w*sin(_angle))) + abs((int)(src_h*cos(_angle) + 0.5f));\n\tconst gdFixed f_0_5 = gd_ftofx(0.5f);\n\tconst gdFixed f_H = gd_itofx(src_h/2);\n\tconst gdFixed f_W = gd_itofx(src_w/2);\n\tconst gdFixed f_cos = gd_ftofx(cos(-_angle));\n\tconst gdFixed f_sin = gd_ftofx(sin(-_angle));\n\tconst gdFixed f_1 = gd_itofx(1);\n\tconst gdFixed f_2 = gd_itofx(2);\n\tconst gdFixed f_4 = gd_itofx(4);\n\tconst gdFixed f_6 = gd_itofx(6);\n\tconst gdFixed f_gama = gd_ftofx(1.04f);\n\n\tunsigned int dst_offset_x;\n\tunsigned int dst_offset_y = 0;\n\tunsigned int i;\n\tgdImagePtr dst;\n\n\tdst = gdImageCreateTrueColor(new_width, new_height);\n\n\tif (dst == NULL) {\n\t\treturn NULL;\n\t}\n\tdst->saveAlphaFlag = 1;\n\n\tfor (i=0; i < new_height; i++) {\n\t\tunsigned int j;\n\t\tdst_offset_x = 0;\n\n\t\tfor (j=0; j < new_width; j++) {\n\t\t\tconst gdFixed f_i = gd_itofx((int)i - (int)new_height/2);\n\t\t\tconst gdFixed f_j = gd_itofx((int)j - (int)new_width/2);\n\t\t\tconst gdFixed f_m = gd_mulfx(f_j,f_sin) + gd_mulfx(f_i,f_cos) + f_0_5 + f_H;\n\t\t\tconst gdFixed f_n = gd_mulfx(f_j,f_cos) - gd_mulfx(f_i,f_sin) + f_0_5 + f_W;\n\t\t\tconst int m = gd_fxtoi(f_m);\n\t\t\tconst int n = gd_fxtoi(f_n);\n\n\t\t\tif ((m > 0) && (m < src_h - 1) && (n > 0) && (n < src_w-1)) {\n\t\t\t\tconst gdFixed f_f = f_m - gd_itofx(m);\n\t\t\t\tconst gdFixed f_g = f_n - gd_itofx(n);\n\t\t\t\tunsigned int src_offset_x[16], src_offset_y[16];\n\t\t\t\tunsigned char red, green, blue, alpha;\n\t\t\t\tgdFixed f_red=0, f_green=0, f_blue=0, f_alpha=0;\n\t\t\t\tint k;\n\n\t\t\t\tif ((m < 1) || (n < 1)) {\n\t\t\t\t\tsrc_offset_x[0] = n;\n\t\t\t\t\tsrc_offset_y[0] = m;\n\t\t\t\t} else {\n\t\t\t\t\tsrc_offset_x[0] = n - 1;\n\t\t\t\t\tsrc_offset_y[0] = m;\n\t\t\t\t}\n\n\t\t\t\tif (m < 1) {\n\t\t\t\t\tsrc_offset_x[1] = n;\n\t\t\t\t\tsrc_offset_y[1] = m;\n\t\t\t\t} else {\n\t\t\t\t\tsrc_offset_x[1] = n;\n\t\t\t\t\tsrc_offset_y[1] = m ;\n\t\t\t\t}\n\n\t\t\t\tif ((m < 1) || (n >= src_w-1)) {\n\t\t\t\t\tsrc_offset_x[2] = - 1;\n\t\t\t\t\tsrc_offset_y[2] = - 1;\n\t\t\t\t} else {\n\t\t\t\t\tsrc_offset_x[2] = n + 1;\n\t\t\t\t\tsrc_offset_y[2] = m ;\n\t\t\t\t}\n\n\t\t\t\tif ((m < 1) || (n >= src_w-2)) {\n\t\t\t\t\tsrc_offset_x[3] = - 1;\n\t\t\t\t\tsrc_offset_y[3] = - 1;\n\t\t\t\t} else {\n\t\t\t\t\tsrc_offset_x[3] = n + 1 + 1;\n\t\t\t\t\tsrc_offset_y[3] = m ;\n\t\t\t\t}\n\n\t\t\t\tif (n < 1) {\n\t\t\t\t\tsrc_offset_x[4] = - 1;\n\t\t\t\t\tsrc_offset_y[4] = - 1;\n\t\t\t\t} else {\n\t\t\t\t\tsrc_offset_x[4] = n - 1;\n\t\t\t\t\tsrc_offset_y[4] = m;\n\t\t\t\t}\n\n\t\t\t\tsrc_offset_x[5] = n;\n\t\t\t\tsrc_offset_y[5] = m;\n\t\t\t\tif (n >= src_w-1) {\n\t\t\t\t\tsrc_offset_x[6] = - 1;\n\t\t\t\t\tsrc_offset_y[6] = - 1;\n\t\t\t\t} else {\n\t\t\t\t\tsrc_offset_x[6] = n + 1;\n\t\t\t\t\tsrc_offset_y[6] = m;\n\t\t\t\t}\n\n\t\t\t\tif (n >= src_w-2) {\n\t\t\t\t\tsrc_offset_x[7] = - 1;\n\t\t\t\t\tsrc_offset_y[7] = - 1;\n\t\t\t\t} else {\n\t\t\t\t\tsrc_offset_x[7] = n + 1 + 1;\n\t\t\t\t\tsrc_offset_y[7] = m;\n\t\t\t\t}\n\n\t\t\t\tif ((m >= src_h-1) || (n < 1)) {\n\t\t\t\t\tsrc_offset_x[8] = - 1;\n\t\t\t\t\tsrc_offset_y[8] = - 1;\n\t\t\t\t} else {\n\t\t\t\t\tsrc_offset_x[8] = n - 1;\n\t\t\t\t\tsrc_offset_y[8] = m;\n\t\t\t\t}\n\n\t\t\t\tif (m >= src_h-1) {\n\t\t\t\t\tsrc_offset_x[8] = - 1;\n\t\t\t\t\tsrc_offset_y[8] = - 1;\n\t\t\t\t} else {\n\t\t\t\t\tsrc_offset_x[9] = n;\n\t\t\t\t\tsrc_offset_y[9] = m;\n\t\t\t\t}\n\n\t\t\t\tif ((m >= src_h-1) || (n >= src_w-1)) {\n\t\t\t\t\tsrc_offset_x[10] = - 1;\n\t\t\t\t\tsrc_offset_y[10] = - 1;\n\t\t\t\t} else {\n\t\t\t\t\tsrc_offset_x[10] = n + 1;\n\t\t\t\t\tsrc_offset_y[10] = m;\n\t\t\t\t}\n\n\t\t\t\tif ((m >= src_h-1) || (n >= src_w-2)) {\n\t\t\t\t\tsrc_offset_x[11] = - 1;\n\t\t\t\t\tsrc_offset_y[11] = - 1;\n\t\t\t\t} else {\n\t\t\t\t\tsrc_offset_x[11] = n + 1 + 1;\n\t\t\t\t\tsrc_offset_y[11] = m;\n\t\t\t\t}\n\n\t\t\t\tif ((m >= src_h-2) || (n < 1)) {\n\t\t\t\t\tsrc_offset_x[12] = - 1;\n\t\t\t\t\tsrc_offset_y[12] = - 1;\n\t\t\t\t} else {\n\t\t\t\t\tsrc_offset_x[12] = n - 1;\n\t\t\t\t\tsrc_offset_y[12] = m;\n\t\t\t\t}\n\n\t\t\t\tif (m >= src_h-2) {\n\t\t\t\t\tsrc_offset_x[13] = - 1;\n\t\t\t\t\tsrc_offset_y[13] = - 1;\n\t\t\t\t} else {\n\t\t\t\t\tsrc_offset_x[13] = n;\n\t\t\t\t\tsrc_offset_y[13] = m;\n\t\t\t\t}\n\n\t\t\t\tif ((m >= src_h-2) || (n >= src_w - 1)) {\n\t\t\t\t\tsrc_offset_x[14] = - 1;\n\t\t\t\t\tsrc_offset_y[14] = - 1;\n\t\t\t\t} else {\n\t\t\t\t\tsrc_offset_x[14] = n + 1;\n\t\t\t\t\tsrc_offset_y[14] = m;\n\t\t\t\t}\n\n\t\t\t\tif ((m >= src_h-2) || (n >= src_w-2)) {\n\t\t\t\t\tsrc_offset_x[15] = - 1;\n\t\t\t\t\tsrc_offset_y[15] = - 1;\n\t\t\t\t} else {\n\t\t\t\t\tsrc_offset_x[15] = n  + 1 + 1;\n\t\t\t\t\tsrc_offset_y[15] = m;\n\t\t\t\t}\n\n\t\t\t\tfor (k=-1; k<3; k++) {\n\t\t\t\t\tconst gdFixed f = gd_itofx(k)-f_f;\n\t\t\t\t\tconst gdFixed f_fm1 = f - f_1;\n\t\t\t\t\tconst gdFixed f_fp1 = f + f_1;\n\t\t\t\t\tconst gdFixed f_fp2 = f + f_2;\n\t\t\t\t\tgdFixed f_a = 0, f_b = 0,f_c = 0, f_d = 0;\n\t\t\t\t\tgdFixed f_RY;\n\t\t\t\t\tint l;\n\n\t\t\t\t\tif (f_fp2 > 0) {\n\t\t\t\t\t\tf_a = gd_mulfx(f_fp2,gd_mulfx(f_fp2,f_fp2));\n\t\t\t\t\t}\n\n\t\t\t\t\tif (f_fp1 > 0) {\n\t\t\t\t\t\tf_b = gd_mulfx(f_fp1,gd_mulfx(f_fp1,f_fp1));\n\t\t\t\t\t}\n\n\t\t\t\t\tif (f > 0) {\n\t\t\t\t\t\tf_c = gd_mulfx(f,gd_mulfx(f,f));\n\t\t\t\t\t}\n\n\t\t\t\t\tif (f_fm1 > 0) {\n\t\t\t\t\t\tf_d = gd_mulfx(f_fm1,gd_mulfx(f_fm1,f_fm1));\n\t\t\t\t\t}\n\t\t\t\t\tf_RY = gd_divfx((f_a-gd_mulfx(f_4,f_b)+gd_mulfx(f_6,f_c)-gd_mulfx(f_4,f_d)),f_6);\n\n\t\t\t\t\tfor (l=-1;  l< 3; l++) {\n\t\t\t\t\t\tconst gdFixed f = gd_itofx(l) - f_g;\n\t\t\t\t\t\tconst gdFixed f_fm1 = f - f_1;\n\t\t\t\t\t\tconst gdFixed f_fp1 = f + f_1;\n\t\t\t\t\t\tconst gdFixed f_fp2 = f + f_2;\n\t\t\t\t\t\tgdFixed f_a = 0, f_b = 0, f_c = 0, f_d = 0;\n\t\t\t\t\t\tgdFixed f_RX, f_R;\n\t\t\t\t\t\tconst int _k = ((k + 1) * 4) + (l + 1);\n\t\t\t\t\t\tregister gdFixed f_rs, f_gs, f_bs, f_as;\n\t\t\t\t\t\tregister int c;\n\n\t\t\t\t\t\tif (f_fp2 > 0) {\n\t\t\t\t\t\t\tf_a = gd_mulfx(f_fp2,gd_mulfx(f_fp2,f_fp2));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (f_fp1 > 0) {\n\t\t\t\t\t\t\tf_b = gd_mulfx(f_fp1,gd_mulfx(f_fp1,f_fp1));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (f > 0) {\n\t\t\t\t\t\t\tf_c = gd_mulfx(f,gd_mulfx(f,f));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (f_fm1 > 0) {\n\t\t\t\t\t\t\tf_d = gd_mulfx(f_fm1,gd_mulfx(f_fm1,f_fm1));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tf_RX = gd_divfx((f_a - gd_mulfx(f_4, f_b) + gd_mulfx(f_6, f_c) - gd_mulfx(f_4, f_d)), f_6);\n\t\t\t\t\t\tf_R = gd_mulfx(f_RY, f_RX);\n\n\t\t\t\t\t\tif ((src_offset_x[_k] <= 0) || (src_offset_y[_k] <= 0) || (src_offset_y[_k] >= src_h) || (src_offset_x[_k] >= src_w)) {\n\t\t\t\t\t\t\tc = bgColor;\n\t\t\t\t\t\t} else if ((src_offset_x[_k] <= 1) || (src_offset_y[_k] <= 1) || (src_offset_y[_k] >= (int)src_h - 1) || (src_offset_x[_k] >= (int)src_w - 1)) {\n\t\t\t\t\t\t\tgdFixed f_127 = gd_itofx(127);\n\t\t\t\t\t\t\tc = src->tpixels[src_offset_y[_k]][src_offset_x[_k]];\n\t\t\t\t\t\t\tc = c | (( (int) (gd_fxtof(gd_mulfx(f_R, f_127)) + 50.5f)) << 24);\n\t\t\t\t\t\t\tc = _color_blend(bgColor, c);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tc = src->tpixels[src_offset_y[_k]][src_offset_x[_k]];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tf_rs = gd_itofx(gdTrueColorGetRed(c));\n\t\t\t\t\t\tf_gs = gd_itofx(gdTrueColorGetGreen(c));\n\t\t\t\t\t\tf_bs = gd_itofx(gdTrueColorGetBlue(c));\n\t\t\t\t\t\tf_as = gd_itofx(gdTrueColorGetAlpha(c));\n\n\t\t\t\t\t\tf_red   += gd_mulfx(f_rs, f_R);\n\t\t\t\t\t\tf_green += gd_mulfx(f_gs, f_R);\n\t\t\t\t\t\tf_blue  += gd_mulfx(f_bs, f_R);\n\t\t\t\t\t\tf_alpha += gd_mulfx(f_as, f_R);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tred   = (unsigned char) CLAMP(gd_fxtoi(gd_mulfx(f_red, f_gama)),   0, 255);\n\t\t\t\tgreen = (unsigned char) CLAMP(gd_fxtoi(gd_mulfx(f_green, f_gama)), 0, 255);\n\t\t\t\tblue  = (unsigned char) CLAMP(gd_fxtoi(gd_mulfx(f_blue, f_gama)),  0, 255);\n\t\t\t\talpha = (unsigned char) CLAMP(gd_fxtoi(gd_mulfx(f_alpha, f_gama)), 0, 127);\n\n\t\t\t\tdst->tpixels[dst_offset_y][dst_offset_x] =  gdTrueColorAlpha(red, green, blue, alpha);\n\t\t\t} else {\n\t\t\t\tdst->tpixels[dst_offset_y][dst_offset_x] =  bgColor;\n\t\t\t}\n\t\t\tdst_offset_x++;\n\t\t}\n\n\t\tdst_offset_y++;\n\t}\n\treturn dst;\n}\n\ngdImagePtr gdImageRotateInterpolated(const gdImagePtr src, const float angle, int bgcolor)\n{\n\tconst int angle_rounded = (int)floor(angle * 100);\n\n\tif (bgcolor < 0) {\n\t\treturn NULL;\n\t}\n\n\t/* impact perf a bit, but not that much. Implementation for palette\n\t   images can be done at a later point.\n\t*/\n\tif (src->trueColor == 0) {\n\t\tif (bgcolor < gdMaxColors) {\n\t\t\tbgcolor =  gdTrueColorAlpha(src->red[bgcolor], src->green[bgcolor], src->blue[bgcolor], src->alpha[bgcolor]);\n\t\t}\n\t\tgdImagePaletteToTrueColor(src);\n\t}\n\n\t/* no interpolation needed here */\n\tswitch (angle_rounded) {\n\t\tcase 9000:\n\t\t\treturn gdImageRotate90(src, 0);\n\t\tcase 18000:\n\t\t\treturn gdImageRotate180(src, 0);\n\t\tcase 27000:\n\t\t\treturn gdImageRotate270(src, 0);\n\t}\n\n\tif (src == NULL || src->interpolation_id < 1 || src->interpolation_id > GD_METHOD_COUNT) {\n\t\treturn NULL;\n\t}\n\n\tswitch (src->interpolation_id) {\n\t\tcase GD_NEAREST_NEIGHBOUR:\n\t\t\treturn gdImageRotateNearestNeighbour(src, angle, bgcolor);\n\t\t\tbreak;\n\n\t\tcase GD_BILINEAR_FIXED:\n\t\t\treturn gdImageRotateBilinear(src, angle, bgcolor);\n\t\t\tbreak;\n\n\t\tcase GD_BICUBIC_FIXED:\n\t\t\treturn gdImageRotateBicubicFixed(src, angle, bgcolor);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn gdImageRotateGeneric(src, angle, bgcolor);\n\t}\n\treturn NULL;\n}\n\n/**\n * Title: Affine transformation\n **/\n\n/**\n * Group: Transform\n **/\n\n static void gdImageClipRectangle(gdImagePtr im, gdRectPtr r)\n{\n\tint c1x, c1y, c2x, c2y;\n\tint x1,y1;\n\n\tgdImageGetClip(im, &c1x, &c1y, &c2x, &c2y);\n\tx1 = r->x + r->width - 1;\n\ty1 = r->y + r->height - 1;\n\tr->x = CLAMP(r->x, c1x, c2x);\n\tr->y = CLAMP(r->y, c1y, c2y);\n\tr->width = CLAMP(x1, c1x, c2x) - r->x + 1;\n\tr->height = CLAMP(y1, c1y, c2y) - r->y + 1;\n}\n\nvoid gdDumpRect(const char *msg, gdRectPtr r)\n{\n\tprintf(\"%s (%i, %i) (%i, %i)\\n\", msg, r->x, r->y, r->width, r->height);\n}\n\n/**\n * Function: gdTransformAffineGetImage\n *  Applies an affine transformation to a region and return an image\n *  containing the complete transformation.\n *\n * Parameters:\n * \tdst - Pointer to a gdImagePtr to store the created image, NULL when\n *        the creation or the transformation failed\n *  src - Source image\n *  src_area - rectangle defining the source region to transform\n *  dstY - Y position in the destination image\n *  affine - The desired affine transformation\n *\n * Returns:\n *  GD_TRUE if the affine is rectilinear or GD_FALSE\n */\nint gdTransformAffineGetImage(gdImagePtr *dst,\n\t\t  const gdImagePtr src,\n\t\t  gdRectPtr src_area,\n\t\t  const double affine[6])\n{\n\tint res;\n\tdouble m[6];\n\tgdRect bbox;\n\tgdRect area_full;\n\n\tif (src_area == NULL) {\n\t\tarea_full.x = 0;\n\t\tarea_full.y = 0;\n\t\tarea_full.width  = gdImageSX(src);\n\t\tarea_full.height = gdImageSY(src);\n\t\tsrc_area = &area_full;\n\t}\n\n\tgdTransformAffineBoundingBox(src_area, affine, &bbox);\n\n\t*dst = gdImageCreateTrueColor(bbox.width, bbox.height);\n\tif (*dst == NULL) {\n\t\treturn GD_FALSE;\n\t}\n\t(*dst)->saveAlphaFlag = 1;\n\n\tif (!src->trueColor) {\n\t\tgdImagePaletteToTrueColor(src);\n\t}\n\n\t/* Translate to dst origin (0,0) */\n\tgdAffineTranslate(m, -bbox.x, -bbox.y);\n\tgdAffineConcat(m, affine, m);\n\n\tgdImageAlphaBlending(*dst, 0);\n\n\tres = gdTransformAffineCopy(*dst,\n\t\t  0,0,\n\t\t  src,\n\t\t  src_area,\n\t\t  m);\n\n\tif (res != GD_TRUE) {\n\t\tgdImageDestroy(*dst);\n\t\tdst = NULL;\n\t\treturn GD_FALSE;\n\t} else {\n\t\treturn GD_TRUE;\n\t}\n}\n\n/**\n * Function: gdTransformAffineCopy\n *  Applies an affine transformation to a region and copy the result\n *  in a destination to the given position.\n *\n * Parameters:\n * \tdst - Image to draw the transformed image\n *  src - Source image\n *  dstX - X position in the destination image\n *  dstY - Y position in the destination image\n *  src_area - Rectangular region to rotate in the src image\n *\n * Returns:\n *  GD_TRUE if the affine is rectilinear or GD_FALSE\n */\nint gdTransformAffineCopy(gdImagePtr dst,\n\t\t  int dst_x, int dst_y,\n\t\t  const gdImagePtr src,\n\t\t  gdRectPtr src_region,\n\t\t  const double affine[6])\n{\n\tint c1x,c1y,c2x,c2y;\n\tint backclip = 0;\n\tint backup_clipx1, backup_clipy1, backup_clipx2, backup_clipy2;\n\tregister int x, y, src_offset_x, src_offset_y;\n\tdouble inv[6];\n\tint *dst_p;\n\tgdPointF pt, src_pt;\n\tgdRect bbox;\n\tint end_x, end_y;\n\tgdInterpolationMethod interpolation_id_bak = GD_DEFAULT;\n\tinterpolation_method interpolation_bak;\n\n\t/* These methods use special implementations */\n\tif (src->interpolation_id == GD_BILINEAR_FIXED || src->interpolation_id == GD_BICUBIC_FIXED || src->interpolation_id == GD_NEAREST_NEIGHBOUR) {\n\t\tinterpolation_id_bak = src->interpolation_id;\n\t\tinterpolation_bak = src->interpolation;\n\n\t\tgdImageSetInterpolationMethod(src, GD_BICUBIC);\n\t}\n\n\n\tgdImageClipRectangle(src, src_region);\n\n\tif (src_region->x > 0 || src_region->y > 0\n\t\t|| src_region->width < gdImageSX(src)\n\t\t|| src_region->height < gdImageSY(src)) {\n\t\tbackclip = 1;\n\n\t\tgdImageGetClip(src, &backup_clipx1, &backup_clipy1,\n\t\t&backup_clipx2, &backup_clipy2);\n\n\t\tgdImageSetClip(src, src_region->x, src_region->y,\n\t\t\tsrc_region->x + src_region->width - 1,\n\t\t\tsrc_region->y + src_region->height - 1);\n\t}\n\n\tif (!gdTransformAffineBoundingBox(src_region, affine, &bbox)) {\n\t\tif (backclip) {\n\t\t\tgdImageSetClip(src, backup_clipx1, backup_clipy1,\n\t\t\t\t\tbackup_clipx2, backup_clipy2);\n\t\t}\n\t\tgdImageSetInterpolationMethod(src, interpolation_id_bak);\n\t\treturn GD_FALSE;\n\t}\n\n\tgdImageGetClip(dst, &c1x, &c1y, &c2x, &c2y);\n\n\tend_x = bbox.width  + (int) fabs(bbox.x);\n\tend_y = bbox.height + (int) fabs(bbox.y);\n\n\t/* Get inverse affine to let us work with destination -> source */\n\tgdAffineInvert(inv, affine);\n\n\tsrc_offset_x =  src_region->x;\n\tsrc_offset_y =  src_region->y;\n\n\tif (dst->alphaBlendingFlag) {\n\t\tfor (y = bbox.y; y <= end_y; y++) {\n\t\t\tpt.y = y + 0.5;\n\t\t\tfor (x = 0; x <= end_x; x++) {\n\t\t\t\tpt.x = x + 0.5;\n\t\t\t\tgdAffineApplyToPointF(&src_pt, &pt, inv);\n\t\t\t\tgdImageSetPixel(dst, dst_x + x, dst_y + y, getPixelInterpolated(src, src_offset_x + src_pt.x, src_offset_y + src_pt.y, 0));\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (y = 0; y <= end_y; y++) {\n\t\t\tpt.y = y + 0.5 + bbox.y;\n\t\t\tif ((dst_y + y) < 0 || ((dst_y + y) > gdImageSY(dst) -1)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdst_p = dst->tpixels[dst_y + y] + dst_x;\n\n\t\t\tfor (x = 0; x <= end_x; x++) {\n\t\t\t\tpt.x = x + 0.5 + bbox.x;\n\t\t\t\tgdAffineApplyToPointF(&src_pt, &pt, inv);\n\n\t\t\t\tif ((dst_x + x) < 0 || (dst_x + x) > (gdImageSX(dst) - 1)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t*(dst_p++) = getPixelInterpolated(src, src_offset_x + src_pt.x, src_offset_y + src_pt.y, -1);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Restore clip if required */\n\tif (backclip) {\n\t\tgdImageSetClip(src, backup_clipx1, backup_clipy1,\n\t\t\t\tbackup_clipx2, backup_clipy2);\n\t}\n\n\tgdImageSetInterpolationMethod(src, interpolation_id_bak);\n\treturn GD_TRUE;\n}\n\n/**\n * Function: gdTransformAffineBoundingBox\n *  Returns the bounding box of an affine transformation applied to a\n *  rectangular area <gdRect>\n *\n * Parameters:\n * \tsrc - Rectangular source area for the affine transformation\n *  affine - the affine transformation\n *  bbox - the resulting bounding box\n *\n * Returns:\n *  GD_TRUE if the affine is rectilinear or GD_FALSE\n */\nint gdTransformAffineBoundingBox(gdRectPtr src, const double affine[6], gdRectPtr bbox)\n{\n\tgdPointF extent[4], min, max, point;\n\tint i;\n\n\textent[0].x=0.0;\n\textent[0].y=0.0;\n\textent[1].x=(double) src->width;\n\textent[1].y=0.0;\n\textent[2].x=(double) src->width;\n\textent[2].y=(double) src->height;\n\textent[3].x=0.0;\n\textent[3].y=(double) src->height;\n\n\tfor (i=0; i < 4; i++) {\n\t\tpoint=extent[i];\n\t\tif (gdAffineApplyToPointF(&extent[i], &point, affine) != GD_TRUE) {\n\t\t\treturn GD_FALSE;\n\t\t}\n\t}\n\tmin=extent[0];\n\tmax=extent[0];\n\n\tfor (i=1; i < 4; i++) {\n\t\tif (min.x > extent[i].x)\n\t\t\tmin.x=extent[i].x;\n\t\tif (min.y > extent[i].y)\n\t\t\tmin.y=extent[i].y;\n\t\tif (max.x < extent[i].x)\n\t\t\tmax.x=extent[i].x;\n\t\tif (max.y < extent[i].y)\n\t\t\tmax.y=extent[i].y;\n\t}\n\tbbox->x = (int) min.x;\n\tbbox->y = (int) min.y;\n\tbbox->width  = (int) floor(max.x - min.x) - 1;\n\tbbox->height = (int) floor(max.y - min.y);\n\treturn GD_TRUE;\n}\n\nint gdImageSetInterpolationMethod(gdImagePtr im, gdInterpolationMethod id)\n{\n\tif (im == NULL || id < 0 || id > GD_METHOD_COUNT) {\n\t\treturn 0;\n\t}\n\n\tswitch (id) {\n\t\tcase GD_DEFAULT:\n\t\t\tid = GD_BILINEAR_FIXED;\n\t\t/* Optimized versions */\n\t\tcase GD_BILINEAR_FIXED:\n\t\tcase GD_BICUBIC_FIXED:\n\t\tcase GD_NEAREST_NEIGHBOUR:\n\t\tcase GD_WEIGHTED4:\n\t\t\tim->interpolation = NULL;\n\t\t\tbreak;\n\n\t\t/* generic versions*/\n\t\tcase GD_BELL:\n\t\t\tim->interpolation = filter_bell;\n\t\t\tbreak;\n\t\tcase GD_BESSEL:\n\t\t\tim->interpolation = filter_bessel;\n\t\t\tbreak;\n\t\tcase GD_BICUBIC:\n\t\t\tim->interpolation = filter_bicubic;\n\t\t\tbreak;\n\t\tcase GD_BLACKMAN:\n\t\t\tim->interpolation = filter_blackman;\n\t\t\tbreak;\n\t\tcase GD_BOX:\n\t\t\tim->interpolation = filter_box;\n\t\t\tbreak;\n\t\tcase GD_BSPLINE:\n\t\t\tim->interpolation = filter_bspline;\n\t\t\tbreak;\n\t\tcase GD_CATMULLROM:\n\t\t\tim->interpolation = filter_catmullrom;\n\t\t\tbreak;\n\t\tcase GD_GAUSSIAN:\n\t\t\tim->interpolation = filter_gaussian;\n\t\t\tbreak;\n\t\tcase GD_GENERALIZED_CUBIC:\n\t\t\tim->interpolation = filter_generalized_cubic;\n\t\t\tbreak;\n\t\tcase GD_HERMITE:\n\t\t\tim->interpolation = filter_hermite;\n\t\t\tbreak;\n\t\tcase GD_HAMMING:\n\t\t\tim->interpolation = filter_hamming;\n\t\t\tbreak;\n\t\tcase GD_HANNING:\n\t\t\tim->interpolation = filter_hanning;\n\t\t\tbreak;\n\t\tcase GD_MITCHELL:\n\t\t\tim->interpolation = filter_mitchell;\n\t\t\tbreak;\n\t\tcase GD_POWER:\n\t\t\tim->interpolation = filter_power;\n\t\t\tbreak;\n\t\tcase GD_QUADRATIC:\n\t\t\tim->interpolation = filter_quadratic;\n\t\t\tbreak;\n\t\tcase GD_SINC:\n\t\t\tim->interpolation = filter_sinc;\n\t\t\tbreak;\n\t\tcase GD_TRIANGLE:\n\t\t\tim->interpolation = filter_triangle;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn 0;\n\t\t\tbreak;\n\t}\n\tim->interpolation_id = id;\n\treturn 1;\n}\n\n#ifdef _MSC_VER\n# pragma optimize(\"\", on)\n#endif\n", "code_before": "/*\n * The two pass scaling function is based on:\n * Filtered Image Rescaling\n * Based on Gems III\n *  - Schumacher general filtered image rescaling\n * (pp. 414-424)\n * by Dale Schumacher\n *\n * \tAdditional changes by Ray Gardener, Daylon Graphics Ltd.\n * \tDecember 4, 1999\n *\n * \tPorted to libgd by Pierre Joye. Support for multiple channels\n * \tadded (argb for now).\n *\n * \tInitial sources code is avaibable in the Gems Source Code Packages:\n * \thttp://www.acm.org/pubs/tog/GraphicsGems/GGemsIII.tar.gz\n *\n */\n\n/*\n\tSummary:\n\n\t\t- Horizontal filter contributions are calculated on the fly,\n\t\t  as each column is mapped from src to dst image. This lets\n\t\t  us omit having to allocate a temporary full horizontal stretch\n\t\t  of the src image.\n\n\t\t- If none of the src pixels within a sampling region differ,\n\t\t  then the output pixel is forced to equal (any of) the source pixel.\n\t\t  This ensures that filters do not corrupt areas of constant color.\n\n\t\t- Filter weight contribution results, after summing, are\n\t\t  rounded to the nearest pixel color value instead of\n\t\t  being casted to ILubyte (usually an int or char). Otherwise,\n\t\t  artifacting occurs.\n\n*/\n\n/*\n\tAdditional functions are available for simple rotation or up/downscaling.\n\tdownscaling using the fixed point implementations are usually much faster\n\tthan the existing gdImageCopyResampled while having a similar or better\n\tquality.\n\n\tFor image rotations, the optimized versions have a lazy antialiasing for\n\tthe edges of the images. For a much better antialiased result, the affine\n\tfunction is recommended.\n*/\n\n/*\nTODO:\n - Optimize pixel accesses and loops once we have continuous buffer\n - Add scale support for a portion only of an image (equivalent of copyresized/resampled)\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n\n#include \"gd.h\"\n#include \"gdhelpers.h\"\n#include \"gd_intern.h\"\n\n#ifdef _MSC_VER\n# pragma optimize(\"t\", on)\n# include <emmintrin.h>\n#endif\n\nstatic gdImagePtr gdImageScaleBilinear(gdImagePtr im,\n                                       const unsigned int new_width,\n                                       const unsigned int new_height);\nstatic gdImagePtr gdImageScaleBicubicFixed(gdImagePtr src,\n                                           const unsigned int width,\n                                           const unsigned int height);\nstatic gdImagePtr gdImageScaleNearestNeighbour(gdImagePtr im,\n                                               const unsigned int width, const unsigned int height);\nstatic gdImagePtr gdImageScaleTwoPass(const gdImagePtr pOrigImage,\n                                      const unsigned int uOrigWidth,\n                                      const unsigned int uOrigHeight,\n                                      const unsigned int uNewWidth,\n                                      const unsigned int uNewHeight);\nstatic gdImagePtr gdImageRotateNearestNeighbour(gdImagePtr src,\n                                                const float degrees,\n                                                const int bgColor);\nstatic gdImagePtr gdImageRotateGeneric(gdImagePtr src,\n                                       const float degrees,\n                                       const int bgColor);\n\n/* only used here, let do a generic fixed point integers later if required by other\n   part of GD */\ntypedef long gdFixed;\n/* Integer to fixed point */\n#define gd_itofx(x) (long)((unsigned long)(x) << 8)\n\n/* Float to fixed point */\n#define gd_ftofx(x) (long)((x) * 256)\n\n/*  Double to fixed point */\n#define gd_dtofx(x) (long)((x) * 256)\n\n/* Fixed point to integer */\n#define gd_fxtoi(x) ((x) >> 8)\n\n/* Fixed point to float */\n# define gd_fxtof(x) ((float)(x) / 256)\n\n/* Fixed point to double */\n#define gd_fxtod(x) ((double)(x) / 256)\n\n/* Multiply a fixed by a fixed */\n#define gd_mulfx(x,y) (((x) * (y)) >> 8)\n\n/* Divide a fixed by a fixed */\n#define gd_divfx(x,y) ((long)((unsigned long)(x) << 8) / (y))\n\ntypedef struct\n{\n   double *Weights;  /* Normalized weights of neighboring pixels */\n   int Left,Right;   /* Bounds of source pixels window */\n} ContributionType;  /* Contirbution information for a single pixel */\n\ntypedef struct\n{\n   ContributionType *ContribRow; /* Row (or column) of contribution weights */\n   unsigned int WindowSize,      /* Filter window size (of affecting source pixels) */\n\t\t\t\tLineLength;      /* Length of line (no. or rows / cols) */\n} LineContribType;\n\n/* Each core filter has its own radius */\n#define DEFAULT_FILTER_LINEAR \t\t\t\t1.0f\n#define DEFAULT_FILTER_BICUBIC\t\t\t\t3.0f\n#define DEFAULT_FILTER_BOX\t\t\t\t\t0.5f\n#define DEFAULT_FILTER_GENERALIZED_CUBIC\t0.5f\n#define DEFAULT_FILTER_RADIUS\t\t\t\t1.0f\n#define DEFAULT_LANCZOS8_RADIUS\t\t\t\t8.0f\n#define DEFAULT_LANCZOS3_RADIUS\t\t\t\t3.0f\n#define DEFAULT_HERMITE_RADIUS\t\t\t\t1.0f\n#define DEFAULT_BOX_RADIUS\t\t\t\t\t0.5f\n#define DEFAULT_TRIANGLE_RADIUS\t\t\t\t1.0f\n#define DEFAULT_BELL_RADIUS\t\t\t\t\t1.5f\n#define DEFAULT_CUBICSPLINE_RADIUS\t\t\t2.0f\n#define DEFAULT_MITCHELL_RADIUS\t\t\t\t2.0f\n#define DEFAULT_COSINE_RADIUS\t\t\t\t1.0f\n#define DEFAULT_CATMULLROM_RADIUS\t\t\t2.0f\n#define DEFAULT_QUADRATIC_RADIUS\t\t\t1.5f\n#define DEFAULT_QUADRATICBSPLINE_RADIUS\t\t1.5f\n#define DEFAULT_CUBICCONVOLUTION_RADIUS\t\t3.0f\n#define DEFAULT_GAUSSIAN_RADIUS\t\t\t\t1.0f\n#define DEFAULT_HANNING_RADIUS\t\t\t\t1.0f\n#define DEFAULT_HAMMING_RADIUS\t\t\t\t1.0f\n#define DEFAULT_SINC_RADIUS\t\t\t\t\t1.0f\n#define DEFAULT_WELSH_RADIUS\t\t\t\t1.0f\n\nenum GD_RESIZE_FILTER_TYPE{\n\tFILTER_DEFAULT          = 0,\n\tFILTER_BELL,\n\tFILTER_BESSEL,\n\tFILTER_BLACKMAN,\n\tFILTER_BOX,\n\tFILTER_BSPLINE,\n\tFILTER_CATMULLROM,\n\tFILTER_COSINE,\n\tFILTER_CUBICCONVOLUTION,\n\tFILTER_CUBICSPLINE,\n\tFILTER_HERMITE,\n\tFILTER_LANCZOS3,\n\tFILTER_LANCZOS8,\n\tFILTER_MITCHELL,\n\tFILTER_QUADRATIC,\n\tFILTER_QUADRATICBSPLINE,\n\tFILTER_TRIANGLE,\n\tFILTER_GAUSSIAN,\n\tFILTER_HANNING,\n\tFILTER_HAMMING,\n\tFILTER_SINC,\n\tFILTER_WELSH,\n\n\tFILTER_CALLBACK        = 999\n};\n\ntypedef enum GD_RESIZE_FILTER_TYPE gdResizeFilterType;\n\nstatic double KernelBessel_J1(const double x)\n{\n\tdouble p, q;\n\n\tregister long i;\n\n\tstatic const double\n\tPone[] =\n\t{\n\t\t0.581199354001606143928050809e+21,\n\t\t-0.6672106568924916298020941484e+20,\n\t\t0.2316433580634002297931815435e+19,\n\t\t-0.3588817569910106050743641413e+17,\n\t\t0.2908795263834775409737601689e+15,\n\t\t-0.1322983480332126453125473247e+13,\n\t\t0.3413234182301700539091292655e+10,\n\t\t-0.4695753530642995859767162166e+7,\n\t\t0.270112271089232341485679099e+4\n\t},\n\tQone[] =\n\t{\n\t\t0.11623987080032122878585294e+22,\n\t\t0.1185770712190320999837113348e+20,\n\t\t0.6092061398917521746105196863e+17,\n\t\t0.2081661221307607351240184229e+15,\n\t\t0.5243710262167649715406728642e+12,\n\t\t0.1013863514358673989967045588e+10,\n\t\t0.1501793594998585505921097578e+7,\n\t\t0.1606931573481487801970916749e+4,\n\t\t0.1e+1\n\t};\n\n\tp = Pone[8];\n\tq = Qone[8];\n\tfor (i=7; i >= 0; i--)\n\t{\n\t\tp = p*x*x+Pone[i];\n\t\tq = q*x*x+Qone[i];\n\t}\n\treturn (double)(p/q);\n}\n\nstatic double KernelBessel_P1(const double x)\n{\n\tdouble p, q;\n\n\tregister long i;\n\n\tstatic const double\n\tPone[] =\n\t{\n\t\t0.352246649133679798341724373e+5,\n\t\t0.62758845247161281269005675e+5,\n\t\t0.313539631109159574238669888e+5,\n\t\t0.49854832060594338434500455e+4,\n\t\t0.2111529182853962382105718e+3,\n\t\t0.12571716929145341558495e+1\n\t},\n\tQone[] =\n\t{\n\t\t0.352246649133679798068390431e+5,\n\t\t0.626943469593560511888833731e+5,\n\t\t0.312404063819041039923015703e+5,\n\t\t0.4930396490181088979386097e+4,\n\t\t0.2030775189134759322293574e+3,\n\t\t0.1e+1\n\t};\n\n\tp = Pone[5];\n\tq = Qone[5];\n\tfor (i=4; i >= 0; i--)\n\t{\n\t\tp = p*(8.0/x)*(8.0/x)+Pone[i];\n\t\tq = q*(8.0/x)*(8.0/x)+Qone[i];\n\t}\n\treturn (double)(p/q);\n}\n\nstatic double KernelBessel_Q1(const double x)\n{\n\tdouble p, q;\n\n\tregister long i;\n\n\tstatic const double\n\tPone[] =\n\t{\n\t\t0.3511751914303552822533318e+3,\n\t\t0.7210391804904475039280863e+3,\n\t\t0.4259873011654442389886993e+3,\n\t\t0.831898957673850827325226e+2,\n\t\t0.45681716295512267064405e+1,\n\t\t0.3532840052740123642735e-1\n\t},\n\tQone[] =\n\t{\n\t\t0.74917374171809127714519505e+4,\n\t\t0.154141773392650970499848051e+5,\n\t\t0.91522317015169922705904727e+4,\n\t\t0.18111867005523513506724158e+4,\n\t\t0.1038187585462133728776636e+3,\n\t\t0.1e+1\n\t};\n\n\tp = Pone[5];\n\tq = Qone[5];\n\tfor (i=4; i >= 0; i--)\n\t{\n\t\tp = p*(8.0/x)*(8.0/x)+Pone[i];\n\t\tq = q*(8.0/x)*(8.0/x)+Qone[i];\n\t}\n\treturn (double)(p/q);\n}\n\nstatic double KernelBessel_Order1(double x)\n{\n\tdouble p, q;\n\n\tif (x == 0.0)\n\t\treturn (0.0f);\n\tp = x;\n\tif (x < 0.0)\n\t\tx=(-x);\n\tif (x < 8.0)\n\t\treturn (p*KernelBessel_J1(x));\n\tq = (double)sqrt(2.0f/(M_PI*x))*(double)(KernelBessel_P1(x)*(1.0f/sqrt(2.0f)*(sin(x)-cos(x)))-8.0f/x*KernelBessel_Q1(x)*\n\t\t(-1.0f/sqrt(2.0f)*(sin(x)+cos(x))));\n\tif (p < 0.0f)\n\t\tq = (-q);\n\treturn (q);\n}\n\nstatic double filter_bessel(const double x)\n{\n\tif (x == 0.0f)\n\t\treturn (double)(M_PI/4.0f);\n\treturn (KernelBessel_Order1((double)M_PI*x)/(2.0f*x));\n}\n\n\nstatic double filter_blackman(const double x)\n{\n\treturn (0.42f+0.5f*(double)cos(M_PI*x)+0.08f*(double)cos(2.0f*M_PI*x));\n}\n\ndouble filter_linear(const double x) {\n\tdouble ax = fabs(x);\n\tif (ax < 1.0f) {\n\t\treturn (1.0f - ax);\n\t}\n\treturn 0.0f;\n}\n\n/**\n * Bicubic interpolation kernel (a=-1):\n  \\verbatim\n          /\n         | 1-2|t|**2+|t|**3          , if |t| < 1\n  h(t) = | 4-8|t|+5|t|**2-|t|**3     , if 1<=|t|<2\n         | 0                         , otherwise\n          \\\n  \\endverbatim\n * ***bd*** 2.2004\n */\nstatic double filter_bicubic(const double t)\n{\n  const double abs_t = (double)fabs(t);\n  const double abs_t_sq = abs_t * abs_t;\n  if (abs_t<1) return 1-2*abs_t_sq+abs_t_sq*abs_t;\n  if (abs_t<2) return 4 - 8*abs_t +5*abs_t_sq - abs_t_sq*abs_t;\n  return 0;\n}\n\n/**\n * Generalized cubic kernel (for a=-1 it is the same as BicubicKernel):\n  \\verbatim\n          /\n         | (a+2)|t|**3 - (a+3)|t|**2 + 1     , |t| <= 1\n  h(t) = | a|t|**3 - 5a|t|**2 + 8a|t| - 4a   , 1 < |t| <= 2\n         | 0                                 , otherwise\n          \\\n  \\endverbatim\n * Often used values for a are -1 and -1/2.\n */\nstatic double filter_generalized_cubic(const double t)\n{\n\tconst double a = -DEFAULT_FILTER_GENERALIZED_CUBIC;\n\tdouble abs_t = (double)fabs(t);\n\tdouble abs_t_sq = abs_t * abs_t;\n\tif (abs_t < 1) return (a + 2) * abs_t_sq * abs_t - (a + 3) * abs_t_sq + 1;\n\tif (abs_t < 2) return a * abs_t_sq * abs_t - 5 * a * abs_t_sq + 8 * a * abs_t - 4 * a;\n\treturn 0;\n}\n\n#ifdef FUNCTION_NOT_USED_YET\n/* CubicSpline filter, default radius 2 */\nstatic double filter_cubic_spline(const double x1)\n{\n\tconst double x = x1 < 0.0 ? -x1 : x1;\n\n\tif (x < 1.0 ) {\n\t\tconst double x2 = x*x;\n\n\t\treturn (0.5 * x2 * x - x2 + 2.0 / 3.0);\n\t}\n\tif (x < 2.0) {\n\t\treturn (pow(2.0 - x, 3.0)/6.0);\n\t}\n\treturn 0;\n}\n#endif\n\n#ifdef FUNCTION_NOT_USED_YET\n/* CubicConvolution filter, default radius 3 */\nstatic double filter_cubic_convolution(const double x1)\n{\n\tconst double x = x1 < 0.0 ? -x1 : x1;\n\tconst double x2 = x1 * x1;\n\tconst double x2_x = x2 * x;\n\n\tif (x <= 1.0) return ((4.0 / 3.0)* x2_x - (7.0 / 3.0) * x2 + 1.0);\n\tif (x <= 2.0) return (- (7.0 / 12.0) * x2_x + 3 * x2 - (59.0 / 12.0) * x + 2.5);\n\tif (x <= 3.0) return ( (1.0/12.0) * x2_x - (2.0 / 3.0) * x2 + 1.75 * x - 1.5);\n\treturn 0;\n}\n#endif\n\nstatic double filter_box(double x) {\n\tif (x < - DEFAULT_FILTER_BOX)\n\t\treturn 0.0f;\n\tif (x < DEFAULT_FILTER_BOX)\n\t\treturn 1.0f;\n\treturn 0.0f;\n}\n\nstatic double filter_catmullrom(const double x)\n{\n\tif (x < -2.0)\n\t\treturn(0.0f);\n\tif (x < -1.0)\n\t\treturn(0.5f*(4.0f+x*(8.0f+x*(5.0f+x))));\n\tif (x < 0.0)\n\t\treturn(0.5f*(2.0f+x*x*(-5.0f-3.0f*x)));\n\tif (x < 1.0)\n\t\treturn(0.5f*(2.0f+x*x*(-5.0f+3.0f*x)));\n\tif (x < 2.0)\n\t\treturn(0.5f*(4.0f+x*(-8.0f+x*(5.0f-x))));\n\treturn(0.0f);\n}\n\n#ifdef FUNCTION_NOT_USED_YET\nstatic double filter_filter(double t)\n{\n\t/* f(t) = 2|t|^3 - 3|t|^2 + 1, -1 <= t <= 1 */\n\tif(t < 0.0) t = -t;\n\tif(t < 1.0) return((2.0 * t - 3.0) * t * t + 1.0);\n\treturn(0.0);\n}\n#endif\n\n#ifdef FUNCTION_NOT_USED_YET\n/* Lanczos8 filter, default radius 8 */\nstatic double filter_lanczos8(const double x1)\n{\n\tconst double x = x1 < 0.0 ? -x1 : x1;\n#define R DEFAULT_LANCZOS8_RADIUS\n\n\tif ( x == 0.0) return 1;\n\n\tif ( x < R) {\n\t\treturn R * sin(x*M_PI) * sin(x * M_PI/ R) / (x * M_PI * x * M_PI);\n\t}\n\treturn 0.0;\n#undef R\n}\n#endif\n\n#ifdef FUNCTION_NOT_USED_YET\n/* Lanczos3 filter, default radius 3 */\nstatic double filter_lanczos3(const double x1)\n{\n\tconst double x = x1 < 0.0 ? -x1 : x1;\n#define R DEFAULT_LANCZOS3_RADIUS\n\n\tif ( x == 0.0) return 1;\n\n\tif ( x < R)\n\t{\n\t\treturn R * sin(x*M_PI) * sin(x * M_PI / R) / (x * M_PI * x * M_PI);\n\t}\n\treturn 0.0;\n#undef R\n}\n#endif\n\n/* Hermite filter, default radius 1 */\nstatic double filter_hermite(const double x1)\n{\n\tconst double x = x1 < 0.0 ? -x1 : x1;\n\n\tif (x < 1.0) return ((2.0 * x - 3) * x * x + 1.0 );\n\n\treturn 0.0;\n}\n\n/* Trangle filter, default radius 1 */\nstatic double filter_triangle(const double x1)\n{\n\tconst double x = x1 < 0.0 ? -x1 : x1;\n\tif (x < 1.0) return (1.0 - x);\n\treturn 0.0;\n}\n\n/* Bell filter, default radius 1.5 */\nstatic double filter_bell(const double x1)\n{\n\tconst double x = x1 < 0.0 ? -x1 : x1;\n\n\tif (x < 0.5) return (0.75 - x*x);\n\tif (x < 1.5) return (0.5 * pow(x - 1.5, 2.0));\n\treturn 0.0;\n}\n\n/* Mitchell filter, default radius 2.0 */\nstatic double filter_mitchell(const double x)\n{\n#define KM_B (1.0f/3.0f)\n#define KM_C (1.0f/3.0f)\n#define KM_P0 ((  6.0f - 2.0f * KM_B ) / 6.0f)\n#define KM_P2 ((-18.0f + 12.0f * KM_B + 6.0f * KM_C) / 6.0f)\n#define KM_P3 (( 12.0f - 9.0f  * KM_B - 6.0f * KM_C) / 6.0f)\n#define KM_Q0 ((  8.0f * KM_B + 24.0f * KM_C) / 6.0f)\n#define KM_Q1 ((-12.0f * KM_B - 48.0f * KM_C) / 6.0f)\n#define KM_Q2 ((  6.0f * KM_B + 30.0f * KM_C) / 6.0f)\n#define KM_Q3 (( -1.0f * KM_B -  6.0f * KM_C) / 6.0f)\n\n\tif (x < -2.0)\n\t\treturn(0.0f);\n\tif (x < -1.0)\n\t\treturn(KM_Q0-x*(KM_Q1-x*(KM_Q2-x*KM_Q3)));\n\tif (x < 0.0f)\n\t\treturn(KM_P0+x*x*(KM_P2-x*KM_P3));\n\tif (x < 1.0f)\n\t\treturn(KM_P0+x*x*(KM_P2+x*KM_P3));\n\tif (x < 2.0f)\n\t\treturn(KM_Q0+x*(KM_Q1+x*(KM_Q2+x*KM_Q3)));\n\treturn(0.0f);\n}\n\n\n\n#ifdef FUNCTION_NOT_USED_YET\n/* Cosine filter, default radius 1 */\nstatic double filter_cosine(const double x)\n{\n\tif ((x >= -1.0) && (x <= 1.0)) return ((cos(x * M_PI) + 1.0)/2.0);\n\n\treturn 0;\n}\n#endif\n\n/* Quadratic filter, default radius 1.5 */\nstatic double filter_quadratic(const double x1)\n{\n\tconst double x = x1 < 0.0 ? -x1 : x1;\n\n\tif (x <= 0.5) return (- 2.0 * x * x + 1);\n\tif (x <= 1.5) return (x * x - 2.5* x + 1.5);\n\treturn 0.0;\n}\n\nstatic double filter_bspline(const double x)\n{\n\tif (x>2.0f) {\n\t\treturn 0.0f;\n\t} else {\n\t\tdouble a, b, c, d;\n\t\t/* Was calculated anyway cause the \"if((x-1.0f) < 0)\" */\n\t\tconst double xm1 = x - 1.0f;\n\t\tconst double xp1 = x + 1.0f;\n\t\tconst double xp2 = x + 2.0f;\n\n\t\tif ((xp2) <= 0.0f) a = 0.0f; else a = xp2*xp2*xp2;\n\t\tif ((xp1) <= 0.0f) b = 0.0f; else b = xp1*xp1*xp1;\n\t\tif (x <= 0) c = 0.0f; else c = x*x*x;\n\t\tif ((xm1) <= 0.0f) d = 0.0f; else d = xm1*xm1*xm1;\n\n\t\treturn (0.16666666666666666667f * (a - (4.0f * b) + (6.0f * c) - (4.0f * d)));\n\t}\n}\n\n#ifdef FUNCTION_NOT_USED_YET\n/* QuadraticBSpline filter, default radius 1.5 */\nstatic double filter_quadratic_bspline(const double x1)\n{\n\tconst double x = x1 < 0.0 ? -x1 : x1;\n\n\tif (x <= 0.5) return (- x * x + 0.75);\n\tif (x <= 1.5) return (0.5 * x * x - 1.5 * x + 1.125);\n\treturn 0.0;\n}\n#endif\n\nstatic double filter_gaussian(const double x)\n{\n\t/* return(exp((double) (-2.0 * x * x)) * sqrt(2.0 / M_PI)); */\n\treturn (double)(exp(-2.0f * x * x) * 0.79788456080287f);\n}\n\nstatic double filter_hanning(const double x)\n{\n\t/* A Cosine windowing function */\n\treturn(0.5 + 0.5 * cos(M_PI * x));\n}\n\nstatic double filter_hamming(const double x)\n{\n\t/* should be\n\t(0.54+0.46*cos(M_PI*(double) x));\n\tbut this approximation is sufficient */\n\tif (x < -1.0f)\n\t\treturn 0.0f;\n\tif (x < 0.0f)\n\t\treturn 0.92f*(-2.0f*x-3.0f)*x*x+1.0f;\n\tif (x < 1.0f)\n\t\treturn 0.92f*(2.0f*x-3.0f)*x*x+1.0f;\n\treturn 0.0f;\n}\n\nstatic double filter_power(const double x)\n{\n\tconst double a = 2.0f;\n\tif (fabs(x)>1) return 0.0f;\n\treturn (1.0f - (double)fabs(pow(x,a)));\n}\n\nstatic double filter_sinc(const double x)\n{\n\t/* X-scaled Sinc(x) function. */\n\tif (x == 0.0) return(1.0);\n\treturn (sin(M_PI * (double) x) / (M_PI * (double) x));\n}\n\n#ifdef FUNCTION_NOT_USED_YET\nstatic double filter_welsh(const double x)\n{\n\t/* Welsh parabolic windowing filter */\n\tif (x <  1.0)\n\t\treturn(1 - x*x);\n\treturn(0.0);\n}\n#endif\n\n\n/* keep it for future usage for affine copy over an existing image, targetting fix for 2.2.2 */\n#if 0 \n/* Copied from upstream's libgd */\nstatic inline int _color_blend (const int dst, const int src)\n{\n    const int src_alpha = gdTrueColorGetAlpha(src);\n\n    if( src_alpha == gdAlphaOpaque ) {\n\t\treturn src;\n\t} else {\n\t\tconst int dst_alpha = gdTrueColorGetAlpha(dst);\n\n\t\tif( src_alpha == gdAlphaTransparent ) return dst;\n\t\tif( dst_alpha == gdAlphaTransparent ) {\n\t\t\treturn src;\n\t\t} else {\n\t\t\tregister int alpha, red, green, blue;\n\t\t\tconst int src_weight = gdAlphaTransparent - src_alpha;\n\t\t\tconst int dst_weight = (gdAlphaTransparent - dst_alpha) * src_alpha / gdAlphaMax;\n\t\t\tconst int tot_weight = src_weight + dst_weight;\n\n\t\t\talpha = src_alpha * dst_alpha / gdAlphaMax;\n\n\t\t\tred = (gdTrueColorGetRed(src) * src_weight\n\t\t\t\t   + gdTrueColorGetRed(dst) * dst_weight) / tot_weight;\n\t\t\tgreen = (gdTrueColorGetGreen(src) * src_weight\n\t\t\t\t   + gdTrueColorGetGreen(dst) * dst_weight) / tot_weight;\n\t\t\tblue = (gdTrueColorGetBlue(src) * src_weight\n\t\t\t\t   + gdTrueColorGetBlue(dst) * dst_weight) / tot_weight;\n\n\t\t\treturn ((alpha << 24) + (red << 16) + (green << 8) + blue);\n\t\t}\n\t}\n}\n#endif\n\nstatic inline int getPixelOverflowTC(gdImagePtr im, const int x, const int y, const int bgColor)\n{\n\tif (gdImageBoundsSafe(im, x, y)) {\n\t\tconst int c = im->tpixels[y][x];\n\t\tif (c == im->transparent) {\n\t\t\treturn bgColor == -1 ? gdTrueColorAlpha(0, 0, 0, 127) : bgColor;\n\t\t}\n\t\treturn c;\n\t} else {\n\t\treturn bgColor;\n\t}\n}\n\n#define colorIndex2RGBA(c) gdTrueColorAlpha(im->red[(c)], im->green[(c)], im->blue[(c)], im->alpha[(c)])\n#define colorIndex2RGBcustomA(c, a) gdTrueColorAlpha(im->red[(c)], im->green[(c)], im->blue[(c)], im->alpha[(a)])\nstatic inline int getPixelOverflowPalette(gdImagePtr im, const int x, const int y, const int bgColor)\n{\n\tif (gdImageBoundsSafe(im, x, y)) {\n\t\tconst int c = im->pixels[y][x];\n\t\tif (c == im->transparent) {\n\t\t\treturn bgColor == -1 ? gdTrueColorAlpha(0, 0, 0, 127) : bgColor;\n\t\t}\n\t\treturn colorIndex2RGBA(c);\n\t} else {\n\t\treturn bgColor;\n\t}\n}\n\nstatic int getPixelInterpolateWeight(gdImagePtr im, const double x, const double y, const int bgColor)\n{\n\t/* Closest pixel <= (xf,yf) */\n\tint sx = (int)(x);\n\tint sy = (int)(y);\n\tconst double xf = x - (double)sx;\n\tconst double yf = y - (double)sy;\n\tconst double nxf = (double) 1.0 - xf;\n\tconst double nyf = (double) 1.0 - yf;\n\tconst double m1 = xf * yf;\n\tconst double m2 = nxf * yf;\n\tconst double m3 = xf * nyf;\n\tconst double m4 = nxf * nyf;\n\n\t/* get color values of neighbouring pixels */\n\tconst int c1 = im->trueColor == 1 ? getPixelOverflowTC(im, sx, sy, bgColor)         : getPixelOverflowPalette(im, sx, sy, bgColor);\n\tconst int c2 = im->trueColor == 1 ? getPixelOverflowTC(im, sx - 1, sy, bgColor)     : getPixelOverflowPalette(im, sx - 1, sy, bgColor);\n\tconst int c3 = im->trueColor == 1 ? getPixelOverflowTC(im, sx, sy - 1, bgColor)     : getPixelOverflowPalette(im, sx, sy - 1, bgColor);\n\tconst int c4 = im->trueColor == 1 ? getPixelOverflowTC(im, sx - 1, sy - 1, bgColor) : getPixelOverflowPalette(im, sx, sy - 1, bgColor);\n\tint r, g, b, a;\n\n\tif (x < 0) sx--;\n\tif (y < 0) sy--;\n\n\t/* component-wise summing-up of color values */\n\tif (im->trueColor) {\n\t\tr = (int)(m1*gdTrueColorGetRed(c1)   + m2*gdTrueColorGetRed(c2)   + m3*gdTrueColorGetRed(c3)   + m4*gdTrueColorGetRed(c4));\n\t\tg = (int)(m1*gdTrueColorGetGreen(c1) + m2*gdTrueColorGetGreen(c2) + m3*gdTrueColorGetGreen(c3) + m4*gdTrueColorGetGreen(c4));\n\t\tb = (int)(m1*gdTrueColorGetBlue(c1)  + m2*gdTrueColorGetBlue(c2)  + m3*gdTrueColorGetBlue(c3)  + m4*gdTrueColorGetBlue(c4));\n\t\ta = (int)(m1*gdTrueColorGetAlpha(c1) + m2*gdTrueColorGetAlpha(c2) + m3*gdTrueColorGetAlpha(c3) + m4*gdTrueColorGetAlpha(c4));\n\t} else {\n\t\tr = (int)(m1*im->red[(c1)]   + m2*im->red[(c2)]   + m3*im->red[(c3)]   + m4*im->red[(c4)]);\n\t\tg = (int)(m1*im->green[(c1)] + m2*im->green[(c2)] + m3*im->green[(c3)] + m4*im->green[(c4)]);\n\t\tb = (int)(m1*im->blue[(c1)]  + m2*im->blue[(c2)]  + m3*im->blue[(c3)]  + m4*im->blue[(c4)]);\n\t\ta = (int)(m1*im->alpha[(c1)] + m2*im->alpha[(c2)] + m3*im->alpha[(c3)] + m4*im->alpha[(c4)]);\n\t}\n\n\tr = CLAMP(r, 0, 255);\n\tg = CLAMP(g, 0, 255);\n\tb = CLAMP(b, 0, 255);\n\ta = CLAMP(a, 0, gdAlphaMax);\n\treturn gdTrueColorAlpha(r, g, b, a);\n}\n\n/**\n * Function: getPixelInterpolated\n *  Returns the interpolated color value using the default interpolation\n *  method. The returned color is always in the ARGB format (truecolor).\n *\n * Parameters:\n * \tim - Image to set the default interpolation method\n *  y - X value of the ideal position\n *  y - Y value of the ideal position\n *  method - Interpolation method <gdInterpolationMethod>\n *\n * Returns:\n *  GD_TRUE if the affine is rectilinear or GD_FALSE\n *\n * See also:\n *  <gdSetInterpolationMethod>\n */\nint getPixelInterpolated(gdImagePtr im, const double x, const double y, const int bgColor)\n{\n\tconst int xi=(int)(x);\n\tconst int yi=(int)(y);\n\tint yii;\n\tint i;\n\tdouble kernel, kernel_cache_y;\n\tdouble kernel_x[12], kernel_y[4];\n\tdouble new_r = 0.0f, new_g = 0.0f, new_b = 0.0f, new_a = 0.0f;\n\n\t/* These methods use special implementations */\n\tif (im->interpolation_id == GD_NEAREST_NEIGHBOUR) {\n\t\treturn -1;\n\t}\n\n\tif (im->interpolation_id == GD_WEIGHTED4) {\n\t\treturn getPixelInterpolateWeight(im, x, y, bgColor);\n\t}\n\n\tif (im->interpolation_id == GD_NEAREST_NEIGHBOUR) {\n\t\tif (im->trueColor == 1) {\n\t\t\treturn getPixelOverflowTC(im, xi, yi, bgColor);\n\t\t} else {\n\t\t\treturn getPixelOverflowPalette(im, xi, yi, bgColor);\n\t\t}\n\t}\n\tif (im->interpolation) {\n\t\tfor (i=0; i<4; i++) {\n\t\t\tkernel_x[i] = (double) im->interpolation((double)(xi+i-1-x));\n\t\t\tkernel_y[i] = (double) im->interpolation((double)(yi+i-1-y));\n\t\t}\n\t} else {\n\t\treturn -1;\n\t}\n\n\t/*\n\t * TODO: use the known fast rgba multiplication implementation once\n\t * the new formats are in place\n\t */\n\tfor (yii = yi-1; yii < yi+3; yii++) {\n\t\tint xii;\n\t\tkernel_cache_y = kernel_y[yii-(yi-1)];\n\t\tif (im->trueColor) {\n\t\t\tfor (xii=xi-1; xii<xi+3; xii++) {\n\t\t\t\tconst int rgbs = getPixelOverflowTC(im, xii, yii, bgColor);\n\n\t\t\t\tkernel = kernel_cache_y * kernel_x[xii-(xi-1)];\n\t\t\t\tnew_r += kernel * gdTrueColorGetRed(rgbs);\n\t\t\t\tnew_g += kernel * gdTrueColorGetGreen(rgbs);\n\t\t\t\tnew_b += kernel * gdTrueColorGetBlue(rgbs);\n\t\t\t\tnew_a += kernel * gdTrueColorGetAlpha(rgbs);\n\t\t\t}\n\t\t} else {\n\t\t\tfor (xii=xi-1; xii<xi+3; xii++) {\n\t\t\t\tconst int rgbs = getPixelOverflowPalette(im, xii, yii, bgColor);\n\n\t\t\t\tkernel = kernel_cache_y * kernel_x[xii-(xi-1)];\n\t\t\t\tnew_r += kernel * gdTrueColorGetRed(rgbs);\n\t\t\t\tnew_g += kernel * gdTrueColorGetGreen(rgbs);\n\t\t\t\tnew_b += kernel * gdTrueColorGetBlue(rgbs);\n\t\t\t\tnew_a += kernel * gdTrueColorGetAlpha(rgbs);\n\t\t\t}\n\t\t}\n\t}\n\n\tnew_r = CLAMP(new_r, 0, 255);\n\tnew_g = CLAMP(new_g, 0, 255);\n\tnew_b = CLAMP(new_b, 0, 255);\n\tnew_a = CLAMP(new_a, 0, gdAlphaMax);\n\n\treturn gdTrueColorAlpha(((int)new_r), ((int)new_g), ((int)new_b), ((int)new_a));\n}\n\nstatic inline LineContribType * _gdContributionsAlloc(unsigned int line_length, unsigned int windows_size)\n{\n\tunsigned int u = 0;\n\tLineContribType *res;\n\tsize_t weights_size;\n\n\tif (overflow2(windows_size, sizeof(double))) {\n\t\treturn NULL;\n\t} else {\n\t\tweights_size = windows_size * sizeof(double);\n\t}\n\tres = (LineContribType *) gdMalloc(sizeof(LineContribType));\n\tif (!res) {\n\t\treturn NULL;\n\t}\n\tres->WindowSize = windows_size;\n\tres->LineLength = line_length;\n\tif (overflow2(line_length, sizeof(ContributionType))) {\n\t\tgdFree(res);\n\t\treturn NULL;\n\t}\n\tres->ContribRow = (ContributionType *) gdMalloc(line_length * sizeof(ContributionType));\n\tif (res->ContribRow == NULL) {\n\t\tgdFree(res);\n\t\treturn NULL;\n\t}\n\tfor (u = 0 ; u < line_length ; u++) {\n\t\tres->ContribRow[u].Weights = (double *) gdMalloc(weights_size);\n\t\tif (res->ContribRow[u].Weights == NULL) {\n\t\t\tunsigned int i;\n\t\t\tfor (i=0;i<u;i++) {\n\t\t\t\tgdFree(res->ContribRow[i].Weights);\n\t\t\t}\n\t\t\tgdFree(res->ContribRow);\n\t\t\tgdFree(res);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn res;\n}\n\nstatic inline void _gdContributionsFree(LineContribType * p)\n{\n\tunsigned int u;\n\tfor (u = 0; u < p->LineLength; u++)  {\n\t\tgdFree(p->ContribRow[u].Weights);\n\t}\n\tgdFree(p->ContribRow);\n\tgdFree(p);\n}\n\nstatic inline LineContribType *_gdContributionsCalc(unsigned int line_size, unsigned int src_size, double scale_d,  const interpolation_method pFilter)\n{\n\tdouble width_d;\n\tdouble scale_f_d = 1.0;\n\tconst double filter_width_d = DEFAULT_BOX_RADIUS;\n\tint windows_size;\n\tunsigned int u;\n\tLineContribType *res;\n\n\tif (scale_d < 1.0) {\n\t\twidth_d = filter_width_d / scale_d;\n\t\tscale_f_d = scale_d;\n\t}  else {\n\t\twidth_d= filter_width_d;\n\t}\n\n\twindows_size = 2 * (int)ceil(width_d) + 1;\n\tres = _gdContributionsAlloc(line_size, windows_size);\n\tif (res == NULL) {\n\t\treturn NULL;\n\t}\n\tfor (u = 0; u < line_size; u++) {\n\tconst double dCenter = (double)u / scale_d;\n\t/* get the significant edge points affecting the pixel */\n\tregister int iLeft = MAX(0, (int)floor (dCenter - width_d));\n\tint iRight = MIN((int)ceil(dCenter + width_d), (int)src_size - 1);\n\tdouble dTotalWeight = 0.0;\n\t\tint iSrc;\n\n\t/* Cut edge points to fit in filter window in case of spill-off */\n\tif (iRight - iLeft + 1 > windows_size)  {\n\t\tif (iLeft < ((int)src_size - 1 / 2))  {\n\t\t\tiLeft++;\n\t\t} else {\n\t\t\tiRight--;\n\t\t}\n\t}\n\n\tres->ContribRow[u].Left = iLeft;\n\tres->ContribRow[u].Right = iRight;\n\n\tfor (iSrc = iLeft; iSrc <= iRight; iSrc++) {\n\t\tdTotalWeight += (res->ContribRow[u].Weights[iSrc-iLeft] =  scale_f_d * (*pFilter)(scale_f_d * (dCenter - (double)iSrc)));\n\t}\n\n\t\tif (dTotalWeight < 0.0) {\n\t\t\t_gdContributionsFree(res);\n\t\t\treturn NULL;\n\t\t}\n\n\tif (dTotalWeight > 0.0) {\n\t\tfor (iSrc = iLeft; iSrc <= iRight; iSrc++) {\n\t\t\tres->ContribRow[u].Weights[iSrc-iLeft] /= dTotalWeight;\n\t\t}\n\t}\n\t}\n\treturn res;\n}\n\n/* Convert a double to an unsigned char, rounding to the nearest\n * integer and clamping the result between 0 and max.  The absolute\n * value of clr must be less than the maximum value of an unsigned\n * short. */\nstatic inline unsigned char\nuchar_clamp(double clr, unsigned char max) {\n\tunsigned short result;\n\n\t//assert(fabs(clr) <= SHRT_MAX);\n\n\t/* Casting a negative float to an unsigned short is undefined.\n\t * However, casting a float to a signed truncates toward zero and\n\t * casting a negative signed value to an unsigned of the same size\n\t * results in a bit-identical value (assuming twos-complement\n\t * arithmetic).\t This is what we want: all legal negative values\n\t * for clr will be greater than 255. */\n\n\t/* Convert and clamp. */\n\tresult = (unsigned short)(short)(clr + 0.5);\n\tif (result > max) {\n\t\tresult = (clr < 0) ? 0 : max;\n\t}/* if */\n\n\treturn result;\n}/* uchar_clamp*/\n\nstatic inline void _gdScaleRow(gdImagePtr pSrc,  unsigned int src_width, gdImagePtr dst, unsigned int dst_width, unsigned int row, LineContribType *contrib)\n{\n    int *p_src_row = pSrc->tpixels[row];\n    int *p_dst_row = dst->tpixels[row];\n\tunsigned int x;\n\n    for (x = 0; x < dst_width; x++) {\n\t    double r = 0, g = 0, b = 0, a = 0;\n        const int left = contrib->ContribRow[x].Left;\n        const int right = contrib->ContribRow[x].Right;\n\tint i;\n\n\t/* Accumulate each channel */\n\tfor (i = left; i <= right; i++) {\n\t\tconst int left_channel = i - left;\n\t\tr += contrib->ContribRow[x].Weights[left_channel] * (double)(gdTrueColorGetRed(p_src_row[i]));\n\t\tg += contrib->ContribRow[x].Weights[left_channel] * (double)(gdTrueColorGetGreen(p_src_row[i]));\n\t\tb += contrib->ContribRow[x].Weights[left_channel] * (double)(gdTrueColorGetBlue(p_src_row[i]));\n\t\ta += contrib->ContribRow[x].Weights[left_channel] * (double)(gdTrueColorGetAlpha(p_src_row[i]));\n\t}\n\tp_dst_row[x] = gdTrueColorAlpha(uchar_clamp(r, 0xFF), uchar_clamp(g, 0xFF),\n\t\t\t\t\t\t\t\t\tuchar_clamp(b, 0xFF),\n\t\t\t\t\t\t\t\t\tuchar_clamp(a, 0x7F)); /* alpha is 0..127 */\n    }\n}\n\nstatic inline int _gdScaleHoriz(gdImagePtr pSrc, unsigned int src_width, unsigned int src_height, gdImagePtr pDst,  unsigned int dst_width, unsigned int dst_height)\n{\n\tunsigned int u;\n\tLineContribType * contrib;\n\n\t/* same width, just copy it */\n\tif (dst_width == src_width) {\n\t\tunsigned int y;\n\t\tfor (y = 0; y < src_height - 1; ++y) {\n\t\t\tmemcpy(pDst->tpixels[y], pSrc->tpixels[y], src_width);\n\t\t}\n\t}\n\n\tcontrib = _gdContributionsCalc(dst_width, src_width, (double)dst_width / (double)src_width, pSrc->interpolation);\n\tif (contrib == NULL) {\n\t\treturn 0;\n\t}\n\t/* Scale each row */\n\tfor (u = 0; u < dst_height; u++) {\n\t\t_gdScaleRow(pSrc, src_width, pDst, dst_width, u, contrib);\n\t}\n\t_gdContributionsFree (contrib);\n\treturn 1;\n}\n\nstatic inline void _gdScaleCol (gdImagePtr pSrc,  unsigned int src_width, gdImagePtr pRes, unsigned int dst_width, unsigned int dst_height, unsigned int uCol, LineContribType *contrib)\n{\n\tunsigned int y;\n\tfor (y = 0; y < dst_height; y++) {\n\t\tdouble r = 0, g = 0, b = 0, a = 0;\n\t\tconst int iLeft = contrib->ContribRow[y].Left;\n\t\tconst int iRight = contrib->ContribRow[y].Right;\n\t\tint i;\n\n\t\t/* Accumulate each channel */\n\t\tfor (i = iLeft; i <= iRight; i++) {\n\t\t\tconst int pCurSrc = pSrc->tpixels[i][uCol];\n\t\t\tconst int i_iLeft = i - iLeft;\n\t\t\tr += contrib->ContribRow[y].Weights[i_iLeft] * (double)(gdTrueColorGetRed(pCurSrc));\n\t\t\tg += contrib->ContribRow[y].Weights[i_iLeft] * (double)(gdTrueColorGetGreen(pCurSrc));\n\t\t\tb += contrib->ContribRow[y].Weights[i_iLeft] * (double)(gdTrueColorGetBlue(pCurSrc));\n\t\t\ta += contrib->ContribRow[y].Weights[i_iLeft] * (double)(gdTrueColorGetAlpha(pCurSrc));\n\t\t}\n\t\tpRes->tpixels[y][uCol] = gdTrueColorAlpha(uchar_clamp(r, 0xFF), uchar_clamp(g, 0xFF),\n\t\t\t\t\t\t\t\t\t\t\t\t  uchar_clamp(b, 0xFF),\n\t\t\t\t\t\t\t\t\t\t\t\t  uchar_clamp(a, 0x7F)); /* alpha is 0..127 */\n\t}\n}\n\nstatic inline int _gdScaleVert (const gdImagePtr pSrc, const unsigned int src_width, const unsigned int src_height, const gdImagePtr pDst, const unsigned int dst_width, const unsigned int dst_height)\n{\n\tunsigned int u;\n\tLineContribType * contrib;\n\n\t/* same height, copy it */\n\tif (src_height == dst_height) {\n\t\tunsigned int y;\n\t\tfor (y = 0; y < src_height - 1; ++y) {\n\t\t\tmemcpy(pDst->tpixels[y], pSrc->tpixels[y], src_width);\n\t\t}\n\t}\n\n\tcontrib = _gdContributionsCalc(dst_height, src_height, (double)(dst_height) / (double)(src_height), pSrc->interpolation);\n\tif (contrib == NULL) {\n\t\treturn 0;\n\t}\n\t/* scale each column */\n\tfor (u = 0; u < dst_width; u++) {\n\t\t_gdScaleCol(pSrc, src_width, pDst, dst_width, dst_height, u, contrib);\n\t}\n\t_gdContributionsFree(contrib);\n\treturn 1;\n}\n\nstatic gdImagePtr\ngdImageScaleTwoPass(const gdImagePtr src, const unsigned int src_width, const unsigned int src_height, const unsigned int new_width, const unsigned int new_height)\n{\n\tgdImagePtr tmp_im;\n\tgdImagePtr dst;\n\tint scale_pass_res;\n\n\t/* Convert to truecolor if it isn't; this code requires it. */\n\tif (!src->trueColor) {\n\t\tgdImagePaletteToTrueColor(src);\n\t}\n\n\ttmp_im = gdImageCreateTrueColor(new_width, src_height);\n\tif (tmp_im == NULL) {\n\t\treturn NULL;\n\t}\n\tgdImageSetInterpolationMethod(tmp_im, src->interpolation_id);\n\tscale_pass_res = _gdScaleHoriz(src, src_width, src_height, tmp_im, new_width, src_height);\n\tif (scale_pass_res != 1) {\n\t\tgdImageDestroy(tmp_im);\n\t\treturn NULL;\n\t}\n\n\tdst = gdImageCreateTrueColor(new_width, new_height);\n\tif (dst == NULL) {\n\t\tgdImageDestroy(tmp_im);\n\t\treturn NULL;\n\t}\n\tgdImageSetInterpolationMethod(dst, src->interpolation_id);\n\tscale_pass_res = _gdScaleVert(tmp_im, new_width, src_height, dst, new_width, new_height);\n\tif (scale_pass_res != 1) {\n\t\tgdImageDestroy(dst);\n\t\tgdImageDestroy(tmp_im);\n\t\treturn NULL;\n\t}\n\tgdImageDestroy(tmp_im);\n\n\treturn dst;\n}\n\n/*\n\tBilinearFixed, BicubicFixed and nearest implementations are rewamped versions of the implementation in CBitmapEx\n\thttp://www.codeproject.com/Articles/29121/CBitmapEx-Free-C-Bitmap-Manipulation-Class\n\tInteger only implementation, good to have for common usages like pre scale very large\n\timages before using another interpolation methods for the last step.\n*/\nstatic gdImagePtr\ngdImageScaleNearestNeighbour(gdImagePtr im, const unsigned int width, const unsigned int height)\n{\n\tconst unsigned long new_width = MAX(1, width);\n\tconst unsigned long new_height = MAX(1, height);\n\tconst float dx = (float)im->sx / (float)new_width;\n\tconst float dy = (float)im->sy / (float)new_height;\n\tconst gdFixed f_dx = gd_ftofx(dx);\n\tconst gdFixed f_dy = gd_ftofx(dy);\n\n\tgdImagePtr dst_img;\n\tunsigned long  dst_offset_x;\n\tunsigned long  dst_offset_y = 0;\n\tunsigned int i;\n\n\tdst_img = gdImageCreateTrueColor(new_width, new_height);\n\n\tif (dst_img == NULL) {\n\t\treturn NULL;\n\t}\n\n\tfor (i=0; i<new_height; i++) {\n\t\tunsigned int j;\n\t\tdst_offset_x = 0;\n\t\tif (im->trueColor) {\n\t\t\tfor (j=0; j<new_width; j++) {\n\t\t\t\tconst gdFixed f_i = gd_itofx(i);\n\t\t\t\tconst gdFixed f_j = gd_itofx(j);\n\t\t\t\tconst gdFixed f_a = gd_mulfx(f_i, f_dy);\n\t\t\t\tconst gdFixed f_b = gd_mulfx(f_j, f_dx);\n\t\t\t\tconst long m = gd_fxtoi(f_a);\n\t\t\t\tconst long n = gd_fxtoi(f_b);\n\n\t\t\t\tdst_img->tpixels[dst_offset_y][dst_offset_x++] = im->tpixels[m][n];\n\t\t\t}\n\t\t} else {\n\t\t\tfor (j=0; j<new_width; j++) {\n\t\t\t\tconst gdFixed f_i = gd_itofx(i);\n\t\t\t\tconst gdFixed f_j = gd_itofx(j);\n\t\t\t\tconst gdFixed f_a = gd_mulfx(f_i, f_dy);\n\t\t\t\tconst gdFixed f_b = gd_mulfx(f_j, f_dx);\n\t\t\t\tconst long m = gd_fxtoi(f_a);\n\t\t\t\tconst long n = gd_fxtoi(f_b);\n\n\t\t\t\tdst_img->tpixels[dst_offset_y][dst_offset_x++] = colorIndex2RGBA(im->pixels[m][n]);\n\t\t\t}\n\t\t}\n\t\tdst_offset_y++;\n\t}\n\treturn dst_img;\n}\n\nstatic gdImagePtr gdImageScaleBilinearPalette(gdImagePtr im, const unsigned int new_width, const unsigned int new_height)\n{\n\tlong _width = MAX(1, new_width);\n\tlong _height = MAX(1, new_height);\n\tfloat dx = (float)gdImageSX(im) / (float)_width;\n\tfloat dy = (float)gdImageSY(im) / (float)_height;\n\tgdFixed f_dx = gd_ftofx(dx);\n\tgdFixed f_dy = gd_ftofx(dy);\n\tgdFixed f_1 = gd_itofx(1);\n\n\tint dst_offset_h;\n\tint dst_offset_v = 0;\n\tlong i;\n\tgdImagePtr new_img;\n\tconst int transparent = im->transparent;\n\n\tnew_img = gdImageCreateTrueColor(new_width, new_height);\n\tif (new_img == NULL) {\n\t\treturn NULL;\n\t}\n\n\tif (transparent < 0) {\n\t\t/* uninitialized */\n\t\tnew_img->transparent = -1;\n\t} else {\n\t\tnew_img->transparent = gdTrueColorAlpha(im->red[transparent], im->green[transparent], im->blue[transparent], im->alpha[transparent]);\n\t}\n\n\tfor (i=0; i < _height; i++) {\n\t\tlong j;\n\t\tconst gdFixed f_i = gd_itofx(i);\n\t\tconst gdFixed f_a = gd_mulfx(f_i, f_dy);\n\t\tregister long m = gd_fxtoi(f_a);\n\n\t\tdst_offset_h = 0;\n\n\t\tfor (j=0; j < _width; j++) {\n\t\t\t/* Update bitmap */\n\t\t\tgdFixed f_j = gd_itofx(j);\n\t\t\tgdFixed f_b = gd_mulfx(f_j, f_dx);\n\n\t\t\tconst long n = gd_fxtoi(f_b);\n\t\t\tgdFixed f_f = f_a - gd_itofx(m);\n\t\t\tgdFixed f_g = f_b - gd_itofx(n);\n\n\t\t\tconst gdFixed f_w1 = gd_mulfx(f_1-f_f, f_1-f_g);\n\t\t\tconst gdFixed f_w2 = gd_mulfx(f_1-f_f, f_g);\n\t\t\tconst gdFixed f_w3 = gd_mulfx(f_f, f_1-f_g);\n\t\t\tconst gdFixed f_w4 = gd_mulfx(f_f, f_g);\n\t\t\tunsigned int pixel1;\n\t\t\tunsigned int pixel2;\n\t\t\tunsigned int pixel3;\n\t\t\tunsigned int pixel4;\n\t\t\tregister gdFixed f_r1, f_r2, f_r3, f_r4,\n\t\t\t\t\tf_g1, f_g2, f_g3, f_g4,\n\t\t\t\t\tf_b1, f_b2, f_b3, f_b4,\n\t\t\t\t\tf_a1, f_a2, f_a3, f_a4;\n\n\t\t\t/* 0 for bgColor; (n,m) is supposed to be valid anyway */\n\t\t\tpixel1 = getPixelOverflowPalette(im, n, m, 0);\n\t\t\tpixel2 = getPixelOverflowPalette(im, n + 1, m, pixel1);\n\t\t\tpixel3 = getPixelOverflowPalette(im, n, m + 1, pixel1);\n\t\t\tpixel4 = getPixelOverflowPalette(im, n + 1, m + 1, pixel1);\n\n\t\t\tf_r1 = gd_itofx(gdTrueColorGetRed(pixel1));\n\t\t\tf_r2 = gd_itofx(gdTrueColorGetRed(pixel2));\n\t\t\tf_r3 = gd_itofx(gdTrueColorGetRed(pixel3));\n\t\t\tf_r4 = gd_itofx(gdTrueColorGetRed(pixel4));\n\t\t\tf_g1 = gd_itofx(gdTrueColorGetGreen(pixel1));\n\t\t\tf_g2 = gd_itofx(gdTrueColorGetGreen(pixel2));\n\t\t\tf_g3 = gd_itofx(gdTrueColorGetGreen(pixel3));\n\t\t\tf_g4 = gd_itofx(gdTrueColorGetGreen(pixel4));\n\t\t\tf_b1 = gd_itofx(gdTrueColorGetBlue(pixel1));\n\t\t\tf_b2 = gd_itofx(gdTrueColorGetBlue(pixel2));\n\t\t\tf_b3 = gd_itofx(gdTrueColorGetBlue(pixel3));\n\t\t\tf_b4 = gd_itofx(gdTrueColorGetBlue(pixel4));\n\t\t\tf_a1 = gd_itofx(gdTrueColorGetAlpha(pixel1));\n\t\t\tf_a2 = gd_itofx(gdTrueColorGetAlpha(pixel2));\n\t\t\tf_a3 = gd_itofx(gdTrueColorGetAlpha(pixel3));\n\t\t\tf_a4 = gd_itofx(gdTrueColorGetAlpha(pixel4));\n\n\t\t\t{\n\t\t\t\tconst unsigned char red = (unsigned char) gd_fxtoi(gd_mulfx(f_w1, f_r1) + gd_mulfx(f_w2, f_r2) + gd_mulfx(f_w3, f_r3) + gd_mulfx(f_w4, f_r4));\n\t\t\t\tconst unsigned char green = (unsigned char) gd_fxtoi(gd_mulfx(f_w1, f_g1) + gd_mulfx(f_w2, f_g2) + gd_mulfx(f_w3, f_g3) + gd_mulfx(f_w4, f_g4));\n\t\t\t\tconst unsigned char blue = (unsigned char) gd_fxtoi(gd_mulfx(f_w1, f_b1) + gd_mulfx(f_w2, f_b2) + gd_mulfx(f_w3, f_b3) + gd_mulfx(f_w4, f_b4));\n\t\t\t\tconst unsigned char alpha = (unsigned char) gd_fxtoi(gd_mulfx(f_w1, f_a1) + gd_mulfx(f_w2, f_a2) + gd_mulfx(f_w3, f_a3) + gd_mulfx(f_w4, f_a4));\n\n\t\t\t\tnew_img->tpixels[dst_offset_v][dst_offset_h] = gdTrueColorAlpha(red, green, blue, alpha);\n\t\t\t}\n\n\t\t\tdst_offset_h++;\n\t\t}\n\n\t\tdst_offset_v++;\n\t}\n\treturn new_img;\n}\n\nstatic gdImagePtr gdImageScaleBilinearTC(gdImagePtr im, const unsigned int new_width, const unsigned int new_height)\n{\n\tlong dst_w = MAX(1, new_width);\n\tlong dst_h = MAX(1, new_height);\n\tfloat dx = (float)gdImageSX(im) / (float)dst_w;\n\tfloat dy = (float)gdImageSY(im) / (float)dst_h;\n\tgdFixed f_dx = gd_ftofx(dx);\n\tgdFixed f_dy = gd_ftofx(dy);\n\tgdFixed f_1 = gd_itofx(1);\n\n\tint dst_offset_h;\n\tint dst_offset_v = 0;\n\tlong i;\n\tgdImagePtr new_img;\n\n\tnew_img = gdImageCreateTrueColor(new_width, new_height);\n\tif (!new_img){\n\t\treturn NULL;\n\t}\n\n\tfor (i=0; i < dst_h; i++) {\n\t\tlong j;\n\t\tdst_offset_h = 0;\n\t\tfor (j=0; j < dst_w; j++) {\n\t\t\t/* Update bitmap */\n\t\t\tgdFixed f_i = gd_itofx(i);\n\t\t\tgdFixed f_j = gd_itofx(j);\n\t\t\tgdFixed f_a = gd_mulfx(f_i, f_dy);\n\t\t\tgdFixed f_b = gd_mulfx(f_j, f_dx);\n\t\t\tconst long m = gd_fxtoi(f_a);\n\t\t\tconst long n = gd_fxtoi(f_b);\n\t\t\tgdFixed f_f = f_a - gd_itofx(m);\n\t\t\tgdFixed f_g = f_b - gd_itofx(n);\n\n\t\t\tconst gdFixed f_w1 = gd_mulfx(f_1-f_f, f_1-f_g);\n\t\t\tconst gdFixed f_w2 = gd_mulfx(f_1-f_f, f_g);\n\t\t\tconst gdFixed f_w3 = gd_mulfx(f_f, f_1-f_g);\n\t\t\tconst gdFixed f_w4 = gd_mulfx(f_f, f_g);\n\t\t\tunsigned int pixel1;\n\t\t\tunsigned int pixel2;\n\t\t\tunsigned int pixel3;\n\t\t\tunsigned int pixel4;\n\t\t\tregister gdFixed f_r1, f_r2, f_r3, f_r4,\n\t\t\t\t\tf_g1, f_g2, f_g3, f_g4,\n\t\t\t\t\tf_b1, f_b2, f_b3, f_b4,\n\t\t\t\t\tf_a1, f_a2, f_a3, f_a4;\n\t\t\t/* 0 for bgColor; (n,m) is supposed to be valid anyway */\n\t\t\tpixel1 = getPixelOverflowTC(im, n, m, 0);\n\t\t\tpixel2 = getPixelOverflowTC(im, n + 1, m, pixel1);\n\t\t\tpixel3 = getPixelOverflowTC(im, n, m + 1, pixel1);\n\t\t\tpixel4 = getPixelOverflowTC(im, n + 1, m + 1, pixel1);\n\n\t\t\tf_r1 = gd_itofx(gdTrueColorGetRed(pixel1));\n\t\t\tf_r2 = gd_itofx(gdTrueColorGetRed(pixel2));\n\t\t\tf_r3 = gd_itofx(gdTrueColorGetRed(pixel3));\n\t\t\tf_r4 = gd_itofx(gdTrueColorGetRed(pixel4));\n\t\t\tf_g1 = gd_itofx(gdTrueColorGetGreen(pixel1));\n\t\t\tf_g2 = gd_itofx(gdTrueColorGetGreen(pixel2));\n\t\t\tf_g3 = gd_itofx(gdTrueColorGetGreen(pixel3));\n\t\t\tf_g4 = gd_itofx(gdTrueColorGetGreen(pixel4));\n\t\t\tf_b1 = gd_itofx(gdTrueColorGetBlue(pixel1));\n\t\t\tf_b2 = gd_itofx(gdTrueColorGetBlue(pixel2));\n\t\t\tf_b3 = gd_itofx(gdTrueColorGetBlue(pixel3));\n\t\t\tf_b4 = gd_itofx(gdTrueColorGetBlue(pixel4));\n\t\t\tf_a1 = gd_itofx(gdTrueColorGetAlpha(pixel1));\n\t\t\tf_a2 = gd_itofx(gdTrueColorGetAlpha(pixel2));\n\t\t\tf_a3 = gd_itofx(gdTrueColorGetAlpha(pixel3));\n\t\t\tf_a4 = gd_itofx(gdTrueColorGetAlpha(pixel4));\n\t\t\t{\n\t\t\t\tconst unsigned char red   = (unsigned char) gd_fxtoi(gd_mulfx(f_w1, f_r1) + gd_mulfx(f_w2, f_r2) + gd_mulfx(f_w3, f_r3) + gd_mulfx(f_w4, f_r4));\n\t\t\t\tconst unsigned char green = (unsigned char) gd_fxtoi(gd_mulfx(f_w1, f_g1) + gd_mulfx(f_w2, f_g2) + gd_mulfx(f_w3, f_g3) + gd_mulfx(f_w4, f_g4));\n\t\t\t\tconst unsigned char blue  = (unsigned char) gd_fxtoi(gd_mulfx(f_w1, f_b1) + gd_mulfx(f_w2, f_b2) + gd_mulfx(f_w3, f_b3) + gd_mulfx(f_w4, f_b4));\n\t\t\t\tconst unsigned char alpha = (unsigned char) gd_fxtoi(gd_mulfx(f_w1, f_a1) + gd_mulfx(f_w2, f_a2) + gd_mulfx(f_w3, f_a3) + gd_mulfx(f_w4, f_a4));\n\n\t\t\t\tnew_img->tpixels[dst_offset_v][dst_offset_h] = gdTrueColorAlpha(red, green, blue, alpha);\n\t\t\t}\n\n\t\t\tdst_offset_h++;\n\t\t}\n\n\t\tdst_offset_v++;\n\t}\n\treturn new_img;\n}\n\nstatic gdImagePtr\ngdImageScaleBilinear(gdImagePtr im, const unsigned int new_width, const unsigned int new_height)\n{\n\tif (im->trueColor) {\n\t\treturn gdImageScaleBilinearTC(im, new_width, new_height);\n\t} else {\n\t\treturn gdImageScaleBilinearPalette(im, new_width, new_height);\n\t}\n}\n\nstatic gdImagePtr\ngdImageScaleBicubicFixed(gdImagePtr src, const unsigned int width, const unsigned int height)\n{\n\tconst long new_width = MAX(1, width);\n\tconst long new_height = MAX(1, height);\n\tconst int src_w = gdImageSX(src);\n\tconst int src_h = gdImageSY(src);\n\tconst gdFixed f_dx = gd_ftofx((float)src_w / (float)new_width);\n\tconst gdFixed f_dy = gd_ftofx((float)src_h / (float)new_height);\n\tconst gdFixed f_1 = gd_itofx(1);\n\tconst gdFixed f_2 = gd_itofx(2);\n\tconst gdFixed f_4 = gd_itofx(4);\n\tconst gdFixed f_6 = gd_itofx(6);\n\tconst gdFixed f_gamma = gd_ftofx(1.04f);\n\tgdImagePtr dst;\n\n\tunsigned int dst_offset_x;\n\tunsigned int dst_offset_y = 0;\n\tlong i;\n\n\t/* impact perf a bit, but not that much. Implementation for palette\n\t   images can be done at a later point.\n\t*/\n\tif (src->trueColor == 0) {\n\t\tgdImagePaletteToTrueColor(src);\n\t}\n\n\tdst = gdImageCreateTrueColor(new_width, new_height);\n\tif (!dst) {\n\t\treturn NULL;\n\t}\n\n\tdst->saveAlphaFlag = 1;\n\n\tfor (i=0; i < new_height; i++) {\n\t\tlong j;\n\t\tdst_offset_x = 0;\n\n\t\tfor (j=0; j < new_width; j++) {\n\t\t\tconst gdFixed f_a = gd_mulfx(gd_itofx(i), f_dy);\n\t\t\tconst gdFixed f_b = gd_mulfx(gd_itofx(j), f_dx);\n\t\t\tconst long m = gd_fxtoi(f_a);\n\t\t\tconst long n = gd_fxtoi(f_b);\n\t\t\tconst gdFixed f_f = f_a - gd_itofx(m);\n\t\t\tconst gdFixed f_g = f_b - gd_itofx(n);\n\t\t\tunsigned int src_offset_x[16], src_offset_y[16];\n\t\t\tlong k;\n\t\t\tregister gdFixed f_red = 0, f_green = 0, f_blue = 0, f_alpha = 0;\n\t\t\tunsigned char red, green, blue, alpha = 0;\n\t\t\tint *dst_row = dst->tpixels[dst_offset_y];\n\n\t\t\tif ((m < 1) || (n < 1)) {\n\t\t\t\tsrc_offset_x[0] = n;\n\t\t\t\tsrc_offset_y[0] = m;\n\t\t\t} else {\n\t\t\t\tsrc_offset_x[0] = n - 1;\n\t\t\t\tsrc_offset_y[0] = m;\n\t\t\t}\n\n\t\t\tsrc_offset_x[1] = n;\n\t\t\tsrc_offset_y[1] = m;\n\n\t\t\tif ((m < 1) || (n >= src_w - 1)) {\n\t\t\t\tsrc_offset_x[2] = n;\n\t\t\t\tsrc_offset_y[2] = m;\n\t\t\t} else {\n\t\t\t\tsrc_offset_x[2] = n + 1;\n\t\t\t\tsrc_offset_y[2] = m;\n\t\t\t}\n\n\t\t\tif ((m < 1) || (n >= src_w - 2)) {\n\t\t\t\tsrc_offset_x[3] = n;\n\t\t\t\tsrc_offset_y[3] = m;\n\t\t\t} else {\n\t\t\t\tsrc_offset_x[3] = n + 1 + 1;\n\t\t\t\tsrc_offset_y[3] = m;\n\t\t\t}\n\n\t\t\tif (n < 1) {\n\t\t\t\tsrc_offset_x[4] = n;\n\t\t\t\tsrc_offset_y[4] = m;\n\t\t\t} else {\n\t\t\t\tsrc_offset_x[4] = n - 1;\n\t\t\t\tsrc_offset_y[4] = m;\n\t\t\t}\n\n\t\t\tsrc_offset_x[5] = n;\n\t\t\tsrc_offset_y[5] = m;\n\t\t\tif (n >= src_w-1) {\n\t\t\t\tsrc_offset_x[6] = n;\n\t\t\t\tsrc_offset_y[6] = m;\n\t\t\t} else {\n\t\t\t\tsrc_offset_x[6] = n + 1;\n\t\t\t\tsrc_offset_y[6] = m;\n\t\t\t}\n\n\t\t\tif (n >= src_w - 2) {\n\t\t\t\tsrc_offset_x[7] = n;\n\t\t\t\tsrc_offset_y[7] = m;\n\t\t\t} else {\n\t\t\t\tsrc_offset_x[7] = n + 1 + 1;\n\t\t\t\tsrc_offset_y[7] = m;\n\t\t\t}\n\n\t\t\tif ((m >= src_h - 1) || (n < 1)) {\n\t\t\t\tsrc_offset_x[8] = n;\n\t\t\t\tsrc_offset_y[8] = m;\n\t\t\t} else {\n\t\t\t\tsrc_offset_x[8] = n - 1;\n\t\t\t\tsrc_offset_y[8] = m;\n\t\t\t}\n\n\t\t\tsrc_offset_x[9] = n;\n\t\t\tsrc_offset_y[9] = m;\n\n\t\t\tif ((m >= src_h-1) || (n >= src_w-1)) {\n\t\t\t\tsrc_offset_x[10] = n;\n\t\t\t\tsrc_offset_y[10] = m;\n\t\t\t} else {\n\t\t\t\tsrc_offset_x[10] = n + 1;\n\t\t\t\tsrc_offset_y[10] = m;\n\t\t\t}\n\n\t\t\tif ((m >= src_h - 1) || (n >= src_w - 2)) {\n\t\t\t\tsrc_offset_x[11] = n;\n\t\t\t\tsrc_offset_y[11] = m;\n\t\t\t} else {\n\t\t\t\tsrc_offset_x[11] = n + 1 + 1;\n\t\t\t\tsrc_offset_y[11] = m;\n\t\t\t}\n\n\t\t\tif ((m >= src_h - 2) || (n < 1)) {\n\t\t\t\tsrc_offset_x[12] = n;\n\t\t\t\tsrc_offset_y[12] = m;\n\t\t\t} else {\n\t\t\t\tsrc_offset_x[12] = n - 1;\n\t\t\t\tsrc_offset_y[12] = m;\n\t\t\t}\n\n\t\t\tsrc_offset_x[13] = n;\n\t\t\tsrc_offset_y[13] = m;\n\n\t\t\tif ((m >= src_h - 2) || (n >= src_w - 1)) {\n\t\t\t\tsrc_offset_x[14] = n;\n\t\t\t\tsrc_offset_y[14] = m;\n\t\t\t} else {\n\t\t\t\tsrc_offset_x[14] = n + 1;\n\t\t\t\tsrc_offset_y[14] = m;\n\t\t\t}\n\n\t\t\tif ((m >= src_h - 2) || (n >= src_w - 2)) {\n\t\t\t\tsrc_offset_x[15] = n;\n\t\t\t\tsrc_offset_y[15] = m;\n\t\t\t} else {\n\t\t\t\tsrc_offset_x[15] = n  + 1 + 1;\n\t\t\t\tsrc_offset_y[15] = m;\n\t\t\t}\n\n\t\t\tfor (k = -1; k < 3; k++) {\n\t\t\t\tconst gdFixed f = gd_itofx(k)-f_f;\n\t\t\t\tconst gdFixed f_fm1 = f - f_1;\n\t\t\t\tconst gdFixed f_fp1 = f + f_1;\n\t\t\t\tconst gdFixed f_fp2 = f + f_2;\n\t\t\t\tregister gdFixed f_a = 0, f_b = 0, f_d = 0, f_c = 0;\n\t\t\t\tregister gdFixed f_RY;\n\t\t\t\tint l;\n\n\t\t\t\tif (f_fp2 > 0) f_a = gd_mulfx(f_fp2, gd_mulfx(f_fp2,f_fp2));\n\t\t\t\tif (f_fp1 > 0) f_b = gd_mulfx(f_fp1, gd_mulfx(f_fp1,f_fp1));\n\t\t\t\tif (f > 0)     f_c = gd_mulfx(f, gd_mulfx(f,f));\n\t\t\t\tif (f_fm1 > 0) f_d = gd_mulfx(f_fm1, gd_mulfx(f_fm1,f_fm1));\n\n\t\t\t\tf_RY = gd_divfx((f_a - gd_mulfx(f_4,f_b) + gd_mulfx(f_6,f_c) - gd_mulfx(f_4,f_d)),f_6);\n\n\t\t\t\tfor (l = -1; l < 3; l++) {\n\t\t\t\t\tconst gdFixed f = gd_itofx(l) - f_g;\n\t\t\t\t\tconst gdFixed f_fm1 = f - f_1;\n\t\t\t\t\tconst gdFixed f_fp1 = f + f_1;\n\t\t\t\t\tconst gdFixed f_fp2 = f + f_2;\n\t\t\t\t\tregister gdFixed f_a = 0, f_b = 0, f_c = 0, f_d = 0;\n\t\t\t\t\tregister gdFixed f_RX, f_R, f_rs, f_gs, f_bs, f_ba;\n\t\t\t\t\tregister int c;\n\t\t\t\t\tconst int _k = ((k+1)*4) + (l+1);\n\n\t\t\t\t\tif (f_fp2 > 0) f_a = gd_mulfx(f_fp2,gd_mulfx(f_fp2,f_fp2));\n\n\t\t\t\t\tif (f_fp1 > 0) f_b = gd_mulfx(f_fp1,gd_mulfx(f_fp1,f_fp1));\n\n\t\t\t\t\tif (f > 0) f_c = gd_mulfx(f,gd_mulfx(f,f));\n\n\t\t\t\t\tif (f_fm1 > 0) f_d = gd_mulfx(f_fm1,gd_mulfx(f_fm1,f_fm1));\n\n\t\t\t\t\tf_RX = gd_divfx((f_a-gd_mulfx(f_4,f_b)+gd_mulfx(f_6,f_c)-gd_mulfx(f_4,f_d)),f_6);\n\t\t\t\t\tf_R = gd_mulfx(f_RY,f_RX);\n\n\t\t\t\t\tc = src->tpixels[*(src_offset_y + _k)][*(src_offset_x + _k)];\n\t\t\t\t\tf_rs = gd_itofx(gdTrueColorGetRed(c));\n\t\t\t\t\tf_gs = gd_itofx(gdTrueColorGetGreen(c));\n\t\t\t\t\tf_bs = gd_itofx(gdTrueColorGetBlue(c));\n\t\t\t\t\tf_ba = gd_itofx(gdTrueColorGetAlpha(c));\n\n\t\t\t\t\tf_red += gd_mulfx(f_rs,f_R);\n\t\t\t\t\tf_green += gd_mulfx(f_gs,f_R);\n\t\t\t\t\tf_blue += gd_mulfx(f_bs,f_R);\n\t\t\t\t\tf_alpha += gd_mulfx(f_ba,f_R);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tred    = (unsigned char) CLAMP(gd_fxtoi(gd_mulfx(f_red,   f_gamma)),  0, 255);\n\t\t\tgreen  = (unsigned char) CLAMP(gd_fxtoi(gd_mulfx(f_green, f_gamma)),  0, 255);\n\t\t\tblue   = (unsigned char) CLAMP(gd_fxtoi(gd_mulfx(f_blue,  f_gamma)),  0, 255);\n\t\t\talpha  = (unsigned char) CLAMP(gd_fxtoi(gd_mulfx(f_alpha,  f_gamma)), 0, 127);\n\n\t\t\t*(dst_row + dst_offset_x) = gdTrueColorAlpha(red, green, blue, alpha);\n\n\t\t\tdst_offset_x++;\n\t\t}\n\t\tdst_offset_y++;\n\t}\n\treturn dst;\n}\n\ngdImagePtr gdImageScale(const gdImagePtr src, const unsigned int new_width, const unsigned int new_height)\n{\n\tgdImagePtr im_scaled = NULL;\n\n\tif (src == NULL || src->interpolation_id < 0 || src->interpolation_id > GD_METHOD_COUNT) {\n\t\treturn NULL;\n\t}\n\n\tif (new_width == 0 || new_height == 0) {\n\t\treturn NULL;\n\t}\n\n\tif (new_width == gdImageSX(src) && new_height == gdImageSY(src)) {\n\t\treturn gdImageClone(src);\n\t}\n\tswitch (src->interpolation_id) {\n\t\t/*Special cases, optimized implementations */\n\t\tcase GD_NEAREST_NEIGHBOUR:\n\t\t\tim_scaled = gdImageScaleNearestNeighbour(src, new_width, new_height);\n\t\t\tbreak;\n\n\t\tcase GD_BILINEAR_FIXED:\n\t\tcase GD_LINEAR:\n\t\t\tim_scaled = gdImageScaleBilinear(src, new_width, new_height);\n\t\t\tbreak;\n\n\t\tcase GD_BICUBIC_FIXED:\n\t\tcase GD_BICUBIC:\n\t\t\tim_scaled = gdImageScaleBicubicFixed(src, new_width, new_height);\n\t\t\tbreak;\n\n\t\t/* generic */\n\t\tdefault:\n\t\t\tif (src->interpolation == NULL) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tim_scaled = gdImageScaleTwoPass(src, src->sx, src->sy, new_width, new_height);\n\t\t\tbreak;\n\t}\n\treturn im_scaled;\n}\n\nstatic int gdRotatedImageSize(gdImagePtr src, const float angle, gdRectPtr bbox)\n{\n    gdRect src_area;\n    double m[6];\n\n    gdAffineRotate(m, angle);\n    src_area.x = 0;\n    src_area.y = 0;\n    src_area.width = gdImageSX(src);\n    src_area.height = gdImageSY(src);\n    if (gdTransformAffineBoundingBox(&src_area, m, bbox) != GD_TRUE) {\n        return GD_FALSE;\n    }\n\n    return GD_TRUE;\n}\n\nstatic gdImagePtr\ngdImageRotateNearestNeighbour(gdImagePtr src, const float degrees, const int bgColor)\n{\n\tfloat _angle = ((float) (-degrees / 180.0f) * (float)M_PI);\n\tconst int src_w  = gdImageSX(src);\n\tconst int src_h = gdImageSY(src);\n\tconst gdFixed f_0_5 = gd_ftofx(0.5f);\n\tconst gdFixed f_H = gd_itofx(src_h/2);\n\tconst gdFixed f_W = gd_itofx(src_w/2);\n\tconst gdFixed f_cos = gd_ftofx(cos(-_angle));\n\tconst gdFixed f_sin = gd_ftofx(sin(-_angle));\n\n\tunsigned int dst_offset_x;\n\tunsigned int dst_offset_y = 0;\n\tunsigned int i;\n\tgdImagePtr dst;\n\tgdRect bbox;\n\tint new_height, new_width;\n\n    gdRotatedImageSize(src, degrees, &bbox);\n    new_width = bbox.width;\n    new_height = bbox.height;\n\n\tdst = gdImageCreateTrueColor(new_width, new_height);\n\tif (!dst) {\n\t\treturn NULL;\n\t}\n\tdst->saveAlphaFlag = 1;\n\tfor (i = 0; i < new_height; i++) {\n\t\tunsigned int j;\n\t\tdst_offset_x = 0;\n\t\tfor (j = 0; j < new_width; j++) {\n\t\t\tgdFixed f_i = gd_itofx((int)i - (int)new_height/2);\n\t\t\tgdFixed f_j = gd_itofx((int)j - (int)new_width/2);\n\t\t\tgdFixed f_m = gd_mulfx(f_j,f_sin) + gd_mulfx(f_i,f_cos) + f_0_5 + f_H;\n\t\t\tgdFixed f_n = gd_mulfx(f_j,f_cos) - gd_mulfx(f_i,f_sin) + f_0_5 + f_W;\n\t\t\tlong m = gd_fxtoi(f_m);\n\t\t\tlong n = gd_fxtoi(f_n);\n\n\t\t\tif ((m > 0) && (m < src_h-1) && (n > 0) && (n < src_w-1)) {\n\t\t\t\tif (dst_offset_y < new_height) {\n\t\t\t\t\tdst->tpixels[dst_offset_y][dst_offset_x++] = src->tpixels[m][n];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (dst_offset_y < new_height) {\n\t\t\t\t\tdst->tpixels[dst_offset_y][dst_offset_x++] = bgColor;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdst_offset_y++;\n\t}\n\treturn dst;\n}\n\nstatic gdImagePtr\ngdImageRotateGeneric(gdImagePtr src, const float degrees, const int bgColor)\n{\n\tfloat _angle = ((float) (-degrees / 180.0f) * (float)M_PI);\n\tconst int src_w  = gdImageSX(src);\n\tconst int src_h = gdImageSY(src);\n\tconst gdFixed f_0_5 = gd_ftofx(0.5f);\n\tconst gdFixed f_H = gd_itofx(src_h/2);\n\tconst gdFixed f_W = gd_itofx(src_w/2);\n\tconst gdFixed f_cos = gd_ftofx(cos(-_angle));\n\tconst gdFixed f_sin = gd_ftofx(sin(-_angle));\n\n\tunsigned int dst_offset_x;\n\tunsigned int dst_offset_y = 0;\n\tunsigned int i;\n\tgdImagePtr dst;\n\tint new_width, new_height;\n\tgdRect bbox;\n\n\tif (bgColor < 0) {\n\t\treturn NULL;\n\t}\n\n\tif (src->interpolation == NULL) {\n\t\tgdImageSetInterpolationMethod(src, GD_DEFAULT);\n\t}\n\n    gdRotatedImageSize(src, degrees, &bbox);\n    new_width = bbox.width;\n    new_height = bbox.height;\n\n\tdst = gdImageCreateTrueColor(new_width, new_height);\n\tif (!dst) {\n\t\treturn NULL;\n\t}\n\tdst->saveAlphaFlag = 1;\n\n\tfor (i = 0; i < new_height; i++) {\n\t\tunsigned int j;\n\t\tdst_offset_x = 0;\n\t\tfor (j = 0; j < new_width; j++) {\n\t\t\tgdFixed f_i = gd_itofx((int)i - (int)new_height/ 2);\n\t\t\tgdFixed f_j = gd_itofx((int)j - (int)new_width / 2);\n\t\t\tgdFixed f_m = gd_mulfx(f_j,f_sin) + gd_mulfx(f_i,f_cos) + f_0_5 + f_H;\n\t\t\tgdFixed f_n = gd_mulfx(f_j,f_cos) - gd_mulfx(f_i,f_sin) + f_0_5 + f_W;\n\t\t\tlong m = gd_fxtoi(f_m);\n\t\t\tlong n = gd_fxtoi(f_n);\n\n\t\t\tif (m < -1 || n < -1 || m >= src_h || n >= src_w ) {\n\t\t\t\tdst->tpixels[dst_offset_y][dst_offset_x++] = bgColor;\n\t\t\t} else {\n\t\t\t\tdst->tpixels[dst_offset_y][dst_offset_x++] = getPixelInterpolated(src, gd_fxtod(f_n), gd_fxtod(f_m), bgColor);\n\t\t\t}\n\t\t}\n\t\tdst_offset_y++;\n\t}\n\treturn dst;\n}\n\ngdImagePtr gdImageRotateInterpolated(const gdImagePtr src, const float angle, int bgcolor)\n{\n\t/* round to two decimals and keep the 100x multiplication to use it in the common square angles\n\t   case later. Keep the two decimal precisions so smaller rotation steps can be done, useful for\n\t   slow animations. */\n\tconst int angle_rounded = fmod((int) floorf(angle * 100), 360 * 100);\n\n\tif (bgcolor < 0) {\n\t\treturn NULL;\n\t}\n\n\t/* impact perf a bit, but not that much. Implementation for palette\n\t   images can be done at a later point.\n\t*/\n\tif (src->trueColor == 0) {\n\t\tif (bgcolor < gdMaxColors) {\n\t\t\tbgcolor =  gdTrueColorAlpha(src->red[bgcolor], src->green[bgcolor], src->blue[bgcolor], src->alpha[bgcolor]);\n\t\t}\n\t\tgdImagePaletteToTrueColor(src);\n\t}\n\n\t/* no interpolation needed here */\n\tswitch (angle_rounded) {\n\t\tcase    0: {\n\t\t\tgdImagePtr dst = gdImageCreateTrueColor(src->sx, src->sy);\n\t\t\tif (dst == NULL) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tdst->transparent = src->transparent;\n\t\t\tdst->saveAlphaFlag = 1;\n\t\t\tdst->alphaBlendingFlag = gdEffectReplace;\n\n\t\t\tgdImageCopy(dst, src, 0,0,0,0,src->sx,src->sy);\n\t\t\treturn dst;\n\t\t}\n\t\tcase -27000:\n\t\tcase   9000:\n\t\t\treturn gdImageRotate90(src, 0);\n\t\tcase -18000:\n\t\tcase  18000:\n\t\t\treturn gdImageRotate180(src, 0);\n\t\tcase -9000:\n\t\tcase 27000:\n\t\t\treturn gdImageRotate270(src, 0);\n\t}\n\n\tif (src == NULL || src->interpolation_id < 1 || src->interpolation_id > GD_METHOD_COUNT) {\n\t\treturn NULL;\n\t}\n\n\tswitch (src->interpolation_id) {\n\t\tcase GD_NEAREST_NEIGHBOUR:\n\t\t\treturn gdImageRotateNearestNeighbour(src, angle, bgcolor);\n\t\t\tbreak;\n\n\t\tcase GD_BILINEAR_FIXED:\n\t\tcase GD_BICUBIC_FIXED:\n\t\tdefault:\n\t\t\treturn gdImageRotateGeneric(src, angle, bgcolor);\n\t}\n\treturn NULL;\n}\n\n/**\n * Title: Affine transformation\n **/\n\n/**\n * Group: Transform\n **/\n\n static void gdImageClipRectangle(gdImagePtr im, gdRectPtr r)\n{\n\tint c1x, c1y, c2x, c2y;\n\tint x1,y1;\n\n\tgdImageGetClip(im, &c1x, &c1y, &c2x, &c2y);\n\tx1 = r->x + r->width - 1;\n\ty1 = r->y + r->height - 1;\n\tr->x = CLAMP(r->x, c1x, c2x);\n\tr->y = CLAMP(r->y, c1y, c2y);\n\tr->width = CLAMP(x1, c1x, c2x) - r->x + 1;\n\tr->height = CLAMP(y1, c1y, c2y) - r->y + 1;\n}\n\nvoid gdDumpRect(const char *msg, gdRectPtr r)\n{\n\tprintf(\"%s (%i, %i) (%i, %i)\\n\", msg, r->x, r->y, r->width, r->height);\n}\n\n/**\n * Function: gdTransformAffineGetImage\n *  Applies an affine transformation to a region and return an image\n *  containing the complete transformation.\n *\n * Parameters:\n * \tdst - Pointer to a gdImagePtr to store the created image, NULL when\n *        the creation or the transformation failed\n *  src - Source image\n *  src_area - rectangle defining the source region to transform\n *  dstY - Y position in the destination image\n *  affine - The desired affine transformation\n *\n * Returns:\n *  GD_TRUE if the affine is rectilinear or GD_FALSE\n */\nint gdTransformAffineGetImage(gdImagePtr *dst,\n\t\t  const gdImagePtr src,\n\t\t  gdRectPtr src_area,\n\t\t  const double affine[6])\n{\n\tint res;\n\tdouble m[6];\n\tgdRect bbox;\n\tgdRect area_full;\n\n\tif (src_area == NULL) {\n\t\tarea_full.x = 0;\n\t\tarea_full.y = 0;\n\t\tarea_full.width  = gdImageSX(src);\n\t\tarea_full.height = gdImageSY(src);\n\t\tsrc_area = &area_full;\n\t}\n\n\tgdTransformAffineBoundingBox(src_area, affine, &bbox);\n\n\t*dst = gdImageCreateTrueColor(bbox.width, bbox.height);\n\tif (*dst == NULL) {\n\t\treturn GD_FALSE;\n\t}\n\t(*dst)->saveAlphaFlag = 1;\n\n\tif (!src->trueColor) {\n\t\tgdImagePaletteToTrueColor(src);\n\t}\n\n\t/* Translate to dst origin (0,0) */\n\tgdAffineTranslate(m, -bbox.x, -bbox.y);\n\tgdAffineConcat(m, affine, m);\n\n\tgdImageAlphaBlending(*dst, 0);\n\n\tres = gdTransformAffineCopy(*dst,\n\t\t  0,0,\n\t\t  src,\n\t\t  src_area,\n\t\t  m);\n\n\tif (res != GD_TRUE) {\n\t\tgdImageDestroy(*dst);\n\t\tdst = NULL;\n\t\treturn GD_FALSE;\n\t} else {\n\t\treturn GD_TRUE;\n\t}\n}\n\n/**\n * Function: gdTransformAffineCopy\n *  Applies an affine transformation to a region and copy the result\n *  in a destination to the given position.\n *\n * Parameters:\n * \tdst - Image to draw the transformed image\n *  src - Source image\n *  dstX - X position in the destination image\n *  dstY - Y position in the destination image\n *  src_area - Rectangular region to rotate in the src image\n *\n * Returns:\n *  GD_TRUE on success or GD_FALSE on failure\n */\nint gdTransformAffineCopy(gdImagePtr dst,\n\t\t  int dst_x, int dst_y,\n\t\t  const gdImagePtr src,\n\t\t  gdRectPtr src_region,\n\t\t  const double affine[6])\n{\n\tint c1x,c1y,c2x,c2y;\n\tint backclip = 0;\n\tint backup_clipx1, backup_clipy1, backup_clipx2, backup_clipy2;\n\tregister int x, y, src_offset_x, src_offset_y;\n\tdouble inv[6];\n\tgdPointF pt, src_pt;\n\tgdRect bbox;\n\tint end_x, end_y;\n\tgdInterpolationMethod interpolation_id_bak = src->interpolation_id;\n\n\t/* These methods use special implementations */\n\tif (src->interpolation_id == GD_BILINEAR_FIXED || src->interpolation_id == GD_BICUBIC_FIXED || src->interpolation_id == GD_NEAREST_NEIGHBOUR) {\n\t\tinterpolation_id_bak = src->interpolation_id;\n\n\t\tgdImageSetInterpolationMethod(src, GD_BICUBIC);\n\t}\n\n\n\tgdImageClipRectangle(src, src_region);\n\n\tif (src_region->x > 0 || src_region->y > 0\n\t\t|| src_region->width < gdImageSX(src)\n\t\t|| src_region->height < gdImageSY(src)) {\n\t\tbackclip = 1;\n\n\t\tgdImageGetClip(src, &backup_clipx1, &backup_clipy1,\n\t\t&backup_clipx2, &backup_clipy2);\n\n\t\tgdImageSetClip(src, src_region->x, src_region->y,\n\t\t\tsrc_region->x + src_region->width - 1,\n\t\t\tsrc_region->y + src_region->height - 1);\n\t}\n\n\tif (!gdTransformAffineBoundingBox(src_region, affine, &bbox)) {\n\t\tif (backclip) {\n\t\t\tgdImageSetClip(src, backup_clipx1, backup_clipy1,\n\t\t\t\t\tbackup_clipx2, backup_clipy2);\n\t\t}\n\t\tgdImageSetInterpolationMethod(src, interpolation_id_bak);\n\t\treturn GD_FALSE;\n\t}\n\n\tgdImageGetClip(dst, &c1x, &c1y, &c2x, &c2y);\n\n\tend_x = bbox.width  + abs(bbox.x);\n\tend_y = bbox.height + abs(bbox.y);\n\n\t/* Get inverse affine to let us work with destination -> source */\n\tif (gdAffineInvert(inv, affine) == GD_FALSE) {\n\t\tgdImageSetInterpolationMethod(src, interpolation_id_bak);\n\t\treturn GD_FALSE;\n\t}\n\n\tsrc_offset_x =  src_region->x;\n\tsrc_offset_y =  src_region->y;\n\n\tif (dst->alphaBlendingFlag) {\n\t\tfor (y = bbox.y; y <= end_y; y++) {\n\t\t\tpt.y = y + 0.5;\n\t\t\tfor (x = 0; x <= end_x; x++) {\n\t\t\t\tpt.x = x + 0.5;\n\t\t\t\tgdAffineApplyToPointF(&src_pt, &pt, inv);\n\t\t\t\tgdImageSetPixel(dst, dst_x + x, dst_y + y, getPixelInterpolated(src, src_offset_x + src_pt.x, src_offset_y + src_pt.y, 0));\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (y = 0; y <= end_y; y++) {\n\t\t\tunsigned char *dst_p = NULL;\n\t\t\tint *tdst_p = NULL;\n\n\t\t\tpt.y = y + 0.5 + bbox.y;\n\t\t\tif ((dst_y + y) < 0 || ((dst_y + y) > gdImageSY(dst) -1)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (dst->trueColor) {\n\t\t\t\ttdst_p = dst->tpixels[dst_y + y] + dst_x;\n\t\t\t} else {\n\t\t\t\tdst_p = dst->pixels[dst_y + y] + dst_x;\n\t\t\t}\n\n\t\t\tfor (x = 0; x <= end_x; x++) {\n\t\t\t\tpt.x = x + 0.5 + bbox.x;\n\t\t\t\tgdAffineApplyToPointF(&src_pt, &pt, inv);\n\n\t\t\t\tif ((dst_x + x) < 0 || (dst_x + x) > (gdImageSX(dst) - 1)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (dst->trueColor) {\n\t\t\t\t\t*(tdst_p++) = getPixelInterpolated(src, src_offset_x + src_pt.x, src_offset_y + src_pt.y, -1);\n\t\t\t\t} else {\n\t\t\t\t\t*(dst_p++) = getPixelInterpolated(src, src_offset_x + src_pt.x, src_offset_y + src_pt.y, -1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Restore clip if required */\n\tif (backclip) {\n\t\tgdImageSetClip(src, backup_clipx1, backup_clipy1,\n\t\t\t\tbackup_clipx2, backup_clipy2);\n\t}\n\n\tgdImageSetInterpolationMethod(src, interpolation_id_bak);\n\treturn GD_TRUE;\n}\n\n/**\n * Function: gdTransformAffineBoundingBox\n *  Returns the bounding box of an affine transformation applied to a\n *  rectangular area <gdRect>\n *\n * Parameters:\n * \tsrc - Rectangular source area for the affine transformation\n *  affine - the affine transformation\n *  bbox - the resulting bounding box\n *\n * Returns:\n *  GD_TRUE if the affine is rectilinear or GD_FALSE\n */\nint gdTransformAffineBoundingBox(gdRectPtr src, const double affine[6], gdRectPtr bbox)\n{\n\tgdPointF extent[4], min, max, point;\n\tint i;\n\n\textent[0].x=0.0;\n\textent[0].y=0.0;\n\textent[1].x=(double) src->width;\n\textent[1].y=0.0;\n\textent[2].x=(double) src->width;\n\textent[2].y=(double) src->height;\n\textent[3].x=0.0;\n\textent[3].y=(double) src->height;\n\n\tfor (i=0; i < 4; i++) {\n\t\tpoint=extent[i];\n\t\tif (gdAffineApplyToPointF(&extent[i], &point, affine) != GD_TRUE) {\n\t\t\treturn GD_FALSE;\n\t\t}\n\t}\n\tmin=extent[0];\n\tmax=extent[0];\n\n\tfor (i=1; i < 4; i++) {\n\t\tif (min.x > extent[i].x)\n\t\t\tmin.x=extent[i].x;\n\t\tif (min.y > extent[i].y)\n\t\t\tmin.y=extent[i].y;\n\t\tif (max.x < extent[i].x)\n\t\t\tmax.x=extent[i].x;\n\t\tif (max.y < extent[i].y)\n\t\t\tmax.y=extent[i].y;\n\t}\n\tbbox->x = (int) min.x;\n\tbbox->y = (int) min.y;\n\tbbox->width  = (int) floor(max.x - min.x) - 1;\n\tbbox->height = (int) floor(max.y - min.y);\n\treturn GD_TRUE;\n}\n\nint gdImageSetInterpolationMethod(gdImagePtr im, gdInterpolationMethod id)\n{\n\tif (im == NULL || id < 0 || id > GD_METHOD_COUNT) {\n\t\treturn 0;\n\t}\n\n\tswitch (id) {\n\t\tcase GD_NEAREST_NEIGHBOUR:\n\t\tcase GD_WEIGHTED4:\n\t\t\tim->interpolation = NULL;\n\t\t\tbreak;\n\n\t\t/* generic versions*/\n\t\t/* GD_BILINEAR_FIXED and GD_BICUBIC_FIXED are kept for BC reasons */\n\t\tcase GD_BILINEAR_FIXED:\n\t\tcase GD_LINEAR:\n\t\t\tim->interpolation = filter_linear;\n\t\t\tbreak;\n\t\tcase GD_BELL:\n\t\t\tim->interpolation = filter_bell;\n\t\t\tbreak;\n\t\tcase GD_BESSEL:\n\t\t\tim->interpolation = filter_bessel;\n\t\t\tbreak;\n\t\tcase GD_BICUBIC_FIXED:\n\t\tcase GD_BICUBIC:\n\t\t\tim->interpolation = filter_bicubic;\n\t\t\tbreak;\n\t\tcase GD_BLACKMAN:\n\t\t\tim->interpolation = filter_blackman;\n\t\t\tbreak;\n\t\tcase GD_BOX:\n\t\t\tim->interpolation = filter_box;\n\t\t\tbreak;\n\t\tcase GD_BSPLINE:\n\t\t\tim->interpolation = filter_bspline;\n\t\t\tbreak;\n\t\tcase GD_CATMULLROM:\n\t\t\tim->interpolation = filter_catmullrom;\n\t\t\tbreak;\n\t\tcase GD_GAUSSIAN:\n\t\t\tim->interpolation = filter_gaussian;\n\t\t\tbreak;\n\t\tcase GD_GENERALIZED_CUBIC:\n\t\t\tim->interpolation = filter_generalized_cubic;\n\t\t\tbreak;\n\t\tcase GD_HERMITE:\n\t\t\tim->interpolation = filter_hermite;\n\t\t\tbreak;\n\t\tcase GD_HAMMING:\n\t\t\tim->interpolation = filter_hamming;\n\t\t\tbreak;\n\t\tcase GD_HANNING:\n\t\t\tim->interpolation = filter_hanning;\n\t\t\tbreak;\n\t\tcase GD_MITCHELL:\n\t\t\tim->interpolation = filter_mitchell;\n\t\t\tbreak;\n\t\tcase GD_POWER:\n\t\t\tim->interpolation = filter_power;\n\t\t\tbreak;\n\t\tcase GD_QUADRATIC:\n\t\t\tim->interpolation = filter_quadratic;\n\t\t\tbreak;\n\t\tcase GD_SINC:\n\t\t\tim->interpolation = filter_sinc;\n\t\t\tbreak;\n\t\tcase GD_TRIANGLE:\n\t\t\tim->interpolation = filter_triangle;\n\t\t\tbreak;\n\t\tcase GD_DEFAULT:\n\t\t\tid = GD_LINEAR;\n\t\t\tim->interpolation = filter_linear;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn 0;\n\t}\n\tim->interpolation_id = id;\n\treturn 1;\n}\n\n/**\n * Function: gdImageGetInterpolationMethod\n *\n * Get the current interpolation method\n *\n * This is here so that the value can be read via a language or VM with an FFI\n * but no (portable) way to extract the value from the struct.\n *\n * Parameters:\n *   im - The image.\n *\n * Returns:\n *   The current interpolation method.\n *\n * See also:\n *   - <gdInterpolationMethod>\n *   - <gdImageSetInterpolationMethod>\n */\ngdInterpolationMethod gdImageGetInterpolationMethod(gdImagePtr im)\n{\n    return im->interpolation_id;\n}\n\n#ifdef _MSC_VER\n# pragma optimize(\"\", on)\n#endif\n", "patch": "@@ -39,8 +39,8 @@\n \tdownscaling using the fixed point implementations are usually much faster\n \tthan the existing gdImageCopyResampled while having a similar or better\n \tquality.\n-\t\n-\tFor image rotations, the optimized versions have a lazy antialiasing for \n+\n+\tFor image rotations, the optimized versions have a lazy antialiasing for\n \tthe edges of the images. For a much better antialiased result, the affine\n \tfunction is recommended.\n */\n@@ -633,7 +633,7 @@ static inline int _color_blend (const int dst, const int src)\n \t}\n }\n \n-static inline int _setEdgePixel(const gdImagePtr src, unsigned int x, unsigned int y, gdFixed coverage, const int bgColor) \n+static inline int _setEdgePixel(const gdImagePtr src, unsigned int x, unsigned int y, gdFixed coverage, const int bgColor)\n {\n \tconst gdFixed f_127 = gd_itofx(127);\n \tregister int c = src->tpixels[y][x];\n@@ -934,9 +934,6 @@ static inline LineContribType *_gdContributionsCalc(unsigned int line_size, unsi\n         double dTotalWeight = 0.0;\n \t\tint iSrc;\n \n-        res->ContribRow[u].Left = iLeft;\n-        res->ContribRow[u].Right = iRight;\n-\n         /* Cut edge points to fit in filter window in case of spill-off */\n         if (iRight - iLeft + 1 > windows_size)  {\n             if (iLeft < ((int)src_size - 1 / 2))  {\n@@ -946,6 +943,9 @@ static inline LineContribType *_gdContributionsCalc(unsigned int line_size, unsi\n             }\n         }\n \n+        res->ContribRow[u].Left = iLeft;\n+        res->ContribRow[u].Right = iRight;\n+\n         for (iSrc = iLeft; iSrc <= iRight; iSrc++) {\n             dTotalWeight += (res->ContribRow[u].Weights[iSrc-iLeft] =  scale_f_d * (*pFilter)(scale_f_d * (dCenter - (double)iSrc)));\n         }\n@@ -2273,7 +2273,7 @@ int gdTransformAffineGetImage(gdImagePtr *dst,\n \tif (!src->trueColor) {\n \t\tgdImagePaletteToTrueColor(src);\n \t}\n-\t\n+\n \t/* Translate to dst origin (0,0) */\n \tgdAffineTranslate(m, -bbox.x, -bbox.y);\n \tgdAffineConcat(m, affine, m);\n@@ -2332,7 +2332,7 @@ int gdTransformAffineCopy(gdImagePtr dst,\n \tif (src->interpolation_id == GD_BILINEAR_FIXED || src->interpolation_id == GD_BICUBIC_FIXED || src->interpolation_id == GD_NEAREST_NEIGHBOUR) {\n \t\tinterpolation_id_bak = src->interpolation_id;\n \t\tinterpolation_bak = src->interpolation;\n-\t\t\n+\n \t\tgdImageSetInterpolationMethod(src, GD_BICUBIC);\n \t}\n ", "file_path": "files/2016_8\\67", "file_language": "c", "file_name": "ext/gd/libgd/gd_interpolation.c", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}, {"raw_url": "https://github.com/php/php-src/raw/7a1aac3343af85b4af4df5f8844946eaa27394ab/ext/gd/tests/bug72227.phpt", "code": "--TEST--\nBug #72227: imagescale out-of-bounds read\n--SKIPIF--\n<?php\n\tif (!extension_loaded('gd')) die(\"skip gd extension not available\\n\");\n?>\n--FILE--\n<?php\n\n$img = imagecreatetruecolor ( 100, 100);\nimagescale($img, 13, 1, IMG_BICUBIC);\n?>\nDONE\n--EXPECT--\nDONE", "code_before": "--TEST--\nBug #72227: imagescale out-of-bounds read\n--SKIPIF--\n<?php\n    if (!extension_loaded('gd')) die(\"skip gd extension not available\\n\");\n?>\n--FILE--\n<?php\n\n$img = imagecreatetruecolor ( 100, 100);\nimagescale($img, 13, 1, IMG_BICUBIC);\n?>\nDONE\n--EXPECT--\nDONE\n", "patch": "@@ -0,0 +1,15 @@\n+--TEST--\n+Bug #72227: imagescale out-of-bounds read\n+--SKIPIF--\n+<?php\n+\tif (!extension_loaded('gd')) die(\"skip gd extension not available\\n\");\n+?>\n+--FILE--\n+<?php\n+\n+$img = imagecreatetruecolor ( 100, 100);\n+imagescale($img, 13, 1, IMG_BICUBIC);\n+?>\n+DONE\n+--EXPECT--\n+DONE\n\\ No newline at end of file", "file_path": "files/2016_8\\68", "file_language": "phpt", "file_name": "ext/gd/tests/bug72227.phpt", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}], "outdated": 0}
{"index": 26, "cve_id": "CVE-2016-5769", "cwe_id": ["CWE-190"], "cve_language": "C", "cve_description": "Multiple integer overflows in mcrypt.c in the mcrypt extension in PHP before 5.5.37, 5.6.x before 5.6.23, and 7.x before 7.0.8 allow remote attackers to cause a denial of service (heap-based buffer overflow and application crash) or possibly have unspecified other impact via a crafted length value, related to the (1) mcrypt_generic and (2) mdecrypt_generic functions.", "cvss": "9.8", "publish_date": "August 7, 2016", "AV": "NETWORK", "AC": "LOW", "PR": "NONE", "UI": "NONE", "S": "UNCHANGED", "C": "HIGH", "I": "HIGH", "A": "HIGH", "commit_id": "3b8d4de300854b3517c7acb239b84f7726c1353c", "commit_message": "Fix bug #71923 - integer overflow in ZipArchive::getFrom*", "commit_date": "2016-04-27T15:51:54Z", "project": "php/php-src", "url": "https://api.github.com/repos/php/php-src/commits/3b8d4de300854b3517c7acb239b84f7726c1353c", "html_url": "https://github.com/php/php-src/commit/3b8d4de300854b3517c7acb239b84f7726c1353c", "windows_before": "", "windows_after": "", "parents": [{"commit_id_before": "7133f28df57cef51076d5045b006c5c75c664728", "url_before": "https://api.github.com/repos/php/php-src/commits/7133f28df57cef51076d5045b006c5c75c664728", "html_url_before": "https://github.com/php/php-src/commit/7133f28df57cef51076d5045b006c5c75c664728"}], "details": [{"raw_url": "https://github.com/php/php-src/raw/3b8d4de300854b3517c7acb239b84f7726c1353c/ext/zip/php_zip.c", "code": "/*\n  +----------------------------------------------------------------------+\n  | PHP Version 7                                                        |\n  +----------------------------------------------------------------------+\n  | Copyright (c) 1997-2016 The PHP Group                                |\n  +----------------------------------------------------------------------+\n  | This source file is subject to version 3.01 of the PHP license,      |\n  | that is bundled with this package in the file LICENSE, and is        |\n  | available through the world-wide-web at the following url:           |\n  | http://www.php.net/license/3_01.txt.                                 |\n  | If you did not receive a copy of the PHP license and are unable to   |\n  | obtain it through the world-wide-web, please send a note to          |\n  | license@php.net so we can mail you a copy immediately.               |\n  +----------------------------------------------------------------------+\n  | Author: Piere-Alain Joye <pierre@php.net>                            |\n  +----------------------------------------------------------------------+\n*/\n\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include \"php.h\"\n#include \"php_ini.h\"\n#include \"ext/standard/info.h\"\n#include \"ext/standard/file.h\"\n#include \"ext/standard/php_string.h\"\n#include \"ext/pcre/php_pcre.h\"\n#include \"ext/standard/php_filestat.h\"\n#include \"php_zip.h\"\n\n/* zip_open is a macro for renaming libzip zipopen, so we need to use PHP_NAMED_FUNCTION */\nstatic PHP_NAMED_FUNCTION(zif_zip_open);\nstatic PHP_NAMED_FUNCTION(zif_zip_read);\nstatic PHP_NAMED_FUNCTION(zif_zip_close);\nstatic PHP_NAMED_FUNCTION(zif_zip_entry_read);\nstatic PHP_NAMED_FUNCTION(zif_zip_entry_filesize);\nstatic PHP_NAMED_FUNCTION(zif_zip_entry_name);\nstatic PHP_NAMED_FUNCTION(zif_zip_entry_compressedsize);\nstatic PHP_NAMED_FUNCTION(zif_zip_entry_compressionmethod);\nstatic PHP_NAMED_FUNCTION(zif_zip_entry_open);\nstatic PHP_NAMED_FUNCTION(zif_zip_entry_close);\n\n#ifdef HAVE_GLOB\n#ifndef PHP_WIN32\n#include <glob.h>\n#else\n#include \"win32/glob.h\"\n#endif\n#endif\n\n/* {{{ Resource le */\nstatic int le_zip_dir;\n#define le_zip_dir_name \"Zip Directory\"\nstatic int le_zip_entry;\n#define le_zip_entry_name \"Zip Entry\"\n/* }}} */\n\n/* {{{ PHP_ZIP_STAT_INDEX(za, index, flags, sb) */\n#define PHP_ZIP_STAT_INDEX(za, index, flags, sb) \\\n\tif (zip_stat_index(za, index, flags, &sb) != 0) { \\\n\t\tRETURN_FALSE; \\\n\t}\n/* }}} */\n\n/* {{{  PHP_ZIP_STAT_PATH(za, path, path_len, flags, sb) */\n#define PHP_ZIP_STAT_PATH(za, path, path_len, flags, sb) \\\n\tif (path_len < 1) { \\\n\t\tphp_error_docref(NULL, E_NOTICE, \"Empty string as entry name\"); \\\n\t\tRETURN_FALSE; \\\n\t} \\\n\tif (zip_stat(za, path, flags, &sb) != 0) { \\\n\t\tRETURN_FALSE; \\\n\t}\n/* }}} */\n\n/* {{{ PHP_ZIP_SET_FILE_COMMENT(za, index, comment, comment_len) */\n#define PHP_ZIP_SET_FILE_COMMENT(za, index, comment, comment_len) \\\n\tif (comment_len == 0) { \\\n\t\t/* Passing NULL remove the existing comment */ \\\n\t\tif (zip_set_file_comment(za, index, NULL, 0) < 0) { \\\n\t\t\tRETURN_FALSE; \\\n\t\t} \\\n\t} else if (zip_set_file_comment(za, index, comment, comment_len) < 0) { \\\n\t\tRETURN_FALSE; \\\n\t} \\\n\tRETURN_TRUE;\n/* }}} */\n\n# define add_ascii_assoc_string add_assoc_string\n# define add_ascii_assoc_long add_assoc_long\n\n/* Flatten a path by making a relative path (to .)*/\nstatic char * php_zip_make_relative_path(char *path, size_t path_len) /* {{{ */\n{\n\tchar *path_begin = path;\n\tsize_t i;\n\n\tif (path_len < 1 || path == NULL) {\n\t\treturn NULL;\n\t}\n\n\tif (IS_SLASH(path[0])) {\n\t\treturn path + 1;\n\t}\n\n\ti = path_len;\n\n\twhile (1) {\n\t\twhile (i > 0 && !IS_SLASH(path[i])) {\n\t\t\ti--;\n\t\t}\n\n\t\tif (!i) {\n\t\t\treturn path;\n\t\t}\n\n\t\tif (i >= 2 && (path[i -1] == '.' || path[i -1] == ':')) {\n\t\t\t/* i is the position of . or :, add 1 for / */\n\t\t\tpath_begin = path + i + 1;\n\t\t\tbreak;\n\t\t}\n\t\ti--;\n\t}\n\n\treturn path_begin;\n}\n/* }}} */\n\n# define CWD_STATE_ALLOC(l) emalloc(l)\n# define CWD_STATE_FREE(s)  efree(s)\n\n/* {{{ php_zip_extract_file */\nstatic int php_zip_extract_file(struct zip * za, char *dest, char *file, int file_len)\n{\n\tphp_stream_statbuf ssb;\n\tstruct zip_file *zf;\n\tstruct zip_stat sb;\n\tchar b[8192];\n\tint n, len, ret;\n\tphp_stream *stream;\n\tchar *fullpath;\n\tchar *file_dirname_fullpath;\n\tchar file_dirname[MAXPATHLEN];\n\tsize_t dir_len;\n\tint is_dir_only = 0;\n\tchar *path_cleaned;\n\tsize_t path_cleaned_len;\n\tcwd_state new_state;\n\tzend_string *file_basename;\n\n\tnew_state.cwd = CWD_STATE_ALLOC(1);\n\tnew_state.cwd[0] = '\\0';\n\tnew_state.cwd_length = 0;\n\n\t/* Clean/normlize the path and then transform any path (absolute or relative)\n\t\t to a path relative to cwd (../../mydir/foo.txt > mydir/foo.txt)\n\t */\n\tvirtual_file_ex(&new_state, file, NULL, CWD_EXPAND);\n\tpath_cleaned =  php_zip_make_relative_path(new_state.cwd, new_state.cwd_length);\n\tif(!path_cleaned) {\n\t\treturn 0;\n\t}\n\tpath_cleaned_len = strlen(path_cleaned);\n\n\tif (path_cleaned_len >= MAXPATHLEN || zip_stat(za, file, 0, &sb) != 0) {\n\t\treturn 0;\n\t}\n\n\t/* it is a directory only, see #40228 */\n\tif (path_cleaned_len > 1 && IS_SLASH(path_cleaned[path_cleaned_len - 1])) {\n\t\tlen = spprintf(&file_dirname_fullpath, 0, \"%s/%s\", dest, path_cleaned);\n\t\tis_dir_only = 1;\n\t} else {\n\t\tmemcpy(file_dirname, path_cleaned, path_cleaned_len);\n\t\tdir_len = php_dirname(file_dirname, path_cleaned_len);\n\n\t\tif (dir_len <= 0 || (dir_len == 1 && file_dirname[0] == '.')) {\n\t\t\tlen = spprintf(&file_dirname_fullpath, 0, \"%s\", dest);\n\t\t} else {\n\t\t\tlen = spprintf(&file_dirname_fullpath, 0, \"%s/%s\", dest, file_dirname);\n\t\t}\n\n\t\tfile_basename =\tphp_basename(path_cleaned, path_cleaned_len, NULL, 0);\n\n\t\tif (ZIP_OPENBASEDIR_CHECKPATH(file_dirname_fullpath)) {\n\t\t\tefree(file_dirname_fullpath);\n\t\t\tzend_string_release(file_basename);\n\t\t\tCWD_STATE_FREE(new_state.cwd);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* let see if the path already exists */\n\tif (php_stream_stat_path_ex(file_dirname_fullpath, PHP_STREAM_URL_STAT_QUIET, &ssb, NULL) < 0) {\n\t\tret = php_stream_mkdir(file_dirname_fullpath, 0777,  PHP_STREAM_MKDIR_RECURSIVE|REPORT_ERRORS, NULL);\n\t\tif (!ret) {\n\t\t\tefree(file_dirname_fullpath);\n\t\t\tif (!is_dir_only) {\n\t\t\t\tzend_string_release(file_basename);\n\t\t\t\tCWD_STATE_FREE(new_state.cwd);\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* it is a standalone directory, job done */\n\tif (is_dir_only) {\n\t\tefree(file_dirname_fullpath);\n\t\tCWD_STATE_FREE(new_state.cwd);\n\t\treturn 1;\n\t}\n\n\tlen = spprintf(&fullpath, 0, \"%s/%s\", file_dirname_fullpath, ZSTR_VAL(file_basename));\n\tif (!len) {\n\t\tefree(file_dirname_fullpath);\n\t\tzend_string_release(file_basename);\n\t\tCWD_STATE_FREE(new_state.cwd);\n\t\treturn 0;\n\t} else if (len > MAXPATHLEN) {\n\t\tphp_error_docref(NULL, E_WARNING, \"Full extraction path exceed MAXPATHLEN (%i)\", MAXPATHLEN);\n\t\tefree(file_dirname_fullpath);\n\t\tzend_string_release(file_basename);\n\t\tCWD_STATE_FREE(new_state.cwd);\n\t\treturn 0;\n\t}\n\n\t/* check again the full path, not sure if it\n\t * is required, does a file can have a different\n\t * safemode status as its parent folder?\n\t */\n\tif (ZIP_OPENBASEDIR_CHECKPATH(fullpath)) {\n\t\tefree(fullpath);\n\t\tefree(file_dirname_fullpath);\n\t\tzend_string_release(file_basename);\n\t\tCWD_STATE_FREE(new_state.cwd);\n\t\treturn 0;\n\t}\n\n\tstream = php_stream_open_wrapper(fullpath, \"w+b\", REPORT_ERRORS, NULL);\n\n\tif (stream == NULL) {\n\t\tn = -1;\n\t\tgoto done;\n\t}\n\n\tzf = zip_fopen(za, file, 0);\n\tif (zf == NULL) {\n\t\tn = -1;\n\t\tphp_stream_close(stream);\n\t\tgoto done;\n\t}\n\n\tn = 0;\n\n\twhile ((n=zip_fread(zf, b, sizeof(b))) > 0) {\n\t\tphp_stream_write(stream, b, n);\n\t}\n\n\tphp_stream_close(stream);\n\tn = zip_fclose(zf);\n\ndone:\n\tefree(fullpath);\n\tzend_string_release(file_basename);\n\tefree(file_dirname_fullpath);\n\tCWD_STATE_FREE(new_state.cwd);\n\n\tif (n<0) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}\n/* }}} */\n\nstatic int php_zip_add_file(struct zip *za, const char *filename, size_t filename_len,\n\tchar *entry_name, size_t entry_name_len, long offset_start, long offset_len) /* {{{ */\n{\n\tstruct zip_source *zs;\n\tchar resolved_path[MAXPATHLEN];\n\tzval exists_flag;\n\n\n\tif (ZIP_OPENBASEDIR_CHECKPATH(filename)) {\n\t\treturn -1;\n\t}\n\n\tif (!expand_filepath(filename, resolved_path)) {\n\t\treturn -1;\n\t}\n\n\tphp_stat(resolved_path, strlen(resolved_path), FS_EXISTS, &exists_flag);\n\tif (Z_TYPE(exists_flag) == IS_FALSE) {\n\t\treturn -1;\n\t}\n\n\tzs = zip_source_file(za, resolved_path, offset_start, offset_len);\n\tif (!zs) {\n\t\treturn -1;\n\t}\n\tif (zip_file_add(za, entry_name, zs, ZIP_FL_OVERWRITE) < 0) {\n\t\tzip_source_free(zs);\n\t\treturn -1;\n\t} else {\n\t\tzip_error_clear(za);\n\t\treturn 1;\n\t}\n}\n/* }}} */\n\nstatic int php_zip_parse_options(zval *options, zend_long *remove_all_path, char **remove_path, size_t *remove_path_len, char **add_path, size_t *add_path_len) /* {{{ */\n{\n\tzval *option;\n\tif ((option = zend_hash_str_find(Z_ARRVAL_P(options), \"remove_all_path\", sizeof(\"remove_all_path\") - 1)) != NULL) {\n\t\t*remove_all_path = zval_get_long(option);\n\t}\n\n\t/* If I add more options, it would make sense to create a nice static struct and loop over it. */\n\tif ((option = zend_hash_str_find(Z_ARRVAL_P(options), \"remove_path\", sizeof(\"remove_path\") - 1)) != NULL) {\n\t\tif (Z_TYPE_P(option) != IS_STRING) {\n\t\t\tphp_error_docref(NULL, E_WARNING, \"remove_path option expected to be a string\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (Z_STRLEN_P(option) < 1) {\n\t\t\tphp_error_docref(NULL, E_NOTICE, \"Empty string given as remove_path option\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (Z_STRLEN_P(option) >= MAXPATHLEN) {\n\t\t\tphp_error_docref(NULL, E_WARNING, \"remove_path string is too long (max: %d, %zd given)\",\n\t\t\t\t\t\tMAXPATHLEN - 1, Z_STRLEN_P(option));\n\t\t\treturn -1;\n\t\t}\n\t\t*remove_path_len = Z_STRLEN_P(option);\n\t\t*remove_path = Z_STRVAL_P(option);\n\t}\n\n\tif ((option = zend_hash_str_find(Z_ARRVAL_P(options), \"add_path\", sizeof(\"add_path\") - 1)) != NULL) {\n\t\tif (Z_TYPE_P(option) != IS_STRING) {\n\t\t\tphp_error_docref(NULL, E_WARNING, \"add_path option expected to be a string\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (Z_STRLEN_P(option) < 1) {\n\t\t\tphp_error_docref(NULL, E_NOTICE, \"Empty string given as the add_path option\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (Z_STRLEN_P(option) >= MAXPATHLEN) {\n\t\t\tphp_error_docref(NULL, E_WARNING, \"add_path string too long (max: %d, %zd given)\",\n\t\t\t\t\t\tMAXPATHLEN - 1, Z_STRLEN_P(option));\n\t\t\treturn -1;\n\t\t}\n\t\t*add_path_len = Z_STRLEN_P(option);\n\t\t*add_path = Z_STRVAL_P(option);\n\t}\n\treturn 1;\n}\n/* }}} */\n\n/* {{{ REGISTER_ZIP_CLASS_CONST_LONG */\n#define REGISTER_ZIP_CLASS_CONST_LONG(const_name, value) \\\n\t    zend_declare_class_constant_long(zip_class_entry, const_name, sizeof(const_name)-1, (zend_long)value);\n/* }}} */\n\n/* {{{ ZIP_FROM_OBJECT */\n#define ZIP_FROM_OBJECT(intern, object) \\\n\t{ \\\n\t\tze_zip_object *obj = Z_ZIP_P(object); \\\n\t\tintern = obj->za; \\\n\t\tif (!intern) { \\\n\t\t\tphp_error_docref(NULL, E_WARNING, \"Invalid or uninitialized Zip object\"); \\\n\t\t\tRETURN_FALSE; \\\n\t\t} \\\n\t}\n/* }}} */\n\n/* {{{ RETURN_SB(sb) */\n#define RETURN_SB(sb) \\\n\t{ \\\n\t\tarray_init(return_value); \\\n\t\tadd_ascii_assoc_string(return_value, \"name\", (char *)(sb)->name); \\\n\t\tadd_ascii_assoc_long(return_value, \"index\", (zend_long) (sb)->index); \\\n\t\tadd_ascii_assoc_long(return_value, \"crc\", (zend_long) (sb)->crc); \\\n\t\tadd_ascii_assoc_long(return_value, \"size\", (zend_long) (sb)->size); \\\n\t\tadd_ascii_assoc_long(return_value, \"mtime\", (zend_long) (sb)->mtime); \\\n\t\tadd_ascii_assoc_long(return_value, \"comp_size\", (zend_long) (sb)->comp_size); \\\n\t\tadd_ascii_assoc_long(return_value, \"comp_method\", (zend_long) (sb)->comp_method); \\\n\t}\n/* }}} */\n\nstatic int php_zip_status(struct zip *za) /* {{{ */\n{\n#if LIBZIP_VERSION_MAJOR < 1\n\tint zep, syp;\n\n\tzip_error_get(za, &zep, &syp);\n#else\n\tint zep;\n\tzip_error_t *err;\n\n\terr = zip_get_error(za);\n\tzep = zip_error_code_zip(err);\n\tzip_error_fini(err);\n#endif\n\treturn zep;\n}\n/* }}} */\n\nstatic int php_zip_status_sys(struct zip *za) /* {{{ */\n{\n#if LIBZIP_VERSION_MAJOR < 1\n\tint zep, syp;\n\n\tzip_error_get(za, &zep, &syp);\n#else\n\tint syp;\n\tzip_error_t *err;\n\n\terr = zip_get_error(za);\n\tsyp = zip_error_code_system(err);\n\tzip_error_fini(err);\n#endif\n\treturn syp;\n}\n/* }}} */\n\nstatic int php_zip_get_num_files(struct zip *za) /* {{{ */\n{\n\treturn zip_get_num_files(za);\n}\n/* }}} */\n\nstatic char * php_zipobj_get_filename(ze_zip_object *obj) /* {{{ */\n{\n\n\tif (!obj) {\n\t\treturn NULL;\n\t}\n\n\tif (obj->filename) {\n\t\treturn obj->filename;\n\t}\n\treturn NULL;\n}\n/* }}} */\n\nstatic char * php_zipobj_get_zip_comment(struct zip *za, int *len) /* {{{ */\n{\n\tif (za) {\n\t\treturn (char *)zip_get_archive_comment(za, len, 0);\n\t}\n\treturn NULL;\n}\n/* }}} */\n\n#ifdef HAVE_GLOB /* {{{ */\n#ifndef GLOB_ONLYDIR\n#define GLOB_ONLYDIR (1<<30)\n#define GLOB_EMULATE_ONLYDIR\n#define GLOB_FLAGMASK (~GLOB_ONLYDIR)\n#else\n#define GLOB_FLAGMASK (~0)\n#endif\n#ifndef GLOB_BRACE\n# define GLOB_BRACE 0\n#endif\n#ifndef GLOB_MARK\n# define GLOB_MARK 0\n#endif\n#ifndef GLOB_NOSORT\n# define GLOB_NOSORT 0\n#endif\n#ifndef GLOB_NOCHECK\n# define GLOB_NOCHECK 0\n#endif\n#ifndef GLOB_NOESCAPE\n# define GLOB_NOESCAPE 0\n#endif\n#ifndef GLOB_ERR\n# define GLOB_ERR 0\n#endif\n\n/* This is used for checking validity of passed flags (passing invalid flags causes segfault in glob()!! */\n#define GLOB_AVAILABLE_FLAGS (0 | GLOB_BRACE | GLOB_MARK | GLOB_NOSORT | GLOB_NOCHECK | GLOB_NOESCAPE | GLOB_ERR | GLOB_ONLYDIR)\n\n#endif /* }}} */\n\nint php_zip_glob(char *pattern, int pattern_len, zend_long flags, zval *return_value) /* {{{ */\n{\n#ifdef HAVE_GLOB\n\tchar cwd[MAXPATHLEN];\n\tint cwd_skip = 0;\n#ifdef ZTS\n\tchar work_pattern[MAXPATHLEN];\n\tchar *result;\n#endif\n\tglob_t globbuf;\n\tint n;\n\tint ret;\n\n\tif (pattern_len >= MAXPATHLEN) {\n\t\tphp_error_docref(NULL, E_WARNING, \"Pattern exceeds the maximum allowed length of %d characters\", MAXPATHLEN);\n\t\treturn -1;\n\t}\n\n\tif ((GLOB_AVAILABLE_FLAGS & flags) != flags) {\n\t\tphp_error_docref(NULL, E_WARNING, \"At least one of the passed flags is invalid or not supported on this platform\");\n\t\treturn -1;\n\t}\n\n#ifdef ZTS\n\tif (!IS_ABSOLUTE_PATH(pattern, pattern_len)) {\n\t\tresult = VCWD_GETCWD(cwd, MAXPATHLEN);\n\t\tif (!result) {\n\t\t\tcwd[0] = '\\0';\n\t\t}\n#ifdef PHP_WIN32\n\t\tif (IS_SLASH(*pattern)) {\n\t\t\tcwd[2] = '\\0';\n\t\t}\n#endif\n\t\tcwd_skip = strlen(cwd)+1;\n\n\t\tsnprintf(work_pattern, MAXPATHLEN, \"%s%c%s\", cwd, DEFAULT_SLASH, pattern);\n\t\tpattern = work_pattern;\n\t}\n#endif\n\n\tglobbuf.gl_offs = 0;\n\tif (0 != (ret = glob(pattern, flags & GLOB_FLAGMASK, NULL, &globbuf))) {\n#ifdef GLOB_NOMATCH\n\t\tif (GLOB_NOMATCH == ret) {\n\t\t\t/* Some glob implementation simply return no data if no matches\n\t\t\t   were found, others return the GLOB_NOMATCH error code.\n\t\t\t   We don't want to treat GLOB_NOMATCH as an error condition\n\t\t\t   so that PHP glob() behaves the same on both types of\n\t\t\t   implementations and so that 'foreach (glob() as ...'\n\t\t\t   can be used for simple glob() calls without further error\n\t\t\t   checking.\n\t\t\t*/\n\t\t\tarray_init(return_value);\n\t\t\treturn 0;\n\t\t}\n#endif\n\t\treturn 0;\n\t}\n\n\t/* now catch the FreeBSD style of \"no matches\" */\n\tif (!globbuf.gl_pathc || !globbuf.gl_pathv) {\n\t\tarray_init(return_value);\n\t\treturn 0;\n\t}\n\n\t/* we assume that any glob pattern will match files from one directory only\n\t   so checking the dirname of the first match should be sufficient */\n\tstrncpy(cwd, globbuf.gl_pathv[0], MAXPATHLEN);\n\tif (ZIP_OPENBASEDIR_CHECKPATH(cwd)) {\n\t\treturn -1;\n\t}\n\n\tarray_init(return_value);\n\tfor (n = 0; n < globbuf.gl_pathc; n++) {\n\t\t/* we need to do this every time since GLOB_ONLYDIR does not guarantee that\n\t\t * all directories will be filtered. GNU libc documentation states the\n\t\t * following:\n\t\t * If the information about the type of the file is easily available\n\t\t * non-directories will be rejected but no extra work will be done to\n\t\t * determine the information for each file. I.e., the caller must still be\n\t\t * able to filter directories out.\n\t\t */\n\t\tif (flags & GLOB_ONLYDIR) {\n\t\t\tzend_stat_t s;\n\n\t\t\tif (0 != VCWD_STAT(globbuf.gl_pathv[n], &s)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (S_IFDIR != (s.st_mode & S_IFMT)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tadd_next_index_string(return_value, globbuf.gl_pathv[n]+cwd_skip);\n\t}\n\n\tglobfree(&globbuf);\n\treturn globbuf.gl_pathc;\n#else\n\tphp_error_docref(NULL, E_ERROR, \"Glob support is not available\");\n\treturn 0;\n#endif  /* HAVE_GLOB */\n}\n/* }}} */\n\nint php_zip_pcre(zend_string *regexp, char *path, int path_len, zval *return_value) /* {{{ */\n{\n#ifdef ZTS\n\tchar cwd[MAXPATHLEN];\n\tint cwd_skip = 0;\n\tchar work_path[MAXPATHLEN];\n\tchar *result;\n#endif\n\tint files_cnt;\n\tzend_string **namelist;\n\n#ifdef ZTS\n\tif (!IS_ABSOLUTE_PATH(path, path_len)) {\n\t\tresult = VCWD_GETCWD(cwd, MAXPATHLEN);\n\t\tif (!result) {\n\t\t\tcwd[0] = '\\0';\n\t\t}\n#ifdef PHP_WIN32\n\t\tif (IS_SLASH(*path)) {\n\t\t\tcwd[2] = '\\0';\n\t\t}\n#endif\n\t\tcwd_skip = strlen(cwd)+1;\n\n\t\tsnprintf(work_path, MAXPATHLEN, \"%s%c%s\", cwd, DEFAULT_SLASH, path);\n\t\tpath = work_path;\n\t}\n#endif\n\n\tif (ZIP_OPENBASEDIR_CHECKPATH(path)) {\n\t\treturn -1;\n\t}\n\n\tfiles_cnt = php_stream_scandir(path, &namelist, NULL, (void *) php_stream_dirent_alphasort);\n\n\tif (files_cnt > 0) {\n\t\tpcre *re = NULL;\n\t\tpcre_extra *pcre_extra = NULL;\n\t\tint preg_options = 0, i;\n\n\t\tre = pcre_get_compiled_regex(regexp, &pcre_extra, &preg_options);\n\t\tif (!re) {\n\t\t\tphp_error_docref(NULL, E_WARNING, \"Invalid expression\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tarray_init(return_value);\n\n\t\t/* only the files, directories are ignored */\n\t\tfor (i = 0; i < files_cnt; i++) {\n\t\t\tzend_stat_t s;\n\t\t\tchar   fullpath[MAXPATHLEN];\n\t\t\tint    ovector[3];\n\t\t\tint    matches;\n\t\t\tint    namelist_len = ZSTR_LEN(namelist[i]);\n\n\t\t\tif ((namelist_len == 1 && ZSTR_VAL(namelist[i])[0] == '.') ||\n\t\t\t\t(namelist_len == 2 && ZSTR_VAL(namelist[i])[0] == '.' && ZSTR_VAL(namelist[i])[1] == '.')) {\n\t\t\t\tzend_string_release(namelist[i]);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif ((path_len + namelist_len + 1) >= MAXPATHLEN) {\n\t\t\t\tphp_error_docref(NULL, E_WARNING, \"add_path string too long (max: %i, %i given)\",\n\t\t\t\t\t\tMAXPATHLEN - 1, (path_len + namelist_len + 1));\n\t\t\t\tzend_string_release(namelist[i]);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tsnprintf(fullpath, MAXPATHLEN, \"%s%c%s\", path, DEFAULT_SLASH, ZSTR_VAL(namelist[i]));\n\n\t\t\tif (0 != VCWD_STAT(fullpath, &s)) {\n\t\t\t\tphp_error_docref(NULL, E_WARNING, \"Cannot read <%s>\", fullpath);\n\t\t\t\tzend_string_release(namelist[i]);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (S_IFDIR == (s.st_mode & S_IFMT)) {\n\t\t\t\tzend_string_release(namelist[i]);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tmatches = pcre_exec(re, NULL, ZSTR_VAL(namelist[i]), ZSTR_LEN(namelist[i]), 0, 0, ovector, 3);\n\t\t\t/* 0 means that the vector is too small to hold all the captured substring offsets */\n\t\t\tif (matches < 0) {\n\t\t\t\tzend_string_release(namelist[i]);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tadd_next_index_string(return_value, fullpath);\n\t\t\tzend_string_release(namelist[i]);\n\t\t}\n\t\tefree(namelist);\n\t}\n\treturn files_cnt;\n}\n/* }}} */\n\n/* {{{ arginfo */\nZEND_BEGIN_ARG_INFO_EX(arginfo_zip_open, 0, 0, 1)\n\tZEND_ARG_INFO(0, filename)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_zip_close, 0, 0, 1)\n\tZEND_ARG_INFO(0, zip)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_zip_read, 0, 0, 1)\n\tZEND_ARG_INFO(0, zip)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_zip_entry_open, 0, 0, 2)\n\tZEND_ARG_INFO(0, zip_dp)\n\tZEND_ARG_INFO(0, zip_entry)\n\tZEND_ARG_INFO(0, mode)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_zip_entry_close, 0, 0, 1)\n\tZEND_ARG_INFO(0, zip_ent)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_zip_entry_read, 0, 0, 1)\n\tZEND_ARG_INFO(0, zip_entry)\n\tZEND_ARG_INFO(0, len)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_zip_entry_name, 0, 0, 1)\n\tZEND_ARG_INFO(0, zip_entry)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_zip_entry_compressedsize, 0, 0, 1)\n\tZEND_ARG_INFO(0, zip_entry)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_zip_entry_filesize, 0, 0, 1)\n\tZEND_ARG_INFO(0, zip_entry)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_zip_entry_compressionmethod, 0, 0, 1)\n\tZEND_ARG_INFO(0, zip_entry)\nZEND_END_ARG_INFO()\n/* }}} */\n\n/* {{{ zend_function_entry */\nstatic const zend_function_entry zip_functions[] = {\n\tZEND_RAW_FENTRY(\"zip_open\", zif_zip_open, arginfo_zip_open, 0)\n\tZEND_RAW_FENTRY(\"zip_close\", zif_zip_close, arginfo_zip_close, 0)\n\tZEND_RAW_FENTRY(\"zip_read\", zif_zip_read, arginfo_zip_read, 0)\n\tPHP_FE(zip_entry_open,\t\targinfo_zip_entry_open)\n\tPHP_FE(zip_entry_close,\t\targinfo_zip_entry_close)\n\tPHP_FE(zip_entry_read,\t\targinfo_zip_entry_read)\n\tPHP_FE(zip_entry_filesize,\targinfo_zip_entry_filesize)\n\tPHP_FE(zip_entry_name,\t\targinfo_zip_entry_name)\n\tPHP_FE(zip_entry_compressedsize,\t\targinfo_zip_entry_compressedsize)\n\tPHP_FE(zip_entry_compressionmethod,\t\targinfo_zip_entry_compressionmethod)\n#ifdef  PHP_FE_END\n\tPHP_FE_END\n#else\n\t{NULL,NULL,NULL}\n#endif\n};\n/* }}} */\n\n/* {{{ ZE2 OO definitions */\nstatic zend_class_entry *zip_class_entry;\nstatic zend_object_handlers zip_object_handlers;\n\nstatic HashTable zip_prop_handlers;\n\ntypedef int (*zip_read_int_t)(struct zip *za);\ntypedef char *(*zip_read_const_char_t)(struct zip *za, int *len);\ntypedef char *(*zip_read_const_char_from_ze_t)(ze_zip_object *obj);\n\ntypedef struct _zip_prop_handler {\n\tzip_read_int_t read_int_func;\n\tzip_read_const_char_t read_const_char_func;\n\tzip_read_const_char_from_ze_t read_const_char_from_obj_func;\n\n\tint type;\n} zip_prop_handler;\n/* }}} */\n\nstatic void php_zip_register_prop_handler(HashTable *prop_handler, char *name, zip_read_int_t read_int_func, zip_read_const_char_t read_char_func, zip_read_const_char_from_ze_t read_char_from_obj_func, int rettype) /* {{{ */\n{\n\tzip_prop_handler hnd;\n\n\thnd.read_const_char_func = read_char_func;\n\thnd.read_int_func = read_int_func;\n\thnd.read_const_char_from_obj_func = read_char_from_obj_func;\n\thnd.type = rettype;\n\tzend_hash_str_add_mem(prop_handler, name, strlen(name), &hnd, sizeof(zip_prop_handler));\n}\n/* }}} */\n\nstatic zval *php_zip_property_reader(ze_zip_object *obj, zip_prop_handler *hnd, zval *rv) /* {{{ */\n{\n\tconst char *retchar = NULL;\n\tint retint = 0;\n\tint len = 0;\n\n\tif (obj && obj->za != NULL) {\n\t\tif (hnd->read_const_char_func) {\n\t\t\tretchar = hnd->read_const_char_func(obj->za, &len);\n\t\t} else {\n\t\t\tif (hnd->read_int_func) {\n\t\t\t\tretint = hnd->read_int_func(obj->za);\n\t\t\t\tif (retint == -1) {\n\t\t\t\t\tphp_error_docref(NULL, E_WARNING, \"Internal zip error returned\");\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (hnd->read_const_char_from_obj_func) {\n\t\t\t\t\tretchar = hnd->read_const_char_from_obj_func(obj);\n\t\t\t\t\tlen = strlen(retchar);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tswitch (hnd->type) {\n\t\tcase IS_STRING:\n\t\t\tif (retchar) {\n\t\t\t\tZVAL_STRINGL(rv, (char *) retchar, len);\n\t\t\t} else {\n\t\t\t\tZVAL_EMPTY_STRING(rv);\n\t\t\t}\n\t\t\tbreak;\n\t\t/* case IS_TRUE */\n\t\tcase IS_FALSE:\n\t\t\tZVAL_BOOL(rv, (long)retint);\n\t\t\tbreak;\n\t\tcase IS_LONG:\n\t\t\tZVAL_LONG(rv, (long)retint);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tZVAL_NULL(rv);\n\t}\n\n\treturn rv;\n}\n/* }}} */\n\nstatic zval *php_zip_get_property_ptr_ptr(zval *object, zval *member, int type, void **cache_slot) /* {{{ */\n{\n\tze_zip_object *obj;\n\tzval tmp_member;\n\tzval *retval = NULL;\n\tzip_prop_handler *hnd = NULL;\n\tzend_object_handlers *std_hnd;\n\n\tif (Z_TYPE_P(member) != IS_STRING) {\n\t\tZVAL_COPY(&tmp_member, member);\n\t\tconvert_to_string(&tmp_member);\n\t\tmember = &tmp_member;\n\t\tcache_slot = NULL;\n\t}\n\n\tobj = Z_ZIP_P(object);\n\n\tif (obj->prop_handler != NULL) {\n\t\thnd = zend_hash_find_ptr(obj->prop_handler, Z_STR_P(member));\n\t}\n\n\tif (hnd == NULL) {\n\t\tstd_hnd = zend_get_std_object_handlers();\n\t\tretval = std_hnd->get_property_ptr_ptr(object, member, type, cache_slot);\n\t}\n\n\tif (member == &tmp_member) {\n\t\tzval_dtor(member);\n\t}\n\n\treturn retval;\n}\n/* }}} */\n\nstatic zval *php_zip_read_property(zval *object, zval *member, int type, void **cache_slot, zval *rv) /* {{{ */\n{\n\tze_zip_object *obj;\n\tzval tmp_member;\n\tzval *retval = NULL;\n\tzip_prop_handler *hnd = NULL;\n\tzend_object_handlers *std_hnd;\n\n\tif (Z_TYPE_P(member) != IS_STRING) {\n\t\tZVAL_COPY(&tmp_member, member);\n\t\tconvert_to_string(&tmp_member);\n\t\tmember = &tmp_member;\n\t\tcache_slot = NULL;\n\t}\n\n\tobj = Z_ZIP_P(object);\n\n\tif (obj->prop_handler != NULL) {\n\t\thnd = zend_hash_find_ptr(obj->prop_handler, Z_STR_P(member));\n\t}\n\n\tif (hnd != NULL) {\n\t\tretval = php_zip_property_reader(obj, hnd, rv);\n\t\tif (retval == NULL) {\n\t\t\tretval = &EG(uninitialized_zval);\n\t\t}\n\t} else {\n\t\tstd_hnd = zend_get_std_object_handlers();\n\t\tretval = std_hnd->read_property(object, member, type, cache_slot, rv);\n\t}\n\n\tif (member == &tmp_member) {\n\t\tzval_dtor(member);\n\t}\n\n\treturn retval;\n}\n/* }}} */\n\nstatic int php_zip_has_property(zval *object, zval *member, int type, void **cache_slot) /* {{{ */\n{\n\tze_zip_object *obj;\n\tzval tmp_member;\n\tzip_prop_handler *hnd = NULL;\n\tzend_object_handlers *std_hnd;\n\tint retval = 0;\n\n\tif (Z_TYPE_P(member) != IS_STRING) {\n\t\tZVAL_COPY(&tmp_member, member);\n\t\tconvert_to_string(&tmp_member);\n\t\tmember = &tmp_member;\n\t\tcache_slot = NULL;\n\t}\n\n\tobj = Z_ZIP_P(object);\n\n\tif (obj->prop_handler != NULL) {\n\t\thnd = zend_hash_find_ptr(obj->prop_handler, Z_STR_P(member));\n\t}\n\n\tif (hnd != NULL) {\n\t\tzval tmp, *prop;\n\n\t\tif (type == 2) {\n\t\t\tretval = 1;\n\t\t} else if ((prop = php_zip_property_reader(obj, hnd, &tmp)) != NULL) {\n\t\t\tif (type == 1) {\n\t\t\t\tretval = zend_is_true(&tmp);\n\t\t\t} else if (type == 0) {\n\t\t\t\tretval = (Z_TYPE(tmp) != IS_NULL);\n\t\t\t}\n\t\t}\n\n\t\tzval_ptr_dtor(&tmp);\n\t} else {\n\t\tstd_hnd = zend_get_std_object_handlers();\n\t\tretval = std_hnd->has_property(object, member, type, cache_slot);\n\t}\n\n\tif (member == &tmp_member) {\n\t\tzval_dtor(member);\n\t}\n\n\treturn retval;\n}\n/* }}} */\n\nstatic HashTable *php_zip_get_properties(zval *object)/* {{{ */\n{\n\tze_zip_object *obj;\n\tHashTable *props;\n\tzip_prop_handler *hnd;\n\tzend_string *key;\n\n\tobj = Z_ZIP_P(object);\n\tprops = zend_std_get_properties(object);\n\n\tif (obj->prop_handler == NULL) {\n\t\treturn NULL;\n\t}\n\n\tZEND_HASH_FOREACH_STR_KEY_PTR(obj->prop_handler, key, hnd) {\n\t\tzval *ret, val;\n\t\tret = php_zip_property_reader(obj, hnd, &val);\n\t\tif (ret == NULL) {\n\t\t\tret = &EG(uninitialized_zval);\n\t\t}\n\t\tzend_hash_update(props, key, ret);\n\t} ZEND_HASH_FOREACH_END();\n\n\treturn props;\n}\n/* }}} */\n\nstatic void php_zip_object_free_storage(zend_object *object) /* {{{ */\n{\n\tze_zip_object * intern = php_zip_fetch_object(object);\n\tint i;\n\n\tif (!intern) {\n\t\treturn;\n\t}\n\tif (intern->za) {\n\t\tif (zip_close(intern->za) != 0) {\n\t\t\tphp_error_docref(NULL, E_WARNING, \"Cannot destroy the zip context: %s\", zip_strerror(intern->za));\n\t\t\treturn;\n\t\t}\n\t\tintern->za = NULL;\n\t}\n\n\tif (intern->buffers_cnt>0) {\n\t\tfor (i=0; i<intern->buffers_cnt; i++) {\n\t\t\tefree(intern->buffers[i]);\n\t\t}\n\t\tefree(intern->buffers);\n\t}\n\n\tintern->za = NULL;\n\tzend_object_std_dtor(&intern->zo);\n\n\tif (intern->filename) {\n\t\tefree(intern->filename);\n\t}\n}\n/* }}} */\n\nstatic zend_object *php_zip_object_new(zend_class_entry *class_type) /* {{{ */\n{\n\tze_zip_object *intern;\n\n\tintern = ecalloc(1, sizeof(ze_zip_object) + zend_object_properties_size(class_type));\n\tintern->prop_handler = &zip_prop_handlers;\n\tzend_object_std_init(&intern->zo, class_type);\n\tobject_properties_init(&intern->zo, class_type);\n\tintern->zo.handlers = &zip_object_handlers;\n\n\treturn &intern->zo;\n}\n/* }}} */\n\n/* {{{ Resource dtors */\n\n/* {{{ php_zip_free_dir */\nstatic void php_zip_free_dir(zend_resource *rsrc)\n{\n\tzip_rsrc * zip_int = (zip_rsrc *) rsrc->ptr;\n\n\tif (zip_int) {\n\t\tif (zip_int->za) {\n\t\t\tif (zip_close(zip_int->za) != 0) {\n\t\t\t\tphp_error_docref(NULL, E_WARNING, \"Cannot destroy the zip context\");\n\t\t\t}\n\t\t\tzip_int->za = NULL;\n\t\t}\n\n\t\tefree(rsrc->ptr);\n\n\t\trsrc->ptr = NULL;\n\t}\n}\n/* }}} */\n\n/* {{{ php_zip_free_entry */\nstatic void php_zip_free_entry(zend_resource *rsrc)\n{\n\tzip_read_rsrc *zr_rsrc = (zip_read_rsrc *) rsrc->ptr;\n\n\tif (zr_rsrc) {\n\t\tif (zr_rsrc->zf) {\n\t\t\tzip_fclose(zr_rsrc->zf);\n\t\t\tzr_rsrc->zf = NULL;\n\t\t}\n\t\tefree(zr_rsrc);\n\t\trsrc->ptr = NULL;\n\t}\n}\n/* }}} */\n\n/* }}}*/\n\n/* reset macro */\n\n/* {{{ function prototypes */\nstatic PHP_MINIT_FUNCTION(zip);\nstatic PHP_MSHUTDOWN_FUNCTION(zip);\nstatic PHP_MINFO_FUNCTION(zip);\n/* }}} */\n\n/* {{{ zip_module_entry\n */\nzend_module_entry zip_module_entry = {\n\tSTANDARD_MODULE_HEADER,\n\t\"zip\",\n\tzip_functions,\n\tPHP_MINIT(zip),\n\tPHP_MSHUTDOWN(zip),\n\tNULL,\n\tNULL,\n\tPHP_MINFO(zip),\n\tPHP_ZIP_VERSION,\n\tSTANDARD_MODULE_PROPERTIES\n};\n/* }}} */\n\n#ifdef COMPILE_DL_ZIP\nZEND_GET_MODULE(zip)\n#endif\n/* set macro */\n\n/* {{{ proto resource zip_open(string filename)\nCreate new zip using source uri for output */\nstatic PHP_NAMED_FUNCTION(zif_zip_open)\n{\n\tchar resolved_path[MAXPATHLEN + 1];\n\tzip_rsrc *rsrc_int;\n\tint err = 0;\n\tzend_string *filename;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"P\", &filename) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (ZSTR_LEN(filename) == 0) {\n\t\tphp_error_docref(NULL, E_WARNING, \"Empty string as source\");\n\t\tRETURN_FALSE;\n\t}\n\n\tif (ZIP_OPENBASEDIR_CHECKPATH(ZSTR_VAL(filename))) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif(!expand_filepath(ZSTR_VAL(filename), resolved_path)) {\n\t\tRETURN_FALSE;\n\t}\n\n\trsrc_int = (zip_rsrc *)emalloc(sizeof(zip_rsrc));\n\n\trsrc_int->za = zip_open(resolved_path, 0, &err);\n\tif (rsrc_int->za == NULL) {\n\t\tefree(rsrc_int);\n\t\tRETURN_LONG((zend_long)err);\n\t}\n\n\trsrc_int->index_current = 0;\n\trsrc_int->num_files = zip_get_num_files(rsrc_int->za);\n\n\tRETURN_RES(zend_register_resource(rsrc_int, le_zip_dir));\n}\n/* }}} */\n\n/* {{{ proto void zip_close(resource zip)\n   Close a Zip archive */\nstatic PHP_NAMED_FUNCTION(zif_zip_close)\n{\n\tzval * zip;\n\tzip_rsrc *z_rsrc = NULL;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"r\", &zip) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif ((z_rsrc = (zip_rsrc *)zend_fetch_resource(Z_RES_P(zip), le_zip_dir_name, le_zip_dir)) == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\n\t/* really close the zip will break BC :-D */\n\tzend_list_close(Z_RES_P(zip));\n}\n/* }}} */\n\n/* {{{ proto resource zip_read(resource zip)\n   Returns the next file in the archive */\nstatic PHP_NAMED_FUNCTION(zif_zip_read)\n{\n\tzval *zip_dp;\n\tzip_read_rsrc *zr_rsrc;\n\tint ret;\n\tzip_rsrc *rsrc_int;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"r\", &zip_dp) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif ((rsrc_int = (zip_rsrc *)zend_fetch_resource(Z_RES_P(zip_dp), le_zip_dir_name, le_zip_dir)) == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (rsrc_int && rsrc_int->za) {\n\t\tif (rsrc_int->index_current >= rsrc_int->num_files) {\n\t\t\tRETURN_FALSE;\n\t\t}\n\n\t\tzr_rsrc = emalloc(sizeof(zip_read_rsrc));\n\n\t\tret = zip_stat_index(rsrc_int->za, rsrc_int->index_current, 0, &zr_rsrc->sb);\n\n\t\tif (ret != 0) {\n\t\t\tefree(zr_rsrc);\n\t\t\tRETURN_FALSE;\n\t\t}\n\n\t\tzr_rsrc->zf = zip_fopen_index(rsrc_int->za, rsrc_int->index_current, 0);\n\t\tif (zr_rsrc->zf) {\n\t\t\trsrc_int->index_current++;\n\t\t\tRETURN_RES(zend_register_resource(zr_rsrc, le_zip_entry));\n\t\t} else {\n\t\t\tefree(zr_rsrc);\n\t\t\tRETURN_FALSE;\n\t\t}\n\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n}\n/* }}} */\n\n/* {{{ proto bool zip_entry_open(resource zip_dp, resource zip_entry [, string mode])\n   Open a Zip File, pointed by the resource entry */\n/* Dummy function to follow the old API */\nstatic PHP_NAMED_FUNCTION(zif_zip_entry_open)\n{\n\tzval * zip;\n\tzval * zip_entry;\n\tchar *mode = NULL;\n\tsize_t mode_len = 0;\n\tzip_read_rsrc * zr_rsrc;\n\tzip_rsrc *z_rsrc;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"rr|s\", &zip, &zip_entry, &mode, &mode_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif ((zr_rsrc = (zip_read_rsrc *)zend_fetch_resource(Z_RES_P(zip_entry), le_zip_entry_name, le_zip_entry)) == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif ((z_rsrc = (zip_rsrc *)zend_fetch_resource(Z_RES_P(zip), le_zip_dir_name, le_zip_dir)) == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (zr_rsrc->zf != NULL) {\n\t\tRETURN_TRUE;\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n}\n/* }}} */\n\n/* {{{ proto bool zip_entry_close(resource zip_ent)\n   Close a zip entry */\nstatic PHP_NAMED_FUNCTION(zif_zip_entry_close)\n{\n\tzval * zip_entry;\n\tzip_read_rsrc * zr_rsrc;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"r\", &zip_entry) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif ((zr_rsrc = (zip_read_rsrc *)zend_fetch_resource(Z_RES_P(zip_entry), le_zip_entry_name, le_zip_entry)) == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\n\tRETURN_BOOL(SUCCESS == zend_list_close(Z_RES_P(zip_entry)));\n}\n/* }}} */\n\n/* {{{ proto mixed zip_entry_read(resource zip_entry [, int len])\n   Read from an open directory entry */\nstatic PHP_NAMED_FUNCTION(zif_zip_entry_read)\n{\n\tzval * zip_entry;\n\tzend_long len = 0;\n\tzip_read_rsrc * zr_rsrc;\n\tzend_string *buffer;\n\tint n = 0;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"r|l\", &zip_entry, &len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif ((zr_rsrc = (zip_read_rsrc *)zend_fetch_resource(Z_RES_P(zip_entry), le_zip_entry_name, le_zip_entry)) == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (len <= 0) {\n\t\tlen = 1024;\n\t}\n\n\tif (zr_rsrc->zf) {\n\t\tbuffer = zend_string_safe_alloc(1, len, 0, 0);\n\t\tn = zip_fread(zr_rsrc->zf, ZSTR_VAL(buffer), ZSTR_LEN(buffer));\n\t\tif (n > 0) {\n\t\t\tZSTR_VAL(buffer)[n] = '\\0';\n\t\t\tZSTR_LEN(buffer) = n;\n\t\t\tRETURN_NEW_STR(buffer);\n\t\t} else {\n\t\t\tzend_string_free(buffer);\n\t\t\tRETURN_EMPTY_STRING()\n\t\t}\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n}\n/* }}} */\n\nstatic void php_zip_entry_get_info(INTERNAL_FUNCTION_PARAMETERS, int opt) /* {{{ */\n{\n\tzval * zip_entry;\n\tzip_read_rsrc * zr_rsrc;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"r\", &zip_entry) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif ((zr_rsrc = (zip_read_rsrc *)zend_fetch_resource(Z_RES_P(zip_entry), le_zip_entry_name, le_zip_entry)) == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (!zr_rsrc->zf) {\n\t\tRETURN_FALSE;\n\t}\n\n\tswitch (opt) {\n\t\tcase 0:\n\t\t\tRETURN_STRING((char *)zr_rsrc->sb.name);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tRETURN_LONG((zend_long) (zr_rsrc->sb.comp_size));\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tRETURN_LONG((zend_long) (zr_rsrc->sb.size));\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tswitch (zr_rsrc->sb.comp_method) {\n\t\t\t\tcase 0:\n\t\t\t\t\tRETURN_STRING(\"stored\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tRETURN_STRING(\"shrunk\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\tcase 3:\n\t\t\t\tcase 4:\n\t\t\t\tcase 5:\n\t\t\t\t\tRETURN_STRING(\"reduced\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase 6:\n\t\t\t\t\tRETURN_STRING(\"imploded\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase 7:\n\t\t\t\t\tRETURN_STRING(\"tokenized\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase 8:\n\t\t\t\t\tRETURN_STRING(\"deflated\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase 9:\n\t\t\t\t\tRETURN_STRING(\"deflatedX\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase 10:\n\t\t\t\t\tRETURN_STRING(\"implodedX\");\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\t\t\tRETURN_LONG((zend_long) (zr_rsrc->sb.comp_method));\n\t\t\tbreak;\n\t}\n\n}\n/* }}} */\n\n/* {{{ proto string zip_entry_name(resource zip_entry)\n   Return the name given a ZZip entry */\nstatic PHP_NAMED_FUNCTION(zif_zip_entry_name)\n{\n\tphp_zip_entry_get_info(INTERNAL_FUNCTION_PARAM_PASSTHRU, 0);\n}\n/* }}} */\n\n/* {{{ proto int zip_entry_compressedsize(resource zip_entry)\n   Return the compressed size of a ZZip entry */\nstatic PHP_NAMED_FUNCTION(zif_zip_entry_compressedsize)\n{\n\tphp_zip_entry_get_info(INTERNAL_FUNCTION_PARAM_PASSTHRU, 1);\n}\n/* }}} */\n\n/* {{{ proto int zip_entry_filesize(resource zip_entry)\n   Return the actual filesize of a ZZip entry */\nstatic PHP_NAMED_FUNCTION(zif_zip_entry_filesize)\n{\n\tphp_zip_entry_get_info(INTERNAL_FUNCTION_PARAM_PASSTHRU, 2);\n}\n/* }}} */\n\n/* {{{ proto string zip_entry_compressionmethod(resource zip_entry)\n   Return a string containing the compression method used on a particular entry */\nstatic PHP_NAMED_FUNCTION(zif_zip_entry_compressionmethod)\n{\n\tphp_zip_entry_get_info(INTERNAL_FUNCTION_PARAM_PASSTHRU, 3);\n}\n/* }}} */\n\n/* {{{ proto mixed ZipArchive::open(string source [, int flags])\nCreate new zip using source uri for output, return TRUE on success or the error code */\nstatic ZIPARCHIVE_METHOD(open)\n{\n\tstruct zip *intern;\n\tint err = 0;\n\tzend_long flags = 0;\n\tchar *resolved_path;\n\tzend_string *filename;\n\tzval *self = getThis();\n\tze_zip_object *ze_obj = NULL;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"P|l\", &filename, &flags) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (self) {\n\t\t/* We do not use ZIP_FROM_OBJECT, zip init function here */\n\t\tze_obj = Z_ZIP_P(self);\n\t}\n\n\tif (ZSTR_LEN(filename) == 0) {\n\t\tphp_error_docref(NULL, E_WARNING, \"Empty string as source\");\n\t\tRETURN_FALSE;\n\t}\n\n\tif (ZIP_OPENBASEDIR_CHECKPATH(ZSTR_VAL(filename))) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (!(resolved_path = expand_filepath(ZSTR_VAL(filename), NULL))) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (ze_obj->za) {\n\t\t/* we already have an opened zip, free it */\n\t\tif (zip_close(ze_obj->za) != 0) {\n\t\t\tphp_error_docref(NULL, E_WARNING, \"Empty string as source\");\n\t\t\tefree(resolved_path);\n\t\t\tRETURN_FALSE;\n\t\t}\n\t\tze_obj->za = NULL;\n\t}\n\tif (ze_obj->filename) {\n\t\tefree(ze_obj->filename);\n\t\tze_obj->filename = NULL;\n\t}\n\n\tintern = zip_open(resolved_path, flags, &err);\n\tif (!intern || err) {\n\t\tefree(resolved_path);\n\t\tRETURN_LONG((zend_long)err);\n\t}\n\tze_obj->filename = resolved_path;\n\tze_obj->filename_len = strlen(resolved_path);\n\tze_obj->za = intern;\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ proto resource ZipArchive::setPassword(string password)\nSet the password for the active archive */\nstatic ZIPARCHIVE_METHOD(setPassword)\n{\n\tstruct zip *intern;\n\tzval *self = getThis();\n\tchar *password;\n\tsize_t\tpassword_len;\n\n\tif (!self) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"s\", &password, &password_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (password_len < 1) {\n\t\tRETURN_FALSE;\n\t} else {\n\t\tint res = zip_set_default_password(intern, (const char *)password);\n\t\tif (res == 0) {\n\t\t\tRETURN_TRUE;\n\t\t} else {\n\t\t\tRETURN_FALSE;\n\t\t}\n\t}\n}\n/* }}} */\n\n/* {{{ proto bool ZipArchive::close()\nclose the zip archive */\nstatic ZIPARCHIVE_METHOD(close)\n{\n\tstruct zip *intern;\n\tzval *self = getThis();\n\tze_zip_object *ze_obj;\n\tint err;\n\n\tif (!self) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tze_obj = Z_ZIP_P(self);\n\n\tif ((err = zip_close(intern))) {\n\t\tphp_error_docref(NULL, E_WARNING, \"%s\", zip_strerror(intern));\n\t\tzip_discard(intern);\n\t}\n\n\tefree(ze_obj->filename);\n\tze_obj->filename = NULL;\n\tze_obj->filename_len = 0;\n\tze_obj->za = NULL;\n\n\tif (!err) {\n\t\tRETURN_TRUE;\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n}\n/* }}} */\n\n/* {{{ proto string ZipArchive::getStatusString()\n * Returns the status error message, system and/or zip messages */\nstatic ZIPARCHIVE_METHOD(getStatusString)\n{\n\tstruct zip *intern;\n\tzval *self = getThis();\n#if LIBZIP_VERSION_MAJOR < 1\n\tint zep, syp, len;\n\tchar error_string[128];\n#else\n\tzip_error_t *err;\n#endif\n\n\tif (!self) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n#if LIBZIP_VERSION_MAJOR < 1\n\tzip_error_get(intern, &zep, &syp);\n\n\tlen = zip_error_to_str(error_string, 128, zep, syp);\n\tRETVAL_STRINGL(error_string, len);\n#else\n\terr = zip_get_error(intern);\n\tRETVAL_STRING(zip_error_strerror(err));\n\tzip_error_fini(err);\n#endif\n}\n/* }}} */\n\n/* {{{ proto bool ZipArchive::createEmptyDir(string dirname)\nReturns the index of the entry named filename in the archive */\nstatic ZIPARCHIVE_METHOD(addEmptyDir)\n{\n\tstruct zip *intern;\n\tzval *self = getThis();\n\tchar *dirname;\n\tsize_t   dirname_len;\n\tint idx;\n\tstruct zip_stat sb;\n\tchar *s;\n\n\tif (!self) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"s\",\n\t\t\t\t&dirname, &dirname_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (dirname_len<1) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (dirname[dirname_len-1] != '/') {\n\t\ts=(char *)emalloc(dirname_len+2);\n\t\tstrcpy(s, dirname);\n\t\ts[dirname_len] = '/';\n\t\ts[dirname_len+1] = '\\0';\n\t} else {\n\t\ts = dirname;\n\t}\n\n\tidx = zip_stat(intern, s, 0, &sb);\n\tif (idx >= 0) {\n\t\tRETVAL_FALSE;\n\t} else {\n\t\tif (zip_add_dir(intern, (const char *)s) == -1) {\n\t\t\tRETVAL_FALSE;\n\t\t}\n\t\tzip_error_clear(intern);\n\t\tRETVAL_TRUE;\n\t}\n\n\tif (s != dirname) {\n\t\tefree(s);\n\t}\n}\n/* }}} */\n\nstatic void php_zip_add_from_pattern(INTERNAL_FUNCTION_PARAMETERS, int type) /* {{{ */\n{\n\tstruct zip *intern;\n\tzval *self = getThis();\n\tchar *path = NULL;\n\tchar *remove_path = NULL;\n\tchar *add_path = NULL;\n\tsize_t  add_path_len, remove_path_len = 0, path_len = 0;\n\tzend_long remove_all_path = 0;\n\tzend_long flags = 0;\n\tzval *options = NULL;\n\tint found;\n\tzend_string *pattern;\n\n\tif (!self) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\t/* 1 == glob, 2 == pcre */\n\tif (type == 1) {\n\t\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"P|la\",\n\t\t\t\t\t&pattern, &flags, &options) == FAILURE) {\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"P|sa\",\n\t\t\t\t\t&pattern, &path, &path_len, &options) == FAILURE) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (ZSTR_LEN(pattern) == 0) {\n\t\tphp_error_docref(NULL, E_NOTICE, \"Empty string as pattern\");\n\t\tRETURN_FALSE;\n\t}\n\tif (options && (php_zip_parse_options(options, &remove_all_path, &remove_path, &remove_path_len,\n\t\t\t&add_path, &add_path_len) < 0)) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (remove_path && remove_path_len > 1) {\n\t\tsize_t real_len = strlen(remove_path);\n\t\tif ((real_len > 1) && ((remove_path[real_len - 1] == '/') || (remove_path[real_len - 1] == '\\\\'))) {\n\t\t\tremove_path[real_len - 1] = '\\0';\n\t\t}\n\t}\n\n\tif (type == 1) {\n\t\tfound = php_zip_glob(ZSTR_VAL(pattern), ZSTR_LEN(pattern), flags, return_value);\n\t} else {\n\t\tfound = php_zip_pcre(pattern, path, path_len, return_value);\n\t}\n\n\tif (found > 0) {\n\t\tint i;\n\t\tzval *zval_file;\n\n\t\tfor (i = 0; i < found; i++) {\n\t\t\tchar *file_stripped, *entry_name;\n\t\t\tsize_t entry_name_len, file_stripped_len;\n\t\t\tchar entry_name_buf[MAXPATHLEN];\n\t\t\tzend_string *basename = NULL;\n\n\t\t\tif ((zval_file = zend_hash_index_find(Z_ARRVAL_P(return_value), i)) != NULL) {\n\t\t\t\tif (remove_all_path) {\n\t\t\t\t\tbasename = php_basename(Z_STRVAL_P(zval_file), Z_STRLEN_P(zval_file), NULL, 0);\n\t\t\t\t\tfile_stripped = ZSTR_VAL(basename);\n\t\t\t\t\tfile_stripped_len = ZSTR_LEN(basename);\n\t\t\t\t} else if (remove_path && strstr(Z_STRVAL_P(zval_file), remove_path) != NULL) {\n\t\t\t\t\tfile_stripped = Z_STRVAL_P(zval_file) + remove_path_len + 1;\n\t\t\t\t\tfile_stripped_len = Z_STRLEN_P(zval_file) - remove_path_len - 1;\n\t\t\t\t} else {\n\t\t\t\t\tfile_stripped = Z_STRVAL_P(zval_file);\n\t\t\t\t\tfile_stripped_len = Z_STRLEN_P(zval_file);\n\t\t\t\t}\n\n\t\t\t\tif (add_path) {\n\t\t\t\t\tif ((add_path_len + file_stripped_len) > MAXPATHLEN) {\n\t\t\t\t\t\tphp_error_docref(NULL, E_WARNING, \"Entry name too long (max: %d, %pd given)\",\n\t\t\t\t\t\tMAXPATHLEN - 1, (add_path_len + file_stripped_len));\n\t\t\t\t\t\tzval_ptr_dtor(return_value);\n\t\t\t\t\t\tRETURN_FALSE;\n\t\t\t\t\t}\n\n\t\t\t\t\tsnprintf(entry_name_buf, MAXPATHLEN, \"%s%s\", add_path, file_stripped);\n\t\t\t\t\tentry_name = entry_name_buf;\n\t\t\t\t\tentry_name_len = strlen(entry_name);\n\t\t\t\t} else {\n\t\t\t\t\tentry_name = Z_STRVAL_P(zval_file);\n\t\t\t\t\tentry_name_len = Z_STRLEN_P(zval_file);\n\t\t\t\t}\n\t\t\t\tif (basename) {\n\t\t\t\t\tzend_string_release(basename);\n\t\t\t\t\tbasename = NULL;\n\t\t\t\t}\n\t\t\t\tif (php_zip_add_file(intern, Z_STRVAL_P(zval_file), Z_STRLEN_P(zval_file),\n\t\t\t\t\tentry_name, entry_name_len, 0, 0) < 0) {\n\t\t\t\t\tzval_dtor(return_value);\n\t\t\t\t\tRETURN_FALSE;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n/* }}} */\n\n/* {{{ proto bool ZipArchive::addGlob(string pattern[,int flags [, array options]])\nAdd files matching the glob pattern. See php's glob for the pattern syntax. */\nstatic ZIPARCHIVE_METHOD(addGlob)\n{\n\tphp_zip_add_from_pattern(INTERNAL_FUNCTION_PARAM_PASSTHRU, 1);\n}\n/* }}} */\n\n/* {{{ proto bool ZipArchive::addPattern(string pattern[, string path [, array options]])\nAdd files matching the pcre pattern. See php's pcre for the pattern syntax. */\nstatic ZIPARCHIVE_METHOD(addPattern)\n{\n\tphp_zip_add_from_pattern(INTERNAL_FUNCTION_PARAM_PASSTHRU, 2);\n}\n/* }}} */\n\n/* {{{ proto bool ZipArchive::addFile(string filepath[, string entryname[, int start [, int length]]])\nAdd a file in a Zip archive using its path and the name to use. */\nstatic ZIPARCHIVE_METHOD(addFile)\n{\n\tstruct zip *intern;\n\tzval *self = getThis();\n\tchar *entry_name = NULL;\n\tsize_t entry_name_len = 0;\n\tzend_long offset_start = 0, offset_len = 0;\n\tzend_string *filename;\n\n\tif (!self) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"P|sll\",\n\t\t\t&filename, &entry_name, &entry_name_len, &offset_start, &offset_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (ZSTR_LEN(filename) == 0) {\n\t\tphp_error_docref(NULL, E_NOTICE, \"Empty string as filename\");\n\t\tRETURN_FALSE;\n\t}\n\n\tif (entry_name_len == 0) {\n\t\tentry_name = ZSTR_VAL(filename);\n\t\tentry_name_len = ZSTR_LEN(filename);\n\t}\n\n\tif (php_zip_add_file(intern, ZSTR_VAL(filename), ZSTR_LEN(filename), entry_name, entry_name_len, 0, 0) < 0) {\n\t\tRETURN_FALSE;\n\t} else {\n\t\tRETURN_TRUE;\n\t}\n}\n/* }}} */\n\n/* {{{ proto bool ZipArchive::addFromString(string name, string content)\nAdd a file using content and the entry name */\nstatic ZIPARCHIVE_METHOD(addFromString)\n{\n\tstruct zip *intern;\n\tzval *self = getThis();\n\tzend_string *buffer;\n\tchar *name;\n\tsize_t name_len;\n\tze_zip_object *ze_obj;\n\tstruct zip_source *zs;\n\tint pos = 0;\n\tint cur_idx;\n\n\tif (!self) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"sS\",\n\t\t\t&name, &name_len, &buffer) == FAILURE) {\n\t\treturn;\n\t}\n\n\tze_obj = Z_ZIP_P(self);\n\tif (ze_obj->buffers_cnt) {\n\t\tze_obj->buffers = (char **)erealloc(ze_obj->buffers, sizeof(char *) * (ze_obj->buffers_cnt+1));\n\t\tpos = ze_obj->buffers_cnt++;\n\t} else {\n\t\tze_obj->buffers = (char **)emalloc(sizeof(char *));\n\t\tze_obj->buffers_cnt++;\n\t\tpos = 0;\n\t}\n\tze_obj->buffers[pos] = (char *)emalloc(ZSTR_LEN(buffer) + 1);\n\tmemcpy(ze_obj->buffers[pos], ZSTR_VAL(buffer), ZSTR_LEN(buffer) + 1);\n\n\tzs = zip_source_buffer(intern, ze_obj->buffers[pos], ZSTR_LEN(buffer), 0);\n\n\tif (zs == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\n\tcur_idx = zip_name_locate(intern, (const char *)name, 0);\n\t/* TODO: fix  _zip_replace */\n\tif (cur_idx >= 0) {\n\t\tif (zip_delete(intern, cur_idx) == -1) {\n\t\t\tzip_source_free(zs);\n\t\t\tRETURN_FALSE;\n\t\t}\n\t}\n\n\tif (zip_add(intern, name, zs) == -1) {\n\t\tzip_source_free(zs);\n\t\tRETURN_FALSE;\n\t} else {\n\t\tzip_error_clear(intern);\n\t\tRETURN_TRUE;\n\t}\n}\n/* }}} */\n\n/* {{{ proto array ZipArchive::statName(string filename[, int flags])\nReturns the information about a the zip entry filename */\nstatic ZIPARCHIVE_METHOD(statName)\n{\n\tstruct zip *intern;\n\tzval *self = getThis();\n\tzend_long flags = 0;\n\tstruct zip_stat sb;\n\tzend_string *name;\n\n\tif (!self) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"P|l\", &name, &flags) == FAILURE) {\n\t\treturn;\n\t}\n\n\tPHP_ZIP_STAT_PATH(intern, ZSTR_VAL(name), ZSTR_LEN(name), flags, sb);\n\n\tRETURN_SB(&sb);\n}\n/* }}} */\n\n/* {{{ proto resource ZipArchive::statIndex(int index[, int flags])\nReturns the zip entry informations using its index */\nstatic ZIPARCHIVE_METHOD(statIndex)\n{\n\tstruct zip *intern;\n\tzval *self = getThis();\n\tzend_long index, flags = 0;\n\n\tstruct zip_stat sb;\n\n\tif (!self) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"l|l\",\n\t\t\t&index, &flags) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (zip_stat_index(intern, index, flags, &sb) != 0) {\n\t\tRETURN_FALSE;\n\t}\n\tRETURN_SB(&sb);\n}\n/* }}} */\n\n/* {{{ proto int ZipArchive::locateName(string filename[, int flags])\nReturns the index of the entry named filename in the archive */\nstatic ZIPARCHIVE_METHOD(locateName)\n{\n\tstruct zip *intern;\n\tzval *self = getThis();\n\tzend_long flags = 0;\n\tzend_long idx = -1;\n\tzend_string *name;\n\n\tif (!self) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"P|l\", &name, &flags) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (ZSTR_LEN(name) < 1) {\n\t\tRETURN_FALSE;\n\t}\n\n\tidx = (zend_long)zip_name_locate(intern, (const char *)ZSTR_VAL(name), flags);\n\n\tif (idx >= 0) {\n\t\tRETURN_LONG(idx);\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n}\n/* }}} */\n\n/* {{{ proto string ZipArchive::getNameIndex(int index [, int flags])\nReturns the name of the file at position index */\nstatic ZIPARCHIVE_METHOD(getNameIndex)\n{\n\tstruct zip *intern;\n\tzval *self = getThis();\n\tconst char *name;\n\tzend_long flags = 0, index = 0;\n\n\tif (!self) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"l|l\",\n\t\t\t&index, &flags) == FAILURE) {\n\t\treturn;\n\t}\n\n\tname = zip_get_name(intern, (int) index, flags);\n\n\tif (name) {\n\t\tRETVAL_STRING((char *)name);\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n}\n/* }}} */\n\n/* {{{ proto bool ZipArchive::setArchiveComment(string comment)\nSet or remove (NULL/'') the comment of the archive */\nstatic ZIPARCHIVE_METHOD(setArchiveComment)\n{\n\tstruct zip *intern;\n\tzval *self = getThis();\n\tsize_t comment_len;\n\tchar * comment;\n\n\tif (!self) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"s\", &comment, &comment_len) == FAILURE) {\n\t\treturn;\n\t}\n\tif (zip_set_archive_comment(intern, (const char *)comment, (int)comment_len)) {\n\t\tRETURN_FALSE;\n\t} else {\n\t\tRETURN_TRUE;\n\t}\n}\n/* }}} */\n\n/* {{{ proto string ZipArchive::getArchiveComment([int flags])\nReturns the comment of an entry using its index */\nstatic ZIPARCHIVE_METHOD(getArchiveComment)\n{\n\tstruct zip *intern;\n\tzval *self = getThis();\n\tzend_long flags = 0;\n\tconst char * comment;\n\tint comment_len = 0;\n\n\tif (!self) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"|l\", &flags) == FAILURE) {\n\t\treturn;\n\t}\n\n\tcomment = zip_get_archive_comment(intern, &comment_len, (int)flags);\n\tif(comment==NULL) {\n\t\tRETURN_FALSE;\n\t}\n\tRETURN_STRINGL((char *)comment, (zend_long)comment_len);\n}\n/* }}} */\n\n/* {{{ proto bool ZipArchive::setCommentName(string name, string comment)\nSet or remove (NULL/'') the comment of an entry using its Name */\nstatic ZIPARCHIVE_METHOD(setCommentName)\n{\n\tstruct zip *intern;\n\tzval *self = getThis();\n\tsize_t comment_len, name_len;\n\tchar * comment, *name;\n\tint idx;\n\n\tif (!self) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"ss\",\n\t\t\t&name, &name_len, &comment, &comment_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (name_len < 1) {\n\t\tphp_error_docref(NULL, E_NOTICE, \"Empty string as entry name\");\n\t}\n\n\tidx = zip_name_locate(intern, name, 0);\n\tif (idx < 0) {\n\t\tRETURN_FALSE;\n\t}\n\tPHP_ZIP_SET_FILE_COMMENT(intern, idx, comment, comment_len);\n}\n/* }}} */\n\n/* {{{ proto bool ZipArchive::setCommentIndex(int index, string comment)\nSet or remove (NULL/'') the comment of an entry using its index */\nstatic ZIPARCHIVE_METHOD(setCommentIndex)\n{\n\tstruct zip *intern;\n\tzval *self = getThis();\n\tzend_long index;\n\tsize_t comment_len;\n\tchar * comment;\n\tstruct zip_stat sb;\n\n\tif (!self) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"ls\",\n\t\t\t&index, &comment, &comment_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tPHP_ZIP_STAT_INDEX(intern, index, 0, sb);\n\tPHP_ZIP_SET_FILE_COMMENT(intern, index, comment, comment_len);\n}\n/* }}} */\n\n/* those constants/functions are only available in libzip since 0.11.2 */\n#ifdef ZIP_OPSYS_DEFAULT\n\n/* {{{ proto bool ZipArchive::setExternalAttributesName(string name, int opsys, int attr [, int flags])\nSet external attributes for file in zip, using its name */\nstatic ZIPARCHIVE_METHOD(setExternalAttributesName)\n{\n\tstruct zip *intern;\n\tzval *self = getThis();\n\tsize_t name_len;\n\tchar *name;\n\tzend_long flags=0, opsys, attr;\n\tzip_int64_t idx;\n\n\tif (!self) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"sll|l\",\n\t\t\t&name, &name_len, &opsys, &attr, &flags) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (name_len < 1) {\n\t\tphp_error_docref(NULL, E_NOTICE, \"Empty string as entry name\");\n\t}\n\n\tidx = zip_name_locate(intern, name, 0);\n\tif (idx < 0) {\n\t\tRETURN_FALSE;\n\t}\n\tif (zip_file_set_external_attributes(intern, idx, (zip_flags_t)flags,\n\t\t\t(zip_uint8_t)(opsys&0xff), (zip_uint32_t)attr) < 0) {\n\t\tRETURN_FALSE;\n\t}\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ proto bool ZipArchive::setExternalAttributesIndex(int index, int opsys, int attr [, int flags])\nSet external attributes for file in zip, using its index */\nstatic ZIPARCHIVE_METHOD(setExternalAttributesIndex)\n{\n\tstruct zip *intern;\n\tzval *self = getThis();\n\tzend_long index, flags=0, opsys, attr;\n\tstruct zip_stat sb;\n\n\tif (!self) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"lll|l\",\n\t\t\t&index, &opsys, &attr, &flags) == FAILURE) {\n\t\treturn;\n\t}\n\n\tPHP_ZIP_STAT_INDEX(intern, index, 0, sb);\n\tif (zip_file_set_external_attributes(intern, (zip_uint64_t)index,\n\t\t\t(zip_flags_t)flags, (zip_uint8_t)(opsys&0xff), (zip_uint32_t)attr) < 0) {\n\t\tRETURN_FALSE;\n\t}\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ proto bool ZipArchive::getExternalAttributesName(string name, int &opsys, int &attr [, int flags])\nGet external attributes for file in zip, using its name */\nstatic ZIPARCHIVE_METHOD(getExternalAttributesName)\n{\n\tstruct zip *intern;\n\tzval *self = getThis(), *z_opsys, *z_attr;\n\tsize_t name_len;\n\tchar *name;\n\tzend_long flags=0;\n\tzip_uint8_t opsys;\n\tzip_uint32_t attr;\n\tzip_int64_t idx;\n\n\tif (!self) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"sz/z/|l\",\n\t\t\t&name, &name_len, &z_opsys, &z_attr, &flags) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (name_len < 1) {\n\t\tphp_error_docref(NULL, E_NOTICE, \"Empty string as entry name\");\n\t}\n\n\tidx = zip_name_locate(intern, name, 0);\n\tif (idx < 0) {\n\t\tRETURN_FALSE;\n\t}\n\tif (zip_file_get_external_attributes(intern, idx,\n\t\t\t(zip_flags_t)flags, &opsys, &attr) < 0) {\n\t\tRETURN_FALSE;\n\t}\n\tzval_ptr_dtor(z_opsys);\n\tZVAL_LONG(z_opsys, opsys);\n\tzval_ptr_dtor(z_attr);\n\tZVAL_LONG(z_attr, attr);\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ proto bool ZipArchive::getExternalAttributesIndex(int index, int &opsys, int &attr [, int flags])\nGet external attributes for file in zip, using its index */\nstatic ZIPARCHIVE_METHOD(getExternalAttributesIndex)\n{\n\tstruct zip *intern;\n\tzval *self = getThis(), *z_opsys, *z_attr;\n\tzend_long index, flags=0;\n\tzip_uint8_t opsys;\n\tzip_uint32_t attr;\n\tstruct zip_stat sb;\n\n\tif (!self) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"lz/z/|l\",\n\t\t\t&index, &z_opsys, &z_attr, &flags) == FAILURE) {\n\t\treturn;\n\t}\n\n\tPHP_ZIP_STAT_INDEX(intern, index, 0, sb);\n\tif (zip_file_get_external_attributes(intern, (zip_uint64_t)index,\n\t\t\t(zip_flags_t)flags, &opsys, &attr) < 0) {\n\t\tRETURN_FALSE;\n\t}\n\tzval_dtor(z_opsys);\n\tZVAL_LONG(z_opsys, opsys);\n\tzval_dtor(z_attr);\n\tZVAL_LONG(z_attr, attr);\n\tRETURN_TRUE;\n}\n/* }}} */\n#endif /* ifdef ZIP_OPSYS_DEFAULT */\n\n/* {{{ proto string ZipArchive::getCommentName(string name[, int flags])\nReturns the comment of an entry using its name */\nstatic ZIPARCHIVE_METHOD(getCommentName)\n{\n\tstruct zip *intern;\n\tzval *self = getThis();\n\tsize_t name_len;\n\tint idx;\n\tzend_long flags = 0;\n\tint comment_len = 0;\n\tconst char * comment;\n\tchar *name;\n\n\tif (!self) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"s|l\",\n\t\t\t&name, &name_len, &flags) == FAILURE) {\n\t\treturn;\n\t}\n\tif (name_len < 1) {\n\t\tphp_error_docref(NULL, E_NOTICE, \"Empty string as entry name\");\n\t\tRETURN_FALSE;\n\t}\n\n\tidx = zip_name_locate(intern, name, 0);\n\tif (idx < 0) {\n\t\tRETURN_FALSE;\n\t}\n\n\tcomment = zip_get_file_comment(intern, idx, &comment_len, (int)flags);\n\tRETURN_STRINGL((char *)comment, (zend_long)comment_len);\n}\n/* }}} */\n\n/* {{{ proto string ZipArchive::getCommentIndex(int index[, int flags])\nReturns the comment of an entry using its index */\nstatic ZIPARCHIVE_METHOD(getCommentIndex)\n{\n\tstruct zip *intern;\n\tzval *self = getThis();\n\tzend_long index, flags = 0;\n\tconst char * comment;\n\tint comment_len = 0;\n\tstruct zip_stat sb;\n\n\tif (!self) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"l|l\",\n\t\t\t\t&index, &flags) == FAILURE) {\n\t\treturn;\n\t}\n\n\tPHP_ZIP_STAT_INDEX(intern, index, 0, sb);\n\tcomment = zip_get_file_comment(intern, index, &comment_len, (int)flags);\n\tRETURN_STRINGL((char *)comment, (zend_long)comment_len);\n}\n/* }}} */\n\n/* {{{ proto bool ZipArchive::setCompressionName(string name, int comp_method[, int comp_flags])\nSet the compression of a file in zip, using its name */\nstatic ZIPARCHIVE_METHOD(setCompressionName)\n {\n\tstruct zip *intern;\n\tzval *this = getThis();\n\tsize_t name_len;\n\tchar *name;\n\tzip_int64_t idx;\n\tzend_long comp_method, comp_flags = 0;\n\n\tif (!this) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZIP_FROM_OBJECT(intern, this);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"sl|l\",\n\t\t\t&name, &name_len, &comp_method, &comp_flags) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (name_len < 1) {\n\t\tphp_error_docref(NULL, E_NOTICE, \"Empty string as entry name\");\n\t}\n\n\tidx = zip_name_locate(intern, name, 0);\n\tif (idx < 0) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (zip_set_file_compression(intern, (zip_uint64_t)idx,\n\t\t\t(zip_int32_t)comp_method, (zip_uint32_t)comp_flags) != 0) {\n\t\tRETURN_FALSE;\n\t}\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ proto bool ZipArchive::setCompressionIndex(int index, int comp_method[, int comp_flags])\nSet the compression of a file in zip, using its index */\nstatic ZIPARCHIVE_METHOD(setCompressionIndex)\n{\n\tstruct zip *intern;\n\tzval *this = getThis();\n\tzend_long index;\n\tzend_long comp_method, comp_flags = 0;\n\n\tif (!this) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZIP_FROM_OBJECT(intern, this);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"ll|l\",\n\t\t\t&index, &comp_method, &comp_flags) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (zip_set_file_compression(intern, (zip_uint64_t)index,\n\t\t\t(zip_int32_t)comp_method, (zip_uint32_t)comp_flags) != 0) {\n\t\tRETURN_FALSE;\n\t}\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ proto bool ZipArchive::deleteIndex(int index)\nDelete a file using its index */\nstatic ZIPARCHIVE_METHOD(deleteIndex)\n{\n\tstruct zip *intern;\n\tzval *self = getThis();\n\tzend_long index;\n\n\tif (!self) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"l\", &index) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (index < 0) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (zip_delete(intern, index) < 0) {\n\t\tRETURN_FALSE;\n\t}\n\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ proto bool ZipArchive::deleteName(string name)\nDelete a file using its index */\nstatic ZIPARCHIVE_METHOD(deleteName)\n{\n\tstruct zip *intern;\n\tzval *self = getThis();\n\tsize_t name_len;\n\tchar *name;\n\tstruct zip_stat sb;\n\n\tif (!self) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"s\", &name, &name_len) == FAILURE) {\n\t\treturn;\n\t}\n\tif (name_len < 1) {\n\t\tRETURN_FALSE;\n\t}\n\n\tPHP_ZIP_STAT_PATH(intern, name, name_len, 0, sb);\n\tif (zip_delete(intern, sb.index)) {\n\t\tRETURN_FALSE;\n\t}\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ proto bool ZipArchive::renameIndex(int index, string new_name)\nRename an entry selected by its index to new_name */\nstatic ZIPARCHIVE_METHOD(renameIndex)\n{\n\tstruct zip *intern;\n\tzval *self = getThis();\n\n\tchar *new_name;\n\tsize_t new_name_len;\n\tzend_long index;\n\n\tif (!self) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"ls\", &index, &new_name, &new_name_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (index < 0) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (new_name_len < 1) {\n\t\tphp_error_docref(NULL, E_NOTICE, \"Empty string as new entry name\");\n\t\tRETURN_FALSE;\n\t}\n\tif (zip_rename(intern, index, (const char *)new_name) != 0) {\n\t\tRETURN_FALSE;\n\t}\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ proto bool ZipArchive::renameName(string name, string new_name)\nRename an entry selected by its name to new_name */\nstatic ZIPARCHIVE_METHOD(renameName)\n{\n\tstruct zip *intern;\n\tzval *self = getThis();\n\tstruct zip_stat sb;\n\tchar *name, *new_name;\n\tsize_t name_len, new_name_len;\n\n\tif (!self) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"ss\", &name, &name_len, &new_name, &new_name_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (new_name_len < 1) {\n\t\tphp_error_docref(NULL, E_NOTICE, \"Empty string as new entry name\");\n\t\tRETURN_FALSE;\n\t}\n\n\tPHP_ZIP_STAT_PATH(intern, name, name_len, 0, sb);\n\n\tif (zip_rename(intern, sb.index, (const char *)new_name)) {\n\t\tRETURN_FALSE;\n\t}\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ proto bool ZipArchive::unchangeIndex(int index)\nChanges to the file at position index are reverted */\nstatic ZIPARCHIVE_METHOD(unchangeIndex)\n{\n\tstruct zip *intern;\n\tzval *self = getThis();\n\tzend_long index;\n\n\tif (!self) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"l\", &index) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (index < 0) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (zip_unchange(intern, index) != 0) {\n\t\tRETURN_FALSE;\n\t} else {\n\t\tRETURN_TRUE;\n\t}\n}\n/* }}} */\n\n/* {{{ proto bool ZipArchive::unchangeName(string name)\nChanges to the file named 'name' are reverted */\nstatic ZIPARCHIVE_METHOD(unchangeName)\n{\n\tstruct zip *intern;\n\tzval *self = getThis();\n\tstruct zip_stat sb;\n\tchar *name;\n\tsize_t name_len;\n\n\tif (!self) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"s\", &name, &name_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (name_len < 1) {\n\t\tRETURN_FALSE;\n\t}\n\n\tPHP_ZIP_STAT_PATH(intern, name, name_len, 0, sb);\n\n\tif (zip_unchange(intern, sb.index) != 0) {\n\t\tRETURN_FALSE;\n\t} else {\n\t\tRETURN_TRUE;\n\t}\n}\n/* }}} */\n\n/* {{{ proto bool ZipArchive::unchangeAll()\nAll changes to files and global information in archive are reverted */\nstatic ZIPARCHIVE_METHOD(unchangeAll)\n{\n\tstruct zip *intern;\n\tzval *self = getThis();\n\n\tif (!self) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tif (zip_unchange_all(intern) != 0) {\n\t\tRETURN_FALSE;\n\t} else {\n\t\tRETURN_TRUE;\n\t}\n}\n/* }}} */\n\n/* {{{ proto bool ZipArchive::unchangeArchive()\nRevert all global changes to the archive archive.  For now, this only reverts archive comment changes. */\nstatic ZIPARCHIVE_METHOD(unchangeArchive)\n{\n\tstruct zip *intern;\n\tzval *self = getThis();\n\n\tif (!self) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tif (zip_unchange_archive(intern) != 0) {\n\t\tRETURN_FALSE;\n\t} else {\n\t\tRETURN_TRUE;\n\t}\n}\n/* }}} */\n\n/* {{{ proto bool ZipArchive::extractTo(string pathto[, mixed files])\nExtract one or more file from a zip archive */\n/* TODO:\n * - allow index or array of indeces\n * - replace path\n * - patterns\n */\nstatic ZIPARCHIVE_METHOD(extractTo)\n{\n\tstruct zip *intern;\n\n\tzval *self = getThis();\n\tzval *zval_files = NULL;\n\tzval *zval_file = NULL;\n\tphp_stream_statbuf ssb;\n\tchar *pathto;\n\tsize_t pathto_len;\n\tint ret, i;\n\n\tint nelems;\n\n\tif (!self) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"s|z\", &pathto, &pathto_len, &zval_files) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (pathto_len < 1) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (php_stream_stat_path_ex(pathto, PHP_STREAM_URL_STAT_QUIET, &ssb, NULL) < 0) {\n\t\t\tret = php_stream_mkdir(pathto, 0777,  PHP_STREAM_MKDIR_RECURSIVE, NULL);\n\t\t\tif (!ret) {\n\t\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\tif (zval_files && (Z_TYPE_P(zval_files) != IS_NULL)) {\n\t\tswitch (Z_TYPE_P(zval_files)) {\n\t\t\tcase IS_STRING:\n\t\t\t\tif (!php_zip_extract_file(intern, pathto, Z_STRVAL_P(zval_files), Z_STRLEN_P(zval_files))) {\n\t\t\t\t\tRETURN_FALSE;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase IS_ARRAY:\n\t\t\t\tnelems = zend_hash_num_elements(Z_ARRVAL_P(zval_files));\n\t\t\t\tif (nelems == 0 ) {\n\t\t\t\t\tRETURN_FALSE;\n\t\t\t\t}\n\t\t\t\tfor (i = 0; i < nelems; i++) {\n\t\t\t\t\tif ((zval_file = zend_hash_index_find(Z_ARRVAL_P(zval_files), i)) != NULL) {\n\t\t\t\t\t\tswitch (Z_TYPE_P(zval_file)) {\n\t\t\t\t\t\t\tcase IS_LONG:\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase IS_STRING:\n\t\t\t\t\t\t\t\tif (!php_zip_extract_file(intern, pathto, Z_STRVAL_P(zval_file), Z_STRLEN_P(zval_file))) {\n\t\t\t\t\t\t\t\t\tRETURN_FALSE;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase IS_LONG:\n\t\t\tdefault:\n\t\t\t\tphp_error_docref(NULL, E_WARNING, \"Invalid argument, expect string or array of strings\");\n\t\t\t\tbreak;\n\t\t}\n\t} else {\n\t\t/* Extract all files */\n\t\tint filecount = zip_get_num_files(intern);\n\n\t\tif (filecount == -1) {\n\t\t\t\tphp_error_docref(NULL, E_WARNING, \"Illegal archive\");\n\t\t\t\tRETURN_FALSE;\n\t\t}\n\n\t\tfor (i = 0; i < filecount; i++) {\n\t\t\tchar *file = (char*)zip_get_name(intern, i, ZIP_FL_UNCHANGED);\n\t\t\tif (!file || !php_zip_extract_file(intern, pathto, file, strlen(file))) {\n\t\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\t\t}\n\t}\n\tRETURN_TRUE;\n}\n/* }}} */\n\nstatic void php_zip_get_from(INTERNAL_FUNCTION_PARAMETERS, int type) /* {{{ */\n{\n\tstruct zip *intern;\n\tzval *self = getThis();\n\n\tstruct zip_stat sb;\n\tstruct zip_file *zf;\n\n\tzend_long index = -1;\n\tzend_long flags = 0;\n\tzend_long len = 0;\n\n\tzend_string *filename;\n\tzend_string *buffer;\n\n\tint n = 0;\n\n\tif (!self) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tif (type == 1) {\n\t\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"P|ll\", &filename, &len, &flags) == FAILURE) {\n\t\t\treturn;\n\t\t}\n\t\tPHP_ZIP_STAT_PATH(intern, ZSTR_VAL(filename), ZSTR_LEN(filename), flags, sb);\n\t} else {\n\t\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"l|ll\", &index, &len, &flags) == FAILURE) {\n\t\t\treturn;\n\t\t}\n\t\tPHP_ZIP_STAT_INDEX(intern, index, 0, sb);\n\t}\n\n\tif (sb.size < 1) {\n\t\tRETURN_EMPTY_STRING();\n\t}\n\n\tif (len < 1) {\n\t\tlen = sb.size;\n\t}\n\tif (index >= 0) {\n\t\tzf = zip_fopen_index(intern, index, flags);\n\t} else {\n\t\tzf = zip_fopen(intern, ZSTR_VAL(filename), flags);\n\t}\n\n\tif (zf == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\n\tbuffer = zend_string_safe_alloc(1, len, 0, 0);\n\tn = zip_fread(zf, ZSTR_VAL(buffer), ZSTR_LEN(buffer));\n\tif (n < 1) {\n\t\tzend_string_free(buffer);\n\t\tRETURN_EMPTY_STRING();\n\t}\n\n\tzip_fclose(zf);\n\tZSTR_VAL(buffer)[n] = '\\0';\n\tZSTR_LEN(buffer) = n;\n\tRETURN_NEW_STR(buffer);\n}\n/* }}} */\n\n/* {{{ proto string ZipArchive::getFromName(string entryname[, int len [, int flags]])\nget the contents of an entry using its name */\nstatic ZIPARCHIVE_METHOD(getFromName)\n{\n\tphp_zip_get_from(INTERNAL_FUNCTION_PARAM_PASSTHRU, 1);\n}\n/* }}} */\n\n/* {{{ proto string ZipArchive::getFromIndex(int index[, int len [, int flags]])\nget the contents of an entry using its index */\nstatic ZIPARCHIVE_METHOD(getFromIndex)\n{\n\tphp_zip_get_from(INTERNAL_FUNCTION_PARAM_PASSTHRU, 0);\n}\n/* }}} */\n\n/* {{{ proto resource ZipArchive::getStream(string entryname)\nget a stream for an entry using its name */\nstatic ZIPARCHIVE_METHOD(getStream)\n{\n\tstruct zip *intern;\n\tzval *self = getThis();\n\tstruct zip_stat sb;\n\tchar *mode = \"rb\";\n\tzend_string *filename;\n\tphp_stream *stream;\n\tze_zip_object *obj;\n\n\tif (!self) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"P\", &filename) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (zip_stat(intern, ZSTR_VAL(filename), 0, &sb) != 0) {\n\t\tRETURN_FALSE;\n\t}\n\n\tobj = Z_ZIP_P(self);\n\n\tstream = php_stream_zip_open(obj->filename, ZSTR_VAL(filename), mode STREAMS_CC);\n\tif (stream) {\n\t\tphp_stream_to_zval(stream, return_value);\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n}\n/* }}} */\n\n/* {{{ arginfo */\nZEND_BEGIN_ARG_INFO_EX(arginfo_ziparchive_open, 0, 0, 1)\n\tZEND_ARG_INFO(0, filename)\n\tZEND_ARG_INFO(0, flags)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_ziparchive_setpassword, 0, 0, 1)\n\tZEND_ARG_INFO(0, password)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO(arginfo_ziparchive__void, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_ziparchive_addemptydir, 0, 0, 1)\n\tZEND_ARG_INFO(0, dirname)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_ziparchive_addglob, 0, 0, 1)\n\tZEND_ARG_INFO(0, pattern)\n\tZEND_ARG_INFO(0, flags)\n\tZEND_ARG_INFO(0, options)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_ziparchive_addpattern, 0, 0, 1)\n\tZEND_ARG_INFO(0, pattern)\n\tZEND_ARG_INFO(0, path)\n\tZEND_ARG_INFO(0, options)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_ziparchive_addfile, 0, 0, 1)\n\tZEND_ARG_INFO(0, filepath)\n\tZEND_ARG_INFO(0, entryname)\n\tZEND_ARG_INFO(0, start)\n\tZEND_ARG_INFO(0, length)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_ziparchive_addfromstring, 0, 0, 2)\n\tZEND_ARG_INFO(0, name)\n\tZEND_ARG_INFO(0, content)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_ziparchive_statname, 0, 0, 1)\n\tZEND_ARG_INFO(0, filename)\n\tZEND_ARG_INFO(0, flags)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_ziparchive_statindex, 0, 0, 1)\n\tZEND_ARG_INFO(0, index)\n\tZEND_ARG_INFO(0, flags)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_ziparchive_setarchivecomment, 0, 0, 1)\n\tZEND_ARG_INFO(0, comment)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_ziparchive_setcommentindex, 0, 0, 2)\n\tZEND_ARG_INFO(0, index)\n\tZEND_ARG_INFO(0, comment)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_ziparchive_getcommentname, 0, 0, 1)\n\tZEND_ARG_INFO(0, name)\n\tZEND_ARG_INFO(0, flags)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_ziparchive_getcommentindex, 0, 0, 1)\n\tZEND_ARG_INFO(0, index)\n\tZEND_ARG_INFO(0, flags)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_ziparchive_renameindex, 0, 0, 2)\n\tZEND_ARG_INFO(0, index)\n\tZEND_ARG_INFO(0, new_name)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_ziparchive_renamename, 0, 0, 2)\n\tZEND_ARG_INFO(0, name)\n\tZEND_ARG_INFO(0, new_name)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_ziparchive_unchangeindex, 0, 0, 1)\n\tZEND_ARG_INFO(0, index)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_ziparchive_unchangename, 0, 0, 1)\n\tZEND_ARG_INFO(0, name)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_ziparchive_extractto, 0, 0, 1)\n\tZEND_ARG_INFO(0, pathto)\n\tZEND_ARG_INFO(0, files)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_ziparchive_getfromname, 0, 0, 1)\n\tZEND_ARG_INFO(0, entryname)\n\tZEND_ARG_INFO(0, len)\n\tZEND_ARG_INFO(0, flags)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_ziparchive_getfromindex, 0, 0, 1)\n\tZEND_ARG_INFO(0, index)\n\tZEND_ARG_INFO(0, len)\n\tZEND_ARG_INFO(0, flags)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_ziparchive_getarchivecomment, 0, 0, 0)\n\tZEND_ARG_INFO(0, flags)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_ziparchive_setcommentname, 0, 0, 2)\n\tZEND_ARG_INFO(0, name)\n\tZEND_ARG_INFO(0, comment)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_ziparchive_getstream, 0, 0, 1)\n\tZEND_ARG_INFO(0, entryname)\nZEND_END_ARG_INFO()\n\n#ifdef ZIP_OPSYS_DEFAULT\nZEND_BEGIN_ARG_INFO_EX(arginfo_ziparchive_setextattrname, 0, 0, 3)\n\tZEND_ARG_INFO(0, name)\n\tZEND_ARG_INFO(0, opsys)\n\tZEND_ARG_INFO(0, attr)\n\tZEND_ARG_INFO(0, flags)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_ziparchive_setextattrindex, 0, 0, 3)\n\tZEND_ARG_INFO(0, index)\n\tZEND_ARG_INFO(0, opsys)\n\tZEND_ARG_INFO(0, attr)\n\tZEND_ARG_INFO(0, flags)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_ziparchive_getextattrname, 0, 0, 3)\n\tZEND_ARG_INFO(0, name)\n\tZEND_ARG_INFO(1, opsys)\n\tZEND_ARG_INFO(1, attr)\n\tZEND_ARG_INFO(0, flags)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_ziparchive_getextattrindex, 0, 0, 3)\n\tZEND_ARG_INFO(0, index)\n\tZEND_ARG_INFO(1, opsys)\n\tZEND_ARG_INFO(1, attr)\n\tZEND_ARG_INFO(0, flags)\nZEND_END_ARG_INFO()\n#endif /* ifdef ZIP_OPSYS_DEFAULT */\n/* }}} */\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_ziparchive_setcompname, 0, 0, 2)\n\tZEND_ARG_INFO(0, name)\n\tZEND_ARG_INFO(0, method)\n\tZEND_ARG_INFO(0, compflags)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_ziparchive_setcompindex, 0, 0, 2)\n\tZEND_ARG_INFO(0, index)\n\tZEND_ARG_INFO(0, method)\n\tZEND_ARG_INFO(0, compflags)\nZEND_END_ARG_INFO()\n\n/* {{{ ze_zip_object_class_functions */\nstatic const zend_function_entry zip_class_functions[] = {\n\tZIPARCHIVE_ME(open,\t\t\t\t\targinfo_ziparchive_open, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(setPassword,\t\t\targinfo_ziparchive_setpassword, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(close,\t\t\t\targinfo_ziparchive__void, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(getStatusString,\t\targinfo_ziparchive__void, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(addEmptyDir,\t\t\targinfo_ziparchive_addemptydir, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(addFromString,\t\targinfo_ziparchive_addfromstring, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(addFile,\t\t\t\targinfo_ziparchive_addfile, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(addGlob,\t\t\t\targinfo_ziparchive_addglob, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(addPattern,\t\t\targinfo_ziparchive_addpattern, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(renameIndex,\t\t\targinfo_ziparchive_renameindex, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(renameName,\t\t\targinfo_ziparchive_renamename, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(setArchiveComment,\targinfo_ziparchive_setarchivecomment, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(getArchiveComment,\targinfo_ziparchive_getarchivecomment, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(setCommentIndex,\t\targinfo_ziparchive_setcommentindex, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(setCommentName,\t\targinfo_ziparchive_setcommentname, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(getCommentIndex,\t\targinfo_ziparchive_getcommentindex, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(getCommentName,\t\targinfo_ziparchive_getcommentname, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(deleteIndex,\t\t\targinfo_ziparchive_unchangeindex, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(deleteName,\t\t\targinfo_ziparchive_unchangename, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(statName,\t\t\t\targinfo_ziparchive_statname, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(statIndex,\t\t\targinfo_ziparchive_statindex, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(locateName,\t\t\targinfo_ziparchive_statname, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(getNameIndex,\t\t\targinfo_ziparchive_statindex, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(unchangeArchive,\t\targinfo_ziparchive__void, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(unchangeAll,\t\t\targinfo_ziparchive__void, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(unchangeIndex,\t\targinfo_ziparchive_unchangeindex, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(unchangeName,\t\t\targinfo_ziparchive_unchangename, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(extractTo,\t\t\targinfo_ziparchive_extractto, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(getFromName,\t\t\targinfo_ziparchive_getfromname, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(getFromIndex,\t\t\targinfo_ziparchive_getfromindex, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(getStream,\t\t\targinfo_ziparchive_getstream, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(setExternalAttributesName,\targinfo_ziparchive_setextattrname, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(setExternalAttributesIndex,\targinfo_ziparchive_setextattrindex, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(getExternalAttributesName,\targinfo_ziparchive_getextattrname, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(getExternalAttributesIndex,\targinfo_ziparchive_getextattrindex, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(setCompressionName,\t\targinfo_ziparchive_setcompname, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(setCompressionIndex,\t\targinfo_ziparchive_setcompindex, ZEND_ACC_PUBLIC)\n\t{NULL, NULL, NULL}\n};\n/* }}} */\n\nstatic void php_zip_free_prop_handler(zval *el) /* {{{ */ {\n\tpefree(Z_PTR_P(el), 1);\n} /* }}} */\n\n/* {{{ PHP_MINIT_FUNCTION */\nstatic PHP_MINIT_FUNCTION(zip)\n{\n\tzend_class_entry ce;\n\n\tmemcpy(&zip_object_handlers, zend_get_std_object_handlers(), sizeof(zend_object_handlers));\n\tzip_object_handlers.offset = XtOffsetOf(ze_zip_object, zo);\n\tzip_object_handlers.free_obj = php_zip_object_free_storage;\n\tzip_object_handlers.clone_obj = NULL;\n\tzip_object_handlers.get_property_ptr_ptr = php_zip_get_property_ptr_ptr;\n\n\tzip_object_handlers.get_properties = php_zip_get_properties;\n\tzip_object_handlers.read_property\t= php_zip_read_property;\n\tzip_object_handlers.has_property\t= php_zip_has_property;\n\n\tINIT_CLASS_ENTRY(ce, \"ZipArchive\", zip_class_functions);\n\tce.create_object = php_zip_object_new;\n\tzip_class_entry = zend_register_internal_class(&ce);\n\n\tzend_hash_init(&zip_prop_handlers, 0, NULL, php_zip_free_prop_handler, 1);\n\tphp_zip_register_prop_handler(&zip_prop_handlers, \"status\",    php_zip_status, NULL, NULL, IS_LONG);\n\tphp_zip_register_prop_handler(&zip_prop_handlers, \"statusSys\", php_zip_status_sys, NULL, NULL, IS_LONG);\n\tphp_zip_register_prop_handler(&zip_prop_handlers, \"numFiles\",  php_zip_get_num_files, NULL, NULL, IS_LONG);\n\tphp_zip_register_prop_handler(&zip_prop_handlers, \"filename\", NULL, NULL, php_zipobj_get_filename, IS_STRING);\n\tphp_zip_register_prop_handler(&zip_prop_handlers, \"comment\", NULL, php_zipobj_get_zip_comment, NULL, IS_STRING);\n\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CREATE\", ZIP_CREATE);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"EXCL\", ZIP_EXCL);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CHECKCONS\", ZIP_CHECKCONS);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"OVERWRITE\", ZIP_OVERWRITE);\n\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"FL_NOCASE\", ZIP_FL_NOCASE);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"FL_NODIR\", ZIP_FL_NODIR);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"FL_COMPRESSED\", ZIP_FL_COMPRESSED);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"FL_UNCHANGED\", ZIP_FL_UNCHANGED);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_DEFAULT\", ZIP_CM_DEFAULT);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_STORE\", ZIP_CM_STORE);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_SHRINK\", ZIP_CM_SHRINK);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_REDUCE_1\", ZIP_CM_REDUCE_1);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_REDUCE_2\", ZIP_CM_REDUCE_2);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_REDUCE_3\", ZIP_CM_REDUCE_3);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_REDUCE_4\", ZIP_CM_REDUCE_4);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_IMPLODE\", ZIP_CM_IMPLODE);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_DEFLATE\", ZIP_CM_DEFLATE);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_DEFLATE64\", ZIP_CM_DEFLATE64);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_PKWARE_IMPLODE\", ZIP_CM_PKWARE_IMPLODE);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_BZIP2\", ZIP_CM_BZIP2);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_LZMA\", ZIP_CM_LZMA);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_TERSE\", ZIP_CM_TERSE);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_LZ77\", ZIP_CM_LZ77);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_WAVPACK\", ZIP_CM_WAVPACK);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_PPMD\", ZIP_CM_PPMD);\n\n\t/* Error code */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_OK\",\t\t\tZIP_ER_OK);\t\t\t/* N No error */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_MULTIDISK\",\tZIP_ER_MULTIDISK);\t/* N Multi-disk zip archives not supported */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_RENAME\",\t\tZIP_ER_RENAME);\t\t/* S Renaming temporary file failed */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_CLOSE\",\t\tZIP_ER_CLOSE);\t\t/* S Closing zip archive failed */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_SEEK\",\t\tZIP_ER_SEEK);\t\t/* S Seek error */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_READ\",\t\tZIP_ER_READ);\t\t/* S Read error */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_WRITE\",\t\tZIP_ER_WRITE);\t\t/* S Write error */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_CRC\",\t\t\tZIP_ER_CRC);\t\t/* N CRC error */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_ZIPCLOSED\",\tZIP_ER_ZIPCLOSED);\t/* N Containing zip archive was closed */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_NOENT\",\t\tZIP_ER_NOENT);\t\t/* N No such file */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_EXISTS\",\t\tZIP_ER_EXISTS);\t\t/* N File already exists */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_OPEN\",\t\tZIP_ER_OPEN);\t\t/* S Can't open file */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_TMPOPEN\",\t\tZIP_ER_TMPOPEN);\t/* S Failure to create temporary file */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_ZLIB\",\t\tZIP_ER_ZLIB);\t\t/* Z Zlib error */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_MEMORY\",\t\tZIP_ER_MEMORY);\t\t/* N Malloc failure */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_CHANGED\",\t\tZIP_ER_CHANGED);\t/* N Entry has been changed */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_COMPNOTSUPP\",\tZIP_ER_COMPNOTSUPP);/* N Compression method not supported */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_EOF\",\t\t\tZIP_ER_EOF);\t\t/* N Premature EOF */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_INVAL\",\t\tZIP_ER_INVAL);\t\t/* N Invalid argument */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_NOZIP\",\t\tZIP_ER_NOZIP);\t\t/* N Not a zip archive */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_INTERNAL\",\tZIP_ER_INTERNAL);\t/* N Internal error */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_INCONS\",\t\tZIP_ER_INCONS);\t\t/* N Zip archive inconsistent */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_REMOVE\",\t\tZIP_ER_REMOVE);\t\t/* S Can't remove file */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_DELETED\",  \tZIP_ER_DELETED);\t/* N Entry has been deleted */\n\n#ifdef ZIP_OPSYS_DEFAULT\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"OPSYS_DOS\",\t\t\t\tZIP_OPSYS_DOS);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"OPSYS_AMIGA\",\t\t\tZIP_OPSYS_AMIGA);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"OPSYS_OPENVMS\",\t\t\tZIP_OPSYS_OPENVMS);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"OPSYS_UNIX\",\t\t\t\tZIP_OPSYS_UNIX);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"OPSYS_VM_CMS\",\t\t\tZIP_OPSYS_VM_CMS);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"OPSYS_ATARI_ST\",\t\t\tZIP_OPSYS_ATARI_ST);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"OPSYS_OS_2\",\t\t\t\tZIP_OPSYS_OS_2);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"OPSYS_MACINTOSH\",\t\tZIP_OPSYS_MACINTOSH);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"OPSYS_Z_SYSTEM\",\t\t\tZIP_OPSYS_Z_SYSTEM);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"OPSYS_Z_CPM\",\t\t\tZIP_OPSYS_CPM);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"OPSYS_WINDOWS_NTFS\",\t\tZIP_OPSYS_WINDOWS_NTFS);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"OPSYS_MVS\",\t\t\t\tZIP_OPSYS_MVS);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"OPSYS_VSE\",\t\t\t\tZIP_OPSYS_VSE);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"OPSYS_ACORN_RISC\",\t\tZIP_OPSYS_ACORN_RISC);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"OPSYS_VFAT\",\t\t\t\tZIP_OPSYS_VFAT);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"OPSYS_ALTERNATE_MVS\",\tZIP_OPSYS_ALTERNATE_MVS);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"OPSYS_BEOS\",\t\t\t\tZIP_OPSYS_BEOS);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"OPSYS_TANDEM\",\t\t\tZIP_OPSYS_TANDEM);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"OPSYS_OS_400\",\t\t\tZIP_OPSYS_OS_400);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"OPSYS_OS_X\",\t\t\t\tZIP_OPSYS_OS_X);\n\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"OPSYS_DEFAULT\", ZIP_OPSYS_DEFAULT);\n#endif /* ifdef ZIP_OPSYS_DEFAULT */\n\n\tphp_register_url_stream_wrapper(\"zip\", &php_stream_zip_wrapper);\n\n\tle_zip_dir   = zend_register_list_destructors_ex(php_zip_free_dir,   NULL, le_zip_dir_name,   module_number);\n\tle_zip_entry = zend_register_list_destructors_ex(php_zip_free_entry, NULL, le_zip_entry_name, module_number);\n\n\treturn SUCCESS;\n}\n/* }}} */\n\n/* {{{ PHP_MSHUTDOWN_FUNCTION\n */\nstatic PHP_MSHUTDOWN_FUNCTION(zip)\n{\n\tzend_hash_destroy(&zip_prop_handlers);\n\tphp_unregister_url_stream_wrapper(\"zip\");\n\treturn SUCCESS;\n}\n/* }}} */\n\n/* {{{ PHP_MINFO_FUNCTION\n */\nstatic PHP_MINFO_FUNCTION(zip)\n{\n\tphp_info_print_table_start();\n\n\tphp_info_print_table_row(2, \"Zip\", \"enabled\");\n\tphp_info_print_table_row(2, \"Zip version\", PHP_ZIP_VERSION);\n\tphp_info_print_table_row(2, \"Libzip version\", LIBZIP_VERSION);\n\n\tphp_info_print_table_end();\n}\n/* }}} */\n\n/*\n * Local variables:\n * tab-width: 4\n * c-basic-offset: 4\n * End:\n * vim600: noet sw=4 ts=4 fdm=marker\n * vim<600: noet sw=4 ts=4\n */\n", "code_before": "/*\n  +----------------------------------------------------------------------+\n  | Copyright (c) The PHP Group                                          |\n  +----------------------------------------------------------------------+\n  | This source file is subject to version 3.01 of the PHP license,      |\n  | that is bundled with this package in the file LICENSE, and is        |\n  | available through the world-wide-web at the following url:           |\n  | https://www.php.net/license/3_01.txt                                 |\n  | If you did not receive a copy of the PHP license and are unable to   |\n  | obtain it through the world-wide-web, please send a note to          |\n  | license@php.net so we can mail you a copy immediately.               |\n  +----------------------------------------------------------------------+\n  | Author: Piere-Alain Joye <pierre@php.net>                            |\n  +----------------------------------------------------------------------+\n*/\n\n\n#ifdef HAVE_CONFIG_H\n#include <config.h>\n#endif\n\n#include \"php.h\"\n#include \"ext/standard/info.h\"\n#include \"ext/standard/file.h\"\n#include \"ext/standard/php_string.h\" /* For php_basename() */\n#include \"ext/pcre/php_pcre.h\"\n#include \"ext/standard/php_filestat.h\"\n#include \"zend_attributes.h\"\n#include \"zend_interfaces.h\"\n#include \"php_zip.h\"\n#include \"php_zip_arginfo.h\"\n\n#include \"php_glob.h\"\n\n/* {{{ Resource le */\nstatic int le_zip_dir;\n#define le_zip_dir_name \"Zip Directory\"\nstatic int le_zip_entry;\n#define le_zip_entry_name \"Zip Entry\"\n/* }}} */\n\n/* {{{ PHP_ZIP_STAT_INDEX(za, index, flags, sb) */\n#define PHP_ZIP_STAT_INDEX(za, index, flags, sb) \\\n\tif (zip_stat_index(za, index, flags, &sb) != 0) { \\\n\t\tRETURN_FALSE; \\\n\t}\n/* }}} */\n\n/* {{{  PHP_ZIP_STAT_PATH(za, path, path_len, flags, sb)\n\tThis is always used for the first argument*/\n#define PHP_ZIP_STAT_PATH(za, path, path_len, flags, sb) \\\n\tif (path_len == 0) { \\\n\t\tzend_argument_must_not_be_empty_error(1); \\\n\t\tRETURN_THROWS(); \\\n\t} \\\n\tif (zip_stat(za, path, flags, &sb) != 0) { \\\n\t\tRETURN_FALSE; \\\n\t}\n/* }}} */\n\n/* {{{ PHP_ZIP_SET_FILE_COMMENT(za, index, comment, comment_len) */\n#define PHP_ZIP_SET_FILE_COMMENT(za, index, comment, comment_len) \\\n\tif (comment_len == 0) { \\\n\t\t/* Passing NULL remove the existing comment */ \\\n\t\tif (zip_file_set_comment(za, index, NULL, 0, 0) < 0) { \\\n\t\t\tRETURN_FALSE; \\\n\t\t} \\\n\t} else if (zip_file_set_comment(za, index, comment, comment_len, 0) < 0) { \\\n\t\tRETURN_FALSE; \\\n\t} \\\n\tRETURN_TRUE;\n/* }}} */\n\n# define add_ascii_assoc_string add_assoc_string\n# define add_ascii_assoc_long add_assoc_long\n\n/* Flatten a path by making a relative path (to .)*/\nstatic char * php_zip_make_relative_path(char *path, size_t path_len) /* {{{ */\n{\n\tchar *path_begin = path;\n\tsize_t i;\n\n\tif (path_len < 1 || path == NULL) {\n\t\treturn NULL;\n\t}\n\n\tif (IS_ABSOLUTE_PATH(path, path_len)) {\n\t\treturn path + COPY_WHEN_ABSOLUTE(path) + 1;\n\t}\n\n\ti = path_len;\n\n\twhile (1) {\n\t\twhile (i > 0 && !IS_SLASH(path[i])) {\n\t\t\ti--;\n\t\t}\n\n\t\tif (!i) {\n\t\t\treturn path;\n\t\t}\n\n\t\tif (i >= 2 && path[i -1] == '.') {\n\t\t\t/* i is the position of ., add 1 for / */\n\t\t\tpath_begin = path + i + 1;\n\t\t\tbreak;\n\t\t}\n\t\ti--;\n\t}\n\n\treturn path_begin;\n}\n/* }}} */\n\n# define CWD_STATE_ALLOC(l) emalloc(l)\n# define CWD_STATE_FREE(s)  efree(s)\n\n/* {{{ php_zip_extract_file */\nstatic int php_zip_extract_file(struct zip * za, char *dest, const char *file, size_t file_len, zip_int64_t idx)\n{\n\tphp_stream_statbuf ssb;\n\tstruct zip_file *zf;\n\tstruct zip_stat sb;\n\tchar b[8192];\n\tint n, ret;\n\tphp_stream *stream;\n\tchar *fullpath;\n\tchar *file_dirname_fullpath;\n\tchar file_dirname[MAXPATHLEN];\n\tsize_t dir_len, len;\n\tint is_dir_only = 0;\n\tchar *path_cleaned;\n\tsize_t path_cleaned_len;\n\tcwd_state new_state;\n\tzend_string *file_basename;\n\n\tif (idx < 0) {\n\t\tidx = zip_name_locate(za, file, 0);\n\t\tif (idx < 0) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\tnew_state.cwd = CWD_STATE_ALLOC(1);\n\tnew_state.cwd[0] = '\\0';\n\tnew_state.cwd_length = 0;\n\n\t/* Clean/normlize the path and then transform any path (absolute or relative)\n\t\t to a path relative to cwd (../../mydir/foo.txt > mydir/foo.txt)\n\t */\n\tvirtual_file_ex(&new_state, file, NULL, CWD_EXPAND);\n\tpath_cleaned =  php_zip_make_relative_path(new_state.cwd, new_state.cwd_length);\n\tif(!path_cleaned) {\n\t\tCWD_STATE_FREE(new_state.cwd);\n\t\treturn 0;\n\t}\n\tpath_cleaned_len = strlen(path_cleaned);\n\n\tif (path_cleaned_len >= MAXPATHLEN || zip_stat_index(za, idx, 0, &sb) != 0) {\n\t\tCWD_STATE_FREE(new_state.cwd);\n\t\treturn 0;\n\t}\n\n\t/* it is a directory only, see #40228 */\n\tif (path_cleaned_len > 1 && IS_SLASH(path_cleaned[path_cleaned_len - 1])) {\n\t\tlen = spprintf(&file_dirname_fullpath, 0, \"%s/%s\", dest, path_cleaned);\n\t\tis_dir_only = 1;\n\t} else {\n\t\tmemcpy(file_dirname, path_cleaned, path_cleaned_len);\n\t\tdir_len = zend_dirname(file_dirname, path_cleaned_len);\n\n\t\tif (!dir_len || (dir_len == 1 && file_dirname[0] == '.')) {\n\t\t\tlen = spprintf(&file_dirname_fullpath, 0, \"%s\", dest);\n\t\t} else {\n\t\t\tlen = spprintf(&file_dirname_fullpath, 0, \"%s/%s\", dest, file_dirname);\n\t\t}\n\n\t\tfile_basename =\tphp_basename(path_cleaned, path_cleaned_len, NULL, 0);\n\n\t\tif (ZIP_OPENBASEDIR_CHECKPATH(file_dirname_fullpath)) {\n\t\t\tefree(file_dirname_fullpath);\n\t\t\tzend_string_release_ex(file_basename, 0);\n\t\t\tCWD_STATE_FREE(new_state.cwd);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* let see if the path already exists */\n\tif (php_stream_stat_path_ex(file_dirname_fullpath, PHP_STREAM_URL_STAT_QUIET, &ssb, NULL) < 0) {\n\t\tret = php_stream_mkdir(file_dirname_fullpath, 0777,  PHP_STREAM_MKDIR_RECURSIVE|REPORT_ERRORS, NULL);\n\t\tif (!ret) {\n\t\t\tefree(file_dirname_fullpath);\n\t\t\tif (!is_dir_only) {\n\t\t\t\tzend_string_release_ex(file_basename, 0);\n\t\t\t}\n\t\t\tCWD_STATE_FREE(new_state.cwd);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* it is a standalone directory, job done */\n\tif (is_dir_only) {\n\t\tefree(file_dirname_fullpath);\n\t\tCWD_STATE_FREE(new_state.cwd);\n\t\treturn 1;\n\t}\n\n\tlen = spprintf(&fullpath, 0, \"%s/%s\", file_dirname_fullpath, ZSTR_VAL(file_basename));\n\tif (!len) {\n\t\tefree(file_dirname_fullpath);\n\t\tzend_string_release_ex(file_basename, 0);\n\t\tCWD_STATE_FREE(new_state.cwd);\n\t\treturn 0;\n\t} else if (len > MAXPATHLEN) {\n\t\tphp_error_docref(NULL, E_WARNING, \"Full extraction path exceed MAXPATHLEN (%i)\", MAXPATHLEN);\n\t\tefree(fullpath);\n\t\tefree(file_dirname_fullpath);\n\t\tzend_string_release_ex(file_basename, 0);\n\t\tCWD_STATE_FREE(new_state.cwd);\n\t\treturn 0;\n\t}\n\n\t/* check again the full path, not sure if it\n\t * is required, does a file can have a different\n\t * safemode status as its parent folder?\n\t */\n\tif (ZIP_OPENBASEDIR_CHECKPATH(fullpath)) {\n\t\tefree(fullpath);\n\t\tefree(file_dirname_fullpath);\n\t\tzend_string_release_ex(file_basename, 0);\n\t\tCWD_STATE_FREE(new_state.cwd);\n\t\treturn 0;\n\t}\n\n\tzf = zip_fopen_index(za, idx, 0);\n\tif (zf == NULL) {\n\t\tn = -1;\n\t\tgoto done;\n\t}\n\n\tstream = php_stream_open_wrapper(fullpath, \"w+b\", REPORT_ERRORS, NULL);\n\n\tif (stream == NULL) {\n\t\tn = -1;\n\t\tzip_fclose(zf);\n\t\tgoto done;\n\t}\n\n\tn = 0;\n\n\twhile ((n=zip_fread(zf, b, sizeof(b))) > 0) {\n\t\tphp_stream_write(stream, b, n);\n\t}\n\n\tif (stream->wrapper->wops->stream_metadata) {\n\t\tstruct utimbuf ut;\n\n\t\tut.modtime = ut.actime = sb.mtime;\n\t\tstream->wrapper->wops->stream_metadata(stream->wrapper, fullpath, PHP_STREAM_META_TOUCH, &ut, NULL);\n\t}\n\n\tphp_stream_close(stream);\n\tn = zip_fclose(zf);\n\ndone:\n\tefree(fullpath);\n\tzend_string_release_ex(file_basename, 0);\n\tefree(file_dirname_fullpath);\n\tCWD_STATE_FREE(new_state.cwd);\n\n\tif (n<0) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}\n/* }}} */\n\nstatic int php_zip_add_file(ze_zip_object *obj, const char *filename, size_t filename_len,\n\tchar *entry_name, size_t entry_name_len, /* unused if replace >= 0 */\n\tzip_uint64_t offset_start, zip_uint64_t offset_len,\n\tzend_long replace, /* index to replace, add new file if < 0 */\n\tzip_flags_t flags\n) /* {{{ */\n{\n\tstruct zip_source *zs;\n\tchar resolved_path[MAXPATHLEN];\n\tphp_stream_statbuf ssb;\n\n\tif (ZIP_OPENBASEDIR_CHECKPATH(filename)) {\n\t\treturn -1;\n\t}\n\n\tif (!expand_filepath(filename, resolved_path)) {\n\t\tphp_error_docref(NULL, E_WARNING, \"No such file or directory\");\n\t\treturn -1;\n\t}\n\n\tif (php_stream_stat_path_ex(resolved_path, PHP_STREAM_URL_STAT_QUIET, &ssb, NULL)) {\n\t\tphp_error_docref(NULL, E_WARNING, \"No such file or directory\");\n\t\treturn -1;\n\t}\n\n\tif (flags & ZIP_FL_OPEN_FILE_NOW) {\n\t\tFILE *fd;\n\t\tfd = fopen(resolved_path, \"rb\");\n\t\tif (!fd) {\n\t\t\treturn -1;\n\t\t}\n\t\tflags ^= ZIP_FL_OPEN_FILE_NOW;\n\t\tzs = zip_source_filep(obj->za, fd, offset_start, offset_len);\n\t} else {\n\t\tzs = zip_source_file(obj->za, resolved_path, offset_start, offset_len);\n\t}\n\tif (!zs) {\n\t\treturn -1;\n\t}\n\t/* Replace */\n\tif (replace >= 0) {\n\t\tif (zip_file_replace(obj->za, replace, zs, flags) < 0) {\n\t\t\tzip_source_free(zs);\n\t\t\treturn -1;\n\t\t}\n\t\tzip_error_clear(obj->za);\n\t\treturn 1;\n\t}\n\t/* Add */\n\tobj->last_id = zip_file_add(obj->za, entry_name, zs, flags);\n\tif (obj->last_id < 0) {\n\t\tzip_source_free(zs);\n\t\treturn -1;\n\t}\n\tzip_error_clear(obj->za);\n\treturn 1;\n}\n/* }}} */\n\ntypedef struct {\n\tzend_long    remove_all_path;\n\tchar        *remove_path;\n\tsize_t       remove_path_len;\n\tchar        *add_path;\n\tsize_t       add_path_len;\n\tzip_flags_t  flags;\n\tzip_int32_t  comp_method;\n\tzip_uint32_t comp_flags;\n#ifdef HAVE_ENCRYPTION\n\tzip_int16_t  enc_method;\n\tchar        *enc_password;\n#endif\n} zip_options;\n\n/* Expects opts to be zero-initialized. */\nstatic int php_zip_parse_options(HashTable *options, zip_options *opts)\n/* {{{ */\n{\n\tzval *option;\n\n\t/* default values */\n\topts->flags = ZIP_FL_OVERWRITE;\n\topts->comp_method = -1; /* -1 to not change default */\n#ifdef HAVE_ENCRYPTION\n\topts->enc_method = -1;  /* -1 to not change default */\n#endif\n\n\tif ((option = zend_hash_str_find(options, \"remove_all_path\", sizeof(\"remove_all_path\") - 1)) != NULL) {\n\t\tif (Z_TYPE_P(option) != IS_FALSE && Z_TYPE_P(option) != IS_TRUE) {\n\t\t\tphp_error_docref(NULL, E_WARNING, \"Option \\\"remove_all_path\\\" must be of type bool, %s given\",\n\t\t\t\tzend_zval_value_name(option));\n\t\t}\n\t\topts->remove_all_path = zval_get_long(option);\n\t}\n\n\tif ((option = zend_hash_str_find(options, \"comp_method\", sizeof(\"comp_method\") - 1)) != NULL) {\n\t\tif (Z_TYPE_P(option) != IS_LONG) {\n\t\t\tphp_error_docref(NULL, E_WARNING, \"Option \\\"comp_method\\\" must be of type int, %s given\",\n\t\t\t\tzend_zval_value_name(option));\n\t\t}\n\t\topts->comp_method = zval_get_long(option);\n\n\t\tif ((option = zend_hash_str_find(options, \"comp_flags\", sizeof(\"comp_flags\") - 1)) != NULL) {\n\t\t\tif (Z_TYPE_P(option) != IS_LONG) {\n\t\t\t\tphp_error_docref(NULL, E_WARNING, \"Option \\\"comp_flags\\\" must be of type int, %s given\",\n\t\t\t\t\tzend_zval_value_name(option));\n\t\t\t}\n\t\t\topts->comp_flags = zval_get_long(option);\n\t\t}\n\t}\n\n#ifdef HAVE_ENCRYPTION\n\tif ((option = zend_hash_str_find(options, \"enc_method\", sizeof(\"enc_method\") - 1)) != NULL) {\n\t\tif (Z_TYPE_P(option) != IS_LONG) {\n\t\t\tphp_error_docref(NULL, E_WARNING, \"Option \\\"enc_method\\\" must be of type int, %s given\",\n\t\t\t\tzend_zval_value_name(option));\n\t\t}\n\t\topts->enc_method = zval_get_long(option);\n\n\t\tif ((option = zend_hash_str_find(options, \"enc_password\", sizeof(\"enc_password\") - 1)) != NULL) {\n\t\t\tif (Z_TYPE_P(option) != IS_STRING) {\n\t\t\t\tzend_type_error(\"Option \\\"enc_password\\\" must be of type string, %s given\",\n\t\t\t\t\tzend_zval_value_name(option));\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\topts->enc_password = Z_STRVAL_P(option);\n\t\t}\n\t}\n#endif\n\n\tif ((option = zend_hash_str_find(options, \"remove_path\", sizeof(\"remove_path\") - 1)) != NULL) {\n\t\tif (Z_TYPE_P(option) != IS_STRING) {\n\t\t\tzend_type_error(\"Option \\\"remove_path\\\" must be of type string, %s given\",\n\t\t\t\tzend_zval_value_name(option));\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (Z_STRLEN_P(option) == 0) {\n\t\t\tzend_value_error(\"Option \\\"remove_path\\\" must not be empty\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (Z_STRLEN_P(option) >= MAXPATHLEN) {\n\t\t\tzend_value_error(\"Option \\\"remove_path\\\" must be less than %d bytes\", MAXPATHLEN - 1);\n\t\t\treturn -1;\n\t\t}\n\t\topts->remove_path_len = Z_STRLEN_P(option);\n\t\topts->remove_path = Z_STRVAL_P(option);\n\t}\n\n\tif ((option = zend_hash_str_find(options, \"add_path\", sizeof(\"add_path\") - 1)) != NULL) {\n\t\tif (Z_TYPE_P(option) != IS_STRING) {\n\t\t\tzend_type_error(\"Option \\\"add_path\\\" must be of type string, %s given\",\n\t\t\t\tzend_zval_value_name(option));\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (Z_STRLEN_P(option) == 0) {\n\t\t\tzend_value_error(\"Option \\\"add_path\\\" must not be empty\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (Z_STRLEN_P(option) >= MAXPATHLEN) {\n\t\t\tzend_value_error(\"Option \\\"add_path\\\" must be less than %d bytes\", MAXPATHLEN - 1);\n\t\t\treturn -1;\n\t\t}\n\t\topts->add_path_len = Z_STRLEN_P(option);\n\t\topts->add_path = Z_STRVAL_P(option);\n\t}\n\n\tif ((option = zend_hash_str_find(options, \"flags\", sizeof(\"flags\") - 1)) != NULL) {\n\t\tif (Z_TYPE_P(option) != IS_LONG) {\n\t\t\tzend_type_error(\"Option \\\"flags\\\" must be of type int, %s given\",\n\t\t\t\tzend_zval_value_name(option));\n\t\t\treturn -1;\n\t\t}\n\t\topts->flags = Z_LVAL_P(option);\n\t}\n\n\treturn 1;\n}\n/* }}} */\n\n/* {{{ ZIP_FROM_OBJECT */\n#define ZIP_FROM_OBJECT(intern, object) \\\n\t{ \\\n\t\tze_zip_object *obj = Z_ZIP_P(object); \\\n\t\tintern = obj->za; \\\n\t\tif (!intern) { \\\n\t\t\tzend_value_error(\"Invalid or uninitialized Zip object\"); \\\n\t\t\tRETURN_THROWS(); \\\n\t\t} \\\n\t}\n/* }}} */\n\n/* {{{ RETURN_SB(sb) */\n#ifdef HAVE_ENCRYPTION\n#define RETURN_SB(sb) \\\n\t{ \\\n\t\tarray_init(return_value); \\\n\t\tadd_ascii_assoc_string(return_value, \"name\", (char *)(sb)->name); \\\n\t\tadd_ascii_assoc_long(return_value, \"index\", (zend_long) (sb)->index); \\\n\t\tadd_ascii_assoc_long(return_value, \"crc\", (zend_long) (sb)->crc); \\\n\t\tadd_ascii_assoc_long(return_value, \"size\", (zend_long) (sb)->size); \\\n\t\tadd_ascii_assoc_long(return_value, \"mtime\", (zend_long) (sb)->mtime); \\\n\t\tadd_ascii_assoc_long(return_value, \"comp_size\", (zend_long) (sb)->comp_size); \\\n\t\tadd_ascii_assoc_long(return_value, \"comp_method\", (zend_long) (sb)->comp_method); \\\n\t\tadd_ascii_assoc_long(return_value, \"encryption_method\", (zend_long) (sb)->encryption_method); \\\n\t}\n#else\n#define RETURN_SB(sb) \\\n\t{ \\\n\t\tarray_init(return_value); \\\n\t\tadd_ascii_assoc_string(return_value, \"name\", (char *)(sb)->name); \\\n\t\tadd_ascii_assoc_long(return_value, \"index\", (zend_long) (sb)->index); \\\n\t\tadd_ascii_assoc_long(return_value, \"crc\", (zend_long) (sb)->crc); \\\n\t\tadd_ascii_assoc_long(return_value, \"size\", (zend_long) (sb)->size); \\\n\t\tadd_ascii_assoc_long(return_value, \"mtime\", (zend_long) (sb)->mtime); \\\n\t\tadd_ascii_assoc_long(return_value, \"comp_size\", (zend_long) (sb)->comp_size); \\\n\t\tadd_ascii_assoc_long(return_value, \"comp_method\", (zend_long) (sb)->comp_method); \\\n\t}\n#endif\n/* }}} */\n\nstatic zend_long php_zip_status(ze_zip_object *obj) /* {{{ */\n{\n\tint zep = obj->err_zip; /* saved err if closed */\n\n\tif (obj->za) {\n#if LIBZIP_VERSION_MAJOR < 1\n\t\tint syp;\n\n\t\tzip_error_get(obj->za, &zep, &syp);\n#else\n\t\tzip_error_t *err;\n\n\t\terr = zip_get_error(obj->za);\n\t\tzep = zip_error_code_zip(err);\n\t\tzip_error_fini(err);\n#endif\n\t}\n\treturn zep;\n}\n/* }}} */\n\nstatic zend_long php_zip_last_id(ze_zip_object *obj) /* {{{ */\n{\n\treturn obj->last_id;\n}\n/* }}} */\n\nstatic zend_long php_zip_status_sys(ze_zip_object *obj) /* {{{ */\n{\n\tint syp = obj->err_sys;  /* saved err if closed */\n\n\tif (obj->za) {\n#if LIBZIP_VERSION_MAJOR < 1\n\t\tint zep;\n\n\t\tzip_error_get(obj->za, &zep, &syp);\n#else\n\t\tzip_error_t *err;\n\n\t\terr = zip_get_error(obj->za);\n\t\tsyp = zip_error_code_system(err);\n\t\tzip_error_fini(err);\n#endif\n\t}\n\treturn syp;\n}\n/* }}} */\n\nstatic zend_long php_zip_get_num_files(ze_zip_object *obj) /* {{{ */\n{\n\tif (obj->za) {\n\t\tzip_int64_t num = zip_get_num_entries(obj->za, 0);\n\t\treturn MIN(num, ZEND_LONG_MAX);\n\t}\n\treturn 0;\n}\n/* }}} */\n\nstatic char * php_zipobj_get_filename(ze_zip_object *obj, int *len) /* {{{ */\n{\n\tif (obj && obj->filename) {\n\t\t*len = strlen(obj->filename);\n\t\treturn obj->filename;\n\t}\n\treturn NULL;\n}\n/* }}} */\n\nstatic char * php_zipobj_get_zip_comment(ze_zip_object *obj, int *len) /* {{{ */\n{\n\tif (obj->za) {\n\t\treturn (char *)zip_get_archive_comment(obj->za, len, 0);\n\t}\n\treturn NULL;\n}\n/* }}} */\n\nint php_zip_glob(char *pattern, int pattern_len, zend_long flags, zval *return_value) /* {{{ */\n{\n\tint cwd_skip = 0;\n#ifdef ZTS\n\tchar cwd[MAXPATHLEN];\n\tchar work_pattern[MAXPATHLEN];\n\tchar *result;\n#endif\n\tphp_glob_t globbuf;\n\tsize_t n;\n\tint ret;\n\n\tif (pattern_len >= MAXPATHLEN) {\n\t\tphp_error_docref(NULL, E_WARNING, \"Pattern exceeds the maximum allowed length of %d characters\", MAXPATHLEN);\n\t\treturn -1;\n\t}\n\n\tif ((PHP_GLOB_AVAILABLE_FLAGS & flags) != flags) {\n\n\t\tphp_error_docref(NULL, E_WARNING, \"At least one of the passed flags is invalid or not supported on this platform\");\n\t\treturn -1;\n\t}\n\n#ifdef ZTS\n\tif (!IS_ABSOLUTE_PATH(pattern, pattern_len)) {\n\t\tresult = VCWD_GETCWD(cwd, MAXPATHLEN);\n\t\tif (!result) {\n\t\t\tcwd[0] = '\\0';\n\t\t}\n#ifdef PHP_WIN32\n\t\tif (IS_SLASH(*pattern)) {\n\t\t\tcwd[2] = '\\0';\n\t\t}\n#endif\n\t\tcwd_skip = strlen(cwd)+1;\n\n\t\tsnprintf(work_pattern, MAXPATHLEN, \"%s%c%s\", cwd, DEFAULT_SLASH, pattern);\n\t\tpattern = work_pattern;\n\t}\n#endif\n\n\tglobbuf.gl_offs = 0;\n\tif (0 != (ret = php_glob(pattern, flags & PHP_GLOB_FLAGMASK, NULL, &globbuf))) {\n#ifdef PHP_GLOB_NOMATCH\n\t\tif (PHP_GLOB_NOMATCH == ret) {\n\t\t\t/* Some glob implementation simply return no data if no matches\n\t\t\t   were found, others return the PHP_GLOB_NOMATCH error code.\n\t\t\t   We don't want to treat PHP_GLOB_NOMATCH as an error condition\n\t\t\t   so that PHP glob() behaves the same on both types of\n\t\t\t   implementations and so that 'foreach (glob() as ...'\n\t\t\t   can be used for simple glob() calls without further error\n\t\t\t   checking.\n\t\t\t*/\n\t\t\treturn 0;\n\t\t}\n#endif\n\t\treturn 0;\n\t}\n\n\t/* now catch the FreeBSD style of \"no matches\" */\n\tif (!globbuf.gl_pathc || !globbuf.gl_pathv) {\n\t\treturn 0;\n\t}\n\n\t/* we assume that any glob pattern will match files from one directory only\n\t   so checking the dirname of the first match should be sufficient */\n\tif (ZIP_OPENBASEDIR_CHECKPATH(globbuf.gl_pathv[0])) {\n\t\treturn -1;\n\t}\n\n\tarray_init(return_value);\n\tfor (n = 0; n < globbuf.gl_pathc; n++) {\n\t\t/* we need to do this every time since PHP_GLOB_ONLYDIR does not guarantee that\n\t\t * all directories will be filtered. GNU libc documentation states the\n\t\t * following:\n\t\t * If the information about the type of the file is easily available\n\t\t * non-directories will be rejected but no extra work will be done to\n\t\t * determine the information for each file. I.e., the caller must still be\n\t\t * able to filter directories out.\n\t\t */\n\t\tif (flags & PHP_GLOB_ONLYDIR) {\n\t\t\tzend_stat_t s = {0};\n\n\t\t\tif (0 != VCWD_STAT(globbuf.gl_pathv[n], &s)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (S_IFDIR != (s.st_mode & S_IFMT)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tadd_next_index_string(return_value, globbuf.gl_pathv[n]+cwd_skip);\n\t}\n\n\tret = globbuf.gl_pathc;\n\tphp_globfree(&globbuf);\n\treturn ret;\n}\n/* }}} */\n\nint php_zip_pcre(zend_string *regexp, char *path, int path_len, zval *return_value) /* {{{ */\n{\n#ifdef ZTS\n\tchar cwd[MAXPATHLEN];\n\tchar work_path[MAXPATHLEN];\n\tchar *result;\n#endif\n\tint files_cnt;\n\tzend_string **namelist;\n\tpcre2_match_context *mctx = php_pcre_mctx();\n\n#ifdef ZTS\n\tif (!IS_ABSOLUTE_PATH(path, path_len)) {\n\t\tresult = VCWD_GETCWD(cwd, MAXPATHLEN);\n\t\tif (!result) {\n\t\t\tcwd[0] = '\\0';\n\t\t}\n#ifdef PHP_WIN32\n\t\tif (IS_SLASH(*path)) {\n\t\t\tcwd[2] = '\\0';\n\t\t}\n#endif\n\t\tsnprintf(work_path, MAXPATHLEN, \"%s%c%s\", cwd, DEFAULT_SLASH, path);\n\t\tpath = work_path;\n\t}\n#endif\n\n\tif (ZIP_OPENBASEDIR_CHECKPATH(path)) {\n\t\treturn -1;\n\t}\n\n\tfiles_cnt = php_stream_scandir(path, &namelist, NULL, (void *) php_stream_dirent_alphasort);\n\n\tif (files_cnt > 0) {\n\t\tpcre2_code *re = NULL;\n\t\tpcre2_match_data *match_data = NULL;\n\t\tuint32_t i, capture_count;\n\t\tint rc;\n\n\t\tre = pcre_get_compiled_regex(regexp, &capture_count);\n\t\tif (!re) {\n\t\t\tfor (i = 0; i < files_cnt; i++) {\n\t\t\t\tzend_string_release_ex(namelist[i], 0);\n\t\t\t}\n\t\t\tefree(namelist);\n\t\t\tphp_error_docref(NULL, E_WARNING, \"Invalid expression\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tarray_init(return_value);\n\n\t\t/* only the files, directories are ignored */\n\t\tfor (i = 0; i < files_cnt; i++) {\n\t\t\tzend_stat_t s = {0};\n\t\t\tchar   fullpath[MAXPATHLEN];\n\t\t\tsize_t    namelist_len = ZSTR_LEN(namelist[i]);\n\n\t\t\tif ((namelist_len == 1 && ZSTR_VAL(namelist[i])[0] == '.') ||\n\t\t\t\t(namelist_len == 2 && ZSTR_VAL(namelist[i])[0] == '.' && ZSTR_VAL(namelist[i])[1] == '.')) {\n\t\t\t\tzend_string_release_ex(namelist[i], 0);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif ((path_len + namelist_len + 1) >= MAXPATHLEN) {\n\t\t\t\tphp_error_docref(NULL, E_WARNING, \"add_path string too long (max: %u, %zu given)\",\n\t\t\t\t\t\tMAXPATHLEN - 1, (path_len + namelist_len + 1));\n\t\t\t\tzend_string_release_ex(namelist[i], 0);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tmatch_data = php_pcre_create_match_data(capture_count, re);\n\t\t\tif (!match_data) {\n\t\t\t\t/* Allocation failed, but can proceed to the next pattern. */\n\t\t\t\tzend_string_release_ex(namelist[i], 0);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trc = pcre2_match(re, (PCRE2_SPTR)ZSTR_VAL(namelist[i]), ZSTR_LEN(namelist[i]), 0, 0, match_data, mctx);\n\t\t\tphp_pcre_free_match_data(match_data);\n\t\t\t/* 0 means that the vector is too small to hold all the captured substring offsets */\n\t\t\tif (rc < 0) {\n\t\t\t\tzend_string_release_ex(namelist[i], 0);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tsnprintf(fullpath, MAXPATHLEN, \"%s%c%s\", path, DEFAULT_SLASH, ZSTR_VAL(namelist[i]));\n\n\t\t\tif (0 != VCWD_STAT(fullpath, &s)) {\n\t\t\t\tphp_error_docref(NULL, E_WARNING, \"Cannot read <%s>\", fullpath);\n\t\t\t\tzend_string_release_ex(namelist[i], 0);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (S_IFDIR == (s.st_mode & S_IFMT)) {\n\t\t\t\tzend_string_release_ex(namelist[i], 0);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tadd_next_index_string(return_value, fullpath);\n\t\t\tzend_string_release_ex(namelist[i], 0);\n\t\t}\n\t\tefree(namelist);\n\t}\n\treturn files_cnt;\n}\n/* }}} */\n\n/* {{{ ZE2 OO definitions */\nstatic zend_class_entry *zip_class_entry;\nstatic zend_object_handlers zip_object_handlers;\n\nstatic HashTable zip_prop_handlers;\n\ntypedef zend_long (*zip_read_int_t)(ze_zip_object *obj);\ntypedef char *(*zip_read_const_char_t)(ze_zip_object *obj, int *len);\n\ntypedef struct _zip_prop_handler {\n\tzip_read_int_t read_int_func;\n\tzip_read_const_char_t read_const_char_func;\n\n\tint type;\n} zip_prop_handler;\n/* }}} */\n\nstatic void php_zip_register_prop_handler(HashTable *prop_handler, char *name, zip_read_int_t read_int_func, zip_read_const_char_t read_char_func, int rettype) /* {{{ */\n{\n\tzip_prop_handler hnd;\n\tzend_string *str;\n\n\thnd.read_const_char_func = read_char_func;\n\thnd.read_int_func = read_int_func;\n\thnd.type = rettype;\n\tstr = zend_string_init_interned(name, strlen(name), 1);\n\tzend_hash_add_mem(prop_handler, str, &hnd, sizeof(zip_prop_handler));\n\tzend_string_release_ex(str, 1);\n}\n/* }}} */\n\nstatic zval *php_zip_property_reader(ze_zip_object *obj, zip_prop_handler *hnd, zval *rv) /* {{{ */\n{\n\tconst char *retchar = NULL;\n\tzend_long retint = 0;\n\tint len = 0;\n\n\tif (hnd->read_const_char_func) {\n\t\tretchar = hnd->read_const_char_func(obj, &len);\n\t} else if (hnd->read_int_func) {\n\t\tretint = hnd->read_int_func(obj);\n\t}\n\n\tswitch (hnd->type) {\n\t\tcase IS_STRING:\n\t\t\tif (retchar) {\n\t\t\t\tZVAL_STRINGL(rv, (char *) retchar, len);\n\t\t\t} else {\n\t\t\t\tZVAL_EMPTY_STRING(rv);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase IS_LONG:\n\t\t\tZVAL_LONG(rv, retint);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tZVAL_NULL(rv);\n\t}\n\n\treturn rv;\n}\n/* }}} */\n\nstatic zval *php_zip_get_property_ptr_ptr(zend_object *object, zend_string *name, int type, void **cache_slot) /* {{{ */\n{\n\tze_zip_object *obj;\n\tzval *retval = NULL;\n\tzip_prop_handler *hnd = NULL;\n\n\tobj = php_zip_fetch_object(object);\n\n\tif (obj->prop_handler != NULL) {\n\t\thnd = zend_hash_find_ptr(obj->prop_handler, name);\n\t}\n\n\tif (hnd == NULL) {\n\t\tretval = zend_std_get_property_ptr_ptr(object, name, type, cache_slot);\n\t} else if (cache_slot) {\n\t\tcache_slot[0] = cache_slot[1] = cache_slot[2] = NULL;\n\t}\n\n\treturn retval;\n}\n/* }}} */\n\n\nstatic zval *php_zip_write_property(zend_object *object, zend_string *name, zval *value, void **cache_slot)\n{\n\tze_zip_object *obj;\n\tzip_prop_handler *hnd = NULL;\n\n\tobj = php_zip_fetch_object(object);\n\n\tif (obj->prop_handler != NULL) {\n\t\thnd = zend_hash_find_ptr(obj->prop_handler, name);\n\t}\n\n\tif (hnd != NULL) {\n\t\tzend_throw_error(NULL, \"Cannot write read-only property %s::$%s\", ZSTR_VAL(object->ce->name), ZSTR_VAL(name));\n\t\treturn &EG(error_zval);\n\t}\n\n\treturn zend_std_write_property(object, name, value, cache_slot);\n}\n\nstatic zval *php_zip_read_property(zend_object *object, zend_string *name, int type, void **cache_slot, zval *rv) /* {{{ */\n{\n\tze_zip_object *obj;\n\tzval *retval = NULL;\n\tzip_prop_handler *hnd = NULL;\n\n\tobj = php_zip_fetch_object(object);\n\n\tif (obj->prop_handler != NULL) {\n\t\thnd = zend_hash_find_ptr(obj->prop_handler, name);\n\t}\n\n\tif (hnd != NULL) {\n\t\tretval = php_zip_property_reader(obj, hnd, rv);\n\t\tif (retval == NULL) {\n\t\t\tretval = &EG(uninitialized_zval);\n\t\t}\n\t} else {\n\t\tretval = zend_std_read_property(object, name, type, cache_slot, rv);\n\t}\n\n\treturn retval;\n}\n/* }}} */\n\n// todo: make php_zip_has_property return bool as well\nstatic int php_zip_has_property(zend_object *object, zend_string *name, int type, void **cache_slot) /* {{{ */\n{\n\tze_zip_object *obj;\n\tzip_prop_handler *hnd = NULL;\n\tbool retval = false;\n\n\tobj = php_zip_fetch_object(object);\n\n\tif (obj->prop_handler != NULL) {\n\t\thnd = zend_hash_find_ptr(obj->prop_handler, name);\n\t}\n\n\tif (hnd != NULL) {\n\t\tzval tmp, *prop;\n\n\t\tif (type == 2) {\n\t\t\tretval = true;\n\t\t} else if ((prop = php_zip_property_reader(obj, hnd, &tmp)) != NULL) {\n\t\t\tif (type == 1) {\n\t\t\t\tretval = zend_is_true(&tmp);\n\t\t\t} else if (type == 0) {\n\t\t\t\tretval = (Z_TYPE(tmp) != IS_NULL);\n\t\t\t}\n\t\t}\n\n\t\tzval_ptr_dtor(&tmp);\n\t} else {\n\t\tretval = zend_std_has_property(object, name, type, cache_slot);\n\t}\n\n\treturn retval;\n}\n/* }}} */\n\nstatic HashTable *php_zip_get_gc(zend_object *object, zval **gc_data, int *gc_data_count) /* {{{ */\n{\n\t*gc_data = NULL;\n\t*gc_data_count = 0;\n\treturn zend_std_get_properties(object);\n}\n/* }}} */\n\nstatic HashTable *php_zip_get_properties(zend_object *object)/* {{{ */\n{\n\tze_zip_object *obj;\n\tHashTable *props;\n\tzip_prop_handler *hnd;\n\tzend_string *key;\n\n\tobj = php_zip_fetch_object(object);\n\tprops = zend_std_get_properties(object);\n\n\tif (obj->prop_handler == NULL) {\n\t\treturn NULL;\n\t}\n\n\tZEND_HASH_MAP_FOREACH_STR_KEY_PTR(obj->prop_handler, key, hnd) {\n\t\tzval *ret, val;\n\t\tret = php_zip_property_reader(obj, hnd, &val);\n\t\tif (ret == NULL) {\n\t\t\tret = &EG(uninitialized_zval);\n\t\t}\n\t\tzend_hash_update(props, key, ret);\n\t} ZEND_HASH_FOREACH_END();\n\n\treturn props;\n}\n/* }}} */\n\n#ifdef HAVE_PROGRESS_CALLBACK\nstatic void php_zip_progress_callback_free(void *ptr)\n{\n\tze_zip_object *obj = ptr;\n\n\tif (ZEND_FCC_INITIALIZED(obj->progress_callback)) {\n\t\tzend_fcc_dtor(&obj->progress_callback);\n\t}\n}\n#endif\n\n#ifdef HAVE_CANCEL_CALLBACK\nstatic void php_zip_cancel_callback_free(void *ptr)\n{\n\tze_zip_object *obj = ptr;\n\n\tif (ZEND_FCC_INITIALIZED(obj->cancel_callback)) {\n\t\tzend_fcc_dtor(&obj->cancel_callback);\n\t}\n}\n#endif\n\nstatic void php_zip_object_free_storage(zend_object *object) /* {{{ */\n{\n\tze_zip_object * intern = php_zip_fetch_object(object);\n\tint i;\n\n\tif (intern->za) {\n\t\tif (zip_close(intern->za) != 0) {\n\t\t\tphp_error_docref(NULL, E_WARNING, \"Cannot destroy the zip context: %s\", zip_strerror(intern->za));\n\t\t\tzip_discard(intern->za);\n\t\t}\n\t}\n\n\tif (intern->buffers_cnt>0) {\n\t\tfor (i=0; i<intern->buffers_cnt; i++) {\n\t\t\tefree(intern->buffers[i]);\n\t\t}\n\t\tefree(intern->buffers);\n\t}\n\n#ifdef HAVE_PROGRESS_CALLBACK\n\t/* if not properly called by libzip */\n\tphp_zip_progress_callback_free(intern);\n#endif\n\n#ifdef HAVE_CANCEL_CALLBACK\n\t/* if not properly called by libzip */\n\tphp_zip_cancel_callback_free(intern);\n#endif\n\n\tintern->za = NULL;\n\tzend_object_std_dtor(&intern->zo);\n\n\tif (intern->filename) {\n\t\tefree(intern->filename);\n\t}\n}\n/* }}} */\n\nstatic zend_object *php_zip_object_new(zend_class_entry *class_type) /* {{{ */\n{\n\tze_zip_object *intern;\n\n\tintern = zend_object_alloc(sizeof(ze_zip_object), class_type);\n\tintern->prop_handler = &zip_prop_handlers;\n\tzend_object_std_init(&intern->zo, class_type);\n\tobject_properties_init(&intern->zo, class_type);\n\tintern->last_id = -1;\n\n\treturn &intern->zo;\n}\n/* }}} */\n\n/* {{{ Resource dtors */\n\n/* {{{ php_zip_free_dir */\nstatic void php_zip_free_dir(zend_resource *rsrc)\n{\n\tzip_rsrc * zip_int = (zip_rsrc *) rsrc->ptr;\n\n\tif (zip_int) {\n\t\tif (zip_int->za) {\n\t\t\tif (zip_close(zip_int->za) != 0) {\n\t\t\t\tphp_error_docref(NULL, E_WARNING, \"Cannot destroy the zip context\");\n\t\t\t}\n\t\t\tzip_int->za = NULL;\n\t\t}\n\n\t\tefree(rsrc->ptr);\n\n\t\trsrc->ptr = NULL;\n\t}\n}\n/* }}} */\n\n/* {{{ php_zip_free_entry */\nstatic void php_zip_free_entry(zend_resource *rsrc)\n{\n\tzip_read_rsrc *zr_rsrc = (zip_read_rsrc *) rsrc->ptr;\n\n\tif (zr_rsrc) {\n\t\tif (zr_rsrc->zf) {\n\t\t\tzip_fclose(zr_rsrc->zf);\n\t\t\tzr_rsrc->zf = NULL;\n\t\t}\n\t\tefree(zr_rsrc);\n\t\trsrc->ptr = NULL;\n\t}\n}\n/* }}} */\n\n/* }}}*/\n\n/* reset macro */\n\n/* {{{ function prototypes */\nstatic PHP_MINIT_FUNCTION(zip);\nstatic PHP_MSHUTDOWN_FUNCTION(zip);\nstatic PHP_MINFO_FUNCTION(zip);\n/* }}} */\n\nstatic const zend_module_dep zip_deps[] = {\n\tZEND_MOD_REQUIRED(\"pcre\")\n\tZEND_MOD_END\n};\n\n/* {{{ zip_module_entry */\nzend_module_entry zip_module_entry = {\n\tSTANDARD_MODULE_HEADER_EX, NULL,\n\tzip_deps,\n\t\"zip\",\n\text_functions,\n\tPHP_MINIT(zip),\n\tPHP_MSHUTDOWN(zip),\n\tNULL,\n\tNULL,\n\tPHP_MINFO(zip),\n\tPHP_ZIP_VERSION,\n\tSTANDARD_MODULE_PROPERTIES\n};\n/* }}} */\n\n#ifdef COMPILE_DL_ZIP\nZEND_GET_MODULE(zip)\n#endif\n/* set macro */\n\n/* {{{ Create new zip using source uri for output */\nPHP_FUNCTION(zip_open)\n{\n\tchar resolved_path[MAXPATHLEN + 1];\n\tzip_rsrc *rsrc_int;\n\tint err = 0;\n\tzend_string *filename;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"P\", &filename) == FAILURE) {\n\t\tRETURN_THROWS();\n\t}\n\n\tif (ZSTR_LEN(filename) == 0) {\n\t\tzend_argument_must_not_be_empty_error(1);\n\t\tRETURN_THROWS();\n\t}\n\n\tif (ZIP_OPENBASEDIR_CHECKPATH(ZSTR_VAL(filename))) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif(!expand_filepath(ZSTR_VAL(filename), resolved_path)) {\n\t\tphp_error_docref(NULL, E_WARNING, \"No such file or directory\");\n\t\tRETURN_FALSE;\n\t}\n\n\trsrc_int = (zip_rsrc *)emalloc(sizeof(zip_rsrc));\n\n\trsrc_int->za = zip_open(resolved_path, 0, &err);\n\tif (rsrc_int->za == NULL) {\n\t\tefree(rsrc_int);\n\t\tRETURN_LONG((zend_long)err);\n\t}\n\n\trsrc_int->index_current = 0;\n\trsrc_int->num_files = zip_get_num_entries(rsrc_int->za, 0);\n\n\tRETURN_RES(zend_register_resource(rsrc_int, le_zip_dir));\n}\n/* }}} */\n\n/* {{{ Close a Zip archive */\nPHP_FUNCTION(zip_close)\n{\n\tzval * zip;\n\tzip_rsrc *z_rsrc = NULL;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"r\", &zip) == FAILURE) {\n\t\tRETURN_THROWS();\n\t}\n\n\tif ((z_rsrc = (zip_rsrc *)zend_fetch_resource(Z_RES_P(zip), le_zip_dir_name, le_zip_dir)) == NULL) {\n\t\tRETURN_THROWS();\n\t}\n\n\t/* really close the zip will break BC :-D */\n\tzend_list_close(Z_RES_P(zip));\n}\n/* }}} */\n\n/* {{{ Returns the next file in the archive */\nPHP_FUNCTION(zip_read)\n{\n\tzval *zip_dp;\n\tzip_read_rsrc *zr_rsrc;\n\tint ret;\n\tzip_rsrc *rsrc_int;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"r\", &zip_dp) == FAILURE) {\n\t\tRETURN_THROWS();\n\t}\n\n\tif ((rsrc_int = (zip_rsrc *)zend_fetch_resource(Z_RES_P(zip_dp), le_zip_dir_name, le_zip_dir)) == NULL) {\n\t\tRETURN_THROWS();\n\t}\n\n\tif (rsrc_int && rsrc_int->za) {\n\t\tif (rsrc_int->index_current >= rsrc_int->num_files) {\n\t\t\tRETURN_FALSE;\n\t\t}\n\n\t\tzr_rsrc = emalloc(sizeof(zip_read_rsrc));\n\n\t\tret = zip_stat_index(rsrc_int->za, rsrc_int->index_current, 0, &zr_rsrc->sb);\n\n\t\tif (ret != 0) {\n\t\t\tefree(zr_rsrc);\n\t\t\tRETURN_FALSE;\n\t\t}\n\n\t\tzr_rsrc->zip_rsrc_handle = Z_RES_P(zip_dp)->handle;\n\t\tzr_rsrc->zf = zip_fopen_index(rsrc_int->za, rsrc_int->index_current, 0);\n\t\tif (zr_rsrc->zf) {\n\t\t\trsrc_int->index_current++;\n\t\t\tRETURN_RES(zend_register_resource(zr_rsrc, le_zip_entry));\n\t\t} else {\n\t\t\tefree(zr_rsrc);\n\t\t\tRETURN_FALSE;\n\t\t}\n\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n}\n/* }}} */\n\n/* {{{ Open a Zip File, pointed by the resource entry */\n/* Dummy function to follow the old API */\nPHP_FUNCTION(zip_entry_open)\n{\n\tzval * zip;\n\tzval * zip_entry;\n\tchar *mode = NULL;\n\tsize_t mode_len = 0;\n\tzip_read_rsrc * zr_rsrc;\n\tzip_rsrc *z_rsrc;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"rr|s\", &zip, &zip_entry, &mode, &mode_len) == FAILURE) {\n\t\tRETURN_THROWS();\n\t}\n\n\tif ((zr_rsrc = (zip_read_rsrc *)zend_fetch_resource(Z_RES_P(zip_entry), le_zip_entry_name, le_zip_entry)) == NULL) {\n\t\tRETURN_THROWS();\n\t}\n\n\tif ((z_rsrc = (zip_rsrc *)zend_fetch_resource(Z_RES_P(zip), le_zip_dir_name, le_zip_dir)) == NULL) {\n\t\tRETURN_THROWS();\n\t}\n\n\tif (zr_rsrc->zf != NULL) {\n\t\tRETURN_TRUE;\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n}\n/* }}} */\n\n/* {{{ Close a zip entry */\nPHP_FUNCTION(zip_entry_close)\n{\n\tzval * zip_entry;\n\tzip_read_rsrc * zr_rsrc;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"r\", &zip_entry) == FAILURE) {\n\t\tRETURN_THROWS();\n\t}\n\n\tif ((zr_rsrc = (zip_read_rsrc *)zend_fetch_resource(Z_RES_P(zip_entry), le_zip_entry_name, le_zip_entry)) == NULL) {\n\t\tRETURN_THROWS();\n\t}\n\n\tzend_list_close(Z_RES_P(zip_entry));\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ Read from an open directory entry */\nPHP_FUNCTION(zip_entry_read)\n{\n\tzval * zip_entry;\n\tzend_long len = 0;\n\tzip_read_rsrc * zr_rsrc;\n\tzend_string *buffer;\n\tint n = 0;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"r|l\", &zip_entry, &len) == FAILURE) {\n\t\tRETURN_THROWS();\n\t}\n\n\tif ((zr_rsrc = (zip_read_rsrc *)zend_fetch_resource(Z_RES_P(zip_entry), le_zip_entry_name, le_zip_entry)) == NULL) {\n\t\tRETURN_THROWS();\n\t}\n\n\tif (len <= 0) {\n\t\tlen = 1024;\n\t}\n\n\tif (zr_rsrc->zf) {\n\t\tbuffer = zend_string_safe_alloc(1, len, 0, 0);\n\t\tn = zip_fread(zr_rsrc->zf, ZSTR_VAL(buffer), ZSTR_LEN(buffer));\n\t\tif (n > 0) {\n\t\t\tZSTR_VAL(buffer)[n] = '\\0';\n\t\t\tZSTR_LEN(buffer) = n;\n\t\t\tRETURN_NEW_STR(buffer);\n\t\t} else {\n\t\t\tzend_string_efree(buffer);\n\t\t\tRETURN_EMPTY_STRING();\n\t\t}\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n}\n/* }}} */\n\nstatic void php_zip_entry_get_info(INTERNAL_FUNCTION_PARAMETERS, int opt) /* {{{ */\n{\n\tzval * zip_entry;\n\tzip_read_rsrc * zr_rsrc;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"r\", &zip_entry) == FAILURE) {\n\t\tRETURN_THROWS();\n\t}\n\n\tif ((zr_rsrc = (zip_read_rsrc *)zend_fetch_resource(Z_RES_P(zip_entry), le_zip_entry_name, le_zip_entry)) == NULL) {\n\t\tRETURN_THROWS();\n\t}\n\n\tif (!zr_rsrc->zf || !zend_hash_index_exists(&EG(regular_list), zr_rsrc->zip_rsrc_handle)) {\n\t\tRETURN_FALSE;\n\t}\n\n\tswitch (opt) {\n\t\tcase 0:\n\t\t\tRETURN_STRING((char *)zr_rsrc->sb.name);\n\t\tcase 1:\n\t\t\tRETURN_LONG((zend_long) (zr_rsrc->sb.comp_size));\n\t\tcase 2:\n\t\t\tRETURN_LONG((zend_long) (zr_rsrc->sb.size));\n\t\tcase 3:\n\t\t\tswitch (zr_rsrc->sb.comp_method) {\n\t\t\t\tcase 0:\n\t\t\t\t\tRETURN_STRING(\"stored\");\n\t\t\t\tcase 1:\n\t\t\t\t\tRETURN_STRING(\"shrunk\");\n\t\t\t\tcase 2:\n\t\t\t\tcase 3:\n\t\t\t\tcase 4:\n\t\t\t\tcase 5:\n\t\t\t\t\tRETURN_STRING(\"reduced\");\n\t\t\t\tcase 6:\n\t\t\t\t\tRETURN_STRING(\"imploded\");\n\t\t\t\tcase 7:\n\t\t\t\t\tRETURN_STRING(\"tokenized\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase 8:\n\t\t\t\t\tRETURN_STRING(\"deflated\");\n\t\t\t\tcase 9:\n\t\t\t\t\tRETURN_STRING(\"deflatedX\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase 10:\n\t\t\t\t\tRETURN_STRING(\"implodedX\");\n\t\t\t\tdefault:\n\t\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\t}\n\n}\n/* }}} */\n\n/* {{{ Return the name given a ZZip entry */\nPHP_FUNCTION(zip_entry_name)\n{\n\tphp_zip_entry_get_info(INTERNAL_FUNCTION_PARAM_PASSTHRU, 0);\n}\n/* }}} */\n\n/* {{{ Return the compressed size of a ZZip entry */\nPHP_FUNCTION(zip_entry_compressedsize)\n{\n\tphp_zip_entry_get_info(INTERNAL_FUNCTION_PARAM_PASSTHRU, 1);\n}\n/* }}} */\n\n/* {{{ Return the actual filesize of a ZZip entry */\nPHP_FUNCTION(zip_entry_filesize)\n{\n\tphp_zip_entry_get_info(INTERNAL_FUNCTION_PARAM_PASSTHRU, 2);\n}\n/* }}} */\n\n/* {{{ Return a string containing the compression method used on a particular entry */\nPHP_FUNCTION(zip_entry_compressionmethod)\n{\n\tphp_zip_entry_get_info(INTERNAL_FUNCTION_PARAM_PASSTHRU, 3);\n}\n/* }}} */\n\n/* {{{ Create new zip using source uri for output, return TRUE on success or the error code */\nPHP_METHOD(ZipArchive, open)\n{\n\tstruct zip *intern;\n\tint err = 0;\n\tzend_long flags = 0;\n\tchar *resolved_path;\n\tzend_string *filename;\n\tzval *self = ZEND_THIS;\n\tze_zip_object *ze_obj;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"P|l\", &filename, &flags) == FAILURE) {\n\t\tRETURN_THROWS();\n\t}\n\n\t/* We do not use ZIP_FROM_OBJECT, zip init function here */\n\tze_obj = Z_ZIP_P(self);\n\n\tif (ZSTR_LEN(filename) == 0) {\n\t\tzend_argument_must_not_be_empty_error(1);\n\t\tRETURN_THROWS();\n\t}\n\n\tif (ZIP_OPENBASEDIR_CHECKPATH(ZSTR_VAL(filename))) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (!(resolved_path = expand_filepath(ZSTR_VAL(filename), NULL))) {\n\t\tphp_error_docref(NULL, E_WARNING, \"No such file or directory\");\n\t\tRETURN_FALSE;\n\t}\n\n\tif (ze_obj->za) {\n\t\t/* we already have an opened zip, free it */\n\t\tif (zip_close(ze_obj->za) != 0) {\n\t\t\tphp_error_docref(NULL, E_WARNING, \"Empty string as source\");\n\t\t\tefree(resolved_path);\n\t\t\tRETURN_FALSE;\n\t\t}\n\t\tze_obj->za = NULL;\n\t}\n\tif (ze_obj->filename) {\n\t\tefree(ze_obj->filename);\n\t\tze_obj->filename = NULL;\n\t}\n\n\t/* open for write without option to empty the archive */\n#ifdef ZIP_RDONLY\n\tif ((flags & (ZIP_TRUNCATE | ZIP_RDONLY)) == 0) {\n#else\n\tif ((flags & ZIP_TRUNCATE) == 0) {\n#endif\n\t\tzend_stat_t st = {0};\n\n\t\t/* exists and is empty */\n\t\tif (VCWD_STAT(resolved_path, &st) == 0 && st.st_size == 0) {\n\t\t\tphp_error_docref(NULL, E_DEPRECATED, \"Using empty file as ZipArchive is deprecated\");\n\n\t\t\t/* reduce BC break introduced in libzip 1.6.0\n\t\t\t   \"Do not accept empty files as valid zip archives any longer\" */\n\t\t\tflags |= ZIP_TRUNCATE;\n\t\t}\n\t}\n\n\tintern = zip_open(resolved_path, flags, &err);\n\tif (!intern || err) {\n\t\tefree(resolved_path);\n\t\tRETURN_LONG((zend_long)err);\n\t}\n\tze_obj->filename = resolved_path;\n\tze_obj->filename_len = strlen(resolved_path);\n\tze_obj->za = intern;\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ Set the password for the active archive */\nPHP_METHOD(ZipArchive, setPassword)\n{\n\tstruct zip *intern;\n\tzval *self = ZEND_THIS;\n\tchar *password;\n\tsize_t\tpassword_len;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"s\", &password, &password_len) == FAILURE) {\n\t\tRETURN_THROWS();\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tif (password_len < 1) {\n\t\tRETURN_FALSE;\n\t}\n\n\tint res = zip_set_default_password(intern, (const char *)password);\n\tif (res == 0) {\n\t\tRETURN_TRUE;\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n}\n/* }}} */\n\n/* {{{ close the zip archive */\nPHP_METHOD(ZipArchive, close)\n{\n\tstruct zip *intern;\n\tzval *self = ZEND_THIS;\n\tze_zip_object *ze_obj;\n\tint err;\n\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\tRETURN_THROWS();\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tze_obj = Z_ZIP_P(self);\n\n\terr = zip_close(intern);\n\tif (err) {\n\t\tphp_error_docref(NULL, E_WARNING, \"%s\", zip_strerror(intern));\n\t\t/* Save error for property reader */\n\t\t#if LIBZIP_VERSION_MAJOR < 1\n\t\t\tzip_error_get(intern, &ze_obj->err_zip, &ze_obj->err_sys);\n\t\t#else\n\t\t\t{\n\t\t\tzip_error_t *ziperr;\n\n\t\t\tziperr = zip_get_error(intern);\n\t\t\tze_obj->err_zip = zip_error_code_zip(ziperr);\n\t\t\tze_obj->err_sys = zip_error_code_system(ziperr);\n\t\t\tzip_error_fini(ziperr);\n\t\t\t}\n\t\t#endif\n\t\tzip_discard(intern);\n\t} else {\n\t\tze_obj->err_zip = 0;\n\t\tze_obj->err_sys = 0;\n\t}\n\n\t/* clear cache as empty zip are not created but deleted */\n\tphp_clear_stat_cache(1, ze_obj->filename, ze_obj->filename_len);\n\n\tefree(ze_obj->filename);\n\tze_obj->filename = NULL;\n\tze_obj->filename_len = 0;\n\tze_obj->za = NULL;\n\n\tif (!err) {\n\t\tRETURN_TRUE;\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n}\n/* }}} */\n\n/* {{{ close the zip archive */\nPHP_METHOD(ZipArchive, count)\n{\n\tstruct zip *intern;\n\tzval *self = ZEND_THIS;\n\tzip_int64_t num;\n\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\tRETURN_THROWS();\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tnum = zip_get_num_entries(intern, 0);\n\tRETVAL_LONG(MIN(num, ZEND_LONG_MAX));\n}\n/* }}} */\n\n/* {{{ clear the internal status */\nPHP_METHOD(ZipArchive, clearError)\n{\n\tzval *self = ZEND_THIS;\n\tze_zip_object *ze_obj;\n\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\tRETURN_THROWS();\n\t}\n\n\tze_obj = Z_ZIP_P(self); /* not ZIP_FROM_OBJECT as we can use saved error after close */\n\tif (ze_obj->za) {\n\t\tzip_error_clear(ze_obj->za);\n\t} else {\n\t\tze_obj->err_zip = 0;\n\t\tze_obj->err_sys = 0;\n\t}\n}\n/* }}} */\n\n/* {{{ Returns the status error message, system and/or zip messages */\nPHP_METHOD(ZipArchive, getStatusString)\n{\n\tzval *self = ZEND_THIS;\n#if LIBZIP_VERSION_MAJOR < 1\n\tint zep, syp, len;\n\tchar error_string[128];\n#endif\n\tze_zip_object *ze_obj;\n\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\tRETURN_THROWS();\n\t}\n\n\tze_obj = Z_ZIP_P(self); /* not ZIP_FROM_OBJECT as we can use saved error after close */\n\n#if LIBZIP_VERSION_MAJOR < 1\n\tif (ze_obj->za) {\n\t\tzip_error_get(ze_obj->za, &zep, &syp);\n\t\tlen = zip_error_to_str(error_string, 128, zep, syp);\n\t} else {\n\t\tlen = zip_error_to_str(error_string, 128, ze_obj->err_zip, ze_obj->err_sys);\n\t}\n\tRETVAL_STRINGL(error_string, len);\n#else\n\tif (ze_obj->za) {\n\t\tzip_error_t *err;\n\n\t\terr = zip_get_error(ze_obj->za);\n\t\tRETVAL_STRING(zip_error_strerror(err));\n\t\tzip_error_fini(err);\n\t} else {\n\t\tzip_error_t err;\n\n\t\tzip_error_init(&err);\n\t\tzip_error_set(&err, ze_obj->err_zip, ze_obj->err_sys);\n\t\tRETVAL_STRING(zip_error_strerror(&err));\n\t\tzip_error_fini(&err);\n\t}\n#endif\n}\n/* }}} */\n\n/* {{{ Returns the index of the entry named filename in the archive */\nPHP_METHOD(ZipArchive, addEmptyDir)\n{\n\tstruct zip *intern;\n\tzval *self = ZEND_THIS;\n\tchar *dirname;\n\tsize_t   dirname_len;\n\tchar *s;\n\tzend_long flags = 0;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"s|l\",\n\t\t\t\t&dirname, &dirname_len, &flags) == FAILURE) {\n\t\tRETURN_THROWS();\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tif (dirname_len<1) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (dirname[dirname_len-1] != '/') {\n\t\ts=(char *)safe_emalloc(dirname_len, 1, 2);\n\t\tstrcpy(s, dirname);\n\t\ts[dirname_len] = '/';\n\t\ts[dirname_len+1] = '\\0';\n\t} else {\n\t\ts = dirname;\n\t}\n\n\tif ((Z_ZIP_P(self)->last_id = zip_dir_add(intern, (const char *)s, flags)) == -1) {\n\t\tRETVAL_FALSE;\n\t} else {\n\t\tzip_error_clear(intern);\n\t\tRETVAL_TRUE;\n\t}\n\n\tif (s != dirname) {\n\t\tefree(s);\n\t}\n}\n/* }}} */\n\nstatic void php_zip_add_from_pattern(INTERNAL_FUNCTION_PARAMETERS, int type) /* {{{ */\n{\n\tzval *self = ZEND_THIS;\n\tchar *path = \".\";\n\tsize_t  path_len = 1;\n\tzend_long glob_flags = 0;\n\tHashTable *options = NULL;\n\tzip_options opts = {0};\n\tint found;\n\tzend_string *pattern;\n\n\t/* 1 == glob, 2 == pcre */\n\tif (type == 1) {\n\t\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"P|lh\",\n\t\t\t\t\t&pattern, &glob_flags, &options) == FAILURE) {\n\t\t\tRETURN_THROWS();\n\t\t}\n\t} else {\n\t\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"P|sh\",\n\t\t\t\t\t&pattern, &path, &path_len, &options) == FAILURE) {\n\t\t\tRETURN_THROWS();\n\t\t}\n\t}\n\n\tif (ZSTR_LEN(pattern) == 0) {\n\t\tzend_argument_must_not_be_empty_error(1);\n\t\tRETURN_THROWS();\n\t}\n\tif (options && zend_hash_num_elements(options) > 0 && (php_zip_parse_options(options, &opts) < 0)) {\n\t\tRETURN_THROWS();\n\t}\n\n\tif (type == 1) {\n\t\tfound = php_zip_glob(ZSTR_VAL(pattern), ZSTR_LEN(pattern), glob_flags, return_value);\n\t} else {\n\t\tfound = php_zip_pcre(pattern, path, path_len, return_value);\n\t}\n\n\tif (found > 0) {\n\t\tint i;\n\t\tzval *zval_file;\n\t\tze_zip_object *ze_obj;\n\n\t\tze_obj = Z_ZIP_P(self);\n\n\t\tfor (i = 0; i < found; i++) {\n\t\t\tchar *file_stripped, *entry_name;\n\t\t\tsize_t entry_name_len, file_stripped_len;\n\t\t\tchar entry_name_buf[MAXPATHLEN];\n\t\t\tzend_string *basename = NULL;\n\n\t\t\tif ((zval_file = zend_hash_index_find(Z_ARRVAL_P(return_value), i)) != NULL) {\n\t\t\t\tif (opts.remove_all_path) {\n\t\t\t\t\tbasename = php_basename(Z_STRVAL_P(zval_file), Z_STRLEN_P(zval_file), NULL, 0);\n\t\t\t\t\tfile_stripped = ZSTR_VAL(basename);\n\t\t\t\t\tfile_stripped_len = ZSTR_LEN(basename);\n\t\t\t\t} else if (opts.remove_path && Z_STRLEN_P(zval_file) > opts.remove_path_len && !memcmp(Z_STRVAL_P(zval_file), opts.remove_path, opts.remove_path_len)) {\n\t\t\t\t\tif (IS_SLASH(Z_STRVAL_P(zval_file)[opts.remove_path_len])) {\n\t\t\t\t\t\tfile_stripped = Z_STRVAL_P(zval_file) + opts.remove_path_len + 1;\n\t\t\t\t\t\tfile_stripped_len = Z_STRLEN_P(zval_file) - opts.remove_path_len - 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfile_stripped = Z_STRVAL_P(zval_file) + opts.remove_path_len;\n\t\t\t\t\t\tfile_stripped_len = Z_STRLEN_P(zval_file) - opts.remove_path_len;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfile_stripped = Z_STRVAL_P(zval_file);\n\t\t\t\t\tfile_stripped_len = Z_STRLEN_P(zval_file);\n\t\t\t\t}\n\n\t\t\t\tif (opts.add_path) {\n\t\t\t\t\tif ((opts.add_path_len + file_stripped_len) > MAXPATHLEN) {\n\t\t\t\t\t\tif (basename) {\n\t\t\t\t\t\t\tzend_string_release_ex(basename, 0);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tphp_error_docref(NULL, E_WARNING, \"Entry name too long (max: %d, %zd given)\",\n\t\t\t\t\t\tMAXPATHLEN - 1, (opts.add_path_len + file_stripped_len));\n\t\t\t\t\t\tzend_array_destroy(Z_ARR_P(return_value));\n\t\t\t\t\t\tRETURN_FALSE;\n\t\t\t\t\t}\n\t\t\t\t\tsnprintf(entry_name_buf, MAXPATHLEN, \"%s%s\", opts.add_path, file_stripped);\n\t\t\t\t} else {\n\t\t\t\t\tsnprintf(entry_name_buf, MAXPATHLEN, \"%s\", file_stripped);\n\t\t\t\t}\n\n\t\t\t\tentry_name = entry_name_buf;\n\t\t\t\tentry_name_len = strlen(entry_name);\n\t\t\t\tif (basename) {\n\t\t\t\t\tzend_string_release_ex(basename, 0);\n\t\t\t\t\tbasename = NULL;\n\t\t\t\t}\n\n\t\t\t\tif (php_zip_add_file(ze_obj, Z_STRVAL_P(zval_file), Z_STRLEN_P(zval_file),\n\t\t\t\t\tentry_name, entry_name_len, 0, 0, -1, opts.flags) < 0) {\n\t\t\t\t\tzend_array_destroy(Z_ARR_P(return_value));\n\t\t\t\t\tRETURN_FALSE;\n\t\t\t\t}\n\t\t\t\tif (opts.comp_method >= 0) {\n\t\t\t\t\tif (zip_set_file_compression(ze_obj->za, ze_obj->last_id, opts.comp_method, opts.comp_flags)) {\n\t\t\t\t\t\tzend_array_destroy(Z_ARR_P(return_value));\n\t\t\t\t\t\tRETURN_FALSE;\n\t\t\t\t\t}\n\t\t\t\t}\n#ifdef HAVE_ENCRYPTION\n\t\t\t\tif (opts.enc_method >= 0) {\n\t\t\t\t\tif (zip_file_set_encryption(ze_obj->za, ze_obj->last_id, opts.enc_method, opts.enc_password)) {\n\t\t\t\t\t\tzend_array_destroy(Z_ARR_P(return_value));\n\t\t\t\t\t\tRETURN_FALSE;\n\t\t\t\t\t}\n\t\t\t\t}\n#endif\n\t\t\t}\n\t\t}\n\t} else if (found == 0) {\n\t\tRETURN_EMPTY_ARRAY();\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n}\n/* }}} */\n\n/* {{{ Add files matching the glob pattern. See php's glob for the pattern syntax. */\nPHP_METHOD(ZipArchive, addGlob)\n{\n\tphp_zip_add_from_pattern(INTERNAL_FUNCTION_PARAM_PASSTHRU, 1);\n}\n/* }}} */\n\n/* {{{ Add files matching the pcre pattern. See php's pcre for the pattern syntax. */\nPHP_METHOD(ZipArchive, addPattern)\n{\n\tphp_zip_add_from_pattern(INTERNAL_FUNCTION_PARAM_PASSTHRU, 2);\n}\n/* }}} */\n\n/* {{{ Add a file in a Zip archive using its path and the name to use. */\nPHP_METHOD(ZipArchive, addFile)\n{\n\tzval *self = ZEND_THIS;\n\tchar *entry_name = NULL;\n\tsize_t entry_name_len = 0;\n\tzend_long offset_start = 0, offset_len = 0;\n\tzend_string *filename;\n\tzend_long flags = ZIP_FL_OVERWRITE;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"P|slll\",\n\t\t\t&filename, &entry_name, &entry_name_len, &offset_start, &offset_len, &flags) == FAILURE) {\n\t\tRETURN_THROWS();\n\t}\n\n\tif (ZSTR_LEN(filename) == 0) {\n\t\tzend_argument_must_not_be_empty_error(1);\n\t\tRETURN_THROWS();\n\t}\n\n\tif (entry_name_len == 0) {\n\t\tentry_name = ZSTR_VAL(filename);\n\t\tentry_name_len = ZSTR_LEN(filename);\n\t}\n\n\tif (php_zip_add_file(Z_ZIP_P(self), ZSTR_VAL(filename), ZSTR_LEN(filename),\n\t\t\tentry_name, entry_name_len, offset_start, offset_len, -1, flags) < 0) {\n\t\tRETURN_FALSE;\n\t} else {\n\t\tRETURN_TRUE;\n\t}\n}\n/* }}} */\n\n/* {{{ Add a file in a Zip archive using its path and the name to use. */\nPHP_METHOD(ZipArchive, replaceFile)\n{\n\tzval *self = ZEND_THIS;\n\tzend_long index;\n\tzend_long offset_start = 0, offset_len = 0;\n\tzend_string *filename;\n\tzend_long flags = 0;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"Pl|lll\",\n\t\t\t&filename, &index, &offset_start, &offset_len, &flags) == FAILURE) {\n\t\tRETURN_THROWS();\n\t}\n\n\tif (ZSTR_LEN(filename) == 0) {\n\t\tzend_argument_must_not_be_empty_error(1);\n\t\tRETURN_THROWS();\n\t}\n\n\tif (index < 0) {\n\t\tzend_argument_value_error(2, \"must be greater than or equal to 0\");\n\t\tRETURN_THROWS();\n\t}\n\n\tif (php_zip_add_file(Z_ZIP_P(self), ZSTR_VAL(filename), ZSTR_LEN(filename),\n\t\t\tNULL, 0, offset_start, offset_len, index, flags) < 0) {\n\t\tRETURN_FALSE;\n\t} else {\n\t\tRETURN_TRUE;\n\t}\n}\n/* }}} */\n\n/* {{{ Add a file using content and the entry name */\nPHP_METHOD(ZipArchive, addFromString)\n{\n\tstruct zip *intern;\n\tzval *self = ZEND_THIS;\n\tzend_string *buffer;\n\tchar *name;\n\tsize_t name_len;\n\tze_zip_object *ze_obj;\n\tstruct zip_source *zs;\n\tint pos = 0;\n\tzend_long flags = ZIP_FL_OVERWRITE;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"sS|l\",\n\t\t\t&name, &name_len, &buffer, &flags) == FAILURE) {\n\t\tRETURN_THROWS();\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tze_obj = Z_ZIP_P(self);\n\tif (ze_obj->buffers_cnt) {\n\t\tze_obj->buffers = (char **)safe_erealloc(ze_obj->buffers, sizeof(char *), (ze_obj->buffers_cnt+1), 0);\n\t\tpos = ze_obj->buffers_cnt++;\n\t} else {\n\t\tze_obj->buffers = (char **)emalloc(sizeof(char *));\n\t\tze_obj->buffers_cnt++;\n\t\tpos = 0;\n\t}\n\tze_obj->buffers[pos] = (char *)safe_emalloc(ZSTR_LEN(buffer), 1, 1);\n\tmemcpy(ze_obj->buffers[pos], ZSTR_VAL(buffer), ZSTR_LEN(buffer) + 1);\n\n\tzs = zip_source_buffer(intern, ze_obj->buffers[pos], ZSTR_LEN(buffer), 0);\n\n\tif (zs == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\n\tze_obj->last_id = zip_file_add(intern, name, zs, flags);\n\tif (ze_obj->last_id == -1) {\n\t\tzip_source_free(zs);\n\t\tRETURN_FALSE;\n\t} else {\n\t\tzip_error_clear(intern);\n\t\tRETURN_TRUE;\n\t}\n}\n/* }}} */\n\n/* {{{ Returns the information about a the zip entry filename */\nPHP_METHOD(ZipArchive, statName)\n{\n\tstruct zip *intern;\n\tzval *self = ZEND_THIS;\n\tzend_long flags = 0;\n\tstruct zip_stat sb;\n\tzend_string *name;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"P|l\", &name, &flags) == FAILURE) {\n\t\tRETURN_THROWS();\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tPHP_ZIP_STAT_PATH(intern, ZSTR_VAL(name), ZSTR_LEN(name), flags, sb);\n\n\tRETURN_SB(&sb);\n}\n/* }}} */\n\n/* {{{ Returns the zip entry information using its index */\nPHP_METHOD(ZipArchive, statIndex)\n{\n\tstruct zip *intern;\n\tzval *self = ZEND_THIS;\n\tzend_long index, flags = 0;\n\n\tstruct zip_stat sb;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"l|l\",\n\t\t\t&index, &flags) == FAILURE) {\n\t\tRETURN_THROWS();\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tif (zip_stat_index(intern, index, flags, &sb) != 0) {\n\t\tRETURN_FALSE;\n\t}\n\tRETURN_SB(&sb);\n}\n/* }}} */\n\n/* {{{ Returns the index of the entry named filename in the archive */\nPHP_METHOD(ZipArchive, locateName)\n{\n\tstruct zip *intern;\n\tzval *self = ZEND_THIS;\n\tzend_long flags = 0;\n\tzend_long idx = -1;\n\tzend_string *name;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"P|l\", &name, &flags) == FAILURE) {\n\t\tRETURN_THROWS();\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tif (ZSTR_LEN(name) < 1) {\n\t\tRETURN_FALSE;\n\t}\n\n\tidx = (zend_long)zip_name_locate(intern, (const char *)ZSTR_VAL(name), flags);\n\n\tif (idx >= 0) {\n\t\tRETURN_LONG(idx);\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n}\n/* }}} */\n\n/* {{{ Returns the name of the file at position index */\nPHP_METHOD(ZipArchive, getNameIndex)\n{\n\tstruct zip *intern;\n\tzval *self = ZEND_THIS;\n\tconst char *name;\n\tzend_long flags = 0, index = 0;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"l|l\",\n\t\t\t&index, &flags) == FAILURE) {\n\t\tRETURN_THROWS();\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tname = zip_get_name(intern, (int) index, flags);\n\n\tif (name) {\n\t\tRETVAL_STRING((char *)name);\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n}\n/* }}} */\n\n/* {{{ Set or remove (NULL/'') the comment of the archive */\nPHP_METHOD(ZipArchive, setArchiveComment)\n{\n\tstruct zip *intern;\n\tzval *self = ZEND_THIS;\n\tsize_t comment_len;\n\tchar * comment;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"s\", &comment, &comment_len) == FAILURE) {\n\t\tRETURN_THROWS();\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tif (comment_len > 0xffff) {\n\t\tzend_argument_value_error(1, \"must be less than 65535 bytes\");\n\t\tRETURN_THROWS();\n\t}\n\n\tif (zip_set_archive_comment(intern, (const char *)comment, comment_len)) {\n\t\tRETURN_FALSE;\n\t} else {\n\t\tRETURN_TRUE;\n\t}\n}\n/* }}} */\n\n/* {{{ Returns the comment of an entry using its index */\nPHP_METHOD(ZipArchive, getArchiveComment)\n{\n\tstruct zip *intern;\n\tzval *self = ZEND_THIS;\n\tzend_long flags = 0;\n\tconst char * comment;\n\tint comment_len = 0;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"|l\", &flags) == FAILURE) {\n\t\tRETURN_THROWS();\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tcomment = zip_get_archive_comment(intern, &comment_len, (int)flags);\n\tif(comment==NULL) {\n\t\tRETURN_FALSE;\n\t}\n\tRETURN_STRINGL((char *)comment, (zend_long)comment_len);\n}\n/* }}} */\n\nPHP_METHOD(ZipArchive, setArchiveFlag)\n{\n\tstruct zip *intern;\n\tzval *self = ZEND_THIS;\n\tzend_long flag, value;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"ll\", &flag, &value) == FAILURE) {\n\t\tRETURN_THROWS();\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tif (zip_set_archive_flag(intern, flag, (int)value)) {\n\t\tRETURN_FALSE;\n\t} else {\n\t\tRETURN_TRUE;\n\t}\n}\n\nPHP_METHOD(ZipArchive, getArchiveFlag)\n{\n\tstruct zip *intern;\n\tzval *self = ZEND_THIS;\n\tzend_long flag, flags = 0;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"l|l\", &flag, &flags) == FAILURE) {\n\t\tRETURN_THROWS();\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tRETURN_LONG(zip_get_archive_flag(intern, flag, flags));\n}\n\n/* {{{ Set or remove (NULL/'') the comment of an entry using its Name */\nPHP_METHOD(ZipArchive, setCommentName)\n{\n\tstruct zip *intern;\n\tzval *self = ZEND_THIS;\n\tsize_t comment_len, name_len;\n\tchar * comment, *name;\n\tint idx;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"ss\",\n\t\t\t&name, &name_len, &comment, &comment_len) == FAILURE) {\n\t\tRETURN_THROWS();\n\t}\n\n\tif (name_len == 0) {\n\t\tzend_argument_must_not_be_empty_error(1);\n\t\tRETURN_THROWS();\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tif (comment_len > 0xffff) {\n\t\tzend_argument_value_error(2, \"must be less than 65535 bytes\");\n\t\tRETURN_THROWS();\n\t}\n\n\tidx = zip_name_locate(intern, name, 0);\n\tif (idx < 0) {\n\t\tRETURN_FALSE;\n\t}\n\tPHP_ZIP_SET_FILE_COMMENT(intern, idx, comment, comment_len);\n}\n/* }}} */\n\n/* {{{ Set or remove (NULL/'') the comment of an entry using its index */\nPHP_METHOD(ZipArchive, setCommentIndex)\n{\n\tstruct zip *intern;\n\tzval *self = ZEND_THIS;\n\tzend_long index;\n\tsize_t comment_len;\n\tchar * comment;\n\tstruct zip_stat sb;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"ls\",\n\t\t\t&index, &comment, &comment_len) == FAILURE) {\n\t\tRETURN_THROWS();\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tif (comment_len > 0xffff) {\n\t\tzend_argument_value_error(2, \"must be less than 65535 bytes\");\n\t\tRETURN_THROWS();\n\t}\n\n\tPHP_ZIP_STAT_INDEX(intern, index, 0, sb);\n\tPHP_ZIP_SET_FILE_COMMENT(intern, index, comment, comment_len);\n}\n/* }}} */\n\n/* those constants/functions are only available in libzip since 0.11.2 */\n#ifdef ZIP_OPSYS_DEFAULT\n\n/* {{{ Set external attributes for file in zip, using its name */\nPHP_METHOD(ZipArchive, setExternalAttributesName)\n{\n\tstruct zip *intern;\n\tzval *self = ZEND_THIS;\n\tsize_t name_len;\n\tchar *name;\n\tzend_long flags=0, opsys, attr;\n\tzip_int64_t idx;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"sll|l\",\n\t\t\t&name, &name_len, &opsys, &attr, &flags) == FAILURE) {\n\t\tRETURN_THROWS();\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tif (name_len == 0) {\n\t\tzend_argument_must_not_be_empty_error(1);\n\t\tRETURN_THROWS();\n\t}\n\n\tidx = zip_name_locate(intern, name, 0);\n\n\tif (idx < 0) {\n\t\tRETURN_FALSE;\n\t}\n\tif (zip_file_set_external_attributes(intern, idx, (zip_flags_t)flags,\n\t\t\t(zip_uint8_t)(opsys&0xff), (zip_uint32_t)attr) < 0) {\n\t\tRETURN_FALSE;\n\t}\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ Set external attributes for file in zip, using its index */\nPHP_METHOD(ZipArchive, setExternalAttributesIndex)\n{\n\tstruct zip *intern;\n\tzval *self = ZEND_THIS;\n\tzend_long index, flags=0, opsys, attr;\n\tstruct zip_stat sb;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"lll|l\",\n\t\t\t&index, &opsys, &attr, &flags) == FAILURE) {\n\t\tRETURN_THROWS();\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tPHP_ZIP_STAT_INDEX(intern, index, 0, sb);\n\tif (zip_file_set_external_attributes(intern, (zip_uint64_t)index,\n\t\t\t(zip_flags_t)flags, (zip_uint8_t)(opsys&0xff), (zip_uint32_t)attr) < 0) {\n\t\tRETURN_FALSE;\n\t}\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ Get external attributes for file in zip, using its name */\nPHP_METHOD(ZipArchive, getExternalAttributesName)\n{\n\tstruct zip *intern;\n\tzval *self = ZEND_THIS, *z_opsys, *z_attr;\n\tsize_t name_len;\n\tchar *name;\n\tzend_long flags=0;\n\tzip_uint8_t opsys;\n\tzip_uint32_t attr;\n\tzip_int64_t idx;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"szz|l\",\n\t\t\t&name, &name_len, &z_opsys, &z_attr, &flags) == FAILURE) {\n\t\tRETURN_THROWS();\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tif (name_len == 0) {\n\t\tzend_argument_must_not_be_empty_error(1);\n\t\tRETURN_THROWS();\n\t}\n\n\tidx = zip_name_locate(intern, name, 0);\n\n\tif (idx < 0) {\n\t\tRETURN_FALSE;\n\t}\n\tif (zip_file_get_external_attributes(intern, idx,\n\t\t\t(zip_flags_t)flags, &opsys, &attr) < 0) {\n\t\tRETURN_FALSE;\n\t}\n\tZEND_TRY_ASSIGN_REF_LONG(z_opsys, opsys);\n\tZEND_TRY_ASSIGN_REF_LONG(z_attr, attr);\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ Get external attributes for file in zip, using its index */\nPHP_METHOD(ZipArchive, getExternalAttributesIndex)\n{\n\tstruct zip *intern;\n\tzval *self = ZEND_THIS, *z_opsys, *z_attr;\n\tzend_long index, flags=0;\n\tzip_uint8_t opsys;\n\tzip_uint32_t attr;\n\tstruct zip_stat sb;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"lzz|l\",\n\t\t\t&index, &z_opsys, &z_attr, &flags) == FAILURE) {\n\t\tRETURN_THROWS();\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tPHP_ZIP_STAT_INDEX(intern, index, 0, sb);\n\tif (zip_file_get_external_attributes(intern, (zip_uint64_t)index,\n\t\t\t(zip_flags_t)flags, &opsys, &attr) < 0) {\n\t\tRETURN_FALSE;\n\t}\n\tZEND_TRY_ASSIGN_REF_LONG(z_opsys, opsys);\n\tZEND_TRY_ASSIGN_REF_LONG(z_attr, attr);\n\tRETURN_TRUE;\n}\n/* }}} */\n#endif /* ifdef ZIP_OPSYS_DEFAULT */\n\n#ifdef HAVE_ENCRYPTION\n/* {{{ Set encryption method for file in zip, using its name */\nPHP_METHOD(ZipArchive, setEncryptionName)\n{\n\tstruct zip *intern;\n\tzval *self = ZEND_THIS;\n\tzend_long method;\n\tzip_int64_t idx;\n\tchar *name, *password = NULL;\n\tsize_t name_len, password_len;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"sl|s!\",\n\t\t\t&name, &name_len, &method, &password, &password_len) == FAILURE) {\n\t\tRETURN_THROWS();\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tif (name_len == 0) {\n\t\tzend_argument_must_not_be_empty_error(1);\n\t\tRETURN_THROWS();\n\t}\n\n\tidx = zip_name_locate(intern, name, 0);\n\n\tif (idx < 0) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (UNEXPECTED(zip_file_set_encryption(intern, idx, ZIP_EM_NONE, NULL) < 0)) {\n\t\tphp_error_docref(NULL, E_WARNING, \"password reset failed\");\n\t\tRETURN_FALSE;\n\t}\n\n\tif (zip_file_set_encryption(intern, idx, (zip_uint16_t)method, password)) {\n\t\tRETURN_FALSE;\n\t}\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ Set encryption method for file in zip, using its index */\nPHP_METHOD(ZipArchive, setEncryptionIndex)\n{\n\tstruct zip *intern;\n\tzval *self = ZEND_THIS;\n\tzend_long index, method;\n\tchar *password = NULL;\n\tsize_t password_len;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"ll|s!\",\n\t\t\t&index, &method, &password, &password_len) == FAILURE) {\n\t\tRETURN_THROWS();\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tif (UNEXPECTED(zip_file_set_encryption(intern, index, ZIP_EM_NONE, NULL) < 0)) {\n\t\tphp_error_docref(NULL, E_WARNING, \"password reset failed\");\n\t\tRETURN_FALSE;\n\t}\n\n\tif (zip_file_set_encryption(intern, index, (zip_uint16_t)method, password)) {\n\t\tRETURN_FALSE;\n\t}\n\tRETURN_TRUE;\n}\n/* }}} */\n#endif\n\n/* {{{ Returns the comment of an entry using its name */\nPHP_METHOD(ZipArchive, getCommentName)\n{\n\tstruct zip *intern;\n\tzval *self = ZEND_THIS;\n\tsize_t name_len;\n\tint idx;\n\tzend_long flags = 0;\n\tzip_uint32_t comment_len = 0;\n\tconst char * comment;\n\tchar *name;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"s|l\",\n\t\t\t&name, &name_len, &flags) == FAILURE) {\n\t\tRETURN_THROWS();\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tif (name_len == 0) {\n\t\tzend_argument_must_not_be_empty_error(1);\n\t\tRETURN_THROWS();\n\t}\n\n\tidx = zip_name_locate(intern, name, 0);\n\n\tif (idx < 0) {\n\t\tRETURN_FALSE;\n\t}\n\n\tcomment = zip_file_get_comment(intern, idx, &comment_len, (zip_flags_t)flags);\n\tRETURN_STRINGL((char *)comment, comment_len);\n}\n/* }}} */\n\n/* {{{ Returns the comment of an entry using its index */\nPHP_METHOD(ZipArchive, getCommentIndex)\n{\n\tstruct zip *intern;\n\tzval *self = ZEND_THIS;\n\tzend_long index, flags = 0;\n\tconst char * comment;\n\tzip_uint32_t comment_len = 0;\n\tstruct zip_stat sb;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"l|l\",\n\t\t\t\t&index, &flags) == FAILURE) {\n\t\tRETURN_THROWS();\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tPHP_ZIP_STAT_INDEX(intern, index, 0, sb);\n\tcomment = zip_file_get_comment(intern, index, &comment_len, (zip_flags_t)flags);\n\tRETURN_STRINGL((char *)comment, comment_len);\n}\n/* }}} */\n\n/* {{{ Set the compression of a file in zip, using its name */\nPHP_METHOD(ZipArchive, setCompressionName)\n{\n\tstruct zip *intern;\n\tzval *this = ZEND_THIS;\n\tsize_t name_len;\n\tchar *name;\n\tzip_int64_t idx;\n\tzend_long comp_method, comp_flags = 0;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"sl|l\",\n\t\t\t&name, &name_len, &comp_method, &comp_flags) == FAILURE) {\n\t\tRETURN_THROWS();\n\t}\n\n\tZIP_FROM_OBJECT(intern, this);\n\n\tif (name_len == 0) {\n\t\tzend_argument_must_not_be_empty_error(1);\n\t\tRETURN_THROWS();\n\t}\n\n\tidx = zip_name_locate(intern, name, 0);\n\n\tif (idx < 0) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (zip_set_file_compression(intern, (zip_uint64_t)idx,\n\t\t\t(zip_int32_t)comp_method, (zip_uint32_t)comp_flags) != 0) {\n\t\tRETURN_FALSE;\n\t}\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ Set the compression of a file in zip, using its index */\nPHP_METHOD(ZipArchive, setCompressionIndex)\n{\n\tstruct zip *intern;\n\tzval *this = ZEND_THIS;\n\tzend_long index;\n\tzend_long comp_method, comp_flags = 0;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"ll|l\",\n\t\t\t&index, &comp_method, &comp_flags) == FAILURE) {\n\t\tRETURN_THROWS();\n\t}\n\n\tZIP_FROM_OBJECT(intern, this);\n\n\tif (zip_set_file_compression(intern, (zip_uint64_t)index,\n\t\t\t(zip_int32_t)comp_method, (zip_uint32_t)comp_flags) != 0) {\n\t\tRETURN_FALSE;\n\t}\n\tRETURN_TRUE;\n}\n/* }}} */\n\n#ifdef HAVE_SET_MTIME\n/* {{{ Set the modification time of a file in zip, using its name */\nPHP_METHOD(ZipArchive, setMtimeName)\n{\n\tstruct zip *intern;\n\tzval *this = ZEND_THIS;\n\tsize_t name_len;\n\tchar *name;\n\tzip_int64_t idx;\n\tzend_long mtime, flags = 0;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"sl|l\",\n\t\t\t&name, &name_len, &mtime,  &flags) == FAILURE) {\n\t\tRETURN_THROWS();\n\t}\n\n\tZIP_FROM_OBJECT(intern, this);\n\n\tif (name_len == 0) {\n\t\tzend_argument_must_not_be_empty_error(1);\n\t\tRETURN_THROWS();\n\t}\n\n\tidx = zip_name_locate(intern, name, 0);\n\n\tif (idx < 0) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (zip_file_set_mtime(intern, (zip_uint64_t)idx,\n\t\t\t(time_t)mtime, (zip_uint32_t)flags) != 0) {\n\t\tRETURN_FALSE;\n\t}\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ Set the modification time of a file in zip, using its index */\nPHP_METHOD(ZipArchive, setMtimeIndex)\n{\n\tstruct zip *intern;\n\tzval *this = ZEND_THIS;\n\tzend_long index;\n\tzend_long mtime, flags = 0;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"ll|l\",\n\t\t\t&index, &mtime, &flags) == FAILURE) {\n\t\tRETURN_THROWS();\n\t}\n\n\tZIP_FROM_OBJECT(intern, this);\n\n\tif (zip_file_set_mtime(intern, (zip_uint64_t)index,\n\t\t\t(time_t)mtime, (zip_uint32_t)flags) != 0) {\n\t\tRETURN_FALSE;\n\t}\n\tRETURN_TRUE;\n}\n/* }}} */\n#endif\n\n/* {{{ Delete a file using its index */\nPHP_METHOD(ZipArchive, deleteIndex)\n{\n\tstruct zip *intern;\n\tzval *self = ZEND_THIS;\n\tzend_long index;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"l\", &index) == FAILURE) {\n\t\tRETURN_THROWS();\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tif (index < 0) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (zip_delete(intern, index) < 0) {\n\t\tRETURN_FALSE;\n\t}\n\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ Delete a file using its index */\nPHP_METHOD(ZipArchive, deleteName)\n{\n\tstruct zip *intern;\n\tzval *self = ZEND_THIS;\n\tsize_t name_len;\n\tchar *name;\n\tstruct zip_stat sb;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"s\", &name, &name_len) == FAILURE) {\n\t\tRETURN_THROWS();\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tif (name_len < 1) {\n\t\tRETURN_FALSE;\n\t}\n\n\tPHP_ZIP_STAT_PATH(intern, name, name_len, 0, sb);\n\tif (zip_delete(intern, sb.index)) {\n\t\tRETURN_FALSE;\n\t}\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ Rename an entry selected by its index to new_name */\nPHP_METHOD(ZipArchive, renameIndex)\n{\n\tstruct zip *intern;\n\tzval *self = ZEND_THIS;\n\tchar *new_name;\n\tsize_t new_name_len;\n\tzend_long index;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"ls\", &index, &new_name, &new_name_len) == FAILURE) {\n\t\tRETURN_THROWS();\n\t}\n\n\tif (index < 0) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tif (new_name_len == 0) {\n\t\tzend_argument_must_not_be_empty_error(2);\n\t\tRETURN_THROWS();\n\t}\n\n\tif (zip_file_rename(intern, index, (const char *)new_name, 0) != 0) {\n\t\tRETURN_FALSE;\n\t}\n\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ Rename an entry selected by its name to new_name */\nPHP_METHOD(ZipArchive, renameName)\n{\n\tstruct zip *intern;\n\tzval *self = ZEND_THIS;\n\tstruct zip_stat sb;\n\tchar *name, *new_name;\n\tsize_t name_len, new_name_len;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"ss\", &name, &name_len, &new_name, &new_name_len) == FAILURE) {\n\t\tRETURN_THROWS();\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tif (new_name_len == 0) {\n\t\tzend_argument_must_not_be_empty_error(2);\n\t\tRETURN_THROWS();\n\t}\n\n\tPHP_ZIP_STAT_PATH(intern, name, name_len, 0, sb);\n\n\tif (zip_file_rename(intern, sb.index, (const char *)new_name, 0)) {\n\t\tRETURN_FALSE;\n\t}\n\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ Changes to the file at position index are reverted */\nPHP_METHOD(ZipArchive, unchangeIndex)\n{\n\tstruct zip *intern;\n\tzval *self = ZEND_THIS;\n\tzend_long index;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"l\", &index) == FAILURE) {\n\t\tRETURN_THROWS();\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tif (index < 0) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (zip_unchange(intern, index) != 0) {\n\t\tRETURN_FALSE;\n\t} else {\n\t\tRETURN_TRUE;\n\t}\n}\n/* }}} */\n\n/* {{{ Changes to the file named 'name' are reverted */\nPHP_METHOD(ZipArchive, unchangeName)\n{\n\tstruct zip *intern;\n\tzval *self = ZEND_THIS;\n\tstruct zip_stat sb;\n\tchar *name;\n\tsize_t name_len;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"s\", &name, &name_len) == FAILURE) {\n\t\tRETURN_THROWS();\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tif (name_len < 1) {\n\t\tRETURN_FALSE;\n\t}\n\n\tPHP_ZIP_STAT_PATH(intern, name, name_len, 0, sb);\n\n\tif (zip_unchange(intern, sb.index) != 0) {\n\t\tRETURN_FALSE;\n\t} else {\n\t\tRETURN_TRUE;\n\t}\n}\n/* }}} */\n\n/* {{{ All changes to files and global information in archive are reverted */\nPHP_METHOD(ZipArchive, unchangeAll)\n{\n\tstruct zip *intern;\n\tzval *self = ZEND_THIS;\n\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\tRETURN_THROWS();\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tif (zip_unchange_all(intern) != 0) {\n\t\tRETURN_FALSE;\n\t} else {\n\t\tRETURN_TRUE;\n\t}\n}\n/* }}} */\n\n/* {{{ Revert all global changes to the archive archive.  For now, this only reverts archive comment changes. */\nPHP_METHOD(ZipArchive, unchangeArchive)\n{\n\tstruct zip *intern;\n\tzval *self = ZEND_THIS;\n\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\tRETURN_THROWS();\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tif (zip_unchange_archive(intern) != 0) {\n\t\tRETURN_FALSE;\n\t} else {\n\t\tRETURN_TRUE;\n\t}\n}\n/* }}} */\n\n/* {{{ Extract one or more file from a zip archive */\n/* TODO:\n * - allow index or array of indices\n * - replace path\n * - patterns\n */\nPHP_METHOD(ZipArchive, extractTo)\n{\n\tstruct zip *intern;\n\n\tzval *self = ZEND_THIS;\n\tzend_string *files_str = NULL;\n\tHashTable *files_ht = NULL;\n\n\tphp_stream_statbuf ssb;\n\tchar *pathto;\n\tsize_t pathto_len;\n\tint ret;\n\n\tZEND_PARSE_PARAMETERS_START(1, 2)\n\t\tZ_PARAM_PATH(pathto, pathto_len)\n\t\tZ_PARAM_OPTIONAL\n\t\tZ_PARAM_ARRAY_HT_OR_STR_OR_NULL(files_ht, files_str)\n\tZEND_PARSE_PARAMETERS_END();\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tif (pathto_len < 1) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (php_stream_stat_path_ex(pathto, PHP_STREAM_URL_STAT_QUIET, &ssb, NULL) < 0) {\n\t\tret = php_stream_mkdir(pathto, 0777, PHP_STREAM_MKDIR_RECURSIVE, NULL);\n\t\tif (!ret) {\n\t\t\tRETURN_FALSE;\n\t\t}\n\t}\n\n\tuint32_t nelems, i;\n\n\tif (files_str) {\n\t\tif (!php_zip_extract_file(intern, pathto, ZSTR_VAL(files_str), ZSTR_LEN(files_str), -1)) {\n\t\t\tRETURN_FALSE;\n\t\t}\n\t} else if (files_ht) {\n\t\tnelems = zend_hash_num_elements(files_ht);\n\t\tif (nelems == 0 ) {\n\t\t\tRETURN_FALSE;\n\t\t}\n\t\tfor (i = 0; i < nelems; i++) {\n\t\t\tzval *zval_file;\n\t\t\tif ((zval_file = zend_hash_index_find_deref(files_ht, i)) != NULL) {\n\t\t\t\tswitch (Z_TYPE_P(zval_file)) {\n\t\t\t\t\tcase IS_LONG:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase IS_STRING:\n\t\t\t\t\t\tif (!php_zip_extract_file(intern, pathto, Z_STRVAL_P(zval_file), Z_STRLEN_P(zval_file), -1)) {\n\t\t\t\t\t\t\tRETURN_FALSE;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\t/* Extract all files */\n\t\tzip_int64_t i, filecount = zip_get_num_entries(intern, 0);\n\n\t\tif (filecount == -1) {\n\t\t\t\tphp_error_docref(NULL, E_WARNING, \"Illegal archive\");\n\t\t\t\tRETURN_FALSE;\n\t\t}\n\n\t\tfor (i = 0; i < filecount; i++) {\n\t\t\tconst char *file = zip_get_name(intern, i, ZIP_FL_UNCHANGED);\n\t\t\tif (!file || !php_zip_extract_file(intern, pathto, file, strlen(file), i)) {\n\t\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\t\t}\n\t}\n\n\tRETURN_TRUE;\n}\n/* }}} */\n\nstatic void php_zip_get_from(INTERNAL_FUNCTION_PARAMETERS, int type) /* {{{ */\n{\n\tstruct zip *intern;\n\tzval *self = ZEND_THIS;\n\n\tstruct zip_stat sb;\n\tstruct zip_file *zf;\n\n\tzend_long index = -1;\n\tzend_long flags = 0;\n\tzend_long len = 0;\n\n\tzend_string *filename;\n\tzend_string *buffer;\n\n\tint n = 0;\n\n\tif (type == 1) {\n\t\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"P|ll\", &filename, &len, &flags) == FAILURE) {\n\t\t\tRETURN_THROWS();\n\t\t}\n\n\t\tZIP_FROM_OBJECT(intern, self);\n\n\t\tPHP_ZIP_STAT_PATH(intern, ZSTR_VAL(filename), ZSTR_LEN(filename), flags, sb);\n\t} else {\n\t\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"l|ll\", &index, &len, &flags) == FAILURE) {\n\t\t\tRETURN_THROWS();\n\t\t}\n\n\t\tZIP_FROM_OBJECT(intern, self);\n\n\t\tPHP_ZIP_STAT_INDEX(intern, index, 0, sb);\n\t}\n\n\tif (sb.size < 1) {\n\t\tRETURN_EMPTY_STRING();\n\t}\n\n\tif (len < 1) {\n\t\tlen = sb.size;\n\t}\n\tif (index >= 0) {\n\t\tzf = zip_fopen_index(intern, index, flags);\n\t} else {\n\t\tzf = zip_fopen(intern, ZSTR_VAL(filename), flags);\n\t}\n\n\tif (zf == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\n\tbuffer = zend_string_safe_alloc(1, len, 0, 0);\n\tn = zip_fread(zf, ZSTR_VAL(buffer), ZSTR_LEN(buffer));\n\tif (n < 1) {\n\t\tzend_string_efree(buffer);\n\t\tRETURN_EMPTY_STRING();\n\t}\n\n\tzip_fclose(zf);\n\tZSTR_VAL(buffer)[n] = '\\0';\n\tZSTR_LEN(buffer) = n;\n\tRETURN_NEW_STR(buffer);\n}\n/* }}} */\n\n/* {{{ get the contents of an entry using its name */\nPHP_METHOD(ZipArchive, getFromName)\n{\n\tphp_zip_get_from(INTERNAL_FUNCTION_PARAM_PASSTHRU, 1);\n}\n/* }}} */\n\n/* {{{ get the contents of an entry using its index */\nPHP_METHOD(ZipArchive, getFromIndex)\n{\n\tphp_zip_get_from(INTERNAL_FUNCTION_PARAM_PASSTHRU, 0);\n}\n/* }}} */\n\nstatic void php_zip_get_stream(INTERNAL_FUNCTION_PARAMETERS, int type, bool accept_flags) /* {{{ */\n{\n\tstruct zip *intern;\n\tzval *self = ZEND_THIS;\n\tzend_long index;\n\tzend_long flags = 0;\n\tstruct zip_stat sb;\n\tchar *mode = \"rb\";\n\tzend_string *filename;\n\tphp_stream *stream;\n\n\tif (type) {\n\t\tif (accept_flags) {\n\t\t\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"P|l\", &filename, &flags) == FAILURE) {\n\t\t\t\tRETURN_THROWS();\n\t\t\t}\n\t\t} else {\n\t\t\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"P\", &filename) == FAILURE) {\n\t\t\t\tRETURN_THROWS();\n\t\t\t}\n\t\t}\n\t} else {\n\t\tZEND_ASSERT(accept_flags);\n\t\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"l|l\", &index, &flags) == FAILURE) {\n\t\t\tRETURN_THROWS();\n\t\t}\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tif (type) {\n\t\tPHP_ZIP_STAT_PATH(intern, ZSTR_VAL(filename), ZSTR_LEN(filename), flags, sb);\n\t} else {\n\t\tPHP_ZIP_STAT_INDEX(intern, index, flags, sb);\n\t}\n\n\tstream = php_stream_zip_open(intern, &sb, mode, flags STREAMS_CC);\n\tif (stream) {\n\t\tphp_stream_to_zval(stream, return_value);\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n}\n\n/* {{{ get a stream for an entry using its name */\nPHP_METHOD(ZipArchive, getStreamName)\n{\n\tphp_zip_get_stream(INTERNAL_FUNCTION_PARAM_PASSTHRU, 1, /* accept_flags */ true);\n}\n/* }}} */\n\n/* {{{ get a stream for an entry using its index */\nPHP_METHOD(ZipArchive, getStreamIndex)\n{\n\tphp_zip_get_stream(INTERNAL_FUNCTION_PARAM_PASSTHRU, 0, /* accept_flags */ true);\n}\n/* }}} */\n\nPHP_METHOD(ZipArchive, getStream)\n{\n\tphp_zip_get_stream(INTERNAL_FUNCTION_PARAM_PASSTHRU, 1, /* accept_flags */ false);\n}\n\n#ifdef HAVE_PROGRESS_CALLBACK\nstatic void php_zip_progress_callback(zip_t *arch, double state, void *ptr)\n{\n\tzval cb_args[1];\n\tze_zip_object *obj = ptr;\n\n\tZVAL_DOUBLE(&cb_args[0], state);\n\tzend_call_known_fcc(&obj->progress_callback, NULL, 1, cb_args, NULL);\n}\n\n/* {{{ register a progression callback: void callback(double state); */\nPHP_METHOD(ZipArchive, registerProgressCallback)\n{\n\tstruct zip *intern;\n\tdouble rate;\n\tzend_fcall_info dummy_fci;\n\tzend_fcall_info_cache fcc;\n\tze_zip_object *obj;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"dF\", &rate, &dummy_fci, &fcc) == FAILURE) {\n\t\tRETURN_THROWS();\n\t}\n\n\t/* Inline ZIP_FROM_OBJECT(intern, self); */\n\tobj = Z_ZIP_P(ZEND_THIS);\n\tintern = obj->za;\n\tif (!intern) { \\\n\t\tzend_value_error(\"Invalid or uninitialized Zip object\");\n\t\tzend_release_fcall_info_cache(&fcc);\n\t\tRETURN_THROWS();\n\t}\n\n\t/* register */\n\tif (zip_register_progress_callback_with_state(intern, rate, php_zip_progress_callback, php_zip_progress_callback_free, obj)) {\n\t\tRETURN_FALSE;\n\t}\n\tzend_fcc_dup(&obj->progress_callback, &fcc);\n\n\tRETURN_TRUE;\n}\n/* }}} */\n#endif\n\n#ifdef HAVE_CANCEL_CALLBACK\nstatic int php_zip_cancel_callback(zip_t *arch, void *ptr)\n{\n\tzval cb_retval;\n\tze_zip_object *obj = ptr;\n\n\tzend_call_known_fcc(&obj->cancel_callback, &cb_retval, 0, NULL, NULL);\n\tif (Z_ISUNDEF(cb_retval)) {\n\t\t/* Cancel if an exception has been thrown */\n\t\treturn -1;\n\t}\n\tbool failed;\n\tzend_long retval = zval_try_get_long(&cb_retval, &failed);\n\tif (failed) {\n\t\tzend_type_error(\"Return value of callback provided to ZipArchive::registerCancelCallback()\"\n\t\t\t\" must be of type int, %s returned\", zend_zval_value_name(&cb_retval));\n\t\tzval_ptr_dtor(&cb_retval);\n\t\treturn -1;\n\t}\n\tzval_ptr_dtor(&cb_retval);\n\n\treturn (int) retval;\n}\n\n/* {{{ register a progression callback: int callback(double state); */\nPHP_METHOD(ZipArchive, registerCancelCallback)\n{\n\tstruct zip *intern;\n\tzend_fcall_info dummy_fci;\n\tzend_fcall_info_cache fcc;\n\tze_zip_object *obj;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"F\", &dummy_fci, &fcc) == FAILURE) {\n\t\tRETURN_THROWS();\n\t}\n\n\t/* Inline ZIP_FROM_OBJECT(intern, self); */\n\tobj = Z_ZIP_P(ZEND_THIS);\n\tintern = obj->za;\n\tif (!intern) { \\\n\t\tzend_value_error(\"Invalid or uninitialized Zip object\");\n\t\tzend_release_fcall_info_cache(&fcc);\n\t\tRETURN_THROWS();\n\t}\n\n\t/* register */\n\tif (zip_register_cancel_callback_with_state(intern, php_zip_cancel_callback, php_zip_cancel_callback_free, obj)) {\n\t\tRETURN_FALSE;\n\t}\n\tzend_fcc_dup(&obj->cancel_callback, &fcc);\n\n\tRETURN_TRUE;\n}\n/* }}} */\n#endif\n\n#ifdef HAVE_METHOD_SUPPORTED\n/* {{{ check if a compression method is available in used libzip */\nPHP_METHOD(ZipArchive, isCompressionMethodSupported)\n{\n\tzend_long method;\n\tbool enc = 1;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"l|b\", &method, &enc) == FAILURE) {\n\t\treturn;\n\t}\n\tRETVAL_BOOL(zip_compression_method_supported((zip_int32_t)method, enc));\n}\n/* }}} */\n\n/* {{{ check if a encryption method is available in used libzip */\nPHP_METHOD(ZipArchive, isEncryptionMethodSupported)\n{\n\tzend_long method;\n\tbool enc = 1;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"l|b\", &method, &enc) == FAILURE) {\n\t\treturn;\n\t}\n\tRETVAL_BOOL(zip_encryption_method_supported((zip_uint16_t)method, enc));\n}\n/* }}} */\n#endif\n\nstatic void php_zip_free_prop_handler(zval *el) /* {{{ */ {\n\tpefree(Z_PTR_P(el), 1);\n} /* }}} */\n\n/* {{{ PHP_MINIT_FUNCTION */\nstatic PHP_MINIT_FUNCTION(zip)\n{\n\tmemcpy(&zip_object_handlers, &std_object_handlers, sizeof(zend_object_handlers));\n\tzip_object_handlers.offset = XtOffsetOf(ze_zip_object, zo);\n\tzip_object_handlers.free_obj = php_zip_object_free_storage;\n\tzip_object_handlers.clone_obj = NULL;\n\tzip_object_handlers.get_property_ptr_ptr = php_zip_get_property_ptr_ptr;\n\n\tzip_object_handlers.get_gc          = php_zip_get_gc;\n\tzip_object_handlers.get_properties = php_zip_get_properties;\n\tzip_object_handlers.read_property\t= php_zip_read_property;\n\tzip_object_handlers.has_property\t= php_zip_has_property;\n\tzip_object_handlers.write_property = php_zip_write_property;\n\n\tzip_class_entry = register_class_ZipArchive(zend_ce_countable);\n\tzip_class_entry->create_object = php_zip_object_new;\n\tzip_class_entry->default_object_handlers = &zip_object_handlers;\n\n\tzend_hash_init(&zip_prop_handlers, 0, NULL, php_zip_free_prop_handler, 1);\n\tphp_zip_register_prop_handler(&zip_prop_handlers, \"lastId\",    php_zip_last_id, NULL, IS_LONG);\n\tphp_zip_register_prop_handler(&zip_prop_handlers, \"status\",    php_zip_status, NULL, IS_LONG);\n\tphp_zip_register_prop_handler(&zip_prop_handlers, \"statusSys\", php_zip_status_sys, NULL, IS_LONG);\n\tphp_zip_register_prop_handler(&zip_prop_handlers, \"numFiles\",  php_zip_get_num_files, NULL, IS_LONG);\n\tphp_zip_register_prop_handler(&zip_prop_handlers, \"filename\",  NULL, php_zipobj_get_filename, IS_STRING);\n\tphp_zip_register_prop_handler(&zip_prop_handlers, \"comment\",   NULL, php_zipobj_get_zip_comment, IS_STRING);\n\n\tphp_register_url_stream_wrapper(\"zip\", &php_stream_zip_wrapper);\n\n\tregister_php_zip_symbols(module_number);\n\n\tle_zip_dir   = zend_register_list_destructors_ex(php_zip_free_dir,   NULL, le_zip_dir_name,   module_number);\n\tle_zip_entry = zend_register_list_destructors_ex(php_zip_free_entry, NULL, le_zip_entry_name, module_number);\n\n\treturn SUCCESS;\n}\n/* }}} */\n\n/* {{{ PHP_MSHUTDOWN_FUNCTION */\nstatic PHP_MSHUTDOWN_FUNCTION(zip)\n{\n\tzend_hash_destroy(&zip_prop_handlers);\n\tphp_unregister_url_stream_wrapper(\"zip\");\n\treturn SUCCESS;\n}\n/* }}} */\n\n/* {{{ PHP_MINFO_FUNCTION */\nstatic PHP_MINFO_FUNCTION(zip)\n{\n\tphp_info_print_table_start();\n\n\tphp_info_print_table_row(2, \"Zip\", \"enabled\");\n\tphp_info_print_table_row(2, \"Zip version\", PHP_ZIP_VERSION);\n#ifdef HAVE_LIBZIP_VERSION\n\tif (strcmp(LIBZIP_VERSION, zip_libzip_version())) {\n\t\tphp_info_print_table_row(2, \"Libzip headers version\", LIBZIP_VERSION);\n\t\tphp_info_print_table_row(2, \"Libzip library version\", zip_libzip_version());\n\t} else\n#endif\n\t{\n\t\tphp_info_print_table_row(2, \"Libzip version\", LIBZIP_VERSION);\n\t}\n#ifdef HAVE_METHOD_SUPPORTED\n\tphp_info_print_table_row(2, \"BZIP2 compression\",\n\t\tzip_compression_method_supported(ZIP_CM_BZIP2, 1) ? \"Yes\" : \"No\");\n\tphp_info_print_table_row(2, \"XZ compression\",\n\t\tzip_compression_method_supported(ZIP_CM_XZ, 1) ? \"Yes\" : \"No\");\n#ifdef ZIP_CM_ZSTD\n\tphp_info_print_table_row(2, \"ZSTD compression\",\n\t\tzip_compression_method_supported(ZIP_CM_ZSTD, 1) ? \"Yes\" : \"No\");\n#else\n\tphp_info_print_table_row(2, \"ZSTD compression\", \"No\");\n#endif\n\tphp_info_print_table_row(2, \"AES-128 encryption\",\n\t\tzip_encryption_method_supported(ZIP_EM_AES_128, 1) ? \"Yes\" : \"No\");\n\tphp_info_print_table_row(2, \"AES-192 encryption\",\n\t\tzip_encryption_method_supported(ZIP_EM_AES_128, 1) ? \"Yes\" : \"No\");\n\tphp_info_print_table_row(2, \"AES-256 encryption\",\n\t\tzip_encryption_method_supported(ZIP_EM_AES_128, 1) ? \"Yes\" : \"No\");\n#endif\n\n\tphp_info_print_table_end();\n}\n/* }}} */\n", "patch": "@@ -1281,7 +1281,7 @@ static PHP_NAMED_FUNCTION(zif_zip_entry_read)\n \t}\n \n \tif (zr_rsrc->zf) {\n-\t\tbuffer = zend_string_alloc(len, 0);\n+\t\tbuffer = zend_string_safe_alloc(1, len, 0, 0);\n \t\tn = zip_fread(zr_rsrc->zf, ZSTR_VAL(buffer), ZSTR_LEN(buffer));\n \t\tif (n > 0) {\n \t\t\tZSTR_VAL(buffer)[n] = '\\0';\n@@ -2728,7 +2728,7 @@ static void php_zip_get_from(INTERNAL_FUNCTION_PARAMETERS, int type) /* {{{ */\n \t\tRETURN_FALSE;\n \t}\n \n-\tbuffer = zend_string_alloc(len, 0);\n+\tbuffer = zend_string_safe_alloc(1, len, 0, 0);\n \tn = zip_fread(zf, ZSTR_VAL(buffer), ZSTR_LEN(buffer));\n \tif (n < 1) {\n \t\tzend_string_free(buffer);", "file_path": "files/2016_8\\70", "file_language": "c", "file_name": "ext/zip/php_zip.c", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}], "outdated": 0}
{"index": 27, "cve_id": "CVE-2016-5771", "cwe_id": ["CWE-416"], "cve_language": "C", "cve_description": "spl_array.c in the SPL extension in PHP before 5.5.37 and 5.6.x before 5.6.23 improperly interacts with the unserialize implementation and garbage collection, which allows remote attackers to execute arbitrary code or cause a denial of service (use-after-free and application crash) via crafted serialized data.", "cvss": "9.8", "publish_date": "August 7, 2016", "AV": "NETWORK", "AC": "LOW", "PR": "NONE", "UI": "NONE", "S": "UNCHANGED", "C": "HIGH", "I": "HIGH", "A": "HIGH", "commit_id": "996faf964bba1aec06b153b370a7f20d3dd2bb8b", "commit_message": "Update header handling to RFC 7230", "commit_date": "2015-02-18T10:34:53Z", "project": "php/php-src", "url": "https://api.github.com/repos/php/php-src/commits/996faf964bba1aec06b153b370a7f20d3dd2bb8b", "html_url": "https://github.com/php/php-src/commit/996faf964bba1aec06b153b370a7f20d3dd2bb8b", "windows_before": "", "windows_after": "", "parents": [{"commit_id_before": "d8bc34942d4f94cecdcbc63aa0772c5717525279", "url_before": "https://api.github.com/repos/php/php-src/commits/d8bc34942d4f94cecdcbc63aa0772c5717525279", "html_url_before": "https://github.com/php/php-src/commit/d8bc34942d4f94cecdcbc63aa0772c5717525279"}], "details": [{"raw_url": "https://github.com/php/php-src/raw/996faf964bba1aec06b153b370a7f20d3dd2bb8b/ext/standard/tests/general_functions/bug60227_2.phpt", "code": "--TEST--\nBug #60227 (header() cannot detect the multi-line header with CR), \\r before \\n\n--INI--\nexpose_php=0\n--FILE--\n<?php\nheader(\"X-foo: e\\n foo\");\necho 'foo';\n?>\n--EXPECTF--\n\nWarning: Header may not contain more than a single header, new line detected in %s on line %d\nfoo\n--EXPECTHEADERS--\nContent-type: text/html; charset=UTF-8\n", "code_before": "--TEST--\nBug #60227 (header() cannot detect the multi-line header with CR), \\r before \\n\n--INI--\nexpose_php=0\ndefault_charset=UTF-8\n--FILE--\n<?php\nheader(\"X-foo: e\\n foo\");\necho 'foo';\n?>\n--EXPECTF--\n\nWarning: Header may not contain more than a single header, new line detected in %s on line %d\nfoo\n--EXPECTHEADERS--\nContent-type: text/html; charset=UTF-8\n", "patch": "@@ -1,14 +1,15 @@\n --TEST--\n Bug #60227 (header() cannot detect the multi-line header with CR), \\r before \\n\n+--INI--\n+expose_php=0\n --FILE--\n <?php\n header(\"X-foo: e\\n foo\");\n-header(\"X-Foo6: e\\rSet-Cookie: ID=123\\n d\");\n echo 'foo';\n ?>\n --EXPECTF--\n+\n Warning: Header may not contain more than a single header, new line detected in %s on line %d\n foo\n --EXPECTHEADERS--\n-X-foo: e\n-foo\n+Content-type: text/html; charset=UTF-8", "file_path": "files/2016_8\\71", "file_language": "phpt", "file_name": "ext/standard/tests/general_functions/bug60227_2.phpt", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}, {"raw_url": "https://github.com/php/php-src/raw/996faf964bba1aec06b153b370a7f20d3dd2bb8b/ext/standard/tests/general_functions/bug60227_3.phpt", "code": "--TEST--\nBug #60227 (header() cannot detect the multi-line header with CR), \\0 before \\n\n--INI--\nexpose_php=0\n--FILE--\n<?php\nheader(\"X-Foo6: e\\0Set-Cookie: ID=\\n123\\n d\");\necho 'foo';\n?>\n--EXPECTF--\nWarning: Header may not contain NUL bytes in %s on line %d\nfoo\n--EXPECTHEADERS--\nContent-type: text/html; charset=UTF-8\n", "code_before": "--TEST--\nBug #60227 (header() cannot detect the multi-line header with CR), \\0 before \\n\n--INI--\nexpose_php=0\n--FILE--\n<?php\nheader(\"X-Foo6: e\\0Set-Cookie: ID=\\n123\\n d\");\necho 'foo';\n?>\n--EXPECTF--\nWarning: Header may not contain NUL bytes in %s on line %d\nfoo\n--EXPECTHEADERS--\nContent-type: text/html; charset=UTF-8\n", "patch": "@@ -1,14 +1,14 @@\n --TEST--\n Bug #60227 (header() cannot detect the multi-line header with CR), \\0 before \\n\n+--INI--\n+expose_php=0\n --FILE--\n <?php\n-header(\"X-foo: e\\n foo\");\n header(\"X-Foo6: e\\0Set-Cookie: ID=\\n123\\n d\");\n echo 'foo';\n ?>\n --EXPECTF--\n Warning: Header may not contain NUL bytes in %s on line %d\n foo\n --EXPECTHEADERS--\n-X-foo: e\n-foo\n+Content-type: text/html; charset=UTF-8", "file_path": "files/2016_8\\72", "file_language": "phpt", "file_name": "ext/standard/tests/general_functions/bug60227_3.phpt", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}, {"raw_url": "https://github.com/php/php-src/raw/996faf964bba1aec06b153b370a7f20d3dd2bb8b/ext/standard/tests/general_functions/bug60227_4.phpt", "code": "--TEST--\nBug #60227 (header() cannot detect the multi-line header with CR), CRLF\n--INI--\nexpose_php=0\n--FILE--\n<?php\nheader(\"X-foo: e\\r\\nfoo\");\necho 'foo';\n?>\n--EXPECTF--\nWarning: Header may not contain more than a single header, new line detected in %s on line %d\nfoo\n--EXPECTHEADERS--\nContent-type: text/html; charset=UTF-8\n", "code_before": "--TEST--\nBug #60227 (header() cannot detect the multi-line header with CR), CRLF\n--INI--\nexpose_php=0\n--FILE--\n<?php\nheader(\"X-foo: e\\r\\nfoo\");\necho 'foo';\n?>\n--EXPECTF--\nWarning: Header may not contain more than a single header, new line detected in %s on line %d\nfoo\n--EXPECTHEADERS--\nContent-type: text/html; charset=UTF-8\n", "patch": "@@ -1,14 +1,14 @@\n --TEST--\n Bug #60227 (header() cannot detect the multi-line header with CR), CRLF\n+--INI--\n+expose_php=0\n --FILE--\n <?php\n-header(\"X-foo: e\\r\\n foo\");\n header(\"X-foo: e\\r\\nfoo\");\n echo 'foo';\n ?>\n --EXPECTF--\n Warning: Header may not contain more than a single header, new line detected in %s on line %d\n foo\n --EXPECTHEADERS--\n-X-foo: e\n- foo\n+Content-type: text/html; charset=UTF-8", "file_path": "files/2016_8\\73", "file_language": "phpt", "file_name": "ext/standard/tests/general_functions/bug60227_4.phpt", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}, {"raw_url": "https://github.com/php/php-src/raw/996faf964bba1aec06b153b370a7f20d3dd2bb8b/main/SAPI.c", "code": "/* \n   +----------------------------------------------------------------------+\n   | PHP Version 5                                                        |\n   +----------------------------------------------------------------------+\n   | Copyright (c) 1997-2015 The PHP Group                                |\n   +----------------------------------------------------------------------+\n   | This source file is subject to version 3.01 of the PHP license,      |\n   | that is bundled with this package in the file LICENSE, and is        |\n   | available through the world-wide-web at the following url:           |\n   | http://www.php.net/license/3_01.txt                                  |\n   | If you did not receive a copy of the PHP license and are unable to   |\n   | obtain it through the world-wide-web, please send a note to          |\n   | license@php.net so we can mail you a copy immediately.               |\n   +----------------------------------------------------------------------+\n   | Original design:  Shane Caraveo <shane@caraveo.com>                  |\n   | Authors: Andi Gutmans <andi@zend.com>                                |\n   |          Zeev Suraski <zeev@zend.com>                                |\n   +----------------------------------------------------------------------+\n*/\n\n/* $Id$ */\n\n#include <ctype.h>\n#include <sys/stat.h>\n\n#include \"php.h\"\n#include \"SAPI.h\"\n#include \"php_variables.h\"\n#include \"php_ini.h\"\n#include \"ext/standard/php_string.h\"\n#include \"ext/standard/pageinfo.h\"\n#if (HAVE_PCRE || HAVE_BUNDLED_PCRE) && !defined(COMPILE_DL_PCRE)\n#include \"ext/pcre/php_pcre.h\"\n#endif\n#ifdef ZTS\n#include \"TSRM.h\"\n#endif\n#ifdef HAVE_SYS_TIME_H\n#include <sys/time.h>\n#elif defined(PHP_WIN32)\n#include \"win32/time.h\"\n#endif\n\n#include \"rfc1867.h\"\n\n#ifdef PHP_WIN32\n#define STRCASECMP stricmp\n#else\n#define STRCASECMP strcasecmp\n#endif\n\n#include \"php_content_types.h\"\n\n#ifdef ZTS\nSAPI_API int sapi_globals_id;\n#else\nsapi_globals_struct sapi_globals;\n#endif\n\nstatic void sapi_globals_ctor(sapi_globals_struct *sapi_globals TSRMLS_DC)\n{\n\tmemset(sapi_globals, 0, sizeof(*sapi_globals));\n\tzend_hash_init_ex(&sapi_globals->known_post_content_types, 5, NULL, NULL, 1, 0);\n\tphp_setup_sapi_content_types(TSRMLS_C);\n}\n\nstatic void sapi_globals_dtor(sapi_globals_struct *sapi_globals TSRMLS_DC)\n{\n\tzend_hash_destroy(&sapi_globals->known_post_content_types);\n}\n\n/* True globals (no need for thread safety) */\nSAPI_API sapi_module_struct sapi_module;\n\n\nSAPI_API void sapi_startup(sapi_module_struct *sf)\n{\n#ifdef ZEND_SIGNALS\n\tzend_signal_startup();\n#endif\n\n\tsf->ini_entries = NULL;\n\tsapi_module = *sf;\n\n#ifdef ZTS\n\tts_allocate_id(&sapi_globals_id, sizeof(sapi_globals_struct), (ts_allocate_ctor) sapi_globals_ctor, (ts_allocate_dtor) sapi_globals_dtor);\n# ifdef PHP_WIN32\n\t_configthreadlocale(_ENABLE_PER_THREAD_LOCALE);\n# endif\n#else\n\tsapi_globals_ctor(&sapi_globals);\n#endif\n\n\tvirtual_cwd_startup(); /* Could use shutdown to free the main cwd but it would just slow it down for CGI */\n\n#ifdef PHP_WIN32\n\ttsrm_win32_startup();\n#endif\n\n\treentrancy_startup();\n}\n\nSAPI_API void sapi_shutdown(void)\n{\n#ifdef ZTS\n\tts_free_id(sapi_globals_id);\n#else\n\tsapi_globals_dtor(&sapi_globals);\n#endif\n\n\treentrancy_shutdown();\n\n\tvirtual_cwd_shutdown();\n\n#ifdef PHP_WIN32\n\ttsrm_win32_shutdown();\n#endif\n}\n\n\nSAPI_API void sapi_free_header(sapi_header_struct *sapi_header)\n{\n\tefree(sapi_header->header);\n}\n\n/* {{{ proto bool header_register_callback(mixed callback)\n   call a header function */\nPHP_FUNCTION(header_register_callback)\n{\n\tzval *callback_func;\n\tchar *callback_name;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"z\", &callback_func) == FAILURE) {\n\t\treturn;\n\t}\n\t\n\tif (!zend_is_callable(callback_func, 0, &callback_name TSRMLS_CC)) {\n\t\tefree(callback_name);\n\t\tRETURN_FALSE;\n\t}\n\n\tefree(callback_name);\n\n\tif (SG(callback_func)) {\n\t\tzval_ptr_dtor(&SG(callback_func));\n\t\tSG(fci_cache) = empty_fcall_info_cache;\n\t}\n\n\tSG(callback_func) = callback_func;\n\n\tZ_ADDREF_P(SG(callback_func));\n\n\tRETURN_TRUE;\n}\n/* }}} */\n\nstatic void sapi_run_header_callback(TSRMLS_D)\n{\n\tint   error;\n\tzend_fcall_info fci;\n\tchar *callback_name = NULL;\n\tchar *callback_error = NULL;\n\tzval *retval_ptr = NULL;\n\t\n\tif (zend_fcall_info_init(SG(callback_func), 0, &fci, &SG(fci_cache), &callback_name, &callback_error TSRMLS_CC) == SUCCESS) {\n\t\tfci.retval_ptr_ptr = &retval_ptr;\n\t\t\n\t\terror = zend_call_function(&fci, &SG(fci_cache) TSRMLS_CC);\n\t\tif (error == FAILURE) {\n\t\t\tgoto callback_failed;\n\t\t} else if (retval_ptr) {\n\t\t\tzval_ptr_dtor(&retval_ptr);\n\t\t}\n\t} else {\ncallback_failed:\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Could not call the sapi_header_callback\");\n\t}\n\t\n\tif (callback_name) {\n\t\tefree(callback_name);\n\t}\n\tif (callback_error) {\n\t\tefree(callback_error);\n\t}\t\n}\n\nSAPI_API void sapi_handle_post(void *arg TSRMLS_DC)\n{\n\tif (SG(request_info).post_entry && SG(request_info).content_type_dup) {\n\t\tSG(request_info).post_entry->post_handler(SG(request_info).content_type_dup, arg TSRMLS_CC);\n\t\tif (SG(request_info).post_data) {\n\t\t\tefree(SG(request_info).post_data);\n\t\t\tSG(request_info).post_data = NULL;\n\t\t}\n\t\tefree(SG(request_info).content_type_dup);\n\t\tSG(request_info).content_type_dup = NULL;\n\t}\n}\n\nstatic void sapi_read_post_data(TSRMLS_D)\n{\n\tsapi_post_entry *post_entry;\n\tuint content_type_length = strlen(SG(request_info).content_type);\n\tchar *content_type = estrndup(SG(request_info).content_type, content_type_length);\n\tchar *p;\n\tchar oldchar=0;\n\tvoid (*post_reader_func)(TSRMLS_D) = NULL;\n\n\n\t/* dedicated implementation for increased performance:\n\t * - Make the content type lowercase\n\t * - Trim descriptive data, stay with the content-type only\n\t */\n\tfor (p=content_type; p<content_type+content_type_length; p++) {\n\t\tswitch (*p) {\n\t\t\tcase ';':\n\t\t\tcase ',':\n\t\t\tcase ' ':\n\t\t\t\tcontent_type_length = p-content_type;\n\t\t\t\toldchar = *p;\n\t\t\t\t*p = 0;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t*p = tolower(*p);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* now try to find an appropriate POST content handler */\n\tif (zend_hash_find(&SG(known_post_content_types), content_type,\n\t\t\tcontent_type_length+1, (void **) &post_entry) == SUCCESS) {\n\t\t/* found one, register it for use */\n\t\tSG(request_info).post_entry = post_entry;\n\t\tpost_reader_func = post_entry->post_reader;\n\t} else {\n\t\t/* fallback */\n\t\tSG(request_info).post_entry = NULL;\n\t\tif (!sapi_module.default_post_reader) {\n\t\t\t/* no default reader ? */\n\t\t\tSG(request_info).content_type_dup = NULL;\n\t\t\tsapi_module.sapi_error(E_WARNING, \"Unsupported content type:  '%s'\", content_type);\n\t\t\treturn;\n\t\t}\n\t}\n\tif (oldchar) {\n\t\t*(p-1) = oldchar;\n\t}\n\n\tSG(request_info).content_type_dup = content_type;\n\n\tif(post_reader_func) {\n\t\tpost_reader_func(TSRMLS_C);\n\t}\n\n\tif(sapi_module.default_post_reader) {\n\t\tsapi_module.default_post_reader(TSRMLS_C);\n\t}\n}\n\n\nSAPI_API SAPI_POST_READER_FUNC(sapi_read_standard_form_data)\n{\n\tint read_bytes;\n\tint allocated_bytes=SAPI_POST_BLOCK_SIZE+1;\n\n\tif ((SG(post_max_size) > 0) && (SG(request_info).content_length > SG(post_max_size))) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"POST Content-Length of %ld bytes exceeds the limit of %ld bytes\",\n\t\t\t\t\tSG(request_info).content_length, SG(post_max_size));\n\t\treturn;\n\t}\n\tSG(request_info).post_data = emalloc(allocated_bytes);\n\n\tfor (;;) {\n\t\tread_bytes = sapi_module.read_post(SG(request_info).post_data+SG(read_post_bytes), SAPI_POST_BLOCK_SIZE TSRMLS_CC);\n\t\tif (read_bytes<=0) {\n\t\t\tbreak;\n\t\t}\n\t\tSG(read_post_bytes) += read_bytes;\n\t\tif ((SG(post_max_size) > 0) && (SG(read_post_bytes) > SG(post_max_size))) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Actual POST length does not match Content-Length, and exceeds %ld bytes\", SG(post_max_size));\n\t\t\tbreak;\n\t\t}\n\t\tif (read_bytes < SAPI_POST_BLOCK_SIZE) {\n\t\t\tbreak;\n\t\t}\n\t\tif (SG(read_post_bytes)+SAPI_POST_BLOCK_SIZE >= allocated_bytes) {\n\t\t\tallocated_bytes = SG(read_post_bytes)+SAPI_POST_BLOCK_SIZE+1;\n\t\t\tSG(request_info).post_data = erealloc(SG(request_info).post_data, allocated_bytes);\n\t\t}\n\t}\n\tSG(request_info).post_data[SG(read_post_bytes)] = 0;  /* terminating NULL */\n\tSG(request_info).post_data_length = SG(read_post_bytes);\n}\n\n\nstatic inline char *get_default_content_type(uint prefix_len, uint *len TSRMLS_DC)\n{\n\tchar *mimetype, *charset, *content_type;\n\tuint mimetype_len, charset_len;\n\n\tif (SG(default_mimetype)) {\n\t\tmimetype = SG(default_mimetype);\n\t\tmimetype_len = strlen(SG(default_mimetype));\n\t} else {\n\t\tmimetype = SAPI_DEFAULT_MIMETYPE;\n\t\tmimetype_len = sizeof(SAPI_DEFAULT_MIMETYPE) - 1;\n\t}\n\tif (SG(default_charset)) {\n\t\tcharset = SG(default_charset);\n\t\tcharset_len = strlen(SG(default_charset));\n\t} else {\n\t\tcharset = SAPI_DEFAULT_CHARSET;\n\t\tcharset_len = sizeof(SAPI_DEFAULT_CHARSET) - 1;\n\t}\n\n\tif (*charset && strncasecmp(mimetype, \"text/\", 5) == 0) {\n\t\tchar *p;\n\n\t\t*len = prefix_len + mimetype_len + sizeof(\"; charset=\") - 1 + charset_len;\n\t\tcontent_type = (char*)emalloc(*len + 1);\n\t\tp = content_type + prefix_len;\n\t\tmemcpy(p, mimetype, mimetype_len);\n\t\tp += mimetype_len;\n\t\tmemcpy(p, \"; charset=\", sizeof(\"; charset=\") - 1);\n\t\tp += sizeof(\"; charset=\") - 1;\n\t\tmemcpy(p, charset, charset_len + 1);\n\t} else {\n\t\t*len = prefix_len + mimetype_len;\n\t\tcontent_type = (char*)emalloc(*len + 1);\n\t\tmemcpy(content_type + prefix_len, mimetype, mimetype_len + 1);\n\t}\n\treturn content_type;\n}\n\n\nSAPI_API char *sapi_get_default_content_type(TSRMLS_D)\n{\n\tuint len;\n\n\treturn get_default_content_type(0, &len TSRMLS_CC);\n}\n\n\nSAPI_API void sapi_get_default_content_type_header(sapi_header_struct *default_header TSRMLS_DC)\n{\n    uint len;\n\n\tdefault_header->header = get_default_content_type(sizeof(\"Content-type: \")-1, &len TSRMLS_CC);\n\tdefault_header->header_len = len;\n\tmemcpy(default_header->header, \"Content-type: \", sizeof(\"Content-type: \") - 1);\n}\n\n/*\n * Add charset on content-type header if the MIME type starts with\n * \"text/\", the default_charset directive is not empty and\n * there is not already a charset option in there.\n *\n * If \"mimetype\" is non-NULL, it should point to a pointer allocated\n * with emalloc().  If a charset is added, the string will be\n * re-allocated and the new length is returned.  If mimetype is\n * unchanged, 0 is returned.\n *\n */\nSAPI_API size_t sapi_apply_default_charset(char **mimetype, size_t len TSRMLS_DC)\n{\n\tchar *charset, *newtype;\n\tsize_t newlen;\n\tcharset = SG(default_charset) ? SG(default_charset) : SAPI_DEFAULT_CHARSET;\n\n\tif (*mimetype != NULL) {\n\t\tif (*charset && strncmp(*mimetype, \"text/\", 5) == 0 && strstr(*mimetype, \"charset=\") == NULL) {\n\t\t\tnewlen = len + (sizeof(\";charset=\")-1) + strlen(charset);\n\t\t\tnewtype = emalloc(newlen + 1);\n\t \t\tPHP_STRLCPY(newtype, *mimetype, newlen + 1, len);\n\t\t\tstrlcat(newtype, \";charset=\", newlen + 1);\n\t\t\tstrlcat(newtype, charset, newlen + 1);\n\t\t\tefree(*mimetype);\n\t\t\t*mimetype = newtype;\n\t\t\treturn newlen;\n\t\t}\n\t}\n\treturn 0;\n}\n\nSAPI_API void sapi_activate_headers_only(TSRMLS_D)\n{\n\tif (SG(request_info).headers_read == 1)\n\t\treturn;\n\tSG(request_info).headers_read = 1;\n\tzend_llist_init(&SG(sapi_headers).headers, sizeof(sapi_header_struct), \n\t\t\t(void (*)(void *)) sapi_free_header, 0);\n\tSG(sapi_headers).send_default_content_type = 1;\n\n\t/* SG(sapi_headers).http_response_code = 200; */ \n\tSG(sapi_headers).http_status_line = NULL;\n\tSG(sapi_headers).mimetype = NULL;\n\tSG(read_post_bytes) = 0;\n\tSG(request_info).post_data = NULL;\n\tSG(request_info).raw_post_data = NULL;\n\tSG(request_info).current_user = NULL;\n\tSG(request_info).current_user_length = 0;\n\tSG(request_info).no_headers = 0;\n\tSG(request_info).post_entry = NULL;\n\tSG(global_request_time) = 0;\n\n\t/*\n\t * It's possible to override this general case in the activate() callback, \n\t * if necessary.\n\t */\n\tif (SG(request_info).request_method && !strcmp(SG(request_info).request_method, \"HEAD\")) {\n\t\tSG(request_info).headers_only = 1;\n\t} else {\n\t\tSG(request_info).headers_only = 0;\n\t}\n\tif (SG(server_context)) {\n\t\tSG(request_info).cookie_data = sapi_module.read_cookies(TSRMLS_C);\n\t\tif (sapi_module.activate) {\n\t\t\tsapi_module.activate(TSRMLS_C);\n\t\t}\n\t}\n\tif (sapi_module.input_filter_init ) {\n\t\tsapi_module.input_filter_init(TSRMLS_C);\n\t}\n}\n\n/*\n * Called from php_request_startup() for every request.\n */\n\nSAPI_API void sapi_activate(TSRMLS_D)\n{\n\tzend_llist_init(&SG(sapi_headers).headers, sizeof(sapi_header_struct), (void (*)(void *)) sapi_free_header, 0);\n\tSG(sapi_headers).send_default_content_type = 1;\n\n\t/*\n\tSG(sapi_headers).http_response_code = 200;\n\t*/\n\tSG(sapi_headers).http_status_line = NULL;\n\tSG(sapi_headers).mimetype = NULL;\n\tSG(headers_sent) = 0;\n\tSG(callback_run) = 0;\n\tSG(callback_func) = NULL;\n\tSG(read_post_bytes) = 0;\n\tSG(request_info).post_data = NULL;\n\tSG(request_info).raw_post_data = NULL;\n\tSG(request_info).current_user = NULL;\n\tSG(request_info).current_user_length = 0;\n\tSG(request_info).no_headers = 0;\n\tSG(request_info).post_entry = NULL;\n\tSG(request_info).proto_num = 1000; /* Default to HTTP 1.0 */\n\tSG(global_request_time) = 0;\n\n\t/* It's possible to override this general case in the activate() callback, if necessary. */\n\tif (SG(request_info).request_method && !strcmp(SG(request_info).request_method, \"HEAD\")) {\n\t\tSG(request_info).headers_only = 1;\n\t} else {\n\t\tSG(request_info).headers_only = 0;\n\t}\n\tSG(rfc1867_uploaded_files) = NULL;\n\n\t/* Handle request method */\n\tif (SG(server_context)) {\n\t\tif (PG(enable_post_data_reading) && SG(request_info).request_method) {\n\t\t\tif (SG(request_info).content_type && !strcmp(SG(request_info).request_method, \"POST\")) {\n\t\t\t\t/* HTTP POST may contain form data to be processed into variables\n\t\t\t\t * depending on given content type */\n\t\t\t\tsapi_read_post_data(TSRMLS_C);\n\t\t\t} else {\n\t\t\t\t/* Any other method with content payload will fill $HTTP_RAW_POST_DATA \n\t\t\t\t * if it is enabled by always_populate_raw_post_data. \n\t\t\t\t * It's up to the webserver to decide whether to allow a method or not. */\n\t\t\t\tSG(request_info).content_type_dup = NULL;\n\t\t\t\tif (sapi_module.default_post_reader) {\n\t\t\t\t\tsapi_module.default_post_reader(TSRMLS_C);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tSG(request_info).content_type_dup = NULL;\n\t\t}\n\n\t\t/* Cookies */\n\t\tSG(request_info).cookie_data = sapi_module.read_cookies(TSRMLS_C);\n\n\t\tif (sapi_module.activate) {\n\t\t\tsapi_module.activate(TSRMLS_C);\n\t\t}\n\t}\n\tif (sapi_module.input_filter_init) {\n\t\tsapi_module.input_filter_init(TSRMLS_C);\n\t}\n}\n\n\nstatic void sapi_send_headers_free(TSRMLS_D)\n{\n\tif (SG(sapi_headers).http_status_line) {\n\t\tefree(SG(sapi_headers).http_status_line);\n\t\tSG(sapi_headers).http_status_line = NULL;\n\t}\n}\n\t\nSAPI_API void sapi_deactivate(TSRMLS_D)\n{\n\tzend_llist_destroy(&SG(sapi_headers).headers);\n\tif (SG(request_info).post_data) {\n\t\tefree(SG(request_info).post_data);\n\t}  else \tif (SG(server_context)) {\n\t\tif(sapi_module.read_post) { \n\t\t\t/* make sure we've consumed all request input data */\n\t\t\tchar dummy[SAPI_POST_BLOCK_SIZE];\n\t\t\tint read_bytes;\n\n\t\t\twhile((read_bytes = sapi_module.read_post(dummy, sizeof(dummy)-1 TSRMLS_CC)) > 0) {\n\t\t\t\tSG(read_post_bytes) += read_bytes;\n\t\t\t}\n\t\t}\n\t}\n\tif (SG(request_info).raw_post_data) {\n\t\tefree(SG(request_info).raw_post_data);\n\t} \n\tif (SG(request_info).auth_user) {\n\t\tefree(SG(request_info).auth_user);\n\t}\n\tif (SG(request_info).auth_password) {\n\t\tefree(SG(request_info).auth_password);\n\t}\n\tif (SG(request_info).auth_digest) {\n\t\tefree(SG(request_info).auth_digest);\n\t}\n\tif (SG(request_info).content_type_dup) {\n\t\tefree(SG(request_info).content_type_dup);\n\t}\n\tif (SG(request_info).current_user) {\n\t\tefree(SG(request_info).current_user);\n\t}\n\tif (sapi_module.deactivate) {\n\t\tsapi_module.deactivate(TSRMLS_C);\n\t}\n\tif (SG(rfc1867_uploaded_files)) {\n\t\tdestroy_uploaded_files_hash(TSRMLS_C);\n\t}\n\tif (SG(sapi_headers).mimetype) {\n\t\tefree(SG(sapi_headers).mimetype);\n\t\tSG(sapi_headers).mimetype = NULL;\n\t}\n\tsapi_send_headers_free(TSRMLS_C);\n\tSG(sapi_started) = 0;\n\tSG(headers_sent) = 0;\n\tSG(callback_run) = 0;\n\tif (SG(callback_func)) {\n\t\tzval_ptr_dtor(&SG(callback_func));\n\t}\n\tSG(request_info).headers_read = 0;\n\tSG(global_request_time) = 0;\n}\n\n\nSAPI_API void sapi_initialize_empty_request(TSRMLS_D)\n{\n\tSG(server_context) = NULL;\n\tSG(request_info).request_method = NULL;\n\tSG(request_info).auth_digest = SG(request_info).auth_user = SG(request_info).auth_password = NULL;\n\tSG(request_info).content_type_dup = NULL;\n}\n\n\nstatic int sapi_extract_response_code(const char *header_line)\n{\n\tint code = 200;\n\tconst char *ptr;\n\n\tfor (ptr = header_line; *ptr; ptr++) {\n\t\tif (*ptr == ' ' && *(ptr + 1) != ' ') {\n\t\t\tcode = atoi(ptr + 1);\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\treturn code;\n}\n\n\nstatic void sapi_update_response_code(int ncode TSRMLS_DC)\n{\n\t/* if the status code did not change, we do not want\n\t   to change the status line, and no need to change the code */\n\tif (SG(sapi_headers).http_response_code == ncode) {\n\t\treturn;\n\t}\n\n\tif (SG(sapi_headers).http_status_line) {\n\t\tefree(SG(sapi_headers).http_status_line);\n\t\tSG(sapi_headers).http_status_line = NULL;\n\t}\n\tSG(sapi_headers).http_response_code = ncode;\n}\n\n/* \n * since zend_llist_del_element only remove one matched item once,\n * we should remove them by ourself\n */\nstatic void sapi_remove_header(zend_llist *l, char *name, uint len) {\n\tsapi_header_struct *header;\n\tzend_llist_element *next;\n\tzend_llist_element *current=l->head;\n\n\twhile (current) {\n\t\theader = (sapi_header_struct *)(current->data);\n\t\tnext = current->next;\n\t\tif (header->header_len > len && header->header[len] == ':'\n\t\t\t\t&& !strncasecmp(header->header, name, len)) {\n\t\t\tif (current->prev) {\n\t\t\t\tcurrent->prev->next = next;\n\t\t\t} else {\n\t\t\t\tl->head = next;\n\t\t\t}\n\t\t\tif (next) {\n\t\t\t\tnext->prev = current->prev;\n\t\t\t} else {\n\t\t\t\tl->tail = current->prev;\n\t\t\t}\n\t\t\tsapi_free_header(header);\n\t\t\tefree(current);\n\t\t\t--l->count;\n\t\t}\n\t\tcurrent = next;\n\t}\n}\n\nSAPI_API int sapi_add_header_ex(char *header_line, uint header_line_len, zend_bool duplicate, zend_bool replace TSRMLS_DC)\n{\n\tsapi_header_line ctr = {0};\n\tint r;\n\t\n\tctr.line = header_line;\n\tctr.line_len = header_line_len;\n\n\tr = sapi_header_op(replace ? SAPI_HEADER_REPLACE : SAPI_HEADER_ADD,\n\t\t\t&ctr TSRMLS_CC);\n\n\tif (!duplicate)\n\t\tefree(header_line);\n\n\treturn r;\n}\n\nstatic void sapi_header_add_op(sapi_header_op_enum op, sapi_header_struct *sapi_header TSRMLS_DC)\n{\n\tif (!sapi_module.header_handler ||\n\t\t(SAPI_HEADER_ADD & sapi_module.header_handler(sapi_header, op, &SG(sapi_headers) TSRMLS_CC))) {\n\t\tif (op == SAPI_HEADER_REPLACE) {\n\t\t\tchar *colon_offset = strchr(sapi_header->header, ':');\n\n\t\t\tif (colon_offset) {\n\t\t\t\tchar sav = *colon_offset;\n\n\t\t\t\t*colon_offset = 0;\n\t\t        sapi_remove_header(&SG(sapi_headers).headers, sapi_header->header, strlen(sapi_header->header));\n\t\t\t\t*colon_offset = sav;\n\t\t\t}\n\t\t}\n\t\tzend_llist_add_element(&SG(sapi_headers).headers, (void *) sapi_header);\n\t} else {\n\t\tsapi_free_header(sapi_header);\n\t}\n}\n\nSAPI_API int sapi_header_op(sapi_header_op_enum op, void *arg TSRMLS_DC)\n{\n\tsapi_header_struct sapi_header;\n\tchar *colon_offset;\n\tchar *header_line;\n\tuint header_line_len;\n\tint http_response_code;\n\n\tif (SG(headers_sent) && !SG(request_info).no_headers) {\n\t\tconst char *output_start_filename = php_output_get_start_filename(TSRMLS_C);\n\t\tint output_start_lineno = php_output_get_start_lineno(TSRMLS_C);\n\n\t\tif (output_start_filename) {\n\t\t\tsapi_module.sapi_error(E_WARNING, \"Cannot modify header information - headers already sent by (output started at %s:%d)\",\n\t\t\t\toutput_start_filename, output_start_lineno);\n\t\t} else {\n\t\t\tsapi_module.sapi_error(E_WARNING, \"Cannot modify header information - headers already sent\");\n\t\t}\n\t\treturn FAILURE;\n\t}\n\n\tswitch (op) {\n\t\tcase SAPI_HEADER_SET_STATUS:\n\t\t\tsapi_update_response_code((int)(zend_intptr_t) arg TSRMLS_CC);\n\t\t\treturn SUCCESS;\n\n\t\tcase SAPI_HEADER_ADD:\n\t\tcase SAPI_HEADER_REPLACE:\n\t\tcase SAPI_HEADER_DELETE: {\n\t\t\t\tsapi_header_line *p = arg;\n\n\t\t\t\tif (!p->line || !p->line_len) {\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\t\t\t\theader_line = p->line;\n\t\t\t\theader_line_len = p->line_len;\n\t\t\t\thttp_response_code = p->response_code;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tcase SAPI_HEADER_DELETE_ALL:\n\t\t\tif (sapi_module.header_handler) {\n\t\t\t\tsapi_module.header_handler(&sapi_header, op, &SG(sapi_headers) TSRMLS_CC);\n\t\t\t}\n\t\t\tzend_llist_clean(&SG(sapi_headers).headers);\n\t\t\treturn SUCCESS;\n\n\t\tdefault:\n\t\t\treturn FAILURE;\n\t}\n\n\theader_line = estrndup(header_line, header_line_len);\n\n\t/* cut off trailing spaces, linefeeds and carriage-returns */\n\tif (header_line_len && isspace(header_line[header_line_len-1])) {\n\t\tdo {\n\t\t\theader_line_len--;\n\t\t} while(header_line_len && isspace(header_line[header_line_len-1]));\n\t\theader_line[header_line_len]='\\0';\n\t}\n\t\n\tif (op == SAPI_HEADER_DELETE) {\n\t\tif (strchr(header_line, ':')) {\n\t\t\tefree(header_line);\n\t\t\tsapi_module.sapi_error(E_WARNING, \"Header to delete may not contain colon.\");\n\t\t\treturn FAILURE;\n\t\t}\n\t\tif (sapi_module.header_handler) {\n\t\t\tsapi_header.header = header_line;\n\t\t\tsapi_header.header_len = header_line_len;\n\t\t\tsapi_module.header_handler(&sapi_header, op, &SG(sapi_headers) TSRMLS_CC);\n\t\t}\n\t\tsapi_remove_header(&SG(sapi_headers).headers, header_line, header_line_len);\n\t\tefree(header_line);\n\t\treturn SUCCESS;\n\t} else {\n\t\t/* new line/NUL character safety check */\n\t\tint i;\n\t\tfor (i = 0; i < header_line_len; i++) {\n\t\t\t/* RFC 7230 ch. 3.2.4 deprecates folding support */\n\t\t\tif (header_line[i] == '\\n' || header_line[i] == '\\r') {\n\t\t\t\tefree(header_line);\n\t\t\t\tsapi_module.sapi_error(E_WARNING, \"Header may not contain \"\n\t\t\t\t\t\t\"more than a single header, new line detected\");\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t\tif (header_line[i] == '\\0') {\n\t\t\t\tefree(header_line);\n\t\t\t\tsapi_module.sapi_error(E_WARNING, \"Header may not contain NUL bytes\");\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t}\n\t}\n\n\tsapi_header.header = header_line;\n\tsapi_header.header_len = header_line_len;\n\n\t/* Check the header for a few cases that we have special support for in SAPI */\n\tif (header_line_len>=5 \n\t\t&& !strncasecmp(header_line, \"HTTP/\", 5)) {\n\t\t/* filter out the response code */\n\t\tsapi_update_response_code(sapi_extract_response_code(header_line) TSRMLS_CC);\n\t\t/* sapi_update_response_code doesn't free the status line if the code didn't change */\n\t\tif (SG(sapi_headers).http_status_line) {\n\t\t\tefree(SG(sapi_headers).http_status_line);\n\t\t}\n\t\tSG(sapi_headers).http_status_line = header_line;\n\t\treturn SUCCESS;\n\t} else {\n\t\tcolon_offset = strchr(header_line, ':');\n\t\tif (colon_offset) {\n\t\t\t*colon_offset = 0;\n\t\t\tif (!STRCASECMP(header_line, \"Content-Type\")) {\n\t\t\t\tchar *ptr = colon_offset+1, *mimetype = NULL, *newheader;\n\t\t\t\tsize_t len = header_line_len - (ptr - header_line), newlen;\n\t\t\t\twhile (*ptr == ' ') {\n\t\t\t\t\tptr++;\n\t\t\t\t\tlen--;\n\t\t\t\t}\n\n\t\t\t\t/* Disable possible output compression for images */\n\t\t\t\tif (!strncmp(ptr, \"image/\", sizeof(\"image/\")-1)) {\n\t\t\t\t\tzend_alter_ini_entry(\"zlib.output_compression\", sizeof(\"zlib.output_compression\"), \"0\", sizeof(\"0\") - 1, PHP_INI_USER, PHP_INI_STAGE_RUNTIME);\n\t\t\t\t}\n\n\t\t\t\tmimetype = estrdup(ptr);\n\t\t\t\tnewlen = sapi_apply_default_charset(&mimetype, len TSRMLS_CC);\n\t\t\t\tif (!SG(sapi_headers).mimetype){\n\t\t\t\t\tSG(sapi_headers).mimetype = estrdup(mimetype);\n\t\t\t\t}\n\n\t\t\t\tif (newlen != 0) {\n\t\t\t\t\tnewlen += sizeof(\"Content-type: \");\n\t\t\t\t\tnewheader = emalloc(newlen);\n\t\t\t\t\tPHP_STRLCPY(newheader, \"Content-type: \", newlen, sizeof(\"Content-type: \")-1);\n\t\t\t\t\tstrlcat(newheader, mimetype, newlen);\n\t\t\t\t\tsapi_header.header = newheader;\n\t\t\t\t\tsapi_header.header_len = newlen - 1;\n\t\t\t\t\tefree(header_line);\n\t\t\t\t}\n\t\t\t\tefree(mimetype);\n\t\t\t\tSG(sapi_headers).send_default_content_type = 0;\n\t\t\t} else if (!STRCASECMP(header_line, \"Content-Length\")) {\n\t\t\t\t/* Script is setting Content-length. The script cannot reasonably\n\t\t\t\t * know the size of the message body after compression, so it's best\n\t\t\t\t * do disable compression altogether. This contributes to making scripts\n\t\t\t\t * portable between setups that have and don't have zlib compression\n\t\t\t\t * enabled globally. See req #44164 */\n\t\t\t\tzend_alter_ini_entry(\"zlib.output_compression\", sizeof(\"zlib.output_compression\"),\n\t\t\t\t\t\"0\", sizeof(\"0\") - 1, PHP_INI_USER, PHP_INI_STAGE_RUNTIME);\n\t\t\t} else if (!STRCASECMP(header_line, \"Location\")) {\n\t\t\t\tif ((SG(sapi_headers).http_response_code < 300 ||\n\t\t\t\t\tSG(sapi_headers).http_response_code > 399) &&\n\t\t\t\t\tSG(sapi_headers).http_response_code != 201) {\n\t\t\t\t\t/* Return a Found Redirect if one is not already specified */\n\t\t\t\t\tif (http_response_code) { /* user specified redirect code */\n\t\t\t\t\t\tsapi_update_response_code(http_response_code TSRMLS_CC);\n\t\t\t\t\t} else if (SG(request_info).proto_num > 1000 && \n\t\t\t\t\t   SG(request_info).request_method && \n\t\t\t\t\t   strcmp(SG(request_info).request_method, \"HEAD\") &&\n\t\t\t\t\t   strcmp(SG(request_info).request_method, \"GET\")) {\n\t\t\t\t\t\tsapi_update_response_code(303 TSRMLS_CC);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsapi_update_response_code(302 TSRMLS_CC);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (!STRCASECMP(header_line, \"WWW-Authenticate\")) { /* HTTP Authentication */\n\t\t\t\tsapi_update_response_code(401 TSRMLS_CC); /* authentication-required */\n\t\t\t}\n\t\t\tif (sapi_header.header==header_line) {\n\t\t\t\t*colon_offset = ':';\n\t\t\t}\n\t\t}\n\t}\n\tif (http_response_code) {\n\t\tsapi_update_response_code(http_response_code TSRMLS_CC);\n\t}\n\tsapi_header_add_op(op, &sapi_header TSRMLS_CC);\n\treturn SUCCESS;\n}\n\n\nSAPI_API int sapi_send_headers(TSRMLS_D)\n{\n\tint retval;\n\tint ret = FAILURE;\n\n\tif (SG(headers_sent) || SG(request_info).no_headers || SG(callback_run)) {\n\t\treturn SUCCESS;\n\t}\n\n\t/* Success-oriented.  We set headers_sent to 1 here to avoid an infinite loop\n\t * in case of an error situation.\n\t */\n\tif (SG(sapi_headers).send_default_content_type && sapi_module.send_headers) {\n\t\tsapi_header_struct default_header;\n\t    uint len;\n\n\t\tSG(sapi_headers).mimetype = get_default_content_type(0, &len TSRMLS_CC);\n\t\tdefault_header.header_len = sizeof(\"Content-type: \") - 1 + len;\n\t\tdefault_header.header = emalloc(default_header.header_len + 1);\n\t\tmemcpy(default_header.header, \"Content-type: \", sizeof(\"Content-type: \") - 1);\n\t\tmemcpy(default_header.header + sizeof(\"Content-type: \") - 1, SG(sapi_headers).mimetype, len + 1);\n\t\tsapi_header_add_op(SAPI_HEADER_ADD, &default_header TSRMLS_CC);\n\t\tSG(sapi_headers).send_default_content_type = 0;\n\t}\n\n\tif (SG(callback_func) && !SG(callback_run)) {\n\t\tSG(callback_run) = 1;\n\t\tsapi_run_header_callback(TSRMLS_C);\n\t}\n\n\tSG(headers_sent) = 1;\n\n\tif (sapi_module.send_headers) {\n\t\tretval = sapi_module.send_headers(&SG(sapi_headers) TSRMLS_CC);\n\t} else {\n\t\tretval = SAPI_HEADER_DO_SEND;\n\t}\n\n\tswitch (retval) {\n\t\tcase SAPI_HEADER_SENT_SUCCESSFULLY:\n\t\t\tret = SUCCESS;\n\t\t\tbreak;\n\t\tcase SAPI_HEADER_DO_SEND: {\n\t\t\t\tsapi_header_struct http_status_line;\n\t\t\t\tchar buf[255];\n\n\t\t\t\tif (SG(sapi_headers).http_status_line) {\n\t\t\t\t\thttp_status_line.header = SG(sapi_headers).http_status_line;\n\t\t\t\t\thttp_status_line.header_len = strlen(SG(sapi_headers).http_status_line);\n\t\t\t\t} else {\n\t\t\t\t\thttp_status_line.header = buf;\n\t\t\t\t\thttp_status_line.header_len = slprintf(buf, sizeof(buf), \"HTTP/1.0 %d X\", SG(sapi_headers).http_response_code);\n\t\t\t\t}\n\t\t\t\tsapi_module.send_header(&http_status_line, SG(server_context) TSRMLS_CC);\n\t\t\t}\n\t\t\tzend_llist_apply_with_argument(&SG(sapi_headers).headers, (llist_apply_with_arg_func_t) sapi_module.send_header, SG(server_context) TSRMLS_CC);\n\t\t\tif(SG(sapi_headers).send_default_content_type) {\n\t\t\t\tsapi_header_struct default_header;\n\n\t\t\t\tsapi_get_default_content_type_header(&default_header TSRMLS_CC);\n\t\t\t\tsapi_module.send_header(&default_header, SG(server_context) TSRMLS_CC);\n\t\t\t\tsapi_free_header(&default_header);\n\t\t\t}\n\t\t\tsapi_module.send_header(NULL, SG(server_context) TSRMLS_CC);\n\t\t\tret = SUCCESS;\n\t\t\tbreak;\n\t\tcase SAPI_HEADER_SEND_FAILED:\n\t\t\tSG(headers_sent) = 0;\n\t\t\tret = FAILURE;\n\t\t\tbreak;\n\t}\n\n\tsapi_send_headers_free(TSRMLS_C);\n\n\treturn ret;\n}\n\n\nSAPI_API int sapi_register_post_entries(sapi_post_entry *post_entries TSRMLS_DC)\n{\n\tsapi_post_entry *p=post_entries;\n\n\twhile (p->content_type) {\n\t\tif (sapi_register_post_entry(p TSRMLS_CC) == FAILURE) {\n\t\t\treturn FAILURE;\n\t\t}\n\t\tp++;\n\t}\n\treturn SUCCESS;\n}\n\n\nSAPI_API int sapi_register_post_entry(sapi_post_entry *post_entry TSRMLS_DC)\n{\n\tif (SG(sapi_started) && EG(in_execution)) {\n\t\treturn FAILURE;\n\t}\n\treturn zend_hash_add(&SG(known_post_content_types),\n\t\t\tpost_entry->content_type, post_entry->content_type_len+1,\n\t\t\t(void *) post_entry, sizeof(sapi_post_entry), NULL);\n}\n\nSAPI_API void sapi_unregister_post_entry(sapi_post_entry *post_entry TSRMLS_DC)\n{\n\tif (SG(sapi_started) && EG(in_execution)) {\n\t\treturn;\n\t}\n\tzend_hash_del(&SG(known_post_content_types), post_entry->content_type,\n\t\t\tpost_entry->content_type_len+1);\n}\n\n\nSAPI_API int sapi_register_default_post_reader(void (*default_post_reader)(TSRMLS_D) TSRMLS_DC)\n{\n\tif (SG(sapi_started) && EG(in_execution)) {\n\t\treturn FAILURE;\n\t}\n\tsapi_module.default_post_reader = default_post_reader;\n\treturn SUCCESS;\n}\n\n\nSAPI_API int sapi_register_treat_data(void (*treat_data)(int arg, char *str, zval *destArray TSRMLS_DC) TSRMLS_DC)\n{\n\tif (SG(sapi_started) && EG(in_execution)) {\n\t\treturn FAILURE;\n\t}\n\tsapi_module.treat_data = treat_data;\n\treturn SUCCESS;\n}\n\nSAPI_API int sapi_register_input_filter(unsigned int (*input_filter)(int arg, char *var, char **val, unsigned int val_len, unsigned int *new_val_len TSRMLS_DC), unsigned int (*input_filter_init)(TSRMLS_D) TSRMLS_DC)\n{\n\tif (SG(sapi_started) && EG(in_execution)) {\n\t\treturn FAILURE;\n\t}\n\tsapi_module.input_filter = input_filter;\n\tsapi_module.input_filter_init = input_filter_init;\n\treturn SUCCESS;\n}\n\nSAPI_API int sapi_flush(TSRMLS_D)\n{\n\tif (sapi_module.flush) {\n\t\tsapi_module.flush(SG(server_context));\n\t\treturn SUCCESS;\n\t} else {\n\t\treturn FAILURE;\n\t}\n}\n\nSAPI_API struct stat *sapi_get_stat(TSRMLS_D)\n{\n\tif (sapi_module.get_stat) {\n\t\treturn sapi_module.get_stat(TSRMLS_C);\n\t} else {\n\t\tif (!SG(request_info).path_translated || (VCWD_STAT(SG(request_info).path_translated, &SG(global_stat)) == -1)) {\n\t\t\treturn NULL;\n\t\t}\n\t\treturn &SG(global_stat);\n\t}\n}\n\nSAPI_API char *sapi_getenv(char *name, size_t name_len TSRMLS_DC)\n{\n\tif (sapi_module.getenv) { \n\t\tchar *value, *tmp = sapi_module.getenv(name, name_len TSRMLS_CC);\n\t\tif (tmp) {\n\t\t\tvalue = estrdup(tmp);\n\t\t} else {\n\t\t\treturn NULL;\n\t\t}\n\t\tif (sapi_module.input_filter) {\n\t\t\tsapi_module.input_filter(PARSE_STRING, name, &value, strlen(value), NULL TSRMLS_CC);\n\t\t}\n\t\treturn value;\n\t}\n\treturn NULL;\n}\n\nSAPI_API int sapi_get_fd(int *fd TSRMLS_DC)\n{\n\tif (sapi_module.get_fd) {\n\t\treturn sapi_module.get_fd(fd TSRMLS_CC);\n\t} else {\n\t\treturn FAILURE;\n\t}\n}\n\nSAPI_API int sapi_force_http_10(TSRMLS_D)\n{\n\tif (sapi_module.force_http_10) {\n\t\treturn sapi_module.force_http_10(TSRMLS_C);\n\t} else {\n\t\treturn FAILURE;\n\t}\n}\n\n\nSAPI_API int sapi_get_target_uid(uid_t *obj TSRMLS_DC)\n{\n\tif (sapi_module.get_target_uid) {\n\t\treturn sapi_module.get_target_uid(obj TSRMLS_CC);\n\t} else {\n\t\treturn FAILURE;\n\t}\n}\n\nSAPI_API int sapi_get_target_gid(gid_t *obj TSRMLS_DC)\n{\n\tif (sapi_module.get_target_gid) {\n\t\treturn sapi_module.get_target_gid(obj TSRMLS_CC);\n\t} else {\n\t\treturn FAILURE;\n\t}\n}\n\nSAPI_API double sapi_get_request_time(TSRMLS_D)\n{\n\tif(SG(global_request_time)) return SG(global_request_time);\n\n\tif (sapi_module.get_request_time && SG(server_context)) {\n\t\tSG(global_request_time) = sapi_module.get_request_time(TSRMLS_C);\n\t} else {\n\t\tstruct timeval tp = {0};\n\t\tif (!gettimeofday(&tp, NULL)) {\n\t\t\tSG(global_request_time) = (double)(tp.tv_sec + tp.tv_usec / 1000000.00);\n\t\t} else {\n\t\t\tSG(global_request_time) = (double)time(0);\n\t\t}\n\t}\n\treturn SG(global_request_time);\n}\n\nSAPI_API void sapi_terminate_process(TSRMLS_D) {\n\tif (sapi_module.terminate_process) {\n\t\tsapi_module.terminate_process(TSRMLS_C);\n\t}\n}\n\n/*\n * Local variables:\n * tab-width: 4\n * c-basic-offset: 4\n * End:\n * vim600: sw=4 ts=4 fdm=marker\n * vim<600: sw=4 ts=4\n */\n", "code_before": "/*\n   +----------------------------------------------------------------------+\n   | Copyright (c) The PHP Group                                          |\n   +----------------------------------------------------------------------+\n   | This source file is subject to version 3.01 of the PHP license,      |\n   | that is bundled with this package in the file LICENSE, and is        |\n   | available through the world-wide-web at the following url:           |\n   | https://www.php.net/license/3_01.txt                                 |\n   | If you did not receive a copy of the PHP license and are unable to   |\n   | obtain it through the world-wide-web, please send a note to          |\n   | license@php.net so we can mail you a copy immediately.               |\n   +----------------------------------------------------------------------+\n   | Original design:  Shane Caraveo <shane@caraveo.com>                  |\n   | Authors: Andi Gutmans <andi@php.net>                                 |\n   |          Zeev Suraski <zeev@php.net>                                 |\n   +----------------------------------------------------------------------+\n*/\n\n#include <ctype.h>\n#include <sys/stat.h>\n#include <locale.h>\n\n#include \"php.h\"\n#include \"SAPI.h\"\n#include \"php_variables.h\"\n#include \"php_ini.h\"\n#ifdef ZTS\n#include \"TSRM.h\"\n#endif\n#ifdef HAVE_SYS_TIME_H\n#include <sys/time.h>\n#elif defined(PHP_WIN32)\n#include \"win32/time.h\"\n#endif\n\n#include \"rfc1867.h\"\n\n#include \"php_content_types.h\"\n\n#ifdef ZTS\nSAPI_API int sapi_globals_id;\nSAPI_API size_t sapi_globals_offset;\n#else\nsapi_globals_struct sapi_globals;\n#endif\n\nstatic void _type_dtor(zval *zv)\n{\n\tfree(Z_PTR_P(zv));\n}\n\nstatic void sapi_globals_ctor(sapi_globals_struct *sapi_globals)\n{\n\tmemset(sapi_globals, 0, sizeof(*sapi_globals));\n\tzend_hash_init(&sapi_globals->known_post_content_types, 8, NULL, _type_dtor, 1);\n\tphp_setup_sapi_content_types();\n}\n\nstatic void sapi_globals_dtor(sapi_globals_struct *sapi_globals)\n{\n\tzend_hash_destroy(&sapi_globals->known_post_content_types);\n}\n\n/* True globals (no need for thread safety) */\nSAPI_API sapi_module_struct sapi_module;\n\n\nSAPI_API void sapi_startup(sapi_module_struct *sf)\n{\n\tsf->ini_entries = NULL;\n\tsapi_module = *sf;\n\n#ifdef ZTS\n\tts_allocate_fast_id(&sapi_globals_id, &sapi_globals_offset, sizeof(sapi_globals_struct), (ts_allocate_ctor) sapi_globals_ctor, (ts_allocate_dtor) sapi_globals_dtor);\n# ifdef PHP_WIN32\n\t_configthreadlocale(_ENABLE_PER_THREAD_LOCALE);\n# endif\n#else\n\tsapi_globals_ctor(&sapi_globals);\n#endif\n\n#ifdef PHP_WIN32\n\ttsrm_win32_startup();\n#endif\n\n\treentrancy_startup();\n}\n\nSAPI_API void sapi_shutdown(void)\n{\n#ifdef ZTS\n\tts_free_id(sapi_globals_id);\n#else\n\tsapi_globals_dtor(&sapi_globals);\n#endif\n\n\treentrancy_shutdown();\n\n#ifdef PHP_WIN32\n\ttsrm_win32_shutdown();\n#endif\n}\n\n\nSAPI_API void sapi_free_header(sapi_header_struct *sapi_header)\n{\n\tefree(sapi_header->header);\n}\n\n/* {{{ call a header function */\nPHP_FUNCTION(header_register_callback)\n{\n\tzend_fcall_info fci;\n\tzend_fcall_info_cache fcc;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"f\", &fci, &fcc) == FAILURE) {\n\t\tRETURN_THROWS();\n\t}\n\n\tif (Z_TYPE(SG(callback_func)) != IS_UNDEF) {\n\t\tzval_ptr_dtor(&SG(callback_func));\n\t\tSG(fci_cache) = empty_fcall_info_cache;\n\t}\n\n\t/* Don't store callback if headers have already been sent:\n\t * It won't get used and we won't have a chance to release it. */\n\tif (!SG(headers_sent)) {\n\t\tZVAL_COPY(&SG(callback_func), &fci.function_name);\n\t}\n\n\tRETURN_TRUE;\n}\n/* }}} */\n\nstatic void sapi_run_header_callback(zval *callback)\n{\n\tint   error;\n\tzend_fcall_info fci;\n\tchar *callback_error = NULL;\n\tzval retval;\n\n\tif (zend_fcall_info_init(callback, 0, &fci, &SG(fci_cache), NULL, &callback_error) == SUCCESS) {\n\t\tfci.retval = &retval;\n\n\t\terror = zend_call_function(&fci, &SG(fci_cache));\n\t\tif (error == FAILURE) {\n\t\t\tgoto callback_failed;\n\t\t} else {\n\t\t\tzval_ptr_dtor(&retval);\n\t\t}\n\t} else {\ncallback_failed:\n\t\tphp_error_docref(NULL, E_WARNING, \"Could not call the sapi_header_callback\");\n\t}\n\n\tif (callback_error) {\n\t\tefree(callback_error);\n\t}\n}\n\nSAPI_API void sapi_handle_post(void *arg)\n{\n\tif (SG(request_info).post_entry && SG(request_info).content_type_dup) {\n\t\tSG(request_info).post_entry->post_handler(SG(request_info).content_type_dup, arg);\n\t\tefree(SG(request_info).content_type_dup);\n\t\tSG(request_info).content_type_dup = NULL;\n\t}\n}\n\nSAPI_API void sapi_read_post_data(void)\n{\n\tsapi_post_entry *post_entry;\n\tuint32_t content_type_length = (uint32_t)strlen(SG(request_info).content_type);\n\tchar *content_type = estrndup(SG(request_info).content_type, content_type_length);\n\tchar *p;\n\tchar oldchar=0;\n\tvoid (*post_reader_func)(void) = NULL;\n\n\n\t/* dedicated implementation for increased performance:\n\t * - Make the content type lowercase\n\t * - Trim descriptive data, stay with the content-type only\n\t */\n\tfor (p = content_type; p < content_type + content_type_length; p++) {\n\t\tswitch (*p) {\n\t\t\tcase ';':\n\t\t\tcase ',':\n\t\t\tcase ' ':\n\t\t\t\tcontent_type_length = p-content_type;\n\t\t\t\toldchar = *p;\n\t\t\t\t*p = 0;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t*p = tolower(*p);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* now try to find an appropriate POST content handler */\n\tif ((post_entry = zend_hash_str_find_ptr(&SG(known_post_content_types), content_type,\n\t\t\tcontent_type_length)) != NULL) {\n\t\t/* found one, register it for use */\n\t\tSG(request_info).post_entry = post_entry;\n\t\tpost_reader_func = post_entry->post_reader;\n\t} else {\n\t\t/* fallback */\n\t\tSG(request_info).post_entry = NULL;\n\t\tif (UNEXPECTED(!sapi_module.default_post_reader)) {\n\t\t\t/* this should not happen as there should always be a default_post_reader */\n\t\t\tSG(request_info).content_type_dup = NULL;\n\t\t\tsapi_module.sapi_error(E_WARNING, \"Unsupported content type:  '%s'\", content_type);\n\t\t\tefree(content_type);\n\t\t\treturn;\n\t\t}\n\t}\n\tif (oldchar) {\n\t\t*(p-1) = oldchar;\n\t}\n\n\t/* the content_type_dup is not set at this stage so no need to try to free it first */\n\tSG(request_info).content_type_dup = content_type;\n\n\tif(post_reader_func) {\n\t\tpost_reader_func();\n\t}\n\n\tif(sapi_module.default_post_reader) {\n\t\tsapi_module.default_post_reader();\n\t}\n}\n\nSAPI_API size_t sapi_read_post_block(char *buffer, size_t buflen)\n{\n\tsize_t read_bytes;\n\n\tif (!sapi_module.read_post) {\n\t\treturn 0;\n\t}\n\n\tread_bytes = sapi_module.read_post(buffer, buflen);\n\n\tif (read_bytes > 0) {\n\t\t/* gogo */\n\t\tSG(read_post_bytes) += read_bytes;\n\t}\n\tif (read_bytes < buflen) {\n\t\t/* done */\n\t\tSG(post_read) = 1;\n\t}\n\n\treturn read_bytes;\n}\n\nSAPI_API SAPI_POST_READER_FUNC(sapi_read_standard_form_data)\n{\n\tzend_long post_max_size = REQUEST_PARSE_BODY_OPTION_GET(post_max_size, SG(post_max_size));\n\n\tif (post_max_size > 0 && SG(request_info).content_length > post_max_size) {\n\t\tphp_error_docref(NULL, E_WARNING, \"POST Content-Length of \" ZEND_LONG_FMT \" bytes exceeds the limit of \" ZEND_LONG_FMT \" bytes\",\n\t\t\t\t\tSG(request_info).content_length, post_max_size);\n\t\treturn;\n\t}\n\n\n\tSG(request_info).request_body = php_stream_temp_create_ex(TEMP_STREAM_DEFAULT, SAPI_POST_BLOCK_SIZE, PG(upload_tmp_dir));\n\n\tif (sapi_module.read_post) {\n\t\tsize_t read_bytes;\n\n\t\tfor (;;) {\n\t\t\tchar buffer[SAPI_POST_BLOCK_SIZE];\n\n\t\t\tread_bytes = sapi_read_post_block(buffer, SAPI_POST_BLOCK_SIZE);\n\n\t\t\tif (read_bytes > 0) {\n\t\t\t\tif (php_stream_write(SG(request_info).request_body, buffer, read_bytes) != read_bytes) {\n\t\t\t\t\t/* if parts of the stream can't be written, purge it completely */\n\t\t\t\t\tphp_stream_truncate_set_size(SG(request_info).request_body, 0);\n\t\t\t\t\tphp_error_docref(NULL, E_WARNING, \"POST data can't be buffered; all data discarded\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (post_max_size > 0 && SG(read_post_bytes) > post_max_size) {\n\t\t\t\tphp_error_docref(NULL, E_WARNING, \"Actual POST length does not match Content-Length, and exceeds \" ZEND_LONG_FMT \" bytes\", post_max_size);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (read_bytes < SAPI_POST_BLOCK_SIZE) {\n\t\t\t\t/* done */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tphp_stream_rewind(SG(request_info).request_body);\n\t}\n}\n\n\nstatic inline char *get_default_content_type(uint32_t prefix_len, uint32_t *len)\n{\n\tchar *mimetype, *charset, *content_type;\n\tuint32_t mimetype_len, charset_len;\n\n\tif (SG(default_mimetype)) {\n\t\tmimetype = SG(default_mimetype);\n\t\tmimetype_len = (uint32_t)strlen(SG(default_mimetype));\n\t} else {\n\t\tmimetype = SAPI_DEFAULT_MIMETYPE;\n\t\tmimetype_len = sizeof(SAPI_DEFAULT_MIMETYPE) - 1;\n\t}\n\tif (SG(default_charset)) {\n\t\tcharset = SG(default_charset);\n\t\tcharset_len = (uint32_t)strlen(SG(default_charset));\n\t} else {\n\t\tcharset = SAPI_DEFAULT_CHARSET;\n\t\tcharset_len = sizeof(SAPI_DEFAULT_CHARSET) - 1;\n\t}\n\n\tif (*charset && strncasecmp(mimetype, \"text/\", 5) == 0) {\n\t\tchar *p;\n\n\t\t*len = prefix_len + mimetype_len + sizeof(\"; charset=\") - 1 + charset_len;\n\t\tcontent_type = (char*)emalloc(*len + 1);\n\t\tp = content_type + prefix_len;\n\t\tp = zend_mempcpy(p, mimetype, mimetype_len);\n\t\tp = zend_mempcpy(p, \"; charset=\", sizeof(\"; charset=\") - 1);\n\t\tmemcpy(p, charset, charset_len + 1);\n\t} else {\n\t\t*len = prefix_len + mimetype_len;\n\t\tcontent_type = (char*)emalloc(*len + 1);\n\t\tmemcpy(content_type + prefix_len, mimetype, mimetype_len + 1);\n\t}\n\treturn content_type;\n}\n\n\nSAPI_API char *sapi_get_default_content_type(void)\n{\n\tuint32_t len;\n\n\treturn get_default_content_type(0, &len);\n}\n\n\nSAPI_API void sapi_get_default_content_type_header(sapi_header_struct *default_header)\n{\n\tuint32_t len;\n\n\tdefault_header->header = get_default_content_type(sizeof(\"Content-type: \")-1, &len);\n\tdefault_header->header_len = len;\n\tmemcpy(default_header->header, \"Content-type: \", sizeof(\"Content-type: \") - 1);\n}\n\n/*\n * Add charset on content-type header if the MIME type starts with\n * \"text/\", the default_charset directive is not empty and\n * there is not already a charset option in there.\n *\n * If \"mimetype\" is non-NULL, it should point to a pointer allocated\n * with emalloc(). If a charset is added, the string will be\n * re-allocated and the new length is returned.  If mimetype is\n * unchanged, 0 is returned.\n *\n */\nSAPI_API size_t sapi_apply_default_charset(char **mimetype, size_t len)\n{\n\tchar *charset, *newtype;\n\tsize_t newlen;\n\tcharset = SG(default_charset) ? SG(default_charset) : SAPI_DEFAULT_CHARSET;\n\n\tif (*mimetype != NULL) {\n\t\tif (*charset && strncmp(*mimetype, \"text/\", 5) == 0 && strstr(*mimetype, \"charset=\") == NULL) {\n\t\t\tnewlen = len + (sizeof(\";charset=\")-1) + strlen(charset);\n\t\t\tnewtype = emalloc(newlen + 1);\n\t \t\tPHP_STRLCPY(newtype, *mimetype, newlen + 1, len);\n\t\t\tstrlcat(newtype, \";charset=\", newlen + 1);\n\t\t\tstrlcat(newtype, charset, newlen + 1);\n\t\t\tefree(*mimetype);\n\t\t\t*mimetype = newtype;\n\t\t\treturn newlen;\n\t\t}\n\t}\n\treturn 0;\n}\n\nSAPI_API void sapi_activate_headers_only(void)\n{\n\tif (SG(request_info).headers_read == 1)\n\t\treturn;\n\tSG(request_info).headers_read = 1;\n\tzend_llist_init(&SG(sapi_headers).headers, sizeof(sapi_header_struct),\n\t\t\t(void (*)(void *)) sapi_free_header, 0);\n\tSG(sapi_headers).send_default_content_type = 1;\n\n\t/* SG(sapi_headers).http_response_code = 200; */\n\tSG(sapi_headers).http_status_line = NULL;\n\tSG(sapi_headers).mimetype = NULL;\n\tSG(read_post_bytes) = 0;\n\tSG(request_info).request_body = NULL;\n\tSG(request_info).current_user = NULL;\n\tSG(request_info).current_user_length = 0;\n\tSG(request_info).no_headers = 0;\n\tSG(request_info).post_entry = NULL;\n\tSG(global_request_time) = 0;\n\n\t/*\n\t * It's possible to override this general case in the activate() callback,\n\t * if necessary.\n\t */\n\tif (SG(request_info).request_method && !strcmp(SG(request_info).request_method, \"HEAD\")) {\n\t\tSG(request_info).headers_only = 1;\n\t} else {\n\t\tSG(request_info).headers_only = 0;\n\t}\n\tif (SG(server_context)) {\n\t\tSG(request_info).cookie_data = sapi_module.read_cookies();\n\t\tif (sapi_module.activate) {\n\t\t\tsapi_module.activate();\n\t\t}\n\t}\n\tif (sapi_module.input_filter_init ) {\n\t\tsapi_module.input_filter_init();\n\t}\n}\n\n/*\n * Called from php_request_startup() for every request.\n */\n\nSAPI_API void sapi_activate(void)\n{\n\tzend_llist_init(&SG(sapi_headers).headers, sizeof(sapi_header_struct), (void (*)(void *)) sapi_free_header, 0);\n\tSG(sapi_headers).send_default_content_type = 1;\n\n\t/*\n\tSG(sapi_headers).http_response_code = 200;\n\t*/\n\tSG(sapi_headers).http_status_line = NULL;\n\tSG(sapi_headers).mimetype = NULL;\n\tSG(headers_sent) = 0;\n\tZVAL_UNDEF(&SG(callback_func));\n\tSG(read_post_bytes) = 0;\n\tSG(request_info).request_body = NULL;\n\tSG(request_info).current_user = NULL;\n\tSG(request_info).current_user_length = 0;\n\tSG(request_info).no_headers = 0;\n\tSG(request_info).post_entry = NULL;\n\tSG(request_info).proto_num = 1000; /* Default to HTTP 1.0 */\n\tSG(global_request_time) = 0;\n\tSG(post_read) = 0;\n\t/* It's possible to override this general case in the activate() callback, if necessary. */\n\tif (SG(request_info).request_method && !strcmp(SG(request_info).request_method, \"HEAD\")) {\n\t\tSG(request_info).headers_only = 1;\n\t} else {\n\t\tSG(request_info).headers_only = 0;\n\t}\n\tSG(rfc1867_uploaded_files) = NULL;\n\tSG(request_parse_body_context).throw_exceptions = false;\n\tmemset(&SG(request_parse_body_context).options_cache, 0, sizeof(SG(request_parse_body_context).options_cache));\n\n\t/* Handle request method */\n\tif (SG(server_context)) {\n\t\tif (PG(enable_post_data_reading)\n\t\t&& \tSG(request_info).content_type\n\t\t&&  SG(request_info).request_method\n\t\t&& !strcmp(SG(request_info).request_method, \"POST\")) {\n\t\t\t/* HTTP POST may contain form data to be processed into variables\n\t\t\t * depending on given content type */\n\t\t\tsapi_read_post_data();\n\t\t} else {\n\t\t\tSG(request_info).content_type_dup = NULL;\n\t\t}\n\n\t\t/* Cookies */\n\t\tSG(request_info).cookie_data = sapi_module.read_cookies();\n\t}\n\tif (sapi_module.activate) {\n\t\tsapi_module.activate();\n\t}\n\tif (sapi_module.input_filter_init) {\n\t\tsapi_module.input_filter_init();\n\t}\n}\n\n\nstatic void sapi_send_headers_free(void)\n{\n\tif (SG(sapi_headers).http_status_line) {\n\t\tefree(SG(sapi_headers).http_status_line);\n\t\tSG(sapi_headers).http_status_line = NULL;\n\t}\n}\n\nSAPI_API void sapi_deactivate_module(void)\n{\n\tzend_llist_destroy(&SG(sapi_headers).headers);\n\tif (SG(request_info).request_body) {\n\t\tSG(request_info).request_body = NULL;\n\t} else if (SG(server_context)) {\n\t\tif (!SG(post_read)) {\n\t\t\t/* make sure we've consumed all request input data */\n\t\t\tchar dummy[SAPI_POST_BLOCK_SIZE];\n\t\t\tsize_t read_bytes;\n\n\t\t\tdo {\n\t\t\t\tread_bytes = sapi_read_post_block(dummy, SAPI_POST_BLOCK_SIZE);\n\t\t\t} while (SAPI_POST_BLOCK_SIZE == read_bytes);\n\t\t}\n\t}\n\tif (SG(request_info).auth_user) {\n\t\tefree(SG(request_info).auth_user);\n\t\tSG(request_info).auth_user = NULL;\n\t}\n\tif (SG(request_info).auth_password) {\n\t\tefree(SG(request_info).auth_password);\n\t\tSG(request_info).auth_password = NULL;\n\t}\n\tif (SG(request_info).auth_digest) {\n\t\tefree(SG(request_info).auth_digest);\n\t\tSG(request_info).auth_digest = NULL;\n\t}\n\tif (SG(request_info).content_type_dup) {\n\t\tefree(SG(request_info).content_type_dup);\n\t}\n\tif (SG(request_info).current_user) {\n\t\tefree(SG(request_info).current_user);\n\t}\n\tif (sapi_module.deactivate) {\n\t\tsapi_module.deactivate();\n\t}\n}\n\nSAPI_API void sapi_deactivate_destroy(void)\n{\n\tif (SG(rfc1867_uploaded_files)) {\n\t\tdestroy_uploaded_files_hash();\n\t}\n\tif (SG(sapi_headers).mimetype) {\n\t\tefree(SG(sapi_headers).mimetype);\n\t\tSG(sapi_headers).mimetype = NULL;\n\t}\n\tsapi_send_headers_free();\n\tSG(sapi_started) = 0;\n\tSG(headers_sent) = 0;\n\tSG(request_info).headers_read = 0;\n\tSG(global_request_time) = 0;\n}\n\nSAPI_API void sapi_deactivate(void)\n{\n\tsapi_deactivate_module();\n\tsapi_deactivate_destroy();\n}\n\n\nSAPI_API void sapi_initialize_empty_request(void)\n{\n\tSG(server_context) = NULL;\n\tSG(request_info).request_method = NULL;\n\tSG(request_info).auth_digest = SG(request_info).auth_user = SG(request_info).auth_password = NULL;\n\tSG(request_info).content_type_dup = NULL;\n}\n\n\nstatic int sapi_extract_response_code(const char *header_line)\n{\n\tint code = 200;\n\tconst char *ptr;\n\n\tfor (ptr = header_line; *ptr; ptr++) {\n\t\tif (*ptr == ' ' && *(ptr + 1) != ' ') {\n\t\t\tcode = atoi(ptr + 1);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn code;\n}\n\n\nstatic void sapi_update_response_code(int ncode)\n{\n\t/* if the status code did not change, we do not want\n\t   to change the status line, and no need to change the code */\n\tif (SG(sapi_headers).http_response_code == ncode) {\n\t\treturn;\n\t}\n\n\tif (SG(sapi_headers).http_status_line) {\n\t\tefree(SG(sapi_headers).http_status_line);\n\t\tSG(sapi_headers).http_status_line = NULL;\n\t}\n\tSG(sapi_headers).http_response_code = ncode;\n}\n\n/*\n * since zend_llist_del_element only removes one matched item once,\n * we should remove them manually\n */\nstatic void sapi_remove_header(zend_llist *l, char *name, size_t len, size_t header_len)\n{\n\tsapi_header_struct *header;\n\tzend_llist_element *next;\n\tzend_llist_element *current=l->head;\n\n\twhile (current) {\n\t\theader = (sapi_header_struct *)(current->data);\n\t\tnext = current->next;\n\t\tif (header->header_len > header_len\n\t\t\t\t&& (header->header[header_len] == ':' || len > header_len)\n\t\t\t\t&& !strncasecmp(header->header, name, len)) {\n\t\t\tif (current->prev) {\n\t\t\t\tcurrent->prev->next = next;\n\t\t\t} else {\n\t\t\t\tl->head = next;\n\t\t\t}\n\t\t\tif (next) {\n\t\t\t\tnext->prev = current->prev;\n\t\t\t} else {\n\t\t\t\tl->tail = current->prev;\n\t\t\t}\n\t\t\tsapi_free_header(header);\n\t\t\tefree(current);\n\t\t\t--l->count;\n\t\t}\n\t\tcurrent = next;\n\t}\n}\n\nSAPI_API int sapi_add_header_ex(const char *header_line, size_t header_line_len, bool duplicate, bool replace)\n{\n\tsapi_header_line ctr = {0};\n\tint r;\n\n\tctr.line = header_line;\n\tctr.line_len = header_line_len;\n\n\tr = sapi_header_op(replace ? SAPI_HEADER_REPLACE : SAPI_HEADER_ADD,\n\t\t\t&ctr);\n\n\tif (!duplicate)\n\t\tefree((void *) header_line);\n\n\treturn r;\n}\n\nstatic void sapi_header_add_op(sapi_header_op_enum op, sapi_header_struct *sapi_header)\n{\n\tif (!sapi_module.header_handler ||\n\t\t(SAPI_HEADER_ADD & sapi_module.header_handler(sapi_header, op, &SG(sapi_headers)))) {\n\t\tif (op == SAPI_HEADER_REPLACE) {\n\t\t\tchar *colon_offset = strchr(sapi_header->header, ':');\n\n\t\t\tif (colon_offset) {\n\t\t\t\tchar sav = *colon_offset;\n\n\t\t\t\t*colon_offset = 0;\n\t\t\t\tsapi_remove_header(&SG(sapi_headers).headers, sapi_header->header, strlen(sapi_header->header), 0);\n\t\t\t\t*colon_offset = sav;\n\t\t\t}\n\t\t}\n\t\tzend_llist_add_element(&SG(sapi_headers).headers, (void *) sapi_header);\n\t} else {\n\t\tsapi_free_header(sapi_header);\n\t}\n}\n\nSAPI_API int sapi_header_op(sapi_header_op_enum op, void *arg)\n{\n\tsapi_header_struct sapi_header;\n\tchar *colon_offset;\n\tchar *header_line;\n\tsize_t header_line_len, header_len;\n\tint http_response_code;\n\n\tif (SG(headers_sent) && !SG(request_info).no_headers) {\n\t\tconst char *output_start_filename = php_output_get_start_filename();\n\t\tint output_start_lineno = php_output_get_start_lineno();\n\n\t\tif (output_start_filename) {\n\t\t\tsapi_module.sapi_error(E_WARNING, \"Cannot modify header information - headers already sent by (output started at %s:%d)\",\n\t\t\t\toutput_start_filename, output_start_lineno);\n\t\t} else {\n\t\t\tsapi_module.sapi_error(E_WARNING, \"Cannot modify header information - headers already sent\");\n\t\t}\n\t\treturn FAILURE;\n\t}\n\n\tswitch (op) {\n\t\tcase SAPI_HEADER_SET_STATUS:\n\t\t\tsapi_update_response_code((int)(intptr_t) arg);\n\t\t\treturn SUCCESS;\n\n\t\tcase SAPI_HEADER_ADD:\n\t\tcase SAPI_HEADER_REPLACE:\n\t\tcase SAPI_HEADER_DELETE_PREFIX:\n\t\tcase SAPI_HEADER_DELETE: {\n\t\t\t\tsapi_header_line *p = arg;\n\n\t\t\t\tif (!p->line || !p->line_len) {\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\t\t\t\theader_line = estrndup(p->line, p->line_len);\n\t\t\t\theader_line_len = p->line_len;\n\t\t\t\tif (op == SAPI_HEADER_DELETE_PREFIX) {\n\t\t\t\t\theader_len = p->header_len;\n\t\t\t\t\thttp_response_code = 0;\n\t\t\t\t} else {\n\t\t\t\t\theader_len = 0;\n\t\t\t\t\thttp_response_code = p->response_code;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tcase SAPI_HEADER_DELETE_ALL:\n\t\t\tif (sapi_module.header_handler) {\n\t\t\t\tsapi_module.header_handler(&sapi_header, op, &SG(sapi_headers));\n\t\t\t}\n\t\t\tzend_llist_clean(&SG(sapi_headers).headers);\n\t\t\treturn SUCCESS;\n\n\t\tdefault:\n\t\t\treturn FAILURE;\n\t}\n\n\t/* cut off trailing spaces, linefeeds and carriage-returns */\n\tif (header_line_len && isspace(header_line[header_line_len-1])) {\n\t\tdo {\n\t\t\theader_line_len--;\n\t\t} while(header_line_len && isspace(header_line[header_line_len-1]));\n\t\theader_line[header_line_len]='\\0';\n\t}\n\n\tif (op == SAPI_HEADER_DELETE || op == SAPI_HEADER_DELETE_PREFIX) {\n\t\tif (op == SAPI_HEADER_DELETE && strchr(header_line, ':')) {\n\t\t\tefree(header_line);\n\t\t\tsapi_module.sapi_error(E_WARNING, \"Header to delete may not contain colon.\");\n\t\t\treturn FAILURE;\n\t\t}\n\t\tif (sapi_module.header_handler) {\n\t\t\tsapi_header.header = header_line;\n\t\t\tsapi_header.header_len = header_line_len;\n\t\t\tsapi_module.header_handler(&sapi_header, op, &SG(sapi_headers));\n\t\t}\n\t\tsapi_remove_header(&SG(sapi_headers).headers, header_line, header_line_len, header_len);\n\t\tefree(header_line);\n\t\treturn SUCCESS;\n\t} else {\n\t\t/* new line/NUL character safety check */\n\t\tuint32_t i;\n\t\tfor (i = 0; i < header_line_len; i++) {\n\t\t\t/* RFC 7230 ch. 3.2.4 deprecates folding support */\n\t\t\tif (header_line[i] == '\\n' || header_line[i] == '\\r') {\n\t\t\t\tefree(header_line);\n\t\t\t\tsapi_module.sapi_error(E_WARNING, \"Header may not contain \"\n\t\t\t\t\t\t\"more than a single header, new line detected\");\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t\tif (header_line[i] == '\\0') {\n\t\t\t\tefree(header_line);\n\t\t\t\tsapi_module.sapi_error(E_WARNING, \"Header may not contain NUL bytes\");\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t}\n\t}\n\n\tsapi_header.header = header_line;\n\tsapi_header.header_len = header_line_len;\n\n\t/* Check the header for a few cases that we have special support for in SAPI */\n\tif (header_line_len>=5\n\t\t&& !strncasecmp(header_line, \"HTTP/\", 5)) {\n\t\t/* filter out the response code */\n\t\tsapi_update_response_code(sapi_extract_response_code(header_line));\n\t\t/* sapi_update_response_code doesn't free the status line if the code didn't change */\n\t\tif (SG(sapi_headers).http_status_line) {\n\t\t\tefree(SG(sapi_headers).http_status_line);\n\t\t}\n\t\tSG(sapi_headers).http_status_line = header_line;\n\t\treturn SUCCESS;\n\t} else {\n\t\tcolon_offset = strchr(header_line, ':');\n\t\tif (colon_offset) {\n\t\t\t*colon_offset = 0;\n\t\t\tif (!strcasecmp(header_line, \"Content-Type\")) {\n\t\t\t\tchar *ptr = colon_offset+1, *mimetype = NULL, *newheader;\n\t\t\t\tsize_t len = header_line_len - (ptr - header_line), newlen;\n\t\t\t\twhile (*ptr == ' ') {\n\t\t\t\t\tptr++;\n\t\t\t\t\tlen--;\n\t\t\t\t}\n\n\t\t\t\tmimetype = estrdup(ptr);\n\t\t\t\tnewlen = sapi_apply_default_charset(&mimetype, len);\n\t\t\t\tif (!SG(sapi_headers).mimetype){\n\t\t\t\t\tSG(sapi_headers).mimetype = estrdup(mimetype);\n\t\t\t\t}\n\n\t\t\t\tif (newlen != 0) {\n\t\t\t\t\tnewlen += sizeof(\"Content-type: \");\n\t\t\t\t\tnewheader = emalloc(newlen);\n\t\t\t\t\tPHP_STRLCPY(newheader, \"Content-type: \", newlen, sizeof(\"Content-type: \")-1);\n\t\t\t\t\tstrlcat(newheader, mimetype, newlen);\n\t\t\t\t\tsapi_header.header = newheader;\n\t\t\t\t\tsapi_header.header_len = (uint32_t)(newlen - 1);\n\t\t\t\t\tefree(header_line);\n\t\t\t\t}\n\t\t\t\tefree(mimetype);\n\t\t\t\tSG(sapi_headers).send_default_content_type = 0;\n\t\t\t} else if (!strcasecmp(header_line, \"Content-Length\")) {\n\t\t\t\t/* Script is setting Content-length. The script cannot reasonably\n\t\t\t\t * know the size of the message body after compression, so it's best\n\t\t\t\t * to disable compression altogether. This contributes to making scripts\n\t\t\t\t * portable between setups that have and don't have zlib compression\n\t\t\t\t * enabled globally. See req #44164 */\n\t\t\t\tzend_string *key = ZSTR_INIT_LITERAL(\"zlib.output_compression\", 0);\n\t\t\t\tzend_alter_ini_entry_chars(key,\n\t\t\t\t\t\"0\", sizeof(\"0\") - 1, PHP_INI_USER, PHP_INI_STAGE_RUNTIME);\n\t\t\t\tzend_string_release_ex(key, 0);\n\t\t\t} else if (!strcasecmp(header_line, \"Location\")) {\n\t\t\t\tif ((SG(sapi_headers).http_response_code < 300 ||\n\t\t\t\t\tSG(sapi_headers).http_response_code > 399) &&\n\t\t\t\t\tSG(sapi_headers).http_response_code != 201) {\n\t\t\t\t\t/* Return a Found Redirect if one is not already specified */\n\t\t\t\t\tif (http_response_code) { /* user specified redirect code */\n\t\t\t\t\t\tsapi_update_response_code(http_response_code);\n\t\t\t\t\t} else if (SG(request_info).proto_num > 1000 &&\n\t\t\t\t\t   SG(request_info).request_method &&\n\t\t\t\t\t   strcmp(SG(request_info).request_method, \"HEAD\") &&\n\t\t\t\t\t   strcmp(SG(request_info).request_method, \"GET\")) {\n\t\t\t\t\t\tsapi_update_response_code(303);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsapi_update_response_code(302);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (!strcasecmp(header_line, \"WWW-Authenticate\")) { /* HTTP Authentication */\n\t\t\t\tsapi_update_response_code(401); /* authentication-required */\n\t\t\t}\n\t\t\tif (sapi_header.header==header_line) {\n\t\t\t\t*colon_offset = ':';\n\t\t\t}\n\t\t}\n\t}\n\tif (http_response_code) {\n\t\tsapi_update_response_code(http_response_code);\n\t}\n\tsapi_header_add_op(op, &sapi_header);\n\treturn SUCCESS;\n}\n\n\nSAPI_API int sapi_send_headers(void)\n{\n\tint retval;\n\tint ret = FAILURE;\n\n\tif (SG(headers_sent) || SG(request_info).no_headers) {\n\t\treturn SUCCESS;\n\t}\n\n\t/* Success-oriented. We set headers_sent to 1 here to avoid an infinite loop\n\t * in case of an error situation.\n\t */\n\tif (SG(sapi_headers).send_default_content_type && sapi_module.send_headers) {\n\t    uint32_t len = 0;\n\t\tchar *default_mimetype = get_default_content_type(0, &len);\n\n\t\tif (default_mimetype && len) {\n\t\t\tsapi_header_struct default_header;\n\n\t\t\tSG(sapi_headers).mimetype = default_mimetype;\n\n\t\t\tdefault_header.header_len = sizeof(\"Content-type: \") - 1 + len;\n\t\t\tdefault_header.header = emalloc(default_header.header_len + 1);\n\n\t\t\tmemcpy(default_header.header, \"Content-type: \", sizeof(\"Content-type: \") - 1);\n\t\t\tmemcpy(default_header.header + sizeof(\"Content-type: \") - 1, SG(sapi_headers).mimetype, len + 1);\n\n\t\t\tsapi_header_add_op(SAPI_HEADER_ADD, &default_header);\n\t\t} else {\n\t\t\tefree(default_mimetype);\n\t\t}\n\t\tSG(sapi_headers).send_default_content_type = 0;\n\t}\n\n\tif (Z_TYPE(SG(callback_func)) != IS_UNDEF) {\n\t\tzval cb;\n\t\tZVAL_COPY_VALUE(&cb, &SG(callback_func));\n\t\tZVAL_UNDEF(&SG(callback_func));\n\t\tsapi_run_header_callback(&cb);\n\t\tzval_ptr_dtor(&cb);\n\t}\n\n\tSG(headers_sent) = 1;\n\n\tif (sapi_module.send_headers) {\n\t\tretval = sapi_module.send_headers(&SG(sapi_headers));\n\t} else {\n\t\tretval = SAPI_HEADER_DO_SEND;\n\t}\n\n\tswitch (retval) {\n\t\tcase SAPI_HEADER_SENT_SUCCESSFULLY:\n\t\t\tret = SUCCESS;\n\t\t\tbreak;\n\t\tcase SAPI_HEADER_DO_SEND: {\n\t\t\t\tsapi_header_struct http_status_line;\n\t\t\t\tchar buf[255];\n\n\t\t\t\tif (SG(sapi_headers).http_status_line) {\n\t\t\t\t\thttp_status_line.header = SG(sapi_headers).http_status_line;\n\t\t\t\t\thttp_status_line.header_len = (uint32_t)strlen(SG(sapi_headers).http_status_line);\n\t\t\t\t} else {\n\t\t\t\t\thttp_status_line.header = buf;\n\t\t\t\t\thttp_status_line.header_len = slprintf(buf, sizeof(buf), \"HTTP/1.0 %d X\", SG(sapi_headers).http_response_code);\n\t\t\t\t}\n\t\t\t\tsapi_module.send_header(&http_status_line, SG(server_context));\n\t\t\t}\n\t\t\tzend_llist_apply_with_argument(&SG(sapi_headers).headers, (llist_apply_with_arg_func_t) sapi_module.send_header, SG(server_context));\n\t\t\tif(SG(sapi_headers).send_default_content_type) {\n\t\t\t\tsapi_header_struct default_header;\n\n\t\t\t\tsapi_get_default_content_type_header(&default_header);\n\t\t\t\tsapi_module.send_header(&default_header, SG(server_context));\n\t\t\t\tsapi_free_header(&default_header);\n\t\t\t}\n\t\t\tsapi_module.send_header(NULL, SG(server_context));\n\t\t\tret = SUCCESS;\n\t\t\tbreak;\n\t\tcase SAPI_HEADER_SEND_FAILED:\n\t\t\tSG(headers_sent) = 0;\n\t\t\tret = FAILURE;\n\t\t\tbreak;\n\t}\n\n\tsapi_send_headers_free();\n\n\treturn ret;\n}\n\n\nSAPI_API int sapi_register_post_entries(const sapi_post_entry *post_entries)\n{\n\tconst sapi_post_entry *p=post_entries;\n\n\twhile (p->content_type) {\n\t\tif (sapi_register_post_entry(p) == FAILURE) {\n\t\t\treturn FAILURE;\n\t\t}\n\t\tp++;\n\t}\n\treturn SUCCESS;\n}\n\n\nSAPI_API int sapi_register_post_entry(const sapi_post_entry *post_entry)\n{\n\tint ret;\n\tzend_string *key;\n\tif (SG(sapi_started) && EG(current_execute_data)) {\n\t\treturn FAILURE;\n\t}\n\tkey = zend_string_init(post_entry->content_type, post_entry->content_type_len, 1);\n\tGC_MAKE_PERSISTENT_LOCAL(key);\n\tret = zend_hash_add_mem(&SG(known_post_content_types), key,\n\t\t\t(void *) post_entry, sizeof(sapi_post_entry)) ? SUCCESS : FAILURE;\n\tzend_string_release_ex(key, 1);\n\treturn ret;\n}\n\nSAPI_API void sapi_unregister_post_entry(const sapi_post_entry *post_entry)\n{\n\tif (SG(sapi_started) && EG(current_execute_data)) {\n\t\treturn;\n\t}\n\tzend_hash_str_del(&SG(known_post_content_types), post_entry->content_type,\n\t\t\tpost_entry->content_type_len);\n}\n\n\nSAPI_API int sapi_register_default_post_reader(void (*default_post_reader)(void))\n{\n\tif (SG(sapi_started) && EG(current_execute_data)) {\n\t\treturn FAILURE;\n\t}\n\tsapi_module.default_post_reader = default_post_reader;\n\treturn SUCCESS;\n}\n\n\nSAPI_API int sapi_register_treat_data(void (*treat_data)(int arg, char *str, zval *destArray))\n{\n\tif (SG(sapi_started) && EG(current_execute_data)) {\n\t\treturn FAILURE;\n\t}\n\tsapi_module.treat_data = treat_data;\n\treturn SUCCESS;\n}\n\nSAPI_API int sapi_register_input_filter(unsigned int (*input_filter)(int arg, const char *var, char **val, size_t val_len, size_t *new_val_len), unsigned int (*input_filter_init)(void))\n{\n\tif (SG(sapi_started) && EG(current_execute_data)) {\n\t\treturn FAILURE;\n\t}\n\tsapi_module.input_filter = input_filter;\n\tsapi_module.input_filter_init = input_filter_init;\n\treturn SUCCESS;\n}\n\nSAPI_API int sapi_flush(void)\n{\n\tif (sapi_module.flush) {\n\t\tsapi_module.flush(SG(server_context));\n\t\treturn SUCCESS;\n\t} else {\n\t\treturn FAILURE;\n\t}\n}\n\nSAPI_API zend_stat_t *sapi_get_stat(void)\n{\n\tif (sapi_module.get_stat) {\n\t\treturn sapi_module.get_stat();\n\t} else {\n\t\tif (!SG(request_info).path_translated || (VCWD_STAT(SG(request_info).path_translated, &SG(global_stat)) == -1)) {\n\t\t\treturn NULL;\n\t\t}\n\t\treturn &SG(global_stat);\n\t}\n}\n\nSAPI_API char *sapi_getenv(const char *name, size_t name_len)\n{\n\tchar *value, *tmp;\n\n\tif (!sapi_module.getenv) {\n\t\treturn NULL;\n\t}\n\tif (!strncasecmp(name, \"HTTP_PROXY\", name_len)) {\n\t\t/* Ugly fix for HTTP_PROXY issue, see bug #72573 */\n\t\treturn NULL;\n\t}\n\ttmp = sapi_module.getenv(name, name_len);\n\tif (!tmp) {\n\t\treturn NULL;\n\t}\n\tvalue = estrdup(tmp);\n#ifdef PHP_WIN32\n\tif (strlen(sapi_module.name) == sizeof(\"cgi-fcgi\") - 1 && !strcmp(sapi_module.name, \"cgi-fcgi\")) {\n\t\t/* XXX more modules to go, if needed. */\n\t\tfree(tmp);\n\t}\n#endif\n\tif (sapi_module.input_filter) {\n\t\tsapi_module.input_filter(PARSE_STRING, name, &value, strlen(value), NULL);\n\t}\n\treturn value;\n}\n\nSAPI_API int sapi_get_fd(int *fd)\n{\n\tif (sapi_module.get_fd) {\n\t\treturn sapi_module.get_fd(fd);\n\t} else {\n\t\treturn FAILURE;\n\t}\n}\n\nSAPI_API int sapi_force_http_10(void)\n{\n\tif (sapi_module.force_http_10) {\n\t\treturn sapi_module.force_http_10();\n\t} else {\n\t\treturn FAILURE;\n\t}\n}\n\n\nSAPI_API int sapi_get_target_uid(uid_t *obj)\n{\n\tif (sapi_module.get_target_uid) {\n\t\treturn sapi_module.get_target_uid(obj);\n\t} else {\n\t\treturn FAILURE;\n\t}\n}\n\nSAPI_API int sapi_get_target_gid(gid_t *obj)\n{\n\tif (sapi_module.get_target_gid) {\n\t\treturn sapi_module.get_target_gid(obj);\n\t} else {\n\t\treturn FAILURE;\n\t}\n}\n\nSAPI_API double sapi_get_request_time(void)\n{\n\tif(SG(global_request_time)) return SG(global_request_time);\n\n\tif (!sapi_module.get_request_time\n\t\t\t|| sapi_module.get_request_time(&SG(global_request_time)) == FAILURE) {\n\t\tstruct timeval tp = {0};\n\t\tif (!gettimeofday(&tp, NULL)) {\n\t\t\tSG(global_request_time) = (double)(tp.tv_sec + tp.tv_usec / 1000000.00);\n\t\t} else {\n\t\t\tSG(global_request_time) = (double)time(0);\n\t\t}\n\t}\n\treturn SG(global_request_time);\n}\n\nSAPI_API void sapi_terminate_process(void) {\n\tif (sapi_module.terminate_process) {\n\t\tsapi_module.terminate_process();\n\t}\n}\n\nSAPI_API void sapi_add_request_header(const char *var, unsigned int var_len, char *val, unsigned int val_len, void *arg) /* {{{ */\n{\n\tzval *return_value = (zval*)arg;\n\tchar *buf = NULL;\n\n\tALLOCA_FLAG(use_heap)\n\n\tif (var_len > 5 &&\n\t    var[0] == 'H' &&\n\t    var[1] == 'T' &&\n\t    var[2] == 'T' &&\n\t    var[3] == 'P' &&\n\t    var[4] == '_') {\n\n\t\tconst char *p;\n\t\tchar *str;\n\n\t\tvar_len -= 5;\n\t\tp = var + 5;\n\t\tvar = str = buf = do_alloca(var_len + 1, use_heap);\n\t\t*str++ = *p++;\n\t\twhile (*p) {\n\t\t\tif (*p == '_') {\n\t\t\t\t*str++ = '-';\n\t\t\t\tp++;\n\t\t\t\tif (*p) {\n\t\t\t\t\t*str++ = *p++;\n\t\t\t\t}\n\t\t\t} else if (*p >= 'A' && *p <= 'Z') {\n\t\t\t\t*str++ = (*p++ - 'A' + 'a');\n\t\t\t} else {\n\t\t\t\t*str++ = *p++;\n\t\t\t}\n\t\t}\n\t\t*str = 0;\n\t} else if (var_len == sizeof(\"CONTENT_TYPE\")-1 &&\n\t           memcmp(var, \"CONTENT_TYPE\", sizeof(\"CONTENT_TYPE\")-1) == 0) {\n\t\tvar = \"Content-Type\";\n\t} else if (var_len == sizeof(\"CONTENT_LENGTH\")-1 &&\n\t           memcmp(var, \"CONTENT_LENGTH\", sizeof(\"CONTENT_LENGTH\")-1) == 0) {\n\t\tvar = \"Content-Length\";\n\t} else {\n\t\treturn;\n\t}\n\tadd_assoc_stringl_ex(return_value, var, var_len, val, val_len);\n\tif (buf) {\n\t\tfree_alloca(buf, use_heap);\n\t}\n}\n/* }}} */\n", "patch": "@@ -743,13 +743,8 @@ SAPI_API int sapi_header_op(sapi_header_op_enum op, void *arg TSRMLS_DC)\n \t\t/* new line/NUL character safety check */\n \t\tint i;\n \t\tfor (i = 0; i < header_line_len; i++) {\n-\t\t\t/* RFC 2616 allows new lines if followed by SP or HT */\n-\t\t\tint illegal_break =\n-\t\t\t\t\t(header_line[i+1] != ' ' && header_line[i+1] != '\\t')\n-\t\t\t\t\t&& (\n-\t\t\t\t\t\theader_line[i] == '\\n'\n-\t\t\t\t\t\t|| (header_line[i] == '\\r' && header_line[i+1] != '\\n'));\n-\t\t\tif (illegal_break) {\n+\t\t\t/* RFC 7230 ch. 3.2.4 deprecates folding support */\n+\t\t\tif (header_line[i] == '\\n' || header_line[i] == '\\r') {\n \t\t\t\tefree(header_line);\n \t\t\t\tsapi_module.sapi_error(E_WARNING, \"Header may not contain \"\n \t\t\t\t\t\t\"more than a single header, new line detected\");", "file_path": "files/2016_8\\74", "file_language": "c", "file_name": "main/SAPI.c", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}], "outdated": 0}
{"index": 28, "cve_id": "CVE-2016-3078", "cwe_id": ["CWE-190"], "cve_language": "C", "cve_description": "Multiple integer overflows in php_zip.c in the zip extension in PHP before 7.0.6 allow remote attackers to cause a denial of service (heap-based buffer overflow and application crash) or possibly have unspecified other impact via a crafted call to (1) getFromIndex or (2) getFromName in the ZipArchive class.", "cvss": "9.8", "publish_date": "August 7, 2016", "AV": "NETWORK", "AC": "LOW", "PR": "NONE", "UI": "NONE", "S": "UNCHANGED", "C": "HIGH", "I": "HIGH", "A": "HIGH", "commit_id": "97eff7eb57fc2320c267a949cffd622c38712484", "commit_message": "Fix bug #72241: get_icu_value_internal out-of-bounds read", "commit_date": "2016-05-23T00:49:02Z", "project": "php/php-src", "url": "https://api.github.com/repos/php/php-src/commits/97eff7eb57fc2320c267a949cffd622c38712484", "html_url": "https://github.com/php/php-src/commit/97eff7eb57fc2320c267a949cffd622c38712484", "windows_before": "", "windows_after": "", "parents": [{"commit_id_before": "0da8b8b801f9276359262f1ef8274c7812d3dfda", "url_before": "https://api.github.com/repos/php/php-src/commits/0da8b8b801f9276359262f1ef8274c7812d3dfda", "html_url_before": "https://github.com/php/php-src/commit/0da8b8b801f9276359262f1ef8274c7812d3dfda"}], "details": [{"raw_url": "https://github.com/php/php-src/raw/97eff7eb57fc2320c267a949cffd622c38712484/ext/intl/locale/locale_methods.c", "code": "/*\n   +----------------------------------------------------------------------+\n   | PHP Version 5                                                        |\n   +----------------------------------------------------------------------+\n   | This source file is subject to version 3.01 of the PHP license,      |\n   | that is bundled with this package in the file LICENSE, and is        |\n   | available through the world-wide-web at the following url:           |\n   | http://www.php.net/license/3_01.txt                                  |\n   | If you did not receive a copy of the PHP license and are unable to   |\n   | obtain it through the world-wide-web, please send a note to          |\n   | license@php.net so we can mail you a copy immediately.               |\n   +----------------------------------------------------------------------+\n   | Authors: Kirti Velankar <kirtig@yahoo-inc.com>                       |\n   +----------------------------------------------------------------------+\n*/\n\n/* $Id$ */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <unicode/ustring.h>\n#include <unicode/udata.h>\n#include <unicode/putil.h>\n#include <unicode/ures.h>\n\n#include \"php_intl.h\"\n#include \"locale.h\"\n#include \"locale_class.h\"\n#include \"locale_methods.h\"\n#include \"intl_convert.h\"\n#include \"intl_data.h\"\n\n#include <zend_API.h>\n#include <zend.h>\n#include <php.h>\n#include \"main/php_ini.h\"\n#include \"ext/standard/php_smart_str.h\"\n\nZEND_EXTERN_MODULE_GLOBALS( intl )\n\n/* Sizes required for the strings \"variant15\" , \"extlang11\", \"private12\" etc. */\n#define SEPARATOR \"_\"\n#define SEPARATOR1 \"-\"\n#define DELIMITER \"-_\"\n#define EXTLANG_PREFIX \"a\"\n#define PRIVATE_PREFIX \"x\"\n#define DISP_NAME \"name\"\n\n#define MAX_NO_VARIANT  15\n#define MAX_NO_EXTLANG  3\n#define MAX_NO_PRIVATE  15\n#define MAX_NO_LOOKUP_LANG_TAG  100\n\n#define LOC_NOT_FOUND 1\n\n/* Sizes required for the strings \"variant15\" , \"extlang3\", \"private12\" etc. */\n#define VARIANT_KEYNAME_LEN  11\n#define EXTLANG_KEYNAME_LEN  10\n#define PRIVATE_KEYNAME_LEN  11\n\n/* Based on IANA registry at the time of writing this code\n*\n*/\nstatic const char * const LOC_GRANDFATHERED[] = {\n\t\"art-lojban\",\t\t\"i-klingon\",\t\t\"i-lux\",\t\t\t\"i-navajo\",\t\t\"no-bok\",\t\t\"no-nyn\",\n\t\"cel-gaulish\",\t\t\"en-GB-oed\",\t\t\"i-ami\",\n\t\"i-bnn\",\t\t\"i-default\",\t\t\"i-enochian\",\n\t\"i-mingo\",\t\t\"i-pwn\", \t\t\"i-tao\",\n\t\"i-tay\",\t\t\"i-tsu\",\t\t\"sgn-BE-fr\",\n\t\"sgn-BE-nl\",\t\t\"sgn-CH-de\", \t\t\"zh-cmn\",\n \t\"zh-cmn-Hans\", \t\t\"zh-cmn-Hant\",\t\t\"zh-gan\" ,\n\t\"zh-guoyu\", \t\t\"zh-hakka\", \t\t\"zh-min\",\n\t\"zh-min-nan\", \t\t\"zh-wuu\", \t\t\"zh-xiang\",\n\t\"zh-yue\",\t\tNULL\n};\n\n/* Based on IANA registry at the time of writing this code\n*  This array lists the preferred values for the grandfathered tags if applicable\n*  This is in sync with the array LOC_GRANDFATHERED\n*  e.g. the offsets of the grandfathered tags match the offset of the preferred  value\n*/\nstatic const int \t\tLOC_PREFERRED_GRANDFATHERED_LEN = 6;\nstatic const char * const \tLOC_PREFERRED_GRANDFATHERED[]  = {\n\t\"jbo\",\t\t\t\"tlh\",\t\t\t\"lb\",\n\t\"nv\", \t\t\t\"nb\",\t\t\t\"nn\",\n\tNULL\n};\n\n/*returns TRUE if a is an ID separator FALSE otherwise*/\n#define isIDSeparator(a) (a == '_' || a == '-')\n#define isKeywordSeparator(a) (a == '@' )\n#define isEndOfTag(a) (a == '\\0' )\n\n#define isPrefixLetter(a) ((a=='x')||(a=='X')||(a=='i')||(a=='I'))\n\n/*returns TRUE if one of the special prefixes is here (s=string)\n  'x-' or 'i-' */\n#define isIDPrefix(s) (isPrefixLetter(s[0])&&isIDSeparator(s[1]))\n#define isKeywordPrefix(s) ( isKeywordSeparator(s[0]) )\n\n/* Dot terminates it because of POSIX form  where dot precedes the codepage\n * except for variant */\n#define isTerminator(a)  ((a==0)||(a=='.')||(a=='@'))\n\n/* {{{ return the offset of 'key' in the array 'list'.\n * returns -1 if not present */\nstatic int16_t findOffset(const char* const* list, const char* key)\n{\n\tconst char* const* anchor = list;\n\twhile (*list != NULL) {\n\t\tif (strcmp(key, *list) == 0) {\n\t\t\treturn (int16_t)(list - anchor);\n\t\t}\n\t\tlist++;\n\t}\n\n\treturn -1;\n\n}\n/*}}}*/\n\nstatic char* getPreferredTag(const char* gf_tag)\n{\n\tchar* result = NULL;\n\tint grOffset = 0;\n\n\tgrOffset = findOffset( LOC_GRANDFATHERED ,gf_tag);\n\tif(grOffset < 0) {\n\t\treturn NULL;\n\t}\n\tif( grOffset < LOC_PREFERRED_GRANDFATHERED_LEN ){\n\t\t/* return preferred tag */\n\t\tresult = estrdup( LOC_PREFERRED_GRANDFATHERED[grOffset] );\n\t} else {\n\t\t/* Return correct grandfathered language tag */\n\t\tresult = estrdup( LOC_GRANDFATHERED[grOffset] );\n\t}\n\treturn result;\n}\n\n/* {{{\n* returns the position of next token for lookup\n* or -1 if no token\n* strtokr equivalent search for token in reverse direction\n*/\nstatic int getStrrtokenPos(char* str, int savedPos)\n{\n\tint result =-1;\n\tint i;\n\n\tfor(i=savedPos-1; i>=0; i--) {\n\t\tif(isIDSeparator(*(str+i)) ){\n\t\t\t/* delimiter found; check for singleton */\n\t\t\tif(i>=2 && isIDSeparator(*(str+i-2)) ){\n\t\t\t\t/* a singleton; so send the position of token before the singleton */\n\t\t\t\tresult = i-2;\n\t\t\t} else {\n\t\t\t\tresult = i;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(result < 1){\n\t\t/* Just in case inavlid locale e.g. '-x-xyz' or '-sl_Latn' */\n\t\tresult =-1;\n\t}\n\treturn result;\n}\n/* }}} */\n\n/* {{{\n* returns the position of a singleton if present\n* returns -1 if no singleton\n* strtok equivalent search for singleton\n*/\nstatic int getSingletonPos(const char* str)\n{\n\tint result =-1;\n\tint i=0;\n\tint len = 0;\n\n\tif( str && ((len=strlen(str))>0) ){\n\t\tfor( i=0; i<len ; i++){\n\t\t\tif( isIDSeparator(*(str+i)) ){\n\t\t\t\tif( i==1){\n\t\t\t\t\t/* string is of the form x-avy or a-prv1 */\n\t\t\t\t\tresult =0;\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t/* delimiter found; check for singleton */\n\t\t\t\t\tif( isIDSeparator(*(str+i+2)) ){\n\t\t\t\t\t\t/* a singleton; so send the position of separator before singleton */\n\t\t\t\t\t\tresult = i+1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}/* end of for */\n\n\t}\n\treturn result;\n}\n/* }}} */\n\n/* {{{ proto static string Locale::getDefault(  )\n   Get default locale */\n/* }}} */\n/* {{{ proto static string locale_get_default( )\n   Get default locale */\nPHP_NAMED_FUNCTION(zif_locale_get_default)\n{\n\tRETURN_STRING( intl_locale_get_default( TSRMLS_C ), TRUE );\n}\n\n/* }}} */\n\n/* {{{ proto static string Locale::setDefault( string $locale )\n   Set default locale */\n/* }}} */\n/* {{{ proto static string locale_set_default( string $locale )\n   Set default locale */\nPHP_NAMED_FUNCTION(zif_locale_set_default)\n{\n\tchar* locale_name = NULL;\n\tint   len=0;\n\n\tif(zend_parse_parameters( ZEND_NUM_ARGS() TSRMLS_CC,  \"s\",\n\t\t&locale_name ,&len ) == FAILURE)\n\t{\n\t\tintl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,\n\t\t\t \t\"locale_set_default: unable to parse input params\", 0 TSRMLS_CC );\n\n\t\tRETURN_FALSE;\n\t}\n\n\tif(len == 0) {\n\t\tlocale_name =  (char *)uloc_getDefault() ;\n\t\tlen = strlen(locale_name);\n\t}\n\n\tzend_alter_ini_entry(LOCALE_INI_NAME, sizeof(LOCALE_INI_NAME), locale_name, len, PHP_INI_USER, PHP_INI_STAGE_RUNTIME);\n\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{\n* Gets the value from ICU\n* common code shared by get_primary_language,get_script or get_region or get_variant\n* result = 0 if error, 1 if successful , -1 if no value\n*/\nstatic char* get_icu_value_internal( const char* loc_name , char* tag_name, int* result , int fromParseLocale)\n{\n\tchar*\t\ttag_value\t= NULL;\n\tint32_t     \ttag_value_len   = 512;\n\n\tint\t\tsingletonPos   \t= 0;\n\tchar*       \tmod_loc_name\t= NULL;\n\tint \t\tgrOffset\t= 0;\n\n\tint32_t     \tbuflen          = 512;\n\tUErrorCode  \tstatus          = U_ZERO_ERROR;\n\n\n\tif( strcmp(tag_name, LOC_CANONICALIZE_TAG) != 0 ){\n\t\t/* Handle  grandfathered languages */\n\t\tgrOffset =  findOffset( LOC_GRANDFATHERED , loc_name );\n\t\tif( grOffset >= 0 ){\n\t\t\tif( strcmp(tag_name , LOC_LANG_TAG)==0 ){\n\t\t\t\treturn estrdup(loc_name);\n\t\t\t} else {\n\t\t\t\t/* Since Grandfathered , no value , do nothing , retutn NULL */\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\n\tif( fromParseLocale==1 ){\n\t\t/* Handle singletons */\n\t\tif( strcmp(tag_name , LOC_LANG_TAG)==0 ){\n\t\t\tif( strlen(loc_name)>1 && (isIDPrefix(loc_name) == 1) ){\n\t\t\t\treturn estrdup(loc_name);\n\t\t\t}\n\t\t}\n\n\t\tsingletonPos = getSingletonPos( loc_name );\n\t\tif( singletonPos == 0){\n\t\t\t/* singleton at start of script, region , variant etc.\n\t\t\t * or invalid singleton at start of language */\n\t\t\treturn NULL;\n\t\t} else if( singletonPos > 0 ){\n\t\t\t/* singleton at some position except at start\n\t\t\t * strip off the singleton and rest of the loc_name */\n\t\t\tmod_loc_name = estrndup ( loc_name , singletonPos-1);\n\t\t}\n\t} /* end of if fromParse */\n\n\t} /* end of if != LOC_CANONICAL_TAG */\n\n\tif( mod_loc_name == NULL){\n\t\tmod_loc_name = estrdup(loc_name );\n\t}\n\n\t/* Proceed to ICU */\n    do{\n\t\ttag_value = erealloc( tag_value , buflen  );\n\t\ttag_value_len = buflen;\n\n\t\tif( strcmp(tag_name , LOC_SCRIPT_TAG)==0 ){\n\t\t\tbuflen = uloc_getScript ( mod_loc_name ,tag_value , tag_value_len , &status);\n\t\t}\n\t\tif( strcmp(tag_name , LOC_LANG_TAG )==0 ){\n\t\t\tbuflen = uloc_getLanguage ( mod_loc_name ,tag_value , tag_value_len , &status);\n\t\t}\n\t\tif( strcmp(tag_name , LOC_REGION_TAG)==0 ){\n\t\t\tbuflen = uloc_getCountry ( mod_loc_name ,tag_value , tag_value_len , &status);\n\t\t}\n\t\tif( strcmp(tag_name , LOC_VARIANT_TAG)==0 ){\n\t\t\tbuflen = uloc_getVariant ( mod_loc_name ,tag_value , tag_value_len , &status);\n\t\t}\n\t\tif( strcmp(tag_name , LOC_CANONICALIZE_TAG)==0 ){\n\t\t\tbuflen = uloc_canonicalize ( mod_loc_name ,tag_value , tag_value_len , &status);\n\t\t}\n\n\t\tif( U_FAILURE( status ) ) {\n\t\t\tif( status == U_BUFFER_OVERFLOW_ERROR ) {\n\t\t\t\tstatus = U_ZERO_ERROR;\n\t\t\t\tbuflen++; /* add space for \\0 */\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* Error in retriving data */\n\t\t\t*result = 0;\n\t\t\tif( tag_value ){\n\t\t\t\tefree( tag_value );\n\t\t\t}\n\t\t\tif( mod_loc_name ){\n\t\t\t\tefree( mod_loc_name);\n\t\t\t}\n\t\t\treturn NULL;\n\t\t}\n\t} while( buflen > tag_value_len );\n\n\tif(  buflen ==0 ){\n\t\t/* No value found */\n\t\t*result = -1;\n\t\tif( tag_value ){\n\t\t\tefree( tag_value );\n\t\t}\n\t\tif( mod_loc_name ){\n\t\t\tefree( mod_loc_name);\n\t\t}\n\t\treturn NULL;\n\t} else {\n\t\t*result = 1;\n\t}\n\n\tif( mod_loc_name ){\n\t\tefree( mod_loc_name);\n\t}\n\treturn tag_value;\n}\n/* }}} */\n\n/* {{{\n* Gets the value from ICU , called when PHP userspace function is called\n* common code shared by get_primary_language,get_script or get_region or get_variant\n*/\nstatic void get_icu_value_src_php( char* tag_name, INTERNAL_FUNCTION_PARAMETERS)\n{\n\n\tconst char* loc_name        \t= NULL;\n\tint         loc_name_len    \t= 0;\n\n\tchar*       tag_value\t\t= NULL;\n\tchar*       empty_result\t= \"\";\n\n\tint         result    \t\t= 0;\n\tchar*       msg        \t\t= NULL;\n\n\tUErrorCode  status          \t= U_ZERO_ERROR;\n\n\tintl_error_reset( NULL TSRMLS_CC );\n\n\tif(zend_parse_parameters( ZEND_NUM_ARGS() TSRMLS_CC, \"s\",\n\t&loc_name ,&loc_name_len ) == FAILURE) {\n\t\tspprintf(&msg , 0, \"locale_get_%s : unable to parse input params\", tag_name );\n\t\tintl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,  msg , 1 TSRMLS_CC );\n\t\tefree(msg);\n\n\t\tRETURN_FALSE;\n    }\n\n\tif(loc_name_len == 0) {\n\t\tloc_name = intl_locale_get_default(TSRMLS_C);\n\t}\n\n\t/* Call ICU get */\n\ttag_value = get_icu_value_internal( loc_name , tag_name , &result ,0);\n\n\t/* No value found */\n\tif( result == -1 ) {\n\t\tif( tag_value){\n\t\t\tefree( tag_value);\n\t\t}\n\t\tRETURN_STRING( empty_result , TRUE);\n\t}\n\n\t/* value found */\n\tif( tag_value){\n\t\tRETURN_STRING( tag_value , FALSE);\n\t}\n\n\t/* Error encountered while fetching the value */\n\tif( result ==0) {\n\t\tspprintf(&msg , 0, \"locale_get_%s : unable to get locale %s\", tag_name , tag_name );\n\t\tintl_error_set( NULL, status, msg , 1 TSRMLS_CC );\n\t\tefree(msg);\n\t\tRETURN_NULL();\n\t}\n\n}\n/* }}} */\n\n/* {{{ proto static string Locale::getScript($locale)\n * gets the script for the $locale\n }}} */\n/* {{{ proto static string locale_get_script($locale)\n * gets the script for the $locale\n */\nPHP_FUNCTION( locale_get_script )\n{\n\tget_icu_value_src_php( LOC_SCRIPT_TAG , INTERNAL_FUNCTION_PARAM_PASSTHRU );\n}\n/* }}} */\n\n/* {{{ proto static string Locale::getRegion($locale)\n * gets the region for the $locale\n }}} */\n/* {{{ proto static string locale_get_region($locale)\n * gets the region for the $locale\n */\nPHP_FUNCTION( locale_get_region )\n{\n\tget_icu_value_src_php( LOC_REGION_TAG , INTERNAL_FUNCTION_PARAM_PASSTHRU );\n}\n/* }}} */\n\n/* {{{ proto static string Locale::getPrimaryLanguage($locale)\n * gets the primary language for the $locale\n }}} */\n/* {{{ proto static string locale_get_primary_language($locale)\n * gets the primary language for the $locale\n */\nPHP_FUNCTION(locale_get_primary_language )\n{\n\tget_icu_value_src_php( LOC_LANG_TAG , INTERNAL_FUNCTION_PARAM_PASSTHRU );\n}\n/* }}} */\n\n\n/* {{{\n * common code shared by display_xyz functions to  get the value from ICU\n }}} */\nstatic void get_icu_disp_value_src_php( char* tag_name, INTERNAL_FUNCTION_PARAMETERS)\n{\n\tconst char* loc_name        \t= NULL;\n\tint         loc_name_len    \t= 0;\n\n\tconst char* disp_loc_name       = NULL;\n\tint         disp_loc_name_len   = 0;\n\tint         free_loc_name       = 0;\n\n\tUChar*      disp_name      \t= NULL;\n\tint32_t     disp_name_len  \t= 0;\n\n\tchar*       mod_loc_name        = NULL;\n\n\tint32_t     buflen          \t= 512;\n\tUErrorCode  status          \t= U_ZERO_ERROR;\n\n\tchar*       utf8value\t\t= NULL;\n\tint         utf8value_len   \t= 0;\n\n  \tchar*       msg             \t= NULL;\n\tint         grOffset    \t= 0;\n\n\tintl_error_reset( NULL TSRMLS_CC );\n\n\tif(zend_parse_parameters( ZEND_NUM_ARGS() TSRMLS_CC, \"s|s\",\n\t\t&loc_name, &loc_name_len ,\n\t\t&disp_loc_name ,&disp_loc_name_len ) == FAILURE)\n\t{\n\t\tspprintf(&msg , 0, \"locale_get_display_%s : unable to parse input params\", tag_name );\n\t\tintl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,  msg , 1 TSRMLS_CC );\n\t\tefree(msg);\n\t\tRETURN_FALSE;\n\t}\n\n    if(loc_name_len > ULOC_FULLNAME_CAPACITY) {\n        /* See bug 67397: overlong locale names cause trouble in uloc_getDisplayName */\n\t\tspprintf(&msg , 0, \"locale_get_display_%s : name too long\", tag_name );\n\t\tintl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,  msg , 1 TSRMLS_CC );\n\t\tefree(msg);\n\t\tRETURN_FALSE;\n    }\n\n\tif(loc_name_len == 0) {\n\t\tloc_name = intl_locale_get_default(TSRMLS_C);\n\t}\n\n\tif( strcmp(tag_name, DISP_NAME) != 0 ){\n\t\t/* Handle grandfathered languages */\n\t\tgrOffset = findOffset( LOC_GRANDFATHERED , loc_name );\n\t\tif( grOffset >= 0 ){\n\t\t\tif( strcmp(tag_name , LOC_LANG_TAG)==0 ){\n\t\t\t\tmod_loc_name = getPreferredTag( loc_name );\n\t\t\t} else {\n\t\t\t\t/* Since Grandfathered, no value, do nothing, retutn NULL */\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\t\t}\n\t} /* end of if != LOC_CANONICAL_TAG */\n\n\tif( mod_loc_name==NULL ){\n\t\tmod_loc_name = estrdup( loc_name );\n\t}\n\n\t/* Check if disp_loc_name passed , if not use default locale */\n\tif( !disp_loc_name){\n\t\tdisp_loc_name = estrdup(intl_locale_get_default(TSRMLS_C));\n\t\tfree_loc_name = 1;\n\t}\n\n    /* Get the disp_value for the given locale */\n    do{\n        disp_name = erealloc( disp_name , buflen * sizeof(UChar)  );\n        disp_name_len = buflen;\n\n\t\tif( strcmp(tag_name , LOC_LANG_TAG)==0 ){\n\t\t\tbuflen = uloc_getDisplayLanguage ( mod_loc_name , disp_loc_name , disp_name , disp_name_len , &status);\n\t\t} else if( strcmp(tag_name , LOC_SCRIPT_TAG)==0 ){\n\t\t\tbuflen = uloc_getDisplayScript ( mod_loc_name , disp_loc_name , disp_name , disp_name_len , &status);\n\t\t} else if( strcmp(tag_name , LOC_REGION_TAG)==0 ){\n\t\t\tbuflen = uloc_getDisplayCountry ( mod_loc_name , disp_loc_name , disp_name , disp_name_len , &status);\n\t\t} else if( strcmp(tag_name , LOC_VARIANT_TAG)==0 ){\n\t\t\tbuflen = uloc_getDisplayVariant ( mod_loc_name , disp_loc_name , disp_name , disp_name_len , &status);\n\t\t} else if( strcmp(tag_name , DISP_NAME)==0 ){\n\t\t\tbuflen = uloc_getDisplayName ( mod_loc_name , disp_loc_name , disp_name , disp_name_len , &status);\n\t\t}\n\n\t\t/* U_STRING_NOT_TERMINATED_WARNING is admissible here; don't look for it */\n\t\tif( U_FAILURE( status ) )\n\t\t{\n\t\t\tif( status == U_BUFFER_OVERFLOW_ERROR )\n\t\t\t{\n\t\t\t\tstatus = U_ZERO_ERROR;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tspprintf(&msg, 0, \"locale_get_display_%s : unable to get locale %s\", tag_name , tag_name );\n\t\t\tintl_error_set( NULL, status, msg , 1 TSRMLS_CC );\n\t\t\tefree(msg);\n\t\t\tif( disp_name){\n\t\t\t\tefree( disp_name );\n\t\t\t}\n\t\t\tif( mod_loc_name){\n\t\t\t\tefree( mod_loc_name );\n\t\t\t}\n\t\t\tif (free_loc_name) {\n\t\t\t\tefree((void *)disp_loc_name);\n\t\t\t\tdisp_loc_name = NULL;\n\t\t\t}\n\t\t\tRETURN_FALSE;\n\t\t}\n\t} while( buflen > disp_name_len );\n\n\tif( mod_loc_name){\n\t\tefree( mod_loc_name );\n\t}\n\tif (free_loc_name) {\n\t\tefree((void *)disp_loc_name);\n\t\tdisp_loc_name = NULL;\n\t}\n\t/* Convert display locale name from UTF-16 to UTF-8. */\n\tintl_convert_utf16_to_utf8( &utf8value, &utf8value_len, disp_name, buflen, &status );\n\tefree( disp_name );\n\tif( U_FAILURE( status ) )\n\t{\n\t\tspprintf(&msg, 0, \"locale_get_display_%s :error converting display name for %s to UTF-8\", tag_name , tag_name );\n\t\tintl_error_set( NULL, status, msg , 1 TSRMLS_CC );\n\t\tefree(msg);\n\t\tRETURN_FALSE;\n\t}\n\n\tRETVAL_STRINGL( utf8value, utf8value_len , FALSE);\n\n}\n/* }}} */\n\n/* {{{ proto static string Locale::getDisplayName($locale[, $in_locale = null])\n* gets the name for the $locale in $in_locale or default_locale\n }}} */\n/* {{{ proto static string get_display_name($locale[, $in_locale = null])\n* gets the name for the $locale in $in_locale or default_locale\n*/\nPHP_FUNCTION(locale_get_display_name)\n{\n    get_icu_disp_value_src_php( DISP_NAME , INTERNAL_FUNCTION_PARAM_PASSTHRU );\n}\n/* }}} */\n\n/* {{{ proto static string Locale::getDisplayLanguage($locale[, $in_locale = null])\n* gets the language for the $locale in $in_locale or default_locale\n }}} */\n/* {{{ proto static string get_display_language($locale[, $in_locale = null])\n* gets the language for the $locale in $in_locale or default_locale\n*/\nPHP_FUNCTION(locale_get_display_language)\n{\n    get_icu_disp_value_src_php( LOC_LANG_TAG , INTERNAL_FUNCTION_PARAM_PASSTHRU );\n}\n/* }}} */\n\n/* {{{ proto static string Locale::getDisplayScript($locale, $in_locale = null)\n* gets the script for the $locale in $in_locale or default_locale\n }}} */\n/* {{{ proto static string get_display_script($locale, $in_locale = null)\n* gets the script for the $locale in $in_locale or default_locale\n*/\nPHP_FUNCTION(locale_get_display_script)\n{\n    get_icu_disp_value_src_php( LOC_SCRIPT_TAG , INTERNAL_FUNCTION_PARAM_PASSTHRU );\n}\n/* }}} */\n\n/* {{{ proto static string Locale::getDisplayRegion($locale, $in_locale = null)\n* gets the region for the $locale in $in_locale or default_locale\n }}} */\n/* {{{ proto static string get_display_region($locale, $in_locale = null)\n* gets the region for the $locale in $in_locale or default_locale\n*/\nPHP_FUNCTION(locale_get_display_region)\n{\n    get_icu_disp_value_src_php( LOC_REGION_TAG , INTERNAL_FUNCTION_PARAM_PASSTHRU );\n}\n/* }}} */\n\n/* {{{\n* proto static string Locale::getDisplayVariant($locale, $in_locale = null)\n* gets the variant for the $locale in $in_locale or default_locale\n }}} */\n/* {{{\n* proto static string get_display_variant($locale, $in_locale = null)\n* gets the variant for the $locale in $in_locale or default_locale\n*/\nPHP_FUNCTION(locale_get_display_variant)\n{\n    get_icu_disp_value_src_php( LOC_VARIANT_TAG , INTERNAL_FUNCTION_PARAM_PASSTHRU );\n}\n/* }}} */\n\n /* {{{ proto static array getKeywords(string $locale) {\n * return an associative array containing keyword-value\n * pairs for this locale. The keys are keys to the array (doh!)\n * }}}*/\n /* {{{ proto static array locale_get_keywords(string $locale) {\n * return an associative array containing keyword-value\n * pairs for this locale. The keys are keys to the array (doh!)\n */\nPHP_FUNCTION( locale_get_keywords )\n{\n    UEnumeration*   e        = NULL;\n    UErrorCode      status   = U_ZERO_ERROR;\n\n    const char*\t \tkw_key        = NULL;\n    int32_t         kw_key_len    = 0;\n\n    const char*       \tloc_name        = NULL;\n    int        \t \tloc_name_len    = 0;\n\n/*\n\tICU expects the buffer to be allocated  before calling the function\n\tand so the buffer size has been explicitly specified\n\tICU uloc.h #define \tULOC_KEYWORD_AND_VALUES_CAPACITY   100\n\thence the kw_value buffer size is 100\n*/\n\tchar*\t \tkw_value        = NULL;\n    int32_t     kw_value_len    = 100;\n\n    intl_error_reset( NULL TSRMLS_CC );\n\n    if(zend_parse_parameters( ZEND_NUM_ARGS() TSRMLS_CC, \"s\",\n        &loc_name, &loc_name_len ) == FAILURE)\n    {\n        intl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,\n             \"locale_get_keywords: unable to parse input params\", 0 TSRMLS_CC );\n\n        RETURN_FALSE;\n    }\n\n    if(loc_name_len == 0) {\n        loc_name = intl_locale_get_default(TSRMLS_C);\n    }\n\n\t/* Get the keywords */\n    e = uloc_openKeywords( loc_name, &status );\n    if( e != NULL )\n    {\n\t\t/* Traverse it, filling the return array. */\n    \tarray_init( return_value );\n\n    \twhile( ( kw_key = uenum_next( e, &kw_key_len, &status ) ) != NULL ){\n\t\t\tkw_value = ecalloc( 1 , kw_value_len  );\n\n\t\t\t/* Get the keyword value for each keyword */\n\t\t\tkw_value_len=uloc_getKeywordValue( loc_name,kw_key, kw_value, kw_value_len ,  &status );\n\t\t\tif (status == U_BUFFER_OVERFLOW_ERROR) {\n\t\t\t\tstatus = U_ZERO_ERROR;\n\t\t\t\tkw_value = erealloc( kw_value , kw_value_len+1);\n\t\t\t\tkw_value_len=uloc_getKeywordValue( loc_name,kw_key, kw_value, kw_value_len+1 ,  &status );\n\t\t\t} else if(!U_FAILURE(status)) {\n\t\t\t\tkw_value = erealloc( kw_value , kw_value_len+1);\n\t\t\t}\n\t\t\tif (U_FAILURE(status)) {\n\t        \t\tintl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR, \"locale_get_keywords: Error encountered while getting the keyword  value for the  keyword\", 0 TSRMLS_CC );\n\t\t\t\tif( kw_value){\n\t\t\t\t\tefree( kw_value );\n\t\t\t\t}\n\t\t\t\tzval_dtor(return_value);\n        \t\tRETURN_FALSE;\n\t\t\t}\n\n       \t\tadd_assoc_stringl( return_value, (char *)kw_key, kw_value , kw_value_len, 0);\n\t\t} /* end of while */\n\n\t} /* end of if e!=NULL */\n\n    uenum_close( e );\n}\n/* }}} */\n\n /* {{{ proto static string Locale::canonicalize($locale)\n * @return string the canonicalized locale\n * }}} */\n /* {{{ proto static string locale_canonicalize(Locale $loc, string $locale)\n * @param string $locale\tThe locale string to canonicalize\n */\nPHP_FUNCTION(locale_canonicalize)\n{\n\tget_icu_value_src_php( LOC_CANONICALIZE_TAG , INTERNAL_FUNCTION_PARAM_PASSTHRU );\n}\n/* }}} */\n\n/* {{{ append_key_value\n* Internal function which is called from locale_compose\n* gets the value for the key_name and appends to the loc_name\n* returns 1 if successful , -1 if not found ,\n* 0 if array element is not a string , -2 if buffer-overflow\n*/\nstatic int append_key_value(smart_str* loc_name, HashTable* hash_arr, char* key_name)\n{\n\tzval**\tele_value\t= NULL;\n\n\tif(zend_hash_find(hash_arr , key_name , strlen(key_name) + 1 ,(void **)&ele_value ) == SUCCESS ) {\n\t\tif(Z_TYPE_PP(ele_value)!= IS_STRING ){\n\t\t\t/* element value is not a string */\n\t\t\treturn FAILURE;\n\t\t}\n\t\tif(strcmp(key_name, LOC_LANG_TAG) != 0 &&\n\t\t   strcmp(key_name, LOC_GRANDFATHERED_LANG_TAG)!=0 ) {\n\t\t\t/* not lang or grandfathered tag */\n\t\t\tsmart_str_appendl(loc_name, SEPARATOR , sizeof(SEPARATOR)-1);\n\t\t}\n\t\tsmart_str_appendl(loc_name, Z_STRVAL_PP(ele_value) , Z_STRLEN_PP(ele_value));\n\t\treturn SUCCESS;\n\t}\n\n\treturn LOC_NOT_FOUND;\n}\n/* }}} */\n\n/* {{{ append_prefix , appends the prefix needed\n* e.g. private adds 'x'\n*/\nstatic void add_prefix(smart_str* loc_name, char* key_name)\n{\n\tif( strncmp(key_name , LOC_PRIVATE_TAG , 7) == 0 ){\n\t\tsmart_str_appendl(loc_name, SEPARATOR , sizeof(SEPARATOR)-1);\n\t\tsmart_str_appendl(loc_name, PRIVATE_PREFIX , sizeof(PRIVATE_PREFIX)-1);\n\t}\n}\n/* }}} */\n\n/* {{{ append_multiple_key_values\n* Internal function which is called from locale_compose\n* gets the multiple values for the key_name and appends to the loc_name\n* used for 'variant','extlang','private'\n* returns 1 if successful , -1 if not found ,\n* 0 if array element is not a string , -2 if buffer-overflow\n*/\nstatic int append_multiple_key_values(smart_str* loc_name, HashTable* hash_arr, char* key_name TSRMLS_DC)\n{\n\tzval**\tele_value    \t= NULL;\n\tint \ti \t\t= 0;\n\tint \tisFirstSubtag \t= 0;\n\tint \tmax_value \t= 0;\n\n\t/* Variant/ Extlang/Private etc. */\n\tif( zend_hash_find( hash_arr , key_name , strlen(key_name) + 1 ,(void **)&ele_value ) == SUCCESS ) {\n\t\tif( Z_TYPE_PP(ele_value) == IS_STRING ){\n\t\t\tadd_prefix( loc_name , key_name);\n\n\t\t\tsmart_str_appendl(loc_name, SEPARATOR , sizeof(SEPARATOR)-1);\n\t\t\tsmart_str_appendl(loc_name, Z_STRVAL_PP(ele_value) , Z_STRLEN_PP(ele_value));\n\t\t\treturn SUCCESS;\n\t\t} else if(Z_TYPE_PP(ele_value) == IS_ARRAY ) {\n\t\t\tHashPosition pos;\n\t\t\tHashTable *arr = HASH_OF(*ele_value);\n\t\t\tzval **data = NULL;\n\n\t\t\tzend_hash_internal_pointer_reset_ex(arr, &pos);\n\t\t\twhile(zend_hash_get_current_data_ex(arr, (void **)&data, &pos) != FAILURE) {\n\t\t\t\tif(Z_TYPE_PP(data) != IS_STRING) {\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\t\t\t\tif (isFirstSubtag++ == 0){\n\t\t\t\t\tadd_prefix(loc_name , key_name);\n\t\t\t\t}\n\t\t\t\tsmart_str_appendl(loc_name, SEPARATOR , sizeof(SEPARATOR)-1);\n\t\t\t\tsmart_str_appendl(loc_name, Z_STRVAL_PP(data) , Z_STRLEN_PP(data));\n\t\t\t\tzend_hash_move_forward_ex(arr, &pos);\n\t\t\t}\n\t\t\treturn SUCCESS;\n\t\t} else {\n\t\t\treturn FAILURE;\n\t\t}\n\t} else {\n\t\tchar cur_key_name[31];\n\t\t/* Decide the max_value: the max. no. of elements allowed */\n\t\tif( strcmp(key_name , LOC_VARIANT_TAG) ==0 ){\n\t\t\tmax_value  = MAX_NO_VARIANT;\n\t\t}\n\t\tif( strcmp(key_name , LOC_EXTLANG_TAG) ==0 ){\n\t\t\tmax_value  = MAX_NO_EXTLANG;\n\t\t}\n\t\tif( strcmp(key_name , LOC_PRIVATE_TAG) ==0 ){\n\t\t\tmax_value  = MAX_NO_PRIVATE;\n\t\t}\n\n\t\t/* Multiple variant values as variant0, variant1 ,variant2 */\n\t\tisFirstSubtag = 0;\n\t\tfor( i=0 ; i< max_value; i++ ){\n\t\t\tsnprintf( cur_key_name , 30, \"%s%d\", key_name , i);\n\t\t\tif( zend_hash_find( hash_arr , cur_key_name , strlen(cur_key_name) + 1,(void **)&ele_value ) == SUCCESS ){\n\t\t\t\tif( Z_TYPE_PP(ele_value)!= IS_STRING ){\n\t\t\t\t\t/* variant is not a string */\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\t\t\t\t/* Add the contents */\n\t\t\t\tif (isFirstSubtag++ == 0){\n\t\t\t\t\tadd_prefix(loc_name , cur_key_name);\n\t\t\t\t}\n\t\t\t\tsmart_str_appendl(loc_name, SEPARATOR , sizeof(SEPARATOR)-1);\n\t\t\t\tsmart_str_appendl(loc_name, Z_STRVAL_PP(ele_value) , Z_STRLEN_PP(ele_value));\n\t\t\t}\n\t\t} /* end of for */\n\t} /* end of else */\n\n\treturn SUCCESS;\n}\n/* }}} */\n\n/*{{{\n* If applicable sets error message and aborts locale_compose gracefully\n* returns 0  if locale_compose needs to be aborted\n* otherwise returns 1\n*/\nstatic int handleAppendResult( int result, smart_str* loc_name TSRMLS_DC)\n{\n\tintl_error_reset( NULL TSRMLS_CC );\n\tif( result == FAILURE) {\n\t\tintl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,\n\t\t\t \"locale_compose: parameter array element is not a string\", 0 TSRMLS_CC );\n\t\tsmart_str_free(loc_name);\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n/* }}} */\n\n#define RETURN_SMART_STR(s) smart_str_0((s)); RETURN_STRINGL((s)->c, (s)->len, 0)\n/* {{{ proto static string Locale::composeLocale($array)\n* Creates a locale by combining the parts of locale-ID passed\n* }}} */\n/* {{{ proto static string compose_locale($array)\n* Creates a locale by combining the parts of locale-ID passed\n* }}} */\nPHP_FUNCTION(locale_compose)\n{\n\tsmart_str      \tloc_name_s = {0};\n\tsmart_str *loc_name = &loc_name_s;\n\tzval*\t\t\tarr\t= NULL;\n\tHashTable*\t\thash_arr = NULL;\n\tint \t\t\tresult = 0;\n\n\tintl_error_reset( NULL TSRMLS_CC );\n\n\tif(zend_parse_parameters( ZEND_NUM_ARGS() TSRMLS_CC, \"a\",\n\t\t&arr) == FAILURE)\n\t{\n\t\tintl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,\n\t\t\t \"locale_compose: unable to parse input params\", 0 TSRMLS_CC );\n\t\tRETURN_FALSE;\n\t}\n\n\thash_arr = HASH_OF( arr );\n\n\tif( !hash_arr || zend_hash_num_elements( hash_arr ) == 0 )\n\t\tRETURN_FALSE;\n\n\t/* Check for grandfathered first */\n\tresult = append_key_value(loc_name, hash_arr,  LOC_GRANDFATHERED_LANG_TAG);\n\tif( result == SUCCESS){\n\t\tRETURN_SMART_STR(loc_name);\n\t}\n\tif( !handleAppendResult( result, loc_name TSRMLS_CC)){\n\t\tRETURN_FALSE;\n\t}\n\n\t/* Not grandfathered */\n\tresult = append_key_value(loc_name, hash_arr , LOC_LANG_TAG);\n\tif( result == LOC_NOT_FOUND ){\n\t\tintl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,\n\t\t\"locale_compose: parameter array does not contain 'language' tag.\", 0 TSRMLS_CC );\n\t\tsmart_str_free(loc_name);\n\t\tRETURN_FALSE;\n\t}\n\tif( !handleAppendResult( result, loc_name TSRMLS_CC)){\n\t\tRETURN_FALSE;\n\t}\n\n\t/* Extlang */\n\tresult = append_multiple_key_values(loc_name, hash_arr , LOC_EXTLANG_TAG TSRMLS_CC);\n\tif( !handleAppendResult( result, loc_name TSRMLS_CC)){\n\t\tRETURN_FALSE;\n\t}\n\n\t/* Script */\n\tresult = append_key_value(loc_name, hash_arr , LOC_SCRIPT_TAG);\n\tif( !handleAppendResult( result, loc_name TSRMLS_CC)){\n\t\tRETURN_FALSE;\n\t}\n\n\t/* Region */\n\tresult = append_key_value( loc_name, hash_arr , LOC_REGION_TAG);\n\tif( !handleAppendResult( result, loc_name TSRMLS_CC)){\n\t\tRETURN_FALSE;\n\t}\n\n\t/* Variant */\n\tresult = append_multiple_key_values( loc_name, hash_arr , LOC_VARIANT_TAG TSRMLS_CC);\n\tif( !handleAppendResult( result, loc_name TSRMLS_CC)){\n\t\tRETURN_FALSE;\n\t}\n\n\t/* Private */\n\tresult = append_multiple_key_values( loc_name, hash_arr , LOC_PRIVATE_TAG TSRMLS_CC);\n\tif( !handleAppendResult( result, loc_name TSRMLS_CC)){\n\t\tRETURN_FALSE;\n\t}\n\n\tRETURN_SMART_STR(loc_name);\n}\n/* }}} */\n\n\n/*{{{\n* Parses the locale and returns private subtags  if existing\n* else returns NULL\n* e.g. for locale='en_US-x-prv1-prv2-prv3'\n* returns a pointer to the string 'prv1-prv2-prv3'\n*/\nstatic char* get_private_subtags(const char* loc_name)\n{\n\tchar* \tresult =NULL;\n\tint \tsingletonPos = 0;\n\tint \tlen =0;\n\tconst char* \tmod_loc_name =NULL;\n\n\tif( loc_name && (len = strlen(loc_name)>0 ) ){\n\t\tmod_loc_name = loc_name ;\n\t\tlen   = strlen(mod_loc_name);\n\t\twhile( (singletonPos = getSingletonPos(mod_loc_name))!= -1){\n\n\t\t\tif( singletonPos!=-1){\n\t\t\t\tif( (*(mod_loc_name+singletonPos)=='x') || (*(mod_loc_name+singletonPos)=='X') ){\n\t\t\t\t\t/* private subtag start found */\n\t\t\t\t\tif( singletonPos + 2 ==  len){\n\t\t\t\t\t\t/* loc_name ends with '-x-' ; return  NULL */\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\t/* result = mod_loc_name + singletonPos +2; */\n\t\t\t\t\t\tresult = estrndup(mod_loc_name + singletonPos+2  , (len -( singletonPos +2) ) );\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif( singletonPos + 1 >=  len){\n\t\t\t\t\t\t/* String end */\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* singleton found but not a private subtag , hence check further in the string for the private subtag */\n\t\t\t\t\t\tmod_loc_name = mod_loc_name + singletonPos +1;\n\t\t\t\t\t\tlen = strlen(mod_loc_name);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t} /* end of while */\n\t}\n\n\treturn result;\n}\n/* }}} */\n\n/* {{{ code used by locale_parse\n*/\nstatic int add_array_entry(const char* loc_name, zval* hash_arr, char* key_name TSRMLS_DC)\n{\n\tchar*   key_value \t= NULL;\n\tchar*   cur_key_name\t= NULL;\n\tchar*   token        \t= NULL;\n\tchar*   last_ptr  \t= NULL;\n\n\tint\tresult\t\t= 0;\n\tint \tcur_result  \t= 0;\n\tint \tcnt  \t\t= 0;\n\n\n\tif( strcmp(key_name , LOC_PRIVATE_TAG)==0 ){\n\t\tkey_value = get_private_subtags( loc_name );\n\t\tresult = 1;\n\t} else {\n\t\tkey_value = get_icu_value_internal( loc_name , key_name , &result,1 );\n\t}\n\tif( (strcmp(key_name , LOC_PRIVATE_TAG)==0) ||\n\t\t( strcmp(key_name , LOC_VARIANT_TAG)==0) ){\n\t\tif( result > 0 && key_value){\n\t\t\t/* Tokenize on the \"_\" or \"-\"  */\n\t\t\ttoken = php_strtok_r( key_value , DELIMITER ,&last_ptr);\n\t\t\tif( cur_key_name ){\n\t\t\t\tefree( cur_key_name);\n\t\t\t}\n\t\t\tcur_key_name = (char*)ecalloc( 25,  25);\n\t\t\tsprintf( cur_key_name , \"%s%d\", key_name , cnt++);\n\t\t\tadd_assoc_string( hash_arr, cur_key_name , token ,TRUE );\n\t\t\t/* tokenize on the \"_\" or \"-\" and stop  at singleton if any */\n\t\t\twhile( (token = php_strtok_r(NULL , DELIMITER , &last_ptr)) && (strlen(token)>1) ){\n\t\t\t\tsprintf( cur_key_name , \"%s%d\", key_name , cnt++);\n\t\t\t\tadd_assoc_string( hash_arr, cur_key_name , token , TRUE );\n\t\t\t}\n/*\n\t\t\tif( strcmp(key_name, LOC_PRIVATE_TAG) == 0 ){\n\t\t\t}\n*/\n\t\t}\n\t} else {\n\t\tif( result == 1 ){\n\t\t\tadd_assoc_string( hash_arr, key_name , key_value , TRUE );\n\t\t\tcur_result = 1;\n\t\t}\n\t}\n\n\tif( cur_key_name ){\n\t\tefree( cur_key_name);\n\t}\n\t/*if( key_name != LOC_PRIVATE_TAG && key_value){*/\n\tif( key_value){\n\t\tefree(key_value);\n\t}\n\treturn cur_result;\n}\n/* }}} */\n\n/* {{{ proto static array Locale::parseLocale($locale)\n* parses a locale-id into an array the different parts of it\n }}} */\n/* {{{ proto static array parse_locale($locale)\n* parses a locale-id into an array the different parts of it\n*/\nPHP_FUNCTION(locale_parse)\n{\n    const char* loc_name        = NULL;\n    int         loc_name_len    = 0;\n    int         grOffset    \t= 0;\n\n    intl_error_reset( NULL TSRMLS_CC );\n\n    if(zend_parse_parameters( ZEND_NUM_ARGS() TSRMLS_CC, \"s\",\n        &loc_name, &loc_name_len ) == FAILURE)\n    {\n        intl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,\n             \"locale_parse: unable to parse input params\", 0 TSRMLS_CC );\n\n        RETURN_FALSE;\n    }\n\n    if(loc_name_len == 0) {\n        loc_name = intl_locale_get_default(TSRMLS_C);\n    }\n\n\tarray_init( return_value );\n\n\tgrOffset =  findOffset( LOC_GRANDFATHERED , loc_name );\n\tif( grOffset >= 0 ){\n\t\tadd_assoc_string( return_value , LOC_GRANDFATHERED_LANG_TAG , estrdup(loc_name) ,FALSE );\n\t}\n\telse{\n\t\t/* Not grandfathered */\n\t\tadd_array_entry( loc_name , return_value , LOC_LANG_TAG TSRMLS_CC);\n\t\tadd_array_entry( loc_name , return_value , LOC_SCRIPT_TAG TSRMLS_CC);\n\t\tadd_array_entry( loc_name , return_value , LOC_REGION_TAG TSRMLS_CC);\n\t\tadd_array_entry( loc_name , return_value , LOC_VARIANT_TAG TSRMLS_CC);\n\t\tadd_array_entry( loc_name , return_value , LOC_PRIVATE_TAG TSRMLS_CC);\n\t}\n}\n/* }}} */\n\n/* {{{ proto static array Locale::getAllVariants($locale)\n* gets an array containing the list of variants, or null\n }}} */\n/* {{{ proto static array locale_get_all_variants($locale)\n* gets an array containing the list of variants, or null\n*/\nPHP_FUNCTION(locale_get_all_variants)\n{\n\tconst char*  \tloc_name        = NULL;\n\tint    \t\tloc_name_len    = 0;\n\n\tint\tresult\t\t= 0;\n\tchar*\ttoken\t\t= NULL;\n\tchar*\tvariant\t\t= NULL;\n\tchar*\tsaved_ptr\t= NULL;\n\n\tintl_error_reset( NULL TSRMLS_CC );\n\n\tif(zend_parse_parameters( ZEND_NUM_ARGS() TSRMLS_CC, \"s\",\n\t&loc_name, &loc_name_len ) == FAILURE)\n\t{\n\t\tintl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,\n\t     \"locale_parse: unable to parse input params\", 0 TSRMLS_CC );\n\n\t\tRETURN_FALSE;\n\t}\n\n\tif(loc_name_len == 0) {\n\t\tloc_name = intl_locale_get_default(TSRMLS_C);\n\t}\n\n\n\tarray_init( return_value );\n\n\t/* If the locale is grandfathered, stop, no variants */\n\tif( findOffset( LOC_GRANDFATHERED , loc_name ) >=  0 ){\n\t\t/* (\"Grandfathered Tag. No variants.\"); */\n\t}\n\telse {\n\t/* Call ICU variant */\n\t\tvariant = get_icu_value_internal( loc_name , LOC_VARIANT_TAG , &result ,0);\n\t\tif( result > 0 && variant){\n\t\t\t/* Tokenize on the \"_\" or \"-\" */\n\t\t\ttoken = php_strtok_r( variant , DELIMITER , &saved_ptr);\n\t\t\tadd_next_index_stringl( return_value, token , strlen(token) ,TRUE );\n\t\t\t/* tokenize on the \"_\" or \"-\" and stop  at singleton if any\t*/\n\t\t\twhile( (token = php_strtok_r(NULL , DELIMITER, &saved_ptr)) && (strlen(token)>1) ){\n \t\t\t\tadd_next_index_stringl( return_value, token , strlen(token) ,TRUE );\n\t\t\t}\n\t\t}\n\t\tif( variant ){\n\t\t\tefree( variant );\n\t\t}\n\t}\n\n\n}\n/* }}} */\n\n/*{{{\n* Converts to lower case and also replaces all hyphens with the underscore\n*/\nstatic int strToMatch(const char* str ,char *retstr)\n{\n\tchar* \tanchor \t= NULL;\n\tconst char* \tanchor1 = NULL;\n\tint \tresult \t= 0;\n\n    if( (!str) || str[0] == '\\0'){\n        return result;\n    } else {\n\tanchor = retstr;\n\tanchor1 = str;\n        while( (*str)!='\\0' ){\n\t\tif( *str == '-' ){\n\t\t\t*retstr =  '_';\n\t\t} else {\n\t\t\t*retstr = tolower(*str);\n\t\t}\n            str++;\n            retstr++;\n\t}\n\t*retstr = '\\0';\n\tretstr=  anchor;\n\tstr=  anchor1;\n\tresult = 1;\n    }\n\n    return(result);\n}\n/* }}} */\n\n/* {{{ proto static boolean Locale::filterMatches(string $langtag, string $locale[, bool $canonicalize])\n* Checks if a $langtag filter matches with $locale according to RFC 4647's basic filtering algorithm\n*/\n/* }}} */\n/* {{{ proto boolean locale_filter_matches(string $langtag, string $locale[, bool $canonicalize])\n* Checks if a $langtag filter matches with $locale according to RFC 4647's basic filtering algorithm\n*/\nPHP_FUNCTION(locale_filter_matches)\n{\n\tchar*       \tlang_tag        = NULL;\n\tint         \tlang_tag_len    = 0;\n\tconst char*     loc_range       = NULL;\n\tint         \tloc_range_len   = 0;\n\n\tint\t\tresult\t\t= 0;\n\tchar*\t\ttoken\t\t= 0;\n\tchar*\t\tchrcheck\t= NULL;\n\n\tchar*       \tcan_lang_tag    = NULL;\n\tchar*       \tcan_loc_range   = NULL;\n\n\tchar*       \tcur_lang_tag    = NULL;\n\tchar*       \tcur_loc_range   = NULL;\n\n\tzend_bool \tboolCanonical \t= 0;\n\tUErrorCode\tstatus\t\t= U_ZERO_ERROR;\n\n\tintl_error_reset( NULL TSRMLS_CC );\n\n\tif(zend_parse_parameters( ZEND_NUM_ARGS() TSRMLS_CC, \"ss|b\",\n\t\t&lang_tag, &lang_tag_len , &loc_range , &loc_range_len ,\n\t\t&boolCanonical) == FAILURE)\n\t{\n\t\tintl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,\n\t\t\"locale_filter_matches: unable to parse input params\", 0 TSRMLS_CC );\n\n\t\tRETURN_FALSE;\n\t}\n\n\tif(loc_range_len == 0) {\n\t\tloc_range = intl_locale_get_default(TSRMLS_C);\n\t}\n\n\tif( strcmp(loc_range,\"*\")==0){\n\t\tRETURN_TRUE;\n\t}\n\n\tif( boolCanonical ){\n\t\t/* canonicalize loc_range */\n\t\tcan_loc_range=get_icu_value_internal( loc_range , LOC_CANONICALIZE_TAG , &result , 0);\n\t\tif( result ==0) {\n\t\t\tintl_error_set( NULL, status,\n\t\t\t\t\"locale_filter_matches : unable to canonicalize loc_range\" , 0 TSRMLS_CC );\n\t\t\tRETURN_FALSE;\n\t\t}\n\n\t\t/* canonicalize lang_tag */\n\t\tcan_lang_tag = get_icu_value_internal( lang_tag , LOC_CANONICALIZE_TAG , &result ,  0);\n\t\tif( result ==0) {\n\t\t\tintl_error_set( NULL, status,\n\t\t\t\t\"locale_filter_matches : unable to canonicalize lang_tag\" , 0 TSRMLS_CC );\n\t\t\tRETURN_FALSE;\n\t\t}\n\n\t\t/* Convert to lower case for case-insensitive comparison */\n\t\tcur_lang_tag = ecalloc( 1, strlen(can_lang_tag) + 1);\n\n\t\t/* Convert to lower case for case-insensitive comparison */\n\t\tresult = strToMatch( can_lang_tag , cur_lang_tag);\n\t\tif( result == 0) {\n\t\t\tefree( cur_lang_tag );\n\t\t\tefree( can_lang_tag );\n\t\t\tRETURN_FALSE;\n\t\t}\n\n\t\tcur_loc_range = ecalloc( 1, strlen(can_loc_range) + 1);\n\t\tresult = strToMatch( can_loc_range , cur_loc_range );\n\t\tif( result == 0) {\n\t\t\tefree( cur_lang_tag );\n\t\t\tefree( can_lang_tag );\n\t\t\tefree( cur_loc_range );\n\t\t\tefree( can_loc_range );\n\t\t\tRETURN_FALSE;\n\t\t}\n\n\t\t/* check if prefix */\n\t\ttoken \t= strstr( cur_lang_tag , cur_loc_range );\n\n\t\tif( token && (token==cur_lang_tag) ){\n\t\t\t/* check if the char. after match is SEPARATOR */\n\t\t\tchrcheck = token + (strlen(cur_loc_range));\n\t\t\tif( isIDSeparator(*chrcheck) || isEndOfTag(*chrcheck) ){\n\t\t\t\tif( cur_lang_tag){\n\t\t\t\t\tefree( cur_lang_tag );\n\t\t\t\t}\n\t\t\t\tif( cur_loc_range){\n\t\t\t\t\tefree( cur_loc_range );\n\t\t\t\t}\n\t\t\t\tif( can_lang_tag){\n\t\t\t\t\tefree( can_lang_tag );\n\t\t\t\t}\n\t\t\t\tif( can_loc_range){\n\t\t\t\t\tefree( can_loc_range );\n\t\t\t\t}\n\t\t\t\tRETURN_TRUE;\n\t\t\t}\n\t\t}\n\n\t\t/* No prefix as loc_range */\n\t\tif( cur_lang_tag){\n\t\t\tefree( cur_lang_tag );\n\t\t}\n\t\tif( cur_loc_range){\n\t\t\tefree( cur_loc_range );\n\t\t}\n\t\tif( can_lang_tag){\n\t\t\tefree( can_lang_tag );\n\t\t}\n\t\tif( can_loc_range){\n\t\t\tefree( can_loc_range );\n\t\t}\n\t\tRETURN_FALSE;\n\n\t} /* end of if isCanonical */\n\telse{\n\t\t/* Convert to lower case for case-insensitive comparison */\n\t\tcur_lang_tag = ecalloc( 1, strlen(lang_tag ) + 1);\n\n\t\tresult = strToMatch( lang_tag , cur_lang_tag);\n\t\tif( result == 0) {\n\t\t\tefree( cur_lang_tag );\n\t\t\tRETURN_FALSE;\n\t\t}\n\t\tcur_loc_range = ecalloc( 1, strlen(loc_range ) + 1);\n\t\tresult = strToMatch( loc_range , cur_loc_range );\n\t\tif( result == 0) {\n\t\t\tefree( cur_lang_tag );\n\t\t\tefree( cur_loc_range );\n\t\t\tRETURN_FALSE;\n\t\t}\n\n\t\t/* check if prefix */\n\t\ttoken \t= strstr( cur_lang_tag , cur_loc_range );\n\n\t\tif( token && (token==cur_lang_tag) ){\n\t\t\t/* check if the char. after match is SEPARATOR */\n\t\t\tchrcheck = token + (strlen(cur_loc_range));\n\t\t\tif( isIDSeparator(*chrcheck) || isEndOfTag(*chrcheck) ){\n\t\t\t\tif( cur_lang_tag){\n\t\t\t\t\tefree( cur_lang_tag );\n\t\t\t\t}\n\t\t\t\tif( cur_loc_range){\n\t\t\t\t\tefree( cur_loc_range );\n\t\t\t\t}\n\t\t\t\tRETURN_TRUE;\n\t\t\t}\n\t\t}\n\n\t\t/* No prefix as loc_range */\n\t\tif( cur_lang_tag){\n\t\t\tefree( cur_lang_tag );\n\t\t}\n\t\tif( cur_loc_range){\n\t\t\tefree( cur_loc_range );\n\t\t}\n\t\tRETURN_FALSE;\n\n\t}\n}\n/* }}} */\n\nstatic void array_cleanup( char* arr[] , int arr_size)\n{\n\tint i=0;\n\tfor( i=0; i< arr_size; i++ ){\n\t\tif( arr[i*2] ){\n\t\t\tefree( arr[i*2]);\n\t\t}\n\t}\n\tefree(arr);\n}\n\n#define LOOKUP_CLEAN_RETURN(value)\tarray_cleanup(cur_arr, cur_arr_len); return (value)\n/* {{{\n* returns the lookup result to lookup_loc_range_src_php\n* internal function\n*/\nstatic char* lookup_loc_range(const char* loc_range, HashTable* hash_arr, int canonicalize  TSRMLS_DC)\n{\n\tint\ti = 0;\n\tint\tcur_arr_len = 0;\n\tint result = 0;\n\n\tchar* lang_tag = NULL;\n\tzval** ele_value = NULL;\n\tchar** cur_arr = NULL;\n\n\tchar* cur_loc_range\t= NULL;\n\tchar* can_loc_range\t= NULL;\n\tint\tsaved_pos = 0;\n\n\tchar* return_value = NULL;\n\n\tcur_arr = ecalloc(zend_hash_num_elements(hash_arr)*2, sizeof(char *));\n\t/* convert the array to lowercase , also replace hyphens with the underscore and store it in cur_arr */\n\tfor(zend_hash_internal_pointer_reset(hash_arr);\n\t\tzend_hash_has_more_elements(hash_arr) == SUCCESS;\n\t\tzend_hash_move_forward(hash_arr)) {\n\n\t\tif (zend_hash_get_current_data(hash_arr, (void**)&ele_value) == FAILURE) {\n\t\t\t/* Should never actually fail since the key is known to exist.*/\n\t\t\tcontinue;\n\t\t}\n\t\tif(Z_TYPE_PP(ele_value)!= IS_STRING) {\n\t\t\t/* element value is not a string */\n\t\t\tintl_error_set(NULL, U_ILLEGAL_ARGUMENT_ERROR, \"lookup_loc_range: locale array element is not a string\", 0 TSRMLS_CC);\n\t\t\tLOOKUP_CLEAN_RETURN(NULL);\n\t\t}\n\t\tcur_arr[cur_arr_len*2] = estrndup(Z_STRVAL_PP(ele_value), Z_STRLEN_PP(ele_value));\n\t\tresult = strToMatch(Z_STRVAL_PP(ele_value), cur_arr[cur_arr_len*2]);\n\t\tif(result == 0) {\n\t\t\tintl_error_set(NULL, U_ILLEGAL_ARGUMENT_ERROR, \"lookup_loc_range: unable to canonicalize lang_tag\", 0 TSRMLS_CC);\n\t\t\tLOOKUP_CLEAN_RETURN(NULL);\n\t\t}\n\t\tcur_arr[cur_arr_len*2+1] = Z_STRVAL_PP(ele_value);\n\t\tcur_arr_len++ ;\n\t} /* end of for */\n\n\t/* Canonicalize array elements */\n\tif(canonicalize) {\n\t\tfor(i=0; i<cur_arr_len; i++) {\n\t\t\tlang_tag = get_icu_value_internal(cur_arr[i*2], LOC_CANONICALIZE_TAG, &result, 0);\n\t\t\tif(result != 1 || lang_tag == NULL || !lang_tag[0]) {\n\t\t\t\tif(lang_tag) {\n\t\t\t\t\tefree(lang_tag);\n\t\t\t\t}\n\t\t\t\tintl_error_set(NULL, U_ILLEGAL_ARGUMENT_ERROR, \"lookup_loc_range: unable to canonicalize lang_tag\" , 0 TSRMLS_CC);\n\t\t\t\tLOOKUP_CLEAN_RETURN(NULL);\n\t\t\t}\n\t\t\tcur_arr[i*2] = erealloc(cur_arr[i*2], strlen(lang_tag)+1);\n\t\t\tresult = strToMatch(lang_tag, cur_arr[i*2]);\n\t\t\tefree(lang_tag);\n\t\t\tif(result == 0) {\n\t\t\t\tintl_error_set(NULL, U_ILLEGAL_ARGUMENT_ERROR, \"lookup_loc_range: unable to canonicalize lang_tag\" , 0 TSRMLS_CC);\n\t\t\t\tLOOKUP_CLEAN_RETURN(NULL);\n\t\t\t}\n\t\t}\n\n\t}\n\n\tif(canonicalize) {\n\t\t/* Canonicalize the loc_range */\n\t\tcan_loc_range = get_icu_value_internal(loc_range, LOC_CANONICALIZE_TAG, &result , 0);\n\t\tif( result != 1 || can_loc_range == NULL || !can_loc_range[0]) {\n\t\t\t/* Error */\n\t\t\tintl_error_set(NULL, U_ILLEGAL_ARGUMENT_ERROR, \"lookup_loc_range: unable to canonicalize loc_range\" , 0 TSRMLS_CC );\n\t\t\tif(can_loc_range) {\n\t\t\t\tefree(can_loc_range);\n\t\t\t}\n\t\t\tLOOKUP_CLEAN_RETURN(NULL);\n\t\t} else {\n\t\t\tloc_range = can_loc_range;\n\t\t}\n\t}\n\n\tcur_loc_range = ecalloc(1, strlen(loc_range)+1);\n\t/* convert to lower and replace hyphens */\n\tresult = strToMatch(loc_range, cur_loc_range);\n\tif(can_loc_range) {\n\t\tefree(can_loc_range);\n\t}\n\tif(result == 0) {\n\t\tintl_error_set(NULL, U_ILLEGAL_ARGUMENT_ERROR, \"lookup_loc_range: unable to canonicalize lang_tag\" , 0 TSRMLS_CC);\n\t\tLOOKUP_CLEAN_RETURN(NULL);\n\t}\n\n\t/* Lookup for the lang_tag match */\n\tsaved_pos = strlen(cur_loc_range);\n\twhile(saved_pos > 0) {\n\t\tfor(i=0; i< cur_arr_len; i++){\n\t\t\tif(cur_arr[i*2] != NULL && strlen(cur_arr[i*2]) == saved_pos && strncmp(cur_loc_range, cur_arr[i*2], saved_pos) == 0) {\n\t\t\t\t/* Match found */\n\t\t\t\treturn_value = estrdup(canonicalize?cur_arr[i*2]:cur_arr[i*2+1]);\n\t\t\t\tefree(cur_loc_range);\n\t\t\t\tLOOKUP_CLEAN_RETURN(return_value);\n\t\t\t}\n\t\t}\n\t\tsaved_pos = getStrrtokenPos(cur_loc_range, saved_pos);\n\t}\n\n\t/* Match not found */\n\tefree(cur_loc_range);\n\tLOOKUP_CLEAN_RETURN(NULL);\n}\n/* }}} */\n\n/* {{{ proto string Locale::lookup(array $langtag, string $locale[, bool $canonicalize[, string $default = null]])\n* Searchs the items in $langtag for the best match to the language\n* range\n*/\n/* }}} */\n/* {{{ proto string locale_lookup(array $langtag, string $locale[, bool $canonicalize[, string $default = null]])\n* Searchs the items in $langtag for the best match to the language\n* range\n*/\nPHP_FUNCTION(locale_lookup)\n{\n\tchar*      \tfallback_loc  \t\t= NULL;\n\tint        \tfallback_loc_len\t= 0;\n\tconst char*    \tloc_range      \t\t= NULL;\n\tint        \tloc_range_len  \t\t= 0;\n\n\tzval*\t\tarr\t\t\t\t= NULL;\n\tHashTable*\thash_arr\t\t= NULL;\n\tzend_bool\tboolCanonical\t= 0;\n\tchar*\t \tresult\t\t\t=NULL;\n\n\tintl_error_reset( NULL TSRMLS_CC );\n\n\tif(zend_parse_parameters( ZEND_NUM_ARGS() TSRMLS_CC, \"as|bs\", &arr, &loc_range, &loc_range_len,\n\t\t&boolCanonical,\t&fallback_loc, &fallback_loc_len) == FAILURE) {\n\t\tintl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,\t\"locale_lookup: unable to parse input params\", 0 TSRMLS_CC );\n\t\tRETURN_FALSE;\n\t}\n\n\tif(loc_range_len == 0) {\n\t\tloc_range = intl_locale_get_default(TSRMLS_C);\n\t}\n\n\thash_arr = HASH_OF(arr);\n\n\tif( !hash_arr || zend_hash_num_elements( hash_arr ) == 0 ) {\n\t\tRETURN_EMPTY_STRING();\n\t}\n\n\tresult = lookup_loc_range(loc_range, hash_arr, boolCanonical TSRMLS_CC);\n\tif(result == NULL || result[0] == '\\0') {\n\t\tif( fallback_loc ) {\n\t\t\tresult = estrndup(fallback_loc, fallback_loc_len);\n\t\t} else {\n\t\t\tRETURN_EMPTY_STRING();\n\t\t}\n\t}\n\n\tRETVAL_STRINGL(result, strlen(result), 0);\n}\n/* }}} */\n\n/* {{{ proto string Locale::acceptFromHttp(string $http_accept)\n* Tries to find out best available locale based on HTTP \ufffdAccept-Language\ufffd header\n*/\n/* }}} */\n/* {{{ proto string locale_accept_from_http(string $http_accept)\n* Tries to find out best available locale based on HTTP \ufffdAccept-Language\ufffd header\n*/\nPHP_FUNCTION(locale_accept_from_http)\n{\n\tUEnumeration *available;\n\tchar *http_accept = NULL;\n\tint http_accept_len;\n\tUErrorCode status = 0;\n\tint len;\n\tchar resultLocale[INTL_MAX_LOCALE_LEN+1];\n\tUAcceptResult outResult;\n\n\tif(zend_parse_parameters( ZEND_NUM_ARGS() TSRMLS_CC, \"s\", &http_accept, &http_accept_len) == FAILURE)\n\t{\n\t\tintl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,\n\t\t\"locale_accept_from_http: unable to parse input parameters\", 0 TSRMLS_CC );\n\t\tRETURN_FALSE;\n\t}\n\n\tavailable = ures_openAvailableLocales(NULL, &status);\n\tINTL_CHECK_STATUS(status, \"locale_accept_from_http: failed to retrieve locale list\");\n\tlen = uloc_acceptLanguageFromHTTP(resultLocale, INTL_MAX_LOCALE_LEN,\n\t\t\t\t\t\t&outResult, http_accept, available, &status);\n\tuenum_close(available);\n\tINTL_CHECK_STATUS(status, \"locale_accept_from_http: failed to find acceptable locale\");\n\tif (len < 0 || outResult == ULOC_ACCEPT_FAILED) {\n\t\tRETURN_FALSE;\n\t}\n\tRETURN_STRINGL(resultLocale, len, 1);\n}\n/* }}} */\n\n/*\n * Local variables:\n * tab-width: 4\n * c-basic-offset: 4\n * End:\n * vim600: noet sw=4 ts=4 fdm=marker\n * vim<600: noet sw=4 ts=4\n *can_loc_len\n*/\n", "code_before": "/*\n   +----------------------------------------------------------------------+\n   | This source file is subject to version 3.01 of the PHP license,      |\n   | that is bundled with this package in the file LICENSE, and is        |\n   | available through the world-wide-web at the following url:           |\n   | https://www.php.net/license/3_01.txt                                 |\n   | If you did not receive a copy of the PHP license and are unable to   |\n   | obtain it through the world-wide-web, please send a note to          |\n   | license@php.net so we can mail you a copy immediately.               |\n   +----------------------------------------------------------------------+\n   | Authors: Kirti Velankar <kirtig@yahoo-inc.com>                       |\n   +----------------------------------------------------------------------+\n*/\n\n#ifdef HAVE_CONFIG_H\n#include <config.h>\n#endif\n\n#include <unicode/ustring.h>\n#include <unicode/udata.h>\n#include <unicode/putil.h>\n#include <unicode/ures.h>\n\n#include \"php_intl.h\"\n#include \"locale.h\"\n#include \"locale_class.h\"\n#include \"intl_convert.h\"\n#include \"intl_data.h\"\n\n#include <zend_API.h>\n#include <zend.h>\n#include <php.h>\n#include \"main/php_ini.h\"\n#include \"zend_smart_str.h\"\n\nZEND_EXTERN_MODULE_GLOBALS( intl )\n\n/* Sizes required for the strings \"variant15\" , \"extlang11\", \"private12\" etc. */\n#define SEPARATOR \"_\"\n#define SEPARATOR1 \"-\"\n#define DELIMITER \"-_\"\n#define EXTLANG_PREFIX \"a\"\n#define PRIVATE_PREFIX \"x\"\n#define DISP_NAME \"name\"\n\n#define MAX_NO_VARIANT  15\n#define MAX_NO_EXTLANG  3\n#define MAX_NO_PRIVATE  15\n#define MAX_NO_LOOKUP_LANG_TAG  100\n\n#define LOC_NOT_FOUND 1\n\n/* Sizes required for the strings \"variant15\" , \"extlang3\", \"private12\" etc. */\n#define VARIANT_KEYNAME_LEN  11\n#define EXTLANG_KEYNAME_LEN  10\n#define PRIVATE_KEYNAME_LEN  11\n\n/* Based on the IANA language subtag registry (File-Date: 2021-08-06)\n * https://www.iana.org/assignments/language-subtag-registry\n *\n * This list includes all grandfathered tags, as well as redundant\n * tags that have a Preferred-Value.\n */\nstatic const char * const LOC_GRANDFATHERED[] = {\n\t\"art-lojban\",\n\t\"cel-gaulish\",\n\t\"en-GB-oed\",\n\t\"i-ami\",\n\t\"i-bnn\",\n\t\"i-default\",\n\t\"i-enochian\",\n\t\"i-hak\",\n\t\"i-klingon\",\n\t\"i-lux\",\n\t\"i-mingo\",\n\t\"i-navajo\",\n\t\"i-pwn\",\n\t\"i-tao\",\n\t\"i-tay\",\n\t\"i-tsu\",\n\t\"no-bok\",\n\t\"no-nyn\",\n\t\"sgn-BE-FR\",\n\t\"sgn-BE-NL\",\n\t\"sgn-BR\",\n\t\"sgn-CH-DE\",\n\t\"sgn-CO\",\n\t\"sgn-DE\",\n\t\"sgn-DK\",\n\t\"sgn-ES\",\n\t\"sgn-FR\",\n\t\"sgn-GB\",\n\t\"sgn-GR\",\n\t\"sgn-IE\",\n\t\"sgn-IT\",\n\t\"sgn-JP\",\n\t\"sgn-MX\",\n\t\"sgn-NI\",\n\t\"sgn-NL\",\n\t\"sgn-NO\",\n\t\"sgn-PT\",\n\t\"sgn-SE\",\n\t\"sgn-US\",\n\t\"sgn-ZA\",\n\t\"zh-cmn\",\n\t\"zh-cmn-Hans\",\n\t\"zh-cmn-Hant\",\n\t\"zh-gan\",\n\t\"zh-guoyu\",\n\t\"zh-hakka\",\n\t\"zh-min\",\n\t\"zh-min-nan\",\n\t\"zh-wuu\",\n\t\"zh-xiang\",\n\tNULL\n};\n\n/* Based on the IANA language subtag registry (File-Date: 2021-08-06)\n *\n * This array lists the preferred values for the grandfathered and redundant\n * tags listed in LOC_GRANDFATHERED. This is in sync with the array\n * LOC_GRANDFATHERED, i.e., the offsets of the grandfathered tags match the\n * offsets of the preferred value. If a value in LOC_PREFERRED_GRANDFATHERED is\n * NULL, then the matching offset in LOC_GRANDFATHERED has no preferred value.\n */\nstatic const char * const LOC_PREFERRED_GRANDFATHERED[] = {\n\t\"jbo\",\n\tNULL,\n\t\"en-GB-oxendict\",\n\t\"ami\",\n\t\"bnn\",\n\tNULL,\n\tNULL,\n\t\"hak\",\n\t\"tlh\",\n\t\"lb\",\n\tNULL,\n\t\"nv\",\n\t\"pwn\",\n\t\"tao\",\n\t\"tay\",\n\t\"tsu\",\n\t\"nb\",\n\t\"nn\",\n\t\"sfb\",\n\t\"vgt\",\n\t\"bzs\",\n\t\"sgg\",\n\t\"csn\",\n\t\"gsg\",\n\t\"dsl\",\n\t\"ssp\",\n\t\"fsl\",\n\t\"bfi\",\n\t\"gss\",\n\t\"isg\",\n\t\"ise\",\n\t\"jsl\",\n\t\"mfs\",\n\t\"ncs\",\n\t\"dse\",\n\t\"nsl\",\n\t\"psr\",\n\t\"swl\",\n\t\"ase\",\n\t\"sfs\",\n\t\"cmn\",\n\t\"cmn-Hans\",\n\t\"cmn-Hant\",\n\t\"gan\",\n\t\"cmn\",\n\t\"hak\",\n\tNULL,\n\t\"nan\",\n\t\"wuu\",\n\t\"hsn\",\n\tNULL\n};\n\n/* returns true if a is an ID separator, false otherwise */\n#define isIDSeparator(a) (a == '_' || a == '-')\n#define isKeywordSeparator(a) (a == '@' )\n#define isEndOfTag(a) (a == '\\0' )\n\n#define isPrefixLetter(a) ((a=='x')||(a=='X')||(a=='i')||(a=='I'))\n\n/*returns true if one of the special prefixes is here (s=string)\n  'x-' or 'i-' */\n#define isIDPrefix(s) (isPrefixLetter(s[0])&&isIDSeparator(s[1]))\n#define isKeywordPrefix(s) ( isKeywordSeparator(s[0]) )\n\n/* Dot terminates it because of POSIX form  where dot precedes the codepage\n * except for variant */\n#define isTerminator(a)  ((a==0)||(a=='.')||(a=='@'))\n\n/* {{{ return the offset of 'key' in the array 'list'.\n * returns -1 if not present */\nstatic int16_t findOffset(const char* const* list, const char* key)\n{\n\tconst char* const* anchor = list;\n\twhile (*list != NULL) {\n\t\tif (strcasecmp(key, *list) == 0) {\n\t\t\treturn (int16_t)(list - anchor);\n\t\t}\n\t\tlist++;\n\t}\n\n\treturn -1;\n\n}\n/*}}}*/\n\nstatic char* getPreferredTag(const char* gf_tag)\n{\n\tchar* result = NULL;\n\tzend_off_t grOffset = 0;\n\n\tgrOffset = findOffset( LOC_GRANDFATHERED ,gf_tag);\n\tif(grOffset < 0) {\n\t\treturn NULL;\n\t}\n\tif( LOC_PREFERRED_GRANDFATHERED[grOffset] != NULL ){\n\t\t/* return preferred tag */\n\t\tresult = estrdup( LOC_PREFERRED_GRANDFATHERED[grOffset] );\n\t} else {\n\t\t/* Return correct grandfathered language tag */\n\t\tresult = estrdup( LOC_GRANDFATHERED[grOffset] );\n\t}\n\treturn result;\n}\n\n/* {{{\n* returns the position of next token for lookup\n* or -1 if no token\n* strtokr equivalent search for token in reverse direction\n*/\nstatic zend_off_t getStrrtokenPos(char* str, zend_off_t savedPos)\n{\n\tzend_off_t result =-1;\n\tzend_off_t i;\n\n\tfor(i=savedPos-1; i>=0; i--) {\n\t\tif(isIDSeparator(*(str+i)) || isKeywordSeparator(*(str+i))){\n\t\t\t/* delimiter found; check for singleton */\n\t\t\tif(i>=2 && isIDSeparator(*(str+i-2)) ){\n\t\t\t\t/* a singleton; so send the position of token before the singleton */\n\t\t\t\tresult = i-2;\n\t\t\t} else {\n\t\t\t\tresult = i;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(result < 1){\n\t\t/* Just in case inavlid locale e.g. '-x-xyz' or '-sl_Latn' */\n\t\tresult =-1;\n\t}\n\treturn result;\n}\n/* }}} */\n\n/* {{{\n* returns the position of a singleton if present\n* returns -1 if no singleton\n* strtok equivalent search for singleton\n*/\nstatic zend_off_t getSingletonPos(const char* str)\n{\n\tzend_off_t result =-1;\n\tsize_t len = 0;\n\n\tif( str && ((len=strlen(str))>0) ){\n\t\tzend_off_t i = 0;\n\t\tfor( i=0; (size_t)i < len ; i++){\n\t\t\tif( isIDSeparator(*(str+i)) ){\n\t\t\t\tif( i==1){\n\t\t\t\t\t/* string is of the form x-avy or a-prv1 */\n\t\t\t\t\tresult =0;\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t/* delimiter found; check for singleton */\n\t\t\t\t\tif( isIDSeparator(*(str+i+2)) ){\n\t\t\t\t\t\t/* a singleton; so send the position of separator before singleton */\n\t\t\t\t\t\tresult = i+1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}/* end of for */\n\n\t}\n\treturn result;\n}\n/* }}} */\n\n/* {{{ Get default locale */\n/* }}} */\n/* {{{ Get default locale */\nPHP_NAMED_FUNCTION(zif_locale_get_default)\n{\n\tZEND_PARSE_PARAMETERS_NONE();\n\n\tRETURN_STRING( intl_locale_get_default(  ) );\n}\n\n/* }}} */\n\n/* {{{ Set default locale */\n/* }}} */\n/* {{{ Set default locale */\nPHP_NAMED_FUNCTION(zif_locale_set_default)\n{\n\tzend_string* locale_name;\n\tzend_string *ini_name;\n\tchar *default_locale = NULL;\n\n\tZEND_PARSE_PARAMETERS_START(1, 1)\n\t\tZ_PARAM_PATH_STR(locale_name)\n\tZEND_PARSE_PARAMETERS_END();\n\n\tif (ZSTR_LEN(locale_name) == 0) {\n\t\tdefault_locale = (char *)uloc_getDefault();\n\t\tlocale_name = zend_string_init(default_locale, strlen(default_locale), 0);\n\t}\n\n\tini_name = zend_string_init(LOCALE_INI_NAME, sizeof(LOCALE_INI_NAME) - 1, 0);\n\tzend_alter_ini_entry(ini_name, locale_name, PHP_INI_USER, PHP_INI_STAGE_RUNTIME);\n\tzend_string_release_ex(ini_name, 0);\n\tif (default_locale != NULL) {\n\t\tzend_string_release_ex(locale_name, 0);\n\t}\n\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{\n* Gets the value from ICU\n* common code shared by get_primary_language,get_script or get_region or get_variant\n* result = 0 if error, 1 if successful , -1 if no value\n*/\nstatic zend_string* get_icu_value_internal( const char* loc_name , char* tag_name, int* result , int fromParseLocale)\n{\n\tzend_string* tag_value\t    = NULL;\n\tint32_t      tag_value_len  = 512;\n\n\tchar*        mod_loc_name   = NULL;\n\n\tint32_t      buflen         = 512;\n\tUErrorCode   status         = U_ZERO_ERROR;\n\n\tif (strlen(loc_name) > INTL_MAX_LOCALE_LEN) {\n\t\treturn NULL;\n\t}\n\n\tif( strcmp(tag_name, LOC_CANONICALIZE_TAG) != 0 ){\n\t\t/* Handle  grandfathered languages */\n\t\tzend_off_t grOffset =  findOffset( LOC_GRANDFATHERED , loc_name );\n\t\tif( grOffset >= 0 ){\n\t\t\tif( strcmp(tag_name , LOC_LANG_TAG)==0 ){\n\t\t\t\treturn zend_string_init(loc_name, strlen(loc_name), 0);\n\t\t\t} else {\n\t\t\t\t/* Since Grandfathered , no value , do nothing , retutn NULL */\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\n\tif( fromParseLocale==1 ){\n\t\tzend_off_t singletonPos = 0;\n\n\t\t/* Handle singletons */\n\t\tif( strcmp(tag_name , LOC_LANG_TAG)==0 ){\n\t\t\tif( strlen(loc_name)>1 && (isIDPrefix(loc_name) == 1) ){\n\t\t\t\treturn zend_string_init(loc_name, strlen(loc_name), 0);\n\t\t\t}\n\t\t}\n\n\t\tsingletonPos = getSingletonPos( loc_name );\n\t\tif( singletonPos == 0){\n\t\t\t/* singleton at start of script, region , variant etc.\n\t\t\t * or invalid singleton at start of language */\n\t\t\treturn NULL;\n\t\t} else if( singletonPos > 0 ){\n\t\t\t/* singleton at some position except at start\n\t\t\t * strip off the singleton and rest of the loc_name */\n\t\t\tmod_loc_name = estrndup ( loc_name , singletonPos-1);\n\t\t}\n\t} /* end of if fromParse */\n\n\t} /* end of if != LOC_CANONICAL_TAG */\n\n\tif( mod_loc_name == NULL){\n\t\tmod_loc_name = estrdup(loc_name );\n\t}\n\n\t/* Proceed to ICU */\n\tdo{\n\t\tif (tag_value) {\n\t\t\ttag_value = zend_string_realloc( tag_value , buflen, 0);\n\t\t} else {\n\t\t\ttag_value = zend_string_alloc( buflen, 0);\n\t\t}\n\t\ttag_value_len = buflen;\n\n\t\tif( strcmp(tag_name , LOC_SCRIPT_TAG)==0 ){\n\t\t\tbuflen = uloc_getScript ( mod_loc_name , tag_value->val , tag_value_len , &status);\n\t\t}\n\t\tif( strcmp(tag_name , LOC_LANG_TAG )==0 ){\n\t\t\tbuflen = uloc_getLanguage ( mod_loc_name , tag_value->val , tag_value_len , &status);\n\t\t}\n\t\tif( strcmp(tag_name , LOC_REGION_TAG)==0 ){\n\t\t\tbuflen = uloc_getCountry ( mod_loc_name , tag_value->val , tag_value_len , &status);\n\t\t}\n\t\tif( strcmp(tag_name , LOC_VARIANT_TAG)==0 ){\n\t\t\tbuflen = uloc_getVariant ( mod_loc_name , tag_value->val , tag_value_len , &status);\n\t\t}\n\t\tif( strcmp(tag_name , LOC_CANONICALIZE_TAG)==0 ){\n\t\t\tbuflen = uloc_canonicalize ( mod_loc_name , tag_value->val , tag_value_len , &status);\n\t\t}\n\n\t\tif( U_FAILURE( status ) ) {\n\t\t\tif( status == U_BUFFER_OVERFLOW_ERROR ) {\n\t\t\t\tstatus = U_ZERO_ERROR;\n\t\t\t\tbuflen++; /* add space for \\0 */\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* Error in retrieving data */\n\t\t\t*result = 0;\n\t\t\tif( tag_value ){\n\t\t\t\tzend_string_release_ex( tag_value, 0 );\n\t\t\t}\n\t\t\tif( mod_loc_name ){\n\t\t\t\tefree( mod_loc_name);\n\t\t\t}\n\t\t\treturn NULL;\n\t\t}\n\t} while( buflen > tag_value_len );\n\n\tif(  buflen ==0 ){\n\t\t/* No value found */\n\t\t*result = -1;\n\t\tif( tag_value ){\n\t\t\tzend_string_release_ex( tag_value, 0 );\n\t\t}\n\t\tif( mod_loc_name ){\n\t\t\tefree( mod_loc_name);\n\t\t}\n\t\treturn NULL;\n\t} else {\n\t\t*result = 1;\n\t}\n\n\tif( mod_loc_name ){\n\t\tefree( mod_loc_name);\n\t}\n\n\ttag_value->len = strlen(tag_value->val);\n\treturn tag_value;\n}\n/* }}} */\n\n/* {{{\n* Gets the value from ICU , called when PHP userspace function is called\n* common code shared by get_primary_language,get_script or get_region or get_variant\n*/\nstatic void get_icu_value_src_php( char* tag_name, INTERNAL_FUNCTION_PARAMETERS)\n{\n\n\tchar*          loc_name        \t= NULL;\n\tsize_t         loc_name_len    \t= 0;\n\n\tzend_string*   tag_value\t\t= NULL;\n\tchar*       empty_result\t= \"\";\n\n\tint         result    \t\t= 0;\n\tchar*       msg        \t\t= NULL;\n\n\tUErrorCode  status          \t= U_ZERO_ERROR;\n\n\tintl_error_reset( NULL );\n\n\tZEND_PARSE_PARAMETERS_START(1, 1)\n\t\tZ_PARAM_PATH(loc_name, loc_name_len)\n\tZEND_PARSE_PARAMETERS_END();\n\n\tif(loc_name_len == 0) {\n\t\tloc_name = (char *)intl_locale_get_default();\n\t\tloc_name_len = strlen(loc_name);\n\t}\n\n\tINTL_CHECK_LOCALE_LEN(loc_name_len);\n\n\t/* Call ICU get */\n\ttag_value = get_icu_value_internal( loc_name , tag_name , &result ,0);\n\n\t/* No value found */\n\tif( result == -1 ) {\n\t\tif( tag_value){\n\t\t\tzend_string_release_ex( tag_value, 0 );\n\t\t}\n\t\tRETURN_STRING( empty_result);\n\t}\n\n\t/* value found */\n\tif( tag_value){\n\t\tRETVAL_STR( tag_value );\n\t\treturn;\n\t}\n\n\t/* Error encountered while fetching the value */\n\tif( result ==0) {\n\t\tspprintf(&msg , 0, \"locale_get_%s : unable to get locale %s\", tag_name , tag_name );\n\t\tintl_error_set( NULL, status, msg , 1 );\n\t\tefree(msg);\n\t\tRETURN_NULL();\n\t}\n\n}\n/* }}} */\n\n/* {{{ gets the script for the $locale */\nPHP_FUNCTION( locale_get_script )\n{\n\tget_icu_value_src_php( LOC_SCRIPT_TAG , INTERNAL_FUNCTION_PARAM_PASSTHRU );\n}\n/* }}} */\n\n/* {{{ gets the region for the $locale */\nPHP_FUNCTION( locale_get_region )\n{\n\tget_icu_value_src_php( LOC_REGION_TAG , INTERNAL_FUNCTION_PARAM_PASSTHRU );\n}\n/* }}} */\n\n/* {{{ gets the primary language for the $locale */\nPHP_FUNCTION(locale_get_primary_language )\n{\n\tget_icu_value_src_php( LOC_LANG_TAG , INTERNAL_FUNCTION_PARAM_PASSTHRU );\n}\n/* }}} */\n\n\n/* {{{\n * common code shared by display_xyz functions to  get the value from ICU\n }}} */\nstatic void get_icu_disp_value_src_php( char* tag_name, INTERNAL_FUNCTION_PARAMETERS)\n{\n\tchar*          loc_name        \t= NULL;\n\tsize_t         loc_name_len    \t= 0;\n\n\tchar*       disp_loc_name       = NULL;\n\tsize_t      disp_loc_name_len   = 0;\n\tint         free_loc_name       = 0;\n\n\tUChar*      disp_name      \t= NULL;\n\tint32_t     disp_name_len  \t= 0;\n\n\tchar*       mod_loc_name        = NULL;\n\n\tint32_t     buflen          \t= 512;\n\tUErrorCode  status          \t= U_ZERO_ERROR;\n\n\tzend_string* u8str;\n\n\tchar*       msg             \t= NULL;\n\n\tintl_error_reset( NULL );\n\n\tZEND_PARSE_PARAMETERS_START(1, 2)\n\t\tZ_PARAM_PATH(loc_name, loc_name_len)\n\t\tZ_PARAM_OPTIONAL\n\t\tZ_PARAM_PATH_OR_NULL(disp_loc_name, disp_loc_name_len)\n\tZEND_PARSE_PARAMETERS_END();\n\n\tif(loc_name_len > ULOC_FULLNAME_CAPACITY) {\n\t\t/* See bug 67397: overlong locale names cause trouble in uloc_getDisplayName */\n\t\tspprintf(&msg , 0, \"locale_get_display_%s : name too long\", tag_name );\n\t\tintl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,  msg , 1 );\n\t\tefree(msg);\n\t\tRETURN_FALSE;\n\t}\n\n\tif(loc_name_len == 0) {\n\t\tloc_name = (char *)intl_locale_get_default();\n\t}\n\n\tif( strcmp(tag_name, DISP_NAME) != 0 ){\n\t\t/* Handle grandfathered languages */\n\t\tint grOffset = findOffset( LOC_GRANDFATHERED , loc_name );\n\t\tif( grOffset >= 0 ){\n\t\t\tif( strcmp(tag_name , LOC_LANG_TAG)==0 ){\n\t\t\t\tmod_loc_name = getPreferredTag( loc_name );\n\t\t\t} else {\n\t\t\t\t/* Since Grandfathered, no value, do nothing, return NULL */\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\t\t}\n\t} /* end of if != LOC_CANONICAL_TAG */\n\n\tif( mod_loc_name==NULL ){\n\t\tmod_loc_name = estrdup( loc_name );\n\t}\n\n\t/* Check if disp_loc_name passed , if not use default locale */\n\tif( !disp_loc_name){\n\t\tdisp_loc_name = estrdup(intl_locale_get_default());\n\t\tfree_loc_name = 1;\n\t}\n\n\t/* Get the disp_value for the given locale */\n\tdo{\n\t\tdisp_name = erealloc( disp_name , buflen * sizeof(UChar)  );\n\t\tdisp_name_len = buflen;\n\n\t\tif( strcmp(tag_name , LOC_LANG_TAG)==0 ){\n\t\t\tbuflen = uloc_getDisplayLanguage ( mod_loc_name , disp_loc_name , disp_name , disp_name_len , &status);\n\t\t} else if( strcmp(tag_name , LOC_SCRIPT_TAG)==0 ){\n\t\t\tbuflen = uloc_getDisplayScript ( mod_loc_name , disp_loc_name , disp_name , disp_name_len , &status);\n\t\t} else if( strcmp(tag_name , LOC_REGION_TAG)==0 ){\n\t\t\tbuflen = uloc_getDisplayCountry ( mod_loc_name , disp_loc_name , disp_name , disp_name_len , &status);\n\t\t} else if( strcmp(tag_name , LOC_VARIANT_TAG)==0 ){\n\t\t\tbuflen = uloc_getDisplayVariant ( mod_loc_name , disp_loc_name , disp_name , disp_name_len , &status);\n\t\t} else if( strcmp(tag_name , DISP_NAME)==0 ){\n\t\t\tbuflen = uloc_getDisplayName ( mod_loc_name , disp_loc_name , disp_name , disp_name_len , &status);\n\t\t}\n\n\t\t/* U_STRING_NOT_TERMINATED_WARNING is admissible here; don't look for it */\n\t\tif( U_FAILURE( status ) )\n\t\t{\n\t\t\tif( status == U_BUFFER_OVERFLOW_ERROR )\n\t\t\t{\n\t\t\t\tstatus = U_ZERO_ERROR;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tspprintf(&msg, 0, \"locale_get_display_%s : unable to get locale %s\", tag_name , tag_name );\n\t\t\tintl_error_set( NULL, status, msg , 1 );\n\t\t\tefree(msg);\n\t\t\tif( disp_name){\n\t\t\t\tefree( disp_name );\n\t\t\t}\n\t\t\tif( mod_loc_name){\n\t\t\t\tefree( mod_loc_name );\n\t\t\t}\n\t\t\tif (free_loc_name) {\n\t\t\t\tefree((void *)disp_loc_name);\n\t\t\t\tdisp_loc_name = NULL;\n\t\t\t}\n\t\t\tRETURN_FALSE;\n\t\t}\n\t} while( buflen > disp_name_len );\n\n\tif( mod_loc_name){\n\t\tefree( mod_loc_name );\n\t}\n\tif (free_loc_name) {\n\t\tefree((void *)disp_loc_name);\n\t\tdisp_loc_name = NULL;\n\t}\n\t/* Convert display locale name from UTF-16 to UTF-8. */\n\tu8str = intl_convert_utf16_to_utf8(disp_name, buflen, &status );\n\tefree( disp_name );\n\tif( !u8str )\n\t{\n\t\tspprintf(&msg, 0, \"locale_get_display_%s :error converting display name for %s to UTF-8\", tag_name , tag_name );\n\t\tintl_error_set( NULL, status, msg , 1 );\n\t\tefree(msg);\n\t\tRETURN_FALSE;\n\t}\n\n\tRETVAL_NEW_STR( u8str );\n}\n/* }}} */\n\n/* {{{ gets the name for the $locale in $in_locale or default_locale */\nPHP_FUNCTION(locale_get_display_name)\n{\n\tget_icu_disp_value_src_php( DISP_NAME , INTERNAL_FUNCTION_PARAM_PASSTHRU );\n}\n/* }}} */\n\n/* {{{ gets the language for the $locale in $in_locale or default_locale */\nPHP_FUNCTION(locale_get_display_language)\n{\n\tget_icu_disp_value_src_php( LOC_LANG_TAG , INTERNAL_FUNCTION_PARAM_PASSTHRU );\n}\n/* }}} */\n\n/* {{{ gets the script for the $locale in $in_locale or default_locale */\nPHP_FUNCTION(locale_get_display_script)\n{\n\tget_icu_disp_value_src_php( LOC_SCRIPT_TAG , INTERNAL_FUNCTION_PARAM_PASSTHRU );\n}\n/* }}} */\n\n/* {{{ gets the region for the $locale in $in_locale or default_locale */\nPHP_FUNCTION(locale_get_display_region)\n{\n\tget_icu_disp_value_src_php( LOC_REGION_TAG , INTERNAL_FUNCTION_PARAM_PASSTHRU );\n}\n/* }}} */\n\n/* {{{\n* proto static string Locale::getDisplayVariant($locale, $in_locale = null)\n* gets the variant for the $locale in $in_locale or default_locale\n }}} */\n/* {{{\n* proto static string get_display_variant($locale, $in_locale = null)\n* gets the variant for the $locale in $in_locale or default_locale\n*/\nPHP_FUNCTION(locale_get_display_variant)\n{\n\tget_icu_disp_value_src_php( LOC_VARIANT_TAG , INTERNAL_FUNCTION_PARAM_PASSTHRU );\n}\n/* }}} */\n\n /* {{{ return an associative array containing keyword-value\n * pairs for this locale. The keys are keys to the array (doh!)\n * }}}*/\n /* {{{ return an associative array containing keyword-value\n * pairs for this locale. The keys are keys to the array (doh!)\n */\nPHP_FUNCTION( locale_get_keywords )\n{\n\tUEnumeration*   e        = NULL;\n\tUErrorCode      status   = U_ZERO_ERROR;\n\n\tconst char*\t \tkw_key        = NULL;\n\tint32_t         kw_key_len    = 0;\n\n\tchar*       \t        loc_name        = NULL;\n\tsize_t        \t \tloc_name_len    = 0;\n\n\tintl_error_reset( NULL );\n\n\tZEND_PARSE_PARAMETERS_START(1, 1)\n\t\tZ_PARAM_PATH(loc_name, loc_name_len)\n\tZEND_PARSE_PARAMETERS_END();\n\n\tINTL_CHECK_LOCALE_LEN(strlen(loc_name));\n\n\tif(loc_name_len == 0) {\n\t\tloc_name = (char *)intl_locale_get_default();\n\t}\n\n\t/* Get the keywords */\n\te = uloc_openKeywords( loc_name, &status );\n\tif( e != NULL ) {\n\t\t/*\n\t\tICU expects the buffer to be allocated  before calling the function\n\t\tand so the buffer size has been explicitly specified\n\t\tICU uloc.h #define \tULOC_KEYWORD_AND_VALUES_CAPACITY   100\n\t\thence the kw_value buffer size is 100\n\t\t*/\n\n\t\t/* Traverse it, filling the return array. */\n\t\tarray_init( return_value );\n\n\t\twhile( ( kw_key = uenum_next( e, &kw_key_len, &status ) ) != NULL ){\n\t\t\tint32_t kw_value_len = 100;\n\t\t\tzend_string *kw_value_str = zend_string_alloc(kw_value_len, 0);\n\n\t\t\t/* Get the keyword value for each keyword */\n\t\t\tkw_value_len=uloc_getKeywordValue( loc_name, kw_key, ZSTR_VAL(kw_value_str), kw_value_len, &status );\n\t\t\tif (status == U_BUFFER_OVERFLOW_ERROR) {\n\t\t\t\tstatus = U_ZERO_ERROR;\n\t\t\t\tkw_value_str = zend_string_extend(kw_value_str, kw_value_len, 0);\n\t\t\t\tkw_value_len=uloc_getKeywordValue( loc_name,kw_key, ZSTR_VAL(kw_value_str), kw_value_len+1, &status );\n\t\t\t} else if(!U_FAILURE(status)) {\n\t\t\t\tkw_value_str = zend_string_truncate(kw_value_str, kw_value_len, 0);\n\t\t\t}\n\t\t\tif (U_FAILURE(status)) {\n\t\t\t\tintl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR, \"locale_get_keywords: Error encountered while getting the keyword  value for the  keyword\", 0 );\n\t\t\t\tif( kw_value_str){\n\t\t\t\t\tzend_string_efree( kw_value_str );\n\t\t\t\t}\n\t\t\t\tzend_array_destroy(Z_ARR_P(return_value));\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\n\t\t\tadd_assoc_str( return_value, (char *)kw_key, kw_value_str);\n\t\t} /* end of while */\n\n\t} /* end of if e!=NULL */\n\n\tuenum_close( e );\n}\n/* }}} */\n\n /* {{{ @return string the canonicalized locale\n * }}} */\n /* {{{ @param string $locale\tThe locale string to canonicalize */\nPHP_FUNCTION(locale_canonicalize)\n{\n\tget_icu_value_src_php( LOC_CANONICALIZE_TAG , INTERNAL_FUNCTION_PARAM_PASSTHRU );\n}\n/* }}} */\n\n/* {{{ append_key_value\n* Internal function which is called from locale_compose\n* gets the value for the key_name and appends to the loc_name\n* returns 1 if successful , -1 if not found ,\n* 0 if array element is not a string , -2 if buffer-overflow\n*/\nstatic int append_key_value(smart_str* loc_name, HashTable* hash_arr, char* key_name)\n{\n\tzval *ele_value;\n\n\tif ((ele_value = zend_hash_str_find_deref(hash_arr , key_name, strlen(key_name))) != NULL ) {\n\t\tif(Z_TYPE_P(ele_value)!= IS_STRING ){\n\t\t\t/* element value is not a string */\n\t\t\treturn FAILURE;\n\t\t}\n\t\tif(strcmp(key_name, LOC_LANG_TAG) != 0 &&\n\t\t   strcmp(key_name, LOC_GRANDFATHERED_LANG_TAG)!=0 ) {\n\t\t\t/* not lang or grandfathered tag */\n\t\t\tsmart_str_appendl(loc_name, SEPARATOR , sizeof(SEPARATOR)-1);\n\t\t}\n\t\tsmart_str_appendl(loc_name, Z_STRVAL_P(ele_value) , Z_STRLEN_P(ele_value));\n\t\treturn SUCCESS;\n\t}\n\n\treturn LOC_NOT_FOUND;\n}\n/* }}} */\n\n/* {{{ append_prefix , appends the prefix needed\n* e.g. private adds 'x'\n*/\nstatic void add_prefix(smart_str* loc_name, char* key_name)\n{\n\tif( strncmp(key_name , LOC_PRIVATE_TAG , 7) == 0 ){\n\t\tsmart_str_appendl(loc_name, SEPARATOR , sizeof(SEPARATOR)-1);\n\t\tsmart_str_appendl(loc_name, PRIVATE_PREFIX , sizeof(PRIVATE_PREFIX)-1);\n\t}\n}\n/* }}} */\n\n/* {{{ append_multiple_key_values\n* Internal function which is called from locale_compose\n* gets the multiple values for the key_name and appends to the loc_name\n* used for 'variant','extlang','private'\n* returns 1 if successful , -1 if not found ,\n* 0 if array element is not a string , -2 if buffer-overflow\n*/\nstatic int append_multiple_key_values(smart_str* loc_name, HashTable* hash_arr, char* key_name)\n{\n\tzval\t*ele_value;\n\tint \tisFirstSubtag \t= 0;\n\n\t/* Variant/ Extlang/Private etc. */\n\tif ((ele_value = zend_hash_str_find_deref( hash_arr , key_name , strlen(key_name))) != NULL) {\n\t\tif( Z_TYPE_P(ele_value) == IS_STRING ){\n\t\t\tadd_prefix( loc_name , key_name);\n\n\t\t\tsmart_str_appendl(loc_name, SEPARATOR , sizeof(SEPARATOR)-1);\n\t\t\tsmart_str_appendl(loc_name, Z_STRVAL_P(ele_value) , Z_STRLEN_P(ele_value));\n\t\t\treturn SUCCESS;\n\t\t} else if(Z_TYPE_P(ele_value) == IS_ARRAY ) {\n\t\t\tHashTable *arr = Z_ARRVAL_P(ele_value);\n\t\t\tzval *data;\n\n\t\t\tZEND_HASH_FOREACH_VAL(arr, data) {\n\t\t\t\tZVAL_DEREF(data);\n\t\t\t\tif(Z_TYPE_P(data) != IS_STRING) {\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\t\t\t\tif (isFirstSubtag++ == 0){\n\t\t\t\t\tadd_prefix(loc_name , key_name);\n\t\t\t\t}\n\t\t\t\tsmart_str_appendl(loc_name, SEPARATOR , sizeof(SEPARATOR)-1);\n\t\t\t\tsmart_str_appendl(loc_name, Z_STRVAL_P(data) , Z_STRLEN_P(data));\n\t\t\t} ZEND_HASH_FOREACH_END();\n\t\t\treturn SUCCESS;\n\t\t} else {\n\t\t\treturn FAILURE;\n\t\t}\n\t} else {\n\t\tchar cur_key_name[31];\n\t\tint  max_value = 0, i;\n\t\t/* Decide the max_value: the max. no. of elements allowed */\n\t\tif( strcmp(key_name , LOC_VARIANT_TAG) ==0 ){\n\t\t\tmax_value  = MAX_NO_VARIANT;\n\t\t}\n\t\tif( strcmp(key_name , LOC_EXTLANG_TAG) ==0 ){\n\t\t\tmax_value  = MAX_NO_EXTLANG;\n\t\t}\n\t\tif( strcmp(key_name , LOC_PRIVATE_TAG) ==0 ){\n\t\t\tmax_value  = MAX_NO_PRIVATE;\n\t\t}\n\n\t\t/* Multiple variant values as variant0, variant1 ,variant2 */\n\t\tisFirstSubtag = 0;\n\t\tfor( i=0 ; i< max_value; i++ ){\n\t\t\tsnprintf( cur_key_name , 30, \"%s%d\", key_name , i);\n\t\t\tif ((ele_value = zend_hash_str_find_deref( hash_arr , cur_key_name , strlen(cur_key_name))) != NULL) {\n\t\t\t\tif( Z_TYPE_P(ele_value)!= IS_STRING ){\n\t\t\t\t\t/* variant is not a string */\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\t\t\t\t/* Add the contents */\n\t\t\t\tif (isFirstSubtag++ == 0){\n\t\t\t\t\tadd_prefix(loc_name , cur_key_name);\n\t\t\t\t}\n\t\t\t\tsmart_str_appendl(loc_name, SEPARATOR , sizeof(SEPARATOR)-1);\n\t\t\t\tsmart_str_appendl(loc_name, Z_STRVAL_P(ele_value) , Z_STRLEN_P(ele_value));\n\t\t\t}\n\t\t} /* end of for */\n\t} /* end of else */\n\n\treturn SUCCESS;\n}\n/* }}} */\n\n/*{{{\n* If applicable sets error message and aborts locale_compose gracefully\n* returns 0  if locale_compose needs to be aborted\n* otherwise returns 1\n*/\nstatic int handleAppendResult( int result, smart_str* loc_name)\n{\n\tintl_error_reset( NULL );\n\tif( result == FAILURE) {\n\t\tintl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,\n\t\t\t \"locale_compose: parameter array element is not a string\", 0 );\n\t\tsmart_str_free(loc_name);\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n/* }}} */\n\n#define RETURN_SMART_STR(str) smart_str_0((str)); RETURN_NEW_STR((str)->s)\n/* {{{ Creates a locale by combining the parts of locale-ID passed\n* }}} */\n/* {{{ Creates a locale by combining the parts of locale-ID passed\n* }}} */\nPHP_FUNCTION(locale_compose)\n{\n\tsmart_str      \tloc_name_s = {0};\n\tsmart_str *loc_name = &loc_name_s;\n\tzval*\t\t\tarr\t= NULL;\n\tHashTable*\t\thash_arr = NULL;\n\tint \t\t\tresult = 0;\n\n\tintl_error_reset( NULL );\n\n\tZEND_PARSE_PARAMETERS_START(1, 1)\n\t\tZ_PARAM_ARRAY(arr)\n\tZEND_PARSE_PARAMETERS_END();\n\n\thash_arr = Z_ARRVAL_P( arr );\n\n\tif( !hash_arr || zend_hash_num_elements( hash_arr ) == 0 )\n\t\tRETURN_FALSE;\n\n\t/* Check for grandfathered first */\n\tresult = append_key_value(loc_name, hash_arr,  LOC_GRANDFATHERED_LANG_TAG);\n\tif( result == SUCCESS){\n\t\tRETURN_SMART_STR(loc_name);\n\t}\n\tif( !handleAppendResult( result, loc_name)){\n\t\tRETURN_FALSE;\n\t}\n\n\t/* Not grandfathered */\n\tresult = append_key_value(loc_name, hash_arr , LOC_LANG_TAG);\n\tif( result == LOC_NOT_FOUND ){\n\t\tzend_argument_value_error(1, \"must contain a \\\"%s\\\" key\", LOC_LANG_TAG);\n\t\tsmart_str_free(loc_name);\n\t\tRETURN_THROWS();\n\t}\n\tif( !handleAppendResult( result, loc_name)){\n\t\tRETURN_FALSE;\n\t}\n\n\t/* Extlang */\n\tresult = append_multiple_key_values(loc_name, hash_arr , LOC_EXTLANG_TAG);\n\tif( !handleAppendResult( result, loc_name)){\n\t\tRETURN_FALSE;\n\t}\n\n\t/* Script */\n\tresult = append_key_value(loc_name, hash_arr , LOC_SCRIPT_TAG);\n\tif( !handleAppendResult( result, loc_name)){\n\t\tRETURN_FALSE;\n\t}\n\n\t/* Region */\n\tresult = append_key_value( loc_name, hash_arr , LOC_REGION_TAG);\n\tif( !handleAppendResult( result, loc_name)){\n\t\tRETURN_FALSE;\n\t}\n\n\t/* Variant */\n\tresult = append_multiple_key_values( loc_name, hash_arr , LOC_VARIANT_TAG);\n\tif( !handleAppendResult( result, loc_name)){\n\t\tRETURN_FALSE;\n\t}\n\n\t/* Private */\n\tresult = append_multiple_key_values( loc_name, hash_arr , LOC_PRIVATE_TAG);\n\tif( !handleAppendResult( result, loc_name)){\n\t\tRETURN_FALSE;\n\t}\n\n\tRETURN_SMART_STR(loc_name);\n}\n/* }}} */\n\n\n/*{{{\n* Parses the locale and returns private subtags  if existing\n* else returns NULL\n* e.g. for locale='en_US-x-prv1-prv2-prv3'\n* returns a pointer to the string 'prv1-prv2-prv3'\n*/\nstatic zend_string* get_private_subtags(const char* loc_name)\n{\n\tzend_string* result = NULL;\n\tsize_t       len = 0;\n\tconst char*  mod_loc_name =NULL;\n\n\tif( loc_name && (len = strlen(loc_name)) > 0 ){\n\t\tzend_off_t singletonPos = 0;\n\t\tmod_loc_name = loc_name ;\n\t\twhile( (singletonPos = getSingletonPos(mod_loc_name)) > -1){\n\t\t\tif( (*(mod_loc_name+singletonPos)=='x') || (*(mod_loc_name+singletonPos)=='X') ){\n\t\t\t\t/* private subtag start found */\n\t\t\t\tif( singletonPos + 2 ==  len){\n\t\t\t\t\t/* loc_name ends with '-x-' ; return  NULL */\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\t/* result = mod_loc_name + singletonPos +2; */\n\t\t\t\t\tresult = zend_string_init(mod_loc_name + singletonPos+2  , (len -( singletonPos +2) ), 0);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif((size_t)(singletonPos + 1) >= len){\n\t\t\t\t\t/* String end */\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t/* singleton found but not a private subtag , hence check further in the string for the private subtag */\n\t\t\t\t\tmod_loc_name = mod_loc_name + singletonPos +1;\n\t\t\t\t\tlen = strlen(mod_loc_name);\n\t\t\t\t}\n\t\t\t}\n\t\t} /* end of while */\n\t}\n\n\treturn result;\n}\n/* }}} */\n\n/* {{{ code used by locale_parse */\nstatic int add_array_entry(const char* loc_name, zval* hash_arr, char* key_name)\n{\n\tzend_string*   key_value \t= NULL;\n\tchar*   cur_key_name\t= NULL;\n\tchar*   token        \t= NULL;\n\tchar*   last_ptr  \t= NULL;\n\n\tint\tresult\t\t= 0;\n\tint \tcur_result  \t= 0;\n\n\n\tif( strcmp(key_name , LOC_PRIVATE_TAG)==0 ){\n\t\tkey_value = get_private_subtags( loc_name );\n\t\tresult = 1;\n\t} else {\n\t\tkey_value = get_icu_value_internal( loc_name , key_name , &result,1 );\n\t}\n\tif( (strcmp(key_name , LOC_PRIVATE_TAG)==0) ||\n\t\t( strcmp(key_name , LOC_VARIANT_TAG)==0) ){\n\t\tif( result > 0 && key_value){\n\t\t\tint cnt = 0;\n\t\t\t/* Tokenize on the \"_\" or \"-\"  */\n\t\t\ttoken = php_strtok_r( key_value->val , DELIMITER ,&last_ptr);\n\t\t\tif( cur_key_name ){\n\t\t\t\tefree( cur_key_name);\n\t\t\t}\n\t\t\t/* Over-allocates a few bytes for the integer so we don't have to reallocate. */\n\t\t\tsize_t cur_key_name_size = (sizeof(\"-2147483648\") - 1) + strlen(key_name) + 1;\n\t\t\tcur_key_name = emalloc(cur_key_name_size);\n\t\t\tsnprintf( cur_key_name, cur_key_name_size , \"%s%d\", key_name , cnt++);\n\t\t\tadd_assoc_string( hash_arr, cur_key_name , token);\n\t\t\t/* tokenize on the \"_\" or \"-\" and stop  at singleton if any */\n\t\t\twhile( (token = php_strtok_r(NULL , DELIMITER , &last_ptr)) && (strlen(token)>1) ){\n\t\t\t\tsnprintf( cur_key_name , cur_key_name_size, \"%s%d\", key_name , cnt++);\n\t\t\t\tadd_assoc_string( hash_arr, cur_key_name , token);\n\t\t\t}\n/*\n\t\t\tif( strcmp(key_name, LOC_PRIVATE_TAG) == 0 ){\n\t\t\t}\n*/\n\t\t}\n\t\tif (key_value) {\n\t\t\tzend_string_release_ex(key_value, 0);\n\t\t}\n\t} else {\n\t\tif( result == 1 ){\n\t\t\tadd_assoc_str( hash_arr, key_name , key_value);\n\t\t\tcur_result = 1;\n\t\t} else if (key_value) {\n\t\t\tzend_string_release_ex(key_value, 0);\n\t\t}\n\t}\n\n\tif( cur_key_name ){\n\t\tefree( cur_key_name);\n\t}\n\t/*if( key_name != LOC_PRIVATE_TAG && key_value){*/\n\treturn cur_result;\n}\n/* }}} */\n\n/* {{{ parses a locale-id into an array the different parts of it */\nPHP_FUNCTION(locale_parse)\n{\n\tchar*          loc_name        = NULL;\n\tsize_t         loc_name_len    = 0;\n\tint         grOffset    \t= 0;\n\n\tintl_error_reset( NULL );\n\n\tZEND_PARSE_PARAMETERS_START(1, 1)\n\t\tZ_PARAM_PATH(loc_name, loc_name_len)\n\tZEND_PARSE_PARAMETERS_END();\n\n\tINTL_CHECK_LOCALE_LEN(strlen(loc_name));\n\n\tif(loc_name_len == 0) {\n\t\tloc_name = (char *)intl_locale_get_default();\n\t}\n\n\tarray_init( return_value );\n\n\tgrOffset =  findOffset( LOC_GRANDFATHERED , loc_name );\n\tif( grOffset >= 0 ){\n\t\tadd_assoc_string( return_value , LOC_GRANDFATHERED_LANG_TAG, (char *)loc_name);\n\t}\n\telse{\n\t\t/* Not grandfathered */\n\t\tadd_array_entry( loc_name , return_value , LOC_LANG_TAG);\n\t\tadd_array_entry( loc_name , return_value , LOC_SCRIPT_TAG);\n\t\tadd_array_entry( loc_name , return_value , LOC_REGION_TAG);\n\t\tadd_array_entry( loc_name , return_value , LOC_VARIANT_TAG);\n\t\tadd_array_entry( loc_name , return_value , LOC_PRIVATE_TAG);\n\t}\n}\n/* }}} */\n\n/* {{{ gets an array containing the list of variants, or null */\nPHP_FUNCTION(locale_get_all_variants)\n{\n\tchar*  \t                loc_name        = NULL;\n\tsize_t    \t\tloc_name_len    = 0;\n\n\tint\tresult\t\t= 0;\n\tchar*\ttoken\t\t= NULL;\n\tzend_string*\tvariant\t\t= NULL;\n\tchar*\tsaved_ptr\t= NULL;\n\n\tintl_error_reset( NULL );\n\n\tZEND_PARSE_PARAMETERS_START(1, 1)\n\t\tZ_PARAM_PATH(loc_name, loc_name_len)\n\tZEND_PARSE_PARAMETERS_END();\n\n\tif(loc_name_len == 0) {\n\t\tloc_name = (char *)intl_locale_get_default();\n\t\tloc_name_len = strlen(loc_name);\n\t}\n\n\tINTL_CHECK_LOCALE_LEN(loc_name_len);\n\n\tarray_init( return_value );\n\n\t/* If the locale is grandfathered, stop, no variants */\n\tif( findOffset( LOC_GRANDFATHERED , loc_name ) >=  0 ){\n\t\t/* (\"Grandfathered Tag. No variants.\"); */\n\t}\n\telse {\n\t/* Call ICU variant */\n\t\tvariant = get_icu_value_internal( loc_name , LOC_VARIANT_TAG , &result ,0);\n\t\tif( result > 0 && variant){\n\t\t\t/* Tokenize on the \"_\" or \"-\" */\n\t\t\ttoken = php_strtok_r( variant->val , DELIMITER , &saved_ptr);\n\t\t\tadd_next_index_stringl( return_value, token , strlen(token));\n\t\t\t/* tokenize on the \"_\" or \"-\" and stop  at singleton if any\t*/\n\t\t\twhile( (token = php_strtok_r(NULL , DELIMITER, &saved_ptr)) && (strlen(token)>1) ){\n\t\t\t\tadd_next_index_stringl( return_value, token , strlen(token));\n\t\t\t}\n\t\t}\n\t\tif( variant ){\n\t\t\tzend_string_release_ex( variant, 0 );\n\t\t}\n\t}\n\n\n}\n/* }}} */\n\n/* {{{ Converts to lower case and also replaces all hyphens with the underscore */\nstatic int strToMatch(const char* str ,char *retstr)\n{\n\tchar* \tanchor \t= NULL;\n\tconst char* \tanchor1 = NULL;\n\tint \tresult \t= 0;\n\n\tif( (!str) || str[0] == '\\0'){\n\t\treturn result;\n\t} else {\n\t\tanchor = retstr;\n\t\tanchor1 = str;\n\t\t\twhile( (*str)!='\\0' ){\n\t\t\tif( *str == '-' ){\n\t\t\t\t*retstr =  '_';\n\t\t\t} else {\n\t\t\t\t*retstr = tolower(*str);\n\t\t\t}\n\t\t\t\tstr++;\n\t\t\t\tretstr++;\n\t\t}\n\t\t*retstr = '\\0';\n\t\tretstr=  anchor;\n\t\tstr=  anchor1;\n\t\tresult = 1;\n\t}\n\n\treturn(result);\n}\n/* }}} */\n\n/* {{{ Checks if a $langtag filter matches with $locale according to RFC 4647's basic filtering algorithm */\n/* }}} */\n/* {{{ Checks if a $langtag filter matches with $locale according to RFC 4647's basic filtering algorithm */\nPHP_FUNCTION(locale_filter_matches)\n{\n\tchar*       \tlang_tag        = NULL;\n\tsize_t         \tlang_tag_len    = 0;\n\tchar*           loc_range       = NULL;\n\tsize_t         \tloc_range_len   = 0;\n\n\tint\t\tresult\t\t= 0;\n\tchar*\t\ttoken\t\t= 0;\n\tchar*\t\tchrcheck\t= NULL;\n\n\tzend_string*   \tcan_lang_tag    = NULL;\n\tzend_string*   \tcan_loc_range   = NULL;\n\n\tchar*       \tcur_lang_tag    = NULL;\n\tchar*       \tcur_loc_range   = NULL;\n\n\tbool \tboolCanonical \t= 0;\n\tUErrorCode\tstatus\t\t= U_ZERO_ERROR;\n\n\tintl_error_reset( NULL );\n\n\tZEND_PARSE_PARAMETERS_START(2, 3)\n\t\tZ_PARAM_PATH(lang_tag, lang_tag_len)\n\t\tZ_PARAM_PATH(loc_range,  loc_range_len)\n\t\tZ_PARAM_OPTIONAL\n\t\tZ_PARAM_BOOL(boolCanonical)\n\tZEND_PARSE_PARAMETERS_END();\n\n\tif(loc_range_len == 0) {\n\t\tloc_range = (char *)intl_locale_get_default();\n\t\tloc_range_len = strlen(loc_range);\n\t}\n\n\tif( strcmp(loc_range,\"*\")==0){\n\t\tRETURN_TRUE;\n\t}\n\n\tINTL_CHECK_LOCALE_LEN(loc_range_len);\n\tINTL_CHECK_LOCALE_LEN(lang_tag_len);\n\n\tif( boolCanonical ){\n\t\t/* canonicalize loc_range */\n\t\tcan_loc_range=get_icu_value_internal( loc_range , LOC_CANONICALIZE_TAG , &result , 0);\n\t\tif( result <=0) {\n\t\t\tintl_error_set( NULL, status,\n\t\t\t\t\"locale_filter_matches : unable to canonicalize loc_range\" , 0 );\n\t\t\tRETURN_FALSE;\n\t\t}\n\n\t\t/* canonicalize lang_tag */\n\t\tcan_lang_tag = get_icu_value_internal( lang_tag , LOC_CANONICALIZE_TAG , &result ,  0);\n\t\tif( result <=0) {\n\t\t\tintl_error_set( NULL, status,\n\t\t\t\t\"locale_filter_matches : unable to canonicalize lang_tag\" , 0 );\n\t\t\tRETURN_FALSE;\n\t\t}\n\n\t\t/* Convert to lower case for case-insensitive comparison */\n\t\tcur_lang_tag = ecalloc( 1, can_lang_tag->len + 1);\n\n\t\t/* Convert to lower case for case-insensitive comparison */\n\t\tresult = strToMatch( can_lang_tag->val , cur_lang_tag);\n\t\tif( result == 0) {\n\t\t\tefree( cur_lang_tag );\n\t\t\tzend_string_release_ex( can_lang_tag, 0 );\n\t\t\tRETURN_FALSE;\n\t\t}\n\n\t\tcur_loc_range = ecalloc( 1, can_loc_range->len + 1);\n\t\tresult = strToMatch( can_loc_range->val , cur_loc_range );\n\t\tif( result == 0) {\n\t\t\tefree( cur_lang_tag );\n\t\t\tzend_string_release_ex( can_lang_tag, 0 );\n\t\t\tefree( cur_loc_range );\n\t\t\tzend_string_release_ex( can_loc_range, 0 );\n\t\t\tRETURN_FALSE;\n\t\t}\n\n\t\t/* check if prefix */\n\t\ttoken \t= strstr( cur_lang_tag , cur_loc_range );\n\n\t\tif( token && (token==cur_lang_tag) ){\n\t\t\t/* check if the char. after match is SEPARATOR */\n\t\t\tchrcheck = token + (strlen(cur_loc_range));\n\t\t\tif( isIDSeparator(*chrcheck) || isKeywordSeparator(*chrcheck) || isEndOfTag(*chrcheck) ){\n\t\t\t\tefree( cur_lang_tag );\n\t\t\t\tefree( cur_loc_range );\n\t\t\t\tif( can_lang_tag){\n\t\t\t\t\tzend_string_release_ex( can_lang_tag, 0 );\n\t\t\t\t}\n\t\t\t\tif( can_loc_range){\n\t\t\t\t\tzend_string_release_ex( can_loc_range, 0 );\n\t\t\t\t}\n\t\t\t\tRETURN_TRUE;\n\t\t\t}\n\t\t}\n\n\t\t/* No prefix as loc_range */\n\t\tif( cur_lang_tag){\n\t\t\tefree( cur_lang_tag );\n\t\t}\n\t\tif( cur_loc_range){\n\t\t\tefree( cur_loc_range );\n\t\t}\n\t\tif( can_lang_tag){\n\t\t\tzend_string_release_ex( can_lang_tag, 0 );\n\t\t}\n\t\tif( can_loc_range){\n\t\t\tzend_string_release_ex( can_loc_range, 0 );\n\t\t}\n\t\tRETURN_FALSE;\n\n\t} /* end of if isCanonical */\n\telse{\n\t\t/* Convert to lower case for case-insensitive comparison */\n\t\tcur_lang_tag = ecalloc( 1, strlen(lang_tag ) + 1);\n\n\t\tresult = strToMatch( lang_tag , cur_lang_tag);\n\t\tif( result == 0) {\n\t\t\tefree( cur_lang_tag );\n\t\t\tRETURN_FALSE;\n\t\t}\n\t\tcur_loc_range = ecalloc( 1, strlen(loc_range ) + 1);\n\t\tresult = strToMatch( loc_range , cur_loc_range );\n\t\tif( result == 0) {\n\t\t\tefree( cur_lang_tag );\n\t\t\tefree( cur_loc_range );\n\t\t\tRETURN_FALSE;\n\t\t}\n\n\t\t/* check if prefix */\n\t\ttoken \t= strstr( cur_lang_tag , cur_loc_range );\n\n\t\tif( token && (token==cur_lang_tag) ){\n\t\t\t/* check if the char. after match is SEPARATOR */\n\t\t\tchrcheck = token + (strlen(cur_loc_range));\n\t\t\tif( isIDSeparator(*chrcheck) || isEndOfTag(*chrcheck) ){\n\t\t\t\tefree( cur_lang_tag );\n\t\t\t\tefree( cur_loc_range );\n\t\t\t\tRETURN_TRUE;\n\t\t\t}\n\t\t}\n\n\t\t/* No prefix as loc_range */\n\t\tif( cur_lang_tag){\n\t\t\tefree( cur_lang_tag );\n\t\t}\n\t\tif( cur_loc_range){\n\t\t\tefree( cur_loc_range );\n\t\t}\n\t\tRETURN_FALSE;\n\n\t}\n}\n/* }}} */\n\nstatic void array_cleanup( char* arr[] , int arr_size)\n{\n\tint i=0;\n\tfor( i=0; i< arr_size; i++ ){\n\t\tif( arr[i*2] ){\n\t\t\tefree( arr[i*2]);\n\t\t}\n\t}\n\tefree(arr);\n}\n\n#define LOOKUP_CLEAN_RETURN(value)\tarray_cleanup(cur_arr, cur_arr_len); return (value)\n/* {{{\n* returns the lookup result to lookup_loc_range_src_php\n* internal function\n*/\nstatic zend_string* lookup_loc_range(const char* loc_range, HashTable* hash_arr, int canonicalize )\n{\n\tint\ti = 0;\n\tint\tcur_arr_len = 0;\n\tint result = 0;\n\n\tzend_string* lang_tag = NULL;\n\tzval* ele_value = NULL;\n\n\tchar* cur_loc_range\t= NULL;\n\tzend_string* can_loc_range\t= NULL;\n\tzend_off_t saved_pos = 0;\n\n\tzend_string* return_value = NULL;\n\n\tchar **cur_arr = ecalloc(zend_hash_num_elements(hash_arr)*2, sizeof(char *));\n\tZEND_HASH_FOREACH_VAL(hash_arr, ele_value) {\n\t\tZVAL_DEREF(ele_value);\n\t/* convert the array to lowercase , also replace hyphens with the underscore and store it in cur_arr */\n\t\tif(Z_TYPE_P(ele_value)!= IS_STRING) {\n\t\t\t/* element value is not a string */\n\t\t\tzend_argument_type_error(2, \"must only contain string values\");\n\t\t\tLOOKUP_CLEAN_RETURN(NULL);\n\t\t}\n\t\tif (zend_str_has_nul_byte(Z_STR_P(ele_value))) {\n\t\t\tzend_argument_value_error(2, \"must not contain any null bytes\");\n\t\t\tLOOKUP_CLEAN_RETURN(NULL);\n\t\t}\n\t\tcur_arr[cur_arr_len*2] = estrndup(Z_STRVAL_P(ele_value), Z_STRLEN_P(ele_value));\n\t\tresult = strToMatch(Z_STRVAL_P(ele_value), cur_arr[cur_arr_len*2]);\n\t\tif(result == 0) {\n\t\t\tintl_error_set(NULL, U_ILLEGAL_ARGUMENT_ERROR, \"lookup_loc_range: unable to canonicalize lang_tag\", 0);\n\t\t\tLOOKUP_CLEAN_RETURN(NULL);\n\t\t}\n\t\tcur_arr[cur_arr_len*2+1] = Z_STRVAL_P(ele_value);\n\t\tcur_arr_len++ ;\n\t} ZEND_HASH_FOREACH_END(); /* end of for */\n\n\t/* Canonicalize array elements */\n\tif(canonicalize) {\n\t\tfor(i=0; i<cur_arr_len; i++) {\n\t\t\tlang_tag = get_icu_value_internal(cur_arr[i*2], LOC_CANONICALIZE_TAG, &result, 0);\n\t\t\tif(result != 1 || lang_tag == NULL || !lang_tag->val[0]) {\n\t\t\t\tif(lang_tag) {\n\t\t\t\t\tzend_string_release_ex(lang_tag, 0);\n\t\t\t\t}\n\t\t\t\tintl_error_set(NULL, U_ILLEGAL_ARGUMENT_ERROR, \"lookup_loc_range: unable to canonicalize lang_tag\" , 0);\n\t\t\t\tLOOKUP_CLEAN_RETURN(NULL);\n\t\t\t}\n\t\t\tcur_arr[i*2] = erealloc(cur_arr[i*2], lang_tag->len+1);\n\t\t\tresult = strToMatch(lang_tag->val, cur_arr[i*2]);\n\t\t\tzend_string_release_ex(lang_tag, 0);\n\t\t\tif(result == 0) {\n\t\t\t\tintl_error_set(NULL, U_ILLEGAL_ARGUMENT_ERROR, \"lookup_loc_range: unable to canonicalize lang_tag\" , 0);\n\t\t\t\tLOOKUP_CLEAN_RETURN(NULL);\n\t\t\t}\n\t\t}\n\n\t}\n\n\tif(canonicalize) {\n\t\t/* Canonicalize the loc_range */\n\t\tcan_loc_range = get_icu_value_internal(loc_range, LOC_CANONICALIZE_TAG, &result , 0);\n\t\tif( result != 1 || can_loc_range == NULL || !can_loc_range->val[0]) {\n\t\t\t/* Error */\n\t\t\tintl_error_set(NULL, U_ILLEGAL_ARGUMENT_ERROR, \"lookup_loc_range: unable to canonicalize loc_range\" , 0 );\n\t\t\tif(can_loc_range) {\n\t\t\t\tzend_string_release_ex(can_loc_range, 0);\n\t\t\t}\n\t\t\tLOOKUP_CLEAN_RETURN(NULL);\n\t\t} else {\n\t\t\tloc_range = can_loc_range->val;\n\t\t}\n\t}\n\n\tcur_loc_range = ecalloc(1, strlen(loc_range)+1);\n\t/* convert to lower and replace hyphens */\n\tresult = strToMatch(loc_range, cur_loc_range);\n\tif(can_loc_range) {\n\t\tzend_string_release_ex(can_loc_range, 0);\n\t}\n\tif(result == 0) {\n\t\tefree(cur_loc_range);\n\t\tintl_error_set(NULL, U_ILLEGAL_ARGUMENT_ERROR, \"lookup_loc_range: unable to canonicalize lang_tag\" , 0);\n\t\tLOOKUP_CLEAN_RETURN(NULL);\n\t}\n\n\t/* Lookup for the lang_tag match */\n\tsaved_pos = strlen(cur_loc_range);\n\twhile(saved_pos > 0) {\n\t\tfor(i=0; i< cur_arr_len; i++){\n\t\t\tif(cur_arr[i*2] != NULL && strlen(cur_arr[i*2]) == saved_pos && strncmp(cur_loc_range, cur_arr[i*2], saved_pos) == 0) {\n\t\t\t\t/* Match found */\n\t\t\t\tchar *str = canonicalize ? cur_arr[i*2] : cur_arr[i*2+1];\n\t\t\t\treturn_value = zend_string_init(str, strlen(str), 0);\n\t\t\t\tefree(cur_loc_range);\n\t\t\t\tLOOKUP_CLEAN_RETURN(return_value);\n\t\t\t}\n\t\t}\n\t\tsaved_pos = getStrrtokenPos(cur_loc_range, saved_pos);\n\t}\n\n\t/* Match not found */\n\tefree(cur_loc_range);\n\tLOOKUP_CLEAN_RETURN(NULL);\n}\n/* }}} */\n\n/* {{{ Searches the items in $langtag for the best match to the language\n* range\n*/\n/* }}} */\n/* {{{ Searches the items in $langtag for the best match to the language\n* range\n*/\nPHP_FUNCTION(locale_lookup)\n{\n\tzend_string*   \tfallback_loc_str\t= NULL;\n\tchar*    \tloc_range      \t\t= NULL;\n\tsize_t        \tloc_range_len  \t\t= 0;\n\n\tzval*\t\tarr\t\t\t\t= NULL;\n\tHashTable*\thash_arr\t\t= NULL;\n\tbool\tboolCanonical\t= 0;\n\tzend_string* \tresult_str\t= NULL;\n\n\tintl_error_reset( NULL );\n\n\tZEND_PARSE_PARAMETERS_START(2, 4)\n\t\tZ_PARAM_ARRAY(arr)\n\t\tZ_PARAM_PATH(loc_range, loc_range_len)\n\t\tZ_PARAM_OPTIONAL\n\t\tZ_PARAM_BOOL(boolCanonical)\n\t\tZ_PARAM_PATH_STR_OR_NULL(fallback_loc_str)\n\tZEND_PARSE_PARAMETERS_END();\n\n\tif(loc_range_len == 0) {\n\t\tif(fallback_loc_str) {\n\t\t\tloc_range = ZSTR_VAL(fallback_loc_str);\n\t\t\tloc_range_len = ZSTR_LEN(fallback_loc_str);\n\t\t} else {\n\t\t\tloc_range = (char *)intl_locale_get_default();\n\t\t\tloc_range_len = strlen(loc_range);\n\t\t}\n\t}\n\n\thash_arr = Z_ARRVAL_P(arr);\n\n\tINTL_CHECK_LOCALE_LEN(loc_range_len);\n\n\tif( !hash_arr || zend_hash_num_elements( hash_arr ) == 0 ) {\n\t\tRETURN_EMPTY_STRING();\n\t}\n\n\tresult_str = lookup_loc_range(loc_range, hash_arr, boolCanonical);\n\tif(result_str == NULL || ZSTR_VAL(result_str)[0] == '\\0') {\n\t\tif( fallback_loc_str ) {\n\t\t\tresult_str = zend_string_copy(fallback_loc_str);\n\t\t} else {\n\t\t\tRETURN_EMPTY_STRING();\n\t\t}\n\t}\n\n\tRETURN_STR(result_str);\n}\n/* }}} */\n\n/* {{{ Tries to find out best available locale based on HTTP \"Accept-Language\" header */\n/* }}} */\n/* {{{ Tries to find out best available locale based on HTTP \"Accept-Language\" header */\nPHP_FUNCTION(locale_accept_from_http)\n{\n\tUEnumeration *available;\n\tchar *http_accept = NULL;\n\tsize_t http_accept_len;\n\tUErrorCode status = 0;\n\tint len;\n\tchar resultLocale[INTL_MAX_LOCALE_LEN+1];\n\tUAcceptResult outResult;\n\n\tZEND_PARSE_PARAMETERS_START(1, 1)\n\t\tZ_PARAM_STRING(http_accept, http_accept_len)\n\tZEND_PARSE_PARAMETERS_END();\n\tif(http_accept_len > ULOC_FULLNAME_CAPACITY) {\n\t\t/* check each fragment, if any bigger than capacity, can't do it due to bug #72533 */\n\t\tchar *start = http_accept;\n\t\tchar *end;\n\t\tsize_t len;\n\t\tdo {\n\t\t\tend = strchr(start, ',');\n\t\t\tlen = end ? end-start : http_accept_len-(start-http_accept);\n\t\t\tif(len > ULOC_FULLNAME_CAPACITY) {\n\t\t\t\tintl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,\n\t\t\t\t\t\t\"locale_accept_from_http: locale string too long\", 0 );\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\t\t\tif(end) {\n\t\t\t\tstart = end+1;\n\t\t\t}\n\t\t} while(end != NULL);\n\t}\n\n\tavailable = ures_openAvailableLocales(NULL, &status);\n\tINTL_CHECK_STATUS(status, \"locale_accept_from_http: failed to retrieve locale list\");\n\tlen = uloc_acceptLanguageFromHTTP(resultLocale, INTL_MAX_LOCALE_LEN,\n\t\t\t\t\t\t&outResult, http_accept, available, &status);\n\tuenum_close(available);\n\tINTL_CHECK_STATUS(status, \"locale_accept_from_http: failed to find acceptable locale\");\n\tif (len < 0 || outResult == ULOC_ACCEPT_FAILED) {\n\t\tRETURN_FALSE;\n\t}\n\tRETURN_STRINGL(resultLocale, len);\n}\n/* }}} */\n\nPHP_FUNCTION(locale_is_right_to_left)\n{\n\tchar *locale;\n\tsize_t locale_len;\n\n\tZEND_PARSE_PARAMETERS_START(1, 1)\n\t\tZ_PARAM_PATH(locale, locale_len)\n\tZEND_PARSE_PARAMETERS_END();\n\n\tif (!locale_len) {\n\t\tlocale = (char *)intl_locale_get_default();\n\t}\n\n\tRETURN_BOOL(uloc_isRightToLeft(locale));\n}\n\nPHP_FUNCTION(locale_add_likely_subtags)\n{\n\tchar *locale, maximized_locale[ULOC_FULLNAME_CAPACITY];\n\tUErrorCode status = 0;\n\tsize_t locale_len;\n\n\tZEND_PARSE_PARAMETERS_START(1, 1)\n\t\tZ_PARAM_PATH(locale, locale_len)\n\tZEND_PARSE_PARAMETERS_END();\n\n\tif (!locale_len) {\n\t\tlocale = (char *)intl_locale_get_default();\n\t}\n\n\tint32_t maximized_locale_len = uloc_addLikelySubtags(locale, maximized_locale, sizeof(maximized_locale), &status);\n\tINTL_CHECK_STATUS(status, \"locale_add_likely_subtags: invalid locale\");\n\tif (maximized_locale_len < 0) {\n\t\tRETURN_FALSE;\n\t}\n\n\tRETURN_STRINGL(maximized_locale, maximized_locale_len);\n}\n\nPHP_FUNCTION(locale_minimize_subtags)\n{\n\tchar *locale, minimized_locale[ULOC_FULLNAME_CAPACITY];\n\tUErrorCode status = 0;\n\tsize_t locale_len;\n\n\tZEND_PARSE_PARAMETERS_START(1, 1)\n\t\tZ_PARAM_PATH(locale, locale_len)\n\tZEND_PARSE_PARAMETERS_END();\n\n\tif (!locale_len) {\n\t\tlocale = (char *)intl_locale_get_default();\n\t}\n\n\tint32_t minimized_locale_len = uloc_minimizeSubtags(locale, minimized_locale, sizeof(minimized_locale), &status);\n\tINTL_CHECK_STATUS(status, \"locale_minimize_subtags: invalid locale\");\n\tif (minimized_locale_len < 0) {\n\t\tRETURN_FALSE;\n\t}\n\n\tRETURN_STRINGL(minimized_locale, minimized_locale_len);\n}\n", "patch": "@@ -65,26 +65,26 @@ ZEND_EXTERN_MODULE_GLOBALS( intl )\n */\n static const char * const LOC_GRANDFATHERED[] = {\n \t\"art-lojban\",\t\t\"i-klingon\",\t\t\"i-lux\",\t\t\t\"i-navajo\",\t\t\"no-bok\",\t\t\"no-nyn\",\n-\t\"cel-gaulish\",\t\t\"en-GB-oed\",\t\t\"i-ami\", \t\t\n-\t\"i-bnn\",\t\t\"i-default\",\t\t\"i-enochian\",\t\n-\t\"i-mingo\",\t\t\"i-pwn\", \t\t\"i-tao\", \n+\t\"cel-gaulish\",\t\t\"en-GB-oed\",\t\t\"i-ami\",\n+\t\"i-bnn\",\t\t\"i-default\",\t\t\"i-enochian\",\n+\t\"i-mingo\",\t\t\"i-pwn\", \t\t\"i-tao\",\n \t\"i-tay\",\t\t\"i-tsu\",\t\t\"sgn-BE-fr\",\n \t\"sgn-BE-nl\",\t\t\"sgn-CH-de\", \t\t\"zh-cmn\",\n  \t\"zh-cmn-Hans\", \t\t\"zh-cmn-Hant\",\t\t\"zh-gan\" ,\n \t\"zh-guoyu\", \t\t\"zh-hakka\", \t\t\"zh-min\",\n-\t\"zh-min-nan\", \t\t\"zh-wuu\", \t\t\"zh-xiang\",\t\n+\t\"zh-min-nan\", \t\t\"zh-wuu\", \t\t\"zh-xiang\",\n \t\"zh-yue\",\t\tNULL\n };\n \n /* Based on IANA registry at the time of writing this code\n *  This array lists the preferred values for the grandfathered tags if applicable\n-*  This is in sync with the array LOC_GRANDFATHERED\t \n+*  This is in sync with the array LOC_GRANDFATHERED\n *  e.g. the offsets of the grandfathered tags match the offset of the preferred  value\n */\n static const int \t\tLOC_PREFERRED_GRANDFATHERED_LEN = 6;\n static const char * const \tLOC_PREFERRED_GRANDFATHERED[]  = {\n \t\"jbo\",\t\t\t\"tlh\",\t\t\t\"lb\",\n-\t\"nv\", \t\t\t\"nb\",\t\t\t\"nn\",\t\t\t\n+\t\"nv\", \t\t\t\"nb\",\t\t\t\"nn\",\n \tNULL\n };\n \n@@ -122,7 +122,7 @@ static int16_t findOffset(const char* const* list, const char* key)\n /*}}}*/\n \n static char* getPreferredTag(const char* gf_tag)\n-{ \n+{\n \tchar* result = NULL;\n \tint grOffset = 0;\n \n@@ -141,15 +141,15 @@ static char* getPreferredTag(const char* gf_tag)\n }\n \n /* {{{\n-* returns the position of next token for lookup \n+* returns the position of next token for lookup\n * or -1 if no token\n-* strtokr equivalent search for token in reverse direction \n+* strtokr equivalent search for token in reverse direction\n */\n static int getStrrtokenPos(char* str, int savedPos)\n {\n \tint result =-1;\n \tint i;\n-\t\n+\n \tfor(i=savedPos-1; i>=0; i--) {\n \t\tif(isIDSeparator(*(str+i)) ){\n \t\t\t/* delimiter found; check for singleton */\n@@ -171,7 +171,7 @@ static int getStrrtokenPos(char* str, int savedPos)\n /* }}} */\n \n /* {{{\n-* returns the position of a singleton if present \n+* returns the position of a singleton if present\n * returns -1 if no singleton\n * strtok equivalent search for singleton\n */\n@@ -180,7 +180,7 @@ static int getSingletonPos(const char* str)\n \tint result =-1;\n \tint i=0;\n \tint len = 0;\n-\t\n+\n \tif( str && ((len=strlen(str))>0) ){\n \t\tfor( i=0; i<len ; i++){\n \t\t\tif( isIDSeparator(*(str+i)) ){\n@@ -198,7 +198,7 @@ static int getSingletonPos(const char* str)\n \t\t\t\t}\n \t\t\t}\n \t\t}/* end of for */\n-\t\t\n+\n \t}\n \treturn result;\n }\n@@ -224,7 +224,7 @@ PHP_NAMED_FUNCTION(zif_locale_get_default)\n PHP_NAMED_FUNCTION(zif_locale_set_default)\n {\n \tchar* locale_name = NULL;\n-\tint   len=0;\t\n+\tint   len=0;\n \n \tif(zend_parse_parameters( ZEND_NUM_ARGS() TSRMLS_CC,  \"s\",\n \t\t&locale_name ,&len ) == FAILURE)\n@@ -240,14 +240,14 @@ PHP_NAMED_FUNCTION(zif_locale_set_default)\n \t\tlen = strlen(locale_name);\n \t}\n \n-\tzend_alter_ini_entry(LOCALE_INI_NAME, sizeof(LOCALE_INI_NAME), locale_name, len, PHP_INI_USER, PHP_INI_STAGE_RUNTIME);\t\n+\tzend_alter_ini_entry(LOCALE_INI_NAME, sizeof(LOCALE_INI_NAME), locale_name, len, PHP_INI_USER, PHP_INI_STAGE_RUNTIME);\n \n \tRETURN_TRUE;\n }\n /* }}} */\n \n /* {{{\n-* Gets the value from ICU \n+* Gets the value from ICU\n * common code shared by get_primary_language,get_script or get_region or get_variant\n * result = 0 if error, 1 if successful , -1 if no value\n */\n@@ -284,7 +284,7 @@ static char* get_icu_value_internal( const char* loc_name , char* tag_name, int*\n \t\t\t}\n \t\t}\n \n-\t\tsingletonPos = getSingletonPos( loc_name );\t\n+\t\tsingletonPos = getSingletonPos( loc_name );\n \t\tif( singletonPos == 0){\n \t\t\t/* singleton at start of script, region , variant etc.\n \t\t\t * or invalid singleton at start of language */\n@@ -299,7 +299,7 @@ static char* get_icu_value_internal( const char* loc_name , char* tag_name, int*\n \t} /* end of if != LOC_CANONICAL_TAG */\n \n \tif( mod_loc_name == NULL){\n-\t\tmod_loc_name = estrdup(loc_name );\t\n+\t\tmod_loc_name = estrdup(loc_name );\n \t}\n \n \t/* Proceed to ICU */\n@@ -326,6 +326,7 @@ static char* get_icu_value_internal( const char* loc_name , char* tag_name, int*\n \t\tif( U_FAILURE( status ) ) {\n \t\t\tif( status == U_BUFFER_OVERFLOW_ERROR ) {\n \t\t\t\tstatus = U_ZERO_ERROR;\n+\t\t\t\tbuflen++; /* add space for \\0 */\n \t\t\t\tcontinue;\n \t\t\t}\n \n@@ -366,7 +367,7 @@ static char* get_icu_value_internal( const char* loc_name , char* tag_name, int*\n * Gets the value from ICU , called when PHP userspace function is called\n * common code shared by get_primary_language,get_script or get_region or get_variant\n */\n-static void get_icu_value_src_php( char* tag_name, INTERNAL_FUNCTION_PARAMETERS) \n+static void get_icu_value_src_php( char* tag_name, INTERNAL_FUNCTION_PARAMETERS)\n {\n \n \tconst char* loc_name        \t= NULL;\n@@ -422,47 +423,47 @@ static void get_icu_value_src_php( char* tag_name, INTERNAL_FUNCTION_PARAMETERS)\n }\n /* }}} */\n \n-/* {{{ proto static string Locale::getScript($locale) \n- * gets the script for the $locale \n+/* {{{ proto static string Locale::getScript($locale)\n+ * gets the script for the $locale\n  }}} */\n-/* {{{ proto static string locale_get_script($locale) \n- * gets the script for the $locale \n+/* {{{ proto static string locale_get_script($locale)\n+ * gets the script for the $locale\n  */\n-PHP_FUNCTION( locale_get_script ) \n+PHP_FUNCTION( locale_get_script )\n {\n \tget_icu_value_src_php( LOC_SCRIPT_TAG , INTERNAL_FUNCTION_PARAM_PASSTHRU );\n }\n /* }}} */\n \n-/* {{{ proto static string Locale::getRegion($locale) \n- * gets the region for the $locale \n+/* {{{ proto static string Locale::getRegion($locale)\n+ * gets the region for the $locale\n  }}} */\n-/* {{{ proto static string locale_get_region($locale) \n- * gets the region for the $locale \n+/* {{{ proto static string locale_get_region($locale)\n+ * gets the region for the $locale\n  */\n-PHP_FUNCTION( locale_get_region ) \n+PHP_FUNCTION( locale_get_region )\n {\n \tget_icu_value_src_php( LOC_REGION_TAG , INTERNAL_FUNCTION_PARAM_PASSTHRU );\n }\n /* }}} */\n \n-/* {{{ proto static string Locale::getPrimaryLanguage($locale) \n- * gets the primary language for the $locale \n+/* {{{ proto static string Locale::getPrimaryLanguage($locale)\n+ * gets the primary language for the $locale\n  }}} */\n-/* {{{ proto static string locale_get_primary_language($locale) \n- * gets the primary language for the $locale \n+/* {{{ proto static string locale_get_primary_language($locale)\n+ * gets the primary language for the $locale\n  */\n-PHP_FUNCTION(locale_get_primary_language ) \n+PHP_FUNCTION(locale_get_primary_language )\n {\n \tget_icu_value_src_php( LOC_LANG_TAG , INTERNAL_FUNCTION_PARAM_PASSTHRU );\n }\n /* }}} */\n \n \n /* {{{\n- * common code shared by display_xyz functions to  get the value from ICU \n+ * common code shared by display_xyz functions to  get the value from ICU\n  }}} */\n-static void get_icu_disp_value_src_php( char* tag_name, INTERNAL_FUNCTION_PARAMETERS) \n+static void get_icu_disp_value_src_php( char* tag_name, INTERNAL_FUNCTION_PARAMETERS)\n {\n \tconst char* loc_name        \t= NULL;\n \tint         loc_name_len    \t= 0;\n@@ -488,7 +489,7 @@ static void get_icu_disp_value_src_php( char* tag_name, INTERNAL_FUNCTION_PARAME\n \tintl_error_reset( NULL TSRMLS_CC );\n \n \tif(zend_parse_parameters( ZEND_NUM_ARGS() TSRMLS_CC, \"s|s\",\n-\t\t&loc_name, &loc_name_len , \n+\t\t&loc_name, &loc_name_len ,\n \t\t&disp_loc_name ,&disp_loc_name_len ) == FAILURE)\n \t{\n \t\tspprintf(&msg , 0, \"locale_get_display_%s : unable to parse input params\", tag_name );\n@@ -525,7 +526,7 @@ static void get_icu_disp_value_src_php( char* tag_name, INTERNAL_FUNCTION_PARAME\n \tif( mod_loc_name==NULL ){\n \t\tmod_loc_name = estrdup( loc_name );\n \t}\n-\t\n+\n \t/* Check if disp_loc_name passed , if not use default locale */\n \tif( !disp_loc_name){\n \t\tdisp_loc_name = estrdup(intl_locale_get_default(TSRMLS_C));\n@@ -604,7 +605,7 @@ static void get_icu_disp_value_src_php( char* tag_name, INTERNAL_FUNCTION_PARAME\n /* {{{ proto static string get_display_name($locale[, $in_locale = null])\n * gets the name for the $locale in $in_locale or default_locale\n */\n-PHP_FUNCTION(locale_get_display_name) \n+PHP_FUNCTION(locale_get_display_name)\n {\n     get_icu_disp_value_src_php( DISP_NAME , INTERNAL_FUNCTION_PARAM_PASSTHRU );\n }\n@@ -616,7 +617,7 @@ PHP_FUNCTION(locale_get_display_name)\n /* {{{ proto static string get_display_language($locale[, $in_locale = null])\n * gets the language for the $locale in $in_locale or default_locale\n */\n-PHP_FUNCTION(locale_get_display_language) \n+PHP_FUNCTION(locale_get_display_language)\n {\n     get_icu_disp_value_src_php( LOC_LANG_TAG , INTERNAL_FUNCTION_PARAM_PASSTHRU );\n }\n@@ -628,7 +629,7 @@ PHP_FUNCTION(locale_get_display_language)\n /* {{{ proto static string get_display_script($locale, $in_locale = null)\n * gets the script for the $locale in $in_locale or default_locale\n */\n-PHP_FUNCTION(locale_get_display_script) \n+PHP_FUNCTION(locale_get_display_script)\n {\n     get_icu_disp_value_src_php( LOC_SCRIPT_TAG , INTERNAL_FUNCTION_PARAM_PASSTHRU );\n }\n@@ -640,7 +641,7 @@ PHP_FUNCTION(locale_get_display_script)\n /* {{{ proto static string get_display_region($locale, $in_locale = null)\n * gets the region for the $locale in $in_locale or default_locale\n */\n-PHP_FUNCTION(locale_get_display_region) \n+PHP_FUNCTION(locale_get_display_region)\n {\n     get_icu_disp_value_src_php( LOC_REGION_TAG , INTERNAL_FUNCTION_PARAM_PASSTHRU );\n }\n@@ -654,7 +655,7 @@ PHP_FUNCTION(locale_get_display_region)\n * proto static string get_display_variant($locale, $in_locale = null)\n * gets the variant for the $locale in $in_locale or default_locale\n */\n-PHP_FUNCTION(locale_get_display_variant) \n+PHP_FUNCTION(locale_get_display_variant)\n {\n     get_icu_disp_value_src_php( LOC_VARIANT_TAG , INTERNAL_FUNCTION_PARAM_PASSTHRU );\n }\n@@ -667,7 +668,7 @@ PHP_FUNCTION(locale_get_display_variant)\n  /* {{{ proto static array locale_get_keywords(string $locale) {\n  * return an associative array containing keyword-value\n  * pairs for this locale. The keys are keys to the array (doh!)\n- */ \n+ */\n PHP_FUNCTION( locale_get_keywords )\n {\n     UEnumeration*   e        = NULL;\n@@ -679,10 +680,10 @@ PHP_FUNCTION( locale_get_keywords )\n     const char*       \tloc_name        = NULL;\n     int        \t \tloc_name_len    = 0;\n \n-/* \n-\tICU expects the buffer to be allocated  before calling the function \n-\tand so the buffer size has been explicitly specified \n-\tICU uloc.h #define \tULOC_KEYWORD_AND_VALUES_CAPACITY   100 \n+/*\n+\tICU expects the buffer to be allocated  before calling the function\n+\tand so the buffer size has been explicitly specified\n+\tICU uloc.h #define \tULOC_KEYWORD_AND_VALUES_CAPACITY   100\n \thence the kw_value buffer size is 100\n */\n \tchar*\t \tkw_value        = NULL;\n@@ -721,7 +722,7 @@ PHP_FUNCTION( locale_get_keywords )\n \t\t\t\tkw_value_len=uloc_getKeywordValue( loc_name,kw_key, kw_value, kw_value_len+1 ,  &status );\n \t\t\t} else if(!U_FAILURE(status)) {\n \t\t\t\tkw_value = erealloc( kw_value , kw_value_len+1);\n-\t\t\t} \n+\t\t\t}\n \t\t\tif (U_FAILURE(status)) {\n \t        \t\tintl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR, \"locale_get_keywords: Error encountered while getting the keyword  value for the  keyword\", 0 TSRMLS_CC );\n \t\t\t\tif( kw_value){\n@@ -740,10 +741,10 @@ PHP_FUNCTION( locale_get_keywords )\n }\n /* }}} */\n \n- /* {{{ proto static string Locale::canonicalize($locale) \n- * @return string the canonicalized locale \n+ /* {{{ proto static string Locale::canonicalize($locale)\n+ * @return string the canonicalized locale\n  * }}} */\n- /* {{{ proto static string locale_canonicalize(Locale $loc, string $locale) \n+ /* {{{ proto static string locale_canonicalize(Locale $loc, string $locale)\n  * @param string $locale\tThe locale string to canonicalize\n  */\n PHP_FUNCTION(locale_canonicalize)\n@@ -752,10 +753,10 @@ PHP_FUNCTION(locale_canonicalize)\n }\n /* }}} */\n \n-/* {{{ append_key_value \n+/* {{{ append_key_value\n * Internal function which is called from locale_compose\n * gets the value for the key_name and appends to the loc_name\n-* returns 1 if successful , -1 if not found , \n+* returns 1 if successful , -1 if not found ,\n * 0 if array element is not a string , -2 if buffer-overflow\n */\n static int append_key_value(smart_str* loc_name, HashTable* hash_arr, char* key_name)\n@@ -767,7 +768,7 @@ static int append_key_value(smart_str* loc_name, HashTable* hash_arr, char* key_\n \t\t\t/* element value is not a string */\n \t\t\treturn FAILURE;\n \t\t}\n-\t\tif(strcmp(key_name, LOC_LANG_TAG) != 0 && \n+\t\tif(strcmp(key_name, LOC_LANG_TAG) != 0 &&\n \t\t   strcmp(key_name, LOC_GRANDFATHERED_LANG_TAG)!=0 ) {\n \t\t\t/* not lang or grandfathered tag */\n \t\t\tsmart_str_appendl(loc_name, SEPARATOR , sizeof(SEPARATOR)-1);\n@@ -792,11 +793,11 @@ static void add_prefix(smart_str* loc_name, char* key_name)\n }\n /* }}} */\n \n-/* {{{ append_multiple_key_values \n+/* {{{ append_multiple_key_values\n * Internal function which is called from locale_compose\n * gets the multiple values for the key_name and appends to the loc_name\n-* used for 'variant','extlang','private' \n-* returns 1 if successful , -1 if not found , \n+* used for 'variant','extlang','private'\n+* returns 1 if successful , -1 if not found ,\n * 0 if array element is not a string , -2 if buffer-overflow\n */\n static int append_multiple_key_values(smart_str* loc_name, HashTable* hash_arr, char* key_name TSRMLS_DC)\n@@ -850,8 +851,8 @@ static int append_multiple_key_values(smart_str* loc_name, HashTable* hash_arr,\n \n \t\t/* Multiple variant values as variant0, variant1 ,variant2 */\n \t\tisFirstSubtag = 0;\n-\t\tfor( i=0 ; i< max_value; i++ ){  \n-\t\t\tsnprintf( cur_key_name , 30, \"%s%d\", key_name , i);\t\n+\t\tfor( i=0 ; i< max_value; i++ ){\n+\t\t\tsnprintf( cur_key_name , 30, \"%s%d\", key_name , i);\n \t\t\tif( zend_hash_find( hash_arr , cur_key_name , strlen(cur_key_name) + 1,(void **)&ele_value ) == SUCCESS ){\n \t\t\t\tif( Z_TYPE_PP(ele_value)!= IS_STRING ){\n \t\t\t\t\t/* variant is not a string */\n@@ -873,7 +874,7 @@ static int append_multiple_key_values(smart_str* loc_name, HashTable* hash_arr,\n \n /*{{{\n * If applicable sets error message and aborts locale_compose gracefully\n-* returns 0  if locale_compose needs to be aborted \n+* returns 0  if locale_compose needs to be aborted\n * otherwise returns 1\n */\n static int handleAppendResult( int result, smart_str* loc_name TSRMLS_DC)\n@@ -890,11 +891,11 @@ static int handleAppendResult( int result, smart_str* loc_name TSRMLS_DC)\n /* }}} */\n \n #define RETURN_SMART_STR(s) smart_str_0((s)); RETURN_STRINGL((s)->c, (s)->len, 0)\n-/* {{{ proto static string Locale::composeLocale($array) \n-* Creates a locale by combining the parts of locale-ID passed\t\n+/* {{{ proto static string Locale::composeLocale($array)\n+* Creates a locale by combining the parts of locale-ID passed\n * }}} */\n-/* {{{ proto static string compose_locale($array) \n-* Creates a locale by combining the parts of locale-ID passed\t\n+/* {{{ proto static string compose_locale($array)\n+* Creates a locale by combining the parts of locale-ID passed\n * }}} */\n PHP_FUNCTION(locale_compose)\n {\n@@ -920,7 +921,7 @@ PHP_FUNCTION(locale_compose)\n \t\tRETURN_FALSE;\n \n \t/* Check for grandfathered first */\n-\tresult = append_key_value(loc_name, hash_arr,  LOC_GRANDFATHERED_LANG_TAG);\t\n+\tresult = append_key_value(loc_name, hash_arr,  LOC_GRANDFATHERED_LANG_TAG);\n \tif( result == SUCCESS){\n \t\tRETURN_SMART_STR(loc_name);\n \t}\n@@ -929,7 +930,7 @@ PHP_FUNCTION(locale_compose)\n \t}\n \n \t/* Not grandfathered */\n-\tresult = append_key_value(loc_name, hash_arr , LOC_LANG_TAG);\t\n+\tresult = append_key_value(loc_name, hash_arr , LOC_LANG_TAG);\n \tif( result == LOC_NOT_FOUND ){\n \t\tintl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,\n \t\t\"locale_compose: parameter array does not contain 'language' tag.\", 0 TSRMLS_CC );\n@@ -947,19 +948,19 @@ PHP_FUNCTION(locale_compose)\n \t}\n \n \t/* Script */\n-\tresult = append_key_value(loc_name, hash_arr , LOC_SCRIPT_TAG); \n+\tresult = append_key_value(loc_name, hash_arr , LOC_SCRIPT_TAG);\n \tif( !handleAppendResult( result, loc_name TSRMLS_CC)){\n \t\tRETURN_FALSE;\n \t}\n-\t\n+\n \t/* Region */\n \tresult = append_key_value( loc_name, hash_arr , LOC_REGION_TAG);\n \tif( !handleAppendResult( result, loc_name TSRMLS_CC)){\n \t\tRETURN_FALSE;\n \t}\n \n \t/* Variant */\n-\tresult = append_multiple_key_values( loc_name, hash_arr , LOC_VARIANT_TAG TSRMLS_CC); \n+\tresult = append_multiple_key_values( loc_name, hash_arr , LOC_VARIANT_TAG TSRMLS_CC);\n \tif( !handleAppendResult( result, loc_name TSRMLS_CC)){\n \t\tRETURN_FALSE;\n \t}\n@@ -985,16 +986,16 @@ static char* get_private_subtags(const char* loc_name)\n {\n \tchar* \tresult =NULL;\n \tint \tsingletonPos = 0;\n-\tint \tlen =0; \n+\tint \tlen =0;\n \tconst char* \tmod_loc_name =NULL;\n \n \tif( loc_name && (len = strlen(loc_name)>0 ) ){\n-\t\tmod_loc_name = loc_name ; \n+\t\tmod_loc_name = loc_name ;\n \t\tlen   = strlen(mod_loc_name);\n \t\twhile( (singletonPos = getSingletonPos(mod_loc_name))!= -1){\n \n-\t\t\tif( singletonPos!=-1){ \n-\t\t\t\tif( (*(mod_loc_name+singletonPos)=='x') || (*(mod_loc_name+singletonPos)=='X') ){\t\t\n+\t\t\tif( singletonPos!=-1){\n+\t\t\t\tif( (*(mod_loc_name+singletonPos)=='x') || (*(mod_loc_name+singletonPos)=='X') ){\n \t\t\t\t\t/* private subtag start found */\n \t\t\t\t\tif( singletonPos + 2 ==  len){\n \t\t\t\t\t\t/* loc_name ends with '-x-' ; return  NULL */\n@@ -1019,7 +1020,7 @@ static char* get_private_subtags(const char* loc_name)\n \n \t\t} /* end of while */\n \t}\n-\t\n+\n \treturn result;\n }\n /* }}} */\n@@ -1044,20 +1045,20 @@ static int add_array_entry(const char* loc_name, zval* hash_arr, char* key_name\n \t} else {\n \t\tkey_value = get_icu_value_internal( loc_name , key_name , &result,1 );\n \t}\n-\tif( (strcmp(key_name , LOC_PRIVATE_TAG)==0) || \n+\tif( (strcmp(key_name , LOC_PRIVATE_TAG)==0) ||\n \t\t( strcmp(key_name , LOC_VARIANT_TAG)==0) ){\n \t\tif( result > 0 && key_value){\n \t\t\t/* Tokenize on the \"_\" or \"-\"  */\n-\t\t\ttoken = php_strtok_r( key_value , DELIMITER ,&last_ptr);\t\n+\t\t\ttoken = php_strtok_r( key_value , DELIMITER ,&last_ptr);\n \t\t\tif( cur_key_name ){\n \t\t\t\tefree( cur_key_name);\n \t\t\t}\n \t\t\tcur_key_name = (char*)ecalloc( 25,  25);\n-\t\t\tsprintf( cur_key_name , \"%s%d\", key_name , cnt++);\t\n+\t\t\tsprintf( cur_key_name , \"%s%d\", key_name , cnt++);\n \t\t\tadd_assoc_string( hash_arr, cur_key_name , token ,TRUE );\n \t\t\t/* tokenize on the \"_\" or \"-\" and stop  at singleton if any */\n \t\t\twhile( (token = php_strtok_r(NULL , DELIMITER , &last_ptr)) && (strlen(token)>1) ){\n-\t\t\t\tsprintf( cur_key_name , \"%s%d\", key_name , cnt++);\t\n+\t\t\t\tsprintf( cur_key_name , \"%s%d\", key_name , cnt++);\n \t\t\t\tadd_assoc_string( hash_arr, cur_key_name , token , TRUE );\n \t\t\t}\n /*\n@@ -1077,16 +1078,16 @@ static int add_array_entry(const char* loc_name, zval* hash_arr, char* key_name\n \t}\n \t/*if( key_name != LOC_PRIVATE_TAG && key_value){*/\n \tif( key_value){\n-\t\tefree(key_value);\t\n+\t\tefree(key_value);\n \t}\n \treturn cur_result;\n }\n /* }}} */\n \n-/* {{{ proto static array Locale::parseLocale($locale) \n+/* {{{ proto static array Locale::parseLocale($locale)\n * parses a locale-id into an array the different parts of it\n  }}} */\n-/* {{{ proto static array parse_locale($locale) \n+/* {{{ proto static array parse_locale($locale)\n * parses a locale-id into an array the different parts of it\n */\n PHP_FUNCTION(locale_parse)\n@@ -1144,7 +1145,7 @@ PHP_FUNCTION(locale_get_all_variants)\n \tchar*\tsaved_ptr\t= NULL;\n \n \tintl_error_reset( NULL TSRMLS_CC );\n-\t\n+\n \tif(zend_parse_parameters( ZEND_NUM_ARGS() TSRMLS_CC, \"s\",\n \t&loc_name, &loc_name_len ) == FAILURE)\n \t{\n@@ -1162,15 +1163,15 @@ PHP_FUNCTION(locale_get_all_variants)\n \tarray_init( return_value );\n \n \t/* If the locale is grandfathered, stop, no variants */\n-\tif( findOffset( LOC_GRANDFATHERED , loc_name ) >=  0 ){ \n+\tif( findOffset( LOC_GRANDFATHERED , loc_name ) >=  0 ){\n \t\t/* (\"Grandfathered Tag. No variants.\"); */\n \t}\n-\telse {\t\n+\telse {\n \t/* Call ICU variant */\n \t\tvariant = get_icu_value_internal( loc_name , LOC_VARIANT_TAG , &result ,0);\n \t\tif( result > 0 && variant){\n \t\t\t/* Tokenize on the \"_\" or \"-\" */\n-\t\t\ttoken = php_strtok_r( variant , DELIMITER , &saved_ptr);\t\n+\t\t\ttoken = php_strtok_r( variant , DELIMITER , &saved_ptr);\n \t\t\tadd_next_index_stringl( return_value, token , strlen(token) ,TRUE );\n \t\t\t/* tokenize on the \"_\" or \"-\" and stop  at singleton if any\t*/\n \t\t\twhile( (token = php_strtok_r(NULL , DELIMITER, &saved_ptr)) && (strlen(token)>1) ){\n@@ -1181,7 +1182,7 @@ PHP_FUNCTION(locale_get_all_variants)\n \t\t\tefree( variant );\n \t\t}\n \t}\n-\t\t\t\n+\n \n }\n /* }}} */\n@@ -1220,11 +1221,11 @@ static int strToMatch(const char* str ,char *retstr)\n /* }}} */\n \n /* {{{ proto static boolean Locale::filterMatches(string $langtag, string $locale[, bool $canonicalize])\n-* Checks if a $langtag filter matches with $locale according to RFC 4647's basic filtering algorithm \n+* Checks if a $langtag filter matches with $locale according to RFC 4647's basic filtering algorithm\n */\n /* }}} */\n /* {{{ proto boolean locale_filter_matches(string $langtag, string $locale[, bool $canonicalize])\n-* Checks if a $langtag filter matches with $locale according to RFC 4647's basic filtering algorithm \n+* Checks if a $langtag filter matches with $locale according to RFC 4647's basic filtering algorithm\n */\n PHP_FUNCTION(locale_filter_matches)\n {\n@@ -1243,13 +1244,13 @@ PHP_FUNCTION(locale_filter_matches)\n \tchar*       \tcur_lang_tag    = NULL;\n \tchar*       \tcur_loc_range   = NULL;\n \n-\tzend_bool \tboolCanonical \t= 0;\t\n+\tzend_bool \tboolCanonical \t= 0;\n \tUErrorCode\tstatus\t\t= U_ZERO_ERROR;\n \n \tintl_error_reset( NULL TSRMLS_CC );\n-\t\n+\n \tif(zend_parse_parameters( ZEND_NUM_ARGS() TSRMLS_CC, \"ss|b\",\n-\t\t&lang_tag, &lang_tag_len , &loc_range , &loc_range_len , \n+\t\t&lang_tag, &lang_tag_len , &loc_range , &loc_range_len ,\n \t\t&boolCanonical) == FAILURE)\n \t{\n \t\tintl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,\n@@ -1270,15 +1271,15 @@ PHP_FUNCTION(locale_filter_matches)\n \t\t/* canonicalize loc_range */\n \t\tcan_loc_range=get_icu_value_internal( loc_range , LOC_CANONICALIZE_TAG , &result , 0);\n \t\tif( result ==0) {\n-\t\t\tintl_error_set( NULL, status, \n+\t\t\tintl_error_set( NULL, status,\n \t\t\t\t\"locale_filter_matches : unable to canonicalize loc_range\" , 0 TSRMLS_CC );\n \t\t\tRETURN_FALSE;\n \t\t}\n \n \t\t/* canonicalize lang_tag */\n \t\tcan_lang_tag = get_icu_value_internal( lang_tag , LOC_CANONICALIZE_TAG , &result ,  0);\n \t\tif( result ==0) {\n-\t\t\tintl_error_set( NULL, status, \n+\t\t\tintl_error_set( NULL, status,\n \t\t\t\t\"locale_filter_matches : unable to canonicalize lang_tag\" , 0 TSRMLS_CC );\n \t\t\tRETURN_FALSE;\n \t\t}\n@@ -1306,11 +1307,11 @@ PHP_FUNCTION(locale_filter_matches)\n \n \t\t/* check if prefix */\n \t\ttoken \t= strstr( cur_lang_tag , cur_loc_range );\n-\t\n+\n \t\tif( token && (token==cur_lang_tag) ){\n \t\t\t/* check if the char. after match is SEPARATOR */\n \t\t\tchrcheck = token + (strlen(cur_loc_range));\n-\t\t\tif( isIDSeparator(*chrcheck) || isEndOfTag(*chrcheck) ){ \n+\t\t\tif( isIDSeparator(*chrcheck) || isEndOfTag(*chrcheck) ){\n \t\t\t\tif( cur_lang_tag){\n \t\t\t\t\tefree( cur_lang_tag );\n \t\t\t\t}\n@@ -1346,7 +1347,7 @@ PHP_FUNCTION(locale_filter_matches)\n \telse{\n \t\t/* Convert to lower case for case-insensitive comparison */\n \t\tcur_lang_tag = ecalloc( 1, strlen(lang_tag ) + 1);\n-\t\t\n+\n \t\tresult = strToMatch( lang_tag , cur_lang_tag);\n \t\tif( result == 0) {\n \t\t\tefree( cur_lang_tag );\n@@ -1362,11 +1363,11 @@ PHP_FUNCTION(locale_filter_matches)\n \n \t\t/* check if prefix */\n \t\ttoken \t= strstr( cur_lang_tag , cur_loc_range );\n-\t\t\n+\n \t\tif( token && (token==cur_lang_tag) ){\n \t\t\t/* check if the char. after match is SEPARATOR */\n \t\t\tchrcheck = token + (strlen(cur_loc_range));\n-\t\t\tif( isIDSeparator(*chrcheck) || isEndOfTag(*chrcheck) ){ \n+\t\t\tif( isIDSeparator(*chrcheck) || isEndOfTag(*chrcheck) ){\n \t\t\t\tif( cur_lang_tag){\n \t\t\t\t\tefree( cur_lang_tag );\n \t\t\t\t}\n@@ -1393,7 +1394,7 @@ PHP_FUNCTION(locale_filter_matches)\n static void array_cleanup( char* arr[] , int arr_size)\n {\n \tint i=0;\n-\tfor( i=0; i< arr_size; i++ ){ \n+\tfor( i=0; i< arr_size; i++ ){\n \t\tif( arr[i*2] ){\n \t\t\tefree( arr[i*2]);\n \t\t}\n@@ -1403,7 +1404,7 @@ static void array_cleanup( char* arr[] , int arr_size)\n \n #define LOOKUP_CLEAN_RETURN(value)\tarray_cleanup(cur_arr, cur_arr_len); return (value)\n /* {{{\n-* returns the lookup result to lookup_loc_range_src_php \n+* returns the lookup result to lookup_loc_range_src_php\n * internal function\n */\n static char* lookup_loc_range(const char* loc_range, HashTable* hash_arr, int canonicalize  TSRMLS_DC)\n@@ -1427,7 +1428,7 @@ static char* lookup_loc_range(const char* loc_range, HashTable* hash_arr, int ca\n \tfor(zend_hash_internal_pointer_reset(hash_arr);\n \t\tzend_hash_has_more_elements(hash_arr) == SUCCESS;\n \t\tzend_hash_move_forward(hash_arr)) {\n-\t\t\n+\n \t\tif (zend_hash_get_current_data(hash_arr, (void**)&ele_value) == FAILURE) {\n \t\t\t/* Should never actually fail since the key is known to exist.*/\n \t\t\tcontinue;\n@@ -1436,20 +1437,20 @@ static char* lookup_loc_range(const char* loc_range, HashTable* hash_arr, int ca\n \t\t\t/* element value is not a string */\n \t\t\tintl_error_set(NULL, U_ILLEGAL_ARGUMENT_ERROR, \"lookup_loc_range: locale array element is not a string\", 0 TSRMLS_CC);\n \t\t\tLOOKUP_CLEAN_RETURN(NULL);\n-\t\t} \n+\t\t}\n \t\tcur_arr[cur_arr_len*2] = estrndup(Z_STRVAL_PP(ele_value), Z_STRLEN_PP(ele_value));\n \t\tresult = strToMatch(Z_STRVAL_PP(ele_value), cur_arr[cur_arr_len*2]);\n \t\tif(result == 0) {\n \t\t\tintl_error_set(NULL, U_ILLEGAL_ARGUMENT_ERROR, \"lookup_loc_range: unable to canonicalize lang_tag\", 0 TSRMLS_CC);\n \t\t\tLOOKUP_CLEAN_RETURN(NULL);\n \t\t}\n \t\tcur_arr[cur_arr_len*2+1] = Z_STRVAL_PP(ele_value);\n-\t\tcur_arr_len++ ; \n+\t\tcur_arr_len++ ;\n \t} /* end of for */\n \n \t/* Canonicalize array elements */\n \tif(canonicalize) {\n-\t\tfor(i=0; i<cur_arr_len; i++) { \n+\t\tfor(i=0; i<cur_arr_len; i++) {\n \t\t\tlang_tag = get_icu_value_internal(cur_arr[i*2], LOC_CANONICALIZE_TAG, &result, 0);\n \t\t\tif(result != 1 || lang_tag == NULL || !lang_tag[0]) {\n \t\t\t\tif(lang_tag) {\n@@ -1459,7 +1460,7 @@ static char* lookup_loc_range(const char* loc_range, HashTable* hash_arr, int ca\n \t\t\t\tLOOKUP_CLEAN_RETURN(NULL);\n \t\t\t}\n \t\t\tcur_arr[i*2] = erealloc(cur_arr[i*2], strlen(lang_tag)+1);\n-\t\t\tresult = strToMatch(lang_tag, cur_arr[i*2]);\t\n+\t\t\tresult = strToMatch(lang_tag, cur_arr[i*2]);\n \t\t\tefree(lang_tag);\n \t\t\tif(result == 0) {\n \t\t\t\tintl_error_set(NULL, U_ILLEGAL_ARGUMENT_ERROR, \"lookup_loc_range: unable to canonicalize lang_tag\" , 0 TSRMLS_CC);\n@@ -1482,11 +1483,11 @@ static char* lookup_loc_range(const char* loc_range, HashTable* hash_arr, int ca\n \t\t} else {\n \t\t\tloc_range = can_loc_range;\n \t\t}\n-\t} \n+\t}\n \n \tcur_loc_range = ecalloc(1, strlen(loc_range)+1);\n \t/* convert to lower and replace hyphens */\n-\tresult = strToMatch(loc_range, cur_loc_range);\t\n+\tresult = strToMatch(loc_range, cur_loc_range);\n \tif(can_loc_range) {\n \t\tefree(can_loc_range);\n \t}\n@@ -1498,8 +1499,8 @@ static char* lookup_loc_range(const char* loc_range, HashTable* hash_arr, int ca\n \t/* Lookup for the lang_tag match */\n \tsaved_pos = strlen(cur_loc_range);\n \twhile(saved_pos > 0) {\n-\t\tfor(i=0; i< cur_arr_len; i++){ \n-\t\t\tif(cur_arr[i*2] != NULL && strlen(cur_arr[i*2]) == saved_pos && strncmp(cur_loc_range, cur_arr[i*2], saved_pos) == 0) {\t\n+\t\tfor(i=0; i< cur_arr_len; i++){\n+\t\t\tif(cur_arr[i*2] != NULL && strlen(cur_arr[i*2]) == saved_pos && strncmp(cur_loc_range, cur_arr[i*2], saved_pos) == 0) {\n \t\t\t\t/* Match found */\n \t\t\t\treturn_value = estrdup(canonicalize?cur_arr[i*2]:cur_arr[i*2+1]);\n \t\t\t\tefree(cur_loc_range);\n@@ -1515,14 +1516,14 @@ static char* lookup_loc_range(const char* loc_range, HashTable* hash_arr, int ca\n }\n /* }}} */\n \n-/* {{{ proto string Locale::lookup(array $langtag, string $locale[, bool $canonicalize[, string $default = null]]) \n+/* {{{ proto string Locale::lookup(array $langtag, string $locale[, bool $canonicalize[, string $default = null]])\n * Searchs the items in $langtag for the best match to the language\n-* range \n+* range\n */\n /* }}} */\n /* {{{ proto string locale_lookup(array $langtag, string $locale[, bool $canonicalize[, string $default = null]])\n * Searchs the items in $langtag for the best match to the language\n-* range \n+* range\n */\n PHP_FUNCTION(locale_lookup)\n {\n@@ -1552,8 +1553,8 @@ PHP_FUNCTION(locale_lookup)\n \n \tif( !hash_arr || zend_hash_num_elements( hash_arr ) == 0 ) {\n \t\tRETURN_EMPTY_STRING();\n-\t} \n-\t\n+\t}\n+\n \tresult = lookup_loc_range(loc_range, hash_arr, boolCanonical TSRMLS_CC);\n \tif(result == NULL || result[0] == '\\0') {\n \t\tif( fallback_loc ) {\n@@ -1590,10 +1591,10 @@ PHP_FUNCTION(locale_accept_from_http)\n \t\t\"locale_accept_from_http: unable to parse input parameters\", 0 TSRMLS_CC );\n \t\tRETURN_FALSE;\n \t}\n-\t\n+\n \tavailable = ures_openAvailableLocales(NULL, &status);\n \tINTL_CHECK_STATUS(status, \"locale_accept_from_http: failed to retrieve locale list\");\n-\tlen = uloc_acceptLanguageFromHTTP(resultLocale, INTL_MAX_LOCALE_LEN, \n+\tlen = uloc_acceptLanguageFromHTTP(resultLocale, INTL_MAX_LOCALE_LEN,\n \t\t\t\t\t\t&outResult, http_accept, available, &status);\n \tuenum_close(available);\n \tINTL_CHECK_STATUS(status, \"locale_accept_from_http: failed to find acceptable locale\");", "file_path": "files/2016_8\\75", "file_language": "c", "file_name": "ext/intl/locale/locale_methods.c", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}, {"raw_url": "https://github.com/php/php-src/raw/97eff7eb57fc2320c267a949cffd622c38712484/ext/intl/tests/bug72241.phpt", "code": "--TEST--\nBug #72241: get_icu_value_internal out-of-bounds read\n--SKIPIF--\n<?php if( !extension_loaded( 'intl' ) ) print 'skip'; ?>\n--FILE--\n<?php\n$var1=str_repeat(\"A\", 1000);\n$out = locale_get_primary_language($var1);\necho strlen($out) . PHP_EOL;\necho unpack('H*', $out)[1] . PHP_EOL;\n--EXPECT--\n1000\n61616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161\n\n", "code_before": "--TEST--\nBug #72241: get_icu_value_internal out-of-bounds read\n--SKIPIF--\n<?php if( !extension_loaded( 'intl' ) ) print 'skip'; ?>\n--FILE--\n<?php\n$var1=str_repeat(\"A\", 1000);\n$out = locale_get_primary_language($var1);\nvar_dump($out);\n?>\n--EXPECT--\nNULL\n", "patch": "@@ -0,0 +1,14 @@\n+--TEST--\n+Bug #72241: get_icu_value_internal out-of-bounds read\n+--SKIPIF--\n+<?php if( !extension_loaded( 'intl' ) ) print 'skip'; ?>\n+--FILE--\n+<?php\n+$var1=str_repeat(\"A\", 1000);\n+$out = locale_get_primary_language($var1);\n+echo strlen($out) . PHP_EOL;\n+echo unpack('H*', $out)[1] . PHP_EOL;\n+--EXPECT--\n+1000\n+61616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161\n+", "file_path": "files/2016_8\\76", "file_language": "phpt", "file_name": "ext/intl/tests/bug72241.phpt", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}], "outdated": 0}
{"index": 30, "cve_id": "CVE-2016-5094", "cwe_id": ["CWE-190"], "cve_language": "C", "cve_description": "Integer overflow in the php_html_entities function in ext/standard/html.c in PHP before 5.5.36 and 5.6.x before 5.6.22 allows remote attackers to cause a denial of service or possibly have unspecified other impact by triggering a large output string from the htmlspecialchars function.", "cvss": "8.6", "publish_date": "August 7, 2016", "AV": "NETWORK", "AC": "LOW", "PR": "NONE", "UI": "NONE", "S": "UNCHANGED", "C": "LOW", "I": "LOW", "A": "HIGH", "commit_id": "0da8b8b801f9276359262f1ef8274c7812d3dfda", "commit_message": "Fix bug #72135 - don't create strings with lengths outside int range", "commit_date": "2016-05-16T06:26:51Z", "project": "php/php-src", "url": "https://api.github.com/repos/php/php-src/commits/0da8b8b801f9276359262f1ef8274c7812d3dfda", "html_url": "https://github.com/php/php-src/commit/0da8b8b801f9276359262f1ef8274c7812d3dfda", "windows_before": "", "windows_after": "", "parents": [{"commit_id_before": "41fc3c76e97a36ff3b505da7d704ca17bb171fdf", "url_before": "https://api.github.com/repos/php/php-src/commits/41fc3c76e97a36ff3b505da7d704ca17bb171fdf", "html_url_before": "https://github.com/php/php-src/commit/41fc3c76e97a36ff3b505da7d704ca17bb171fdf"}], "details": [{"raw_url": "https://github.com/php/php-src/raw/0da8b8b801f9276359262f1ef8274c7812d3dfda/ext/standard/html.c", "code": "/*\n   +----------------------------------------------------------------------+\n   | PHP Version 5                                                        |\n   +----------------------------------------------------------------------+\n   | Copyright (c) 1997-2015 The PHP Group                                |\n   +----------------------------------------------------------------------+\n   | This source file is subject to version 3.01 of the PHP license,      |\n   | that is bundled with this package in the file LICENSE, and is        |\n   | available through the world-wide-web at the following url:           |\n   | http://www.php.net/license/3_01.txt                                  |\n   | If you did not receive a copy of the PHP license and are unable to   |\n   | obtain it through the world-wide-web, please send a note to          |\n   | license@php.net so we can mail you a copy immediately.               |\n   +----------------------------------------------------------------------+\n   | Authors: Rasmus Lerdorf <rasmus@php.net>                             |\n   |          Jaakko Hyv\u00e4tti <jaakko.hyvatti@iki.fi>                      |\n   |          Wez Furlong    <wez@thebrainroom.com>                       |\n   |          Gustavo Lopes  <cataphract@php.net>                         |\n   +----------------------------------------------------------------------+\n*/\n\n/* $Id$ */\n\n/*\n * HTML entity resources:\n *\n * http://www.unicode.org/Public/MAPPINGS/OBSOLETE/UNI2SGML.TXT\n *\n * XHTML 1.0 DTD\n * http://www.w3.org/TR/2002/REC-xhtml1-20020801/dtds.html#h-A2\n *\n * From HTML 4.01 strict DTD:\n * http://www.w3.org/TR/html4/HTMLlat1.ent\n * http://www.w3.org/TR/html4/HTMLsymbol.ent\n * http://www.w3.org/TR/html4/HTMLspecial.ent\n *\n * HTML 5:\n * http://dev.w3.org/html5/spec/Overview.html#named-character-references\n */\n\n#include \"php.h\"\n#if PHP_WIN32\n#include \"config.w32.h\"\n#else\n#include <php_config.h>\n#endif\n#include \"php_standard.h\"\n#include \"php_string.h\"\n#include \"SAPI.h\"\n#if HAVE_LOCALE_H\n#include <locale.h>\n#endif\n#if HAVE_LANGINFO_H\n#include <langinfo.h>\n#endif\n\n#include <zend_hash.h>\n#include \"html_tables.h\"\n\n/* Macro for disabling flag of translation of non-basic entities where this isn't supported.\n * Not appropriate for html_entity_decode/htmlspecialchars_decode */\n#define LIMIT_ALL(all, doctype, charset) do { \\\n\t(all) = (all) && !CHARSET_PARTIAL_SUPPORT((charset)) && ((doctype) != ENT_HTML_DOC_XML1); \\\n} while (0)\n\n#define MB_FAILURE(pos, advance) do { \\\n\t*cursor = pos + (advance); \\\n\t*status = FAILURE; \\\n\treturn 0; \\\n} while (0)\n\n#define CHECK_LEN(pos, chars_need) ((str_len - (pos)) >= (chars_need))\n\n/* valid as single byte character or leading byte */\n#define utf8_lead(c)  ((c) < 0x80 || ((c) >= 0xC2 && (c) <= 0xF4))\n/* whether it's actually valid depends on other stuff;\n * this macro cannot check for non-shortest forms, surrogates or\n * code points above 0x10FFFF */\n#define utf8_trail(c) ((c) >= 0x80 && (c) <= 0xBF)\n\n#define gb2312_lead(c) ((c) != 0x8E && (c) != 0x8F && (c) != 0xA0 && (c) != 0xFF)\n#define gb2312_trail(c) ((c) >= 0xA1 && (c) <= 0xFE)\n\n#define sjis_lead(c) ((c) != 0x80 && (c) != 0xA0 && (c) < 0xFD)\n#define sjis_trail(c) ((c) >= 0x40  && (c) != 0x7F && (c) < 0xFD)\n\n/* {{{ get_next_char\n */\nstatic inline unsigned int get_next_char(\n\t\tenum entity_charset charset,\n\t\tconst unsigned char *str,\n\t\tsize_t str_len,\n\t\tsize_t *cursor,\n\t\tint *status)\n{\n\tsize_t pos = *cursor;\n\tunsigned int this_char = 0;\n\n\t*status = SUCCESS;\n\tassert(pos <= str_len);\n\n\tif (!CHECK_LEN(pos, 1))\n\t\tMB_FAILURE(pos, 1);\n\n\tswitch (charset) {\n\tcase cs_utf_8:\n\t\t{\n\t\t\t/* We'll follow strategy 2. from section 3.6.1 of UTR #36:\n\t\t\t * \"In a reported illegal byte sequence, do not include any\n\t\t\t *  non-initial byte that encodes a valid character or is a leading\n\t\t\t *  byte for a valid sequence.\" */\n\t\t\tunsigned char c;\n\t\t\tc = str[pos];\n\t\t\tif (c < 0x80) {\n\t\t\t\tthis_char = c;\n\t\t\t\tpos++;\n\t\t\t} else if (c < 0xc2) {\n\t\t\t\tMB_FAILURE(pos, 1);\n\t\t\t} else if (c < 0xe0) {\n\t\t\t\tif (!CHECK_LEN(pos, 2))\n\t\t\t\t\tMB_FAILURE(pos, 1);\n\n\t\t\t\tif (!utf8_trail(str[pos + 1])) {\n\t\t\t\t\tMB_FAILURE(pos, utf8_lead(str[pos + 1]) ? 1 : 2);\n\t\t\t\t}\n\t\t\t\tthis_char = ((c & 0x1f) << 6) | (str[pos + 1] & 0x3f);\n\t\t\t\tif (this_char < 0x80) { /* non-shortest form */\n\t\t\t\t\tMB_FAILURE(pos, 2);\n\t\t\t\t}\n\t\t\t\tpos += 2;\n\t\t\t} else if (c < 0xf0) {\n\t\t\t\tsize_t avail = str_len - pos;\n\n\t\t\t\tif (avail < 3 ||\n\t\t\t\t\t\t!utf8_trail(str[pos + 1]) || !utf8_trail(str[pos + 2])) {\n\t\t\t\t\tif (avail < 2 || utf8_lead(str[pos + 1]))\n\t\t\t\t\t\tMB_FAILURE(pos, 1);\n\t\t\t\t\telse if (avail < 3 || utf8_lead(str[pos + 2]))\n\t\t\t\t\t\tMB_FAILURE(pos, 2);\n\t\t\t\t\telse\n\t\t\t\t\t\tMB_FAILURE(pos, 3);\n\t\t\t\t}\n\n\t\t\t\tthis_char = ((c & 0x0f) << 12) | ((str[pos + 1] & 0x3f) << 6) | (str[pos + 2] & 0x3f);\n\t\t\t\tif (this_char < 0x800) { /* non-shortest form */\n\t\t\t\t\tMB_FAILURE(pos, 3);\n\t\t\t\t} else if (this_char >= 0xd800 && this_char <= 0xdfff) { /* surrogate */\n\t\t\t\t\tMB_FAILURE(pos, 3);\n\t\t\t\t}\n\t\t\t\tpos += 3;\n\t\t\t} else if (c < 0xf5) {\n\t\t\t\tsize_t avail = str_len - pos;\n\n\t\t\t\tif (avail < 4 ||\n\t\t\t\t\t\t!utf8_trail(str[pos + 1]) || !utf8_trail(str[pos + 2]) ||\n\t\t\t\t\t\t!utf8_trail(str[pos + 3])) {\n\t\t\t\t\tif (avail < 2 || utf8_lead(str[pos + 1]))\n\t\t\t\t\t\tMB_FAILURE(pos, 1);\n\t\t\t\t\telse if (avail < 3 || utf8_lead(str[pos + 2]))\n\t\t\t\t\t\tMB_FAILURE(pos, 2);\n\t\t\t\t\telse if (avail < 4 || utf8_lead(str[pos + 3]))\n\t\t\t\t\t\tMB_FAILURE(pos, 3);\n\t\t\t\t\telse\n\t\t\t\t\t\tMB_FAILURE(pos, 4);\n\t\t\t\t}\n\n\t\t\t\tthis_char = ((c & 0x07) << 18) | ((str[pos + 1] & 0x3f) << 12) | ((str[pos + 2] & 0x3f) << 6) | (str[pos + 3] & 0x3f);\n\t\t\t\tif (this_char < 0x10000 || this_char > 0x10FFFF) { /* non-shortest form or outside range */\n\t\t\t\t\tMB_FAILURE(pos, 4);\n\t\t\t\t}\n\t\t\t\tpos += 4;\n\t\t\t} else {\n\t\t\t\tMB_FAILURE(pos, 1);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase cs_big5:\n\t\t/* reference http://demo.icu-project.org/icu-bin/convexp?conv=big5 */\n\t\t{\n\t\t\tunsigned char c = str[pos];\n\t\t\tif (c >= 0x81 && c <= 0xFE) {\n\t\t\t\tunsigned char next;\n\t\t\t\tif (!CHECK_LEN(pos, 2))\n\t\t\t\t\tMB_FAILURE(pos, 1);\n\n\t\t\t\tnext = str[pos + 1];\n\n\t\t\t\tif ((next >= 0x40 && next <= 0x7E) ||\n\t\t\t\t\t\t(next >= 0xA1 && next <= 0xFE)) {\n\t\t\t\t\tthis_char = (c << 8) | next;\n\t\t\t\t} else {\n\t\t\t\t\tMB_FAILURE(pos, 1);\n\t\t\t\t}\n\t\t\t\tpos += 2;\n\t\t\t} else {\n\t\t\t\tthis_char = c;\n\t\t\t\tpos += 1;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase cs_big5hkscs:\n\t\t{\n\t\t\tunsigned char c = str[pos];\n\t\t\tif (c >= 0x81 && c <= 0xFE) {\n\t\t\t\tunsigned char next;\n\t\t\t\tif (!CHECK_LEN(pos, 2))\n\t\t\t\t\tMB_FAILURE(pos, 1);\n\n\t\t\t\tnext = str[pos + 1];\n\n\t\t\t\tif ((next >= 0x40 && next <= 0x7E) ||\n\t\t\t\t\t\t(next >= 0xA1 && next <= 0xFE)) {\n\t\t\t\t\tthis_char = (c << 8) | next;\n\t\t\t\t} else if (next != 0x80 && next != 0xFF) {\n\t\t\t\t\tMB_FAILURE(pos, 1);\n\t\t\t\t} else {\n\t\t\t\t\tMB_FAILURE(pos, 2);\n\t\t\t\t}\n\t\t\t\tpos += 2;\n\t\t\t} else {\n\t\t\t\tthis_char = c;\n\t\t\t\tpos += 1;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase cs_gb2312: /* EUC-CN */\n\t\t{\n\t\t\tunsigned char c = str[pos];\n\t\t\tif (c >= 0xA1 && c <= 0xFE) {\n\t\t\t\tunsigned char next;\n\t\t\t\tif (!CHECK_LEN(pos, 2))\n\t\t\t\t\tMB_FAILURE(pos, 1);\n\n\t\t\t\tnext = str[pos + 1];\n\n\t\t\t\tif (gb2312_trail(next)) {\n\t\t\t\t\tthis_char = (c << 8) | next;\n\t\t\t\t} else if (gb2312_lead(next)) {\n\t\t\t\t\tMB_FAILURE(pos, 1);\n\t\t\t\t} else {\n\t\t\t\t\tMB_FAILURE(pos, 2);\n\t\t\t\t}\n\t\t\t\tpos += 2;\n\t\t\t} else if (gb2312_lead(c)) {\n\t\t\t\tthis_char = c;\n\t\t\t\tpos += 1;\n\t\t\t} else {\n\t\t\t\tMB_FAILURE(pos, 1);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase cs_sjis:\n\t\t{\n\t\t\tunsigned char c = str[pos];\n\t\t\tif ((c >= 0x81 && c <= 0x9F) || (c >= 0xE0 && c <= 0xFC)) {\n\t\t\t\tunsigned char next;\n\t\t\t\tif (!CHECK_LEN(pos, 2))\n\t\t\t\t\tMB_FAILURE(pos, 1);\n\n\t\t\t\tnext = str[pos + 1];\n\n\t\t\t\tif (sjis_trail(next)) {\n\t\t\t\t\tthis_char = (c << 8) | next;\n\t\t\t\t} else if (sjis_lead(next)) {\n\t\t\t\t\tMB_FAILURE(pos, 1);\n\t\t\t\t} else {\n\t\t\t\t\tMB_FAILURE(pos, 2);\n\t\t\t\t}\n\t\t\t\tpos += 2;\n\t\t\t} else if (c < 0x80 || (c >= 0xA1 && c <= 0xDF)) {\n\t\t\t\tthis_char = c;\n\t\t\t\tpos += 1;\n\t\t\t} else {\n\t\t\t\tMB_FAILURE(pos, 1);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase cs_eucjp:\n\t\t{\n\t\t\tunsigned char c = str[pos];\n\n\t\t\tif (c >= 0xA1 && c <= 0xFE) {\n\t\t\t\tunsigned next;\n\t\t\t\tif (!CHECK_LEN(pos, 2))\n\t\t\t\t\tMB_FAILURE(pos, 1);\n\t\t\t\tnext = str[pos + 1];\n\n\t\t\t\tif (next >= 0xA1 && next <= 0xFE) {\n\t\t\t\t\t/* this a jis kanji char */\n\t\t\t\t\tthis_char = (c << 8) | next;\n\t\t\t\t} else {\n\t\t\t\t\tMB_FAILURE(pos, (next != 0xA0 && next != 0xFF) ? 1 : 2);\n\t\t\t\t}\n\t\t\t\tpos += 2;\n\t\t\t} else if (c == 0x8E) {\n\t\t\t\tunsigned next;\n\t\t\t\tif (!CHECK_LEN(pos, 2))\n\t\t\t\t\tMB_FAILURE(pos, 1);\n\n\t\t\t\tnext = str[pos + 1];\n\t\t\t\tif (next >= 0xA1 && next <= 0xDF) {\n\t\t\t\t\t/* JIS X 0201 kana */\n\t\t\t\t\tthis_char = (c << 8) | next;\n\t\t\t\t} else {\n\t\t\t\t\tMB_FAILURE(pos, (next != 0xA0 && next != 0xFF) ? 1 : 2);\n\t\t\t\t}\n\t\t\t\tpos += 2;\n\t\t\t} else if (c == 0x8F) {\n\t\t\t\tsize_t avail = str_len - pos;\n\n\t\t\t\tif (avail < 3 || !(str[pos + 1] >= 0xA1 && str[pos + 1] <= 0xFE) ||\n\t\t\t\t\t\t!(str[pos + 2] >= 0xA1 && str[pos + 2] <= 0xFE)) {\n\t\t\t\t\tif (avail < 2 || (str[pos + 1] != 0xA0 && str[pos + 1] != 0xFF))\n\t\t\t\t\t\tMB_FAILURE(pos, 1);\n\t\t\t\t\telse if (avail < 3 || (str[pos + 2] != 0xA0 && str[pos + 2] != 0xFF))\n\t\t\t\t\t\tMB_FAILURE(pos, 2);\n\t\t\t\t\telse\n\t\t\t\t\t\tMB_FAILURE(pos, 3);\n\t\t\t\t} else {\n\t\t\t\t\t/* JIS X 0212 hojo-kanji */\n\t\t\t\t\tthis_char = (c << 16) | (str[pos + 1] << 8) | str[pos + 2];\n\t\t\t\t}\n\t\t\t\tpos += 3;\n\t\t\t} else if (c != 0xA0 && c != 0xFF) {\n\t\t\t\t/* character encoded in 1 code unit */\n\t\t\t\tthis_char = c;\n\t\t\t\tpos += 1;\n\t\t\t} else {\n\t\t\t\tMB_FAILURE(pos, 1);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\t/* single-byte charsets */\n\t\tthis_char = str[pos++];\n\t\tbreak;\n\t}\n\n\t*cursor = pos;\n  \treturn this_char;\n}\n/* }}} */\n\n/* {{{ php_next_utf8_char\n * Public interface for get_next_char used with UTF-8 */\n PHPAPI unsigned int php_next_utf8_char(\n\t\tconst unsigned char *str,\n\t\tsize_t str_len,\n\t\tsize_t *cursor,\n\t\tint *status)\n{\n\treturn get_next_char(cs_utf_8, str, str_len, cursor, status);\n}\n/* }}} */\n\n/* {{{ entity_charset determine_charset\n * returns the charset identifier based on current locale or a hint.\n * defaults to UTF-8 */\nstatic enum entity_charset determine_charset(char *charset_hint TSRMLS_DC)\n{\n\tint i;\n\tenum entity_charset charset = cs_utf_8;\n\tint len = 0;\n\tconst zend_encoding *zenc;\n\n\t/* Default is now UTF-8 */\n\tif (charset_hint == NULL)\n\t\treturn cs_utf_8;\n\n\tif ((len = strlen(charset_hint)) != 0) {\n\t\tgoto det_charset;\n\t}\n\n\tzenc = zend_multibyte_get_internal_encoding(TSRMLS_C);\n\tif (zenc != NULL) {\n\t\tcharset_hint = (char *)zend_multibyte_get_encoding_name(zenc);\n\t\tif (charset_hint != NULL && (len=strlen(charset_hint)) != 0) {\n\t\t\tif ((len == 4) /* sizeof (none|auto|pass) */ &&\n\t\t\t\t\t(!memcmp(\"pass\", charset_hint, 4) ||\n\t\t\t\t\t !memcmp(\"auto\", charset_hint, 4) ||\n\t\t\t\t\t !memcmp(\"auto\", charset_hint, 4))) {\n\t\t\t\tcharset_hint = NULL;\n\t\t\t\tlen = 0;\n\t\t\t} else {\n\t\t\t\tgoto det_charset;\n\t\t\t}\n\t\t}\n\t}\n\n\tcharset_hint = SG(default_charset);\n\tif (charset_hint != NULL && (len=strlen(charset_hint)) != 0) {\n\t\tgoto det_charset;\n\t}\n\n\t/* try to detect the charset for the locale */\n#if HAVE_NL_LANGINFO && HAVE_LOCALE_H && defined(CODESET)\n\tcharset_hint = nl_langinfo(CODESET);\n\tif (charset_hint != NULL && (len=strlen(charset_hint)) != 0) {\n\t\tgoto det_charset;\n\t}\n#endif\n\n#if HAVE_LOCALE_H\n\t/* try to figure out the charset from the locale */\n\t{\n\t\tchar *localename;\n\t\tchar *dot, *at;\n\n\t\t/* lang[_territory][.codeset][@modifier] */\n\t\tlocalename = setlocale(LC_CTYPE, NULL);\n\n\t\tdot = strchr(localename, '.');\n\t\tif (dot) {\n\t\t\tdot++;\n\t\t\t/* locale specifies a codeset */\n\t\t\tat = strchr(dot, '@');\n\t\t\tif (at)\n\t\t\t\tlen = at - dot;\n\t\t\telse\n\t\t\t\tlen = strlen(dot);\n\t\t\tcharset_hint = dot;\n\t\t} else {\n\t\t\t/* no explicit name; see if the name itself\n\t\t\t * is the charset */\n\t\t\tcharset_hint = localename;\n\t\t\tlen = strlen(charset_hint);\n\t\t}\n\t}\n#endif\n\ndet_charset:\n\n\tif (charset_hint) {\n\t\tint found = 0;\n\n\t\t/* now walk the charset map and look for the codeset */\n\t\tfor (i = 0; charset_map[i].codeset; i++) {\n\t\t\tif (len == strlen(charset_map[i].codeset) && strncasecmp(charset_hint, charset_map[i].codeset, len) == 0) {\n\t\t\t\tcharset = charset_map[i].charset;\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!found) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"charset `%s' not supported, assuming utf-8\",\n\t\t\t\t\tcharset_hint);\n\t\t}\n\t}\n\treturn charset;\n}\n/* }}} */\n\n/* {{{ php_utf32_utf8 */\nstatic inline size_t php_utf32_utf8(unsigned char *buf, unsigned k)\n{\n\tsize_t retval = 0;\n\n\t/* assert(0x0 <= k <= 0x10FFFF); */\n\n\tif (k < 0x80) {\n\t\tbuf[0] = k;\n\t\tretval = 1;\n\t} else if (k < 0x800) {\n\t\tbuf[0] = 0xc0 | (k >> 6);\n\t\tbuf[1] = 0x80 | (k & 0x3f);\n\t\tretval = 2;\n\t} else if (k < 0x10000) {\n\t\tbuf[0] = 0xe0 | (k >> 12);\n\t\tbuf[1] = 0x80 | ((k >> 6) & 0x3f);\n\t\tbuf[2] = 0x80 | (k & 0x3f);\n\t\tretval = 3;\n\t} else {\n\t\tbuf[0] = 0xf0 | (k >> 18);\n\t\tbuf[1] = 0x80 | ((k >> 12) & 0x3f);\n\t\tbuf[2] = 0x80 | ((k >> 6) & 0x3f);\n\t\tbuf[3] = 0x80 | (k & 0x3f);\n\t\tretval = 4;\n\t}\n\t/* UTF-8 has been restricted to max 4 bytes since RFC 3629 */\n\n\treturn retval;\n}\n/* }}} */\n\n/* {{{ php_mb2_int_to_char\n * Convert back big endian int representation of sequence of one or two 8-bit code units. */\nstatic inline size_t php_mb2_int_to_char(unsigned char *buf, unsigned k)\n{\n\tassert(k <= 0xFFFFU);\n\t/* one or two bytes */\n\tif (k <= 0xFFU) { /* 1 */\n\t\tbuf[0] = k;\n\t\treturn 1U;\n\t} else { /* 2 */\n\t\tbuf[0] = k >> 8;\n\t\tbuf[1] = k & 0xFFU;\n\t\treturn 2U;\n\t}\n}\n/* }}} */\n\n/* {{{ php_mb3_int_to_char\n * Convert back big endian int representation of sequence of one to three 8-bit code units.\n * For EUC-JP. */\nstatic inline size_t php_mb3_int_to_char(unsigned char *buf, unsigned k)\n{\n\tassert(k <= 0xFFFFFFU);\n\t/* one to three bytes */\n\tif (k <= 0xFFU) { /* 1 */\n\t\tbuf[0] = k;\n\t\treturn 1U;\n\t} else if (k <= 0xFFFFU) { /* 2 */\n\t\tbuf[0] = k >> 8;\n\t\tbuf[1] = k & 0xFFU;\n\t\treturn 2U;\n\t} else {\n\t\tbuf[0] = k >> 16;\n\t\tbuf[1] = (k >> 8) & 0xFFU;\n\t\tbuf[2] = k & 0xFFU;\n\t\treturn 3U;\n\t}\n}\n/* }}} */\n\n\n/* {{{ unimap_bsearc_cmp\n * Binary search of unicode code points in unicode <--> charset mapping.\n * Returns the code point in the target charset (whose mapping table was given) or 0 if\n * the unicode code point is not in the table.\n */\nstatic inline unsigned char unimap_bsearch(const uni_to_enc *table, unsigned code_key_a, size_t num)\n{\n\tconst uni_to_enc *l = table,\n\t\t\t\t\t *h = &table[num-1],\n\t\t\t\t\t *m;\n\tunsigned short code_key;\n\n\t/* we have no mappings outside the BMP */\n\tif (code_key_a > 0xFFFFU)\n\t\treturn 0;\n\n\tcode_key = (unsigned short) code_key_a;\n\n\twhile (l <= h) {\n\t\tm = l + (h - l) / 2;\n\t\tif (code_key < m->un_code_point)\n\t\t\th = m - 1;\n\t\telse if (code_key > m->un_code_point)\n\t\t\tl = m + 1;\n\t\telse\n\t\t\treturn m->cs_code;\n\t}\n\treturn 0;\n}\n/* }}} */\n\n/* {{{ map_from_unicode */\nstatic inline int map_from_unicode(unsigned code, enum entity_charset charset, unsigned *res)\n{\n\tunsigned char found;\n\tconst uni_to_enc *table;\n\tsize_t table_size;\n\n\tswitch (charset) {\n\tcase cs_8859_1:\n\t\t/* identity mapping of code points to unicode */\n\t\tif (code > 0xFF) {\n\t\t\treturn FAILURE;\n\t\t}\n\t\t*res = code;\n\t\tbreak;\n\n\tcase cs_8859_5:\n\t\tif (code <= 0xA0 || code == 0xAD /* soft hyphen */) {\n\t\t\t*res = code;\n\t\t} else if (code == 0x2116) {\n\t\t\t*res = 0xF0; /* numero sign */\n\t\t} else if (code == 0xA7) {\n\t\t\t*res = 0xFD; /* section sign */\n\t\t} else if (code >= 0x0401 && code <= 0x044F) {\n\t\t\tif (code == 0x040D || code == 0x0450 || code == 0x045D)\n\t\t\t\treturn FAILURE;\n\t\t\t*res = code - 0x360;\n\t\t} else {\n\t\t\treturn FAILURE;\n\t\t}\n\t\tbreak;\n\n\tcase cs_8859_15:\n\t\tif (code < 0xA4 || (code > 0xBE && code <= 0xFF)) {\n\t\t\t*res = code;\n\t\t} else { /* between A4 and 0xBE */\n\t\t\tfound = unimap_bsearch(unimap_iso885915,\n\t\t\t\tcode, sizeof(unimap_iso885915) / sizeof(*unimap_iso885915));\n\t\t\tif (found)\n\t\t\t\t*res = found;\n\t\t\telse\n\t\t\t\treturn FAILURE;\n\t\t}\n\t\tbreak;\n\n\tcase cs_cp1252:\n\t\tif (code <= 0x7F || (code >= 0xA0 && code <= 0xFF)) {\n\t\t\t*res = code;\n\t\t} else {\n\t\t\tfound = unimap_bsearch(unimap_win1252,\n\t\t\t\tcode, sizeof(unimap_win1252) / sizeof(*unimap_win1252));\n\t\t\tif (found)\n\t\t\t\t*res = found;\n\t\t\telse\n\t\t\t\treturn FAILURE;\n\t\t}\n\t\tbreak;\n\n\tcase cs_macroman:\n\t\tif (code == 0x7F)\n\t\t\treturn FAILURE;\n\t\ttable = unimap_macroman;\n\t\ttable_size = sizeof(unimap_macroman) / sizeof(*unimap_macroman);\n\t\tgoto table_over_7F;\n\tcase cs_cp1251:\n\t\ttable = unimap_win1251;\n\t\ttable_size = sizeof(unimap_win1251) / sizeof(*unimap_win1251);\n\t\tgoto table_over_7F;\n\tcase cs_koi8r:\n\t\ttable = unimap_koi8r;\n\t\ttable_size = sizeof(unimap_koi8r) / sizeof(*unimap_koi8r);\n\t\tgoto table_over_7F;\n\tcase cs_cp866:\n\t\ttable = unimap_cp866;\n\t\ttable_size = sizeof(unimap_cp866) / sizeof(*unimap_cp866);\n\ntable_over_7F:\n\t\tif (code <= 0x7F) {\n\t\t\t*res = code;\n\t\t} else {\n\t\t\tfound = unimap_bsearch(table, code, table_size);\n\t\t\tif (found)\n\t\t\t\t*res = found;\n\t\t\telse\n\t\t\t\treturn FAILURE;\n\t\t}\n\t\tbreak;\n\n\t/* from here on, only map the possible characters in the ASCII range.\n\t * to improve support here, it's a matter of building the unicode mappings.\n\t * See <http://www.unicode.org/Public/6.0.0/ucd/Unihan.zip> */\n\tcase cs_sjis:\n\tcase cs_eucjp:\n\t\t/* we interpret 0x5C as the Yen symbol. This is not universal.\n\t\t * See <http://www.w3.org/Submission/japanese-xml/#ambiguity_of_yen> */\n\t\tif (code >= 0x20 && code <= 0x7D) {\n\t\t\tif (code == 0x5C)\n\t\t\t\treturn FAILURE;\n\t\t\t*res = code;\n\t\t} else {\n\t\t\treturn FAILURE;\n\t\t}\n\t\tbreak;\n\n\tcase cs_big5:\n\tcase cs_big5hkscs:\n\tcase cs_gb2312:\n\t\tif (code >= 0x20 && code <= 0x7D) {\n\t\t\t*res = code;\n\t\t} else {\n\t\t\treturn FAILURE;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\treturn FAILURE;\n\t}\n\n\treturn SUCCESS;\n}\n/* }}} */\n\n/* {{{ */\nstatic inline void map_to_unicode(unsigned code, const enc_to_uni *table, unsigned *res)\n{\n\t/* only single byte encodings are currently supported; assumed code <= 0xFF */\n\t*res = table->inner[ENT_ENC_TO_UNI_STAGE1(code)]->uni_cp[ENT_ENC_TO_UNI_STAGE2(code)];\n}\n/* }}} */\n\n/* {{{ unicode_cp_is_allowed */\nstatic inline int unicode_cp_is_allowed(unsigned uni_cp, int document_type)\n{\n\t/* XML 1.0\t\t\t\tHTML 4.01\t\t\tHTML 5\n\t * 0x09..0x0A\t\t\t0x09..0x0A\t\t\t0x09..0x0A\n\t * 0x0D\t\t\t\t\t0x0D\t\t\t\t0x0C..0x0D\n\t * 0x0020..0xD7FF\t\t0x20..0x7E\t\t\t0x20..0x7E\n\t *\t\t\t\t\t\t0x00A0..0xD7FF\t\t0x00A0..0xD7FF\n\t * 0xE000..0xFFFD\t\t0xE000..0x10FFFF\t0xE000..0xFDCF\n\t * 0x010000..0x10FFFF\t\t\t\t\t\t0xFDF0..0x10FFFF (*)\n\t *\n\t * (*) exclude code points where ((code & 0xFFFF) >= 0xFFFE)\n\t *\n\t * References:\n\t * XML 1.0:   <http://www.w3.org/TR/REC-xml/#charsets>\n\t * HTML 4.01: <http://www.w3.org/TR/1999/PR-html40-19990824/sgml/sgmldecl.html>\n\t * HTML 5:    <http://dev.w3.org/html5/spec/Overview.html#preprocessing-the-input-stream>\n\t *\n\t * Not sure this is the relevant part for HTML 5, though. I opted to\n\t * disallow the characters that would result in a parse error when\n\t * preprocessing of the input stream. See also section 8.1.3.\n\t *\n\t * It's unclear if XHTML 1.0 allows C1 characters. I'll opt to apply to\n\t * XHTML 1.0 the same rules as for XML 1.0.\n\t * See <http://cmsmcq.com/2007/C1.xml>.\n\t */\n\n\tswitch (document_type) {\n\tcase ENT_HTML_DOC_HTML401:\n\t\treturn (uni_cp >= 0x20 && uni_cp <= 0x7E) ||\n\t\t\t(uni_cp == 0x0A || uni_cp == 0x09 || uni_cp == 0x0D) ||\n\t\t\t(uni_cp >= 0xA0 && uni_cp <= 0xD7FF) ||\n\t\t\t(uni_cp >= 0xE000 && uni_cp <= 0x10FFFF);\n\tcase ENT_HTML_DOC_HTML5:\n\t\treturn (uni_cp >= 0x20 && uni_cp <= 0x7E) ||\n\t\t\t(uni_cp >= 0x09 && uni_cp <= 0x0D && uni_cp != 0x0B) || /* form feed U+0C allowed */\n\t\t\t(uni_cp >= 0xA0 && uni_cp <= 0xD7FF) ||\n\t\t\t(uni_cp >= 0xE000 && uni_cp <= 0x10FFFF &&\n\t\t\t\t((uni_cp & 0xFFFF) < 0xFFFE) && /* last two of each plane (nonchars) disallowed */\n\t\t\t\t(uni_cp < 0xFDD0 || uni_cp > 0xFDEF)); /* U+FDD0-U+FDEF (nonchars) disallowed */\n\tcase ENT_HTML_DOC_XHTML:\n\tcase ENT_HTML_DOC_XML1:\n\t\treturn (uni_cp >= 0x20 && uni_cp <= 0xD7FF) ||\n\t\t\t(uni_cp == 0x0A || uni_cp == 0x09 || uni_cp == 0x0D) ||\n\t\t\t(uni_cp >= 0xE000 && uni_cp <= 0x10FFFF && uni_cp != 0xFFFE && uni_cp != 0xFFFF);\n\tdefault:\n\t\treturn 1;\n\t}\n}\n/* }}} */\n\n/* {{{ unicode_cp_is_allowed */\nstatic inline int numeric_entity_is_allowed(unsigned uni_cp, int document_type)\n{\n\t/* less restrictive than unicode_cp_is_allowed */\n\tswitch (document_type) {\n\tcase ENT_HTML_DOC_HTML401:\n\t\t/* all non-SGML characters (those marked with UNUSED in DESCSET) should be\n\t\t * representable with numeric entities */\n\t\treturn uni_cp <= 0x10FFFF;\n\tcase ENT_HTML_DOC_HTML5:\n\t\t/* 8.1.4. The numeric character reference forms described above are allowed to\n\t\t * reference any Unicode code point other than U+0000, U+000D, permanently\n\t\t * undefined Unicode characters (noncharacters), and control characters other\n\t\t * than space characters (U+0009, U+000A, U+000C and U+000D) */\n\t\t/* seems to allow surrogate characters, then */\n\t\treturn (uni_cp >= 0x20 && uni_cp <= 0x7E) ||\n\t\t\t(uni_cp >= 0x09 && uni_cp <= 0x0C && uni_cp != 0x0B) || /* form feed U+0C allowed, but not U+0D */\n\t\t\t(uni_cp >= 0xA0 && uni_cp <= 0x10FFFF &&\n\t\t\t\t((uni_cp & 0xFFFF) < 0xFFFE) && /* last two of each plane (nonchars) disallowed */\n\t\t\t\t(uni_cp < 0xFDD0 || uni_cp > 0xFDEF)); /* U+FDD0-U+FDEF (nonchars) disallowed */\n\tcase ENT_HTML_DOC_XHTML:\n\tcase ENT_HTML_DOC_XML1:\n\t\t/* OTOH, XML 1.0 requires \"character references to match the production for Char\n\t\t * See <http://www.w3.org/TR/REC-xml/#NT-CharRef> */\n\t\treturn unicode_cp_is_allowed(uni_cp, document_type);\n\tdefault:\n\t\treturn 1;\n\t}\n}\n/* }}} */\n\n/* {{{ process_numeric_entity\n * Auxiliary function to traverse_for_entities.\n * On input, *buf should point to the first character after # and on output, it's the last\n * byte read, no matter if there was success or insuccess.\n */\nstatic inline int process_numeric_entity(const char **buf, unsigned *code_point)\n{\n\tlong code_l;\n\tint hexadecimal = (**buf == 'x' || **buf == 'X'); /* TODO: XML apparently disallows \"X\" */\n\tchar *endptr;\n\n\tif (hexadecimal && (**buf != '\\0'))\n\t\t(*buf)++;\n\n\t/* strtol allows whitespace and other stuff in the beginning\n\t\t* we're not interested */\n\tif ((hexadecimal && !isxdigit(**buf)) ||\n\t\t\t(!hexadecimal && !isdigit(**buf))) {\n\t\treturn FAILURE;\n\t}\n\n\tcode_l = strtol(*buf, &endptr, hexadecimal ? 16 : 10);\n\t/* we're guaranteed there were valid digits, so *endptr > buf */\n\t*buf = endptr;\n\n\tif (**buf != ';')\n\t\treturn FAILURE;\n\n\t/* many more are invalid, but that depends on whether it's HTML\n\t * (and which version) or XML. */\n\tif (code_l > 0x10FFFFL)\n\t\treturn FAILURE;\n\n\tif (code_point != NULL)\n\t\t*code_point = (unsigned)code_l;\n\n\treturn SUCCESS;\n}\n/* }}} */\n\n/* {{{ process_named_entity */\nstatic inline int process_named_entity_html(const char **buf, const char **start, size_t *length)\n{\n\t*start = *buf;\n\n\t/* \"&\" is represented by a 0x26 in all supported encodings. That means\n\t * the byte after represents a character or is the leading byte of an\n\t * sequence of 8-bit code units. If in the ranges below, it represents\n\t * necessarily a alpha character because none of the supported encodings\n\t * has an overlap with ASCII in the leading byte (only on the second one) */\n\twhile ((**buf >= 'a' && **buf <= 'z') ||\n\t\t\t(**buf >= 'A' && **buf <= 'Z') ||\n\t\t\t(**buf >= '0' && **buf <= '9')) {\n\t\t(*buf)++;\n\t}\n\n\tif (**buf != ';')\n\t\treturn FAILURE;\n\n\t/* cast to size_t OK as the quantity is always non-negative */\n\t*length = *buf - *start;\n\n\tif (*length == 0)\n\t\treturn FAILURE;\n\n\treturn SUCCESS;\n}\n/* }}} */\n\n/* {{{ resolve_named_entity_html */\nstatic inline int resolve_named_entity_html(const char *start, size_t length, const entity_ht *ht, unsigned *uni_cp1, unsigned *uni_cp2)\n{\n\tconst entity_cp_map *s;\n\tulong hash = zend_inline_hash_func(start, length);\n\n\ts = ht->buckets[hash % ht->num_elems];\n\twhile (s->entity) {\n\t\tif (s->entity_len == length) {\n\t\t\tif (memcmp(start, s->entity, length) == 0) {\n\t\t\t\t*uni_cp1 = s->codepoint1;\n\t\t\t\t*uni_cp2 = s->codepoint2;\n\t\t\t\treturn SUCCESS;\n\t\t\t}\n\t\t}\n\t\ts++;\n\t}\n\treturn FAILURE;\n}\n/* }}} */\n\nstatic inline size_t write_octet_sequence(unsigned char *buf, enum entity_charset charset, unsigned code) {\n\t/* code is not necessarily a unicode code point */\n\tswitch (charset) {\n\tcase cs_utf_8:\n\t\treturn php_utf32_utf8(buf, code);\n\n\tcase cs_8859_1:\n\tcase cs_cp1252:\n\tcase cs_8859_15:\n\tcase cs_koi8r:\n\tcase cs_cp1251:\n\tcase cs_8859_5:\n\tcase cs_cp866:\n\tcase cs_macroman:\n\t\t/* single byte stuff */\n\t\t*buf = code;\n\t\treturn 1;\n\n\tcase cs_big5:\n\tcase cs_big5hkscs:\n\tcase cs_sjis:\n\tcase cs_gb2312:\n\t\t/* we don't have complete unicode mappings for these yet in entity_decode,\n\t\t * and we opt to pass through the octet sequences for these in htmlentities\n\t\t * instead of converting to an int and then converting back. */\n#if 0\n\t\treturn php_mb2_int_to_char(buf, code);\n#else\n#ifdef ZEND_DEBUG\n\t\tassert(code <= 0xFFU);\n#endif\n\t\t*buf = code;\n\t\treturn 1;\n#endif\n\n\tcase cs_eucjp:\n#if 0 /* idem */\n\t\treturn php_mb2_int_to_char(buf, code);\n#else\n#ifdef ZEND_DEBUG\n\t\tassert(code <= 0xFFU);\n#endif\n\t\t*buf = code;\n\t\treturn 1;\n#endif\n\n\tdefault:\n\t\tassert(0);\n\t\treturn 0;\n\t}\n}\n\n/* {{{ traverse_for_entities\n * Auxiliary function to php_unescape_html_entities().\n * - The argument \"all\" determines if all numeric entities are decode or only those\n *   that correspond to quotes (depending on quote_style).\n */\n/* maximum expansion (factor 1.2) for HTML 5 with &nGt; and &nLt; */\n/* +2 is 1 because of rest (probably unnecessary), 1 because of terminating 0 */\n#define TRAVERSE_FOR_ENTITIES_EXPAND_SIZE(oldlen) ((oldlen) + (oldlen) / 5 + 2)\nstatic void traverse_for_entities(\n\tconst char *old,\n\tsize_t oldlen,\n\tchar *ret, /* should have allocated TRAVERSE_FOR_ENTITIES_EXPAND_SIZE(olden) */\n\tsize_t *retlen,\n\tint all,\n\tint flags,\n\tconst entity_ht *inv_map,\n\tenum entity_charset charset)\n{\n\tconst char *p,\n\t\t\t   *lim;\n\tchar\t   *q;\n\tint doctype = flags & ENT_HTML_DOC_TYPE_MASK;\n\n\tlim = old + oldlen; /* terminator address */\n\tassert(*lim == '\\0');\n\n\tfor (p = old, q = ret; p < lim;) {\n\t\tunsigned code, code2 = 0;\n\t\tconst char *next = NULL; /* when set, next > p, otherwise possible inf loop */\n\n\t\t/* Shift JIS, Big5 and HKSCS use multi-byte encodings where an\n\t\t * ASCII range byte can be part of a multi-byte sequence.\n\t\t * However, they start at 0x40, therefore if we find a 0x26 byte,\n\t\t * we're sure it represents the '&' character. */\n\n\t\t/* assumes there are no single-char entities */\n\t\tif (p[0] != '&' || (p + 3 >= lim)) {\n\t\t\t*(q++) = *(p++);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* now p[3] is surely valid and is no terminator */\n\n\t\t/* numerical entity */\n\t\tif (p[1] == '#') {\n\t\t\tnext = &p[2];\n\t\t\tif (process_numeric_entity(&next, &code) == FAILURE)\n\t\t\t\tgoto invalid_code;\n\n\t\t\t/* If we're in htmlspecialchars_decode, we're only decoding entities\n\t\t\t * that represent &, <, >, \" and '. Is this one of them? */\n\t\t\tif (!all && (code > 63U ||\n\t\t\t\t\tstage3_table_be_apos_00000[code].data.ent.entity == NULL))\n\t\t\t\tgoto invalid_code;\n\n\t\t\t/* are we allowed to decode this entity in this document type?\n\t\t\t * HTML 5 is the only that has a character that cannot be used in\n\t\t\t * a numeric entity but is allowed literally (U+000D). The\n\t\t\t * unoptimized version would be ... || !numeric_entity_is_allowed(code) */\n\t\t\tif (!unicode_cp_is_allowed(code, doctype) ||\n\t\t\t\t\t(doctype == ENT_HTML_DOC_HTML5 && code == 0x0D))\n\t\t\t\tgoto invalid_code;\n\t\t} else {\n\t\t\tconst char *start;\n\t\t\tsize_t ent_len;\n\n\t\t\tnext = &p[1];\n\t\t\tstart = next;\n\n\t\t\tif (process_named_entity_html(&next, &start, &ent_len) == FAILURE)\n\t\t\t\tgoto invalid_code;\n\n\t\t\tif (resolve_named_entity_html(start, ent_len, inv_map, &code, &code2) == FAILURE) {\n\t\t\t\tif (doctype == ENT_HTML_DOC_XHTML && ent_len == 4 && start[0] == 'a'\n\t\t\t\t\t\t\t&& start[1] == 'p' && start[2] == 'o' && start[3] == 's') {\n\t\t\t\t\t/* uses html4 inv_map, which doesn't include apos;. This is a\n\t\t\t\t\t * hack to support it */\n\t\t\t\t\tcode = (unsigned) '\\'';\n\t\t\t\t} else {\n\t\t\t\t\tgoto invalid_code;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tassert(*next == ';');\n\n\t\tif (((code == '\\'' && !(flags & ENT_HTML_QUOTE_SINGLE)) ||\n\t\t\t\t(code == '\"' && !(flags & ENT_HTML_QUOTE_DOUBLE)))\n\t\t\t\t/* && code2 == '\\0' always true for current maps */)\n\t\t\tgoto invalid_code;\n\n\t\t/* UTF-8 doesn't need mapping (ISO-8859-1 doesn't either, but\n\t\t * the call is needed to ensure the codepoint <= U+00FF)  */\n\t\tif (charset != cs_utf_8) {\n\t\t\t/* replace unicode code point */\n\t\t\tif (map_from_unicode(code, charset, &code) == FAILURE || code2 != 0)\n\t\t\t\tgoto invalid_code; /* not representable in target charset */\n\t\t}\n\n\t\tq += write_octet_sequence(q, charset, code);\n\t\tif (code2) {\n\t\t\tq += write_octet_sequence(q, charset, code2);\n\t\t}\n\n\t\t/* jump over the valid entity; may go beyond size of buffer; np */\n\t\tp = next + 1;\n\t\tcontinue;\n\ninvalid_code:\n\t\tfor (; p < next; p++) {\n\t\t\t*(q++) = *p;\n\t\t}\n\t}\n\n\t*q = '\\0';\n\t*retlen = (size_t)(q - ret);\n}\n/* }}} */\n\n/* {{{ unescape_inverse_map */\nstatic const entity_ht *unescape_inverse_map(int all, int flags)\n{\n\tint document_type = flags & ENT_HTML_DOC_TYPE_MASK;\n\n\tif (all) {\n\t\tswitch (document_type) {\n\t\tcase ENT_HTML_DOC_HTML401:\n\t\tcase ENT_HTML_DOC_XHTML: /* but watch out for &apos;...*/\n\t\t\treturn &ent_ht_html4;\n\t\tcase ENT_HTML_DOC_HTML5:\n\t\t\treturn &ent_ht_html5;\n\t\tdefault:\n\t\t\treturn &ent_ht_be_apos;\n\t\t}\n\t} else {\n\t\tswitch (document_type) {\n\t\tcase ENT_HTML_DOC_HTML401:\n\t\t\treturn &ent_ht_be_noapos;\n\t\tdefault:\n\t\t\treturn &ent_ht_be_apos;\n\t\t}\n\t}\n}\n/* }}} */\n\n/* {{{ determine_entity_table\n * Entity table to use. Note that entity tables are defined in terms of\n * unicode code points */\nstatic entity_table_opt determine_entity_table(int all, int doctype)\n{\n\tentity_table_opt retval = {NULL};\n\n\tassert(!(doctype == ENT_HTML_DOC_XML1 && all));\n\n\tif (all) {\n\t\tretval.ms_table = (doctype == ENT_HTML_DOC_HTML5) ?\n\t\t\tentity_ms_table_html5 : entity_ms_table_html4;\n\t} else {\n\t\tretval.table = (doctype == ENT_HTML_DOC_HTML401) ?\n\t\t\tstage3_table_be_noapos_00000 : stage3_table_be_apos_00000;\n\t}\n\treturn retval;\n}\n/* }}} */\n\n/* {{{ php_unescape_html_entities\n * The parameter \"all\" should be true to decode all possible entities, false to decode\n * only the basic ones, i.e., those in basic_entities_ex + the numeric entities\n * that correspond to quotes.\n */\nPHPAPI char *php_unescape_html_entities(unsigned char *old, size_t oldlen, size_t *newlen, int all, int flags, char *hint_charset TSRMLS_DC)\n{\n\tsize_t retlen;\n\tchar *ret;\n\tenum entity_charset charset;\n\tconst entity_ht *inverse_map = NULL;\n\tsize_t new_size = TRAVERSE_FOR_ENTITIES_EXPAND_SIZE(oldlen);\n\n\tif (all) {\n\t\tcharset = determine_charset(hint_charset TSRMLS_CC);\n\t} else {\n\t\tcharset = cs_8859_1; /* charset shouldn't matter, use ISO-8859-1 for performance */\n\t}\n\n\t/* don't use LIMIT_ALL! */\n\n\tif (oldlen > new_size) {\n\t\t/* overflow, refuse to do anything */\n\t\tret = estrndup((char*)old, oldlen);\n\t\tretlen = oldlen;\n\t\tgoto empty_source;\n\t}\n\tret = emalloc(new_size);\n\t*ret = '\\0';\n\tretlen = oldlen;\n\tif (retlen == 0) {\n\t\tgoto empty_source;\n\t}\n\n\tinverse_map = unescape_inverse_map(all, flags);\n\n\t/* replace numeric entities */\n\ttraverse_for_entities(old, oldlen, ret, &retlen, all, flags, inverse_map, charset);\n\nempty_source:\n\t*newlen = retlen;\n\treturn ret;\n}\n/* }}} */\n\nPHPAPI char *php_escape_html_entities(unsigned char *old, size_t oldlen, size_t *newlen, int all, int flags, char *hint_charset TSRMLS_DC)\n{\n\treturn php_escape_html_entities_ex(old, oldlen, newlen, all, flags, hint_charset, 1 TSRMLS_CC);\n}\n\n/* {{{ find_entity_for_char */\nstatic inline void find_entity_for_char(\n\tunsigned int k,\n\tenum entity_charset charset,\n\tconst entity_stage1_row *table,\n\tconst unsigned char **entity,\n\tsize_t *entity_len,\n\tunsigned char *old,\n\tsize_t oldlen,\n\tsize_t *cursor)\n{\n\tunsigned stage1_idx = ENT_STAGE1_INDEX(k);\n\tconst entity_stage3_row *c;\n\n\tif (stage1_idx > 0x1D) {\n\t\t*entity     = NULL;\n\t\t*entity_len = 0;\n\t\treturn;\n\t}\n\n\tc = &table[stage1_idx][ENT_STAGE2_INDEX(k)][ENT_STAGE3_INDEX(k)];\n\n\tif (!c->ambiguous) {\n\t\t*entity     = (const unsigned char *)c->data.ent.entity;\n\t\t*entity_len = c->data.ent.entity_len;\n\t} else {\n\t\t/* peek at next char */\n\t\tsize_t\t cursor_before\t= *cursor;\n\t\tint\t\t status\t\t\t= SUCCESS;\n\t\tunsigned next_char;\n\n\t\tif (!(*cursor < oldlen))\n\t\t\tgoto no_suitable_2nd;\n\n\t\tnext_char = get_next_char(charset, old, oldlen, cursor, &status);\n\n\t\tif (status == FAILURE)\n\t\t\tgoto no_suitable_2nd;\n\n\t\t{\n\t\t\tconst entity_multicodepoint_row *s, *e;\n\n\t\t\ts = &c->data.multicodepoint_table[1];\n\t\t\te = s - 1 + c->data.multicodepoint_table[0].leading_entry.size;\n\t\t\t/* we could do a binary search but it's not worth it since we have\n\t\t\t * at most two entries... */\n\t\t\tfor ( ; s <= e; s++) {\n\t\t\t\tif (s->normal_entry.second_cp == next_char) {\n\t\t\t\t\t*entity     = s->normal_entry.entity;\n\t\t\t\t\t*entity_len = s->normal_entry.entity_len;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\nno_suitable_2nd:\n\t\t*cursor = cursor_before;\n\t\t*entity = (const unsigned char *)\n\t\t\tc->data.multicodepoint_table[0].leading_entry.default_entity;\n\t\t*entity_len = c->data.multicodepoint_table[0].leading_entry.default_entity_len;\n\t}\n}\n/* }}} */\n\n/* {{{ find_entity_for_char_basic */\nstatic inline void find_entity_for_char_basic(\n\tunsigned int k,\n\tconst entity_stage3_row *table,\n\tconst unsigned char **entity,\n\tsize_t *entity_len)\n{\n\tif (k >= 64U) {\n\t\t*entity     = NULL;\n\t\t*entity_len = 0;\n\t\treturn;\n\t}\n\n\t*entity     = table[k].data.ent.entity;\n\t*entity_len = table[k].data.ent.entity_len;\n}\n/* }}} */\n\n/* {{{ php_escape_html_entities\n */\nPHPAPI char *php_escape_html_entities_ex(unsigned char *old, size_t oldlen, size_t *newlen, int all, int flags, char *hint_charset, zend_bool double_encode TSRMLS_DC)\n{\n\tsize_t cursor, maxlen, len;\n\tchar *replaced;\n\tenum entity_charset charset = determine_charset(hint_charset TSRMLS_CC);\n\tint doctype = flags & ENT_HTML_DOC_TYPE_MASK;\n\tentity_table_opt entity_table;\n\tconst enc_to_uni *to_uni_table = NULL;\n\tconst entity_ht *inv_map = NULL; /* used for !double_encode */\n\t/* only used if flags includes ENT_HTML_IGNORE_ERRORS or ENT_HTML_SUBSTITUTE_DISALLOWED_CHARS */\n\tconst unsigned char *replacement = NULL;\n\tsize_t replacement_len = 0;\n\n\tif (all) { /* replace with all named entities */\n\t\tif (CHARSET_PARTIAL_SUPPORT(charset)) {\n\t\t\tphp_error_docref0(NULL TSRMLS_CC, E_STRICT, \"Only basic entities \"\n\t\t\t\t\"substitution is supported for multi-byte encodings other than UTF-8; \"\n\t\t\t\t\"functionality is equivalent to htmlspecialchars\");\n\t\t}\n\t\tLIMIT_ALL(all, doctype, charset);\n\t}\n\tentity_table = determine_entity_table(all, doctype);\n\tif (all && !CHARSET_UNICODE_COMPAT(charset)) {\n\t\tto_uni_table = enc_to_uni_index[charset];\n\t}\n\n\tif (!double_encode) {\n\t\t/* first arg is 1 because we want to identify valid named entities\n\t\t * even if we are only encoding the basic ones */\n\t\tinv_map = unescape_inverse_map(1, flags);\n\t}\n\n\tif (flags & (ENT_HTML_SUBSTITUTE_ERRORS | ENT_HTML_SUBSTITUTE_DISALLOWED_CHARS)) {\n\t\tif (charset == cs_utf_8) {\n\t\t\treplacement = (const unsigned char*)\"\\xEF\\xBF\\xBD\";\n\t\t\treplacement_len = sizeof(\"\\xEF\\xBF\\xBD\") - 1;\n\t\t} else {\n\t\t\treplacement = (const unsigned char*)\"&#xFFFD;\";\n\t\t\treplacement_len = sizeof(\"&#xFFFD;\") - 1;\n\t\t}\n\t}\n\n\t/* initial estimate */\n\tif (oldlen < 64) {\n\t\tmaxlen = 128;\n\t} else {\n\t\tmaxlen = 2 * oldlen;\n\t\tif (maxlen < oldlen) {\n\t\t\tzend_error_noreturn(E_ERROR, \"Input string is too long\");\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treplaced = emalloc(maxlen + 1); /* adding 1 is safe: maxlen is even */\n\tlen = 0;\n\tcursor = 0;\n\twhile (cursor < oldlen) {\n\t\tconst unsigned char *mbsequence = NULL;\n\t\tsize_t mbseqlen\t\t\t\t\t= 0,\n\t\t       cursor_before\t\t\t= cursor;\n\t\tint status\t\t\t\t\t\t= SUCCESS;\n\t\tunsigned int this_char\t\t\t= get_next_char(charset, old, oldlen, &cursor, &status);\n\n\t\t/* guarantee we have at least 40 bytes to write.\n\t\t * In HTML5, entities may take up to 33 bytes */\n\t\tif (len > maxlen - 40) { /* maxlen can never be smaller than 128 */\n\t\t\treplaced = safe_erealloc(replaced, maxlen , 1, 128 + 1);\n\t\t\tmaxlen += 128;\n\t\t}\n\n\t\tif (status == FAILURE) {\n\t\t\t/* invalid MB sequence */\n\t\t\tif (flags & ENT_HTML_IGNORE_ERRORS) {\n\t\t\t\tcontinue;\n\t\t\t} else if (flags & ENT_HTML_SUBSTITUTE_ERRORS) {\n\t\t\t\tmemcpy(&replaced[len], replacement, replacement_len);\n\t\t\t\tlen += replacement_len;\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tefree(replaced);\n\t\t\t\t*newlen = 0;\n\t\t\t\treturn STR_EMPTY_ALLOC();\n\t\t\t}\n\t\t} else { /* SUCCESS */\n\t\t\tmbsequence = &old[cursor_before];\n\t\t\tmbseqlen = cursor - cursor_before;\n\t\t}\n\n\t\tif (this_char != '&') { /* no entity on this position */\n\t\t\tconst unsigned char *rep\t= NULL;\n\t\t\tsize_t\t\t\t\trep_len\t= 0;\n\n\t\t\tif (((this_char == '\\'' && !(flags & ENT_HTML_QUOTE_SINGLE)) ||\n\t\t\t\t\t(this_char == '\"' && !(flags & ENT_HTML_QUOTE_DOUBLE))))\n\t\t\t\tgoto pass_char_through;\n\n\t\t\tif (all) { /* false that CHARSET_PARTIAL_SUPPORT(charset) */\n\t\t\t\tif (to_uni_table != NULL) {\n\t\t\t\t\t/* !CHARSET_UNICODE_COMPAT therefore not UTF-8; since UTF-8\n\t\t\t\t\t * is the only multibyte encoding with !CHARSET_PARTIAL_SUPPORT,\n\t\t\t\t\t * we're using a single byte encoding */\n\t\t\t\t\tmap_to_unicode(this_char, to_uni_table, &this_char);\n\t\t\t\t\tif (this_char == 0xFFFF) /* no mapping; pass through */\n\t\t\t\t\t\tgoto pass_char_through;\n\t\t\t\t}\n\t\t\t\t/* the cursor may advance */\n\t\t\t\tfind_entity_for_char(this_char, charset, entity_table.ms_table, &rep,\n\t\t\t\t\t&rep_len, old, oldlen, &cursor);\n\t\t\t} else {\n\t\t\t\tfind_entity_for_char_basic(this_char, entity_table.table, &rep, &rep_len);\n\t\t\t}\n\n\t\t\tif (rep != NULL) {\n\t\t\t\treplaced[len++] = '&';\n\t\t\t\tmemcpy(&replaced[len], rep, rep_len);\n\t\t\t\tlen += rep_len;\n\t\t\t\treplaced[len++] = ';';\n\t\t\t} else {\n\t\t\t\t/* we did not find an entity for this char.\n\t\t\t\t * check for its validity, if its valid pass it unchanged */\n\t\t\t\tif (flags & ENT_HTML_SUBSTITUTE_DISALLOWED_CHARS) {\n\t\t\t\t\tif (CHARSET_UNICODE_COMPAT(charset)) {\n\t\t\t\t\t\tif (!unicode_cp_is_allowed(this_char, doctype)) {\n\t\t\t\t\t\t\tmbsequence = replacement;\n\t\t\t\t\t\t\tmbseqlen = replacement_len;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (to_uni_table) {\n\t\t\t\t\t\tif (!all) /* otherwise we already did this */\n\t\t\t\t\t\t\tmap_to_unicode(this_char, to_uni_table, &this_char);\n\t\t\t\t\t\tif (!unicode_cp_is_allowed(this_char, doctype)) {\n\t\t\t\t\t\t\tmbsequence = replacement;\n\t\t\t\t\t\t\tmbseqlen = replacement_len;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* not a unicode code point, unless, coincidentally, it's in\n\t\t\t\t\t\t * the 0x20..0x7D range (except 0x5C in sjis). We know nothing\n\t\t\t\t\t\t * about other code points, because we have no tables. Since\n\t\t\t\t\t\t * Unicode code points in that range are not disallowed in any\n\t\t\t\t\t\t * document type, we could do nothing. However, conversion\n\t\t\t\t\t\t * tables frequently map 0x00-0x1F to the respective C0 code\n\t\t\t\t\t\t * points. Let's play it safe and admit that's the case */\n\t\t\t\t\t\tif (this_char <= 0x7D &&\n\t\t\t\t\t\t\t\t!unicode_cp_is_allowed(this_char, doctype)) {\n\t\t\t\t\t\t\tmbsequence = replacement;\n\t\t\t\t\t\t\tmbseqlen = replacement_len;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\npass_char_through:\n\t\t\t\tif (mbseqlen > 1) {\n\t\t\t\t\tmemcpy(replaced + len, mbsequence, mbseqlen);\n\t\t\t\t\tlen += mbseqlen;\n\t\t\t\t} else {\n\t\t\t\t\treplaced[len++] = mbsequence[0];\n\t\t\t\t}\n\t\t\t}\n\t\t} else { /* this_char == '&' */\n\t\t\tif (double_encode) {\nencode_amp:\n\t\t\t\tmemcpy(&replaced[len], \"&amp;\", sizeof(\"&amp;\") - 1);\n\t\t\t\tlen += sizeof(\"&amp;\") - 1;\n\t\t\t} else { /* no double encode */\n\t\t\t\t/* check if entity is valid */\n\t\t\t\tsize_t ent_len; /* not counting & or ; */\n\t\t\t\t/* peek at next char */\n\t\t\t\tif (old[cursor] == '#') { /* numeric entity */\n\t\t\t\t\tunsigned code_point;\n\t\t\t\t\tint valid;\n\t\t\t\t\tchar *pos = (char*)&old[cursor+1];\n\t\t\t\t\tvalid = process_numeric_entity((const char **)&pos, &code_point);\n\t\t\t\t\tif (valid == FAILURE)\n\t\t\t\t\t\tgoto encode_amp;\n\t\t\t\t\tif (flags & ENT_HTML_SUBSTITUTE_DISALLOWED_CHARS) {\n\t\t\t\t\t\tif (!numeric_entity_is_allowed(code_point, doctype))\n\t\t\t\t\t\t\tgoto encode_amp;\n\t\t\t\t\t}\n\t\t\t\t\tent_len = pos - (char*)&old[cursor];\n\t\t\t\t} else { /* named entity */\n\t\t\t\t\t/* check for vality of named entity */\n\t\t\t\t\tconst char *start = &old[cursor],\n\t\t\t\t\t\t\t   *next = start;\n\t\t\t\t\tunsigned   dummy1, dummy2;\n\n\t\t\t\t\tif (process_named_entity_html(&next, &start, &ent_len) == FAILURE)\n\t\t\t\t\t\tgoto encode_amp;\n\t\t\t\t\tif (resolve_named_entity_html(start, ent_len, inv_map, &dummy1, &dummy2) == FAILURE) {\n\t\t\t\t\t\tif (!(doctype == ENT_HTML_DOC_XHTML && ent_len == 4 && start[0] == 'a'\n\t\t\t\t\t\t\t\t\t&& start[1] == 'p' && start[2] == 'o' && start[3] == 's')) {\n\t\t\t\t\t\t\t/* uses html4 inv_map, which doesn't include apos;. This is a\n\t\t\t\t\t\t\t * hack to support it */\n\t\t\t\t\t\t\tgoto encode_amp;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/* checks passed; copy entity to result */\n\t\t\t\t/* entity size is unbounded, we may need more memory */\n\t\t\t\t/* at this point maxlen - len >= 40 */\n\t\t\t\tif (maxlen - len < ent_len + 2 /* & and ; */) {\n\t\t\t\t\t/* ent_len < oldlen, which is certainly <= SIZE_MAX/2 */\n\t\t\t\t\treplaced = safe_erealloc(replaced, maxlen, 1, ent_len + 128 + 1);\n\t\t\t\t\tmaxlen += ent_len + 128;\n\t\t\t\t}\n\t\t\t\treplaced[len++] = '&';\n\t\t\t\tmemcpy(&replaced[len], &old[cursor], ent_len);\n\t\t\t\tlen += ent_len;\n\t\t\t\treplaced[len++] = ';';\n\t\t\t\tcursor += ent_len + 1;\n\t\t\t}\n\t\t}\n\t}\n\treplaced[len] = '\\0';\n\t*newlen = len;\n\n\treturn replaced;\n}\n/* }}} */\n\n/* {{{ php_html_entities\n */\nstatic void php_html_entities(INTERNAL_FUNCTION_PARAMETERS, int all)\n{\n\tchar *str, *hint_charset = NULL;\n\tint str_len, hint_charset_len = 0;\n\tsize_t new_len;\n\tlong flags = ENT_COMPAT;\n\tchar *replaced;\n\tzend_bool double_encode = 1;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s|ls!b\", &str, &str_len, &flags, &hint_charset, &hint_charset_len, &double_encode) == FAILURE) {\n\t\treturn;\n\t}\n\n\treplaced = php_escape_html_entities_ex(str, str_len, &new_len, all, (int) flags, hint_charset, double_encode TSRMLS_CC);\n\tif (new_len > INT_MAX) {\n\t\tefree(replaced);\n\t\tRETURN_FALSE;\n\t}\n\tRETVAL_STRINGL(replaced, (int)new_len, 0);\n}\n/* }}} */\n\n#define HTML_SPECIALCHARS \t0\n#define HTML_ENTITIES\t \t1\n\n/* {{{ register_html_constants\n */\nvoid register_html_constants(INIT_FUNC_ARGS)\n{\n\tREGISTER_LONG_CONSTANT(\"HTML_SPECIALCHARS\", HTML_SPECIALCHARS, CONST_PERSISTENT|CONST_CS);\n\tREGISTER_LONG_CONSTANT(\"HTML_ENTITIES\", HTML_ENTITIES, CONST_PERSISTENT|CONST_CS);\n\tREGISTER_LONG_CONSTANT(\"ENT_COMPAT\", ENT_COMPAT, CONST_PERSISTENT|CONST_CS);\n\tREGISTER_LONG_CONSTANT(\"ENT_QUOTES\", ENT_QUOTES, CONST_PERSISTENT|CONST_CS);\n\tREGISTER_LONG_CONSTANT(\"ENT_NOQUOTES\", ENT_NOQUOTES, CONST_PERSISTENT|CONST_CS);\n\tREGISTER_LONG_CONSTANT(\"ENT_IGNORE\", ENT_IGNORE, CONST_PERSISTENT|CONST_CS);\n\tREGISTER_LONG_CONSTANT(\"ENT_SUBSTITUTE\", ENT_SUBSTITUTE, CONST_PERSISTENT|CONST_CS);\n\tREGISTER_LONG_CONSTANT(\"ENT_DISALLOWED\", ENT_DISALLOWED, CONST_PERSISTENT|CONST_CS);\n\tREGISTER_LONG_CONSTANT(\"ENT_HTML401\", ENT_HTML401, CONST_PERSISTENT|CONST_CS);\n\tREGISTER_LONG_CONSTANT(\"ENT_XML1\", ENT_XML1, CONST_PERSISTENT|CONST_CS);\n\tREGISTER_LONG_CONSTANT(\"ENT_XHTML\", ENT_XHTML, CONST_PERSISTENT|CONST_CS);\n\tREGISTER_LONG_CONSTANT(\"ENT_HTML5\", ENT_HTML5, CONST_PERSISTENT|CONST_CS);\n}\n/* }}} */\n\n/* {{{ proto string htmlspecialchars(string string [, int quote_style[, string charset[, bool double_encode]]])\n   Convert special characters to HTML entities */\nPHP_FUNCTION(htmlspecialchars)\n{\n\tphp_html_entities(INTERNAL_FUNCTION_PARAM_PASSTHRU, 0);\n}\n/* }}} */\n\n/* {{{ proto string htmlspecialchars_decode(string string [, int quote_style])\n   Convert special HTML entities back to characters */\nPHP_FUNCTION(htmlspecialchars_decode)\n{\n\tchar *str;\n\tint str_len;\n\tsize_t new_len = 0;\n\tlong quote_style = ENT_COMPAT;\n\tchar *replaced;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s|l\", &str, &str_len, &quote_style) == FAILURE) {\n\t\treturn;\n\t}\n\n\treplaced = php_unescape_html_entities(str, str_len, &new_len, 0 /*!all*/, quote_style, NULL TSRMLS_CC);\n\tif (replaced) {\n\t\tRETURN_STRINGL(replaced, (int)new_len, 0);\n\t}\n\tRETURN_FALSE;\n}\n/* }}} */\n\n/* {{{ proto string html_entity_decode(string string [, int quote_style][, string charset])\n   Convert all HTML entities to their applicable characters */\nPHP_FUNCTION(html_entity_decode)\n{\n\tchar *str, *hint_charset = NULL;\n\tint str_len, hint_charset_len = 0;\n\tsize_t new_len = 0;\n\tlong quote_style = ENT_COMPAT;\n\tchar *replaced;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s|ls\", &str, &str_len,\n\t\t\t\t\t\t\t  &quote_style, &hint_charset, &hint_charset_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\treplaced = php_unescape_html_entities(str, str_len, &new_len, 1 /*all*/, quote_style, hint_charset TSRMLS_CC);\n\tif (replaced) {\n\t\tRETURN_STRINGL(replaced, (int)new_len, 0);\n\t}\n\tRETURN_FALSE;\n}\n/* }}} */\n\n\n/* {{{ proto string htmlentities(string string [, int quote_style[, string charset[, bool double_encode]]])\n   Convert all applicable characters to HTML entities */\nPHP_FUNCTION(htmlentities)\n{\n\tphp_html_entities(INTERNAL_FUNCTION_PARAM_PASSTHRU, 1);\n}\n/* }}} */\n\n/* {{{ write_s3row_data */\nstatic inline void write_s3row_data(\n\tconst entity_stage3_row *r,\n\tunsigned orig_cp,\n\tenum entity_charset charset,\n\tzval *arr)\n{\n\tchar key[9] = \"\"; /* two unicode code points in UTF-8 */\n\tchar entity[LONGEST_ENTITY_LENGTH + 2] = {'&'};\n\tsize_t written_k1;\n\n\twritten_k1 = write_octet_sequence(key, charset, orig_cp);\n\n\tif (!r->ambiguous) {\n\t\tsize_t l = r->data.ent.entity_len;\n\t\tmemcpy(&entity[1], r->data.ent.entity, l);\n\t\tentity[l + 1] = ';';\n\t\tadd_assoc_stringl_ex(arr, key, written_k1 + 1, entity, l + 2, 1);\n\t} else {\n\t\tunsigned i,\n\t\t\t     num_entries;\n\t\tconst entity_multicodepoint_row *mcpr = r->data.multicodepoint_table;\n\n\t\tif (mcpr[0].leading_entry.default_entity != NULL) {\n\t\t\tsize_t l = mcpr[0].leading_entry.default_entity_len;\n\t\t\tmemcpy(&entity[1], mcpr[0].leading_entry.default_entity, l);\n\t\t\tentity[l + 1] = ';';\n\t\t\tadd_assoc_stringl_ex(arr, key, written_k1 + 1, entity, l + 2, 1);\n\t\t}\n\t\tnum_entries = mcpr[0].leading_entry.size;\n\t\tfor (i = 1; i <= num_entries; i++) {\n\t\t\tsize_t   l,\n\t\t\t\t     written_k2;\n\t\t\tunsigned uni_cp,\n\t\t\t\t\t spe_cp;\n\n\t\t\tuni_cp = mcpr[i].normal_entry.second_cp;\n\t\t\tl = mcpr[i].normal_entry.entity_len;\n\n\t\t\tif (!CHARSET_UNICODE_COMPAT(charset)) {\n\t\t\t\tif (map_from_unicode(uni_cp, charset, &spe_cp) == FAILURE)\n\t\t\t\t\tcontinue; /* non representable in this charset */\n\t\t\t} else {\n\t\t\t\tspe_cp = uni_cp;\n\t\t\t}\n\n\t\t\twritten_k2 = write_octet_sequence(&key[written_k1], charset, spe_cp);\n\t\t\tmemcpy(&entity[1], mcpr[i].normal_entry.entity, l);\n\t\t\tentity[l + 1] = ';';\n\t\t\tentity[l + 1] = '\\0';\n\t\t\tadd_assoc_stringl_ex(arr, key, written_k1 + written_k2 + 1, entity, l + 1, 1);\n\t\t}\n\t}\n}\n/* }}} */\n\n/* {{{ proto array get_html_translation_table([int table [, int flags [, string charset_hint]]])\n   Returns the internal translation table used by htmlspecialchars and htmlentities */\nPHP_FUNCTION(get_html_translation_table)\n{\n\tlong all = HTML_SPECIALCHARS,\n\t\t flags = ENT_COMPAT;\n\tint doctype;\n\tentity_table_opt entity_table;\n\tconst enc_to_uni *to_uni_table = NULL;\n\tchar *charset_hint = NULL;\n\tint charset_hint_len;\n\tenum entity_charset charset;\n\n\t/* in this function we have to jump through some loops because we're\n\t * getting the translated table from data structures that are optimized for\n\t * random access, not traversal */\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"|lls\",\n\t\t\t&all, &flags, &charset_hint, &charset_hint_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tcharset = determine_charset(charset_hint TSRMLS_CC);\n\tdoctype = flags & ENT_HTML_DOC_TYPE_MASK;\n\tLIMIT_ALL(all, doctype, charset);\n\n\tarray_init(return_value);\n\n\tentity_table = determine_entity_table(all, doctype);\n\tif (all && !CHARSET_UNICODE_COMPAT(charset)) {\n\t\tto_uni_table = enc_to_uni_index[charset];\n\t}\n\n\tif (all) { /* HTML_ENTITIES (actually, any non-zero value for 1st param) */\n\t\tconst entity_stage1_row *ms_table = entity_table.ms_table;\n\n\t\tif (CHARSET_UNICODE_COMPAT(charset)) {\n\t\t\tunsigned i, j, k,\n\t\t\t\t\t max_i, max_j, max_k;\n\t\t\t/* no mapping to unicode required */\n\t\t\tif (CHARSET_SINGLE_BYTE(charset)) { /* ISO-8859-1 */\n\t\t\t\tmax_i = 1; max_j = 4; max_k = 64;\n\t\t\t} else {\n\t\t\t\tmax_i = 0x1E; max_j = 64; max_k = 64;\n\t\t\t}\n\n\t\t\tfor (i = 0; i < max_i; i++) {\n\t\t\t\tif (ms_table[i] == empty_stage2_table)\n\t\t\t\t\tcontinue;\n\t\t\t\tfor (j = 0; j < max_j; j++) {\n\t\t\t\t\tif (ms_table[i][j] == empty_stage3_table)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tfor (k = 0; k < max_k; k++) {\n\t\t\t\t\t\tconst entity_stage3_row *r = &ms_table[i][j][k];\n\t\t\t\t\t\tunsigned code;\n\n\t\t\t\t\t\tif (r->data.ent.entity == NULL)\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\tcode = ENT_CODE_POINT_FROM_STAGES(i, j, k);\n\t\t\t\t\t\tif (((code == '\\'' && !(flags & ENT_HTML_QUOTE_SINGLE)) ||\n\t\t\t\t\t\t\t\t(code == '\"' && !(flags & ENT_HTML_QUOTE_DOUBLE))))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\twrite_s3row_data(r, code, charset, return_value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t/* we have to iterate through the set of code points for this\n\t\t\t * encoding and map them to unicode code points */\n\t\t\tunsigned i;\n\t\t\tfor (i = 0; i <= 0xFF; i++) {\n\t\t\t\tconst entity_stage3_row *r;\n\t\t\t\tunsigned uni_cp;\n\n\t\t\t\t/* can be done before mapping, they're invariant */\n\t\t\t\tif (((i == '\\'' && !(flags & ENT_HTML_QUOTE_SINGLE)) ||\n\t\t\t\t\t\t(i == '\"' && !(flags & ENT_HTML_QUOTE_DOUBLE))))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tmap_to_unicode(i, to_uni_table, &uni_cp);\n\t\t\t\tr = &ms_table[ENT_STAGE1_INDEX(uni_cp)][ENT_STAGE2_INDEX(uni_cp)][ENT_STAGE3_INDEX(uni_cp)];\n\t\t\t\tif (r->data.ent.entity == NULL)\n\t\t\t\t\tcontinue;\n\n\t\t\t\twrite_s3row_data(r, i, charset, return_value);\n\t\t\t}\n\t\t}\n\t} else {\n\t\t/* we could use sizeof(stage3_table_be_apos_00000) as well */\n\t\tunsigned\t  j,\n\t\t\t\t\t  numelems = sizeof(stage3_table_be_noapos_00000) /\n\t\t\t\t\t\t\tsizeof(*stage3_table_be_noapos_00000);\n\n\t\tfor (j = 0; j < numelems; j++) {\n\t\t\tconst entity_stage3_row *r = &entity_table.table[j];\n\t\t\tif (r->data.ent.entity == NULL)\n\t\t\t\tcontinue;\n\n\t\t\tif (((j == '\\'' && !(flags & ENT_HTML_QUOTE_SINGLE)) ||\n\t\t\t\t\t(j == '\"' && !(flags & ENT_HTML_QUOTE_DOUBLE))))\n\t\t\t\tcontinue;\n\n\t\t\t/* charset is indifferent, used cs_8859_1 for efficiency */\n\t\t\twrite_s3row_data(r, j, cs_8859_1, return_value);\n\t\t}\n\t}\n}\n/* }}} */\n\n/*\n * Local variables:\n * tab-width: 4\n * c-basic-offset: 4\n * End:\n * vim600: sw=4 ts=4 fdm=marker\n * vim<600: sw=4 ts=4\n */\n", "code_before": "/*\n   +----------------------------------------------------------------------+\n   | Copyright (c) The PHP Group                                          |\n   +----------------------------------------------------------------------+\n   | This source file is subject to version 3.01 of the PHP license,      |\n   | that is bundled with this package in the file LICENSE, and is        |\n   | available through the world-wide-web at the following url:           |\n   | https://www.php.net/license/3_01.txt                                 |\n   | If you did not receive a copy of the PHP license and are unable to   |\n   | obtain it through the world-wide-web, please send a note to          |\n   | license@php.net so we can mail you a copy immediately.               |\n   +----------------------------------------------------------------------+\n   | Authors: Rasmus Lerdorf <rasmus@php.net>                             |\n   |          Jaakko Hyv\u00e4tti <jaakko.hyvatti@iki.fi>                      |\n   |          Wez Furlong    <wez@thebrainroom.com>                       |\n   |          Gustavo Lopes  <cataphract@php.net>                         |\n   +----------------------------------------------------------------------+\n*/\n\n/*\n * HTML entity resources:\n *\n * http://www.unicode.org/Public/MAPPINGS/OBSOLETE/UNI2SGML.TXT\n *\n * XHTML 1.0 DTD\n * http://www.w3.org/TR/2002/REC-xhtml1-20020801/dtds.html#h-A2\n *\n * From HTML 4.01 strict DTD:\n * http://www.w3.org/TR/html4/HTMLlat1.ent\n * http://www.w3.org/TR/html4/HTMLsymbol.ent\n * http://www.w3.org/TR/html4/HTMLspecial.ent\n *\n * HTML 5:\n * http://dev.w3.org/html5/spec/Overview.html#named-character-references\n */\n\n#include \"php.h\"\n#ifdef PHP_WIN32\n#include \"config.w32.h\"\n#else\n#include <php_config.h>\n#endif\n#include \"php_standard.h\"\n#include \"SAPI.h\"\n#include <locale.h>\n\n#include <zend_hash.h>\n#include \"html_tables.h\"\n\n/* Macro for disabling flag of translation of non-basic entities where this isn't supported.\n * Not appropriate for html_entity_decode/htmlspecialchars_decode */\n#define LIMIT_ALL(all, doctype, charset) do { \\\n\t(all) = (all) && !CHARSET_PARTIAL_SUPPORT((charset)) && ((doctype) != ENT_HTML_DOC_XML1); \\\n} while (0)\n\n#define MB_FAILURE(pos, advance) do { \\\n\t*cursor = pos + (advance); \\\n\t*status = FAILURE; \\\n\treturn 0; \\\n} while (0)\n\n#define CHECK_LEN(pos, chars_need) ((str_len - (pos)) >= (chars_need))\n\n/* valid as single byte character or leading byte */\n#define utf8_lead(c)  ((c) < 0x80 || ((c) >= 0xC2 && (c) <= 0xF4))\n/* whether it's actually valid depends on other stuff;\n * this macro cannot check for non-shortest forms, surrogates or\n * code points above 0x10FFFF */\n#define utf8_trail(c) ((c) >= 0x80 && (c) <= 0xBF)\n\n#define gb2312_lead(c) ((c) != 0x8E && (c) != 0x8F && (c) != 0xA0 && (c) != 0xFF)\n#define gb2312_trail(c) ((c) >= 0xA1 && (c) <= 0xFE)\n\n#define sjis_lead(c) ((c) != 0x80 && (c) != 0xA0 && (c) < 0xFD)\n#define sjis_trail(c) ((c) >= 0x40  && (c) != 0x7F && (c) < 0xFD)\n\n/* {{{ get_default_charset */\nstatic char *get_default_charset(void) {\n\tif (PG(internal_encoding) && PG(internal_encoding)[0]) {\n\t\treturn PG(internal_encoding);\n\t} else if (SG(default_charset) && SG(default_charset)[0] ) {\n\t\treturn SG(default_charset);\n\t}\n\treturn NULL;\n}\n/* }}} */\n\n/* {{{ get_next_char */\nstatic inline unsigned int get_next_char(\n\t\tenum entity_charset charset,\n\t\tconst unsigned char *str,\n\t\tsize_t str_len,\n\t\tsize_t *cursor,\n\t\tzend_result *status)\n{\n\tsize_t pos = *cursor;\n\tunsigned int this_char = 0;\n\n\t*status = SUCCESS;\n\tassert(pos <= str_len);\n\n\tif (!CHECK_LEN(pos, 1))\n\t\tMB_FAILURE(pos, 1);\n\n\tswitch (charset) {\n\tcase cs_utf_8:\n\t\t{\n\t\t\t/* We'll follow strategy 2. from section 3.6.1 of UTR #36:\n\t\t\t * \"In a reported illegal byte sequence, do not include any\n\t\t\t *  non-initial byte that encodes a valid character or is a leading\n\t\t\t *  byte for a valid sequence.\" */\n\t\t\tunsigned char c;\n\t\t\tc = str[pos];\n\t\t\tif (c < 0x80) {\n\t\t\t\tthis_char = c;\n\t\t\t\tpos++;\n\t\t\t} else if (c < 0xc2) {\n\t\t\t\tMB_FAILURE(pos, 1);\n\t\t\t} else if (c < 0xe0) {\n\t\t\t\tif (!CHECK_LEN(pos, 2))\n\t\t\t\t\tMB_FAILURE(pos, 1);\n\n\t\t\t\tif (!utf8_trail(str[pos + 1])) {\n\t\t\t\t\tMB_FAILURE(pos, utf8_lead(str[pos + 1]) ? 1 : 2);\n\t\t\t\t}\n\t\t\t\tthis_char = ((c & 0x1f) << 6) | (str[pos + 1] & 0x3f);\n\t\t\t\tif (this_char < 0x80) { /* non-shortest form */\n\t\t\t\t\tMB_FAILURE(pos, 2);\n\t\t\t\t}\n\t\t\t\tpos += 2;\n\t\t\t} else if (c < 0xf0) {\n\t\t\t\tsize_t avail = str_len - pos;\n\n\t\t\t\tif (avail < 3 ||\n\t\t\t\t\t\t!utf8_trail(str[pos + 1]) || !utf8_trail(str[pos + 2])) {\n\t\t\t\t\tif (avail < 2 || utf8_lead(str[pos + 1]))\n\t\t\t\t\t\tMB_FAILURE(pos, 1);\n\t\t\t\t\telse if (avail < 3 || utf8_lead(str[pos + 2]))\n\t\t\t\t\t\tMB_FAILURE(pos, 2);\n\t\t\t\t\telse\n\t\t\t\t\t\tMB_FAILURE(pos, 3);\n\t\t\t\t}\n\n\t\t\t\tthis_char = ((c & 0x0f) << 12) | ((str[pos + 1] & 0x3f) << 6) | (str[pos + 2] & 0x3f);\n\t\t\t\tif (this_char < 0x800) { /* non-shortest form */\n\t\t\t\t\tMB_FAILURE(pos, 3);\n\t\t\t\t} else if (this_char >= 0xd800 && this_char <= 0xdfff) { /* surrogate */\n\t\t\t\t\tMB_FAILURE(pos, 3);\n\t\t\t\t}\n\t\t\t\tpos += 3;\n\t\t\t} else if (c < 0xf5) {\n\t\t\t\tsize_t avail = str_len - pos;\n\n\t\t\t\tif (avail < 4 ||\n\t\t\t\t\t\t!utf8_trail(str[pos + 1]) || !utf8_trail(str[pos + 2]) ||\n\t\t\t\t\t\t!utf8_trail(str[pos + 3])) {\n\t\t\t\t\tif (avail < 2 || utf8_lead(str[pos + 1]))\n\t\t\t\t\t\tMB_FAILURE(pos, 1);\n\t\t\t\t\telse if (avail < 3 || utf8_lead(str[pos + 2]))\n\t\t\t\t\t\tMB_FAILURE(pos, 2);\n\t\t\t\t\telse if (avail < 4 || utf8_lead(str[pos + 3]))\n\t\t\t\t\t\tMB_FAILURE(pos, 3);\n\t\t\t\t\telse\n\t\t\t\t\t\tMB_FAILURE(pos, 4);\n\t\t\t\t}\n\n\t\t\t\tthis_char = ((c & 0x07) << 18) | ((str[pos + 1] & 0x3f) << 12) | ((str[pos + 2] & 0x3f) << 6) | (str[pos + 3] & 0x3f);\n\t\t\t\tif (this_char < 0x10000 || this_char > 0x10FFFF) { /* non-shortest form or outside range */\n\t\t\t\t\tMB_FAILURE(pos, 4);\n\t\t\t\t}\n\t\t\t\tpos += 4;\n\t\t\t} else {\n\t\t\t\tMB_FAILURE(pos, 1);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase cs_big5:\n\t\t/* reference http://demo.icu-project.org/icu-bin/convexp?conv=big5 */\n\t\t{\n\t\t\tunsigned char c = str[pos];\n\t\t\tif (c >= 0x81 && c <= 0xFE) {\n\t\t\t\tunsigned char next;\n\t\t\t\tif (!CHECK_LEN(pos, 2))\n\t\t\t\t\tMB_FAILURE(pos, 1);\n\n\t\t\t\tnext = str[pos + 1];\n\n\t\t\t\tif ((next >= 0x40 && next <= 0x7E) ||\n\t\t\t\t\t\t(next >= 0xA1 && next <= 0xFE)) {\n\t\t\t\t\tthis_char = (c << 8) | next;\n\t\t\t\t} else {\n\t\t\t\t\tMB_FAILURE(pos, 1);\n\t\t\t\t}\n\t\t\t\tpos += 2;\n\t\t\t} else {\n\t\t\t\tthis_char = c;\n\t\t\t\tpos += 1;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase cs_big5hkscs:\n\t\t{\n\t\t\tunsigned char c = str[pos];\n\t\t\tif (c >= 0x81 && c <= 0xFE) {\n\t\t\t\tunsigned char next;\n\t\t\t\tif (!CHECK_LEN(pos, 2))\n\t\t\t\t\tMB_FAILURE(pos, 1);\n\n\t\t\t\tnext = str[pos + 1];\n\n\t\t\t\tif ((next >= 0x40 && next <= 0x7E) ||\n\t\t\t\t\t\t(next >= 0xA1 && next <= 0xFE)) {\n\t\t\t\t\tthis_char = (c << 8) | next;\n\t\t\t\t} else if (next != 0x80 && next != 0xFF) {\n\t\t\t\t\tMB_FAILURE(pos, 1);\n\t\t\t\t} else {\n\t\t\t\t\tMB_FAILURE(pos, 2);\n\t\t\t\t}\n\t\t\t\tpos += 2;\n\t\t\t} else {\n\t\t\t\tthis_char = c;\n\t\t\t\tpos += 1;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase cs_gb2312: /* EUC-CN */\n\t\t{\n\t\t\tunsigned char c = str[pos];\n\t\t\tif (c >= 0xA1 && c <= 0xFE) {\n\t\t\t\tunsigned char next;\n\t\t\t\tif (!CHECK_LEN(pos, 2))\n\t\t\t\t\tMB_FAILURE(pos, 1);\n\n\t\t\t\tnext = str[pos + 1];\n\n\t\t\t\tif (gb2312_trail(next)) {\n\t\t\t\t\tthis_char = (c << 8) | next;\n\t\t\t\t} else if (gb2312_lead(next)) {\n\t\t\t\t\tMB_FAILURE(pos, 1);\n\t\t\t\t} else {\n\t\t\t\t\tMB_FAILURE(pos, 2);\n\t\t\t\t}\n\t\t\t\tpos += 2;\n\t\t\t} else if (gb2312_lead(c)) {\n\t\t\t\tthis_char = c;\n\t\t\t\tpos += 1;\n\t\t\t} else {\n\t\t\t\tMB_FAILURE(pos, 1);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase cs_sjis:\n\t\t{\n\t\t\tunsigned char c = str[pos];\n\t\t\tif ((c >= 0x81 && c <= 0x9F) || (c >= 0xE0 && c <= 0xFC)) {\n\t\t\t\tunsigned char next;\n\t\t\t\tif (!CHECK_LEN(pos, 2))\n\t\t\t\t\tMB_FAILURE(pos, 1);\n\n\t\t\t\tnext = str[pos + 1];\n\n\t\t\t\tif (sjis_trail(next)) {\n\t\t\t\t\tthis_char = (c << 8) | next;\n\t\t\t\t} else if (sjis_lead(next)) {\n\t\t\t\t\tMB_FAILURE(pos, 1);\n\t\t\t\t} else {\n\t\t\t\t\tMB_FAILURE(pos, 2);\n\t\t\t\t}\n\t\t\t\tpos += 2;\n\t\t\t} else if (c < 0x80 || (c >= 0xA1 && c <= 0xDF)) {\n\t\t\t\tthis_char = c;\n\t\t\t\tpos += 1;\n\t\t\t} else {\n\t\t\t\tMB_FAILURE(pos, 1);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase cs_eucjp:\n\t\t{\n\t\t\tunsigned char c = str[pos];\n\n\t\t\tif (c >= 0xA1 && c <= 0xFE) {\n\t\t\t\tunsigned next;\n\t\t\t\tif (!CHECK_LEN(pos, 2))\n\t\t\t\t\tMB_FAILURE(pos, 1);\n\t\t\t\tnext = str[pos + 1];\n\n\t\t\t\tif (next >= 0xA1 && next <= 0xFE) {\n\t\t\t\t\t/* this a jis kanji char */\n\t\t\t\t\tthis_char = (c << 8) | next;\n\t\t\t\t} else {\n\t\t\t\t\tMB_FAILURE(pos, (next != 0xA0 && next != 0xFF) ? 1 : 2);\n\t\t\t\t}\n\t\t\t\tpos += 2;\n\t\t\t} else if (c == 0x8E) {\n\t\t\t\tunsigned next;\n\t\t\t\tif (!CHECK_LEN(pos, 2))\n\t\t\t\t\tMB_FAILURE(pos, 1);\n\n\t\t\t\tnext = str[pos + 1];\n\t\t\t\tif (next >= 0xA1 && next <= 0xDF) {\n\t\t\t\t\t/* JIS X 0201 kana */\n\t\t\t\t\tthis_char = (c << 8) | next;\n\t\t\t\t} else {\n\t\t\t\t\tMB_FAILURE(pos, (next != 0xA0 && next != 0xFF) ? 1 : 2);\n\t\t\t\t}\n\t\t\t\tpos += 2;\n\t\t\t} else if (c == 0x8F) {\n\t\t\t\tsize_t avail = str_len - pos;\n\n\t\t\t\tif (avail < 3 || !(str[pos + 1] >= 0xA1 && str[pos + 1] <= 0xFE) ||\n\t\t\t\t\t\t!(str[pos + 2] >= 0xA1 && str[pos + 2] <= 0xFE)) {\n\t\t\t\t\tif (avail < 2 || (str[pos + 1] != 0xA0 && str[pos + 1] != 0xFF))\n\t\t\t\t\t\tMB_FAILURE(pos, 1);\n\t\t\t\t\telse if (avail < 3 || (str[pos + 2] != 0xA0 && str[pos + 2] != 0xFF))\n\t\t\t\t\t\tMB_FAILURE(pos, 2);\n\t\t\t\t\telse\n\t\t\t\t\t\tMB_FAILURE(pos, 3);\n\t\t\t\t} else {\n\t\t\t\t\t/* JIS X 0212 hojo-kanji */\n\t\t\t\t\tthis_char = (c << 16) | (str[pos + 1] << 8) | str[pos + 2];\n\t\t\t\t}\n\t\t\t\tpos += 3;\n\t\t\t} else if (c != 0xA0 && c != 0xFF) {\n\t\t\t\t/* character encoded in 1 code unit */\n\t\t\t\tthis_char = c;\n\t\t\t\tpos += 1;\n\t\t\t} else {\n\t\t\t\tMB_FAILURE(pos, 1);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\t/* single-byte charsets */\n\t\tthis_char = str[pos++];\n\t\tbreak;\n\t}\n\n\t*cursor = pos;\n\treturn this_char;\n}\n/* }}} */\n\n/* {{{ php_next_utf8_char\n * Public interface for get_next_char used with UTF-8 */\nPHPAPI unsigned int php_next_utf8_char(\n\t\tconst unsigned char *str,\n\t\tsize_t str_len,\n\t\tsize_t *cursor,\n\t\tzend_result *status)\n{\n\treturn get_next_char(cs_utf_8, str, str_len, cursor, status);\n}\n/* }}} */\n\n/* {{{ entity_charset determine_charset\n * Returns the charset identifier based on an explicitly provided charset,\n * the internal_encoding and default_charset ini settings, or UTF-8 by default. */\nstatic enum entity_charset determine_charset(const char *charset_hint, bool quiet)\n{\n\tif (!charset_hint || !*charset_hint) {\n\t\tcharset_hint = get_default_charset();\n\t}\n\n\tif (charset_hint && *charset_hint) {\n\t\tsize_t len = strlen(charset_hint);\n\t\t/* now walk the charset map and look for the codeset */\n\t\tfor (size_t i = 0; i < sizeof(charset_map)/sizeof(charset_map[0]); i++) {\n\t\t\tif (len == charset_map[i].codeset_len &&\n\t\t\t    zend_binary_strcasecmp(charset_hint, len, charset_map[i].codeset, len) == 0) {\n\t\t\t\treturn charset_map[i].charset;\n\t\t\t}\n\t\t}\n\n\t\tif (!quiet) {\n\t\t\tphp_error_docref(NULL, E_WARNING, \"Charset \\\"%s\\\" is not supported, assuming UTF-8\",\n\t\t\t\t\tcharset_hint);\n\t\t}\n\t}\n\n\treturn cs_utf_8;\n}\n/* }}} */\n\n/* {{{ php_utf32_utf8 */\nstatic inline size_t php_utf32_utf8(unsigned char *buf, unsigned k)\n{\n\tsize_t retval = 0;\n\n\t/* assert(0x0 <= k <= 0x10FFFF); */\n\n\tif (k < 0x80) {\n\t\tbuf[0] = k;\n\t\tretval = 1;\n\t} else if (k < 0x800) {\n\t\tbuf[0] = 0xc0 | (k >> 6);\n\t\tbuf[1] = 0x80 | (k & 0x3f);\n\t\tretval = 2;\n\t} else if (k < 0x10000) {\n\t\tbuf[0] = 0xe0 | (k >> 12);\n\t\tbuf[1] = 0x80 | ((k >> 6) & 0x3f);\n\t\tbuf[2] = 0x80 | (k & 0x3f);\n\t\tretval = 3;\n\t} else {\n\t\tbuf[0] = 0xf0 | (k >> 18);\n\t\tbuf[1] = 0x80 | ((k >> 12) & 0x3f);\n\t\tbuf[2] = 0x80 | ((k >> 6) & 0x3f);\n\t\tbuf[3] = 0x80 | (k & 0x3f);\n\t\tretval = 4;\n\t}\n\t/* UTF-8 has been restricted to max 4 bytes since RFC 3629 */\n\n\treturn retval;\n}\n/* }}} */\n\n/* {{{ unimap_bsearc_cmp\n * Binary search of unicode code points in unicode <--> charset mapping.\n * Returns the code point in the target charset (whose mapping table was given) or 0 if\n * the unicode code point is not in the table.\n */\nstatic inline unsigned char unimap_bsearch(const uni_to_enc *table, unsigned code_key_a, size_t num)\n{\n\tconst uni_to_enc *l = table,\n\t\t\t\t\t *h = &table[num-1],\n\t\t\t\t\t *m;\n\tunsigned short code_key;\n\n\t/* we have no mappings outside the BMP */\n\tif (code_key_a > 0xFFFFU)\n\t\treturn 0;\n\n\tcode_key = (unsigned short) code_key_a;\n\n\twhile (l <= h) {\n\t\tm = l + (h - l) / 2;\n\t\tif (code_key < m->un_code_point)\n\t\t\th = m - 1;\n\t\telse if (code_key > m->un_code_point)\n\t\t\tl = m + 1;\n\t\telse\n\t\t\treturn m->cs_code;\n\t}\n\treturn 0;\n}\n/* }}} */\n\n/* {{{ map_from_unicode */\nstatic inline zend_result map_from_unicode(unsigned code, enum entity_charset charset, unsigned *res)\n{\n\tunsigned char found;\n\tconst uni_to_enc *table;\n\tsize_t table_size;\n\n\tswitch (charset) {\n\tcase cs_8859_1:\n\t\t/* identity mapping of code points to unicode */\n\t\tif (code > 0xFF) {\n\t\t\treturn FAILURE;\n\t\t}\n\t\t*res = code;\n\t\tbreak;\n\n\tcase cs_8859_5:\n\t\tif (code <= 0xA0 || code == 0xAD /* soft hyphen */) {\n\t\t\t*res = code;\n\t\t} else if (code == 0x2116) {\n\t\t\t*res = 0xF0; /* numero sign */\n\t\t} else if (code == 0xA7) {\n\t\t\t*res = 0xFD; /* section sign */\n\t\t} else if (code >= 0x0401 && code <= 0x045F) {\n\t\t\tif (code == 0x040D || code == 0x0450 || code == 0x045D)\n\t\t\t\treturn FAILURE;\n\t\t\t*res = code - 0x360;\n\t\t} else {\n\t\t\treturn FAILURE;\n\t\t}\n\t\tbreak;\n\n\tcase cs_8859_15:\n\t\tif (code < 0xA4 || (code > 0xBE && code <= 0xFF)) {\n\t\t\t*res = code;\n\t\t} else { /* between A4 and 0xBE */\n\t\t\tfound = unimap_bsearch(unimap_iso885915,\n\t\t\t\tcode, sizeof(unimap_iso885915) / sizeof(*unimap_iso885915));\n\t\t\tif (found)\n\t\t\t\t*res = found;\n\t\t\telse\n\t\t\t\treturn FAILURE;\n\t\t}\n\t\tbreak;\n\n\tcase cs_cp1252:\n\t\tif (code <= 0x7F || (code >= 0xA0 && code <= 0xFF)) {\n\t\t\t*res = code;\n\t\t} else {\n\t\t\tfound = unimap_bsearch(unimap_win1252,\n\t\t\t\tcode, sizeof(unimap_win1252) / sizeof(*unimap_win1252));\n\t\t\tif (found)\n\t\t\t\t*res = found;\n\t\t\telse\n\t\t\t\treturn FAILURE;\n\t\t}\n\t\tbreak;\n\n\tcase cs_macroman:\n\t\tif (code == 0x7F)\n\t\t\treturn FAILURE;\n\t\ttable = unimap_macroman;\n\t\ttable_size = sizeof(unimap_macroman) / sizeof(*unimap_macroman);\n\t\tgoto table_over_7F;\n\tcase cs_cp1251:\n\t\ttable = unimap_win1251;\n\t\ttable_size = sizeof(unimap_win1251) / sizeof(*unimap_win1251);\n\t\tgoto table_over_7F;\n\tcase cs_koi8r:\n\t\ttable = unimap_koi8r;\n\t\ttable_size = sizeof(unimap_koi8r) / sizeof(*unimap_koi8r);\n\t\tgoto table_over_7F;\n\tcase cs_cp866:\n\t\ttable = unimap_cp866;\n\t\ttable_size = sizeof(unimap_cp866) / sizeof(*unimap_cp866);\n\ntable_over_7F:\n\t\tif (code <= 0x7F) {\n\t\t\t*res = code;\n\t\t} else {\n\t\t\tfound = unimap_bsearch(table, code, table_size);\n\t\t\tif (found)\n\t\t\t\t*res = found;\n\t\t\telse\n\t\t\t\treturn FAILURE;\n\t\t}\n\t\tbreak;\n\n\t/* from here on, only map the possible characters in the ASCII range.\n\t * to improve support here, it's a matter of building the unicode mappings.\n\t * See <http://www.unicode.org/Public/6.0.0/ucd/Unihan.zip> */\n\tcase cs_sjis:\n\tcase cs_eucjp:\n\t\t/* we interpret 0x5C as the Yen symbol. This is not universal.\n\t\t * See <http://www.w3.org/Submission/japanese-xml/#ambiguity_of_yen> */\n\t\tif (code >= 0x20 && code <= 0x7D) {\n\t\t\tif (code == 0x5C)\n\t\t\t\treturn FAILURE;\n\t\t\t*res = code;\n\t\t} else {\n\t\t\treturn FAILURE;\n\t\t}\n\t\tbreak;\n\n\tcase cs_big5:\n\tcase cs_big5hkscs:\n\tcase cs_gb2312:\n\t\tif (code >= 0x20 && code <= 0x7D) {\n\t\t\t*res = code;\n\t\t} else {\n\t\t\treturn FAILURE;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\treturn FAILURE;\n\t}\n\n\treturn SUCCESS;\n}\n/* }}} */\n\n/* {{{ */\nstatic inline void map_to_unicode(unsigned code, const enc_to_uni *table, unsigned *res)\n{\n\t/* only single byte encodings are currently supported; assumed code <= 0xFF */\n\t*res = table->inner[ENT_ENC_TO_UNI_STAGE1(code)]->uni_cp[ENT_ENC_TO_UNI_STAGE2(code)];\n}\n/* }}} */\n\n/* {{{ unicode_cp_is_allowed */\nstatic inline int unicode_cp_is_allowed(unsigned uni_cp, int document_type)\n{\n\t/* XML 1.0\t\t\t\tHTML 4.01\t\t\tHTML 5\n\t * 0x09..0x0A\t\t\t0x09..0x0A\t\t\t0x09..0x0A\n\t * 0x0D\t\t\t\t\t0x0D\t\t\t\t0x0C..0x0D\n\t * 0x0020..0xD7FF\t\t0x20..0x7E\t\t\t0x20..0x7E\n\t *\t\t\t\t\t\t0x00A0..0xD7FF\t\t0x00A0..0xD7FF\n\t * 0xE000..0xFFFD\t\t0xE000..0x10FFFF\t0xE000..0xFDCF\n\t * 0x010000..0x10FFFF\t\t\t\t\t\t0xFDF0..0x10FFFF (*)\n\t *\n\t * (*) exclude code points where ((code & 0xFFFF) >= 0xFFFE)\n\t *\n\t * References:\n\t * XML 1.0:   <http://www.w3.org/TR/REC-xml/#charsets>\n\t * HTML 4.01: <http://www.w3.org/TR/1999/PR-html40-19990824/sgml/sgmldecl.html>\n\t * HTML 5:    <http://dev.w3.org/html5/spec/Overview.html#preprocessing-the-input-stream>\n\t *\n\t * Not sure this is the relevant part for HTML 5, though. I opted to\n\t * disallow the characters that would result in a parse error when\n\t * preprocessing of the input stream. See also section 8.1.3.\n\t *\n\t * It's unclear if XHTML 1.0 allows C1 characters. I'll opt to apply to\n\t * XHTML 1.0 the same rules as for XML 1.0.\n\t * See <http://cmsmcq.com/2007/C1.xml>.\n\t */\n\n\tswitch (document_type) {\n\tcase ENT_HTML_DOC_HTML401:\n\t\treturn (uni_cp >= 0x20 && uni_cp <= 0x7E) ||\n\t\t\t(uni_cp == 0x0A || uni_cp == 0x09 || uni_cp == 0x0D) ||\n\t\t\t(uni_cp >= 0xA0 && uni_cp <= 0xD7FF) ||\n\t\t\t(uni_cp >= 0xE000 && uni_cp <= 0x10FFFF);\n\tcase ENT_HTML_DOC_HTML5:\n\t\treturn (uni_cp >= 0x20 && uni_cp <= 0x7E) ||\n\t\t\t(uni_cp >= 0x09 && uni_cp <= 0x0D && uni_cp != 0x0B) || /* form feed U+0C allowed */\n\t\t\t(uni_cp >= 0xA0 && uni_cp <= 0xD7FF) ||\n\t\t\t(uni_cp >= 0xE000 && uni_cp <= 0x10FFFF &&\n\t\t\t\t((uni_cp & 0xFFFF) < 0xFFFE) && /* last two of each plane (nonchars) disallowed */\n\t\t\t\t(uni_cp < 0xFDD0 || uni_cp > 0xFDEF)); /* U+FDD0-U+FDEF (nonchars) disallowed */\n\tcase ENT_HTML_DOC_XHTML:\n\tcase ENT_HTML_DOC_XML1:\n\t\treturn (uni_cp >= 0x20 && uni_cp <= 0xD7FF) ||\n\t\t\t(uni_cp == 0x0A || uni_cp == 0x09 || uni_cp == 0x0D) ||\n\t\t\t(uni_cp >= 0xE000 && uni_cp <= 0x10FFFF && uni_cp != 0xFFFE && uni_cp != 0xFFFF);\n\tdefault:\n\t\treturn 1;\n\t}\n}\n/* }}} */\n\n/* {{{ unicode_cp_is_allowed */\nstatic inline int numeric_entity_is_allowed(unsigned uni_cp, int document_type)\n{\n\t/* less restrictive than unicode_cp_is_allowed */\n\tswitch (document_type) {\n\tcase ENT_HTML_DOC_HTML401:\n\t\t/* all non-SGML characters (those marked with UNUSED in DESCSET) should be\n\t\t * representable with numeric entities */\n\t\treturn uni_cp <= 0x10FFFF;\n\tcase ENT_HTML_DOC_HTML5:\n\t\t/* 8.1.4. The numeric character reference forms described above are allowed to\n\t\t * reference any Unicode code point other than U+0000, U+000D, permanently\n\t\t * undefined Unicode characters (noncharacters), and control characters other\n\t\t * than space characters (U+0009, U+000A, U+000C and U+000D) */\n\t\t/* seems to allow surrogate characters, then */\n\t\treturn (uni_cp >= 0x20 && uni_cp <= 0x7E) ||\n\t\t\t(uni_cp >= 0x09 && uni_cp <= 0x0C && uni_cp != 0x0B) || /* form feed U+0C allowed, but not U+0D */\n\t\t\t(uni_cp >= 0xA0 && uni_cp <= 0x10FFFF &&\n\t\t\t\t((uni_cp & 0xFFFF) < 0xFFFE) && /* last two of each plane (nonchars) disallowed */\n\t\t\t\t(uni_cp < 0xFDD0 || uni_cp > 0xFDEF)); /* U+FDD0-U+FDEF (nonchars) disallowed */\n\tcase ENT_HTML_DOC_XHTML:\n\tcase ENT_HTML_DOC_XML1:\n\t\t/* OTOH, XML 1.0 requires \"character references to match the production for Char\n\t\t * See <http://www.w3.org/TR/REC-xml/#NT-CharRef> */\n\t\treturn unicode_cp_is_allowed(uni_cp, document_type);\n\tdefault:\n\t\treturn 1;\n\t}\n}\n/* }}} */\n\n/* {{{ process_numeric_entity\n * Auxiliary function to traverse_for_entities.\n * On input, *buf should point to the first character after # and on output, it's the last\n * byte read, no matter if there was success or insuccess.\n */\nstatic inline zend_result process_numeric_entity(const char **buf, unsigned *code_point)\n{\n\tzend_long code_l;\n\tint hexadecimal = (**buf == 'x' || **buf == 'X'); /* TODO: XML apparently disallows \"X\" */\n\tchar *endptr;\n\n\tif (hexadecimal)\n\t\t(*buf)++;\n\n\t/* strtol allows whitespace and other stuff in the beginning\n\t\t* we're not interested */\n\tif ((hexadecimal && !isxdigit(**buf)) ||\n\t\t\t(!hexadecimal && !isdigit(**buf))) {\n\t\treturn FAILURE;\n\t}\n\n\tcode_l = ZEND_STRTOL(*buf, &endptr, hexadecimal ? 16 : 10);\n\t/* we're guaranteed there were valid digits, so *endptr > buf */\n\t*buf = endptr;\n\n\tif (**buf != ';')\n\t\treturn FAILURE;\n\n\t/* many more are invalid, but that depends on whether it's HTML\n\t * (and which version) or XML. */\n\tif (code_l > Z_L(0x10FFFF))\n\t\treturn FAILURE;\n\n\tif (code_point != NULL)\n\t\t*code_point = (unsigned)code_l;\n\n\treturn SUCCESS;\n}\n/* }}} */\n\n/* {{{ process_named_entity */\nstatic inline zend_result process_named_entity_html(const char **buf, const char **start, size_t *length)\n{\n\t*start = *buf;\n\n\t/* \"&\" is represented by a 0x26 in all supported encodings. That means\n\t * the byte after represents a character or is the leading byte of a\n\t * sequence of 8-bit code units. If in the ranges below, it represents\n\t * necessarily an alpha character because none of the supported encodings\n\t * has an overlap with ASCII in the leading byte (only on the second one) */\n\twhile ((**buf >= 'a' && **buf <= 'z') ||\n\t\t\t(**buf >= 'A' && **buf <= 'Z') ||\n\t\t\t(**buf >= '0' && **buf <= '9')) {\n\t\t(*buf)++;\n\t}\n\n\tif (**buf != ';')\n\t\treturn FAILURE;\n\n\t/* cast to size_t OK as the quantity is always non-negative */\n\t*length = *buf - *start;\n\n\tif (*length == 0)\n\t\treturn FAILURE;\n\n\treturn SUCCESS;\n}\n/* }}} */\n\n/* {{{ resolve_named_entity_html */\nstatic zend_result resolve_named_entity_html(const char *start, size_t length, const entity_ht *ht, unsigned *uni_cp1, unsigned *uni_cp2)\n{\n\tconst entity_cp_map *s;\n\tzend_ulong hash = zend_inline_hash_func(start, length);\n\n\ts = ht->buckets[hash % ht->num_elems];\n\twhile (s->entity) {\n\t\tif (s->entity_len == length) {\n\t\t\tif (memcmp(start, s->entity, length) == 0) {\n\t\t\t\t*uni_cp1 = s->codepoint1;\n\t\t\t\t*uni_cp2 = s->codepoint2;\n\t\t\t\treturn SUCCESS;\n\t\t\t}\n\t\t}\n\t\ts++;\n\t}\n\treturn FAILURE;\n}\n/* }}} */\n\nstatic inline size_t write_octet_sequence(unsigned char *buf, enum entity_charset charset, unsigned code) {\n\t/* code is not necessarily a unicode code point */\n\tswitch (charset) {\n\tcase cs_utf_8:\n\t\treturn php_utf32_utf8(buf, code);\n\n\tcase cs_8859_1:\n\tcase cs_cp1252:\n\tcase cs_8859_15:\n\tcase cs_koi8r:\n\tcase cs_cp1251:\n\tcase cs_8859_5:\n\tcase cs_cp866:\n\tcase cs_macroman:\n\t\t/* single byte stuff */\n\t\t*buf = code;\n\t\treturn 1;\n\n\tcase cs_big5:\n\tcase cs_big5hkscs:\n\tcase cs_sjis:\n\tcase cs_gb2312:\n\t\t/* we don't have complete unicode mappings for these yet in entity_decode,\n\t\t * and we opt to pass through the octet sequences for these in htmlentities\n\t\t * instead of converting to an int and then converting back. */\n#if 0\n\t\treturn php_mb2_int_to_char(buf, code);\n#else\n\t\tZEND_ASSERT(code <= 0xFFU);\n\t\t*buf = code;\n\t\treturn 1;\n#endif\n\n\tcase cs_eucjp:\n#if 0 /* idem */\n\t\treturn php_mb2_int_to_char(buf, code);\n#else\n\t\tZEND_ASSERT(code <= 0xFFU);\n\t\t*buf = code;\n\t\treturn 1;\n#endif\n\n\tdefault:\n\t\tassert(0);\n\t\treturn 0;\n\t}\n}\n\n/* {{{ traverse_for_entities\n * Auxiliary function to php_unescape_html_entities().\n * - The argument \"all\" determines if all numeric entities are decode or only those\n *   that correspond to quotes (depending on quote_style).\n */\n/* maximum expansion (factor 1.2) for HTML 5 with &nGt; and &nLt; */\n/* +2 is 1 because of rest (probably unnecessary), 1 because of terminating 0 */\n#define TRAVERSE_FOR_ENTITIES_EXPAND_SIZE(oldlen) ((oldlen) + (oldlen) / 5 + 2)\nstatic void traverse_for_entities(\n\tconst zend_string *input,\n\tzend_string *output, /* should have allocated TRAVERSE_FOR_ENTITIES_EXPAND_SIZE(olden) */\n\tconst int all,\n\tconst int flags,\n\tconst entity_ht *inv_map,\n\tconst enum entity_charset charset)\n{\n\tconst char *current_ptr = ZSTR_VAL(input);\n\tconst char *input_end   = current_ptr + ZSTR_LEN(input); /* terminator address */\n\tchar *output_ptr\t\t= ZSTR_VAL(output);\n\tconst int doctype\t   = flags & ENT_HTML_DOC_TYPE_MASK;\n\n\twhile (current_ptr < input_end) {\n\t\tconst char *ampersand_ptr = memchr(current_ptr, '&', input_end - current_ptr);\n\t\tif (!ampersand_ptr) {\n\t\t\tconst size_t tail_len = input_end - current_ptr;\n\t\t\tif (tail_len > 0) {\n\t\t\t\tmemcpy(output_ptr, current_ptr, tail_len);\n\t\t\t\toutput_ptr += tail_len;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Copy everything up to the found '&' */\n\t\tconst size_t chunk_len = ampersand_ptr - current_ptr;\n\t\tif (chunk_len > 0) {\n\t\t\tmemcpy(output_ptr, current_ptr, chunk_len);\n\t\t\toutput_ptr += chunk_len;\n\t\t}\n\n\t\t/* Now current_ptr points to the '&' character. */\n\t\tcurrent_ptr = ampersand_ptr;\n\n\t\t/* If there are less than 4 bytes remaining, there isn't enough for an entity - \n\t\t * copy '&' as a normal character. */\n\t\tif (input_end - current_ptr < 4) {\n\t\t\tconst size_t remaining = input_end - current_ptr;\n\t\t\tmemcpy(output_ptr, current_ptr, remaining);\n\t\t\toutput_ptr += remaining;\n\t\t\tbreak;\n\t\t}\n\n\t\tunsigned code = 0, code2 = 0;\n\t\tconst char *entity_end_ptr = NULL;\n\n\t\tif (current_ptr[1] == '#') {\n\t\t\t/* Processing numeric entity */\n\t\t\tconst char *num_start = current_ptr + 2;\n\t\t\tentity_end_ptr = num_start;\n\t\t\tif (process_numeric_entity(&entity_end_ptr, &code) == FAILURE) {\n\t\t\t\tgoto invalid_incomplete_entity;\n\t\t\t}\n\t\t\tif (!all && (code > 63U || stage3_table_be_apos_00000[code].data.ent.entity == NULL)) {\n\t\t\t\t/* If we're in htmlspecialchars_decode, we're only decoding entities\n\t\t\t\t * that represent &, <, >, \" and '. Is this one of them? */\n\t\t\t\tgoto invalid_incomplete_entity;\n\t\t\t} else if (!unicode_cp_is_allowed(code, doctype) ||\n\t\t\t\t\t   (doctype == ENT_HTML_DOC_HTML5 && code == 0x0D)) {\n\t\t\t\t/* are we allowed to decode this entity in this document type?\n\t\t\t\t * HTML 5 is the only that has a character that cannot be used in\n\t\t\t\t * a numeric entity but is allowed literally (U+000D). The\n\t\t\t\t * unoptimized version would be ... || !numeric_entity_is_allowed(code) */\n\t\t\t\tgoto invalid_incomplete_entity;\n\t\t\t}\n\t\t} else {\n\t\t\t/* Processing named entity */\n\t\t\tconst char *name_start = current_ptr + 1;\n\t\t\t/* Search for ';' */\n\t\t\tconst size_t max_search_len = MIN(LONGEST_ENTITY_LENGTH + 1, input_end - name_start);\n\t\t\tconst char *semi_colon_ptr = memchr(name_start, ';', max_search_len);\n\t\t\tif (!semi_colon_ptr) {\n\t\t\t\tgoto invalid_incomplete_entity;\n\t\t\t} else {\n\t\t\t\tconst size_t name_len = semi_colon_ptr - name_start;\n\t\t\t\tif (name_len == 0) {\n\t\t\t\t\tgoto invalid_incomplete_entity;\n\t\t\t\t} else {\n\t\t\t\t\tif (resolve_named_entity_html(name_start, name_len, inv_map, &code, &code2) == FAILURE) {\n\t\t\t\t\t\tif (doctype == ENT_HTML_DOC_XHTML && name_len == 4 &&\n\t\t\t\t\t\t\tname_start[0] == 'a' && name_start[1] == 'p' &&\n\t\t\t\t\t\t\tname_start[2] == 'o' && name_start[3] == 's')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/* uses html4 inv_map, which doesn't include apos;. This is a\n\t\t\t\t\t\t\t * hack to support it */\n\t\t\t\t\t\t\tcode = (unsigned)'\\'';\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tgoto invalid_incomplete_entity;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tentity_end_ptr = semi_colon_ptr;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* At this stage the entity_end_ptr should be always set. */\n\t\tZEND_ASSERT(entity_end_ptr != NULL);\n\n\t\t/* Check if quotes are allowed for entities representing ' or \" */\n\t\tif ((code == '\\'' && !(flags & ENT_HTML_QUOTE_SINGLE)) ||\n\t\t\t(code == '\"'  && !(flags & ENT_HTML_QUOTE_DOUBLE)))\n\t\t{\n\t\t\tgoto invalid_complete_entity;\n\t\t}\n\n\t\t/* UTF-8 doesn't need mapping (ISO-8859-1 doesn't either, but\n\t\t * the call is needed to ensure the codepoint <= U+00FF)  */\n\t\tif (charset != cs_utf_8) {\n\t\t\t/* replace unicode code point */\n\t\t\tif (map_from_unicode(code, charset, &code) == FAILURE || code2 != 0) {\n\t\t\t\tgoto invalid_complete_entity;\n\t\t\t}\n\t\t}\n\n\t\t/* Write the parsed entity into the output buffer */\n\t\toutput_ptr += write_octet_sequence((unsigned char*)output_ptr, charset, code);\n\t\tif (code2) {\n\t\t\toutput_ptr += write_octet_sequence((unsigned char*)output_ptr, charset, code2);\n\t\t}\n\t\t/* Move current_ptr past the semicolon */\n\t\tcurrent_ptr = entity_end_ptr + 1;\n\t\tcontinue;\n\ninvalid_incomplete_entity:\n\t\t/* If the entity is invalid at parse stage or entity_end_ptr was never found, copy '&' as normal */\n\t\t*output_ptr++ = *current_ptr++;\n\t\tcontinue;\n\ninvalid_complete_entity:\n\t\t/* If the entity became invalid after we found entity_end_ptr */\n\t\tif (entity_end_ptr) {\n\t\t\tconst size_t len = entity_end_ptr - current_ptr;\n\t\t\tmemcpy(output_ptr, current_ptr, len);\n\t\t\toutput_ptr += len;\n\t\t\tcurrent_ptr = entity_end_ptr;\n\t\t} else {\n\t\t\t*output_ptr++ = *current_ptr++;\n\t\t}\n\t\tcontinue;\n\t}\n\n\t*output_ptr = '\\0';\n\tZSTR_LEN(output) = (size_t)(output_ptr - ZSTR_VAL(output));\n}\n/* }}} */\n\n/* {{{ unescape_inverse_map */\nstatic const entity_ht *unescape_inverse_map(int all, int flags)\n{\n\tint document_type = flags & ENT_HTML_DOC_TYPE_MASK;\n\n\tif (all) {\n\t\tswitch (document_type) {\n\t\tcase ENT_HTML_DOC_HTML401:\n\t\tcase ENT_HTML_DOC_XHTML: /* but watch out for &apos;...*/\n\t\t\treturn &ent_ht_html4;\n\t\tcase ENT_HTML_DOC_HTML5:\n\t\t\treturn &ent_ht_html5;\n\t\tdefault:\n\t\t\treturn &ent_ht_be_apos;\n\t\t}\n\t} else {\n\t\tswitch (document_type) {\n\t\tcase ENT_HTML_DOC_HTML401:\n\t\t\treturn &ent_ht_be_noapos;\n\t\tdefault:\n\t\t\treturn &ent_ht_be_apos;\n\t\t}\n\t}\n}\n/* }}} */\n\n/* {{{ determine_entity_table\n * Entity table to use. Note that entity tables are defined in terms of\n * unicode code points */\nstatic entity_table_opt determine_entity_table(int all, int doctype)\n{\n\tentity_table_opt retval = {0};\n\n\tassert(!(doctype == ENT_HTML_DOC_XML1 && all));\n\n\tif (all) {\n\t\tretval.ms_table = (doctype == ENT_HTML_DOC_HTML5) ?\n\t\t\tentity_ms_table_html5 : entity_ms_table_html4;\n\t} else {\n\t\tretval.table = (doctype == ENT_HTML_DOC_HTML401) ?\n\t\t\tstage3_table_be_noapos_00000 : stage3_table_be_apos_00000;\n\t}\n\treturn retval;\n}\n/* }}} */\n\n/* {{{ php_unescape_html_entities\n * The parameter \"all\" should be true to decode all possible entities, false to decode\n * only the basic ones, i.e., those in basic_entities_ex + the numeric entities\n * that correspond to quotes.\n */\nPHPAPI zend_string *php_unescape_html_entities(zend_string *str, int all, int flags, const char *hint_charset)\n{\n\tzend_string *ret;\n\tenum entity_charset charset;\n\tconst entity_ht *inverse_map;\n\tsize_t new_size;\n\n\tif (!memchr(ZSTR_VAL(str), '&', ZSTR_LEN(str))) {\n\t\treturn zend_string_copy(str);\n\t}\n\n\tif (all) {\n\t\tcharset = determine_charset(hint_charset, /* quiet */ 0);\n\t} else {\n\t\tcharset = cs_8859_1; /* charset shouldn't matter, use ISO-8859-1 for performance */\n\t}\n\n\t/* don't use LIMIT_ALL! */\n\n\tnew_size = TRAVERSE_FOR_ENTITIES_EXPAND_SIZE(ZSTR_LEN(str));\n\tif (ZSTR_LEN(str) > new_size) {\n\t\t/* overflow, refuse to do anything */\n\t\treturn zend_string_copy(str);\n\t}\n\n\tret = zend_string_alloc(new_size, 0);\n\n\tinverse_map = unescape_inverse_map(all, flags);\n\n\t/* replace numeric entities */\n\ttraverse_for_entities(str, ret, all, flags, inverse_map, charset);\n\n\treturn ret;\n}\n/* }}} */\n\nPHPAPI zend_string *php_escape_html_entities(const unsigned char *old, size_t oldlen, int all, int flags, const char *hint_charset)\n{\n\treturn php_escape_html_entities_ex(old, oldlen, all, flags, hint_charset, 1, /* quiet */ 0);\n}\n\n/* {{{ find_entity_for_char */\nstatic inline void find_entity_for_char(\n\tunsigned int k,\n\tenum entity_charset charset,\n\tconst entity_stage1_row *table,\n\tconst unsigned char **entity,\n\tsize_t *entity_len,\n\tconst unsigned char *old,\n\tsize_t oldlen,\n\tsize_t *cursor)\n{\n\tunsigned stage1_idx = ENT_STAGE1_INDEX(k);\n\tconst entity_stage3_row *c;\n\n\tif (stage1_idx > 0x1D) {\n\t\t*entity     = NULL;\n\t\t*entity_len = 0;\n\t\treturn;\n\t}\n\n\tc = &table[stage1_idx][ENT_STAGE2_INDEX(k)][ENT_STAGE3_INDEX(k)];\n\n\tif (!c->ambiguous) {\n\t\t*entity     = (const unsigned char *)c->data.ent.entity;\n\t\t*entity_len = c->data.ent.entity_len;\n\t} else {\n\t\t/* peek at next char */\n\t\tsize_t cursor_before = *cursor;\n\t\tzend_result status = SUCCESS;\n\t\tunsigned next_char;\n\n\t\tif (!(*cursor < oldlen))\n\t\t\tgoto no_suitable_2nd;\n\n\t\tnext_char = get_next_char(charset, old, oldlen, cursor, &status);\n\n\t\tif (status == FAILURE)\n\t\t\tgoto no_suitable_2nd;\n\n\t\t{\n\t\t\tconst entity_multicodepoint_row *s, *e;\n\n\t\t\ts = &c->data.multicodepoint_table[1];\n\t\t\te = s - 1 + c->data.multicodepoint_table[0].leading_entry.size;\n\t\t\t/* we could do a binary search but it's not worth it since we have\n\t\t\t * at most two entries... */\n\t\t\tfor ( ; s <= e; s++) {\n\t\t\t\tif (s->normal_entry.second_cp == next_char) {\n\t\t\t\t\t*entity     = (const unsigned char *) s->normal_entry.entity;\n\t\t\t\t\t*entity_len = s->normal_entry.entity_len;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\nno_suitable_2nd:\n\t\t*cursor = cursor_before;\n\t\t*entity = (const unsigned char *)\n\t\t\tc->data.multicodepoint_table[0].leading_entry.default_entity;\n\t\t*entity_len = c->data.multicodepoint_table[0].leading_entry.default_entity_len;\n\t}\n}\n/* }}} */\n\n/* {{{ find_entity_for_char_basic */\nstatic inline void find_entity_for_char_basic(\n\tunsigned int k,\n\tconst entity_stage3_row *table,\n\tconst unsigned char **entity,\n\tsize_t *entity_len)\n{\n\tif (k >= 64U) {\n\t\t*entity     = NULL;\n\t\t*entity_len = 0;\n\t\treturn;\n\t}\n\n\t*entity     = (const unsigned char *) table[k].data.ent.entity;\n\t*entity_len = table[k].data.ent.entity_len;\n}\n/* }}} */\n\n/* {{{ php_escape_html_entities */\nPHPAPI zend_string *php_escape_html_entities_ex(const unsigned char *old, size_t oldlen, int all, int flags, const char *hint_charset, bool double_encode, bool quiet)\n{\n\tsize_t cursor, maxlen, len;\n\tzend_string *replaced;\n\tenum entity_charset charset = determine_charset(hint_charset, quiet);\n\tint doctype = flags & ENT_HTML_DOC_TYPE_MASK;\n\tentity_table_opt entity_table;\n\tconst enc_to_uni *to_uni_table = NULL;\n\tconst entity_ht *inv_map = NULL; /* used for !double_encode */\n\t/* only used if flags includes ENT_HTML_IGNORE_ERRORS or ENT_HTML_SUBSTITUTE_DISALLOWED_CHARS */\n\tconst unsigned char *replacement = NULL;\n\tsize_t replacement_len = 0;\n\n\tif (all) { /* replace with all named entities */\n\t\tif (!quiet && CHARSET_PARTIAL_SUPPORT(charset)) {\n\t\t\tphp_error_docref(NULL, E_NOTICE, \"Only basic entities \"\n\t\t\t\t\"substitution is supported for multi-byte encodings other than UTF-8; \"\n\t\t\t\t\"functionality is equivalent to htmlspecialchars\");\n\t\t}\n\t\tLIMIT_ALL(all, doctype, charset);\n\t}\n\tentity_table = determine_entity_table(all, doctype);\n\tif (all && !CHARSET_UNICODE_COMPAT(charset)) {\n\t\tto_uni_table = enc_to_uni_index[charset];\n\t}\n\n\tif (!double_encode) {\n\t\t/* first arg is 1 because we want to identify valid named entities\n\t\t * even if we are only encoding the basic ones */\n\t\tinv_map = unescape_inverse_map(1, flags);\n\t}\n\n\tif (flags & (ENT_HTML_SUBSTITUTE_ERRORS | ENT_HTML_SUBSTITUTE_DISALLOWED_CHARS)) {\n\t\tif (charset == cs_utf_8) {\n\t\t\treplacement = (const unsigned char*)\"\\xEF\\xBF\\xBD\";\n\t\t\treplacement_len = sizeof(\"\\xEF\\xBF\\xBD\") - 1;\n\t\t} else {\n\t\t\treplacement = (const unsigned char*)\"&#xFFFD;\";\n\t\t\treplacement_len = sizeof(\"&#xFFFD;\") - 1;\n\t\t}\n\t}\n\n\t/* initial estimate */\n\tif (oldlen < 64) {\n\t\tmaxlen = 128;\n\t} else {\n\t\tmaxlen = zend_safe_addmult(oldlen, 2, 0, \"html_entities\");\n\t}\n\n\treplaced = zend_string_alloc(maxlen, 0);\n\tlen = 0;\n\tcursor = 0;\n\twhile (cursor < oldlen) {\n\t\tconst unsigned char *mbsequence = NULL;\n\t\tsize_t mbseqlen\t\t\t\t\t= 0,\n\t\t       cursor_before\t\t\t= cursor;\n\t\tzend_result status\t\t\t\t= SUCCESS;\n\t\tunsigned int this_char\t\t\t= get_next_char(charset, old, oldlen, &cursor, &status);\n\n\t\t/* guarantee we have at least 40 bytes to write.\n\t\t * In HTML5, entities may take up to 33 bytes */\n\t\tif (len > maxlen - 40) { /* maxlen can never be smaller than 128 */\n\t\t\treplaced = zend_string_safe_realloc(replaced, maxlen, 1, 128, 0);\n\t\t\tmaxlen += 128;\n\t\t}\n\n\t\tif (status == FAILURE) {\n\t\t\t/* invalid MB sequence */\n\t\t\tif (flags & ENT_HTML_IGNORE_ERRORS) {\n\t\t\t\tcontinue;\n\t\t\t} else if (flags & ENT_HTML_SUBSTITUTE_ERRORS) {\n\t\t\t\tmemcpy(&ZSTR_VAL(replaced)[len], replacement, replacement_len);\n\t\t\t\tlen += replacement_len;\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tzend_string_efree(replaced);\n\t\t\t\treturn ZSTR_EMPTY_ALLOC();\n\t\t\t}\n\t\t} else { /* SUCCESS */\n\t\t\tmbsequence = &old[cursor_before];\n\t\t\tmbseqlen = cursor - cursor_before;\n\t\t}\n\n\t\tif (this_char != '&') { /* no entity on this position */\n\t\t\tconst unsigned char *rep\t= NULL;\n\t\t\tsize_t\t\t\t\trep_len\t= 0;\n\n\t\t\tif (((this_char == '\\'' && !(flags & ENT_HTML_QUOTE_SINGLE)) ||\n\t\t\t\t\t(this_char == '\"' && !(flags & ENT_HTML_QUOTE_DOUBLE))))\n\t\t\t\tgoto pass_char_through;\n\n\t\t\tif (all) { /* false that CHARSET_PARTIAL_SUPPORT(charset) */\n\t\t\t\tif (to_uni_table != NULL) {\n\t\t\t\t\t/* !CHARSET_UNICODE_COMPAT therefore not UTF-8; since UTF-8\n\t\t\t\t\t * is the only multibyte encoding with !CHARSET_PARTIAL_SUPPORT,\n\t\t\t\t\t * we're using a single byte encoding */\n\t\t\t\t\tmap_to_unicode(this_char, to_uni_table, &this_char);\n\t\t\t\t\tif (this_char == 0xFFFF) /* no mapping; pass through */\n\t\t\t\t\t\tgoto pass_char_through;\n\t\t\t\t}\n\t\t\t\t/* the cursor may advance */\n\t\t\t\tfind_entity_for_char(this_char, charset, entity_table.ms_table, &rep,\n\t\t\t\t\t&rep_len, old, oldlen, &cursor);\n\t\t\t} else {\n\t\t\t\tfind_entity_for_char_basic(this_char, entity_table.table, &rep, &rep_len);\n\t\t\t}\n\n\t\t\tif (rep != NULL) {\n\t\t\t\tZSTR_VAL(replaced)[len++] = '&';\n\t\t\t\tmemcpy(&ZSTR_VAL(replaced)[len], rep, rep_len);\n\t\t\t\tlen += rep_len;\n\t\t\t\tZSTR_VAL(replaced)[len++] = ';';\n\t\t\t} else {\n\t\t\t\t/* we did not find an entity for this char.\n\t\t\t\t * check for its validity, if its valid pass it unchanged */\n\t\t\t\tif (flags & ENT_HTML_SUBSTITUTE_DISALLOWED_CHARS) {\n\t\t\t\t\tif (CHARSET_UNICODE_COMPAT(charset)) {\n\t\t\t\t\t\tif (!unicode_cp_is_allowed(this_char, doctype)) {\n\t\t\t\t\t\t\tmbsequence = replacement;\n\t\t\t\t\t\t\tmbseqlen = replacement_len;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (to_uni_table) {\n\t\t\t\t\t\tif (!all) /* otherwise we already did this */\n\t\t\t\t\t\t\tmap_to_unicode(this_char, to_uni_table, &this_char);\n\t\t\t\t\t\tif (!unicode_cp_is_allowed(this_char, doctype)) {\n\t\t\t\t\t\t\tmbsequence = replacement;\n\t\t\t\t\t\t\tmbseqlen = replacement_len;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* not a unicode code point, unless, coincidentally, it's in\n\t\t\t\t\t\t * the 0x20..0x7D range (except 0x5C in sjis). We know nothing\n\t\t\t\t\t\t * about other code points, because we have no tables. Since\n\t\t\t\t\t\t * Unicode code points in that range are not disallowed in any\n\t\t\t\t\t\t * document type, we could do nothing. However, conversion\n\t\t\t\t\t\t * tables frequently map 0x00-0x1F to the respective C0 code\n\t\t\t\t\t\t * points. Let's play it safe and admit that's the case */\n\t\t\t\t\t\tif (this_char <= 0x7D &&\n\t\t\t\t\t\t\t\t!unicode_cp_is_allowed(this_char, doctype)) {\n\t\t\t\t\t\t\tmbsequence = replacement;\n\t\t\t\t\t\t\tmbseqlen = replacement_len;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\npass_char_through:\n\t\t\t\tif (mbseqlen > 1) {\n\t\t\t\t\tmemcpy(ZSTR_VAL(replaced) + len, mbsequence, mbseqlen);\n\t\t\t\t\tlen += mbseqlen;\n\t\t\t\t} else {\n\t\t\t\t\tZSTR_VAL(replaced)[len++] = mbsequence[0];\n\t\t\t\t}\n\t\t\t}\n\t\t} else { /* this_char == '&' */\n\t\t\tif (double_encode) {\nencode_amp:\n\t\t\t\tmemcpy(&ZSTR_VAL(replaced)[len], \"&amp;\", sizeof(\"&amp;\") - 1);\n\t\t\t\tlen += sizeof(\"&amp;\") - 1;\n\t\t\t} else { /* no double encode */\n\t\t\t\t/* check if entity is valid */\n\t\t\t\tsize_t ent_len; /* not counting & or ; */\n\t\t\t\t/* peek at next char */\n\t\t\t\tif (old[cursor] == '#') { /* numeric entity */\n\t\t\t\t\tunsigned code_point;\n\t\t\t\t\tint valid;\n\t\t\t\t\tchar *pos = (char*)&old[cursor+1];\n\t\t\t\t\tvalid = process_numeric_entity((const char **)&pos, &code_point);\n\t\t\t\t\tif (valid == FAILURE)\n\t\t\t\t\t\tgoto encode_amp;\n\t\t\t\t\tif (flags & ENT_HTML_SUBSTITUTE_DISALLOWED_CHARS) {\n\t\t\t\t\t\tif (!numeric_entity_is_allowed(code_point, doctype))\n\t\t\t\t\t\t\tgoto encode_amp;\n\t\t\t\t\t}\n\t\t\t\t\tent_len = pos - (char*)&old[cursor];\n\t\t\t\t} else { /* named entity */\n\t\t\t\t\t/* check for vality of named entity */\n\t\t\t\t\tconst char *start = (const char *) &old[cursor],\n\t\t\t\t\t\t\t   *next = start;\n\t\t\t\t\tunsigned   dummy1, dummy2;\n\n\t\t\t\t\tif (process_named_entity_html(&next, &start, &ent_len) == FAILURE)\n\t\t\t\t\t\tgoto encode_amp;\n\t\t\t\t\tif (resolve_named_entity_html(start, ent_len, inv_map, &dummy1, &dummy2) == FAILURE) {\n\t\t\t\t\t\tif (!(doctype == ENT_HTML_DOC_XHTML && ent_len == 4 && start[0] == 'a'\n\t\t\t\t\t\t\t\t\t&& start[1] == 'p' && start[2] == 'o' && start[3] == 's')) {\n\t\t\t\t\t\t\t/* uses html4 inv_map, which doesn't include apos;. This is a\n\t\t\t\t\t\t\t * hack to support it */\n\t\t\t\t\t\t\tgoto encode_amp;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/* checks passed; copy entity to result */\n\t\t\t\t/* entity size is unbounded, we may need more memory */\n\t\t\t\t/* at this point maxlen - len >= 40 */\n\t\t\t\tif (maxlen - len < ent_len + 2 /* & and ; */) {\n\t\t\t\t\t/* ent_len < oldlen, which is certainly <= SIZE_MAX/2 */\n\t\t\t\t\treplaced = zend_string_safe_realloc(replaced, maxlen, 1, ent_len + 128, 0);\n\t\t\t\t\tmaxlen += ent_len + 128;\n\t\t\t\t}\n\t\t\t\tZSTR_VAL(replaced)[len++] = '&';\n\t\t\t\tmemcpy(&ZSTR_VAL(replaced)[len], &old[cursor], ent_len);\n\t\t\t\tlen += ent_len;\n\t\t\t\tZSTR_VAL(replaced)[len++] = ';';\n\t\t\t\tcursor += ent_len + 1;\n\t\t\t}\n\t\t}\n\t}\n\tZSTR_VAL(replaced)[len] = '\\0';\n\tZSTR_LEN(replaced) = len;\n\n\treturn replaced;\n}\n/* }}} */\n\n/* {{{ php_html_entities */\nstatic void php_html_entities(INTERNAL_FUNCTION_PARAMETERS, int all)\n{\n\tzend_string *str, *hint_charset = NULL;\n\tzend_long flags = ENT_QUOTES|ENT_SUBSTITUTE;\n\tzend_string *replaced;\n\tbool double_encode = 1;\n\n\tZEND_PARSE_PARAMETERS_START(1, 4)\n\t\tZ_PARAM_STR(str)\n\t\tZ_PARAM_OPTIONAL\n\t\tZ_PARAM_LONG(flags)\n\t\tZ_PARAM_STR_OR_NULL(hint_charset)\n\t\tZ_PARAM_BOOL(double_encode);\n\tZEND_PARSE_PARAMETERS_END();\n\n\tif (ZSTR_LEN(str) == 0) {\n\t\tRETURN_EMPTY_STRING();\n\t}\n\treplaced = php_escape_html_entities_ex(\n\t\t(unsigned char*)ZSTR_VAL(str), ZSTR_LEN(str), all, (int) flags,\n\t\thint_charset ? ZSTR_VAL(hint_charset) : NULL, double_encode, /* quiet */ 0);\n\tRETVAL_STR(replaced);\n}\n/* }}} */\n\n/* {{{ Convert special characters to HTML entities */\nPHP_FUNCTION(htmlspecialchars)\n{\n\tphp_html_entities(INTERNAL_FUNCTION_PARAM_PASSTHRU, 0);\n}\n/* }}} */\n\n/* {{{ Convert special HTML entities back to characters */\nPHP_FUNCTION(htmlspecialchars_decode)\n{\n\tzend_string *str;\n\tzend_long quote_style = ENT_QUOTES|ENT_SUBSTITUTE;\n\tzend_string *replaced;\n\n\tZEND_PARSE_PARAMETERS_START(1, 2)\n\t\tZ_PARAM_STR(str)\n\t\tZ_PARAM_OPTIONAL\n\t\tZ_PARAM_LONG(quote_style)\n\tZEND_PARSE_PARAMETERS_END();\n\n\treplaced = php_unescape_html_entities(str, 0 /*!all*/, (int)quote_style, NULL);\n\tRETURN_STR(replaced);\n}\n/* }}} */\n\n/* {{{ Convert all HTML entities to their applicable characters */\nPHP_FUNCTION(html_entity_decode)\n{\n\tzend_string *str, *hint_charset = NULL;\n\tzend_long quote_style = ENT_QUOTES|ENT_SUBSTITUTE;\n\tzend_string *replaced;\n\n\tZEND_PARSE_PARAMETERS_START(1, 3)\n\t\tZ_PARAM_STR(str)\n\t\tZ_PARAM_OPTIONAL\n\t\tZ_PARAM_LONG(quote_style)\n\t\tZ_PARAM_STR_OR_NULL(hint_charset)\n\tZEND_PARSE_PARAMETERS_END();\n\n\treplaced = php_unescape_html_entities(\n\t\tstr, 1 /*all*/, (int)quote_style, hint_charset ? ZSTR_VAL(hint_charset) : NULL);\n\tRETURN_STR(replaced);\n}\n/* }}} */\n\n\n/* {{{ Convert all applicable characters to HTML entities */\nPHP_FUNCTION(htmlentities)\n{\n\tphp_html_entities(INTERNAL_FUNCTION_PARAM_PASSTHRU, 1);\n}\n/* }}} */\n\n/* {{{ write_s3row_data */\nstatic inline void write_s3row_data(\n\tconst entity_stage3_row *r,\n\tunsigned orig_cp,\n\tenum entity_charset charset,\n\tzval *arr)\n{\n\tchar key[9] = \"\"; /* two unicode code points in UTF-8 */\n\tchar entity[LONGEST_ENTITY_LENGTH + 2] = {'&'};\n\tsize_t written_k1;\n\n\twritten_k1 = write_octet_sequence((unsigned char*)key, charset, orig_cp);\n\n\tif (!r->ambiguous) {\n\t\tsize_t l = r->data.ent.entity_len;\n\t\tmemcpy(&entity[1], r->data.ent.entity, l);\n\t\tentity[l + 1] = ';';\n\t\tadd_assoc_stringl_ex(arr, key, written_k1, entity, l + 2);\n\t} else {\n\t\tunsigned i,\n\t\t\t     num_entries;\n\t\tconst entity_multicodepoint_row *mcpr = r->data.multicodepoint_table;\n\n\t\tif (mcpr[0].leading_entry.default_entity != NULL) {\n\t\t\tsize_t l = mcpr[0].leading_entry.default_entity_len;\n\t\t\tmemcpy(&entity[1], mcpr[0].leading_entry.default_entity, l);\n\t\t\tentity[l + 1] = ';';\n\t\t\tadd_assoc_stringl_ex(arr, key, written_k1, entity, l + 2);\n\t\t}\n\t\tnum_entries = mcpr[0].leading_entry.size;\n\t\tfor (i = 1; i <= num_entries; i++) {\n\t\t\tsize_t   l,\n\t\t\t\t     written_k2;\n\t\t\tunsigned uni_cp,\n\t\t\t\t\t spe_cp;\n\n\t\t\tuni_cp = mcpr[i].normal_entry.second_cp;\n\t\t\tl = mcpr[i].normal_entry.entity_len;\n\n\t\t\tif (!CHARSET_UNICODE_COMPAT(charset)) {\n\t\t\t\tif (map_from_unicode(uni_cp, charset, &spe_cp) == FAILURE)\n\t\t\t\t\tcontinue; /* non representable in this charset */\n\t\t\t} else {\n\t\t\t\tspe_cp = uni_cp;\n\t\t\t}\n\n\t\t\twritten_k2 = write_octet_sequence((unsigned char*)&key[written_k1], charset, spe_cp);\n\t\t\tmemcpy(&entity[1], mcpr[i].normal_entry.entity, l);\n\t\t\tentity[l + 1] = ';';\n\t\t\tadd_assoc_stringl_ex(arr, key, written_k1 + written_k2, entity, l + 2);\n\t\t}\n\t}\n}\n/* }}} */\n\n/* {{{ Returns the internal translation table used by htmlspecialchars and htmlentities */\nPHP_FUNCTION(get_html_translation_table)\n{\n\tzend_long all = PHP_HTML_SPECIALCHARS,\n\t\t flags = ENT_QUOTES|ENT_SUBSTITUTE;\n\tint doctype;\n\tentity_table_opt entity_table;\n\tconst enc_to_uni *to_uni_table = NULL;\n\tchar *charset_hint = NULL;\n\tsize_t charset_hint_len;\n\tenum entity_charset charset;\n\n\t/* in this function we have to jump through some loops because we're\n\t * getting the translated table from data structures that are optimized for\n\t * random access, not traversal */\n\n\tZEND_PARSE_PARAMETERS_START(0, 3)\n\t\tZ_PARAM_OPTIONAL\n\t\tZ_PARAM_LONG(all)\n\t\tZ_PARAM_LONG(flags)\n\t\tZ_PARAM_STRING(charset_hint, charset_hint_len)\n\tZEND_PARSE_PARAMETERS_END();\n\n\tcharset = determine_charset(charset_hint, /* quiet */ 0);\n\tdoctype = flags & ENT_HTML_DOC_TYPE_MASK;\n\tLIMIT_ALL(all, doctype, charset);\n\n\tarray_init(return_value);\n\n\tentity_table = determine_entity_table((int)all, doctype);\n\tif (all && !CHARSET_UNICODE_COMPAT(charset)) {\n\t\tto_uni_table = enc_to_uni_index[charset];\n\t}\n\n\tif (all) { /* PHP_HTML_ENTITIES (actually, any non-zero value for 1st param) */\n\t\tconst entity_stage1_row *ms_table = entity_table.ms_table;\n\n\t\tif (CHARSET_UNICODE_COMPAT(charset)) {\n\t\t\tunsigned i, j, k,\n\t\t\t\t\t max_i, max_j, max_k;\n\t\t\t/* no mapping to unicode required */\n\t\t\tif (CHARSET_SINGLE_BYTE(charset)) { /* ISO-8859-1 */\n\t\t\t\tmax_i = 1; max_j = 4; max_k = 64;\n\t\t\t} else {\n\t\t\t\tmax_i = 0x1E; max_j = 64; max_k = 64;\n\t\t\t}\n\n\t\t\tfor (i = 0; i < max_i; i++) {\n\t\t\t\tif (ms_table[i] == empty_stage2_table)\n\t\t\t\t\tcontinue;\n\t\t\t\tfor (j = 0; j < max_j; j++) {\n\t\t\t\t\tif (ms_table[i][j] == empty_stage3_table)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tfor (k = 0; k < max_k; k++) {\n\t\t\t\t\t\tconst entity_stage3_row *r = &ms_table[i][j][k];\n\t\t\t\t\t\tunsigned code;\n\n\t\t\t\t\t\tif (r->data.ent.entity == NULL)\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\tcode = ENT_CODE_POINT_FROM_STAGES(i, j, k);\n\t\t\t\t\t\tif (((code == '\\'' && !(flags & ENT_HTML_QUOTE_SINGLE)) ||\n\t\t\t\t\t\t\t\t(code == '\"' && !(flags & ENT_HTML_QUOTE_DOUBLE))))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\twrite_s3row_data(r, code, charset, return_value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t/* we have to iterate through the set of code points for this\n\t\t\t * encoding and map them to unicode code points */\n\t\t\tunsigned i;\n\t\t\tfor (i = 0; i <= 0xFF; i++) {\n\t\t\t\tconst entity_stage3_row *r;\n\t\t\t\tunsigned uni_cp;\n\n\t\t\t\t/* can be done before mapping, they're invariant */\n\t\t\t\tif (((i == '\\'' && !(flags & ENT_HTML_QUOTE_SINGLE)) ||\n\t\t\t\t\t\t(i == '\"' && !(flags & ENT_HTML_QUOTE_DOUBLE))))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tmap_to_unicode(i, to_uni_table, &uni_cp);\n\t\t\t\tr = &ms_table[ENT_STAGE1_INDEX(uni_cp)][ENT_STAGE2_INDEX(uni_cp)][ENT_STAGE3_INDEX(uni_cp)];\n\t\t\t\tif (r->data.ent.entity == NULL)\n\t\t\t\t\tcontinue;\n\n\t\t\t\twrite_s3row_data(r, i, charset, return_value);\n\t\t\t}\n\t\t}\n\t} else {\n\t\t/* we could use sizeof(stage3_table_be_apos_00000) as well */\n\t\tunsigned\t  j,\n\t\t\t\t\t  numelems = sizeof(stage3_table_be_noapos_00000) /\n\t\t\t\t\t\t\tsizeof(*stage3_table_be_noapos_00000);\n\n\t\tfor (j = 0; j < numelems; j++) {\n\t\t\tconst entity_stage3_row *r = &entity_table.table[j];\n\t\t\tif (r->data.ent.entity == NULL)\n\t\t\t\tcontinue;\n\n\t\t\tif (((j == '\\'' && !(flags & ENT_HTML_QUOTE_SINGLE)) ||\n\t\t\t\t\t(j == '\"' && !(flags & ENT_HTML_QUOTE_DOUBLE))))\n\t\t\t\tcontinue;\n\n\t\t\t/* charset is indifferent, used cs_8859_1 for efficiency */\n\t\t\twrite_s3row_data(r, j, cs_8859_1, return_value);\n\t\t}\n\t}\n}\n/* }}} */\n", "patch": "@@ -163,7 +163,7 @@ static inline unsigned int get_next_char(\n \t\t\t\t\telse\n \t\t\t\t\t\tMB_FAILURE(pos, 4);\n \t\t\t\t}\n-\t\t\t\t\n+\n \t\t\t\tthis_char = ((c & 0x07) << 18) | ((str[pos + 1] & 0x3f) << 12) | ((str[pos + 2] & 0x3f) << 6) | (str[pos + 3] & 0x3f);\n \t\t\t\tif (this_char < 0x10000 || this_char > 0x10FFFF) { /* non-shortest form or outside range */\n \t\t\t\t\tMB_FAILURE(pos, 4);\n@@ -437,7 +437,7 @@ static enum entity_charset determine_charset(char *charset_hint TSRMLS_DC)\n \n \tif (charset_hint) {\n \t\tint found = 0;\n-\t\t\n+\n \t\t/* now walk the charset map and look for the codeset */\n \t\tfor (i = 0; charset_map[i].codeset; i++) {\n \t\t\tif (len == strlen(charset_map[i].codeset) && strncasecmp(charset_hint, charset_map[i].codeset, len) == 0) {\n@@ -545,7 +545,7 @@ static inline unsigned char unimap_bsearch(const uni_to_enc *table, unsigned cod\n \t\treturn 0;\n \n \tcode_key = (unsigned short) code_key_a;\n-\t\n+\n \twhile (l <= h) {\n \t\tm = l + (h - l) / 2;\n \t\tif (code_key < m->un_code_point)\n@@ -571,7 +571,7 @@ static inline int map_from_unicode(unsigned code, enum entity_charset charset, u\n \t\t/* identity mapping of code points to unicode */\n \t\tif (code > 0xFF) {\n \t\t\treturn FAILURE;\n-\t\t} \n+\t\t}\n \t\t*res = code;\n \t\tbreak;\n \n@@ -590,7 +590,7 @@ static inline int map_from_unicode(unsigned code, enum entity_charset charset, u\n \t\t\treturn FAILURE;\n \t\t}\n \t\tbreak;\n-\t\t\n+\n \tcase cs_8859_15:\n \t\tif (code < 0xA4 || (code > 0xBE && code <= 0xFF)) {\n \t\t\t*res = code;\n@@ -634,7 +634,7 @@ static inline int map_from_unicode(unsigned code, enum entity_charset charset, u\n \tcase cs_cp866:\n \t\ttable = unimap_cp866;\n \t\ttable_size = sizeof(unimap_cp866) / sizeof(*unimap_cp866);\n-\t\t\n+\n table_over_7F:\n \t\tif (code <= 0x7F) {\n \t\t\t*res = code;\n@@ -710,7 +710,7 @@ static inline int unicode_cp_is_allowed(unsigned uni_cp, int document_type)\n \t * Not sure this is the relevant part for HTML 5, though. I opted to\n \t * disallow the characters that would result in a parse error when\n \t * preprocessing of the input stream. See also section 8.1.3.\n-\t * \n+\t *\n \t * It's unclear if XHTML 1.0 allows C1 characters. I'll opt to apply to\n \t * XHTML 1.0 the same rules as for XML 1.0.\n \t * See <http://cmsmcq.com/2007/C1.xml>.\n@@ -774,7 +774,7 @@ static inline int numeric_entity_is_allowed(unsigned uni_cp, int document_type)\n /* {{{ process_numeric_entity\n  * Auxiliary function to traverse_for_entities.\n  * On input, *buf should point to the first character after # and on output, it's the last\n- * byte read, no matter if there was success or insuccess. \n+ * byte read, no matter if there was success or insuccess.\n  */\n static inline int process_numeric_entity(const char **buf, unsigned *code_point)\n {\n@@ -784,7 +784,7 @@ static inline int process_numeric_entity(const char **buf, unsigned *code_point)\n \n \tif (hexadecimal && (**buf != '\\0'))\n \t\t(*buf)++;\n-\t\t\t\n+\n \t/* strtol allows whitespace and other stuff in the beginning\n \t\t* we're not interested */\n \tif ((hexadecimal && !isxdigit(**buf)) ||\n@@ -969,7 +969,7 @@ static void traverse_for_entities(\n \t\t\t\tgoto invalid_code;\n \n \t\t\t/* are we allowed to decode this entity in this document type?\n-\t\t\t * HTML 5 is the only that has a character that cannot be used in \n+\t\t\t * HTML 5 is the only that has a character that cannot be used in\n \t\t\t * a numeric entity but is allowed literally (U+000D). The\n \t\t\t * unoptimized version would be ... || !numeric_entity_is_allowed(code) */\n \t\t\tif (!unicode_cp_is_allowed(code, doctype) ||\n@@ -996,9 +996,9 @@ static void traverse_for_entities(\n \t\t\t\t}\n \t\t\t}\n \t\t}\n-\t\t\n+\n \t\tassert(*next == ';');\n-\t\t\n+\n \t\tif (((code == '\\'' && !(flags & ENT_HTML_QUOTE_SINGLE)) ||\n \t\t\t\t(code == '\"' && !(flags & ENT_HTML_QUOTE_DOUBLE)))\n \t\t\t\t/* && code2 == '\\0' always true for current maps */)\n@@ -1026,7 +1026,7 @@ static void traverse_for_entities(\n \t\t\t*(q++) = *p;\n \t\t}\n \t}\n-\t\n+\n \t*q = '\\0';\n \t*retlen = (size_t)(q - ret);\n }\n@@ -1066,7 +1066,7 @@ static entity_table_opt determine_entity_table(int all, int doctype)\n \tentity_table_opt retval = {NULL};\n \n \tassert(!(doctype == ENT_HTML_DOC_XML1 && all));\n-\t\n+\n \tif (all) {\n \t\tretval.ms_table = (doctype == ENT_HTML_DOC_HTML5) ?\n \t\t\tentity_ms_table_html5 : entity_ms_table_html4;\n@@ -1111,13 +1111,13 @@ PHPAPI char *php_unescape_html_entities(unsigned char *old, size_t oldlen, size_\n \tif (retlen == 0) {\n \t\tgoto empty_source;\n \t}\n-\t\n+\n \tinverse_map = unescape_inverse_map(all, flags);\n-\t\n+\n \t/* replace numeric entities */\n \ttraverse_for_entities(old, oldlen, ret, &retlen, all, flags, inverse_map, charset);\n \n-empty_source:\t\n+empty_source:\n \t*newlen = retlen;\n \treturn ret;\n }\n@@ -1141,7 +1141,7 @@ static inline void find_entity_for_char(\n {\n \tunsigned stage1_idx = ENT_STAGE1_INDEX(k);\n \tconst entity_stage3_row *c;\n-\t\n+\n \tif (stage1_idx > 0x1D) {\n \t\t*entity     = NULL;\n \t\t*entity_len = 0;\n@@ -1162,7 +1162,7 @@ static inline void find_entity_for_char(\n \t\tif (!(*cursor < oldlen))\n \t\t\tgoto no_suitable_2nd;\n \n-\t\tnext_char = get_next_char(charset, old, oldlen, cursor, &status); \n+\t\tnext_char = get_next_char(charset, old, oldlen, cursor, &status);\n \n \t\tif (status == FAILURE)\n \t\t\tgoto no_suitable_2nd;\n@@ -1187,7 +1187,7 @@ static inline void find_entity_for_char(\n \t\t*entity = (const unsigned char *)\n \t\t\tc->data.multicodepoint_table[0].leading_entry.default_entity;\n \t\t*entity_len = c->data.multicodepoint_table[0].leading_entry.default_entity_len;\n-\t}\t\n+\t}\n }\n /* }}} */\n \n@@ -1255,7 +1255,7 @@ PHPAPI char *php_escape_html_entities_ex(unsigned char *old, size_t oldlen, size\n \n \t/* initial estimate */\n \tif (oldlen < 64) {\n-\t\tmaxlen = 128;\t\n+\t\tmaxlen = 128;\n \t} else {\n \t\tmaxlen = 2 * oldlen;\n \t\tif (maxlen < oldlen) {\n@@ -1444,6 +1444,10 @@ static void php_html_entities(INTERNAL_FUNCTION_PARAMETERS, int all)\n \t}\n \n \treplaced = php_escape_html_entities_ex(str, str_len, &new_len, all, (int) flags, hint_charset, double_encode TSRMLS_CC);\n+\tif (new_len > INT_MAX) {\n+\t\tefree(replaced);\n+\t\tRETURN_FALSE;\n+\t}\n \tRETVAL_STRINGL(replaced, (int)new_len, 0);\n }\n /* }}} */\n@@ -1577,7 +1581,7 @@ static inline void write_s3row_data(\n \t\t\t} else {\n \t\t\t\tspe_cp = uni_cp;\n \t\t\t}\n-\t\t\t\n+\n \t\t\twritten_k2 = write_octet_sequence(&key[written_k1], charset, spe_cp);\n \t\t\tmemcpy(&entity[1], mcpr[i].normal_entry.entity, l);\n \t\t\tentity[l + 1] = ';';\n@@ -1615,7 +1619,7 @@ PHP_FUNCTION(get_html_translation_table)\n \tLIMIT_ALL(all, doctype, charset);\n \n \tarray_init(return_value);\n-\t\n+\n \tentity_table = determine_entity_table(all, doctype);\n \tif (all && !CHARSET_UNICODE_COMPAT(charset)) {\n \t\tto_uni_table = enc_to_uni_index[charset];", "file_path": "files/2016_8\\78", "file_language": "c", "file_name": "ext/standard/html.c", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}], "outdated": 0}
{"index": 31, "cve_id": "CVE-2016-5096", "cwe_id": ["CWE-190"], "cve_language": "C", "cve_description": "Integer overflow in the fread function in ext/standard/file.c in PHP before 5.5.36 and 5.6.x before 5.6.22 allows remote attackers to cause a denial of service or possibly have unspecified other impact via a large integer in the second argument.", "cvss": "8.6", "publish_date": "August 7, 2016", "AV": "NETWORK", "AC": "LOW", "PR": "NONE", "UI": "NONE", "S": "UNCHANGED", "C": "LOW", "I": "LOW", "A": "HIGH", "commit_id": "abd159cce48f3e34f08e4751c568e09677d5ec9c", "commit_message": "Fix bug #72114 - int/size_t confusion in fread", "commit_date": "2016-05-10T04:55:29Z", "project": "php/php-src", "url": "https://api.github.com/repos/php/php-src/commits/abd159cce48f3e34f08e4751c568e09677d5ec9c", "html_url": "https://github.com/php/php-src/commit/abd159cce48f3e34f08e4751c568e09677d5ec9c", "windows_before": "", "windows_after": "", "parents": [{"commit_id_before": "95ed19ae28009aa7b3ed42d5760478de82640560", "url_before": "https://api.github.com/repos/php/php-src/commits/95ed19ae28009aa7b3ed42d5760478de82640560", "html_url_before": "https://github.com/php/php-src/commit/95ed19ae28009aa7b3ed42d5760478de82640560"}], "details": [{"raw_url": "https://github.com/php/php-src/raw/abd159cce48f3e34f08e4751c568e09677d5ec9c/ext/standard/file.c", "code": "/*\n   +----------------------------------------------------------------------+\n   | PHP Version 5                                                        |\n   +----------------------------------------------------------------------+\n   | Copyright (c) 1997-2015 The PHP Group                                |\n   +----------------------------------------------------------------------+\n   | This source file is subject to version 3.01 of the PHP license,      |\n   | that is bundled with this package in the file LICENSE, and is        |\n   | available through the world-wide-web at the following url:           |\n   | http://www.php.net/license/3_01.txt                                  |\n   | If you did not receive a copy of the PHP license and are unable to   |\n   | obtain it through the world-wide-web, please send a note to          |\n   | license@php.net so we can mail you a copy immediately.               |\n   +----------------------------------------------------------------------+\n   | Authors: Rasmus Lerdorf <rasmus@php.net>                             |\n   |          Stig Bakken <ssb@php.net>                                   |\n   |          Andi Gutmans <andi@zend.com>                                |\n   |          Zeev Suraski <zeev@zend.com>                                |\n   | PHP 4.0 patches by Thies C. Arntzen (thies@thieso.net)               |\n   | PHP streams by Wez Furlong (wez@thebrainroom.com)                    |\n   +----------------------------------------------------------------------+\n*/\n\n/* $Id$ */\n\n/* Synced with php 3.0 revision 1.218 1999-06-16 [ssb] */\n\n/* {{{ includes */\n\n#include \"php.h\"\n#include \"php_globals.h\"\n#include \"ext/standard/flock_compat.h\"\n#include \"ext/standard/exec.h\"\n#include \"ext/standard/php_filestat.h\"\n#include \"php_open_temporary_file.h\"\n#include \"ext/standard/basic_functions.h\"\n#include \"php_ini.h\"\n#include \"php_smart_str.h\"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n\n#ifdef PHP_WIN32\n# include <io.h>\n# define O_RDONLY _O_RDONLY\n# include \"win32/param.h\"\n# include \"win32/winutil.h\"\n# include \"win32/fnmatch.h\"\n#else\n# if HAVE_SYS_PARAM_H\n#  include <sys/param.h>\n# endif\n# if HAVE_SYS_SELECT_H\n#  include <sys/select.h>\n# endif\n# if defined(NETWARE) && defined(USE_WINSOCK)\n#  include <novsock2.h>\n# else\n#  include <sys/socket.h>\n#  include <netinet/in.h>\n#  include <netdb.h>\n# endif\n# if HAVE_ARPA_INET_H\n#  include <arpa/inet.h>\n# endif\n#endif\n\n#include \"ext/standard/head.h\"\n#include \"php_string.h\"\n#include \"file.h\"\n\n#if HAVE_PWD_H\n# ifdef PHP_WIN32\n#  include \"win32/pwd.h\"\n# else\n#  include <pwd.h>\n# endif\n#endif\n\n#ifdef HAVE_SYS_TIME_H\n# include <sys/time.h>\n#endif\n\n#include \"fsock.h\"\n#include \"fopen_wrappers.h\"\n#include \"streamsfuncs.h\"\n#include \"php_globals.h\"\n\n#ifdef HAVE_SYS_FILE_H\n# include <sys/file.h>\n#endif\n\n#if MISSING_FCLOSE_DECL\nextern int fclose(FILE *);\n#endif\n\n#ifdef HAVE_SYS_MMAN_H\n# include <sys/mman.h>\n#endif\n\n#include \"scanf.h\"\n#include \"zend_API.h\"\n\n#ifdef ZTS\nint file_globals_id;\n#else\nphp_file_globals file_globals;\n#endif\n\n#if defined(HAVE_FNMATCH) && !defined(PHP_WIN32)\n# ifndef _GNU_SOURCE\n#  define _GNU_SOURCE\n# endif\n# include <fnmatch.h>\n#endif\n\n#ifdef HAVE_WCHAR_H\n# include <wchar.h>\n#endif\n\n#ifndef S_ISDIR\n# define S_ISDIR(mode)\t(((mode)&S_IFMT) == S_IFDIR)\n#endif\n/* }}} */\n\n#define PHP_STREAM_TO_ZVAL(stream, arg) \\\n\tphp_stream_from_zval_no_verify(stream, arg); \\\n\tif (stream == NULL) {\t\\\n\t\tRETURN_FALSE;\t\\\n\t}\n\n/* {{{ ZTS-stuff / Globals / Prototypes */\n\n/* sharing globals is *evil* */\nstatic int le_stream_context = FAILURE;\n\nPHPAPI int php_le_stream_context(TSRMLS_D)\n{\n\treturn le_stream_context;\n}\n/* }}} */\n\n/* {{{ Module-Stuff\n*/\nstatic ZEND_RSRC_DTOR_FUNC(file_context_dtor)\n{\n\tphp_stream_context *context = (php_stream_context*)rsrc->ptr;\n\tif (context->options) {\n\t\tzval_ptr_dtor(&context->options);\n\t\tcontext->options = NULL;\n\t}\n\tphp_stream_context_free(context);\n}\n\nstatic void file_globals_ctor(php_file_globals *file_globals_p TSRMLS_DC)\n{\n\tFG(pclose_ret) = 0;\n\tFG(pclose_wait) = 0;\n\tFG(user_stream_current_filename) = NULL;\n\tFG(def_chunk_size) = PHP_SOCK_CHUNK_SIZE;\n\tFG(wrapper_errors) = NULL;\n}\n\nstatic void file_globals_dtor(php_file_globals *file_globals_p TSRMLS_DC)\n{\n}\n\nPHP_INI_BEGIN()\n\tSTD_PHP_INI_ENTRY(\"user_agent\", NULL, PHP_INI_ALL, OnUpdateString, user_agent, php_file_globals, file_globals)\n\tSTD_PHP_INI_ENTRY(\"from\", NULL, PHP_INI_ALL, OnUpdateString, from_address, php_file_globals, file_globals)\n\tSTD_PHP_INI_ENTRY(\"default_socket_timeout\", \"60\", PHP_INI_ALL, OnUpdateLong, default_socket_timeout, php_file_globals, file_globals)\n\tSTD_PHP_INI_ENTRY(\"auto_detect_line_endings\", \"0\", PHP_INI_ALL, OnUpdateLong, auto_detect_line_endings, php_file_globals, file_globals)\nPHP_INI_END()\n\nPHP_MINIT_FUNCTION(file)\n{\n\tle_stream_context = zend_register_list_destructors_ex(file_context_dtor, NULL, \"stream-context\", module_number);\n\n#ifdef ZTS\n\tts_allocate_id(&file_globals_id, sizeof(php_file_globals), (ts_allocate_ctor) file_globals_ctor, (ts_allocate_dtor) file_globals_dtor);\n#else\n\tfile_globals_ctor(&file_globals TSRMLS_CC);\n#endif\n\n\tREGISTER_INI_ENTRIES();\n\n\tREGISTER_LONG_CONSTANT(\"SEEK_SET\", SEEK_SET, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SEEK_CUR\", SEEK_CUR, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SEEK_END\", SEEK_END, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"LOCK_SH\", PHP_LOCK_SH, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"LOCK_EX\", PHP_LOCK_EX, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"LOCK_UN\", PHP_LOCK_UN, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"LOCK_NB\", PHP_LOCK_NB, CONST_CS | CONST_PERSISTENT);\n\n\tREGISTER_LONG_CONSTANT(\"STREAM_NOTIFY_CONNECT\",\t\t\tPHP_STREAM_NOTIFY_CONNECT,\t\t\tCONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"STREAM_NOTIFY_AUTH_REQUIRED\",\tPHP_STREAM_NOTIFY_AUTH_REQUIRED,\tCONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"STREAM_NOTIFY_AUTH_RESULT\",\t\tPHP_STREAM_NOTIFY_AUTH_RESULT,\t\tCONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"STREAM_NOTIFY_MIME_TYPE_IS\",\tPHP_STREAM_NOTIFY_MIME_TYPE_IS,\t\tCONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"STREAM_NOTIFY_FILE_SIZE_IS\",\tPHP_STREAM_NOTIFY_FILE_SIZE_IS,\t\tCONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"STREAM_NOTIFY_REDIRECTED\",\t\tPHP_STREAM_NOTIFY_REDIRECTED,\t\tCONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"STREAM_NOTIFY_PROGRESS\",\t\tPHP_STREAM_NOTIFY_PROGRESS,\t\t\tCONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"STREAM_NOTIFY_FAILURE\",\t\t\tPHP_STREAM_NOTIFY_FAILURE,\t\t\tCONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"STREAM_NOTIFY_COMPLETED\",\t\tPHP_STREAM_NOTIFY_COMPLETED,\t\tCONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"STREAM_NOTIFY_RESOLVE\",\t\t\tPHP_STREAM_NOTIFY_RESOLVE,\t\t\tCONST_CS | CONST_PERSISTENT);\n\n\tREGISTER_LONG_CONSTANT(\"STREAM_NOTIFY_SEVERITY_INFO\",\tPHP_STREAM_NOTIFY_SEVERITY_INFO,\tCONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"STREAM_NOTIFY_SEVERITY_WARN\",\tPHP_STREAM_NOTIFY_SEVERITY_WARN,\tCONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"STREAM_NOTIFY_SEVERITY_ERR\",\tPHP_STREAM_NOTIFY_SEVERITY_ERR,\t\tCONST_CS | CONST_PERSISTENT);\n\n\tREGISTER_LONG_CONSTANT(\"STREAM_FILTER_READ\",\t\t\tPHP_STREAM_FILTER_READ,\t\t\t\tCONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"STREAM_FILTER_WRITE\",\t\t\tPHP_STREAM_FILTER_WRITE,\t\t\tCONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"STREAM_FILTER_ALL\",\t\t\t\tPHP_STREAM_FILTER_ALL,\t\t\t\tCONST_CS | CONST_PERSISTENT);\n\n\tREGISTER_LONG_CONSTANT(\"STREAM_CLIENT_PERSISTENT\",\t\tPHP_STREAM_CLIENT_PERSISTENT,\t\tCONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"STREAM_CLIENT_ASYNC_CONNECT\",\tPHP_STREAM_CLIENT_ASYNC_CONNECT,\tCONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"STREAM_CLIENT_CONNECT\",\t\t\tPHP_STREAM_CLIENT_CONNECT,\tCONST_CS | CONST_PERSISTENT);\n\n\tREGISTER_LONG_CONSTANT(\"STREAM_CRYPTO_METHOD_SSLv2_CLIENT\",\t\tSTREAM_CRYPTO_METHOD_SSLv2_CLIENT,\tCONST_CS|CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"STREAM_CRYPTO_METHOD_SSLv3_CLIENT\",\t\tSTREAM_CRYPTO_METHOD_SSLv3_CLIENT,\tCONST_CS|CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"STREAM_CRYPTO_METHOD_SSLv23_CLIENT\",\tSTREAM_CRYPTO_METHOD_SSLv23_CLIENT,\tCONST_CS|CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"STREAM_CRYPTO_METHOD_TLS_CLIENT\",\t\tSTREAM_CRYPTO_METHOD_TLS_CLIENT,\tCONST_CS|CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"STREAM_CRYPTO_METHOD_SSLv2_SERVER\",\t\tSTREAM_CRYPTO_METHOD_SSLv2_SERVER,\tCONST_CS|CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"STREAM_CRYPTO_METHOD_SSLv3_SERVER\",\t\tSTREAM_CRYPTO_METHOD_SSLv3_SERVER,\tCONST_CS|CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"STREAM_CRYPTO_METHOD_SSLv23_SERVER\",\tSTREAM_CRYPTO_METHOD_SSLv23_SERVER,\tCONST_CS|CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"STREAM_CRYPTO_METHOD_TLS_SERVER\",\t\tSTREAM_CRYPTO_METHOD_TLS_SERVER,\tCONST_CS|CONST_PERSISTENT);\n\n\tREGISTER_LONG_CONSTANT(\"STREAM_SHUT_RD\",\tSTREAM_SHUT_RD,\t\tCONST_CS|CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"STREAM_SHUT_WR\",\tSTREAM_SHUT_WR,\t\tCONST_CS|CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"STREAM_SHUT_RDWR\",\tSTREAM_SHUT_RDWR,\tCONST_CS|CONST_PERSISTENT);\n\n#ifdef PF_INET\n\tREGISTER_LONG_CONSTANT(\"STREAM_PF_INET\", PF_INET, CONST_CS|CONST_PERSISTENT);\n#elif defined(AF_INET)\n\tREGISTER_LONG_CONSTANT(\"STREAM_PF_INET\", AF_INET, CONST_CS|CONST_PERSISTENT);\n#endif\n\n#if HAVE_IPV6\n# ifdef PF_INET6\n\tREGISTER_LONG_CONSTANT(\"STREAM_PF_INET6\", PF_INET6, CONST_CS|CONST_PERSISTENT);\n# elif defined(AF_INET6)\n\tREGISTER_LONG_CONSTANT(\"STREAM_PF_INET6\", AF_INET6, CONST_CS|CONST_PERSISTENT);\n# endif\n#endif\n\n#ifdef PF_UNIX\n\tREGISTER_LONG_CONSTANT(\"STREAM_PF_UNIX\", PF_UNIX, CONST_CS|CONST_PERSISTENT);\n#elif defined(AF_UNIX)\n\tREGISTER_LONG_CONSTANT(\"STREAM_PF_UNIX\", AF_UNIX, CONST_CS|CONST_PERSISTENT);\n#endif\n\n#ifdef IPPROTO_IP\n\t/* most people will use this one when calling socket() or socketpair() */\n\tREGISTER_LONG_CONSTANT(\"STREAM_IPPROTO_IP\", IPPROTO_IP, CONST_CS|CONST_PERSISTENT);\n#endif\n\n#ifdef IPPROTO_TCP\n\tREGISTER_LONG_CONSTANT(\"STREAM_IPPROTO_TCP\", IPPROTO_TCP, CONST_CS|CONST_PERSISTENT);\n#endif\n\n#ifdef IPPROTO_UDP\n\tREGISTER_LONG_CONSTANT(\"STREAM_IPPROTO_UDP\", IPPROTO_UDP, CONST_CS|CONST_PERSISTENT);\n#endif\n\n#ifdef IPPROTO_ICMP\n\tREGISTER_LONG_CONSTANT(\"STREAM_IPPROTO_ICMP\", IPPROTO_ICMP, CONST_CS|CONST_PERSISTENT);\n#endif\n\n#ifdef IPPROTO_RAW\n\tREGISTER_LONG_CONSTANT(\"STREAM_IPPROTO_RAW\", IPPROTO_RAW, CONST_CS|CONST_PERSISTENT);\n#endif\n\n\tREGISTER_LONG_CONSTANT(\"STREAM_SOCK_STREAM\", SOCK_STREAM, CONST_CS|CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"STREAM_SOCK_DGRAM\", SOCK_DGRAM, CONST_CS|CONST_PERSISTENT);\n\n#ifdef SOCK_RAW\n\tREGISTER_LONG_CONSTANT(\"STREAM_SOCK_RAW\", SOCK_RAW, CONST_CS|CONST_PERSISTENT);\n#endif\n\n#ifdef SOCK_SEQPACKET\n\tREGISTER_LONG_CONSTANT(\"STREAM_SOCK_SEQPACKET\", SOCK_SEQPACKET, CONST_CS|CONST_PERSISTENT);\n#endif\n\n#ifdef SOCK_RDM\n\tREGISTER_LONG_CONSTANT(\"STREAM_SOCK_RDM\", SOCK_RDM, CONST_CS|CONST_PERSISTENT);\n#endif\n\n\tREGISTER_LONG_CONSTANT(\"STREAM_PEEK\", STREAM_PEEK, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"STREAM_OOB\",  STREAM_OOB, CONST_CS | CONST_PERSISTENT);\n\n\tREGISTER_LONG_CONSTANT(\"STREAM_SERVER_BIND\",\t\t\tSTREAM_XPORT_BIND,\t\t\t\t\tCONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"STREAM_SERVER_LISTEN\",\t\t\tSTREAM_XPORT_LISTEN,\t\t\t\tCONST_CS | CONST_PERSISTENT);\n\n\tREGISTER_LONG_CONSTANT(\"FILE_USE_INCLUDE_PATH\",\t\t\tPHP_FILE_USE_INCLUDE_PATH,\t\t\tCONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILE_IGNORE_NEW_LINES\",\t\t\tPHP_FILE_IGNORE_NEW_LINES,\t\t\tCONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILE_SKIP_EMPTY_LINES\",\t\t\tPHP_FILE_SKIP_EMPTY_LINES,\t\t\tCONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILE_APPEND\",\t\t\t\t\tPHP_FILE_APPEND,\t\t\t\t\tCONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILE_NO_DEFAULT_CONTEXT\",\t\tPHP_FILE_NO_DEFAULT_CONTEXT,\t\tCONST_CS | CONST_PERSISTENT);\n\n\tREGISTER_LONG_CONSTANT(\"FILE_TEXT\",\t\t\t\t\t\t0,\t\t\t\t\t\t\t\t\tCONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FILE_BINARY\",\t\t\t\t\t0,\t\t\t\t\t\t\t\t\tCONST_CS | CONST_PERSISTENT);\n\n#ifdef HAVE_FNMATCH\n\tREGISTER_LONG_CONSTANT(\"FNM_NOESCAPE\", FNM_NOESCAPE, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FNM_PATHNAME\", FNM_PATHNAME, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"FNM_PERIOD\",   FNM_PERIOD,   CONST_CS | CONST_PERSISTENT);\n# ifdef FNM_CASEFOLD /* a GNU extension */ /* TODO emulate if not available */\n\tREGISTER_LONG_CONSTANT(\"FNM_CASEFOLD\", FNM_CASEFOLD, CONST_CS | CONST_PERSISTENT);\n# endif\n#endif\n\n\treturn SUCCESS;\n}\n/* }}} */\n\nPHP_MSHUTDOWN_FUNCTION(file) /* {{{ */\n{\n#ifndef ZTS\n\tfile_globals_dtor(&file_globals TSRMLS_CC);\n#endif\n\treturn SUCCESS;\n}\n/* }}} */\n\nstatic int flock_values[] = { LOCK_SH, LOCK_EX, LOCK_UN };\n\n/* {{{ proto bool flock(resource fp, int operation [, int &wouldblock])\n   Portable file locking */\nPHP_FUNCTION(flock)\n{\n\tzval *arg1, *arg3 = NULL;\n\tint act;\n\tphp_stream *stream;\n\tlong operation = 0;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rl|z\", &arg1, &operation, &arg3) == FAILURE) {\n\t\treturn;\n\t}\n\n\tPHP_STREAM_TO_ZVAL(stream, &arg1);\n\n\tact = operation & 3;\n\tif (act < 1 || act > 3) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Illegal operation argument\");\n\t\tRETURN_FALSE;\n\t}\n\n\tif (arg3 && PZVAL_IS_REF(arg3)) {\n\t\tconvert_to_long_ex(&arg3);\n\t\tZ_LVAL_P(arg3) = 0;\n\t}\n\n\t/* flock_values contains all possible actions if (operation & 4) we won't block on the lock */\n\tact = flock_values[act - 1] | (operation & PHP_LOCK_NB ? LOCK_NB : 0);\n\tif (php_stream_lock(stream, act)) {\n\t\tif (operation && errno == EWOULDBLOCK && arg3 && PZVAL_IS_REF(arg3)) {\n\t\t\tZ_LVAL_P(arg3) = 1;\n\t\t}\n\t\tRETURN_FALSE;\n\t}\n\tRETURN_TRUE;\n}\n/* }}} */\n\n#define PHP_META_UNSAFE \".\\\\+*?[^]$() \"\n\n/* {{{ proto array get_meta_tags(string filename [, bool use_include_path])\n   Extracts all meta tag content attributes from a file and returns an array */\nPHP_FUNCTION(get_meta_tags)\n{\n\tchar *filename;\n\tint filename_len;\n\tzend_bool use_include_path = 0;\n\tint in_tag = 0, done = 0;\n\tint looking_for_val = 0, have_name = 0, have_content = 0;\n\tint saw_name = 0, saw_content = 0;\n\tchar *name = NULL, *value = NULL, *temp = NULL;\n\tphp_meta_tags_token tok, tok_last;\n\tphp_meta_tags_data md;\n\n\t/* Initiailize our structure */\n\tmemset(&md, 0, sizeof(md));\n\n\t/* Parse arguments */\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"p|b\", &filename, &filename_len, &use_include_path) == FAILURE) {\n\t\treturn;\n\t}\n\n\tmd.stream = php_stream_open_wrapper(filename, \"rb\",\n\t\t\t(use_include_path ? USE_PATH : 0) | REPORT_ERRORS,\n\t\t\tNULL);\n\tif (!md.stream)\t{\n\t\tRETURN_FALSE;\n\t}\n\n\tarray_init(return_value);\n\n\ttok_last = TOK_EOF;\n\n\twhile (!done && (tok = php_next_meta_token(&md TSRMLS_CC)) != TOK_EOF) {\n\t\tif (tok == TOK_ID) {\n\t\t\tif (tok_last == TOK_OPENTAG) {\n\t\t\t\tmd.in_meta = !strcasecmp(\"meta\", md.token_data);\n\t\t\t} else if (tok_last == TOK_SLASH && in_tag) {\n\t\t\t\tif (strcasecmp(\"head\", md.token_data) == 0) {\n\t\t\t\t\t/* We are done here! */\n\t\t\t\t\tdone = 1;\n\t\t\t\t}\n\t\t\t} else if (tok_last == TOK_EQUAL && looking_for_val) {\n\t\t\t\tif (saw_name) {\n\t\t\t\t\tSTR_FREE(name);\n\t\t\t\t\t/* Get the NAME attr (Single word attr, non-quoted) */\n\t\t\t\t\ttemp = name = estrndup(md.token_data, md.token_len);\n\n\t\t\t\t\twhile (temp && *temp) {\n\t\t\t\t\t\tif (strchr(PHP_META_UNSAFE, *temp)) {\n\t\t\t\t\t\t\t*temp = '_';\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttemp++;\n\t\t\t\t\t}\n\n\t\t\t\t\thave_name = 1;\n\t\t\t\t} else if (saw_content) {\n\t\t\t\t\tSTR_FREE(value);\n\t\t\t\t\tvalue = estrndup(md.token_data, md.token_len);\n\t\t\t\t\thave_content = 1;\n\t\t\t\t}\n\n\t\t\t\tlooking_for_val = 0;\n\t\t\t} else {\n\t\t\t\tif (md.in_meta) {\n\t\t\t\t\tif (strcasecmp(\"name\", md.token_data) == 0) {\n\t\t\t\t\t\tsaw_name = 1;\n\t\t\t\t\t\tsaw_content = 0;\n\t\t\t\t\t\tlooking_for_val = 1;\n\t\t\t\t\t} else if (strcasecmp(\"content\", md.token_data) == 0) {\n\t\t\t\t\t\tsaw_name = 0;\n\t\t\t\t\t\tsaw_content = 1;\n\t\t\t\t\t\tlooking_for_val = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (tok == TOK_STRING && tok_last == TOK_EQUAL && looking_for_val) {\n\t\t\tif (saw_name) {\n\t\t\t\tSTR_FREE(name);\n\t\t\t\t/* Get the NAME attr (Quoted single/double) */\n\t\t\t\ttemp = name = estrndup(md.token_data, md.token_len);\n\n\t\t\t\twhile (temp && *temp) {\n\t\t\t\t\tif (strchr(PHP_META_UNSAFE, *temp)) {\n\t\t\t\t\t\t*temp = '_';\n\t\t\t\t\t}\n\t\t\t\t\ttemp++;\n\t\t\t\t}\n\n\t\t\t\thave_name = 1;\n\t\t\t} else if (saw_content) {\n\t\t\t\tSTR_FREE(value);\n\t\t\t\tvalue = estrndup(md.token_data, md.token_len);\n\t\t\t\thave_content = 1;\n\t\t\t}\n\n\t\t\tlooking_for_val = 0;\n\t\t} else if (tok == TOK_OPENTAG) {\n\t\t\tif (looking_for_val) {\n\t\t\t\tlooking_for_val = 0;\n\t\t\t\thave_name = saw_name = 0;\n\t\t\t\thave_content = saw_content = 0;\n\t\t\t}\n\t\t\tin_tag = 1;\n\t\t} else if (tok == TOK_CLOSETAG) {\n\t\t\tif (have_name) {\n\t\t\t\t/* For BC */\n\t\t\t\tphp_strtolower(name, strlen(name));\n\t\t\t\tif (have_content) {\n\t\t\t\t\tadd_assoc_string(return_value, name, value, 1);\n\t\t\t\t} else {\n\t\t\t\t\tadd_assoc_string(return_value, name, \"\", 1);\n\t\t\t\t}\n\n\t\t\t\tefree(name);\n\t\t\t\tSTR_FREE(value);\n\t\t\t} else if (have_content) {\n\t\t\t\tefree(value);\n\t\t\t}\n\n\t\t\tname = value = NULL;\n\n\t\t\t/* Reset all of our flags */\n\t\t\tin_tag = looking_for_val = 0;\n\t\t\thave_name = saw_name = 0;\n\t\t\thave_content = saw_content = 0;\n\t\t\tmd.in_meta = 0;\n\t\t}\n\n\t\ttok_last = tok;\n\n\t\tif (md.token_data)\n\t\t\tefree(md.token_data);\n\n\t\tmd.token_data = NULL;\n\t}\n\n\tSTR_FREE(value);\n\tSTR_FREE(name);\n\tphp_stream_close(md.stream);\n}\n/* }}} */\n\n/* {{{ proto string file_get_contents(string filename [, bool use_include_path [, resource context [, long offset [, long maxlen]]]])\n   Read the entire file into a string */\nPHP_FUNCTION(file_get_contents)\n{\n\tchar *filename;\n\tint filename_len;\n\tchar *contents;\n\tzend_bool use_include_path = 0;\n\tphp_stream *stream;\n\tlong len;\n\tlong offset = -1;\n\tlong maxlen = PHP_STREAM_COPY_ALL;\n\tzval *zcontext = NULL;\n\tphp_stream_context *context = NULL;\n\n\t/* Parse arguments */\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"p|br!ll\", &filename, &filename_len, &use_include_path, &zcontext, &offset, &maxlen) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (ZEND_NUM_ARGS() == 5 && maxlen < 0) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"length must be greater than or equal to zero\");\n\t\tRETURN_FALSE;\n\t}\n\n\tcontext = php_stream_context_from_zval(zcontext, 0);\n\n\tstream = php_stream_open_wrapper_ex(filename, \"rb\",\n\t\t\t\t(use_include_path ? USE_PATH : 0) | REPORT_ERRORS,\n\t\t\t\tNULL, context);\n\tif (!stream) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (offset > 0 && php_stream_seek(stream, offset, SEEK_SET) < 0) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Failed to seek to position %ld in the stream\", offset);\n\t\tphp_stream_close(stream);\n\t\tRETURN_FALSE;\n\t}\n\n\tif ((len = php_stream_copy_to_mem(stream, &contents, maxlen, 0)) > 0) {\n\t\tif (len > INT_MAX) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"content truncated from %ld to %d bytes\", len, INT_MAX);\n\t\t\tlen = INT_MAX;\n\t\t}\n\t\tRETVAL_STRINGL(contents, len, 0);\n\t} else if (len == 0) {\n\t\tRETVAL_EMPTY_STRING();\n\t} else {\n\t\tRETVAL_FALSE;\n\t}\n\n\tphp_stream_close(stream);\n}\n/* }}} */\n\n/* {{{ proto int file_put_contents(string file, mixed data [, int flags [, resource context]])\n   Write/Create a file with contents data and return the number of bytes written */\nPHP_FUNCTION(file_put_contents)\n{\n\tphp_stream *stream;\n\tchar *filename;\n\tint filename_len;\n\tzval *data;\n\tlong numbytes = 0;\n\tlong flags = 0;\n\tzval *zcontext = NULL;\n\tphp_stream_context *context = NULL;\n\tphp_stream *srcstream = NULL;\n\tchar mode[3] = \"wb\";\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"pz/|lr!\", &filename, &filename_len, &data, &flags, &zcontext) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (Z_TYPE_P(data) == IS_RESOURCE) {\n\t\tphp_stream_from_zval(srcstream, &data);\n\t}\n\n\tcontext = php_stream_context_from_zval(zcontext, flags & PHP_FILE_NO_DEFAULT_CONTEXT);\n\n\tif (flags & PHP_FILE_APPEND) {\n\t\tmode[0] = 'a';\n\t} else if (flags & LOCK_EX) {\n\t\t/* check to make sure we are dealing with a regular file */\n\t\tif (php_memnstr(filename, \"://\", sizeof(\"://\") - 1, filename + filename_len)) {\n\t\t\tif (strncasecmp(filename, \"file://\", sizeof(\"file://\") - 1)) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Exclusive locks may only be set for regular files\");\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\t\t}\n\t\tmode[0] = 'c';\n\t}\n\tmode[2] = '\\0';\n\n\tstream = php_stream_open_wrapper_ex(filename, mode, ((flags & PHP_FILE_USE_INCLUDE_PATH) ? USE_PATH : 0) | REPORT_ERRORS, NULL, context);\n\tif (stream == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (flags & LOCK_EX && (!php_stream_supports_lock(stream) || php_stream_lock(stream, LOCK_EX))) {\n\t\tphp_stream_close(stream);\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Exclusive locks are not supported for this stream\");\n\t\tRETURN_FALSE;\n\t}\n\n\tif (mode[0] == 'c') {\n\t\tphp_stream_truncate_set_size(stream, 0);\n\t}\n\n\tswitch (Z_TYPE_P(data)) {\n\t\tcase IS_RESOURCE: {\n\t\t\tsize_t len;\n\t\t\tif (php_stream_copy_to_stream_ex(srcstream, stream, PHP_STREAM_COPY_ALL, &len) != SUCCESS) {\n\t\t\t\tnumbytes = -1;\n\t\t\t} else {\n\t\t\t\tif (len > LONG_MAX) {\n\t\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"content truncated from %lu to %ld bytes\", (unsigned long) len, LONG_MAX);\n\t\t\t\t\tlen = LONG_MAX;\n\t\t\t\t}\n\t\t\t\tnumbytes = len;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase IS_NULL:\n\t\tcase IS_LONG:\n\t\tcase IS_DOUBLE:\n\t\tcase IS_BOOL:\n\t\tcase IS_CONSTANT:\n\t\t\tconvert_to_string_ex(&data);\n\n\t\tcase IS_STRING:\n\t\t\tif (Z_STRLEN_P(data)) {\n\t\t\t\tnumbytes = php_stream_write(stream, Z_STRVAL_P(data), Z_STRLEN_P(data));\n\t\t\t\tif (numbytes != Z_STRLEN_P(data)) {\n\t\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Only %ld of %d bytes written, possibly out of free disk space\", numbytes, Z_STRLEN_P(data));\n\t\t\t\t\tnumbytes = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase IS_ARRAY:\n\t\t\tif (zend_hash_num_elements(Z_ARRVAL_P(data))) {\n\t\t\t\tint bytes_written;\n\t\t\t\tzval **tmp;\n\t\t\t\tHashPosition pos;\n\n\t\t\t\tzend_hash_internal_pointer_reset_ex(Z_ARRVAL_P(data), &pos);\n\t\t\t\twhile (zend_hash_get_current_data_ex(Z_ARRVAL_P(data), (void **) &tmp, &pos) == SUCCESS) {\n\t\t\t\t\tif (Z_TYPE_PP(tmp) != IS_STRING) {\n\t\t\t\t\t\tSEPARATE_ZVAL(tmp);\n\t\t\t\t\t\tconvert_to_string(*tmp);\n\t\t\t\t\t}\n\t\t\t\t\tif (Z_STRLEN_PP(tmp)) {\n\t\t\t\t\t\tnumbytes += Z_STRLEN_PP(tmp);\n\t\t\t\t\t\tbytes_written = php_stream_write(stream, Z_STRVAL_PP(tmp), Z_STRLEN_PP(tmp));\n\t\t\t\t\t\tif (bytes_written < 0 || bytes_written != Z_STRLEN_PP(tmp)) {\n\t\t\t\t\t\t\tif (bytes_written < 0) {\n\t\t\t\t\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Failed to write %d bytes to %s\", Z_STRLEN_PP(tmp), filename);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Only %d of %d bytes written, possibly out of free disk space\", bytes_written, Z_STRLEN_PP(tmp));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tnumbytes = -1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tzend_hash_move_forward_ex(Z_ARRVAL_P(data), &pos);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase IS_OBJECT:\n\t\t\tif (Z_OBJ_HT_P(data) != NULL) {\n\t\t\t\tzval out;\n\n\t\t\t\tif (zend_std_cast_object_tostring(data, &out, IS_STRING TSRMLS_CC) == SUCCESS) {\n\t\t\t\t\tnumbytes = php_stream_write(stream, Z_STRVAL(out), Z_STRLEN(out));\n\t\t\t\t\tif (numbytes != Z_STRLEN(out)) {\n\t\t\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Only %ld of %d bytes written, possibly out of free disk space\", numbytes, Z_STRLEN(out));\n\t\t\t\t\t\tnumbytes = -1;\n\t\t\t\t\t}\n\t\t\t\t\tzval_dtor(&out);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\tdefault:\n\t\t\tnumbytes = -1;\n\t\t\tbreak;\n\t}\n\tphp_stream_close(stream);\n\n\tif (numbytes < 0) {\n\t\tRETURN_FALSE;\n\t}\n\n\tRETURN_LONG(numbytes);\n}\n/* }}} */\n\n#define PHP_FILE_BUF_SIZE\t80\n\n/* {{{ proto array file(string filename [, int flags[, resource context]])\n   Read entire file into an array */\nPHP_FUNCTION(file)\n{\n\tchar *filename;\n\tint filename_len;\n\tchar *target_buf=NULL, *p, *s, *e;\n\tregister int i = 0;\n\tint target_len;\n\tchar eol_marker = '\\n';\n\tlong flags = 0;\n\tzend_bool use_include_path;\n\tzend_bool include_new_line;\n\tzend_bool skip_blank_lines;\n\tphp_stream *stream;\n\tzval *zcontext = NULL;\n\tphp_stream_context *context = NULL;\n\n\t/* Parse arguments */\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"p|lr!\", &filename, &filename_len, &flags, &zcontext) == FAILURE) {\n\t\treturn;\n\t}\n\tif (flags < 0 || flags > (PHP_FILE_USE_INCLUDE_PATH | PHP_FILE_IGNORE_NEW_LINES | PHP_FILE_SKIP_EMPTY_LINES | PHP_FILE_NO_DEFAULT_CONTEXT)) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"'%ld' flag is not supported\", flags);\n\t\tRETURN_FALSE;\n\t}\n\n\tuse_include_path = flags & PHP_FILE_USE_INCLUDE_PATH;\n\tinclude_new_line = !(flags & PHP_FILE_IGNORE_NEW_LINES);\n\tskip_blank_lines = flags & PHP_FILE_SKIP_EMPTY_LINES;\n\n\tcontext = php_stream_context_from_zval(zcontext, flags & PHP_FILE_NO_DEFAULT_CONTEXT);\n\n\tstream = php_stream_open_wrapper_ex(filename, \"rb\", (use_include_path ? USE_PATH : 0) | REPORT_ERRORS, NULL, context);\n\tif (!stream) {\n\t\tRETURN_FALSE;\n\t}\n\n\t/* Initialize return array */\n\tarray_init(return_value);\n\n\tif ((target_len = php_stream_copy_to_mem(stream, &target_buf, PHP_STREAM_COPY_ALL, 0))) {\n\t\ts = target_buf;\n\t\te = target_buf + target_len;\n\n\t\tif (!(p = php_stream_locate_eol(stream, target_buf, target_len TSRMLS_CC))) {\n\t\t\tp = e;\n\t\t\tgoto parse_eol;\n\t\t}\n\n\t\tif (stream->flags & PHP_STREAM_FLAG_EOL_MAC) {\n\t\t\teol_marker = '\\r';\n\t\t}\n\n\t\t/* for performance reasons the code is duplicated, so that the if (include_new_line)\n\t\t * will not need to be done for every single line in the file. */\n\t\tif (include_new_line) {\n\t\t\tdo {\n\t\t\t\tp++;\nparse_eol:\n\t\t\t\tadd_index_stringl(return_value, i++, estrndup(s, p-s), p-s, 0);\n\t\t\t\ts = p;\n\t\t\t} while ((p = memchr(p, eol_marker, (e-p))));\n\t\t} else {\n\t\t\tdo {\n\t\t\t\tint windows_eol = 0;\n\t\t\t\tif (p != target_buf && eol_marker == '\\n' && *(p - 1) == '\\r') {\n\t\t\t\t\twindows_eol++;\n\t\t\t\t}\n\t\t\t\tif (skip_blank_lines && !(p-s-windows_eol)) {\n\t\t\t\t\ts = ++p;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tadd_index_stringl(return_value, i++, estrndup(s, p-s-windows_eol), p-s-windows_eol, 0);\n\t\t\t\ts = ++p;\n\t\t\t} while ((p = memchr(p, eol_marker, (e-p))));\n\t\t}\n\n\t\t/* handle any left overs of files without new lines */\n\t\tif (s != e) {\n\t\t\tp = e;\n\t\t\tgoto parse_eol;\n\t\t}\n\t}\n\n\tif (target_buf) {\n\t\tefree(target_buf);\n\t}\n\tphp_stream_close(stream);\n}\n/* }}} */\n\n/* {{{ proto string tempnam(string dir, string prefix)\n   Create a unique filename in a directory */\nPHP_FUNCTION(tempnam)\n{\n\tchar *dir, *prefix;\n\tint dir_len, prefix_len;\n\tsize_t p_len;\n\tchar *opened_path;\n\tchar *p;\n\tint fd;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"pp\", &dir, &dir_len, &prefix, &prefix_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (php_check_open_basedir(dir TSRMLS_CC)) {\n\t\tRETURN_FALSE;\n\t}\n\n\tphp_basename(prefix, prefix_len, NULL, 0, &p, &p_len TSRMLS_CC);\n\tif (p_len > 64) {\n\t\tp[63] = '\\0';\n\t}\n\n\tRETVAL_FALSE;\n\n\tif ((fd = php_open_temporary_fd_ex(dir, p, &opened_path, 1 TSRMLS_CC)) >= 0) {\n\t\tclose(fd);\n\t\tRETVAL_STRING(opened_path, 0);\n\t}\n\tefree(p);\n}\n/* }}} */\n\n/* {{{ proto resource tmpfile(void)\n   Create a temporary file that will be deleted automatically after use */\nPHP_NAMED_FUNCTION(php_if_tmpfile)\n{\n\tphp_stream *stream;\n\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tstream = php_stream_fopen_tmpfile();\n\n\tif (stream) {\n\t\tphp_stream_to_zval(stream, return_value);\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n}\n/* }}} */\n\n/* {{{ proto resource fopen(string filename, string mode [, bool use_include_path [, resource context]])\n   Open a file or a URL and return a file pointer */\nPHP_NAMED_FUNCTION(php_if_fopen)\n{\n\tchar *filename, *mode;\n\tint filename_len, mode_len;\n\tzend_bool use_include_path = 0;\n\tzval *zcontext = NULL;\n\tphp_stream *stream;\n\tphp_stream_context *context = NULL;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"ps|br\", &filename, &filename_len, &mode, &mode_len, &use_include_path, &zcontext) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tcontext = php_stream_context_from_zval(zcontext, 0);\n\n\tstream = php_stream_open_wrapper_ex(filename, mode, (use_include_path ? USE_PATH : 0) | REPORT_ERRORS, NULL, context);\n\n\tif (stream == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\n\tphp_stream_to_zval(stream, return_value);\n}\n/* }}} */\n\n/* {{{ proto bool fclose(resource fp)\n   Close an open file pointer */\nPHPAPI PHP_FUNCTION(fclose)\n{\n\tzval *arg1;\n\tphp_stream *stream;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"r\", &arg1) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tPHP_STREAM_TO_ZVAL(stream, &arg1);\n\n\tif ((stream->flags & PHP_STREAM_FLAG_NO_FCLOSE) != 0) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"%d is not a valid stream resource\", stream->rsrc_id);\n\t\tRETURN_FALSE;\n\t}\n\n\tif (!stream->is_persistent) {\n\t\tphp_stream_close(stream);\n\t} else {\n\t\tphp_stream_pclose(stream);\n\t}\n\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ proto resource popen(string command, string mode)\n   Execute a command and open either a read or a write pipe to it */\nPHP_FUNCTION(popen)\n{\n\tchar *command, *mode;\n\tint command_len, mode_len;\n\tFILE *fp;\n\tphp_stream *stream;\n\tchar *posix_mode;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"ps\", &command, &command_len, &mode, &mode_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tposix_mode = estrndup(mode, mode_len);\n#ifndef PHP_WIN32\n\t{\n\t\tchar *z = memchr(posix_mode, 'b', mode_len);\n\t\tif (z) {\n\t\t\tmemmove(z, z + 1, mode_len - (z - posix_mode));\n\t\t}\n\t}\n#endif\n\n\tfp = VCWD_POPEN(command, posix_mode);\n\tif (!fp) {\n\t\tphp_error_docref2(NULL TSRMLS_CC, command, posix_mode, E_WARNING, \"%s\", strerror(errno));\n\t\tefree(posix_mode);\n\t\tRETURN_FALSE;\n\t}\n\n\tstream = php_stream_fopen_from_pipe(fp, mode);\n\n\tif (stream == NULL)\t{\n\t\tphp_error_docref2(NULL TSRMLS_CC, command, mode, E_WARNING, \"%s\", strerror(errno));\n\t\tRETVAL_FALSE;\n\t} else {\n\t\tphp_stream_to_zval(stream, return_value);\n\t}\n\n\tefree(posix_mode);\n}\n/* }}} */\n\n/* {{{ proto int pclose(resource fp)\n   Close a file pointer opened by popen() */\nPHP_FUNCTION(pclose)\n{\n\tzval *arg1;\n\tphp_stream *stream;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"r\", &arg1) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tPHP_STREAM_TO_ZVAL(stream, &arg1);\n\n\tFG(pclose_wait) = 1;\n\tzend_list_delete(stream->rsrc_id);\n\tFG(pclose_wait) = 0;\n\tRETURN_LONG(FG(pclose_ret));\n}\n/* }}} */\n\n/* {{{ proto bool feof(resource fp)\n   Test for end-of-file on a file pointer */\nPHPAPI PHP_FUNCTION(feof)\n{\n\tzval *arg1;\n\tphp_stream *stream;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"r\", &arg1) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tPHP_STREAM_TO_ZVAL(stream, &arg1);\n\n\tif (php_stream_eof(stream)) {\n\t\tRETURN_TRUE;\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n}\n/* }}} */\n\n/* {{{ proto string fgets(resource fp[, int length])\n   Get a line from file pointer */\nPHPAPI PHP_FUNCTION(fgets)\n{\n\tzval *arg1;\n\tlong len = 1024;\n\tchar *buf = NULL;\n\tint argc = ZEND_NUM_ARGS();\n\tsize_t line_len = 0;\n\tphp_stream *stream;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"r|l\", &arg1, &len) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tPHP_STREAM_TO_ZVAL(stream, &arg1);\n\n\tif (argc == 1) {\n\t\t/* ask streams to give us a buffer of an appropriate size */\n\t\tbuf = php_stream_get_line(stream, NULL, 0, &line_len);\n\t\tif (buf == NULL) {\n\t\t\tgoto exit_failed;\n\t\t}\n\t} else if (argc > 1) {\n\t\tif (len <= 0) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Length parameter must be greater than 0\");\n\t\t\tRETURN_FALSE;\n\t\t}\n\n\t\tbuf = ecalloc(len + 1, sizeof(char));\n\t\tif (php_stream_get_line(stream, buf, len, &line_len) == NULL) {\n\t\t\tgoto exit_failed;\n\t\t}\n\t}\n\n\tZVAL_STRINGL(return_value, buf, line_len, 0);\n\t/* resize buffer if it's much larger than the result.\n\t * Only needed if the user requested a buffer size. */\n\tif (argc > 1 && Z_STRLEN_P(return_value) < len / 2) {\n\t\tZ_STRVAL_P(return_value) = erealloc(buf, line_len + 1);\n\t}\n\treturn;\n\nexit_failed:\n\tRETVAL_FALSE;\n\tif (buf) {\n\t\tefree(buf);\n\t}\n}\n/* }}} */\n\n/* {{{ proto string fgetc(resource fp)\n   Get a character from file pointer */\nPHPAPI PHP_FUNCTION(fgetc)\n{\n\tzval *arg1;\n\tchar buf[2];\n\tint result;\n\tphp_stream *stream;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"r\", &arg1) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tPHP_STREAM_TO_ZVAL(stream, &arg1);\n\n\tresult = php_stream_getc(stream);\n\n\tif (result == EOF) {\n\t\tRETVAL_FALSE;\n\t} else {\n\t\tbuf[0] = result;\n\t\tbuf[1] = '\\0';\n\n\t\tRETURN_STRINGL(buf, 1, 1);\n\t}\n}\n/* }}} */\n\n/* {{{ proto string fgetss(resource fp [, int length [, string allowable_tags]])\n   Get a line from file pointer and strip HTML tags */\nPHPAPI PHP_FUNCTION(fgetss)\n{\n\tzval *fd;\n\tlong bytes = 0;\n\tsize_t len = 0;\n\tsize_t actual_len, retval_len;\n\tchar *buf = NULL, *retval;\n\tphp_stream *stream;\n\tchar *allowed_tags=NULL;\n\tint allowed_tags_len=0;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"r|ls\", &fd, &bytes, &allowed_tags, &allowed_tags_len) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tPHP_STREAM_TO_ZVAL(stream, &fd);\n\n\tif (ZEND_NUM_ARGS() >= 2) {\n\t\tif (bytes <= 0) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Length parameter must be greater than 0\");\n\t\t\tRETURN_FALSE;\n\t\t}\n\n\t\tlen = (size_t) bytes;\n\t\tbuf = safe_emalloc(sizeof(char), (len + 1), 0);\n\t\t/*needed because recv doesnt set null char at end*/\n\t\tmemset(buf, 0, len + 1);\n\t}\n\n\tif ((retval = php_stream_get_line(stream, buf, len, &actual_len)) == NULL)\t{\n\t\tif (buf != NULL) {\n\t\t\tefree(buf);\n\t\t}\n\t\tRETURN_FALSE;\n\t}\n\n\tretval_len = php_strip_tags(retval, actual_len, &stream->fgetss_state, allowed_tags, allowed_tags_len);\n\n\tRETURN_STRINGL(retval, retval_len, 0);\n}\n/* }}} */\n\n/* {{{ proto mixed fscanf(resource stream, string format [, string ...])\n   Implements a mostly ANSI compatible fscanf() */\nPHP_FUNCTION(fscanf)\n{\n\tint result, format_len, type, argc = 0;\n\tzval ***args = NULL;\n\tzval *file_handle;\n\tchar *buf, *format;\n\tsize_t len;\n\tvoid *what;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rs*\", &file_handle, &format, &format_len, &args, &argc) == FAILURE) {\n\t\treturn;\n\t}\n\n\twhat = zend_fetch_resource(&file_handle TSRMLS_CC, -1, \"File-Handle\", &type, 2, php_file_le_stream(), php_file_le_pstream());\n\n\t/* we can't do a ZEND_VERIFY_RESOURCE(what), otherwise we end up\n\t * with a leak if we have an invalid filehandle. This needs changing\n\t * if the code behind ZEND_VERIFY_RESOURCE changed. - cc */\n\tif (!what) {\n\t\tif (args) {\n\t\t\tefree(args);\n\t\t}\n\t\tRETURN_FALSE;\n\t}\n\n\tbuf = php_stream_get_line((php_stream *) what, NULL, 0, &len);\n\tif (buf == NULL) {\n\t\tif (args) {\n\t\t\tefree(args);\n\t\t}\n\t\tRETURN_FALSE;\n\t}\n\n\tresult = php_sscanf_internal(buf, format, argc, args, 0, &return_value TSRMLS_CC);\n\n\tif (args) {\n\t\tefree(args);\n\t}\n\tefree(buf);\n\n\tif (SCAN_ERROR_WRONG_PARAM_COUNT == result) {\n\t\tWRONG_PARAM_COUNT;\n\t}\n}\n/* }}} */\n\n/* {{{ proto int fwrite(resource fp, string str [, int length])\n   Binary-safe file write */\nPHPAPI PHP_FUNCTION(fwrite)\n{\n\tzval *arg1;\n\tchar *arg2;\n\tint arg2len;\n\tint ret;\n\tint num_bytes;\n\tlong arg3 = 0;\n\tchar *buffer = NULL;\n\tphp_stream *stream;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rs|l\", &arg1, &arg2, &arg2len, &arg3) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (ZEND_NUM_ARGS() == 2) {\n\t\tnum_bytes = arg2len;\n\t} else {\n\t\tnum_bytes = MAX(0, MIN((int)arg3, arg2len));\n\t}\n\n\tif (!num_bytes) {\n\t\tRETURN_LONG(0);\n\t}\n\n\tPHP_STREAM_TO_ZVAL(stream, &arg1);\n\n\tret = php_stream_write(stream, buffer ? buffer : arg2, num_bytes);\n\tif (buffer) {\n\t\tefree(buffer);\n\t}\n\n\tRETURN_LONG(ret);\n}\n/* }}} */\n\n/* {{{ proto bool fflush(resource fp)\n   Flushes output */\nPHPAPI PHP_FUNCTION(fflush)\n{\n\tzval *arg1;\n\tint ret;\n\tphp_stream *stream;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"r\", &arg1) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tPHP_STREAM_TO_ZVAL(stream, &arg1);\n\n\tret = php_stream_flush(stream);\n\tif (ret) {\n\t\tRETURN_FALSE;\n\t}\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ proto bool rewind(resource fp)\n   Rewind the position of a file pointer */\nPHPAPI PHP_FUNCTION(rewind)\n{\n\tzval *arg1;\n\tphp_stream *stream;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"r\", &arg1) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tPHP_STREAM_TO_ZVAL(stream, &arg1);\n\n\tif (-1 == php_stream_rewind(stream)) {\n\t\tRETURN_FALSE;\n\t}\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ proto int ftell(resource fp)\n   Get file pointer's read/write position */\nPHPAPI PHP_FUNCTION(ftell)\n{\n\tzval *arg1;\n\tlong ret;\n\tphp_stream *stream;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"r\", &arg1) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tPHP_STREAM_TO_ZVAL(stream, &arg1);\n\n\tret = php_stream_tell(stream);\n\tif (ret == -1)\t{\n\t\tRETURN_FALSE;\n\t}\n\tRETURN_LONG(ret);\n}\n/* }}} */\n\n/* {{{ proto int fseek(resource fp, int offset [, int whence])\n   Seek on a file pointer */\nPHPAPI PHP_FUNCTION(fseek)\n{\n\tzval *arg1;\n\tlong arg2, whence = SEEK_SET;\n\tphp_stream *stream;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rl|l\", &arg1, &arg2, &whence) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tPHP_STREAM_TO_ZVAL(stream, &arg1);\n\n\tRETURN_LONG(php_stream_seek(stream, arg2, whence));\n}\n/* }}} */\n\n/* {{{ php_mkdir\n*/\n\n/* DEPRECATED APIs: Use php_stream_mkdir() instead */\nPHPAPI int php_mkdir_ex(char *dir, long mode, int options TSRMLS_DC)\n{\n\tint ret;\n\n\tif (php_check_open_basedir(dir TSRMLS_CC)) {\n\t\treturn -1;\n\t}\n\n\tif ((ret = VCWD_MKDIR(dir, (mode_t)mode)) < 0 && (options & REPORT_ERRORS)) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"%s\", strerror(errno));\n\t}\n\n\treturn ret;\n}\n\nPHPAPI int php_mkdir(char *dir, long mode TSRMLS_DC)\n{\n\treturn php_mkdir_ex(dir, mode, REPORT_ERRORS TSRMLS_CC);\n}\n/* }}} */\n\n/* {{{ proto bool mkdir(string pathname [, int mode [, bool recursive [, resource context]]])\n   Create a directory */\nPHP_FUNCTION(mkdir)\n{\n\tchar *dir;\n\tint dir_len;\n\tzval *zcontext = NULL;\n\tlong mode = 0777;\n\tzend_bool recursive = 0;\n\tphp_stream_context *context;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"p|lbr\", &dir, &dir_len, &mode, &recursive, &zcontext) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tcontext = php_stream_context_from_zval(zcontext, 0);\n\n\tRETURN_BOOL(php_stream_mkdir(dir, mode, (recursive ? PHP_STREAM_MKDIR_RECURSIVE : 0) | REPORT_ERRORS, context));\n}\n/* }}} */\n\n/* {{{ proto bool rmdir(string dirname[, resource context])\n   Remove a directory */\nPHP_FUNCTION(rmdir)\n{\n\tchar *dir;\n\tint dir_len;\n\tzval *zcontext = NULL;\n\tphp_stream_context *context;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"p|r\", &dir, &dir_len, &zcontext) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tcontext = php_stream_context_from_zval(zcontext, 0);\n\n\tRETURN_BOOL(php_stream_rmdir(dir, REPORT_ERRORS, context));\n}\n/* }}} */\n\n/* {{{ proto int readfile(string filename [, bool use_include_path[, resource context]])\n   Output a file or a URL */\nPHP_FUNCTION(readfile)\n{\n\tchar *filename;\n\tint filename_len;\n\tint size = 0;\n\tzend_bool use_include_path = 0;\n\tzval *zcontext = NULL;\n\tphp_stream *stream;\n\tphp_stream_context *context = NULL;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"p|br!\", &filename, &filename_len, &use_include_path, &zcontext) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tcontext = php_stream_context_from_zval(zcontext, 0);\n\n\tstream = php_stream_open_wrapper_ex(filename, \"rb\", (use_include_path ? USE_PATH : 0) | REPORT_ERRORS, NULL, context);\n\tif (stream) {\n\t\tsize = php_stream_passthru(stream);\n\t\tphp_stream_close(stream);\n\t\tRETURN_LONG(size);\n\t}\n\n\tRETURN_FALSE;\n}\n/* }}} */\n\n/* {{{ proto int umask([int mask])\n   Return or change the umask */\nPHP_FUNCTION(umask)\n{\n\tlong arg1 = 0;\n\tint oldumask;\n\n\toldumask = umask(077);\n\n\tif (BG(umask) == -1) {\n\t\tBG(umask) = oldumask;\n\t}\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"|l\", &arg1) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (ZEND_NUM_ARGS() == 0) {\n\t\tumask(oldumask);\n\t} else {\n\t\tumask(arg1);\n\t}\n\n\tRETURN_LONG(oldumask);\n}\n/* }}} */\n\n/* {{{ proto int fpassthru(resource fp)\n   Output all remaining data from a file pointer */\nPHPAPI PHP_FUNCTION(fpassthru)\n{\n\tzval *arg1;\n\tint size;\n\tphp_stream *stream;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"r\", &arg1) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tPHP_STREAM_TO_ZVAL(stream, &arg1);\n\n\tsize = php_stream_passthru(stream);\n\tRETURN_LONG(size);\n}\n/* }}} */\n\n/* {{{ proto bool rename(string old_name, string new_name[, resource context])\n   Rename a file */\nPHP_FUNCTION(rename)\n{\n\tchar *old_name, *new_name;\n\tint old_name_len, new_name_len;\n\tzval *zcontext = NULL;\n\tphp_stream_wrapper *wrapper;\n\tphp_stream_context *context;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"pp|r\", &old_name, &old_name_len, &new_name, &new_name_len, &zcontext) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\twrapper = php_stream_locate_url_wrapper(old_name, NULL, 0 TSRMLS_CC);\n\n\tif (!wrapper || !wrapper->wops) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unable to locate stream wrapper\");\n\t\tRETURN_FALSE;\n\t}\n\n\tif (!wrapper->wops->rename) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"%s wrapper does not support renaming\", wrapper->wops->label ? wrapper->wops->label : \"Source\");\n\t\tRETURN_FALSE;\n\t}\n\n\tif (wrapper != php_stream_locate_url_wrapper(new_name, NULL, 0 TSRMLS_CC)) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Cannot rename a file across wrapper types\");\n\t\tRETURN_FALSE;\n\t}\n\n\tcontext = php_stream_context_from_zval(zcontext, 0);\n\n\tRETURN_BOOL(wrapper->wops->rename(wrapper, old_name, new_name, 0, context TSRMLS_CC));\n}\n/* }}} */\n\n/* {{{ proto bool unlink(string filename[, context context])\n   Delete a file */\nPHP_FUNCTION(unlink)\n{\n\tchar *filename;\n\tint filename_len;\n\tphp_stream_wrapper *wrapper;\n\tzval *zcontext = NULL;\n\tphp_stream_context *context = NULL;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"p|r\", &filename, &filename_len, &zcontext) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tcontext = php_stream_context_from_zval(zcontext, 0);\n\n\twrapper = php_stream_locate_url_wrapper(filename, NULL, 0 TSRMLS_CC);\n\n\tif (!wrapper || !wrapper->wops) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unable to locate stream wrapper\");\n\t\tRETURN_FALSE;\n\t}\n\n\tif (!wrapper->wops->unlink) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"%s does not allow unlinking\", wrapper->wops->label ? wrapper->wops->label : \"Wrapper\");\n\t\tRETURN_FALSE;\n\t}\n\tRETURN_BOOL(wrapper->wops->unlink(wrapper, filename, REPORT_ERRORS, context TSRMLS_CC));\n}\n/* }}} */\n\n/* {{{ proto bool ftruncate(resource fp, int size)\n   Truncate file to 'size' length */\nPHP_NAMED_FUNCTION(php_if_ftruncate)\n{\n\tzval *fp;\n\tlong size;\n\tphp_stream *stream;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rl\", &fp, &size) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tPHP_STREAM_TO_ZVAL(stream, &fp);\n\n\tif (!php_stream_truncate_supported(stream)) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Can't truncate this stream!\");\n\t\tRETURN_FALSE;\n\t}\n\n\tRETURN_BOOL(0 == php_stream_truncate_set_size(stream, size));\n}\n/* }}} */\n\n/* {{{ proto array fstat(resource fp)\n   Stat() on a filehandle */\nPHP_NAMED_FUNCTION(php_if_fstat)\n{\n\tzval *fp;\n\tzval *stat_dev, *stat_ino, *stat_mode, *stat_nlink, *stat_uid, *stat_gid, *stat_rdev,\n\t\t *stat_size, *stat_atime, *stat_mtime, *stat_ctime, *stat_blksize, *stat_blocks;\n\tphp_stream *stream;\n\tphp_stream_statbuf stat_ssb;\n\tchar *stat_sb_names[13] = {\n\t\t\"dev\", \"ino\", \"mode\", \"nlink\", \"uid\", \"gid\", \"rdev\",\n\t\t\"size\", \"atime\", \"mtime\", \"ctime\", \"blksize\", \"blocks\"\n\t};\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"r\", &fp) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tPHP_STREAM_TO_ZVAL(stream, &fp);\n\n\tif (php_stream_stat(stream, &stat_ssb)) {\n\t\tRETURN_FALSE;\n\t}\n\n\tarray_init(return_value);\n\n\tMAKE_LONG_ZVAL_INCREF(stat_dev, stat_ssb.sb.st_dev);\n\tMAKE_LONG_ZVAL_INCREF(stat_ino, stat_ssb.sb.st_ino);\n\tMAKE_LONG_ZVAL_INCREF(stat_mode, stat_ssb.sb.st_mode);\n\tMAKE_LONG_ZVAL_INCREF(stat_nlink, stat_ssb.sb.st_nlink);\n\tMAKE_LONG_ZVAL_INCREF(stat_uid, stat_ssb.sb.st_uid);\n\tMAKE_LONG_ZVAL_INCREF(stat_gid, stat_ssb.sb.st_gid);\n#ifdef HAVE_ST_RDEV\n\tMAKE_LONG_ZVAL_INCREF(stat_rdev, stat_ssb.sb.st_rdev);\n#else\n\tMAKE_LONG_ZVAL_INCREF(stat_rdev, -1);\n#endif\n\tMAKE_LONG_ZVAL_INCREF(stat_size, stat_ssb.sb.st_size);\n\tMAKE_LONG_ZVAL_INCREF(stat_atime, stat_ssb.sb.st_atime);\n\tMAKE_LONG_ZVAL_INCREF(stat_mtime, stat_ssb.sb.st_mtime);\n\tMAKE_LONG_ZVAL_INCREF(stat_ctime, stat_ssb.sb.st_ctime);\n#ifdef HAVE_ST_BLKSIZE\n\tMAKE_LONG_ZVAL_INCREF(stat_blksize, stat_ssb.sb.st_blksize);\n#else\n\tMAKE_LONG_ZVAL_INCREF(stat_blksize,-1);\n#endif\n#ifdef HAVE_ST_BLOCKS\n\tMAKE_LONG_ZVAL_INCREF(stat_blocks, stat_ssb.sb.st_blocks);\n#else\n\tMAKE_LONG_ZVAL_INCREF(stat_blocks,-1);\n#endif\n\t/* Store numeric indexes in propper order */\n\tzend_hash_next_index_insert(HASH_OF(return_value), (void *)&stat_dev, sizeof(zval *), NULL);\n\tzend_hash_next_index_insert(HASH_OF(return_value), (void *)&stat_ino, sizeof(zval *), NULL);\n\tzend_hash_next_index_insert(HASH_OF(return_value), (void *)&stat_mode, sizeof(zval *), NULL);\n\tzend_hash_next_index_insert(HASH_OF(return_value), (void *)&stat_nlink, sizeof(zval *), NULL);\n\tzend_hash_next_index_insert(HASH_OF(return_value), (void *)&stat_uid, sizeof(zval *), NULL);\n\tzend_hash_next_index_insert(HASH_OF(return_value), (void *)&stat_gid, sizeof(zval *), NULL);\n\tzend_hash_next_index_insert(HASH_OF(return_value), (void *)&stat_rdev, sizeof(zval *), NULL);\n\tzend_hash_next_index_insert(HASH_OF(return_value), (void *)&stat_size, sizeof(zval *), NULL);\n\tzend_hash_next_index_insert(HASH_OF(return_value), (void *)&stat_atime, sizeof(zval *), NULL);\n\tzend_hash_next_index_insert(HASH_OF(return_value), (void *)&stat_mtime, sizeof(zval *), NULL);\n\tzend_hash_next_index_insert(HASH_OF(return_value), (void *)&stat_ctime, sizeof(zval *), NULL);\n\tzend_hash_next_index_insert(HASH_OF(return_value), (void *)&stat_blksize, sizeof(zval *), NULL);\n\tzend_hash_next_index_insert(HASH_OF(return_value), (void *)&stat_blocks, sizeof(zval *), NULL);\n\n\t/* Store string indexes referencing the same zval*/\n\tzend_hash_update(HASH_OF(return_value), stat_sb_names[0], strlen(stat_sb_names[0])+1, (void *)&stat_dev, sizeof(zval *), NULL);\n\tzend_hash_update(HASH_OF(return_value), stat_sb_names[1], strlen(stat_sb_names[1])+1, (void *)&stat_ino, sizeof(zval *), NULL);\n\tzend_hash_update(HASH_OF(return_value), stat_sb_names[2], strlen(stat_sb_names[2])+1, (void *)&stat_mode, sizeof(zval *), NULL);\n\tzend_hash_update(HASH_OF(return_value), stat_sb_names[3], strlen(stat_sb_names[3])+1, (void *)&stat_nlink, sizeof(zval *), NULL);\n\tzend_hash_update(HASH_OF(return_value), stat_sb_names[4], strlen(stat_sb_names[4])+1, (void *)&stat_uid, sizeof(zval *), NULL);\n\tzend_hash_update(HASH_OF(return_value), stat_sb_names[5], strlen(stat_sb_names[5])+1, (void *)&stat_gid, sizeof(zval *), NULL);\n\tzend_hash_update(HASH_OF(return_value), stat_sb_names[6], strlen(stat_sb_names[6])+1, (void *)&stat_rdev, sizeof(zval *), NULL);\n\tzend_hash_update(HASH_OF(return_value), stat_sb_names[7], strlen(stat_sb_names[7])+1, (void *)&stat_size, sizeof(zval *), NULL);\n\tzend_hash_update(HASH_OF(return_value), stat_sb_names[8], strlen(stat_sb_names[8])+1, (void *)&stat_atime, sizeof(zval *), NULL);\n\tzend_hash_update(HASH_OF(return_value), stat_sb_names[9], strlen(stat_sb_names[9])+1, (void *)&stat_mtime, sizeof(zval *), NULL);\n\tzend_hash_update(HASH_OF(return_value), stat_sb_names[10], strlen(stat_sb_names[10])+1, (void *)&stat_ctime, sizeof(zval *), NULL);\n\tzend_hash_update(HASH_OF(return_value), stat_sb_names[11], strlen(stat_sb_names[11])+1, (void *)&stat_blksize, sizeof(zval *), NULL);\n\tzend_hash_update(HASH_OF(return_value), stat_sb_names[12], strlen(stat_sb_names[12])+1, (void *)&stat_blocks, sizeof(zval *), NULL);\n}\n/* }}} */\n\n/* {{{ proto bool copy(string source_file, string destination_file [, resource context])\n   Copy a file */\nPHP_FUNCTION(copy)\n{\n\tchar *source, *target;\n\tint source_len, target_len;\n\tzval *zcontext = NULL;\n\tphp_stream_context *context;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"pp|r\", &source, &source_len, &target, &target_len, &zcontext) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (php_check_open_basedir(source TSRMLS_CC)) {\n\t\tRETURN_FALSE;\n\t}\n\n\tcontext = php_stream_context_from_zval(zcontext, 0);\n\n\tif (php_copy_file_ctx(source, target, 0, context TSRMLS_CC) == SUCCESS) {\n\t\tRETURN_TRUE;\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n}\n/* }}} */\n\n/* {{{ php_copy_file\n */\nPHPAPI int php_copy_file(char *src, char *dest TSRMLS_DC)\n{\n\treturn php_copy_file_ctx(src, dest, 0, NULL TSRMLS_CC);\n}\n/* }}} */\n\n/* {{{ php_copy_file_ex\n */\nPHPAPI int php_copy_file_ex(char *src, char *dest, int src_flg TSRMLS_DC)\n{\n\treturn php_copy_file_ctx(src, dest, 0, NULL TSRMLS_CC);\n}\n/* }}} */\n\n/* {{{ php_copy_file_ctx\n */\nPHPAPI int php_copy_file_ctx(char *src, char *dest, int src_flg, php_stream_context *ctx TSRMLS_DC)\n{\n\tphp_stream *srcstream = NULL, *deststream = NULL;\n\tint ret = FAILURE;\n\tphp_stream_statbuf src_s, dest_s;\n\n\tswitch (php_stream_stat_path_ex(src, 0, &src_s, ctx)) {\n\t\tcase -1:\n\t\t\t/* non-statable stream */\n\t\t\tgoto safe_to_copy;\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tbreak;\n\t\tdefault: /* failed to stat file, does not exist? */\n\t\t\treturn ret;\n\t}\n\tif (S_ISDIR(src_s.sb.st_mode)) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"The first argument to copy() function cannot be a directory\");\n\t\treturn FAILURE;\n\t}\n\n\tswitch (php_stream_stat_path_ex(dest, PHP_STREAM_URL_STAT_QUIET | PHP_STREAM_URL_STAT_NOCACHE, &dest_s, ctx)) {\n\t\tcase -1:\n\t\t\t/* non-statable stream */\n\t\t\tgoto safe_to_copy;\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tbreak;\n\t\tdefault: /* failed to stat file, does not exist? */\n\t\t\treturn ret;\n\t}\n\tif (S_ISDIR(dest_s.sb.st_mode)) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"The second argument to copy() function cannot be a directory\");\n\t\treturn FAILURE;\n\t}\n\tif (!src_s.sb.st_ino || !dest_s.sb.st_ino) {\n\t\tgoto no_stat;\n\t}\n\tif (src_s.sb.st_ino == dest_s.sb.st_ino && src_s.sb.st_dev == dest_s.sb.st_dev) {\n\t\treturn ret;\n\t} else {\n\t\tgoto safe_to_copy;\n\t}\nno_stat:\n\t{\n\t\tchar *sp, *dp;\n\t\tint res;\n\n\t\tif ((sp = expand_filepath(src, NULL TSRMLS_CC)) == NULL) {\n\t\t\treturn ret;\n\t\t}\n\t\tif ((dp = expand_filepath(dest, NULL TSRMLS_CC)) == NULL) {\n\t\t\tefree(sp);\n\t\t\tgoto safe_to_copy;\n\t\t}\n\n\t\tres =\n#ifndef PHP_WIN32\n\t\t\t!strcmp(sp, dp);\n#else\n\t\t\t!strcasecmp(sp, dp);\n#endif\n\n\t\tefree(sp);\n\t\tefree(dp);\n\t\tif (res) {\n\t\t\treturn ret;\n\t\t}\n\t}\nsafe_to_copy:\n\n\tsrcstream = php_stream_open_wrapper_ex(src, \"rb\", src_flg | REPORT_ERRORS, NULL, ctx);\n\n\tif (!srcstream) {\n\t\treturn ret;\n\t}\n\n\tdeststream = php_stream_open_wrapper_ex(dest, \"wb\", REPORT_ERRORS, NULL, ctx);\n\n\tif (srcstream && deststream) {\n\t\tret = php_stream_copy_to_stream_ex(srcstream, deststream, PHP_STREAM_COPY_ALL, NULL);\n\t}\n\tif (srcstream) {\n\t\tphp_stream_close(srcstream);\n\t}\n\tif (deststream) {\n\t\tphp_stream_close(deststream);\n\t}\n\treturn ret;\n}\n/* }}} */\n\n/* {{{ proto string fread(resource fp, int length)\n   Binary-safe file read */\nPHPAPI PHP_FUNCTION(fread)\n{\n\tzval *arg1;\n\tlong len;\n\tphp_stream *stream;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rl\", &arg1, &len) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tPHP_STREAM_TO_ZVAL(stream, &arg1);\n\n\tif (len <= 0) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Length parameter must be greater than 0\");\n\t\tRETURN_FALSE;\n\t}\n\n\tif (len > INT_MAX) {\n\t\t/* string length is int in 5.x so we can not read more than int */\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Length parameter must be no more than %d\", INT_MAX);\n\t\tRETURN_FALSE;\n\t}\n\n\tZ_STRVAL_P(return_value) = emalloc(len + 1);\n\tZ_STRLEN_P(return_value) = php_stream_read(stream, Z_STRVAL_P(return_value), len);\n\n\t/* needed because recv/read/gzread doesnt put a null at the end*/\n\tZ_STRVAL_P(return_value)[Z_STRLEN_P(return_value)] = 0;\n\tZ_TYPE_P(return_value) = IS_STRING;\n}\n/* }}} */\n\nstatic const char *php_fgetcsv_lookup_trailing_spaces(const char *ptr, size_t len, const char delimiter TSRMLS_DC) /* {{{ */\n{\n\tint inc_len;\n\tunsigned char last_chars[2] = { 0, 0 };\n\n\twhile (len > 0) {\n\t\tinc_len = (*ptr == '\\0' ? 1: php_mblen(ptr, len));\n\t\tswitch (inc_len) {\n\t\t\tcase -2:\n\t\t\tcase -1:\n\t\t\t\tinc_len = 1;\n\t\t\t\tphp_ignore_value(php_mblen(NULL, 0));\n\t\t\t\tbreak;\n\t\t\tcase 0:\n\t\t\t\tgoto quit_loop;\n\t\t\tcase 1:\n\t\t\tdefault:\n\t\t\t\tlast_chars[0] = last_chars[1];\n\t\t\t\tlast_chars[1] = *ptr;\n\t\t\t\tbreak;\n\t\t}\n\t\tptr += inc_len;\n\t\tlen -= inc_len;\n\t}\nquit_loop:\n\tswitch (last_chars[1]) {\n\t\tcase '\\n':\n\t\t\tif (last_chars[0] == '\\r') {\n\t\t\t\treturn ptr - 2;\n\t\t\t}\n\t\t\t/* break is omitted intentionally */\n\t\tcase '\\r':\n\t\t\treturn ptr - 1;\n\t}\n\treturn ptr;\n}\n/* }}} */\n\n#define FPUTCSV_FLD_CHK(c) memchr(Z_STRVAL(field), c, Z_STRLEN(field))\n\n/* {{{ proto int fputcsv(resource fp, array fields [, string delimiter [, string enclosure [, string escape_char]]])\n   Format line as CSV and write to file pointer */\nPHP_FUNCTION(fputcsv)\n{\n\tchar delimiter = ',';\t /* allow this to be set as parameter */\n\tchar enclosure = '\"';\t /* allow this to be set as parameter */\n\tchar escape_char = '\\\\'; /* allow this to be set as parameter */\n\tphp_stream *stream;\n\tzval *fp = NULL, *fields = NULL;\n\tint ret;\n\tchar *delimiter_str = NULL, *enclosure_str = NULL, *escape_str = NULL;\n\tint delimiter_str_len = 0, enclosure_str_len = 0, escape_str_len = 0;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"ra|sss\",\n\t\t\t&fp, &fields, &delimiter_str, &delimiter_str_len,\n\t\t\t&enclosure_str, &enclosure_str_len,\n\t\t\t&escape_str, &escape_str_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (delimiter_str != NULL) {\n\t\t/* Make sure that there is at least one character in string */\n\t\tif (delimiter_str_len < 1) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"delimiter must be a character\");\n\t\t\tRETURN_FALSE;\n\t\t} else if (delimiter_str_len > 1) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_NOTICE, \"delimiter must be a single character\");\n\t\t}\n\n\t\t/* use first character from string */\n\t\tdelimiter = *delimiter_str;\n\t}\n\n\tif (enclosure_str != NULL) {\n\t\tif (enclosure_str_len < 1) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"enclosure must be a character\");\n\t\t\tRETURN_FALSE;\n\t\t} else if (enclosure_str_len > 1) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_NOTICE, \"enclosure must be a single character\");\n\t\t}\n\t\t/* use first character from string */\n\t\tenclosure = *enclosure_str;\n\t}\n\n\tif (escape_str != NULL) {\n\t\tif (escape_str_len < 1) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"escape must be a character\");\n\t\t\tRETURN_FALSE;\n\t\t} else if (escape_str_len > 1) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_NOTICE, \"escape must be a single character\");\n\t\t}\n\t\t/* use first character from string */\n\t\tescape_char = *escape_str;\n\t}\n\n\tPHP_STREAM_TO_ZVAL(stream, &fp);\n\n\tret = php_fputcsv(stream, fields, delimiter, enclosure, escape_char TSRMLS_CC);\n\tRETURN_LONG(ret);\n}\n/* }}} */\n\n/* {{{ PHPAPI int php_fputcsv(php_stream *stream, zval *fields, char delimiter, char enclosure, char escape_char TSRMLS_DC) */\nPHPAPI int php_fputcsv(php_stream *stream, zval *fields, char delimiter, char enclosure, char escape_char TSRMLS_DC)\n{\n\tint count, i = 0, ret;\n\tzval **field_tmp = NULL, field;\n\tsmart_str csvline = {0};\n\tHashPosition pos;\n\n\tcount = zend_hash_num_elements(Z_ARRVAL_P(fields));\n\tzend_hash_internal_pointer_reset_ex(Z_ARRVAL_P(fields), &pos);\n\twhile (zend_hash_get_current_data_ex(Z_ARRVAL_P(fields), (void **) &field_tmp, &pos) == SUCCESS) {\n\t\tfield = **field_tmp;\n\n\t\tif (Z_TYPE_PP(field_tmp) != IS_STRING) {\n\t\t\tzval_copy_ctor(&field);\n\t\t\tconvert_to_string(&field);\n\t\t}\n\n\t\t/* enclose a field that contains a delimiter, an enclosure character, or a newline */\n\t\tif (FPUTCSV_FLD_CHK(delimiter) ||\n\t\t\tFPUTCSV_FLD_CHK(enclosure) ||\n\t\t\tFPUTCSV_FLD_CHK(escape_char) ||\n\t\t\tFPUTCSV_FLD_CHK('\\n') ||\n\t\t\tFPUTCSV_FLD_CHK('\\r') ||\n\t\t\tFPUTCSV_FLD_CHK('\\t') ||\n\t\t\tFPUTCSV_FLD_CHK(' ')\n\t\t) {\n\t\t\tchar *ch = Z_STRVAL(field);\n\t\t\tchar *end = ch + Z_STRLEN(field);\n\t\t\tint escaped = 0;\n\n\t\t\tsmart_str_appendc(&csvline, enclosure);\n\t\t\twhile (ch < end) {\n\t\t\t\tif (*ch == escape_char) {\n\t\t\t\t\tescaped = 1;\n\t\t\t\t} else if (!escaped && *ch == enclosure) {\n\t\t\t\t\tsmart_str_appendc(&csvline, enclosure);\n\t\t\t\t} else {\n\t\t\t\t\tescaped = 0;\n\t\t\t\t}\n\t\t\t\tsmart_str_appendc(&csvline, *ch);\n\t\t\t\tch++;\n\t\t\t}\n\t\t\tsmart_str_appendc(&csvline, enclosure);\n\t\t} else {\n\t\t\tsmart_str_appendl(&csvline, Z_STRVAL(field), Z_STRLEN(field));\n\t\t}\n\n\t\tif (++i != count) {\n\t\t\tsmart_str_appendl(&csvline, &delimiter, 1);\n\t\t}\n\t\tzend_hash_move_forward_ex(Z_ARRVAL_P(fields), &pos);\n\n\t\tif (Z_TYPE_PP(field_tmp) != IS_STRING) {\n\t\t\tzval_dtor(&field);\n\t\t}\n\t}\n\n\tsmart_str_appendc(&csvline, '\\n');\n\tsmart_str_0(&csvline);\n\n\tret = php_stream_write(stream, csvline.c, csvline.len);\n\n\tsmart_str_free(&csvline);\n\n\treturn ret;\n}\n/* }}} */\n\n/* {{{ proto array fgetcsv(resource fp [,int length [, string delimiter [, string enclosure [, string escape]]]])\n   Get line from file pointer and parse for CSV fields */\nPHP_FUNCTION(fgetcsv)\n{\n\tchar delimiter = ',';\t/* allow this to be set as parameter */\n\tchar enclosure = '\"';\t/* allow this to be set as parameter */\n\tchar escape = '\\\\';\n\n\t/* first section exactly as php_fgetss */\n\n\tlong len = 0;\n\tsize_t buf_len;\n\tchar *buf;\n\tphp_stream *stream;\n\n\t{\n\t\tzval *fd, **len_zv = NULL;\n\t\tchar *delimiter_str = NULL;\n\t\tint delimiter_str_len = 0;\n\t\tchar *enclosure_str = NULL;\n\t\tint enclosure_str_len = 0;\n\t\tchar *escape_str = NULL;\n\t\tint escape_str_len = 0;\n\n\t\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"r|Zsss\",\n\t\t\t&fd, &len_zv, &delimiter_str, &delimiter_str_len,\n\t\t\t&enclosure_str, &enclosure_str_len,\n\t\t\t&escape_str, &escape_str_len) == FAILURE\n\t\t) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (delimiter_str != NULL) {\n\t\t\t/* Make sure that there is at least one character in string */\n\t\t\tif (delimiter_str_len < 1) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"delimiter must be a character\");\n\t\t\t\tRETURN_FALSE;\n\t\t\t} else if (delimiter_str_len > 1) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_NOTICE, \"delimiter must be a single character\");\n\t\t\t}\n\n\t\t\t/* use first character from string */\n\t\t\tdelimiter = delimiter_str[0];\n\t\t}\n\n\t\tif (enclosure_str != NULL) {\n\t\t\tif (enclosure_str_len < 1) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"enclosure must be a character\");\n\t\t\t\tRETURN_FALSE;\n\t\t\t} else if (enclosure_str_len > 1) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_NOTICE, \"enclosure must be a single character\");\n\t\t\t}\n\n\t\t\t/* use first character from string */\n\t\t\tenclosure = enclosure_str[0];\n\t\t}\n\n\t\tif (escape_str != NULL) {\n\t\t\tif (escape_str_len < 1) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"escape must be character\");\n\t\t\t\tRETURN_FALSE;\n\t\t\t} else if (escape_str_len > 1) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_NOTICE, \"escape must be a single character\");\n\t\t\t}\n\n\t\t\tescape = escape_str[0];\n\t\t}\n\n\t\tif (len_zv != NULL && Z_TYPE_PP(len_zv) != IS_NULL) {\n\t\t\tconvert_to_long_ex(len_zv);\n\t\t\tlen = Z_LVAL_PP(len_zv);\n\t\t\tif (len < 0) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Length parameter may not be negative\");\n\t\t\t\tRETURN_FALSE;\n\t\t\t} else if (len == 0) {\n\t\t\t\tlen = -1;\n\t\t\t}\n\t\t} else {\n\t\t\tlen = -1;\n\t\t}\n\n\t\tPHP_STREAM_TO_ZVAL(stream, &fd);\n\t}\n\n\tif (len < 0) {\n\t\tif ((buf = php_stream_get_line(stream, NULL, 0, &buf_len)) == NULL) {\n\t\t\tRETURN_FALSE;\n\t\t}\n\t} else {\n\t\tbuf = emalloc(len + 1);\n\t\tif (php_stream_get_line(stream, buf, len + 1, &buf_len) == NULL) {\n\t\t\tefree(buf);\n\t\t\tRETURN_FALSE;\n\t\t}\n\t}\n\n\tphp_fgetcsv(stream, delimiter, enclosure, escape, buf_len, buf, return_value TSRMLS_CC);\n}\n/* }}} */\n\nPHPAPI void php_fgetcsv(php_stream *stream, char delimiter, char enclosure, char escape_char, size_t buf_len, char *buf, zval *return_value TSRMLS_DC) /* {{{ */\n{\n\tchar *temp, *tptr, *bptr, *line_end, *limit;\n\tsize_t temp_len, line_end_len;\n\tint inc_len;\n\tzend_bool first_field = 1;\n\n\t/* initialize internal state */\n\tphp_ignore_value(php_mblen(NULL, 0));\n\n\t/* Now into new section that parses buf for delimiter/enclosure fields */\n\n\t/* Strip trailing space from buf, saving end of line in case required for enclosure field */\n\n\tbptr = buf;\n\ttptr = (char *)php_fgetcsv_lookup_trailing_spaces(buf, buf_len, delimiter TSRMLS_CC);\n\tline_end_len = buf_len - (size_t)(tptr - buf);\n\tline_end = limit = tptr;\n\n\t/* reserve workspace for building each individual field */\n\ttemp_len = buf_len;\n\ttemp = emalloc(temp_len + line_end_len + 1);\n\n\t/* Initialize return array */\n\tarray_init(return_value);\n\n\t/* Main loop to read CSV fields */\n\t/* NB this routine will return a single null entry for a blank line */\n\n\tdo {\n\t\tchar *comp_end, *hunk_begin;\n\n\t\ttptr = temp;\n\n\t\tinc_len = (bptr < limit ? (*bptr == '\\0' ? 1: php_mblen(bptr, limit - bptr)): 0);\n\t\tif (inc_len == 1) {\n\t\t\tchar *tmp = bptr;\n\t\t\twhile ((*tmp != delimiter) && isspace((int)*(unsigned char *)tmp)) {\n\t\t\t\ttmp++;\n  \t\t\t}\n\t\t\tif (*tmp == enclosure) {\n\t\t\t\tbptr = tmp;\n\t\t\t}\n  \t\t}\n\n\t\tif (first_field && bptr == line_end) {\n\t\t\tadd_next_index_null(return_value);\n\t\t\tbreak;\n\t\t}\n\t\tfirst_field = 0;\n\t\t/* 2. Read field, leaving bptr pointing at start of next field */\n\t\tif (inc_len != 0 && *bptr == enclosure) {\n\t\t\tint state = 0;\n\n\t\t\tbptr++;\t/* move on to first character in field */\n\t\t\thunk_begin = bptr;\n\n\t\t\t/* 2A. handle enclosure delimited field */\n\t\t\tfor (;;) {\n\t\t\t\tswitch (inc_len) {\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tswitch (state) {\n\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\t\tmemcpy(tptr, hunk_begin, bptr - hunk_begin - 1);\n\t\t\t\t\t\t\t\ttptr += (bptr - hunk_begin - 1);\n\t\t\t\t\t\t\t\thunk_begin = bptr;\n\t\t\t\t\t\t\t\tgoto quit_loop_2;\n\n\t\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\t\tmemcpy(tptr, hunk_begin, bptr - hunk_begin);\n\t\t\t\t\t\t\t\ttptr += (bptr - hunk_begin);\n\t\t\t\t\t\t\t\thunk_begin = bptr;\n\t\t\t\t\t\t\t\t/* break is omitted intentionally */\n\n\t\t\t\t\t\t\tcase 0: {\n\t\t\t\t\t\t\t\tchar *new_buf;\n\t\t\t\t\t\t\t\tsize_t new_len;\n\t\t\t\t\t\t\t\tchar *new_temp;\n\n\t\t\t\t\t\t\t\tif (hunk_begin != line_end) {\n\t\t\t\t\t\t\t\t\tmemcpy(tptr, hunk_begin, bptr - hunk_begin);\n\t\t\t\t\t\t\t\t\ttptr += (bptr - hunk_begin);\n\t\t\t\t\t\t\t\t\thunk_begin = bptr;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t/* add the embedded line end to the field */\n\t\t\t\t\t\t\t\tmemcpy(tptr, line_end, line_end_len);\n\t\t\t\t\t\t\t\ttptr += line_end_len;\n\n\t\t\t\t\t\t\t\tif (stream == NULL) {\n\t\t\t\t\t\t\t\t\tgoto quit_loop_2;\n\t\t\t\t\t\t\t\t} else if ((new_buf = php_stream_get_line(stream, NULL, 0, &new_len)) == NULL) {\n\t\t\t\t\t\t\t\t\t/* we've got an unterminated enclosure,\n\t\t\t\t\t\t\t\t\t * assign all the data from the start of\n\t\t\t\t\t\t\t\t\t * the enclosure to end of data to the\n\t\t\t\t\t\t\t\t\t * last element */\n\t\t\t\t\t\t\t\t\tif ((size_t)temp_len > (size_t)(limit - buf)) {\n\t\t\t\t\t\t\t\t\t\tgoto quit_loop_2;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tzval_dtor(return_value);\n\t\t\t\t\t\t\t\t\tRETVAL_FALSE;\n\t\t\t\t\t\t\t\t\tgoto out;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\ttemp_len += new_len;\n\t\t\t\t\t\t\t\tnew_temp = erealloc(temp, temp_len);\n\t\t\t\t\t\t\t\ttptr = new_temp + (size_t)(tptr - temp);\n\t\t\t\t\t\t\t\ttemp = new_temp;\n\n\t\t\t\t\t\t\t\tefree(buf);\n\t\t\t\t\t\t\t\tbuf_len = new_len;\n\t\t\t\t\t\t\t\tbptr = buf = new_buf;\n\t\t\t\t\t\t\t\thunk_begin = buf;\n\n\t\t\t\t\t\t\t\tline_end = limit = (char *)php_fgetcsv_lookup_trailing_spaces(buf, buf_len, delimiter TSRMLS_CC);\n\t\t\t\t\t\t\t\tline_end_len = buf_len - (size_t)(limit - buf);\n\n\t\t\t\t\t\t\t\tstate = 0;\n\t\t\t\t\t\t\t} break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase -2:\n\t\t\t\t\tcase -1:\n\t\t\t\t\t\tphp_ignore_value(php_mblen(NULL, 0));\n\t\t\t\t\t\t/* break is omitted intentionally */\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\t/* we need to determine if the enclosure is\n\t\t\t\t\t\t * 'real' or is it escaped */\n\t\t\t\t\t\tswitch (state) {\n\t\t\t\t\t\t\tcase 1: /* escaped */\n\t\t\t\t\t\t\t\tbptr++;\n\t\t\t\t\t\t\t\tstate = 0;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 2: /* embedded enclosure ? let's check it */\n\t\t\t\t\t\t\t\tif (*bptr != enclosure) {\n\t\t\t\t\t\t\t\t\t/* real enclosure */\n\t\t\t\t\t\t\t\t\tmemcpy(tptr, hunk_begin, bptr - hunk_begin - 1);\n\t\t\t\t\t\t\t\t\ttptr += (bptr - hunk_begin - 1);\n\t\t\t\t\t\t\t\t\thunk_begin = bptr;\n\t\t\t\t\t\t\t\t\tgoto quit_loop_2;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tmemcpy(tptr, hunk_begin, bptr - hunk_begin);\n\t\t\t\t\t\t\t\ttptr += (bptr - hunk_begin);\n\t\t\t\t\t\t\t\tbptr++;\n\t\t\t\t\t\t\t\thunk_begin = bptr;\n\t\t\t\t\t\t\t\tstate = 0;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tif (*bptr == enclosure) {\n\t\t\t\t\t\t\t\t\tstate = 2;\n\t\t\t\t\t\t\t\t} else if (*bptr == escape_char) {\n\t\t\t\t\t\t\t\t\tstate = 1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbptr++;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tswitch (state) {\n\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\t\t/* real enclosure */\n\t\t\t\t\t\t\t\tmemcpy(tptr, hunk_begin, bptr - hunk_begin - 1);\n\t\t\t\t\t\t\t\ttptr += (bptr - hunk_begin - 1);\n\t\t\t\t\t\t\t\thunk_begin = bptr;\n\t\t\t\t\t\t\t\tgoto quit_loop_2;\n\t\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\t\tbptr += inc_len;\n\t\t\t\t\t\t\t\tmemcpy(tptr, hunk_begin, bptr - hunk_begin);\n\t\t\t\t\t\t\t\ttptr += (bptr - hunk_begin);\n\t\t\t\t\t\t\t\thunk_begin = bptr;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tbptr += inc_len;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tinc_len = (bptr < limit ? (*bptr == '\\0' ? 1: php_mblen(bptr, limit - bptr)): 0);\n\t\t\t}\n\n\t\tquit_loop_2:\n\t\t\t/* look up for a delimiter */\n\t\t\tfor (;;) {\n\t\t\t\tswitch (inc_len) {\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tgoto quit_loop_3;\n\n\t\t\t\t\tcase -2:\n\t\t\t\t\tcase -1:\n\t\t\t\t\t\tinc_len = 1;\n\t\t\t\t\t\tphp_ignore_value(php_mblen(NULL, 0));\n\t\t\t\t\t\t/* break is omitted intentionally */\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tif (*bptr == delimiter) {\n\t\t\t\t\t\t\tgoto quit_loop_3;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbptr += inc_len;\n\t\t\t\tinc_len = (bptr < limit ? (*bptr == '\\0' ? 1: php_mblen(bptr, limit - bptr)): 0);\n\t\t\t}\n\n\t\tquit_loop_3:\n\t\t\tmemcpy(tptr, hunk_begin, bptr - hunk_begin);\n\t\t\ttptr += (bptr - hunk_begin);\n\t\t\tbptr += inc_len;\n\t\t\tcomp_end = tptr;\n\t\t} else {\n\t\t\t/* 2B. Handle non-enclosure field */\n\n\t\t\thunk_begin = bptr;\n\n\t\t\tfor (;;) {\n\t\t\t\tswitch (inc_len) {\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tgoto quit_loop_4;\n\t\t\t\t\tcase -2:\n\t\t\t\t\tcase -1:\n\t\t\t\t\t\tinc_len = 1;\n\t\t\t\t\t\tphp_ignore_value(php_mblen(NULL, 0));\n\t\t\t\t\t\t/* break is omitted intentionally */\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tif (*bptr == delimiter) {\n\t\t\t\t\t\t\tgoto quit_loop_4;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbptr += inc_len;\n\t\t\t\tinc_len = (bptr < limit ? (*bptr == '\\0' ? 1: php_mblen(bptr, limit - bptr)): 0);\n\t\t\t}\n\t\tquit_loop_4:\n\t\t\tmemcpy(tptr, hunk_begin, bptr - hunk_begin);\n\t\t\ttptr += (bptr - hunk_begin);\n\n\t\t\tcomp_end = (char *)php_fgetcsv_lookup_trailing_spaces(temp, tptr - temp, delimiter TSRMLS_CC);\n\t\t\tif (*bptr == delimiter) {\n\t\t\t\tbptr++;\n\t\t\t}\n\t\t}\n\n\t\t/* 3. Now pass our field back to php */\n\t\t*comp_end = '\\0';\n\t\tadd_next_index_stringl(return_value, temp, comp_end - temp, 1);\n\t} while (inc_len > 0);\n\nout:\n\tefree(temp);\n\tif (stream) {\n\t\tefree(buf);\n\t}\n}\n/* }}} */\n\n#if (!defined(__BEOS__) && !defined(NETWARE) && HAVE_REALPATH) || defined(ZTS)\n/* {{{ proto string realpath(string path)\n   Return the resolved path */\nPHP_FUNCTION(realpath)\n{\n\tchar *filename;\n\tint filename_len;\n\tchar resolved_path_buff[MAXPATHLEN];\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"p\", &filename, &filename_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (VCWD_REALPATH(filename, resolved_path_buff)) {\n\t\tif (php_check_open_basedir(resolved_path_buff TSRMLS_CC)) {\n\t\t\tRETURN_FALSE;\n\t\t}\n\n#ifdef ZTS\n\t\tif (VCWD_ACCESS(resolved_path_buff, F_OK)) {\n\t\t\tRETURN_FALSE;\n\t\t}\n#endif\n\t\tRETURN_STRING(resolved_path_buff, 1);\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n}\n/* }}} */\n#endif\n\n/* See http://www.w3.org/TR/html4/intro/sgmltut.html#h-3.2.2 */\n#define PHP_META_HTML401_CHARS \"-_.:\"\n\n/* {{{ php_next_meta_token\n   Tokenizes an HTML file for get_meta_tags */\nphp_meta_tags_token php_next_meta_token(php_meta_tags_data *md TSRMLS_DC)\n{\n\tint ch = 0, compliment;\n\tchar buff[META_DEF_BUFSIZE + 1];\n\n\tmemset((void *)buff, 0, META_DEF_BUFSIZE + 1);\n\n\twhile (md->ulc || (!php_stream_eof(md->stream) && (ch = php_stream_getc(md->stream)))) {\n\t\tif (php_stream_eof(md->stream)) {\n\t\t\tbreak;\n\t\t}\n\n\t\tif (md->ulc) {\n\t\t\tch = md->lc;\n\t\t\tmd->ulc = 0;\n\t\t}\n\n\t\tswitch (ch) {\n\t\t\tcase '<':\n\t\t\t\treturn TOK_OPENTAG;\n\t\t\t\tbreak;\n\n\t\t\tcase '>':\n\t\t\t\treturn TOK_CLOSETAG;\n\t\t\t\tbreak;\n\n\t\t\tcase '=':\n\t\t\t\treturn TOK_EQUAL;\n\t\t\t\tbreak;\n\t\t\tcase '/':\n\t\t\t\treturn TOK_SLASH;\n\t\t\t\tbreak;\n\n\t\t\tcase '\\'':\n\t\t\tcase '\"':\n\t\t\t\tcompliment = ch;\n\t\t\t\tmd->token_len = 0;\n\t\t\t\twhile (!php_stream_eof(md->stream) && (ch = php_stream_getc(md->stream)) && ch != compliment && ch != '<' && ch != '>') {\n\t\t\t\t\tbuff[(md->token_len)++] = ch;\n\n\t\t\t\t\tif (md->token_len == META_DEF_BUFSIZE) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (ch == '<' || ch == '>') {\n\t\t\t\t\t/* Was just an apostrohpe */\n\t\t\t\t\tmd->ulc = 1;\n\t\t\t\t\tmd->lc = ch;\n\t\t\t\t}\n\n\t\t\t\t/* We don't need to alloc unless we are in a meta tag */\n\t\t\t\tif (md->in_meta) {\n\t\t\t\t\tmd->token_data = (char *) emalloc(md->token_len + 1);\n\t\t\t\t\tmemcpy(md->token_data, buff, md->token_len+1);\n\t\t\t\t}\n\n\t\t\t\treturn TOK_STRING;\n\t\t\t\tbreak;\n\n\t\t\tcase '\\n':\n\t\t\tcase '\\r':\n\t\t\tcase '\\t':\n\t\t\t\tbreak;\n\n\t\t\tcase ' ':\n\t\t\t\treturn TOK_SPACE;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tif (isalnum(ch)) {\n\t\t\t\t\tmd->token_len = 0;\n\t\t\t\t\tbuff[(md->token_len)++] = ch;\n\t\t\t\t\twhile (!php_stream_eof(md->stream) && (ch = php_stream_getc(md->stream)) && (isalnum(ch) || strchr(PHP_META_HTML401_CHARS, ch))) {\n\t\t\t\t\t\tbuff[(md->token_len)++] = ch;\n\n\t\t\t\t\t\tif (md->token_len == META_DEF_BUFSIZE) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t/* This is ugly, but we have to replace ungetc */\n\t\t\t\t\tif (!isalpha(ch) && ch != '-') {\n\t\t\t\t\t\tmd->ulc = 1;\n\t\t\t\t\t\tmd->lc = ch;\n\t\t\t\t\t}\n\n\t\t\t\t\tmd->token_data = (char *) emalloc(md->token_len + 1);\n\t\t\t\t\tmemcpy(md->token_data, buff, md->token_len+1);\n\n\t\t\t\t\treturn TOK_ID;\n\t\t\t\t} else {\n\t\t\t\t\treturn TOK_OTHER;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn TOK_EOF;\n}\n/* }}} */\n\n#ifdef HAVE_FNMATCH\n/* {{{ proto bool fnmatch(string pattern, string filename [, int flags])\n   Match filename against pattern */\nPHP_FUNCTION(fnmatch)\n{\n\tchar *pattern, *filename;\n\tint pattern_len, filename_len;\n\tlong flags = 0;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"pp|l\", &pattern, &pattern_len, &filename, &filename_len, &flags) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (filename_len >= MAXPATHLEN) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Filename exceeds the maximum allowed length of %d characters\", MAXPATHLEN);\n\t\tRETURN_FALSE;\n\t}\n\tif (pattern_len >= MAXPATHLEN) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Pattern exceeds the maximum allowed length of %d characters\", MAXPATHLEN);\n\t\tRETURN_FALSE;\n\t}\n\n\tRETURN_BOOL( ! fnmatch( pattern, filename, flags ));\n}\n/* }}} */\n#endif\n\n/* {{{ proto string sys_get_temp_dir()\n   Returns directory path used for temporary files */\nPHP_FUNCTION(sys_get_temp_dir)\n{\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\tRETURN_STRING((char *)php_get_temporary_directory(TSRMLS_C), 1);\n}\n/* }}} */\n\n/*\n * Local variables:\n * tab-width: 4\n * c-basic-offset: 4\n * End:\n * vim600: noet sw=4 ts=4 fdm=marker\n * vim<600: noet sw=4 ts=4\n */\n", "code_before": "/*\n   +----------------------------------------------------------------------+\n   | Copyright (c) The PHP Group                                          |\n   +----------------------------------------------------------------------+\n   | This source file is subject to version 3.01 of the PHP license,      |\n   | that is bundled with this package in the file LICENSE, and is        |\n   | available through the world-wide-web at the following url:           |\n   | https://www.php.net/license/3_01.txt                                 |\n   | If you did not receive a copy of the PHP license and are unable to   |\n   | obtain it through the world-wide-web, please send a note to          |\n   | license@php.net so we can mail you a copy immediately.               |\n   +----------------------------------------------------------------------+\n   | Authors: Rasmus Lerdorf <rasmus@php.net>                             |\n   |          Stig Bakken <ssb@php.net>                                   |\n   |          Andi Gutmans <andi@php.net>                                 |\n   |          Zeev Suraski <zeev@php.net>                                 |\n   | PHP 4.0 patches by Thies C. Arntzen (thies@thieso.net)               |\n   | PHP streams by Wez Furlong (wez@thebrainroom.com)                    |\n   +----------------------------------------------------------------------+\n*/\n\n/* {{{ includes */\n\n#include \"php.h\"\n#include \"ext/standard/flock_compat.h\"\n#include \"ext/standard/php_filestat.h\"\n#include \"php_open_temporary_file.h\"\n#include \"ext/standard/basic_functions.h\"\n#include \"php_ini.h\"\n#include \"zend_smart_str.h\"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <wchar.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n\n#ifdef PHP_WIN32\n# include <io.h>\n# define O_RDONLY _O_RDONLY\n# include \"win32/param.h\"\n# include \"win32/winutil.h\"\n# include \"win32/fnmatch.h\"\n# include \"win32/ioutil.h\"\n#else\n# ifdef HAVE_SYS_PARAM_H\n#  include <sys/param.h>\n# endif\n# ifdef HAVE_SYS_SELECT_H\n#  include <sys/select.h>\n# endif\n# include <sys/socket.h>\n# include <netinet/in.h>\n# include <netdb.h>\n# ifdef HAVE_ARPA_INET_H\n#  include <arpa/inet.h>\n# endif\n#endif\n\n#include \"php_string.h\"\n#include \"file.h\"\n\n#ifdef HAVE_PWD_H\n# ifdef PHP_WIN32\n#  include \"win32/pwd.h\"\n# else\n#  include <pwd.h>\n# endif\n#endif\n\n#include \"fsock.h\"\n#include \"fopen_wrappers.h\"\n#include \"streamsfuncs.h\" /* To define constants in the arg_info */\n\n#ifdef HAVE_SYS_FILE_H\n# include <sys/file.h>\n#endif\n\n#ifdef HAVE_SYS_MMAN_H\n# include <sys/mman.h>\n#endif\n\n#include \"scanf.h\"\n#include \"zend_API.h\"\n\n#ifdef ZTS\nint file_globals_id;\n#else\nphp_file_globals file_globals;\n#endif\n\n#if defined(HAVE_FNMATCH) && !defined(PHP_WIN32)\n# ifndef _GNU_SOURCE\n#  define _GNU_SOURCE\n# endif\n# include <fnmatch.h>\n#endif\n\n#include \"file_arginfo.h\"\n\n/* }}} */\n\n/* {{{ ZTS-stuff / Globals / Prototypes */\n\n/* sharing globals is *evil* */\nstatic int le_stream_context = FAILURE;\n\nPHPAPI int php_le_stream_context(void)\n{\n\treturn le_stream_context;\n}\n/* }}} */\n\n/* {{{ Module-Stuff */\nstatic ZEND_RSRC_DTOR_FUNC(file_context_dtor)\n{\n\tphp_stream_context *context = (php_stream_context*)res->ptr;\n\tif (Z_TYPE(context->options) != IS_UNDEF) {\n\t\tzval_ptr_dtor(&context->options);\n\t\tZVAL_UNDEF(&context->options);\n\t}\n\tphp_stream_context_free(context);\n}\n\nstatic void file_globals_ctor(php_file_globals *file_globals_p)\n{\n\tmemset(file_globals_p, 0, sizeof(php_file_globals));\n\tfile_globals_p->def_chunk_size = PHP_SOCK_CHUNK_SIZE;\n}\n\nstatic void file_globals_dtor(php_file_globals *file_globals_p)\n{\n#if defined(HAVE_GETHOSTBYNAME_R)\n\tif (file_globals_p->tmp_host_buf) {\n\t\tfree(file_globals_p->tmp_host_buf);\n\t}\n#endif\n}\n\nstatic PHP_INI_MH(OnUpdateAutoDetectLineEndings)\n{\n\tif (zend_ini_parse_bool(new_value)) {\n\t\tzend_error(E_DEPRECATED, \"auto_detect_line_endings is deprecated\");\n\t}\n\treturn OnUpdateBool(entry, new_value, mh_arg1, mh_arg2, mh_arg3, stage);\n}\n\nPHP_INI_BEGIN()\n\tSTD_PHP_INI_ENTRY(\"user_agent\", NULL, PHP_INI_ALL, OnUpdateString, user_agent, php_file_globals, file_globals)\n\tSTD_PHP_INI_ENTRY(\"from\", NULL, PHP_INI_ALL, OnUpdateString, from_address, php_file_globals, file_globals)\n\tSTD_PHP_INI_ENTRY(\"default_socket_timeout\", \"60\", PHP_INI_ALL, OnUpdateLong, default_socket_timeout, php_file_globals, file_globals)\n\tSTD_PHP_INI_BOOLEAN(\"auto_detect_line_endings\", \"0\", PHP_INI_ALL, OnUpdateAutoDetectLineEndings, auto_detect_line_endings, php_file_globals, file_globals)\nPHP_INI_END()\n\nPHP_MINIT_FUNCTION(file)\n{\n\tle_stream_context = zend_register_list_destructors_ex(file_context_dtor, NULL, \"stream-context\", module_number);\n\n#ifdef ZTS\n\tts_allocate_id(&file_globals_id, sizeof(php_file_globals), (ts_allocate_ctor) file_globals_ctor, (ts_allocate_dtor) file_globals_dtor);\n#else\n\tfile_globals_ctor(&file_globals);\n#endif\n\n\tREGISTER_INI_ENTRIES();\n\n\tregister_file_symbols(module_number);\n\n\treturn SUCCESS;\n}\n/* }}} */\n\nPHP_MSHUTDOWN_FUNCTION(file) /* {{{ */\n{\n#ifndef ZTS\n\tfile_globals_dtor(&file_globals);\n#endif\n\treturn SUCCESS;\n}\n/* }}} */\n\nPHPAPI void php_flock_common(php_stream *stream, zend_long operation,\n\tuint32_t operation_arg_num, zval *wouldblock, zval *return_value)\n{\n\tint flock_values[] = { LOCK_SH, LOCK_EX, LOCK_UN };\n\tint act;\n\n\tact = operation & PHP_LOCK_UN;\n\tif (act < 1 || act > 3) {\n\t\tzend_argument_value_error(operation_arg_num, \"must be one of LOCK_SH, LOCK_EX, or LOCK_UN\");\n\t\tRETURN_THROWS();\n\t}\n\n\tif (wouldblock) {\n\t\tZEND_TRY_ASSIGN_REF_LONG(wouldblock, 0);\n\t}\n\n\t/* flock_values contains all possible actions if (operation & PHP_LOCK_NB) we won't block on the lock */\n\tact = flock_values[act - 1] | (operation & PHP_LOCK_NB ? LOCK_NB : 0);\n\tif (php_stream_lock(stream, act)) {\n\t\tif (operation && errno == EWOULDBLOCK && wouldblock) {\n\t\t\tZEND_TRY_ASSIGN_REF_LONG(wouldblock, 1);\n\t\t}\n\t\tRETURN_FALSE;\n\t}\n\tRETURN_TRUE;\n}\n\n/* {{{ Portable file locking */\nPHP_FUNCTION(flock)\n{\n\tzval *wouldblock = NULL;\n\tphp_stream *stream;\n\tzend_long operation = 0;\n\n\tZEND_PARSE_PARAMETERS_START(2, 3)\n\t\tPHP_Z_PARAM_STREAM(stream)\n\t\tZ_PARAM_LONG(operation)\n\t\tZ_PARAM_OPTIONAL\n\t\tZ_PARAM_ZVAL(wouldblock)\n\tZEND_PARSE_PARAMETERS_END();\n\n\tphp_flock_common(stream, operation, 2, wouldblock, return_value);\n}\n/* }}} */\n\n#define PHP_META_UNSAFE \".\\\\+*?[^]$() \"\n\n/* {{{ Extracts all meta tag content attributes from a file and returns an array */\nPHP_FUNCTION(get_meta_tags)\n{\n\tchar *filename;\n\tsize_t filename_len;\n\tbool use_include_path = 0;\n\tint in_tag = 0, done = 0;\n\tint looking_for_val = 0, have_name = 0, have_content = 0;\n\tint saw_name = 0, saw_content = 0;\n\tchar *name = NULL, *value = NULL, *temp = NULL;\n\tphp_meta_tags_token tok, tok_last;\n\tphp_meta_tags_data md;\n\n\t/* Initialize our structure */\n\tmemset(&md, 0, sizeof(md));\n\n\t/* Parse arguments */\n\tZEND_PARSE_PARAMETERS_START(1, 2)\n\t\tZ_PARAM_PATH(filename, filename_len)\n\t\tZ_PARAM_OPTIONAL\n\t\tZ_PARAM_BOOL(use_include_path)\n\tZEND_PARSE_PARAMETERS_END();\n\n\tmd.stream = php_stream_open_wrapper(filename, \"rb\",\n\t\t\t(use_include_path ? USE_PATH : 0) | REPORT_ERRORS,\n\t\t\tNULL);\n\tif (!md.stream)\t{\n\t\tRETURN_FALSE;\n\t}\n\n\tarray_init(return_value);\n\n\ttok_last = TOK_EOF;\n\n\twhile (!done && (tok = php_next_meta_token(&md)) != TOK_EOF) {\n\t\tif (tok == TOK_ID) {\n\t\t\tif (tok_last == TOK_OPENTAG) {\n\t\t\t\tmd.in_meta = !strcasecmp(\"meta\", md.token_data);\n\t\t\t} else if (tok_last == TOK_SLASH && in_tag) {\n\t\t\t\tif (strcasecmp(\"head\", md.token_data) == 0) {\n\t\t\t\t\t/* We are done here! */\n\t\t\t\t\tdone = 1;\n\t\t\t\t}\n\t\t\t} else if (tok_last == TOK_EQUAL && looking_for_val) {\n\t\t\t\tif (saw_name) {\n\t\t\t\t\tif (name) efree(name);\n\t\t\t\t\t/* Get the NAME attr (Single word attr, non-quoted) */\n\t\t\t\t\ttemp = name = estrndup(md.token_data, md.token_len);\n\n\t\t\t\t\twhile (temp && *temp) {\n\t\t\t\t\t\tif (strchr(PHP_META_UNSAFE, *temp)) {\n\t\t\t\t\t\t\t*temp = '_';\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttemp++;\n\t\t\t\t\t}\n\n\t\t\t\t\thave_name = 1;\n\t\t\t\t} else if (saw_content) {\n\t\t\t\t\tif (value) efree(value);\n\t\t\t\t\tvalue = estrndup(md.token_data, md.token_len);\n\t\t\t\t\thave_content = 1;\n\t\t\t\t}\n\n\t\t\t\tlooking_for_val = 0;\n\t\t\t} else {\n\t\t\t\tif (md.in_meta) {\n\t\t\t\t\tif (strcasecmp(\"name\", md.token_data) == 0) {\n\t\t\t\t\t\tsaw_name = 1;\n\t\t\t\t\t\tsaw_content = 0;\n\t\t\t\t\t\tlooking_for_val = 1;\n\t\t\t\t\t} else if (strcasecmp(\"content\", md.token_data) == 0) {\n\t\t\t\t\t\tsaw_name = 0;\n\t\t\t\t\t\tsaw_content = 1;\n\t\t\t\t\t\tlooking_for_val = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (tok == TOK_STRING && tok_last == TOK_EQUAL && looking_for_val) {\n\t\t\tif (saw_name) {\n\t\t\t\tif (name) efree(name);\n\t\t\t\t/* Get the NAME attr (Quoted single/double) */\n\t\t\t\ttemp = name = estrndup(md.token_data, md.token_len);\n\n\t\t\t\twhile (temp && *temp) {\n\t\t\t\t\tif (strchr(PHP_META_UNSAFE, *temp)) {\n\t\t\t\t\t\t*temp = '_';\n\t\t\t\t\t}\n\t\t\t\t\ttemp++;\n\t\t\t\t}\n\n\t\t\t\thave_name = 1;\n\t\t\t} else if (saw_content) {\n\t\t\t\tif (value) efree(value);\n\t\t\t\tvalue = estrndup(md.token_data, md.token_len);\n\t\t\t\thave_content = 1;\n\t\t\t}\n\n\t\t\tlooking_for_val = 0;\n\t\t} else if (tok == TOK_OPENTAG) {\n\t\t\tif (looking_for_val) {\n\t\t\t\tlooking_for_val = 0;\n\t\t\t\thave_name = saw_name = 0;\n\t\t\t\thave_content = saw_content = 0;\n\t\t\t}\n\t\t\tin_tag = 1;\n\t\t} else if (tok == TOK_CLOSETAG) {\n\t\t\tif (have_name) {\n\t\t\t\t/* For BC */\n\t\t\t\tzend_str_tolower(name, strlen(name));\n\t\t\t\tif (have_content) {\n\t\t\t\t\tadd_assoc_string(return_value, name, value);\n\t\t\t\t} else {\n\t\t\t\t\tadd_assoc_string(return_value, name, \"\");\n\t\t\t\t}\n\n\t\t\t\tefree(name);\n\t\t\t\tif (value) efree(value);\n\t\t\t} else if (have_content) {\n\t\t\t\tefree(value);\n\t\t\t}\n\n\t\t\tname = value = NULL;\n\n\t\t\t/* Reset all of our flags */\n\t\t\tin_tag = looking_for_val = 0;\n\t\t\thave_name = saw_name = 0;\n\t\t\thave_content = saw_content = 0;\n\t\t\tmd.in_meta = 0;\n\t\t}\n\n\t\ttok_last = tok;\n\n\t\tif (md.token_data)\n\t\t\tefree(md.token_data);\n\n\t\tmd.token_data = NULL;\n\t}\n\n\tif (value) efree(value);\n\tif (name) efree(name);\n\tphp_stream_close(md.stream);\n}\n/* }}} */\n\n/* {{{ Read the entire file into a string */\nPHP_FUNCTION(file_get_contents)\n{\n\tchar *filename;\n\tsize_t filename_len;\n\tbool use_include_path = 0;\n\tphp_stream *stream;\n\tzend_long offset = 0;\n\tzend_long maxlen;\n\tbool maxlen_is_null = 1;\n\tzval *zcontext = NULL;\n\tphp_stream_context *context = NULL;\n\tzend_string *contents;\n\n\t/* Parse arguments */\n\tZEND_PARSE_PARAMETERS_START(1, 5)\n\t\tZ_PARAM_PATH(filename, filename_len)\n\t\tZ_PARAM_OPTIONAL\n\t\tZ_PARAM_BOOL(use_include_path)\n\t\tZ_PARAM_RESOURCE_OR_NULL(zcontext)\n\t\tZ_PARAM_LONG(offset)\n\t\tZ_PARAM_LONG_OR_NULL(maxlen, maxlen_is_null)\n\tZEND_PARSE_PARAMETERS_END();\n\n\tif (maxlen_is_null) {\n\t\tmaxlen = (ssize_t) PHP_STREAM_COPY_ALL;\n\t} else if (maxlen < 0) {\n\t\tzend_argument_value_error(5, \"must be greater than or equal to 0\");\n\t\tRETURN_THROWS();\n\t}\n\n\tcontext = php_stream_context_from_zval(zcontext, 0);\n\n\tstream = php_stream_open_wrapper_ex(filename, \"rb\",\n\t\t\t\t(use_include_path ? USE_PATH : 0) | REPORT_ERRORS,\n\t\t\t\tNULL, context);\n\tif (!stream) {\n\t\tRETURN_FALSE;\n\t}\n\n\t/* disabling the read buffer allows doing the whole transfer\n\t   in just one read() system call */\n\tif (php_stream_is(stream, PHP_STREAM_IS_STDIO)) {\n\t\tphp_stream_set_option(stream, PHP_STREAM_OPTION_READ_BUFFER, PHP_STREAM_BUFFER_NONE, NULL);\n\t}\n\n\tif (offset != 0 && php_stream_seek(stream, offset, ((offset > 0) ? SEEK_SET : SEEK_END)) < 0) {\n\t\tphp_error_docref(NULL, E_WARNING, \"Failed to seek to position \" ZEND_LONG_FMT \" in the stream\", offset);\n\t\tphp_stream_close(stream);\n\t\tRETURN_FALSE;\n\t}\n\n\tif ((contents = php_stream_copy_to_mem(stream, maxlen, 0)) != NULL) {\n\t\tRETVAL_STR(contents);\n\t} else {\n\t\tRETVAL_EMPTY_STRING();\n\t}\n\n\tphp_stream_close(stream);\n}\n/* }}} */\n\n/* {{{ Write/Create a file with contents data and return the number of bytes written */\nPHP_FUNCTION(file_put_contents)\n{\n\tphp_stream *stream;\n\tchar *filename;\n\tsize_t filename_len;\n\tzval *data;\n\tssize_t numbytes = 0;\n\tzend_long flags = 0;\n\tzval *zcontext = NULL;\n\tphp_stream_context *context = NULL;\n\tphp_stream *srcstream = NULL;\n\tchar mode[3] = \"wb\";\n\n\tZEND_PARSE_PARAMETERS_START(2, 4)\n\t\tZ_PARAM_PATH(filename, filename_len)\n\t\tZ_PARAM_ZVAL(data)\n\t\tZ_PARAM_OPTIONAL\n\t\tZ_PARAM_LONG(flags)\n\t\tZ_PARAM_RESOURCE_OR_NULL(zcontext)\n\tZEND_PARSE_PARAMETERS_END();\n\n\tif (Z_TYPE_P(data) == IS_RESOURCE) {\n\t\tphp_stream_from_zval(srcstream, data);\n\t}\n\n\tcontext = php_stream_context_from_zval(zcontext, flags & PHP_FILE_NO_DEFAULT_CONTEXT);\n\n\tif (flags & PHP_FILE_APPEND) {\n\t\tmode[0] = 'a';\n\t} else if (flags & LOCK_EX) {\n\t\t/* check to make sure we are dealing with a regular file */\n\t\tif (php_memnstr(filename, \"://\", sizeof(\"://\") - 1, filename + filename_len)) {\n\t\t\tif (strncasecmp(filename, \"file://\", sizeof(\"file://\") - 1)) {\n\t\t\t\tphp_error_docref(NULL, E_WARNING, \"Exclusive locks may only be set for regular files\");\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\t\t}\n\t\tmode[0] = 'c';\n\t}\n\tmode[2] = '\\0';\n\n\tstream = php_stream_open_wrapper_ex(filename, mode, ((flags & PHP_FILE_USE_INCLUDE_PATH) ? USE_PATH : 0) | REPORT_ERRORS, NULL, context);\n\tif (stream == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif ((flags & LOCK_EX) && (!php_stream_supports_lock(stream) || php_stream_lock(stream, LOCK_EX))) {\n\t\tphp_stream_close(stream);\n\t\tphp_error_docref(NULL, E_WARNING, \"Exclusive locks are not supported for this stream\");\n\t\tRETURN_FALSE;\n\t}\n\n\tif (mode[0] == 'c') {\n\t\tphp_stream_truncate_set_size(stream, 0);\n\t}\n\n\tswitch (Z_TYPE_P(data)) {\n\t\tcase IS_RESOURCE: {\n\t\t\tsize_t len;\n\t\t\tif (php_stream_copy_to_stream_ex(srcstream, stream, PHP_STREAM_COPY_ALL, &len) != SUCCESS) {\n\t\t\t\tnumbytes = -1;\n\t\t\t} else {\n\t\t\t\tif (len > ZEND_LONG_MAX) {\n\t\t\t\t\tphp_error_docref(NULL, E_WARNING, \"content truncated from %zu to \" ZEND_LONG_FMT \" bytes\", len, ZEND_LONG_MAX);\n\t\t\t\t\tlen = ZEND_LONG_MAX;\n\t\t\t\t}\n\t\t\t\tnumbytes = len;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase IS_NULL:\n\t\tcase IS_LONG:\n\t\tcase IS_DOUBLE:\n\t\tcase IS_FALSE:\n\t\tcase IS_TRUE:\n\t\t\tconvert_to_string(data);\n\t\t\tZEND_FALLTHROUGH;\n\t\tcase IS_STRING:\n\t\t\tif (Z_STRLEN_P(data)) {\n\t\t\t\tnumbytes = php_stream_write(stream, Z_STRVAL_P(data), Z_STRLEN_P(data));\n\t\t\t\tif (numbytes != -1 && numbytes != Z_STRLEN_P(data)) {\n\t\t\t\t\tphp_error_docref(NULL, E_WARNING, \"Only %zd of %zd bytes written, possibly out of free disk space\", numbytes, Z_STRLEN_P(data));\n\t\t\t\t\tnumbytes = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase IS_ARRAY:\n\t\t\tif (zend_hash_num_elements(Z_ARRVAL_P(data))) {\n\t\t\t\tssize_t bytes_written;\n\t\t\t\tzval *tmp;\n\n\t\t\t\tZEND_HASH_FOREACH_VAL(Z_ARRVAL_P(data), tmp) {\n\t\t\t\t\tzend_string *t;\n\t\t\t\t\tzend_string *str = zval_get_tmp_string(tmp, &t);\n\t\t\t\t\tif (ZSTR_LEN(str)) {\n\t\t\t\t\t\tnumbytes += ZSTR_LEN(str);\n\t\t\t\t\t\tbytes_written = php_stream_write(stream, ZSTR_VAL(str), ZSTR_LEN(str));\n\t\t\t\t\t\tif (bytes_written != ZSTR_LEN(str)) {\n\t\t\t\t\t\t\tphp_error_docref(NULL, E_WARNING, \"Failed to write %zd bytes to %s\", ZSTR_LEN(str), filename);\n\t\t\t\t\t\t\tzend_tmp_string_release(t);\n\t\t\t\t\t\t\tnumbytes = -1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tzend_tmp_string_release(t);\n\t\t\t\t} ZEND_HASH_FOREACH_END();\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase IS_OBJECT:\n\t\t\tif (Z_OBJ_HT_P(data) != NULL) {\n\t\t\t\tzval out;\n\n\t\t\t\tif (zend_std_cast_object_tostring(Z_OBJ_P(data), &out, IS_STRING) == SUCCESS) {\n\t\t\t\t\tnumbytes = php_stream_write(stream, Z_STRVAL(out), Z_STRLEN(out));\n\t\t\t\t\tif (numbytes != -1 && numbytes != Z_STRLEN(out)) {\n\t\t\t\t\t\tphp_error_docref(NULL, E_WARNING, \"Only %zd of %zd bytes written, possibly out of free disk space\", numbytes, Z_STRLEN(out));\n\t\t\t\t\t\tnumbytes = -1;\n\t\t\t\t\t}\n\t\t\t\t\tzval_ptr_dtor_str(&out);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tZEND_FALLTHROUGH;\n\t\tdefault:\n\t\t\tnumbytes = -1;\n\t\t\tbreak;\n\t}\n\tphp_stream_close(stream);\n\n\tif (numbytes < 0) {\n\t\tRETURN_FALSE;\n\t}\n\n\tRETURN_LONG(numbytes);\n}\n/* }}} */\n\n#define PHP_FILE_BUF_SIZE\t80\n\n/* {{{ Read entire file into an array */\nPHP_FUNCTION(file)\n{\n\tchar *filename;\n\tsize_t filename_len;\n\tchar *p, *s, *e;\n\tint i = 0;\n\tchar eol_marker = '\\n';\n\tzend_long flags = 0;\n\tbool use_include_path;\n\tbool include_new_line;\n\tbool skip_blank_lines;\n\tphp_stream *stream;\n\tzval *zcontext = NULL;\n\tphp_stream_context *context = NULL;\n\tzend_string *target_buf;\n\n\t/* Parse arguments */\n\tZEND_PARSE_PARAMETERS_START(1, 3)\n\t\tZ_PARAM_PATH(filename, filename_len)\n\t\tZ_PARAM_OPTIONAL\n\t\tZ_PARAM_LONG(flags)\n\t\tZ_PARAM_RESOURCE_OR_NULL(zcontext)\n\tZEND_PARSE_PARAMETERS_END();\n\n\tif ((flags & ~(PHP_FILE_USE_INCLUDE_PATH | PHP_FILE_IGNORE_NEW_LINES | PHP_FILE_SKIP_EMPTY_LINES | PHP_FILE_NO_DEFAULT_CONTEXT)) != 0) {\n\t\tzend_argument_value_error(2, \"must be a valid flag value\");\n\t\tRETURN_THROWS();\n\t}\n\n\tuse_include_path = flags & PHP_FILE_USE_INCLUDE_PATH;\n\tinclude_new_line = !(flags & PHP_FILE_IGNORE_NEW_LINES);\n\tskip_blank_lines = flags & PHP_FILE_SKIP_EMPTY_LINES;\n\n\tcontext = php_stream_context_from_zval(zcontext, flags & PHP_FILE_NO_DEFAULT_CONTEXT);\n\n\tstream = php_stream_open_wrapper_ex(filename, \"rb\", (use_include_path ? USE_PATH : 0) | REPORT_ERRORS, NULL, context);\n\tif (!stream) {\n\t\tRETURN_FALSE;\n\t}\n\n\t/* Initialize return array */\n\tarray_init(return_value);\n\n\tif ((target_buf = php_stream_copy_to_mem(stream, PHP_STREAM_COPY_ALL, 0)) != NULL) {\n\t\ts = ZSTR_VAL(target_buf);\n\t\te = ZSTR_VAL(target_buf) + ZSTR_LEN(target_buf);\n\n\t\tif (!(p = (char*)php_stream_locate_eol(stream, target_buf))) {\n\t\t\tp = e;\n\t\t\tgoto parse_eol;\n\t\t}\n\n\t\tif (stream->flags & PHP_STREAM_FLAG_EOL_MAC) {\n\t\t\teol_marker = '\\r';\n\t\t}\n\n\t\t/* for performance reasons the code is duplicated, so that the if (include_new_line)\n\t\t * will not need to be done for every single line in the file. */\n\t\tif (include_new_line) {\n\t\t\tdo {\n\t\t\t\tp++;\nparse_eol:\n\t\t\t\tadd_index_stringl(return_value, i++, s, p-s);\n\t\t\t\ts = p;\n\t\t\t} while ((p = memchr(p, eol_marker, (e-p))));\n\t\t} else {\n\t\t\tdo {\n\t\t\t\tint windows_eol = 0;\n\t\t\t\tif (p != ZSTR_VAL(target_buf) && eol_marker == '\\n' && *(p - 1) == '\\r') {\n\t\t\t\t\twindows_eol++;\n\t\t\t\t}\n\t\t\t\tif (skip_blank_lines && !(p-s-windows_eol)) {\n\t\t\t\t\ts = ++p;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tadd_index_stringl(return_value, i++, s, p-s-windows_eol);\n\t\t\t\ts = ++p;\n\t\t\t} while ((p = memchr(p, eol_marker, (e-p))));\n\t\t}\n\n\t\t/* handle any leftovers of files without new lines */\n\t\tif (s != e) {\n\t\t\tp = e;\n\t\t\tgoto parse_eol;\n\t\t}\n\t}\n\n\tif (target_buf) {\n\t\tzend_string_free(target_buf);\n\t}\n\tphp_stream_close(stream);\n}\n/* }}} */\n\n/* {{{ Create a unique filename in a directory */\nPHP_FUNCTION(tempnam)\n{\n\tchar *dir, *prefix;\n\tsize_t dir_len, prefix_len;\n\tzend_string *opened_path;\n\tint fd;\n\tzend_string *p;\n\n\tZEND_PARSE_PARAMETERS_START(2, 2)\n\t\tZ_PARAM_PATH(dir, dir_len)\n\t\tZ_PARAM_PATH(prefix, prefix_len)\n\tZEND_PARSE_PARAMETERS_END();\n\n\tp = php_basename(prefix, prefix_len, NULL, 0);\n\tif (ZSTR_LEN(p) >= 64) {\n\t\tZSTR_VAL(p)[63] = '\\0';\n\t}\n\n\tRETVAL_FALSE;\n\n\tif ((fd = php_open_temporary_fd_ex(dir, ZSTR_VAL(p), &opened_path, PHP_TMP_FILE_OPEN_BASEDIR_CHECK_ALWAYS)) >= 0) {\n\t\tclose(fd);\n\t\tRETVAL_STR(opened_path);\n\t}\n\tzend_string_release_ex(p, 0);\n}\n/* }}} */\n\n/* {{{ Create a temporary file that will be deleted automatically after use */\nPHP_FUNCTION(tmpfile)\n{\n\tphp_stream *stream;\n\n\tZEND_PARSE_PARAMETERS_NONE();\n\n\tstream = php_stream_fopen_tmpfile();\n\n\tif (stream) {\n\t\tphp_stream_to_zval(stream, return_value);\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n}\n/* }}} */\n\n/* {{{ Open a file or a URL and return a file pointer */\nPHP_FUNCTION(fopen)\n{\n\tchar *filename, *mode;\n\tsize_t filename_len, mode_len;\n\tbool use_include_path = 0;\n\tzval *zcontext = NULL;\n\tphp_stream *stream;\n\tphp_stream_context *context = NULL;\n\n\tZEND_PARSE_PARAMETERS_START(2, 4)\n\t\tZ_PARAM_PATH(filename, filename_len)\n\t\tZ_PARAM_STRING(mode, mode_len)\n\t\tZ_PARAM_OPTIONAL\n\t\tZ_PARAM_BOOL(use_include_path)\n\t\tZ_PARAM_RESOURCE_OR_NULL(zcontext)\n\tZEND_PARSE_PARAMETERS_END();\n\n\tcontext = php_stream_context_from_zval(zcontext, 0);\n\n\tstream = php_stream_open_wrapper_ex(filename, mode, (use_include_path ? USE_PATH : 0) | REPORT_ERRORS, NULL, context);\n\n\tif (stream == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\n\tphp_stream_to_zval(stream, return_value);\n}\n/* }}} */\n\n/* {{{ Close an open file pointer */\nPHPAPI PHP_FUNCTION(fclose)\n{\n\tphp_stream *stream;\n\n\tZEND_PARSE_PARAMETERS_START(1, 1)\n\t\tPHP_Z_PARAM_STREAM(stream)\n\tZEND_PARSE_PARAMETERS_END();\n\n\tif ((stream->flags & PHP_STREAM_FLAG_NO_FCLOSE) != 0) {\n\t\tphp_error_docref(NULL, E_WARNING, \"cannot close the provided stream, as it must not be manually closed\");\n\t\tRETURN_FALSE;\n\t}\n\n\tphp_stream_free(stream,\n\t\tPHP_STREAM_FREE_KEEP_RSRC |\n\t\t(stream->is_persistent ? PHP_STREAM_FREE_CLOSE_PERSISTENT : PHP_STREAM_FREE_CLOSE));\n\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ Execute a command and open either a read or a write pipe to it */\nPHP_FUNCTION(popen)\n{\n\tchar *command, *mode;\n\tsize_t command_len, mode_len;\n\tFILE *fp;\n\tphp_stream *stream;\n\tchar *posix_mode;\n\n\tZEND_PARSE_PARAMETERS_START(2, 2)\n\t\tZ_PARAM_PATH(command, command_len)\n\t\tZ_PARAM_STRING(mode, mode_len)\n\tZEND_PARSE_PARAMETERS_END();\n\n\tposix_mode = estrndup(mode, mode_len);\n#ifndef PHP_WIN32\n\t{\n\t\tchar *z = memchr(posix_mode, 'b', mode_len);\n\t\tif (z) {\n\t\t\tmemmove(z, z + 1, mode_len - (z - posix_mode));\n\t\t\tmode_len--;\n\t\t}\n\t}\n#endif\n\n\t/* Musl only partially validates the mode. Manually check it to ensure consistent behavior. */\n\tif (mode_len > 2 ||\n\t\t(mode_len == 1 && (*posix_mode != 'r' && *posix_mode != 'w')) ||\n\t\t(mode_len == 2 && (memcmp(posix_mode, \"rb\", 2) && memcmp(posix_mode, \"wb\", 2)))\n\t) {\n\t\tzend_argument_value_error(2, \"must be one of \\\"r\\\", \\\"rb\\\", \\\"w\\\", or \\\"wb\\\"\");\n\t\tefree(posix_mode);\n\t\tRETURN_THROWS();\n\t}\n\n\tfp = VCWD_POPEN(command, posix_mode);\n\tif (!fp) {\n\t\tphp_error_docref2(NULL, command, posix_mode, E_WARNING, \"%s\", strerror(errno));\n\t\tefree(posix_mode);\n\t\tRETURN_FALSE;\n\t}\n\n\tstream = php_stream_fopen_from_pipe(fp, mode);\n\n\tif (stream == NULL)\t{\n\t\tphp_error_docref2(NULL, command, mode, E_WARNING, \"%s\", strerror(errno));\n\t\tRETVAL_FALSE;\n\t} else {\n\t\tphp_stream_to_zval(stream, return_value);\n\t}\n\n\tefree(posix_mode);\n}\n/* }}} */\n\n/* {{{ Close a file pointer opened by popen() */\nPHP_FUNCTION(pclose)\n{\n\tphp_stream *stream;\n\n\tZEND_PARSE_PARAMETERS_START(1, 1)\n\t\tPHP_Z_PARAM_STREAM(stream)\n\tZEND_PARSE_PARAMETERS_END();\n\n\tFG(pclose_wait) = 1;\n\tzend_list_close(stream->res);\n\tFG(pclose_wait) = 0;\n\tRETURN_LONG(FG(pclose_ret));\n}\n/* }}} */\n\n/* {{{ Test for end-of-file on a file pointer */\nPHPAPI PHP_FUNCTION(feof)\n{\n\tphp_stream *stream;\n\n\tZEND_PARSE_PARAMETERS_START(1, 1)\n\t\tPHP_Z_PARAM_STREAM(stream)\n\tZEND_PARSE_PARAMETERS_END();\n\n\tif (php_stream_eof(stream)) {\n\t\tRETURN_TRUE;\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n}\n/* }}} */\n\n/* {{{ Get a line from file pointer */\nPHPAPI PHP_FUNCTION(fgets)\n{\n\tzend_long len = 1024;\n\tbool len_is_null = 1;\n\tchar *buf = NULL;\n\tsize_t line_len = 0;\n\tzend_string *str;\n\tphp_stream *stream;\n\n\tZEND_PARSE_PARAMETERS_START(1, 2)\n\t\tPHP_Z_PARAM_STREAM(stream)\n\t\tZ_PARAM_OPTIONAL\n\t\tZ_PARAM_LONG_OR_NULL(len, len_is_null)\n\tZEND_PARSE_PARAMETERS_END();\n\n\tif (len_is_null) {\n\t\t/* ask streams to give us a buffer of an appropriate size */\n\t\tbuf = php_stream_get_line(stream, NULL, 0, &line_len);\n\t\tif (buf == NULL) {\n\t\t\tRETURN_FALSE;\n\t\t}\n\t\t// TODO: avoid reallocation ???\n\t\tRETVAL_STRINGL(buf, line_len);\n\t\tefree(buf);\n\t} else {\n\t\tif (len <= 0) {\n\t\t\tzend_argument_value_error(2, \"must be greater than 0\");\n\t\t\tRETURN_THROWS();\n\t\t}\n\n\t\tstr = zend_string_alloc(len, 0);\n\t\tif (php_stream_get_line(stream, ZSTR_VAL(str), len, &line_len) == NULL) {\n\t\t\tzend_string_efree(str);\n\t\t\tRETURN_FALSE;\n\t\t}\n\t\t/* resize buffer if it's much larger than the result.\n\t\t * Only needed if the user requested a buffer size. */\n\t\tif (line_len < (size_t)len / 2) {\n\t\t\tstr = zend_string_truncate(str, line_len, 0);\n\t\t} else {\n\t\t\tZSTR_LEN(str) = line_len;\n\t\t}\n\t\tRETURN_NEW_STR(str);\n\t}\n}\n/* }}} */\n\n/* {{{ Get a character from file pointer */\nPHPAPI PHP_FUNCTION(fgetc)\n{\n\tphp_stream *stream;\n\n\tZEND_PARSE_PARAMETERS_START(1, 1)\n\t\tPHP_Z_PARAM_STREAM(stream)\n\tZEND_PARSE_PARAMETERS_END();\n\n\tint result = php_stream_getc(stream);\n\n\tif (result == EOF) {\n\t\tRETVAL_FALSE;\n\t} else {\n\t\tRETURN_CHAR(result);\n\t}\n}\n/* }}} */\n\n/* {{{ Implements a mostly ANSI compatible fscanf() */\nPHP_FUNCTION(fscanf)\n{\n\tint result, argc = 0;\n\tsize_t format_len;\n\tzval *args = NULL;\n\tzval *file_handle;\n\tchar *buf, *format;\n\tsize_t len;\n\tvoid *what;\n\n\tZEND_PARSE_PARAMETERS_START(2, -1)\n\t\tZ_PARAM_RESOURCE(file_handle)\n\t\tZ_PARAM_STRING(format, format_len)\n\t\tZ_PARAM_VARIADIC('*', args, argc)\n\tZEND_PARSE_PARAMETERS_END();\n\n\twhat = zend_fetch_resource2(Z_RES_P(file_handle), \"File-Handle\", php_file_le_stream(), php_file_le_pstream());\n\n\t/* we can't do a ZEND_VERIFY_RESOURCE(what), otherwise we end up\n\t * with a leak if we have an invalid filehandle. This needs changing\n\t * if the code behind ZEND_VERIFY_RESOURCE changed. - cc */\n\tif (!what) {\n\t\tRETURN_THROWS();\n\t}\n\n\tbuf = php_stream_get_line((php_stream *) what, NULL, 0, &len);\n\tif (buf == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\n\tresult = php_sscanf_internal(buf, format, argc, args, 0, return_value);\n\n\tefree(buf);\n\n\tif (SCAN_ERROR_WRONG_PARAM_COUNT == result) {\n\t\tWRONG_PARAM_COUNT;\n\t}\n}\n/* }}} */\n\n/* {{{ Binary-safe file write */\nPHPAPI PHP_FUNCTION(fwrite)\n{\n\tchar *input;\n\tsize_t inputlen;\n\tssize_t ret;\n\tsize_t num_bytes;\n\tzend_long maxlen = 0;\n\tbool maxlen_is_null = 1;\n\tphp_stream *stream;\n\n\tZEND_PARSE_PARAMETERS_START(2, 3)\n\t\tPHP_Z_PARAM_STREAM(stream)\n\t\tZ_PARAM_STRING(input, inputlen)\n\t\tZ_PARAM_OPTIONAL\n\t\tZ_PARAM_LONG_OR_NULL(maxlen, maxlen_is_null)\n\tZEND_PARSE_PARAMETERS_END();\n\n\tif (maxlen_is_null) {\n\t\tnum_bytes = inputlen;\n\t} else if (maxlen <= 0) {\n\t\tnum_bytes = 0;\n\t} else {\n\t\tnum_bytes = MIN((size_t) maxlen, inputlen);\n\t}\n\n\tif (!num_bytes) {\n\t\tRETURN_LONG(0);\n\t}\n\n\tret = php_stream_write(stream, input, num_bytes);\n\tif (ret < 0) {\n\t\tRETURN_FALSE;\n\t}\n\n\tRETURN_LONG(ret);\n}\n/* }}} */\n\n/* {{{ Flushes output */\nPHPAPI PHP_FUNCTION(fflush)\n{\n\tint ret;\n\tphp_stream *stream;\n\n\tZEND_PARSE_PARAMETERS_START(1, 1)\n\t\tPHP_Z_PARAM_STREAM(stream)\n\tZEND_PARSE_PARAMETERS_END();\n\n\tret = php_stream_flush(stream);\n\tif (ret) {\n\t\tRETURN_FALSE;\n\t}\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ Rewind the position of a file pointer */\nPHPAPI PHP_FUNCTION(rewind)\n{\n\tphp_stream *stream;\n\n\tZEND_PARSE_PARAMETERS_START(1, 1)\n\t\tPHP_Z_PARAM_STREAM(stream)\n\tZEND_PARSE_PARAMETERS_END();\n\n\tif (-1 == php_stream_rewind(stream)) {\n\t\tRETURN_FALSE;\n\t}\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ Get file pointer's read/write position */\nPHPAPI PHP_FUNCTION(ftell)\n{\n\tzend_long ret;\n\tphp_stream *stream;\n\n\tZEND_PARSE_PARAMETERS_START(1, 1)\n\t\tPHP_Z_PARAM_STREAM(stream)\n\tZEND_PARSE_PARAMETERS_END();\n\n\tret = php_stream_tell(stream);\n\tif (ret == -1)\t{\n\t\tRETURN_FALSE;\n\t}\n\tRETURN_LONG(ret);\n}\n/* }}} */\n\n/* {{{ Seek on a file pointer */\nPHPAPI PHP_FUNCTION(fseek)\n{\n\tzend_long offset, whence = SEEK_SET;\n\tphp_stream *stream;\n\n\tZEND_PARSE_PARAMETERS_START(2, 3)\n\t\tPHP_Z_PARAM_STREAM(stream)\n\t\tZ_PARAM_LONG(offset)\n\t\tZ_PARAM_OPTIONAL\n\t\tZ_PARAM_LONG(whence)\n\tZEND_PARSE_PARAMETERS_END();\n\n\tRETURN_LONG(php_stream_seek(stream, offset, (int) whence));\n}\n/* }}} */\n\n/* {{{ Create a directory */\nPHP_FUNCTION(mkdir)\n{\n\tchar *dir;\n\tsize_t dir_len;\n\tzval *zcontext = NULL;\n\tzend_long mode = 0777;\n\tbool recursive = 0;\n\tphp_stream_context *context;\n\n\tZEND_PARSE_PARAMETERS_START(1, 4)\n\t\tZ_PARAM_PATH(dir, dir_len)\n\t\tZ_PARAM_OPTIONAL\n\t\tZ_PARAM_LONG(mode)\n\t\tZ_PARAM_BOOL(recursive)\n\t\tZ_PARAM_RESOURCE_OR_NULL(zcontext)\n\tZEND_PARSE_PARAMETERS_END();\n\n\tcontext = php_stream_context_from_zval(zcontext, 0);\n\n\tRETURN_BOOL(php_stream_mkdir(dir, (int)mode, (recursive ? PHP_STREAM_MKDIR_RECURSIVE : 0) | REPORT_ERRORS, context));\n}\n/* }}} */\n\n/* {{{ Remove a directory */\nPHP_FUNCTION(rmdir)\n{\n\tchar *dir;\n\tsize_t dir_len;\n\tzval *zcontext = NULL;\n\tphp_stream_context *context;\n\n\tZEND_PARSE_PARAMETERS_START(1, 2)\n\t\tZ_PARAM_PATH(dir, dir_len)\n\t\tZ_PARAM_OPTIONAL\n\t\tZ_PARAM_RESOURCE_OR_NULL(zcontext)\n\tZEND_PARSE_PARAMETERS_END();\n\n\tcontext = php_stream_context_from_zval(zcontext, 0);\n\n\tRETURN_BOOL(php_stream_rmdir(dir, REPORT_ERRORS, context));\n}\n/* }}} */\n\n/* {{{ Output a file or a URL */\nPHP_FUNCTION(readfile)\n{\n\tchar *filename;\n\tsize_t filename_len;\n\tsize_t size = 0;\n\tbool use_include_path = 0;\n\tzval *zcontext = NULL;\n\tphp_stream *stream;\n\tphp_stream_context *context = NULL;\n\n\tZEND_PARSE_PARAMETERS_START(1, 3)\n\t\tZ_PARAM_PATH(filename, filename_len)\n\t\tZ_PARAM_OPTIONAL\n\t\tZ_PARAM_BOOL(use_include_path)\n\t\tZ_PARAM_RESOURCE_OR_NULL(zcontext)\n\tZEND_PARSE_PARAMETERS_END();\n\n\tcontext = php_stream_context_from_zval(zcontext, 0);\n\n\tstream = php_stream_open_wrapper_ex(filename, \"rb\", (use_include_path ? USE_PATH : 0) | REPORT_ERRORS, NULL, context);\n\tif (stream) {\n\t\tsize = php_stream_passthru(stream);\n\t\tphp_stream_close(stream);\n\t\tRETURN_LONG(size);\n\t}\n\n\tRETURN_FALSE;\n}\n/* }}} */\n\n/* {{{ Return or change the umask */\nPHP_FUNCTION(umask)\n{\n\tzend_long mask = 0;\n\tbool mask_is_null = 1;\n\tint oldumask;\n\n\tZEND_PARSE_PARAMETERS_START(0, 1)\n\t\tZ_PARAM_OPTIONAL\n\t\tZ_PARAM_LONG_OR_NULL(mask, mask_is_null)\n\tZEND_PARSE_PARAMETERS_END();\n\n\toldumask = umask(077);\n\n\tif (BG(umask) == -1) {\n\t\tBG(umask) = oldumask;\n\t}\n\n\tif (mask_is_null) {\n\t\tumask(oldumask);\n\t} else {\n\t\tumask((int) mask);\n\t}\n\n\tRETURN_LONG(oldumask);\n}\n/* }}} */\n\n/* {{{ Output all remaining data from a file pointer */\nPHPAPI PHP_FUNCTION(fpassthru)\n{\n\tsize_t size;\n\tphp_stream *stream;\n\n\tZEND_PARSE_PARAMETERS_START(1, 1)\n\t\tPHP_Z_PARAM_STREAM(stream)\n\tZEND_PARSE_PARAMETERS_END();\n\n\tsize = php_stream_passthru(stream);\n\tRETURN_LONG(size);\n}\n/* }}} */\n\n/* {{{ Rename a file */\nPHP_FUNCTION(rename)\n{\n\tchar *old_name, *new_name;\n\tsize_t old_name_len, new_name_len;\n\tzval *zcontext = NULL;\n\tphp_stream_wrapper *wrapper;\n\tphp_stream_context *context;\n\n\tZEND_PARSE_PARAMETERS_START(2, 3)\n\t\tZ_PARAM_PATH(old_name, old_name_len)\n\t\tZ_PARAM_PATH(new_name, new_name_len)\n\t\tZ_PARAM_OPTIONAL\n\t\tZ_PARAM_RESOURCE_OR_NULL(zcontext)\n\tZEND_PARSE_PARAMETERS_END();\n\n\twrapper = php_stream_locate_url_wrapper(old_name, NULL, 0);\n\n\tif (!wrapper || !wrapper->wops) {\n\t\tphp_error_docref(NULL, E_WARNING, \"Unable to locate stream wrapper\");\n\t\tRETURN_FALSE;\n\t}\n\n\tif (!wrapper->wops->rename) {\n\t\tphp_error_docref(NULL, E_WARNING, \"%s wrapper does not support renaming\", wrapper->wops->label ? wrapper->wops->label : \"Source\");\n\t\tRETURN_FALSE;\n\t}\n\n\tif (wrapper != php_stream_locate_url_wrapper(new_name, NULL, 0)) {\n\t\tphp_error_docref(NULL, E_WARNING, \"Cannot rename a file across wrapper types\");\n\t\tRETURN_FALSE;\n\t}\n\n\tcontext = php_stream_context_from_zval(zcontext, 0);\n\n\tRETURN_BOOL(wrapper->wops->rename(wrapper, old_name, new_name, 0, context));\n}\n/* }}} */\n\n/* {{{ Delete a file */\nPHP_FUNCTION(unlink)\n{\n\tchar *filename;\n\tsize_t filename_len;\n\tphp_stream_wrapper *wrapper;\n\tzval *zcontext = NULL;\n\tphp_stream_context *context = NULL;\n\n\tZEND_PARSE_PARAMETERS_START(1, 2)\n\t\tZ_PARAM_PATH(filename, filename_len)\n\t\tZ_PARAM_OPTIONAL\n\t\tZ_PARAM_RESOURCE_OR_NULL(zcontext)\n\tZEND_PARSE_PARAMETERS_END();\n\n\tcontext = php_stream_context_from_zval(zcontext, 0);\n\n\twrapper = php_stream_locate_url_wrapper(filename, NULL, 0);\n\n\tif (!wrapper || !wrapper->wops) {\n\t\tphp_error_docref(NULL, E_WARNING, \"Unable to locate stream wrapper\");\n\t\tRETURN_FALSE;\n\t}\n\n\tif (!wrapper->wops->unlink) {\n\t\tphp_error_docref(NULL, E_WARNING, \"%s does not allow unlinking\", wrapper->wops->label ? wrapper->wops->label : \"Wrapper\");\n\t\tRETURN_FALSE;\n\t}\n\tRETURN_BOOL(wrapper->wops->unlink(wrapper, filename, REPORT_ERRORS, context));\n}\n/* }}} */\n\nPHP_FUNCTION(fsync)\n{\n\tphp_stream *stream;\n\n\tZEND_PARSE_PARAMETERS_START(1, 1)\n\t\tPHP_Z_PARAM_STREAM(stream)\n\tZEND_PARSE_PARAMETERS_END();\n\n\tif (!php_stream_sync_supported(stream)) {\n\t\tphp_error_docref(NULL, E_WARNING, \"Can't fsync this stream!\");\n\t\tRETURN_FALSE;\n\t}\n\n\tRETURN_BOOL(php_stream_sync(stream, /* data_only */ 0) == 0);\n}\n\nPHP_FUNCTION(fdatasync)\n{\n\tphp_stream *stream;\n\n\tZEND_PARSE_PARAMETERS_START(1, 1)\n\t\tPHP_Z_PARAM_STREAM(stream)\n\tZEND_PARSE_PARAMETERS_END();\n\n\tif (!php_stream_sync_supported(stream)) {\n\t\tphp_error_docref(NULL, E_WARNING, \"Can't fsync this stream!\");\n\t\tRETURN_FALSE;\n\t}\n\n\tRETURN_BOOL(php_stream_sync(stream, /* data_only */ 1) == 0);\n}\n\n/* {{{ Truncate file to 'size' length */\nPHP_FUNCTION(ftruncate)\n{\n\tzend_long size;\n\tphp_stream *stream;\n\n\tZEND_PARSE_PARAMETERS_START(2, 2)\n\t\tPHP_Z_PARAM_STREAM(stream)\n\t\tZ_PARAM_LONG(size)\n\tZEND_PARSE_PARAMETERS_END();\n\n\tif (size < 0) {\n\t\tzend_argument_value_error(2, \"must be greater than or equal to 0\");\n\t\tRETURN_THROWS();\n\t}\n\n\tif (!php_stream_truncate_supported(stream)) {\n\t\tphp_error_docref(NULL, E_WARNING, \"Can't truncate this stream!\");\n\t\tRETURN_FALSE;\n\t}\n\n\tRETURN_BOOL(0 == php_stream_truncate_set_size(stream, size));\n}\n/* }}} */\nPHPAPI void php_fstat(php_stream *stream, zval *return_value)\n{\n\tphp_stream_statbuf stat_ssb;\n\tzval stat_dev, stat_ino, stat_mode, stat_nlink, stat_uid, stat_gid, stat_rdev,\n\t\t stat_size, stat_atime, stat_mtime, stat_ctime, stat_blksize, stat_blocks;\n\tchar *stat_sb_names[13] = {\n\t\t\"dev\", \"ino\", \"mode\", \"nlink\", \"uid\", \"gid\", \"rdev\",\n\t\t\"size\", \"atime\", \"mtime\", \"ctime\", \"blksize\", \"blocks\"\n\t};\n\n\tif (php_stream_stat(stream, &stat_ssb)) {\n\t\tRETURN_FALSE;\n\t}\n\n\tarray_init(return_value);\n\n\tZVAL_LONG(&stat_dev, stat_ssb.sb.st_dev);\n\tZVAL_LONG(&stat_ino, stat_ssb.sb.st_ino);\n\tZVAL_LONG(&stat_mode, stat_ssb.sb.st_mode);\n\tZVAL_LONG(&stat_nlink, stat_ssb.sb.st_nlink);\n\tZVAL_LONG(&stat_uid, stat_ssb.sb.st_uid);\n\tZVAL_LONG(&stat_gid, stat_ssb.sb.st_gid);\n#ifdef HAVE_STRUCT_STAT_ST_RDEV\n\tZVAL_LONG(&stat_rdev, stat_ssb.sb.st_rdev);\n#else\n\tZVAL_LONG(&stat_rdev, -1);\n#endif\n\tZVAL_LONG(&stat_size, stat_ssb.sb.st_size);\n\tZVAL_LONG(&stat_atime, stat_ssb.sb.st_atime);\n\tZVAL_LONG(&stat_mtime, stat_ssb.sb.st_mtime);\n\tZVAL_LONG(&stat_ctime, stat_ssb.sb.st_ctime);\n#ifdef HAVE_STRUCT_STAT_ST_BLKSIZE\n\tZVAL_LONG(&stat_blksize, stat_ssb.sb.st_blksize);\n#else\n\tZVAL_LONG(&stat_blksize,-1);\n#endif\n#ifdef HAVE_STRUCT_STAT_ST_BLOCKS\n\tZVAL_LONG(&stat_blocks, stat_ssb.sb.st_blocks);\n#else\n\tZVAL_LONG(&stat_blocks,-1);\n#endif\n\t/* Store numeric indexes in proper order */\n\tzend_hash_next_index_insert(Z_ARRVAL_P(return_value), &stat_dev);\n\tzend_hash_next_index_insert(Z_ARRVAL_P(return_value), &stat_ino);\n\tzend_hash_next_index_insert(Z_ARRVAL_P(return_value), &stat_mode);\n\tzend_hash_next_index_insert(Z_ARRVAL_P(return_value), &stat_nlink);\n\tzend_hash_next_index_insert(Z_ARRVAL_P(return_value), &stat_uid);\n\tzend_hash_next_index_insert(Z_ARRVAL_P(return_value), &stat_gid);\n\tzend_hash_next_index_insert(Z_ARRVAL_P(return_value), &stat_rdev);\n\tzend_hash_next_index_insert(Z_ARRVAL_P(return_value), &stat_size);\n\tzend_hash_next_index_insert(Z_ARRVAL_P(return_value), &stat_atime);\n\tzend_hash_next_index_insert(Z_ARRVAL_P(return_value), &stat_mtime);\n\tzend_hash_next_index_insert(Z_ARRVAL_P(return_value), &stat_ctime);\n\tzend_hash_next_index_insert(Z_ARRVAL_P(return_value), &stat_blksize);\n\tzend_hash_next_index_insert(Z_ARRVAL_P(return_value), &stat_blocks);\n\n\t/* Store string indexes referencing the same zval*/\n\tzend_hash_str_add_new(Z_ARRVAL_P(return_value), stat_sb_names[0], strlen(stat_sb_names[0]), &stat_dev);\n\tzend_hash_str_add_new(Z_ARRVAL_P(return_value), stat_sb_names[1], strlen(stat_sb_names[1]), &stat_ino);\n\tzend_hash_str_add_new(Z_ARRVAL_P(return_value), stat_sb_names[2], strlen(stat_sb_names[2]), &stat_mode);\n\tzend_hash_str_add_new(Z_ARRVAL_P(return_value), stat_sb_names[3], strlen(stat_sb_names[3]), &stat_nlink);\n\tzend_hash_str_add_new(Z_ARRVAL_P(return_value), stat_sb_names[4], strlen(stat_sb_names[4]), &stat_uid);\n\tzend_hash_str_add_new(Z_ARRVAL_P(return_value), stat_sb_names[5], strlen(stat_sb_names[5]), &stat_gid);\n\tzend_hash_str_add_new(Z_ARRVAL_P(return_value), stat_sb_names[6], strlen(stat_sb_names[6]), &stat_rdev);\n\tzend_hash_str_add_new(Z_ARRVAL_P(return_value), stat_sb_names[7], strlen(stat_sb_names[7]), &stat_size);\n\tzend_hash_str_add_new(Z_ARRVAL_P(return_value), stat_sb_names[8], strlen(stat_sb_names[8]), &stat_atime);\n\tzend_hash_str_add_new(Z_ARRVAL_P(return_value), stat_sb_names[9], strlen(stat_sb_names[9]), &stat_mtime);\n\tzend_hash_str_add_new(Z_ARRVAL_P(return_value), stat_sb_names[10], strlen(stat_sb_names[10]), &stat_ctime);\n\tzend_hash_str_add_new(Z_ARRVAL_P(return_value), stat_sb_names[11], strlen(stat_sb_names[11]), &stat_blksize);\n\tzend_hash_str_add_new(Z_ARRVAL_P(return_value), stat_sb_names[12], strlen(stat_sb_names[12]), &stat_blocks);\n}\n\n/* {{{ Stat() on a filehandle */\nPHP_FUNCTION(fstat)\n{\n\tphp_stream *stream;\n\n\tZEND_PARSE_PARAMETERS_START(1, 1)\n\t\tPHP_Z_PARAM_STREAM(stream)\n\tZEND_PARSE_PARAMETERS_END();\n\n\tphp_fstat(stream, return_value);\n}\n/* }}} */\n\n/* {{{ Copy a file */\nPHP_FUNCTION(copy)\n{\n\tchar *source, *target;\n\tsize_t source_len, target_len;\n\tzval *zcontext = NULL;\n\tphp_stream_context *context;\n\n\tZEND_PARSE_PARAMETERS_START(2, 3)\n\t\tZ_PARAM_PATH(source, source_len)\n\t\tZ_PARAM_PATH(target, target_len)\n\t\tZ_PARAM_OPTIONAL\n\t\tZ_PARAM_RESOURCE_OR_NULL(zcontext)\n\tZEND_PARSE_PARAMETERS_END();\n\n\tif (php_stream_locate_url_wrapper(source, NULL, 0) == &php_plain_files_wrapper && php_check_open_basedir(source)) {\n\t\tRETURN_FALSE;\n\t}\n\n\tcontext = php_stream_context_from_zval(zcontext, 0);\n\n\tRETURN_BOOL(php_copy_file_ctx(source, target, 0, context) == SUCCESS);\n}\n/* }}} */\n\n/* {{{ php_copy_file */\nPHPAPI zend_result php_copy_file(const char *src, const char *dest)\n{\n\treturn php_copy_file_ctx(src, dest, 0, NULL);\n}\n/* }}} */\n\n/* {{{ php_copy_file_ex */\nPHPAPI zend_result php_copy_file_ex(const char *src, const char *dest, int src_flags)\n{\n\treturn php_copy_file_ctx(src, dest, src_flags, NULL);\n}\n/* }}} */\n\n/* {{{ php_copy_file_ctx */\nPHPAPI zend_result php_copy_file_ctx(const char *src, const char *dest, int src_flags, php_stream_context *ctx)\n{\n\tphp_stream *srcstream = NULL, *deststream = NULL;\n\tzend_result ret = FAILURE;\n\tphp_stream_statbuf src_s, dest_s;\n\tint src_stat_flags = (src_flags & STREAM_DISABLE_OPEN_BASEDIR) ? PHP_STREAM_URL_STAT_IGNORE_OPEN_BASEDIR : 0;\n\n\tswitch (php_stream_stat_path_ex(src, src_stat_flags, &src_s, ctx)) {\n\t\tcase -1:\n\t\t\t/* non-statable stream */\n\t\t\tgoto safe_to_copy;\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tbreak;\n\t\tdefault: /* failed to stat file, does not exist? */\n\t\t\treturn ret;\n\t}\n\tif (S_ISDIR(src_s.sb.st_mode)) {\n\t\tphp_error_docref(NULL, E_WARNING, \"The first argument to copy() function cannot be a directory\");\n\t\treturn FAILURE;\n\t}\n\n\tswitch (php_stream_stat_path_ex(dest, PHP_STREAM_URL_STAT_QUIET, &dest_s, ctx)) {\n\t\tcase -1:\n\t\t\t/* non-statable stream */\n\t\t\tgoto safe_to_copy;\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tbreak;\n\t\tdefault: /* failed to stat file, does not exist? */\n\t\t\treturn ret;\n\t}\n\tif (S_ISDIR(dest_s.sb.st_mode)) {\n\t\tphp_error_docref(NULL, E_WARNING, \"The second argument to copy() function cannot be a directory\");\n\t\treturn FAILURE;\n\t}\n\tif (!src_s.sb.st_ino || !dest_s.sb.st_ino) {\n\t\tgoto no_stat;\n\t}\n\tif (src_s.sb.st_ino == dest_s.sb.st_ino && src_s.sb.st_dev == dest_s.sb.st_dev) {\n\t\treturn ret;\n\t} else {\n\t\tgoto safe_to_copy;\n\t}\nno_stat:\n\t{\n\t\tchar *sp, *dp;\n\t\tint res;\n\n\t\tif ((sp = expand_filepath(src, NULL)) == NULL) {\n\t\t\treturn ret;\n\t\t}\n\t\tif ((dp = expand_filepath(dest, NULL)) == NULL) {\n\t\t\tefree(sp);\n\t\t\tgoto safe_to_copy;\n\t\t}\n\n\t\tres =\n#ifndef PHP_WIN32\n\t\t\t!strcmp(sp, dp);\n#else\n\t\t\t!strcasecmp(sp, dp);\n#endif\n\n\t\tefree(sp);\n\t\tefree(dp);\n\t\tif (res) {\n\t\t\treturn ret;\n\t\t}\n\t}\nsafe_to_copy:\n\n\tsrcstream = php_stream_open_wrapper_ex(src, \"rb\", src_flags | REPORT_ERRORS, NULL, ctx);\n\n\tif (!srcstream) {\n\t\treturn ret;\n\t}\n\n\tdeststream = php_stream_open_wrapper_ex(dest, \"wb\", REPORT_ERRORS, NULL, ctx);\n\n\tif (deststream) {\n\t\tret = php_stream_copy_to_stream_ex(srcstream, deststream, PHP_STREAM_COPY_ALL, NULL);\n\t}\n\tphp_stream_close(srcstream);\n\tif (deststream) {\n\t\tphp_stream_close(deststream);\n\t}\n\treturn ret;\n}\n/* }}} */\n\n/* {{{ Binary-safe file read */\nPHPAPI PHP_FUNCTION(fread)\n{\n\tzend_long len;\n\tphp_stream *stream;\n\tzend_string *str;\n\n\tZEND_PARSE_PARAMETERS_START(2, 2)\n\t\tPHP_Z_PARAM_STREAM(stream)\n\t\tZ_PARAM_LONG(len)\n\tZEND_PARSE_PARAMETERS_END();\n\n\tif (len <= 0) {\n\t\tzend_argument_value_error(2, \"must be greater than 0\");\n\t\tRETURN_THROWS();\n\t}\n\n\tstr = php_stream_read_to_str(stream, len);\n\tif (!str) {\n\t\tzval_ptr_dtor_str(return_value);\n\t\tRETURN_FALSE;\n\t}\n\n\tRETURN_STR(str);\n}\n/* }}} */\n\nstatic const char *php_fgetcsv_lookup_trailing_spaces(const char *ptr, size_t len) /* {{{ */\n{\n\tint inc_len;\n\tunsigned char last_chars[2] = { 0, 0 };\n\n\twhile (len > 0) {\n\t\tinc_len = (*ptr == '\\0' ? 1 : php_mblen(ptr, len));\n\t\tswitch (inc_len) {\n\t\t\tcase -2:\n\t\t\tcase -1:\n\t\t\t\tinc_len = 1;\n\t\t\t\tphp_mb_reset();\n\t\t\t\tbreak;\n\t\t\tcase 0:\n\t\t\t\tgoto quit_loop;\n\t\t\tcase 1:\n\t\t\tdefault:\n\t\t\t\tlast_chars[0] = last_chars[1];\n\t\t\t\tlast_chars[1] = *ptr;\n\t\t\t\tbreak;\n\t\t}\n\t\tptr += inc_len;\n\t\tlen -= inc_len;\n\t}\nquit_loop:\n\tswitch (last_chars[1]) {\n\t\tcase '\\n':\n\t\t\tif (last_chars[0] == '\\r') {\n\t\t\t\treturn ptr - 2;\n\t\t\t}\n\t\t\tZEND_FALLTHROUGH;\n\t\tcase '\\r':\n\t\t\treturn ptr - 1;\n\t}\n\treturn ptr;\n}\n/* }}} */\n\nPHPAPI int php_csv_handle_escape_argument(const zend_string *escape_str, uint32_t arg_num)\n{\n\tif (escape_str != NULL) {\n\t\tif (ZSTR_LEN(escape_str) > 1) {\n\t\t\tzend_argument_value_error(arg_num, \"must be empty or a single character\");\n\t\t\treturn PHP_CSV_ESCAPE_ERROR;\n\t\t}\n\t\tif (ZSTR_LEN(escape_str) < 1) {\n\t\t\treturn PHP_CSV_NO_ESCAPE;\n\t\t} else {\n\t\t\t/* use first character from string */\n\t\t\treturn (unsigned char) ZSTR_VAL(escape_str)[0];\n\t\t}\n\t} else {\n\t\tphp_error_docref(NULL, E_DEPRECATED, \"the $escape parameter must be provided as its default value will change\");\n\t\tif (UNEXPECTED(EG(exception))) {\n\t\t\treturn PHP_CSV_ESCAPE_ERROR;\n\t\t}\n\t\treturn (unsigned char) '\\\\';\n\t}\n}\n\n#define FPUTCSV_FLD_CHK(c) memchr(ZSTR_VAL(field_str), c, ZSTR_LEN(field_str))\n\n/* {{{ Format line as CSV and write to file pointer */\nPHP_FUNCTION(fputcsv)\n{\n\tchar delimiter = ',';\t\t\t\t\t/* allow this to be set as parameter */\n\tchar enclosure = '\"';\t\t\t\t\t/* allow this to be set as parameter */\n\tphp_stream *stream;\n\tzval *fields = NULL;\n\tssize_t ret;\n\tchar *delimiter_str = NULL, *enclosure_str = NULL;\n\tzend_string *escape_str = NULL;\n\tsize_t delimiter_str_len = 0, enclosure_str_len = 0;\n\tzend_string *eol_str = NULL;\n\n\tZEND_PARSE_PARAMETERS_START(2, 6)\n\t\tPHP_Z_PARAM_STREAM(stream)\n\t\tZ_PARAM_ARRAY(fields)\n\t\tZ_PARAM_OPTIONAL\n\t\tZ_PARAM_STRING(delimiter_str, delimiter_str_len)\n\t\tZ_PARAM_STRING(enclosure_str, enclosure_str_len)\n\t\tZ_PARAM_STR(escape_str)\n\t\tZ_PARAM_STR_OR_NULL(eol_str)\n\tZEND_PARSE_PARAMETERS_END();\n\n\tif (delimiter_str != NULL) {\n\t\t/* Make sure that there is at least one character in string */\n\t\tif (delimiter_str_len != 1) {\n\t\t\tzend_argument_value_error(3, \"must be a single character\");\n\t\t\tRETURN_THROWS();\n\t\t}\n\n\t\t/* use first character from string */\n\t\tdelimiter = *delimiter_str;\n\t}\n\n\tif (enclosure_str != NULL) {\n\t\tif (enclosure_str_len != 1) {\n\t\t\tzend_argument_value_error(4, \"must be a single character\");\n\t\t\tRETURN_THROWS();\n\t\t}\n\t\t/* use first character from string */\n\t\tenclosure = *enclosure_str;\n\t}\n\n\tint escape_char = php_csv_handle_escape_argument(escape_str, 5);\n\tif (escape_char == PHP_CSV_ESCAPE_ERROR) {\n\t\tRETURN_THROWS();\n\t}\n\n\tret = php_fputcsv(stream, fields, delimiter, enclosure, escape_char, eol_str);\n\tif (ret < 0) {\n\t\tRETURN_FALSE;\n\t}\n\tRETURN_LONG(ret);\n}\n/* }}} */\n\n/* {{{ PHPAPI size_t php_fputcsv(php_stream *stream, zval *fields, char delimiter, char enclosure, int escape_char, zend_string *eol_str) */\nPHPAPI ssize_t php_fputcsv(php_stream *stream, zval *fields, char delimiter, char enclosure, int escape_char, zend_string *eol_str)\n{\n\tuint32_t count, i = 0;\n\tsize_t ret;\n\tzval *field_tmp;\n\tsmart_str csvline = {0};\n\n\tZEND_ASSERT((escape_char >= 0 && escape_char <= UCHAR_MAX) || escape_char == PHP_CSV_NO_ESCAPE);\n\tcount = zend_hash_num_elements(Z_ARRVAL_P(fields));\n\tZEND_HASH_FOREACH_VAL(Z_ARRVAL_P(fields), field_tmp) {\n\t\tzend_string *tmp_field_str;\n\t\tzend_string *field_str = zval_get_tmp_string(field_tmp, &tmp_field_str);\n\n\t\t/* enclose a field that contains a delimiter, an enclosure character, or a newline */\n\t\tif (FPUTCSV_FLD_CHK(delimiter) ||\n\t\t\tFPUTCSV_FLD_CHK(enclosure) ||\n\t\t\t(escape_char != PHP_CSV_NO_ESCAPE && FPUTCSV_FLD_CHK(escape_char)) ||\n\t\t\tFPUTCSV_FLD_CHK('\\n') ||\n\t\t\tFPUTCSV_FLD_CHK('\\r') ||\n\t\t\tFPUTCSV_FLD_CHK('\\t') ||\n\t\t\tFPUTCSV_FLD_CHK(' ')\n\t\t) {\n\t\t\tchar *ch = ZSTR_VAL(field_str);\n\t\t\tchar *end = ch + ZSTR_LEN(field_str);\n\t\t\tint escaped = 0;\n\n\t\t\tsmart_str_appendc(&csvline, enclosure);\n\t\t\twhile (ch < end) {\n\t\t\t\tif (escape_char != PHP_CSV_NO_ESCAPE && *ch == escape_char) {\n\t\t\t\t\tescaped = 1;\n\t\t\t\t} else if (!escaped && *ch == enclosure) {\n\t\t\t\t\tsmart_str_appendc(&csvline, enclosure);\n\t\t\t\t} else {\n\t\t\t\t\tescaped = 0;\n\t\t\t\t}\n\t\t\t\tsmart_str_appendc(&csvline, *ch);\n\t\t\t\tch++;\n\t\t\t}\n\t\t\tsmart_str_appendc(&csvline, enclosure);\n\t\t} else {\n\t\t\tsmart_str_append(&csvline, field_str);\n\t\t}\n\n\t\tif (++i != count) {\n\t\t\tsmart_str_appendl(&csvline, &delimiter, 1);\n\t\t}\n\t\tzend_tmp_string_release(tmp_field_str);\n\t} ZEND_HASH_FOREACH_END();\n\n\tif (eol_str) {\n\t\tsmart_str_append(&csvline, eol_str);\n\t} else {\n\t\tsmart_str_appendc(&csvline, '\\n');\n\t}\n\tsmart_str_0(&csvline);\n\n\tret = php_stream_write(stream, ZSTR_VAL(csvline.s), ZSTR_LEN(csvline.s));\n\n\tsmart_str_free(&csvline);\n\n\treturn ret;\n}\n/* }}} */\n\n/* {{{ Get line from file pointer and parse for CSV fields */\nPHP_FUNCTION(fgetcsv)\n{\n\tchar delimiter = ',';\t/* allow this to be set as parameter */\n\tchar enclosure = '\"';\t/* allow this to be set as parameter */\n\n\tzend_long len = 0;\n\tsize_t buf_len;\n\tchar *buf;\n\tphp_stream *stream;\n\n\tbool len_is_null = 1;\n\tchar *delimiter_str = NULL;\n\tsize_t delimiter_str_len = 0;\n\tchar *enclosure_str = NULL;\n\tsize_t enclosure_str_len = 0;\n\tzend_string *escape_str = NULL;\n\n\tZEND_PARSE_PARAMETERS_START(1, 5)\n\t\tPHP_Z_PARAM_STREAM(stream)\n\t\tZ_PARAM_OPTIONAL\n\t\tZ_PARAM_LONG_OR_NULL(len, len_is_null)\n\t\tZ_PARAM_STRING(delimiter_str, delimiter_str_len)\n\t\tZ_PARAM_STRING(enclosure_str, enclosure_str_len)\n\t\tZ_PARAM_STR(escape_str)\n\tZEND_PARSE_PARAMETERS_END();\n\n\tif (delimiter_str != NULL) {\n\t\t/* Make sure that there is at least one character in string */\n\t\tif (delimiter_str_len != 1) {\n\t\t\tzend_argument_value_error(3, \"must be a single character\");\n\t\t\tRETURN_THROWS();\n\t\t}\n\n\t\t/* use first character from string */\n\t\tdelimiter = delimiter_str[0];\n\t}\n\n\tif (enclosure_str != NULL) {\n\t\tif (enclosure_str_len != 1) {\n\t\t\tzend_argument_value_error(4, \"must be a single character\");\n\t\t\tRETURN_THROWS();\n\t\t}\n\n\t\t/* use first character from string */\n\t\tenclosure = enclosure_str[0];\n\t}\n\n\tint escape_char = php_csv_handle_escape_argument(escape_str, 5);\n\tif (escape_char == PHP_CSV_ESCAPE_ERROR) {\n\t\tRETURN_THROWS();\n\t}\n\n\tif (len_is_null || len == 0) {\n\t\tlen = -1;\n\t} else if (len < 0 || len > (ZEND_LONG_MAX - 1)) {\n\t\tzend_argument_value_error(2, \"must be between 0 and \" ZEND_LONG_FMT, (ZEND_LONG_MAX - 1));\n\t\tRETURN_THROWS();\n\t}\n\n\tif (len < 0) {\n\t\tif ((buf = php_stream_get_line(stream, NULL, 0, &buf_len)) == NULL) {\n\t\t\tRETURN_FALSE;\n\t\t}\n\t} else {\n\t\tbuf = emalloc(len + 1);\n\t\tif (php_stream_get_line(stream, buf, len + 1, &buf_len) == NULL) {\n\t\t\tefree(buf);\n\t\t\tRETURN_FALSE;\n\t\t}\n\t}\n\n\tHashTable *values = php_fgetcsv(stream, delimiter, enclosure, escape_char, buf_len, buf);\n\tif (values == NULL) {\n\t\tvalues = php_bc_fgetcsv_empty_line();\n\t}\n\tRETURN_ARR(values);\n}\n/* }}} */\n\nPHPAPI HashTable *php_bc_fgetcsv_empty_line(void)\n{\n\tHashTable *values = zend_new_array(1);\n\tzval tmp;\n\tZVAL_NULL(&tmp);\n\tzend_hash_next_index_insert(values, &tmp);\n\treturn values;\n}\n\nPHPAPI HashTable *php_fgetcsv(php_stream *stream, char delimiter, char enclosure, int escape_char, size_t buf_len, char *buf) /* {{{ */\n{\n\tchar *temp, *bptr, *line_end, *limit;\n\tsize_t temp_len, line_end_len;\n\tint inc_len;\n\tbool first_field = true;\n\n\tZEND_ASSERT((escape_char >= 0 && escape_char <= UCHAR_MAX) || escape_char == PHP_CSV_NO_ESCAPE);\n\n\t/* initialize internal state */\n\tphp_mb_reset();\n\n\t/* Now into new section that parses buf for delimiter/enclosure fields */\n\n\t/* Strip trailing space from buf, saving end of line in case required for enclosure field */\n\n\tbptr = buf;\n\tline_end = limit = (char *)php_fgetcsv_lookup_trailing_spaces(buf, buf_len);\n\tline_end_len = buf_len - (size_t)(limit - buf);\n\n\t/* reserve workspace for building each individual field */\n\ttemp_len = buf_len;\n\ttemp = emalloc(temp_len + line_end_len + 1);\n\n\t/* Initialize values HashTable */\n\tHashTable *values = zend_new_array(0);\n\n\t/* Main loop to read CSV fields */\n\t/* NB this routine will return NULL for a blank line */\n\tdo {\n\t\tchar *comp_end, *hunk_begin;\n\t\tchar *tptr = temp;\n\n\t\tinc_len = (bptr < limit ? (*bptr == '\\0' ? 1 : php_mblen(bptr, limit - bptr)): 0);\n\t\tif (inc_len == 1) {\n\t\t\tchar *tmp = bptr;\n\t\t\twhile ((*tmp != delimiter) && isspace((int)*(unsigned char *)tmp)) {\n\t\t\t\ttmp++;\n\t\t\t}\n\t\t\tif (*tmp == enclosure && tmp < limit) {\n\t\t\t\tbptr = tmp;\n\t\t\t}\n\t\t}\n\n\t\tif (first_field && bptr == line_end) {\n\t\t\tzend_array_destroy(values);\n\t\t\tvalues = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tfirst_field = false;\n\t\t/* 2. Read field, leaving bptr pointing at start of next field */\n\t\tif (inc_len != 0 && *bptr == enclosure) {\n\t\t\tint state = 0;\n\n\t\t\tbptr++;\t/* move on to first character in field */\n\t\t\thunk_begin = bptr;\n\n\t\t\t/* 2A. handle enclosure delimited field */\n\t\t\tfor (;;) {\n\t\t\t\tswitch (inc_len) {\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tswitch (state) {\n\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\t\ttptr = zend_mempcpy(tptr, hunk_begin, (bptr - hunk_begin - 1));\n\t\t\t\t\t\t\t\thunk_begin = bptr;\n\t\t\t\t\t\t\t\tgoto quit_loop_2;\n\n\t\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\t\ttptr = zend_mempcpy(tptr, hunk_begin, (bptr - hunk_begin));\n\t\t\t\t\t\t\t\thunk_begin = bptr;\n\t\t\t\t\t\t\t\tZEND_FALLTHROUGH;\n\n\t\t\t\t\t\t\tcase 0: {\n\t\t\t\t\t\t\t\tif (hunk_begin != line_end) {\n\t\t\t\t\t\t\t\t\ttptr = zend_mempcpy(tptr, hunk_begin, (bptr - hunk_begin));\n\t\t\t\t\t\t\t\t\thunk_begin = bptr;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t/* add the embedded line end to the field */\n\t\t\t\t\t\t\t\ttptr = zend_mempcpy(tptr, line_end, line_end_len);\n\n\t\t\t\t\t\t\t\t/* nothing can be fetched if stream is NULL (e.g. str_getcsv()) */\n\t\t\t\t\t\t\t\tif (stream == NULL) {\n\t\t\t\t\t\t\t\t\t/* the enclosure is unterminated */\n\t\t\t\t\t\t\t\t\tif (bptr > limit) {\n\t\t\t\t\t\t\t\t\t\t/* if the line ends with enclosure, we need to go back by\n\t\t\t\t\t\t\t\t\t\t * one character so the \\0 character is not copied. */\n\t\t\t\t\t\t\t\t\t\tif (hunk_begin == bptr) {\n\t\t\t\t\t\t\t\t\t\t\t--hunk_begin;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t--bptr;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tgoto quit_loop_2;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tsize_t new_len;\n\t\t\t\t\t\t\t\tchar *new_buf = php_stream_get_line(stream, NULL, 0, &new_len);\n\t\t\t\t\t\t\t\tif (!new_buf) {\n\t\t\t\t\t\t\t\t\t/* we've got an unterminated enclosure,\n\t\t\t\t\t\t\t\t\t * assign all the data from the start of\n\t\t\t\t\t\t\t\t\t * the enclosure to end of data to the\n\t\t\t\t\t\t\t\t\t * last element */\n\t\t\t\t\t\t\t\t\tif (bptr > limit) {\n\t\t\t\t\t\t\t\t\t\t/* if the line ends with enclosure, we need to go back by\n\t\t\t\t\t\t\t\t\t\t * one character so the \\0 character is not copied. */\n\t\t\t\t\t\t\t\t\t\tif (hunk_begin == bptr) {\n\t\t\t\t\t\t\t\t\t\t\t--hunk_begin;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t--bptr;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tgoto quit_loop_2;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\ttemp_len += new_len;\n\t\t\t\t\t\t\t\tchar *new_temp = erealloc(temp, temp_len);\n\t\t\t\t\t\t\t\ttptr = new_temp + (size_t)(tptr - temp);\n\t\t\t\t\t\t\t\ttemp = new_temp;\n\n\t\t\t\t\t\t\t\tefree(buf);\n\t\t\t\t\t\t\t\tbuf_len = new_len;\n\t\t\t\t\t\t\t\tbptr = buf = new_buf;\n\t\t\t\t\t\t\t\thunk_begin = buf;\n\n\t\t\t\t\t\t\t\tline_end = limit = (char *)php_fgetcsv_lookup_trailing_spaces(buf, buf_len);\n\t\t\t\t\t\t\t\tline_end_len = buf_len - (size_t)(limit - buf);\n\n\t\t\t\t\t\t\t\tstate = 0;\n\t\t\t\t\t\t\t} break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase -2:\n\t\t\t\t\tcase -1:\n\t\t\t\t\t\tphp_mb_reset();\n\t\t\t\t\t\tZEND_FALLTHROUGH;\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\t/* we need to determine if the enclosure is\n\t\t\t\t\t\t * 'real' or is it escaped */\n\t\t\t\t\t\tswitch (state) {\n\t\t\t\t\t\t\tcase 1: /* escaped */\n\t\t\t\t\t\t\t\tbptr++;\n\t\t\t\t\t\t\t\tstate = 0;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 2: /* embedded enclosure ? let's check it */\n\t\t\t\t\t\t\t\tif (*bptr != enclosure) {\n\t\t\t\t\t\t\t\t\t/* real enclosure */\n\t\t\t\t\t\t\t\t\ttptr = zend_mempcpy(tptr, hunk_begin, bptr - hunk_begin - 1);\n\t\t\t\t\t\t\t\t\thunk_begin = bptr;\n\t\t\t\t\t\t\t\t\tgoto quit_loop_2;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\ttptr = zend_mempcpy(tptr, hunk_begin, bptr - hunk_begin);\n\t\t\t\t\t\t\t\tbptr++;\n\t\t\t\t\t\t\t\thunk_begin = bptr;\n\t\t\t\t\t\t\t\tstate = 0;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tif (*bptr == enclosure) {\n\t\t\t\t\t\t\t\t\tstate = 2;\n\t\t\t\t\t\t\t\t} else if (escape_char != PHP_CSV_NO_ESCAPE && *bptr == escape_char) {\n\t\t\t\t\t\t\t\t\tstate = 1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbptr++;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tswitch (state) {\n\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\t\t/* real enclosure */\n\t\t\t\t\t\t\t\ttptr = zend_mempcpy(tptr, hunk_begin, bptr - hunk_begin - 1);\n\t\t\t\t\t\t\t\thunk_begin = bptr;\n\t\t\t\t\t\t\t\tgoto quit_loop_2;\n\t\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\t\tbptr += inc_len;\n\t\t\t\t\t\t\t\ttptr = zend_mempcpy(tptr, hunk_begin, bptr - hunk_begin);\n\t\t\t\t\t\t\t\thunk_begin = bptr;\n\t\t\t\t\t\t\t\tstate = 0;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tbptr += inc_len;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tinc_len = (bptr < limit ? (*bptr == '\\0' ? 1 : php_mblen(bptr, limit - bptr)): 0);\n\t\t\t}\n\n\t\tquit_loop_2:\n\t\t\t/* look up for a delimiter */\n\t\t\tfor (;;) {\n\t\t\t\tswitch (inc_len) {\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tgoto quit_loop_3;\n\n\t\t\t\t\tcase -2:\n\t\t\t\t\tcase -1:\n\t\t\t\t\t\tinc_len = 1;\n\t\t\t\t\t\tphp_mb_reset();\n\t\t\t\t\t\tZEND_FALLTHROUGH;\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tif (*bptr == delimiter) {\n\t\t\t\t\t\t\tgoto quit_loop_3;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbptr += inc_len;\n\t\t\t\tinc_len = (bptr < limit ? (*bptr == '\\0' ? 1 : php_mblen(bptr, limit - bptr)): 0);\n\t\t\t}\n\n\t\tquit_loop_3:\n\t\t\ttptr = zend_mempcpy(tptr, hunk_begin, bptr - hunk_begin);\n\t\t\tbptr += inc_len;\n\t\t\tcomp_end = tptr;\n\t\t} else {\n\t\t\t/* 2B. Handle non-enclosure field */\n\n\t\t\thunk_begin = bptr;\n\n\t\t\tfor (;;) {\n\t\t\t\tswitch (inc_len) {\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tgoto quit_loop_4;\n\t\t\t\t\tcase -2:\n\t\t\t\t\tcase -1:\n\t\t\t\t\t\tinc_len = 1;\n\t\t\t\t\t\tphp_mb_reset();\n\t\t\t\t\t\tZEND_FALLTHROUGH;\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tif (*bptr == delimiter) {\n\t\t\t\t\t\t\tgoto quit_loop_4;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbptr += inc_len;\n\t\t\t\tinc_len = (bptr < limit ? (*bptr == '\\0' ? 1 : php_mblen(bptr, limit - bptr)): 0);\n\t\t\t}\n\t\tquit_loop_4:\n\t\t\ttptr = zend_mempcpy(tptr, hunk_begin, bptr - hunk_begin);\n\n\t\t\tcomp_end = (char *)php_fgetcsv_lookup_trailing_spaces(temp, tptr - temp);\n\t\t\tif (*bptr == delimiter) {\n\t\t\t\tbptr++;\n\t\t\t}\n\t\t}\n\n\t\t/* 3. Now pass our field back to php */\n\t\t*comp_end = '\\0';\n\n\t\tzval z_tmp;\n\t\tZVAL_STRINGL(&z_tmp, temp, comp_end - temp);\n\t\tzend_hash_next_index_insert(values, &z_tmp);\n\t} while (inc_len > 0);\n\n\tefree(temp);\n\tif (stream) {\n\t\tefree(buf);\n\t}\n\n\treturn values;\n}\n/* }}} */\n\n/* {{{ Return the resolved path */\nPHP_FUNCTION(realpath)\n{\n\tchar *filename;\n\tsize_t filename_len;\n\tchar resolved_path_buff[MAXPATHLEN];\n\n\tZEND_PARSE_PARAMETERS_START(1, 1)\n\t\tZ_PARAM_PATH(filename, filename_len)\n\tZEND_PARSE_PARAMETERS_END();\n\n\tif (VCWD_REALPATH(filename, resolved_path_buff)) {\n\t\tif (php_check_open_basedir(resolved_path_buff)) {\n\t\t\tRETURN_FALSE;\n\t\t}\n\n#ifdef ZTS\n\t\tif (VCWD_ACCESS(resolved_path_buff, F_OK)) {\n\t\t\tRETURN_FALSE;\n\t\t}\n#endif\n\t\tRETURN_STRING(resolved_path_buff);\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n}\n/* }}} */\n\n/* See http://www.w3.org/TR/html4/intro/sgmltut.html#h-3.2.2 */\n#define PHP_META_HTML401_CHARS \"-_.:\"\n\n/* {{{ php_next_meta_token\n   Tokenizes an HTML file for get_meta_tags */\nphp_meta_tags_token php_next_meta_token(php_meta_tags_data *md)\n{\n\tint ch = 0, compliment;\n\tchar buff[META_DEF_BUFSIZE + 1];\n\n\tmemset((void *)buff, 0, META_DEF_BUFSIZE + 1);\n\n\twhile (md->ulc || (!php_stream_eof(md->stream) && (ch = php_stream_getc(md->stream)))) {\n\t\tif (php_stream_eof(md->stream)) {\n\t\t\tbreak;\n\t\t}\n\n\t\tif (md->ulc) {\n\t\t\tch = md->lc;\n\t\t\tmd->ulc = 0;\n\t\t}\n\n\t\tswitch (ch) {\n\t\t\tcase '<':\n\t\t\t\treturn TOK_OPENTAG;\n\t\t\t\tbreak;\n\n\t\t\tcase '>':\n\t\t\t\treturn TOK_CLOSETAG;\n\t\t\t\tbreak;\n\n\t\t\tcase '=':\n\t\t\t\treturn TOK_EQUAL;\n\t\t\t\tbreak;\n\t\t\tcase '/':\n\t\t\t\treturn TOK_SLASH;\n\t\t\t\tbreak;\n\n\t\t\tcase '\\'':\n\t\t\tcase '\"':\n\t\t\t\tcompliment = ch;\n\t\t\t\tmd->token_len = 0;\n\t\t\t\twhile (!php_stream_eof(md->stream) && (ch = php_stream_getc(md->stream)) && ch != compliment && ch != '<' && ch != '>') {\n\t\t\t\t\tbuff[(md->token_len)++] = ch;\n\n\t\t\t\t\tif (md->token_len == META_DEF_BUFSIZE) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (ch == '<' || ch == '>') {\n\t\t\t\t\t/* Was just an apostrophe */\n\t\t\t\t\tmd->ulc = 1;\n\t\t\t\t\tmd->lc = ch;\n\t\t\t\t}\n\n\t\t\t\t/* We don't need to alloc unless we are in a meta tag */\n\t\t\t\tif (md->in_meta) {\n\t\t\t\t\tmd->token_data = (char *) emalloc(md->token_len + 1);\n\t\t\t\t\tmemcpy(md->token_data, buff, md->token_len+1);\n\t\t\t\t}\n\n\t\t\t\treturn TOK_STRING;\n\t\t\t\tbreak;\n\n\t\t\tcase '\\n':\n\t\t\tcase '\\r':\n\t\t\tcase '\\t':\n\t\t\t\tbreak;\n\n\t\t\tcase ' ':\n\t\t\t\treturn TOK_SPACE;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tif (isalnum(ch)) {\n\t\t\t\t\tmd->token_len = 0;\n\t\t\t\t\tbuff[(md->token_len)++] = ch;\n\t\t\t\t\twhile (!php_stream_eof(md->stream) && (ch = php_stream_getc(md->stream)) && (isalnum(ch) || strchr(PHP_META_HTML401_CHARS, ch))) {\n\t\t\t\t\t\tbuff[(md->token_len)++] = ch;\n\n\t\t\t\t\t\tif (md->token_len == META_DEF_BUFSIZE) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t/* This is ugly, but we have to replace ungetc */\n\t\t\t\t\tif (!isalpha(ch) && ch != '-') {\n\t\t\t\t\t\tmd->ulc = 1;\n\t\t\t\t\t\tmd->lc = ch;\n\t\t\t\t\t}\n\n\t\t\t\t\tmd->token_data = (char *) emalloc(md->token_len + 1);\n\t\t\t\t\tmemcpy(md->token_data, buff, md->token_len+1);\n\n\t\t\t\t\treturn TOK_ID;\n\t\t\t\t} else {\n\t\t\t\t\treturn TOK_OTHER;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn TOK_EOF;\n}\n/* }}} */\n\n#ifdef HAVE_FNMATCH\n/* {{{ Match filename against pattern */\nPHP_FUNCTION(fnmatch)\n{\n\tchar *pattern, *filename;\n\tsize_t pattern_len, filename_len;\n\tzend_long flags = 0;\n\n\tZEND_PARSE_PARAMETERS_START(2, 3)\n\t\tZ_PARAM_PATH(pattern, pattern_len)\n\t\tZ_PARAM_PATH(filename, filename_len)\n\t\tZ_PARAM_OPTIONAL\n\t\tZ_PARAM_LONG(flags)\n\tZEND_PARSE_PARAMETERS_END();\n\n\tif (filename_len >= MAXPATHLEN) {\n\t\tphp_error_docref(NULL, E_WARNING, \"Filename exceeds the maximum allowed length of %d characters\", MAXPATHLEN);\n\t\tRETURN_FALSE;\n\t}\n\tif (pattern_len >= MAXPATHLEN) {\n\t\tphp_error_docref(NULL, E_WARNING, \"Pattern exceeds the maximum allowed length of %d characters\", MAXPATHLEN);\n\t\tRETURN_FALSE;\n\t}\n\n\tRETURN_BOOL( ! fnmatch( pattern, filename, (int)flags ));\n}\n/* }}} */\n#endif\n\n/* {{{ Returns directory path used for temporary files */\nPHP_FUNCTION(sys_get_temp_dir)\n{\n\tZEND_PARSE_PARAMETERS_NONE();\n\n\tRETURN_STRING((char *)php_get_temporary_directory());\n}\n/* }}} */\n", "patch": "@@ -1758,6 +1758,12 @@ PHPAPI PHP_FUNCTION(fread)\n \t\tRETURN_FALSE;\n \t}\n \n+\tif (len > INT_MAX) {\n+\t\t/* string length is int in 5.x so we can not read more than int */\n+\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Length parameter must be no more than %d\", INT_MAX);\n+\t\tRETURN_FALSE;\n+\t}\n+\n \tZ_STRVAL_P(return_value) = emalloc(len + 1);\n \tZ_STRLEN_P(return_value) = php_stream_read(stream, Z_STRVAL_P(return_value), len);\n ", "file_path": "files/2016_8\\79", "file_language": "c", "file_name": "ext/standard/file.c", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}, {"raw_url": "https://github.com/php/php-src/raw/abd159cce48f3e34f08e4751c568e09677d5ec9c/ext/standard/tests/file/bug72114.phpt", "code": "--TEST--\nBug #72114 (Integer underflow / arbitrary null write in fread/gzread)\n--FILE--\n<?php\nini_set('memory_limit', \"2500M\");\n$fp = fopen(\"/dev/zero\", \"r\");\nfread($fp, 2147483648);\n?>\nDone\n--EXPECTF--\nWarning: fread(): Length parameter must be no more than 2147483647 in %s/bug72114.php on line %d\nDone\n", "code_before": "", "patch": "@@ -0,0 +1,12 @@\n+--TEST--\n+Bug #72114 (Integer underflow / arbitrary null write in fread/gzread)\n+--FILE--\n+<?php\n+ini_set('memory_limit', \"2500M\");\n+$fp = fopen(\"/dev/zero\", \"r\");\n+fread($fp, 2147483648);\n+?>\n+Done\n+--EXPECTF--\n+Warning: fread(): Length parameter must be no more than 2147483647 in %s/bug72114.php on line %d\n+Done", "file_path": "files/2016_8\\80", "file_language": "phpt", "file_name": "ext/standard/tests/file/bug72114.phpt", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}], "outdated": 0}
