{"index": 8, "cve_id": "CVE-2016-5351", "cwe_id": ["CWE-20"], "cve_language": "C", "cve_description": "epan/crypt/airpdcap.c in the IEEE 802.11 dissector in Wireshark 1.12.x before 1.12.12 and 2.x before 2.0.4 mishandles the lack of an EAPOL_RSN_KEY, which allows remote attackers to cause a denial of service (application crash) via a crafted packet.", "cvss": "5.9", "publish_date": "August 7, 2016", "AV": "NETWORK", "AC": "HIGH", "PR": "NONE", "UI": "NONE", "S": "UNCHANGED", "C": "NONE", "I": "NONE", "A": "HIGH", "commit_id": "9b0b20b8d5f8c9f7839d58ff6c5900f7e19283b4", "commit_message": "Make sure EAPOL body is big enough for a EAPOL_RSN_KEY.\n\nA pointer to a EAPOL_RSN_KEY is set on the packet presuming the\nwhole EAPOL_RSN_KEY is there.  That's not always the case for\nfuzzed/malicious captures.\n\nBug: 11585\nChange-Id: Ib94b8aceef444c7820e43b969596efdb8dbecccd\nReviewed-on: https://code.wireshark.org/review/15540\nReviewed-by: Michael Mann <mmann78@netscape.net>\nPetri-Dish: Michael Mann <mmann78@netscape.net>\nTested-by: Petri Dish Buildbot <buildbot-no-reply@wireshark.org>\nReviewed-by: Anders Broman <a.broman58@gmail.com>", "commit_date": "2016-05-23T08:04:46Z", "project": "wireshark/wireshark", "url": "https://api.github.com/repos/wireshark/wireshark/commits/9b0b20b8d5f8c9f7839d58ff6c5900f7e19283b4", "html_url": "https://github.com/wireshark/wireshark/commit/9b0b20b8d5f8c9f7839d58ff6c5900f7e19283b4", "windows_before": "", "windows_after": "", "parents": [{"commit_id_before": "b831f251eff85c7cc32085bde5bc789f848a301f", "url_before": "https://api.github.com/repos/wireshark/wireshark/commits/b831f251eff85c7cc32085bde5bc789f848a301f", "html_url_before": "https://github.com/wireshark/wireshark/commit/b831f251eff85c7cc32085bde5bc789f848a301f"}], "details": [{"raw_url": "https://github.com/wireshark/wireshark/raw/9b0b20b8d5f8c9f7839d58ff6c5900f7e19283b4/epan/crypt/airpdcap.c", "code": "/* airpdcap.c\n *\n * Copyright (c) 2006 CACE Technologies, Davis (California)\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the project nor the names of its contributors\n *    may be used to endorse or promote products derived from this software\n *    without specific prior written permission.\n *\n * Alternatively, this software may be distributed under the terms of the\n * GNU General Public License (\"GPL\") version 2 as published by the Free\n * Software Foundation.\n *\n * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n\n/*\n * The files matching airpcap*.[ch] were originally developed as part of\n * Wireshark's support for AirPcap adapters. However, they've been used\n * for general 802.11 decryption for quite some time. It might make sense\n * to rename them accordingly.\n */\n\n/****************************************************************************/\n/*      File includes                                                       */\n\n#include \"config.h\"\n\n#include <glib.h>\n\n#include <wsutil/crc32.h>\n#include <wsutil/rc4.h>\n#include <wsutil/sha1.h>\n#include <wsutil/sha2.h>\n#include <wsutil/md5.h>\n#include <wsutil/pint.h>\n#include <wsutil/aes.h>\n\n#include <epan/tvbuff.h>\n#include <epan/to_str.h>\n#include <epan/strutil.h>\n#include <epan/crypt/airpdcap_rijndael.h>\n\n#include \"airpdcap_system.h\"\n#include \"airpdcap_int.h\"\n\n#include \"airpdcap_debug.h\"\n\n#include \"wep-wpadefs.h\"\n\n\n/****************************************************************************/\n\n/****************************************************************************/\n/*      Constant definitions                                                    */\n\n/*      EAPOL definitions                                                       */\n/**\n * Length of the EAPOL-Key key confirmation key (KCK) used to calculate\n * MIC over EAPOL frame and validate an EAPOL packet (128 bits)\n */\n#define AIRPDCAP_WPA_KCK_LEN    16\n/**\n *Offset of the Key MIC in the EAPOL packet body\n */\n#define AIRPDCAP_WPA_MICKEY_OFFSET      77\n/**\n * Maximum length of the EAPOL packet (it depends on the maximum MAC\n * frame size)\n */\n#define AIRPDCAP_WPA_MAX_EAPOL_LEN      4095\n/**\n * EAPOL Key Descriptor Version 1, used for all EAPOL-Key frames to and\n * from a STA when neither the group nor pairwise ciphers are CCMP for\n * Key Descriptor 1.\n * @note\n * Defined in 802.11i-2004, page 78\n */\n#define AIRPDCAP_WPA_KEY_VER_NOT_CCMP   1\n/**\n * EAPOL Key Descriptor Version 2, used for all EAPOL-Key frames to and\n * from a STA when either the pairwise or the group cipher is AES-CCMP\n * for Key Descriptor 2.\n * /note\n * Defined in 802.11i-2004, page 78\n */\n#define AIRPDCAP_WPA_KEY_VER_AES_CCMP   2\n\n/** Define EAPOL Key Descriptor type values:  use 254 for WPA and 2 for WPA2 **/\n#define AIRPDCAP_RSN_WPA_KEY_DESCRIPTOR 254\n#define AIRPDCAP_RSN_WPA2_KEY_DESCRIPTOR 2\n\n/****************************************************************************/\n\n\n\n/****************************************************************************/\n/*      Macro definitions                                                       */\n\nextern const UINT32 crc32_table[256];\n#define CRC(crc, ch)     (crc = (crc >> 8) ^ crc32_table[(crc ^ (ch)) & 0xff])\n\n#define AIRPDCAP_GET_TK(ptk)    (ptk + 32)\n\n/****************************************************************************/\n\n/****************************************************************************/\n/*      Type definitions                                                        */\n\n/*      Internal function prototype declarations                                */\n\n#ifdef  __cplusplus\nextern \"C\" {\n#endif\n\n/**\n * It is a step of the PBKDF2 (specifically the PKCS #5 v2.0) defined in\n * the RFC 2898 to derive a key (used as PMK in WPA)\n * @param ppbytes [IN] pointer to a password (sequence of between 8 and\n * 63 ASCII encoded characters)\n * @param ssid [IN] pointer to the SSID string encoded in max 32 ASCII\n * encoded characters\n * @param iterations [IN] times to hash the password (4096 for WPA)\n * @param count [IN] ???\n * @param output [OUT] pointer to a preallocated buffer of\n * SHA1_DIGEST_LEN characters that will contain a part of the key\n */\nstatic INT AirPDcapRsnaPwd2PskStep(\n    const guint8 *ppbytes,\n    const guint passLength,\n    const CHAR *ssid,\n    const size_t ssidLength,\n    const INT iterations,\n    const INT count,\n    UCHAR *output)\n    ;\n\n/**\n * It calculates the passphrase-to-PSK mapping reccomanded for use with\n * RSNAs. This implementation uses the PBKDF2 method defined in the RFC\n * 2898.\n * @param passphrase [IN] pointer to a password (sequence of between 8 and\n * 63 ASCII encoded characters)\n * @param ssid [IN] pointer to the SSID string encoded in max 32 ASCII\n * encoded characters\n * @param output [OUT] calculated PSK (to use as PMK in WPA)\n * @note\n * Described in 802.11i-2004, page 165\n */\nstatic INT AirPDcapRsnaPwd2Psk(\n    const CHAR *passphrase,\n    const CHAR *ssid,\n    const size_t ssidLength,\n    UCHAR *output)\n    ;\n\nstatic INT AirPDcapRsnaMng(\n    UCHAR *decrypt_data,\n    guint mac_header_len,\n    guint *decrypt_len,\n    PAIRPDCAP_KEY_ITEM key,\n    AIRPDCAP_SEC_ASSOCIATION *sa,\n    INT offset)\n    ;\n\nstatic INT AirPDcapWepMng(\n    PAIRPDCAP_CONTEXT ctx,\n    UCHAR *decrypt_data,\n    guint mac_header_len,\n    guint *decrypt_len,\n    PAIRPDCAP_KEY_ITEM key,\n    AIRPDCAP_SEC_ASSOCIATION *sa,\n    INT offset)\n    ;\n\nstatic INT AirPDcapRsna4WHandshake(\n    PAIRPDCAP_CONTEXT ctx,\n    const UCHAR *data,\n    AIRPDCAP_SEC_ASSOCIATION *sa,\n    INT offset,\n    const guint tot_len)\n    ;\n/**\n * It checks whether the specified key is corrected or not.\n * @note\n * For a standard WEP key the length will be changed to the standard\n * length, and the type changed in a generic WEP key.\n * @param key [IN] pointer to the key to validate\n * @return\n * - TRUE: the key contains valid fields and values\n * - FALSE: the key has some invalid field or value\n */\nstatic INT AirPDcapValidateKey(\n    PAIRPDCAP_KEY_ITEM key)\n    ;\n\nstatic INT AirPDcapRsnaMicCheck(\n    UCHAR *eapol,\n    USHORT eapol_len,\n    UCHAR KCK[AIRPDCAP_WPA_KCK_LEN],\n    USHORT key_ver)\n    ;\n\n/**\n * @param ctx [IN] pointer to the current context\n * @param id [IN] id of the association (composed by BSSID and MAC of\n * the station)\n * @return\n * - index of the Security Association structure if found\n * - -1, if the specified addresses pair BSSID-STA MAC has not been found\n */\nstatic INT AirPDcapGetSa(\n    PAIRPDCAP_CONTEXT ctx,\n    AIRPDCAP_SEC_ASSOCIATION_ID *id)\n    ;\n\nstatic INT AirPDcapStoreSa(\n    PAIRPDCAP_CONTEXT ctx,\n    AIRPDCAP_SEC_ASSOCIATION_ID *id)\n    ;\n\nstatic INT AirPDcapGetSaAddress(\n    const AIRPDCAP_MAC_FRAME_ADDR4 *frame,\n    AIRPDCAP_SEC_ASSOCIATION_ID *id)\n    ;\n\nstatic const UCHAR * AirPDcapGetStaAddress(\n    const AIRPDCAP_MAC_FRAME_ADDR4 *frame)\n    ;\n\nstatic const UCHAR * AirPDcapGetBssidAddress(\n    const AIRPDCAP_MAC_FRAME_ADDR4 *frame)\n    ;\n\nstatic void AirPDcapRsnaPrfX(\n    AIRPDCAP_SEC_ASSOCIATION *sa,\n    const UCHAR pmk[32],\n    const UCHAR snonce[32],\n    const INT x,        /*      for TKIP 512, for CCMP 384      */\n    UCHAR *ptk)\n    ;\n\n\n/**\n * @param sa  [IN/OUT] pointer to SA that will hold the key\n * @param data [IN] Frame\n * @param offset_rsne [IN] RSNE IE offset in the frame\n * @param offset_fte [IN] Fast BSS Transition IE offset in the frame\n * @param offset_timeout [IN] Timeout Interval IE offset in the frame\n * @param offset_link [IN] Link Identifier IE offset in the frame\n * @param action [IN] Tdls Action code (response or confirm)\n *\n * @return\n *  AIRPDCAP_RET_SUCCESS if Key has been sucessfully derived (and MIC verified)\n *  AIRPDCAP_RET_UNSUCCESS otherwise\n */\nstatic INT\nAirPDcapTDLSDeriveKey(\n    PAIRPDCAP_SEC_ASSOCIATION sa,\n    const guint8 *data,\n    guint offset_rsne,\n    guint offset_fte,\n    guint offset_timeout,\n    guint offset_link,\n    guint8 action)\n    ;\n#ifdef  __cplusplus\n}\n#endif\n\n/****************************************************************************/\n\n/****************************************************************************/\n/* Exported function definitions                                                */\n\n#ifdef  __cplusplus\nextern \"C\" {\n#endif\n\nconst guint8 broadcast_mac[] = { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF };\n\n#define EAPKEY_MIC_LEN  16  /* length of the MIC key for EAPoL_Key packet's MIC using MD5 */\n#define NONCE_LEN 32\n\n#define TKIP_GROUP_KEY_LEN 32\n#define CCMP_GROUP_KEY_LEN 16\n\ntypedef struct {\n    guint8  type;\n    guint8  key_information[2];  /* Make this an array to avoid alignment issues */\n    guint8  key_length[2];  /* Make this an array to avoid alignment issues */\n    guint8  replay_counter[8];\n    guint8  key_nonce[NONCE_LEN];\n    guint8  key_iv[16];\n    guint8  key_sequence_counter[8];  /* also called the RSC */\n    guint8  key_id[8];\n    guint8  key_mic[EAPKEY_MIC_LEN];\n    guint8  key_data_len[2];  /* Make this an array rather than a U16 to avoid alignment shifting */\n} EAPOL_RSN_KEY,  * P_EAPOL_RSN_KEY;\n\n/* Minimum possible key data size (at least one GTK KDE with CCMP key) */\n#define GROUP_KEY_MIN_LEN 8 + CCMP_GROUP_KEY_LEN\n/* Minimum possible group key msg size (group key msg using CCMP as cipher)*/\n#define GROUP_KEY_PAYLOAD_LEN_MIN sizeof(EAPOL_RSN_KEY) + GROUP_KEY_MIN_LEN\n\n/* XXX - what if this doesn't get the key? */\nstatic INT\nAirPDcapDecryptWPABroadcastKey(const EAPOL_RSN_KEY *pEAPKey, guint8 *decryption_key, PAIRPDCAP_SEC_ASSOCIATION sa, guint eapol_len)\n{\n    guint8 key_version;\n    guint8 *key_data;\n    guint8  *szEncryptedKey;\n    guint16 key_bytes_len = 0; /* Length of the total key data field */\n    guint16 key_len;           /* Actual group key length */\n    static AIRPDCAP_KEY_ITEM dummy_key; /* needed in case AirPDcapRsnaMng() wants the key structure */\n    AIRPDCAP_SEC_ASSOCIATION *tmp_sa;\n\n    /* We skip verifying the MIC of the key. If we were implementing a WPA supplicant we'd want to verify, but for a sniffer it's not needed. */\n\n    /* Preparation for decrypting the group key -  determine group key data length */\n    /* depending on whether the pairwise key is TKIP or AES encryption key */\n    key_version = AIRPDCAP_EAP_KEY_DESCR_VER(pEAPKey->key_information[1]);\n    if (key_version == AIRPDCAP_WPA_KEY_VER_NOT_CCMP){\n        /* TKIP */\n        key_bytes_len = pntoh16(pEAPKey->key_length);\n    }else if (key_version == AIRPDCAP_WPA_KEY_VER_AES_CCMP){\n        /* AES */\n        key_bytes_len = pntoh16(pEAPKey->key_data_len);\n\n        /* AES keys must be at least 128 bits = 16 bytes. */\n        if (key_bytes_len < 16) {\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n        }\n    }\n\n    if ((key_bytes_len < GROUP_KEY_MIN_LEN) ||\n        (eapol_len < sizeof(EAPOL_RSN_KEY)) ||\n        (key_bytes_len > eapol_len - sizeof(EAPOL_RSN_KEY))) {\n        return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n    }\n\n    /* Encrypted key is in the information element field of the EAPOL key packet */\n    key_data = (guint8 *)pEAPKey + sizeof(EAPOL_RSN_KEY);\n    szEncryptedKey = (guint8 *)g_memdup(key_data, key_bytes_len);\n\n    DEBUG_DUMP(\"Encrypted Broadcast key:\", szEncryptedKey, key_bytes_len);\n    DEBUG_DUMP(\"KeyIV:\", pEAPKey->key_iv, 16);\n    DEBUG_DUMP(\"decryption_key:\", decryption_key, 16);\n\n    /* We are rekeying, save old sa */\n    tmp_sa=(AIRPDCAP_SEC_ASSOCIATION *)g_malloc(sizeof(AIRPDCAP_SEC_ASSOCIATION));\n    memcpy(tmp_sa, sa, sizeof(AIRPDCAP_SEC_ASSOCIATION));\n    sa->next=tmp_sa;\n\n    /* As we have no concept of the prior association request at this point, we need to deduce the     */\n    /* group key cipher from the length of the key bytes. In WPA this is straightforward as the        */\n    /* keybytes just contain the GTK, and the GTK is only in the group handshake, NOT the M3.          */\n    /* In WPA2 its a little more tricky as the M3 keybytes contain an RSN_IE, but the group handshake  */\n    /* does not. Also there are other (variable length) items in the keybytes which we need to account */\n    /* for to determine the true key length, and thus the group cipher.                                */\n\n    if (key_version == AIRPDCAP_WPA_KEY_VER_NOT_CCMP){\n        guint8 new_key[32];\n        guint8 dummy[256];\n        /* TKIP key */\n        /* Per 802.11i, Draft 3.0 spec, section 8.5.2, p. 97, line 4-8, */\n        /* group key is decrypted using RC4.  Concatenate the IV with the 16 byte EK (PTK+16) to get the decryption key */\n\n        rc4_state_struct rc4_state;\n\n        /* The WPA group key just contains the GTK bytes so deducing the type is straightforward   */\n        /* Note - WPA M3 doesn't contain a group key so we'll only be here for the group handshake */\n        sa->wpa.key_ver = (key_bytes_len >=TKIP_GROUP_KEY_LEN)?AIRPDCAP_WPA_KEY_VER_NOT_CCMP:AIRPDCAP_WPA_KEY_VER_AES_CCMP;\n\n        /* Build the full decryption key based on the IV and part of the pairwise key */\n        memcpy(new_key, pEAPKey->key_iv, 16);\n        memcpy(new_key+16, decryption_key, 16);\n        DEBUG_DUMP(\"FullDecrKey:\", new_key, 32);\n\n        crypt_rc4_init(&rc4_state, new_key, sizeof(new_key));\n\n        /* Do dummy 256 iterations of the RC4 algorithm (per 802.11i, Draft 3.0, p. 97 line 6) */\n        crypt_rc4(&rc4_state, dummy, 256);\n        crypt_rc4(&rc4_state, szEncryptedKey, key_bytes_len);\n\n    } else if (key_version == AIRPDCAP_WPA_KEY_VER_AES_CCMP){\n        /* AES CCMP key */\n\n        guint8 key_found;\n        guint8 key_length;\n        guint16 key_index;\n        guint8 *decrypted_data;\n\n        /* Unwrap the key; the result is key_bytes_len in length */\n        decrypted_data = AES_unwrap(decryption_key, 16, szEncryptedKey,  key_bytes_len);\n\n        /* With WPA2 what we get after Broadcast Key decryption is an actual RSN structure.\n           The key itself is stored as a GTK KDE\n           WPA2 IE (1 byte) id = 0xdd, length (1 byte), GTK OUI (4 bytes), key index (1 byte) and 1 reserved byte. Thus we have to\n           pass pointer to the actual key with 8 bytes offset */\n\n        key_found = FALSE;\n        key_index = 0;\n\n        /* Parse Key data until we found GTK KDE */\n        /* GTK KDE = 00-0F-AC 01 */\n        while(key_index < (key_bytes_len - 6) && !key_found){\n            guint8 rsn_id;\n            guint32 type;\n\n            /* Get RSN ID */\n            rsn_id = decrypted_data[key_index];\n            type = ((decrypted_data[key_index + 2] << 24) +\n                    (decrypted_data[key_index + 3] << 16) +\n                    (decrypted_data[key_index + 4] << 8) +\n                     (decrypted_data[key_index + 5]));\n\n            if (rsn_id == 0xdd && type == 0x000fac01) {\n                key_found = TRUE;\n            } else {\n                key_index += decrypted_data[key_index+1]+2;\n            }\n        }\n\n        if (key_found){\n            key_length = decrypted_data[key_index+1] - 6;\n\n            if (key_index+8 >= key_bytes_len ||\n                key_length > key_bytes_len - key_index - 8) {\n                g_free(decrypted_data);\n                g_free(szEncryptedKey);\n                return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n            }\n\n            /* Skip over the GTK header info, and don't copy past the end of the encrypted data */\n            memcpy(szEncryptedKey, decrypted_data+key_index+8, key_length);\n        } else {\n            g_free(decrypted_data);\n            g_free(szEncryptedKey);\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n        }\n\n        if (key_length == TKIP_GROUP_KEY_LEN)\n            sa->wpa.key_ver = AIRPDCAP_WPA_KEY_VER_NOT_CCMP;\n        else\n            sa->wpa.key_ver = AIRPDCAP_WPA_KEY_VER_AES_CCMP;\n\n        g_free(decrypted_data);\n    }\n\n    key_len = (sa->wpa.key_ver==AIRPDCAP_WPA_KEY_VER_NOT_CCMP)?TKIP_GROUP_KEY_LEN:CCMP_GROUP_KEY_LEN;\n    if (key_len > key_bytes_len) {\n        /* the key required for this protocol is longer than the key that we just calculated */\n        g_free(szEncryptedKey);\n        return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n    }\n\n    /* Decrypted key is now in szEncryptedKey with len of key_len */\n    DEBUG_DUMP(\"Broadcast key:\", szEncryptedKey, key_len);\n\n    /* Load the proper key material info into the SA */\n    sa->key = &dummy_key;  /* we just need key to be not null because it is checked in AirPDcapRsnaMng().  The WPA key materials are actually in the .wpa structure */\n    sa->validKey = TRUE;\n\n    /* Since this is a GTK and its size is only 32 bytes (vs. the 64 byte size of a PTK), we fake it and put it in at a 32-byte offset so the  */\n    /* AirPDcapRsnaMng() function will extract the right piece of the GTK for decryption. (The first 16 bytes of the GTK are used for decryption.) */\n    memset(sa->wpa.ptk, 0, sizeof(sa->wpa.ptk));\n    memcpy(sa->wpa.ptk+32, szEncryptedKey, key_len);\n    g_free(szEncryptedKey);\n    return AIRPDCAP_RET_SUCCESS_HANDSHAKE;\n}\n\n\n/* Return a pointer the the requested SA. If it doesn't exist create it. */\nstatic PAIRPDCAP_SEC_ASSOCIATION\nAirPDcapGetSaPtr(\n    PAIRPDCAP_CONTEXT ctx,\n    AIRPDCAP_SEC_ASSOCIATION_ID *id)\n{\n    int sa_index;\n\n    /* search for a cached Security Association for supplied BSSID and STA MAC  */\n    if ((sa_index=AirPDcapGetSa(ctx, id))==-1) {\n        /* create a new Security Association if it doesn't currently exist      */\n        if ((sa_index=AirPDcapStoreSa(ctx, id))==-1) {\n            return NULL;\n        }\n    }\n    /* get the Security Association structure   */\n    return &ctx->sa[sa_index];\n}\n\nstatic INT AirPDcapScanForKeys(\n    PAIRPDCAP_CONTEXT ctx,\n    const guint8 *data,\n    const guint mac_header_len,\n    const guint tot_len,\n    AIRPDCAP_SEC_ASSOCIATION_ID id\n)\n{\n    const UCHAR *addr;\n    guint bodyLength;\n    PAIRPDCAP_SEC_ASSOCIATION sta_sa;\n    PAIRPDCAP_SEC_ASSOCIATION sa;\n    guint offset = 0;\n    const guint8 dot1x_header[] = {\n        0xAA,             /* DSAP=SNAP */\n        0xAA,             /* SSAP=SNAP */\n        0x03,             /* Control field=Unnumbered frame */\n        0x00, 0x00, 0x00, /* Org. code=encaps. Ethernet */\n        0x88, 0x8E        /* Type: 802.1X authentication */\n    };\n    const guint8 bt_dot1x_header[] = {\n        0xAA,             /* DSAP=SNAP */\n        0xAA,             /* SSAP=SNAP */\n        0x03,             /* Control field=Unnumbered frame */\n        0x00, 0x19, 0x58, /* Org. code=Bluetooth SIG */\n        0x00, 0x03        /* Type: Bluetooth Security */\n    };\n    const guint8 tdls_header[] = {\n        0xAA,             /* DSAP=SNAP */\n        0xAA,             /* SSAP=SNAP */\n        0x03,             /* Control field=Unnumbered frame */\n        0x00, 0x00, 0x00, /* Org. code=encaps. Ethernet */\n        0x89, 0x0D,       /* Type: 802.11 - Fast Roaming Remote Request */\n        0x02,             /* Payload Type: TDLS */\n        0X0C              /* Action Category: TDLS */\n    };\n\n    const EAPOL_RSN_KEY *pEAPKey;\n#ifdef _DEBUG\n#define MSGBUF_LEN 255\n    CHAR msgbuf[MSGBUF_LEN];\n#endif\n    AIRPDCAP_DEBUG_TRACE_START(\"AirPDcapScanForKeys\");\n\n    /* cache offset in the packet data */\n    offset = mac_header_len;\n\n    /* check if the packet has an LLC header and the packet is 802.1X authentication (IEEE 802.1X-2004, pg. 24) */\n    if (memcmp(data+offset, dot1x_header, 8) == 0 || memcmp(data+offset, bt_dot1x_header, 8) == 0) {\n\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Authentication: EAPOL packet\", AIRPDCAP_DEBUG_LEVEL_3);\n\n        /* skip LLC header */\n        offset+=8;\n\n        /* check if the packet is a EAPOL-Key (0x03) (IEEE 802.1X-2004, pg. 25) */\n        if (data[offset+1]!=3) {\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Not EAPOL-Key\", AIRPDCAP_DEBUG_LEVEL_3);\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n        }\n\n        /* get and check the body length (IEEE 802.1X-2004, pg. 25) */\n        bodyLength=pntoh16(data+offset+2);\n        if (((tot_len-offset-4) < bodyLength) || (bodyLength < sizeof(EAPOL_RSN_KEY))) { /* Only check if frame is long enough for eapol header, ignore tailing garbage, see bug 9065 */\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"EAPOL body too short\", AIRPDCAP_DEBUG_LEVEL_3);\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n        }\n\n        /* skip EAPOL MPDU and go to the first byte of the body */\n        offset+=4;\n\n        pEAPKey = (const EAPOL_RSN_KEY *) (data+offset);\n\n        /* check if the key descriptor type is valid (IEEE 802.1X-2004, pg. 27) */\n        if (/*pEAPKey->type!=0x1 &&*/ /* RC4 Key Descriptor Type (deprecated) */\n            pEAPKey->type != AIRPDCAP_RSN_WPA2_KEY_DESCRIPTOR &&             /* IEEE 802.11 Key Descriptor Type  (WPA2) */\n            pEAPKey->type != AIRPDCAP_RSN_WPA_KEY_DESCRIPTOR)           /* 254 = RSN_KEY_DESCRIPTOR - WPA,              */\n        {\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Not valid key descriptor type\", AIRPDCAP_DEBUG_LEVEL_3);\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n        }\n\n        /* start with descriptor body */\n        offset+=1;\n\n        /* search for a cached Security Association for current BSSID and AP */\n        sa = AirPDcapGetSaPtr(ctx, &id);\n        if (sa == NULL){\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"No SA for BSSID found\", AIRPDCAP_DEBUG_LEVEL_3);\n            return AIRPDCAP_RET_REQ_DATA;\n        }\n\n        /* It could be a Pairwise Key exchange, check */\n        if (AirPDcapRsna4WHandshake(ctx, data, sa, offset, tot_len) == AIRPDCAP_RET_SUCCESS_HANDSHAKE)\n            return AIRPDCAP_RET_SUCCESS_HANDSHAKE;\n\n        if (mac_header_len + GROUP_KEY_PAYLOAD_LEN_MIN > tot_len) {\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Message too short for Group Key\", AIRPDCAP_DEBUG_LEVEL_3);\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n        }\n\n        /* Verify the bitfields: Key = 0(groupwise) Mic = 1 Ack = 1 Secure = 1 */\n        if (AIRPDCAP_EAP_KEY(data[offset+1])!=0 ||\n            AIRPDCAP_EAP_ACK(data[offset+1])!=1 ||\n            AIRPDCAP_EAP_MIC(data[offset]) != 1 ||\n            AIRPDCAP_EAP_SEC(data[offset]) != 1){\n\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Key bitfields not correct for Group Key\", AIRPDCAP_DEBUG_LEVEL_3);\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n        }\n\n        /* force STA address to be the broadcast MAC so we create an SA for the groupkey */\n        memcpy(id.sta, broadcast_mac, AIRPDCAP_MAC_LEN);\n\n        /* get the Security Association structure for the broadcast MAC and AP */\n        sa = AirPDcapGetSaPtr(ctx, &id);\n        if (sa == NULL){\n            return AIRPDCAP_RET_REQ_DATA;\n        }\n\n        /* Get the SA for the STA, since we need its pairwise key to decrpyt the group key */\n\n        /* get STA address */\n        if ( (addr=AirPDcapGetStaAddress((const AIRPDCAP_MAC_FRAME_ADDR4 *)(data))) != NULL) {\n            memcpy(id.sta, addr, AIRPDCAP_MAC_LEN);\n#ifdef _DEBUG\n            g_snprintf(msgbuf, MSGBUF_LEN, \"ST_MAC: %2X.%2X.%2X.%2X.%2X.%2X\\t\", id.sta[0],id.sta[1],id.sta[2],id.sta[3],id.sta[4],id.sta[5]);\n#endif\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", msgbuf, AIRPDCAP_DEBUG_LEVEL_3);\n        } else {\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"SA not found\", AIRPDCAP_DEBUG_LEVEL_5);\n            return AIRPDCAP_RET_REQ_DATA;\n        }\n\n        sta_sa = AirPDcapGetSaPtr(ctx, &id);\n        if (sta_sa == NULL){\n            return AIRPDCAP_RET_REQ_DATA;\n        }\n\n        /* Try to extract the group key and install it in the SA */\n        return (AirPDcapDecryptWPABroadcastKey(pEAPKey, sta_sa->wpa.ptk+16, sa, tot_len-offset+1));\n\n    } else if (memcmp(data+offset, tdls_header, 10) == 0) {\n        const guint8 *initiator, *responder;\n        guint8 action;\n        guint status, offset_rsne = 0, offset_fte = 0, offset_link = 0, offset_timeout = 0;\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Authentication: TDLS Action Frame\", AIRPDCAP_DEBUG_LEVEL_3);\n\n        /* skip LLC header */\n        offset+=10;\n\n        /* check if the packet is a TDLS response or confirm */\n        action = data[offset];\n        if (action!=1 && action!=2) {\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Not Response nor confirm\", AIRPDCAP_DEBUG_LEVEL_3);\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n        }\n\n        /* check status */\n        offset++;\n        status=pntoh16(data+offset);\n        if (status!=0) {\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"TDLS setup not successfull\", AIRPDCAP_DEBUG_LEVEL_3);\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n        }\n\n        /* skip Token + capabilities */\n        offset+=5;\n\n        /* search for RSN, Fast BSS Transition, Link Identifier and Timeout Interval IEs */\n\n        while(offset < (tot_len - 2)) {\n            if (data[offset] == 48) {\n                offset_rsne = offset;\n            } else if (data[offset] == 55) {\n                offset_fte = offset;\n            } else if (data[offset] == 56) {\n                offset_timeout = offset;\n            } else if (data[offset] == 101) {\n                offset_link = offset;\n            }\n\n            if (tot_len < offset + data[offset + 1] + 2) {\n                return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n            }\n            offset += data[offset + 1] + 2;\n        }\n\n        if (offset_rsne == 0 || offset_fte == 0 ||\n            offset_timeout == 0 || offset_link == 0)\n        {\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Cannot Find all necessary IEs\", AIRPDCAP_DEBUG_LEVEL_3);\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n        }\n\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Found RSNE/Fast BSS/Timeout Interval/Link IEs\", AIRPDCAP_DEBUG_LEVEL_3);\n\n        /* Will create a Security Association between 2 STA. Need to get both MAC address */\n        initiator = &data[offset_link + 8];\n        responder = &data[offset_link + 14];\n\n        if (memcmp(initiator, responder, AIRPDCAP_MAC_LEN) < 0) {\n            memcpy(id.sta, initiator, AIRPDCAP_MAC_LEN);\n            memcpy(id.bssid, responder, AIRPDCAP_MAC_LEN);\n        } else {\n            memcpy(id.sta, responder, AIRPDCAP_MAC_LEN);\n            memcpy(id.bssid, initiator, AIRPDCAP_MAC_LEN);\n        }\n\n        sa = AirPDcapGetSaPtr(ctx, &id);\n        if (sa == NULL){\n            return AIRPDCAP_RET_REQ_DATA;\n        }\n\n        if (sa->validKey) {\n            if (memcmp(sa->wpa.nonce, data + offset_fte + 52, AIRPDCAP_WPA_NONCE_LEN) == 0) {\n                /* Already have valid key for this SA, no need to redo key derivation */\n                return AIRPDCAP_RET_SUCCESS_HANDSHAKE;\n            } else {\n                /* We are opening a new session with the same two STA, save previous sa  */\n                AIRPDCAP_SEC_ASSOCIATION *tmp_sa = g_new(AIRPDCAP_SEC_ASSOCIATION, 1);\n                memcpy(tmp_sa, sa, sizeof(AIRPDCAP_SEC_ASSOCIATION));\n                sa->next=tmp_sa;\n                sa->validKey = FALSE;\n            }\n        }\n\n        if (AirPDcapTDLSDeriveKey(sa, data, offset_rsne, offset_fte, offset_timeout, offset_link, action)\n            == AIRPDCAP_RET_SUCCESS) {\n            AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapScanForKeys\");\n            return AIRPDCAP_RET_SUCCESS_HANDSHAKE;\n        }\n    } else {\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Skipping: not an EAPOL packet\", AIRPDCAP_DEBUG_LEVEL_3);\n    }\n\n    AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapScanForKeys\");\n    return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n}\n\n\nINT AirPDcapPacketProcess(\n    PAIRPDCAP_CONTEXT ctx,\n    const guint8 *data,\n    const guint mac_header_len,\n    const guint tot_len,\n    UCHAR *decrypt_data,\n    guint *decrypt_len,\n    PAIRPDCAP_KEY_ITEM key,\n    gboolean scanHandshake)\n{\n    AIRPDCAP_SEC_ASSOCIATION_ID id;\n    UCHAR tmp_data[AIRPDCAP_MAX_CAPLEN];\n    guint tmp_len;\n\n#ifdef _DEBUG\n#define MSGBUF_LEN 255\n    CHAR msgbuf[MSGBUF_LEN];\n#endif\n\n    AIRPDCAP_DEBUG_TRACE_START(\"AirPDcapPacketProcess\");\n\n    if (ctx==NULL) {\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapPacketProcess\", \"NULL context\", AIRPDCAP_DEBUG_LEVEL_5);\n        AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapPacketProcess\");\n        return AIRPDCAP_RET_REQ_DATA;\n    }\n    if (data==NULL || tot_len==0) {\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapPacketProcess\", \"NULL data or length=0\", AIRPDCAP_DEBUG_LEVEL_5);\n        AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapPacketProcess\");\n        return AIRPDCAP_RET_REQ_DATA;\n    }\n\n    /* check if the packet is of data or robust managment type */\n    if (!((AIRPDCAP_TYPE(data[0])==AIRPDCAP_TYPE_DATA) ||\n          (AIRPDCAP_TYPE(data[0])==AIRPDCAP_TYPE_MANAGEMENT &&\n           (AIRPDCAP_SUBTYPE(data[0])==AIRPDCAP_SUBTYPE_DISASS ||\n            AIRPDCAP_SUBTYPE(data[0])==AIRPDCAP_SUBTYPE_DEAUTHENTICATION ||\n            AIRPDCAP_SUBTYPE(data[0])==AIRPDCAP_SUBTYPE_ACTION)))) {\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapPacketProcess\", \"not data nor robust mgmt packet\", AIRPDCAP_DEBUG_LEVEL_5);\n        return AIRPDCAP_RET_NO_DATA;\n    }\n\n    /* check correct packet size, to avoid wrong elaboration of encryption algorithms */\n    if (tot_len < (UINT)(mac_header_len+AIRPDCAP_CRYPTED_DATA_MINLEN)) {\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapPacketProcess\", \"minimum length violated\", AIRPDCAP_DEBUG_LEVEL_5);\n        return AIRPDCAP_RET_WRONG_DATA_SIZE;\n    }\n\n    /* Assume that the decrypt_data field is at least this size. */\n    if (tot_len > AIRPDCAP_MAX_CAPLEN) {\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapPacketProcess\", \"length too large\", AIRPDCAP_DEBUG_LEVEL_3);\n        return AIRPDCAP_RET_UNSUCCESS;\n    }\n\n    /* get STA/BSSID address */\n    if (AirPDcapGetSaAddress((const AIRPDCAP_MAC_FRAME_ADDR4 *)(data), &id) != AIRPDCAP_RET_SUCCESS) {\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapPacketProcess\", \"STA/BSSID not found\", AIRPDCAP_DEBUG_LEVEL_5);\n        return AIRPDCAP_RET_REQ_DATA;\n    }\n\n    /* check if data is encrypted (use the WEP bit in the Frame Control field) */\n    if (AIRPDCAP_WEP(data[1])==0) {\n        if (scanHandshake) {\n            /* data is sent in cleartext, check if is an authentication message or end the process */\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapPacketProcess\", \"Unencrypted data\", AIRPDCAP_DEBUG_LEVEL_3);\n            return (AirPDcapScanForKeys(ctx, data, mac_header_len, tot_len, id));\n        }\n        return AIRPDCAP_RET_NO_DATA_ENCRYPTED;\n    } else {\n        PAIRPDCAP_SEC_ASSOCIATION sa;\n        int offset = 0;\n\n        /* get the Security Association structure for the STA and AP */\n        sa = AirPDcapGetSaPtr(ctx, &id);\n        if (sa == NULL){\n            return AIRPDCAP_RET_REQ_DATA;\n        }\n\n        /* cache offset in the packet data (to scan encryption data) */\n        offset = mac_header_len;\n\n        if (decrypt_data==NULL) {\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapPacketProcess\", \"no decrypt buffer, use local\", AIRPDCAP_DEBUG_LEVEL_3);\n            decrypt_data=tmp_data;\n            decrypt_len=&tmp_len;\n        }\n\n        /* create new header and data to modify */\n        *decrypt_len = tot_len;\n        memcpy(decrypt_data, data, *decrypt_len);\n\n        /* encrypted data */\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapPacketProcess\", \"Encrypted data\", AIRPDCAP_DEBUG_LEVEL_3);\n\n        /* check the Extension IV to distinguish between WEP encryption and WPA encryption */\n        /* refer to IEEE 802.11i-2004, 8.2.1.2, pag.35 for WEP,    */\n        /*          IEEE 802.11i-2004, 8.3.2.2, pag. 45 for TKIP,  */\n        /*          IEEE 802.11i-2004, 8.3.3.2, pag. 57 for CCMP   */\n        if (AIRPDCAP_EXTIV(data[offset+3])==0) {\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapPacketProcess\", \"WEP encryption\", AIRPDCAP_DEBUG_LEVEL_3);\n            return AirPDcapWepMng(ctx, decrypt_data, mac_header_len, decrypt_len, key, sa, offset);\n        } else {\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapPacketProcess\", \"TKIP or CCMP encryption\", AIRPDCAP_DEBUG_LEVEL_3);\n\n            /* If index >= 1, then use the group key.  This will not work if the AP is using\n               more than one group key simultaneously.  I've not seen this in practice, however.\n               Usually an AP will rotate between the two key index values of 1 and 2 whenever\n               it needs to change the group key to be used. */\n            if (AIRPDCAP_KEY_INDEX(data[offset+3])>=1){\n\n                AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapPacketProcess\", \"The key index >= 1. This is encrypted with a group key.\", AIRPDCAP_DEBUG_LEVEL_3);\n\n                /* force STA address to broadcast MAC so we load the SA for the groupkey */\n                memcpy(id.sta, broadcast_mac, AIRPDCAP_MAC_LEN);\n\n#ifdef _DEBUG\n                g_snprintf(msgbuf, MSGBUF_LEN, \"ST_MAC: %2X.%2X.%2X.%2X.%2X.%2X\\t\", id.sta[0],id.sta[1],id.sta[2],id.sta[3],id.sta[4],id.sta[5]);\n                AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapPacketProcess\", msgbuf, AIRPDCAP_DEBUG_LEVEL_3);\n#endif\n\n                /* search for a cached Security Association for current BSSID and broadcast MAC */\n                sa = AirPDcapGetSaPtr(ctx, &id);\n                if (sa == NULL)\n                    return AIRPDCAP_RET_REQ_DATA;\n            }\n\n            /* Decrypt the packet using the appropriate SA */\n            if (AirPDcapRsnaMng(decrypt_data, mac_header_len, decrypt_len, key, sa, offset) == AIRPDCAP_RET_SUCCESS) {\n                /* If we successfully decrypted a packet, scan it to see if it contains a key handshake.\n                   The group key handshake could be sent at any time the AP wants to change the key (such as when\n                   it is using key rotation) and it also could be a rekey for the Pairwise key. So we must scan every packet. */\n                if (scanHandshake) {\n                    return (AirPDcapScanForKeys(ctx, decrypt_data, mac_header_len, *decrypt_len, id));\n                } else {\n                    return AIRPDCAP_RET_SUCCESS;\n                }\n            }\n        }\n    }\n    return AIRPDCAP_RET_UNSUCCESS;\n}\n\nINT AirPDcapSetKeys(\n    PAIRPDCAP_CONTEXT ctx,\n    AIRPDCAP_KEY_ITEM keys[],\n    const size_t keys_nr)\n{\n    INT i;\n    INT success;\n    AIRPDCAP_DEBUG_TRACE_START(\"AirPDcapSetKeys\");\n\n    if (ctx==NULL || keys==NULL) {\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapSetKeys\", \"NULL context or NULL keys array\", AIRPDCAP_DEBUG_LEVEL_3);\n        AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapSetKeys\");\n        return 0;\n    }\n\n    if (keys_nr>AIRPDCAP_MAX_KEYS_NR) {\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapSetKeys\", \"Keys number greater than maximum\", AIRPDCAP_DEBUG_LEVEL_3);\n        AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapSetKeys\");\n        return 0;\n    }\n\n    /* clean key and SA collections before setting new ones */\n    AirPDcapInitContext(ctx);\n\n    /* check and insert keys */\n    for (i=0, success=0; i<(INT)keys_nr; i++) {\n        if (AirPDcapValidateKey(keys+i)==TRUE) {\n            if (keys[i].KeyType==AIRPDCAP_KEY_TYPE_WPA_PWD) {\n                AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapSetKeys\", \"Set a WPA-PWD key\", AIRPDCAP_DEBUG_LEVEL_4);\n                AirPDcapRsnaPwd2Psk(keys[i].UserPwd.Passphrase, keys[i].UserPwd.Ssid, keys[i].UserPwd.SsidLen, keys[i].KeyData.Wpa.Psk);\n            }\n#ifdef _DEBUG\n            else if (keys[i].KeyType==AIRPDCAP_KEY_TYPE_WPA_PMK) {\n                AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapSetKeys\", \"Set a WPA-PMK key\", AIRPDCAP_DEBUG_LEVEL_4);\n            } else if (keys[i].KeyType==AIRPDCAP_KEY_TYPE_WEP) {\n                AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapSetKeys\", \"Set a WEP key\", AIRPDCAP_DEBUG_LEVEL_4);\n            } else {\n                AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapSetKeys\", \"Set a key\", AIRPDCAP_DEBUG_LEVEL_4);\n            }\n#endif\n            memcpy(&ctx->keys[success], &keys[i], sizeof(keys[i]));\n            success++;\n        }\n    }\n\n    ctx->keys_nr=success;\n\n    AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapSetKeys\");\n    return success;\n}\n\nstatic void\nAirPDcapCleanKeys(\n    PAIRPDCAP_CONTEXT ctx)\n{\n    AIRPDCAP_DEBUG_TRACE_START(\"AirPDcapCleanKeys\");\n\n    if (ctx==NULL) {\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapCleanKeys\", \"NULL context\", AIRPDCAP_DEBUG_LEVEL_5);\n        AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapCleanKeys\");\n        return;\n    }\n\n    memset(ctx->keys, 0, sizeof(AIRPDCAP_KEY_ITEM) * AIRPDCAP_MAX_KEYS_NR);\n\n    ctx->keys_nr=0;\n\n    AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapCleanKeys\", \"Keys collection cleaned!\", AIRPDCAP_DEBUG_LEVEL_5);\n    AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapCleanKeys\");\n}\n\nstatic void\nAirPDcapRecurseCleanSA(\n    PAIRPDCAP_SEC_ASSOCIATION sa)\n{\n    if (sa->next != NULL) {\n        AirPDcapRecurseCleanSA(sa->next);\n        g_free(sa->next);\n        sa->next = NULL;\n    }\n}\n\nstatic void\nAirPDcapCleanSecAssoc(\n    PAIRPDCAP_CONTEXT ctx)\n{\n    PAIRPDCAP_SEC_ASSOCIATION psa;\n    int i;\n\n    for (psa = ctx->sa, i = 0; i < AIRPDCAP_MAX_SEC_ASSOCIATIONS_NR; i++, psa++) {\n        /* To iterate is human, to recurse, divine */\n        AirPDcapRecurseCleanSA(psa);\n    }\n}\n\nINT AirPDcapGetKeys(\n    const PAIRPDCAP_CONTEXT ctx,\n    AIRPDCAP_KEY_ITEM keys[],\n    const size_t keys_nr)\n{\n    UINT i;\n    UINT j;\n    AIRPDCAP_DEBUG_TRACE_START(\"AirPDcapGetKeys\");\n\n    if (ctx==NULL) {\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapGetKeys\", \"NULL context\", AIRPDCAP_DEBUG_LEVEL_5);\n        AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapGetKeys\");\n        return 0;\n    } else if (keys==NULL) {\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapGetKeys\", \"NULL keys array\", AIRPDCAP_DEBUG_LEVEL_5);\n        AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapGetKeys\");\n        return (INT)ctx->keys_nr;\n    } else {\n        for (i=0, j=0; i<ctx->keys_nr && i<keys_nr && i<AIRPDCAP_MAX_KEYS_NR; i++) {\n            memcpy(&keys[j], &ctx->keys[i], sizeof(keys[j]));\n            j++;\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapGetKeys\", \"Got a key\", AIRPDCAP_DEBUG_LEVEL_5);\n        }\n\n        AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapGetKeys\");\n        return j;\n    }\n}\n\n/*\n * XXX - This won't be reliable if a packet containing SSID \"B\" shows\n * up in the middle of a 4-way handshake for SSID \"A\".\n * We should probably use a small array or hash table to keep multiple\n * SSIDs.\n */\nINT AirPDcapSetLastSSID(\n    PAIRPDCAP_CONTEXT ctx,\n    CHAR *pkt_ssid,\n    size_t pkt_ssid_len)\n{\n    if (!ctx || !pkt_ssid || pkt_ssid_len < 1 || pkt_ssid_len > WPA_SSID_MAX_SIZE)\n        return AIRPDCAP_RET_UNSUCCESS;\n\n    memcpy(ctx->pkt_ssid, pkt_ssid, pkt_ssid_len);\n    ctx->pkt_ssid_len = pkt_ssid_len;\n\n    return AIRPDCAP_RET_SUCCESS;\n}\n\nINT AirPDcapInitContext(\n    PAIRPDCAP_CONTEXT ctx)\n{\n    AIRPDCAP_DEBUG_TRACE_START(\"AirPDcapInitContext\");\n\n    if (ctx==NULL) {\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapInitContext\", \"NULL context\", AIRPDCAP_DEBUG_LEVEL_5);\n        AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapInitContext\");\n        return AIRPDCAP_RET_UNSUCCESS;\n    }\n\n    AirPDcapCleanKeys(ctx);\n\n    ctx->first_free_index=0;\n    ctx->index=-1;\n    ctx->sa_index=-1;\n    ctx->pkt_ssid_len = 0;\n\n    memset(ctx->sa, 0, AIRPDCAP_MAX_SEC_ASSOCIATIONS_NR * sizeof(AIRPDCAP_SEC_ASSOCIATION));\n\n    AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapInitContext\", \"Context initialized!\", AIRPDCAP_DEBUG_LEVEL_5);\n    AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapInitContext\");\n    return AIRPDCAP_RET_SUCCESS;\n}\n\nINT AirPDcapDestroyContext(\n    PAIRPDCAP_CONTEXT ctx)\n{\n    AIRPDCAP_DEBUG_TRACE_START(\"AirPDcapDestroyContext\");\n\n    if (ctx==NULL) {\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapDestroyContext\", \"NULL context\", AIRPDCAP_DEBUG_LEVEL_5);\n        AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapDestroyContext\");\n        return AIRPDCAP_RET_UNSUCCESS;\n    }\n\n    AirPDcapCleanKeys(ctx);\n    AirPDcapCleanSecAssoc(ctx);\n\n    ctx->first_free_index=0;\n    ctx->index=-1;\n    ctx->sa_index=-1;\n\n    AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapDestroyContext\", \"Context destroyed!\", AIRPDCAP_DEBUG_LEVEL_5);\n    AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapDestroyContext\");\n    return AIRPDCAP_RET_SUCCESS;\n}\n\n#ifdef __cplusplus\n}\n#endif\n\n/****************************************************************************/\n\n/****************************************************************************/\n/* Internal function definitions                                         */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nstatic INT\nAirPDcapRsnaMng(\n    UCHAR *decrypt_data,\n    guint mac_header_len,\n    guint *decrypt_len,\n    PAIRPDCAP_KEY_ITEM key,\n    AIRPDCAP_SEC_ASSOCIATION *sa,\n    INT offset)\n{\n    INT ret_value=1;\n    UCHAR *try_data;\n    guint try_data_len = *decrypt_len;\n\n    if (*decrypt_len > try_data_len) {\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsnaMng\", \"Invalid decryption length\", AIRPDCAP_DEBUG_LEVEL_3);\n        return AIRPDCAP_RET_UNSUCCESS;\n    }\n\n    /* allocate a temp buffer for the decryption loop */\n    try_data=(UCHAR *)g_malloc(try_data_len);\n\n    /* start of loop added by GCS */\n    for(/* sa */; sa != NULL ;sa=sa->next) {\n\n       if (sa->validKey==FALSE) {\n           AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsnaMng\", \"Key not yet valid\", AIRPDCAP_DEBUG_LEVEL_3);\n           continue;\n       }\n\n       /* copy the encrypted data into a temp buffer */\n       memcpy(try_data, decrypt_data, *decrypt_len);\n\n       if (sa->wpa.key_ver==1) {\n           /* CCMP -> HMAC-MD5 is the EAPOL-Key MIC, RC4 is the EAPOL-Key encryption algorithm */\n           AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsnaMng\", \"TKIP\", AIRPDCAP_DEBUG_LEVEL_3);\n           DEBUG_DUMP(\"ptk\", sa->wpa.ptk, 64);\n           DEBUG_DUMP(\"ptk portion used\", AIRPDCAP_GET_TK(sa->wpa.ptk), 16);\n\n           ret_value=AirPDcapTkipDecrypt(try_data+offset, *decrypt_len-offset, try_data+AIRPDCAP_TA_OFFSET, AIRPDCAP_GET_TK(sa->wpa.ptk));\n           if (ret_value){\n               AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsnaMng\", \"TKIP failed!\", AIRPDCAP_DEBUG_LEVEL_3);\n               continue;\n           }\n\n           AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsnaMng\", \"TKIP DECRYPTED!!!\", AIRPDCAP_DEBUG_LEVEL_3);\n           /* remove MIC (8bytes) and ICV (4bytes) from the end of packet */\n           *decrypt_len-=12;\n           break;\n       } else {\n           /* AES-CCMP -> HMAC-SHA1-128 is the EAPOL-Key MIC, AES wep_key wrap is the EAPOL-Key encryption algorithm */\n           AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsnaMng\", \"CCMP\", AIRPDCAP_DEBUG_LEVEL_3);\n\n           ret_value=AirPDcapCcmpDecrypt(try_data, mac_header_len, (INT)*decrypt_len, AIRPDCAP_GET_TK(sa->wpa.ptk));\n           if (ret_value)\n              continue;\n\n           AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsnaMng\", \"CCMP DECRYPTED!!!\", AIRPDCAP_DEBUG_LEVEL_3);\n           /* remove MIC (8bytes) from the end of packet */\n           *decrypt_len-=8;\n           break;\n       }\n    }\n    /* end of loop */\n\n    /* none of the keys worked */\n    if(sa == NULL) {\n        g_free(try_data);\n        return ret_value;\n    }\n\n    if (*decrypt_len > try_data_len || *decrypt_len < 8) {\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsnaMng\", \"Invalid decryption length\", AIRPDCAP_DEBUG_LEVEL_3);\n        g_free(try_data);\n        return AIRPDCAP_RET_UNSUCCESS;\n    }\n\n    /* copy the decrypted data into the decrypt buffer GCS*/\n    memcpy(decrypt_data, try_data, *decrypt_len);\n    g_free(try_data);\n\n    /* remove protection bit */\n    decrypt_data[1]&=0xBF;\n\n    /* remove TKIP/CCMP header */\n    offset = mac_header_len;\n    *decrypt_len-=8;\n    memmove(decrypt_data+offset, decrypt_data+offset+8, *decrypt_len-offset);\n\n    if (key!=NULL) {\n        if (sa->key!=NULL)\n            memcpy(key, sa->key, sizeof(AIRPDCAP_KEY_ITEM));\n        else\n            memset(key, 0, sizeof(AIRPDCAP_KEY_ITEM));\n        memcpy(key->KeyData.Wpa.Ptk, sa->wpa.ptk, AIRPDCAP_WPA_PTK_LEN); /* copy the PTK to the key structure for future use by wireshark */\n        if (sa->wpa.key_ver==AIRPDCAP_WPA_KEY_VER_NOT_CCMP)\n            key->KeyType=AIRPDCAP_KEY_TYPE_TKIP;\n        else if (sa->wpa.key_ver==AIRPDCAP_WPA_KEY_VER_AES_CCMP)\n            key->KeyType=AIRPDCAP_KEY_TYPE_CCMP;\n    }\n\n    return AIRPDCAP_RET_SUCCESS;\n}\n\nstatic INT\nAirPDcapWepMng(\n    PAIRPDCAP_CONTEXT ctx,\n    UCHAR *decrypt_data,\n    guint mac_header_len,\n    guint *decrypt_len,\n    PAIRPDCAP_KEY_ITEM key,\n    AIRPDCAP_SEC_ASSOCIATION *sa,\n    INT offset)\n{\n    UCHAR wep_key[AIRPDCAP_WEP_KEY_MAXLEN+AIRPDCAP_WEP_IVLEN];\n    size_t keylen;\n    INT ret_value=1;\n    INT key_index;\n    AIRPDCAP_KEY_ITEM *tmp_key;\n    UINT8 useCache=FALSE;\n    UCHAR *try_data;\n    guint try_data_len = *decrypt_len;\n\n    try_data = (UCHAR *)g_malloc(try_data_len);\n\n    if (sa->key!=NULL)\n        useCache=TRUE;\n\n    for (key_index=0; key_index<(INT)ctx->keys_nr; key_index++) {\n        /* use the cached one, or try all keys */\n        if (!useCache) {\n            tmp_key=&ctx->keys[key_index];\n        } else {\n            if (sa->key!=NULL && sa->key->KeyType==AIRPDCAP_KEY_TYPE_WEP) {\n                AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapWepMng\", \"Try cached WEP key...\", AIRPDCAP_DEBUG_LEVEL_3);\n                tmp_key=sa->key;\n            } else {\n                AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapWepMng\", \"Cached key is not valid, try another WEP key...\", AIRPDCAP_DEBUG_LEVEL_3);\n                tmp_key=&ctx->keys[key_index];\n            }\n        }\n\n        /* obviously, try only WEP keys... */\n        if (tmp_key->KeyType==AIRPDCAP_KEY_TYPE_WEP) {\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapWepMng\", \"Try WEP key...\", AIRPDCAP_DEBUG_LEVEL_3);\n\n            memset(wep_key, 0, sizeof(wep_key));\n            memcpy(try_data, decrypt_data, *decrypt_len);\n\n            /* Costruct the WEP seed: copy the IV in first 3 bytes and then the WEP key (refer to 802-11i-2004, 8.2.1.4.3, pag. 36) */\n            memcpy(wep_key, try_data+mac_header_len, AIRPDCAP_WEP_IVLEN);\n            keylen=tmp_key->KeyData.Wep.WepKeyLen;\n            memcpy(wep_key+AIRPDCAP_WEP_IVLEN, tmp_key->KeyData.Wep.WepKey, keylen);\n\n            ret_value=AirPDcapWepDecrypt(wep_key,\n                keylen+AIRPDCAP_WEP_IVLEN,\n                try_data + (mac_header_len+AIRPDCAP_WEP_IVLEN+AIRPDCAP_WEP_KIDLEN),\n                *decrypt_len-(mac_header_len+AIRPDCAP_WEP_IVLEN+AIRPDCAP_WEP_KIDLEN+AIRPDCAP_CRC_LEN));\n\n            if (ret_value == AIRPDCAP_RET_SUCCESS)\n                memcpy(decrypt_data, try_data, *decrypt_len);\n        }\n\n        if (!ret_value && tmp_key->KeyType==AIRPDCAP_KEY_TYPE_WEP) {\n            /* the tried key is the correct one, cached in the Security Association */\n\n            sa->key=tmp_key;\n\n            if (key!=NULL) {\n                memcpy(key, sa->key, sizeof(AIRPDCAP_KEY_ITEM));\n                key->KeyType=AIRPDCAP_KEY_TYPE_WEP;\n            }\n\n            break;\n        } else {\n            /* the cached key was not valid, try other keys */\n\n            if (useCache==TRUE) {\n                useCache=FALSE;\n                key_index--;\n            }\n        }\n    }\n\n    g_free(try_data);\n    if (ret_value)\n        return AIRPDCAP_RET_UNSUCCESS;\n\n    AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapWepMng\", \"WEP DECRYPTED!!!\", AIRPDCAP_DEBUG_LEVEL_3);\n\n    /* remove ICV (4bytes) from the end of packet */\n    *decrypt_len-=4;\n\n    if (*decrypt_len < 4) {\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapWepMng\", \"Decryption length too short\", AIRPDCAP_DEBUG_LEVEL_3);\n        return AIRPDCAP_RET_UNSUCCESS;\n    }\n\n    /* remove protection bit */\n    decrypt_data[1]&=0xBF;\n\n    /* remove IC header */\n    offset = mac_header_len;\n    *decrypt_len-=4;\n    memmove(decrypt_data+offset, decrypt_data+offset+AIRPDCAP_WEP_IVLEN+AIRPDCAP_WEP_KIDLEN, *decrypt_len-offset);\n\n    return AIRPDCAP_RET_SUCCESS;\n}\n\n/* Refer to IEEE 802.11i-2004, 8.5.3, pag. 85 */\nstatic INT\nAirPDcapRsna4WHandshake(\n    PAIRPDCAP_CONTEXT ctx,\n    const UCHAR *data,\n    AIRPDCAP_SEC_ASSOCIATION *sa,\n    INT offset,\n    const guint tot_len)\n{\n    AIRPDCAP_KEY_ITEM *tmp_key, *tmp_pkt_key, pkt_key;\n    AIRPDCAP_SEC_ASSOCIATION *tmp_sa;\n    INT key_index;\n    INT ret_value=1;\n    UCHAR useCache=FALSE;\n    UCHAR eapol[AIRPDCAP_EAPOL_MAX_LEN];\n    USHORT eapol_len;\n\n    if (sa->key!=NULL)\n        useCache=TRUE;\n\n    /* a 4-way handshake packet use a Pairwise key type (IEEE 802.11i-2004, pg. 79) */\n    if (AIRPDCAP_EAP_KEY(data[offset+1])!=1) {\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsna4WHandshake\", \"Group/STAKey message (not used)\", AIRPDCAP_DEBUG_LEVEL_5);\n        return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n    }\n\n    /* TODO timeouts? */\n\n    /* TODO consider key-index */\n\n    /* TODO considera Deauthentications */\n\n    AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsna4WHandshake\", \"4-way handshake...\", AIRPDCAP_DEBUG_LEVEL_5);\n\n    /* manage 4-way handshake packets; this step completes the 802.1X authentication process (IEEE 802.11i-2004, pag. 85) */\n\n    /* message 1: Authenticator->Supplicant (Sec=0, Mic=0, Ack=1, Inst=0, Key=1(pairwise), KeyRSC=0, Nonce=ANonce, MIC=0) */\n    if (AIRPDCAP_EAP_INST(data[offset+1])==0 &&\n        AIRPDCAP_EAP_ACK(data[offset+1])==1 &&\n        AIRPDCAP_EAP_MIC(data[offset])==0)\n    {\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsna4WHandshake\", \"4-way handshake message 1\", AIRPDCAP_DEBUG_LEVEL_3);\n\n        /* On reception of Message 1, the Supplicant determines whether the Key Replay Counter field value has been        */\n        /* used before with the current PMKSA. If the Key Replay Counter field value is less than or equal to the current  */\n        /* local value, the Supplicant discards the message.                                                               */\n        /* -> not checked, the Authenticator will be send another Message 1 (hopefully!)                                   */\n\n        /* This saves the sa since we are reauthenticating which will overwrite our current sa GCS*/\n        if( sa->handshake >= 2) {\n            tmp_sa= g_new(AIRPDCAP_SEC_ASSOCIATION, 1);\n            memcpy(tmp_sa, sa, sizeof(AIRPDCAP_SEC_ASSOCIATION));\n            sa->validKey=FALSE;\n            sa->next=tmp_sa;\n        }\n\n        /* save ANonce (from authenticator) to derive the PTK with the SNonce (from the 2 message) */\n        memcpy(sa->wpa.nonce, data+offset+12, 32);\n\n        /* get the Key Descriptor Version (to select algorithm used in decryption -CCMP or TKIP-) */\n        sa->wpa.key_ver=AIRPDCAP_EAP_KEY_DESCR_VER(data[offset+1]);\n\n        sa->handshake=1;\n\n        return AIRPDCAP_RET_SUCCESS_HANDSHAKE;\n    }\n\n    /* message 2|4: Supplicant->Authenticator (Sec=0|1, Mic=1, Ack=0, Inst=0, Key=1(pairwise), KeyRSC=0, Nonce=SNonce|0, MIC=MIC(KCK,EAPOL)) */\n    if (AIRPDCAP_EAP_INST(data[offset+1])==0 &&\n        AIRPDCAP_EAP_ACK(data[offset+1])==0 &&\n        AIRPDCAP_EAP_MIC(data[offset])==1)\n    {\n        /* Check key data length to differentiate between message 2 or 4, same as in epan/dissectors/packet-ieee80211.c */\n        if (pntoh16(data+offset+92)) {\n            /* message 2 */\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsna4WHandshake\", \"4-way handshake message 2\", AIRPDCAP_DEBUG_LEVEL_3);\n\n            /* On reception of Message 2, the Authenticator checks that the key replay counter corresponds to the */\n            /* outstanding Message 1. If not, it silently discards the message.                                   */\n            /* If the calculated MIC does not match the MIC that the Supplicant included in the EAPOL-Key frame,  */\n            /* the Authenticator silently discards Message 2.                                                     */\n            /* -> not checked; the Supplicant will send another message 2 (hopefully!)                            */\n\n            /* now you can derive the PTK */\n            for (key_index=0; key_index<(INT)ctx->keys_nr || useCache; key_index++) {\n                /* use the cached one, or try all keys */\n                if (!useCache) {\n                    AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsna4WHandshake\", \"Try WPA key...\", AIRPDCAP_DEBUG_LEVEL_3);\n                    tmp_key=&ctx->keys[key_index];\n                } else {\n                    /* there is a cached key in the security association, if it's a WPA key try it... */\n                    if (sa->key!=NULL &&\n                        (sa->key->KeyType==AIRPDCAP_KEY_TYPE_WPA_PWD ||\n                         sa->key->KeyType==AIRPDCAP_KEY_TYPE_WPA_PSK ||\n                         sa->key->KeyType==AIRPDCAP_KEY_TYPE_WPA_PMK)) {\n                            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsna4WHandshake\", \"Try cached WPA key...\", AIRPDCAP_DEBUG_LEVEL_3);\n                            tmp_key=sa->key;\n                    } else {\n                        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsna4WHandshake\", \"Cached key is of a wrong type, try WPA key...\", AIRPDCAP_DEBUG_LEVEL_3);\n                        tmp_key=&ctx->keys[key_index];\n                    }\n                }\n\n                /* obviously, try only WPA keys... */\n                if (tmp_key->KeyType==AIRPDCAP_KEY_TYPE_WPA_PWD ||\n                    tmp_key->KeyType==AIRPDCAP_KEY_TYPE_WPA_PSK ||\n                    tmp_key->KeyType==AIRPDCAP_KEY_TYPE_WPA_PMK)\n                {\n                    if (tmp_key->KeyType == AIRPDCAP_KEY_TYPE_WPA_PWD && tmp_key->UserPwd.SsidLen == 0 && ctx->pkt_ssid_len > 0 && ctx->pkt_ssid_len <= AIRPDCAP_WPA_SSID_MAX_LEN) {\n                        /* We have a \"wildcard\" SSID.  Use the one from the packet. */\n                        memcpy(&pkt_key, tmp_key, sizeof(pkt_key));\n                        memcpy(&pkt_key.UserPwd.Ssid, ctx->pkt_ssid, ctx->pkt_ssid_len);\n                         pkt_key.UserPwd.SsidLen = ctx->pkt_ssid_len;\n                        AirPDcapRsnaPwd2Psk(pkt_key.UserPwd.Passphrase, pkt_key.UserPwd.Ssid,\n                            pkt_key.UserPwd.SsidLen, pkt_key.KeyData.Wpa.Psk);\n                        tmp_pkt_key = &pkt_key;\n                    } else {\n                        tmp_pkt_key = tmp_key;\n                    }\n\n                    /* derive the PTK from the BSSID, STA MAC, PMK, SNonce, ANonce */\n                    AirPDcapRsnaPrfX(sa,                            /* authenticator nonce, bssid, station mac */\n                                     tmp_pkt_key->KeyData.Wpa.Psk,      /* PSK == PMK */\n                                     data+offset+12,                /* supplicant nonce */\n                                     512,\n                                     sa->wpa.ptk);\n\n                    /* verify the MIC (compare the MIC in the packet included in this message with a MIC calculated with the PTK) */\n                    eapol_len=pntoh16(data+offset-3)+4;\n                    memcpy(eapol, &data[offset-5], (eapol_len<AIRPDCAP_EAPOL_MAX_LEN?eapol_len:AIRPDCAP_EAPOL_MAX_LEN));\n                    ret_value=AirPDcapRsnaMicCheck(eapol,           /*      eapol frame (header also) */\n                                                   eapol_len,       /*      eapol frame length        */\n                                                   sa->wpa.ptk,     /*      Key Confirmation Key      */\n                                                   AIRPDCAP_EAP_KEY_DESCR_VER(data[offset+1])); /*  EAPOL-Key description version */\n\n                    /* If the MIC is valid, the Authenticator checks that the RSN information element bit-wise matches       */\n                    /* that from the (Re)Association Request message.                                                        */\n                    /*              i) TODO If these are not exactly the same, the Authenticator uses MLME-DEAUTHENTICATE.request */\n                    /* primitive to terminate the association.                                                               */\n                    /*              ii) If they do match bit-wise, the Authenticator constructs Message 3.                   */\n                }\n\n                if (!ret_value &&\n                    (tmp_key->KeyType==AIRPDCAP_KEY_TYPE_WPA_PWD ||\n                    tmp_key->KeyType==AIRPDCAP_KEY_TYPE_WPA_PSK ||\n                    tmp_key->KeyType==AIRPDCAP_KEY_TYPE_WPA_PMK))\n                {\n                    /* the temporary key is the correct one, cached in the Security Association */\n\n                    sa->key=tmp_key;\n                    break;\n                } else {\n                    /* the cached key was not valid, try other keys */\n\n                    if (useCache==TRUE) {\n                        useCache=FALSE;\n                        key_index--;\n                    }\n                }\n            }\n\n            if (ret_value) {\n                AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsna4WHandshake\", \"handshake step failed\", AIRPDCAP_DEBUG_LEVEL_3);\n                return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n            }\n\n            sa->handshake=2;\n            sa->validKey=TRUE; /* we can use the key to decode, even if we have not captured the other eapol packets */\n\n            return AIRPDCAP_RET_SUCCESS_HANDSHAKE;\n        } else {\n        /* message 4 */\n\n            /* TODO \"Note that when the 4-Way Handshake is first used Message 4 is sent in the clear.\" */\n\n            /* TODO check MIC and Replay Counter                                                                     */\n            /* On reception of Message 4, the Authenticator verifies that the Key Replay Counter field value is one  */\n            /* that it used on this 4-Way Handshake; if it is not, it silently discards the message.                 */\n            /* If the calculated MIC does not match the MIC that the Supplicant included in the EAPOL-Key frame, the */\n            /* Authenticator silently discards Message 4.                                                            */\n\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsna4WHandshake\", \"4-way handshake message 4\", AIRPDCAP_DEBUG_LEVEL_3);\n\n            sa->handshake=4;\n\n            return AIRPDCAP_RET_SUCCESS_HANDSHAKE;\n        }\n    }\n\n    /* message 3: Authenticator->Supplicant (Sec=1, Mic=1, Ack=1, Inst=0/1, Key=1(pairwise), KeyRSC=???, Nonce=ANonce, MIC=1) */\n    if (AIRPDCAP_EAP_ACK(data[offset+1])==1 &&\n        AIRPDCAP_EAP_MIC(data[offset])==1)\n    {\n        const EAPOL_RSN_KEY *pEAPKey;\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsna4WHandshake\", \"4-way handshake message 3\", AIRPDCAP_DEBUG_LEVEL_3);\n\n        /* On reception of Message 3, the Supplicant silently discards the message if the Key Replay Counter field     */\n        /* value has already been used or if the ANonce value in Message 3 differs from the ANonce value in Message 1. */\n        /* -> not checked, the Authenticator will send another message 3 (hopefully!)                                  */\n\n        /* TODO check page 88 (RNS) */\n\n        /* If using WPA2 PSK, message 3 will contain an RSN for the group key (GTK KDE).\n           In order to properly support decrypting WPA2-PSK packets, we need to parse this to get the group key. */\n        pEAPKey = (const EAPOL_RSN_KEY *)(&(data[offset-1]));\n        if (pEAPKey->type == AIRPDCAP_RSN_WPA2_KEY_DESCRIPTOR){\n            PAIRPDCAP_SEC_ASSOCIATION broadcast_sa;\n            AIRPDCAP_SEC_ASSOCIATION_ID id;\n\n            /* Get broadcacst SA for the current BSSID */\n            memcpy(id.sta, broadcast_mac, AIRPDCAP_MAC_LEN);\n            memcpy(id.bssid, sa->saId.bssid, AIRPDCAP_MAC_LEN);\n            broadcast_sa = AirPDcapGetSaPtr(ctx, &id);\n\n            if (broadcast_sa == NULL){\n                return AIRPDCAP_RET_REQ_DATA;\n            }\n            return (AirPDcapDecryptWPABroadcastKey(pEAPKey, sa->wpa.ptk+16, broadcast_sa, tot_len-offset+1));\n        }\n    }\n\n    return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n}\n\nstatic INT\nAirPDcapRsnaMicCheck(\n    UCHAR *eapol,\n    USHORT eapol_len,\n    UCHAR KCK[AIRPDCAP_WPA_KCK_LEN],\n    USHORT key_ver)\n{\n    UCHAR mic[AIRPDCAP_WPA_MICKEY_LEN];\n    UCHAR c_mic[20];  /* MIC 16 byte, the HMAC-SHA1 use a buffer of 20 bytes */\n\n    /* copy the MIC from the EAPOL packet */\n    memcpy(mic, eapol+AIRPDCAP_WPA_MICKEY_OFFSET+4, AIRPDCAP_WPA_MICKEY_LEN);\n\n    /* set to 0 the MIC in the EAPOL packet (to calculate the MIC) */\n    memset(eapol+AIRPDCAP_WPA_MICKEY_OFFSET+4, 0, AIRPDCAP_WPA_MICKEY_LEN);\n\n    if (key_ver==AIRPDCAP_WPA_KEY_VER_NOT_CCMP) {\n        /* use HMAC-MD5 for the EAPOL-Key MIC */\n        md5_hmac(eapol, eapol_len, KCK, AIRPDCAP_WPA_KCK_LEN, c_mic);\n    } else if (key_ver==AIRPDCAP_WPA_KEY_VER_AES_CCMP) {\n        /* use HMAC-SHA1-128 for the EAPOL-Key MIC */\n        sha1_hmac(KCK, AIRPDCAP_WPA_KCK_LEN, eapol, eapol_len, c_mic);\n    } else\n        /* key descriptor version not recognized */\n        return AIRPDCAP_RET_UNSUCCESS;\n\n    /* compare calculated MIC with the Key MIC and return result (0 means success) */\n    return memcmp(mic, c_mic, AIRPDCAP_WPA_MICKEY_LEN);\n}\n\nstatic INT\nAirPDcapValidateKey(\n    PAIRPDCAP_KEY_ITEM key)\n{\n    size_t len;\n    UCHAR ret=TRUE;\n    AIRPDCAP_DEBUG_TRACE_START(\"AirPDcapValidateKey\");\n\n    if (key==NULL) {\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapValidateKey\", \"NULL key\", AIRPDCAP_DEBUG_LEVEL_5);\n        AIRPDCAP_DEBUG_TRACE_START(\"AirPDcapValidateKey\");\n        return FALSE;\n    }\n\n    switch (key->KeyType) {\n        case AIRPDCAP_KEY_TYPE_WEP:\n            /* check key size limits */\n            len=key->KeyData.Wep.WepKeyLen;\n            if (len<AIRPDCAP_WEP_KEY_MINLEN || len>AIRPDCAP_WEP_KEY_MAXLEN) {\n                AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapValidateKey\", \"WEP key: key length not accepted\", AIRPDCAP_DEBUG_LEVEL_5);\n                ret=FALSE;\n            }\n            break;\n\n        case AIRPDCAP_KEY_TYPE_WEP_40:\n            /* set the standard length and use a generic WEP key type */\n            key->KeyData.Wep.WepKeyLen=AIRPDCAP_WEP_40_KEY_LEN;\n            key->KeyType=AIRPDCAP_KEY_TYPE_WEP;\n            break;\n\n        case AIRPDCAP_KEY_TYPE_WEP_104:\n            /* set the standard length and use a generic WEP key type */\n            key->KeyData.Wep.WepKeyLen=AIRPDCAP_WEP_104_KEY_LEN;\n            key->KeyType=AIRPDCAP_KEY_TYPE_WEP;\n            break;\n\n        case AIRPDCAP_KEY_TYPE_WPA_PWD:\n            /* check passphrase and SSID size limits */\n            len=strlen(key->UserPwd.Passphrase);\n            if (len<AIRPDCAP_WPA_PASSPHRASE_MIN_LEN || len>AIRPDCAP_WPA_PASSPHRASE_MAX_LEN) {\n                AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapValidateKey\", \"WPA-PWD key: passphrase length not accepted\", AIRPDCAP_DEBUG_LEVEL_5);\n                ret=FALSE;\n            }\n\n            len=key->UserPwd.SsidLen;\n            if (len>AIRPDCAP_WPA_SSID_MAX_LEN) {\n                AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapValidateKey\", \"WPA-PWD key: ssid length not accepted\", AIRPDCAP_DEBUG_LEVEL_5);\n                ret=FALSE;\n            }\n\n            break;\n\n        case AIRPDCAP_KEY_TYPE_WPA_PSK:\n            break;\n\n        case AIRPDCAP_KEY_TYPE_WPA_PMK:\n            break;\n\n        default:\n            ret=FALSE;\n    }\n\n    AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapValidateKey\");\n    return ret;\n}\n\nstatic INT\nAirPDcapGetSa(\n    PAIRPDCAP_CONTEXT ctx,\n    AIRPDCAP_SEC_ASSOCIATION_ID *id)\n{\n    INT sa_index;\n    if (ctx->sa_index!=-1) {\n        /* at least one association was stored                               */\n        /* search for the association from sa_index to 0 (most recent added) */\n        for (sa_index=ctx->sa_index; sa_index>=0; sa_index--) {\n            if (ctx->sa[sa_index].used) {\n                if (memcmp(id, &(ctx->sa[sa_index].saId), sizeof(AIRPDCAP_SEC_ASSOCIATION_ID))==0) {\n                    ctx->index=sa_index;\n                    return sa_index;\n                }\n            }\n        }\n    }\n\n    return -1;\n}\n\nstatic INT\nAirPDcapStoreSa(\n    PAIRPDCAP_CONTEXT ctx,\n    AIRPDCAP_SEC_ASSOCIATION_ID *id)\n{\n    INT last_free;\n    if (ctx->first_free_index>=AIRPDCAP_MAX_SEC_ASSOCIATIONS_NR) {\n        /* there is no empty space available. FAILURE */\n        return -1;\n    }\n    if (ctx->sa[ctx->first_free_index].used) {\n        /* last addition was in the middle of the array (and the first_free_index was just incremented by 1)   */\n        /* search for a free space from the first_free_index to AIRPDCAP_STA_INFOS_NR (to avoid free blocks in */\n        /*              the middle)                                                                            */\n        for (last_free=ctx->first_free_index; last_free<AIRPDCAP_MAX_SEC_ASSOCIATIONS_NR; last_free++)\n            if (!ctx->sa[last_free].used)\n                break;\n\n        if (last_free>=AIRPDCAP_MAX_SEC_ASSOCIATIONS_NR) {\n            /* there is no empty space available. FAILURE */\n            return -1;\n        }\n\n        /* store first free space index */\n        ctx->first_free_index=last_free;\n    }\n\n    /* use this info */\n    ctx->index=ctx->first_free_index;\n\n    /* reset the info structure */\n    memset(ctx->sa+ctx->index, 0, sizeof(AIRPDCAP_SEC_ASSOCIATION));\n\n    ctx->sa[ctx->index].used=1;\n\n    /* set the info structure */\n    memcpy(&(ctx->sa[ctx->index].saId), id, sizeof(AIRPDCAP_SEC_ASSOCIATION_ID));\n\n    /* increment by 1 the first_free_index (heuristic) */\n    ctx->first_free_index++;\n\n    /* set the sa_index if the added index is greater the the sa_index */\n    if (ctx->index > ctx->sa_index)\n        ctx->sa_index=ctx->index;\n\n    return ctx->index;\n}\n\n\nstatic INT\nAirPDcapGetSaAddress(\n    const AIRPDCAP_MAC_FRAME_ADDR4 *frame,\n    AIRPDCAP_SEC_ASSOCIATION_ID *id)\n{\n#ifdef _DEBUG\n#define MSGBUF_LEN 255\n    CHAR msgbuf[MSGBUF_LEN];\n#endif\n\n    if ((AIRPDCAP_TYPE(frame->fc[0])==AIRPDCAP_TYPE_DATA) &&\n        (AIRPDCAP_DS_BITS(frame->fc[1]) == 0) &&\n        (memcmp(frame->addr2, frame->addr3, AIRPDCAP_MAC_LEN) != 0) &&\n        (memcmp(frame->addr1, frame->addr3, AIRPDCAP_MAC_LEN) != 0)) {\n        /* DATA frame with fromDS=0 ToDS=0 and neither RA or SA is BSSID\n           => TDLS traffic. Use highest MAC address for bssid */\n        if (memcmp(frame->addr1, frame->addr2, AIRPDCAP_MAC_LEN) < 0) {\n            memcpy(id->sta, frame->addr1, AIRPDCAP_MAC_LEN);\n            memcpy(id->bssid, frame->addr2, AIRPDCAP_MAC_LEN);\n        } else {\n            memcpy(id->sta, frame->addr2, AIRPDCAP_MAC_LEN);\n            memcpy(id->bssid, frame->addr1, AIRPDCAP_MAC_LEN);\n        }\n    } else {\n        const UCHAR *addr;\n\n        /* Normal Case: SA between STA and AP */\n        if ((addr = AirPDcapGetBssidAddress(frame)) != NULL) {\n            memcpy(id->bssid, addr, AIRPDCAP_MAC_LEN);\n        } else {\n            return AIRPDCAP_RET_UNSUCCESS;\n        }\n\n        if ((addr = AirPDcapGetStaAddress(frame)) != NULL) {\n            memcpy(id->sta, addr, AIRPDCAP_MAC_LEN);\n        } else {\n            return AIRPDCAP_RET_UNSUCCESS;\n        }\n    }\n\n#ifdef _DEBUG\n    g_snprintf(msgbuf, MSGBUF_LEN, \"BSSID_MAC: %02X.%02X.%02X.%02X.%02X.%02X\\t\",\n               id->bssid[0],id->bssid[1],id->bssid[2],id->bssid[3],id->bssid[4],id->bssid[5]);\n    AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapGetSaAddress\", msgbuf, AIRPDCAP_DEBUG_LEVEL_3);\n    g_snprintf(msgbuf, MSGBUF_LEN, \"STA_MAC: %02X.%02X.%02X.%02X.%02X.%02X\\t\",\n               id->sta[0],id->sta[1],id->sta[2],id->sta[3],id->sta[4],id->sta[5]);\n    AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapGetSaAddress\", msgbuf, AIRPDCAP_DEBUG_LEVEL_3);\n#endif\n\n    return AIRPDCAP_RET_SUCCESS;\n}\n\n/*\n * AirPDcapGetBssidAddress() and AirPDcapGetBssidAddress() are used for\n * key caching.  In each case, it's more important to return a value than\n * to return a _correct_ value, so we fudge addresses in some cases, e.g.\n * the BSSID in bridged connections.\n * FromDS    ToDS   Sta      BSSID\n * 0         0      addr1/2  addr3\n * 0         1      addr2    addr1\n * 1         0      addr1    addr2\n * 1         1      addr2    addr1\n */\n\nstatic const UCHAR *\nAirPDcapGetStaAddress(\n    const AIRPDCAP_MAC_FRAME_ADDR4 *frame)\n{\n    switch(AIRPDCAP_DS_BITS(frame->fc[1])) { /* Bit 1 = FromDS, bit 0 = ToDS */\n        case 0:\n            if (memcmp(frame->addr2, frame->addr3, AIRPDCAP_MAC_LEN) == 0)\n                return frame->addr1;\n            else\n                return frame->addr2;\n        case 1:\n            return frame->addr2;\n        case 2:\n            return frame->addr1;\n        case 3:\n            if (memcmp(frame->addr1, frame->addr2, AIRPDCAP_MAC_LEN) < 0)\n                return frame->addr1;\n            else\n                return frame->addr2;\n\n        default:\n            return NULL;\n    }\n}\n\nstatic const UCHAR *\nAirPDcapGetBssidAddress(\n    const AIRPDCAP_MAC_FRAME_ADDR4 *frame)\n{\n    switch(AIRPDCAP_DS_BITS(frame->fc[1])) { /* Bit 1 = FromDS, bit 0 = ToDS */\n        case 0:\n            return frame->addr3;\n        case 1:\n            return frame->addr1;\n        case 2:\n            return frame->addr2;\n        case 3:\n            if (memcmp(frame->addr1, frame->addr2, AIRPDCAP_MAC_LEN) > 0)\n                return frame->addr1;\n            else\n                return frame->addr2;\n\n        default:\n            return NULL;\n    }\n}\n\n/* Function used to derive the PTK. Refer to IEEE 802.11I-2004, pag. 74\n * and IEEE 802.11i-2004, pag. 164 */\nstatic void\nAirPDcapRsnaPrfX(\n    AIRPDCAP_SEC_ASSOCIATION *sa,\n    const UCHAR pmk[32],\n    const UCHAR snonce[32],\n    const INT x,        /*      for TKIP 512, for CCMP 384 */\n    UCHAR *ptk)\n{\n    UINT8 i;\n    UCHAR R[100];\n    INT offset=sizeof(\"Pairwise key expansion\");\n    UCHAR output[80]; /* allow for sha1 overflow. */\n\n    memset(R, 0, 100);\n\n    memcpy(R, \"Pairwise key expansion\", offset);\n\n    /* Min(AA, SPA) || Max(AA, SPA) */\n    if (memcmp(sa->saId.sta, sa->saId.bssid, AIRPDCAP_MAC_LEN) < 0)\n    {\n        memcpy(R + offset, sa->saId.sta, AIRPDCAP_MAC_LEN);\n        memcpy(R + offset+AIRPDCAP_MAC_LEN, sa->saId.bssid, AIRPDCAP_MAC_LEN);\n    }\n    else\n    {\n        memcpy(R + offset, sa->saId.bssid, AIRPDCAP_MAC_LEN);\n        memcpy(R + offset+AIRPDCAP_MAC_LEN, sa->saId.sta, AIRPDCAP_MAC_LEN);\n    }\n\n    offset+=AIRPDCAP_MAC_LEN*2;\n\n    /* Min(ANonce,SNonce) || Max(ANonce,SNonce) */\n    if( memcmp(snonce, sa->wpa.nonce, 32) < 0 )\n    {\n        memcpy(R + offset, snonce, 32);\n        memcpy(R + offset + 32, sa->wpa.nonce, 32);\n    }\n    else\n    {\n        memcpy(R + offset, sa->wpa.nonce, 32);\n        memcpy(R + offset + 32, snonce, 32);\n    }\n\n    offset+=32*2;\n\n    for(i = 0; i < (x+159)/160; i++)\n    {\n        R[offset] = i;\n        sha1_hmac(pmk, 32, R, 100, &output[20 * i]);\n    }\n    memcpy(ptk, output, x/8);\n}\n\n#define MAX_SSID_LENGTH 32 /* maximum SSID length */\n\nstatic INT\nAirPDcapRsnaPwd2PskStep(\n    const guint8 *ppBytes,\n    const guint ppLength,\n    const CHAR *ssid,\n    const size_t ssidLength,\n    const INT iterations,\n    const INT count,\n    UCHAR *output)\n{\n    UCHAR digest[MAX_SSID_LENGTH+4];  /* SSID plus 4 bytes of count */\n    UCHAR digest1[SHA1_DIGEST_LEN];\n    INT i, j;\n\n    if (ssidLength > MAX_SSID_LENGTH) {\n        /* This \"should not happen\" */\n        return AIRPDCAP_RET_UNSUCCESS;\n    }\n\n    memset(digest, 0, sizeof digest);\n    memset(digest1, 0, sizeof digest1);\n\n    /* U1 = PRF(P, S || INT(i)) */\n    memcpy(digest, ssid, ssidLength);\n    digest[ssidLength] = (UCHAR)((count>>24) & 0xff);\n    digest[ssidLength+1] = (UCHAR)((count>>16) & 0xff);\n    digest[ssidLength+2] = (UCHAR)((count>>8) & 0xff);\n    digest[ssidLength+3] = (UCHAR)(count & 0xff);\n    sha1_hmac(ppBytes, ppLength, digest, (guint32) ssidLength+4, digest1);\n\n    /* output = U1 */\n    memcpy(output, digest1, SHA1_DIGEST_LEN);\n    for (i = 1; i < iterations; i++) {\n        /* Un = PRF(P, Un-1) */\n        sha1_hmac(ppBytes, ppLength, digest1, SHA1_DIGEST_LEN, digest);\n\n        memcpy(digest1, digest, SHA1_DIGEST_LEN);\n        /* output = output xor Un */\n        for (j = 0; j < SHA1_DIGEST_LEN; j++) {\n            output[j] ^= digest[j];\n        }\n    }\n\n    return AIRPDCAP_RET_SUCCESS;\n}\n\nstatic INT\nAirPDcapRsnaPwd2Psk(\n    const CHAR *passphrase,\n    const CHAR *ssid,\n    const size_t ssidLength,\n    UCHAR *output)\n{\n    UCHAR m_output[2*SHA1_DIGEST_LEN];\n    GByteArray *pp_ba = g_byte_array_new();\n\n    memset(m_output, 0, 2*SHA1_DIGEST_LEN);\n\n    if (!uri_str_to_bytes(passphrase, pp_ba)) {\n        g_byte_array_free(pp_ba, TRUE);\n        return 0;\n    }\n\n    AirPDcapRsnaPwd2PskStep(pp_ba->data, pp_ba->len, ssid, ssidLength, 4096, 1, m_output);\n    AirPDcapRsnaPwd2PskStep(pp_ba->data, pp_ba->len, ssid, ssidLength, 4096, 2, &m_output[SHA1_DIGEST_LEN]);\n\n    memcpy(output, m_output, AIRPDCAP_WPA_PSK_LEN);\n    g_byte_array_free(pp_ba, TRUE);\n\n    return 0;\n}\n\n/*\n * Returns the decryption_key_t struct given a string describing the key.\n * Returns NULL if the input_string cannot be parsed.\n */\ndecryption_key_t*\nparse_key_string(gchar* input_string, guint8 key_type)\n{\n    gchar *key, *tmp_str;\n    gchar *ssid;\n\n    GString    *key_string = NULL;\n    GByteArray *ssid_ba = NULL, *key_ba;\n    gboolean    res;\n\n    gchar **tokens;\n    guint n = 0;\n    decryption_key_t *dk;\n\n    if(input_string == NULL)\n        return NULL;\n\n    /*\n     * Parse the input_string. WEP and WPA will be just a string\n     * of hexadecimal characters (if key is wrong, null will be\n     * returned...).\n     * WPA-PWD should be in the form\n     * <key data>[:<ssid>]\n     */\n\n    switch(key_type)\n    {\n    case AIRPDCAP_KEY_TYPE_WEP:\n    case AIRPDCAP_KEY_TYPE_WEP_40:\n    case AIRPDCAP_KEY_TYPE_WEP_104:\n\n       key_ba = g_byte_array_new();\n       res = hex_str_to_bytes(input_string, key_ba, FALSE);\n\n       if (res && key_ba->len > 0) {\n           /* Key is correct! It was probably an 'old style' WEP key */\n           /* Create the decryption_key_t structure, fill it and return it*/\n           dk = (decryption_key_t *)g_malloc(sizeof(decryption_key_t));\n\n           dk->type = AIRPDCAP_KEY_TYPE_WEP;\n           /* XXX - The current key handling code in the GUI requires\n            * no separators and lower case */\n           tmp_str = bytes_to_str(NULL, key_ba->data, key_ba->len);\n           dk->key  = g_string_new(tmp_str);\n           g_string_ascii_down(dk->key);\n           dk->bits = key_ba->len * 8;\n           dk->ssid = NULL;\n\n           wmem_free(NULL, tmp_str);\n           g_byte_array_free(key_ba, TRUE);\n           return dk;\n       }\n\n       /* Key doesn't work */\n       g_byte_array_free(key_ba, TRUE);\n       return NULL;\n\n    case AIRPDCAP_KEY_TYPE_WPA_PWD:\n\n        tokens = g_strsplit(input_string,\":\",0);\n\n        /* Tokens is a null termiated array of strings ... */\n        while(tokens[n] != NULL)\n            n++;\n\n        if(n < 1)\n        {\n            /* Free the array of strings */\n            g_strfreev(tokens);\n            return NULL;\n        }\n\n        /*\n         * The first token is the key\n         */\n        key = g_strdup(tokens[0]);\n\n        ssid = NULL;\n        /* Maybe there is a second token (an ssid, if everything else is ok) */\n        if(n >= 2)\n        {\n           ssid = g_strdup(tokens[1]);\n        }\n\n        /* Create a new string */\n        key_string = g_string_new(key);\n        ssid_ba = NULL;\n\n        /* Two (or more) tokens mean that the user entered a WPA-PWD key ... */\n        if( ((key_string->len) > WPA_KEY_MAX_CHAR_SIZE) || ((key_string->len) < WPA_KEY_MIN_CHAR_SIZE))\n        {\n            g_string_free(key_string, TRUE);\n\n            g_free(key);\n            g_free(ssid);\n\n            /* Free the array of strings */\n            g_strfreev(tokens);\n            return NULL;\n        }\n\n        if(ssid != NULL) /* more than two tokens found, means that the user specified the ssid */\n        {\n            ssid_ba = g_byte_array_new();\n            if (! uri_str_to_bytes(ssid, ssid_ba)) {\n                g_string_free(key_string, TRUE);\n                g_byte_array_free(ssid_ba, TRUE);\n                g_free(key);\n                g_free(ssid);\n                /* Free the array of strings */\n                g_strfreev(tokens);\n                return NULL;\n            }\n\n            if(ssid_ba->len > WPA_SSID_MAX_CHAR_SIZE)\n            {\n                g_string_free(key_string, TRUE);\n                g_byte_array_free(ssid_ba, TRUE);\n\n                g_free(key);\n                g_free(ssid);\n\n                /* Free the array of strings */\n                g_strfreev(tokens);\n                return NULL;\n            }\n        }\n\n        /* Key was correct!!! Create the new decryption_key_t ... */\n        dk = (decryption_key_t*)g_malloc(sizeof(decryption_key_t));\n\n        dk->type = AIRPDCAP_KEY_TYPE_WPA_PWD;\n        dk->key  = g_string_new(key);\n        dk->bits = 256; /* This is the length of the array pf bytes that will be generated using key+ssid ...*/\n        dk->ssid = byte_array_dup(ssid_ba); /* NULL if ssid_ba is NULL */\n\n        g_string_free(key_string, TRUE);\n        if (ssid_ba != NULL)\n            g_byte_array_free(ssid_ba, TRUE);\n\n        g_free(key);\n        if(ssid != NULL)\n            g_free(ssid);\n\n        /* Free the array of strings */\n        g_strfreev(tokens);\n        return dk;\n\n    case AIRPDCAP_KEY_TYPE_WPA_PSK:\n\n        key_ba = g_byte_array_new();\n        res = hex_str_to_bytes(input_string, key_ba, FALSE);\n\n        /* Two tokens means that the user should have entered a WPA-BIN key ... */\n        if(!res || ((key_ba->len) != WPA_PSK_KEY_SIZE))\n        {\n            g_byte_array_free(key_ba, TRUE);\n\n            /* No ssid has been created ... */\n            return NULL;\n        }\n\n        /* Key was correct!!! Create the new decryption_key_t ... */\n        dk = (decryption_key_t*)g_malloc(sizeof(decryption_key_t));\n\n        dk->type = AIRPDCAP_KEY_TYPE_WPA_PSK;\n        dk->key  = g_string_new(input_string);\n        dk->bits = (guint) dk->key->len * 4;\n        dk->ssid = NULL;\n\n        g_byte_array_free(key_ba, TRUE);\n        return dk;\n    }\n\n    /* Type not supported */\n    return NULL;\n}\n\nvoid\nfree_key_string(decryption_key_t *dk)\n{\n    if (dk->key)\n        g_string_free(dk->key, TRUE);\n    if (dk->ssid)\n        g_byte_array_free(dk->ssid, TRUE);\n    g_free(dk);\n}\n\n/*\n * Returns a newly allocated string representing the given decryption_key_t\n * struct, or NULL if something is wrong...\n */\ngchar*\nget_key_string(decryption_key_t* dk)\n{\n    gchar* output_string = NULL;\n\n    if(dk == NULL || dk->key == NULL)\n        return NULL;\n\n    switch(dk->type) {\n        case AIRPDCAP_KEY_TYPE_WEP:\n            output_string = g_strdup(dk->key->str);\n            break;\n        case AIRPDCAP_KEY_TYPE_WPA_PWD:\n            if(dk->ssid == NULL)\n                output_string = g_strdup(dk->key->str);\n            else\n                output_string = g_strdup_printf(\"%s:%s\",\n                    dk->key->str, format_uri(dk->ssid, \":\"));\n            break;\n        case AIRPDCAP_KEY_TYPE_WPA_PMK:\n            output_string = g_strdup(dk->key->str);\n            break;\n        default:\n            return NULL;\n    }\n\n    return output_string;\n}\n\nstatic INT\nAirPDcapTDLSDeriveKey(\n    PAIRPDCAP_SEC_ASSOCIATION sa,\n    const guint8 *data,\n    guint offset_rsne,\n    guint offset_fte,\n    guint offset_timeout,\n    guint offset_link,\n    guint8 action)\n{\n\n    sha256_hmac_context sha_ctx;\n    aes_cmac_ctx aes_ctx;\n    const guint8 *snonce, *anonce, *initiator, *responder, *bssid;\n    guint8 key_input[SHA256_DIGEST_LEN];\n    guint8 mic[16], iter[2], length[2], seq_num = action + 1;\n\n    /* Get key input */\n    anonce = &data[offset_fte + 20];\n    snonce = &data[offset_fte + 52];\n    sha256_starts(&(sha_ctx.ctx));\n    if (memcmp(anonce, snonce, AIRPDCAP_WPA_NONCE_LEN) < 0) {\n        sha256_update(&(sha_ctx.ctx), anonce, AIRPDCAP_WPA_NONCE_LEN);\n        sha256_update(&(sha_ctx.ctx), snonce, AIRPDCAP_WPA_NONCE_LEN);\n    } else {\n        sha256_update(&(sha_ctx.ctx), snonce, AIRPDCAP_WPA_NONCE_LEN);\n        sha256_update(&(sha_ctx.ctx), anonce, AIRPDCAP_WPA_NONCE_LEN);\n    }\n    sha256_finish(&(sha_ctx.ctx), key_input);\n\n    /* Derive key */\n    bssid = &data[offset_link + 2];\n    initiator = &data[offset_link + 8];\n    responder = &data[offset_link + 14];\n    sha256_hmac_starts(&sha_ctx, key_input, SHA256_DIGEST_LEN);\n    iter[0] = 1;\n    iter[1] = 0;\n    sha256_hmac_update(&sha_ctx, (const guint8 *)&iter, 2);\n    sha256_hmac_update(&sha_ctx, \"TDLS PMK\", 8);\n    if (memcmp(initiator, responder, AIRPDCAP_MAC_LEN) < 0) {\n        sha256_hmac_update(&sha_ctx, initiator, AIRPDCAP_MAC_LEN);\n        sha256_hmac_update(&sha_ctx, responder, AIRPDCAP_MAC_LEN);\n    } else {\n        sha256_hmac_update(&sha_ctx, responder, AIRPDCAP_MAC_LEN);\n        sha256_hmac_update(&sha_ctx, initiator, AIRPDCAP_MAC_LEN);\n    }\n    sha256_hmac_update(&sha_ctx, bssid, AIRPDCAP_MAC_LEN);\n    length[0] = 256 & 0xff;\n    length[1] = (256 >> 8) & 0xff;\n    sha256_hmac_update(&sha_ctx, (const guint8 *)&length, 2);\n    sha256_hmac_finish(&sha_ctx, key_input);\n\n    /* Check MIC */\n    aes_cmac_encrypt_starts(&aes_ctx, key_input, 16);\n    aes_cmac_encrypt_update(&aes_ctx, initiator, AIRPDCAP_MAC_LEN);\n    aes_cmac_encrypt_update(&aes_ctx, responder, AIRPDCAP_MAC_LEN);\n    aes_cmac_encrypt_update(&aes_ctx, &seq_num, 1);\n    aes_cmac_encrypt_update(&aes_ctx, &data[offset_link], data[offset_link + 1] + 2);\n    aes_cmac_encrypt_update(&aes_ctx, &data[offset_rsne], data[offset_rsne + 1] + 2);\n    aes_cmac_encrypt_update(&aes_ctx, &data[offset_timeout], data[offset_timeout + 1] + 2);\n    aes_cmac_encrypt_update(&aes_ctx, &data[offset_fte], 4);\n    memset(mic, 0, 16);\n    aes_cmac_encrypt_update(&aes_ctx, mic, 16);\n    aes_cmac_encrypt_update(&aes_ctx, &data[offset_fte + 20], data[offset_fte + 1] + 2 - 20);\n    aes_cmac_encrypt_finish(&aes_ctx, mic);\n\n    if (memcmp(mic, &data[offset_fte + 4],16)) {\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapTDLSDeriveKey\", \"MIC verification failed\", AIRPDCAP_DEBUG_LEVEL_3);\n        return AIRPDCAP_RET_UNSUCCESS;\n    }\n\n    memcpy(AIRPDCAP_GET_TK(sa->wpa.ptk), &key_input[16], 16);\n    memcpy(sa->wpa.nonce, snonce, AIRPDCAP_WPA_NONCE_LEN);\n    sa->validKey = TRUE;\n    sa->wpa.key_ver = AIRPDCAP_WPA_KEY_VER_AES_CCMP;\n    AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapTDLSDeriveKey\", \"MIC verified\", AIRPDCAP_DEBUG_LEVEL_3);\n    return  AIRPDCAP_RET_SUCCESS;\n}\n\n\n#ifdef __cplusplus\n}\n#endif\n\n/****************************************************************************/\n\n/*\n * Editor modelines\n *\n * Local Variables:\n * c-basic-offset: 4\n * tab-width: 8\n * indent-tabs-mode: nil\n * End:\n *\n * ex: set shiftwidth=4 tabstop=8 expandtab:\n * :indentSize=4:tabSize=8:noTabs=true:\n */\n", "code_before": "/* airpdcap.c\n *\n * Copyright (c) 2006 CACE Technologies, Davis (California)\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the project nor the names of its contributors\n *    may be used to endorse or promote products derived from this software\n *    without specific prior written permission.\n *\n * Alternatively, this software may be distributed under the terms of the\n * GNU General Public License (\"GPL\") version 2 as published by the Free\n * Software Foundation.\n *\n * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n\n/*\n * The files matching airpcap*.[ch] were originally developed as part of\n * Wireshark's support for AirPcap adapters. However, they've been used\n * for general 802.11 decryption for quite some time. It might make sense\n * to rename them accordingly.\n */\n\n/****************************************************************************/\n/*      File includes                                                       */\n\n#include \"config.h\"\n\n#include <glib.h>\n\n#include <wsutil/wsgcrypt.h>\n#include <wsutil/crc32.h>\n#include <wsutil/pint.h>\n\n#include <epan/tvbuff.h>\n#include <epan/to_str.h>\n#include <epan/strutil.h>\n#include <epan/crypt/airpdcap_rijndael.h>\n\n#include \"airpdcap_system.h\"\n#include \"airpdcap_int.h\"\n\n#include \"airpdcap_debug.h\"\n\n#include \"wep-wpadefs.h\"\n\n\n/****************************************************************************/\n\n/****************************************************************************/\n/*      Constant definitions                                                    */\n\n/*      EAPOL definitions                                                       */\n/**\n * Length of the EAPOL-Key key confirmation key (KCK) used to calculate\n * MIC over EAPOL frame and validate an EAPOL packet (128 bits)\n */\n#define AIRPDCAP_WPA_KCK_LEN    16\n/**\n *Offset of the Key MIC in the EAPOL packet body\n */\n#define AIRPDCAP_WPA_MICKEY_OFFSET      77\n/**\n * Maximum length of the EAPOL packet (it depends on the maximum MAC\n * frame size)\n */\n#define AIRPDCAP_WPA_MAX_EAPOL_LEN      4095\n/**\n * EAPOL Key Descriptor Version 1, used for all EAPOL-Key frames to and\n * from a STA when neither the group nor pairwise ciphers are CCMP for\n * Key Descriptor 1.\n * @note\n * Defined in 802.11i-2004, page 78\n */\n#define AIRPDCAP_WPA_KEY_VER_NOT_CCMP   1\n/**\n * EAPOL Key Descriptor Version 2, used for all EAPOL-Key frames to and\n * from a STA when either the pairwise or the group cipher is AES-CCMP\n * for Key Descriptor 2.\n * /note\n * Defined in 802.11i-2004, page 78\n */\n#define AIRPDCAP_WPA_KEY_VER_AES_CCMP   2\n\n/** Define EAPOL Key Descriptor type values:  use 254 for WPA and 2 for WPA2 **/\n#define AIRPDCAP_RSN_WPA_KEY_DESCRIPTOR 254\n#define AIRPDCAP_RSN_WPA2_KEY_DESCRIPTOR 2\n\n/****************************************************************************/\n\n\n\n/****************************************************************************/\n/*      Macro definitions                                                       */\n\nextern const UINT32 crc32_table[256];\n#define CRC(crc, ch)     (crc = (crc >> 8) ^ crc32_table[(crc ^ (ch)) & 0xff])\n\n#define AIRPDCAP_GET_TK(ptk)    (ptk + 32)\n\n/****************************************************************************/\n\n/****************************************************************************/\n/*      Type definitions                                                        */\n\n/*      Internal function prototype declarations                                */\n\n#ifdef  __cplusplus\nextern \"C\" {\n#endif\n\n/**\n * It is a step of the PBKDF2 (specifically the PKCS #5 v2.0) defined in\n * the RFC 2898 to derive a key (used as PMK in WPA)\n * @param ppbytes [IN] pointer to a password (sequence of between 8 and\n * 63 ASCII encoded characters)\n * @param ssid [IN] pointer to the SSID string encoded in max 32 ASCII\n * encoded characters\n * @param iterations [IN] times to hash the password (4096 for WPA)\n * @param count [IN] ???\n * @param output [OUT] pointer to a preallocated buffer of\n * SHA1_DIGEST_LEN characters that will contain a part of the key\n */\nstatic INT AirPDcapRsnaPwd2PskStep(\n    const guint8 *ppbytes,\n    const guint passLength,\n    const CHAR *ssid,\n    const size_t ssidLength,\n    const INT iterations,\n    const INT count,\n    UCHAR *output)\n    ;\n\n/**\n * It calculates the passphrase-to-PSK mapping reccomanded for use with\n * RSNAs. This implementation uses the PBKDF2 method defined in the RFC\n * 2898.\n * @param passphrase [IN] pointer to a password (sequence of between 8 and\n * 63 ASCII encoded characters)\n * @param ssid [IN] pointer to the SSID string encoded in max 32 ASCII\n * encoded characters\n * @param output [OUT] calculated PSK (to use as PMK in WPA)\n * @note\n * Described in 802.11i-2004, page 165\n */\nstatic INT AirPDcapRsnaPwd2Psk(\n    const CHAR *passphrase,\n    const CHAR *ssid,\n    const size_t ssidLength,\n    UCHAR *output)\n    ;\n\nstatic INT AirPDcapRsnaMng(\n    UCHAR *decrypt_data,\n    guint mac_header_len,\n    guint *decrypt_len,\n    PAIRPDCAP_KEY_ITEM key,\n    AIRPDCAP_SEC_ASSOCIATION *sa,\n    INT offset)\n    ;\n\nstatic INT AirPDcapWepMng(\n    PAIRPDCAP_CONTEXT ctx,\n    UCHAR *decrypt_data,\n    guint mac_header_len,\n    guint *decrypt_len,\n    PAIRPDCAP_KEY_ITEM key,\n    AIRPDCAP_SEC_ASSOCIATION *sa,\n    INT offset)\n    ;\n\nstatic INT AirPDcapRsna4WHandshake(\n    PAIRPDCAP_CONTEXT ctx,\n    const UCHAR *data,\n    AIRPDCAP_SEC_ASSOCIATION *sa,\n    INT offset,\n    const guint tot_len)\n    ;\n/**\n * It checks whether the specified key is corrected or not.\n * @note\n * For a standard WEP key the length will be changed to the standard\n * length, and the type changed in a generic WEP key.\n * @param key [IN] pointer to the key to validate\n * @return\n * - TRUE: the key contains valid fields and values\n * - FALSE: the key has some invalid field or value\n */\nstatic INT AirPDcapValidateKey(\n    PAIRPDCAP_KEY_ITEM key)\n    ;\n\nstatic INT AirPDcapRsnaMicCheck(\n    UCHAR *eapol,\n    USHORT eapol_len,\n    UCHAR KCK[AIRPDCAP_WPA_KCK_LEN],\n    USHORT key_ver)\n    ;\n\n/**\n * @param ctx [IN] pointer to the current context\n * @param id [IN] id of the association (composed by BSSID and MAC of\n * the station)\n * @return\n * - index of the Security Association structure if found\n * - -1, if the specified addresses pair BSSID-STA MAC has not been found\n */\nstatic INT AirPDcapGetSa(\n    PAIRPDCAP_CONTEXT ctx,\n    AIRPDCAP_SEC_ASSOCIATION_ID *id)\n    ;\n\nstatic INT AirPDcapStoreSa(\n    PAIRPDCAP_CONTEXT ctx,\n    AIRPDCAP_SEC_ASSOCIATION_ID *id)\n    ;\n\nstatic INT AirPDcapGetSaAddress(\n    const AIRPDCAP_MAC_FRAME_ADDR4 *frame,\n    AIRPDCAP_SEC_ASSOCIATION_ID *id)\n    ;\n\nstatic const UCHAR * AirPDcapGetStaAddress(\n    const AIRPDCAP_MAC_FRAME_ADDR4 *frame)\n    ;\n\nstatic const UCHAR * AirPDcapGetBssidAddress(\n    const AIRPDCAP_MAC_FRAME_ADDR4 *frame)\n    ;\n\nstatic void AirPDcapRsnaPrfX(\n    AIRPDCAP_SEC_ASSOCIATION *sa,\n    const UCHAR pmk[32],\n    const UCHAR snonce[32],\n    const INT x,        /*      for TKIP 512, for CCMP 384      */\n    UCHAR *ptk)\n    ;\n\n\n/**\n * @param sa  [IN/OUT] pointer to SA that will hold the key\n * @param data [IN] Frame\n * @param offset_rsne [IN] RSNE IE offset in the frame\n * @param offset_fte [IN] Fast BSS Transition IE offset in the frame\n * @param offset_timeout [IN] Timeout Interval IE offset in the frame\n * @param offset_link [IN] Link Identifier IE offset in the frame\n * @param action [IN] Tdls Action code (response or confirm)\n *\n * @return\n *  AIRPDCAP_RET_SUCCESS if Key has been sucessfully derived (and MIC verified)\n *  AIRPDCAP_RET_UNSUCCESS otherwise\n */\nstatic INT\nAirPDcapTDLSDeriveKey(\n    PAIRPDCAP_SEC_ASSOCIATION sa,\n    const guint8 *data,\n    guint offset_rsne,\n    guint offset_fte,\n    guint offset_timeout,\n    guint offset_link,\n    guint8 action)\n    ;\n#ifdef  __cplusplus\n}\n#endif\n\n/****************************************************************************/\n\n/****************************************************************************/\n/* Exported function definitions                                                */\n\n#ifdef  __cplusplus\nextern \"C\" {\n#endif\n\nconst guint8 broadcast_mac[] = { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF };\n\n#define EAPKEY_MIC_LEN  16  /* length of the MIC key for EAPoL_Key packet's MIC using MD5 */\n#define NONCE_LEN 32\n\n#define TKIP_GROUP_KEY_LEN 32\n#define CCMP_GROUP_KEY_LEN 16\n\ntypedef struct {\n    guint8  type;\n    guint8  key_information[2];  /* Make this an array to avoid alignment issues */\n    guint8  key_length[2];  /* Make this an array to avoid alignment issues */\n    guint8  replay_counter[8];\n    guint8  key_nonce[NONCE_LEN];\n    guint8  key_iv[16];\n    guint8  key_sequence_counter[8];  /* also called the RSC */\n    guint8  key_id[8];\n    guint8  key_mic[EAPKEY_MIC_LEN];\n    guint8  key_data_len[2];  /* Make this an array rather than a U16 to avoid alignment shifting */\n} EAPOL_RSN_KEY,  * P_EAPOL_RSN_KEY;\n\n/* Minimum possible key data size (at least one GTK KDE with CCMP key) */\n#define GROUP_KEY_MIN_LEN 8 + CCMP_GROUP_KEY_LEN\n/* Minimum possible group key msg size (group key msg using CCMP as cipher)*/\n#define GROUP_KEY_PAYLOAD_LEN_MIN sizeof(EAPOL_RSN_KEY) + GROUP_KEY_MIN_LEN\n\n/* XXX - what if this doesn't get the key? */\nstatic INT\nAirPDcapDecryptWPABroadcastKey(const EAPOL_RSN_KEY *pEAPKey, guint8 *decryption_key, PAIRPDCAP_SEC_ASSOCIATION sa, guint eapol_len)\n{\n    guint8 key_version;\n    const guint8 *key_data;\n    guint8  *szEncryptedKey;\n    guint16 key_bytes_len = 0; /* Length of the total key data field */\n    guint16 key_len;           /* Actual group key length */\n    static AIRPDCAP_KEY_ITEM dummy_key; /* needed in case AirPDcapRsnaMng() wants the key structure */\n    AIRPDCAP_SEC_ASSOCIATION *tmp_sa;\n\n    /* We skip verifying the MIC of the key. If we were implementing a WPA supplicant we'd want to verify, but for a sniffer it's not needed. */\n\n    /* Preparation for decrypting the group key -  determine group key data length */\n    /* depending on whether the pairwise key is TKIP or AES encryption key */\n    key_version = AIRPDCAP_EAP_KEY_DESCR_VER(pEAPKey->key_information[1]);\n    if (key_version == AIRPDCAP_WPA_KEY_VER_NOT_CCMP){\n        /* TKIP */\n        key_bytes_len = pntoh16(pEAPKey->key_length);\n    }else if (key_version == AIRPDCAP_WPA_KEY_VER_AES_CCMP){\n        /* AES */\n        key_bytes_len = pntoh16(pEAPKey->key_data_len);\n\n        /* AES keys must be at least 128 bits = 16 bytes. */\n        if (key_bytes_len < 16) {\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n        }\n    }\n\n    if ((key_bytes_len < GROUP_KEY_MIN_LEN) ||\n        (eapol_len < sizeof(EAPOL_RSN_KEY)) ||\n        (key_bytes_len > eapol_len - sizeof(EAPOL_RSN_KEY))) {\n        return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n    }\n\n    /* Encrypted key is in the information element field of the EAPOL key packet */\n    key_data = (const guint8 *)pEAPKey + sizeof(EAPOL_RSN_KEY);\n    szEncryptedKey = (guint8 *)g_memdup(key_data, key_bytes_len);\n\n    DEBUG_DUMP(\"Encrypted Broadcast key:\", szEncryptedKey, key_bytes_len);\n    DEBUG_DUMP(\"KeyIV:\", pEAPKey->key_iv, 16);\n    DEBUG_DUMP(\"decryption_key:\", decryption_key, 16);\n\n    /* We are rekeying, save old sa */\n    tmp_sa=(AIRPDCAP_SEC_ASSOCIATION *)g_malloc(sizeof(AIRPDCAP_SEC_ASSOCIATION));\n    memcpy(tmp_sa, sa, sizeof(AIRPDCAP_SEC_ASSOCIATION));\n    sa->next=tmp_sa;\n\n    /* As we have no concept of the prior association request at this point, we need to deduce the     */\n    /* group key cipher from the length of the key bytes. In WPA this is straightforward as the        */\n    /* keybytes just contain the GTK, and the GTK is only in the group handshake, NOT the M3.          */\n    /* In WPA2 its a little more tricky as the M3 keybytes contain an RSN_IE, but the group handshake  */\n    /* does not. Also there are other (variable length) items in the keybytes which we need to account */\n    /* for to determine the true key length, and thus the group cipher.                                */\n\n    if (key_version == AIRPDCAP_WPA_KEY_VER_NOT_CCMP){\n        guint8 new_key[32];\n        guint8 dummy[256] = { 0 };\n        /* TKIP key */\n        /* Per 802.11i, Draft 3.0 spec, section 8.5.2, p. 97, line 4-8, */\n        /* group key is decrypted using RC4.  Concatenate the IV with the 16 byte EK (PTK+16) to get the decryption key */\n\n        gcry_cipher_hd_t  rc4_handle;\n\n        /* The WPA group key just contains the GTK bytes so deducing the type is straightforward   */\n        /* Note - WPA M3 doesn't contain a group key so we'll only be here for the group handshake */\n        sa->wpa.key_ver = (key_bytes_len >=TKIP_GROUP_KEY_LEN)?AIRPDCAP_WPA_KEY_VER_NOT_CCMP:AIRPDCAP_WPA_KEY_VER_AES_CCMP;\n\n        /* Build the full decryption key based on the IV and part of the pairwise key */\n        memcpy(new_key, pEAPKey->key_iv, 16);\n        memcpy(new_key+16, decryption_key, 16);\n        DEBUG_DUMP(\"FullDecrKey:\", new_key, 32);\n\n        if (gcry_cipher_open (&rc4_handle, GCRY_CIPHER_ARCFOUR, GCRY_CIPHER_MODE_STREAM, 0)) {\n          return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n        }\n        if (gcry_cipher_setkey(rc4_handle, new_key, sizeof(new_key))) {\n          gcry_cipher_close(rc4_handle);\n          return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n        }\n\n        /* Do dummy 256 iterations of the RC4 algorithm (per 802.11i, Draft 3.0, p. 97 line 6) */\n        gcry_cipher_decrypt(rc4_handle, dummy, 256, NULL, 0);\n        gcry_cipher_decrypt(rc4_handle, szEncryptedKey, key_bytes_len, NULL, 0);\n        gcry_cipher_close(rc4_handle);\n\n    } else if (key_version == AIRPDCAP_WPA_KEY_VER_AES_CCMP){\n        /* AES CCMP key */\n\n        guint8 key_found;\n        guint8 key_length;\n        guint16 key_index;\n        guint8 *decrypted_data;\n\n        /* Unwrap the key; the result is key_bytes_len in length */\n        decrypted_data = AES_unwrap(decryption_key, 16, szEncryptedKey,  key_bytes_len);\n\n        /* With WPA2 what we get after Broadcast Key decryption is an actual RSN structure.\n           The key itself is stored as a GTK KDE\n           WPA2 IE (1 byte) id = 0xdd, length (1 byte), GTK OUI (4 bytes), key index (1 byte) and 1 reserved byte. Thus we have to\n           pass pointer to the actual key with 8 bytes offset */\n\n        key_found = FALSE;\n        key_index = 0;\n\n        /* Parse Key data until we found GTK KDE */\n        /* GTK KDE = 00-0F-AC 01 */\n        while(key_index < (key_bytes_len - 6) && !key_found){\n            guint8 rsn_id;\n            guint32 type;\n\n            /* Get RSN ID */\n            rsn_id = decrypted_data[key_index];\n            type = ((decrypted_data[key_index + 2] << 24) +\n                    (decrypted_data[key_index + 3] << 16) +\n                    (decrypted_data[key_index + 4] << 8) +\n                     (decrypted_data[key_index + 5]));\n\n            if (rsn_id == 0xdd && type == 0x000fac01) {\n                key_found = TRUE;\n            } else {\n                key_index += decrypted_data[key_index+1]+2;\n            }\n        }\n\n        if (key_found){\n            if (decrypted_data[key_index+1] <= 6) {\n                g_free(decrypted_data);\n                g_free(szEncryptedKey);\n                return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n            }\n            key_length = decrypted_data[key_index+1] - 6;\n\n            if (key_index+8 >= key_bytes_len ||\n                key_length > key_bytes_len - key_index - 8) {\n                g_free(decrypted_data);\n                g_free(szEncryptedKey);\n                return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n            }\n\n            /* Skip over the GTK header info, and don't copy past the end of the encrypted data */\n            memcpy(szEncryptedKey, decrypted_data+key_index+8, key_length);\n        } else {\n            g_free(decrypted_data);\n            g_free(szEncryptedKey);\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n        }\n\n        if (key_length == TKIP_GROUP_KEY_LEN)\n            sa->wpa.key_ver = AIRPDCAP_WPA_KEY_VER_NOT_CCMP;\n        else\n            sa->wpa.key_ver = AIRPDCAP_WPA_KEY_VER_AES_CCMP;\n\n        g_free(decrypted_data);\n    }\n\n    key_len = (sa->wpa.key_ver==AIRPDCAP_WPA_KEY_VER_NOT_CCMP)?TKIP_GROUP_KEY_LEN:CCMP_GROUP_KEY_LEN;\n    if (key_len > key_bytes_len) {\n        /* the key required for this protocol is longer than the key that we just calculated */\n        g_free(szEncryptedKey);\n        return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n    }\n\n    /* Decrypted key is now in szEncryptedKey with len of key_len */\n    DEBUG_DUMP(\"Broadcast key:\", szEncryptedKey, key_len);\n\n    /* Load the proper key material info into the SA */\n    sa->key = &dummy_key;  /* we just need key to be not null because it is checked in AirPDcapRsnaMng().  The WPA key materials are actually in the .wpa structure */\n    sa->validKey = TRUE;\n\n    /* Since this is a GTK and its size is only 32 bytes (vs. the 64 byte size of a PTK), we fake it and put it in at a 32-byte offset so the  */\n    /* AirPDcapRsnaMng() function will extract the right piece of the GTK for decryption. (The first 16 bytes of the GTK are used for decryption.) */\n    memset(sa->wpa.ptk, 0, sizeof(sa->wpa.ptk));\n    memcpy(sa->wpa.ptk+32, szEncryptedKey, key_len);\n    g_free(szEncryptedKey);\n    return AIRPDCAP_RET_SUCCESS_HANDSHAKE;\n}\n\n\n/* Return a pointer the the requested SA. If it doesn't exist create it. */\nstatic PAIRPDCAP_SEC_ASSOCIATION\nAirPDcapGetSaPtr(\n    PAIRPDCAP_CONTEXT ctx,\n    AIRPDCAP_SEC_ASSOCIATION_ID *id)\n{\n    int sa_index;\n\n    /* search for a cached Security Association for supplied BSSID and STA MAC  */\n    if ((sa_index=AirPDcapGetSa(ctx, id))==-1) {\n        /* create a new Security Association if it doesn't currently exist      */\n        if ((sa_index=AirPDcapStoreSa(ctx, id))==-1) {\n            return NULL;\n        }\n    }\n    /* get the Security Association structure   */\n    return &ctx->sa[sa_index];\n}\n\nstatic INT AirPDcapScanForKeys(\n    PAIRPDCAP_CONTEXT ctx,\n    const guint8 *data,\n    const guint mac_header_len,\n    const guint tot_len,\n    AIRPDCAP_SEC_ASSOCIATION_ID id\n)\n{\n    const UCHAR *addr;\n    guint bodyLength;\n    PAIRPDCAP_SEC_ASSOCIATION sta_sa;\n    PAIRPDCAP_SEC_ASSOCIATION sa;\n    guint offset = 0;\n    const guint8 dot1x_header[] = {\n        0xAA,             /* DSAP=SNAP */\n        0xAA,             /* SSAP=SNAP */\n        0x03,             /* Control field=Unnumbered frame */\n        0x00, 0x00, 0x00, /* Org. code=encaps. Ethernet */\n        0x88, 0x8E        /* Type: 802.1X authentication */\n    };\n    const guint8 bt_dot1x_header[] = {\n        0xAA,             /* DSAP=SNAP */\n        0xAA,             /* SSAP=SNAP */\n        0x03,             /* Control field=Unnumbered frame */\n        0x00, 0x19, 0x58, /* Org. code=Bluetooth SIG */\n        0x00, 0x03        /* Type: Bluetooth Security */\n    };\n    const guint8 tdls_header[] = {\n        0xAA,             /* DSAP=SNAP */\n        0xAA,             /* SSAP=SNAP */\n        0x03,             /* Control field=Unnumbered frame */\n        0x00, 0x00, 0x00, /* Org. code=encaps. Ethernet */\n        0x89, 0x0D,       /* Type: 802.11 - Fast Roaming Remote Request */\n        0x02,             /* Payload Type: TDLS */\n        0X0C              /* Action Category: TDLS */\n    };\n\n    const EAPOL_RSN_KEY *pEAPKey;\n#ifdef AIRPDCAP_DEBUG\n#define MSGBUF_LEN 255\n    CHAR msgbuf[MSGBUF_LEN];\n#endif\n    AIRPDCAP_DEBUG_TRACE_START(\"AirPDcapScanForKeys\");\n\n    /* cache offset in the packet data */\n    offset = mac_header_len;\n\n    /* check if the packet has an LLC header and the packet is 802.1X authentication (IEEE 802.1X-2004, pg. 24) */\n    if (memcmp(data+offset, dot1x_header, 8) == 0 || memcmp(data+offset, bt_dot1x_header, 8) == 0) {\n\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Authentication: EAPOL packet\", AIRPDCAP_DEBUG_LEVEL_3);\n\n        /* skip LLC header */\n        offset+=8;\n\n        /* check if the packet is a EAPOL-Key (0x03) (IEEE 802.1X-2004, pg. 25) */\n        if (data[offset+1]!=3) {\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Not EAPOL-Key\", AIRPDCAP_DEBUG_LEVEL_3);\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n        }\n\n        /* get and check the body length (IEEE 802.1X-2004, pg. 25) */\n        bodyLength=pntoh16(data+offset+2);\n        if (((tot_len-offset-4) < bodyLength) || (bodyLength < sizeof(EAPOL_RSN_KEY))) { /* Only check if frame is long enough for eapol header, ignore tailing garbage, see bug 9065 */\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"EAPOL body too short\", AIRPDCAP_DEBUG_LEVEL_3);\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n        }\n\n        /* skip EAPOL MPDU and go to the first byte of the body */\n        offset+=4;\n\n        pEAPKey = (const EAPOL_RSN_KEY *) (data+offset);\n\n        /* check if the key descriptor type is valid (IEEE 802.1X-2004, pg. 27) */\n        if (/*pEAPKey->type!=0x1 &&*/ /* RC4 Key Descriptor Type (deprecated) */\n            pEAPKey->type != AIRPDCAP_RSN_WPA2_KEY_DESCRIPTOR &&             /* IEEE 802.11 Key Descriptor Type  (WPA2) */\n            pEAPKey->type != AIRPDCAP_RSN_WPA_KEY_DESCRIPTOR)           /* 254 = RSN_KEY_DESCRIPTOR - WPA,              */\n        {\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Not valid key descriptor type\", AIRPDCAP_DEBUG_LEVEL_3);\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n        }\n\n        /* start with descriptor body */\n        offset+=1;\n\n        /* search for a cached Security Association for current BSSID and AP */\n        sa = AirPDcapGetSaPtr(ctx, &id);\n        if (sa == NULL){\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"No SA for BSSID found\", AIRPDCAP_DEBUG_LEVEL_3);\n            return AIRPDCAP_RET_REQ_DATA;\n        }\n\n        /* It could be a Pairwise Key exchange, check */\n        if (AirPDcapRsna4WHandshake(ctx, data, sa, offset, tot_len) == AIRPDCAP_RET_SUCCESS_HANDSHAKE)\n            return AIRPDCAP_RET_SUCCESS_HANDSHAKE;\n\n        if (mac_header_len + GROUP_KEY_PAYLOAD_LEN_MIN > tot_len) {\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Message too short for Group Key\", AIRPDCAP_DEBUG_LEVEL_3);\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n        }\n\n        /* Verify the bitfields: Key = 0(groupwise) Mic = 1 Ack = 1 Secure = 1 */\n        if (AIRPDCAP_EAP_KEY(data[offset+1])!=0 ||\n            AIRPDCAP_EAP_ACK(data[offset+1])!=1 ||\n            AIRPDCAP_EAP_MIC(data[offset]) != 1 ||\n            AIRPDCAP_EAP_SEC(data[offset]) != 1){\n\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Key bitfields not correct for Group Key\", AIRPDCAP_DEBUG_LEVEL_3);\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n        }\n\n        /* force STA address to be the broadcast MAC so we create an SA for the groupkey */\n        memcpy(id.sta, broadcast_mac, AIRPDCAP_MAC_LEN);\n\n        /* get the Security Association structure for the broadcast MAC and AP */\n        sa = AirPDcapGetSaPtr(ctx, &id);\n        if (sa == NULL){\n            return AIRPDCAP_RET_REQ_DATA;\n        }\n\n        /* Get the SA for the STA, since we need its pairwise key to decrpyt the group key */\n\n        /* get STA address */\n        if ( (addr=AirPDcapGetStaAddress((const AIRPDCAP_MAC_FRAME_ADDR4 *)(data))) != NULL) {\n            memcpy(id.sta, addr, AIRPDCAP_MAC_LEN);\n#ifdef AIRPDCAP_DEBUG\n            g_snprintf(msgbuf, MSGBUF_LEN, \"ST_MAC: %2X.%2X.%2X.%2X.%2X.%2X\\t\", id.sta[0],id.sta[1],id.sta[2],id.sta[3],id.sta[4],id.sta[5]);\n#endif\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", msgbuf, AIRPDCAP_DEBUG_LEVEL_3);\n        } else {\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"SA not found\", AIRPDCAP_DEBUG_LEVEL_5);\n            return AIRPDCAP_RET_REQ_DATA;\n        }\n\n        sta_sa = AirPDcapGetSaPtr(ctx, &id);\n        if (sta_sa == NULL){\n            return AIRPDCAP_RET_REQ_DATA;\n        }\n\n        /* Try to extract the group key and install it in the SA */\n        return (AirPDcapDecryptWPABroadcastKey(pEAPKey, sta_sa->wpa.ptk+16, sa, tot_len-offset+1));\n\n    } else if (memcmp(data+offset, tdls_header, 10) == 0) {\n        const guint8 *initiator, *responder;\n        guint8 action;\n        guint status, offset_rsne = 0, offset_fte = 0, offset_link = 0, offset_timeout = 0;\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Authentication: TDLS Action Frame\", AIRPDCAP_DEBUG_LEVEL_3);\n\n        /* skip LLC header */\n        offset+=10;\n\n        /* check if the packet is a TDLS response or confirm */\n        action = data[offset];\n        if (action!=1 && action!=2) {\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Not Response nor confirm\", AIRPDCAP_DEBUG_LEVEL_3);\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n        }\n\n        /* check status */\n        offset++;\n        status=pntoh16(data+offset);\n        if (status!=0) {\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"TDLS setup not successfull\", AIRPDCAP_DEBUG_LEVEL_3);\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n        }\n\n        /* skip Token + capabilities */\n        offset+=5;\n\n        /* search for RSN, Fast BSS Transition, Link Identifier and Timeout Interval IEs */\n\n        while(offset < (tot_len - 2)) {\n            if (data[offset] == 48) {\n                offset_rsne = offset;\n            } else if (data[offset] == 55) {\n                offset_fte = offset;\n            } else if (data[offset] == 56) {\n                offset_timeout = offset;\n            } else if (data[offset] == 101) {\n                offset_link = offset;\n            }\n\n            if (tot_len < offset + data[offset + 1] + 2) {\n                return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n            }\n            offset += data[offset + 1] + 2;\n        }\n\n        if (offset_rsne == 0 || offset_fte == 0 ||\n            offset_timeout == 0 || offset_link == 0)\n        {\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Cannot Find all necessary IEs\", AIRPDCAP_DEBUG_LEVEL_3);\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n        }\n\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Found RSNE/Fast BSS/Timeout Interval/Link IEs\", AIRPDCAP_DEBUG_LEVEL_3);\n\n        /* Will create a Security Association between 2 STA. Need to get both MAC address */\n        initiator = &data[offset_link + 8];\n        responder = &data[offset_link + 14];\n\n        if (memcmp(initiator, responder, AIRPDCAP_MAC_LEN) < 0) {\n            memcpy(id.sta, initiator, AIRPDCAP_MAC_LEN);\n            memcpy(id.bssid, responder, AIRPDCAP_MAC_LEN);\n        } else {\n            memcpy(id.sta, responder, AIRPDCAP_MAC_LEN);\n            memcpy(id.bssid, initiator, AIRPDCAP_MAC_LEN);\n        }\n\n        sa = AirPDcapGetSaPtr(ctx, &id);\n        if (sa == NULL){\n            return AIRPDCAP_RET_REQ_DATA;\n        }\n\n        if (sa->validKey) {\n            if (memcmp(sa->wpa.nonce, data + offset_fte + 52, AIRPDCAP_WPA_NONCE_LEN) == 0) {\n                /* Already have valid key for this SA, no need to redo key derivation */\n                return AIRPDCAP_RET_SUCCESS_HANDSHAKE;\n            } else {\n                /* We are opening a new session with the same two STA, save previous sa  */\n                AIRPDCAP_SEC_ASSOCIATION *tmp_sa = g_new(AIRPDCAP_SEC_ASSOCIATION, 1);\n                memcpy(tmp_sa, sa, sizeof(AIRPDCAP_SEC_ASSOCIATION));\n                sa->next=tmp_sa;\n                sa->validKey = FALSE;\n            }\n        }\n\n        if (AirPDcapTDLSDeriveKey(sa, data, offset_rsne, offset_fte, offset_timeout, offset_link, action)\n            == AIRPDCAP_RET_SUCCESS) {\n            AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapScanForKeys\");\n            return AIRPDCAP_RET_SUCCESS_HANDSHAKE;\n        }\n    } else {\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Skipping: not an EAPOL packet\", AIRPDCAP_DEBUG_LEVEL_3);\n    }\n\n    AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapScanForKeys\");\n    return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n}\n\n\nINT AirPDcapPacketProcess(\n    PAIRPDCAP_CONTEXT ctx,\n    const guint8 *data,\n    const guint mac_header_len,\n    const guint tot_len,\n    UCHAR *decrypt_data,\n    guint *decrypt_len,\n    PAIRPDCAP_KEY_ITEM key,\n    gboolean scanHandshake)\n{\n    AIRPDCAP_SEC_ASSOCIATION_ID id;\n    UCHAR tmp_data[AIRPDCAP_MAX_CAPLEN];\n    guint tmp_len;\n\n#ifdef AIRPDCAP_DEBUG\n#define MSGBUF_LEN 255\n    CHAR msgbuf[MSGBUF_LEN];\n#endif\n\n    AIRPDCAP_DEBUG_TRACE_START(\"AirPDcapPacketProcess\");\n\n    if (ctx==NULL) {\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapPacketProcess\", \"NULL context\", AIRPDCAP_DEBUG_LEVEL_5);\n        AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapPacketProcess\");\n        return AIRPDCAP_RET_REQ_DATA;\n    }\n    if (data==NULL || tot_len==0) {\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapPacketProcess\", \"NULL data or length=0\", AIRPDCAP_DEBUG_LEVEL_5);\n        AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapPacketProcess\");\n        return AIRPDCAP_RET_REQ_DATA;\n    }\n\n    /* check if the packet is of data or robust managment type */\n    if (!((AIRPDCAP_TYPE(data[0])==AIRPDCAP_TYPE_DATA) ||\n          (AIRPDCAP_TYPE(data[0])==AIRPDCAP_TYPE_MANAGEMENT &&\n           (AIRPDCAP_SUBTYPE(data[0])==AIRPDCAP_SUBTYPE_DISASS ||\n            AIRPDCAP_SUBTYPE(data[0])==AIRPDCAP_SUBTYPE_DEAUTHENTICATION ||\n            AIRPDCAP_SUBTYPE(data[0])==AIRPDCAP_SUBTYPE_ACTION)))) {\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapPacketProcess\", \"not data nor robust mgmt packet\", AIRPDCAP_DEBUG_LEVEL_5);\n        return AIRPDCAP_RET_NO_DATA;\n    }\n\n    /* check correct packet size, to avoid wrong elaboration of encryption algorithms */\n    if (tot_len < (UINT)(mac_header_len+AIRPDCAP_CRYPTED_DATA_MINLEN)) {\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapPacketProcess\", \"minimum length violated\", AIRPDCAP_DEBUG_LEVEL_5);\n        return AIRPDCAP_RET_WRONG_DATA_SIZE;\n    }\n\n    /* Assume that the decrypt_data field is at least this size. */\n    if (tot_len > AIRPDCAP_MAX_CAPLEN) {\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapPacketProcess\", \"length too large\", AIRPDCAP_DEBUG_LEVEL_3);\n        return AIRPDCAP_RET_UNSUCCESS;\n    }\n\n    /* get STA/BSSID address */\n    if (AirPDcapGetSaAddress((const AIRPDCAP_MAC_FRAME_ADDR4 *)(data), &id) != AIRPDCAP_RET_SUCCESS) {\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapPacketProcess\", \"STA/BSSID not found\", AIRPDCAP_DEBUG_LEVEL_5);\n        return AIRPDCAP_RET_REQ_DATA;\n    }\n\n    /* check if data is encrypted (use the WEP bit in the Frame Control field) */\n    if (AIRPDCAP_WEP(data[1])==0) {\n        if (scanHandshake) {\n            /* data is sent in cleartext, check if is an authentication message or end the process */\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapPacketProcess\", \"Unencrypted data\", AIRPDCAP_DEBUG_LEVEL_3);\n            return (AirPDcapScanForKeys(ctx, data, mac_header_len, tot_len, id));\n        }\n        return AIRPDCAP_RET_NO_DATA_ENCRYPTED;\n    } else {\n        PAIRPDCAP_SEC_ASSOCIATION sa;\n        int offset = 0;\n\n        /* get the Security Association structure for the STA and AP */\n        sa = AirPDcapGetSaPtr(ctx, &id);\n        if (sa == NULL){\n            return AIRPDCAP_RET_REQ_DATA;\n        }\n\n        /* cache offset in the packet data (to scan encryption data) */\n        offset = mac_header_len;\n\n        if (decrypt_data==NULL) {\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapPacketProcess\", \"no decrypt buffer, use local\", AIRPDCAP_DEBUG_LEVEL_3);\n            decrypt_data=tmp_data;\n            decrypt_len=&tmp_len;\n        }\n\n        /* create new header and data to modify */\n        *decrypt_len = tot_len;\n        memcpy(decrypt_data, data, *decrypt_len);\n\n        /* encrypted data */\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapPacketProcess\", \"Encrypted data\", AIRPDCAP_DEBUG_LEVEL_3);\n\n        /* check the Extension IV to distinguish between WEP encryption and WPA encryption */\n        /* refer to IEEE 802.11i-2004, 8.2.1.2, pag.35 for WEP,    */\n        /*          IEEE 802.11i-2004, 8.3.2.2, pag. 45 for TKIP,  */\n        /*          IEEE 802.11i-2004, 8.3.3.2, pag. 57 for CCMP   */\n        if (AIRPDCAP_EXTIV(data[offset+3])==0) {\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapPacketProcess\", \"WEP encryption\", AIRPDCAP_DEBUG_LEVEL_3);\n            return AirPDcapWepMng(ctx, decrypt_data, mac_header_len, decrypt_len, key, sa, offset);\n        } else {\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapPacketProcess\", \"TKIP or CCMP encryption\", AIRPDCAP_DEBUG_LEVEL_3);\n\n            /* If index >= 1, then use the group key.  This will not work if the AP is using\n               more than one group key simultaneously.  I've not seen this in practice, however.\n               Usually an AP will rotate between the two key index values of 1 and 2 whenever\n               it needs to change the group key to be used. */\n            if (AIRPDCAP_KEY_INDEX(data[offset+3])>=1){\n\n                AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapPacketProcess\", \"The key index >= 1. This is encrypted with a group key.\", AIRPDCAP_DEBUG_LEVEL_3);\n\n                /* force STA address to broadcast MAC so we load the SA for the groupkey */\n                memcpy(id.sta, broadcast_mac, AIRPDCAP_MAC_LEN);\n\n#ifdef AIRPDCAP_DEBUG\n                g_snprintf(msgbuf, MSGBUF_LEN, \"ST_MAC: %2X.%2X.%2X.%2X.%2X.%2X\\t\", id.sta[0],id.sta[1],id.sta[2],id.sta[3],id.sta[4],id.sta[5]);\n                AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapPacketProcess\", msgbuf, AIRPDCAP_DEBUG_LEVEL_3);\n#endif\n\n                /* search for a cached Security Association for current BSSID and broadcast MAC */\n                sa = AirPDcapGetSaPtr(ctx, &id);\n                if (sa == NULL)\n                    return AIRPDCAP_RET_REQ_DATA;\n            }\n\n            /* Decrypt the packet using the appropriate SA */\n            if (AirPDcapRsnaMng(decrypt_data, mac_header_len, decrypt_len, key, sa, offset) == AIRPDCAP_RET_SUCCESS) {\n                /* If we successfully decrypted a packet, scan it to see if it contains a key handshake.\n                   The group key handshake could be sent at any time the AP wants to change the key (such as when\n                   it is using key rotation) and it also could be a rekey for the Pairwise key. So we must scan every packet. */\n                if (scanHandshake) {\n                    return (AirPDcapScanForKeys(ctx, decrypt_data, mac_header_len, *decrypt_len, id));\n                } else {\n                    return AIRPDCAP_RET_SUCCESS;\n                }\n            }\n        }\n    }\n    return AIRPDCAP_RET_UNSUCCESS;\n}\n\nINT AirPDcapSetKeys(\n    PAIRPDCAP_CONTEXT ctx,\n    AIRPDCAP_KEY_ITEM keys[],\n    const size_t keys_nr)\n{\n    INT i;\n    INT success;\n    AIRPDCAP_DEBUG_TRACE_START(\"AirPDcapSetKeys\");\n\n    if (ctx==NULL || keys==NULL) {\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapSetKeys\", \"NULL context or NULL keys array\", AIRPDCAP_DEBUG_LEVEL_3);\n        AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapSetKeys\");\n        return 0;\n    }\n\n    if (keys_nr>AIRPDCAP_MAX_KEYS_NR) {\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapSetKeys\", \"Keys number greater than maximum\", AIRPDCAP_DEBUG_LEVEL_3);\n        AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapSetKeys\");\n        return 0;\n    }\n\n    /* clean key and SA collections before setting new ones */\n    AirPDcapInitContext(ctx);\n\n    /* check and insert keys */\n    for (i=0, success=0; i<(INT)keys_nr; i++) {\n        if (AirPDcapValidateKey(keys+i)==TRUE) {\n            if (keys[i].KeyType==AIRPDCAP_KEY_TYPE_WPA_PWD) {\n                AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapSetKeys\", \"Set a WPA-PWD key\", AIRPDCAP_DEBUG_LEVEL_4);\n                AirPDcapRsnaPwd2Psk(keys[i].UserPwd.Passphrase, keys[i].UserPwd.Ssid, keys[i].UserPwd.SsidLen, keys[i].KeyData.Wpa.Psk);\n            }\n#ifdef AIRPDCAP_DEBUG\n            else if (keys[i].KeyType==AIRPDCAP_KEY_TYPE_WPA_PMK) {\n                AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapSetKeys\", \"Set a WPA-PMK key\", AIRPDCAP_DEBUG_LEVEL_4);\n            } else if (keys[i].KeyType==AIRPDCAP_KEY_TYPE_WEP) {\n                AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapSetKeys\", \"Set a WEP key\", AIRPDCAP_DEBUG_LEVEL_4);\n            } else {\n                AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapSetKeys\", \"Set a key\", AIRPDCAP_DEBUG_LEVEL_4);\n            }\n#endif\n            memcpy(&ctx->keys[success], &keys[i], sizeof(keys[i]));\n            success++;\n        }\n    }\n\n    ctx->keys_nr=success;\n\n    AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapSetKeys\");\n    return success;\n}\n\nstatic void\nAirPDcapCleanKeys(\n    PAIRPDCAP_CONTEXT ctx)\n{\n    AIRPDCAP_DEBUG_TRACE_START(\"AirPDcapCleanKeys\");\n\n    if (ctx==NULL) {\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapCleanKeys\", \"NULL context\", AIRPDCAP_DEBUG_LEVEL_5);\n        AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapCleanKeys\");\n        return;\n    }\n\n    memset(ctx->keys, 0, sizeof(AIRPDCAP_KEY_ITEM) * AIRPDCAP_MAX_KEYS_NR);\n\n    ctx->keys_nr=0;\n\n    AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapCleanKeys\", \"Keys collection cleaned!\", AIRPDCAP_DEBUG_LEVEL_5);\n    AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapCleanKeys\");\n}\n\nstatic void\nAirPDcapRecurseCleanSA(\n    PAIRPDCAP_SEC_ASSOCIATION sa)\n{\n    if (sa->next != NULL) {\n        AirPDcapRecurseCleanSA(sa->next);\n        g_free(sa->next);\n        sa->next = NULL;\n    }\n}\n\nstatic void\nAirPDcapCleanSecAssoc(\n    PAIRPDCAP_CONTEXT ctx)\n{\n    PAIRPDCAP_SEC_ASSOCIATION psa;\n    int i;\n\n    for (psa = ctx->sa, i = 0; i < AIRPDCAP_MAX_SEC_ASSOCIATIONS_NR; i++, psa++) {\n        /* To iterate is human, to recurse, divine */\n        AirPDcapRecurseCleanSA(psa);\n    }\n}\n\nINT AirPDcapGetKeys(\n    const PAIRPDCAP_CONTEXT ctx,\n    AIRPDCAP_KEY_ITEM keys[],\n    const size_t keys_nr)\n{\n    UINT i;\n    UINT j;\n    AIRPDCAP_DEBUG_TRACE_START(\"AirPDcapGetKeys\");\n\n    if (ctx==NULL) {\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapGetKeys\", \"NULL context\", AIRPDCAP_DEBUG_LEVEL_5);\n        AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapGetKeys\");\n        return 0;\n    } else if (keys==NULL) {\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapGetKeys\", \"NULL keys array\", AIRPDCAP_DEBUG_LEVEL_5);\n        AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapGetKeys\");\n        return (INT)ctx->keys_nr;\n    } else {\n        for (i=0, j=0; i<ctx->keys_nr && i<keys_nr && i<AIRPDCAP_MAX_KEYS_NR; i++) {\n            memcpy(&keys[j], &ctx->keys[i], sizeof(keys[j]));\n            j++;\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapGetKeys\", \"Got a key\", AIRPDCAP_DEBUG_LEVEL_5);\n        }\n\n        AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapGetKeys\");\n        return j;\n    }\n}\n\n/*\n * XXX - This won't be reliable if a packet containing SSID \"B\" shows\n * up in the middle of a 4-way handshake for SSID \"A\".\n * We should probably use a small array or hash table to keep multiple\n * SSIDs.\n */\nINT AirPDcapSetLastSSID(\n    PAIRPDCAP_CONTEXT ctx,\n    CHAR *pkt_ssid,\n    size_t pkt_ssid_len)\n{\n    if (!ctx || !pkt_ssid || pkt_ssid_len < 1 || pkt_ssid_len > WPA_SSID_MAX_SIZE)\n        return AIRPDCAP_RET_UNSUCCESS;\n\n    memcpy(ctx->pkt_ssid, pkt_ssid, pkt_ssid_len);\n    ctx->pkt_ssid_len = pkt_ssid_len;\n\n    return AIRPDCAP_RET_SUCCESS;\n}\n\nINT AirPDcapInitContext(\n    PAIRPDCAP_CONTEXT ctx)\n{\n    AIRPDCAP_DEBUG_TRACE_START(\"AirPDcapInitContext\");\n\n    if (ctx==NULL) {\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapInitContext\", \"NULL context\", AIRPDCAP_DEBUG_LEVEL_5);\n        AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapInitContext\");\n        return AIRPDCAP_RET_UNSUCCESS;\n    }\n\n    AirPDcapCleanKeys(ctx);\n\n    ctx->first_free_index=0;\n    ctx->index=-1;\n    ctx->sa_index=-1;\n    ctx->pkt_ssid_len = 0;\n\n    memset(ctx->sa, 0, AIRPDCAP_MAX_SEC_ASSOCIATIONS_NR * sizeof(AIRPDCAP_SEC_ASSOCIATION));\n\n    AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapInitContext\", \"Context initialized!\", AIRPDCAP_DEBUG_LEVEL_5);\n    AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapInitContext\");\n    return AIRPDCAP_RET_SUCCESS;\n}\n\nINT AirPDcapDestroyContext(\n    PAIRPDCAP_CONTEXT ctx)\n{\n    AIRPDCAP_DEBUG_TRACE_START(\"AirPDcapDestroyContext\");\n\n    if (ctx==NULL) {\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapDestroyContext\", \"NULL context\", AIRPDCAP_DEBUG_LEVEL_5);\n        AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapDestroyContext\");\n        return AIRPDCAP_RET_UNSUCCESS;\n    }\n\n    AirPDcapCleanKeys(ctx);\n    AirPDcapCleanSecAssoc(ctx);\n\n    ctx->first_free_index=0;\n    ctx->index=-1;\n    ctx->sa_index=-1;\n\n    AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapDestroyContext\", \"Context destroyed!\", AIRPDCAP_DEBUG_LEVEL_5);\n    AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapDestroyContext\");\n    return AIRPDCAP_RET_SUCCESS;\n}\n\n#ifdef __cplusplus\n}\n#endif\n\n/****************************************************************************/\n\n/****************************************************************************/\n/* Internal function definitions                                         */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nstatic INT\nAirPDcapRsnaMng(\n    UCHAR *decrypt_data,\n    guint mac_header_len,\n    guint *decrypt_len,\n    PAIRPDCAP_KEY_ITEM key,\n    AIRPDCAP_SEC_ASSOCIATION *sa,\n    INT offset)\n{\n    INT ret_value=1;\n    UCHAR *try_data;\n    guint try_data_len = *decrypt_len;\n\n    if (*decrypt_len > try_data_len) {\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsnaMng\", \"Invalid decryption length\", AIRPDCAP_DEBUG_LEVEL_3);\n        return AIRPDCAP_RET_UNSUCCESS;\n    }\n\n    /* allocate a temp buffer for the decryption loop */\n    try_data=(UCHAR *)g_malloc(try_data_len);\n\n    /* start of loop added by GCS */\n    for(/* sa */; sa != NULL ;sa=sa->next) {\n\n       if (sa->validKey==FALSE) {\n           AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsnaMng\", \"Key not yet valid\", AIRPDCAP_DEBUG_LEVEL_3);\n           continue;\n       }\n\n       /* copy the encrypted data into a temp buffer */\n       memcpy(try_data, decrypt_data, *decrypt_len);\n\n       if (sa->wpa.key_ver==1) {\n           /* CCMP -> HMAC-MD5 is the EAPOL-Key MIC, RC4 is the EAPOL-Key encryption algorithm */\n           AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsnaMng\", \"TKIP\", AIRPDCAP_DEBUG_LEVEL_3);\n           DEBUG_DUMP(\"ptk\", sa->wpa.ptk, 64);\n           DEBUG_DUMP(\"ptk portion used\", AIRPDCAP_GET_TK(sa->wpa.ptk), 16);\n\n           ret_value=AirPDcapTkipDecrypt(try_data+offset, *decrypt_len-offset, try_data+AIRPDCAP_TA_OFFSET, AIRPDCAP_GET_TK(sa->wpa.ptk));\n           if (ret_value){\n               AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsnaMng\", \"TKIP failed!\", AIRPDCAP_DEBUG_LEVEL_3);\n               continue;\n           }\n\n           AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsnaMng\", \"TKIP DECRYPTED!!!\", AIRPDCAP_DEBUG_LEVEL_3);\n           /* remove MIC (8bytes) and ICV (4bytes) from the end of packet */\n           *decrypt_len-=12;\n           break;\n       } else {\n           /* AES-CCMP -> HMAC-SHA1-128 is the EAPOL-Key MIC, AES wep_key wrap is the EAPOL-Key encryption algorithm */\n           AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsnaMng\", \"CCMP\", AIRPDCAP_DEBUG_LEVEL_3);\n\n           ret_value=AirPDcapCcmpDecrypt(try_data, mac_header_len, (INT)*decrypt_len, AIRPDCAP_GET_TK(sa->wpa.ptk));\n           if (ret_value)\n              continue;\n\n           AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsnaMng\", \"CCMP DECRYPTED!!!\", AIRPDCAP_DEBUG_LEVEL_3);\n           /* remove MIC (8bytes) from the end of packet */\n           *decrypt_len-=8;\n           break;\n       }\n    }\n    /* end of loop */\n\n    /* none of the keys worked */\n    if(sa == NULL) {\n        g_free(try_data);\n        return ret_value;\n    }\n\n    if (*decrypt_len > try_data_len || *decrypt_len < 8) {\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsnaMng\", \"Invalid decryption length\", AIRPDCAP_DEBUG_LEVEL_3);\n        g_free(try_data);\n        return AIRPDCAP_RET_UNSUCCESS;\n    }\n\n    /* copy the decrypted data into the decrypt buffer GCS*/\n    memcpy(decrypt_data, try_data, *decrypt_len);\n    g_free(try_data);\n\n    /* remove protection bit */\n    decrypt_data[1]&=0xBF;\n\n    /* remove TKIP/CCMP header */\n    offset = mac_header_len;\n    *decrypt_len-=8;\n    memmove(decrypt_data+offset, decrypt_data+offset+8, *decrypt_len-offset);\n\n    if (key!=NULL) {\n        if (sa->key!=NULL)\n            memcpy(key, sa->key, sizeof(AIRPDCAP_KEY_ITEM));\n        else\n            memset(key, 0, sizeof(AIRPDCAP_KEY_ITEM));\n        memcpy(key->KeyData.Wpa.Ptk, sa->wpa.ptk, AIRPDCAP_WPA_PTK_LEN); /* copy the PTK to the key structure for future use by wireshark */\n        if (sa->wpa.key_ver==AIRPDCAP_WPA_KEY_VER_NOT_CCMP)\n            key->KeyType=AIRPDCAP_KEY_TYPE_TKIP;\n        else if (sa->wpa.key_ver==AIRPDCAP_WPA_KEY_VER_AES_CCMP)\n            key->KeyType=AIRPDCAP_KEY_TYPE_CCMP;\n    }\n\n    return AIRPDCAP_RET_SUCCESS;\n}\n\nstatic INT\nAirPDcapWepMng(\n    PAIRPDCAP_CONTEXT ctx,\n    UCHAR *decrypt_data,\n    guint mac_header_len,\n    guint *decrypt_len,\n    PAIRPDCAP_KEY_ITEM key,\n    AIRPDCAP_SEC_ASSOCIATION *sa,\n    INT offset)\n{\n    UCHAR wep_key[AIRPDCAP_WEP_KEY_MAXLEN+AIRPDCAP_WEP_IVLEN];\n    size_t keylen;\n    INT ret_value=1;\n    INT key_index;\n    AIRPDCAP_KEY_ITEM *tmp_key;\n    UINT8 useCache=FALSE;\n    UCHAR *try_data;\n    guint try_data_len = *decrypt_len;\n\n    try_data = (UCHAR *)g_malloc(try_data_len);\n\n    if (sa->key!=NULL)\n        useCache=TRUE;\n\n    for (key_index=0; key_index<(INT)ctx->keys_nr; key_index++) {\n        /* use the cached one, or try all keys */\n        if (!useCache) {\n            tmp_key=&ctx->keys[key_index];\n        } else {\n            if (sa->key!=NULL && sa->key->KeyType==AIRPDCAP_KEY_TYPE_WEP) {\n                AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapWepMng\", \"Try cached WEP key...\", AIRPDCAP_DEBUG_LEVEL_3);\n                tmp_key=sa->key;\n            } else {\n                AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapWepMng\", \"Cached key is not valid, try another WEP key...\", AIRPDCAP_DEBUG_LEVEL_3);\n                tmp_key=&ctx->keys[key_index];\n            }\n        }\n\n        /* obviously, try only WEP keys... */\n        if (tmp_key->KeyType==AIRPDCAP_KEY_TYPE_WEP) {\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapWepMng\", \"Try WEP key...\", AIRPDCAP_DEBUG_LEVEL_3);\n\n            memset(wep_key, 0, sizeof(wep_key));\n            memcpy(try_data, decrypt_data, *decrypt_len);\n\n            /* Costruct the WEP seed: copy the IV in first 3 bytes and then the WEP key (refer to 802-11i-2004, 8.2.1.4.3, pag. 36) */\n            memcpy(wep_key, try_data+mac_header_len, AIRPDCAP_WEP_IVLEN);\n            keylen=tmp_key->KeyData.Wep.WepKeyLen;\n            memcpy(wep_key+AIRPDCAP_WEP_IVLEN, tmp_key->KeyData.Wep.WepKey, keylen);\n\n            ret_value=AirPDcapWepDecrypt(wep_key,\n                keylen+AIRPDCAP_WEP_IVLEN,\n                try_data + (mac_header_len+AIRPDCAP_WEP_IVLEN+AIRPDCAP_WEP_KIDLEN),\n                *decrypt_len-(mac_header_len+AIRPDCAP_WEP_IVLEN+AIRPDCAP_WEP_KIDLEN+AIRPDCAP_CRC_LEN));\n\n            if (ret_value == AIRPDCAP_RET_SUCCESS)\n                memcpy(decrypt_data, try_data, *decrypt_len);\n        }\n\n        if (!ret_value && tmp_key->KeyType==AIRPDCAP_KEY_TYPE_WEP) {\n            /* the tried key is the correct one, cached in the Security Association */\n\n            sa->key=tmp_key;\n\n            if (key!=NULL) {\n                memcpy(key, sa->key, sizeof(AIRPDCAP_KEY_ITEM));\n                key->KeyType=AIRPDCAP_KEY_TYPE_WEP;\n            }\n\n            break;\n        } else {\n            /* the cached key was not valid, try other keys */\n\n            if (useCache==TRUE) {\n                useCache=FALSE;\n                key_index--;\n            }\n        }\n    }\n\n    g_free(try_data);\n    if (ret_value)\n        return AIRPDCAP_RET_UNSUCCESS;\n\n    AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapWepMng\", \"WEP DECRYPTED!!!\", AIRPDCAP_DEBUG_LEVEL_3);\n\n    /* remove ICV (4bytes) from the end of packet */\n    *decrypt_len-=4;\n\n    if (*decrypt_len < 4) {\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapWepMng\", \"Decryption length too short\", AIRPDCAP_DEBUG_LEVEL_3);\n        return AIRPDCAP_RET_UNSUCCESS;\n    }\n\n    /* remove protection bit */\n    decrypt_data[1]&=0xBF;\n\n    /* remove IC header */\n    offset = mac_header_len;\n    *decrypt_len-=4;\n    memmove(decrypt_data+offset, decrypt_data+offset+AIRPDCAP_WEP_IVLEN+AIRPDCAP_WEP_KIDLEN, *decrypt_len-offset);\n\n    return AIRPDCAP_RET_SUCCESS;\n}\n\n/* Refer to IEEE 802.11i-2004, 8.5.3, pag. 85 */\nstatic INT\nAirPDcapRsna4WHandshake(\n    PAIRPDCAP_CONTEXT ctx,\n    const UCHAR *data,\n    AIRPDCAP_SEC_ASSOCIATION *sa,\n    INT offset,\n    const guint tot_len)\n{\n    AIRPDCAP_KEY_ITEM *tmp_key, *tmp_pkt_key, pkt_key;\n    AIRPDCAP_SEC_ASSOCIATION *tmp_sa;\n    INT key_index;\n    INT ret_value=1;\n    UCHAR useCache=FALSE;\n    UCHAR eapol[AIRPDCAP_EAPOL_MAX_LEN];\n    USHORT eapol_len;\n\n    if (sa->key!=NULL)\n        useCache=TRUE;\n\n    /* a 4-way handshake packet use a Pairwise key type (IEEE 802.11i-2004, pg. 79) */\n    if (AIRPDCAP_EAP_KEY(data[offset+1])!=1) {\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsna4WHandshake\", \"Group/STAKey message (not used)\", AIRPDCAP_DEBUG_LEVEL_5);\n        return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n    }\n\n    /* TODO timeouts? */\n\n    /* TODO consider key-index */\n\n    /* TODO considera Deauthentications */\n\n    AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsna4WHandshake\", \"4-way handshake...\", AIRPDCAP_DEBUG_LEVEL_5);\n\n    /* manage 4-way handshake packets; this step completes the 802.1X authentication process (IEEE 802.11i-2004, pag. 85) */\n\n    /* message 1: Authenticator->Supplicant (Sec=0, Mic=0, Ack=1, Inst=0, Key=1(pairwise), KeyRSC=0, Nonce=ANonce, MIC=0) */\n    if (AIRPDCAP_EAP_INST(data[offset+1])==0 &&\n        AIRPDCAP_EAP_ACK(data[offset+1])==1 &&\n        AIRPDCAP_EAP_MIC(data[offset])==0)\n    {\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsna4WHandshake\", \"4-way handshake message 1\", AIRPDCAP_DEBUG_LEVEL_3);\n\n        /* On reception of Message 1, the Supplicant determines whether the Key Replay Counter field value has been        */\n        /* used before with the current PMKSA. If the Key Replay Counter field value is less than or equal to the current  */\n        /* local value, the Supplicant discards the message.                                                               */\n        /* -> not checked, the Authenticator will be send another Message 1 (hopefully!)                                   */\n\n        /* This saves the sa since we are reauthenticating which will overwrite our current sa GCS*/\n        if( sa->handshake >= 2) {\n            tmp_sa= g_new(AIRPDCAP_SEC_ASSOCIATION, 1);\n            memcpy(tmp_sa, sa, sizeof(AIRPDCAP_SEC_ASSOCIATION));\n            sa->validKey=FALSE;\n            sa->next=tmp_sa;\n        }\n\n        /* save ANonce (from authenticator) to derive the PTK with the SNonce (from the 2 message) */\n        memcpy(sa->wpa.nonce, data+offset+12, 32);\n\n        /* get the Key Descriptor Version (to select algorithm used in decryption -CCMP or TKIP-) */\n        sa->wpa.key_ver=AIRPDCAP_EAP_KEY_DESCR_VER(data[offset+1]);\n\n        sa->handshake=1;\n\n        return AIRPDCAP_RET_SUCCESS_HANDSHAKE;\n    }\n\n    /* message 2|4: Supplicant->Authenticator (Sec=0|1, Mic=1, Ack=0, Inst=0, Key=1(pairwise), KeyRSC=0, Nonce=SNonce|0, MIC=MIC(KCK,EAPOL)) */\n    if (AIRPDCAP_EAP_INST(data[offset+1])==0 &&\n        AIRPDCAP_EAP_ACK(data[offset+1])==0 &&\n        AIRPDCAP_EAP_MIC(data[offset])==1)\n    {\n        /* Check key data length to differentiate between message 2 or 4, same as in epan/dissectors/packet-ieee80211.c */\n        if (pntoh16(data+offset+92)) {\n            /* message 2 */\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsna4WHandshake\", \"4-way handshake message 2\", AIRPDCAP_DEBUG_LEVEL_3);\n\n            /* On reception of Message 2, the Authenticator checks that the key replay counter corresponds to the */\n            /* outstanding Message 1. If not, it silently discards the message.                                   */\n            /* If the calculated MIC does not match the MIC that the Supplicant included in the EAPOL-Key frame,  */\n            /* the Authenticator silently discards Message 2.                                                     */\n            /* -> not checked; the Supplicant will send another message 2 (hopefully!)                            */\n\n            /* now you can derive the PTK */\n            for (key_index=0; key_index<(INT)ctx->keys_nr || useCache; key_index++) {\n                /* use the cached one, or try all keys */\n                if (!useCache) {\n                    AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsna4WHandshake\", \"Try WPA key...\", AIRPDCAP_DEBUG_LEVEL_3);\n                    tmp_key=&ctx->keys[key_index];\n                } else {\n                    /* there is a cached key in the security association, if it's a WPA key try it... */\n                    if (sa->key!=NULL &&\n                        (sa->key->KeyType==AIRPDCAP_KEY_TYPE_WPA_PWD ||\n                         sa->key->KeyType==AIRPDCAP_KEY_TYPE_WPA_PSK ||\n                         sa->key->KeyType==AIRPDCAP_KEY_TYPE_WPA_PMK)) {\n                            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsna4WHandshake\", \"Try cached WPA key...\", AIRPDCAP_DEBUG_LEVEL_3);\n                            tmp_key=sa->key;\n                    } else {\n                        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsna4WHandshake\", \"Cached key is of a wrong type, try WPA key...\", AIRPDCAP_DEBUG_LEVEL_3);\n                        tmp_key=&ctx->keys[key_index];\n                    }\n                }\n\n                /* obviously, try only WPA keys... */\n                if (tmp_key->KeyType==AIRPDCAP_KEY_TYPE_WPA_PWD ||\n                    tmp_key->KeyType==AIRPDCAP_KEY_TYPE_WPA_PSK ||\n                    tmp_key->KeyType==AIRPDCAP_KEY_TYPE_WPA_PMK)\n                {\n                    if (tmp_key->KeyType == AIRPDCAP_KEY_TYPE_WPA_PWD && tmp_key->UserPwd.SsidLen == 0 && ctx->pkt_ssid_len > 0 && ctx->pkt_ssid_len <= AIRPDCAP_WPA_SSID_MAX_LEN) {\n                        /* We have a \"wildcard\" SSID.  Use the one from the packet. */\n                        memcpy(&pkt_key, tmp_key, sizeof(pkt_key));\n                        memcpy(&pkt_key.UserPwd.Ssid, ctx->pkt_ssid, ctx->pkt_ssid_len);\n                         pkt_key.UserPwd.SsidLen = ctx->pkt_ssid_len;\n                        AirPDcapRsnaPwd2Psk(pkt_key.UserPwd.Passphrase, pkt_key.UserPwd.Ssid,\n                            pkt_key.UserPwd.SsidLen, pkt_key.KeyData.Wpa.Psk);\n                        tmp_pkt_key = &pkt_key;\n                    } else {\n                        tmp_pkt_key = tmp_key;\n                    }\n\n                    /* derive the PTK from the BSSID, STA MAC, PMK, SNonce, ANonce */\n                    AirPDcapRsnaPrfX(sa,                            /* authenticator nonce, bssid, station mac */\n                                     tmp_pkt_key->KeyData.Wpa.Psk,      /* PSK == PMK */\n                                     data+offset+12,                /* supplicant nonce */\n                                     512,\n                                     sa->wpa.ptk);\n\n                    /* verify the MIC (compare the MIC in the packet included in this message with a MIC calculated with the PTK) */\n                    eapol_len=pntoh16(data+offset-3)+4;\n                    memcpy(eapol, &data[offset-5], (eapol_len<AIRPDCAP_EAPOL_MAX_LEN?eapol_len:AIRPDCAP_EAPOL_MAX_LEN));\n                    ret_value=AirPDcapRsnaMicCheck(eapol,           /*      eapol frame (header also) */\n                                                   eapol_len,       /*      eapol frame length        */\n                                                   sa->wpa.ptk,     /*      Key Confirmation Key      */\n                                                   AIRPDCAP_EAP_KEY_DESCR_VER(data[offset+1])); /*  EAPOL-Key description version */\n\n                    /* If the MIC is valid, the Authenticator checks that the RSN information element bit-wise matches       */\n                    /* that from the (Re)Association Request message.                                                        */\n                    /*              i) TODO If these are not exactly the same, the Authenticator uses MLME-DEAUTHENTICATE.request */\n                    /* primitive to terminate the association.                                                               */\n                    /*              ii) If they do match bit-wise, the Authenticator constructs Message 3.                   */\n                }\n\n                if (!ret_value &&\n                    (tmp_key->KeyType==AIRPDCAP_KEY_TYPE_WPA_PWD ||\n                    tmp_key->KeyType==AIRPDCAP_KEY_TYPE_WPA_PSK ||\n                    tmp_key->KeyType==AIRPDCAP_KEY_TYPE_WPA_PMK))\n                {\n                    /* the temporary key is the correct one, cached in the Security Association */\n\n                    sa->key=tmp_key;\n                    break;\n                } else {\n                    /* the cached key was not valid, try other keys */\n\n                    if (useCache==TRUE) {\n                        useCache=FALSE;\n                        key_index--;\n                    }\n                }\n            }\n\n            if (ret_value) {\n                AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsna4WHandshake\", \"handshake step failed\", AIRPDCAP_DEBUG_LEVEL_3);\n                return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n            }\n\n            sa->handshake=2;\n            sa->validKey=TRUE; /* we can use the key to decode, even if we have not captured the other eapol packets */\n\n            return AIRPDCAP_RET_SUCCESS_HANDSHAKE;\n        } else {\n        /* message 4 */\n\n            /* TODO \"Note that when the 4-Way Handshake is first used Message 4 is sent in the clear.\" */\n\n            /* TODO check MIC and Replay Counter                                                                     */\n            /* On reception of Message 4, the Authenticator verifies that the Key Replay Counter field value is one  */\n            /* that it used on this 4-Way Handshake; if it is not, it silently discards the message.                 */\n            /* If the calculated MIC does not match the MIC that the Supplicant included in the EAPOL-Key frame, the */\n            /* Authenticator silently discards Message 4.                                                            */\n\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsna4WHandshake\", \"4-way handshake message 4\", AIRPDCAP_DEBUG_LEVEL_3);\n\n            sa->handshake=4;\n\n            return AIRPDCAP_RET_SUCCESS_HANDSHAKE;\n        }\n    }\n\n    /* message 3: Authenticator->Supplicant (Sec=1, Mic=1, Ack=1, Inst=0/1, Key=1(pairwise), KeyRSC=???, Nonce=ANonce, MIC=1) */\n    if (AIRPDCAP_EAP_ACK(data[offset+1])==1 &&\n        AIRPDCAP_EAP_MIC(data[offset])==1)\n    {\n        const EAPOL_RSN_KEY *pEAPKey;\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsna4WHandshake\", \"4-way handshake message 3\", AIRPDCAP_DEBUG_LEVEL_3);\n\n        /* On reception of Message 3, the Supplicant silently discards the message if the Key Replay Counter field     */\n        /* value has already been used or if the ANonce value in Message 3 differs from the ANonce value in Message 1. */\n        /* -> not checked, the Authenticator will send another message 3 (hopefully!)                                  */\n\n        /* TODO check page 88 (RNS) */\n\n        /* If using WPA2 PSK, message 3 will contain an RSN for the group key (GTK KDE).\n           In order to properly support decrypting WPA2-PSK packets, we need to parse this to get the group key. */\n        pEAPKey = (const EAPOL_RSN_KEY *)(&(data[offset-1]));\n        if (pEAPKey->type == AIRPDCAP_RSN_WPA2_KEY_DESCRIPTOR){\n            PAIRPDCAP_SEC_ASSOCIATION broadcast_sa;\n            AIRPDCAP_SEC_ASSOCIATION_ID id;\n\n            /* Get broadcacst SA for the current BSSID */\n            memcpy(id.sta, broadcast_mac, AIRPDCAP_MAC_LEN);\n            memcpy(id.bssid, sa->saId.bssid, AIRPDCAP_MAC_LEN);\n            broadcast_sa = AirPDcapGetSaPtr(ctx, &id);\n\n            if (broadcast_sa == NULL){\n                return AIRPDCAP_RET_REQ_DATA;\n            }\n            return (AirPDcapDecryptWPABroadcastKey(pEAPKey, sa->wpa.ptk+16, broadcast_sa, tot_len-offset+1));\n        }\n    }\n\n    return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n}\n\nstatic INT\nAirPDcapRsnaMicCheck(\n    UCHAR *eapol,\n    USHORT eapol_len,\n    UCHAR KCK[AIRPDCAP_WPA_KCK_LEN],\n    USHORT key_ver)\n{\n    UCHAR mic[AIRPDCAP_WPA_MICKEY_LEN];\n    UCHAR c_mic[HASH_SHA1_LENGTH] = { 0 };  /* MIC 16 byte, the HMAC-SHA1 use a buffer of 20 bytes */\n    int algo;\n\n    /* copy the MIC from the EAPOL packet */\n    memcpy(mic, eapol+AIRPDCAP_WPA_MICKEY_OFFSET+4, AIRPDCAP_WPA_MICKEY_LEN);\n\n    /* set to 0 the MIC in the EAPOL packet (to calculate the MIC) */\n    memset(eapol+AIRPDCAP_WPA_MICKEY_OFFSET+4, 0, AIRPDCAP_WPA_MICKEY_LEN);\n\n    if (key_ver==AIRPDCAP_WPA_KEY_VER_NOT_CCMP) {\n        /* use HMAC-MD5 for the EAPOL-Key MIC */\n        algo = GCRY_MD_MD5;\n    } else if (key_ver==AIRPDCAP_WPA_KEY_VER_AES_CCMP) {\n        /* use HMAC-SHA1-128 for the EAPOL-Key MIC */\n        algo = GCRY_MD_SHA1;\n    } else {\n        /* key descriptor version not recognized */\n        return AIRPDCAP_RET_UNSUCCESS;\n    }\n\n    if (ws_hmac_buffer(algo, c_mic, eapol, eapol_len, KCK, AIRPDCAP_WPA_KCK_LEN)) {\n        return AIRPDCAP_RET_UNSUCCESS;\n    }\n\n    /* compare calculated MIC with the Key MIC and return result (0 means success) */\n    return memcmp(mic, c_mic, AIRPDCAP_WPA_MICKEY_LEN);\n}\n\nstatic INT\nAirPDcapValidateKey(\n    PAIRPDCAP_KEY_ITEM key)\n{\n    size_t len;\n    UCHAR ret=TRUE;\n    AIRPDCAP_DEBUG_TRACE_START(\"AirPDcapValidateKey\");\n\n    if (key==NULL) {\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapValidateKey\", \"NULL key\", AIRPDCAP_DEBUG_LEVEL_5);\n        AIRPDCAP_DEBUG_TRACE_START(\"AirPDcapValidateKey\");\n        return FALSE;\n    }\n\n    switch (key->KeyType) {\n        case AIRPDCAP_KEY_TYPE_WEP:\n            /* check key size limits */\n            len=key->KeyData.Wep.WepKeyLen;\n            if (len<AIRPDCAP_WEP_KEY_MINLEN || len>AIRPDCAP_WEP_KEY_MAXLEN) {\n                AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapValidateKey\", \"WEP key: key length not accepted\", AIRPDCAP_DEBUG_LEVEL_5);\n                ret=FALSE;\n            }\n            break;\n\n        case AIRPDCAP_KEY_TYPE_WEP_40:\n            /* set the standard length and use a generic WEP key type */\n            key->KeyData.Wep.WepKeyLen=AIRPDCAP_WEP_40_KEY_LEN;\n            key->KeyType=AIRPDCAP_KEY_TYPE_WEP;\n            break;\n\n        case AIRPDCAP_KEY_TYPE_WEP_104:\n            /* set the standard length and use a generic WEP key type */\n            key->KeyData.Wep.WepKeyLen=AIRPDCAP_WEP_104_KEY_LEN;\n            key->KeyType=AIRPDCAP_KEY_TYPE_WEP;\n            break;\n\n        case AIRPDCAP_KEY_TYPE_WPA_PWD:\n            /* check passphrase and SSID size limits */\n            len=strlen(key->UserPwd.Passphrase);\n            if (len<AIRPDCAP_WPA_PASSPHRASE_MIN_LEN || len>AIRPDCAP_WPA_PASSPHRASE_MAX_LEN) {\n                AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapValidateKey\", \"WPA-PWD key: passphrase length not accepted\", AIRPDCAP_DEBUG_LEVEL_5);\n                ret=FALSE;\n            }\n\n            len=key->UserPwd.SsidLen;\n            if (len>AIRPDCAP_WPA_SSID_MAX_LEN) {\n                AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapValidateKey\", \"WPA-PWD key: ssid length not accepted\", AIRPDCAP_DEBUG_LEVEL_5);\n                ret=FALSE;\n            }\n\n            break;\n\n        case AIRPDCAP_KEY_TYPE_WPA_PSK:\n            break;\n\n        case AIRPDCAP_KEY_TYPE_WPA_PMK:\n            break;\n\n        default:\n            ret=FALSE;\n    }\n\n    AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapValidateKey\");\n    return ret;\n}\n\nstatic INT\nAirPDcapGetSa(\n    PAIRPDCAP_CONTEXT ctx,\n    AIRPDCAP_SEC_ASSOCIATION_ID *id)\n{\n    INT sa_index;\n    if (ctx->sa_index!=-1) {\n        /* at least one association was stored                               */\n        /* search for the association from sa_index to 0 (most recent added) */\n        for (sa_index=ctx->sa_index; sa_index>=0; sa_index--) {\n            if (ctx->sa[sa_index].used) {\n                if (memcmp(id, &(ctx->sa[sa_index].saId), sizeof(AIRPDCAP_SEC_ASSOCIATION_ID))==0) {\n                    ctx->index=sa_index;\n                    return sa_index;\n                }\n            }\n        }\n    }\n\n    return -1;\n}\n\nstatic INT\nAirPDcapStoreSa(\n    PAIRPDCAP_CONTEXT ctx,\n    AIRPDCAP_SEC_ASSOCIATION_ID *id)\n{\n    INT last_free;\n    if (ctx->first_free_index>=AIRPDCAP_MAX_SEC_ASSOCIATIONS_NR) {\n        /* there is no empty space available. FAILURE */\n        return -1;\n    }\n    if (ctx->sa[ctx->first_free_index].used) {\n        /* last addition was in the middle of the array (and the first_free_index was just incremented by 1)   */\n        /* search for a free space from the first_free_index to AIRPDCAP_STA_INFOS_NR (to avoid free blocks in */\n        /*              the middle)                                                                            */\n        for (last_free=ctx->first_free_index; last_free<AIRPDCAP_MAX_SEC_ASSOCIATIONS_NR; last_free++)\n            if (!ctx->sa[last_free].used)\n                break;\n\n        if (last_free>=AIRPDCAP_MAX_SEC_ASSOCIATIONS_NR) {\n            /* there is no empty space available. FAILURE */\n            return -1;\n        }\n\n        /* store first free space index */\n        ctx->first_free_index=last_free;\n    }\n\n    /* use this info */\n    ctx->index=ctx->first_free_index;\n\n    /* reset the info structure */\n    memset(ctx->sa+ctx->index, 0, sizeof(AIRPDCAP_SEC_ASSOCIATION));\n\n    ctx->sa[ctx->index].used=1;\n\n    /* set the info structure */\n    memcpy(&(ctx->sa[ctx->index].saId), id, sizeof(AIRPDCAP_SEC_ASSOCIATION_ID));\n\n    /* increment by 1 the first_free_index (heuristic) */\n    ctx->first_free_index++;\n\n    /* set the sa_index if the added index is greater the the sa_index */\n    if (ctx->index > ctx->sa_index)\n        ctx->sa_index=ctx->index;\n\n    return ctx->index;\n}\n\n\nstatic INT\nAirPDcapGetSaAddress(\n    const AIRPDCAP_MAC_FRAME_ADDR4 *frame,\n    AIRPDCAP_SEC_ASSOCIATION_ID *id)\n{\n#ifdef AIRPDCAP_DEBUG\n#define MSGBUF_LEN 255\n    CHAR msgbuf[MSGBUF_LEN];\n#endif\n\n    if ((AIRPDCAP_TYPE(frame->fc[0])==AIRPDCAP_TYPE_DATA) &&\n        (AIRPDCAP_DS_BITS(frame->fc[1]) == 0) &&\n        (memcmp(frame->addr2, frame->addr3, AIRPDCAP_MAC_LEN) != 0) &&\n        (memcmp(frame->addr1, frame->addr3, AIRPDCAP_MAC_LEN) != 0)) {\n        /* DATA frame with fromDS=0 ToDS=0 and neither RA or SA is BSSID\n           => TDLS traffic. Use highest MAC address for bssid */\n        if (memcmp(frame->addr1, frame->addr2, AIRPDCAP_MAC_LEN) < 0) {\n            memcpy(id->sta, frame->addr1, AIRPDCAP_MAC_LEN);\n            memcpy(id->bssid, frame->addr2, AIRPDCAP_MAC_LEN);\n        } else {\n            memcpy(id->sta, frame->addr2, AIRPDCAP_MAC_LEN);\n            memcpy(id->bssid, frame->addr1, AIRPDCAP_MAC_LEN);\n        }\n    } else {\n        const UCHAR *addr;\n\n        /* Normal Case: SA between STA and AP */\n        if ((addr = AirPDcapGetBssidAddress(frame)) != NULL) {\n            memcpy(id->bssid, addr, AIRPDCAP_MAC_LEN);\n        } else {\n            return AIRPDCAP_RET_UNSUCCESS;\n        }\n\n        if ((addr = AirPDcapGetStaAddress(frame)) != NULL) {\n            memcpy(id->sta, addr, AIRPDCAP_MAC_LEN);\n        } else {\n            return AIRPDCAP_RET_UNSUCCESS;\n        }\n    }\n\n#ifdef AIRPDCAP_DEBUG\n    g_snprintf(msgbuf, MSGBUF_LEN, \"BSSID_MAC: %02X.%02X.%02X.%02X.%02X.%02X\\t\",\n               id->bssid[0],id->bssid[1],id->bssid[2],id->bssid[3],id->bssid[4],id->bssid[5]);\n    AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapGetSaAddress\", msgbuf, AIRPDCAP_DEBUG_LEVEL_3);\n    g_snprintf(msgbuf, MSGBUF_LEN, \"STA_MAC: %02X.%02X.%02X.%02X.%02X.%02X\\t\",\n               id->sta[0],id->sta[1],id->sta[2],id->sta[3],id->sta[4],id->sta[5]);\n    AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapGetSaAddress\", msgbuf, AIRPDCAP_DEBUG_LEVEL_3);\n#endif\n\n    return AIRPDCAP_RET_SUCCESS;\n}\n\n/*\n * AirPDcapGetBssidAddress() and AirPDcapGetBssidAddress() are used for\n * key caching.  In each case, it's more important to return a value than\n * to return a _correct_ value, so we fudge addresses in some cases, e.g.\n * the BSSID in bridged connections.\n * FromDS    ToDS   Sta      BSSID\n * 0         0      addr1/2  addr3\n * 0         1      addr2    addr1\n * 1         0      addr1    addr2\n * 1         1      addr2    addr1\n */\n\nstatic const UCHAR *\nAirPDcapGetStaAddress(\n    const AIRPDCAP_MAC_FRAME_ADDR4 *frame)\n{\n    switch(AIRPDCAP_DS_BITS(frame->fc[1])) { /* Bit 1 = FromDS, bit 0 = ToDS */\n        case 0:\n            if (memcmp(frame->addr2, frame->addr3, AIRPDCAP_MAC_LEN) == 0)\n                return frame->addr1;\n            else\n                return frame->addr2;\n        case 1:\n            return frame->addr2;\n        case 2:\n            return frame->addr1;\n        case 3:\n            if (memcmp(frame->addr1, frame->addr2, AIRPDCAP_MAC_LEN) < 0)\n                return frame->addr1;\n            else\n                return frame->addr2;\n\n        default:\n            return NULL;\n    }\n}\n\nstatic const UCHAR *\nAirPDcapGetBssidAddress(\n    const AIRPDCAP_MAC_FRAME_ADDR4 *frame)\n{\n    switch(AIRPDCAP_DS_BITS(frame->fc[1])) { /* Bit 1 = FromDS, bit 0 = ToDS */\n        case 0:\n            return frame->addr3;\n        case 1:\n            return frame->addr1;\n        case 2:\n            return frame->addr2;\n        case 3:\n            if (memcmp(frame->addr1, frame->addr2, AIRPDCAP_MAC_LEN) > 0)\n                return frame->addr1;\n            else\n                return frame->addr2;\n\n        default:\n            return NULL;\n    }\n}\n\n/* Function used to derive the PTK. Refer to IEEE 802.11I-2004, pag. 74\n * and IEEE 802.11i-2004, pag. 164 */\nstatic void\nAirPDcapRsnaPrfX(\n    AIRPDCAP_SEC_ASSOCIATION *sa,\n    const UCHAR pmk[32],\n    const UCHAR snonce[32],\n    const INT x,        /*      for TKIP 512, for CCMP 384 */\n    UCHAR *ptk)\n{\n    UINT8 i;\n    UCHAR R[100];\n    INT offset=sizeof(\"Pairwise key expansion\");\n    UCHAR output[80]; /* allow for sha1 overflow. */\n\n    memset(R, 0, 100);\n\n    memcpy(R, \"Pairwise key expansion\", offset);\n\n    /* Min(AA, SPA) || Max(AA, SPA) */\n    if (memcmp(sa->saId.sta, sa->saId.bssid, AIRPDCAP_MAC_LEN) < 0)\n    {\n        memcpy(R + offset, sa->saId.sta, AIRPDCAP_MAC_LEN);\n        memcpy(R + offset+AIRPDCAP_MAC_LEN, sa->saId.bssid, AIRPDCAP_MAC_LEN);\n    }\n    else\n    {\n        memcpy(R + offset, sa->saId.bssid, AIRPDCAP_MAC_LEN);\n        memcpy(R + offset+AIRPDCAP_MAC_LEN, sa->saId.sta, AIRPDCAP_MAC_LEN);\n    }\n\n    offset+=AIRPDCAP_MAC_LEN*2;\n\n    /* Min(ANonce,SNonce) || Max(ANonce,SNonce) */\n    if( memcmp(snonce, sa->wpa.nonce, 32) < 0 )\n    {\n        memcpy(R + offset, snonce, 32);\n        memcpy(R + offset + 32, sa->wpa.nonce, 32);\n    }\n    else\n    {\n        memcpy(R + offset, sa->wpa.nonce, 32);\n        memcpy(R + offset + 32, snonce, 32);\n    }\n\n    offset+=32*2;\n\n    for(i = 0; i < (x+159)/160; i++)\n    {\n        R[offset] = i;\n        if (ws_hmac_buffer(GCRY_MD_SHA1, &output[HASH_SHA1_LENGTH * i], R, 100, pmk, 32)) {\n          return;\n        }\n    }\n    memcpy(ptk, output, x/8);\n}\n\n#define MAX_SSID_LENGTH 32 /* maximum SSID length */\n\nstatic INT\nAirPDcapRsnaPwd2PskStep(\n    const guint8 *ppBytes,\n    const guint ppLength,\n    const CHAR *ssid,\n    const size_t ssidLength,\n    const INT iterations,\n    const INT count,\n    UCHAR *output)\n{\n    UCHAR digest[MAX_SSID_LENGTH+4] = { 0 };  /* SSID plus 4 bytes of count */\n    INT i, j;\n\n    if (ssidLength > MAX_SSID_LENGTH) {\n        /* This \"should not happen\" */\n        return AIRPDCAP_RET_UNSUCCESS;\n    }\n\n    /* U1 = PRF(P, S || INT(i)) */\n    memcpy(digest, ssid, ssidLength);\n    digest[ssidLength] = (UCHAR)((count>>24) & 0xff);\n    digest[ssidLength+1] = (UCHAR)((count>>16) & 0xff);\n    digest[ssidLength+2] = (UCHAR)((count>>8) & 0xff);\n    digest[ssidLength+3] = (UCHAR)(count & 0xff);\n    if (ws_hmac_buffer(GCRY_MD_SHA1, digest, digest, (guint32) ssidLength + 4, ppBytes, ppLength)) {\n      return AIRPDCAP_RET_UNSUCCESS;\n    }\n\n    /* output = U1 */\n    memcpy(output, digest, 20);\n    for (i = 1; i < iterations; i++) {\n        /* Un = PRF(P, Un-1) */\n        if (ws_hmac_buffer(GCRY_MD_SHA1, digest, digest, HASH_SHA1_LENGTH, ppBytes, ppLength)) {\n          return AIRPDCAP_RET_UNSUCCESS;\n        }\n\n        /* output = output xor Un */\n        for (j = 0; j < 20; j++) {\n            output[j] ^= digest[j];\n        }\n    }\n\n    return AIRPDCAP_RET_SUCCESS;\n}\n\nstatic INT\nAirPDcapRsnaPwd2Psk(\n    const CHAR *passphrase,\n    const CHAR *ssid,\n    const size_t ssidLength,\n    UCHAR *output)\n{\n    UCHAR m_output[40] = { 0 };\n    GByteArray *pp_ba = g_byte_array_new();\n\n    if (!uri_str_to_bytes(passphrase, pp_ba)) {\n        g_byte_array_free(pp_ba, TRUE);\n        return 0;\n    }\n\n    AirPDcapRsnaPwd2PskStep(pp_ba->data, pp_ba->len, ssid, ssidLength, 4096, 1, m_output);\n    AirPDcapRsnaPwd2PskStep(pp_ba->data, pp_ba->len, ssid, ssidLength, 4096, 2, &m_output[20]);\n\n    memcpy(output, m_output, AIRPDCAP_WPA_PSK_LEN);\n    g_byte_array_free(pp_ba, TRUE);\n\n    return 0;\n}\n\n/*\n * Returns the decryption_key_t struct given a string describing the key.\n * Returns NULL if the input_string cannot be parsed.\n */\ndecryption_key_t*\nparse_key_string(gchar* input_string, guint8 key_type)\n{\n    gchar *key, *tmp_str;\n    gchar *ssid;\n\n    GString    *key_string = NULL;\n    GByteArray *ssid_ba = NULL, *key_ba;\n    gboolean    res;\n\n    gchar **tokens;\n    guint n = 0;\n    decryption_key_t *dk;\n\n    if(input_string == NULL)\n        return NULL;\n\n    /*\n     * Parse the input_string. WEP and WPA will be just a string\n     * of hexadecimal characters (if key is wrong, null will be\n     * returned...).\n     * WPA-PWD should be in the form\n     * <key data>[:<ssid>]\n     */\n\n    switch(key_type)\n    {\n    case AIRPDCAP_KEY_TYPE_WEP:\n    case AIRPDCAP_KEY_TYPE_WEP_40:\n    case AIRPDCAP_KEY_TYPE_WEP_104:\n\n       key_ba = g_byte_array_new();\n       res = hex_str_to_bytes(input_string, key_ba, FALSE);\n\n       if (res && key_ba->len > 0) {\n           /* Key is correct! It was probably an 'old style' WEP key */\n           /* Create the decryption_key_t structure, fill it and return it*/\n           dk = (decryption_key_t *)g_malloc(sizeof(decryption_key_t));\n\n           dk->type = AIRPDCAP_KEY_TYPE_WEP;\n           /* XXX - The current key handling code in the GUI requires\n            * no separators and lower case */\n           tmp_str = bytes_to_str(NULL, key_ba->data, key_ba->len);\n           dk->key  = g_string_new(tmp_str);\n           g_string_ascii_down(dk->key);\n           dk->bits = key_ba->len * 8;\n           dk->ssid = NULL;\n\n           wmem_free(NULL, tmp_str);\n           g_byte_array_free(key_ba, TRUE);\n           return dk;\n       }\n\n       /* Key doesn't work */\n       g_byte_array_free(key_ba, TRUE);\n       return NULL;\n\n    case AIRPDCAP_KEY_TYPE_WPA_PWD:\n\n        tokens = g_strsplit(input_string,\":\",0);\n\n        /* Tokens is a null termiated array of strings ... */\n        while(tokens[n] != NULL)\n            n++;\n\n        if(n < 1)\n        {\n            /* Free the array of strings */\n            g_strfreev(tokens);\n            return NULL;\n        }\n\n        /*\n         * The first token is the key\n         */\n        key = g_strdup(tokens[0]);\n\n        ssid = NULL;\n        /* Maybe there is a second token (an ssid, if everything else is ok) */\n        if(n >= 2)\n        {\n           ssid = g_strdup(tokens[1]);\n        }\n\n        /* Create a new string */\n        key_string = g_string_new(key);\n        ssid_ba = NULL;\n\n        /* Two (or more) tokens mean that the user entered a WPA-PWD key ... */\n        if( ((key_string->len) > WPA_KEY_MAX_CHAR_SIZE) || ((key_string->len) < WPA_KEY_MIN_CHAR_SIZE))\n        {\n            g_string_free(key_string, TRUE);\n\n            g_free(key);\n            g_free(ssid);\n\n            /* Free the array of strings */\n            g_strfreev(tokens);\n            return NULL;\n        }\n\n        if(ssid != NULL) /* more than two tokens found, means that the user specified the ssid */\n        {\n            ssid_ba = g_byte_array_new();\n            if (! uri_str_to_bytes(ssid, ssid_ba)) {\n                g_string_free(key_string, TRUE);\n                g_byte_array_free(ssid_ba, TRUE);\n                g_free(key);\n                g_free(ssid);\n                /* Free the array of strings */\n                g_strfreev(tokens);\n                return NULL;\n            }\n\n            if(ssid_ba->len > WPA_SSID_MAX_CHAR_SIZE)\n            {\n                g_string_free(key_string, TRUE);\n                g_byte_array_free(ssid_ba, TRUE);\n\n                g_free(key);\n                g_free(ssid);\n\n                /* Free the array of strings */\n                g_strfreev(tokens);\n                return NULL;\n            }\n        }\n\n        /* Key was correct!!! Create the new decryption_key_t ... */\n        dk = (decryption_key_t*)g_malloc(sizeof(decryption_key_t));\n\n        dk->type = AIRPDCAP_KEY_TYPE_WPA_PWD;\n        dk->key  = g_string_new(key);\n        dk->bits = 256; /* This is the length of the array pf bytes that will be generated using key+ssid ...*/\n        dk->ssid = byte_array_dup(ssid_ba); /* NULL if ssid_ba is NULL */\n\n        g_string_free(key_string, TRUE);\n        if (ssid_ba != NULL)\n            g_byte_array_free(ssid_ba, TRUE);\n\n        g_free(key);\n        g_free(ssid);\n\n        /* Free the array of strings */\n        g_strfreev(tokens);\n        return dk;\n\n    case AIRPDCAP_KEY_TYPE_WPA_PSK:\n\n        key_ba = g_byte_array_new();\n        res = hex_str_to_bytes(input_string, key_ba, FALSE);\n\n        /* Two tokens means that the user should have entered a WPA-BIN key ... */\n        if(!res || ((key_ba->len) != WPA_PSK_KEY_SIZE))\n        {\n            g_byte_array_free(key_ba, TRUE);\n\n            /* No ssid has been created ... */\n            return NULL;\n        }\n\n        /* Key was correct!!! Create the new decryption_key_t ... */\n        dk = (decryption_key_t*)g_malloc(sizeof(decryption_key_t));\n\n        dk->type = AIRPDCAP_KEY_TYPE_WPA_PSK;\n        dk->key  = g_string_new(input_string);\n        dk->bits = (guint) dk->key->len * 4;\n        dk->ssid = NULL;\n\n        g_byte_array_free(key_ba, TRUE);\n        return dk;\n    }\n\n    /* Type not supported */\n    return NULL;\n}\n\nvoid\nfree_key_string(decryption_key_t *dk)\n{\n    if (dk->key)\n        g_string_free(dk->key, TRUE);\n    if (dk->ssid)\n        g_byte_array_free(dk->ssid, TRUE);\n    g_free(dk);\n}\n\n/*\n * Returns a newly allocated string representing the given decryption_key_t\n * struct, or NULL if something is wrong...\n */\ngchar*\nget_key_string(decryption_key_t* dk)\n{\n    gchar* output_string = NULL;\n\n    if(dk == NULL || dk->key == NULL)\n        return NULL;\n\n    switch(dk->type) {\n        case AIRPDCAP_KEY_TYPE_WEP:\n            output_string = g_strdup(dk->key->str);\n            break;\n        case AIRPDCAP_KEY_TYPE_WPA_PWD:\n            if(dk->ssid == NULL)\n                output_string = g_strdup(dk->key->str);\n            else {\n                gchar* ssid = format_uri(NULL, dk->ssid, \":\");\n                output_string = g_strdup_printf(\"%s:%s\",\n                    dk->key->str, ssid);\n                wmem_free(NULL, ssid);\n            }\n            break;\n        case AIRPDCAP_KEY_TYPE_WPA_PMK:\n            output_string = g_strdup(dk->key->str);\n            break;\n        default:\n            return NULL;\n    }\n\n    return output_string;\n}\n\nstatic INT\nAirPDcapTDLSDeriveKey(\n    PAIRPDCAP_SEC_ASSOCIATION sa,\n    const guint8 *data,\n#if GCRYPT_VERSION_NUMBER >= 0x010600\n    guint offset_rsne,\n#else\n    guint offset_rsne _U_,\n#endif\n    guint offset_fte,\n#if GCRYPT_VERSION_NUMBER >= 0x010600\n    guint offset_timeout,\n#else\n    guint offset_timeout _U_,\n#endif\n    guint offset_link,\n#if GCRYPT_VERSION_NUMBER >= 0x010600\n    guint8 action)\n#else\n    guint8 action _U_)\n#endif\n{\n\n    gcry_md_hd_t sha256_handle;\n    gcry_md_hd_t hmac_handle;\n    const guint8 *snonce, *anonce, *initiator, *responder, *bssid;\n    guint8 key_input[32];\n#if GCRYPT_VERSION_NUMBER >= 0x010600\n    guint8 mic[16], seq_num = action + 1;\n    guint8 zeros[16] = { 0 };\n    gcry_mac_hd_t cmac_handle;\n    size_t cmac_len = 16;\n    size_t cmac_write_len;\n#endif\n\n    /* Get key input */\n    anonce = &data[offset_fte + 20];\n    snonce = &data[offset_fte + 52];\n\n    gcry_md_open (&sha256_handle, GCRY_MD_SHA256, 0);\n    if (memcmp(anonce, snonce, AIRPDCAP_WPA_NONCE_LEN) < 0) {\n        gcry_md_write(sha256_handle, anonce, AIRPDCAP_WPA_NONCE_LEN);\n        gcry_md_write(sha256_handle, snonce, AIRPDCAP_WPA_NONCE_LEN);\n    } else {\n        gcry_md_write(sha256_handle, snonce, AIRPDCAP_WPA_NONCE_LEN);\n        gcry_md_write(sha256_handle, anonce, AIRPDCAP_WPA_NONCE_LEN);\n    }\n    memcpy(key_input, gcry_md_read(sha256_handle, 0), 32);\n    gcry_md_close(sha256_handle);\n\n    /* Derive key */\n    bssid = &data[offset_link + 2];\n    initiator = &data[offset_link + 8];\n    responder = &data[offset_link + 14];\n    if (gcry_md_open(&hmac_handle, GCRY_MD_SHA256, GCRY_MD_FLAG_HMAC)) {\n        return AIRPDCAP_RET_UNSUCCESS;\n    }\n    if (gcry_md_setkey(hmac_handle, key_input, 32)) {\n        gcry_md_close(hmac_handle);\n        return AIRPDCAP_RET_UNSUCCESS;\n    }\n    gcry_md_putc(hmac_handle, 1);\n    gcry_md_putc(hmac_handle, 0);\n    gcry_md_write(hmac_handle, \"TDLS PMK\", 8);\n    if (memcmp(initiator, responder, AIRPDCAP_MAC_LEN) < 0) {\n          gcry_md_write(hmac_handle, initiator, AIRPDCAP_MAC_LEN);\n          gcry_md_write(hmac_handle, responder, AIRPDCAP_MAC_LEN);\n    } else {\n          gcry_md_write(hmac_handle, responder, AIRPDCAP_MAC_LEN);\n          gcry_md_write(hmac_handle, initiator, AIRPDCAP_MAC_LEN);\n    }\n    gcry_md_write(hmac_handle, bssid, AIRPDCAP_MAC_LEN);\n    gcry_md_putc(hmac_handle, 0);\n    gcry_md_putc(hmac_handle, 1);\n    memcpy(key_input, gcry_md_read(hmac_handle, 0), 32);\n    gcry_md_close(hmac_handle);\n\n    /* Check MIC */\n#if GCRYPT_VERSION_NUMBER >= 0x010600\n    if (gcry_mac_open(&cmac_handle, GCRY_MAC_CMAC_AES, 0, NULL)) {\n        return AIRPDCAP_RET_UNSUCCESS;\n    }\n    if (gcry_mac_setkey(cmac_handle, key_input, 16)) {\n        gcry_mac_close(cmac_handle);\n        return AIRPDCAP_RET_UNSUCCESS;\n    }\n    gcry_mac_write(cmac_handle, initiator, AIRPDCAP_MAC_LEN);\n    gcry_mac_write(cmac_handle, responder, AIRPDCAP_MAC_LEN);\n    gcry_mac_write(cmac_handle, &seq_num, 1);\n    gcry_mac_write(cmac_handle, &data[offset_link], data[offset_link + 1] + 2);\n    gcry_mac_write(cmac_handle, &data[offset_rsne], data[offset_rsne + 1] + 2);\n    gcry_mac_write(cmac_handle, &data[offset_timeout], data[offset_timeout + 1] + 2);\n    gcry_mac_write(cmac_handle, &data[offset_fte], 4);\n    gcry_mac_write(cmac_handle, zeros, 16);\n    cmac_write_len = data[offset_fte + 1] + 2;\n    if (cmac_write_len < 20) {\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapTDLSDeriveKey\", \"Bad MAC len\", AIRPDCAP_DEBUG_LEVEL_3);\n        gcry_mac_close(cmac_handle);\n        return AIRPDCAP_RET_UNSUCCESS;\n    }\n    gcry_mac_write(cmac_handle, &data[offset_fte + 20], cmac_write_len - 20);\n    if (gcry_mac_read(cmac_handle, mic, &cmac_len) != GPG_ERR_NO_ERROR) {\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapTDLSDeriveKey\", \"MAC read error\", AIRPDCAP_DEBUG_LEVEL_3);\n        gcry_mac_close(cmac_handle);\n        return AIRPDCAP_RET_UNSUCCESS;\n    }\n    if (memcmp(mic, &data[offset_fte + 4], 16)) {\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapTDLSDeriveKey\", \"MIC verification failed\", AIRPDCAP_DEBUG_LEVEL_3);\n        gcry_mac_close(cmac_handle);\n        return AIRPDCAP_RET_UNSUCCESS;\n    }\n    gcry_mac_close(cmac_handle);\n#else\n    AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapTDLSDeriveKey\", \"MIC verification failed, need libgcrypt >= 1.6\", AIRPDCAP_DEBUG_LEVEL_3);\n    return AIRPDCAP_RET_UNSUCCESS;\n#endif\n    memcpy(AIRPDCAP_GET_TK(sa->wpa.ptk), &key_input[16], 16);\n    memcpy(sa->wpa.nonce, snonce, AIRPDCAP_WPA_NONCE_LEN);\n    sa->validKey = TRUE;\n    sa->wpa.key_ver = AIRPDCAP_WPA_KEY_VER_AES_CCMP;\n    AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapTDLSDeriveKey\", \"MIC verified\", AIRPDCAP_DEBUG_LEVEL_3);\n    return  AIRPDCAP_RET_SUCCESS;\n}\n\n\n#ifdef __cplusplus\n}\n#endif\n\n/****************************************************************************/\n\n/*\n * Editor modelines\n *\n * Local Variables:\n * c-basic-offset: 4\n * tab-width: 8\n * indent-tabs-mode: nil\n * End:\n *\n * ex: set shiftwidth=4 tabstop=8 expandtab:\n * :indentSize=4:tabSize=8:noTabs=true:\n */\n", "patch": "@@ -571,7 +571,7 @@ static INT AirPDcapScanForKeys(\n \n         /* get and check the body length (IEEE 802.1X-2004, pg. 25) */\n         bodyLength=pntoh16(data+offset+2);\n-        if ((tot_len-offset-4) < bodyLength) { /* Only check if frame is long enough for eapol header, ignore tailing garbage, see bug 9065 */\n+        if (((tot_len-offset-4) < bodyLength) || (bodyLength < sizeof(EAPOL_RSN_KEY))) { /* Only check if frame is long enough for eapol header, ignore tailing garbage, see bug 9065 */\n             AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"EAPOL body too short\", AIRPDCAP_DEBUG_LEVEL_3);\n             return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n         }", "file_path": "files/2016_8\\40", "file_language": "c", "file_name": "epan/crypt/airpdcap.c", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}], "outdated": 0}
{"index": 9, "cve_id": "CVE-2016-5353", "cwe_id": ["CWE-20"], "cve_language": "C", "cve_description": "epan/dissectors/packet-umts_fp.c in the UMTS FP dissector in Wireshark 1.12.x before 1.12.12 and 2.x before 2.0.4 mishandles the reserved C/T value, which allows remote attackers to cause a denial of service (application crash) via a crafted packet.", "cvss": "5.9", "publish_date": "August 7, 2016", "AV": "NETWORK", "AC": "HIGH", "PR": "NONE", "UI": "NONE", "S": "UNCHANGED", "C": "NONE", "I": "NONE", "A": "HIGH", "commit_id": "7d7190695ce2ff269fdffb04e87139995cde21f4", "commit_message": "UMTS_FP: fix handling reserved C/T value\n\nThe spec puts the reserved value at 0xf but our internal table has 'unknown' at\n0; since all the other values seem to be offset-by-one, just take the modulus\n0xf to avoid running off the end of the table.\n\nBug: 12191\nChange-Id: I83c8fb66797bbdee52a2246fb1eea6e37cbc7eb0\nReviewed-on: https://code.wireshark.org/review/15722\nReviewed-by: Evan Huus <eapache@gmail.com>\nPetri-Dish: Evan Huus <eapache@gmail.com>\nTested-by: Petri Dish Buildbot <buildbot-no-reply@wireshark.org>\nReviewed-by: Michael Mann <mmann78@netscape.net>", "commit_date": "2016-06-05T02:39:31Z", "project": "wireshark/wireshark", "url": "https://api.github.com/repos/wireshark/wireshark/commits/7d7190695ce2ff269fdffb04e87139995cde21f4", "html_url": "https://github.com/wireshark/wireshark/commit/7d7190695ce2ff269fdffb04e87139995cde21f4", "windows_before": "", "windows_after": "", "parents": [{"commit_id_before": "b84b3f9f1d8577255a9d83c81277ebc53bcac68d", "url_before": "https://api.github.com/repos/wireshark/wireshark/commits/b84b3f9f1d8577255a9d83c81277ebc53bcac68d", "html_url_before": "https://github.com/wireshark/wireshark/commit/b84b3f9f1d8577255a9d83c81277ebc53bcac68d"}], "details": [{"raw_url": "https://github.com/wireshark/wireshark/raw/7d7190695ce2ff269fdffb04e87139995cde21f4/epan/dissectors/packet-umts_fp.c", "code": "/* packet-umts_fp.c\n * Routines for UMTS FP disassembly\n *\n * Martin Mathieson\n *\n * Wireshark - Network traffic analyzer\n * By Gerald Combs <gerald@wireshark.org>\n * Copyright 1998 Gerald Combs\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version 2\n * of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */\n\n#include \"config.h\"\n\n#include <epan/packet.h>\n#include <epan/expert.h>\n#include <epan/prefs.h>\n#include <epan/uat.h>\n#include <epan/conversation.h>\n#include <epan/addr_resolv.h>\n#include <epan/proto_data.h>\n\n#include <wsutil/crc7.h> /* For FP data header and control frame CRC. */\n#include <wsutil/crc16-plain.h> /* For FP Payload CRC. */\n#include <wsutil/crc11.h> /* For FP EDCH header CRC. */\n\n#include \"packet-umts_fp.h\"\n#include \"packet-nbap.h\"\n#include \"packet-rrc.h\"\n\n/* The Frame Protocol (FP) is described in:\n * 3GPP TS 25.427 (for dedicated channels)\n * 3GPP TS 25.435 (for common/shared channels)\n *\n * TODO:\n *  - IUR interface-specific formats\n *  - do CRC verification before further parsing\n *    - Set the logical channel properly for non multiplexed, channels\n *     for channels that doesn't have the C/T flag! This should be based\n * on the RRC message RadioBearerSetup.\n */\nvoid proto_register_fp(void);\nvoid proto_reg_handoff_fp(void);\n\n\n#define UMTS_FP_IPV4 1\n#define UMTS_FP_IPV6 2\n\n/* Initialize the protocol and registered fields. */\n\nint proto_fp = -1;\nextern int proto_umts_mac;\nextern int proto_rlc;\n\nstatic int hf_fp_release = -1;\nstatic int hf_fp_release_version = -1;\nstatic int hf_fp_release_year = -1;\nstatic int hf_fp_release_month = -1;\nstatic int hf_fp_channel_type = -1;\nstatic int hf_fp_division = -1;\nstatic int hf_fp_direction = -1;\nstatic int hf_fp_ddi_config = -1;\nstatic int hf_fp_ddi_config_ddi = -1;\nstatic int hf_fp_ddi_config_macd_pdu_size = -1;\n\nstatic int hf_fp_header_crc = -1;\nstatic int hf_fp_ft = -1;\nstatic int hf_fp_cfn = -1;\nstatic int hf_fp_pch_cfn = -1;\nstatic int hf_fp_pch_toa = -1;\nstatic int hf_fp_cfn_control = -1;\nstatic int hf_fp_toa = -1;\nstatic int hf_fp_tfi = -1;\nstatic int hf_fp_usch_tfi = -1;\nstatic int hf_fp_cpch_tfi = -1;\nstatic int hf_fp_propagation_delay = -1;\nstatic int hf_fp_tb = -1;\nstatic int hf_fp_chan_zero_tbs = -1;\nstatic int hf_fp_received_sync_ul_timing_deviation = -1;\nstatic int hf_fp_pch_pi = -1;\nstatic int hf_fp_pch_tfi = -1;\nstatic int hf_fp_fach_tfi = -1;\nstatic int hf_fp_transmit_power_level = -1;\nstatic int hf_fp_paging_indication_bitmap = -1;\nstatic int hf_fp_pdsch_set_id = -1;\nstatic int hf_fp_rx_timing_deviation = -1;\nstatic int hf_fp_dch_e_rucch_flag = -1;\nstatic int hf_fp_dch_control_frame_type = -1;\nstatic int hf_fp_dch_rx_timing_deviation = -1;\nstatic int hf_fp_quality_estimate = -1;\nstatic int hf_fp_payload_crc = -1;\nstatic int hf_fp_edch_header_crc = -1;\nstatic int hf_fp_edch_fsn = -1;\nstatic int hf_fp_edch_subframe = -1;\nstatic int hf_fp_edch_number_of_subframes = -1;\nstatic int hf_fp_edch_harq_retransmissions = -1;\nstatic int hf_fp_edch_subframe_number = -1;\nstatic int hf_fp_edch_number_of_mac_es_pdus = -1;\nstatic int hf_fp_edch_ddi = -1;\nstatic int hf_fp_edch_subframe_header = -1;\nstatic int hf_fp_edch_number_of_mac_d_pdus = -1;\nstatic int hf_fp_edch_pdu_padding = -1;\nstatic int hf_fp_edch_tsn = -1;\nstatic int hf_fp_edch_mac_es_pdu = -1;\n\nstatic int hf_fp_edch_user_buffer_size = -1;\nstatic int hf_fp_edch_no_macid_sdus = -1;\nstatic int hf_fp_edch_number_of_mac_is_pdus = -1;\nstatic int hf_fp_edch_mac_is_pdu = -1;\n\nstatic int hf_fp_edch_e_rnti = -1;\nstatic int hf_fp_edch_macis_descriptors = -1;\nstatic int hf_fp_edch_macis_lchid = -1;\nstatic int hf_fp_edch_macis_length = -1;\nstatic int hf_fp_edch_macis_flag = -1;\n\nstatic int hf_fp_frame_seq_nr = -1;\nstatic int hf_fp_hsdsch_pdu_block_header = -1;\n/* static int hf_fp_hsdsch_pdu_block = -1; */\nstatic int hf_fp_flush = -1;\nstatic int hf_fp_fsn_drt_reset = -1;\nstatic int hf_fp_drt_indicator = -1;\nstatic int hf_fp_fach_indicator = -1;\nstatic int hf_fp_total_pdu_blocks = -1;\nstatic int hf_fp_drt = -1;\nstatic int hf_fp_hrnti = -1;\nstatic int hf_fp_rach_measurement_result = -1;\nstatic int hf_fp_lchid = -1;\nstatic int hf_fp_pdu_length_in_block = -1;\nstatic int hf_fp_pdus_in_block = -1;\nstatic int hf_fp_cmch_pi = -1;\nstatic int hf_fp_user_buffer_size = -1;\nstatic int hf_fp_hsdsch_credits = -1;\nstatic int hf_fp_hsdsch_max_macd_pdu_len = -1;\nstatic int hf_fp_hsdsch_max_macdc_pdu_len = -1;\nstatic int hf_fp_hsdsch_interval = -1;\nstatic int hf_fp_hsdsch_calculated_rate = -1;\nstatic int hf_fp_hsdsch_unlimited_rate = -1;\nstatic int hf_fp_hsdsch_repetition_period = -1;\nstatic int hf_fp_hsdsch_data_padding = -1;\nstatic int hf_fp_hsdsch_new_ie_flags = -1;\nstatic int hf_fp_hsdsch_new_ie_flag[8] = {-1, -1, -1, -1, -1, -1, -1, -1};\nstatic int hf_fp_hsdsch_drt = -1;\nstatic int hf_fp_hsdsch_entity = -1;\nstatic int hf_fp_hsdsch_physical_layer_category = -1;\nstatic int hf_fp_timing_advance = -1;\nstatic int hf_fp_num_of_pdu = -1;\nstatic int hf_fp_mac_d_pdu_len = -1;\nstatic int hf_fp_mac_d_pdu = -1;\nstatic int hf_fp_data = -1;\nstatic int hf_fp_crcis = -1;\nstatic int hf_fp_crci[8] = {-1, -1, -1, -1, -1, -1, -1, -1};\nstatic int hf_fp_common_control_frame_type = -1;\nstatic int hf_fp_t1 = -1;\nstatic int hf_fp_t2 = -1;\nstatic int hf_fp_t3 = -1;\nstatic int hf_fp_ul_sir_target = -1;\nstatic int hf_fp_pusch_set_id = -1;\nstatic int hf_fp_activation_cfn = -1;\nstatic int hf_fp_duration = -1;\nstatic int hf_fp_power_offset = -1;\nstatic int hf_fp_code_number = -1;\nstatic int hf_fp_spreading_factor = -1;\nstatic int hf_fp_mc_info = -1;\n\nstatic int hf_fp_rach_new_ie_flags = -1;\nstatic int hf_fp_rach_new_ie_flag_unused[7] = {-1, -1, -1, -1, -1, -1, -1 };\nstatic int hf_fp_rach_ext_propagation_delay_present = -1;\nstatic int hf_fp_rach_cell_portion_id_present = -1;\nstatic int hf_fp_rach_angle_of_arrival_present = -1;\nstatic int hf_fp_rach_ext_rx_sync_ul_timing_deviation_present = -1;\nstatic int hf_fp_rach_ext_rx_timing_deviation_present = -1;\n\nstatic int hf_fp_cell_portion_id = -1;\nstatic int hf_fp_ext_propagation_delay = -1;\nstatic int hf_fp_angle_of_arrival = -1;\nstatic int hf_fp_ext_received_sync_ul_timing_deviation = -1;\n\nstatic int hf_fp_radio_interface_parameter_update_flag[5] = {-1, -1, -1, -1, -1};\nstatic int hf_fp_dpc_mode = -1;\nstatic int hf_fp_tpc_po = -1;\nstatic int hf_fp_multiple_rl_set_indicator = -1;\nstatic int hf_fp_max_ue_tx_pow = -1;\nstatic int hf_fp_congestion_status = -1;\nstatic int hf_fp_e_rucch_present = -1;\nstatic int hf_fp_extended_bits_present = -1;\nstatic int hf_fp_extended_bits = -1;\nstatic int hf_fp_spare_extension = -1;\nstatic int hf_fp_ul_setup_frame = -1;\nstatic int hf_fp_dl_setup_frame = -1;\n\n/* Subtrees. */\nstatic int ett_fp = -1;\nstatic int ett_fp_release = -1;\nstatic int ett_fp_data = -1;\nstatic int ett_fp_crcis = -1;\nstatic int ett_fp_ddi_config = -1;\nstatic int ett_fp_edch_subframe_header = -1;\nstatic int ett_fp_edch_subframe = -1;\nstatic int ett_fp_edch_maces = -1;\nstatic int ett_fp_edch_macis_descriptors = -1;\nstatic int ett_fp_hsdsch_new_ie_flags = -1;\nstatic int ett_fp_rach_new_ie_flags = -1;\nstatic int ett_fp_hsdsch_pdu_block_header = -1;\n\nstatic expert_field ei_fp_hsdsch_common_experimental_support = EI_INIT;\nstatic expert_field ei_fp_hsdsch_common_t3_not_implemented = EI_INIT;\nstatic expert_field ei_fp_channel_type_unknown = EI_INIT;\nstatic expert_field ei_fp_ddi_not_defined = EI_INIT;\nstatic expert_field ei_fp_stop_hsdpa_transmission = EI_INIT;\nstatic expert_field ei_fp_hsdsch_entity_not_specified = EI_INIT;\nstatic expert_field ei_fp_expecting_tdd = EI_INIT;\nstatic expert_field ei_fp_bad_payload_checksum = EI_INIT;\nstatic expert_field ei_fp_e_rnti_t2_edch_frames = EI_INIT;\nstatic expert_field ei_fp_crci_no_subdissector = EI_INIT;\nstatic expert_field ei_fp_timing_adjustmentment_reported = EI_INIT;\nstatic expert_field ei_fp_mac_is_sdus_miscount = EI_INIT;\nstatic expert_field ei_fp_maybe_srb = EI_INIT;\nstatic expert_field ei_fp_transport_channel_type_unknown = EI_INIT;\nstatic expert_field ei_fp_unable_to_locate_ddi_entry = EI_INIT;\nstatic expert_field ei_fp_e_rnti_first_entry = EI_INIT;\nstatic expert_field ei_fp_bad_header_checksum = EI_INIT;\nstatic expert_field ei_fp_crci_error_bit_set_for_tb = EI_INIT;\nstatic expert_field ei_fp_spare_extension = EI_INIT;\nstatic expert_field ei_fp_no_per_frame_info = EI_INIT;\n\nstatic dissector_handle_t rlc_bcch_handle;\nstatic dissector_handle_t mac_fdd_dch_handle;\nstatic dissector_handle_t mac_fdd_rach_handle;\nstatic dissector_handle_t mac_fdd_fach_handle;\nstatic dissector_handle_t mac_fdd_pch_handle;\nstatic dissector_handle_t mac_fdd_edch_handle;\nstatic dissector_handle_t mac_fdd_edch_type2_handle;\nstatic dissector_handle_t mac_fdd_hsdsch_handle;\nstatic dissector_handle_t fp_handle;\n\nstatic proto_tree *top_level_tree = NULL;\n\n/* Variables used for preferences */\nstatic gboolean preferences_call_mac_dissectors = TRUE;\nstatic gboolean preferences_show_release_info = TRUE;\nstatic gboolean preferences_payload_checksum = TRUE;\nstatic gboolean preferences_header_checksum = TRUE;\n\n#define UMTS_FP_USE_UAT 1\n\n#ifdef UMTS_FP_USE_UAT\n/* UAT entry structure. */\ntypedef struct {\n   guint8 protocol;\n   gchar *srcIP;\n   guint16 src_port;\n   gchar *dstIP;\n   guint16 dst_port;\n   guint8 interface_type;\n   guint8 division;\n   guint8 rlc_mode;\n   guint8 channel_type;\n} uat_umts_fp_ep_and_ch_record_t;\n\nstatic uat_umts_fp_ep_and_ch_record_t *uat_umts_fp_ep_and_ch_records = NULL;\n\nstatic uat_t *umts_fp_uat = NULL;\nstatic guint  num_umts_fp_ep_and_ch_items = 0;\n\n#endif /* UMTS_FP_USE_UAT */\n/* E-DCH (T1) channel header information */\nstruct edch_t1_subframe_info\n{\n    guint8  subframe_number;\n    guint8  number_of_mac_es_pdus;\n    guint8  ddi[64];\n    guint16 number_of_mac_d_pdus[64];\n};\n\n/* E-DCH (T2) channel header information */\nstruct edch_t2_subframe_info\n{\n    guint8  subframe_number;\n    guint8  number_of_mac_is_pdus;\n    guint8  number_of_mac_is_sdus[16];\n    guint8  mac_is_lchid[16][16];\n    guint16 mac_is_length[16][16];\n};\n\n\nstatic const value_string channel_type_vals[] =\n{\n    { CHANNEL_RACH_FDD,         \"RACH_FDD\" },\n    { CHANNEL_RACH_TDD,         \"RACH_TDD\" },\n    { CHANNEL_FACH_FDD,         \"FACH_FDD\" },\n    { CHANNEL_FACH_TDD,         \"FACH_TDD\" },\n    { CHANNEL_DSCH_FDD,         \"DSCH_FDD\" },\n    { CHANNEL_DSCH_TDD,         \"DSCH_TDD\" },\n    { CHANNEL_USCH_TDD_384,     \"USCH_TDD_384\" },\n    { CHANNEL_USCH_TDD_128,     \"USCH_TDD_128\" },\n    { CHANNEL_PCH,              \"PCH\" },\n    { CHANNEL_CPCH,             \"CPCH\" },\n    { CHANNEL_BCH,              \"BCH\" },\n    { CHANNEL_DCH,              \"DCH\" },\n    { CHANNEL_HSDSCH,           \"HSDSCH\" },\n    { CHANNEL_IUR_CPCHF,        \"IUR CPCHF\" },\n    { CHANNEL_IUR_FACH,         \"IUR FACH\" },\n    { CHANNEL_IUR_DSCH,         \"IUR DSCH\" },\n    { CHANNEL_EDCH,             \"EDCH\" },\n    { CHANNEL_RACH_TDD_128,     \"RACH_TDD_128\" },\n    { CHANNEL_HSDSCH_COMMON,    \"HSDSCH-COMMON\" },\n    { CHANNEL_HSDSCH_COMMON_T3, \"HSDSCH-COMMON-T3\" },\n    { CHANNEL_EDCH_COMMON,      \"EDCH-COMMON\"},\n    { 0, NULL }\n};\n\nstatic const value_string division_vals[] =\n{\n    { Division_FDD,      \"FDD\"},\n    { Division_TDD_384,  \"TDD-384\"},\n    { Division_TDD_128,  \"TDD-128\"},\n    { Division_TDD_768,  \"TDD-768\"},\n    { 0, NULL }\n};\n\n\nstatic const value_string data_control_vals[] = {\n    { 0,   \"Data\" },\n    { 1,   \"Control\" },\n    { 0,   NULL }\n};\n\nstatic const value_string direction_vals[] = {\n    { 0,   \"Downlink\" },\n    { 1,   \"Uplink\" },\n    { 0,   NULL }\n};\n\nstatic const value_string crci_vals[] = {\n    { 0,   \"Correct\" },\n    { 1,   \"Not correct\" },\n    { 0,   NULL }\n};\n\nstatic const value_string paging_indication_vals[] = {\n    { 0,   \"no PI-bitmap in payload\" },\n    { 1,   \"PI-bitmap in payload\" },\n    { 0,   NULL }\n};\n\nstatic const value_string spreading_factor_vals[] = {\n    { 0,   \"4\"},\n    { 1,   \"8\"},\n    { 2,   \"16\"},\n    { 3,   \"32\"},\n    { 4,   \"64\"},\n    { 5,   \"128\"},\n    { 6,   \"256\"},\n    { 0,   NULL }\n};\n\nstatic const value_string congestion_status_vals[] = {\n    { 0,   \"No TNL congestion\"},\n    { 1,   \"Reserved for future use\"},\n    { 2,   \"TNL congestion - detected by delay build-up\"},\n    { 3,   \"TNL congestion - detected by frame loss\"},\n    { 0,   NULL }\n};\n\nstatic const value_string e_rucch_flag_vals[] = {\n    { 0,   \"Conventional E-RUCCH reception\" },\n    { 1,   \"TA Request reception\" },\n    { 0,   NULL }\n};\n\nstatic const value_string hsdshc_mac_entity_vals[] = {\n    { entity_not_specified,    \"Unspecified (assume MAC-hs)\" },\n    { hs,                      \"MAC-hs\" },\n    { ehs,                     \"MAC-ehs\" },\n    { 0,   NULL }\n};\n\n/* TODO: add and use */\n#if 0\nstatic const value_string segmentation_status_vals[] = {\n    { 0,    \"\" },\n    { 1,    \"\" },\n    { 2,    \"\" },\n    { 3,    \"\" },\n    { 0,   NULL }\n};\n#endif\n\nstatic const value_string lchid_vals[] = {\n    {  0,   \"Logical Channel 1\" },\n    {  1,   \"Logical Channel 2\" },\n    {  2,   \"Logical Channel 3\" },\n    {  3,   \"Logical Channel 4\" },\n    {  4,   \"Logical Channel 5\" },\n    {  5,   \"Logical Channel 6\" },\n    {  6,   \"Logical Channel 7\" },\n    {  7,   \"Logical Channel 8\" },\n    {  8,   \"Logical Channel 9\" },\n    {  9,   \"Logical Channel 10\" },\n    { 10,   \"Logical Channel 11\" },\n    { 11,   \"Logical Channel 12\" },\n    { 12,   \"Logical Channel 13\" },\n    { 13,   \"Logical Channel 14\" },\n    { 14,   \"CCCH (SRB0)\" },\n    { 15,   \"E-RNTI being included (FDD only)\" },\n    { 0,   NULL }\n};\n\n/* Dedicated control types */\n#define DCH_OUTER_LOOP_POWER_CONTROL            1\n#define DCH_TIMING_ADJUSTMENT                   2\n#define DCH_DL_SYNCHRONISATION                  3\n#define DCH_UL_SYNCHRONISATION                  4\n\n#define DCH_DL_NODE_SYNCHRONISATION             6\n#define DCH_UL_NODE_SYNCHRONISATION             7\n#define DCH_RX_TIMING_DEVIATION                 8\n#define DCH_RADIO_INTERFACE_PARAMETER_UPDATE    9\n#define DCH_TIMING_ADVANCE                     10\n#define DCH_TNL_CONGESTION_INDICATION          11\n\nstatic const value_string dch_control_frame_type_vals[] = {\n    { DCH_OUTER_LOOP_POWER_CONTROL,         \"OUTER LOOP POWER CONTROL\" },\n    { DCH_TIMING_ADJUSTMENT,                \"TIMING ADJUSTMENT\" },\n    { DCH_DL_SYNCHRONISATION,               \"DL SYNCHRONISATION\" },\n    { DCH_UL_SYNCHRONISATION,               \"UL SYNCHRONISATION\" },\n    { 5,                                    \"Reserved Value\" },\n    { DCH_DL_NODE_SYNCHRONISATION,          \"DL NODE SYNCHRONISATION\" },\n    { DCH_UL_NODE_SYNCHRONISATION,          \"UL NODE SYNCHRONISATION\" },\n    { DCH_RX_TIMING_DEVIATION,              \"RX TIMING DEVIATION\" },\n    { DCH_RADIO_INTERFACE_PARAMETER_UPDATE, \"RADIO INTERFACE PARAMETER UPDATE\" },\n    { DCH_TIMING_ADVANCE,                   \"TIMING ADVANCE\" },\n    { DCH_TNL_CONGESTION_INDICATION,        \"TNL CONGESTION INDICATION\" },\n    { 0,   NULL }\n};\n\n\n/* Common channel control types */\n#define COMMON_OUTER_LOOP_POWER_CONTROL                1\n#define COMMON_TIMING_ADJUSTMENT                       2\n#define COMMON_DL_SYNCHRONISATION                      3\n#define COMMON_UL_SYNCHRONISATION                      4\n\n#define COMMON_DL_NODE_SYNCHRONISATION                 6\n#define COMMON_UL_NODE_SYNCHRONISATION                 7\n#define COMMON_DYNAMIC_PUSCH_ASSIGNMENT                8\n#define COMMON_TIMING_ADVANCE                          9\n#define COMMON_HS_DSCH_Capacity_Request               10\n#define COMMON_HS_DSCH_Capacity_Allocation            11\n#define COMMON_HS_DSCH_Capacity_Allocation_Type_2     12\n\nstatic const value_string common_control_frame_type_vals[] = {\n    { COMMON_OUTER_LOOP_POWER_CONTROL,            \"OUTER LOOP POWER CONTROL\" },\n    { COMMON_TIMING_ADJUSTMENT,                   \"TIMING ADJUSTMENT\" },\n    { COMMON_DL_SYNCHRONISATION,                  \"DL SYNCHRONISATION\" },\n    { COMMON_UL_SYNCHRONISATION,                  \"UL SYNCHRONISATION\" },\n    { 5,                                          \"Reserved Value\" },\n    { COMMON_DL_NODE_SYNCHRONISATION,             \"DL NODE SYNCHRONISATION\" },\n    { COMMON_UL_NODE_SYNCHRONISATION,             \"UL NODE SYNCHRONISATION\" },\n    { COMMON_DYNAMIC_PUSCH_ASSIGNMENT,            \"DYNAMIC PUSCH ASSIGNMENT\" },\n    { COMMON_TIMING_ADVANCE,                      \"TIMING ADVANCE\" },\n    { COMMON_HS_DSCH_Capacity_Request,            \"HS-DSCH Capacity Request\" },\n    { COMMON_HS_DSCH_Capacity_Allocation,         \"HS-DSCH Capacity Allocation\" },\n    { COMMON_HS_DSCH_Capacity_Allocation_Type_2,  \"HS-DSCH Capacity Allocation Type 2\" },\n    { 0,   NULL }\n};\n\n/* 0 to 7*/\nstatic const guint8 hsdsch_macdflow_id_rlc_map[] = {\n\tRLC_UM,                   /*0 SRB */\n\tRLC_AM,                   /*1 Interactive PS*/\n\tRLC_AM,                   /*2 Interatcive PS*/\n\tRLC_UNKNOWN_MODE,         /*3 ???*/\n\tRLC_AM,                   /*4 Streaming PS*/\n\tRLC_UNKNOWN_MODE,\n\tRLC_UNKNOWN_MODE,\n\tRLC_UNKNOWN_MODE\n};\n\n/* Mapping hsdsch MACd-FlowId to MAC_CONTENT, basically flowid = 1 (0) => SRB*/\n/* 1 to 8*/\nstatic const guint8 hsdsch_macdflow_id_mac_content_map[] = {\n\tMAC_CONTENT_DCCH,\t/*1 SRB */\n\tMAC_CONTENT_PS_DTCH, /*2 Interactive PS*/\n\tMAC_CONTENT_PS_DTCH,\t/*3 Interatcive PS*/\n\tRLC_UNKNOWN_MODE, /*4 ???*/\n\tMAC_CONTENT_PS_DTCH,\t/*5 Streaming PS*/\n\tRLC_UNKNOWN_MODE,\n\tRLC_UNKNOWN_MODE,\n\tRLC_UNKNOWN_MODE\n\t};\n\n/* Make fake logical channel id's based on MACdFlow-ID's, \n* XXXX Bug 12121 expanded the number of entries to 8(+2),\n* not at all sure what the proper value should be 0xfF?\n*/\nstatic const guint8 fake_lchid_macd_flow[] = {1,9,14,11,0,12,0,0};\n\n/* Dissect message parts */\nstatic int dissect_tb_data(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\n                           int offset, struct fp_info *p_fp_info,\n                           dissector_handle_t *data_handle,\n                           void *data);\n\nstatic int dissect_macd_pdu_data(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\n                                 int offset, guint16 length, guint16 number_of_pdus, struct fp_info *p_fp_info,\n                                 void *data);\nstatic int dissect_macd_pdu_data_type_2(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\n                                        int offset, guint16 length, guint16 number_of_pdus, struct fp_info * fpi,\n                                        void *data);\n\nstatic int dissect_crci_bits(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\n                             fp_info *p_fp_info, int offset);\nstatic void dissect_spare_extension_and_crc(tvbuff_t *tvb, packet_info *pinfo,\n                                            proto_tree *tree, guint8 dch_crc_present,\n                                            int offset, guint header_length);\n/* Dissect common control messages */\nstatic int dissect_common_outer_loop_power_control(packet_info *pinfo, proto_tree *tree, tvbuff_t *tvb,\n                                                   int offset, struct fp_info *p_fp_info);\nstatic int dissect_common_timing_adjustment(packet_info *pinfo, proto_tree *tree, tvbuff_t *tvb,\n                                            int offset, struct fp_info *p_fp_info);\nstatic int dissect_common_dl_node_synchronisation(packet_info *pinfo, proto_tree *tree,\n                                                  tvbuff_t *tvb, int offset);\nstatic int dissect_common_ul_node_synchronisation(packet_info *pinfo, proto_tree *tree,\n                                                  tvbuff_t *tvb, int offset);\nstatic int dissect_common_dl_synchronisation(packet_info *pinfo, proto_tree *tree,\n                                            tvbuff_t *tvb, int offset,\n                                            struct fp_info *p_fp_info);\nstatic int dissect_common_ul_synchronisation(packet_info *pinfo, proto_tree *tree,\n                                            tvbuff_t *tvb, int offset,\n                                            struct fp_info *p_fp_info);\nstatic int dissect_common_timing_advance(packet_info *pinfo, proto_tree *tree,\n                                         tvbuff_t *tvb, int offset);\nstatic int dissect_hsdpa_capacity_request(packet_info *pinfo, proto_tree *tree,\n                                          tvbuff_t *tvb, int offset);\nstatic int dissect_hsdpa_capacity_allocation(packet_info *pinfo, proto_tree *tree,\n                                             tvbuff_t *tvb, int offset,\n                                             struct fp_info *p_fp_info);\nstatic int dissect_hsdpa_capacity_allocation_type_2(packet_info *pinfo, proto_tree *tree,\n                                                    tvbuff_t *tvb, int offset);\nstatic void dissect_common_control(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\n                                   int offset, struct fp_info *p_fp_info);\nstatic int dissect_common_dynamic_pusch_assignment(packet_info *pinfo, proto_tree *tree,\n                                                   tvbuff_t *tvb, int offset);\n\n/* Dissect common channel types */\nstatic void dissect_rach_channel_info(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\n                                      int offset, struct fp_info *p_fp_info,\n                                      void *data);\nstatic void dissect_fach_channel_info(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\n                                      int offset, struct fp_info *p_fp_info,\n                                      void *data);\nstatic void dissect_dsch_channel_info(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\n                                      int offset, struct fp_info *p_fp_info);\nstatic void dissect_usch_channel_info(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\n                                      int offset, struct fp_info *p_fp_info);\nstatic void dissect_pch_channel_info(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\n                                     int offset, struct fp_info *p_fp_info,\n                                     void *data);\nstatic void dissect_cpch_channel_info(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\n                                      int offset, struct fp_info *p_fp_info);\nstatic void dissect_bch_channel_info(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\n                                     int offset, struct fp_info *p_fp_info);\nstatic void dissect_iur_dsch_channel_info(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\n                                          int offset, struct fp_info *p_fp_info);\nstatic void dissect_hsdsch_channel_info(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\n                                        int offset, struct fp_info *p_fp_info,\n                                        void *data);\nstatic void dissect_hsdsch_type_2_channel_info(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\n                                               int offset, struct fp_info *p_fp_info,\n                                               void *data);\nstatic void dissect_hsdsch_common_channel_info(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\n                                               int offset,\n                                               struct fp_info *p_fp_info,\n                                               void *data);\n\n/* Dissect DCH control messages */\nstatic int dissect_dch_timing_adjustment(proto_tree *tree, packet_info *pinfo,\n                                         tvbuff_t *tvb, int offset);\nstatic int dissect_dch_rx_timing_deviation(packet_info *pinfo, proto_tree *tree, tvbuff_t *tvb, int offset,\n                                           struct fp_info *p_fp_info);\nstatic int dissect_dch_dl_synchronisation(proto_tree *tree, packet_info *pinfo,\n                                          tvbuff_t *tvb, int offset);\nstatic int dissect_dch_ul_synchronisation(proto_tree *tree, packet_info *pinfo,\n                                          tvbuff_t *tvb, int offset);\nstatic int dissect_dch_outer_loop_power_control(proto_tree *tree, packet_info *pinfo,\n                                                tvbuff_t *tvb, int offset);\nstatic int dissect_dch_dl_node_synchronisation(proto_tree *tree, packet_info *pinfo,\n                                               tvbuff_t *tvb, int offset);\nstatic int dissect_dch_ul_node_synchronisation(proto_tree *tree, packet_info *pinfo,\n                                               tvbuff_t *tvb, int offset);\nstatic int dissect_dch_radio_interface_parameter_update(proto_tree *tree, packet_info *pinfo,\n                                                        tvbuff_t *tvb, int offset);\nstatic int dissect_dch_timing_advance(proto_tree *tree, packet_info *pinfo,\n                                      tvbuff_t *tvb, int offset, struct fp_info *p_fp_info);\nstatic int dissect_dch_tnl_congestion_indication(proto_tree *tree, packet_info *pinfo,\n                                                 tvbuff_t *tvb, int offset);\n\n\nstatic void dissect_dch_control_frame(proto_tree *tree, packet_info *pinfo, tvbuff_t *tvb,\n                                      int offset, struct fp_info *p_fp_info);\n\n\n/* Dissect a DCH channel */\nstatic void dissect_dch_channel_info(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\n                                     int offset, struct fp_info *p_fp_info,\n                                     void *data);\n\n/* Dissect dedicated channels */\nstatic void dissect_e_dch_channel_info(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\n                                       int offset, struct fp_info *p_fp_info,\n                                       gboolean is_common, rlc_info  *rlcinf,\n                                       void *data);\n\nstatic void dissect_e_dch_t2_or_common_channel_info(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\n                                                    int offset, struct fp_info *p_fp_info,\n                                                    int number_of_subframes,\n                                                    gboolean is_common,\n                                                    guint16 header_crc,\n                                                    proto_item * header_crc_pi,\n                                                    void *data);\n\n/* Main dissection function */\nstatic int dissect_fp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data);\n\n/*\n * CRNC sends data downlink on uplink parameters.\n */\nvoid\nset_umts_fp_conv_data(conversation_t *conversation, umts_fp_conversation_info_t *umts_fp_conversation_info)\n{\n\n    if (conversation == NULL) {\n        return;\n     }\n\n    conversation_add_proto_data(conversation, proto_fp, umts_fp_conversation_info);\n}\n\n\nstatic int\nget_tb_count(struct fp_info *p_fp_info)\n{\n    int chan, tb_count = 0;\n    for (chan = 0; chan < p_fp_info->num_chans; chan++) {\n        tb_count += p_fp_info->chan_num_tbs[chan];\n    }\n    return tb_count;\n}\n\nstatic gboolean verify_control_frame_crc(tvbuff_t * tvb, packet_info * pinfo, proto_item * pi, guint16 frame_crc)\n{\n    guint8 crc = 0;\n    guint8 * data = NULL;\n    /* Get data. */\n    data = (guint8 *)tvb_memdup(wmem_packet_scope(), tvb, 0, tvb_reported_length(tvb));\n    /* Include only FT flag bit in CRC calculation. */\n    data[0] = data[0] & 1;\n    /* Calculate crc7 sum. */\n    crc = crc7update(0, data, tvb_reported_length(tvb));\n    crc = crc7finalize(crc); /* finalize crc */\n    if (frame_crc == crc) {\n        proto_item_append_text(pi, \" [correct]\");\n        return TRUE;\n    } else {\n        proto_item_append_text(pi, \" [incorrect, should be 0x%x]\", crc);\n        expert_add_info(pinfo, pi, &ei_fp_bad_header_checksum);\n        return FALSE;\n    }\n}\nstatic gboolean verify_header_crc(tvbuff_t * tvb, packet_info * pinfo, proto_item * pi, guint16 header_crc, guint header_length)\n{\n    guint8 crc = 0;\n    guint8 * data = NULL;\n    /* Get data of header with first byte removed. */\n    data = (guint8 *)tvb_memdup(wmem_packet_scope(), tvb, 1, header_length-1);\n    /* Calculate crc7 sum. */\n    crc = crc7update(0, data, header_length-1);\n    crc = crc7finalize(crc); /* finalize crc */\n    if (header_crc == crc) {\n        proto_item_append_text(pi, \" [correct]\");\n        return TRUE;\n    } else {\n        proto_item_append_text(pi, \" [incorrect, should be 0x%x]\", crc);\n        expert_add_info(pinfo, pi, &ei_fp_bad_header_checksum);\n        return FALSE;\n    }\n}\nstatic gboolean verify_header_crc_edch(tvbuff_t * tvb, packet_info * pinfo, proto_item * pi, guint16 header_crc, guint header_length)\n{\n    guint16 crc = 0;\n    guint8 * data = NULL;\n    /* First create new subset of header with first byte removed. */\n    tvbuff_t * headtvb = tvb_new_subset_length(tvb, 1, header_length-1);\n    /* Get data of header with first byte removed. */\n    data = (guint8 *)tvb_memdup(wmem_packet_scope(), headtvb, 0, header_length-1);\n    /* Remove first 4 bits of the remaining data which are Header CRC cont. */\n    data[0] = data[0] & 0x0f;\n    crc = crc11_307_noreflect_noxor(data, header_length-1);\n    if (header_crc == crc) {\n        proto_item_append_text(pi, \" [correct]\");\n        return TRUE;\n    } else {\n        proto_item_append_text(pi, \" [incorrect, should be 0x%x]\", crc);\n        expert_add_info(pinfo, pi, &ei_fp_bad_header_checksum);\n        return FALSE;\n    }\n}\n\n/* Dissect the TBs of a UL data frame*/\nstatic int\ndissect_tb_data(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\n                int offset, struct fp_info *p_fp_info,\n                dissector_handle_t *data_handle, void *data)\n{\n    int         chan, num_tbs   = 0;\n    int         bit_offset      = 0;\n    int         crci_bit_offset = (offset+1)<<3; /* Current offset + Quality estimate of 1 byte at the end*/\n    guint       data_bits       = 0;\n    guint8      crci_bit        = 0;\n    proto_item *tree_ti         = NULL;\n    proto_tree *data_tree       = NULL;\n    gboolean    dissected       = FALSE;\n\n    if (tree) {\n        /* Add data subtree */\n        tree_ti =  proto_tree_add_item(tree, hf_fp_data, tvb, offset, -1, ENC_NA);\n        proto_item_set_text(tree_ti, \"TB data for %u chans\", p_fp_info->num_chans);\n        data_tree = proto_item_add_subtree(tree_ti, ett_fp_data);\n    }\n\n    /* Calculate offset to CRCI bits */\n\n    if (p_fp_info->is_uplink) {\n        for (chan=0; chan < p_fp_info->num_chans; chan++) {\n            int n;\n            for (n=0; n < p_fp_info->chan_num_tbs[chan]; n++) {\n                /* Advance bit offset */\n                crci_bit_offset += p_fp_info->chan_tf_size[chan];\n                /* Pad out to next byte */\n                if (crci_bit_offset % 8) {\n                    crci_bit_offset += (8 - (crci_bit_offset % 8));\n                }\n            }\n        }\n    }\n    /* Now for the TB data */\n    for (chan=0; chan < p_fp_info->num_chans; chan++) {\n        int n;\n        p_fp_info->cur_chan = chan;    /*Set current channel?*/\n        /* Clearly show channels with no TBs */\n        if (p_fp_info->chan_num_tbs[chan] == 0) {\n            proto_item *no_tb_ti = proto_tree_add_uint(data_tree, hf_fp_chan_zero_tbs, tvb,\n                                                       offset+(bit_offset/8),\n                                                       0, chan+1);\n            proto_item_append_text(no_tb_ti, \" (of size %d)\",\n                                   p_fp_info->chan_tf_size[chan]);\n            PROTO_ITEM_SET_GENERATED(no_tb_ti);\n        }\n\n        /* Show TBs from non-empty channels */\n        pinfo->fd->subnum = chan; /* set subframe number to current TB */\n        for (n=0; n < p_fp_info->chan_num_tbs[chan]; n++) {\n\n            proto_item *ti;\n            p_fp_info->cur_tb = chan;    /*Set current transport block?*/\n            if (data_tree) {\n                ti = proto_tree_add_item(data_tree, hf_fp_tb, tvb,\n                                         offset + (bit_offset/8),\n                                         ((bit_offset % 8) + p_fp_info->chan_tf_size[chan] + 7) / 8,\n                                         ENC_NA);\n                proto_item_set_text(ti, \"TB (chan %u, tb %u, %u bits)\",\n                                    chan+1, n+1, p_fp_info->chan_tf_size[chan]);\n            }\n\n            if (preferences_call_mac_dissectors /*&& !rlc_is_ciphered(pinfo)*/ && data_handle &&\n                (p_fp_info->chan_tf_size[chan] > 0)) {\n                tvbuff_t *next_tvb;\n                proto_item *item;\n                /* If this is DL we should not care about crci bits (since they don't exists)*/\n                if (p_fp_info->is_uplink) {\n\n\n                    if ( p_fp_info->channel == CHANNEL_RACH_FDD) {    /*In RACH we don't have any QE field, hence go back 8 bits.*/\n                        crci_bit = tvb_get_bits8(tvb, crci_bit_offset+n-8, 1);\n                        item = proto_tree_add_item(data_tree, hf_fp_crci[n%8], tvb, (crci_bit_offset+n-8)/8, 1, ENC_BIG_ENDIAN);\n                        PROTO_ITEM_SET_GENERATED(item);\n                    } else {\n                        crci_bit = tvb_get_bits8(tvb, crci_bit_offset+n, 1);\n                        item = proto_tree_add_item(data_tree, hf_fp_crci[n%8], tvb, (crci_bit_offset+n)/8, 1, ENC_BIG_ENDIAN);\n                        PROTO_ITEM_SET_GENERATED(item);\n                    }\n                }\n\n                if (crci_bit == 0 || !p_fp_info->is_uplink) {\n                    next_tvb = tvb_new_subset(tvb, offset + bit_offset/8,\n                                              ((bit_offset % 8) + p_fp_info->chan_tf_size[chan] + 7) / 8, -1);\n\n\n                    /****************/\n                    /* TODO: maybe this decision can be based only on info available in fp_info */\n                    call_dissector_with_data(*data_handle, next_tvb, pinfo, top_level_tree, data);\n                    dissected = TRUE;\n                } else {\n                    proto_tree_add_expert(tree, pinfo, &ei_fp_crci_no_subdissector, tvb, offset + bit_offset/8,\n                                               ((bit_offset % 8) + p_fp_info->chan_tf_size[chan] + 7) / 8);\n                }\n\n            }\n            num_tbs++;\n\n            /* Advance bit offset */\n            bit_offset += p_fp_info->chan_tf_size[chan];\n            data_bits  += p_fp_info->chan_tf_size[chan];\n\n            /* Pad out to next byte */\n            if (bit_offset % 8) {\n                bit_offset += (8 - (bit_offset % 8));\n            }\n        }\n    }\n\n    if (dissected == FALSE) {\n        col_append_fstr(pinfo->cinfo, COL_INFO, \"(%u bits in %u tbs)\",\n                        data_bits, num_tbs);\n    }\n\n    /* Data tree should cover entire length */\n    if (data_tree) {\n        proto_item_set_len(tree_ti, bit_offset/8);\n        proto_item_append_text(tree_ti, \" (%u bits in %u tbs)\", data_bits, num_tbs);\n    }\n\n    /* Move offset past TBs (we know it's already padded out to next byte) */\n    offset += (bit_offset / 8);\n\n    return offset;\n}\n\n\n/* Dissect the MAC-d PDUs of an HS-DSCH (type 1) frame.\n   Length is in bits, and payload is offset by 4 bits of padding */\nstatic int\ndissect_macd_pdu_data(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\n                      int offset, guint16 length, guint16 number_of_pdus,\n                      struct fp_info *p_fp_info, void *data)\n{\n    int         pdu;\n    int         bit_offset = 0;\n    proto_item *pdus_ti    = NULL;\n    proto_tree *data_tree  = NULL;\n    gboolean    dissected  = FALSE;\n\n    /* Add data subtree */\n    if (tree) {\n        pdus_ti =  proto_tree_add_item(tree, hf_fp_data, tvb, offset, -1, ENC_NA);\n        proto_item_set_text(pdus_ti, \"%u MAC-d PDUs of %u bits\", number_of_pdus, length);\n        data_tree = proto_item_add_subtree(pdus_ti, ett_fp_data);\n    }\n\n    /* Now for the PDUs */\n    for (pdu=0; pdu < number_of_pdus; pdu++) {\n        proto_item *pdu_ti;\n\n        if (data_tree) {\n            /* Show 4 bits padding at start of PDU */\n            proto_tree_add_item(data_tree, hf_fp_hsdsch_data_padding, tvb, offset+(bit_offset/8), 1, ENC_BIG_ENDIAN);\n\n        }\n        bit_offset += 4;\n\n        /* Data bytes! */\n        if (data_tree) {\n            pinfo->fd->subnum = pdu; /* set subframe number to current TB */\n            p_fp_info->cur_tb = pdu;    /*Set TB (PDU) index correctly*/\n            pdu_ti = proto_tree_add_item(data_tree, hf_fp_mac_d_pdu, tvb,\n                                         offset + (bit_offset/8),\n                                         ((bit_offset % 8) + length + 7) / 8,\n                                         ENC_NA);\n            proto_item_set_text(pdu_ti, \"MAC-d PDU (PDU %u)\", pdu+1);\n        }\n        if (preferences_call_mac_dissectors /*&& !rlc_is_ciphered(pinfo)*/) {\n            tvbuff_t *next_tvb;\n            next_tvb = tvb_new_subset(tvb, offset + bit_offset/8,\n                                      ((bit_offset % 8) + length + 7)/8, -1);\n            call_dissector_with_data(mac_fdd_hsdsch_handle, next_tvb, pinfo, top_level_tree, data);\n            dissected = TRUE;\n        }\n\n        /* Advance bit offset */\n        bit_offset += length;\n\n        /* Pad out to next byte */\n        if (bit_offset % 8) {\n            bit_offset += (8 - (bit_offset % 8));\n        }\n    }\n\n    /* Data tree should cover entire length */\n    proto_item_set_len(pdus_ti, bit_offset/8);\n\n    /* Move offset past PDUs (we know it's already padded out to next byte) */\n    offset += (bit_offset / 8);\n\n    /* Show summary in info column */\n    if (dissected == FALSE) {\n        col_append_fstr(pinfo->cinfo, COL_INFO, \"   %u PDUs of %u bits\",\n                        number_of_pdus, length);\n    }\n\n    return offset;\n}\n\n\n/* Dissect the MAC-d PDUs of an HS-DSCH (type 2) frame.\n   Length is in bytes, and payload is byte-aligned (no padding) */\nstatic int\ndissect_macd_pdu_data_type_2(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\n                             int offset, guint16 length, guint16 number_of_pdus,\n                             struct fp_info *fpi, void *data)\n{\n    int         pdu;\n    proto_item *pdus_ti      = NULL;\n    proto_tree *data_tree    = NULL;\n    int         first_offset = offset;\n    gboolean    dissected    = FALSE;\n\n    /* Add data subtree */\n    if (tree) {\n        pdus_ti =  proto_tree_add_item(tree, hf_fp_data, tvb, offset, -1, ENC_NA);\n        proto_item_set_text(pdus_ti, \"%u MAC-d PDUs of %u bytes\", number_of_pdus, length);\n        data_tree = proto_item_add_subtree(pdus_ti, ett_fp_data);\n    }\n\n    /* Now for the PDUs */\n    for (pdu=0; pdu < number_of_pdus; pdu++) {\n        proto_item *pdu_ti;\n\n        /* Data bytes! */\n        if (data_tree) {\n            pdu_ti = proto_tree_add_item(data_tree, hf_fp_mac_d_pdu, tvb,\n                                         offset, length, ENC_NA);\n            proto_item_set_text(pdu_ti, \"MAC-d PDU (PDU %u)\", pdu+1);\n\n        }\n\n        if (preferences_call_mac_dissectors  /*&& !rlc_is_ciphered(pinfo)*/) {\n\n            tvbuff_t *next_tvb = tvb_new_subset(tvb, offset, length, -1);\n\n\n            fpi->cur_tb = pdu;    /*Set proper pdu index for MAC and higher layers*/\n            call_dissector_with_data(mac_fdd_hsdsch_handle, next_tvb, pinfo, top_level_tree, data);\n            dissected = TRUE;\n        }\n\n        /* Advance offset */\n        offset += length;\n    }\n\n    /* Data tree should cover entire length */\n    proto_item_set_len(pdus_ti, offset-first_offset);\n\n    /* Show summary in info column */\n    if (!dissected) {\n        col_append_fstr(pinfo->cinfo, COL_INFO, \"   %u PDUs of %u bits\",\n                        number_of_pdus, length*8);\n    }\n\n    return offset;\n}\n\n/* Dissect CRCI bits (uplink) */\nstatic int\ndissect_crci_bits(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\n                  fp_info *p_fp_info, int offset)\n{\n    int         n, num_tbs;\n    proto_item *ti         = NULL;\n    proto_tree *crcis_tree = NULL;\n    guint       errors     = 0;\n\n    num_tbs = get_tb_count(p_fp_info);\n\n\n    /* Add CRCIs subtree */\n    if (tree) {\n        ti =  proto_tree_add_item(tree, hf_fp_crcis, tvb, offset, (num_tbs+7)/8, ENC_NA);\n        proto_item_set_text(ti, \"CRCI bits for %u tbs\", num_tbs);\n        crcis_tree = proto_item_add_subtree(ti, ett_fp_crcis);\n    }\n\n    /* CRCIs */\n    for (n=0; n < num_tbs; n++) {\n        int bit = (tvb_get_guint8(tvb, offset+(n/8)) >> (7-(n%8))) & 0x01;\n        proto_tree_add_item(crcis_tree, hf_fp_crci[n%8], tvb, offset+(n/8),\n                            1, ENC_BIG_ENDIAN);\n\n        if (bit == 1) {\n            errors++;\n            expert_add_info(pinfo, ti, &ei_fp_crci_error_bit_set_for_tb);\n        }\n    }\n\n    if (tree) {\n        /* Highlight range of bytes covered by indicator bits */\n        proto_item_set_len(ti, (num_tbs+7) / 8);\n\n        /* Show error count in root text */\n        proto_item_append_text(ti, \" (%u errors)\", errors);\n    }\n\n    offset += ((num_tbs+7) / 8);\n    return offset;\n}\n\n\nstatic void\ndissect_spare_extension_and_crc(tvbuff_t *tvb, packet_info *pinfo,\n                                proto_tree *tree, guint8 dch_crc_present,\n                                int offset, guint header_length)\n{\n    int         crc_size = 0;\n    int         remain   = tvb_captured_length_remaining(tvb, offset);\n\n    /* Payload CRC (optional) */\n    if ((dch_crc_present == 1) || ((dch_crc_present == 2) && (remain >= 2))) {\n        crc_size = 2;\n    }\n\n    if (remain > crc_size) {\n        proto_item *ti;\n        ti = proto_tree_add_item(tree, hf_fp_spare_extension, tvb,\n                                 offset, remain-crc_size, ENC_NA);\n        proto_item_append_text(ti, \" (%u octets)\", remain-crc_size);\n        expert_add_info_format(pinfo, ti, &ei_fp_spare_extension, \"Spare Extension present (%u bytes)\", remain-crc_size);\n        offset += remain-crc_size;\n    }\n\n    if (crc_size) {\n     proto_item * pi = proto_tree_add_item(tree, hf_fp_payload_crc, tvb, offset, crc_size,\n                            ENC_BIG_ENDIAN);\n        if (preferences_payload_checksum) {\n            guint16 calc_crc, read_crc;\n            guint8 * data = (guint8 *)tvb_memdup(wmem_packet_scope(), tvb, header_length, offset-header_length);\n            calc_crc = crc16_8005_noreflect_noxor(data, offset-header_length);\n            read_crc = tvb_get_bits16(tvb, offset*8, 16, ENC_BIG_ENDIAN);\n\n            if (calc_crc == read_crc) {\n                proto_item_append_text(pi, \" [correct]\");\n            } else {\n                proto_item_append_text(pi, \" [incorrect, should be 0x%x]\", calc_crc);\n                expert_add_info(pinfo, pi, &ei_fp_bad_payload_checksum);\n            }\n        }\n    }\n}\n\n/***********************************************************/\n/* Common control message types                            */\n\nstatic int\ndissect_common_outer_loop_power_control(packet_info *pinfo, proto_tree *tree, tvbuff_t *tvb,\n                                        int offset, struct fp_info *p_fp_info _U_)\n{\n    return dissect_dch_outer_loop_power_control(tree, pinfo, tvb, offset);\n}\n\n\nstatic int\ndissect_common_timing_adjustment(packet_info *pinfo, proto_tree *tree, tvbuff_t *tvb,\n                                 int offset, struct fp_info *p_fp_info)\n{\n    if (p_fp_info->channel != CHANNEL_PCH) {\n        guint8 cfn;\n        gint16 toa;\n\n        /* CFN control */\n        cfn = tvb_get_guint8(tvb, offset);\n        proto_tree_add_item(tree, hf_fp_cfn_control, tvb, offset, 1, ENC_BIG_ENDIAN);\n        offset++;\n\n        /* ToA */\n        toa = tvb_get_ntohs(tvb, offset);\n        proto_tree_add_item(tree, hf_fp_toa, tvb, offset, 2, ENC_BIG_ENDIAN);\n        offset += 2;\n\n        col_append_fstr(pinfo->cinfo, COL_INFO, \"   CFN=%u, ToA=%d\", cfn, toa);\n    }\n    else {\n        guint16 cfn;\n        gint32 toa;\n\n        /* PCH CFN is 12 bits */\n        cfn = (tvb_get_ntohs(tvb, offset) >> 4);\n        proto_tree_add_item(tree, hf_fp_pch_cfn, tvb, offset, 2, ENC_BIG_ENDIAN);\n        offset += 2;\n\n        /* 4 bits of padding follow... */\n\n        /* 20 bits of ToA (followed by 4 padding bits) */\n        toa = ((int)(tvb_get_ntoh24(tvb, offset) << 8)) / 4096;\n        proto_tree_add_int(tree, hf_fp_pch_toa, tvb, offset, 3, toa);\n        offset += 3;\n\n        col_append_fstr(pinfo->cinfo, COL_INFO, \"   CFN=%u, ToA=%d\", cfn, toa);\n    }\n    return offset;\n}\n\nstatic int\ndissect_common_dl_node_synchronisation(packet_info *pinfo, proto_tree *tree,\n                                       tvbuff_t *tvb, int offset)\n{\n    /* T1 (3 bytes) */\n    guint32 t1 = tvb_get_ntoh24(tvb, offset);\n    proto_tree_add_item(tree, hf_fp_t1, tvb, offset, 3, ENC_BIG_ENDIAN);\n    offset += 3;\n\n    col_append_fstr(pinfo->cinfo, COL_INFO, \"   T1=%u\", t1);\n\n    return offset;\n}\n\nstatic int\ndissect_common_ul_node_synchronisation(packet_info *pinfo, proto_tree *tree,\n                                       tvbuff_t *tvb, int offset)\n{\n    guint32 t1, t2, t3;\n\n    /* T1 (3 bytes) */\n    t1 = tvb_get_ntoh24(tvb, offset);\n    proto_tree_add_item(tree, hf_fp_t1, tvb, offset, 3, ENC_BIG_ENDIAN);\n    offset += 3;\n\n    /* T2 (3 bytes) */\n    t2 = tvb_get_ntoh24(tvb, offset);\n    proto_tree_add_item(tree, hf_fp_t2, tvb, offset, 3, ENC_BIG_ENDIAN);\n    offset += 3;\n\n    /* T3 (3 bytes) */\n    t3 = tvb_get_ntoh24(tvb, offset);\n    proto_tree_add_item(tree, hf_fp_t3, tvb, offset, 3, ENC_BIG_ENDIAN);\n    offset += 3;\n\n    col_append_fstr(pinfo->cinfo, COL_INFO, \"   T1=%u T2=%u, T3=%u\",\n                    t1, t2, t3);\n\n    return offset;\n}\n\nstatic int\ndissect_common_dl_synchronisation(packet_info *pinfo, proto_tree *tree,\n                                  tvbuff_t *tvb, int offset, struct fp_info *p_fp_info)\n{\n    guint16 cfn;\n\n    if (p_fp_info->channel != CHANNEL_PCH) {\n        /* CFN control */\n        cfn = tvb_get_guint8(tvb, offset);\n        proto_tree_add_item(tree, hf_fp_cfn_control, tvb, offset, 1, ENC_BIG_ENDIAN);\n        offset++;\n    }\n    else {\n        /* PCH CFN is 12 bits */\n        cfn = (tvb_get_ntohs(tvb, offset) >> 4);\n        proto_tree_add_item(tree, hf_fp_pch_cfn, tvb, offset, 2, ENC_BIG_ENDIAN);\n\n        /* 4 bits of padding follow... */\n        offset += 2;\n    }\n\n    col_append_fstr(pinfo->cinfo, COL_INFO, \"   CFN=%u\", cfn);\n\n    return offset;\n}\n\nstatic int\ndissect_common_ul_synchronisation(packet_info *pinfo, proto_tree *tree,\n                                  tvbuff_t *tvb, int offset, struct fp_info *p_fp_info)\n{\n    return dissect_common_timing_adjustment(pinfo, tree, tvb, offset, p_fp_info);\n}\n\nstatic int\ndissect_common_timing_advance(packet_info *pinfo, proto_tree *tree, tvbuff_t *tvb, int offset)\n{\n    guint8  cfn;\n    guint16 timing_advance;\n\n    /* CFN control */\n    cfn = tvb_get_guint8(tvb, offset);\n    proto_tree_add_item(tree, hf_fp_cfn_control, tvb, offset, 1, ENC_BIG_ENDIAN);\n    offset++;\n\n    /* Timing Advance */\n    timing_advance = (tvb_get_guint8(tvb, offset) & 0x3f) * 4;\n    proto_tree_add_uint(tree, hf_fp_timing_advance, tvb, offset, 1, timing_advance);\n    offset++;\n\n    col_append_fstr(pinfo->cinfo, COL_INFO, \" CFN = %u, TA = %u\",\n                    cfn, timing_advance);\n\n    return offset;\n}\n\nstatic int\ndissect_hsdpa_capacity_request(packet_info *pinfo, proto_tree *tree,\n                               tvbuff_t *tvb, int offset)\n{\n    guint8  priority;\n    guint16 user_buffer_size;\n\n    /* CmCH-PI */\n    priority = (tvb_get_guint8(tvb, offset) & 0x0f);\n    proto_tree_add_item(tree, hf_fp_cmch_pi, tvb, offset, 1, ENC_BIG_ENDIAN);\n    offset++;\n\n    /* User buffer size */\n    user_buffer_size = tvb_get_ntohs(tvb, offset);\n    proto_tree_add_item(tree, hf_fp_user_buffer_size, tvb, offset, 2, ENC_BIG_ENDIAN);\n    offset += 2;\n\n    col_append_fstr(pinfo->cinfo, COL_INFO, \"      CmCH-PI=%u  User-Buffer-Size=%u\",\n                    priority, user_buffer_size);\n\n    return offset;\n}\n\nstatic int\ndissect_hsdpa_capacity_allocation(packet_info *pinfo, proto_tree *tree,\n                                  tvbuff_t *tvb, int offset,\n                                  struct fp_info *p_fp_info)\n{\n    proto_item *ti;\n    proto_item *rate_ti;\n    guint16     max_pdu_length;\n    guint8      repetition_period;\n    guint8      interval;\n    guint64     credits;\n\n    /* Congestion status (introduced sometime during R6...) */\n    if ((p_fp_info->release == 6) || (p_fp_info->release == 7)) {\n        proto_tree_add_bits_item(tree, hf_fp_congestion_status, tvb,\n                                 offset*8 + 2, 2, ENC_BIG_ENDIAN);\n    }\n\n    /* CmCH-PI */\n    proto_tree_add_item(tree, hf_fp_cmch_pi, tvb, offset, 1, ENC_BIG_ENDIAN);\n    offset++;\n\n    /* Max MAC-d PDU length (13 bits) */\n    max_pdu_length = tvb_get_ntohs(tvb, offset) >> 3;\n    proto_tree_add_item(tree, hf_fp_hsdsch_max_macd_pdu_len, tvb, offset, 2, ENC_BIG_ENDIAN);\n    offset++;\n\n    /* HS-DSCH credits (11 bits) */\n    ti = proto_tree_add_bits_ret_val(tree, hf_fp_hsdsch_credits, tvb,\n                                     offset*8 + 5, 11, &credits, ENC_BIG_ENDIAN);\n    offset += 2;\n\n    /* Interesting values */\n    if (credits == 0) {\n        proto_item_append_text(ti, \" (stop transmission)\");\n        expert_add_info(pinfo, ti, &ei_fp_stop_hsdpa_transmission);\n    }\n    if (credits == 2047) {\n        proto_item_append_text(ti, \" (unlimited)\");\n    }\n\n    /* HS-DSCH Interval */\n    interval = tvb_get_guint8(tvb, offset);\n    ti = proto_tree_add_uint(tree, hf_fp_hsdsch_interval, tvb, offset, 1, interval*10);\n    offset++;\n    if (interval == 0) {\n        proto_item_append_text(ti, \" (none of the credits shall be used)\");\n    }\n\n    /* HS-DSCH Repetition period */\n    repetition_period = tvb_get_guint8(tvb, offset);\n    ti = proto_tree_add_item(tree, hf_fp_hsdsch_repetition_period, tvb, offset, 1, ENC_BIG_ENDIAN);\n    offset++;\n    if (repetition_period == 0) {\n        proto_item_append_text(ti, \" (unlimited repetition period)\");\n    }\n\n    /* Calculated and show effective rate enabled */\n    if (credits == 2047) {\n        rate_ti = proto_tree_add_item(tree, hf_fp_hsdsch_unlimited_rate, tvb, 0, 0, ENC_NA);\n        PROTO_ITEM_SET_GENERATED(rate_ti);\n    }\n    else {\n        if (interval != 0) {\n            /* Cast on credits is safe, since we know it won't exceed 10^11 */\n            rate_ti = proto_tree_add_uint(tree, hf_fp_hsdsch_calculated_rate, tvb, 0, 0,\n                                          (guint16)credits * max_pdu_length * (1000 / (interval*10)));\n            PROTO_ITEM_SET_GENERATED(rate_ti);\n        }\n    }\n\n    col_append_fstr(pinfo->cinfo, COL_INFO,\n                    \"   Max-PDU-len=%u  Credits=%u  Interval=%u  Rep-Period=%u\",\n                    max_pdu_length, (guint16)credits, interval, repetition_period);\n\n    return offset;\n}\n\nstatic int\ndissect_hsdpa_capacity_allocation_type_2(packet_info *pinfo, proto_tree *tree,\n                                         tvbuff_t *tvb, int offset)\n{\n    proto_item *ti;\n    proto_item *rate_ti;\n    guint16     max_pdu_length;\n    guint8      repetition_period;\n    guint8      interval;\n    guint16     credits;\n\n    /* Congestion status */\n    proto_tree_add_bits_item(tree, hf_fp_congestion_status, tvb,\n                            offset*8 + 2, 2, ENC_BIG_ENDIAN);\n\n    /* CmCH-PI */\n    proto_tree_add_item(tree, hf_fp_cmch_pi, tvb, offset, 1, ENC_BIG_ENDIAN);\n    offset++;\n\n    /* 5 spare bits follow here */\n\n    /* Max MAC-d/c PDU length (11 bits) */\n    max_pdu_length = tvb_get_ntohs(tvb, offset) & 0x7ff;\n    proto_tree_add_item(tree, hf_fp_hsdsch_max_macdc_pdu_len, tvb, offset, 2, ENC_BIG_ENDIAN);\n    offset += 2;\n\n    /* HS-DSCH credits (16 bits) */\n    credits = (tvb_get_ntohs(tvb, offset));\n    ti = proto_tree_add_uint(tree, hf_fp_hsdsch_credits, tvb,\n                             offset, 2, credits);\n    offset += 2;\n\n    /* Interesting values */\n    if (credits == 0) {\n        proto_item_append_text(ti, \" (stop transmission)\");\n        expert_add_info(pinfo, ti, &ei_fp_stop_hsdpa_transmission);\n    }\n    if (credits == 65535) {\n        proto_item_append_text(ti, \" (unlimited)\");\n    }\n\n    /* HS-DSCH Interval */\n    interval = tvb_get_guint8(tvb, offset);\n    ti = proto_tree_add_uint(tree, hf_fp_hsdsch_interval, tvb, offset, 1, interval*10);\n    offset++;\n    if (interval == 0) {\n        proto_item_append_text(ti, \" (none of the credits shall be used)\");\n    }\n\n    /* HS-DSCH Repetition period */\n    repetition_period = tvb_get_guint8(tvb, offset);\n    ti = proto_tree_add_item(tree, hf_fp_hsdsch_repetition_period, tvb, offset, 1, ENC_BIG_ENDIAN);\n    offset++;\n    if (repetition_period == 0) {\n        proto_item_append_text(ti, \" (unlimited repetition period)\");\n    }\n\n    /* Calculated and show effective rate enabled */\n    if (credits == 65535) {\n        rate_ti = proto_tree_add_item(tree, hf_fp_hsdsch_unlimited_rate, tvb, 0, 0, ENC_NA);\n        PROTO_ITEM_SET_GENERATED(rate_ti);\n    }\n    else {\n        if (interval != 0) {\n            rate_ti = proto_tree_add_uint(tree, hf_fp_hsdsch_calculated_rate, tvb, 0, 0,\n                                          credits * max_pdu_length * (1000 / (interval*10)));\n            PROTO_ITEM_SET_GENERATED(rate_ti);\n        }\n    }\n\n    col_append_fstr(pinfo->cinfo, COL_INFO,\n                    \"   Max-PDU-len=%u  Credits=%u  Interval=%u  Rep-Period=%u\",\n                    max_pdu_length, credits, interval, repetition_period);\n\n    return offset;\n}\n\n\n\nstatic int\ndissect_common_dynamic_pusch_assignment(packet_info *pinfo, proto_tree *tree,\n                                        tvbuff_t *tvb, int offset)\n{\n    guint8 pusch_set_id;\n    guint8 activation_cfn;\n    guint8 duration;\n\n    /* PUSCH Set Id */\n    pusch_set_id = tvb_get_guint8(tvb, offset);\n    proto_tree_add_item(tree, hf_fp_pusch_set_id, tvb, offset, 1, ENC_BIG_ENDIAN);\n    offset++;\n\n    /* Activation CFN */\n    activation_cfn = tvb_get_guint8(tvb, offset);\n    proto_tree_add_item(tree, hf_fp_activation_cfn, tvb, offset, 1, ENC_BIG_ENDIAN);\n    offset++;\n\n    /* Duration */\n    duration = tvb_get_guint8(tvb, offset) * 10;\n    proto_tree_add_uint(tree, hf_fp_duration, tvb, offset, 1, duration);\n    offset++;\n\n    col_append_fstr(pinfo->cinfo, COL_INFO,\n                    \"   PUSCH Set Id=%u  Activation CFN=%u  Duration=%u\",\n                    pusch_set_id, activation_cfn, duration);\n\n    return offset;\n}\n\n\n\n\n\n/* Dissect the control part of a common channel message */\nstatic void\ndissect_common_control(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\n                       int offset, struct fp_info *p_fp_info)\n{\n    /* Common control frame type */\n    guint8 control_frame_type = tvb_get_guint8(tvb, offset);\n    proto_tree_add_item(tree, hf_fp_common_control_frame_type, tvb, offset, 1, ENC_BIG_ENDIAN);\n    offset++;\n\n    col_append_str(pinfo->cinfo, COL_INFO,\n                   val_to_str_const(control_frame_type, common_control_frame_type_vals, \"Unknown\"));\n\n    /* Frame-type specific dissection */\n    switch (control_frame_type) {\n        case COMMON_OUTER_LOOP_POWER_CONTROL:\n            /*offset =*/ dissect_common_outer_loop_power_control(pinfo, tree, tvb, offset, p_fp_info);\n            break;\n        case COMMON_TIMING_ADJUSTMENT:\n            /*offset =*/ dissect_common_timing_adjustment(pinfo, tree, tvb, offset, p_fp_info);\n            break;\n        case COMMON_DL_SYNCHRONISATION:\n            /*offset =*/ dissect_common_dl_synchronisation(pinfo, tree, tvb, offset, p_fp_info);\n            break;\n        case COMMON_UL_SYNCHRONISATION:\n            /*offset =*/ dissect_common_ul_synchronisation(pinfo, tree, tvb, offset, p_fp_info);\n            break;\n        case COMMON_DL_NODE_SYNCHRONISATION:\n            /*offset =*/ dissect_common_dl_node_synchronisation(pinfo, tree, tvb, offset);\n            break;\n        case COMMON_UL_NODE_SYNCHRONISATION:\n            /*offset =*/ dissect_common_ul_node_synchronisation(pinfo, tree, tvb, offset);\n            break;\n        case COMMON_DYNAMIC_PUSCH_ASSIGNMENT:\n            /*offset =*/ dissect_common_dynamic_pusch_assignment(pinfo, tree, tvb, offset);\n            break;\n        case COMMON_TIMING_ADVANCE:\n            /*offset =*/ dissect_common_timing_advance(pinfo, tree, tvb, offset);\n            break;\n        case COMMON_HS_DSCH_Capacity_Request:\n            /*offset =*/ dissect_hsdpa_capacity_request(pinfo, tree, tvb, offset);\n            break;\n        case COMMON_HS_DSCH_Capacity_Allocation:\n            /*offset =*/ dissect_hsdpa_capacity_allocation(pinfo, tree, tvb, offset, p_fp_info);\n            break;\n        case COMMON_HS_DSCH_Capacity_Allocation_Type_2:\n            /*offset =*/ dissect_hsdpa_capacity_allocation_type_2(pinfo, tree, tvb, offset);\n            break;\n\n        default:\n            break;\n    }\n\n     /* There is no Spare Extension nor payload crc in common control!? */\n   /* dissect_spare_extension_and_crc(tvb, pinfo, tree, 0, offset);\n    */\n}\n\n\n\n/**************************/\n/* Dissect a RACH channel */\nstatic void\ndissect_rach_channel_info(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\n                          int offset, struct fp_info *p_fp_info, void *data)\n{\n    gboolean is_control_frame;\n    guint16 header_crc = 0;\n    proto_item * header_crc_pi = NULL;\n    guint header_length = 0;\n\n    /* Header CRC */\n    header_crc = tvb_get_bits8(tvb, 0, 7);\n    header_crc_pi = proto_tree_add_item(tree, hf_fp_header_crc, tvb, offset, 1, ENC_BIG_ENDIAN);\n\n    /* Frame Type */\n    is_control_frame = tvb_get_guint8(tvb, offset) & 0x01;\n    proto_tree_add_item(tree, hf_fp_ft, tvb, offset, 1, ENC_BIG_ENDIAN);\n    offset++;\n\n    col_append_str(pinfo->cinfo, COL_INFO, is_control_frame ? \" [Control] \" : \" [Data] \");\n\n    if (is_control_frame) {\n        dissect_common_control(tvb, pinfo, tree, offset, p_fp_info);\n        /* For control frame the header CRC is actually frame CRC covering all\n         * bytes except the first */\n        if (preferences_header_checksum) {\n            verify_control_frame_crc(tvb, pinfo, header_crc_pi, header_crc);\n        }\n    }\n    else {\n        guint8      cfn;\n        guint32     propagation_delay                    = 0;\n        proto_item *propagation_delay_ti                 = NULL;\n        guint32     received_sync_ul_timing_deviation    = 0;\n        proto_item *received_sync_ul_timing_deviation_ti = NULL;\n        proto_item *rx_timing_deviation_ti               = NULL;\n        guint16     rx_timing_deviation                  = 0;\n\n        /* DATA */\n\n        /* CFN */\n        cfn = tvb_get_guint8(tvb, offset);\n        proto_tree_add_item(tree, hf_fp_cfn, tvb, offset, 1, ENC_BIG_ENDIAN);\n        offset++;\n\n        col_append_fstr(pinfo->cinfo, COL_INFO, \"CFN=%03u \", cfn);\n\n        /* TFI */\n        proto_tree_add_item(tree, hf_fp_tfi, tvb, offset, 1, ENC_BIG_ENDIAN);\n        offset++;\n\n        if (p_fp_info->channel == CHANNEL_RACH_FDD) {\n            /* Propagation delay */\n            propagation_delay = tvb_get_guint8(tvb, offset);\n            propagation_delay_ti = proto_tree_add_uint(tree, hf_fp_propagation_delay, tvb, offset, 1,\n                                                       propagation_delay*3);\n            offset++;\n        }\n\n        /* Should be TDD 3.84 or 7.68 */\n        if (p_fp_info->channel == CHANNEL_RACH_TDD) {\n            /* Rx Timing Deviation */\n            rx_timing_deviation = tvb_get_guint8(tvb, offset);\n            rx_timing_deviation_ti = proto_tree_add_item(tree, hf_fp_rx_timing_deviation, tvb, offset, 1, ENC_BIG_ENDIAN);\n            offset++;\n        }\n\n        if (p_fp_info->channel == CHANNEL_RACH_TDD_128) {\n            /* Received SYNC UL Timing Deviation */\n            received_sync_ul_timing_deviation = tvb_get_guint8(tvb, offset);\n            received_sync_ul_timing_deviation_ti =\n                 proto_tree_add_item(tree, hf_fp_received_sync_ul_timing_deviation, tvb, offset, 1, ENC_BIG_ENDIAN);\n            offset++;\n        }\n\n        header_length = offset;\n\n        /* TB data */\n        offset = dissect_tb_data(tvb, pinfo, tree, offset, p_fp_info, &mac_fdd_rach_handle, data);\n\n        /* CRCIs */\n        offset = dissect_crci_bits(tvb, pinfo, tree, p_fp_info, offset);\n\n        /* Info introduced in R6 */\n        /* only check if it looks as if they are present */\n        if (((p_fp_info->release == 6) || (p_fp_info->release == 7)) &&\n            (tvb_reported_length_remaining(tvb, offset) > 2))\n        {\n            int n;\n            guint8 flags;\n            /* guint8 flag_bytes = 0; */\n\n            gboolean cell_portion_id_present                 = FALSE;\n            gboolean ext_propagation_delay_present           = FALSE;\n            gboolean angle_of_arrival_present                = FALSE;\n            gboolean ext_rx_sync_ul_timing_deviation_present = FALSE;\n            gboolean ext_rx_timing_deviation_present         = FALSE;\n\n            /* New IE flags (assume mandatory for now) */\n            do {\n                proto_item *new_ie_flags_ti;\n                proto_tree *new_ie_flags_tree;\n                guint ies_found = 0;\n\n                /* Add new IE flags subtree */\n                new_ie_flags_ti = proto_tree_add_string_format(tree, hf_fp_rach_new_ie_flags, tvb, offset, 1,\n                                                              \"\", \"New IE flags\");\n                new_ie_flags_tree = proto_item_add_subtree(new_ie_flags_ti, ett_fp_rach_new_ie_flags);\n\n                /* Read next byte */\n                flags = tvb_get_guint8(tvb, offset);\n                /* flag_bytes++ */\n\n                /* Dissect individual bits */\n                for (n=0; n < 8; n++) {\n                    switch (n) {\n                        case 6:\n                            switch (p_fp_info->division) {\n                                case Division_FDD:\n                                    /* Ext propagation delay */\n                                    ext_propagation_delay_present = TRUE;\n                                    proto_tree_add_item(new_ie_flags_tree, hf_fp_rach_ext_propagation_delay_present,\n                                                        tvb, offset, 1, ENC_BIG_ENDIAN);\n                                    break;\n                                case Division_TDD_128:\n                                    /* Ext Rx Sync UL Timing */\n                                    ext_rx_sync_ul_timing_deviation_present = TRUE;\n                                    proto_tree_add_item(new_ie_flags_tree, hf_fp_rach_ext_rx_sync_ul_timing_deviation_present,\n                                                        tvb, offset, 1, ENC_BIG_ENDIAN);\n\n                                    break;\n                                default:\n                                    /* Not defined */\n                                    proto_tree_add_item(new_ie_flags_tree, hf_fp_rach_new_ie_flag_unused[6],\n                                                        tvb, offset, 1, ENC_BIG_ENDIAN);\n                                    break;\n                            }\n                            break;\n                        case 7:\n                            switch (p_fp_info->division) {\n                                case Division_FDD:\n                                    /* Cell Portion ID */\n                                    cell_portion_id_present = TRUE;\n                                    proto_tree_add_item(new_ie_flags_tree, hf_fp_rach_cell_portion_id_present,\n                                                        tvb, offset, 1, ENC_BIG_ENDIAN);\n                                    break;\n                                case Division_TDD_128:\n                                    /* AOA */\n                                    angle_of_arrival_present = TRUE;\n                                    proto_tree_add_item(new_ie_flags_tree, hf_fp_rach_angle_of_arrival_present,\n                                                        tvb, offset, 1, ENC_BIG_ENDIAN);\n                                    break;\n                                case Division_TDD_384:\n                                case Division_TDD_768:\n                                    /* Extended Rx Timing Deviation */\n                                    ext_rx_timing_deviation_present = TRUE;\n                                    proto_tree_add_item(new_ie_flags_tree, hf_fp_rach_ext_rx_timing_deviation_present,\n                                                        tvb, offset, 1, ENC_BIG_ENDIAN);\n                                    break;\n                            }\n                            break;\n\n                        default:\n                            /* No defined meanings */\n                            /* Visual Studio Code Analyzer wrongly thinks n can be 7 here. It can't */\n                            proto_tree_add_item(new_ie_flags_tree, hf_fp_rach_new_ie_flag_unused[n],\n                                                tvb, offset, 1, ENC_BIG_ENDIAN);\n                            break;\n                    }\n                    if ((flags >> (7-n)) & 0x01) {\n                        ies_found++;\n                    }\n                }\n                offset++;\n\n                proto_item_append_text(new_ie_flags_ti, \" (%u IEs found)\", ies_found);\n\n                /* Last bit set will indicate another flags byte follows... */\n            } while (0); /*((flags & 0x01) && (flag_bytes < 31));*/\n\n            /* Cell Portion ID */\n            if (cell_portion_id_present) {\n                    proto_tree_add_item(tree, hf_fp_cell_portion_id, tvb, offset, 1, ENC_BIG_ENDIAN);\n                    offset++;\n            }\n\n            /* Ext Rx Timing Deviation */\n            if (ext_rx_timing_deviation_present) {\n                guint8 extra_bits;\n                guint bits_to_extend;\n                switch (p_fp_info->division) {\n                    case Division_TDD_384:\n                        bits_to_extend = 1;\n                        break;\n                    case Division_TDD_768:\n                        bits_to_extend = 2;\n                        break;\n\n                    default:\n                        /* TODO: report unexpected division type */\n                        bits_to_extend = 1;\n                        break;\n                }\n                extra_bits = tvb_get_guint8(tvb, offset) &\n                                 ((bits_to_extend == 1) ? 0x01 : 0x03);\n                rx_timing_deviation = (extra_bits << 8) | (rx_timing_deviation);\n                proto_item_append_text(rx_timing_deviation_ti,\n                                       \" (extended to 0x%x)\",\n                                       rx_timing_deviation);\n                proto_tree_add_bits_item(tree, hf_fp_extended_bits, tvb,\n                                         offset*8 + (8-bits_to_extend), bits_to_extend, ENC_BIG_ENDIAN);\n                offset++;\n            }\n\n            /* Ext propagation delay. */\n            if (ext_propagation_delay_present) {\n                guint16 extra_bits = tvb_get_ntohs(tvb, offset) & 0x03ff;\n                proto_tree_add_item(tree, hf_fp_ext_propagation_delay, tvb, offset, 2, ENC_BIG_ENDIAN);\n\n                /* Adding 10 bits to original 8 */\n                proto_item_append_text(propagation_delay_ti, \" (extended to %u)\",\n                                       ((extra_bits << 8) | propagation_delay) * 3);\n                offset += 2;\n            }\n\n            /* Angle of Arrival (AOA) */\n            if (angle_of_arrival_present) {\n                proto_tree_add_item(tree, hf_fp_angle_of_arrival, tvb, offset, 2, ENC_BIG_ENDIAN);\n                offset += 2;\n            }\n\n            /* Ext. Rx Sync UL Timing Deviation */\n            if (ext_rx_sync_ul_timing_deviation_present) {\n                guint16 extra_bits;\n\n                /* Ext received Sync UL Timing Deviation */\n                extra_bits = tvb_get_ntohs(tvb, offset) & 0x1fff;\n                proto_tree_add_item(tree, hf_fp_ext_received_sync_ul_timing_deviation, tvb, offset, 2, ENC_BIG_ENDIAN);\n\n                /* Adding 13 bits to original 8 */\n                proto_item_append_text(received_sync_ul_timing_deviation_ti, \" (extended to %u)\",\n                                       (extra_bits << 8) | received_sync_ul_timing_deviation);\n                offset += 2;\n            }\n        }\n        if (preferences_header_checksum) {\n            verify_header_crc(tvb, pinfo, header_crc_pi, header_crc, header_length);\n        }\n        /* Spare Extension and Payload CRC */\n        dissect_spare_extension_and_crc(tvb, pinfo, tree, 1, offset, header_length);\n    }\n}\n\n\n/**************************/\n/* Dissect a FACH channel */\nstatic void\ndissect_fach_channel_info(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\n                          int offset, struct fp_info *p_fp_info, void *data)\n{\n    gboolean is_control_frame;\n    guint16 header_crc = 0;\n    proto_item * header_crc_pi = NULL;\n    guint header_length = 0;\n\n    /* Header CRC */\n    header_crc = tvb_get_bits8(tvb, 0, 7);\n    header_crc_pi = proto_tree_add_item(tree, hf_fp_header_crc, tvb, offset, 1, ENC_BIG_ENDIAN);\n\n    /* Frame Type */\n    is_control_frame = tvb_get_guint8(tvb, offset) & 0x01;\n    proto_tree_add_item(tree, hf_fp_ft, tvb, offset, 1, ENC_BIG_ENDIAN);\n    offset++;\n\n    col_append_str(pinfo->cinfo, COL_INFO, is_control_frame ? \" [Control] \" : \" [Data] \");\n\n    if (is_control_frame) {\n        dissect_common_control(tvb, pinfo, tree, offset, p_fp_info);\n        /* For control frame the header CRC is actually frame CRC covering all\n         * bytes except the first */\n        if (preferences_header_checksum) {\n            verify_control_frame_crc(tvb, pinfo, header_crc_pi, header_crc);\n        }\n    }\n    else {\n        guint8 cfn;\n        /* DATA */\n\n        /* CFN */\n        cfn = tvb_get_guint8(tvb, offset);\n        proto_tree_add_item(tree, hf_fp_cfn, tvb, offset, 1, ENC_BIG_ENDIAN);\n        offset++;\n\n        col_append_fstr(pinfo->cinfo, COL_INFO, \"CFN=%03u \", cfn);\n\n        /* TFI */\n        proto_tree_add_item(tree, hf_fp_fach_tfi, tvb, offset, 1, ENC_BIG_ENDIAN);\n        offset++;\n\n        /* Transmit power level */\n        proto_tree_add_float(tree, hf_fp_transmit_power_level, tvb, offset, 1,\n                             (float)(int)(tvb_get_guint8(tvb, offset)) / 10);\n        offset++;\n        header_length = offset;\n\n        /* TB data */\n        offset = dissect_tb_data(tvb, pinfo, tree, offset, p_fp_info, &mac_fdd_fach_handle, data);\n\n        /* New IE flags (if it looks as though they are present) */\n        if ((p_fp_info->release == 7) &&\n            (tvb_reported_length_remaining(tvb, offset) > 2)) {\n\n            guint8 flags = tvb_get_guint8(tvb, offset);\n            guint8 aoa_present = flags & 0x01;\n            offset++;\n\n            if (aoa_present) {\n                proto_tree_add_item(tree, hf_fp_angle_of_arrival, tvb, offset, 2, ENC_BIG_ENDIAN);\n                offset += 2;\n            }\n        }\n        if (preferences_header_checksum) {\n            verify_header_crc(tvb, pinfo, header_crc_pi, header_crc, header_length);\n        }\n        /* Spare Extension and Payload CRC */\n        dissect_spare_extension_and_crc(tvb, pinfo, tree, 1, offset, header_length);\n    }\n}\n\n\n/**************************/\n/* Dissect a DSCH channel */\nstatic void\ndissect_dsch_channel_info(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\n                          int offset, struct fp_info *p_fp_info)\n{\n    gboolean is_control_frame;\n\n    /* Header CRC */\n    proto_tree_add_item(tree, hf_fp_header_crc, tvb, offset, 1, ENC_BIG_ENDIAN);\n\n    /* Frame Type */\n    is_control_frame = tvb_get_guint8(tvb, offset) & 0x01;\n    proto_tree_add_item(tree, hf_fp_ft, tvb, offset, 1, ENC_BIG_ENDIAN);\n    offset++;\n\n    col_append_str(pinfo->cinfo, COL_INFO, is_control_frame ? \" [Control] \" : \" [Data] \");\n\n    if (is_control_frame) {\n        dissect_common_control(tvb, pinfo, tree, offset, p_fp_info);\n    }\n    else {\n        guint8 cfn;\n        guint header_length = 0;\n\n        /* DATA */\n\n        /* CFN */\n        cfn = tvb_get_guint8(tvb, offset);\n        proto_tree_add_item(tree, hf_fp_cfn, tvb, offset, 1, ENC_BIG_ENDIAN);\n        offset++;\n\n        col_append_fstr(pinfo->cinfo, COL_INFO, \"CFN=%03u \", cfn);\n\n        /* TFI */\n        proto_tree_add_item(tree, hf_fp_tfi, tvb, offset, 1, ENC_BIG_ENDIAN);\n        offset++;\n\n\n        /* Other fields depend upon release & FDD/TDD settings */\n        if (((p_fp_info->release == 99) || (p_fp_info->release == 4)) &&\n             (p_fp_info->channel == CHANNEL_DSCH_FDD)) {\n\n            /* Power offset */\n            proto_tree_add_float(tree, hf_fp_power_offset, tvb, offset, 1,\n                                 (float)(-32.0) +\n                                  ((float)(int)(tvb_get_guint8(tvb, offset)) * (float)(0.25)));\n            offset++;\n\n            /* Code number */\n            proto_tree_add_item(tree, hf_fp_code_number, tvb, offset, 1, ENC_BIG_ENDIAN);\n            offset++;\n\n            /* Spreading Factor (3 bits) */\n            proto_tree_add_item(tree, hf_fp_spreading_factor, tvb, offset, 1, ENC_BIG_ENDIAN);\n\n            /* MC info (4 bits)*/\n            proto_tree_add_item(tree, hf_fp_mc_info, tvb, offset, 1, ENC_BIG_ENDIAN);\n\n            /* Last bit of this byte is spare */\n            offset++;\n        }\n        else {\n            /* Normal case */\n\n            /* PDSCH Set Id */\n            proto_tree_add_item(tree, hf_fp_pdsch_set_id, tvb, offset, 1, ENC_BIG_ENDIAN);\n            offset++;\n\n            /* Transmit power level */\n            proto_tree_add_float(tree, hf_fp_transmit_power_level, tvb, offset, 1,\n                                 (float)(int)(tvb_get_guint8(tvb, offset)) / 10);\n            offset++;\n        }\n        header_length = offset;\n        /* TB data */\n        offset = dissect_tb_data(tvb, pinfo, tree, offset, p_fp_info, NULL, NULL);\n\n        /* Spare Extension and Payload CRC */\n        dissect_spare_extension_and_crc(tvb, pinfo, tree, 1, offset, header_length);\n    }\n}\n\n\n/**************************/\n/* Dissect a USCH channel */\nstatic void\ndissect_usch_channel_info(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\n                          int offset, struct fp_info *p_fp_info)\n{\n    gboolean is_control_frame;\n\n    /* Header CRC */\n    proto_tree_add_item(tree, hf_fp_header_crc, tvb, offset, 1, ENC_BIG_ENDIAN);\n\n    /* Frame Type */\n    is_control_frame = tvb_get_guint8(tvb, offset) & 0x01;\n    proto_tree_add_item(tree, hf_fp_ft, tvb, offset, 1, ENC_BIG_ENDIAN);\n    offset++;\n\n    col_append_str(pinfo->cinfo, COL_INFO, is_control_frame ? \" [Control] \" : \" [Data] \");\n\n    if (is_control_frame) {\n        dissect_common_control(tvb, pinfo, tree, offset, p_fp_info);\n    }\n    else {\n        guint cfn;\n        guint16 rx_timing_deviation;\n        proto_item *rx_timing_deviation_ti;\n        guint header_length = 0;\n\n        /* DATA */\n\n        /* CFN */\n        cfn = tvb_get_guint8(tvb, offset);\n        proto_tree_add_item(tree, hf_fp_cfn, tvb, offset, 1, ENC_BIG_ENDIAN);\n        offset++;\n\n        col_append_fstr(pinfo->cinfo, COL_INFO, \"CFN=%03u \", cfn);\n\n        /* TFI */\n        proto_tree_add_item(tree, hf_fp_usch_tfi, tvb, offset, 1, ENC_BIG_ENDIAN);\n        offset++;\n\n        /* Rx Timing Deviation */\n        rx_timing_deviation = tvb_get_guint8(tvb, offset);\n        rx_timing_deviation_ti = proto_tree_add_item(tree, hf_fp_rx_timing_deviation,\n                                                     tvb, offset, 1, ENC_BIG_ENDIAN);\n        offset++;\n        header_length = offset;\n        /* TB data */\n        offset = dissect_tb_data(tvb, pinfo, tree, offset, p_fp_info, NULL, NULL);\n\n        /* QE */\n        proto_tree_add_item(tree, hf_fp_quality_estimate, tvb, offset, 1, ENC_BIG_ENDIAN);\n        offset++;\n\n        /* CRCIs */\n        offset = dissect_crci_bits(tvb, pinfo, tree, p_fp_info, offset);\n\n        /* New IEs */\n        if ((p_fp_info->release == 7) &&\n            (tvb_reported_length_remaining(tvb, offset) > 2)) {\n\n            guint8 flags = tvb_get_guint8(tvb, offset);\n            guint8 bits_extended = flags & 0x01;\n            offset++;\n\n            if (bits_extended) {\n                guint8 extra_bits = tvb_get_guint8(tvb, offset) & 0x03;\n                proto_item_append_text(rx_timing_deviation_ti,\n                                       \" (extended to %u)\",\n                                       (rx_timing_deviation << 2) | extra_bits);\n            }\n            offset++;\n        }\n\n        /* Spare Extension and Payload CRC */\n        dissect_spare_extension_and_crc(tvb, pinfo, tree, 1, offset, header_length);\n    }\n}\n\n\n\n/**************************/\n/* Dissect a PCH channel  */\nstatic void\ndissect_pch_channel_info(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\n                         int offset, struct fp_info *p_fp_info, void *data)\n{\n    gboolean is_control_frame;\n    guint16  pch_cfn;\n    gboolean paging_indication;\n    guint16 header_crc = 0;\n    proto_item * header_crc_pi = NULL;\n\n    /* Header CRC */\n    header_crc = tvb_get_bits8(tvb, 0, 7);\n    header_crc_pi = proto_tree_add_item(tree, hf_fp_header_crc, tvb, offset, 1, ENC_BIG_ENDIAN);\n\n    /* Frame Type */\n    is_control_frame = tvb_get_guint8(tvb, offset) & 0x01;\n    proto_tree_add_item(tree, hf_fp_ft, tvb, offset, 1, ENC_BIG_ENDIAN);\n    offset++;\n\n    col_append_str(pinfo->cinfo, COL_INFO, is_control_frame ? \" [Control] \" : \" [Data] \");\n\n    if (is_control_frame) {\n        dissect_common_control(tvb, pinfo, tree, offset, p_fp_info);\n        /* For control frame the header CRC is actually frame CRC covering all\n         * bytes except the first */\n        if (preferences_header_checksum) {\n            verify_control_frame_crc(tvb, pinfo, header_crc_pi, header_crc);\n        }\n    }\n    else {\n        guint header_length = 0;\n        /* DATA */\n\n        /* 12-bit CFN value */\n        proto_tree_add_item(tree, hf_fp_pch_cfn, tvb, offset, 2, ENC_BIG_ENDIAN);\n        pch_cfn = (tvb_get_ntohs(tvb, offset) & 0xfff0) >> 4;\n        offset++;\n\n        col_append_fstr(pinfo->cinfo, COL_INFO, \"CFN=%04u \", pch_cfn);\n\n        /* Paging indication */\n        proto_tree_add_item(tree, hf_fp_pch_pi, tvb, offset, 1, ENC_BIG_ENDIAN);\n        paging_indication = tvb_get_guint8(tvb, offset) & 0x01;\n        offset++;\n\n        /* 5-bit TFI */\n        proto_tree_add_item(tree, hf_fp_pch_tfi, tvb, offset, 1, ENC_BIG_ENDIAN);\n        offset++;\n        header_length = offset;\n        /* Optional paging indications */\n        if (paging_indication) {\n            proto_item *ti;\n            ti = proto_tree_add_item(tree, hf_fp_paging_indication_bitmap, tvb,\n                                     offset,\n                                     (p_fp_info->paging_indications+7) / 8,\n                                     ENC_NA);\n            proto_item_append_text(ti, \" (%u bits)\", p_fp_info->paging_indications);\n            offset += ((p_fp_info->paging_indications+7) / 8);\n        }\n\n        /* TB data */\n        offset = dissect_tb_data(tvb, pinfo, tree, offset, p_fp_info, &mac_fdd_pch_handle, data);\n\n        if (preferences_header_checksum) {\n            verify_header_crc(tvb, pinfo, header_crc_pi, header_crc, header_length);\n        }\n        /* Spare Extension and Payload CRC */\n        dissect_spare_extension_and_crc(tvb, pinfo, tree, 1, offset, header_length);\n    }\n}\n\n\n/**************************/\n/* Dissect a CPCH channel */\nstatic void\ndissect_cpch_channel_info(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\n                          int offset, struct fp_info *p_fp_info)\n{\n    gboolean is_control_frame;\n\n    /* Header CRC */\n    proto_tree_add_item(tree, hf_fp_header_crc, tvb, offset, 1, ENC_BIG_ENDIAN);\n\n    /* Frame Type */\n    is_control_frame = tvb_get_guint8(tvb, offset) & 0x01;\n    proto_tree_add_item(tree, hf_fp_ft, tvb, offset, 1, ENC_BIG_ENDIAN);\n    offset++;\n\n    col_append_str(pinfo->cinfo, COL_INFO, is_control_frame ? \" [Control] \" : \" [Data] \");\n\n    if (is_control_frame) {\n        dissect_common_control(tvb, pinfo, tree, offset, p_fp_info);\n    }\n    else {\n        guint cfn;\n        guint header_length = 0;\n        /* DATA */\n\n        /* CFN */\n        cfn = tvb_get_guint8(tvb, offset);\n        proto_tree_add_item(tree, hf_fp_cfn, tvb, offset, 1, ENC_BIG_ENDIAN);\n        offset++;\n\n        col_append_fstr(pinfo->cinfo, COL_INFO, \"CFN=%03u \", cfn);\n\n        /* TFI */\n        proto_tree_add_item(tree, hf_fp_cpch_tfi, tvb, offset, 1, ENC_BIG_ENDIAN);\n        offset++;\n\n        /* Propagation delay */\n        proto_tree_add_uint(tree, hf_fp_propagation_delay, tvb, offset, 1,\n                            tvb_get_guint8(tvb, offset) * 3);\n        offset++;\n        header_length = offset; /* XXX this might be wrong */\n        /* TB data */\n        offset = dissect_tb_data(tvb, pinfo, tree, offset, p_fp_info, NULL, NULL);\n\n        /* CRCIs */\n        offset = dissect_crci_bits(tvb, pinfo, tree, p_fp_info, offset);\n\n        /* Spare Extension and Payload CRC */\n        dissect_spare_extension_and_crc(tvb, pinfo, tree, 1, offset, header_length);\n    }\n}\n\n\n/**************************/\n/* Dissect a BCH channel  */\nstatic void\ndissect_bch_channel_info(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\n                         int offset, struct fp_info *p_fp_info)\n{\n    gboolean is_control_frame;\n\n    /* Header CRC */\n    proto_tree_add_item(tree, hf_fp_header_crc, tvb, offset, 1, ENC_BIG_ENDIAN);\n\n    /* Frame Type */\n    is_control_frame = tvb_get_guint8(tvb, offset) & 0x01;\n    proto_tree_add_item(tree, hf_fp_ft, tvb, offset, 1, ENC_BIG_ENDIAN);\n    offset++;\n\n    col_append_str(pinfo->cinfo, COL_INFO, is_control_frame ? \" [Control] \" : \" [Data] \");\n\n    if (is_control_frame) {\n        dissect_common_control(tvb, pinfo, tree, offset, p_fp_info);\n    }\n}\n\n\n/********************************/\n/* Dissect an IUR DSCH channel  */\nstatic void\ndissect_iur_dsch_channel_info(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\n                              int offset, struct fp_info *p_fp_info)\n{\n    gboolean is_control_frame;\n\n    /* Header CRC */\n    proto_tree_add_item(tree, hf_fp_header_crc, tvb, offset, 1, ENC_BIG_ENDIAN);\n\n    /* Frame Type */\n    is_control_frame = tvb_get_guint8(tvb, offset) & 0x01;\n    proto_tree_add_item(tree, hf_fp_ft, tvb, offset, 1, ENC_BIG_ENDIAN);\n    offset++;\n\n    col_append_str(pinfo->cinfo, COL_INFO, is_control_frame ? \" [Control] \" : \" [Data] \");\n\n    if (is_control_frame) {\n        dissect_common_control(tvb, pinfo, tree, offset, p_fp_info);\n    }\n    else {\n        /* TODO: DATA */\n    }\n}\n\n\n\n\n/************************/\n/* DCH control messages */\n\nstatic int\ndissect_dch_timing_adjustment(proto_tree *tree, packet_info *pinfo, tvbuff_t *tvb, int offset)\n{\n    guint8      control_cfn;\n    gint16      toa;\n    proto_item *toa_ti;\n\n    /* CFN control */\n    control_cfn = tvb_get_guint8(tvb, offset);\n    proto_tree_add_item(tree, hf_fp_cfn_control, tvb, offset, 1, ENC_BIG_ENDIAN);\n    offset++;\n\n    /* ToA */\n    toa = tvb_get_ntohs(tvb, offset);\n    toa_ti = proto_tree_add_item(tree, hf_fp_toa, tvb, offset, 2, ENC_BIG_ENDIAN);\n    offset += 2;\n\n    expert_add_info_format(pinfo, toa_ti, &ei_fp_timing_adjustmentment_reported, \"Timing adjustmentment reported (%f ms)\", (float)(toa / 8));\n\n    col_append_fstr(pinfo->cinfo, COL_INFO,\n                    \" CFN = %u, ToA = %d\", control_cfn, toa);\n\n    return offset;\n}\n\nstatic int\ndissect_dch_rx_timing_deviation(packet_info *pinfo, proto_tree *tree,\n                                tvbuff_t *tvb, int offset,\n                                struct fp_info *p_fp_info)\n{\n    guint16     timing_deviation;\n    gint        timing_deviation_chips;\n    proto_item *timing_deviation_ti;\n\n    /* CFN control */\n    proto_tree_add_item(tree, hf_fp_cfn_control, tvb, offset, 1, ENC_BIG_ENDIAN);\n    offset++;\n\n    /* Rx Timing Deviation */\n    timing_deviation = tvb_get_guint8(tvb, offset);\n    timing_deviation_ti = proto_tree_add_item(tree, hf_fp_dch_rx_timing_deviation, tvb, offset, 1, ENC_BIG_ENDIAN);\n    offset++;\n\n    /* May be extended in R7, but in this case there are at least 2 bytes remaining */\n    if ((p_fp_info->release == 7) &&\n        (tvb_reported_length_remaining(tvb, offset) >= 2)) {\n\n        /* New IE flags */\n        guint64 extended_bits_present;\n        guint64 e_rucch_present;\n\n        /* Read flags */\n        proto_tree_add_bits_ret_val(tree, hf_fp_e_rucch_present, tvb,\n                                    offset*8 + 6, 1, &e_rucch_present, ENC_BIG_ENDIAN);\n        proto_tree_add_bits_ret_val(tree, hf_fp_extended_bits_present, tvb,\n                                    offset*8 + 7, 1, &extended_bits_present, ENC_BIG_ENDIAN);\n        offset++;\n\n        /* Optional E-RUCCH */\n        if (e_rucch_present) {\n\n            /* Value of bit_offset depends upon division type */\n            int bit_offset;\n\n            switch (p_fp_info->division) {\n                case Division_TDD_384:\n                    bit_offset = 6;\n                    break;\n                case Division_TDD_768:\n                    bit_offset = 5;\n                    break;\n                default:\n                    {\n                        proto_tree_add_expert(tree, pinfo, &ei_fp_expecting_tdd, tvb, 0, 0);\n                        bit_offset = 6;\n                    }\n            }\n\n            proto_tree_add_item(tree, hf_fp_dch_e_rucch_flag, tvb, offset, 1, ENC_BIG_ENDIAN);\n            proto_tree_add_bits_item(tree, hf_fp_dch_e_rucch_flag, tvb,\n                                     offset*8 + bit_offset, 1, ENC_BIG_ENDIAN);\n        }\n\n        /* Timing deviation may be extended by another:\n           - 1 bits (3.84 TDD)    OR\n           - 2 bits (7.68 TDD)\n        */\n        if (extended_bits_present) {\n            guint8 extra_bits;\n            guint bits_to_extend;\n            switch (p_fp_info->division) {\n                case Division_TDD_384:\n                    bits_to_extend = 1;\n                    break;\n                case Division_TDD_768:\n                    bits_to_extend = 2;\n                    break;\n\n                default:\n                    /* TODO: report unexpected division type */\n                    bits_to_extend = 1;\n                    break;\n            }\n            extra_bits = tvb_get_guint8(tvb, offset) &\n                             ((bits_to_extend == 1) ? 0x01 : 0x03);\n            timing_deviation = (extra_bits << 8) | (timing_deviation);\n            proto_item_append_text(timing_deviation_ti,\n                                   \" (extended to 0x%x)\",\n                                   timing_deviation);\n            proto_tree_add_bits_item(tree, hf_fp_extended_bits, tvb,\n                                     offset*8 + (8-bits_to_extend), bits_to_extend, ENC_BIG_ENDIAN);\n            offset++;\n        }\n    }\n\n    timing_deviation_chips = (timing_deviation*4) - 1024;\n    proto_item_append_text(timing_deviation_ti, \" (%d chips)\",\n                           timing_deviation_chips);\n\n    col_append_fstr(pinfo->cinfo, COL_INFO, \" deviation = %u (%d chips)\",\n                    timing_deviation, timing_deviation_chips);\n\n    return offset;\n}\n\nstatic int\ndissect_dch_dl_synchronisation(proto_tree *tree, packet_info *pinfo, tvbuff_t *tvb, int offset)\n{\n    /* CFN control */\n    guint cfn = tvb_get_guint8(tvb, offset);\n    proto_tree_add_item(tree, hf_fp_cfn_control, tvb, offset, 1, ENC_BIG_ENDIAN);\n    offset++;\n\n    col_append_fstr(pinfo->cinfo, COL_INFO, \" CFN = %u\", cfn);\n\n    return offset;\n}\n\nstatic int\ndissect_dch_ul_synchronisation(proto_tree *tree, packet_info *pinfo, tvbuff_t *tvb, int offset)\n{\n    guint8 cfn;\n    gint16 toa;\n\n    /* CFN control */\n    cfn = tvb_get_guint8(tvb, offset);\n    proto_tree_add_item(tree, hf_fp_cfn_control, tvb, offset, 1, ENC_BIG_ENDIAN);\n    offset++;\n\n    /* ToA */\n    toa = tvb_get_ntohs(tvb, offset);\n    proto_tree_add_item(tree, hf_fp_toa, tvb, offset, 2, ENC_BIG_ENDIAN);\n    offset += 2;\n\n    col_append_fstr(pinfo->cinfo, COL_INFO, \" CFN = %u, ToA = %d\",\n                    cfn, toa);\n\n    return offset;\n}\n\nstatic int\ndissect_dch_outer_loop_power_control(proto_tree *tree, packet_info *pinfo, tvbuff_t *tvb, int offset)\n{\n    /* UL SIR target */\n    float target = (float)-8.2 + ((float)0.1 * (float)(int)(tvb_get_guint8(tvb, offset)));\n    proto_tree_add_float(tree, hf_fp_ul_sir_target, tvb, offset, 1, target);\n    offset++;\n\n    col_append_fstr(pinfo->cinfo, COL_INFO, \" UL SIR Target = %f\", target);\n\n    return offset;\n}\n\nstatic int\ndissect_dch_dl_node_synchronisation(proto_tree *tree, packet_info *pinfo, tvbuff_t *tvb, int offset)\n{\n    return dissect_common_dl_node_synchronisation(pinfo, tree, tvb, offset);\n}\n\nstatic int\ndissect_dch_ul_node_synchronisation(proto_tree *tree, packet_info *pinfo, tvbuff_t *tvb, int offset)\n{\n    return dissect_common_ul_node_synchronisation(pinfo, tree, tvb, offset);\n}\n\nstatic int\ndissect_dch_radio_interface_parameter_update(proto_tree *tree, packet_info *pinfo _U_, tvbuff_t *tvb, int offset)\n{\n    int    n;\n    guint8 value;\n\n    /* Show defined flags in these 2 bytes */\n    for (n=4; n >= 0; n--) {\n        proto_tree_add_item(tree, hf_fp_radio_interface_parameter_update_flag[n], tvb, offset, 2, ENC_BIG_ENDIAN);\n    }\n    offset += 2;\n\n    /* CFN  */\n    tvb_get_guint8(tvb, offset);\n    proto_tree_add_item(tree, hf_fp_cfn, tvb, offset, 1, ENC_BIG_ENDIAN);\n    offset++;\n\n    /* DPC mode */\n    proto_tree_add_item(tree, hf_fp_dpc_mode, tvb, offset, 1, ENC_BIG_ENDIAN);\n\n    /* TPC PO */\n    proto_tree_add_item(tree, hf_fp_tpc_po, tvb, offset, 1, ENC_BIG_ENDIAN);\n    offset++;\n\n    /* Multiple RL sets indicator */\n    proto_tree_add_item(tree, hf_fp_multiple_rl_set_indicator, tvb, offset, 1, ENC_BIG_ENDIAN);\n    offset += 2;\n\n    /* MAX_UE_TX_POW */\n    value = (tvb_get_guint8(tvb, offset) & 0x7f);\n    proto_tree_add_int(tree, hf_fp_max_ue_tx_pow, tvb, offset, 1, -55 + value);\n    offset++;\n\n    return offset;\n}\n\nstatic int\ndissect_dch_timing_advance(proto_tree *tree, packet_info *pinfo,\n                           tvbuff_t *tvb, int offset, struct fp_info *p_fp_info)\n{\n    guint8      cfn;\n    guint16     timing_advance;\n    proto_item *timing_advance_ti;\n\n    /* CFN control */\n    cfn = tvb_get_guint8(tvb, offset);\n    proto_tree_add_item(tree, hf_fp_cfn_control, tvb, offset, 1, ENC_BIG_ENDIAN);\n    offset++;\n\n    /* Timing Advance */\n    timing_advance = (tvb_get_guint8(tvb, offset) & 0x3f) * 4;\n    timing_advance_ti = proto_tree_add_uint(tree, hf_fp_timing_advance, tvb, offset, 1, timing_advance);\n    offset++;\n\n    if ((p_fp_info->release == 7) &&\n        (tvb_reported_length_remaining(tvb, offset) > 0)) {\n\n        /* New IE flags */\n        guint8 flags = tvb_get_guint8(tvb, offset);\n        guint8 extended_bits = flags & 0x01;\n        offset++;\n\n        if (extended_bits) {\n            guint8 extra_bit = tvb_get_guint8(tvb, offset) & 0x01;\n            proto_item_append_text(timing_advance_ti, \" (extended to %u)\",\n                                   (timing_advance << 1) | extra_bit);\n        }\n        offset++;\n    }\n\n    col_append_fstr(pinfo->cinfo, COL_INFO, \" CFN = %u, TA = %u\",\n                    cfn, timing_advance);\n\n    return offset;\n}\n\nstatic int\ndissect_dch_tnl_congestion_indication(proto_tree *tree, packet_info *pinfo, tvbuff_t *tvb, int offset)\n{\n    guint64 status;\n\n    /* Congestion status */\n    proto_tree_add_bits_ret_val(tree, hf_fp_congestion_status, tvb,\n                                offset*8 + 6, 2, &status, ENC_BIG_ENDIAN);\n    offset++;\n\n    col_append_fstr(pinfo->cinfo, COL_INFO, \" status = %s\",\n                    val_to_str_const((guint16)status, congestion_status_vals, \"unknown\"));\n\n    return offset;\n}\n\n\n\n\n/* DCH control frame */\nstatic void\ndissect_dch_control_frame(proto_tree *tree, packet_info *pinfo, tvbuff_t *tvb,\n                          int offset, struct fp_info *p_fp_info)\n{\n    /* Control frame type */\n    guint8 control_frame_type = tvb_get_guint8(tvb, offset);\n    proto_tree_add_item(tree, hf_fp_dch_control_frame_type, tvb, offset, 1, ENC_BIG_ENDIAN);\n    offset++;\n\n    col_append_str(pinfo->cinfo, COL_INFO,\n                   val_to_str_const(control_frame_type,\n                                    dch_control_frame_type_vals, \"Unknown\"));\n\n    switch (control_frame_type) {\n        case DCH_TIMING_ADJUSTMENT:\n            /*offset =*/ dissect_dch_timing_adjustment(tree, pinfo, tvb, offset);\n            break;\n        case DCH_RX_TIMING_DEVIATION:\n            /*offset =*/ dissect_dch_rx_timing_deviation(pinfo, tree, tvb, offset, p_fp_info);\n            break;\n        case DCH_DL_SYNCHRONISATION:\n            /*offset =*/ dissect_dch_dl_synchronisation(tree, pinfo, tvb, offset);\n            break;\n        case DCH_UL_SYNCHRONISATION:\n            /*offset =*/ dissect_dch_ul_synchronisation(tree, pinfo, tvb, offset);\n            break;\n        case DCH_OUTER_LOOP_POWER_CONTROL:\n            /*offset =*/ dissect_dch_outer_loop_power_control(tree, pinfo, tvb, offset);\n            break;\n        case DCH_DL_NODE_SYNCHRONISATION:\n            /*offset =*/ dissect_dch_dl_node_synchronisation(tree, pinfo, tvb, offset);\n            break;\n        case DCH_UL_NODE_SYNCHRONISATION:\n            /*offset =*/ dissect_dch_ul_node_synchronisation(tree, pinfo, tvb, offset);\n            break;\n        case DCH_RADIO_INTERFACE_PARAMETER_UPDATE:\n            /*offset =*/ dissect_dch_radio_interface_parameter_update(tree, pinfo, tvb, offset);\n            break;\n        case DCH_TIMING_ADVANCE:\n            /*offset =*/ dissect_dch_timing_advance(tree, pinfo, tvb, offset, p_fp_info);\n            break;\n        case DCH_TNL_CONGESTION_INDICATION:\n            /*offset =*/ dissect_dch_tnl_congestion_indication(tree, pinfo, tvb, offset);\n            break;\n    }\n\n    /* Spare Extension */\n   /* dissect_spare_extension_and_crc(tvb, pinfo, tree, 0, offset);\n    */\n}\n\n/*******************************/\n/* Dissect a DCH channel       */\nstatic void\ndissect_dch_channel_info(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\n                         int offset, struct fp_info *p_fp_info, void *data)\n{\n    gboolean is_control_frame;\n    guint8   cfn;\n    guint header_length = 0;\n    guint16 header_crc = 0;\n    proto_item * header_crc_pi = NULL;\n\n    /* Header CRC */\n    header_crc = tvb_get_bits8(tvb, 0, 7);\n    header_crc_pi = proto_tree_add_item(tree, hf_fp_header_crc, tvb, offset, 1, ENC_BIG_ENDIAN);\n\n    /* Frame Type */\n    is_control_frame = tvb_get_guint8(tvb, offset) & 0x01;\n    proto_tree_add_item(tree, hf_fp_ft, tvb, offset, 1, ENC_BIG_ENDIAN);\n    offset++;\n\n    col_append_str(pinfo->cinfo, COL_INFO,\n                   is_control_frame ? \" [Control] \" :\n                                      ((p_fp_info->is_uplink) ? \" [ULData] \" :\n                                                                \" [DLData] \" ));\n\n    if (is_control_frame) {\n        /* DCH control frame */\n        dissect_dch_control_frame(tree, pinfo, tvb, offset, p_fp_info);\n        /* For control frame the header CRC is actually frame CRC covering all\n         * bytes except the first */\n        if (preferences_header_checksum) {\n            verify_control_frame_crc(tvb, pinfo, header_crc_pi, header_crc);\n        }\n    } else {\n        /************************/\n        /* DCH data here        */\n        int chan;\n        /* CFN */\n        proto_tree_add_item(tree, hf_fp_cfn, tvb, offset, 1, ENC_BIG_ENDIAN);\n        cfn = tvb_get_guint8(tvb, offset);\n        offset++;\n\n        col_append_fstr(pinfo->cinfo, COL_INFO, \"CFN=%03u \", cfn);\n\n        /* One TFI for each channel */\n        for (chan=0; chan < p_fp_info->num_chans; chan++) {\n            proto_tree_add_item(tree, hf_fp_tfi, tvb, offset, 1, ENC_BIG_ENDIAN);\n            offset++;\n        }\n        header_length = offset;\n        /* Dissect TB data */\n        offset = dissect_tb_data(tvb, pinfo, tree, offset, p_fp_info, &mac_fdd_dch_handle, data);\n\n        /* QE (uplink only) */\n        if (p_fp_info->is_uplink) {\n            proto_tree_add_item(tree, hf_fp_quality_estimate, tvb, offset, 1, ENC_BIG_ENDIAN);\n            offset++;\n        }\n\n        /* CRCI bits (uplink only) */\n        if (p_fp_info->is_uplink) {\n            offset = dissect_crci_bits(tvb, pinfo, tree, p_fp_info, offset);\n        }\n        if (preferences_header_checksum) {\n            verify_header_crc(tvb, pinfo, header_crc_pi, header_crc, header_length);\n        }\n        /* Spare extension and payload CRC (optional) */\n        dissect_spare_extension_and_crc(tvb, pinfo, tree,\n                                        p_fp_info->dch_crc_present, offset, header_length);\n    }\n}\n\n/**********************************/\n/* Dissect an E-DCH channel       */\nstatic void\ndissect_e_dch_channel_info(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\n                           int offset, struct fp_info *p_fp_info,\n                           gboolean is_common, rlc_info  *rlcinf,\n                           void *data)\n{\n    gboolean is_control_frame;\n    guint8   number_of_subframes;\n    guint8   cfn;\n    int      n;\n    struct   edch_t1_subframe_info subframes[16];\n    guint16 header_crc = 0;\n    proto_item * header_crc_pi = NULL;\n    guint header_length = 0;\n\n    if (p_fp_info->edch_type == 1) {\n        col_append_str(pinfo->cinfo, COL_INFO, \" (T2)\");\n    }\n\n    /* Header CRC */\n     /* the bitmask doesn't properly handle this delicate case, do manually */\n    header_crc = (tvb_get_bits8(tvb, offset*8, 7) << 4) + tvb_get_bits8(tvb, offset*8+8, 4);\n\n    /* Frame Type */\n    is_control_frame = tvb_get_guint8(tvb, offset) & 0x01;\n\n    col_append_str(pinfo->cinfo, COL_INFO, is_control_frame ? \" [Control] \" : \" [Data] \");\n\n    if (is_control_frame) {\n        /* DCH control frame */\n\n        /* For control frame the header CRC is actually frame CRC covering all\n         * bytes except the first */\n        header_crc = tvb_get_bits8(tvb, 0, 7);\n        header_crc_pi = proto_tree_add_item(tree, hf_fp_header_crc, tvb, 0, 1, ENC_BIG_ENDIAN);\n        proto_tree_add_item(tree, hf_fp_ft, tvb, 0, 1, ENC_BIG_ENDIAN);\n        offset++;\n        if (preferences_header_checksum) {\n            verify_control_frame_crc(tvb, pinfo, header_crc_pi, header_crc);\n        }\n        dissect_dch_control_frame(tree, pinfo, tvb, offset, p_fp_info);\n    }\n    else {\n        /********************************/\n        /* E-DCH data here              */\n        guint  bit_offset = 0;\n        guint  total_pdus = 0;\n        guint  total_bits = 0;\n        gboolean dissected = FALSE;\n\n        header_crc_pi = proto_tree_add_uint_format(tree, hf_fp_edch_header_crc, tvb,\n                offset, 2, header_crc,\n                \"%u%u%u%u%u%u%u.%u%u%u%u.... = E-DCH Header CRC: 0x%x\",\n                (header_crc >> 10) & 1,\n                (header_crc >> 9) & 1,\n                (header_crc >> 8) & 1,\n                (header_crc >> 7) & 1,\n                (header_crc >> 6) & 1,\n                (header_crc >> 5) & 1,\n                (header_crc >> 4) & 1,\n                (header_crc >> 3) & 1,\n                (header_crc >> 2) & 1,\n                (header_crc >> 1) & 1,\n                (header_crc >> 0) & 1, header_crc);\n        proto_tree_add_item(tree, hf_fp_ft, tvb, offset, 1, ENC_BIG_ENDIAN);\n        offset++;\n        /* FSN */\n        proto_tree_add_item(tree, hf_fp_edch_fsn, tvb, offset, 1, ENC_BIG_ENDIAN);\n        offset++;\n\n        /* Number of subframes.\n           This was 3 bits in early releases, is 4 bits offset by 1 in later releases  */\n        if ((p_fp_info->release >= 6) &&\n            ((p_fp_info->release_year > 2005) ||\n             ((p_fp_info->release_year == 2005) && (p_fp_info->release_month >= 9)))) {\n\n            /* Use 4 bits plus offset of 1 */\n            number_of_subframes = (tvb_get_guint8(tvb, offset) & 0x0f) + 1;\n        }\n        else {\n            /* Use 3 bits only */\n            number_of_subframes = (tvb_get_guint8(tvb, offset) & 0x07);\n        }\n        proto_tree_add_uint(tree, hf_fp_edch_number_of_subframes, tvb, offset, 1,\n                            number_of_subframes);\n\n        offset++;\n\n        /* CFN */\n        cfn = tvb_get_guint8(tvb, offset);\n        proto_tree_add_item(tree, hf_fp_cfn, tvb, offset, 1, ENC_BIG_ENDIAN);\n        offset++;\n\n        /* Remainder of T2 or common data frames differ here... */\n        if (p_fp_info->edch_type == 1) {\n            dissect_e_dch_t2_or_common_channel_info(tvb, pinfo, tree, offset, p_fp_info,\n                                                    number_of_subframes,\n                                                    is_common, header_crc,\n                                                    header_crc_pi, data);\n            return;\n        }\n\n        /* EDCH subframe header list */\n        for (n=0; n < number_of_subframes; n++) {\n            int i;\n            int start_offset = offset;\n            proto_item *subframe_header_ti;\n            proto_tree *subframe_header_tree;\n\n            /* Add subframe header subtree */\n            subframe_header_ti = proto_tree_add_string_format(tree, hf_fp_edch_subframe_header, tvb, offset, 0,\n                                                              \"\", \"Subframe\");\n            subframe_header_tree = proto_item_add_subtree(subframe_header_ti, ett_fp_edch_subframe_header);\n\n            /* Number of HARQ Retransmissions */\n            proto_tree_add_item(subframe_header_tree, hf_fp_edch_harq_retransmissions, tvb,\n                                offset, 1, ENC_BIG_ENDIAN);\n\n            /* Subframe number */\n            subframes[n].subframe_number = (tvb_get_guint8(tvb, offset) & 0x07);\n            proto_tree_add_bits_item(subframe_header_tree, hf_fp_edch_subframe_number, tvb,\n                                     offset*8+5, 1, ENC_BIG_ENDIAN);\n            offset++;\n\n            /* Number of MAC-es PDUs */\n            subframes[n].number_of_mac_es_pdus = (tvb_get_guint8(tvb, offset) & 0xf0) >> 4;\n            proto_tree_add_item(subframe_header_tree, hf_fp_edch_number_of_mac_es_pdus,\n                                tvb, offset, 1, ENC_BIG_ENDIAN);\n            bit_offset = 4;\n\n            proto_item_append_text(subframe_header_ti, \" %u header (%u MAC-es PDUs)\",\n                                   subframes[n].subframe_number,\n                                   subframes[n].number_of_mac_es_pdus);\n\n            /* Details of each MAC-es PDU */\n            for (i=0; i < subframes[n].number_of_mac_es_pdus; i++) {\n                guint64 ddi;\n                guint64 n_pdus;    /*Size of the PDU*/\n\n                proto_item *ddi_ti;\n                gint ddi_size = -1;\n                int     p;\n\n                /* DDI (6 bits) */\n                ddi_ti = proto_tree_add_bits_ret_val(subframe_header_tree, hf_fp_edch_ddi, tvb,\n                                                     offset*8 + bit_offset, 6, &ddi, ENC_BIG_ENDIAN);\n\n                if (rlcinf) {\n                    rlcinf->rbid[i] = (guint8)ddi;\n                }\n                /********************************/\n                /* Look up data in higher layers*/\n                /* Look up the size from this DDI value */\n                for (p=0; p < p_fp_info->no_ddi_entries; p++) {\n                    if (ddi == p_fp_info->edch_ddi[p]) {\n                        ddi_size = p_fp_info->edch_macd_pdu_size[p];\n\n                        break;\n                    }\n                }\n\n                if (ddi_size == -1) {\n                    expert_add_info_format(pinfo, ddi_ti, &ei_fp_ddi_not_defined, \"DDI %u not defined for this UE!\", (guint)ddi);\n                    return;\n                }\n                else {\n                    proto_item_append_text(ddi_ti, \" (%d bits)\", ddi_size);\n                }\n\n                subframes[n].ddi[i] = (guint8)ddi;\n                bit_offset += 6;\n\n                /* Number of MAC-d PDUs (6 bits) */\n                proto_tree_add_bits_ret_val(subframe_header_tree, hf_fp_edch_number_of_mac_d_pdus, tvb,\n                                            offset*8 + bit_offset, 6, &n_pdus, ENC_BIG_ENDIAN);\n\n                subframes[n].number_of_mac_d_pdus[i] = (guint8)n_pdus;\n                bit_offset += 6;\n            }\n\n            offset += ((bit_offset+7)/8);\n\n            /* Tree should cover entire subframe header */\n            proto_item_set_len(subframe_header_ti, offset - start_offset);\n        }\n        header_length = offset;\n        /* EDCH subframes */\n        for (n=0; n < number_of_subframes; n++) {\n            int i;\n            proto_item *subframe_ti;\n            proto_tree *subframe_tree;\n            guint bits_in_subframe = 0;\n            guint mac_d_pdus_in_subframe = 0;\n            guint    lchid=0;    /*Logcial channel id*/\n            umts_mac_info *macinf;\n            bit_offset = 0;\n\n            macinf = (umts_mac_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_umts_mac, 0);\n            /* Add subframe subtree */\n            subframe_ti = proto_tree_add_string_format(tree, hf_fp_edch_subframe, tvb, offset, 0,\n                                                       \"\", \"Subframe %u data\", subframes[n].subframe_number);\n            subframe_tree = proto_item_add_subtree(subframe_ti, ett_fp_edch_subframe);\n\n            for (i=0; i < subframes[n].number_of_mac_es_pdus; i++) {\n                int         m;\n                guint16     size = 0;\n                /* guint8      tsn; */\n                guint       send_size;\n                proto_item  *ti;\n                int         macd_idx;\n                proto_tree  *maces_tree = NULL;\n\n                /** TODO: Merge these two loops? **/\n                /* Look up mac-d pdu size for this ddi */\n                for (m=0; m < p_fp_info->no_ddi_entries; m++) {\n                    if (subframes[n].ddi[i] == p_fp_info->edch_ddi[m]) {\n                        size = p_fp_info->edch_macd_pdu_size[m];\n                        break;\n                    }\n                }\n                /* Look up logicalchannel id for this DDI value */\n                for (m=0; m < p_fp_info->no_ddi_entries; m++) {\n                    if (subframes[n].ddi[i] == p_fp_info->edch_ddi[m]) {\n                        lchid = p_fp_info->edch_lchId[m];\n                        break;\n                    }\n                }\n\n                if (m == p_fp_info->no_ddi_entries) {\n                    /* Not found.  Oops */\n                    expert_add_info(pinfo, NULL, &ei_fp_unable_to_locate_ddi_entry);\n                    return;\n                }\n\n                /* Send MAC-dd PDUs together as one MAC-es PDU */\n                send_size = size * subframes[n].number_of_mac_d_pdus[i];\n\n                /* 2 bits spare */\n                proto_tree_add_item(subframe_tree, hf_fp_edch_pdu_padding, tvb,\n                                    offset + (bit_offset/8),\n                                    1, ENC_BIG_ENDIAN);\n                bit_offset += 2;\n\n                /* TSN */\n                /* tsn = (tvb_get_guint8(tvb, offset + (bit_offset/8)) & 0x3f); */\n                proto_tree_add_item(subframe_tree, hf_fp_edch_tsn, tvb,\n                                    offset + (bit_offset/8),\n                                    1, ENC_BIG_ENDIAN);\n                bit_offset += 6;\n\n                /* PDU */\n                if (subframe_tree) {\n                    ti = proto_tree_add_item(subframe_tree, hf_fp_edch_mac_es_pdu, tvb,\n                                             offset + (bit_offset/8),\n                                             ((bit_offset % 8) + send_size + 7) / 8,\n                                             ENC_NA);\n                    proto_item_append_text(ti, \" (%u * %u = %u bits, PDU %d)\",\n                                           size, subframes[n].number_of_mac_d_pdus[i],\n                                           send_size, n);\n                    maces_tree = proto_item_add_subtree(ti, ett_fp_edch_maces);\n                }\n                for (macd_idx = 0; macd_idx < subframes[n].number_of_mac_d_pdus[i]; macd_idx++) {\n\n                    if (preferences_call_mac_dissectors /*&& !rlc_is_ciphered(pinfo)*/) {\n                        tvbuff_t *next_tvb;\n                        pinfo->fd->subnum = macd_idx; /* set subframe number to current TB */\n                        /* create new TVB and pass further on */\n                        next_tvb = tvb_new_subset(tvb, offset + bit_offset/8,\n                                ((bit_offset % 8) + size + 7) / 8, -1);\n\n\n                        /*This was all previously stored in [0] rather than [macd_idx] and cur_tb wasn't updated!*/\n                        /*Set up information needed for MAC and lower layers*/\n                        macinf->content[macd_idx] = lchId_type_table[lchid];     /*Set the proper Content type for the mac layer.*/\n                        macinf->lchid[macd_idx] = lchid;\n                        rlcinf->mode[macd_idx] = lchId_rlc_map[lchid]; /* Set RLC mode by lchid to RLC_MODE map in nbap.h */\n\n                        /* Set U-RNTI to ComuncationContext signaled from nbap*/\n                        rlcinf->urnti[macd_idx] = p_fp_info->com_context_id;\n                        rlcinf->rbid[macd_idx] = lchid; /*subframes[n].ddi[i];*/    /*Save the DDI value for RLC*/\n                        /*g_warning(\"========Setting RBID:%d for lchid:%d\", subframes[n].ddi[i], lchid);*/\n                        /* rlcinf->mode[0] = RLC_AM;*/\n                        rlcinf->li_size[macd_idx] = RLC_LI_7BITS;\n\n#if 0\n                        /*If this entry exists, SECRUITY_MODE is completed*/\n                        if ( rrc_ciph_inf && g_tree_lookup(rrc_ciph_inf, GINT_TO_POINTER((gint)p_fp_info->com_context_id)) ) {\n                            rlcinf->ciphered[macd_idx] = TRUE;\n                        } else {\n                            rlcinf->ciphered[macd_idx] = FALSE;\n                        }\n#endif\n                        rlcinf->ciphered[macd_idx] = FALSE;\n                        rlcinf->deciphered[macd_idx] = FALSE;\n                        p_fp_info->cur_tb = macd_idx;    /*Set the transport block index (NOTE: This and not subnum is used in MAC dissector!)*/\n\n                        /* TODO: use maces_tree? */\n                        call_dissector_with_data(mac_fdd_edch_handle, next_tvb, pinfo, top_level_tree, data);\n                        dissected = TRUE;\n                    }\n                    else {\n                        /* Just add as a MAC-d PDU */\n                        proto_tree_add_item(maces_tree, hf_fp_mac_d_pdu, tvb,\n                                            offset + (bit_offset/8),\n                                            ((bit_offset % 8) + size + 7) / 8,\n                                            ENC_NA);\n                    }\n                    bit_offset += size;\n                }\n\n                bits_in_subframe += send_size;\n                mac_d_pdus_in_subframe += subframes[n].number_of_mac_d_pdus[i];\n\n                /* Pad out to next byte */\n                if (bit_offset % 8) {\n                    bit_offset += (8 - (bit_offset % 8));\n                }\n            }\n\n            if (tree) {\n                /* Tree should cover entire subframe */\n                proto_item_set_len(subframe_ti, bit_offset/8);\n                /* Append summary info to subframe label */\n                proto_item_append_text(subframe_ti, \" (%u bits in %u MAC-d PDUs)\",\n                                       bits_in_subframe, mac_d_pdus_in_subframe);\n            }\n            total_pdus += mac_d_pdus_in_subframe;\n            total_bits += bits_in_subframe;\n\n            offset += (bit_offset/8);\n        }\n\n        /* Report number of subframes in info column\n         * do this only if no other dissector was called */\n        if (dissected == FALSE) {\n            col_append_fstr(pinfo->cinfo, COL_INFO,\n                            \" CFN = %03u   (%u bits in %u pdus in %u subframes)\",\n                            cfn, total_bits, total_pdus, number_of_subframes);\n        }\n        /* Add data summary to info column */\n        /*col_append_fstr(pinfo->cinfo, COL_INFO, \" (%u bytes in %u SDUs in %u MAC-is PDUs in %u subframes)\",\n                        total_bytes, macis_sdus_found, macis_pdus, number_of_subframes);*/\n        if (preferences_header_checksum) {\n            verify_header_crc_edch(tvb, pinfo, header_crc_pi, header_crc, header_length);\n        }\n        /* Spare extension and payload CRC (optional) */\n        dissect_spare_extension_and_crc(tvb, pinfo, tree,\n                                        p_fp_info->dch_crc_present, offset, header_length);\n    }\n}\n\n/* Dissect the remainder of the T2 or common frame that differs from T1 */\nstatic void\ndissect_e_dch_t2_or_common_channel_info(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\n                                        int offset, struct fp_info *p_fp_info,\n                                        int number_of_subframes,\n                                        gboolean is_common,\n                                        guint16 header_crc,\n                                        proto_item * header_crc_pi,\n                                        void *data)\n{\n    int      n;\n    int      pdu_no;\n    guint64  total_macis_sdus;\n    guint16  macis_sdus_found = 0;\n    guint16  macis_pdus       = 0;\n    gboolean F                = TRUE; /* We want to continue loop if get E-RNTI indication... */\n    gint     bit_offset;\n    proto_item *subframe_macis_descriptors_ti = NULL;\n    static struct edch_t2_subframe_info subframes[16];\n    guint header_length = 0;\n    /* User Buffer size */\n    proto_tree_add_bits_item(tree, hf_fp_edch_user_buffer_size, tvb, offset*8,\n                             18, ENC_BIG_ENDIAN);\n    offset += 2;\n\n    /* Spare is in-between... */\n\n    /* Total number of MAC-is SDUs */\n    proto_tree_add_bits_ret_val(tree, hf_fp_edch_no_macid_sdus, tvb, offset*8+4,\n                                12, &total_macis_sdus, ENC_BIG_ENDIAN);\n    offset += 2;\n\n    if (is_common) {\n        /* E-RNTI */\n        proto_tree_add_item(tree, hf_fp_edch_e_rnti, tvb, offset, 2, ENC_BIG_ENDIAN);\n        offset += 2;\n    }\n\n    bit_offset = offset*8;\n    /* EDCH subframe header list */\n    for (n=0; n < number_of_subframes; n++) {\n        guint64    subframe_number;\n        guint64    no_of_macis_pdus;\n        proto_item *subframe_header_ti;\n        proto_tree *subframe_header_tree;\n\n        /* Add subframe header subtree */\n        subframe_header_ti = proto_tree_add_string_format(tree, hf_fp_edch_subframe_header, tvb, offset, 0,\n                                                          \"\", \"Subframe\");\n        subframe_header_tree = proto_item_add_subtree(subframe_header_ti, ett_fp_edch_subframe_header);\n\n        /* Spare bit */\n        bit_offset++;\n\n        if (!is_common) {\n            /* Number of HARQ Retransmissions */\n            proto_tree_add_item(subframe_header_tree, hf_fp_edch_harq_retransmissions, tvb,\n                                bit_offset/8, 1, ENC_BIG_ENDIAN);\n            bit_offset += 4;\n        }\n\n        /* Subframe number */\n        proto_tree_add_bits_ret_val(subframe_header_tree, hf_fp_edch_subframe_number, tvb,\n                                    bit_offset, 3, &subframe_number, ENC_BIG_ENDIAN);\n        subframes[n].subframe_number = (guint8)subframe_number;\n        bit_offset += 3;\n\n        /* Number of MAC-is PDUs */\n        proto_tree_add_bits_ret_val(subframe_header_tree, hf_fp_edch_number_of_mac_is_pdus, tvb,\n                                    bit_offset, 4, &no_of_macis_pdus, ENC_BIG_ENDIAN);\n        bit_offset += 4;\n        subframes[n].number_of_mac_is_pdus = (guint8)no_of_macis_pdus;\n        macis_pdus += subframes[n].number_of_mac_is_pdus;\n\n        /* Next 4 bits are spare for T2*/\n        if (!is_common) {\n            bit_offset += 4;\n        }\n\n        /* Show summary in root */\n        proto_item_append_text(subframe_header_ti, \" (SFN %u, %u MAC-is PDUs)\",\n                               subframes[n].subframe_number, subframes[n].number_of_mac_is_pdus);\n        proto_item_set_len(subframe_header_ti, is_common ? 1 : 2);\n    }\n    offset = bit_offset / 8;\n\n\n    /* MAC-is PDU descriptors for each subframe follow */\n    for (n=0; n < number_of_subframes; n++) {\n        proto_tree *subframe_macis_descriptors_tree;\n\n        /* Add subframe header subtree */\n        subframe_macis_descriptors_ti = proto_tree_add_string_format(tree, hf_fp_edch_macis_descriptors, tvb, offset, 0,\n                                                                     \"\", \"MAC-is descriptors (SFN %u)\", subframes[n].subframe_number);\n        proto_item_set_len(subframe_macis_descriptors_ti, subframes[n].number_of_mac_is_pdus*2);\n        subframe_macis_descriptors_tree = proto_item_add_subtree(subframe_macis_descriptors_ti,\n                                                                 ett_fp_edch_macis_descriptors);\n\n        /* Find a sequence of descriptors for each MAC-is PDU in this subframe */\n        for (pdu_no=0; pdu_no < subframes[n].number_of_mac_is_pdus; pdu_no++) {\n            proto_item *f_ti = NULL;\n\n            subframes[n].number_of_mac_is_sdus[pdu_no] = 0;\n\n            do {\n                /* Check we haven't gone past the limit */\n                if (macis_sdus_found++ > total_macis_sdus) {\n                    expert_add_info_format(pinfo, f_ti, &ei_fp_mac_is_sdus_miscount, \"Found too many (%u) MAC-is SDUs - header said there were %u\", macis_sdus_found, (guint16)total_macis_sdus);\n                }\n\n                /* LCH-ID */\n                subframes[n].mac_is_lchid[pdu_no][subframes[n].number_of_mac_is_sdus[pdu_no]] = (tvb_get_guint8(tvb, offset) & 0xf0) >> 4;\n                proto_tree_add_item(subframe_macis_descriptors_tree, hf_fp_edch_macis_lchid, tvb, offset, 1, ENC_BIG_ENDIAN);\n                if (subframes[n].mac_is_lchid[pdu_no][subframes[n].number_of_mac_is_sdus[pdu_no]] == 15) {\n                    proto_item *ti;\n\n                    /* 4 bits of spare */\n                    offset++;\n\n                    /* E-RNTI */\n                    ti = proto_tree_add_item(tree, hf_fp_edch_e_rnti, tvb, offset, 2, ENC_BIG_ENDIAN);\n                    offset += 2;\n\n                    /* This is only allowed if:\n                       - it's the common case AND\n                       - it's the first descriptor */\n                    if (!is_common) {\n                        expert_add_info(pinfo, ti, &ei_fp_e_rnti_t2_edch_frames);\n                    }\n                    if (subframes[n].number_of_mac_is_sdus[pdu_no] > 0) {\n                        expert_add_info(pinfo, ti, &ei_fp_e_rnti_first_entry);\n                    }\n                    continue;\n                }\n\n                /* Length */\n                subframes[n].mac_is_length[pdu_no][subframes[n].number_of_mac_is_sdus[pdu_no]] = (tvb_get_ntohs(tvb, offset) & 0x0ffe) >> 1;\n                proto_tree_add_item(subframe_macis_descriptors_tree, hf_fp_edch_macis_length, tvb, offset, 2, ENC_BIG_ENDIAN);\n                offset++;\n\n                /* Flag */\n                F = tvb_get_guint8(tvb, offset) & 0x01;\n                f_ti = proto_tree_add_item(subframe_macis_descriptors_tree, hf_fp_edch_macis_flag, tvb, offset, 1, ENC_BIG_ENDIAN);\n\n                subframes[n].number_of_mac_is_sdus[pdu_no]++;\n\n                offset++;\n            } while (F == 0);\n        }\n    }\n\n    /* Check overall count of MAC-is SDUs */\n    if (macis_sdus_found != total_macis_sdus) {\n        expert_add_info_format(pinfo, subframe_macis_descriptors_ti, &ei_fp_mac_is_sdus_miscount, \"Frame contains %u MAC-is SDUs - header said there would be %u!\", macis_sdus_found, (guint16)total_macis_sdus);\n    }\n    header_length = offset;\n    /* Now PDUs */\n    for (n=0; n < number_of_subframes; n++) {\n\n        /* MAC-is PDU */\n        for (pdu_no=0; pdu_no < subframes[n].number_of_mac_is_pdus; pdu_no++) {\n            int i;\n            guint length = 0;\n            umts_mac_is_info * mac_is_info = wmem_new(wmem_file_scope(), umts_mac_is_info);\n\n            mac_is_info->number_of_mac_is_sdus = subframes[n].number_of_mac_is_sdus[pdu_no];\n            DISSECTOR_ASSERT(subframes[n].number_of_mac_is_sdus[pdu_no] <= MAX_MAC_FRAMES);\n            for (i = 0; i < subframes[n].number_of_mac_is_sdus[pdu_no]; i++) {\n                mac_is_info->sdulength[i] = subframes[n].mac_is_length[pdu_no][i];\n                mac_is_info->lchid[i] = subframes[n].mac_is_lchid[pdu_no][i];\n                length += subframes[n].mac_is_length[pdu_no][i];\n            }\n\n            /* Call MAC for this PDU if configured to */\n            if (preferences_call_mac_dissectors) {\n                p_add_proto_data(wmem_file_scope(), pinfo, proto_umts_mac, 0, mac_is_info);\n                call_dissector_with_data(mac_fdd_edch_type2_handle, tvb_new_subset_remaining(tvb, offset), pinfo, top_level_tree, data);\n            }\n            else {\n                /* Still show data if not decoding as MAC PDU */\n                proto_tree_add_item(tree, hf_fp_edch_mac_is_pdu, tvb, offset, length, ENC_NA);\n            }\n\n            /* get_mac_tsn_size in packet-umts_mac.h, gets the global_mac_tsn_size preference in umts_mac.c */\n            if (get_mac_tsn_size() == MAC_TSN_14BITS) {\n                offset += length + 2; /* Plus 2 bytes for TSN 14 bits and SS 2 bit. */\n            } else {\n                offset += length + 1; /* Plus 1 byte for TSN 6 bits and SS 2 bit. */\n            }\n        }\n    }\n    if (preferences_header_checksum) {\n        verify_header_crc_edch(tvb, pinfo, header_crc_pi, header_crc, header_length);\n    }\n    /* Spare extension and payload CRC (optional) */\n    dissect_spare_extension_and_crc(tvb, pinfo, tree,\n                                    p_fp_info->dch_crc_present, offset, header_length);\n}\n\n\n\n/**********************************************************/\n/* Dissect an HSDSCH channel                              */\n/* The data format corresponds to the format              */\n/* described in R5 and R6, and frame type 1 in Release 7. */\nstatic void\ndissect_hsdsch_channel_info(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\n                            int offset, struct fp_info *p_fp_info, void *data)\n{\n    gboolean is_control_frame;\n    guint header_length = 0;\n    guint16 header_crc = 0;\n    proto_item * header_crc_pi = NULL;\n\n    /* Header CRC */\n    header_crc = tvb_get_bits8(tvb, 0, 7);\n    header_crc_pi = proto_tree_add_item(tree, hf_fp_header_crc, tvb, offset, 1, ENC_BIG_ENDIAN);\n\n    /* Frame Type */\n    is_control_frame = tvb_get_guint8(tvb, offset) & 0x01;\n    proto_tree_add_item(tree, hf_fp_ft, tvb, offset, 1, ENC_BIG_ENDIAN);\n    offset++;\n\n    col_append_str(pinfo->cinfo, COL_INFO, is_control_frame ? \" [Control] \" : \" [Data] \");\n\n    if (is_control_frame) {\n        dissect_common_control(tvb, pinfo, tree, offset, p_fp_info);\n        /* For control frame the header CRC is actually frame CRC covering all\n         * bytes except the first */\n        if (preferences_header_checksum) {\n            verify_control_frame_crc(tvb, pinfo, header_crc_pi, header_crc);\n        }\n    }\n    else {\n        guint8 number_of_pdus;\n        guint16 pdu_length;\n        guint16 user_buffer_size;\n        int i;\n        umts_mac_info *macinf;\n        rlc_info *rlcinf;\n\n        rlcinf = (rlc_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_rlc, 0);\n        macinf = (umts_mac_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_umts_mac, 0);\n\n        /**************************************/\n        /* HS-DCH data here (type 1 in R7)    */\n\n        /* Frame Seq Nr */\n        if ((p_fp_info->release == 6) ||\n            (p_fp_info->release == 7)) {\n\n            guint8 frame_seq_no = (tvb_get_guint8(tvb, offset) & 0xf0) >> 4;\n            proto_tree_add_item(tree, hf_fp_frame_seq_nr, tvb, offset, 1, ENC_BIG_ENDIAN);\n\n            col_append_fstr(pinfo->cinfo, COL_INFO, \"  seqno=%u\", frame_seq_no);\n        }\n\n        /* CmCH-PI */\n        proto_tree_add_item(tree, hf_fp_cmch_pi, tvb, offset, 1, ENC_BIG_ENDIAN);\n        offset++;\n\n        /* MAC-d PDU Length (13 bits) */\n        pdu_length = (tvb_get_ntohs(tvb, offset) >> 3);\n        proto_tree_add_item(tree, hf_fp_mac_d_pdu_len, tvb, offset, 2, ENC_BIG_ENDIAN);\n        offset += 2;\n        macinf->pdu_len = pdu_length;\n\n        if ((p_fp_info->release == 6) ||\n            (p_fp_info->release == 7)) {\n\n            /* Flush bit */\n            proto_tree_add_item(tree, hf_fp_flush, tvb, offset-1, 1, ENC_BIG_ENDIAN);\n\n            /* FSN/DRT reset bit */\n            proto_tree_add_item(tree, hf_fp_fsn_drt_reset, tvb, offset-1, 1, ENC_BIG_ENDIAN);\n        }\n\n\n        /* Num of PDUs */\n        number_of_pdus = tvb_get_guint8(tvb, offset);\n        proto_tree_add_item(tree, hf_fp_num_of_pdu, tvb, offset, 1, ENC_BIG_ENDIAN);\n        offset++;\n\n        /* User buffer size */\n        user_buffer_size = tvb_get_ntohs(tvb, offset);\n        proto_tree_add_item(tree, hf_fp_user_buffer_size, tvb, offset, 2, ENC_BIG_ENDIAN);\n        offset += 2;\n\n        header_length = offset;\n\n\n        /************************/\n        /*Configure the pdus*/\n        for (i=0;i<number_of_pdus && i<MIN(MAX_MAC_FRAMES, MAX_RLC_CHANS); i++) {\n            macinf->content[i] = hsdsch_macdflow_id_mac_content_map[p_fp_info->hsdsch_macflowd_id]; /*MAC_CONTENT_PS_DTCH;*/\n            macinf->lchid[i] = fake_lchid_macd_flow[p_fp_info->hsdsch_macflowd_id];/*Faked logical channel id 255 used as a mark if it doesn't exist...*/\n            macinf->fake_chid[i] = TRUE;    /**/\n            macinf->macdflow_id[i] = p_fp_info->hsdsch_macflowd_id;    /*Save the flow ID (+1 to make it human readable (it's zero indexed!))*/\n            /*Figure out RLC_MODE based on MACd-flow-ID, basically MACd-flow-ID = 0 then it's SRB0 == UM else AM*/\n            rlcinf->mode[i] = hsdsch_macdflow_id_rlc_map[p_fp_info->hsdsch_macflowd_id];\n\n\n            /*Check if this is multiplexed (signaled by RRC)*/\n            if ( /*!rlc_is_ciphered(pinfo) &&*/ p_fp_info->hsdhsch_macfdlow_is_mux[p_fp_info->hsdsch_macflowd_id] ) {\n                macinf->ctmux[i] = TRUE;\n            } else if (p_fp_info->hsdsch_macflowd_id == 0) {              /*MACd-flow = 0 is often SRB */\n                expert_add_info(pinfo, NULL, &ei_fp_maybe_srb);\n            } else {\n                    macinf->ctmux[i] = FALSE;    /*Either it's multiplexed and not signled or it's not MUX*/\n            }\n            rlcinf->urnti[i] = p_fp_info->com_context_id;\n            rlcinf->li_size[i] = RLC_LI_7BITS;\n            rlcinf->deciphered[i] = FALSE;\n            rlcinf->ciphered[i] = FALSE;\n            rlcinf->rbid[i] = macinf->lchid[i];\n\n#if 0\n            /*When a flow has been reconfigured rlc needs to be reset.\n             * This needs more work though since we must figure out when the re-configuration becomes\n             * active based on the CFN value\n             * */\n            /*Indicate we need to reset stream*/\n            if (p_fp_info->reset_frag) {\n                rlc_reset_channel(rlcinf->mode[i], macinf->lchid[i], p_fp_info->is_uplink,  rlcinf->urnti[i] );\n                p_fp_info->reset_frag = FALSE;\n\n            }\n#endif\n        }\n\n\n        /* MAC-d PDUs */\n        offset = dissect_macd_pdu_data(tvb, pinfo, tree, offset, pdu_length,\n                                       number_of_pdus, p_fp_info, data);\n\n        col_append_fstr(pinfo->cinfo, COL_INFO, \"  %ux%u-bit PDUs  User-Buffer-Size=%u\",\n                        number_of_pdus, pdu_length, user_buffer_size);\n\n        /* Extra IEs (if there is room for them) */\n        if (((p_fp_info->release == 6) ||\n             (p_fp_info->release == 7)) &&\n            (tvb_reported_length_remaining(tvb, offset) > 2)) {\n\n            int n;\n            guint8 flags;\n            /* guint8 flag_bytes = 0; */\n\n            /* New IE flags */\n            do {\n                proto_item *new_ie_flags_ti;\n                proto_tree *new_ie_flags_tree;\n                guint ies_found = 0;\n\n                /* Add new IE flags subtree */\n                new_ie_flags_ti = proto_tree_add_string_format(tree, hf_fp_hsdsch_new_ie_flags, tvb, offset, 1,\n                                                              \"\", \"New IE flags\");\n                new_ie_flags_tree = proto_item_add_subtree(new_ie_flags_ti, ett_fp_hsdsch_new_ie_flags);\n\n                /* Read next byte */\n                flags = tvb_get_guint8(tvb, offset);\n                /* flag_bytes++; */\n\n                /* Dissect individual bits */\n                for (n=0; n < 8; n++) {\n                    proto_tree_add_item(new_ie_flags_tree, hf_fp_hsdsch_new_ie_flag[n], tvb, offset, 1, ENC_BIG_ENDIAN);\n                    if ((flags >> (7-n)) & 0x01) {\n                        ies_found++;\n                    }\n                }\n                offset++;\n\n                proto_item_append_text(new_ie_flags_ti, \" (%u IEs found)\", ies_found);\n\n                /* Last bit set will indicate another flags byte follows... */\n            } while (0); /*((flags & 0x01) && (flag_bytes < 31));*/\n\n            if (1) /*(flags & 0x8) */ {\n                /* DRT is shown as mandatory in the diagram (3GPP TS 25.435 V6.3.0),\n                   but the description below it states that\n                   it should depend upon the first bit.  The detailed description of\n                   New IE flags doesn't agree, so treat as mandatory for now... */\n                proto_tree_add_item(tree, hf_fp_hsdsch_drt, tvb, offset, 2, ENC_BIG_ENDIAN);\n                offset += 2;\n            }\n        }\n        if (preferences_header_checksum) {\n            verify_header_crc(tvb, pinfo, header_crc_pi, header_crc, header_length);\n        }\n        /* Spare Extension and Payload CRC */\n        dissect_spare_extension_and_crc(tvb, pinfo, tree, 1, offset, header_length);\n    }\n}\n\n\n/******************************************/\n/* Dissect an HSDSCH type 2 channel       */\n/* (introduced in Release 7)              */\n/* N.B. there is currently no support for */\n/* frame type 3 (IuR only?)               */\nstatic void\ndissect_hsdsch_type_2_channel_info(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\n                                   int offset, struct fp_info *p_fp_info,\n                                   void *data)\n{\n    gboolean is_control_frame;\n    guint16 header_crc = 0;\n    proto_item * header_crc_pi = NULL;\n    guint16 header_length = 0;\n\n    /* Header CRC */\n    header_crc = tvb_get_bits8(tvb, 0, 7);\n    header_crc_pi = proto_tree_add_item(tree, hf_fp_header_crc, tvb, offset, 1, ENC_BIG_ENDIAN);\n\n    /* Frame Type */\n    is_control_frame = tvb_get_guint8(tvb, offset) & 0x01;\n    proto_tree_add_item(tree, hf_fp_ft, tvb, offset, 1, ENC_BIG_ENDIAN);\n    offset++;\n\n    col_append_str(pinfo->cinfo, COL_INFO, is_control_frame ? \" [Control] \" : \" [Data] \");\n\n    if (is_control_frame) {\n        dissect_common_control(tvb, pinfo, tree, offset, p_fp_info);\n        /* For control frame the header CRC is actually frame CRC covering all\n         * bytes except the first */\n        if (preferences_header_checksum) {\n            verify_control_frame_crc(tvb, pinfo, header_crc_pi, header_crc);\n        }\n    }\n    else {\n        guint8 number_of_pdu_blocks;\n        gboolean drt_present = FALSE;\n        gboolean fach_present = FALSE;\n        guint16 user_buffer_size;\n        int n;\n        guint j;\n\n        #define MAX_PDU_BLOCKS 31\n        guint64 lchid[MAX_PDU_BLOCKS];\n        guint64 pdu_length[MAX_PDU_BLOCKS];\n        guint64 no_of_pdus[MAX_PDU_BLOCKS];\n\n        umts_mac_info *macinf;\n        rlc_info *rlcinf;\n\n        rlcinf = (rlc_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_rlc, 0);\n        macinf = (umts_mac_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_umts_mac, 0);\n        /********************************/\n        /* HS-DCH type 2 data here      */\n\n        col_append_str(pinfo->cinfo, COL_INFO, \"(ehs)\");\n\n        /* Frame Seq Nr (4 bits) */\n        if ((p_fp_info->release == 6) ||\n            (p_fp_info->release == 7)) {\n\n            guint8 frame_seq_no = (tvb_get_guint8(tvb, offset) & 0xf0) >> 4;\n            proto_tree_add_item(tree, hf_fp_frame_seq_nr, tvb, offset, 1, ENC_BIG_ENDIAN);\n\n            col_append_fstr(pinfo->cinfo, COL_INFO, \"  seqno=%u\", frame_seq_no);\n        }\n\n        /* CmCH-PI (4 bits) */\n        proto_tree_add_item(tree, hf_fp_cmch_pi, tvb, offset, 1, ENC_BIG_ENDIAN);\n        offset++;\n\n        /* Total number of PDU blocks (5 bits) */\n        number_of_pdu_blocks = (tvb_get_guint8(tvb, offset) >> 3);\n        proto_tree_add_item(tree, hf_fp_total_pdu_blocks, tvb, offset, 1, ENC_BIG_ENDIAN);\n\n        if (p_fp_info->release == 7) {\n            /* Flush bit */\n            proto_tree_add_item(tree, hf_fp_flush, tvb, offset, 1, ENC_BIG_ENDIAN);\n\n            /* FSN/DRT reset bit */\n            proto_tree_add_item(tree, hf_fp_fsn_drt_reset, tvb, offset, 1, ENC_BIG_ENDIAN);\n\n            /* DRT Indicator */\n            drt_present = tvb_get_guint8(tvb, offset) & 0x01;\n            proto_tree_add_item(tree, hf_fp_drt_indicator, tvb, offset, 1, ENC_BIG_ENDIAN);\n        }\n        offset++;\n\n        /* FACH Indicator flag */\n        fach_present = (tvb_get_guint8(tvb, offset) & 0x80) >> 7;\n        proto_tree_add_item(tree, hf_fp_fach_indicator, tvb, offset, 1, ENC_BIG_ENDIAN);\n        offset++;\n\n        /* User buffer size */\n        user_buffer_size = tvb_get_ntohs(tvb, offset);\n        proto_tree_add_item(tree, hf_fp_user_buffer_size, tvb, offset, 2, ENC_BIG_ENDIAN);\n        offset += 2;\n\n        col_append_fstr(pinfo->cinfo, COL_INFO, \"  User-Buffer-Size=%u\", user_buffer_size);\n\n\n\n        /********************************************************************/\n        /* Now read number_of_pdu_blocks header entries                     */\n        for (n=0; n < number_of_pdu_blocks; n++) {\n            proto_item *pdu_block_header_ti;\n            proto_tree *pdu_block_header_tree;\n            int        block_header_start_offset = offset;\n\n            /* Add PDU block header subtree */\n            pdu_block_header_ti = proto_tree_add_string_format(tree, hf_fp_hsdsch_pdu_block_header,\n                                                               tvb, offset, 0,\n                                                               \"\",\n                                                               \"PDU Block Header\");\n            pdu_block_header_tree = proto_item_add_subtree(pdu_block_header_ti,\n                                                           ett_fp_hsdsch_pdu_block_header);\n\n            /* MAC-d/c PDU length in this block (11 bits) */\n            proto_tree_add_bits_ret_val(pdu_block_header_tree, hf_fp_pdu_length_in_block, tvb,\n                                        (offset*8) + ((n % 2) ? 4 : 0), 11,\n                                        &pdu_length[n], ENC_BIG_ENDIAN);\n            if ((n % 2) == 0)\n                offset++;\n            else\n                offset += 2;\n\n\n            /* # PDUs in this block (4 bits) */\n            proto_tree_add_bits_ret_val(pdu_block_header_tree, hf_fp_pdus_in_block, tvb,\n                                        (offset*8) + ((n % 2) ? 0 : 4), 4,\n                                        &no_of_pdus[n], ENC_BIG_ENDIAN);\n            if ((n % 2) == 0) {\n                offset++;\n            }\n\n            /* Logical channel ID in block (4 bits) */\n            proto_tree_add_bits_ret_val(pdu_block_header_tree, hf_fp_lchid, tvb,\n                                        (offset*8) + ((n % 2) ? 4 : 0), 4,\n                                        &lchid[n], ENC_BIG_ENDIAN);\n            if ((n % 2) == 1) {\n                offset++;\n            }\n            else {\n                if (n == (number_of_pdu_blocks-1)) {\n                    /* Byte is padded out for last block */\n                    offset++;\n                }\n            }\n\n            /* Append summary to header tree root */\n            proto_item_append_text(pdu_block_header_ti,\n                                   \" (lch:%u, %u pdus of %u bytes)\",\n                                   (guint16)lchid[n],\n                                   (guint16)no_of_pdus[n],\n                                   (guint16)pdu_length[n]);\n\n            /* Set length of header tree item */\n            if (((n % 2) == 0) && (n < (number_of_pdu_blocks-1))) {\n                proto_item_set_len(pdu_block_header_ti,\n                                   offset - block_header_start_offset+1);\n            }\n            else {\n                proto_item_set_len(pdu_block_header_ti,\n                                   offset - block_header_start_offset);\n            }\n        }\n\n        if (header_length == 0) {\n            header_length = offset;\n        }\n        /**********************************************/\n        /* Optional fields indicated by earlier flags */\n        if (drt_present) {\n            /* DRT */\n            proto_tree_add_item(tree, hf_fp_drt, tvb, offset, 2, ENC_BIG_ENDIAN);\n            offset += 2;\n        }\n\n        if (fach_present) {\n            /* H-RNTI: */\n            proto_tree_add_item(tree, hf_fp_hrnti, tvb, offset, 2, ENC_BIG_ENDIAN);\n            offset += 2;\n\n            /* RACH Measurement Result */\n            proto_tree_add_item(tree, hf_fp_rach_measurement_result, tvb, offset, 2, ENC_BIG_ENDIAN);\n            offset++;\n        }\n\n\n        /********************************************************************/\n        /* Now read the MAC-d/c PDUs for each block using info from headers */\n        for (n=0; n < number_of_pdu_blocks; n++) {\n            for (j=0;j<no_of_pdus[n];j++) {\n\n                /*Configure (signal to lower layers) the PDU!*/\n                macinf->content[j] = lchId_type_table[lchid[n]+1];/*hsdsch_macdflow_id_mac_content_map[p_fp_info->hsdsch_macflowd_id];*/ /*MAC_CONTENT_PS_DTCH;*/\n                macinf->lchid[j] = (guint8)lchid[n]+1;    /*Add 1 since C/T is zero indexed? ie C/T =0 => L-CHID = 1*/\n                macinf->macdflow_id[j] = p_fp_info->hsdsch_macflowd_id;\n                /*Figure out RLC_MODE based on MACd-flow-ID, basically MACd-flow-ID = 0 then it's SRB0 == UM else AM*/\n                rlcinf->mode[j] = lchId_rlc_map[lchid[n]+1];/*hsdsch_macdflow_id_rlc_map[p_fp_info->hsdsch_macflowd_id];*/\n\n                macinf->ctmux[n] = FALSE;\n\n                rlcinf->li_size[j] = RLC_LI_7BITS;\n\n                /** Configure ciphering **/\n#if 0\n                /*If this entry exists, SECRUITY_MODE is completed*/\n                if ( rrc_ciph_inf && g_tree_lookup(rrc_ciph_inf, GINT_TO_POINTER((gint)p_fp_info->com_context_id)) ) {\n                    rlcinf->ciphered[j] = TRUE;\n                } else {\n                    rlcinf->ciphered[j] = FALSE;\n                }\n#endif\n                rlcinf->ciphered[j] = FALSE;\n                rlcinf->deciphered[j] = FALSE;\n                rlcinf->rbid[j] = (guint8)lchid[n]+1;\n\n                rlcinf->urnti[j] = p_fp_info->com_context_id;    /*Set URNIT to comuncation context id*/\n            }\n\n            /* Add PDU block header subtree */\n            offset = dissect_macd_pdu_data_type_2(tvb, pinfo, tree, offset,\n                                                  (guint16)pdu_length[n],\n                                                  (guint16)no_of_pdus[n],\n                                                  p_fp_info, data);\n        }\n        if (preferences_header_checksum) {\n            verify_header_crc(tvb, pinfo, header_crc_pi, header_crc, header_length);\n        }\n        /* Spare Extension and Payload CRC */\n        dissect_spare_extension_and_crc(tvb, pinfo, tree, 1, offset, header_length);\n    }\n}\n/**\n* Dissect and CONFIGURE hsdsch_common channel.\n*\n* This will dissect hsdsch common channels of type 2, so this is\n* very similar to regular type two (ehs) the difference being how\n* the configuration is done. NOTE: VERY EXPERIMENTAL.\n*\n* @param tvb the tv buffer of the current data\n* @param pinfo the packet info of the current data\n* @param tree the tree to append this item to\n* @param offset the offset in the tvb\n* @param p_fp_info FP-packet information\n*/\nstatic\nvoid dissect_hsdsch_common_channel_info(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\n                                        int offset, struct fp_info *p_fp_info,\n                                        void *data)\n{\n    gboolean is_control_frame;\n    guint16 header_crc = 0;\n    proto_item * header_crc_pi = NULL;\n    guint header_length = 0;\n\n    /* Header CRC */\n    header_crc = tvb_get_bits8(tvb, 0, 7);\n    header_crc_pi = proto_tree_add_item(tree, hf_fp_header_crc, tvb, offset, 1, ENC_BIG_ENDIAN);\n\n    /* Frame Type */\n    is_control_frame = tvb_get_guint8(tvb, offset) & 0x01;\n    proto_tree_add_item(tree, hf_fp_ft, tvb, offset, 1, ENC_BIG_ENDIAN);\n    offset++;\n\n    col_append_str(pinfo->cinfo, COL_INFO, is_control_frame ? \" [Control] \" : \" [Data] \");\n\n    if (is_control_frame) {\n        dissect_common_control(tvb, pinfo, tree, offset, p_fp_info);\n        /* For control frame the header CRC is actually frame CRC covering all\n         * bytes except the first */\n        if (preferences_header_checksum) {\n            verify_control_frame_crc(tvb, pinfo, header_crc_pi, header_crc);\n        }\n    }\n    else {\n        guint8 number_of_pdu_blocks;\n        gboolean drt_present = FALSE;\n        gboolean fach_present = FALSE;\n        guint16 user_buffer_size;\n        int n;\n        guint j;\n\n        #define MAX_PDU_BLOCKS 31\n        guint64 lchid[MAX_PDU_BLOCKS];\n        guint64 pdu_length[MAX_PDU_BLOCKS];\n        guint64 no_of_pdus[MAX_PDU_BLOCKS];\n        guint8 newieflags = 0;\n\n        umts_mac_info *macinf;\n        rlc_info *rlcinf;\n\n        rlcinf = (rlc_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_rlc, 0);\n        macinf = (umts_mac_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_umts_mac, 0);\n        /********************************/\n        /* HS-DCH type 2 data here      */\n\n        col_append_str(pinfo->cinfo, COL_INFO, \"(ehs)\");\n\n        /* Frame Seq Nr (4 bits) */\n        if ((p_fp_info->release == 6) ||\n            (p_fp_info->release == 7)) {\n\n            guint8 frame_seq_no = (tvb_get_guint8(tvb, offset) & 0xf0) >> 4;\n            proto_tree_add_item(tree, hf_fp_frame_seq_nr, tvb, offset, 1, ENC_BIG_ENDIAN);\n\n            col_append_fstr(pinfo->cinfo, COL_INFO, \"  seqno=%u\", frame_seq_no);\n        }\n\n        /* CmCH-PI (4 bits) */\n        proto_tree_add_item(tree, hf_fp_cmch_pi, tvb, offset, 1, ENC_BIG_ENDIAN);\n        offset++;\n\n        /* Total number of PDU blocks (5 bits) */\n        number_of_pdu_blocks = (tvb_get_guint8(tvb, offset) >> 3);\n        proto_tree_add_item(tree, hf_fp_total_pdu_blocks, tvb, offset, 1, ENC_BIG_ENDIAN);\n\n        if (p_fp_info->release == 7) {\n            /* Flush bit */\n            proto_tree_add_item(tree, hf_fp_flush, tvb, offset, 1, ENC_BIG_ENDIAN);\n\n            /* FSN/DRT reset bit */\n            proto_tree_add_item(tree, hf_fp_fsn_drt_reset, tvb, offset, 1, ENC_BIG_ENDIAN);\n\n            /* DRT Indicator */\n            drt_present = tvb_get_guint8(tvb, offset) & 0x01;\n            proto_tree_add_item(tree, hf_fp_drt_indicator, tvb, offset, 1, ENC_BIG_ENDIAN);\n        }\n        offset++;\n\n        /* FACH Indicator flag */\n        fach_present = (tvb_get_guint8(tvb, offset) & 0x80) >> 7;\n        proto_tree_add_item(tree, hf_fp_fach_indicator, tvb, offset, 1, ENC_BIG_ENDIAN);\n        offset++;\n\n        /* User buffer size */\n        user_buffer_size = tvb_get_ntohs(tvb, offset);\n        proto_tree_add_item(tree, hf_fp_user_buffer_size, tvb, offset, 2, ENC_BIG_ENDIAN);\n        offset += 2;\n\n        col_append_fstr(pinfo->cinfo, COL_INFO, \"  User-Buffer-Size=%u\", user_buffer_size);\n\n\n        /********************************************************************/\n        /* Now read number_of_pdu_blocks header entries                     */\n        for (n=0; n < number_of_pdu_blocks; n++) {\n            proto_item *pdu_block_header_ti;\n            proto_tree *pdu_block_header_tree;\n            int        block_header_start_offset = offset;\n\n            /* Add PDU block header subtree */\n            pdu_block_header_ti = proto_tree_add_string_format(tree, hf_fp_hsdsch_pdu_block_header,\n                                                               tvb, offset, 0,\n                                                               \"\",\n                                                               \"PDU Block Header\");\n            pdu_block_header_tree = proto_item_add_subtree(pdu_block_header_ti,\n                                                           ett_fp_hsdsch_pdu_block_header);\n\n            /* MAC-d/c PDU length in this block (11 bits) */\n            proto_tree_add_bits_ret_val(pdu_block_header_tree, hf_fp_pdu_length_in_block, tvb,\n                                        (offset*8) + ((n % 2) ? 4 : 0), 11,\n                                        &pdu_length[n], ENC_BIG_ENDIAN);\n            if ((n % 2) == 0)\n                offset++;\n            else\n                offset += 2;\n\n\n            /* # PDUs in this block (4 bits) */\n            proto_tree_add_bits_ret_val(pdu_block_header_tree, hf_fp_pdus_in_block, tvb,\n                                        (offset*8) + ((n % 2) ? 0 : 4), 4,\n                                        &no_of_pdus[n], ENC_BIG_ENDIAN);\n            if ((n % 2) == 0) {\n                offset++;\n            }\n\n            /* Logical channel ID in block (4 bits) */\n            proto_tree_add_bits_ret_val(pdu_block_header_tree, hf_fp_lchid, tvb,\n                                        (offset*8) + ((n % 2) ? 4 : 0), 4,\n                                        &lchid[n], ENC_BIG_ENDIAN);\n            if ((n % 2) == 1) {\n                offset++;\n            }\n            else {\n                if (n == (number_of_pdu_blocks-1)) {\n                    /* Byte is padded out for last block */\n                    offset++;\n                }\n            }\n\n            /* Append summary to header tree root */\n            proto_item_append_text(pdu_block_header_ti,\n                                   \" (lch:%u, %u pdus of %u bytes)\",\n                                   (guint16)lchid[n],\n                                   (guint16)no_of_pdus[n],\n                                   (guint16)pdu_length[n]);\n\n            /* Set length of header tree item */\n            if (((n % 2) == 0) && (n < (number_of_pdu_blocks-1))) {\n                proto_item_set_len(pdu_block_header_ti,\n                                   offset - block_header_start_offset+1);\n            }\n            else {\n                proto_item_set_len(pdu_block_header_ti,\n                                   offset - block_header_start_offset);\n            }\n        }\n        if (header_length == 0) {\n            header_length = offset;\n        }\n\n        /**********************************************/\n        /* Optional fields indicated by earlier flags */\n        if (drt_present) {\n            /* DRT */\n            proto_tree_add_item(tree, hf_fp_drt, tvb, offset, 2, ENC_BIG_ENDIAN);\n            offset += 2;\n        }\n\n        if (fach_present) {\n            /* H-RNTI: */\n            proto_tree_add_item(tree, hf_fp_hrnti, tvb, offset, 2, ENC_BIG_ENDIAN);\n            offset += 2;\n\n            /* RACH Measurement Result */\n            proto_tree_add_item(tree, hf_fp_rach_measurement_result, tvb, offset, 1, ENC_BIG_ENDIAN);\n            offset++;\n        }\n\n        /********************************************************************/\n        /* Now read the MAC-d/c PDUs for each block using info from headers */\n        for (n=0; n < number_of_pdu_blocks; n++) {\n            tvbuff_t *next_tvb;\n            for (j=0; j<no_of_pdus[n]; j++) {\n                /* If all bits are set, then this is BCCH or PCCH according to: 25.435 paragraph: 6.2.7.31 */\n                if (lchid[n] == 0xF) {\n                    /* In the very few test cases I've seen, this seems to be\n                     * BCCH with transparent MAC layer. Therefore skip right to\n                     * rlc_bcch and hope for the best. */\n                    next_tvb = tvb_new_subset_length(tvb, offset, (gint)pdu_length[n]);\n                    call_dissector_with_data(rlc_bcch_handle, next_tvb, pinfo, top_level_tree, data);\n                    offset += (gint)pdu_length[n];\n                } else { /* Else go for CCCH UM, this seems to work. */\n                    p_fp_info->hsdsch_entity = ehs; /* HSDSCH type 2 */\n                    /* TODO: use cur_tb or subnum everywhere. */\n                    p_fp_info->cur_tb = j; /* set cur_tb for MAC */\n                    pinfo->fd->subnum = j; /* set subframe number for RRC */\n                    macinf->content[j] = MAC_CONTENT_CCCH;\n                    macinf->lchid[j] = (guint8)lchid[n]+1; /*Add 1 since it is zero indexed? */\n                    macinf->macdflow_id[j] = p_fp_info->hsdsch_macflowd_id;\n                    macinf->ctmux[j] = FALSE;\n\n                    rlcinf->li_size[j] = RLC_LI_7BITS;\n                    rlcinf->ciphered[j] = FALSE;\n                    rlcinf->deciphered[j] = FALSE;\n                    rlcinf->rbid[j] = (guint8)lchid[n]+1;\n                    rlcinf->urnti[j] = p_fp_info->channel; /*We need to fake urnti*/\n\n                    next_tvb = tvb_new_subset_length(tvb, offset, (gint)pdu_length[n]);\n                    call_dissector_with_data(mac_fdd_hsdsch_handle, next_tvb, pinfo, top_level_tree, data);\n\n                    offset += (gint)pdu_length[n];\n                }\n            }\n        }\n\n        /* New IE Flags */\n        newieflags = tvb_get_guint8(tvb, offset);\n        /* If newieflags == 0000 0010 then this indicates that there is a\n         * HS-DSCH physical layer category and no other New IE flags. */\n        if (newieflags == 2) {\n            /* HS-DSCH physical layer category presence bit. */\n            proto_tree_add_uint(tree, hf_fp_hsdsch_new_ie_flag[6], tvb, offset, 1, newieflags);\n            offset++;\n            /* HS-DSCH physical layer category. */\n            proto_tree_add_bits_item(tree, hf_fp_hsdsch_physical_layer_category, tvb, offset*8, 6, ENC_BIG_ENDIAN);\n            offset++;\n        }\n        if (preferences_header_checksum) {\n            verify_header_crc(tvb, pinfo, header_crc_pi, header_crc, header_length);\n        }\n        /* Spare Extension and Payload CRC */\n        dissect_spare_extension_and_crc(tvb, pinfo, tree, 1, offset, header_length);\n    }\n}\nstatic gboolean\nheur_dissect_fp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)\n{\n    struct fp_info *p_fp_info;\n\n    p_fp_info = (fp_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_fp, 0);\n\n    /* if no FP info is present, this might be FP in a pcap(ng) file */\n    if (!p_fp_info) {\n        /* We only know the header length of control frames, so check that bit first */\n        int offset = 0, length;\n        guint8 oct, calc_crc = 0, crc;\n        unsigned char *buf;\n\n        oct = tvb_get_guint8(tvb, offset);\n        crc = oct & 0xfe;\n        if ((oct & 0x01) == 1) {\n            /*\n             * 6.3.2.1 Frame CRC\n             * Description: It is the result of the CRC applied to the remaining part of the frame,\n             * i.e. from bit 0 of the first byte of the header (the FT IE) to bit 0 of the last byte of the payload,\n             * with the corresponding generator polynomial: G(D) = D7+D6+D2+1. See subclause 7.2.\n             */\n            length =  tvb_reported_length(tvb);\n            buf = (unsigned char *)tvb_memdup(wmem_packet_scope(), tvb, 0, length);\n            buf[0] = 01;\n\n            calc_crc = crc7update(calc_crc, buf, length);\n            if (calc_crc == crc) {\n                /* assume this is FP, set conversatio dissector to catch the data frames too */\n                conversation_set_dissector(find_or_create_conversation(pinfo), fp_handle);\n                dissect_fp(tvb, pinfo, tree, data);\n                return TRUE;\n            }\n        }\n        return FALSE;\n    }\n\n    /* if FP info is present, check that it really is an ethernet link */\n    if (p_fp_info->link_type != FP_Link_Ethernet) {\n        return FALSE;\n    }\n\n    /* discriminate 'lower' UDP layer from 'user data' UDP layer\n     * (i.e. if an FP over UDP packet contains a user UDP packet */\n    if (p_fp_info->srcport != pinfo->srcport ||\n        p_fp_info->destport != pinfo->destport)\n        return FALSE;\n\n    /* assume this is FP */\n    dissect_fp(tvb, pinfo, tree, data);\n    return TRUE;\n}\nstatic guint8 fakes =5; /*[] ={1,5,8};*/\nstatic guint8 fake_map[256];\n\n /*\n * TODO: This need to be fixed!\n * Basically you would want the actual RRC messages, that sooner or later maps\n * transport channel id's to logical id's or RAB IDs\n * to set the proper logical channel/RAB ID, but for now we make syntethic ones.\n * */\n\nstatic guint8\nmake_fake_lchid(packet_info *pinfo _U_, gint trchld)\n{\n    if ( fake_map[trchld] == 0) {\n        fake_map[trchld] = fakes;\n        fakes++;\n    }\n    return fake_map[trchld];\n}\n\n/*\n * july 2012:\n * Alot of configuration has been move into the actual dissecting functions\n * since most of the configuration/signalign has to be set per tb (pdu) rather\n * for the channel!\n */\nstatic fp_info *\nfp_set_per_packet_inf_from_conv(umts_fp_conversation_info_t *p_conv_data,\n                                tvbuff_t *tvb, packet_info *pinfo,\n                                proto_tree *tree _U_)\n{\n    fp_info  *fpi;\n    guint8    tfi, c_t;\n    int       offset = 0, i=0, j=0, num_tbs, chan, tb_size, tb_bit_off;\n    gboolean  is_control_frame;\n    umts_mac_info *macinf;\n    rlc_info *rlcinf;\n    guint8 fake_lchid=0;\n    gint *cur_val=NULL;\n\n    fpi = wmem_new0(wmem_file_scope(), fp_info);\n    p_add_proto_data(wmem_file_scope(), pinfo, proto_fp, 0, fpi);\n\n    fpi->iface_type = p_conv_data->iface_type;\n    fpi->division = p_conv_data->division;\n    fpi->release = 7;               /* Set values greater then the checks performed */\n    fpi->release_year = 2006;\n    fpi->release_month = 12;\n    fpi->channel = p_conv_data->channel;\n    fpi->dch_crc_present = p_conv_data->dch_crc_present;\n    /*fpi->paging_indications;*/\n    fpi->link_type = FP_Link_Ethernet;\n\n#if 0\n    /*Only do this the first run, signals that we need to reset the RLC fragtable*/\n    if (!pinfo->fd->flags.visited &&  p_conv_data->reset_frag ) {\n        fpi->reset_frag = p_conv_data->reset_frag;\n        p_conv_data->reset_frag = FALSE;\n    }\n#endif\n    /* remember 'lower' UDP layer port information so we can later\n     * differentiate 'lower' UDP layer from 'user data' UDP layer */\n    fpi->srcport = pinfo->srcport;\n    fpi->destport = pinfo->destport;\n\n    fpi->com_context_id = p_conv_data->com_context_id;\n\n    if (pinfo->link_dir == P2P_DIR_UL) {\n        fpi->is_uplink = TRUE;\n    } else {\n        fpi->is_uplink = FALSE;\n    }\n\n    is_control_frame = tvb_get_guint8(tvb, offset) & 0x01;\n\n    switch (fpi->channel) {\n        case CHANNEL_HSDSCH: /* HS-DSCH - High Speed Downlink Shared Channel */\n            fpi->hsdsch_entity = p_conv_data->hsdsch_entity;\n            macinf = wmem_new0(wmem_file_scope(), umts_mac_info);\n            fpi->hsdsch_macflowd_id = p_conv_data->hsdsch_macdflow_id;\n           macinf->content[0] = hsdsch_macdflow_id_mac_content_map[p_conv_data->hsdsch_macdflow_id]; /*MAC_CONTENT_PS_DTCH;*/\n            macinf->lchid[0] = p_conv_data->hsdsch_macdflow_id;\n            /*macinf->content[0] = lchId_type_table[p_conv_data->edch_lchId[0]];*/\n            p_add_proto_data(wmem_file_scope(), pinfo, proto_umts_mac, 0, macinf);\n\n            rlcinf = wmem_new0(wmem_file_scope(), rlc_info);\n\n            /*Figure out RLC_MODE based on MACd-flow-ID, basically MACd-flow-ID = 0 then it's SRB0 == UM else AM*/\n            rlcinf->mode[0] = hsdsch_macdflow_id_rlc_map[p_conv_data->hsdsch_macdflow_id];\n\n            if (fpi->hsdsch_entity == hs /*&& !rlc_is_ciphered(pinfo)*/) {\n                for (i=0; i<MAX_NUM_HSDHSCH_MACDFLOW; i++) {\n                    /*Figure out if this channel is multiplexed (signaled from RRC)*/\n                    if ((cur_val=(gint *)g_tree_lookup(hsdsch_muxed_flows, GINT_TO_POINTER((gint)p_conv_data->hrnti))) != NULL) {\n                        j = 1 << i;\n                        fpi->hsdhsch_macfdlow_is_mux[i] = j & *cur_val;\n                    } else {\n                        fpi->hsdhsch_macfdlow_is_mux[i] = FALSE;\n                    }\n\n                }\n            }\n            /* Make configurable ?(available in NBAP?) */\n            /* urnti[MAX_RLC_CHANS] */\n            /*\n            switch (p_conv_data->rlc_mode) {\n                case FP_RLC_TM:\n                    rlcinf->mode[0] = RLC_TM;\n                    break;\n                case FP_RLC_UM:\n                    rlcinf->mode[0] = RLC_UM;\n                    break;\n                case FP_RLC_AM:\n                    rlcinf->mode[0] = RLC_AM;\n                    break;\n                case FP_RLC_MODE_UNKNOWN:\n                default:\n                    rlcinf->mode[0] = RLC_UNKNOWN_MODE;\n                    break;\n            }*/\n            /* rbid[MAX_RLC_CHANS] */\n            /* For RLC re-assembly to work we urnti signaled from NBAP */\n            rlcinf->urnti[0] = fpi->com_context_id;\n            rlcinf->li_size[0] = RLC_LI_7BITS;\n            rlcinf->ciphered[0] = FALSE;\n            rlcinf->deciphered[0] = FALSE;\n            p_add_proto_data(wmem_file_scope(), pinfo, proto_rlc, 0, rlcinf);\n\n\n            return fpi;\n\n        case CHANNEL_EDCH:\n            /*Most configuration is now done in the actual dissecting function*/\n            macinf = wmem_new0(wmem_file_scope(), umts_mac_info);\n            rlcinf = wmem_new0(wmem_file_scope(), rlc_info);\n            fpi->no_ddi_entries = p_conv_data->no_ddi_entries;\n            for (i=0; i<fpi->no_ddi_entries; i++) {\n                fpi->edch_ddi[i] = p_conv_data->edch_ddi[i];    /*Set the DDI value*/\n                fpi->edch_macd_pdu_size[i] = p_conv_data->edch_macd_pdu_size[i];    /*Set the size*/\n                fpi->edch_lchId[i] = p_conv_data->edch_lchId[i];    /*Set the channel id for this entry*/\n                /*macinf->content[i] = lchId_type_table[p_conv_data->edch_lchId[i]]; */    /*Set the proper Content type for the mac layer.*/\n            /*    rlcinf->mode[i] = lchId_rlc_map[p_conv_data->edch_lchId[i]];*/ /* Set RLC mode by lchid to RLC_MODE map in nbap.h */\n\n            }\n            fpi->edch_type = p_conv_data->edch_type;\n\n           /* macinf = wmem_new0(wmem_file_scope(), umts_mac_info);\n            macinf->content[0] = MAC_CONTENT_PS_DTCH;*/\n            p_add_proto_data(wmem_file_scope(), pinfo, proto_umts_mac, 0, macinf);\n\n\n            /* For RLC re-assembly to work we need a urnti signaled from NBAP */\n            rlcinf->urnti[0] = fpi->com_context_id;\n           /* rlcinf->mode[0] = RLC_AM;*/\n            rlcinf->li_size[0] = RLC_LI_7BITS;\n            rlcinf->ciphered[0] = FALSE;\n            rlcinf->deciphered[0] = FALSE;\n\n            p_add_proto_data(wmem_file_scope(), pinfo, proto_rlc, 0, rlcinf);\n\n            return fpi;\n\n        case CHANNEL_PCH:\n            fpi->paging_indications = p_conv_data->paging_indications;\n            fpi->num_chans = p_conv_data->num_dch_in_flow;\n            /* Set offset to point to first TFI\n             */\n            if (is_control_frame) {\n                /* control frame, we're done */\n                return fpi;\n            }\n            /* Set offset to TFI */\n            offset = 3;\n            break;\n        case CHANNEL_DCH:\n            fpi->num_chans = p_conv_data->num_dch_in_flow;\n            if (is_control_frame) {\n                /* control frame, we're done */\n                return fpi;\n            }\n\n            rlcinf = wmem_new0(wmem_file_scope(), rlc_info);\n            macinf = wmem_new0(wmem_file_scope(), umts_mac_info);\n            offset = 2;    /*To correctly read the tfi*/\n            fakes  = 5; /* Reset fake counter. */\n            for (chan=0; chan < fpi->num_chans; chan++) {    /*Iterate over the what channels*/\n                    /*Iterate over the transport blocks*/\n                   /*tfi = tvb_get_guint8(tvb, offset);*/\n                   /*TFI is 5 bits according to 3GPP TS 25.321, paragraph 6.2.4.4*/\n                    tfi = tvb_get_bits8(tvb, 3+offset*8, 5);\n\n                   /*Figure out the number of tbs and size*/\n                   num_tbs = (fpi->is_uplink) ? p_conv_data->fp_dch_channel_info[chan].ul_chan_num_tbs[tfi] : p_conv_data->fp_dch_channel_info[chan].dl_chan_num_tbs[tfi];\n                   tb_size=  (fpi->is_uplink) ? p_conv_data->fp_dch_channel_info[i].ul_chan_tf_size[tfi] :    p_conv_data->fp_dch_channel_info[i].dl_chan_tf_size[tfi];\n\n                    /*TODO: This stuff has to be reworked!*/\n                    /*Generates a fake logical channel id for non multiplexed channel*/\n                    if ( p_conv_data->dchs_in_flow_list[chan] != 31 && (p_conv_data->dchs_in_flow_list[chan] == 24 &&\n                     tb_size != 340) ) {\n                        fake_lchid = make_fake_lchid(pinfo, p_conv_data->dchs_in_flow_list[chan]);\n                    }\n                    tb_bit_off = (2+p_conv_data->num_dch_in_flow)*8;    /*Point to the C/T of first TB*/\n                    /*Set configuration for individual blocks*/\n                    for (j=0; j < num_tbs && j+chan < MAX_MAC_FRAMES; j++) {\n                        /*Set transport channel id (useful for debugging)*/\n                        macinf->trchid[j+chan] = p_conv_data->dchs_in_flow_list[chan];\n\n                        /*Transport Channel m31 and 24 might be multiplexed!*/\n                        if ( p_conv_data->dchs_in_flow_list[chan] == 31 || p_conv_data->dchs_in_flow_list[chan] == 24) {\n\n                            /****** MUST FIGURE OUT IF THIS IS REALLY MULTIPLEXED OR NOT*******/\n                            /*If Trchid == 31 and only on TB, we have no multiplexing*/\n                            if (0/*p_conv_data->dchs_in_flow_list[chan] == 31 && num_tbs == 1*/) {\n                                macinf->ctmux[j+chan] = FALSE;/*Set TRUE if this channel is multiplexed (ie. C/T flag exists)*/\n\n                                macinf->lchid[j+chan] = 1;\n\n                                macinf->content[j+chan] = lchId_type_table[1];    /*Base MAC content on logical channel id (Table is in packet-nbap.h)*/\n                                rlcinf->mode[j+chan] = lchId_rlc_map[1];    /*Based RLC mode on logical channel id*/\n\n                            }\n                            /*Indicate we don't have multiplexing.*/\n                            else if (p_conv_data->dchs_in_flow_list[chan] == 24 && tb_size != 340) {\n                                macinf->ctmux[j+chan] = FALSE;/*Set TRUE if this channel is multiplexed (ie. C/T flag exists)*/\n\n                                /*g_warning(\"settin this for %d\", pinfo->num);*/\n                                macinf->lchid[j+chan] = fake_lchid;\n                                macinf->fake_chid[j+chan] = TRUE;\n                                macinf->content[j+chan] = MAC_CONTENT_PS_DTCH; /*lchId_type_table[fake_lchid];*/    /*Base MAC content on logical channel id (Table is in packet-nbap.h)*/\n                                rlcinf->mode[j+chan] = RLC_AM;/*lchId_rlc_map[fake_lchid];*/    /*Based RLC mode on logical channel id*/\n                            }\n                            /*We have multiplexing*/\n                            else {\n                                macinf->ctmux[j+chan] = TRUE;/*Set TRUE if this channel is multiplexed (ie. C/T flag exists)*/\n\n                                /* Peek at C/T, different RLC params for different logical channels */\n                                /*C/T is 4 bits according to 3GPP TS 25.321, paragraph 9.2.1, from MAC header (not FP)*/\n                                c_t = (tvb_get_bits8(tvb, tb_bit_off/*(2+p_conv_data->num_dch_in_flow)*8*/, 4) + 1) % 0xf;    /* c_t = tvb_get_guint8(tvb, offset);*/\n                                macinf->lchid[j+chan] = c_t;\n\n                                macinf->content[j+chan] = lchId_type_table[c_t];    /*Base MAC content on logical channel id (Table is in packet-nbap.h)*/\n                                rlcinf->mode[j+chan] = lchId_rlc_map[c_t];    /*Based RLC mode on logical channel id*/\n                            }\n                        } else {\n                            fake_lchid = make_fake_lchid(pinfo, p_conv_data->dchs_in_flow_list[chan]);\n                            macinf->ctmux[j+chan] = FALSE;/*Set TRUE if this channel is multiplexed (ie. C/T flag exists)*/\n                            /*macinf->content[j+chan] = MAC_CONTENT_CS_DTCH;*/\n                            macinf->content[j+chan] = lchId_type_table[fake_lchid];\n\n\n                            rlcinf->mode[j+chan] = lchId_rlc_map[fake_lchid];\n\n                            /*Generate virtual logical channel id*/\n                            /************************/\n                            /*TODO: Once proper lchid is always set, this has to be removed*/\n                            macinf->fake_chid[j+chan] = TRUE;\n                            macinf->lchid[j+chan] = fake_lchid;  /*make_fake_lchid(pinfo, p_conv_data->dchs_in_flow_list[chan]);*/\n                            /************************/\n                        }\n\n                        /*** Set rlc info ***/\n                        rlcinf->urnti[j+chan] = p_conv_data->com_context_id;\n                        rlcinf->li_size[j+chan] = RLC_LI_7BITS;\n#if 0\n                        /*If this entry exists, SECRUITY_MODE is completed (signled by RRC)*/\n                        if ( rrc_ciph_inf && g_tree_lookup(rrc_ciph_inf, GINT_TO_POINTER((gint)p_conv_data->com_context_id)) != NULL ) {\n                            rlcinf->ciphered[j+chan] = TRUE;\n                        } else {\n                            rlcinf->ciphered[j+chan] = FALSE;\n                        }\n#endif\n                        rlcinf->ciphered[j+chan] = FALSE;\n                        rlcinf->deciphered[j+chan] = FALSE;\n                        rlcinf->rbid[j+chan] = macinf->lchid[j+chan];\n\n\n                        /*Step over this TB and it's C/T flag.*/\n                        tb_bit_off += tb_size+4;\n                    }\n\n                    offset++;\n            }\n            p_add_proto_data(wmem_file_scope(), pinfo, proto_umts_mac, 0, macinf);\n            p_add_proto_data(wmem_file_scope(), pinfo, proto_rlc, 0, rlcinf);\n            /* Set offset to point to first TFI\n             * the Number of TFI's = number of DCH's in the flow\n             */\n            offset = 2;\n            break;\n        case CHANNEL_FACH_FDD:\n            fpi->num_chans = p_conv_data->num_dch_in_flow;\n            if (is_control_frame) {\n                /* control frame, we're done */\n                return fpi;\n            }\n            /* Set offset to point to first TFI\n             * the Number of TFI's = number of DCH's in the flow\n             */\n            offset = 2;\n            /* Set MAC data */\n            macinf = wmem_new0(wmem_file_scope(), umts_mac_info);\n            macinf->ctmux[0]   = 1;\n            macinf->content[0] = MAC_CONTENT_DCCH;\n            p_add_proto_data(wmem_file_scope(), pinfo, proto_umts_mac, 0, macinf);\n            /* Set RLC data */\n            rlcinf = wmem_new0(wmem_file_scope(), rlc_info);\n            /* Make configurable ?(avaliable in NBAP?) */\n            /* For RLC re-assembly to work we need to fake urnti */\n            rlcinf->urnti[0] = fpi->channel;\n            rlcinf->mode[0] = RLC_AM;\n            /* rbid[MAX_RLC_CHANS] */\n            rlcinf->li_size[0] = RLC_LI_7BITS;\n            rlcinf->ciphered[0] = FALSE;\n            rlcinf->deciphered[0] = FALSE;\n            p_add_proto_data(wmem_file_scope(), pinfo, proto_rlc, 0, rlcinf);\n            break;\n\n        case CHANNEL_RACH_FDD:\n            fpi->num_chans = p_conv_data->num_dch_in_flow;\n            if (is_control_frame) {\n                /* control frame, we're done */\n                return fpi;\n            }\n            /* Set offset to point to first TFI\n             * the Number of TFI's = number of DCH's in the flow\n             */\n            offset = 2;\n            /* set MAC data */\n            macinf = wmem_new0(wmem_file_scope(), umts_mac_info);\n            rlcinf = wmem_new0(wmem_file_scope(), rlc_info);\n            for ( chan = 0; chan < fpi->num_chans; chan++ ) {\n                    macinf->ctmux[chan]   = 1;\n                    macinf->content[chan] = MAC_CONTENT_DCCH;\n                    rlcinf->urnti[chan] = fpi->com_context_id;    /*Note that MAC probably will change this*/\n            }\n\n\n\n            p_add_proto_data(wmem_file_scope(), pinfo, proto_umts_mac, 0, macinf);\n            p_add_proto_data(wmem_file_scope(), pinfo, proto_rlc, 0, rlcinf);\n            break;\n        case CHANNEL_HSDSCH_COMMON:\n                rlcinf = wmem_new0(wmem_file_scope(), rlc_info);\n                macinf = wmem_new0(wmem_file_scope(), umts_mac_info);\n                p_add_proto_data(wmem_file_scope(), pinfo, proto_umts_mac, 0, macinf);\n                p_add_proto_data(wmem_file_scope(), pinfo, proto_rlc, 0, rlcinf);\n            break;\n        default:\n            expert_add_info(pinfo, NULL, &ei_fp_transport_channel_type_unknown);\n            return NULL;\n    }\n\n    /* Peek at the packet as the per packet info seems not to take the tfi into account */\n    for (i=0; i<fpi->num_chans; i++) {\n        tfi = tvb_get_guint8(tvb, offset);\n\n        /*TFI is 5 bits according to 3GPP TS 25.321, paragraph 6.2.4.4*/\n        /*tfi = tvb_get_bits8(tvb, offset*8, 5);*/\n        if (pinfo->link_dir == P2P_DIR_UL) {\n            fpi->chan_tf_size[i] = p_conv_data->fp_dch_channel_info[i].ul_chan_tf_size[tfi];\n            fpi->chan_num_tbs[i] = p_conv_data->fp_dch_channel_info[i].ul_chan_num_tbs[tfi];\n        } else {\n            fpi->chan_tf_size[i] = p_conv_data->fp_dch_channel_info[i].dl_chan_tf_size[tfi];\n            fpi->chan_num_tbs[i] = p_conv_data->fp_dch_channel_info[i].dl_chan_num_tbs[tfi];\n        }\n        offset++;\n    }\n\n\n    return fpi;\n}\n\n/*****************************/\n/* Main dissection function. */\nstatic int\ndissect_fp_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)\n{\n    proto_tree       *fp_tree;\n    proto_item       *ti;\n    gint              offset = 0;\n    struct fp_info   *p_fp_info;\n    rlc_info         *rlcinf;\n    conversation_t   *p_conv;\n    umts_fp_conversation_info_t *p_conv_data = NULL;\n\n    /* Append this protocol name rather than replace. */\n    col_set_str(pinfo->cinfo, COL_PROTOCOL, \"FP\");\n\n    /* Create fp tree. */\n    ti = proto_tree_add_item(tree, proto_fp, tvb, offset, -1, ENC_NA);\n    fp_tree = proto_item_add_subtree(ti, ett_fp);\n\n    top_level_tree = tree;\n\n    /* Look for packet info! */\n    p_fp_info = (struct fp_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_fp, 0);\n\n    /* Check if we have conversation info */\n    p_conv = (conversation_t *)find_conversation(pinfo->num, &pinfo->net_dst, &pinfo->net_src,\n                               pinfo->ptype,\n                               pinfo->destport, pinfo->srcport, NO_ADDR_B);\n\n\n    if (p_conv) {\n         /*Find correct conversation, basically find the one that's closest to this frame*/\n#if 0\n         while (p_conv->next != NULL && p_conv->next->setup_frame < pinfo->num) {\n            p_conv = p_conv->next;\n         }\n#endif\n\n        p_conv_data = (umts_fp_conversation_info_t *)conversation_get_proto_data(p_conv, proto_fp);\n\n        if (p_conv_data) {\n            /*Figure out the direction of the link*/\n            if (addresses_equal(&(pinfo->net_dst), (&p_conv_data->crnc_address))) {\n\n                proto_item *item= proto_tree_add_uint(fp_tree, hf_fp_ul_setup_frame,\n                                                      tvb, 0, 0, p_conv_data->ul_frame_number);\n\n                PROTO_ITEM_SET_GENERATED(item);\n                /* CRNC -> Node B */\n                pinfo->link_dir=P2P_DIR_UL;\n                if (p_fp_info == NULL) {\n                    p_fp_info = fp_set_per_packet_inf_from_conv(p_conv_data, tvb, pinfo, fp_tree);\n                }\n            }\n            else {\n                /* Maybe the frame number should be stored in the proper location already in nbap?, in ul_frame_number*/\n                proto_item *item= proto_tree_add_uint(fp_tree, hf_fp_dl_setup_frame,\n                                                       tvb, 0, 0, p_conv_data->ul_frame_number);\n\n                PROTO_ITEM_SET_GENERATED(item);\n                pinfo->link_dir=P2P_DIR_DL;\n                if (p_fp_info == NULL) {\n                    p_fp_info = fp_set_per_packet_inf_from_conv(p_conv_data, tvb, pinfo, fp_tree);\n                }\n            }\n        }\n\n    }\n\n    if (pinfo->p2p_dir == P2P_DIR_UNKNOWN) {\n        if (pinfo->link_dir == P2P_DIR_UL) {\n            pinfo->p2p_dir = P2P_DIR_RECV;\n        } else {\n            pinfo->p2p_dir = P2P_DIR_SENT;\n        }\n    }\n\n    /* Can't dissect anything without it... */\n    if (p_fp_info == NULL) {\n        proto_tree_add_expert(fp_tree, pinfo, &ei_fp_no_per_frame_info, tvb, offset, -1);\n        return 1;\n    }\n\n    rlcinf = (rlc_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_rlc, 0);\n\n    /* Show release information */\n    if (preferences_show_release_info) {\n        proto_item *release_ti;\n        proto_tree *release_tree;\n        proto_item *temp_ti;\n\n        release_ti = proto_tree_add_item(fp_tree, hf_fp_release, tvb, 0, 0, ENC_NA);\n        PROTO_ITEM_SET_GENERATED(release_ti);\n        proto_item_append_text(release_ti, \" R%u (%d/%d)\",\n                               p_fp_info->release, p_fp_info->release_year, p_fp_info->release_month);\n        release_tree = proto_item_add_subtree(release_ti, ett_fp_release);\n\n        temp_ti = proto_tree_add_uint(release_tree, hf_fp_release_version, tvb, 0, 0, p_fp_info->release);\n        PROTO_ITEM_SET_GENERATED(temp_ti);\n\n        temp_ti = proto_tree_add_uint(release_tree, hf_fp_release_year, tvb, 0, 0, p_fp_info->release_year);\n        PROTO_ITEM_SET_GENERATED(temp_ti);\n\n        temp_ti = proto_tree_add_uint(release_tree, hf_fp_release_month, tvb, 0, 0, p_fp_info->release_month);\n        PROTO_ITEM_SET_GENERATED(temp_ti);\n    }\n\n    /* Show channel type in info column, tree */\n    col_set_str(pinfo->cinfo, COL_INFO,\n                val_to_str_const(p_fp_info->channel,\n                                 channel_type_vals,\n                                 \"Unknown channel type\"));\n    if (p_conv_data) {\n        int i;\n        col_append_fstr(pinfo->cinfo, COL_INFO, \"(%u\", p_conv_data->dchs_in_flow_list[0]);\n        for (i=1; i < p_conv_data->num_dch_in_flow; i++) {\n            col_append_fstr(pinfo->cinfo, COL_INFO, \",%u\", p_conv_data->dchs_in_flow_list[i]);\n        }\n        col_append_fstr(pinfo->cinfo, COL_INFO, \") \");\n    }\n    proto_item_append_text(ti, \" (%s)\",\n                           val_to_str_const(p_fp_info->channel,\n                                            channel_type_vals,\n                                            \"Unknown channel type\"));\n\n    /* Add channel type as a generated field */\n    ti = proto_tree_add_uint(fp_tree, hf_fp_channel_type, tvb, 0, 0, p_fp_info->channel);\n    PROTO_ITEM_SET_GENERATED(ti);\n\n    /* Add division type as a generated field */\n    if (p_fp_info->release == 7) {\n        ti = proto_tree_add_uint(fp_tree, hf_fp_division, tvb, 0, 0, p_fp_info->division);\n        PROTO_ITEM_SET_GENERATED(ti);\n    }\n\n    /* Add link direction as a generated field */\n    ti = proto_tree_add_uint(fp_tree, hf_fp_direction, tvb, 0, 0, p_fp_info->is_uplink);\n    PROTO_ITEM_SET_GENERATED(ti);\n\n    /* Don't currently handle IuR-specific formats, but it's useful to even see\n       the channel type and direction */\n    if (p_fp_info->iface_type == IuR_Interface) {\n        return 1;\n    }\n\n    /* Show DDI config info */\n    if (p_fp_info->no_ddi_entries > 0) {\n        int n;\n        proto_item *ddi_config_ti;\n        proto_tree *ddi_config_tree;\n\n        ddi_config_ti = proto_tree_add_string_format(fp_tree, hf_fp_ddi_config, tvb, offset, 0,\n                                                     \"\", \"DDI Config (\");\n        PROTO_ITEM_SET_GENERATED(ddi_config_ti);\n        ddi_config_tree = proto_item_add_subtree(ddi_config_ti, ett_fp_ddi_config);\n\n        /* Add each entry */\n        for (n=0; n < p_fp_info->no_ddi_entries; n++) {\n            proto_item_append_text(ddi_config_ti, \"%s%u->%ubits\",\n                                   (n == 0) ? \"\" : \"  \",\n                                   p_fp_info->edch_ddi[n], p_fp_info->edch_macd_pdu_size[n]);\n            ti = proto_tree_add_uint(ddi_config_tree, hf_fp_ddi_config_ddi, tvb, 0, 0,\n                                p_fp_info->edch_ddi[n]);\n            PROTO_ITEM_SET_GENERATED(ti);\n            ti = proto_tree_add_uint(ddi_config_tree, hf_fp_ddi_config_macd_pdu_size, tvb, 0, 0,\n                                p_fp_info->edch_macd_pdu_size[n]);\n            PROTO_ITEM_SET_GENERATED(ti);\n\n        }\n        proto_item_append_text(ddi_config_ti, \")\");\n    }\n\n    /*************************************/\n    /* Dissect according to channel type */\n    switch (p_fp_info->channel) {\n        case CHANNEL_RACH_TDD:\n        case CHANNEL_RACH_TDD_128:\n        case CHANNEL_RACH_FDD:\n            dissect_rach_channel_info(tvb, pinfo, fp_tree, offset, p_fp_info,\n                                      data);\n            break;\n        case CHANNEL_DCH:\n            dissect_dch_channel_info(tvb, pinfo, fp_tree, offset, p_fp_info,\n                                     data);\n            break;\n        case CHANNEL_FACH_FDD:\n        case CHANNEL_FACH_TDD:\n            dissect_fach_channel_info(tvb, pinfo, fp_tree, offset, p_fp_info,\n                                      data);\n            break;\n        case CHANNEL_DSCH_FDD:\n        case CHANNEL_DSCH_TDD:\n            dissect_dsch_channel_info(tvb, pinfo, fp_tree, offset, p_fp_info);\n            break;\n        case CHANNEL_USCH_TDD_128:\n        case CHANNEL_USCH_TDD_384:\n            dissect_usch_channel_info(tvb, pinfo, fp_tree, offset, p_fp_info);\n            break;\n        case CHANNEL_PCH:\n            dissect_pch_channel_info(tvb, pinfo, fp_tree, offset, p_fp_info,\n                                     data);\n            break;\n        case CHANNEL_CPCH:\n            dissect_cpch_channel_info(tvb, pinfo, fp_tree, offset, p_fp_info);\n            break;\n        case CHANNEL_BCH:\n            dissect_bch_channel_info(tvb, pinfo, fp_tree, offset, p_fp_info);\n            break;\n        case CHANNEL_HSDSCH:\n            /* Show configured MAC HS-DSCH entity in use */\n            if (fp_tree)\n            {\n                proto_item *entity_ti;\n                entity_ti = proto_tree_add_uint(fp_tree, hf_fp_hsdsch_entity,\n                                                tvb, 0, 0,\n                                                p_fp_info->hsdsch_entity);\n                PROTO_ITEM_SET_GENERATED(entity_ti);\n            }\n            switch (p_fp_info->hsdsch_entity) {\n                case entity_not_specified:\n                case hs:\n                    /* This is the pre-R7 default */\n                    dissect_hsdsch_channel_info(tvb, pinfo, fp_tree, offset, p_fp_info, data);\n                    break;\n                case ehs:\n                    dissect_hsdsch_type_2_channel_info(tvb, pinfo, fp_tree, offset, p_fp_info, data);\n                    break;\n                default:\n                    /* Report Error */\n                    expert_add_info(pinfo, NULL, &ei_fp_hsdsch_entity_not_specified);\n                    break;\n            }\n            break;\n        case CHANNEL_HSDSCH_COMMON:\n            expert_add_info(pinfo, NULL, &ei_fp_hsdsch_common_experimental_support);\n            /*if (FALSE)*/\n            dissect_hsdsch_common_channel_info(tvb, pinfo, fp_tree, offset, p_fp_info, data);\n\n            break;\n        case CHANNEL_HSDSCH_COMMON_T3:\n            expert_add_info(pinfo, NULL, &ei_fp_hsdsch_common_t3_not_implemented);\n\n            /* TODO: */\n            break;\n        case CHANNEL_IUR_CPCHF:\n            /* TODO: */\n            break;\n        case CHANNEL_IUR_FACH:\n            /* TODO: */\n            break;\n        case CHANNEL_IUR_DSCH:\n            dissect_iur_dsch_channel_info(tvb, pinfo, fp_tree, offset, p_fp_info);\n            break;\n        case CHANNEL_EDCH:\n        case CHANNEL_EDCH_COMMON:\n            dissect_e_dch_channel_info(tvb, pinfo, fp_tree, offset, p_fp_info,\n                                       p_fp_info->channel == CHANNEL_EDCH_COMMON,\n                                       rlcinf, data);\n            break;\n\n        default:\n            expert_add_info(pinfo, NULL, &ei_fp_channel_type_unknown);\n            break;\n    }\n    return tvb_captured_length(tvb);\n}\n\nstatic int\ndissect_fp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)\n{\n    return dissect_fp_common(tvb, pinfo, tree, NULL);\n}\n\nstatic int\ndissect_fp_aal2(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)\n{\n    return dissect_fp_common(tvb, pinfo, tree, data);\n}\n\n#ifdef UMTS_FP_USE_UAT\nUAT_VS_DEF(uat_umts_fp_ep_and_ch_records, protocol, uat_umts_fp_ep_and_ch_record_t, guint8, UMTS_FP_IPV4, \"IPv4\")\nUAT_CSTRING_CB_DEF(uat_umts_fp_ep_and_ch_records, srcIP, uat_umts_fp_ep_and_ch_record_t)\nUAT_DEC_CB_DEF(uat_umts_fp_ep_and_ch_records, src_port, uat_umts_fp_ep_and_ch_record_t)\nUAT_CSTRING_CB_DEF(uat_umts_fp_ep_and_ch_records, dstIP, uat_umts_fp_ep_and_ch_record_t)\nUAT_DEC_CB_DEF(uat_umts_fp_ep_and_ch_records, dst_port, uat_umts_fp_ep_and_ch_record_t)\nUAT_VS_DEF(uat_umts_fp_ep_and_ch_records, interface_type, uat_umts_fp_ep_and_ch_record_t, guint8, IuB_Interface, \"IuB Interface\")\nUAT_VS_DEF(uat_umts_fp_ep_and_ch_records, division, uat_umts_fp_ep_and_ch_record_t, guint8, Division_FDD, \"Division FDD\")\nUAT_VS_DEF(uat_umts_fp_ep_and_ch_records, rlc_mode, uat_umts_fp_ep_and_ch_record_t, guint8, FP_RLC_TM, \"RLC mode\")\nUAT_VS_DEF(uat_umts_fp_ep_and_ch_records, channel_type, uat_umts_fp_ep_and_ch_record_t, guint8, CHANNEL_RACH_FDD, \"RACH FDD\")\n\nstatic void *uat_umts_fp_record_copy_cb(void *n, const void *o, size_t siz _U_) {\n    uat_umts_fp_ep_and_ch_record_t *new_rec = (uat_umts_fp_ep_and_ch_record_t *)n;\n    const uat_umts_fp_ep_and_ch_record_t *old_rec = (const uat_umts_fp_ep_and_ch_record_t *)o;\n\n    new_rec->srcIP = (old_rec->srcIP) ? g_strdup(old_rec->srcIP) : NULL;\n    new_rec->dstIP = (old_rec->dstIP) ? g_strdup(old_rec->dstIP) : NULL;\n\n    return new_rec;\n}\n\nstatic void uat_umts_fp_record_free_cb(void*r) {\n    uat_umts_fp_ep_and_ch_record_t *rec = (uat_umts_fp_ep_and_ch_record_t *)r;\n\n    g_free(rec->srcIP);\n    g_free(rec->dstIP);\n}\n/*\n * Set up UAT predefined conversations for specified channels\n *  typedef struct {\n *    guint8 protocol;\n *    gchar *srcIP;\n *    guint16 src_port;\n *    gchar *dstIP;\n *    guint16 dst_port;\n *    guint8 interface_type;\n *    guint8 division;\n *    guint8 rlc_mode;\n *    guint8 channel_type;\n * } uat_umts_fp_ep_and_ch_record_t;\n */\nstatic void\numts_fp_init_protocol(void)\n{\n    guint32 hosta_addr[4];\n    guint32 hostb_addr[4];\n    address     src_addr, dst_addr;\n    conversation_t *conversation;\n    umts_fp_conversation_info_t *umts_fp_conversation_info;\n    guint i, j, num_tf;\n\n    for (i=0; i<num_umts_fp_ep_and_ch_items; i++) {\n        /* check if we have a conversation allready */\n\n        /* Convert the strings to ADDR */\n        if (uat_umts_fp_ep_and_ch_records[i].protocol == UMTS_FP_IPV4) {\n            if ((uat_umts_fp_ep_and_ch_records[i].srcIP) && (!str_to_ip(uat_umts_fp_ep_and_ch_records[i].srcIP, &hosta_addr))) {\n                continue; /* parsing failed, skip this entry */\n            }\n            if ((uat_umts_fp_ep_and_ch_records[i].dstIP) && (!str_to_ip(uat_umts_fp_ep_and_ch_records[i].dstIP, &hostb_addr))) {\n                continue; /* parsing failed, skip this entry */\n            }\n            set_address(&src_addr, AT_IPv4, 4, &hosta_addr);\n            set_address(&dst_addr, AT_IPv4, 4, &hostb_addr);\n        } else {\n            continue; /* Not implemented yet */\n        }\n        conversation = find_conversation(1, &src_addr, &dst_addr, PT_UDP, uat_umts_fp_ep_and_ch_records[i].src_port, 0, NO_ADDR2|NO_PORT2);\n        if (conversation == NULL) {\n            /* It's not part of any conversation - create a new one. */\n            conversation = conversation_new(1, &src_addr, &dst_addr, PT_UDP, uat_umts_fp_ep_and_ch_records[i].src_port, 0, NO_ADDR2|NO_PORT2);\n            if (conversation == NULL)\n                continue;\n            conversation_set_dissector(conversation, fp_handle);\n            switch (uat_umts_fp_ep_and_ch_records[i].channel_type) {\n            case CHANNEL_RACH_FDD:\n                /* set up conversation info for RACH FDD channels */\n                umts_fp_conversation_info = wmem_new0(wmem_file_scope(), umts_fp_conversation_info_t);\n                /* Fill in the data */\n                umts_fp_conversation_info->iface_type        = (enum fp_interface_type)uat_umts_fp_ep_and_ch_records[i].interface_type;\n                umts_fp_conversation_info->division          = (enum division_type) uat_umts_fp_ep_and_ch_records[i].division;\n                umts_fp_conversation_info->channel           = uat_umts_fp_ep_and_ch_records[i].channel_type;\n                umts_fp_conversation_info->dl_frame_number   = 0;\n                umts_fp_conversation_info->ul_frame_number   = 1;\n                copy_address_wmem(wmem_file_scope(), &(umts_fp_conversation_info->crnc_address), &src_addr);\n                umts_fp_conversation_info->crnc_port         = uat_umts_fp_ep_and_ch_records[i].src_port;\n                umts_fp_conversation_info->rlc_mode          = (enum fp_rlc_mode) uat_umts_fp_ep_and_ch_records[i].rlc_mode;\n                /*Save unique UE-identifier */\n                umts_fp_conversation_info->com_context_id = 1;\n\n\n                /* DCH's in this flow */\n                umts_fp_conversation_info->dch_crc_present = 2;\n                /* Set data for First or single channel */\n                umts_fp_conversation_info->fp_dch_channel_info[0].num_ul_chans = num_tf = 1;\n\n                for (j = 0; j < num_tf; j++) {\n                    umts_fp_conversation_info->fp_dch_channel_info[0].ul_chan_tf_size[j] = 168;\n                    umts_fp_conversation_info->fp_dch_channel_info[0].ul_chan_num_tbs[j] = 1;\n                }\n\n                umts_fp_conversation_info->dchs_in_flow_list[0] = 1;\n                umts_fp_conversation_info->num_dch_in_flow=1;\n                set_umts_fp_conv_data(conversation, umts_fp_conversation_info);\n            default:\n                break;\n            }\n        }\n    }\n}\n\n\n#endif /* UMTS_FP_USE_UAT */\n\nvoid proto_register_fp(void)\n{\n    static hf_register_info hf[] =\n        {\n            { &hf_fp_release,\n              { \"Release\",\n                \"fp.release\", FT_NONE, BASE_NONE, NULL, 0x0,\n                \"Release information\", HFILL\n              }\n            },\n            { &hf_fp_release_version,\n              { \"Release Version\",\n                \"fp.release.version\", FT_UINT8, BASE_DEC, NULL, 0x0,\n                \"3GPP Release number\", HFILL\n              }\n            },\n            { &hf_fp_release_year,\n              { \"Release year\",\n                \"fp.release.year\", FT_UINT16, BASE_DEC, NULL, 0x0,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_release_month,\n              { \"Release month\",\n                \"fp.release.month\", FT_UINT8, BASE_DEC, NULL, 0x0,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_channel_type,\n              { \"Channel Type\",\n                \"fp.channel-type\", FT_UINT8, BASE_HEX, VALS(channel_type_vals), 0x0,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_division,\n              { \"Division\",\n                \"fp.division\", FT_UINT8, BASE_HEX, VALS(division_vals), 0x0,\n                \"Radio division type\", HFILL\n              }\n            },\n            { &hf_fp_direction,\n              { \"Direction\",\n                \"fp.direction\", FT_UINT8, BASE_HEX, VALS(direction_vals), 0x0,\n                \"Link direction\", HFILL\n              }\n            },\n            { &hf_fp_ddi_config,\n              { \"DDI Config\",\n                \"fp.ddi-config\", FT_STRING, BASE_NONE, NULL, 0x0,\n                \"DDI Config (for E-DCH)\", HFILL\n              }\n            },\n            { &hf_fp_ddi_config_ddi,\n              { \"DDI\",\n                \"fp.ddi-config.ddi\", FT_UINT8, BASE_DEC, NULL, 0x0,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_ddi_config_macd_pdu_size,\n              { \"MACd PDU Size\",\n                \"fp.ddi-config.macd-pdu-size\", FT_UINT16, BASE_DEC, NULL, 0x0,\n                NULL, HFILL\n              }\n            },\n\n\n            { &hf_fp_header_crc,\n              { \"Header CRC\",\n                \"fp.header-crc\", FT_UINT8, BASE_HEX, NULL, 0xfe,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_ft,\n              { \"Frame Type\",\n                \"fp.ft\", FT_UINT8, BASE_HEX, VALS(data_control_vals), 0x01,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_cfn,\n              { \"CFN\",\n                \"fp.cfn\", FT_UINT8, BASE_DEC, NULL, 0x0,\n                \"Connection Frame Number\", HFILL\n              }\n            },\n            { &hf_fp_pch_cfn,\n              { \"CFN (PCH)\",\n                \"fp.pch.cfn\", FT_UINT16, BASE_DEC, NULL, 0xfff0,\n                \"PCH Connection Frame Number\", HFILL\n              }\n            },\n            { &hf_fp_pch_toa,\n              { \"ToA (PCH)\",\n                \"fp.pch.toa\", FT_INT24, BASE_DEC, NULL, 0x0,\n                \"PCH Time of Arrival\", HFILL\n              }\n            },\n            { &hf_fp_cfn_control,\n              { \"CFN control\",\n                \"fp.cfn-control\", FT_UINT8, BASE_DEC, NULL, 0x0,\n                \"Connection Frame Number Control\", HFILL\n              }\n            },\n            { &hf_fp_toa,\n              { \"ToA\",\n                \"fp.toa\", FT_INT16, BASE_DEC, NULL, 0x0,\n                \"Time of arrival (units are 125 microseconds)\", HFILL\n              }\n            },\n            { &hf_fp_tb,\n              { \"TB\",\n                \"fp.tb\", FT_BYTES, BASE_NONE, NULL, 0x0,\n                \"Transport Block\", HFILL\n              }\n            },\n            { &hf_fp_chan_zero_tbs,\n              { \"No TBs for channel\",\n                \"fp.channel-with-zero-tbs\", FT_UINT32, BASE_DEC, NULL, 0x0,\n                \"Channel with 0 TBs\", HFILL\n              }\n            },\n            { &hf_fp_tfi,\n              { \"TFI\",\n                \"fp.tfi\", FT_UINT8, BASE_DEC, NULL, 0x0,\n                \"Transport Format Indicator\", HFILL\n              }\n            },\n            { &hf_fp_usch_tfi,\n              { \"TFI\",\n                \"fp.usch.tfi\", FT_UINT8, BASE_DEC, NULL, 0x1f,\n                \"USCH Transport Format Indicator\", HFILL\n              }\n            },\n            { &hf_fp_cpch_tfi,\n              { \"TFI\",\n                \"fp.cpch.tfi\", FT_UINT8, BASE_DEC, NULL, 0x1f,\n                \"CPCH Transport Format Indicator\", HFILL\n              }\n            },\n            { &hf_fp_propagation_delay,\n              { \"Propagation Delay\",\n                \"fp.propagation-delay\", FT_UINT8, BASE_DEC, NULL, 0x0,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_dch_control_frame_type,\n              { \"Control Frame Type\",\n                \"fp.dch.control.frame-type\", FT_UINT8, BASE_HEX, VALS(dch_control_frame_type_vals), 0x0,\n                \"DCH Control Frame Type\", HFILL\n              }\n            },\n            { &hf_fp_dch_rx_timing_deviation,\n              { \"Rx Timing Deviation\",\n                \"fp.dch.control.rx-timing-deviation\", FT_UINT8, BASE_DEC, 0, 0x0,\n                \"DCH Rx Timing Deviation\", HFILL\n              }\n            },\n            { &hf_fp_quality_estimate,\n              { \"Quality Estimate\",\n                \"fp.dch.quality-estimate\", FT_UINT8, BASE_DEC, 0, 0x0,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_payload_crc,\n              { \"Payload CRC\",\n                \"fp.payload-crc\", FT_UINT16, BASE_HEX, 0, 0x0,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_common_control_frame_type,\n              { \"Control Frame Type\",\n                \"fp.common.control.frame-type\", FT_UINT8, BASE_HEX, VALS(common_control_frame_type_vals), 0x0,\n                \"Common Control Frame Type\", HFILL\n              }\n            },\n            { &hf_fp_crci[0],\n              { \"CRCI\",\n                \"fp.crci\", FT_UINT8, BASE_HEX, VALS(crci_vals), 0x80,\n                \"CRC correctness indicator\", HFILL\n              }\n            },\n            { &hf_fp_crci[1],\n              { \"CRCI\",\n                \"fp.crci\", FT_UINT8, BASE_HEX, VALS(crci_vals), 0x40,\n                \"CRC correctness indicator\", HFILL\n              }\n            },\n            { &hf_fp_crci[2],\n              { \"CRCI\",\n                \"fp.crci\", FT_UINT8, BASE_HEX, VALS(crci_vals), 0x20,\n                \"CRC correctness indicator\", HFILL\n              }\n            },\n            { &hf_fp_crci[3],\n              { \"CRCI\",\n                \"fp.crci\", FT_UINT8, BASE_HEX, VALS(crci_vals), 0x10,\n                \"CRC correctness indicator\", HFILL\n              }\n            },\n            { &hf_fp_crci[4],\n              { \"CRCI\",\n                \"fp.crci\", FT_UINT8, BASE_HEX, VALS(crci_vals), 0x08,\n                \"CRC correctness indicator\", HFILL\n              }\n            },\n            { &hf_fp_crci[5],\n              { \"CRCI\",\n                \"fp.crci\", FT_UINT8, BASE_HEX, VALS(crci_vals), 0x04,\n                \"CRC correctness indicator\", HFILL\n              }\n            },\n            { &hf_fp_crci[6],\n              { \"CRCI\",\n                \"fp.crci\", FT_UINT8, BASE_HEX, VALS(crci_vals), 0x02,\n                \"CRC correctness indicator\", HFILL\n              }\n            },\n            { &hf_fp_crci[7],\n              { \"CRCI\",\n                \"fp.crci\", FT_UINT8, BASE_HEX, VALS(crci_vals), 0x01,\n                \"CRC correctness indicator\", HFILL\n              }\n            },\n            { &hf_fp_received_sync_ul_timing_deviation,\n              { \"Received SYNC UL Timing Deviation\",\n                \"fp.rx-sync-ul-timing-deviation\", FT_UINT8, BASE_DEC, 0, 0x0,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_pch_pi,\n              { \"Paging Indication\",\n                \"fp.pch.pi\", FT_UINT8, BASE_DEC, VALS(paging_indication_vals), 0x01,\n                \"Indicates if the PI Bitmap is present\", HFILL\n              }\n            },\n            { &hf_fp_pch_tfi,\n              { \"TFI\",\n                \"fp.pch.tfi\", FT_UINT8, BASE_DEC, 0, 0x1f,\n                \"PCH Transport Format Indicator\", HFILL\n              }\n            },\n            { &hf_fp_fach_tfi,\n              { \"TFI\",\n                \"fp.fach.tfi\", FT_UINT8, BASE_DEC, 0, 0x1f,\n                \"FACH Transport Format Indicator\", HFILL\n              }\n            },\n            { &hf_fp_transmit_power_level,\n              { \"Transmit Power Level\",\n                \"fp.transmit-power-level\", FT_FLOAT, BASE_NONE, 0, 0x0,\n                \"Transmit Power Level (dB)\", HFILL\n              }\n            },\n            { &hf_fp_pdsch_set_id,\n              { \"PDSCH Set Id\",\n                \"fp.pdsch-set-id\", FT_UINT8, BASE_DEC, 0, 0x0,\n                \"A pointer to the PDSCH Set which shall be used to transmit\", HFILL\n              }\n            },\n            { &hf_fp_paging_indication_bitmap,\n              { \"Paging Indications bitmap\",\n                \"fp.pch.pi-bitmap\", FT_NONE, BASE_NONE, NULL, 0x0,\n                \"Paging Indication bitmap\", HFILL\n              }\n            },\n            { &hf_fp_rx_timing_deviation,\n              { \"Rx Timing Deviation\",\n                \"fp.common.control.rx-timing-deviation\", FT_UINT8, BASE_DEC, 0, 0x0,\n                \"Common Rx Timing Deviation\", HFILL\n              }\n            },\n            { &hf_fp_dch_e_rucch_flag,\n              { \"E-RUCCH Flag\",\n                \"fp.common.control.e-rucch-flag\", FT_UINT8, BASE_DEC, VALS(e_rucch_flag_vals), 0x0,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_edch_header_crc,\n              { \"E-DCH Header CRC\",\n                \"fp.edch.header-crc\", FT_UINT16, BASE_HEX, 0, 0,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_edch_fsn,\n              { \"FSN\",\n                \"fp.edch.fsn\", FT_UINT8, BASE_DEC, 0, 0x0f,\n                \"E-DCH Frame Sequence Number\", HFILL\n              }\n            },\n            { &hf_fp_edch_number_of_subframes,\n              { \"No of subframes\",\n                \"fp.edch.no-of-subframes\", FT_UINT8, BASE_DEC, 0, 0x0f,\n                \"E-DCH Number of subframes\", HFILL\n              }\n            },\n            { &hf_fp_edch_harq_retransmissions,\n              { \"No of HARQ Retransmissions\",\n                \"fp.edch.no-of-harq-retransmissions\", FT_UINT8, BASE_DEC, 0, 0x78,\n                \"E-DCH Number of HARQ retransmissions\", HFILL\n              }\n            },\n            { &hf_fp_edch_subframe_number,\n              { \"Subframe number\",\n                \"fp.edch.subframe-number\", FT_UINT8, BASE_DEC, 0, 0x0,\n                \"E-DCH Subframe number\", HFILL\n              }\n            },\n            { &hf_fp_edch_number_of_mac_es_pdus,\n              { \"Number of Mac-es PDUs\",\n                \"fp.edch.number-of-mac-es-pdus\", FT_UINT8, BASE_DEC, 0, 0xf0,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_edch_ddi,\n              { \"DDI\",\n                \"fp.edch.ddi\", FT_UINT8, BASE_DEC, 0, 0x0,\n                \"E-DCH Data Description Indicator\", HFILL\n              }\n            },\n            { &hf_fp_edch_subframe,\n              { \"Subframe\",\n                \"fp.edch.subframe\", FT_STRING, BASE_NONE, NULL, 0x0,\n                \"EDCH Subframe\", HFILL\n              }\n            },\n            { &hf_fp_edch_subframe_header,\n              { \"Subframe header\",\n                \"fp.edch.subframe-header\", FT_STRING, BASE_NONE, NULL, 0x0,\n                \"EDCH Subframe header\", HFILL\n              }\n            },\n            { &hf_fp_edch_number_of_mac_d_pdus,\n              { \"Number of Mac-d PDUs\",\n                \"fp.edch.number-of-mac-d-pdus\", FT_UINT8, BASE_DEC, 0, 0x0,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_edch_pdu_padding,\n              { \"Padding\",\n                \"fp.edch-data-padding\", FT_UINT8, BASE_DEC, 0, 0xc0,\n                \"E-DCH padding before PDU\", HFILL\n              }\n            },\n            { &hf_fp_edch_tsn,\n              { \"TSN\",\n                \"fp.edch-tsn\", FT_UINT8, BASE_DEC, 0, 0x3f,\n                \"E-DCH Transmission Sequence Number\", HFILL\n              }\n            },\n            { &hf_fp_edch_mac_es_pdu,\n              { \"MAC-es PDU\",\n                \"fp.edch.mac-es-pdu\", FT_NONE, BASE_NONE, NULL, 0x0,\n                NULL, HFILL\n              }\n            },\n\n            { &hf_fp_edch_user_buffer_size,\n              { \"User Buffer Size\",\n                \"fp.edch.user-buffer-size\", FT_UINT24, BASE_DEC, NULL, 0x0,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_edch_no_macid_sdus,\n              { \"No of MAC-is SDUs\",\n                \"fp.edch.no-macis-sdus\", FT_UINT16, BASE_DEC, NULL, 0x0,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_edch_number_of_mac_is_pdus,\n              { \"Number of Mac-is PDUs\",\n                \"fp.edch.number-of-mac-is-pdus\", FT_UINT8, BASE_DEC, 0, 0x0,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_edch_mac_is_pdu,\n              { \"Mac-is PDU\",\n                \"fp.edch.mac-is-pdu\", FT_BYTES, BASE_NONE, 0, 0x0,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_edch_e_rnti,\n              { \"E-RNTI\",\n                \"fp.edch.e-rnti\", FT_UINT16, BASE_DEC, 0, 0x0,\n                NULL, HFILL\n              }\n            },\n\n            { &hf_fp_edch_macis_descriptors,\n              { \"MAC-is Descriptors\",\n                \"fp.edch.mac-is.descriptors\", FT_STRING, BASE_NONE, NULL, 0x0,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_edch_macis_lchid,\n              { \"LCH-ID\",\n                \"fp.edch.mac-is.lchid\", FT_UINT8, BASE_HEX, VALS(lchid_vals), 0xf0,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_edch_macis_length,\n              { \"Length\",\n                \"fp.edch.mac-is.length\", FT_UINT16, BASE_DEC, 0, 0x0ffe,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_edch_macis_flag,\n              { \"Flag\",\n                \"fp.edch.mac-is.lchid\", FT_UINT8, BASE_HEX, 0, 0x01,\n                \"Indicates if another entry follows\", HFILL\n              }\n            },\n            { &hf_fp_frame_seq_nr,\n              { \"Frame Seq Nr\",\n                \"fp.frame-seq-nr\", FT_UINT8, BASE_DEC, 0, 0xf0,\n                \"Frame Sequence Number\", HFILL\n              }\n            },\n            { &hf_fp_hsdsch_pdu_block_header,\n              { \"PDU block header\",\n                \"fp.hsdsch.pdu-block-header\", FT_STRING, BASE_NONE, NULL, 0x0,\n                \"HS-DSCH type 2 PDU block header\", HFILL\n              }\n            },\n#if 0\n            { &hf_fp_hsdsch_pdu_block,\n              { \"PDU block\",\n                \"fp.hsdsch.pdu-block\", FT_STRING, BASE_NONE, NULL, 0x0,\n                \"HS-DSCH type 2 PDU block data\", HFILL\n              }\n            },\n#endif\n            { &hf_fp_flush,\n              { \"Flush\",\n                \"fp.flush\", FT_UINT8, BASE_DEC, 0, 0x04,\n                \"Whether all PDUs for this priority queue should be removed\", HFILL\n              }\n            },\n            { &hf_fp_fsn_drt_reset,\n              { \"FSN-DRT reset\",\n                \"fp.fsn-drt-reset\", FT_UINT8, BASE_DEC, 0, 0x02,\n                \"FSN/DRT Reset Flag\", HFILL\n              }\n            },\n            { &hf_fp_drt_indicator,\n              { \"DRT Indicator\",\n                \"fp.drt-indicator\", FT_UINT8, BASE_DEC, 0, 0x01,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_fach_indicator,\n              { \"FACH Indicator\",\n                \"fp.fach-indicator\", FT_UINT8, BASE_DEC, 0, 0x80,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_total_pdu_blocks,\n              { \"PDU Blocks\",\n                \"fp.pdu_blocks\", FT_UINT8, BASE_DEC, 0, 0xf8,\n                \"Total number of PDU blocks\", HFILL\n              }\n            },\n            { &hf_fp_drt,\n              { \"DelayRefTime\",\n                \"fp.drt\", FT_UINT16, BASE_DEC, 0, 0x0,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_hrnti,\n              { \"HRNTI\",\n                \"fp.hrnti\", FT_UINT16, BASE_DEC, 0, 0x0,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_rach_measurement_result,\n              { \"RACH Measurement Result\",\n                \"fp.rach-measurement-result\", FT_UINT16, BASE_DEC, 0, 0x0,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_lchid,\n              { \"Logical Channel ID\",\n                \"fp.lchid\", FT_UINT8, BASE_DEC, NULL, 0x0,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_pdu_length_in_block,\n              { \"PDU length in block\",\n                \"fp.pdu-length-in-block\", FT_UINT8, BASE_DEC, 0, 0x0,\n                \"Length of each PDU in this block in bytes\", HFILL\n              }\n            },\n            { &hf_fp_pdus_in_block,\n              { \"PDUs in block\",\n                \"fp.no-pdus-in-block\", FT_UINT8, BASE_DEC, 0, 0x0,\n                \"Number of PDUs in block\", HFILL\n              }\n            },\n            { &hf_fp_cmch_pi,\n              { \"CmCH-PI\",\n                \"fp.cmch-pi\", FT_UINT8, BASE_DEC, 0, 0x0f,\n                \"Common Transport Channel Priority Indicator\", HFILL\n              }\n            },\n            { &hf_fp_user_buffer_size,\n              { \"User buffer size\",\n                \"fp.user-buffer-size\", FT_UINT16, BASE_DEC, 0, 0x0,\n                \"User buffer size in octets\", HFILL\n              }\n            },\n            { &hf_fp_hsdsch_credits,\n              { \"HS-DSCH Credits\",\n                \"fp.hsdsch-credits\", FT_UINT16, BASE_DEC, 0, 0x0,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_hsdsch_max_macd_pdu_len,\n              { \"Max MAC-d PDU Length\",\n                \"fp.hsdsch.max-macd-pdu-len\", FT_UINT16, BASE_DEC, 0, 0xfff8,\n                \"Maximum MAC-d PDU Length in bits\", HFILL\n              }\n            },\n            { &hf_fp_hsdsch_max_macdc_pdu_len,\n              { \"Max MAC-d/c PDU Length\",\n                \"fp.hsdsch.max-macdc-pdu-len\", FT_UINT16, BASE_DEC, 0, 0x07ff,\n                \"Maximum MAC-d/c PDU Length in bits\", HFILL\n              }\n            },\n            { &hf_fp_hsdsch_interval,\n              { \"HS-DSCH Interval in milliseconds\",\n                \"fp.hsdsch-interval\", FT_UINT8, BASE_DEC, 0, 0x0,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_hsdsch_calculated_rate,\n              { \"Calculated rate allocation (bps)\",\n                \"fp.hsdsch-calculated-rate\", FT_UINT32, BASE_DEC, 0, 0x0,\n                \"Calculated rate RNC is allowed to send in bps\", HFILL\n              }\n            },\n            { &hf_fp_hsdsch_unlimited_rate,\n              { \"Unlimited rate\",\n                \"fp.hsdsch-unlimited-rate\", FT_NONE, BASE_NONE, 0, 0x0,\n                \"No restriction on rate at which date may be sent\", HFILL\n              }\n            },\n            { &hf_fp_hsdsch_repetition_period,\n              { \"HS-DSCH Repetition Period\",\n                \"fp.hsdsch-repetition-period\", FT_UINT8, BASE_DEC, 0, 0x0,\n                \"HS-DSCH Repetition Period in milliseconds\", HFILL\n              }\n            },\n            { &hf_fp_hsdsch_data_padding,\n              { \"Padding\",\n                \"fp.hsdsch-data-padding\", FT_UINT8, BASE_DEC, 0, 0xf0,\n                \"HS-DSCH Repetition Period in milliseconds\", HFILL\n              }\n            },\n            { &hf_fp_hsdsch_new_ie_flags,\n              { \"New IEs flags\",\n                \"fp.hsdsch.new-ie-flags\", FT_STRING, BASE_NONE, 0, 0x0,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_hsdsch_new_ie_flag[0],\n              { \"DRT IE present\",\n                \"fp.hsdsch.new-ie-flag\", FT_UINT8, BASE_DEC, 0, 0x80,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_hsdsch_new_ie_flag[1],\n              { \"New IE present\",\n                \"fp.hsdsch.new-ie-flag\", FT_UINT8, BASE_DEC, 0, 0x40,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_hsdsch_new_ie_flag[2],\n              { \"New IE present\",\n                \"fp.hsdsch.new-ie-flag\", FT_UINT8, BASE_DEC, 0, 0x20,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_hsdsch_new_ie_flag[3],\n              { \"New IE present\",\n                \"fp.hsdsch.new-ie-flag\", FT_UINT8, BASE_DEC, 0, 0x10,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_hsdsch_new_ie_flag[4],\n              { \"New IE present\",\n                \"fp.hsdsch.new-ie-flag\", FT_UINT8, BASE_DEC, 0, 0x08,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_hsdsch_new_ie_flag[5],\n              { \"New IE present\",\n                \"fp.hsdsch.new-ie-flag\", FT_UINT8, BASE_DEC, 0, 0x04,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_hsdsch_new_ie_flag[6],\n              { \"HS-DSCH physical layer category present\",\n                \"fp.hsdsch.new-ie-flag\", FT_UINT8, BASE_DEC, 0, 0x02,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_hsdsch_new_ie_flag[7],\n              { \"Another new IE flags byte\",\n                \"fp.hsdsch.new-ie-flags-byte\", FT_UINT8, BASE_DEC, 0, 0x01,\n                \"Another new IE flagsbyte\", HFILL\n              }\n            },\n            { &hf_fp_hsdsch_drt,\n              { \"DRT\",\n                \"fp.hsdsch.drt\", FT_UINT8, BASE_DEC, 0, 0xf0,\n                \"Delay Reference Time\", HFILL\n              }\n            },\n            { &hf_fp_hsdsch_entity,\n              { \"HS-DSCH Entity\",\n                \"fp.hsdsch.entity\", FT_UINT8, BASE_DEC, VALS(hsdshc_mac_entity_vals), 0x0,\n                \"Type of MAC entity for this HS-DSCH channel\", HFILL\n              }\n            },\n            { &hf_fp_timing_advance,\n              { \"Timing advance\",\n                \"fp.timing-advance\", FT_UINT8, BASE_DEC, 0, 0x3f,\n                \"Timing advance in chips\", HFILL\n              }\n            },\n            { &hf_fp_num_of_pdu,\n              { \"Number of PDUs\",\n                \"fp.hsdsch.num-of-pdu\", FT_UINT8, BASE_DEC, 0, 0x0,\n                \"Number of PDUs in the payload\", HFILL\n              }\n            },\n            { &hf_fp_mac_d_pdu_len,\n              { \"MAC-d PDU Length\",\n                \"fp.hsdsch.mac-d-pdu-len\", FT_UINT16, BASE_DEC, 0, 0xfff8,\n                \"MAC-d PDU Length in bits\", HFILL\n              }\n            },\n            { &hf_fp_mac_d_pdu,\n              { \"MAC-d PDU\",\n                \"fp.mac-d-pdu\", FT_BYTES, BASE_NONE, NULL, 0x0,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_data,\n              { \"Data\",\n                \"fp.data\", FT_BYTES, BASE_NONE, NULL, 0x0,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_crcis,\n              { \"CRCIs\",\n                \"fp.crcis\", FT_BYTES, BASE_NONE, NULL, 0x0,\n                \"CRC Indicators for uplink TBs\", HFILL\n              }\n            },\n            { &hf_fp_t1,\n              { \"T1\",\n                \"fp.t1\", FT_UINT24, BASE_DEC, NULL, 0x0,\n                \"RNC frame number indicating time it sends frame\", HFILL\n              }\n            },\n            { &hf_fp_t2,\n              { \"T2\",\n                \"fp.t2\", FT_UINT24, BASE_DEC, NULL, 0x0,\n                \"NodeB frame number indicating time it received DL Sync\", HFILL\n              }\n            },\n            { &hf_fp_t3,\n              { \"T3\",\n                \"fp.t3\", FT_UINT24, BASE_DEC, NULL, 0x0,\n                \"NodeB frame number indicating time it sends frame\", HFILL\n              }\n            },\n            { &hf_fp_ul_sir_target,\n              { \"UL_SIR_TARGET\",\n                \"fp.ul-sir-target\", FT_FLOAT, BASE_NONE, 0, 0x0,\n                \"Value (in dB) of the SIR target to be used by the UL inner loop power control\", HFILL\n              }\n            },\n            { &hf_fp_pusch_set_id,\n              { \"PUSCH Set Id\",\n                \"fp.pusch-set-id\", FT_UINT8, BASE_DEC, NULL, 0x0,\n                \"Identifies PUSCH Set from those configured in NodeB\", HFILL\n              }\n            },\n            { &hf_fp_activation_cfn,\n              { \"Activation CFN\",\n                \"fp.activation-cfn\", FT_UINT8, BASE_DEC, NULL, 0x0,\n                \"Activation Connection Frame Number\", HFILL\n              }\n            },\n            { &hf_fp_duration,\n              { \"Duration (ms)\",\n                \"fp.pusch-set-id\", FT_UINT8, BASE_DEC, NULL, 0x0,\n                \"Duration of the activation period of the PUSCH Set\", HFILL\n              }\n            },\n            { &hf_fp_power_offset,\n              { \"Power offset\",\n                \"fp.power-offset\", FT_FLOAT, BASE_NONE, NULL, 0x0,\n                \"Power offset (in dB)\", HFILL\n              }\n            },\n            { &hf_fp_code_number,\n              { \"Code number\",\n                \"fp.code-number\", FT_UINT8, BASE_DEC, NULL, 0x0,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_spreading_factor,\n              { \"Spreading factor\",\n                \"fp.spreading-factor\", FT_UINT8, BASE_DEC, VALS(spreading_factor_vals), 0xf0,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_mc_info,\n              { \"MC info\",\n                \"fp.mc-info\", FT_UINT8, BASE_DEC, NULL, 0x0e,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_rach_new_ie_flags,\n              { \"New IEs flags\",\n                \"fp.rach.new-ie-flags\", FT_STRING, BASE_NONE, 0, 0x0,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_rach_new_ie_flag_unused[0],\n              { \"New IE present\",\n                \"fp.rach.new-ie-flag\", FT_UINT8, BASE_DEC, 0, 0x80,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_rach_new_ie_flag_unused[1],\n              { \"New IE present\",\n                \"fp.rach.new-ie-flag\", FT_UINT8, BASE_DEC, 0, 0x40,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_rach_new_ie_flag_unused[2],\n              { \"New IE present\",\n                \"fp.rach.new-ie-flag\", FT_UINT8, BASE_DEC, 0, 0x20,\n                \"New IE present (unused)\", HFILL\n              }\n            },\n            { &hf_fp_rach_new_ie_flag_unused[3],\n              { \"New IE present\",\n                \"fp.rach.new-ie-flag\", FT_UINT8, BASE_DEC, 0, 0x10,\n                \"New IE present (unused)\", HFILL\n              }\n            },\n            { &hf_fp_rach_new_ie_flag_unused[4],\n              { \"New IE present\",\n                \"fp.rach.new-ie-flag\", FT_UINT8, BASE_DEC, 0, 0x08,\n                \"New IE present (unused)\", HFILL\n              }\n            },\n            { &hf_fp_rach_new_ie_flag_unused[5],\n              { \"New IE present\",\n                \"fp.rach.new-ie-flag\", FT_UINT8, BASE_DEC, 0, 0x04,\n                \"New IE present (unused)\", HFILL\n              }\n            },\n            { &hf_fp_rach_new_ie_flag_unused[6],\n              { \"New IE present\",\n                \"fp.rach.new-ie-flag\", FT_UINT8, BASE_DEC, 0, 0x02,\n                \"New IE present (unused)\", HFILL\n              }\n            },\n            { &hf_fp_rach_cell_portion_id_present,\n              { \"Cell portion ID present\",\n                \"fp.rach.cell-portion-id-present\", FT_UINT8, BASE_DEC, 0, 0x01,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_rach_angle_of_arrival_present,\n              { \"Angle of arrival present\",\n                \"fp.rach.angle-of-arrival-present\", FT_UINT8, BASE_DEC, 0, 0x01,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_rach_ext_propagation_delay_present,\n              { \"Ext Propagation Delay Present\",\n                \"fp.rach.ext-propagation-delay-present\", FT_UINT8, BASE_DEC, 0, 0x02,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_rach_ext_rx_sync_ul_timing_deviation_present,\n              { \"Ext Received Sync UL Timing Deviation present\",\n                \"fp.rach.ext-rx-sync-ul-timing-deviation-present\", FT_UINT8, BASE_DEC, 0, 0x02,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_rach_ext_rx_timing_deviation_present,\n              { \"Ext Rx Timing Deviation present\",\n                \"fp.rach.ext-rx-timing-deviation-present\", FT_UINT8, BASE_DEC, 0, 0x01,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_cell_portion_id,\n              { \"Cell Portion ID\",\n                \"fp.cell-portion-id\", FT_UINT8, BASE_DEC, NULL, 0x3f,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_ext_propagation_delay,\n              { \"Ext Propagation Delay\",\n                \"fp.ext-propagation-delay\", FT_UINT16, BASE_DEC, NULL, 0x03ff,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_angle_of_arrival,\n              { \"Angle of Arrival\",\n                \"fp.angle-of-arrival\", FT_UINT16, BASE_DEC, NULL, 0x03ff,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_ext_received_sync_ul_timing_deviation,\n              { \"Ext Received SYNC UL Timing Deviation\",\n                \"fp.ext-received-sync-ul-timing-deviation\", FT_UINT16, BASE_DEC, NULL, 0x1fff,\n                NULL, HFILL\n              }\n            },\n\n\n            { &hf_fp_radio_interface_parameter_update_flag[0],\n              { \"CFN valid\",\n                \"fp.radio-interface-param.cfn-valid\", FT_UINT16, BASE_DEC, 0, 0x0001,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_radio_interface_parameter_update_flag[1],\n              { \"TPC PO valid\",\n                \"fp.radio-interface-param.tpc-po-valid\", FT_UINT16, BASE_DEC, 0, 0x0002,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_radio_interface_parameter_update_flag[2],\n              { \"DPC mode valid\",\n                \"fp.radio-interface-param.dpc-mode-valid\", FT_UINT16, BASE_DEC, 0, 0x0004,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_radio_interface_parameter_update_flag[3],\n              { \"RL sets indicator valid\",\n                \"fp.radio-interface_param.rl-sets-indicator-valid\", FT_UINT16, BASE_DEC, 0, 0x0020,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_radio_interface_parameter_update_flag[4],\n              { \"MAX_UE_TX_POW valid\",\n                \"fp.radio-interface-param.max-ue-tx-pow-valid\", FT_UINT16, BASE_DEC, 0, 0x0040,\n                \"MAX UE TX POW valid\", HFILL\n              }\n            },\n            { &hf_fp_dpc_mode,\n              { \"DPC Mode\",\n                \"fp.dpc-mode\", FT_UINT8, BASE_DEC, NULL, 0x20,\n                \"DPC Mode to be applied in the uplink\", HFILL\n              }\n            },\n            { &hf_fp_tpc_po,\n              { \"TPC PO\",\n                \"fp.tpc-po\", FT_UINT8, BASE_DEC, NULL, 0x1f,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_multiple_rl_set_indicator,\n              { \"Multiple RL sets indicator\",\n                \"fp.multiple-rl-sets-indicator\", FT_UINT8, BASE_DEC, NULL, 0x80,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_max_ue_tx_pow,\n              { \"MAX_UE_TX_POW\",\n                \"fp.max-ue-tx-pow\", FT_INT8, BASE_DEC, NULL, 0x0,\n                \"Max UE TX POW (dBm)\", HFILL\n              }\n            },\n            { &hf_fp_congestion_status,\n              { \"Congestion Status\",\n                \"fp.congestion-status\", FT_UINT8, BASE_DEC, VALS(congestion_status_vals), 0x0,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_e_rucch_present,\n              { \"E-RUCCH Present\",\n                \"fp.erucch-present\", FT_UINT8, BASE_DEC, NULL, 0x0,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_extended_bits_present,\n              { \"Extended Bits Present\",\n                \"fp.extended-bits-present\", FT_UINT8, BASE_DEC, NULL, 0x0,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_extended_bits,\n              { \"Extended Bits\",\n                \"fp.extended-bits\", FT_UINT8, BASE_HEX, NULL, 0x0,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_spare_extension,\n              { \"Spare Extension\",\n                \"fp.spare-extension\", FT_NONE, BASE_NONE, NULL, 0x0,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_ul_setup_frame,\n              { \"UL setup frame\",\n                \"fp.ul.setup_frame\", FT_FRAMENUM, BASE_NONE, NULL, 0x0,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_dl_setup_frame,\n              { \"DL setup frame\",\n                \"fp.dl.setup_frame\", FT_FRAMENUM, BASE_NONE, NULL, 0x0,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_hsdsch_physical_layer_category,\n              { \"HS-DSCH physical layer category\",\n                \"fp.hsdsch.physical_layer_category\", FT_UINT8, BASE_DEC, NULL, 0x0,\n                NULL, HFILL\n              }\n            }\n        };\n\n\n    static gint *ett[] =\n    {\n        &ett_fp,\n        &ett_fp_data,\n        &ett_fp_crcis,\n        &ett_fp_ddi_config,\n        &ett_fp_edch_subframe_header,\n        &ett_fp_edch_subframe,\n        &ett_fp_edch_maces,\n        &ett_fp_edch_macis_descriptors,\n        &ett_fp_hsdsch_new_ie_flags,\n        &ett_fp_rach_new_ie_flags,\n        &ett_fp_hsdsch_pdu_block_header,\n        &ett_fp_release\n    };\n\n    static ei_register_info ei[] = {\n        { &ei_fp_bad_header_checksum, { \"fp.header.bad_checksum.\", PI_CHECKSUM, PI_WARN, \"Bad header checksum.\", EXPFILL }},\n        { &ei_fp_crci_no_subdissector, { \"fp.crci.no_subdissector\", PI_UNDECODED, PI_NOTE, \"Not sent to subdissectors as CRCI is set\", EXPFILL }},\n        { &ei_fp_crci_error_bit_set_for_tb, { \"fp.crci.error_bit_set_for_tb\", PI_CHECKSUM, PI_WARN, \"CRCI error bit set for TB\", EXPFILL }},\n        { &ei_fp_spare_extension, { \"fp.spare-extension.expert\", PI_UNDECODED, PI_WARN, \"Spare Extension present (%u bytes)\", EXPFILL }},\n        { &ei_fp_bad_payload_checksum, { \"fp.payload-crc.bad.\", PI_CHECKSUM, PI_WARN, \"Bad payload checksum.\", EXPFILL }},\n        { &ei_fp_stop_hsdpa_transmission, { \"fp.stop_hsdpa_transmission\", PI_RESPONSE_CODE, PI_NOTE, \"Stop HSDPA transmission\", EXPFILL }},\n        { &ei_fp_timing_adjustmentment_reported, { \"fp.timing_adjustmentment_reported\", PI_SEQUENCE, PI_WARN, \"Timing adjustmentment reported (%f ms)\", EXPFILL }},\n        { &ei_fp_expecting_tdd, { \"fp.expecting_tdd\", PI_MALFORMED, PI_NOTE, \"Error: expecting TDD-384 or TDD-768\", EXPFILL }},\n        { &ei_fp_ddi_not_defined, { \"fp.ddi_not_defined\", PI_MALFORMED, PI_ERROR, \"DDI %u not defined for this UE!\", EXPFILL }},\n        { &ei_fp_unable_to_locate_ddi_entry, { \"fp.unable_to_locate_ddi_entry\", PI_UNDECODED, PI_ERROR, \"Unable to locate DDI entry.\", EXPFILL }},\n        { &ei_fp_mac_is_sdus_miscount, { \"fp.mac_is_sdus.miscount\", PI_MALFORMED, PI_ERROR, \"Found too many (%u) MAC-is SDUs - header said there were %u\", EXPFILL }},\n        { &ei_fp_e_rnti_t2_edch_frames, { \"fp.e_rnti.t2_edch_frames\", PI_MALFORMED, PI_ERROR, \"E-RNTI not supposed to appear for T2 EDCH frames\", EXPFILL }},\n        { &ei_fp_e_rnti_first_entry, { \"fp.e_rnti.first_entry\", PI_MALFORMED, PI_ERROR, \"E-RNTI must be first entry among descriptors\", EXPFILL }},\n        { &ei_fp_maybe_srb, { \"fp.maybe_srb\", PI_PROTOCOL, PI_NOTE, \"Found MACd-Flow = 0 and not MUX detected. (This might be SRB)\", EXPFILL }},\n        { &ei_fp_transport_channel_type_unknown, { \"fp.transport_channel_type.unknown\", PI_UNDECODED, PI_WARN, \"Unknown transport channel type\", EXPFILL }},\n        { &ei_fp_hsdsch_entity_not_specified, { \"fp.hsdsch_entity_not_specified\", PI_MALFORMED, PI_ERROR, \"HSDSCH Entity not specified\", EXPFILL }},\n        { &ei_fp_hsdsch_common_experimental_support, { \"fp.hsdsch_common.experimental_support\", PI_DEBUG, PI_WARN, \"HSDSCH COMMON - Experimental support!\", EXPFILL }},\n        { &ei_fp_hsdsch_common_t3_not_implemented, { \"fp.hsdsch_common_t3.not_implemented\", PI_DEBUG, PI_ERROR, \"HSDSCH COMMON T3 - Not implemeneted!\", EXPFILL }},\n        { &ei_fp_channel_type_unknown, { \"fp.channel_type.unknown\", PI_MALFORMED, PI_ERROR, \"Unknown channel type\", EXPFILL }},\n        { &ei_fp_no_per_frame_info, { \"fp.no_per_frame_info\", PI_UNDECODED, PI_ERROR, \"Can't dissect FP frame because no per-frame info was attached!\", EXPFILL }},\n    };\n\n    module_t *fp_module;\n    expert_module_t *expert_fp;\n\n#ifdef UMTS_FP_USE_UAT\n    /* Define a UAT to set channel configuration data */\n\n  static const value_string umts_fp_proto_type_vals[] = {\n    { UMTS_FP_IPV4, \"IPv4\" },\n    { UMTS_FP_IPV6, \"IPv6\" },\n    { 0x00, NULL }\n  };\n  static const value_string umts_fp_uat_channel_type_vals[] = {\n    { CHANNEL_RACH_FDD, \"RACH FDD\" },\n    { 0x00, NULL }\n  };\n  static const value_string umts_fp_uat_interface_type_vals[] = {\n    { IuB_Interface, \"IuB Interface\" },\n    { 0x00, NULL }\n  };\n  static const value_string umts_fp_uat_division_type_vals[] = {\n    { Division_FDD, \"Division FDD\" },\n    { 0x00, NULL }\n  };\n\n  static const value_string umts_fp_uat_rlc_mode_vals[] = {\n    { FP_RLC_TM, \"FP RLC TM\" },\n    { 0x00, NULL }\n  };\n\n  static uat_field_t umts_fp_uat_flds[] = {\n      UAT_FLD_VS(uat_umts_fp_ep_and_ch_records, protocol, \"IP address type\", umts_fp_proto_type_vals, \"IPv4 or IPv6\"),\n      UAT_FLD_CSTRING(uat_umts_fp_ep_and_ch_records, srcIP, \"RNC IP Address\", \"Source Address\"),\n      UAT_FLD_DEC(uat_umts_fp_ep_and_ch_records, src_port, \"RNC port for this channel\", \"Source port\"),\n      UAT_FLD_CSTRING(uat_umts_fp_ep_and_ch_records, dstIP, \"NodeB IP Address\", \"Destination Address\"),\n      UAT_FLD_DEC(uat_umts_fp_ep_and_ch_records, dst_port, \"NodeB port for this channel\", \"Destination port\"),\n      UAT_FLD_VS(uat_umts_fp_ep_and_ch_records, interface_type, \"Interface type\", umts_fp_uat_interface_type_vals, \"Interface type used\"),\n      UAT_FLD_VS(uat_umts_fp_ep_and_ch_records, division, \"division\", umts_fp_uat_division_type_vals, \"Division type used\"),\n      UAT_FLD_VS(uat_umts_fp_ep_and_ch_records, channel_type, \"Channel type\", umts_fp_uat_channel_type_vals, \"Channel type used\"),\n      UAT_FLD_VS(uat_umts_fp_ep_and_ch_records, rlc_mode, \"RLC mode\", umts_fp_uat_rlc_mode_vals, \"RLC mode used\"),\n      UAT_END_FIELDS\n    };\n#endif /* UMTS_FP_USE_UAT */\n    /* Register protocol. */\n    proto_fp = proto_register_protocol(\"FP\", \"FP\", \"fp\");\n    proto_register_field_array(proto_fp, hf, array_length(hf));\n    proto_register_subtree_array(ett, array_length(ett));\n    expert_fp = expert_register_protocol(proto_fp);\n    expert_register_field_array(expert_fp, ei, array_length(ei));\n\n    /* Allow other dissectors to find this one by name. */\n    fp_handle = register_dissector(\"fp\", dissect_fp, proto_fp);\n\n    /* Preferences */\n    fp_module = prefs_register_protocol(proto_fp, NULL);\n\n    /* Determines whether release information should be displayed */\n    prefs_register_bool_preference(fp_module, \"show_release_info\",\n                                   \"Show reported release info\",\n                                   \"Show reported release info\",\n                                   &preferences_show_release_info);\n\n    /* Determines whether MAC dissector should be called for payloads */\n    prefs_register_bool_preference(fp_module, \"call_mac\",\n                                   \"Call MAC dissector for payloads\",\n                                   \"Call MAC dissector for payloads\",\n                                   &preferences_call_mac_dissectors);\n     /* Determines whether or not to validate FP payload checksums */\n    prefs_register_bool_preference(fp_module, \"payload_checksum\",\n                                    \"Validate FP payload checksums\",\n                                    \"Validate FP payload checksums\",\n                                    &preferences_payload_checksum);\n     /* Determines whether or not to validate FP header checksums */\n    prefs_register_bool_preference(fp_module, \"header_checksum\",\n                                    \"Validate FP header checksums\",\n                                    \"Validate FP header checksums\",\n                                    &preferences_header_checksum);\n     /* Determines whether or not to validate FP header checksums */\n    prefs_register_obsolete_preference(fp_module, \"udp_heur\");\n#ifdef UMTS_FP_USE_UAT\n\n  umts_fp_uat = uat_new(\"Endpoint and Channel Configuration\",\n            sizeof(uat_umts_fp_ep_and_ch_record_t),   /* record size */\n            \"umts_fp_ep_and_channel_cnf\",     /* filename */\n            TRUE,                             /* from_profile */\n            &uat_umts_fp_ep_and_ch_records,   /* data_ptr */\n            &num_umts_fp_ep_and_ch_items,     /* numitems_ptr */\n            UAT_AFFECTS_DISSECTION,           /* affects dissection of packets, but not set of named fields */\n            NULL,                             /* help */\n            uat_umts_fp_record_copy_cb,       /* copy callback */\n            NULL,                             /* update callback */\n            uat_umts_fp_record_free_cb,       /* free callback */\n            NULL,                             /* post update callback */\n            umts_fp_uat_flds);                /* UAT field definitions */\n\n  prefs_register_uat_preference(fp_module,\n                                \"epandchannelconfigurationtable\",\n                                \"Endpoints and Radio Channels configuration\",\n                                \"Preconfigured endpoint and Channels data\",\n                                umts_fp_uat);\n\n  register_init_routine(&umts_fp_init_protocol);\n#endif\n\n}\n\n\nvoid proto_reg_handoff_fp(void)\n{\n    dissector_handle_t fp_aal2_handle;\n\n    rlc_bcch_handle           = find_dissector_add_dependency(\"rlc.bcch\", proto_fp);\n    mac_fdd_rach_handle       = find_dissector_add_dependency(\"mac.fdd.rach\", proto_fp);\n    mac_fdd_fach_handle       = find_dissector_add_dependency(\"mac.fdd.fach\", proto_fp);\n    mac_fdd_pch_handle        = find_dissector_add_dependency(\"mac.fdd.pch\", proto_fp);\n    mac_fdd_dch_handle        = find_dissector_add_dependency(\"mac.fdd.dch\", proto_fp);\n    mac_fdd_edch_handle       = find_dissector_add_dependency(\"mac.fdd.edch\", proto_fp);\n    mac_fdd_edch_type2_handle = find_dissector_add_dependency(\"mac.fdd.edch.type2\", proto_fp);\n    mac_fdd_hsdsch_handle     = find_dissector_add_dependency(\"mac.fdd.hsdsch\", proto_fp);\n\n    heur_dissector_add(\"udp\", heur_dissect_fp, \"FP over UDP\", \"fp_udp\", proto_fp, HEURISTIC_DISABLE);\n\n    fp_aal2_handle = create_dissector_handle(dissect_fp_aal2, proto_fp);\n    dissector_add_uint(\"atm.aal2.type\", TRAF_UMTS_FP, fp_aal2_handle);\n}\n\n/*\n * Editor modelines  -  http://www.wireshark.org/tools/modelines.html\n *\n * Local variables:\n * c-basic-offset: 4\n * tab-width: 8\n * indent-tabs-mode: nil\n * End:\n *\n * vi: set shiftwidth=4 tabstop=8 expandtab:\n * :indentSize=4:tabSize=8:noTabs=true:\n */\n", "code_before": "/* packet-umts_fp.c\n * Routines for UMTS FP disassembly\n *\n * Martin Mathieson\n *\n * Wireshark - Network traffic analyzer\n * By Gerald Combs <gerald@wireshark.org>\n * Copyright 1998 Gerald Combs\n *\n * SPDX-License-Identifier: GPL-2.0-or-later\n */\n\n#include \"config.h\"\n\n#include <epan/packet.h>\n#include <epan/expert.h>\n#include <epan/prefs.h>\n#include <epan/conversation.h>\n#include <epan/proto_data.h>\n#include <epan/tfs.h>\n\n#include <wsutil/array.h>\n#include <wsutil/crc7.h> /* For FP data header and control frame CRC. */\n#include <wsutil/crc16-plain.h> /* For FP Payload CRC. */\n#include <wsutil/crc11.h> /* For FP EDCH header CRC. */\n#include <wsutil/pint.h>\n#include <wsutil/ws_roundup.h>\n\n#include \"packet-umts_fp.h\"\n#include \"packet-nbap.h\"\n#include \"packet-rrc.h\"\n\n/* The Frame Protocol (FP) is described in:\n * 3GPP TS 25.427 (for dedicated channels)\n * 3GPP TS 25.435 (for common/shared channels)\n *\n * TODO:\n *  - IUR interface-specific formats\n *  - do CRC verification before further parsing\n *  - Set the logical channel properly for non multiplexed, channels\n *    for channels that doesn't have the C/T field! This should be based\n *    on the RRC message RadioBearerSetup.\n *  - E-DCH T2 heuristic dissector\n */\nvoid proto_register_fp(void);\nvoid proto_reg_handoff_fp(void);\n\n/* Initialize the protocol and registered fields. */\n\nint proto_fp;\nextern int proto_umts_mac;\nextern int proto_umts_rlc;\n\nstatic int hf_fp_release;\nstatic int hf_fp_release_version;\nstatic int hf_fp_release_year;\nstatic int hf_fp_release_month;\nstatic int hf_fp_channel_type;\nstatic int hf_fp_division;\nstatic int hf_fp_direction;\nstatic int hf_fp_ddi_config;\nstatic int hf_fp_ddi_config_ddi;\nstatic int hf_fp_ddi_config_macd_pdu_size;\n\nstatic int hf_fp_header_crc;\nstatic int hf_fp_ft;\nstatic int hf_fp_cfn;\nstatic int hf_fp_pch_cfn;\nstatic int hf_fp_pch_toa;\nstatic int hf_fp_cfn_control;\nstatic int hf_fp_toa;\nstatic int hf_fp_tfi;\nstatic int hf_fp_usch_tfi;\nstatic int hf_fp_cpch_tfi;\nstatic int hf_fp_propagation_delay;\nstatic int hf_fp_tb;\nstatic int hf_fp_chan_zero_tbs;\nstatic int hf_fp_received_sync_ul_timing_deviation;\nstatic int hf_fp_pch_pi;\nstatic int hf_fp_pch_tfi;\nstatic int hf_fp_fach_tfi;\nstatic int hf_fp_transmit_power_level;\nstatic int hf_fp_paging_indication_bitmap;\nstatic int hf_fp_relevant_paging_indication_bitmap;\nstatic int hf_fp_pdsch_set_id;\nstatic int hf_fp_rx_timing_deviation;\nstatic int hf_fp_dch_e_rucch_flag;\nstatic int hf_fp_dch_control_frame_type;\nstatic int hf_fp_dch_rx_timing_deviation;\nstatic int hf_fp_quality_estimate;\nstatic int hf_fp_payload_crc;\nstatic int hf_fp_payload_crc_status;\nstatic int hf_fp_edch_header_crc;\nstatic int hf_fp_edch_fsn;\nstatic int hf_fp_edch_subframe;\nstatic int hf_fp_edch_number_of_subframes;\nstatic int hf_fp_edch_harq_retransmissions;\nstatic int hf_fp_edch_subframe_number;\nstatic int hf_fp_edch_number_of_mac_es_pdus;\nstatic int hf_fp_edch_ddi;\nstatic int hf_fp_edch_subframe_header;\nstatic int hf_fp_edch_number_of_mac_d_pdus;\nstatic int hf_fp_edch_pdu_padding;\nstatic int hf_fp_edch_tsn;\nstatic int hf_fp_edch_mac_es_pdu;\n\nstatic int hf_fp_edch_user_buffer_size;\nstatic int hf_fp_edch_no_macid_sdus;\nstatic int hf_fp_edch_number_of_mac_is_pdus;\nstatic int hf_fp_edch_mac_is_pdu;\n\nstatic int hf_fp_edch_e_rnti;\nstatic int hf_fp_edch_macis_descriptors;\nstatic int hf_fp_edch_macis_lchid;\nstatic int hf_fp_edch_macis_length;\nstatic int hf_fp_edch_macis_flag;\nstatic int hf_fp_edch_entity;\n\nstatic int hf_fp_frame_seq_nr;\nstatic int hf_fp_hsdsch_pdu_block_header;\n/* static int hf_fp_hsdsch_pdu_block; */\nstatic int hf_fp_flush;\nstatic int hf_fp_fsn_drt_reset;\nstatic int hf_fp_drt_indicator;\nstatic int hf_fp_fach_indicator;\nstatic int hf_fp_total_pdu_blocks;\nstatic int hf_fp_drt;\nstatic int hf_fp_hrnti;\nstatic int hf_fp_rach_measurement_result;\nstatic int hf_fp_lchid;\nstatic int hf_fp_pdu_length_in_block;\nstatic int hf_fp_pdus_in_block;\nstatic int hf_fp_cmch_pi;\nstatic int hf_fp_user_buffer_size;\nstatic int hf_fp_hsdsch_credits;\nstatic int hf_fp_hsdsch_max_macd_pdu_len;\nstatic int hf_fp_hsdsch_max_macdc_pdu_len;\nstatic int hf_fp_hsdsch_interval;\nstatic int hf_fp_hsdsch_calculated_rate;\nstatic int hf_fp_hsdsch_unlimited_rate;\nstatic int hf_fp_hsdsch_repetition_period;\nstatic int hf_fp_hsdsch_data_padding;\nstatic int hf_fp_hsdsch_new_ie_flags;\nstatic int hf_fp_hsdsch_new_ie_flag[8];\nstatic int hf_fp_hsdsch_drt;\nstatic int hf_fp_hsdsch_entity;\nstatic int hf_fp_hsdsch_physical_layer_category;\nstatic int hf_fp_timing_advance;\nstatic int hf_fp_num_of_pdu;\nstatic int hf_fp_mac_d_pdu_len;\nstatic int hf_fp_mac_d_pdu;\nstatic int hf_fp_data;\nstatic int hf_fp_crcis;\nstatic int hf_fp_crci[8];\nstatic int hf_fp_common_control_frame_type;\nstatic int hf_fp_t1;\nstatic int hf_fp_t2;\nstatic int hf_fp_t3;\nstatic int hf_fp_ul_sir_target;\nstatic int hf_fp_pusch_set_id;\nstatic int hf_fp_activation_cfn;\nstatic int hf_fp_duration;\nstatic int hf_fp_power_offset;\nstatic int hf_fp_code_number;\nstatic int hf_fp_spreading_factor;\nstatic int hf_fp_mc_info;\n\nstatic int hf_fp_rach_new_ie_flags;\nstatic int hf_fp_rach_new_ie_flag_unused[7];\nstatic int hf_fp_rach_ext_propagation_delay_present;\nstatic int hf_fp_rach_cell_portion_id_present;\nstatic int hf_fp_rach_angle_of_arrival_present;\nstatic int hf_fp_rach_ext_rx_sync_ul_timing_deviation_present;\nstatic int hf_fp_rach_ext_rx_timing_deviation_present;\n\nstatic int hf_fp_cell_portion_id;\nstatic int hf_fp_ext_propagation_delay;\nstatic int hf_fp_angle_of_arrival;\nstatic int hf_fp_ext_received_sync_ul_timing_deviation;\n\nstatic int hf_fp_radio_interface_parameter_update_flag[5];\nstatic int hf_fp_dpc_mode;\nstatic int hf_fp_tpc_po;\nstatic int hf_fp_multiple_rl_set_indicator;\nstatic int hf_fp_max_ue_tx_pow;\nstatic int hf_fp_congestion_status;\nstatic int hf_fp_e_rucch_present;\nstatic int hf_fp_extended_bits_present;\nstatic int hf_fp_extended_bits;\nstatic int hf_fp_spare_extension;\nstatic int hf_fp_ul_setup_frame;\nstatic int hf_fp_dl_setup_frame;\nstatic int hf_fp_relevant_pi_frame;\n\n/* Subtrees. */\nstatic int ett_fp;\nstatic int ett_fp_release;\nstatic int ett_fp_data;\nstatic int ett_fp_crcis;\nstatic int ett_fp_ddi_config;\nstatic int ett_fp_edch_subframe_header;\nstatic int ett_fp_edch_subframe;\nstatic int ett_fp_edch_maces;\nstatic int ett_fp_edch_macis_descriptors;\nstatic int ett_fp_hsdsch_new_ie_flags;\nstatic int ett_fp_rach_new_ie_flags;\nstatic int ett_fp_hsdsch_pdu_block_header;\nstatic int ett_fp_pch_relevant_pi;\n\nstatic expert_field ei_fp_hsdsch_common_experimental_support;\nstatic expert_field ei_fp_hsdsch_common_t3_not_implemented;\nstatic expert_field ei_fp_channel_type_unknown;\nstatic expert_field ei_fp_ddi_not_defined;\nstatic expert_field ei_fp_stop_hsdpa_transmission;\nstatic expert_field ei_fp_hsdsch_entity_not_specified;\nstatic expert_field ei_fp_expecting_tdd;\nstatic expert_field ei_fp_bad_payload_checksum;\nstatic expert_field ei_fp_e_rnti_t2_edch_frames;\nstatic expert_field ei_fp_crci_no_subdissector;\nstatic expert_field ei_fp_timing_adjustment_reported;\nstatic expert_field ei_fp_mac_is_sdus_miscount;\nstatic expert_field ei_fp_maybe_srb;\nstatic expert_field ei_fp_transport_channel_type_unknown;\nstatic expert_field ei_fp_pch_lost_relevant_pi_frame;\nstatic expert_field ei_fp_unable_to_locate_ddi_entry;\nstatic expert_field ei_fp_e_rnti_first_entry;\nstatic expert_field ei_fp_bad_header_checksum;\nstatic expert_field ei_fp_crci_error_bit_set_for_tb;\nstatic expert_field ei_fp_spare_extension;\nstatic expert_field ei_fp_no_per_frame_info;\nstatic expert_field ei_fp_no_per_conv_channel_info;\nstatic expert_field ei_fp_invalid_frame_count;\n\nstatic dissector_handle_t rlc_bcch_handle;\nstatic dissector_handle_t mac_fdd_dch_handle;\nstatic dissector_handle_t mac_fdd_rach_handle;\nstatic dissector_handle_t mac_fdd_fach_handle;\nstatic dissector_handle_t mac_fdd_pch_handle;\nstatic dissector_handle_t mac_fdd_edch_handle;\nstatic dissector_handle_t mac_fdd_edch_type2_handle;\nstatic dissector_handle_t mac_fdd_hsdsch_handle;\nstatic dissector_handle_t fp_handle;\nstatic dissector_handle_t fp_aal2_handle;\n\n\nstatic proto_tree *top_level_tree;\n\n/* Variables used for preferences */\nstatic bool preferences_call_mac_dissectors = true;\nstatic bool preferences_show_release_info = true;\nstatic bool preferences_payload_checksum = true;\nstatic bool preferences_header_checksum = true;\nstatic bool preferences_track_paging_indications = true;\n\n/* E-DCH (T1) channel header information */\nstruct edch_t1_subframe_info\n{\n    uint8_t subframe_number;\n    uint8_t number_of_mac_es_pdus;\n    uint8_t ddi[64];\n    uint16_t number_of_mac_d_pdus[64];\n};\n\n/* E-DCH (T2) channel header information */\nstruct edch_t2_subframe_info\n{\n    uint8_t subframe_number;\n    uint8_t number_of_mac_is_pdus;\n    uint8_t number_of_mac_is_sdus[16];\n    uint8_t mac_is_lchid[16][16];\n    uint16_t mac_is_length[16][16];\n};\n\n\nstatic const value_string channel_type_vals[] =\n{\n    { CHANNEL_RACH_FDD,         \"RACH_FDD\" },\n    { CHANNEL_RACH_TDD,         \"RACH_TDD\" },\n    { CHANNEL_FACH_FDD,         \"FACH_FDD\" },\n    { CHANNEL_FACH_TDD,         \"FACH_TDD\" },\n    { CHANNEL_DSCH_FDD,         \"DSCH_FDD\" },\n    { CHANNEL_DSCH_TDD,         \"DSCH_TDD\" },\n    { CHANNEL_USCH_TDD_384,     \"USCH_TDD_384\" },\n    { CHANNEL_USCH_TDD_128,     \"USCH_TDD_128\" },\n    { CHANNEL_PCH,              \"PCH\" },\n    { CHANNEL_CPCH,             \"CPCH\" },\n    { CHANNEL_BCH,              \"BCH\" },\n    { CHANNEL_DCH,              \"DCH\" },\n    { CHANNEL_HSDSCH,           \"HSDSCH\" },\n    { CHANNEL_IUR_CPCHF,        \"IUR CPCHF\" },\n    { CHANNEL_IUR_FACH,         \"IUR FACH\" },\n    { CHANNEL_IUR_DSCH,         \"IUR DSCH\" },\n    { CHANNEL_EDCH,             \"EDCH\" },\n    { CHANNEL_RACH_TDD_128,     \"RACH_TDD_128\" },\n    { CHANNEL_HSDSCH_COMMON,    \"HSDSCH-COMMON\" },\n    { CHANNEL_HSDSCH_COMMON_T3, \"HSDSCH-COMMON-T3\" },\n    { CHANNEL_EDCH_COMMON,      \"EDCH-COMMON\"},\n    { 0, NULL }\n};\n\nstatic const value_string division_vals[] =\n{\n    { Division_FDD,      \"FDD\"},\n    { Division_TDD_384,  \"TDD-384\"},\n    { Division_TDD_128,  \"TDD-128\"},\n    { Division_TDD_768,  \"TDD-768\"},\n    { 0, NULL }\n};\n\n/* Frame Type (ft) values */\n#define FT_DATA    0\n#define FT_CONTROL 1\n\nstatic const value_string frame_type_vals[] = {\n    { FT_DATA,      \"Data\" },\n    { FT_CONTROL,   \"Control\" },\n    { 0,   NULL }\n};\n\nstatic const value_string crci_vals[] = {\n    { 0,   \"Correct\" },\n    { 1,   \"Not correct\" },\n    { 0,   NULL }\n};\n\nstatic const value_string paging_indication_vals[] = {\n    { 0,   \"no PI-bitmap in payload\" },\n    { 1,   \"PI-bitmap in payload\" },\n    { 0,   NULL }\n};\n\nstatic const value_string spreading_factor_vals[] = {\n    { 0,   \"4\"},\n    { 1,   \"8\"},\n    { 2,   \"16\"},\n    { 3,   \"32\"},\n    { 4,   \"64\"},\n    { 5,   \"128\"},\n    { 6,   \"256\"},\n    { 0,   NULL }\n};\n\nstatic const value_string congestion_status_vals[] = {\n    { 0,   \"No TNL congestion\"},\n    { 1,   \"Reserved for future use\"},\n    { 2,   \"TNL congestion - detected by delay build-up\"},\n    { 3,   \"TNL congestion - detected by frame loss\"},\n    { 0,   NULL }\n};\n\nstatic const value_string e_rucch_flag_vals[] = {\n    { 0,   \"Conventional E-RUCCH reception\" },\n    { 1,   \"TA Request reception\" },\n    { 0,   NULL }\n};\n\nstatic const value_string hsdshc_mac_entity_vals[] = {\n    { entity_not_specified,    \"Unspecified (assume MAC-hs)\" },\n    { hs,                      \"MAC-hs\" },\n    { ehs,                     \"MAC-ehs\" },\n    { 0,   NULL }\n};\n\nstatic const value_string edch_mac_entity_vals[] = {\n    { 0,                    \"MAC-e/es\" },\n    { 1,                    \"MAC-i/is\" },\n    { 0,   NULL }\n};\n\nstatic const value_string lchid_vals[] = {\n    {  0,   \"Logical Channel 1\" },\n    {  1,   \"Logical Channel 2\" },\n    {  2,   \"Logical Channel 3\" },\n    {  3,   \"Logical Channel 4\" },\n    {  4,   \"Logical Channel 5\" },\n    {  5,   \"Logical Channel 6\" },\n    {  6,   \"Logical Channel 7\" },\n    {  7,   \"Logical Channel 8\" },\n    {  8,   \"Logical Channel 9\" },\n    {  9,   \"Logical Channel 10\" },\n    { 10,   \"Logical Channel 11\" },\n    { 11,   \"Logical Channel 12\" },\n    { 12,   \"Logical Channel 13\" },\n    { 13,   \"Logical Channel 14\" },\n    { 14,   \"CCCH (SRB0)\" },\n    { 15,   \"E-RNTI being included (FDD only)\" },\n    { 0,   NULL }\n};\n\n/* Dedicated control types */\n#define DCH_OUTER_LOOP_POWER_CONTROL            1\n#define DCH_TIMING_ADJUSTMENT                   2\n#define DCH_DL_SYNCHRONISATION                  3\n#define DCH_UL_SYNCHRONISATION                  4\n\n#define DCH_DL_NODE_SYNCHRONISATION             6\n#define DCH_UL_NODE_SYNCHRONISATION             7\n#define DCH_RX_TIMING_DEVIATION                 8\n#define DCH_RADIO_INTERFACE_PARAMETER_UPDATE    9\n#define DCH_TIMING_ADVANCE                     10\n#define DCH_TNL_CONGESTION_INDICATION          11\n\nstatic const value_string dch_control_frame_type_vals[] = {\n    { DCH_OUTER_LOOP_POWER_CONTROL,         \"OUTER LOOP POWER CONTROL\" },\n    { DCH_TIMING_ADJUSTMENT,                \"TIMING ADJUSTMENT\" },\n    { DCH_DL_SYNCHRONISATION,               \"DL SYNCHRONISATION\" },\n    { DCH_UL_SYNCHRONISATION,               \"UL SYNCHRONISATION\" },\n    { 5,                                    \"Reserved Value\" },\n    { DCH_DL_NODE_SYNCHRONISATION,          \"DL NODE SYNCHRONISATION\" },\n    { DCH_UL_NODE_SYNCHRONISATION,          \"UL NODE SYNCHRONISATION\" },\n    { DCH_RX_TIMING_DEVIATION,              \"RX TIMING DEVIATION\" },\n    { DCH_RADIO_INTERFACE_PARAMETER_UPDATE, \"RADIO INTERFACE PARAMETER UPDATE\" },\n    { DCH_TIMING_ADVANCE,                   \"TIMING ADVANCE\" },\n    { DCH_TNL_CONGESTION_INDICATION,        \"TNL CONGESTION INDICATION\" },\n    { 0,   NULL }\n};\n\n\n/* Common channel control types */\n#define COMMON_OUTER_LOOP_POWER_CONTROL                1\n#define COMMON_TIMING_ADJUSTMENT                       2\n#define COMMON_DL_SYNCHRONISATION                      3\n#define COMMON_UL_SYNCHRONISATION                      4\n\n#define COMMON_DL_NODE_SYNCHRONISATION                 6\n#define COMMON_UL_NODE_SYNCHRONISATION                 7\n#define COMMON_DYNAMIC_PUSCH_ASSIGNMENT                8\n#define COMMON_TIMING_ADVANCE                          9\n#define COMMON_HS_DSCH_Capacity_Request               10\n#define COMMON_HS_DSCH_Capacity_Allocation            11\n#define COMMON_HS_DSCH_Capacity_Allocation_Type_2     12\n\nstatic const value_string common_control_frame_type_vals[] = {\n    { COMMON_OUTER_LOOP_POWER_CONTROL,            \"OUTER LOOP POWER CONTROL\" },\n    { COMMON_TIMING_ADJUSTMENT,                   \"TIMING ADJUSTMENT\" },\n    { COMMON_DL_SYNCHRONISATION,                  \"DL SYNCHRONISATION\" },\n    { COMMON_UL_SYNCHRONISATION,                  \"UL SYNCHRONISATION\" },\n    { 5,                                          \"Reserved Value\" },\n    { COMMON_DL_NODE_SYNCHRONISATION,             \"DL NODE SYNCHRONISATION\" },\n    { COMMON_UL_NODE_SYNCHRONISATION,             \"UL NODE SYNCHRONISATION\" },\n    { COMMON_DYNAMIC_PUSCH_ASSIGNMENT,            \"DYNAMIC PUSCH ASSIGNMENT\" },\n    { COMMON_TIMING_ADVANCE,                      \"TIMING ADVANCE\" },\n    { COMMON_HS_DSCH_Capacity_Request,            \"HS-DSCH Capacity Request\" },\n    { COMMON_HS_DSCH_Capacity_Allocation,         \"HS-DSCH Capacity Allocation\" },\n    { COMMON_HS_DSCH_Capacity_Allocation_Type_2,  \"HS-DSCH Capacity Allocation Type 2\" },\n    { 0,   NULL }\n};\n\n/* 0 to 7*/\nstatic const uint8_t hsdsch_macdflow_id_rlc_map[] = {\n    RLC_UM,                   /*0 SRB */\n    RLC_AM,                   /*1 Interactive PS*/\n    RLC_AM,                   /*2 Interactive PS*/\n    RLC_UNKNOWN_MODE,         /*3 ???*/\n    RLC_AM,                   /*4 Streaming PS*/\n    RLC_UNKNOWN_MODE,\n    RLC_UNKNOWN_MODE,\n    RLC_UNKNOWN_MODE\n};\n\n/* Mapping hsdsch MACd-FlowId to MAC_CONTENT, basically flowid = 1 (0) => SRB*/\n/* 1 to 8*/\nstatic const uint8_t hsdsch_macdflow_id_mac_content_map[] = {\n    MAC_CONTENT_DCCH,    /*1 SRB */\n    MAC_CONTENT_PS_DTCH, /*2 Interactive PS*/\n    MAC_CONTENT_PS_DTCH, /*3 Interactive PS*/\n    RLC_UNKNOWN_MODE,    /*4 ???*/\n    MAC_CONTENT_PS_DTCH, /*5 Streaming PS*/\n    RLC_UNKNOWN_MODE,\n    RLC_UNKNOWN_MODE,\n    RLC_UNKNOWN_MODE\n};\n\n/* Make fake logical channel id's based on MACdFlow-ID's,\n* XXXX Bug 12121 expanded the number of entries to 8(+2),\n* not at all sure what the proper value should be 0xfF?\n*/\nstatic const uint8_t fake_lchid_macd_flow[] = {1,9,14,11,0,12,0,0};\n\n/* Dissect message parts */\nstatic int dissect_tb_data(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\n                           int offset, struct fp_info *p_fp_info,\n                           dissector_handle_t *data_handle,\n                           void *data);\n\nstatic int dissect_macd_pdu_data(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\n                                 int offset, uint16_t length, uint16_t number_of_pdus, struct fp_info *p_fp_info,\n                                 void *data);\nstatic int dissect_macd_pdu_data_type_2(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\n                                        int offset, uint16_t length, uint16_t number_of_pdus, struct fp_info * fpi,\n                                        void *data);\n\nstatic int dissect_crci_bits(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\n                             fp_info *p_fp_info, int offset);\nstatic void dissect_spare_extension_and_crc(tvbuff_t *tvb, packet_info *pinfo,\n                                            proto_tree *tree, uint8_t dch_crc_present,\n                                            int offset, unsigned header_length);\n/* Dissect common control messages */\nstatic int dissect_common_outer_loop_power_control(packet_info *pinfo, proto_tree *tree, tvbuff_t *tvb,\n                                                   int offset, struct fp_info *p_fp_info);\nstatic int dissect_common_timing_adjustment(packet_info *pinfo, proto_tree *tree, tvbuff_t *tvb,\n                                            int offset, struct fp_info *p_fp_info);\nstatic int dissect_common_dl_node_synchronisation(packet_info *pinfo, proto_tree *tree,\n                                                  tvbuff_t *tvb, int offset);\nstatic int dissect_common_ul_node_synchronisation(packet_info *pinfo, proto_tree *tree,\n                                                  tvbuff_t *tvb, int offset);\nstatic int dissect_common_dl_synchronisation(packet_info *pinfo, proto_tree *tree,\n                                            tvbuff_t *tvb, int offset,\n                                            struct fp_info *p_fp_info);\nstatic int dissect_common_ul_synchronisation(packet_info *pinfo, proto_tree *tree,\n                                            tvbuff_t *tvb, int offset,\n                                            struct fp_info *p_fp_info);\nstatic int dissect_common_timing_advance(packet_info *pinfo, proto_tree *tree,\n                                         tvbuff_t *tvb, int offset);\nstatic int dissect_hsdpa_capacity_request(packet_info *pinfo, proto_tree *tree,\n                                          tvbuff_t *tvb, int offset);\nstatic int dissect_hsdpa_capacity_allocation(packet_info *pinfo, proto_tree *tree,\n                                             tvbuff_t *tvb, int offset,\n                                             struct fp_info *p_fp_info);\nstatic int dissect_hsdpa_capacity_allocation_type_2(packet_info *pinfo, proto_tree *tree,\n                                                    tvbuff_t *tvb, int offset);\nstatic void dissect_common_control(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\n                                   int offset, struct fp_info *p_fp_info);\nstatic int dissect_common_dynamic_pusch_assignment(packet_info *pinfo, proto_tree *tree,\n                                                   tvbuff_t *tvb, int offset);\n\n/* Dissect common channel types */\nstatic void dissect_rach_channel_info(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\n                                      int offset, struct fp_info *p_fp_info,\n                                      void *data);\nstatic void dissect_fach_channel_info(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\n                                      int offset, struct fp_info *p_fp_info,\n                                      void *data);\nstatic void dissect_dsch_channel_info(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\n                                      int offset, struct fp_info *p_fp_info);\nstatic void dissect_usch_channel_info(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\n                                      int offset, struct fp_info *p_fp_info);\nstatic void dissect_pch_channel_info(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\n                                     int offset, struct fp_info *p_fp_info,\n                                     void *data);\nstatic void dissect_cpch_channel_info(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\n                                      int offset, struct fp_info *p_fp_info);\nstatic void dissect_bch_channel_info(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\n                                     int offset, struct fp_info *p_fp_info);\nstatic void dissect_iur_dsch_channel_info(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\n                                          int offset, struct fp_info *p_fp_info);\nstatic void dissect_hsdsch_channel_info(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\n                                        int offset, struct fp_info *p_fp_info,\n                                        void *data);\nstatic void dissect_hsdsch_type_2_channel_info(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\n                                               int offset, struct fp_info *p_fp_info,\n                                               void *data);\nstatic void dissect_hsdsch_common_channel_info(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\n                                               int offset,\n                                               struct fp_info *p_fp_info,\n                                               void *data);\n\n/* Dissect DCH control messages */\nstatic int dissect_dch_timing_adjustment(proto_tree *tree, packet_info *pinfo,\n                                         tvbuff_t *tvb, int offset);\nstatic int dissect_dch_rx_timing_deviation(packet_info *pinfo, proto_tree *tree, tvbuff_t *tvb, int offset,\n                                           struct fp_info *p_fp_info);\nstatic int dissect_dch_dl_synchronisation(proto_tree *tree, packet_info *pinfo,\n                                          tvbuff_t *tvb, int offset);\nstatic int dissect_dch_ul_synchronisation(proto_tree *tree, packet_info *pinfo,\n                                          tvbuff_t *tvb, int offset);\nstatic int dissect_dch_outer_loop_power_control(proto_tree *tree, packet_info *pinfo,\n                                                tvbuff_t *tvb, int offset);\nstatic int dissect_dch_dl_node_synchronisation(proto_tree *tree, packet_info *pinfo,\n                                               tvbuff_t *tvb, int offset);\nstatic int dissect_dch_ul_node_synchronisation(proto_tree *tree, packet_info *pinfo,\n                                               tvbuff_t *tvb, int offset);\nstatic int dissect_dch_radio_interface_parameter_update(proto_tree *tree, packet_info *pinfo,\n                                                        tvbuff_t *tvb, int offset);\nstatic int dissect_dch_timing_advance(proto_tree *tree, packet_info *pinfo,\n                                      tvbuff_t *tvb, int offset, struct fp_info *p_fp_info);\nstatic int dissect_dch_tnl_congestion_indication(proto_tree *tree, packet_info *pinfo,\n                                                 tvbuff_t *tvb, int offset);\n\n\nstatic void dissect_dch_control_frame(proto_tree *tree, packet_info *pinfo, tvbuff_t *tvb,\n                                      int offset, struct fp_info *p_fp_info);\n\n\n/* Dissect a DCH channel */\nstatic void dissect_dch_channel_info(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\n                                     int offset, struct fp_info *p_fp_info,\n                                     void *data);\n\n/* Dissect dedicated channels */\nstatic void dissect_e_dch_channel_info(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\n                                       int offset, struct fp_info *p_fp_info,\n                                       bool is_common,\n                                       void *data);\n\nstatic void dissect_e_dch_t2_or_common_channel_info(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\n                                                    int offset, struct fp_info *p_fp_info,\n                                                    int number_of_subframes,\n                                                    bool is_common,\n                                                    uint16_t header_crc,\n                                                    proto_item * header_crc_pi,\n                                                    void *data);\n\n/* Main dissection function */\nstatic int dissect_fp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data);\n\n/*\n * CRNC sends data downlink on uplink parameters.\n */\nvoid\nset_umts_fp_conv_data(conversation_t *conversation, umts_fp_conversation_info_t *umts_fp_conversation_info)\n{\n\n    if (conversation == NULL) {\n        return;\n     }\n\n    conversation_add_proto_data(conversation, proto_fp, umts_fp_conversation_info);\n}\n\n\nstatic int\nget_tb_count(struct fp_info *p_fp_info)\n{\n    int chan, tb_count = 0;\n    for (chan = 0; chan < p_fp_info->num_chans; chan++) {\n        tb_count += p_fp_info->chan_num_tbs[chan];\n    }\n    return tb_count;\n}\n\nstatic bool verify_control_frame_crc(tvbuff_t * tvb, packet_info * pinfo, proto_item * pi, uint16_t frame_crc)\n{\n    uint8_t crc = 0;\n    uint8_t * data = NULL;\n    /* Get data. */\n    data = (uint8_t *)tvb_memdup(pinfo->pool, tvb, 0, tvb_reported_length(tvb));\n    /* Include only FT flag bit in CRC calculation. */\n    data[0] = data[0] & 1;\n    /* Calculate crc7 sum. */\n    crc = crc7update(0, data, tvb_reported_length(tvb));\n    crc = crc7finalize(crc); /* finalize crc */\n    if (frame_crc == crc) {\n        proto_item_append_text(pi, \" [correct]\");\n        return true;\n    } else {\n        proto_item_append_text(pi, \" [incorrect, should be 0x%x]\", crc);\n        expert_add_info(pinfo, pi, &ei_fp_bad_header_checksum);\n        return false;\n    }\n}\nstatic bool verify_header_crc(tvbuff_t * tvb, packet_info * pinfo, proto_item * pi, uint16_t header_crc, unsigned header_length)\n{\n    uint8_t crc = 0;\n    uint8_t * data = NULL;\n    /* Get data of header with first byte removed. */\n    data = (uint8_t *)tvb_memdup(pinfo->pool, tvb, 1, header_length-1);\n    /* Calculate crc7 sum. */\n    crc = crc7update(0, data, header_length-1);\n    crc = crc7finalize(crc); /* finalize crc */\n    if (header_crc == crc) {\n        proto_item_append_text(pi, \" [correct]\");\n        return true;\n    } else {\n        proto_item_append_text(pi, \" [incorrect, should be 0x%x]\", crc);\n        expert_add_info(pinfo, pi, &ei_fp_bad_header_checksum);\n        return false;\n    }\n}\nstatic bool verify_header_crc_edch(tvbuff_t * tvb, packet_info * pinfo, proto_item * pi, uint16_t header_crc, unsigned header_length)\n{\n    uint16_t crc = 0;\n    uint8_t * data = NULL;\n    /* First create new subset of header with first byte removed. */\n    tvbuff_t * headtvb = tvb_new_subset_length(tvb, 1, header_length-1);\n    /* Get data of header with first byte removed. */\n    data = (uint8_t *)tvb_memdup(pinfo->pool, headtvb, 0, header_length-1);\n    /* Remove first 4 bits of the remaining data which are Header CRC cont. */\n    data[0] = data[0] & 0x0f;\n    crc = crc11_307_noreflect_noxor(data, header_length-1);\n    if (header_crc == crc) {\n        proto_item_append_text(pi, \" [correct]\");\n        return true;\n    } else {\n        proto_item_append_text(pi, \" [incorrect, should be 0x%x]\", crc);\n        expert_add_info(pinfo, pi, &ei_fp_bad_header_checksum);\n        return false;\n    }\n}\n\n/* Dissect the TBs of a UL data frame*/\nstatic int\ndissect_tb_data(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\n                int offset, struct fp_info *p_fp_info,\n                dissector_handle_t *data_handle, void *data)\n{\n    int         chan, num_tbs   = 0;\n    int         bit_offset      = 0;\n    int         crci_bit_offset = (offset+1)<<3; /* Current offset + Quality estimate of 1 byte at the end*/\n    unsigned    data_bits       = 0;\n    uint8_t     crci_bit        = 0;\n    proto_item *tree_ti         = NULL;\n    proto_tree *data_tree       = NULL;\n    bool        dissected       = false;\n\n    /* Add data subtree */\n    tree_ti =  proto_tree_add_item(tree, hf_fp_data, tvb, offset, -1, ENC_NA);\n    proto_item_set_text(tree_ti, \"TB data for %u chans\", p_fp_info->num_chans);\n    data_tree = proto_item_add_subtree(tree_ti, ett_fp_data);\n\n    if (p_fp_info->num_chans >= MAX_MAC_FRAMES) {\n        expert_add_info_format(pinfo, data_tree, &ei_fp_invalid_frame_count, \"Invalid Number of channels (max is %u)\", MAX_MAC_FRAMES);\n        return offset;\n    }\n\n    /* Calculate offset to CRCI bits */\n\n    if (p_fp_info->is_uplink) {\n        for (chan=0; chan < p_fp_info->num_chans; chan++) {\n            int n;\n            for (n=0; n < p_fp_info->chan_num_tbs[chan]; n++) {\n                /* Advance bit offset */\n                crci_bit_offset += p_fp_info->chan_tf_size[chan];\n                /* Pad out to next byte */\n                crci_bit_offset = WS_ROUNDUP_8(crci_bit_offset);\n            }\n        }\n    }\n    /* Now for the TB data */\n    for (chan=0; chan < p_fp_info->num_chans; chan++) {\n        int n;\n        p_fp_info->cur_chan = chan;    /*Set current channel?*/\n        /* Clearly show channels with no TBs */\n        if (p_fp_info->chan_num_tbs[chan] == 0) {\n            proto_item *no_tb_ti = proto_tree_add_uint(data_tree, hf_fp_chan_zero_tbs, tvb,\n                                                       offset+(bit_offset/8),\n                                                       0, chan+1);\n            proto_item_append_text(no_tb_ti, \" (of size %d)\",\n                                   p_fp_info->chan_tf_size[chan]);\n            proto_item_set_generated(no_tb_ti);\n        }\n\n        /* Show TBs from non-empty channels */\n        for (n=0; n < p_fp_info->chan_num_tbs[chan]; n++) {\n\n            proto_item *ti;\n            p_fp_info->cur_tb = chan;    /*Set current transport block?*/\n            if (data_tree) {\n                ti = proto_tree_add_item(data_tree, hf_fp_tb, tvb,\n                                         offset + (bit_offset/8),\n                                         ((bit_offset % 8) + p_fp_info->chan_tf_size[chan] + 7) / 8,\n                                         ENC_NA);\n                proto_item_set_text(ti, \"TB (chan %u, tb %u, %u bits)\",\n                                    chan+1, n+1, p_fp_info->chan_tf_size[chan]);\n            }\n\n            if (preferences_call_mac_dissectors && data_handle &&\n                (p_fp_info->chan_tf_size[chan] > 0)) {\n                tvbuff_t *next_tvb;\n                proto_item *item;\n                /* If this is DL we should not care about crci bits (since they don't exists)*/\n                if (p_fp_info->is_uplink) {\n\n\n                    if ( p_fp_info->channel == CHANNEL_RACH_FDD) {    /*In RACH we don't have any QE field, hence go back 8 bits.*/\n                        crci_bit = tvb_get_bits8(tvb, crci_bit_offset+n-8, 1);\n                        item = proto_tree_add_item(data_tree, hf_fp_crci[n%8], tvb, (crci_bit_offset+n-8)/8, 1, ENC_BIG_ENDIAN);\n                        proto_item_set_generated(item);\n                    } else {\n                        crci_bit = tvb_get_bits8(tvb, crci_bit_offset+n, 1);\n                        item = proto_tree_add_item(data_tree, hf_fp_crci[n%8], tvb, (crci_bit_offset+n)/8, 1, ENC_BIG_ENDIAN);\n                        proto_item_set_generated(item);\n                    }\n                }\n\n                if (crci_bit == 0 || !p_fp_info->is_uplink) {\n                    next_tvb = tvb_new_subset_length(tvb, offset + bit_offset/8,\n                                              ((bit_offset % 8) + p_fp_info->chan_tf_size[chan] + 7) / 8);\n\n\n                    /****************/\n                    /* TODO: maybe this decision can be based only on info available in fp_info */\n                    call_dissector_with_data(*data_handle, next_tvb, pinfo, top_level_tree, data);\n                    dissected = true;\n                } else {\n                    proto_tree_add_expert(tree, pinfo, &ei_fp_crci_no_subdissector, tvb, offset + bit_offset/8,\n                                               ((bit_offset % 8) + p_fp_info->chan_tf_size[chan] + 7) / 8);\n                }\n\n            }\n            num_tbs++;\n\n            /* Advance bit offset */\n            bit_offset += p_fp_info->chan_tf_size[chan];\n            data_bits  += p_fp_info->chan_tf_size[chan];\n\n            /* Pad out to next byte */\n            bit_offset = WS_ROUNDUP_8(bit_offset);\n        }\n    }\n\n    if (dissected == false) {\n        col_append_fstr(pinfo->cinfo, COL_INFO, \"(%u bits in %u tbs)\",\n                        data_bits, num_tbs);\n    }\n\n    /* Data tree should cover entire length */\n    if (data_tree) {\n        proto_item_set_len(tree_ti, bit_offset/8);\n        proto_item_append_text(tree_ti, \" (%u bits in %u tbs)\", data_bits, num_tbs);\n    }\n\n    /* Move offset past TBs (we know it's already padded out to next byte) */\n    offset += (bit_offset / 8);\n\n    return offset;\n}\n\n\n/* Dissect the MAC-d PDUs of an HS-DSCH (type 1) frame.\n   Length is in bits, and payload is offset by 4 bits of padding */\nstatic int\ndissect_macd_pdu_data(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\n                      int offset, uint16_t length, uint16_t number_of_pdus,\n                      struct fp_info *p_fp_info, void *data)\n{\n    int         pdu;\n    int         bit_offset = 0;\n    proto_item *pdus_ti    = NULL;\n    proto_tree *data_tree  = NULL;\n    bool        dissected  = false;\n\n    /* Add data subtree */\n    pdus_ti =  proto_tree_add_item(tree, hf_fp_data, tvb, offset, -1, ENC_NA);\n    proto_item_set_text(pdus_ti, \"%u MAC-d PDUs of %u bits\", number_of_pdus, length);\n    data_tree = proto_item_add_subtree(pdus_ti, ett_fp_data);\n    if (number_of_pdus >= MAX_MAC_FRAMES) {\n        expert_add_info_format(pinfo, data_tree, &ei_fp_invalid_frame_count, \"Invalid number_of_pdus (max is %u)\", MAX_MAC_FRAMES);\n        return offset;\n    }\n\n    /* Now for the PDUs */\n    for (pdu=0; pdu < number_of_pdus; pdu++) {\n        proto_item *pdu_ti;\n\n        if (data_tree) {\n            /* Show 4 bits padding at start of PDU */\n            proto_tree_add_item(data_tree, hf_fp_hsdsch_data_padding, tvb, offset+(bit_offset/8), 1, ENC_BIG_ENDIAN);\n\n        }\n        bit_offset += 4;\n\n        /* Data bytes! */\n        if (data_tree) {\n            pdu_ti = proto_tree_add_item(data_tree, hf_fp_mac_d_pdu, tvb,\n                                         offset + (bit_offset/8),\n                                         ((bit_offset % 8) + length + 7) / 8,\n                                         ENC_NA);\n            proto_item_set_text(pdu_ti, \"MAC-d PDU (PDU %u)\", pdu+1);\n        }\n\n        p_fp_info->cur_tb = pdu;    /*Set TB (PDU) index correctly*/\n        if (preferences_call_mac_dissectors) {\n            tvbuff_t *next_tvb;\n            next_tvb = tvb_new_subset_length_caplen(tvb, offset + bit_offset/8,\n                                      ((bit_offset % 8) + length + 7)/8, -1);\n            call_dissector_with_data(mac_fdd_hsdsch_handle, next_tvb, pinfo, top_level_tree, data);\n            dissected = true;\n        }\n\n        /* Advance bit offset */\n        bit_offset += length;\n\n        /* Pad out to next byte */\n        bit_offset = WS_ROUNDUP_8(bit_offset);\n    }\n\n    /* Data tree should cover entire length */\n    proto_item_set_len(pdus_ti, bit_offset/8);\n\n    /* Move offset past PDUs (we know it's already padded out to next byte) */\n    offset += (bit_offset / 8);\n\n    /* Show summary in info column */\n    if (dissected == false) {\n        col_append_fstr(pinfo->cinfo, COL_INFO, \"   %u PDUs of %u bits\",\n                        number_of_pdus, length);\n    }\n\n    return offset;\n}\n\n\n/* Dissect the MAC-d PDUs of an HS-DSCH (type 2) frame.\n   Length is in bytes, and payload is byte-aligned (no padding) */\nstatic int\ndissect_macd_pdu_data_type_2(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\n                             int offset, uint16_t length, uint16_t number_of_pdus,\n                             struct fp_info *fpi, void *data)\n{\n    int         pdu;\n    proto_item *pdus_ti      = NULL;\n    proto_tree *data_tree    = NULL;\n    int         first_offset = offset;\n    bool        dissected    = false;\n\n    /* Add data subtree */\n    pdus_ti =  proto_tree_add_item(tree, hf_fp_data, tvb, offset, -1, ENC_NA);\n    proto_item_set_text(pdus_ti, \"%u MAC-d PDUs of %u bytes\", number_of_pdus, length);\n    data_tree = proto_item_add_subtree(pdus_ti, ett_fp_data);\n\n    if (number_of_pdus >= MAX_MAC_FRAMES) {\n        expert_add_info_format(pinfo, data_tree, &ei_fp_invalid_frame_count, \"Invalid number_of_pdus (max is %u)\", MAX_MAC_FRAMES);\n        return offset;\n    }\n\n    /* Now for the PDUs */\n    for (pdu=0; pdu < number_of_pdus; pdu++) {\n        proto_item *pdu_ti;\n\n        /* Data bytes! */\n        if (data_tree) {\n            pdu_ti = proto_tree_add_item(data_tree, hf_fp_mac_d_pdu, tvb,\n                                         offset, length, ENC_NA);\n            proto_item_set_text(pdu_ti, \"MAC-d PDU (PDU %u)\", pdu+1);\n\n        }\n\n        if (preferences_call_mac_dissectors) {\n\n            tvbuff_t *next_tvb = tvb_new_subset_length(tvb, offset, length);\n\n            fpi->cur_tb = pdu;    /*Set proper pdu index for MAC and higher layers*/\n            call_dissector_with_data(mac_fdd_hsdsch_handle, next_tvb, pinfo, top_level_tree, data);\n            dissected = true;\n        }\n\n        /* Advance offset */\n        offset += length;\n    }\n\n    /* Data tree should cover entire length */\n    proto_item_set_len(pdus_ti, offset-first_offset);\n\n    /* Show summary in info column */\n    if (!dissected) {\n        col_append_fstr(pinfo->cinfo, COL_INFO, \"   %u PDUs of %u bits\",\n                        number_of_pdus, length*8);\n    }\n\n    return offset;\n}\n\n/* Dissect CRCI bits (uplink) */\nstatic int\ndissect_crci_bits(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\n                  fp_info *p_fp_info, int offset)\n{\n    int         n, num_tbs;\n    proto_item *ti         = NULL;\n    proto_tree *crcis_tree = NULL;\n    unsigned    errors     = 0;\n\n    num_tbs = get_tb_count(p_fp_info);\n\n\n    /* Add CRCIs subtree */\n    if (tree) {\n        ti =  proto_tree_add_item(tree, hf_fp_crcis, tvb, offset, (num_tbs+7)/8, ENC_NA);\n        proto_item_set_text(ti, \"CRCI bits for %u tbs\", num_tbs);\n        crcis_tree = proto_item_add_subtree(ti, ett_fp_crcis);\n    }\n\n    /* CRCIs */\n    for (n=0; n < num_tbs; n++) {\n        int bit = (tvb_get_uint8(tvb, offset+(n/8)) >> (7-(n%8))) & 0x01;\n        proto_tree_add_item(crcis_tree, hf_fp_crci[n%8], tvb, offset+(n/8),\n                            1, ENC_BIG_ENDIAN);\n\n        if (bit == 1) {\n            errors++;\n            expert_add_info(pinfo, ti, &ei_fp_crci_error_bit_set_for_tb);\n        }\n    }\n\n    if (tree) {\n        /* Highlight range of bytes covered by indicator bits */\n        proto_item_set_len(ti, (num_tbs+7) / 8);\n\n        /* Show error count in root text */\n        proto_item_append_text(ti, \" (%u errors)\", errors);\n    }\n\n    offset += ((num_tbs+7) / 8);\n    return offset;\n}\n\n\nstatic void\ndissect_spare_extension_and_crc(tvbuff_t *tvb, packet_info *pinfo,\n                                proto_tree *tree, uint8_t dch_crc_present,\n                                int offset, unsigned header_length)\n{\n    int         crc_size = 0;\n    int         remain   = tvb_reported_length_remaining(tvb, offset);\n\n    /* Payload CRC (optional) */\n    if ((dch_crc_present == 1) || ((dch_crc_present == 2) && (remain >= 2))) {\n        crc_size = 2;\n    }\n\n    if (remain > crc_size) {\n        proto_item *ti;\n        ti = proto_tree_add_item(tree, hf_fp_spare_extension, tvb,\n                                 offset, remain-crc_size, ENC_NA);\n        proto_item_append_text(ti, \" (%u octets)\", remain-crc_size);\n        expert_add_info_format(pinfo, ti, &ei_fp_spare_extension, \"Spare Extension present (%u bytes)\", remain-crc_size);\n        offset += remain-crc_size;\n    }\n\n    if (crc_size) {\n        unsigned flags = PROTO_CHECKSUM_NO_FLAGS;\n        uint16_t calc_crc = 0;\n        if (preferences_payload_checksum) {\n            flags = PROTO_CHECKSUM_VERIFY;\n            if ((unsigned)offset > header_length) {\n                uint8_t * data = (uint8_t *)tvb_memdup(pinfo->pool, tvb, header_length, offset-header_length);\n                calc_crc = crc16_8005_noreflect_noxor(data, offset-header_length);\n            }\n        }\n        if ((unsigned)offset == header_length && remain == 0) {\n            /* 3GPP TS 25.427 and TS 25.435: \"The Payload CRC IE may\n             * only be present if the frame contains payload\" (even\n             * if defined as present at the setup of the transport bearer.)\n             * If there's room for the CRC and no payload, assume zero,\n             * otherwise, assume it's absent.\n             */\n            flags = PROTO_CHECKSUM_NOT_PRESENT;\n        }\n        proto_tree_add_checksum(tree, tvb, offset,\n                hf_fp_payload_crc, hf_fp_payload_crc_status,\n                &ei_fp_bad_payload_checksum, pinfo, calc_crc,\n                ENC_BIG_ENDIAN, flags);\n    }\n}\n\n/***********************************************************/\n/* Common control message types                            */\n\nstatic int\ndissect_common_outer_loop_power_control(packet_info *pinfo, proto_tree *tree, tvbuff_t *tvb,\n                                        int offset, struct fp_info *p_fp_info _U_)\n{\n    return dissect_dch_outer_loop_power_control(tree, pinfo, tvb, offset);\n}\n\n\nstatic int\ndissect_common_timing_adjustment(packet_info *pinfo, proto_tree *tree, tvbuff_t *tvb,\n                                 int offset, struct fp_info *p_fp_info)\n{\n    int32_t toa;\n    proto_item *toa_ti;\n\n    if (p_fp_info->channel != CHANNEL_PCH) {\n        uint32_t cfn;\n\n        /* CFN control */\n        proto_tree_add_item_ret_uint(tree, hf_fp_cfn_control, tvb, offset, 1, ENC_BIG_ENDIAN, &cfn);\n        offset++;\n\n        /* ToA */\n        toa = tvb_get_ntohis(tvb, offset);\n        toa_ti = proto_tree_add_item(tree, hf_fp_toa, tvb, offset, 2, ENC_BIG_ENDIAN);\n        offset += 2;\n\n        col_append_fstr(pinfo->cinfo, COL_INFO, \"   CFN=%u, ToA=%d\", cfn, toa);\n    }\n    else {\n        uint32_t cfn;\n\n        /* PCH CFN is 12 bits */\n        proto_tree_add_item_ret_uint(tree, hf_fp_pch_cfn, tvb, offset, 2, ENC_BIG_ENDIAN, &cfn);\n        offset += 2;\n\n        /* 4 bits of padding follow... */\n\n        /* 20 bits of ToA (followed by 4 padding bits) */\n        toa = ((int)(tvb_get_ntoh24(tvb, offset) << 8)) / 4096;\n        toa_ti = proto_tree_add_int(tree, hf_fp_pch_toa, tvb, offset, 3, toa);\n        offset += 3;\n\n        col_append_fstr(pinfo->cinfo, COL_INFO, \"   CFN=%u, ToA=%d\", cfn, toa);\n    }\n\n    expert_add_info_format(pinfo, toa_ti, &ei_fp_timing_adjustment_reported, \"Timing adjustment reported (%.3f ms)\", ((float)(toa) / 8));\n\n    return offset;\n}\n\nstatic int\ndissect_common_dl_node_synchronisation(packet_info *pinfo, proto_tree *tree,\n                                       tvbuff_t *tvb, int offset)\n{\n    /* T1 (3 bytes) */\n    uint32_t encoded = tvb_get_ntoh24(tvb, offset);\n    float t1 = encoded * (float)0.125;\n    proto_tree_add_float_format_value(tree, hf_fp_t1, tvb, offset, 3, t1, \"%.3f ms (%u)\", t1, encoded);\n    offset += 3;\n\n    col_append_fstr(pinfo->cinfo, COL_INFO, \"   T1=%.3f\", t1);\n\n    return offset;\n}\n\nstatic int\ndissect_common_ul_node_synchronisation(packet_info *pinfo, proto_tree *tree,\n                                       tvbuff_t *tvb, int offset)\n{\n    uint32_t encoded;\n    float t1, t2, t3;\n\n    /* T1 (3 bytes) */\n    encoded = tvb_get_ntoh24(tvb, offset);\n    t1 = encoded * (float)0.125;\n    proto_tree_add_float_format_value(tree, hf_fp_t1, tvb, offset, 3, t1, \"%.3f ms (%u)\", t1, encoded);\n    offset += 3;\n\n    /* T2 (3 bytes) */\n    encoded = tvb_get_ntoh24(tvb, offset);\n    t2 = encoded * (float)0.125;\n    proto_tree_add_float_format_value(tree, hf_fp_t2, tvb, offset, 3, t2, \"%.3f ms (%u)\", t2, encoded);\n    offset += 3;\n\n    /* T3 (3 bytes) */\n    encoded = tvb_get_ntoh24(tvb, offset);\n    t3 = encoded * (float)0.125;\n    proto_tree_add_float_format_value(tree, hf_fp_t3, tvb, offset, 3, t3, \"%.3f ms (%u)\", t3, encoded);\n    offset += 3;\n\n    col_append_fstr(pinfo->cinfo, COL_INFO, \"   T1=%.3f T2=%.3f, T3=%.3f\",\n                    t1, t2, t3);\n\n    return offset;\n}\n\nstatic int\ndissect_common_dl_synchronisation(packet_info *pinfo, proto_tree *tree,\n                                  tvbuff_t *tvb, int offset, struct fp_info *p_fp_info)\n{\n    uint32_t cfn;\n\n    if (p_fp_info->channel != CHANNEL_PCH) {\n        /* CFN control */\n        proto_tree_add_item_ret_uint(tree, hf_fp_cfn_control, tvb, offset, 1, ENC_BIG_ENDIAN, &cfn);\n        offset++;\n    }\n    else {\n        /* PCH CFN is 12 bits */\n        proto_tree_add_item_ret_uint(tree, hf_fp_pch_cfn, tvb, offset, 2, ENC_BIG_ENDIAN, &cfn);\n\n        /* 4 bits of padding follow... */\n        offset += 2;\n    }\n\n    col_append_fstr(pinfo->cinfo, COL_INFO, \"   CFN=%u\", cfn);\n\n    return offset;\n}\n\nstatic int\ndissect_common_ul_synchronisation(packet_info *pinfo, proto_tree *tree,\n                                  tvbuff_t *tvb, int offset, struct fp_info *p_fp_info)\n{\n    return dissect_common_timing_adjustment(pinfo, tree, tvb, offset, p_fp_info);\n}\n\nstatic int\ndissect_common_timing_advance(packet_info *pinfo, proto_tree *tree, tvbuff_t *tvb, int offset)\n{\n    uint32_t cfn;\n    uint16_t timing_advance;\n\n    /* CFN control */\n    proto_tree_add_item_ret_uint(tree, hf_fp_cfn_control, tvb, offset, 1, ENC_BIG_ENDIAN, &cfn);\n    offset++;\n\n    /* Timing Advance */\n    timing_advance = (tvb_get_uint8(tvb, offset) & 0x3f) * 4;\n    proto_tree_add_uint(tree, hf_fp_timing_advance, tvb, offset, 1, timing_advance);\n    offset++;\n\n    col_append_fstr(pinfo->cinfo, COL_INFO, \" CFN = %u, TA = %u\",\n                    cfn, timing_advance);\n\n    return offset;\n}\n\nstatic int\ndissect_hsdpa_capacity_request(packet_info *pinfo, proto_tree *tree,\n                               tvbuff_t *tvb, int offset)\n{\n    uint8_t priority;\n    uint16_t user_buffer_size;\n\n    /* CmCH-PI */\n    priority = (tvb_get_uint8(tvb, offset) & 0x0f);\n    proto_tree_add_item(tree, hf_fp_cmch_pi, tvb, offset, 1, ENC_BIG_ENDIAN);\n    offset++;\n\n    /* User buffer size */\n    user_buffer_size = tvb_get_ntohs(tvb, offset);\n    proto_tree_add_item(tree, hf_fp_user_buffer_size, tvb, offset, 2, ENC_BIG_ENDIAN);\n    offset += 2;\n\n    col_append_fstr(pinfo->cinfo, COL_INFO, \"      CmCH-PI=%u  User-Buffer-Size=%u\",\n                    priority, user_buffer_size);\n\n    return offset;\n}\n\nstatic int\ndissect_hsdpa_capacity_allocation(packet_info *pinfo, proto_tree *tree,\n                                  tvbuff_t *tvb, int offset,\n                                  struct fp_info *p_fp_info)\n{\n    proto_item *ti;\n    proto_item *rate_ti;\n    uint16_t    max_pdu_length;\n    uint8_t     repetition_period;\n    uint8_t     interval;\n    uint64_t    credits;\n\n    /* Congestion status (introduced sometime during R6...) */\n    if ((p_fp_info->release == 6) || (p_fp_info->release == 7)) {\n        proto_tree_add_bits_item(tree, hf_fp_congestion_status, tvb,\n                                 offset*8 + 2, 2, ENC_BIG_ENDIAN);\n    }\n\n    /* CmCH-PI */\n    proto_tree_add_item(tree, hf_fp_cmch_pi, tvb, offset, 1, ENC_BIG_ENDIAN);\n    offset++;\n\n    /* Max MAC-d PDU length (13 bits) */\n    max_pdu_length = tvb_get_ntohs(tvb, offset) >> 3;\n    proto_tree_add_item(tree, hf_fp_hsdsch_max_macd_pdu_len, tvb, offset, 2, ENC_BIG_ENDIAN);\n    offset++;\n\n    /* HS-DSCH credits (11 bits) */\n    ti = proto_tree_add_bits_ret_val(tree, hf_fp_hsdsch_credits, tvb,\n                                     offset*8 + 5, 11, &credits, ENC_BIG_ENDIAN);\n    offset += 2;\n\n    /* Interesting values */\n    if (credits == 0) {\n        proto_item_append_text(ti, \" (stop transmission)\");\n        expert_add_info(pinfo, ti, &ei_fp_stop_hsdpa_transmission);\n    }\n    if (credits == 2047) {\n        proto_item_append_text(ti, \" (unlimited)\");\n    }\n\n    /* HS-DSCH Interval */\n    interval = tvb_get_uint8(tvb, offset);\n    ti = proto_tree_add_uint(tree, hf_fp_hsdsch_interval, tvb, offset, 1, interval*10);\n    offset++;\n    if (interval == 0) {\n        proto_item_append_text(ti, \" (none of the credits shall be used)\");\n    }\n\n    /* HS-DSCH Repetition period */\n    repetition_period = tvb_get_uint8(tvb, offset);\n    ti = proto_tree_add_item(tree, hf_fp_hsdsch_repetition_period, tvb, offset, 1, ENC_BIG_ENDIAN);\n    offset++;\n    if (repetition_period == 0) {\n        proto_item_append_text(ti, \" (unlimited repetition period)\");\n    }\n\n    /* Calculated and show effective rate enabled */\n    if (credits == 2047) {\n        rate_ti = proto_tree_add_item(tree, hf_fp_hsdsch_unlimited_rate, tvb, 0, 0, ENC_NA);\n        proto_item_set_generated(rate_ti);\n    }\n    else {\n        if (interval != 0) {\n            /* Cast on credits is safe, since we know it won't exceed 10^11 */\n            rate_ti = proto_tree_add_uint(tree, hf_fp_hsdsch_calculated_rate, tvb, 0, 0,\n                                          (uint16_t)credits * max_pdu_length * (1000 / (interval*10)));\n            proto_item_set_generated(rate_ti);\n        }\n    }\n\n    col_append_fstr(pinfo->cinfo, COL_INFO,\n                    \"   Max-PDU-len=%u  Credits=%u  Interval=%u  Rep-Period=%u\",\n                    max_pdu_length, (uint16_t)credits, interval, repetition_period);\n\n    return offset;\n}\n\nstatic int\ndissect_hsdpa_capacity_allocation_type_2(packet_info *pinfo, proto_tree *tree,\n                                         tvbuff_t *tvb, int offset)\n{\n    proto_item *ti;\n    proto_item *rate_ti;\n    uint16_t    max_pdu_length;\n    uint8_t     repetition_period;\n    uint8_t     interval;\n    uint16_t    credits;\n\n    /* Congestion status */\n    proto_tree_add_bits_item(tree, hf_fp_congestion_status, tvb,\n                            offset*8 + 2, 2, ENC_BIG_ENDIAN);\n\n    /* CmCH-PI */\n    proto_tree_add_item(tree, hf_fp_cmch_pi, tvb, offset, 1, ENC_BIG_ENDIAN);\n    offset++;\n\n    /* 5 spare bits follow here */\n\n    /* Max MAC-d/c PDU length (11 bits) */\n    max_pdu_length = tvb_get_ntohs(tvb, offset) & 0x7ff;\n    proto_tree_add_item(tree, hf_fp_hsdsch_max_macdc_pdu_len, tvb, offset, 2, ENC_BIG_ENDIAN);\n    offset += 2;\n\n    /* HS-DSCH credits (16 bits) */\n    credits = (tvb_get_ntohs(tvb, offset));\n    ti = proto_tree_add_uint(tree, hf_fp_hsdsch_credits, tvb,\n                             offset, 2, credits);\n    offset += 2;\n\n    /* Interesting values */\n    if (credits == 0) {\n        proto_item_append_text(ti, \" (stop transmission)\");\n        expert_add_info(pinfo, ti, &ei_fp_stop_hsdpa_transmission);\n    }\n    if (credits == 65535) {\n        proto_item_append_text(ti, \" (unlimited)\");\n    }\n\n    /* HS-DSCH Interval */\n    interval = tvb_get_uint8(tvb, offset);\n    ti = proto_tree_add_uint(tree, hf_fp_hsdsch_interval, tvb, offset, 1, interval*10);\n    offset++;\n    if (interval == 0) {\n        proto_item_append_text(ti, \" (none of the credits shall be used)\");\n    }\n\n    /* HS-DSCH Repetition period */\n    repetition_period = tvb_get_uint8(tvb, offset);\n    ti = proto_tree_add_item(tree, hf_fp_hsdsch_repetition_period, tvb, offset, 1, ENC_BIG_ENDIAN);\n    offset++;\n    if (repetition_period == 0) {\n        proto_item_append_text(ti, \" (unlimited repetition period)\");\n    }\n\n    /* Calculated and show effective rate enabled */\n    if (credits == 65535) {\n        rate_ti = proto_tree_add_item(tree, hf_fp_hsdsch_unlimited_rate, tvb, 0, 0, ENC_NA);\n        proto_item_set_generated(rate_ti);\n    }\n    else {\n        if (interval != 0) {\n            rate_ti = proto_tree_add_uint(tree, hf_fp_hsdsch_calculated_rate, tvb, 0, 0,\n                                          credits * max_pdu_length * (1000 / (interval*10)));\n            proto_item_set_generated(rate_ti);\n        }\n    }\n\n    col_append_fstr(pinfo->cinfo, COL_INFO,\n                    \"   Max-PDU-len=%u  Credits=%u  Interval=%u  Rep-Period=%u\",\n                    max_pdu_length, credits, interval, repetition_period);\n\n    return offset;\n}\n\n\n\nstatic int\ndissect_common_dynamic_pusch_assignment(packet_info *pinfo, proto_tree *tree,\n                                        tvbuff_t *tvb, int offset)\n{\n    uint8_t pusch_set_id;\n    uint8_t activation_cfn;\n    uint8_t duration;\n\n    /* PUSCH Set Id */\n    pusch_set_id = tvb_get_uint8(tvb, offset);\n    proto_tree_add_item(tree, hf_fp_pusch_set_id, tvb, offset, 1, ENC_BIG_ENDIAN);\n    offset++;\n\n    /* Activation CFN */\n    activation_cfn = tvb_get_uint8(tvb, offset);\n    proto_tree_add_item(tree, hf_fp_activation_cfn, tvb, offset, 1, ENC_BIG_ENDIAN);\n    offset++;\n\n    /* Duration */\n    duration = tvb_get_uint8(tvb, offset) * 10;\n    proto_tree_add_uint(tree, hf_fp_duration, tvb, offset, 1, duration);\n    offset++;\n\n    col_append_fstr(pinfo->cinfo, COL_INFO,\n                    \"   PUSCH Set Id=%u  Activation CFN=%u  Duration=%u\",\n                    pusch_set_id, activation_cfn, duration);\n\n    return offset;\n}\n\n\n\n\n\n/* Dissect the control part of a common channel message */\nstatic void\ndissect_common_control(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\n                       int offset, struct fp_info *p_fp_info)\n{\n    /* Common control frame type */\n    uint8_t control_frame_type = tvb_get_uint8(tvb, offset);\n    proto_tree_add_item(tree, hf_fp_common_control_frame_type, tvb, offset, 1, ENC_BIG_ENDIAN);\n    offset++;\n\n    col_append_str(pinfo->cinfo, COL_INFO,\n                   val_to_str_const(control_frame_type, common_control_frame_type_vals, \"Unknown\"));\n\n    /* Frame-type specific dissection */\n    switch (control_frame_type) {\n        case COMMON_OUTER_LOOP_POWER_CONTROL:\n            /*offset =*/ dissect_common_outer_loop_power_control(pinfo, tree, tvb, offset, p_fp_info);\n            break;\n        case COMMON_TIMING_ADJUSTMENT:\n            /*offset =*/ dissect_common_timing_adjustment(pinfo, tree, tvb, offset, p_fp_info);\n            break;\n        case COMMON_DL_SYNCHRONISATION:\n            /*offset =*/ dissect_common_dl_synchronisation(pinfo, tree, tvb, offset, p_fp_info);\n            break;\n        case COMMON_UL_SYNCHRONISATION:\n            /*offset =*/ dissect_common_ul_synchronisation(pinfo, tree, tvb, offset, p_fp_info);\n            break;\n        case COMMON_DL_NODE_SYNCHRONISATION:\n            /*offset =*/ dissect_common_dl_node_synchronisation(pinfo, tree, tvb, offset);\n            break;\n        case COMMON_UL_NODE_SYNCHRONISATION:\n            /*offset =*/ dissect_common_ul_node_synchronisation(pinfo, tree, tvb, offset);\n            break;\n        case COMMON_DYNAMIC_PUSCH_ASSIGNMENT:\n            /*offset =*/ dissect_common_dynamic_pusch_assignment(pinfo, tree, tvb, offset);\n            break;\n        case COMMON_TIMING_ADVANCE:\n            /*offset =*/ dissect_common_timing_advance(pinfo, tree, tvb, offset);\n            break;\n        case COMMON_HS_DSCH_Capacity_Request:\n            /*offset =*/ dissect_hsdpa_capacity_request(pinfo, tree, tvb, offset);\n            break;\n        case COMMON_HS_DSCH_Capacity_Allocation:\n            /*offset =*/ dissect_hsdpa_capacity_allocation(pinfo, tree, tvb, offset, p_fp_info);\n            break;\n        case COMMON_HS_DSCH_Capacity_Allocation_Type_2:\n            /*offset =*/ dissect_hsdpa_capacity_allocation_type_2(pinfo, tree, tvb, offset);\n            break;\n\n        default:\n            break;\n    }\n\n     /* There is no Spare Extension nor payload crc in common control!? */\n   /* dissect_spare_extension_and_crc(tvb, pinfo, tree, 0, offset);\n    */\n}\n\n\n\n/**************************/\n/* Dissect a RACH channel */\nstatic void\ndissect_rach_channel_info(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\n                          int offset, struct fp_info *p_fp_info, void *data)\n{\n    uint32_t ft;\n    uint32_t header_crc = 0;\n    proto_item * header_crc_pi = NULL;\n    unsigned header_length;\n\n    /* Header CRC */\n    header_crc_pi = proto_tree_add_item_ret_uint(tree, hf_fp_header_crc, tvb, offset, 1, ENC_BIG_ENDIAN, &header_crc);\n\n    /* Frame Type */\n    proto_tree_add_item_ret_uint(tree, hf_fp_ft, tvb, offset, 1, ENC_BIG_ENDIAN, &ft);\n    offset++;\n\n    col_append_fstr(pinfo->cinfo, COL_INFO, \" [%s] \", val_to_str_const(ft, frame_type_vals, \"Unknown\"));\n\n    if (ft == FT_CONTROL) {\n        dissect_common_control(tvb, pinfo, tree, offset, p_fp_info);\n        /* For control frame the header CRC is actually frame CRC covering all\n         * bytes except the first */\n        if (preferences_header_checksum) {\n            verify_control_frame_crc(tvb, pinfo, header_crc_pi, (uint16_t)header_crc);\n        }\n    }\n    else {\n        uint8_t     cfn;\n        uint32_t    encoded;\n        uint32_t    propagation_delay                    = 0;\n        proto_item *propagation_delay_ti                 = NULL;\n        uint32_t    received_sync_ul_timing_deviation    = 0;\n        proto_item *received_sync_ul_timing_deviation_ti = NULL;\n        proto_item *rx_timing_deviation_ti               = NULL;\n        uint16_t    rx_timing_deviation                  = 0;\n\n        /* DATA */\n\n        /* CFN */\n        cfn = tvb_get_uint8(tvb, offset);\n        proto_tree_add_item(tree, hf_fp_cfn, tvb, offset, 1, ENC_BIG_ENDIAN);\n        offset++;\n\n        col_append_fstr(pinfo->cinfo, COL_INFO, \"CFN=%03u \", cfn);\n\n        /* TFI */\n        proto_tree_add_item(tree, hf_fp_tfi, tvb, offset, 1, ENC_BIG_ENDIAN);\n        offset++;\n\n        if (p_fp_info->channel == CHANNEL_RACH_FDD) {\n            /* Propagation delay */\n            encoded = tvb_get_uint8(tvb, offset);\n            propagation_delay = encoded * 3;\n            propagation_delay_ti = proto_tree_add_uint_format(tree, hf_fp_propagation_delay, tvb, offset, 1,\n                                               propagation_delay, \"Propagation Delay: %u chips (%u)\",\n                                               propagation_delay, encoded);\n            offset++;\n        }\n\n        /* Should be TDD 3.84 or 7.68 */\n        if (p_fp_info->channel == CHANNEL_RACH_TDD) {\n            /* Rx Timing Deviation */\n            rx_timing_deviation = tvb_get_uint8(tvb, offset);\n            rx_timing_deviation_ti = proto_tree_add_item(tree, hf_fp_rx_timing_deviation, tvb, offset, 1, ENC_BIG_ENDIAN);\n            offset++;\n        }\n\n        if (p_fp_info->channel == CHANNEL_RACH_TDD_128) {\n            /* Received SYNC UL Timing Deviation */\n            received_sync_ul_timing_deviation = tvb_get_uint8(tvb, offset);\n            received_sync_ul_timing_deviation_ti =\n                 proto_tree_add_item(tree, hf_fp_received_sync_ul_timing_deviation, tvb, offset, 1, ENC_BIG_ENDIAN);\n            offset++;\n        }\n\n        header_length = offset;\n\n        /* TB data */\n        offset = dissect_tb_data(tvb, pinfo, tree, offset, p_fp_info, &mac_fdd_rach_handle, data);\n\n        /* CRCIs */\n        offset = dissect_crci_bits(tvb, pinfo, tree, p_fp_info, offset);\n\n        /* Info introduced in R6 */\n        /* only check if it looks as if they are present */\n        if (((p_fp_info->release == 6) || (p_fp_info->release == 7)) &&\n            (tvb_reported_length_remaining(tvb, offset) > 2))\n        {\n            int n;\n            uint8_t flags;\n            /* uint8_t flag_bytes = 0; */\n\n            bool cell_portion_id_present                 = false;\n            bool ext_propagation_delay_present           = false;\n            bool angle_of_arrival_present                = false;\n            bool ext_rx_sync_ul_timing_deviation_present = false;\n            bool ext_rx_timing_deviation_present         = false;\n\n            /* New IE flags (assume mandatory for now) */\n            do {\n                proto_item *new_ie_flags_ti;\n                proto_tree *new_ie_flags_tree;\n                unsigned ies_found = 0;\n\n                /* Add new IE flags subtree */\n                new_ie_flags_ti = proto_tree_add_string_format(tree, hf_fp_rach_new_ie_flags, tvb, offset, 1,\n                                                              \"\", \"New IE flags\");\n                new_ie_flags_tree = proto_item_add_subtree(new_ie_flags_ti, ett_fp_rach_new_ie_flags);\n\n                /* Read next byte */\n                flags = tvb_get_uint8(tvb, offset);\n                /* flag_bytes++ */\n\n                /* Dissect individual bits */\n                for (n=0; n < 8; n++) {\n                    switch (n) {\n                        case 6:\n                            switch (p_fp_info->division) {\n                                case Division_FDD:\n                                    /* Ext propagation delay */\n                                    ext_propagation_delay_present = true;\n                                    proto_tree_add_item(new_ie_flags_tree, hf_fp_rach_ext_propagation_delay_present,\n                                                        tvb, offset, 1, ENC_BIG_ENDIAN);\n                                    break;\n                                case Division_TDD_128:\n                                    /* Ext Rx Sync UL Timing */\n                                    ext_rx_sync_ul_timing_deviation_present = true;\n                                    proto_tree_add_item(new_ie_flags_tree, hf_fp_rach_ext_rx_sync_ul_timing_deviation_present,\n                                                        tvb, offset, 1, ENC_BIG_ENDIAN);\n\n                                    break;\n                                default:\n                                    /* Not defined */\n                                    proto_tree_add_item(new_ie_flags_tree, hf_fp_rach_new_ie_flag_unused[6],\n                                                        tvb, offset, 1, ENC_BIG_ENDIAN);\n                                    break;\n                            }\n                            break;\n                        case 7:\n                            switch (p_fp_info->division) {\n                                case Division_FDD:\n                                    /* Cell Portion ID */\n                                    cell_portion_id_present = true;\n                                    proto_tree_add_item(new_ie_flags_tree, hf_fp_rach_cell_portion_id_present,\n                                                        tvb, offset, 1, ENC_BIG_ENDIAN);\n                                    break;\n                                case Division_TDD_128:\n                                    /* AOA */\n                                    angle_of_arrival_present = true;\n                                    proto_tree_add_item(new_ie_flags_tree, hf_fp_rach_angle_of_arrival_present,\n                                                        tvb, offset, 1, ENC_BIG_ENDIAN);\n                                    break;\n                                case Division_TDD_384:\n                                case Division_TDD_768:\n                                    /* Extended Rx Timing Deviation */\n                                    ext_rx_timing_deviation_present = true;\n                                    proto_tree_add_item(new_ie_flags_tree, hf_fp_rach_ext_rx_timing_deviation_present,\n                                                        tvb, offset, 1, ENC_BIG_ENDIAN);\n                                    break;\n                            }\n                            break;\n\n                        default:\n                            /* No defined meanings */\n                            /* Visual Studio Code Analyzer wrongly thinks n can be 7 here. It can't */\n                            proto_tree_add_item(new_ie_flags_tree, hf_fp_rach_new_ie_flag_unused[n],\n                                                tvb, offset, 1, ENC_BIG_ENDIAN);\n                            break;\n                    }\n                    if ((flags >> (7-n)) & 0x01) {\n                        ies_found++;\n                    }\n                }\n                offset++;\n\n                proto_item_append_text(new_ie_flags_ti, \" (%u IEs found)\", ies_found);\n\n                /* Last bit set will indicate another flags byte follows... */\n            } while (0); /*((flags & 0x01) && (flag_bytes < 31));*/\n\n            /* Cell Portion ID */\n            if (cell_portion_id_present) {\n                    proto_tree_add_item(tree, hf_fp_cell_portion_id, tvb, offset, 1, ENC_BIG_ENDIAN);\n                    offset++;\n            }\n\n            /* Ext Rx Timing Deviation */\n            if (ext_rx_timing_deviation_present) {\n                uint8_t extra_bits;\n                unsigned bits_to_extend;\n                switch (p_fp_info->division) {\n                    case Division_TDD_384:\n                        bits_to_extend = 1;\n                        break;\n                    case Division_TDD_768:\n                        bits_to_extend = 2;\n                        break;\n\n                    default:\n                        /* TODO: report unexpected division type */\n                        bits_to_extend = 1;\n                        break;\n                }\n                extra_bits = tvb_get_uint8(tvb, offset) &\n                                 ((bits_to_extend == 1) ? 0x01 : 0x03);\n                rx_timing_deviation = (extra_bits << 8) | (rx_timing_deviation);\n                proto_item_append_text(rx_timing_deviation_ti,\n                                       \" (extended to 0x%x)\",\n                                       rx_timing_deviation);\n                proto_tree_add_bits_item(tree, hf_fp_extended_bits, tvb,\n                                         offset*8 + (8-bits_to_extend), bits_to_extend, ENC_BIG_ENDIAN);\n                offset++;\n            }\n\n            /* Ext propagation delay. */\n            if (ext_propagation_delay_present) {\n                uint16_t extra_bits = tvb_get_ntohs(tvb, offset) & 0x03ff;\n                proto_tree_add_item(tree, hf_fp_ext_propagation_delay, tvb, offset, 2, ENC_BIG_ENDIAN);\n\n                /* Adding 10 bits to original 8 */\n                proto_item_append_text(propagation_delay_ti, \" (extended to %u)\",\n                                       ((extra_bits << 8) | propagation_delay) * 3);\n                offset += 2;\n            }\n\n            /* Angle of Arrival (AOA) */\n            if (angle_of_arrival_present) {\n                proto_tree_add_item(tree, hf_fp_angle_of_arrival, tvb, offset, 2, ENC_BIG_ENDIAN);\n                offset += 2;\n            }\n\n            /* Ext. Rx Sync UL Timing Deviation */\n            if (ext_rx_sync_ul_timing_deviation_present) {\n                uint16_t extra_bits;\n\n                /* Ext received Sync UL Timing Deviation */\n                extra_bits = tvb_get_ntohs(tvb, offset) & 0x1fff;\n                proto_tree_add_item(tree, hf_fp_ext_received_sync_ul_timing_deviation, tvb, offset, 2, ENC_BIG_ENDIAN);\n\n                /* Adding 13 bits to original 8 */\n                proto_item_append_text(received_sync_ul_timing_deviation_ti, \" (extended to %u)\",\n                                       (extra_bits << 8) | received_sync_ul_timing_deviation);\n                offset += 2;\n            }\n        }\n        if (preferences_header_checksum) {\n            verify_header_crc(tvb, pinfo, header_crc_pi, header_crc, header_length);\n        }\n        /* Spare Extension and Payload CRC */\n        dissect_spare_extension_and_crc(tvb, pinfo, tree, 1, offset, header_length);\n    }\n}\n\n\n/**************************/\n/* Dissect a FACH channel */\nstatic void\ndissect_fach_channel_info(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\n                          int offset, struct fp_info *p_fp_info, void *data)\n{\n    uint32_t ft;\n    uint32_t header_crc = 0;\n    proto_item * header_crc_pi = NULL;\n    unsigned header_length;\n\n    /* Header CRC */\n    header_crc_pi = proto_tree_add_item_ret_uint(tree, hf_fp_header_crc, tvb, offset, 1, ENC_BIG_ENDIAN, &header_crc);\n\n    /* Frame Type */\n    proto_tree_add_item_ret_uint(tree, hf_fp_ft, tvb, offset, 1, ENC_BIG_ENDIAN, &ft);\n    offset++;\n\n    col_append_fstr(pinfo->cinfo, COL_INFO, \" [%s] \", val_to_str_const(ft, frame_type_vals, \"Unknown\"));\n\n    if (ft == FT_CONTROL) {\n        dissect_common_control(tvb, pinfo, tree, offset, p_fp_info);\n        /* For control frame the header CRC is actually frame CRC covering all\n         * bytes except the first */\n        if (preferences_header_checksum) {\n            verify_control_frame_crc(tvb, pinfo, header_crc_pi, (uint16_t)header_crc);\n        }\n    }\n    else {\n        uint8_t cfn;\n        /* DATA */\n\n        /* CFN */\n        cfn = tvb_get_uint8(tvb, offset);\n        proto_tree_add_item(tree, hf_fp_cfn, tvb, offset, 1, ENC_BIG_ENDIAN);\n        offset++;\n\n        col_append_fstr(pinfo->cinfo, COL_INFO, \"CFN=%03u \", cfn);\n\n        /* TFI */\n        proto_tree_add_item(tree, hf_fp_fach_tfi, tvb, offset, 1, ENC_BIG_ENDIAN);\n        offset++;\n\n        /* Transmit power level */\n        proto_tree_add_float(tree, hf_fp_transmit_power_level, tvb, offset, 1,\n                             (float)(int)(tvb_get_uint8(tvb, offset)) / 10);\n        offset++;\n        header_length = offset;\n\n        /* TB data */\n        offset = dissect_tb_data(tvb, pinfo, tree, offset, p_fp_info, &mac_fdd_fach_handle, data);\n\n        /* New IE flags (if it looks as though they are present) */\n        if ((p_fp_info->release == 7) &&\n            (tvb_reported_length_remaining(tvb, offset) > 2)) {\n\n            uint8_t flags = tvb_get_uint8(tvb, offset);\n            uint8_t aoa_present = flags & 0x01;\n            offset++;\n\n            if (aoa_present) {\n                proto_tree_add_item(tree, hf_fp_angle_of_arrival, tvb, offset, 2, ENC_BIG_ENDIAN);\n                offset += 2;\n            }\n        }\n        if (preferences_header_checksum) {\n            verify_header_crc(tvb, pinfo, header_crc_pi, header_crc, header_length);\n        }\n        /* Spare Extension and Payload CRC */\n        dissect_spare_extension_and_crc(tvb, pinfo, tree, 1, offset, header_length);\n    }\n}\n\n\n/**************************/\n/* Dissect a DSCH channel */\nstatic void\ndissect_dsch_channel_info(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\n                          int offset, struct fp_info *p_fp_info)\n{\n    uint32_t ft;\n\n    /* Header CRC */\n    proto_tree_add_item(tree, hf_fp_header_crc, tvb, offset, 1, ENC_BIG_ENDIAN);\n\n    /* Frame Type */\n    proto_tree_add_item_ret_uint(tree, hf_fp_ft, tvb, offset, 1, ENC_BIG_ENDIAN, &ft);\n    offset++;\n\n    col_append_fstr(pinfo->cinfo, COL_INFO, \" [%s] \", val_to_str_const(ft, frame_type_vals, \"Unknown\"));\n\n    if (ft == FT_CONTROL) {\n        dissect_common_control(tvb, pinfo, tree, offset, p_fp_info);\n    }\n    else {\n        uint32_t cfn;\n        unsigned header_length = 0;\n\n        /* DATA */\n\n        /* CFN */\n        proto_tree_add_item_ret_uint(tree, hf_fp_cfn, tvb, offset, 1, ENC_BIG_ENDIAN, &cfn);\n        offset++;\n\n        col_append_fstr(pinfo->cinfo, COL_INFO, \"CFN=%03u \", cfn);\n\n        /* TFI */\n        proto_tree_add_item(tree, hf_fp_tfi, tvb, offset, 1, ENC_BIG_ENDIAN);\n        offset++;\n\n\n        /* Other fields depend upon release & FDD/TDD settings */\n        if (((p_fp_info->release == 99) || (p_fp_info->release == 4)) &&\n             (p_fp_info->channel == CHANNEL_DSCH_FDD)) {\n\n            /* Power offset */\n            proto_tree_add_float(tree, hf_fp_power_offset, tvb, offset, 1,\n                                 (float)(-32.0) +\n                                  ((float)(int)(tvb_get_uint8(tvb, offset)) * (float)(0.25)));\n            offset++;\n\n            /* Code number */\n            proto_tree_add_item(tree, hf_fp_code_number, tvb, offset, 1, ENC_BIG_ENDIAN);\n            offset++;\n\n            /* Spreading Factor (3 bits) */\n            proto_tree_add_item(tree, hf_fp_spreading_factor, tvb, offset, 1, ENC_BIG_ENDIAN);\n\n            /* MC info (4 bits)*/\n            proto_tree_add_item(tree, hf_fp_mc_info, tvb, offset, 1, ENC_BIG_ENDIAN);\n\n            /* Last bit of this byte is spare */\n            offset++;\n        }\n        else {\n            /* Normal case */\n\n            /* PDSCH Set Id */\n            proto_tree_add_item(tree, hf_fp_pdsch_set_id, tvb, offset, 1, ENC_BIG_ENDIAN);\n            offset++;\n\n            /* Transmit power level */\n            proto_tree_add_float(tree, hf_fp_transmit_power_level, tvb, offset, 1,\n                                 (float)(int)(tvb_get_uint8(tvb, offset)) / 10);\n            offset++;\n        }\n        header_length = offset;\n        /* TB data */\n        offset = dissect_tb_data(tvb, pinfo, tree, offset, p_fp_info, NULL, NULL);\n\n        /* Spare Extension and Payload CRC */\n        dissect_spare_extension_and_crc(tvb, pinfo, tree, 1, offset, header_length);\n    }\n}\n\n\n/**************************/\n/* Dissect a USCH channel */\nstatic void\ndissect_usch_channel_info(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\n                          int offset, struct fp_info *p_fp_info)\n{\n    uint32_t ft;\n\n    /* Header CRC */\n    proto_tree_add_item(tree, hf_fp_header_crc, tvb, offset, 1, ENC_BIG_ENDIAN);\n\n    /* Frame Type */\n    proto_tree_add_item_ret_uint(tree, hf_fp_ft, tvb, offset, 1, ENC_BIG_ENDIAN, &ft);\n    offset++;\n\n    col_append_fstr(pinfo->cinfo, COL_INFO, \" [%s] \", val_to_str_const(ft, frame_type_vals, \"Unknown\"));\n\n    if (ft == FT_CONTROL) {\n        dissect_common_control(tvb, pinfo, tree, offset, p_fp_info);\n    }\n    else {\n        unsigned cfn;\n        uint16_t rx_timing_deviation;\n        proto_item *rx_timing_deviation_ti;\n        unsigned header_length = 0;\n\n        /* DATA */\n\n        /* CFN */\n        proto_tree_add_item_ret_uint(tree, hf_fp_cfn, tvb, offset, 1, ENC_BIG_ENDIAN, &cfn);\n        offset++;\n\n        col_append_fstr(pinfo->cinfo, COL_INFO, \"CFN=%03u \", cfn);\n\n        /* TFI */\n        proto_tree_add_item(tree, hf_fp_usch_tfi, tvb, offset, 1, ENC_BIG_ENDIAN);\n        offset++;\n\n        /* Rx Timing Deviation */\n        rx_timing_deviation = tvb_get_uint8(tvb, offset);\n        rx_timing_deviation_ti = proto_tree_add_item(tree, hf_fp_rx_timing_deviation,\n                                                     tvb, offset, 1, ENC_BIG_ENDIAN);\n        offset++;\n        header_length = offset;\n        /* TB data */\n        offset = dissect_tb_data(tvb, pinfo, tree, offset, p_fp_info, NULL, NULL);\n\n        /* QE */\n        proto_tree_add_item(tree, hf_fp_quality_estimate, tvb, offset, 1, ENC_BIG_ENDIAN);\n        offset++;\n\n        /* CRCIs */\n        offset = dissect_crci_bits(tvb, pinfo, tree, p_fp_info, offset);\n\n        /* New IEs */\n        if ((p_fp_info->release == 7) &&\n            (tvb_reported_length_remaining(tvb, offset) > 2)) {\n\n            uint8_t flags = tvb_get_uint8(tvb, offset);\n            uint8_t bits_extended = flags & 0x01;\n            offset++;\n\n            if (bits_extended) {\n                uint8_t extra_bits = tvb_get_uint8(tvb, offset) & 0x03;\n                proto_item_append_text(rx_timing_deviation_ti,\n                                       \" (extended to %u)\",\n                                       (rx_timing_deviation << 2) | extra_bits);\n            }\n            offset++;\n        }\n\n        /* Spare Extension and Payload CRC */\n        dissect_spare_extension_and_crc(tvb, pinfo, tree, 1, offset, header_length);\n    }\n}\n\n\n\n/**************************/\n/* Dissect a PCH channel  */\nstatic void\ndissect_pch_channel_info(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\n                         int offset, struct fp_info *p_fp_info, void *data)\n{\n    uint32_t ft;\n    uint16_t pch_cfn;\n    uint32_t tfi;\n    bool paging_indication;\n    uint32_t header_crc = 0;\n    proto_item * header_crc_pi = NULL;\n\n    /* Header CRC */\n    header_crc_pi = proto_tree_add_item_ret_uint(tree, hf_fp_header_crc, tvb, offset, 1, ENC_BIG_ENDIAN, &header_crc);\n\n    /* Frame Type */\n    proto_tree_add_item_ret_uint(tree, hf_fp_ft, tvb, offset, 1, ENC_BIG_ENDIAN, &ft);\n    offset++;\n\n    col_append_fstr(pinfo->cinfo, COL_INFO, \" [%s] \", val_to_str_const(ft, frame_type_vals, \"Unknown\"));\n\n    if (ft == FT_CONTROL) {\n        dissect_common_control(tvb, pinfo, tree, offset, p_fp_info);\n        /* For control frame the header CRC is actually frame CRC covering all\n         * bytes except the first */\n        if (preferences_header_checksum) {\n            verify_control_frame_crc(tvb, pinfo, header_crc_pi, (uint16_t)header_crc);\n        }\n    }\n    else {\n        unsigned header_length = 0;\n        /* DATA */\n\n        /* 12-bit CFN value */\n        proto_tree_add_item(tree, hf_fp_pch_cfn, tvb, offset, 2, ENC_BIG_ENDIAN);\n        pch_cfn = (tvb_get_ntohs(tvb, offset) & 0xfff0) >> 4;\n        offset++;\n\n        col_append_fstr(pinfo->cinfo, COL_INFO, \"CFN=%04u \", pch_cfn);\n\n        /* Paging indication */\n        proto_tree_add_item(tree, hf_fp_pch_pi, tvb, offset, 1, ENC_BIG_ENDIAN);\n        paging_indication = tvb_get_uint8(tvb, offset) & 0x01;\n        offset++;\n\n        /* 5-bit TFI */\n        proto_tree_add_item_ret_uint(tree, hf_fp_pch_tfi, tvb, offset, 1, ENC_BIG_ENDIAN, &tfi);\n        offset++;\n        header_length = offset;\n        /* Optional paging indications */\n        if (paging_indication) {\n            proto_item *ti;\n            ti = proto_tree_add_item(tree, hf_fp_paging_indication_bitmap, tvb,\n                                     offset,\n                                     (p_fp_info->paging_indications+7) / 8,\n                                     ENC_NA);\n            proto_item_append_text(ti, \" (%u bits)\", p_fp_info->paging_indications);\n\n            if(preferences_track_paging_indications && !PINFO_FD_VISITED(pinfo)){\n                paging_indications_info_t* current_pi_info;\n                current_pi_info = wmem_new0(wmem_file_scope(), paging_indications_info_t);\n                current_pi_info->frame_number = pinfo->num;\n                current_pi_info->paging_indications_bitmap = (uint8_t*)tvb_memdup(wmem_file_scope(), tvb, offset, (p_fp_info->paging_indications+7) / 8);\n                p_fp_info->current_paging_indications = current_pi_info;\n            }\n\n            offset += ((p_fp_info->paging_indications+7) / 8);\n        }\n        if(preferences_track_paging_indications) {\n            if(p_fp_info->relevant_paging_indications) {\n                /*If tracking PI is enabled and PI info (from the last packet) is attached, show on tree*/\n                proto_item *ti;\n                proto_tree *relevant_pi_tree;\n\n                tvbuff_t *pi_tvb;\n                pi_tvb = tvb_new_child_real_data(tvb,\n                                                 p_fp_info->relevant_paging_indications->paging_indications_bitmap,\n                                                 (p_fp_info->paging_indications+7) / 8,\n                                                 (p_fp_info->paging_indications+7) / 8);\n                add_new_data_source(pinfo, pi_tvb, \"Relevant Paging Indication\");\n                ti = proto_tree_add_item(tree, hf_fp_relevant_paging_indication_bitmap, pi_tvb,\n                                         0,\n                                         (p_fp_info->paging_indications+7) / 8,\n                                         ENC_NA);\n                proto_item_append_text(ti, \" (%u bits)\", p_fp_info->paging_indications);\n                proto_item_set_generated(ti);\n                relevant_pi_tree = proto_item_add_subtree(ti, ett_fp_pch_relevant_pi);\n                ti = proto_tree_add_uint(relevant_pi_tree, hf_fp_relevant_pi_frame,\n                                                           tvb, 0, 0, p_fp_info->relevant_paging_indications->frame_number);\n                proto_item_set_generated(ti);\n            }\n            else {\n                /* PI info not attached. Check if this frame has any Transport Blocks (i.e. RRC payloads) */\n                if(tfi > 0)\n                {\n                    /* This frame has RRC payload(s) but the PI info is missing, report to the user*/\n                    proto_tree_add_expert(tree, pinfo, &ei_fp_pch_lost_relevant_pi_frame, tvb, offset, -1);\n                }\n            }\n        }\n\n        /* TB data */\n        offset = dissect_tb_data(tvb, pinfo, tree, offset, p_fp_info, &mac_fdd_pch_handle, data);\n\n        if (preferences_header_checksum) {\n            verify_header_crc(tvb, pinfo, header_crc_pi, header_crc, header_length);\n        }\n        /* Spare Extension and Payload CRC */\n        dissect_spare_extension_and_crc(tvb, pinfo, tree, 1, offset, header_length);\n    }\n}\n\n\n/**************************/\n/* Dissect a CPCH channel */\nstatic void\ndissect_cpch_channel_info(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\n                          int offset, struct fp_info *p_fp_info)\n{\n    uint32_t ft;\n\n    /* Header CRC */\n    proto_tree_add_item(tree, hf_fp_header_crc, tvb, offset, 1, ENC_BIG_ENDIAN);\n\n    /* Frame Type */\n    proto_tree_add_item_ret_uint(tree, hf_fp_ft, tvb, offset, 1, ENC_BIG_ENDIAN, &ft);\n    offset++;\n\n    col_append_fstr(pinfo->cinfo, COL_INFO, \" [%s] \", val_to_str_const(ft, frame_type_vals, \"Unknown\"));\n\n    if (ft == FT_CONTROL) {\n        dissect_common_control(tvb, pinfo, tree, offset, p_fp_info);\n    }\n    else {\n        unsigned cfn;\n        uint32_t encoded;\n        unsigned header_length = 0;\n        uint32_t propagation_delay = 0;\n\n        /* DATA */\n\n        /* CFN */\n        proto_tree_add_item_ret_uint(tree, hf_fp_cfn, tvb, offset, 1, ENC_BIG_ENDIAN, &cfn);\n        offset++;\n\n        col_append_fstr(pinfo->cinfo, COL_INFO, \"CFN=%03u \", cfn);\n\n        /* TFI */\n        proto_tree_add_item(tree, hf_fp_cpch_tfi, tvb, offset, 1, ENC_BIG_ENDIAN);\n        offset++;\n\n        /* Propagation delay */\n        encoded = tvb_get_uint8(tvb, offset);\n        propagation_delay = encoded * 3;\n        proto_tree_add_uint_format_value(tree, hf_fp_propagation_delay, tvb, offset, 1,\n                                               propagation_delay, \"Propagation Delay: %u chips (%u)\",\n                                               propagation_delay, encoded);\n        offset++;\n        header_length = offset; /* XXX this might be wrong */\n        /* TB data */\n        offset = dissect_tb_data(tvb, pinfo, tree, offset, p_fp_info, NULL, NULL);\n\n        /* CRCIs */\n        offset = dissect_crci_bits(tvb, pinfo, tree, p_fp_info, offset);\n\n        /* Spare Extension and Payload CRC */\n        dissect_spare_extension_and_crc(tvb, pinfo, tree, 1, offset, header_length);\n    }\n}\n\n\n/**************************/\n/* Dissect a BCH channel  */\nstatic void\ndissect_bch_channel_info(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\n                         int offset, struct fp_info *p_fp_info)\n{\n    uint32_t ft;\n\n    /* Header CRC */\n    proto_tree_add_item(tree, hf_fp_header_crc, tvb, offset, 1, ENC_BIG_ENDIAN);\n\n    /* Frame Type */\n    proto_tree_add_item_ret_uint(tree, hf_fp_ft, tvb, offset, 1, ENC_BIG_ENDIAN, &ft);\n    offset++;\n\n    col_append_fstr(pinfo->cinfo, COL_INFO, \" [%s] \", val_to_str_const(ft, frame_type_vals, \"Unknown\"));\n\n    if (ft == FT_CONTROL) {\n        dissect_common_control(tvb, pinfo, tree, offset, p_fp_info);\n    }\n}\n\n\n/********************************/\n/* Dissect an IUR DSCH channel  */\nstatic void\ndissect_iur_dsch_channel_info(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\n                              int offset, struct fp_info *p_fp_info)\n{\n    uint32_t ft;\n\n    /* Header CRC */\n    proto_tree_add_item(tree, hf_fp_header_crc, tvb, offset, 1, ENC_BIG_ENDIAN);\n\n    /* Frame Type */\n    proto_tree_add_item_ret_uint(tree, hf_fp_ft, tvb, offset, 1, ENC_BIG_ENDIAN, &ft);\n    offset++;\n\n    col_append_fstr(pinfo->cinfo, COL_INFO, \" [%s] \", val_to_str_const(ft, frame_type_vals, \"Unknown\"));\n\n    if (ft == FT_CONTROL) {\n        dissect_common_control(tvb, pinfo, tree, offset, p_fp_info);\n    }\n    else {\n        /* TODO: DATA */\n    }\n}\n\n\n\n\n/************************/\n/* DCH control messages */\n\nstatic int\ndissect_dch_timing_adjustment(proto_tree *tree, packet_info *pinfo, tvbuff_t *tvb, int offset)\n{\n    uint32_t    cfn;\n    int16_t     toa;\n    proto_item *toa_ti;\n\n    /* CFN control */\n    proto_tree_add_item_ret_uint(tree, hf_fp_cfn_control, tvb, offset, 1, ENC_BIG_ENDIAN, &cfn);\n    offset++;\n\n    /* ToA */\n    toa = tvb_get_ntohs(tvb, offset);\n    toa_ti = proto_tree_add_item(tree, hf_fp_toa, tvb, offset, 2, ENC_BIG_ENDIAN);\n    offset += 2;\n\n    expert_add_info_format(pinfo, toa_ti, &ei_fp_timing_adjustment_reported, \"Timing adjustment reported (%.3f ms)\", ((float)(toa) / 8));\n\n    col_append_fstr(pinfo->cinfo, COL_INFO,\n                    \" CFN = %u, ToA = %d\", cfn, toa);\n\n    return offset;\n}\n\nstatic int\ndissect_dch_rx_timing_deviation(packet_info *pinfo, proto_tree *tree,\n                                tvbuff_t *tvb, int offset,\n                                struct fp_info *p_fp_info)\n{\n    uint16_t    timing_deviation;\n    int         timing_deviation_chips;\n    proto_item *timing_deviation_ti;\n\n    /* CFN control */\n    proto_tree_add_item(tree, hf_fp_cfn_control, tvb, offset, 1, ENC_BIG_ENDIAN);\n    offset++;\n\n    /* Rx Timing Deviation */\n    timing_deviation = tvb_get_uint8(tvb, offset);\n    timing_deviation_ti = proto_tree_add_item(tree, hf_fp_dch_rx_timing_deviation, tvb, offset, 1, ENC_BIG_ENDIAN);\n    offset++;\n\n    /* May be extended in R7, but in this case there are at least 2 bytes remaining */\n    if ((p_fp_info->release == 7) &&\n        (tvb_reported_length_remaining(tvb, offset) >= 2)) {\n\n        /* New IE flags */\n        uint64_t extended_bits_present;\n        uint64_t e_rucch_present;\n\n        /* Read flags */\n        proto_tree_add_bits_ret_val(tree, hf_fp_e_rucch_present, tvb,\n                                    offset*8 + 6, 1, &e_rucch_present, ENC_BIG_ENDIAN);\n        proto_tree_add_bits_ret_val(tree, hf_fp_extended_bits_present, tvb,\n                                    offset*8 + 7, 1, &extended_bits_present, ENC_BIG_ENDIAN);\n        offset++;\n\n        /* Optional E-RUCCH */\n        if (e_rucch_present) {\n\n            /* Value of bit_offset depends upon division type */\n            int bit_offset;\n\n            switch (p_fp_info->division) {\n                case Division_TDD_384:\n                    bit_offset = 6;\n                    break;\n                case Division_TDD_768:\n                    bit_offset = 5;\n                    break;\n                default:\n                    {\n                        proto_tree_add_expert(tree, pinfo, &ei_fp_expecting_tdd, tvb, 0, 0);\n                        bit_offset = 6;\n                    }\n            }\n\n            proto_tree_add_item(tree, hf_fp_dch_e_rucch_flag, tvb, offset, 1, ENC_BIG_ENDIAN);\n            proto_tree_add_bits_item(tree, hf_fp_dch_e_rucch_flag, tvb,\n                                     offset*8 + bit_offset, 1, ENC_BIG_ENDIAN);\n        }\n\n        /* Timing deviation may be extended by another:\n           - 1 bits (3.84 TDD)    OR\n           - 2 bits (7.68 TDD)\n        */\n        if (extended_bits_present) {\n            uint8_t extra_bits;\n            unsigned bits_to_extend;\n            switch (p_fp_info->division) {\n                case Division_TDD_384:\n                    bits_to_extend = 1;\n                    break;\n                case Division_TDD_768:\n                    bits_to_extend = 2;\n                    break;\n\n                default:\n                    /* TODO: report unexpected division type */\n                    bits_to_extend = 1;\n                    break;\n            }\n            extra_bits = tvb_get_uint8(tvb, offset) &\n                             ((bits_to_extend == 1) ? 0x01 : 0x03);\n            timing_deviation = (extra_bits << 8) | (timing_deviation);\n            proto_item_append_text(timing_deviation_ti,\n                                   \" (extended to 0x%x)\",\n                                   timing_deviation);\n            proto_tree_add_bits_item(tree, hf_fp_extended_bits, tvb,\n                                     offset*8 + (8-bits_to_extend), bits_to_extend, ENC_BIG_ENDIAN);\n            offset++;\n        }\n    }\n\n    timing_deviation_chips = (timing_deviation*4) - 1024;\n    proto_item_append_text(timing_deviation_ti, \" (%d chips)\",\n                           timing_deviation_chips);\n\n    col_append_fstr(pinfo->cinfo, COL_INFO, \" deviation = %u (%d chips)\",\n                    timing_deviation, timing_deviation_chips);\n\n    return offset;\n}\n\nstatic int\ndissect_dch_dl_synchronisation(proto_tree *tree, packet_info *pinfo, tvbuff_t *tvb, int offset)\n{\n    uint32_t cfn;\n\n    /* CFN control */\n    proto_tree_add_item_ret_uint(tree, hf_fp_cfn_control, tvb, offset, 1, ENC_BIG_ENDIAN, &cfn);\n    offset++;\n\n    col_append_fstr(pinfo->cinfo, COL_INFO, \" CFN = %u\", cfn);\n\n    return offset;\n}\n\nstatic int\ndissect_dch_ul_synchronisation(proto_tree *tree, packet_info *pinfo, tvbuff_t *tvb, int offset)\n{\n    uint32_t cfn;\n    int16_t toa;\n\n    /* CFN control */\n    proto_tree_add_item_ret_uint(tree, hf_fp_cfn_control, tvb, offset, 1, ENC_BIG_ENDIAN, &cfn);\n    offset++;\n\n    /* ToA */\n    toa = tvb_get_ntohs(tvb, offset);\n    proto_tree_add_item(tree, hf_fp_toa, tvb, offset, 2, ENC_BIG_ENDIAN);\n    offset += 2;\n\n    col_append_fstr(pinfo->cinfo, COL_INFO, \" CFN = %u, ToA = %d\",\n                    cfn, toa);\n\n    return offset;\n}\n\nstatic int\ndissect_dch_outer_loop_power_control(proto_tree *tree, packet_info *pinfo, tvbuff_t *tvb, int offset)\n{\n    /* UL SIR target */\n    uint8_t encoded = tvb_get_uint8(tvb, offset);\n    float target = (float)-8.2 + ((float)0.1 * (float)(int)(encoded));\n    proto_tree_add_float_format_value(tree, hf_fp_ul_sir_target, tvb, offset, 1, target, \"%.1f dB (%u)\", target, encoded);\n    offset++;\n\n    col_append_fstr(pinfo->cinfo, COL_INFO, \" UL SIR Target = %.1f\", target);\n\n    return offset;\n}\n\nstatic int\ndissect_dch_dl_node_synchronisation(proto_tree *tree, packet_info *pinfo, tvbuff_t *tvb, int offset)\n{\n    return dissect_common_dl_node_synchronisation(pinfo, tree, tvb, offset);\n}\n\nstatic int\ndissect_dch_ul_node_synchronisation(proto_tree *tree, packet_info *pinfo, tvbuff_t *tvb, int offset)\n{\n    return dissect_common_ul_node_synchronisation(pinfo, tree, tvb, offset);\n}\n\nstatic int\ndissect_dch_radio_interface_parameter_update(proto_tree *tree, packet_info *pinfo _U_, tvbuff_t *tvb, int offset)\n{\n    float tpc_po;\n    int8_t max_tx_pwr;\n    int    n;\n    uint8_t encoded;\n\n    /* Show defined flags in these 2 bytes */\n    for (n=4; n >= 0; n--) {\n        proto_tree_add_item(tree, hf_fp_radio_interface_parameter_update_flag[n], tvb, offset, 2, ENC_BIG_ENDIAN);\n    }\n    offset += 2;\n\n    /* CFN  */\n    proto_tree_add_item(tree, hf_fp_cfn, tvb, offset, 1, ENC_BIG_ENDIAN);\n    offset++;\n\n    /* DPC mode */\n    proto_tree_add_item(tree, hf_fp_dpc_mode, tvb, offset, 1, ENC_BIG_ENDIAN);\n\n    /* TPC PO */\n    encoded = tvb_get_uint8(tvb, offset) & 0x1f;\n    tpc_po = (float)encoded * 0.25f;\n    proto_tree_add_float_format_value(tree, hf_fp_tpc_po, tvb, offset, 1, tpc_po,\n                                      \"%.2f dB (%u)\", tpc_po, encoded);\n    offset++;\n\n    /* Multiple RL sets indicator */\n    proto_tree_add_item(tree, hf_fp_multiple_rl_set_indicator, tvb, offset, 1, ENC_BIG_ENDIAN);\n    offset += 2;\n\n    /* Maximum UE TX Power */\n    encoded = tvb_get_uint8(tvb, offset) & 0x7f;\n    max_tx_pwr = -55 + encoded;\n    proto_tree_add_int_format(tree, hf_fp_max_ue_tx_pow, tvb, offset, 1, max_tx_pwr,\n                              \"%d dBm (%u)\", max_tx_pwr, encoded);\n    offset++;\n\n    return offset;\n}\n\nstatic int\ndissect_dch_timing_advance(proto_tree *tree, packet_info *pinfo,\n                           tvbuff_t *tvb, int offset, struct fp_info *p_fp_info)\n{\n    uint32_t    cfn;\n    uint16_t    timing_advance;\n    proto_item *timing_advance_ti;\n\n    /* CFN control */\n    proto_tree_add_item_ret_uint(tree, hf_fp_cfn_control, tvb, offset, 1, ENC_BIG_ENDIAN, &cfn);\n    offset++;\n\n    /* Timing Advance */\n    timing_advance = (tvb_get_uint8(tvb, offset) & 0x3f) * 4;\n    timing_advance_ti = proto_tree_add_uint(tree, hf_fp_timing_advance, tvb, offset, 1, timing_advance);\n    offset++;\n\n    if ((p_fp_info->release == 7) &&\n        (tvb_reported_length_remaining(tvb, offset) > 0)) {\n\n        /* New IE flags */\n        uint8_t flags = tvb_get_uint8(tvb, offset);\n        uint8_t extended_bits = flags & 0x01;\n        offset++;\n\n        if (extended_bits) {\n            uint8_t extra_bit = tvb_get_uint8(tvb, offset) & 0x01;\n            proto_item_append_text(timing_advance_ti, \" (extended to %u)\",\n                                   (timing_advance << 1) | extra_bit);\n        }\n        offset++;\n    }\n\n    col_append_fstr(pinfo->cinfo, COL_INFO, \" CFN = %u, TA = %u\",\n                    cfn, timing_advance);\n\n    return offset;\n}\n\nstatic int\ndissect_dch_tnl_congestion_indication(proto_tree *tree, packet_info *pinfo, tvbuff_t *tvb, int offset)\n{\n    uint64_t status;\n\n    /* Congestion status */\n    proto_tree_add_bits_ret_val(tree, hf_fp_congestion_status, tvb,\n                                offset*8 + 6, 2, &status, ENC_BIG_ENDIAN);\n    offset++;\n\n    col_append_fstr(pinfo->cinfo, COL_INFO, \" status = %s\",\n                    val_to_str_const((uint16_t)status, congestion_status_vals, \"unknown\"));\n\n    return offset;\n}\n\n\n\n\n/* DCH control frame */\nstatic void\ndissect_dch_control_frame(proto_tree *tree, packet_info *pinfo, tvbuff_t *tvb,\n                          int offset, struct fp_info *p_fp_info)\n{\n    /* Control frame type */\n    uint8_t control_frame_type = tvb_get_uint8(tvb, offset);\n    proto_tree_add_item(tree, hf_fp_dch_control_frame_type, tvb, offset, 1, ENC_BIG_ENDIAN);\n    offset++;\n\n    col_append_str(pinfo->cinfo, COL_INFO,\n                   val_to_str_const(control_frame_type,\n                                    dch_control_frame_type_vals, \"Unknown\"));\n\n    switch (control_frame_type) {\n        case DCH_TIMING_ADJUSTMENT:\n            /*offset =*/ dissect_dch_timing_adjustment(tree, pinfo, tvb, offset);\n            break;\n        case DCH_RX_TIMING_DEVIATION:\n            /*offset =*/ dissect_dch_rx_timing_deviation(pinfo, tree, tvb, offset, p_fp_info);\n            break;\n        case DCH_DL_SYNCHRONISATION:\n            /*offset =*/ dissect_dch_dl_synchronisation(tree, pinfo, tvb, offset);\n            break;\n        case DCH_UL_SYNCHRONISATION:\n            /*offset =*/ dissect_dch_ul_synchronisation(tree, pinfo, tvb, offset);\n            break;\n        case DCH_OUTER_LOOP_POWER_CONTROL:\n            /*offset =*/ dissect_dch_outer_loop_power_control(tree, pinfo, tvb, offset);\n            break;\n        case DCH_DL_NODE_SYNCHRONISATION:\n            /*offset =*/ dissect_dch_dl_node_synchronisation(tree, pinfo, tvb, offset);\n            break;\n        case DCH_UL_NODE_SYNCHRONISATION:\n            /*offset =*/ dissect_dch_ul_node_synchronisation(tree, pinfo, tvb, offset);\n            break;\n        case DCH_RADIO_INTERFACE_PARAMETER_UPDATE:\n            /*offset =*/ dissect_dch_radio_interface_parameter_update(tree, pinfo, tvb, offset);\n            break;\n        case DCH_TIMING_ADVANCE:\n            /*offset =*/ dissect_dch_timing_advance(tree, pinfo, tvb, offset, p_fp_info);\n            break;\n        case DCH_TNL_CONGESTION_INDICATION:\n            /*offset =*/ dissect_dch_tnl_congestion_indication(tree, pinfo, tvb, offset);\n            break;\n    }\n\n    /* Spare Extension */\n   /* dissect_spare_extension_and_crc(tvb, pinfo, tree, 0, offset);\n    */\n}\n\n/*******************************/\n/* Dissect a DCH channel       */\nstatic void\ndissect_dch_channel_info(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\n                         int offset, struct fp_info *p_fp_info, void *data)\n{\n    uint32_t ft;\n    uint32_t  cfn;\n    unsigned header_length;\n    uint32_t header_crc = 0;\n    proto_item * header_crc_pi = NULL;\n\n    /* Header CRC */\n    header_crc_pi = proto_tree_add_item_ret_uint(tree, hf_fp_header_crc, tvb, offset, 1, ENC_BIG_ENDIAN, &header_crc);\n\n    /* Frame Type */\n    proto_tree_add_item_ret_uint(tree, hf_fp_ft, tvb, offset, 1, ENC_BIG_ENDIAN, &ft);\n    offset++;\n\n    col_append_str(pinfo->cinfo, COL_INFO,\n                   (ft == FT_CONTROL )? \" [Control] \" :\n                                       ((p_fp_info->is_uplink) ? \" [ULData] \" :\n                                                                 \" [DLData] \" ));\n\n    if (ft == FT_CONTROL) {\n        /* DCH control frame */\n        dissect_dch_control_frame(tree, pinfo, tvb, offset, p_fp_info);\n        /* For control frame the header CRC is actually frame CRC covering all\n         * bytes except the first */\n        if (preferences_header_checksum) {\n            verify_control_frame_crc(tvb, pinfo, header_crc_pi, (uint16_t)header_crc);\n        }\n    } else {\n        /************************/\n        /* DCH data here        */\n        int chan;\n        /* CFN */\n        proto_tree_add_item_ret_uint(tree, hf_fp_cfn, tvb, offset, 1, ENC_BIG_ENDIAN, &cfn);\n        offset++;\n\n        col_append_fstr(pinfo->cinfo, COL_INFO, \"CFN=%03u \", cfn);\n\n        /* One TFI for each channel */\n        for (chan=0; chan < p_fp_info->num_chans; chan++) {\n            proto_tree_add_item(tree, hf_fp_tfi, tvb, offset, 1, ENC_BIG_ENDIAN);\n            offset++;\n        }\n        header_length = offset;\n        /* Dissect TB data */\n        offset = dissect_tb_data(tvb, pinfo, tree, offset, p_fp_info, &mac_fdd_dch_handle, data);\n\n        /* QE and CRCI bits (uplink only) */\n        if (p_fp_info->is_uplink) {\n            proto_tree_add_item(tree, hf_fp_quality_estimate, tvb, offset, 1, ENC_BIG_ENDIAN);\n            offset++;\n            offset = dissect_crci_bits(tvb, pinfo, tree, p_fp_info, offset);\n        }\n\n        if (preferences_header_checksum) {\n            verify_header_crc(tvb, pinfo, header_crc_pi, header_crc, header_length);\n        }\n        /* Spare extension and payload CRC (optional) */\n        dissect_spare_extension_and_crc(tvb, pinfo, tree,\n                                        p_fp_info->dch_crc_present, offset, header_length);\n    }\n}\n\n/**********************************/\n/* Dissect an E-DCH channel       */\nstatic void\ndissect_e_dch_channel_info(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\n                           int offset, struct fp_info *p_fp_info,\n                           bool is_common,\n                           void *data)\n{\n    uint32_t ft;\n    uint8_t  number_of_subframes;\n    uint32_t cfn;\n    int      n;\n    struct   edch_t1_subframe_info subframes[16];\n    uint32_t header_crc = 0;\n    proto_item * header_crc_pi = NULL;\n    proto_item * item;\n    unsigned header_length;\n    rlc_info * rlcinf;\n\n    if (p_fp_info->edch_type == 1) {\n        col_append_str(pinfo->cinfo, COL_INFO, \" (T2)\");\n    }\n\n    /* Header CRC */\n     /* the bitmask doesn't properly handle this delicate case, do manually */\n    header_crc = (tvb_get_bits8(tvb, offset*8, 7) << 4) + tvb_get_bits8(tvb, offset*8+8, 4);\n\n    /* Frame Type */\n    ft = tvb_get_uint8(tvb, offset) & 0x01;\n\n    col_append_fstr(pinfo->cinfo, COL_INFO, \" [%s] \", val_to_str_const(ft, frame_type_vals, \"Unknown\"));\n\n    if (ft == FT_CONTROL) {\n        /* DCH control frame */\n\n        /* For control frame the header CRC is actually frame CRC covering all\n         * bytes except the first */\n        header_crc_pi = proto_tree_add_item_ret_uint(tree, hf_fp_header_crc, tvb, offset, 1, ENC_BIG_ENDIAN, &header_crc);\n        proto_tree_add_item(tree, hf_fp_ft, tvb, 0, 1, ENC_BIG_ENDIAN);\n        offset++;\n        if (preferences_header_checksum) {\n            verify_control_frame_crc(tvb, pinfo, header_crc_pi, (uint16_t)header_crc);\n        }\n        dissect_dch_control_frame(tree, pinfo, tvb, offset, p_fp_info);\n    }\n    else {\n        /********************************/\n        /* E-DCH data here              */\n        unsigned  bit_offset;\n        unsigned  total_pdus = 0;\n        unsigned  total_bits = 0;\n        bool dissected = false;\n\n        rlcinf = (rlc_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_umts_rlc, 0);\n        if (!rlcinf) {\n            rlcinf = wmem_new0(pinfo->pool, rlc_info);\n        }\n\n        header_crc_pi = proto_tree_add_uint_format(tree, hf_fp_edch_header_crc, tvb,\n                offset, 2, header_crc,\n                \"%u%u%u%u %u%u%u. %u%u%u%u .... = E-DCH Header CRC: 0x%x\",\n                (header_crc >> 10) & 1,\n                (header_crc >> 9) & 1,\n                (header_crc >> 8) & 1,\n                (header_crc >> 7) & 1,\n                (header_crc >> 6) & 1,\n                (header_crc >> 5) & 1,\n                (header_crc >> 4) & 1,\n                (header_crc >> 3) & 1,\n                (header_crc >> 2) & 1,\n                (header_crc >> 1) & 1,\n                (header_crc >> 0) & 1, header_crc);\n        proto_tree_add_item(tree, hf_fp_ft, tvb, offset, 1, ENC_BIG_ENDIAN);\n        offset++;\n        /* FSN */\n        proto_tree_add_item(tree, hf_fp_edch_fsn, tvb, offset, 1, ENC_BIG_ENDIAN);\n        offset++;\n\n        /* Number of subframes.\n           This was 3 bits in early releases, is 4 bits offset by 1 in later releases  */\n        if ((p_fp_info->release >= 6) &&\n            ((p_fp_info->release_year > 2005) ||\n             ((p_fp_info->release_year == 2005) && (p_fp_info->release_month >= 9)))) {\n\n            /* Use 4 bits plus offset of 1 */\n            number_of_subframes = (tvb_get_uint8(tvb, offset) & 0x0f) + 1;\n        }\n        else {\n            /* Use 3 bits only */\n            number_of_subframes = (tvb_get_uint8(tvb, offset) & 0x07);\n        }\n        proto_tree_add_uint(tree, hf_fp_edch_number_of_subframes, tvb, offset, 1,\n                            number_of_subframes);\n\n        offset++;\n\n        /* CFN */\n        proto_tree_add_item_ret_uint(tree, hf_fp_cfn, tvb, offset, 1, ENC_BIG_ENDIAN, &cfn);\n        offset++;\n\n        /* Remainder of T2 or common data frames differ here... */\n        if (p_fp_info->edch_type == 1) {\n            dissect_e_dch_t2_or_common_channel_info(tvb, pinfo, tree, offset, p_fp_info,\n                                                    number_of_subframes,\n                                                    is_common, header_crc,\n                                                    header_crc_pi, data);\n            return;\n        }\n\n        /* EDCH subframe header list */\n        for (n=0; n < number_of_subframes; n++) {\n            int i;\n            int start_offset = offset;\n            proto_item *subframe_header_ti;\n            proto_tree *subframe_header_tree;\n\n            /* Add subframe header subtree */\n            subframe_header_ti = proto_tree_add_string_format(tree, hf_fp_edch_subframe_header, tvb, offset, 0,\n                                                              \"\", \"Subframe\");\n            subframe_header_tree = proto_item_add_subtree(subframe_header_ti, ett_fp_edch_subframe_header);\n\n            /* Number of HARQ Retransmissions */\n            proto_tree_add_item(subframe_header_tree, hf_fp_edch_harq_retransmissions, tvb,\n                                offset, 1, ENC_BIG_ENDIAN);\n\n            /* Subframe number */\n            subframes[n].subframe_number = (tvb_get_uint8(tvb, offset) & 0x07);\n            proto_tree_add_bits_item(subframe_header_tree, hf_fp_edch_subframe_number, tvb,\n                                     offset*8+5, 3, ENC_BIG_ENDIAN);\n            offset++;\n\n            /* Number of MAC-es PDUs */\n            subframes[n].number_of_mac_es_pdus = (tvb_get_uint8(tvb, offset) & 0xf0) >> 4;\n            proto_tree_add_item(subframe_header_tree, hf_fp_edch_number_of_mac_es_pdus,\n                                tvb, offset, 1, ENC_BIG_ENDIAN);\n            bit_offset = 4;\n\n            proto_item_append_text(subframe_header_ti, \" %u header (%u MAC-es PDUs)\",\n                                   subframes[n].subframe_number,\n                                   subframes[n].number_of_mac_es_pdus);\n\n            /* Details of each MAC-es PDU */\n            for (i=0; i < subframes[n].number_of_mac_es_pdus; i++) {\n                uint64_t ddi;\n                uint64_t n_pdus;    /*Size of the PDU*/\n\n                proto_item *ddi_ti;\n                int ddi_size = -1;\n                int     p;\n\n                /* DDI (6 bits) */\n                ddi_ti = proto_tree_add_bits_ret_val(subframe_header_tree, hf_fp_edch_ddi, tvb,\n                                                     offset*8 + bit_offset, 6, &ddi, ENC_BIG_ENDIAN);\n\n                rlcinf->rbid[i] = (uint8_t)ddi;\n                /********************************/\n                /* Look up data in higher layers*/\n                /* Look up the size from this DDI value */\n                for (p=0; p < p_fp_info->no_ddi_entries; p++) {\n                    if (ddi == p_fp_info->edch_ddi[p]) {\n                        ddi_size = p_fp_info->edch_macd_pdu_size[p];\n\n                        break;\n                    }\n                }\n\n                if (ddi_size == -1) {\n                    expert_add_info_format(pinfo, ddi_ti, &ei_fp_ddi_not_defined, \"DDI %u not defined for this UE!\", (unsigned)ddi);\n                    return;\n                }\n                else {\n                    proto_item_append_text(ddi_ti, \" (%d bits)\", ddi_size);\n                }\n\n                subframes[n].ddi[i] = (uint8_t)ddi;\n                bit_offset += 6;\n\n                /* Number of MAC-d PDUs (6 bits) */\n                item = proto_tree_add_bits_ret_val(subframe_header_tree, hf_fp_edch_number_of_mac_d_pdus, tvb,\n                                            offset*8 + bit_offset, 6, &n_pdus, ENC_BIG_ENDIAN);\n                if (n_pdus > MAX_MAC_FRAMES) {\n                    expert_add_info_format(pinfo, item, &ei_fp_invalid_frame_count, \"Invalid number of PDUs (max is %u)\", MAX_MAC_FRAMES);\n                    return;\n                }\n\n                subframes[n].number_of_mac_d_pdus[i] = (uint8_t)n_pdus;\n                bit_offset += 6;\n            }\n\n            offset += ((bit_offset+7)/8);\n\n            /* Tree should cover entire subframe header */\n            proto_item_set_len(subframe_header_ti, offset - start_offset);\n        }\n        header_length = offset;\n        /* EDCH subframes */\n        for (n=0; n < number_of_subframes; n++) {\n            int i;\n            proto_item *subframe_ti;\n            proto_tree *subframe_tree;\n            unsigned bits_in_subframe = 0;\n            unsigned mac_d_pdus_in_subframe = 0;\n            unsigned lchid=0;    /*Logical channel id*/\n            uint32_t user_identity;\n            umts_mac_info *macinf;\n            bit_offset = 0;\n\n            macinf = (umts_mac_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_umts_mac, 0);\n            if (!macinf) {\n                macinf = wmem_new0(pinfo->pool, umts_mac_info);\n            }\n            /* Add subframe subtree */\n            subframe_ti = proto_tree_add_string_format(tree, hf_fp_edch_subframe, tvb, offset, 0,\n                                                       \"\", \"Subframe %u data\", subframes[n].subframe_number);\n            subframe_tree = proto_item_add_subtree(subframe_ti, ett_fp_edch_subframe);\n\n            for (i=0; i < subframes[n].number_of_mac_es_pdus; i++) {\n                int         m;\n                uint16_t    size = 0;\n                /* uint8_t     tsn; */\n                unsigned    send_size;\n                proto_item  *ti;\n                int         macd_idx;\n                proto_tree  *maces_tree = NULL;\n\n                /** TODO: Merge these two loops? **/\n                /* Look up mac-d pdu size for this ddi */\n                for (m=0; m < p_fp_info->no_ddi_entries; m++) {\n                    if (subframes[n].ddi[i] == p_fp_info->edch_ddi[m]) {\n                        size = p_fp_info->edch_macd_pdu_size[m];\n                        break;\n                    }\n                }\n                /* Look up logicalchannel id for this DDI value */\n                for (m=0; m < p_fp_info->no_ddi_entries; m++) {\n                    if (subframes[n].ddi[i] == p_fp_info->edch_ddi[m]) {\n                        lchid = p_fp_info->edch_lchId[m];\n                        break;\n                    }\n                }\n\n                if (m == p_fp_info->no_ddi_entries) {\n                    /* Not found.  Oops */\n                    expert_add_info(pinfo, NULL, &ei_fp_unable_to_locate_ddi_entry);\n                    return;\n                }\n\n                /* Send MAC-dd PDUs together as one MAC-es PDU */\n                send_size = size * subframes[n].number_of_mac_d_pdus[i];\n\n                /* 2 bits spare */\n                proto_tree_add_item(subframe_tree, hf_fp_edch_pdu_padding, tvb,\n                                    offset + (bit_offset/8),\n                                    1, ENC_BIG_ENDIAN);\n                bit_offset += 2;\n\n                /* TSN */\n                /* tsn = (tvb_get_uint8(tvb, offset + (bit_offset/8)) & 0x3f); */\n                proto_tree_add_item(subframe_tree, hf_fp_edch_tsn, tvb,\n                                    offset + (bit_offset/8),\n                                    1, ENC_BIG_ENDIAN);\n                bit_offset += 6;\n\n                /* PDU */\n                if (subframe_tree) {\n                    ti = proto_tree_add_item(subframe_tree, hf_fp_edch_mac_es_pdu, tvb,\n                                             offset + (bit_offset/8),\n                                             ((bit_offset % 8) + send_size + 7) / 8,\n                                             ENC_NA);\n                    proto_item_append_text(ti, \" (%u * %u = %u bits, PDU %d)\",\n                                           size, subframes[n].number_of_mac_d_pdus[i],\n                                           send_size, n);\n                    maces_tree = proto_item_add_subtree(ti, ett_fp_edch_maces);\n                }\n                /* Determine the UE ID to use in RLC */\n                user_identity = p_fp_info->com_context_id;\n                if(p_fp_info->urnti) {\n                    user_identity = p_fp_info->urnti;\n                }\n                for (macd_idx = 0; macd_idx < subframes[n].number_of_mac_d_pdus[i]; macd_idx++) {\n\n                    if (preferences_call_mac_dissectors) {\n                        /* Should no longer happen ??*/\n                        if (macd_idx >= MAX_MAC_FRAMES) {\n                            expert_add_info_format(pinfo, subframe_tree, &ei_fp_invalid_frame_count, \"Invalid frame count (max is %u)\", MAX_MAC_FRAMES);\n                            return;\n                        }\n\n                        tvbuff_t *next_tvb;\n                        /* create new TVB and pass further on */\n                        next_tvb = tvb_new_subset_length(tvb, offset + bit_offset/8,\n                                ((bit_offset % 8) + size + 7) / 8);\n\n                        /*Set up information needed for MAC and lower layers*/\n                        macinf->content[macd_idx] = lchId_type_table[lchid];     /*Set the proper Content type for the mac layer.*/\n                        macinf->lchid[macd_idx] = lchid;\n                        rlcinf->mode[macd_idx] = lchId_rlc_map[lchid]; /* Set RLC mode by lchid to RLC_MODE map in nbap.h */\n\n                        /* Set UE ID to U-RNTI or NBAP Communication Context*/\n                        rlcinf->ueid[macd_idx] = user_identity;\n                        rlcinf->rbid[macd_idx] = lchid;\n                        rlcinf->li_size[macd_idx] = RLC_LI_7BITS;\n\n                        rlcinf->ciphered[macd_idx] = false;\n                        rlcinf->deciphered[macd_idx] = false;\n                        p_fp_info->cur_tb = macd_idx;    /*Set the transport block index */\n\n                        call_dissector_with_data(mac_fdd_edch_handle, next_tvb, pinfo, top_level_tree, data);\n                        dissected = true;\n                    }\n                    else {\n                        /* Just add as a MAC-d PDU */\n                        proto_tree_add_item(maces_tree, hf_fp_mac_d_pdu, tvb,\n                                            offset + (bit_offset/8),\n                                            ((bit_offset % 8) + size + 7) / 8,\n                                            ENC_NA);\n                    }\n                    bit_offset += size;\n                }\n\n                bits_in_subframe += send_size;\n                mac_d_pdus_in_subframe += subframes[n].number_of_mac_d_pdus[i];\n\n                /* Pad out to next byte */\n                bit_offset = WS_ROUNDUP_8(bit_offset);\n            }\n\n            if (tree) {\n                /* Tree should cover entire subframe */\n                proto_item_set_len(subframe_ti, bit_offset/8);\n                /* Append summary info to subframe label */\n                proto_item_append_text(subframe_ti, \" (%u bits in %u MAC-d PDUs)\",\n                                       bits_in_subframe, mac_d_pdus_in_subframe);\n            }\n            total_pdus += mac_d_pdus_in_subframe;\n            total_bits += bits_in_subframe;\n\n            offset += (bit_offset/8);\n        }\n\n        /* Report number of subframes in info column\n         * do this only if no other dissector was called */\n        if (dissected == false) {\n            col_append_fstr(pinfo->cinfo, COL_INFO,\n                            \" CFN = %03u   (%u bits in %u pdus in %u subframes)\",\n                            cfn, total_bits, total_pdus, number_of_subframes);\n        }\n        /* Add data summary to info column */\n        /*col_append_fstr(pinfo->cinfo, COL_INFO, \" (%u bytes in %u SDUs in %u MAC-is PDUs in %u subframes)\",\n                        total_bytes, macis_sdus_found, macis_pdus, number_of_subframes);*/\n        if (preferences_header_checksum) {\n            verify_header_crc_edch(tvb, pinfo, header_crc_pi, header_crc, header_length);\n        }\n        /* Spare extension and payload CRC (optional) */\n        dissect_spare_extension_and_crc(tvb, pinfo, tree,\n                                        p_fp_info->dch_crc_present, offset, header_length);\n    }\n}\n\n/* Dissect the remainder of the T2 or common frame that differs from T1 */\nstatic void\ndissect_e_dch_t2_or_common_channel_info(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\n                                        int offset, struct fp_info *p_fp_info,\n                                        int number_of_subframes,\n                                        bool is_common,\n                                        uint16_t header_crc,\n                                        proto_item * header_crc_pi,\n                                        void *data)\n{\n    int      n;\n    int      pdu_no;\n    uint64_t total_macis_sdus;\n    uint16_t macis_sdus_found = 0;\n    /* uint16_t macis_pdus       = 0; */\n    bool F                = true; /* We want to continue loop if get E-RNTI indication... */\n    int      bit_offset;\n    proto_item *subframe_macis_descriptors_ti = NULL;\n    static struct edch_t2_subframe_info subframes[16];\n    unsigned header_length = 0;\n    /* User Buffer size */\n    proto_tree_add_bits_item(tree, hf_fp_edch_user_buffer_size, tvb, offset*8,\n                             18, ENC_BIG_ENDIAN);\n    offset += 2;\n\n    /* Spare is in-between... */\n\n    /* Total number of MAC-is SDUs */\n    proto_tree_add_bits_ret_val(tree, hf_fp_edch_no_macid_sdus, tvb, offset*8+4,\n                                12, &total_macis_sdus, ENC_BIG_ENDIAN);\n    offset += 2;\n\n    if (is_common) {\n        /* E-RNTI */\n        proto_tree_add_item(tree, hf_fp_edch_e_rnti, tvb, offset, 2, ENC_BIG_ENDIAN);\n        offset += 2;\n    }\n\n    bit_offset = offset*8;\n    /* EDCH subframe header list */\n    for (n=0; n < number_of_subframes; n++) {\n        uint64_t   subframe_number;\n        uint64_t   no_of_macis_pdus;\n        proto_item *subframe_header_ti;\n        proto_tree *subframe_header_tree;\n\n        /* Add subframe header subtree */\n        subframe_header_ti = proto_tree_add_string_format(tree, hf_fp_edch_subframe_header, tvb, offset, 0,\n                                                          \"\", \"Subframe\");\n        subframe_header_tree = proto_item_add_subtree(subframe_header_ti, ett_fp_edch_subframe_header);\n\n        /* Spare bit */\n        bit_offset++;\n\n        if (!is_common) {\n            /* Number of HARQ Retransmissions */\n            proto_tree_add_item(subframe_header_tree, hf_fp_edch_harq_retransmissions, tvb,\n                                bit_offset/8, 1, ENC_BIG_ENDIAN);\n            bit_offset += 4;\n        }\n\n        /* Subframe number */\n        proto_tree_add_bits_ret_val(subframe_header_tree, hf_fp_edch_subframe_number, tvb,\n                                    bit_offset, 3, &subframe_number, ENC_BIG_ENDIAN);\n        subframes[n].subframe_number = (uint8_t)subframe_number;\n        bit_offset += 3;\n\n        /* Number of MAC-is PDUs */\n        proto_tree_add_bits_ret_val(subframe_header_tree, hf_fp_edch_number_of_mac_is_pdus, tvb,\n                                    bit_offset, 4, &no_of_macis_pdus, ENC_BIG_ENDIAN);\n        bit_offset += 4;\n        subframes[n].number_of_mac_is_pdus = (uint8_t)no_of_macis_pdus;\n        /* macis_pdus += subframes[n].number_of_mac_is_pdus; */\n\n        /* Next 4 bits are spare for T2*/\n        if (!is_common) {\n            bit_offset += 4;\n        }\n\n        /* Show summary in root */\n        proto_item_append_text(subframe_header_ti, \" (SFN %u, %u MAC-is PDUs)\",\n                               subframes[n].subframe_number, subframes[n].number_of_mac_is_pdus);\n        proto_item_set_len(subframe_header_ti, is_common ? 1 : 2);\n    }\n    offset = bit_offset / 8;\n\n\n    /* MAC-is PDU descriptors for each subframe follow */\n    for (n=0; n < number_of_subframes; n++) {\n        proto_tree *subframe_macis_descriptors_tree;\n\n        /* Add subframe header subtree */\n        subframe_macis_descriptors_ti = proto_tree_add_string_format(tree, hf_fp_edch_macis_descriptors, tvb, offset, 0,\n                                                                     \"\", \"MAC-is descriptors (SFN %u)\", subframes[n].subframe_number);\n        proto_item_set_len(subframe_macis_descriptors_ti, subframes[n].number_of_mac_is_pdus*2);\n        subframe_macis_descriptors_tree = proto_item_add_subtree(subframe_macis_descriptors_ti,\n                                                                 ett_fp_edch_macis_descriptors);\n\n        /* Find a sequence of descriptors for each MAC-is PDU in this subframe */\n        for (pdu_no=0; pdu_no < subframes[n].number_of_mac_is_pdus; pdu_no++) {\n            proto_item *f_ti = NULL;\n\n            subframes[n].number_of_mac_is_sdus[pdu_no] = 0;\n\n            do {\n                /* Check we haven't gone past the limit */\n                if (macis_sdus_found++ > total_macis_sdus) {\n                    expert_add_info_format(pinfo, f_ti, &ei_fp_mac_is_sdus_miscount, \"Found too many (%u) MAC-is SDUs - header said there were %u\", macis_sdus_found, (uint16_t)total_macis_sdus);\n                }\n\n                /* LCH-ID */\n                subframes[n].mac_is_lchid[pdu_no][subframes[n].number_of_mac_is_sdus[pdu_no]] = (tvb_get_uint8(tvb, offset) & 0xf0) >> 4;\n                proto_tree_add_item(subframe_macis_descriptors_tree, hf_fp_edch_macis_lchid, tvb, offset, 1, ENC_BIG_ENDIAN);\n                if (subframes[n].mac_is_lchid[pdu_no][subframes[n].number_of_mac_is_sdus[pdu_no]] == 15) {\n                    proto_item *ti;\n\n                    /* 4 bits of spare */\n                    offset++;\n\n                    /* E-RNTI */\n                    ti = proto_tree_add_item(tree, hf_fp_edch_e_rnti, tvb, offset, 2, ENC_BIG_ENDIAN);\n                    offset += 2;\n\n                    /* This is only allowed if:\n                       - it's the common case AND\n                       - it's the first descriptor */\n                    if (!is_common) {\n                        expert_add_info(pinfo, ti, &ei_fp_e_rnti_t2_edch_frames);\n                    }\n                    if (subframes[n].number_of_mac_is_sdus[pdu_no] > 0) {\n                        expert_add_info(pinfo, ti, &ei_fp_e_rnti_first_entry);\n                    }\n                    continue;\n                }\n\n                /* Length */\n                subframes[n].mac_is_length[pdu_no][subframes[n].number_of_mac_is_sdus[pdu_no]] = (tvb_get_ntohs(tvb, offset) & 0x0ffe) >> 1;\n                proto_tree_add_item(subframe_macis_descriptors_tree, hf_fp_edch_macis_length, tvb, offset, 2, ENC_BIG_ENDIAN);\n                offset++;\n\n                /* Flag */\n                F = tvb_get_uint8(tvb, offset) & 0x01;\n                f_ti = proto_tree_add_item(subframe_macis_descriptors_tree, hf_fp_edch_macis_flag, tvb, offset, 1, ENC_BIG_ENDIAN);\n\n                subframes[n].number_of_mac_is_sdus[pdu_no]++;\n\n                offset++;\n            } while (F == 0);\n        }\n    }\n\n    /* Check overall count of MAC-is SDUs */\n    if (macis_sdus_found != total_macis_sdus) {\n        expert_add_info_format(pinfo, subframe_macis_descriptors_ti, &ei_fp_mac_is_sdus_miscount, \"Frame contains %u MAC-is SDUs - header said there would be %u!\", macis_sdus_found, (uint16_t)total_macis_sdus);\n    }\n    header_length = offset;\n    /* Now PDUs */\n    for (n=0; n < number_of_subframes; n++) {\n\n        /* MAC-is PDU */\n        for (pdu_no=0; pdu_no < subframes[n].number_of_mac_is_pdus; pdu_no++) {\n            int i;\n            unsigned length = 0;\n            umts_mac_is_info * mac_is_info = wmem_new(wmem_file_scope(), umts_mac_is_info);\n\n            mac_is_info->number_of_mac_is_sdus = subframes[n].number_of_mac_is_sdus[pdu_no];\n            DISSECTOR_ASSERT(subframes[n].number_of_mac_is_sdus[pdu_no] <= MAX_MAC_FRAMES);\n            for (i = 0; i < subframes[n].number_of_mac_is_sdus[pdu_no]; i++) {\n                mac_is_info->sdulength[i] = subframes[n].mac_is_length[pdu_no][i];\n                mac_is_info->lchid[i] = subframes[n].mac_is_lchid[pdu_no][i];\n                length += subframes[n].mac_is_length[pdu_no][i];\n            }\n\n            /* Call MAC for this PDU if configured to */\n            if (preferences_call_mac_dissectors) {\n                p_add_proto_data(wmem_file_scope(), pinfo, proto_umts_mac, 0, mac_is_info);\n                call_dissector_with_data(mac_fdd_edch_type2_handle, tvb_new_subset_remaining(tvb, offset), pinfo, top_level_tree, data);\n            }\n            else {\n                /* Still show data if not decoding as MAC PDU */\n                proto_tree_add_item(tree, hf_fp_edch_mac_is_pdu, tvb, offset, length, ENC_NA);\n            }\n\n            /* get_mac_tsn_size in packet-umts_mac.h, gets the global_mac_tsn_size preference in umts_mac.c */\n            if (get_mac_tsn_size() == MAC_TSN_14BITS) {\n                offset += length + 2; /* Plus 2 bytes for TSN 14 bits and SS 2 bit. */\n            } else {\n                offset += length + 1; /* Plus 1 byte for TSN 6 bits and SS 2 bit. */\n            }\n        }\n    }\n    if (preferences_header_checksum) {\n        verify_header_crc_edch(tvb, pinfo, header_crc_pi, header_crc, header_length);\n    }\n    /* Spare extension and payload CRC (optional) */\n    dissect_spare_extension_and_crc(tvb, pinfo, tree,\n                                    p_fp_info->dch_crc_present, offset, header_length);\n}\n\n\n\n/**********************************************************/\n/* Dissect an HSDSCH channel                              */\n/* The data format corresponds to the format              */\n/* described in R5 and R6, and frame type 1 in Release 7. */\nstatic void\ndissect_hsdsch_channel_info(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\n                            int offset, struct fp_info *p_fp_info, void *data)\n{\n    uint32_t ft;\n    unsigned header_length;\n    uint32_t header_crc = 0;\n    proto_item * header_crc_pi = NULL;\n\n    /* Header CRC */\n    header_crc_pi = proto_tree_add_item_ret_uint(tree, hf_fp_header_crc, tvb, offset, 1, ENC_BIG_ENDIAN, &header_crc);\n\n    /* Frame Type */\n    proto_tree_add_item_ret_uint(tree, hf_fp_ft, tvb, offset, 1, ENC_BIG_ENDIAN, &ft);\n    offset++;\n\n    col_append_fstr(pinfo->cinfo, COL_INFO, \" [%s] \", val_to_str_const(ft, frame_type_vals, \"Unknown\"));\n\n    if (ft == FT_CONTROL) {\n        dissect_common_control(tvb, pinfo, tree, offset, p_fp_info);\n        /* For control frame the header CRC is actually frame CRC covering all\n         * bytes except the first */\n        if (preferences_header_checksum) {\n            verify_control_frame_crc(tvb, pinfo, header_crc_pi, (uint16_t)header_crc);\n        }\n    }\n    else {\n        uint8_t number_of_pdus;\n        uint16_t pdu_length;\n        uint16_t user_buffer_size;\n        int i;\n        umts_mac_info *macinf;\n        rlc_info *rlcinf;\n        uint32_t user_identity;\n        proto_item *item;\n\n        rlcinf = (rlc_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_umts_rlc, 0);\n        if (!rlcinf) {\n            rlcinf = wmem_new0(pinfo->pool, rlc_info);\n        }\n        macinf = (umts_mac_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_umts_mac, 0);\n        if (!macinf) {\n            macinf = wmem_new0(pinfo->pool, umts_mac_info);\n        }\n\n        /**************************************/\n        /* HS-DCH data here (type 1 in R7)    */\n\n        /* Frame Seq Nr */\n        if ((p_fp_info->release == 6) ||\n            (p_fp_info->release == 7)) {\n\n            uint8_t frame_seq_no = (tvb_get_uint8(tvb, offset) & 0xf0) >> 4;\n            proto_tree_add_item(tree, hf_fp_frame_seq_nr, tvb, offset, 1, ENC_BIG_ENDIAN);\n\n            col_append_fstr(pinfo->cinfo, COL_INFO, \"  seqno=%u\", frame_seq_no);\n        }\n\n        /* CmCH-PI */\n        proto_tree_add_item(tree, hf_fp_cmch_pi, tvb, offset, 1, ENC_BIG_ENDIAN);\n        offset++;\n\n        /* MAC-d PDU Length (13 bits) */\n        pdu_length = (tvb_get_ntohs(tvb, offset) >> 3);\n        proto_tree_add_item(tree, hf_fp_mac_d_pdu_len, tvb, offset, 2, ENC_BIG_ENDIAN);\n        offset += 2;\n        macinf->pdu_len = pdu_length;\n\n        if ((p_fp_info->release == 6) ||\n            (p_fp_info->release == 7)) {\n\n            /* Flush bit */\n            proto_tree_add_item(tree, hf_fp_flush, tvb, offset-1, 1, ENC_BIG_ENDIAN);\n\n            /* FSN/DRT reset bit */\n            proto_tree_add_item(tree, hf_fp_fsn_drt_reset, tvb, offset-1, 1, ENC_BIG_ENDIAN);\n        }\n\n        /* Num of PDUs */\n        number_of_pdus = tvb_get_uint8(tvb, offset);\n        item = proto_tree_add_item(tree, hf_fp_num_of_pdu, tvb, offset, 1, ENC_BIG_ENDIAN);\n        offset++;\n        if (number_of_pdus > MAX_MAC_FRAMES) {\n            expert_add_info_format(pinfo, item, &ei_fp_invalid_frame_count, \"Invalid number of PDUs (max is %u)\", MAX_MAC_FRAMES);\n            return;\n        }\n\n        /* User buffer size */\n        user_buffer_size = tvb_get_ntohs(tvb, offset);\n        proto_tree_add_item(tree, hf_fp_user_buffer_size, tvb, offset, 2, ENC_BIG_ENDIAN);\n        offset += 2;\n\n        header_length = offset;\n\n\n        /* Determine the UE ID to use in RLC */\n        user_identity = p_fp_info->com_context_id;\n        if(p_fp_info->urnti) {\n            user_identity = p_fp_info->urnti;\n        }\n        /************************/\n        /*Configure the pdus*/\n        for (i=0;i<number_of_pdus && i<MIN(MAX_MAC_FRAMES, MAX_RLC_CHANS); i++) {\n            macinf->content[i] = hsdsch_macdflow_id_mac_content_map[p_fp_info->hsdsch_macflowd_id]; /*MAC_CONTENT_PS_DTCH;*/\n            macinf->lchid[i] = fake_lchid_macd_flow[p_fp_info->hsdsch_macflowd_id];/*Faked logical channel id 255 used as a mark if it doesn't exist...*/\n            macinf->fake_chid[i] = true;    /**/\n            macinf->macdflow_id[i] = p_fp_info->hsdsch_macflowd_id;    /*Save the flow ID (+1 to make it human readable (it's zero indexed!))*/\n\n            /*Check if this is multiplexed (signaled by RRC)*/\n            if (p_fp_info->hsdhsch_macfdlow_is_mux[p_fp_info->hsdsch_macflowd_id] ) {\n                macinf->ctmux[i] = true;\n            } else if (p_fp_info->hsdsch_macflowd_id == 0) {              /*MACd-flow = 0 is often SRB */\n                expert_add_info(pinfo, NULL, &ei_fp_maybe_srb);\n            } else {\n                    macinf->ctmux[i] = false;    /*Either it's multiplexed and not signalled or it's not MUX*/\n            }\n\n            /* Figure out RLC mode */\n            if(p_fp_info->hsdsch_rlc_mode != FP_RLC_MODE_UNKNOWN) {\n                /* We know the RLC mode, possibly reported from NBAP */\n                rlcinf->mode[i] = (enum rlc_mode)(p_fp_info->hsdsch_rlc_mode - 1);\n            }\n            else {\n                /* Guess the mode by the MACd-flow-ID, basically MACd-flow-ID = 0 then it's SRB0 == UM else AM */\n                /* This logic might be incorrect sometimes */\n                rlcinf->mode[i] = hsdsch_macdflow_id_rlc_map[p_fp_info->hsdsch_macflowd_id];\n            }\n\n            rlcinf->ueid[i] = user_identity;\n            rlcinf->li_size[i] = RLC_LI_7BITS;\n            rlcinf->deciphered[i] = false;\n            rlcinf->ciphered[i] = false;\n            rlcinf->rbid[i] = macinf->lchid[i];\n\n#if 0\n            /*When a flow has been reconfigured rlc needs to be reset.\n             * This needs more work though since we must figure out when the re-configuration becomes\n             * active based on the CFN value\n             * */\n            /*Indicate we need to reset stream*/\n            if (p_fp_info->reset_frag) {\n                rlc_reset_channel(rlcinf->mode[i], macinf->lchid[i], p_fp_info->is_uplink,  rlcinf->ueid[i] );\n                p_fp_info->reset_frag = false;\n\n            }\n#endif\n        }\n\n        col_append_fstr(pinfo->cinfo, COL_INFO, \"  %ux%u-bit PDUs  User-Buffer-Size=%u\",\n                        number_of_pdus, pdu_length, user_buffer_size);\n\n        /* MAC-d PDUs */\n        offset = dissect_macd_pdu_data(tvb, pinfo, tree, offset, pdu_length,\n                                       number_of_pdus, p_fp_info, data);\n\n        /* Extra IEs (if there is room for them) */\n        if (((p_fp_info->release == 6) ||\n             (p_fp_info->release == 7)) &&\n            (tvb_reported_length_remaining(tvb, offset) > 2)) {\n\n            int n;\n            uint8_t flags;\n            /* uint8_t flag_bytes = 0; */\n\n            /* New IE flags */\n            do {\n                proto_item *new_ie_flags_ti;\n                proto_tree *new_ie_flags_tree;\n                unsigned ies_found = 0;\n\n                /* Add new IE flags subtree */\n                new_ie_flags_ti = proto_tree_add_string_format(tree, hf_fp_hsdsch_new_ie_flags, tvb, offset, 1,\n                                                              \"\", \"New IE flags\");\n                new_ie_flags_tree = proto_item_add_subtree(new_ie_flags_ti, ett_fp_hsdsch_new_ie_flags);\n\n                /* Read next byte */\n                flags = tvb_get_uint8(tvb, offset);\n                /* flag_bytes++; */\n\n                /* Dissect individual bits */\n                for (n=0; n < 8; n++) {\n                    proto_tree_add_item(new_ie_flags_tree, hf_fp_hsdsch_new_ie_flag[n], tvb, offset, 1, ENC_BIG_ENDIAN);\n                    if ((flags >> (7-n)) & 0x01) {\n                        ies_found++;\n                    }\n                }\n                offset++;\n\n                proto_item_append_text(new_ie_flags_ti, \" (%u IEs found)\", ies_found);\n\n                /* Last bit set will indicate another flags byte follows... */\n            } while (0); /*((flags & 0x01) && (flag_bytes < 31));*/\n\n            if (1) /*(flags & 0x8) */ {\n                /* DRT is shown as mandatory in the diagram (3GPP TS 25.435 V6.3.0),\n                   but the description below it states that\n                   it should depend upon the first bit.  The detailed description of\n                   New IE flags doesn't agree, so treat as mandatory for now... */\n                proto_tree_add_item(tree, hf_fp_hsdsch_drt, tvb, offset, 2, ENC_BIG_ENDIAN);\n                offset += 2;\n            }\n        }\n        if (preferences_header_checksum) {\n            verify_header_crc(tvb, pinfo, header_crc_pi, header_crc, header_length);\n        }\n        /* Spare Extension and Payload CRC */\n        dissect_spare_extension_and_crc(tvb, pinfo, tree, 1, offset, header_length);\n    }\n}\n\n\n/******************************************/\n/* Dissect an HSDSCH type 2 channel       */\n/* (introduced in Release 7)              */\n/* N.B. there is currently no support for */\n/* frame type 3 (IuR only?)               */\nstatic void\ndissect_hsdsch_type_2_channel_info(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\n                                   int offset, struct fp_info *p_fp_info,\n                                   void *data)\n{\n    uint32_t ft;\n    uint32_t header_crc = 0;\n    proto_item * header_crc_pi = NULL;\n    uint16_t header_length;\n\n    /* Header CRC */\n    header_crc_pi = proto_tree_add_item_ret_uint(tree, hf_fp_header_crc, tvb, offset, 1, ENC_BIG_ENDIAN, &header_crc);\n\n    /* Frame Type */\n    proto_tree_add_item_ret_uint(tree, hf_fp_ft, tvb, offset, 1, ENC_BIG_ENDIAN, &ft);\n    offset++;\n\n    col_append_fstr(pinfo->cinfo, COL_INFO, \" [%s] \", val_to_str_const(ft, frame_type_vals, \"Unknown\"));\n\n    if (ft == FT_CONTROL) {\n        dissect_common_control(tvb, pinfo, tree, offset, p_fp_info);\n        /* For control frame the header CRC is actually frame CRC covering all\n         * bytes except the first */\n        if (preferences_header_checksum) {\n            verify_control_frame_crc(tvb, pinfo, header_crc_pi, (uint16_t)header_crc);\n        }\n    }\n    else {\n        uint8_t number_of_pdu_blocks;\n        bool drt_present = false;\n        bool fach_present = false;\n        uint16_t user_buffer_size;\n        int n;\n        unsigned j;\n        uint64_t lchid_val;\n\n        #define MAX_PDU_BLOCKS 31\n        uint64_t lchid_field[MAX_PDU_BLOCKS];\n        uint64_t pdu_length[MAX_PDU_BLOCKS];\n        uint64_t no_of_pdus[MAX_PDU_BLOCKS];\n\n        umts_mac_info *macinf;\n        rlc_info *rlcinf;\n        uint32_t user_identity;\n\n        rlcinf = (rlc_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_umts_rlc, 0);\n        if (!rlcinf) {\n            rlcinf = wmem_new0(pinfo->pool, rlc_info);\n        }\n        macinf = (umts_mac_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_umts_mac, 0);\n        if (!macinf) {\n            macinf = wmem_new0(pinfo->pool, umts_mac_info);\n        }\n\n        /********************************/\n        /* HS-DCH type 2 data here      */\n\n        col_append_str(pinfo->cinfo, COL_INFO, \"(ehs)\");\n\n        /* Frame Seq Nr (4 bits) */\n        if ((p_fp_info->release == 6) ||\n            (p_fp_info->release == 7)) {\n\n            uint8_t frame_seq_no = (tvb_get_uint8(tvb, offset) & 0xf0) >> 4;\n            proto_tree_add_item(tree, hf_fp_frame_seq_nr, tvb, offset, 1, ENC_BIG_ENDIAN);\n\n            col_append_fstr(pinfo->cinfo, COL_INFO, \"  seqno=%u\", frame_seq_no);\n        }\n\n        /* CmCH-PI (4 bits) */\n        proto_tree_add_item(tree, hf_fp_cmch_pi, tvb, offset, 1, ENC_BIG_ENDIAN);\n        offset++;\n\n        /* Total number of PDU blocks (5 bits) */\n        number_of_pdu_blocks = (tvb_get_uint8(tvb, offset) >> 3);\n        proto_tree_add_item(tree, hf_fp_total_pdu_blocks, tvb, offset, 1, ENC_BIG_ENDIAN);\n\n        if (p_fp_info->release == 7) {\n            /* Flush bit */\n            proto_tree_add_item(tree, hf_fp_flush, tvb, offset, 1, ENC_BIG_ENDIAN);\n\n            /* FSN/DRT reset bit */\n            proto_tree_add_item(tree, hf_fp_fsn_drt_reset, tvb, offset, 1, ENC_BIG_ENDIAN);\n\n            /* DRT Indicator */\n            drt_present = tvb_get_uint8(tvb, offset) & 0x01;\n            proto_tree_add_item(tree, hf_fp_drt_indicator, tvb, offset, 1, ENC_BIG_ENDIAN);\n        }\n        offset++;\n\n        /* FACH Indicator flag */\n        fach_present = (tvb_get_uint8(tvb, offset) & 0x80) >> 7;\n        proto_tree_add_item(tree, hf_fp_fach_indicator, tvb, offset, 1, ENC_BIG_ENDIAN);\n        offset++;\n\n        /* User buffer size */\n        user_buffer_size = tvb_get_ntohs(tvb, offset);\n        proto_tree_add_item(tree, hf_fp_user_buffer_size, tvb, offset, 2, ENC_BIG_ENDIAN);\n        offset += 2;\n\n        col_append_fstr(pinfo->cinfo, COL_INFO, \"  User-Buffer-Size=%u\", user_buffer_size);\n\n\n\n        /********************************************************************/\n        /* Now read number_of_pdu_blocks header entries                     */\n        for (n=0; n < number_of_pdu_blocks; n++) {\n            proto_item *pdu_block_header_ti;\n            proto_tree *pdu_block_header_tree;\n            int        block_header_start_offset = offset;\n\n            /* Add PDU block header subtree */\n            pdu_block_header_ti = proto_tree_add_string_format(tree, hf_fp_hsdsch_pdu_block_header,\n                                                               tvb, offset, 0,\n                                                               \"\",\n                                                               \"PDU Block Header\");\n            pdu_block_header_tree = proto_item_add_subtree(pdu_block_header_ti,\n                                                           ett_fp_hsdsch_pdu_block_header);\n\n            /* MAC-d/c PDU length in this block (11 bits) */\n            proto_tree_add_bits_ret_val(pdu_block_header_tree, hf_fp_pdu_length_in_block, tvb,\n                                        (offset*8) + ((n % 2) ? 4 : 0), 11,\n                                        &pdu_length[n], ENC_BIG_ENDIAN);\n            if ((n % 2) == 0)\n                offset++;\n            else\n                offset += 2;\n\n\n            /* # PDUs in this block (4 bits) */\n            proto_tree_add_bits_ret_val(pdu_block_header_tree, hf_fp_pdus_in_block, tvb,\n                                        (offset*8) + ((n % 2) ? 0 : 4), 4,\n                                        &no_of_pdus[n], ENC_BIG_ENDIAN);\n            if ((n % 2) == 0) {\n                offset++;\n            }\n\n            /* Logical channel ID in block (4 bits) */\n            proto_tree_add_bits_ret_val(pdu_block_header_tree, hf_fp_lchid, tvb,\n                                        (offset*8) + ((n % 2) ? 4 : 0), 4,\n                                        &lchid_field[n], ENC_BIG_ENDIAN);\n            if ((n % 2) == 1) {\n                offset++;\n            }\n            else {\n                if (n == (number_of_pdu_blocks-1)) {\n                    /* Byte is padded out for last block */\n                    offset++;\n                }\n            }\n\n            /* Append summary to header tree root */\n            proto_item_append_text(pdu_block_header_ti,\n                                   \" (lch:%u, %u pdus of %u bytes)\",\n                                   (uint16_t)lchid_field[n],\n                                   (uint16_t)no_of_pdus[n],\n                                   (uint16_t)pdu_length[n]);\n\n            /* Set length of header tree item */\n            if (((n % 2) == 0) && (n < (number_of_pdu_blocks-1))) {\n                proto_item_set_len(pdu_block_header_ti,\n                                   offset - block_header_start_offset+1);\n            }\n            else {\n                proto_item_set_len(pdu_block_header_ti,\n                                   offset - block_header_start_offset);\n            }\n        }\n\n        header_length = offset;\n\n        /**********************************************/\n        /* Optional fields indicated by earlier flags */\n        if (drt_present) {\n            /* DRT */\n            proto_tree_add_item(tree, hf_fp_drt, tvb, offset, 2, ENC_BIG_ENDIAN);\n            offset += 2;\n        }\n\n        if (fach_present) {\n            /* H-RNTI: */\n            proto_tree_add_item(tree, hf_fp_hrnti, tvb, offset, 2, ENC_BIG_ENDIAN);\n            offset += 2;\n\n            /* RACH Measurement Result */\n            proto_tree_add_item(tree, hf_fp_rach_measurement_result, tvb, offset, 2, ENC_BIG_ENDIAN);\n            offset++;\n        }\n\n\n        /* Determine the UE ID to use in RLC */\n        user_identity = p_fp_info->com_context_id;\n        if(p_fp_info->urnti) {\n            user_identity = p_fp_info->urnti;\n        }\n        /********************************************************************/\n        /* Now read the MAC-d/c PDUs for each block using info from headers */\n        for (n=0; n < number_of_pdu_blocks; n++) {\n            for (j=0;j<no_of_pdus[n];j++) {\n\n                /*Configure (signal to lower layers) the PDU!*/\n                if (lchid_field[n] != 0x0f) {\n                    lchid_val = lchid_field[n] + 1; /* Add 1 since 'LCHID' field is zero indexed. ie field value = 0 => Actual L-CHID = 1*/\n                    macinf->content[j] = lchId_type_table[lchid_val];\n                    macinf->lchid[j] = (uint8_t)lchid_val;\n                    macinf->macdflow_id[j] = p_fp_info->hsdsch_macflowd_id;\n                    /*Figure out RLC_MODE based on MACd-flow-ID, basically MACd-flow-ID = 0 then it's SRB0 == UM else AM*/\n                    rlcinf->mode[j] = lchId_rlc_map[lchid_val];\n\n                    macinf->ctmux[n] = false;\n\n                    rlcinf->li_size[j] = RLC_LI_7BITS;\n                    rlcinf->ciphered[j] = false;\n                    rlcinf->deciphered[j] = false;\n                    rlcinf->rbid[j] = (uint8_t)lchid_val;\n\n                    rlcinf->ueid[j] = user_identity;\n                }\n                else {\n                    /* LCHID field is 15. This value indicates BCCH or PCCH mapped on HS-DSCH*/\n                    /* The dissector does not handle this case yet, so we are filling zeroes and default values below*/\n                    macinf->content[j] = MAC_CONTENT_UNKNOWN;\n                    macinf->lchid[j] = 0; /* LCHID field doesn't reflect a real ID in this case*/\n                    macinf->macdflow_id[j] = 0;\n                    macinf->ctmux[j] = false;\n\n                    rlcinf->mode[j] = RLC_TM; /* PCCH and BCCH should be using RLC TM? */\n                    rlcinf->li_size[j] = RLC_LI_7BITS;\n                    rlcinf->ciphered[j] = false;\n                    rlcinf->deciphered[j] = false;\n                    rlcinf->rbid[j] = 0;\n                    rlcinf->ueid[j] = 0;\n                }\n            }\n\n            /* Add PDU block header subtree */\n            offset = dissect_macd_pdu_data_type_2(tvb, pinfo, tree, offset,\n                                                  (uint16_t)pdu_length[n],\n                                                  (uint16_t)no_of_pdus[n],\n                                                  p_fp_info, data);\n        }\n        if (preferences_header_checksum) {\n            verify_header_crc(tvb, pinfo, header_crc_pi, header_crc, header_length);\n        }\n        /* Spare Extension and Payload CRC */\n        dissect_spare_extension_and_crc(tvb, pinfo, tree, 1, offset, header_length);\n    }\n}\n/**\n* Dissect and CONFIGURE hsdsch_common channel.\n*\n* This will dissect hsdsch common channels of type 2, so this is\n* very similar to regular type two (ehs) the difference being how\n* the configuration is done. NOTE: VERY EXPERIMENTAL.\n*\n* @param tvb the tv buffer of the current data\n* @param pinfo the packet info of the current data\n* @param tree the tree to append this item to\n* @param offset the offset in the tvb\n* @param p_fp_info FP-packet information\n*/\nstatic\nvoid dissect_hsdsch_common_channel_info(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\n                                        int offset, struct fp_info *p_fp_info,\n                                        void *data)\n{\n    uint32_t ft;\n    uint32_t header_crc = 0;\n    proto_item * header_crc_pi = NULL;\n    unsigned header_length;\n\n    /* Header CRC */\n    header_crc_pi = proto_tree_add_item_ret_uint(tree, hf_fp_header_crc, tvb, offset, 1, ENC_BIG_ENDIAN, &header_crc);\n\n    /* Frame Type */\n    proto_tree_add_item_ret_uint(tree, hf_fp_ft, tvb, offset, 1, ENC_BIG_ENDIAN, &ft);\n    offset++;\n\n    col_append_fstr(pinfo->cinfo, COL_INFO, \" [%s] \", val_to_str_const(ft, frame_type_vals, \"Unknown\"));\n\n    if (ft == FT_CONTROL) {\n        dissect_common_control(tvb, pinfo, tree, offset, p_fp_info);\n        /* For control frame the header CRC is actually frame CRC covering all\n         * bytes except the first */\n        if (preferences_header_checksum) {\n            verify_control_frame_crc(tvb, pinfo, header_crc_pi, (uint16_t)header_crc);\n        }\n    }\n    else {\n        uint8_t number_of_pdu_blocks;\n        bool drt_present = false;\n        bool fach_present = false;\n        uint16_t user_buffer_size;\n        int n;\n        unsigned j;\n\n        #define MAX_PDU_BLOCKS 31\n        uint64_t lchid[MAX_PDU_BLOCKS];\n        uint64_t pdu_length[MAX_PDU_BLOCKS];\n        uint64_t no_of_pdus[MAX_PDU_BLOCKS];\n        uint8_t newieflags = 0;\n\n        umts_mac_info *macinf;\n        rlc_info *rlcinf;\n\n        rlcinf = (rlc_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_umts_rlc, 0);\n        if (!rlcinf) {\n            rlcinf = wmem_new0(pinfo->pool, rlc_info);\n        }\n        macinf = (umts_mac_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_umts_mac, 0);\n        if (!macinf) {\n            macinf = wmem_new0(pinfo->pool, umts_mac_info);\n        }\n        /********************************/\n        /* HS-DCH type 2 data here      */\n\n        col_append_str(pinfo->cinfo, COL_INFO, \"(ehs)\");\n\n        /* Frame Seq Nr (4 bits) */\n        if ((p_fp_info->release == 6) ||\n            (p_fp_info->release == 7)) {\n\n            uint8_t frame_seq_no = (tvb_get_uint8(tvb, offset) & 0xf0) >> 4;\n            proto_tree_add_item(tree, hf_fp_frame_seq_nr, tvb, offset, 1, ENC_BIG_ENDIAN);\n\n            col_append_fstr(pinfo->cinfo, COL_INFO, \"  seqno=%u\", frame_seq_no);\n        }\n\n        /* CmCH-PI (4 bits) */\n        proto_tree_add_item(tree, hf_fp_cmch_pi, tvb, offset, 1, ENC_BIG_ENDIAN);\n        offset++;\n\n        /* Total number of PDU blocks (5 bits) */\n        number_of_pdu_blocks = (tvb_get_uint8(tvb, offset) >> 3);\n        proto_tree_add_item(tree, hf_fp_total_pdu_blocks, tvb, offset, 1, ENC_BIG_ENDIAN);\n\n        if (p_fp_info->release == 7) {\n            /* Flush bit */\n            proto_tree_add_item(tree, hf_fp_flush, tvb, offset, 1, ENC_BIG_ENDIAN);\n\n            /* FSN/DRT reset bit */\n            proto_tree_add_item(tree, hf_fp_fsn_drt_reset, tvb, offset, 1, ENC_BIG_ENDIAN);\n\n            /* DRT Indicator */\n            drt_present = tvb_get_uint8(tvb, offset) & 0x01;\n            proto_tree_add_item(tree, hf_fp_drt_indicator, tvb, offset, 1, ENC_BIG_ENDIAN);\n        }\n        offset++;\n\n        /* FACH Indicator flag */\n        fach_present = (tvb_get_uint8(tvb, offset) & 0x80) >> 7;\n        proto_tree_add_item(tree, hf_fp_fach_indicator, tvb, offset, 1, ENC_BIG_ENDIAN);\n        offset++;\n\n        /* User buffer size */\n        user_buffer_size = tvb_get_ntohs(tvb, offset);\n        proto_tree_add_item(tree, hf_fp_user_buffer_size, tvb, offset, 2, ENC_BIG_ENDIAN);\n        offset += 2;\n\n        col_append_fstr(pinfo->cinfo, COL_INFO, \"  User-Buffer-Size=%u\", user_buffer_size);\n\n\n        /********************************************************************/\n        /* Now read number_of_pdu_blocks header entries                     */\n        for (n=0; n < number_of_pdu_blocks; n++) {\n            proto_item *pdu_block_header_ti;\n            proto_item *item;\n            proto_tree *pdu_block_header_tree;\n            int        block_header_start_offset = offset;\n\n            /* Add PDU block header subtree */\n            pdu_block_header_ti = proto_tree_add_string_format(tree, hf_fp_hsdsch_pdu_block_header,\n                                                               tvb, offset, 0,\n                                                               \"\",\n                                                               \"PDU Block Header\");\n            pdu_block_header_tree = proto_item_add_subtree(pdu_block_header_ti,\n                                                           ett_fp_hsdsch_pdu_block_header);\n\n            /* MAC-d/c PDU length in this block (11 bits) */\n            proto_tree_add_bits_ret_val(pdu_block_header_tree, hf_fp_pdu_length_in_block, tvb,\n                                        (offset*8) + ((n % 2) ? 4 : 0), 11,\n                                        &pdu_length[n], ENC_BIG_ENDIAN);\n            if ((n % 2) == 0)\n                offset++;\n            else\n                offset += 2;\n\n\n            /* # PDUs in this block (4 bits) */\n            item = proto_tree_add_bits_ret_val(pdu_block_header_tree, hf_fp_pdus_in_block, tvb,\n                                        (offset*8) + ((n % 2) ? 0 : 4), 4,\n                                        &no_of_pdus[n], ENC_BIG_ENDIAN);\n            if ((n % 2) == 0) {\n                offset++;\n            }\n            if (no_of_pdus[n] > MAX_MAC_FRAMES) {\n                expert_add_info_format(pinfo, item, &ei_fp_invalid_frame_count, \"Invalid number of PDUs (max is %u)\", MAX_MAC_FRAMES);\n                return;\n            }\n\n            /* Logical channel ID in block (4 bits) */\n            proto_tree_add_bits_ret_val(pdu_block_header_tree, hf_fp_lchid, tvb,\n                                        (offset*8) + ((n % 2) ? 4 : 0), 4,\n                                        &lchid[n], ENC_BIG_ENDIAN);\n            if ((n % 2) == 1) {\n                offset++;\n            }\n            else {\n                if (n == (number_of_pdu_blocks-1)) {\n                    /* Byte is padded out for last block */\n                    offset++;\n                }\n            }\n\n            /* Append summary to header tree root */\n            proto_item_append_text(pdu_block_header_ti,\n                                   \" (lch:%u, %u pdus of %u bytes)\",\n                                   (uint16_t)lchid[n],\n                                   (uint16_t)no_of_pdus[n],\n                                   (uint16_t)pdu_length[n]);\n\n            /* Set length of header tree item */\n            if (((n % 2) == 0) && (n < (number_of_pdu_blocks-1))) {\n                proto_item_set_len(pdu_block_header_ti,\n                                   offset - block_header_start_offset+1);\n            }\n            else {\n                proto_item_set_len(pdu_block_header_ti,\n                                   offset - block_header_start_offset);\n            }\n        }\n\n        header_length = offset;\n\n        /**********************************************/\n        /* Optional fields indicated by earlier flags */\n        if (drt_present) {\n            /* DRT */\n            proto_tree_add_item(tree, hf_fp_drt, tvb, offset, 2, ENC_BIG_ENDIAN);\n            offset += 2;\n        }\n\n        if (fach_present) {\n            /* H-RNTI: */\n            proto_tree_add_item(tree, hf_fp_hrnti, tvb, offset, 2, ENC_BIG_ENDIAN);\n            offset += 2;\n\n            /* RACH Measurement Result */\n            proto_tree_add_item(tree, hf_fp_rach_measurement_result, tvb, offset, 1, ENC_BIG_ENDIAN);\n            offset++;\n        }\n\n        /********************************************************************/\n        /* Now read the MAC-d/c PDUs for each block using info from headers */\n        for (n=0; n < number_of_pdu_blocks; n++) {\n            tvbuff_t *next_tvb;\n            for (j=0; j<no_of_pdus[n]; j++) {\n                /* If all bits are set, then this is BCCH or PCCH according to: 25.435 paragraph: 6.2.7.31 */\n                if (lchid[n] == 0xF) {\n                    /* In the very few test cases I've seen, this seems to be\n                     * BCCH with transparent MAC layer. Therefore skip right to\n                     * rlc_bcch and hope for the best. */\n                    next_tvb = tvb_new_subset_length(tvb, offset, (int)pdu_length[n]);\n                    call_dissector_with_data(rlc_bcch_handle, next_tvb, pinfo, top_level_tree, data);\n                    offset += (int)pdu_length[n];\n                } else { /* Else go for CCCH UM, this seems to work. */\n                    p_fp_info->hsdsch_entity = ehs; /* HSDSCH type 2 */\n                    if (j >= MAX_MAC_FRAMES) {\n                        /* Should not happen as we check no_of_pdus[n]*/\n                        expert_add_info_format(pinfo, tree, &ei_fp_invalid_frame_count, \"Invalid frame count (max is %u)\", MAX_MAC_FRAMES);\n                        return;\n                    }\n                    p_fp_info->cur_tb = j; /* set cur_tb for MAC and RRC */\n                    macinf->content[j] = MAC_CONTENT_CCCH;\n                    macinf->lchid[j] = (uint8_t)lchid[n]+1; /*Add 1 since it is zero indexed? */\n                    macinf->macdflow_id[j] = p_fp_info->hsdsch_macflowd_id;\n                    macinf->ctmux[j] = false;\n\n                    rlcinf->li_size[j] = RLC_LI_7BITS;\n                    rlcinf->ciphered[j] = false;\n                    rlcinf->deciphered[j] = false;\n                    rlcinf->rbid[j] = (uint8_t)lchid[n]+1;\n                    rlcinf->ueid[j] = p_fp_info->channel; /*We need to fake \"UE ID\"*/\n\n                    next_tvb = tvb_new_subset_length(tvb, offset, (int)pdu_length[n]);\n                    call_dissector_with_data(mac_fdd_hsdsch_handle, next_tvb, pinfo, top_level_tree, data);\n\n                    offset += (int)pdu_length[n];\n                }\n            }\n        }\n\n        /* New IE Flags */\n        newieflags = tvb_get_uint8(tvb, offset);\n        /* If newieflags == 0000 0010 then this indicates that there is a\n         * HS-DSCH physical layer category and no other New IE flags. */\n        if (newieflags == 2) {\n            /* HS-DSCH physical layer category presence bit. */\n            proto_tree_add_uint(tree, hf_fp_hsdsch_new_ie_flag[6], tvb, offset, 1, newieflags);\n            offset++;\n            /* HS-DSCH physical layer category. */\n            proto_tree_add_bits_item(tree, hf_fp_hsdsch_physical_layer_category, tvb, offset*8, 6, ENC_BIG_ENDIAN);\n            offset++;\n        }\n        if (preferences_header_checksum) {\n            verify_header_crc(tvb, pinfo, header_crc_pi, header_crc, header_length);\n        }\n        /* Spare Extension and Payload CRC */\n        dissect_spare_extension_and_crc(tvb, pinfo, tree, 1, offset, header_length);\n    }\n}\n/* Validates the header CRC in a Control FP frame */\n/* Should only be used in heuristic dissectors! */\nstatic bool\ncheck_control_frame_crc_for_heur(wmem_allocator_t* allocator, tvbuff_t * tvb)\n{\n    uint8_t crc = 0;\n    uint8_t calc_crc = 0;\n    uint8_t * data = NULL;\n    unsigned  reported_length = tvb_reported_length(tvb);\n\n    if (reported_length == 0 || reported_length > tvb_captured_length(tvb))\n        return false;\n\n    crc = tvb_get_uint8(tvb, 0) >> 1;\n    /* Get data. */\n    data = (uint8_t *)tvb_memdup(allocator, tvb, 0, tvb_reported_length(tvb));\n    /* Include only FT flag bit in CRC calculation. */\n    data[0] = data[0] & 1;\n    calc_crc = crc7update(0, data, tvb_reported_length(tvb));\n    calc_crc = crc7finalize(calc_crc);\n\n    return calc_crc == crc;\n}\n/* Validates the header CRC in a Data FP frame */\n/* Should only be used in heuristic dissectors! */\nstatic bool\ncheck_header_crc_for_heur(tvbuff_t *tvb, uint16_t header_length)\n{\n    uint8_t crc = 0;\n    uint8_t calc_crc = 0;\n    const uint8_t * data = NULL;\n\n    if (header_length > tvb_captured_length(tvb))\n        return false;\n\n    crc = tvb_get_uint8(tvb, 0) >> 1;\n    /* Get data of header excluding the first byte */\n    data = tvb_get_ptr(tvb, 1, header_length - 1);\n\n    calc_crc = crc7update(0, data, header_length - 1);\n    calc_crc = crc7finalize(calc_crc);\n\n    return calc_crc == crc;\n}\n/* Validates the payload CRC in a Data FP frame */\n/* Should only be used in heuristic dissectors! */\nstatic bool\ncheck_payload_crc_for_heur(tvbuff_t *tvb, uint16_t header_length)\n{\n    uint16_t reported_length;\n    uint16_t crc_index;\n    uint16_t crc = 0;\n    uint16_t calc_crc = 0;\n    uint16_t payload_index;\n    uint16_t payload_length;\n    const uint8_t *data = NULL;\n\n    reported_length = tvb_reported_length(tvb);\n    if (reported_length < 2 || reported_length > tvb_captured_length(tvb)) {\n        return false;\n    }\n    /* Payload CRC is in the last 2 bytes of the packet */\n    crc_index = reported_length - 2;\n    crc = tvb_get_bits16(tvb, crc_index * 8, 16, ENC_BIG_ENDIAN);\n\n    payload_index = header_length; /* payload first index is the same as the header length */\n    payload_length = (reported_length - payload_index) - 2;\n    data = tvb_get_ptr(tvb, payload_index, payload_length);\n    calc_crc = crc16_8005_noreflect_noxor(data, payload_length);\n\n    return calc_crc == crc;\n}\n/* Validates the header CRC in a E-DCH Data FP frame */\n/* Should only be used in heuristic dissectors! */\nstatic bool\ncheck_edch_header_crc_for_heur(wmem_allocator_t* allocator, tvbuff_t *tvb, uint16_t header_length)\n{\n    uint16_t crc = 0;\n    uint16_t calc_crc = 0;\n    uint8_t * data = NULL;\n\n    if (header_length > tvb_captured_length(tvb))\n        return false;\n\n    crc = (tvb_get_bits8(tvb, 0, 7) << 4) + tvb_get_bits8(tvb, 8, 4);\n    /* Get data of header excluding the first byte */\n    data = (uint8_t *)tvb_memdup(allocator, tvb, 1, header_length-1);\n    /*Zero the part in the second byte which contains part of the CRC*/\n    data[0] = data[0] & 0x0f;\n\n    calc_crc = crc11_307_noreflect_noxor(data, header_length-1);\n\n    return calc_crc == crc;\n}\n/* Generates a unique 32bit identifier based on the frame's metadata */\n/* This ID is used in the RLC dissector for reassembly */\n/* Should only be used in heuristic dissectors! */\nstatic uint32_t\ngenerate_ue_id_for_heur(packet_info *pinfo)\n{\n    if (pinfo->ptype == PT_UDP &&  pinfo->src.type == AT_IPv4 &&  pinfo->dst.type == AT_IPv4) {\n        /* This logic assumes FP is delivered over IP/UDP*/\n        /* Will return the same ID even if the address and ports are reversed */\n\n        /* srcXor: [ ------- Source Address ------- ] (4 bytes)*/\n        /*                         XOR                         */\n        /*         [  Source Port  ][  Source Port  ] (4 bytes)*/\n        int srcXor = pntohu32(pinfo->src.data) ^ ((pinfo->srcport << 16) | (pinfo->srcport));\n\n        /* dstXor: [ ---- Destination  Address ---- ] (4 bytes)*/\n        /*                         XOR                         */\n        /*         [ - Dest Port - ][ - Dest Port - ] (4 bytes)*/\n        int dstXor = pntohu32(pinfo->dst.data) ^ ((pinfo->destport << 16) | (pinfo->destport));\n        return srcXor ^ dstXor;\n    }\n    else {\n        /* Fallback - When IP and/or UDP are missing for whatever reason */\n        /* Using the frame number of the first heuristicly dissected frame as the UE ID should be unique enough */\n        /* The bitwise NOT operator is used to prevent low UE ID values which are likely to collide */\n        /* with legitimate UE IDs derived from C-RNTIs in FACH/RACH */\n        return ~(pinfo->num);\n    }\n}\n/* Fills common PCH information in a 'fp conversation info' object */\n/* Should only be used in heuristic dissectors! */\nstatic void\nfill_pch_conversation_info_for_heur(umts_fp_conversation_info_t* umts_fp_conversation_info ,packet_info *pinfo)\n{\n    umts_fp_conversation_info->iface_type = IuB_Interface;\n    umts_fp_conversation_info->division = Division_FDD;\n    umts_fp_conversation_info->dl_frame_number = pinfo->num;\n    umts_fp_conversation_info->ul_frame_number = pinfo->num;\n    umts_fp_conversation_info->dch_crc_present = 1;\n    umts_fp_conversation_info->com_context_id = generate_ue_id_for_heur(pinfo);\n    umts_fp_conversation_info->rlc_mode = FP_RLC_AM;\n    copy_address_wmem(wmem_file_scope(), &(umts_fp_conversation_info->crnc_address), &pinfo->src);\n    umts_fp_conversation_info->crnc_port = pinfo->srcport;\n    umts_fp_conversation_info->channel = CHANNEL_PCH;\n    umts_fp_conversation_info->num_dch_in_flow = 1;\n    umts_fp_conversation_info->fp_dch_channel_info[0].num_dl_chans = 1;\n    umts_fp_conversation_info->fp_dch_channel_info[0].dl_chan_num_tbs[1] = 1;\n    umts_fp_conversation_info->channel_specific_info = (void*)wmem_new0(wmem_file_scope(), fp_pch_channel_info_t);\n}\n/* Attaches conversation info to both the downlink and uplink 'conversations' (streams) */\n/* (Required since only one of them is checked in every dissected FP packet) */\n/* Should only be used in heuristic dissectors! */\nstatic void\nset_both_sides_umts_fp_conv_data(packet_info *pinfo, umts_fp_conversation_info_t *umts_fp_conversation_info)\n{\n    conversation_t   *packet_direction_conv;\n    conversation_t   *other_direction_conv;\n\n    if (pinfo == NULL) {\n        return;\n    }\n\n    /* Finding or creating conversation for the way the packet is heading */\n    packet_direction_conv = (conversation_t *)find_conversation(pinfo->num, &pinfo->net_dst, &pinfo->net_src,\n        conversation_pt_to_conversation_type(pinfo->ptype),\n        pinfo->destport, pinfo->srcport, NO_ADDR_B);\n\n    if (packet_direction_conv == NULL) {\n        /* Conversation does not exist yet, creating one now. */\n        packet_direction_conv = conversation_new(pinfo->num, &pinfo->net_dst, &pinfo->net_src,\n            conversation_pt_to_conversation_type(pinfo->ptype),\n            pinfo->destport, pinfo->srcport, NO_ADDR2);\n    }\n    conversation_add_proto_data(packet_direction_conv, proto_fp, umts_fp_conversation_info);\n\n    /* Finding or creating conversation for the other side */\n    other_direction_conv = (conversation_t *)find_conversation(pinfo->num, &pinfo->net_src, &pinfo->net_dst,\n        conversation_pt_to_conversation_type(pinfo->ptype),\n        pinfo->srcport, pinfo->destport, NO_ADDR_B);\n\n    if (other_direction_conv == NULL) {\n        /* Conversation does not exist yet, creating one now. */\n        other_direction_conv = conversation_new(pinfo->num, &pinfo->net_src, &pinfo->net_dst,\n            conversation_pt_to_conversation_type(pinfo->ptype),\n            pinfo->srcport, pinfo->destport, NO_ADDR2);\n    }\n    conversation_add_proto_data(other_direction_conv, proto_fp, umts_fp_conversation_info);\n\n}\nstatic bool\nheur_dissect_fp_dcch_over_dch(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)\n{\n    conversation_t   *p_conv;\n    umts_fp_conversation_info_t* umts_fp_conversation_info = NULL;\n    struct fp_info *p_fp_info;\n    uint32_t captured_length;\n    uint32_t reported_length;\n    uint8_t frame_type;\n    uint8_t tfi;\n    uint8_t pch_collisions_byte;\n\n    /* Trying to find existing conversation */\n    p_conv = (conversation_t *)find_conversation(pinfo->num, &pinfo->net_dst, &pinfo->net_src,\n        conversation_pt_to_conversation_type(pinfo->ptype),\n        pinfo->destport, pinfo->srcport, NO_ADDR_B);\n\n    if (p_conv != NULL) {\n        /* Checking if the conversation was already framed */\n        umts_fp_conversation_info = (umts_fp_conversation_info_t *)conversation_get_proto_data(p_conv, proto_fp);\n        if (umts_fp_conversation_info) {\n            if (umts_fp_conversation_info->channel == CHANNEL_DCH) {\n                conversation_set_dissector(p_conv, fp_handle);\n                dissect_fp(tvb, pinfo, tree, data);\n                return true;\n            }\n            else if (umts_fp_conversation_info->channel != CHANNEL_UNKNOWN){\n                /* This conversation was successfully framed as ANOTHER type */\n                return false;\n            }\n        }\n    }\n\n    /* Making sure FP info isn't already attached */\n    p_fp_info = (fp_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_fp, 0);\n    if (p_fp_info) {\n        return false;\n    }\n\n    frame_type = tvb_get_uint8(tvb, 0) & 0x01;\n    if (frame_type == 1) { /* is 'control' frame type*/\n        return false;\n    }\n\n    /* Making sure we have at least enough bytes for header (3) + footer (2) */\n    captured_length = tvb_captured_length(tvb);\n    if (captured_length < 5) {\n        return false;\n    }\n    reported_length = tvb_reported_length(tvb);\n\n    tfi = tvb_get_uint8(tvb, 2) & 0x1f;\n\n    /* Checking if this is a DCH frame with 0 TBs*/\n    if (tfi == 0x00)\n    {\n        if (reported_length != 5 /* DL */ && reported_length != 7 /* UL */) {\n            return false;\n        }\n        if (!check_header_crc_for_heur(tvb, 3)) {\n            return false;\n        }\n        if (!check_payload_crc_for_heur(tvb, 3)) {\n            return false;\n        }\n        /* All checks passed - This is an unknown DCH FP frame. */\n        /* To allow dissection of this frame after umts_fp_conversation_info will be added in a later frame */\n        /* the conversation must be created here if it doesn't exist yet*/\n        if (p_conv == NULL) {\n            conversation_new(pinfo->num, &pinfo->net_dst, &pinfo->net_src,\n                conversation_pt_to_conversation_type(pinfo->ptype),\n                pinfo->destport, pinfo->srcport, NO_ADDR2);\n        }\n        return false;\n    }\n\n    /* Checking this is a DCH frame with 1 TB */\n    if (tfi != 0x01) {\n        return false;\n    }\n\n    /* Expecting specific lengths: 24 for downlink frames, 26 for uplink frames */\n    /* This is the common Transport Format of DCCH over DCH ( See 3GPP TR 25.944 / 4.1.1.3.1.1 ) */\n    if (reported_length != 24 /* DL */ && reported_length != 26 /* UL */) {\n        return false;\n    }\n\n    if (!check_header_crc_for_heur(tvb, 3)) {\n        return false;\n    }\n    if (!check_payload_crc_for_heur(tvb, 3)) {\n        return false;\n    }\n\n    /* Checking if the 4th byte in the frame is zeroed. In this case the CRC checks aren't */\n    /* deterministic enough to guarantee this is a DCH since this packet could also be a PCH frame */\n    /* with PI Bitmap of 18 bytes + 0 TBs (Both CRCs will match for both formats) */\n    pch_collisions_byte = tvb_get_uint8(tvb, 3);\n    if (pch_collisions_byte == 0) {\n        return false;\n    }\n\n    if(!umts_fp_conversation_info) {\n        umts_fp_conversation_info = wmem_new0(wmem_file_scope(), umts_fp_conversation_info_t);\n        set_both_sides_umts_fp_conv_data(pinfo, umts_fp_conversation_info);\n    }\n    umts_fp_conversation_info->iface_type = IuB_Interface;\n    umts_fp_conversation_info->division = Division_FDD;\n    umts_fp_conversation_info->dl_frame_number = pinfo->num;\n    umts_fp_conversation_info->ul_frame_number = pinfo->num;\n    umts_fp_conversation_info->dch_crc_present = 1;\n    umts_fp_conversation_info->com_context_id = generate_ue_id_for_heur(pinfo);\n    umts_fp_conversation_info->rlc_mode = FP_RLC_AM;\n    if (reported_length == 24) { /* Downlink */\n        copy_address_wmem(wmem_file_scope(), &(umts_fp_conversation_info->crnc_address), &pinfo->src);\n        umts_fp_conversation_info->crnc_port = pinfo->srcport;\n    }\n    else { /* Uplink*/\n        copy_address_wmem(wmem_file_scope(), &(umts_fp_conversation_info->crnc_address), &pinfo->dst);\n        umts_fp_conversation_info->crnc_port = pinfo->destport;\n    }\n    umts_fp_conversation_info->channel = CHANNEL_DCH;\n    umts_fp_conversation_info->num_dch_in_flow = 1;\n    umts_fp_conversation_info->dch_ids_in_flow_list[0] = 31;\n    umts_fp_conversation_info->fp_dch_channel_info[0].num_dl_chans = 1;\n    umts_fp_conversation_info->fp_dch_channel_info[0].dl_chan_num_tbs[1] = 1;\n    umts_fp_conversation_info->fp_dch_channel_info[0].dl_chan_tf_size[1] = 148;\n    umts_fp_conversation_info->fp_dch_channel_info[0].num_ul_chans = 1;\n    umts_fp_conversation_info->fp_dch_channel_info[0].ul_chan_num_tbs[1] = 1;\n    umts_fp_conversation_info->fp_dch_channel_info[0].ul_chan_tf_size[1] = 148;\n    conversation_set_dissector(find_or_create_conversation(pinfo), fp_handle);\n    dissect_fp(tvb, pinfo, tree, data);\n    return true;\n}\nstatic bool\nheur_dissect_fp_fach1(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)\n{\n    conversation_t   *p_conv;\n    fp_fach_channel_info_t* fp_fach_channel_info;\n    umts_fp_conversation_info_t* umts_fp_conversation_info = NULL;\n    struct fp_info *p_fp_info;\n    uint32_t captured_length;\n    uint32_t reported_length;\n    uint8_t frame_type;\n    uint8_t tfi;\n    uint8_t tctf;\n\n    /* Finding or creating conversation */\n    p_conv = (conversation_t *)find_conversation(pinfo->num, &pinfo->net_dst, &pinfo->net_src,\n        conversation_pt_to_conversation_type(pinfo->ptype),\n        pinfo->destport, pinfo->srcport, NO_ADDR_B);\n\n    if (p_conv != NULL) {\n        /* Checking if the conversation was already framed */\n        umts_fp_conversation_info = (umts_fp_conversation_info_t *)conversation_get_proto_data(p_conv, proto_fp);\n        if (umts_fp_conversation_info) {\n            if (umts_fp_conversation_info->channel == CHANNEL_FACH_FDD) {\n                conversation_set_dissector(p_conv, fp_handle);\n                dissect_fp(tvb, pinfo, tree, data);\n                return true;\n            }\n            else if (umts_fp_conversation_info->channel != CHANNEL_UNKNOWN){\n                /* This conversation was successfully framed as ANOTHER type */\n                return false;\n            }\n        }\n    }\n    /* Making sure we have at least enough bytes for header (4) + footer (2) */\n    captured_length = tvb_captured_length(tvb);\n    if(captured_length < 6) {\n        return false;\n    }\n\n    /* Expecting specific lengths: 51 for frames with 1 TB */\n    /* This is a common Transport Format of FACH ( See 3GPP TR 25.944 / 4.1.1.2 'FACH1' ) */\n    reported_length = tvb_reported_length(tvb);\n    if (reported_length != 51) {\n        return false;\n    }\n\n    p_fp_info = (fp_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_fp, 0);\n\n    /* Making sure FP info isn't already attached */\n    if (p_fp_info) {\n        return false;\n    }\n\n    frame_type = tvb_get_uint8(tvb, 0) & 0x01;\n    if (frame_type == 1) { /* is 'control' frame type*/\n                           /* We can't tell the FP type and content of control frames */\n        return false;\n    }\n\n    tfi = tvb_get_uint8(tvb, 2) & 0x1f;\n    if (tfi != 0x01) {\n        return false;\n    }\n\n    tctf = tvb_get_uint8(tvb, 4);\n    /* Asserting the TCTF field contains a valid (non reserved) value according to TS 25.321 Table 9.2.1-2 */\n    if (tctf != 0x40 && /* CCCH */\n        tctf != 0x50 && /* MCCH */\n        tctf != 0x5F && /* MSCH */\n        tctf != 0x80 && /* CTCH */\n        (tctf >> 4) != 0x06 && /* MTCH */\n        (tctf >> 6) != 0x00 && /* BCCH */\n        (tctf >> 6) != 0x03) { /* DCCH or DTCH over FACH */\n        return false;\n    }\n\n    if (!check_header_crc_for_heur(tvb, 4)) {\n        return false;\n    }\n    if (!check_payload_crc_for_heur(tvb, 4)) {\n        return false;\n    }\n\n    if(!umts_fp_conversation_info) {\n        umts_fp_conversation_info = wmem_new0(wmem_file_scope(), umts_fp_conversation_info_t);\n        set_both_sides_umts_fp_conv_data(pinfo, umts_fp_conversation_info);\n    }\n    umts_fp_conversation_info->iface_type = IuB_Interface;\n    umts_fp_conversation_info->division = Division_FDD;\n    umts_fp_conversation_info->dl_frame_number = pinfo->num;\n    umts_fp_conversation_info->ul_frame_number = pinfo->num;\n    umts_fp_conversation_info->dch_crc_present = 1;\n    umts_fp_conversation_info->com_context_id = generate_ue_id_for_heur(pinfo);\n    umts_fp_conversation_info->rlc_mode = FP_RLC_AM;\n    copy_address_wmem(wmem_file_scope(), &(umts_fp_conversation_info->crnc_address), &pinfo->src);\n    umts_fp_conversation_info->crnc_port = pinfo->srcport;\n    umts_fp_conversation_info->channel = CHANNEL_FACH_FDD;\n    umts_fp_conversation_info->num_dch_in_flow = 1;\n    umts_fp_conversation_info->fp_dch_channel_info[0].num_dl_chans = 1;\n    umts_fp_conversation_info->fp_dch_channel_info[0].dl_chan_num_tbs[1] = 1;\n    umts_fp_conversation_info->fp_dch_channel_info[0].dl_chan_tf_size[1] = 360;\n    /* Adding the 'channel specific info' for FACH */\n    fp_fach_channel_info = wmem_new0(wmem_file_scope(), fp_fach_channel_info_t);\n    fp_fach_channel_info->crnti_to_urnti_map = wmem_tree_new_autoreset(wmem_epan_scope(), wmem_file_scope());\n    umts_fp_conversation_info->channel_specific_info = (void*)fp_fach_channel_info;\n\n    conversation_set_dissector(find_or_create_conversation(pinfo), fp_handle);\n    dissect_fp(tvb, pinfo, tree, data);\n    return true;\n}\nstatic bool\nheur_dissect_fp_fach2(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)\n{\n    conversation_t   *p_conv;\n    fp_fach_channel_info_t* fp_fach_channel_info;\n    umts_fp_conversation_info_t* umts_fp_conversation_info = NULL;\n    struct fp_info *p_fp_info;\n    uint32_t captured_length;\n    uint32_t reported_length;\n    uint8_t frame_type;\n    uint8_t tfi;\n    uint8_t tctf;\n\n    /* Finding or creating conversation */\n    p_conv = (conversation_t *)find_conversation(pinfo->num, &pinfo->net_dst, &pinfo->net_src,\n        conversation_pt_to_conversation_type(pinfo->ptype),\n        pinfo->destport, pinfo->srcport, NO_ADDR_B);\n\n    if (p_conv != NULL) {\n        /* Checking if the conversation was already framed */\n        umts_fp_conversation_info = (umts_fp_conversation_info_t *)conversation_get_proto_data(p_conv, proto_fp);\n        if (umts_fp_conversation_info) {\n            if (umts_fp_conversation_info->channel == CHANNEL_FACH_FDD) {\n                conversation_set_dissector(p_conv, fp_handle);\n                dissect_fp(tvb, pinfo, tree, data);\n                return true;\n            }\n            else if (umts_fp_conversation_info->channel != CHANNEL_UNKNOWN){\n                /* This conversation was successfully framed as ANOTHER type */\n                return false;\n            }\n        }\n    }\n    /* Making sure we have at least enough bytes for header (4) + footer (2) */\n    captured_length = tvb_captured_length(tvb);\n    if(captured_length < 6) {\n        return false;\n    }\n\n    /* Expecting specific lengths: 27 for frames with 1 TB, 48 for frames with 2 TBs */\n    /* This is a common Transport Format of FACH ( See 3GPP TR 25.944 / 4.1.1.2 'FACH2' ) */\n    reported_length = tvb_reported_length(tvb);\n    if (reported_length != 27 && reported_length != 48) {\n        return false;\n    }\n\n    p_fp_info = (fp_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_fp, 0);\n\n    /* Making sure FP info isn't already attached */\n    if (p_fp_info) {\n        return false;\n    }\n\n    frame_type = tvb_get_uint8(tvb, 0) & 0x01;\n    if (frame_type == 1) { /* is 'control' frame type*/\n                           /* We can't tell the FP type and content of control frames */\n        return false;\n    }\n\n    tfi = tvb_get_uint8(tvb, 2) & 0x1f;\n    if (reported_length == 27 && tfi != 0x01) {\n        return false;\n    }\n    if (reported_length == 48 && tfi != 0x02) {\n        return false;\n    }\n\n    tctf = tvb_get_uint8(tvb, 4);\n    /* Asserting the TCTF field contains a valid (non reserved) value according to TS 25.321 Table 9.2.1-2 */\n    if (tctf != 0x40 && /* CCCH */\n        tctf != 0x50 && /* MCCH */\n        tctf != 0x5F && /* MSCH */\n        tctf != 0x80 && /* CTCH */\n        (tctf >> 4) != 0x06 && /* MTCH */\n        (tctf >> 6) != 0x00 && /* BCCH */\n        (tctf >> 6) != 0x03) { /* DCCH or DTCH over FACH */\n        return false;\n    }\n\n    if (!check_header_crc_for_heur(tvb, 4)) {\n        return false;\n    }\n    if (!check_payload_crc_for_heur(tvb, 4)) {\n        return false;\n    }\n\n    if(!umts_fp_conversation_info) {\n        umts_fp_conversation_info = wmem_new0(wmem_file_scope(), umts_fp_conversation_info_t);\n        set_both_sides_umts_fp_conv_data(pinfo, umts_fp_conversation_info);\n    }\n    umts_fp_conversation_info->iface_type = IuB_Interface;\n    umts_fp_conversation_info->division = Division_FDD;\n    umts_fp_conversation_info->dl_frame_number = pinfo->num;\n    umts_fp_conversation_info->ul_frame_number = pinfo->num;\n    umts_fp_conversation_info->dch_crc_present = 1;\n    umts_fp_conversation_info->com_context_id = generate_ue_id_for_heur(pinfo);\n    umts_fp_conversation_info->rlc_mode = FP_RLC_AM;\n    copy_address_wmem(wmem_file_scope(), &(umts_fp_conversation_info->crnc_address), &pinfo->src);\n    umts_fp_conversation_info->crnc_port = pinfo->srcport;\n    umts_fp_conversation_info->channel = CHANNEL_FACH_FDD;\n    umts_fp_conversation_info->num_dch_in_flow = 1;\n    umts_fp_conversation_info->fp_dch_channel_info[0].num_dl_chans = 1;\n    umts_fp_conversation_info->fp_dch_channel_info[0].dl_chan_num_tbs[1] = 1;\n    umts_fp_conversation_info->fp_dch_channel_info[0].dl_chan_tf_size[1] = 168;\n    umts_fp_conversation_info->fp_dch_channel_info[0].dl_chan_num_tbs[2] = 2;\n    umts_fp_conversation_info->fp_dch_channel_info[0].dl_chan_tf_size[2] = 168;\n    /* Adding the 'channel specific info' for FACH */\n    fp_fach_channel_info = wmem_new0(wmem_file_scope(), fp_fach_channel_info_t);\n    fp_fach_channel_info->crnti_to_urnti_map = wmem_tree_new_autoreset(wmem_epan_scope(), wmem_file_scope());\n    umts_fp_conversation_info->channel_specific_info = (void*)fp_fach_channel_info;\n\n    conversation_set_dissector(find_or_create_conversation(pinfo), fp_handle);\n    dissect_fp(tvb, pinfo, tree, data);\n    return true;\n}\nstatic bool\nheur_dissect_fp_rach(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)\n{\n    conversation_t   *p_conv;\n    fp_rach_channel_info_t* fp_rach_channel_info;\n    umts_fp_conversation_info_t* umts_fp_conversation_info = NULL;\n    struct fp_info *p_fp_info;\n    uint32_t captured_length;\n    uint32_t reported_length;\n    uint8_t frame_type;\n    uint8_t tfi;\n    uint8_t tctf;\n\n    /* Finding or creating conversation */\n    p_conv = (conversation_t *)find_conversation(pinfo->num, &pinfo->net_dst, &pinfo->net_src,\n        conversation_pt_to_conversation_type(pinfo->ptype),\n        pinfo->destport, pinfo->srcport, NO_ADDR_B);\n\n    if (p_conv != NULL) {\n        /* Checking if the conversation was already framed */\n        umts_fp_conversation_info = (umts_fp_conversation_info_t *)conversation_get_proto_data(p_conv, proto_fp);\n        if (umts_fp_conversation_info) {\n            if (umts_fp_conversation_info->channel == CHANNEL_RACH_FDD) {\n                conversation_set_dissector(p_conv, fp_handle);\n                dissect_fp(tvb, pinfo, tree, data);\n                return true;\n            }\n            else if (umts_fp_conversation_info->channel != CHANNEL_UNKNOWN){\n                /* This conversation was successfully framed as ANOTHER type */\n                return false;\n            }\n        }\n    }\n\n    /* Making sure we have at least enough bytes for header (4) + footer (2) */\n    captured_length = tvb_captured_length(tvb);\n    if(captured_length < 6) {\n        return false;\n    }\n\n    /* Expecting specific lengths: rach frames are either 28 or 52 bytes long */\n    /* This is the common Transport Formats of RACH ( See 3GPP TR 25.944 / 4.1.2.1 ) */\n    reported_length = tvb_reported_length(tvb);\n    if (reported_length != 28 && reported_length != 52) {\n        return false;\n    }\n\n    p_fp_info = (fp_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_fp, 0);\n\n    /* Making sure FP info isn't already attached */\n    if (p_fp_info) {\n        return false;\n    }\n\n    frame_type = tvb_get_uint8(tvb, 0) & 0x01;\n    if (frame_type == 1) { /* is 'control' frame type*/\n                           /* We can't tell the FP type and content of control frames */\n        return false;\n    }\n\n    tfi = tvb_get_uint8(tvb, 2) & 0x1f;\n    if (reported_length == 28 && tfi != 0x00) {\n        return false;\n    }\n    if (reported_length == 52 && tfi != 0x01) {\n        return false;\n    }\n\n    tctf = tvb_get_uint8(tvb, 4) >> 6;\n    /* Asserting the TCTF field contains a valid (non reserved) value according to TS 25.321 Table 9.2.1-4 */\n    if (tctf != 0x00 && /* CCCH */\n        tctf != 0x01)  /* DCCH over RACH */\n    {\n        return false;\n    }\n\n    if (!check_header_crc_for_heur(tvb, 4)) {\n        return false;\n    }\n    if (!check_payload_crc_for_heur(tvb, 4)) {\n        return false;\n    }\n\n    if(!umts_fp_conversation_info) {\n        umts_fp_conversation_info = wmem_new0(wmem_file_scope(), umts_fp_conversation_info_t);\n        set_both_sides_umts_fp_conv_data(pinfo, umts_fp_conversation_info);\n    }\n    umts_fp_conversation_info->iface_type = IuB_Interface;\n    umts_fp_conversation_info->division = Division_FDD;\n    umts_fp_conversation_info->dl_frame_number = pinfo->num;\n    umts_fp_conversation_info->ul_frame_number = pinfo->num;\n    umts_fp_conversation_info->dch_crc_present = 1;\n    umts_fp_conversation_info->com_context_id = generate_ue_id_for_heur(pinfo);\n    umts_fp_conversation_info->rlc_mode = FP_RLC_AM;\n    copy_address_wmem(wmem_file_scope(), &(umts_fp_conversation_info->crnc_address), &pinfo->dst);\n    umts_fp_conversation_info->crnc_port = pinfo->destport;\n    umts_fp_conversation_info->channel = CHANNEL_RACH_FDD;\n    umts_fp_conversation_info->num_dch_in_flow = 1;\n    umts_fp_conversation_info->fp_dch_channel_info[0].num_ul_chans = 0;\n    umts_fp_conversation_info->fp_dch_channel_info[0].ul_chan_num_tbs[0] = 1;\n    umts_fp_conversation_info->fp_dch_channel_info[0].ul_chan_num_tbs[1] = 1;\n    umts_fp_conversation_info->fp_dch_channel_info[0].ul_chan_tf_size[0] = 168;\n    umts_fp_conversation_info->fp_dch_channel_info[0].ul_chan_tf_size[1] = 360;\n\n    /* Adding the 'channel specific info' for RACH */\n    fp_rach_channel_info = wmem_new0(wmem_file_scope(), fp_rach_channel_info_t);\n    fp_rach_channel_info->crnti_to_urnti_map = wmem_tree_new_autoreset(wmem_epan_scope(), wmem_file_scope());\n    umts_fp_conversation_info->channel_specific_info = (void*)fp_rach_channel_info;\n\n    conversation_set_dissector(find_or_create_conversation(pinfo), fp_handle);\n    dissect_fp(tvb, pinfo, tree, data);\n    return true;\n}\nstatic bool\nheur_dissect_fp_pch(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)\n{\n    conversation_t   *p_conv;\n    umts_fp_conversation_info_t* umts_fp_conversation_info = NULL;\n    fp_pch_channel_info_t* fp_pch_channel_info = NULL;\n    struct fp_info *p_fp_info;\n    bool conversation_initialized = false;\n    uint32_t captured_length;\n    uint32_t reported_length;\n    uint8_t frame_type;\n    uint8_t reserved_bits;\n    uint8_t tfi;\n    uint8_t pi_byte_length;\n    uint16_t tb_byte_length;\n    bool pi_present;\n    bool tb_size_found;\n    bool pi_length_found;\n    uint8_t cfn_lowest_bits;\n    uint8_t dch_collisions_byte;\n\n    /* To correctly dissect a PCH stream 2 parameters are required: PI Bitmap length & TB length */\n    /* Both are optional in each packet and having them both in a packet without knowing any of them */\n    /* is not helpful.*/\n    /* Hence gathering the info from 2 different frames is required. */\n\n    /* Finding or creating conversation */\n    p_conv = (conversation_t *)find_conversation(pinfo->num, &pinfo->net_dst, &pinfo->net_src,\n        conversation_pt_to_conversation_type(pinfo->ptype),\n        pinfo->destport, pinfo->srcport, NO_ADDR_B);\n\n    if (p_conv != NULL) {\n        /* Checking if the conversation was already framed */\n        umts_fp_conversation_info = (umts_fp_conversation_info_t *)conversation_get_proto_data(p_conv, proto_fp);\n        if (umts_fp_conversation_info) {\n            fp_pch_channel_info = (fp_pch_channel_info_t*)umts_fp_conversation_info->channel_specific_info;\n            /* Making sure this conversation type is \"PCH\" and the PCH channel info is present */\n            if (umts_fp_conversation_info->channel == CHANNEL_PCH && fp_pch_channel_info != NULL) {\n                conversation_initialized = true;\n                pi_length_found = fp_pch_channel_info->paging_indications != 0;\n                tb_size_found = umts_fp_conversation_info->fp_dch_channel_info[0].dl_chan_tf_size[1] != 0;\n                if (pi_length_found && tb_size_found) {\n                    /* Stream already framed - contains both PI length and TB size */\n                    dissect_fp(tvb, pinfo, tree, data);\n                    return true;\n                }\n            }\n            else if (umts_fp_conversation_info->channel != CHANNEL_UNKNOWN){\n                /* This conversation was successfully framed as ANOTHER type */\n                return false;\n            }\n            else {\n                /* FP conversation info attached and the channel type is UNKNOWN - might be PCH */\n                tb_size_found = false;\n                pi_length_found = false;\n            }\n        }\n        else {\n            /* FP conversation info not attached - no PCH info is known */\n            tb_size_found = false;\n            pi_length_found = false;\n        }\n    }\n    else {\n        /* A conversation does not exist yet - no PCH info is known */\n        tb_size_found = false;\n        pi_length_found = false;\n    }\n\n    /* Making sure we have at least enough bytes for header (4) + footer (2) */\n    captured_length = tvb_captured_length(tvb);\n    if(captured_length < 6) {\n        return false;\n    }\n\n    p_fp_info = (fp_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_fp, 0);\n    /* Making sure FP info isn't already attached */\n    if (p_fp_info) {\n        return false;\n    }\n\n    frame_type = tvb_get_uint8(tvb, 0) & 0x01;\n    if (frame_type == 1) { /* is 'control' frame type*/\n                           /* We can't tell the FP type and content of control frames */\n        return false;\n    }\n\n    /* Checking bits after CFN and before PI indicator are zeroed */\n    reserved_bits = tvb_get_uint8(tvb, 2) & 0x0E;\n    if (reserved_bits != 0x00) {\n        return false;\n    }\n\n    tfi = tvb_get_uint8(tvb, 3) & 0x1f;\n    if (tfi != 0x00 && tfi != 0x01) {\n        return false;\n    }\n\n    if (!check_header_crc_for_heur(tvb, 4)) {\n        return false;\n    }\n    if (!check_payload_crc_for_heur(tvb, 4)) {\n        return false;\n    }\n\n    reported_length = tvb_reported_length(tvb);\n    pi_present = tvb_get_uint8(tvb, 2) & 0x01; /* Rightmost bit in the 3rd byte */\n    if (pi_present) {\n        if (tfi == 0x00 && !pi_length_found) {\n            /* PI Bitmap present and No TB. Can calculate PI bitmap length */\n            uint8_t pi_bit_length;\n            pi_byte_length = reported_length - 6; /* Removing header length (4) and footer length (2)*/\n            switch (pi_byte_length)\n            {\n            case 3: /* 18 bits bitmap + padding */\n                pi_bit_length = 18;\n                break;\n            case 5: /* 36 bits bitmap + padding */\n                pi_bit_length = 36;\n                break;\n            case 9: /* 72 bits bitmap */\n                pi_bit_length = 72;\n                break;\n            case 18: /* 144 bits bitmap */\n                pi_bit_length = 144;\n                break;\n            default:\n                return false;\n            }\n\n            if (pi_bit_length == 144 && !tb_size_found) {\n                /* Nothing has confirmed yet that this channel is a PCH since */\n                /* both 'tb_size_found' and 'pi_length_found' are false. */\n                /* Checking if the 4 LSB bits of the CFN (the 4 leftmost bits in the 3rd byte) aren't zeroed. */\n                /* if they aren't this is probably PCH because those are reserved in DCH */\n                cfn_lowest_bits = tvb_get_uint8(tvb, 2) & 0xF0;\n                if(cfn_lowest_bits == 0) {\n                    /* Checking if the 4th byte in the frame is zeroed. In this case the CRC checks aren't */\n                    /* deterministic enough to guarantee this is a PCH since this packet could also be a DCH frame */\n                    /* with MAC's C/T is 0 and 4 leftmost bits of RLC are 0 */\n                    dch_collisions_byte = tvb_get_uint8(tvb, 3);\n                    if (dch_collisions_byte == 0) {\n                        return false;\n                    }\n                }\n            }\n\n            if (!umts_fp_conversation_info) {\n                umts_fp_conversation_info = wmem_new0(wmem_file_scope(), umts_fp_conversation_info_t);\n                set_both_sides_umts_fp_conv_data(pinfo, umts_fp_conversation_info);\n            }\n            if(!conversation_initialized) {\n                fill_pch_conversation_info_for_heur(umts_fp_conversation_info, pinfo);\n                fp_pch_channel_info = (fp_pch_channel_info_t*)umts_fp_conversation_info->channel_specific_info;\n            }\n            fp_pch_channel_info->paging_indications = pi_bit_length;\n            pi_length_found = true;\n        }\n        else if (tfi == 0x01 && !tb_size_found && pi_length_found) {\n            /* TB present and PI bitmap length is known. Can calculate TB length.*/\n            pi_byte_length = (fp_pch_channel_info->paging_indications + 7) / 8;\n            if (!umts_fp_conversation_info) {\n                umts_fp_conversation_info = wmem_new0(wmem_file_scope(), umts_fp_conversation_info_t);\n                set_both_sides_umts_fp_conv_data(pinfo, umts_fp_conversation_info);\n            }\n            if(!conversation_initialized) {\n                fill_pch_conversation_info_for_heur(umts_fp_conversation_info, pinfo);\n            }\n            tb_byte_length = (reported_length - (pi_byte_length + 6)); /* Removing header length (4), footer length (2) and PI bitmap length*/\n            /* Possible TB lengths for PCH is 10 or 30 bytes ( See 3GPP TR 25.944 / 4.1.1.2 ) */\n            if (tb_byte_length == 10 || tb_byte_length == 30) {\n                umts_fp_conversation_info->fp_dch_channel_info[0].dl_chan_tf_size[1] = tb_byte_length * 8;\n                tb_size_found = true;\n            }\n        }\n        /* TODO: It should be possible to figure both PI & TB sizes if both are present in a frame and neither is known */\n        /* Since the total size of the frame should be unique */\n        /* e.g. 19 bytes = header (4) + PI 18bits (3) + TB (10) + footer (2)*/\n        /*      21 bytes = header (4) + PI 36bits (5) + TB (10) + footer (2)*/\n        /*      etc... */\n        /* This could mostly help dissect 'busy' PCHs where most of the frames have both PI & TB*/\n    }\n    else {\n        if (tfi == 0x01 && !tb_size_found) {\n            /* TB present and PI bitmap is missing. Can calculate TB length.*/\n            if (!umts_fp_conversation_info) {\n                umts_fp_conversation_info = wmem_new0(wmem_file_scope(), umts_fp_conversation_info_t);\n                set_both_sides_umts_fp_conv_data(pinfo, umts_fp_conversation_info);\n            }\n            if(!conversation_initialized) {\n                fill_pch_conversation_info_for_heur(umts_fp_conversation_info, pinfo);\n            }\n            tb_byte_length = (reported_length - 6); /* Removing header length (4), footer length (2) */\n            /* Possible TB lengths for PCH is 10 or 30 bytes ( See 3GPP TR 25.944 / 4.1.1.2 ) */\n            if (tb_byte_length == 10 || tb_byte_length == 30) {\n                umts_fp_conversation_info->fp_dch_channel_info[0].dl_chan_tf_size[1] = tb_byte_length * 8;\n                set_both_sides_umts_fp_conv_data(pinfo, umts_fp_conversation_info);\n                tb_size_found = true;\n            }\n        }\n    }\n\n    if (pi_length_found && tb_size_found) {\n        /* Stream completely framed! */\n        conversation_set_dissector(find_or_create_conversation(pinfo), fp_handle);\n        dissect_fp(tvb, pinfo, tree, data);\n        return true;\n    }\n    else {\n        /* Some data still missing */\n        return false;\n    }\n}\nstatic bool\nheur_dissect_fp_hsdsch_type_1(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)\n{\n    conversation_t   *p_conv;\n    umts_fp_conversation_info_t* umts_fp_conversation_info = NULL;\n    fp_hsdsch_channel_info_t* fp_hsdsch_channel_info;\n    struct fp_info *p_fp_info;\n    uint32_t captured_length;\n    uint32_t reported_length;\n    uint8_t frame_type;\n    uint16_t mac_d_pdu_length;\n    uint16_t num_of_pdus;\n    uint32_t expected_total_size;\n    uint32_t next_pdu_index;\n    uint16_t index_step;\n    uint8_t pre_pdu_padding;\n\n    /* Trying to find existing conversation */\n    p_conv = (conversation_t *)find_conversation(pinfo->num, &pinfo->net_dst, &pinfo->net_src,\n        conversation_pt_to_conversation_type(pinfo->ptype),\n        pinfo->destport, pinfo->srcport, NO_ADDR_B);\n\n    if (p_conv != NULL) {\n        /* Checking if the conversation was already framed */\n        umts_fp_conversation_info = (umts_fp_conversation_info_t *)conversation_get_proto_data(p_conv, proto_fp);\n        if (umts_fp_conversation_info) {\n            fp_hsdsch_channel_info = (fp_hsdsch_channel_info_t*)umts_fp_conversation_info->channel_specific_info;\n            if (umts_fp_conversation_info->channel == CHANNEL_HSDSCH && fp_hsdsch_channel_info->hsdsch_entity == hs) {\n                conversation_set_dissector(p_conv, fp_handle);\n                dissect_fp(tvb, pinfo, tree, data);\n                return true;\n            }\n            else if (umts_fp_conversation_info->channel != CHANNEL_UNKNOWN){\n                /* This conversation was successfully framed as ANOTHER type */\n                return false;\n            }\n        }\n    }\n\n    /* Making sure FP info isn't already attached */\n    p_fp_info = (fp_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_fp, 0);\n    if (p_fp_info) {\n        return false;\n    }\n\n    captured_length = tvb_reported_length(tvb);\n    /* Lengths limit: header size (7) + at least 1 PDU Block (2) + CRC Payload size (2)*/\n    if (captured_length < 11) {\n        return false;\n    }\n\n    frame_type = tvb_get_uint8(tvb, 0) & 0x01;\n    if (frame_type == 1) { /* is 'control' frame type*/\n        return false;\n    }\n\n    /* Lengths limit: Smallest HS-DSCH type 1 data frame is 55 bytes (1 PDU of 336 bits) */\n    reported_length = tvb_reported_length(tvb);\n    if (reported_length < 55) {\n        return false;\n    }\n\n    mac_d_pdu_length = tvb_get_uint16(tvb, 2, ENC_NA) >> 3;\n    /* Only valid PDU lengths are 336 or 656 */\n    if (mac_d_pdu_length != 336 && mac_d_pdu_length != 656) {\n        return false;\n    }\n\n    num_of_pdus = tvb_get_uint8(tvb, 4);\n    /* PDUs count shouldn't be 0*/\n    if (num_of_pdus == 0) {\n        return false;\n    }\n    /* Maximum PDUs count constraint: 32 PDUs * 336 bits or 17 PDUs * 656 bits */\n    if ((mac_d_pdu_length == 336 && num_of_pdus > 32) || (mac_d_pdu_length == 656 && num_of_pdus > 17)) {\n        return false;\n    }\n\n    /* Making sure the expected packet size is smaller/equals to the entire packet's size */\n    expected_total_size = (num_of_pdus * mac_d_pdu_length / 8) + 7 /*Header length*/ + 2 /*Footer length*/;\n    if (expected_total_size > captured_length || expected_total_size > reported_length) {\n        return false;\n    }\n\n    /* Iterating through the PDUs making sure the padding nibble is present in all of them */\n    next_pdu_index = 7;\n    index_step = mac_d_pdu_length / 8;\n    for (int i = 0; i < num_of_pdus; i++)\n    {\n        pre_pdu_padding = tvb_get_uint8(tvb, next_pdu_index) >> 4;\n        if (pre_pdu_padding != 0x00)\n        {\n            /* One of the padding nibbles is not zeroed */\n            return false;\n        }\n        next_pdu_index += index_step;\n    }\n\n    if (!check_header_crc_for_heur(tvb, 7)) {\n        return false;\n    }\n    if (!check_payload_crc_for_heur(tvb, 7)) {\n        return false;\n    }\n\n    if(!umts_fp_conversation_info) {\n        umts_fp_conversation_info = wmem_new0(wmem_file_scope(), umts_fp_conversation_info_t);\n        set_both_sides_umts_fp_conv_data(pinfo, umts_fp_conversation_info);\n    }\n    umts_fp_conversation_info->iface_type = IuB_Interface;\n    umts_fp_conversation_info->division = Division_FDD;\n    umts_fp_conversation_info->dl_frame_number = pinfo->num;\n    umts_fp_conversation_info->ul_frame_number = pinfo->num;\n    umts_fp_conversation_info->dch_crc_present = 1;\n    umts_fp_conversation_info->com_context_id = generate_ue_id_for_heur(pinfo);\n    umts_fp_conversation_info->rlc_mode = FP_RLC_AM;\n    copy_address_wmem(wmem_file_scope(), &(umts_fp_conversation_info->crnc_address), &pinfo->src);\n    umts_fp_conversation_info->crnc_port = pinfo->srcport;\n    umts_fp_conversation_info->channel = CHANNEL_HSDSCH;\n    fp_hsdsch_channel_info = wmem_new0(wmem_file_scope(), fp_hsdsch_channel_info_t);\n    fp_hsdsch_channel_info->hsdsch_entity = hs;\n    fp_hsdsch_channel_info->hsdsch_macdflow_id = 0;\n    umts_fp_conversation_info->channel_specific_info = (void*)fp_hsdsch_channel_info;\n\n    conversation_set_dissector(find_or_create_conversation(pinfo), fp_handle);\n    dissect_fp(tvb, pinfo, tree, data);\n    return true;\n}\nstatic bool\nheur_dissect_fp_hsdsch_type_2(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)\n{\n    conversation_t   *p_conv;\n    umts_fp_conversation_info_t* umts_fp_conversation_info = NULL;\n    fp_hsdsch_channel_info_t* fp_hsdsch_channel_info;\n    struct fp_info *p_fp_info;\n    uint32_t captured_length;\n    uint32_t reported_length;\n    uint8_t frame_type;\n    uint8_t reserved_fach_ind_bits;\n    uint8_t pdu_block_header_reserved_bit;\n    uint8_t pdu_block_headers_count;\n    uint16_t next_pdu_block_header_index;\n    uint16_t pdu_block_header_pdu_length;\n    uint8_t pdu_block_header_pdus_count;\n    uint8_t pdu_block_header_lchid;\n    uint32_t total_header_length;\n    uint32_t expected_payload_length;\n\n    /* Trying to find existing conversation */\n    p_conv = (conversation_t *)find_conversation(pinfo->num, &pinfo->net_dst, &pinfo->net_src,\n        conversation_pt_to_conversation_type(pinfo->ptype),\n        pinfo->destport, pinfo->srcport, NO_ADDR_B);\n\n    if (p_conv != NULL) {\n        /* Checking if the conversation was already framed */\n        umts_fp_conversation_info = (umts_fp_conversation_info_t *)conversation_get_proto_data(p_conv, proto_fp);\n        if (umts_fp_conversation_info) {\n            fp_hsdsch_channel_info = (fp_hsdsch_channel_info_t*)umts_fp_conversation_info->channel_specific_info;\n            if (umts_fp_conversation_info->channel == CHANNEL_HSDSCH && fp_hsdsch_channel_info->hsdsch_entity == ehs) {\n                conversation_set_dissector(p_conv, fp_handle);\n                dissect_fp(tvb, pinfo, tree, data);\n                return true;\n            }\n            else if (umts_fp_conversation_info->channel != CHANNEL_UNKNOWN){\n                /* This conversation was successfully framed as ANOTHER type */\n                return false;\n            }\n        }\n    }\n\n    /* Making sure FP info isn't already attached */\n    p_fp_info = (fp_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_fp, 0);\n    if (p_fp_info) {\n        return false;\n    }\n\n    captured_length = tvb_captured_length(tvb);\n    reported_length = tvb_reported_length(tvb);\n    /* Lengths limit: header size + at least 1 PDU Block Header + CRC Payload size */\n    if (captured_length < 11) {\n        return false;\n    }\n\n    frame_type = tvb_get_uint8(tvb, 0) & 0x01;\n    if (frame_type == 1) { /* is 'control' frame type*/\n        return false;\n    }\n\n    pdu_block_header_reserved_bit = (tvb_get_uint8(tvb, 7) & 0x10) >> 4;\n    if (pdu_block_header_reserved_bit == 0x1) {\n        return false;\n    }\n\n    /* Expecting at least 1 PDU Block Header */\n    pdu_block_headers_count = tvb_get_uint8(tvb, 2) >> 3;\n    if (pdu_block_headers_count == 0) {\n        return false;\n    }\n\n    /* Getting 3 rightmost bits in the FACH Indicator's byte, which are reserved and should be 0 */\n    reserved_fach_ind_bits = tvb_get_uint8(tvb, 3) & 0x03;\n    if (reserved_fach_ind_bits != 0x00) {\n        return false;\n    }\n\n    /* Iterating through the block headers looking for invalid fields and */\n    /* calculating the expected total packet length */\n    total_header_length = 6;\n    expected_payload_length = 0;\n    for (int i = 0; i < pdu_block_headers_count; i++)\n    {\n        /* Making sure the next index is not out of range */\n        if (((uint32_t)(8 + (i * 3))) >= captured_length) {\n            return false;\n        }\n\n        /* Getting blocks length and count from the i-th header */\n        if (i % 2 == 0) {\n            next_pdu_block_header_index = (i * 25) / 10;\n        }\n        else {\n            next_pdu_block_header_index = (((i-1) * 25) / 10) + 2;\n        }\n        pdu_block_header_pdu_length = tvb_get_uint16(tvb, 6 + next_pdu_block_header_index, ENC_NA) >> 5;\n        pdu_block_header_pdus_count = tvb_get_uint8(tvb, 7 + next_pdu_block_header_index) & 0x0F;\n        pdu_block_header_lchid = tvb_get_uint8(tvb, 8 + next_pdu_block_header_index) >> 4;\n\n\n        /* Making sure PDUs' Length isn't zeroed*/\n        if (pdu_block_header_pdu_length == 0) {\n            return false;\n        }\n        /* Making sure PDUs Count isn't zeroed */\n        if (pdu_block_header_pdus_count == 0) {\n            return false;\n        }\n\n        /* Adding this header's length to expected length*/\n        if (i % 2 == 0) {\n            total_header_length += 3;\n        }\n        else {\n            total_header_length += 2;\n        }\n        /* Adding this header's payload's size to expected length*/\n        expected_payload_length += (pdu_block_header_pdu_length * pdu_block_header_pdus_count);\n\n        /* Checking padding after lchid */\n        if ((tvb_get_uint8(tvb, 8 + (i * 3)) & 0x0F) != 0x00) {\n            return false;\n        }\n        /* Checking lchid for reserved value 0x0F*/\n\n        if (pdu_block_header_lchid == 0x0F) {\n            return false;\n        }\n    }\n    /* Adding Payload CRC'slength to payload length*/\n    expected_payload_length += 2;\n    /* Calculated expected packet size must not exceed captured length or reported length*/\n    if ((total_header_length + expected_payload_length) > captured_length || (total_header_length + expected_payload_length) > reported_length) {\n        return false;\n    }\n\n    if (!check_header_crc_for_heur(tvb, total_header_length)) {\n        return false;\n    }\n    if (!check_payload_crc_for_heur(tvb, total_header_length)) {\n        return false;\n    }\n\n    if(!umts_fp_conversation_info) {\n        umts_fp_conversation_info = wmem_new0(wmem_file_scope(), umts_fp_conversation_info_t);\n        set_both_sides_umts_fp_conv_data(pinfo, umts_fp_conversation_info);\n    }\n    umts_fp_conversation_info->iface_type = IuB_Interface;\n    umts_fp_conversation_info->division = Division_FDD;\n    umts_fp_conversation_info->dl_frame_number = pinfo->num;\n    umts_fp_conversation_info->ul_frame_number = pinfo->num;\n    umts_fp_conversation_info->dch_crc_present = 1;\n    umts_fp_conversation_info->com_context_id = generate_ue_id_for_heur(pinfo);\n    umts_fp_conversation_info->rlc_mode = FP_RLC_AM;\n    copy_address_wmem(wmem_file_scope(), &(umts_fp_conversation_info->crnc_address), &pinfo->src);\n    umts_fp_conversation_info->crnc_port = pinfo->srcport;\n    umts_fp_conversation_info->channel = CHANNEL_HSDSCH;\n    fp_hsdsch_channel_info = wmem_new0(wmem_file_scope(), fp_hsdsch_channel_info_t);\n    fp_hsdsch_channel_info->hsdsch_entity = ehs;\n    fp_hsdsch_channel_info->hsdsch_macdflow_id = 1;\n    umts_fp_conversation_info->channel_specific_info = (void*)fp_hsdsch_channel_info;\n\n    conversation_set_dissector(find_or_create_conversation(pinfo), fp_handle);\n    dissect_fp(tvb, pinfo, tree, data);\n    return true;\n}\n\nstatic bool\nheur_dissect_fp_edch_type_1(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)\n{\n    conversation_t   *p_conv;\n    umts_fp_conversation_info_t* umts_fp_conversation_info = NULL;\n    fp_edch_channel_info_t* fp_edch_channel_info;\n    struct fp_info *p_fp_info;\n    uint32_t captured_length;\n    uint8_t frame_type;\n    uint8_t num_sub_frames_byte;\n    uint8_t number_of_subframes;\n    uint8_t number_of_mac_es_pdus;\n    uint32_t subframe_number;\n    uint32_t total_sub_headers_len;\n    uint32_t total_header_length;\n    uint32_t payload_length;\n    uint32_t total_mac_pdus_count;\n    uint32_t macd_pdu_bit_size;\n    uint32_t bit_offset;\n    uint32_t offset;\n    uint32_t i = 0;\n    uint32_t n = 0;\n\n    /* Trying to find existing conversation */\n    p_conv = (conversation_t *)find_conversation(pinfo->num, &pinfo->net_dst, &pinfo->net_src,\n        conversation_pt_to_conversation_type(pinfo->ptype),\n        pinfo->destport, pinfo->srcport, NO_ADDR_B);\n\n    if (p_conv != NULL) {\n        /* Checking if the conversation was already framed */\n        umts_fp_conversation_info = (umts_fp_conversation_info_t *)conversation_get_proto_data(p_conv, proto_fp);\n        if (umts_fp_conversation_info) {\n            fp_edch_channel_info = (fp_edch_channel_info_t*)umts_fp_conversation_info->channel_specific_info;\n            if (umts_fp_conversation_info->channel == CHANNEL_EDCH && fp_edch_channel_info->edch_type == 0) {\n                conversation_set_dissector(p_conv, fp_handle);\n                dissect_fp(tvb, pinfo, tree, data);\n                return true;\n            }\n            else if (umts_fp_conversation_info->channel != CHANNEL_UNKNOWN){\n                /* This conversation was successfully framed as ANOTHER type */\n                return false;\n            }\n        }\n    }\n\n    /* Making sure FP info isn't already attached */\n    p_fp_info = (fp_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_fp, 0);\n    if (p_fp_info) {\n        return false;\n    }\n\n    captured_length = tvb_reported_length(tvb);\n    /* Lengths limit: header size + at least 1 Subframe Header + CRC Payload size */\n    if (captured_length < 9) {\n        return false;\n    }\n\n    frame_type = tvb_get_uint8(tvb, 0) & 0x01;\n    if (frame_type == 1) { /* is 'control' frame type*/\n        return false;\n    }\n\n    num_sub_frames_byte = tvb_get_uint8(tvb, 2);\n    /* Checking 4 leftmost bits in the 'Number of Subframes' byte, which are reserved and should be 0 */\n    if (num_sub_frames_byte & 0xf0) {\n        return false;\n    }\n\n    /* Values {11-16} are reserved */\n    number_of_subframes = (num_sub_frames_byte & 0x0f) + 1;\n    if (number_of_subframes >= 11) {\n        return false;\n    }\n\n    /* Iterating through the block headers looking for invalid fields */\n    total_header_length = 4;\n    offset = 4;\n    total_mac_pdus_count = 0;\n    /* EDCH subframe header list */\n    for (n=0; n < number_of_subframes; n++) {\n\n        /* Making sure the next index is not out of range */\n        if (((uint32_t)(offset + 3)) >= captured_length) {\n            return false;\n        }\n\n        /* Subframe number */\n        subframe_number = (tvb_get_uint8(tvb, offset) & 0x07);\n        if (subframe_number > 4) {\n            return false;\n        }\n        offset++;\n\n        /* Number of MAC-es PDUs */\n        number_of_mac_es_pdus = (tvb_get_uint8(tvb, offset) & 0xf0) >> 4;\n        if (number_of_mac_es_pdus == 0) {\n            return false;\n        }\n        bit_offset = 4;\n\n        /* Making sure enough bytes are present for all sub-header */\n        total_sub_headers_len = ((int)((((1.5 + (number_of_mac_es_pdus * 1.5))*8+7)/8)));\n        if ((offset + total_sub_headers_len) >= captured_length) {\n            return false;\n        }\n        /* Details of each MAC-es PDU */\n        for (i=0; i < number_of_mac_es_pdus; i++) {\n            uint32_t n_pdus;    /*Size of the PDU*/\n\n            /* DDI (6 bits) */\n            bit_offset += 6;\n\n            /* Number of MAC-d PDUs (6 bits) */\n            n_pdus = tvb_get_bits8( tvb, offset*8 + bit_offset, 6);\n            total_mac_pdus_count += n_pdus;\n            bit_offset += 6;\n        }\n\n        total_header_length += total_sub_headers_len;\n        offset += ((bit_offset+7)/8);\n    }\n\n    /* Figure MAC bit size */\n    payload_length = captured_length - total_header_length - 3; /* Removing 3 bytes for Payload CRC and TSN */\n    if (payload_length == (total_mac_pdus_count * 42)) {\n        macd_pdu_bit_size = 336;\n    }\n    else if (payload_length == (total_mac_pdus_count * 18)) {\n        macd_pdu_bit_size = 144;\n    }\n    else {\n        /* Unexpected payload length or DDIs combination */\n        return false;\n    }\n\n    if (!check_edch_header_crc_for_heur(pinfo->pool, tvb, total_header_length)) {\n        return false;\n    }\n    if (!check_payload_crc_for_heur(tvb, total_header_length)) {\n        return false;\n    }\n\n    if(!umts_fp_conversation_info) {\n        umts_fp_conversation_info = wmem_new0(wmem_file_scope(), umts_fp_conversation_info_t);\n        set_both_sides_umts_fp_conv_data(pinfo, umts_fp_conversation_info);\n    }\n    umts_fp_conversation_info->iface_type = IuB_Interface;\n    umts_fp_conversation_info->division = Division_FDD;\n    umts_fp_conversation_info->dl_frame_number = pinfo->num;\n    umts_fp_conversation_info->ul_frame_number = pinfo->num;\n    umts_fp_conversation_info->dch_crc_present = 1;\n    umts_fp_conversation_info->com_context_id = generate_ue_id_for_heur(pinfo);\n    umts_fp_conversation_info->rlc_mode = FP_RLC_AM;\n    copy_address_wmem(wmem_file_scope(), &(umts_fp_conversation_info->crnc_address), &pinfo->src);\n    umts_fp_conversation_info->crnc_port = pinfo->srcport;\n    umts_fp_conversation_info->channel = CHANNEL_EDCH;\n    fp_edch_channel_info = wmem_new0(wmem_file_scope(), fp_edch_channel_info_t);\n    fp_edch_channel_info->no_ddi_entries = 0x0f;\n    for(i = 0;i<0x0f;i++) {\n        fp_edch_channel_info->edch_ddi[i] = i;\n        fp_edch_channel_info->edch_macd_pdu_size[i] = macd_pdu_bit_size;\n        fp_edch_channel_info->edch_lchId[i] = 9;\n    }\n    fp_edch_channel_info->edch_type = 0; /* Type 1 */\n    umts_fp_conversation_info->channel_specific_info = (void*)fp_edch_channel_info;\n\n    conversation_set_dissector(find_or_create_conversation(pinfo), fp_handle);\n    dissect_fp(tvb, pinfo, tree, data);\n    return true;\n}\n/* This method can frame UDP streams containing FP packets but dissection of those packets will */\n/* fail since the FP conversation info is never attached */\n/* Useful for DCH streams containing CS data and don't have their own heuristic method */\nstatic bool\nheur_dissect_fp_unknown_format(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)\n{\n    conversation_t   *p_conv;\n    umts_fp_conversation_info_t* umts_fp_conversation_info = NULL;\n    struct fp_info *p_fp_info;\n    uint32_t length;\n    uint8_t frame_type;\n    uint32_t ft;\n\n    /* Trying to find existing conversation */\n    p_conv = (conversation_t *)find_conversation(pinfo->num, &pinfo->net_dst, &pinfo->net_src,\n        conversation_pt_to_conversation_type(pinfo->ptype),\n        pinfo->destport, pinfo->srcport, NO_ADDR_B);\n\n    /* Check if FP Conversation Info is attached */\n    if (p_conv != NULL) {\n        umts_fp_conversation_info = (umts_fp_conversation_info_t *)conversation_get_proto_data(p_conv, proto_fp);\n        if (umts_fp_conversation_info) {\n            if (umts_fp_conversation_info->channel == CHANNEL_UNKNOWN) {\n                /* This stream was framed using a previous control frame, we can call FP dissector without further tests*/\n                dissect_fp(tvb, pinfo, tree, data);\n                return true;\n            }\n            else {\n                return false;\n            }\n        }\n    }\n\n    p_fp_info = (fp_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_fp, 0);\n\n    /* Check if per-frame FP Info is attached*/\n    if(p_fp_info) {\n        /* if FP info is present, check that it really is an ethernet link */\n        if (p_fp_info->link_type != FP_Link_Ethernet) {\n            return false;\n        }\n\n        /* discriminate 'lower' UDP layer from 'user data' UDP layer\n         * (i.e. if an FP over UDP packet contains a user UDP packet */\n        if (p_fp_info->srcport != pinfo->srcport ||\n            p_fp_info->destport != pinfo->destport)\n            return false;\n\n        /* assume this is FP */\n        dissect_fp(tvb, pinfo, tree, data);\n        return true;\n    }\n\n    /* Both per-frame FP info and conversation FP info are missing */\n    /* Try to frame control frames using header CRC */\n    ft = (tvb_get_uint8(tvb, 0) & 0x01);\n    if(ft != FT_CONTROL) {\n        /* This is a Data frame, can't tell if it's FP. */\n        return false;\n    }\n\n    length = tvb_captured_length(tvb);\n    /* Length limit: control frames header is 2 bytes */\n    if (length < 2) {\n        return false;\n    }\n\n    /* Check 'Frame Type' */\n    frame_type = tvb_get_uint8(tvb, 1);\n    /* 0x00 is unused for both dedicated & common FP */\n    if( frame_type == 0x00 ) {\n        return false;\n    }\n    /* Max frame types are: */\n    /* For common channels: 0x0E */\n    /* For dedicated channels: 0x0B */\n    /* The left nibble is zeroed in both cases */\n    if( (frame_type & 0xF0) != 0x00) {\n        return false;\n    }\n\n    /* Checking Header CRC*/\n    if (!check_control_frame_crc_for_heur(pinfo->pool, tvb)) {\n        /* The CRC is incorrect */\n        return false;\n    }\n\n    /* The CRC is correct! */\n    /* Attaching 'FP Conversation Info' to the UDP conversation so other */\n    /* packets (both Control AND Data) will be marked as FP */\n    umts_fp_conversation_info = wmem_new0(wmem_file_scope(), umts_fp_conversation_info_t);\n    umts_fp_conversation_info->channel = CHANNEL_UNKNOWN;\n    set_both_sides_umts_fp_conv_data(pinfo, umts_fp_conversation_info);\n    /* Call FP Dissector for the current frame */\n    dissect_fp(tvb, pinfo, tree, data);\n    return true;\n}\n\n/* This method wraps the heuristic dissectors of all supported channels */\nstatic bool\nheur_dissect_fp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)\n{\n    bool match;\n\n    match = heur_dissect_fp_dcch_over_dch(tvb, pinfo, tree, data);\n    if(match)\n        return true;\n    match = heur_dissect_fp_fach1(tvb, pinfo, tree, data);\n    if(match)\n        return true;\n    match = heur_dissect_fp_fach2(tvb, pinfo, tree, data);\n    if(match)\n        return true;\n    match = heur_dissect_fp_rach(tvb, pinfo, tree, data);\n    if(match)\n        return true;\n    match = heur_dissect_fp_pch(tvb, pinfo, tree, data);\n    if(match)\n        return true;\n    match = heur_dissect_fp_hsdsch_type_1(tvb, pinfo, tree, data);\n    if(match)\n        return true;\n    match = heur_dissect_fp_hsdsch_type_2(tvb, pinfo, tree, data);\n    if(match)\n        return true;\n    match = heur_dissect_fp_edch_type_1(tvb, pinfo, tree, data);\n    if(match)\n        return true;\n    /* NOTE: Add new heuristic dissectors BEFORE the 'unknown format' dissector */\n    /* since it might 'swallow' packets if the UDP stream is framed as 'CHANNEL_UNKNOWN' */\n    match = heur_dissect_fp_unknown_format(tvb, pinfo, tree, data);\n    if(match)\n        return true;\n\n    return false;\n}\n\nstatic uint8_t fakes =5; /*[] ={1,5,8};*/\nstatic uint8_t fake_map[256];\n\n /*\n * TODO: This need to be fixed!\n * Basically you would want the actual RRC messages, that sooner or later maps\n * transport channel id's to logical id's or RAB IDs\n * to set the proper logical channel/RAB ID, but for now we make syntethic ones.\n * */\n\nstatic uint8_t\nmake_fake_lchid(packet_info *pinfo _U_, int trchld)\n{\n    if ( fake_map[trchld] == 0) {\n        fake_map[trchld] = fakes;\n        fakes++;\n    }\n    return fake_map[trchld];\n}\n\n/* Tries to resolve the U-RNTI of a channel user based on info in the fp conv info */\nstatic void fp_conv_resolve_urnti(umts_fp_conversation_info_t *p_conv_data)\n{\n    /* Trying to resolve the U-RNTI of the user if missing */\n    /* Resolving based on the 'C-RNC Communication Context' field found in NBAP */\n    if (!p_conv_data->urnti && p_conv_data->com_context_id != 0) {\n        uint32_t * mapped_urnti = (uint32_t *)(wmem_tree_lookup32(nbap_crncc_urnti_map,p_conv_data->com_context_id));\n        if (mapped_urnti != 0) {\n            p_conv_data->urnti = GPOINTER_TO_UINT(mapped_urnti);\n        }\n    }\n}\n\n/* Figures the best \"UE ID\" to use in RLC reassembly logic */\nstatic uint32_t get_ue_id_from_conv(umts_fp_conversation_info_t *p_conv_data)\n{\n    uint32_t user_identity;\n    /* Choosing RLC 'UE ID': */\n    /* 1. Preferring the U-RNTI if attached */\n    /* 2. Fallback - Using the 'C-RNC Communication Context' used in NBAP for this user */\n    user_identity = p_conv_data->com_context_id;\n    if(p_conv_data->urnti) {\n        user_identity = p_conv_data->urnti;\n    }\n    return user_identity;\n}\n\nstatic fp_info *\nfp_set_per_packet_inf_from_conv(conversation_t *p_conv,\n                                umts_fp_conversation_info_t *p_conv_data,\n                                tvbuff_t *tvb, packet_info *pinfo,\n                                proto_tree *tree _U_)\n{\n    fp_info  *fpi;\n    uint8_t   tfi, c_t, lchid;\n    int       offset = 0, i=0, j=0, num_tbs, chan, tb_size, tb_bit_off;\n    uint32_t  ft;\n    bool      is_known_dcch_tf,is_stndalone_ps_rab_tf,is_muxed_cs_ps_tf;\n    umts_mac_info *macinf;\n    rlc_info *rlcinf;\n    uint8_t fake_lchid=0;\n    int *cur_val=NULL;\n    fp_hsdsch_channel_info_t* fp_hsdsch_channel_info = NULL;\n    fp_edch_channel_info_t* fp_edch_channel_info = NULL;\n    fp_pch_channel_info_t *fp_pch_channel_info = NULL;\n    fp_fach_channel_info_t* fp_fach_channel_info = NULL;\n    fp_rach_channel_info_t* fp_rach_channel_info = NULL;\n    bool info_missing = false;\n\n    fpi = wmem_new0(wmem_file_scope(), fp_info);\n    p_add_proto_data(wmem_file_scope(), pinfo, proto_fp, 0, fpi);\n\n    fpi->iface_type = p_conv_data->iface_type;\n    fpi->division = p_conv_data->division;\n    fpi->release = 7;               /* Set values greater then the checks performed */\n    fpi->release_year = 2006;\n    fpi->release_month = 12;\n    fpi->channel = p_conv_data->channel;\n    fpi->dch_crc_present = p_conv_data->dch_crc_present;\n    fpi->link_type = FP_Link_Ethernet;\n\n#if 0\n    /*Only do this the first run, signals that we need to reset the RLC fragtable*/\n    if (!PINFO_FD_VISITED(pinfo) &&  p_conv_data->reset_frag ) {\n        fpi->reset_frag = p_conv_data->reset_frag;\n        p_conv_data->reset_frag = false;\n    }\n#endif\n    /* remember 'lower' UDP layer port information so we can later\n     * differentiate 'lower' UDP layer from 'user data' UDP layer */\n    fpi->srcport = pinfo->srcport;\n    fpi->destport = pinfo->destport;\n\n    fpi->com_context_id = p_conv_data->com_context_id;\n    if(!p_conv_data->urnti) {\n        fp_conv_resolve_urnti(p_conv_data);\n    }\n    fpi->urnti = p_conv_data->urnti;\n\n    if (pinfo->link_dir == P2P_DIR_UL) {\n        fpi->is_uplink = true;\n    } else {\n        fpi->is_uplink = false;\n    }\n\n    ft = tvb_get_uint8(tvb, offset) & 0x01;\n\n    switch (fpi->channel) {\n        case CHANNEL_HSDSCH: /* HS-DSCH - High Speed Downlink Shared Channel */\n            fp_hsdsch_channel_info = (fp_hsdsch_channel_info_t*)p_conv_data->channel_specific_info;\n            if(fp_hsdsch_channel_info == NULL) {\n                proto_tree_add_expert_format(tree, pinfo, &ei_fp_no_per_conv_channel_info, tvb, offset, -1,\n                                      \"Can't dissect HS-DSCH FP stream because no per-conversation channel info was attached!\");\n                info_missing = true;\n                break;\n            }\n            fpi->hsdsch_entity = fp_hsdsch_channel_info->hsdsch_entity;\n            fpi->hsdsch_rlc_mode = p_conv_data->rlc_mode;\n            macinf = wmem_new0(wmem_file_scope(), umts_mac_info);\n            fpi->hsdsch_macflowd_id = fp_hsdsch_channel_info->hsdsch_macdflow_id;\n            macinf->content[0] = hsdsch_macdflow_id_mac_content_map[fp_hsdsch_channel_info->hsdsch_macdflow_id];\n            macinf->lchid[0] = fp_hsdsch_channel_info->hsdsch_macdflow_id;\n            p_add_proto_data(wmem_file_scope(), pinfo, proto_umts_mac, 0, macinf);\n\n            rlcinf = wmem_new0(wmem_file_scope(), rlc_info);\n\n            /*Figure out RLC_MODE based on MACd-flow-ID, basically MACd-flow-ID = 0 then it's SRB0 == UM else AM*/\n            rlcinf->mode[0] = hsdsch_macdflow_id_rlc_map[fp_hsdsch_channel_info->hsdsch_macdflow_id];\n\n            if (fpi->hsdsch_entity == hs) {\n                for (i=0; i<MAX_NUM_HSDHSCH_MACDFLOW; i++) {\n                    /*Figure out if this channel is multiplexed (signaled from RRC)*/\n                    if ((cur_val=(int *)g_tree_lookup(hsdsch_muxed_flows, GINT_TO_POINTER((int)fp_hsdsch_channel_info->hrnti))) != NULL) {\n                        j = 1 << i;\n                        fpi->hsdhsch_macfdlow_is_mux[i] = j & *cur_val;\n                    } else {\n                        fpi->hsdhsch_macfdlow_is_mux[i] = false;\n                    }\n\n                }\n            }\n            rlcinf->ueid[0] = get_ue_id_from_conv(p_conv_data);\n            rlcinf->li_size[0] = RLC_LI_7BITS;\n            rlcinf->ciphered[0] = false;\n            rlcinf->deciphered[0] = false;\n            p_add_proto_data(wmem_file_scope(), pinfo, proto_umts_rlc, 0, rlcinf);\n\n            return fpi;\n\n        case CHANNEL_EDCH:\n            fp_edch_channel_info = (fp_edch_channel_info_t*)p_conv_data->channel_specific_info;\n            if(fp_edch_channel_info == NULL) {\n                proto_tree_add_expert_format(tree, pinfo, &ei_fp_no_per_conv_channel_info, tvb, offset, -1,\n                                      \"Can't dissect E-DCH FP stream because no per-conversation channel info was attached!\");\n                info_missing = true;\n                break;\n            }\n            macinf = wmem_new0(wmem_file_scope(), umts_mac_info);\n            rlcinf = wmem_new0(wmem_file_scope(), rlc_info);\n            fpi->no_ddi_entries = fp_edch_channel_info->no_ddi_entries;\n            for (i=0; i<fpi->no_ddi_entries; i++) {\n                fpi->edch_ddi[i] = fp_edch_channel_info->edch_ddi[i];    /*Set the DDI value*/\n                fpi->edch_macd_pdu_size[i] = fp_edch_channel_info->edch_macd_pdu_size[i];    /*Set the PDU size*/\n                fpi->edch_lchId[i] = fp_edch_channel_info->edch_lchId[i];    /*Set the channel id for this entry*/\n            }\n            fpi->edch_type = fp_edch_channel_info->edch_type;\n\n            rlcinf->ueid[0] = get_ue_id_from_conv(p_conv_data);\n            rlcinf->li_size[0] = RLC_LI_7BITS;\n            rlcinf->ciphered[0] = false;\n            rlcinf->deciphered[0] = false;\n\n            p_add_proto_data(wmem_file_scope(), pinfo, proto_umts_mac, 0, macinf);\n            p_add_proto_data(wmem_file_scope(), pinfo, proto_umts_rlc, 0, rlcinf);\n\n            return fpi;\n\n        case CHANNEL_PCH:\n            fp_pch_channel_info = (fp_pch_channel_info_t*)p_conv_data->channel_specific_info;\n            if(fp_pch_channel_info == NULL) {\n                proto_tree_add_expert_format(tree, pinfo, &ei_fp_no_per_conv_channel_info, tvb, offset, -1,\n                                      \"Can't dissect PCH FP stream because no per-conversation channel info was attached!\");\n                info_missing = true;\n                break;\n            }\n            fpi->paging_indications = fp_pch_channel_info->paging_indications;\n            fpi->num_chans = p_conv_data->num_dch_in_flow;\n\n            if (ft == FT_CONTROL) {\n                /* control frame, we're done */\n                return fpi;\n            }\n            /* Inserting Paging Indication Info extracted from the previous packet */\n            fpi->relevant_paging_indications = fp_pch_channel_info->last_paging_indication_info;\n            fp_pch_channel_info->last_paging_indication_info = NULL;\n\n            /* Set offset to TFI */\n            offset = 3;\n            break;\n        case CHANNEL_DCH:\n            fpi->num_chans = p_conv_data->num_dch_in_flow;\n            if (ft == FT_CONTROL) {\n                /* control frame, we're done */\n                return fpi;\n            }\n\n            rlcinf = wmem_new0(wmem_file_scope(), rlc_info);\n            macinf = wmem_new0(wmem_file_scope(), umts_mac_info);\n            offset = 2; /* Set offset to TFI */\n            fakes  = 5; /* Reset fake counter */\n            for (chan=0; chan < fpi->num_chans; chan++) { /* Iterate over the DCH channels in the flow (each given a TFI) */\n                /* TFI is 5 bits according to 3GPP TS 25.427, paragraph 6.2.4.4 */\n                tfi = tvb_get_bits8(tvb, 3+offset*8, 5);\n\n                /* Figure out the number of TBs and size */\n                num_tbs = (fpi->is_uplink) ?\n                    p_conv_data->fp_dch_channel_info[chan].ul_chan_num_tbs[tfi] :\n                    p_conv_data->fp_dch_channel_info[chan].dl_chan_num_tbs[tfi];\n                tb_size = (fpi->is_uplink) ?\n                    p_conv_data->fp_dch_channel_info[chan].ul_chan_tf_size[tfi] :\n                    p_conv_data->fp_dch_channel_info[chan].dl_chan_tf_size[tfi];\n\n                tb_bit_off = (2 + p_conv_data->num_dch_in_flow) * 8; /*Point to the C/T of first TB*/\n                /* Iterate over the Transport Blocks */\n                /* Set configuration for each individual block */\n                for (j=0; j < num_tbs && j+chan < MAX_MAC_FRAMES; j++) {\n                    /* Set transport channel id (useful for debugging) */\n                    macinf->trchid[j+chan] = p_conv_data->dch_ids_in_flow_list[chan];\n\n                    /* Checking for the common Transport Format of 3.4 kbps SRBs for DCCH ( See 3GPP TR 25.944 / 4.1.1.3.1.1 ) */\n                    is_known_dcch_tf = (tfi == 1 && num_tbs == 1 && tb_size == 148);\n                    /* Checking for Transport Format of interactive or background PS RAB ( See 3GPP TS 34.108 / 6.10.2.4.1.23 -> 6.10.2.4.1.35 ) */\n                    is_stndalone_ps_rab_tf = tb_size == 336;\n                    /* Checking for Transport Format of muxed CS & PS RABs ( See 3GPP TS 34.108 / 6.10.2.4.1.38 -> 6.10.2.4.1.51 ) */\n                    is_muxed_cs_ps_tf = (p_conv_data->dch_ids_in_flow_list[chan] == 24 && tb_size == 340);\n\n                    if (is_known_dcch_tf || is_muxed_cs_ps_tf) {\n                        /* Channel is multiplexed (ie. C/T field present) */\n                        macinf->ctmux[j+chan] = true;\n\n                        /* Peek at C/T, different RLC params for different logical channels */\n                        /* C/T is 4 bits according to 3GPP TS 25.321, paragraph 9.2.1, from MAC header (not FP) */\n                        c_t = tvb_get_bits8(tvb, tb_bit_off, 4);\n                        lchid = (c_t + 1) % 0xf; /* C/T field represents the Logical Channel ID but it is zero-based */\n                        macinf->lchid[j+chan] = lchid;\n                        macinf->content[j+chan] = lchId_type_table[lchid]; /* Base MAC content on logical channel id (Table is in packet-nbap.h) */\n                        rlcinf->mode[j+chan] = lchId_rlc_map[lchid];       /* Base RLC mode on logical channel id */\n                    }\n                    else if (is_stndalone_ps_rab_tf) {\n                        /* Channel isn't multiplexed (ie. C/T field not present) */\n                        macinf->ctmux[j+chan] = false;\n\n                        /* Using a fake 'interactive PS' DTCH logical channel id */\n                        /* TODO: Once proper lchid is always set, this has to be changed */\n                        macinf->fake_chid[j+chan] = true;\n                        macinf->lchid[j+chan] = 11;\n                        macinf->content[j+chan] = MAC_CONTENT_PS_DTCH;\n                        rlcinf->mode[j+chan] = RLC_AM;\n                    }\n                    else {\n                        /* Unfamiliar DCH format, faking LCHID */\n                        /* Asuming the channel isn't multiplexed (ie. C/T field not present) */\n                        macinf->ctmux[j+chan] = false;\n\n                        /* TODO: This stuff has to be reworked! */\n                        /* Generates a fake logical channel id for non multiplexed channel */\n                        fake_lchid = make_fake_lchid(pinfo, p_conv_data->dch_ids_in_flow_list[chan]);\n                        macinf->content[j+chan] = lchId_type_table[fake_lchid];\n                        rlcinf->mode[j+chan] = lchId_rlc_map[fake_lchid];\n\n                        /************************/\n                        /* TODO: Once proper lchid is always set, this has to be removed */\n                        macinf->fake_chid[j+chan] = true;\n                        macinf->lchid[j+chan] = fake_lchid;\n                        /************************/\n                    }\n\n                    /* Set RLC data */\n                    rlcinf->ueid[j + chan] = get_ue_id_from_conv(p_conv_data);\n                    rlcinf->li_size[j+chan] = RLC_LI_7BITS;\n                    rlcinf->ciphered[j+chan] = false;\n                    rlcinf->deciphered[j+chan] = false;\n                    rlcinf->rbid[j+chan] = macinf->lchid[j+chan];\n\n                    /*Step over this TB and it's C/T field.*/\n                    tb_bit_off += tb_size+4;\n                }\n\n                offset++;\n            }\n            p_add_proto_data(wmem_file_scope(), pinfo, proto_umts_mac, 0, macinf);\n            p_add_proto_data(wmem_file_scope(), pinfo, proto_umts_rlc, 0, rlcinf);\n            /* Set offset to point to first TFI */\n            offset = 2;\n            break;\n        case CHANNEL_FACH_FDD:\n            fp_fach_channel_info = (fp_fach_channel_info_t*)p_conv_data->channel_specific_info;\n            if(fp_fach_channel_info == NULL) {\n                proto_tree_add_expert_format(tree, pinfo, &ei_fp_no_per_conv_channel_info, tvb, offset, -1,\n                                      \"Can't dissect FACH FP stream because no per-conversation channel info was attached!\");\n                info_missing = true;\n                break;\n            }\n            fpi->num_chans = p_conv_data->num_dch_in_flow;\n            if (ft == FT_CONTROL) {\n                /* control frame, we're done */\n                return fpi;\n            }\n            /* Set offset to TFI */\n            offset = 2;\n            /* Set MAC data */\n            macinf = wmem_new0(wmem_file_scope(), umts_mac_info);\n            macinf->ctmux[0]   = 1;\n            macinf->content[0] = MAC_CONTENT_DCCH;\n            p_add_proto_data(wmem_file_scope(), pinfo, proto_umts_mac, 0, macinf);\n            /* Set RLC data */\n            rlcinf = wmem_new0(wmem_file_scope(), rlc_info);\n            /* For RLC reassembly to work we need to fake a \"UE ID\" as an identifier of this stream.*/\n            /* Using the (UDP) conversation's ID and the prefix of 0xFFF */\n            rlcinf->ueid[0] = (p_conv->conv_index | 0xFFF00000);\n            rlcinf->mode[0] = RLC_AM;\n            rlcinf->li_size[0] = RLC_LI_7BITS;\n            rlcinf->ciphered[0] = false;\n            rlcinf->deciphered[0] = false;\n            p_add_proto_data(wmem_file_scope(), pinfo, proto_umts_rlc, 0, rlcinf);\n            break;\n\n        case CHANNEL_RACH_FDD:\n            fp_rach_channel_info = (fp_rach_channel_info_t*)p_conv_data->channel_specific_info;\n            if(fp_rach_channel_info == NULL) {\n                proto_tree_add_expert_format(tree, pinfo, &ei_fp_no_per_conv_channel_info, tvb, offset, -1,\n                                      \"Can't dissect RACH FP stream because no per-conversation channel info was attached!\");\n                info_missing = true;\n                break;\n            }\n            fpi->num_chans = p_conv_data->num_dch_in_flow;\n            if (ft == FT_CONTROL) {\n                /* control frame, we're done */\n                return fpi;\n            }\n            /* Set offset to TFI */\n            offset = 2;\n            /* set MAC & RLC data */\n            macinf = wmem_new0(wmem_file_scope(), umts_mac_info);\n            rlcinf = wmem_new0(wmem_file_scope(), rlc_info);\n            for ( chan = 0; chan < fpi->num_chans; chan++ ) {\n                macinf->ctmux[chan]   = 1;\n                macinf->content[chan] = MAC_CONTENT_DCCH;\n                /* RLC dissector's reassembly requires a non-zero stream identifier ('UE ID') to work */\n                /* For DCCH: MAC dissector will override this with C-RNTI/U-RNTI */\n                /* For CCCH: RLC's mode is TM and the dissector does not reassemble at all - showing 0 in the UI to indicate that */\n                rlcinf->ueid[chan] = 0;\n            }\n            p_add_proto_data(wmem_file_scope(), pinfo, proto_umts_mac, 0, macinf);\n            p_add_proto_data(wmem_file_scope(), pinfo, proto_umts_rlc, 0, rlcinf);\n            break;\n        case CHANNEL_HSDSCH_COMMON:\n            rlcinf = wmem_new0(wmem_file_scope(), rlc_info);\n            macinf = wmem_new0(wmem_file_scope(), umts_mac_info);\n            p_add_proto_data(wmem_file_scope(), pinfo, proto_umts_mac, 0, macinf);\n            p_add_proto_data(wmem_file_scope(), pinfo, proto_umts_rlc, 0, rlcinf);\n            break;\n        default:\n            expert_add_info(pinfo, NULL, &ei_fp_transport_channel_type_unknown);\n            info_missing = true;\n            break;\n    }\n\n    if(info_missing) {\n        /* Some information was missing in the conversation struct and the FP info isn't complete */\n        p_remove_proto_data(wmem_file_scope(), pinfo, proto_fp, 0);\n        wmem_free(wmem_file_scope(), fpi);\n        return NULL;\n    }\n\n    /* Peek at the packet as the per packet info seems not to take the tfi into account */\n    for (i=0; i<fpi->num_chans; i++) {\n        /*TFI is 5 bits according to 3GPP TS 25.427, paragraph 6.2.4.4*/\n        tfi = tvb_get_uint8(tvb, offset) & 0x1f;\n        if (pinfo->link_dir == P2P_DIR_UL) {\n            fpi->chan_tf_size[i] = p_conv_data->fp_dch_channel_info[i].ul_chan_tf_size[tfi];\n            fpi->chan_num_tbs[i] = p_conv_data->fp_dch_channel_info[i].ul_chan_num_tbs[tfi];\n        } else {\n            fpi->chan_tf_size[i] = p_conv_data->fp_dch_channel_info[i].dl_chan_tf_size[tfi];\n            fpi->chan_num_tbs[i] = p_conv_data->fp_dch_channel_info[i].dl_chan_num_tbs[tfi];\n        }\n        offset++;\n    }\n\n\n    return fpi;\n}\n\n/* Updates the conversation info of a PCH stream based on information parsed in the current frame*/\nstatic void\nupdate_pch_coversation_info(umts_fp_conversation_info_t *p_conv_data, packet_info *pinfo, struct fp_info *p_fp_info)\n{\n    fp_pch_channel_info_t* fp_pch_channel_info;\n    /* The channel type MUST be set to PCH */\n    DISSECTOR_ASSERT(p_conv_data);\n    DISSECTOR_ASSERT(p_conv_data->channel == CHANNEL_PCH);\n\n    fp_pch_channel_info = (fp_pch_channel_info_t*)p_conv_data->channel_specific_info;\n    if(p_fp_info->current_paging_indications && !PINFO_FD_VISITED(pinfo))\n    {\n        /* Saving the PI info for the next packet to find */\n        fp_pch_channel_info->last_paging_indication_info = p_fp_info->current_paging_indications;\n        /* Resetting this field so we don't add it again to the conversation next time the packet is parsed */\n        p_fp_info->current_paging_indications = NULL;\n    }\n}\n\n/*****************************/\n/* Main dissection function. */\nstatic int\ndissect_fp_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)\n{\n    proto_tree       *fp_tree;\n    proto_item       *ti;\n    int               offset = 0;\n    struct fp_info   *p_fp_info;\n    conversation_t   *p_conv = NULL;\n    umts_fp_conversation_info_t *p_conv_data = NULL;\n\n    /* Append this protocol name rather than replace. */\n    col_set_str(pinfo->cinfo, COL_PROTOCOL, \"FP\");\n\n    /* Create fp tree. */\n    ti = proto_tree_add_item(tree, proto_fp, tvb, offset, -1, ENC_NA);\n    fp_tree = proto_item_add_subtree(ti, ett_fp);\n\n    top_level_tree = tree;\n\n    /* Look for packet info! */\n    p_fp_info = (struct fp_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_fp, 0);\n\n    /* Check if we have conversation info */\n    /* Trying to find exact match - with both RNC's address & port and Node B's address & port */\n    p_conv = (conversation_t *)find_conversation(pinfo->num, &pinfo->net_dst, &pinfo->net_src,\n                               conversation_pt_to_conversation_type(pinfo->ptype),\n                               pinfo->destport, pinfo->srcport, 0);\n    if (p_conv) {\n        p_conv_data = (umts_fp_conversation_info_t *)conversation_get_proto_data(p_conv, proto_fp);\n    }\n    if (!p_conv || !p_conv_data) {\n        /* Didn't find exact conversation match */\n        /* Try to find a partial match with just the source/destination included */\n        p_conv = (conversation_t *)find_conversation(pinfo->num, &pinfo->net_dst, &pinfo->net_src,\n                                   conversation_pt_to_conversation_type(pinfo->ptype),\n                                   pinfo->destport, pinfo->srcport, NO_ADDR_B);\n        if (p_conv) {\n            p_conv_data = (umts_fp_conversation_info_t *)conversation_get_proto_data(p_conv, proto_fp);\n        }\n    }\n\n    if (p_conv_data) {\n        /*Figure out the direction of the link*/\n        if (addresses_equal(&(pinfo->net_dst), (&p_conv_data->crnc_address))) {\n            /* Node B -> CRNC*/\n            pinfo->link_dir=P2P_DIR_UL;\n\n            proto_item *item= proto_tree_add_uint(fp_tree, hf_fp_ul_setup_frame,\n                                                  tvb, 0, 0, p_conv_data->ul_frame_number);\n            proto_item_set_generated(item);\n        }\n        else {\n            /* CRNC -> Node B */\n            pinfo->link_dir=P2P_DIR_DL;\n\n            /* Maybe the frame number should be stored in the proper location already in nbap?, in ul_frame_number*/\n            proto_item *item= proto_tree_add_uint(fp_tree, hf_fp_dl_setup_frame,\n                                                   tvb, 0, 0, p_conv_data->ul_frame_number);\n            proto_item_set_generated(item);\n        }\n        if (p_fp_info == NULL) {\n            p_fp_info = fp_set_per_packet_inf_from_conv(p_conv, p_conv_data, tvb, pinfo, fp_tree);\n        }\n    }\n\n    if (pinfo->p2p_dir == P2P_DIR_UNKNOWN) {\n        if (pinfo->link_dir == P2P_DIR_UL) {\n            pinfo->p2p_dir = P2P_DIR_RECV;\n        } else {\n            pinfo->p2p_dir = P2P_DIR_SENT;\n        }\n    }\n\n    /* Can't dissect anything without it... */\n    if (p_fp_info == NULL) {\n        proto_tree_add_expert(fp_tree, pinfo, &ei_fp_no_per_frame_info, tvb, offset, -1);\n        return 1;\n    }\n\n    /* Show release information */\n    if (preferences_show_release_info) {\n        proto_item *release_ti;\n        proto_tree *release_tree;\n        proto_item *temp_ti;\n\n        release_ti = proto_tree_add_item(fp_tree, hf_fp_release, tvb, 0, 0, ENC_NA);\n        proto_item_set_generated(release_ti);\n        proto_item_append_text(release_ti, \" R%u (%d/%d)\",\n                               p_fp_info->release, p_fp_info->release_year, p_fp_info->release_month);\n        release_tree = proto_item_add_subtree(release_ti, ett_fp_release);\n\n        temp_ti = proto_tree_add_uint(release_tree, hf_fp_release_version, tvb, 0, 0, p_fp_info->release);\n        proto_item_set_generated(temp_ti);\n\n        temp_ti = proto_tree_add_uint(release_tree, hf_fp_release_year, tvb, 0, 0, p_fp_info->release_year);\n        proto_item_set_generated(temp_ti);\n\n        temp_ti = proto_tree_add_uint(release_tree, hf_fp_release_month, tvb, 0, 0, p_fp_info->release_month);\n        proto_item_set_generated(temp_ti);\n    }\n\n    /* Show channel type in info column, tree */\n    col_set_str(pinfo->cinfo, COL_INFO,\n                val_to_str_const(p_fp_info->channel,\n                                 channel_type_vals,\n                                 \"Unknown channel type\"));\n    if (p_conv_data) {\n        int i;\n        col_append_fstr(pinfo->cinfo, COL_INFO, \"(%u\", p_conv_data->dch_ids_in_flow_list[0]);\n        for (i=1; i < p_conv_data->num_dch_in_flow; i++) {\n            col_append_fstr(pinfo->cinfo, COL_INFO, \",%u\", p_conv_data->dch_ids_in_flow_list[i]);\n        }\n        col_append_str(pinfo->cinfo, COL_INFO, \") \");\n    }\n    proto_item_append_text(ti, \" (%s)\",\n                           val_to_str_const(p_fp_info->channel,\n                                            channel_type_vals,\n                                            \"Unknown channel type\"));\n\n    /* Add channel type as a generated field */\n    ti = proto_tree_add_uint(fp_tree, hf_fp_channel_type, tvb, 0, 0, p_fp_info->channel);\n    proto_item_set_generated(ti);\n\n    /* Add division type as a generated field */\n    if (p_fp_info->release == 7) {\n        ti = proto_tree_add_uint(fp_tree, hf_fp_division, tvb, 0, 0, p_fp_info->division);\n        proto_item_set_generated(ti);\n    }\n\n    /* Add link direction as a generated field */\n    ti = proto_tree_add_boolean(fp_tree, hf_fp_direction, tvb, 0, 0, p_fp_info->is_uplink);\n    proto_item_set_generated(ti);\n\n    /* Don't currently handle IuR-specific formats, but it's useful to even see\n       the channel type and direction */\n    if (p_fp_info->iface_type == IuR_Interface) {\n        return 1;\n    }\n\n    /* Show DDI config info */\n    if (p_fp_info->no_ddi_entries > 0) {\n        int n;\n        proto_item *ddi_config_ti;\n        proto_tree *ddi_config_tree;\n\n        ddi_config_ti = proto_tree_add_string_format(fp_tree, hf_fp_ddi_config, tvb, offset, 0,\n                                                     \"\", \"DDI Config (\");\n        proto_item_set_generated(ddi_config_ti);\n        ddi_config_tree = proto_item_add_subtree(ddi_config_ti, ett_fp_ddi_config);\n\n        /* Add each entry */\n        for (n=0; n < p_fp_info->no_ddi_entries; n++) {\n            proto_item_append_text(ddi_config_ti, \"%s%u->%ubits\",\n                                   (n == 0) ? \"\" : \"  \",\n                                   p_fp_info->edch_ddi[n], p_fp_info->edch_macd_pdu_size[n]);\n            ti = proto_tree_add_uint(ddi_config_tree, hf_fp_ddi_config_ddi, tvb, 0, 0,\n                                p_fp_info->edch_ddi[n]);\n            proto_item_set_generated(ti);\n            ti = proto_tree_add_uint(ddi_config_tree, hf_fp_ddi_config_macd_pdu_size, tvb, 0, 0,\n                                p_fp_info->edch_macd_pdu_size[n]);\n            proto_item_set_generated(ti);\n\n        }\n        proto_item_append_text(ddi_config_ti, \")\");\n    }\n\n    /*************************************/\n    /* Dissect according to channel type */\n    switch (p_fp_info->channel) {\n        case CHANNEL_RACH_TDD:\n        case CHANNEL_RACH_TDD_128:\n        case CHANNEL_RACH_FDD:\n            dissect_rach_channel_info(tvb, pinfo, fp_tree, offset, p_fp_info,\n                                      data);\n            break;\n        case CHANNEL_DCH:\n            dissect_dch_channel_info(tvb, pinfo, fp_tree, offset, p_fp_info,\n                                     data);\n            break;\n        case CHANNEL_FACH_FDD:\n        case CHANNEL_FACH_TDD:\n            dissect_fach_channel_info(tvb, pinfo, fp_tree, offset, p_fp_info,\n                                      data);\n            break;\n        case CHANNEL_DSCH_FDD:\n        case CHANNEL_DSCH_TDD:\n            dissect_dsch_channel_info(tvb, pinfo, fp_tree, offset, p_fp_info);\n            break;\n        case CHANNEL_USCH_TDD_128:\n        case CHANNEL_USCH_TDD_384:\n            dissect_usch_channel_info(tvb, pinfo, fp_tree, offset, p_fp_info);\n            break;\n        case CHANNEL_PCH:\n            dissect_pch_channel_info(tvb, pinfo, fp_tree, offset, p_fp_info,\n                                     data);\n            update_pch_coversation_info(p_conv_data, pinfo, p_fp_info);\n            break;\n        case CHANNEL_CPCH:\n            dissect_cpch_channel_info(tvb, pinfo, fp_tree, offset, p_fp_info);\n            break;\n        case CHANNEL_BCH:\n            dissect_bch_channel_info(tvb, pinfo, fp_tree, offset, p_fp_info);\n            break;\n        case CHANNEL_HSDSCH:\n            /* Show configured MAC HS-DSCH entity in use */\n            if (fp_tree)\n            {\n                proto_item *entity_ti;\n                entity_ti = proto_tree_add_uint(fp_tree, hf_fp_hsdsch_entity,\n                                                tvb, 0, 0,\n                                                p_fp_info->hsdsch_entity);\n                proto_item_set_generated(entity_ti);\n            }\n            switch (p_fp_info->hsdsch_entity) {\n                case entity_not_specified:\n                case hs:\n                    /* This is the pre-R7 default */\n                    dissect_hsdsch_channel_info(tvb, pinfo, fp_tree, offset, p_fp_info, data);\n                    break;\n                case ehs:\n                    dissect_hsdsch_type_2_channel_info(tvb, pinfo, fp_tree, offset, p_fp_info, data);\n                    break;\n                default:\n                    /* Report Error */\n                    expert_add_info(pinfo, NULL, &ei_fp_hsdsch_entity_not_specified);\n                    break;\n            }\n            break;\n        case CHANNEL_HSDSCH_COMMON:\n            expert_add_info(pinfo, NULL, &ei_fp_hsdsch_common_experimental_support);\n            /*if (false)*/\n            dissect_hsdsch_common_channel_info(tvb, pinfo, fp_tree, offset, p_fp_info, data);\n\n            break;\n        case CHANNEL_HSDSCH_COMMON_T3:\n            expert_add_info(pinfo, NULL, &ei_fp_hsdsch_common_t3_not_implemented);\n\n            /* TODO: */\n            break;\n        case CHANNEL_IUR_CPCHF:\n            /* TODO: */\n            break;\n        case CHANNEL_IUR_FACH:\n            /* TODO: */\n            break;\n        case CHANNEL_IUR_DSCH:\n            dissect_iur_dsch_channel_info(tvb, pinfo, fp_tree, offset, p_fp_info);\n            break;\n        case CHANNEL_EDCH:\n        case CHANNEL_EDCH_COMMON:\n            /* Show configured MAC E-DCH entity in use */\n            if (fp_tree)\n            {\n                proto_item *entity_ti;\n                entity_ti = proto_tree_add_uint(fp_tree, hf_fp_edch_entity,\n                                                tvb, 0, 0,\n                                                p_fp_info->edch_type);\n                proto_item_set_generated(entity_ti);\n            }\n            dissect_e_dch_channel_info(tvb, pinfo, fp_tree, offset, p_fp_info,\n                                       p_fp_info->channel == CHANNEL_EDCH_COMMON,\n                                       data);\n            break;\n\n        default:\n            expert_add_info(pinfo, NULL, &ei_fp_channel_type_unknown);\n            break;\n    }\n    return tvb_captured_length(tvb);\n}\n\nstatic int\ndissect_fp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)\n{\n    return dissect_fp_common(tvb, pinfo, tree, NULL);\n}\n\nstatic int\ndissect_fp_aal2(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)\n{\n    return dissect_fp_common(tvb, pinfo, tree, data);\n}\n\nvoid proto_register_fp(void)\n{\n    static hf_register_info hf[] =\n        {\n            { &hf_fp_release,\n              { \"Release\",\n                \"fp.release\", FT_NONE, BASE_NONE, NULL, 0x0,\n                \"Release information\", HFILL\n              }\n            },\n            { &hf_fp_release_version,\n              { \"Release Version\",\n                \"fp.release.version\", FT_UINT8, BASE_DEC, NULL, 0x0,\n                \"3GPP Release number\", HFILL\n              }\n            },\n            { &hf_fp_release_year,\n              { \"Release year\",\n                \"fp.release.year\", FT_UINT16, BASE_DEC, NULL, 0x0,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_release_month,\n              { \"Release month\",\n                \"fp.release.month\", FT_UINT8, BASE_DEC, NULL, 0x0,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_channel_type,\n              { \"Channel Type\",\n                \"fp.channel-type\", FT_UINT8, BASE_HEX, VALS(channel_type_vals), 0x0,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_division,\n              { \"Division\",\n                \"fp.division\", FT_UINT8, BASE_HEX, VALS(division_vals), 0x0,\n                \"Radio division type\", HFILL\n              }\n            },\n            { &hf_fp_direction,\n              { \"Direction\",\n                \"fp.direction\", FT_BOOLEAN, BASE_NONE, TFS(&tfs_uplink_downlink), 0x0,\n                \"Link direction\", HFILL\n              }\n            },\n            { &hf_fp_ddi_config,\n              { \"DDI Config\",\n                \"fp.ddi-config\", FT_STRING, BASE_NONE, NULL, 0x0,\n                \"DDI Config (for E-DCH)\", HFILL\n              }\n            },\n            { &hf_fp_ddi_config_ddi,\n              { \"DDI\",\n                \"fp.ddi-config.ddi\", FT_UINT8, BASE_DEC, NULL, 0x0,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_ddi_config_macd_pdu_size,\n              { \"MACd PDU Size\",\n                \"fp.ddi-config.macd-pdu-size\", FT_UINT16, BASE_DEC, NULL, 0x0,\n                NULL, HFILL\n              }\n            },\n\n\n            { &hf_fp_header_crc,\n              { \"Header CRC\",\n                \"fp.header-crc\", FT_UINT8, BASE_HEX, NULL, 0xfe,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_ft,\n              { \"Frame Type\",\n                \"fp.ft\", FT_UINT8, BASE_HEX, VALS(frame_type_vals), 0x01,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_cfn,\n              { \"CFN\",\n                \"fp.cfn\", FT_UINT8, BASE_DEC, NULL, 0x0,\n                \"Connection Frame Number\", HFILL\n              }\n            },\n            { &hf_fp_pch_cfn,\n              { \"CFN (PCH)\",\n                \"fp.pch.cfn\", FT_UINT16, BASE_DEC, NULL, 0xfff0,\n                \"PCH Connection Frame Number\", HFILL\n              }\n            },\n            { &hf_fp_pch_toa,\n              { \"ToA (PCH)\",\n                \"fp.pch.toa\", FT_INT24, BASE_DEC, NULL, 0x0,\n                \"PCH Time of Arrival\", HFILL\n              }\n            },\n            { &hf_fp_cfn_control,\n              { \"CFN control\",\n                \"fp.cfn-control\", FT_UINT8, BASE_DEC, NULL, 0x0,\n                \"Connection Frame Number Control\", HFILL\n              }\n            },\n            { &hf_fp_toa,\n              { \"ToA\",\n                \"fp.toa\", FT_INT16, BASE_DEC, NULL, 0x0,\n                \"Time of arrival (units are 125 microseconds)\", HFILL\n              }\n            },\n            { &hf_fp_tb,\n              { \"TB\",\n                \"fp.tb\", FT_BYTES, BASE_NONE, NULL, 0x0,\n                \"Transport Block\", HFILL\n              }\n            },\n            { &hf_fp_chan_zero_tbs,\n              { \"No TBs for channel\",\n                \"fp.channel-with-zero-tbs\", FT_UINT32, BASE_DEC, NULL, 0x0,\n                \"Channel with 0 TBs\", HFILL\n              }\n            },\n            { &hf_fp_tfi,\n              { \"TFI\",\n                \"fp.tfi\", FT_UINT8, BASE_DEC, NULL, 0x0,\n                \"Transport Format Indicator\", HFILL\n              }\n            },\n            { &hf_fp_usch_tfi,\n              { \"TFI\",\n                \"fp.usch.tfi\", FT_UINT8, BASE_DEC, NULL, 0x1f,\n                \"USCH Transport Format Indicator\", HFILL\n              }\n            },\n            { &hf_fp_cpch_tfi,\n              { \"TFI\",\n                \"fp.cpch.tfi\", FT_UINT8, BASE_DEC, NULL, 0x1f,\n                \"CPCH Transport Format Indicator\", HFILL\n              }\n            },\n            { &hf_fp_propagation_delay,\n              { \"Propagation Delay\",\n                \"fp.propagation-delay\", FT_UINT8, BASE_DEC, NULL, 0x0,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_dch_control_frame_type,\n              { \"Control Frame Type\",\n                \"fp.dch.control.frame-type\", FT_UINT8, BASE_HEX, VALS(dch_control_frame_type_vals), 0x0,\n                \"DCH Control Frame Type\", HFILL\n              }\n            },\n            { &hf_fp_dch_rx_timing_deviation,\n              { \"Rx Timing Deviation\",\n                \"fp.dch.control.rx-timing-deviation\", FT_UINT8, BASE_DEC, 0, 0x0,\n                \"DCH Rx Timing Deviation\", HFILL\n              }\n            },\n            { &hf_fp_quality_estimate,\n              { \"Quality Estimate\",\n                \"fp.dch.quality-estimate\", FT_UINT8, BASE_DEC, 0, 0x0,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_payload_crc,\n              { \"Payload CRC\",\n                \"fp.payload-crc\", FT_UINT16, BASE_HEX, 0, 0x0,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_payload_crc_status,\n              { \"Payload CRC Status\",\n                \"fp.payload-crc.status\", FT_UINT8, BASE_NONE, VALS(proto_checksum_vals), 0x0,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_common_control_frame_type,\n              { \"Control Frame Type\",\n                \"fp.common.control.frame-type\", FT_UINT8, BASE_HEX, VALS(common_control_frame_type_vals), 0x0,\n                \"Common Control Frame Type\", HFILL\n              }\n            },\n            { &hf_fp_crci[0],\n              { \"CRCI\",\n                \"fp.crci\", FT_UINT8, BASE_HEX, VALS(crci_vals), 0x80,\n                \"CRC correctness indicator\", HFILL\n              }\n            },\n            { &hf_fp_crci[1],\n              { \"CRCI\",\n                \"fp.crci\", FT_UINT8, BASE_HEX, VALS(crci_vals), 0x40,\n                \"CRC correctness indicator\", HFILL\n              }\n            },\n            { &hf_fp_crci[2],\n              { \"CRCI\",\n                \"fp.crci\", FT_UINT8, BASE_HEX, VALS(crci_vals), 0x20,\n                \"CRC correctness indicator\", HFILL\n              }\n            },\n            { &hf_fp_crci[3],\n              { \"CRCI\",\n                \"fp.crci\", FT_UINT8, BASE_HEX, VALS(crci_vals), 0x10,\n                \"CRC correctness indicator\", HFILL\n              }\n            },\n            { &hf_fp_crci[4],\n              { \"CRCI\",\n                \"fp.crci\", FT_UINT8, BASE_HEX, VALS(crci_vals), 0x08,\n                \"CRC correctness indicator\", HFILL\n              }\n            },\n            { &hf_fp_crci[5],\n              { \"CRCI\",\n                \"fp.crci\", FT_UINT8, BASE_HEX, VALS(crci_vals), 0x04,\n                \"CRC correctness indicator\", HFILL\n              }\n            },\n            { &hf_fp_crci[6],\n              { \"CRCI\",\n                \"fp.crci\", FT_UINT8, BASE_HEX, VALS(crci_vals), 0x02,\n                \"CRC correctness indicator\", HFILL\n              }\n            },\n            { &hf_fp_crci[7],\n              { \"CRCI\",\n                \"fp.crci\", FT_UINT8, BASE_HEX, VALS(crci_vals), 0x01,\n                \"CRC correctness indicator\", HFILL\n              }\n            },\n            { &hf_fp_received_sync_ul_timing_deviation,\n              { \"Received SYNC UL Timing Deviation\",\n                \"fp.rx-sync-ul-timing-deviation\", FT_UINT8, BASE_DEC, 0, 0x0,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_pch_pi,\n              { \"Paging Indication\",\n                \"fp.pch.pi\", FT_UINT8, BASE_DEC, VALS(paging_indication_vals), 0x01,\n                \"Indicates if the PI Bitmap is present\", HFILL\n              }\n            },\n            { &hf_fp_pch_tfi,\n              { \"TFI\",\n                \"fp.pch.tfi\", FT_UINT8, BASE_DEC, 0, 0x1f,\n                \"PCH Transport Format Indicator\", HFILL\n              }\n            },\n            { &hf_fp_fach_tfi,\n              { \"TFI\",\n                \"fp.fach.tfi\", FT_UINT8, BASE_DEC, 0, 0x1f,\n                \"FACH Transport Format Indicator\", HFILL\n              }\n            },\n            { &hf_fp_transmit_power_level,\n              { \"Transmit Power Level\",\n                \"fp.transmit-power-level\", FT_FLOAT, BASE_NONE, 0, 0x0,\n                \"Transmit Power Level (dB)\", HFILL\n              }\n            },\n            { &hf_fp_pdsch_set_id,\n              { \"PDSCH Set Id\",\n                \"fp.pdsch-set-id\", FT_UINT8, BASE_DEC, 0, 0x0,\n                \"A pointer to the PDSCH Set which shall be used to transmit\", HFILL\n              }\n            },\n            { &hf_fp_paging_indication_bitmap,\n              { \"Paging Indications bitmap\",\n                \"fp.pch.pi-bitmap\", FT_BYTES , BASE_NONE, NULL, 0x0,\n                \"Paging Indication bitmap\", HFILL\n              }\n            },\n            { &hf_fp_relevant_paging_indication_bitmap,\n              { \"Relevant Paging Indications bitmap\",\n                \"fp.pch.relevant-pi-bitmap\", FT_BYTES , BASE_NONE, NULL, 0x0,\n                \"The Paging Indication bitmap used to inform users about the current frame\", HFILL\n              }\n            },\n            { &hf_fp_rx_timing_deviation,\n              { \"Rx Timing Deviation\",\n                \"fp.common.control.rx-timing-deviation\", FT_UINT8, BASE_DEC, 0, 0x0,\n                \"Common Rx Timing Deviation\", HFILL\n              }\n            },\n            { &hf_fp_dch_e_rucch_flag,\n              { \"E-RUCCH Flag\",\n                \"fp.common.control.e-rucch-flag\", FT_UINT8, BASE_DEC, VALS(e_rucch_flag_vals), 0x0,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_edch_header_crc,\n              { \"E-DCH Header CRC\",\n                \"fp.edch.header-crc\", FT_UINT16, BASE_HEX, 0, 0,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_edch_fsn,\n              { \"FSN\",\n                \"fp.edch.fsn\", FT_UINT8, BASE_DEC, 0, 0x0f,\n                \"E-DCH Frame Sequence Number\", HFILL\n              }\n            },\n            { &hf_fp_edch_number_of_subframes,\n              { \"No of subframes\",\n                \"fp.edch.no-of-subframes\", FT_UINT8, BASE_DEC, 0, 0x0f,\n                \"E-DCH Number of subframes\", HFILL\n              }\n            },\n            { &hf_fp_edch_harq_retransmissions,\n              { \"No of HARQ Retransmissions\",\n                \"fp.edch.no-of-harq-retransmissions\", FT_UINT8, BASE_DEC, 0, 0x78,\n                \"E-DCH Number of HARQ retransmissions\", HFILL\n              }\n            },\n            { &hf_fp_edch_subframe_number,\n              { \"Subframe number\",\n                \"fp.edch.subframe-number\", FT_UINT8, BASE_DEC, 0, 0x0,\n                \"E-DCH Subframe number\", HFILL\n              }\n            },\n            { &hf_fp_edch_number_of_mac_es_pdus,\n              { \"Number of Mac-es PDUs\",\n                \"fp.edch.number-of-mac-es-pdus\", FT_UINT8, BASE_DEC, 0, 0xf0,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_edch_ddi,\n              { \"DDI\",\n                \"fp.edch.ddi\", FT_UINT8, BASE_DEC, 0, 0x0,\n                \"E-DCH Data Description Indicator\", HFILL\n              }\n            },\n            { &hf_fp_edch_subframe,\n              { \"Subframe\",\n                \"fp.edch.subframe\", FT_STRING, BASE_NONE, NULL, 0x0,\n                \"EDCH Subframe\", HFILL\n              }\n            },\n            { &hf_fp_edch_subframe_header,\n              { \"Subframe header\",\n                \"fp.edch.subframe-header\", FT_STRING, BASE_NONE, NULL, 0x0,\n                \"EDCH Subframe header\", HFILL\n              }\n            },\n            { &hf_fp_edch_number_of_mac_d_pdus,\n              { \"Number of Mac-d PDUs\",\n                \"fp.edch.number-of-mac-d-pdus\", FT_UINT8, BASE_DEC, 0, 0x0,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_edch_pdu_padding,\n              { \"Padding\",\n                \"fp.edch-data-padding\", FT_UINT8, BASE_DEC, 0, 0xc0,\n                \"E-DCH padding before PDU\", HFILL\n              }\n            },\n            { &hf_fp_edch_tsn,\n              { \"TSN\",\n                \"fp.edch-tsn\", FT_UINT8, BASE_DEC, 0, 0x3f,\n                \"E-DCH Transmission Sequence Number\", HFILL\n              }\n            },\n            { &hf_fp_edch_mac_es_pdu,\n              { \"MAC-es PDU\",\n                \"fp.edch.mac-es-pdu\", FT_NONE, BASE_NONE, NULL, 0x0,\n                NULL, HFILL\n              }\n            },\n\n            { &hf_fp_edch_user_buffer_size,\n              { \"User Buffer Size\",\n                \"fp.edch.user-buffer-size\", FT_UINT24, BASE_DEC, NULL, 0x0,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_edch_no_macid_sdus,\n              { \"No of MAC-is SDUs\",\n                \"fp.edch.no-macis-sdus\", FT_UINT16, BASE_DEC, NULL, 0x0,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_edch_number_of_mac_is_pdus,\n              { \"Number of Mac-is PDUs\",\n                \"fp.edch.number-of-mac-is-pdus\", FT_UINT8, BASE_DEC, 0, 0x0,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_edch_mac_is_pdu,\n              { \"Mac-is PDU\",\n                \"fp.edch.mac-is-pdu\", FT_BYTES, BASE_NONE, 0, 0x0,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_edch_e_rnti,\n              { \"E-RNTI\",\n                \"fp.edch.e-rnti\", FT_UINT16, BASE_DEC, 0, 0x0,\n                NULL, HFILL\n              }\n            },\n\n            { &hf_fp_edch_macis_descriptors,\n              { \"MAC-is Descriptors\",\n                \"fp.edch.mac-is.descriptors\", FT_STRING, BASE_NONE, NULL, 0x0,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_edch_macis_lchid,\n              { \"LCH-ID\",\n                \"fp.edch.mac-is.lchid\", FT_UINT8, BASE_HEX, VALS(lchid_vals), 0xf0,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_edch_macis_length,\n              { \"Length\",\n                \"fp.edch.mac-is.length\", FT_UINT16, BASE_DEC, 0, 0x0ffe,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_edch_macis_flag,\n              { \"Flag\",\n                \"fp.edch.mac-is.flag\", FT_UINT8, BASE_HEX, 0, 0x01,\n                \"Indicates if another entry follows\", HFILL\n              }\n            },\n            { &hf_fp_edch_entity,\n              { \"E-DCH Entity\",\n                \"fp.edch.entity\", FT_UINT8, BASE_DEC, VALS(edch_mac_entity_vals), 0x0,\n                \"Type of MAC entity for this E-DCH channel\", HFILL\n              }\n            },\n            { &hf_fp_frame_seq_nr,\n              { \"Frame Seq Nr\",\n                \"fp.frame-seq-nr\", FT_UINT8, BASE_DEC, 0, 0xf0,\n                \"Frame Sequence Number\", HFILL\n              }\n            },\n            { &hf_fp_hsdsch_pdu_block_header,\n              { \"PDU block header\",\n                \"fp.hsdsch.pdu-block-header\", FT_STRING, BASE_NONE, NULL, 0x0,\n                \"HS-DSCH type 2 PDU block header\", HFILL\n              }\n            },\n#if 0\n            { &hf_fp_hsdsch_pdu_block,\n              { \"PDU block\",\n                \"fp.hsdsch.pdu-block\", FT_STRING, BASE_NONE, NULL, 0x0,\n                \"HS-DSCH type 2 PDU block data\", HFILL\n              }\n            },\n#endif\n            { &hf_fp_flush,\n              { \"Flush\",\n                \"fp.flush\", FT_UINT8, BASE_DEC, 0, 0x04,\n                \"Whether all PDUs for this priority queue should be removed\", HFILL\n              }\n            },\n            { &hf_fp_fsn_drt_reset,\n              { \"FSN-DRT reset\",\n                \"fp.fsn-drt-reset\", FT_UINT8, BASE_DEC, 0, 0x02,\n                \"FSN/DRT Reset Flag\", HFILL\n              }\n            },\n            { &hf_fp_drt_indicator,\n              { \"DRT Indicator\",\n                \"fp.drt-indicator\", FT_UINT8, BASE_DEC, 0, 0x01,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_fach_indicator,\n              { \"FACH Indicator\",\n                \"fp.fach-indicator\", FT_UINT8, BASE_DEC, 0, 0x80,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_total_pdu_blocks,\n              { \"PDU Blocks\",\n                \"fp.pdu_blocks\", FT_UINT8, BASE_DEC, 0, 0xf8,\n                \"Total number of PDU blocks\", HFILL\n              }\n            },\n            { &hf_fp_drt,\n              { \"DelayRefTime\",\n                \"fp.drt\", FT_UINT16, BASE_DEC, 0, 0x0,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_hrnti,\n              { \"HRNTI\",\n                \"fp.hrnti\", FT_UINT16, BASE_DEC, 0, 0x0,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_rach_measurement_result,\n              { \"RACH Measurement Result\",\n                \"fp.rach-measurement-result\", FT_UINT16, BASE_DEC, 0, 0x0,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_lchid,\n              { \"Logical Channel ID\",\n                \"fp.lchid\", FT_UINT8, BASE_DEC, NULL, 0x0,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_pdu_length_in_block,\n              { \"PDU length in block\",\n                \"fp.pdu-length-in-block\", FT_UINT8, BASE_DEC, 0, 0x0,\n                \"Length of each PDU in this block in bytes\", HFILL\n              }\n            },\n            { &hf_fp_pdus_in_block,\n              { \"PDUs in block\",\n                \"fp.no-pdus-in-block\", FT_UINT8, BASE_DEC, 0, 0x0,\n                \"Number of PDUs in block\", HFILL\n              }\n            },\n            { &hf_fp_cmch_pi,\n              { \"CmCH-PI\",\n                \"fp.cmch-pi\", FT_UINT8, BASE_DEC, 0, 0x0f,\n                \"Common Transport Channel Priority Indicator\", HFILL\n              }\n            },\n            { &hf_fp_user_buffer_size,\n              { \"User buffer size\",\n                \"fp.user-buffer-size\", FT_UINT16, BASE_DEC, 0, 0x0,\n                \"User buffer size in octets\", HFILL\n              }\n            },\n            { &hf_fp_hsdsch_credits,\n              { \"HS-DSCH Credits\",\n                \"fp.hsdsch-credits\", FT_UINT16, BASE_DEC, 0, 0x0,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_hsdsch_max_macd_pdu_len,\n              { \"Max MAC-d PDU Length\",\n                \"fp.hsdsch.max-macd-pdu-len\", FT_UINT16, BASE_DEC, 0, 0xfff8,\n                \"Maximum MAC-d PDU Length in bits\", HFILL\n              }\n            },\n            { &hf_fp_hsdsch_max_macdc_pdu_len,\n              { \"Max MAC-d/c PDU Length\",\n                \"fp.hsdsch.max-macdc-pdu-len\", FT_UINT16, BASE_DEC, 0, 0x07ff,\n                \"Maximum MAC-d/c PDU Length in bits\", HFILL\n              }\n            },\n            { &hf_fp_hsdsch_interval,\n              { \"HS-DSCH Interval in milliseconds\",\n                \"fp.hsdsch-interval\", FT_UINT8, BASE_DEC, 0, 0x0,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_hsdsch_calculated_rate,\n              { \"Calculated rate allocation (bps)\",\n                \"fp.hsdsch-calculated-rate\", FT_UINT32, BASE_DEC, 0, 0x0,\n                \"Calculated rate RNC is allowed to send in bps\", HFILL\n              }\n            },\n            { &hf_fp_hsdsch_unlimited_rate,\n              { \"Unlimited rate\",\n                \"fp.hsdsch-unlimited-rate\", FT_NONE, BASE_NONE, 0, 0x0,\n                \"No restriction on rate at which date may be sent\", HFILL\n              }\n            },\n            { &hf_fp_hsdsch_repetition_period,\n              { \"HS-DSCH Repetition Period\",\n                \"fp.hsdsch-repetition-period\", FT_UINT8, BASE_DEC, 0, 0x0,\n                \"HS-DSCH Repetition Period in milliseconds\", HFILL\n              }\n            },\n            { &hf_fp_hsdsch_data_padding,\n              { \"Padding\",\n                \"fp.hsdsch-data-padding\", FT_UINT8, BASE_DEC, 0, 0xf0,\n                \"HS-DSCH Repetition Period in milliseconds\", HFILL\n              }\n            },\n            { &hf_fp_hsdsch_new_ie_flags,\n              { \"New IEs flags\",\n                \"fp.hsdsch.new-ie-flags\", FT_STRING, BASE_NONE, 0, 0x0,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_hsdsch_new_ie_flag[0],\n              { \"DRT IE present\",\n                \"fp.hsdsch.new-ie-flag\", FT_UINT8, BASE_DEC, 0, 0x80,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_hsdsch_new_ie_flag[1],\n              { \"New IE present\",\n                \"fp.hsdsch.new-ie-flag\", FT_UINT8, BASE_DEC, 0, 0x40,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_hsdsch_new_ie_flag[2],\n              { \"New IE present\",\n                \"fp.hsdsch.new-ie-flag\", FT_UINT8, BASE_DEC, 0, 0x20,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_hsdsch_new_ie_flag[3],\n              { \"New IE present\",\n                \"fp.hsdsch.new-ie-flag\", FT_UINT8, BASE_DEC, 0, 0x10,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_hsdsch_new_ie_flag[4],\n              { \"New IE present\",\n                \"fp.hsdsch.new-ie-flag\", FT_UINT8, BASE_DEC, 0, 0x08,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_hsdsch_new_ie_flag[5],\n              { \"New IE present\",\n                \"fp.hsdsch.new-ie-flag\", FT_UINT8, BASE_DEC, 0, 0x04,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_hsdsch_new_ie_flag[6],\n              { \"HS-DSCH physical layer category present\",\n                \"fp.hsdsch.new-ie-flag\", FT_UINT8, BASE_DEC, 0, 0x02,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_hsdsch_new_ie_flag[7],\n              { \"Another new IE flags byte\",\n                \"fp.hsdsch.new-ie-flags-byte\", FT_UINT8, BASE_DEC, 0, 0x01,\n                \"Another new IE flagsbyte\", HFILL\n              }\n            },\n            { &hf_fp_hsdsch_drt,\n              { \"DRT\",\n                \"fp.hsdsch.drt\", FT_UINT16, BASE_DEC, 0, 0x0,\n                \"Delay Reference Time\", HFILL\n              }\n            },\n            { &hf_fp_hsdsch_entity,\n              { \"HS-DSCH Entity\",\n                \"fp.hsdsch.entity\", FT_UINT8, BASE_DEC, VALS(hsdshc_mac_entity_vals), 0x0,\n                \"Type of MAC entity for this HS-DSCH channel\", HFILL\n              }\n            },\n            { &hf_fp_timing_advance,\n              { \"Timing advance\",\n                \"fp.timing-advance\", FT_UINT8, BASE_DEC, 0, 0x3f,\n                \"Timing advance in chips\", HFILL\n              }\n            },\n            { &hf_fp_num_of_pdu,\n              { \"Number of PDUs\",\n                \"fp.hsdsch.num-of-pdu\", FT_UINT8, BASE_DEC, 0, 0x0,\n                \"Number of PDUs in the payload\", HFILL\n              }\n            },\n            { &hf_fp_mac_d_pdu_len,\n              { \"MAC-d PDU Length\",\n                \"fp.hsdsch.mac-d-pdu-len\", FT_UINT16, BASE_DEC, 0, 0xfff8,\n                \"MAC-d PDU Length in bits\", HFILL\n              }\n            },\n            { &hf_fp_mac_d_pdu,\n              { \"MAC-d PDU\",\n                \"fp.mac-d-pdu\", FT_BYTES, BASE_NONE, NULL, 0x0,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_data,\n              { \"Data\",\n                \"fp.data\", FT_BYTES, BASE_NONE, NULL, 0x0,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_crcis,\n              { \"CRCIs\",\n                \"fp.crcis\", FT_BYTES, BASE_NONE, NULL, 0x0,\n                \"CRC Indicators for uplink TBs\", HFILL\n              }\n            },\n            { &hf_fp_t1,\n              { \"T1\",\n                \"fp.t1\", FT_FLOAT, BASE_NONE, NULL, 0x0,\n                \"RNC frame number indicating time it sends frame\", HFILL\n              }\n            },\n            { &hf_fp_t2,\n              { \"T2\",\n                \"fp.t2\", FT_FLOAT, BASE_NONE, NULL, 0x0,\n                \"NodeB frame number indicating time it received DL Sync\", HFILL\n              }\n            },\n            { &hf_fp_t3,\n              { \"T3\",\n                \"fp.t3\", FT_FLOAT, BASE_NONE, NULL, 0x0,\n                \"NodeB frame number indicating time it sends frame\", HFILL\n              }\n            },\n            { &hf_fp_ul_sir_target,\n              { \"UL_SIR_TARGET\",\n                \"fp.ul-sir-target\", FT_FLOAT, BASE_NONE, 0, 0x0,\n                \"Value (in dB) of the SIR target to be used by the UL inner loop power control\", HFILL\n              }\n            },\n            { &hf_fp_pusch_set_id,\n              { \"PUSCH Set Id\",\n                \"fp.pusch-set-id\", FT_UINT8, BASE_DEC, NULL, 0x0,\n                \"Identifies PUSCH Set from those configured in NodeB\", HFILL\n              }\n            },\n            { &hf_fp_activation_cfn,\n              { \"Activation CFN\",\n                \"fp.activation-cfn\", FT_UINT8, BASE_DEC, NULL, 0x0,\n                \"Activation Connection Frame Number\", HFILL\n              }\n            },\n            { &hf_fp_duration,\n              { \"Duration (ms)\",\n                \"fp.pusch-duration\", FT_UINT8, BASE_DEC, NULL, 0x0,\n                \"Duration of the activation period of the PUSCH Set\", HFILL\n              }\n            },\n            { &hf_fp_power_offset,\n              { \"Power offset\",\n                \"fp.power-offset\", FT_FLOAT, BASE_NONE, NULL, 0x0,\n                \"Power offset (in dB)\", HFILL\n              }\n            },\n            { &hf_fp_code_number,\n              { \"Code number\",\n                \"fp.code-number\", FT_UINT8, BASE_DEC, NULL, 0x0,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_spreading_factor,\n              { \"Spreading factor\",\n                \"fp.spreading-factor\", FT_UINT8, BASE_DEC, VALS(spreading_factor_vals), 0xf0,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_mc_info,\n              { \"MC info\",\n                \"fp.mc-info\", FT_UINT8, BASE_DEC, NULL, 0x0e,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_rach_new_ie_flags,\n              { \"New IEs flags\",\n                \"fp.rach.new-ie-flags\", FT_STRING, BASE_NONE, 0, 0x0,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_rach_new_ie_flag_unused[0],\n              { \"New IE present\",\n                \"fp.rach.new-ie-flag\", FT_UINT8, BASE_DEC, 0, 0x80,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_rach_new_ie_flag_unused[1],\n              { \"New IE present\",\n                \"fp.rach.new-ie-flag\", FT_UINT8, BASE_DEC, 0, 0x40,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_rach_new_ie_flag_unused[2],\n              { \"New IE present\",\n                \"fp.rach.new-ie-flag\", FT_UINT8, BASE_DEC, 0, 0x20,\n                \"New IE present (unused)\", HFILL\n              }\n            },\n            { &hf_fp_rach_new_ie_flag_unused[3],\n              { \"New IE present\",\n                \"fp.rach.new-ie-flag\", FT_UINT8, BASE_DEC, 0, 0x10,\n                \"New IE present (unused)\", HFILL\n              }\n            },\n            { &hf_fp_rach_new_ie_flag_unused[4],\n              { \"New IE present\",\n                \"fp.rach.new-ie-flag\", FT_UINT8, BASE_DEC, 0, 0x08,\n                \"New IE present (unused)\", HFILL\n              }\n            },\n            { &hf_fp_rach_new_ie_flag_unused[5],\n              { \"New IE present\",\n                \"fp.rach.new-ie-flag\", FT_UINT8, BASE_DEC, 0, 0x04,\n                \"New IE present (unused)\", HFILL\n              }\n            },\n            { &hf_fp_rach_new_ie_flag_unused[6],\n              { \"New IE present\",\n                \"fp.rach.new-ie-flag\", FT_UINT8, BASE_DEC, 0, 0x02,\n                \"New IE present (unused)\", HFILL\n              }\n            },\n            { &hf_fp_rach_cell_portion_id_present,\n              { \"Cell portion ID present\",\n                \"fp.rach.cell-portion-id-present\", FT_UINT8, BASE_DEC, 0, 0x01,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_rach_angle_of_arrival_present,\n              { \"Angle of arrival present\",\n                \"fp.rach.angle-of-arrival-present\", FT_UINT8, BASE_DEC, 0, 0x01,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_rach_ext_propagation_delay_present,\n              { \"Ext Propagation Delay Present\",\n                \"fp.rach.ext-propagation-delay-present\", FT_UINT8, BASE_DEC, 0, 0x02,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_rach_ext_rx_sync_ul_timing_deviation_present,\n              { \"Ext Received Sync UL Timing Deviation present\",\n                \"fp.rach.ext-rx-sync-ul-timing-deviation-present\", FT_UINT8, BASE_DEC, 0, 0x02,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_rach_ext_rx_timing_deviation_present,\n              { \"Ext Rx Timing Deviation present\",\n                \"fp.rach.ext-rx-timing-deviation-present\", FT_UINT8, BASE_DEC, 0, 0x01,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_cell_portion_id,\n              { \"Cell Portion ID\",\n                \"fp.cell-portion-id\", FT_UINT8, BASE_DEC, NULL, 0x3f,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_ext_propagation_delay,\n              { \"Ext Propagation Delay\",\n                \"fp.ext-propagation-delay\", FT_UINT16, BASE_DEC, NULL, 0x03ff,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_angle_of_arrival,\n              { \"Angle of Arrival\",\n                \"fp.angle-of-arrival\", FT_UINT16, BASE_DEC, NULL, 0x03ff,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_ext_received_sync_ul_timing_deviation,\n              { \"Ext Received SYNC UL Timing Deviation\",\n                \"fp.ext-received-sync-ul-timing-deviation\", FT_UINT16, BASE_DEC, NULL, 0x1fff,\n                NULL, HFILL\n              }\n            },\n\n\n            { &hf_fp_radio_interface_parameter_update_flag[0],\n              { \"CFN valid\",\n                \"fp.radio-interface-param.cfn-valid\", FT_UINT16, BASE_DEC, 0, 0x0001,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_radio_interface_parameter_update_flag[1],\n              { \"TPC PO valid\",\n                \"fp.radio-interface-param.tpc-po-valid\", FT_UINT16, BASE_DEC, 0, 0x0002,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_radio_interface_parameter_update_flag[2],\n              { \"DPC mode valid\",\n                \"fp.radio-interface-param.dpc-mode-valid\", FT_UINT16, BASE_DEC, 0, 0x0004,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_radio_interface_parameter_update_flag[3],\n              { \"RL sets indicator valid\",\n                \"fp.radio-interface_param.rl-sets-indicator-valid\", FT_UINT16, BASE_DEC, 0, 0x0020,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_radio_interface_parameter_update_flag[4],\n              { \"Maximum UE TX Power valid\",\n                \"fp.radio-interface-param.max-ue-tx-pow-valid\", FT_UINT16, BASE_DEC, 0, 0x0040,\n                \"MAX UE TX POW valid\", HFILL\n              }\n            },\n            { &hf_fp_dpc_mode,\n              { \"DPC Mode\",\n                \"fp.dpc-mode\", FT_UINT8, BASE_DEC, NULL, 0x20,\n                \"DPC Mode to be applied in the uplink\", HFILL\n              }\n            },\n            { &hf_fp_tpc_po,\n              { \"TPC Power Offset\",\n                \"fp.tpc-po\", FT_FLOAT, BASE_NONE, NULL, 0x0,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_multiple_rl_set_indicator,\n              { \"Multiple RL sets indicator\",\n                \"fp.multiple-rl-sets-indicator\", FT_UINT8, BASE_DEC, NULL, 0x80,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_max_ue_tx_pow,\n              { \"Maximum UE TX Power\",\n                \"fp.max-ue-tx-pow\", FT_INT8, BASE_DEC, NULL, 0x0,\n                \"Max UE TX POW (dBm)\", HFILL\n              }\n            },\n            { &hf_fp_congestion_status,\n              { \"Congestion Status\",\n                \"fp.congestion-status\", FT_UINT8, BASE_DEC, VALS(congestion_status_vals), 0x0,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_e_rucch_present,\n              { \"E-RUCCH Present\",\n                \"fp.erucch-present\", FT_UINT8, BASE_DEC, NULL, 0x0,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_extended_bits_present,\n              { \"Extended Bits Present\",\n                \"fp.extended-bits-present\", FT_UINT8, BASE_DEC, NULL, 0x0,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_extended_bits,\n              { \"Extended Bits\",\n                \"fp.extended-bits\", FT_UINT8, BASE_HEX, NULL, 0x0,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_spare_extension,\n              { \"Spare Extension\",\n                \"fp.spare-extension\", FT_NONE, BASE_NONE, NULL, 0x0,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_ul_setup_frame,\n              { \"UL setup frame\",\n                \"fp.ul.setup_frame\", FT_FRAMENUM, BASE_NONE, NULL, 0x0,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_dl_setup_frame,\n              { \"DL setup frame\",\n                \"fp.dl.setup_frame\", FT_FRAMENUM, BASE_NONE, NULL, 0x0,\n                NULL, HFILL\n              }\n            },\n            { &hf_fp_relevant_pi_frame,\n              { \"Paging Indications frame number\",\n                \"fp.pch.relevant-pi-frame\", FT_FRAMENUM, BASE_NONE, NULL, 0x0,\n                \"The frame where this Paging Indication bitmap was found\",\n                HFILL\n              }\n            },\n            { &hf_fp_hsdsch_physical_layer_category,\n              { \"HS-DSCH physical layer category\",\n                \"fp.hsdsch.physical_layer_category\", FT_UINT8, BASE_DEC, NULL, 0x0,\n                NULL, HFILL\n              }\n            }\n        };\n\n\n    static int *ett[] =\n    {\n        &ett_fp,\n        &ett_fp_data,\n        &ett_fp_crcis,\n        &ett_fp_ddi_config,\n        &ett_fp_edch_subframe_header,\n        &ett_fp_edch_subframe,\n        &ett_fp_edch_maces,\n        &ett_fp_edch_macis_descriptors,\n        &ett_fp_hsdsch_new_ie_flags,\n        &ett_fp_rach_new_ie_flags,\n        &ett_fp_hsdsch_pdu_block_header,\n        &ett_fp_pch_relevant_pi,\n        &ett_fp_release\n    };\n\n    static ei_register_info ei[] = {\n        { &ei_fp_bad_header_checksum, { \"fp.header.bad_checksum\", PI_CHECKSUM, PI_WARN, \"Bad header checksum\", EXPFILL }},\n        { &ei_fp_crci_no_subdissector, { \"fp.crci.no_subdissector\", PI_UNDECODED, PI_NOTE, \"Not sent to subdissectors as CRCI is set\", EXPFILL }},\n        { &ei_fp_crci_error_bit_set_for_tb, { \"fp.crci.error_bit_set_for_tb\", PI_CHECKSUM, PI_WARN, \"CRCI error bit set for TB\", EXPFILL }},\n        { &ei_fp_spare_extension, { \"fp.spare-extension.expert\", PI_UNDECODED, PI_WARN, \"Spare Extension present\", EXPFILL }},\n        { &ei_fp_bad_payload_checksum, { \"fp.payload-crc.bad\", PI_CHECKSUM, PI_WARN, \"Bad payload checksum\", EXPFILL }},\n        { &ei_fp_stop_hsdpa_transmission, { \"fp.stop_hsdpa_transmission\", PI_RESPONSE_CODE, PI_NOTE, \"Stop HSDPA transmission\", EXPFILL }},\n        { &ei_fp_timing_adjustment_reported, { \"fp.timing_adjustment_reported\", PI_SEQUENCE, PI_WARN, \"Timing adjustment reported\", EXPFILL }},\n        { &ei_fp_expecting_tdd, { \"fp.expecting_tdd\", PI_MALFORMED, PI_NOTE, \"Error: expecting TDD-384 or TDD-768\", EXPFILL }},\n        { &ei_fp_ddi_not_defined, { \"fp.ddi_not_defined\", PI_MALFORMED, PI_ERROR, \"DDI not defined for this UE!\", EXPFILL }},\n        { &ei_fp_unable_to_locate_ddi_entry, { \"fp.unable_to_locate_ddi_entry\", PI_UNDECODED, PI_ERROR, \"Unable to locate DDI entry.\", EXPFILL }},\n        { &ei_fp_mac_is_sdus_miscount, { \"fp.mac_is_sdus.miscount\", PI_MALFORMED, PI_ERROR, \"Found too many MAC-is SDUs\", EXPFILL }},\n        { &ei_fp_e_rnti_t2_edch_frames, { \"fp.e_rnti.t2_edch_frames\", PI_MALFORMED, PI_ERROR, \"E-RNTI not supposed to appear for T2 EDCH frames\", EXPFILL }},\n        { &ei_fp_e_rnti_first_entry, { \"fp.e_rnti.first_entry\", PI_MALFORMED, PI_ERROR, \"E-RNTI must be first entry among descriptors\", EXPFILL }},\n        { &ei_fp_maybe_srb, { \"fp.maybe_srb\", PI_PROTOCOL, PI_NOTE, \"Found MACd-Flow = 0 and not MUX detected. (This might be SRB)\", EXPFILL }},\n        { &ei_fp_transport_channel_type_unknown, { \"fp.transport_channel_type.unknown\", PI_UNDECODED, PI_WARN, \"Unknown transport channel type\", EXPFILL }},\n        { &ei_fp_pch_lost_relevant_pi_frame, { \"fp.pch_lost_relevant_pi_frame\", PI_SEQUENCE, PI_WARN, \"Previous PCH frame containing PI bitmap not captured (common at capture start)\", EXPFILL }},\n        { &ei_fp_hsdsch_entity_not_specified, { \"fp.hsdsch_entity_not_specified\", PI_MALFORMED, PI_ERROR, \"HSDSCH Entity not specified\", EXPFILL }},\n        { &ei_fp_hsdsch_common_experimental_support, { \"fp.hsdsch_common.experimental_support\", PI_DEBUG, PI_WARN, \"HSDSCH COMMON - Experimental support!\", EXPFILL }},\n        { &ei_fp_hsdsch_common_t3_not_implemented, { \"fp.hsdsch_common_t3.not_implemented\", PI_DEBUG, PI_ERROR, \"HSDSCH COMMON T3 - Not implemented!\", EXPFILL }},\n        { &ei_fp_channel_type_unknown, { \"fp.channel_type.unknown\", PI_MALFORMED, PI_ERROR, \"Unknown channel type\", EXPFILL }},\n        { &ei_fp_no_per_frame_info, { \"fp.no_per_frame_info\", PI_UNDECODED, PI_ERROR, \"Can't dissect FP frame because no per-frame info was attached!\", EXPFILL }},\n        { &ei_fp_no_per_conv_channel_info, { \"fp.no_per_conv_channel_info\", PI_UNDECODED, PI_ERROR, \"Can't dissect this FP stream because no per-conversation channel info was attached!\", EXPFILL }},\n        { &ei_fp_invalid_frame_count, { \"fp.invalid_frame_count\", PI_MALFORMED, PI_ERROR, \"Invalid frame count\", EXPFILL }},\n    };\n\n    module_t *fp_module;\n    expert_module_t *expert_fp;\n\n    /* Register protocol. */\n    proto_fp = proto_register_protocol(\"FP\", \"FP\", \"fp\");\n    proto_register_field_array(proto_fp, hf, array_length(hf));\n    proto_register_subtree_array(ett, array_length(ett));\n    expert_fp = expert_register_protocol(proto_fp);\n    expert_register_field_array(expert_fp, ei, array_length(ei));\n\n    /* Allow other dissectors to find this one by name. */\n    fp_handle = register_dissector(\"fp\", dissect_fp, proto_fp);\n    fp_aal2_handle = register_dissector(\"fp.aal2\", dissect_fp_aal2, proto_fp);\n\n    /* Preferences */\n    fp_module = prefs_register_protocol(proto_fp, NULL);\n\n    /* Determines whether release information should be displayed */\n    prefs_register_bool_preference(fp_module, \"show_release_info\",\n                                   \"Show reported release info\",\n                                   \"Show reported release info\",\n                                   &preferences_show_release_info);\n\n    /* Determines whether MAC dissector should be called for payloads */\n    prefs_register_bool_preference(fp_module, \"call_mac\",\n                                   \"Call MAC dissector for payloads\",\n                                   \"Call MAC dissector for payloads\",\n                                   &preferences_call_mac_dissectors);\n     /* Determines whether or not to validate FP payload checksums */\n    prefs_register_bool_preference(fp_module, \"payload_checksum\",\n                                    \"Validate FP payload checksums\",\n                                    \"Validate FP payload checksums\",\n                                    &preferences_payload_checksum);\n     /* Determines whether or not to validate FP header checksums */\n    prefs_register_bool_preference(fp_module, \"header_checksum\",\n                                    \"Validate FP header checksums\",\n                                    \"Validate FP header checksums\",\n                                    &preferences_header_checksum);\n     /* Determines whether or not to track Paging Indications between PCH frames*/\n     prefs_register_bool_preference(fp_module, \"track_paging_indications\",\n                                    \"Track Paging Indications in PCH channels\",\n                                    \"For each PCH data frame, Try to show the paging indications bitmap found in the previous frame\",\n                                    &preferences_track_paging_indications);\n    prefs_register_obsolete_preference(fp_module, \"udp_heur\");\n    prefs_register_obsolete_preference(fp_module, \"epandchannelconfigurationtable\");\n\n}\n\n\nvoid proto_reg_handoff_fp(void)\n{\n    rlc_bcch_handle           = find_dissector_add_dependency(\"rlc.bcch\", proto_fp);\n    mac_fdd_rach_handle       = find_dissector_add_dependency(\"mac.fdd.rach\", proto_fp);\n    mac_fdd_fach_handle       = find_dissector_add_dependency(\"mac.fdd.fach\", proto_fp);\n    mac_fdd_pch_handle        = find_dissector_add_dependency(\"mac.fdd.pch\", proto_fp);\n    mac_fdd_dch_handle        = find_dissector_add_dependency(\"mac.fdd.dch\", proto_fp);\n    mac_fdd_edch_handle       = find_dissector_add_dependency(\"mac.fdd.edch\", proto_fp);\n    mac_fdd_edch_type2_handle = find_dissector_add_dependency(\"mac.fdd.edch.type2\", proto_fp);\n    mac_fdd_hsdsch_handle     = find_dissector_add_dependency(\"mac.fdd.hsdsch\", proto_fp);\n\n    heur_dissector_add(\"udp\", heur_dissect_fp, \"FP over UDP\", \"fp_udp\", proto_fp, HEURISTIC_DISABLE);\n    heur_dissector_add(\"fp_mux\", heur_dissect_fp, \"FP over FP Mux\", \"fp_fp_mux\", proto_fp, HEURISTIC_ENABLE);\n\n    dissector_add_uint(\"atm.aal2.type\", TRAF_UMTS_FP, fp_aal2_handle);\n}\n\n/*\n * Editor modelines  -  https://www.wireshark.org/tools/modelines.html\n *\n * Local variables:\n * c-basic-offset: 4\n * tab-width: 8\n * indent-tabs-mode: nil\n * End:\n *\n * vi: set shiftwidth=4 tabstop=8 expandtab:\n * :indentSize=4:tabSize=8:noTabs=true:\n */\n", "patch": "@@ -4098,11 +4098,11 @@ fp_set_per_packet_inf_from_conv(umts_fp_conversation_info_t *p_conv_data,\n \n                                 /* Peek at C/T, different RLC params for different logical channels */\n                                 /*C/T is 4 bits according to 3GPP TS 25.321, paragraph 9.2.1, from MAC header (not FP)*/\n-                                c_t = tvb_get_bits8(tvb, tb_bit_off/*(2+p_conv_data->num_dch_in_flow)*8*/, 4);    /* c_t = tvb_get_guint8(tvb, offset);*/\n-                                macinf->lchid[j+chan] = c_t+1;\n+                                c_t = (tvb_get_bits8(tvb, tb_bit_off/*(2+p_conv_data->num_dch_in_flow)*8*/, 4) + 1) % 0xf;    /* c_t = tvb_get_guint8(tvb, offset);*/\n+                                macinf->lchid[j+chan] = c_t;\n \n-                                macinf->content[j+chan] = lchId_type_table[c_t+1];    /*Base MAC content on logical channel id (Table is in packet-nbap.h)*/\n-                                rlcinf->mode[j+chan] = lchId_rlc_map[c_t+1];    /*Based RLC mode on logical channel id*/\n+                                macinf->content[j+chan] = lchId_type_table[c_t];    /*Base MAC content on logical channel id (Table is in packet-nbap.h)*/\n+                                rlcinf->mode[j+chan] = lchId_rlc_map[c_t];    /*Based RLC mode on logical channel id*/\n                             }\n                         } else {\n                             fake_lchid = make_fake_lchid(pinfo, p_conv_data->dchs_in_flow_list[chan]);", "file_path": "files/2016_8\\41", "file_language": "c", "file_name": "epan/dissectors/packet-umts_fp.c", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}], "outdated": 0}
{"index": 11, "cve_id": "CVE-2016-5359", "cwe_id": ["CWE-119", "CWE-399"], "cve_language": "C", "cve_description": "epan/dissectors/packet-wbxml.c in the WBXML dissector in Wireshark 1.12.x before 1.12.12 mishandles offsets, which allows remote attackers to cause a denial of service (integer overflow and infinite loop) via a crafted packet.", "cvss": "5.9", "publish_date": "August 7, 2016", "AV": "NETWORK", "AC": "HIGH", "PR": "NONE", "UI": "NONE", "S": "UNCHANGED", "C": "NONE", "I": "NONE", "A": "HIGH", "commit_id": "b8e0d416898bb975a02c1b55883342edc5b4c9c0", "commit_message": "WBXML: add a basic sanity check for offset overflow\n\nThis is a naive approach allowing to detact that something went wrong,\nwithout the need to replace all proto_tree_add_text() calls as what was\ndone in master-2.0 branch.\n\nBug: 12408\nChange-Id: Ia14905005e17ae322c2fc639ad5e491fa08b0108\nReviewed-on: https://code.wireshark.org/review/15310\nReviewed-by: Michael Mann <mmann78@netscape.net>\nReviewed-by: Pascal Quantin <pascal.quantin@gmail.com>", "commit_date": "2016-05-10T08:42:16Z", "project": "wireshark/wireshark", "url": "https://api.github.com/repos/wireshark/wireshark/commits/b8e0d416898bb975a02c1b55883342edc5b4c9c0", "html_url": "https://github.com/wireshark/wireshark/commit/b8e0d416898bb975a02c1b55883342edc5b4c9c0", "windows_before": "", "windows_after": "", "parents": [{"commit_id_before": "0a8a44cea3db67962770d616cfed9f6aa66b662c", "url_before": "https://api.github.com/repos/wireshark/wireshark/commits/0a8a44cea3db67962770d616cfed9f6aa66b662c", "html_url_before": "https://github.com/wireshark/wireshark/commit/0a8a44cea3db67962770d616cfed9f6aa66b662c"}], "details": [{"raw_url": "https://github.com/wireshark/wireshark/raw/b8e0d416898bb975a02c1b55883342edc5b4c9c0/epan/dissectors/packet-wbxml.c", "code": "/* packet-wbxml.c\n *\n * Routines for WAP Binary XML dissection\n * Copyright 2003, 2004, Olivier Biot.\n *\n * Routines for WV-CSP 1.3 dissection\n * Copyright 2007, Andrei Rubaniuk.\n *\n * Refer to the AUTHORS file or the AUTHORS section in the man page\n * for contacting the author(s) of this file.\n *\n * Wireshark - Network traffic analyzer\n * By Gerald Combs <gerald@wireshark.org>\n * Copyright 1998 Gerald Combs\n *\n * WAP Binary XML decoding functionality provided by Olivier Biot.\n * WV-CSP 1.2 updated to Release version and WV-CSP 1.3 protocol\n * decoding functionality provided by Andrei Rubaniuk.\n *\n * The WAP specifications used to be found at the WAP Forum:\n *\t<http://www.wapforum.org/what/Technical.htm>\n * But now the correct link is at the Open Mobile Alliance:\n *\t<http://www.openmobilealliance.org/tech/affiliates/wap/wapindex.html>\n * Media types defined by OMA affiliates will have their standards at:\n *\t<http://www.openmobilealliance.org/tech/affiliates/index.html>\n *\t<http://www.openmobilealliance.org/release_program/index.html>\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version 2\n * of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */\n\n/* Edit this file with 4-space tabulation */\n\n#include \"config.h\"\n\n#include <string.h>\n\n#include <glib.h>\n\n#include <epan/packet.h>\n#include <epan/exceptions.h>\n#include <epan/prefs.h>\n#include <epan/wmem/wmem.h>\n\n/* We need the function tvb_get_guintvar() */\n#include \"packet-wap.h\"\n\nvoid proto_register_wbxml(void);\nvoid proto_reg_handoff_wbxml(void);\n\n/* General-purpose debug logger.\n * Requires double parentheses because of variable arguments of printf().\n *\n * Enable debug logging for WBXML by defining AM_FLAGS\n * so that it contains \"-DDEBUG_wbxml\"\n */\n#ifdef DEBUG_wbxml\n#define DebugLog(x)\t\t\t\t\\\n\tg_print(\"%s:%u: \", __FILE__, __LINE__); \\\n\tg_print x\n#else\n#define DebugLog(x) ;\n#endif\n\n/* The code in this source file dissects the WAP Binary XML content,\n * and if possible renders it. WBXML mappings are defined in the\n * \"wbxml_decoding\" structure.\n *\n * NOTES:\n *\n *  - Some WBXML content is *not* backwards compatible across minor versions.\n *    This painful remark is true for:\n *      o  WMLC 1.0 with respect to later WMLC 1.x\n *      o  All WV-CSP versions (never backwards compatible)\n *    The only way of correctly rendering the WBXML is to let the end-user\n *    choose from the possible renderings. This only applies to the case when\n *    the WBXML DocType is not included in the WBXML header (unknown/missing).\n *\n *  - Some WBXML content uses EXT_T_* in a non-tableref manner. This is the\n *    case with WV-CSP 1.1 and up, where the index points to a value_string\n *    containing WV-CSP specific token values. This is allowed as it is not\n *    explicitly forbidden in the WBXML specifications. Hence the global token\n *    map for content must also contain a function pointer if no tableref\n *    string is used.\n *\n *  - Code page switches apply until a new code page switch. In the WBXML/1.x\n *    ABNF notation, it can be proven that the switch_page can only precede\n *    the following tokens:\n *      o  stag      : TAG | LITERAL | LITERAL_A | LITERAL_C | LITERAL_AC\n *      o  attr      : ATTRSTART | ATTRVALUE\n *      o  extension : EXT_I | EXT_T | EXT\n *    Code page switches are displayed in a separate column.\n *\n *  - The WBXML spec states that code pages are static to both the tag and the\n *    attribute state parser. A SWITCH_PAGE within a state switches the code\n *    page of the active state only. Note that code page 255 is reserved for\n *    application-specific (read: testing) purposes.\n *\n *  - In order to render the XML content, recursion is inevitable at some\n *    point (when a tag with content occurs in the content of a tag with\n *    content). The code will however not recurse if this is not strictly\n *    required (e.g., tag without content in the content of a tag with\n *    content).\n *\n *  - I found it useful to display the XML nesting level as a first \"column\",\n *    followed by the abbreviated WBXML token interpretation. When a mapping\n *    is defined for the parsed WBXML content, then the XML rendering is\n *    displayed with appropriate indentation (maximum nesting level = 255,\n *    after which the nesting and level will safely roll-over to 0).\n *\n *  - The WAP Forum defines the order of precedence for finding out the\n *    WBXML content type (same rules for charset) as follows:\n *      1. Look in the Content-Type WSP header\n *      2. Look in the WBXML header\n *    Currently there is no means of using content type parameters:\n *      o  Type=<some_type>\n *      o  Charset=<charset_of_the_content>\n *    So it is possible some WBXML content types are incorrectly parsed.\n *    This would only be the case when the content type declaration in the\n *    WSP Content-Type header would be different (or would have parameters\n *    which are relevant to the WBXML decoding) from the content type\n *    identifier specified in the WBXML header. This has to do with the\n *    decoding of terminated text strings in the different character codings.\n *    TODO: investigate this and provide correct decoding at all times.\n */\n\ntypedef struct _value_valuestring {\n\tguint32 value;\n\tconst value_string *valstrptr;\n} value_valuestring;\n\n/* Tries to match val against each element in the value_value_string array vvs.\n * Returns the associated value_string ptr on a match, or NULL on failure. */\nstatic const value_string *\nval_to_valstr(guint32 val, const value_valuestring *vvs)\n{\n\tgint i = 0;\n\n\twhile (vvs[i].valstrptr) {\n\t\tif (vvs[i].value == val)\n\t\t\treturn(vvs[i].valstrptr);\n\t\ti++;\n\t}\n\n\treturn(NULL);\n}\n\n/* Note on Token mapping\n * ---------------------\n *\n * The WBXML dissector will try mapping the token decoding to their textual\n * representation if the media type has a defined token representation. The\n * following logic applies:\n *\n * a. Inspect the WBXML PublicID\n *\tThis means that I need a list { PublicID, decoding }\n *\n * b. Inspect the literal media type\n *\tThis requires a list { \"media/type\", discriminator, { decodings } }\n *\n *   b.1. Use a discriminator to choose an appropriate token mapping;\n *\tThe disciminator needs a small number of bytes from the data tvbuff_t.\n *\n * else\n *   b.2. Provide a list to the end-user with all possible token mappings.\n *\n * c. If none match then only show the tokens without mapping.\n *\n */\n\n/* ext_t_func_ptr is a pointer to a function handling the EXT_T_i tokens:\n *\n * char * ext_t_function(tvbuff_t *tvb, guint32 value, guint32 strtbl);\n */\ntypedef char * (* ext_t_func_ptr)(tvbuff_t *, guint32, guint32);\n\n/* Note on parsing of OPAQUE data\n * ------------------------------\n *\n * The WBXML encapsulation allows the insertion of opaque binary data in the\n * WBXML body. Although this opaque data has no meaning in WBXML, the media\n * type itself may define compact encoding of given input by encoding it in\n * such a OPAQUE blob of bytes.\n *\n * The WBXML dissector now supports dissection of OPAQUE data by means of a\n * mapping function that will operate based on the token (well-known or literal)\n * and the active code page.\n *\n * For well-known tokens the simplest approach is to use a switch for the code\n * pages and another switch for the relevant tokens within a code page.\n *\n * For literal tokens (tags and attribute names), the only approach is a string\n * comparison with the literal representation of the given tag or attribute\n * name.\n *\n * opaque_token_func_ptr is a pointer to a function handling OPAQUE values\n * for binary tokens representing tags or attribute starts.\n * opaque_literal_func_ptr is a pointer to a function handling OPAQUE values\n * for literal tokens representing tags or attribute starts.\n *\n * The length field of the OPAQUE entry starts at offset (not offset + 1).\n *\n * The length of the processed OPAQUE value is returned by reference.\n *\n * char * opaque_token_function(tvbuff_t *tvb, guint32 offset,\n * \t\tguint8 token, guint8 codepage, guint32 *length);\n * char * opaque_literal_function(tvbuff_t *tvb, guint32 offset,\n * \t\tconst char *token, guint8 codepage, guint32 *length);\n */\ntypedef char * (* opaque_token_func_ptr)(tvbuff_t *, guint32, guint8, guint8, guint32 *);\ntypedef char * (* opaque_literal_func_ptr)(tvbuff_t *, guint32, const char *, guint8, guint32 *);\n\nstatic char *\ndefault_opaque_binary_tag(tvbuff_t *tvb, guint32 offset,\n\t\t\t  guint8 token _U_, guint8 codepage _U_, guint32 *length)\n{\n\tguint32 data_len = tvb_get_guintvar(tvb, offset, length);\n\tchar *str = wmem_strdup_printf(wmem_packet_scope(), \"(%d bytes of opaque data)\", data_len);\n\t*length += data_len;\n\treturn str;\n}\n\nstatic char *\ndefault_opaque_literal_tag(tvbuff_t *tvb, guint32 offset,\n\t\t\t   const char *token _U_, guint8 codepage _U_, guint32 *length)\n{\n\tguint32 data_len = tvb_get_guintvar(tvb, offset, length);\n\tchar *str = wmem_strdup_printf(wmem_packet_scope(), \"(%d bytes of opaque data)\", data_len);\n\t*length += data_len;\n\treturn str;\n}\n\nstatic char *\ndefault_opaque_binary_attr(tvbuff_t *tvb, guint32 offset,\n\t\t\t   guint8 token _U_, guint8 codepage _U_, guint32 *length)\n{\n\tguint32 data_len = tvb_get_guintvar(tvb, offset, length);\n\tchar *str = wmem_strdup_printf(wmem_packet_scope(), \"(%d bytes of opaque data)\", data_len);\n\t*length += data_len;\n\treturn str;\n}\n\nstatic char *\ndefault_opaque_literal_attr(tvbuff_t *tvb, guint32 offset,\n\t\t\t    const char *token _U_, guint8 codepage _U_, guint32 *length)\n{\n\tguint32 data_len = tvb_get_guintvar(tvb, offset, length);\n\tchar *str = wmem_strdup_printf(wmem_packet_scope(), \"(%d bytes of opaque data)\", data_len);\n\t*length += data_len;\n\treturn str;\n}\n\n/* Render a hex %dateTime encoded timestamp as a string.\n * 0x20011231123456 becomes \"2001-12-31T12:34:56Z\" */\nstatic char *\ndate_time_from_opaque(tvbuff_t *tvb, guint32 offset, guint32 data_len)\n{\n\tchar *str;\n\n\tswitch (data_len) {\n\tcase 4: /* YYYY-MM-DD[T00:00:00Z] */\n\t\tstr = wmem_strdup_printf(wmem_packet_scope(), \"%%DateTime: \"\n\t\t\t\t      \"%02x%02x-%02x-%02xT00:00:00Z\",\n\t\t\t\t      tvb_get_guint8(tvb, offset),\n\t\t\t\t      tvb_get_guint8(tvb, offset + 1),\n\t\t\t\t      tvb_get_guint8(tvb, offset + 2),\n\t\t\t\t      tvb_get_guint8(tvb, offset + 3));\n\t\tbreak;\n\tcase 5: /* YYYY-MM-DDThh[:00:00Z] */\n\t\tstr = wmem_strdup_printf(wmem_packet_scope(), \"%%DateTime: \"\n\t\t\t\t      \"%02x%02x-%02x-%02xT%02x:00:00Z\",\n\t\t\t\t      tvb_get_guint8(tvb, offset),\n\t\t\t\t      tvb_get_guint8(tvb, offset + 1),\n\t\t\t\t      tvb_get_guint8(tvb, offset + 2),\n\t\t\t\t      tvb_get_guint8(tvb, offset + 3),\n\t\t\t\t      tvb_get_guint8(tvb, offset + 4));\n\t\tbreak;\n\tcase 6: /* YYYY-MM-DDThh:mm[:00Z] */\n\t\tstr = wmem_strdup_printf(wmem_packet_scope(), \"%%DateTime: \"\n\t\t\t\t      \"%02x%02x-%02x-%02xT%02x:%02x:00Z\",\n\t\t\t\t      tvb_get_guint8(tvb, offset),\n\t\t\t\t      tvb_get_guint8(tvb, offset + 1),\n\t\t\t\t      tvb_get_guint8(tvb, offset + 2),\n\t\t\t\t      tvb_get_guint8(tvb, offset + 3),\n\t\t\t\t      tvb_get_guint8(tvb, offset + 4),\n\t\t\t\t      tvb_get_guint8(tvb, offset + 5));\n\t\tbreak;\n\tcase 7: /* YYYY-MM-DDThh:mm[:00Z] */\n\t\tstr = wmem_strdup_printf(wmem_packet_scope(), \"%%DateTime: \"\n\t\t\t\t      \"%02x%02x-%02x-%02xT%02x:%02x:%02xZ\",\n\t\t\t\t      tvb_get_guint8(tvb, offset),\n\t\t\t\t      tvb_get_guint8(tvb, offset + 1),\n\t\t\t\t      tvb_get_guint8(tvb, offset + 2),\n\t\t\t\t      tvb_get_guint8(tvb, offset + 3),\n\t\t\t\t      tvb_get_guint8(tvb, offset + 4),\n\t\t\t\t      tvb_get_guint8(tvb, offset + 5),\n\t\t\t\t      tvb_get_guint8(tvb, offset + 6));\n\t\tbreak;\n\tdefault:\n\t\tstr = wmem_strdup_printf(wmem_packet_scope(), \"<Error: invalid binary %%DateTime \"\n\t\t\t\t      \"(%d bytes of opaque data)>\", data_len);\n\t\tbreak;\n\t}\n\n\treturn str;\n}\n\n/* Is ALWAYS 6 bytes long:\n * 00YY YYYY  YYYY YYMM  MMDD DDDh  hhhh mmmm  mmss ssss  ZZZZ ZZZZ */\nstatic char *\nwv_datetime_from_opaque(tvbuff_t *tvb, guint32 offset, guint32 data_len)\n{\n\tchar *str;\n\tguint16 year;\n\tguint8 month, day, hour, minute, second, time_zone;\n\tguint8 peek;\n\n\tif (data_len == 6) { /* Valid */\n\n\t\t/* Octet 1: 00YY YYYY */\n\t\tyear = tvb_get_guint8(tvb, offset) & 0x3F; /* ..11 1111 */\n\t\tyear <<=6;\n\t\t/* Octet 2: YYYY YYMM */\n\t\tpeek = tvb_get_guint8(tvb, offset + 1);\n\t\tyear += (peek >> 2); /* 1111 11.. */\n\t\tmonth = (peek & 0x03) << 2; /* .... ..11 */\n\t\t/* Octet 3: MMDD DDDh */\n\t\tpeek = tvb_get_guint8(tvb, offset + 2);\n\t\tmonth += (peek >> 6); /* 11.. .... */\n\t\tday = (peek & 0x3E) >> 1; /* ..11 111. */\n\t\thour = (peek & 0x01) << 4; /* .... ...1 */\n\t\t/* Octet 4: hhhh mmmm */\n\t\tpeek = tvb_get_guint8(tvb, offset + 3);\n\t\thour += (peek >> 4);\n\t\tminute = (peek & 0x0F) << 2; /* .... 1111 */\n\t\t/* Octet 5: mmss ssss */\n\t\tpeek = tvb_get_guint8(tvb, offset + 4);\n\t\tminute += (peek >> 6); /* 11.. .... */\n\t\tsecond = peek & 0x3F; /* ..11 1111 */\n\t\t/* octet 6: ZZZZZZZZ */\n\t\ttime_zone = tvb_get_guint8(tvb, offset + 5);\n\t\t/* Now construct the string */\n\t\tstr = wmem_strdup_printf(wmem_packet_scope(), \"WV-CSP DateTime: \"\n\t\t\t\t      \"%04d-%02d-%02dT%02d:%02d:%02d%c\",\n\t\t\t\t      year, month, day, hour, minute, second, time_zone);\n\t} else { /* Invalid length for a WV-CSP DateTime tag value */\n\t\tstr = wmem_strdup_printf(wmem_packet_scope(), \"<Error: invalid binary WV-CSP DateTime value \"\n\t\t\t\t      \"(%d bytes of opaque data)>\", data_len);\n\t}\n\treturn str;\n}\n\n/* WV-CSP integer values for tag content is encoded in a fashion similar\n * to a Long-Integer in WSP */\nstatic char *\nwv_integer_from_opaque(tvbuff_t *tvb, guint32 offset, guint32 data_len)\n{\n\tchar *str;\n\n\tswitch (data_len) {\n\tcase 1:\n\t\tstr = wmem_strdup_printf(wmem_packet_scope(), \"WV-CSP Integer: %d\",\n\t\t\t\t      tvb_get_guint8(tvb, offset));\n\t\tbreak;\n\tcase 2:\n\t\tstr = wmem_strdup_printf(wmem_packet_scope(), \"WV-CSP Integer: %d\",\n\t\t\t\t      tvb_get_ntohs(tvb, offset));\n\t\tbreak;\n\tcase 3:\n\t\tstr = wmem_strdup_printf(wmem_packet_scope(), \"WV-CSP Integer: %d\",\n\t\t\t\t      tvb_get_ntoh24(tvb, offset));\n\t\tbreak;\n\tcase 4:\n\t\tstr = wmem_strdup_printf(wmem_packet_scope(), \"WV-CSP Integer: %d\",\n\t\t\t\t      tvb_get_ntohl(tvb, offset));\n\t\tbreak;\n\tdefault:\n\t\tstr = wmem_strdup_printf(wmem_packet_scope(), \"<Error: invalid binary WV-CSP Integer value \"\n\t\t\t\t      \"(%d bytes of opaque data)>\", data_len);\n\t\tbreak;\n\t}\n\n\treturn str;\n}\n\nstatic char *\nwv_csp10_opaque_binary_tag(tvbuff_t *tvb, guint32 offset,\n\t\t\t   guint8 token, guint8 codepage, guint32 *length)\n{\n\tguint32 data_len = tvb_get_guintvar(tvb, offset, length);\n\tchar *str = NULL;\n\n\tswitch (codepage) {\n\tcase 0: /* Common code page */\n\t\tswitch (token) {\n\t\tcase 0x0B: /* <Code> */\n\t\tcase 0x0F: /* <ContentSize> */\n\t\tcase 0x1A: /* <MessageCount> */\n\t\tcase 0x3C: /* <Validity> */\n\t\t\tstr = wv_integer_from_opaque(tvb,\n\t\t\t\t\t\t     offset + *length, data_len);\n\t\t\tbreak;\n\t\tcase 0x11: /* <DateTime> */\n\t\t\tstr = wv_datetime_from_opaque(tvb,\n\t\t\t\t\t\t      offset + *length, data_len);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 1: /* Access code page */\n\t\tswitch (token) {\n\t\tcase 0x1C: /* <KeepAliveTime> */\n\t\tcase 0x32: /* <TimeToLive> */\n\t\t\tstr = wv_integer_from_opaque(tvb,\n\t\t\t\t\t\t     offset + *length, data_len);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 3: /* Client capability code page */\n\t\tswitch (token) {\n\t\tcase 0x06: /* <AcceptedContentLength> */\n\t\tcase 0x0C: /* <MultiTrans> */\n\t\tcase 0x0D: /* <ParserSize> */\n\t\tcase 0x0E: /* <ServerPollMin> */\n\t\tcase 0x11: /* <TCPAddress> */\n\t\tcase 0x12: /* <TCPPort> */\n\t\tcase 0x13: /* <UDPPort> */\n\t\t\tstr = wv_integer_from_opaque(tvb,\n\t\t\t\t\t\t     offset + *length, data_len);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (str == NULL) { /* Error, or not parsed */\n\t\tstr = wmem_strdup_printf(wmem_packet_scope(), \"(%d bytes of unparsed opaque data)\", data_len);\n\t}\n\t*length += data_len;\n\n\treturn str;\n}\n\nstatic char *\nwv_csp10_opaque_literal_tag(tvbuff_t *tvb, guint32 offset,\n\t\t\t    const char *token, guint8 codepage _U_, guint32 *length)\n{\n\tguint32 data_len = tvb_get_guintvar(tvb, offset, length);\n\tchar *str = NULL;\n\n\tif ( token && ( (strcmp(token, \"Code\") == 0)\n\t\t\t|| (strcmp(token, \"ContentSize\") == 0)\n\t\t\t|| (strcmp(token, \"MessageCount\") == 0)\n\t\t\t|| (strcmp(token, \"Validity\") == 0)\n\t\t\t|| (strcmp(token, \"KeepAliveTime\") == 0)\n\t\t\t|| (strcmp(token, \"TimeToLive\") == 0)\n\t\t\t|| (strcmp(token, \"AcceptedContentLength\") == 0)\n\t\t\t|| (strcmp(token, \"MultiTrans\") == 0)\n\t\t\t|| (strcmp(token, \"ParserSize\") == 0)\n\t\t\t|| (strcmp(token, \"ServerPollMin\") == 0)\n\t\t\t|| (strcmp(token, \"TCPAddress\") == 0)\n\t\t\t|| (strcmp(token, \"TCPPort\") == 0)\n\t\t\t|| (strcmp(token, \"UDPPort\") == 0) ) )\n\t\t{\n\t\t\tstr = wv_integer_from_opaque(tvb, offset + *length, data_len);\n\t\t}\n\telse if ( token && ( strcmp(token, \"DateTime\") == 0) )\n\t\t{\n\t\t\tstr = wv_datetime_from_opaque(tvb, offset + *length, data_len);\n\t\t}\n\n\tif (str == NULL) { /* Error, or not parsed */\n\t\tstr = wmem_strdup_printf(wmem_packet_scope(), \"(%d bytes of unparsed opaque data)\", data_len);\n\t}\n\t*length += data_len;\n\treturn str;\n}\n\nstatic char *\nwv_csp11_opaque_binary_tag(tvbuff_t *tvb, guint32 offset,\n\t\t\t   guint8 token, guint8 codepage, guint32 *length)\n{\n\tguint32 data_len = tvb_get_guintvar(tvb, offset, length);\n\tchar *str = NULL;\n\n\tswitch (codepage) {\n\tcase 0: /* Common code page */\n\t\tswitch (token) {\n\t\tcase 0x0B: /* <Code> */\n\t\tcase 0x0F: /* <ContentSize> */\n\t\tcase 0x1A: /* <MessageCount> */\n\t\tcase 0x3C: /* <Validity> */\n\t\t\tstr = wv_integer_from_opaque(tvb,\n\t\t\t\t\t\t     offset + *length, data_len);\n\t\t\tbreak;\n\t\tcase 0x11: /* <DateTime> */\n\t\t\tstr = wv_datetime_from_opaque(tvb,\n\t\t\t\t\t\t      offset + *length, data_len);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 1: /* Access code page */\n\t\tswitch (token) {\n\t\tcase 0x1C: /* <KeepAliveTime> */\n\t\tcase 0x32: /* <TimeToLive> */\n\t\t\tstr = wv_integer_from_opaque(tvb,\n\t\t\t\t\t\t     offset + *length, data_len);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 3: /* Client capability code page */\n\t\tswitch (token) {\n\t\tcase 0x06: /* <AcceptedContentLength> */\n\t\tcase 0x0C: /* <MultiTrans> */\n\t\tcase 0x0D: /* <ParserSize> */\n\t\tcase 0x0E: /* <ServerPollMin> */\n\t\tcase 0x12: /* <TCPPort> */\n\t\tcase 0x13: /* <UDPPort> */\n\t\t\tstr = wv_integer_from_opaque(tvb,\n\t\t\t\t\t\t     offset + *length, data_len);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 6: /* Messaging code page */\n\t\tswitch (token) {\n\t\tcase 0x1A: /* <DeliveryTime> - not in 1.0 */\n\t\t\tstr = wv_datetime_from_opaque(tvb,\n\t\t\t\t\t\t      offset + *length, data_len);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (str == NULL) { /* Error, or not parsed */\n\t\tstr = wmem_strdup_printf(wmem_packet_scope(), \"(%d bytes of unparsed opaque data)\", data_len);\n\t}\n\t*length += data_len;\n\n\treturn str;\n}\n\nstatic char *\nwv_csp11_opaque_literal_tag(tvbuff_t *tvb, guint32 offset,\n\t\t\t    const char *token, guint8 codepage _U_, guint32 *length)\n{\n\tguint32 data_len = tvb_get_guintvar(tvb, offset, length);\n\tchar *str = NULL;\n\n\tif ( token && ( (strcmp(token, \"Code\") == 0)\n\t\t\t|| (strcmp(token, \"ContentSize\") == 0)\n\t\t\t|| (strcmp(token, \"MessageCount\") == 0)\n\t\t\t|| (strcmp(token, \"Validity\") == 0)\n\t\t\t|| (strcmp(token, \"KeepAliveTime\") == 0)\n\t\t\t|| (strcmp(token, \"TimeToLive\") == 0)\n\t\t\t|| (strcmp(token, \"AcceptedContentLength\") == 0)\n\t\t\t|| (strcmp(token, \"MultiTrans\") == 0)\n\t\t\t|| (strcmp(token, \"ParserSize\") == 0)\n\t\t\t|| (strcmp(token, \"ServerPollMin\") == 0)\n\t\t\t|| (strcmp(token, \"TCPPort\") == 0)\n\t\t\t|| (strcmp(token, \"UDPPort\") == 0) ) )\n\t\t{\n\t\t\tstr = wv_integer_from_opaque(tvb, offset + *length, data_len);\n\t\t}\n\telse\n\t\tif ( token && ( (strcmp(token, \"DateTime\") == 0)\n\t\t\t\t|| (strcmp(token, \"DeliveryTime\") == 0) ) )\n\t\t\t{\n\t\t\t\tstr = wv_datetime_from_opaque(tvb, offset + *length, data_len);\n\t\t\t}\n\n\tif (str == NULL) { /* Error, or not parsed */\n\t\tstr = wmem_strdup_printf(wmem_packet_scope(), \"(%d bytes of unparsed opaque data)\", data_len);\n\t}\n\t*length += data_len;\n\treturn str;\n}\n\n\nstatic char *\nwv_csp12_opaque_binary_tag(tvbuff_t *tvb, guint32 offset,\n\t\t\t   guint8 token, guint8 codepage, guint32 *length)\n{\n\tguint32 data_len = tvb_get_guintvar(tvb, offset, length);\n\tchar *str = NULL;\n\n\tswitch (codepage) {\n\tcase 0: /* Common code page */\n\t\tswitch (token) {\n\t\tcase 0x0B: /* <Code> */\n\t\tcase 0x0F: /* <ContentSize> */\n\t\tcase 0x1A: /* <MessageCount> */\n\t\tcase 0x3C: /* <Validity> */\n\t\t\tstr = wv_integer_from_opaque(tvb,\n\t\t\t\t\t\t     offset + *length, data_len);\n\t\t\tbreak;\n\t\tcase 0x11: /* <DateTime> */\n\t\t\tstr = wv_datetime_from_opaque(tvb,\n\t\t\t\t\t\t      offset + *length, data_len);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 1: /* Access code page */\n\t\tswitch (token) {\n\t\tcase 0x1C: /* <KeepAliveTime> */\n\t\tcase 0x32: /* <TimeToLive> */\n\t\t\tstr = wv_integer_from_opaque(tvb,\n\t\t\t\t\t\t     offset + *length, data_len);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 3: /* Client capability code page */\n\t\tswitch (token) {\n\t\tcase 0x06: /* <AcceptedContentLength> */\n\t\tcase 0x0C: /* <MultiTrans> */\n\t\tcase 0x0D: /* <ParserSize> */\n\t\tcase 0x0E: /* <ServerPollMin> */\n\t\tcase 0x12: /* <TCPPort> */\n\t\tcase 0x13: /* <UDPPort> */\n\t\t\tstr = wv_integer_from_opaque(tvb,\n\t\t\t\t\t\t     offset + *length, data_len);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 6: /* Messaging code page */\n\t\tswitch (token) {\n\t\tcase 0x1A: /* <DeliveryTime> - not in 1.0 */\n\t\t\tstr = wv_datetime_from_opaque(tvb,\n\t\t\t\t\t\t      offset + *length, data_len);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 9: /* Common code page (continued) */\n\t\tswitch (token) {\n\t\tcase 0x08: /* <HistoryPeriod> - 1.2 only */\n\t\tcase 0x0A: /* <MaxWatcherList> - 1.2 only */\n\t\t\tstr = wv_integer_from_opaque(tvb,\n\t\t\t\t\t\t     offset + *length, data_len);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (str == NULL) { /* Error, or not parsed */\n\t\tstr = wmem_strdup_printf(wmem_packet_scope(), \"(%d bytes of unparsed opaque data)\", data_len);\n\t}\n\t*length += data_len;\n\n\treturn str;\n}\n\nstatic char *\nwv_csp12_opaque_literal_tag(tvbuff_t *tvb, guint32 offset,\n\t\t\t    const char *token, guint8 codepage _U_, guint32 *length)\n{\n\tguint32 data_len = tvb_get_guintvar(tvb, offset, length);\n\tchar *str = NULL;\n\n\tif ( token && ( (strcmp(token, \"Code\") == 0)\n\t\t\t|| (strcmp(token, \"ContentSize\") == 0)\n\t\t\t|| (strcmp(token, \"MessageCount\") == 0)\n\t\t\t|| (strcmp(token, \"Validity\") == 0)\n\t\t\t|| (strcmp(token, \"KeepAliveTime\") == 0)\n\t\t\t|| (strcmp(token, \"TimeToLive\") == 0)\n\t\t\t|| (strcmp(token, \"AcceptedContentLength\") == 0)\n\t\t\t|| (strcmp(token, \"MultiTrans\") == 0)\n\t\t\t|| (strcmp(token, \"ParserSize\") == 0)\n\t\t\t|| (strcmp(token, \"ServerPollMin\") == 0)\n\t\t\t|| (strcmp(token, \"TCPPort\") == 0)\n\t\t\t|| (strcmp(token, \"UDPPort\") == 0)\n\t\t\t|| (strcmp(token, \"HistoryPeriod\") == 0)\n\t\t\t|| (strcmp(token, \"MaxWatcherList\") == 0) ) )\n\t\t{\n\t\t\tstr = wv_integer_from_opaque(tvb, offset + *length, data_len);\n\t\t}\n\telse\n\t\tif ( token && ( (strcmp(token, \"DateTime\") == 0)\n\t\t\t\t|| (strcmp(token, \"DeliveryTime\") == 0) ) )\n\t\t\t{\n\t\t\t\tstr = wv_datetime_from_opaque(tvb, offset + *length, data_len);\n\t\t\t}\n\n\tif (str == NULL) { /* Error, or not parsed */\n\t\tstr = wmem_strdup_printf(wmem_packet_scope(), \"(%d bytes of unparsed opaque data)\", data_len);\n\t}\n\t*length += data_len;\n\treturn str;\n}\n\nstatic char *\nwv_csp13_opaque_binary_tag(tvbuff_t *tvb, guint32 offset,\n\t\t\t   guint8 token, guint8 codepage, guint32 *length)\n{\n\tguint32 data_len = tvb_get_guintvar(tvb, offset, length);\n\tchar *str = NULL;\n\n\tswitch (codepage)\n\t\t{\n\t\tcase 0: /* Common code page */\n\t\t\tswitch (token)\n\t\t\t\t{\n\t\t\t\tcase 0x0B: /* <Code> */\n\t\t\t\tcase 0x0F: /* <ContentSize> */\n\t\t\t\tcase 0x1A: /* <MessageCount> */\n\t\t\t\tcase 0x3C: /* <Validity> */\n\t\t\t\t\tstr = wv_integer_from_opaque(tvb, offset + *length, data_len);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x11: /* <DateTime> */\n\t\t\t\t\tstr = wv_datetime_from_opaque(tvb, offset + *length, data_len);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 1: /* Access code page */\n\t\t\tswitch (token)\n\t\t\t\t{\n\t\t\t\tcase 0x1C: /* <KeepAliveTime> */\n\t\t\t\tcase 0x25: /* <SearchFindings> */\n\t\t\t\tcase 0x26: /* <SearchID> */\n\t\t\t\tcase 0x27: /* <SearchIndex> */\n\t\t\t\tcase 0x28: /* <SearchLimit> */\n\t\t\t\tcase 0x32: /* <TimeToLive> */\n\t\t\t\t\tstr = wv_integer_from_opaque(tvb, offset + *length, data_len);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 3: /* Client capability code page */\n\t\t\tswitch (token)\n\t\t\t\t{\n\t\t\t\tcase 0x06: /* <AcceptedContentLength> */\n\t\t\t\tcase 0x0C: /* <MultiTrans> */\n\t\t\t\tcase 0x0D: /* <ParserSize> */\n\t\t\t\tcase 0x0E: /* <ServerPollMin> */\n\t\t\t\tcase 0x12: /* <TCPPort> */\n\t\t\t\tcase 0x13: /* <UDPPort> */\n\t\t\t\t\t/* New in WV-CSP 1.3*/\n\t\t\t\tcase 0x16: /* <AcceptedPullLength> */\n\t\t\t\tcase 0x17: /* <AcceptedPushLength> */\n\t\t\t\tcase 0x18: /* <AcceptedRichContentLength> */\n\t\t\t\tcase 0x19: /* <AcceptedTextContentLength> */\n\t\t\t\tcase 0x1B: /* <PlainTextCharset> MIBenum number - character set, i.e. UTF-8, windows-1251, etc. */\n\t\t\t\tcase 0x1C: /* <SessionPriority> */\n\t\t\t\tcase 0x1F: /* <UserSessionLimit> */\n\t\t\t\tcase 0x21: /* <MultiTransPerMessage> */\n\t\t\t\tcase 0x24: /* <ContentPolicyLimit> */\n\t\t\t\t\tstr = wv_integer_from_opaque(tvb, offset + *length, data_len);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 5: /* Presence attribute code page */\n\t\t\tswitch (token)\n\t\t\t\t{\n\t\t\t\t\t/* New in WV-CSP 1.3*/\n\t\t\t\t\t/*\t\tcase 0x3B: */ /* <ClientContentLimit> */\n\t\t\t\tcase 0x3C: /* <ClientIMPriority> */\n\t\t\t\tcase 0x3D: /* <MaxPullLength> */\n\t\t\t\tcase 0x3E: /* <MaxPushLength> */\n\t\t\t\t\tstr = wv_integer_from_opaque(tvb, offset + *length, data_len);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 6: /* Messaging code page */\n\t\t\tswitch (token)\n\t\t\t\t{\n\t\t\t\tcase 0x1A: /* <DeliveryTime> - not in 1.0 */\n\t\t\t\t\t/* New in WV-CSP 1.3*/\n\t\t\t\tcase 0x1C: /* <AnswerOptionID> */\n\t\t\t\t\tstr = wv_datetime_from_opaque(tvb, offset + *length, data_len);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 9: /* Common code page (continued) */\n\t\t\tswitch (token)\n\t\t\t\t{\n\t\t\t\tcase 0x08: /* <HistoryPeriod> - 1.2 only */\n\t\t\t\tcase 0x0A: /* <MaxWatcherList> - 1.2 only */\n\t\t\t\t\t/* New in WV-CSP 1.3*/\n\t\t\t\tcase 0x25: /* <SegmentCount> */\n\t\t\t\tcase 0x28: /* <SegmentReference> */\n\t\t\t\tcase 0x30: /* <TryAgainTimeout> */\n\t\t\t\tcase 0x3A: /* <GroupContentLimit> */\n\t\t\t\tcase 0x3B: /* <MessageTotalCount> */\n\t\t\t\t\tstr = wv_integer_from_opaque(tvb, offset + *length, data_len);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 10:\n\t\t\tswitch (token)\n\t\t\t\t{\n\t\t\t\t\t/* New in WV-CSP 1.3*/\n\t\t\t\tcase 0x0C: /* <PairID> */\n\t\t\t\t\tstr = wv_integer_from_opaque(tvb, offset + *length, data_len);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\tif (str == NULL)\n\t\t{ /* Error, or not parsed */\n\t\t\tstr = wmem_strdup_printf(wmem_packet_scope(), \"(%d bytes of unparsed opaque data)\", data_len);\n\t\t}\n\t*length += data_len;\n\n\treturn str;\n}\n\n\nstatic char *\nwv_csp13_opaque_literal_tag(tvbuff_t *tvb, guint32 offset,\n\t\t\t    const char *token, guint8 codepage _U_, guint32 *length)\n{\n\tguint32 data_len = tvb_get_guintvar(tvb, offset, length);\n\tchar *str = NULL;\n\n\tif ( token && ( (strcmp(token, \"Code\") == 0)\n\t\t\t|| (strcmp(token, \"ContentSize\") == 0)\n\t\t\t|| (strcmp(token, \"MessageCount\") == 0)\n\t\t\t|| (strcmp(token, \"Validity\") == 0)\n\t\t\t|| (strcmp(token, \"KeepAliveTime\") == 0)\n\t\t\t|| (strcmp(token, \"TimeToLive\") == 0)\n\t\t\t|| (strcmp(token, \"AcceptedContentLength\") == 0)\n\t\t\t|| (strcmp(token, \"MultiTrans\") == 0)\n\t\t\t|| (strcmp(token, \"ParserSize\") == 0)\n\t\t\t|| (strcmp(token, \"ServerPollMin\") == 0)\n\t\t\t|| (strcmp(token, \"TCPPort\") == 0)\n\t\t\t|| (strcmp(token, \"UDPPort\") == 0)\n\t\t\t|| (strcmp(token, \"HistoryPeriod\") == 0)\n\t\t\t|| (strcmp(token, \"MaxWatcherList\") == 0)\n\t\t\t/* New in WV-CSP 1.3*/\n\t\t\t|| (strcmp(token, \"SearchFindings\") == 0)\n\t\t\t|| (strcmp(token, \"SearchID\") == 0)\n\t\t\t|| (strcmp(token, \"SearchIndex\") == 0)\n\t\t\t|| (strcmp(token, \"SearchLimit\") == 0)\n\t\t\t|| (strcmp(token, \"AcceptedPullLength\") == 0)\n\t\t\t|| (strcmp(token, \"AcceptedPushLength\") == 0)\n\t\t\t|| (strcmp(token, \"AcceptedRichContentLength\") == 0)\n\t\t\t|| (strcmp(token, \"AcceptedTextContentLength\") == 0)\n\t\t\t|| (strcmp(token, \"SessionPriority\") == 0)\n\t\t\t|| (strcmp(token, \"UserSessionLimit\") == 0)\n\t\t\t|| (strcmp(token, \"MultiTransPerMessage\") == 0)\n\t\t\t|| (strcmp(token, \"ContentPolicyLimit\") == 0)\n\t\t\t|| (strcmp(token, \"AnswerOptionID\") == 0)\n\t\t\t|| (strcmp(token, \"SegmentCount\") == 0)\n\t\t\t|| (strcmp(token, \"SegmentReference\") == 0)\n\t\t\t|| (strcmp(token, \"TryAgainTimeout\") == 0)\n\t\t\t|| (strcmp(token, \"GroupContentLimit\") == 0)\n\t\t\t|| (strcmp(token, \"MessageTotalCount\") == 0)\n\t\t\t|| (strcmp(token, \"PairID\") == 0) ) )\n\t\t{\n\t\t\tstr = wv_integer_from_opaque(tvb, offset + *length, data_len);\n\t\t}\n\telse\n\t\tif ( token && ( (strcmp(token, \"DateTime\") == 0)\n\t\t\t\t|| (strcmp(token, \"DeliveryTime\") == 0) ) )\n\t\t\t{\n\t\t\t\tstr = wv_datetime_from_opaque(tvb, offset + *length, data_len);\n\t\t\t}\n\n\tif (str == NULL) { /* Error, or not parsed */\n\t\tstr = wmem_strdup_printf(wmem_packet_scope(), \"(%d bytes of unparsed opaque data)\", data_len);\n\t}\n\t*length += data_len;\n\treturn str;\n}\n\nstatic char *\nsic10_opaque_literal_attr(tvbuff_t *tvb, guint32 offset,\n\t\t\t  const char *token, guint8 codepage _U_, guint32 *length)\n{\n\tguint32 data_len = tvb_get_guintvar(tvb, offset, length);\n\tchar *str = NULL;\n\n\tif ( token && ( (strcmp(token, \"created\") == 0)\n\t\t\t|| (strcmp(token, \"si-expires\") == 0) ) )\n\t\t{\n\t\t\tstr = date_time_from_opaque(tvb, offset + *length, data_len);\n\t\t}\n\tif (str == NULL) { /* Error, or not parsed */\n\t\tstr = wmem_strdup_printf(wmem_packet_scope(), \"(%d bytes of unparsed opaque data)\", data_len);\n\t}\n\t*length += data_len;\n\n\treturn str;\n}\n\nstatic char *\nsic10_opaque_binary_attr(tvbuff_t *tvb, guint32 offset,\n\t\t\t guint8 token, guint8 codepage, guint32 *length)\n{\n\tguint32 data_len = tvb_get_guintvar(tvb, offset, length);\n\tchar *str = NULL;\n\n\tswitch (codepage) {\n\tcase 0: /* Only valid codepage for SI */\n\t\tswitch (token) {\n\t\tcase 0x0A: /* created= */\n\t\tcase 0x10: /* si-expires= */\n\t\t\tstr = date_time_from_opaque(tvb,\n\t\t\t\t\t\t    offset + *length, data_len);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (str == NULL) { /* Error, or not parsed */\n\t\tstr = wmem_strdup_printf(wmem_packet_scope(), \"(%d bytes of unparsed opaque data)\", data_len);\n\t}\n\t*length += data_len;\n\n\treturn str;\n}\n\nstatic char *\nemnc10_opaque_literal_attr(tvbuff_t *tvb, guint32 offset,\n\t\t\t   const char *token, guint8 codepage _U_, guint32 *length)\n{\n\tguint32 data_len = tvb_get_guintvar(tvb, offset, length);\n\tchar *str = NULL;\n\n\tif ( token && (strcmp(token, \"timestamp\") == 0) )\n\t\t{\n\t\t\tstr = date_time_from_opaque(tvb, offset + *length, data_len);\n\t\t}\n\tif (str == NULL) { /* Error, or not parsed */\n\t\tstr = wmem_strdup_printf(wmem_packet_scope(), \"(%d bytes of unparsed opaque data)\", data_len);\n\t}\n\t*length += data_len;\n\n\treturn str;\n}\n\nstatic char *\nemnc10_opaque_binary_attr(tvbuff_t *tvb, guint32 offset,\n\t\t\t  guint8 token, guint8 codepage, guint32 *length)\n{\n\tguint32 data_len = tvb_get_guintvar(tvb, offset, length);\n\tchar *str = NULL;\n\n\tswitch (codepage) {\n\tcase 0: /* Only valid codepage for EMN */\n\t\tswitch (token) {\n\t\tcase 0x05: /* timestamp= */\n\t\t\tstr = date_time_from_opaque(tvb,\n\t\t\t\t\t\t    offset + *length, data_len);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (str == NULL) { /* Error, or not parsed */\n\t\tstr = wmem_strdup_printf(wmem_packet_scope(), \"(%d bytes of unparsed opaque data)\", data_len);\n\t}\n\t*length += data_len;\n\n\treturn str;\n}\n\ntypedef struct _wbxml_decoding {\n\tconst char *name;\n\tconst char *abbrev;\n\text_t_func_ptr ext_t[3];\n\topaque_token_func_ptr\topaque_binary_tag;\n\topaque_literal_func_ptr\topaque_literal_tag;\n\topaque_token_func_ptr\topaque_binary_attr;\n\topaque_literal_func_ptr\topaque_literal_attr;\n\tconst value_valuestring *global;\n\tconst value_valuestring *tags;\n\tconst value_valuestring *attrStart;\n\tconst value_valuestring *attrValue;\n} wbxml_decoding;\n\n/* Define a pointer to a discriminator function taking a tvb and the start\n * offset of the WBXML tokens in the body as arguments.\n */\ntypedef const wbxml_decoding * (* discriminator_func_ptr)(tvbuff_t *, guint32);\n\n/* For the decoding lists based on the known WBXML public ID */\ntypedef struct _wbxml_integer_list {\n\tguint32 public_id;\n\tconst wbxml_decoding *map;\n} wbxml_integer_list;\n\n/* For the decoding lists on the literal content type */\ntypedef struct _wbxml_literal_list {\n\tconst char *content_type;\n\tdiscriminator_func_ptr discriminator; /* TODO */\n\tconst wbxml_decoding *map;\n} wbxml_literal_list;\n\n/************************** Variable declarations **************************/\n\n\n/* Initialize the protocol and registered fields */\nstatic int proto_wbxml = -1;\nstatic int hf_wbxml_version = -1;\nstatic int hf_wbxml_public_id_known = -1;\nstatic int hf_wbxml_public_id_literal = -1;\nstatic int hf_wbxml_charset = -1;\n\n/* Initialize the subtree pointers */\nstatic gint ett_wbxml = -1;\nstatic gint ett_wbxml_str_tbl = -1;\nstatic gint ett_wbxml_content = -1;\n\n/* WBXML Preferences */\nstatic gboolean skip_wbxml_token_mapping = FALSE;\nstatic gboolean disable_wbxml_token_parsing = FALSE;\n\n\n/**************** WBXML related declarations and definitions ****************/\n\n\n/* WBXML public ID mappings. For an up-to-date list, see\n * http://www.openmobilealliance.org/tech/omna/ */\nstatic const value_string vals_wbxml_public_ids[] = {\n\t/* 0x00 = literal public identifier */\n\t{ 0x01, \"Unknown or missing Public Identifier\" },\n\t{ 0x02, \"-//WAPFORUM//DTD WML 1.0//EN (WML 1.0)\" },\n\t{ 0x03, \"-//WAPFORUM//DTD WTA 1.0//EN (WTA Event 1.0) - Deprecated\" },\n\t{ 0x04, \"-//WAPFORUM//DTD WML 1.1//EN (WML 1.1)\" },\n\t{ 0x05, \"-//WAPFORUM//DTD SI 1.0//EN (Service Indication 1.0)\" },\n\t{ 0x06, \"-//WAPFORUM//DTD SL 1.0//EN (Service Loading 1.0)\" },\n\t{ 0x07, \"-//WAPFORUM//DTD CO 1.0//EN (Cache Operation 1.0)\" },\n\t{ 0x08, \"-//WAPFORUM//DTD CHANNEL 1.1//EN (Channel 1.1)\" },\n\t{ 0x09, \"-//WAPFORUM//DTD WML 1.2//EN (WML 1.2)\" },\n\t{ 0x0a, \"-//WAPFORUM//DTD WML 1.3//EN (WML 1.3)\" },\n\t{ 0x0b, \"-//WAPFORUM//DTD PROV 1.0//EN (Provisioning 1.0)\" },\n\t{ 0x0c, \"-//WAPFORUM//DTD WTA-WML 1.2//EN (WTA-WML 1.2)\" },\n\t{ 0x0d, \"-//WAPFORUM//DTD EMN 1.0//EN (Email Notification 1.0)\" },\n\t{ 0x0e, \"-//WAPFORUM//DTD DRMREL 1.0//EN (DRMREL 1.0)\" },\n\t{ 0x0f, \"-//WIRELESSVILLAGE//DTD CSP 1.0//EN\"\n\t  \" (Wireless Village Client-Server Protocol DTD v1.0)\" },\n\t{ 0x10, \"-//WIRELESSVILLAGE//DTD CSP 1.1//EN\"\n\t  \" (Wireless Village Client-Server Protocol DTD v1.1)\" },\n\t{ 0x11, \"-//OMA//DTD WV-CSP 1.2//EN (OMA IMPS - CSP protocol DTD v1.2)\" },\n\t{ 0x12, \"-//OMA//DTD IMPS-CSP 1.3//EN (OMA IMPS - CSP protocol DTD v1.3)\" },\n\t{ 0x13, \"-//OMA//DRM 2.1//EN (OMA DRM 2.1)\" },\n\t/* 0x14 -- 0x7F: reserved */\n\n\t/* Registered values - www.syncml.org */\n\t{ 0x0fd1, \"-//SYNCML//DTD SyncML 1.0//EN (SyncML 1.0)\" },\n\t{ 0x0fd3, \"-//SYNCML//DTD SyncML 1.1//EN (SyncML 1.1)\" },\n\n\t/* Registered values - www.wapforum.org/wina/ */\n\t{ 0x1100, \"-//PHONE.COM//DTD ALERT 1.0//EN\" },\n\t{ 0x1101, \"-//PHONE.COM//DTD CACHE-OPERATION 1.0//EN\" },\n\t{ 0x1102, \"-//PHONE.COM//DTD SIGNAL 1.0//EN\" },\n\t{ 0x1103, \"-//PHONE.COM//DTD LIST 1.0//EN\" },\n\t{ 0x1104, \"-//PHONE.COM//DTD LISTCMD 1.0//EN\" },\n\t{ 0x1105, \"-//PHONE.COM//DTD CHANNEL 1.0//EN\" },\n\t{ 0x1106, \"-//PHONE.COM//DTD MMC 1.0//EN\" },\n\t{ 0x1107, \"-//PHONE.COM//DTD BEARER-CHOICE 1.0//EN\" },\n\t{ 0x1108, \"-//PHONE.COM//DTD WML 1.1//EN (WML+ 1.1)\" },\n\t{ 0x1109, \"-//PHONE.COM//DTD CHANNEL 1.1//EN\" },\n\t{ 0x110a, \"-//PHONE.COM//DTD LIST 1.1//EN\" },\n\t{ 0x110b, \"-//PHONE.COM//DTD LISTCMD 1.1//EN\" },\n\t{ 0x110c, \"-//PHONE.COM//DTD MMC 1.1//EN\" },\n\t{ 0x110d, \"-//PHONE.COM//DTD WML 1.3//EN (WML+ 1.3)\" },\n\t{ 0x110e, \"-//PHONE.COM//DTD MMC 2.0//EN\" },\n\t/* 0x110F -- 0x11FF: unassigned */\n\t{ 0x1200, \"-//3GPP2.COM//DTD IOTA 1.0//EN\" },\n\t{ 0x1201, \"-//SYNCML//DTD SyncML 1.2//EN\" },\n  \t{ 0x1202, \"-//SYNCML//DTD MetaInf 1.2//EN\" },\n \t{ 0x1203, \"-//SYNCML//DTD DevInf 1.2//EN\" },\n \t{ 0x1204, \"-//NOKIA//DTD LANDMARKS 1.0//EN\" },\n\n\t{ 0x00, NULL }\n};\nstatic value_string_ext vals_wbxml_public_ids_ext = VALUE_STRING_EXT_INIT(vals_wbxml_public_ids);\n\nstatic const value_string vals_wbxml_versions[] = {\n\t{ 0x00, \"1.0\" },\t/* WAP-104-WBXML */\n\t{ 0x01, \"1.1\" },\t/* WAP-135-WBXML */\n\t{ 0x02, \"1.2\" },\t/* WAP-154-WBXML */\n\t{ 0x03, \"1.3\" },\t/* WAP-192-WBXML */\n\n\t{ 0x00, NULL }\n};\nstatic value_string_ext vals_wbxml_versions_ext = VALUE_STRING_EXT_INIT(vals_wbxml_versions);\n\n/* WBXML 1.0 global tokens: WAP-104-WBXML\n * Same token mapping as in vals_wbxml1x_global_tokens, but:\n *   { 0xC3, \"RESERVED_2\" }\n */\n\n/* WBXML 1.x (x>0) global tokens: WAP-135-WBXML, WAP-154-WBXML, WAP-192-WBXML\n */\nstatic const value_string vals_wbxml1x_global_tokens[] = {\n\t{ 0x00, \"SWITCH_PAGE\" },\n\t{ 0x01, \"END\" },\n\t{ 0x02, \"ENTITY\" },\n\t{ 0x03, \"STR_I\" },\n\t{ 0x04, \"LITERAL\" },\n\n\t{ 0x40, \"EXT_I_0\" },\n\t{ 0x41, \"EXT_I_1\" },\n\t{ 0x42, \"EXT_I_2\" },\n\t{ 0x43, \"PI\" },\n\t{ 0x44, \"LITERAL_C\" },\n\n\t{ 0x80, \"EXT_T_0\" },\n\t{ 0x81, \"EXT_T_1\" },\n\t{ 0x82, \"EXT_T_2\" },\n\t{ 0x83, \"STR_T\" },\n\t{ 0x84, \"LITERAL_A\" },\n\n\t{ 0xC0, \"EXT_0\" },\n\t{ 0xC1, \"EXT_1\" },\n\t{ 0xC2, \"EXT_2\" },\n\t{ 0xC3, \"OPAQUE\" },\n\t{ 0xC4, \"LITERAL_AC\" },\n\n\t{ 0x00, NULL }\n};\nstatic value_string_ext vals_wbxml1x_global_tokens_ext = VALUE_STRING_EXT_INIT(vals_wbxml1x_global_tokens);\n\n\n\n\n\n/********************** WBXML token mapping definition **********************/\n\n/*\n * NOTE: Please make sure the Attribute Start values all contain an equal sign\n *       even in cases where they do not contain the start of an Attribute\n *       Value.\n */\n\n\n/* WML 1.0\n *\n * Wireless Markup Language\n ***************************************/\nstatic char *\next_t_0_wml_10(tvbuff_t *tvb, guint32 value, guint32 str_tbl)\n{\n\tchar *str = wmem_strdup_printf(wmem_packet_scope(), \"Variable substitution - escaped: '%s'\",\n\t\t\t\t    tvb_get_const_stringz(tvb, str_tbl + value, NULL));\n\treturn str;\n}\n\nstatic char *\next_t_1_wml_10(tvbuff_t *tvb, guint32 value, guint32 str_tbl)\n{\n\tchar *str = wmem_strdup_printf(wmem_packet_scope(), \"Variable substitution - unescaped: '%s'\",\n\t\t\t\t    tvb_get_const_stringz(tvb, str_tbl + value, NULL));\n\treturn str;\n}\n\nstatic char *\next_t_2_wml_10(tvbuff_t *tvb, guint32 value, guint32 str_tbl)\n{\n\tchar *str = wmem_strdup_printf(wmem_packet_scope(), \"Variable substitution - no transformation: '%s'\",\n\t\t\t\t    tvb_get_const_stringz(tvb, str_tbl + value, NULL));\n\treturn str;\n}\n/*****   Global extension tokens   *****/\nstatic const value_string wbxml_wmlc10_global_cp0[] = {\n\t{ 0x40, \"Variable substitution - escaped\" },\n\t{ 0x41, \"Variable substitution - unescaped\" },\n\t{ 0x42, \"Variable substitution - no transformation\" },\n\t{ 0x80, \"Variable substitution - escaped\" },\n\t{ 0x81, \"Variable substitution - unescaped\" },\n\t{ 0x82, \"Variable substitution - no transformation\" },\n\t{ 0xC0, \"Reserved\" },\n\t{ 0xC1, \"Reserved\" },\n\t{ 0xC2, \"Reserved\" },\n\n\t{ 0x00, NULL }\n};\n\n/*****         Tag tokens          *****/\nstatic const value_string wbxml_wmlc10_tags_cp0[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t/* 0x05 -- 0x21 */\n\t{ 0x22, \"A\" },\n\t{ 0x23, \"ACCESS\" },\n\t{ 0x24, \"B\" },\n\t{ 0x25, \"BIG\" },\n\t{ 0x26, \"BR\" },\n\t{ 0x27, \"CARD\" },\n\t{ 0x28, \"DO\" },\n\t{ 0x29, \"EM\" },\n\t{ 0x2A, \"FIELDSET\" },\n\t{ 0x2B, \"GO\" },\n\t{ 0x2C, \"HEAD\" },\n\t{ 0x2D, \"I\" },\n\t{ 0x2E, \"IMG\" },\n\t{ 0x2F, \"INPUT\" },\n\t{ 0x30, \"META\" },\n\t{ 0x31, \"NOOP\" },\n\t{ 0x32, \"PREV\" },\n\t{ 0x33, \"ONEVENT\" },\n\t{ 0x34, \"OPTGROUP\" },\n\t{ 0x35, \"OPTION\" },\n\t{ 0x36, \"REFRESH\" },\n\t{ 0x37, \"SELECT\" },\n\t{ 0x38, \"SMALL\" },\n\t{ 0x39, \"STRONG\" },\n\t{ 0x3A, \"TAB\" },\n\t{ 0x3B, \"TEMPLATE\" },\n\t{ 0x3C, \"TIMER\" },\n\t{ 0x3D, \"U\" },\n\t{ 0x3E, \"VAR\" },\n\t{ 0x3F, \"WML\" },\n\n\t{ 0x00, NULL }\n};\n\n/*****    Attribute Start tokens   *****/\nstatic const value_string wbxml_wmlc10_attrStart_cp0[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"ACCEPT-CHARSET=\" },\n\t{ 0x06, \"ALIGN='BOTTOM'\" },\n\t{ 0x07, \"ALIGN='CENTER'\" },\n\t{ 0x08, \"ALIGN='LEFT'\" },\n\t{ 0x09, \"ALIGN='MIDDLE'\" },\n\t{ 0x0A, \"ALIGN='RIGHT'\" },\n\t{ 0x0B, \"ALIGN='TOP'\" },\n\t{ 0x0C, \"ALT=\" },\n\t{ 0x0D, \"CONTENT=\" },\n\t{ 0x0E, \"DEFAULT=\" },\n\t{ 0x0F, \"DOMAIN=\" },\n\t{ 0x10, \"EMPTYOK='FALSE'\" },\n\t{ 0x11, \"EMPTYOK='TRUE'\" },\n\t{ 0x12, \"FORMAT=\" },\n\t{ 0x13, \"HEIGHT=\" },\n\t{ 0x14, \"HSPACE=\" },\n\t{ 0x15, \"IDEFAULT=\" },\n\t{ 0x16, \"IKEY=\" },\n\t{ 0x17, \"KEY=\" },\n\t{ 0x18, \"LABEL=\" },\n\t{ 0x19, \"LOCALSRC=\" },\n\t{ 0x1A, \"MAXLENGTH=\" },\n\t{ 0x1B, \"METHOD='GET'\" },\n\t{ 0x1C, \"METHOD='POST'\" },\n\t{ 0x1D, \"MODE='NOWRAP'\" },\n\t{ 0x1E, \"MODE='WRAP'\" },\n\t{ 0x1F, \"MULTIPLE='FALSE'\" },\n\t{ 0x20, \"MULTIPLE='TRUE'\" },\n\t{ 0x21, \"NAME=\" },\n\t{ 0x22, \"NEWCONTEXT='FALSE'\" },\n\t{ 0x23, \"NEWCONTEXT='TRUE'\" },\n\t{ 0x24, \"ONCLICK=\" },\n\t{ 0x25, \"ONENTERBACKWARD=\" },\n\t{ 0x26, \"ONENTERFORWARD=\" },\n\t{ 0x27, \"ONTIMER=\" },\n\t{ 0x28, \"OPTIONAL='FALSE'\" },\n\t{ 0x29, \"OPTIONAL='TRUE'\" },\n\t{ 0x2A, \"PATH=\" },\n\t{ 0x2B, \"POSTDATA=\" },\n\t{ 0x2C, \"PUBLIC='FALSE'\" },\n\t{ 0x2D, \"PUBLIC='TRUE'\" },\n\t{ 0x2E, \"SCHEME=\" },\n\t{ 0x2F, \"SENDREFERER='FALSE'\" },\n\t{ 0x30, \"SENDREFERER='TRUE'\" },\n\t{ 0x31, \"SIZE=\" },\n\t{ 0x32, \"SRC=\" },\n\t{ 0x33, \"STYLE='LIST'\" },\n\t{ 0x34, \"STYLE='SET'\" },\n\t{ 0x35, \"TABINDEX=\" },\n\t{ 0x36, \"TITLE=\" },\n\t{ 0x37, \"TYPE=\" },\n\t{ 0x38, \"TYPE='ACCEPT'\" },\n\t{ 0x39, \"TYPE='DELETE'\" },\n\t{ 0x3A, \"TYPE='HELP'\" },\n\t{ 0x3B, \"TYPE='PASSWORD'\" },\n\t{ 0x3C, \"TYPE='ONCLICK'\" },\n\t{ 0x3D, \"TYPE='ONENTERBACKWARD'\" },\n\t{ 0x3E, \"TYPE='ONENTERFORWARD'\" },\n\t{ 0x3F, \"TYPE='ONTIMER'\" },\n\t/* 0x40 -- 0x44 GLOBAL */\n\t{ 0x45, \"TYPE='OPTIONS'\" },\n\t{ 0x46, \"TYPE='PREV'\" },\n\t{ 0x47, \"TYPE='RESET'\" },\n\t{ 0x48, \"TYPE='TEXT'\" },\n\t{ 0x49, \"TYPE='vnd.'\" },\n\t{ 0x4A, \"URL=\" },\n\t{ 0x4B, \"URL='http://'\" },\n\t{ 0x4C, \"URL='https://'\" },\n\t{ 0x4D, \"USER-AGENT=\" },\n\t{ 0x4E, \"VALUE=\" },\n\t{ 0x4F, \"VSPACE=\" },\n\t{ 0x50, \"WIDTH=\" },\n\t{ 0x51, \"xml:lang=\" },\n\n\t{ 0x00, NULL }\n};\n\n/*****    Attribute Value tokens   *****/\nstatic const value_string wbxml_wmlc10_attrValue_cp0[] = {\n\t/* 0x80 -- 0x84 GLOBAL */\n\t{ 0x85, \"'.com/'\" },\n\t{ 0x86, \"'.edu/'\" },\n\t{ 0x87, \"'.net/'\" },\n\t{ 0x88, \"'.org/'\" },\n\t{ 0x89, \"'ACCEPT'\" },\n\t{ 0x8A, \"'BOTTOM'\" },\n\t{ 0x8B, \"'CLEAR'\" },\n\t{ 0x8C, \"'DELETE'\" },\n\t{ 0x8D, \"'HELP'\" },\n\t{ 0x8E, \"'http://'\" },\n\t{ 0x8F, \"'http://www.'\" },\n\t{ 0x90, \"'https://'\" },\n\t{ 0x91, \"'https://www.'\" },\n\t{ 0x92, \"'LIST'\" },\n\t{ 0x93, \"'MIDDLE'\" },\n\t{ 0x94, \"'NOWRAP'\" },\n\t{ 0x95, \"'ONCLICK'\" },\n\t{ 0x96, \"'ONENTERBACKWARD'\" },\n\t{ 0x97, \"'ONENTERFORWARD'\" },\n\t{ 0x98, \"'ONTIMER'\" },\n\t{ 0x99, \"'OPTIONS'\" },\n\t{ 0x9A, \"'PASSWORD'\" },\n\t{ 0x9B, \"'RESET'\" },\n\t{ 0x9C, \"'SET'\" },\n\t{ 0x9D, \"'TEXT'\" },\n\t{ 0x9E, \"'TOP'\" },\n\t{ 0x9F, \"'UNKNOWN'\" },\n\t{ 0xA0, \"'WRAP'\" },\n\t{ 0xA1, \"'www.'\" },\n\n\t{ 0x00, NULL }\n};\n\n/***** Token code page aggregation *****/\nstatic const value_valuestring wbxml_wmlc10_global[] = {\n\t{ 0, wbxml_wmlc10_global_cp0 },\n\t{ 0, NULL }\n};\n\nstatic const value_valuestring wbxml_wmlc10_tags[] = {\n\t{ 0, wbxml_wmlc10_tags_cp0 },\n\t{ 0, NULL }\n};\n\nstatic const value_valuestring wbxml_wmlc10_attrStart[] = {\n\t{ 0, wbxml_wmlc10_attrStart_cp0 },\n\t{ 0, NULL }\n};\n\nstatic const value_valuestring wbxml_wmlc10_attrValue[] = {\n\t{ 0, wbxml_wmlc10_attrValue_cp0 },\n\t{ 0, NULL }\n};\n\nstatic const wbxml_decoding decode_wmlc_10 = {\n\t\"Wireless Markup Language 1.0\",\n\t\"WML 1.0\",\n\t{ ext_t_0_wml_10, ext_t_1_wml_10, ext_t_2_wml_10 },\n\tdefault_opaque_binary_tag,\n\tdefault_opaque_literal_tag,\n\tdefault_opaque_binary_attr,\n\tdefault_opaque_literal_attr,\n\twbxml_wmlc10_global,\n\twbxml_wmlc10_tags,\n\twbxml_wmlc10_attrStart,\n\twbxml_wmlc10_attrValue\n};\n\n\n\n\n/* WML 1.1\n *\n * Wireless Markup Language\n ***************************************/\n\n/*****   Global extension tokens   *****/\n/* Same as in WML 1.0 */\n\n/*****         Tag tokens          *****/\nstatic const value_string wbxml_wmlc11_tags_cp0[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t/* 0x05 -- 0x1B */\n\t{ 0x1C, \"a\" },\n\t{ 0x1D, \"td\" },\n\t{ 0x1E, \"tr\" },\n\t{ 0x1F, \"table\" },\n\t{ 0x20, \"p\" },\n\t{ 0x21, \"postfield\" },\n\t{ 0x22, \"anchor\" },\n\t{ 0x23, \"access\" },\n\t{ 0x24, \"b\" },\n\t{ 0x25, \"big\" },\n\t{ 0x26, \"br\" },\n\t{ 0x27, \"card\" },\n\t{ 0x28, \"do\" },\n\t{ 0x29, \"em\" },\n\t{ 0x2A, \"fieldset\" },\n\t{ 0x2B, \"go\" },\n\t{ 0x2C, \"head\" },\n\t{ 0x2D, \"i\" },\n\t{ 0x2E, \"img\" },\n\t{ 0x2F, \"input\" },\n\t{ 0x30, \"meta\" },\n\t{ 0x31, \"noop\" },\n\t{ 0x32, \"prev\" },\n\t{ 0x33, \"onevent\" },\n\t{ 0x34, \"optgroup\" },\n\t{ 0x35, \"option\" },\n\t{ 0x36, \"refresh\" },\n\t{ 0x37, \"select\" },\n\t{ 0x38, \"small\" },\n\t{ 0x39, \"strong\" },\n\t/* 0x3A */\n\t{ 0x3B, \"template\" },\n\t{ 0x3C, \"timer\" },\n\t{ 0x3D, \"u\" },\n\t{ 0x3E, \"setvar\" },\n\t{ 0x3F, \"wml\" },\n\n\t{ 0x00, NULL }\n};\n\n/*****    Attribute Start tokens   *****/\nstatic const value_string wbxml_wmlc11_attrStart_cp0[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"accept-charset=\" },\n\t{ 0x06, \"align='bottom'\" },\n\t{ 0x07, \"align='center'\" },\n\t{ 0x08, \"align='left'\" },\n\t{ 0x09, \"align='middle'\" },\n\t{ 0x0A, \"align='right'\" },\n\t{ 0x0B, \"align='top'\" },\n\t{ 0x0C, \"alt=\" },\n\t{ 0x0D, \"content=\" },\n\t/* 0x0E */\n\t{ 0x0F, \"domain=\" },\n\t{ 0x10, \"emptyok='false'\" },\n\t{ 0x11, \"emptyok='true'\" },\n\t{ 0x12, \"format=\" },\n\t{ 0x13, \"height=\" },\n\t{ 0x14, \"hspace=\" },\n\t{ 0x15, \"ivalue=\" },\n\t{ 0x16, \"iname=\" },\n\t/* 0x17 */\n\t{ 0x18, \"label=\" },\n\t{ 0x19, \"localsrc=\" },\n\t{ 0x1A, \"maxlength=\" },\n\t{ 0x1B, \"method='get'\" },\n\t{ 0x1C, \"method='post'\" },\n\t{ 0x1D, \"mode='nowrap'\" },\n\t{ 0x1E, \"mode='wrap'\" },\n\t{ 0x1F, \"multiple='false'\" },\n\t{ 0x20, \"multiple='true'\" },\n\t{ 0x21, \"name=\" },\n\t{ 0x22, \"newcontext='false'\" },\n\t{ 0x23, \"newcontext='true'\" },\n\t{ 0x24, \"onpick=\" },\n\t{ 0x25, \"onenterbackward=\" },\n\t{ 0x26, \"onenterforward=\" },\n\t{ 0x27, \"ontimer=\" },\n\t{ 0x28, \"optional='false'\" },\n\t{ 0x29, \"optional='true'\" },\n\t{ 0x2A, \"path=\" },\n\t/* 0x2B -- 0x2D */\n\t{ 0x2E, \"scheme=\" },\n\t{ 0x2F, \"sendreferer='false'\" },\n\t{ 0x30, \"sendreferer='true'\" },\n\t{ 0x31, \"size=\" },\n\t{ 0x32, \"src=\" },\n\t{ 0x33, \"ordered='false'\" },\n\t{ 0x34, \"ordered='true'\" },\n\t{ 0x35, \"tabindex=\" },\n\t{ 0x36, \"title=\" },\n\t{ 0x37, \"type=\" },\n\t{ 0x38, \"type='accept'\" },\n\t{ 0x39, \"type='delete'\" },\n\t{ 0x3A, \"type='help'\" },\n\t{ 0x3B, \"type='password'\" },\n\t{ 0x3C, \"type='onpick'\" },\n\t{ 0x3D, \"type='onenterbackward'\" },\n\t{ 0x3E, \"type='onenterforward'\" },\n\t{ 0x3F, \"type='ontimer'\" },\n\t/* 0x40 -- 0x44 GLOBAL */\n\t{ 0x45, \"type='options'\" },\n\t{ 0x46, \"type='prev'\" },\n\t{ 0x47, \"type='reset'\" },\n\t{ 0x48, \"type='text'\" },\n\t{ 0x49, \"type='vnd.'\" },\n\t{ 0x4A, \"href=\" },\n\t{ 0x4B, \"href='http://'\" },\n\t{ 0x4C, \"href='https://'\" },\n\t{ 0x4D, \"value=\" },\n\t{ 0x4E, \"vspace=\" },\n\t{ 0x4F, \"width=\" },\n\t{ 0x50, \"xml:lang=\" },\n\t/* 0x51 */\n\t{ 0x52, \"align=\" },\n\t{ 0x53, \"columns=\" },\n\t{ 0x54, \"class=\" },\n\t{ 0x55, \"id=\" },\n\t{ 0x56, \"forua='false'\" },\n\t{ 0x57, \"forua='true'\" },\n\t{ 0x58, \"src='http://'\" },\n\t{ 0x59, \"src='https://'\" },\n\t{ 0x5A, \"http-equiv=\" },\n\t{ 0x5B, \"http-equiv='Content-Type'\" },\n\t{ 0x5C, \"content='application/vnd.wap.wmlc;charset='\" },\n\t{ 0x5D, \"http-equiv='Expires'\" },\n\n\t{ 0x00, NULL }\n};\n\n/*****    Attribute Value tokens   *****/\nstatic const value_string wbxml_wmlc11_attrValue_cp0[] = {\n\t/* 0x80 -- 0x84 GLOBAL */\n\t{ 0x85, \"'.com/'\" },\n\t{ 0x86, \"'.edu/'\" },\n\t{ 0x87, \"'.net/'\" },\n\t{ 0x88, \"'.org/'\" },\n\t{ 0x89, \"'accept'\" },\n\t{ 0x8A, \"'bottom'\" },\n\t{ 0x8B, \"'clear'\" },\n\t{ 0x8C, \"'delete'\" },\n\t{ 0x8D, \"'help'\" },\n\t{ 0x8E, \"'http://'\" },\n\t{ 0x8F, \"'http://www.'\" },\n\t{ 0x90, \"'https://'\" },\n\t{ 0x91, \"'https://www.'\" },\n\t/* 0x92 */\n\t{ 0x93, \"'middle'\" },\n\t{ 0x94, \"'nowrap'\" },\n\t{ 0x95, \"'onpick'\" },\n\t{ 0x96, \"'onenterbackward'\" },\n\t{ 0x97, \"'onenterforward'\" },\n\t{ 0x98, \"'ontimer'\" },\n\t{ 0x99, \"'options'\" },\n\t{ 0x9A, \"'password'\" },\n\t{ 0x9B, \"'reset'\" },\n\t/* 0x9C */\n\t{ 0x9D, \"'text'\" },\n\t{ 0x9E, \"'top'\" },\n\t{ 0x9F, \"'unknown'\" },\n\t{ 0xA0, \"'wrap'\" },\n\t{ 0xA1, \"'www.'\" },\n\n\t{ 0x00, NULL }\n};\n\n/***** Token code page aggregation *****/\nstatic const value_valuestring wbxml_wmlc11_global[] = {\n\t{ 0, wbxml_wmlc10_global_cp0 }, /* Same as WML 1.0 */\n\t{ 0, NULL }\n};\n\nstatic const value_valuestring wbxml_wmlc11_tags[] = {\n\t{ 0, wbxml_wmlc11_tags_cp0 },\n\t{ 0, NULL }\n};\n\nstatic const value_valuestring wbxml_wmlc11_attrStart[] = {\n\t{ 0, wbxml_wmlc11_attrStart_cp0 },\n\t{ 0, NULL }\n};\n\nstatic const value_valuestring wbxml_wmlc11_attrValue[] = {\n\t{ 0, wbxml_wmlc11_attrValue_cp0 },\n\t{ 0, NULL }\n};\n\nstatic const wbxml_decoding decode_wmlc_11 = {\n\t\"Wireless Markup Language 1.1\",\n\t\"WML 1.1\",\n\t{ ext_t_0_wml_10, ext_t_1_wml_10, ext_t_2_wml_10 },\n\tdefault_opaque_binary_tag,\n\tdefault_opaque_literal_tag,\n\tdefault_opaque_binary_attr,\n\tdefault_opaque_literal_attr,\n\twbxml_wmlc11_global,\n\twbxml_wmlc11_tags,\n\twbxml_wmlc11_attrStart,\n\twbxml_wmlc11_attrValue\n};\n\n\n\n\n\n/* WML 1.2\n *\n * Wireless Markup Language\n ***************************************/\n\n/*****   Global extension tokens   *****/\n/* Same as in WML 1.0 */\n\n/*****         Tag tokens          *****/\nstatic const value_string wbxml_wmlc12_tags_cp0[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t/* 0x05 -- 0x1A */\n\t{ 0x1B, \"pre\" },\n\t{ 0x1C, \"a\" },\n\t{ 0x1D, \"td\" },\n\t{ 0x1E, \"tr\" },\n\t{ 0x1F, \"table\" },\n\t{ 0x20, \"p\" },\n\t{ 0x21, \"postfield\" },\n\t{ 0x22, \"anchor\" },\n\t{ 0x23, \"access\" },\n\t{ 0x24, \"b\" },\n\t{ 0x25, \"big\" },\n\t{ 0x26, \"br\" },\n\t{ 0x27, \"card\" },\n\t{ 0x28, \"do\" },\n\t{ 0x29, \"em\" },\n\t{ 0x2A, \"fieldset\" },\n\t{ 0x2B, \"go\" },\n\t{ 0x2C, \"head\" },\n\t{ 0x2D, \"i\" },\n\t{ 0x2E, \"img\" },\n\t{ 0x2F, \"input\" },\n\t{ 0x30, \"meta\" },\n\t{ 0x31, \"noop\" },\n\t{ 0x32, \"prev\" },\n\t{ 0x33, \"onevent\" },\n\t{ 0x34, \"optgroup\" },\n\t{ 0x35, \"option\" },\n\t{ 0x36, \"refresh\" },\n\t{ 0x37, \"select\" },\n\t{ 0x38, \"small\" },\n\t{ 0x39, \"strong\" },\n\t/* 0x3A */\n\t{ 0x3B, \"template\" },\n\t{ 0x3C, \"timer\" },\n\t{ 0x3D, \"u\" },\n\t{ 0x3E, \"setvar\" },\n\t{ 0x3F, \"wml\" },\n\n\t{ 0x00, NULL }\n};\n\n/*****    Attribute Start tokens   *****/\nstatic const value_string wbxml_wmlc12_attrStart_cp0[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"accept-charset=\" },\n\t{ 0x06, \"align='bottom'\" },\n\t{ 0x07, \"align='center'\" },\n\t{ 0x08, \"align='left'\" },\n\t{ 0x09, \"align='middle'\" },\n\t{ 0x0A, \"align='right'\" },\n\t{ 0x0B, \"align='top'\" },\n\t{ 0x0C, \"alt=\" },\n\t{ 0x0D, \"content=\" },\n\t/* 0x0E */\n\t{ 0x0F, \"domain=\" },\n\t{ 0x10, \"emptyok='false'\" },\n\t{ 0x11, \"emptyok='true'\" },\n\t{ 0x12, \"format=\" },\n\t{ 0x13, \"height=\" },\n\t{ 0x14, \"hspace=\" },\n\t{ 0x15, \"ivalue=\" },\n\t{ 0x16, \"iname=\" },\n\t/* 0x17 */\n\t{ 0x18, \"label=\" },\n\t{ 0x19, \"localsrc=\" },\n\t{ 0x1A, \"maxlength=\" },\n\t{ 0x1B, \"method='get'\" },\n\t{ 0x1C, \"method='post'\" },\n\t{ 0x1D, \"mode='nowrap'\" },\n\t{ 0x1E, \"mode='wrap'\" },\n\t{ 0x1F, \"multiple='false'\" },\n\t{ 0x20, \"multiple='true'\" },\n\t{ 0x21, \"name=\" },\n\t{ 0x22, \"newcontext='false'\" },\n\t{ 0x23, \"newcontext='true'\" },\n\t{ 0x24, \"onpick=\" },\n\t{ 0x25, \"onenterbackward=\" },\n\t{ 0x26, \"onenterforward=\" },\n\t{ 0x27, \"ontimer=\" },\n\t{ 0x28, \"optional='false'\" },\n\t{ 0x29, \"optional='true'\" },\n\t{ 0x2A, \"path=\" },\n\t/* 0x2B -- 0x2D */\n\t{ 0x2E, \"scheme=\" },\n\t{ 0x2F, \"sendreferer='false'\" },\n\t{ 0x30, \"sendreferer='true'\" },\n\t{ 0x31, \"size=\" },\n\t{ 0x32, \"src=\" },\n\t{ 0x33, \"ordered='false'\" },\n\t{ 0x34, \"ordered='true'\" },\n\t{ 0x35, \"tabindex=\" },\n\t{ 0x36, \"title=\" },\n\t{ 0x37, \"type=\" },\n\t{ 0x38, \"type='accept'\" },\n\t{ 0x39, \"type='delete'\" },\n\t{ 0x3A, \"type='help'\" },\n\t{ 0x3B, \"type='password'\" },\n\t{ 0x3C, \"type='onpick'\" },\n\t{ 0x3D, \"type='onenterbackward'\" },\n\t{ 0x3E, \"type='onenterforward'\" },\n\t{ 0x3F, \"type='ontimer'\" },\n\t/* 0x40 -- 0x44 GLOBAL */\n\t{ 0x45, \"type='options'\" },\n\t{ 0x46, \"type='prev'\" },\n\t{ 0x47, \"type='reset'\" },\n\t{ 0x48, \"type='text'\" },\n\t{ 0x49, \"type='vnd.'\" },\n\t{ 0x4A, \"href=\" },\n\t{ 0x4B, \"href='http://'\" },\n\t{ 0x4C, \"href='https://'\" },\n\t{ 0x4D, \"value=\" },\n\t{ 0x4E, \"vspace=\" },\n\t{ 0x4F, \"width=\" },\n\t{ 0x50, \"xml:lang=\" },\n\t/* 0x51 */\n\t{ 0x52, \"align=\" },\n\t{ 0x53, \"columns=\" },\n\t{ 0x54, \"class=\" },\n\t{ 0x55, \"id=\" },\n\t{ 0x56, \"forua='false'\" },\n\t{ 0x57, \"forua='true'\" },\n\t{ 0x58, \"src='http://'\" },\n\t{ 0x59, \"src='https://'\" },\n\t{ 0x5A, \"http-equiv=\" },\n\t{ 0x5B, \"http-equiv='Content-Type'\" },\n\t{ 0x5C, \"content='application/vnd.wap.wmlc;charset='\" },\n\t{ 0x5D, \"http-equiv='Expires'\" },\n\t{ 0x5E, \"accesskey=\" },\n\t{ 0x5F, \"enctype=\" },\n\t{ 0x60, \"enctype='application/x-www-form-urlencoded'\" },\n\t{ 0x61, \"enctype='multipart/form-data'\" },\n\n\t{ 0x00, NULL }\n};\n\n/*****    Attribute Value tokens   *****/\n/* Same as in WML 1.1 */\n\n/***** Token code page aggregation *****/\nstatic const value_valuestring wbxml_wmlc12_global[] = {\n\t{ 0, wbxml_wmlc10_global_cp0 }, /* Same as WML 1.0 */\n\t{ 0, NULL }\n};\n\nstatic const value_valuestring wbxml_wmlc12_tags[] = {\n\t{ 0, wbxml_wmlc12_tags_cp0 },\n\t{ 0, NULL }\n};\n\nstatic const value_valuestring wbxml_wmlc12_attrStart[] = {\n\t{ 0, wbxml_wmlc12_attrStart_cp0 },\n\t{ 0, NULL }\n};\n\nstatic const value_valuestring wbxml_wmlc12_attrValue[] = {\n\t{ 0, wbxml_wmlc11_attrValue_cp0 }, /* Same as WML 1.1 */\n\t{ 0, NULL }\n};\n\nstatic const wbxml_decoding decode_wmlc_12 = {\n\t\"Wireless Markup Language 1.2\",\n\t\"WML 1.2\",\n\t{ ext_t_0_wml_10, ext_t_1_wml_10, ext_t_2_wml_10 },\n\tdefault_opaque_binary_tag,\n\tdefault_opaque_literal_tag,\n\tdefault_opaque_binary_attr,\n\tdefault_opaque_literal_attr,\n\twbxml_wmlc12_global,\n\twbxml_wmlc12_tags,\n\twbxml_wmlc12_attrStart,\n\twbxml_wmlc12_attrValue\n};\n\n\n\n\n\n/* WML 1.3\n *\n * Wireless Markup Language\n ***************************************/\n\n/*****   Global extension tokens   *****/\n/* Same as in WML 1.0 */\n\n/*****         Tag tokens          *****/\n/* Same as in WML 1.2 */\n\n/*****    Attribute Start tokens   *****/\nstatic const value_string wbxml_wmlc13_attrStart_cp0[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"accept-charset=\" },\n\t{ 0x06, \"align='bottom'\" },\n\t{ 0x07, \"align='center'\" },\n\t{ 0x08, \"align='left'\" },\n\t{ 0x09, \"align='middle'\" },\n\t{ 0x0A, \"align='right'\" },\n\t{ 0x0B, \"align='top'\" },\n\t{ 0x0C, \"alt=\" },\n\t{ 0x0D, \"content=\" },\n\t/* 0x0E */\n\t{ 0x0F, \"domain=\" },\n\t{ 0x10, \"emptyok='false'\" },\n\t{ 0x11, \"emptyok='true'\" },\n\t{ 0x12, \"format=\" },\n\t{ 0x13, \"height=\" },\n\t{ 0x14, \"hspace=\" },\n\t{ 0x15, \"ivalue=\" },\n\t{ 0x16, \"iname=\" },\n\t/* 0x17 */\n\t{ 0x18, \"label=\" },\n\t{ 0x19, \"localsrc=\" },\n\t{ 0x1A, \"maxlength=\" },\n\t{ 0x1B, \"method='get'\" },\n\t{ 0x1C, \"method='post'\" },\n\t{ 0x1D, \"mode='nowrap'\" },\n\t{ 0x1E, \"mode='wrap'\" },\n\t{ 0x1F, \"multiple='false'\" },\n\t{ 0x20, \"multiple='true'\" },\n\t{ 0x21, \"name=\" },\n\t{ 0x22, \"newcontext='false'\" },\n\t{ 0x23, \"newcontext='true'\" },\n\t{ 0x24, \"onpick=\" },\n\t{ 0x25, \"onenterbackward=\" },\n\t{ 0x26, \"onenterforward=\" },\n\t{ 0x27, \"ontimer=\" },\n\t{ 0x28, \"optional='false'\" },\n\t{ 0x29, \"optional='true'\" },\n\t{ 0x2A, \"path=\" },\n\t/* 0x2B -- 0x2D */\n\t{ 0x2E, \"scheme=\" },\n\t{ 0x2F, \"sendreferer='false'\" },\n\t{ 0x30, \"sendreferer='true'\" },\n\t{ 0x31, \"size=\" },\n\t{ 0x32, \"src=\" },\n\t{ 0x33, \"ordered='false'\" },\n\t{ 0x34, \"ordered='true'\" },\n\t{ 0x35, \"tabindex=\" },\n\t{ 0x36, \"title=\" },\n\t{ 0x37, \"type=\" },\n\t{ 0x38, \"type='accept'\" },\n\t{ 0x39, \"type='delete'\" },\n\t{ 0x3A, \"type='help'\" },\n\t{ 0x3B, \"type='password'\" },\n\t{ 0x3C, \"type='onpick'\" },\n\t{ 0x3D, \"type='onenterbackward'\" },\n\t{ 0x3E, \"type='onenterforward'\" },\n\t{ 0x3F, \"type='ontimer'\" },\n\t/* 0x40 -- 0x44 GLOBAL */\n\t{ 0x45, \"type='options'\" },\n\t{ 0x46, \"type='prev'\" },\n\t{ 0x47, \"type='reset'\" },\n\t{ 0x48, \"type='text'\" },\n\t{ 0x49, \"type='vnd.'\" },\n\t{ 0x4A, \"href=\" },\n\t{ 0x4B, \"href='http://'\" },\n\t{ 0x4C, \"href='https://'\" },\n\t{ 0x4D, \"value=\" },\n\t{ 0x4E, \"vspace=\" },\n\t{ 0x4F, \"width=\" },\n\t{ 0x50, \"xml:lang=\" },\n\t/* 0x51 */\n\t{ 0x52, \"align=\" },\n\t{ 0x53, \"columns=\" },\n\t{ 0x54, \"class=\" },\n\t{ 0x55, \"id=\" },\n\t{ 0x56, \"forua='false'\" },\n\t{ 0x57, \"forua='true'\" },\n\t{ 0x58, \"src='http://'\" },\n\t{ 0x59, \"src='https://'\" },\n\t{ 0x5A, \"http-equiv=\" },\n\t{ 0x5B, \"http-equiv='Content-Type'\" },\n\t{ 0x5C, \"content='application/vnd.wap.wmlc;charset='\" },\n\t{ 0x5D, \"http-equiv='Expires'\" },\n\t{ 0x5E, \"accesskey=\" },\n\t{ 0x5F, \"enctype=\" },\n\t{ 0x60, \"enctype='application/x-www-form-urlencoded'\" },\n\t{ 0x61, \"enctype='multipart/form-data'\" },\n\t{ 0x62, \"xml:space='preserve'\" },\n\t{ 0x63, \"xml:space='default'\" },\n\t{ 0x64, \"cache-control='no-cache'\" },\n\n\t{ 0x00, NULL }\n};\n\n/*****    Attribute Value tokens   *****/\n/* Same as in WML 1.1 */\n\n/***** Token code page aggregation *****/\nstatic const value_valuestring wbxml_wmlc13_global[] = {\n\t{ 0, wbxml_wmlc10_global_cp0 }, /* Same as WML 1.0 */\n\t{ 0, NULL }\n};\n\nstatic const value_valuestring wbxml_wmlc13_tags[] = {\n\t{ 0, wbxml_wmlc12_tags_cp0 },\n\t{ 0, NULL }\n};\n\nstatic const value_valuestring wbxml_wmlc13_attrStart[] = {\n\t{ 0, wbxml_wmlc13_attrStart_cp0 },\n\t{ 0, NULL }\n};\n\nstatic const value_valuestring wbxml_wmlc13_attrValue[] = {\n\t{ 0, wbxml_wmlc11_attrValue_cp0 }, /* Same as WML 1.1 */\n\t{ 0, NULL }\n};\n\nstatic const wbxml_decoding decode_wmlc_13 = {\n\t\"Wireless Markup Language 1.3\",\n\t\"WML 1.3\",\n\t{ ext_t_0_wml_10, ext_t_1_wml_10, ext_t_2_wml_10 },\n\tdefault_opaque_binary_tag,\n\tdefault_opaque_literal_tag,\n\tdefault_opaque_binary_attr,\n\tdefault_opaque_literal_attr,\n\twbxml_wmlc13_global,\n\twbxml_wmlc13_tags,\n\twbxml_wmlc13_attrStart,\n\twbxml_wmlc13_attrValue\n};\n\n\n\n\n\n/* SI 1.0\n *\n * Service Indication\n ***************************************/\n\n/*****   Global extension tokens   *****/\n\n/*****         Tag tokens          *****/\nstatic const value_string wbxml_sic10_tags_cp0[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"si\" },\n\t{ 0x06, \"indication\" },\n\t{ 0x07, \"info\" },\n\t{ 0x08, \"item\" },\n\n\t{ 0x00, NULL }\n};\n\n/*****    Attribute Start tokens   *****/\nstatic const value_string wbxml_sic10_attrStart_cp0[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"action='signal-none'\" },\n\t{ 0x06, \"action='signal-low'\" },\n\t{ 0x07, \"action='signal-medium'\" },\n\t{ 0x08, \"action='signal-high'\" },\n\t{ 0x09, \"action='delete'\" },\n\t{ 0x0a, \"created=\" },\n\t{ 0x0b, \"href=\" },\n\t{ 0x0c, \"href='http://'\" },\n\t{ 0x0d, \"href='http://www.'\" },\n\t{ 0x0e, \"href='https://'\" },\n\t{ 0x0f, \"href='https://www.'\" },\n\t{ 0x10, \"si-expires=\" },\n\t{ 0x11, \"si-id=\" },\n\t{ 0x12, \"class=\" },\n\n\t{ 0x00, NULL }\n};\n\n/*****    Attribute Value tokens   *****/\nstatic const value_string wbxml_sic10_attrValue_cp0[] = {\n\t/* 0x80 -- 0x84 GLOBAL */\n\t{ 0x85, \"'.com/'\" },\n\t{ 0x86, \"'.edu/'\" },\n\t{ 0x87, \"'.net/'\" },\n\t{ 0x88, \"'.org/'\" },\n\n\t{ 0x00, NULL }\n};\n\n/***** Token code page aggregation *****/\nstatic const value_valuestring wbxml_sic10_tags[] = {\n\t{ 0, wbxml_sic10_tags_cp0 },\n\t{ 0, NULL }\n};\n\nstatic const value_valuestring wbxml_sic10_attrStart[] = {\n\t{ 0, wbxml_sic10_attrStart_cp0 },\n\t{ 0, NULL }\n};\n\nstatic const value_valuestring wbxml_sic10_attrValue[] = {\n\t{ 0, wbxml_sic10_attrValue_cp0 },\n\t{ 0, NULL }\n};\n\nstatic const wbxml_decoding decode_sic_10 = {\n\t\"Service Indication 1.0\",\n\t\"SI 1.0\",\n\t{ NULL, NULL, NULL },\n\tdefault_opaque_binary_tag,\n\tdefault_opaque_literal_tag,\n\tsic10_opaque_binary_attr,\n\tsic10_opaque_literal_attr,\n\tNULL,\n\twbxml_sic10_tags,\n\twbxml_sic10_attrStart,\n\twbxml_sic10_attrValue\n};\n\n\n\n\n\n/* SL 1.0\n *\n * Service Loading\n ***************************************/\n\n/*****   Global extension tokens   *****/\n\n/*****         Tag tokens          *****/\nstatic const value_string wbxml_slc10_tags_cp0[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"sl\" },\n\n\t{ 0x00, NULL }\n};\n\n/*****    Attribute Start tokens   *****/\nstatic const value_string wbxml_slc10_attrStart_cp0[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"action='execute-low'\" },\n\t{ 0x06, \"action='execute-high'\" },\n\t{ 0x07, \"action='cache'\" },\n\t{ 0x08, \"href=\" },\n\t{ 0x09, \"href='http://'\" },\n\t{ 0x0a, \"href='http://www.'\" },\n\t{ 0x0b, \"href='https://'\" },\n\t{ 0x0c, \"href='https://www.'\" },\n\n\t{ 0x00, NULL }\n};\n\n/*****    Attribute Value tokens   *****/\n/* Same as in SI 1.0 */\n\n/***** Token code page aggregation *****/\nstatic const value_valuestring wbxml_slc10_tags[] = {\n\t{ 0, wbxml_slc10_tags_cp0 },\n\t{ 0, NULL }\n};\n\nstatic const value_valuestring wbxml_slc10_attrStart[] = {\n\t{ 0, wbxml_slc10_attrStart_cp0 },\n\t{ 0, NULL }\n};\n\nstatic const value_valuestring wbxml_slc10_attrValue[] = {\n\t{ 0, wbxml_sic10_attrValue_cp0 }, /* Same as SI 1.0 */\n\t{ 0, NULL }\n};\n\nstatic const wbxml_decoding decode_slc_10 = {\n\t\"Service Loading 1.0\",\n\t\"SL 1.0\",\n\t{ NULL, NULL, NULL },\n\tdefault_opaque_binary_tag,\n\tdefault_opaque_literal_tag,\n\tdefault_opaque_binary_attr,\n\tdefault_opaque_literal_attr,\n\tNULL,\n\twbxml_slc10_tags,\n\twbxml_slc10_attrStart,\n\twbxml_slc10_attrValue\n};\n\n\n\n\n\n/* CO 1.0\n *\n * Cache Operation\n ***************************************/\n\n/*****   Global extension tokens   *****/\n\n/*****         Tag tokens          *****/\nstatic const value_string wbxml_coc10_tags_cp0[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"co\" },\n\t{ 0x06, \"invalidate-object\" },\n\t{ 0x07, \"invalidate-service\" },\n\n\t{ 0x00, NULL }\n};\n\n/*****    Attribute Start tokens   *****/\nstatic const value_string wbxml_coc10_attrStart_cp0[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"uri=\" },\n\t{ 0x06, \"uri='http://'\" },\n\t{ 0x07, \"uri='http://www.'\" },\n\t{ 0x08, \"uri='https://'\" },\n\t{ 0x09, \"uri='https://www.'\" },\n\n\t{ 0x00, NULL }\n};\n\n/*****    Attribute Value tokens   *****/\n/* Same as in SI 1.0 */\n\n/***** Token code page aggregation *****/\nstatic const value_valuestring wbxml_coc10_tags[] = {\n\t{ 0, wbxml_coc10_tags_cp0 },\n\t{ 0, NULL }\n};\n\nstatic const value_valuestring wbxml_coc10_attrStart[] = {\n\t{ 0, wbxml_coc10_attrStart_cp0 },\n\t{ 0, NULL }\n};\n\nstatic const value_valuestring wbxml_coc10_attrValue[] = {\n\t{ 0, wbxml_sic10_attrValue_cp0 }, /* Same as SI 1.0 */\n\t{ 0, NULL }\n};\n\nstatic const wbxml_decoding decode_coc_10 = {\n\t\"Cache Operation 1.0\",\n\t\"CO 1.0\",\n\t{ NULL, NULL, NULL },\n\tdefault_opaque_binary_tag,\n\tdefault_opaque_literal_tag,\n\tdefault_opaque_binary_attr,\n\tdefault_opaque_literal_attr,\n\tNULL,\n\twbxml_coc10_tags,\n\twbxml_coc10_attrStart,\n\twbxml_coc10_attrValue\n};\n\n\n\n\n\n/* PROV 1.0\n *\n * Client Provisioning\n ***************************************/\n\n/*****   Global extension tokens   *****/\n\n/*****         Tag tokens          *****/\nstatic const value_string wbxml_provc10_tags_cp0[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"wap-provisioningdoc\" },\n\t{ 0x06, \"characteristic\" },\n\t{ 0x07, \"parm\" },\n\n\t{ 0x00, NULL }\n};\nstatic const value_string wbxml_provc10_tags_cp1[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t/* 0x05 */\n\t{ 0x06, \"characteristic\" },\n\t{ 0x07, \"parm\" },\n\n\t{ 0x00, NULL }\n};\n\n/*****    Attribute Start tokens   *****/\nstatic const value_string wbxml_provc10_attrStart_cp0[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"name=\" },\n\t{ 0x06, \"value=\" },\n\t{ 0x07, \"name='NAME'\" },\n\t{ 0x08, \"name='NAP-ADDRESS'\" },\n\t{ 0x09, \"name='NAP-ADDRTYPE'\" },\n\t{ 0x0A, \"name='CALLTYPE'\" },\n\t{ 0x0B, \"name='VALIDUNTIL'\" },\n\t{ 0x0C, \"name='AUTHTYPE'\" },\n\t{ 0x0D, \"name='AUTHNAME'\" },\n\t{ 0x0E, \"name='AUTHSECRET'\" },\n\t{ 0x0F, \"name='LINGER'\" },\n\t{ 0x10, \"name='BEARER'\" },\n\t{ 0x11, \"name='NAPID'\" },\n\t{ 0x12, \"name='COUNTRY'\" },\n\t{ 0x13, \"name='NETWORK'\" },\n\t{ 0x14, \"name='INTERNET'\" },\n\t{ 0x15, \"name='PROXY-ID'\" },\n\t{ 0x16, \"name='PROXY-PROVIDER-ID'\" },\n\t{ 0x17, \"name='DOMAIN'\" },\n\t{ 0x18, \"name='PROVURL'\" },\n\t{ 0x19, \"name='PXAUTH-TYPE'\" },\n\t{ 0x1A, \"name='PXAUTH-ID'\" },\n\t{ 0x1B, \"name='PXAUTH-PW'\" },\n\t{ 0x1C, \"name='STARTPAGE'\" },\n\t{ 0x1D, \"name='BASAUTH-ID'\" },\n\t{ 0x1E, \"name='BASAUTH-PW'\" },\n\t{ 0x1F, \"name='PUSHENABLED'\" },\n\t{ 0x20, \"name='PXADDR'\" },\n\t{ 0x21, \"name='PXADDRTYPE'\" },\n\t{ 0x22, \"name='TO-NAPID'\" },\n\t{ 0x23, \"name='PORTNBR'\" },\n\t{ 0x24, \"name='SERVICE'\" },\n\t{ 0x25, \"name='LINKSPEED'\" },\n\t{ 0x26, \"name='DNLINKSPEED'\" },\n\t{ 0x27, \"name='LOCAL-ADDR'\" },\n\t{ 0x28, \"name='LOCAL-ADDRTYPE'\" },\n\t{ 0x29, \"name='CONTEXT-ALLOW'\" },\n\t{ 0x2A, \"name='TRUST'\" },\n\t{ 0x2B, \"name='MASTER'\" },\n\t{ 0x2C, \"name='SID'\" },\n\t{ 0x2D, \"name='SOC'\" },\n\t{ 0x2E, \"name='WSP-VERSION'\" },\n\t{ 0x2F, \"name='PHYSICAL-PROXY-ID'\" },\n\t{ 0x30, \"name='CLIENT-ID'\" },\n\t{ 0x31, \"name='DELIVERY-ERR-SDU'\" },\n\t{ 0x32, \"name='DELIVERY-ORDER'\" },\n\t{ 0x33, \"name='TRAFFIC-CLASS'\" },\n\t{ 0x34, \"name='MAX-SDU-SIZE'\" },\n\t{ 0x35, \"name='MAX-BITRATE-UPLINK'\" },\n\t{ 0x36, \"name='MAX-BITRATE-DNLINK'\" },\n\t{ 0x37, \"name='RESIDUAL-BER'\" },\n\t{ 0x38, \"name='SDU-ERROR-RATIO'\" },\n\t{ 0x39, \"name='TRAFFIC-HANDL-PRIO'\" },\n\t{ 0x3A, \"name='TRANSFER-DELAY'\" },\n\t{ 0x3B, \"name='GUARANTEED-BITRATE-UPLINK'\" },\n\t{ 0x3C, \"name='GUARANTEED-BITRATE-DNLINK'\" },\n\t{ 0x3D, \"name='PXADDR-FQDN'\" },\n\t{ 0x3E, \"name='PROXY-PW'\" },\n\t{ 0x3F, \"name='PPGAUTH-TYPE'\" },\n\t/* 0x40 -- 0x44 GLOBAL */\n\t{ 0x45, \"version=\" },\n\t{ 0x46, \"version='1.0'\" },\n\t{ 0x47, \"name='PULLENABLED'\" },\n\t{ 0x48, \"name='DNS-ADDR'\" },\n\t{ 0x49, \"name='MAX-NUM-RETRY'\" },\n\t{ 0x4A, \"name='FIRST-RETRY-TIMEOUT'\" },\n\t{ 0x4B, \"name='REREG-THRESHOLD'\" },\n\t{ 0x4C, \"name='T-BIT'\" },\n\t/* 0x4D */\n\t{ 0x4E, \"name='AUTH-ENTITY'\" },\n\t{ 0x4F, \"name='SPI'\" },\n\t{ 0x50, \"type=\" },\n\t{ 0x51, \"type='PXLOGICAL'\" },\n\t{ 0x52, \"type='PXPHYSICAL'\" },\n\t{ 0x53, \"type='PORT'\" },\n\t{ 0x54, \"type='VALIDITY'\" },\n\t{ 0x55, \"type='NAPDEF'\" },\n\t{ 0x56, \"type='BOOTSTRAP'\" },\n\t{ 0x57, \"type='VENDORCONFIG'\" },\n\t{ 0x58, \"type='CLIENTIDENTITY'\" },\n\t{ 0x59, \"type='PXAUTHINFO'\" },\n\t{ 0x5A, \"type='NAPAUTHINFO'\" },\n\t{ 0x5B, \"type='ACCESS'\" },\n\n\t{ 0x00, NULL }\n};\nstatic const value_string wbxml_provc10_attrStart_cp1[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t/* 0x05 -- 0x06 */\n\t{ 0x07, \"name='NAME'\" },\n\t/* 0x08 -- 0x13 */\n\t{ 0x14, \"name='INTERNET'\" },\n\t/* 0x15 -- 0x1B */\n\t{ 0x1C, \"name='STARTPAGE'\" },\n\t/* 0x1D -- 0x21 */\n\t{ 0x22, \"name='TO-NAPID'\" },\n\t{ 0x23, \"name='PORTNBR'\" },\n\t{ 0x24, \"name='SERVICE'\" },\n\t/* 0x25 -- 0x2D */\n\t{ 0x2E, \"name='AACCEPT'\" },\n\t{ 0x2F, \"name='AAUTHDATA'\" },\n\t{ 0x30, \"name='AAUTHLEVEL'\" },\n\t{ 0x31, \"name='AAUTHNAME'\" },\n\t{ 0x32, \"name='AAUTHSECRET'\" },\n\t{ 0x33, \"name='AAUTHTYPE'\" },\n\t{ 0x34, \"name='ADDR'\" },\n\t{ 0x35, \"name='ADDRTYPE'\" },\n\t{ 0x36, \"name='APPID'\" },\n\t{ 0x37, \"name='APROTOCOL'\" },\n\t{ 0x38, \"name='PROVIDER-ID'\" },\n\t{ 0x39, \"name='TO-PROXY'\" },\n\t{ 0x3A, \"name='URI'\" },\n\t{ 0x3B, \"name='RULE'\" },\n\t/* 0x3C -- 0x3F */\n\t/* 0x40 -- 0x44 GLOBAL */\n\t/* 0x45 -- 0x4F */\n\t{ 0x50, \"type=\" },\n\t/* 0x51 -- 0x52 */\n\t{ 0x53, \"type='PORT'\" },\n\t/* 0x54 */\n\t{ 0x55, \"type='APPLICATION'\" },\n\t{ 0x56, \"type='APPADDR'\" },\n\t{ 0x57, \"type='APPAUTH'\" },\n\t{ 0x58, \"type='CLIENTIDENTITY'\" },\n\t{ 0x59, \"type='RESOURCE'\" },\n\t/* 0x5A -- 0x7F */\n\n\t{ 0x00, NULL }\n};\n\n/*****    Attribute Start tokens   *****/\nstatic const value_string wbxml_provc10_attrValue_cp0[] = {\n\t/* 0x80 -- 0x84 GLOBAL */\n\t{ 0x85, \"'IPV4'\" },\n\t{ 0x86, \"'IPV6'\" },\n\t{ 0x87, \"'E164'\" },\n\t{ 0x88, \"'ALPHA'\" },\n\t{ 0x89, \"'APN'\" },\n\t{ 0x8A, \"'SCODE'\" },\n\t{ 0x8B, \"'TETRA-ITSI'\" },\n\t{ 0x8C, \"'MAN'\" },\n\t/* 0x8D -- 0x8F */\n\t{ 0x90, \"'ANALOG-MODEM'\" },\n\t{ 0x91, \"'V.120'\" },\n\t{ 0x92, \"'V.110'\" },\n\t{ 0x93, \"'X.31'\" },\n\t{ 0x94, \"'BIT-TRANSPARENT'\" },\n\t{ 0x95, \"'DIRECT-ASYNCHRONOUS-DATA-SERVICE'\" },\n\t/* 0x96 -- 0x99 */\n\t{ 0x9A, \"'PAP'\" },\n\t{ 0x9B, \"'CHAP'\" },\n\t{ 0x9C, \"'HTTP-BASIC'\" },\n\t{ 0x9D, \"'HTTP-DIGEST'\" },\n\t{ 0x9E, \"'WTLS-SS'\" },\n\t{ 0x9F, \"'MD5'\" },\n\t/* 0xA0 -- 0xA1 */\n\t{ 0xA2, \"'GSM-USSD'\" },\n\t{ 0xA3, \"'GSM-SMS'\" },\n\t{ 0xA4, \"'ANSI-136-GUTS'\" },\n\t{ 0xA5, \"'IS-95-CDMA-SMS'\" },\n\t{ 0xA6, \"'IS-95-CDMA-CSD'\" },\n\t{ 0xA7, \"'IS-95-CDMA-PACKET'\" },\n\t{ 0xA8, \"'ANSI-136-CSD'\" },\n\t{ 0xA9, \"'ANSI-136-GPRS'\" },\n\t{ 0xAA, \"'GSM-CSD'\" },\n\t{ 0xAB, \"'GSM-GPRS'\" },\n\t{ 0xAC, \"'AMPS-CDPD'\" },\n\t{ 0xAD, \"'PDC-CSD'\" },\n\t{ 0xAE, \"'PDC-PACKET'\" },\n\t{ 0xAF, \"'IDEN-SMS'\" },\n\t{ 0xB0, \"'IDEN-CSD'\" },\n\t{ 0xB1, \"'IDEN-PACKET'\" },\n\t{ 0xB2, \"'FLEX/REFLEX'\" },\n\t{ 0xB3, \"'PHS-SMS'\" },\n\t{ 0xB4, \"'PHS-CSD'\" },\n\t{ 0xB5, \"'TETRA-SDS'\" },\n\t{ 0xB6, \"'TETRA-PACKET'\" },\n\t{ 0xB7, \"'ANSI-136-GHOST'\" },\n\t{ 0xB8, \"'MOBITEX-MPAK'\" },\n\t{ 0xB9, \"'CDMA2000-IX-SIMPLE-IP'\" },\n\t{ 0xBA, \"'CDMA2000-IX-MOBILE-IP'\" },\n\t/* 0xBB -- 0xBF */\n\t/* 0xC0 -- 0xC4 GLOBAL */\n\t{ 0xC5, \"'AUTOBAUDING'\" },\n\t/* 0xC6 -- 0xC9 */\n\t{ 0xCA, \"'CL-WSP'\" },\n\t{ 0xCB, \"'CO-WSP'\" },\n\t{ 0xCC, \"'CL-SEC-WSP'\" },\n\t{ 0xCD, \"'CO-SEC-WSP'\" },\n\t{ 0xCE, \"'CL-SEC-WTA'\" },\n\t{ 0xCF, \"'CO-SEC-WTA'\" },\n\t{ 0xD0, \"'OTA-HTTP-TO'\" },\n\t{ 0xD1, \"'OTA-HTTP-TLS-TO'\" },\n\t{ 0xD2, \"'OTA-HTTP-PO'\" },\n\t{ 0xD3, \"'OTA-HTTP-TLS-PO'\" },\n\t/* 0xD4 -- 0xFF */\n\n\t{ 0x00, NULL }\n};\nstatic const value_string wbxml_provc10_attrValue_cp1[] = {\n\t/* 0x80 -- 0x84 GLOBAL */\n\t/* 0x85 */\n\t{ 0x86, \"'IPV6'\" },\n\t{ 0x87, \"'E164'\" },\n\t{ 0x88, \"'ALPHA'\" },\n\t{ 0x8D, \"'APPSRV'\" },\n\t{ 0x8E, \"'OBEX'\" },\n\t/* 0x8F */\n\n\t/* XXX - Errors that require a fix in the OMA/WAP Client Provisioning specs:\n\t   { 0xXXX, \"','\" },\n\t   { 0xXXX, \"'HTTP-'\" },\n\t   { 0xXXX, \"'BASIC'\" },\n\t   { 0xXXX, \"'DIGEST'\" },\n\t*/\n\n\t{ 0xE0, \"'AAA'\" },\n\t{ 0xE1, \"'HA'\" },\n\n\t{ 0x00, NULL }\n};\n\n/***** Token code page aggregation *****/\nstatic const value_valuestring wbxml_provc10_tags[] = {\n\t{ 0, wbxml_provc10_tags_cp0 },\n\t{ 1, wbxml_provc10_tags_cp1 },\n\t{ 0, NULL }\n};\n\nstatic const value_valuestring wbxml_provc10_attrStart[] = {\n\t{ 0, wbxml_provc10_attrStart_cp0 },\n\t{ 1, wbxml_provc10_attrStart_cp1 },\n\t{ 0, NULL }\n};\n\nstatic const value_valuestring wbxml_provc10_attrValue[] = {\n\t{ 0, wbxml_provc10_attrValue_cp0 },\n\t{ 1, wbxml_provc10_attrValue_cp1 },\n\t{ 0, NULL }\n};\n\nstatic const wbxml_decoding decode_provc_10 = {\n\t\"WAP Client Provisioning Document 1.0\",\n\t\"WAP ProvisioningDoc 1.0\",\n\t{ NULL, NULL, NULL },\n\tdefault_opaque_binary_tag,\n\tdefault_opaque_literal_tag,\n\tdefault_opaque_binary_attr,\n\tdefault_opaque_literal_attr,\n\tNULL,\n\twbxml_provc10_tags,\n\twbxml_provc10_attrStart,\n\twbxml_provc10_attrValue\n};\n\n\n\n\n\n/* EMN 1.0\n *\n * Email Notification\n ***************************************/\n\n/*****   Global extension tokens   *****/\n\n/*****         Tag tokens          *****/\nstatic const value_string wbxml_emnc10_tags_cp0[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"emn\" },\n\n\t{ 0x00, NULL }\n};\n\n/*****    Attribute Start tokens   *****/\nstatic const value_string wbxml_emnc10_attrStart_cp0[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"timestamp=\" },\n\t{ 0x06, \"mailbox=\" },\n\t{ 0x07, \"mailbox='mailat:'\" },\n\t{ 0x08, \"mailbox='pop://'\" },\n\t{ 0x09, \"mailbox='imap://'\" },\n\t{ 0x0a, \"mailbox='http://'\" },\n\t{ 0x0b, \"mailbox='http://www.'\" },\n\t{ 0x0c, \"mailbox='https://'\" },\n\t{ 0x0D, \"mailbox='https://www.'\" },\n\n\t{ 0x00, NULL }\n};\n\n/*****    Attribute Value tokens   *****/\n/* Same as in SI 1.0 */\n\n/***** Token code page aggregation *****/\nstatic const value_valuestring wbxml_emnc10_tags[] = {\n\t{ 0, wbxml_emnc10_tags_cp0 },\n\t{ 0, NULL }\n};\n\nstatic const value_valuestring wbxml_emnc10_attrStart[] = {\n\t{ 0, wbxml_emnc10_attrStart_cp0 },\n\t{ 0, NULL }\n};\n\nstatic const value_valuestring wbxml_emnc10_attrValue[] = {\n\t{ 0, wbxml_sic10_attrValue_cp0 }, /* Same as SI 1.0 */\n\t{ 0, NULL }\n};\n\nstatic const wbxml_decoding decode_emnc_10 = {\n\t\"E-Mail Notification 1.0\",\n\t\"EMN 1.0\",\n\t{ NULL, NULL, NULL },\n\tdefault_opaque_binary_tag,\n\tdefault_opaque_literal_tag,\n\temnc10_opaque_binary_attr,\n\temnc10_opaque_literal_attr,\n\tNULL,\n\twbxml_emnc10_tags,\n\twbxml_emnc10_attrStart,\n\twbxml_emnc10_attrValue\n};\n\n\n\n\n\n/* SyncML 1.0\n *\n * SyncML Representation Protocol\n ***************************************/\n\n/*****   Global extension tokens   *****/\n\n/*****         Tag tokens          *****/\nstatic const value_string wbxml_syncmlc10_tags_cp0[] = { /* SyncML 1.0 */\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"Add\" },\n\t{ 0x06, \"Alert\" },\n\t{ 0x07, \"Archive\" },\n\t{ 0x08, \"Atomic\" },\n\t{ 0x09, \"Chal\" },\n\t{ 0x0A, \"Cmd\" },\n\t{ 0x0B, \"CmdID\" },\n\t{ 0x0C, \"CmdRef\" },\n\t{ 0x0D, \"Copy\" },\n\t{ 0x0E, \"Cred\" },\n\t{ 0x0F, \"Data\" },\n\t{ 0x10, \"Delete\" },\n\t{ 0x11, \"Exec\" },\n\t{ 0x12, \"Final\" },\n\t{ 0x13, \"Get\" },\n\t{ 0x14, \"Item\" },\n\t{ 0x15, \"Lang\" },\n\t{ 0x16, \"LocName\" },\n\t{ 0x17, \"LocURI\" },\n\t{ 0x18, \"Map\" },\n\t{ 0x19, \"MapItem\" },\n\t{ 0x1A, \"Meta\" },\n\t{ 0x1B, \"MsgID\" },\n\t{ 0x1C, \"MsgRef\" },\n\t{ 0x1D, \"NoResp\" },\n\t{ 0x1E, \"NoResults\" },\n\t{ 0x1F, \"Put\" },\n\t{ 0x20, \"Replace\" },\n\t{ 0x21, \"RespURI\" },\n\t{ 0x22, \"Results\" },\n\t{ 0x23, \"Search\" },\n\t{ 0x24, \"Sequence\" },\n\t{ 0x25, \"SessionID\" },\n\t{ 0x26, \"SftDel\" },\n\t{ 0x27, \"Source\" },\n\t{ 0x28, \"SourceRef\" },\n\t{ 0x29, \"Status\" },\n\t{ 0x2A, \"Sync\" },\n\t{ 0x2B, \"SyncBody\" },\n\t{ 0x2C, \"SyncHdr\" },\n\t{ 0x2D, \"SyncML\" },\n\t{ 0x2E, \"Target\" },\n\t{ 0x2F, \"TargetRef\" },\n\t/* 0x30 - Reserved */\n\t{ 0x31, \"VerDTD\" },\n\t{ 0x32, \"VerProto\" },\n\n\t{ 0x00, NULL }\n};\n\nstatic const value_string wbxml_syncmlc10_tags_cp1[] = { /* MetInf 1.0 */\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"Anchor\" },\n\t{ 0x06, \"EMI\" },\n\t{ 0x07, \"Format\" },\n\t{ 0x08, \"FreeID\" },\n\t{ 0x09, \"FreeMem\" },\n\t{ 0x0A, \"Last\" },\n\t{ 0x0B, \"Mark\" },\n\t{ 0x0C, \"MaxMsgSize\" },\n\t{ 0x0D, \"Mem\" },\n\t{ 0x0E, \"MetInf\" },\n\t{ 0x0F, \"Next\" },\n\t{ 0x10, \"NextNonce\" },\n\t{ 0x11, \"SharedMem\" },\n\t{ 0x12, \"Size\" },\n\t{ 0x13, \"Type\" },\n\t{ 0x14, \"Version\" },\n\n\t{ 0x00, NULL }\n};\n\n/*****    Attribute Start tokens   *****/\n\n/*****    Attribute Value tokens   *****/\n\n/***** Token code page aggregation *****/\nstatic const value_valuestring wbxml_syncmlc10_tags[] = {\n\t{ 0, wbxml_syncmlc10_tags_cp0 }, /* -//SYNCML//DTD SyncML 1.0//EN */\n\t{ 1, wbxml_syncmlc10_tags_cp1 }, /* -//SYNCML//DTD MetInf 1.0//EN */\n\t{ 0, NULL }\n};\n\nstatic const wbxml_decoding decode_syncmlc_10 = {\n\t\"SyncML Representation Protocol 1.0\",\n\t\"SyncML 1.0\",\n\t{ NULL, NULL, NULL },\n\tdefault_opaque_binary_tag,\n\tdefault_opaque_literal_tag,\n\tdefault_opaque_binary_attr,\n\tdefault_opaque_literal_attr,\n\tNULL,\n\twbxml_syncmlc10_tags,\n\tNULL,\n\tNULL\n};\n\n\n\n\n\n/* SyncML 1.1\n *\n * SyncML Representation Protocol\n ***************************************/\n\n/*****   Global extension tokens   *****/\n\n/*****         Tag tokens          *****/\nstatic const value_string wbxml_syncmlc11_tags_cp0[] = { /* SyncML 1.1 */\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"Add\" },\n\t{ 0x06, \"Alert\" },\n\t{ 0x07, \"Archive\" },\n\t{ 0x08, \"Atomic\" },\n\t{ 0x09, \"Chal\" },\n\t{ 0x0a, \"Cmd\" },\n\t{ 0x0b, \"CmdID\" },\n\t{ 0x0c, \"CmdRef\" },\n\t{ 0x0d, \"Copy\" },\n\t{ 0x0e, \"Cred\" },\n\t{ 0x0f, \"Data\" },\n\t{ 0x10, \"Delete\" },\n\t{ 0x11, \"Exec\" },\n\t{ 0x12, \"Final\" },\n\t{ 0x13, \"Get\" },\n\t{ 0x14, \"Item\" },\n\t{ 0x15, \"Lang\" },\n\t{ 0x16, \"LocName\" },\n\t{ 0x17, \"LocURI\" },\n\t{ 0x18, \"Map\" },\n\t{ 0x19, \"MapItem\" },\n\t{ 0x1a, \"Meta\" },\n\t{ 0x1b, \"MsgID\" },\n\t{ 0x1c, \"MsgRef\" },\n\t{ 0x1d, \"NoResp\" },\n\t{ 0x1e, \"NoResults\" },\n\t{ 0x1f, \"Put\" },\n\t{ 0x20, \"Replace\" },\n\t{ 0x21, \"RespURI\" },\n\t{ 0x22, \"Results\" },\n\t{ 0x23, \"Search\" },\n\t{ 0x24, \"Sequence\" },\n\t{ 0x25, \"SessionID\" },\n\t{ 0x26, \"SftDel\" },\n\t{ 0x27, \"Source\" },\n\t{ 0x28, \"SourceRef\" },\n\t{ 0x29, \"Status\" },\n\t{ 0x2a, \"Sync\" },\n\t{ 0x2b, \"SyncBody\" },\n\t{ 0x2c, \"SyncHdr\" },\n\t{ 0x2d, \"SyncML\" },\n\t{ 0x2e, \"Target\" },\n\t{ 0x2f, \"TargetRef\" },\n\t/* 0x30 - Reserved */\n\t{ 0x31, \"VerDTD\" },\n\t{ 0x32, \"VerProto\" },\n\t{ 0x33, \"NumberOfChanges\" },\n\t{ 0x34, \"MoreData\" },\n\n\t{ 0x00, NULL }\n};\n\nstatic const value_string wbxml_syncmlc11_tags_cp1[] = { /* MetInf 1.1 */\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"Anchor\" },\n\t{ 0x06, \"EMI\" },\n\t{ 0x07, \"Format\" },\n\t{ 0x08, \"FreeID\" },\n\t{ 0x09, \"FreeMem\" },\n\t{ 0x0A, \"Last\" },\n\t{ 0x0B, \"Mark\" },\n\t{ 0x0C, \"MaxMsgSize\" },\n\t{ 0x0D, \"Mem\" },\n\t{ 0x0E, \"MetInf\" },\n\t{ 0x0F, \"Next\" },\n\t{ 0x10, \"NextNonce\" },\n\t{ 0x11, \"SharedMem\" },\n\t{ 0x12, \"Size\" },\n\t{ 0x13, \"Type\" },\n\t{ 0x14, \"Version\" },\n\t{ 0x15, \"MaxObjSize\" },\n\n\t{ 0x00, NULL }\n};\n\n/*****    Attribute Start tokens   *****/\n\n/*****    Attribute Value tokens   *****/\n\n/***** Token code page aggregation *****/\nstatic const value_valuestring wbxml_syncmlc11_tags[] = {\n\t{ 0, wbxml_syncmlc11_tags_cp0 }, /* -//SYNCML//DTD SyncML 1.1//EN */\n\t{ 1, wbxml_syncmlc11_tags_cp1 }, /* -//SYNCML//DTD MetInf 1.1//EN */\n\t{ 0, NULL }\n};\n\nstatic const wbxml_decoding decode_syncmlc_11 = {\n\t\"SyncML Representation Protocol 1.1\",\n\t\"SyncML 1.1\",\n\t{ NULL, NULL, NULL },\n\tdefault_opaque_binary_tag,\n\tdefault_opaque_literal_tag,\n\tdefault_opaque_binary_attr,\n\tdefault_opaque_literal_attr,\n\tNULL,\n\twbxml_syncmlc11_tags,\n\tNULL,\n\tNULL\n};\n\n\n\n\n\n/* SyncML 1.2\n *\n * SyncML Representation Protocol\n ***************************************/\n\n/*****   Global extension tokens   *****/\n\n/*****         Tag tokens          *****/\nstatic const value_string wbxml_syncmlc12_tags_cp0[] = { /* SyncML 1.2 */\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"Add\" },\n\t{ 0x06, \"Alert\" },\n\t{ 0x07, \"Archive\" },\n\t{ 0x08, \"Atomic\" },\n\t{ 0x09, \"Chal\" },\n\t{ 0x0a, \"Cmd\" },\n\t{ 0x0b, \"CmdID\" },\n\t{ 0x0c, \"CmdRef\" },\n\t{ 0x0d, \"Copy\" },\n\t{ 0x0e, \"Cred\" },\n\t{ 0x0f, \"Data\" },\n\t{ 0x10, \"Delete\" },\n\t{ 0x11, \"Exec\" },\n\t{ 0x12, \"Final\" },\n\t{ 0x13, \"Get\" },\n\t{ 0x14, \"Item\" },\n\t{ 0x15, \"Lang\" },\n\t{ 0x16, \"LocName\" },\n\t{ 0x17, \"LocURI\" },\n\t{ 0x18, \"Map\" },\n\t{ 0x19, \"MapItem\" },\n\t{ 0x1a, \"Meta\" },\n\t{ 0x1b, \"MsgID\" },\n\t{ 0x1c, \"MsgRef\" },\n\t{ 0x1d, \"NoResp\" },\n\t{ 0x1e, \"NoResults\" },\n\t{ 0x1f, \"Put\" },\n\t{ 0x20, \"Replace\" },\n\t{ 0x21, \"RespURI\" },\n\t{ 0x22, \"Results\" },\n\t{ 0x23, \"Search\" },\n\t{ 0x24, \"Sequence\" },\n\t{ 0x25, \"SessionID\" },\n\t{ 0x26, \"SftDel\" },\n\t{ 0x27, \"Source\" },\n\t{ 0x28, \"SourceRef\" },\n\t{ 0x29, \"Status\" },\n\t{ 0x2a, \"Sync\" },\n\t{ 0x2b, \"SyncBody\" },\n\t{ 0x2c, \"SyncHdr\" },\n\t{ 0x2d, \"SyncML\" },\n\t{ 0x2e, \"Target\" },\n\t{ 0x2f, \"TargetRef\" },\n\t/* 0x30 - Reserved */\n\t{ 0x31, \"VerDTD\" },\n\t{ 0x32, \"VerProto\" },\n\t{ 0x33, \"NumberOfChanges\" },\n\t{ 0x34, \"MoreData\" },\n\t{ 0x35, \"Field\" },\n\t{ 0x36, \"Filter\" },\n\t{ 0x37, \"Record\" },\n\t{ 0x38, \"FilterType\" },\n\t{ 0x39, \"SourceParent\" },\n\t{ 0x3a, \"TargetParent\" },\n\t{ 0x3b, \"Move\" },\n\t{ 0x3c, \"Correlator\" },\n\n\t{ 0x00, NULL }\n};\n\nstatic const value_string wbxml_syncmlc12_tags_cp1[] = { /* MetInf 1.2 */\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"Anchor\" },\n\t{ 0x06, \"EMI\" },\n\t{ 0x07, \"Format\" },\n\t{ 0x08, \"FreeID\" },\n\t{ 0x09, \"FreeMem\" },\n\t{ 0x0A, \"Last\" },\n\t{ 0x0B, \"Mark\" },\n\t{ 0x0C, \"MaxMsgSize\" },\n\t{ 0x0D, \"Mem\" },\n\t{ 0x0E, \"MetInf\" },\n\t{ 0x0F, \"Next\" },\n\t{ 0x10, \"NextNonce\" },\n\t{ 0x11, \"SharedMem\" },\n\t{ 0x12, \"Size\" },\n\t{ 0x13, \"Type\" },\n\t{ 0x14, \"Version\" },\n\t{ 0x15, \"MaxObjSize\" },\n\t{ 0x16, \"FieldLevel\" },\n\t{ 0x17, \"FP\" }, /* Extensions on certain devices */\n\t{ 0x18, \"ID\" }, /* Extensions on certain devices */\n\t{ 0x19, \"IDContainer\" }, /* Extensions on certain devices */\n\t{ 0x1a, \"IDPair\" }, /* Extensions on certain devices */\n\n\t{ 0x00, NULL }\n};\n\n/*****    Attribute Start tokens   *****/\n\n/*****    Attribute Value tokens   *****/\n\n/***** Token code page aggregation *****/\nstatic const value_valuestring wbxml_syncmlc12_tags[] = {\n\t{ 0, wbxml_syncmlc12_tags_cp0 }, /* -//SYNCML//DTD SyncML 1.2//EN */\n\t{ 1, wbxml_syncmlc12_tags_cp1 }, /* -//SYNCML//DTD MetInf 1.2//EN */\n\t/* Note: 02 reserved for DM use */\n\t{ 0, NULL }\n};\n\nstatic const wbxml_decoding decode_syncmlc_12 = {\n\t\"SyncML Representation Protocol 1.2\",\n\t\"SyncML 1.2\",\n\t{ NULL, NULL, NULL },\n\tdefault_opaque_binary_tag,\n\tdefault_opaque_literal_tag,\n\tdefault_opaque_binary_attr,\n\tdefault_opaque_literal_attr,\n\tNULL,\n\twbxml_syncmlc12_tags,\n\tNULL,\n\tNULL\n};\n/* Microsoft ActiveSync 1.0 (Actual Version Unknown - either 1.0 or 2.0, taken from [MS-ASWBXML].pdf)\n *\n * ActiveSync Representation Protocol\n ***************************************/\n\n/*****   Global extension tokens   *****/\n\n/*****         Tag tokens          *****/\nstatic const value_string wbxml_mssyncc10_tags_cp0[] = { /* ActiveSync 'AirSync:' Page */\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"Sync\" },\n\t{ 0x06, \"Responses\" },\n\t{ 0x07, \"Add\" },\n\t{ 0x08, \"Change\" },\n\t{ 0x09, \"Delete\" },\n\t{ 0x0A, \"Fetch\" },\n\t{ 0x0B, \"SyncKey\" },\n\t{ 0x0C, \"ClientId\" },\n\t{ 0x0D, \"ServerId\" },\n\t{ 0x0E, \"Status\" },\n\t{ 0x0F, \"Collection\" },\n\t{ 0x10, \"Class\" },\n\t{ 0x12, \"CollectionId\" },\n\t{ 0x13, \"GetChanges\" },\n\t{ 0x14, \"MoreAvailable\" },\n\t{ 0x15, \"WindowSize\" },\n\t{ 0x16, \"Commands\" },\n\t{ 0x17, \"Options\" },\n\t{ 0x18, \"FilterType\" },\n\t{ 0x1B, \"Conflict\" },\n\t{ 0x1C, \"Collections\" },\n\t{ 0x1D, \"ApplicationData\" },\n\t{ 0x1E, \"DeletesAsMoves\" },\n\t{ 0x20, \"Supported\" },\n\t{ 0x21, \"SoftDelete\" },\n\t{ 0x22, \"MIMESupport\" },\n\t{ 0x23, \"MIMETruncation\" },\n\t{ 0x24, \"Wait\" },\n\t{ 0x25, \"Limit\" },\n\t{ 0x26, \"Partial\" },\n\t{ 0x27, \"ConversationMode\" },\n\t{ 0x28, \"MaxItems\" },\n\t{ 0x29, \"HeartbeatInterval\" },\n\n\t{ 0x00, NULL }\n};\n\nstatic const value_string wbxml_mssyncc10_tags_cp1[] = { /* ActiveSync 'Contacts:' Page */\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"Anniversary\" },\n\t{ 0x06, \"AssistantName\" },\n\t{ 0x07, \"AssistantTelephoneNumber\" },\n\t{ 0x08, \"Birthday\" },\n\t{ 0x0C, \"Business2PhoneNumber\" },\n\t{ 0x0D, \"BusinessCity\" },\n\t{ 0x0E, \"BusinessCountry\" },\n\t{ 0x0F, \"BusinessPostalCode\" },\n\t{ 0x10, \"BusinessState\" },\n\t{ 0x11, \"BusinessStreet\" },\n\t{ 0x12, \"BusinessFaxNumber\" },\n\t{ 0x13, \"BusinessPhoneNumber\" },\n\t{ 0x14, \"CarPhoneNumber\" },\n\t{ 0x15, \"Categories\" },\n\t{ 0x16, \"Category\" },\n\t{ 0x17, \"Children\" },\n\t{ 0x18, \"Child\" },\n\t{ 0x19, \"CompanyName\" },\n\t{ 0x1A, \"Department\" },\n\t{ 0x1B, \"Email1Address\" },\n\t{ 0x1C, \"Email2Address\" },\n\t{ 0x1D, \"Email3Address\" },\n\t{ 0x1E, \"FileAs\" },\n\t{ 0x1F, \"FirstName\" },\n\t{ 0x20, \"Home2PhoneNumber\" },\n\t{ 0x21, \"HomeCity\" },\n\t{ 0x22, \"HomeCountry\" },\n\t{ 0x23, \"HomePostalCode\" },\n\t{ 0x24, \"HomeState\" },\n\t{ 0x25, \"HomeStreet\" },\n\t{ 0x26, \"HomeFaxNumber\" },\n\t{ 0x27, \"HomePhoneNumber\" },\n\t{ 0x29, \"JobTitle\" },\n\t{ 0x2A, \"MiddleName\" },\n\t{ 0x2B, \"MobilePhoneNumber\" },\n\t{ 0x2C, \"OfficeLocation\" },\n\t{ 0x2D, \"OtherCity\" },\n\t{ 0x2E, \"OtherCountry\" },\n\t{ 0x2F, \"OtherPostalCode\" },\n\t{ 0x30, \"OtherState\" },\n\t{ 0x31, \"OtherStreet\" },\n\t{ 0x32, \"PagerNumber\" },\n\t{ 0x33, \"RadioPhoneNumber\" },\n\t{ 0x34, \"Spouse\" },\n\t{ 0x35, \"Suffix\" },\n\t{ 0x36, \"Title\" },\n\t{ 0x37, \"Webpage\" },\n\t{ 0x38, \"YomiCompanyName\" },\n\t{ 0x39, \"YomiFirstName\" },\n\t{ 0x3A, \"YomiLastName\" },\n\t{ 0x3C, \"Picture\" },\n\t{ 0x3D, \"Alias\" },\n\t{ 0x3E, \"WeightedRank\" },\n\n\t{ 0x00, NULL }\n};\n\nstatic const value_string wbxml_mssyncc10_tags_cp2[] = { /* ActiveSync 'Email:' Page */\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x0F, \"DateReceived\" },\n\t{ 0x11, \"DisplayTo\" },\n\t{ 0x12, \"Importance\" },\n\t{ 0x13, \"MessageClass\" },\n\t{ 0x14, \"Subject\" },\n\t{ 0x15, \"Read\" },\n\t{ 0x16, \"To\" },\n\t{ 0x17, \"CC\" },\n\t{ 0x18, \"From\" },\n\t{ 0x19, \"ReplyTo\" },\n\t{ 0x1A, \"AllDayEvent\" },\n\t{ 0x1B, \"Categories\" },\n\t{ 0x1C, \"Category\" },\n\t{ 0x1D, \"DTStamp\" },\n\t{ 0x1E, \"EndTime\" },\n\t{ 0x1F, \"InstanceType\" },\n\t{ 0x20, \"BusyStatus\" },\n\t{ 0x21, \"Location\" },\n\t{ 0x22, \"MeetingRequest\" },\n\t{ 0x23, \"Organizer\" },\n\t{ 0x24, \"RecurrenceId\" },\n\t{ 0x25, \"Reminder\" },\n\t{ 0x26, \"ResponseRequest\" },\n\t{ 0x27, \"Recurrences\" },\n\t{ 0x28, \"Recurrence\" },\n\t{ 0x29, \"Recurrence_Type\" },\n\t{ 0x2A, \"Recurrence_Until\" },\n\t{ 0x2B, \"Recurrence_Occurrences\" },\n\t{ 0x2C, \"Recurrence_Interval\" },\n\t{ 0x2D, \"Recurrence_DayOfWeek\" },\n\t{ 0x2E, \"Recurrence_DayOfMonth\" },\n\t{ 0x2F, \"Recurrence_WeekOfMonth\" },\n\t{ 0x30, \"Recurrence_MonthOfYear\" },\n\t{ 0x31, \"StartTime\" },\n\t{ 0x32, \"Sensitivity\" },\n\t{ 0x33, \"TimeZone\" },\n\t{ 0x34, \"GlobalObjId\" },\n\t{ 0x35, \"ThreadTopic\" },\n\t{ 0x39, \"InternetCPID\" },\n\t{ 0x3A, \"Flag\" },\n\t{ 0x3B, \"FlagStatus\" },\n\t{ 0x3C, \"ContentClass\" },\n\t{ 0x3D, \"FlagType\" },\n\t{ 0x3E, \"CompleteTime\" },\n\t{ 0x3F, \"DisallowNewTimeProposal\" },\n\n\t{ 0x00, NULL }\n};\n\nstatic const value_string wbxml_mssyncc10_tags_cp4[] = { /* ActiveSync 'Calendar:' Page */\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"TimeZone\" },\n\t{ 0x06, \"AllDAyEvent\" },\n\t{ 0x07, \"Attendees\" },\n\t{ 0x08, \"Attendee\" },\n\t{ 0x09, \"Attendee_Email\" },\n\t{ 0x0A, \"Attendee_Name\" },\n\t{ 0x0D, \"BusyStatus\" },\n\t{ 0x0E, \"Categories\" },\n\t{ 0x0F, \"Category\" },\n\t{ 0x11, \"DTStamp\" },\n\t{ 0x12, \"EndTime\" },\n\t{ 0x13, \"Exception\" },\n\t{ 0x14, \"Exceptions\" },\n\t{ 0x15, \"Exception_Deleted\" },\n\t{ 0x16, \"Exception_StartTime\" },\n\t{ 0x17, \"Location\" },\n\t{ 0x18, \"MeetingStatus\" },\n\t{ 0x19, \"Organizer_Email\" },\n\t{ 0x1A, \"Organizer_Name\" },\n\t{ 0x1B, \"Recurrence\" },\n\t{ 0x1C, \"Recurrence_Type\" },\n\t{ 0x1D, \"Recurrence_Until\" },\n\t{ 0x1E, \"Recurrence_Occurrences\" },\n\t{ 0x1F, \"Recurrence_Interval\" },\n\t{ 0x20, \"Recurrence_DayOfWeek\" },\n\t{ 0x21, \"Recurrence_DayOfMonth\" },\n\t{ 0x22, \"Recurrence_WeekOfMonth\" },\n\t{ 0x23, \"Recurrence_MonthOfYear\" },\n\t{ 0x24, \"Reminder\" },\n\t{ 0x25, \"Sensitivity\" },\n\t{ 0x26, \"Subject\" },\n\t{ 0x27, \"StartTime\" },\n\t{ 0x28, \"UID\" },\n\t{ 0x29, \"Attendee_Status\" },\n\t{ 0x2A, \"Attendee_Type\" },\n\t{ 0x33, \"DisallowNewTimeProposal\" },\n\t{ 0x34, \"ResponseRequested\" },\n\t{ 0x35, \"AppointmentReplyTime\" },\n\t{ 0x36, \"ResponseType\" },\n\t{ 0x37, \"CalendarType\" },\n\t{ 0x38, \"IsLeapMonth\" },\n\t{ 0x39, \"FirstDayOfWeek\" },\n\t{ 0x3A, \"OnlineMeetingConfLink\" },\n\t{ 0x3B, \"OnlineMeetingExternalLink\" },\n\n\t{ 0x00, NULL }\n};\n\nstatic const value_string wbxml_mssyncc10_tags_cp5[] = { /* ActiveSync 'Move:' Page */\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"MoveItems\" },\n\t{ 0x06, \"Move\" },\n\t{ 0x07, \"SrcMsgId\" },\n\t{ 0x08, \"SrcFldId\" },\n\t{ 0x09, \"DstFldId\" },\n\t{ 0x0A, \"Response\" },\n\t{ 0x0B, \"Status\" },\n\t{ 0x0C, \"DstMsgId\" },\n\n\t{ 0x00, NULL }\n};\n\nstatic const value_string wbxml_mssyncc10_tags_cp6[] = { /* ActiveSync 'GetItemEstimate:' Page */\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"GetItemEstimate\" },\n\t{ 0x06, \"Version\" },\n\t{ 0x07, \"Collections\" },\n\t{ 0x08, \"Collection\" },\n\t{ 0x09, \"Class\" },\n\t{ 0x0A, \"CollectionId\" },\n\t{ 0x0B, \"DateTime\" },\n\t{ 0x0C, \"Estimate\" },\n\t{ 0x0D, \"Response\" },\n\t{ 0x0E, \"Status\" },\n\n\t{ 0x00, NULL }\n};\n\nstatic const value_string wbxml_mssyncc10_tags_cp7[] = { /* ActiveSync 'FolderHierarchy:' Page */\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x07, \"DisplayName\" },\n\t{ 0x08, \"ServerId\" },\n\t{ 0x09, \"ParentId\" },\n\t{ 0x0A, \"Type\" },\n\t{ 0x0C, \"Status\" },\n\t{ 0x0E, \"Changes\" },\n\t{ 0x0F, \"Add\" },\n\t{ 0x10, \"Delete\" },\n\t{ 0x11, \"Update\" },\n\t{ 0x12, \"SyncKey\" },\n\t{ 0x13, \"FolderCreate\" },\n\t{ 0x14, \"FolderDelete\" },\n\t{ 0x15, \"FolderUpdate\" },\n\t{ 0x16, \"FolderSync\" },\n\t{ 0x17, \"Count\" },\n\n\t{ 0x00, NULL }\n};\n\nstatic const value_string wbxml_mssyncc10_tags_cp8[] = { /* ActiveSync 'MeetingResponse:' Page */\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"CalendarId\" },\n\t{ 0x06, \"CollectionId\" },\n\t{ 0x07, \"MeetingResponse\" },\n\t{ 0x08, \"RequestId\" },\n\t{ 0x09, \"Request\" },\n\t{ 0x0A, \"Result\" },\n\t{ 0x0B, \"Status\" },\n\t{ 0x0C, \"UserResponse\" },\n\t{ 0x0E, \"InstanceId\" },\n\n\t{ 0x00, NULL }\n};\n\nstatic const value_string wbxml_mssyncc10_tags_cp9[] = { /* ActiveSync 'Tasks:' Page */\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x08, \"Categories\" },\n\t{ 0x09, \"Category\" },\n\t{ 0x0A, \"Complete\" },\n\t{ 0x0B, \"DateCompleted\" },\n\t{ 0x0D, \"DueDate\" },\n\t{ 0x0E, \"Importance\" },\n\t{ 0x0F, \"Recurrence\" },\n\t{ 0x10, \"Recurrence_Type\" },\n\t{ 0x11, \"Recurrence_Start\" },\n\t{ 0x12, \"Recurrence_Until\" },\n\t{ 0x13, \"Recurrence_Occurrences\" },\n\t{ 0x14, \"Recurrence_Interval\" },\n\t{ 0x15, \"Recurrence_DayOfMonth\" },\n\t{ 0x16, \"Recurrence_DayOfWeek\" },\n\t{ 0x17, \"Recurrence_WeekOfMonth\" },\n\t{ 0x18, \"Recurrence_MonthOfYear\" },\n\t{ 0x19, \"Recurrence_Regenerate\" },\n\t{ 0x1A, \"Recurrence_DeadOccur\" },\n\t{ 0x1B, \"ReminderSet\" },\n\t{ 0x1C, \"ReminderTime\" },\n\t{ 0x1D, \"Sensitivity\" },\n\t{ 0x1E, \"StartDate\" },\n\t{ 0x1F, \"UTCStartDate\" },\n\t{ 0x20, \"Subject\" },\n\t{ 0x22, \"OrdinalDate\" },\n\t{ 0x23, \"SubOrdinalDate\" },\n\t{ 0x24, \"CalendarType\" },\n\t{ 0x25, \"IsLeapMonth\" },\n\t{ 0x26, \"FirstDayOfWeek\" },\n\n\t{ 0x00, NULL }\n};\n\nstatic const value_string wbxml_mssyncc10_tags_cp10[] = { /* ActiveSync 'ResolveRecipients:' Page */\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"ResolveRecipients\" },\n\t{ 0x06, \"Response\" },\n\t{ 0x07, \"Status\" },\n\t{ 0x08, \"Type\" },\n\t{ 0x09, \"Recipient\" },\n\t{ 0x0A, \"DisplayName\" },\n\t{ 0x0B, \"EmailAddress\" },\n\t{ 0x0C, \"Certificates\" },\n\t{ 0x0D, \"Certificate\" },\n\t{ 0x0E, \"MiniCertificate\" },\n\t{ 0x0F, \"Options\" },\n\t{ 0x10, \"To\" },\n\t{ 0x11, \"CertificateRetrieval\" },\n\t{ 0x12, \"RecipientCount\" },\n\t{ 0x13, \"MaxCertificates\" },\n\t{ 0x14, \"MaxAmbiguousRecipients\" },\n\t{ 0x15, \"CertificateCount\" },\n\t{ 0x16, \"Availability\" },\n\t{ 0x17, \"StartTime\" },\n\t{ 0x18, \"EndTime\" },\n\t{ 0x19, \"MergedFreeBusy\" },\n\t{ 0x1A, \"Picture\" },\n\t{ 0x1B, \"MaxSize\" },\n\t{ 0x1C, \"Data\" },\n\t{ 0x1D, \"MaxPictures\" },\n\n\t{ 0x00, NULL }\n};\n\nstatic const value_string wbxml_mssyncc10_tags_cp11[] = { /* ActiveSync 'ValidateCert:' Page */\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"ValidateCert\" },\n\t{ 0x06, \"Certificates\" },\n\t{ 0x07, \"Certificate\" },\n\t{ 0x08, \"CertificateChain\" },\n\t{ 0x09, \"CheckCRL\" },\n\t{ 0x0A, \"Status\" },\n\n\t{ 0x00, NULL }\n};\n\nstatic const value_string wbxml_mssyncc10_tags_cp12[] = { /* ActiveSync 'Contacts2:' Page */\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"CustomerId\" },\n\t{ 0x06, \"GovernmentId\" },\n\t{ 0x07, \"IMAddress\" },\n\t{ 0x08, \"IMAddress2\" },\n\t{ 0x09, \"IMAddress3\" },\n\t{ 0x0A, \"ManagerName\" },\n\t{ 0x0B, \"CompanyMainPhone\" },\n\t{ 0x0C, \"AccountName\" },\n\t{ 0x0D, \"NickName\" },\n\t{ 0x0E, \"MMS\" },\n\n\t{ 0x00, NULL }\n};\n\nstatic const value_string wbxml_mssyncc10_tags_cp13[] = { /* ActiveSync 'Ping:' Page */\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"Ping\" },\n\t{ 0x06, \"AutdState\" },\n\t{ 0x07, \"Status\" },\n\t{ 0x08, \"HeartbeatInterval\" },\n\t{ 0x09, \"Folders\" },\n\t{ 0x0A, \"Folder\" },\n\t{ 0x0B, \"Id\" },\n\t{ 0x0C, \"Class\" },\n\t{ 0x0D, \"MaxFolders\" },\n\n\t{ 0x00, NULL }\n};\n\nstatic const value_string wbxml_mssyncc10_tags_cp14[] = { /* ActiveSync 'Provision:' Page */\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"Provision\" },\n\t{ 0x06, \"Policies\" },\n\t{ 0x07, \"Policy\" },\n\t{ 0x08, \"PolicyType\" },\n\t{ 0x09, \"PolicyKey\" },\n\t{ 0x0A, \"Data\" },\n\t{ 0x0B, \"Status\" },\n\t{ 0x0C, \"RemoteWipe\" },\n\t{ 0x0D, \"EASProvisionDoc\" },\n\t{ 0x0E, \"DevicePasswordEnabled\" },\n\t{ 0x0F, \"AlphanumericDevicePasswordRequired\" },\n\t{ 0x10, \"DeviceEncryptionEnabled\" },\n\t{ 0x11, \"PasswordRecoveryEnabled\" },\n\t{ 0x13, \"AttachmentsEnabled\" },\n\t{ 0x14, \"MinDevicePasswordLength\" },\n\t{ 0x15, \"MaxInactivityTimeDeviceLock\" },\n\t{ 0x16, \"MaxDevicePasswordFailedAttempts\" },\n\t{ 0x17, \"MaxAttachmentSize\" },\n\t{ 0x18, \"AllowSimpleDevicePassword\" },\n\t{ 0x19, \"DevicePasswordExpiration\" },\n\t{ 0x1A, \"DevicePasswordHistory\" },\n\t{ 0x1B, \"AllowStorageCard\" },\n\t{ 0x1C, \"AllowCamera\" },\n\t{ 0x1D, \"RequireDeviceEncryption\" },\n\t{ 0x1E, \"AllowUnsignedApplications\" },\n\t{ 0x1F, \"AllowUnsignedInstallationPackages\" },\n\t{ 0x20, \"MinDevicePasswordComplexCharacters\" },\n\t{ 0x21, \"AllowWiFi\" },\n\t{ 0x22, \"AllowTextMessaging\" },\n\t{ 0x23, \"AllowPOPIMAPEmail\" },\n\t{ 0x24, \"AllowBluetooth\" },\n\t{ 0x25, \"AllowIrDA\" },\n\t{ 0x26, \"RequireManualSyncWhenRoaming\" },\n\t{ 0x27, \"AllowDesktopSync\" },\n\t{ 0x28, \"MaxCalendarAgeFilter\" },\n\t{ 0x29, \"AllowHTMLEmail\" },\n\t{ 0x2A, \"MaxEmailAgeFilter\" },\n\t{ 0x2B, \"MaxEmailBodyTruncationSize\" },\n\t{ 0x2C, \"MaxEmailHTMLBodyTruncationSize\" },\n\t{ 0x2D, \"RequireSignedSMIMEMessages\" },\n\t{ 0x2E, \"RequireEncryptedSMIMEMessages\" },\n\t{ 0x2F, \"RequireSignedSMIMEAlgorithm\" },\n\t{ 0x30, \"RequireEncryptionSMIMEAlgorithm\" },\n\t{ 0x31, \"AllowSMIMEEncryptionAlgorithmNegotiation\" },\n\t{ 0x32, \"AllowSMIMESoftCerts\" },\n\t{ 0x33, \"AllowBrowser\" },\n\t{ 0x34, \"AllowConsumerEmail\" },\n\t{ 0x35, \"AllowRemoteDesktop\" },\n\t{ 0x36, \"AllowInternetSharing\" },\n\t{ 0x37, \"UnapprovedInROMApplicationList\" },\n\t{ 0x38, \"ApplicationName\" },\n\t{ 0x39, \"ApprovedApplicationList\" },\n\t{ 0x3A, \"Hash\" },\n\n\t{ 0x00, NULL }\n};\n\nstatic const value_string wbxml_mssyncc10_tags_cp15[] = { /* ActiveSync 'Search:' Page */\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"Search\" },\n\t{ 0x07, \"Store\" },\n\t{ 0x08, \"Name\" },\n\t{ 0x09, \"Query\" },\n\t{ 0x0A, \"Options\" },\n\t{ 0x0B, \"Range\" },\n\t{ 0x0C, \"Status\" },\n\t{ 0x0D, \"Response\" },\n\t{ 0x0E, \"Result\" },\n\t{ 0x0F, \"Properties\" },\n\t{ 0x10, \"Total\" },\n\t{ 0x11, \"EqualTo\" },\n\t{ 0x12, \"Value\" },\n\t{ 0x13, \"And\" },\n\t{ 0x14, \"Or\" },\n\t{ 0x15, \"FreeText\" },\n\t{ 0x17, \"DeepTraversal\" },\n\t{ 0x18, \"LongId\" },\n\t{ 0x19, \"RebuildResults\" },\n\t{ 0x1A, \"LessThan\" },\n\t{ 0x1B, \"GreaterThan\" },\n\t{ 0x1E, \"UserName\" },\n\t{ 0x1F, \"Password\" },\n\t{ 0x20, \"ConversationId\" },\n\t{ 0x21, \"Picture\" },\n\t{ 0x22, \"MaxSize\" },\n\t{ 0x23, \"MaxPictures\" },\n\n\t{ 0x00, NULL }\n};\n\nstatic const value_string wbxml_mssyncc10_tags_cp16[] = { /* ActiveSync 'Gal:' Page */\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"DisplayName\" },\n\t{ 0x06, \"Phone\" },\n\t{ 0x07, \"Office\" },\n\t{ 0x08, \"Title\" },\n\t{ 0x09, \"Company\" },\n\t{ 0x0A, \"Alias\" },\n\t{ 0x0B, \"FirstName\" },\n\t{ 0x0C, \"LastName\" },\n\t{ 0x0D, \"HomePhone\" },\n\t{ 0x0E, \"MobilePhone\" },\n\t{ 0x0F, \"EmailAddress\" },\n\t{ 0x10, \"Picture\" },\n\t{ 0x11, \"Status\" },\n\t{ 0x12, \"Data\" },\n\n\t{ 0x00, NULL }\n};\n\nstatic const value_string wbxml_mssyncc10_tags_cp17[] = { /* ActiveSync 'AirSyncBase:' Page */\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"BodyPreference\" },\n\t{ 0x06, \"Type\" },\n\t{ 0x07, \"TruncationSize\" },\n\t{ 0x08, \"AllOrNone\" },\n\t{ 0x0A, \"Body\" },\n\t{ 0x0B, \"Data\" },\n\t{ 0x0C, \"EstimatedDataSize\" },\n\t{ 0x0D, \"Truncated\" },\n\t{ 0x0E, \"Attachments\" },\n\t{ 0x0F, \"Attachment\" },\n\t{ 0x10, \"DisplayName\" },\n\t{ 0x11, \"FileReference\" },\n\t{ 0x12, \"Method\" },\n\t{ 0x13, \"ContentId\" },\n\t{ 0x14, \"ContentLocation\" },\n\t{ 0x15, \"IsInline\" },\n\t{ 0x16, \"NativeBodyType\" },\n\t{ 0x17, \"ContentType\" },\n\t{ 0x18, \"Preview\" },\n\t{ 0x19, \"BodyPartReference\" },\n\t{ 0x1A, \"BodyPart\" },\n\t{ 0x1B, \"Status\" },\n\n\t{ 0x00, NULL }\n};\n\nstatic const value_string wbxml_mssyncc10_tags_cp18[] = { /* ActiveSync 'Settings:' Page */\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"Settings\" },\n\t{ 0x06, \"Status\" },\n\t{ 0x07, \"Get\" },\n\t{ 0x08, \"Set\" },\n\t{ 0x09, \"Oof\" },\n\t{ 0x0A, \"OofState\" },\n\t{ 0x0B, \"StartTime\" },\n\t{ 0x0C, \"EndTime\" },\n\t{ 0x0D, \"OofMessage\" },\n\t{ 0x0E, \"AppliesToInteral\" },\n\t{ 0x0F, \"AppliesToExternalKnown\" },\n\t{ 0x10, \"AppliesToExternalUnknown\" },\n\t{ 0x11, \"Enabled\" },\n\t{ 0x12, \"ReplyMessage\" },\n\t{ 0x13, \"BodyType\" },\n\t{ 0x14, \"DevicePassword\" },\n\t{ 0x15, \"Password\" },\n\t{ 0x16, \"DeviceInformation\" },\n\t{ 0x17, \"Model\" },\n\t{ 0x18, \"IMEI\" },\n\t{ 0x19, \"FriendlyName\" },\n\t{ 0x1A, \"OS\" },\n\t{ 0x1B, \"OSLanguage\" },\n\t{ 0x1C, \"PhoneNumber\" },\n\t{ 0x1D, \"UserInformation\" },\n\t{ 0x1E, \"EmailAddresses\" },\n\t{ 0x1F, \"SmtpAddress\" },\n\t{ 0x20, \"UserAgent\" },\n\t{ 0x21, \"EnableOutboundSMS\" },\n\t{ 0x22, \"MobileOperator\" },\n\t{ 0x23, \"PrimarySmtpAddress\" },\n\t{ 0x24, \"Accounts\" },\n\t{ 0x25, \"Account\" },\n\t{ 0x26, \"AccountId\" },\n\t{ 0x27, \"AccountName\" },\n\t{ 0x28, \"UserDisplayName\" },\n\t{ 0x29, \"SendDisabled\" },\n\t{ 0x2B, \"RightsManagementInformation\" },\n\n\t{ 0x00, NULL }\n};\n\nstatic const value_string wbxml_mssyncc10_tags_cp19[] = { /* ActiveSync 'DocumentLibrary:' Page */\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"LinkId\" },\n\t{ 0x06, \"DisplayName\" },\n\t{ 0x07, \"IsFolder\" },\n\t{ 0x09, \"CreationDate\" },\n\t{ 0x0A, \"LastModifiedDate\" },\n\t{ 0x0B, \"ContentLength\" },\n\t{ 0x0C, \"ContentType\" },\n\n\t{ 0x00, NULL }\n};\n\nstatic const value_string wbxml_mssyncc10_tags_cp20[] = { /* ActiveSync 'ItemOperations:' Page */\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"ItemOperations\" },\n\t{ 0x06, \"Fetch\" },\n\t{ 0x07, \"Store\" },\n\t{ 0x08, \"Options\" },\n\t{ 0x09, \"Range\" },\n\t{ 0x0A, \"Total\" },\n\t{ 0x0B, \"Properties\" },\n\t{ 0x0C, \"Data\" },\n\t{ 0x0D, \"Status\" },\n\t{ 0x0E, \"Response\" },\n\t{ 0x0F, \"Version\" },\n\t{ 0x10, \"Schema\" },\n\t{ 0x11, \"Part\" },\n\t{ 0x12, \"EmptyFolderContents\" },\n\t{ 0x13, \"DeleteSubFolders\" },\n\t{ 0x14, \"UserName\" },\n\t{ 0x15, \"Password\" },\n\t{ 0x16, \"Move\" },\n\t{ 0x17, \"DstFldId\" },\n\t{ 0x18, \"ConversationId\" },\n\t{ 0x19, \"MoveAlways\" },\n\n\t{ 0x00, NULL }\n};\n\nstatic const value_string wbxml_mssyncc10_tags_cp21[] = { /* ActiveSync 'ComposeMail:' Page */\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"SendMail\" },\n\t{ 0x06, \"SmartForward\" },\n\t{ 0x07, \"SmartReply\" },\n\t{ 0x08, \"SaveInSentItems\" },\n\t{ 0x09, \"ReplaceMime\" },\n\t{ 0x0B, \"Source\" },\n\t{ 0x0C, \"FolderId\" },\n\t{ 0x0D, \"ItemId\" },\n\t{ 0x0E, \"LongId\" },\n\t{ 0x0F, \"InstanceId\" },\n\t{ 0x10, \"MIME\" },\n\t{ 0x11, \"ClientId\" },\n\t{ 0x12, \"Status\" },\n\t{ 0x13, \"AccountId\" },\n\n\t{ 0x00, NULL }\n};\n\nstatic const value_string wbxml_mssyncc10_tags_cp22[] = { /* ActiveSync 'Email2:' Page */\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"UmCallerID\" },\n\t{ 0x06, \"UmUserNotes\" },\n\t{ 0x07, \"UmAttDuration\" },\n\t{ 0x08, \"UmAttOrder\" },\n\t{ 0x09, \"ConversationId\" },\n\t{ 0x0A, \"ConversationIndex\" },\n\t{ 0x0B, \"LastVerbExecuted\" },\n\t{ 0x0C, \"LastVerbExecutionTime\" },\n\t{ 0x0D, \"ReceivedAsBcc\" },\n\t{ 0x0E, \"Sender\" },\n\t{ 0x0F, \"CalendarType\" },\n\t{ 0x10, \"IsLeapMonth\" },\n\t{ 0x11, \"AccountId\" },\n\t{ 0x12, \"FirstDayOfWeek\" },\n\t{ 0x13, \"MeetingMessageType\" },\n\n\t{ 0x00, NULL }\n};\n\nstatic const value_string wbxml_mssyncc10_tags_cp23[] = { /* ActiveSync 'Notes:' Page */\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"Subject\" },\n\t{ 0x06, \"MessageClass\" },\n\t{ 0x07, \"LastModifiedDate\" },\n\t{ 0x08, \"Categories\" },\n\t{ 0x09, \"Category\" },\n\n\t{ 0x00, NULL }\n};\n\nstatic const value_string wbxml_mssyncc10_tags_cp24[] = { /* ActiveSync 'RightsManagement:' Page */\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"RightsManagementSupport\" },\n\t{ 0x06, \"RightsManagementTemplates\" },\n\t{ 0x07, \"RightsManagementTemplate\" },\n\t{ 0x08, \"RightsManagementLicense\" },\n\t{ 0x09, \"EditAllowed\" },\n\t{ 0x0A, \"ReplyAllowed\" },\n\t{ 0x0B, \"ReplyAllAllowed\" },\n\t{ 0x0C, \"ForwardAllowed\" },\n\t{ 0x0D, \"ModifyRecipientsAllowed\" },\n\t{ 0x0E, \"ExtractAllowed\" },\n\t{ 0x0F, \"PrintAllowed\" },\n\t{ 0x10, \"ExportAllowed\" },\n\t{ 0x11, \"ProgrammaticAccessAllowed\" },\n\t{ 0x12, \"RMOwner\" },\n\t{ 0x13, \"ContentExpiryDate\" },\n\t{ 0x14, \"TemplateId\" },\n\t{ 0x15, \"TemplateName\" },\n\t{ 0x16, \"TemplateDescription\" },\n\t{ 0x17, \"ContentOwner\" },\n\t{ 0x18, \"RemoveRightsManagementDistribution\" },\n\n\t{ 0x00, NULL }\n};\n\n\n/*****    Attribute Start tokens   *****/\n\n/*****    Attribute Value tokens   *****/\n\n/***** Token code page aggregation *****/\nstatic const value_valuestring wbxml_mssyncc10_tags[] = {\n\t{ 0x00, wbxml_mssyncc10_tags_cp0 }, /* AirSync: */\n\t{ 0x01, wbxml_mssyncc10_tags_cp1 }, /* Contacts: */\n\t{ 0x02, wbxml_mssyncc10_tags_cp2 }, /* Email: */\n\t{ 0x04, wbxml_mssyncc10_tags_cp4 }, /* Calendar: */\n\t{ 0x05, wbxml_mssyncc10_tags_cp5 }, /* Move: */\n\t{ 0x06, wbxml_mssyncc10_tags_cp6 }, /* GetItemEstimate: */\n\t{ 0x07, wbxml_mssyncc10_tags_cp7 }, /* FolderHierarchy: */\n\t{ 0x08, wbxml_mssyncc10_tags_cp8 }, /* MeetingResponse: */\n\t{ 0x09, wbxml_mssyncc10_tags_cp9 }, /* Tasks: */\n\t{ 0x0A, wbxml_mssyncc10_tags_cp10 }, /* ResolveRecipients: */\n\t{ 0x0B, wbxml_mssyncc10_tags_cp11 }, /* ValidateCert: */\n\t{ 0x0C, wbxml_mssyncc10_tags_cp12 }, /* Contacts2: */\n\t{ 0x0D, wbxml_mssyncc10_tags_cp13 }, /* Ping: */\n\t{ 0x0E, wbxml_mssyncc10_tags_cp14 }, /* Provision: */\n\t{ 0x0F, wbxml_mssyncc10_tags_cp15 }, /* Search: */\n\t{ 0x10, wbxml_mssyncc10_tags_cp16 }, /* Gal: */\n\t{ 0x11, wbxml_mssyncc10_tags_cp17 }, /* AirSyncBase: */\n\t{ 0x12, wbxml_mssyncc10_tags_cp18 }, /* Settings: */\n\t{ 0x13, wbxml_mssyncc10_tags_cp19 }, /* DocumentLibrary: */\n\t{ 0x14, wbxml_mssyncc10_tags_cp20 }, /* ItemOperations: */\n\t{ 0x15, wbxml_mssyncc10_tags_cp21 }, /* ComposeMail: */\n\t{ 0x16, wbxml_mssyncc10_tags_cp22 }, /* Email2: */\n\t{ 0x17, wbxml_mssyncc10_tags_cp23 }, /* Notes: */\n\t{ 0x18, wbxml_mssyncc10_tags_cp24 }, /* RightsManagement: */\n\n\t{ 0x00, NULL }\n};\n\nstatic const wbxml_decoding decode_mssync_10 = {\n\t\"Microsoft ActiveSync\",\n\t\"ActiveSync\",\n\t{ NULL, NULL, NULL },\n\tdefault_opaque_binary_tag,\n\tdefault_opaque_literal_tag,\n\tdefault_opaque_binary_attr,\n\tdefault_opaque_literal_attr,\n\tNULL,\n\twbxml_mssyncc10_tags,\n\tNULL,\n\tNULL\n};\n\n\n\n\n/* CHANNEL 1.0\n *\n * WTA Channel\n ***************************************/\n\n/*****   Global extension tokens   *****/\n\n/*****         Tag tokens          *****/\nstatic const value_string wbxml_channelc10_tags_cp0[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"channel\" },\n\t{ 0x06, \"title\" },\n\t{ 0x07, \"abstract\" },\n\t{ 0x08, \"resource\" },\n\n\t{ 0x00, NULL }\n};\n\n/*****    Attribute Start tokens   *****/\nstatic const value_string wbxml_channelc10_attrStart_cp0[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"maxspace=\" },\n\t{ 0x06, \"base=\" },\n\t{ 0x07, \"href=\" },\n\t{ 0x08, \"href='http://'\" },\n\t{ 0x09, \"href='https://'\" },\n\t{ 0x0A, \"lastmod=\" },\n\t{ 0x0B, \"etag=\" },\n\t{ 0x0C, \"md5=\" },\n\t{ 0x0D, \"success=\" },\n\t{ 0x0E, \"success='http://'\" },\n\t{ 0x0F, \"success='https://'\" },\n\t{ 0x10, \"failure=\" },\n\t{ 0x11, \"failure='http://'\" },\n\t{ 0x12, \"failure='https://'\" },\n\t{ 0x13, \"EventId=\" },\n\n\t{ 0x00, NULL }\n};\n\n/*****    Attribute Value tokens   *****/\n\n/***** Token code page aggregation *****/\nstatic const value_valuestring wbxml_channelc10_tags[] = {\n\t{ 0, wbxml_channelc10_tags_cp0 },\n\t{ 0, NULL }\n};\n\nstatic const value_valuestring wbxml_channelc10_attrStart[] = {\n\t{ 0, wbxml_channelc10_attrStart_cp0 },\n\t{ 0, NULL }\n};\n\nstatic const wbxml_decoding decode_channelc_10 = {\n\t\"Wireless Telephony Application (WTA) Channel 1.0\",\n\t\"CHANNEL 1.0\",\n\t{ NULL, NULL, NULL },\n\tdefault_opaque_binary_tag,\n\tdefault_opaque_literal_tag,\n\tdefault_opaque_binary_attr,\n\tdefault_opaque_literal_attr,\n\tNULL,\n\twbxml_channelc10_tags,\n\twbxml_channelc10_attrStart,\n\tNULL\n};\n\n\n\n\n\n/* application/x-wap-prov.browser-settings\n * application/x-wap-prov.browser-bookmarks\n *\n * Nokia OTA Provisioning document format\n ***************************************/\n\n/*****   Global extension tokens   *****/\n\n/*****         Tag tokens          *****/\nstatic const value_string wbxml_nokiaprovc70_tags_cp0[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"CHARACTERISTIC-LIST\" },\n\t{ 0x06, \"CHARACTERISTIC\" },\n\t{ 0x07, \"PARM\" },\n\n\t{ 0x00, NULL }\n};\n\n/*****    Attribute Start tokens   *****/\nstatic const value_string wbxml_nokiaprovc70_attrStart_cp0[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x06, \"TYPE='ADDRESS'\" },\n\t{ 0x07, \"TYPE='URL'\" },\n\t{ 0x08, \"TYPE='NAME'\" },\n\t{ 0x10, \"NAME=\" },\n\t{ 0x11, \"VALUE=\" },\n\t{ 0x12, \"NAME='BEARER'\" },\n\t{ 0x13, \"NAME='PROXY'\" },\n\t{ 0x14, \"NAME='PORT'\" },\n\t{ 0x15, \"NAME='NAME'\" },\n\t{ 0x16, \"NAME='PROXY_TYPE'\" },\n\t{ 0x17, \"NAME='URL'\" },\n\t{ 0x18, \"NAME='PROXY_AUTHNAME'\" },\n\t{ 0x19, \"NAME='PROXY_AUTHSECRET'\" },\n\t{ 0x1A, \"NAME='SMS_SMSC_ADDRESS'\" },\n\t{ 0x1B, \"NAME='USSD_SERVICE_CODE'\" },\n\t{ 0x1C, \"NAME='GPRS_ACCESSPOINTNAME'\" },\n\t{ 0x1D, \"NAME='PPP_LOGINTYPE'\" },\n\t{ 0x1E, \"NAME='PROXY_LOGINTYPE'\" },\n\t{ 0x21, \"NAME='CSD_DIALSTRING'\" },\n\t{ 0x22, \"NAME='PPP_AUTHTYPE'\" },\n\t{ 0x23, \"NAME='PPP_AUTHNAME'\" },\n\t{ 0x24, \"NAME='PPP_AUTHSECRET'\" },\n\t{ 0x28, \"NAME='CSD_CALLTYPE'\" },\n\t{ 0x29, \"NAME='CSD_CALLSPEED'\" },\n\t{ 0x45, \"VALUE='GSM/CSD'\" },\n\t{ 0x46, \"VALUE='GSM/SMS'\" },\n\t{ 0x47, \"VALUE='GSM/USSD'\" },\n\t{ 0x48, \"VALUE='IS-136/CSD'\" },\n\t{ 0x49, \"VALUE='GPRS'\" },\n\t{ 0x60, \"VALUE='9200'\" },\n\t{ 0x61, \"VALUE='9201'\" },\n\t{ 0x62, \"VALUE='9202'\" },\n\t{ 0x63, \"VALUE='9203'\" },\n\t{ 0x64, \"VALUE='AUTOMATIC'\" },\n\t{ 0x65, \"VALUE='MANUAL'\" },\n\t{ 0x6A, \"VALUE='AUTO'\" },\n\t{ 0x6B, \"VALUE='9600'\" },\n\t{ 0x6C, \"VALUE='14400'\" },\n\t{ 0x6D, \"VALUE='19200'\" },\n\t{ 0x6E, \"VALUE='28800'\" },\n\t{ 0x6F, \"VALUE='38400'\" },\n\t{ 0x70, \"VALUE='PAP'\" },\n\t{ 0x71, \"VALUE='CHAP'\" },\n\t{ 0x72, \"VALUE='ANALOGUE'\" },\n\t{ 0x73, \"VALUE='ISDN'\" },\n\t{ 0x74, \"VALUE='43200'\" },\n\t{ 0x75, \"VALUE='57600'\" },\n\t{ 0x76, \"VALUE='MSISDN_NO'\" },\n\t{ 0x77, \"VALUE='IPV4'\" },\n\t{ 0x78, \"VALUE='MS_CHAP'\" },\n\t{ 0x7C, \"TYPE='MMSURL'\" },\n\t{ 0x7D, \"TYPE='ID'\" },\n\t{ 0x7E, \"NAME='ISP_NAME'\" },\n\t{ 0x7F, \"TYPE='BOOKMARK'\" },\n\n\t{ 0x00, NULL }\n};\n\n/*****    Attribute Value tokens   *****/\n\n/***** Token code page aggregation *****/\nstatic const value_valuestring wbxml_nokiaprovc70_tags[] = {\n\t{ 0, wbxml_nokiaprovc70_tags_cp0 },\n\t{ 0, NULL }\n};\n\nstatic const value_valuestring wbxml_nokiaprovc70_attrStart[] = {\n\t{ 0, wbxml_nokiaprovc70_attrStart_cp0 },\n\t{ 0, NULL }\n};\n\nstatic const wbxml_decoding decode_nokiaprovc_70 = {\n\t\"Nokia Client Provisioning 7.0\",\n\t\"Nokia Client Provisioning 7.0\",\n\t{ NULL, NULL, NULL },\n\tdefault_opaque_binary_tag,\n\tdefault_opaque_literal_tag,\n\tdefault_opaque_binary_attr,\n\tdefault_opaque_literal_attr,\n\tNULL,\n\twbxml_nokiaprovc70_tags,\n\twbxml_nokiaprovc70_attrStart,\n\tNULL\n};\n\n\n\n\n\n/* UAProf [WAP-248]\n *\n * User-Agent Profile (used in profile-diff WSP header)\n ***************************************/\n\n/*****   Global extension tokens   *****/\n\n/*****         Tag tokens          *****/\n/* CodePage\t0\tRDF */\nstatic const value_string  wbxml_uaprof_tags_cp0[] = {\n\t{0x05, \"rdf:RDF\"},\n\t{0x06, \"rdf:Description\"},\n\t{0x07, \"rdf:Alt\"},\n\t{0x08, \"rdf:Bag\"},\n\t{0x09, \"rdf:Seq\"},\n\t{0x0A, \"rdf:li\"},\n\t{0x0B, \"rdf:type\"},\n\t{0x0C, \"rdf:value\"},\n\t{0x0D, \"rdf:subject\"},\n\t{0x0E, \"rdf:predicate\"},\n\t{0x0F, \"rdf:object\"},\n\n\t{ 0x00, NULL }\n};\n\n/* CodePage\t1\tCore Vocabulary */\nstatic const value_string  wbxml_uaprof_tags_cp1[] = {\n\t{0x06, \"rdf:Description\"},\n\t{0x07, \"rdf:Alt\"},\n\t{0x08, \"rdf:Bag\"},\n\t{0x09, \"rdf:Seq\"},\n\t{0x0A, \"rdf:li\"},\n\t{0x0B, \"rdf:type\"},\n\t{0x0C, \"prf:component\"},\n\t{0x0D, \"prf:defaults\"},\n\t{0x0E, \"prf:BitsPerPixel\"},\n\t{0x0F, \"prf:ColorCapable\"},\n\t{0x10, \"prf:CPU\"},\n\t{0x11, \"prf:ImageCapable\"},\n\t{0x12, \"prf:InputCharSet\"},\n\t{0x13, \"prf:Keyboard\"},\n\t{0x15, \"prf:Model\"},\n\t{0x16, \"prf:OutputCharSet\"},\n\t{0x17, \"prf:PointingResolution\"},\n\t{0x18, \"prf:ScreenSize\"},\n\t{0x19, \"prf:ScreenSizeChar\"},\n\t{0x1A, \"prf:NumberOfSoftKeys\"},\n\t{0x1B, \"prf:SoundOutputCapable\"},\n\t{0x1C, \"prf:TextInputCapable\"},\n\t{0x1D, \"prf:Vendor\"},\n\t{0x1E, \"prf:VoiceInputCapable\"},\n\t{0x1F, \"prf:AcceptDownloadableSoftware\"},\n\t{0x20, \"prf:AudioInputEncoder\"},\n\t{0x21, \"prf:DownloadableSoftwareSupport\"},\n\t{0x22, \"prf:JavaEnabled\"},\n\t{0x23, \"prf:JVMVersion\"},\n\t{0x24, \"prf:MexeClassmark\"},\n\t{0x25, \"prf:MexeSpec\"},\n\t{0x26, \"prf:OSName\"},\n\t{0x27, \"prf:OSVendor\"},\n\t{0x28, \"prf:OSVersion\"},\n\t{0x29, \"prf:RecipientAppAgent\"},\n\t{0x2A, \"prf:SoftwareNumber\"},\n\t{0x2B, \"prf:VideoInputEncoder\"},\n\t{0x2C, \"prf:CurrentBearerService\"},\n\t{0x2D, \"prf:SecuritySupport\"},\n\t{0x2E, \"prf:SupportedBearers\"},\n\t{0x2F, \"prf:WapDeviceClass\"},\n\t{0x30, \"prf:WapPushMsgPriority\"}, /* Deprecated */\n\t{0x31, \"prf:WapPushMsgSize\"}, /* Deprecated */\n\t{0x32, \"prf:WapVersion\"},\n\t{0x33, \"prf:WmlDeckSize\"},\n\t{0x34, \"prf:WmlScriptLibraries\"},\n\t{0x35, \"prf:WmlScriptVersion\"},\n\t{0x36, \"prf:WmlVersion\"},\n\t{0x37, \"prf:WtaiLibraries\"},\n\t{0x38, \"prf:WtaVersion\"},\n\t{0x39, \"prf:PixelAspectRatio\"},\n\t{0x3A, \"prf:StandardFontProportional\"},\n\t{0x3B, \"prf:WapSupportedApplications\"}, /* Deprecated */\n\t{0x3C, \"prf:BluetoothProfile\"},\n\t{0x3D, \"prf:MexeClassmarks\"},\n\t{0x3E, \"prf:MexeSecureDomains\"},\n\n\t{ 0x00, NULL }\n};\n\n/* CodePage\t4\tCore Vocabulary (continued) */\nstatic const value_string  wbxml_uaprof_tags_cp4[] = {\n\t{0x10, \"prf:SupportedBluetoothVersion\"},\n\t{0x11, \"prf:SupportedPictogramSet\"},\n\t{0x12, \"prf:CcppAccept\"},\n\t{0x13, \"prf:CcppAccept-Charset\"},\n\t{0x14, \"prf:CcppAccept-Encoding\"},\n\t{0x15, \"prf:CcppAccept-Language\"},\n\n\t{ 0x00, NULL }\n};\n\n/* CodePage\t2\tBrowserUA */\nstatic const value_string  wbxml_uaprof_tags_cp2[] = {\n\t{0x05, \"rdf:Description\"},\n\t{0x06, \"rdf:Alt\"},\n\t{0x07, \"rdf:Bag\"},\n\t{0x08, \"rdf:Seq\"},\n\t{0x09, \"rdf:li\"},\n\t{0x0A, \"rdf:type\"},\n\t{0x0B, \"prf:component\"},\n\t{0x0C, \"prf:defaults\"},\n\t{0x0D, \"prf:BrowserName\"},\n\t{0x0E, \"prf:BrowserVersion\"},\n\t{0x0F, \"prf:CcppAccept\"}, /* Deprecated */\n\t{0x10, \"prf:CcppAccept-Charset\"}, /* Deprecated */\n\t{0x11, \"prf:CcppAccept-Encoding\"}, /* Deprecated */\n\t{0x12, \"prf:CcppAccept-Language\"}, /* Deprecated */\n\t{0x13, \"prf:DownloadableBrowserApps\"},\n\t{0x14, \"prf:FramesCapable\"},\n\t{0x15, \"prf:HtmlVersion\"},\n\t{0x16, \"prf:JavaAppletEnabled\"},\n\t{0x17, \"prf:JavaScriptEnabled\"},\n\t{0x18, \"prf:JavaScriptVersion\"},\n\t{0x19, \"prf:PreferenceForFrames\"},\n\t{0x1A, \"prf:TablesCapable\"},\n\t{0x1B, \"Prf:XhtmlVersion\"},\n\t{0x1C, \"prf:XhtmlModules\"},\n\n\t{ 0x00, NULL }\n};\n\n/* CodePage\t3\tPushCharacteristics */\nstatic const value_string  wbxml_uaprof_tags_cp3[] = {\n\t{0x05, \"rdf:Description\"},\n\t{0x06, \"rdf:Alt\"},\n\t{0x07, \"rdf:Bag\"},\n\t{0x08, \"rdf:Seq\"},\n\t{0x09, \"rdf:li\"},\n\t{0x0A, \"rdf:type\"},\n\t{0x0B, \"prf:component\"},\n\t{0x0C, \"prf:defaults\"},\n\t{0x0D, \"prf:Push-Accept\"},\n\t{0x0E, \"prf:Push-Accept-Charset\"},\n\t{0x0F, \"prf:Push-Accept-Encoding\"},\n\t{0x10, \"prf:Push-Accept-Language\"},\n\t{0x11, \"prf:Push-Accept-AppID\"},\n\t{0x12, \"prf:Push-MsgSize\"},\n\t{0x13, \"prf:Push-MaxPushReq\"},\n\n\t{ 0x00, NULL }\n};\n\n/*****    Attribute Start tokens   *****/\n/* CodePage\t0\tRDF */\nstatic const value_string  wbxml_uaprof_attrStart_cp0[] = {\n\t{0x05, \"ID\"},\n\t{0x06, \"rdf:about\"},\n\t{0x07, \"rdf:aboutEach\"},\n\t{0x08, \"rdf:aboutEachPrefix\"},\n\t{0x09, \"rdf:bagID\"},\n\t{0x0A, \"rdf:type\"},\n\t{0x0B, \"rdf:resource\"},\n\t{0x0C, \"rdf:parseType='Literal'\"},\n\t{0x0D, \"rdf:parseType='Resource'\"},\n\t{0x0E, \"xml:lang\"},\n\t{0x0F, \"xmlns:prf\"},\n\t{0x10, \"xmlns:rdf\"},\n\n\t{ 0x00, NULL }\n};\n\n/* CodePage\t1\tCore Vocabulary */\nstatic const value_string  wbxml_uaprof_attrStart_cp1[] = {\n\t{0x05, \"rdf:resource\"},\n\t{0x06, \"rdf:resource='http://www.wapforum.org/profiles/UAPROF/\"\n\t \"ccppschema-20010430#HardwarePlatform'\"},\n\t{0x07, \"rdf:resource='http://www.wapforum.org/profiles/UAPROF/\"\n\t \"ccppschema-20010430#SoftwarePlatform'\"},\n\t{0x08, \"rdf:resource='http://www.wapforum.org/profiles/UAPROF/\"\n\t \"ccppschema-20010430#NetworkCharacteristics'\"},\n\t{0x09, \"rdf:resource='http://www.wapforum.org/profiles/UAPROF/\"\n\t \"ccppschema-20010430#WapCharacteristics'\"},\n\t{0x0A, \"rdf:resource='http://www.wapforum.org/profiles/UAPROF/\"\n\t \"ccppschema-20010430#BrowserUA'\"},\n\t{0x0B, \"rdf:resource='http://www.wapforum.org/profiles/UAPROF/\"\n\t \"ccppschema-20010430#PushCharacteristics'\"},\n\t{0x10, \"prf:BitsPerPixel\"},\n\t{0x11, \"prf:ColorCapable='Yes'\"},\n\t{0x12, \"prf:ColorCapable='No'\"},\n\t{0x13, \"prf:CPU\"},\n\t{0x14, \"prf:ImageCapable='Yes'\"},\n\t{0x15, \"prf:ImageCapable='No'\"},\n\t{0x16, \"prf:InputCharSet\"},\n\t{0x17, \"prf:Keyboard\"},\n\t{0x19, \"prf:Model\"},\n\t{0x1A, \"prf:OutputCharSet\"},\n\t{0x1B, \"prf:PointingResolution\"},\n\t{0x1C, \"prf:ScreenSize\"},\n\t{0x1D, \"prf:ScreenSizeChar\"},\n\t{0x1E, \"prf:NumberOfSoftKeys='Yes'\"},\n\t{0x20, \"prf:SoundOutputCapable='Yes'\"},\n\t{0x21, \"prf:SoundOutputCapable='No'\"},\n\t{0x22, \"prf:TextInputCapable='Yes'\"},\n\t{0x23, \"prf:TextInputCapable='No'\"},\n\t{0x24, \"prf:Vendor\"},\n\t{0x25, \"prf:VoiceInputCapable='Yes'\"},\n\t{0x26, \"prf:VoiceInputCapable='No'\"},\n\t{0x27, \"prf:PixelAspectRatio\"},\n\t{0x28, \"prf:StandardFontProportional='Yes'\"},\n\t{0x29, \"prf:StandardFontProportional='No'\"},\n\t{0x30, \"prf:AcceptDownloadableSoftware='Yes'\"},\n\t{0x31, \"prf:AcceptDownloadableSoftware='No'\"},\n\t{0x32, \"prf:AudioInputEncoder\"},\n\t{0x33, \"prf:DownloadableSoftwareSupport\"},\n\t{0x35, \"prf:JavaEnabled='Yes'\"},\n\t{0x36, \"prf:JavaEnabled='No'\"},\n\t{0x37, \"prf:JVMVersion\"},\n\t{0x38, \"prf:MexeClassmark\"},\n\t{0x39, \"prf:MexeSpec\"},\n\t{0x3A, \"prf:OSName\"},\n\t{0x3B, \"prf:OSVendor\"},\n\t{0x3C, \"prf:OSVersion\"},\n\t{0x3D, \"prf:RecipientAppAgent\"},\n\t{0x3E, \"prf:SoftwareNumber\"},\n\t{0x21, \"prf:SoundOutputCapable='No'\"},\n\t{0x22, \"prf:TextInputCapable='Yes'\"},\n\t{0x23, \"prf:TextInputCapable='No'\"},\n\t{0x24, \"prf:Vendor\"},\n\t{0x25, \"prf:VoiceInputCapable='Yes'\"},\n\t{0x26, \"prf:VoiceInputCapable='No'\"},\n\t{0x27, \"prf:PixelAspectRatio\"},\n\t{0x28, \"prf:StandardFontProportional='Yes'\"},\n\t{0x29, \"prf:StandardFontProportional='No'\"},\n\t{0x30, \"prf:AcceptDownloadableSoftware='Yes'\"},\n\t{0x31, \"prf:AcceptDownloadableSoftware='No'\"},\n\t{0x32, \"prf:AudioInputEncoder\"},\n\t{0x33, \"prf:DownloadableSoftwareSupport\"},\n\t{0x35, \"prf:JavaEnabled='Yes'\"},\n\t{0x36, \"prf:JavaEnabled='No'\"},\n\t{0x37, \"prf:JVMVersion\"},\n\t{0x38, \"prf:MexeClassmark\"},\n\t{0x39, \"prf:MexeSpec\"},\n\t{0x3A, \"prf:OSName\"},\n\t{0x3B, \"prf:OSVendor\"},\n\t{0x3C, \"prf:OSVersion\"},\n\t{0x3D, \"prf:RecipientAppAgent\"},\n\t{0x3E, \"prf:SoftwareNumber\"},\n\t{0x3F, \"prf:VideoInputEncoder\"},\n\t{0x50, \"prf:CurrentBearerService\"},\n\t{0x51, \"prf:SecuritySupport\"},\n\t{0x52, \"prf:SupportedBearers\"},\n\t{0x60, \"prf:WapDeviceClass\"},\n\t{0x61, \"prf:WapPushMsgPriority\"}, /* Deprecated */\n\t{0x62, \"prf:WapPushMsgSize\"}, /* Deprecated */\n\t{0x63, \"prf:WapVersion\"},\n\t{0x64, \"prf:WmlDeckSize\"},\n\t{0x65, \"prf:WmlScriptLibraries\"},\n\t{0x66, \"prf:WmlScriptVersion\"},\n\t{0x67, \"prf:WmlVersion\"},\n\t{0x68, \"prf:WtaiLibraries\"},\n\t{0x69, \"prf:WtaVersion\"},\n\t{0x70, \"prf:WapSupportedApplications\"}, /* Deprecated */\n\t{0x71, \"prf:BluetoothProfile\"},\n\t{0x72, \"prf:MexeClassmarks\"},\n\t{0x73, \"prf:MexeSecureDomains='YES'\"},\n\t{0x74, \"prf:MexeSecureDomains='NO'\"},\n\t{0x75, \"prf:SupportedBluetoothVersion\"},\n\t{0x76, \"prf:SupportedPictogramSet\"},\n\t{0x77, \"prf:CcppAccept\"},\n\t{0x78, \"prf:CcppAccept-Charset\"},\n\t{0x79, \"prf:CcppAccept-Encoding\"},\n\t{0x7F, \"prf:CcppAccept-Language\"},\n\n\t{ 0x00, NULL }\n};\n\n/* CodePage\t2\tBrowserUA */\nstatic const value_string  wbxml_uaprof_attrStart_cp2[] = {\n\t{0x05, \"prf:CcppAccept\"}, /* Deprecated */\n\t{0x06, \"prf:CcppAccept-Charset\"}, /* Deprecated */\n\t{0x07, \"prf:CcppAccept-Encoding\"}, /* Deprecated */\n\t{0x08, \"prf:CcppAccept-Language\"}, /* Deprecated */\n\t{0x09, \"prf:DownloadableBrowserApps\"},\n\t{0x0A, \"prf:FramesCapable='Yes'\"},\n\t{0x0B, \"prf:FramesCapable='No'\"},\n\t{0x0C, \"prf:HtmlVersion='3.2'\"},\n\t{0x0D, \"prf:HtmlVersion='4.0'\"},\n\t{0x0E, \"prf:JavaAppletEnabled='Yes'\"},\n\t{0x0F, \"prf:JavaAppletEnabled='No'\"},\n\t{0x10, \"prf:JavaScriptEnabled='Yes'\"},\n\t{0x11, \"prf:JavaScriptEnabled='No'\"},\n\t{0x12, \"prf:JavaScriptVersion\"},\n\t{0x13, \"prf:PreferenceForFrames='Yes'\"},\n\t{0x14, \"prf:PreferenceForFrames='No'\"},\n\t{0x15, \"prf:TablesCapable='Yes'\"},\n\t{0x16, \"prf:TablesCapable='No'\"},\n\t{0x17, \"prf:XhtmlVersion\"},\n\t{0x18, \"prf:XhtmlModules\"},\n\t{0x19, \"prf:BrowserName\"},\n\t{0x1A, \"prf:BrowserVersion\"},\n\n\t{ 0x00, NULL }\n};\n\n/* CodePage\t3\tPushCharacteristics */\nstatic const value_string  wbxml_uaprof_attrStart_cp3[] = {\n\t{0x05, \"prf:Push-Accept\"},\n\t{0x06, \"prf:Push-Accept-Charset\"},\n\t{0x07, \"prf:Push-Accept-Encoding\"},\n\t{0x08, \"prf:Push-Accept-Language\"},\n\t{0x09, \"prf:Push-Accept-AppID\"},\n\t{0x0A, \"prf:Push-MsgSize\"},\n\t{0x0B, \"prf:Push-MaxPushReq\"},\n\n\t{ 0x00, NULL }\n};\n\n/*****    Attribute Value tokens   *****/\n/* CodePage\t0\tRDF */\nstatic const value_string  wbxml_uaprof_attrValue_cp0[] = {\n\t{0x85, \"rdf:Statement\"},\n\t{0x86, \"http://\"},\n\t{0x87, \"http://www.\"},\n\t{0x88, \"https://\"},\n\t{0x89, \"https://www.\"},\n\t{0x8A, \"www.\"},\n\t{0x8B, \".com/\"},\n\t{0x8C, \".edu/\"},\n\t{0x8D, \".net/\"},\n\t{0x8E, \".org/\"},\n\n\t{ 0x00, NULL }\n};\n\n/* CodePage\t1\tCoreVocabularyAttrValue */\nstatic const value_string  wbxml_uaprof_attrValue_cp1[] = {\n\t{0x85, \"No\"},\n\t{0x86, \"Yes\"},\n\n\t{ 0x00, NULL }\n};\n\n/* CodePage\t2\tBrowserUAAttrValue */\nstatic const value_string  wbxml_uaprof_attrValue_cp2[] = {\n\t{0x85, \"No\"},\n\t{0x86, \"Yes\"},\n\n\t{ 0x00, NULL }\n};\n\n/***** Token code page aggregation *****/\nstatic const value_valuestring wbxml_uaprof_tags[] = {\n\t{ 0, wbxml_uaprof_tags_cp0 },\n\t{ 1, wbxml_uaprof_tags_cp1 },\n\t{ 2, wbxml_uaprof_tags_cp2 },\n\t{ 3, wbxml_uaprof_tags_cp3 },\n\t{ 4, wbxml_uaprof_tags_cp4 },\n\t{ 0, NULL }\n};\n\nstatic const value_valuestring wbxml_uaprof_attrStart[] = {\n\t{ 0, wbxml_uaprof_attrStart_cp0 },\n\t{ 1, wbxml_uaprof_attrStart_cp1 },\n\t{ 2, wbxml_uaprof_attrStart_cp2 },\n\t{ 3, wbxml_uaprof_attrStart_cp3 },\n\t{ 0, NULL }\n};\n\nstatic const value_valuestring wbxml_uaprof_attrValue[] = {\n\t{ 0, wbxml_uaprof_attrValue_cp0 },\n\t{ 1, wbxml_uaprof_attrValue_cp1 },\n\t{ 2, wbxml_uaprof_attrValue_cp2 },\n\t{ 0, NULL }\n};\n\nstatic const wbxml_decoding decode_uaprof_wap_248 = {\n\t\"User-Agent Profile (WAP-174, WAP-248)\",\n\t\"UAProf (WAP-174, WAP-248)\",\n\t{ NULL, NULL, NULL },\n\tdefault_opaque_binary_tag,\n\tdefault_opaque_literal_tag,\n\tdefault_opaque_binary_attr,\n\tdefault_opaque_literal_attr,\n\tNULL,\n\twbxml_uaprof_tags,\n\twbxml_uaprof_attrStart,\n\twbxml_uaprof_attrValue\n};\n\n\n\n\n\n/* WV-CSP 1.0\n *\n * Wireless Village Client Server Protocol\n ***************************************/\n\n/*****   Global extension tokens   *****/\n\n/*****         Tag tokens          *****/\n/* Common code page (0x00) */\nstatic const value_string wbxml_wv_csp_10_tags_cp0[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"Acceptance\" },\n\t{ 0x06, \"AddList\" },\n\t{ 0x07, \"AddNickList\" },\n\t{ 0x08, \"Attribute\" },\n\t{ 0x09, \"AttributeList\" },\n\t{ 0x0A, \"ClientID\" },\n\t{ 0x0B, \"Code\" },\n\t{ 0x0C, \"ContactList\" },\n\t{ 0x0D, \"ContentData\" },\n\t{ 0x0E, \"ContentEncoding\" },\n\t{ 0x0F, \"ContentSize\" },\n\t{ 0x10, \"ContentType\" },\n\t{ 0x11, \"DateTime\" },\n\t{ 0x12, \"Description\" },\n\t{ 0x13, \"DetailedResult\" },\n\t{ 0x14, \"EntityList\" },\n\t{ 0x15, \"Group\" },\n\t{ 0x16, \"GroupID\" },\n\t{ 0x17, \"GroupList\" },\n\t{ 0x18, \"InUse\" },\n\t{ 0x19, \"Logo\" },\n\t{ 0x1A, \"MessageCount\" },\n\t{ 0x1B, \"MessageID\" },\n\t{ 0x1C, \"MessageURI\" },\n\t{ 0x1D, \"MSISDN\" },\n\t{ 0x1E, \"Name\" },\n\t{ 0x1F, \"NickList\" },\n\t{ 0x20, \"NickName\" },\n\t{ 0x21, \"Poll\" },\n\t{ 0x22, \"Presence\" },\n\t{ 0x23, \"PresenceSubList\" },\n\t{ 0x24, \"PresenceValue\" },\n\t{ 0x25, \"Property\" },\n\t{ 0x26, \"Qualifier\" },\n\t{ 0x27, \"Recipient\" },\n\t{ 0x28, \"RemoveList\" },\n\t{ 0x29, \"RemoveNickList\" },\n\t{ 0x2A, \"Result\" },\n\t{ 0x2B, \"ScreenName\" },\n\t{ 0x2C, \"Sender\" },\n\t{ 0x2D, \"Session\" },\n\t{ 0x2E, \"SessionDescriptor\" },\n\t{ 0x2F, \"SessionID\" },\n\t{ 0x30, \"SessionType\" },\n\t{ 0x31, \"Status\" },\n\t{ 0x32, \"Transaction\" },\n\t{ 0x33, \"TransactionContent\" },\n\t{ 0x34, \"TransactionDescriptor\" },\n\t{ 0x35, \"TransactionID\" },\n\t{ 0x36, \"TransactionMode\" },\n\t{ 0x37, \"URL\" },\n\t{ 0x38, \"URLList\" },\n\t{ 0x39, \"User\" },\n\t{ 0x3A, \"UserID\" },\n\t{ 0x3B, \"UserList\" },\n\t{ 0x3C, \"Validity\" },\n\t{ 0x3D, \"Value\" },\n\t{ 0x3E, \"WV-CSP-Message\" },\n\n\t{ 0x00, NULL }\n};\n\n/* Access code page (0x01) */\nstatic const value_string wbxml_wv_csp_10_tags_cp1[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"AllFunctions\" },\n\t{ 0x06, \"AllFunctionsRequest\" },\n\t{ 0x07, \"CancelInvite-Request\" },\n\t{ 0x08, \"CancelInviteUser-Request\" },\n\t{ 0x09, \"Capability\" },\n\t{ 0x0A, \"CapabilityList\" },\n\t{ 0x0B, \"CapabilityRequest\" },\n\t{ 0x0C, \"ClientCapability-Request\" },\n\t{ 0x0D, \"ClientCapability-Response\" },\n\t{ 0x0E, \"DigestBytes\" },\n\t{ 0x0F, \"DigestSchema\" },\n\t{ 0x10, \"Disconnect\" },\n\t{ 0x11, \"Functions\" },\n\t{ 0x12, \"GetSPInfo-Request\" },\n\t{ 0x13, \"GetSPInfo-Response\" },\n\t{ 0x14, \"InviteID\" },\n\t{ 0x15, \"InviteNote\" },\n\t{ 0x16, \"Invite-Request\" },\n\t{ 0x17, \"Invite-Response\" },\n\t{ 0x18, \"InviteType\" },\n\t{ 0x19, \"InviteUser-Request\" },\n\t{ 0x1A, \"InviteUser-Response\" },\n\t{ 0x1B, \"KeepAlive-Request\" },\n\t{ 0x1C, \"KeepAliveTime\" },\n\t{ 0x1D, \"Login-Request\" },\n\t{ 0x1E, \"Login-Response\" },\n\t{ 0x1F, \"Logout-Request\" },\n\t{ 0x20, \"Nonce\" },\n\t{ 0x21, \"Password\" },\n\t{ 0x22, \"Polling-Request\" },\n\t{ 0x23, \"ResponseNote\" },\n\t{ 0x24, \"SearchElement\" },\n\t{ 0x25, \"SearchFindings\" },\n\t{ 0x26, \"SearchID\" },\n\t{ 0x27, \"SearchIndex\" },\n\t{ 0x28, \"SearchLimit\" },\n\t{ 0x29, \"SearchOnlineStatus\" },\n\t{ 0x2A, \"SearchPairList\" },\n\t{ 0x2B, \"Search-Request\" },\n\t{ 0x2C, \"Search-Response\" },\n\t{ 0x2D, \"SearchResult\" },\n\t{ 0x2E, \"Service-Request\" },\n\t{ 0x2F, \"Service-Response\" },\n\t{ 0x30, \"SessionCookie\" },\n\t{ 0x31, \"StopSearch-Request\" },\n\t{ 0x32, \"TimeToLive\" },\n\n\t{ 0x00, NULL }\n};\n\n/* Service code page (0x02) */\nstatic const value_string wbxml_wv_csp_10_tags_cp2[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"ADDGM\" },\n\t{ 0x06, \"AttListFunc\" },\n\t{ 0x07, \"BLENT\" },\n\t{ 0x08, \"CAAUT\" },\n\t{ 0x09, \"CAINV\" },\n\t{ 0x0A, \"CALI\" },\n\t{ 0x0B, \"CCLI\" },\n\t{ 0x0C, \"ContListFunc\" },\n\t{ 0x0D, \"CREAG\" },\n\t{ 0x0E, \"DALI\" },\n\t{ 0x0F, \"DCLI\" },\n\t{ 0x10, \"DELGR\" },\n\t{ 0x11, \"FundamentalFeat\" },\n\t{ 0x12, \"FWMSG\" },\n\t{ 0x13, \"GALS\" },\n\t{ 0x14, \"GCLI\" },\n\t{ 0x15, \"GETGM\" },\n\t{ 0x16, \"GETGP\" },\n\t{ 0x17, \"GETLM\" },\n\t{ 0x18, \"GETM\" },\n\t{ 0x19, \"GETPR\" },\n\t{ 0x1A, \"GETSPI\" },\n\t{ 0x1B, \"GETWL\" },\n\t{ 0x1C, \"GLBLU\" },\n\t{ 0x1D, \"GRCHN\" },\n\t{ 0x1E, \"GroupAuthFunc\" },\n\t{ 0x1F, \"GroupFeat\" },\n\t{ 0x20, \"GroupMgmtFunc\" },\n\t{ 0x21, \"GroupUseFunc\" },\n\t{ 0x22, \"IMAuthFunc\" },\n\t{ 0x23, \"IMFeat\" },\n\t{ 0x24, \"IMReceiveFunc\" },\n\t{ 0x25, \"IMSendFunc\" },\n\t{ 0x26, \"INVIT\" },\n\t{ 0x27, \"InviteFunc\" },\n\t{ 0x28, \"MBRAC\" },\n\t{ 0x29, \"MCLS\" },\n\t{ 0x2A, \"MDELIV\" },\n\t{ 0x2B, \"NEWM\" },\n\t{ 0x2C, \"NOTIF\" },\n\t{ 0x2D, \"PresenceAuthFunc\" },\n\t{ 0x2E, \"PresenceDeliverFunc\" },\n\t{ 0x2F, \"PresenceFeat\" },\n\t{ 0x30, \"REACT\" },\n\t{ 0x31, \"REJCM\" },\n\t{ 0x32, \"REJEC\" },\n\t{ 0x33, \"RMVGM\" },\n\t{ 0x34, \"SearchFunc\" },\n\t{ 0x35, \"ServiceFunc\" },\n\t{ 0x36, \"SETD\" },\n\t{ 0x37, \"SETGP\" },\n\t{ 0x38, \"SRCH\" },\n\t{ 0x39, \"STSRC\" },\n\t{ 0x3A, \"SUBGCN\" },\n\t{ 0x3B, \"UPDPR\" },\n\t{ 0x3C, \"WVCSPFeat\" },\n\n\t{ 0x00, NULL }\n};\n\n/* Client capability code page (0x03) */\nstatic const value_string wbxml_wv_csp_10_tags_cp3[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"AcceptedCharset\" },\n\t{ 0x06, \"AcceptedContentLength\" },\n\t{ 0x07, \"AcceptedContentType\" },\n\t{ 0x08, \"AcceptedTransferEncoding\" },\n\t{ 0x09, \"AnyContent\" },\n\t{ 0x0A, \"ClientType\" },\n\t{ 0x0B, \"InitialDeliveryMethod\" },\n\t{ 0x0C, \"MultiTrans\" },\n\t{ 0x0D, \"ParserSize\" },\n\t{ 0x0E, \"ServerPollMin\" },\n\t{ 0x0F, \"SupportedBearer\" },\n\t{ 0x10, \"SupportedCIRMethod\" },\n\t{ 0x11, \"TCPAddress\" },\n\t{ 0x12, \"TCPPort\" },\n\t{ 0x13, \"UDPPort\" },\n\n\t{ 0x00, NULL }\n};\n\n/* Presence primitive code page (0x04) */\nstatic const value_string wbxml_wv_csp_10_tags_cp4[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"CancelAuth-Request\" },\n\t{ 0x06, \"ContactListProperties\" },\n\t{ 0x07, \"CreateAttributeList-Request\" },\n\t{ 0x08, \"CreateList-Request\" },\n\t{ 0x09, \"DefaultAttributeList\" },\n\t{ 0x0A, \"DefaultContactList\" },\n\t{ 0x0B, \"DefaultList\" },\n\t{ 0x0C, \"DeleteAttributeList-Request\" },\n\t{ 0x0D, \"DeleteList-Request\" },\n\t{ 0x0E, \"GetAttributeList-Request\" },\n\t{ 0x0F, \"GetAttributeList-Response\" },\n\t{ 0x10, \"GetList-Request\" },\n\t{ 0x11, \"GetList-Response\" },\n\t{ 0x12, \"GetPresence-Request\" },\n\t{ 0x13, \"GetPresence-Response\" },\n\t{ 0x14, \"GetWatcherList-Request\" },\n\t{ 0x15, \"GetWatcherList-Response\" },\n\t{ 0x16, \"ListManage-Request\" },\n\t{ 0x17, \"ListManage-Response\" },\n\t{ 0x18, \"Presence\" },\n\t{ 0x19, \"PresenceAuth-Request\" },\n\t{ 0x1A, \"PresenceAuth-Response\" },\n\t{ 0x1B, \"PresenceNotification-Request\" },\n\t{ 0x1C, \"PresenceValueList\" },\n\t{ 0x1D, \"SubscribePresence-Request\" },\n\t{ 0x1E, \"UnsubscribePresence-Request\" },\n\t{ 0x1F, \"UpdatePresence-Request\" },\n\n\t{ 0x00, NULL }\n};\n\n/* Presence attribute code page (0x05) */\nstatic const value_string wbxml_wv_csp_10_tags_cp5[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"Accuracy\" },\n\t{ 0x06, \"Address\" },\n\t{ 0x07, \"AddrPref\" },\n\t{ 0x08, \"Alias\" },\n\t{ 0x09, \"Altitude\" },\n\t{ 0x0A, \"Building\" },\n\t{ 0x0B, \"CAddr\" },\n\t{ 0x0C, \"City\" },\n\t{ 0x0D, \"ClientInfo\" },\n\t{ 0x0E, \"ClientProducer\" },\n\t{ 0x0F, \"ClientType\" },\n\t{ 0x10, \"ClientVersion\" },\n\t{ 0x11, \"CommC\" },\n\t{ 0x12, \"CommCap\" },\n\t{ 0x13, \"ContactInfo\" },\n\t{ 0x14, \"ContainedvCard\" },\n\t{ 0x15, \"Country\" },\n\t{ 0x16, \"Crossing1\" },\n\t{ 0x17, \"Crossing2\" },\n\t{ 0x18, \"DevManufacturer\" },\n\t{ 0x19, \"DirectContent\" },\n\t{ 0x1A, \"FreeTextLocation\" },\n\t{ 0x1B, \"GeoLocation\" },\n\t{ 0x1C, \"Language\" },\n\t{ 0x1D, \"Latitude\" },\n\t{ 0x1E, \"Longitude\" },\n\t{ 0x1F, \"Model\" },\n\t{ 0x20, \"NamedArea\" },\n\t{ 0x21, \"OnlineStatus\" },\n\t{ 0x22, \"PLMN\" },\n\t{ 0x23, \"PrefC\" },\n\t{ 0x24, \"PreferredContacts\" },\n\t{ 0x25, \"PreferredLanguage\" },\n\t{ 0x26, \"ReferredContent\" },\n\t{ 0x27, \"ReferredvCard\" },\n\t{ 0x28, \"Registration\" },\n\t{ 0x29, \"StatusContent\" },\n\t{ 0x2A, \"StatusMood\" },\n\t{ 0x2B, \"StatusText\" },\n\t{ 0x2C, \"Street\" },\n\t{ 0x2D, \"TimeZone\" },\n\t{ 0x2E, \"UserAvailability\" },\n\n\t{ 0x00, NULL }\n};\n\n/* Messaging code page (0x06) */\nstatic const value_string wbxml_wv_csp_10_tags_cp6[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"BlockList\" },\n\t{ 0x06, \"BlockUser-Request\" },\n\t{ 0x07, \"DeliveryMethod\" },\n\t{ 0x08, \"DeliveryReport\" },\n\t{ 0x09, \"DeliveryReport-Request\" },\n\t{ 0x0A, \"ForwardMessage-Request\" },\n\t{ 0x0B, \"GetBlockedList-Request\" },\n\t{ 0x0C, \"GetBlockedList-Response\" },\n\t{ 0x0D, \"GetMessageList-Request\" },\n\t{ 0x0E, \"GetMessageList-Response\" },\n\t{ 0x0F, \"GetMessage-Request\" },\n\t{ 0x10, \"GetMessage-Response\" },\n\t{ 0x11, \"GrantList\" },\n\t{ 0x12, \"MessageDelivered\" },\n\t{ 0x13, \"MessageInfo\" },\n\t{ 0x14, \"MessageNotification\" },\n\t{ 0x15, \"NewMessage\" },\n\t{ 0x16, \"RejectMessage-Request\" },\n\t{ 0x17, \"SendMessage-Request\" },\n\t{ 0x18, \"SendMessage-Response\" },\n\t{ 0x19, \"SetDeliveryMethod-Request\" },\n\n\t{ 0x00, NULL }\n};\n\n/* Group code page (0x07) */\nstatic const value_string wbxml_wv_csp_10_tags_cp7[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"AddGroupMembers-Request\" },\n\t{ 0x06, \"Admin\" },\n\t{ 0x07, \"CreateGroup-Request\" },\n\t{ 0x08, \"DeleteGroup-Request\" },\n\t{ 0x09, \"GetGroupMembers-Request\" },\n\t{ 0x0A, \"GetGroupMembers-Response\" },\n\t{ 0x0B, \"GetGroupProps-Request\" },\n\t{ 0x0C, \"GetGroupProps-Response\" },\n\t{ 0x0D, \"GroupChangeNotice\" },\n\t{ 0x0E, \"GroupProperties\" },\n\t{ 0x0F, \"Joined\" },\n\t{ 0x10, \"JoinedRequest\" },\n\t{ 0x11, \"JoinGroup-Request\" },\n\t{ 0x12, \"JoinGroup-Response\" },\n\t{ 0x13, \"LeaveGroup-Request\" },\n\t{ 0x14, \"LeaveGroup-Response\" },\n\t{ 0x15, \"Left\" },\n\t{ 0x16, \"MemberAccess-Request\" },\n\t{ 0x17, \"Mod\" },\n\t{ 0x18, \"OwnProperties\" },\n\t{ 0x19, \"RejectList-Request\" },\n\t{ 0x1A, \"RejectList-Response\" },\n\t{ 0x1B, \"RemoveGroupMembers-Request\" },\n\t{ 0x1C, \"SetGroupProps-Request\" },\n\t{ 0x1D, \"SubscribeGroupNotice-Request\" },\n\t{ 0x1E, \"SubscribeGroupNotice-Response\" },\n\t{ 0x1F, \"Users\" },\n\t{ 0x20, \"WelcomeNote\" },\n\n\t{ 0x00, NULL }\n};\n\n/*\n * Attribute start tokens\n */\n/* common code page (0x00) */\nstatic const value_string wbxml_wv_csp_10_attrStart_cp0[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"xmlns='http://www.wireless-village.org/CSP'\" },\n\t{ 0x06, \"xmlns='http://www.wireless-village.org/PA'\" },\n\t{ 0x07, \"xmlns='http://www.wireless-village.org/TRC'\" },\n\n\t{ 0x00, NULL }\n};\n\n/*\n * Attribute value tokens\n */\n/* Common value tokens (0x00) */\nstatic const value_string wbxml_wv_csp_10_attrValue_cp0[] = {\n\t/* 0x80 -- 0x84 GLOBAL */\n\t{ 0x85, \"AccessType\" },\n\t{ 0x86, \"ActiveUsers\" },\n\t{ 0x87, \"Admin\" },\n\t{ 0x88, \"application/\" },\n\t{ 0x89, \"application/vnd.wap.mms-message\" },\n\t{ 0x8A, \"application/x-sms\" },\n\t{ 0x8B, \"BASE64\" },\n\t{ 0x8C, \"Closed\" },\n\t{ 0x8D, \"Default\" },\n\t{ 0x8E, \"DisplayName\" },\n\t{ 0x8F, \"False (No)\" },\n\t{ 0x90, \"Get\" },\n\t{ 0x91, \"Group (GR)\" },\n\t{ 0x92, \"http://\" },\n\t{ 0x93, \"https://\" },\n\t{ 0x94, \"image/\" },\n\t{ 0x95, \"Inband\" },\n\t{ 0x96, \"Instant Messaging (IM)\" },\n\t{ 0x97, \"MaxActiveUsers\" },\n\t{ 0x98, \"Mod\" },\n\t{ 0x99, \"Name\" },\n\t{ 0x9A, \"None\" },\n\t{ 0x9B, \"Notify/Get\" },\n\t{ 0x9C, \"Open\" },\n\t{ 0x9D, \"Outband\" },\n\t{ 0x9E, \"Presence (PR)\" },\n\t{ 0x9F, \"Private\" },\n\t{ 0xA0, \"PrivateMessaging\" },\n\t{ 0xA1, \"PrivilegeLevel\" },\n\t{ 0xA2, \"Public\" },\n\t{ 0xA3, \"Push\" },\n\t{ 0xA4, \"Request\" },\n\t{ 0xA5, \"Response\" },\n\t{ 0xA6, \"ScreenName\" },\n\t{ 0xA7, \"Searchable\" },\n\t{ 0xA8, \"Set\" },\n\t{ 0xA9, \"Shared Content (SC)\" },\n\t{ 0xAA, \"text/\" },\n\t{ 0xAB, \"text/plain\" },\n\t{ 0xAC, \"text/x-vCalendar\" },\n\t{ 0xAD, \"text/x-vCard\" },\n\t{ 0xAE, \"Topic\" },\n\t{ 0xAF, \"True (Yes)\" },\n\t{ 0xB0, \"Type\" },\n\t{ 0xB1, \"Unset\" },\n\t{ 0xB2, \"User (US)\" },\n\t{ 0xB3, \"www.wireless-village.org\" },\n\n\t{ 0x00, NULL }\n};\n\n/* Access value tokens (0x01) */\nstatic const value_string wbxml_wv_csp_10_attrValue_cp1[] = {\n\t/* 0x80 -- 0x84 GLOBAL */\n\t{ 0x85, \"GROUP_ID\" },\n\t{ 0x86, \"GROUP_NAME\" },\n\t{ 0x87, \"GROUP_TOPIC\" },\n\t{ 0x88, \"GROUP_USER_ID_JOINED\" },\n\t{ 0x89, \"HTTP\" },\n\t{ 0x8A, \"SMS\" },\n\t{ 0x8B, \"STCP\" },\n\t{ 0x8C, \"SUDP\" },\n\t{ 0x8D, \"USER_ALIAS\" },\n\t{ 0x8E, \"USER_EMAIL_ADDRESS\" },\n\t{ 0x8F, \"USER_FIRST_NAME\" },\n\t{ 0x90, \"USER_ID\" },\n\t{ 0x91, \"USER_LAST_NAME\" },\n\t{ 0x92, \"USER_MOBILE_NUMBER\" },\n\t{ 0x93, \"WAPSMS\" },\n\t{ 0x94, \"WAPUDP\" },\n\t{ 0x95, \"WSP\" },\n\n\t{ 0x00, NULL }\n};\n\n/* Presence value tokens (0x05) */\nstatic const value_string wbxml_wv_csp_10_attrValue_cp5[] = {\n\t/* 0x80 -- 0x84 GLOBAL */\n\t{ 0x85, \"ANGRY\" },\n\t{ 0x86, \"ANXIOUS\" },\n\t{ 0x87, \"ASHAMED\" },\n\t{ 0x88, \"AUDIO_CALL\" },\n\t{ 0x89, \"AVAILABLE\" },\n\t{ 0x8A, \"BORED\" },\n\t{ 0x8B, \"CALL\" },\n\t{ 0x8C, \"CLI\" },\n\t{ 0x8D, \"COMPUTER\" },\n\t{ 0x8E, \"DISCREET\" },\n\t{ 0x8F, \"EMAIL\" },\n\t{ 0x90, \"EXCITED\" },\n\t{ 0x91, \"HAPPY\" },\n\t{ 0x92, \"IM\" },\n\t{ 0x93, \"IM_OFFLINE\" },\n\t{ 0x94, \"IM_ONLINE\" },\n\t{ 0x95, \"IN_LOVE\" },\n\t{ 0x96, \"INVINCIBLE\" },\n\t{ 0x97, \"JEALOUS\" },\n\t{ 0x98, \"MMS\" },\n\t{ 0x99, \"MOBILE_PHONE\" },\n\t{ 0x9A, \"NOT_AVAILABLE\" },\n\t{ 0x9B, \"OTHER\" },\n\t{ 0x9C, \"PDA\" },\n\t{ 0x9D, \"SAD\" },\n\t{ 0x9E, \"SLEEPY\" },\n\t{ 0x9F, \"SMS\" },\n\t{ 0xA0, \"VIDEO_CALL\" },\n\t{ 0xA1, \"VIDEO_STREAM\" },\n\n\t{ 0x00, NULL }\n};\n\n\n/***** Token code page aggregation *****/\nstatic const value_valuestring wbxml_wv_csp_10_tags[] = {\n\t{ 0, wbxml_wv_csp_10_tags_cp0 },\n\t{ 1, wbxml_wv_csp_10_tags_cp1 },\n\t{ 2, wbxml_wv_csp_10_tags_cp2 },\n\t{ 3, wbxml_wv_csp_10_tags_cp3 },\n\t{ 4, wbxml_wv_csp_10_tags_cp4 },\n\t{ 5, wbxml_wv_csp_10_tags_cp5 },\n\t{ 6, wbxml_wv_csp_10_tags_cp6 },\n\t{ 7, wbxml_wv_csp_10_tags_cp7 },\n\t{ 0, NULL }\n};\n\nstatic const value_valuestring wbxml_wv_csp_10_attrStart[] = {\n\t{ 0, wbxml_wv_csp_10_attrStart_cp0 },\n\t{ 0, NULL }\n};\n\nstatic const value_valuestring wbxml_wv_csp_10_attrValue[] = {\n\t{ 0, wbxml_wv_csp_10_attrValue_cp0 },\n\t{ 1, wbxml_wv_csp_10_attrValue_cp1 },\n\t{ 5, wbxml_wv_csp_10_attrValue_cp5 },\n\t{ 0, NULL }\n};\n\nstatic const wbxml_decoding decode_wv_cspc_10 = {\n\t\"Wireless-Village Client-Server Protocol 1.0\",\n\t\"WV-CSP 1.0\",\n\t{ NULL, NULL, NULL },\n\twv_csp10_opaque_binary_tag,\n\twv_csp10_opaque_literal_tag,\n\tdefault_opaque_binary_attr,\n\tdefault_opaque_literal_attr,\n\tNULL,\n\twbxml_wv_csp_10_tags,\n\twbxml_wv_csp_10_attrStart,\n\twbxml_wv_csp_10_attrValue\n};\n\n\n\n\n\n/* WV-CSP 1.1\n *\n * Wireless Village Client Server Protocol\n ***************************************/\n\n/*****   Global extension tokens   *****/\nstatic const value_string wbxml_wv_csp_11_global_cp0[] = {\n\t{ 0x80, \"Common Value\" }, /* EXT_T_0 */\n\n\t{ 0x00, NULL }\n};\n\n/*****         Tag tokens          *****/\n/* Common code page */\nstatic const value_string wbxml_wv_csp_11_tags_cp0[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"Acceptance\" },\n\t{ 0x06, \"AddList\" },\n\t{ 0x07, \"AddNickList\" },\n\t{ 0x08, \"SName\" },\t\t/* Was: Attribute */\n\t{ 0x09, \"WV-CSP-Message\" },\t/* Was: AttributeList */\n\t{ 0x0A, \"ClientID\" },\n\t{ 0x0B, \"Code\" },\n\t{ 0x0C, \"ContactList\" },\n\t{ 0x0D, \"ContentData\" },\n\t{ 0x0E, \"ContentEncoding\" },\n\t{ 0x0F, \"ContentSize\" },\n\t{ 0x10, \"ContentType\" },\n\t{ 0x11, \"DateTime\" },\n\t{ 0x12, \"Description\" },\n\t{ 0x13, \"DetailedResult\" },\n\t{ 0x14, \"EntityList\" },\n\t{ 0x15, \"Group\" },\n\t{ 0x16, \"GroupID\" },\n\t{ 0x17, \"GroupList\" },\n\t{ 0x18, \"InUse\" },\n\t{ 0x19, \"Logo\" },\n\t{ 0x1A, \"MessageCount\" },\n\t{ 0x1B, \"MessageID\" },\n\t{ 0x1C, \"MessageURI\" },\n\t{ 0x1D, \"MSISDN\" },\n\t{ 0x1E, \"Name\" },\n\t{ 0x1F, \"NickList\" },\n\t{ 0x20, \"NickName\" },\n\t{ 0x21, \"Poll\" },\n\t{ 0x22, \"Presence\" },\n\t{ 0x23, \"PresenceSubList\" },\n\t{ 0x24, \"PresenceValue\" },\n\t{ 0x25, \"Property\" },\n\t{ 0x26, \"Qualifier\" },\n\t{ 0x27, \"Recipient\" },\n\t{ 0x28, \"RemoveList\" },\n\t{ 0x29, \"RemoveNickList\" },\n\t{ 0x2A, \"Result\" },\n\t{ 0x2B, \"ScreenName\" },\n\t{ 0x2C, \"Sender\" },\n\t{ 0x2D, \"Session\" },\n\t{ 0x2E, \"SessionDescriptor\" },\n\t{ 0x2F, \"SessionID\" },\n\t{ 0x30, \"SessionType\" },\n\t{ 0x31, \"Status\" },\n\t{ 0x32, \"Transaction\" },\n\t{ 0x33, \"TransactionContent\" },\n\t{ 0x34, \"TransactionDescriptor\" },\n\t{ 0x35, \"TransactionID\" },\n\t{ 0x36, \"TransactionMode\" },\n\t{ 0x37, \"URL\" },\n\t{ 0x38, \"URLList\" },\n\t{ 0x39, \"User\" },\n\t{ 0x3A, \"UserID\" },\n\t{ 0x3B, \"UserList\" },\n\t{ 0x3C, \"Validity\" },\n\t{ 0x3D, \"Value\" },\n\t/* 0x3E - Removed: WV-CSP-Message */\n\n\t{ 0x00, NULL }\n};\n\n/* Access code page */\nstatic const value_string wbxml_wv_csp_11_tags_cp1[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"AllFunctions\" },\n\t{ 0x06, \"AllFunctionsRequest\" },\n\t{ 0x07, \"CancelInvite-Request\" },\n\t{ 0x08, \"CancelInviteUser-Request\" },\n\t{ 0x09, \"Capability\" },\n\t{ 0x0A, \"CapabilityList\" },\n\t{ 0x0B, \"CapabilityRequest\" },\n\t{ 0x0C, \"ClientCapability-Request\" },\n\t{ 0x0D, \"ClientCapability-Response\" },\n\t{ 0x0E, \"DigestBytes\" },\n\t{ 0x0F, \"DigestSchema\" },\n\t{ 0x10, \"Disconnect\" },\n\t{ 0x11, \"Functions\" },\n\t{ 0x12, \"GetSPInfo-Request\" },\n\t{ 0x13, \"GetSPInfo-Response\" },\n\t{ 0x14, \"InviteID\" },\n\t{ 0x15, \"InviteNote\" },\n\t{ 0x16, \"Invite-Request\" },\n\t{ 0x17, \"Invite-Response\" },\n\t{ 0x18, \"InviteType\" },\n\t{ 0x19, \"InviteUser-Request\" },\n\t{ 0x1A, \"InviteUser-Response\" },\n\t{ 0x1B, \"KeepAlive-Request\" },\n\t{ 0x1C, \"KeepAliveTime\" },\n\t{ 0x1D, \"Login-Request\" },\n\t{ 0x1E, \"Login-Response\" },\n\t{ 0x1F, \"Logout-Request\" },\n\t{ 0x20, \"Nonce\" },\n\t{ 0x21, \"Password\" },\n\t{ 0x22, \"Polling-Request\" },\n\t{ 0x23, \"ResponseNote\" },\n\t{ 0x24, \"SearchElement\" },\n\t{ 0x25, \"SearchFindings\" },\n\t{ 0x26, \"SearchID\" },\n\t{ 0x27, \"SearchIndex\" },\n\t{ 0x28, \"SearchLimit\" },\n\t{ 0x29, \"KeepAlive-Response\" },\n\t{ 0x2A, \"SearchPairList\" },\n\t{ 0x2B, \"Search-Request\" },\n\t{ 0x2C, \"Search-Response\" },\n\t{ 0x2D, \"SearchResult\" },\n\t{ 0x2E, \"Service-Request\" },\n\t{ 0x2F, \"Service-Response\" },\n\t{ 0x30, \"SessionCookie\" },\n\t{ 0x31, \"StopSearch-Request\" },\n\t{ 0x32, \"TimeToLive\" },\n\t/* New in WV-CSP 1.1 */\n\t{ 0x33, \"SearchString\" },\n\t{ 0x34, \"CompletionFlag\" },\n\n\t{ 0x00, NULL }\n};\n\n/* Service code page */\n/* Same as cp2 of WV-CSP 1.0 */\n#define wbxml_wv_csp_11_tags_cp2 wbxml_wv_csp_10_tags_cp2\n\n/* Client capability code page */\nstatic const value_string wbxml_wv_csp_11_tags_cp3[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"AcceptedCharset\" },\n\t{ 0x06, \"AcceptedContentLength\" },\n\t{ 0x07, \"AcceptedContentType\" },\n\t{ 0x08, \"AcceptedTransferEncoding\" },\n\t{ 0x09, \"AnyContent\" },\n\t{ 0x0A, \"DefaultLanguage\" },\t/* Was: ClientType */\n\t{ 0x0B, \"InitialDeliveryMethod\" },\n\t{ 0x0C, \"MultiTrans\" },\n\t{ 0x0D, \"ParserSize\" },\n\t{ 0x0E, \"ServerPollMin\" },\n\t{ 0x0F, \"SupportedBearer\" },\n\t{ 0x10, \"SupportedCIRMethod\" },\n\t{ 0x11, \"TCPAddress\" },\n\t{ 0x12, \"TCPPort\" },\n\t{ 0x13, \"UDPPort\" },\n\n\t{ 0x00, NULL }\n};\n\n/* Presence primitive code page */\nstatic const value_string wbxml_wv_csp_11_tags_cp4[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"CancelAuth-Request\" },\n\t{ 0x06, \"ContactListProperties\" },\n\t{ 0x07, \"CreateAttributeList-Request\" },\n\t{ 0x08, \"CreateList-Request\" },\n\t{ 0x09, \"DefaultAttributeList\" },\n\t{ 0x0A, \"DefaultContactList\" },\n\t{ 0x0B, \"DefaultList\" },\n\t{ 0x0C, \"DeleteAttributeList-Request\" },\n\t{ 0x0D, \"DeleteList-Request\" },\n\t{ 0x0E, \"GetAttributeList-Request\" },\n\t{ 0x0F, \"GetAttributeList-Response\" },\n\t{ 0x10, \"GetList-Request\" },\n\t{ 0x11, \"GetList-Response\" },\n\t{ 0x12, \"GetPresence-Request\" },\n\t{ 0x13, \"GetPresence-Response\" },\n\t{ 0x14, \"GetWatcherList-Request\" },\n\t{ 0x15, \"GetWatcherList-Response\" },\n\t{ 0x16, \"ListManage-Request\" },\n\t{ 0x17, \"ListManage-Response\" },\n\t{ 0x18, \"UnsubscribePresence-Request\" },\t/* Was: Presence */\n\t{ 0x19, \"PresenceAuth-Request\" },\n\t{ 0x1A, \"PresenceAuth-User\" },\t\t/* Was: PresenceAuth-Response */\n\t{ 0x1B, \"PresenceNotification-Request\" },\n\t{ 0x1C, \"UpdatePresence-Request\" },\t/* Was: PresenceValueList */\n\t{ 0x1D, \"SubscribePresence-Request\" },\n\t/* 0x1E - Removed: UnsubscribePresence-Request */\n\t/* 0x1F - Removed: UpdatePresence-Request */\n\n\t{ 0x00, NULL }\n};\n\n/* Presence attribute code page */\nstatic const value_string wbxml_wv_csp_11_tags_cp5[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"Accuracy\" },\n\t{ 0x06, \"Address\" },\n\t{ 0x07, \"AddrPref\" },\n\t{ 0x08, \"Alias\" },\n\t{ 0x09, \"Altitude\" },\n\t{ 0x0A, \"Building\" },\n\t{ 0x0B, \"Caddr\" },\n\t{ 0x0C, \"City\" },\n\t{ 0x0D, \"ClientInfo\" },\n\t{ 0x0E, \"ClientProducer\" },\n\t{ 0x0F, \"ClientType\" },\n\t{ 0x10, \"ClientVersion\" },\n\t{ 0x11, \"CommC\" },\n\t{ 0x12, \"CommCap\" },\n\t{ 0x13, \"ContactInfo\" },\n\t{ 0x14, \"ContainedvCard\" },\n\t{ 0x15, \"Country\" },\n\t{ 0x16, \"Crossing1\" },\n\t{ 0x17, \"Crossing2\" },\n\t{ 0x18, \"DevManufacturer\" },\n\t{ 0x19, \"DirectContent\" },\n\t{ 0x1A, \"FreeTextLocation\" },\n\t{ 0x1B, \"GeoLocation\" },\n\t{ 0x1C, \"Language\" },\n\t{ 0x1D, \"Latitude\" },\n\t{ 0x1E, \"Longitude\" },\n\t{ 0x1F, \"Model\" },\n\t{ 0x20, \"NamedArea\" },\n\t{ 0x21, \"OnlineStatus\" },\n\t{ 0x22, \"PLMN\" },\n\t{ 0x23, \"PrefC\" },\n\t{ 0x24, \"PreferredContacts\" },\n\t{ 0x25, \"PreferredLanguage\" },\n\t{ 0x26, \"ReferredContent\" },\n\t{ 0x27, \"ReferredvCard\" },\n\t{ 0x28, \"Registration\" },\n\t{ 0x29, \"StatusContent\" },\n\t{ 0x2A, \"StatusMood\" },\n\t{ 0x2B, \"StatusText\" },\n\t{ 0x2C, \"Street\" },\n\t{ 0x2D, \"TimeZone\" },\n\t{ 0x2E, \"UserAvailability\" },\n\t/* New in WV-CSP 1.1 */\n\t{ 0x2F, \"Cap\" },\n\t{ 0x30, \"Cname\" },\n\t{ 0x31, \"Contact\" },\n\t{ 0x32, \"Cpriority\" },\n\t{ 0x33, \"Cstatus\" },\n\t{ 0x34, \"Note\" },\n\t{ 0x35, \"Zone\" },\n\n\t{ 0x00, NULL }\n};\n\n/* Messaging code page */\nstatic const value_string wbxml_wv_csp_11_tags_cp6[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"BlockList\" },\n\t{ 0x06, \"BlockUser-Request\" },\n\t{ 0x07, \"DeliveryMethod\" },\n\t{ 0x08, \"DeliveryReport\" },\n\t{ 0x09, \"DeliveryReport-Request\" },\n\t{ 0x0A, \"ForwardMessage-Request\" },\n\t{ 0x0B, \"GetBlockedList-Request\" },\n\t{ 0x0C, \"GetBlockedList-Response\" },\n\t{ 0x0D, \"GetMessageList-Request\" },\n\t{ 0x0E, \"GetMessageList-Response\" },\n\t{ 0x0F, \"GetMessage-Request\" },\n\t{ 0x10, \"GetMessage-Response\" },\n\t{ 0x11, \"GrantList\" },\n\t{ 0x12, \"MessageDelivered\" },\n\t{ 0x13, \"MessageInfo\" },\n\t{ 0x14, \"MessageNotification\" },\n\t{ 0x15, \"NewMessage\" },\n\t{ 0x16, \"RejectMessage-Request\" },\n\t{ 0x17, \"SendMessage-Request\" },\n\t{ 0x18, \"SendMessage-Response\" },\n\t{ 0x19, \"SetDeliveryMethod-Request\" },\n\t/* New in WV-CSP 1.1 */\n\t{ 0x1A, \"DeliveryTime\" },\n\n\t{ 0x00, NULL }\n};\n\n/* Group code page */\nstatic const value_string wbxml_wv_csp_11_tags_cp7[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"AddGroupMembers-Request\" },\n\t{ 0x06, \"Admin\" },\n\t{ 0x07, \"CreateGroup-Request\" },\n\t{ 0x08, \"DeleteGroup-Request\" },\n\t{ 0x09, \"GetGroupMembers-Request\" },\n\t{ 0x0A, \"GetGroupMembers-Response\" },\n\t{ 0x0B, \"GetGroupProps-Request\" },\n\t{ 0x0C, \"GetGroupProps-Response\" },\n\t{ 0x0D, \"GroupChangeNotice\" },\n\t{ 0x0E, \"GroupProperties\" },\n\t{ 0x0F, \"Joined\" },\n\t{ 0x10, \"JoinedRequest\" },\n\t{ 0x11, \"JoinGroup-Request\" },\n\t{ 0x12, \"JoinGroup-Response\" },\n\t{ 0x13, \"LeaveGroup-Request\" },\n\t{ 0x14, \"LeaveGroup-Response\" },\n\t{ 0x15, \"Left\" },\n\t{ 0x16, \"MemberAccess-Request\" },\n\t{ 0x17, \"Mod\" },\n\t{ 0x18, \"OwnProperties\" },\n\t{ 0x19, \"RejectList-Request\" },\n\t{ 0x1A, \"RejectList-Response\" },\n\t{ 0x1B, \"RemoveGroupMembers-Request\" },\n\t{ 0x1C, \"SetGroupProps-Request\" },\n\t{ 0x1D, \"SubscribeGroupNotice-Request\" },\n\t{ 0x1E, \"SubscribeGroupNotice-Response\" },\n\t{ 0x1F, \"Users\" },\n\t{ 0x20, \"WelcomeNote\" },\n\t/* New in WV-CSP 1.1 */\n\t{ 0x21, \"JoinGroup\" },\n\t{ 0x22, \"SubscribeNotification\" },\n\t{ 0x23, \"SubscribeType\" },\n\n\t{ 0x00, NULL }\n};\n\n/*****    Attribute Start tokens   *****/\n/* Common code page */\n/* Same as cp0 of WV-CSP 1.0 */\n#define wbxml_wv_csp_11_attrStart_cp0 wbxml_wv_csp_10_attrStart_cp0\n\n/*****    Attribute Value tokens   *****/\n/*\n * Element value tokens\n *\n * NOTE - WV-CSP uses the EXT_T_0 token in a peculiar way: the mb_u_int32\n * does *not* reference an offset in the string table, but it refers to\n * the index in the following value_string.\n *\n * Please note that:\n *  - Values 'T' and 'F' are Boolean values representing \"True\" and \"False\"\n *    (or \"Yes\" and \"No\" in some circumstances) respectively.\n *  - Values 'GR', 'IM', 'PR', 'SC', 'GM' and 'US' are enumerated values\n *    representing \"Group\", \"Instant Messaging\", \"Presence\", \"Shared Content\",\n *    \"Group membership\" and \"User\" respectively.\n *  - Values 'G', 'S' and 'U' are enumerated values representing \"Get\", \"Set\"\n *    and \"Unset\" respectively.\n *  - Values 'N' and 'P' are enumerated values representing \"Notify/Get\" and\n *    \"Push\" respectively.\n *\n * I repeat: this is NOT a attrValue[] array hence it is not called\n * wbxml_wv_XXX but vals_wv_XXX.\n *\n * Result: the attribute value token definitions from WV-CSP 1.0 are dropped.\n */\nstatic const value_string vals_wv_csp_11_element_value_tokens[] = {\n\t/*\n\t * Common value tokens\n\t */\n\t{ 0x00, \"AccessType\" },\n\t{ 0x01, \"ActiveUsers\" },\n\t{ 0x02, \"Admin\" },\n\t{ 0x03, \"application/\" },\n\t{ 0x04, \"application/vnd.wap.mms-message\" },\n\t{ 0x05, \"application/x-sms\" },\n\t{ 0x06, \"AutoJoin\" },\n\t{ 0x07, \"BASE64\" },\n\t{ 0x08, \"Closed\" },\n\t{ 0x09, \"Default\" },\n\t{ 0x0A, \"DisplayName\" },\n\t{ 0x0B, \"F\" },\n\t{ 0x0C, \"G\" },\n\t{ 0x0D, \"GR\" },\n\t{ 0x0E, \"http://\" },\n\t{ 0x0F, \"https://\" },\n\t{ 0x10, \"image/\" },\n\t{ 0x11, \"Inband\" },\n\t{ 0x12, \"IM\" },\n\t{ 0x13, \"MaxActiveUsers\" },\n\t{ 0x14, \"Mod\" },\n\t{ 0x15, \"Name\" },\n\t{ 0x16, \"None\" },\n\t{ 0x17, \"N\" },\n\t{ 0x18, \"Open\" },\n\t{ 0x19, \"Outband\" },\n\t{ 0x1A, \"PR\" },\n\t{ 0x1B, \"Private\" },\n\t{ 0x1C, \"PrivateMessaging\" },\n\t{ 0x1D, \"PrivilegeLevel\" },\n\t{ 0x1E, \"Public\" },\n\t{ 0x1F, \"P\" },\n\t{ 0x20, \"Request\" },\n\t{ 0x21, \"Response\" },\n\t{ 0x22, \"Restricted\" },\n\t{ 0x23, \"ScreenName\" },\n\t{ 0x24, \"Searchable\" },\n\t{ 0x25, \"S\" },\n\t{ 0x26, \"SC\" },\n\t{ 0x27, \"text/\" },\n\t{ 0x28, \"text/plain\" },\n\t{ 0x29, \"text/x-vCalendar\" },\n\t{ 0x2A, \"text/x-vCard\" },\n\t{ 0x2B, \"Topic\" },\n\t{ 0x2C, \"T\" },\n\t{ 0x2D, \"Type\" },\n\t{ 0x2E, \"U\" },\n\t{ 0x2F, \"US\" },\n\t{ 0x30, \"www.wireless-village.org\" },\n\t/*\n\t * Access value tokens\n\t */\n\t{ 0x3D, \"GROUP_ID\" },\n\t{ 0x3E, \"GROUP_NAME\" },\n\t{ 0x3F, \"GROUP_TOPIC\" },\n\t{ 0x40, \"GROUP_USER_ID_JOINED\" },\n\t{ 0x41, \"GROUP_USER_ID_OWNER\" },\n\t{ 0x42, \"HTTP\" },\n\t{ 0x43, \"SMS\" },\n\t{ 0x44, \"STCP\" },\n\t{ 0x45, \"SUDP\" },\n\t{ 0x46, \"USER_ALIAS\" },\n\t{ 0x47, \"USER_EMAIL_ADDRESS\" },\n\t{ 0x48, \"USER_FIRST_NAME\" },\n\t{ 0x49, \"USER_ID\" },\n\t{ 0x4A, \"USER_LAST_NAME\" },\n\t{ 0x4B, \"USER_MOBILE_NUMBER\" },\n\t{ 0x4C, \"USER_ONLINE_STATUS\" },\n\t{ 0x4D, \"WAPSMS\" },\n\t{ 0x4E, \"WAPUDP\" },\n\t{ 0x4F, \"WSP\" },\n\t/*\n\t * Presence value tokens\n\t */\n\t{ 0x5B, \"ANGRY\" },\n\t{ 0x5C, \"ANXIOUS\" },\n\t{ 0x5D, \"ASHAMED\" },\n\t{ 0x5E, \"AUDIO_CALL\" },\n\t{ 0x5F, \"AVAILABLE\" },\n\t{ 0x60, \"BORED\" },\n\t{ 0x61, \"CALL\" },\n\t{ 0x62, \"CLI\" },\n\t{ 0x63, \"COMPUTER\" },\n\t{ 0x64, \"DISCREET\" },\n\t{ 0x65, \"EMAIL\" },\n\t{ 0x66, \"EXCITED\" },\n\t{ 0x67, \"HAPPY\" },\n\t{ 0x68, \"IM\" },\n\t{ 0x69, \"IM_OFFLINE\" },\n\t{ 0x6A, \"IM_ONLINE\" },\n\t{ 0x6B, \"IN_LOVE\" },\n\t{ 0x6C, \"INVINCIBLE\" },\n\t{ 0x6D, \"JEALOUS\" },\n\t{ 0x6E, \"MMS\" },\n\t{ 0x6F, \"MOBILE_PHONE\" },\n\t{ 0x70, \"NOT_AVAILABLE\" },\n\t{ 0x71, \"OTHER\" },\n\t{ 0x72, \"PDA\" },\n\t{ 0x73, \"SAD\" },\n\t{ 0x74, \"SLEEPY\" },\n\t{ 0x75, \"SMS\" },\n\t{ 0x76, \"VIDEO_CALL\" },\n\t{ 0x77, \"VIDEO_STREAM\" },\n\n\t{ 0x00, NULL }\n};\nstatic value_string_ext vals_wv_csp_11_element_value_tokens_ext = VALUE_STRING_EXT_INIT(vals_wv_csp_11_element_value_tokens);\n\n\n/***** Token code page aggregation *****/\n\nstatic char *\next_t_0_wv_cspc_11(tvbuff_t *tvb _U_, guint32 value, guint32 str_tbl _U_)\n{\n\tchar *str = wmem_strdup_printf(wmem_packet_scope(), \"Common Value: '%s'\",\n\t\t\t\t    val_to_str_ext(value, &vals_wv_csp_11_element_value_tokens_ext,\n\t\t\t\t\t       \"<Unknown WV-CSP 1.1 Common Value token 0x%X>\"));\n\treturn str;\n}\n\nstatic const value_valuestring wbxml_wv_csp_11_global[] = {\n\t{ 0, wbxml_wv_csp_11_global_cp0 },\n\t{ 0, NULL }\n};\n\nstatic const value_valuestring wbxml_wv_csp_11_tags[] = {\n\t{ 0, wbxml_wv_csp_11_tags_cp0 },\n\t{ 1, wbxml_wv_csp_11_tags_cp1 },\n\t{ 2, wbxml_wv_csp_11_tags_cp2 },\n\t{ 3, wbxml_wv_csp_11_tags_cp3 },\n\t{ 4, wbxml_wv_csp_11_tags_cp4 },\n\t{ 5, wbxml_wv_csp_11_tags_cp5 },\n\t{ 6, wbxml_wv_csp_11_tags_cp6 },\n\t{ 7, wbxml_wv_csp_11_tags_cp7 },\n\t{ 0, NULL }\n};\n\nstatic const value_valuestring wbxml_wv_csp_11_attrStart[] = {\n\t{ 0, wbxml_wv_csp_11_attrStart_cp0 },\n\t{ 0, NULL }\n};\n\nstatic const wbxml_decoding decode_wv_cspc_11 = {\n\t\"Wireless-Village Client-Server Protocol 1.1\",\n\t\"WV-CSP 1.1\",\n\t{ ext_t_0_wv_cspc_11, NULL, NULL },\n\twv_csp11_opaque_binary_tag,\n\twv_csp11_opaque_literal_tag,\n\tdefault_opaque_binary_attr,\n\tdefault_opaque_literal_attr,\n\twbxml_wv_csp_11_global,\n\twbxml_wv_csp_11_tags,\n\twbxml_wv_csp_11_attrStart,\n\tNULL\n};\n\n\n\n\n\n/* WV-CSP 1.2\n *\n * Wireless Village Client Server Protocol\n ***************************************/\n\n/*****   Global extension tokens   *****/\n/* Same as WV-CSP 1.1 */\n\n/*****         Tag tokens          *****/\n/* Common code page */\n/* Same as cp0 of WV-CSP 1.1 */\n#define wbxml_wv_csp_12_tags_cp0 wbxml_wv_csp_11_tags_cp0\n/* Note that the table continues in code page 0x09 */\n\n/* Access code page (0x01) */\nstatic const value_string wbxml_wv_csp_12_tags_cp1[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"AllFunctions\" },\n\t{ 0x06, \"AllFunctionsRequest\" },\n\t{ 0x07, \"CancelInvite-Request\" },\n\t{ 0x08, \"CancelInviteUser-Request\" },\n\t{ 0x09, \"Capability\" },\n\t{ 0x0A, \"CapabilityList\" },\n\t{ 0x0B, \"CapabilityRequest\" },\n\t{ 0x0C, \"ClientCapability-Request\" },\n\t{ 0x0D, \"ClientCapability-Response\" },\n\t{ 0x0E, \"DigestBytes\" },\n\t{ 0x0F, \"DigestSchema\" },\n\t{ 0x10, \"Disconnect\" },\n\t{ 0x11, \"Functions\" },\n\t{ 0x12, \"GetSPInfo-Request\" },\n\t{ 0x13, \"GetSPInfo-Response\" },\n\t{ 0x14, \"InviteID\" },\n\t{ 0x15, \"InviteNote\" },\n\t{ 0x16, \"Invite-Request\" },\n\t{ 0x17, \"Invite-Response\" },\n\t{ 0x18, \"InviteType\" },\n\t{ 0x19, \"InviteUser-Request\" },\n\t{ 0x1A, \"InviteUser-Response\" },\n\t{ 0x1B, \"KeepAlive-Request\" },\n\t{ 0x1C, \"KeepAliveTime\" },\n\t{ 0x1D, \"Login-Request\" },\n\t{ 0x1E, \"Login-Response\" },\n\t{ 0x1F, \"Logout-Request\" },\n\t{ 0x20, \"Nonce\" },\n\t{ 0x21, \"Password\" },\n\t{ 0x22, \"Polling-Request\" },\n\t{ 0x23, \"ResponseNote\" },\n\t{ 0x24, \"SearchElement\" },\n\t{ 0x25, \"SearchFindings\" },\n\t{ 0x26, \"SearchID\" },\n\t{ 0x27, \"SearchIndex\" },\n\t{ 0x28, \"SearchLimit\" },\n\t{ 0x29, \"KeepAlive-Response\" },\n\t{ 0x2A, \"SearchPairList\" },\n\t{ 0x2B, \"Search-Request\" },\n\t{ 0x2C, \"Search-Response\" },\n\t{ 0x2D, \"SearchResult\" },\n\t{ 0x2E, \"Service-Request\" },\n\t{ 0x2F, \"Service-Response\" },\n\t{ 0x30, \"SessionCookie\" },\n\t{ 0x31, \"StopSearch-Request\" },\n\t{ 0x32, \"TimeToLive\" },\n\t/* New in WV-CSP 1.1 */\n\t{ 0x33, \"SearchString\" },\n\t{ 0x34, \"CompletionFlag\" },\n\t/* New in WV-CSP 1.2 */\n\t{ 0x36, \"ReceiveList\" },\n\t{ 0x37, \"VerifyID-Request\" },\n\t{ 0x38, \"Extended-Request\" },\n\t{ 0x39, \"Extended-Response\" },\n\t{ 0x3A, \"AgreedCapabilityList\" },\n\t{ 0x3B, \"ExtendedData\" },\n\t{ 0x3C, \"OtherServer\" },\n\t{ 0x3D, \"PresenceAttributeNSName\" },\n\t{ 0x3E, \"SessionNSName\" },\n\t{ 0x3F, \"TransactionNSName\" },\n\n\t{ 0x00, NULL }\n};\n/* Note that the table continues in code page 0x0A */\n\n/* Service code page (0x02) */\nstatic const value_string wbxml_wv_csp_12_tags_cp2[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"ADDGM\" },\n\t{ 0x06, \"AttListFunc\" },\n\t{ 0x07, \"BLENT\" },\n\t{ 0x08, \"CAAUT\" },\n\t{ 0x09, \"CAINV\" },\n\t{ 0x0A, \"CALI\" },\n\t{ 0x0B, \"CCLI\" },\n\t{ 0x0C, \"ContListFunc\" },\n\t{ 0x0D, \"CREAG\" },\n\t{ 0x0E, \"DALI\" },\n\t{ 0x0F, \"DCLI\" },\n\t{ 0x10, \"DELGR\" },\n\t{ 0x11, \"FundamentalFeat\" },\n\t{ 0x12, \"FWMSG\" },\n\t{ 0x13, \"GALS\" },\n\t{ 0x14, \"GCLI\" },\n\t{ 0x15, \"GETGM\" },\n\t{ 0x16, \"GETGP\" },\n\t{ 0x17, \"GETLM\" },\n\t{ 0x18, \"GETM\" },\n\t{ 0x19, \"GETPR\" },\n\t{ 0x1A, \"GETSPI\" },\n\t{ 0x1B, \"GETWL\" },\n\t{ 0x1C, \"GLBLU\" },\n\t{ 0x1D, \"GRCHN\" },\n\t{ 0x1E, \"GroupAuthFunc\" },\n\t{ 0x1F, \"GroupFeat\" },\n\t{ 0x20, \"GroupMgmtFunc\" },\n\t{ 0x21, \"GroupUseFunc\" },\n\t{ 0x22, \"IMAuthFunc\" },\n\t{ 0x23, \"IMFeat\" },\n\t{ 0x24, \"IMReceiveFunc\" },\n\t{ 0x25, \"IMSendFunc\" },\n\t{ 0x26, \"INVIT\" },\n\t{ 0x27, \"InviteFunc\" },\n\t{ 0x28, \"MBRAC\" },\n\t{ 0x29, \"MCLS\" },\n\t{ 0x2A, \"MDELIV\" },\n\t{ 0x2B, \"NEWM\" },\n\t{ 0x2C, \"NOTIF\" },\n\t{ 0x2D, \"PresenceAuthFunc\" },\n\t{ 0x2E, \"PresenceDeliverFunc\" },\n\t{ 0x2F, \"PresenceFeat\" },\n\t{ 0x30, \"REACT\" },\n\t{ 0x31, \"REJCM\" },\n\t{ 0x32, \"REJEC\" },\n\t{ 0x33, \"RMVGM\" },\n\t{ 0x34, \"SearchFunc\" },\n\t{ 0x35, \"ServiceFunc\" },\n\t{ 0x36, \"SETD\" },\n\t{ 0x37, \"SETGP\" },\n\t{ 0x38, \"SRCH\" },\n\t{ 0x39, \"STSRC\" },\n\t{ 0x3A, \"SUBGCN\" },\n\t{ 0x3B, \"UPDPR\" },\n\t{ 0x3C, \"WVCSPFeat\" },\n\t/* New in WV-CSP 1.2 */\n\t{ 0x3D, \"MF\" },\n\t{ 0x3E, \"MG\" },\n\t{ 0x3F, \"MM\" },\n\n\t{ 0x00, NULL }\n};\n/* Note that the table continues in code page 0x08 */\n\n/* Client capability code page (0x03) */\nstatic const value_string wbxml_wv_csp_12_tags_cp3[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"AcceptedCharset\" },\n\t{ 0x06, \"AcceptedContentLength\" },\n\t{ 0x07, \"AcceptedContentType\" },\n\t{ 0x08, \"AcceptedTransferEncoding\" },\n\t{ 0x09, \"AnyContent\" },\n\t{ 0x0A, \"DefaultLanguage\" },\n\t{ 0x0B, \"InitialDeliveryMethod\" },\n\t{ 0x0C, \"MultiTrans\" },\n\t{ 0x0D, \"ParserSize\" },\n\t{ 0x0E, \"ServerPollMin\" },\n\t{ 0x0F, \"SupportedBearer\" },\n\t{ 0x10, \"SupportedCIRMethod\" },\n\t{ 0x11, \"TCPAddress\" },\n\t{ 0x12, \"TCPPort\" },\n\t{ 0x13, \"UDPPort\" },\n\t{ 0x14, \"CIRURL\" },\n\n\t{ 0x00, NULL }\n};\n\n\n\n/* Presence primitive code page (0x04) */\nstatic const value_string wbxml_wv_csp_12_tags_cp4[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"CancelAuth-Request\" },\n\t{ 0x06, \"ContactListProperties\" },\n\t{ 0x07, \"CreateAttributeList-Request\" },\n\t{ 0x08, \"CreateList-Request\" },\n\t{ 0x09, \"DefaultAttributeList\" },\n\t{ 0x0A, \"DefaultContactList\" },\n\t{ 0x0B, \"DefaultList\" },\n\t{ 0x0C, \"DeleteAttributeList-Request\" },\n\t{ 0x0D, \"DeleteList-Request\" },\n\t{ 0x0E, \"GetAttributeList-Request\" },\n\t{ 0x0F, \"GetAttributeList-Response\" },\n\t{ 0x10, \"GetList-Request\" },\n\t{ 0x11, \"GetList-Response\" },\n\t{ 0x12, \"GetPresence-Request\" },\n\t{ 0x13, \"GetPresence-Response\" },\n\t{ 0x14, \"GetWatcherList-Request\" },\n\t{ 0x15, \"GetWatcherList-Response\" },\n\t{ 0x16, \"ListManage-Request\" },\n\t{ 0x17, \"ListManage-Response\" },\n\t{ 0x18, \"UnsubscribePresence-Request\" },\n\t{ 0x19, \"PresenceAuth-Request\" },\n\t{ 0x1A, \"PresenceAuth-User\" },\n\t{ 0x1B, \"PresenceNotification-Request\" },\n\t{ 0x1C, \"UpdatePresence-Request\" },\n\t{ 0x1D, \"SubscribePresence-Request\" },\n\t/* New in WV-CSP 1.2 */\n\t{ 0x1E, \"Auto-Subscribe\" },\n\t/* 0x1E was defined in WV-CSP 1.0: UnsubscribePresence-Request */\n\t{ 0x1F, \"GetReactiveAuthStatus-Request\" },\n\t/* 0x1F was defined in WV-CSP 1.0: UpdatePresence-Request */\n\t{ 0x20, \"GetReactiveAuthStatus-Response\" },\n\n\t{ 0x00, NULL }\n};\n\n/* Presence attribute code page (0x05) */\nstatic const value_string wbxml_wv_csp_12_tags_cp5[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"Accuracy\" },\n\t{ 0x06, \"Address\" },\n\t{ 0x07, \"AddrPref\" },\n\t{ 0x08, \"Alias\" },\n\t{ 0x09, \"Altitude\" },\n\t{ 0x0A, \"Building\" },\n\t{ 0x0B, \"Caddr\" },\n\t{ 0x0C, \"City\" },\n\t{ 0x0D, \"ClientInfo\" },\n\t{ 0x0E, \"ClientProducer\" },\n\t{ 0x0F, \"ClientType\" },\n\t{ 0x10, \"ClientVersion\" },\n\t{ 0x11, \"CommC\" },\n\t{ 0x12, \"CommCap\" },\n\t{ 0x13, \"ContactInfo\" },\n\t{ 0x14, \"ContainedvCard\" },\n\t{ 0x15, \"Country\" },\n\t{ 0x16, \"Crossing1\" },\n\t{ 0x17, \"Crossing2\" },\n\t{ 0x18, \"DevManufacturer\" },\n\t{ 0x19, \"DirectContent\" },\n\t{ 0x1A, \"FreeTextLocation\" },\n\t{ 0x1B, \"GeoLocation\" },\n\t{ 0x1C, \"Language\" },\n\t{ 0x1D, \"Latitude\" },\n\t{ 0x1E, \"Longitude\" },\n\t{ 0x1F, \"Model\" },\n\t{ 0x20, \"NamedArea\" },\n\t{ 0x21, \"OnlineStatus\" },\n\t{ 0x22, \"PLMN\" },\n\t{ 0x23, \"PrefC\" },\n\t{ 0x24, \"PreferredContacts\" },\n\t{ 0x25, \"PreferredLanguage\" },\n\t{ 0x26, \"ReferredContent\" },\n\t{ 0x27, \"ReferredvCard\" },\n\t{ 0x28, \"Registration\" },\n\t{ 0x29, \"StatusContent\" },\n\t{ 0x2A, \"StatusMood\" },\n\t{ 0x2B, \"StatusText\" },\n\t{ 0x2C, \"Street\" },\n\t{ 0x2D, \"TimeZone\" },\n\t{ 0x2E, \"UserAvailability\" },\n\t/* New in WV-CSP 1.1 */\n\t{ 0x2F, \"Cap\" },\n\t{ 0x30, \"Cname\" },\n\t{ 0x31, \"Contact\" },\n\t{ 0x32, \"Cpriority\" },\n\t{ 0x33, \"Cstatus\" },\n\t{ 0x34, \"Note\" },\n\t{ 0x35, \"Zone\" },\n\t/* New in WV-CSP 1.2 */\n\t{ 0x36, \"ContentType\" },\n\t{ 0x37, \"Inf_link\" },\n\t{ 0x38, \"InfoLink\" },\n\t{ 0x39, \"Link\" },\n\t{ 0x3A, \"Text\" },\n\n\t{ 0x00, NULL }\n};\n\n/* Messaging code page (0x06) */\nstatic const value_string wbxml_wv_csp_12_tags_cp6[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"BlockList\" },\n\t{ 0x06, \"BlockEntity-Request\" }, /* Was: BlockUser-Request */\n\t{ 0x07, \"DeliveryMethod\" },\n\t{ 0x08, \"DeliveryReport\" },\n\t{ 0x09, \"DeliveryReport-Request\" },\n\t{ 0x0A, \"ForwardMessage-Request\" },\n\t{ 0x0B, \"GetBlockedList-Request\" },\n\t{ 0x0C, \"GetBlockedList-Response\" },\n\t{ 0x0D, \"GetMessageList-Request\" },\n\t{ 0x0E, \"GetMessageList-Response\" },\n\t{ 0x0F, \"GetMessage-Request\" },\n\t{ 0x10, \"GetMessage-Response\" },\n\t{ 0x11, \"GrantList\" },\n\t{ 0x12, \"MessageDelivered\" },\n\t{ 0x13, \"MessageInfo\" },\n\t{ 0x14, \"MessageNotification\" },\n\t{ 0x15, \"NewMessage\" },\n\t{ 0x16, \"RejectMessage-Request\" },\n\t{ 0x17, \"SendMessage-Request\" },\n\t{ 0x18, \"SendMessage-Response\" },\n\t{ 0x19, \"SetDeliveryMethod-Request\" },\n\t{ 0x1A, \"DeliveryTime\" },\n\n\t{ 0x00, NULL }\n};\n\n/* Group code page (0x07) */\nstatic const value_string wbxml_wv_csp_12_tags_cp7[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"AddGroupMembers-Request\" },\n\t{ 0x06, \"Admin\" },\n\t{ 0x07, \"CreateGroup-Request\" },\n\t{ 0x08, \"DeleteGroup-Request\" },\n\t{ 0x09, \"GetGroupMembers-Request\" },\n\t{ 0x0A, \"GetGroupMembers-Response\" },\n\t{ 0x0B, \"GetGroupProps-Request\" },\n\t{ 0x0C, \"GetGroupProps-Response\" },\n\t{ 0x0D, \"GroupChangeNotice\" },\n\t{ 0x0E, \"GroupProperties\" },\n\t{ 0x0F, \"Joined\" },\n\t{ 0x10, \"JoinedRequest\" },\n\t{ 0x11, \"JoinGroup-Request\" },\n\t{ 0x12, \"JoinGroup-Response\" },\n\t{ 0x13, \"LeaveGroup-Request\" },\n\t{ 0x14, \"LeaveGroup-Response\" },\n\t{ 0x15, \"Left\" },\n\t{ 0x16, \"MemberAccess-Request\" },\n\t{ 0x17, \"Mod\" },\n\t{ 0x18, \"OwnProperties\" },\n\t{ 0x19, \"RejectList-Request\" },\n\t{ 0x1A, \"RejectList-Response\" },\n\t{ 0x1B, \"RemoveGroupMembers-Request\" },\n\t{ 0x1C, \"SetGroupProps-Request\" },\n\t{ 0x1D, \"SubscribeGroupNotice-Request\" },\n\t{ 0x1E, \"SubscribeGroupNotice-Response\" },\n\t{ 0x1F, \"Users\" },\n\t{ 0x20, \"WelcomeNote\" },\n\t/* New in WV-CSP 1.1 */\n\t{ 0x21, \"JoinGroup\" },\n\t{ 0x22, \"SubscribeNotification\" },\n\t{ 0x23, \"SubscribeType\" },\n\t/* New in WV-CSP 1.2 */\n\t{ 0x24, \"GetJoinedUsers-Request\" },\n\t{ 0x25, \"GetJoinedUsers-Response\" },\n\t{ 0x26, \"AdminMapList\" },\n\t{ 0x27, \"AdminMapping\" },\n\t{ 0x28, \"Mapping\" },\n\t{ 0x29, \"ModMapping\" },\n\t{ 0x2A, \"UserMapList\" },\n\t{ 0x2B, \"UserMapping\" },\n\n\t{ 0x00, NULL }\n};\n\n/* Service negotiation code page - continued (0x08) */\nstatic const value_string wbxml_wv_csp_12_tags_cp8[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"MP\" },\n\t{ 0x06, \"GETAUT\" },\n\t{ 0x07, \"GETJU\" },\n\t{ 0x08, \"VRID\" },\n\t{ 0x09, \"VerifyIDFunc\" },\n\n\t{ 0x00, NULL }\n};\n\n/* Common code page - continued (0x09) */\nstatic const value_string wbxml_wv_csp_12_tags_cp9[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"CIR\" },\n\t{ 0x06, \"Domain\" },\n\t{ 0x07, \"ExtBlock\" },\n\t{ 0x08, \"HistoryPeriod\" },\n\t{ 0x09, \"IDList\" },\n\t{ 0x0A, \"MaxWatcherList\" },\n\t{ 0x0B, \"ReactiveAuthState\" },\n\t{ 0x0C, \"ReactiveAuthStatus\" },\n\t{ 0x0D, \"ReactiveAuthStatusList\" },\n\t{ 0x0E, \"Watcher\" },\n\t{ 0x0F, \"WatcherStatus\" },\n\n\t{ 0x00, NULL }\n};\n\n/* Access code page - continued (0x0A) */\nstatic const value_string wbxml_wv_csp_12_tags_cp10[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"WV-CSP-NSDiscovery-Request\" },\n\t{ 0x06, \"WV-CSP-NSDiscovery-Response\" },\n\t{ 0x07, \"VersionList\" },\n\n\t{ 0x00, NULL }\n};\n\n/*****    Attribute Start tokens   *****/\n/* Common code page (0x00) */\nstatic const value_string wbxml_wv_csp_12_attrStart_cp0[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"xmlns='http://www.wireless-village.org/CSP'\" },\n\t{ 0x06, \"xmlns='http://www.wireless-village.org/PA'\" },\n\t{ 0x07, \"xmlns='http://www.wireless-village.org/TRC'\" },\n\t/* New in WV-CSP 1.2 */\n\t{ 0x08, \"xmlns='http://www.openmobilealliance.org/DTD/WV-CSP'\" },\n\t{ 0x09, \"xmlns='http://www.openmobilealliance.org/DTD/WV-PA'\" },\n\t{ 0x0A, \"xmlns http://www.openmobilealliance.org/DTD/WV-TRC'\" },\n\n\t{ 0x00, NULL }\n};\n\n/*****    Attribute Value tokens   *****/\n/*\n * Element value tokens\n *\n * NOTE - WV-CSP uses the EXT_T_0 token in a peculiar way: the mb_u_int32\n * does *not* reference an offset in the string table, but it refers to\n * the index in the following value_string.\n *\n * Please note that:\n *  - Values 'T' and 'F' are Boolean values representing \"True\" and \"False\"\n *    (or \"Yes\" and \"No\" in some circumstances) respectively.\n *  - Values 'GR', 'IM', 'PR', 'SC', 'GM' and 'US' are enumerated values\n *    representing \"Group\", \"Instant Messaging\", \"Presence\", \"Shared Content\",\n *    \"Group membership\" and \"User\" respectively.\n *  - Values 'G', 'S' and 'U' are enumerated values representing \"Get\", \"Set\"\n *    and \"Unset\" respectively.\n *  - Values 'N' and 'P' are enumerated values representing \"Notify/Get\" and\n *    \"Push\" respectively.\n *\n * I repeat: this is NOT a attrValue[] array hence it is not called\n * wbxml_wv_XXX but vals_wv_XXX.\n */\nstatic const value_string vals_wv_csp_12_element_value_tokens[] = {\n\t/*\n\t * Common value tokens\n\t */\n\t{ 0x00, \"AccessType\" },\n\t{ 0x01, \"ActiveUsers\" },\n\t{ 0x02, \"Admin\" },\n\t{ 0x03, \"application/\" },\n\t{ 0x04, \"application/vnd.wap.mms-message\" },\n\t{ 0x05, \"application/x-sms\" },\n\t{ 0x06, \"AutoJoin\" },\n\t{ 0x07, \"BASE64\" },\n\t{ 0x08, \"Closed\" },\n\t{ 0x09, \"Default\" },\n\t{ 0x0A, \"DisplayName\" },\n\t{ 0x0B, \"F\" },\n\t{ 0x0C, \"G\" },\n\t{ 0x0D, \"GR\" },\n\t{ 0x0E, \"http://\" },\n\t{ 0x0F, \"https://\" },\n\t{ 0x10, \"image/\" },\n\t{ 0x11, \"Inband\" },\n\t{ 0x12, \"IM\" },\n\t{ 0x13, \"MaxActiveUsers\" },\n\t{ 0x14, \"Mod\" },\n\t{ 0x15, \"Name\" },\n\t{ 0x16, \"None\" },\n\t{ 0x17, \"N\" },\n\t{ 0x18, \"Open\" },\n\t{ 0x19, \"Outband\" },\n\t{ 0x1A, \"PR\" },\n\t{ 0x1B, \"Private\" },\n\t{ 0x1C, \"PrivateMessaging\" },\n\t{ 0x1D, \"PrivilegeLevel\" },\n\t{ 0x1E, \"Public\" },\n\t{ 0x1F, \"P\" },\n\t{ 0x20, \"Request\" },\n\t{ 0x21, \"Response\" },\n\t{ 0x22, \"Restricted\" },\n\t{ 0x23, \"ScreenName\" },\n\t{ 0x24, \"Searchable\" },\n\t{ 0x25, \"S\" },\n\t{ 0x26, \"SC\" },\n\t{ 0x27, \"text/\" },\n\t{ 0x28, \"text/plain\" },\n\t{ 0x29, \"text/x-vCalendar\" },\n\t{ 0x2A, \"text/x-vCard\" },\n\t{ 0x2B, \"Topic\" },\n\t{ 0x2C, \"T\" },\n\t{ 0x2D, \"Type\" },\n\t{ 0x2E, \"U\" },\n\t{ 0x2F, \"US\" },\n\t{ 0x30, \"www.wireless-village.org\" },\n\t/* New in WV-CSP 1.2 */\n\t{ 0x31, \"AutoDelete\" },\n\t{ 0x32, \"GM\" },\n\t{ 0x33, \"Validity\" },\n\t{ 0x34, \"DENIED\" },\n\t{ 0x35, \"GRANTED\" },\n\t{ 0x36, \"PENDING\" },\n\t{ 0x37, \"ShowID\" },\n\n\t/*\n\t * Access value tokens\n\t */\n\t{ 0x3D, \"GROUP_ID\" },\n\t{ 0x3E, \"GROUP_NAME\" },\n\t{ 0x3F, \"GROUP_TOPIC\" },\n\t{ 0x40, \"GROUP_USER_ID_JOINED\" },\n\t{ 0x41, \"GROUP_USER_ID_OWNER\" },\n\t{ 0x42, \"HTTP\" },\n\t{ 0x43, \"SMS\" },\n\t{ 0x44, \"STCP\" },\n\t{ 0x45, \"SUDP\" },\n\t{ 0x46, \"USER_ALIAS\" },\n\t{ 0x47, \"USER_EMAIL_ADDRESS\" },\n\t{ 0x48, \"USER_FIRST_NAME\" },\n\t{ 0x49, \"USER_ID\" },\n\t{ 0x4A, \"USER_LAST_NAME\" },\n\t{ 0x4B, \"USER_MOBILE_NUMBER\" },\n\t{ 0x4C, \"USER_ONLINE_STATUS\" },\n\t{ 0x4D, \"WAPSMS\" },\n\t{ 0x4E, \"WAPUDP\" },\n\t{ 0x4F, \"WSP\" },\n\t/* New in WV-CSP 1.2 */\n\t{ 0x50, \"GROUP_USER_ID_AUTOJOIN\" },\n\t/*\n\t * Presence value tokens\n\t */\n\t{ 0x5B, \"ANGRY\" },\n\t{ 0x5C, \"ANXIOUS\" },\n\t{ 0x5D, \"ASHAMED\" },\n\t{ 0x5E, \"AUDIO_CALL\" },\n\t{ 0x5F, \"AVAILABLE\" },\n\t{ 0x60, \"BORED\" },\n\t{ 0x61, \"CALL\" },\n\t{ 0x62, \"CLI\" },\n\t{ 0x63, \"COMPUTER\" },\n\t{ 0x64, \"DISCREET\" },\n\t{ 0x65, \"EMAIL\" },\n\t{ 0x66, \"EXCITED\" },\n\t{ 0x67, \"HAPPY\" },\n\t/*\t{ 0x68, \"IM\" },\t\tObsolete */\n\t{ 0x69, \"IM_OFFLINE\" },\n\t{ 0x6A, \"IM_ONLINE\" },\n\t{ 0x6B, \"IN_LOVE\" },\n\t{ 0x6C, \"INVINCIBLE\" },\n\t{ 0x6D, \"JEALOUS\" },\n\t{ 0x6E, \"MMS\" },\n\t{ 0x6F, \"MOBILE_PHONE\" },\n\t{ 0x70, \"NOT_AVAILABLE\" },\n\t{ 0x71, \"OTHER\" },\n\t{ 0x72, \"PDA\" },\n\t{ 0x73, \"SAD\" },\n\t{ 0x74, \"SLEEPY\" },\n\t{ 0x75, \"SMS\" },\n\t{ 0x76, \"VIDEO_CALL\" },\n\t{ 0x77, \"VIDEO_STREAM\" },\n\n\t/*\n\t * Access value tokens - continued\n\t */\n\t{ 0xA4, \"SSMS\" },\n\t{ 0xA5, \"SHTTP\" },\n\n\t{ 0x00, NULL }\n};\n\n\n\n/***** Token code page aggregation *****/\n\nstatic char *\next_t_0_wv_cspc_12(tvbuff_t *tvb _U_, guint32 value, guint32 str_tbl _U_)\n{\n\tchar *str = wmem_strdup_printf(wmem_packet_scope(), \"Common Value: '%s'\",\n\t\t\t\t    val_to_str(value, vals_wv_csp_12_element_value_tokens,\n\t\t\t\t\t       \"<Unknown WV-CSP 1.2 Common Value token 0x%X>\"));\n\treturn str;\n}\n\n#define wbxml_wv_csp_12_global wbxml_wv_csp_11_global\n\nstatic const value_valuestring wbxml_wv_csp_12_tags[] = {\n\t{  0, wbxml_wv_csp_12_tags_cp0 },\n\t{  1, wbxml_wv_csp_12_tags_cp1 },\n\t{  2, wbxml_wv_csp_12_tags_cp2 },\n\t{  3, wbxml_wv_csp_12_tags_cp3 },\n\t{  4, wbxml_wv_csp_12_tags_cp4 },\n\t{  5, wbxml_wv_csp_12_tags_cp5 },\n\t{  6, wbxml_wv_csp_12_tags_cp6 },\n\t{  7, wbxml_wv_csp_12_tags_cp7 },\n\t{  8, wbxml_wv_csp_12_tags_cp8 },\n\t{  9, wbxml_wv_csp_12_tags_cp9 },\n\t{ 10, wbxml_wv_csp_12_tags_cp10 },\n\t{  0, NULL }\n};\n\nstatic const value_valuestring wbxml_wv_csp_12_attrStart[] = {\n\t{ 0, wbxml_wv_csp_12_attrStart_cp0 },\n\t{ 0, NULL }\n};\n\nstatic const wbxml_decoding decode_wv_cspc_12 = {\n\t\"Wireless-Village Client-Server Protocol 1.2\",\n\t\"WV-CSP 1.2\",\n\t{ ext_t_0_wv_cspc_12, NULL, NULL },\n\twv_csp12_opaque_binary_tag,\n\twv_csp12_opaque_literal_tag,\n\tdefault_opaque_binary_attr,\n\tdefault_opaque_literal_attr,\n\twbxml_wv_csp_12_global,\n\twbxml_wv_csp_12_tags,\n\twbxml_wv_csp_12_attrStart,\n\tNULL\n};\n\n\n/* WV-CSP 1.3\n *\n * Wireless Village Client Server Protocol\n ***************************************/\n\n/*****   Global extension tokens   *****/\n/* Same as WV-CSP 1.1 */\n\n/*****         Tag tokens          *****/\n/* Common code page */\nstatic const value_string wbxml_wv_csp_13_tags_cp0[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"Acceptance\"},\n\t{ 0x06, \"AddList\" },\n\t{ 0x07, \"AddNickList\"},\n\t{ 0x09, \"WV-CSP-Message\"},\n\t{ 0x0A, \"ClientID\"},\n\t{ 0x0B,\t\"Code\"},\n\t{ 0x0C, \"ContactList\"},\n\t{ 0x0D, \"ContentData\"},\n\t{ 0x0E, \"ContentEncoding\"},\n\t{ 0x0F, \"ContentSize\"   },\n\t{ 0x10, \"ContentType\"},\n\t{ 0x11, \"DateTime\"   },\n\t{ 0x12, \"Description\" },\n\t{ 0x13, \"DetailedResult\"},\n\t{ 0x14, \"EntityList\"},\n\t{ 0x15, \"Group\"  },\n\t{ 0x16, \"GroupID\"},\n\t{ 0x17, \"GroupList\"},\n\t{ 0x19, \"Logo\"},\n\t{ 0x1A, \"MessageCount\" },\n\t{ 0x1B, \"MessageID\" },\n\t{ 0x1C, \"MessageURI\"},\n\t{ 0x1D, \"MSISDN\" },\n\t{ 0x1E, \"Name\"},\n\t{ 0x1F, \"NickList\"},\n\t{ 0x20, \"NickName\"},\n\t{ 0x21, \"Poll\"},\n\t{ 0x22, \"Presence\"},\n\t{ 0x23, \"PresenceSubList\" },\n\t{ 0x24, \"PresenceValue\"},\n\t{ 0x25, \"Property\"  },\n\t{ 0x26, \"Qualifier\" },\n\t{ 0x27, \"Recipient\" },\n\t{ 0x28, \"RemoveList\"},\n\t{ 0x29, \"RemoveNickList\"  },\n\t{ 0x2A, \"Result\" },\n\t{ 0x2B, \"ScreenName\"},\n\t{ 0x2C, \"Sender\" },\n\t{ 0x2D, \"Session\"},\n\t{ 0x2E, \"SessionDescriptor\" },\n\t{ 0x2F, \"SessionID\"},\n\t{ 0x30, \"SessionType\" },\n\t{ 0x08, \"SName\" },\n\t{ 0x31, \"Status\"},\n\t{ 0x32, \"Transaction\" },\n\t{ 0x33, \"TransactionContent\"  },\n\t{ 0x34, \"TransactionDescriptor\"},\n\t{ 0x35, \"TransactionID\"},\n\t{ 0x36, \"TransactionMode\" },\n\t{ 0x37, \"URL\" },\n\t{ 0x38, \"URLList\"},\n\t{ 0x39, \"User\"},\n\t{ 0x3A, \"UserID\" },\n\t{ 0x3B, \"UserList\"  },\n\t{ 0x3C, \"Validity\"  },\n\t{ 0x3D, \"Value\"  },\n\n\t{ 0x00, NULL }\n};\n/* Note that the table continues in code page 0x09 */\n\n/* Access code page (0x01) */\nstatic const value_string wbxml_wv_csp_13_tags_cp1[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"AllFunctions\" },\n\t{ 0x06, \"AllFunctionsRequest\" },\n\t{ 0x07, \"CancelInvite-Request\" },\n\t{ 0x08, \"CancelInviteUser-Request\" },\n\t/*\t{ 0x09, \"Capability\" }, - removed in WV 1.3*/\n\t{ 0x0A, \"CapabilityList\" },\n\t{ 0x0B, \"CapabilityRequest\" },\n\t{ 0x0C, \"ClientCapability-Request\" },\n\t{ 0x0D, \"ClientCapability-Response\" },\n\t{ 0x0E, \"DigestBytes\" },\n\t{ 0x0F, \"DigestSchema\" },\n\t{ 0x10, \"Disconnect\" },\n\t{ 0x11, \"Functions\" },\n\t{ 0x12, \"GetSPInfo-Request\" },\n\t{ 0x13, \"GetSPInfo-Response\" },\n\t{ 0x14, \"InviteID\" },\n\t{ 0x15, \"InviteNote\" },\n\t{ 0x16, \"Invite-Request\" },\n\t{ 0x17, \"Invite-Response\" },\n\t{ 0x18, \"InviteType\" },\n\t{ 0x19, \"InviteUser-Request\" },\n\t{ 0x1A, \"InviteUser-Response\" },\n\t{ 0x1B, \"KeepAlive-Request\" },\n\t{ 0x1C, \"KeepAliveTime\" },\n\t{ 0x1D, \"Login-Request\" },\n\t{ 0x1E, \"Login-Response\" },\n\t{ 0x1F, \"Logout-Request\" },\n\t{ 0x20, \"Nonce\" },\n\t{ 0x21, \"Password\" },\n\t{ 0x22, \"Polling-Request\" },\n\t{ 0x23, \"ResponseNote\" },\n\t{ 0x24, \"SearchElement\" },\n\t{ 0x25, \"SearchFindings\" },\n\t{ 0x26, \"SearchID\" },\n\t{ 0x27, \"SearchIndex\" },\n\t{ 0x28, \"SearchLimit\" },\n\t{ 0x29, \"KeepAlive-Response\" },\n\t{ 0x2A, \"SearchPairList\" },\n\t{ 0x2B, \"Search-Request\" },\n\t{ 0x2C, \"Search-Response\" },\n\t{ 0x2D, \"SearchResult\" },\n\t{ 0x2E, \"Service-Request\" },\n\t{ 0x2F, \"Service-Response\" },\n\t{ 0x30, \"SessionCookie\" },\n\t{ 0x31, \"StopSearch-Request\" },\n\t{ 0x32, \"TimeToLive\" },\n\t/* New in WV-CSP 1.1 */\n\t{ 0x33, \"SearchString\" },\n\t{ 0x34, \"CompletionFlag\" },\n\t/* New in WV-CSP 1.2 */\n\t{ 0x36, \"ReceiveList\" },\n\t{ 0x37, \"VerifyID-Request\" },\n\t{ 0x38, \"Extended-Request\" },\n\t{ 0x39, \"Extended-Response\" },\n\t{ 0x3A, \"AgreedCapabilityList\" },\n\t{ 0x3B, \"ExtendedData\" },\n\t{ 0x3C, \"OtherServer\" },\n\t{ 0x3D, \"PresenceAttributeNSName\" },\n\t{ 0x3E, \"SessionNSName\" },\n\t{ 0x3F, \"TransactionNSName\" },\n\n\t{ 0x00, NULL }\n};\n/* Note that the table continues in code page 0x0A */\n\n/* Service code page (0x02) */\nstatic const value_string wbxml_wv_csp_13_tags_cp2[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"ADDGM\" },\n\t/*\t{ 0x06, \"AttListFunc\" }, removed in WV 1.3 */\n\t{ 0x07, \"BLENT\" },\n\t/*\t{ 0x08, \"CAAUT\" }, removed in WV 1.3 */\n\t{ 0x09, \"CAINV\" },\n\t/*\t{ 0x0A, \"CALI\" }, removed in WV 1.3 */\n\t{ 0x0B, \"CCLI\" },\n\t{ 0x0C, \"ContListFunc\" },\n\t{ 0x0D, \"CREAG\" },\n\t{ 0x0E, \"DALI\" },\n\t{ 0x0F, \"DCLI\" },\n\t{ 0x10, \"DELGR\" },\n\t{ 0x11, \"FundamentalFeat\" },\n\t{ 0x12, \"FWMSG\" },\n\t/*\t{ 0x13, \"GALS\" }, removed in WV 1.3 */\n\t{ 0x14, \"GCLI\" },\n\t{ 0x15, \"GETGM\" },\n\t{ 0x16, \"GETGP\" },\n\t{ 0x17, \"GETLM\" },\n\t{ 0x18, \"GETM\" },\n\t{ 0x19, \"GETPR\" },\n\t{ 0x1A, \"GETSPI\" },\n\t{ 0x1B, \"GETWL\" },\n\t{ 0x1C, \"GLBLU\" },\n\t{ 0x1D, \"GRCHN\" },\n\t{ 0x1E, \"GroupAuthFunc\" },\n\t{ 0x1F, \"GroupFeat\" },\n\t{ 0x20, \"GroupMgmtFunc\" },\n\t{ 0x21, \"GroupUseFunc\" },\n\t{ 0x22, \"IMAuthFunc\" },\n\t{ 0x23, \"IMFeat\" },\n\t{ 0x24, \"IMReceiveFunc\" },\n\t{ 0x25, \"IMSendFunc\" },\n\t{ 0x26, \"INVIT\" },\n\t{ 0x27, \"InviteFunc\" },\n\t{ 0x28, \"MBRAC\" },\n\t{ 0x29, \"MCLS\" },\n\t{ 0x2A, \"MDELIV\" },\n\t{ 0x2B, \"NEWM\" },\n\t{ 0x2C, \"NOTIF\" },\n\t{ 0x2D, \"PresenceAuthFunc\" },\n\t{ 0x2E, \"PresenceDeliverFunc\"},\n\t{ 0x2F, \"PresenceFeat\" },\n\t/*\t{ 0x30, \"REACT\" }, removed in WV 1.3 */\n\t{ 0x31, \"REJCM\" },\n\t{ 0x32, \"REJEC\" },\n\t{ 0x33, \"RMVGM\" },\n\t{ 0x34, \"SearchFunc\" },\n\t{ 0x35, \"ServiceFunc\" },\n\t{ 0x36, \"SETD\" },\n\t{ 0x37, \"SETGP\" },\n\t{ 0x38, \"SRCH\" },\n\t{ 0x39, \"STSRC\" },\n\t{ 0x3A, \"SUBGCN\" },\n\t{ 0x3B, \"UPDPR\" },\n\t{ 0x3C, \"WVCSPFeat\" },\n\t/* New in WV-CSP 1.2 */\n\t{ 0x3D, \"MF\" },\n\t{ 0x3E, \"MG\" },\n\t{ 0x3F, \"MM\" },\n\n\t{ 0x00, NULL }\n};\n/* Note that the table continues in code page 0x08 */\n\n/* Client capability code page (0x03) */\nstatic const value_string wbxml_wv_csp_13_tags_cp3[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t/*  {0x05, \"AcceptedCharset\"}, - removed in WV 1.3 */\n\t/*  { 0x06, \"AcceptedContentLength\"}, - removed in WV 1.3 */\n\t{ 0x07, \"AcceptedContentType\"},\n\t{ 0x08, \"AcceptedTransferEncoding\"},\n\t{ 0x09, \"AnyContent\"},\n\t{ 0x0A, \"DefaultLanguage\"},\n\t{ 0x0B, \"InitialDeliveryMethod\"},\n\t{ 0x0C, \"MultiTrans\"},\n\t{ 0x0D, \"ParserSize\"},\n\t{ 0x0E, \"ServerPollMin\"},\n\t{ 0x0F, \"SupportedBearer\"},\n\t{ 0x10, \"SupportedCIRMethod\"},\n\t{ 0x11, \"TCPAddress\"},\n\t{ 0x12, \"TCPPort\"},\n\t{ 0x13, \"UDPPort\"},\n\t/* New in WV-CSP 1.3*/\n\t{ 0x14, \"CIRHTTPAddress\"},\n\t{ 0x15, \"UDPAddress\"},\n\t{ 0x16, \"AcceptedPullLength\"},\n\t{ 0x17, \"AcceptedPushLength\"},\n\t{ 0x18, \"AcceptedRichContentLength\"},\n\t{ 0x19, \"AcceptedTextContentLength\"},\n\t{ 0x1A, \"OfflineETEMHandling\"},\n\t{ 0x1B, \"PlainTextCharset\"},\n\t{ 0x1C, \"SessionPriority\"},\n\t{ 0x1D, \"SupportedOfflineBearer\"},\n\t{ 0x1F, \"UserSessionLimit\"},\n\t{ 0x20, \"CIRSMSAddress\"},\n\t{ 0x21, \"MultiTransPerMessage\"},\n\t{ 0x22, \"OnlineETEMHandling\"},\n\t{ 0x23,\"ContentPolicy\"},\n\t{ 0x24, \"ContentPolicyLimit\"},\n\n\t{ 0x00, NULL }\n};\n\n/* Presence primitive code page (0x04) */\nstatic const value_string wbxml_wv_csp_13_tags_cp4[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t/*\t{ 0x05, \"CancelAuth-Request\" }, - removed in WV 1.3 */\n\t{ 0x06, \"ContactListProperties\" },\n\t{ 0x07, \"CreateAttributeList-Request\" },\n\t{ 0x08, \"CreateList-Request\" },\n\t{ 0x09, \"DefaultAttributeList\" },\n\t{ 0x0A, \"DefaultContactList\" },\n\t{ 0x0B, \"DefaultList\" },\n\t{ 0x0C, \"DeleteAttributeList-Request\" },\n\t{ 0x0D, \"DeleteList-Request\" },\n\t{ 0x0E, \"GetAttributeList-Request\" },\n\t{ 0x0F, \"GetAttributeList-Response\" },\n\t{ 0x10, \"GetList-Request\" },\n\t{ 0x11, \"GetList-Response\" },\n\t{ 0x12, \"GetPresence-Request\" },\n\t{ 0x13, \"GetPresence-Response\" },\n\t{ 0x14, \"GetWatcherList-Request\" },\n\t{ 0x15, \"GetWatcherList-Response\" },\n\t{ 0x16, \"ListManage-Request\" },\n\t{ 0x17, \"ListManage-Response\" },\n\t{ 0x18, \"UnsubscribePresence-Request\" },\n\t{ 0x19, \"PresenceAuth-Request\" },\n\t{ 0x1A, \"PresenceAuth-User\" },\n\t{ 0x1B, \"PresenceNotification-Request\" },\n\t{ 0x1C, \"UpdatePresence-Request\" },\n\t{ 0x1D, \"SubscribePresence-Request\" },\n\t/* New in WV-CSP 1.2 */\n\t/*\t{ 0x1E, \"Auto-Subscribe\" }, - removed in WV 1.3 */\n\t/*\t{ 0x1F, \"GetReactiveAuthStatus-Request\" }, */\n\t/*\t{ 0x20, \"GetReactiveAuthStatus-Response\" }, */\n\t/* New in WV-CSP 1.3 */\n\t{ 0x21, \"CreateList-Response\"},\n\n\t{ 0x00, NULL }\n};\n\n/* Presence attribute code page (0x05) */\nstatic const value_string wbxml_wv_csp_13_tags_cp5[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"Accuracy\" },\n\t{ 0x06, \"Address\" },\n\t{ 0x07, \"AddrPref\" },\n\t{ 0x08, \"Alias\" },\n\t{ 0x09, \"Altitude\" },\n\t{ 0x0A, \"Building\" },\n\t{ 0x0B, \"Caddr\" },\n\t{ 0x0C, \"City\" },\n\t{ 0x0D, \"ClientInfo\" },\n\t{ 0x0E, \"ClientProducer\" },\n\t{ 0x0F, \"ClientType\" },\n\t{ 0x10, \"ClientVersion\" },\n\t{ 0x11, \"CommC\" },\n\t{ 0x12, \"CommCap\" },\n\t{ 0x13, \"ContactInfo\" },\n\t{ 0x14, \"ContainedvCard\" },\n\t{ 0x15, \"Country\" },\n\t{ 0x16, \"Crossing1\" },\n\t{ 0x17, \"Crossing2\" },\n\t{ 0x18, \"DevManufacturer\" },\n\t{ 0x19, \"DirectContent\" },\n\t{ 0x1A, \"FreeTextLocation\" },\n\t{ 0x1B, \"GeoLocation\" },\n\t{ 0x1C, \"Language\" },\n\t{ 0x1D, \"Latitude\" },\n\t{ 0x1E, \"Longitude\" },\n\t{ 0x1F, \"Model\" },\n\t{ 0x20, \"NamedArea\" },\n\t{ 0x21, \"OnlineStatus\" },\n\t{ 0x22, \"PLMN\" },\n\t{ 0x23, \"PrefC\" },\n\t{ 0x24, \"PreferredContacts\" },\n\t{ 0x25, \"PreferredLanguage\" },\n\t{ 0x26, \"ReferredContent\" },\n\t{ 0x27, \"ReferredvCard\" },\n\t{ 0x28, \"Registration\" },\n\t{ 0x29, \"StatusContent\" },\n\t{ 0x2A, \"StatusMood\" },\n\t{ 0x2B, \"StatusText\" },\n\t{ 0x2C, \"Street\" },\n\t{ 0x2D, \"TimeZone\" },\n\t{ 0x2E, \"UserAvailability\" },\n\t/* New in WV-CSP 1.1 */\n\t{ 0x2F, \"Cap\" },\n\t{ 0x30, \"Cname\" },\n\t{ 0x31, \"Contact\" },\n\t{ 0x32, \"Cpriority\" },\n\t{ 0x33, \"Cstatus\" },\n\t{ 0x34, \"Note\" },\n\t{ 0x35, \"Zone\" },\n\t/* New in WV-CSP 1.2 */\n\t{ 0x36, \"ContentType\" },\n\t{ 0x37, \"Inf_link\" },\n\t{ 0x38, \"InfoLink\" },\n\t{ 0x39, \"Link\" },\n\t{ 0x3A, \"Text\" },\n\t/* New in WV-CSP 1.3 */\n\t{ 0x3B, \"ClientContentLimit\"},\n\t{ 0x3C, \"ClientIMPriority\"},\n\t{ 0x3D, \"MaxPullLength\"},\n\t{ 0x3E, \"MaxPushLength\"},\n\n\t{ 0x00, NULL }\n};\n\n/* Messaging code page (0x06) */\nstatic const value_string wbxml_wv_csp_13_tags_cp6[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"BlockList\" },\n\t{ 0x06, \"BlockEntity-Request\" }, /* Was: BlockUser-Request */\n\t{ 0x07, \"DeliveryMethod\" },\n\t{ 0x08, \"DeliveryReport\" },\n\t{ 0x09, \"DeliveryReport-Request\" },\n\t{ 0x0A, \"ForwardMessage-Request\" },\n\t{ 0x0B, \"GetBlockedList-Request\" },\n\t{ 0x0C, \"GetBlockedList-Response\" },\n\t{ 0x0D, \"GetMessageList-Request\" },\n\t{ 0x0E, \"GetMessageList-Response\" },\n\t{ 0x0F, \"GetMessage-Request\" },\n\t{ 0x10, \"GetMessage-Response\" },\n\t{ 0x11, \"GrantList\" },\n\t{ 0x12, \"MessageDelivered\" },\n\t{ 0x13, \"MessageInfo\" },\n\t{ 0x14, \"MessageNotification\" },\n\t{ 0x15, \"NewMessage\" },\n\t{ 0x16, \"RejectMessage-Request\" },\n\t{ 0x17, \"SendMessage-Request\" },\n\t{ 0x18, \"SendMessage-Response\" },\n\t{ 0x19, \"SetDeliveryMethod-Request\" },\n\t{ 0x1A, \"DeliveryTime\" },\n\t/* New in WV-CSP 1.3 */\n\t{ 0x20, \"MessageInfoList\"},\n\t{ 0x21, \"ForwardMessage-Response\"},\n\n\t{ 0x00, NULL }\n};\n\n/* Group code page (0x07) */\nstatic const value_string wbxml_wv_csp_13_tags_cp7[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"AddGroupMembers-Request\" },\n\t{ 0x06, \"Admin\" },\n\t{ 0x07, \"CreateGroup-Request\" },\n\t{ 0x08, \"DeleteGroup-Request\" },\n\t{ 0x09, \"GetGroupMembers-Request\" },\n\t{ 0x0A, \"GetGroupMembers-Response\" },\n\t{ 0x0B, \"GetGroupProps-Request\" },\n\t{ 0x0C, \"GetGroupProps-Response\" },\n\t{ 0x0D, \"GroupChangeNotice\" },\n\t{ 0x0E, \"GroupProperties\" },\n\t{ 0x0F, \"Joined\" },\n\t{ 0x10, \"JoinedRequest\" },\n\t{ 0x11, \"JoinGroup-Request\" },\n\t{ 0x12, \"JoinGroup-Response\" },\n\t{ 0x13, \"LeaveGroup-Request\" },\n\t{ 0x14, \"LeaveGroup-Response\" },\n\t{ 0x15, \"Left\" },\n\t{ 0x16, \"MemberAccess-Request\" },\n\t{ 0x17, \"Mod\" },\n\t{ 0x18, \"OwnProperties\" },\n\t{ 0x19, \"RejectList-Request\" },\n\t{ 0x1A, \"RejectList-Response\" },\n\t{ 0x1B, \"RemoveGroupMembers-Request\" },\n\t{ 0x1C, \"SetGroupProps-Request\" },\n\t{ 0x1D, \"SubscribeGroupNotice-Request\" },\n\t{ 0x1E, \"SubscribeGroupNotice-Response\" },\n\t/*\t{ 0x1F, \"Users\" },  - removed in WV 1.3 */\n\t{ 0x20, \"WelcomeNote\" },\n\t/* New in WV-CSP 1.1 */\n\t{ 0x21, \"JoinGroup\" },\n\t{ 0x22, \"SubscribeNotification\" },\n\t{ 0x23, \"SubscribeType\" },\n\t/* New in WV-CSP 1.2 */\n\t{ 0x24, \"GetJoinedUsers-Request\" },\n\t{ 0x25, \"GetJoinedUsers-Response\" },\n\t{ 0x26, \"AdminMapList\" },\n\t{ 0x27, \"AdminMapping\" },\n\t{ 0x28, \"Mapping\" },\n\t{ 0x29, \"ModMapping\" },\n\t{ 0x2A, \"UserMapList\" },\n\t{ 0x2B, \"UserMapping\" },\n\t/* New in WV-CSP 1.3 */\n\t{ 0x2C, \"JoinedBlocked\" },\n\t{ 0x2D, \"LeftBlocked\" },\n\n\t{ 0x00, NULL }\n};\n\n/* Service negotiation code page - continued (0x08) */\nstatic const value_string wbxml_wv_csp_13_tags_cp8[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t/* New in WV-CSP 1.2 */\n\t{ 0x05, \"MP\" },\n\t{ 0x06, \"GETAUT\" },\n\t{ 0x07, \"GETJU\" },\n\t{ 0x08, \"VRID\" },\n\t{ 0x09, \"VerifyIDFunc\" },\n\t/* New in WV-CSP 1.3 */\n \t{ 0x0A, \"GETMAP\" },\n\t{ 0x0B, \"SGMNT\" },\n\t{ 0x0C, \"EXCON\" },\n\t{ 0x0D, \"OFFNOTIF\" },\n\t{ 0x0E, \"ADVSR\" },\n\n\t{ 0x00, NULL }\n};\n\n/* Common code page - continued (0x09) */\nstatic const value_string wbxml_wv_csp_13_tags_cp9[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t/* New in WV-CSP 1.2 */\n\t{ 0x05, \"CIR\" },\n\t{ 0x06, \"Domain\" },\n\t{ 0x07, \"ExtBlock\" },\n\t{ 0x08, \"HistoryPeriod\" },\n\t{ 0x09, \"IDList\" },\n\t{ 0x0A, \"MaxWatcherList\" },\n\t/*\t{ 0x0B, \"ReactiveAuthState\" }, - removed in WV 1.3 */\n\t/*\t{ 0x0C, \"ReactiveAuthStatus\" }, - removed in WV 1.3 */\n\t/*\t{ 0x0D, \"ReactiveAuthStatusList\" }, - removed in WV 1.3 */\n\t{ 0x0E, \"Watcher\" },\n\t{ 0x0F, \"WatcherStatus\" },\n\t/* New in WV-CSP 1.3 */\n\t{ 0x1B, \"AnswerOption\"},\n\t{ 0x1C, \"AnswerOptionID\" },\n\t{ 0x1D, \"AnswerOptions\"},\n\t{ 0x0B, \"AnswerOptionText\"},\n\t{ 0x1E, \"ApplicationID\"},\n\t{ 0x1F, \"AuthorizeAndGrant\"},\n\t{ 0x20, \"ChosenOptionID\"},\n\t{ 0x19, \"ClearPublicProfile\"},\n\t{ 0x13, \"Color\"},\n\t{ 0x21, \"ContactListNotify\"},\n\t{ 0x14, \"ContentName\"},\n\t{ 0x22, \"DefaultNotify\"},\n\t{ 0x39, \"ExtBlockETEM\"},\n\t{ 0x36, \"ExtendConversationID\"},\n\t{ 0x23, \"ExtendConversationUser\"},\n\t{ 0x10, \"Font\"},\n\t{ 0x18, \"FriendlyName\"},\n\t{ 0x34 , \"GetMap-Request\"},\n\t{ 0x35, \"GetMap-Response\"},\n\t{ 0x3A, \"GroupContentLimit\" },\n\t{ 0x24, \"InText\"},\n\t{ 0x15, \"Map\"},\n\t{ 0x3B, \"MessageTotalCount\"},\n\t{ 0x16, \"NotificationType\"},\n\t{ 0x17, \"NotificationTypeList\"},\n\t{ 0x1A, \"PublicProfile\"},\n\t{ 0x38, \"RequiresResponse\"},\n\t{ 0x25, \"SegmentCount\"},\n\t{ 0x26, \"SegmentID\"\t},\n\t{ 0x27, \"SegmentInfo\"},\n\t{ 0x28, \"SegmentReference\"},\n\t{ 0x11, \"Size\"},\n\t{ 0x12, \"Style\"\t},\n\t{ 0x29, \"SystemMessage\"},\n\t{ 0x2A, \"SystemMessageID\"},\n\t{ 0x2B, \"SystemMessageList\"},\n\t{ 0x2C, \"SystemMessageResponse\"},\n\t{ 0x2D, \"SystemMessageResponseList\" },\n\t{ 0x2F, \"SystemMessageText\"},\n\t{ 0x30, \"TryAgainTimeout\"},\n\t{ 0x3C, \"UnrecognizedUserID\"},\n\t{ 0x3F , \"UserIDList\"},\n\t{ 0x3D, \"UserIDPair\"},\n\t{ 0x31, \"UserNotify\"},\n\t{ 0x3E, \"ValidUserID\"},\n\t{ 0x32, \"VerificationKey\"},\n\t{ 0x33, \"VerificationMechanism\"},\n\t{ 0x37, \"WatcherCount\"},\n\n\t{ 0x00, NULL }\n};\n\n/* Access code page - continued (0x0A) */\nstatic const value_string wbxml_wv_csp_13_tags_cp10[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t/* New in WV-CSP 1.2 */\n\t{ 0x05, \"WV-CSP-NSDiscovery-Request\" },\n\t{ 0x06, \"WV-CSP-NSDiscovery-Response\" },\n\t{ 0x07, \"VersionList\"},\n\t/* New in WV-CSP 1.3 */\n\t{ 0x08, \"SubscribeNotification-Request\" },\n\t{ 0x09, \"UnsubscribeNotification-Request\" },\n\t{ 0x0A, \"Notification-Request\" },\n\t{ 0x0B, \"AdvancedCriteria\" },\n\t{ 0x0C, \"PairID\" },\n\t{ 0x0D, \"GetPublicProfile-Request\" },\n\t{ 0x0E, \"GetPublicProfile-Response\" },\n\t{ 0x0F, \"UpdatePublicProfile-Request\" },\n\t{ 0x10, \"DropSegment-Request\" },\n\t{ 0x11, \"ExtendConversation-Response\" },\n\t{ 0x12, \"ExtendConversation-Request\" },\n\t{ 0x13, \"GetSegment-Request\" },\n\t{ 0x14, \"GetSegment-Response\" },\n\t{ 0x15, \"SystemMessage-Request\" },\n\t{ 0x16, \"SystemMessage-User\" },\n\t{ 0x17, \"SearchPair\" },\n\t{ 0x18, \"SegmentContent\" },\n\n\t{ 0x00, NULL }\n};\n\n/* Common code page - continued (0x0B) */\nstatic const value_string wbxml_wv_csp_13_tags_cp11[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t/* New in WV-CSP 1.3 */\n\t{ 0x05, \"GrantListInUse\" },\n\t{ 0x06, \"BlockListInUse\" },\n\t{ 0x07, \"ContactListIDList\" },\n\t{ 0x08, \"AnswerOptionsText\" },\n\n\t{ 0x00, NULL }\n};\n\n\n/*****    Attribute Start tokens   *****/\n/* Common code page (0x00) */\nstatic const value_string wbxml_wv_csp_13_attrStart_cp0[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"xmlns='http://www.wireless-village.org/CSP'\" },\n\t{ 0x06, \"xmlns='http://www.wireless-village.org/PA'\" },\n\t{ 0x07, \"xmlns='http://www.wireless-village.org/TRC'\" },\n\t/* New in WV-CSP 1.2 */\n\t{ 0x08, \"xmlns='http://www.openmobilealliance.org/DTD/WV-CSP'\" },\n\t{ 0x09, \"xmlns='http://www.openmobilealliance.org/DTD/WV-PA'\" },\n\t{ 0x0A, \"xmlns='http://www.openmobilealliance.org/DTD/WV-TRC'\" },\n\t/* New in WV-CSP 1.3 */\n\t{ 0x0B, \"xmlns='http://www.openmobilealliance.org/DTD/IMPS-CSP'\" },\n\t{ 0x0C, \"xmlns='http://www.openmobilealliance.org/DTD/IMPS-PA'\" },\n\t{ 0x0D, \"xmlns='http://www.openmobilealliance.org/DTD/IMPS-TRC'\" },\n\n\t{ 0x00, NULL }\n};\n\n/*****    Attribute Value tokens   *****/\n/*\n * Element value tokens\n */\nstatic const value_string vals_wv_csp_13_element_value_tokens[] = {\n\t/*\n\t * Common value tokens\n\t */\n\t{ 0x52, \"AC\" },\n\t{ 0x00, \"AccessType\" },\n\t{ 0x01, \"ActiveUsers\" },\n\t{ 0x02, \"Admin\" },\n\t{ 0x3C, \"ANC\" },\n\t{ 0x51, \"AND\" },\n\t{ 0x5A, \"ANU\" },\n\t{ 0x68, \"AP\" },\n\t{ 0x03, \"application/\" },\n\t{ 0x04, \"application/vnd.wap.mms-message\" },\n\t{ 0x05, \"application/x-sms\" },\n\t{ 0x8F, \"Aqua\" },\n\t{ 0x90, \"ATCL\" },\n\t{ 0x31, \"AutoDelete\" },\n\t{ 0x06, \"AutoJoin\" },\n\t{ 0x07, \"BASE64\" },\n\t{ 0x7B, \"Big\" },\n\t{ 0x80, \"Black\" },\n\t{ 0x53, \"BLC\" },\n\t{ 0x54, \"BLUC\" },\n\t{ 0x8D, \"Blue\" },\n\t{ 0x7D, \"Bold\" },\n\t{ 0xBC, \"C\" },\n\t{ 0x91, \"CLC\" },\n\t{ 0x55, \"CLCR\" },\n\t{ 0x56, \"CLD\" },\n\t{ 0x08, \"Closed\" },\n\t{ 0xBD, \"CURRENT_SUBSCRIBER\" },\n\t{ 0x09, \"Default\" },\n\t{ 0x34, \"DENIED\" },\n\t{ 0xAB, \"DETECT\" },\n\t{ 0x0A, \"DisplayName\" },\n\t{ 0xA6, \"DoNotNotify\" },\n\t{ 0xA0, \"EC\" },\n\t{ 0xBA, \"EG\" },\n\t{ 0x0B, \"F\" },\n\t{ 0xAC, \"FORKALL\" },\n\t{ 0xBE, \"FORMER_SUBSCRIBER\" },\n\t{ 0x87, \"Fuchsia\" },\n\t{ 0x0C, \"G\" },\n\t{ 0x57, \"GC\" },\n\t{ 0x58, \"GD\" },\n\t{ 0x59, \"GLC\" },\n\t{ 0xA1, \"GLUC\" },\n\t{ 0x32, \"GM\" },\n\t{ 0xA7, \"GMAU\" },\n\t{ 0xA8, \"GMG\" },\n\t{ 0xA9, \"GMR\" },\n\t{ 0xAA, \"GMU\" },\n\t{ 0x0D, \"GR\" },\n\t{ 0x35, \"GRANTED\" },\n\t{ 0x82, \"Gray\" },\n\t{ 0x88, \"Green\" },\n\t{ 0x3D, \"History\" },\n\t{ 0x0E, \"http://\" },\n\t{ 0x0F, \"https://\" },\n\t{ 0x7C, \"Huge\" },\n\t{ 0xA2, \"IA\" },\n\t{ 0xA3, \"IC\" },\n\t{ 0x10, \"image/\" },\n\t{ 0x11, \"Inband\" },\n\t{ 0x12, \"IM\" },\n\t{ 0x9F, \"IR\" },\n\t{ 0x7E, \"Italic\" },\n\t{ 0x89, \"Lime\" },\n\t{ 0x84, \"Maroon\" },\n\t{ 0x13, \"MaxActiveUsers\" },\n\t{ 0x7A, \"Medium\" },\n\t{ 0xBB, \"MinimumAge\" },\n\t{ 0x14, \"Mod\" },\n\t{ 0x15, \"Name\" },\n\t{ 0x8C, \"Navy\" },\n\t{ 0x16, \"None\" },\n\t{ 0x17, \"N\" },\n\t{ 0xAD, \"OEU\" },\n\t{ 0x8A, \"Olive\" },\n\t{ 0x18, \"Open\" },\n\t{ 0x19, \"Outband\" },\n\t{ 0x36, \"PENDING\" },\n\t{ 0x3A, \"PPU\" },\n\t{ 0x1A, \"PR\" },\n\t{ 0xBF, \"PRESENCE_ACCESS\" },\n\t{ 0x1B, \"Private\" },\n\t{ 0x1C, \"PrivateMessaging\" },\n\t{ 0x1D, \"PrivilegeLevel\" },\n\t{ 0x1E, \"Public\" },\n\t{ 0x86, \"Purple\" },\n\t{ 0x1F, \"P\" },\n\t{ 0xC0, \"R\" },\n\t{ 0x85, \"Red\" },\n\t{ 0x20, \"Request\" },\n\t{ 0x21, \"Response\" },\n\t{ 0x22, \"Restricted\" },\n\t{ 0x38, \"RequireInvitation\" },\n\t{ 0x23, \"ScreenName\" },\n\t{ 0x24, \"Searchable\" },\n\t{ 0x25, \"S\" },\n\t{ 0x26, \"SC\" },\n\t{ 0xAE, \"SERVERLOGIC\" },\n\t{ 0x37, \"ShowID\" },\n\t{ 0x81, \"Silver\" },\n\t{ 0x79, \"Small\" },\n\t{ 0x3B, \"SPA\" },\n\t{ 0x8E, \"Teal\" },\n\t{ 0x27, \"text/\" },\n\t{ 0x28, \"text/plain\" },\n\t{ 0x29, \"text/x-vCalendar\" },\n\t{ 0x2A, \"text/x-vCard\" },\n\t{ 0x39, \"Tiny\" },\n\t{ 0x2B, \"Topic\" },\n\t{ 0x2C, \"T\" },\n\t{ 0x2D, \"Type\" },\n\t{ 0x2E, \"U\" },\n\t{ 0x7F, \"Underline\" },\n\t{ 0x2F, \"US\" },\n\t{ 0x33, \"Validity\" },\n\t{ 0x83, \"White\" },\n\t{ 0x78, \"www.openmobilealliance.org\" },\n\t{ 0x30, \"www.wireless-village.org\" },\n\t{ 0x8B, \"Yellow\" },\n\t/*\n\t * Access value tokens\n\t */\n\t{ 0x3D, \"GROUP_ID\" },\n\t{ 0x3E, \"GROUP_NAME\" },\n\t{ 0x3F, \"GROUP_TOPIC\" },\n\t{ 0x40, \"GROUP_USER_ID_JOINED\" },\n\t{ 0x41, \"GROUP_USER_ID_OWNER\" },\n\t{ 0x42, \"HTTP\" },\n\t{ 0x43, \"SMS\" },\n\t{ 0x44, \"STCP\" },\n\t{ 0x45, \"SUDP\" },\n\t{ 0x46, \"USER_ALIAS\" },\n\t{ 0x47, \"USER_EMAIL_ADDRESS\" },\n\t{ 0x48, \"USER_FIRST_NAME\" },\n\t{ 0x49, \"USER_ID\" },\n\t{ 0x4A, \"USER_LAST_NAME\" },\n\t{ 0x4B, \"USER_MOBILE_NUMBER\" },\n\t{ 0x4C, \"USER_ONLINE_STATUS\" },\n\t{ 0x4D, \"WAPSMS\" },\n\t{ 0x4E, \"WAPUDP\" },\n\t{ 0x4F, \"WSP\" },\n\t{ 0x50, \"GROUP_USER_ID_AUTOJOIN\" },\n\t/*\n\t * Presence value tokens\n\t */\n\t{ 0x5B, \"ANGRY\" },\n\t{ 0x5C, \"ANXIOUS\" },\n\t{ 0x5D, \"ASHAMED\" },\n\t{ 0x5F, \"AVAILABLE\" },\n\t{ 0x60, \"BORED\" },\n\t{ 0x61, \"CALL\" },\n\t{ 0x62, \"CLI\" },\n\t{ 0x63, \"COMPUTER\" },\n\t{ 0x64, \"DISCREET\" },\n\t{ 0x65, \"EMAIL\" },\n\t{ 0x66, \"EXCITED\" },\n\t{ 0x67, \"HAPPY\" },\n\t{ 0x6B, \"IN_LOVE\" },\n\t{ 0x6C, \"INVINCIBLE\" },\n\t{ 0x6D, \"JEALOUS\" },\n\t{ 0x6E, \"MMS\" },\n\t{ 0x6F, \"MOBILE_PHONE\" },\n\t{ 0x70, \"NOT_AVAILABLE\" },\n\t{ 0x71, \"OTHER\" },\n\t{ 0x72, \"PDA\" },\n\t{ 0x73, \"SAD\" },\n\t{ 0x74, \"SLEEPY\" },\n\t{ 0x75, \"SMS\" },\n\t/*\n\t * Access value tokens - continued\n\t */\n\t{ 0x93, \"USER_CITY\" },\n\t{ 0x94, \"USER_COUNTRY\" },\n\t{ 0x95, \"USER_FRIENDLY_NAME\" },\n\t{ 0x96, \"USER_GENDER\" },\n\t{ 0x97, \"USER_INTENTION\" },\n\t{ 0x98, \"USER_INTERESTS_HOBBIES\" },\n\t{ 0x99, \"USER_MARITAL_STATUS\" },\n\t{ 0x9A, \"PRIORITYREJECT\" },\n\t{ 0x9B, \"PRIORITYSTORE\" },\n\t{ 0x9C, \"REJECT\" },\n\t{ 0x9D, \"SENDREJECT\" },\n\t{ 0x9E, \"SENDSTORE\" },\n\t{ 0xA4, \"SSMS\" },\n\t{ 0xA5, \"SHTTP\" },\n\t{ 0xAF, \"PP_AGE\" },\n\t{ 0xB0, \"PP_CITY\" },\n\t{ 0xB1, \"PP_COUNTRY\" },\n\t{ 0xB2, \"PP_FRIENDLY_NAME\" },\n\t{ 0xB3, \"PP_FREE_TEXT\" },\n\t{ 0xB4, \"PP_GENDER\" },\n\t{ 0xB5, \"PP_INTENTION\" },\n\t{ 0xB6, \"PP_INTERESTS\" },\n\t{ 0xB7, \"PP_MARITAL_STATUS\" },\n\t{ 0xB8, \"USER_AGE_MAX\" },\n\t{ 0xB9, \"USER_AGE_MIN\" },\n\n\t{ 0x00, NULL }\n};\n\n/***** Token code page aggregation *****/\nstatic char *\next_t_0_wv_cspc_13(tvbuff_t *tvb _U_, guint32 value, guint32 str_tbl _U_)\n{\n\tchar *str = wmem_strdup_printf(wmem_packet_scope(), \"Common Value: '%s'\",\n\t\t\t\t    val_to_str(value, vals_wv_csp_13_element_value_tokens,\n\t\t\t\t\t       \"<Unknown WV-CSP 1.3 Common Value token 0x%X>\"));\n\treturn str;\n}\n\n#define wbxml_wv_csp_13_global wbxml_wv_csp_12_global\t\t/*TODO*/\n\nstatic const value_valuestring wbxml_wv_csp_13_tags[] = {\n\t{  0, wbxml_wv_csp_13_tags_cp0 },\n\t{  1, wbxml_wv_csp_13_tags_cp1 },\n\t{  2, wbxml_wv_csp_13_tags_cp2 },\n\t{  3, wbxml_wv_csp_13_tags_cp3 },\n\t{  4, wbxml_wv_csp_13_tags_cp4 },\n\t{  5, wbxml_wv_csp_13_tags_cp5 },\n\t{  6, wbxml_wv_csp_13_tags_cp6 },\n\t{  7, wbxml_wv_csp_13_tags_cp7 },\n\t{  8, wbxml_wv_csp_13_tags_cp8 },\n\t{  9, wbxml_wv_csp_13_tags_cp9 },\n\t{ 10, wbxml_wv_csp_13_tags_cp10 },\n\t{ 11, wbxml_wv_csp_13_tags_cp11 },\n\t{  0, NULL }\n};\n\nstatic const value_valuestring wbxml_wv_csp_13_attrStart[] = {\n\t{ 0, wbxml_wv_csp_13_attrStart_cp0 },\n\t{ 0, NULL }\n};\n\nstatic const wbxml_decoding decode_wv_cspc_13 = {\n\t\"Wireless-Village Client-Server Protocol 1.3\",\n\t\"WV-CSP 1.3\",\n\t{ ext_t_0_wv_cspc_13, NULL, NULL },\n\twv_csp13_opaque_binary_tag,\n\twv_csp13_opaque_literal_tag,\n\tdefault_opaque_binary_attr,\n\tdefault_opaque_literal_attr,\n\twbxml_wv_csp_13_global,\n\twbxml_wv_csp_13_tags,\n\twbxml_wv_csp_13_attrStart,\n\tNULL\n};\n\n\n\n\n\n/****************************** Discriminators ******************************/\n/* Discriminator for WV-CSP; allows version detection based on parsing parts\n * of the start of the WBXML body.\n */\nstatic const wbxml_decoding *\nwv_csp_discriminator(tvbuff_t *tvb, guint32 offset)\n{\n\tguint32 magic_1 = tvb_get_ntohl(tvb, offset + 0);\n\tguint16 magic_2 = tvb_get_ntohs(tvb, offset + 4);\n\n\tif (magic_1 == 0xFE050331 && magic_2 == 0x2e30)\n\t\t{\n\t\t\t/* FE 05 03 31 2E 30 --> WV-CSP 1.0 */\n\t\t\treturn &decode_wv_cspc_10;\n\t\t}\n\telse if (magic_1 == 0xC9050331 && magic_2 == 0x2e31)\n\t\t{\n\t\t\t/* C9 05 03 31 2E 31 --> WV-CSP 1.1 */\n\t\t\treturn &decode_wv_cspc_11;\n\t\t}\n\telse if (magic_1 == 0xC9080331 && magic_2 == 0x2e32)\n\t\t{\n\t\t\t/* C9 08 03 31 2E 32 --> WV-CSP 1.2 */\n\t\t\treturn &decode_wv_cspc_12;\n\t\t}\n\telse if ( magic_1 == 0xC90B0331 && magic_2 == 0x2E33)\n\t\t{\n\t\t\t/* C9 0B 03 31 2E 33 --> WV-CSP 1.3 */\n\t\t\treturn &decode_wv_cspc_13;\n\t\t}\n\n\n\t/* Default: WV-CSP 1.2 */\n\treturn &decode_wv_cspc_12;\n}\n\n/********************** WBXML token mapping aggregation **********************/\n\nstatic const wbxml_decoding *get_wbxml_decoding_from_public_id (guint32 publicid);\nstatic const wbxml_decoding *get_wbxml_decoding_from_content_type (\n\t\t\t\t\t\t\t\t   const char *content_type, tvbuff_t *tvb, guint32 offset);\n\n\n/**\n ** Aggregation of content type and aggregated code pages\n ** Content type map lookup will stop at the 1st entry with 3rd member = FALSE\n **/\n\n/*\n * The following map contains entries registered with a registered WBXML\n * public ID. See WAP WINA or OMA OMNA for registered values:\n * http://www.openmobilealliance.org/tech/omna/ */\n static const wbxml_integer_list well_known_public_id_list[] = {\n\t /* 0x00 - Unknown or missing Public ID */\n\t /* 0x01 - LITERAL PublicID - see String Table */\n\t { 0x02,\t&decode_wmlc_10 },\t/* WML 1.0 */\n\t /* 0x03 - WTA 1.0 */\n\t { 0x04,\t&decode_wmlc_11 },\t/* WML 1.1 */\n\t { 0x05,\t&decode_sic_10 },\t/* SI 1.0 */\n\t { 0x06,\t&decode_slc_10 },\t/* SL 1.0 */\n\t { 0x07,\t&decode_coc_10 },\t/* CO 1.0 */\n\t { 0x08,\t&decode_channelc_10 },\t/* CHANNEL 1.0 */\n\t { 0x09,\t&decode_wmlc_12 },\t/* WML 1.2 */\n\t { 0x0A,\t&decode_wmlc_13 },\t/* WML 1.3 */\n\t { 0x0B,\t&decode_provc_10 },\t/* PROV 1.0 */\n\t /* 0x0C - WTA-WML 1.2 */\n\t { 0x0D,\t&decode_emnc_10 },\t/* EMN 1.0 */\n\t /* 0x0E - DRMREL 1.0 */\n\t { 0x0F,\t&decode_wv_cspc_10 },\t/* WV-CSP 1.0 */\n\t { 0x10,\t&decode_wv_cspc_11 },\t/* WV-CSP 1.1 */\n\t /*See http://www.openmobilealliance.org/tech/omna/omna-wbxml-public-docid.htm */\n\t { 0x11,\t&decode_wv_cspc_12 },\t/* OMA IMPS - CSP protocol DTD v1.2 */\n\t { 0x12,\t&decode_wv_cspc_13 },\t/* OMA IMPS - CSP protocol DTD v1.3 */\n\t { 0x020B,\t&decode_nokiaprovc_70 },/* Nokia OTA Provisioning 7.0 */\n\t { 0x0FD1,\t&decode_syncmlc_10 },\t/* SyncML 1.0 */\n\t { 0x0FD3,\t&decode_syncmlc_11 },\t/* SyncML 1.1 */\n\t /* Note: I assumed WML+ 1.x would be not that different from WML 1.x,\n\t  *       the real mapping should come from Phone.com (OpenWave)! */\n\t { 0x1108,\t&decode_wmlc_11 },\t/* Phone.com WMLC+ 1.1 - not 100% correct */\n\t { 0x110D,\t&decode_wmlc_13 },\t/* Phone.com WMLC+ 1.3 - not 100% correct */\n\n\t { 0x1201,\t&decode_syncmlc_12 },\t/* SyncML 1.2 */\n\n\t { 0x00,\tNULL }\n };\n\n/* The following map contains entries only registered with a literal media\n * type. */\nstatic const wbxml_literal_list content_type_list[] = {\n\t{\t\"application/x-wap-prov.browser-settings\",\n\t\tNULL,\n\t\t&decode_nokiaprovc_70\n\t},\n\t{\t\"application/x-wap-prov.browser-bookmarks\",\n\t\tNULL,\n\t\t&decode_nokiaprovc_70\n\t},\n\t{\t\"application/vnd.wv.csp.wbxml\",\n\t\twv_csp_discriminator,\n\t\t&decode_wv_cspc_11\n\t},\n\t{\t\"application/vnd.ms-sync.wbxml\",\n\t\tNULL,\n\t\t&decode_mssync_10\n\t},\n\t{\t\"application/vnd.ms-sync\",\n\t\tNULL,\n\t\t&decode_mssync_10\n\t},\n\t{\tNULL, NULL, NULL }\n};\n\n\n/* Returns a pointer to the WBXML token map for the given WBXML public\n * identifier value (see WINA for a table with defined identifiers). */\nstatic const wbxml_decoding *get_wbxml_decoding_from_public_id (guint32 public_id)\n{\n\tconst wbxml_decoding *map = NULL;\n\n\tDebugLog((\"get_wbxml_decoding_from_public_id: public_id = %u\\n\",\n\t\t  public_id));\n\tif (public_id >= 2) {\n\t\tconst wbxml_integer_list *item = well_known_public_id_list;\n\n\t\twhile (item && item->public_id && item->map) {\n\t\t\tif (item->public_id == public_id) {\n\t\t\t\tmap = item->map;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\titem++;\n\t\t}\n\t}\n\treturn map;\n}\n\nstatic const wbxml_decoding *get_wbxml_decoding_from_content_type (\n\t\t\t\t\t\t\t\t   const char *content_type, tvbuff_t *tvb, guint32 offset)\n{\n\tconst wbxml_decoding *map = NULL;\n\n\tDebugLog((\"get_wbxml_decoding_from_content_type: content_type = [%s]\\n\",\n\t\t  content_type));\n\tif (content_type && content_type[0]) {\n\t\tconst wbxml_literal_list *item = content_type_list;\n\n\t\twhile (item && item->content_type) {\n\t\t\tif (g_ascii_strcasecmp(content_type, item->content_type) == 0) {\n\t\t\t\t/* Try the discriminator */\n\t\t\t\tif (item->discriminator != NULL) {\n\t\t\t\t\tmap = item->discriminator(tvb, offset);\n\t\t\t\t}\n\t\t\t\tif (map == NULL) {\n\t\t\t\t\tmap = item->map;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\titem++;\n\t\t}\n\t}\n\treturn map;\n}\n\n\n/* WBXML content token mapping depends on the following parameters:\n *   - Content type (guint32)\n *   - Token type (global, tags, attrStart, attrValue)\n *   - Code page for tag and attribute\n *\n * This results in the following steps:\n *   1. Retrieve content type mapping\n *   2. If exists, retrieve token type mapping\n *   3. If exists, retrieve required code page\n *   4. If exists, retrieve token mapping\n */\n\n#define wbxml_UNDEFINED_TOKEN                   \\\n\t\"(Requested token not defined for this content type)\"\n#define wbxml_UNDEFINED_TOKEN_CODE_PAGE         \\\n\t\"(Requested token code page not defined for this content type)\"\n#define wbxml_UNDEFINED_TOKEN_MAP               \\\n\t\"(Requested token map not defined for this content type)\"\n/* Return token mapping for a given content mapping entry. */\nstatic const char *\nmap_token (const value_valuestring *token_map, guint8 codepage, guint8 token) {\n\tconst value_string *vs;\n\tconst char         *s;\n\n\tif (token_map) { /* Found map */\n\t\tif ((vs = val_to_valstr (codepage, token_map))) {\n\t\t\t/* Found codepage map */\n\t\t\ts = try_val_to_str (token, vs);\n\t\t\tif (s) { /* Found valid token */\n\t\t\t\tDebugLog((\"map_token(codepage = %u, token = %u: [%s]\\n\", codepage, token, s));\n\t\t\t\treturn s;\n\t\t\t}\n\t\t\t/* No valid token mapping in specified code page of token map */\n\t\t\tDebugLog((\"map_token(codepage = %u, token = %u: \"\n\t\t\t\t  wbxml_UNDEFINED_TOKEN \"\\n\", codepage, token));\n\t\t\treturn wbxml_UNDEFINED_TOKEN;\n\t\t}\n\t\t/* There is no token map entry for the requested code page */\n\t\tDebugLog((\"map_token(codepage = %u, token = %u: \"\n\t\t\t  wbxml_UNDEFINED_TOKEN_CODE_PAGE \"\\n\", codepage, token));\n\t\treturn wbxml_UNDEFINED_TOKEN_CODE_PAGE;\n\t}\n\t/* The token map does not exist */\n\tDebugLog((\"map_token(codepage = %u, token = %u: \"\n\t\t  wbxml_UNDEFINED_TOKEN_MAP \"\\n\", codepage, token));\n\treturn wbxml_UNDEFINED_TOKEN_MAP;\n}\n\n\n\n\n\n/************************** Function prototypes **************************/\n\n\nstatic void\ndissect_wbxml(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree);\n\nstatic void\ndissect_uaprof(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree);\n\nstatic void\ndissect_wbxml_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\n\t\t     const wbxml_decoding *override_content_map);\n\n/* Parse and display the WBXML string table */\nstatic void\nshow_wbxml_string_table (proto_tree *tree, tvbuff_t *tvb, guint32 str_tbl,\n\t\t\t guint32 str_tbl_len);\n\n/* Parse data while in STAG state */\nstatic guint32\nparse_wbxml_tag (proto_tree *tree, tvbuff_t *tvb, guint32 offset,\n\t\t guint32 str_tbl, guint8 *level, guint8 *codepage_stag, guint8 *codepage_attr);\n\n/* Parse data while in STAG state;\n * interpret tokens as defined by content type */\nstatic guint32\nparse_wbxml_tag_defined (proto_tree *tree, tvbuff_t *tvb, guint32 offset,\n\t\t\t guint32 str_tbl, guint8 *level, guint8 *codepage_stag, guint8 *codepage_attr,\n\t\t\t const wbxml_decoding *map);\n\n/* Parse data while in ATTR state */\nstatic guint32\nparse_wbxml_attribute_list (proto_tree *tree, tvbuff_t *tvb,\n\t\t\t    guint32 offset, guint32 str_tbl, guint8 level, guint8 *codepage_attr);\n\n/* Parse data while in ATTR state;\n * interpret tokens as defined by content type */\nstatic guint32\nparse_wbxml_attribute_list_defined (proto_tree *tree, tvbuff_t *tvb,\n\t\t\t\t    guint32 offset, guint32 str_tbl, guint8 level, guint8 *codepage_attr,\n\t\t\t\t    const wbxml_decoding *map);\n\n\n/****************** WBXML protocol dissection functions ******************/\n\n\nstatic void\ndissect_wbxml(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)\n{\n\tdissect_wbxml_common(tvb, pinfo, tree, NULL);\n}\n\nstatic void\ndissect_uaprof(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)\n{\n\tdissect_wbxml_common(tvb, pinfo, tree, &decode_uaprof_wap_248);\n}\n\n/* Code to actually dissect the packets */\nstatic void\ndissect_wbxml_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\n\t\t     const wbxml_decoding *override_content_map)\n{\n\t/* Set up structures needed to add the protocol subtree and manage it */\n\tproto_item           *ti;\n\tproto_tree           *wbxml_tree;          /* Main WBXML tree */\n\tproto_tree           *wbxml_str_tbl_tree;  /* String table subtree */\n\tproto_tree           *wbxml_content_tree;  /* Content subtree */\n\tguint8                version;\n\tguint                 offset          = 0;\n\tguint32               len;\n\tguint32               charset         = 0;\n\tguint32               charset_len     = 0;\n\tguint32               publicid;\n\tguint32               publicid_index  = 0;\n\tguint32               publicid_len;\n\tguint32               str_tbl;\n\tguint32               str_tbl_len;\n\tguint32               str_tbl_len_len = 0;\n\tguint8                level           = 0; /* WBXML recursion level */\n\tconst wbxml_decoding *content_map     = NULL;\n\tgchar                *summary         = NULL;\n\tguint8                codepage_stag   = 0;\n\tguint8                codepage_attr   = 0;\n\n\tDebugLog((\"dissect_wbxml: Dissecting packet %u\\n\", pinfo->fd->num));\n\t/* WBXML format\n\t *\n\t * Version 1.0: version publicid         strtbl BODY\n\t * Version 1.x: version publicid charset strtbl BODY\n\t *\n\t * Last valid format: WBXML 1.3\n\t */\n\tswitch ( version = tvb_get_guint8 (tvb, 0) ) {\n\tcase 0x00: /* WBXML/1.0 */\n\t\tbreak;\n\n\tcase 0x01: /* WBXML/1.1 */\n\tcase 0x02: /* WBXML/1.2 */\n\tcase 0x03: /* WBXML/1.3 */\n\t\tbreak;\n\n\tdefault:\n\t\t/* Put some information here, so that the user knows what's going on. */\n\n\t\t/* Add summary to INFO column if it is enabled */\n\t\tcol_append_fstr(pinfo->cinfo, COL_INFO, \" (Unknown WBXML version 0x%02x)\", version);\n\t\tti = proto_tree_add_item (tree, proto_wbxml, tvb, 0, -1, ENC_NA);\n\t\tproto_item_append_text(ti, \", Unknown version 0x%02x\", version);\n\t\treturn;\n\t}\n\n\t/* In order to properly construct the packet summary,\n\t * I need to read the entire WBXML header\n\t * up to the string table length.\n\t */\n\n\t/* Public ID */\n\tpublicid = tvb_get_guintvar(tvb, 1, &publicid_len);\n\tif (! publicid) {\n\t\t/* Public identifier in string table */\n\t\tpublicid_index = tvb_get_guintvar (tvb, 1+publicid_len, &len);\n\t\tpublicid_len += len;\n\t}\n\toffset = 1 + publicid_len;\n\n\t/* Version-specific handling of Charset */\n\tswitch ( version ) {\n\tcase 0x00: /* WBXML/1.0 */\n\t\t/* No charset */\n\t\tbreak;\n\n\tcase 0x01: /* WBXML/1.1 */\n\tcase 0x02: /* WBXML/1.2 */\n\tcase 0x03: /* WBXML/1.3 */\n\t\t/* Get charset */\n\t\tcharset = tvb_get_guintvar (tvb, offset, &charset_len);\n\t\toffset += charset_len;\n\t\tbreak;\n\n\tdefault: /* Impossible since we returned already earlier */\n\t\tDISSECTOR_ASSERT_NOT_REACHED();\n\t\tbreak;\n\t}\n\n\t/* String table: read string table length in bytes */\n\ttvb_get_guintvar (tvb, offset, &str_tbl_len_len);\n\tstr_tbl = offset + str_tbl_len_len; /* Start of 1st string in string table */\n\n\t/* Compose the summary line */\n\tif ( publicid ) {\n\t\tsummary = wmem_strdup_printf(wmem_packet_scope(), \"%s, Public ID: \\\"%s\\\"\",\n\t\t\t\t\t  val_to_str_ext (version, &vals_wbxml_versions_ext, \"(unknown 0x%x)\"),\n\t\t\t\t\t  val_to_str_ext (publicid, &vals_wbxml_public_ids_ext, \"(unknown 0x%x)\"));\n\t} else {\n\t\t/* Read length of Public ID from string table */\n\t\tlen = tvb_strsize (tvb, str_tbl + publicid_index);\n\t\tsummary = wmem_strdup_printf(wmem_packet_scope(), \"%s, Public ID: \\\"%s\\\"\",\n\t\t\t\t\t  val_to_str_ext (version, &vals_wbxml_versions_ext, \"(unknown 0x%x)\"),\n\t\t\t\t\t  tvb_format_text (tvb, str_tbl + publicid_index, len - 1));\n\t}\n\n\t/* Add summary to INFO column if it is enabled */\n\tcol_append_fstr(pinfo->cinfo, COL_INFO, \" (WBXML %s)\", summary);\n\n\t/* create display subtree for the protocol */\n\tti = proto_tree_add_item (tree, proto_wbxml, tvb, 0, -1, ENC_NA);\n\tproto_item_append_text(ti, \", Version: %s\", summary);\n\n\t/*\n\t * Now show the protocol subtree, if tree is set.\n\t */\n\tif ( tree ) {\n\t\twbxml_tree = proto_item_add_subtree(ti, ett_wbxml);\n\n\t\t/* WBXML Version */\n\t\tproto_tree_add_uint (wbxml_tree, hf_wbxml_version,\n\t\t\t\t     tvb, 0, 1, version);\n\n\t\t/* Public ID */\n\t\tif (publicid) { /* Known Public ID */\n\t\t\tproto_tree_add_uint(wbxml_tree, hf_wbxml_public_id_known,\n\t\t\t\t\t    tvb, 1, publicid_len, publicid);\n\t\t} else { /* Public identifier in string table */\n\t\t\tproto_tree_add_item (wbxml_tree, hf_wbxml_public_id_literal,\n\t\t\t\t\t     tvb, 1, publicid_len, ENC_ASCII|ENC_NA);\n\t\t}\n\t\toffset = 1 + publicid_len;\n\n\t\tif ( version ) { /* Charset */\n\t\t\tproto_tree_add_uint (wbxml_tree, hf_wbxml_charset,\n\t\t\t\t\t     tvb, 1 + publicid_len, charset_len, charset);\n\t\t\toffset += charset_len;\n\t\t}\n\n\t\tstr_tbl_len = tvb_get_guintvar (tvb, offset, &len);\n\t\tstr_tbl = offset + len; /* Start of 1st string in string table */\n\n\t\t/* String Table */\n\t\tti = proto_tree_add_text(wbxml_tree,\n\t\t\t\t\t tvb, offset, len + str_tbl_len, \"String table: %u bytes\",\n\t\t\t\t\t str_tbl_len);\n\n\t\tif (wbxml_tree && str_tbl_len) { /* Display string table as subtree */\n\t\t\twbxml_str_tbl_tree = proto_item_add_subtree (ti,\n\t\t\t\t\t\t\t\t     ett_wbxml_str_tbl);\n\t\t\tshow_wbxml_string_table (wbxml_str_tbl_tree, tvb,\n\t\t\t\t\t\t str_tbl, str_tbl_len);\n\t\t}\n\n\t\t/* Data starts HERE */\n\t\toffset += len + str_tbl_len;\n\n\t\t/* The WBXML BODY starts here */\n\t\tif (disable_wbxml_token_parsing) {\n\t\t\tproto_tree_add_text (wbxml_tree, tvb, offset, -1,\n\t\t\t\t\t\t  \"Data representation not shown \"\n\t\t\t\t\t\t  \"(edit WBXML preferences to show)\");\n\t\t\treturn;\n\t\t} /* Else: render the WBXML tokens */\n\t\tti = proto_tree_add_text (wbxml_tree, tvb, offset, -1,\n\t\t\t\t\t  \"Data representation\");\n\t\twbxml_content_tree = proto_item_add_subtree (ti, ett_wbxml_content);\n\n\t\t/* The parse_wbxml_X() functions will process the content correctly,\n\t\t * irrespective of the WBXML version used. For the WBXML body, this\n\t\t * means that there is a different processing for the global token\n\t\t * RESERVED_2 (WBXML 1.0) or OPAQUE (WBXML 1.x with x > 0).  */\n\t\tif (wbxml_tree) { /* Show only if visible */\n\t\t\tif (override_content_map != NULL) {\n\t\t\t\tcontent_map = override_content_map;\n\t\t\t\tproto_item_append_text(ti,\n\t\t\t\t\t\t       \" is based on: %s\",\n\t\t\t\t\t\t       content_map->name);\n\t\t\t} else {\n\t\t\t\t/* Retrieve the content token mapping if available */\n\t\t\t\tcontent_map = get_wbxml_decoding_from_public_id (publicid);\n\t\t\t\tif (! content_map) {\n\t\t\t\t\tcontent_map = get_wbxml_decoding_from_content_type(\n\t\t\t\t\t\t\t\t\t\t\t   pinfo->match_string, tvb, offset);\n\t\t\t\t\tif (! content_map) {\n\t\t\t\t\t\tproto_tree_add_text (wbxml_content_tree,\n\t\t\t\t\t\t\t\t     tvb, offset, -1,\n\t\t\t\t\t\t\t\t     \"[Rendering of this content type\"\n\t\t\t\t\t\t\t\t     \" not (yet) supported]\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tproto_item_append_text(ti,\n\t\t\t\t\t\t\t\t       \" is based on Content-Type: %s \"\n\t\t\t\t\t\t\t\t       \"(chosen decoding: %s)\",\n\t\t\t\t\t\t\t\t       pinfo->match_string, content_map->name);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (content_map && skip_wbxml_token_mapping) {\n\t\t\t\tproto_tree_add_text (wbxml_content_tree,\n\t\t\t\t\t\t     tvb, offset, -1,\n\t\t\t\t\t\t     \"[Rendering of this content type\"\n\t\t\t\t\t\t     \" has been disabled \"\n\t\t\t\t\t\t     \"(edit WBXML preferences to enable)]\");\n\t\t\t\tcontent_map = NULL;\n\t\t\t}\n\t\t\tproto_tree_add_text (wbxml_content_tree, tvb,\n\t\t\t\t\t     offset, -1,\n\t\t\t\t\t     \"Level | State | Codepage \"\n\t\t\t\t\t     \"| WBXML Token Description         \"\n\t\t\t\t\t     \"| Rendering\");\n\t\t\tif (content_map) {\n\t\t\t\tlen = parse_wbxml_tag_defined (wbxml_content_tree,\n\t\t\t\t\t\t\t       tvb, offset, str_tbl, &level, &codepage_stag,\n\t\t\t\t\t\t\t       &codepage_attr, content_map);\n\t\t\t} else {\n\t\t\t\t/* Default: WBXML only, no interpretation of the content */\n\t\t\t\tlen = parse_wbxml_tag (wbxml_content_tree, tvb, offset,\n\t\t\t\t\t\t       str_tbl, &level, &codepage_stag, &codepage_attr);\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n}\n\n\n/* Parse and display the WBXML string table (in a 3-column table format).\n * This function displays:\n *  - the offset in the string table,\n *  - the length of the string\n *  - the string.\n */\nstatic void\nshow_wbxml_string_table (proto_tree *tree, tvbuff_t *tvb, guint32 str_tbl,\n\t\t\t guint32 str_tbl_len)\n{\n\tguint32 off = str_tbl;\n\tguint32 len = 0;\n\tguint32 end = str_tbl + str_tbl_len;\n\n\tproto_tree_add_text (tree, tvb, off, end,\n\t\t\t     \"Start  | Length | String\");\n\twhile (off < end) {\n\t\tlen = tvb_strsize (tvb, off);\n\t\tproto_tree_add_text (tree, tvb, off, len,\n\t\t\t\t     \"%6d | %6d | '%s'\",\n\t\t\t\t     off - str_tbl, len,\n\t\t\t\t     tvb_format_text (tvb, off, len-1));\n\t\toff += len;\n\t}\n}\n\n\n/* Indentation code is based on a static const array of space characters.\n * At least one single space is returned */\nstatic const char indent_buffer[514] = \" \"\n\t\"                                                                \"\n\t\"                                                                \"\n\t\"                                                                \"\n\t\"                                                                \"\n\t\"                                                                \"\n\t\"                                                                \"\n\t\"                                                                \"\n\t\"                                                                \"\n\t; /* Generate XML indentation (length = 1 + 2 * 256 + 1 for '\\0') */\n\nstatic const char * Indent (guint8 level) {\n\treturn indent_buffer + (512 - 2 * (level));\n}\n\n\n/********************\n * WBXML tag tokens *\n ********************\n *\n * Bit Mask  : Example\n * -------------------\n * 00.. .... : <tag />\n *\n * 01.. .... : <tag>\n *               CONTENT\n *             </tag>\n *\n * 10.. .... : <tag\n *               atrtribute1=\"value1\"\n *               atrtribute2=\"value2\"\n *             />\n *\n * 11.. .... : <tag\n *               atrtribute1=\"value1\"\n *               atrtribute2=\"value2\"\n *             >\n *               CONTENT\n *             </tag>\n *\n * NOTES\n *   - An XML PI is parsed as an attribute list (same syntax).\n *   - A code page switch only applies to the single token that follows.\n */\n\n\n/* This function parses the WBXML and maps known token interpretations\n * to the WBXML tokens. As a result, the original XML document can be\n * recreated. Indentation is generated in order to ease reading.\n *\n * Attribute parsing is done in parse_wbxml_attribute_list_defined().\n *\n * The wbxml_decoding entry *map contains the actual token mapping.\n *\n * NOTE: In order to parse the content, some recursion is required.\n *       However, for performance reasons, recursion has been avoided\n *       where possible (tags without content within tags with content).\n *       This is achieved by means of the parsing_tag_content and tag_save*\n *       variables.\n *\n * NOTE: See above for known token mappings.\n *\n * NOTE: As tags can be opened and closed, a tag representation lookup\n *       may happen once or twice for a given tag. For efficiency reasons,\n *       the literal tag value is stored and used throughout the code.\n *       With the introduction of code page support, this solution is robust\n *       as the lookup only occurs once, removing the need for storage of\n *       the used code page.\n */\nstatic guint32\nparse_wbxml_tag_defined (proto_tree *tree, tvbuff_t *tvb, guint32 offset,\n\t\t\t guint32 str_tbl, guint8 *level, guint8 *codepage_stag, guint8 *codepage_attr,\n\t\t\t const wbxml_decoding *map)\n{\n\tguint32     tvb_len  = tvb_reported_length (tvb);\n\tguint32     off      = offset, last_off;\n\tguint32     len;\n\tguint       str_len;\n\tguint32     ent;\n\tguint32     idx;\n\tguint8      peek;\n\tguint32     tag_len;                     /* Length of the index (uintvar) from a LITERAL tag */\n\tguint8      tag_save_known      = 0;     /* Will contain peek & 0x3F (tag identity) */\n\tguint8      tag_new_known       = 0;     /* Will contain peek & 0x3F (tag identity) */\n\tconst char *tag_save_literal;            /* Will contain the LITERAL tag identity */\n\tconst char *tag_new_literal;             /* Will contain the LITERAL tag identity */\n\tguint8      parsing_tag_content = FALSE; /* Are we parsing content from a\n\t\t\t\t\t            tag with content: <x>Content</x>\n\n\t\t\t\t\t            The initial state is FALSE.\n\t\t\t\t\t            This state will trigger recursion. */\n\ttag_save_literal = NULL;                 /* Prevents compiler warning */\n\n\tDebugLog((\"parse_wbxml_tag_defined (level = %u, offset = %u)\\n\", *level, offset));\n\tlast_off = off;\n\twhile (off < tvb_len) {\n\t\tpeek = tvb_get_guint8 (tvb, off);\n\t\tDebugLog((\"STAG: (top of while) level = %3u, peek = 0x%02X, off = %u, tvb_len = %u\\n\", *level, peek, off, tvb_len));\n\t\tif ((peek & 0x3F) < 4) switch (peek) { /* Global tokens in state = STAG\n\t\t\t\t\t\t\t  but not the LITERAL tokens */\n\t\tcase 0x00: /* SWITCH_PAGE */\n\t\t\t*codepage_stag = tvb_get_guint8 (tvb, off+1);\n\t\t\tproto_tree_add_text (tree, tvb, off, 2,\n\t\t\t\t\t     \"      | Tag   | T -->%3d \"\n\t\t\t\t\t     \"| SWITCH_PAGE (Tag code page)     \"\n\t\t\t\t\t     \"|\",\n\t\t\t\t\t     *codepage_stag);\n\t\t\toff += 2;\n\t\t\tbreak;\n\t\tcase 0x01: /* END: only possible for Tag with Content */\n\t\t\tif (tag_save_known) { /* Known TAG */\n\t\t\t\tproto_tree_add_text (tree, tvb, off, 1,\n\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t\t     \"| END (Known Tag 0x%02X)            \"\n\t\t\t\t\t\t     \"| %s</%s>\",\n\t\t\t\t\t\t     *level, *codepage_stag,\n\t\t\t\t\t\t     tag_save_known, Indent (*level),\n\t\t\t\t\t\t     tag_save_literal); /* We already looked it up! */\n\t\t\t} else { /* Literal TAG */\n\t\t\t\tproto_tree_add_text (tree, tvb, off, 1,\n\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t\t     \"| END (Literal Tag)               \"\n\t\t\t\t\t\t     \"| %s</%s>\",\n\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level),\n\t\t\t\t\t\t     tag_save_literal ? tag_save_literal : \"\");\n\t\t\t}\n\t\t\t(*level)--;\n\t\t\toff++;\n\t\t\t/* Reset code page: not needed as return from recursion */\n\t\t\tDebugLog((\"STAG: level = %u, Return: len = %u\\n\", *level, off - offset));\n\t\t\treturn (off - offset);\n\t\tcase 0x02: /* ENTITY */\n\t\t\tent = tvb_get_guintvar (tvb, off+1, &len);\n\t\t\tproto_tree_add_text (tree, tvb, off, 1+len,\n\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t     \"| ENTITY                          \"\n\t\t\t\t\t     \"| %s'&#%u;'\",\n\t\t\t\t\t     *level, *codepage_stag, Indent (*level), ent);\n\t\t\toff += 1+len;\n\t\t\tbreak;\n\t\tcase 0x03: /* STR_I */\n\t\t\tlen = tvb_strsize (tvb, off+1);\n\t\t\tproto_tree_add_text (tree, tvb, off, 1+len,\n\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t     \"| STR_I (Inline string)           \"\n\t\t\t\t\t     \"| %s\\'%s\\'\",\n\t\t\t\t\t     *level, *codepage_stag, Indent(*level),\n\t\t\t\t\t     tvb_format_text (tvb, off+1, len-1));\n\t\t\toff += 1+len;\n\t\t\tbreak;\n\t\tcase 0x40: /* EXT_I_0 */\n\t\tcase 0x41: /* EXT_I_1 */\n\t\tcase 0x42: /* EXT_I_2 */\n\t\t\t/* Extension tokens */\n\t\t\tlen = tvb_strsize (tvb, off+1);\n\t\t\tproto_tree_add_text (tree, tvb, off, 1+len,\n\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t     \"| EXT_I_%1x    (Extension Token)    \"\n\t\t\t\t\t     \"| %s(%s: \\'%s\\')\",\n\t\t\t\t\t     *level, *codepage_stag,\n\t\t\t\t\t     peek & 0x0f, Indent (*level),\n\t\t\t\t\t     map_token (map->global, 0, peek),\n\t\t\t\t\t     tvb_format_text (tvb, off+1, len-1));\n\t\t\toff += 1+len;\n\t\t\tbreak;\n\t\tcase 0x43: /* PI */\n\t\t\tproto_tree_add_text (tree, tvb, off, 1,\n\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t     \"| PI (XML Processing Instruction) \"\n\t\t\t\t\t     \"| %s<?xml\",\n\t\t\t\t\t     *level, *codepage_stag, Indent (*level));\n\t\t\tlen = parse_wbxml_attribute_list_defined (tree, tvb, off,\n\t\t\t\t\t\t\t\t  str_tbl, *level, codepage_attr, map);\n\t\t\t/* Check that there is still room in packet */\n\t\t\toff += len;\n\t\t\tif (off >= tvb_len) {\n\t\t\t\tDebugLog((\"STAG: level = %u, ThrowException: len = %u (short frame)\\n\", *level, off - offset));\n\t\t\t\t/*\n\t\t\t\t * TODO - Do we need to free g_malloc()ed memory?\n\t\t\t\t */\n\t\t\t\tTHROW(ReportedBoundsError);\n\t\t\t}\n\t\t\tproto_tree_add_text (tree, tvb, off-1, 1,\n\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t     \"| END (PI)                        \"\n\t\t\t\t\t     \"| %s?>\",\n\t\t\t\t\t     *level, *codepage_stag, Indent (*level));\n\t\t\tbreak;\n\t\tcase 0x80: /* EXT_T_0 */\n\t\tcase 0x81: /* EXT_T_1 */\n\t\tcase 0x82: /* EXT_T_2 */\n\t\t\t/* Extension tokens */\n\t\t\tidx = tvb_get_guintvar (tvb, off+1, &len);\n\t\t\t{   char *s;\n\t\t\t\tif (map->ext_t[peek & 0x03])\n\t\t\t\t\ts = (map->ext_t[peek & 0x03])(tvb, idx, str_tbl);\n\t\t\t\telse\n\t\t\t\t\ts = wmem_strdup_printf(wmem_packet_scope(), \"EXT_T_%1x (%s)\", peek & 0x03,\n\t\t\t\t\t\t\t    map_token (map->global, 0, peek));\n\t\t\t\tproto_tree_add_text (tree, tvb, off, 1+len,\n\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t\t     \"| EXT_T_%1x    (Extension Token)    \"\n\t\t\t\t\t\t     \"| %s%s\",\n\t\t\t\t\t\t     *level, *codepage_stag, peek & 0x0f, Indent (*level),\n\t\t\t\t\t\t     s);\n\t\t\t}\n\t\t\toff += 1+len;\n\t\t\tbreak;\n\t\tcase 0x83: /* STR_T */\n\t\t\tidx = tvb_get_guintvar (tvb, off+1, &len);\n\t\t\tstr_len = tvb_strsize (tvb, str_tbl+idx);\n\t\t\tproto_tree_add_text (tree, tvb, off, 1+len,\n\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t     \"| STR_T (Tableref string)         \"\n\t\t\t\t\t     \"| %s\\'%s\\'\",\n\t\t\t\t\t     *level, *codepage_stag, Indent (*level),\n\t\t\t\t\t     tvb_format_text (tvb, str_tbl+idx, str_len-1));\n\t\t\toff += 1+len;\n\t\t\tbreak;\n\t\tcase 0xC0: /* EXT_0 */\n\t\tcase 0xC1: /* EXT_1 */\n\t\tcase 0xC2: /* EXT_2 */\n\t\t\t/* Extension tokens */\n\t\t\tproto_tree_add_text (tree, tvb, off, 1,\n\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t     \"| EXT_%1x      (Extension Token)    \"\n\t\t\t\t\t     \"| %s(%s)\",\n\t\t\t\t\t     *level, *codepage_stag, peek & 0x0f, Indent (*level),\n\t\t\t\t\t     map_token (map->global, 0, peek));\n\t\t\toff++;\n\t\t\tbreak;\n\t\tcase 0xC3: /* OPAQUE - WBXML 1.1 and newer */\n\t\t\tif (tvb_get_guint8 (tvb, 0)) { /* WBXML 1.x (x > 0) */\n\t\t\t\tchar *str;\n\t\t\t\tif (tag_save_known) { /* Knwon tag */\n\t\t\t\t\tif (map->opaque_binary_tag) {\n\t\t\t\t\t\tstr = map->opaque_binary_tag(tvb, off + 1,\n\t\t\t\t\t\t\t\t\t     tag_save_known, *codepage_stag, &len);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstr = default_opaque_binary_tag(tvb, off + 1,\n\t\t\t\t\t\t\t\t\t\ttag_save_known, *codepage_stag, &len);\n\t\t\t\t\t}\n\t\t\t\t} else { /* lITERAL tag */\n\t\t\t\t\tif (map->opaque_literal_tag) {\n\t\t\t\t\t\tstr = map->opaque_literal_tag(tvb, off + 1,\n\t\t\t\t\t\t\t\t\t      tag_save_literal, *codepage_stag, &len);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstr = default_opaque_literal_tag(tvb, off + 1,\n\t\t\t\t\t\t\t\t\t\t tag_save_literal, *codepage_stag, &len);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tproto_tree_add_text (tree, tvb, off, 1 + len,\n\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t\t     \"| OPAQUE (Opaque data)            \"\n\t\t\t\t\t\t     \"| %s%s\",\n\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level), str);\n\t\t\t\toff += 1 + len;\n\t\t\t} else { /* WBXML 1.0 - RESERVED_2 token (invalid) */\n\t\t\t\tproto_tree_add_text (tree, tvb, off, 1,\n\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t\t     \"| RESERVED_2     (Invalid Token!) \"\n\t\t\t\t\t\t     \"| WBXML 1.0 parsing stops here.\",\n\t\t\t\t\t\t     *level, *codepage_stag);\n\t\t\t\t/* Stop processing as it is impossible to parse now */\n\t\t\t\toff = tvb_len;\n\t\t\t\tDebugLog((\"STAG: level = %u, Return: len = %u\\n\", *level, off - offset));\n\t\t\t\treturn (off - offset);\n\t\t\t}\n\t\t\tbreak;\n\n\t\t\t/* No default clause, as all cases have been treated */\n\t\t} else { /* LITERAL or Known TAG */\n\t\t\t/* We must store the initial tag, and also retrieve the new tag.\n\t\t\t * For efficiency reasons, we store the literal tag representation\n\t\t\t * for known tags too, so we can easily close the tag without the\n\t\t\t * need of a new lookup and avoiding storage of token codepage.\n\t\t\t *\n\t\t\t * There are 4 possibilities:\n\t\t\t *\n\t\t\t *  1. Known tag followed by a known tag\n\t\t\t *  2. Known tag followed by a LITERAL tag\n\t\t\t *  3. LITERAL tag followed by Known tag\n\t\t\t *  4. LITERAL tag followed by LITERAL tag\n\t\t\t */\n\n\t\t\t/* Store the new tag */\n\t\t\ttag_len = 0;\n\t\t\tif ((peek & 0x3F) == 4) { /* LITERAL */\n\t\t\t\tDebugLog((\"STAG: LITERAL tag (peek = 0x%02X, off = %u) - TableRef follows!\\n\", peek, off));\n\t\t\t\tidx = tvb_get_guintvar (tvb, off+1, &tag_len);\n\t\t\t\tstr_len = tvb_strsize (tvb, str_tbl+idx);\n\t\t\t\ttag_new_literal = (const gchar*)tvb_get_ptr (tvb, str_tbl+idx, str_len);\n\t\t\t\ttag_new_known = 0; /* invalidate known tag_new */\n\t\t\t} else { /* Known tag */\n\t\t\t\ttag_new_known = peek & 0x3F;\n\t\t\t\ttag_new_literal = map_token (map->tags, *codepage_stag,\n\t\t\t\t\t\t\t     tag_new_known);\n\t\t\t\t/* Stored looked up tag name string */\n\t\t\t}\n\n\t\t\t/* Parsing of TAG starts HERE */\n\t\t\tif (peek & 0x40) { /* Content present */\n\t\t\t\t/* Content follows\n\t\t\t\t * [!] An explicit END token is expected in these cases!\n\t\t\t\t * ==> Recursion possible if we encounter a tag with content;\n\t\t\t\t *     recursion will return at the explicit END token.\n\t\t\t\t */\n\t\t\t\tif (parsing_tag_content) { /* Recurse */\n\t\t\t\t\tDebugLog((\"STAG: Tag in Tag - RECURSE! (off = %u)\\n\", off));\n\t\t\t\t\t/* Do not process the attribute list:\n\t\t\t\t\t * recursion will take care of it */\n\t\t\t\t\t(*level)++;\n\t\t\t\t\tlen = parse_wbxml_tag_defined (tree, tvb, off, str_tbl,\n\t\t\t\t\t\t\t\t       level, codepage_stag, codepage_attr, map);\n\t\t\t\t\toff += len;\n\t\t\t\t} else { /* Now we will have content to parse */\n\t\t\t\t\t/* Save the start tag so we can properly close it later. */\n\t\t\t\t\tif ((peek & 0x3F) == 4) { /* Literal tag */\n\t\t\t\t\t\ttag_save_literal = tag_new_literal;\n\t\t\t\t\t\ttag_save_known = 0;\n\t\t\t\t\t} else { /* Known tag */\n\t\t\t\t\t\ttag_save_known = tag_new_known;\n\t\t\t\t\t\ttag_save_literal = tag_new_literal;\n\t\t\t\t\t\t/* The last statement avoids needless lookups */\n\t\t\t\t\t}\n\t\t\t\t\t/* Process the attribute list if present */\n\t\t\t\t\tif (peek & 0x80) { /* Content and Attribute list present */\n\t\t\t\t\t\tif (tag_new_known) { /* Known tag */\n\t\t\t\t\t\t\tproto_tree_add_text (tree, tvb, off, 1,\n\t\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t\t\t\t\t     \"|   Known Tag 0x%02X           (AC) \"\n\t\t\t\t\t\t\t\t\t     \"| %s<%s\",\n\t\t\t\t\t\t\t\t\t     *level, *codepage_stag, tag_new_known,\n\t\t\t\t\t\t\t\t\t     Indent (*level), tag_new_literal);\n\t\t\t\t\t\t\t/* Tag string already looked up earlier! */\n\t\t\t\t\t\t\toff++;\n\t\t\t\t\t\t} else { /* LITERAL tag */\n\t\t\t\t\t\t\tproto_tree_add_text (tree, tvb, off, 1,\n\t\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t\t\t\t\t     \"| LITERAL_AC (Literal tag)   (AC) \"\n\t\t\t\t\t\t\t\t\t     \"| %s<%s\",\n\t\t\t\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level), tag_new_literal);\n\t\t\t\t\t\t\toff += 1 + tag_len;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlen = parse_wbxml_attribute_list_defined (tree, tvb,\n\t\t\t\t\t\t\t\t\t\t\t  off, str_tbl, *level, codepage_attr, map);\n\t\t\t\t\t\t/* Check that there is still room in packet */\n\t\t\t\t\t\toff += len;\n\t\t\t\t\t\tif (off >= tvb_len) {\n\t\t\t\t\t\t\tDebugLog((\"STAG: level = %u, ThrowException: len = %u (short frame)\\n\",\n\t\t\t\t\t\t\t\t  *level, off - offset));\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * TODO - Do we need to free g_malloc()ed memory?\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tTHROW(ReportedBoundsError);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tproto_tree_add_text (tree, tvb, off-1, 1,\n\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t\t\t\t     \"| END (attribute list)            \"\n\t\t\t\t\t\t\t\t     \"| %s>\",\n\t\t\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level));\n\t\t\t\t\t} else { /* Content, no Attribute list */\n\t\t\t\t\t\tif (tag_new_known) { /* Known tag */\n\t\t\t\t\t\t\tproto_tree_add_text (tree, tvb, off, 1,\n\t\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t\t\t\t\t     \"|   Known Tag 0x%02X           (.C) \"\n\t\t\t\t\t\t\t\t\t     \"| %s<%s>\",\n\t\t\t\t\t\t\t\t\t     *level, *codepage_stag, tag_new_known,\n\t\t\t\t\t\t\t\t\t     Indent (*level), tag_new_literal);\n\t\t\t\t\t\t\t/* Tag string already looked up earlier! */\n\t\t\t\t\t\t\toff++;\n\t\t\t\t\t\t} else { /* LITERAL tag */\n\t\t\t\t\t\t\tproto_tree_add_text (tree, tvb, off, 1,\n\t\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t\t\t\t\t     \"| LITERAL_C  (Literal Tag)   (.C) \"\n\t\t\t\t\t\t\t\t\t     \"| %s<%s>\",\n\t\t\t\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level),\n\t\t\t\t\t\t\t\t\t     tag_new_literal);\n\t\t\t\t\t\t\toff += 1 + tag_len;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t/* The data that follows in the parsing process\n\t\t\t\t\t * represents content for the opening tag\n\t\t\t\t\t * we've just processed in the lines above.\n\t\t\t\t\t * Next time we encounter a tag with content: recurse\n\t\t\t\t\t */\n\t\t\t\t\tparsing_tag_content = TRUE;\n\t\t\t\t\tDebugLog((\"Tag in Tag - No recursion this time! (off = %u)\\n\", off));\n\t\t\t\t}\n\t\t\t} else { /* No Content */\n\t\t\t\tDebugLog((\"<Tag/> in Tag - No recursion! (off = %u)\\n\", off));\n\t\t\t\t(*level)++;\n\t\t\t\tif (peek & 0x80) { /* No Content, Attribute list present */\n\t\t\t\t\tif (tag_new_known) { /* Known tag */\n\t\t\t\t\t\tproto_tree_add_text (tree, tvb, off, 1,\n\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t\t\t\t     \"|   Known Tag 0x%02X           (A.) \"\n\t\t\t\t\t\t\t\t     \"| %s<%s\",\n\t\t\t\t\t\t\t\t     *level, *codepage_stag, tag_new_known,\n\t\t\t\t\t\t\t\t     Indent (*level), tag_new_literal);\n\t\t\t\t\t\t/* Tag string already looked up earlier! */\n\t\t\t\t\t\toff++;\n\t\t\t\t\t\tlen = parse_wbxml_attribute_list_defined (tree, tvb,\n\t\t\t\t\t\t\t\t\t\t\t  off, str_tbl, *level, codepage_attr, map);\n\t\t\t\t\t\t/* Check that there is still room in packet */\n\t\t\t\t\t\toff += len;\n\t\t\t\t\t\tif (off > tvb_len) {\n\t\t\t\t\t\t\tDebugLog((\"STAG: level = %u, ThrowException: len = %u (short frame)\\n\", *level, off - offset));\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * TODO - Do we need to free g_malloc()ed memory?\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tTHROW(ReportedBoundsError);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tproto_tree_add_text (tree, tvb, off-1, 1,\n\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t\t\t\t     \"| END (Known Tag)                 \"\n\t\t\t\t\t\t\t\t     \"| %s/>\",\n\t\t\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level));\n\t\t\t\t\t} else { /* LITERAL tag */\n\t\t\t\t\t\tproto_tree_add_text (tree, tvb, off, 1,\n\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t\t\t\t     \"| LITERAL_A  (Literal Tag)   (A.) \"\n\t\t\t\t\t\t\t\t     \"| %s<%s\",\n\t\t\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level), tag_new_literal);\n\t\t\t\t\t\toff += 1 + tag_len;\n\t\t\t\t\t\tlen = parse_wbxml_attribute_list_defined (tree, tvb,\n\t\t\t\t\t\t\t\t\t\t\t  off, str_tbl, *level, codepage_attr, map);\n\t\t\t\t\t\t/* Check that there is still room in packet */\n\t\t\t\t\t\toff += len;\n\t\t\t\t\t\tif (off >= tvb_len) {\n\t\t\t\t\t\t\tDebugLog((\"STAG: level = %u, ThrowException: len = %u (short frame)\\n\", *level, off - offset));\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * TODO - Do we need to free g_malloc()ed memory?\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tTHROW(ReportedBoundsError);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tproto_tree_add_text (tree, tvb, off-1, 1,\n\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t\t\t\t     \"| END (Literal Tag)               \"\n\t\t\t\t\t\t\t\t     \"| %s/>\",\n\t\t\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level));\n\t\t\t\t\t}\n\t\t\t\t} else { /* No Content, No Attribute list */\n\t\t\t\t\tif (tag_new_known) { /* Known tag */\n\t\t\t\t\t\tproto_tree_add_text (tree, tvb, off, 1,\n\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t\t\t\t     \"|   Known Tag 0x%02x           (..) \"\n\t\t\t\t\t\t\t\t     \"| %s<%s />\",\n\t\t\t\t\t\t\t\t     *level, *codepage_stag, tag_new_known,\n\t\t\t\t\t\t\t\t     Indent (*level), tag_new_literal);\n\t\t\t\t\t\t/* Tag string already looked up earlier! */\n\t\t\t\t\t\toff++;\n\t\t\t\t\t} else { /* LITERAL tag */\n\t\t\t\t\t\tproto_tree_add_text (tree, tvb, off, 1,\n\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t\t\t\t     \"| LITERAL    (Literal Tag)   (..) \"\n\t\t\t\t\t\t\t\t     \"| %s<%s />\",\n\t\t\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level),\n\t\t\t\t\t\t\t\t     tag_new_literal);\n\t\t\t\t\t\toff += 1 + tag_len;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t(*level)--;\n\t\t\t\t/* TODO: Do I have to reset code page here? */\n\t\t\t}\n\t\t} /* if (tag & 0x3F) >= 5 */\n\t\tif (off < last_off) {\n\t\t\tTHROW(ReportedBoundsError);\n\t\t}\n\t\tlast_off = off;\n\t} /* while */\n\tDebugLog((\"STAG: level = %u, Return: len = %u (end of function body)\\n\", *level, off - offset));\n\treturn (off - offset);\n}\n\n\n/* This function performs the WBXML decoding as in parse_wbxml_tag_defined()\n * but this time no WBXML mapping is performed.\n *\n * Attribute parsing is done in parse_wbxml_attribute_list().\n */\nstatic guint32\nparse_wbxml_tag (proto_tree *tree, tvbuff_t *tvb, guint32 offset,\n\t\t guint32 str_tbl, guint8 *level,\n\t\t guint8 *codepage_stag, guint8 *codepage_attr)\n{\n\tguint32     tvb_len             = tvb_reported_length (tvb);\n\tguint32     off                 = offset, last_off;\n\tguint32     len;\n\tguint       str_len;\n\tguint32     ent;\n\tguint32     idx;\n\tguint8      peek;\n\tguint32     tag_len;                     /* Length of the idx (uintvar) from a LITERAL tag */\n\tguint8      tag_save_known      = 0;     /* Will contain peek & 0x3F (tag identity) */\n\tguint8      tag_new_known       = 0;     /* Will contain peek & 0x3F (tag identity) */\n\tconst char *tag_save_literal;            /* Will contain the LITERAL tag identity */\n\tconst char *tag_new_literal;             /* Will contain the LITERAL tag identity */\n\tchar       *tag_save_buf        = NULL;  /* Will contain \"tag_0x%02X\" */\n\tchar       *tag_new_buf         = NULL;  /* Will contain \"tag_0x%02X\" */\n\tguint8      parsing_tag_content = FALSE; /* Are we parsing content from a\n\t\t\t\t\t            tag with content: <x>Content</x>\n\n\t\t\t\t\t            The initial state is FALSE.\n\t\t\t\t\t            This state will trigger recursion. */\n\ttag_save_literal = NULL;                 /* Prevents compiler warning */\n\n\tDebugLog((\"parse_wbxml_tag (level = %u, offset = %u)\\n\", *level, offset));\n\tlast_off = off;\n\twhile (off < tvb_len) {\n\t\tpeek = tvb_get_guint8 (tvb, off);\n\t\tDebugLog((\"STAG: (top of while) level = %3u, peek = 0x%02X, off = %u, tvb_len = %u\\n\", *level, peek, off, tvb_len));\n\t\tif ((peek & 0x3F) < 4) switch (peek) { /* Global tokens in state = STAG\n\t\t\t\t\t\t\t  but not the LITERAL tokens */\n\t\tcase 0x00: /* SWITCH_PAGE */\n\t\t\t*codepage_stag = tvb_get_guint8 (tvb, off+1);\n\t\t\tproto_tree_add_text (tree, tvb, off, 2,\n\t\t\t\t\t     \"      | Tag   | T -->%3d \"\n\t\t\t\t\t     \"| SWITCH_PAGE (Tag code page)     \"\n\t\t\t\t\t     \"|\",\n\t\t\t\t\t     *codepage_stag);\n\t\t\toff += 2;\n\t\t\tbreak;\n\t\tcase 0x01: /* END: only possible for Tag with Content */\n\t\t\tif (tag_save_known) { /* Known TAG */\n\t\t\t\tproto_tree_add_text (tree, tvb, off, 1,\n\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t\t     \"| END (Known Tag 0x%02X)            \"\n\t\t\t\t\t\t     \"| %s</%s>\",\n\t\t\t\t\t\t     *level, *codepage_stag, tag_save_known,\n\t\t\t\t\t\t     Indent (*level),\n\t\t\t\t\t\t     tag_save_literal); /* We already looked it up! */\n\t\t\t} else { /* Literal TAG */\n\t\t\t\tproto_tree_add_text (tree, tvb, off, 1,\n\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t\t     \"| END (Literal Tag)               \"\n\t\t\t\t\t\t     \"| %s</%s>\",\n\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level),\n\t\t\t\t\t\t     tag_save_literal ? tag_save_literal : \"\");\n\t\t\t}\n\t\t\t(*level)--;\n\t\t\toff++;\n\t\t\t/* Reset code page: not needed as return from recursion */\n\t\t\tDebugLog((\"STAG: level = %u, Return: len = %u\\n\",\n\t\t\t\t  *level, off - offset));\n\t\t\treturn (off - offset);\n\t\tcase 0x02: /* ENTITY */\n\t\t\tent = tvb_get_guintvar (tvb, off+1, &len);\n\t\t\tproto_tree_add_text (tree, tvb, off, 1+len,\n\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t     \"| ENTITY                          \"\n\t\t\t\t\t     \"| %s'&#%u;'\",\n\t\t\t\t\t     *level, *codepage_stag, Indent (*level), ent);\n\t\t\toff += 1+len;\n\t\t\tbreak;\n\t\tcase 0x03: /* STR_I */\n\t\t\tlen = tvb_strsize (tvb, off+1);\n\t\t\tproto_tree_add_text (tree, tvb, off, 1+len,\n\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t     \"| STR_I (Inline string)           \"\n\t\t\t\t\t     \"| %s\\'%s\\'\",\n\t\t\t\t\t     *level, *codepage_stag, Indent(*level),\n\t\t\t\t\t     tvb_format_text (tvb, off+1, len-1));\n\t\t\toff += 1+len;\n\t\t\tbreak;\n\t\tcase 0x40: /* EXT_I_0 */\n\t\tcase 0x41: /* EXT_I_1 */\n\t\tcase 0x42: /* EXT_I_2 */\n\t\t\t/* Extension tokens */\n\t\t\tlen = tvb_strsize (tvb, off+1);\n\t\t\tproto_tree_add_text (tree, tvb, off, 1+len,\n\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t     \"| EXT_I_%1x    (Extension Token)    \"\n\t\t\t\t\t     \"| %s(Inline string extension: \\'%s\\')\",\n\t\t\t\t\t     *level, *codepage_stag, peek & 0x0f, Indent (*level),\n\t\t\t\t\t     tvb_format_text (tvb, off+1, len-1));\n\t\t\toff += 1+len;\n\t\t\tbreak;\n\t\tcase 0x43: /* PI */\n\t\t\tproto_tree_add_text (tree, tvb, off, 1,\n\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t     \"| PI (XML Processing Instruction) \"\n\t\t\t\t\t     \"| %s<?xml\",\n\t\t\t\t\t     *level, *codepage_stag, Indent (*level));\n\t\t\tlen = parse_wbxml_attribute_list (tree, tvb, off, str_tbl,\n\t\t\t\t\t\t\t  *level, codepage_attr);\n\t\t\t/* Check that there is still room in packet */\n\t\t\toff += len;\n\t\t\tif (off >= tvb_len) {\n\t\t\t\tDebugLog((\"STAG: level = %u, ThrowException: len = %u (short frame)\\n\",\n\t\t\t\t\t  *level, off - offset));\n\t\t\t\t/*\n\t\t\t\t * TODO - Do we need to free g_malloc()ed memory?\n\t\t\t\t */\n\t\t\t\tTHROW(ReportedBoundsError);\n\t\t\t}\n\t\t\tproto_tree_add_text (tree, tvb, off-1, 1,\n\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t     \"| END (PI)                        \"\n\t\t\t\t\t     \"| %s?>\",\n\t\t\t\t\t     *level, *codepage_stag, Indent (*level));\n\t\t\tbreak;\n\t\tcase 0x80: /* EXT_T_0 */\n\t\tcase 0x81: /* EXT_T_1 */\n\t\tcase 0x82: /* EXT_T_2 */\n\t\t\t/* Extension tokens */\n\t\t\tidx = tvb_get_guintvar (tvb, off+1, &len);\n\t\t\tproto_tree_add_text (tree, tvb, off, 1+len,\n\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t     \"| EXT_T_%1x    (Extension Token)    \"\n\t\t\t\t\t     \"| %s(Extension Token, integer value: %u)\",\n\t\t\t\t\t     *level, *codepage_stag, peek & 0x0f, Indent (*level),\n\t\t\t\t\t     idx);\n\t\t\toff += 1+len;\n\t\t\tbreak;\n\t\tcase 0x83: /* STR_T */\n\t\t\tidx = tvb_get_guintvar (tvb, off+1, &len);\n\t\t\tstr_len = tvb_strsize (tvb, str_tbl+idx);\n\t\t\tproto_tree_add_text (tree, tvb, off, 1+len,\n\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t     \"| STR_T (Tableref string)         \"\n\t\t\t\t\t     \"| %s\\'%s\\'\",\n\t\t\t\t\t     *level, *codepage_stag, Indent (*level),\n\t\t\t\t\t     tvb_format_text (tvb, str_tbl+idx, str_len-1));\n\t\t\toff += 1+len;\n\t\t\tbreak;\n\t\tcase 0xC0: /* EXT_0 */\n\t\tcase 0xC1: /* EXT_1 */\n\t\tcase 0xC2: /* EXT_2 */\n\t\t\t/* Extension tokens */\n\t\t\tproto_tree_add_text (tree, tvb, off, 1,\n\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t     \"| EXT_%1x      (Extension Token)    \"\n\t\t\t\t\t     \"| %s(Single-byte extension)\",\n\t\t\t\t\t     *level, *codepage_stag, peek & 0x0f, Indent (*level));\n\t\t\toff++;\n\t\t\tbreak;\n\t\tcase 0xC3: /* OPAQUE - WBXML 1.1 and newer */\n\t\t\tif (tvb_get_guint8 (tvb, 0)) { /* WBXML 1.x (x > 0) */\n\t\t\t\tidx = tvb_get_guintvar (tvb, off+1, &len);\n\t\t\t\tproto_tree_add_text (tree, tvb, off, 1 + len + idx,\n\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t\t     \"| OPAQUE (Opaque data)            \"\n\t\t\t\t\t\t     \"| %s(%d bytes of opaque data)\",\n\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level), idx);\n\t\t\t\toff += 1+len+idx;\n\t\t\t} else { /* WBXML 1.0 - RESERVED_2 token (invalid) */\n\t\t\t\tproto_tree_add_text (tree, tvb, off, 1,\n\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t\t     \"| RESERVED_2     (Invalid Token!) \"\n\t\t\t\t\t\t     \"| WBXML 1.0 parsing stops here.\",\n\t\t\t\t\t\t     *level, *codepage_stag);\n\t\t\t\t/* Stop processing as it is impossible to parse now */\n\t\t\t\toff = tvb_len;\n\t\t\t\tDebugLog((\"STAG: level = %u, Return: len = %u\\n\",\n\t\t\t\t\t  *level, off - offset));\n\t\t\t\treturn (off - offset);\n\t\t\t}\n\t\t\tbreak;\n\n\t\t\t/* No default clause, as all cases have been treated */\n\t\t} else { /* LITERAL or Known TAG */\n\t\t\t/* We must store the initial tag, and also retrieve the new tag.\n\t\t\t * For efficiency reasons, we store the literal tag representation\n\t\t\t * for known tags too, so we can easily close the tag without the\n\t\t\t * need of a new lookup and avoiding storage of token codepage.\n\t\t\t *\n\t\t\t * There are 4 possibilities:\n\t\t\t *\n\t\t\t *  1. Known tag followed by a known tag\n\t\t\t *  2. Known tag followed by a LITERAL tag\n\t\t\t *  3. LITERAL tag followed by Known tag\n\t\t\t *  4. LITERAL tag followed by LITERAL tag\n\t\t\t */\n\n\t\t\t/* Store the new tag */\n\t\t\ttag_len = 0;\n\t\t\tif ((peek & 0x3F) == 4) { /* LITERAL */\n\t\t\t\tDebugLog((\"STAG: LITERAL tag (peek = 0x%02X, off = %u)\"\n\t\t\t\t\t  \" - TableRef follows!\\n\", peek, off));\n\t\t\t\tidx = tvb_get_guintvar (tvb, off+1, &tag_len);\n\t\t\t\tstr_len = tvb_strsize (tvb, str_tbl+idx);\n\t\t\t\ttag_new_literal = (const gchar*)tvb_get_ptr (tvb, str_tbl+idx, str_len);\n\t\t\t\ttag_new_known = 0; /* invalidate known tag_new */\n\t\t\t} else { /* Known tag */\n\t\t\t\ttag_new_known = peek & 0x3F;\n\t\t\t\ttag_new_buf=wmem_strdup_printf(wmem_packet_scope(), \"Tag_0x%02X\",\n\t\t\t\t\t    tag_new_known);\n\t\t\t\ttag_new_literal = tag_new_buf;\n\t\t\t\t/* Stored looked up tag name string */\n\t\t\t}\n\n\t\t\t/* Parsing of TAG starts HERE */\n\t\t\tif (peek & 0x40) { /* Content present */\n\t\t\t\t/* Content follows\n\t\t\t\t * [!] An explicit END token is expected in these cases!\n\t\t\t\t * ==> Recursion possible if we encounter a tag with content;\n\t\t\t\t *     recursion will return at the explicit END token.\n\t\t\t\t */\n\t\t\t\tif (parsing_tag_content) { /* Recurse */\n\t\t\t\t\tDebugLog((\"STAG: Tag in Tag - RECURSE! (off = %u)\\n\", off));\n\t\t\t\t\t/* Do not process the attribute list:\n\t\t\t\t\t * recursion will take care of it */\n\t\t\t\t\t(*level)++;\n\t\t\t\t\tlen = parse_wbxml_tag (tree, tvb, off, str_tbl, level,\n\t\t\t\t\t\t\t       codepage_stag, codepage_attr);\n\t\t\t\t\toff += len;\n\t\t\t\t} else { /* Now we will have content to parse */\n\t\t\t\t\t/* Save the start tag so we can properly close it later. */\n\t\t\t\t\tif ((peek & 0x3F) == 4) { /* Literal tag */\n\t\t\t\t\t\ttag_save_literal = tag_new_literal;\n\t\t\t\t\t\ttag_save_known = 0;\n\t\t\t\t\t} else { /* Known tag */\n\t\t\t\t\t\ttag_save_known = tag_new_known;\n\t\t\t\t\t\ttag_save_buf=wmem_strdup_printf(wmem_packet_scope(), \"Tag_0x%02X\",\n\t\t\t\t\t\t\t    tag_new_known);\n\t\t\t\t\t\ttag_save_literal = tag_save_buf;\n\t\t\t\t\t\t/* The last statement avoids needless lookups */\n\t\t\t\t\t}\n\t\t\t\t\t/* Process the attribute list if present */\n\t\t\t\t\tif (peek & 0x80) { /* Content and Attribute list present */\n\t\t\t\t\t\tif (tag_new_known) { /* Known tag */\n\t\t\t\t\t\t\tproto_tree_add_text (tree, tvb, off, 1,\n\t\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t\t\t\t\t     \"|   Known Tag 0x%02X           (AC) \"\n\t\t\t\t\t\t\t\t\t     \"| %s<%s\",\n\t\t\t\t\t\t\t\t\t     *level, *codepage_stag, tag_new_known,\n\t\t\t\t\t\t\t\t\t     Indent (*level), tag_new_literal);\n\t\t\t\t\t\t\t/* Tag string already looked up earlier! */\n\t\t\t\t\t\t\toff++;\n\t\t\t\t\t\t} else { /* LITERAL tag */\n\t\t\t\t\t\t\tproto_tree_add_text (tree, tvb, off, 1,\n\t\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t\t\t\t\t     \"| LITERAL_AC (Literal tag)   (AC) \"\n\t\t\t\t\t\t\t\t\t     \"| %s<%s\",\n\t\t\t\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level),\n\t\t\t\t\t\t\t\t\t     tag_new_literal);\n\t\t\t\t\t\t\toff += 1 + tag_len;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlen = parse_wbxml_attribute_list (tree, tvb,\n\t\t\t\t\t\t\t\t\t\t  off, str_tbl, *level, codepage_attr);\n\t\t\t\t\t\t/* Check that there is still room in packet */\n\t\t\t\t\t\toff += len;\n\t\t\t\t\t\tif (off >= tvb_len) {\n\t\t\t\t\t\t\tDebugLog((\"STAG: level = %u, ThrowException: \"\n\t\t\t\t\t\t\t\t  \"len = %u (short frame)\\n\",\n\t\t\t\t\t\t\t\t  *level, off - offset));\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * TODO - Do we need to free g_malloc()ed memory?\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tTHROW(ReportedBoundsError);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tproto_tree_add_text (tree, tvb, off-1, 1,\n\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t\t\t\t     \"| END (attribute list)            \"\n\t\t\t\t\t\t\t\t     \"| %s>\",\n\t\t\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level));\n\t\t\t\t\t} else { /* Content, no Attribute list */\n\t\t\t\t\t\tif (tag_new_known) { /* Known tag */\n\t\t\t\t\t\t\tproto_tree_add_text (tree, tvb, off, 1,\n\t\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t\t\t\t\t     \"|   Known Tag 0x%02X           (.C) \"\n\t\t\t\t\t\t\t\t\t     \"| %s<%s>\",\n\t\t\t\t\t\t\t\t\t     *level, *codepage_stag, tag_new_known,\n\t\t\t\t\t\t\t\t\t     Indent (*level), tag_new_literal);\n\t\t\t\t\t\t\t/* Tag string already looked up earlier! */\n\t\t\t\t\t\t\toff++;\n\t\t\t\t\t\t} else { /* LITERAL tag */\n\t\t\t\t\t\t\tproto_tree_add_text (tree, tvb, off, 1,\n\t\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t\t\t\t\t     \"| LITERAL_C  (Literal Tag)   (.C) \"\n\t\t\t\t\t\t\t\t\t     \"| %s<%s>\",\n\t\t\t\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level),\n\t\t\t\t\t\t\t\t\t     tag_new_literal);\n\t\t\t\t\t\t\toff += 1 + tag_len;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t/* The data that follows in the parsing process\n\t\t\t\t\t * represents content for the opening tag\n\t\t\t\t\t * we've just processed in the lines above.\n\t\t\t\t\t * Next time we encounter a tag with content: recurse\n\t\t\t\t\t */\n\t\t\t\t\tparsing_tag_content = TRUE;\n\t\t\t\t\tDebugLog((\"Tag in Tag - No recursion this time! \"\n\t\t\t\t\t\t  \"(off = %u)\\n\", off));\n\t\t\t\t}\n\t\t\t} else { /* No Content */\n\t\t\t\tDebugLog((\"<Tag/> in Tag - No recursion! (off = %u)\\n\", off));\n\t\t\t\t(*level)++;\n\t\t\t\tif (peek & 0x80) { /* No Content, Attribute list present */\n\t\t\t\t\tif (tag_new_known) { /* Known tag */\n\t\t\t\t\t\tproto_tree_add_text (tree, tvb, off, 1,\n\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t\t\t\t     \"|   Known Tag 0x%02X           (A.) \"\n\t\t\t\t\t\t\t\t     \"| %s<%s\",\n\t\t\t\t\t\t\t\t     *level, *codepage_stag, tag_new_known,\n\t\t\t\t\t\t\t\t     Indent (*level), tag_new_literal);\n\t\t\t\t\t\t/* Tag string already looked up earlier! */\n\t\t\t\t\t\toff++;\n\t\t\t\t\t\tlen = parse_wbxml_attribute_list (tree, tvb,\n\t\t\t\t\t\t\t\t\t\t  off, str_tbl, *level, codepage_attr);\n\t\t\t\t\t\t/* Check that there is still room in packet */\n\t\t\t\t\t\toff += len;\n\t\t\t\t\t\tif (off >= tvb_len) {\n\t\t\t\t\t\t\tDebugLog((\"STAG: level = %u, ThrowException: \"\n\t\t\t\t\t\t\t\t  \"len = %u (short frame)\\n\",\n\t\t\t\t\t\t\t\t  *level, off - offset));\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * TODO - Do we need to free g_malloc()ed memory?\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tTHROW(ReportedBoundsError);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tproto_tree_add_text (tree, tvb, off-1, 1,\n\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t\t\t\t     \"| END (Known Tag)                 \"\n\t\t\t\t\t\t\t\t     \"| %s/>\",\n\t\t\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level));\n\t\t\t\t\t} else { /* LITERAL tag */\n\t\t\t\t\t\tproto_tree_add_text (tree, tvb, off, 1,\n\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t\t\t\t     \"| LITERAL_A  (Literal Tag)   (A.) \"\n\t\t\t\t\t\t\t\t     \"| %s<%s\",\n\t\t\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level),\n\t\t\t\t\t\t\t\t     tag_new_literal);\n\t\t\t\t\t\toff += 1 + tag_len;\n\t\t\t\t\t\tlen = parse_wbxml_attribute_list (tree, tvb,\n\t\t\t\t\t\t\t\t\t\t  off, str_tbl, *level, codepage_attr);\n\t\t\t\t\t\t/* Check that there is still room in packet */\n\t\t\t\t\t\toff += len;\n\t\t\t\t\t\tif (off >= tvb_len) {\n\t\t\t\t\t\t\tDebugLog((\"STAG: level = %u, ThrowException: \"\n\t\t\t\t\t\t\t\t  \"len = %u (short frame)\\n\",\n\t\t\t\t\t\t\t\t  *level, off - offset));\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * TODO - Do we need to free g_malloc()ed memory?\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tTHROW(ReportedBoundsError);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tproto_tree_add_text (tree, tvb, off-1, 1,\n\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t\t\t\t     \"| END (Literal Tag)               \"\n\t\t\t\t\t\t\t\t     \"| %s/>\",\n\t\t\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level));\n\t\t\t\t\t}\n\t\t\t\t} else { /* No Content, No Attribute list */\n\t\t\t\t\tif (tag_new_known) { /* Known tag */\n\t\t\t\t\t\tproto_tree_add_text (tree, tvb, off, 1,\n\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t\t\t\t     \"|   Known Tag 0x%02x           (..) \"\n\t\t\t\t\t\t\t\t     \"| %s<%s />\",\n\t\t\t\t\t\t\t\t     *level, *codepage_stag, tag_new_known,\n\t\t\t\t\t\t\t\t     Indent (*level), tag_new_literal);\n\t\t\t\t\t\t/* Tag string already looked up earlier! */\n\t\t\t\t\t\toff++;\n\t\t\t\t\t} else { /* LITERAL tag */\n\t\t\t\t\t\tproto_tree_add_text (tree, tvb, off, 1,\n\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t\t\t\t     \"| LITERAL    (Literal Tag)   (..) \"\n\t\t\t\t\t\t\t\t     \"| %s<%s />\",\n\t\t\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level),\n\t\t\t\t\t\t\t\t     tag_new_literal);\n\t\t\t\t\t\toff += 1 + tag_len;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t(*level)--;\n\t\t\t\t/* TODO: Do I have to reset code page here? */\n\t\t\t}\n\t\t} /* if (tag & 0x3F) >= 5 */\n\t\tif (off < last_off) {\n\t\t\tTHROW(ReportedBoundsError);\n\t\t}\n\t\tlast_off = off;\n\t} /* while */\n\tDebugLog((\"STAG: level = %u, Return: len = %u (end of function body)\\n\",\n\t\t  *level, off - offset));\n\treturn (off - offset);\n}\n\n\n/**************************\n * WBXML Attribute tokens *\n **************************\n * Bit Mask  : Example\n * -------------------\n * 0... .... : attr=             (attribute name)\n *             href='http://'    (attribute name with start of attribute value)\n * 1... .... : 'www.'            (attribute value, or part of it)\n *\n */\n\n\n/* This function parses the WBXML and maps known token interpretations\n * to the WBXML tokens. As a result, the original XML document can be\n * recreated. Indentation is generated in order to ease reading.\n *\n * This function performs attribute list parsing.\n *\n * The wbxml_decoding entry *map contains the actual token mapping.\n *\n * NOTE: See above for known token mappings.\n */\nstatic guint32\nparse_wbxml_attribute_list_defined (proto_tree *tree, tvbuff_t *tvb,\n\t\t\t\t    guint32 offset, guint32 str_tbl, guint8 level, guint8 *codepage_attr,\n\t\t\t\t    const wbxml_decoding *map)\n{\n\tguint32     tvb_len = tvb_reported_length (tvb);\n\tguint32     off     = offset, last_off;\n\tguint32     len;\n\tguint       str_len;\n\tguint32     ent;\n\tguint32     idx;\n\tguint8      peek;\n\tguint8      attr_save_known   = 0; /* Will contain peek & 0x3F (attr identity) */\n\tconst char *attr_save_literal = NULL; /* Will contain the LITERAL attr identity */\n\n\tDebugLog((\"parse_wbxml_attr_defined (level = %u, offset = %u)\\n\",\n\t\t  level, offset));\n\t/* Parse attributes */\n\tlast_off = off;\n\twhile (off < tvb_len) {\n\t\tpeek = tvb_get_guint8 (tvb, off);\n\t\tDebugLog((\"ATTR: (top of while) level = %3u, peek = 0x%02X, \"\n\t\t\t  \"off = %u, tvb_len = %u\\n\", level, peek, off, tvb_len));\n\t\tif ((peek & 0x3F) < 5) switch (peek) { /* Global tokens\n\t\t\t\t\t\t\t  in state = ATTR */\n\t\tcase 0x00: /* SWITCH_PAGE */\n\t\t\t*codepage_attr = tvb_get_guint8 (tvb, off+1);\n\t\t\tproto_tree_add_text (tree, tvb, off, 2,\n\t\t\t\t\t     \"      |  Attr | A -->%3d \"\n\t\t\t\t\t     \"| SWITCH_PAGE (Attr code page)    |\",\n\t\t\t\t\t     *codepage_attr);\n\t\t\toff += 2;\n\t\t\tbreak;\n\t\tcase 0x01: /* END */\n\t\t\t/* BEWARE\n\t\t\t *   The Attribute END token means either \">\" or \"/>\"\n\t\t\t *   and as a consequence both must be treated separately.\n\t\t\t *   This is done in the TAG state parser.\n\t\t\t */\n\t\t\toff++;\n\t\t\tDebugLog((\"ATTR: level = %u, Return: len = %u\\n\",\n\t\t\t\t  level, off - offset));\n\t\t\treturn (off - offset);\n\t\tcase 0x02: /* ENTITY */\n\t\t\tent = tvb_get_guintvar (tvb, off+1, &len);\n\t\t\tproto_tree_add_text (tree, tvb, off, 1+len,\n\t\t\t\t\t     \"  %3d |  Attr | A %3d    \"\n\t\t\t\t\t     \"| ENTITY                          \"\n\t\t\t\t\t     \"|     %s'&#%u;'\",\n\t\t\t\t\t     level, *codepage_attr, Indent (level), ent);\n\t\t\toff += 1+len;\n\t\t\tbreak;\n\t\tcase 0x03: /* STR_I */\n\t\t\tlen = tvb_strsize (tvb, off+1);\n\t\t\tproto_tree_add_text (tree, tvb, off, 1+len,\n\t\t\t\t\t     \"  %3d |  Attr | A %3d    \"\n\t\t\t\t\t     \"| STR_I (Inline string)           \"\n\t\t\t\t\t     \"|     %s\\'%s\\'\",\n\t\t\t\t\t     level, *codepage_attr, Indent (level),\n\t\t\t\t\t     tvb_format_text (tvb, off+1, len-1));\n\t\t\toff += 1+len;\n\t\t\tbreak;\n\t\tcase 0x04: /* LITERAL */\n\t\t\t/* ALWAYS means the start of a new attribute,\n\t\t\t * and may only contain the NAME of the attribute.\n\t\t\t */\n\t\t\tidx = tvb_get_guintvar (tvb, off+1, &len);\n\t\t\tstr_len = tvb_strsize (tvb, str_tbl+idx);\n\t\t\tattr_save_known = 0;\n\t\t\tattr_save_literal = tvb_format_text (tvb,\n\t\t\t\t\t\t\t     str_tbl+idx, str_len-1);\n\t\t\tproto_tree_add_text (tree, tvb, off, 1+len,\n\t\t\t\t\t     \"  %3d |  Attr | A %3d    \"\n\t\t\t\t\t     \"| LITERAL (Literal Attribute)     \"\n\t\t\t\t\t     \"|   %s<%s />\",\n\t\t\t\t\t     level, *codepage_attr, Indent (level),\n\t\t\t\t\t     attr_save_literal);\n\t\t\toff += 1+len;\n\t\t\tbreak;\n\t\tcase 0x40: /* EXT_I_0 */\n\t\tcase 0x41: /* EXT_I_1 */\n\t\tcase 0x42: /* EXT_I_2 */\n\t\t\t/* Extension tokens */\n\t\t\tlen = tvb_strsize (tvb, off+1);\n\t\t\tproto_tree_add_text (tree, tvb, off, 1+len,\n\t\t\t\t\t     \"  %3d |  Attr | A %3d    \"\n\t\t\t\t\t     \"| EXT_I_%1x    (Extension Token)    \"\n\t\t\t\t\t     \"|     %s(%s: \\'%s\\')\",\n\t\t\t\t\t     level, *codepage_attr, peek & 0x0f, Indent (level),\n\t\t\t\t\t     map_token (map->global, 0, peek),\n\t\t\t\t\t     tvb_format_text (tvb, off+1, len-1));\n\t\t\toff += 1+len;\n\t\t\tbreak;\n\t\t\t/* 0x43 impossible in ATTR state */\n\t\t\t/* 0x44 impossible in ATTR state */\n\t\tcase 0x80: /* EXT_T_0 */\n\t\tcase 0x81: /* EXT_T_1 */\n\t\tcase 0x82: /* EXT_T_2 */\n\t\t\t/* Extension tokens */\n\t\t\tidx = tvb_get_guintvar (tvb, off+1, &len);\n\t\t\t{   char *s;\n\n\t\t\t\tif (map->ext_t[peek & 0x03])\n\t\t\t\t\ts = (map->ext_t[peek & 0x03])(tvb, idx, str_tbl);\n\t\t\t\telse\n\t\t\t\t\ts = wmem_strdup_printf(wmem_packet_scope(), \"EXT_T_%1x (%s)\", peek & 0x03,\n\t\t\t\t\t\t\t    map_token (map->global, 0, peek));\n\n\t\t\t\tproto_tree_add_text (tree, tvb, off, 1+len,\n\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t\t     \"| EXT_T_%1x    (Extension Token)    \"\n\t\t\t\t\t\t     \"| %s%s)\",\n\t\t\t\t\t\t     level, *codepage_attr, peek & 0x0f, Indent (level),\n\t\t\t\t\t\t     s);\n\t\t\t}\n\t\t\toff += 1+len;\n\t\t\tbreak;\n\t\tcase 0x83: /* STR_T */\n\t\t\tidx = tvb_get_guintvar (tvb, off+1, &len);\n\t\t\tstr_len = tvb_strsize (tvb, str_tbl+idx);\n\t\t\tproto_tree_add_text (tree, tvb, off, 1+len,\n\t\t\t\t\t     \"  %3d |  Attr | A %3d    \"\n\t\t\t\t\t     \"| STR_T (Tableref string)         \"\n\t\t\t\t\t     \"|     %s\\'%s\\'\",\n\t\t\t\t\t     level, *codepage_attr, Indent (level),\n\t\t\t\t\t     tvb_format_text (tvb, str_tbl+idx, str_len-1));\n\t\t\toff += 1+len;\n\t\t\tbreak;\n\t\t\t/* 0x84 impossible in ATTR state */\n\t\tcase 0xC0: /* EXT_0 */\n\t\tcase 0xC1: /* EXT_1 */\n\t\tcase 0xC2: /* EXT_2 */\n\t\t\t/* Extension tokens */\n\t\t\tproto_tree_add_text (tree, tvb, off, 1,\n\t\t\t\t\t     \"  %3d |  Attr | A %3d    \"\n\t\t\t\t\t     \"| EXT_%1x      (Extension Token)    \"\n\t\t\t\t\t     \"|     %s(%s)\",\n\t\t\t\t\t     level, *codepage_attr, peek & 0x0f, Indent (level),\n\t\t\t\t\t     map_token (map->global, 0, peek));\n\t\t\toff++;\n\t\t\tbreak;\n\t\tcase 0xC3: /* OPAQUE - WBXML 1.1 and newer */\n\t\t\tif (tvb_get_guint8 (tvb, 0)) { /* WBXML 1.x (x > 0) */\n\t\t\t\tchar *str;\n\t\t\t\tif (attr_save_known) { /* Knwon attribute */\n\t\t\t\t\tif (map->opaque_binary_attr) {\n\t\t\t\t\t\tstr = map->opaque_binary_attr(tvb, off + 1,\n\t\t\t\t\t\t\t\t\t      attr_save_known, *codepage_attr, &len);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstr = default_opaque_binary_attr(tvb, off + 1,\n\t\t\t\t\t\t\t\t\t\t attr_save_known, *codepage_attr, &len);\n\t\t\t\t\t}\n\t\t\t\t} else { /* lITERAL attribute */\n\t\t\t\t\tif (map->opaque_literal_tag) {\n\t\t\t\t\t\tstr = map->opaque_literal_attr(tvb, off + 1,\n\t\t\t\t\t\t\t\t\t       attr_save_literal, *codepage_attr, &len);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstr = default_opaque_literal_attr(tvb, off + 1,\n\t\t\t\t\t\t\t\t\t\t  attr_save_literal, *codepage_attr, &len);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tproto_tree_add_text (tree, tvb, off, 1 + len,\n\t\t\t\t\t\t     \"  %3d |  Attr | A %3d    \"\n\t\t\t\t\t\t     \"| OPAQUE (Opaque data)            \"\n\t\t\t\t\t\t     \"|       %s%s\",\n\t\t\t\t\t\t     level, *codepage_attr, Indent (level), str);\n\t\t\t\toff += 1 + len;\n\t\t\t} else { /* WBXML 1.0 - RESERVED_2 token (invalid) */\n\t\t\t\tproto_tree_add_text (tree, tvb, off, 1,\n\t\t\t\t\t\t     \"  %3d |  Attr | A %3d    \"\n\t\t\t\t\t\t     \"| RESERVED_2     (Invalid Token!) \"\n\t\t\t\t\t\t     \"| WBXML 1.0 parsing stops here.\",\n\t\t\t\t\t\t     level, *codepage_attr);\n\t\t\t\t/* Stop processing as it is impossible to parse now */\n\t\t\t\toff = tvb_len;\n\t\t\t\tDebugLog((\"ATTR: level = %u, Return: len = %u\\n\",\n\t\t\t\t\t  level, off - offset));\n\t\t\t\treturn (off - offset);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t/* 0xC4 impossible in ATTR state */\n\t\tdefault:\n\t\t\tproto_tree_add_text (tree, tvb, off, 1,\n\t\t\t\t\t     \"  %3d |  Attr | A %3d    \"\n\t\t\t\t\t     \"| %-10s     (Invalid Token!) \"\n\t\t\t\t\t     \"| WBXML parsing stops here.\",\n\t\t\t\t\t     level, *codepage_attr,\n\t\t\t\t\t     val_to_str_ext (peek, &vals_wbxml1x_global_tokens_ext, \"(unknown 0x%x)\"));\n\t\t\t/* Move to end of buffer */\n\t\t\toff = tvb_len;\n\t\t\tbreak;\n\t\t} else { /* Known atribute token */\n\t\t\tif (peek & 0x80) { /* attrValue */\n\t\t\t\tproto_tree_add_text (tree, tvb, off, 1,\n\t\t\t\t\t\t     \"  %3d |  Attr | A %3d    \"\n\t\t\t\t\t\t     \"|   Known attrValue 0x%02X          \"\n\t\t\t\t\t\t     \"|       %s%s\",\n\t\t\t\t\t\t     level, *codepage_attr, peek & 0x7f, Indent (level),\n\t\t\t\t\t\t     map_token (map->attrValue, *codepage_attr, peek));\n\t\t\t\toff++;\n\t\t\t} else { /* attrStart */\n\t\t\t\tattr_save_known = peek & 0x7f;\n\t\t\t\tproto_tree_add_text (tree, tvb, off, 1,\n\t\t\t\t\t\t     \"  %3d |  Attr | A %3d    \"\n\t\t\t\t\t\t     \"|   Known attrStart 0x%02X          \"\n\t\t\t\t\t\t     \"|   %s%s\",\n\t\t\t\t\t\t     level, *codepage_attr, attr_save_known, Indent (level),\n\t\t\t\t\t\t     map_token (map->attrStart, *codepage_attr, peek));\n\t\t\t\toff++;\n\t\t\t}\n\t\t}\n\t\tif (off < last_off) {\n\t\t\tTHROW(ReportedBoundsError);\n\t\t}\n\t\tlast_off = off;\n\t} /* End WHILE */\n\tDebugLog((\"ATTR: level = %u, Return: len = %u (end of function body)\\n\",\n\t\t  level, off - offset));\n\treturn (off - offset);\n}\n\n\n/* This function performs the WBXML attribute decoding as in\n * parse_wbxml_attribute_list_defined() but this time no WBXML mapping\n * is performed.\n *\n * This function performs attribute list parsing.\n *\n * NOTE: Code page switches not yet processed in the code!\n */\nstatic guint32\nparse_wbxml_attribute_list (proto_tree *tree, tvbuff_t *tvb,\n\t\t\t    guint32 offset, guint32 str_tbl, guint8 level, guint8 *codepage_attr)\n{\n\tguint32 tvb_len = tvb_reported_length (tvb);\n\tguint32 off     = offset, last_off;\n\tguint32 len;\n\tguint   str_len;\n\tguint32 ent;\n\tguint32 idx;\n\tguint8  peek;\n\n\tDebugLog((\"parse_wbxml_attr (level = %u, offset = %u)\\n\", level, offset));\n\t/* Parse attributes */\n\tlast_off = off;\n\twhile (off < tvb_len) {\n\t\tpeek = tvb_get_guint8 (tvb, off);\n\t\tDebugLog((\"ATTR: (top of while) level = %3u, peek = 0x%02X, \"\n\t\t\t  \"off = %u, tvb_len = %u\\n\", level, peek, off, tvb_len));\n\t\tif ((peek & 0x3F) < 5) switch (peek) { /* Global tokens\n\t\t\t\t\t\t\t  in state = ATTR */\n\t\tcase 0x00: /* SWITCH_PAGE */\n\t\t\t*codepage_attr = tvb_get_guint8 (tvb, off+1);\n\t\t\tproto_tree_add_text (tree, tvb, off, 2,\n\t\t\t\t\t     \"      |  Attr | A -->%3d \"\n\t\t\t\t\t     \"| SWITCH_PAGE (Attr code page)    |\",\n\t\t\t\t\t     *codepage_attr);\n\t\t\toff += 2;\n\t\t\tbreak;\n\t\tcase 0x01: /* END */\n\t\t\t/* BEWARE\n\t\t\t *   The Attribute END token means either \">\" or \"/>\"\n\t\t\t *   and as a consequence both must be treated separately.\n\t\t\t *   This is done in the TAG state parser.\n\t\t\t */\n\t\t\toff++;\n\t\t\tDebugLog((\"ATTR: level = %u, Return: len = %u\\n\",\n\t\t\t\t  level, off - offset));\n\t\t\treturn (off - offset);\n\t\tcase 0x02: /* ENTITY */\n\t\t\tent = tvb_get_guintvar (tvb, off+1, &len);\n\t\t\tproto_tree_add_text (tree, tvb, off, 1+len,\n\t\t\t\t\t     \"  %3d |  Attr | A %3d    \"\n\t\t\t\t\t     \"| ENTITY                          \"\n\t\t\t\t\t     \"|     %s'&#%u;'\",\n\t\t\t\t\t     level, *codepage_attr, Indent (level), ent);\n\t\t\toff += 1+len;\n\t\t\tbreak;\n\t\tcase 0x03: /* STR_I */\n\t\t\tlen = tvb_strsize (tvb, off+1);\n\t\t\tproto_tree_add_text (tree, tvb, off, 1+len,\n\t\t\t\t\t     \"  %3d |  Attr | A %3d    \"\n\t\t\t\t\t     \"| STR_I (Inline string)           \"\n\t\t\t\t\t     \"|     %s\\'%s\\'\",\n\t\t\t\t\t     level, *codepage_attr, Indent (level),\n\t\t\t\t\t     tvb_format_text (tvb, off+1, len-1));\n\t\t\toff += 1+len;\n\t\t\tbreak;\n\t\tcase 0x04: /* LITERAL */\n\t\t\tidx = tvb_get_guintvar (tvb, off+1, &len);\n\t\t\tstr_len = tvb_strsize (tvb, str_tbl+idx);\n\t\t\tproto_tree_add_text (tree, tvb, off, 1+len,\n\t\t\t\t\t     \"  %3d |  Attr | A %3d    \"\n\t\t\t\t\t     \"| LITERAL (Literal Attribute)     \"\n\t\t\t\t\t     \"|   %s<%s />\",\n\t\t\t\t\t     level, *codepage_attr, Indent (level),\n\t\t\t\t\t     tvb_format_text (tvb, str_tbl+idx, str_len-1));\n\t\t\toff += 1+len;\n\t\t\tbreak;\n\t\tcase 0x40: /* EXT_I_0 */\n\t\tcase 0x41: /* EXT_I_1 */\n\t\tcase 0x42: /* EXT_I_2 */\n\t\t\t/* Extension tokens */\n\t\t\tlen = tvb_strsize (tvb, off+1);\n\t\t\tproto_tree_add_text (tree, tvb, off, 1+len,\n\t\t\t\t\t     \"  %3d |  Attr | A %3d    \"\n\t\t\t\t\t     \"| EXT_I_%1x    (Extension Token)    \"\n\t\t\t\t\t     \"|     %s(Inline string extension: \\'%s\\')\",\n\t\t\t\t\t     level, *codepage_attr, peek & 0x0f, Indent (level),\n\t\t\t\t\t     tvb_format_text (tvb, off+1, len-1));\n\t\t\toff += 1+len;\n\t\t\tbreak;\n\t\t\t/* 0x43 impossible in ATTR state */\n\t\t\t/* 0x44 impossible in ATTR state */\n\t\tcase 0x80: /* EXT_T_0 */\n\t\tcase 0x81: /* EXT_T_1 */\n\t\tcase 0x82: /* EXT_T_2 */\n\t\t\t/* Extension tokens */\n\t\t\tidx = tvb_get_guintvar (tvb, off+1, &len);\n\t\t\tproto_tree_add_text (tree, tvb, off, 1+len,\n\t\t\t\t\t     \"  %3d |  Attr | A %3d    \"\n\t\t\t\t\t     \"| EXT_T_%1x    (Extension Token)    \"\n\t\t\t\t\t     \"|     %s(Extension Token, integer value: %u)\",\n\t\t\t\t\t     level, *codepage_attr, peek & 0x0f, Indent (level),\n\t\t\t\t\t     idx);\n\t\t\toff += 1+len;\n\t\t\tbreak;\n\t\tcase 0x83: /* STR_T */\n\t\t\tidx = tvb_get_guintvar (tvb, off+1, &len);\n\t\t\tstr_len = tvb_strsize (tvb, str_tbl+idx);\n\t\t\tproto_tree_add_text (tree, tvb, off, 1+len,\n\t\t\t\t\t     \"  %3d |  Attr | A %3d    \"\n\t\t\t\t\t     \"| STR_T (Tableref string)         \"\n\t\t\t\t\t     \"|     %s\\'%s\\'\",\n\t\t\t\t\t     level, *codepage_attr, Indent (level),\n\t\t\t\t\t     tvb_format_text (tvb, str_tbl+idx, str_len-1));\n\t\t\toff += 1+len;\n\t\t\tbreak;\n\t\t\t/* 0x84 impossible in ATTR state */\n\t\tcase 0xC0: /* EXT_0 */\n\t\tcase 0xC1: /* EXT_1 */\n\t\tcase 0xC2: /* EXT_2 */\n\t\t\t/* Extension tokens */\n\t\t\tproto_tree_add_text (tree, tvb, off, 1,\n\t\t\t\t\t     \"  %3d |  Attr | A %3d    \"\n\t\t\t\t\t     \"| EXT_%1x      (Extension Token)    \"\n\t\t\t\t\t     \"|     %s(Single-byte extension)\",\n\t\t\t\t\t     level, *codepage_attr, peek & 0x0f, Indent (level));\n\t\t\toff++;\n\t\t\tbreak;\n\t\tcase 0xC3: /* OPAQUE - WBXML 1.1 and newer */\n\t\t\tif (tvb_get_guint8 (tvb, 0)) { /* WBXML 1.x (x > 0) */\n\t\t\t\tidx = tvb_get_guintvar (tvb, off+1, &len);\n\t\t\t\tproto_tree_add_text (tree, tvb, off, 1 + len + idx,\n\t\t\t\t\t\t     \"  %3d |  Attr | A %3d    \"\n\t\t\t\t\t\t     \"| OPAQUE (Opaque data)            \"\n\t\t\t\t\t\t     \"|       %s(%d bytes of opaque data)\",\n\t\t\t\t\t\t     level, *codepage_attr, Indent (level), idx);\n\t\t\t\toff += 1+len+idx;\n\t\t\t} else { /* WBXML 1.0 - RESERVED_2 token (invalid) */\n\t\t\t\tproto_tree_add_text (tree, tvb, off, 1,\n\t\t\t\t\t\t     \"  %3d |  Attr | A %3d    \"\n\t\t\t\t\t\t     \"| RESERVED_2     (Invalid Token!) \"\n\t\t\t\t\t\t     \"| WBXML 1.0 parsing stops here.\",\n\t\t\t\t\t\t     level, *codepage_attr);\n\t\t\t\t/* Stop processing as it is impossible to parse now */\n\t\t\t\toff = tvb_len;\n\t\t\t\tDebugLog((\"ATTR: level = %u, Return: len = %u\\n\",\n\t\t\t\t\t  level, off - offset));\n\t\t\t\treturn (off - offset);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t/* 0xC4 impossible in ATTR state */\n\t\tdefault:\n\t\t\tproto_tree_add_text (tree, tvb, off, 1,\n\t\t\t\t\t     \"  %3d |  Attr | A %3d    \"\n\t\t\t\t\t     \"| %-10s     (Invalid Token!) \"\n\t\t\t\t\t     \"| WBXML parsing stops here.\",\n\t\t\t\t\t     level, *codepage_attr,\n\t\t\t\t\t     val_to_str_ext (peek, &vals_wbxml1x_global_tokens_ext, \"(unknown 0x%x)\"));\n\t\t\t/* Move to end of buffer */\n\t\t\toff = tvb_len;\n\t\t\tbreak;\n\t\t} else { /* Known atribute token */\n\t\t\tif (peek & 0x80) { /* attrValue */\n\t\t\t\tproto_tree_add_text (tree, tvb, off, 1,\n\t\t\t\t\t\t     \"  %3d |  Attr | A %3d    \"\n\t\t\t\t\t\t     \"|   Known attrValue 0x%02X          \"\n\t\t\t\t\t\t     \"|       %sattrValue_0x%02X\",\n\t\t\t\t\t\t     level, *codepage_attr, peek & 0x7f, Indent (level),\n\t\t\t\t\t\t     peek);\n\t\t\t\toff++;\n\t\t\t} else { /* attrStart */\n\t\t\t\tproto_tree_add_text (tree, tvb, off, 1,\n\t\t\t\t\t\t     \"  %3d |  Attr | A %3d    \"\n\t\t\t\t\t\t     \"|   Known attrStart 0x%02X          \"\n\t\t\t\t\t\t     \"|   %sattrStart_0x%02X\",\n\t\t\t\t\t\t     level, *codepage_attr, peek & 0x7f, Indent (level),\n\t\t\t\t\t\t     peek);\n\t\t\t\toff++;\n\t\t\t}\n\t\t}\n\t\tif (off < last_off) {\n\t\t\tTHROW(ReportedBoundsError);\n\t\t}\n\t\tlast_off = off;\n\t} /* End WHILE */\n\tDebugLog((\"ATTR: level = %u, Return: len = %u (end of function body)\\n\",\n\t\t  level, off - offset));\n\treturn (off - offset);\n}\n\n\n/****************** Register the protocol with Wireshark ******************/\n\n\n/* This format is required because a script is used to build the C function\n * that calls the protocol registration. */\n\nvoid\nproto_register_wbxml(void)\n{\n\tmodule_t *wbxml_module;\t/* WBXML Preferences */\n\n\t/* Setup list of header fields. */\n\tstatic hf_register_info hf[] = {\n\t\t{ &hf_wbxml_version,\n\t\t  { \"Version\",\n\t\t    \"wbxml.version\",\n\t\t    FT_UINT8, BASE_HEX|BASE_EXT_STRING,\n\t\t    &vals_wbxml_versions_ext, 0x00,\n\t\t    \"WBXML Version\", HFILL }\n\t\t},\n\t\t{ &hf_wbxml_public_id_known,\n\t\t  { \"Public Identifier (known)\",\n\t\t    \"wbxml.public_id.known\",\n\t\t    FT_UINT32, BASE_HEX|BASE_EXT_STRING,\n\t\t    &vals_wbxml_public_ids_ext, 0x00,\n\t\t    \"WBXML Known Public Identifier (integer)\", HFILL }\n\t\t},\n\t\t{ &hf_wbxml_public_id_literal,\n\t\t  { \"Public Identifier (literal)\",\n\t\t    \"wbxml.public_id.literal\",\n\t\t    FT_STRING, BASE_NONE,\n\t\t    NULL, 0x00,\n\t\t    \"WBXML Literal Public Identifier (text string)\", HFILL }\n\t\t},\n\t\t{ &hf_wbxml_charset,\n\t\t  { \"Character Set\",\n\t\t    \"wbxml.charset\",\n\t\t    FT_UINT32, BASE_HEX|BASE_EXT_STRING,\n\t\t    &wap_mib_enum_vals_character_sets_ext, 0x00,\n\t\t    \"WBXML Character Set\", HFILL }\n\t\t},\n\t};\n\n\t/* Setup protocol subtree array */\n\tstatic gint *ett[] = {\n\t\t&ett_wbxml,\n\t\t&ett_wbxml_str_tbl,\n\t\t&ett_wbxml_content,\n\t};\n\n\t/* Register the protocol name and description */\n\tproto_wbxml = proto_register_protocol(\n\t\t\t\t\t      \"WAP Binary XML\",\n\t\t\t\t\t      \"WBXML\",\n\t\t\t\t\t      \"wbxml\"\n\t\t\t\t\t      );\n\n\t/* Required function calls to register the header fields\n\t * and subtrees used */\n\tproto_register_field_array(proto_wbxml, hf, array_length(hf));\n\tproto_register_subtree_array(ett, array_length(ett));\n\n\t/* Preferences */\n\twbxml_module = prefs_register_protocol(proto_wbxml, NULL);\n\tprefs_register_bool_preference(wbxml_module,\n\t\t\t\t       \"skip_wbxml_token_mapping\",\n\t\t\t\t       \"Skip the mapping of WBXML tokens to media type tokens.\",\n\t\t\t\t       \"Enable this preference if you want to view the WBXML \"\n\t\t\t\t       \"tokens without the representation in a media type \"\n\t\t\t\t       \"(e.g., WML). Tokens will show up as Tag_0x12, \"\n\t\t\t\t       \"attrStart_0x08 or attrValue_0x0B for example.\",\n\t\t\t\t       &skip_wbxml_token_mapping);\n\tprefs_register_bool_preference(wbxml_module,\n\t\t\t\t       \"disable_wbxml_token_parsing\",\n\t\t\t\t       \"Disable the parsing of the WBXML tokens.\",\n\t\t\t\t       \"Enable this preference if you want to skip the \"\n\t\t\t\t       \"parsing of the WBXML tokens that constitute the body \"\n\t\t\t\t       \"of the WBXML document. Only the WBXML header will be \"\n\t\t\t\t       \"dissected (and visualized) then.\",\n\t\t\t\t       &disable_wbxml_token_parsing);\n\n\tregister_dissector(\"wbxml\", dissect_wbxml, proto_wbxml);\n\tregister_dissector(\"wbxml-uaprof\", dissect_uaprof, proto_wbxml);\n}\n\n\nvoid\nproto_reg_handoff_wbxml(void)\n{\n\tdissector_handle_t wbxml_handle;\n\n\t/* Heuristic dissectors would be declared by means of:\n\t * heur_dissector_add(\"wsp\", dissect_wbxml_heur, proto_wbxml);\n\t */\n\n\twbxml_handle = find_dissector(\"wbxml\");\n\n\t/* Register the WSP content types (defined as protocol port)\n\t * for WBXML dissection.\n\t *\n\t * See http://www.wapforum.org/wina/wsp-content-type.htm\n\t *\n\t * As the media types for WSP and HTTP are the same, the WSP dissector\n\t * uses the same string dissector table as the HTTP protocol.\n\t */\n\n\t/**** Well-known WBXML WSP Content-Type values ****/\n\n\tdissector_add_string(\"media_type\",\n\t\t\t     \"application/vnd.wap.wmlc\", wbxml_handle);\n\tdissector_add_string(\"media_type\",\n\t\t\t     \"application/vnd.wap.wta-eventc\", wbxml_handle);\n\tdissector_add_string(\"media_type\",\n\t\t\t     \"application/vnd.wap.wbxml\", wbxml_handle);\n\tdissector_add_string(\"media_type\",\n\t\t\t     \"application/vnd.wap.sic\", wbxml_handle);\n\tdissector_add_string(\"media_type\",\n\t\t\t     \"application/vnd.wap.slc\", wbxml_handle);\n\tdissector_add_string(\"media_type\",\n\t\t\t     \"application/vnd.wap.coc\", wbxml_handle);\n\tdissector_add_string(\"media_type\",\n\t\t\t     \"application/vnd.wap.connectivity-wbxml\", wbxml_handle);\n\tdissector_add_string(\"media_type\",\n\t\t\t     \"application/vnd.wap.locc+wbxml\", wbxml_handle);\n\tdissector_add_string(\"media_type\",\n\t\t\t     \"application/vnd.syncml+wbxml\", wbxml_handle);\n\tdissector_add_string(\"media_type\",\n\t\t\t     \"application/vnd.syncml.dm+wbxml\", wbxml_handle);\n\tdissector_add_string(\"media_type\",\n\t\t\t     \"application/vnd.oma.drm.rights+wbxml\", wbxml_handle);\n\tdissector_add_string(\"media_type\",\n\t\t\t     \"application/vnd.wv.csp.wbxml\", wbxml_handle);\n\tdissector_add_string(\"media_type\",\n\t\t\t     \"application/vnd.ms-sync.wbxml\", wbxml_handle);\n\tdissector_add_string(\"media_type\",\n\t\t\t     \"application/vnd.ms-sync\", wbxml_handle);\n\n\t/**** Registered WBXML WSP Content-Type values ****/\n\n\tdissector_add_string(\"media_type\",\n\t\t\t     \"application/vnd.uplanet.cacheop-wbxml\", wbxml_handle);\n\tdissector_add_string(\"media_type\",\n\t\t\t     \"application/vnd.uplanet.alert-wbxml\", wbxml_handle);\n\tdissector_add_string(\"media_type\",\n\t\t\t     \"application/vnd.uplanet.list-wbxml\", wbxml_handle);\n\tdissector_add_string(\"media_type\",\n\t\t\t     \"application/vnd.uplanet.listcmd-wbxml\", wbxml_handle);\n\tdissector_add_string(\"media_type\",\n\t\t\t     \"application/vnd.uplanet.channel-wbxml\", wbxml_handle);\n\tdissector_add_string(\"media_type\",\n\t\t\t     \"application/vnd.uplanet.bearer-choice-wbxml\", wbxml_handle);\n\tdissector_add_string(\"media_type\",\n\t\t\t     \"application/vnd.phonecom.mmc-wbxml\", wbxml_handle);\n\tdissector_add_string(\"media_type\",\n\t\t\t     \"application/vnd.nokia.syncset+wbxml\", wbxml_handle);\n\n\t/***** Content types that only have a textual representation *****/\n\tdissector_add_string(\"media_type\",\n\t\t\t     \"application/x-wap-prov.browser-bookmarks\", wbxml_handle);\n\tdissector_add_string(\"media_type\",\n\t\t\t     \"application/x-wap-prov.browser-settings\", wbxml_handle);\n\t/* Same as application/vnd.nokia.syncset+wbxml */\n\tdissector_add_string(\"media_type\",\n\t\t\t     \"application/x-prov.syncset+wbxml\", wbxml_handle);\n}\n\n/*\n * Editor modelines\n *\n * Local Variables:\n * c-basic-offset: 8\n * tab-width: 8\n * indent-tabs-mode: t\n * End:\n *\n * ex: set shiftwidth=8 tabstop=8 noexpandtab:\n * :indentSize=8:tabSize=8:noTabs=false:\n */\n", "code_before": "/* packet-wbxml.c\n *\n * Routines for WAP Binary XML dissection\n * Copyright 2003, 2004, Olivier Biot.\n *\n * Routines for WV-CSP 1.3 dissection\n * Copyright 2007, Andrei Rubaniuk.\n *\n * Refer to the AUTHORS file or the AUTHORS section in the man page\n * for contacting the author(s) of this file.\n *\n * Wireshark - Network traffic analyzer\n * By Gerald Combs <gerald@wireshark.org>\n * Copyright 1998 Gerald Combs\n *\n * WAP Binary XML decoding functionality provided by Olivier Biot.\n * WV-CSP 1.2 updated to Release version and WV-CSP 1.3 protocol\n * decoding functionality provided by Andrei Rubaniuk.\n *\n * The WAP specifications used to be found at the WAP Forum:\n *\t<http://www.wapforum.org/what/Technical.htm>\n * But now the correct link is at the Open Mobile Alliance:\n *\t<http://www.openmobilealliance.org/tech/affiliates/wap/wapindex.html>\n * Media types defined by OMA affiliates will have their standards at:\n *\t<http://www.openmobilealliance.org/tech/affiliates/index.html>\n *\t<http://www.openmobilealliance.org/release_program/index.html>\n *\n * SPDX-License-Identifier: GPL-2.0-or-later\n */\n\n#include \"config.h\"\n\n\n#include <epan/packet.h>\n#include <epan/exceptions.h>\n#include <epan/prefs.h>\n#include <epan/expert.h>\n#include <epan/proto_data.h>\n#include <epan/strutil.h>\n#include <epan/iana_charsets.h>\n/* We need the function tvb_get_uintvar() */\n#include \"packet-wap.h\"\n\nvoid proto_register_wbxml(void);\nvoid proto_reg_handoff_wbxml(void);\n\n/* General-purpose debug logger.\n * Requires double parentheses because of variable arguments of printf().\n *\n * Enable debug logging for WBXML by defining AM_FLAGS\n * so that it contains \"-DDEBUG_wbxml\"\n */\n#ifdef DEBUG_wbxml\n#define DebugLog(x)\t\t\t\t\\\n\tg_print(\"%s:%u: \", __FILE__, __LINE__); \\\n\tg_print x\n#else\n#define DebugLog(x) ;\n#endif\n\n/* The code in this source file dissects the WAP Binary XML content,\n * and if possible renders it. WBXML mappings are defined in the\n * \"wbxml_decoding\" structure.\n *\n * NOTES:\n *\n *  - Some WBXML content is *not* backwards compatible across minor versions.\n *    This painful remark is true for:\n *      o  WMLC 1.0 with respect to later WMLC 1.x\n *      o  All WV-CSP versions (never backwards compatible)\n *    The only way of correctly rendering the WBXML is to let the end-user\n *    choose from the possible renderings. This only applies to the case when\n *    the WBXML DocType is not included in the WBXML header (unknown/missing).\n *\n *  - Some WBXML content uses EXT_T_* in a non-tableref manner. This is the\n *    case with WV-CSP 1.1 and up, where the index points to a value_string\n *    containing WV-CSP specific token values. This is allowed as it is not\n *    explicitly forbidden in the WBXML specifications. Hence the global token\n *    map for content must also contain a function pointer if no tableref\n *    string is used.\n *\n *  - Code page switches apply until a new code page switch. In the WBXML/1.x\n *    ABNF notation, it can be proven that the switch_page can only precede\n *    the following tokens:\n *      o  stag      : TAG | LITERAL | LITERAL_A | LITERAL_C | LITERAL_AC\n *      o  attr      : ATTRSTART | ATTRVALUE\n *      o  extension : EXT_I | EXT_T | EXT\n *    Code page switches are displayed in a separate column.\n *\n *  - The WBXML spec states that code pages are static to both the tag and the\n *    attribute state parser. A SWITCH_PAGE within a state switches the code\n *    page of the active state only. Note that code page 255 is reserved for\n *    application-specific (read: testing) purposes.\n *\n *  - In order to render the XML content, recursion is inevitable at some\n *    point (when a tag with content occurs in the content of a tag with\n *    content). The code will however not recurse if this is not strictly\n *    required (e.g., tag without content in the content of a tag with\n *    content).\n *\n *  - I found it useful to display the XML nesting level as a first \"column\",\n *    followed by the abbreviated WBXML token interpretation. When a mapping\n *    is defined for the parsed WBXML content, then the XML rendering is\n *    displayed with appropriate indentation (maximum nesting level = 255,\n *    after which the nesting and level will safely roll-over to 0).\n *\n *  - The WAP Forum defines the order of precedence for finding out the\n *    WBXML content type (same rules for charset) as follows:\n *      1. Look in the Content-Type WSP header\n *      2. Look in the WBXML header\n *    Currently there is no means of using content type parameters:\n *      o  Type=<some_type>\n *      o  Charset=<charset_of_the_content>\n *    So it is possible some WBXML content types are incorrectly parsed.\n *    This would only be the case when the content type declaration in the\n *    WSP Content-Type header would be different (or would have parameters\n *    which are relevant to the WBXML decoding) from the content type\n *    identifier specified in the WBXML header. This has to do with the\n *    decoding of terminated text strings in the different character codings.\n *    TODO: investigate this and provide correct decoding at all times.\n */\n\n\n/************************** Variable declarations **************************/\n\n\n/* Initialize the protocol and registered fields */\nstatic int proto_wbxml;\nstatic int hf_wbxml_version;\nstatic int hf_wbxml_public_id_known;\nstatic int hf_wbxml_public_id_literal;\nstatic int hf_wbxml_charset;\nstatic int hf_wbxml_string_table_item_offset;\nstatic int hf_wbxml_string_table_item_string;\nstatic int hf_wbxml_switch_page;\nstatic int hf_wbxml_known_tag;\nstatic int hf_wbxml_end_known_tag;\nstatic int hf_wbxml_end_known_tag_uint;\nstatic int hf_wbxml_str_i;\nstatic int hf_wbxml_str_t;\nstatic int hf_wbxml_opaque_data;\nstatic int hf_wbxml_entity;\nstatic int hf_wbxml_literal;\nstatic int hf_wbxml_ext_i;\nstatic int hf_wbxml_ext_t;\nstatic int hf_wbxml_extension_token;\nstatic int hf_wbxml_reserved_2;\nstatic int hf_wbxml_invalid_token;\nstatic int hf_wbxml_known_attrvalue;\nstatic int hf_wbxml_known_attrstart;\nstatic int hf_wbxml_end_literal_tag;\nstatic int hf_wbxml_literal_a;\nstatic int hf_wbxml_literal_c;\nstatic int hf_wbxml_literal_ac;\nstatic int hf_wbxml_end_pi;\nstatic int hf_wbxml_end_attribute_list;\nstatic int hf_wbxml_pi_xml;\n\n/* Initialize the subtree pointers */\nstatic int ett_wbxml;\nstatic int ett_wbxml_str_tbl;\nstatic int ett_wbxml_content;\nstatic int ett_wbxml_tags;\nstatic int ett_wbxml_string_table_item;\n\nstatic expert_field ei_wbxml_data_not_shown;\nstatic expert_field ei_wbxml_content_type_not_supported;\nstatic expert_field ei_wbxml_content_type_disabled;\nstatic expert_field ei_wbxml_oversized_uintvar;\nstatic expert_field ei_wbxml_too_much_recursion;\n\nstatic dissector_handle_t wbxml_handle;\n\n/* WBXML Preferences */\nstatic bool skip_wbxml_token_mapping;\nstatic bool disable_wbxml_token_parsing;\n\n\ntypedef struct _value_valuestring {\n\tuint32_t value;\n\tconst value_string *valstrptr;\n} value_valuestring;\n\n/* Tries to match val against each element in the value_value_string array vvs.\n * Returns the associated value_string ptr on a match, or NULL on failure. */\nstatic const value_string *\nval_to_valstr(uint32_t val, const value_valuestring *vvs)\n{\n\tint i = 0;\n\n\twhile (vvs[i].valstrptr) {\n\t\tif (vvs[i].value == val)\n\t\t\treturn vvs[i].valstrptr;\n\t\ti++;\n\t}\n\n\treturn NULL;\n}\n\n/* Note on Token mapping\n * ---------------------\n *\n * The WBXML dissector will try mapping the token decoding to their textual\n * representation if the media type has a defined token representation. The\n * following logic applies:\n *\n * a. Inspect the WBXML PublicID\n *\tThis means that I need a list { PublicID, decoding }\n *\n * b. Inspect the literal media type\n *\tThis requires a list { \"media/type\", discriminator, { decodings } }\n *\n *   b.1. Use a discriminator to choose an appropriate token mapping;\n *\tThe disciminator needs a small number of bytes from the data tvbuff_t.\n *\n * else\n *   b.2. Provide a list to the end-user with all possible token mappings.\n *\n * c. If none match then only show the tokens without mapping.\n *\n */\n\n/* ext_t_func_ptr is a pointer to a function handling the EXT_T_i tokens:\n *\n * char * ext_t_function(tvbuff_t *tvb, uint32_t value, uint32_t strtbl);\n */\ntypedef char * (* ext_t_func_ptr)(wmem_allocator_t*, tvbuff_t *, uint32_t, uint32_t);\n\n/* Note on parsing of OPAQUE data\n * ------------------------------\n *\n * The WBXML encapsulation allows the insertion of opaque binary data in the\n * WBXML body. Although this opaque data has no meaning in WBXML, the media\n * type itself may define compact encoding of given input by encoding it in\n * such a OPAQUE blob of bytes.\n *\n * The WBXML dissector now supports dissection of OPAQUE data by means of a\n * mapping function that will operate based on the token (well-known or literal)\n * and the active code page.\n *\n * For well-known tokens the simplest approach is to use a switch for the code\n * pages and another switch for the relevant tokens within a code page.\n *\n * For literal tokens (tags and attribute names), the only approach is a string\n * comparison with the literal representation of the given tag or attribute\n * name.\n *\n * opaque_token_func_ptr is a pointer to a function handling OPAQUE values\n * for binary tokens representing tags or attribute starts.\n * opaque_literal_func_ptr is a pointer to a function handling OPAQUE values\n * for literal tokens representing tags or attribute starts.\n *\n * The length field of the OPAQUE entry starts at offset (not offset + 1).\n *\n * The length of the processed OPAQUE value is returned by reference.\n *\n * char * opaque_token_function(tvbuff_t *tvb, uint32_t offset,\n * \t\tuint8_t token, uint8_t codepage, uint32_t *length);\n * char * opaque_literal_function(tvbuff_t *tvb, uint32_t offset,\n * \t\tconst char *token, uint8_t codepage, uint32_t *length);\n */\ntypedef char * (* opaque_token_func_ptr)(tvbuff_t *, uint32_t, uint8_t, uint8_t, uint32_t *, packet_info *);\ntypedef char * (* opaque_literal_func_ptr)(tvbuff_t *, uint32_t, const char *, uint8_t, uint32_t *, packet_info *);\n\nstatic char *\ndefault_opaque_binary_tag(tvbuff_t *tvb, uint32_t offset,\n\t\t\t  uint8_t token _U_, uint8_t codepage _U_, uint32_t *length, packet_info *pinfo)\n{\n\tuint32_t data_len = tvb_get_uintvar(tvb, offset, length, pinfo, &ei_wbxml_oversized_uintvar);\n\tchar *str = wmem_strdup_printf(pinfo->pool, \"(%u bytes of opaque data)\", data_len);\n\t*length += data_len;\n\treturn str;\n}\n\nstatic char *\ndefault_opaque_literal_tag(tvbuff_t *tvb, uint32_t offset,\n\t\t\t   const char *token _U_, uint8_t codepage _U_, uint32_t *length, packet_info *pinfo)\n{\n\tuint32_t data_len = tvb_get_uintvar(tvb, offset, length, pinfo, &ei_wbxml_oversized_uintvar);\n\tchar *str = wmem_strdup_printf(pinfo->pool, \"(%u bytes of opaque data)\", data_len);\n\t*length += data_len;\n\treturn str;\n}\n\nstatic char *\ndefault_opaque_binary_attr(tvbuff_t *tvb, uint32_t offset,\n\t\t\t   uint8_t token _U_, uint8_t codepage _U_, uint32_t *length, packet_info *pinfo)\n{\n\tuint32_t data_len = tvb_get_uintvar(tvb, offset, length, pinfo, &ei_wbxml_oversized_uintvar);\n\tchar *str = wmem_strdup_printf(pinfo->pool, \"(%u bytes of opaque data)\", data_len);\n\t*length += data_len;\n\treturn str;\n}\n\nstatic char *\ndefault_opaque_literal_attr(tvbuff_t *tvb, uint32_t offset,\n\t\t\t    const char *token _U_, uint8_t codepage _U_, uint32_t *length, packet_info *pinfo)\n{\n\tuint32_t data_len = tvb_get_uintvar(tvb, offset, length, pinfo, &ei_wbxml_oversized_uintvar);\n\tchar *str = wmem_strdup_printf(pinfo->pool, \"(%u bytes of opaque data)\", data_len);\n\t*length += data_len;\n\treturn str;\n}\n\n/* Render a hex %dateTime encoded timestamp as a string.\n * 0x20011231123456 becomes \"2001-12-31T12:34:56Z\" */\nstatic char *\ndate_time_from_opaque(wmem_allocator_t *pool, tvbuff_t *tvb, uint32_t offset, uint32_t data_len)\n{\n\tchar *str;\n\n\tswitch (data_len) {\n\tcase 4: /* YYYY-MM-DD[T00:00:00Z] */\n\t\tstr = wmem_strdup_printf(pool, \"%%DateTime: \"\n\t\t\t\t      \"%02x%02x-%02x-%02xT00:00:00Z\",\n\t\t\t\t      tvb_get_uint8(tvb, offset),\n\t\t\t\t      tvb_get_uint8(tvb, offset + 1),\n\t\t\t\t      tvb_get_uint8(tvb, offset + 2),\n\t\t\t\t      tvb_get_uint8(tvb, offset + 3));\n\t\tbreak;\n\tcase 5: /* YYYY-MM-DDThh[:00:00Z] */\n\t\tstr = wmem_strdup_printf(pool, \"%%DateTime: \"\n\t\t\t\t      \"%02x%02x-%02x-%02xT%02x:00:00Z\",\n\t\t\t\t      tvb_get_uint8(tvb, offset),\n\t\t\t\t      tvb_get_uint8(tvb, offset + 1),\n\t\t\t\t      tvb_get_uint8(tvb, offset + 2),\n\t\t\t\t      tvb_get_uint8(tvb, offset + 3),\n\t\t\t\t      tvb_get_uint8(tvb, offset + 4));\n\t\tbreak;\n\tcase 6: /* YYYY-MM-DDThh:mm[:00Z] */\n\t\tstr = wmem_strdup_printf(pool, \"%%DateTime: \"\n\t\t\t\t      \"%02x%02x-%02x-%02xT%02x:%02x:00Z\",\n\t\t\t\t      tvb_get_uint8(tvb, offset),\n\t\t\t\t      tvb_get_uint8(tvb, offset + 1),\n\t\t\t\t      tvb_get_uint8(tvb, offset + 2),\n\t\t\t\t      tvb_get_uint8(tvb, offset + 3),\n\t\t\t\t      tvb_get_uint8(tvb, offset + 4),\n\t\t\t\t      tvb_get_uint8(tvb, offset + 5));\n\t\tbreak;\n\tcase 7: /* YYYY-MM-DDThh:mm[:00Z] */\n\t\tstr = wmem_strdup_printf(pool, \"%%DateTime: \"\n\t\t\t\t      \"%02x%02x-%02x-%02xT%02x:%02x:%02xZ\",\n\t\t\t\t      tvb_get_uint8(tvb, offset),\n\t\t\t\t      tvb_get_uint8(tvb, offset + 1),\n\t\t\t\t      tvb_get_uint8(tvb, offset + 2),\n\t\t\t\t      tvb_get_uint8(tvb, offset + 3),\n\t\t\t\t      tvb_get_uint8(tvb, offset + 4),\n\t\t\t\t      tvb_get_uint8(tvb, offset + 5),\n\t\t\t\t      tvb_get_uint8(tvb, offset + 6));\n\t\tbreak;\n\tdefault:\n\t\tstr = wmem_strdup_printf(pool, \"<Error: invalid binary %%DateTime \"\n\t\t\t\t      \"(%u bytes of opaque data)>\", data_len);\n\t\tbreak;\n\t}\n\n\treturn str;\n}\n\n/* Is ALWAYS 6 bytes long:\n * 00YY YYYY  YYYY YYMM  MMDD DDDh  hhhh mmmm  mmss ssss  ZZZZ ZZZZ */\nstatic char *\nwv_datetime_from_opaque(wmem_allocator_t *pool, tvbuff_t *tvb, uint32_t offset, uint32_t data_len)\n{\n\tchar *str;\n\tuint16_t year;\n\tuint8_t month, day, hour, minute, second, time_zone;\n\tuint8_t peek;\n\n\tif (data_len == 6) { /* Valid */\n\n\t\t/* Octet 1: 00YY YYYY */\n\t\tyear = tvb_get_uint8(tvb, offset) & 0x3F; /* ..11 1111 */\n\t\tyear <<=6;\n\t\t/* Octet 2: YYYY YYMM */\n\t\tpeek = tvb_get_uint8(tvb, offset + 1);\n\t\tyear += (peek >> 2); /* 1111 11.. */\n\t\tmonth = (peek & 0x03) << 2; /* .... ..11 */\n\t\t/* Octet 3: MMDD DDDh */\n\t\tpeek = tvb_get_uint8(tvb, offset + 2);\n\t\tmonth += (peek >> 6); /* 11.. .... */\n\t\tday = (peek & 0x3E) >> 1; /* ..11 111. */\n\t\thour = (peek & 0x01) << 4; /* .... ...1 */\n\t\t/* Octet 4: hhhh mmmm */\n\t\tpeek = tvb_get_uint8(tvb, offset + 3);\n\t\thour += (peek >> 4);\n\t\tminute = (peek & 0x0F) << 2; /* .... 1111 */\n\t\t/* Octet 5: mmss ssss */\n\t\tpeek = tvb_get_uint8(tvb, offset + 4);\n\t\tminute += (peek >> 6); /* 11.. .... */\n\t\tsecond = peek & 0x3F; /* ..11 1111 */\n\t\t/* octet 6: ZZZZZZZZ */\n\t\ttime_zone = tvb_get_uint8(tvb, offset + 5);\n\t\t/* Now construct the string */\n\t\tstr = wmem_strdup_printf(pool, \"WV-CSP DateTime: \"\n\t\t\t\t      \"%04d-%02d-%02dT%02d:%02d:%02d%s\",\n\t\t\t\t      year, month, day, hour, minute, second, format_char(pool, time_zone));\n\t} else { /* Invalid length for a WV-CSP DateTime tag value */\n\t\tstr = wmem_strdup_printf(pool, \"<Error: invalid binary WV-CSP DateTime value \"\n\t\t\t\t      \"(%u bytes of opaque data)>\", data_len);\n\t}\n\treturn str;\n}\n\n/* WV-CSP integer values for tag content is encoded in a fashion similar\n * to a Long-Integer in WSP */\nstatic char *\nwv_integer_from_opaque(wmem_allocator_t *pool, tvbuff_t *tvb, uint32_t offset, uint32_t data_len)\n{\n\tchar *str;\n\n\tswitch (data_len) {\n\tcase 1:\n\t\tstr = wmem_strdup_printf(pool, \"WV-CSP Integer: %d\",\n\t\t\t\t      tvb_get_uint8(tvb, offset));\n\t\tbreak;\n\tcase 2:\n\t\tstr = wmem_strdup_printf(pool, \"WV-CSP Integer: %d\",\n\t\t\t\t      tvb_get_ntohs(tvb, offset));\n\t\tbreak;\n\tcase 3:\n\t\tstr = wmem_strdup_printf(pool, \"WV-CSP Integer: %d\",\n\t\t\t\t      tvb_get_ntoh24(tvb, offset));\n\t\tbreak;\n\tcase 4:\n\t\tstr = wmem_strdup_printf(pool, \"WV-CSP Integer: %d\",\n\t\t\t\t      tvb_get_ntohl(tvb, offset));\n\t\tbreak;\n\tdefault:\n\t\tstr = wmem_strdup_printf(pool, \"<Error: invalid binary WV-CSP Integer value \"\n\t\t\t\t      \"(%u bytes of opaque data)>\", data_len);\n\t\tbreak;\n\t}\n\n\treturn str;\n}\n\nstatic char *\nwv_csp10_opaque_binary_tag(tvbuff_t *tvb, uint32_t offset,\n\t\t\t   uint8_t token, uint8_t codepage, uint32_t *length, packet_info *pinfo)\n{\n\tuint32_t data_len = tvb_get_uintvar(tvb, offset, length, pinfo, &ei_wbxml_oversized_uintvar);\n\tchar *str = NULL;\n\n\tswitch (codepage) {\n\tcase 0: /* Common code page */\n\t\tswitch (token) {\n\t\tcase 0x0B: /* <Code> */\n\t\tcase 0x0F: /* <ContentSize> */\n\t\tcase 0x1A: /* <MessageCount> */\n\t\tcase 0x3C: /* <Validity> */\n\t\t\tstr = wv_integer_from_opaque(pinfo->pool, tvb,\n\t\t\t\t\t\t     offset + *length, data_len);\n\t\t\tbreak;\n\t\tcase 0x11: /* <DateTime> */\n\t\t\tstr = wv_datetime_from_opaque(pinfo->pool, tvb,\n\t\t\t\t\t\t      offset + *length, data_len);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 1: /* Access code page */\n\t\tswitch (token) {\n\t\tcase 0x1C: /* <KeepAliveTime> */\n\t\tcase 0x32: /* <TimeToLive> */\n\t\t\tstr = wv_integer_from_opaque(pinfo->pool, tvb,\n\t\t\t\t\t\t     offset + *length, data_len);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 3: /* Client capability code page */\n\t\tswitch (token) {\n\t\tcase 0x06: /* <AcceptedContentLength> */\n\t\tcase 0x0C: /* <MultiTrans> */\n\t\tcase 0x0D: /* <ParserSize> */\n\t\tcase 0x0E: /* <ServerPollMin> */\n\t\tcase 0x11: /* <TCPAddress> */\n\t\tcase 0x12: /* <TCPPort> */\n\t\tcase 0x13: /* <UDPPort> */\n\t\t\tstr = wv_integer_from_opaque(pinfo->pool, tvb,\n\t\t\t\t\t\t     offset + *length, data_len);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (str == NULL) { /* Error, or not parsed */\n\t\tstr = wmem_strdup_printf(pinfo->pool, \"(%u bytes of unparsed opaque data)\", data_len);\n\t}\n\t*length += data_len;\n\n\treturn str;\n}\n\nstatic char *\nwv_csp10_opaque_literal_tag(tvbuff_t *tvb, uint32_t offset,\n\t\t\t    const char *token, uint8_t codepage _U_, uint32_t *length, packet_info *pinfo)\n{\n\tuint32_t data_len = tvb_get_uintvar(tvb, offset, length, pinfo, &ei_wbxml_oversized_uintvar);\n\tchar *str = NULL;\n\n\tif ( token && ( (strcmp(token, \"Code\") == 0)\n\t\t\t|| (strcmp(token, \"ContentSize\") == 0)\n\t\t\t|| (strcmp(token, \"MessageCount\") == 0)\n\t\t\t|| (strcmp(token, \"Validity\") == 0)\n\t\t\t|| (strcmp(token, \"KeepAliveTime\") == 0)\n\t\t\t|| (strcmp(token, \"TimeToLive\") == 0)\n\t\t\t|| (strcmp(token, \"AcceptedContentLength\") == 0)\n\t\t\t|| (strcmp(token, \"MultiTrans\") == 0)\n\t\t\t|| (strcmp(token, \"ParserSize\") == 0)\n\t\t\t|| (strcmp(token, \"ServerPollMin\") == 0)\n\t\t\t|| (strcmp(token, \"TCPAddress\") == 0)\n\t\t\t|| (strcmp(token, \"TCPPort\") == 0)\n\t\t\t|| (strcmp(token, \"UDPPort\") == 0) ) )\n\t\t{\n\t\t\tstr = wv_integer_from_opaque(pinfo->pool, tvb, offset + *length, data_len);\n\t\t}\n\telse if ( token && ( strcmp(token, \"DateTime\") == 0) )\n\t\t{\n\t\t\tstr = wv_datetime_from_opaque(pinfo->pool, tvb, offset + *length, data_len);\n\t\t}\n\n\tif (str == NULL) { /* Error, or not parsed */\n\t\tstr = wmem_strdup_printf(pinfo->pool, \"(%d bytes of unparsed opaque data)\", data_len);\n\t}\n\t*length += data_len;\n\treturn str;\n}\n\nstatic char *\nwv_csp11_opaque_binary_tag(tvbuff_t *tvb, uint32_t offset,\n\t\t\t   uint8_t token, uint8_t codepage, uint32_t *length, packet_info *pinfo)\n{\n\tuint32_t data_len = tvb_get_uintvar(tvb, offset, length, pinfo, &ei_wbxml_oversized_uintvar);\n\tchar *str = NULL;\n\n\tswitch (codepage) {\n\tcase 0: /* Common code page */\n\t\tswitch (token) {\n\t\tcase 0x0B: /* <Code> */\n\t\tcase 0x0F: /* <ContentSize> */\n\t\tcase 0x1A: /* <MessageCount> */\n\t\tcase 0x3C: /* <Validity> */\n\t\t\tstr = wv_integer_from_opaque(pinfo->pool, tvb,\n\t\t\t\t\t\t     offset + *length, data_len);\n\t\t\tbreak;\n\t\tcase 0x11: /* <DateTime> */\n\t\t\tstr = wv_datetime_from_opaque(pinfo->pool, tvb,\n\t\t\t\t\t\t      offset + *length, data_len);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 1: /* Access code page */\n\t\tswitch (token) {\n\t\tcase 0x1C: /* <KeepAliveTime> */\n\t\tcase 0x32: /* <TimeToLive> */\n\t\t\tstr = wv_integer_from_opaque(pinfo->pool, tvb,\n\t\t\t\t\t\t     offset + *length, data_len);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 3: /* Client capability code page */\n\t\tswitch (token) {\n\t\tcase 0x06: /* <AcceptedContentLength> */\n\t\tcase 0x0C: /* <MultiTrans> */\n\t\tcase 0x0D: /* <ParserSize> */\n\t\tcase 0x0E: /* <ServerPollMin> */\n\t\tcase 0x12: /* <TCPPort> */\n\t\tcase 0x13: /* <UDPPort> */\n\t\t\tstr = wv_integer_from_opaque(pinfo->pool, tvb,\n\t\t\t\t\t\t     offset + *length, data_len);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 6: /* Messaging code page */\n\t\tswitch (token) {\n\t\tcase 0x1A: /* <DeliveryTime> - not in 1.0 */\n\t\t\tstr = wv_datetime_from_opaque(pinfo->pool, tvb,\n\t\t\t\t\t\t      offset + *length, data_len);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (str == NULL) { /* Error, or not parsed */\n\t\tstr = wmem_strdup_printf(pinfo->pool, \"(%d bytes of unparsed opaque data)\", data_len);\n\t}\n\t*length += data_len;\n\n\treturn str;\n}\n\nstatic char *\nwv_csp11_opaque_literal_tag(tvbuff_t *tvb, uint32_t offset,\n\t\t\t    const char *token, uint8_t codepage _U_, uint32_t *length, packet_info *pinfo)\n{\n\tuint32_t data_len = tvb_get_uintvar(tvb, offset, length, pinfo, &ei_wbxml_oversized_uintvar);\n\tchar *str = NULL;\n\n\tif ( token && ( (strcmp(token, \"Code\") == 0)\n\t\t\t|| (strcmp(token, \"ContentSize\") == 0)\n\t\t\t|| (strcmp(token, \"MessageCount\") == 0)\n\t\t\t|| (strcmp(token, \"Validity\") == 0)\n\t\t\t|| (strcmp(token, \"KeepAliveTime\") == 0)\n\t\t\t|| (strcmp(token, \"TimeToLive\") == 0)\n\t\t\t|| (strcmp(token, \"AcceptedContentLength\") == 0)\n\t\t\t|| (strcmp(token, \"MultiTrans\") == 0)\n\t\t\t|| (strcmp(token, \"ParserSize\") == 0)\n\t\t\t|| (strcmp(token, \"ServerPollMin\") == 0)\n\t\t\t|| (strcmp(token, \"TCPPort\") == 0)\n\t\t\t|| (strcmp(token, \"UDPPort\") == 0) ) )\n\t\t{\n\t\t\tstr = wv_integer_from_opaque(pinfo->pool, tvb, offset + *length, data_len);\n\t\t}\n\telse\n\t\tif ( token && ( (strcmp(token, \"DateTime\") == 0)\n\t\t\t\t|| (strcmp(token, \"DeliveryTime\") == 0) ) )\n\t\t\t{\n\t\t\t\tstr = wv_datetime_from_opaque(pinfo->pool, tvb, offset + *length, data_len);\n\t\t\t}\n\n\tif (str == NULL) { /* Error, or not parsed */\n\t\tstr = wmem_strdup_printf(pinfo->pool, \"(%d bytes of unparsed opaque data)\", data_len);\n\t}\n\t*length += data_len;\n\treturn str;\n}\n\n\nstatic char *\nwv_csp12_opaque_binary_tag(tvbuff_t *tvb, uint32_t offset,\n\t\t\t   uint8_t token, uint8_t codepage, uint32_t *length, packet_info *pinfo)\n{\n\tuint32_t data_len = tvb_get_uintvar(tvb, offset, length, pinfo, &ei_wbxml_oversized_uintvar);\n\tchar *str = NULL;\n\n\tswitch (codepage) {\n\tcase 0: /* Common code page */\n\t\tswitch (token) {\n\t\tcase 0x0B: /* <Code> */\n\t\tcase 0x0F: /* <ContentSize> */\n\t\tcase 0x1A: /* <MessageCount> */\n\t\tcase 0x3C: /* <Validity> */\n\t\t\tstr = wv_integer_from_opaque(pinfo->pool, tvb,\n\t\t\t\t\t\t     offset + *length, data_len);\n\t\t\tbreak;\n\t\tcase 0x11: /* <DateTime> */\n\t\t\tstr = wv_datetime_from_opaque(pinfo->pool, tvb,\n\t\t\t\t\t\t      offset + *length, data_len);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 1: /* Access code page */\n\t\tswitch (token) {\n\t\tcase 0x1C: /* <KeepAliveTime> */\n\t\tcase 0x32: /* <TimeToLive> */\n\t\t\tstr = wv_integer_from_opaque(pinfo->pool, tvb,\n\t\t\t\t\t\t     offset + *length, data_len);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 3: /* Client capability code page */\n\t\tswitch (token) {\n\t\tcase 0x06: /* <AcceptedContentLength> */\n\t\tcase 0x0C: /* <MultiTrans> */\n\t\tcase 0x0D: /* <ParserSize> */\n\t\tcase 0x0E: /* <ServerPollMin> */\n\t\tcase 0x12: /* <TCPPort> */\n\t\tcase 0x13: /* <UDPPort> */\n\t\t\tstr = wv_integer_from_opaque(pinfo->pool, tvb,\n\t\t\t\t\t\t     offset + *length, data_len);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 6: /* Messaging code page */\n\t\tswitch (token) {\n\t\tcase 0x1A: /* <DeliveryTime> - not in 1.0 */\n\t\t\tstr = wv_datetime_from_opaque(pinfo->pool, tvb,\n\t\t\t\t\t\t      offset + *length, data_len);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 9: /* Common code page (continued) */\n\t\tswitch (token) {\n\t\tcase 0x08: /* <HistoryPeriod> - 1.2 only */\n\t\tcase 0x0A: /* <MaxWatcherList> - 1.2 only */\n\t\t\tstr = wv_integer_from_opaque(pinfo->pool, tvb,\n\t\t\t\t\t\t     offset + *length, data_len);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (str == NULL) { /* Error, or not parsed */\n\t\tstr = wmem_strdup_printf(pinfo->pool, \"(%d bytes of unparsed opaque data)\", data_len);\n\t}\n\t*length += data_len;\n\n\treturn str;\n}\n\nstatic char *\nwv_csp12_opaque_literal_tag(tvbuff_t *tvb, uint32_t offset,\n\t\t\t    const char *token, uint8_t codepage _U_, uint32_t *length, packet_info *pinfo)\n{\n\tuint32_t data_len = tvb_get_uintvar(tvb, offset, length, pinfo, &ei_wbxml_oversized_uintvar);\n\tchar *str = NULL;\n\n\tif ( token && ( (strcmp(token, \"Code\") == 0)\n\t\t\t|| (strcmp(token, \"ContentSize\") == 0)\n\t\t\t|| (strcmp(token, \"MessageCount\") == 0)\n\t\t\t|| (strcmp(token, \"Validity\") == 0)\n\t\t\t|| (strcmp(token, \"KeepAliveTime\") == 0)\n\t\t\t|| (strcmp(token, \"TimeToLive\") == 0)\n\t\t\t|| (strcmp(token, \"AcceptedContentLength\") == 0)\n\t\t\t|| (strcmp(token, \"MultiTrans\") == 0)\n\t\t\t|| (strcmp(token, \"ParserSize\") == 0)\n\t\t\t|| (strcmp(token, \"ServerPollMin\") == 0)\n\t\t\t|| (strcmp(token, \"TCPPort\") == 0)\n\t\t\t|| (strcmp(token, \"UDPPort\") == 0)\n\t\t\t|| (strcmp(token, \"HistoryPeriod\") == 0)\n\t\t\t|| (strcmp(token, \"MaxWatcherList\") == 0) ) )\n\t\t{\n\t\t\tstr = wv_integer_from_opaque(pinfo->pool, tvb, offset + *length, data_len);\n\t\t}\n\telse\n\t\tif ( token && ( (strcmp(token, \"DateTime\") == 0)\n\t\t\t\t|| (strcmp(token, \"DeliveryTime\") == 0) ) )\n\t\t\t{\n\t\t\t\tstr = wv_datetime_from_opaque(pinfo->pool, tvb, offset + *length, data_len);\n\t\t\t}\n\n\tif (str == NULL) { /* Error, or not parsed */\n\t\tstr = wmem_strdup_printf(pinfo->pool, \"(%d bytes of unparsed opaque data)\", data_len);\n\t}\n\t*length += data_len;\n\treturn str;\n}\n\nstatic char *\nwv_csp13_opaque_binary_tag(tvbuff_t *tvb, uint32_t offset,\n\t\t\t   uint8_t token, uint8_t codepage, uint32_t *length, packet_info *pinfo)\n{\n\tuint32_t data_len = tvb_get_uintvar(tvb, offset, length, pinfo, &ei_wbxml_oversized_uintvar);\n\tchar *str = NULL;\n\n\tswitch (codepage)\n\t\t{\n\t\tcase 0: /* Common code page */\n\t\t\tswitch (token)\n\t\t\t\t{\n\t\t\t\tcase 0x0B: /* <Code> */\n\t\t\t\tcase 0x0F: /* <ContentSize> */\n\t\t\t\tcase 0x1A: /* <MessageCount> */\n\t\t\t\tcase 0x3C: /* <Validity> */\n\t\t\t\t\tstr = wv_integer_from_opaque(pinfo->pool, tvb, offset + *length, data_len);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x11: /* <DateTime> */\n\t\t\t\t\tstr = wv_datetime_from_opaque(pinfo->pool, tvb, offset + *length, data_len);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 1: /* Access code page */\n\t\t\tswitch (token)\n\t\t\t\t{\n\t\t\t\tcase 0x1C: /* <KeepAliveTime> */\n\t\t\t\tcase 0x25: /* <SearchFindings> */\n\t\t\t\tcase 0x26: /* <SearchID> */\n\t\t\t\tcase 0x27: /* <SearchIndex> */\n\t\t\t\tcase 0x28: /* <SearchLimit> */\n\t\t\t\tcase 0x32: /* <TimeToLive> */\n\t\t\t\t\tstr = wv_integer_from_opaque(pinfo->pool, tvb, offset + *length, data_len);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 3: /* Client capability code page */\n\t\t\tswitch (token)\n\t\t\t\t{\n\t\t\t\tcase 0x06: /* <AcceptedContentLength> */\n\t\t\t\tcase 0x0C: /* <MultiTrans> */\n\t\t\t\tcase 0x0D: /* <ParserSize> */\n\t\t\t\tcase 0x0E: /* <ServerPollMin> */\n\t\t\t\tcase 0x12: /* <TCPPort> */\n\t\t\t\tcase 0x13: /* <UDPPort> */\n\t\t\t\t\t/* New in WV-CSP 1.3*/\n\t\t\t\tcase 0x16: /* <AcceptedPullLength> */\n\t\t\t\tcase 0x17: /* <AcceptedPushLength> */\n\t\t\t\tcase 0x18: /* <AcceptedRichContentLength> */\n\t\t\t\tcase 0x19: /* <AcceptedTextContentLength> */\n\t\t\t\tcase 0x1B: /* <PlainTextCharset> MIBenum number - character set, i.e. UTF-8, windows-1251, etc. */\n\t\t\t\tcase 0x1C: /* <SessionPriority> */\n\t\t\t\tcase 0x1F: /* <UserSessionLimit> */\n\t\t\t\tcase 0x21: /* <MultiTransPerMessage> */\n\t\t\t\tcase 0x24: /* <ContentPolicyLimit> */\n\t\t\t\t\tstr = wv_integer_from_opaque(pinfo->pool, tvb, offset + *length, data_len);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 5: /* Presence attribute code page */\n\t\t\tswitch (token)\n\t\t\t\t{\n\t\t\t\t\t/* New in WV-CSP 1.3*/\n\t\t\t\t\t/*\t\tcase 0x3B: */ /* <ClientContentLimit> */\n\t\t\t\tcase 0x3C: /* <ClientIMPriority> */\n\t\t\t\tcase 0x3D: /* <MaxPullLength> */\n\t\t\t\tcase 0x3E: /* <MaxPushLength> */\n\t\t\t\t\tstr = wv_integer_from_opaque(pinfo->pool, tvb, offset + *length, data_len);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 6: /* Messaging code page */\n\t\t\tswitch (token)\n\t\t\t\t{\n\t\t\t\tcase 0x1A: /* <DeliveryTime> - not in 1.0 */\n\t\t\t\t\t/* New in WV-CSP 1.3*/\n\t\t\t\tcase 0x1C: /* <AnswerOptionID> */\n\t\t\t\t\tstr = wv_datetime_from_opaque(pinfo->pool, tvb, offset + *length, data_len);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 9: /* Common code page (continued) */\n\t\t\tswitch (token)\n\t\t\t\t{\n\t\t\t\tcase 0x08: /* <HistoryPeriod> - 1.2 only */\n\t\t\t\tcase 0x0A: /* <MaxWatcherList> - 1.2 only */\n\t\t\t\t\t/* New in WV-CSP 1.3*/\n\t\t\t\tcase 0x25: /* <SegmentCount> */\n\t\t\t\tcase 0x28: /* <SegmentReference> */\n\t\t\t\tcase 0x30: /* <TryAgainTimeout> */\n\t\t\t\tcase 0x3A: /* <GroupContentLimit> */\n\t\t\t\tcase 0x3B: /* <MessageTotalCount> */\n\t\t\t\t\tstr = wv_integer_from_opaque(pinfo->pool, tvb, offset + *length, data_len);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 10:\n\t\t\tswitch (token)\n\t\t\t\t{\n\t\t\t\t\t/* New in WV-CSP 1.3*/\n\t\t\t\tcase 0x0C: /* <PairID> */\n\t\t\t\t\tstr = wv_integer_from_opaque(pinfo->pool, tvb, offset + *length, data_len);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\tif (str == NULL)\n\t\t{ /* Error, or not parsed */\n\t\t\tstr = wmem_strdup_printf(pinfo->pool, \"(%d bytes of unparsed opaque data)\", data_len);\n\t\t}\n\t*length += data_len;\n\n\treturn str;\n}\n\n\nstatic char *\nwv_csp13_opaque_literal_tag(tvbuff_t *tvb, uint32_t offset,\n\t\t\t    const char *token, uint8_t codepage _U_, uint32_t *length, packet_info *pinfo)\n{\n\tuint32_t data_len = tvb_get_uintvar(tvb, offset, length, pinfo, &ei_wbxml_oversized_uintvar);\n\tchar *str = NULL;\n\n\tif ( token && ( (strcmp(token, \"Code\") == 0)\n\t\t\t|| (strcmp(token, \"ContentSize\") == 0)\n\t\t\t|| (strcmp(token, \"MessageCount\") == 0)\n\t\t\t|| (strcmp(token, \"Validity\") == 0)\n\t\t\t|| (strcmp(token, \"KeepAliveTime\") == 0)\n\t\t\t|| (strcmp(token, \"TimeToLive\") == 0)\n\t\t\t|| (strcmp(token, \"AcceptedContentLength\") == 0)\n\t\t\t|| (strcmp(token, \"MultiTrans\") == 0)\n\t\t\t|| (strcmp(token, \"ParserSize\") == 0)\n\t\t\t|| (strcmp(token, \"ServerPollMin\") == 0)\n\t\t\t|| (strcmp(token, \"TCPPort\") == 0)\n\t\t\t|| (strcmp(token, \"UDPPort\") == 0)\n\t\t\t|| (strcmp(token, \"HistoryPeriod\") == 0)\n\t\t\t|| (strcmp(token, \"MaxWatcherList\") == 0)\n\t\t\t/* New in WV-CSP 1.3*/\n\t\t\t|| (strcmp(token, \"SearchFindings\") == 0)\n\t\t\t|| (strcmp(token, \"SearchID\") == 0)\n\t\t\t|| (strcmp(token, \"SearchIndex\") == 0)\n\t\t\t|| (strcmp(token, \"SearchLimit\") == 0)\n\t\t\t|| (strcmp(token, \"AcceptedPullLength\") == 0)\n\t\t\t|| (strcmp(token, \"AcceptedPushLength\") == 0)\n\t\t\t|| (strcmp(token, \"AcceptedRichContentLength\") == 0)\n\t\t\t|| (strcmp(token, \"AcceptedTextContentLength\") == 0)\n\t\t\t|| (strcmp(token, \"SessionPriority\") == 0)\n\t\t\t|| (strcmp(token, \"UserSessionLimit\") == 0)\n\t\t\t|| (strcmp(token, \"MultiTransPerMessage\") == 0)\n\t\t\t|| (strcmp(token, \"ContentPolicyLimit\") == 0)\n\t\t\t|| (strcmp(token, \"AnswerOptionID\") == 0)\n\t\t\t|| (strcmp(token, \"SegmentCount\") == 0)\n\t\t\t|| (strcmp(token, \"SegmentReference\") == 0)\n\t\t\t|| (strcmp(token, \"TryAgainTimeout\") == 0)\n\t\t\t|| (strcmp(token, \"GroupContentLimit\") == 0)\n\t\t\t|| (strcmp(token, \"MessageTotalCount\") == 0)\n\t\t\t|| (strcmp(token, \"PairID\") == 0) ) )\n\t\t{\n\t\t\tstr = wv_integer_from_opaque(pinfo->pool, tvb, offset + *length, data_len);\n\t\t}\n\telse\n\t\tif ( token && ( (strcmp(token, \"DateTime\") == 0)\n\t\t\t\t|| (strcmp(token, \"DeliveryTime\") == 0) ) )\n\t\t\t{\n\t\t\t\tstr = wv_datetime_from_opaque(pinfo->pool, tvb, offset + *length, data_len);\n\t\t\t}\n\n\tif (str == NULL) { /* Error, or not parsed */\n\t\tstr = wmem_strdup_printf(pinfo->pool, \"(%d bytes of unparsed opaque data)\", data_len);\n\t}\n\t*length += data_len;\n\treturn str;\n}\n\nstatic char *\nsic10_opaque_literal_attr(tvbuff_t *tvb, uint32_t offset,\n\t\t\t  const char *token, uint8_t codepage _U_, uint32_t *length, packet_info *pinfo)\n{\n\tuint32_t data_len = tvb_get_uintvar(tvb, offset, length, pinfo, &ei_wbxml_oversized_uintvar);\n\tchar *str = NULL;\n\n\tif ( token && ( (strcmp(token, \"created\") == 0)\n\t\t\t|| (strcmp(token, \"si-expires\") == 0) ) )\n\t\t{\n\t\t\tstr = date_time_from_opaque(pinfo->pool, tvb, offset + *length, data_len);\n\t\t}\n\tif (str == NULL) { /* Error, or not parsed */\n\t\tstr = wmem_strdup_printf(pinfo->pool, \"(%d bytes of unparsed opaque data)\", data_len);\n\t}\n\t*length += data_len;\n\n\treturn str;\n}\n\nstatic char *\nsic10_opaque_binary_attr(tvbuff_t *tvb, uint32_t offset,\n\t\t\t uint8_t token, uint8_t codepage, uint32_t *length, packet_info *pinfo)\n{\n\tuint32_t data_len = tvb_get_uintvar(tvb, offset, length, pinfo, &ei_wbxml_oversized_uintvar);\n\tchar *str = NULL;\n\n\tswitch (codepage) {\n\tcase 0: /* Only valid codepage for SI */\n\t\tswitch (token) {\n\t\tcase 0x0A: /* created= */\n\t\tcase 0x10: /* si-expires= */\n\t\t\tstr = date_time_from_opaque(pinfo->pool, tvb,\n\t\t\t\t\t\t    offset + *length, data_len);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (str == NULL) { /* Error, or not parsed */\n\t\tstr = wmem_strdup_printf(pinfo->pool, \"(%d bytes of unparsed opaque data)\", data_len);\n\t}\n\t*length += data_len;\n\n\treturn str;\n}\n\nstatic char *\nemnc10_opaque_literal_attr(tvbuff_t *tvb, uint32_t offset,\n\t\t\t   const char *token, uint8_t codepage _U_, uint32_t *length, packet_info *pinfo)\n{\n\tuint32_t data_len = tvb_get_uintvar(tvb, offset, length, pinfo, &ei_wbxml_oversized_uintvar);\n\tchar *str = NULL;\n\n\tif ( token && (strcmp(token, \"timestamp\") == 0) )\n\t\t{\n\t\t\tstr = date_time_from_opaque(pinfo->pool, tvb, offset + *length, data_len);\n\t\t}\n\tif (str == NULL) { /* Error, or not parsed */\n\t\tstr = wmem_strdup_printf(pinfo->pool, \"(%d bytes of unparsed opaque data)\", data_len);\n\t}\n\t*length += data_len;\n\n\treturn str;\n}\n\nstatic char *\nemnc10_opaque_binary_attr(tvbuff_t *tvb, uint32_t offset,\n\t\t\t  uint8_t token, uint8_t codepage, uint32_t *length, packet_info *pinfo)\n{\n\tuint32_t data_len = tvb_get_uintvar(tvb, offset, length, pinfo, &ei_wbxml_oversized_uintvar);\n\tchar *str = NULL;\n\n\tswitch (codepage) {\n\tcase 0: /* Only valid codepage for EMN */\n\t\tswitch (token) {\n\t\tcase 0x05: /* timestamp= */\n\t\t\tstr = date_time_from_opaque(pinfo->pool, tvb,\n\t\t\t\t\t\t    offset + *length, data_len);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (str == NULL) { /* Error, or not parsed */\n\t\tstr = wmem_strdup_printf(pinfo->pool, \"(%d bytes of unparsed opaque data)\", data_len);\n\t}\n\t*length += data_len;\n\n\treturn str;\n}\n\ntypedef struct _wbxml_decoding {\n\tconst char *name;\n\tconst char *abbrev;\n\text_t_func_ptr ext_t[3];\n\topaque_token_func_ptr\topaque_binary_tag;\n\topaque_literal_func_ptr\topaque_literal_tag;\n\topaque_token_func_ptr\topaque_binary_attr;\n\topaque_literal_func_ptr\topaque_literal_attr;\n\tconst value_valuestring *global;\n\tconst value_valuestring *tags;\n\tconst value_valuestring *attrStart;\n\tconst value_valuestring *attrValue;\n} wbxml_decoding;\n\n/* Define a pointer to a discriminator function taking a tvb and the start\n * offset of the WBXML tokens in the body as arguments.\n */\ntypedef const wbxml_decoding * (* discriminator_func_ptr)(tvbuff_t *, uint32_t);\n\n/* For the decoding lists based on the known WBXML public ID */\ntypedef struct _wbxml_integer_list {\n\tuint32_t public_id;\n\tconst wbxml_decoding *map;\n} wbxml_integer_list;\n\n/* For the decoding lists on the literal content type */\ntypedef struct _wbxml_literal_list {\n\tconst char *content_type;\n\tdiscriminator_func_ptr discriminator; /* TODO */\n\tconst wbxml_decoding *map;\n} wbxml_literal_list;\n\n/**************** WBXML related declarations and definitions ****************/\n\n\n/* WBXML public ID mappings. For an up-to-date list, see\n * http://www.openmobilealliance.org/tech/omna/ */\nstatic const value_string vals_wbxml_public_ids[] = {\n\t/* 0x00 = literal public identifier */\n\t{ 0x01, \"Unknown or missing Public Identifier\" },\n\t{ 0x02, \"-//WAPFORUM//DTD WML 1.0//EN (WML 1.0)\" },\n\t{ 0x03, \"-//WAPFORUM//DTD WTA 1.0//EN (WTA Event 1.0) - Deprecated\" },\n\t{ 0x04, \"-//WAPFORUM//DTD WML 1.1//EN (WML 1.1)\" },\n\t{ 0x05, \"-//WAPFORUM//DTD SI 1.0//EN (Service Indication 1.0)\" },\n\t{ 0x06, \"-//WAPFORUM//DTD SL 1.0//EN (Service Loading 1.0)\" },\n\t{ 0x07, \"-//WAPFORUM//DTD CO 1.0//EN (Cache Operation 1.0)\" },\n\t{ 0x08, \"-//WAPFORUM//DTD CHANNEL 1.1//EN (Channel 1.1)\" },\n\t{ 0x09, \"-//WAPFORUM//DTD WML 1.2//EN (WML 1.2)\" },\n\t{ 0x0a, \"-//WAPFORUM//DTD WML 1.3//EN (WML 1.3)\" },\n\t{ 0x0b, \"-//WAPFORUM//DTD PROV 1.0//EN (Provisioning 1.0)\" },\n\t{ 0x0c, \"-//WAPFORUM//DTD WTA-WML 1.2//EN (WTA-WML 1.2)\" },\n\t{ 0x0d, \"-//WAPFORUM//DTD EMN 1.0//EN (Email Notification 1.0)\" },\n\t{ 0x0e, \"-//WAPFORUM//DTD DRMREL 1.0//EN (DRMREL 1.0)\" },\n\t{ 0x0f, \"-//WIRELESSVILLAGE//DTD CSP 1.0//EN\"\n\t  \" (Wireless Village Client-Server Protocol DTD v1.0)\" },\n\t{ 0x10, \"-//WIRELESSVILLAGE//DTD CSP 1.1//EN\"\n\t  \" (Wireless Village Client-Server Protocol DTD v1.1)\" },\n\t{ 0x11, \"-//OMA//DTD WV-CSP 1.2//EN (OMA IMPS - CSP protocol DTD v1.2)\" },\n\t{ 0x12, \"-//OMA//DTD IMPS-CSP 1.3//EN (OMA IMPS - CSP protocol DTD v1.3)\" },\n\t{ 0x13, \"-//OMA//DRM 2.1//EN (OMA DRM 2.1)\" },\n\t/* 0x14 -- 0x7F: reserved */\n\n\t/* Registered values - www.syncml.org */\n\t{ 0x0fd1, \"-//SYNCML//DTD SyncML 1.0//EN (SyncML 1.0)\" },\n\t{ 0x0fd3, \"-//SYNCML//DTD SyncML 1.1//EN (SyncML 1.1)\" },\n\n\t/* Registered values - www.wapforum.org/wina/ */\n\t{ 0x1100, \"-//PHONE.COM//DTD ALERT 1.0//EN\" },\n\t{ 0x1101, \"-//PHONE.COM//DTD CACHE-OPERATION 1.0//EN\" },\n\t{ 0x1102, \"-//PHONE.COM//DTD SIGNAL 1.0//EN\" },\n\t{ 0x1103, \"-//PHONE.COM//DTD LIST 1.0//EN\" },\n\t{ 0x1104, \"-//PHONE.COM//DTD LISTCMD 1.0//EN\" },\n\t{ 0x1105, \"-//PHONE.COM//DTD CHANNEL 1.0//EN\" },\n\t{ 0x1106, \"-//PHONE.COM//DTD MMC 1.0//EN\" },\n\t{ 0x1107, \"-//PHONE.COM//DTD BEARER-CHOICE 1.0//EN\" },\n\t{ 0x1108, \"-//PHONE.COM//DTD WML 1.1//EN (WML+ 1.1)\" },\n\t{ 0x1109, \"-//PHONE.COM//DTD CHANNEL 1.1//EN\" },\n\t{ 0x110a, \"-//PHONE.COM//DTD LIST 1.1//EN\" },\n\t{ 0x110b, \"-//PHONE.COM//DTD LISTCMD 1.1//EN\" },\n\t{ 0x110c, \"-//PHONE.COM//DTD MMC 1.1//EN\" },\n\t{ 0x110d, \"-//PHONE.COM//DTD WML 1.3//EN (WML+ 1.3)\" },\n\t{ 0x110e, \"-//PHONE.COM//DTD MMC 2.0//EN\" },\n\t/* 0x110F -- 0x11FF: unassigned */\n\t{ 0x1200, \"-//3GPP2.COM//DTD IOTA 1.0//EN\" },\n\t{ 0x1201, \"-//SYNCML//DTD SyncML 1.2//EN\" },\n\t{ 0x1202, \"-//SYNCML//DTD MetaInf 1.2//EN\" },\n \t{ 0x1203, \"-//SYNCML//DTD DevInf 1.2//EN\" },\n \t{ 0x1204, \"-//NOKIA//DTD LANDMARKS 1.0//EN\" },\n\n\t{ 0x00, NULL }\n};\nstatic value_string_ext vals_wbxml_public_ids_ext = VALUE_STRING_EXT_INIT(vals_wbxml_public_ids);\n\nstatic const value_string vals_wbxml_versions[] = {\n\t{ 0x00, \"1.0\" },\t/* WAP-104-WBXML */\n\t{ 0x01, \"1.1\" },\t/* WAP-135-WBXML */\n\t{ 0x02, \"1.2\" },\t/* WAP-154-WBXML */\n\t{ 0x03, \"1.3\" },\t/* WAP-192-WBXML */\n\n\t{ 0x00, NULL }\n};\nstatic value_string_ext vals_wbxml_versions_ext = VALUE_STRING_EXT_INIT(vals_wbxml_versions);\n\n/* WBXML 1.0 global tokens: WAP-104-WBXML\n * Same token mapping as in vals_wbxml1x_global_tokens, but:\n *   { 0xC3, \"RESERVED_2\" }\n */\n\n/* WBXML 1.x (x>0) global tokens: WAP-135-WBXML, WAP-154-WBXML, WAP-192-WBXML\n */\nstatic const value_string vals_wbxml1x_global_tokens[] = {\n\t{ 0x00, \"SWITCH_PAGE\" },\n\t{ 0x01, \"END\" },\n\t{ 0x02, \"ENTITY\" },\n\t{ 0x03, \"STR_I\" },\n\t{ 0x04, \"LITERAL\" },\n\n\t{ 0x40, \"EXT_I_0\" },\n\t{ 0x41, \"EXT_I_1\" },\n\t{ 0x42, \"EXT_I_2\" },\n\t{ 0x43, \"PI\" },\n\t{ 0x44, \"LITERAL_C\" },\n\n\t{ 0x80, \"EXT_T_0\" },\n\t{ 0x81, \"EXT_T_1\" },\n\t{ 0x82, \"EXT_T_2\" },\n\t{ 0x83, \"STR_T\" },\n\t{ 0x84, \"LITERAL_A\" },\n\n\t{ 0xC0, \"EXT_0\" },\n\t{ 0xC1, \"EXT_1\" },\n\t{ 0xC2, \"EXT_2\" },\n\t{ 0xC3, \"OPAQUE\" },\n\t{ 0xC4, \"LITERAL_AC\" },\n\n\t{ 0x00, NULL }\n};\nstatic value_string_ext vals_wbxml1x_global_tokens_ext = VALUE_STRING_EXT_INIT(vals_wbxml1x_global_tokens);\n\n\n\n\n\n/********************** WBXML token mapping definition **********************/\n\n/*\n * NOTE: Please make sure the Attribute Start values all contain an equal sign\n *       even in cases where they do not contain the start of an Attribute\n *       Value.\n */\n\n\n/* WML 1.0\n *\n * Wireless Markup Language\n ***************************************/\nstatic char *\next_t_0_wml_10(wmem_allocator_t* allocator, tvbuff_t *tvb, uint32_t value, uint32_t str_tbl)\n{\n\tchar *str = wmem_strdup_printf(allocator, \"Variable substitution - escaped: '%s'\",\n\t\t\t\t    tvb_get_stringz_enc(allocator, tvb, str_tbl + value, NULL, ENC_ASCII));\n\treturn str;\n}\n\nstatic char *\next_t_1_wml_10(wmem_allocator_t* allocator, tvbuff_t *tvb, uint32_t value, uint32_t str_tbl)\n{\n\tchar *str = wmem_strdup_printf(allocator, \"Variable substitution - unescaped: '%s'\",\n\t\t\t\t    tvb_get_stringz_enc(allocator, tvb, str_tbl + value, NULL, ENC_ASCII));\n\treturn str;\n}\n\nstatic char *\next_t_2_wml_10(wmem_allocator_t* allocator, tvbuff_t *tvb, uint32_t value, uint32_t str_tbl)\n{\n\tchar *str = wmem_strdup_printf(allocator, \"Variable substitution - no transformation: '%s'\",\n\t\t\t\t    tvb_get_stringz_enc(allocator, tvb, str_tbl + value, NULL, ENC_ASCII));\n\treturn str;\n}\n/*****   Global extension tokens   *****/\nstatic const value_string wbxml_wmlc10_global_cp0[] = {\n\t{ 0x40, \"Variable substitution - escaped\" },\n\t{ 0x41, \"Variable substitution - unescaped\" },\n\t{ 0x42, \"Variable substitution - no transformation\" },\n\t{ 0x80, \"Variable substitution - escaped\" },\n\t{ 0x81, \"Variable substitution - unescaped\" },\n\t{ 0x82, \"Variable substitution - no transformation\" },\n\t{ 0xC0, \"Reserved\" },\n\t{ 0xC1, \"Reserved\" },\n\t{ 0xC2, \"Reserved\" },\n\n\t{ 0x00, NULL }\n};\n\n/*****         Tag tokens          *****/\nstatic const value_string wbxml_wmlc10_tags_cp0[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t/* 0x05 -- 0x21 */\n\t{ 0x22, \"A\" },\n\t{ 0x23, \"ACCESS\" },\n\t{ 0x24, \"B\" },\n\t{ 0x25, \"BIG\" },\n\t{ 0x26, \"BR\" },\n\t{ 0x27, \"CARD\" },\n\t{ 0x28, \"DO\" },\n\t{ 0x29, \"EM\" },\n\t{ 0x2A, \"FIELDSET\" },\n\t{ 0x2B, \"GO\" },\n\t{ 0x2C, \"HEAD\" },\n\t{ 0x2D, \"I\" },\n\t{ 0x2E, \"IMG\" },\n\t{ 0x2F, \"INPUT\" },\n\t{ 0x30, \"META\" },\n\t{ 0x31, \"NOOP\" },\n\t{ 0x32, \"PREV\" },\n\t{ 0x33, \"ONEVENT\" },\n\t{ 0x34, \"OPTGROUP\" },\n\t{ 0x35, \"OPTION\" },\n\t{ 0x36, \"REFRESH\" },\n\t{ 0x37, \"SELECT\" },\n\t{ 0x38, \"SMALL\" },\n\t{ 0x39, \"STRONG\" },\n\t{ 0x3A, \"TAB\" },\n\t{ 0x3B, \"TEMPLATE\" },\n\t{ 0x3C, \"TIMER\" },\n\t{ 0x3D, \"U\" },\n\t{ 0x3E, \"VAR\" },\n\t{ 0x3F, \"WML\" },\n\n\t{ 0x00, NULL }\n};\n\n/*****    Attribute Start tokens   *****/\nstatic const value_string wbxml_wmlc10_attrStart_cp0[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"ACCEPT-CHARSET=\" },\n\t{ 0x06, \"ALIGN='BOTTOM'\" },\n\t{ 0x07, \"ALIGN='CENTER'\" },\n\t{ 0x08, \"ALIGN='LEFT'\" },\n\t{ 0x09, \"ALIGN='MIDDLE'\" },\n\t{ 0x0A, \"ALIGN='RIGHT'\" },\n\t{ 0x0B, \"ALIGN='TOP'\" },\n\t{ 0x0C, \"ALT=\" },\n\t{ 0x0D, \"CONTENT=\" },\n\t{ 0x0E, \"DEFAULT=\" },\n\t{ 0x0F, \"DOMAIN=\" },\n\t{ 0x10, \"EMPTYOK='FALSE'\" },\n\t{ 0x11, \"EMPTYOK='TRUE'\" },\n\t{ 0x12, \"FORMAT=\" },\n\t{ 0x13, \"HEIGHT=\" },\n\t{ 0x14, \"HSPACE=\" },\n\t{ 0x15, \"IDEFAULT=\" },\n\t{ 0x16, \"IKEY=\" },\n\t{ 0x17, \"KEY=\" },\n\t{ 0x18, \"LABEL=\" },\n\t{ 0x19, \"LOCALSRC=\" },\n\t{ 0x1A, \"MAXLENGTH=\" },\n\t{ 0x1B, \"METHOD='GET'\" },\n\t{ 0x1C, \"METHOD='POST'\" },\n\t{ 0x1D, \"MODE='NOWRAP'\" },\n\t{ 0x1E, \"MODE='WRAP'\" },\n\t{ 0x1F, \"MULTIPLE='FALSE'\" },\n\t{ 0x20, \"MULTIPLE='TRUE'\" },\n\t{ 0x21, \"NAME=\" },\n\t{ 0x22, \"NEWCONTEXT='FALSE'\" },\n\t{ 0x23, \"NEWCONTEXT='TRUE'\" },\n\t{ 0x24, \"ONCLICK=\" },\n\t{ 0x25, \"ONENTERBACKWARD=\" },\n\t{ 0x26, \"ONENTERFORWARD=\" },\n\t{ 0x27, \"ONTIMER=\" },\n\t{ 0x28, \"OPTIONAL='FALSE'\" },\n\t{ 0x29, \"OPTIONAL='TRUE'\" },\n\t{ 0x2A, \"PATH=\" },\n\t{ 0x2B, \"POSTDATA=\" },\n\t{ 0x2C, \"PUBLIC='FALSE'\" },\n\t{ 0x2D, \"PUBLIC='TRUE'\" },\n\t{ 0x2E, \"SCHEME=\" },\n\t{ 0x2F, \"SENDREFERER='FALSE'\" },\n\t{ 0x30, \"SENDREFERER='TRUE'\" },\n\t{ 0x31, \"SIZE=\" },\n\t{ 0x32, \"SRC=\" },\n\t{ 0x33, \"STYLE='LIST'\" },\n\t{ 0x34, \"STYLE='SET'\" },\n\t{ 0x35, \"TABINDEX=\" },\n\t{ 0x36, \"TITLE=\" },\n\t{ 0x37, \"TYPE=\" },\n\t{ 0x38, \"TYPE='ACCEPT'\" },\n\t{ 0x39, \"TYPE='DELETE'\" },\n\t{ 0x3A, \"TYPE='HELP'\" },\n\t{ 0x3B, \"TYPE='PASSWORD'\" },\n\t{ 0x3C, \"TYPE='ONCLICK'\" },\n\t{ 0x3D, \"TYPE='ONENTERBACKWARD'\" },\n\t{ 0x3E, \"TYPE='ONENTERFORWARD'\" },\n\t{ 0x3F, \"TYPE='ONTIMER'\" },\n\t/* 0x40 -- 0x44 GLOBAL */\n\t{ 0x45, \"TYPE='OPTIONS'\" },\n\t{ 0x46, \"TYPE='PREV'\" },\n\t{ 0x47, \"TYPE='RESET'\" },\n\t{ 0x48, \"TYPE='TEXT'\" },\n\t{ 0x49, \"TYPE='vnd.'\" },\n\t{ 0x4A, \"URL=\" },\n\t{ 0x4B, \"URL='http://'\" },\n\t{ 0x4C, \"URL='https://'\" },\n\t{ 0x4D, \"USER-AGENT=\" },\n\t{ 0x4E, \"VALUE=\" },\n\t{ 0x4F, \"VSPACE=\" },\n\t{ 0x50, \"WIDTH=\" },\n\t{ 0x51, \"xml:lang=\" },\n\n\t{ 0x00, NULL }\n};\n\n/*****    Attribute Value tokens   *****/\nstatic const value_string wbxml_wmlc10_attrValue_cp0[] = {\n\t/* 0x80 -- 0x84 GLOBAL */\n\t{ 0x85, \"'.com/'\" },\n\t{ 0x86, \"'.edu/'\" },\n\t{ 0x87, \"'.net/'\" },\n\t{ 0x88, \"'.org/'\" },\n\t{ 0x89, \"'ACCEPT'\" },\n\t{ 0x8A, \"'BOTTOM'\" },\n\t{ 0x8B, \"'CLEAR'\" },\n\t{ 0x8C, \"'DELETE'\" },\n\t{ 0x8D, \"'HELP'\" },\n\t{ 0x8E, \"'http://'\" },\n\t{ 0x8F, \"'http://www.'\" },\n\t{ 0x90, \"'https://'\" },\n\t{ 0x91, \"'https://www.'\" },\n\t{ 0x92, \"'LIST'\" },\n\t{ 0x93, \"'MIDDLE'\" },\n\t{ 0x94, \"'NOWRAP'\" },\n\t{ 0x95, \"'ONCLICK'\" },\n\t{ 0x96, \"'ONENTERBACKWARD'\" },\n\t{ 0x97, \"'ONENTERFORWARD'\" },\n\t{ 0x98, \"'ONTIMER'\" },\n\t{ 0x99, \"'OPTIONS'\" },\n\t{ 0x9A, \"'PASSWORD'\" },\n\t{ 0x9B, \"'RESET'\" },\n\t{ 0x9C, \"'SET'\" },\n\t{ 0x9D, \"'TEXT'\" },\n\t{ 0x9E, \"'TOP'\" },\n\t{ 0x9F, \"'UNKNOWN'\" },\n\t{ 0xA0, \"'WRAP'\" },\n\t{ 0xA1, \"'www.'\" },\n\n\t{ 0x00, NULL }\n};\n\n/***** Token code page aggregation *****/\nstatic const value_valuestring wbxml_wmlc10_global[] = {\n\t{ 0, wbxml_wmlc10_global_cp0 },\n\t{ 0, NULL }\n};\n\nstatic const value_valuestring wbxml_wmlc10_tags[] = {\n\t{ 0, wbxml_wmlc10_tags_cp0 },\n\t{ 0, NULL }\n};\n\nstatic const value_valuestring wbxml_wmlc10_attrStart[] = {\n\t{ 0, wbxml_wmlc10_attrStart_cp0 },\n\t{ 0, NULL }\n};\n\nstatic const value_valuestring wbxml_wmlc10_attrValue[] = {\n\t{ 0, wbxml_wmlc10_attrValue_cp0 },\n\t{ 0, NULL }\n};\n\nstatic const wbxml_decoding decode_wmlc_10 = {\n\t\"Wireless Markup Language 1.0\",\n\t\"WML 1.0\",\n\t{ ext_t_0_wml_10, ext_t_1_wml_10, ext_t_2_wml_10 },\n\tdefault_opaque_binary_tag,\n\tdefault_opaque_literal_tag,\n\tdefault_opaque_binary_attr,\n\tdefault_opaque_literal_attr,\n\twbxml_wmlc10_global,\n\twbxml_wmlc10_tags,\n\twbxml_wmlc10_attrStart,\n\twbxml_wmlc10_attrValue\n};\n\n\n\n\n/* WML 1.1\n *\n * Wireless Markup Language\n ***************************************/\n\n/*****   Global extension tokens   *****/\n/* Same as in WML 1.0 */\n\n/*****         Tag tokens          *****/\nstatic const value_string wbxml_wmlc11_tags_cp0[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t/* 0x05 -- 0x1B */\n\t{ 0x1C, \"a\" },\n\t{ 0x1D, \"td\" },\n\t{ 0x1E, \"tr\" },\n\t{ 0x1F, \"table\" },\n\t{ 0x20, \"p\" },\n\t{ 0x21, \"postfield\" },\n\t{ 0x22, \"anchor\" },\n\t{ 0x23, \"access\" },\n\t{ 0x24, \"b\" },\n\t{ 0x25, \"big\" },\n\t{ 0x26, \"br\" },\n\t{ 0x27, \"card\" },\n\t{ 0x28, \"do\" },\n\t{ 0x29, \"em\" },\n\t{ 0x2A, \"fieldset\" },\n\t{ 0x2B, \"go\" },\n\t{ 0x2C, \"head\" },\n\t{ 0x2D, \"i\" },\n\t{ 0x2E, \"img\" },\n\t{ 0x2F, \"input\" },\n\t{ 0x30, \"meta\" },\n\t{ 0x31, \"noop\" },\n\t{ 0x32, \"prev\" },\n\t{ 0x33, \"onevent\" },\n\t{ 0x34, \"optgroup\" },\n\t{ 0x35, \"option\" },\n\t{ 0x36, \"refresh\" },\n\t{ 0x37, \"select\" },\n\t{ 0x38, \"small\" },\n\t{ 0x39, \"strong\" },\n\t/* 0x3A */\n\t{ 0x3B, \"template\" },\n\t{ 0x3C, \"timer\" },\n\t{ 0x3D, \"u\" },\n\t{ 0x3E, \"setvar\" },\n\t{ 0x3F, \"wml\" },\n\n\t{ 0x00, NULL }\n};\n\n/*****    Attribute Start tokens   *****/\nstatic const value_string wbxml_wmlc11_attrStart_cp0[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"accept-charset=\" },\n\t{ 0x06, \"align='bottom'\" },\n\t{ 0x07, \"align='center'\" },\n\t{ 0x08, \"align='left'\" },\n\t{ 0x09, \"align='middle'\" },\n\t{ 0x0A, \"align='right'\" },\n\t{ 0x0B, \"align='top'\" },\n\t{ 0x0C, \"alt=\" },\n\t{ 0x0D, \"content=\" },\n\t/* 0x0E */\n\t{ 0x0F, \"domain=\" },\n\t{ 0x10, \"emptyok='false'\" },\n\t{ 0x11, \"emptyok='true'\" },\n\t{ 0x12, \"format=\" },\n\t{ 0x13, \"height=\" },\n\t{ 0x14, \"hspace=\" },\n\t{ 0x15, \"ivalue=\" },\n\t{ 0x16, \"iname=\" },\n\t/* 0x17 */\n\t{ 0x18, \"label=\" },\n\t{ 0x19, \"localsrc=\" },\n\t{ 0x1A, \"maxlength=\" },\n\t{ 0x1B, \"method='get'\" },\n\t{ 0x1C, \"method='post'\" },\n\t{ 0x1D, \"mode='nowrap'\" },\n\t{ 0x1E, \"mode='wrap'\" },\n\t{ 0x1F, \"multiple='false'\" },\n\t{ 0x20, \"multiple='true'\" },\n\t{ 0x21, \"name=\" },\n\t{ 0x22, \"newcontext='false'\" },\n\t{ 0x23, \"newcontext='true'\" },\n\t{ 0x24, \"onpick=\" },\n\t{ 0x25, \"onenterbackward=\" },\n\t{ 0x26, \"onenterforward=\" },\n\t{ 0x27, \"ontimer=\" },\n\t{ 0x28, \"optional='false'\" },\n\t{ 0x29, \"optional='true'\" },\n\t{ 0x2A, \"path=\" },\n\t/* 0x2B -- 0x2D */\n\t{ 0x2E, \"scheme=\" },\n\t{ 0x2F, \"sendreferer='false'\" },\n\t{ 0x30, \"sendreferer='true'\" },\n\t{ 0x31, \"size=\" },\n\t{ 0x32, \"src=\" },\n\t{ 0x33, \"ordered='false'\" },\n\t{ 0x34, \"ordered='true'\" },\n\t{ 0x35, \"tabindex=\" },\n\t{ 0x36, \"title=\" },\n\t{ 0x37, \"type=\" },\n\t{ 0x38, \"type='accept'\" },\n\t{ 0x39, \"type='delete'\" },\n\t{ 0x3A, \"type='help'\" },\n\t{ 0x3B, \"type='password'\" },\n\t{ 0x3C, \"type='onpick'\" },\n\t{ 0x3D, \"type='onenterbackward'\" },\n\t{ 0x3E, \"type='onenterforward'\" },\n\t{ 0x3F, \"type='ontimer'\" },\n\t/* 0x40 -- 0x44 GLOBAL */\n\t{ 0x45, \"type='options'\" },\n\t{ 0x46, \"type='prev'\" },\n\t{ 0x47, \"type='reset'\" },\n\t{ 0x48, \"type='text'\" },\n\t{ 0x49, \"type='vnd.'\" },\n\t{ 0x4A, \"href=\" },\n\t{ 0x4B, \"href='http://'\" },\n\t{ 0x4C, \"href='https://'\" },\n\t{ 0x4D, \"value=\" },\n\t{ 0x4E, \"vspace=\" },\n\t{ 0x4F, \"width=\" },\n\t{ 0x50, \"xml:lang=\" },\n\t/* 0x51 */\n\t{ 0x52, \"align=\" },\n\t{ 0x53, \"columns=\" },\n\t{ 0x54, \"class=\" },\n\t{ 0x55, \"id=\" },\n\t{ 0x56, \"forua='false'\" },\n\t{ 0x57, \"forua='true'\" },\n\t{ 0x58, \"src='http://'\" },\n\t{ 0x59, \"src='https://'\" },\n\t{ 0x5A, \"http-equiv=\" },\n\t{ 0x5B, \"http-equiv='Content-Type'\" },\n\t{ 0x5C, \"content='application/vnd.wap.wmlc;charset='\" },\n\t{ 0x5D, \"http-equiv='Expires'\" },\n\n\t{ 0x00, NULL }\n};\n\n/*****    Attribute Value tokens   *****/\nstatic const value_string wbxml_wmlc11_attrValue_cp0[] = {\n\t/* 0x80 -- 0x84 GLOBAL */\n\t{ 0x85, \"'.com/'\" },\n\t{ 0x86, \"'.edu/'\" },\n\t{ 0x87, \"'.net/'\" },\n\t{ 0x88, \"'.org/'\" },\n\t{ 0x89, \"'accept'\" },\n\t{ 0x8A, \"'bottom'\" },\n\t{ 0x8B, \"'clear'\" },\n\t{ 0x8C, \"'delete'\" },\n\t{ 0x8D, \"'help'\" },\n\t{ 0x8E, \"'http://'\" },\n\t{ 0x8F, \"'http://www.'\" },\n\t{ 0x90, \"'https://'\" },\n\t{ 0x91, \"'https://www.'\" },\n\t/* 0x92 */\n\t{ 0x93, \"'middle'\" },\n\t{ 0x94, \"'nowrap'\" },\n\t{ 0x95, \"'onpick'\" },\n\t{ 0x96, \"'onenterbackward'\" },\n\t{ 0x97, \"'onenterforward'\" },\n\t{ 0x98, \"'ontimer'\" },\n\t{ 0x99, \"'options'\" },\n\t{ 0x9A, \"'password'\" },\n\t{ 0x9B, \"'reset'\" },\n\t/* 0x9C */\n\t{ 0x9D, \"'text'\" },\n\t{ 0x9E, \"'top'\" },\n\t{ 0x9F, \"'unknown'\" },\n\t{ 0xA0, \"'wrap'\" },\n\t{ 0xA1, \"'www.'\" },\n\n\t{ 0x00, NULL }\n};\n\n/***** Token code page aggregation *****/\nstatic const value_valuestring wbxml_wmlc11_global[] = {\n\t{ 0, wbxml_wmlc10_global_cp0 }, /* Same as WML 1.0 */\n\t{ 0, NULL }\n};\n\nstatic const value_valuestring wbxml_wmlc11_tags[] = {\n\t{ 0, wbxml_wmlc11_tags_cp0 },\n\t{ 0, NULL }\n};\n\nstatic const value_valuestring wbxml_wmlc11_attrStart[] = {\n\t{ 0, wbxml_wmlc11_attrStart_cp0 },\n\t{ 0, NULL }\n};\n\nstatic const value_valuestring wbxml_wmlc11_attrValue[] = {\n\t{ 0, wbxml_wmlc11_attrValue_cp0 },\n\t{ 0, NULL }\n};\n\nstatic const wbxml_decoding decode_wmlc_11 = {\n\t\"Wireless Markup Language 1.1\",\n\t\"WML 1.1\",\n\t{ ext_t_0_wml_10, ext_t_1_wml_10, ext_t_2_wml_10 },\n\tdefault_opaque_binary_tag,\n\tdefault_opaque_literal_tag,\n\tdefault_opaque_binary_attr,\n\tdefault_opaque_literal_attr,\n\twbxml_wmlc11_global,\n\twbxml_wmlc11_tags,\n\twbxml_wmlc11_attrStart,\n\twbxml_wmlc11_attrValue\n};\n\n\n\n\n\n/* WML 1.2\n *\n * Wireless Markup Language\n ***************************************/\n\n/*****   Global extension tokens   *****/\n/* Same as in WML 1.0 */\n\n/*****         Tag tokens          *****/\nstatic const value_string wbxml_wmlc12_tags_cp0[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t/* 0x05 -- 0x1A */\n\t{ 0x1B, \"pre\" },\n\t{ 0x1C, \"a\" },\n\t{ 0x1D, \"td\" },\n\t{ 0x1E, \"tr\" },\n\t{ 0x1F, \"table\" },\n\t{ 0x20, \"p\" },\n\t{ 0x21, \"postfield\" },\n\t{ 0x22, \"anchor\" },\n\t{ 0x23, \"access\" },\n\t{ 0x24, \"b\" },\n\t{ 0x25, \"big\" },\n\t{ 0x26, \"br\" },\n\t{ 0x27, \"card\" },\n\t{ 0x28, \"do\" },\n\t{ 0x29, \"em\" },\n\t{ 0x2A, \"fieldset\" },\n\t{ 0x2B, \"go\" },\n\t{ 0x2C, \"head\" },\n\t{ 0x2D, \"i\" },\n\t{ 0x2E, \"img\" },\n\t{ 0x2F, \"input\" },\n\t{ 0x30, \"meta\" },\n\t{ 0x31, \"noop\" },\n\t{ 0x32, \"prev\" },\n\t{ 0x33, \"onevent\" },\n\t{ 0x34, \"optgroup\" },\n\t{ 0x35, \"option\" },\n\t{ 0x36, \"refresh\" },\n\t{ 0x37, \"select\" },\n\t{ 0x38, \"small\" },\n\t{ 0x39, \"strong\" },\n\t/* 0x3A */\n\t{ 0x3B, \"template\" },\n\t{ 0x3C, \"timer\" },\n\t{ 0x3D, \"u\" },\n\t{ 0x3E, \"setvar\" },\n\t{ 0x3F, \"wml\" },\n\n\t{ 0x00, NULL }\n};\n\n/*****    Attribute Start tokens   *****/\nstatic const value_string wbxml_wmlc12_attrStart_cp0[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"accept-charset=\" },\n\t{ 0x06, \"align='bottom'\" },\n\t{ 0x07, \"align='center'\" },\n\t{ 0x08, \"align='left'\" },\n\t{ 0x09, \"align='middle'\" },\n\t{ 0x0A, \"align='right'\" },\n\t{ 0x0B, \"align='top'\" },\n\t{ 0x0C, \"alt=\" },\n\t{ 0x0D, \"content=\" },\n\t/* 0x0E */\n\t{ 0x0F, \"domain=\" },\n\t{ 0x10, \"emptyok='false'\" },\n\t{ 0x11, \"emptyok='true'\" },\n\t{ 0x12, \"format=\" },\n\t{ 0x13, \"height=\" },\n\t{ 0x14, \"hspace=\" },\n\t{ 0x15, \"ivalue=\" },\n\t{ 0x16, \"iname=\" },\n\t/* 0x17 */\n\t{ 0x18, \"label=\" },\n\t{ 0x19, \"localsrc=\" },\n\t{ 0x1A, \"maxlength=\" },\n\t{ 0x1B, \"method='get'\" },\n\t{ 0x1C, \"method='post'\" },\n\t{ 0x1D, \"mode='nowrap'\" },\n\t{ 0x1E, \"mode='wrap'\" },\n\t{ 0x1F, \"multiple='false'\" },\n\t{ 0x20, \"multiple='true'\" },\n\t{ 0x21, \"name=\" },\n\t{ 0x22, \"newcontext='false'\" },\n\t{ 0x23, \"newcontext='true'\" },\n\t{ 0x24, \"onpick=\" },\n\t{ 0x25, \"onenterbackward=\" },\n\t{ 0x26, \"onenterforward=\" },\n\t{ 0x27, \"ontimer=\" },\n\t{ 0x28, \"optional='false'\" },\n\t{ 0x29, \"optional='true'\" },\n\t{ 0x2A, \"path=\" },\n\t/* 0x2B -- 0x2D */\n\t{ 0x2E, \"scheme=\" },\n\t{ 0x2F, \"sendreferer='false'\" },\n\t{ 0x30, \"sendreferer='true'\" },\n\t{ 0x31, \"size=\" },\n\t{ 0x32, \"src=\" },\n\t{ 0x33, \"ordered='false'\" },\n\t{ 0x34, \"ordered='true'\" },\n\t{ 0x35, \"tabindex=\" },\n\t{ 0x36, \"title=\" },\n\t{ 0x37, \"type=\" },\n\t{ 0x38, \"type='accept'\" },\n\t{ 0x39, \"type='delete'\" },\n\t{ 0x3A, \"type='help'\" },\n\t{ 0x3B, \"type='password'\" },\n\t{ 0x3C, \"type='onpick'\" },\n\t{ 0x3D, \"type='onenterbackward'\" },\n\t{ 0x3E, \"type='onenterforward'\" },\n\t{ 0x3F, \"type='ontimer'\" },\n\t/* 0x40 -- 0x44 GLOBAL */\n\t{ 0x45, \"type='options'\" },\n\t{ 0x46, \"type='prev'\" },\n\t{ 0x47, \"type='reset'\" },\n\t{ 0x48, \"type='text'\" },\n\t{ 0x49, \"type='vnd.'\" },\n\t{ 0x4A, \"href=\" },\n\t{ 0x4B, \"href='http://'\" },\n\t{ 0x4C, \"href='https://'\" },\n\t{ 0x4D, \"value=\" },\n\t{ 0x4E, \"vspace=\" },\n\t{ 0x4F, \"width=\" },\n\t{ 0x50, \"xml:lang=\" },\n\t/* 0x51 */\n\t{ 0x52, \"align=\" },\n\t{ 0x53, \"columns=\" },\n\t{ 0x54, \"class=\" },\n\t{ 0x55, \"id=\" },\n\t{ 0x56, \"forua='false'\" },\n\t{ 0x57, \"forua='true'\" },\n\t{ 0x58, \"src='http://'\" },\n\t{ 0x59, \"src='https://'\" },\n\t{ 0x5A, \"http-equiv=\" },\n\t{ 0x5B, \"http-equiv='Content-Type'\" },\n\t{ 0x5C, \"content='application/vnd.wap.wmlc;charset='\" },\n\t{ 0x5D, \"http-equiv='Expires'\" },\n\t{ 0x5E, \"accesskey=\" },\n\t{ 0x5F, \"enctype=\" },\n\t{ 0x60, \"enctype='application/x-www-form-urlencoded'\" },\n\t{ 0x61, \"enctype='multipart/form-data'\" },\n\n\t{ 0x00, NULL }\n};\n\n/*****    Attribute Value tokens   *****/\n/* Same as in WML 1.1 */\n\n/***** Token code page aggregation *****/\nstatic const value_valuestring wbxml_wmlc12_global[] = {\n\t{ 0, wbxml_wmlc10_global_cp0 }, /* Same as WML 1.0 */\n\t{ 0, NULL }\n};\n\nstatic const value_valuestring wbxml_wmlc12_tags[] = {\n\t{ 0, wbxml_wmlc12_tags_cp0 },\n\t{ 0, NULL }\n};\n\nstatic const value_valuestring wbxml_wmlc12_attrStart[] = {\n\t{ 0, wbxml_wmlc12_attrStart_cp0 },\n\t{ 0, NULL }\n};\n\nstatic const value_valuestring wbxml_wmlc12_attrValue[] = {\n\t{ 0, wbxml_wmlc11_attrValue_cp0 }, /* Same as WML 1.1 */\n\t{ 0, NULL }\n};\n\nstatic const wbxml_decoding decode_wmlc_12 = {\n\t\"Wireless Markup Language 1.2\",\n\t\"WML 1.2\",\n\t{ ext_t_0_wml_10, ext_t_1_wml_10, ext_t_2_wml_10 },\n\tdefault_opaque_binary_tag,\n\tdefault_opaque_literal_tag,\n\tdefault_opaque_binary_attr,\n\tdefault_opaque_literal_attr,\n\twbxml_wmlc12_global,\n\twbxml_wmlc12_tags,\n\twbxml_wmlc12_attrStart,\n\twbxml_wmlc12_attrValue\n};\n\n\n\n\n\n/* WML 1.3\n *\n * Wireless Markup Language\n ***************************************/\n\n/*****   Global extension tokens   *****/\n/* Same as in WML 1.0 */\n\n/*****         Tag tokens          *****/\n/* Same as in WML 1.2 */\n\n/*****    Attribute Start tokens   *****/\nstatic const value_string wbxml_wmlc13_attrStart_cp0[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"accept-charset=\" },\n\t{ 0x06, \"align='bottom'\" },\n\t{ 0x07, \"align='center'\" },\n\t{ 0x08, \"align='left'\" },\n\t{ 0x09, \"align='middle'\" },\n\t{ 0x0A, \"align='right'\" },\n\t{ 0x0B, \"align='top'\" },\n\t{ 0x0C, \"alt=\" },\n\t{ 0x0D, \"content=\" },\n\t/* 0x0E */\n\t{ 0x0F, \"domain=\" },\n\t{ 0x10, \"emptyok='false'\" },\n\t{ 0x11, \"emptyok='true'\" },\n\t{ 0x12, \"format=\" },\n\t{ 0x13, \"height=\" },\n\t{ 0x14, \"hspace=\" },\n\t{ 0x15, \"ivalue=\" },\n\t{ 0x16, \"iname=\" },\n\t/* 0x17 */\n\t{ 0x18, \"label=\" },\n\t{ 0x19, \"localsrc=\" },\n\t{ 0x1A, \"maxlength=\" },\n\t{ 0x1B, \"method='get'\" },\n\t{ 0x1C, \"method='post'\" },\n\t{ 0x1D, \"mode='nowrap'\" },\n\t{ 0x1E, \"mode='wrap'\" },\n\t{ 0x1F, \"multiple='false'\" },\n\t{ 0x20, \"multiple='true'\" },\n\t{ 0x21, \"name=\" },\n\t{ 0x22, \"newcontext='false'\" },\n\t{ 0x23, \"newcontext='true'\" },\n\t{ 0x24, \"onpick=\" },\n\t{ 0x25, \"onenterbackward=\" },\n\t{ 0x26, \"onenterforward=\" },\n\t{ 0x27, \"ontimer=\" },\n\t{ 0x28, \"optional='false'\" },\n\t{ 0x29, \"optional='true'\" },\n\t{ 0x2A, \"path=\" },\n\t/* 0x2B -- 0x2D */\n\t{ 0x2E, \"scheme=\" },\n\t{ 0x2F, \"sendreferer='false'\" },\n\t{ 0x30, \"sendreferer='true'\" },\n\t{ 0x31, \"size=\" },\n\t{ 0x32, \"src=\" },\n\t{ 0x33, \"ordered='false'\" },\n\t{ 0x34, \"ordered='true'\" },\n\t{ 0x35, \"tabindex=\" },\n\t{ 0x36, \"title=\" },\n\t{ 0x37, \"type=\" },\n\t{ 0x38, \"type='accept'\" },\n\t{ 0x39, \"type='delete'\" },\n\t{ 0x3A, \"type='help'\" },\n\t{ 0x3B, \"type='password'\" },\n\t{ 0x3C, \"type='onpick'\" },\n\t{ 0x3D, \"type='onenterbackward'\" },\n\t{ 0x3E, \"type='onenterforward'\" },\n\t{ 0x3F, \"type='ontimer'\" },\n\t/* 0x40 -- 0x44 GLOBAL */\n\t{ 0x45, \"type='options'\" },\n\t{ 0x46, \"type='prev'\" },\n\t{ 0x47, \"type='reset'\" },\n\t{ 0x48, \"type='text'\" },\n\t{ 0x49, \"type='vnd.'\" },\n\t{ 0x4A, \"href=\" },\n\t{ 0x4B, \"href='http://'\" },\n\t{ 0x4C, \"href='https://'\" },\n\t{ 0x4D, \"value=\" },\n\t{ 0x4E, \"vspace=\" },\n\t{ 0x4F, \"width=\" },\n\t{ 0x50, \"xml:lang=\" },\n\t/* 0x51 */\n\t{ 0x52, \"align=\" },\n\t{ 0x53, \"columns=\" },\n\t{ 0x54, \"class=\" },\n\t{ 0x55, \"id=\" },\n\t{ 0x56, \"forua='false'\" },\n\t{ 0x57, \"forua='true'\" },\n\t{ 0x58, \"src='http://'\" },\n\t{ 0x59, \"src='https://'\" },\n\t{ 0x5A, \"http-equiv=\" },\n\t{ 0x5B, \"http-equiv='Content-Type'\" },\n\t{ 0x5C, \"content='application/vnd.wap.wmlc;charset='\" },\n\t{ 0x5D, \"http-equiv='Expires'\" },\n\t{ 0x5E, \"accesskey=\" },\n\t{ 0x5F, \"enctype=\" },\n\t{ 0x60, \"enctype='application/x-www-form-urlencoded'\" },\n\t{ 0x61, \"enctype='multipart/form-data'\" },\n\t{ 0x62, \"xml:space='preserve'\" },\n\t{ 0x63, \"xml:space='default'\" },\n\t{ 0x64, \"cache-control='no-cache'\" },\n\n\t{ 0x00, NULL }\n};\n\n/*****    Attribute Value tokens   *****/\n/* Same as in WML 1.1 */\n\n/***** Token code page aggregation *****/\nstatic const value_valuestring wbxml_wmlc13_global[] = {\n\t{ 0, wbxml_wmlc10_global_cp0 }, /* Same as WML 1.0 */\n\t{ 0, NULL }\n};\n\nstatic const value_valuestring wbxml_wmlc13_tags[] = {\n\t{ 0, wbxml_wmlc12_tags_cp0 },\n\t{ 0, NULL }\n};\n\nstatic const value_valuestring wbxml_wmlc13_attrStart[] = {\n\t{ 0, wbxml_wmlc13_attrStart_cp0 },\n\t{ 0, NULL }\n};\n\nstatic const value_valuestring wbxml_wmlc13_attrValue[] = {\n\t{ 0, wbxml_wmlc11_attrValue_cp0 }, /* Same as WML 1.1 */\n\t{ 0, NULL }\n};\n\nstatic const wbxml_decoding decode_wmlc_13 = {\n\t\"Wireless Markup Language 1.3\",\n\t\"WML 1.3\",\n\t{ ext_t_0_wml_10, ext_t_1_wml_10, ext_t_2_wml_10 },\n\tdefault_opaque_binary_tag,\n\tdefault_opaque_literal_tag,\n\tdefault_opaque_binary_attr,\n\tdefault_opaque_literal_attr,\n\twbxml_wmlc13_global,\n\twbxml_wmlc13_tags,\n\twbxml_wmlc13_attrStart,\n\twbxml_wmlc13_attrValue\n};\n\n\n\n\n\n/* SI 1.0\n *\n * Service Indication\n ***************************************/\n\n/*****   Global extension tokens   *****/\n\n/*****         Tag tokens          *****/\nstatic const value_string wbxml_sic10_tags_cp0[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"si\" },\n\t{ 0x06, \"indication\" },\n\t{ 0x07, \"info\" },\n\t{ 0x08, \"item\" },\n\n\t{ 0x00, NULL }\n};\n\n/*****    Attribute Start tokens   *****/\nstatic const value_string wbxml_sic10_attrStart_cp0[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"action='signal-none'\" },\n\t{ 0x06, \"action='signal-low'\" },\n\t{ 0x07, \"action='signal-medium'\" },\n\t{ 0x08, \"action='signal-high'\" },\n\t{ 0x09, \"action='delete'\" },\n\t{ 0x0a, \"created=\" },\n\t{ 0x0b, \"href=\" },\n\t{ 0x0c, \"href='http://'\" },\n\t{ 0x0d, \"href='http://www.'\" },\n\t{ 0x0e, \"href='https://'\" },\n\t{ 0x0f, \"href='https://www.'\" },\n\t{ 0x10, \"si-expires=\" },\n\t{ 0x11, \"si-id=\" },\n\t{ 0x12, \"class=\" },\n\n\t{ 0x00, NULL }\n};\n\n/*****    Attribute Value tokens   *****/\nstatic const value_string wbxml_sic10_attrValue_cp0[] = {\n\t/* 0x80 -- 0x84 GLOBAL */\n\t{ 0x85, \"'.com/'\" },\n\t{ 0x86, \"'.edu/'\" },\n\t{ 0x87, \"'.net/'\" },\n\t{ 0x88, \"'.org/'\" },\n\n\t{ 0x00, NULL }\n};\n\n/***** Token code page aggregation *****/\nstatic const value_valuestring wbxml_sic10_tags[] = {\n\t{ 0, wbxml_sic10_tags_cp0 },\n\t{ 0, NULL }\n};\n\nstatic const value_valuestring wbxml_sic10_attrStart[] = {\n\t{ 0, wbxml_sic10_attrStart_cp0 },\n\t{ 0, NULL }\n};\n\nstatic const value_valuestring wbxml_sic10_attrValue[] = {\n\t{ 0, wbxml_sic10_attrValue_cp0 },\n\t{ 0, NULL }\n};\n\nstatic const wbxml_decoding decode_sic_10 = {\n\t\"Service Indication 1.0\",\n\t\"SI 1.0\",\n\t{ NULL, NULL, NULL },\n\tdefault_opaque_binary_tag,\n\tdefault_opaque_literal_tag,\n\tsic10_opaque_binary_attr,\n\tsic10_opaque_literal_attr,\n\tNULL,\n\twbxml_sic10_tags,\n\twbxml_sic10_attrStart,\n\twbxml_sic10_attrValue\n};\n\n\n\n\n\n/* SL 1.0\n *\n * Service Loading\n ***************************************/\n\n/*****   Global extension tokens   *****/\n\n/*****         Tag tokens          *****/\nstatic const value_string wbxml_slc10_tags_cp0[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"sl\" },\n\n\t{ 0x00, NULL }\n};\n\n/*****    Attribute Start tokens   *****/\nstatic const value_string wbxml_slc10_attrStart_cp0[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"action='execute-low'\" },\n\t{ 0x06, \"action='execute-high'\" },\n\t{ 0x07, \"action='cache'\" },\n\t{ 0x08, \"href=\" },\n\t{ 0x09, \"href='http://'\" },\n\t{ 0x0a, \"href='http://www.'\" },\n\t{ 0x0b, \"href='https://'\" },\n\t{ 0x0c, \"href='https://www.'\" },\n\n\t{ 0x00, NULL }\n};\n\n/*****    Attribute Value tokens   *****/\n/* Same as in SI 1.0 */\n\n/***** Token code page aggregation *****/\nstatic const value_valuestring wbxml_slc10_tags[] = {\n\t{ 0, wbxml_slc10_tags_cp0 },\n\t{ 0, NULL }\n};\n\nstatic const value_valuestring wbxml_slc10_attrStart[] = {\n\t{ 0, wbxml_slc10_attrStart_cp0 },\n\t{ 0, NULL }\n};\n\nstatic const value_valuestring wbxml_slc10_attrValue[] = {\n\t{ 0, wbxml_sic10_attrValue_cp0 }, /* Same as SI 1.0 */\n\t{ 0, NULL }\n};\n\nstatic const wbxml_decoding decode_slc_10 = {\n\t\"Service Loading 1.0\",\n\t\"SL 1.0\",\n\t{ NULL, NULL, NULL },\n\tdefault_opaque_binary_tag,\n\tdefault_opaque_literal_tag,\n\tdefault_opaque_binary_attr,\n\tdefault_opaque_literal_attr,\n\tNULL,\n\twbxml_slc10_tags,\n\twbxml_slc10_attrStart,\n\twbxml_slc10_attrValue\n};\n\n\n\n\n\n/* CO 1.0\n *\n * Cache Operation\n ***************************************/\n\n/*****   Global extension tokens   *****/\n\n/*****         Tag tokens          *****/\nstatic const value_string wbxml_coc10_tags_cp0[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"co\" },\n\t{ 0x06, \"invalidate-object\" },\n\t{ 0x07, \"invalidate-service\" },\n\n\t{ 0x00, NULL }\n};\n\n/*****    Attribute Start tokens   *****/\nstatic const value_string wbxml_coc10_attrStart_cp0[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"uri=\" },\n\t{ 0x06, \"uri='http://'\" },\n\t{ 0x07, \"uri='http://www.'\" },\n\t{ 0x08, \"uri='https://'\" },\n\t{ 0x09, \"uri='https://www.'\" },\n\n\t{ 0x00, NULL }\n};\n\n/*****    Attribute Value tokens   *****/\n/* Same as in SI 1.0 */\n\n/***** Token code page aggregation *****/\nstatic const value_valuestring wbxml_coc10_tags[] = {\n\t{ 0, wbxml_coc10_tags_cp0 },\n\t{ 0, NULL }\n};\n\nstatic const value_valuestring wbxml_coc10_attrStart[] = {\n\t{ 0, wbxml_coc10_attrStart_cp0 },\n\t{ 0, NULL }\n};\n\nstatic const value_valuestring wbxml_coc10_attrValue[] = {\n\t{ 0, wbxml_sic10_attrValue_cp0 }, /* Same as SI 1.0 */\n\t{ 0, NULL }\n};\n\nstatic const wbxml_decoding decode_coc_10 = {\n\t\"Cache Operation 1.0\",\n\t\"CO 1.0\",\n\t{ NULL, NULL, NULL },\n\tdefault_opaque_binary_tag,\n\tdefault_opaque_literal_tag,\n\tdefault_opaque_binary_attr,\n\tdefault_opaque_literal_attr,\n\tNULL,\n\twbxml_coc10_tags,\n\twbxml_coc10_attrStart,\n\twbxml_coc10_attrValue\n};\n\n\n\n\n\n/* PROV 1.0\n *\n * Client Provisioning\n ***************************************/\n\n/*****   Global extension tokens   *****/\n\n/*****         Tag tokens          *****/\nstatic const value_string wbxml_provc10_tags_cp0[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"wap-provisioningdoc\" },\n\t{ 0x06, \"characteristic\" },\n\t{ 0x07, \"parm\" },\n\n\t{ 0x00, NULL }\n};\nstatic const value_string wbxml_provc10_tags_cp1[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t/* 0x05 */\n\t{ 0x06, \"characteristic\" },\n\t{ 0x07, \"parm\" },\n\n\t{ 0x00, NULL }\n};\n\n/*****    Attribute Start tokens   *****/\nstatic const value_string wbxml_provc10_attrStart_cp0[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"name=\" },\n\t{ 0x06, \"value=\" },\n\t{ 0x07, \"name='NAME'\" },\n\t{ 0x08, \"name='NAP-ADDRESS'\" },\n\t{ 0x09, \"name='NAP-ADDRTYPE'\" },\n\t{ 0x0A, \"name='CALLTYPE'\" },\n\t{ 0x0B, \"name='VALIDUNTIL'\" },\n\t{ 0x0C, \"name='AUTHTYPE'\" },\n\t{ 0x0D, \"name='AUTHNAME'\" },\n\t{ 0x0E, \"name='AUTHSECRET'\" },\n\t{ 0x0F, \"name='LINGER'\" },\n\t{ 0x10, \"name='BEARER'\" },\n\t{ 0x11, \"name='NAPID'\" },\n\t{ 0x12, \"name='COUNTRY'\" },\n\t{ 0x13, \"name='NETWORK'\" },\n\t{ 0x14, \"name='INTERNET'\" },\n\t{ 0x15, \"name='PROXY-ID'\" },\n\t{ 0x16, \"name='PROXY-PROVIDER-ID'\" },\n\t{ 0x17, \"name='DOMAIN'\" },\n\t{ 0x18, \"name='PROVURL'\" },\n\t{ 0x19, \"name='PXAUTH-TYPE'\" },\n\t{ 0x1A, \"name='PXAUTH-ID'\" },\n\t{ 0x1B, \"name='PXAUTH-PW'\" },\n\t{ 0x1C, \"name='STARTPAGE'\" },\n\t{ 0x1D, \"name='BASAUTH-ID'\" },\n\t{ 0x1E, \"name='BASAUTH-PW'\" },\n\t{ 0x1F, \"name='PUSHENABLED'\" },\n\t{ 0x20, \"name='PXADDR'\" },\n\t{ 0x21, \"name='PXADDRTYPE'\" },\n\t{ 0x22, \"name='TO-NAPID'\" },\n\t{ 0x23, \"name='PORTNBR'\" },\n\t{ 0x24, \"name='SERVICE'\" },\n\t{ 0x25, \"name='LINKSPEED'\" },\n\t{ 0x26, \"name='DNLINKSPEED'\" },\n\t{ 0x27, \"name='LOCAL-ADDR'\" },\n\t{ 0x28, \"name='LOCAL-ADDRTYPE'\" },\n\t{ 0x29, \"name='CONTEXT-ALLOW'\" },\n\t{ 0x2A, \"name='TRUST'\" },\n\t{ 0x2B, \"name='MASTER'\" },\n\t{ 0x2C, \"name='SID'\" },\n\t{ 0x2D, \"name='SOC'\" },\n\t{ 0x2E, \"name='WSP-VERSION'\" },\n\t{ 0x2F, \"name='PHYSICAL-PROXY-ID'\" },\n\t{ 0x30, \"name='CLIENT-ID'\" },\n\t{ 0x31, \"name='DELIVERY-ERR-SDU'\" },\n\t{ 0x32, \"name='DELIVERY-ORDER'\" },\n\t{ 0x33, \"name='TRAFFIC-CLASS'\" },\n\t{ 0x34, \"name='MAX-SDU-SIZE'\" },\n\t{ 0x35, \"name='MAX-BITRATE-UPLINK'\" },\n\t{ 0x36, \"name='MAX-BITRATE-DNLINK'\" },\n\t{ 0x37, \"name='RESIDUAL-BER'\" },\n\t{ 0x38, \"name='SDU-ERROR-RATIO'\" },\n\t{ 0x39, \"name='TRAFFIC-HANDL-PRIO'\" },\n\t{ 0x3A, \"name='TRANSFER-DELAY'\" },\n\t{ 0x3B, \"name='GUARANTEED-BITRATE-UPLINK'\" },\n\t{ 0x3C, \"name='GUARANTEED-BITRATE-DNLINK'\" },\n\t{ 0x3D, \"name='PXADDR-FQDN'\" },\n\t{ 0x3E, \"name='PROXY-PW'\" },\n\t{ 0x3F, \"name='PPGAUTH-TYPE'\" },\n\t/* 0x40 -- 0x44 GLOBAL */\n\t{ 0x45, \"version=\" },\n\t{ 0x46, \"version='1.0'\" },\n\t{ 0x47, \"name='PULLENABLED'\" },\n\t{ 0x48, \"name='DNS-ADDR'\" },\n\t{ 0x49, \"name='MAX-NUM-RETRY'\" },\n\t{ 0x4A, \"name='FIRST-RETRY-TIMEOUT'\" },\n\t{ 0x4B, \"name='REREG-THRESHOLD'\" },\n\t{ 0x4C, \"name='T-BIT'\" },\n\t/* 0x4D */\n\t{ 0x4E, \"name='AUTH-ENTITY'\" },\n\t{ 0x4F, \"name='SPI'\" },\n\t{ 0x50, \"type=\" },\n\t{ 0x51, \"type='PXLOGICAL'\" },\n\t{ 0x52, \"type='PXPHYSICAL'\" },\n\t{ 0x53, \"type='PORT'\" },\n\t{ 0x54, \"type='VALIDITY'\" },\n\t{ 0x55, \"type='NAPDEF'\" },\n\t{ 0x56, \"type='BOOTSTRAP'\" },\n\t{ 0x57, \"type='VENDORCONFIG'\" },\n\t{ 0x58, \"type='CLIENTIDENTITY'\" },\n\t{ 0x59, \"type='PXAUTHINFO'\" },\n\t{ 0x5A, \"type='NAPAUTHINFO'\" },\n\t{ 0x5B, \"type='ACCESS'\" },\n\n\t{ 0x00, NULL }\n};\nstatic const value_string wbxml_provc10_attrStart_cp1[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t/* 0x05 -- 0x06 */\n\t{ 0x07, \"name='NAME'\" },\n\t/* 0x08 -- 0x13 */\n\t{ 0x14, \"name='INTERNET'\" },\n\t/* 0x15 -- 0x1B */\n\t{ 0x1C, \"name='STARTPAGE'\" },\n\t/* 0x1D -- 0x21 */\n\t{ 0x22, \"name='TO-NAPID'\" },\n\t{ 0x23, \"name='PORTNBR'\" },\n\t{ 0x24, \"name='SERVICE'\" },\n\t/* 0x25 -- 0x2D */\n\t{ 0x2E, \"name='AACCEPT'\" },\n\t{ 0x2F, \"name='AAUTHDATA'\" },\n\t{ 0x30, \"name='AAUTHLEVEL'\" },\n\t{ 0x31, \"name='AAUTHNAME'\" },\n\t{ 0x32, \"name='AAUTHSECRET'\" },\n\t{ 0x33, \"name='AAUTHTYPE'\" },\n\t{ 0x34, \"name='ADDR'\" },\n\t{ 0x35, \"name='ADDRTYPE'\" },\n\t{ 0x36, \"name='APPID'\" },\n\t{ 0x37, \"name='APROTOCOL'\" },\n\t{ 0x38, \"name='PROVIDER-ID'\" },\n\t{ 0x39, \"name='TO-PROXY'\" },\n\t{ 0x3A, \"name='URI'\" },\n\t{ 0x3B, \"name='RULE'\" },\n\t/* 0x3C -- 0x3F */\n\t/* 0x40 -- 0x44 GLOBAL */\n\t/* 0x45 -- 0x4F */\n\t{ 0x50, \"type=\" },\n\t/* 0x51 -- 0x52 */\n\t{ 0x53, \"type='PORT'\" },\n\t/* 0x54 */\n\t{ 0x55, \"type='APPLICATION'\" },\n\t{ 0x56, \"type='APPADDR'\" },\n\t{ 0x57, \"type='APPAUTH'\" },\n\t{ 0x58, \"type='CLIENTIDENTITY'\" },\n\t{ 0x59, \"type='RESOURCE'\" },\n\t/* 0x5A -- 0x7F */\n\n\t{ 0x00, NULL }\n};\n\n/*****    Attribute Start tokens   *****/\nstatic const value_string wbxml_provc10_attrValue_cp0[] = {\n\t/* 0x80 -- 0x84 GLOBAL */\n\t{ 0x85, \"'IPV4'\" },\n\t{ 0x86, \"'IPV6'\" },\n\t{ 0x87, \"'E164'\" },\n\t{ 0x88, \"'ALPHA'\" },\n\t{ 0x89, \"'APN'\" },\n\t{ 0x8A, \"'SCODE'\" },\n\t{ 0x8B, \"'TETRA-ITSI'\" },\n\t{ 0x8C, \"'MAN'\" },\n\t/* 0x8D -- 0x8F */\n\t{ 0x90, \"'ANALOG-MODEM'\" },\n\t{ 0x91, \"'V.120'\" },\n\t{ 0x92, \"'V.110'\" },\n\t{ 0x93, \"'X.31'\" },\n\t{ 0x94, \"'BIT-TRANSPARENT'\" },\n\t{ 0x95, \"'DIRECT-ASYNCHRONOUS-DATA-SERVICE'\" },\n\t/* 0x96 -- 0x99 */\n\t{ 0x9A, \"'PAP'\" },\n\t{ 0x9B, \"'CHAP'\" },\n\t{ 0x9C, \"'HTTP-BASIC'\" },\n\t{ 0x9D, \"'HTTP-DIGEST'\" },\n\t{ 0x9E, \"'WTLS-SS'\" },\n\t{ 0x9F, \"'MD5'\" },\n\t/* 0xA0 -- 0xA1 */\n\t{ 0xA2, \"'GSM-USSD'\" },\n\t{ 0xA3, \"'GSM-SMS'\" },\n\t{ 0xA4, \"'ANSI-136-GUTS'\" },\n\t{ 0xA5, \"'IS-95-CDMA-SMS'\" },\n\t{ 0xA6, \"'IS-95-CDMA-CSD'\" },\n\t{ 0xA7, \"'IS-95-CDMA-PACKET'\" },\n\t{ 0xA8, \"'ANSI-136-CSD'\" },\n\t{ 0xA9, \"'ANSI-136-GPRS'\" },\n\t{ 0xAA, \"'GSM-CSD'\" },\n\t{ 0xAB, \"'GSM-GPRS'\" },\n\t{ 0xAC, \"'AMPS-CDPD'\" },\n\t{ 0xAD, \"'PDC-CSD'\" },\n\t{ 0xAE, \"'PDC-PACKET'\" },\n\t{ 0xAF, \"'IDEN-SMS'\" },\n\t{ 0xB0, \"'IDEN-CSD'\" },\n\t{ 0xB1, \"'IDEN-PACKET'\" },\n\t{ 0xB2, \"'FLEX/REFLEX'\" },\n\t{ 0xB3, \"'PHS-SMS'\" },\n\t{ 0xB4, \"'PHS-CSD'\" },\n\t{ 0xB5, \"'TETRA-SDS'\" },\n\t{ 0xB6, \"'TETRA-PACKET'\" },\n\t{ 0xB7, \"'ANSI-136-GHOST'\" },\n\t{ 0xB8, \"'MOBITEX-MPAK'\" },\n\t{ 0xB9, \"'CDMA2000-IX-SIMPLE-IP'\" },\n\t{ 0xBA, \"'CDMA2000-IX-MOBILE-IP'\" },\n\t/* 0xBB -- 0xBF */\n\t/* 0xC0 -- 0xC4 GLOBAL */\n\t{ 0xC5, \"'AUTOBAUDING'\" },\n\t/* 0xC6 -- 0xC9 */\n\t{ 0xCA, \"'CL-WSP'\" },\n\t{ 0xCB, \"'CO-WSP'\" },\n\t{ 0xCC, \"'CL-SEC-WSP'\" },\n\t{ 0xCD, \"'CO-SEC-WSP'\" },\n\t{ 0xCE, \"'CL-SEC-WTA'\" },\n\t{ 0xCF, \"'CO-SEC-WTA'\" },\n\t{ 0xD0, \"'OTA-HTTP-TO'\" },\n\t{ 0xD1, \"'OTA-HTTP-TLS-TO'\" },\n\t{ 0xD2, \"'OTA-HTTP-PO'\" },\n\t{ 0xD3, \"'OTA-HTTP-TLS-PO'\" },\n\t/* 0xD4 -- 0xFF */\n\n\t{ 0x00, NULL }\n};\nstatic const value_string wbxml_provc10_attrValue_cp1[] = {\n\t/* 0x80 -- 0x84 GLOBAL */\n\t/* 0x85 */\n\t{ 0x86, \"'IPV6'\" },\n\t{ 0x87, \"'E164'\" },\n\t{ 0x88, \"'ALPHA'\" },\n\t{ 0x8D, \"'APPSRV'\" },\n\t{ 0x8E, \"'OBEX'\" },\n\t/* 0x8F */\n\n\t/* XXX - Errors that require a fix in the OMA/WAP Client Provisioning specs:\n\t   { 0xXXX, \"','\" },\n\t   { 0xXXX, \"'HTTP-'\" },\n\t   { 0xXXX, \"'BASIC'\" },\n\t   { 0xXXX, \"'DIGEST'\" },\n\t*/\n\n\t{ 0xE0, \"'AAA'\" },\n\t{ 0xE1, \"'HA'\" },\n\n\t{ 0x00, NULL }\n};\n\n/***** Token code page aggregation *****/\nstatic const value_valuestring wbxml_provc10_tags[] = {\n\t{ 0, wbxml_provc10_tags_cp0 },\n\t{ 1, wbxml_provc10_tags_cp1 },\n\t{ 0, NULL }\n};\n\nstatic const value_valuestring wbxml_provc10_attrStart[] = {\n\t{ 0, wbxml_provc10_attrStart_cp0 },\n\t{ 1, wbxml_provc10_attrStart_cp1 },\n\t{ 0, NULL }\n};\n\nstatic const value_valuestring wbxml_provc10_attrValue[] = {\n\t{ 0, wbxml_provc10_attrValue_cp0 },\n\t{ 1, wbxml_provc10_attrValue_cp1 },\n\t{ 0, NULL }\n};\n\nstatic const wbxml_decoding decode_provc_10 = {\n\t\"WAP Client Provisioning Document 1.0\",\n\t\"WAP ProvisioningDoc 1.0\",\n\t{ NULL, NULL, NULL },\n\tdefault_opaque_binary_tag,\n\tdefault_opaque_literal_tag,\n\tdefault_opaque_binary_attr,\n\tdefault_opaque_literal_attr,\n\tNULL,\n\twbxml_provc10_tags,\n\twbxml_provc10_attrStart,\n\twbxml_provc10_attrValue\n};\n\n\n\n\n\n/* EMN 1.0\n *\n * Email Notification\n ***************************************/\n\n/*****   Global extension tokens   *****/\n\n/*****         Tag tokens          *****/\nstatic const value_string wbxml_emnc10_tags_cp0[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"emn\" },\n\n\t{ 0x00, NULL }\n};\n\n/*****    Attribute Start tokens   *****/\nstatic const value_string wbxml_emnc10_attrStart_cp0[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"timestamp=\" },\n\t{ 0x06, \"mailbox=\" },\n\t{ 0x07, \"mailbox='mailat:'\" },\n\t{ 0x08, \"mailbox='pop://'\" },\n\t{ 0x09, \"mailbox='imap://'\" },\n\t{ 0x0a, \"mailbox='http://'\" },\n\t{ 0x0b, \"mailbox='http://www.'\" },\n\t{ 0x0c, \"mailbox='https://'\" },\n\t{ 0x0D, \"mailbox='https://www.'\" },\n\n\t{ 0x00, NULL }\n};\n\n/*****    Attribute Value tokens   *****/\n/* Same as in SI 1.0 */\n\n/***** Token code page aggregation *****/\nstatic const value_valuestring wbxml_emnc10_tags[] = {\n\t{ 0, wbxml_emnc10_tags_cp0 },\n\t{ 0, NULL }\n};\n\nstatic const value_valuestring wbxml_emnc10_attrStart[] = {\n\t{ 0, wbxml_emnc10_attrStart_cp0 },\n\t{ 0, NULL }\n};\n\nstatic const value_valuestring wbxml_emnc10_attrValue[] = {\n\t{ 0, wbxml_sic10_attrValue_cp0 }, /* Same as SI 1.0 */\n\t{ 0, NULL }\n};\n\nstatic const wbxml_decoding decode_emnc_10 = {\n\t\"E-Mail Notification 1.0\",\n\t\"EMN 1.0\",\n\t{ NULL, NULL, NULL },\n\tdefault_opaque_binary_tag,\n\tdefault_opaque_literal_tag,\n\temnc10_opaque_binary_attr,\n\temnc10_opaque_literal_attr,\n\tNULL,\n\twbxml_emnc10_tags,\n\twbxml_emnc10_attrStart,\n\twbxml_emnc10_attrValue\n};\n\n\n\n\n\n/* SyncML 1.0\n *\n * SyncML Representation Protocol\n ***************************************/\n\n/*****   Global extension tokens   *****/\n\n/*****         Tag tokens          *****/\nstatic const value_string wbxml_syncmlc10_tags_cp0[] = { /* SyncML 1.0 */\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"Add\" },\n\t{ 0x06, \"Alert\" },\n\t{ 0x07, \"Archive\" },\n\t{ 0x08, \"Atomic\" },\n\t{ 0x09, \"Chal\" },\n\t{ 0x0A, \"Cmd\" },\n\t{ 0x0B, \"CmdID\" },\n\t{ 0x0C, \"CmdRef\" },\n\t{ 0x0D, \"Copy\" },\n\t{ 0x0E, \"Cred\" },\n\t{ 0x0F, \"Data\" },\n\t{ 0x10, \"Delete\" },\n\t{ 0x11, \"Exec\" },\n\t{ 0x12, \"Final\" },\n\t{ 0x13, \"Get\" },\n\t{ 0x14, \"Item\" },\n\t{ 0x15, \"Lang\" },\n\t{ 0x16, \"LocName\" },\n\t{ 0x17, \"LocURI\" },\n\t{ 0x18, \"Map\" },\n\t{ 0x19, \"MapItem\" },\n\t{ 0x1A, \"Meta\" },\n\t{ 0x1B, \"MsgID\" },\n\t{ 0x1C, \"MsgRef\" },\n\t{ 0x1D, \"NoResp\" },\n\t{ 0x1E, \"NoResults\" },\n\t{ 0x1F, \"Put\" },\n\t{ 0x20, \"Replace\" },\n\t{ 0x21, \"RespURI\" },\n\t{ 0x22, \"Results\" },\n\t{ 0x23, \"Search\" },\n\t{ 0x24, \"Sequence\" },\n\t{ 0x25, \"SessionID\" },\n\t{ 0x26, \"SftDel\" },\n\t{ 0x27, \"Source\" },\n\t{ 0x28, \"SourceRef\" },\n\t{ 0x29, \"Status\" },\n\t{ 0x2A, \"Sync\" },\n\t{ 0x2B, \"SyncBody\" },\n\t{ 0x2C, \"SyncHdr\" },\n\t{ 0x2D, \"SyncML\" },\n\t{ 0x2E, \"Target\" },\n\t{ 0x2F, \"TargetRef\" },\n\t/* 0x30 - Reserved */\n\t{ 0x31, \"VerDTD\" },\n\t{ 0x32, \"VerProto\" },\n\n\t{ 0x00, NULL }\n};\n\nstatic const value_string wbxml_syncmlc10_tags_cp1[] = { /* MetInf 1.0 */\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"Anchor\" },\n\t{ 0x06, \"EMI\" },\n\t{ 0x07, \"Format\" },\n\t{ 0x08, \"FreeID\" },\n\t{ 0x09, \"FreeMem\" },\n\t{ 0x0A, \"Last\" },\n\t{ 0x0B, \"Mark\" },\n\t{ 0x0C, \"MaxMsgSize\" },\n\t{ 0x0D, \"Mem\" },\n\t{ 0x0E, \"MetInf\" },\n\t{ 0x0F, \"Next\" },\n\t{ 0x10, \"NextNonce\" },\n\t{ 0x11, \"SharedMem\" },\n\t{ 0x12, \"Size\" },\n\t{ 0x13, \"Type\" },\n\t{ 0x14, \"Version\" },\n\n\t{ 0x00, NULL }\n};\n\n/*****    Attribute Start tokens   *****/\n\n/*****    Attribute Value tokens   *****/\n\n/***** Token code page aggregation *****/\nstatic const value_valuestring wbxml_syncmlc10_tags[] = {\n\t{ 0, wbxml_syncmlc10_tags_cp0 }, /* -//SYNCML//DTD SyncML 1.0//EN */\n\t{ 1, wbxml_syncmlc10_tags_cp1 }, /* -//SYNCML//DTD MetInf 1.0//EN */\n\t{ 0, NULL }\n};\n\nstatic const wbxml_decoding decode_syncmlc_10 = {\n\t\"SyncML Representation Protocol 1.0\",\n\t\"SyncML 1.0\",\n\t{ NULL, NULL, NULL },\n\tdefault_opaque_binary_tag,\n\tdefault_opaque_literal_tag,\n\tdefault_opaque_binary_attr,\n\tdefault_opaque_literal_attr,\n\tNULL,\n\twbxml_syncmlc10_tags,\n\tNULL,\n\tNULL\n};\n\n\n\n\n\n/* SyncML 1.1\n *\n * SyncML Representation Protocol\n ***************************************/\n\n/*****   Global extension tokens   *****/\n\n/*****         Tag tokens          *****/\nstatic const value_string wbxml_syncmlc11_tags_cp0[] = { /* SyncML 1.1 */\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"Add\" },\n\t{ 0x06, \"Alert\" },\n\t{ 0x07, \"Archive\" },\n\t{ 0x08, \"Atomic\" },\n\t{ 0x09, \"Chal\" },\n\t{ 0x0a, \"Cmd\" },\n\t{ 0x0b, \"CmdID\" },\n\t{ 0x0c, \"CmdRef\" },\n\t{ 0x0d, \"Copy\" },\n\t{ 0x0e, \"Cred\" },\n\t{ 0x0f, \"Data\" },\n\t{ 0x10, \"Delete\" },\n\t{ 0x11, \"Exec\" },\n\t{ 0x12, \"Final\" },\n\t{ 0x13, \"Get\" },\n\t{ 0x14, \"Item\" },\n\t{ 0x15, \"Lang\" },\n\t{ 0x16, \"LocName\" },\n\t{ 0x17, \"LocURI\" },\n\t{ 0x18, \"Map\" },\n\t{ 0x19, \"MapItem\" },\n\t{ 0x1a, \"Meta\" },\n\t{ 0x1b, \"MsgID\" },\n\t{ 0x1c, \"MsgRef\" },\n\t{ 0x1d, \"NoResp\" },\n\t{ 0x1e, \"NoResults\" },\n\t{ 0x1f, \"Put\" },\n\t{ 0x20, \"Replace\" },\n\t{ 0x21, \"RespURI\" },\n\t{ 0x22, \"Results\" },\n\t{ 0x23, \"Search\" },\n\t{ 0x24, \"Sequence\" },\n\t{ 0x25, \"SessionID\" },\n\t{ 0x26, \"SftDel\" },\n\t{ 0x27, \"Source\" },\n\t{ 0x28, \"SourceRef\" },\n\t{ 0x29, \"Status\" },\n\t{ 0x2a, \"Sync\" },\n\t{ 0x2b, \"SyncBody\" },\n\t{ 0x2c, \"SyncHdr\" },\n\t{ 0x2d, \"SyncML\" },\n\t{ 0x2e, \"Target\" },\n\t{ 0x2f, \"TargetRef\" },\n\t/* 0x30 - Reserved */\n\t{ 0x31, \"VerDTD\" },\n\t{ 0x32, \"VerProto\" },\n\t{ 0x33, \"NumberOfChanges\" },\n\t{ 0x34, \"MoreData\" },\n\n\t{ 0x00, NULL }\n};\n\nstatic const value_string wbxml_syncmlc11_tags_cp1[] = { /* MetInf 1.1 */\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"Anchor\" },\n\t{ 0x06, \"EMI\" },\n\t{ 0x07, \"Format\" },\n\t{ 0x08, \"FreeID\" },\n\t{ 0x09, \"FreeMem\" },\n\t{ 0x0A, \"Last\" },\n\t{ 0x0B, \"Mark\" },\n\t{ 0x0C, \"MaxMsgSize\" },\n\t{ 0x0D, \"Mem\" },\n\t{ 0x0E, \"MetInf\" },\n\t{ 0x0F, \"Next\" },\n\t{ 0x10, \"NextNonce\" },\n\t{ 0x11, \"SharedMem\" },\n\t{ 0x12, \"Size\" },\n\t{ 0x13, \"Type\" },\n\t{ 0x14, \"Version\" },\n\t{ 0x15, \"MaxObjSize\" },\n\n\t{ 0x00, NULL }\n};\n\n/*****    Attribute Start tokens   *****/\n\n/*****    Attribute Value tokens   *****/\n\n/***** Token code page aggregation *****/\nstatic const value_valuestring wbxml_syncmlc11_tags[] = {\n\t{ 0, wbxml_syncmlc11_tags_cp0 }, /* -//SYNCML//DTD SyncML 1.1//EN */\n\t{ 1, wbxml_syncmlc11_tags_cp1 }, /* -//SYNCML//DTD MetInf 1.1//EN */\n\t{ 0, NULL }\n};\n\nstatic const wbxml_decoding decode_syncmlc_11 = {\n\t\"SyncML Representation Protocol 1.1\",\n\t\"SyncML 1.1\",\n\t{ NULL, NULL, NULL },\n\tdefault_opaque_binary_tag,\n\tdefault_opaque_literal_tag,\n\tdefault_opaque_binary_attr,\n\tdefault_opaque_literal_attr,\n\tNULL,\n\twbxml_syncmlc11_tags,\n\tNULL,\n\tNULL\n};\n\n\n\n\n\n/* SyncML 1.2\n *\n * SyncML Representation Protocol\n ***************************************/\n\n/*****   Global extension tokens   *****/\n\n/*****         Tag tokens          *****/\nstatic const value_string wbxml_syncmlc12_tags_cp0[] = { /* SyncML 1.2 */\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"Add\" },\n\t{ 0x06, \"Alert\" },\n\t{ 0x07, \"Archive\" },\n\t{ 0x08, \"Atomic\" },\n\t{ 0x09, \"Chal\" },\n\t{ 0x0a, \"Cmd\" },\n\t{ 0x0b, \"CmdID\" },\n\t{ 0x0c, \"CmdRef\" },\n\t{ 0x0d, \"Copy\" },\n\t{ 0x0e, \"Cred\" },\n\t{ 0x0f, \"Data\" },\n\t{ 0x10, \"Delete\" },\n\t{ 0x11, \"Exec\" },\n\t{ 0x12, \"Final\" },\n\t{ 0x13, \"Get\" },\n\t{ 0x14, \"Item\" },\n\t{ 0x15, \"Lang\" },\n\t{ 0x16, \"LocName\" },\n\t{ 0x17, \"LocURI\" },\n\t{ 0x18, \"Map\" },\n\t{ 0x19, \"MapItem\" },\n\t{ 0x1a, \"Meta\" },\n\t{ 0x1b, \"MsgID\" },\n\t{ 0x1c, \"MsgRef\" },\n\t{ 0x1d, \"NoResp\" },\n\t{ 0x1e, \"NoResults\" },\n\t{ 0x1f, \"Put\" },\n\t{ 0x20, \"Replace\" },\n\t{ 0x21, \"RespURI\" },\n\t{ 0x22, \"Results\" },\n\t{ 0x23, \"Search\" },\n\t{ 0x24, \"Sequence\" },\n\t{ 0x25, \"SessionID\" },\n\t{ 0x26, \"SftDel\" },\n\t{ 0x27, \"Source\" },\n\t{ 0x28, \"SourceRef\" },\n\t{ 0x29, \"Status\" },\n\t{ 0x2a, \"Sync\" },\n\t{ 0x2b, \"SyncBody\" },\n\t{ 0x2c, \"SyncHdr\" },\n\t{ 0x2d, \"SyncML\" },\n\t{ 0x2e, \"Target\" },\n\t{ 0x2f, \"TargetRef\" },\n\t/* 0x30 - Reserved */\n\t{ 0x31, \"VerDTD\" },\n\t{ 0x32, \"VerProto\" },\n\t{ 0x33, \"NumberOfChanges\" },\n\t{ 0x34, \"MoreData\" },\n\t{ 0x35, \"Field\" },\n\t{ 0x36, \"Filter\" },\n\t{ 0x37, \"Record\" },\n\t{ 0x38, \"FilterType\" },\n\t{ 0x39, \"SourceParent\" },\n\t{ 0x3a, \"TargetParent\" },\n\t{ 0x3b, \"Move\" },\n\t{ 0x3c, \"Correlator\" },\n\n\t{ 0x00, NULL }\n};\n\nstatic const value_string wbxml_syncmlc12_tags_cp1[] = { /* MetInf 1.2 */\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"Anchor\" },\n\t{ 0x06, \"EMI\" },\n\t{ 0x07, \"Format\" },\n\t{ 0x08, \"FreeID\" },\n\t{ 0x09, \"FreeMem\" },\n\t{ 0x0A, \"Last\" },\n\t{ 0x0B, \"Mark\" },\n\t{ 0x0C, \"MaxMsgSize\" },\n\t{ 0x0D, \"Mem\" },\n\t{ 0x0E, \"MetInf\" },\n\t{ 0x0F, \"Next\" },\n\t{ 0x10, \"NextNonce\" },\n\t{ 0x11, \"SharedMem\" },\n\t{ 0x12, \"Size\" },\n\t{ 0x13, \"Type\" },\n\t{ 0x14, \"Version\" },\n\t{ 0x15, \"MaxObjSize\" },\n\t{ 0x16, \"FieldLevel\" },\n\t{ 0x17, \"FP\" }, /* Extensions on certain devices */\n\t{ 0x18, \"ID\" }, /* Extensions on certain devices */\n\t{ 0x19, \"IDContainer\" }, /* Extensions on certain devices */\n\t{ 0x1a, \"IDPair\" }, /* Extensions on certain devices */\n\n\t{ 0x00, NULL }\n};\n\n/*****    Attribute Start tokens   *****/\n\n/*****    Attribute Value tokens   *****/\n\n/***** Token code page aggregation *****/\nstatic const value_valuestring wbxml_syncmlc12_tags[] = {\n\t{ 0, wbxml_syncmlc12_tags_cp0 }, /* -//SYNCML//DTD SyncML 1.2//EN */\n\t{ 1, wbxml_syncmlc12_tags_cp1 }, /* -//SYNCML//DTD MetInf 1.2//EN */\n\t/* Note: 02 reserved for DM use */\n\t{ 0, NULL }\n};\n\nstatic const wbxml_decoding decode_syncmlc_12 = {\n\t\"SyncML Representation Protocol 1.2\",\n\t\"SyncML 1.2\",\n\t{ NULL, NULL, NULL },\n\tdefault_opaque_binary_tag,\n\tdefault_opaque_literal_tag,\n\tdefault_opaque_binary_attr,\n\tdefault_opaque_literal_attr,\n\tNULL,\n\twbxml_syncmlc12_tags,\n\tNULL,\n\tNULL\n};\n/* Microsoft ActiveSync 1.0 (Actual Version Unknown - either 1.0 or 2.0, taken from [MS-ASWBXML].pdf)\n *\n * ActiveSync Representation Protocol\n ***************************************/\n\n/*****   Global extension tokens   *****/\n\n/*****         Tag tokens          *****/\nstatic const value_string wbxml_mssyncc10_tags_cp0[] = { /* ActiveSync 'AirSync:' Page */\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"Sync\" },\n\t{ 0x06, \"Responses\" },\n\t{ 0x07, \"Add\" },\n\t{ 0x08, \"Change\" },\n\t{ 0x09, \"Delete\" },\n\t{ 0x0A, \"Fetch\" },\n\t{ 0x0B, \"SyncKey\" },\n\t{ 0x0C, \"ClientId\" },\n\t{ 0x0D, \"ServerId\" },\n\t{ 0x0E, \"Status\" },\n\t{ 0x0F, \"Collection\" },\n\t{ 0x10, \"Class\" },\n\t{ 0x12, \"CollectionId\" },\n\t{ 0x13, \"GetChanges\" },\n\t{ 0x14, \"MoreAvailable\" },\n\t{ 0x15, \"WindowSize\" },\n\t{ 0x16, \"Commands\" },\n\t{ 0x17, \"Options\" },\n\t{ 0x18, \"FilterType\" },\n\t{ 0x1B, \"Conflict\" },\n\t{ 0x1C, \"Collections\" },\n\t{ 0x1D, \"ApplicationData\" },\n\t{ 0x1E, \"DeletesAsMoves\" },\n\t{ 0x20, \"Supported\" },\n\t{ 0x21, \"SoftDelete\" },\n\t{ 0x22, \"MIMESupport\" },\n\t{ 0x23, \"MIMETruncation\" },\n\t{ 0x24, \"Wait\" },\n\t{ 0x25, \"Limit\" },\n\t{ 0x26, \"Partial\" },\n\t{ 0x27, \"ConversationMode\" },\n\t{ 0x28, \"MaxItems\" },\n\t{ 0x29, \"HeartbeatInterval\" },\n\n\t{ 0x00, NULL }\n};\n\nstatic const value_string wbxml_mssyncc10_tags_cp1[] = { /* ActiveSync 'Contacts:' Page */\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"Anniversary\" },\n\t{ 0x06, \"AssistantName\" },\n\t{ 0x07, \"AssistantTelephoneNumber\" },\n\t{ 0x08, \"Birthday\" },\n\t{ 0x0C, \"Business2PhoneNumber\" },\n\t{ 0x0D, \"BusinessCity\" },\n\t{ 0x0E, \"BusinessCountry\" },\n\t{ 0x0F, \"BusinessPostalCode\" },\n\t{ 0x10, \"BusinessState\" },\n\t{ 0x11, \"BusinessStreet\" },\n\t{ 0x12, \"BusinessFaxNumber\" },\n\t{ 0x13, \"BusinessPhoneNumber\" },\n\t{ 0x14, \"CarPhoneNumber\" },\n\t{ 0x15, \"Categories\" },\n\t{ 0x16, \"Category\" },\n\t{ 0x17, \"Children\" },\n\t{ 0x18, \"Child\" },\n\t{ 0x19, \"CompanyName\" },\n\t{ 0x1A, \"Department\" },\n\t{ 0x1B, \"Email1Address\" },\n\t{ 0x1C, \"Email2Address\" },\n\t{ 0x1D, \"Email3Address\" },\n\t{ 0x1E, \"FileAs\" },\n\t{ 0x1F, \"FirstName\" },\n\t{ 0x20, \"Home2PhoneNumber\" },\n\t{ 0x21, \"HomeCity\" },\n\t{ 0x22, \"HomeCountry\" },\n\t{ 0x23, \"HomePostalCode\" },\n\t{ 0x24, \"HomeState\" },\n\t{ 0x25, \"HomeStreet\" },\n\t{ 0x26, \"HomeFaxNumber\" },\n\t{ 0x27, \"HomePhoneNumber\" },\n\t{ 0x29, \"JobTitle\" },\n\t{ 0x2A, \"MiddleName\" },\n\t{ 0x2B, \"MobilePhoneNumber\" },\n\t{ 0x2C, \"OfficeLocation\" },\n\t{ 0x2D, \"OtherCity\" },\n\t{ 0x2E, \"OtherCountry\" },\n\t{ 0x2F, \"OtherPostalCode\" },\n\t{ 0x30, \"OtherState\" },\n\t{ 0x31, \"OtherStreet\" },\n\t{ 0x32, \"PagerNumber\" },\n\t{ 0x33, \"RadioPhoneNumber\" },\n\t{ 0x34, \"Spouse\" },\n\t{ 0x35, \"Suffix\" },\n\t{ 0x36, \"Title\" },\n\t{ 0x37, \"Webpage\" },\n\t{ 0x38, \"YomiCompanyName\" },\n\t{ 0x39, \"YomiFirstName\" },\n\t{ 0x3A, \"YomiLastName\" },\n\t{ 0x3C, \"Picture\" },\n\t{ 0x3D, \"Alias\" },\n\t{ 0x3E, \"WeightedRank\" },\n\n\t{ 0x00, NULL }\n};\n\nstatic const value_string wbxml_mssyncc10_tags_cp2[] = { /* ActiveSync 'Email:' Page */\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x0F, \"DateReceived\" },\n\t{ 0x11, \"DisplayTo\" },\n\t{ 0x12, \"Importance\" },\n\t{ 0x13, \"MessageClass\" },\n\t{ 0x14, \"Subject\" },\n\t{ 0x15, \"Read\" },\n\t{ 0x16, \"To\" },\n\t{ 0x17, \"CC\" },\n\t{ 0x18, \"From\" },\n\t{ 0x19, \"ReplyTo\" },\n\t{ 0x1A, \"AllDayEvent\" },\n\t{ 0x1B, \"Categories\" },\n\t{ 0x1C, \"Category\" },\n\t{ 0x1D, \"DTStamp\" },\n\t{ 0x1E, \"EndTime\" },\n\t{ 0x1F, \"InstanceType\" },\n\t{ 0x20, \"BusyStatus\" },\n\t{ 0x21, \"Location\" },\n\t{ 0x22, \"MeetingRequest\" },\n\t{ 0x23, \"Organizer\" },\n\t{ 0x24, \"RecurrenceId\" },\n\t{ 0x25, \"Reminder\" },\n\t{ 0x26, \"ResponseRequest\" },\n\t{ 0x27, \"Recurrences\" },\n\t{ 0x28, \"Recurrence\" },\n\t{ 0x29, \"Recurrence_Type\" },\n\t{ 0x2A, \"Recurrence_Until\" },\n\t{ 0x2B, \"Recurrence_Occurrences\" },\n\t{ 0x2C, \"Recurrence_Interval\" },\n\t{ 0x2D, \"Recurrence_DayOfWeek\" },\n\t{ 0x2E, \"Recurrence_DayOfMonth\" },\n\t{ 0x2F, \"Recurrence_WeekOfMonth\" },\n\t{ 0x30, \"Recurrence_MonthOfYear\" },\n\t{ 0x31, \"StartTime\" },\n\t{ 0x32, \"Sensitivity\" },\n\t{ 0x33, \"TimeZone\" },\n\t{ 0x34, \"GlobalObjId\" },\n\t{ 0x35, \"ThreadTopic\" },\n\t{ 0x39, \"InternetCPID\" },\n\t{ 0x3A, \"Flag\" },\n\t{ 0x3B, \"FlagStatus\" },\n\t{ 0x3C, \"ContentClass\" },\n\t{ 0x3D, \"FlagType\" },\n\t{ 0x3E, \"CompleteTime\" },\n\t{ 0x3F, \"DisallowNewTimeProposal\" },\n\n\t{ 0x00, NULL }\n};\n\nstatic const value_string wbxml_mssyncc10_tags_cp4[] = { /* ActiveSync 'Calendar:' Page */\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"TimeZone\" },\n\t{ 0x06, \"AllDAyEvent\" },\n\t{ 0x07, \"Attendees\" },\n\t{ 0x08, \"Attendee\" },\n\t{ 0x09, \"Attendee_Email\" },\n\t{ 0x0A, \"Attendee_Name\" },\n\t{ 0x0D, \"BusyStatus\" },\n\t{ 0x0E, \"Categories\" },\n\t{ 0x0F, \"Category\" },\n\t{ 0x11, \"DTStamp\" },\n\t{ 0x12, \"EndTime\" },\n\t{ 0x13, \"Exception\" },\n\t{ 0x14, \"Exceptions\" },\n\t{ 0x15, \"Exception_Deleted\" },\n\t{ 0x16, \"Exception_StartTime\" },\n\t{ 0x17, \"Location\" },\n\t{ 0x18, \"MeetingStatus\" },\n\t{ 0x19, \"Organizer_Email\" },\n\t{ 0x1A, \"Organizer_Name\" },\n\t{ 0x1B, \"Recurrence\" },\n\t{ 0x1C, \"Recurrence_Type\" },\n\t{ 0x1D, \"Recurrence_Until\" },\n\t{ 0x1E, \"Recurrence_Occurrences\" },\n\t{ 0x1F, \"Recurrence_Interval\" },\n\t{ 0x20, \"Recurrence_DayOfWeek\" },\n\t{ 0x21, \"Recurrence_DayOfMonth\" },\n\t{ 0x22, \"Recurrence_WeekOfMonth\" },\n\t{ 0x23, \"Recurrence_MonthOfYear\" },\n\t{ 0x24, \"Reminder\" },\n\t{ 0x25, \"Sensitivity\" },\n\t{ 0x26, \"Subject\" },\n\t{ 0x27, \"StartTime\" },\n\t{ 0x28, \"UID\" },\n\t{ 0x29, \"Attendee_Status\" },\n\t{ 0x2A, \"Attendee_Type\" },\n\t{ 0x33, \"DisallowNewTimeProposal\" },\n\t{ 0x34, \"ResponseRequested\" },\n\t{ 0x35, \"AppointmentReplyTime\" },\n\t{ 0x36, \"ResponseType\" },\n\t{ 0x37, \"CalendarType\" },\n\t{ 0x38, \"IsLeapMonth\" },\n\t{ 0x39, \"FirstDayOfWeek\" },\n\t{ 0x3A, \"OnlineMeetingConfLink\" },\n\t{ 0x3B, \"OnlineMeetingExternalLink\" },\n\n\t{ 0x00, NULL }\n};\n\nstatic const value_string wbxml_mssyncc10_tags_cp5[] = { /* ActiveSync 'Move:' Page */\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"MoveItems\" },\n\t{ 0x06, \"Move\" },\n\t{ 0x07, \"SrcMsgId\" },\n\t{ 0x08, \"SrcFldId\" },\n\t{ 0x09, \"DstFldId\" },\n\t{ 0x0A, \"Response\" },\n\t{ 0x0B, \"Status\" },\n\t{ 0x0C, \"DstMsgId\" },\n\n\t{ 0x00, NULL }\n};\n\nstatic const value_string wbxml_mssyncc10_tags_cp6[] = { /* ActiveSync 'GetItemEstimate:' Page */\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"GetItemEstimate\" },\n\t{ 0x06, \"Version\" },\n\t{ 0x07, \"Collections\" },\n\t{ 0x08, \"Collection\" },\n\t{ 0x09, \"Class\" },\n\t{ 0x0A, \"CollectionId\" },\n\t{ 0x0B, \"DateTime\" },\n\t{ 0x0C, \"Estimate\" },\n\t{ 0x0D, \"Response\" },\n\t{ 0x0E, \"Status\" },\n\n\t{ 0x00, NULL }\n};\n\nstatic const value_string wbxml_mssyncc10_tags_cp7[] = { /* ActiveSync 'FolderHierarchy:' Page */\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x07, \"DisplayName\" },\n\t{ 0x08, \"ServerId\" },\n\t{ 0x09, \"ParentId\" },\n\t{ 0x0A, \"Type\" },\n\t{ 0x0C, \"Status\" },\n\t{ 0x0E, \"Changes\" },\n\t{ 0x0F, \"Add\" },\n\t{ 0x10, \"Delete\" },\n\t{ 0x11, \"Update\" },\n\t{ 0x12, \"SyncKey\" },\n\t{ 0x13, \"FolderCreate\" },\n\t{ 0x14, \"FolderDelete\" },\n\t{ 0x15, \"FolderUpdate\" },\n\t{ 0x16, \"FolderSync\" },\n\t{ 0x17, \"Count\" },\n\n\t{ 0x00, NULL }\n};\n\nstatic const value_string wbxml_mssyncc10_tags_cp8[] = { /* ActiveSync 'MeetingResponse:' Page */\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"CalendarId\" },\n\t{ 0x06, \"CollectionId\" },\n\t{ 0x07, \"MeetingResponse\" },\n\t{ 0x08, \"RequestId\" },\n\t{ 0x09, \"Request\" },\n\t{ 0x0A, \"Result\" },\n\t{ 0x0B, \"Status\" },\n\t{ 0x0C, \"UserResponse\" },\n\t{ 0x0E, \"InstanceId\" },\n\n\t{ 0x00, NULL }\n};\n\nstatic const value_string wbxml_mssyncc10_tags_cp9[] = { /* ActiveSync 'Tasks:' Page */\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x08, \"Categories\" },\n\t{ 0x09, \"Category\" },\n\t{ 0x0A, \"Complete\" },\n\t{ 0x0B, \"DateCompleted\" },\n\t{ 0x0D, \"DueDate\" },\n\t{ 0x0E, \"Importance\" },\n\t{ 0x0F, \"Recurrence\" },\n\t{ 0x10, \"Recurrence_Type\" },\n\t{ 0x11, \"Recurrence_Start\" },\n\t{ 0x12, \"Recurrence_Until\" },\n\t{ 0x13, \"Recurrence_Occurrences\" },\n\t{ 0x14, \"Recurrence_Interval\" },\n\t{ 0x15, \"Recurrence_DayOfMonth\" },\n\t{ 0x16, \"Recurrence_DayOfWeek\" },\n\t{ 0x17, \"Recurrence_WeekOfMonth\" },\n\t{ 0x18, \"Recurrence_MonthOfYear\" },\n\t{ 0x19, \"Recurrence_Regenerate\" },\n\t{ 0x1A, \"Recurrence_DeadOccur\" },\n\t{ 0x1B, \"ReminderSet\" },\n\t{ 0x1C, \"ReminderTime\" },\n\t{ 0x1D, \"Sensitivity\" },\n\t{ 0x1E, \"StartDate\" },\n\t{ 0x1F, \"UTCStartDate\" },\n\t{ 0x20, \"Subject\" },\n\t{ 0x22, \"OrdinalDate\" },\n\t{ 0x23, \"SubOrdinalDate\" },\n\t{ 0x24, \"CalendarType\" },\n\t{ 0x25, \"IsLeapMonth\" },\n\t{ 0x26, \"FirstDayOfWeek\" },\n\n\t{ 0x00, NULL }\n};\n\nstatic const value_string wbxml_mssyncc10_tags_cp10[] = { /* ActiveSync 'ResolveRecipients:' Page */\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"ResolveRecipients\" },\n\t{ 0x06, \"Response\" },\n\t{ 0x07, \"Status\" },\n\t{ 0x08, \"Type\" },\n\t{ 0x09, \"Recipient\" },\n\t{ 0x0A, \"DisplayName\" },\n\t{ 0x0B, \"EmailAddress\" },\n\t{ 0x0C, \"Certificates\" },\n\t{ 0x0D, \"Certificate\" },\n\t{ 0x0E, \"MiniCertificate\" },\n\t{ 0x0F, \"Options\" },\n\t{ 0x10, \"To\" },\n\t{ 0x11, \"CertificateRetrieval\" },\n\t{ 0x12, \"RecipientCount\" },\n\t{ 0x13, \"MaxCertificates\" },\n\t{ 0x14, \"MaxAmbiguousRecipients\" },\n\t{ 0x15, \"CertificateCount\" },\n\t{ 0x16, \"Availability\" },\n\t{ 0x17, \"StartTime\" },\n\t{ 0x18, \"EndTime\" },\n\t{ 0x19, \"MergedFreeBusy\" },\n\t{ 0x1A, \"Picture\" },\n\t{ 0x1B, \"MaxSize\" },\n\t{ 0x1C, \"Data\" },\n\t{ 0x1D, \"MaxPictures\" },\n\n\t{ 0x00, NULL }\n};\n\nstatic const value_string wbxml_mssyncc10_tags_cp11[] = { /* ActiveSync 'ValidateCert:' Page */\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"ValidateCert\" },\n\t{ 0x06, \"Certificates\" },\n\t{ 0x07, \"Certificate\" },\n\t{ 0x08, \"CertificateChain\" },\n\t{ 0x09, \"CheckCRL\" },\n\t{ 0x0A, \"Status\" },\n\n\t{ 0x00, NULL }\n};\n\nstatic const value_string wbxml_mssyncc10_tags_cp12[] = { /* ActiveSync 'Contacts2:' Page */\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"CustomerId\" },\n\t{ 0x06, \"GovernmentId\" },\n\t{ 0x07, \"IMAddress\" },\n\t{ 0x08, \"IMAddress2\" },\n\t{ 0x09, \"IMAddress3\" },\n\t{ 0x0A, \"ManagerName\" },\n\t{ 0x0B, \"CompanyMainPhone\" },\n\t{ 0x0C, \"AccountName\" },\n\t{ 0x0D, \"NickName\" },\n\t{ 0x0E, \"MMS\" },\n\n\t{ 0x00, NULL }\n};\n\nstatic const value_string wbxml_mssyncc10_tags_cp13[] = { /* ActiveSync 'Ping:' Page */\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"Ping\" },\n\t{ 0x06, \"AutdState\" },\n\t{ 0x07, \"Status\" },\n\t{ 0x08, \"HeartbeatInterval\" },\n\t{ 0x09, \"Folders\" },\n\t{ 0x0A, \"Folder\" },\n\t{ 0x0B, \"Id\" },\n\t{ 0x0C, \"Class\" },\n\t{ 0x0D, \"MaxFolders\" },\n\n\t{ 0x00, NULL }\n};\n\nstatic const value_string wbxml_mssyncc10_tags_cp14[] = { /* ActiveSync 'Provision:' Page */\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"Provision\" },\n\t{ 0x06, \"Policies\" },\n\t{ 0x07, \"Policy\" },\n\t{ 0x08, \"PolicyType\" },\n\t{ 0x09, \"PolicyKey\" },\n\t{ 0x0A, \"Data\" },\n\t{ 0x0B, \"Status\" },\n\t{ 0x0C, \"RemoteWipe\" },\n\t{ 0x0D, \"EASProvisionDoc\" },\n\t{ 0x0E, \"DevicePasswordEnabled\" },\n\t{ 0x0F, \"AlphanumericDevicePasswordRequired\" },\n\t{ 0x10, \"DeviceEncryptionEnabled\" },\n\t{ 0x11, \"PasswordRecoveryEnabled\" },\n\t{ 0x13, \"AttachmentsEnabled\" },\n\t{ 0x14, \"MinDevicePasswordLength\" },\n\t{ 0x15, \"MaxInactivityTimeDeviceLock\" },\n\t{ 0x16, \"MaxDevicePasswordFailedAttempts\" },\n\t{ 0x17, \"MaxAttachmentSize\" },\n\t{ 0x18, \"AllowSimpleDevicePassword\" },\n\t{ 0x19, \"DevicePasswordExpiration\" },\n\t{ 0x1A, \"DevicePasswordHistory\" },\n\t{ 0x1B, \"AllowStorageCard\" },\n\t{ 0x1C, \"AllowCamera\" },\n\t{ 0x1D, \"RequireDeviceEncryption\" },\n\t{ 0x1E, \"AllowUnsignedApplications\" },\n\t{ 0x1F, \"AllowUnsignedInstallationPackages\" },\n\t{ 0x20, \"MinDevicePasswordComplexCharacters\" },\n\t{ 0x21, \"AllowWiFi\" },\n\t{ 0x22, \"AllowTextMessaging\" },\n\t{ 0x23, \"AllowPOPIMAPEmail\" },\n\t{ 0x24, \"AllowBluetooth\" },\n\t{ 0x25, \"AllowIrDA\" },\n\t{ 0x26, \"RequireManualSyncWhenRoaming\" },\n\t{ 0x27, \"AllowDesktopSync\" },\n\t{ 0x28, \"MaxCalendarAgeFilter\" },\n\t{ 0x29, \"AllowHTMLEmail\" },\n\t{ 0x2A, \"MaxEmailAgeFilter\" },\n\t{ 0x2B, \"MaxEmailBodyTruncationSize\" },\n\t{ 0x2C, \"MaxEmailHTMLBodyTruncationSize\" },\n\t{ 0x2D, \"RequireSignedSMIMEMessages\" },\n\t{ 0x2E, \"RequireEncryptedSMIMEMessages\" },\n\t{ 0x2F, \"RequireSignedSMIMEAlgorithm\" },\n\t{ 0x30, \"RequireEncryptionSMIMEAlgorithm\" },\n\t{ 0x31, \"AllowSMIMEEncryptionAlgorithmNegotiation\" },\n\t{ 0x32, \"AllowSMIMESoftCerts\" },\n\t{ 0x33, \"AllowBrowser\" },\n\t{ 0x34, \"AllowConsumerEmail\" },\n\t{ 0x35, \"AllowRemoteDesktop\" },\n\t{ 0x36, \"AllowInternetSharing\" },\n\t{ 0x37, \"UnapprovedInROMApplicationList\" },\n\t{ 0x38, \"ApplicationName\" },\n\t{ 0x39, \"ApprovedApplicationList\" },\n\t{ 0x3A, \"Hash\" },\n\n\t{ 0x00, NULL }\n};\n\nstatic const value_string wbxml_mssyncc10_tags_cp15[] = { /* ActiveSync 'Search:' Page */\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"Search\" },\n\t{ 0x07, \"Store\" },\n\t{ 0x08, \"Name\" },\n\t{ 0x09, \"Query\" },\n\t{ 0x0A, \"Options\" },\n\t{ 0x0B, \"Range\" },\n\t{ 0x0C, \"Status\" },\n\t{ 0x0D, \"Response\" },\n\t{ 0x0E, \"Result\" },\n\t{ 0x0F, \"Properties\" },\n\t{ 0x10, \"Total\" },\n\t{ 0x11, \"EqualTo\" },\n\t{ 0x12, \"Value\" },\n\t{ 0x13, \"And\" },\n\t{ 0x14, \"Or\" },\n\t{ 0x15, \"FreeText\" },\n\t{ 0x17, \"DeepTraversal\" },\n\t{ 0x18, \"LongId\" },\n\t{ 0x19, \"RebuildResults\" },\n\t{ 0x1A, \"LessThan\" },\n\t{ 0x1B, \"GreaterThan\" },\n\t{ 0x1E, \"UserName\" },\n\t{ 0x1F, \"Password\" },\n\t{ 0x20, \"ConversationId\" },\n\t{ 0x21, \"Picture\" },\n\t{ 0x22, \"MaxSize\" },\n\t{ 0x23, \"MaxPictures\" },\n\n\t{ 0x00, NULL }\n};\n\nstatic const value_string wbxml_mssyncc10_tags_cp16[] = { /* ActiveSync 'Gal:' Page */\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"DisplayName\" },\n\t{ 0x06, \"Phone\" },\n\t{ 0x07, \"Office\" },\n\t{ 0x08, \"Title\" },\n\t{ 0x09, \"Company\" },\n\t{ 0x0A, \"Alias\" },\n\t{ 0x0B, \"FirstName\" },\n\t{ 0x0C, \"LastName\" },\n\t{ 0x0D, \"HomePhone\" },\n\t{ 0x0E, \"MobilePhone\" },\n\t{ 0x0F, \"EmailAddress\" },\n\t{ 0x10, \"Picture\" },\n\t{ 0x11, \"Status\" },\n\t{ 0x12, \"Data\" },\n\n\t{ 0x00, NULL }\n};\n\nstatic const value_string wbxml_mssyncc10_tags_cp17[] = { /* ActiveSync 'AirSyncBase:' Page */\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"BodyPreference\" },\n\t{ 0x06, \"Type\" },\n\t{ 0x07, \"TruncationSize\" },\n\t{ 0x08, \"AllOrNone\" },\n\t{ 0x0A, \"Body\" },\n\t{ 0x0B, \"Data\" },\n\t{ 0x0C, \"EstimatedDataSize\" },\n\t{ 0x0D, \"Truncated\" },\n\t{ 0x0E, \"Attachments\" },\n\t{ 0x0F, \"Attachment\" },\n\t{ 0x10, \"DisplayName\" },\n\t{ 0x11, \"FileReference\" },\n\t{ 0x12, \"Method\" },\n\t{ 0x13, \"ContentId\" },\n\t{ 0x14, \"ContentLocation\" },\n\t{ 0x15, \"IsInline\" },\n\t{ 0x16, \"NativeBodyType\" },\n\t{ 0x17, \"ContentType\" },\n\t{ 0x18, \"Preview\" },\n\t{ 0x19, \"BodyPartReference\" },\n\t{ 0x1A, \"BodyPart\" },\n\t{ 0x1B, \"Status\" },\n\n\t{ 0x00, NULL }\n};\n\nstatic const value_string wbxml_mssyncc10_tags_cp18[] = { /* ActiveSync 'Settings:' Page */\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"Settings\" },\n\t{ 0x06, \"Status\" },\n\t{ 0x07, \"Get\" },\n\t{ 0x08, \"Set\" },\n\t{ 0x09, \"Oof\" },\n\t{ 0x0A, \"OofState\" },\n\t{ 0x0B, \"StartTime\" },\n\t{ 0x0C, \"EndTime\" },\n\t{ 0x0D, \"OofMessage\" },\n\t{ 0x0E, \"AppliesToInternal\" },\n\t{ 0x0F, \"AppliesToExternalKnown\" },\n\t{ 0x10, \"AppliesToExternalUnknown\" },\n\t{ 0x11, \"Enabled\" },\n\t{ 0x12, \"ReplyMessage\" },\n\t{ 0x13, \"BodyType\" },\n\t{ 0x14, \"DevicePassword\" },\n\t{ 0x15, \"Password\" },\n\t{ 0x16, \"DeviceInformation\" },\n\t{ 0x17, \"Model\" },\n\t{ 0x18, \"IMEI\" },\n\t{ 0x19, \"FriendlyName\" },\n\t{ 0x1A, \"OS\" },\n\t{ 0x1B, \"OSLanguage\" },\n\t{ 0x1C, \"PhoneNumber\" },\n\t{ 0x1D, \"UserInformation\" },\n\t{ 0x1E, \"EmailAddresses\" },\n\t{ 0x1F, \"SmtpAddress\" },\n\t{ 0x20, \"UserAgent\" },\n\t{ 0x21, \"EnableOutboundSMS\" },\n\t{ 0x22, \"MobileOperator\" },\n\t{ 0x23, \"PrimarySmtpAddress\" },\n\t{ 0x24, \"Accounts\" },\n\t{ 0x25, \"Account\" },\n\t{ 0x26, \"AccountId\" },\n\t{ 0x27, \"AccountName\" },\n\t{ 0x28, \"UserDisplayName\" },\n\t{ 0x29, \"SendDisabled\" },\n\t{ 0x2B, \"RightsManagementInformation\" },\n\n\t{ 0x00, NULL }\n};\n\nstatic const value_string wbxml_mssyncc10_tags_cp19[] = { /* ActiveSync 'DocumentLibrary:' Page */\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"LinkId\" },\n\t{ 0x06, \"DisplayName\" },\n\t{ 0x07, \"IsFolder\" },\n\t{ 0x09, \"CreationDate\" },\n\t{ 0x0A, \"LastModifiedDate\" },\n\t{ 0x0B, \"ContentLength\" },\n\t{ 0x0C, \"ContentType\" },\n\n\t{ 0x00, NULL }\n};\n\nstatic const value_string wbxml_mssyncc10_tags_cp20[] = { /* ActiveSync 'ItemOperations:' Page */\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"ItemOperations\" },\n\t{ 0x06, \"Fetch\" },\n\t{ 0x07, \"Store\" },\n\t{ 0x08, \"Options\" },\n\t{ 0x09, \"Range\" },\n\t{ 0x0A, \"Total\" },\n\t{ 0x0B, \"Properties\" },\n\t{ 0x0C, \"Data\" },\n\t{ 0x0D, \"Status\" },\n\t{ 0x0E, \"Response\" },\n\t{ 0x0F, \"Version\" },\n\t{ 0x10, \"Schema\" },\n\t{ 0x11, \"Part\" },\n\t{ 0x12, \"EmptyFolderContents\" },\n\t{ 0x13, \"DeleteSubFolders\" },\n\t{ 0x14, \"UserName\" },\n\t{ 0x15, \"Password\" },\n\t{ 0x16, \"Move\" },\n\t{ 0x17, \"DstFldId\" },\n\t{ 0x18, \"ConversationId\" },\n\t{ 0x19, \"MoveAlways\" },\n\n\t{ 0x00, NULL }\n};\n\nstatic const value_string wbxml_mssyncc10_tags_cp21[] = { /* ActiveSync 'ComposeMail:' Page */\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"SendMail\" },\n\t{ 0x06, \"SmartForward\" },\n\t{ 0x07, \"SmartReply\" },\n\t{ 0x08, \"SaveInSentItems\" },\n\t{ 0x09, \"ReplaceMime\" },\n\t{ 0x0B, \"Source\" },\n\t{ 0x0C, \"FolderId\" },\n\t{ 0x0D, \"ItemId\" },\n\t{ 0x0E, \"LongId\" },\n\t{ 0x0F, \"InstanceId\" },\n\t{ 0x10, \"MIME\" },\n\t{ 0x11, \"ClientId\" },\n\t{ 0x12, \"Status\" },\n\t{ 0x13, \"AccountId\" },\n\n\t{ 0x00, NULL }\n};\n\nstatic const value_string wbxml_mssyncc10_tags_cp22[] = { /* ActiveSync 'Email2:' Page */\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"UmCallerID\" },\n\t{ 0x06, \"UmUserNotes\" },\n\t{ 0x07, \"UmAttDuration\" },\n\t{ 0x08, \"UmAttOrder\" },\n\t{ 0x09, \"ConversationId\" },\n\t{ 0x0A, \"ConversationIndex\" },\n\t{ 0x0B, \"LastVerbExecuted\" },\n\t{ 0x0C, \"LastVerbExecutionTime\" },\n\t{ 0x0D, \"ReceivedAsBcc\" },\n\t{ 0x0E, \"Sender\" },\n\t{ 0x0F, \"CalendarType\" },\n\t{ 0x10, \"IsLeapMonth\" },\n\t{ 0x11, \"AccountId\" },\n\t{ 0x12, \"FirstDayOfWeek\" },\n\t{ 0x13, \"MeetingMessageType\" },\n\n\t{ 0x00, NULL }\n};\n\nstatic const value_string wbxml_mssyncc10_tags_cp23[] = { /* ActiveSync 'Notes:' Page */\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"Subject\" },\n\t{ 0x06, \"MessageClass\" },\n\t{ 0x07, \"LastModifiedDate\" },\n\t{ 0x08, \"Categories\" },\n\t{ 0x09, \"Category\" },\n\n\t{ 0x00, NULL }\n};\n\nstatic const value_string wbxml_mssyncc10_tags_cp24[] = { /* ActiveSync 'RightsManagement:' Page */\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"RightsManagementSupport\" },\n\t{ 0x06, \"RightsManagementTemplates\" },\n\t{ 0x07, \"RightsManagementTemplate\" },\n\t{ 0x08, \"RightsManagementLicense\" },\n\t{ 0x09, \"EditAllowed\" },\n\t{ 0x0A, \"ReplyAllowed\" },\n\t{ 0x0B, \"ReplyAllAllowed\" },\n\t{ 0x0C, \"ForwardAllowed\" },\n\t{ 0x0D, \"ModifyRecipientsAllowed\" },\n\t{ 0x0E, \"ExtractAllowed\" },\n\t{ 0x0F, \"PrintAllowed\" },\n\t{ 0x10, \"ExportAllowed\" },\n\t{ 0x11, \"ProgrammaticAccessAllowed\" },\n\t{ 0x12, \"RMOwner\" },\n\t{ 0x13, \"ContentExpiryDate\" },\n\t{ 0x14, \"TemplateId\" },\n\t{ 0x15, \"TemplateName\" },\n\t{ 0x16, \"TemplateDescription\" },\n\t{ 0x17, \"ContentOwner\" },\n\t{ 0x18, \"RemoveRightsManagementDistribution\" },\n\n\t{ 0x00, NULL }\n};\n\n\n/*****    Attribute Start tokens   *****/\n\n/*****    Attribute Value tokens   *****/\n\n/***** Token code page aggregation *****/\nstatic const value_valuestring wbxml_mssyncc10_tags[] = {\n\t{ 0x00, wbxml_mssyncc10_tags_cp0 }, /* AirSync: */\n\t{ 0x01, wbxml_mssyncc10_tags_cp1 }, /* Contacts: */\n\t{ 0x02, wbxml_mssyncc10_tags_cp2 }, /* Email: */\n\t{ 0x04, wbxml_mssyncc10_tags_cp4 }, /* Calendar: */\n\t{ 0x05, wbxml_mssyncc10_tags_cp5 }, /* Move: */\n\t{ 0x06, wbxml_mssyncc10_tags_cp6 }, /* GetItemEstimate: */\n\t{ 0x07, wbxml_mssyncc10_tags_cp7 }, /* FolderHierarchy: */\n\t{ 0x08, wbxml_mssyncc10_tags_cp8 }, /* MeetingResponse: */\n\t{ 0x09, wbxml_mssyncc10_tags_cp9 }, /* Tasks: */\n\t{ 0x0A, wbxml_mssyncc10_tags_cp10 }, /* ResolveRecipients: */\n\t{ 0x0B, wbxml_mssyncc10_tags_cp11 }, /* ValidateCert: */\n\t{ 0x0C, wbxml_mssyncc10_tags_cp12 }, /* Contacts2: */\n\t{ 0x0D, wbxml_mssyncc10_tags_cp13 }, /* Ping: */\n\t{ 0x0E, wbxml_mssyncc10_tags_cp14 }, /* Provision: */\n\t{ 0x0F, wbxml_mssyncc10_tags_cp15 }, /* Search: */\n\t{ 0x10, wbxml_mssyncc10_tags_cp16 }, /* Gal: */\n\t{ 0x11, wbxml_mssyncc10_tags_cp17 }, /* AirSyncBase: */\n\t{ 0x12, wbxml_mssyncc10_tags_cp18 }, /* Settings: */\n\t{ 0x13, wbxml_mssyncc10_tags_cp19 }, /* DocumentLibrary: */\n\t{ 0x14, wbxml_mssyncc10_tags_cp20 }, /* ItemOperations: */\n\t{ 0x15, wbxml_mssyncc10_tags_cp21 }, /* ComposeMail: */\n\t{ 0x16, wbxml_mssyncc10_tags_cp22 }, /* Email2: */\n\t{ 0x17, wbxml_mssyncc10_tags_cp23 }, /* Notes: */\n\t{ 0x18, wbxml_mssyncc10_tags_cp24 }, /* RightsManagement: */\n\n\t{ 0x00, NULL }\n};\n\nstatic const wbxml_decoding decode_mssync_10 = {\n\t\"Microsoft ActiveSync\",\n\t\"ActiveSync\",\n\t{ NULL, NULL, NULL },\n\tdefault_opaque_binary_tag,\n\tdefault_opaque_literal_tag,\n\tdefault_opaque_binary_attr,\n\tdefault_opaque_literal_attr,\n\tNULL,\n\twbxml_mssyncc10_tags,\n\tNULL,\n\tNULL\n};\n\n\n\n\n/* CHANNEL 1.0\n *\n * WTA Channel\n ***************************************/\n\n/*****   Global extension tokens   *****/\n\n/*****         Tag tokens          *****/\nstatic const value_string wbxml_channelc10_tags_cp0[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"channel\" },\n\t{ 0x06, \"title\" },\n\t{ 0x07, \"abstract\" },\n\t{ 0x08, \"resource\" },\n\n\t{ 0x00, NULL }\n};\n\n/*****    Attribute Start tokens   *****/\nstatic const value_string wbxml_channelc10_attrStart_cp0[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"maxspace=\" },\n\t{ 0x06, \"base=\" },\n\t{ 0x07, \"href=\" },\n\t{ 0x08, \"href='http://'\" },\n\t{ 0x09, \"href='https://'\" },\n\t{ 0x0A, \"lastmod=\" },\n\t{ 0x0B, \"etag=\" },\n\t{ 0x0C, \"md5=\" },\n\t{ 0x0D, \"success=\" },\n\t{ 0x0E, \"success='http://'\" },\n\t{ 0x0F, \"success='https://'\" },\n\t{ 0x10, \"failure=\" },\n\t{ 0x11, \"failure='http://'\" },\n\t{ 0x12, \"failure='https://'\" },\n\t{ 0x13, \"EventId=\" },\n\n\t{ 0x00, NULL }\n};\n\n/*****    Attribute Value tokens   *****/\n\n/***** Token code page aggregation *****/\nstatic const value_valuestring wbxml_channelc10_tags[] = {\n\t{ 0, wbxml_channelc10_tags_cp0 },\n\t{ 0, NULL }\n};\n\nstatic const value_valuestring wbxml_channelc10_attrStart[] = {\n\t{ 0, wbxml_channelc10_attrStart_cp0 },\n\t{ 0, NULL }\n};\n\nstatic const wbxml_decoding decode_channelc_10 = {\n\t\"Wireless Telephony Application (WTA) Channel 1.0\",\n\t\"CHANNEL 1.0\",\n\t{ NULL, NULL, NULL },\n\tdefault_opaque_binary_tag,\n\tdefault_opaque_literal_tag,\n\tdefault_opaque_binary_attr,\n\tdefault_opaque_literal_attr,\n\tNULL,\n\twbxml_channelc10_tags,\n\twbxml_channelc10_attrStart,\n\tNULL\n};\n\n\n\n\n\n/* application/x-wap-prov.browser-settings\n * application/x-wap-prov.browser-bookmarks\n *\n * Nokia OTA Provisioning document format\n ***************************************/\n\n/*****   Global extension tokens   *****/\n\n/*****         Tag tokens          *****/\nstatic const value_string wbxml_nokiaprovc70_tags_cp0[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"CHARACTERISTIC-LIST\" },\n\t{ 0x06, \"CHARACTERISTIC\" },\n\t{ 0x07, \"PARM\" },\n\n\t{ 0x00, NULL }\n};\n\n/*****    Attribute Start tokens   *****/\nstatic const value_string wbxml_nokiaprovc70_attrStart_cp0[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x06, \"TYPE='ADDRESS'\" },\n\t{ 0x07, \"TYPE='URL'\" },\n\t{ 0x08, \"TYPE='NAME'\" },\n\t{ 0x10, \"NAME=\" },\n\t{ 0x11, \"VALUE=\" },\n\t{ 0x12, \"NAME='BEARER'\" },\n\t{ 0x13, \"NAME='PROXY'\" },\n\t{ 0x14, \"NAME='PORT'\" },\n\t{ 0x15, \"NAME='NAME'\" },\n\t{ 0x16, \"NAME='PROXY_TYPE'\" },\n\t{ 0x17, \"NAME='URL'\" },\n\t{ 0x18, \"NAME='PROXY_AUTHNAME'\" },\n\t{ 0x19, \"NAME='PROXY_AUTHSECRET'\" },\n\t{ 0x1A, \"NAME='SMS_SMSC_ADDRESS'\" },\n\t{ 0x1B, \"NAME='USSD_SERVICE_CODE'\" },\n\t{ 0x1C, \"NAME='GPRS_ACCESSPOINTNAME'\" },\n\t{ 0x1D, \"NAME='PPP_LOGINTYPE'\" },\n\t{ 0x1E, \"NAME='PROXY_LOGINTYPE'\" },\n\t{ 0x21, \"NAME='CSD_DIALSTRING'\" },\n\t{ 0x22, \"NAME='PPP_AUTHTYPE'\" },\n\t{ 0x23, \"NAME='PPP_AUTHNAME'\" },\n\t{ 0x24, \"NAME='PPP_AUTHSECRET'\" },\n\t{ 0x28, \"NAME='CSD_CALLTYPE'\" },\n\t{ 0x29, \"NAME='CSD_CALLSPEED'\" },\n\t{ 0x45, \"VALUE='GSM/CSD'\" },\n\t{ 0x46, \"VALUE='GSM/SMS'\" },\n\t{ 0x47, \"VALUE='GSM/USSD'\" },\n\t{ 0x48, \"VALUE='IS-136/CSD'\" },\n\t{ 0x49, \"VALUE='GPRS'\" },\n\t{ 0x60, \"VALUE='9200'\" },\n\t{ 0x61, \"VALUE='9201'\" },\n\t{ 0x62, \"VALUE='9202'\" },\n\t{ 0x63, \"VALUE='9203'\" },\n\t{ 0x64, \"VALUE='AUTOMATIC'\" },\n\t{ 0x65, \"VALUE='MANUAL'\" },\n\t{ 0x6A, \"VALUE='AUTO'\" },\n\t{ 0x6B, \"VALUE='9600'\" },\n\t{ 0x6C, \"VALUE='14400'\" },\n\t{ 0x6D, \"VALUE='19200'\" },\n\t{ 0x6E, \"VALUE='28800'\" },\n\t{ 0x6F, \"VALUE='38400'\" },\n\t{ 0x70, \"VALUE='PAP'\" },\n\t{ 0x71, \"VALUE='CHAP'\" },\n\t{ 0x72, \"VALUE='ANALOGUE'\" },\n\t{ 0x73, \"VALUE='ISDN'\" },\n\t{ 0x74, \"VALUE='43200'\" },\n\t{ 0x75, \"VALUE='57600'\" },\n\t{ 0x76, \"VALUE='MSISDN_NO'\" },\n\t{ 0x77, \"VALUE='IPV4'\" },\n\t{ 0x78, \"VALUE='MS_CHAP'\" },\n\t{ 0x7C, \"TYPE='MMSURL'\" },\n\t{ 0x7D, \"TYPE='ID'\" },\n\t{ 0x7E, \"NAME='ISP_NAME'\" },\n\t{ 0x7F, \"TYPE='BOOKMARK'\" },\n\n\t{ 0x00, NULL }\n};\n\n/*****    Attribute Value tokens   *****/\n\n/***** Token code page aggregation *****/\nstatic const value_valuestring wbxml_nokiaprovc70_tags[] = {\n\t{ 0, wbxml_nokiaprovc70_tags_cp0 },\n\t{ 0, NULL }\n};\n\nstatic const value_valuestring wbxml_nokiaprovc70_attrStart[] = {\n\t{ 0, wbxml_nokiaprovc70_attrStart_cp0 },\n\t{ 0, NULL }\n};\n\nstatic const wbxml_decoding decode_nokiaprovc_70 = {\n\t\"Nokia Client Provisioning 7.0\",\n\t\"Nokia Client Provisioning 7.0\",\n\t{ NULL, NULL, NULL },\n\tdefault_opaque_binary_tag,\n\tdefault_opaque_literal_tag,\n\tdefault_opaque_binary_attr,\n\tdefault_opaque_literal_attr,\n\tNULL,\n\twbxml_nokiaprovc70_tags,\n\twbxml_nokiaprovc70_attrStart,\n\tNULL\n};\n\n\n\n\n\n/* UAProf [WAP-248]\n *\n * User-Agent Profile (used in profile-diff WSP header)\n ***************************************/\n\n/*****   Global extension tokens   *****/\n\n/*****         Tag tokens          *****/\n/* CodePage\t0\tRDF */\nstatic const value_string  wbxml_uaprof_tags_cp0[] = {\n\t{0x05, \"rdf:RDF\"},\n\t{0x06, \"rdf:Description\"},\n\t{0x07, \"rdf:Alt\"},\n\t{0x08, \"rdf:Bag\"},\n\t{0x09, \"rdf:Seq\"},\n\t{0x0A, \"rdf:li\"},\n\t{0x0B, \"rdf:type\"},\n\t{0x0C, \"rdf:value\"},\n\t{0x0D, \"rdf:subject\"},\n\t{0x0E, \"rdf:predicate\"},\n\t{0x0F, \"rdf:object\"},\n\n\t{ 0x00, NULL }\n};\n\n/* CodePage\t1\tCore Vocabulary */\nstatic const value_string  wbxml_uaprof_tags_cp1[] = {\n\t{0x06, \"rdf:Description\"},\n\t{0x07, \"rdf:Alt\"},\n\t{0x08, \"rdf:Bag\"},\n\t{0x09, \"rdf:Seq\"},\n\t{0x0A, \"rdf:li\"},\n\t{0x0B, \"rdf:type\"},\n\t{0x0C, \"prf:component\"},\n\t{0x0D, \"prf:defaults\"},\n\t{0x0E, \"prf:BitsPerPixel\"},\n\t{0x0F, \"prf:ColorCapable\"},\n\t{0x10, \"prf:CPU\"},\n\t{0x11, \"prf:ImageCapable\"},\n\t{0x12, \"prf:InputCharSet\"},\n\t{0x13, \"prf:Keyboard\"},\n\t{0x15, \"prf:Model\"},\n\t{0x16, \"prf:OutputCharSet\"},\n\t{0x17, \"prf:PointingResolution\"},\n\t{0x18, \"prf:ScreenSize\"},\n\t{0x19, \"prf:ScreenSizeChar\"},\n\t{0x1A, \"prf:NumberOfSoftKeys\"},\n\t{0x1B, \"prf:SoundOutputCapable\"},\n\t{0x1C, \"prf:TextInputCapable\"},\n\t{0x1D, \"prf:Vendor\"},\n\t{0x1E, \"prf:VoiceInputCapable\"},\n\t{0x1F, \"prf:AcceptDownloadableSoftware\"},\n\t{0x20, \"prf:AudioInputEncoder\"},\n\t{0x21, \"prf:DownloadableSoftwareSupport\"},\n\t{0x22, \"prf:JavaEnabled\"},\n\t{0x23, \"prf:JVMVersion\"},\n\t{0x24, \"prf:MexeClassmark\"},\n\t{0x25, \"prf:MexeSpec\"},\n\t{0x26, \"prf:OSName\"},\n\t{0x27, \"prf:OSVendor\"},\n\t{0x28, \"prf:OSVersion\"},\n\t{0x29, \"prf:RecipientAppAgent\"},\n\t{0x2A, \"prf:SoftwareNumber\"},\n\t{0x2B, \"prf:VideoInputEncoder\"},\n\t{0x2C, \"prf:CurrentBearerService\"},\n\t{0x2D, \"prf:SecuritySupport\"},\n\t{0x2E, \"prf:SupportedBearers\"},\n\t{0x2F, \"prf:WapDeviceClass\"},\n\t{0x30, \"prf:WapPushMsgPriority\"}, /* Deprecated */\n\t{0x31, \"prf:WapPushMsgSize\"}, /* Deprecated */\n\t{0x32, \"prf:WapVersion\"},\n\t{0x33, \"prf:WmlDeckSize\"},\n\t{0x34, \"prf:WmlScriptLibraries\"},\n\t{0x35, \"prf:WmlScriptVersion\"},\n\t{0x36, \"prf:WmlVersion\"},\n\t{0x37, \"prf:WtaiLibraries\"},\n\t{0x38, \"prf:WtaVersion\"},\n\t{0x39, \"prf:PixelAspectRatio\"},\n\t{0x3A, \"prf:StandardFontProportional\"},\n\t{0x3B, \"prf:WapSupportedApplications\"}, /* Deprecated */\n\t{0x3C, \"prf:BluetoothProfile\"},\n\t{0x3D, \"prf:MexeClassmarks\"},\n\t{0x3E, \"prf:MexeSecureDomains\"},\n\n\t{ 0x00, NULL }\n};\n\n/* CodePage\t4\tCore Vocabulary (continued) */\nstatic const value_string  wbxml_uaprof_tags_cp4[] = {\n\t{0x10, \"prf:SupportedBluetoothVersion\"},\n\t{0x11, \"prf:SupportedPictogramSet\"},\n\t{0x12, \"prf:CcppAccept\"},\n\t{0x13, \"prf:CcppAccept-Charset\"},\n\t{0x14, \"prf:CcppAccept-Encoding\"},\n\t{0x15, \"prf:CcppAccept-Language\"},\n\n\t{ 0x00, NULL }\n};\n\n/* CodePage\t2\tBrowserUA */\nstatic const value_string  wbxml_uaprof_tags_cp2[] = {\n\t{0x05, \"rdf:Description\"},\n\t{0x06, \"rdf:Alt\"},\n\t{0x07, \"rdf:Bag\"},\n\t{0x08, \"rdf:Seq\"},\n\t{0x09, \"rdf:li\"},\n\t{0x0A, \"rdf:type\"},\n\t{0x0B, \"prf:component\"},\n\t{0x0C, \"prf:defaults\"},\n\t{0x0D, \"prf:BrowserName\"},\n\t{0x0E, \"prf:BrowserVersion\"},\n\t{0x0F, \"prf:CcppAccept\"}, /* Deprecated */\n\t{0x10, \"prf:CcppAccept-Charset\"}, /* Deprecated */\n\t{0x11, \"prf:CcppAccept-Encoding\"}, /* Deprecated */\n\t{0x12, \"prf:CcppAccept-Language\"}, /* Deprecated */\n\t{0x13, \"prf:DownloadableBrowserApps\"},\n\t{0x14, \"prf:FramesCapable\"},\n\t{0x15, \"prf:HtmlVersion\"},\n\t{0x16, \"prf:JavaAppletEnabled\"},\n\t{0x17, \"prf:JavaScriptEnabled\"},\n\t{0x18, \"prf:JavaScriptVersion\"},\n\t{0x19, \"prf:PreferenceForFrames\"},\n\t{0x1A, \"prf:TablesCapable\"},\n\t{0x1B, \"prf:XhtmlVersion\"},\n\t{0x1C, \"prf:XhtmlModules\"},\n\n\t{ 0x00, NULL }\n};\n\n/* CodePage\t3\tPushCharacteristics */\nstatic const value_string  wbxml_uaprof_tags_cp3[] = {\n\t{0x05, \"rdf:Description\"},\n\t{0x06, \"rdf:Alt\"},\n\t{0x07, \"rdf:Bag\"},\n\t{0x08, \"rdf:Seq\"},\n\t{0x09, \"rdf:li\"},\n\t{0x0A, \"rdf:type\"},\n\t{0x0B, \"prf:component\"},\n\t{0x0C, \"prf:defaults\"},\n\t{0x0D, \"prf:Push-Accept\"},\n\t{0x0E, \"prf:Push-Accept-Charset\"},\n\t{0x0F, \"prf:Push-Accept-Encoding\"},\n\t{0x10, \"prf:Push-Accept-Language\"},\n\t{0x11, \"prf:Push-Accept-AppID\"},\n\t{0x12, \"prf:Push-MsgSize\"},\n\t{0x13, \"prf:Push-MaxPushReq\"},\n\n\t{ 0x00, NULL }\n};\n\n/*****    Attribute Start tokens   *****/\n/* CodePage\t0\tRDF */\nstatic const value_string  wbxml_uaprof_attrStart_cp0[] = {\n\t{0x05, \"ID\"},\n\t{0x06, \"rdf:about\"},\n\t{0x07, \"rdf:aboutEach\"},\n\t{0x08, \"rdf:aboutEachPrefix\"},\n\t{0x09, \"rdf:bagID\"},\n\t{0x0A, \"rdf:type\"},\n\t{0x0B, \"rdf:resource\"},\n\t{0x0C, \"rdf:parseType='Literal'\"},\n\t{0x0D, \"rdf:parseType='Resource'\"},\n\t{0x0E, \"xml:lang\"},\n\t{0x0F, \"xmlns:prf\"},\n\t{0x10, \"xmlns:rdf\"},\n\n\t{ 0x00, NULL }\n};\n\n/* CodePage\t1\tCore Vocabulary */\nstatic const value_string  wbxml_uaprof_attrStart_cp1[] = {\n\t{0x05, \"rdf:resource\"},\n\t{0x06, \"rdf:resource='http://www.wapforum.org/profiles/UAPROF/\"\n\t \"ccppschema-20010430#HardwarePlatform'\"},\n\t{0x07, \"rdf:resource='http://www.wapforum.org/profiles/UAPROF/\"\n\t \"ccppschema-20010430#SoftwarePlatform'\"},\n\t{0x08, \"rdf:resource='http://www.wapforum.org/profiles/UAPROF/\"\n\t \"ccppschema-20010430#NetworkCharacteristics'\"},\n\t{0x09, \"rdf:resource='http://www.wapforum.org/profiles/UAPROF/\"\n\t \"ccppschema-20010430#WapCharacteristics'\"},\n\t{0x0A, \"rdf:resource='http://www.wapforum.org/profiles/UAPROF/\"\n\t \"ccppschema-20010430#BrowserUA'\"},\n\t{0x0B, \"rdf:resource='http://www.wapforum.org/profiles/UAPROF/\"\n\t \"ccppschema-20010430#PushCharacteristics'\"},\n\t{0x10, \"prf:BitsPerPixel\"},\n\t{0x11, \"prf:ColorCapable='Yes'\"},\n\t{0x12, \"prf:ColorCapable='No'\"},\n\t{0x13, \"prf:CPU\"},\n\t{0x14, \"prf:ImageCapable='Yes'\"},\n\t{0x15, \"prf:ImageCapable='No'\"},\n\t{0x16, \"prf:InputCharSet\"},\n\t{0x17, \"prf:Keyboard\"},\n\t{0x19, \"prf:Model\"},\n\t{0x1A, \"prf:OutputCharSet\"},\n\t{0x1B, \"prf:PointingResolution\"},\n\t{0x1C, \"prf:ScreenSize\"},\n\t{0x1D, \"prf:ScreenSizeChar\"},\n\t{0x1E, \"prf:NumberOfSoftKeys='Yes'\"},\n\t{0x20, \"prf:SoundOutputCapable='Yes'\"},\n\t{0x21, \"prf:SoundOutputCapable='No'\"},\n\t{0x22, \"prf:TextInputCapable='Yes'\"},\n\t{0x23, \"prf:TextInputCapable='No'\"},\n\t{0x24, \"prf:Vendor\"},\n\t{0x25, \"prf:VoiceInputCapable='Yes'\"},\n\t{0x26, \"prf:VoiceInputCapable='No'\"},\n\t{0x27, \"prf:PixelAspectRatio\"},\n\t{0x28, \"prf:StandardFontProportional='Yes'\"},\n\t{0x29, \"prf:StandardFontProportional='No'\"},\n\t{0x30, \"prf:AcceptDownloadableSoftware='Yes'\"},\n\t{0x31, \"prf:AcceptDownloadableSoftware='No'\"},\n\t{0x32, \"prf:AudioInputEncoder\"},\n\t{0x33, \"prf:DownloadableSoftwareSupport\"},\n\t{0x35, \"prf:JavaEnabled='Yes'\"},\n\t{0x36, \"prf:JavaEnabled='No'\"},\n\t{0x37, \"prf:JVMVersion\"},\n\t{0x38, \"prf:MexeClassmark\"},\n\t{0x39, \"prf:MexeSpec\"},\n\t{0x3A, \"prf:OSName\"},\n\t{0x3B, \"prf:OSVendor\"},\n\t{0x3C, \"prf:OSVersion\"},\n\t{0x3D, \"prf:RecipientAppAgent\"},\n\t{0x3E, \"prf:SoftwareNumber\"},\n\t{0x21, \"prf:SoundOutputCapable='No'\"},\n\t{0x22, \"prf:TextInputCapable='Yes'\"},\n\t{0x23, \"prf:TextInputCapable='No'\"},\n\t{0x24, \"prf:Vendor\"},\n\t{0x25, \"prf:VoiceInputCapable='Yes'\"},\n\t{0x26, \"prf:VoiceInputCapable='No'\"},\n\t{0x27, \"prf:PixelAspectRatio\"},\n\t{0x28, \"prf:StandardFontProportional='Yes'\"},\n\t{0x29, \"prf:StandardFontProportional='No'\"},\n\t{0x30, \"prf:AcceptDownloadableSoftware='Yes'\"},\n\t{0x31, \"prf:AcceptDownloadableSoftware='No'\"},\n\t{0x32, \"prf:AudioInputEncoder\"},\n\t{0x33, \"prf:DownloadableSoftwareSupport\"},\n\t{0x35, \"prf:JavaEnabled='Yes'\"},\n\t{0x36, \"prf:JavaEnabled='No'\"},\n\t{0x37, \"prf:JVMVersion\"},\n\t{0x38, \"prf:MexeClassmark\"},\n\t{0x39, \"prf:MexeSpec\"},\n\t{0x3A, \"prf:OSName\"},\n\t{0x3B, \"prf:OSVendor\"},\n\t{0x3C, \"prf:OSVersion\"},\n\t{0x3D, \"prf:RecipientAppAgent\"},\n\t{0x3E, \"prf:SoftwareNumber\"},\n\t{0x3F, \"prf:VideoInputEncoder\"},\n\t{0x50, \"prf:CurrentBearerService\"},\n\t{0x51, \"prf:SecuritySupport\"},\n\t{0x52, \"prf:SupportedBearers\"},\n\t{0x60, \"prf:WapDeviceClass\"},\n\t{0x61, \"prf:WapPushMsgPriority\"}, /* Deprecated */\n\t{0x62, \"prf:WapPushMsgSize\"}, /* Deprecated */\n\t{0x63, \"prf:WapVersion\"},\n\t{0x64, \"prf:WmlDeckSize\"},\n\t{0x65, \"prf:WmlScriptLibraries\"},\n\t{0x66, \"prf:WmlScriptVersion\"},\n\t{0x67, \"prf:WmlVersion\"},\n\t{0x68, \"prf:WtaiLibraries\"},\n\t{0x69, \"prf:WtaVersion\"},\n\t{0x70, \"prf:WapSupportedApplications\"}, /* Deprecated */\n\t{0x71, \"prf:BluetoothProfile\"},\n\t{0x72, \"prf:MexeClassmarks\"},\n\t{0x73, \"prf:MexeSecureDomains='YES'\"},\n\t{0x74, \"prf:MexeSecureDomains='NO'\"},\n\t{0x75, \"prf:SupportedBluetoothVersion\"},\n\t{0x76, \"prf:SupportedPictogramSet\"},\n\t{0x77, \"prf:CcppAccept\"},\n\t{0x78, \"prf:CcppAccept-Charset\"},\n\t{0x79, \"prf:CcppAccept-Encoding\"},\n\t{0x7F, \"prf:CcppAccept-Language\"},\n\n\t{ 0x00, NULL }\n};\n\n/* CodePage\t2\tBrowserUA */\nstatic const value_string  wbxml_uaprof_attrStart_cp2[] = {\n\t{0x05, \"prf:CcppAccept\"}, /* Deprecated */\n\t{0x06, \"prf:CcppAccept-Charset\"}, /* Deprecated */\n\t{0x07, \"prf:CcppAccept-Encoding\"}, /* Deprecated */\n\t{0x08, \"prf:CcppAccept-Language\"}, /* Deprecated */\n\t{0x09, \"prf:DownloadableBrowserApps\"},\n\t{0x0A, \"prf:FramesCapable='Yes'\"},\n\t{0x0B, \"prf:FramesCapable='No'\"},\n\t{0x0C, \"prf:HtmlVersion='3.2'\"},\n\t{0x0D, \"prf:HtmlVersion='4.0'\"},\n\t{0x0E, \"prf:JavaAppletEnabled='Yes'\"},\n\t{0x0F, \"prf:JavaAppletEnabled='No'\"},\n\t{0x10, \"prf:JavaScriptEnabled='Yes'\"},\n\t{0x11, \"prf:JavaScriptEnabled='No'\"},\n\t{0x12, \"prf:JavaScriptVersion\"},\n\t{0x13, \"prf:PreferenceForFrames='Yes'\"},\n\t{0x14, \"prf:PreferenceForFrames='No'\"},\n\t{0x15, \"prf:TablesCapable='Yes'\"},\n\t{0x16, \"prf:TablesCapable='No'\"},\n\t{0x17, \"prf:XhtmlVersion\"},\n\t{0x18, \"prf:XhtmlModules\"},\n\t{0x19, \"prf:BrowserName\"},\n\t{0x1A, \"prf:BrowserVersion\"},\n\n\t{ 0x00, NULL }\n};\n\n/* CodePage\t3\tPushCharacteristics */\nstatic const value_string  wbxml_uaprof_attrStart_cp3[] = {\n\t{0x05, \"prf:Push-Accept\"},\n\t{0x06, \"prf:Push-Accept-Charset\"},\n\t{0x07, \"prf:Push-Accept-Encoding\"},\n\t{0x08, \"prf:Push-Accept-Language\"},\n\t{0x09, \"prf:Push-Accept-AppID\"},\n\t{0x0A, \"prf:Push-MsgSize\"},\n\t{0x0B, \"prf:Push-MaxPushReq\"},\n\n\t{ 0x00, NULL }\n};\n\n/*****    Attribute Value tokens   *****/\n/* CodePage\t0\tRDF */\nstatic const value_string  wbxml_uaprof_attrValue_cp0[] = {\n\t{0x85, \"rdf:Statement\"},\n\t{0x86, \"http://\"},\n\t{0x87, \"http://www.\"},\n\t{0x88, \"https://\"},\n\t{0x89, \"https://www.\"},\n\t{0x8A, \"www.\"},\n\t{0x8B, \".com/\"},\n\t{0x8C, \".edu/\"},\n\t{0x8D, \".net/\"},\n\t{0x8E, \".org/\"},\n\n\t{ 0x00, NULL }\n};\n\n/* CodePage\t1\tCoreVocabularyAttrValue */\nstatic const value_string  wbxml_uaprof_attrValue_cp1[] = {\n\t{0x85, \"No\"},\n\t{0x86, \"Yes\"},\n\n\t{ 0x00, NULL }\n};\n\n/* CodePage\t2\tBrowserUAAttrValue */\nstatic const value_string  wbxml_uaprof_attrValue_cp2[] = {\n\t{0x85, \"No\"},\n\t{0x86, \"Yes\"},\n\n\t{ 0x00, NULL }\n};\n\n/***** Token code page aggregation *****/\nstatic const value_valuestring wbxml_uaprof_tags[] = {\n\t{ 0, wbxml_uaprof_tags_cp0 },\n\t{ 1, wbxml_uaprof_tags_cp1 },\n\t{ 2, wbxml_uaprof_tags_cp2 },\n\t{ 3, wbxml_uaprof_tags_cp3 },\n\t{ 4, wbxml_uaprof_tags_cp4 },\n\t{ 0, NULL }\n};\n\nstatic const value_valuestring wbxml_uaprof_attrStart[] = {\n\t{ 0, wbxml_uaprof_attrStart_cp0 },\n\t{ 1, wbxml_uaprof_attrStart_cp1 },\n\t{ 2, wbxml_uaprof_attrStart_cp2 },\n\t{ 3, wbxml_uaprof_attrStart_cp3 },\n\t{ 0, NULL }\n};\n\nstatic const value_valuestring wbxml_uaprof_attrValue[] = {\n\t{ 0, wbxml_uaprof_attrValue_cp0 },\n\t{ 1, wbxml_uaprof_attrValue_cp1 },\n\t{ 2, wbxml_uaprof_attrValue_cp2 },\n\t{ 0, NULL }\n};\n\nstatic const wbxml_decoding decode_uaprof_wap_248 = {\n\t\"User-Agent Profile (WAP-174, WAP-248)\",\n\t\"UAProf (WAP-174, WAP-248)\",\n\t{ NULL, NULL, NULL },\n\tdefault_opaque_binary_tag,\n\tdefault_opaque_literal_tag,\n\tdefault_opaque_binary_attr,\n\tdefault_opaque_literal_attr,\n\tNULL,\n\twbxml_uaprof_tags,\n\twbxml_uaprof_attrStart,\n\twbxml_uaprof_attrValue\n};\n\n\n\n\n\n/* WV-CSP 1.0\n *\n * Wireless Village Client Server Protocol\n ***************************************/\n\n/*****   Global extension tokens   *****/\n\n/*****         Tag tokens          *****/\n/* Common code page (0x00) */\nstatic const value_string wbxml_wv_csp_10_tags_cp0[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"Acceptance\" },\n\t{ 0x06, \"AddList\" },\n\t{ 0x07, \"AddNickList\" },\n\t{ 0x08, \"Attribute\" },\n\t{ 0x09, \"AttributeList\" },\n\t{ 0x0A, \"ClientID\" },\n\t{ 0x0B, \"Code\" },\n\t{ 0x0C, \"ContactList\" },\n\t{ 0x0D, \"ContentData\" },\n\t{ 0x0E, \"ContentEncoding\" },\n\t{ 0x0F, \"ContentSize\" },\n\t{ 0x10, \"ContentType\" },\n\t{ 0x11, \"DateTime\" },\n\t{ 0x12, \"Description\" },\n\t{ 0x13, \"DetailedResult\" },\n\t{ 0x14, \"EntityList\" },\n\t{ 0x15, \"Group\" },\n\t{ 0x16, \"GroupID\" },\n\t{ 0x17, \"GroupList\" },\n\t{ 0x18, \"InUse\" },\n\t{ 0x19, \"Logo\" },\n\t{ 0x1A, \"MessageCount\" },\n\t{ 0x1B, \"MessageID\" },\n\t{ 0x1C, \"MessageURI\" },\n\t{ 0x1D, \"MSISDN\" },\n\t{ 0x1E, \"Name\" },\n\t{ 0x1F, \"NickList\" },\n\t{ 0x20, \"NickName\" },\n\t{ 0x21, \"Poll\" },\n\t{ 0x22, \"Presence\" },\n\t{ 0x23, \"PresenceSubList\" },\n\t{ 0x24, \"PresenceValue\" },\n\t{ 0x25, \"Property\" },\n\t{ 0x26, \"Qualifier\" },\n\t{ 0x27, \"Recipient\" },\n\t{ 0x28, \"RemoveList\" },\n\t{ 0x29, \"RemoveNickList\" },\n\t{ 0x2A, \"Result\" },\n\t{ 0x2B, \"ScreenName\" },\n\t{ 0x2C, \"Sender\" },\n\t{ 0x2D, \"Session\" },\n\t{ 0x2E, \"SessionDescriptor\" },\n\t{ 0x2F, \"SessionID\" },\n\t{ 0x30, \"SessionType\" },\n\t{ 0x31, \"Status\" },\n\t{ 0x32, \"Transaction\" },\n\t{ 0x33, \"TransactionContent\" },\n\t{ 0x34, \"TransactionDescriptor\" },\n\t{ 0x35, \"TransactionID\" },\n\t{ 0x36, \"TransactionMode\" },\n\t{ 0x37, \"URL\" },\n\t{ 0x38, \"URLList\" },\n\t{ 0x39, \"User\" },\n\t{ 0x3A, \"UserID\" },\n\t{ 0x3B, \"UserList\" },\n\t{ 0x3C, \"Validity\" },\n\t{ 0x3D, \"Value\" },\n\t{ 0x3E, \"WV-CSP-Message\" },\n\n\t{ 0x00, NULL }\n};\n\n/* Access code page (0x01) */\nstatic const value_string wbxml_wv_csp_10_tags_cp1[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"AllFunctions\" },\n\t{ 0x06, \"AllFunctionsRequest\" },\n\t{ 0x07, \"CancelInvite-Request\" },\n\t{ 0x08, \"CancelInviteUser-Request\" },\n\t{ 0x09, \"Capability\" },\n\t{ 0x0A, \"CapabilityList\" },\n\t{ 0x0B, \"CapabilityRequest\" },\n\t{ 0x0C, \"ClientCapability-Request\" },\n\t{ 0x0D, \"ClientCapability-Response\" },\n\t{ 0x0E, \"DigestBytes\" },\n\t{ 0x0F, \"DigestSchema\" },\n\t{ 0x10, \"Disconnect\" },\n\t{ 0x11, \"Functions\" },\n\t{ 0x12, \"GetSPInfo-Request\" },\n\t{ 0x13, \"GetSPInfo-Response\" },\n\t{ 0x14, \"InviteID\" },\n\t{ 0x15, \"InviteNote\" },\n\t{ 0x16, \"Invite-Request\" },\n\t{ 0x17, \"Invite-Response\" },\n\t{ 0x18, \"InviteType\" },\n\t{ 0x19, \"InviteUser-Request\" },\n\t{ 0x1A, \"InviteUser-Response\" },\n\t{ 0x1B, \"KeepAlive-Request\" },\n\t{ 0x1C, \"KeepAliveTime\" },\n\t{ 0x1D, \"Login-Request\" },\n\t{ 0x1E, \"Login-Response\" },\n\t{ 0x1F, \"Logout-Request\" },\n\t{ 0x20, \"Nonce\" },\n\t{ 0x21, \"Password\" },\n\t{ 0x22, \"Polling-Request\" },\n\t{ 0x23, \"ResponseNote\" },\n\t{ 0x24, \"SearchElement\" },\n\t{ 0x25, \"SearchFindings\" },\n\t{ 0x26, \"SearchID\" },\n\t{ 0x27, \"SearchIndex\" },\n\t{ 0x28, \"SearchLimit\" },\n\t{ 0x29, \"SearchOnlineStatus\" },\n\t{ 0x2A, \"SearchPairList\" },\n\t{ 0x2B, \"Search-Request\" },\n\t{ 0x2C, \"Search-Response\" },\n\t{ 0x2D, \"SearchResult\" },\n\t{ 0x2E, \"Service-Request\" },\n\t{ 0x2F, \"Service-Response\" },\n\t{ 0x30, \"SessionCookie\" },\n\t{ 0x31, \"StopSearch-Request\" },\n\t{ 0x32, \"TimeToLive\" },\n\n\t{ 0x00, NULL }\n};\n\n/* Service code page (0x02) */\nstatic const value_string wbxml_wv_csp_10_tags_cp2[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"ADDGM\" },\n\t{ 0x06, \"AttListFunc\" },\n\t{ 0x07, \"BLENT\" },\n\t{ 0x08, \"CAAUT\" },\n\t{ 0x09, \"CAINV\" },\n\t{ 0x0A, \"CALI\" },\n\t{ 0x0B, \"CCLI\" },\n\t{ 0x0C, \"ContListFunc\" },\n\t{ 0x0D, \"CREAG\" },\n\t{ 0x0E, \"DALI\" },\n\t{ 0x0F, \"DCLI\" },\n\t{ 0x10, \"DELGR\" },\n\t{ 0x11, \"FundamentalFeat\" },\n\t{ 0x12, \"FWMSG\" },\n\t{ 0x13, \"GALS\" },\n\t{ 0x14, \"GCLI\" },\n\t{ 0x15, \"GETGM\" },\n\t{ 0x16, \"GETGP\" },\n\t{ 0x17, \"GETLM\" },\n\t{ 0x18, \"GETM\" },\n\t{ 0x19, \"GETPR\" },\n\t{ 0x1A, \"GETSPI\" },\n\t{ 0x1B, \"GETWL\" },\n\t{ 0x1C, \"GLBLU\" },\n\t{ 0x1D, \"GRCHN\" },\n\t{ 0x1E, \"GroupAuthFunc\" },\n\t{ 0x1F, \"GroupFeat\" },\n\t{ 0x20, \"GroupMgmtFunc\" },\n\t{ 0x21, \"GroupUseFunc\" },\n\t{ 0x22, \"IMAuthFunc\" },\n\t{ 0x23, \"IMFeat\" },\n\t{ 0x24, \"IMReceiveFunc\" },\n\t{ 0x25, \"IMSendFunc\" },\n\t{ 0x26, \"INVIT\" },\n\t{ 0x27, \"InviteFunc\" },\n\t{ 0x28, \"MBRAC\" },\n\t{ 0x29, \"MCLS\" },\n\t{ 0x2A, \"MDELIV\" },\n\t{ 0x2B, \"NEWM\" },\n\t{ 0x2C, \"NOTIF\" },\n\t{ 0x2D, \"PresenceAuthFunc\" },\n\t{ 0x2E, \"PresenceDeliverFunc\" },\n\t{ 0x2F, \"PresenceFeat\" },\n\t{ 0x30, \"REACT\" },\n\t{ 0x31, \"REJCM\" },\n\t{ 0x32, \"REJEC\" },\n\t{ 0x33, \"RMVGM\" },\n\t{ 0x34, \"SearchFunc\" },\n\t{ 0x35, \"ServiceFunc\" },\n\t{ 0x36, \"SETD\" },\n\t{ 0x37, \"SETGP\" },\n\t{ 0x38, \"SRCH\" },\n\t{ 0x39, \"STSRC\" },\n\t{ 0x3A, \"SUBGCN\" },\n\t{ 0x3B, \"UPDPR\" },\n\t{ 0x3C, \"WVCSPFeat\" },\n\n\t{ 0x00, NULL }\n};\n\n/* Client capability code page (0x03) */\nstatic const value_string wbxml_wv_csp_10_tags_cp3[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"AcceptedCharset\" },\n\t{ 0x06, \"AcceptedContentLength\" },\n\t{ 0x07, \"AcceptedContentType\" },\n\t{ 0x08, \"AcceptedTransferEncoding\" },\n\t{ 0x09, \"AnyContent\" },\n\t{ 0x0A, \"ClientType\" },\n\t{ 0x0B, \"InitialDeliveryMethod\" },\n\t{ 0x0C, \"MultiTrans\" },\n\t{ 0x0D, \"ParserSize\" },\n\t{ 0x0E, \"ServerPollMin\" },\n\t{ 0x0F, \"SupportedBearer\" },\n\t{ 0x10, \"SupportedCIRMethod\" },\n\t{ 0x11, \"TCPAddress\" },\n\t{ 0x12, \"TCPPort\" },\n\t{ 0x13, \"UDPPort\" },\n\n\t{ 0x00, NULL }\n};\n\n/* Presence primitive code page (0x04) */\nstatic const value_string wbxml_wv_csp_10_tags_cp4[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"CancelAuth-Request\" },\n\t{ 0x06, \"ContactListProperties\" },\n\t{ 0x07, \"CreateAttributeList-Request\" },\n\t{ 0x08, \"CreateList-Request\" },\n\t{ 0x09, \"DefaultAttributeList\" },\n\t{ 0x0A, \"DefaultContactList\" },\n\t{ 0x0B, \"DefaultList\" },\n\t{ 0x0C, \"DeleteAttributeList-Request\" },\n\t{ 0x0D, \"DeleteList-Request\" },\n\t{ 0x0E, \"GetAttributeList-Request\" },\n\t{ 0x0F, \"GetAttributeList-Response\" },\n\t{ 0x10, \"GetList-Request\" },\n\t{ 0x11, \"GetList-Response\" },\n\t{ 0x12, \"GetPresence-Request\" },\n\t{ 0x13, \"GetPresence-Response\" },\n\t{ 0x14, \"GetWatcherList-Request\" },\n\t{ 0x15, \"GetWatcherList-Response\" },\n\t{ 0x16, \"ListManage-Request\" },\n\t{ 0x17, \"ListManage-Response\" },\n\t{ 0x18, \"Presence\" },\n\t{ 0x19, \"PresenceAuth-Request\" },\n\t{ 0x1A, \"PresenceAuth-Response\" },\n\t{ 0x1B, \"PresenceNotification-Request\" },\n\t{ 0x1C, \"PresenceValueList\" },\n\t{ 0x1D, \"SubscribePresence-Request\" },\n\t{ 0x1E, \"UnsubscribePresence-Request\" },\n\t{ 0x1F, \"UpdatePresence-Request\" },\n\n\t{ 0x00, NULL }\n};\n\n/* Presence attribute code page (0x05) */\nstatic const value_string wbxml_wv_csp_10_tags_cp5[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"Accuracy\" },\n\t{ 0x06, \"Address\" },\n\t{ 0x07, \"AddrPref\" },\n\t{ 0x08, \"Alias\" },\n\t{ 0x09, \"Altitude\" },\n\t{ 0x0A, \"Building\" },\n\t{ 0x0B, \"CAddr\" },\n\t{ 0x0C, \"City\" },\n\t{ 0x0D, \"ClientInfo\" },\n\t{ 0x0E, \"ClientProducer\" },\n\t{ 0x0F, \"ClientType\" },\n\t{ 0x10, \"ClientVersion\" },\n\t{ 0x11, \"CommC\" },\n\t{ 0x12, \"CommCap\" },\n\t{ 0x13, \"ContactInfo\" },\n\t{ 0x14, \"ContainedvCard\" },\n\t{ 0x15, \"Country\" },\n\t{ 0x16, \"Crossing1\" },\n\t{ 0x17, \"Crossing2\" },\n\t{ 0x18, \"DevManufacturer\" },\n\t{ 0x19, \"DirectContent\" },\n\t{ 0x1A, \"FreeTextLocation\" },\n\t{ 0x1B, \"GeoLocation\" },\n\t{ 0x1C, \"Language\" },\n\t{ 0x1D, \"Latitude\" },\n\t{ 0x1E, \"Longitude\" },\n\t{ 0x1F, \"Model\" },\n\t{ 0x20, \"NamedArea\" },\n\t{ 0x21, \"OnlineStatus\" },\n\t{ 0x22, \"PLMN\" },\n\t{ 0x23, \"PrefC\" },\n\t{ 0x24, \"PreferredContacts\" },\n\t{ 0x25, \"PreferredLanguage\" },\n\t{ 0x26, \"ReferredContent\" },\n\t{ 0x27, \"ReferredvCard\" },\n\t{ 0x28, \"Registration\" },\n\t{ 0x29, \"StatusContent\" },\n\t{ 0x2A, \"StatusMood\" },\n\t{ 0x2B, \"StatusText\" },\n\t{ 0x2C, \"Street\" },\n\t{ 0x2D, \"TimeZone\" },\n\t{ 0x2E, \"UserAvailability\" },\n\n\t{ 0x00, NULL }\n};\n\n/* Messaging code page (0x06) */\nstatic const value_string wbxml_wv_csp_10_tags_cp6[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"BlockList\" },\n\t{ 0x06, \"BlockUser-Request\" },\n\t{ 0x07, \"DeliveryMethod\" },\n\t{ 0x08, \"DeliveryReport\" },\n\t{ 0x09, \"DeliveryReport-Request\" },\n\t{ 0x0A, \"ForwardMessage-Request\" },\n\t{ 0x0B, \"GetBlockedList-Request\" },\n\t{ 0x0C, \"GetBlockedList-Response\" },\n\t{ 0x0D, \"GetMessageList-Request\" },\n\t{ 0x0E, \"GetMessageList-Response\" },\n\t{ 0x0F, \"GetMessage-Request\" },\n\t{ 0x10, \"GetMessage-Response\" },\n\t{ 0x11, \"GrantList\" },\n\t{ 0x12, \"MessageDelivered\" },\n\t{ 0x13, \"MessageInfo\" },\n\t{ 0x14, \"MessageNotification\" },\n\t{ 0x15, \"NewMessage\" },\n\t{ 0x16, \"RejectMessage-Request\" },\n\t{ 0x17, \"SendMessage-Request\" },\n\t{ 0x18, \"SendMessage-Response\" },\n\t{ 0x19, \"SetDeliveryMethod-Request\" },\n\n\t{ 0x00, NULL }\n};\n\n/* Group code page (0x07) */\nstatic const value_string wbxml_wv_csp_10_tags_cp7[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"AddGroupMembers-Request\" },\n\t{ 0x06, \"Admin\" },\n\t{ 0x07, \"CreateGroup-Request\" },\n\t{ 0x08, \"DeleteGroup-Request\" },\n\t{ 0x09, \"GetGroupMembers-Request\" },\n\t{ 0x0A, \"GetGroupMembers-Response\" },\n\t{ 0x0B, \"GetGroupProps-Request\" },\n\t{ 0x0C, \"GetGroupProps-Response\" },\n\t{ 0x0D, \"GroupChangeNotice\" },\n\t{ 0x0E, \"GroupProperties\" },\n\t{ 0x0F, \"Joined\" },\n\t{ 0x10, \"JoinedRequest\" },\n\t{ 0x11, \"JoinGroup-Request\" },\n\t{ 0x12, \"JoinGroup-Response\" },\n\t{ 0x13, \"LeaveGroup-Request\" },\n\t{ 0x14, \"LeaveGroup-Response\" },\n\t{ 0x15, \"Left\" },\n\t{ 0x16, \"MemberAccess-Request\" },\n\t{ 0x17, \"Mod\" },\n\t{ 0x18, \"OwnProperties\" },\n\t{ 0x19, \"RejectList-Request\" },\n\t{ 0x1A, \"RejectList-Response\" },\n\t{ 0x1B, \"RemoveGroupMembers-Request\" },\n\t{ 0x1C, \"SetGroupProps-Request\" },\n\t{ 0x1D, \"SubscribeGroupNotice-Request\" },\n\t{ 0x1E, \"SubscribeGroupNotice-Response\" },\n\t{ 0x1F, \"Users\" },\n\t{ 0x20, \"WelcomeNote\" },\n\n\t{ 0x00, NULL }\n};\n\n/*\n * Attribute start tokens\n */\n/* common code page (0x00) */\nstatic const value_string wbxml_wv_csp_10_attrStart_cp0[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"xmlns='http://www.wireless-village.org/CSP'\" },\n\t{ 0x06, \"xmlns='http://www.wireless-village.org/PA'\" },\n\t{ 0x07, \"xmlns='http://www.wireless-village.org/TRC'\" },\n\n\t{ 0x00, NULL }\n};\n\n/*\n * Attribute value tokens\n */\n/* Common value tokens (0x00) */\nstatic const value_string wbxml_wv_csp_10_attrValue_cp0[] = {\n\t/* 0x80 -- 0x84 GLOBAL */\n\t{ 0x85, \"AccessType\" },\n\t{ 0x86, \"ActiveUsers\" },\n\t{ 0x87, \"Admin\" },\n\t{ 0x88, \"application/\" },\n\t{ 0x89, \"application/vnd.wap.mms-message\" },\n\t{ 0x8A, \"application/x-sms\" },\n\t{ 0x8B, \"BASE64\" },\n\t{ 0x8C, \"Closed\" },\n\t{ 0x8D, \"Default\" },\n\t{ 0x8E, \"DisplayName\" },\n\t{ 0x8F, \"False (No)\" },\n\t{ 0x90, \"Get\" },\n\t{ 0x91, \"Group (GR)\" },\n\t{ 0x92, \"http://\" },\n\t{ 0x93, \"https://\" },\n\t{ 0x94, \"image/\" },\n\t{ 0x95, \"Inband\" },\n\t{ 0x96, \"Instant Messaging (IM)\" },\n\t{ 0x97, \"MaxActiveUsers\" },\n\t{ 0x98, \"Mod\" },\n\t{ 0x99, \"Name\" },\n\t{ 0x9A, \"None\" },\n\t{ 0x9B, \"Notify/Get\" },\n\t{ 0x9C, \"Open\" },\n\t{ 0x9D, \"Outband\" },\n\t{ 0x9E, \"Presence (PR)\" },\n\t{ 0x9F, \"Private\" },\n\t{ 0xA0, \"PrivateMessaging\" },\n\t{ 0xA1, \"PrivilegeLevel\" },\n\t{ 0xA2, \"Public\" },\n\t{ 0xA3, \"Push\" },\n\t{ 0xA4, \"Request\" },\n\t{ 0xA5, \"Response\" },\n\t{ 0xA6, \"ScreenName\" },\n\t{ 0xA7, \"Searchable\" },\n\t{ 0xA8, \"Set\" },\n\t{ 0xA9, \"Shared Content (SC)\" },\n\t{ 0xAA, \"text/\" },\n\t{ 0xAB, \"text/plain\" },\n\t{ 0xAC, \"text/x-vCalendar\" },\n\t{ 0xAD, \"text/x-vCard\" },\n\t{ 0xAE, \"Topic\" },\n\t{ 0xAF, \"True (Yes)\" },\n\t{ 0xB0, \"Type\" },\n\t{ 0xB1, \"Unset\" },\n\t{ 0xB2, \"User (US)\" },\n\t{ 0xB3, \"www.wireless-village.org\" },\n\n\t{ 0x00, NULL }\n};\n\n/* Access value tokens (0x01) */\nstatic const value_string wbxml_wv_csp_10_attrValue_cp1[] = {\n\t/* 0x80 -- 0x84 GLOBAL */\n\t{ 0x85, \"GROUP_ID\" },\n\t{ 0x86, \"GROUP_NAME\" },\n\t{ 0x87, \"GROUP_TOPIC\" },\n\t{ 0x88, \"GROUP_USER_ID_JOINED\" },\n\t{ 0x89, \"HTTP\" },\n\t{ 0x8A, \"SMS\" },\n\t{ 0x8B, \"STCP\" },\n\t{ 0x8C, \"SUDP\" },\n\t{ 0x8D, \"USER_ALIAS\" },\n\t{ 0x8E, \"USER_EMAIL_ADDRESS\" },\n\t{ 0x8F, \"USER_FIRST_NAME\" },\n\t{ 0x90, \"USER_ID\" },\n\t{ 0x91, \"USER_LAST_NAME\" },\n\t{ 0x92, \"USER_MOBILE_NUMBER\" },\n\t{ 0x93, \"WAPSMS\" },\n\t{ 0x94, \"WAPUDP\" },\n\t{ 0x95, \"WSP\" },\n\n\t{ 0x00, NULL }\n};\n\n/* Presence value tokens (0x05) */\nstatic const value_string wbxml_wv_csp_10_attrValue_cp5[] = {\n\t/* 0x80 -- 0x84 GLOBAL */\n\t{ 0x85, \"ANGRY\" },\n\t{ 0x86, \"ANXIOUS\" },\n\t{ 0x87, \"ASHAMED\" },\n\t{ 0x88, \"AUDIO_CALL\" },\n\t{ 0x89, \"AVAILABLE\" },\n\t{ 0x8A, \"BORED\" },\n\t{ 0x8B, \"CALL\" },\n\t{ 0x8C, \"CLI\" },\n\t{ 0x8D, \"COMPUTER\" },\n\t{ 0x8E, \"DISCREET\" },\n\t{ 0x8F, \"EMAIL\" },\n\t{ 0x90, \"EXCITED\" },\n\t{ 0x91, \"HAPPY\" },\n\t{ 0x92, \"IM\" },\n\t{ 0x93, \"IM_OFFLINE\" },\n\t{ 0x94, \"IM_ONLINE\" },\n\t{ 0x95, \"IN_LOVE\" },\n\t{ 0x96, \"INVINCIBLE\" },\n\t{ 0x97, \"JEALOUS\" },\n\t{ 0x98, \"MMS\" },\n\t{ 0x99, \"MOBILE_PHONE\" },\n\t{ 0x9A, \"NOT_AVAILABLE\" },\n\t{ 0x9B, \"OTHER\" },\n\t{ 0x9C, \"PDA\" },\n\t{ 0x9D, \"SAD\" },\n\t{ 0x9E, \"SLEEPY\" },\n\t{ 0x9F, \"SMS\" },\n\t{ 0xA0, \"VIDEO_CALL\" },\n\t{ 0xA1, \"VIDEO_STREAM\" },\n\n\t{ 0x00, NULL }\n};\n\n\n/***** Token code page aggregation *****/\nstatic const value_valuestring wbxml_wv_csp_10_tags[] = {\n\t{ 0, wbxml_wv_csp_10_tags_cp0 },\n\t{ 1, wbxml_wv_csp_10_tags_cp1 },\n\t{ 2, wbxml_wv_csp_10_tags_cp2 },\n\t{ 3, wbxml_wv_csp_10_tags_cp3 },\n\t{ 4, wbxml_wv_csp_10_tags_cp4 },\n\t{ 5, wbxml_wv_csp_10_tags_cp5 },\n\t{ 6, wbxml_wv_csp_10_tags_cp6 },\n\t{ 7, wbxml_wv_csp_10_tags_cp7 },\n\t{ 0, NULL }\n};\n\nstatic const value_valuestring wbxml_wv_csp_10_attrStart[] = {\n\t{ 0, wbxml_wv_csp_10_attrStart_cp0 },\n\t{ 0, NULL }\n};\n\nstatic const value_valuestring wbxml_wv_csp_10_attrValue[] = {\n\t{ 0, wbxml_wv_csp_10_attrValue_cp0 },\n\t{ 1, wbxml_wv_csp_10_attrValue_cp1 },\n\t{ 5, wbxml_wv_csp_10_attrValue_cp5 },\n\t{ 0, NULL }\n};\n\nstatic const wbxml_decoding decode_wv_cspc_10 = {\n\t\"Wireless-Village Client-Server Protocol 1.0\",\n\t\"WV-CSP 1.0\",\n\t{ NULL, NULL, NULL },\n\twv_csp10_opaque_binary_tag,\n\twv_csp10_opaque_literal_tag,\n\tdefault_opaque_binary_attr,\n\tdefault_opaque_literal_attr,\n\tNULL,\n\twbxml_wv_csp_10_tags,\n\twbxml_wv_csp_10_attrStart,\n\twbxml_wv_csp_10_attrValue\n};\n\n\n\n\n\n/* WV-CSP 1.1\n *\n * Wireless Village Client Server Protocol\n ***************************************/\n\n/*****   Global extension tokens   *****/\nstatic const value_string wbxml_wv_csp_11_global_cp0[] = {\n\t{ 0x80, \"Common Value\" }, /* EXT_T_0 */\n\n\t{ 0x00, NULL }\n};\n\n/*****         Tag tokens          *****/\n/* Common code page */\nstatic const value_string wbxml_wv_csp_11_tags_cp0[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"Acceptance\" },\n\t{ 0x06, \"AddList\" },\n\t{ 0x07, \"AddNickList\" },\n\t{ 0x08, \"SName\" },\t\t/* Was: Attribute */\n\t{ 0x09, \"WV-CSP-Message\" },\t/* Was: AttributeList */\n\t{ 0x0A, \"ClientID\" },\n\t{ 0x0B, \"Code\" },\n\t{ 0x0C, \"ContactList\" },\n\t{ 0x0D, \"ContentData\" },\n\t{ 0x0E, \"ContentEncoding\" },\n\t{ 0x0F, \"ContentSize\" },\n\t{ 0x10, \"ContentType\" },\n\t{ 0x11, \"DateTime\" },\n\t{ 0x12, \"Description\" },\n\t{ 0x13, \"DetailedResult\" },\n\t{ 0x14, \"EntityList\" },\n\t{ 0x15, \"Group\" },\n\t{ 0x16, \"GroupID\" },\n\t{ 0x17, \"GroupList\" },\n\t{ 0x18, \"InUse\" },\n\t{ 0x19, \"Logo\" },\n\t{ 0x1A, \"MessageCount\" },\n\t{ 0x1B, \"MessageID\" },\n\t{ 0x1C, \"MessageURI\" },\n\t{ 0x1D, \"MSISDN\" },\n\t{ 0x1E, \"Name\" },\n\t{ 0x1F, \"NickList\" },\n\t{ 0x20, \"NickName\" },\n\t{ 0x21, \"Poll\" },\n\t{ 0x22, \"Presence\" },\n\t{ 0x23, \"PresenceSubList\" },\n\t{ 0x24, \"PresenceValue\" },\n\t{ 0x25, \"Property\" },\n\t{ 0x26, \"Qualifier\" },\n\t{ 0x27, \"Recipient\" },\n\t{ 0x28, \"RemoveList\" },\n\t{ 0x29, \"RemoveNickList\" },\n\t{ 0x2A, \"Result\" },\n\t{ 0x2B, \"ScreenName\" },\n\t{ 0x2C, \"Sender\" },\n\t{ 0x2D, \"Session\" },\n\t{ 0x2E, \"SessionDescriptor\" },\n\t{ 0x2F, \"SessionID\" },\n\t{ 0x30, \"SessionType\" },\n\t{ 0x31, \"Status\" },\n\t{ 0x32, \"Transaction\" },\n\t{ 0x33, \"TransactionContent\" },\n\t{ 0x34, \"TransactionDescriptor\" },\n\t{ 0x35, \"TransactionID\" },\n\t{ 0x36, \"TransactionMode\" },\n\t{ 0x37, \"URL\" },\n\t{ 0x38, \"URLList\" },\n\t{ 0x39, \"User\" },\n\t{ 0x3A, \"UserID\" },\n\t{ 0x3B, \"UserList\" },\n\t{ 0x3C, \"Validity\" },\n\t{ 0x3D, \"Value\" },\n\t/* 0x3E - Removed: WV-CSP-Message */\n\n\t{ 0x00, NULL }\n};\n\n/* Access code page */\nstatic const value_string wbxml_wv_csp_11_tags_cp1[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"AllFunctions\" },\n\t{ 0x06, \"AllFunctionsRequest\" },\n\t{ 0x07, \"CancelInvite-Request\" },\n\t{ 0x08, \"CancelInviteUser-Request\" },\n\t{ 0x09, \"Capability\" },\n\t{ 0x0A, \"CapabilityList\" },\n\t{ 0x0B, \"CapabilityRequest\" },\n\t{ 0x0C, \"ClientCapability-Request\" },\n\t{ 0x0D, \"ClientCapability-Response\" },\n\t{ 0x0E, \"DigestBytes\" },\n\t{ 0x0F, \"DigestSchema\" },\n\t{ 0x10, \"Disconnect\" },\n\t{ 0x11, \"Functions\" },\n\t{ 0x12, \"GetSPInfo-Request\" },\n\t{ 0x13, \"GetSPInfo-Response\" },\n\t{ 0x14, \"InviteID\" },\n\t{ 0x15, \"InviteNote\" },\n\t{ 0x16, \"Invite-Request\" },\n\t{ 0x17, \"Invite-Response\" },\n\t{ 0x18, \"InviteType\" },\n\t{ 0x19, \"InviteUser-Request\" },\n\t{ 0x1A, \"InviteUser-Response\" },\n\t{ 0x1B, \"KeepAlive-Request\" },\n\t{ 0x1C, \"KeepAliveTime\" },\n\t{ 0x1D, \"Login-Request\" },\n\t{ 0x1E, \"Login-Response\" },\n\t{ 0x1F, \"Logout-Request\" },\n\t{ 0x20, \"Nonce\" },\n\t{ 0x21, \"Password\" },\n\t{ 0x22, \"Polling-Request\" },\n\t{ 0x23, \"ResponseNote\" },\n\t{ 0x24, \"SearchElement\" },\n\t{ 0x25, \"SearchFindings\" },\n\t{ 0x26, \"SearchID\" },\n\t{ 0x27, \"SearchIndex\" },\n\t{ 0x28, \"SearchLimit\" },\n\t{ 0x29, \"KeepAlive-Response\" },\n\t{ 0x2A, \"SearchPairList\" },\n\t{ 0x2B, \"Search-Request\" },\n\t{ 0x2C, \"Search-Response\" },\n\t{ 0x2D, \"SearchResult\" },\n\t{ 0x2E, \"Service-Request\" },\n\t{ 0x2F, \"Service-Response\" },\n\t{ 0x30, \"SessionCookie\" },\n\t{ 0x31, \"StopSearch-Request\" },\n\t{ 0x32, \"TimeToLive\" },\n\t/* New in WV-CSP 1.1 */\n\t{ 0x33, \"SearchString\" },\n\t{ 0x34, \"CompletionFlag\" },\n\n\t{ 0x00, NULL }\n};\n\n/* Service code page */\n/* Same as cp2 of WV-CSP 1.0 */\n#define wbxml_wv_csp_11_tags_cp2 wbxml_wv_csp_10_tags_cp2\n\n/* Client capability code page */\nstatic const value_string wbxml_wv_csp_11_tags_cp3[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"AcceptedCharset\" },\n\t{ 0x06, \"AcceptedContentLength\" },\n\t{ 0x07, \"AcceptedContentType\" },\n\t{ 0x08, \"AcceptedTransferEncoding\" },\n\t{ 0x09, \"AnyContent\" },\n\t{ 0x0A, \"DefaultLanguage\" },\t/* Was: ClientType */\n\t{ 0x0B, \"InitialDeliveryMethod\" },\n\t{ 0x0C, \"MultiTrans\" },\n\t{ 0x0D, \"ParserSize\" },\n\t{ 0x0E, \"ServerPollMin\" },\n\t{ 0x0F, \"SupportedBearer\" },\n\t{ 0x10, \"SupportedCIRMethod\" },\n\t{ 0x11, \"TCPAddress\" },\n\t{ 0x12, \"TCPPort\" },\n\t{ 0x13, \"UDPPort\" },\n\n\t{ 0x00, NULL }\n};\n\n/* Presence primitive code page */\nstatic const value_string wbxml_wv_csp_11_tags_cp4[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"CancelAuth-Request\" },\n\t{ 0x06, \"ContactListProperties\" },\n\t{ 0x07, \"CreateAttributeList-Request\" },\n\t{ 0x08, \"CreateList-Request\" },\n\t{ 0x09, \"DefaultAttributeList\" },\n\t{ 0x0A, \"DefaultContactList\" },\n\t{ 0x0B, \"DefaultList\" },\n\t{ 0x0C, \"DeleteAttributeList-Request\" },\n\t{ 0x0D, \"DeleteList-Request\" },\n\t{ 0x0E, \"GetAttributeList-Request\" },\n\t{ 0x0F, \"GetAttributeList-Response\" },\n\t{ 0x10, \"GetList-Request\" },\n\t{ 0x11, \"GetList-Response\" },\n\t{ 0x12, \"GetPresence-Request\" },\n\t{ 0x13, \"GetPresence-Response\" },\n\t{ 0x14, \"GetWatcherList-Request\" },\n\t{ 0x15, \"GetWatcherList-Response\" },\n\t{ 0x16, \"ListManage-Request\" },\n\t{ 0x17, \"ListManage-Response\" },\n\t{ 0x18, \"UnsubscribePresence-Request\" },\t/* Was: Presence */\n\t{ 0x19, \"PresenceAuth-Request\" },\n\t{ 0x1A, \"PresenceAuth-User\" },\t\t/* Was: PresenceAuth-Response */\n\t{ 0x1B, \"PresenceNotification-Request\" },\n\t{ 0x1C, \"UpdatePresence-Request\" },\t/* Was: PresenceValueList */\n\t{ 0x1D, \"SubscribePresence-Request\" },\n\t/* 0x1E - Removed: UnsubscribePresence-Request */\n\t/* 0x1F - Removed: UpdatePresence-Request */\n\n\t{ 0x00, NULL }\n};\n\n/* Presence attribute code page */\nstatic const value_string wbxml_wv_csp_11_tags_cp5[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"Accuracy\" },\n\t{ 0x06, \"Address\" },\n\t{ 0x07, \"AddrPref\" },\n\t{ 0x08, \"Alias\" },\n\t{ 0x09, \"Altitude\" },\n\t{ 0x0A, \"Building\" },\n\t{ 0x0B, \"Caddr\" },\n\t{ 0x0C, \"City\" },\n\t{ 0x0D, \"ClientInfo\" },\n\t{ 0x0E, \"ClientProducer\" },\n\t{ 0x0F, \"ClientType\" },\n\t{ 0x10, \"ClientVersion\" },\n\t{ 0x11, \"CommC\" },\n\t{ 0x12, \"CommCap\" },\n\t{ 0x13, \"ContactInfo\" },\n\t{ 0x14, \"ContainedvCard\" },\n\t{ 0x15, \"Country\" },\n\t{ 0x16, \"Crossing1\" },\n\t{ 0x17, \"Crossing2\" },\n\t{ 0x18, \"DevManufacturer\" },\n\t{ 0x19, \"DirectContent\" },\n\t{ 0x1A, \"FreeTextLocation\" },\n\t{ 0x1B, \"GeoLocation\" },\n\t{ 0x1C, \"Language\" },\n\t{ 0x1D, \"Latitude\" },\n\t{ 0x1E, \"Longitude\" },\n\t{ 0x1F, \"Model\" },\n\t{ 0x20, \"NamedArea\" },\n\t{ 0x21, \"OnlineStatus\" },\n\t{ 0x22, \"PLMN\" },\n\t{ 0x23, \"PrefC\" },\n\t{ 0x24, \"PreferredContacts\" },\n\t{ 0x25, \"PreferredLanguage\" },\n\t{ 0x26, \"ReferredContent\" },\n\t{ 0x27, \"ReferredvCard\" },\n\t{ 0x28, \"Registration\" },\n\t{ 0x29, \"StatusContent\" },\n\t{ 0x2A, \"StatusMood\" },\n\t{ 0x2B, \"StatusText\" },\n\t{ 0x2C, \"Street\" },\n\t{ 0x2D, \"TimeZone\" },\n\t{ 0x2E, \"UserAvailability\" },\n\t/* New in WV-CSP 1.1 */\n\t{ 0x2F, \"Cap\" },\n\t{ 0x30, \"Cname\" },\n\t{ 0x31, \"Contact\" },\n\t{ 0x32, \"Cpriority\" },\n\t{ 0x33, \"Cstatus\" },\n\t{ 0x34, \"Note\" },\n\t{ 0x35, \"Zone\" },\n\n\t{ 0x00, NULL }\n};\n\n/* Messaging code page */\nstatic const value_string wbxml_wv_csp_11_tags_cp6[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"BlockList\" },\n\t{ 0x06, \"BlockUser-Request\" },\n\t{ 0x07, \"DeliveryMethod\" },\n\t{ 0x08, \"DeliveryReport\" },\n\t{ 0x09, \"DeliveryReport-Request\" },\n\t{ 0x0A, \"ForwardMessage-Request\" },\n\t{ 0x0B, \"GetBlockedList-Request\" },\n\t{ 0x0C, \"GetBlockedList-Response\" },\n\t{ 0x0D, \"GetMessageList-Request\" },\n\t{ 0x0E, \"GetMessageList-Response\" },\n\t{ 0x0F, \"GetMessage-Request\" },\n\t{ 0x10, \"GetMessage-Response\" },\n\t{ 0x11, \"GrantList\" },\n\t{ 0x12, \"MessageDelivered\" },\n\t{ 0x13, \"MessageInfo\" },\n\t{ 0x14, \"MessageNotification\" },\n\t{ 0x15, \"NewMessage\" },\n\t{ 0x16, \"RejectMessage-Request\" },\n\t{ 0x17, \"SendMessage-Request\" },\n\t{ 0x18, \"SendMessage-Response\" },\n\t{ 0x19, \"SetDeliveryMethod-Request\" },\n\t/* New in WV-CSP 1.1 */\n\t{ 0x1A, \"DeliveryTime\" },\n\n\t{ 0x00, NULL }\n};\n\n/* Group code page */\nstatic const value_string wbxml_wv_csp_11_tags_cp7[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"AddGroupMembers-Request\" },\n\t{ 0x06, \"Admin\" },\n\t{ 0x07, \"CreateGroup-Request\" },\n\t{ 0x08, \"DeleteGroup-Request\" },\n\t{ 0x09, \"GetGroupMembers-Request\" },\n\t{ 0x0A, \"GetGroupMembers-Response\" },\n\t{ 0x0B, \"GetGroupProps-Request\" },\n\t{ 0x0C, \"GetGroupProps-Response\" },\n\t{ 0x0D, \"GroupChangeNotice\" },\n\t{ 0x0E, \"GroupProperties\" },\n\t{ 0x0F, \"Joined\" },\n\t{ 0x10, \"JoinedRequest\" },\n\t{ 0x11, \"JoinGroup-Request\" },\n\t{ 0x12, \"JoinGroup-Response\" },\n\t{ 0x13, \"LeaveGroup-Request\" },\n\t{ 0x14, \"LeaveGroup-Response\" },\n\t{ 0x15, \"Left\" },\n\t{ 0x16, \"MemberAccess-Request\" },\n\t{ 0x17, \"Mod\" },\n\t{ 0x18, \"OwnProperties\" },\n\t{ 0x19, \"RejectList-Request\" },\n\t{ 0x1A, \"RejectList-Response\" },\n\t{ 0x1B, \"RemoveGroupMembers-Request\" },\n\t{ 0x1C, \"SetGroupProps-Request\" },\n\t{ 0x1D, \"SubscribeGroupNotice-Request\" },\n\t{ 0x1E, \"SubscribeGroupNotice-Response\" },\n\t{ 0x1F, \"Users\" },\n\t{ 0x20, \"WelcomeNote\" },\n\t/* New in WV-CSP 1.1 */\n\t{ 0x21, \"JoinGroup\" },\n\t{ 0x22, \"SubscribeNotification\" },\n\t{ 0x23, \"SubscribeType\" },\n\n\t{ 0x00, NULL }\n};\n\n/*****    Attribute Start tokens   *****/\n/* Common code page */\n/* Same as cp0 of WV-CSP 1.0 */\n#define wbxml_wv_csp_11_attrStart_cp0 wbxml_wv_csp_10_attrStart_cp0\n\n/*****    Attribute Value tokens   *****/\n/*\n * Element value tokens\n *\n * NOTE - WV-CSP uses the EXT_T_0 token in a peculiar way: the mb_u_int32\n * does *not* reference an offset in the string table, but it refers to\n * the index in the following value_string.\n *\n * Please note that:\n *  - Values 'T' and 'F' are Boolean values representing \"True\" and \"False\"\n *    (or \"Yes\" and \"No\" in some circumstances) respectively.\n *  - Values 'GR', 'IM', 'PR', 'SC', 'GM' and 'US' are enumerated values\n *    representing \"Group\", \"Instant Messaging\", \"Presence\", \"Shared Content\",\n *    \"Group membership\" and \"User\" respectively.\n *  - Values 'G', 'S' and 'U' are enumerated values representing \"Get\", \"Set\"\n *    and \"Unset\" respectively.\n *  - Values 'N' and 'P' are enumerated values representing \"Notify/Get\" and\n *    \"Push\" respectively.\n *\n * I repeat: this is NOT a attrValue[] array hence it is not called\n * wbxml_wv_XXX but vals_wv_XXX.\n *\n * Result: the attribute value token definitions from WV-CSP 1.0 are dropped.\n */\nstatic const value_string vals_wv_csp_11_element_value_tokens[] = {\n\t/*\n\t * Common value tokens\n\t */\n\t{ 0x00, \"AccessType\" },\n\t{ 0x01, \"ActiveUsers\" },\n\t{ 0x02, \"Admin\" },\n\t{ 0x03, \"application/\" },\n\t{ 0x04, \"application/vnd.wap.mms-message\" },\n\t{ 0x05, \"application/x-sms\" },\n\t{ 0x06, \"AutoJoin\" },\n\t{ 0x07, \"BASE64\" },\n\t{ 0x08, \"Closed\" },\n\t{ 0x09, \"Default\" },\n\t{ 0x0A, \"DisplayName\" },\n\t{ 0x0B, \"F\" },\n\t{ 0x0C, \"G\" },\n\t{ 0x0D, \"GR\" },\n\t{ 0x0E, \"http://\" },\n\t{ 0x0F, \"https://\" },\n\t{ 0x10, \"image/\" },\n\t{ 0x11, \"Inband\" },\n\t{ 0x12, \"IM\" },\n\t{ 0x13, \"MaxActiveUsers\" },\n\t{ 0x14, \"Mod\" },\n\t{ 0x15, \"Name\" },\n\t{ 0x16, \"None\" },\n\t{ 0x17, \"N\" },\n\t{ 0x18, \"Open\" },\n\t{ 0x19, \"Outband\" },\n\t{ 0x1A, \"PR\" },\n\t{ 0x1B, \"Private\" },\n\t{ 0x1C, \"PrivateMessaging\" },\n\t{ 0x1D, \"PrivilegeLevel\" },\n\t{ 0x1E, \"Public\" },\n\t{ 0x1F, \"P\" },\n\t{ 0x20, \"Request\" },\n\t{ 0x21, \"Response\" },\n\t{ 0x22, \"Restricted\" },\n\t{ 0x23, \"ScreenName\" },\n\t{ 0x24, \"Searchable\" },\n\t{ 0x25, \"S\" },\n\t{ 0x26, \"SC\" },\n\t{ 0x27, \"text/\" },\n\t{ 0x28, \"text/plain\" },\n\t{ 0x29, \"text/x-vCalendar\" },\n\t{ 0x2A, \"text/x-vCard\" },\n\t{ 0x2B, \"Topic\" },\n\t{ 0x2C, \"T\" },\n\t{ 0x2D, \"Type\" },\n\t{ 0x2E, \"U\" },\n\t{ 0x2F, \"US\" },\n\t{ 0x30, \"www.wireless-village.org\" },\n\t/*\n\t * Access value tokens\n\t */\n\t{ 0x3D, \"GROUP_ID\" },\n\t{ 0x3E, \"GROUP_NAME\" },\n\t{ 0x3F, \"GROUP_TOPIC\" },\n\t{ 0x40, \"GROUP_USER_ID_JOINED\" },\n\t{ 0x41, \"GROUP_USER_ID_OWNER\" },\n\t{ 0x42, \"HTTP\" },\n\t{ 0x43, \"SMS\" },\n\t{ 0x44, \"STCP\" },\n\t{ 0x45, \"SUDP\" },\n\t{ 0x46, \"USER_ALIAS\" },\n\t{ 0x47, \"USER_EMAIL_ADDRESS\" },\n\t{ 0x48, \"USER_FIRST_NAME\" },\n\t{ 0x49, \"USER_ID\" },\n\t{ 0x4A, \"USER_LAST_NAME\" },\n\t{ 0x4B, \"USER_MOBILE_NUMBER\" },\n\t{ 0x4C, \"USER_ONLINE_STATUS\" },\n\t{ 0x4D, \"WAPSMS\" },\n\t{ 0x4E, \"WAPUDP\" },\n\t{ 0x4F, \"WSP\" },\n\t/*\n\t * Presence value tokens\n\t */\n\t{ 0x5B, \"ANGRY\" },\n\t{ 0x5C, \"ANXIOUS\" },\n\t{ 0x5D, \"ASHAMED\" },\n\t{ 0x5E, \"AUDIO_CALL\" },\n\t{ 0x5F, \"AVAILABLE\" },\n\t{ 0x60, \"BORED\" },\n\t{ 0x61, \"CALL\" },\n\t{ 0x62, \"CLI\" },\n\t{ 0x63, \"COMPUTER\" },\n\t{ 0x64, \"DISCREET\" },\n\t{ 0x65, \"EMAIL\" },\n\t{ 0x66, \"EXCITED\" },\n\t{ 0x67, \"HAPPY\" },\n\t{ 0x68, \"IM\" },\n\t{ 0x69, \"IM_OFFLINE\" },\n\t{ 0x6A, \"IM_ONLINE\" },\n\t{ 0x6B, \"IN_LOVE\" },\n\t{ 0x6C, \"INVINCIBLE\" },\n\t{ 0x6D, \"JEALOUS\" },\n\t{ 0x6E, \"MMS\" },\n\t{ 0x6F, \"MOBILE_PHONE\" },\n\t{ 0x70, \"NOT_AVAILABLE\" },\n\t{ 0x71, \"OTHER\" },\n\t{ 0x72, \"PDA\" },\n\t{ 0x73, \"SAD\" },\n\t{ 0x74, \"SLEEPY\" },\n\t{ 0x75, \"SMS\" },\n\t{ 0x76, \"VIDEO_CALL\" },\n\t{ 0x77, \"VIDEO_STREAM\" },\n\n\t{ 0x00, NULL }\n};\nstatic value_string_ext vals_wv_csp_11_element_value_tokens_ext = VALUE_STRING_EXT_INIT(vals_wv_csp_11_element_value_tokens);\n\n\n/***** Token code page aggregation *****/\n\nstatic char *\next_t_0_wv_cspc_11(wmem_allocator_t* allocator, tvbuff_t *tvb _U_, uint32_t value, uint32_t str_tbl _U_)\n{\n\tchar *str = wmem_strdup_printf(allocator, \"Common Value: '%s'\",\n\t\t\t\t    val_to_str_ext(allocator, value, &vals_wv_csp_11_element_value_tokens_ext,\n\t\t\t\t\t       \"<Unknown WV-CSP 1.1 Common Value token 0x%X>\"));\n\treturn str;\n}\n\nstatic const value_valuestring wbxml_wv_csp_11_global[] = {\n\t{ 0, wbxml_wv_csp_11_global_cp0 },\n\t{ 0, NULL }\n};\n\nstatic const value_valuestring wbxml_wv_csp_11_tags[] = {\n\t{ 0, wbxml_wv_csp_11_tags_cp0 },\n\t{ 1, wbxml_wv_csp_11_tags_cp1 },\n\t{ 2, wbxml_wv_csp_11_tags_cp2 },\n\t{ 3, wbxml_wv_csp_11_tags_cp3 },\n\t{ 4, wbxml_wv_csp_11_tags_cp4 },\n\t{ 5, wbxml_wv_csp_11_tags_cp5 },\n\t{ 6, wbxml_wv_csp_11_tags_cp6 },\n\t{ 7, wbxml_wv_csp_11_tags_cp7 },\n\t{ 0, NULL }\n};\n\nstatic const value_valuestring wbxml_wv_csp_11_attrStart[] = {\n\t{ 0, wbxml_wv_csp_11_attrStart_cp0 },\n\t{ 0, NULL }\n};\n\nstatic const wbxml_decoding decode_wv_cspc_11 = {\n\t\"Wireless-Village Client-Server Protocol 1.1\",\n\t\"WV-CSP 1.1\",\n\t{ ext_t_0_wv_cspc_11, NULL, NULL },\n\twv_csp11_opaque_binary_tag,\n\twv_csp11_opaque_literal_tag,\n\tdefault_opaque_binary_attr,\n\tdefault_opaque_literal_attr,\n\twbxml_wv_csp_11_global,\n\twbxml_wv_csp_11_tags,\n\twbxml_wv_csp_11_attrStart,\n\tNULL\n};\n\n\n\n\n\n/* WV-CSP 1.2\n *\n * Wireless Village Client Server Protocol\n ***************************************/\n\n/*****   Global extension tokens   *****/\n/* Same as WV-CSP 1.1 */\n\n/*****         Tag tokens          *****/\n/* Common code page */\n/* Same as cp0 of WV-CSP 1.1 */\n#define wbxml_wv_csp_12_tags_cp0 wbxml_wv_csp_11_tags_cp0\n/* Note that the table continues in code page 0x09 */\n\n/* Access code page (0x01) */\nstatic const value_string wbxml_wv_csp_12_tags_cp1[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"AllFunctions\" },\n\t{ 0x06, \"AllFunctionsRequest\" },\n\t{ 0x07, \"CancelInvite-Request\" },\n\t{ 0x08, \"CancelInviteUser-Request\" },\n\t{ 0x09, \"Capability\" },\n\t{ 0x0A, \"CapabilityList\" },\n\t{ 0x0B, \"CapabilityRequest\" },\n\t{ 0x0C, \"ClientCapability-Request\" },\n\t{ 0x0D, \"ClientCapability-Response\" },\n\t{ 0x0E, \"DigestBytes\" },\n\t{ 0x0F, \"DigestSchema\" },\n\t{ 0x10, \"Disconnect\" },\n\t{ 0x11, \"Functions\" },\n\t{ 0x12, \"GetSPInfo-Request\" },\n\t{ 0x13, \"GetSPInfo-Response\" },\n\t{ 0x14, \"InviteID\" },\n\t{ 0x15, \"InviteNote\" },\n\t{ 0x16, \"Invite-Request\" },\n\t{ 0x17, \"Invite-Response\" },\n\t{ 0x18, \"InviteType\" },\n\t{ 0x19, \"InviteUser-Request\" },\n\t{ 0x1A, \"InviteUser-Response\" },\n\t{ 0x1B, \"KeepAlive-Request\" },\n\t{ 0x1C, \"KeepAliveTime\" },\n\t{ 0x1D, \"Login-Request\" },\n\t{ 0x1E, \"Login-Response\" },\n\t{ 0x1F, \"Logout-Request\" },\n\t{ 0x20, \"Nonce\" },\n\t{ 0x21, \"Password\" },\n\t{ 0x22, \"Polling-Request\" },\n\t{ 0x23, \"ResponseNote\" },\n\t{ 0x24, \"SearchElement\" },\n\t{ 0x25, \"SearchFindings\" },\n\t{ 0x26, \"SearchID\" },\n\t{ 0x27, \"SearchIndex\" },\n\t{ 0x28, \"SearchLimit\" },\n\t{ 0x29, \"KeepAlive-Response\" },\n\t{ 0x2A, \"SearchPairList\" },\n\t{ 0x2B, \"Search-Request\" },\n\t{ 0x2C, \"Search-Response\" },\n\t{ 0x2D, \"SearchResult\" },\n\t{ 0x2E, \"Service-Request\" },\n\t{ 0x2F, \"Service-Response\" },\n\t{ 0x30, \"SessionCookie\" },\n\t{ 0x31, \"StopSearch-Request\" },\n\t{ 0x32, \"TimeToLive\" },\n\t/* New in WV-CSP 1.1 */\n\t{ 0x33, \"SearchString\" },\n\t{ 0x34, \"CompletionFlag\" },\n\t/* New in WV-CSP 1.2 */\n\t{ 0x36, \"ReceiveList\" },\n\t{ 0x37, \"VerifyID-Request\" },\n\t{ 0x38, \"Extended-Request\" },\n\t{ 0x39, \"Extended-Response\" },\n\t{ 0x3A, \"AgreedCapabilityList\" },\n\t{ 0x3B, \"ExtendedData\" },\n\t{ 0x3C, \"OtherServer\" },\n\t{ 0x3D, \"PresenceAttributeNSName\" },\n\t{ 0x3E, \"SessionNSName\" },\n\t{ 0x3F, \"TransactionNSName\" },\n\n\t{ 0x00, NULL }\n};\n/* Note that the table continues in code page 0x0A */\n\n/* Service code page (0x02) */\nstatic const value_string wbxml_wv_csp_12_tags_cp2[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"ADDGM\" },\n\t{ 0x06, \"AttListFunc\" },\n\t{ 0x07, \"BLENT\" },\n\t{ 0x08, \"CAAUT\" },\n\t{ 0x09, \"CAINV\" },\n\t{ 0x0A, \"CALI\" },\n\t{ 0x0B, \"CCLI\" },\n\t{ 0x0C, \"ContListFunc\" },\n\t{ 0x0D, \"CREAG\" },\n\t{ 0x0E, \"DALI\" },\n\t{ 0x0F, \"DCLI\" },\n\t{ 0x10, \"DELGR\" },\n\t{ 0x11, \"FundamentalFeat\" },\n\t{ 0x12, \"FWMSG\" },\n\t{ 0x13, \"GALS\" },\n\t{ 0x14, \"GCLI\" },\n\t{ 0x15, \"GETGM\" },\n\t{ 0x16, \"GETGP\" },\n\t{ 0x17, \"GETLM\" },\n\t{ 0x18, \"GETM\" },\n\t{ 0x19, \"GETPR\" },\n\t{ 0x1A, \"GETSPI\" },\n\t{ 0x1B, \"GETWL\" },\n\t{ 0x1C, \"GLBLU\" },\n\t{ 0x1D, \"GRCHN\" },\n\t{ 0x1E, \"GroupAuthFunc\" },\n\t{ 0x1F, \"GroupFeat\" },\n\t{ 0x20, \"GroupMgmtFunc\" },\n\t{ 0x21, \"GroupUseFunc\" },\n\t{ 0x22, \"IMAuthFunc\" },\n\t{ 0x23, \"IMFeat\" },\n\t{ 0x24, \"IMReceiveFunc\" },\n\t{ 0x25, \"IMSendFunc\" },\n\t{ 0x26, \"INVIT\" },\n\t{ 0x27, \"InviteFunc\" },\n\t{ 0x28, \"MBRAC\" },\n\t{ 0x29, \"MCLS\" },\n\t{ 0x2A, \"MDELIV\" },\n\t{ 0x2B, \"NEWM\" },\n\t{ 0x2C, \"NOTIF\" },\n\t{ 0x2D, \"PresenceAuthFunc\" },\n\t{ 0x2E, \"PresenceDeliverFunc\" },\n\t{ 0x2F, \"PresenceFeat\" },\n\t{ 0x30, \"REACT\" },\n\t{ 0x31, \"REJCM\" },\n\t{ 0x32, \"REJEC\" },\n\t{ 0x33, \"RMVGM\" },\n\t{ 0x34, \"SearchFunc\" },\n\t{ 0x35, \"ServiceFunc\" },\n\t{ 0x36, \"SETD\" },\n\t{ 0x37, \"SETGP\" },\n\t{ 0x38, \"SRCH\" },\n\t{ 0x39, \"STSRC\" },\n\t{ 0x3A, \"SUBGCN\" },\n\t{ 0x3B, \"UPDPR\" },\n\t{ 0x3C, \"WVCSPFeat\" },\n\t/* New in WV-CSP 1.2 */\n\t{ 0x3D, \"MF\" },\n\t{ 0x3E, \"MG\" },\n\t{ 0x3F, \"MM\" },\n\n\t{ 0x00, NULL }\n};\n/* Note that the table continues in code page 0x08 */\n\n/* Client capability code page (0x03) */\nstatic const value_string wbxml_wv_csp_12_tags_cp3[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"AcceptedCharset\" },\n\t{ 0x06, \"AcceptedContentLength\" },\n\t{ 0x07, \"AcceptedContentType\" },\n\t{ 0x08, \"AcceptedTransferEncoding\" },\n\t{ 0x09, \"AnyContent\" },\n\t{ 0x0A, \"DefaultLanguage\" },\n\t{ 0x0B, \"InitialDeliveryMethod\" },\n\t{ 0x0C, \"MultiTrans\" },\n\t{ 0x0D, \"ParserSize\" },\n\t{ 0x0E, \"ServerPollMin\" },\n\t{ 0x0F, \"SupportedBearer\" },\n\t{ 0x10, \"SupportedCIRMethod\" },\n\t{ 0x11, \"TCPAddress\" },\n\t{ 0x12, \"TCPPort\" },\n\t{ 0x13, \"UDPPort\" },\n\t{ 0x14, \"CIRURL\" },\n\n\t{ 0x00, NULL }\n};\n\n\n\n/* Presence primitive code page (0x04) */\nstatic const value_string wbxml_wv_csp_12_tags_cp4[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"CancelAuth-Request\" },\n\t{ 0x06, \"ContactListProperties\" },\n\t{ 0x07, \"CreateAttributeList-Request\" },\n\t{ 0x08, \"CreateList-Request\" },\n\t{ 0x09, \"DefaultAttributeList\" },\n\t{ 0x0A, \"DefaultContactList\" },\n\t{ 0x0B, \"DefaultList\" },\n\t{ 0x0C, \"DeleteAttributeList-Request\" },\n\t{ 0x0D, \"DeleteList-Request\" },\n\t{ 0x0E, \"GetAttributeList-Request\" },\n\t{ 0x0F, \"GetAttributeList-Response\" },\n\t{ 0x10, \"GetList-Request\" },\n\t{ 0x11, \"GetList-Response\" },\n\t{ 0x12, \"GetPresence-Request\" },\n\t{ 0x13, \"GetPresence-Response\" },\n\t{ 0x14, \"GetWatcherList-Request\" },\n\t{ 0x15, \"GetWatcherList-Response\" },\n\t{ 0x16, \"ListManage-Request\" },\n\t{ 0x17, \"ListManage-Response\" },\n\t{ 0x18, \"UnsubscribePresence-Request\" },\n\t{ 0x19, \"PresenceAuth-Request\" },\n\t{ 0x1A, \"PresenceAuth-User\" },\n\t{ 0x1B, \"PresenceNotification-Request\" },\n\t{ 0x1C, \"UpdatePresence-Request\" },\n\t{ 0x1D, \"SubscribePresence-Request\" },\n\t/* New in WV-CSP 1.2 */\n\t{ 0x1E, \"Auto-Subscribe\" },\n\t/* 0x1E was defined in WV-CSP 1.0: UnsubscribePresence-Request */\n\t{ 0x1F, \"GetReactiveAuthStatus-Request\" },\n\t/* 0x1F was defined in WV-CSP 1.0: UpdatePresence-Request */\n\t{ 0x20, \"GetReactiveAuthStatus-Response\" },\n\n\t{ 0x00, NULL }\n};\n\n/* Presence attribute code page (0x05) */\nstatic const value_string wbxml_wv_csp_12_tags_cp5[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"Accuracy\" },\n\t{ 0x06, \"Address\" },\n\t{ 0x07, \"AddrPref\" },\n\t{ 0x08, \"Alias\" },\n\t{ 0x09, \"Altitude\" },\n\t{ 0x0A, \"Building\" },\n\t{ 0x0B, \"Caddr\" },\n\t{ 0x0C, \"City\" },\n\t{ 0x0D, \"ClientInfo\" },\n\t{ 0x0E, \"ClientProducer\" },\n\t{ 0x0F, \"ClientType\" },\n\t{ 0x10, \"ClientVersion\" },\n\t{ 0x11, \"CommC\" },\n\t{ 0x12, \"CommCap\" },\n\t{ 0x13, \"ContactInfo\" },\n\t{ 0x14, \"ContainedvCard\" },\n\t{ 0x15, \"Country\" },\n\t{ 0x16, \"Crossing1\" },\n\t{ 0x17, \"Crossing2\" },\n\t{ 0x18, \"DevManufacturer\" },\n\t{ 0x19, \"DirectContent\" },\n\t{ 0x1A, \"FreeTextLocation\" },\n\t{ 0x1B, \"GeoLocation\" },\n\t{ 0x1C, \"Language\" },\n\t{ 0x1D, \"Latitude\" },\n\t{ 0x1E, \"Longitude\" },\n\t{ 0x1F, \"Model\" },\n\t{ 0x20, \"NamedArea\" },\n\t{ 0x21, \"OnlineStatus\" },\n\t{ 0x22, \"PLMN\" },\n\t{ 0x23, \"PrefC\" },\n\t{ 0x24, \"PreferredContacts\" },\n\t{ 0x25, \"PreferredLanguage\" },\n\t{ 0x26, \"ReferredContent\" },\n\t{ 0x27, \"ReferredvCard\" },\n\t{ 0x28, \"Registration\" },\n\t{ 0x29, \"StatusContent\" },\n\t{ 0x2A, \"StatusMood\" },\n\t{ 0x2B, \"StatusText\" },\n\t{ 0x2C, \"Street\" },\n\t{ 0x2D, \"TimeZone\" },\n\t{ 0x2E, \"UserAvailability\" },\n\t/* New in WV-CSP 1.1 */\n\t{ 0x2F, \"Cap\" },\n\t{ 0x30, \"Cname\" },\n\t{ 0x31, \"Contact\" },\n\t{ 0x32, \"Cpriority\" },\n\t{ 0x33, \"Cstatus\" },\n\t{ 0x34, \"Note\" },\n\t{ 0x35, \"Zone\" },\n\t/* New in WV-CSP 1.2 */\n\t{ 0x36, \"ContentType\" },\n\t{ 0x37, \"Inf_link\" },\n\t{ 0x38, \"InfoLink\" },\n\t{ 0x39, \"Link\" },\n\t{ 0x3A, \"Text\" },\n\n\t{ 0x00, NULL }\n};\n\n/* Messaging code page (0x06) */\nstatic const value_string wbxml_wv_csp_12_tags_cp6[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"BlockList\" },\n\t{ 0x06, \"BlockEntity-Request\" }, /* Was: BlockUser-Request */\n\t{ 0x07, \"DeliveryMethod\" },\n\t{ 0x08, \"DeliveryReport\" },\n\t{ 0x09, \"DeliveryReport-Request\" },\n\t{ 0x0A, \"ForwardMessage-Request\" },\n\t{ 0x0B, \"GetBlockedList-Request\" },\n\t{ 0x0C, \"GetBlockedList-Response\" },\n\t{ 0x0D, \"GetMessageList-Request\" },\n\t{ 0x0E, \"GetMessageList-Response\" },\n\t{ 0x0F, \"GetMessage-Request\" },\n\t{ 0x10, \"GetMessage-Response\" },\n\t{ 0x11, \"GrantList\" },\n\t{ 0x12, \"MessageDelivered\" },\n\t{ 0x13, \"MessageInfo\" },\n\t{ 0x14, \"MessageNotification\" },\n\t{ 0x15, \"NewMessage\" },\n\t{ 0x16, \"RejectMessage-Request\" },\n\t{ 0x17, \"SendMessage-Request\" },\n\t{ 0x18, \"SendMessage-Response\" },\n\t{ 0x19, \"SetDeliveryMethod-Request\" },\n\t{ 0x1A, \"DeliveryTime\" },\n\n\t{ 0x00, NULL }\n};\n\n/* Group code page (0x07) */\nstatic const value_string wbxml_wv_csp_12_tags_cp7[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"AddGroupMembers-Request\" },\n\t{ 0x06, \"Admin\" },\n\t{ 0x07, \"CreateGroup-Request\" },\n\t{ 0x08, \"DeleteGroup-Request\" },\n\t{ 0x09, \"GetGroupMembers-Request\" },\n\t{ 0x0A, \"GetGroupMembers-Response\" },\n\t{ 0x0B, \"GetGroupProps-Request\" },\n\t{ 0x0C, \"GetGroupProps-Response\" },\n\t{ 0x0D, \"GroupChangeNotice\" },\n\t{ 0x0E, \"GroupProperties\" },\n\t{ 0x0F, \"Joined\" },\n\t{ 0x10, \"JoinedRequest\" },\n\t{ 0x11, \"JoinGroup-Request\" },\n\t{ 0x12, \"JoinGroup-Response\" },\n\t{ 0x13, \"LeaveGroup-Request\" },\n\t{ 0x14, \"LeaveGroup-Response\" },\n\t{ 0x15, \"Left\" },\n\t{ 0x16, \"MemberAccess-Request\" },\n\t{ 0x17, \"Mod\" },\n\t{ 0x18, \"OwnProperties\" },\n\t{ 0x19, \"RejectList-Request\" },\n\t{ 0x1A, \"RejectList-Response\" },\n\t{ 0x1B, \"RemoveGroupMembers-Request\" },\n\t{ 0x1C, \"SetGroupProps-Request\" },\n\t{ 0x1D, \"SubscribeGroupNotice-Request\" },\n\t{ 0x1E, \"SubscribeGroupNotice-Response\" },\n\t{ 0x1F, \"Users\" },\n\t{ 0x20, \"WelcomeNote\" },\n\t/* New in WV-CSP 1.1 */\n\t{ 0x21, \"JoinGroup\" },\n\t{ 0x22, \"SubscribeNotification\" },\n\t{ 0x23, \"SubscribeType\" },\n\t/* New in WV-CSP 1.2 */\n\t{ 0x24, \"GetJoinedUsers-Request\" },\n\t{ 0x25, \"GetJoinedUsers-Response\" },\n\t{ 0x26, \"AdminMapList\" },\n\t{ 0x27, \"AdminMapping\" },\n\t{ 0x28, \"Mapping\" },\n\t{ 0x29, \"ModMapping\" },\n\t{ 0x2A, \"UserMapList\" },\n\t{ 0x2B, \"UserMapping\" },\n\n\t{ 0x00, NULL }\n};\n\n/* Service negotiation code page - continued (0x08) */\nstatic const value_string wbxml_wv_csp_12_tags_cp8[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"MP\" },\n\t{ 0x06, \"GETAUT\" },\n\t{ 0x07, \"GETJU\" },\n\t{ 0x08, \"VRID\" },\n\t{ 0x09, \"VerifyIDFunc\" },\n\n\t{ 0x00, NULL }\n};\n\n/* Common code page - continued (0x09) */\nstatic const value_string wbxml_wv_csp_12_tags_cp9[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"CIR\" },\n\t{ 0x06, \"Domain\" },\n\t{ 0x07, \"ExtBlock\" },\n\t{ 0x08, \"HistoryPeriod\" },\n\t{ 0x09, \"IDList\" },\n\t{ 0x0A, \"MaxWatcherList\" },\n\t{ 0x0B, \"ReactiveAuthState\" },\n\t{ 0x0C, \"ReactiveAuthStatus\" },\n\t{ 0x0D, \"ReactiveAuthStatusList\" },\n\t{ 0x0E, \"Watcher\" },\n\t{ 0x0F, \"WatcherStatus\" },\n\n\t{ 0x00, NULL }\n};\n\n/* Access code page - continued (0x0A) */\nstatic const value_string wbxml_wv_csp_12_tags_cp10[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"WV-CSP-NSDiscovery-Request\" },\n\t{ 0x06, \"WV-CSP-NSDiscovery-Response\" },\n\t{ 0x07, \"VersionList\" },\n\n\t{ 0x00, NULL }\n};\n\n/*****    Attribute Start tokens   *****/\n/* Common code page (0x00) */\nstatic const value_string wbxml_wv_csp_12_attrStart_cp0[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"xmlns='http://www.wireless-village.org/CSP'\" },\n\t{ 0x06, \"xmlns='http://www.wireless-village.org/PA'\" },\n\t{ 0x07, \"xmlns='http://www.wireless-village.org/TRC'\" },\n\t/* New in WV-CSP 1.2 */\n\t{ 0x08, \"xmlns='http://www.openmobilealliance.org/DTD/WV-CSP'\" },\n\t{ 0x09, \"xmlns='http://www.openmobilealliance.org/DTD/WV-PA'\" },\n\t{ 0x0A, \"xmlns http://www.openmobilealliance.org/DTD/WV-TRC'\" },\n\n\t{ 0x00, NULL }\n};\n\n/*****    Attribute Value tokens   *****/\n/*\n * Element value tokens\n *\n * NOTE - WV-CSP uses the EXT_T_0 token in a peculiar way: the mb_u_int32\n * does *not* reference an offset in the string table, but it refers to\n * the index in the following value_string.\n *\n * Please note that:\n *  - Values 'T' and 'F' are Boolean values representing \"True\" and \"False\"\n *    (or \"Yes\" and \"No\" in some circumstances) respectively.\n *  - Values 'GR', 'IM', 'PR', 'SC', 'GM' and 'US' are enumerated values\n *    representing \"Group\", \"Instant Messaging\", \"Presence\", \"Shared Content\",\n *    \"Group membership\" and \"User\" respectively.\n *  - Values 'G', 'S' and 'U' are enumerated values representing \"Get\", \"Set\"\n *    and \"Unset\" respectively.\n *  - Values 'N' and 'P' are enumerated values representing \"Notify/Get\" and\n *    \"Push\" respectively.\n *\n * I repeat: this is NOT a attrValue[] array hence it is not called\n * wbxml_wv_XXX but vals_wv_XXX.\n */\nstatic const value_string vals_wv_csp_12_element_value_tokens[] = {\n\t/*\n\t * Common value tokens\n\t */\n\t{ 0x00, \"AccessType\" },\n\t{ 0x01, \"ActiveUsers\" },\n\t{ 0x02, \"Admin\" },\n\t{ 0x03, \"application/\" },\n\t{ 0x04, \"application/vnd.wap.mms-message\" },\n\t{ 0x05, \"application/x-sms\" },\n\t{ 0x06, \"AutoJoin\" },\n\t{ 0x07, \"BASE64\" },\n\t{ 0x08, \"Closed\" },\n\t{ 0x09, \"Default\" },\n\t{ 0x0A, \"DisplayName\" },\n\t{ 0x0B, \"F\" },\n\t{ 0x0C, \"G\" },\n\t{ 0x0D, \"GR\" },\n\t{ 0x0E, \"http://\" },\n\t{ 0x0F, \"https://\" },\n\t{ 0x10, \"image/\" },\n\t{ 0x11, \"Inband\" },\n\t{ 0x12, \"IM\" },\n\t{ 0x13, \"MaxActiveUsers\" },\n\t{ 0x14, \"Mod\" },\n\t{ 0x15, \"Name\" },\n\t{ 0x16, \"None\" },\n\t{ 0x17, \"N\" },\n\t{ 0x18, \"Open\" },\n\t{ 0x19, \"Outband\" },\n\t{ 0x1A, \"PR\" },\n\t{ 0x1B, \"Private\" },\n\t{ 0x1C, \"PrivateMessaging\" },\n\t{ 0x1D, \"PrivilegeLevel\" },\n\t{ 0x1E, \"Public\" },\n\t{ 0x1F, \"P\" },\n\t{ 0x20, \"Request\" },\n\t{ 0x21, \"Response\" },\n\t{ 0x22, \"Restricted\" },\n\t{ 0x23, \"ScreenName\" },\n\t{ 0x24, \"Searchable\" },\n\t{ 0x25, \"S\" },\n\t{ 0x26, \"SC\" },\n\t{ 0x27, \"text/\" },\n\t{ 0x28, \"text/plain\" },\n\t{ 0x29, \"text/x-vCalendar\" },\n\t{ 0x2A, \"text/x-vCard\" },\n\t{ 0x2B, \"Topic\" },\n\t{ 0x2C, \"T\" },\n\t{ 0x2D, \"Type\" },\n\t{ 0x2E, \"U\" },\n\t{ 0x2F, \"US\" },\n\t{ 0x30, \"www.wireless-village.org\" },\n\t/* New in WV-CSP 1.2 */\n\t{ 0x31, \"AutoDelete\" },\n\t{ 0x32, \"GM\" },\n\t{ 0x33, \"Validity\" },\n\t{ 0x34, \"DENIED\" },\n\t{ 0x35, \"GRANTED\" },\n\t{ 0x36, \"PENDING\" },\n\t{ 0x37, \"ShowID\" },\n\n\t/*\n\t * Access value tokens\n\t */\n\t{ 0x3D, \"GROUP_ID\" },\n\t{ 0x3E, \"GROUP_NAME\" },\n\t{ 0x3F, \"GROUP_TOPIC\" },\n\t{ 0x40, \"GROUP_USER_ID_JOINED\" },\n\t{ 0x41, \"GROUP_USER_ID_OWNER\" },\n\t{ 0x42, \"HTTP\" },\n\t{ 0x43, \"SMS\" },\n\t{ 0x44, \"STCP\" },\n\t{ 0x45, \"SUDP\" },\n\t{ 0x46, \"USER_ALIAS\" },\n\t{ 0x47, \"USER_EMAIL_ADDRESS\" },\n\t{ 0x48, \"USER_FIRST_NAME\" },\n\t{ 0x49, \"USER_ID\" },\n\t{ 0x4A, \"USER_LAST_NAME\" },\n\t{ 0x4B, \"USER_MOBILE_NUMBER\" },\n\t{ 0x4C, \"USER_ONLINE_STATUS\" },\n\t{ 0x4D, \"WAPSMS\" },\n\t{ 0x4E, \"WAPUDP\" },\n\t{ 0x4F, \"WSP\" },\n\t/* New in WV-CSP 1.2 */\n\t{ 0x50, \"GROUP_USER_ID_AUTOJOIN\" },\n\t/*\n\t * Presence value tokens\n\t */\n\t{ 0x5B, \"ANGRY\" },\n\t{ 0x5C, \"ANXIOUS\" },\n\t{ 0x5D, \"ASHAMED\" },\n\t{ 0x5E, \"AUDIO_CALL\" },\n\t{ 0x5F, \"AVAILABLE\" },\n\t{ 0x60, \"BORED\" },\n\t{ 0x61, \"CALL\" },\n\t{ 0x62, \"CLI\" },\n\t{ 0x63, \"COMPUTER\" },\n\t{ 0x64, \"DISCREET\" },\n\t{ 0x65, \"EMAIL\" },\n\t{ 0x66, \"EXCITED\" },\n\t{ 0x67, \"HAPPY\" },\n\t/*\t{ 0x68, \"IM\" },\t\tObsolete */\n\t{ 0x69, \"IM_OFFLINE\" },\n\t{ 0x6A, \"IM_ONLINE\" },\n\t{ 0x6B, \"IN_LOVE\" },\n\t{ 0x6C, \"INVINCIBLE\" },\n\t{ 0x6D, \"JEALOUS\" },\n\t{ 0x6E, \"MMS\" },\n\t{ 0x6F, \"MOBILE_PHONE\" },\n\t{ 0x70, \"NOT_AVAILABLE\" },\n\t{ 0x71, \"OTHER\" },\n\t{ 0x72, \"PDA\" },\n\t{ 0x73, \"SAD\" },\n\t{ 0x74, \"SLEEPY\" },\n\t{ 0x75, \"SMS\" },\n\t{ 0x76, \"VIDEO_CALL\" },\n\t{ 0x77, \"VIDEO_STREAM\" },\n\n\t/*\n\t * Access value tokens - continued\n\t */\n\t{ 0xA4, \"SSMS\" },\n\t{ 0xA5, \"SHTTP\" },\n\n\t{ 0x00, NULL }\n};\n\n\n\n/***** Token code page aggregation *****/\n\nstatic char *\next_t_0_wv_cspc_12(wmem_allocator_t* allocator, tvbuff_t *tvb _U_, uint32_t value, uint32_t str_tbl _U_)\n{\n\tchar *str = wmem_strdup_printf(allocator, \"Common Value: '%s'\",\n\t\t\t\t    val_to_str(allocator, value, vals_wv_csp_12_element_value_tokens,\n\t\t\t\t\t       \"<Unknown WV-CSP 1.2 Common Value token 0x%X>\"));\n\treturn str;\n}\n\n#define wbxml_wv_csp_12_global wbxml_wv_csp_11_global\n\nstatic const value_valuestring wbxml_wv_csp_12_tags[] = {\n\t{  0, wbxml_wv_csp_12_tags_cp0 },\n\t{  1, wbxml_wv_csp_12_tags_cp1 },\n\t{  2, wbxml_wv_csp_12_tags_cp2 },\n\t{  3, wbxml_wv_csp_12_tags_cp3 },\n\t{  4, wbxml_wv_csp_12_tags_cp4 },\n\t{  5, wbxml_wv_csp_12_tags_cp5 },\n\t{  6, wbxml_wv_csp_12_tags_cp6 },\n\t{  7, wbxml_wv_csp_12_tags_cp7 },\n\t{  8, wbxml_wv_csp_12_tags_cp8 },\n\t{  9, wbxml_wv_csp_12_tags_cp9 },\n\t{ 10, wbxml_wv_csp_12_tags_cp10 },\n\t{  0, NULL }\n};\n\nstatic const value_valuestring wbxml_wv_csp_12_attrStart[] = {\n\t{ 0, wbxml_wv_csp_12_attrStart_cp0 },\n\t{ 0, NULL }\n};\n\nstatic const wbxml_decoding decode_wv_cspc_12 = {\n\t\"Wireless-Village Client-Server Protocol 1.2\",\n\t\"WV-CSP 1.2\",\n\t{ ext_t_0_wv_cspc_12, NULL, NULL },\n\twv_csp12_opaque_binary_tag,\n\twv_csp12_opaque_literal_tag,\n\tdefault_opaque_binary_attr,\n\tdefault_opaque_literal_attr,\n\twbxml_wv_csp_12_global,\n\twbxml_wv_csp_12_tags,\n\twbxml_wv_csp_12_attrStart,\n\tNULL\n};\n\n\n/* WV-CSP 1.3\n *\n * Wireless Village Client Server Protocol\n ***************************************/\n\n/*****   Global extension tokens   *****/\n/* Same as WV-CSP 1.1 */\n\n/*****         Tag tokens          *****/\n/* Common code page */\nstatic const value_string wbxml_wv_csp_13_tags_cp0[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"Acceptance\"},\n\t{ 0x06, \"AddList\" },\n\t{ 0x07, \"AddNickList\"},\n\t{ 0x09, \"WV-CSP-Message\"},\n\t{ 0x0A, \"ClientID\"},\n\t{ 0x0B,\t\"Code\"},\n\t{ 0x0C, \"ContactList\"},\n\t{ 0x0D, \"ContentData\"},\n\t{ 0x0E, \"ContentEncoding\"},\n\t{ 0x0F, \"ContentSize\"   },\n\t{ 0x10, \"ContentType\"},\n\t{ 0x11, \"DateTime\"   },\n\t{ 0x12, \"Description\" },\n\t{ 0x13, \"DetailedResult\"},\n\t{ 0x14, \"EntityList\"},\n\t{ 0x15, \"Group\"  },\n\t{ 0x16, \"GroupID\"},\n\t{ 0x17, \"GroupList\"},\n\t{ 0x19, \"Logo\"},\n\t{ 0x1A, \"MessageCount\" },\n\t{ 0x1B, \"MessageID\" },\n\t{ 0x1C, \"MessageURI\"},\n\t{ 0x1D, \"MSISDN\" },\n\t{ 0x1E, \"Name\"},\n\t{ 0x1F, \"NickList\"},\n\t{ 0x20, \"NickName\"},\n\t{ 0x21, \"Poll\"},\n\t{ 0x22, \"Presence\"},\n\t{ 0x23, \"PresenceSubList\" },\n\t{ 0x24, \"PresenceValue\"},\n\t{ 0x25, \"Property\"  },\n\t{ 0x26, \"Qualifier\" },\n\t{ 0x27, \"Recipient\" },\n\t{ 0x28, \"RemoveList\"},\n\t{ 0x29, \"RemoveNickList\"  },\n\t{ 0x2A, \"Result\" },\n\t{ 0x2B, \"ScreenName\"},\n\t{ 0x2C, \"Sender\" },\n\t{ 0x2D, \"Session\"},\n\t{ 0x2E, \"SessionDescriptor\" },\n\t{ 0x2F, \"SessionID\"},\n\t{ 0x30, \"SessionType\" },\n\t{ 0x08, \"SName\" },\n\t{ 0x31, \"Status\"},\n\t{ 0x32, \"Transaction\" },\n\t{ 0x33, \"TransactionContent\"  },\n\t{ 0x34, \"TransactionDescriptor\"},\n\t{ 0x35, \"TransactionID\"},\n\t{ 0x36, \"TransactionMode\" },\n\t{ 0x37, \"URL\" },\n\t{ 0x38, \"URLList\"},\n\t{ 0x39, \"User\"},\n\t{ 0x3A, \"UserID\" },\n\t{ 0x3B, \"UserList\"  },\n\t{ 0x3C, \"Validity\"  },\n\t{ 0x3D, \"Value\"  },\n\n\t{ 0x00, NULL }\n};\n/* Note that the table continues in code page 0x09 */\n\n/* Access code page (0x01) */\nstatic const value_string wbxml_wv_csp_13_tags_cp1[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"AllFunctions\" },\n\t{ 0x06, \"AllFunctionsRequest\" },\n\t{ 0x07, \"CancelInvite-Request\" },\n\t{ 0x08, \"CancelInviteUser-Request\" },\n\t/*\t{ 0x09, \"Capability\" }, - removed in WV 1.3*/\n\t{ 0x0A, \"CapabilityList\" },\n\t{ 0x0B, \"CapabilityRequest\" },\n\t{ 0x0C, \"ClientCapability-Request\" },\n\t{ 0x0D, \"ClientCapability-Response\" },\n\t{ 0x0E, \"DigestBytes\" },\n\t{ 0x0F, \"DigestSchema\" },\n\t{ 0x10, \"Disconnect\" },\n\t{ 0x11, \"Functions\" },\n\t{ 0x12, \"GetSPInfo-Request\" },\n\t{ 0x13, \"GetSPInfo-Response\" },\n\t{ 0x14, \"InviteID\" },\n\t{ 0x15, \"InviteNote\" },\n\t{ 0x16, \"Invite-Request\" },\n\t{ 0x17, \"Invite-Response\" },\n\t{ 0x18, \"InviteType\" },\n\t{ 0x19, \"InviteUser-Request\" },\n\t{ 0x1A, \"InviteUser-Response\" },\n\t{ 0x1B, \"KeepAlive-Request\" },\n\t{ 0x1C, \"KeepAliveTime\" },\n\t{ 0x1D, \"Login-Request\" },\n\t{ 0x1E, \"Login-Response\" },\n\t{ 0x1F, \"Logout-Request\" },\n\t{ 0x20, \"Nonce\" },\n\t{ 0x21, \"Password\" },\n\t{ 0x22, \"Polling-Request\" },\n\t{ 0x23, \"ResponseNote\" },\n\t{ 0x24, \"SearchElement\" },\n\t{ 0x25, \"SearchFindings\" },\n\t{ 0x26, \"SearchID\" },\n\t{ 0x27, \"SearchIndex\" },\n\t{ 0x28, \"SearchLimit\" },\n\t{ 0x29, \"KeepAlive-Response\" },\n\t{ 0x2A, \"SearchPairList\" },\n\t{ 0x2B, \"Search-Request\" },\n\t{ 0x2C, \"Search-Response\" },\n\t{ 0x2D, \"SearchResult\" },\n\t{ 0x2E, \"Service-Request\" },\n\t{ 0x2F, \"Service-Response\" },\n\t{ 0x30, \"SessionCookie\" },\n\t{ 0x31, \"StopSearch-Request\" },\n\t{ 0x32, \"TimeToLive\" },\n\t/* New in WV-CSP 1.1 */\n\t{ 0x33, \"SearchString\" },\n\t{ 0x34, \"CompletionFlag\" },\n\t/* New in WV-CSP 1.2 */\n\t{ 0x36, \"ReceiveList\" },\n\t{ 0x37, \"VerifyID-Request\" },\n\t{ 0x38, \"Extended-Request\" },\n\t{ 0x39, \"Extended-Response\" },\n\t{ 0x3A, \"AgreedCapabilityList\" },\n\t{ 0x3B, \"ExtendedData\" },\n\t{ 0x3C, \"OtherServer\" },\n\t{ 0x3D, \"PresenceAttributeNSName\" },\n\t{ 0x3E, \"SessionNSName\" },\n\t{ 0x3F, \"TransactionNSName\" },\n\n\t{ 0x00, NULL }\n};\n/* Note that the table continues in code page 0x0A */\n\n/* Service code page (0x02) */\nstatic const value_string wbxml_wv_csp_13_tags_cp2[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"ADDGM\" },\n\t/*\t{ 0x06, \"AttListFunc\" }, removed in WV 1.3 */\n\t{ 0x07, \"BLENT\" },\n\t/*\t{ 0x08, \"CAAUT\" }, removed in WV 1.3 */\n\t{ 0x09, \"CAINV\" },\n\t/*\t{ 0x0A, \"CALI\" }, removed in WV 1.3 */\n\t{ 0x0B, \"CCLI\" },\n\t{ 0x0C, \"ContListFunc\" },\n\t{ 0x0D, \"CREAG\" },\n\t{ 0x0E, \"DALI\" },\n\t{ 0x0F, \"DCLI\" },\n\t{ 0x10, \"DELGR\" },\n\t{ 0x11, \"FundamentalFeat\" },\n\t{ 0x12, \"FWMSG\" },\n\t/*\t{ 0x13, \"GALS\" }, removed in WV 1.3 */\n\t{ 0x14, \"GCLI\" },\n\t{ 0x15, \"GETGM\" },\n\t{ 0x16, \"GETGP\" },\n\t{ 0x17, \"GETLM\" },\n\t{ 0x18, \"GETM\" },\n\t{ 0x19, \"GETPR\" },\n\t{ 0x1A, \"GETSPI\" },\n\t{ 0x1B, \"GETWL\" },\n\t{ 0x1C, \"GLBLU\" },\n\t{ 0x1D, \"GRCHN\" },\n\t{ 0x1E, \"GroupAuthFunc\" },\n\t{ 0x1F, \"GroupFeat\" },\n\t{ 0x20, \"GroupMgmtFunc\" },\n\t{ 0x21, \"GroupUseFunc\" },\n\t{ 0x22, \"IMAuthFunc\" },\n\t{ 0x23, \"IMFeat\" },\n\t{ 0x24, \"IMReceiveFunc\" },\n\t{ 0x25, \"IMSendFunc\" },\n\t{ 0x26, \"INVIT\" },\n\t{ 0x27, \"InviteFunc\" },\n\t{ 0x28, \"MBRAC\" },\n\t{ 0x29, \"MCLS\" },\n\t{ 0x2A, \"MDELIV\" },\n\t{ 0x2B, \"NEWM\" },\n\t{ 0x2C, \"NOTIF\" },\n\t{ 0x2D, \"PresenceAuthFunc\" },\n\t{ 0x2E, \"PresenceDeliverFunc\"},\n\t{ 0x2F, \"PresenceFeat\" },\n\t/*\t{ 0x30, \"REACT\" }, removed in WV 1.3 */\n\t{ 0x31, \"REJCM\" },\n\t{ 0x32, \"REJEC\" },\n\t{ 0x33, \"RMVGM\" },\n\t{ 0x34, \"SearchFunc\" },\n\t{ 0x35, \"ServiceFunc\" },\n\t{ 0x36, \"SETD\" },\n\t{ 0x37, \"SETGP\" },\n\t{ 0x38, \"SRCH\" },\n\t{ 0x39, \"STSRC\" },\n\t{ 0x3A, \"SUBGCN\" },\n\t{ 0x3B, \"UPDPR\" },\n\t{ 0x3C, \"WVCSPFeat\" },\n\t/* New in WV-CSP 1.2 */\n\t{ 0x3D, \"MF\" },\n\t{ 0x3E, \"MG\" },\n\t{ 0x3F, \"MM\" },\n\n\t{ 0x00, NULL }\n};\n/* Note that the table continues in code page 0x08 */\n\n/* Client capability code page (0x03) */\nstatic const value_string wbxml_wv_csp_13_tags_cp3[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t/*  {0x05, \"AcceptedCharset\"}, - removed in WV 1.3 */\n\t/*  { 0x06, \"AcceptedContentLength\"}, - removed in WV 1.3 */\n\t{ 0x07, \"AcceptedContentType\"},\n\t{ 0x08, \"AcceptedTransferEncoding\"},\n\t{ 0x09, \"AnyContent\"},\n\t{ 0x0A, \"DefaultLanguage\"},\n\t{ 0x0B, \"InitialDeliveryMethod\"},\n\t{ 0x0C, \"MultiTrans\"},\n\t{ 0x0D, \"ParserSize\"},\n\t{ 0x0E, \"ServerPollMin\"},\n\t{ 0x0F, \"SupportedBearer\"},\n\t{ 0x10, \"SupportedCIRMethod\"},\n\t{ 0x11, \"TCPAddress\"},\n\t{ 0x12, \"TCPPort\"},\n\t{ 0x13, \"UDPPort\"},\n\t/* New in WV-CSP 1.3*/\n\t{ 0x14, \"CIRHTTPAddress\"},\n\t{ 0x15, \"UDPAddress\"},\n\t{ 0x16, \"AcceptedPullLength\"},\n\t{ 0x17, \"AcceptedPushLength\"},\n\t{ 0x18, \"AcceptedRichContentLength\"},\n\t{ 0x19, \"AcceptedTextContentLength\"},\n\t{ 0x1A, \"OfflineETEMHandling\"},\n\t{ 0x1B, \"PlainTextCharset\"},\n\t{ 0x1C, \"SessionPriority\"},\n\t{ 0x1D, \"SupportedOfflineBearer\"},\n\t{ 0x1F, \"UserSessionLimit\"},\n\t{ 0x20, \"CIRSMSAddress\"},\n\t{ 0x21, \"MultiTransPerMessage\"},\n\t{ 0x22, \"OnlineETEMHandling\"},\n\t{ 0x23,\"ContentPolicy\"},\n\t{ 0x24, \"ContentPolicyLimit\"},\n\n\t{ 0x00, NULL }\n};\n\n/* Presence primitive code page (0x04) */\nstatic const value_string wbxml_wv_csp_13_tags_cp4[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t/*\t{ 0x05, \"CancelAuth-Request\" }, - removed in WV 1.3 */\n\t{ 0x06, \"ContactListProperties\" },\n\t{ 0x07, \"CreateAttributeList-Request\" },\n\t{ 0x08, \"CreateList-Request\" },\n\t{ 0x09, \"DefaultAttributeList\" },\n\t{ 0x0A, \"DefaultContactList\" },\n\t{ 0x0B, \"DefaultList\" },\n\t{ 0x0C, \"DeleteAttributeList-Request\" },\n\t{ 0x0D, \"DeleteList-Request\" },\n\t{ 0x0E, \"GetAttributeList-Request\" },\n\t{ 0x0F, \"GetAttributeList-Response\" },\n\t{ 0x10, \"GetList-Request\" },\n\t{ 0x11, \"GetList-Response\" },\n\t{ 0x12, \"GetPresence-Request\" },\n\t{ 0x13, \"GetPresence-Response\" },\n\t{ 0x14, \"GetWatcherList-Request\" },\n\t{ 0x15, \"GetWatcherList-Response\" },\n\t{ 0x16, \"ListManage-Request\" },\n\t{ 0x17, \"ListManage-Response\" },\n\t{ 0x18, \"UnsubscribePresence-Request\" },\n\t{ 0x19, \"PresenceAuth-Request\" },\n\t{ 0x1A, \"PresenceAuth-User\" },\n\t{ 0x1B, \"PresenceNotification-Request\" },\n\t{ 0x1C, \"UpdatePresence-Request\" },\n\t{ 0x1D, \"SubscribePresence-Request\" },\n\t/* New in WV-CSP 1.2 */\n\t/*\t{ 0x1E, \"Auto-Subscribe\" }, - removed in WV 1.3 */\n\t/*\t{ 0x1F, \"GetReactiveAuthStatus-Request\" }, */\n\t/*\t{ 0x20, \"GetReactiveAuthStatus-Response\" }, */\n\t/* New in WV-CSP 1.3 */\n\t{ 0x21, \"CreateList-Response\"},\n\n\t{ 0x00, NULL }\n};\n\n/* Presence attribute code page (0x05) */\nstatic const value_string wbxml_wv_csp_13_tags_cp5[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"Accuracy\" },\n\t{ 0x06, \"Address\" },\n\t{ 0x07, \"AddrPref\" },\n\t{ 0x08, \"Alias\" },\n\t{ 0x09, \"Altitude\" },\n\t{ 0x0A, \"Building\" },\n\t{ 0x0B, \"Caddr\" },\n\t{ 0x0C, \"City\" },\n\t{ 0x0D, \"ClientInfo\" },\n\t{ 0x0E, \"ClientProducer\" },\n\t{ 0x0F, \"ClientType\" },\n\t{ 0x10, \"ClientVersion\" },\n\t{ 0x11, \"CommC\" },\n\t{ 0x12, \"CommCap\" },\n\t{ 0x13, \"ContactInfo\" },\n\t{ 0x14, \"ContainedvCard\" },\n\t{ 0x15, \"Country\" },\n\t{ 0x16, \"Crossing1\" },\n\t{ 0x17, \"Crossing2\" },\n\t{ 0x18, \"DevManufacturer\" },\n\t{ 0x19, \"DirectContent\" },\n\t{ 0x1A, \"FreeTextLocation\" },\n\t{ 0x1B, \"GeoLocation\" },\n\t{ 0x1C, \"Language\" },\n\t{ 0x1D, \"Latitude\" },\n\t{ 0x1E, \"Longitude\" },\n\t{ 0x1F, \"Model\" },\n\t{ 0x20, \"NamedArea\" },\n\t{ 0x21, \"OnlineStatus\" },\n\t{ 0x22, \"PLMN\" },\n\t{ 0x23, \"PrefC\" },\n\t{ 0x24, \"PreferredContacts\" },\n\t{ 0x25, \"PreferredLanguage\" },\n\t{ 0x26, \"ReferredContent\" },\n\t{ 0x27, \"ReferredvCard\" },\n\t{ 0x28, \"Registration\" },\n\t{ 0x29, \"StatusContent\" },\n\t{ 0x2A, \"StatusMood\" },\n\t{ 0x2B, \"StatusText\" },\n\t{ 0x2C, \"Street\" },\n\t{ 0x2D, \"TimeZone\" },\n\t{ 0x2E, \"UserAvailability\" },\n\t/* New in WV-CSP 1.1 */\n\t{ 0x2F, \"Cap\" },\n\t{ 0x30, \"Cname\" },\n\t{ 0x31, \"Contact\" },\n\t{ 0x32, \"Cpriority\" },\n\t{ 0x33, \"Cstatus\" },\n\t{ 0x34, \"Note\" },\n\t{ 0x35, \"Zone\" },\n\t/* New in WV-CSP 1.2 */\n\t{ 0x36, \"ContentType\" },\n\t{ 0x37, \"Inf_link\" },\n\t{ 0x38, \"InfoLink\" },\n\t{ 0x39, \"Link\" },\n\t{ 0x3A, \"Text\" },\n\t/* New in WV-CSP 1.3 */\n\t{ 0x3B, \"ClientContentLimit\"},\n\t{ 0x3C, \"ClientIMPriority\"},\n\t{ 0x3D, \"MaxPullLength\"},\n\t{ 0x3E, \"MaxPushLength\"},\n\n\t{ 0x00, NULL }\n};\n\n/* Messaging code page (0x06) */\nstatic const value_string wbxml_wv_csp_13_tags_cp6[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"BlockList\" },\n\t{ 0x06, \"BlockEntity-Request\" }, /* Was: BlockUser-Request */\n\t{ 0x07, \"DeliveryMethod\" },\n\t{ 0x08, \"DeliveryReport\" },\n\t{ 0x09, \"DeliveryReport-Request\" },\n\t{ 0x0A, \"ForwardMessage-Request\" },\n\t{ 0x0B, \"GetBlockedList-Request\" },\n\t{ 0x0C, \"GetBlockedList-Response\" },\n\t{ 0x0D, \"GetMessageList-Request\" },\n\t{ 0x0E, \"GetMessageList-Response\" },\n\t{ 0x0F, \"GetMessage-Request\" },\n\t{ 0x10, \"GetMessage-Response\" },\n\t{ 0x11, \"GrantList\" },\n\t{ 0x12, \"MessageDelivered\" },\n\t{ 0x13, \"MessageInfo\" },\n\t{ 0x14, \"MessageNotification\" },\n\t{ 0x15, \"NewMessage\" },\n\t{ 0x16, \"RejectMessage-Request\" },\n\t{ 0x17, \"SendMessage-Request\" },\n\t{ 0x18, \"SendMessage-Response\" },\n\t{ 0x19, \"SetDeliveryMethod-Request\" },\n\t{ 0x1A, \"DeliveryTime\" },\n\t/* New in WV-CSP 1.3 */\n\t{ 0x20, \"MessageInfoList\"},\n\t{ 0x21, \"ForwardMessage-Response\"},\n\n\t{ 0x00, NULL }\n};\n\n/* Group code page (0x07) */\nstatic const value_string wbxml_wv_csp_13_tags_cp7[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"AddGroupMembers-Request\" },\n\t{ 0x06, \"Admin\" },\n\t{ 0x07, \"CreateGroup-Request\" },\n\t{ 0x08, \"DeleteGroup-Request\" },\n\t{ 0x09, \"GetGroupMembers-Request\" },\n\t{ 0x0A, \"GetGroupMembers-Response\" },\n\t{ 0x0B, \"GetGroupProps-Request\" },\n\t{ 0x0C, \"GetGroupProps-Response\" },\n\t{ 0x0D, \"GroupChangeNotice\" },\n\t{ 0x0E, \"GroupProperties\" },\n\t{ 0x0F, \"Joined\" },\n\t{ 0x10, \"JoinedRequest\" },\n\t{ 0x11, \"JoinGroup-Request\" },\n\t{ 0x12, \"JoinGroup-Response\" },\n\t{ 0x13, \"LeaveGroup-Request\" },\n\t{ 0x14, \"LeaveGroup-Response\" },\n\t{ 0x15, \"Left\" },\n\t{ 0x16, \"MemberAccess-Request\" },\n\t{ 0x17, \"Mod\" },\n\t{ 0x18, \"OwnProperties\" },\n\t{ 0x19, \"RejectList-Request\" },\n\t{ 0x1A, \"RejectList-Response\" },\n\t{ 0x1B, \"RemoveGroupMembers-Request\" },\n\t{ 0x1C, \"SetGroupProps-Request\" },\n\t{ 0x1D, \"SubscribeGroupNotice-Request\" },\n\t{ 0x1E, \"SubscribeGroupNotice-Response\" },\n\t/*\t{ 0x1F, \"Users\" },  - removed in WV 1.3 */\n\t{ 0x20, \"WelcomeNote\" },\n\t/* New in WV-CSP 1.1 */\n\t{ 0x21, \"JoinGroup\" },\n\t{ 0x22, \"SubscribeNotification\" },\n\t{ 0x23, \"SubscribeType\" },\n\t/* New in WV-CSP 1.2 */\n\t{ 0x24, \"GetJoinedUsers-Request\" },\n\t{ 0x25, \"GetJoinedUsers-Response\" },\n\t{ 0x26, \"AdminMapList\" },\n\t{ 0x27, \"AdminMapping\" },\n\t{ 0x28, \"Mapping\" },\n\t{ 0x29, \"ModMapping\" },\n\t{ 0x2A, \"UserMapList\" },\n\t{ 0x2B, \"UserMapping\" },\n\t/* New in WV-CSP 1.3 */\n\t{ 0x2C, \"JoinedBlocked\" },\n\t{ 0x2D, \"LeftBlocked\" },\n\n\t{ 0x00, NULL }\n};\n\n/* Service negotiation code page - continued (0x08) */\nstatic const value_string wbxml_wv_csp_13_tags_cp8[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t/* New in WV-CSP 1.2 */\n\t{ 0x05, \"MP\" },\n\t{ 0x06, \"GETAUT\" },\n\t{ 0x07, \"GETJU\" },\n\t{ 0x08, \"VRID\" },\n\t{ 0x09, \"VerifyIDFunc\" },\n\t/* New in WV-CSP 1.3 */\n \t{ 0x0A, \"GETMAP\" },\n\t{ 0x0B, \"SGMNT\" },\n\t{ 0x0C, \"EXCON\" },\n\t{ 0x0D, \"OFFNOTIF\" },\n\t{ 0x0E, \"ADVSR\" },\n\n\t{ 0x00, NULL }\n};\n\n/* Common code page - continued (0x09) */\nstatic const value_string wbxml_wv_csp_13_tags_cp9[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t/* New in WV-CSP 1.2 */\n\t{ 0x05, \"CIR\" },\n\t{ 0x06, \"Domain\" },\n\t{ 0x07, \"ExtBlock\" },\n\t{ 0x08, \"HistoryPeriod\" },\n\t{ 0x09, \"IDList\" },\n\t{ 0x0A, \"MaxWatcherList\" },\n\t/*\t{ 0x0B, \"ReactiveAuthState\" }, - removed in WV 1.3 */\n\t/*\t{ 0x0C, \"ReactiveAuthStatus\" }, - removed in WV 1.3 */\n\t/*\t{ 0x0D, \"ReactiveAuthStatusList\" }, - removed in WV 1.3 */\n\t{ 0x0E, \"Watcher\" },\n\t{ 0x0F, \"WatcherStatus\" },\n\t/* New in WV-CSP 1.3 */\n\t{ 0x1B, \"AnswerOption\"},\n\t{ 0x1C, \"AnswerOptionID\" },\n\t{ 0x1D, \"AnswerOptions\"},\n\t{ 0x0B, \"AnswerOptionText\"},\n\t{ 0x1E, \"ApplicationID\"},\n\t{ 0x1F, \"AuthorizeAndGrant\"},\n\t{ 0x20, \"ChosenOptionID\"},\n\t{ 0x19, \"ClearPublicProfile\"},\n\t{ 0x13, \"Color\"},\n\t{ 0x21, \"ContactListNotify\"},\n\t{ 0x14, \"ContentName\"},\n\t{ 0x22, \"DefaultNotify\"},\n\t{ 0x39, \"ExtBlockETEM\"},\n\t{ 0x36, \"ExtendConversationID\"},\n\t{ 0x23, \"ExtendConversationUser\"},\n\t{ 0x10, \"Font\"},\n\t{ 0x18, \"FriendlyName\"},\n\t{ 0x34 , \"GetMap-Request\"},\n\t{ 0x35, \"GetMap-Response\"},\n\t{ 0x3A, \"GroupContentLimit\" },\n\t{ 0x24, \"InText\"},\n\t{ 0x15, \"Map\"},\n\t{ 0x3B, \"MessageTotalCount\"},\n\t{ 0x16, \"NotificationType\"},\n\t{ 0x17, \"NotificationTypeList\"},\n\t{ 0x1A, \"PublicProfile\"},\n\t{ 0x38, \"RequiresResponse\"},\n\t{ 0x25, \"SegmentCount\"},\n\t{ 0x26, \"SegmentID\"\t},\n\t{ 0x27, \"SegmentInfo\"},\n\t{ 0x28, \"SegmentReference\"},\n\t{ 0x11, \"Size\"},\n\t{ 0x12, \"Style\"\t},\n\t{ 0x29, \"SystemMessage\"},\n\t{ 0x2A, \"SystemMessageID\"},\n\t{ 0x2B, \"SystemMessageList\"},\n\t{ 0x2C, \"SystemMessageResponse\"},\n\t{ 0x2D, \"SystemMessageResponseList\" },\n\t{ 0x2F, \"SystemMessageText\"},\n\t{ 0x30, \"TryAgainTimeout\"},\n\t{ 0x3C, \"UnrecognizedUserID\"},\n\t{ 0x3F , \"UserIDList\"},\n\t{ 0x3D, \"UserIDPair\"},\n\t{ 0x31, \"UserNotify\"},\n\t{ 0x3E, \"ValidUserID\"},\n\t{ 0x32, \"VerificationKey\"},\n\t{ 0x33, \"VerificationMechanism\"},\n\t{ 0x37, \"WatcherCount\"},\n\n\t{ 0x00, NULL }\n};\n\n/* Access code page - continued (0x0A) */\nstatic const value_string wbxml_wv_csp_13_tags_cp10[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t/* New in WV-CSP 1.2 */\n\t{ 0x05, \"WV-CSP-NSDiscovery-Request\" },\n\t{ 0x06, \"WV-CSP-NSDiscovery-Response\" },\n\t{ 0x07, \"VersionList\"},\n\t/* New in WV-CSP 1.3 */\n\t{ 0x08, \"SubscribeNotification-Request\" },\n\t{ 0x09, \"UnsubscribeNotification-Request\" },\n\t{ 0x0A, \"Notification-Request\" },\n\t{ 0x0B, \"AdvancedCriteria\" },\n\t{ 0x0C, \"PairID\" },\n\t{ 0x0D, \"GetPublicProfile-Request\" },\n\t{ 0x0E, \"GetPublicProfile-Response\" },\n\t{ 0x0F, \"UpdatePublicProfile-Request\" },\n\t{ 0x10, \"DropSegment-Request\" },\n\t{ 0x11, \"ExtendConversation-Response\" },\n\t{ 0x12, \"ExtendConversation-Request\" },\n\t{ 0x13, \"GetSegment-Request\" },\n\t{ 0x14, \"GetSegment-Response\" },\n\t{ 0x15, \"SystemMessage-Request\" },\n\t{ 0x16, \"SystemMessage-User\" },\n\t{ 0x17, \"SearchPair\" },\n\t{ 0x18, \"SegmentContent\" },\n\n\t{ 0x00, NULL }\n};\n\n/* Common code page - continued (0x0B) */\nstatic const value_string wbxml_wv_csp_13_tags_cp11[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t/* New in WV-CSP 1.3 */\n\t{ 0x05, \"GrantListInUse\" },\n\t{ 0x06, \"BlockListInUse\" },\n\t{ 0x07, \"ContactListIDList\" },\n\t{ 0x08, \"AnswerOptionsText\" },\n\n\t{ 0x00, NULL }\n};\n\n\n/*****    Attribute Start tokens   *****/\n/* Common code page (0x00) */\nstatic const value_string wbxml_wv_csp_13_attrStart_cp0[] = {\n\t/* 0x00 -- 0x04 GLOBAL */\n\t{ 0x05, \"xmlns='http://www.wireless-village.org/CSP'\" },\n\t{ 0x06, \"xmlns='http://www.wireless-village.org/PA'\" },\n\t{ 0x07, \"xmlns='http://www.wireless-village.org/TRC'\" },\n\t/* New in WV-CSP 1.2 */\n\t{ 0x08, \"xmlns='http://www.openmobilealliance.org/DTD/WV-CSP'\" },\n\t{ 0x09, \"xmlns='http://www.openmobilealliance.org/DTD/WV-PA'\" },\n\t{ 0x0A, \"xmlns='http://www.openmobilealliance.org/DTD/WV-TRC'\" },\n\t/* New in WV-CSP 1.3 */\n\t{ 0x0B, \"xmlns='http://www.openmobilealliance.org/DTD/IMPS-CSP'\" },\n\t{ 0x0C, \"xmlns='http://www.openmobilealliance.org/DTD/IMPS-PA'\" },\n\t{ 0x0D, \"xmlns='http://www.openmobilealliance.org/DTD/IMPS-TRC'\" },\n\n\t{ 0x00, NULL }\n};\n\n/*****    Attribute Value tokens   *****/\n/*\n * Element value tokens\n */\nstatic const value_string vals_wv_csp_13_element_value_tokens[] = {\n\t/*\n\t * Common value tokens\n\t */\n\t{ 0x52, \"AC\" },\n\t{ 0x00, \"AccessType\" },\n\t{ 0x01, \"ActiveUsers\" },\n\t{ 0x02, \"Admin\" },\n\t{ 0x3C, \"ANC\" },\n\t{ 0x51, \"AND\" },\n\t{ 0x5A, \"ANU\" },\n\t{ 0x68, \"AP\" },\n\t{ 0x03, \"application/\" },\n\t{ 0x04, \"application/vnd.wap.mms-message\" },\n\t{ 0x05, \"application/x-sms\" },\n\t{ 0x8F, \"Aqua\" },\n\t{ 0x90, \"ATCL\" },\n\t{ 0x31, \"AutoDelete\" },\n\t{ 0x06, \"AutoJoin\" },\n\t{ 0x07, \"BASE64\" },\n\t{ 0x7B, \"Big\" },\n\t{ 0x80, \"Black\" },\n\t{ 0x53, \"BLC\" },\n\t{ 0x54, \"BLUC\" },\n\t{ 0x8D, \"Blue\" },\n\t{ 0x7D, \"Bold\" },\n\t{ 0xBC, \"C\" },\n\t{ 0x91, \"CLC\" },\n\t{ 0x55, \"CLCR\" },\n\t{ 0x56, \"CLD\" },\n\t{ 0x08, \"Closed\" },\n\t{ 0xBD, \"CURRENT_SUBSCRIBER\" },\n\t{ 0x09, \"Default\" },\n\t{ 0x34, \"DENIED\" },\n\t{ 0xAB, \"DETECT\" },\n\t{ 0x0A, \"DisplayName\" },\n\t{ 0xA6, \"DoNotNotify\" },\n\t{ 0xA0, \"EC\" },\n\t{ 0xBA, \"EG\" },\n\t{ 0x0B, \"F\" },\n\t{ 0xAC, \"FORKALL\" },\n\t{ 0xBE, \"FORMER_SUBSCRIBER\" },\n\t{ 0x87, \"Fuchsia\" },\n\t{ 0x0C, \"G\" },\n\t{ 0x57, \"GC\" },\n\t{ 0x58, \"GD\" },\n\t{ 0x59, \"GLC\" },\n\t{ 0xA1, \"GLUC\" },\n\t{ 0x32, \"GM\" },\n\t{ 0xA7, \"GMAU\" },\n\t{ 0xA8, \"GMG\" },\n\t{ 0xA9, \"GMR\" },\n\t{ 0xAA, \"GMU\" },\n\t{ 0x0D, \"GR\" },\n\t{ 0x35, \"GRANTED\" },\n\t{ 0x82, \"Gray\" },\n\t{ 0x88, \"Green\" },\n\t{ 0x0E, \"http://\" },\n\t{ 0x0F, \"https://\" },\n\t{ 0x7C, \"Huge\" },\n\t{ 0xA2, \"IA\" },\n\t{ 0xA3, \"IC\" },\n\t{ 0x10, \"image/\" },\n\t{ 0x11, \"Inband\" },\n\t{ 0x12, \"IM\" },\n\t{ 0x9F, \"IR\" },\n\t{ 0x7E, \"Italic\" },\n\t{ 0x89, \"Lime\" },\n\t{ 0x84, \"Maroon\" },\n\t{ 0x13, \"MaxActiveUsers\" },\n\t{ 0x7A, \"Medium\" },\n\t{ 0xBB, \"MinimumAge\" },\n\t{ 0x14, \"Mod\" },\n\t{ 0x15, \"Name\" },\n\t{ 0x8C, \"Navy\" },\n\t{ 0x16, \"None\" },\n\t{ 0x17, \"N\" },\n\t{ 0xAD, \"OEU\" },\n\t{ 0x8A, \"Olive\" },\n\t{ 0x18, \"Open\" },\n\t{ 0x19, \"Outband\" },\n\t{ 0x36, \"PENDING\" },\n\t{ 0x3A, \"PPU\" },\n\t{ 0x1A, \"PR\" },\n\t{ 0xBF, \"PRESENCE_ACCESS\" },\n\t{ 0x1B, \"Private\" },\n\t{ 0x1C, \"PrivateMessaging\" },\n\t{ 0x1D, \"PrivilegeLevel\" },\n\t{ 0x1E, \"Public\" },\n\t{ 0x86, \"Purple\" },\n\t{ 0x1F, \"P\" },\n\t{ 0xC0, \"R\" },\n\t{ 0x85, \"Red\" },\n\t{ 0x20, \"Request\" },\n\t{ 0x21, \"Response\" },\n\t{ 0x22, \"Restricted\" },\n\t{ 0x38, \"RequireInvitation\" },\n\t{ 0x23, \"ScreenName\" },\n\t{ 0x24, \"Searchable\" },\n\t{ 0x25, \"S\" },\n\t{ 0x26, \"SC\" },\n\t{ 0xAE, \"SERVERLOGIC\" },\n\t{ 0x37, \"ShowID\" },\n\t{ 0x81, \"Silver\" },\n\t{ 0x79, \"Small\" },\n\t{ 0x3B, \"SPA\" },\n\t{ 0x8E, \"Teal\" },\n\t{ 0x27, \"text/\" },\n\t{ 0x28, \"text/plain\" },\n\t{ 0x29, \"text/x-vCalendar\" },\n\t{ 0x2A, \"text/x-vCard\" },\n\t{ 0x39, \"Tiny\" },\n\t{ 0x2B, \"Topic\" },\n\t{ 0x2C, \"T\" },\n\t{ 0x2D, \"Type\" },\n\t{ 0x2E, \"U\" },\n\t{ 0x7F, \"Underline\" },\n\t{ 0x2F, \"US\" },\n\t{ 0x33, \"Validity\" },\n\t{ 0x83, \"White\" },\n\t{ 0x78, \"www.openmobilealliance.org\" },\n\t{ 0x30, \"www.wireless-village.org\" },\n\t{ 0x8B, \"Yellow\" },\n\t/*\n\t * Access value tokens\n\t */\n\t{ 0x3D, \"GROUP_ID\" },\n\t{ 0x3E, \"GROUP_NAME\" },\n\t{ 0x3F, \"GROUP_TOPIC\" },\n\t{ 0x40, \"GROUP_USER_ID_JOINED\" },\n\t{ 0x41, \"GROUP_USER_ID_OWNER\" },\n\t{ 0x42, \"HTTP\" },\n\t{ 0x43, \"SMS\" },\n\t{ 0x44, \"STCP\" },\n\t{ 0x45, \"SUDP\" },\n\t{ 0x46, \"USER_ALIAS\" },\n\t{ 0x47, \"USER_EMAIL_ADDRESS\" },\n\t{ 0x48, \"USER_FIRST_NAME\" },\n\t{ 0x49, \"USER_ID\" },\n\t{ 0x4A, \"USER_LAST_NAME\" },\n\t{ 0x4B, \"USER_MOBILE_NUMBER\" },\n\t{ 0x4C, \"USER_ONLINE_STATUS\" },\n\t{ 0x4D, \"WAPSMS\" },\n\t{ 0x4E, \"WAPUDP\" },\n\t{ 0x4F, \"WSP\" },\n\t{ 0x50, \"GROUP_USER_ID_AUTOJOIN\" },\n\t/*\n\t * Presence value tokens\n\t */\n\t{ 0x5B, \"ANGRY\" },\n\t{ 0x5C, \"ANXIOUS\" },\n\t{ 0x5D, \"ASHAMED\" },\n\t{ 0x5F, \"AVAILABLE\" },\n\t{ 0x60, \"BORED\" },\n\t{ 0x61, \"CALL\" },\n\t{ 0x62, \"CLI\" },\n\t{ 0x63, \"COMPUTER\" },\n\t{ 0x64, \"DISCREET\" },\n\t{ 0x65, \"EMAIL\" },\n\t{ 0x66, \"EXCITED\" },\n\t{ 0x67, \"HAPPY\" },\n\t{ 0x6B, \"IN_LOVE\" },\n\t{ 0x6C, \"INVINCIBLE\" },\n\t{ 0x6D, \"JEALOUS\" },\n\t{ 0x6E, \"MMS\" },\n\t{ 0x6F, \"MOBILE_PHONE\" },\n\t{ 0x70, \"NOT_AVAILABLE\" },\n\t{ 0x71, \"OTHER\" },\n\t{ 0x72, \"PDA\" },\n\t{ 0x73, \"SAD\" },\n\t{ 0x74, \"SLEEPY\" },\n\t{ 0x75, \"SMS\" },\n\t/*\n\t * Access value tokens - continued\n\t */\n\t{ 0x93, \"USER_CITY\" },\n\t{ 0x94, \"USER_COUNTRY\" },\n\t{ 0x95, \"USER_FRIENDLY_NAME\" },\n\t{ 0x96, \"USER_GENDER\" },\n\t{ 0x97, \"USER_INTENTION\" },\n\t{ 0x98, \"USER_INTERESTS_HOBBIES\" },\n\t{ 0x99, \"USER_MARITAL_STATUS\" },\n\t{ 0x9A, \"PRIORITYREJECT\" },\n\t{ 0x9B, \"PRIORITYSTORE\" },\n\t{ 0x9C, \"REJECT\" },\n\t{ 0x9D, \"SENDREJECT\" },\n\t{ 0x9E, \"SENDSTORE\" },\n\t{ 0xA4, \"SSMS\" },\n\t{ 0xA5, \"SHTTP\" },\n\t{ 0xAF, \"PP_AGE\" },\n\t{ 0xB0, \"PP_CITY\" },\n\t{ 0xB1, \"PP_COUNTRY\" },\n\t{ 0xB2, \"PP_FRIENDLY_NAME\" },\n\t{ 0xB3, \"PP_FREE_TEXT\" },\n\t{ 0xB4, \"PP_GENDER\" },\n\t{ 0xB5, \"PP_INTENTION\" },\n\t{ 0xB6, \"PP_INTERESTS\" },\n\t{ 0xB7, \"PP_MARITAL_STATUS\" },\n\t{ 0xB8, \"USER_AGE_MAX\" },\n\t{ 0xB9, \"USER_AGE_MIN\" },\n\n\t{ 0x00, NULL }\n};\n\n/***** Token code page aggregation *****/\nstatic char *\next_t_0_wv_cspc_13(wmem_allocator_t* allocator, tvbuff_t *tvb _U_, uint32_t value, uint32_t str_tbl _U_)\n{\n\tchar *str = wmem_strdup_printf(allocator, \"Common Value: '%s'\",\n\t\t\t\t    val_to_str(allocator, value, vals_wv_csp_13_element_value_tokens,\n\t\t\t\t\t       \"<Unknown WV-CSP 1.3 Common Value token 0x%X>\"));\n\treturn str;\n}\n\n#define wbxml_wv_csp_13_global wbxml_wv_csp_12_global\t\t/*TODO*/\n\nstatic const value_valuestring wbxml_wv_csp_13_tags[] = {\n\t{  0, wbxml_wv_csp_13_tags_cp0 },\n\t{  1, wbxml_wv_csp_13_tags_cp1 },\n\t{  2, wbxml_wv_csp_13_tags_cp2 },\n\t{  3, wbxml_wv_csp_13_tags_cp3 },\n\t{  4, wbxml_wv_csp_13_tags_cp4 },\n\t{  5, wbxml_wv_csp_13_tags_cp5 },\n\t{  6, wbxml_wv_csp_13_tags_cp6 },\n\t{  7, wbxml_wv_csp_13_tags_cp7 },\n\t{  8, wbxml_wv_csp_13_tags_cp8 },\n\t{  9, wbxml_wv_csp_13_tags_cp9 },\n\t{ 10, wbxml_wv_csp_13_tags_cp10 },\n\t{ 11, wbxml_wv_csp_13_tags_cp11 },\n\t{  0, NULL }\n};\n\nstatic const value_valuestring wbxml_wv_csp_13_attrStart[] = {\n\t{ 0, wbxml_wv_csp_13_attrStart_cp0 },\n\t{ 0, NULL }\n};\n\nstatic const wbxml_decoding decode_wv_cspc_13 = {\n\t\"Wireless-Village Client-Server Protocol 1.3\",\n\t\"WV-CSP 1.3\",\n\t{ ext_t_0_wv_cspc_13, NULL, NULL },\n\twv_csp13_opaque_binary_tag,\n\twv_csp13_opaque_literal_tag,\n\tdefault_opaque_binary_attr,\n\tdefault_opaque_literal_attr,\n\twbxml_wv_csp_13_global,\n\twbxml_wv_csp_13_tags,\n\twbxml_wv_csp_13_attrStart,\n\tNULL\n};\n\n\n\n\n\n/****************************** Discriminators ******************************/\n/* Discriminator for WV-CSP; allows version detection based on parsing parts\n * of the start of the WBXML body.\n */\nstatic const wbxml_decoding *\nwv_csp_discriminator(tvbuff_t *tvb, uint32_t offset)\n{\n\tuint32_t magic_1 = tvb_get_ntohl(tvb, offset + 0);\n\tuint16_t magic_2 = tvb_get_ntohs(tvb, offset + 4);\n\n\tif (magic_1 == 0xFE050331 && magic_2 == 0x2e30)\n\t\t{\n\t\t\t/* FE 05 03 31 2E 30 --> WV-CSP 1.0 */\n\t\t\treturn &decode_wv_cspc_10;\n\t\t}\n\telse if (magic_1 == 0xC9050331 && magic_2 == 0x2e31)\n\t\t{\n\t\t\t/* C9 05 03 31 2E 31 --> WV-CSP 1.1 */\n\t\t\treturn &decode_wv_cspc_11;\n\t\t}\n\telse if (magic_1 == 0xC9080331 && magic_2 == 0x2e32)\n\t\t{\n\t\t\t/* C9 08 03 31 2E 32 --> WV-CSP 1.2 */\n\t\t\treturn &decode_wv_cspc_12;\n\t\t}\n\telse if ( magic_1 == 0xC90B0331 && magic_2 == 0x2E33)\n\t\t{\n\t\t\t/* C9 0B 03 31 2E 33 --> WV-CSP 1.3 */\n\t\t\treturn &decode_wv_cspc_13;\n\t\t}\n\n\n\t/* Default: WV-CSP 1.2 */\n\treturn &decode_wv_cspc_12;\n}\n\n/********************** WBXML token mapping aggregation **********************/\n\nstatic const wbxml_decoding *get_wbxml_decoding_from_public_id (uint32_t publicid);\nstatic const wbxml_decoding *get_wbxml_decoding_from_content_type (\n\t\t\t\t\t\t\t\t   const char *content_type, tvbuff_t *tvb, uint32_t offset);\n\n\n/**\n ** Aggregation of content type and aggregated code pages\n ** Content type map lookup will stop at the 1st entry with 3rd member = false\n **/\n\n/*\n * The following map contains entries registered with a registered WBXML\n * public ID. See WAP WINA or OMA OMNA for registered values:\n * http://www.openmobilealliance.org/tech/omna/ */\n static const wbxml_integer_list well_known_public_id_list[] = {\n\t /* 0x00 - Unknown or missing Public ID */\n\t /* 0x01 - LITERAL PublicID - see String Table */\n\t { 0x02,\t&decode_wmlc_10 },\t/* WML 1.0 */\n\t /* 0x03 - WTA 1.0 */\n\t { 0x04,\t&decode_wmlc_11 },\t/* WML 1.1 */\n\t { 0x05,\t&decode_sic_10 },\t/* SI 1.0 */\n\t { 0x06,\t&decode_slc_10 },\t/* SL 1.0 */\n\t { 0x07,\t&decode_coc_10 },\t/* CO 1.0 */\n\t { 0x08,\t&decode_channelc_10 },\t/* CHANNEL 1.0 */\n\t { 0x09,\t&decode_wmlc_12 },\t/* WML 1.2 */\n\t { 0x0A,\t&decode_wmlc_13 },\t/* WML 1.3 */\n\t { 0x0B,\t&decode_provc_10 },\t/* PROV 1.0 */\n\t /* 0x0C - WTA-WML 1.2 */\n\t { 0x0D,\t&decode_emnc_10 },\t/* EMN 1.0 */\n\t /* 0x0E - DRMREL 1.0 */\n\t { 0x0F,\t&decode_wv_cspc_10 },\t/* WV-CSP 1.0 */\n\t { 0x10,\t&decode_wv_cspc_11 },\t/* WV-CSP 1.1 */\n\t /*See http://www.openmobilealliance.org/tech/omna/omna-wbxml-public-docid.htm */\n\t { 0x11,\t&decode_wv_cspc_12 },\t/* OMA IMPS - CSP protocol DTD v1.2 */\n\t { 0x12,\t&decode_wv_cspc_13 },\t/* OMA IMPS - CSP protocol DTD v1.3 */\n\t { 0x020B,\t&decode_nokiaprovc_70 },/* Nokia OTA Provisioning 7.0 */\n\t { 0x0FD1,\t&decode_syncmlc_10 },\t/* SyncML 1.0 */\n\t { 0x0FD3,\t&decode_syncmlc_11 },\t/* SyncML 1.1 */\n\t /* Note: I assumed WML+ 1.x would be not that different from WML 1.x,\n\t  *       the real mapping should come from Phone.com (OpenWave)! */\n\t { 0x1108,\t&decode_wmlc_11 },\t/* Phone.com WMLC+ 1.1 - not 100% correct */\n\t { 0x110D,\t&decode_wmlc_13 },\t/* Phone.com WMLC+ 1.3 - not 100% correct */\n\n\t { 0x1201,\t&decode_syncmlc_12 },\t/* SyncML 1.2 */\n\n\t { 0x00,\tNULL }\n };\n\n/* The following map contains entries only registered with a literal media\n * type. */\nstatic const wbxml_literal_list content_type_list[] = {\n\t{\t\"application/x-wap-prov.browser-settings\",\n\t\tNULL,\n\t\t&decode_nokiaprovc_70\n\t},\n\t{\t\"application/x-wap-prov.browser-bookmarks\",\n\t\tNULL,\n\t\t&decode_nokiaprovc_70\n\t},\n\t{\t\"application/vnd.wv.csp.wbxml\",\n\t\twv_csp_discriminator,\n\t\t&decode_wv_cspc_11\n\t},\n\t{\t\"application/vnd.ms-sync.wbxml\",\n\t\tNULL,\n\t\t&decode_mssync_10\n\t},\n\t{\t\"application/vnd.ms-sync\",\n\t\tNULL,\n\t\t&decode_mssync_10\n\t},\n\t{\tNULL, NULL, NULL }\n};\n\n\n/* Returns a pointer to the WBXML token map for the given WBXML public\n * identifier value (see WINA for a table with defined identifiers). */\nstatic const wbxml_decoding *get_wbxml_decoding_from_public_id (uint32_t public_id)\n{\n\tconst wbxml_decoding *map = NULL;\n\n\tDebugLog((\"get_wbxml_decoding_from_public_id: public_id = %u\\n\",\n\t\t  public_id));\n\tif (public_id >= 2) {\n\t\tconst wbxml_integer_list *item = well_known_public_id_list;\n\n\t\twhile (item && item->public_id && item->map) {\n\t\t\tif (item->public_id == public_id) {\n\t\t\t\tmap = item->map;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\titem++;\n\t\t}\n\t}\n\treturn map;\n}\n\nstatic const wbxml_decoding *get_wbxml_decoding_from_content_type (\n\t\t\t\t\t\t\t\t   const char *content_type, tvbuff_t *tvb, uint32_t offset)\n{\n\tconst wbxml_decoding *map = NULL;\n\n\tDebugLog((\"get_wbxml_decoding_from_content_type: content_type = [%s]\\n\",\n\t\t  content_type));\n\tif (content_type && content_type[0]) {\n\t\tconst wbxml_literal_list *item = content_type_list;\n\n\t\twhile (item && item->content_type) {\n\t\t\tif (g_ascii_strcasecmp(content_type, item->content_type) == 0) {\n\t\t\t\t/* Try the discriminator */\n\t\t\t\tif (item->discriminator != NULL) {\n\t\t\t\t\tmap = item->discriminator(tvb, offset);\n\t\t\t\t}\n\t\t\t\tif (map == NULL) {\n\t\t\t\t\tmap = item->map;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\titem++;\n\t\t}\n\t}\n\treturn map;\n}\n\n\n/* WBXML content token mapping depends on the following parameters:\n *   - Content type (uint32_t)\n *   - Token type (global, tags, attrStart, attrValue)\n *   - Code page for tag and attribute\n *\n * This results in the following steps:\n *   1. Retrieve content type mapping\n *   2. If exists, retrieve token type mapping\n *   3. If exists, retrieve required code page\n *   4. If exists, retrieve token mapping\n */\n\n#define wbxml_UNDEFINED_TOKEN                   \\\n\t\"(Requested token not defined for this content type)\"\n#define wbxml_UNDEFINED_TOKEN_CODE_PAGE         \\\n\t\"(Requested token code page not defined for this content type)\"\n#define wbxml_UNDEFINED_TOKEN_MAP               \\\n\t\"(Requested token map not defined for this content type)\"\n/* Return token mapping for a given content mapping entry. */\nstatic const char *\nmap_token (const value_valuestring *token_map, uint8_t codepage, uint8_t token) {\n\tconst value_string *vs;\n\tconst char         *s;\n\n\tif (token_map) { /* Found map */\n\t\tif ((vs = val_to_valstr (codepage, token_map))) {\n\t\t\t/* Found codepage map */\n\t\t\ts = try_val_to_str (token, vs);\n\t\t\tif (s) { /* Found valid token */\n\t\t\t\tDebugLog((\"map_token(codepage = %u, token = %u: [%s]\\n\", codepage, token, s));\n\t\t\t\treturn s;\n\t\t\t}\n\t\t\t/* No valid token mapping in specified code page of token map */\n\t\t\tDebugLog((\"map_token(codepage = %u, token = %u: \"\n\t\t\t\t  wbxml_UNDEFINED_TOKEN \"\\n\", codepage, token));\n\t\t\treturn wbxml_UNDEFINED_TOKEN;\n\t\t}\n\t\t/* There is no token map entry for the requested code page */\n\t\tDebugLog((\"map_token(codepage = %u, token = %u: \"\n\t\t\t  wbxml_UNDEFINED_TOKEN_CODE_PAGE \"\\n\", codepage, token));\n\t\treturn wbxml_UNDEFINED_TOKEN_CODE_PAGE;\n\t}\n\t/* The token map does not exist */\n\tDebugLog((\"map_token(codepage = %u, token = %u: \"\n\t\t  wbxml_UNDEFINED_TOKEN_MAP \"\\n\", codepage, token));\n\treturn wbxml_UNDEFINED_TOKEN_MAP;\n}\n\n\n\n/* Parse and display the WBXML string table. */\nstatic void\nshow_wbxml_string_table (proto_tree *tree, packet_info* pinfo, tvbuff_t *tvb, uint32_t str_tbl,\n\t\t\t uint32_t str_tbl_len, unsigned charset)\n{\n\tunsigned encoding = mibenum_charset_to_encoding(charset);\n\tuint32_t off = str_tbl;\n\tuint32_t end = str_tbl + str_tbl_len;\n\tproto_tree *item_tree;\n\tproto_item *ti;\n\tconst uint8_t *str;\n\tint len;\n\n\twhile (off < end) {\n\t\t/*\n\t\t * XXX - use the string encoding.\n\t\t */\n\t\titem_tree = proto_tree_add_subtree_format (tree, tvb, off, 0,\n\t\t\t\t\t\t\t   ett_wbxml_string_table_item,\n\t\t\t\t\t\t\t   &ti,\n\t\t\t\t\t\t\t   \"%u:\",\n\t\t\t\t\t\t\t   off - str_tbl);\n\t\tproto_tree_add_uint (item_tree,\n\t\t    hf_wbxml_string_table_item_offset,\n\t\t    tvb, 0, 0, off - str_tbl);\n\t\tproto_tree_add_item_ret_string_and_length (item_tree,\n\t\t    hf_wbxml_string_table_item_string,\n\t\t    tvb, off, -1, encoding, pinfo->pool, &str, &len);\n\t\tproto_item_append_text(ti, \" '%s'\", format_text(pinfo->pool, str, strlen(str)));\n\t\tproto_item_set_len(ti, len);\n\t\toff += len;\n\t}\n}\n\n\n/* Indentation code is based on a static const array of space characters.\n * At least one single space is returned */\nstatic const char indent_buffer[514] = \" \"\n\t\"                                                                \"\n\t\"                                                                \"\n\t\"                                                                \"\n\t\"                                                                \"\n\t\"                                                                \"\n\t\"                                                                \"\n\t\"                                                                \"\n\t\"                                                                \"\n\t; /* Generate XML indentation (length = 1 + 2 * 256 + 1 for '\\0') */\n\nstatic const char * Indent (uint8_t level) {\n\treturn indent_buffer + (512 - 2 * (level));\n}\n\n\n/********************\n * WBXML tag tokens *\n ********************\n *\n * Bit Mask  : Example\n * -------------------\n * 00.. .... : <tag />\n *\n * 01.. .... : <tag>\n *               CONTENT\n *             </tag>\n *\n * 10.. .... : <tag\n *               atrtribute1=\"value1\"\n *               atrtribute2=\"value2\"\n *             />\n *\n * 11.. .... : <tag\n *               atrtribute1=\"value1\"\n *               atrtribute2=\"value2\"\n *             >\n *               CONTENT\n *             </tag>\n *\n * NOTES\n *   - An XML PI is parsed as an attribute list (same syntax).\n *   - A code page switch only applies to the single token that follows.\n */\n\n/**************************\n * WBXML Attribute tokens *\n **************************\n * Bit Mask  : Example\n * -------------------\n * 0... .... : attr=             (attribute name)\n *             href='http://'    (attribute name with start of attribute value)\n * 1... .... : 'www.'            (attribute value, or part of it)\n *\n */\n\n\n/* This function parses the WBXML and maps known token interpretations\n * to the WBXML tokens. As a result, the original XML document can be\n * recreated. Indentation is generated in order to ease reading.\n *\n * This function performs attribute list parsing.\n *\n * The wbxml_decoding entry *map contains the actual token mapping.\n *\n * NOTE: See above for known token mappings.\n */\nstatic uint32_t\nparse_wbxml_attribute_list_defined (proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo,\n\t\t\t\t    uint32_t offset, uint32_t str_tbl, uint8_t *codepage_attr,\n\t\t\t\t    const wbxml_decoding *map)\n{\n\tuint32_t     tvb_len = tvb_reported_length (tvb);\n\tuint32_t     off     = offset;\n\tuint32_t     len;\n\tunsigned     str_len;\n\tuint32_t     ent;\n\tuint32_t     idx;\n\tuint8_t      peek;\n\tuint8_t      attr_save_known   = 0; /* Will contain peek & 0x3F (attr identity) */\n\tconst char  *attr_save_literal = NULL; /* Will contain the LITERAL attr identity */\n\tconst char *str;\n\tunsigned     recursion_level = p_get_proto_depth(pinfo, proto_wbxml);\n\tunsigned     encoding = GPOINTER_TO_UINT(p_get_proto_data(pinfo->pool, pinfo, proto_wbxml, 0));\n\n\tDebugLog((\"parse_wbxml_attr_defined (level = %u, offset = %u)\\n\", recursion_level, offset));\n\t/* Parse attributes */\n\twhile (off < tvb_len) {\n\t\tpeek = tvb_get_uint8 (tvb, off);\n\t\tDebugLog((\"ATTR: (top of while) level = %3u, peek = 0x%02X, \"\n\t\t\t  \"off = %u, tvb_len = %u\\n\", recursion_level, peek, off, tvb_len));\n\t\tif ((peek & 0x3F) < 5) switch (peek) { /* Global tokens\n\t\t\t\t\t\t\t  in state = ATTR */\n\t\tcase 0x00: /* SWITCH_PAGE */\n\t\t\t*codepage_attr = tvb_get_uint8 (tvb, off+1);\n\t\t\tproto_tree_add_uint_format(tree, hf_wbxml_switch_page, tvb, off, 2, *codepage_attr,\n                         \"      |  Attr | A -->%3d | SWITCH_PAGE (Attr code page)    |\",\n\t\t\t\t\t     *codepage_attr);\n\t\t\toff += 2;\n\t\t\tbreak;\n\t\tcase 0x01: /* END */\n\t\t\t/* BEWARE\n\t\t\t *   The Attribute END token means either \">\" or \"/>\"\n\t\t\t *   and as a consequence both must be treated separately.\n\t\t\t *   This is done in the TAG state parser.\n\t\t\t */\n\t\t\toff++;\n\t\t\tDebugLog((\"ATTR: level = %u, Return: len = %u\\n\",\n\t\t\t\t  recursion_level, off - offset));\n\t\t\treturn (off - offset);\n\t\tcase 0x02: /* ENTITY */\n\t\t\tent = tvb_get_uintvar (tvb, off+1, &len, pinfo, &ei_wbxml_oversized_uintvar);\n\t\t\tif (len <= tvb_len) {\n\t\t\t\tproto_tree_add_uint_format(tree, hf_wbxml_entity, tvb, off, 1+len, ent,\n\t\t\t\t\t         \"  %3d |  Attr | A %3d    | ENTITY                          |     %s'&#%u;'\",\n\t\t\t\t\t         recursion_level, *codepage_attr, Indent (recursion_level), ent);\n\t\t\t\toff += 1+len;\n\t\t\t} else {\n\t\t\t\t/* Stop processing as it is impossible to parse now */\n\t\t\t\toff = tvb_len;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x03: /* STR_I */\n\t\t\tstr = tvb_get_stringz_enc(pinfo->pool, tvb, off+1, &len, encoding);\n\t\t\tproto_tree_add_string_format(tree, hf_wbxml_str_i, tvb, off, 1+len, str,\n\t\t\t\t\t     \"  %3d |  Attr | A %3d    | STR_I (Inline string)           |     %s\\'%s\\'\",\n\t\t\t\t\t     recursion_level, *codepage_attr, Indent (recursion_level), str);\n\t\t\toff += 1+len;\n\t\t\tbreak;\n\t\tcase 0x04: /* LITERAL */\n\t\t\t/* ALWAYS means the start of a new attribute,\n\t\t\t * and may only contain the NAME of the attribute.\n\t\t\t */\n\t\t\tidx = tvb_get_uintvar (tvb, off+1, &len, pinfo, &ei_wbxml_oversized_uintvar);\n\t\t\tif (len <= tvb_len) {\n\t\t\t\tattr_save_known = 0;\n\t\t\t\tattr_save_literal = tvb_get_stringz_enc(pinfo->pool, tvb, str_tbl+idx, &str_len, encoding);\n\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_literal, tvb, off, 1+len, attr_save_literal,\n\t\t\t\t\t         \"  %3d |  Attr | A %3d    | LITERAL (Literal Attribute)     |   %s<%s />\",\n\t\t\t\t\t         recursion_level, *codepage_attr, Indent (recursion_level), attr_save_literal);\n\t\t\t\toff += 1+len;\n\t\t\t} else {\n\t\t\t\t/* Stop processing as it is impossible to parse now */\n\t\t\t\toff = tvb_len;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x40: /* EXT_I_0 */\n\t\tcase 0x41: /* EXT_I_1 */\n\t\tcase 0x42: /* EXT_I_2 */\n\t\t\t/* Extension tokens */\n\t\t\tstr = tvb_get_stringz_enc(pinfo->pool, tvb, off+1, &len, encoding);\n\t\t\tproto_tree_add_string_format(tree, hf_wbxml_ext_i, tvb, off, 1+len, str,\n\t\t\t\t\t     \"  %3d |  Attr | A %3d    | EXT_I_%1x    (Extension Token)    |     %s(%s: \\'%s\\')\",\n\t\t\t\t\t     recursion_level, *codepage_attr, peek & 0x0f, Indent (recursion_level),\n\t\t\t\t\t     ((map != NULL) ? map_token (map->global, 0, peek) : \"Inline string extension\"), str);\n\t\t\toff += 1+len;\n\t\t\tbreak;\n\t\t\t/* 0x43 impossible in ATTR state */\n\t\t\t/* 0x44 impossible in ATTR state */\n\t\tcase 0x80: /* EXT_T_0 */\n\t\tcase 0x81: /* EXT_T_1 */\n\t\tcase 0x82: /* EXT_T_2 */\n\t\t\t/* Extension tokens */\n\t\t\tidx = tvb_get_uintvar (tvb, off+1, &len, pinfo, &ei_wbxml_oversized_uintvar);\n\t\t\t{\n\t\t\t\tchar *s;\n\t\t\t\tif (map != NULL) {\n\n\t\t\t\t\tif (map->ext_t[peek & 0x03])\n\t\t\t\t\t\ts = (map->ext_t[peek & 0x03])(pinfo->pool, tvb, idx, str_tbl);\n\t\t\t\t\telse\n\t\t\t\t\t\ts = wmem_strdup_printf(pinfo->pool, \"EXT_T_%1x (%s)\", peek & 0x03,\n\t\t\t\t\t\t\t\t    map_token (map->global, 0, peek));\n\t\t\t\t} else {\n\t\t\t\t\ts = wmem_strdup_printf(pinfo->pool, \"Extension Token, integer value: (%u\", idx);\n\t\t\t\t}\n\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_ext_t, tvb, off, 1+len, s,\n\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    | EXT_T_%1x    (Extension Token)    | %s%s)\",\n\t\t\t\t\t\t     recursion_level, *codepage_attr, peek & 0x0f, Indent (recursion_level),\n\t\t\t\t\t\t     s);\n\t\t\t}\n\t\t\tif (len <= tvb_len) {\n\t\t\t\toff += 1+len;\n\t\t\t} else {\n\t\t\t\t/* Stop processing as it is impossible to parse now */\n\t\t\t\toff = tvb_len;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x83: /* STR_T */\n\t\t\tidx = tvb_get_uintvar (tvb, off+1, &len, pinfo, &ei_wbxml_oversized_uintvar);\n\t\t\tif (len <= tvb_len) {\n\t\t\t\tstr = tvb_get_stringz_enc(pinfo->pool, tvb, str_tbl+idx, &str_len, encoding);\n\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_str_t, tvb, off, 1+len, str,\n\t\t\t\t\t         \"  %3d |  Attr | A %3d    | STR_T (Tableref string)         |     %s\\'%s\\'\",\n\t\t\t\t\t         recursion_level, *codepage_attr, Indent (recursion_level), str);\n\t\t\t\toff += 1+len;\n\t\t\t} else {\n\t\t\t\t/* Stop processing as it is impossible to parse now */\n\t\t\t\toff = tvb_len;\n\t\t\t}\n\t\t\tbreak;\n\t\t\t/* 0x84 impossible in ATTR state */\n\t\tcase 0xC0: /* EXT_0 */\n\t\tcase 0xC1: /* EXT_1 */\n\t\tcase 0xC2: /* EXT_2 */\n\t\t\t/* Extension tokens */\n\t\t\tstr = (map != NULL) ? map_token (map->global, 0, peek) : \"Single-byte extension\";\n\t\t\tproto_tree_add_string_format(tree, hf_wbxml_extension_token, tvb, off, 1, str,\n\t\t\t\t\t     \"  %3d |  Attr | A %3d    | EXT_%1x      (Extension Token)    |     %s(%s)\",\n\t\t\t\t\t     recursion_level, *codepage_attr, peek & 0x0f, Indent (recursion_level), str);\n\t\t\toff++;\n\t\t\tbreak;\n\t\tcase 0xC3: /* OPAQUE - WBXML 1.1 and newer */\n\t\t\tif (tvb_get_uint8 (tvb, 0)) { /* WBXML 1.x (x > 0) */\n\t\t\t\tif (map != NULL) {\n\t\t\t\t\tchar *tmp_str;\n\t\t\t\t\tif (attr_save_known) { /* Knwon attribute */\n\t\t\t\t\t\tif (map->opaque_binary_attr) {\n\t\t\t\t\t\t\ttmp_str = map->opaque_binary_attr(tvb, off + 1,\n\t\t\t\t\t\t\t\t\t      attr_save_known, *codepage_attr, &len, pinfo);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttmp_str = default_opaque_binary_attr(tvb, off + 1,\n\t\t\t\t\t\t\t\t\t\t attr_save_known, *codepage_attr, &len, pinfo);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else { /* lITERAL attribute */\n\t\t\t\t\t\tif (map->opaque_literal_tag) {\n\t\t\t\t\t\t\ttmp_str = map->opaque_literal_attr(tvb, off + 1,\n\t\t\t\t\t\t\t\t\t       attr_save_literal, *codepage_attr, &len, pinfo);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttmp_str = default_opaque_literal_attr(tvb, off + 1,\n\t\t\t\t\t\t\t\t\t\t  attr_save_literal, *codepage_attr, &len, pinfo);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (len <= tvb_len) {\n\t\t\t\t\t\tproto_tree_add_bytes_format(tree, hf_wbxml_opaque_data, tvb, off, 1 + len, NULL,\n\t\t\t\t\t\t\t         \"  %3d |  Attr | A %3d    | OPAQUE (Opaque data)            |       %s%s\",\n\t\t\t\t\t\t\t         recursion_level, *codepage_attr, Indent (recursion_level), tmp_str);\n\t\t\t\t\t\toff += 1 + len;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* Stop processing as it is impossible to parse now */\n\t\t\t\t\t\toff = tvb_len;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tidx = tvb_get_uintvar (tvb, off+1, &len, pinfo, &ei_wbxml_oversized_uintvar);\n\t\t\t\t\tif ((len <= tvb_len) && (idx < tvb_len)) {\n\t\t\t\t\t\tproto_tree_add_bytes_format(tree, hf_wbxml_opaque_data, tvb, off, 1 + len + idx, NULL,\n\t\t\t\t\t\t\t     \"  %3d |  Attr | A %3d    | OPAQUE (Opaque data)            |       %s(%u bytes of opaque data)\",\n\t\t\t\t\t\t\t     recursion_level, *codepage_attr, Indent (recursion_level), idx);\n\t\t\t\t\t\toff += 1+len+idx;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* Stop processing as it is impossible to parse now */\n\t\t\t\t\t\toff = tvb_len;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else { /* WBXML 1.0 - RESERVED_2 token (invalid) */\n\t\t\t\tproto_tree_add_none_format(tree, hf_wbxml_reserved_2, tvb, off, 1,\n\t\t\t\t\t\t\t     \"  %3d |  Attr | A %3d    | RESERVED_2     (Invalid Token!) | WBXML 1.0 parsing stops here.\",\n\t\t\t\t\t\t\t     recursion_level, *codepage_attr);\n\t\t\t\t/* Stop processing as it is impossible to parse now */\n\t\t\t\toff = tvb_len;\n\t\t\t\tDebugLog((\"ATTR: level = %u, Return: len = %u\\n\",\n\t\t\t\t\t  recursion_level, off - offset));\n\t\t\t\treturn (off - offset);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t/* 0xC4 impossible in ATTR state */\n\t\tdefault:\n\t\t\tproto_tree_add_none_format(tree, hf_wbxml_invalid_token, tvb, off, 1,\n\t\t\t\t\t     \"  %3d |  Attr | A %3d    | %-10s     (Invalid Token!) | WBXML parsing stops here.\",\n\t\t\t\t\t     recursion_level, *codepage_attr, val_to_str_ext(pinfo->pool, peek, &vals_wbxml1x_global_tokens_ext, \"(unknown 0x%x)\"));\n\t\t\t/* Move to end of buffer */\n\t\t\toff = tvb_len;\n\t\t\tbreak;\n\t\t} else { /* Known attribute token */\n\t\t\tconst char* s;\n\t\t\tif (peek & 0x80) { /* attrValue */\n\t\t\t\tif (map != NULL) {\n\t\t\t\t\ts = map_token (map->attrValue, *codepage_attr, peek);\n\t\t\t\t} else {\n\t\t\t\t\ts = wmem_strdup_printf(pinfo->pool, \"attrValue_0x%02X\", peek);\n\t\t\t\t}\n\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_known_attrvalue, tvb, off, 1, s,\n\t\t\t\t\t\t     \"  %3d |  Attr | A %3d    |   Known attrValue 0x%02X          |       %s%s\",\n\t\t\t\t\t\t     recursion_level, *codepage_attr, peek & 0x7f, Indent (recursion_level),\n\t\t\t\t\t\t     s);\n\t\t\t\toff++;\n\t\t\t} else { /* attrStart */\n\t\t\t\tattr_save_known = peek & 0x7f;\n\t\t\t\tif (map != NULL) {\n\t\t\t\t\ts = map_token (map->attrStart, *codepage_attr, peek);\n\t\t\t\t} else {\n\t\t\t\t\ts = wmem_strdup_printf(pinfo->pool, \"attrStart_0x%02X\", peek);\n\t\t\t\t}\n\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_known_attrstart, tvb, off, 1, s,\n\t\t\t\t\t\t     \"  %3d |  Attr | A %3d    |   Known attrStart 0x%02X          |   %s%s\",\n\t\t\t\t\t\t     recursion_level, *codepage_attr, attr_save_known, Indent (recursion_level),\n\t\t\t\t\t\t     s);\n\t\t\t\toff++;\n\t\t\t}\n\t\t}\n\t} /* End WHILE */\n\tDebugLog((\"ATTR: level = %u, Return: len = %u (end of function body)\\n\",\n\t\t  recursion_level, off - offset));\n\treturn (off - offset);\n}\n\n\n/* This function parses the WBXML and maps known token interpretations\n * to the WBXML tokens. As a result, the original XML document can be\n * recreated. Indentation is generated in order to ease reading.\n *\n * Attribute parsing is done in parse_wbxml_attribute_list_defined().\n *\n * The wbxml_decoding entry *map contains the actual token mapping.\n *\n * NOTE: In order to parse the content, some recursion is required.\n *       However, for performance reasons, recursion has been avoided\n *       where possible (tags without content within tags with content).\n *       This is achieved by means of the parsing_tag_content and tag_save*\n *       variables.\n *\n * NOTE: See above for known token mappings.\n *\n * NOTE: As tags can be opened and closed, a tag representation lookup\n *       may happen once or twice for a given tag. For efficiency reasons,\n *       the literal tag value is stored and used throughout the code.\n *       With the introduction of code page support, this solution is robust\n *       as the lookup only occurs once, removing the need for storage of\n *       the used code page.\n */\n#define WBXML_MAX_RECURSION_LEVEL 255\nstatic uint32_t\n// NOLINTNEXTLINE(misc-no-recursion)\nparse_wbxml_tag_defined (proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo, uint32_t offset,\n\t\t\t uint32_t str_tbl, uint8_t *codepage_stag, uint8_t *codepage_attr,\n\t\t\t const wbxml_decoding *map)\n{\n\tuint32_t     tvb_len  = tvb_reported_length (tvb);\n\tuint32_t     off      = offset;\n\tuint32_t     len;\n\tunsigned     str_len;\n\tuint32_t     ent;\n\tuint32_t     idx;\n\tuint8_t      peek;\n\tuint32_t     tag_len;                     /* Length of the index (uintvar) from a LITERAL tag */\n\tuint8_t      tag_save_known      = 0;     /* Will contain peek & 0x3F (tag identity) */\n\tuint8_t      tag_new_known       = 0;     /* Will contain peek & 0x3F (tag identity) */\n\tconst char  *tag_save_literal    = NULL;  /* Will contain the LITERAL tag identity */\n\tconst char  *tag_new_literal;             /* Will contain the LITERAL tag identity */\n\tconst char *str;\n\tuint8_t      parsing_tag_content = false; /* Are we parsing content from a\n\t\t\t\t\t\t     tag with content: <x>Content</x>\n\n\t\t\t\t\t\t     The initial state is false.\n\t\t\t\t\t\t     This state will trigger recursion. */\n\n\tunsigned     recursion_level = p_get_proto_depth(pinfo, proto_wbxml);\n\tunsigned     encoding = GPOINTER_TO_UINT(p_get_proto_data(pinfo->pool, pinfo, proto_wbxml, 0));\n\tif (recursion_level >= WBXML_MAX_RECURSION_LEVEL) {\n\t\tproto_tree_add_expert(tree, pinfo, &ei_wbxml_too_much_recursion, tvb, offset, tvb_captured_length_remaining(tvb, offset));\n\t\treturn tvb_len;\n\t}\n\tDebugLog((\"parse_wbxml_tag_defined (level = %u, offset = %u)\\n\", recursion_level, offset));\n\twhile (off < tvb_len) {\n\t\tpeek = tvb_get_uint8 (tvb, off);\n\t\tDebugLog((\"STAG: (top of while) level = %3u, peek = 0x%02X, off = %u, tvb_len = %u\\n\", recursion_level, peek, off, tvb_len));\n\t\tif ((peek & 0x3F) < 4) switch (peek) { /* Global tokens in state = STAG\n\t\t\t\t\t\t\t  but not the LITERAL tokens */\n\t\tcase 0x00: /* SWITCH_PAGE */\n\t\t\t*codepage_stag = tvb_get_uint8 (tvb, off+1);\n\t\t\tproto_tree_add_uint_format(tree, hf_wbxml_switch_page, tvb, off, 2, *codepage_stag,\n\t\t\t\t\t     \"      | Tag   | T -->%3d | SWITCH_PAGE (Tag code page)     |\",\n\t\t\t\t\t     *codepage_stag);\n\t\t\toff += 2;\n\t\t\tbreak;\n\t\tcase 0x01: /* END: only possible for Tag with Content */\n\t\t\tif (tag_save_known) { /* Known TAG */\n\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_end_known_tag, tvb, off, 1, tag_save_literal,\n\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    | END (Known Tag 0x%02X)            | %s</%s>\",\n\t\t\t\t\t\t     recursion_level, *codepage_stag,\n\t\t\t\t\t\t     tag_save_known, Indent (recursion_level),\n\t\t\t\t\t\t     tag_save_literal); /* We already looked it up! */\n\t\t\t} else { /* Literal TAG */\n\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_end_literal_tag, tvb, off, 1, tag_save_literal ? tag_save_literal : \"\",\n\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    | END (Literal Tag)               | %s</%s>\",\n\t\t\t\t\t\t     recursion_level, *codepage_stag, Indent (recursion_level), tag_save_literal ? tag_save_literal : \"\");\n\t\t\t}\n\t\t\trecursion_level--;\n\t\t\tp_set_proto_depth(pinfo, proto_wbxml, recursion_level);\n\t\t\toff++;\n\t\t\t/* Reset code page: not needed as return from recursion */\n\t\t\tDebugLog((\"STAG: level = %u, Return: len = %u\\n\", recursion_level, off - offset));\n\t\t\treturn (off - offset);\n\t\tcase 0x02: /* ENTITY */\n\t\t\tent = tvb_get_uintvar (tvb, off+1, &len, pinfo, &ei_wbxml_oversized_uintvar);\n\t\t\tproto_tree_add_uint_format(tree, hf_wbxml_entity, tvb, off, 1+len, ent,\n\t\t\t\t\t     \"  %3d | Tag   | T %3d    | ENTITY                          | %s'&#%u;'\",\n\t\t\t\t\t     recursion_level, *codepage_stag, Indent (recursion_level), ent);\n\t\t\toff += 1+len;\n\t\t\tbreak;\n\t\tcase 0x03: /* STR_I */\n\t\t\tstr = tvb_get_stringz_enc(pinfo->pool, tvb, off+1, &len, encoding);\n\t\t\tproto_tree_add_string_format(tree, hf_wbxml_str_i, tvb, off, 1+len, str,\n\t\t\t\t\t     \"  %3d | Tag   | T %3d    | STR_I (Inline string)           | %s\\'%s\\'\",\n\t\t\t\t\t     recursion_level, *codepage_stag, Indent(recursion_level),\n\t\t\t\t\t     str);\n\t\t\toff += 1+len;\n\t\t\tbreak;\n\t\tcase 0x40: /* EXT_I_0 */\n\t\tcase 0x41: /* EXT_I_1 */\n\t\tcase 0x42: /* EXT_I_2 */\n\t\t\t/* Extension tokens */\n\t\t\tstr = tvb_get_stringz_enc(pinfo->pool, tvb, off+1, &len, encoding);\n\t\t\tproto_tree_add_string_format(tree, hf_wbxml_ext_i, tvb, off, 1+len, str,\n\t\t\t\t\t     \"  %3d | Tag   | T %3d    | EXT_I_%1x    (Extension Token)    | %s(%s: \\'%s\\')\",\n\t\t\t\t\t     recursion_level, *codepage_stag,\n\t\t\t\t\t     peek & 0x0f, Indent (recursion_level),\n\t\t\t\t\t     ((map != NULL) ? map_token (map->global, 0, peek) : \"Inline string extension\"),\n\t\t\t\t\t     str);\n\t\t\toff += 1+len;\n\t\t\tbreak;\n\t\tcase 0x43: /* PI */\n\t\t\tproto_tree_add_none_format(tree, hf_wbxml_pi_xml, tvb, off, 1,\n\t\t\t\t\t     \"  %3d | Tag   | T %3d    | PI (XML Processing Instruction) | %s<?xml\",\n\t\t\t\t\t     recursion_level, *codepage_stag, Indent (recursion_level));\n\t\t\tlen = parse_wbxml_attribute_list_defined (tree, tvb, pinfo, off,\n\t\t\t\t\t\t\t\t  str_tbl, codepage_attr, map);\n\t\t\t/* Check that there is still room in packet */\n\t\t\toff += len;\n\t\t\tif (off >= tvb_len) {\n\t\t\t\tDebugLog((\"STAG: level = %u, ThrowException: len = %u (short frame)\\n\",\n\t\t\t\t\t\t\trecursion_level, off - offset));\n\t\t\t}\n\n\t\t\tproto_tree_add_none_format(tree, hf_wbxml_end_pi, tvb, off-1, 1,\n\t\t\t\t\t     \"  %3d | Tag   | T %3d    | END (PI)                        | %s?>\",\n\t\t\t\t\t     recursion_level, *codepage_stag, Indent (recursion_level));\n\t\t\tbreak;\n\t\tcase 0x80: /* EXT_T_0 */\n\t\tcase 0x81: /* EXT_T_1 */\n\t\tcase 0x82: /* EXT_T_2 */\n\t\t\t/* Extension tokens */\n\t\t\tidx = tvb_get_uintvar (tvb, off+1, &len, pinfo, &ei_wbxml_oversized_uintvar);\n\t\t\t{\n\t\t\t\tchar *s;\n\t\t\t\tif (map)\n\t\t\t\t{\n\t\t\t\t\tif (map->ext_t[peek & 0x03])\n\t\t\t\t\t\ts = (map->ext_t[peek & 0x03])(pinfo->pool, tvb, idx, str_tbl);\n\t\t\t\t\telse\n\t\t\t\t\t\ts = wmem_strdup_printf(pinfo->pool, \"EXT_T_%1x (%s)\", peek & 0x03,\n\t\t\t\t\t\t\t        map_token (map->global, 0, peek));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ts = wmem_strdup_printf(pinfo->pool, \"(Extension Token, integer value: %u)\", idx);\n\t\t\t\t}\n\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_ext_t, tvb, off, 1+len, s,\n\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    | EXT_T_%1x    (Extension Token)    | %s%s\",\n\t\t\t\t\t\t     recursion_level, *codepage_stag, peek & 0x0f, Indent (recursion_level), s);\n\t\t\t}\n\t\t\toff += 1+len;\n\t\t\tbreak;\n\t\tcase 0x83: /* STR_T */\n\t\t\tidx = tvb_get_uintvar (tvb, off+1, &len, pinfo, &ei_wbxml_oversized_uintvar);\n\t\t\tstr = tvb_get_stringz_enc(pinfo->pool, tvb, str_tbl+idx, &str_len, encoding);\n\t\t\tproto_tree_add_string_format(tree, hf_wbxml_str_t, tvb, off, 1+len, str,\n\t\t\t\t\t     \"  %3d | Tag   | T %3d    | STR_T (Tableref string)         | %s\\'%s\\'\",\n\t\t\t\t\t     recursion_level, *codepage_stag, Indent (recursion_level), str);\n\t\t\toff += 1+len;\n\t\t\tbreak;\n\t\tcase 0xC0: /* EXT_0 */\n\t\tcase 0xC1: /* EXT_1 */\n\t\tcase 0xC2: /* EXT_2 */\n\t\t\t/* Extension tokens */\n\t\t\tstr = (map != NULL) ? map_token (map->global, 0, peek) : \"Single-byte extension\";\n\t\t\tproto_tree_add_string_format(tree, hf_wbxml_extension_token, tvb, off, 1, str,\n\t\t\t\t\t     \"  %3d | Tag   | T %3d    | EXT_%1x      (Extension Token)    | %s(%s)\",\n\t\t\t\t\t     recursion_level, *codepage_stag, peek & 0x0f, Indent (recursion_level), str);\n\t\t\toff++;\n\t\t\tbreak;\n\t\tcase 0xC3: /* OPAQUE - WBXML 1.1 and newer */\n\t\t\tif (tvb_get_uint8 (tvb, 0)) { /* WBXML 1.x (x > 0) */\n\t\t\t\tif (map != NULL)\n\t\t\t\t{\n\t\t\t\t\tchar *tmp_str;\n\t\t\t\t\tif (tag_save_known) { /* Known tag */\n\t\t\t\t\t\tif (map->opaque_binary_tag) {\n\t\t\t\t\t\t\ttmp_str = map->opaque_binary_tag(tvb, off + 1,\n\t\t\t\t\t\t\t\t\t\t     tag_save_known, *codepage_stag, &len, pinfo);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttmp_str = default_opaque_binary_tag(tvb, off + 1,\n\t\t\t\t\t\t\t\t\t\t\ttag_save_known, *codepage_stag, &len, pinfo);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else { /* lITERAL tag */\n\t\t\t\t\t\tif (map->opaque_literal_tag) {\n\t\t\t\t\t\t\ttmp_str = map->opaque_literal_tag(tvb, off + 1,\n\t\t\t\t\t\t\t\t\t\t      tag_save_literal, *codepage_stag, &len, pinfo);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttmp_str = default_opaque_literal_tag(tvb, off + 1,\n\t\t\t\t\t\t\t\t\t\t\t tag_save_literal, *codepage_stag, &len, pinfo);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tproto_tree_add_bytes_format(tree, hf_wbxml_opaque_data, tvb, off, 1 + len, NULL,\n\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    | OPAQUE (Opaque data)            | %s%s\",\n\t\t\t\t\t\t     recursion_level, *codepage_stag, Indent (recursion_level), tmp_str);\n\t\t\t\t\toff += 1 + len;\n\t\t\t\t} else {\n\t\t\t\t\tidx = tvb_get_uintvar (tvb, off+1, &len, pinfo, &ei_wbxml_oversized_uintvar);\n\t\t\t\t\tif ((len <= tvb_len) && (idx < tvb_len))\n\t\t\t\t\t{\n\t\t\t\t\t\tproto_tree_add_bytes_format(tree, hf_wbxml_opaque_data, tvb, off, 1 + len + idx, NULL,\n\t\t\t\t\t\t         \"  %3d | Tag   | T %3d    | OPAQUE (Opaque data)            | %s(%u bytes of opaque data)\",\n\t\t\t\t\t\t         recursion_level, *codepage_stag, Indent (recursion_level), idx);\n\t\t\t\t\t\toff += 1+len+idx;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* Stop processing as it is impossible to parse now */\n\t\t\t\t\t\toff = tvb_len;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else { /* WBXML 1.0 - RESERVED_2 token (invalid) */\n\t\t\t\tproto_tree_add_none_format(tree, hf_wbxml_reserved_2, tvb, off, 1,\n\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    | RESERVED_2     (Invalid Token!) | WBXML 1.0 parsing stops here.\",\n\t\t\t\t\t\t     recursion_level, *codepage_stag);\n\t\t\t\t/* Stop processing as it is impossible to parse now */\n\t\t\t\toff = tvb_len;\n\t\t\t\tDebugLog((\"STAG: level = %u, Return: len = %u\\n\", recursion_level, off - offset));\n\t\t\t\treturn (off - offset);\n\t\t\t}\n\t\t\tbreak;\n\n\t\t\t/* No default clause, as all cases have been treated */\n\t\t} else { /* LITERAL or Known TAG */\n\t\t\t/* We must store the initial tag, and also retrieve the new tag.\n\t\t\t * For efficiency reasons, we store the literal tag representation\n\t\t\t * for known tags too, so we can easily close the tag without the\n\t\t\t * need of a new lookup and avoiding storage of token codepage.\n\t\t\t *\n\t\t\t * There are 4 possibilities:\n\t\t\t *\n\t\t\t *  1. Known tag followed by a known tag\n\t\t\t *  2. Known tag followed by a LITERAL tag\n\t\t\t *  3. LITERAL tag followed by Known tag\n\t\t\t *  4. LITERAL tag followed by LITERAL tag\n\t\t\t */\n\n\t\t\t/* Store the new tag */\n\t\t\ttag_len = 0;\n\t\t\tif ((peek & 0x3F) == 4) { /* LITERAL */\n\t\t\t\tDebugLog((\"STAG: LITERAL tag (peek = 0x%02X, off = %u) - TableRef follows!\\n\", peek, off));\n\t\t\t\tidx = tvb_get_uintvar (tvb, off+1, &tag_len, pinfo, &ei_wbxml_oversized_uintvar);\n\t\t\t\ttag_new_literal = tvb_get_stringz_enc(pinfo->pool, tvb, str_tbl+idx, &str_len, encoding);\n\t\t\t\ttag_new_known = 0; /* invalidate known tag_new */\n\t\t\t} else { /* Known tag */\n\t\t\t\ttag_new_known = peek & 0x3F;\n\t\t\t\tif (map != NULL) {\n\t\t\t\t\ttag_new_literal = map_token (map->tags, *codepage_stag,\n\t\t\t\t\t\t\t     tag_new_known);\n\t\t\t\t} else {\n\t\t\t\t\ttag_new_literal = wmem_strdup_printf(pinfo->pool, \"Tag_0x%02X\",\n\t\t\t\t\t\t\ttag_new_known);\n\t\t\t\t}\n\t\t\t\t/* Stored looked up tag name string */\n\t\t\t}\n\n\t\t\t/* Parsing of TAG starts HERE */\n\t\t\tif (peek & 0x40) { /* Content present */\n\t\t\t\t/* Content follows\n\t\t\t\t * [!] An explicit END token is expected in these cases!\n\t\t\t\t * ==> Recursion possible if we encounter a tag with content;\n\t\t\t\t *     recursion will return at the explicit END token.\n\t\t\t\t */\n\t\t\t\tif (parsing_tag_content) { /* Recurse */\n\t\t\t\t\tDebugLog((\"STAG: Tag in Tag - RECURSE! (off = %u)\\n\", off));\n\t\t\t\t\t/* Do not process the attribute list:\n\t\t\t\t\t * recursion will take care of it */\n\t\t\t\t\tp_set_proto_depth(pinfo, proto_wbxml, recursion_level + 1);\n\t\t\t\t\tlen = parse_wbxml_tag_defined (tree, tvb, pinfo, off, str_tbl,\n\t\t\t\t\t\t\t\t       codepage_stag, codepage_attr, map);\n\t\t\t\t\toff += len;\n\t\t\t\t} else { /* Now we will have content to parse */\n\t\t\t\t\t/* Save the start tag so we can properly close it later. */\n\t\t\t\t\tif ((peek & 0x3F) == 4) { /* Literal tag */\n\t\t\t\t\t\ttag_save_literal = tag_new_literal;\n\t\t\t\t\t\ttag_save_known = 0;\n\t\t\t\t\t} else { /* Known tag */\n\t\t\t\t\t\ttag_save_known = tag_new_known;\n\t\t\t\t\t\ttag_save_literal = tag_new_literal;\n\t\t\t\t\t\t/* The last statement avoids needless lookups */\n\t\t\t\t\t}\n\t\t\t\t\t/* Process the attribute list if present */\n\t\t\t\t\tif (peek & 0x80) { /* Content and Attribute list present */\n\t\t\t\t\t\tif (tag_new_known) { /* Known tag */\n\t\t\t\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_known_tag, tvb, off, 1, tag_new_literal,\n\t\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    |   Known Tag 0x%02X           (AC) | %s<%s\",\n\t\t\t\t\t\t\t\t\t     recursion_level, *codepage_stag, tag_new_known,\n\t\t\t\t\t\t\t\t\t     Indent (recursion_level), tag_new_literal);\n\t\t\t\t\t\t\t/* Tag string already looked up earlier! */\n\t\t\t\t\t\t\toff++;\n\t\t\t\t\t\t} else { /* LITERAL tag */\n\t\t\t\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_literal_ac, tvb, off, 1, tag_new_literal,\n\t\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    | LITERAL_AC (Literal tag)   (AC) | %s<%s\",\n\t\t\t\t\t\t\t\t\t     recursion_level, *codepage_stag, Indent (recursion_level), tag_new_literal);\n\t\t\t\t\t\t\toff += 1 + tag_len;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlen = parse_wbxml_attribute_list_defined (tree, tvb, pinfo,\n\t\t\t\t\t\t\t\t\t\t\t  off, str_tbl, codepage_attr, map);\n\t\t\t\t\t\t/* Check that there is still room in packet */\n\t\t\t\t\t\toff += len;\n\t\t\t\t\t\tif (off >= tvb_len) {\n\t\t\t\t\t\t\tDebugLog((\"STAG: level = %u, ThrowException: len = %u (short frame)\\n\",\n\t\t\t\t\t\t\t\t  recursion_level, off - offset));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tproto_tree_add_none_format(tree, hf_wbxml_end_attribute_list, tvb, off-1, 1,\n\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    | END (attribute list)            | %s>\",\n\t\t\t\t\t\t\t\t     recursion_level, *codepage_stag, Indent (recursion_level));\n\t\t\t\t\t} else { /* Content, no Attribute list */\n\t\t\t\t\t\tif (tag_new_known) { /* Known tag */\n\t\t\t\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_known_tag, tvb, off, 1, tag_new_literal,\n\t\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    |   Known Tag 0x%02X           (.C) | %s<%s>\",\n\t\t\t\t\t\t\t\t\t     recursion_level, *codepage_stag, tag_new_known,\n\t\t\t\t\t\t\t\t\t     Indent (recursion_level), tag_new_literal);\n\t\t\t\t\t\t\t/* Tag string already looked up earlier! */\n\t\t\t\t\t\t\toff++;\n\t\t\t\t\t\t} else { /* LITERAL tag */\n\t\t\t\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_literal_c, tvb, off, 1, tag_new_literal,\n\t\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    | LITERAL_C  (Literal Tag)   (.C) | %s<%s>\",\n\t\t\t\t\t\t\t\t\t     recursion_level, *codepage_stag, Indent (recursion_level), tag_new_literal);\n\t\t\t\t\t\t\toff += 1 + tag_len;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t/* The data that follows in the parsing process\n\t\t\t\t\t * represents content for the opening tag\n\t\t\t\t\t * we've just processed in the lines above.\n\t\t\t\t\t * Next time we encounter a tag with content: recurse\n\t\t\t\t\t */\n\t\t\t\t\tparsing_tag_content = true;\n\t\t\t\t\tDebugLog((\"Tag in Tag - No recursion this time! (off = %u)\\n\", off));\n\t\t\t\t}\n\t\t\t} else { /* No Content */\n\t\t\t\tDebugLog((\"<Tag/> in Tag - No recursion! (off = %u)\\n\", off));\n\t\t\t\trecursion_level++;\n\t\t\t\tp_set_proto_depth(pinfo, proto_wbxml, recursion_level);\n\t\t\t\tif (peek & 0x80) { /* No Content, Attribute list present */\n\t\t\t\t\tif (tag_new_known) { /* Known tag */\n\t\t\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_known_tag, tvb, off, 1, tag_new_literal,\n\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    |   Known Tag 0x%02X           (A.) | %s<%s\",\n\t\t\t\t\t\t\t\t     recursion_level, *codepage_stag, tag_new_known,\n\t\t\t\t\t\t\t\t     Indent (recursion_level), tag_new_literal);\n\t\t\t\t\t\t/* Tag string already looked up earlier! */\n\t\t\t\t\t\toff++;\n\t\t\t\t\t\tlen = parse_wbxml_attribute_list_defined (tree, tvb, pinfo,\n\t\t\t\t\t\t\t\t\t\t\t  off, str_tbl, codepage_attr, map);\n\t\t\t\t\t\t/* Check that there is still room in packet */\n\t\t\t\t\t\toff += len;\n\t\t\t\t\t\tif (off > tvb_len) {\n\t\t\t\t\t\t\tDebugLog((\"STAG: level = %u, ThrowException: len = %u (short frame)\\n\",\n\t\t\t\t\t\t\t\t\t\trecursion_level, off - offset));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tproto_tree_add_uint_format(tree, hf_wbxml_end_known_tag_uint, tvb, off-1, 1, *codepage_stag,\n\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    | END (Known Tag)                 | %s/>\",\n\t\t\t\t\t\t\t\t     recursion_level, *codepage_stag, Indent (recursion_level));\n\t\t\t\t\t} else { /* LITERAL tag */\n\t\t\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_literal_a, tvb, off, 1, tag_new_literal,\n\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    | LITERAL_A  (Literal Tag)   (A.) | %s<%s\",\n\t\t\t\t\t\t\t\t     recursion_level, *codepage_stag, Indent (recursion_level), tag_new_literal);\n\t\t\t\t\t\toff += 1 + tag_len;\n\t\t\t\t\t\tlen = parse_wbxml_attribute_list_defined (tree, tvb, pinfo,\n\t\t\t\t\t\t\t\t\t\t\t  off, str_tbl, codepage_attr, map);\n\t\t\t\t\t\t/* Check that there is still room in packet */\n\t\t\t\t\t\toff += len;\n\t\t\t\t\t\tif (off >= tvb_len) {\n\t\t\t\t\t\t\tDebugLog((\"STAG: level = %u, ThrowException: len = %u (short frame)\\n\",\n\t\t\t\t\t\t\t\t\t\trecursion_level, off - offset));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_end_literal_tag, tvb, off-1, 1, \"\",\n\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    | END (Literal Tag)               | %s/>\",\n\t\t\t\t\t\t\t\t     recursion_level, *codepage_stag, Indent (recursion_level));\n\t\t\t\t\t}\n\t\t\t\t} else { /* No Content, No Attribute list */\n\t\t\t\t\tif (tag_new_known) { /* Known tag */\n\t\t\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_known_tag, tvb, off, 1, tag_new_literal,\n\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    |   Known Tag 0x%02x           (..) | %s<%s />\",\n\t\t\t\t\t\t\t\t     recursion_level, *codepage_stag, tag_new_known,\n\t\t\t\t\t\t\t\t     Indent (recursion_level), tag_new_literal);\n\t\t\t\t\t\t/* Tag string already looked up earlier! */\n\t\t\t\t\t\toff++;\n\t\t\t\t\t} else { /* LITERAL tag */\n\t\t\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_literal, tvb, off, 1, tag_new_literal,\n\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    | LITERAL    (Literal Tag)   (..) | %s<%s />\",\n\t\t\t\t\t\t\t\t     recursion_level, *codepage_stag, Indent (recursion_level),\n\t\t\t\t\t\t\t\t     tag_new_literal);\n\t\t\t\t\t\toff += 1 + tag_len;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trecursion_level--;\n\t\t\t\tp_set_proto_depth(pinfo, proto_wbxml, recursion_level);\n\t\t\t\t/* TODO: Do I have to reset code page here? */\n\t\t\t}\n\t\t} /* if (tag & 0x3F) >= 5 */\n\t} /* while */\n\tDebugLog((\"STAG: level = %u, Return: len = %u (end of function body)\\n\", recursion_level, off - offset));\n\treturn (off - offset);\n}\n\n/****************** WBXML protocol dissection functions ******************/\n\n/* Code to actually dissect the packets */\nstatic void\ndissect_wbxml_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\n\t\t     const wbxml_decoding *override_content_map)\n{\n\t/* Set up structures needed to add the protocol subtree and manage it */\n\tproto_item           *ti;\n\tproto_tree           *wbxml_tree;          /* Main WBXML tree */\n\tproto_tree           *wbxml_str_tbl_tree;  /* String table subtree */\n\tproto_tree           *wbxml_content_tree;  /* Content subtree */\n\tproto_tree           *tag_tree;\n\tuint8_t               version;\n\tunsigned              offset          = 0;\n\tuint32_t              len;\n\tuint32_t              charset         = 0;\n\tuint32_t              charset_len     = 0;\n\tunsigned              encoding;\n\tuint32_t              publicid;\n\tuint32_t              publicid_index  = 0;\n\tuint32_t              publicid_len;\n\tuint32_t              str_tbl;\n\tuint32_t              str_tbl_len;\n\tuint32_t              str_tbl_len_len = 0;\n\tconst wbxml_decoding *content_map     = NULL;\n\tchar                 *summary         = NULL;\n\tuint8_t               codepage_stag   = 0;\n\tuint8_t               codepage_attr   = 0;\n\n\tDebugLog((\"dissect_wbxml: Dissecting packet %u\\n\", pinfo->num));\n\t/* WBXML format\n\t *\n\t * Version 1.0: version publicid         strtbl BODY\n\t * Version 1.x: version publicid charset strtbl BODY\n\t *\n\t * Last valid format: WBXML 1.3\n\t */\n\tswitch ( version = tvb_get_uint8 (tvb, 0) ) {\n\tcase 0x00: /* WBXML/1.0 */\n\t\tbreak;\n\n\tcase 0x01: /* WBXML/1.1 */\n\tcase 0x02: /* WBXML/1.2 */\n\tcase 0x03: /* WBXML/1.3 */\n\t\tbreak;\n\n\tdefault:\n\t\t/* Put some information here, so that the user knows what's going on. */\n\n\t\t/* Add summary to INFO column if it is enabled */\n\t\tcol_append_fstr(pinfo->cinfo, COL_INFO, \" (Unknown WBXML version 0x%02x)\", version);\n\t\tti = proto_tree_add_item (tree, proto_wbxml, tvb, 0, -1, ENC_NA);\n\t\tproto_item_append_text(ti, \", Unknown version 0x%02x\", version);\n\t\treturn;\n\t}\n\n\t/* In order to properly construct the packet summary,\n\t * I need to read the entire WBXML header\n\t * up to the string table length.\n\t */\n\n\t/* Public ID */\n\tpublicid = tvb_get_uintvar(tvb, 1, &publicid_len, pinfo, &ei_wbxml_oversized_uintvar);\n\tif (! publicid) {\n\t\t/* Public identifier in string table */\n\t\tpublicid_index = tvb_get_uintvar (tvb, 1+publicid_len, &len, pinfo, &ei_wbxml_oversized_uintvar);\n\t\tpublicid_len += len;\n\t}\n\toffset = 1 + publicid_len;\n\n\t/* Version-specific handling of Charset */\n\tswitch ( version ) {\n\tcase 0x00: /* WBXML/1.0 */\n\t\t/* No charset */\n\t\tbreak;\n\n\tcase 0x01: /* WBXML/1.1 */\n\tcase 0x02: /* WBXML/1.2 */\n\tcase 0x03: /* WBXML/1.3 */\n\t\t/* Get charset */\n\t\tcharset = tvb_get_uintvar (tvb, offset, &charset_len, pinfo, &ei_wbxml_oversized_uintvar);\n\t\toffset += charset_len;\n\t\tbreak;\n\n\tdefault: /* Impossible since we returned already earlier */\n\t\tDISSECTOR_ASSERT_NOT_REACHED();\n\t\tbreak;\n\t}\n\n\tif (charset) {\n\t\tencoding = mibenum_charset_to_encoding(charset);\n\t} else {\n\t\t/* XXX: If the charset is 0 we should look if there is a charset\n\t\t * parameter in the Content-Type / media_type if passed to\n\t\t * the dissector. Otherwise the default is UTF-8.\n\t\t */\n\t\tencoding = ENC_UTF_8;\n\t}\n\tp_add_proto_data(pinfo->pool, pinfo, proto_wbxml, 0, GUINT_TO_POINTER(encoding));\n\n\t/* String table: read string table length in bytes */\n\ttvb_get_uintvar (tvb, offset, &str_tbl_len_len, pinfo, &ei_wbxml_oversized_uintvar);\n\tstr_tbl = offset + str_tbl_len_len; /* Start of 1st string in string table */\n\n\t/* Compose the summary line */\n\tif ( publicid ) {\n\t\tsummary = wmem_strdup_printf(pinfo->pool, \"%s, Public ID: \\\"%s\\\"\",\n\t\t\t\t\t  val_to_str_ext(pinfo->pool, version, &vals_wbxml_versions_ext, \"(unknown 0x%x)\"),\n\t\t\t\t\t  val_to_str_ext(pinfo->pool, publicid, &vals_wbxml_public_ids_ext, \"(unknown 0x%x)\"));\n\t} else {\n\t\t/* Read length of Public ID from string table */\n\t\tsummary = wmem_strdup_printf(pinfo->pool, \"%s, Public ID: \\\"%s\\\"\",\n\t\t\t\t\t  val_to_str_ext(pinfo->pool, version, &vals_wbxml_versions_ext, \"(unknown 0x%x)\"),\n\t\t\t\t\t  tvb_get_stringz_enc(pinfo->pool, tvb, str_tbl + publicid_index, &len, encoding));\n\t}\n\n\t/* Add summary to INFO column if it is enabled */\n\tcol_append_fstr(pinfo->cinfo, COL_INFO, \" (WBXML %s)\", summary);\n\n\t/* create display subtree for the protocol */\n\tti = proto_tree_add_item (tree, proto_wbxml, tvb, 0, -1, ENC_NA);\n\tproto_item_append_text(ti, \", Version: %s\", summary);\n\n\t/*\n\t * Now show the protocol subtree, if tree is set.\n\t */\n\twbxml_tree = proto_item_add_subtree(ti, ett_wbxml);\n\n\t/* WBXML Version */\n\tproto_tree_add_uint (wbxml_tree, hf_wbxml_version,\n\t\t\t\t    tvb, 0, 1, version);\n\n\t/* Public ID */\n\tif (publicid) { /* Known Public ID */\n\t\tproto_tree_add_uint(wbxml_tree, hf_wbxml_public_id_known,\n\t\t\t\t\ttvb, 1, publicid_len, publicid);\n\t} else { /* Public identifier in string table */\n\t\tproto_tree_add_item (wbxml_tree, hf_wbxml_public_id_literal,\n\t\t\t\t\t    tvb, 1, publicid_len, ENC_ASCII);\n\t}\n\toffset = 1 + publicid_len;\n\n\tif ( charset ) { /* Charset */\n\t\tproto_tree_add_uint (wbxml_tree, hf_wbxml_charset,\n\t\t\t\t\t    tvb, 1 + publicid_len, charset_len, charset);\n\t\toffset += charset_len;\n\t}\n\n\tstr_tbl_len = tvb_get_uintvar (tvb, offset, &len, pinfo, &ei_wbxml_oversized_uintvar);\n\tstr_tbl = offset + len; /* Start of 1st string in string table */\n\n\t/* String Table */\n\twbxml_str_tbl_tree = proto_tree_add_subtree_format(wbxml_tree,\n\t\t\t\t\ttvb, offset, len + str_tbl_len, ett_wbxml_str_tbl, NULL, \"String table: %u bytes\",\n\t\t\t\t\tstr_tbl_len);\n\n\tif (str_tbl_len) { /* Display string table as subtree */\n\t\tshow_wbxml_string_table (wbxml_str_tbl_tree, pinfo, tvb,\n\t\t\t\t\t\tstr_tbl, str_tbl_len,\n\t\t\t\t\t\tcharset);\n\t}\n\n\t/* Data starts HERE */\n\toffset += len + str_tbl_len;\n\n\twbxml_content_tree = proto_tree_add_subtree(wbxml_tree, tvb, offset, -1,\n\t\t\t\t\tett_wbxml_content, &ti, \"Data representation\");\n\t/* The WBXML BODY starts here */\n\tif (disable_wbxml_token_parsing) {\n\t\texpert_add_info(pinfo, ti, &ei_wbxml_data_not_shown);\n\t\treturn;\n\t}\n\n\t/* The parse_wbxml_X() functions will process the content correctly,\n\t\t* irrespective of the WBXML version used. For the WBXML body, this\n\t\t* means that there is a different processing for the global token\n\t\t* RESERVED_2 (WBXML 1.0) or OPAQUE (WBXML 1.x with x > 0).  */\n\tif (override_content_map != NULL) {\n\t\tcontent_map = override_content_map;\n\t\tproto_item_append_text(ti,\n\t\t\t\t\t\t\" is based on: %s\",\n\t\t\t\t\t\tcontent_map->name);\n\t} else {\n\t\t/* Retrieve the content token mapping if available */\n\t\tcontent_map = get_wbxml_decoding_from_public_id (publicid);\n\t\tif (! content_map) {\n\t\t\tcontent_map = get_wbxml_decoding_from_content_type(\n\t\t\t\t\t\t\t\t\t\tpinfo->match_string, tvb, offset);\n\t\t\tif (! content_map) {\n\t\t\t\texpert_add_info(pinfo, ti, &ei_wbxml_content_type_not_supported);\n\t\t\t} else {\n\t\t\t\tproto_item_append_text(ti,\n\t\t\t\t\t\t\t\t\" is based on Content-Type: %s \"\n\t\t\t\t\t\t\t\t\"(chosen decoding: %s)\",\n\t\t\t\t\t\t\t\tpinfo->match_string, content_map->name);\n\t\t\t}\n\t\t}\n\t}\n\tif (content_map && skip_wbxml_token_mapping) {\n\t\texpert_add_info(pinfo, ti, &ei_wbxml_content_type_disabled);\n\t\tcontent_map = NULL;\n\t}\n\ttag_tree = proto_tree_add_subtree(wbxml_content_tree, tvb, offset, -1, ett_wbxml_tags, NULL,\n\t\t\t\t\t\"Level | State | Codepage | WBXML Token Description         | Rendering\");\n\n\t/* If content_map == NULL, WBXML only, no interpretation of the content */\n\tparse_wbxml_tag_defined (tag_tree,\n\t\t\t\t\t\t\ttvb, pinfo, offset, str_tbl, &codepage_stag,\n\t\t\t\t\t\t\t&codepage_attr, content_map);\n}\n\nstatic int\ndissect_wbxml(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\n{\n\tdissect_wbxml_common(tvb, pinfo, tree, NULL);\n\treturn tvb_captured_length(tvb);\n}\n\nstatic int\ndissect_uaprof(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\n{\n\tdissect_wbxml_common(tvb, pinfo, tree, &decode_uaprof_wap_248);\n\treturn tvb_captured_length(tvb);\n}\n\n/****************** Register the protocol with Wireshark ******************/\n\n\n/* This format is required because a script is used to build the C function\n * that calls the protocol registration. */\n\nvoid\nproto_register_wbxml(void)\n{\n\tmodule_t *wbxml_module;\t/* WBXML Preferences */\n\n\t/* Setup list of header fields. */\n\tstatic hf_register_info hf[] = {\n\t\t{ &hf_wbxml_version,\n\t\t  { \"Version\",\n\t\t    \"wbxml.version\",\n\t\t    FT_UINT8, BASE_HEX|BASE_EXT_STRING,\n\t\t    &vals_wbxml_versions_ext, 0x00,\n\t\t    \"WBXML Version\", HFILL }\n\t\t},\n\t\t{ &hf_wbxml_public_id_known,\n\t\t  { \"Public Identifier (known)\",\n\t\t    \"wbxml.public_id.known\",\n\t\t    FT_UINT32, BASE_HEX|BASE_EXT_STRING,\n\t\t    &vals_wbxml_public_ids_ext, 0x00,\n\t\t    \"WBXML Known Public Identifier (integer)\", HFILL }\n\t\t},\n\t\t{ &hf_wbxml_public_id_literal,\n\t\t  { \"Public Identifier (literal)\",\n\t\t    \"wbxml.public_id.literal\",\n\t\t    FT_STRING, BASE_NONE,\n\t\t    NULL, 0x00,\n\t\t    \"WBXML Literal Public Identifier (text string)\", HFILL }\n\t\t},\n\t\t{ &hf_wbxml_charset,\n\t\t  { \"Character Set\",\n\t\t    \"wbxml.charset\",\n\t\t    FT_UINT32, BASE_DEC|BASE_EXT_STRING,\n\t\t    &mibenum_vals_character_sets_ext, 0x00,\n\t\t    \"WBXML Character Set\", HFILL }\n\t\t},\n\t\t{ &hf_wbxml_string_table_item_offset,\n\t\t  { \"Offset\",\n\t\t    \"wbxml.string_table_item_offset\",\n\t\t    FT_UINT32, BASE_DEC,\n\t\t    NULL, 0x00,\n\t\t    NULL, HFILL }\n\t\t},\n\t\t{ &hf_wbxml_string_table_item_string,\n\t\t  { \"String\",\n\t\t    \"wbxml.string_table_item_string\",\n\t\t    FT_STRINGZ, BASE_NONE,\n\t\t    NULL, 0x00,\n\t\t    NULL, HFILL }\n\t\t},\n\t\t{ &hf_wbxml_switch_page,\n\t\t  { \"SWITCH_PAGE\",\n\t\t    \"wbxml.switch_page\",\n\t\t    FT_UINT32, BASE_DEC,\n\t\t    NULL, 0x00,\n\t\t    NULL, HFILL }\n\t\t},\n\t\t{ &hf_wbxml_known_tag,\n\t\t  { \"Known Tag\",\n\t\t    \"wbxml.known_tag\",\n\t\t    FT_STRING, BASE_NONE,\n\t\t    NULL, 0x00,\n\t\t    NULL, HFILL }\n\t\t},\n\t\t{ &hf_wbxml_end_known_tag,\n\t\t  { \"END Known Tag\",\n\t\t    \"wbxml.end_known_tag\",\n\t\t    FT_STRING, BASE_NONE,\n\t\t    NULL, 0x00,\n\t\t    NULL, HFILL }\n\t\t},\n\t\t{ &hf_wbxml_end_known_tag_uint,\n\t\t  { \"END Known Tag\",\n\t\t    \"wbxml.end_known_tag.uint\",\n\t\t    FT_UINT32, BASE_DEC,\n\t\t    NULL, 0x00,\n\t\t    NULL, HFILL }\n\t\t},\n\t\t{ &hf_wbxml_str_i,\n\t\t  { \"STR_I\",\n\t\t    \"wbxml.str_i\",\n\t\t    FT_STRING, BASE_NONE,\n\t\t    NULL, 0x00,\n\t\t    NULL, HFILL }\n\t\t},\n\t\t{ &hf_wbxml_str_t,\n\t\t  { \"STR_T\",\n\t\t    \"wbxml.str_t\",\n\t\t    FT_STRING, BASE_NONE,\n\t\t    NULL, 0x00,\n\t\t    NULL, HFILL }\n\t\t},\n\t\t{ &hf_wbxml_opaque_data,\n\t\t  { \"Opaque Data\",\n\t\t    \"wbxml.opaque_data\",\n\t\t    FT_BYTES, BASE_NONE,\n\t\t    NULL, 0x00,\n\t\t    NULL, HFILL }\n\t\t},\n\t\t{ &hf_wbxml_entity,\n\t\t  { \"ENTITY\",\n\t\t    \"wbxml.entity\",\n\t\t    FT_UINT32, BASE_DEC,\n\t\t    NULL, 0x00,\n\t\t    NULL, HFILL }\n\t\t},\n\t\t{ &hf_wbxml_literal,\n\t\t  { \"LITERAL\",\n\t\t    \"wbxml.literal\",\n\t\t    FT_STRING, BASE_NONE,\n\t\t    NULL, 0x00,\n\t\t    NULL, HFILL }\n\t\t},\n\t\t{ &hf_wbxml_ext_i,\n\t\t  { \"EXT_I\",\n\t\t    \"wbxml.ext_i\",\n\t\t    FT_STRING, BASE_NONE,\n\t\t    NULL, 0x00,\n\t\t    NULL, HFILL }\n\t\t},\n\t\t{ &hf_wbxml_ext_t,\n\t\t  { \"EXT_T\",\n\t\t    \"wbxml.ext_t\",\n\t\t    FT_STRING, BASE_NONE,\n\t\t    NULL, 0x00,\n\t\t    NULL, HFILL }\n\t\t},\n\t\t{ &hf_wbxml_extension_token,\n\t\t  { \"Extension Token\",\n\t\t    \"wbxml.extension_token\",\n\t\t    FT_STRING, BASE_NONE,\n\t\t    NULL, 0x00,\n\t\t    NULL, HFILL }\n\t\t},\n\t\t{ &hf_wbxml_reserved_2,\n\t\t  { \"RESERVED_2\",\n\t\t    \"wbxml.reserved_2\",\n\t\t    FT_NONE, BASE_NONE,\n\t\t    NULL, 0x00,\n\t\t    NULL, HFILL }\n\t\t},\n\t\t{ &hf_wbxml_invalid_token,\n\t\t  { \"Invalid token\",\n\t\t    \"wbxml.invalid_token\",\n\t\t    FT_NONE, BASE_NONE,\n\t\t    NULL, 0x00,\n\t\t    NULL, HFILL }\n\t\t},\n\t\t{ &hf_wbxml_known_attrvalue,\n\t\t  { \"Known attrValue\",\n\t\t    \"wbxml.known_attrvalue\",\n\t\t    FT_STRING, BASE_NONE,\n\t\t    NULL, 0x00,\n\t\t    NULL, HFILL }\n\t\t},\n\t\t{ &hf_wbxml_known_attrstart,\n\t\t  { \"Known attrStart\",\n\t\t    \"wbxml.known_attrstart\",\n\t\t    FT_STRING, BASE_NONE,\n\t\t    NULL, 0x00,\n\t\t    NULL, HFILL }\n\t\t},\n\t\t{ &hf_wbxml_end_literal_tag,\n\t\t  { \"END (Literal Tag)\",\n\t\t    \"wbxml.end_literal_tag\",\n\t\t    FT_STRING, BASE_NONE,\n\t\t    NULL, 0x00,\n\t\t    NULL, HFILL }\n\t\t},\n\t\t{ &hf_wbxml_literal_a,\n\t\t  { \"LITERAL_A\",\n\t\t    \"wbxml.literal_a\",\n\t\t    FT_STRING, BASE_NONE,\n\t\t    NULL, 0x00,\n\t\t    NULL, HFILL }\n\t\t},\n\t\t{ &hf_wbxml_literal_c,\n\t\t  { \"LITERAL_C\",\n\t\t    \"wbxml.literal_c\",\n\t\t    FT_STRING, BASE_NONE,\n\t\t    NULL, 0x00,\n\t\t    NULL, HFILL }\n\t\t},\n\t\t{ &hf_wbxml_literal_ac,\n\t\t  { \"LITERAL_AC\",\n\t\t    \"wbxml.literal_ac\",\n\t\t    FT_STRING, BASE_NONE,\n\t\t    NULL, 0x00,\n\t\t    NULL, HFILL }\n\t\t},\n\t\t{ &hf_wbxml_end_pi,\n\t\t  { \"END (PI)\",\n\t\t    \"wbxml.end_pi\",\n\t\t    FT_NONE, BASE_NONE,\n\t\t    NULL, 0x00,\n\t\t    NULL, HFILL }\n\t\t},\n\t\t{ &hf_wbxml_end_attribute_list,\n\t\t  { \"END (attribute list)\",\n\t\t    \"wbxml.end_attribute_list\",\n\t\t    FT_NONE, BASE_NONE,\n\t\t    NULL, 0x00,\n\t\t    NULL, HFILL }\n\t\t},\n\t\t{ &hf_wbxml_pi_xml,\n\t\t  { \"PI (XML Processing Instruction)\",\n\t\t    \"wbxml.pi_xml\",\n\t\t    FT_NONE, BASE_NONE,\n\t\t    NULL, 0x00,\n\t\t    NULL, HFILL }\n\t\t},\n\t};\n\n\t/* Setup protocol subtree array */\n\tstatic int *ett[] = {\n\t\t&ett_wbxml,\n\t\t&ett_wbxml_str_tbl,\n\t\t&ett_wbxml_content,\n\t\t&ett_wbxml_tags,\n\t\t&ett_wbxml_string_table_item,\n\t};\n\n\tstatic ei_register_info ei[] = {\n\t\t{ &ei_wbxml_data_not_shown, { \"wbxml.data_not_shown\", PI_PROTOCOL, PI_NOTE, \"Data representation not shown (edit WBXML preferences to show)\", EXPFILL }},\n\t\t{ &ei_wbxml_content_type_not_supported, { \"wbxml.content_type.not_supported\", PI_UNDECODED, PI_WARN, \"Rendering of this content type not (yet) supported\", EXPFILL }},\n\t\t{ &ei_wbxml_content_type_disabled, { \"wbxml.content_type.disabled\", PI_PROTOCOL, PI_NOTE, \"Rendering of this content type has been disabled (edit WBXML preferences to enable)\", EXPFILL }},\n\t\t{ &ei_wbxml_oversized_uintvar, { \"wbxml.oversized_uintvar\", PI_MALFORMED, PI_ERROR, \"Uintvar is oversized\", EXPFILL }},\n\t\t{ &ei_wbxml_too_much_recursion, { \"wbxml.too_much_recursion\", PI_UNDECODED, PI_WARN, \"Too much recursion\", EXPFILL }}\n\t};\n\n\texpert_module_t* expert_wbxml;\n\n\t/* Register the protocol name and description */\n\tproto_wbxml = proto_register_protocol(\"WAP Binary XML\", \"WBXML\", \"wbxml\");\n\n\t/* Required function calls to register the header fields\n\t * and subtrees used */\n\tproto_register_field_array(proto_wbxml, hf, array_length(hf));\n\tproto_register_subtree_array(ett, array_length(ett));\n\texpert_wbxml = expert_register_protocol(proto_wbxml);\n\texpert_register_field_array(expert_wbxml, ei, array_length(ei));\n\n\t/* Preferences */\n\twbxml_module = prefs_register_protocol(proto_wbxml, NULL);\n\tprefs_register_bool_preference(wbxml_module,\n\t\t\t\t       \"skip_wbxml_token_mapping\",\n\t\t\t\t       \"Skip the mapping of WBXML tokens to media type tokens.\",\n\t\t\t\t       \"Enable this preference if you want to view the WBXML \"\n\t\t\t\t       \"tokens without the representation in a media type \"\n\t\t\t\t       \"(e.g., WML). Tokens will show up as Tag_0x12, \"\n\t\t\t\t       \"attrStart_0x08 or attrValue_0x0B for example.\",\n\t\t\t\t       &skip_wbxml_token_mapping);\n\tprefs_register_bool_preference(wbxml_module,\n\t\t\t\t       \"disable_wbxml_token_parsing\",\n\t\t\t\t       \"Disable the parsing of the WBXML tokens.\",\n\t\t\t\t       \"Enable this preference if you want to skip the \"\n\t\t\t\t       \"parsing of the WBXML tokens that constitute the body \"\n\t\t\t\t       \"of the WBXML document. Only the WBXML header will be \"\n\t\t\t\t       \"dissected (and visualized) then.\",\n\t\t\t\t       &disable_wbxml_token_parsing);\n\n\tregister_dissector(\"wbxml\", dissect_wbxml, proto_wbxml);\n\tregister_dissector(\"wbxml-uaprof\", dissect_uaprof, proto_wbxml);\n}\n\n\nvoid\nproto_reg_handoff_wbxml(void)\n{\n\t/* Heuristic dissectors would be declared by means of:\n\t * heur_dissector_add(\"wsp\", dissect_wbxml_heur, proto_wbxml);\n\t */\n\n\twbxml_handle = find_dissector(\"wbxml\");\n\n\t/* Register the WSP content types (defined as protocol port)\n\t * for WBXML dissection.\n\t *\n\t * See http://www.wapforum.org/wina/wsp-content-type.htm\n\t *\n\t * As the media types for WSP and HTTP are the same, the WSP dissector\n\t * uses the same string dissector table as the HTTP protocol.\n\t */\n\n\t/**** Well-known WBXML WSP Content-Type values ****/\n\n\tdissector_add_string(\"media_type\",\n\t\t\t     \"application/vnd.wap.wmlc\", wbxml_handle);\n\tdissector_add_string(\"media_type\",\n\t\t\t     \"application/vnd.wap.wta-eventc\", wbxml_handle);\n\tdissector_add_string(\"media_type\",\n\t\t\t     \"application/vnd.wap.wbxml\", wbxml_handle);\n\tdissector_add_string(\"media_type\",\n\t\t\t     \"application/vnd.wap.sic\", wbxml_handle);\n\tdissector_add_string(\"media_type\",\n\t\t\t     \"application/vnd.wap.slc\", wbxml_handle);\n\tdissector_add_string(\"media_type\",\n\t\t\t     \"application/vnd.wap.coc\", wbxml_handle);\n\tdissector_add_string(\"media_type\",\n\t\t\t     \"application/vnd.wap.connectivity-wbxml\", wbxml_handle);\n\tdissector_add_string(\"media_type\",\n\t\t\t     \"application/vnd.wap.locc+wbxml\", wbxml_handle);\n\tdissector_add_string(\"media_type\",\n\t\t\t     \"application/vnd.syncml+wbxml\", wbxml_handle);\n\tdissector_add_string(\"media_type\",\n\t\t\t     \"application/vnd.syncml.dm+wbxml\", wbxml_handle);\n\tdissector_add_string(\"media_type\",\n\t\t\t     \"application/vnd.oma.drm.rights+wbxml\", wbxml_handle);\n\tdissector_add_string(\"media_type\",\n\t\t\t     \"application/vnd.wv.csp.wbxml\", wbxml_handle);\n\tdissector_add_string(\"media_type\",\n\t\t\t     \"application/vnd.ms-sync.wbxml\", wbxml_handle);\n\tdissector_add_string(\"media_type\",\n\t\t\t     \"application/vnd.ms-sync\", wbxml_handle);\n\n\t/**** Registered WBXML WSP Content-Type values ****/\n\n\tdissector_add_string(\"media_type\",\n\t\t\t     \"application/vnd.uplanet.cacheop-wbxml\", wbxml_handle);\n\tdissector_add_string(\"media_type\",\n\t\t\t     \"application/vnd.uplanet.alert-wbxml\", wbxml_handle);\n\tdissector_add_string(\"media_type\",\n\t\t\t     \"application/vnd.uplanet.list-wbxml\", wbxml_handle);\n\tdissector_add_string(\"media_type\",\n\t\t\t     \"application/vnd.uplanet.listcmd-wbxml\", wbxml_handle);\n\tdissector_add_string(\"media_type\",\n\t\t\t     \"application/vnd.uplanet.channel-wbxml\", wbxml_handle);\n\tdissector_add_string(\"media_type\",\n\t\t\t     \"application/vnd.uplanet.bearer-choice-wbxml\", wbxml_handle);\n\tdissector_add_string(\"media_type\",\n\t\t\t     \"application/vnd.phonecom.mmc-wbxml\", wbxml_handle);\n\tdissector_add_string(\"media_type\",\n\t\t\t     \"application/vnd.nokia.syncset+wbxml\", wbxml_handle);\n\n\t/***** Content types that only have a textual representation *****/\n\tdissector_add_string(\"media_type\",\n\t\t\t     \"application/x-wap-prov.browser-bookmarks\", wbxml_handle);\n\tdissector_add_string(\"media_type\",\n\t\t\t     \"application/x-wap-prov.browser-settings\", wbxml_handle);\n\t/* Same as application/vnd.nokia.syncset+wbxml */\n\tdissector_add_string(\"media_type\",\n\t\t\t     \"application/x-prov.syncset+wbxml\", wbxml_handle);\n\n\t/* RFC 6839 */\n\tdissector_add_string(\"media_type.suffix\", \"wbxml\", wbxml_handle);\n}\n\n/*\n * Editor modelines\n *\n * Local Variables:\n * c-basic-offset: 8\n * tab-width: 8\n * indent-tabs-mode: t\n * End:\n *\n * ex: set shiftwidth=8 tabstop=8 noexpandtab:\n * :indentSize=8:tabSize=8:noTabs=false:\n */\n", "patch": "@@ -7304,7 +7304,7 @@ parse_wbxml_tag_defined (proto_tree *tree, tvbuff_t *tvb, guint32 offset,\n \t\t\t const wbxml_decoding *map)\n {\n \tguint32     tvb_len  = tvb_reported_length (tvb);\n-\tguint32     off      = offset;\n+\tguint32     off      = offset, last_off;\n \tguint32     len;\n \tguint       str_len;\n \tguint32     ent;\n@@ -7323,6 +7323,7 @@ parse_wbxml_tag_defined (proto_tree *tree, tvbuff_t *tvb, guint32 offset,\n \ttag_save_literal = NULL;                 /* Prevents compiler warning */\n \n \tDebugLog((\"parse_wbxml_tag_defined (level = %u, offset = %u)\\n\", *level, offset));\n+\tlast_off = off;\n \twhile (off < tvb_len) {\n \t\tpeek = tvb_get_guint8 (tvb, off);\n \t\tDebugLog((\"STAG: (top of while) level = %3u, peek = 0x%02X, off = %u, tvb_len = %u\\n\", *level, peek, off, tvb_len));\n@@ -7694,6 +7695,10 @@ parse_wbxml_tag_defined (proto_tree *tree, tvbuff_t *tvb, guint32 offset,\n \t\t\t\t/* TODO: Do I have to reset code page here? */\n \t\t\t}\n \t\t} /* if (tag & 0x3F) >= 5 */\n+\t\tif (off < last_off) {\n+\t\t\tTHROW(ReportedBoundsError);\n+\t\t}\n+\t\tlast_off = off;\n \t} /* while */\n \tDebugLog((\"STAG: level = %u, Return: len = %u (end of function body)\\n\", *level, off - offset));\n \treturn (off - offset);\n@@ -7711,7 +7716,7 @@ parse_wbxml_tag (proto_tree *tree, tvbuff_t *tvb, guint32 offset,\n \t\t guint8 *codepage_stag, guint8 *codepage_attr)\n {\n \tguint32     tvb_len             = tvb_reported_length (tvb);\n-\tguint32     off                 = offset;\n+\tguint32     off                 = offset, last_off;\n \tguint32     len;\n \tguint       str_len;\n \tguint32     ent;\n@@ -7732,6 +7737,7 @@ parse_wbxml_tag (proto_tree *tree, tvbuff_t *tvb, guint32 offset,\n \ttag_save_literal = NULL;                 /* Prevents compiler warning */\n \n \tDebugLog((\"parse_wbxml_tag (level = %u, offset = %u)\\n\", *level, offset));\n+\tlast_off = off;\n \twhile (off < tvb_len) {\n \t\tpeek = tvb_get_guint8 (tvb, off);\n \t\tDebugLog((\"STAG: (top of while) level = %3u, peek = 0x%02X, off = %u, tvb_len = %u\\n\", *level, peek, off, tvb_len));\n@@ -8091,6 +8097,10 @@ parse_wbxml_tag (proto_tree *tree, tvbuff_t *tvb, guint32 offset,\n \t\t\t\t/* TODO: Do I have to reset code page here? */\n \t\t\t}\n \t\t} /* if (tag & 0x3F) >= 5 */\n+\t\tif (off < last_off) {\n+\t\t\tTHROW(ReportedBoundsError);\n+\t\t}\n+\t\tlast_off = off;\n \t} /* while */\n \tDebugLog((\"STAG: level = %u, Return: len = %u (end of function body)\\n\",\n \t\t  *level, off - offset));\n@@ -8126,7 +8136,7 @@ parse_wbxml_attribute_list_defined (proto_tree *tree, tvbuff_t *tvb,\n \t\t\t\t    const wbxml_decoding *map)\n {\n \tguint32     tvb_len = tvb_reported_length (tvb);\n-\tguint32     off     = offset;\n+\tguint32     off     = offset, last_off;\n \tguint32     len;\n \tguint       str_len;\n \tguint32     ent;\n@@ -8138,6 +8148,7 @@ parse_wbxml_attribute_list_defined (proto_tree *tree, tvbuff_t *tvb,\n \tDebugLog((\"parse_wbxml_attr_defined (level = %u, offset = %u)\\n\",\n \t\t  level, offset));\n \t/* Parse attributes */\n+\tlast_off = off;\n \twhile (off < tvb_len) {\n \t\tpeek = tvb_get_guint8 (tvb, off);\n \t\tDebugLog((\"ATTR: (top of while) level = %3u, peek = 0x%02X, \"\n@@ -8330,6 +8341,10 @@ parse_wbxml_attribute_list_defined (proto_tree *tree, tvbuff_t *tvb,\n \t\t\t\toff++;\n \t\t\t}\n \t\t}\n+\t\tif (off < last_off) {\n+\t\t\tTHROW(ReportedBoundsError);\n+\t\t}\n+\t\tlast_off = off;\n \t} /* End WHILE */\n \tDebugLog((\"ATTR: level = %u, Return: len = %u (end of function body)\\n\",\n \t\t  level, off - offset));\n@@ -8350,7 +8365,7 @@ parse_wbxml_attribute_list (proto_tree *tree, tvbuff_t *tvb,\n \t\t\t    guint32 offset, guint32 str_tbl, guint8 level, guint8 *codepage_attr)\n {\n \tguint32 tvb_len = tvb_reported_length (tvb);\n-\tguint32 off     = offset;\n+\tguint32 off     = offset, last_off;\n \tguint32 len;\n \tguint   str_len;\n \tguint32 ent;\n@@ -8359,6 +8374,7 @@ parse_wbxml_attribute_list (proto_tree *tree, tvbuff_t *tvb,\n \n \tDebugLog((\"parse_wbxml_attr (level = %u, offset = %u)\\n\", level, offset));\n \t/* Parse attributes */\n+\tlast_off = off;\n \twhile (off < tvb_len) {\n \t\tpeek = tvb_get_guint8 (tvb, off);\n \t\tDebugLog((\"ATTR: (top of while) level = %3u, peek = 0x%02X, \"\n@@ -8516,6 +8532,10 @@ parse_wbxml_attribute_list (proto_tree *tree, tvbuff_t *tvb,\n \t\t\t\toff++;\n \t\t\t}\n \t\t}\n+\t\tif (off < last_off) {\n+\t\t\tTHROW(ReportedBoundsError);\n+\t\t}\n+\t\tlast_off = off;\n \t} /* End WHILE */\n \tDebugLog((\"ATTR: level = %u, Return: len = %u (end of function body)\\n\",\n \t\t  level, off - offset));", "file_path": "files/2016_8\\45", "file_language": "c", "file_name": "epan/dissectors/packet-wbxml.c", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}], "outdated": 0}
{"index": 12, "cve_id": "CVE-2016-5350", "cwe_id": ["CWE-399"], "cve_language": "C", "cve_description": "epan/dissectors/packet-dcerpc-spoolss.c in the SPOOLS component in Wireshark 1.12.x before 1.12.12 and 2.x before 2.0.4 mishandles unexpected offsets, which allows remote attackers to cause a denial of service (infinite loop) via a crafted packet.", "cvss": "7.5", "publish_date": "August 7, 2016", "AV": "NETWORK", "AC": "LOW", "PR": "NONE", "UI": "NONE", "S": "UNCHANGED", "C": "NONE", "I": "NONE", "A": "HIGH", "commit_id": "b4d16b4495b732888e12baf5b8a7e9bf2665e22b", "commit_message": "SPOOLSS: Try to avoid an infinite loop.\n\nUse tvb_reported_length_remaining in dissect_spoolss_uint16uni. Make\nsure our offset always increments in dissect_spoolss_keybuffer.\n\nChange-Id: I7017c9685bb2fa27161d80a03b8fca4ef630e793\nReviewed-on: https://code.wireshark.org/review/14687\nReviewed-by: Gerald Combs <gerald@wireshark.org>\nPetri-Dish: Gerald Combs <gerald@wireshark.org>\nTested-by: Petri Dish Buildbot <buildbot-no-reply@wireshark.org>\nReviewed-by: Michael Mann <mmann78@netscape.net>", "commit_date": "2016-03-30T18:17:07Z", "project": "wireshark/wireshark", "url": "https://api.github.com/repos/wireshark/wireshark/commits/b4d16b4495b732888e12baf5b8a7e9bf2665e22b", "html_url": "https://github.com/wireshark/wireshark/commit/b4d16b4495b732888e12baf5b8a7e9bf2665e22b", "windows_before": "", "windows_after": "", "parents": [{"commit_id_before": "782191f7662c2cd2849524ba279aad0aafcba4de", "url_before": "https://api.github.com/repos/wireshark/wireshark/commits/782191f7662c2cd2849524ba279aad0aafcba4de", "html_url_before": "https://github.com/wireshark/wireshark/commit/782191f7662c2cd2849524ba279aad0aafcba4de"}], "details": [{"raw_url": "https://github.com/wireshark/wireshark/raw/b4d16b4495b732888e12baf5b8a7e9bf2665e22b/epan/dissectors/packet-dcerpc-spoolss.c", "code": "/* packet-dcerpc-spoolss.c\n * Routines for SMB \\PIPE\\spoolss packet disassembly\n * Copyright 2001-2003, Tim Potter <tpot@samba.org>\n *\n * Wireshark - Network traffic analyzer\n * By Gerald Combs <gerald@wireshark.org>\n * Copyright 1998 Gerald Combs\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version 2\n * of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */\n\n/* TODO list:\n\n - audit of item lengths\n\n*/\n\n#include \"config.h\"\n\n\n#include <epan/packet.h>\n#include <epan/expert.h>\n#include \"packet-dcerpc.h\"\n#include \"packet-dcerpc-nt.h\"\n#include \"packet-dcerpc-spoolss.h\"\n#include \"packet-windows-common.h\"\n\nvoid proto_register_dcerpc_spoolss(void);\nvoid proto_reg_handoff_dcerpc_spoolss(void);\n\n/* GetPrinterDriver2 */\n\nstatic int hf_clientmajorversion = -1;\nstatic int hf_clientminorversion = -1;\nstatic int hf_servermajorversion = -1;\nstatic int hf_serverminorversion = -1;\nstatic int hf_driverpath = -1;\nstatic int hf_datafile = -1;\nstatic int hf_configfile = -1;\nstatic int hf_helpfile = -1;\nstatic int hf_monitorname = -1;\nstatic int hf_defaultdatatype = -1;\nstatic int hf_driverinfo_cversion = -1;\nstatic int hf_dependentfiles = -1;\nstatic int hf_previousdrivernames = -1;\nstatic int hf_driverdate = -1;\nstatic int hf_padding = -1;\nstatic int hf_driver_version_low = -1;\nstatic int hf_driver_version_high = -1;\nstatic int hf_mfgname = -1;\nstatic int hf_oemurl = -1;\nstatic int hf_hardwareid= -1;\nstatic int hf_provider = -1;\n\n/* GetPrinter */\n\n/* Times */\n\nstatic int hf_start_time = -1;\nstatic int hf_end_time = -1;\nstatic int hf_elapsed_time = -1;\n\n/****************************************************************************/\n\n/*\n * New hf index values - I'm in the process of doing a bit of a cleanup -tpot\n */\n\nstatic int hf_opnum = -1;\nstatic int hf_hnd = -1;\nstatic int hf_rc = -1;\nstatic int hf_offered = -1;\nstatic int hf_needed = -1;\nstatic int hf_returned = -1;\nstatic int hf_buffer_size = -1;\nstatic int hf_buffer_data = -1;\nstatic int hf_string_parm_size = -1;\nstatic int hf_string_parm_data= -1;\nstatic int hf_offset = -1;\nstatic int hf_level = -1;\nstatic int hf_access_required = -1;\n\nstatic int hf_printername = -1;\nstatic int hf_machinename = -1;\nstatic int hf_notifyname = -1;\nstatic int hf_printerdesc = -1;\nstatic int hf_printercomment = -1;\nstatic int hf_servername = -1;\nstatic int hf_sharename = -1;\nstatic int hf_portname = -1;\nstatic int hf_printerlocation = -1;\nstatic int hf_drivername = -1;\nstatic int hf_environment = -1;\nstatic int hf_username = -1;\nstatic int hf_documentname = -1;\nstatic int hf_outputfile = -1;\nstatic int hf_datatype = -1;\nstatic int hf_textstatus = -1;\nstatic int hf_sepfile = -1;\nstatic int hf_printprocessor = -1;\nstatic int hf_parameters = -1;\n\n/* Printer information */\n\nstatic int hf_printer_cjobs = -1;\nstatic int hf_printer_total_jobs = -1;\nstatic int hf_printer_total_bytes = -1;\nstatic int hf_printer_global_counter = -1;\nstatic int hf_printer_total_pages = -1;\nstatic int hf_printer_major_version = -1;\nstatic int hf_printer_build_version = -1;\nstatic int hf_printer_unk7 = -1;\nstatic int hf_printer_unk8 = -1;\nstatic int hf_printer_unk9 = -1;\nstatic int hf_printer_session_ctr = -1;\nstatic int hf_printer_unk11 = -1;\nstatic int hf_printer_printer_errors = -1;\nstatic int hf_printer_unk13 = -1;\nstatic int hf_printer_unk14 = -1;\nstatic int hf_printer_unk15 = -1;\nstatic int hf_printer_unk16 = -1;\nstatic int hf_printer_changeid = -1;\nstatic int hf_printer_unk18 = -1;\nstatic int hf_printer_unk20 = -1;\nstatic int hf_printer_c_setprinter = -1;\nstatic int hf_printer_unk22 = -1;\nstatic int hf_printer_unk23 = -1;\nstatic int hf_printer_unk24 = -1;\nstatic int hf_printer_unk25 = -1;\nstatic int hf_printer_unk26 = -1;\nstatic int hf_printer_unk27 = -1;\nstatic int hf_printer_unk28 = -1;\nstatic int hf_printer_unk29 = -1;\nstatic int hf_printer_flags = -1;\nstatic int hf_printer_priority = -1;\nstatic int hf_printer_default_priority = -1;\nstatic int hf_printer_jobs = -1;\nstatic int hf_printer_averageppm = -1;\nstatic int hf_printer_guid = -1;\nstatic int hf_printer_action = -1;\n\n/* Printer data */\n\nstatic int hf_printerdata = -1;\nstatic int hf_printerdata_key = -1;\nstatic int hf_printerdata_value = -1;\nstatic int hf_printerdata_type = -1;\nstatic int hf_printerdata_size = -1; /* Length of printer data */\nstatic int hf_printerdata_data = -1;\nstatic int hf_printerdata_data_sz = -1;\nstatic int hf_printerdata_data_dword = -1;\n\n/* Devicemode */\n\nstatic int hf_devmodectr_size = -1;\n\nstatic int hf_devmode = -1;\nstatic int hf_devmode_size = -1;\nstatic int hf_devmode_spec_version = -1;\nstatic int hf_devmode_driver_version = -1;\nstatic int hf_devmode_size2 = -1;\nstatic int hf_devmode_driver_extra_len = -1;\nstatic int hf_devmode_fields = -1;\nstatic int hf_devmode_orientation = -1;\nstatic int hf_devmode_paper_size = -1;\nstatic int hf_devmode_paper_width = -1;\nstatic int hf_devmode_paper_length = -1;\nstatic int hf_devmode_scale = -1;\nstatic int hf_devmode_copies = -1;\nstatic int hf_devmode_default_source = -1;\nstatic int hf_devmode_print_quality = -1;\nstatic int hf_devmode_color = -1;\nstatic int hf_devmode_duplex = -1;\nstatic int hf_devmode_y_resolution = -1;\nstatic int hf_devmode_tt_option = -1;\nstatic int hf_devmode_collate = -1;\nstatic int hf_devmode_log_pixels = -1;\nstatic int hf_devmode_bits_per_pel = -1;\nstatic int hf_devmode_pels_width = -1;\nstatic int hf_devmode_pels_height = -1;\nstatic int hf_devmode_display_flags = -1;\nstatic int hf_devmode_display_freq = -1;\nstatic int hf_devmode_icm_method = -1;\nstatic int hf_devmode_icm_intent = -1;\nstatic int hf_devmode_media_type = -1;\nstatic int hf_devmode_dither_type = -1;\nstatic int hf_devmode_reserved1 = -1;\nstatic int hf_devmode_reserved2 = -1;\nstatic int hf_devmode_panning_width = -1;\nstatic int hf_devmode_panning_height = -1;\nstatic int hf_devmode_driver_extra = -1;\n\nstatic int hf_devmode_fields_orientation = -1;\nstatic int hf_devmode_fields_papersize = -1;\nstatic int hf_devmode_fields_paperlength = -1;\nstatic int hf_devmode_fields_paperwidth = -1;\nstatic int hf_devmode_fields_scale = -1;\nstatic int hf_devmode_fields_position = -1;\nstatic int hf_devmode_fields_nup = -1;\nstatic int hf_devmode_fields_copies = -1;\nstatic int hf_devmode_fields_defaultsource = -1;\nstatic int hf_devmode_fields_printquality = -1;\nstatic int hf_devmode_fields_color = -1;\nstatic int hf_devmode_fields_duplex = -1;\nstatic int hf_devmode_fields_yresolution = -1;\nstatic int hf_devmode_fields_ttoption = -1;\nstatic int hf_devmode_fields_collate = -1;\nstatic int hf_devmode_fields_formname = -1;\nstatic int hf_devmode_fields_logpixels = -1;\nstatic int hf_devmode_fields_bitsperpel = -1;\nstatic int hf_devmode_fields_pelswidth = -1;\nstatic int hf_devmode_fields_pelsheight = -1;\nstatic int hf_devmode_fields_displayflags = -1;\nstatic int hf_devmode_fields_displayfrequency = -1;\nstatic int hf_devmode_fields_icmmethod = -1;\nstatic int hf_devmode_fields_icmintent = -1;\nstatic int hf_devmode_fields_mediatype = -1;\nstatic int hf_devmode_fields_dithertype = -1;\nstatic int hf_devmode_fields_panningwidth = -1;\nstatic int hf_devmode_fields_panningheight = -1;\n\n/* Print job */\n\nstatic int hf_job_id = -1;\nstatic int hf_job_priority = -1;\nstatic int hf_job_position = -1;\nstatic int hf_job_totalpages = -1;\nstatic int hf_job_totalbytes = -1;\nstatic int hf_job_pagesprinted = -1;\nstatic int hf_job_bytesprinted = -1;\nstatic int hf_job_size = -1;\n\nstatic int hf_job_status = -1;\nstatic int hf_job_status_paused = -1;\nstatic int hf_job_status_error = -1;\nstatic int hf_job_status_deleting = -1;\nstatic int hf_job_status_spooling = -1;\nstatic int hf_job_status_printing = -1;\nstatic int hf_job_status_offline = -1;\nstatic int hf_job_status_paperout = -1;\nstatic int hf_job_status_printed = -1;\nstatic int hf_job_status_deleted = -1;\nstatic int hf_job_status_blocked = -1;\nstatic int hf_job_status_user_intervention = -1;\n\n/* Forms */\n\nstatic int hf_form = -1;\nstatic int hf_form_level = -1;\nstatic int hf_form_name = -1;\nstatic int hf_form_flags = -1;\nstatic int hf_form_unknown = -1;\nstatic int hf_form_width = -1;\nstatic int hf_form_height = -1;\nstatic int hf_form_left_margin = -1;\nstatic int hf_form_top_margin = -1;\nstatic int hf_form_horiz_len = -1;\nstatic int hf_form_vert_len = -1;\n\nstatic int hf_enumforms_num = -1;\n\n/* Print notify */\n\nstatic int hf_notify_options_version = -1;\nstatic int hf_notify_options_flags = -1;\nstatic int hf_notify_options_flags_refresh = -1;\nstatic int hf_notify_options_count = -1;\nstatic int hf_notify_option_type = -1;\nstatic int hf_notify_option_reserved1 = -1;\nstatic int hf_notify_option_reserved2 = -1;\nstatic int hf_notify_option_reserved3 = -1;\nstatic int hf_notify_option_count = -1;\nstatic int hf_notify_option_data_count = -1;\nstatic int hf_notify_info_count = -1;\nstatic int hf_notify_info_version = -1;\nstatic int hf_notify_info_flags = -1;\nstatic int hf_notify_info_data_type = -1;\nstatic int hf_notify_info_data_count = -1;\nstatic int hf_notify_info_data_id = -1;\nstatic int hf_notify_info_data_value1 = -1;\nstatic int hf_notify_info_data_value2 = -1;\nstatic int hf_notify_info_data_bufsize = -1;\nstatic int hf_notify_info_data_buffer = -1;\nstatic int hf_notify_info_data_buffer_len = -1;\nstatic int hf_notify_info_data_buffer_data = -1;\n\nstatic int hf_notify_field = -1;\n\nstatic int hf_printerlocal = -1;\n\nstatic int hf_rrpcn_changelow = -1;\nstatic int hf_rrpcn_changehigh = -1;\nstatic int hf_rrpcn_unk0 = -1;\nstatic int hf_rrpcn_unk1 = -1;\n\nstatic int hf_replyopenprinter_unk0 = -1;\nstatic int hf_replyopenprinter_unk1 = -1;\n\nstatic int hf_devmode_devicename = -1;\nstatic int hf_devmode_form_name = -1;\nstatic int hf_relative_string = -1;\nstatic int hf_value_name = -1;\nstatic int hf_keybuffer = -1;\nstatic int hf_value_string = -1;\n\nstatic expert_field ei_unimplemented_dissector = EI_INIT;\nstatic expert_field ei_unknown_data = EI_INIT;\nstatic expert_field ei_spool_printer_info_level = EI_INIT;\nstatic expert_field ei_printer_info_level = EI_INIT;\nstatic expert_field ei_form_level = EI_INIT;\nstatic expert_field ei_job_info_level = EI_INIT;\nstatic expert_field ei_driver_info_level = EI_INIT;\nstatic expert_field ei_level = EI_INIT;\nstatic expert_field ei_notify_info_data_type = EI_INIT;\nstatic expert_field ei_enumprinterdataex_value = EI_INIT;\n\n/* Registry data types */\n\n#define DCERPC_REG_NONE                        0\n#define DCERPC_REG_SZ                          1\n#define DCERPC_REG_EXPAND_SZ                   2\n#define DCERPC_REG_BINARY                      3\n#define DCERPC_REG_DWORD                       4\n#define DCERPC_REG_DWORD_LE                    4        /* DWORD, little endian\n*/\n#define DCERPC_REG_DWORD_BE                    5        /* DWORD, big endian */\n#define DCERPC_REG_LINK                        6\n#define DCERPC_REG_MULTI_SZ                    7\n#define DCERPC_REG_RESOURCE_LIST               8\n#define DCERPC_REG_FULL_RESOURCE_DESCRIPTOR    9\n#define DCERPC_REG_RESOURCE_REQUIREMENTS_LIST 10\n\nstatic const value_string reg_datatypes[] = {\n\t{ DCERPC_REG_NONE, \"REG_NONE\" },\n\t{ DCERPC_REG_SZ, \"REG_SZ\" },\n\t{ DCERPC_REG_EXPAND_SZ, \"REG_EXPAND_SZ\" },\n\t{ DCERPC_REG_BINARY, \"REG_BINARY\" },\n\t{ DCERPC_REG_DWORD, \"REG_DWORD\" },\n/*\t  { DCERPC_REG_DWORD_LE, \"REG_DWORD_LE\" }, */\n\t{ DCERPC_REG_DWORD_BE, \"REG_DWORD_BE\" },\n\t{ DCERPC_REG_LINK, \"REG_LINK\" },\n\t{ DCERPC_REG_MULTI_SZ, \"REG_MULTI_SZ\" },\n\t{ DCERPC_REG_RESOURCE_LIST, \"REG_RESOURCE_LIST\" },\n\t{ DCERPC_REG_FULL_RESOURCE_DESCRIPTOR, \"REG_FULL_RESOURCE_DESCRIPTOR\" },\n\t{ DCERPC_REG_RESOURCE_REQUIREMENTS_LIST, \"REG_RESOURCE_REQUIREMENTS_LIST\" },\n\t{0, NULL }\n};\nstatic value_string_ext reg_datatypes_ext = VALUE_STRING_EXT_INIT(reg_datatypes);\n\n/****************************************************************************/\n\n/*\n * Dissect SPOOLSS specific access rights\n */\n\nstatic int hf_server_access_admin = -1;\nstatic int hf_server_access_enum = -1;\nstatic int hf_printer_access_admin = -1;\nstatic int hf_printer_access_use = -1;\nstatic int hf_job_access_admin = -1;\n\nstatic void\nspoolss_printer_specific_rights(tvbuff_t *tvb, gint offset, proto_tree *tree,\n\t\t\t\tguint32 access)\n{\n\tproto_tree_add_boolean(\n\t\ttree, hf_printer_access_use, tvb, offset, 4, access);\n\n\tproto_tree_add_boolean(\n\t\ttree, hf_printer_access_admin, tvb, offset, 4, access);\n}\n\nstruct access_mask_info spoolss_printer_access_mask_info = {\n\t\"SPOOLSS printer\",\n\tspoolss_printer_specific_rights,\n\tNULL,\t\t\t/* Generic mapping table */\n\tNULL\t\t\t/* Standard mapping table */\n};\n\nstatic void\nspoolss_printserver_specific_rights(tvbuff_t *tvb, gint offset,\n\t\t\t\t    proto_tree *tree, guint32 access)\n{\n\tproto_tree_add_boolean(\n\t\ttree, hf_server_access_enum, tvb, offset, 4, access);\n\n\tproto_tree_add_boolean(\n\t\ttree, hf_server_access_admin, tvb, offset, 4, access);\n}\n\nstruct access_mask_info spoolss_printserver_access_mask_info = {\n\t\"SPOOLSS print server\",\n\tspoolss_printserver_specific_rights,\n\tNULL,\t\t\t/* Generic mapping table */\n\tNULL\t\t\t/* Standard mapping table */\n};\n\nstatic void\nspoolss_job_specific_rights(tvbuff_t *tvb, gint offset,\n\t\t\t    proto_tree *tree, guint32 access)\n{\n\tproto_tree_add_boolean(\n\t\ttree, hf_job_access_admin, tvb, offset, 4, access);\n}\n\nstruct access_mask_info spoolss_job_access_mask_info = {\n\t\"SPOOLSS job\",\n\tspoolss_job_specific_rights,\n\tNULL,\t\t\t/* Generic mapping table */\n\tNULL\t\t\t/* Standard mapping table */\n};\n\n/*\n * Routines to dissect a spoolss BUFFER\n */\n\ntypedef struct {\n\ttvbuff_t *tvb;\n\tproto_item *tree;\t/* Proto tree buffer located in */\n\tproto_item *item;\n} BUFFER;\n\nstatic gint ett_BUFFER = -1;\n\nstatic int\ndissect_spoolss_buffer_data(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\t    proto_tree *tree, dcerpc_info *di, guint8 *drep)\n{\n\tBUFFER *b = (BUFFER *)di->private_data;\n\tproto_item *item;\n\tguint32 size;\n\tconst guint8 *data;\n\n\tif (di->conformant_run)\n\t\treturn offset;\n\n\t/* Dissect size and data */\n\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, tree, di, drep,\n\t\t\t\t    hf_buffer_size, &size);\n\n\toffset = dissect_ndr_uint8s(tvb, offset, pinfo, NULL, di, drep,\n\t\t\t\t    hf_buffer_data, size, &data);\n\n\titem = proto_tree_add_item(\n\t\ttree, hf_buffer_data, tvb, offset - size,\n\t\tsize, ENC_NA);\n\n\t/* Return buffer info */\n\n\tif (b) {\n\n\t\t/* I'm not sure about this.  Putting the buffer into\n\t\t   its own tvb makes sense and the dissection code is\n\t\t   much clearer, but the data is a proper subset of\n\t\t   the actual tvb.  Not adding the new data source\n\t\t   makes the hex display confusing as it switches\n\t\t   between the 'DCERPC over SMB' tvb and the buffer\n\t\t   tvb with no visual cues as to what is going on. */\n\n\t\tb->tvb = tvb_new_child_real_data(tvb, data, size, size);\n\t\tadd_new_data_source(pinfo, b->tvb, \"SPOOLSS buffer\");\n\n\t\tb->item = item;\n\t\tb->tree = proto_item_add_subtree(item, ett_BUFFER);\n\t}\n\n\treturn offset;\n}\n\n/* Dissect a spoolss buffer and return buffer data */\n\nstatic int\ndissect_spoolss_buffer(tvbuff_t *tvb, gint offset, packet_info *pinfo,\n\t\t       proto_tree *tree, dcerpc_info *di, guint8 *drep, BUFFER *b)\n{\n\tif (b)\n\t\tmemset(b, 0, sizeof(BUFFER));\n\n\tdi->private_data = b;\n\n\toffset = dissect_ndr_pointer(\n\t\ttvb, offset, pinfo, tree, di, drep,\n\t\tdissect_spoolss_buffer_data, NDR_POINTER_UNIQUE,\n\t\t\"Buffer\", -1);\n\n\treturn offset;\n}\n\nstatic int\ndissect_spoolss_string_parm_data(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\t    proto_tree *tree, dcerpc_info *di, guint8 *drep)\n{\n\tguint32 buffer_len, len;\n\tgchar *s;\n\tproto_item *item = NULL;\n\n\tif (di->conformant_run)\n\t\treturn offset;\n\n\t/* Dissect size and data */\n\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, tree, di, drep,\n\t\t\t\thf_string_parm_size, &buffer_len);\n\n\ts = tvb_get_stringz_enc(wmem_packet_scope(), tvb, offset, &len, ENC_UTF_16|ENC_LITTLE_ENDIAN);\n\n\tif (tree && buffer_len) {\n\t\ttvb_ensure_bytes_exist(tvb, offset, buffer_len);\n\n\t\titem = proto_tree_add_string(\n\t\t\ttree, hf_string_parm_data, tvb, offset, len, s);\n\t}\n\toffset += buffer_len;\n\n\tcol_append_fstr(pinfo->cinfo, COL_INFO, \", %s\", s);\n\n\t/* Append string to upper level item */\n\tif (tree && item) {\n\t\titem = item->parent != NULL ? item->parent : item;\n\t\tproto_item_append_text(item, \": %s\", s);\n\t}\n\n\treturn offset;\n}\n\n/* Dissect a spoolss string parameter */\n\nstatic int\ndissect_spoolss_string_parm(tvbuff_t *tvb, gint offset, packet_info *pinfo,\n\t\t       proto_tree *tree, dcerpc_info *di, guint8 *drep, const char *text)\n{\n\toffset = dissect_ndr_pointer(\n\t\ttvb, offset, pinfo, tree, di, drep,\n\t\tdissect_spoolss_string_parm_data, NDR_POINTER_UNIQUE,\n\t\ttext, -1);\n\n\treturn offset;\n}\n\n/*\n * SYSTEM_TIME\n */\n\nstatic gint ett_SYSTEM_TIME = -1;\n\nstatic int hf_time_year = -1;\nstatic int hf_time_month = -1;\nstatic int hf_time_dow = -1;\nstatic int hf_time_day = -1;\nstatic int hf_time_hour = -1;\nstatic int hf_time_minute = -1;\nstatic int hf_time_second = -1;\nstatic int hf_time_msec = -1;\n\nstatic int\ndissect_SYSTEM_TIME(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t    proto_tree *tree, dcerpc_info *di, guint8 *drep, const char *name,\n\t\t    gboolean add_subtree, char **data)\n{\n\tproto_item *item = NULL;\n\tproto_tree *subtree = tree;\n\tguint16 year, month, day, hour, minute, second, millisecond;\n\tchar *str;\n\n\tif (add_subtree) {\n\t\tsubtree = proto_tree_add_subtree(tree, tvb, offset, 16, ett_SYSTEM_TIME, &item, name);\n\t}\n\n\toffset = dissect_ndr_uint16(\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_time_year, &year);\n\n\toffset = dissect_ndr_uint16(\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_time_month, &month);\n\n\toffset = dissect_ndr_uint16(\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_time_dow, NULL);\n\n\toffset = dissect_ndr_uint16(\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_time_day, &day);\n\n\toffset = dissect_ndr_uint16(\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_time_hour, &hour);\n\n\toffset = dissect_ndr_uint16(\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_time_minute, &minute);\n\n\toffset = dissect_ndr_uint16(\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_time_second, &second);\n\n\toffset = dissect_ndr_uint16(\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_time_msec, &millisecond);\n\n\tstr = wmem_strdup_printf(wmem_packet_scope(),\n\t\t\t      \"%d/%02d/%02d %02d:%02d:%02d.%03d\",\n\t\t\t      year, month, day, hour, minute, second,\n\t\t\t      millisecond);\n\n\tif (add_subtree)\n\t\tproto_item_append_text(item, \": %s\", str);\n\n\tif (data)\n\t\t*data = str;\n\n\treturn offset;\n}\n\nstatic int\ndissect_SYSTEM_TIME_ptr(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\tproto_tree *tree, dcerpc_info *di, guint8 *drep)\n{\n\tdcerpc_call_value *dcv = (dcerpc_call_value *)di->call_data;\n\tchar *str;\n\n\n\toffset =  dissect_SYSTEM_TIME(\n\t\ttvb, offset, pinfo, tree, di, drep, NULL, FALSE, &str);\n\tdcv->private_data = str;\n\n\treturn offset;\n}\n\n/*\n * SpoolssClosePrinter\n */\n\nstatic int\nSpoolssClosePrinter_q(tvbuff_t *tvb, int offset,\n\t\t\t\t packet_info *pinfo, proto_tree *tree,\n\t\t\t\t dcerpc_info *di, guint8 *drep _U_)\n{\n\te_ctx_hnd policy_hnd;\n\tchar *pol_name;\n\n\t/* Parse packet */\n\n\toffset = dissect_nt_policy_hnd(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_hnd, &policy_hnd, NULL,\n\t\tFALSE, TRUE);\n\n\tdcerpc_fetch_polhnd_data(&policy_hnd, &pol_name, NULL, NULL, NULL,\n\t\t\t     pinfo->num);\n\n\tif (pol_name)\n\t\tcol_append_fstr(pinfo->cinfo, COL_INFO, \", %s\",\n\t\t\t\tpol_name);\n\n\treturn offset;\n}\n\nstatic int\nSpoolssClosePrinter_r(tvbuff_t *tvb, int offset,\n\t\t\t\t packet_info *pinfo, proto_tree *tree,\n\t\t\t\t dcerpc_info *di, guint8 *drep _U_)\n{\n\t/* Parse packet */\n\n\toffset = dissect_nt_policy_hnd(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_hnd, NULL, NULL,\n\t\tFALSE, FALSE);\n\n\n\toffset = dissect_doserror(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_rc, NULL);\n\n\treturn offset;\n}\n\n/* Dissect some printer data.  The get/set/enum printerdata routines all\n   store value/data in a uint8 array.  We could use the ndr routines for\n   this but that would result in one item for each byte in the printer\n   data. */\n\nstatic gint ett_printerdata_data = -1;\nstatic gint ett_printerdata_value = -1;\n\nstatic int\ndissect_printerdata_data(tvbuff_t *tvb, int offset,\n\t\t\t\t    packet_info *pinfo, proto_tree *tree,\n\t\t\t\t    dcerpc_info *di, guint8 *drep _U_, guint32 type)\n{\n\tproto_item *item, *hidden_item;\n\tproto_tree *subtree;\n\tguint32 size;\n\n\tsubtree = proto_tree_add_subtree(tree, tvb, offset, 0, ett_printerdata_data, &item, \"Data\");\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_printerdata_size, &size);\n\n\tif (size) {\n\n\t\toffset = dissect_ndr_uint8s(\n\t\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\t\thf_printerdata_data, size, NULL);\n\n\t\tswitch(type) {\n\t\tcase DCERPC_REG_SZ: {\n\t\t\tchar *data = tvb_get_string_enc(NULL, tvb, offset - size, size, ENC_UTF_16|ENC_LITTLE_ENDIAN);\n\n\t\t\tproto_item_append_text(item, \": %s\", data);\n\n\t\t\tcol_append_fstr(\n\t\t\t\t\tpinfo->cinfo, COL_INFO, \" = %s\", data);\n\n\t\t\thidden_item = proto_tree_add_string(\n\t\t\t\ttree, hf_printerdata_data_sz, tvb,\n\t\t\t\toffset - size, size, data);\n\t\t\tPROTO_ITEM_SET_HIDDEN(hidden_item);\n\n\t\t\tg_free(data);\n\n\t\t\tbreak;\n\t\t}\n\t\tcase DCERPC_REG_DWORD: {\n\t\t\tguint32 data = tvb_get_letohl(tvb, offset - size);\n\n\t\t\tproto_item_append_text(item, \": 0x%08x\", data);\n\n\t\t\tcol_append_fstr(\n\t\t\t\t\tpinfo->cinfo, COL_INFO, \" = 0x%08x\",\n\t\t\t\t\tdata);\n\n\t\t\thidden_item = proto_tree_add_uint(\n\t\t\t\ttree, hf_printerdata_data_dword, tvb,\n\t\t\t\toffset - size, 4, data);\n\t\t\tPROTO_ITEM_SET_HIDDEN(hidden_item);\n\n\t\t\tbreak;\n\t\t}\n\t\tcase DCERPC_REG_BINARY:\n\t\t\tcol_append_str(\n\t\t\t\t\tpinfo->cinfo, COL_INFO,\n\t\t\t\t\t\" = <binary data>\");\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tproto_item_set_len(item, size + 4);\n\n\treturn offset;\n}\n\n/*\n * SpoolssGetPrinterData\n */\n\nstatic int\nSpoolssGetPrinterData_q(tvbuff_t *tvb, int offset,\n\t\t\t\t   packet_info *pinfo, proto_tree *tree,\n\t\t\t\t   dcerpc_info *di, guint8 *drep _U_)\n{\n\tdcerpc_call_value *dcv = (dcerpc_call_value *)di->call_data;\n\tchar *value_name;\n\tproto_item *hidden_item;\n\n\thidden_item = proto_tree_add_uint(\n\t\ttree, hf_printerdata, tvb, offset, 0, 1);\n\tPROTO_ITEM_SET_HIDDEN(hidden_item);\n\n\t/* Parse packet */\n\n\toffset = dissect_nt_policy_hnd(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_hnd, NULL, NULL,\n\t\tFALSE, FALSE);\n\n\n\tvalue_name=NULL;\n \toffset = dissect_ndr_cvstring(\n \t\ttvb, offset, pinfo, tree, di, drep, sizeof(guint16),\n \t\thf_printerdata_value, TRUE, value_name ? NULL : &value_name);\n\t/* GetPrinterData() stores the printerdata in se_data */\n\tif(!pinfo->fd->flags.visited){\n\t\tif(!dcv->se_data){\n\t\t\tif(value_name){\n\t\t\t\tdcv->se_data = wmem_strdup(wmem_file_scope(), value_name);\n\t\t\t}\n\t\t}\n\t}\n\n\tcol_append_fstr(pinfo->cinfo, COL_INFO, \", %s\", value_name);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_offered, NULL);\n\n\treturn offset;\n}\n\nstatic int\nSpoolssGetPrinterData_r(tvbuff_t *tvb, int offset,\n\t\t\t\t   packet_info *pinfo, proto_tree *tree,\n\t\t\t\t   dcerpc_info *di, guint8 *drep _U_)\n{\n\tdcerpc_call_value *dcv = (dcerpc_call_value *)di->call_data;\n\tguint32 type;\n\tproto_item *hidden_item;\n\tconst char *data;\n\n\thidden_item = proto_tree_add_uint(\n\t\ttree, hf_printerdata, tvb, offset, 0, 1);\n\tPROTO_ITEM_SET_HIDDEN(hidden_item);\n\n\t/* Parse packet */\n\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, tree, di, drep,\n\t\t\t\t    hf_printerdata_type, &type);\n\n\tdata = (const char *)(dcv->se_data ? dcv->se_data : \"????\");\n\n\tcol_append_fstr(pinfo->cinfo, COL_INFO, \", %s\", data);\n\n\toffset = dissect_printerdata_data(\n\t\ttvb, offset, pinfo, tree, di, drep, type);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_needed, NULL);\n\n\toffset = dissect_doserror(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_rc, NULL);\n\n\treturn offset;\n}\n\n/*\n * SpoolssGetPrinterDataEx\n */\n\nstatic int\nSpoolssGetPrinterDataEx_q(tvbuff_t *tvb, int offset,\n\t\t\t\t     packet_info *pinfo, proto_tree *tree,\n\t\t\t\t     dcerpc_info *di, guint8 *drep _U_)\n{\n\tdcerpc_call_value *dcv = (dcerpc_call_value *)di->call_data;\n\tchar *key_name, *value_name;\n\tproto_item *hidden_item;\n\n\thidden_item = proto_tree_add_uint(\n\t\ttree, hf_printerdata, tvb, offset, 0, 1);\n\tPROTO_ITEM_SET_HIDDEN(hidden_item);\n\n\t/* Parse packet */\n\n\toffset = dissect_nt_policy_hnd(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_hnd, NULL, NULL,\n\t\tFALSE, FALSE);\n\n\tkey_name=NULL;\n\toffset = dissect_ndr_cvstring(\n\t\ttvb, offset, pinfo, tree, di, drep, sizeof(guint16),\n\t\thf_printerdata_key, TRUE, &key_name);\n\n\tvalue_name=NULL;\n\toffset = dissect_ndr_cvstring(\n\t\ttvb, offset, pinfo, tree, di, drep, sizeof(guint16),\n\t\thf_printerdata_value, TRUE, &value_name);\n\n\t/* GetPrinterDataEx() stores the key/value in se_data */\n\tif(!pinfo->fd->flags.visited){\n\t\tif(!dcv->se_data){\n\t\t\tdcv->se_data = wmem_strdup_printf(wmem_file_scope(),\n\t\t\t\t\"%s==%s\",\n\t\t\t\tkey_name?key_name:\"\",\n\t\t\t\tvalue_name?value_name:\"\");\n\t\t}\n\t}\n\n\tif (dcv->se_data)\n\t\tcol_append_fstr(pinfo->cinfo, COL_INFO, \", %s\",\n\t\t\t\t(char *)dcv->se_data);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_needed, NULL);\n\n\treturn offset;\n}\n\nstatic int\nSpoolssGetPrinterDataEx_r(tvbuff_t *tvb, int offset,\n\t\t\t\t     packet_info *pinfo, proto_tree *tree,\n\t\t\t\t     dcerpc_info *di, guint8 *drep _U_)\n{\n\tdcerpc_call_value *dcv = (dcerpc_call_value *)di->call_data;\n\tguint32 size, type;\n\tproto_item *hidden_item;\n\n\thidden_item = proto_tree_add_uint(\n\t\ttree, hf_printerdata, tvb, offset, 0, 1);\n\tPROTO_ITEM_SET_HIDDEN(hidden_item);\n\n\t/* Parse packet */\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printerdata_type, &type);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_returned, &size);\n\n\tif (dcv->se_data) {\n\t\tcol_append_fstr(pinfo->cinfo, COL_INFO, \", %s\", (char *)dcv->se_data);\n\t}\n\n\tif (size)\n\t\tdissect_printerdata_data(tvb, offset, pinfo, tree, di, drep, type);\n\n\toffset += size;\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_needed, NULL);\n\n\toffset = dissect_doserror(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_rc, NULL);\n\n\treturn offset;\n}\n\n/*\n * SpoolssSetPrinterData\n */\n\nstatic int\nSpoolssSetPrinterData_q(tvbuff_t *tvb, int offset,\n\t\t\t\t   packet_info *pinfo, proto_tree *tree,\n\t\t\t\t   dcerpc_info *di, guint8 *drep _U_)\n{\n\tdcerpc_call_value *dcv = (dcerpc_call_value *)di->call_data;\n\tchar *value_name;\n\tguint32 type;\n\tproto_item *hidden_item;\n\n\thidden_item = proto_tree_add_uint(\n\t\ttree, hf_printerdata, tvb, offset, 0, 1);\n\tPROTO_ITEM_SET_HIDDEN(hidden_item);\n\n\t/* Parse packet */\n\n\toffset = dissect_nt_policy_hnd(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_hnd, NULL, NULL,\n\t\tFALSE, FALSE);\n\n\tvalue_name=NULL;\n\toffset = dissect_ndr_cvstring(\n\t\ttvb, offset, pinfo, tree, di, drep, sizeof(guint16),\n\t\thf_printerdata_value, TRUE, &value_name);\n\n\t/* GetPrinterDataEx() stores the key/value in se_data */\n\tif(!pinfo->fd->flags.visited){\n\t\tif(!dcv->se_data){\n\t\t\tdcv->se_data = wmem_strdup_printf(wmem_file_scope(),\n\t\t\t\t\"%s\", value_name?value_name:\"\");\n\t\t}\n\t}\n\n\n\tif (dcv->se_data){\n\t\tcol_append_fstr(pinfo->cinfo, COL_INFO, \", %s\", (char *)dcv->se_data);\n\t}\n\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, tree, di, drep,\n\t\t\t\t    hf_printerdata_type, &type);\n\n\toffset = dissect_printerdata_data(\n\t\ttvb, offset, pinfo, tree, di, drep, type);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_offered, NULL);\n\n\treturn offset;\n}\n\nstatic int\nSpoolssSetPrinterData_r(tvbuff_t *tvb, int offset,\n\t\t\t\t   packet_info *pinfo, proto_tree *tree,\n\t\t\t\t   dcerpc_info *di, guint8 *drep _U_)\n{\n\tproto_item *hidden_item;\n\n\thidden_item = proto_tree_add_uint(\n\t\ttree, hf_printerdata, tvb, offset, 0, 1);\n\tPROTO_ITEM_SET_HIDDEN(hidden_item);\n\n\t/* Parse packet */\n\n\toffset = dissect_doserror(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_rc, NULL);\n\n\treturn offset;\n}\n\n/*\n * SpoolssSetPrinterDataEx\n */\n\nstatic int hf_setprinterdataex_max_len = -1;\nstatic int hf_setprinterdataex_real_len = -1;\nstatic int hf_setprinterdataex_data = -1;\n\nstatic int\nSpoolssSetPrinterDataEx_q(tvbuff_t *tvb, int offset,\n\t\t\t\t     packet_info *pinfo, proto_tree *tree,\n\t\t\t\t     dcerpc_info *di, guint8 *drep _U_)\n{\n\tchar *key_name, *value_name;\n\tguint32 max_len;\n\tproto_item *hidden_item;\n\n\thidden_item = proto_tree_add_uint(\n\t\ttree, hf_printerdata, tvb, offset, 0, 1);\n\tPROTO_ITEM_SET_HIDDEN(hidden_item);\n\n\t/* Parse packet */\n\n\toffset = dissect_nt_policy_hnd(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_hnd, NULL, NULL,\n\t\tFALSE, FALSE);\n\n\toffset = dissect_ndr_cvstring(\n\t\ttvb, offset, pinfo, tree, di, drep, sizeof(guint16),\n\t\thf_printerdata_key, TRUE, &key_name);\n\n\toffset = dissect_ndr_cvstring(\n\t\ttvb, offset, pinfo, tree, di, drep, sizeof(guint16),\n\t\thf_printerdata_value, TRUE, &value_name);\n\n\tcol_append_fstr(pinfo->cinfo, COL_INFO, \", %s/%s\",\n\t\t\t\tkey_name, value_name);\n\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, tree, di, drep,\n\t\t\t\t    hf_printerdata_type, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep,\n\t\thf_setprinterdataex_max_len, &max_len);\n\n\toffset = dissect_ndr_uint8s(\n\t\ttvb, offset, pinfo, tree, di, drep,\n\t\thf_setprinterdataex_data, max_len, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep,\n\t\thf_setprinterdataex_real_len, NULL);\n\n\treturn offset;\n}\n\nstatic int\nSpoolssSetPrinterDataEx_r(tvbuff_t *tvb, int offset,\n\t\t\t\t     packet_info *pinfo, proto_tree *tree,\n\t\t\t\t     dcerpc_info *di, guint8 *drep _U_)\n{\n\tproto_item *hidden_item;\n\n\thidden_item = proto_tree_add_uint(\n\t\ttree, hf_printerdata, tvb, offset, 0, 1);\n\tPROTO_ITEM_SET_HIDDEN(hidden_item);\n\n\t/* Parse packet */\n\n\toffset = dissect_doserror(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_rc, NULL);\n\n\treturn offset;\n}\n\n/* XXX - \"name\" should be an hf_ value for an FT_STRING. */\nstatic int\ndissect_spoolss_uint16uni(tvbuff_t *tvb, int offset, packet_info *pinfo _U_,\n\t\t\t  proto_tree *tree, guint8 *drep _U_, char **data,\n\t\t\t  int hf_name)\n{\n\tgint len, remaining;\n\tchar *text;\n\n\tif (offset % 2)\n\t\toffset += 2 - (offset % 2);\n\n\t/* Get remaining data in buffer as a string */\n\n\tremaining = tvb_reported_length_remaining(tvb, offset);\n\tif (remaining <= 0) {\n\t\tif (data)\n\t\t\t*data = g_strdup(\"\");\n\t\treturn offset;\n\t}\n\n\ttext = tvb_get_string_enc(NULL, tvb, offset, remaining, ENC_UTF_16|ENC_LITTLE_ENDIAN);\n\tlen = (int)strlen(text);\n\n\tproto_tree_add_string(tree, hf_name, tvb, offset, len * 2, text);\n\n\tif (data)\n\t\t*data = text;\n\telse\n\t\tg_free(text);\n\n\treturn offset + (len + 1) * 2;\n}\n\n/*\n * DEVMODE\n */\n\n/* Devicemode orientation values */\n\nstatic const value_string devmode_orientation_vals[] =\n{\n\t{ DEVMODE_ORIENTATION_PORTRAIT, \"Portrait\" },\n\t{ DEVMODE_ORIENTATION_LANDSCAPE, \"Landscape\" },\n\t{ 0, NULL }\n};\n\n/* Paper size values.  International paper sizes is a fascinating\n   topic.  No seriously!  (-: */\n\nstatic const value_string devmode_papersize_vals[] =\n{\n\t{ DEVMODE_PAPERSIZE_LETTER, \"Letter\" },\n\t{ DEVMODE_PAPERSIZE_LETTERSMALL, \"Letter (small)\" },\n\t{ DEVMODE_PAPERSIZE_TABLOID, \"Tabloid\" },\n\t{ DEVMODE_PAPERSIZE_LEDGER, \"Ledger\" },\n\t{ DEVMODE_PAPERSIZE_LEGAL, \"Legal\" },\n\t{ DEVMODE_PAPERSIZE_STATEMENT, \"Statement\" },\n\t{ DEVMODE_PAPERSIZE_EXECUTIVE, \"Executive\" },\n\t{ DEVMODE_PAPERSIZE_A3, \"A3\" },\n\t{ DEVMODE_PAPERSIZE_A4, \"A4\" },\n\t{ DEVMODE_PAPERSIZE_A4SMALL, \"A4 (small)\" },\n\t{ DEVMODE_PAPERSIZE_A5, \"A5\" },\n\t{ DEVMODE_PAPERSIZE_B4, \"B4\" },\n\t{ DEVMODE_PAPERSIZE_B5, \"B5\" },\n\t{ DEVMODE_PAPERSIZE_FOLIO, \"Folio\" },\n\t{ DEVMODE_PAPERSIZE_QUARTO, \"Quarto\" },\n\t{ DEVMODE_PAPERSIZE_10X14, \"10x14\" },\n\t{ DEVMODE_PAPERSIZE_11X17, \"11x17\" },\n\t{ DEVMODE_PAPERSIZE_NOTE, \"Note\" },\n\t{ DEVMODE_PAPERSIZE_ENV9, \"Envelope #9\" },\n\t{ DEVMODE_PAPERSIZE_ENV10, \"Envelope #10\" },\n\t{ DEVMODE_PAPERSIZE_ENV11, \"Envelope #11\" },\n\t{ DEVMODE_PAPERSIZE_ENV12, \"Envelope #12\" },\n\t{ DEVMODE_PAPERSIZE_ENV14, \"Envelope #14\" },\n\t{ DEVMODE_PAPERSIZE_CSHEET, \"C sheet\" },\n\t{ DEVMODE_PAPERSIZE_DSHEET, \"D sheet\" },\n\t{ DEVMODE_PAPERSIZE_ESHEET, \"E sheet\" },\n\t{ DEVMODE_PAPERSIZE_ENVDL, \"Envelope DL\" },\n\t{ DEVMODE_PAPERSIZE_ENVC5, \"Envelope C5\" },\n\t{ DEVMODE_PAPERSIZE_ENVC3, \"Envelope C3\" },\n\t{ DEVMODE_PAPERSIZE_ENVC4, \"Envelope C4\" },\n\t{ DEVMODE_PAPERSIZE_ENVC6, \"Envelope C6\" },\n\t{ DEVMODE_PAPERSIZE_ENVC65, \"Envelope C65\" },\n\t{ DEVMODE_PAPERSIZE_ENVB4, \"Envelope B4\" },\n\t{ DEVMODE_PAPERSIZE_ENVB5, \"Envelope B5\" },\n\t{ DEVMODE_PAPERSIZE_ENVB6, \"Envelope B6\" },\n\t{ DEVMODE_PAPERSIZE_ENVITALY, \"Envelope (Italy)\" },\n\t{ DEVMODE_PAPERSIZE_ENVMONARCH, \"Envelope (Monarch)\" },\n\t{ DEVMODE_PAPERSIZE_ENVPERSONAL, \"Envelope (Personal)\" },\n\t{ DEVMODE_PAPERSIZE_FANFOLDUS, \"Fanfold (US)\" },\n\t{ DEVMODE_PAPERSIZE_FANFOLDSTDGERMAN, \"Fanfold (Std German)\" },\n\t{ DEVMODE_PAPERSIZE_FANFOLDLGLGERMAN, \"Fanfold (Legal German)\" },\n\t{ DEVMODE_PAPERSIZE_ISOB4, \"B4 (ISO)\" },\n\t{ DEVMODE_PAPERSIZE_JAPANESEPOSTCARD, \"Japanese postcard\" },\n\t{ DEVMODE_PAPERSIZE_9X11, \"9x11\" },\n\t{ DEVMODE_PAPERSIZE_10X11, \"10x11\" },\n\t{ DEVMODE_PAPERSIZE_15X11, \"15x11\" },\n\t{ DEVMODE_PAPERSIZE_ENVINVITE, \"Envelope (Invite)\" },\n\t{ DEVMODE_PAPERSIZE_RESERVED48, \"Reserved (48)\" },\n\t{ DEVMODE_PAPERSIZE_RESERVED49, \"Reserved (49)\" },\n\t{ DEVMODE_PAPERSIZE_LETTEREXTRA, \"Letter (Extra)\" },\n\t{ DEVMODE_PAPERSIZE_LEGALEXTRA, \"Legal (Extra)\" },\n\t{ DEVMODE_PAPERSIZE_TABLOIDEXTRA, \"Tabloid (Extra)\" },\n\t{ DEVMODE_PAPERSIZE_A4EXTRA, \"A4 (Extra)\" },\n\t{ DEVMODE_PAPERSIZE_LETTERTRANS, \"Letter (Transverse)\" },\n\t{ DEVMODE_PAPERSIZE_A4TRANS, \"A4 (Transverse)\" },\n\t{ DEVMODE_PAPERSIZE_LETTEREXTRATRANS, \"Letter (Extra, Transverse)\" },\n\t{ DEVMODE_PAPERSIZE_APLUS, \"A+\" },\n\t{ DEVMODE_PAPERSIZE_BPLUS, \"B+\" },\n\t{ DEVMODE_PAPERSIZE_LETTERPLUS, \"Letter+\" },\n\t{ DEVMODE_PAPERSIZE_A4PLUS, \"A4+\" },\n\t{ DEVMODE_PAPERSIZE_A5TRANS, \"A5 (Transverse)\" },\n\t{ DEVMODE_PAPERSIZE_B5TRANS, \"B5 (Transverse)\" },\n\t{ DEVMODE_PAPERSIZE_A3EXTRA, \"A3 (Extra)\" },\n\t{ DEVMODE_PAPERSIZE_A5EXTRA, \"A5 (Extra)\" },\n\t{ DEVMODE_PAPERSIZE_B5EXTRA, \"B5 (Extra)\" },\n\t{ DEVMODE_PAPERSIZE_A2, \"A2\" },\n\t{ DEVMODE_PAPERSIZE_A3TRANS, \"A3 (Transverse)\" },\n\t{ DEVMODE_PAPERSIZE_A3EXTRATRANS, \"A3 (Extra, Transverse\" },\n\t{ DEVMODE_PAPERSIZE_DBLJAPANESEPOSTCARD, \"Double Japanese Postcard\" },\n\t{ DEVMODE_PAPERSIZE_A6, \"A6\" },\n\t{ DEVMODE_PAPERSIZE_JENVKAKU2, \"Japanese Envelope (Kaku #2)\" },\n\t{ DEVMODE_PAPERSIZE_JENVKAKU3, \"Japanese Envelope (Kaku #3)\" },\n\t{ DEVMODE_PAPERSIZE_JENVCHOU3, \"Japanese Envelope (Chou #3)\" },\n\t{ DEVMODE_PAPERSIZE_JENVCHOU4, \"Japaneve Envelope (Chou #4)\" },\n\t{ DEVMODE_PAPERSIZE_LETTERROT, \"Letter (Rotated)\" },\n\t{ DEVMODE_PAPERSIZE_A3ROT, \"A3 (Rotated)\" },\n\t{ DEVMODE_PAPERSIZE_A4ROT, \"A4 (Rotated)\" },\n\t{ DEVMODE_PAPERSIZE_A5ROT, \"A5 (Rotated)\" },\n\t{ DEVMODE_PAPERSIZE_B4JISROT, \"B4 (JIS, Rotated)\" },\n\t{ DEVMODE_PAPERSIZE_B5JISROT, \"B5 (JIS, Rotated)\"},\n\t{ DEVMODE_PAPERSIZE_JAPANESEPOSTCARDROT,\n\t  \"Japanese Postcard (Rotated)\" },\n\t{ DEVMODE_PAPERSIZE_DBLJAPANESEPOSTCARDROT82,\n\t  \"Double Japanese Postcard (Rotated)\" },\n\t{ DEVMODE_PAPERSIZE_A6ROT, \"A6 (Rotated)\" },\n\t{ DEVMODE_PAPERSIZE_JENVKAKU2ROT,\n\t  \"Japanese Envelope (Kaku #2, Rotated)\" },\n\t{ DEVMODE_PAPERSIZE_JENVKAKU3ROT,\n\t  \"Japanese Envelope (Kaku #3, Rotated)\" },\n\t{ DEVMODE_PAPERSIZE_JENVCHOU3ROT,\n\t  \"Japanese Envelope (Chou #3, Rotated)\" },\n\t{ DEVMODE_PAPERSIZE_JENVCHOU4ROT,\n\t  \"Japanese Envelope (Chou #4, Rotated)\" },\n\t{ DEVMODE_PAPERSIZE_B6JIS, \"B6 (JIS)\" },\n\t{ DEVMODE_PAPERSIZE_B6JISROT, \"B6 (JIS, Rotated)\" },\n\t{ DEVMODE_PAPERSIZE_12X11, \"12x11\" },\n\t{ DEVMODE_PAPERSIZE_JENVYOU4, \"Japanese Envelope (You #4)\" },\n\t{ DEVMODE_PAPERSIZE_JENVYOU4ROT,\n\t  \"Japanese Envelope (You #4, Rotated\" },\n\t{ DEVMODE_PAPERSIZE_P16K, \"PRC 16K\" },\n\t{ DEVMODE_PAPERSIZE_P32K, \"PRC 32K\" },\n\t{ DEVMODE_PAPERSIZE_P32KBIG, \"P32K (Big)\" },\n\t{ DEVMODE_PAPERSIZE_PENV1, \"PRC Envelope #1\" },\n\t{ DEVMODE_PAPERSIZE_PENV2, \"PRC Envelope #2\" },\n\t{ DEVMODE_PAPERSIZE_PENV3, \"PRC Envelope #3\" },\n\t{ DEVMODE_PAPERSIZE_PENV4, \"PRC Envelope #4\" },\n\t{ DEVMODE_PAPERSIZE_PENV5, \"PRC Envelope #5\" },\n\t{ DEVMODE_PAPERSIZE_PENV6, \"PRC Envelope #6\" },\n\t{ DEVMODE_PAPERSIZE_PENV7, \"PRC Envelope #7\" },\n\t{ DEVMODE_PAPERSIZE_PENV8, \"PRC Envelope #8\" },\n\t{ DEVMODE_PAPERSIZE_PENV9, \"PRC Envelope #9\" },\n\t{ DEVMODE_PAPERSIZE_PENV10, \"PRC Envelope #10\" },\n\t{ DEVMODE_PAPERSIZE_P16KROT, \"PRC 16K (Rotated)\" },\n\t{ DEVMODE_PAPERSIZE_P32KROT, \"PRC 32K (Rotated)\" },\n\t{ DEVMODE_PAPERSIZE_P32KBIGROT, \"PRC 32K (Big, Rotated)\" },\n\t{ DEVMODE_PAPERSIZE_PENV1ROT, \"PRC Envelope #1 (Rotated)\" },\n\t{ DEVMODE_PAPERSIZE_PENV2ROT, \"PRC Envelope #2 (Rotated)\" },\n\t{ DEVMODE_PAPERSIZE_PENV3ROT, \"PRC Envelope #3 (Rotated)\" },\n\t{ DEVMODE_PAPERSIZE_PENV4ROT, \"PRC Envelope #4 (Rotated)\" },\n\t{ DEVMODE_PAPERSIZE_PENV5ROT, \"PRC Envelope #5 (Rotated)\" },\n\t{ DEVMODE_PAPERSIZE_PENV6ROT, \"PRC Envelope #6 (Rotated)\" },\n\t{ DEVMODE_PAPERSIZE_PENV7ROT, \"PRC Envelope #7 (Rotated)\" },\n\t{ DEVMODE_PAPERSIZE_PENV8ROT, \"PRC Envelope #8 (Rotated)\" },\n\t{ DEVMODE_PAPERSIZE_PENV9ROT, \"PRC Envelope #9 (Rotated)\" },\n\t{ DEVMODE_PAPERSIZE_PENV10ROT, \"PRC Envelope #10 (Rotated)\" },\n\t{ 0, NULL }\n};\nstatic value_string_ext devmode_papersize_vals_ext = VALUE_STRING_EXT_INIT(devmode_papersize_vals);\n\n/* List of observed specversions */\n\nstatic const value_string devmode_specversion_vals[] =\n{\n\t{ 0x0320, \"Observed\" },\n\t{ 0x0400, \"Observed\" },\n\t{ 0x0401, \"Observed\" },\n\t{ 0x040d, \"Observed\" },\n\t{ 0, NULL }\n};\n\n/* Paper sources */\n\nstatic const value_string devmode_papersource_vals[] =\n{\n\t{ DEVMODE_PAPERSOURCE_UPPER, \"Upper\" },\n\t{ DEVMODE_PAPERSOURCE_LOWER, \"Lower\" },\n\t{ DEVMODE_PAPERSOURCE_MIDDLE, \"Middle\" },\n\t{ DEVMODE_PAPERSOURCE_MANUAL, \"Manual\" },\n\t{ DEVMODE_PAPERSOURCE_ENV, \"Envelope\" },\n\t{ DEVMODE_PAPERSOURCE_ENVMANUAL, \"Envelope Manual\" },\n\t{ DEVMODE_PAPERSOURCE_AUTO, \"Auto\" },\n\t{ DEVMODE_PAPERSOURCE_TRACTOR, \"Tractor\" },\n\t{ DEVMODE_PAPERSOURCE_SMALLFMT, \"Small Format\" },\n\t{ DEVMODE_PAPERSOURCE_LARGEFMAT, \"Large Format\" },\n\t{ DEVMODE_PAPERSOURCE_LARGECAP, \"Large Capacity\" },\n\t{ DEVMODE_PAPERSOURCE_CASSETTE, \"Cassette\" },\n\t{ DEVMODE_PAPERSOURCE_FORMSRC, \"Form Source\" },\n\t{ 0, NULL }\n};\nstatic value_string_ext devmode_papersource_vals_ext = VALUE_STRING_EXT_INIT(devmode_papersource_vals);\n\n/* Print quality */\n\nstatic const value_string devmode_printquality_vals[] =\n{\n\t{ DEVMODE_PRINTQUALITY_HIGH, \"High\" },\n\t{ DEVMODE_PRINTQUALITY_MEDIUM, \"Medium\" },\n\t{ DEVMODE_PRINTQUALITY_LOW, \"Low\" },\n\t{ DEVMODE_PRINTQUALITY_DRAFT, \"Draft\" },\n\t{ 0, NULL }\n};\n\n/* Color */\n\nstatic const value_string devmode_colour_vals[] =\n{\n\t{ DEVMODE_COLOUR_COLOUR, \"Colour\" },\n\t{ DEVMODE_COLOUR_MONO, \"Monochrome\" },\n\t{ 0, NULL }\n};\n\n/* TrueType options */\n\nstatic const value_string devmode_ttoption_vals[] =\n{\n\t{ 0, \"Not set\" },\n\t{ DEVMODE_TTOPTION_BITMAP, \"Bitmap\" },\n\t{ DEVMODE_TTOPTION_DOWNLOAD, \"Download\" },\n\t{ DEVMODE_TTOPTION_DOWNLOAD_OUTLINE, \"Download outline\" },\n\t{ DEVMODE_TTOPTION_SUBDEV, \"Substitute device fonts\" },\n\t{ 0, NULL }\n};\n\n/* Collate info */\n\nstatic const value_string devmode_collate_vals[] =\n{\n\t{ DEVMODE_COLLATE_FALSE, \"False\" },\n\t{ DEVMODE_COLLATE_TRUE, \"True\" },\n\t{ 0, NULL }\n};\n\n/* Duplex info */\n\nstatic const value_string devmode_duplex_vals[] =\n{\n\t{ DEVMODE_DUPLEX_SIMPLEX, \"Simplex\" },\n\t{ DEVMODE_DUPLEX_VERT, \"Vertical\" },\n\t{ DEVMODE_DUPLEX_HORIZ, \"Horizontal\" },\n\t{ 0, NULL }\n};\n\nstatic const value_string devmode_displayflags_vals[] =\n{\n\t{ 0, \"Colour\" },\n\t{ DEVMODE_DISPLAYFLAGS_GRAYSCALE, \"Grayscale\" },\n\t{ DEVMODE_DISPLAYFLAGS_INTERLACED, \"Interlaced\" },\n\t{ 0, NULL }\n};\n\nstatic const value_string devmode_icmmethod_vals[] =\n{\n\t{ DEVMODE_ICMMETHOD_NONE, \"None\" },\n\t{ DEVMODE_ICMMETHOD_SYSTEM, \"System\" },\n\t{ DEVMODE_ICMMETHOD_DRIVER, \"Driver\" },\n\t{ DEVMODE_ICMMETHOD_DEVICE, \"Device\" },\n\t{ 0, NULL }\n};\n\nstatic const value_string devmode_icmintent_vals[] =\n{\n\t{ 0, \"Not set\" },\n\t{ DEVMODE_ICMINTENT_SATURATE, \"Saturate\" },\n\t{ DEVMODE_ICMINTENT_CONTRAST, \"Contrast\" },\n\t{ DEVMODE_ICMINTENT_COLORIMETRIC, \"Colorimetric\" },\n\t{ DEVMODE_ICMINTENT_ABS_COLORIMETRIC, \"Absolute colorimetric\" },\n\t{ 0, NULL }\n};\n\nstatic const value_string devmode_mediatype_vals[] =\n{\n\t{ 0, \"Not set\" },\n\t{ DEVMODE_MEDIATYPE_STANDARD, \"Standard\" },\n\t{ DEVMODE_MEDIATYPE_TRANSPARENCY, \"Transparency\" },\n\t{ DEVMODE_MEDIATYPE_GLOSSY, \"Glossy\" },\n\t{ 0, NULL }\n};\n\nstatic const value_string devmode_dithertype_vals[] =\n{\n\t{ 0, \"Not set\" },\n\t{ DEVMODE_DITHERTYPE_NONE, \"None\" },\n\t{ DEVMODE_DITHERTYPE_COARSE, \"Coarse\" },\n\t{ DEVMODE_DITHERTYPE_LINE, \"Line\" },\n\t{ DEVMODE_DITHERTYPE_LINEART, \"Line art\" },\n\t{ DEVMODE_DITHERTYPE_ERRORDIFFUSION, \"Error diffusion\" },\n\t{ DEVMODE_DITHERTYPE_RESERVED6, \"Reserved 6\" },\n\t{ DEVMODE_DITHERTYPE_RESERVED7, \"Reserved 7\" },\n\t{ DEVMODE_DITHERTYPE_GRAYSCALE, \"Grayscale\" },\n\t{ 0, NULL }\n};\n\nstatic gint ett_DEVMODE_fields = -1;\n\nstatic int\ndissect_DEVMODE_fields(tvbuff_t *tvb, gint offset, packet_info *pinfo,\n\t\t       proto_tree *tree, dcerpc_info *di, guint8 *drep _U_, guint32 *pdata)\n{\n\tguint32 fields;\n\tproto_item *hidden_item;\n\n\tstatic const int * hf_fields[] = {\n\t\t&hf_devmode_fields_orientation,\n\t\t&hf_devmode_fields_papersize,\n\t\t&hf_devmode_fields_paperlength,\n\t\t&hf_devmode_fields_paperwidth,\n\t\t&hf_devmode_fields_scale,\n\t\t&hf_devmode_fields_position,\n\t\t&hf_devmode_fields_nup,\n\t\t&hf_devmode_fields_copies,\n\t\t&hf_devmode_fields_defaultsource,\n\t\t&hf_devmode_fields_printquality,\n\t\t&hf_devmode_fields_color,\n\t\t&hf_devmode_fields_duplex,\n\t\t&hf_devmode_fields_yresolution,\n\t\t&hf_devmode_fields_ttoption,\n\t\t&hf_devmode_fields_collate,\n\t\t&hf_devmode_fields_formname,\n\t\t&hf_devmode_fields_logpixels,\n\t\t&hf_devmode_fields_bitsperpel,\n\t\t&hf_devmode_fields_pelswidth,\n\t\t&hf_devmode_fields_pelsheight,\n\t\t&hf_devmode_fields_displayflags,\n\t\t&hf_devmode_fields_displayfrequency,\n\t\t&hf_devmode_fields_icmmethod,\n\t\t&hf_devmode_fields_icmintent,\n\t\t&hf_devmode_fields_mediatype,\n\t\t&hf_devmode_fields_dithertype,\n\t\t&hf_devmode_fields_panningwidth,\n\t\t&hf_devmode_fields_panningheight,\n\t\tNULL\n\t};\n\n\thidden_item = proto_tree_add_uint(\n\t\ttree, hf_devmode, tvb, offset, 0, 1);\n\tPROTO_ITEM_SET_HIDDEN(hidden_item);\n\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, NULL, di, drep, -1, &fields);\n\n\tproto_tree_add_bitmask_value_with_flags(tree, tvb, offset - 4, hf_devmode_fields,\n\t\t\t\t\tett_DEVMODE_fields, hf_fields, fields, BMT_NO_APPEND);\n\n\tif (pdata)\n\t\t*pdata = fields;\n\n\treturn offset;\n}\n\nstatic gint ett_DEVMODE = -1;\n\nstatic int\ndissect_DEVMODE(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\t   proto_tree *tree, dcerpc_info *di, guint8 *drep)\n{\n\tproto_item *item;\n\tproto_tree *subtree;\n\tguint16 driver_extra;\n\tgint16 print_quality;\n\tguint32 fields;\n\tint struct_start = offset;\n\n\tif (di->conformant_run)\n\t\treturn offset;\n\n\tsubtree = proto_tree_add_subtree(tree, tvb, offset, 0, ett_DEVMODE, &item, \"Devicemode\");\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_devmode_size,\n\t\tNULL);\n\n\t/* The device name is stored in a 32-wchar buffer */\n\n\tdissect_spoolss_uint16uni(tvb, offset, pinfo, subtree, drep, NULL, hf_devmode_devicename);\n\toffset += 64;\n\n\toffset = dissect_ndr_uint16(\n\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\thf_devmode_spec_version, NULL);\n\n\toffset = dissect_ndr_uint16(\n\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\thf_devmode_driver_version, NULL);\n\n\toffset = dissect_ndr_uint16(\n\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\thf_devmode_size2, NULL);\n\n\toffset = dissect_ndr_uint16(\n\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\thf_devmode_driver_extra_len, &driver_extra);\n\n\toffset = dissect_DEVMODE_fields(\n\t\ttvb, offset, pinfo, subtree, di, drep, &fields);\n\n\toffset = dissect_ndr_uint16(\n\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\thf_devmode_orientation, NULL);\n\n\toffset = dissect_ndr_uint16(\n\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\thf_devmode_paper_size, NULL);\n\n\toffset = dissect_ndr_uint16(\n\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\thf_devmode_paper_length, NULL);\n\n\toffset = dissect_ndr_uint16(\n\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\thf_devmode_paper_width, NULL);\n\n\toffset = dissect_ndr_uint16(\n\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\thf_devmode_scale, NULL);\n\n\toffset = dissect_ndr_uint16(\n\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\thf_devmode_copies, NULL);\n\n\toffset = dissect_ndr_uint16(\n\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\thf_devmode_default_source, NULL);\n\n\toffset = dissect_ndr_uint16(\n\t\ttvb, offset, pinfo, NULL, di, drep,\n\t\thf_devmode_print_quality, &print_quality);\n\n\tif (print_quality < 0)\n\t\tproto_tree_add_item(\n\t\t\tsubtree, hf_devmode_print_quality, tvb,\n\t\t\toffset - 2, 2, DREP_ENC_INTEGER(drep));\n\telse\n\t\tproto_tree_add_uint_format_value(\n\t\t\tsubtree, hf_devmode_print_quality, tvb, offset - 4, 4,\n\t\t\tprint_quality, \"%d dpi\", print_quality);\n\n\toffset = dissect_ndr_uint16(\n\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\thf_devmode_color, NULL);\n\n\toffset = dissect_ndr_uint16(\n\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\thf_devmode_duplex, NULL);\n\n\toffset = dissect_ndr_uint16(\n\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\thf_devmode_y_resolution, NULL);\n\n\toffset = dissect_ndr_uint16(\n\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\thf_devmode_tt_option, NULL);\n\n\toffset = dissect_ndr_uint16(\n\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\thf_devmode_collate, NULL);\n\n\tdissect_spoolss_uint16uni(tvb, offset, pinfo, subtree, drep, NULL, hf_devmode_form_name);\n\toffset += 64;\n\n\toffset = dissect_ndr_uint16(\n\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\thf_devmode_log_pixels, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\thf_devmode_bits_per_pel, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\thf_devmode_pels_width, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\thf_devmode_pels_height, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\thf_devmode_display_flags, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\thf_devmode_display_freq, NULL);\n\n\t/* TODO: Some of the remaining fields are optional.  See\n\t   rpc_parse/parse_spoolss.c in the Samba source for details. */\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\thf_devmode_icm_method, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\thf_devmode_icm_intent, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\thf_devmode_media_type, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\thf_devmode_dither_type, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\thf_devmode_reserved1, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\thf_devmode_reserved2, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\thf_devmode_panning_width, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\thf_devmode_panning_height, NULL);\n\n\tif (driver_extra)\n\t\toffset = dissect_ndr_uint8s(\n\t\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\t\thf_devmode_driver_extra, driver_extra, NULL);\n\n\tproto_item_set_len(item, offset - struct_start);\n\n\treturn offset;\n}\n\n/*\n * DEVMODE_CTR\n */\n\nstatic gint ett_DEVMODE_CTR = -1;\n\nstatic int\ndissect_DEVMODE_CTR(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\t       proto_tree *tree, dcerpc_info *di, guint8 *drep)\n{\n\tproto_tree *subtree;\n\tguint32 size;\n\n\tsubtree = proto_tree_add_subtree(\n\t\ttree, tvb, offset, 0, ett_DEVMODE_CTR, NULL, \"Devicemode container\");\n\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, subtree, di, drep,\n\t\t\t\t    hf_devmodectr_size, &size);\n\n\toffset = dissect_ndr_pointer(\n\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\tdissect_DEVMODE, NDR_POINTER_UNIQUE, \"Devicemode\", -1);\n\n\treturn offset;\n}\n\n/*\n * Relative string given by offset into the current buffer.  Note that\n * the offset for subsequent relstrs are against the structure start, not\n * the point where the offset is parsed from.\n */\n\nstatic gint ett_RELSTR = -1;\n\nstatic int\ndissect_spoolss_relstr(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t       proto_tree *tree, dcerpc_info *di, guint8 *drep, int hf_index,\n\t\t       int struct_start, char **data)\n{\n\tproto_item *item;\n\tproto_tree *subtree;\n\tguint32 relstr_offset, relstr_start, relstr_end;\n\tchar *text;\n\n\t/* Peek ahead to read the string.  We need this for the\n\t   proto_tree_add_string() call so filtering will work. */\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, NULL, di, drep, hf_offset, &relstr_offset);\n\n\trelstr_start = relstr_offset + struct_start;\n\n\tif (relstr_offset) {\n\t\trelstr_end = dissect_spoolss_uint16uni(\n\t\t\ttvb, relstr_start, pinfo, NULL, drep, &text, hf_relative_string);\n\t} else { \t\t\t/* relstr_offset == 0 is a NULL string */\n\t\ttext = g_strdup(\"\");\n\t\trelstr_end = relstr_start;\n\t}\n\n\t/* OK now add the proto item with the string value */\n\n\titem = proto_tree_add_string(tree, hf_index, tvb, relstr_start, relstr_end - relstr_start, text);\n\tsubtree = proto_item_add_subtree(item, ett_RELSTR);\n\n\tdissect_ndr_uint32(\n\t\ttvb, offset - 4, pinfo, subtree, di, drep, hf_offset, NULL);\n\n\tif (relstr_offset)\n\t\tdissect_spoolss_uint16uni(\n\t\t\ttvb, relstr_start, pinfo, subtree, drep, NULL, hf_relative_string);\n\n\tif (data)\n\t\t*data = text;\n\telse\n\t\tg_free(text);\n\n\treturn offset;\n}\n\n/* An array of relative strings.  This is currently just a copy of the\n   dissect_spoolss_relstr() function as I can't find an example driver that\n   has more than one dependent file. */\n\nstatic gint ett_RELSTR_ARRAY = -1;\n\nstatic int\ndissect_spoolss_relstrarray(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\t    proto_tree *tree, dcerpc_info *di, guint8 *drep, int hf_index,\n\t\t\t    int struct_start, char **data)\n{\n\tproto_item *item;\n\tproto_tree *subtree;\n\tguint32 relstr_offset, relstr_start/*, relstr_end, relstr_len*/;\n\tchar *text;\n\n\titem = proto_tree_add_string(tree, hf_index, tvb, offset, 4, \"\");\n\n\tsubtree = proto_item_add_subtree(item, ett_RELSTR_ARRAY);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_offset, &relstr_offset);\n\n\t/* A relative offset of zero is a NULL string */\n\n\trelstr_start = relstr_offset + struct_start;\n\n\tif (relstr_offset)\n\t\t/*relstr_end = */dissect_spoolss_uint16uni(\n\t\t\ttvb, relstr_start, pinfo, subtree, drep, &text, hf_relative_string);\n\telse {\n\t\ttext = g_strdup(\"NULL\");\n\t\t/*relstr_end = offset;*/\n\t}\n\n\t/*relstr_len = relstr_end - relstr_start;*/\n\n\tproto_item_append_text(item, \"%s\", text);\n\n\tif (data)\n\t\t*data = text;\n\telse\n\t\tg_free(text);\n\n\treturn offset;\n}\n\n/*\n * PRINTER_INFO_0\n */\n\nstatic int hf_printer_status = -1;\n\nstatic const value_string printer_status_vals[] =\n{\n\t{ PRINTER_STATUS_OK, \"OK\" },\n\t{ PRINTER_STATUS_PAUSED, \"Paused\" },\n\t{ PRINTER_STATUS_ERROR, \"Error\" },\n\t{ PRINTER_STATUS_PENDING_DELETION, \"Pending deletion\" },\n\t{ PRINTER_STATUS_PAPER_JAM, \"Paper jam\" },\n\t{ PRINTER_STATUS_PAPER_OUT, \"Paper out\" },\n\t{ PRINTER_STATUS_MANUAL_FEED, \"Manual feed\" },\n\t{ PRINTER_STATUS_PAPER_PROBLEM, \"Paper problem\" },\n\t{ PRINTER_STATUS_OFFLINE, \"Offline\" },\n\t{ PRINTER_STATUS_IO_ACTIVE, \"IO active\" },\n\t{ PRINTER_STATUS_BUSY, \"Busy\" },\n\t{ PRINTER_STATUS_PRINTING, \"Printing\" },\n\t{ PRINTER_STATUS_OUTPUT_BIN_FULL, \"Output bin full\" },\n\t{ PRINTER_STATUS_NOT_AVAILABLE, \"Not available\" },\n\t{ PRINTER_STATUS_WAITING, \"Waiting\" },\n\t{ PRINTER_STATUS_PROCESSING, \"Processing\" },\n\t{ PRINTER_STATUS_INITIALIZING, \"Initialising\" },\n\t{ PRINTER_STATUS_WARMING_UP, \"Warming up\" },\n\t{ PRINTER_STATUS_TONER_LOW, \"Toner low\" },\n\t{ PRINTER_STATUS_NO_TONER, \"No toner\" },\n\t{ PRINTER_STATUS_PAGE_PUNT, \"Page punt\" },\n\t{ PRINTER_STATUS_USER_INTERVENTION, \"User intervention\" },\n\t{ PRINTER_STATUS_OUT_OF_MEMORY, \"Out of memory\" },\n\t{ PRINTER_STATUS_DOOR_OPEN, \"Door open\" },\n\t{ PRINTER_STATUS_SERVER_UNKNOWN, \"Server unknown\" },\n\t{ PRINTER_STATUS_POWER_SAVE, \"Power save\" },\n\t{ 0, NULL }\n};\nstatic value_string_ext printer_status_vals_ext = VALUE_STRING_EXT_INIT(printer_status_vals);\n\nstatic gint ett_PRINTER_INFO_0 = -1;\n\nstatic int\ndissect_PRINTER_INFO_0(tvbuff_t *tvb, int offset,\n\t\t\t\t  packet_info *pinfo, proto_tree *tree,\n\t\t\t\t  dcerpc_info *di, guint8 *drep)\n{\n\toffset = dissect_spoolss_relstr(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printername,\n\t\t0, NULL);\n\n\toffset = dissect_spoolss_relstr(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_servername,\n\t\t0, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printer_cjobs, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printer_total_jobs,\n\t\tNULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printer_total_bytes,\n\t\tNULL);\n\n\toffset = dissect_SYSTEM_TIME(\n\t\ttvb, offset, pinfo, tree, di, drep, \"Unknown time\", TRUE, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printer_global_counter,\n\t\tNULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printer_total_pages,\n\t\tNULL);\n\n\toffset = dissect_ndr_uint16(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printer_major_version,\n\t\tNULL);\n\n\toffset = dissect_ndr_uint16(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printer_build_version,\n\t\tNULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printer_unk7, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printer_unk8, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printer_unk9, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printer_session_ctr,\n\t\tNULL);\n\n\toffset = dissect_ndr_uint32( tvb, offset, pinfo, tree, di, drep,\n\t\thf_printer_unk11, NULL);\n\n\toffset = dissect_ndr_uint32( tvb, offset, pinfo, tree, di, drep,\n\t\thf_printer_printer_errors, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printer_unk13, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printer_unk14, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printer_unk15, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printer_unk16, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printer_changeid, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printer_unk18, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printer_status, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printer_unk20, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printer_c_setprinter,\n\t\tNULL);\n\n\toffset = dissect_ndr_uint16(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printer_unk22, NULL);\n\n\toffset = dissect_ndr_uint16(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printer_unk23, NULL);\n\n\toffset = dissect_ndr_uint16(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printer_unk24, NULL);\n\n\toffset = dissect_ndr_uint16(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printer_unk25, NULL);\n\n\toffset = dissect_ndr_uint16(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printer_unk26, NULL);\n\n\toffset = dissect_ndr_uint16(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printer_unk27, NULL);\n\n\toffset = dissect_ndr_uint16(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printer_unk28, NULL);\n\n\toffset = dissect_ndr_uint16(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printer_unk29, NULL);\n\n\treturn offset;\n}\n\n/*\n * PRINTER_INFO_1\n */\n\nstatic gint ett_PRINTER_INFO_1 = -1;\n\nstatic int\ndissect_PRINTER_INFO_1(tvbuff_t *tvb, int offset,\n\t\t\t\t  packet_info *pinfo, proto_tree *tree,\n\t\t\t\t  dcerpc_info *di, guint8 *drep)\n{\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep,\n\t\thf_printer_flags, NULL);\n\n\toffset = dissect_spoolss_relstr(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printerdesc,\n\t\t0, NULL);\n\n\toffset = dissect_spoolss_relstr(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printername,\n\t\t0, NULL);\n\n\toffset = dissect_spoolss_relstr(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printercomment,\n\t\t0, NULL);\n\n\treturn offset;\n}\n\n/* Job status */\n\nstatic const true_false_string tfs_job_status_paused = {\n\t\"Job is paused\",\n\t\"Job is not paused\"\n};\n\nstatic const true_false_string tfs_job_status_error = {\n\t\"Job has an error\",\n\t\"Job is OK\"\n};\n\nstatic const true_false_string tfs_job_status_deleting = {\n\t\"Job is being deleted\",\n\t\"Job is not being deleted\"\n};\n\nstatic const true_false_string tfs_job_status_spooling = {\n\t\"Job is being spooled\",\n\t\"Job is not being spooled\"\n};\n\nstatic const true_false_string tfs_job_status_printing = {\n\t\"Job is being printed\",\n\t\"Job is not being printed\"\n};\n\nstatic const true_false_string tfs_job_status_offline = {\n\t\"Job is offline\",\n\t\"Job is not offline\"\n};\n\nstatic const true_false_string tfs_job_status_paperout = {\n\t\"Job is out of paper\",\n\t\"Job is not out of paper\"\n};\n\nstatic const true_false_string tfs_job_status_printed = {\n\t\"Job has completed printing\",\n\t\"Job has not completed printing\"\n};\n\nstatic const true_false_string tfs_job_status_deleted = {\n\t\"Job has been deleted\",\n\t\"Job has not been deleted\"\n};\n\nstatic const true_false_string tfs_job_status_blocked = {\n\t\"Job has been blocked\",\n\t\"Job has not been blocked\"\n};\n\nstatic const true_false_string tfs_job_status_user_intervention = {\n\t\"User intervention required\",\n\t\"User intervention not required\"\n};\n\nstatic gint ett_job_status = -1;\n\nstatic int\ndissect_job_status(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t   proto_tree *tree, dcerpc_info *di, guint8 *drep)\n{\n\tguint32 status;\n\tstatic const int * hf_status[] = {\n\t\t&hf_job_status_user_intervention,\n\t\t&hf_job_status_blocked,\n\t\t&hf_job_status_deleted,\n\t\t&hf_job_status_printed,\n\t\t&hf_job_status_paperout,\n\t\t&hf_job_status_offline,\n\t\t&hf_job_status_printing,\n\t\t&hf_job_status_spooling,\n\t\t&hf_job_status_deleting,\n\t\t&hf_job_status_error,\n\t\t&hf_job_status_paused,\n\t\tNULL\n\t};\n\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, NULL, di, drep, -1, &status);\n\n\tproto_tree_add_bitmask_value_with_flags(tree, tvb, offset - 4, hf_job_status,\n\t\t\t\t\tett_job_status, hf_status, status, BMT_NO_APPEND);\n\n\treturn offset;\n}\n\n/* Printer attributes */\n\nstatic gint ett_printer_attributes = -1;\n\nstatic int hf_printer_attributes = -1;\nstatic int hf_printer_attributes_queued = -1;\nstatic int hf_printer_attributes_direct = -1;\nstatic int hf_printer_attributes_default = -1;\nstatic int hf_printer_attributes_shared = -1;\nstatic int hf_printer_attributes_network = -1;\nstatic int hf_printer_attributes_hidden = -1;\nstatic int hf_printer_attributes_local = -1;\nstatic int hf_printer_attributes_enable_devq = -1;\nstatic int hf_printer_attributes_keep_printed_jobs = -1;\nstatic int hf_printer_attributes_do_complete_first = -1;\nstatic int hf_printer_attributes_work_offline = -1;\nstatic int hf_printer_attributes_enable_bidi = -1;\nstatic int hf_printer_attributes_raw_only = -1;\nstatic int hf_printer_attributes_published = -1;\n\nstatic const true_false_string tfs_printer_attributes_queued = {\n\t\"Printer starts printing after last page spooled\",\n\t\"Printer starts printing while spooling\"\n};\n\nstatic const true_false_string tfs_printer_attributes_direct = {\n\t\"Jobs sent directly to printer\",\n\t\"Jobs are spooled to printer before printing\"\n};\n\nstatic const true_false_string tfs_printer_attributes_default = {\n\t\"Printer is the default printer\",\n\t\"Printer is not the default printer\"\n};\n\nstatic const true_false_string tfs_printer_attributes_shared = {\n\t\"Printer is shared\",\n\t\"Printer is not shared\"\n};\n\nstatic const true_false_string tfs_printer_attributes_network = {\n\t\"Printer is a network printer connection\",\n\t\"Printer is not a network printer connection\"\n};\n\nstatic const true_false_string tfs_printer_attributes_hidden = {\n\t\"Reserved\",\n\t\"Reserved\"\n};\n\nstatic const true_false_string tfs_printer_attributes_local = {\n\t\"Printer is a local printer\",\n\t\"Printer is not a local printer\"\n};\n\nstatic const true_false_string tfs_printer_attributes_enable_devq = {\n\t\"Call DevQueryPrint\",\n\t\"Do not call DevQueryPrint\"\n};\n\nstatic const true_false_string tfs_printer_attributes_keep_printed_jobs = {\n\t\"Jobs are kept after they are printed\",\n\t\"Jobs are deleted after printing\"\n};\n\nstatic const true_false_string tfs_printer_attributes_do_complete_first = {\n\t\"Jobs that have completed spooling are scheduled before still spooling jobs\",\n\t\"Jobs are scheduled in the order they start spooling\"\n};\n\nstatic const true_false_string tfs_printer_attributes_work_offline = {\n\t\"The printer is currently connected\",\n\t\"The printer is currently not connected\"\n};\n\nstatic const true_false_string tfs_printer_attributes_enable_bidi = {\n\t\"Bidirectional communications are supported\",\n\t\"Bidirectional communications are not supported\"\n};\n\nstatic const true_false_string tfs_printer_attributes_raw_only = {\n\t\"Only raw data type print jobs can be spooled\",\n\t\"All data type print jobs can be spooled\"\n};\n\nstatic const true_false_string tfs_printer_attributes_published = {\n\t\"Printer is published in the directory\",\n\t\"Printer is not published in the directory\"\n};\n\nstatic int\ndissect_printer_attributes(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\t   proto_tree *tree, dcerpc_info *di, guint8 *drep)\n{\n\tguint32 attributes;\n\tstatic const int * hf_attributes[] = {\n\t\t&hf_printer_attributes_published,\n\t\t&hf_printer_attributes_raw_only,\n\t\t&hf_printer_attributes_enable_bidi,\n\t\t&hf_printer_attributes_work_offline,\n\t\t&hf_printer_attributes_do_complete_first,\n\t\t&hf_printer_attributes_keep_printed_jobs,\n\t\t&hf_printer_attributes_enable_devq,\n\t\t&hf_printer_attributes_local,\n\t\t&hf_printer_attributes_hidden,\n\t\t&hf_printer_attributes_network,\n\t\t&hf_printer_attributes_shared,\n\t\t&hf_printer_attributes_default,\n\t\t&hf_printer_attributes_direct,\n\t\t&hf_printer_attributes_queued,\n\t\tNULL\n\t};\n\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, NULL, di, drep, -1, &attributes);\n\n\tproto_tree_add_bitmask_value_with_flags(tree, tvb, offset - 4, hf_printer_attributes,\n\t\t\t\t\tett_printer_attributes, hf_attributes, attributes, BMT_NO_APPEND);\n\n\treturn offset;\n}\n\n/*\n * PRINTER_INFO_2\n */\n\nstatic gint ett_PRINTER_INFO_2 = -1;\n\nstatic int\ndissect_PRINTER_INFO_2(tvbuff_t *tvb, int offset,\n\t\t\t\t  packet_info *pinfo, proto_tree *tree,\n\t\t\t\t  dcerpc_info *di, guint8 *drep)\n{\n\tguint32 devmode_offset, secdesc_offset;\n\n\toffset = dissect_spoolss_relstr(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_servername,\n\t\t0, NULL);\n\n\toffset = dissect_spoolss_relstr(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printername,\n\t\t0, NULL);\n\n\toffset = dissect_spoolss_relstr(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_sharename,\n\t\t0, NULL);\n\n\toffset = dissect_spoolss_relstr(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_portname,\n\t\t0, NULL);\n\n\toffset = dissect_spoolss_relstr(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_drivername,\n\t\t0, NULL);\n\n\toffset = dissect_spoolss_relstr(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printercomment,\n\t\t0, NULL);\n\n\toffset = dissect_spoolss_relstr(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printerlocation,\n\t\t0, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, NULL, di, drep, hf_offset,\n\t\t&devmode_offset);\n\n\tdissect_DEVMODE(tvb, devmode_offset - 4, pinfo, tree, di, drep);\n\n\toffset = dissect_spoolss_relstr(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_sepfile,\n\t\t0, NULL);\n\n\toffset = dissect_spoolss_relstr(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printprocessor,\n\t\t0, NULL);\n\n\toffset = dissect_spoolss_relstr(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_datatype,\n\t\t0, NULL);\n\n\toffset = dissect_spoolss_relstr(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_parameters,\n\t\t0, NULL);\n\n\t/*\n\t * XXX - what *is* the length of this security descriptor?\n\t * \"prs_PRINTER_INFO_2()\" is passed to \"defer_ptr()\", but\n\t * \"defer_ptr\" takes, as an argument, a function with a\n\t * different calling sequence from \"prs_PRINTER_INFO_2()\",\n\t * lacking the \"len\" argument, so that won't work.\n\t */\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, NULL, di, drep, hf_offset,\n\t\t&secdesc_offset);\n\n\tdissect_nt_sec_desc(\n\t\ttvb, secdesc_offset, pinfo, tree, drep,\n\t\tFALSE, -1,\n\t\t&spoolss_printer_access_mask_info);\n\n\toffset = dissect_printer_attributes(tvb, offset, pinfo, tree, di, drep);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, NULL, di, drep, hf_printer_priority,\n\t\tNULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, NULL, di, drep,\n\t\thf_printer_default_priority, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, NULL, di, drep, hf_start_time, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, NULL, di, drep, hf_end_time, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep,\n\t\thf_printer_status, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, NULL, di, drep, hf_printer_jobs,\n\t\tNULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, NULL, di, drep,\n\t\thf_printer_averageppm, NULL);\n\n\treturn offset;\n}\n\n/*\n * PRINTER_INFO_3\n */\n\nstatic gint ett_PRINTER_INFO_3 = -1;\n\nstatic int\ndissect_PRINTER_INFO_3(tvbuff_t *tvb, int offset,\n\t\t\t\t  packet_info *pinfo, proto_tree *tree,\n\t\t\t\t  dcerpc_info *di, guint8 *drep)\n{\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep,\n\t\thf_printer_flags, NULL);\n\n\toffset = dissect_nt_sec_desc(\n\t\ttvb, offset, pinfo, tree, drep,\n\t\tFALSE, -1,\n\t\t&spoolss_printer_access_mask_info);\n\n\treturn offset;\n}\n\n/*\n * PRINTER_INFO_7\n */\n\nstatic gint ett_PRINTER_INFO_7 = -1;\n\nstatic const value_string getprinter_action_vals[] = {\n\t{ DS_PUBLISH, \"Publish\" },\n\t{ DS_UNPUBLISH, \"Unpublish\" },\n\t{ DS_UPDATE, \"Update\" },\n\n\t/* Not sure what the constant values are here */\n\n/*\t{ DS_PENDING, \"Pending\" }, */\n/*\t{ DS_REPUBLISH, \"Republish\" }, */\n\n\t{ 0, NULL }\n};\n\nstatic int\ndissect_PRINTER_INFO_7(tvbuff_t *tvb, int offset,\n\t\t\t\t  packet_info *pinfo, proto_tree *tree,\n\t\t\t\t  dcerpc_info *di, guint8 *drep)\n{\n\toffset = dissect_spoolss_relstr(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printer_guid,\n\t\t0, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep,\n\t\thf_printer_action, NULL);\n\n\treturn offset;\n}\n\n/*\n * PRINTER_DATATYPE structure\n */\n\nstatic gint ett_PRINTER_DATATYPE = -1;\n\nstatic int\ndissect_PRINTER_DATATYPE(tvbuff_t *tvb, int offset,\n\t\t\t\t    packet_info *pinfo, proto_tree *tree,\n\t\t\t\t    dcerpc_info *di, guint8 *drep _U_)\n{\n\tif (di->conformant_run)\n\t\treturn offset;\n\n\toffset = dissect_ndr_cvstring(\n\t\ttvb, offset, pinfo, tree, di, drep, sizeof(guint16),\n\t\thf_datatype, TRUE, NULL);\n\n\treturn offset;\n}\n\n/*\n * USER_LEVEL_1 structure\n */\n\nstatic gint ett_USER_LEVEL_1 = -1;\n\nstatic int hf_userlevel_size = -1;\nstatic int hf_userlevel_client = -1;\nstatic int hf_userlevel_user = -1;\nstatic int hf_userlevel_build = -1;\nstatic int hf_userlevel_major = -1;\nstatic int hf_userlevel_minor = -1;\nstatic int hf_userlevel_processor = -1;\n\nstatic int\ndissect_USER_LEVEL_1(tvbuff_t *tvb, int offset,\n\t\t\t\tpacket_info *pinfo, proto_tree *tree,\n\t\t\t\tdcerpc_info *di, guint8 *drep)\n{\n\tguint32 level;\n\n\t/* Guy has pointed out that this dissection looks wrong.  In\n\t   the wireshark output for a USER_LEVEL_1 it looks like the\n\t   info level and container pointer are transposed.  I'm not\n\t   even sure this structure is a container. */\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_level, &level);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_userlevel_size, NULL);\n\n\toffset = dissect_ndr_str_pointer_item(\n\t\ttvb, offset, pinfo, tree, di, drep, NDR_POINTER_UNIQUE,\n\t\t\"Client\", hf_userlevel_client, 0);\n\n\toffset = dissect_ndr_str_pointer_item(\n\t\ttvb, offset, pinfo, tree, di, drep, NDR_POINTER_UNIQUE,\n\t\t\"User\", hf_userlevel_user, 0);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_userlevel_build, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_userlevel_major, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_userlevel_minor, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_userlevel_processor, NULL);\n\n\treturn offset;\n}\n\n/*\n * USER_LEVEL_CTR structure\n */\n\nstatic gint ett_USER_LEVEL_CTR = -1;\n\nstatic int\ndissect_USER_LEVEL_CTR(tvbuff_t *tvb, int offset,\n\t\t\t\t  packet_info *pinfo, proto_tree *tree,\n\t\t\t\t  dcerpc_info *di, guint8 *drep)\n{\n\tproto_tree *subtree;\n\tproto_item *item;\n\tguint32 level;\n\n\tif (di->conformant_run)\n\t\treturn offset;\n\n\tsubtree = proto_tree_add_subtree(\n\t\ttree, tvb, offset, 0, ett_USER_LEVEL_CTR, &item, \"User level container\");\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_level, &level);\n\n\tswitch(level) {\n\tcase 1:\n\t\toffset = dissect_ndr_pointer(\n\t\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\t\tdissect_USER_LEVEL_1, NDR_POINTER_UNIQUE,\n\t\t\t\"User level 1\", -1);\n\t\tbreak;\n\tdefault:\n\t\texpert_add_info_format(pinfo, item, &ei_level, \"Info level %d not decoded\", level);\n\t\tbreak;\n\t}\n\n\treturn offset;\n}\n\n/*\n * SpoolssOpenPrinterEx\n */\n\nstatic int\nSpoolssOpenPrinterEx_q(tvbuff_t *tvb, int offset,\n\t\t\t\t  packet_info *pinfo, proto_tree *tree,\n\t\t\t\t  dcerpc_info *di, guint8 *drep _U_)\n{\n\tdcerpc_call_value *dcv = (dcerpc_call_value *)di->call_data;\n\tchar *name;\n\n\t/* Parse packet */\n\n\tdcv->private_data=NULL;\n\toffset = dissect_ndr_pointer_cb(\n\t\ttvb, offset, pinfo, tree, di, drep,\n\t\tdissect_ndr_wchar_cvstring, NDR_POINTER_UNIQUE,\n\t\t\"Printer name\", hf_printername, cb_wstr_postprocess,\n\t\tGINT_TO_POINTER(CB_STR_COL_INFO | CB_STR_SAVE | 1));\n\tname = (char *)dcv->private_data;\n\n\t/* OpenPrinterEx() stores the key/value in se_data */\n\tif(!pinfo->fd->flags.visited){\n\t\tif(!dcv->se_data){\n\t\t\tdcv->se_data = wmem_strdup_printf(wmem_file_scope(),\n\t\t\t\t\"%s\", name?name:\"\");\n\t\t}\n\t}\n\n\toffset = dissect_ndr_pointer(\n\t\ttvb, offset, pinfo, tree, di, drep,\n\t\tdissect_PRINTER_DATATYPE, NDR_POINTER_UNIQUE,\n\t\t\"Printer datatype\", -1);\n\n\toffset = dissect_DEVMODE_CTR(tvb, offset, pinfo, tree, di, drep);\n\n\tname=(char *)dcv->se_data;\n\tif (name) {\n\t\tif (name[0] == '\\\\' && name[1] == '\\\\')\n\t\t\tname += 2;\n\n\t\t/* Determine if we are opening a printer or a print server */\n\n\t\tif (strchr(name, '\\\\'))\n\t\t\toffset = dissect_nt_access_mask(\n\t\t\t\ttvb, offset, pinfo, tree, di, drep,\n\t\t\t\thf_access_required,\n\t\t\t\t&spoolss_printer_access_mask_info, NULL);\n\t\telse\n\t\t\toffset = dissect_nt_access_mask(\n\t\t\t\ttvb, offset, pinfo, tree, di, drep,\n\t\t\t\thf_access_required,\n\t\t\t\t&spoolss_printserver_access_mask_info, NULL);\n\t} else {\n\n\t\t/* We can't decide what type of object being opened */\n\n\t\toffset = dissect_nt_access_mask(\n\t\t\ttvb, offset, pinfo, tree, di, drep, hf_access_required,\n\t\t\tNULL, NULL);\n\t}\n\n\toffset = dissect_USER_LEVEL_CTR(tvb, offset, pinfo, tree, di, drep);\n\n\treturn offset;\n}\n\nstatic int\nSpoolssOpenPrinterEx_r(tvbuff_t *tvb, int offset,\n\t\t\t\t  packet_info *pinfo, proto_tree *tree,\n\t\t\t\t  dcerpc_info *di, guint8 *drep _U_)\n{\n\tdcerpc_call_value *dcv = (dcerpc_call_value *)di->call_data;\n\te_ctx_hnd policy_hnd;\n\tproto_item *hnd_item;\n\tguint32 status;\n\n\t/* Parse packet */\n\n\toffset = dissect_nt_policy_hnd(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_hnd, &policy_hnd, &hnd_item,\n\t\tTRUE, FALSE);\n\n\toffset = dissect_doserror(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_rc, &status);\n\n\tif( status == 0 ){\n\t\tconst char *pol_name;\n\n\t\tif (dcv->se_data){\n\t\t\tpol_name = wmem_strdup_printf(wmem_packet_scope(),\n\t\t\t\t\"OpenPrinterEx(%s)\", (char *)dcv->se_data);\n\t\t} else {\n\t\t\tpol_name = \"Unknown OpenPrinterEx() handle\";\n\t\t}\n\t\tif(!pinfo->fd->flags.visited){\n\t\t\tdcerpc_store_polhnd_name(&policy_hnd, pinfo, pol_name);\n\t\t}\n\n\t\tif(hnd_item)\n\t\t\tproto_item_append_text(hnd_item, \": %s\", pol_name);\n\t}\n\n\treturn offset;\n}\n\nstatic const value_string printer_notify_option_data_vals[] = {\n\t{ PRINTER_NOTIFY_SERVER_NAME, \"Server name\" },\n\t{ PRINTER_NOTIFY_PRINTER_NAME, \"Printer name\" },\n\t{ PRINTER_NOTIFY_SHARE_NAME, \"Share name\" },\n\t{ PRINTER_NOTIFY_PORT_NAME, \"Port name\" },\n\t{ PRINTER_NOTIFY_DRIVER_NAME, \"Driver name\" },\n\t{ PRINTER_NOTIFY_COMMENT, \"Comment\" },\n\t{ PRINTER_NOTIFY_LOCATION, \"Location\" },\n\t{ PRINTER_NOTIFY_DEVMODE, \"Devmode\" },\n\t{ PRINTER_NOTIFY_SEPFILE, \"Sepfile\" },\n\t{ PRINTER_NOTIFY_PRINT_PROCESSOR, \"Print processor\" },\n\t{ PRINTER_NOTIFY_PARAMETERS, \"Parameters\" },\n\t{ PRINTER_NOTIFY_DATATYPE, \"Datatype\" },\n\t{ PRINTER_NOTIFY_SECURITY_DESCRIPTOR, \"Security descriptor\" },\n\t{ PRINTER_NOTIFY_ATTRIBUTES, \"Attributes\" },\n\t{ PRINTER_NOTIFY_PRIORITY, \"Priority\" },\n\t{ PRINTER_NOTIFY_DEFAULT_PRIORITY, \"Default priority\" },\n\t{ PRINTER_NOTIFY_START_TIME, \"Start time\" },\n\t{ PRINTER_NOTIFY_UNTIL_TIME, \"Until time\" },\n\t{ PRINTER_NOTIFY_STATUS, \"Status\" },\n\t{ PRINTER_NOTIFY_STATUS_STRING, \"Status string\" },\n\t{ PRINTER_NOTIFY_CJOBS, \"Cjobs\" },\n\t{ PRINTER_NOTIFY_AVERAGE_PPM, \"Average PPM\" },\n\t{ PRINTER_NOTIFY_TOTAL_PAGES, \"Total pages\" },\n\t{ PRINTER_NOTIFY_PAGES_PRINTED, \"Pages printed\" },\n\t{ PRINTER_NOTIFY_TOTAL_BYTES, \"Total bytes\" },\n\t{ PRINTER_NOTIFY_BYTES_PRINTED, \"Bytes printed\" },\n\t{ 0, NULL}\n};\nstatic value_string_ext printer_notify_option_data_vals_ext = VALUE_STRING_EXT_INIT(printer_notify_option_data_vals);\n\nstatic const value_string job_notify_option_data_vals[] = {\n\t{ JOB_NOTIFY_PRINTER_NAME, \"Printer name\" },\n\t{ JOB_NOTIFY_MACHINE_NAME, \"Machine name\" },\n\t{ JOB_NOTIFY_PORT_NAME, \"Port name\" },\n\t{ JOB_NOTIFY_USER_NAME, \"User name\" },\n\t{ JOB_NOTIFY_NOTIFY_NAME, \"Notify name\" },\n\t{ JOB_NOTIFY_DATATYPE, \"Data type\" },\n\t{ JOB_NOTIFY_PRINT_PROCESSOR, \"Print processor\" },\n\t{ JOB_NOTIFY_PARAMETERS, \"Parameters\" },\n\t{ JOB_NOTIFY_DRIVER_NAME, \"Driver name\" },\n\t{ JOB_NOTIFY_DEVMODE, \"Devmode\" },\n\t{ JOB_NOTIFY_STATUS, \"Status\" },\n\t{ JOB_NOTIFY_STATUS_STRING, \"Status string\" },\n\t{ JOB_NOTIFY_SECURITY_DESCRIPTOR, \"Security descriptor\" },\n\t{ JOB_NOTIFY_DOCUMENT, \"Document\" },\n\t{ JOB_NOTIFY_PRIORITY, \"Priority\" },\n\t{ JOB_NOTIFY_POSITION, \"Position\" },\n\t{ JOB_NOTIFY_SUBMITTED, \"Submitted\" },\n\t{ JOB_NOTIFY_START_TIME, \"Start time\" },\n\t{ JOB_NOTIFY_UNTIL_TIME, \"Until time\" },\n\t{ JOB_NOTIFY_TIME, \"Time\" },\n\t{ JOB_NOTIFY_TOTAL_PAGES, \"Total pages\" },\n\t{ JOB_NOTIFY_PAGES_PRINTED, \"Pages printed\" },\n\t{ JOB_NOTIFY_TOTAL_BYTES, \"Total bytes\" },\n\t{ JOB_NOTIFY_BYTES_PRINTED, \"Bytes printed\" },\n\t{ 0, NULL}\n};\nstatic value_string_ext job_notify_option_data_vals_ext = VALUE_STRING_EXT_INIT(job_notify_option_data_vals);\n\nstatic int\ndissect_notify_field(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t     proto_tree *tree, dcerpc_info *di, guint8 *drep, guint16 type,\n\t\t     guint16 *data)\n{\n\tguint16 field;\n\tconst char *str;\n\n\toffset = dissect_ndr_uint16(\n\t\ttvb, offset, pinfo, NULL, di, drep,\n\t\thf_notify_field, &field);\n\n\tswitch(type) {\n\tcase PRINTER_NOTIFY_TYPE:\n\t\tstr = val_to_str_ext_const(field, &printer_notify_option_data_vals_ext,\n\t\t\t\t \"Unknown\");\n\t\tbreak;\n\tcase JOB_NOTIFY_TYPE:\n\t\tstr = val_to_str_ext_const(field, &job_notify_option_data_vals_ext,\n\t\t\t\t \"Unknown\");\n\t\tbreak;\n\tdefault:\n\t\tstr = \"Unknown notify type\";\n\t\tbreak;\n\t}\n\n\tproto_tree_add_uint_format_value(tree, hf_notify_field, tvb, offset - 2, 2, field, \"%s (%d)\", str, field);\n\n\tif (data)\n\t\t*data = field;\n\n\treturn offset;\n}\n\nstatic int\ndissect_NOTIFY_OPTION_DATA(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\t   proto_tree *tree, dcerpc_info *di, guint8 *drep)\n{\n\tdcerpc_call_value *dcv = (dcerpc_call_value *)di->call_data;\n\tguint32 count, i;\n\tguint16 type;\n\n\tif (di->conformant_run)\n\t\treturn offset;\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep,\n\t\thf_notify_option_data_count, &count);\n\n\ttype = GPOINTER_TO_INT(dcv->private_data);\n\n\tfor (i = 0; i < count; i++)\n\t\toffset = dissect_notify_field(\n\t\t\ttvb, offset, pinfo, tree, di, drep, type, NULL);\n\n\treturn offset;\n}\n\nstatic const value_string printer_notify_types[] =\n{\n\t{ PRINTER_NOTIFY_TYPE, \"Printer notify\" },\n\t{ JOB_NOTIFY_TYPE, \"Job notify\" },\n\t{ 0, NULL }\n};\n\nstatic const\nchar *notify_plural(int count)\n{\n\tif (count == 1)\n\t\treturn \"notification\";\n\n\treturn \"notifies\";\n}\n\nstatic gint ett_NOTIFY_OPTION = -1;\n\nstatic int\ndissect_NOTIFY_OPTION(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t      proto_tree *tree, dcerpc_info *di, guint8 *drep)\n{\n\tdcerpc_call_value *dcv = (dcerpc_call_value *)di->call_data;\n\tproto_item *item;\n\tproto_tree *subtree;\n\tguint16 type;\n\tguint32 count;\n\n\tsubtree = proto_tree_add_subtree(tree, tvb, offset, 0, ett_NOTIFY_OPTION, &item, \"Notify Option\");\n\n\toffset = dissect_ndr_uint16(tvb, offset, pinfo, subtree, di, drep,\n\t\t\t\t    hf_notify_option_type, &type);\n\n\tproto_item_append_text(\n\t\titem, \": %s\", val_to_str(type, printer_notify_types,\n\t\t\t\t\t \"Unknown (%d)\"));\n\n\toffset = dissect_ndr_uint16(tvb, offset, pinfo, subtree, di, drep,\n\t\t\t\t    hf_notify_option_reserved1, NULL);\n\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, subtree, di, drep,\n\t\t\t\t    hf_notify_option_reserved2, NULL);\n\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, subtree, di, drep,\n\t\t\t\t    hf_notify_option_reserved3, NULL);\n\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, subtree, di, drep,\n\t\t\t\t    hf_notify_option_count, &count);\n\n\tproto_item_append_text(\n\t\titem, \", %d %s\", count, notify_plural(count));\n\n\tdcv->private_data = GINT_TO_POINTER((int)type);\n\n\toffset = dissect_ndr_pointer(\n\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\tdissect_NOTIFY_OPTION_DATA, NDR_POINTER_UNIQUE,\n\t\t\"Notify Option Data\", -1);\n\n\treturn offset;\n}\n\nstatic int\ndissect_NOTIFY_OPTIONS_ARRAY(tvbuff_t *tvb, int offset,\n\t\t\t     packet_info *pinfo, proto_tree *tree,\n\t\t\t     dcerpc_info *di, guint8 *drep)\n{\n\t/* Why is a check for di->conformant_run not required here? */\n\n\toffset = dissect_ndr_ucarray(\n\t\ttvb, offset, pinfo, tree, di, drep, dissect_NOTIFY_OPTION);\n\n\treturn offset;\n}\n\nstatic gint ett_notify_options_flags = -1;\n\nstatic const true_false_string tfs_notify_options_flags_refresh = {\n\t\"Data for all monitored fields is present\",\n\t\"Data for all monitored fields not present\"\n};\n\nstatic int\ndissect_notify_options_flags(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\t     proto_tree *tree, dcerpc_info *di, guint8 *drep)\n{\n\tguint32 flags;\n\tstatic const int * hf_flags[] = {\n\t\t&hf_notify_options_flags_refresh,\n\t\tNULL\n\t};\n\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, NULL, di, drep, -1, &flags);\n\n\tproto_tree_add_bitmask_value_with_flags(tree, tvb, offset - 4, hf_notify_options_flags,\n\t\t\t\t\tett_notify_options_flags, hf_flags, flags, BMT_NO_APPEND);\n\n\treturn offset;\n}\n\nstatic int\ndissect_NOTIFY_OPTIONS_ARRAY_CTR(tvbuff_t *tvb, int offset,\n\t\t\t\t packet_info *pinfo, proto_tree *tree,\n\t\t\t\t dcerpc_info *di, guint8 *drep)\n{\n\tif (di->conformant_run)\n\t\treturn offset;\n\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, tree, di, drep,\n\t\t\t\t    hf_notify_options_version, NULL);\n\n\toffset = dissect_notify_options_flags(tvb, offset, pinfo, tree, di, drep);\n\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, tree, di, drep,\n\t\t\t\t    hf_notify_options_count, NULL);\n\n\toffset = dissect_ndr_pointer(\n\t\ttvb, offset, pinfo, tree, di, drep,\n\t\tdissect_NOTIFY_OPTIONS_ARRAY, NDR_POINTER_UNIQUE,\n\t\t\"Notify Options Array\", -1);\n\n\treturn offset;\n}\n\n/*\n * SpoolssRFFPCNEX\n */\n\nstatic gint ett_rffpcnex_flags = -1;\n\nstatic int hf_rffpcnex_flags = -1;\nstatic int hf_rffpcnex_options = -1;\n\nstatic int hf_rffpcnex_flags_add_printer = -1;\nstatic int hf_rffpcnex_flags_set_printer = -1;\nstatic int hf_rffpcnex_flags_delete_printer = -1;\nstatic int hf_rffpcnex_flags_failed_printer_connection = -1;\n\nstatic const true_false_string tfs_rffpcnex_flags_add_printer = {\n\t\"Notify on add printer\",\n\t\"Don't notify on add printer\"\n};\n\nstatic const true_false_string tfs_rffpcnex_flags_set_printer = {\n\t\"Notify on set printer\",\n\t\"Don't notify on set printer\"\n};\n\nstatic const true_false_string tfs_rffpcnex_flags_delete_printer = {\n\t\"Notify on delete printer\",\n\t\"Don't notify on delete printer\"\n};\n\nstatic const true_false_string tfs_rffpcnex_flags_failed_connection_printer = {\n\t\"Notify on failed printer connection\",\n\t\"Don't notify on failed printer connection\"\n};\n\nstatic int hf_rffpcnex_flags_add_job = -1;\nstatic int hf_rffpcnex_flags_set_job = -1;\nstatic int hf_rffpcnex_flags_delete_job = -1;\nstatic int hf_rffpcnex_flags_write_job = -1;\n\nstatic const true_false_string tfs_rffpcnex_flags_add_job = {\n\t\"Notify on add job\",\n\t\"Don't notify on add job\"\n};\n\nstatic const true_false_string tfs_rffpcnex_flags_set_job = {\n\t\"Notify on set job\",\n\t\"Don't notify on set job\"\n};\n\nstatic const true_false_string tfs_rffpcnex_flags_delete_job = {\n\t\"Notify on delete job\",\n\t\"Don't notify on delete job\"\n};\n\nstatic const true_false_string tfs_rffpcnex_flags_write_job = {\n\t\"Notify on writejob\",\n\t\"Don't notify on write job\"\n};\n\nstatic int hf_rffpcnex_flags_add_form = -1;\nstatic int hf_rffpcnex_flags_set_form = -1;\nstatic int hf_rffpcnex_flags_delete_form = -1;\n\nstatic const true_false_string tfs_rffpcnex_flags_add_form = {\n\t\"Notify on add form\",\n\t\"Don't notify on add form\"\n};\n\nstatic const true_false_string tfs_rffpcnex_flags_set_form = {\n\t\"Notify on set form\",\n\t\"Don't notify on set form\"\n};\n\nstatic const true_false_string tfs_rffpcnex_flags_delete_form = {\n\t\"Notify on delete form\",\n\t\"Don't notify on delete form\"\n};\n\nstatic int hf_rffpcnex_flags_add_port = -1;\nstatic int hf_rffpcnex_flags_configure_port = -1;\nstatic int hf_rffpcnex_flags_delete_port = -1;\n\nstatic const true_false_string tfs_rffpcnex_flags_add_port = {\n\t\"Notify on add port\",\n\t\"Don't notify on add port\"\n};\n\nstatic const true_false_string tfs_rffpcnex_flags_configure_port = {\n\t\"Notify on configure port\",\n\t\"Don't notify on configure port\"\n};\n\nstatic const true_false_string tfs_rffpcnex_flags_delete_port = {\n\t\"Notify on delete port\",\n\t\"Don't notify on delete port\"\n};\n\nstatic int hf_rffpcnex_flags_add_print_processor = -1;\nstatic int hf_rffpcnex_flags_delete_print_processor = -1;\n\nstatic const true_false_string tfs_rffpcnex_flags_add_print_processor = {\n\t\"Notify on add driver\",\n\t\"Don't notify on add driver\"\n};\n\nstatic const true_false_string tfs_rffpcnex_flags_delete_print_processor = {\n\t\"Notify on add driver\",\n\t\"Don't notify on add driver\"\n};\n\nstatic int hf_rffpcnex_flags_add_driver = -1;\nstatic int hf_rffpcnex_flags_set_driver = -1;\nstatic int hf_rffpcnex_flags_delete_driver = -1;\n\nstatic const true_false_string tfs_rffpcnex_flags_add_driver = {\n\t\"Notify on add driver\",\n\t\"Don't notify on add driver\"\n};\n\nstatic const true_false_string tfs_rffpcnex_flags_set_driver = {\n\t\"Notify on set driver\",\n\t\"Don't notify on set driver\"\n};\n\nstatic const true_false_string tfs_rffpcnex_flags_delete_driver = {\n\t\"Notify on delete driver\",\n\t\"Don't notify on delete driver\"\n};\n\nstatic int hf_rffpcnex_flags_timeout = -1;\n\nstatic const true_false_string tfs_rffpcnex_flags_timeout = {\n\t\"Notify on timeout\",\n\t\"Don't notify on timeout\"\n};\n\nstatic int\nSpoolssRFFPCNEX_q(tvbuff_t *tvb, int offset,\n\t\t\t     packet_info *pinfo, proto_tree *tree,\n\t\t\t     dcerpc_info *di, guint8 *drep _U_)\n{\n\tguint32 flags;\n\tstatic const int * hf_flags[] = {\n\t\t&hf_rffpcnex_flags_timeout,\n\t\t&hf_rffpcnex_flags_delete_driver,\n\t\t&hf_rffpcnex_flags_set_driver,\n\t\t&hf_rffpcnex_flags_add_driver,\n\t\t&hf_rffpcnex_flags_delete_print_processor,\n\t\t&hf_rffpcnex_flags_add_print_processor,\n\t\t&hf_rffpcnex_flags_delete_port,\n\t\t&hf_rffpcnex_flags_configure_port,\n\t\t&hf_rffpcnex_flags_add_port,\n\t\t&hf_rffpcnex_flags_delete_form,\n\t\t&hf_rffpcnex_flags_set_form,\n\t\t&hf_rffpcnex_flags_add_form,\n\t\t&hf_rffpcnex_flags_write_job,\n\t\t&hf_rffpcnex_flags_delete_job,\n\t\t&hf_rffpcnex_flags_set_job,\n\t\t&hf_rffpcnex_flags_add_job,\n\t\t&hf_rffpcnex_flags_failed_printer_connection,\n\t\t&hf_rffpcnex_flags_delete_printer,\n\t\t&hf_rffpcnex_flags_set_printer,\n\t\t&hf_rffpcnex_flags_add_printer,\n\t\tNULL\n\t};\n\n\t/* Parse packet */\n\n\toffset = dissect_nt_policy_hnd(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_hnd, NULL, NULL,\n\t\tFALSE, FALSE);\n\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, NULL, di, drep, -1, &flags);\n\n\tproto_tree_add_bitmask_value(tree, tvb, offset - 4, hf_rffpcnex_flags,\n\t\t\t\t\tett_rffpcnex_flags, hf_flags, flags);\n\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, tree, di, drep,\n\t\t\t\t    hf_rffpcnex_options, NULL);\n\n\toffset = dissect_ndr_str_pointer_item(\n\t\ttvb, offset, pinfo, tree, di, drep, NDR_POINTER_UNIQUE,\n\t\t\"Server\", hf_servername, 0);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printerlocal, NULL);\n\n\toffset = dissect_ndr_pointer(\n\t\ttvb, offset, pinfo, tree, di, drep,\n\t\tdissect_NOTIFY_OPTIONS_ARRAY_CTR, NDR_POINTER_UNIQUE,\n\t\t\"Notify Options Container\", -1);\n\n\treturn offset;\n}\n\nstatic int\nSpoolssRFFPCNEX_r(tvbuff_t *tvb, int offset,\n\t\t\t     packet_info *pinfo, proto_tree *tree,\n\t\t\t     dcerpc_info *di, guint8 *drep _U_)\n{\n\t/* Parse packet */\n\n\toffset = dissect_doserror(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_rc, NULL);\n\n\treturn offset;\n}\n\n/*\n * SpoolssReplyOpenPrinter\n */\n\nstatic int\nSpoolssReplyOpenPrinter_q(tvbuff_t *tvb, int offset,\n\t\t\t\t     packet_info *pinfo, proto_tree *tree,\n\t\t\t\t     dcerpc_info *di, guint8 *drep _U_)\n{\n\tdcerpc_call_value *dcv = (dcerpc_call_value *)di->call_data;\n\tguint32 printerlocal;\n\tchar *name;\n\n\t/* Parse packet */\n\tname=NULL;\n\toffset = dissect_ndr_cvstring(\n\t\ttvb, offset, pinfo, tree, di, drep, sizeof(guint16),\n\t\thf_servername, TRUE, &name);\n\t/* ReplyOpenPrinter() stores the printername in se_data */\n\tif(!pinfo->fd->flags.visited){\n\t\tif(!dcv->se_data){\n\t\t\tif(name){\n\t\t\t\tdcv->se_data = wmem_strdup(wmem_file_scope(), name);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (name)\n\t\tcol_append_fstr(pinfo->cinfo, COL_INFO, \", %s\", name);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printerlocal,\n\t\t&printerlocal);\n\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, tree, di, drep,\n\t\t\t\t    hf_printerdata_type, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_replyopenprinter_unk0,\n\t\tNULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_replyopenprinter_unk1,\n\t\tNULL);\n\n\treturn offset;\n}\n\nstatic int\nSpoolssReplyOpenPrinter_r(tvbuff_t *tvb, int offset,\n\t\t\t\t     packet_info *pinfo, proto_tree *tree,\n\t\t\t\t     dcerpc_info *di, guint8 *drep _U_)\n{\n\tdcerpc_call_value *dcv = (dcerpc_call_value *)di->call_data;\n\te_ctx_hnd policy_hnd;\n\tproto_item *hnd_item;\n\tguint32 status;\n\n\t/* Parse packet */\n\n\toffset = dissect_nt_policy_hnd(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_hnd, &policy_hnd, &hnd_item,\n\t\tTRUE, FALSE);\n\n\toffset = dissect_doserror(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_rc, &status);\n\n\tif( status == 0 ){\n\t\tconst char *pol_name;\n\n\t\tif (dcv->se_data){\n\t\t\tpol_name = wmem_strdup_printf(wmem_packet_scope(),\n\t\t\t\t\"ReplyOpenPrinter(%s)\", (char *)dcv->se_data);\n\t\t} else {\n\t\t\tpol_name = \"Unknown ReplyOpenPrinter() handle\";\n\t\t}\n\t\tif(!pinfo->fd->flags.visited){\n\t\t\tdcerpc_store_polhnd_name(&policy_hnd, pinfo, pol_name);\n\t\t}\n\n\t\tif(hnd_item)\n\t\t\tproto_item_append_text(hnd_item, \": %s\", pol_name);\n\t}\n\n\treturn offset;\n}\n\n/*\n * SpoolssGetPrinter\n */\n\n\nstatic int\nSpoolssGetPrinter_q(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\t       proto_tree *tree, dcerpc_info *di, guint8 *drep _U_)\n{\n\tdcerpc_call_value *dcv = (dcerpc_call_value *)di->call_data;\n\tguint32 level;\n\n\t/* Parse packet */\n\n\toffset = dissect_nt_policy_hnd(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_hnd, NULL, NULL,\n \t\tFALSE, FALSE);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_level, &level);\n\n\t/* GetPrinter() stores the level in se_data */\n\tif(!pinfo->fd->flags.visited){\n\t\t\tdcv->se_data = GINT_TO_POINTER((int)level);\n\t}\n\n\n\tcol_append_fstr(pinfo->cinfo, COL_INFO, \", level %d\", level);\n\n\toffset = dissect_spoolss_buffer(\n\t\ttvb, offset, pinfo, tree, di, drep, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_offered, NULL);\n\n\treturn offset;\n}\n\nstatic gint ett_PRINTER_INFO = -1;\n\nstatic int\nSpoolssGetPrinter_r(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\t\tproto_tree *tree, dcerpc_info *di, guint8 *drep _U_)\n{\n\tdcerpc_call_value *dcv = (dcerpc_call_value *)di->call_data;\n\tBUFFER buffer;\n\tgint16 level = GPOINTER_TO_INT(dcv->se_data);\n\tproto_item *item = NULL;\n\tproto_tree *subtree = NULL;\n\n\tcol_append_fstr(pinfo->cinfo, COL_INFO, \", level %d\", level);\n\n\t/* Parse packet */\n\n\toffset = dissect_spoolss_buffer(\n\t\ttvb, offset, pinfo, tree, di, drep, &buffer);\n\n\tif (buffer.tvb) {\n\t\tsubtree = proto_tree_add_subtree_format( buffer.tree, buffer.tvb, 0, -1, ett_PRINTER_INFO, &item, \"Print info level %d\", level);\n\n\t\tswitch(level) {\n\t\tcase 0:\n\t\t\tdissect_PRINTER_INFO_0(\n\t\t\t\tbuffer.tvb, 0, pinfo, subtree, di, drep);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tdissect_PRINTER_INFO_1(\n\t\t\t\tbuffer.tvb, 0, pinfo, subtree, di, drep);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tdissect_PRINTER_INFO_2(\n\t\t\t\tbuffer.tvb, 0, pinfo, subtree, di, drep);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tdissect_PRINTER_INFO_3(\n\t\t\t\tbuffer.tvb, 0, pinfo, subtree, di, drep);\n\t\t\tbreak;\n\t\tcase 7:\n\t\t\tdissect_PRINTER_INFO_7(\n\t\t\t\tbuffer.tvb, 0, pinfo, subtree, di, drep);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\texpert_add_info(pinfo, item, &ei_printer_info_level);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_needed, NULL);\n\n\toffset = dissect_doserror(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_rc, NULL);\n\n\treturn offset;\n}\n\n/*\n * SEC_DESC_BUF\n */\n\nstatic gint ett_SEC_DESC_BUF = -1;\n\nstatic int hf_secdescbuf_maxlen = -1;\nstatic int hf_secdescbuf_undoc = -1;\nstatic int hf_secdescbuf_len = -1;\n\nstatic int\ndissect_SEC_DESC_BUF(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t     proto_tree *tree, dcerpc_info *di, guint8 *drep)\n{\n\tproto_tree *subtree;\n\tguint32 len;\n\n\t/* XXX: I think this is really a array of bytes which can be\n\t   dissected using dissect_ndr_cvstring().  The dissected data\n\t   can be passed to dissect_nt_sec_desc().  The problem is that\n\t   dissect_nt_cvstring() passes back a char * where it really\n\t   should pass back a tvb. */\n\n\tsubtree = proto_tree_add_subtree(\n\t\ttree, tvb, offset, 0, ett_SEC_DESC_BUF, NULL, \"Security descriptor buffer\");\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\thf_secdescbuf_maxlen, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\thf_secdescbuf_undoc, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\thf_secdescbuf_len, &len);\n\n\tdissect_nt_sec_desc(\n\t\ttvb, offset, pinfo, subtree, drep, TRUE, len,\n\t\t&spoolss_printer_access_mask_info);\n\n\toffset += len;\n\n\treturn offset;\n}\n\n/*\n * SPOOL_PRINTER_INFO_LEVEL\n */\n\nstatic gint ett_SPOOL_PRINTER_INFO_LEVEL = -1;\n\n/* spool printer info */\n\nstatic int hf_spool_printer_info_devmode_ptr = -1;\nstatic int hf_spool_printer_info_secdesc_ptr = -1;\n\nstatic int\ndissect_SPOOL_PRINTER_INFO(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\t   proto_tree *tree, dcerpc_info *di, guint8 *drep)\n{\n\tproto_tree *subtree;\n\tguint32 level;\n\tproto_tree *item;\n\n\tsubtree = proto_tree_add_subtree(\n\t\ttree, tvb, offset, 0, ett_SPOOL_PRINTER_INFO_LEVEL, &item, \"Spool printer info level\");\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_level, &level);\n\n\tswitch(level) {\n\tcase 3: {\n\t\tguint32 devmode_ptr, secdesc_ptr;\n\n\t\t/* I can't seem to get this working with the correct\n\t\t   dissect_ndr_pointer() function so let's cheat and\n\t\t   dissect the pointers by hand. )-: */\n\n\t\toffset = dissect_ndr_uint32(\n\t\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\t\thf_spool_printer_info_devmode_ptr,\n\t\t\t&devmode_ptr);\n\n\t\toffset = dissect_ndr_uint32(\n\t\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\t\thf_spool_printer_info_secdesc_ptr,\n\t\t\t&secdesc_ptr);\n\n\t\tif (devmode_ptr)\n\t\t\toffset = dissect_DEVMODE_CTR(\n\t\t\t\ttvb, offset, pinfo, subtree, di, drep);\n\n\t\tif (secdesc_ptr)\n\t\t\toffset = dissect_SEC_DESC_BUF(\n\t\t\t\ttvb, offset, pinfo, subtree, di, drep);\n\n\tbreak;\n\t}\n\tcase 2:\n\tdefault:\n\t\texpert_add_info_format(pinfo, item, &ei_spool_printer_info_level, \"Unknown spool printer info level %d\", level);\n\t\tbreak;\n\t}\n\n\treturn offset;\n}\n\n/*\n * SpoolssSetPrinter\n */\n\nstatic int hf_setprinter_cmd = -1;\n\nstatic const value_string setprinter_cmd_vals[] = {\n\t{ SPOOLSS_PRINTER_CONTROL_UNPAUSE, \"Unpause\" },\n\t{ SPOOLSS_PRINTER_CONTROL_PAUSE, \"Pause\" },\n\t{ SPOOLSS_PRINTER_CONTROL_RESUME, \"Resume\" },\n\t{ SPOOLSS_PRINTER_CONTROL_PURGE, \"Purge\" },\n\t{ SPOOLSS_PRINTER_CONTROL_SET_STATUS, \"Set status\" },\n\t{ 0, NULL }\n};\n\nstatic int\nSpoolssSetPrinter_q(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\t       proto_tree *tree, dcerpc_info *di, guint8 *drep _U_)\n{\n\tguint32 level;\n\n\t/* Parse packet */\n\n\toffset = dissect_nt_policy_hnd(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_hnd, NULL, NULL,\n\t\tFALSE, FALSE);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_level, &level);\n\n\tcol_append_fstr(pinfo->cinfo, COL_INFO, \", level %d\", level);\n\n\toffset = dissect_SPOOL_PRINTER_INFO(\n\t\ttvb, offset, pinfo, tree, di, drep);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep,\n\t\thf_setprinter_cmd, NULL);\n\n\treturn offset;\n}\n\nstatic int\nSpoolssSetPrinter_r(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\t\tproto_tree *tree, dcerpc_info *di, guint8 *drep _U_)\n{\n\t/* Parse packet */\n\n\toffset = dissect_doserror(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_rc, NULL);\n\n\treturn offset;\n}\n\n/*\n * FORM_REL\n */\n\nstatic const value_string form_type_vals[] =\n{\n\t{ SPOOLSS_FORM_USER, \"User\" },\n\t{ SPOOLSS_FORM_BUILTIN, \"Builtin\" },\n\t{ SPOOLSS_FORM_PRINTER, \"Printer\" },\n\t{ 0, NULL }\n};\n\nstatic gint ett_FORM_REL = -1;\n\nstatic int\ndissect_FORM_REL(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\t    proto_tree *tree, dcerpc_info *di, guint8 *drep, int struct_start)\n{\n\tproto_item *item;\n\tproto_tree *subtree;\n\tguint32 flags;\n\tint item_start = offset;\n\tchar *name = NULL;\n\n\tsubtree = proto_tree_add_subtree(tree, tvb, offset, 0, ett_FORM_REL, &item, \"Form\");\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_form_flags, &flags);\n\n\toffset = dissect_spoolss_relstr(\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_form_name,\n\t\tstruct_start, &name);\n\n\tif (name) {\n\t\tproto_item_append_text(item, \": %s\", name);\n\t\tg_free(name);\n\t}\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\thf_form_width, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\thf_form_height, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\thf_form_left_margin, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\thf_form_top_margin, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\thf_form_horiz_len, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\thf_form_vert_len, NULL);\n\n\tproto_item_set_len(item, offset - item_start);\n\n\treturn offset;\n}\n\n/*\n * SpoolssEnumForms\n */\n\nstatic int\nSpoolssEnumForms_q(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\t      proto_tree *tree, dcerpc_info *di, guint8 *drep _U_)\n{\n\tdcerpc_call_value *dcv = (dcerpc_call_value *)di->call_data;\n\tguint32 level;\n\tproto_item *hidden_item;\n\n\thidden_item = proto_tree_add_uint(\n\t\ttree, hf_form, tvb, offset, 0, 1);\n\tPROTO_ITEM_SET_HIDDEN(hidden_item);\n\n\t/* Parse packet */\n\n\toffset = dissect_nt_policy_hnd(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_hnd, NULL, NULL,\n\t\tFALSE, FALSE);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_level, &level);\n\n\t/* EnumForms() stores the level in se_data */\n\tif(!pinfo->fd->flags.visited){\n\t\t\tdcv->se_data = GINT_TO_POINTER((int)level);\n\t}\n\n\tcol_append_fstr(pinfo->cinfo, COL_INFO, \", level %d\", level);\n\n\toffset = dissect_spoolss_buffer(\n\t\ttvb, offset, pinfo, tree, di, drep, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_offered, NULL);\n\n\treturn offset;\n}\n\nstatic int\nSpoolssEnumForms_r(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\t      proto_tree *tree, dcerpc_info *di, guint8 *drep _U_)\n{\n\tdcerpc_call_value *dcv = (dcerpc_call_value *)di->call_data;\n\tBUFFER buffer;\n\tguint32 level = GPOINTER_TO_UINT(dcv->se_data), i, count;\n\tint buffer_offset;\n\tproto_item *hidden_item;\n\n\thidden_item = proto_tree_add_uint(\n\t\ttree, hf_form, tvb, offset, 0, 1);\n\tPROTO_ITEM_SET_HIDDEN(hidden_item);\n\n\t/* Parse packet */\n\n\toffset = dissect_spoolss_buffer(\n\t\ttvb, offset, pinfo, tree, di, drep, &buffer);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_needed, NULL);\n\n\tcol_append_fstr(pinfo->cinfo, COL_INFO, \", level %d\", level);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_enumforms_num, &count);\n\n\t/* Unfortunately this array isn't in NDR format so we can't\n\t   use prs_array().  The other weird thing is the\n\t   struct_start being inside the loop rather than outside.\n\t   Very strange. */\n\n\tbuffer_offset = 0;\n\n\tfor (i = 0; i < count; i++) {\n\t\tint struct_start = buffer_offset;\n\n\t\tbuffer_offset = dissect_FORM_REL(\n\t\t\tbuffer.tvb, buffer_offset, pinfo, buffer.tree, di, drep,\n\t\t\tstruct_start);\n\t}\n\n\toffset = dissect_doserror(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_rc, NULL);\n\n\treturn offset;\n}\n\n/*\n * SpoolssDeletePrinter\n */\n\nstatic int\nSpoolssDeletePrinter_q(tvbuff_t *tvb, int offset,\n\t\t\t\t  packet_info *pinfo, proto_tree *tree,\n\t\t\t\t  dcerpc_info *di, guint8 *drep _U_)\n{\n\t/* Parse packet */\n\n\toffset = dissect_nt_policy_hnd(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_hnd, NULL, NULL,\n\t\tFALSE, FALSE);\n\n\treturn offset;\n}\n\nstatic int\nSpoolssDeletePrinter_r(tvbuff_t *tvb, int offset,\n\t\t\t\t  packet_info *pinfo, proto_tree *tree,\n\t\t\t\t  dcerpc_info *di, guint8 *drep _U_)\n{\n\t/* Parse packet */\n\n\toffset = dissect_nt_policy_hnd(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_hnd, NULL, NULL,\n\t\tFALSE, FALSE);\n\n\toffset = dissect_doserror(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_rc, NULL);\n\n\treturn offset;\n}\n\nstatic int\nSpoolssAddPrinterEx_r(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\t\t proto_tree *tree, dcerpc_info *di, guint8 *drep _U_)\n{\n\tdcerpc_call_value *dcv = (dcerpc_call_value *)di->call_data;\n\te_ctx_hnd policy_hnd;\n\tproto_item *hnd_item;\n\tguint32 status;\n\n\t/* Parse packet */\n\n\toffset = dissect_nt_policy_hnd(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_hnd, &policy_hnd, &hnd_item,\n\t\tTRUE, FALSE);\n\n\toffset = dissect_doserror(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_rc, &status);\n\n\tif( status == 0 ){\n\t\tconst char *pol_name;\n\n\t\tif (dcv->se_data){\n\t\t\tpol_name = wmem_strdup_printf(wmem_packet_scope(),\n\t\t\t\t\"AddPrinterEx(%s)\", (char *)dcv->se_data);\n\t\t} else {\n\t\t\tpol_name = \"Unknown AddPrinterEx() handle\";\n\t\t}\n\t\tif(!pinfo->fd->flags.visited){\n\t\t\tdcerpc_store_polhnd_name(&policy_hnd, pinfo, pol_name);\n\t\t}\n\n\t\tif(hnd_item)\n\t\t\tproto_item_append_text(hnd_item, \": %s\", pol_name);\n\t}\n\n\treturn offset;\n}\n\n/*\n * SpoolssEnumPrinterData\n */\n\nstatic int hf_enumprinterdata_enumindex = -1;\nstatic int hf_enumprinterdata_value_offered = -1;\nstatic int hf_enumprinterdata_data_offered = -1;\nstatic int hf_enumprinterdata_value_len = -1;\nstatic int hf_enumprinterdata_value_needed = -1;\nstatic int hf_enumprinterdata_data_needed = -1;\n\nstatic int\nSpoolssEnumPrinterData_q(tvbuff_t *tvb, int offset,\n\t\t\t\t    packet_info *pinfo, proto_tree *tree,\n\t\t\t\t    dcerpc_info *di, guint8 *drep _U_)\n{\n\tguint32 ndx;\n\tproto_item *hidden_item;\n\n\thidden_item = proto_tree_add_uint(\n\t\ttree, hf_printerdata, tvb, offset, 0, 1);\n\tPROTO_ITEM_SET_HIDDEN(hidden_item);\n\n\t/* Parse packet */\n\n\toffset = dissect_nt_policy_hnd(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_hnd, NULL, NULL,\n\t\tFALSE, FALSE);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep,\n\t\thf_enumprinterdata_enumindex, &ndx);\n\n\tcol_append_fstr(pinfo->cinfo, COL_INFO, \", index %d\", ndx);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep,\n\t\thf_enumprinterdata_value_offered, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep,\n\t\thf_enumprinterdata_data_offered, NULL);\n\n\treturn offset;\n}\n\nstatic int\nSpoolssEnumPrinterData_r(tvbuff_t *tvb, int offset,\n\t\t\t\t    packet_info *pinfo, proto_tree *tree,\n\t\t\t\t    dcerpc_info *di, guint8 *drep _U_)\n{\n\tguint32 value_len, type;\n\tchar *value;\n\tproto_item *value_item;\n\tproto_tree *value_subtree;\n\tproto_item *hidden_item;\n\n\thidden_item = proto_tree_add_uint(\n\t\ttree, hf_printerdata, tvb, offset, 0, 1);\n\tPROTO_ITEM_SET_HIDDEN(hidden_item);\n\n\t/* Parse packet */\n\n\tvalue_subtree = proto_tree_add_subtree(tree, tvb, offset, 0, ett_printerdata_value, &value_item, \"Value\");\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, value_subtree, di, drep,\n\t\thf_enumprinterdata_value_len, &value_len);\n\n\tif (value_len) {\n\t\tdissect_spoolss_uint16uni(\n\t\t\ttvb, offset, pinfo, value_subtree, drep, &value, hf_value_name);\n\n\t\toffset += value_len * 2;\n\n\t\tif (value && value[0])\n\t\t\tcol_append_fstr(pinfo->cinfo, COL_INFO, \", %s\", value);\n\n\t\tproto_item_append_text(value_item, \": %s\", value);\n\n\t\thidden_item = proto_tree_add_string(\n\t\t\ttree, hf_printerdata_value, tvb, offset, 0, value);\n\t\tPROTO_ITEM_SET_HIDDEN(hidden_item);\n\n\t\tg_free(value);\n\t}\n\n\tproto_item_set_len(value_item, value_len * 2 + 4);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, value_subtree, di, drep,\n\t\thf_enumprinterdata_value_needed, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printerdata_type, &type);\n\n\toffset = dissect_printerdata_data(\n\t\ttvb, offset, pinfo, tree, di, drep, type);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep,\n\t\thf_enumprinterdata_data_needed, NULL);\n\n\toffset = dissect_doserror(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_rc, NULL);\n\n\treturn offset;\n}\n\n/*\n * SpoolssEnumPrinters\n */\n\nstatic gint ett_enumprinters_flags = -1;\n\nstatic int hf_enumprinters_flags = -1;\nstatic int hf_enumprinters_flags_local = -1;\nstatic int hf_enumprinters_flags_name = -1;\nstatic int hf_enumprinters_flags_shared = -1;\nstatic int hf_enumprinters_flags_default = -1;\nstatic int hf_enumprinters_flags_connections = -1;\nstatic int hf_enumprinters_flags_network = -1;\nstatic int hf_enumprinters_flags_remote = -1;\n\nstatic int\nSpoolssEnumPrinters_q(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\t\t proto_tree *tree, dcerpc_info *di, guint8 *drep _U_)\n{\n\tguint32 level, flags;\n\tdcerpc_call_value *dcv = (dcerpc_call_value *)di->call_data;\n\tstatic const int * hf_flags[] = {\n\t\t&hf_enumprinters_flags_network,\n\t\t&hf_enumprinters_flags_shared,\n\t\t&hf_enumprinters_flags_remote,\n\t\t&hf_enumprinters_flags_name,\n\t\t&hf_enumprinters_flags_connections,\n\t\t&hf_enumprinters_flags_local,\n\t\t&hf_enumprinters_flags_default,\n\t\tNULL\n\t};\n\n\t/* Parse packet */\n\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, NULL, di, drep, -1, &flags);\n\n\tproto_tree_add_bitmask_value(tree, tvb, offset - 4, hf_enumprinters_flags,\n\t\t\t\t\tett_enumprinters_flags, hf_flags, flags);\n\n\toffset = dissect_ndr_str_pointer_item(\n\t\ttvb, offset, pinfo, tree, di, drep,\n\t\tNDR_POINTER_UNIQUE, \"Server name\", hf_servername, 0);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_level, &level);\n\n\t/* GetPrinter() stores the level in se_data */\n\tif(!pinfo->fd->flags.visited){\n\t\tdcv->se_data = GINT_TO_POINTER((int)level);\n\t}\n\n\tcol_append_fstr(pinfo->cinfo, COL_INFO, \", level %d\", level);\n\n\toffset = dissect_spoolss_buffer(\n\t\ttvb, offset, pinfo, tree, di, drep, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_offered, NULL);\n\n\treturn offset;\n}\n\nstatic int\nSpoolssEnumPrinters_r(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\t\t proto_tree *tree, dcerpc_info *di, guint8 *drep _U_)\n{\n\tguint32 num_drivers;\n\tdcerpc_call_value *dcv = (dcerpc_call_value *)di->call_data;\n\tgint16 level = GPOINTER_TO_INT(dcv->se_data);\n\tBUFFER buffer;\n\tproto_item *item;\n\tproto_tree *subtree = NULL;\n\n\tcol_append_fstr(pinfo->cinfo, COL_INFO, \", level %d\", level);\n\n\t/* Parse packet */\n\n\toffset = dissect_spoolss_buffer(\n\t\ttvb, offset, pinfo, tree, di, drep, &buffer);\n\n\tif (buffer.tvb) {\n\t\tsubtree = proto_tree_add_subtree_format( buffer.tree, buffer.tvb, 0, -1, ett_PRINTER_INFO, &item, \"Print info level %d\", level);\n\n\t\tswitch(level) {\n\t\tcase 0:\n\t\t\tdissect_PRINTER_INFO_0(\n\t\t\t\tbuffer.tvb, 0, pinfo, subtree, di, drep);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tdissect_PRINTER_INFO_1(\n\t\t\t\tbuffer.tvb, 0, pinfo, subtree, di, drep);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tdissect_PRINTER_INFO_2(\n\t\t\t\tbuffer.tvb, 0, pinfo, subtree, di, drep);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tdissect_PRINTER_INFO_3(\n\t\t\t\tbuffer.tvb, 0, pinfo, subtree, di, drep);\n\t\t\tbreak;\n\t\tcase 7:\n\t\t\tdissect_PRINTER_INFO_7(\n\t\t\t\tbuffer.tvb, 0, pinfo, subtree, di, drep);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\texpert_add_info(pinfo, item, &ei_printer_info_level);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_needed, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_returned,\n\t\t&num_drivers);\n\n\toffset = dissect_doserror(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_rc, NULL);\n\n\treturn offset;\n}\n\n/*\n * AddPrinterDriver\n */\nstatic int\nSpoolssAddPrinterDriver_r(tvbuff_t *tvb, int offset,\n\t\t\t\t     packet_info *pinfo, proto_tree *tree,\n\t\t\t\t     dcerpc_info *di, guint8 *drep _U_)\n{\n\t/* Parse packet */\n\n\toffset = dissect_doserror(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_rc, NULL);\n\n\treturn offset;\n}\n\n/*\n * FORM_1\n */\n\nstatic gint ett_FORM_1 = -1;\n\nstatic int\ndissect_FORM_1(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\t  proto_tree *tree, dcerpc_info *di, guint8 *drep)\n{\n\tproto_tree *subtree;\n\tguint32 flags;\n\n\tsubtree = proto_tree_add_subtree(tree, tvb, offset, 0, ett_FORM_1, NULL, \"Form level 1\");\n\n\toffset = dissect_ndr_str_pointer_item(\n\t\ttvb, offset, pinfo, subtree, di, drep, NDR_POINTER_UNIQUE,\n\t\t\"Name\", hf_form_name, 0);\n\n\t/* Eek - we need to know whether this pointer was NULL or not.\n\t   Currently there is not any way to do this. */\n\n\tif (tvb_reported_length_remaining(tvb, offset) <= 0)\n\t\tgoto done;\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_form_flags, &flags);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\thf_form_unknown, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\thf_form_width, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\thf_form_height, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\thf_form_left_margin, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\thf_form_top_margin, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\thf_form_horiz_len, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\thf_form_vert_len, NULL);\n\n done:\n\treturn offset;\n}\n\n/*\n * FORM_CTR\n */\n\nstatic gint ett_FORM_CTR = -1;\n\nstatic int\ndissect_FORM_CTR(tvbuff_t *tvb, int offset,\n\t\t\t    packet_info *pinfo, proto_tree *tree,\n\t\t\t    dcerpc_info *di, guint8 *drep)\n{\n\tproto_tree *subtree;\n\tproto_item *item;\n\tguint32 level;\n\n\tsubtree = proto_tree_add_subtree(tree, tvb, offset, 0, ett_FORM_CTR, &item, \"Form container\");\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_form_level, &level);\n\n\tswitch(level) {\n\tcase 1:\n\t\toffset = dissect_FORM_1(tvb, offset, pinfo, subtree, di, drep);\n\t\tbreak;\n\n\tdefault:\n\t\texpert_add_info_format(pinfo, item, &ei_form_level, \"Unknown form info level %d\", level);\n\t\tbreak;\n\t}\n\n\treturn offset;\n}\n\n/*\n * AddForm\n */\n\nstatic int\nSpoolssAddForm_q(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\t    proto_tree *tree, dcerpc_info *di, guint8 *drep _U_)\n{\n\tdcerpc_call_value *dcv = (dcerpc_call_value *)di->call_data;\n\tguint32 level;\n\tproto_item *hidden_item;\n\n\thidden_item = proto_tree_add_uint(\n\t\ttree, hf_form, tvb, offset, 0, 1);\n\tPROTO_ITEM_SET_HIDDEN(hidden_item);\n\n\t/* Parse packet */\n\n\toffset = dissect_nt_policy_hnd(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_hnd, NULL, NULL,\n\t\tFALSE, FALSE);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_form_level, &level);\n\n\tcol_append_fstr(pinfo->cinfo, COL_INFO, \", level %d\", level);\n\n\t/* AddForm() stores the level in se_data */\n\tif(!pinfo->fd->flags.visited){\n\t\t\tdcv->se_data = GUINT_TO_POINTER((int)level);\n\t}\n\n\toffset = dissect_FORM_CTR(tvb, offset, pinfo, tree, di, drep);\n\n\treturn offset;\n}\n\nstatic int\nSpoolssAddForm_r(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\t    proto_tree *tree, dcerpc_info *di, guint8 *drep _U_)\n{\n\tproto_item *hidden_item;\n\n\thidden_item = proto_tree_add_uint(\n\t\ttree, hf_form, tvb, offset, 0, 1);\n\tPROTO_ITEM_SET_HIDDEN(hidden_item);\n\n\t/* Parse packet */\n\n\toffset = dissect_doserror(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_rc, NULL);\n\n\treturn offset;\n}\n\n/*\n * DeleteForm\n */\n\nstatic int\nSpoolssDeleteForm_q(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\t       proto_tree *tree, dcerpc_info *di, guint8 *drep _U_)\n{\n\tproto_item *hidden_item;\n\tchar *name = NULL;\n\n\thidden_item = proto_tree_add_uint(\n\t\ttree, hf_form, tvb, offset, 0, 1);\n\tPROTO_ITEM_SET_HIDDEN(hidden_item);\n\n\t/* Parse packet */\n\n\toffset = dissect_nt_policy_hnd(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_hnd, NULL, NULL,\n\t\tFALSE, FALSE);\n\n\toffset = dissect_ndr_cvstring(\n\t\ttvb, offset, pinfo, tree, di, drep,\n\t\tsizeof(guint16), hf_form_name, TRUE, &name);\n\n\tif (name)\n\t\tcol_append_fstr(pinfo->cinfo, COL_INFO, \", %s\", name);\n\n\treturn offset;\n}\n\nstatic int\nSpoolssDeleteForm_r(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\t    proto_tree *tree, dcerpc_info *di, guint8 *drep _U_)\n{\n\tproto_item *hidden_item;\n\n\thidden_item = proto_tree_add_uint(\n\t\ttree, hf_form, tvb, offset, 0, 1);\n\tPROTO_ITEM_SET_HIDDEN(hidden_item);\n\n\t/* Parse packet */\n\n\toffset = dissect_doserror(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_rc, NULL);\n\n\treturn offset;\n}\n\n/*\n * SetForm\n */\n\nstatic int\nSpoolssSetForm_q(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\t    proto_tree *tree, dcerpc_info *di, guint8 *drep _U_)\n{\n\tchar *name = NULL;\n\tguint32 level;\n\tproto_item *hidden_item;\n\n\thidden_item = proto_tree_add_uint(\n\t\ttree, hf_form, tvb, offset, 0, 1);\n\tPROTO_ITEM_SET_HIDDEN(hidden_item);\n\n\t/* Parse packet */\n\n\toffset = dissect_nt_policy_hnd(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_hnd, NULL, NULL,\n\t\tFALSE, FALSE);\n\n\toffset = dissect_ndr_cvstring(\n\t\ttvb, offset, pinfo, tree, di, drep,\n\t\tsizeof(guint16), hf_form_name, TRUE, &name);\n\n\tif (name)\n\t\tcol_append_fstr(pinfo->cinfo, COL_INFO, \", %s\", name);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_form_level, &level);\n\n\tcol_append_fstr(pinfo->cinfo, COL_INFO, \", level %d\", level);\n\n\toffset = dissect_FORM_CTR(tvb, offset, pinfo, tree, di, drep);\n\n\treturn offset;\n}\n\nstatic int\nSpoolssSetForm_r(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\t    proto_tree *tree, dcerpc_info *di, guint8 *drep _U_)\n{\n\tproto_item *hidden_item;\n\n\thidden_item = proto_tree_add_uint(\n\t\ttree, hf_form, tvb, offset, 0, 1);\n\tPROTO_ITEM_SET_HIDDEN(hidden_item);\n\n\t/* Parse packet */\n\n\toffset = dissect_doserror(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_rc, NULL);\n\n\treturn offset;\n}\n\n/*\n * GetForm\n */\n\nstatic int\nSpoolssGetForm_q(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\t    proto_tree *tree, dcerpc_info *di, guint8 *drep _U_)\n{\n\tdcerpc_call_value *dcv = (dcerpc_call_value *)di->call_data;\n\tproto_item *hidden_item;\n\tguint32 level;\n\tchar *name;\n\n\thidden_item = proto_tree_add_uint(\n\t\ttree, hf_form, tvb, offset, 0, 1);\n\tPROTO_ITEM_SET_HIDDEN(hidden_item);\n\n\t/* Parse packet */\n\n\toffset = dissect_nt_policy_hnd(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_hnd, NULL, NULL,\n\t\tFALSE, FALSE);\n\n\toffset = dissect_ndr_cvstring(\n\t\ttvb, offset, pinfo, tree, di, drep,\n\t\tsizeof(guint16), hf_form_name, TRUE, &name);\n\n\tcol_append_fstr(pinfo->cinfo, COL_INFO, \", %s\", name);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_form_level, &level);\n\n\t/* GetForm() stores the level in se_data */\n\tif(!pinfo->fd->flags.visited){\n\t\t\tdcv->se_data = GUINT_TO_POINTER((int)level);\n\t}\n\n\tcol_append_fstr(pinfo->cinfo, COL_INFO, \", level %d\",\n\t\t\t\tlevel);\n\n\toffset = dissect_spoolss_buffer(tvb, offset, pinfo, tree, di, drep, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_offered, NULL);\n\n\treturn offset;\n}\n\nstatic int\nSpoolssGetForm_r(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\t    proto_tree *tree, dcerpc_info *di, guint8 *drep _U_)\n{\n\tdcerpc_call_value *dcv = (dcerpc_call_value *)di->call_data;\n\tBUFFER buffer;\n\tguint32 level = GPOINTER_TO_UINT(dcv->se_data);\n\tproto_item *hidden_item;\n\n\thidden_item = proto_tree_add_uint(\n\t\ttree, hf_form, tvb, offset, 0, 1);\n\tPROTO_ITEM_SET_HIDDEN(hidden_item);\n\n\t/* Parse packet */\n\n\toffset = dissect_spoolss_buffer(\n\t\ttvb, offset, pinfo, tree, di, drep, &buffer);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_needed, NULL);\n\n\tcol_append_fstr(pinfo->cinfo, COL_INFO, \", level %d\", level);\n\n\tif (buffer.tvb) {\n\t\tint buffer_offset = 0;\n\n\t\tswitch(level) {\n\t\tcase 1: {\n\t\t\tint struct_start = buffer_offset;\n\n\t\t\t/*buffer_offset = */dissect_FORM_REL(\n\t\t\t\tbuffer.tvb, buffer_offset, pinfo, tree, di, drep,\n\t\t\t\tstruct_start);\n\t\t\tbreak;\n\t\t}\n\n\t\tdefault:\n\t\t\tproto_tree_add_expert_format(buffer.tree, pinfo, &ei_form_level, buffer.tvb, buffer_offset, -1, \"Unknown form info level %d\", level);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\toffset = dissect_doserror(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_rc, NULL);\n\n\treturn offset;\n}\n\n\n/* A generic reply function that just parses the status code.  Useful for\n   unimplemented dissectors so the status code can be inserted into the\n   INFO column. */\n\nstatic int\nSpoolssGeneric_r(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\t    proto_tree *tree, dcerpc_info *di, guint8 *drep _U_)\n{\n\tint len = tvb_reported_length(tvb);\n\n\tproto_tree_add_expert(tree, pinfo, &ei_unimplemented_dissector, tvb, offset, 0);\n\n\toffset = dissect_doserror(\n\t\ttvb, len - 4, pinfo, tree, di, drep, hf_rc, NULL);\n\n\treturn offset;\n}\n\n/*\n * JOB_INFO_1\n */\n\nstatic gint ett_JOB_INFO_1 = -1;\n\nstatic int\ndissect_spoolss_JOB_INFO_1(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\t   proto_tree *tree, dcerpc_info *di, guint8 *drep)\n{\n\tproto_item *item;\n\tproto_tree *subtree;\n\tint struct_start = offset;\n\tchar *document_name;\n\n\tsubtree = proto_tree_add_subtree(tree, tvb, offset, 0, ett_JOB_INFO_1, &item, \"Job info level 1\");\n\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, subtree, di, drep,\n\t\t\t\t    hf_job_id, NULL);\n\n\toffset = dissect_spoolss_relstr(\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_printername,\n\t\tstruct_start, NULL);\n\n\toffset = dissect_spoolss_relstr(\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_servername,\n\t\tstruct_start, NULL);\n\n\toffset = dissect_spoolss_relstr(\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_username,\n\t\tstruct_start, NULL);\n\n\toffset = dissect_spoolss_relstr(\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_documentname,\n\t\tstruct_start, &document_name);\n\n\tproto_item_append_text(item, \": %s\", document_name);\n\tg_free(document_name);\n\n\toffset = dissect_spoolss_relstr(\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_datatype,\n\t\tstruct_start, NULL);\n\n\toffset = dissect_spoolss_relstr(\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_textstatus,\n\t\tstruct_start, NULL);\n\n\toffset = dissect_job_status(tvb, offset, pinfo, subtree, di, drep);\n\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, subtree, di, drep,\n\t\t\t\t    hf_job_priority, NULL);\n\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, subtree, di, drep,\n\t\t\t\t    hf_job_position, NULL);\n\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, subtree, di, drep,\n\t\t\t\t    hf_job_totalpages, NULL);\n\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, subtree, di, drep,\n\t\t\t\t    hf_job_pagesprinted, NULL);\n\n\toffset = dissect_SYSTEM_TIME(\n\t\ttvb, offset, pinfo, subtree, di, drep, \"Job Submission Time\",\n\t\tTRUE, NULL);\n\n\tproto_item_set_len(item, offset - struct_start);\n\n\treturn offset;\n}\n\n/*\n * JOB_INFO_2\n */\n\nstatic gint ett_JOB_INFO_2 = -1;\n\nstatic int\ndissect_spoolss_JOB_INFO_2(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\t   proto_tree *tree, dcerpc_info *di, guint8 *drep)\n{\n\tproto_item *item;\n\tproto_tree *subtree;\n\tint struct_start = offset;\n\tchar *document_name;\n\tguint32 devmode_offset, secdesc_offset;\n\n\tsubtree = proto_tree_add_subtree(tree, tvb, offset, 0, ett_JOB_INFO_2, &item, \"Job info level 2\");\n\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, subtree, di, drep,\n\t\t\t\t    hf_job_id, NULL);\n\n\toffset = dissect_spoolss_relstr(\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_printername,\n\t\tstruct_start, NULL);\n\n\toffset = dissect_spoolss_relstr(\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_machinename,\n\t\tstruct_start, NULL);\n\n\toffset = dissect_spoolss_relstr(\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_username,\n\t\tstruct_start, NULL);\n\n\toffset = dissect_spoolss_relstr(\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_documentname,\n\t\tstruct_start, &document_name);\n\n\tproto_item_append_text(item, \": %s\", document_name);\n\tg_free(document_name);\n\n\toffset = dissect_spoolss_relstr(\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_notifyname,\n\t\tstruct_start, NULL);\n\n\toffset = dissect_spoolss_relstr(\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_datatype,\n\t\tstruct_start, NULL);\n\n\toffset = dissect_spoolss_relstr(\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_printprocessor,\n\t\tstruct_start, NULL);\n\n\toffset = dissect_spoolss_relstr(\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_parameters,\n\t\tstruct_start, NULL);\n\n\toffset = dissect_spoolss_relstr(\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_drivername,\n\t\tstruct_start, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, NULL, di, drep, hf_offset,\n\t\t&devmode_offset);\n\n\tdissect_DEVMODE(\n\t\ttvb, devmode_offset - 4 + struct_start, pinfo, subtree, di, drep);\n\n\toffset = dissect_spoolss_relstr(\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_textstatus,\n\t\tstruct_start, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, NULL, di, drep, hf_offset,\n\t\t&secdesc_offset);\n\n\tdissect_nt_sec_desc(\n\t\ttvb, secdesc_offset, pinfo, subtree, drep,\n\t\tFALSE, -1,\n\t\t&spoolss_job_access_mask_info);\n\n\toffset = dissect_job_status(tvb, offset, pinfo, subtree, di, drep);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_job_priority, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_job_position, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, NULL, di, drep, hf_start_time, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, NULL, di, drep, hf_end_time, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_job_totalpages, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_job_size, NULL);\n\n\toffset = dissect_SYSTEM_TIME(\n\t\ttvb, offset, pinfo, subtree, di, drep, \"Job Submission Time\",\n\t\tTRUE, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, NULL, di, drep, hf_elapsed_time, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_job_pagesprinted, NULL);\n\n\tproto_item_set_len(item, offset - struct_start);\n\n\treturn offset;\n}\n\n/*\n * EnumJobs\n */\n\nstatic int hf_enumjobs_firstjob = -1;\nstatic int hf_enumjobs_numjobs = -1;\n\nstatic int\nSpoolssEnumJobs_q(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\t     proto_tree *tree, dcerpc_info *di, guint8 *drep _U_)\n{\n\tdcerpc_call_value *dcv = (dcerpc_call_value *)di->call_data;\n\tguint32 level;\n\n\t/* Parse packet */\n\n\toffset = dissect_nt_policy_hnd(\n\t\ttvb, offset, pinfo, tree, di, drep,\n\t\thf_hnd, NULL, NULL, FALSE, FALSE);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_enumjobs_firstjob, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_enumjobs_numjobs, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_level, &level);\n\n\t/* EnumJobs() stores the level in se_data */\n\tif(!pinfo->fd->flags.visited){\n\t\t\tdcv->se_data = GUINT_TO_POINTER((int)level);\n\t}\n\n\tcol_append_fstr(pinfo->cinfo, COL_INFO, \", level %d\", level);\n\n\toffset = dissect_spoolss_buffer(tvb, offset, pinfo, tree, di, drep, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_offered, NULL);\n\n\treturn offset;\n}\n\nstatic int\nSpoolssEnumJobs_r(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\t     proto_tree *tree, dcerpc_info *di, guint8 *drep _U_)\n{\n\tdcerpc_call_value *dcv = (dcerpc_call_value *)di->call_data;\n\tgint16 level = GPOINTER_TO_UINT(dcv->se_data);\n\tBUFFER buffer;\n\tguint32 num_jobs, i;\n\tint buffer_offset;\n\n\t/* Parse packet */\n\n\toffset = dissect_spoolss_buffer(\n\t\ttvb, offset, pinfo, tree, di, drep, &buffer);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_needed, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_enumjobs_numjobs,\n\t\t&num_jobs);\n\n\tbuffer_offset = 0;\n\n\tfor (i = 0; i < num_jobs; i++) {\n\t\tswitch(level) {\n\t\tcase 1:\n\t\t\tbuffer_offset = dissect_spoolss_JOB_INFO_1(\n\t\t\t\tbuffer.tvb, buffer_offset, pinfo,\n\t\t\t\tbuffer.tree, di, drep);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tbuffer_offset = dissect_spoolss_JOB_INFO_2(\n\t\t\t\tbuffer.tvb, buffer_offset, pinfo,\n\t\t\t\tbuffer.tree, di, drep);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tproto_tree_add_expert_format( buffer.tree, pinfo, &ei_job_info_level, buffer.tvb, 0, -1, \"Unknown job info level %d\", level);\n\t\t\tbreak;\n\t\t}\n\n\t}\n\n\toffset = dissect_doserror(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_rc, NULL);\n\n\treturn offset;\n}\n\n/*\n * SetJob\n */\n\nstatic const value_string setjob_commands[] = {\n\t{ JOB_CONTROL_PAUSE, \"Pause\" },\n\t{ JOB_CONTROL_RESUME, \"Resume\" },\n\t{ JOB_CONTROL_CANCEL, \"Cancel\" },\n\t{ JOB_CONTROL_RESTART, \"Restart\" },\n\t{ JOB_CONTROL_DELETE, \"Delete\" },\n\t{ 0, NULL }\n};\n\nstatic int hf_setjob_cmd = -1;\n\nstatic int\nSpoolssSetJob_q(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\t   proto_tree *tree, dcerpc_info *di, guint8 *drep)\n{\n\tguint32 jobid, cmd;\n\n\t/* Parse packet */\n\n\toffset = dissect_nt_policy_hnd(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_hnd, NULL, NULL,\n\t\tFALSE, FALSE);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_job_id, &jobid);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_level, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_setjob_cmd, &cmd);\n\n\tcol_append_fstr(\n\t\t\tpinfo->cinfo, COL_INFO, \", %s jobid %d\",\n\t\t\tval_to_str(cmd, setjob_commands, \"Unknown (%d)\"),\n\t\t\tjobid);\n\n\treturn offset;\n}\n\nstatic int\nSpoolssSetJob_r(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\t   proto_tree *tree, dcerpc_info *di, guint8 *drep)\n{\n\t/* Parse packet */\n\n\toffset = dissect_doserror(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_rc, NULL);\n\n\treturn offset;\n}\n\n/*\n * GetJob\n */\n\nstatic int\nSpoolssGetJob_q(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\t   proto_tree *tree, dcerpc_info *di, guint8 *drep)\n{\n\tdcerpc_call_value *dcv = (dcerpc_call_value *)di->call_data;\n\tguint32 level, jobid;\n\n\t/* Parse packet */\n\n\toffset = dissect_nt_policy_hnd(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_hnd, NULL, NULL,\n\t\tFALSE, FALSE);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_job_id, &jobid);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_level, &level);\n\n\t/* GetJob() stores the level in se_data */\n\tif(!pinfo->fd->flags.visited){\n\t\t\tdcv->se_data = GUINT_TO_POINTER((int)level);\n\t}\n\n\tcol_append_fstr(pinfo->cinfo, COL_INFO, \", level %d, jobid %d\",\n\t\t\t\tlevel, jobid);\n\n\toffset = dissect_spoolss_buffer(tvb, offset, pinfo, tree, di, drep, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_offered, NULL);\n\n\treturn offset;\n}\n\nstatic int\nSpoolssGetJob_r(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\tproto_tree *tree, dcerpc_info *di, guint8 *drep)\n{\n\tdcerpc_call_value *dcv = (dcerpc_call_value *)di->call_data;\n\tgint32 level = GPOINTER_TO_UINT(dcv->se_data);\n\tBUFFER buffer;\n\n\t/* Parse packet */\n\n\toffset = dissect_spoolss_buffer(tvb, offset, pinfo, tree, di, drep,\n\t\t\t\t\t&buffer);\n\n\tif (buffer.tvb) {\n\t\tint buffer_offset = 0;\n\n\t\tswitch(level) {\n\t\tcase 1:\n\t\t\t/*buffer_offset = */dissect_spoolss_JOB_INFO_1(\n\t\t\t\tbuffer.tvb, buffer_offset, pinfo,\n\t\t\t\tbuffer.tree, di, drep);\n\t\t\tbreak;\n\t\tcase 2:\n\t\tdefault:\n\t\t\tproto_tree_add_expert_format( buffer.tree, pinfo, &ei_job_info_level, buffer.tvb, buffer_offset, -1, \"Unknown job info level %d\", level);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_needed, NULL);\n\n\toffset = dissect_doserror(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_rc, NULL);\n\n\treturn offset;\n}\n\n/*\n * StartPagePrinter\n */\n\nstatic int\nSpoolssStartPagePrinter_q(tvbuff_t *tvb, int offset,\n\t\t\t\t     packet_info *pinfo, proto_tree *tree,\n\t\t\t\t     dcerpc_info *di, guint8 *drep)\n{\n\te_ctx_hnd policy_hnd;\n\tchar *pol_name;\n\n\t/* Parse packet */\n\n\toffset = dissect_nt_policy_hnd(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_hnd, &policy_hnd, NULL,\n\t\tFALSE, FALSE);\n\n\tdcerpc_fetch_polhnd_data(&policy_hnd, &pol_name, NULL, NULL, NULL,\n\t\t\t     pinfo->num);\n\n\tif (pol_name)\n\t\tcol_append_fstr(pinfo->cinfo, COL_INFO, \", %s\",\n\t\t\t\tpol_name);\n\n\treturn offset;\n}\n\nstatic int\nSpoolssStartPagePrinter_r(tvbuff_t *tvb, int offset,\n\t\t\t\t     packet_info *pinfo, proto_tree *tree,\n\t\t\t\t     dcerpc_info *di, guint8 *drep)\n{\n\t/* Parse packet */\n\n\toffset = dissect_doserror(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_rc, NULL);\n\n\treturn offset;\n}\n\n/*\n * EndPagePrinter\n */\n\nstatic int\nSpoolssEndPagePrinter_q(tvbuff_t *tvb, int offset,\n\t\t\t\t   packet_info *pinfo, proto_tree *tree,\n\t\t\t\t   dcerpc_info *di, guint8 *drep)\n{\n\te_ctx_hnd policy_hnd;\n\tchar *pol_name;\n\n\t/* Parse packet */\n\n\toffset = dissect_nt_policy_hnd(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_hnd, &policy_hnd, NULL,\n\t\tFALSE, FALSE);\n\n\tdcerpc_fetch_polhnd_data(&policy_hnd, &pol_name, NULL, NULL, NULL,\n\t\t\t     pinfo->num);\n\n\tif (pol_name)\n\t\tcol_append_fstr(pinfo->cinfo, COL_INFO, \", %s\",\n\t\t\t\tpol_name);\n\n\treturn offset;\n}\n\nstatic int\nSpoolssEndPagePrinter_r(tvbuff_t *tvb, int offset,\n\t\t\t\t   packet_info *pinfo, proto_tree *tree,\n\t\t\t\t   dcerpc_info *di, guint8 *drep)\n{\n\t/* Parse packet */\n\n\toffset = dissect_doserror(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_rc, NULL);\n\n\treturn offset;\n}\n\n/*\n * DOC_INFO_1\n */\n\nstatic gint ett_DOC_INFO_1 = -1;\n\nstatic int\ndissect_spoolss_doc_info_1(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\t   proto_tree *tree, dcerpc_info *di, guint8 *drep)\n{\n\tproto_tree *subtree;\n\n\tsubtree = proto_tree_add_subtree(\n\t\ttree, tvb, offset, 0, ett_DOC_INFO_1, NULL, \"Document info level 1\");\n\n\toffset = dissect_ndr_str_pointer_item(\n\t\ttvb, offset, pinfo, subtree, di, drep, NDR_POINTER_UNIQUE,\n\t\t\"Document name\", hf_documentname, 0);\n\n\toffset = dissect_ndr_str_pointer_item(\n\t\ttvb, offset, pinfo, subtree, di, drep, NDR_POINTER_UNIQUE,\n\t\t\"Output file\", hf_outputfile, 0);\n\n\toffset = dissect_ndr_str_pointer_item(\n\t\ttvb, offset, pinfo, subtree, di, drep, NDR_POINTER_UNIQUE,\n\t\t\"Data type\", hf_datatype, 0);\n\n\treturn offset;\n}\n\nstatic int\ndissect_spoolss_doc_info_data(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\t      proto_tree *tree, dcerpc_info *di, guint8 *drep)\n{\n\tif (di->conformant_run)\n\t\treturn offset;\n\n\treturn dissect_spoolss_doc_info_1(tvb, offset, pinfo, tree, di, drep);\n}\n\n/*\n * DOC_INFO\n */\n\nstatic gint ett_DOC_INFO = -1;\n\nstatic int\ndissect_spoolss_doc_info(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\t proto_tree *tree, dcerpc_info *di, guint8 *drep)\n{\n\tproto_tree *subtree;\n\tguint32 level;\n\n\tsubtree = proto_tree_add_subtree(\n\t\ttree, tvb, offset, 0, ett_DOC_INFO, NULL, \"Document info\");\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_level, &level);\n\n\toffset = dissect_ndr_pointer(\n\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\tdissect_spoolss_doc_info_data,\n\t\tNDR_POINTER_UNIQUE, \"Document info\", -1);\n\n\treturn offset;\n}\n\n/*\n * DOC_INFO_CTR\n */\n\nstatic gint ett_DOC_INFO_CTR = -1;\n\nstatic int\ndissect_spoolss_doc_info_ctr(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\t     proto_tree *tree, dcerpc_info *di, guint8 *drep)\n{\n\tproto_tree *subtree;\n\n\tsubtree = proto_tree_add_subtree(\n\t\ttree, tvb, offset, 0, ett_DOC_INFO_CTR, NULL, \"Document info container\");\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_level, NULL);\n\n\toffset = dissect_spoolss_doc_info(\n\t\ttvb, offset, pinfo, subtree, di, drep);\n\n\treturn offset;\n}\n\n/*\n * StartDocPrinter\n */\n\nstatic int\nSpoolssStartDocPrinter_q(tvbuff_t *tvb, int offset,\n\t\t\t\t    packet_info *pinfo, proto_tree *tree,\n\t\t\t\t    dcerpc_info *di, guint8 *drep)\n{\n\te_ctx_hnd policy_hnd;\n\tchar *pol_name;\n\n\t/* Parse packet */\n\n\toffset = dissect_nt_policy_hnd(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_hnd, &policy_hnd, NULL,\n\t\tFALSE, FALSE);\n\n\tdcerpc_fetch_polhnd_data(&policy_hnd, &pol_name, NULL, NULL, NULL,\n\t\t\t     pinfo->num);\n\n\tif (pol_name)\n\t\tcol_append_fstr(pinfo->cinfo, COL_INFO, \", %s\",\n\t\t\t\tpol_name);\n\n\toffset = dissect_spoolss_doc_info_ctr(tvb, offset, pinfo, tree, di, drep);\n\n\treturn offset;\n}\n\nstatic int\nSpoolssStartDocPrinter_r(tvbuff_t *tvb, int offset,\n\t\t\t\t    packet_info *pinfo, proto_tree *tree,\n\t\t\t\t    dcerpc_info *di, guint8 *drep)\n{\n\t/* Parse packet */\n\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, tree, di, drep,\n\t\t\t\t    hf_job_id, NULL);\n\n\toffset = dissect_doserror(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_rc, NULL);\n\n\treturn offset;\n}\n\n/*\n * EndDocPrinter\n */\n\nstatic int\nSpoolssEndDocPrinter_q(tvbuff_t *tvb, int offset,\n\t\t\t\t  packet_info *pinfo, proto_tree *tree,\n\t\t\t\t  dcerpc_info *di, guint8 *drep)\n{\n\te_ctx_hnd policy_hnd;\n\tchar *pol_name;\n\n\t/* Parse packet */\n\n\toffset = dissect_nt_policy_hnd(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_hnd, &policy_hnd, NULL,\n\t\tFALSE, FALSE);\n\n\tdcerpc_fetch_polhnd_data(&policy_hnd, &pol_name, NULL, NULL, NULL,\n\t\t\t     pinfo->num);\n\n\tif (pol_name)\n\t\tcol_append_fstr(pinfo->cinfo, COL_INFO, \", %s\",\n\t\t\t\tpol_name);\n\n\n\treturn offset;\n}\n\nstatic int\nSpoolssEndDocPrinter_r(tvbuff_t *tvb, int offset,\n\t\t\t\t  packet_info *pinfo, proto_tree *tree,\n\t\t\t\t  dcerpc_info *di, guint8 *drep)\n{\n\t/* Parse packet */\n\n\toffset = dissect_doserror(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_rc, NULL);\n\n\treturn offset;\n}\n\n/*\n * WritePrinter\n */\n\nstatic gint ett_writeprinter_buffer = -1;\n\nstatic int hf_writeprinter_numwritten = -1;\n\nstatic int\nSpoolssWritePrinter_q(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\t\t proto_tree *tree, dcerpc_info *di, guint8 *drep)\n{\n\te_ctx_hnd policy_hnd;\n\tchar *pol_name;\n\tguint32 size;\n\tproto_item *item;\n\tproto_tree *subtree;\n\n\t/* Parse packet */\n\n\toffset = dissect_nt_policy_hnd(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_hnd, &policy_hnd, NULL,\n\t\tFALSE, FALSE);\n\n\tdcerpc_fetch_polhnd_data(&policy_hnd, &pol_name, NULL, NULL, NULL,\n\t\t\t     pinfo->num);\n\n\tif (pol_name)\n\t\tcol_append_fstr(pinfo->cinfo, COL_INFO, \", %s\",\n\t\t\t\tpol_name);\n\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, tree, di, drep,\n\t\t\t\t    hf_buffer_size, &size);\n\n\tcol_append_fstr(pinfo->cinfo, COL_INFO, \", %d bytes\", size);\n\n\tsubtree = proto_tree_add_subtree(tree, tvb, offset, 0, ett_writeprinter_buffer, &item, \"Buffer\");\n\n\toffset = dissect_ndr_uint8s(tvb, offset, pinfo, subtree, di, drep,\n\t\t\t\t    hf_buffer_data, size, NULL);\n\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, subtree, di, drep,\n\t\t\t\t    hf_buffer_size, NULL);\n\n\tproto_item_set_len(item, size + 4);\n\n\treturn offset;\n}\n\nstatic int\nSpoolssWritePrinter_r(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\t\t proto_tree *tree, dcerpc_info *di, guint8 *drep)\n{\n\tguint32 size;\n\n\t/* Parse packet */\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_writeprinter_numwritten,\n\t\t&size);\n\n\tcol_append_fstr(\n\t\t\tpinfo->cinfo, COL_INFO, \", %d bytes written\", size);\n\n\toffset = dissect_doserror(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_rc, NULL);\n\n\treturn offset;\n}\n\n/*\n * DeletePrinterData\n */\n\nstatic int\nSpoolssDeletePrinterData_q(tvbuff_t *tvb, int offset,\n\t\t\t\t      packet_info *pinfo, proto_tree *tree,\n\t\t\t\t      dcerpc_info *di, guint8 *drep)\n{\n\tchar *value_name;\n\tproto_item *hidden_item;\n\n\thidden_item = proto_tree_add_uint(\n\t\ttree, hf_printerdata, tvb, offset, 0, 1);\n\tPROTO_ITEM_SET_HIDDEN(hidden_item);\n\n\t/* Parse packet */\n\n\toffset = dissect_nt_policy_hnd(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_hnd, NULL, NULL,\n\t\tFALSE, FALSE);\n\n\toffset = dissect_ndr_cvstring(\n\t\ttvb, offset, pinfo, tree, di, drep, sizeof(guint16),\n\t\thf_printerdata_value, TRUE, &value_name);\n\n\tcol_append_fstr(pinfo->cinfo, COL_INFO, \", %s\", value_name);\n\n\treturn offset;\n}\n\nstatic int\nSpoolssDeletePrinterData_r(tvbuff_t *tvb, int offset,\n\t\t\t\t      packet_info *pinfo, proto_tree *tree,\n\t\t\t\t      dcerpc_info *di, guint8 *drep)\n{\n\tproto_item *hidden_item;\n\n\thidden_item = proto_tree_add_uint(\n\t\ttree, hf_printerdata, tvb, offset, 0, 1);\n\tPROTO_ITEM_SET_HIDDEN(hidden_item);\n\n\t/* Parse packet */\n\n\toffset = dissect_doserror(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_rc, NULL);\n\n\treturn offset;\n}\n\n/*\n * DRIVER_INFO_1\n */\n\nstatic gint ett_DRIVER_INFO_1 = -1;\n\nstatic int\ndissect_DRIVER_INFO_1(tvbuff_t *tvb, int offset,\n\t\t\t\t packet_info *pinfo, proto_tree *tree,\n\t\t\t\t dcerpc_info *di, guint8 *drep)\n{\n\tproto_tree *subtree;\n\tint struct_start = offset;\n\n\tsubtree = proto_tree_add_subtree(\n\t\ttree, tvb, offset, 0, ett_DRIVER_INFO_1, NULL, \"Driver info level 1\");\n\n\toffset = dissect_spoolss_relstr(\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_drivername,\n\t\tstruct_start, NULL);\n\n\treturn offset;\n}\n\n/*\n * DRIVER_INFO_2\n */\n\nstatic const value_string driverinfo_cversion_vals[] =\n{\n\t{ 0, \"Windows 95/98/Me\" },\n\t{ 2, \"Windows NT 4.0\" },\n\t{ 3, \"Windows 2000/XP\" },\n\t{ 0, NULL }\n};\n\nstatic gint ett_DRIVER_INFO_2 = -1;\n\nstatic int\ndissect_DRIVER_INFO_2(tvbuff_t *tvb, int offset,\n\t packet_info *pinfo, proto_tree *tree,\n\t dcerpc_info *di, guint8 *drep)\n{\n\tproto_tree *subtree;\n\tint struct_start = offset;\n\n\tsubtree = proto_tree_add_subtree(\n\t\t\ttree, tvb, offset, 0, ett_DRIVER_INFO_2, NULL, \"Driver info level 2\");\n\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, subtree, di, drep,\n\t\t\thf_driverinfo_cversion, NULL);\n\n\toffset = dissect_spoolss_relstr(\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_drivername,\n\t\t\tstruct_start, NULL);\n\n\toffset = dissect_spoolss_relstr(\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_environment,\n\t\t\tstruct_start, NULL);\n\n\toffset = dissect_spoolss_relstr(\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_driverpath,\n\t\t\tstruct_start, NULL);\n\n\toffset = dissect_spoolss_relstr(\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_datafile,\n\t\t\tstruct_start, NULL);\n\n\toffset = dissect_spoolss_relstr(\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_configfile,\n\t\t\tstruct_start, NULL);\n\n\treturn offset;\n}\n\n/*\n * DRIVER_INFO_3\n */\n\nstatic gint ett_DRIVER_INFO_3 = -1;\n\nstatic int\ndissect_DRIVER_INFO_3(tvbuff_t *tvb, int offset,\n\t\t\t\t packet_info *pinfo, proto_tree *tree,\n\t\t\t\t dcerpc_info *di, guint8 *drep)\n{\n\tproto_tree *subtree;\n\tint struct_start = offset;\n\n\tsubtree = proto_tree_add_subtree(\n\t\ttree, tvb, offset, 0, ett_DRIVER_INFO_3, NULL, \"Driver info level 3\");\n\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, subtree, di, drep,\n\t\t\t\t    hf_driverinfo_cversion, NULL);\n\n\toffset = dissect_spoolss_relstr(\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_drivername,\n\t\tstruct_start, NULL);\n\n\toffset = dissect_spoolss_relstr(\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_environment,\n\t\tstruct_start, NULL);\n\n\toffset = dissect_spoolss_relstr(\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_driverpath,\n\t\tstruct_start, NULL);\n\n\toffset = dissect_spoolss_relstr(\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_datafile,\n\t\tstruct_start, NULL);\n\n\toffset = dissect_spoolss_relstr(\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_configfile,\n\t\tstruct_start, NULL);\n\n\toffset = dissect_spoolss_relstr(\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_helpfile,\n\t\tstruct_start, NULL);\n\n\toffset = dissect_spoolss_relstrarray(\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_dependentfiles,\n\t\tstruct_start, NULL);\n\n\toffset = dissect_spoolss_relstr(\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_monitorname,\n\t\tstruct_start, NULL);\n\n\toffset = dissect_spoolss_relstr(\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_defaultdatatype,\n\t\tstruct_start, NULL);\n\n\treturn offset;\n}\n\n\n/*\n\tDRIVER_INFO_6\n*/\n\nstatic gint ett_DRIVER_INFO_6 = -1;\n\nstatic int\ndissect_DRIVER_INFO_6(tvbuff_t *tvb, int offset,\n\t\t\t\t packet_info *pinfo, proto_tree *tree,\n\t\t\t\t dcerpc_info *di, guint8 *drep)\n{\n\tproto_tree *subtree;\n\tint struct_start = offset;\n\n\tsubtree = proto_tree_add_subtree(\n\t\t\ttree, tvb, offset, 0, ett_DRIVER_INFO_6, NULL, \"Driver info level 6\");\n\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, subtree, di, drep,\n\t\t\thf_driverinfo_cversion, NULL);\n\n\toffset = dissect_spoolss_relstr(\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_drivername,\n\t\t\tstruct_start, NULL);\n\n\toffset = dissect_spoolss_relstr(\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_environment,\n\t\t\tstruct_start, NULL);\n\n\toffset = dissect_spoolss_relstr(\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_driverpath,\n\t\t\tstruct_start, NULL);\n\n\toffset = dissect_spoolss_relstr(\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_datafile,\n\t\t\tstruct_start, NULL);\n\n\toffset = dissect_spoolss_relstr(\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_configfile,\n\t\t\tstruct_start, NULL);\n\n\toffset = dissect_spoolss_relstr(\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_helpfile,\n\t\t\tstruct_start, NULL);\n\n\toffset = dissect_spoolss_relstrarray(\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_dependentfiles,\n\t\t\tstruct_start, NULL);\n\n\toffset = dissect_spoolss_relstr(\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_monitorname,\n\t\t\tstruct_start, NULL);\n\n\toffset = dissect_spoolss_relstr(\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_defaultdatatype,\n\t\t\tstruct_start, NULL);\n\n\toffset = dissect_spoolss_relstrarray(\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_previousdrivernames,\n\t\t\tstruct_start, NULL);\n\n\toffset = dissect_ndr_nt_NTTIME (\n\t\t\ttvb, offset, pinfo, subtree, di, drep,hf_driverdate);\n\n\toffset = dissect_ndr_uint32(\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_padding,\n\t\t\tNULL);\n\n\toffset = dissect_ndr_uint32(\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_driver_version_low,\n\t\t\tNULL);\n\n\toffset = dissect_ndr_uint32(\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_driver_version_high,\n\t\t\tNULL);\n\n\n\toffset = dissect_spoolss_relstr(\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_mfgname,\n\t\t\tstruct_start, NULL);\n\n\toffset = dissect_spoolss_relstr(\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_oemurl,\n\t\t\tstruct_start, NULL);\n\n\toffset = dissect_spoolss_relstr(\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_hardwareid,\n\t\t\tstruct_start, NULL);\n\n\toffset = dissect_spoolss_relstr(\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_provider,\n\t\t\tstruct_start, NULL);\n\n\treturn offset;\n}\n\n\nstatic gint ett_DRIVER_INFO_101 = -1;\n\nstatic int\ndissect_DRIVER_INFO_101(tvbuff_t *tvb, int offset,\n\t\t\t\t packet_info *pinfo, proto_tree *tree,\n\t\t\t\t dcerpc_info *di, guint8 *drep)\n{\n\tproto_tree *subtree;\n\tint struct_start = offset;\n\n\tsubtree = proto_tree_add_subtree(\n\t\t\ttree, tvb, offset, 0, ett_DRIVER_INFO_101, NULL, \"Driver info level 101\");\n\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, subtree, di, drep,\n\t\t\thf_driverinfo_cversion, NULL);\n\n\toffset = dissect_spoolss_relstr(\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_drivername,\n\t\t\tstruct_start, NULL);\n\n\toffset = dissect_spoolss_relstr(\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_environment,\n\t\t\tstruct_start, NULL);\n\n\tproto_tree_add_expert(subtree, pinfo, &ei_unknown_data, tvb, offset, 0);\n\n\treturn offset;\n}\n/*\n * EnumPrinterDrivers\n */\n\nstatic int\nSpoolssEnumPrinterDrivers_q(tvbuff_t *tvb, int offset,\n\t\t\t\t       packet_info *pinfo, proto_tree *tree,\n\t\t\t\t       dcerpc_info *di, guint8 *drep)\n{\n\tdcerpc_call_value *dcv = (dcerpc_call_value *)di->call_data;\n\tguint32 level;\n\n\t/* Parse packet */\n\n\toffset = dissect_ndr_str_pointer_item(\n\t\ttvb, offset, pinfo, tree, di, drep, NDR_POINTER_UNIQUE,\n\t\t\"Name\", hf_servername, 0);\n\n\toffset = dissect_ndr_str_pointer_item(\n\t\ttvb, offset, pinfo, tree, di, drep, NDR_POINTER_UNIQUE,\n\t\t\"Environment\", hf_environment, 0);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_level, &level);\n\n\t/* EnumPrinterDrivers() stores the level in se_data */\n\tif(!pinfo->fd->flags.visited){\n\t\t\tdcv->se_data = GUINT_TO_POINTER((int)level);\n\t}\n\n\tcol_append_fstr(pinfo->cinfo, COL_INFO, \", level %d\", level);\n\n\toffset = dissect_spoolss_buffer(tvb, offset, pinfo, tree, di, drep, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_offered, NULL);\n\n\treturn offset;\n}\n\nstatic int\nSpoolssEnumPrinterDrivers_r(tvbuff_t *tvb, int offset,\n\t\t\t\t       packet_info *pinfo, proto_tree *tree,\n\t\t\t\t       dcerpc_info *di, guint8 *drep)\n{\n\tdcerpc_call_value *dcv = (dcerpc_call_value *)di->call_data;\n\tguint32 level = GPOINTER_TO_UINT(dcv->se_data), num_drivers, i;\n\tint buffer_offset;\n\tBUFFER buffer;\n\n\t/* Parse packet */\n\n\toffset = dissect_spoolss_buffer(tvb, offset, pinfo, tree, di, drep,\n\t\t\t\t\t&buffer);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_needed, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_returned,\n\t\t&num_drivers);\n\n\tbuffer_offset = 0;\n\n\tfor (i = 0; i < num_drivers; i++) {\n\t\tswitch(level) {\n\t\tcase 1:\n\t\t\tbuffer_offset = dissect_DRIVER_INFO_1(\n\t\t\t\tbuffer.tvb, buffer_offset, pinfo,\n\t\t\t\tbuffer.tree, di, drep);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tbuffer_offset = dissect_DRIVER_INFO_2(\n\t\t\t\tbuffer.tvb, buffer_offset, pinfo,\n\t\t\t\tbuffer.tree, di, drep);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tbuffer_offset = dissect_DRIVER_INFO_3(\n\t\t\t\tbuffer.tvb, buffer_offset, pinfo,\n\t\t\t\tbuffer.tree, di, drep);\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tbuffer_offset = dissect_DRIVER_INFO_6(\n\t\t\t\tbuffer.tvb, buffer_offset, pinfo,\n\t\t\t\tbuffer.tree, di, drep);\n\t\t\tbreak;\n\t\tcase 101:\n\t\t\t/*buffer_offset =*/ dissect_DRIVER_INFO_101(\n\t\t\t\tbuffer.tvb, buffer_offset, pinfo,\n\t\t\t\tbuffer.tree, di, drep);\n\t\t\t/*break;*/\n\t\t\tgoto done; /*Not entirely imeplemented*/\n\t\tdefault:\n\t\t\tproto_tree_add_expert_format( buffer.tree, pinfo, &ei_driver_info_level, buffer.tvb, buffer_offset, -1, \"Unknown driver info level %d\", level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\ndone:\n\toffset = dissect_doserror(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_rc, NULL);\n\n\treturn offset;\n}\n\n/*\n * GetPrinterDriver2\n */\n\nstatic int\nSpoolssGetPrinterDriver2_q(tvbuff_t *tvb, int offset,\n\t\t\t\t      packet_info *pinfo, proto_tree *tree,\n\t\t\t\t      dcerpc_info *di, guint8 *drep)\n{\n\tdcerpc_call_value *dcv = (dcerpc_call_value *)di->call_data;\n\te_ctx_hnd policy_hnd;\n\tchar *pol_name;\n\tguint32 level;\n\n\t/* Parse packet */\n\n\toffset = dissect_nt_policy_hnd(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_hnd, &policy_hnd, NULL,\n\t\tFALSE, FALSE);\n\n\tdcerpc_fetch_polhnd_data(&policy_hnd, &pol_name, NULL, NULL, NULL,\n\t\t\t     pinfo->num);\n\n\tcol_append_fstr(pinfo->cinfo, COL_INFO, \", %s\",\n\t\t\t\tpol_name);\n\n\toffset = dissect_ndr_str_pointer_item(\n\t\ttvb, offset, pinfo, tree, di, drep, NDR_POINTER_UNIQUE,\n\t\t\"Environment\", hf_environment, 0);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_level, &level);\n\n\t/* GetPrinterDriver2() stores the level in se_data */\n\tif(!pinfo->fd->flags.visited){\n\t\t\tdcv->se_data = GUINT_TO_POINTER((int)level);\n\t}\n\n\tcol_append_fstr(pinfo->cinfo, COL_INFO, \", level %d\", level);\n\n\toffset = dissect_spoolss_buffer(tvb, offset, pinfo, tree, di, drep, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_offered, NULL);\n\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, tree, di, drep,\n\t\t\t\t    hf_clientmajorversion, NULL);\n\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, tree, di, drep,\n\t\t\t\t    hf_clientminorversion, NULL);\n\n\treturn offset;\n}\n\nstatic int\nSpoolssGetPrinterDriver2_r(tvbuff_t *tvb, int offset,\n\t\t\t\t      packet_info *pinfo, proto_tree *tree,\n\t\t\t\t      dcerpc_info *di, guint8 *drep)\n{\n\tdcerpc_call_value *dcv = (dcerpc_call_value *)di->call_data;\n\tguint32 level = GPOINTER_TO_UINT(dcv->se_data);\n\tBUFFER buffer;\n\n\t/* Parse packet */\n\n\toffset = dissect_spoolss_buffer(tvb, offset, pinfo, tree, di, drep,\n\t\t\t\t\t&buffer);\n\n\tif (buffer.tvb) {\n\t\tswitch(level) {\n\t\tcase 1:\n\t\t\tdissect_DRIVER_INFO_1(\n\t\t\t\tbuffer.tvb, 0, pinfo, buffer.tree, di, drep);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tdissect_DRIVER_INFO_2(\n\t\t\t\tbuffer.tvb, 0, pinfo, buffer.tree, di, drep);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tdissect_DRIVER_INFO_3(\n\t\t\t\tbuffer.tvb, 0, pinfo, buffer.tree, di, drep);\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tdissect_DRIVER_INFO_6(\n\t\t\t\tbuffer.tvb, 0, pinfo, buffer.tree, di, drep);\n\t\t\tbreak;\n\t\tcase 101:\n\t\t\tdissect_DRIVER_INFO_101(\n\t\t\t\tbuffer.tvb, 0, pinfo, buffer.tree, di, drep);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tproto_tree_add_expert_format( buffer.tree, pinfo, &ei_driver_info_level, buffer.tvb, 0, -1, \"Unknown driver info level %d\", level);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_needed, NULL);\n\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, tree, di, drep,\n\t\t\t\t    hf_servermajorversion, NULL);\n\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, tree, di, drep,\n\t\t\t\t    hf_serverminorversion, NULL);\n\n\toffset = dissect_doserror(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_rc, NULL);\n\n\treturn offset;\n}\n\nstatic int\ndissect_notify_info_data_buffer(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\t\tproto_tree *tree, dcerpc_info *di, guint8 *drep)\n{\n\tguint32 len;\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep,\n\t\thf_notify_info_data_buffer_len, &len);\n\n\toffset = dissect_ndr_uint16s(\n\t\ttvb, offset, pinfo, tree, di, drep,\n\t\thf_notify_info_data_buffer_data, len);\n\n\treturn offset;\n}\n\nstatic void\ncb_notify_str_postprocess(packet_info *pinfo _U_,\n\t\t\t\t      proto_tree *tree _U_,\n\t\t\t\t      proto_item *item, dcerpc_info *di _U_, tvbuff_t *tvb,\n\t\t\t\t      int start_offset, int end_offset,\n\t\t\t\t      void *callback_args)\n{\n\tgint levels, hf_index = GPOINTER_TO_INT(callback_args);\n\tguint32 len;\n\tchar *s;\n\tproto_item *hidden_item;\n\n\t/* Align start_offset on 4-byte boundary. */\n\n\tif (start_offset % 4)\n\t\tstart_offset += 4 - (start_offset % 4);\n\n\t/* Get string length */\n\n\tlen = tvb_get_letohl(tvb, start_offset);\n\n\ts = tvb_get_string_enc(NULL,\n\t\ttvb, start_offset + 4, (end_offset - start_offset - 4), ENC_UTF_16|ENC_LITTLE_ENDIAN);\n\n\t/* Append string to upper-level proto_items */\n\n\tlevels = 2;\n\n\tif (levels > 0 && item && s && s[0]) {\n\t\tproto_item_append_text(item, \": %s\", s);\n\t\titem = item->parent;\n\t\tlevels--;\n\t\tif (levels > 0) {\n\t\t\tproto_item_append_text(item, \": %s\", s);\n\t\t\titem = item->parent;\n\t\t\tlevels--;\n\t\t\twhile (levels > 0) {\n\t\t\t\tproto_item_append_text(item, \" %s\", s);\n\t\t\t\titem = item->parent;\n\t\t\t\tlevels--;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Add hidden field so filter brings up any notify data */\n\n\tif (hf_index != -1) {\n\t\thidden_item = proto_tree_add_string(\n\t\t\ttree, hf_index, tvb, start_offset, len, s);\n\t\tPROTO_ITEM_SET_HIDDEN(hidden_item);\n\t}\n\n\tg_free(s);\n}\n\n/* Return the hf_index for a printer notify field.  This is used to\n   add a hidden string to the display so that filtering will bring\n   up relevant notify data. */\n\nstatic int\nprinter_notify_hf_index(int field)\n{\n\tint result = -1;\n\n\tswitch(field) {\n\tcase PRINTER_NOTIFY_SERVER_NAME:\n\t\tresult = hf_servername;\n\t\tbreak;\n\tcase PRINTER_NOTIFY_PRINTER_NAME:\n\t\tresult = hf_printername;\n\t\tbreak;\n\tcase PRINTER_NOTIFY_SHARE_NAME:\n\t\tresult = hf_sharename;\n\t\tbreak;\n\tcase PRINTER_NOTIFY_PORT_NAME:\n\t\tresult = hf_portname;\n\t\tbreak;\n\tcase PRINTER_NOTIFY_DRIVER_NAME:\n\t\tresult = hf_drivername;\n\t\tbreak;\n\tcase PRINTER_NOTIFY_COMMENT:\n\t\tresult = hf_printercomment;\n\t\tbreak;\n\tcase PRINTER_NOTIFY_LOCATION:\n\t\tresult = hf_printerlocation;\n\t\tbreak;\n\tcase PRINTER_NOTIFY_SEPFILE:\n\t\tresult = hf_sepfile;\n\t\tbreak;\n\tcase PRINTER_NOTIFY_PRINT_PROCESSOR:\n\t\tresult = hf_printprocessor;\n\t\tbreak;\n\tcase PRINTER_NOTIFY_PARAMETERS:\n\t\tresult = hf_parameters;\n\t\tbreak;\n\tcase PRINTER_NOTIFY_DATATYPE:\n\t\tresult = hf_parameters;\n\t\tbreak;\n\t}\n\n\treturn result;\n}\n\nstatic int\njob_notify_hf_index(int field)\n{\n\tint result = -1;\n\n\tswitch(field) {\n\tcase JOB_NOTIFY_PRINTER_NAME:\n\t\tresult = hf_printername;\n\t\tbreak;\n\tcase JOB_NOTIFY_MACHINE_NAME:\n\t\tresult = hf_machinename;\n\t\tbreak;\n\tcase JOB_NOTIFY_PORT_NAME:\n\t\tresult = hf_portname;\n\t\tbreak;\n\tcase JOB_NOTIFY_USER_NAME:\n\t\tresult = hf_username;\n\t\tbreak;\n\tcase JOB_NOTIFY_NOTIFY_NAME:\n\t\tresult = hf_notifyname;\n\t\tbreak;\n\tcase JOB_NOTIFY_DATATYPE:\n\t\tresult = hf_datatype;\n\t\tbreak;\n\tcase JOB_NOTIFY_PRINT_PROCESSOR:\n\t\tresult = hf_printprocessor;\n\t\tbreak;\n\tcase JOB_NOTIFY_DRIVER_NAME:\n\t\tresult = hf_drivername;\n\t\tbreak;\n\tcase JOB_NOTIFY_DOCUMENT:\n\t\tresult = hf_documentname;\n\t\tbreak;\n\tcase JOB_NOTIFY_PRIORITY:\n\t\tresult = hf_job_priority;\n\t\tbreak;\n\tcase JOB_NOTIFY_POSITION:\n\t\tresult = hf_job_position;\n\t\tbreak;\n\tcase JOB_NOTIFY_TOTAL_PAGES:\n\t\tresult = hf_job_totalpages;\n\t\tbreak;\n\tcase JOB_NOTIFY_PAGES_PRINTED:\n\t\tresult = hf_job_pagesprinted;\n\t\tbreak;\n\tcase JOB_NOTIFY_TOTAL_BYTES:\n\t\tresult = hf_job_totalbytes;\n\t\tbreak;\n\tcase JOB_NOTIFY_BYTES_PRINTED:\n\t\tresult = hf_job_bytesprinted;\n\t\tbreak;\n\t}\n\n\treturn result;\n}\n\nstatic int\ndissect_NOTIFY_INFO_DATA_printer(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\t\t proto_tree *tree, proto_item *item,\n\t\t\t\t dcerpc_info *di, guint8 *drep, guint16 field)\n{\n\tguint32 value1;\n\n\tswitch (field) {\n\n\t\t/* String notify data */\n\n\tcase PRINTER_NOTIFY_SERVER_NAME:\n\tcase PRINTER_NOTIFY_PRINTER_NAME:\n\tcase PRINTER_NOTIFY_SHARE_NAME:\n\tcase PRINTER_NOTIFY_DRIVER_NAME:\n\tcase PRINTER_NOTIFY_COMMENT:\n\tcase PRINTER_NOTIFY_LOCATION:\n\tcase PRINTER_NOTIFY_SEPFILE:\n\tcase PRINTER_NOTIFY_PRINT_PROCESSOR:\n\tcase PRINTER_NOTIFY_PARAMETERS:\n\tcase PRINTER_NOTIFY_DATATYPE:\n\tcase PRINTER_NOTIFY_PORT_NAME:\n\n\t\toffset = dissect_ndr_uint32(\n\t\t\ttvb, offset, pinfo, tree, di, drep,\n\t\t\thf_notify_info_data_bufsize, &value1);\n\n\t\toffset = dissect_ndr_pointer_cb(\n\t\t\ttvb, offset, pinfo, tree, di, drep,\n\t\t\tdissect_notify_info_data_buffer,\n\t\t\tNDR_POINTER_UNIQUE, \"String\",\n\t\t\thf_notify_info_data_buffer,\n\t\t\tcb_notify_str_postprocess,\n\t\t\tGINT_TO_POINTER(printer_notify_hf_index(field)));\n\n\t\tbreak;\n\n\tcase PRINTER_NOTIFY_ATTRIBUTES:\n\n\t\t/* Value 1 is the printer attributes */\n\n\t\toffset = dissect_printer_attributes(\n\t\t\ttvb, offset, pinfo, tree, di, drep);\n\n\t\toffset = dissect_ndr_uint32(\n\t\t\ttvb, offset, pinfo, NULL, di, drep,\n\t\t\thf_notify_info_data_value2, NULL);\n\n\t\tbreak;\n\n\tcase PRINTER_NOTIFY_STATUS: {\n\t\tguint32 status;\n\n\t\t/* Value 1 is the printer status */\n\n \t\toffset = dissect_ndr_uint32(\n\t\t\ttvb, offset, pinfo, tree, di, drep,\n\t\t\thf_printer_status, &status);\n\n\t\toffset = dissect_ndr_uint32(\n\t\t\ttvb, offset, pinfo, NULL, di, drep,\n\t\t\thf_notify_info_data_value2, NULL);\n\n\t\tproto_item_append_text(\n\t\t\titem, \": %s\",\n\t\t\tval_to_str_ext_const(status, &printer_status_vals_ext, \"Unknown\"));\n\n\t\tbreak;\n\t}\n\n\t\t/* Unknown notify data */\n\n\tcase PRINTER_NOTIFY_SECURITY_DESCRIPTOR: /* Secdesc */\n\tcase PRINTER_NOTIFY_DEVMODE: /* Devicemode */\n\n\t\toffset = dissect_ndr_uint32(\n\t\t\ttvb, offset, pinfo, tree, di, drep,\n\t\t\thf_notify_info_data_bufsize, &value1);\n\n\t\toffset = dissect_ndr_pointer(\n\t\t\ttvb, offset, pinfo, tree, di, drep,\n\t\t\tdissect_notify_info_data_buffer,\n\t\t\tNDR_POINTER_UNIQUE, \"Buffer\",\n\t\t\thf_notify_info_data_buffer);\n\n\t\tbreak;\n\n\tdefault:\n\t\toffset = dissect_ndr_uint32(\n\t\t\ttvb, offset, pinfo, tree, di, drep,\n\t\t\thf_notify_info_data_value1, NULL);\n\n\t\toffset = dissect_ndr_uint32(\n\t\t\ttvb, offset, pinfo, tree, di, drep,\n\t\t\thf_notify_info_data_value2, NULL);\n\n\t\tbreak;\n\t}\n\treturn offset;\n}\n\nstatic void\nnotify_job_time_cb(packet_info *pinfo _U_, proto_tree *tree _U_,\n\t\t\t       proto_item *item, dcerpc_info *di, tvbuff_t *tvb _U_,\n\t\t\t       int start_offset _U_, int end_offset _U_,\n\t\t\t       void *callback_args _U_)\n{\n\tdcerpc_call_value *dcv = (dcerpc_call_value *)di->call_data;\n\tchar *str = (char *)dcv->private_data;\n\n\t/* Append job string stored in dcv->private_data by\n\t   dissect_SYSTEM_TIME_ptr() in the current item as well\n\t   as the parent. */\n\n\tproto_item_append_text(item, \": %s\", str);\n\n\tif (item)\n\t\tproto_item_append_text(item->parent, \": %s\", str);\n}\n\nstatic int\ndissect_NOTIFY_INFO_DATA_job(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\t     proto_tree *tree, proto_item *item, dcerpc_info *di, guint8 *drep,\n\t\t\t     guint16 field)\n{\n\tguint32 value1;\n\tproto_item *hidden_item;\n\n\tswitch (field) {\n\n\t\t/* String notify data */\n\n\tcase JOB_NOTIFY_PRINTER_NAME:\n\tcase JOB_NOTIFY_MACHINE_NAME:\n\tcase JOB_NOTIFY_PORT_NAME:\n\tcase JOB_NOTIFY_USER_NAME:\n\tcase JOB_NOTIFY_NOTIFY_NAME:\n\tcase JOB_NOTIFY_DATATYPE:\n\tcase JOB_NOTIFY_PRINT_PROCESSOR:\n\tcase JOB_NOTIFY_PARAMETERS:\n\tcase JOB_NOTIFY_DRIVER_NAME:\n\tcase JOB_NOTIFY_STATUS_STRING:\n\tcase JOB_NOTIFY_DOCUMENT:\n\n\t\toffset = dissect_ndr_uint32(\n\t\t\ttvb, offset, pinfo, tree, di, drep,\n\t\t\thf_notify_info_data_bufsize, &value1);\n\n\t\toffset = dissect_ndr_pointer_cb(\n\t\t\ttvb, offset, pinfo, tree, di, drep,\n\t\t\tdissect_notify_info_data_buffer,\n\t\t\tNDR_POINTER_UNIQUE, \"String\",\n\t\t\thf_notify_info_data_buffer,\n\t\t\tcb_notify_str_postprocess,\n\t\t\tGINT_TO_POINTER(job_notify_hf_index(field)));\n\n\t\tbreak;\n\n\tcase JOB_NOTIFY_STATUS:\n\t\toffset = dissect_job_status(\n\t\t\ttvb, offset, pinfo, tree, di, drep);\n\n\t\toffset = dissect_ndr_uint32(\n\t\t\ttvb, offset, pinfo, NULL, di, drep,\n\t\t\thf_notify_info_data_value2, NULL);\n\n\t\tbreak;\n\n\tcase JOB_NOTIFY_SUBMITTED:\n\n\t\t/* SYSTEM_TIME */\n\n\t\toffset = dissect_ndr_uint32(\n\t\t\ttvb, offset, pinfo, tree, di, drep,\n\t\t\thf_notify_info_data_buffer_len, NULL);\n\n\t\toffset = dissect_ndr_pointer_cb(\n\t\t\ttvb, offset, pinfo, tree, di, drep,\n\t\t\tdissect_SYSTEM_TIME_ptr, NDR_POINTER_UNIQUE,\n\t\t\t\"Time submitted\", -1, notify_job_time_cb, NULL);\n\n\t\tbreak;\n\n\tcase JOB_NOTIFY_PRIORITY:\n\tcase JOB_NOTIFY_POSITION:\n\tcase JOB_NOTIFY_TOTAL_PAGES:\n\tcase JOB_NOTIFY_PAGES_PRINTED:\n\tcase JOB_NOTIFY_TOTAL_BYTES:\n\tcase JOB_NOTIFY_BYTES_PRINTED: {\n\t\tguint32 value;\n\n\t\toffset = dissect_ndr_uint32(\n\t\t\ttvb, offset, pinfo, tree, di, drep,\n\t\t\thf_notify_info_data_value1, &value);\n\n\t\toffset = dissect_ndr_uint32(\n\t\t\ttvb, offset, pinfo, tree, di, drep,\n\t\t\thf_notify_info_data_value2, NULL);\n\n\t\tproto_item_append_text(item, \": %d\", value);\n\n\t\thidden_item = proto_tree_add_uint(\n\t\t\ttree, job_notify_hf_index(field), tvb,\n\t\t\toffset, 4, value);\n\t\tPROTO_ITEM_SET_HIDDEN(hidden_item);\n\n\t\tbreak;\n\t}\n\n\t\t/* Unknown notify data */\n\n\tcase JOB_NOTIFY_DEVMODE:\n\n\t\toffset = dissect_ndr_uint32(\n\t\t\ttvb, offset, pinfo, tree, di, drep,\n\t\t\thf_notify_info_data_bufsize, &value1);\n\n\t\toffset = dissect_ndr_pointer(\n\t\t\ttvb, offset, pinfo, tree, di, drep,\n\t\t\tdissect_notify_info_data_buffer,\n\t\t\tNDR_POINTER_UNIQUE, \"Buffer\",\n\t\t\thf_notify_info_data_buffer);\n\n\t\tbreak;\n\n\tdefault:\n\t\toffset = dissect_ndr_uint32(\n\t\t\ttvb, offset, pinfo, tree, di, drep,\n\t\t\thf_notify_info_data_value1, NULL);\n\n\t\toffset = dissect_ndr_uint32(\n\t\t\ttvb, offset, pinfo, tree, di, drep,\n\t\t\thf_notify_info_data_value2, NULL);\n\t}\n\treturn offset;\n}\n\nstatic gint ett_NOTIFY_INFO_DATA = -1;\n\nstatic int\ndissect_NOTIFY_INFO_DATA(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\t proto_tree *tree, dcerpc_info *di, guint8 *drep)\n{\n\tproto_item *item;\n\tproto_tree *subtree;\n\tguint32 count;\n\tguint16 type, field;\n\tconst char *field_string;\n\n\tsubtree = proto_tree_add_subtree(tree, tvb, offset, 0, ett_NOTIFY_INFO_DATA, &item, \"\");\n\n\toffset = dissect_ndr_uint16(\n\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\thf_notify_info_data_type, &type);\n\n\toffset = dissect_notify_field(\n\t\ttvb, offset, pinfo, subtree, di, drep, type, &field);\n\n\tswitch(type) {\n\tcase PRINTER_NOTIFY_TYPE:\n\t\tfield_string = val_to_str_ext(\n\t\t\tfield, &printer_notify_option_data_vals_ext,\n\t\t\t\"Unknown (%d)\");\n\t\tbreak;\n\tcase JOB_NOTIFY_TYPE:\n\t\tfield_string = val_to_str_ext(\n\t\t\tfield, &job_notify_option_data_vals_ext,\n\t\t\t\"Unknown (%d)\");\n\t\tbreak;\n\tdefault:\n\t\tfield_string = \"Unknown field\";\n\t\tbreak;\n\t}\n\n\tproto_item_append_text(\n\t\titem, \"%s, %s\",\n\t\tval_to_str(type, printer_notify_types, \"Unknown (%d)\"),\n\t\tfield_string);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\thf_notify_info_data_count, &count);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\thf_notify_info_data_id, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\thf_notify_info_data_count, NULL);\n\n\t/* The value here depends on (type, field) */\n\n\tswitch (type) {\n\tcase PRINTER_NOTIFY_TYPE:\n\t\toffset = dissect_NOTIFY_INFO_DATA_printer(\n\t\t\ttvb, offset, pinfo, subtree, item, di, drep, field);\n\t\tbreak;\n\tcase JOB_NOTIFY_TYPE:\n\t\toffset = dissect_NOTIFY_INFO_DATA_job(\n\t\t\ttvb, offset, pinfo, subtree, item, di, drep, field);\n\t\tbreak;\n\tdefault:\n\t\texpert_add_info(pinfo, item, &ei_notify_info_data_type);\n\t\tbreak;\n\t}\n\n\treturn offset;\n}\n\nstatic int\ndissect_NOTIFY_INFO(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t    proto_tree *tree, dcerpc_info *di, guint8 *drep)\n{\n\tguint32 count;\n\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, tree, di, drep,\n\t\t\t\t    hf_notify_info_version, NULL);\n\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, tree, di, drep,\n\t\t\t\t    hf_notify_info_flags, NULL);\n\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, tree, di, drep,\n\t\t\t\t    hf_notify_info_count, &count);\n\n\tif (!di->conformant_run)\n\t\tcol_append_fstr(\n\t\t\tpinfo->cinfo, COL_INFO, \", %d %s\", count,\n\t\t\tnotify_plural(count));\n\n\toffset = dissect_ndr_ucarray(tvb, offset, pinfo, tree, di, drep,\n\t\t\t\t     dissect_NOTIFY_INFO_DATA);\n\n\treturn offset;\n}\n\n/*\n * RFNPCNEX\n */\n\nstatic int\nSpoolssRFNPCNEX_q(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\t     proto_tree *tree, dcerpc_info *di, guint8 *drep)\n{\n\tguint32 changeid;\n\n\t/* Parse packet */\n\n\toffset = dissect_nt_policy_hnd(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_hnd, NULL, NULL,\n\t\tFALSE, FALSE);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_rrpcn_changelow, &changeid);\n\n\tcol_append_fstr(\n\t\t\tpinfo->cinfo, COL_INFO, \", changeid %d\", changeid);\n\n\toffset = dissect_ndr_pointer(\n\t\ttvb, offset, pinfo, tree, di, drep,\n\t\tdissect_NOTIFY_OPTIONS_ARRAY_CTR, NDR_POINTER_UNIQUE,\n\t\t\"Notify Options Array Container\", -1);\n\n\treturn offset;\n}\n\nstatic int\nSpoolssRFNPCNEX_r(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\t     proto_tree *tree, dcerpc_info *di, guint8 *drep)\n{\n\t/* Parse packet */\n\n\toffset = dissect_ndr_pointer(\n\t\ttvb, offset, pinfo, tree, di, drep,\n\t\tdissect_NOTIFY_INFO, NDR_POINTER_UNIQUE,\n\t\t\"Notify Info\", -1);\n\n\toffset = dissect_doserror(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_rc, NULL);\n\n\treturn offset;\n}\n\n/*\n * RRPCN\n */\n\nstatic int\nSpoolssRRPCN_q(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\t  proto_tree *tree, dcerpc_info *di, guint8 *drep)\n{\n\tguint32 changeid;\n\n\t/* Parse packet */\n\n\toffset = dissect_nt_policy_hnd(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_hnd, NULL, NULL,\n\t\tFALSE, FALSE);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_rrpcn_changelow, &changeid);\n\n\tcol_append_fstr(\n\t\t\tpinfo->cinfo, COL_INFO, \", changeid %d\", changeid);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_rrpcn_changehigh, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_rrpcn_unk0, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_rrpcn_unk1, NULL);\n\n\toffset = dissect_ndr_pointer(\n\t\ttvb, offset, pinfo, tree, di, drep,\n\t\tdissect_NOTIFY_INFO, NDR_POINTER_UNIQUE,\n\t\t\"Notify Info\", -1);\n\n\t/* Notify info */\n\n\treturn offset;\n}\n\nstatic int\nSpoolssRRPCN_r(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\t  proto_tree *tree, dcerpc_info *di, guint8 *drep)\n{\n\t/* Parse packet */\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_rrpcn_unk0, NULL);\n\n\toffset = dissect_doserror(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_rc, NULL);\n\n\treturn offset;\n}\n\n/*\n * ReplyClosePrinter\n */\n\nstatic int\nSpoolssReplyClosePrinter_q(tvbuff_t *tvb, int offset,\n\t\t\t\t      packet_info *pinfo, proto_tree *tree,\n\t\t\t\t      dcerpc_info *di, guint8 *drep)\n{\n\t/* Parse packet */\n\n\toffset = dissect_nt_policy_hnd(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_hnd, NULL, NULL,\n\t\tFALSE, TRUE);\n\n\treturn offset;\n}\n\nstatic int\nSpoolssReplyClosePrinter_r(tvbuff_t *tvb, int offset,\n\t\t\t\t      packet_info *pinfo, proto_tree *tree,\n\t\t\t\t      dcerpc_info *di, guint8 *drep)\n{\n\t/* Parse packet */\n\n\toffset = dissect_nt_policy_hnd(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_hnd, NULL, NULL,\n\t\tFALSE, FALSE);\n\n\toffset = dissect_doserror(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_rc, NULL);\n\n\treturn offset;\n}\n\n/*\n * FCPN\n */\n\nstatic int\nSpoolssFCPN_q(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\tproto_tree *tree, dcerpc_info *di, guint8 *drep)\n{\n\t/* Parse packet */\n\n\toffset = dissect_nt_policy_hnd(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_hnd, NULL, NULL,\n\t\tFALSE, FALSE);\n\n\treturn offset;\n}\n\nstatic int\nSpoolssFCPN_r(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\tproto_tree *tree, dcerpc_info *di, guint8 *drep)\n{\n\t/* Parse packet */\n\n\toffset = dissect_doserror(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_rc, NULL);\n\n\treturn offset;\n}\n\n/*\n * RouterReplyPrinter\n */\n\nstatic int hf_routerreplyprinter_condition = -1;\nstatic int hf_routerreplyprinter_unknown1 = -1;\nstatic int hf_routerreplyprinter_changeid = -1;\n\nstatic int\nSpoolssRouterReplyPrinter_q(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\t\t       proto_tree *tree, dcerpc_info *di, guint8 *drep)\n{\n\t/* Parse packet */\n\n\toffset = dissect_nt_policy_hnd(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_hnd, NULL, NULL,\n\t\tFALSE, FALSE);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep,\n\t\thf_routerreplyprinter_condition, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep,\n\t\thf_routerreplyprinter_unknown1, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep,\n\t\thf_routerreplyprinter_changeid, NULL);\n\n\treturn offset;\n}\n\nstatic int\nSpoolssRouterReplyPrinter_r(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\t\t       proto_tree *tree, dcerpc_info *di, guint8 *drep)\n{\n\t/* Parse packet */\n\n\toffset = dissect_doserror(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_rc, NULL);\n\n\treturn offset;\n}\n\nstatic int hf_keybuffer_size = -1;\n\nstatic int\ndissect_spoolss_keybuffer(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\t  proto_tree *tree, dcerpc_info *di, guint8 *drep)\n{\n\tguint32 size;\n\tint end_offset;\n\n\tif (di->conformant_run)\n\t\treturn offset;\n\n\t/* Dissect size and data */\n\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, tree, di, drep,\n\t\t\t\t    hf_keybuffer_size, &size);\n\n\tend_offset = offset + (size*2);\n\tif (end_offset < offset) {\n\t\t/*\n\t\t * Overflow - make the end offset one past the end of\n\t\t * the packet data, so we throw an exception (as the\n\t\t * size is almost certainly too big).\n\t\t */\n\t\tend_offset = tvb_reported_length_remaining(tvb, offset) + 1;\n\t}\n\n\twhile (offset > 0 && offset < end_offset) {\n\t\toffset = dissect_spoolss_uint16uni(\n\t\t\ttvb, offset, pinfo, tree, drep, NULL, hf_keybuffer);\n\t}\n\n\treturn offset;\n}\n\n\nstatic int\nSpoolssEnumPrinterKey_q(tvbuff_t *tvb, int offset,\n\t\t\t\t   packet_info *pinfo, proto_tree *tree,\n\t\t\t\t   dcerpc_info *di, guint8 *drep)\n{\n\tchar *key_name;\n\n\t/* Parse packet */\n\n\toffset = dissect_nt_policy_hnd(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_hnd, NULL, NULL,\n\t\tFALSE, FALSE);\n\n\toffset = dissect_ndr_cvstring(\n\t\ttvb, offset, pinfo, tree, di, drep, sizeof(guint16),\n\t\thf_printerdata_key, TRUE, &key_name);\n\n\tif (!key_name[0])\n\t\tkey_name = \"\\\"\\\"\";\n\n\tcol_append_fstr(pinfo->cinfo, COL_INFO, \", %s\", key_name);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_needed, NULL);\n\n\treturn offset;\n}\n\nstatic int\nSpoolssEnumPrinterKey_r(tvbuff_t *tvb, int offset,\n\t\t\t\t   packet_info *pinfo, proto_tree *tree,\n\t\t\t\t   dcerpc_info *di, guint8 *drep)\n{\n\t/* Parse packet */\n\n\toffset = dissect_spoolss_keybuffer(tvb, offset, pinfo, tree, di, drep);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_needed, NULL);\n\n\toffset = dissect_doserror(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_rc, NULL);\n\n\treturn offset;\n}\n\nstatic int hf_enumprinterdataex_name_offset = -1;\nstatic int hf_enumprinterdataex_name_len = -1;\nstatic int hf_enumprinterdataex_name = -1;\nstatic int hf_enumprinterdataex_val_offset = -1;\nstatic int hf_enumprinterdataex_val_len = -1;\nstatic int hf_enumprinterdataex_val_dword_low = -1;\nstatic int hf_enumprinterdataex_val_dword_high = -1;\nstatic int hf_enumprinterdataex_value_null = -1;\nstatic int hf_enumprinterdataex_value_uint = -1;\nstatic int hf_enumprinterdataex_value_binary = -1;\nstatic int hf_enumprinterdataex_value_multi_sz = -1;\n\nstatic int\nSpoolssEnumPrinterDataEx_q(tvbuff_t *tvb, int offset,\n\t\t\t\t      packet_info *pinfo, proto_tree *tree,\n\t\t\t\t      dcerpc_info *di, guint8 *drep)\n{\n\tchar *key_name;\n\tproto_item *hidden_item;\n\n\thidden_item = proto_tree_add_uint(\n\t\ttree, hf_printerdata, tvb, offset, 0, 1);\n\tPROTO_ITEM_SET_HIDDEN(hidden_item);\n\n\t/* Parse packet */\n\n\toffset = dissect_nt_policy_hnd(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_hnd, NULL, NULL,\n\t\tFALSE, FALSE);\n\n\toffset = dissect_ndr_cvstring(\n\t\ttvb, offset, pinfo, tree, di, drep, sizeof(guint16),\n\t\thf_printerdata_key, TRUE, &key_name);\n\n\tcol_append_fstr(pinfo->cinfo, COL_INFO, \", %s\", key_name);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_offered, NULL);\n\n\treturn offset;\n}\n\nstatic gint ett_printer_enumdataex_value = -1;\n\nstatic int\ndissect_spoolss_printer_enum_values(tvbuff_t *tvb, int offset,\n\t\t\t\t    packet_info *pinfo, proto_tree *tree,\n\t\t\t\t    dcerpc_info *di, guint8 *drep)\n{\n\tguint32 start_offset = offset;\n\tguint32 name_offset, name_len, val_offset, val_len, val_type;\n\tchar *name;\n\tproto_item *item;\n\tproto_tree *subtree;\n\n\t/* Get offset of value name */\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, NULL, di, drep,\n\t\thf_enumprinterdataex_name_offset, &name_offset);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, NULL, di, drep,\n\t\thf_enumprinterdataex_name_len, &name_len);\n\n\tdissect_spoolss_uint16uni(\n\t\ttvb, start_offset + name_offset, pinfo, NULL, drep,\n\t\t&name, hf_enumprinterdataex_name);\n\n\tsubtree = proto_tree_add_subtree_format(tree, tvb, offset, 0, ett_printer_enumdataex_value, &item, \"Name: %s\", name);\n\n\tproto_tree_add_uint(subtree, hf_enumprinterdataex_name_offset, tvb, offset - 8, 4, name_offset);\n\n\tproto_tree_add_uint(subtree, hf_enumprinterdataex_name_len, tvb, offset - 4, 4, name_len);\n\n\tproto_tree_add_string( subtree, hf_enumprinterdataex_name, tvb, start_offset + name_offset, ((int)strlen(name) + 1) * 2, name);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_printerdata_type,\n\t\t&val_type);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\thf_enumprinterdataex_val_offset, &val_offset);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\thf_enumprinterdataex_val_len, &val_len);\n\n\tif (val_len == 0) {\n\t\tproto_tree_add_uint_format_value(subtree, hf_enumprinterdataex_value_null, tvb, start_offset + val_offset, 4, 0, \"(null)\");\n\t\tgoto done;\n\t}\n\n\tswitch(val_type) {\n\tcase DCERPC_REG_DWORD: {\n\t\tguint32 value;\n\t\tguint16 low, high;\n\t\tint offset2 = start_offset + val_offset;\n\n\t\t/* Needs to be broken into two 16-byte ints because it may\n\t\t   not be aligned. */\n\n\t\toffset2 = dissect_ndr_uint16(\n\t\t\ttvb, offset2, pinfo, subtree, di, drep,\n\t\t\thf_enumprinterdataex_val_dword_low, &low);\n\n\t\t/*offset2 = */dissect_ndr_uint16(\n\t\t\ttvb, offset2, pinfo, subtree, di, drep,\n\t\t\thf_enumprinterdataex_val_dword_high, &high);\n\n\t\tvalue = (high << 16) | low;\n\n\t\tproto_tree_add_uint(subtree, hf_enumprinterdataex_value_uint, tvb, start_offset + val_offset, 4, value);\n\n\t\tproto_item_append_text(item, \", Value: %d\", value);\n\n\t\tbreak;\n\t}\n\tcase DCERPC_REG_SZ: {\n\t\tchar *value;\n\n\t\tdissect_spoolss_uint16uni(\n\t\t\ttvb, start_offset + val_offset, pinfo, subtree, drep,\n\t\t\t&value, hf_value_string);\n\n\t\tproto_item_append_text(item, \", Value: %s\", value);\n\n\t\tg_free(value);\n\n\t\tbreak;\n\t}\n\tcase DCERPC_REG_BINARY:\n\n\t\t/* FIXME: nicer way to display this */\n\n\t\tproto_tree_add_bytes_format_value( subtree, hf_enumprinterdataex_value_binary, tvb, start_offset + val_offset, val_len, NULL, \"<binary data>\");\n\t\tbreak;\n\n\tcase DCERPC_REG_MULTI_SZ:\n\n\t\t/* FIXME: implement REG_MULTI_SZ support */\n\n\t\tproto_tree_add_bytes_format_value(subtree, hf_enumprinterdataex_value_multi_sz, tvb, start_offset + val_offset, val_len, NULL, \"<REG_MULTI_SZ not implemented>\");\n\t\tbreak;\n\n\tdefault:\n\t\tproto_tree_add_expert_format( subtree, pinfo, &ei_enumprinterdataex_value, tvb, start_offset + val_offset, val_len, \"%s: unknown type %d\", name, val_type);\n\t}\n\n done:\n\tg_free(name);\n\n\treturn offset;\n}\n\nstatic gint ett_PRINTER_DATA_CTR = -1;\n\nstatic int\nSpoolssEnumPrinterDataEx_r(tvbuff_t *tvb, int offset,\n\t\t\t\t   packet_info *pinfo, proto_tree *tree,\n\t\t\t\t   dcerpc_info *di, guint8 *drep)\n{\n\tguint32 size, num_values;\n\tproto_item *hidden_item;\n\n\thidden_item = proto_tree_add_uint(\n\t\ttree, hf_printerdata, tvb, offset, 0, 1);\n\tPROTO_ITEM_SET_HIDDEN(hidden_item);\n\n\t/* Parse packet */\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep,\n\t\thf_buffer_size, &size);\n\n\tdissect_ndr_uint32(\n\t\ttvb, offset + size + 4, pinfo, NULL, di, drep, hf_returned,\n\t\t&num_values);\n\n\tif (size) {\n\t\tproto_tree *subtree;\n\t\tint offset2 = offset;\n\t\tguint32 i;\n\n\t\tsubtree = proto_tree_add_subtree(\n\t\t\ttree, tvb, offset, 0, ett_PRINTER_DATA_CTR, NULL, \"Printer data\");\n\n\t\tfor (i=0; i < num_values; i++)\n\t\t\toffset2 = dissect_spoolss_printer_enum_values(\n\t\t\t\ttvb, offset2, pinfo, subtree, di, drep);\n\t}\n\n\toffset += size;\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_needed, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_returned, NULL);\n\n\toffset = dissect_doserror(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_rc, NULL);\n\n\treturn offset;\n}\n\nstatic int\nSpoolssGetPrinterDriverDirectory_q(tvbuff_t *tvb, int offset,\n\t\t\t\t      packet_info *pinfo, proto_tree *tree,\n\t\t\t\t      dcerpc_info *di, guint8 *drep)\n{\n\tguint32 level;\n\n\t/* Parse packet */\n\n\toffset = dissect_ndr_str_pointer_item(\n\t\ttvb, offset, pinfo, tree, di, drep, NDR_POINTER_UNIQUE,\n\t\t\"Name\", hf_servername, 0);\n\n\toffset = dissect_ndr_str_pointer_item(\n\t\ttvb, offset, pinfo, tree, di, drep, NDR_POINTER_UNIQUE,\n\t\t\"Environment\", hf_environment, 0);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_level, &level);\n\n\toffset = dissect_spoolss_buffer(\n\t\ttvb, offset, pinfo, tree, di, drep, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_offered, NULL);\n\n\treturn offset;\n}\n\nstatic int\nSpoolssGetPrinterDriverDirectory_r(tvbuff_t *tvb, int offset,\n\t\t\t\t      packet_info *pinfo, proto_tree *tree,\n\t\t\t\t      dcerpc_info *di, guint8 *drep)\n{\n\t/* Parse packet */\n\n\toffset = dissect_spoolss_string_parm(\n\t\ttvb, offset, pinfo, tree, di, drep, \"Directory\");\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_needed, NULL);\n\n\toffset = dissect_doserror(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_rc, NULL);\n\n\treturn offset;\n}\n\n/*\n * List of subdissectors for this pipe.\n */\n\nstatic dcerpc_sub_dissector dcerpc_spoolss_dissectors[] = {\n\t{ SPOOLSS_ENUMPRINTERS, \"EnumPrinters\",\n\t  SpoolssEnumPrinters_q, SpoolssEnumPrinters_r },\n\t{ SPOOLSS_OPENPRINTER, \"OpenPrinter\",\n\t  NULL, SpoolssGeneric_r },\n\t{ SPOOLSS_SETJOB, \"SetJob\",\n\t  SpoolssSetJob_q, SpoolssSetJob_r },\n\t{ SPOOLSS_GETJOB, \"GetJob\",\n\t  SpoolssGetJob_q, SpoolssGetJob_r },\n\t{ SPOOLSS_ENUMJOBS, \"EnumJobs\",\n\t  SpoolssEnumJobs_q, SpoolssEnumJobs_r },\n\t{ SPOOLSS_ADDPRINTER, \"AddPrinter\",\n\t  NULL, SpoolssGeneric_r },\n\t{ SPOOLSS_DELETEPRINTER, \"DeletePrinter\",\n\t  SpoolssDeletePrinter_q, SpoolssDeletePrinter_r },\n\t{ SPOOLSS_SETPRINTER, \"SetPrinter\",\n\t  SpoolssSetPrinter_q, SpoolssSetPrinter_r },\n\t{ SPOOLSS_GETPRINTER, \"GetPrinter\",\n\t  SpoolssGetPrinter_q, SpoolssGetPrinter_r },\n\t{ SPOOLSS_ADDPRINTERDRIVER, \"AddPrinterDriver\",\n\t  NULL, SpoolssAddPrinterDriver_r },\n\t{ SPOOLSS_ENUMPRINTERDRIVERS, \"EnumPrinterDrivers\",\n\t  SpoolssEnumPrinterDrivers_q, SpoolssEnumPrinterDrivers_r },\n\t{ SPOOLSS_GETPRINTERDRIVER, \"GetPrinterDriver\",\n\t  NULL, SpoolssGeneric_r },\n\t{ SPOOLSS_GETPRINTERDRIVERDIRECTORY, \"GetPrinterDriverDirectory\",\n\t  SpoolssGetPrinterDriverDirectory_q, SpoolssGetPrinterDriverDirectory_r },\n\t{ SPOOLSS_DELETEPRINTERDRIVER, \"DeletePrinterDriver\",\n\t  NULL, SpoolssGeneric_r },\n\t{ SPOOLSS_ADDPRINTPROCESSOR, \"AddPrintProcessor\",\n\t  NULL, SpoolssGeneric_r },\n\t{ SPOOLSS_ENUMPRINTPROCESSORS, \"EnumPrintProcessor\",\n\t  NULL, SpoolssGeneric_r },\n\t{ SPOOLSS_GETPRINTPROCESSORDIRECTORY, \"GetPrintProcessorDirectory\",\n\t  NULL, SpoolssGeneric_r },\n\t{ SPOOLSS_STARTDOCPRINTER, \"StartDocPrinter\",\n\t  SpoolssStartDocPrinter_q, SpoolssStartDocPrinter_r },\n\t{ SPOOLSS_STARTPAGEPRINTER, \"StartPagePrinter\",\n\t  SpoolssStartPagePrinter_q, SpoolssStartPagePrinter_r },\n\t{ SPOOLSS_WRITEPRINTER, \"WritePrinter\",\n\t  SpoolssWritePrinter_q, SpoolssWritePrinter_r },\n\t{ SPOOLSS_ENDPAGEPRINTER, \"EndPagePrinter\",\n\t  SpoolssEndPagePrinter_q, SpoolssEndPagePrinter_r },\n\t{ SPOOLSS_ABORTPRINTER, \"AbortPrinter\",\n\t  NULL, SpoolssGeneric_r },\n\t{ SPOOLSS_READPRINTER, \"ReadPrinter\",\n\t  NULL, SpoolssGeneric_r },\n\t{ SPOOLSS_ENDDOCPRINTER, \"EndDocPrinter\",\n\t  SpoolssEndDocPrinter_q, SpoolssEndDocPrinter_r },\n\t{ SPOOLSS_ADDJOB, \"AddJob\",\n\t  NULL, SpoolssGeneric_r },\n\t{ SPOOLSS_SCHEDULEJOB, \"ScheduleJob\",\n\t  NULL, SpoolssGeneric_r },\n\t{ SPOOLSS_GETPRINTERDATA, \"GetPrinterData\",\n\t  SpoolssGetPrinterData_q, SpoolssGetPrinterData_r },\n\t{ SPOOLSS_SETPRINTERDATA, \"SetPrinterData\",\n\t  SpoolssSetPrinterData_q, SpoolssSetPrinterData_r },\n\t{ SPOOLSS_WAITFORPRINTERCHANGE, \"WaitForPrinterChange\",\n\t  NULL, SpoolssGeneric_r },\n\t{ SPOOLSS_CLOSEPRINTER, \"ClosePrinter\",\n\t  SpoolssClosePrinter_q, SpoolssClosePrinter_r },\n\t{ SPOOLSS_ADDFORM, \"AddForm\",\n\t  SpoolssAddForm_q, SpoolssAddForm_r },\n\t{ SPOOLSS_DELETEFORM, \"DeleteForm\",\n\t  SpoolssDeleteForm_q, SpoolssDeleteForm_r },\n\t{ SPOOLSS_GETFORM, \"GetForm\",\n\t  SpoolssGetForm_q, SpoolssGetForm_r },\n\t{ SPOOLSS_SETFORM, \"SetForm\",\n\t  SpoolssSetForm_q, SpoolssSetForm_r },\n\t{ SPOOLSS_ENUMFORMS, \"EnumForms\",\n\t  SpoolssEnumForms_q, SpoolssEnumForms_r },\n\t{ SPOOLSS_ENUMPORTS, \"EnumPorts\",\n\t  NULL, SpoolssGeneric_r },\n\t{ SPOOLSS_ENUMMONITORS, \"EnumMonitors\",\n\t  NULL, SpoolssGeneric_r },\n\t{ SPOOLSS_ADDPORT, \"AddPort\",\n\t  NULL, SpoolssGeneric_r },\n\t{ SPOOLSS_CONFIGUREPORT, \"ConfigurePort\",\n\t  NULL, SpoolssGeneric_r },\n\t{ SPOOLSS_DELETEPORT, \"DeletePort\",\n\t  NULL, SpoolssGeneric_r },\n\t{ SPOOLSS_CREATEPRINTERIC, \"CreatePrinterIC\",\n\t  NULL, SpoolssGeneric_r },\n\t{ SPOOLSS_PLAYGDISCRIPTONPRINTERIC, \"PlayDiscriptOnPrinterIC\",\n\t  NULL, SpoolssGeneric_r },\n\t{ SPOOLSS_DELETEPRINTERIC, \"DeletePrinterIC\",\n\t  NULL, SpoolssGeneric_r },\n\t{ SPOOLSS_ADDPRINTERCONNECTION, \"AddPrinterConnection\",\n\t  NULL, SpoolssGeneric_r },\n\t{ SPOOLSS_DELETEPRINTERCONNECTION, \"DeletePrinterConnection\",\n\t  NULL, SpoolssGeneric_r },\n\t{ SPOOLSS_PRINTERMESSAGEBOX, \"PrinterMessageBox\",\n\t  NULL, SpoolssGeneric_r },\n\t{ SPOOLSS_ADDMONITOR, \"AddMonitor\",\n\t  NULL, SpoolssGeneric_r },\n\t{ SPOOLSS_DELETEMONITOR, \"DeleteMonitor\",\n\t  NULL, SpoolssGeneric_r },\n\t{ SPOOLSS_DELETEPRINTPROCESSOR, \"DeletePrintProcessor\",\n\t  NULL, SpoolssGeneric_r },\n\t{ SPOOLSS_ADDPRINTPROVIDER, \"AddPrintProvider\",\n\t  NULL, SpoolssGeneric_r },\n\t{ SPOOLSS_DELETEPRINTPROVIDER, \"DeletePrintProvider\",\n\t  NULL, SpoolssGeneric_r },\n\t{ SPOOLSS_ENUMPRINTPROCDATATYPES, \"EnumPrintProcDataTypes\",\n\t  NULL, SpoolssGeneric_r },\n\t{ SPOOLSS_RESETPRINTER, \"ResetPrinter\",\n\t  NULL, SpoolssGeneric_r },\n\t{ SPOOLSS_GETPRINTERDRIVER2, \"GetPrinterDriver2\",\n\t  SpoolssGetPrinterDriver2_q, SpoolssGetPrinterDriver2_r },\n\t{ SPOOLSS_FINDFIRSTPRINTERCHANGENOTIFICATION,\n\t  \"FindFirstPrinterChangeNotification\",\n\t  NULL, SpoolssGeneric_r },\n\t{ SPOOLSS_FINDNEXTPRINTERCHANGENOTIFICATION,\n\t  \"FindNextPrinterChangeNotification\",\n\t  NULL, SpoolssGeneric_r },\n\t{ SPOOLSS_FCPN, \"FCPN\",\n\t  SpoolssFCPN_q, SpoolssFCPN_r },\n\t{ SPOOLSS_ROUTERFINDFIRSTPRINTERNOTIFICATIONOLD,\n\t  \"RouterFindFirstPrinterNotificationOld\",\n\t  NULL, SpoolssGeneric_r },\n\t{ SPOOLSS_REPLYOPENPRINTER, \"ReplyOpenPrinter\",\n\t  SpoolssReplyOpenPrinter_q, SpoolssReplyOpenPrinter_r },\n\t{ SPOOLSS_ROUTERREPLYPRINTER, \"RouterReplyPrinter\",\n\t  SpoolssRouterReplyPrinter_q, SpoolssRouterReplyPrinter_r },\n\t{ SPOOLSS_REPLYCLOSEPRINTER, \"ReplyClosePrinter\",\n\t  SpoolssReplyClosePrinter_q, SpoolssReplyClosePrinter_r },\n\t{ SPOOLSS_ADDPORTEX, \"AddPortEx\",\n\t  NULL, SpoolssGeneric_r },\n\t{ SPOOLSS_REMOTEFINDFIRSTPRINTERCHANGENOTIFICATION,\n\t  \"RemoteFindFirstPrinterChangeNotification\",\n\t  NULL, SpoolssGeneric_r },\n\t{ SPOOLSS_SPOOLERINIT, \"SpoolerInit\",\n\t  NULL, SpoolssGeneric_r },\n\t{ SPOOLSS_RESETPRINTEREX, \"ResetPrinterEx\",\n\t  NULL, SpoolssGeneric_r },\n\t{ SPOOLSS_RFFPCNEX, \"RFFPCNEX\",\n\t  SpoolssRFFPCNEX_q, SpoolssRFFPCNEX_r },\n\t{ SPOOLSS_RRPCN, \"RRPCN\",\n\t  SpoolssRRPCN_q, SpoolssRRPCN_r },\n\t{ SPOOLSS_RFNPCNEX, \"RFNPCNEX\",\n\t  SpoolssRFNPCNEX_q, SpoolssRFNPCNEX_r },\n\t{ SPOOLSS_OPENPRINTEREX, \"OpenPrinterEx\",\n\t  SpoolssOpenPrinterEx_q, SpoolssOpenPrinterEx_r },\n\t{ SPOOLSS_ADDPRINTEREX, \"AddPrinterEx\",\n\t  NULL, SpoolssAddPrinterEx_r },\n\t{ SPOOLSS_ENUMPRINTERDATA, \"EnumPrinterData\",\n\t  SpoolssEnumPrinterData_q, SpoolssEnumPrinterData_r },\n\t{ SPOOLSS_DELETEPRINTERDATA, \"DeletePrinterData\",\n\t  SpoolssDeletePrinterData_q, SpoolssDeletePrinterData_r },\n\t{ SPOOLSS_GETPRINTERDATAEX, \"GetPrinterDataEx\",\n\t  SpoolssGetPrinterDataEx_q, SpoolssGetPrinterDataEx_r },\n\t{ SPOOLSS_SETPRINTERDATAEX, \"SetPrinterDataEx\",\n\t  SpoolssSetPrinterDataEx_q, SpoolssSetPrinterDataEx_r },\n\t{ SPOOLSS_ENUMPRINTERDATAEX, \"EnumPrinterDataEx\",\n\t  SpoolssEnumPrinterDataEx_q, SpoolssEnumPrinterDataEx_r },\n\t{ SPOOLSS_ENUMPRINTERKEY, \"EnumPrinterKey\",\n\t  SpoolssEnumPrinterKey_q, SpoolssEnumPrinterKey_r },\n\t{ SPOOLSS_DELETEPRINTERDATAEX, \"DeletePrinterDataEx\",\n\t  NULL, SpoolssGeneric_r },\n\t{ SPOOLSS_DELETEPRINTERDRIVEREX, \"DeletePrinterDriverEx\",\n\t  NULL, SpoolssGeneric_r },\n\t{ SPOOLSS_ADDPRINTERDRIVEREX, \"AddPrinterDriverEx\",\n\t  NULL, SpoolssGeneric_r },\n\n\t{ 0, NULL, NULL, NULL },\n};\n\n/*\n * Dissector initialisation function\n */\n\n/* Protocol registration */\n\nstatic int proto_dcerpc_spoolss = -1;\nstatic gint ett_dcerpc_spoolss = -1;\n\nvoid\nproto_register_dcerpc_spoolss(void)\n{\n\tstatic hf_register_info hf[] = {\n\n\t\t/* GetPrinterDriver2 */\n\n\t\t{ &hf_clientmajorversion,\n\t\t  { \"Client major version\", \"spoolss.clientmajorversion\", FT_UINT32, BASE_DEC,\n\t\t    NULL, 0x0, \"Client printer driver major version\", HFILL }},\n\t\t{ &hf_clientminorversion,\n\t\t  { \"Client minor version\", \"spoolss.clientminorversion\", FT_UINT32, BASE_DEC,\n\t\t    NULL, 0x0, \"Client printer driver minor version\", HFILL }},\n\t\t{ &hf_servermajorversion,\n\t\t  { \"Server major version\", \"spoolss.servermajorversion\", FT_UINT32, BASE_DEC,\n\t\t    NULL, 0x0, \"Server printer driver major version\", HFILL }},\n\t\t{ &hf_serverminorversion,\n\t\t  { \"Server minor version\", \"spoolss.serverminorversion\", FT_UINT32, BASE_DEC,\n\t\t    NULL, 0x0, \"Server printer driver minor version\", HFILL }},\n\t\t{ &hf_driverpath,\n\t\t  { \"Driver path\", \"spoolss.driverpath\", FT_STRING, BASE_NONE,\n\t\t    NULL, 0, NULL, HFILL }},\n\t\t{ &hf_datafile,\n\t\t  { \"Data file\", \"spoolss.datafile\", FT_STRING, BASE_NONE,\n\t\t    NULL, 0, NULL, HFILL }},\n\t\t{ &hf_configfile,\n\t\t  { \"Config file\", \"spoolss.configfile\", FT_STRING, BASE_NONE,\n\t\t    NULL, 0, \"Printer name\", HFILL }},\n\t\t{ &hf_helpfile,\n\t\t  { \"Help file\", \"spoolss.helpfile\", FT_STRING, BASE_NONE,\n\t\t    NULL, 0, NULL, HFILL }},\n\t\t{ &hf_monitorname,\n\t\t  { \"Monitor name\", \"spoolss.monitorname\", FT_STRING, BASE_NONE,\n\t\t    NULL, 0, NULL, HFILL }},\n\t\t{ &hf_defaultdatatype,\n\t\t  { \"Default data type\", \"spoolss.defaultdatatype\", FT_STRING, BASE_NONE,\n\t\t    NULL, 0, NULL, HFILL }},\n\t\t{ &hf_driverinfo_cversion,\n\t\t  { \"Driver version\", \"spoolss.driverversion\", FT_UINT32, BASE_DEC,\n\t\t    VALS(driverinfo_cversion_vals), 0, \"Printer name\", HFILL }},\n\t\t{ &hf_dependentfiles,\n\t\t  { \"Dependent files\", \"spoolss.dependentfiles\", FT_STRING, BASE_NONE,\n\t\t    NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_printer_status,\n\t\t  { \"Status\", \"spoolss.printer_status\", FT_UINT32, BASE_DEC|BASE_EXT_STRING,\n\t\t    &printer_status_vals_ext, 0, NULL, HFILL }},\n\n\t\t{ &hf_previousdrivernames,\n\t\t  { \"Previous Driver Names\", \"spoolss.previousdrivernames\", FT_STRING, BASE_NONE,\n\t\t    NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_driverdate,\n\t\t  { \"Driver Date\", \"spoolss.driverdate\", FT_ABSOLUTE_TIME, ABSOLUTE_TIME_LOCAL,\n\t\t    NULL, 0, \"Date of driver creation\", HFILL }},\n\n\t\t{ &hf_padding,\n\t\t  { \"Padding\", \"spoolss.padding\", FT_UINT32, BASE_HEX,\n\t\t    NULL, 0, \"Some padding - conveys no semantic information\", HFILL }},\n\n\t\t{ &hf_driver_version_low,\n\t\t  { \"Minor Driver Version\", \"spoolss.minordriverversion\", FT_UINT32, BASE_DEC,\n\t\t    NULL, 0, \"Driver Version Low\", HFILL }},\n\n\t\t{ &hf_driver_version_high,\n\t\t  { \"Major Driver Version\", \"spoolss.majordriverversion\", FT_UINT32, BASE_DEC,\n\t\t    NULL, 0, \"Driver Version High\", HFILL }},\n\n\t\t{ &hf_mfgname,\n\t\t  { \"Mfgname\", \"spoolss.mfgname\", FT_STRING, BASE_NONE,\n\t\t    NULL, 0, \"Manufacturer Name\", HFILL }},\n\n\t\t{ &hf_oemurl,\n\t\t  { \"OEM URL\", \"spoolss.oemrul\", FT_STRING, BASE_NONE,\n\t\t    NULL, 0, \"OEM URL - Website of Vendor\", HFILL }},\n\n\t\t{ &hf_hardwareid,\n\t\t  { \"Hardware ID\", \"spoolss.hardwareid\", FT_STRING, BASE_NONE,\n\t\t    NULL, 0, \"Hardware Identification Information\", HFILL }},\n\n\t   \t{ &hf_provider,\n\t   \t  { \"Provider\", \"spoolss.provider\", FT_STRING, BASE_NONE,\n\t\t    NULL, 0, \"Provider of Driver\", HFILL }},\n\n\t\t/* Setprinter RPC */\n\n\t\t{ &hf_setprinter_cmd,\n\t\t  { \"Command\", \"spoolss.setprinter_cmd\", FT_UINT32, BASE_DEC,\n\t\t   VALS(setprinter_cmd_vals), 0, NULL, HFILL }},\n\n\t\t/* Enumprinters */\n\n\t\t{ &hf_enumprinters_flags,\n\t\t  { \"Flags\", \"spoolss.enumprinters.flags\",\n\t\t    FT_UINT32, BASE_HEX, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_enumprinters_flags_local,\n\t\t  { \"Enum local\", \"spoolss.enumprinters.flags.enum_local\",\n\t\t    FT_BOOLEAN, 32, TFS(&tfs_set_notset),\n\t\t    PRINTER_ENUM_LOCAL, NULL, HFILL }},\n\n\t\t{ &hf_enumprinters_flags_name,\n\t\t  { \"Enum name\", \"spoolss.enumprinters.flags.enum_name\",\n\t\t    FT_BOOLEAN, 32, TFS(&tfs_set_notset),\n\t\t    PRINTER_ENUM_NAME, NULL, HFILL }},\n\n\t\t{ &hf_enumprinters_flags_shared,\n\t\t  { \"Enum shared\", \"spoolss.enumprinters.flags.enum_shared\",\n\t\t    FT_BOOLEAN, 32, TFS(&tfs_set_notset),\n\t\t    PRINTER_ENUM_SHARED, NULL, HFILL }},\n\n\t\t{ &hf_enumprinters_flags_default,\n\t\t  { \"Enum default\", \"spoolss.enumprinters.flags.enum_default\",\n\t\t    FT_BOOLEAN, 32, TFS(&tfs_set_notset),\n\t\t    PRINTER_ENUM_DEFAULT, NULL, HFILL }},\n\n\t\t{ &hf_enumprinters_flags_connections,\n\t\t  { \"Enum connections\", \"spoolss.enumprinters.flags.enum_connections\",\n\t\t    FT_BOOLEAN, 32, TFS(&tfs_set_notset),\n\t\t    PRINTER_ENUM_CONNECTIONS, NULL, HFILL }},\n\n\t\t{ &hf_enumprinters_flags_network,\n\t\t  { \"Enum network\", \"spoolss.enumprinters.flags.enum_network\",\n\t\t    FT_BOOLEAN, 32, TFS(&tfs_set_notset),\n\t\t    PRINTER_ENUM_NETWORK, NULL, HFILL }},\n\n\t\t{ &hf_enumprinters_flags_remote,\n\t\t  { \"Enum remote\", \"spoolss.enumprinters.flags.enum_remote\",\n\t\t    FT_BOOLEAN, 32, TFS(&tfs_set_notset),\n\t\t    PRINTER_ENUM_REMOTE, NULL, HFILL }},\n\n\t\t/* GetPrinter */\n\n\t\t{ &hf_start_time,\n\t\t  { \"Start time\", \"spoolss.start_time\",\n\t\t    FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_end_time,\n\t\t  { \"End time\", \"spoolss.end_time\",\n\t\t    FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_elapsed_time,\n\t\t  { \"Elapsed time\", \"spoolss.elapsed_time\",\n\t\t    FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t/*\n\t\t * New hf index values\n\t\t */\n\n\t\t{ &hf_opnum,\n\t\t  { \"Operation\", \"spoolss.opnum\", FT_UINT16, BASE_DEC,\n\t\t    NULL, 0x0, NULL, HFILL }},\n\n\t\t{ &hf_hnd,\n\t\t  { \"Context handle\", \"spoolss.hnd\", FT_BYTES, BASE_NONE,\n\t\t    NULL, 0x0, \"SPOOLSS policy handle\", HFILL }},\n\n\t\t{ &hf_rc,\n\t\t  { \"Return code\", \"spoolss.rc\", FT_UINT32, BASE_HEX | BASE_EXT_STRING,\n\t\t    &DOS_errors_ext, 0x0, \"SPOOLSS return code\", HFILL }},\n\n\t\t{ &hf_offered,\n\t\t  { \"Offered\", \"spoolss.offered\", FT_UINT32, BASE_DEC,\n\t\t    NULL, 0x0, \"Size of buffer offered in this request\",\n\t\t    HFILL }},\n\n\t\t{ &hf_needed,\n\t\t  { \"Needed\", \"spoolss.needed\", FT_UINT32, BASE_DEC,\n\t\t    NULL, 0x0, \"Size of buffer required for request\", HFILL }},\n\n\t\t{ &hf_returned,\n\t\t  { \"Returned\", \"spoolss.returned\", FT_UINT32, BASE_DEC,\n\t\t    NULL, 0x0, \"Number of items returned\", HFILL }},\n\n\t\t{ &hf_buffer_size,\n\t\t  { \"Buffer size\", \"spoolss.buffer.size\", FT_UINT32, BASE_DEC,\n\t\t    NULL, 0x0, \"Size of buffer\", HFILL }},\n\n\t\t{ &hf_buffer_data,\n\t\t  { \"Buffer data\", \"spoolss.buffer.data\", FT_BYTES, BASE_NONE,\n\t\t    NULL, 0x0, \"Contents of buffer\", HFILL }},\n\n\t\t{ &hf_string_parm_size,\n\t\t  { \"String buffer size\", \"spoolss.string.buffersize\", FT_UINT32, BASE_DEC,\n\t\t    NULL, 0x0, \"Size of string buffer\", HFILL }},\n\n\t\t{ &hf_string_parm_data,\n\t\t  { \"String data\", \"spoolss.string.data\", FT_STRINGZ, BASE_NONE,\n\t\t    NULL, 0x0, \"Contents of string\", HFILL }},\n\n\t\t{ &hf_offset,\n\t\t  { \"Offset\", \"spoolss.offset\", FT_UINT32, BASE_DEC,\n\t\t    NULL, 0x0, \"Offset of data\", HFILL }},\n\n\t\t{ &hf_level,\n\t\t  { \"Info level\", \"spoolss.enumjobs.level\", FT_UINT32,\n\t\t    BASE_DEC, NULL, 0x0, NULL, HFILL }},\n\n\n\t\t{ &hf_printername,\n\t\t  { \"Printer name\", \"spoolss.printername\", FT_STRING,\n\t\t    BASE_NONE, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_machinename,\n\t\t  { \"Machine name\", \"spoolss.machinename\", FT_STRING,\n\t\t    BASE_NONE, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_notifyname,\n\t\t  { \"Notify name\", \"spoolss.notifyname\", FT_STRING,\n\t\t    BASE_NONE, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_printerdesc,\n\t\t  { \"Printer description\", \"spoolss.printerdesc\", FT_STRING,\n\t\t    BASE_NONE, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_printercomment,\n\t\t  { \"Printer comment\", \"spoolss.printercomment\", FT_STRING,\n\t\t    BASE_NONE, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_servername,\n\t\t  { \"Server name\", \"spoolss.servername\", FT_STRING, BASE_NONE,\n\t\t    NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_sharename,\n\t\t  { \"Share name\", \"spoolss.sharename\", FT_STRING, BASE_NONE,\n\t\t    NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_portname,\n\t\t  { \"Port name\", \"spoolss.portname\", FT_STRING, BASE_NONE,\n\t\t    NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_printerlocation,\n\t\t  { \"Printer location\", \"spoolss.printerlocation\", FT_STRING,\n\t\t    BASE_NONE, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_environment,\n\t\t  { \"Environment name\", \"spoolss.environment\", FT_STRING,\n\t\t    BASE_NONE, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_drivername,\n\t\t  { \"Driver name\", \"spoolss.drivername\", FT_STRING, BASE_NONE,\n\t\t    NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_username,\n\t\t  { \"User name\", \"spoolss.username\", FT_STRING, BASE_NONE,\n\t\t    NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_documentname,\n\t\t  { \"Document name\", \"spoolss.document\", FT_STRING, BASE_NONE,\n\t\t    NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_outputfile,\n\t\t  { \"Output file\", \"spoolss.outputfile\", FT_STRING, BASE_NONE,\n\t\t    NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_datatype,\n\t\t  { \"Datatype\", \"spoolss.datatype\", FT_STRING, BASE_NONE,\n\t\t    NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_textstatus,\n\t\t  { \"Text status\", \"spoolss.textstatus\", FT_STRING, BASE_NONE,\n\t\t    NULL, 0, NULL, HFILL }},\n\n \t\t{ &hf_sepfile,\n\t\t  { \"Separator file\", \"spoolss.setpfile\", FT_STRING, BASE_NONE,\n\t\t    NULL, 0, NULL, HFILL }},\n\n \t\t{ &hf_parameters,\n\t\t  { \"Parameters\", \"spoolss.parameters\", FT_STRING, BASE_NONE,\n\t\t    NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_printprocessor,\n\t\t  { \"Print processor\", \"spoolss.printprocessor\", FT_STRING,\n\t\t    BASE_NONE, NULL, 0, NULL, HFILL }},\n\n\t\t/* Printer data */\n\n\t\t{ &hf_printerdata,\n\t\t  { \"Data\", \"spoolss.printerdata\", FT_UINT32,\n\t\t    BASE_HEX, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_printerdata_key,\n\t\t  { \"Key\", \"spoolss.printerdata.key\", FT_STRING,\n\t\t    BASE_NONE, NULL, 0, \"Printer data key\", HFILL }},\n\n\t\t{ &hf_printerdata_value,\n\t\t  { \"Value\", \"spoolss.printerdata.value\",\n\t\t    FT_STRING, BASE_NONE, NULL, 0, \"Printer data value\",\n\t\t    HFILL }},\n\n\t\t{ &hf_printerdata_type,\n\t\t  { \"Type\", \"spoolss.printerdata.type\",\n\t\t    FT_UINT32, BASE_DEC|BASE_EXT_STRING, &reg_datatypes_ext, 0,\n\t\t    \"Printer data type\", HFILL }},\n\n\t\t{ &hf_printerdata_size,\n\t\t  { \"Size\", \"spoolss.printerdata.size\",\n\t\t    FT_UINT32, BASE_DEC, NULL, 0, \"Printer data size\",\n\t\t    HFILL }},\n\n\t\t{ &hf_printerdata_data,\n\t\t  { \"Data\", \"spoolss.printerdata.data\", FT_BYTES, BASE_NONE,\n\t\t    NULL, 0x0, \"Printer data\", HFILL }},\n\n\t\t{ &hf_printerdata_data_dword,\n\t\t  { \"DWORD data\", \"spoolss.printerdata.data.dword\",\n\t\t    FT_UINT32, BASE_HEX, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_printerdata_data_sz,\n\t\t  { \"String data\", \"spoolss.printerdata.data.sz\",\n\t\t    FT_STRING, BASE_NONE, NULL, 0, NULL,\n\t\t    HFILL }},\n\n\t\t/* Devicemode */\n\n\t\t{ &hf_devmodectr_size,\n\t\t  { \"Devicemode ctr size\", \"spoolss.devicemodectr.size\",\n\t\t    FT_UINT32, BASE_DEC, NULL, 0, NULL,\n\t\t    HFILL }},\n\n\t\t{ &hf_devmode,\n\t\t  { \"Devicemode\", \"spoolss.devmode\", FT_UINT32,\n\t\t    BASE_HEX, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_devmode_size,\n\t\t  { \"Size\", \"spoolss.devmode.size\",\n\t\t    FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_devmode_spec_version,\n\t\t  { \"Spec version\", \"spoolss.devmode.spec_version\",\n\t\t    FT_UINT16, BASE_DEC, VALS(devmode_specversion_vals),\n\t\t    0, NULL, HFILL }},\n\n\t\t{ &hf_devmode_driver_version,\n\t\t  { \"Driver version\", \"spoolss.devmode.driver_version\",\n\t\t    FT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_devmode_size2,\n\t\t  { \"Size2\", \"spoolss.devmode.size2\",\n\t\t    FT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_devmode_fields,\n\t\t  { \"Fields\", \"spoolss.devmode.fields\",\n\t\t    FT_UINT32, BASE_HEX, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_devmode_orientation,\n\t\t  { \"Orientation\", \"spoolss.devmode.orientation\",\n\t\t    FT_UINT16, BASE_DEC, VALS(devmode_orientation_vals),\n\t\t    0, NULL, HFILL }},\n\n\t\t{ &hf_devmode_paper_size,\n\t\t  { \"Paper size\", \"spoolss.devmode.paper_size\",\n\t\t    FT_UINT16, BASE_DEC|BASE_EXT_STRING, &devmode_papersize_vals_ext,\n\t\t    0, NULL, HFILL }},\n\n\t\t{ &hf_devmode_paper_width,\n\t\t  { \"Paper width\", \"spoolss.devmode.paper_width\",\n\t\t    FT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_devmode_paper_length,\n\t\t  { \"Paper length\", \"spoolss.devmode.paper_length\",\n\t\t    FT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_devmode_scale,\n\t\t  { \"Scale\", \"spoolss.devmode.scale\",\n\t\t    FT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_devmode_copies,\n\t\t  { \"Copies\", \"spoolss.devmode.copies\",\n\t\t    FT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_devmode_default_source,\n\t\t  { \"Default source\", \"spoolss.devmode.default_source\",\n\t\t    FT_UINT16, BASE_DEC|BASE_EXT_STRING, &devmode_papersource_vals_ext,\n\t\t    0, NULL, HFILL }},\n\n\t\t{ &hf_devmode_print_quality,\n\t\t  { \"Print quality\", \"spoolss.devmode.print_quality\",\n\t\t    FT_UINT16, BASE_DEC, VALS(devmode_printquality_vals),\n\t\t    0, NULL, HFILL }},\n\n\t\t{ &hf_devmode_color,\n\t\t  { \"Color\", \"spoolss.devmode.color\",\n\t\t    FT_UINT16, BASE_DEC, VALS(devmode_colour_vals), 0,\n\t\t    NULL, HFILL }},\n\n\t\t{ &hf_devmode_duplex,\n\t\t  { \"Duplex\", \"spoolss.devmode.duplex\",\n\t\t    FT_UINT16, BASE_DEC, VALS(devmode_duplex_vals), 0,\n\t\t    NULL, HFILL }},\n\n\t\t{ &hf_devmode_y_resolution,\n\t\t  { \"Y resolution\", \"spoolss.devmode.y_resolution\",\n\t\t    FT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_devmode_tt_option,\n\t\t  { \"TT option\", \"spoolss.devmode.tt_option\",\n\t\t    FT_UINT16, BASE_DEC, VALS(devmode_ttoption_vals), 0,\n\t\t    NULL, HFILL }},\n\n\t\t{ &hf_devmode_collate,\n\t\t  { \"Collate\", \"spoolss.devmode.collate\",\n\t\t    FT_UINT16, BASE_DEC, VALS(devmode_collate_vals), 0,\n\t\t    NULL, HFILL }},\n\n\t\t{ &hf_devmode_log_pixels,\n\t\t  { \"Log pixels\", \"spoolss.devmode.log_pixels\",\n\t\t    FT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_devmode_bits_per_pel,\n\t\t  { \"Bits per pel\", \"spoolss.devmode.bits_per_pel\",\n\t\t    FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_devmode_pels_width,\n\t\t  { \"Pels width\", \"spoolss.devmode.pels_width\",\n\t\t    FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_devmode_pels_height,\n\t\t  { \"Pels height\", \"spoolss.devmode.pels_height\",\n\t\t    FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_devmode_display_flags,\n\t\t  { \"Display flags\", \"spoolss.devmode.display_flags\",\n\t\t    FT_UINT32, BASE_DEC, VALS(devmode_displayflags_vals), 0,\n\t\t    NULL, HFILL }},\n\n\t\t{ &hf_devmode_display_freq,\n\t\t  { \"Display frequency\", \"spoolss.devmode.display_freq\",\n\t\t    FT_UINT32, BASE_DEC, NULL, 0, NULL,\n\t\t    HFILL }},\n\n\t\t{ &hf_devmode_icm_method,\n\t\t  { \"ICM method\", \"spoolss.devmode.icm_method\",\n\t\t    FT_UINT32, BASE_DEC, VALS(devmode_icmmethod_vals), 0,\n\t\t    NULL, HFILL }},\n\n\t\t{ &hf_devmode_icm_intent,\n\t\t  { \"ICM intent\", \"spoolss.devmode.icm_intent\",\n\t\t    FT_UINT32, BASE_DEC, VALS(devmode_icmintent_vals), 0,\n\t\t    NULL, HFILL }},\n\n\t\t{ &hf_devmode_media_type,\n\t\t  { \"Media type\", \"spoolss.devmode.media_type\",\n\t\t    FT_UINT32, BASE_DEC, VALS(devmode_mediatype_vals), 0,\n\t\t    NULL, HFILL }},\n\n\t\t{ &hf_devmode_dither_type,\n\t\t  { \"Dither type\", \"spoolss.devmode.dither_type\",\n\t\t    FT_UINT32, BASE_DEC, VALS(devmode_dithertype_vals), 0,\n\t\t    NULL, HFILL }},\n\n\t\t{ &hf_devmode_reserved1,\n\t\t  { \"Reserved1\", \"spoolss.devmode.reserved1\",\n\t\t    FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_devmode_reserved2,\n\t\t  { \"Reserved2\", \"spoolss.devmode.reserved2\",\n\t\t    FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_devmode_panning_width,\n\t\t  { \"Panning width\", \"spoolss.devmode.panning_width\",\n\t\t    FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_devmode_panning_height,\n\t\t  { \"Panning height\", \"spoolss.devmode.panning_height\",\n\t\t    FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_devmode_driver_extra_len,\n\t\t  { \"Driver extra length\",\n\t\t    \"spoolss.devmode.driver_extra_len\",\n\t\t    FT_UINT32, BASE_DEC, NULL, 0, NULL,\n\t\t    HFILL }},\n\n\t\t{ &hf_devmode_driver_extra,\n\t\t  { \"Driver extra\", \"spoolss.devmode.driver_extra\",\n\t\t    FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL }},\n\n\t\t/* Devicemode fields */\n\n\t\t{ &hf_devmode_fields_orientation,\n\t\t  { \"Orientation\", \"spoolss.devmode.fields.orientation\",\n\t\t    FT_BOOLEAN, 32, TFS(&tfs_set_notset),\n\t\t    DEVMODE_ORIENTATION, NULL, HFILL }},\n\n\t\t{ &hf_devmode_fields_papersize,\n\t\t  { \"Paper size\", \"spoolss.devmode.fields.paper_size\",\n\t\t    FT_BOOLEAN, 32, TFS(&tfs_set_notset),\n\t\t    DEVMODE_PAPERSIZE, NULL, HFILL }},\n\n\t\t{ &hf_devmode_fields_paperlength,\n\t\t  { \"Paper length\", \"spoolss.devmode.fields.paper_length\",\n\t\t    FT_BOOLEAN, 32, TFS(&tfs_set_notset),\n\t\t    DEVMODE_PAPERLENGTH, NULL, HFILL }},\n\n\t\t{ &hf_devmode_fields_paperwidth,\n\t\t  { \"Paper width\", \"spoolss.devmode.fields.paper_width\",\n\t\t    FT_BOOLEAN, 32, TFS(&tfs_set_notset),\n\t\t    DEVMODE_PAPERWIDTH, NULL, HFILL }},\n\n\t\t{ &hf_devmode_fields_scale,\n\t\t  { \"Scale\", \"spoolss.devmode.fields.scale\",\n\t\t    FT_BOOLEAN, 32, TFS(&tfs_set_notset),\n\t\t    DEVMODE_SCALE, NULL, HFILL }},\n\n\t\t{ &hf_devmode_fields_position,\n\t\t  { \"Position\", \"spoolss.devmode.fields.position\",\n\t\t    FT_BOOLEAN, 32, TFS(&tfs_set_notset),\n\t\t    DEVMODE_POSITION, NULL, HFILL }},\n\n\t\t{ &hf_devmode_fields_nup,\n\t\t  { \"N-up\", \"spoolss.devmode.fields.nup\",\n\t\t    FT_BOOLEAN, 32, TFS(&tfs_set_notset),\n\t\t    DEVMODE_NUP, NULL, HFILL }},\n\n\t\t{ &hf_devmode_fields_copies,\n\t\t  { \"Copies\", \"spoolss.devmode.fields.copies\",\n\t\t    FT_BOOLEAN, 32, TFS(&tfs_set_notset),\n\t\t    DEVMODE_COPIES, NULL, HFILL }},\n\n\t\t{ &hf_devmode_fields_defaultsource,\n\t\t  { \"Default source\", \"spoolss.devmode.fields.default_source\",\n\t\t    FT_BOOLEAN, 32, TFS(&tfs_set_notset),\n\t\t    DEVMODE_DEFAULTSOURCE, NULL, HFILL }},\n\n\t\t{ &hf_devmode_fields_printquality,\n\t\t  { \"Print quality\", \"spoolss.devmode.fields.print_quality\",\n\t\t    FT_BOOLEAN, 32, TFS(&tfs_set_notset),\n\t\t    DEVMODE_PRINTQUALITY, NULL, HFILL }},\n\n\t\t{ &hf_devmode_fields_color,\n\t\t  { \"Color\", \"spoolss.devmode.fields.color\",\n\t\t    FT_BOOLEAN, 32, TFS(&tfs_set_notset),\n\t\t    DEVMODE_COLOR, NULL, HFILL }},\n\n\t\t{ &hf_devmode_fields_duplex,\n\t\t  { \"Duplex\", \"spoolss.devmode.fields.duplex\",\n\t\t    FT_BOOLEAN, 32, TFS(&tfs_set_notset),\n\t\t    DEVMODE_DUPLEX, NULL, HFILL }},\n\n\t\t{ &hf_devmode_fields_yresolution,\n\t\t  { \"Y resolution\", \"spoolss.devmode.fields.y_resolution\",\n\t\t    FT_BOOLEAN, 32, TFS(&tfs_set_notset),\n\t\t    DEVMODE_YRESOLUTION, NULL, HFILL }},\n\n\t\t{ &hf_devmode_fields_ttoption,\n\t\t  { \"TT option\", \"spoolss.devmode.fields.tt_option\",\n\t\t    FT_BOOLEAN, 32, TFS(&tfs_set_notset),\n\t\t    DEVMODE_TTOPTION, NULL, HFILL }},\n\n\t\t{ &hf_devmode_fields_collate,\n\t\t  { \"Collate\", \"spoolss.devmode.fields.collate\",\n\t\t    FT_BOOLEAN, 32, TFS(&tfs_set_notset),\n\t\t    DEVMODE_COLLATE, NULL, HFILL }},\n\n\t\t{ &hf_devmode_fields_formname,\n\t\t  { \"Form name\", \"spoolss.devmode.fields.form_name\",\n\t\t    FT_BOOLEAN, 32, TFS(&tfs_set_notset),\n\t\t    DEVMODE_FORMNAME, NULL, HFILL }},\n\n\t\t{ &hf_devmode_fields_logpixels,\n\t\t  { \"Log pixels\", \"spoolss.devmode.fields.log_pixels\",\n\t\t    FT_BOOLEAN, 32, TFS(&tfs_set_notset),\n\t\t    DEVMODE_LOGPIXELS, NULL, HFILL }},\n\n\t\t{ &hf_devmode_fields_bitsperpel,\n\t\t  { \"Bits per pel\", \"spoolss.devmode.fields.bits_per_pel\",\n\t\t    FT_BOOLEAN, 32, TFS(&tfs_set_notset),\n\t\t    DEVMODE_BITSPERPEL, NULL, HFILL }},\n\n\t\t{ &hf_devmode_fields_pelswidth,\n\t\t  { \"Pels width\", \"spoolss.devmode.fields.pels_width\",\n\t\t    FT_BOOLEAN, 32, TFS(&tfs_set_notset),\n\t\t    DEVMODE_PELSWIDTH, NULL, HFILL }},\n\n\t\t{ &hf_devmode_fields_pelsheight,\n\t\t  { \"Pels height\", \"spoolss.devmode.fields.pels_height\",\n\t\t    FT_BOOLEAN, 32, TFS(&tfs_set_notset),\n\t\t    DEVMODE_PELSHEIGHT, NULL, HFILL }},\n\n\t\t{ &hf_devmode_fields_displayflags,\n\t\t  { \"Display flags\", \"spoolss.devmode.fields.display_flags\",\n\t\t    FT_BOOLEAN, 32, TFS(&tfs_set_notset),\n\t\t    DEVMODE_DISPLAYFLAGS, NULL, HFILL }},\n\n\t\t{ &hf_devmode_fields_displayfrequency,\n\t\t  { \"Display frequency\",\n\t\t    \"spoolss.devmode.fields.display_frequency\",\n\t\t    FT_BOOLEAN, 32, TFS(&tfs_set_notset),\n\t\t    DEVMODE_DISPLAYFREQUENCY, NULL, HFILL }},\n\n\t\t{ &hf_devmode_fields_icmmethod,\n\t\t  { \"ICM method\", \"spoolss.devmode.fields.icm_method\",\n\t\t    FT_BOOLEAN, 32, TFS(&tfs_set_notset),\n\t\t    DEVMODE_ICMMETHOD, NULL, HFILL }},\n\n\t\t{ &hf_devmode_fields_icmintent,\n\t\t  { \"ICM intent\", \"spoolss.devmode.fields.icm_intent\",\n\t\t    FT_BOOLEAN, 32, TFS(&tfs_set_notset),\n\t\t    DEVMODE_ICMINTENT, NULL, HFILL }},\n\n\t\t{ &hf_devmode_fields_mediatype,\n\t\t  { \"Media type\", \"spoolss.devmode.fields.media_type\",\n\t\t    FT_BOOLEAN, 32, TFS(&tfs_set_notset),\n\t\t    DEVMODE_MEDIATYPE, NULL, HFILL }},\n\n\t\t{ &hf_devmode_fields_dithertype,\n\t\t  { \"Dither type\", \"spoolss.devmode.fields.dither_type\",\n\t\t    FT_BOOLEAN, 32, TFS(&tfs_set_notset),\n\t\t    DEVMODE_DITHERTYPE, NULL, HFILL }},\n\n\t\t{ &hf_devmode_fields_panningwidth,\n\t\t  { \"Panning width\", \"spoolss.devmode.fields.panning_width\",\n\t\t    FT_BOOLEAN, 32, TFS(&tfs_set_notset),\n\t\t    DEVMODE_PANNINGWIDTH, NULL, HFILL }},\n\n\t\t{ &hf_devmode_fields_panningheight,\n\t\t  { \"Panning height\", \"spoolss.devmode.fields.panning_height\",\n\t\t    FT_BOOLEAN, 32, TFS(&tfs_set_notset),\n\t\t    DEVMODE_PANNINGHEIGHT, NULL, HFILL }},\n\n\t\t/* EnumPrinterData RPC */\n\n\t\t{ &hf_enumprinterdata_enumindex,\n\t\t  { \"Enum index\", \"spoolss.enumprinterdata.enumindex\",\n\t\t    FT_UINT32, BASE_DEC, NULL, 0x0,\n\t\t    \"Index for start of enumeration\", HFILL }},\n\n\t\t{ &hf_enumprinterdata_value_offered,\n\t\t  { \"Value size offered\",\n\t\t    \"spoolss.enumprinterdata.value_offered\", FT_UINT32,\n\t\t    BASE_DEC, NULL, 0x0,\n\t\t    \"Buffer size offered for printerdata value\", HFILL }},\n\n\t\t{ &hf_enumprinterdata_data_offered,\n\t\t  { \"Data size offered\",\n\t\t    \"spoolss.enumprinterdata.data_offered\", FT_UINT32,\n\t\t    BASE_DEC, NULL, 0x0,\n\t\t    \"Buffer size offered for printerdata data\", HFILL }},\n\n\t\t{ &hf_enumprinterdata_value_len,\n\t\t  { \"Value length\",\n\t\t    \"spoolss.enumprinterdata.value_len\", FT_UINT32,\n\t\t    BASE_DEC, NULL, 0x0,\n\t\t    \"Size of printerdata value\", HFILL }},\n\n\t\t{ &hf_enumprinterdata_value_needed,\n\t\t  { \"Value size needed\",\n\t\t    \"spoolss.enumprinterdata.value_needed\", FT_UINT32,\n\t\t    BASE_DEC, NULL, 0x0,\n\t\t    \"Buffer size needed for printerdata value\", HFILL }},\n\n\t\t{ &hf_enumprinterdata_data_needed,\n\t\t  { \"Data size needed\",\n\t\t    \"spoolss.enumprinterdata.data_needed\", FT_UINT32, BASE_DEC,\n\t\t    NULL, 0x0, \"Buffer size needed for printerdata data\",\n\t\t    HFILL }},\n\n\t\t/* Print jobs */\n\n\t\t{ &hf_job_id,\n\t\t  { \"Job ID\", \"spoolss.job.id\", FT_UINT32, BASE_DEC,\n\t\t    NULL, 0x0, \"Job identification number\", HFILL }},\n\n\t\t{ &hf_job_status,\n\t\t  { \"Job status\", \"spoolss.job.status\", FT_UINT32, BASE_DEC,\n\t\t    NULL, 0x0, NULL, HFILL }},\n\n\t\t{ &hf_job_status_paused,\n\t\t  { \"Paused\", \"spoolss.job.status.paused\", FT_BOOLEAN, 32,\n\t\t    TFS(&tfs_job_status_paused), JOB_STATUS_PAUSED,\n\t\t    NULL, HFILL }},\n\n\t\t{ &hf_job_status_error,\n\t\t  { \"Error\", \"spoolss.job.status.error\", FT_BOOLEAN, 32,\n\t\t    TFS(&tfs_job_status_error), JOB_STATUS_ERROR,\n\t\t    NULL, HFILL }},\n\n\t\t{ &hf_job_status_deleting,\n\t\t  { \"Deleting\", \"spoolss.job.status.deleting\", FT_BOOLEAN, 32,\n\t\t    TFS(&tfs_job_status_deleting), JOB_STATUS_DELETING,\n\t\t    NULL, HFILL }},\n\n\t\t{ &hf_job_status_spooling,\n\t\t  { \"Spooling\", \"spoolss.job.status.spooling\", FT_BOOLEAN, 32,\n\t\t    TFS(&tfs_job_status_spooling), JOB_STATUS_SPOOLING,\n\t\t    NULL, HFILL }},\n\n\t\t{ &hf_job_status_printing,\n\t\t  { \"Printing\", \"spoolss.job.status.printing\", FT_BOOLEAN, 32,\n\t\t    TFS(&tfs_job_status_printing), JOB_STATUS_PRINTING,\n\t\t    NULL, HFILL }},\n\n\t\t{ &hf_job_status_offline,\n\t\t  { \"Offline\", \"spoolss.job.status.offline\", FT_BOOLEAN, 32,\n\t\t    TFS(&tfs_job_status_offline), JOB_STATUS_OFFLINE,\n\t\t    NULL, HFILL }},\n\n\t\t{ &hf_job_status_paperout,\n\t\t  { \"Paperout\", \"spoolss.job.status.paperout\", FT_BOOLEAN, 32,\n\t\t    TFS(&tfs_job_status_paperout), JOB_STATUS_PAPEROUT,\n\t\t    NULL, HFILL }},\n\n\t\t{ &hf_job_status_printed,\n\t\t  { \"Printed\", \"spoolss.job.status.printed\", FT_BOOLEAN, 32,\n\t\t    TFS(&tfs_job_status_printed), JOB_STATUS_PRINTED,\n\t\t    NULL, HFILL }},\n\n\t\t{ &hf_job_status_deleted,\n\t\t  { \"Deleted\", \"spoolss.job.status.deleted\", FT_BOOLEAN, 32,\n\t\t    TFS(&tfs_job_status_deleted), JOB_STATUS_DELETED,\n\t\t    NULL, HFILL }},\n\n\t\t{ &hf_job_status_blocked,\n\t\t  { \"Blocked\", \"spoolss.job.status.blocked\", FT_BOOLEAN, 32,\n\t\t    TFS(&tfs_job_status_blocked), JOB_STATUS_BLOCKED,\n\t\t    NULL, HFILL }},\n\n\t\t{ &hf_job_status_user_intervention,\n\t\t  { \"User intervention\",\n\t\t    \"spoolss.job.status.user_intervention\", FT_BOOLEAN, 32,\n\t\t    TFS(&tfs_job_status_user_intervention),\n\t\t    JOB_STATUS_USER_INTERVENTION, NULL,\n\t\t    HFILL }},\n\n\t\t{ &hf_job_priority,\n\t\t  { \"Job priority\", \"spoolss.job.priority\", FT_UINT32,\n\t\t    BASE_DEC, NULL, 0x0, NULL, HFILL }},\n\n\t\t{ &hf_job_position,\n\t\t  { \"Job position\", \"spoolss.job.position\", FT_UINT32,\n\t\t    BASE_DEC, NULL, 0x0, NULL, HFILL }},\n\n\t\t{ &hf_job_totalpages,\n\t\t  { \"Job total pages\", \"spoolss.job.totalpages\", FT_UINT32,\n\t\t    BASE_DEC, NULL, 0x0, NULL, HFILL }},\n\n\t\t{ &hf_job_totalbytes,\n\t\t  { \"Job total bytes\", \"spoolss.job.totalbytes\", FT_UINT32,\n\t\t    BASE_DEC, NULL, 0x0, NULL, HFILL }},\n\n\t\t{ &hf_job_bytesprinted,\n\t\t  { \"Job bytes printed\", \"spoolss.job.bytesprinted\",\n\t\t    FT_UINT32, BASE_DEC, NULL, 0x0, NULL,\n\t\t    HFILL }},\n\n\t\t{ &hf_job_pagesprinted,\n\t\t  { \"Job pages printed\", \"spoolss.job.pagesprinted\",\n\t\t    FT_UINT32, BASE_DEC, NULL, 0x0, NULL,\n\t\t    HFILL }},\n\n\t\t{ &hf_job_size,\n\t\t  { \"Job size\", \"spoolss.job.size\", FT_UINT32, BASE_DEC,\n\t\t    NULL, 0x0, NULL, HFILL }},\n\n\t\t/* Forms */\n\n\t\t{ &hf_form,\n\t\t  { \"Data\", \"spoolss.form\", FT_UINT32,\n\t\t    BASE_HEX, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_form_level,\n\t\t  { \"Level\", \"spoolss.form.level\", FT_UINT32,\n\t\t    BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_form_name,\n\t\t  { \"Name\", \"spoolss.form.name\", FT_STRING, BASE_NONE,\n\t\t    NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_form_flags,\n\t\t  { \"Flags\", \"spoolss.form.flags\", FT_UINT32,\n\t\t    BASE_DEC, VALS(form_type_vals), 0, NULL, HFILL }},\n\n\t\t{ &hf_form_unknown,\n\t\t  { \"Unknown\", \"spoolss.form.unknown\", FT_UINT32,\n\t\t    BASE_HEX, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_form_width,\n\t\t  { \"Width\", \"spoolss.form.width\", FT_UINT32,\n\t\t    BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_form_height,\n\t\t  { \"Height\", \"spoolss.form.height\", FT_UINT32,\n\t\t    BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_form_left_margin,\n\t\t  { \"Left margin\", \"spoolss.form.left\", FT_UINT32,\n\t\t    BASE_DEC, NULL, 0, \"Left\", HFILL }},\n\n\t\t{ &hf_form_top_margin,\n\t\t  { \"Top\", \"spoolss.form.top\", FT_UINT32,\n\t\t    BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_form_horiz_len,\n\t\t  { \"Horizontal\", \"spoolss.form.horiz\", FT_UINT32,\n\t\t    BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_form_vert_len,\n\t\t  { \"Vertical\", \"spoolss.form.vert\", FT_UINT32,\n\t\t    BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_enumforms_num,\n\t\t  { \"Num\", \"spoolss.enumforms.num\", FT_UINT32,\n\t\t    BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t/* Print notify */\n\n\t\t{ &hf_notify_options_version,\n\t\t  { \"Version\", \"spoolss.notify_options.version\", FT_UINT32,\n\t\t    BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_notify_options_flags,\n\t\t  { \"Flags\", \"spoolss.notify_options.flags\", FT_UINT32,\n\t\t    BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_notify_options_count,\n\t\t  { \"Count\", \"spoolss.notify_options.count\", FT_UINT32,\n\t\t    BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_notify_option_type,\n\t\t  { \"Type\", \"spoolss.notify_option.type\", FT_UINT16, BASE_DEC,\n\t\t    VALS(printer_notify_types), 0, NULL, HFILL }},\n\n\t\t{ &hf_notify_option_reserved1,\n\t\t  { \"Reserved1\", \"spoolss.notify_option.reserved1\", FT_UINT16,\n\t\t    BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_notify_option_reserved2,\n\t\t  { \"Reserved2\", \"spoolss.notify_option.reserved2\", FT_UINT32,\n\t\t    BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_notify_option_reserved3,\n\t\t  { \"Reserved3\", \"spoolss.notify_option.reserved3\", FT_UINT32,\n\t\t    BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_notify_option_count,\n\t\t  { \"Count\", \"spoolss.notify_option.count\", FT_UINT32,\n\t\t    BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_notify_option_data_count,\n\t\t  { \"Count\", \"spoolss.notify_option_data.count\", FT_UINT32,\n\t\t    BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_notify_options_flags_refresh,\n\t\t  { \"Refresh\", \"spoolss.notify_options.flags.refresh\", FT_BOOLEAN, 32,\n\t\t    TFS(&tfs_notify_options_flags_refresh),\n\t\t    PRINTER_NOTIFY_OPTIONS_REFRESH, NULL, HFILL }},\n\n\t\t{ &hf_notify_info_count,\n\t\t  { \"Count\", \"spoolss.notify_info.count\", FT_UINT32, BASE_DEC,\n\t\t    NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_notify_info_version,\n\t\t  { \"Version\", \"spoolss.notify_info.version\", FT_UINT32,\n\t\t    BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_notify_info_flags,\n\t\t  { \"Flags\", \"spoolss.notify_info.flags\", FT_UINT32, BASE_HEX,\n\t\t    NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_notify_info_data_type,\n\t\t  { \"Type\", \"spoolss.notify_info_data.type\", FT_UINT16,\n\t\t    BASE_DEC, VALS(printer_notify_types), 0, NULL, HFILL }},\n\n\t\t{ &hf_notify_field,\n\t\t  { \"Field\", \"spoolss.notify_field\", FT_UINT16, BASE_DEC,\n\t\t    NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_notify_info_data_count,\n\t\t  { \"Count\", \"spoolss.notify_info_data.count\", FT_UINT32,\n\t\t    BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_notify_info_data_id,\n\t\t  { \"Job Id\", \"spoolss.notify_info_data.jobid\", FT_UINT32,\n\t\t    BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_notify_info_data_value1,\n\t\t  { \"Value1\", \"spoolss.notify_info_data.value1\", FT_UINT32,\n\t\t    BASE_HEX, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_notify_info_data_value2,\n\t\t  { \"Value2\", \"spoolss.notify_info_data.value2\", FT_UINT32,\n\t\t    BASE_HEX, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_notify_info_data_bufsize,\n\t\t  { \"Buffer size\", \"spoolss.notify_info_data.bufsize\",\n\t\t    FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_notify_info_data_buffer,\n\t\t  { \"Buffer\", \"spoolss.notify_info_data.buffer\", FT_UINT32,\n\t\t    BASE_HEX, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_notify_info_data_buffer_len,\n\t\t  { \"Buffer length\", \"spoolss.notify_info_data.buffer.len\",\n\t\t    FT_UINT32, BASE_HEX, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_notify_info_data_buffer_data,\n\t\t  { \"Buffer data\", \"spoolss.notify_info_data.buffer.data\",\n\t\t    FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL }},\n\n\t\t/* RffpCNex RPC */\n\n\t\t{ &hf_rffpcnex_options,\n\t\t  { \"Options\", \"spoolss.rffpcnex.options\", FT_UINT32, BASE_DEC,\n\t\t    NULL, 0, \"RFFPCNEX options\", HFILL }},\n\n\t\t{ &hf_printerlocal, /* XXX: move me */\n\t\t  { \"Printer local\", \"spoolss.printer_local\", FT_UINT32,\n\t\t    BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_rffpcnex_flags,\n\t\t  { \"RFFPCNEX flags\", \"spoolss.rffpcnex.flags\", FT_UINT32,\n\t\t    BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_rffpcnex_flags_add_printer,\n\t\t  { \"Add printer\", \"spoolss.rffpcnex.flags.add_printer\",\n\t\t    FT_BOOLEAN, 32, TFS(&tfs_rffpcnex_flags_add_printer),\n\t\t    SPOOLSS_PRINTER_CHANGE_ADD_PRINTER, NULL,\n\t\t    HFILL }},\n\n\t\t{ &hf_rffpcnex_flags_set_printer,\n\t\t  { \"Set printer\", \"spoolss.rffpcnex.flags.set_printer\",\n\t\t    FT_BOOLEAN, 32, TFS(&tfs_rffpcnex_flags_set_printer),\n\t\t    SPOOLSS_PRINTER_CHANGE_SET_PRINTER, NULL,\n\t\t    HFILL }},\n\n\t\t{ &hf_rffpcnex_flags_delete_printer,\n\t\t  { \"Delete printer\", \"spoolss.rffpcnex.flags.delete_printer\",\n\t\t    FT_BOOLEAN, 32, TFS(&tfs_rffpcnex_flags_delete_printer),\n\t\t    SPOOLSS_PRINTER_CHANGE_DELETE_PRINTER, NULL,\n\t\t    HFILL }},\n\n\t\t{ &hf_rffpcnex_flags_add_job,\n\t\t  { \"Add job\", \"spoolss.rffpcnex.flags.add_job\",\n\t\t    FT_BOOLEAN, 32, TFS(&tfs_rffpcnex_flags_add_job),\n\t\t    SPOOLSS_PRINTER_CHANGE_ADD_JOB, NULL, HFILL }},\n\n\t\t{ &hf_rffpcnex_flags_set_job,\n\t\t  { \"Set job\", \"spoolss.rffpcnex.flags.set_job\",\n\t\t    FT_BOOLEAN, 32, TFS(&tfs_rffpcnex_flags_set_job),\n\t\t    SPOOLSS_PRINTER_CHANGE_SET_JOB, NULL, HFILL }},\n\n\t\t{ &hf_rffpcnex_flags_delete_job,\n\t\t  { \"Delete job\", \"spoolss.rffpcnex.flags.delete_job\",\n\t\t    FT_BOOLEAN, 32, TFS(&tfs_rffpcnex_flags_delete_job),\n\t\t    SPOOLSS_PRINTER_CHANGE_DELETE_JOB, NULL, HFILL }},\n\n\t\t{ &hf_rffpcnex_flags_write_job,\n\t\t  { \"Write job\", \"spoolss.rffpcnex.flags.write_job\",\n\t\t    FT_BOOLEAN, 32, TFS(&tfs_rffpcnex_flags_write_job),\n\t\t    SPOOLSS_PRINTER_CHANGE_WRITE_JOB, NULL, HFILL }},\n\n\t\t{ &hf_rffpcnex_flags_add_form,\n\t\t  { \"Add form\", \"spoolss.rffpcnex.flags.add_form\",\n\t\t    FT_BOOLEAN, 32, TFS(&tfs_rffpcnex_flags_add_form),\n\t\t    SPOOLSS_PRINTER_CHANGE_ADD_FORM, NULL, HFILL }},\n\n\t\t{ &hf_rffpcnex_flags_set_form,\n\t\t  { \"Set form\", \"spoolss.rffpcnex.flags.set_form\",\n\t\t    FT_BOOLEAN, 32, TFS(&tfs_rffpcnex_flags_set_form),\n\t\t    SPOOLSS_PRINTER_CHANGE_SET_FORM, NULL, HFILL }},\n\n\t\t{ &hf_rffpcnex_flags_delete_form,\n\t\t  { \"Delete form\", \"spoolss.rffpcnex.flags.delete_form\",\n\t\t    FT_BOOLEAN, 32, TFS(&tfs_rffpcnex_flags_delete_form),\n\t\t    SPOOLSS_PRINTER_CHANGE_DELETE_FORM, NULL,\n\t\t    HFILL }},\n\n\t\t{ &hf_rffpcnex_flags_add_port,\n\t\t  { \"Add port\", \"spoolss.rffpcnex.flags.add_port\",\n\t\t    FT_BOOLEAN, 32, TFS(&tfs_rffpcnex_flags_add_port),\n\t\t    SPOOLSS_PRINTER_CHANGE_ADD_PORT, NULL, HFILL }},\n\n\t\t{ &hf_rffpcnex_flags_configure_port,\n\t\t  { \"Configure port\", \"spoolss.rffpcnex.flags.configure_port\",\n\t\t    FT_BOOLEAN, 32, TFS(&tfs_rffpcnex_flags_configure_port),\n\t\t    SPOOLSS_PRINTER_CHANGE_CONFIGURE_PORT, NULL,\n\t\t    HFILL }},\n\n\t\t{ &hf_rffpcnex_flags_delete_port,\n\t\t  { \"Delete port\", \"spoolss.rffpcnex.flags.delete_port\",\n\t\t    FT_BOOLEAN, 32, TFS(&tfs_rffpcnex_flags_delete_port),\n\t\t    SPOOLSS_PRINTER_CHANGE_DELETE_PORT, NULL,\n\t\t    HFILL }},\n\n\t\t{ &hf_rffpcnex_flags_add_print_processor,\n\t\t  { \"Add processor\", \"spoolss.rffpcnex.flags.add_processor\",\n\t\t    FT_BOOLEAN, 32,\n\t\t    TFS(&tfs_rffpcnex_flags_add_print_processor),\n\t\t    SPOOLSS_PRINTER_CHANGE_ADD_PRINT_PROCESSOR,\n\t\t    NULL, HFILL }},\n\n\t\t{ &hf_rffpcnex_flags_delete_print_processor,\n\t\t  { \"Delete processor\",\n\t\t    \"spoolss.rffpcnex.flags.delete_processor\", FT_BOOLEAN, 32,\n\t\t    TFS(&tfs_rffpcnex_flags_delete_print_processor),\n\t\t    SPOOLSS_PRINTER_CHANGE_DELETE_PRINT_PROCESSOR,\n\t\t    NULL, HFILL }},\n\n\t\t{ &hf_rffpcnex_flags_add_driver,\n\t\t  { \"Add driver\", \"spoolss.rffpcnex.flags.add_driver\",\n\t\t    FT_BOOLEAN, 32, TFS(&tfs_rffpcnex_flags_add_driver),\n\t\t    SPOOLSS_PRINTER_CHANGE_ADD_PRINTER_DRIVER, NULL,\n\t\t    HFILL }},\n\n\t\t{ &hf_rffpcnex_flags_set_driver,\n\t\t  { \"Set driver\", \"spoolss.rffpcnex.flags.set_driver\",\n\t\t    FT_BOOLEAN, 32, TFS(&tfs_rffpcnex_flags_set_driver),\n\t\t    SPOOLSS_PRINTER_CHANGE_SET_PRINTER_DRIVER, NULL,\n\t\t    HFILL }},\n\n\t\t{ &hf_rffpcnex_flags_delete_driver,\n\t\t  { \"Delete driver\", \"spoolss.rffpcnex.flags.delete_driver\",\n\t\t    FT_BOOLEAN, 32, TFS(&tfs_rffpcnex_flags_delete_driver),\n\t\t    SPOOLSS_PRINTER_CHANGE_DELETE_PRINTER_DRIVER,\n\t\t    NULL, HFILL }},\n\n\t\t{ &hf_rffpcnex_flags_timeout,\n\t\t  { \"Timeout\", \"spoolss.rffpcnex.flags.timeout\",\n\t\t    FT_BOOLEAN, 32, TFS(&tfs_rffpcnex_flags_timeout),\n\t\t    SPOOLSS_PRINTER_CHANGE_TIMEOUT, NULL, HFILL }},\n\n\t\t{ &hf_rffpcnex_flags_failed_printer_connection,\n\t\t  { \"Failed printer connection\",\n\t\t    \"spoolss.rffpcnex.flags.failed_connection_printer\",\n\t\t    FT_BOOLEAN, 32,\n\t\t    TFS(&tfs_rffpcnex_flags_failed_connection_printer),\n\t\t    SPOOLSS_PRINTER_CHANGE_FAILED_CONNECTION_PRINTER,\n\t\t    NULL, HFILL }},\n\n\t\t/* RRPCN RPC */\n\n\t\t{ &hf_rrpcn_changelow,\n\t\t  { \"Change low\", \"spoolss.rrpcn.changelow\", FT_UINT32,\n\t\t    BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_rrpcn_changehigh,\n\t\t  { \"Change high\", \"spoolss.rrpcn.changehigh\", FT_UINT32,\n\t\t    BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_rrpcn_unk0,\n\t\t  { \"Unknown 0\", \"spoolss.rrpcn.unk0\", FT_UINT32, BASE_DEC,\n\t\t    NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_rrpcn_unk1,\n\t\t  { \"Unknown 1\", \"spoolss.rrpcn.unk1\", FT_UINT32, BASE_DEC,\n\t\t    NULL, 0, NULL, HFILL }},\n\n\t\t/* ReplyOpenPrinter RPC */\n\n\t\t{ &hf_replyopenprinter_unk0,\n\t\t  { \"Unknown 0\", \"spoolss.replyopenprinter.unk0\", FT_UINT32,\n\t\t    BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_replyopenprinter_unk1,\n\t\t  { \"Unknown 1\", \"spoolss.replyopenprinter.unk1\", FT_UINT32,\n\t\t    BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_devmode_devicename,\n\t\t  { \"DeviceName\", \"spoolss.devmode.devicename\", FT_STRING,\n\t\t    BASE_NONE, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_devmode_form_name,\n\t\t  { \"FormName\", \"spoolss.devmode.form_name\", FT_STRING,\n\t\t    BASE_NONE, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_relative_string,\n\t\t  { \"String\", \"spoolss.relative_string\", FT_STRING,\n\t\t    BASE_NONE, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_value_name,\n\t\t  { \"Value Name\", \"spoolss.value_name\", FT_STRING,\n\t\t    BASE_NONE, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_keybuffer,\n\t\t  { \"Key\", \"spoolss.hf_keybuffer\", FT_STRING,\n\t\t    BASE_NONE, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_value_string,\n\t\t  { \"Value\", \"spoolss.value_string\", FT_STRING,\n\t\t    BASE_NONE, NULL, 0, NULL, HFILL }},\n\n\t\t/* Printer attributes */\n\n\t\t{ &hf_printer_attributes,\n\t\t  { \"Attributes\", \"spoolss.printer_attributes\", FT_UINT32,\n\t\t    BASE_HEX, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_printer_attributes_queued,\n\t\t  { \"Queued\", \"spoolss.printer_attributes.queued\", FT_BOOLEAN,\n\t\t    32, TFS(&tfs_printer_attributes_queued),\n\t\t    PRINTER_ATTRIBUTE_QUEUED, NULL, HFILL }},\n\n\t\t{ &hf_printer_attributes_direct,\n\t\t  { \"Direct\", \"spoolss.printer_attributes.direct\", FT_BOOLEAN,\n\t\t    32, TFS(&tfs_printer_attributes_direct),\n\t\t    PRINTER_ATTRIBUTE_DIRECT, NULL, HFILL }},\n\n\t\t{ &hf_printer_attributes_default,\n\t\t  { \"Default (9x/ME only)\",\n\t\t    \"spoolss.printer_attributes.default\",FT_BOOLEAN,\n\t\t    32, TFS(&tfs_printer_attributes_default),\n\t\t    PRINTER_ATTRIBUTE_DEFAULT, \"Default\", HFILL }},\n\n\t\t{ &hf_printer_attributes_shared,\n\t\t  { \"Shared\", \"spoolss.printer_attributes.shared\", FT_BOOLEAN,\n\t\t    32, TFS(&tfs_printer_attributes_shared),\n\t\t    PRINTER_ATTRIBUTE_SHARED, NULL, HFILL }},\n\n\t\t{ &hf_printer_attributes_network,\n\t\t  { \"Network\", \"spoolss.printer_attributes.network\",\n\t\t    FT_BOOLEAN, 32, TFS(&tfs_printer_attributes_network),\n\t\t    PRINTER_ATTRIBUTE_NETWORK, NULL, HFILL }},\n\n\t\t{ &hf_printer_attributes_hidden,\n\t\t  { \"Hidden\", \"spoolss.printer_attributes.hidden\", FT_BOOLEAN,\n\t\t    32, TFS(&tfs_printer_attributes_hidden),\n\t\t    PRINTER_ATTRIBUTE_HIDDEN, NULL, HFILL }},\n\n\t\t{ &hf_printer_attributes_local,\n\t\t  { \"Local\", \"spoolss.printer_attributes.local\", FT_BOOLEAN,\n\t\t    32, TFS(&tfs_printer_attributes_local),\n\t\t    PRINTER_ATTRIBUTE_LOCAL, NULL, HFILL }},\n\n\t\t{ &hf_printer_attributes_enable_devq,\n\t\t  { \"Enable devq\", \"spoolss.printer_attributes.enable_devq\",\n\t\t    FT_BOOLEAN, 32, TFS(&tfs_printer_attributes_enable_devq),\n\t\t    PRINTER_ATTRIBUTE_ENABLE_DEVQ, \"Enable evq\", HFILL }},\n\n\t\t{ &hf_printer_attributes_keep_printed_jobs,\n\t\t  { \"Keep printed jobs\",\n\t\t    \"spoolss.printer_attributes.keep_printed_jobs\", FT_BOOLEAN,\n\t\t    32, TFS(&tfs_printer_attributes_keep_printed_jobs),\n\t\t    PRINTER_ATTRIBUTE_KEEPPRINTEDJOBS, NULL,\n\t\t    HFILL }},\n\n\t\t{ &hf_printer_attributes_do_complete_first,\n\t\t  { \"Do complete first\",\n\t\t    \"spoolss.printer_attributes.do_complete_first\", FT_BOOLEAN,\n\t\t    32, TFS(&tfs_printer_attributes_do_complete_first),\n\t\t    PRINTER_ATTRIBUTE_DO_COMPLETE_FIRST, NULL,\n\t\t    HFILL }},\n\n\t\t{ &hf_printer_attributes_work_offline,\n\t\t  { \"Work offline (9x/ME only)\",\n\t\t    \"spoolss.printer_attributes.work_offline\", FT_BOOLEAN,\n\t\t    32, TFS(&tfs_printer_attributes_work_offline),\n\t\t    PRINTER_ATTRIBUTE_WORK_OFFLINE, \"Work offline\", HFILL }},\n\n\t\t{ &hf_printer_attributes_enable_bidi,\n\t\t  { \"Enable bidi (9x/ME only)\",\n\t\t    \"spoolss.printer_attributes.enable_bidi\", FT_BOOLEAN,\n\t\t    32, TFS(&tfs_printer_attributes_enable_bidi),\n\t\t    PRINTER_ATTRIBUTE_ENABLE_BIDI, \"Enable bidi\", HFILL }},\n\n\t\t{ &hf_printer_attributes_raw_only,\n\t\t  { \"Raw only\", \"spoolss.printer_attributes.raw_only\",\n\t\t    FT_BOOLEAN, 32, TFS(&tfs_printer_attributes_raw_only),\n\t\t    PRINTER_ATTRIBUTE_RAW_ONLY, NULL, HFILL }},\n\n\t\t{ &hf_printer_attributes_published,\n\t\t  { \"Published\", \"spoolss.printer_attributes.published\",\n\t\t    FT_BOOLEAN, 32, TFS(&tfs_printer_attributes_published),\n\t\t    PRINTER_ATTRIBUTE_PUBLISHED, NULL, HFILL }},\n\n\t\t/* Timestamps */\n\n\t\t{ &hf_time_year,\n\t\t  { \"Year\", \"spoolss.time.year\", FT_UINT32, BASE_DEC,\n\t\t    NULL, 0x0, NULL, HFILL }},\n\n\t\t{ &hf_time_month,\n\t\t  { \"Month\", \"spoolss.time.month\", FT_UINT32, BASE_DEC,\n\t\t    NULL, 0x0, NULL, HFILL }},\n\n\t\t{ &hf_time_dow,\n\t\t  { \"Day of week\", \"spoolss.time.dow\", FT_UINT32, BASE_DEC,\n\t\t    NULL, 0x0, NULL, HFILL }},\n\n\t\t{ &hf_time_day,\n\t\t  { \"Day\", \"spoolss.time.day\", FT_UINT32, BASE_DEC,\n\t\t    NULL, 0x0, NULL, HFILL }},\n\n\t\t{ &hf_time_hour,\n\t\t  { \"Hour\", \"spoolss.time.hour\", FT_UINT32, BASE_DEC,\n\t\t    NULL, 0x0, NULL, HFILL }},\n\n\t\t{ &hf_time_minute,\n\t\t  { \"Minute\", \"spoolss.time.minute\", FT_UINT32, BASE_DEC,\n\t\t    NULL, 0x0, NULL, HFILL }},\n\n\t\t{ &hf_time_second,\n\t\t  { \"Second\", \"spoolss.time.second\", FT_UINT32, BASE_DEC,\n\t\t    NULL, 0x0, NULL, HFILL }},\n\n\t\t{ &hf_time_msec,\n\t\t  { \"Millisecond\", \"spoolss.time.msec\", FT_UINT32, BASE_DEC,\n\t\t    NULL, 0x0, NULL, HFILL }},\n\n\t\t/* Userlevel */\n\n\t\t{ &hf_userlevel_size,\n\t\t  { \"Size\", \"spoolss.userlevel.size\",\n\t\t    FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_userlevel_client,\n\t\t  { \"Client\", \"spoolss.userlevel.client\", FT_STRING,\n\t\t    BASE_NONE, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_userlevel_user,\n\t\t  { \"User\", \"spoolss.userlevel.user\", FT_STRING,\n\t\t    BASE_NONE, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_userlevel_build,\n\t\t  { \"Build\", \"spoolss.userlevel.build\",\n\t\t    FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_userlevel_major,\n\t\t  { \"Major\", \"spoolss.userlevel.major\",\n\t\t    FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_userlevel_minor,\n\t\t  { \"Minor\", \"spoolss.userlevel.minor\",\n\t\t    FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_userlevel_processor,\n\t\t  { \"Processor\", \"spoolss.userlevel.processor\",\n\t\t    FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t/* EnumprinterdataEx RPC */\n\n\t\t{ &hf_enumprinterdataex_name_offset,\n\t\t  { \"Name offset\", \"spoolss.enumprinterdataex.name_offset\",\n\t\t    FT_UINT32, BASE_DEC, NULL, 0x0,\n\t\t    NULL, HFILL }},\n\n\t\t{ &hf_enumprinterdataex_name_len,\n\t\t  { \"Name len\", \"spoolss.enumprinterdataex.name_len\",\n\t\t    FT_UINT32, BASE_DEC, NULL, 0x0,\n\t\t    NULL, HFILL }},\n\n\t\t{ &hf_enumprinterdataex_name,\n\t\t  { \"Name\", \"spoolss.enumprinterdataex.name\",\n\t\t    FT_STRING, BASE_NONE, NULL, 0x0,\n\t\t    NULL, HFILL }},\n\n\t\t{ &hf_enumprinterdataex_val_offset,\n\t\t  { \"Value offset\", \"spoolss.enumprinterdataex.value_offset\",\n\t\t    FT_UINT32, BASE_DEC, NULL, 0x0,\n\t\t    NULL, HFILL }},\n\n\t\t{ &hf_enumprinterdataex_val_len,\n\t\t  { \"Value len\", \"spoolss.enumprinterdataex.value_len\",\n\t\t    FT_UINT32, BASE_DEC, NULL, 0x0,\n\t\t    NULL, HFILL }},\n\n\t\t{ &hf_enumprinterdataex_val_dword_high,\n\t\t  { \"DWORD value (high)\",\n\t\t    \"spoolss.enumprinterdataex.val_dword.high\",\n\t\t    FT_UINT16, BASE_DEC, NULL, 0x0,\n\t\t    NULL, HFILL }},\n\n\t\t{ &hf_enumprinterdataex_value_null,\n\t\t  { \"Value\",\n\t\t    \"spoolss.enumprinterdataex.val_null\",\n\t\t    FT_UINT32, BASE_DEC, NULL, 0x0,\n\t\t    NULL, HFILL }},\n\n\t\t{ &hf_enumprinterdataex_value_uint,\n\t\t  { \"Value\",\n\t\t    \"spoolss.enumprinterdataex.val_uint\",\n\t\t    FT_UINT32, BASE_DEC, NULL, 0x0,\n\t\t    NULL, HFILL }},\n\n\t\t{ &hf_enumprinterdataex_value_binary,\n\t\t  { \"Value\",\n\t\t    \"spoolss.enumprinterdataex.val_binary\",\n\t\t    FT_BYTES, BASE_NONE, NULL, 0x0,\n\t\t    NULL, HFILL }},\n\n\t\t{ &hf_enumprinterdataex_value_multi_sz,\n\t\t  { \"Value\",\n\t\t    \"spoolss.enumprinterdataex.val_multi_sz\",\n\t\t    FT_BYTES, BASE_NONE, NULL, 0x0,\n\t\t    NULL, HFILL }},\n\n\t\t{ &hf_enumprinterdataex_val_dword_low,\n\t\t  { \"DWORD value (low)\",\n\t\t    \"spoolss.enumprinterdataex.val_dword.low\",\n\t\t    FT_UINT16, BASE_DEC, NULL, 0x0,\n\t\t    NULL, HFILL }},\n\n\t\t/* RouterReplyPrinter RPC */\n\n\t\t{ &hf_routerreplyprinter_condition,\n\t\t  { \"Condition\", \"spoolss.routerreplyprinter.condition\",\n\t\t    FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_routerreplyprinter_unknown1,\n\t\t  { \"Unknown1\", \"spoolss.routerreplyprinter.unknown1\",\n\t\t    FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_routerreplyprinter_changeid,\n\t\t  { \"Change id\", \"spoolss.routerreplyprinter.changeid\",\n\t\t    FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t/* EnumPrinterKey RPC */\n\n\t\t{ &hf_keybuffer_size,\n\t\t  { \"Key Buffer size\", \"spoolss.keybuffer.size\", FT_UINT32,\n\t\t    BASE_DEC, NULL, 0x0, \"Size of buffer\", HFILL }},\n\n\t\t/* SetJob RPC */\n\n\t\t{ &hf_setjob_cmd,\n\t\t  { \"Set job command\", \"spoolss.setjob.cmd\", FT_UINT32,\n\t\t    BASE_DEC, VALS(setjob_commands), 0x0, \"Printer data name\",\n\t\t    HFILL }},\n\n\t\t/* EnumJobs RPC */\n\n\t\t{ &hf_enumjobs_firstjob,\n\t\t  { \"First job\", \"spoolss.enumjobs.firstjob\", FT_UINT32,\n\t\t    BASE_DEC, NULL, 0x0, \"Index of first job to return\",\n\t\t    HFILL }},\n\n\t\t{ &hf_enumjobs_numjobs,\n\t\t  { \"Num jobs\", \"spoolss.enumjobs.numjobs\", FT_UINT32,\n\t\t    BASE_DEC, NULL, 0x0, \"Number of jobs to return\", HFILL }},\n\n\t\t/* Security descriptor buffer */\n\n\t\t{ &hf_secdescbuf_maxlen,\n\t\t  { \"Max len\", \"spoolss.secdescbuf.max_len\",\n\t\t    FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_secdescbuf_undoc,\n\t\t  { \"Undocumented\", \"spoolss.secdescbuf.undoc\",\n\t\t    FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_secdescbuf_len,\n\t\t  { \"Length\", \"spoolss.secdescbuf.len\",\n\t\t    FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t/* Spool printer info */\n\n\t\t{ &hf_spool_printer_info_devmode_ptr,\n\t\t  { \"Devmode pointer\", \"spoolss.spoolprinterinfo.devmode_ptr\",\n\t\t    FT_UINT32, BASE_HEX, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_spool_printer_info_secdesc_ptr,\n\t\t  { \"Secdesc pointer\", \"spoolss.spoolprinterinfo.secdesc_ptr\",\n\t\t    FT_UINT32, BASE_HEX, NULL, 0, NULL, HFILL }},\n\n\t\t/* WritePrinter RPC */\n\n\t\t{ &hf_writeprinter_numwritten,\n\t\t  { \"Num written\", \"spoolss.writeprinter.numwritten\",\n\t\t    FT_UINT32, BASE_DEC, NULL, 0x0, \"Number of bytes written\",\n\t\t    HFILL }},\n\n\t\t/* Setprinterdataex RPC */\n\n\t\t{ &hf_setprinterdataex_max_len,\n\t\t  { \"Max len\", \"spoolss.setprinterdataex.max_len\",\n\t\t    FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_setprinterdataex_real_len,\n\t\t  { \"Real len\", \"spoolss.setprinterdataex.real_len\",\n\t\t    FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_setprinterdataex_data,\n\t\t  { \"Data\", \"spoolss.setprinterdataex.data\",\n\t\t    FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL }},\n\n\t\t/* Specific access rights */\n\n\t\t{ &hf_access_required,\n\t\t  { \"Access required\", \"spoolss.access_required\",\n\t\t    FT_UINT32, BASE_HEX, NULL, 0x0, NULL,\n\t\t    HFILL }},\n\n\t\t{ &hf_server_access_admin,\n\t\t  { \"Server admin\", \"spoolss.access_mask.server_admin\",\n\t\t    FT_BOOLEAN, 32, TFS(&tfs_set_notset),\n\t\t    SERVER_ACCESS_ADMINISTER, NULL, HFILL }},\n\n\t\t{ &hf_server_access_enum,\n\t\t  { \"Server enum\", \"spoolss.access_mask.server_enum\",\n\t\t    FT_BOOLEAN, 32, TFS(&tfs_set_notset),\n\t\t    SERVER_ACCESS_ENUMERATE, NULL, HFILL }},\n\n\t\t{ &hf_printer_access_admin,\n\t\t  { \"Printer admin\", \"spoolss.access_mask.printer_admin\",\n\t\t    FT_BOOLEAN, 32, TFS(&tfs_set_notset),\n\t\t    PRINTER_ACCESS_ADMINISTER, NULL, HFILL }},\n\n\t\t{ &hf_printer_access_use,\n\t\t  { \"Printer use\", \"spoolss.access_mask.printer_use\",\n\t\t    FT_BOOLEAN, 32, TFS(&tfs_set_notset),\n\t\t    PRINTER_ACCESS_USE, NULL, HFILL }},\n\n\t\t{ &hf_job_access_admin,\n\t\t  { \"Job admin\", \"spoolss.access_mask.job_admin\",\n\t\t    FT_BOOLEAN, 32, TFS(&tfs_set_notset),\n\t\t    JOB_ACCESS_ADMINISTER, NULL, HFILL }},\n\n\t\t/* Printer information */\n\n\t\t{ &hf_printer_cjobs,\n\t\t  { \"CJobs\", \"spoolss.printer.cjobs\", FT_UINT32,\n\t\t    BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_printer_total_jobs,\n\t\t  { \"Total jobs\", \"spoolss.printer.total_jobs\", FT_UINT32,\n\t\t    BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_printer_total_bytes,\n\t\t  { \"Total bytes\", \"spoolss.printer.total_bytes\", FT_UINT32,\n\t\t    BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_printer_global_counter,\n\t\t  { \"Global counter\", \"spoolss.printer.global_counter\",\n\t\t    FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_printer_total_pages,\n\t\t  { \"Total pages\", \"spoolss.printer.total_pages\", FT_UINT32,\n\t\t    BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_printer_major_version,\n\t\t  { \"Major version\", \"spoolss.printer.major_version\",\n\t\t    FT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_printer_build_version,\n\t\t  { \"Build version\", \"spoolss.printer.build_version\",\n\t\t    FT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_printer_unk7,\n\t\t  { \"Unknown 7\", \"spoolss.printer.unknown7\", FT_UINT32,\n\t\t    BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_printer_unk8,\n\t\t  { \"Unknown 8\", \"spoolss.printer.unknown8\", FT_UINT32,\n\t\t    BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_printer_unk9,\n\t\t  { \"Unknown 9\", \"spoolss.printer.unknown9\", FT_UINT32,\n\t\t    BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_printer_session_ctr,\n\t\t  { \"Session counter\", \"spoolss.printer.session_ctr\",\n\t\t    FT_UINT32, BASE_DEC, NULL, 0, \"Sessopm counter\", HFILL }},\n\n\t\t{ &hf_printer_unk11,\n\t\t  { \"Unknown 11\", \"spoolss.printer.unknown11\", FT_UINT32,\n\t\t    BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_printer_printer_errors,\n\t\t  { \"Printer errors\", \"spoolss.printer.printer_errors\",\n\t\t    FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_printer_unk13,\n\t\t  { \"Unknown 13\", \"spoolss.printer.unknown13\", FT_UINT32,\n\t\t    BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_printer_unk14,\n\t\t  { \"Unknown 14\", \"spoolss.printer.unknown14\", FT_UINT32,\n\t\t    BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_printer_unk15,\n\t\t  { \"Unknown 15\", \"spoolss.printer.unknown15\", FT_UINT32,\n\t\t    BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_printer_unk16,\n\t\t  { \"Unknown 16\", \"spoolss.printer.unknown16\", FT_UINT32,\n\t\t    BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_printer_changeid,\n\t\t  { \"Change id\", \"spoolss.printer.changeid\", FT_UINT32,\n\t\t    BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_printer_unk18,\n\t\t  { \"Unknown 18\", \"spoolss.printer.unknown18\", FT_UINT32,\n\t\t    BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_printer_unk20,\n\t\t  { \"Unknown 20\", \"spoolss.printer.unknown20\", FT_UINT32,\n\t\t    BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_printer_c_setprinter,\n\t\t  { \"Csetprinter\", \"spoolss.printer.c_setprinter\",\n\t\t    FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_printer_unk22,\n\t\t  { \"Unknown 22\", \"spoolss.printer.unknown22\",\n\t\t    FT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_printer_unk23,\n\t\t  { \"Unknown 23\", \"spoolss.printer.unknown23\",\n\t\t    FT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_printer_unk24,\n\t\t  { \"Unknown 24\", \"spoolss.printer.unknown24\",\n\t\t    FT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_printer_unk25,\n\t\t  { \"Unknown 25\", \"spoolss.printer.unknown25\",\n\t\t    FT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_printer_unk26,\n\t\t  { \"Unknown 26\", \"spoolss.printer.unknown26\",\n\t\t    FT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_printer_unk27,\n\t\t  { \"Unknown 27\", \"spoolss.printer.unknown27\",\n\t\t    FT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_printer_unk28,\n\t\t  { \"Unknown 28\", \"spoolss.printer.unknown28\",\n\t\t    FT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_printer_unk29,\n\t\t  { \"Unknown 29\", \"spoolss.printer.unknown29\",\n\t\t    FT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_printer_flags,\n\t\t  { \"Flags\", \"spoolss.printer.flags\",\n\t\t    FT_UINT32, BASE_HEX, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_printer_priority,\n\t\t  { \"Priority\", \"spoolss.printer.priority\",\n\t\t    FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_printer_default_priority,\n\t\t  { \"Default Priority\", \"spoolss.printer.default_priority\",\n\t\t    FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_printer_averageppm,\n\t\t  { \"Average PPM\", \"spoolss.printer.averageppm\",\n\t\t    FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_printer_jobs,\n\t\t  { \"Jobs\", \"spoolss.printer.jobs\",\n\t\t    FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_printer_guid,\n\t\t  { \"GUID\", \"spoolss.printer.guid\", FT_STRING,\n\t\t    BASE_NONE, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_printer_action,\n\t\t  { \"Action\", \"spoolss.printer.action\", FT_UINT32, BASE_DEC,\n\t\t   VALS(getprinter_action_vals), 0, NULL, HFILL }},\n\t};\n\n\tstatic gint *ett[] = {\n\t\t&ett_dcerpc_spoolss,\n\t\t&ett_PRINTER_DATATYPE,\n\t\t&ett_DEVMODE_CTR,\n\t\t&ett_DEVMODE,\n\t\t&ett_DEVMODE_fields,\n\t\t&ett_USER_LEVEL_CTR,\n\t\t&ett_USER_LEVEL_1,\n\t\t&ett_BUFFER,\n\t\t&ett_PRINTER_INFO,\n\t\t&ett_SPOOL_PRINTER_INFO_LEVEL,\n\t\t&ett_PRINTER_INFO_0,\n\t\t&ett_PRINTER_INFO_1,\n\t\t&ett_PRINTER_INFO_2,\n\t\t&ett_PRINTER_INFO_3,\n\t\t&ett_PRINTER_INFO_7,\n\t\t&ett_RELSTR,\n\t\t&ett_RELSTR_ARRAY,\n\t\t&ett_FORM_REL,\n\t\t&ett_FORM_CTR,\n\t\t&ett_FORM_1,\n\t\t&ett_JOB_INFO_1,\n\t\t&ett_JOB_INFO_2,\n\t\t&ett_SEC_DESC_BUF,\n\t\t&ett_SYSTEM_TIME,\n\t\t&ett_DOC_INFO_1,\n\t\t&ett_DOC_INFO,\n\t\t&ett_DOC_INFO_CTR,\n\t\t&ett_printerdata_value,\n\t\t&ett_printerdata_data,\n\t\t&ett_writeprinter_buffer,\n\t\t&ett_DRIVER_INFO_1,\n\t\t&ett_DRIVER_INFO_2,\n\t\t&ett_DRIVER_INFO_3,\n\t\t&ett_DRIVER_INFO_6,\n\t\t&ett_DRIVER_INFO_101,\n\t\t&ett_rffpcnex_flags,\n\t\t&ett_notify_options_flags,\n\t\t&ett_NOTIFY_INFO_DATA,\n\t\t&ett_NOTIFY_OPTION,\n\t\t&ett_printer_attributes,\n\t\t&ett_job_status,\n\t\t&ett_enumprinters_flags,\n\t\t&ett_PRINTER_DATA_CTR,\n\t\t&ett_printer_enumdataex_value,\n\t};\n\n\tstatic ei_register_info ei[] = {\n\t\t{ &ei_unimplemented_dissector, { \"spoolss.unimplemented_dissector\", PI_UNDECODED, PI_WARN, \"Unimplemented dissector: SPOOLSS\", EXPFILL }},\n\t\t{ &ei_unknown_data, { \"spoolss.unknown_data\", PI_UNDECODED, PI_WARN, \"Unknown data follows\", EXPFILL }},\n\t\t{ &ei_printer_info_level, { \"spoolss.printer.unknown\", PI_PROTOCOL, PI_WARN, \"Unknown printer info level\", EXPFILL }},\n\t\t{ &ei_spool_printer_info_level, { \"spoolss.spool_printer.unknown\", PI_PROTOCOL, PI_WARN, \"Unknown spool printer info level\", EXPFILL }},\n\t\t{ &ei_form_level, { \"spoolss.form.level.unknown\", PI_PROTOCOL, PI_WARN, \"Unknown form info level\", EXPFILL }},\n\t\t{ &ei_job_info_level, { \"spoolss.job_info.level.unknown\", PI_PROTOCOL, PI_WARN, \"Unknown job info level\", EXPFILL }},\n\t\t{ &ei_driver_info_level, { \"spoolss.driver_info.level.unknown\", PI_PROTOCOL, PI_WARN, \"Unknown driver info level\", EXPFILL }},\n\t\t{ &ei_level, { \"spoolss.level.unknown\", PI_PROTOCOL, PI_WARN, \"Info level unknown\", EXPFILL }},\n\t\t{ &ei_notify_info_data_type, { \"spoolss.notify_info_data.type.unknown\", PI_PROTOCOL, PI_WARN, \"Unknown notify type\", EXPFILL }},\n\t\t{ &ei_enumprinterdataex_value, { \"spoolss.enumprinterdataex.val_unknown\", PI_PROTOCOL, PI_WARN, \"Unknown value type\", EXPFILL }},\n\t};\n\n\texpert_module_t* expert_dcerpc_spoolss;\n\n\tproto_dcerpc_spoolss = proto_register_protocol(\n\t\t\"Microsoft Spool Subsystem\", \"SPOOLSS\", \"spoolss\");\n\n\tproto_register_field_array(proto_dcerpc_spoolss, hf, array_length(hf));\n\tproto_register_subtree_array(ett, array_length(ett));\n\texpert_dcerpc_spoolss = expert_register_protocol(proto_dcerpc_spoolss);\n\texpert_register_field_array(expert_dcerpc_spoolss, ei, array_length(ei));\n}\n\n/* Protocol handoff */\n\nstatic e_guid_t uuid_dcerpc_spoolss = {\n\t0x12345678, 0x1234, 0xabcd,\n\t{ 0xef, 0x00, 0x01, 0x23, 0x45, 0x67, 0x89, 0xab }\n};\n\nstatic guint16 ver_dcerpc_spoolss = 1;\n\nvoid\nproto_reg_handoff_dcerpc_spoolss(void)\n{\n\n\t/* Register protocol as dcerpc */\n\n\tdcerpc_init_uuid(proto_dcerpc_spoolss, ett_dcerpc_spoolss,\n\t\t\t &uuid_dcerpc_spoolss, ver_dcerpc_spoolss,\n\t\t\t dcerpc_spoolss_dissectors, hf_opnum);\n}\n\n/*\n * Editor modelines  -  http://www.wireshark.org/tools/modelines.html\n *\n * Local variables:\n * c-basic-offset: 8\n * tab-width: 8\n * indent-tabs-mode: t\n * End:\n *\n * vi: set shiftwidth=8 tabstop=8 noexpandtab:\n * :indentSize=8:tabSize=8:noTabs=false:\n */\n", "code_before": "/* packet-dcerpc-spoolss.c\n * Routines for SMB \\PIPE\\spoolss packet disassembly\n * Copyright 2001-2003, Tim Potter <tpot@samba.org>\n *\n * Wireshark - Network traffic analyzer\n * By Gerald Combs <gerald@wireshark.org>\n * Copyright 1998 Gerald Combs\n *\n * SPDX-License-Identifier: GPL-2.0-or-later\n */\n\n/* TODO list:\n\n - audit of item lengths\n\n*/\n\n#include \"config.h\"\n\n\n#include <epan/packet.h>\n#include <epan/expert.h>\n#include <epan/tfs.h>\n\n#include <wsutil/ws_roundup.h>\n\n#include \"packet-dcerpc.h\"\n#include \"packet-dcerpc-nt.h\"\n#include \"packet-dcerpc-spoolss.h\"\n#include \"packet-windows-common.h\"\n\nvoid proto_register_dcerpc_spoolss(void);\nvoid proto_reg_handoff_dcerpc_spoolss(void);\n\n/* GetPrinterDriver2 */\n\nstatic int hf_clientmajorversion;\nstatic int hf_clientminorversion;\nstatic int hf_servermajorversion;\nstatic int hf_serverminorversion;\nstatic int hf_driverpath;\nstatic int hf_datafile;\nstatic int hf_configfile;\nstatic int hf_helpfile;\nstatic int hf_monitorname;\nstatic int hf_defaultdatatype;\nstatic int hf_driverinfo_cversion;\nstatic int hf_dependentfiles;\nstatic int hf_previousdrivernames;\nstatic int hf_color_profiles;\nstatic int hf_core_driver_dependencies;\nstatic int hf_driverdate;\nstatic int hf_min_inbox_driverdate;\nstatic int hf_padding;\nstatic int hf_driver_version_low;\nstatic int hf_driver_version_high;\nstatic int hf_min_inbox_driver_version_low;\nstatic int hf_min_inbox_driver_version_high;\nstatic int hf_mfgname;\nstatic int hf_oemurl;\nstatic int hf_hardwareid;\nstatic int hf_provider;\n\n/* GetPrinter */\n\n/* Times */\n\nstatic int hf_start_time;\nstatic int hf_end_time;\nstatic int hf_elapsed_time;\nstatic int hf_device_not_selected_timeout;\nstatic int hf_transmission_retry_timeout;\n\n/****************************************************************************/\n\n/*\n * New hf index values - I'm in the process of doing a bit of a cleanup -tpot\n */\n\nstatic int hf_opnum;\nstatic int hf_hnd;\nstatic int hf_rc;\nstatic int hf_hresult;\nstatic int hf_offered;\nstatic int hf_needed;\nstatic int hf_returned;\nstatic int hf_buffer_size;\nstatic int hf_buffer_data;\nstatic int hf_string_parm_size;\nstatic int hf_string_parm_data;\nstatic int hf_offset;\nstatic int hf_level;\nstatic int hf_access_required;\n\nstatic int hf_printername;\nstatic int hf_machinename;\nstatic int hf_notifyname;\nstatic int hf_printerdesc;\nstatic int hf_printercomment;\nstatic int hf_servername;\nstatic int hf_sharename;\nstatic int hf_portname;\nstatic int hf_printerlocation;\nstatic int hf_drivername;\nstatic int hf_environment;\nstatic int hf_username;\nstatic int hf_documentname;\nstatic int hf_outputfile;\nstatic int hf_datatype;\nstatic int hf_textstatus;\nstatic int hf_sepfile;\nstatic int hf_printprocessor;\nstatic int hf_vendor_setup;\nstatic int hf_inf_path;\nstatic int hf_parameters;\nstatic int hf_core_printer_driver_ids;\nstatic int hf_core_driver_guid;\nstatic int hf_core_driver_size;\nstatic int hf_driver_version;\nstatic int hf_core_printer_driver_count;\nstatic int hf_package_id;\nstatic int hf_language;\nstatic int hf_driver_package_cab_size;\n\n/* Printer information */\n\nstatic int hf_printer_cjobs;\nstatic int hf_printer_total_jobs;\nstatic int hf_printer_total_bytes;\nstatic int hf_printer_global_counter;\nstatic int hf_printer_total_pages;\nstatic int hf_printer_major_version;\nstatic int hf_printer_build_version;\nstatic int hf_printer_unk7;\nstatic int hf_printer_unk8;\nstatic int hf_printer_unk9;\nstatic int hf_printer_session_ctr;\nstatic int hf_printer_unk11;\nstatic int hf_printer_printer_errors;\nstatic int hf_printer_unk13;\nstatic int hf_printer_unk14;\nstatic int hf_printer_unk15;\nstatic int hf_printer_unk16;\nstatic int hf_printer_changeid;\nstatic int hf_printer_unk18;\nstatic int hf_printer_unk20;\nstatic int hf_printer_c_setprinter;\nstatic int hf_printer_unk22;\nstatic int hf_printer_unk23;\nstatic int hf_printer_unk24;\nstatic int hf_printer_unk25;\nstatic int hf_printer_unk26;\nstatic int hf_printer_unk27;\nstatic int hf_printer_unk28;\nstatic int hf_printer_unk29;\nstatic int hf_printer_flags;\nstatic int hf_printer_priority;\nstatic int hf_printer_default_priority;\nstatic int hf_printer_jobs;\nstatic int hf_printer_averageppm;\nstatic int hf_printer_guid;\nstatic int hf_printer_action;\n\n/* Printer data */\n\nstatic int hf_printerdata;\nstatic int hf_printerdata_key;\nstatic int hf_printerdata_value;\nstatic int hf_printerdata_type;\nstatic int hf_printerdata_size; /* Length of printer data */\nstatic int hf_printerdata_data;\nstatic int hf_printerdata_data_sz;\nstatic int hf_printerdata_data_dword;\n\n/* Devicemode */\n\nstatic int hf_devmodectr_size;\n\nstatic int hf_devmode;\nstatic int hf_devmode_size;\nstatic int hf_devmode_spec_version;\nstatic int hf_devmode_driver_version;\nstatic int hf_devmode_size2;\nstatic int hf_devmode_driver_extra_len;\nstatic int hf_devmode_fields;\nstatic int hf_devmode_orientation;\nstatic int hf_devmode_paper_size;\nstatic int hf_devmode_paper_width;\nstatic int hf_devmode_paper_length;\nstatic int hf_devmode_scale;\nstatic int hf_devmode_copies;\nstatic int hf_devmode_default_source;\nstatic int hf_devmode_print_quality;\nstatic int hf_devmode_color;\nstatic int hf_devmode_duplex;\nstatic int hf_devmode_y_resolution;\nstatic int hf_devmode_tt_option;\nstatic int hf_devmode_collate;\nstatic int hf_devmode_log_pixels;\nstatic int hf_devmode_bits_per_pel;\nstatic int hf_devmode_pels_width;\nstatic int hf_devmode_pels_height;\nstatic int hf_devmode_display_flags;\nstatic int hf_devmode_display_freq;\nstatic int hf_devmode_icm_method;\nstatic int hf_devmode_icm_intent;\nstatic int hf_devmode_media_type;\nstatic int hf_devmode_dither_type;\nstatic int hf_devmode_reserved1;\nstatic int hf_devmode_reserved2;\nstatic int hf_devmode_panning_width;\nstatic int hf_devmode_panning_height;\nstatic int hf_devmode_driver_extra;\n\nstatic int hf_devmode_fields_orientation;\nstatic int hf_devmode_fields_papersize;\nstatic int hf_devmode_fields_paperlength;\nstatic int hf_devmode_fields_paperwidth;\nstatic int hf_devmode_fields_scale;\nstatic int hf_devmode_fields_position;\nstatic int hf_devmode_fields_nup;\nstatic int hf_devmode_fields_copies;\nstatic int hf_devmode_fields_defaultsource;\nstatic int hf_devmode_fields_printquality;\nstatic int hf_devmode_fields_color;\nstatic int hf_devmode_fields_duplex;\nstatic int hf_devmode_fields_yresolution;\nstatic int hf_devmode_fields_ttoption;\nstatic int hf_devmode_fields_collate;\nstatic int hf_devmode_fields_formname;\nstatic int hf_devmode_fields_logpixels;\nstatic int hf_devmode_fields_bitsperpel;\nstatic int hf_devmode_fields_pelswidth;\nstatic int hf_devmode_fields_pelsheight;\nstatic int hf_devmode_fields_displayflags;\nstatic int hf_devmode_fields_displayfrequency;\nstatic int hf_devmode_fields_icmmethod;\nstatic int hf_devmode_fields_icmintent;\nstatic int hf_devmode_fields_mediatype;\nstatic int hf_devmode_fields_dithertype;\nstatic int hf_devmode_fields_panningwidth;\nstatic int hf_devmode_fields_panningheight;\n\n/* Print job */\n\nstatic int hf_job_id;\nstatic int hf_job_priority;\nstatic int hf_job_position;\nstatic int hf_job_totalpages;\nstatic int hf_job_totalbytes;\nstatic int hf_job_pagesprinted;\nstatic int hf_job_bytesprinted;\nstatic int hf_job_size;\n\nstatic int hf_job_status;\nstatic int hf_job_status_paused;\nstatic int hf_job_status_error;\nstatic int hf_job_status_deleting;\nstatic int hf_job_status_spooling;\nstatic int hf_job_status_printing;\nstatic int hf_job_status_offline;\nstatic int hf_job_status_paperout;\nstatic int hf_job_status_printed;\nstatic int hf_job_status_deleted;\nstatic int hf_job_status_blocked;\nstatic int hf_job_status_user_intervention;\n\n/* Forms */\n\nstatic int hf_form;\nstatic int hf_form_level;\nstatic int hf_form_name;\nstatic int hf_form_flags;\nstatic int hf_form_unknown;\nstatic int hf_form_width;\nstatic int hf_form_height;\nstatic int hf_form_left_margin;\nstatic int hf_form_top_margin;\nstatic int hf_form_horiz_len;\nstatic int hf_form_vert_len;\n\nstatic int hf_enumforms_num;\n\n/* Print notify */\n\nstatic int hf_notify_options_version;\nstatic int hf_notify_options_flags;\nstatic int hf_notify_options_flags_refresh;\nstatic int hf_notify_options_count;\nstatic int hf_notify_option_type;\nstatic int hf_notify_option_reserved1;\nstatic int hf_notify_option_reserved2;\nstatic int hf_notify_option_reserved3;\nstatic int hf_notify_option_count;\nstatic int hf_notify_option_data_count;\nstatic int hf_notify_info_count;\nstatic int hf_notify_info_version;\nstatic int hf_notify_info_flags;\nstatic int hf_notify_info_data_type;\nstatic int hf_notify_info_data_count;\nstatic int hf_notify_info_data_id;\nstatic int hf_notify_info_data_value1;\nstatic int hf_notify_info_data_value2;\nstatic int hf_notify_info_data_bufsize;\nstatic int hf_notify_info_data_buffer;\nstatic int hf_notify_info_data_buffer_len;\nstatic int hf_notify_info_data_buffer_data;\n\nstatic int hf_notify_field;\n\nstatic int hf_printerlocal;\n\nstatic int hf_rrpcn_changelow;\nstatic int hf_rrpcn_changehigh;\nstatic int hf_rrpcn_unk0;\nstatic int hf_rrpcn_unk1;\n\nstatic int hf_replyopenprinter_unk0;\nstatic int hf_replyopenprinter_unk1;\n\nstatic int hf_devmode_devicename;\nstatic int hf_devmode_form_name;\nstatic int hf_relative_string;\nstatic int hf_value_name;\nstatic int hf_keybuffer;\nstatic int hf_value_string;\n\nstatic expert_field ei_unimplemented_dissector;\nstatic expert_field ei_unknown_data;\nstatic expert_field ei_spool_printer_info_level;\nstatic expert_field ei_printer_info_level;\nstatic expert_field ei_form_level;\nstatic expert_field ei_job_info_level;\nstatic expert_field ei_driver_info_level;\nstatic expert_field ei_level;\nstatic expert_field ei_notify_info_data_type;\nstatic expert_field ei_enumprinterdataex_value;\nstatic expert_field ei_buffer_size_too_long;\n\n/* Registry data types */\n\n#define DCERPC_REG_NONE                        0\n#define DCERPC_REG_SZ                          1\n#define DCERPC_REG_EXPAND_SZ                   2\n#define DCERPC_REG_BINARY                      3\n#define DCERPC_REG_DWORD                       4\n#define DCERPC_REG_DWORD_LE                    4        /* DWORD, little endian\n*/\n#define DCERPC_REG_DWORD_BE                    5        /* DWORD, big endian */\n#define DCERPC_REG_LINK                        6\n#define DCERPC_REG_MULTI_SZ                    7\n#define DCERPC_REG_RESOURCE_LIST               8\n#define DCERPC_REG_FULL_RESOURCE_DESCRIPTOR    9\n#define DCERPC_REG_RESOURCE_REQUIREMENTS_LIST 10\n\nstatic const value_string reg_datatypes[] = {\n\t{ DCERPC_REG_NONE, \"REG_NONE\" },\n\t{ DCERPC_REG_SZ, \"REG_SZ\" },\n\t{ DCERPC_REG_EXPAND_SZ, \"REG_EXPAND_SZ\" },\n\t{ DCERPC_REG_BINARY, \"REG_BINARY\" },\n\t{ DCERPC_REG_DWORD, \"REG_DWORD\" },\n/*\t  { DCERPC_REG_DWORD_LE, \"REG_DWORD_LE\" }, */\n\t{ DCERPC_REG_DWORD_BE, \"REG_DWORD_BE\" },\n\t{ DCERPC_REG_LINK, \"REG_LINK\" },\n\t{ DCERPC_REG_MULTI_SZ, \"REG_MULTI_SZ\" },\n\t{ DCERPC_REG_RESOURCE_LIST, \"REG_RESOURCE_LIST\" },\n\t{ DCERPC_REG_FULL_RESOURCE_DESCRIPTOR, \"REG_FULL_RESOURCE_DESCRIPTOR\" },\n\t{ DCERPC_REG_RESOURCE_REQUIREMENTS_LIST, \"REG_RESOURCE_REQUIREMENTS_LIST\" },\n\t{0, NULL }\n};\nstatic value_string_ext reg_datatypes_ext = VALUE_STRING_EXT_INIT(reg_datatypes);\n\n/****************************************************************************/\n\n/*\n * Dissect SPOOLSS specific access rights\n */\n\nstatic int hf_server_access_admin;\nstatic int hf_server_access_enum;\nstatic int hf_printer_access_admin;\nstatic int hf_printer_access_use;\nstatic int hf_job_access_admin;\n\nstatic void\nspoolss_printer_specific_rights(tvbuff_t *tvb, int offset, proto_tree *tree,\n\t\t\t\tuint32_t access)\n{\n\tproto_tree_add_boolean(\n\t\ttree, hf_printer_access_use, tvb, offset, 4, access);\n\n\tproto_tree_add_boolean(\n\t\ttree, hf_printer_access_admin, tvb, offset, 4, access);\n}\n\nstruct access_mask_info spoolss_printer_access_mask_info = {\n\t\"SPOOLSS printer\",\n\tspoolss_printer_specific_rights,\n\tNULL,\t\t\t/* Generic mapping table */\n\tNULL\t\t\t/* Standard mapping table */\n};\n\nstatic void\nspoolss_printserver_specific_rights(tvbuff_t *tvb, int offset,\n\t\t\t\t    proto_tree *tree, uint32_t access)\n{\n\tproto_tree_add_boolean(\n\t\ttree, hf_server_access_enum, tvb, offset, 4, access);\n\n\tproto_tree_add_boolean(\n\t\ttree, hf_server_access_admin, tvb, offset, 4, access);\n}\n\nstatic struct access_mask_info spoolss_printserver_access_mask_info = {\n\t\"SPOOLSS print server\",\n\tspoolss_printserver_specific_rights,\n\tNULL,\t\t\t/* Generic mapping table */\n\tNULL\t\t\t/* Standard mapping table */\n};\n\nstatic void\nspoolss_job_specific_rights(tvbuff_t *tvb, int offset,\n\t\t\t    proto_tree *tree, uint32_t access)\n{\n\tproto_tree_add_boolean(\n\t\ttree, hf_job_access_admin, tvb, offset, 4, access);\n}\n\nstatic struct access_mask_info spoolss_job_access_mask_info = {\n\t\"SPOOLSS job\",\n\tspoolss_job_specific_rights,\n\tNULL,\t\t\t/* Generic mapping table */\n\tNULL\t\t\t/* Standard mapping table */\n};\n\n/*\n * Routines to dissect a spoolss BUFFER\n */\n\ntypedef struct {\n\ttvbuff_t *tvb;\n\tproto_item *tree;\t/* Proto tree buffer located in */\n\tproto_item *item;\n} BUFFER;\n\nstatic int ett_BUFFER;\n\nstatic int\ndissect_spoolss_buffer_data(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\t    proto_tree *tree, dcerpc_info *di, uint8_t *drep)\n{\n\tBUFFER *b = (BUFFER *)di->private_data;\n\tproto_item *item;\n\tuint32_t size;\n\tconst uint8_t *data;\n\n\tif (di->conformant_run)\n\t\treturn offset;\n\n\t/* Dissect size and data */\n\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, tree, di, drep,\n\t\t\t\t    hf_buffer_size, &size);\n\n\t/* Before going any further, we must ensure the bytes\n\t   actually esist in the tvb */\n\tif ((uint32_t)tvb_reported_length_remaining(tvb, offset) < size) {\n\t\texpert_add_info(pinfo, tree, &ei_buffer_size_too_long);\n\t\treturn offset;\n\t}\n\n\toffset = dissect_ndr_uint8s(tvb, offset, pinfo, NULL, di, drep,\n\t\t\t\t    hf_buffer_data, size, &data);\n\n\titem = proto_tree_add_item(\n\t\ttree, hf_buffer_data, tvb, offset - size,\n\t\tsize, ENC_NA);\n\n\t/* Return buffer info */\n\n\tif (b) {\n\n\t\t/* I'm not sure about this.  Putting the buffer into\n\t\t   its own tvb makes sense and the dissection code is\n\t\t   much clearer, but the data is a proper subset of\n\t\t   the actual tvb.  Not adding the new data source\n\t\t   makes the hex display confusing as it switches\n\t\t   between the 'DCERPC over SMB' tvb and the buffer\n\t\t   tvb with no visual cues as to what is going on. */\n\n\t\tb->tvb = tvb_new_child_real_data(tvb, data, size, size);\n\t\tadd_new_data_source(pinfo, b->tvb, \"SPOOLSS buffer\");\n\n\t\tb->item = item;\n\t\tb->tree = proto_item_add_subtree(item, ett_BUFFER);\n\t}\n\n\treturn offset;\n}\n\n/* Dissect a spoolss buffer and return buffer data */\n\nstatic int\ndissect_spoolss_buffer(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t       proto_tree *tree, dcerpc_info *di, uint8_t *drep, BUFFER *b)\n{\n\tif (b)\n\t\tmemset(b, 0, sizeof(BUFFER));\n\n\tdi->private_data = b;\n\n\toffset = dissect_ndr_pointer(\n\t\ttvb, offset, pinfo, tree, di, drep,\n\t\tdissect_spoolss_buffer_data, NDR_POINTER_UNIQUE,\n\t\t\"Buffer\", -1);\n\n\treturn offset;\n}\n\nstatic int\ndissect_spoolss_string_parm_data(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\t    proto_tree *tree, dcerpc_info *di, uint8_t *drep)\n{\n\tuint32_t buffer_len, len;\n\tchar *s;\n\tproto_item *item = NULL;\n\n\tif (di->conformant_run)\n\t\treturn offset;\n\n\t/* Dissect size and data */\n\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, tree, di, drep,\n\t\t\t\thf_string_parm_size, &buffer_len);\n\n\ts = tvb_get_stringz_enc(pinfo->pool, tvb, offset, &len, ENC_UTF_16|ENC_LITTLE_ENDIAN);\n\n\tif (tree && buffer_len) {\n\t\ttvb_ensure_bytes_exist(tvb, offset, buffer_len);\n\n\t\titem = proto_tree_add_string(\n\t\t\ttree, hf_string_parm_data, tvb, offset, len, s);\n\t}\n\toffset += buffer_len;\n\n\tcol_append_fstr(pinfo->cinfo, COL_INFO, \", %s\", s);\n\n\t/* Append string to upper level item */\n\tif (tree && item) {\n\t\titem = item->parent != NULL ? item->parent : item;\n\t\tproto_item_append_text(item, \": %s\", s);\n\t}\n\n\treturn offset;\n}\n\n/* Dissect a spoolss string parameter */\n\nstatic int\ndissect_spoolss_string_parm(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t       proto_tree *tree, dcerpc_info *di, uint8_t *drep, const char *text)\n{\n\toffset = dissect_ndr_pointer(\n\t\ttvb, offset, pinfo, tree, di, drep,\n\t\tdissect_spoolss_string_parm_data, NDR_POINTER_UNIQUE,\n\t\ttext, -1);\n\n\treturn offset;\n}\n\n/*\n * SYSTEM_TIME\n */\n\nstatic int ett_SYSTEM_TIME;\n\nstatic int hf_time_year;\nstatic int hf_time_month;\nstatic int hf_time_dow;\nstatic int hf_time_day;\nstatic int hf_time_hour;\nstatic int hf_time_minute;\nstatic int hf_time_second;\nstatic int hf_time_msec;\n\nstatic int\ndissect_SYSTEM_TIME(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t    proto_tree *tree, dcerpc_info *di, uint8_t *drep, const char *name,\n\t\t    bool add_subtree, char **data)\n{\n\tproto_item *item = NULL;\n\tproto_tree *subtree = tree;\n\tuint16_t year, month, day, hour, minute, second, millisecond;\n\tchar *str;\n\n\tif (add_subtree) {\n\t\tsubtree = proto_tree_add_subtree(tree, tvb, offset, 16, ett_SYSTEM_TIME, &item, name);\n\t}\n\n\toffset = dissect_ndr_uint16(\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_time_year, &year);\n\n\toffset = dissect_ndr_uint16(\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_time_month, &month);\n\n\toffset = dissect_ndr_uint16(\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_time_dow, NULL);\n\n\toffset = dissect_ndr_uint16(\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_time_day, &day);\n\n\toffset = dissect_ndr_uint16(\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_time_hour, &hour);\n\n\toffset = dissect_ndr_uint16(\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_time_minute, &minute);\n\n\toffset = dissect_ndr_uint16(\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_time_second, &second);\n\n\toffset = dissect_ndr_uint16(\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_time_msec, &millisecond);\n\n\tstr = wmem_strdup_printf(pinfo->pool,\n\t\t\t      \"%d/%02d/%02d %02d:%02d:%02d.%03d\",\n\t\t\t      year, month, day, hour, minute, second,\n\t\t\t      millisecond);\n\n\tif (add_subtree)\n\t\tproto_item_append_text(item, \": %s\", str);\n\n\tif (data)\n\t\t*data = str;\n\n\treturn offset;\n}\n\nstatic int\ndissect_SYSTEM_TIME_ptr(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\tproto_tree *tree, dcerpc_info *di, uint8_t *drep)\n{\n\tdcerpc_call_value *dcv = (dcerpc_call_value *)di->call_data;\n\tchar *str;\n\n\n\toffset =  dissect_SYSTEM_TIME(\n\t\ttvb, offset, pinfo, tree, di, drep, NULL, false, &str);\n\tdcv->private_data = wmem_strdup(wmem_file_scope(), str);\n\n\treturn offset;\n}\n\n/*\n * SpoolssClosePrinter\n */\n\nstatic int\nSpoolssClosePrinter_q(tvbuff_t *tvb, int offset,\n\t\t\t\t packet_info *pinfo, proto_tree *tree,\n\t\t\t\t dcerpc_info *di, uint8_t *drep)\n{\n\te_ctx_hnd policy_hnd;\n\tchar *pol_name;\n\n\t/* Parse packet */\n\n\toffset = dissect_nt_policy_hnd(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_hnd, &policy_hnd, NULL,\n\t\tPIDL_POLHND_CLOSE);\n\n\tdcerpc_fetch_polhnd_data(&policy_hnd, &pol_name, NULL, NULL, NULL,\n\t\t\t     pinfo->num);\n\n\tif (pol_name)\n\t\tcol_append_fstr(pinfo->cinfo, COL_INFO, \", %s\",\n\t\t\t\tpol_name);\n\n\treturn offset;\n}\n\nstatic int\nSpoolssClosePrinter_r(tvbuff_t *tvb, int offset,\n\t\t\t\t packet_info *pinfo, proto_tree *tree,\n\t\t\t\t dcerpc_info *di, uint8_t *drep)\n{\n\t/* Parse packet */\n\n\toffset = dissect_nt_policy_hnd(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_hnd, NULL, NULL,\n\t\tPIDL_POLHND_USE);\n\n\n\toffset = dissect_doserror(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_rc, NULL);\n\n\treturn offset;\n}\n\n/* Dissect some printer data.  The get/set/enum printerdata routines all\n   store value/data in a uint8 array.  We could use the ndr routines for\n   this but that would result in one item for each byte in the printer\n   data. */\n\nstatic int ett_printerdata_data;\nstatic int ett_printerdata_value;\n\nstatic int\ndissect_printerdata_data(tvbuff_t *tvb, int offset,\n\t\t\t\t    packet_info *pinfo, proto_tree *tree,\n\t\t\t\t    dcerpc_info *di, uint8_t *drep, uint32_t type)\n{\n\tproto_item *item, *hidden_item;\n\tproto_tree *subtree;\n\tuint32_t size;\n\n\tsubtree = proto_tree_add_subtree(tree, tvb, offset, 0, ett_printerdata_data, &item, \"Data\");\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_printerdata_size, &size);\n\n\tif (size) {\n\n\t\toffset = dissect_ndr_uint8s(\n\t\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\t\thf_printerdata_data, size, NULL);\n\n\t\tswitch(type) {\n\t\tcase DCERPC_REG_SZ: {\n\t\t\tconst uint8_t *data;\n\n\t\t\thidden_item = proto_tree_add_item_ret_string(\n\t\t\t\ttree, hf_printerdata_data_sz, tvb,\n\t\t\t\toffset - size, size, ENC_UTF_16|ENC_LITTLE_ENDIAN, pinfo->pool, &data);\n\t\t\tproto_item_set_hidden(hidden_item);\n\n\t\t\tproto_item_append_text(item, \": %s\", data);\n\n\t\t\tcol_append_fstr(pinfo->cinfo, COL_INFO, \" = %s\", data);\n\t\t\tbreak;\n\t\t}\n\t\tcase DCERPC_REG_DWORD: {\n\t\t\tuint32_t data = tvb_get_letohl(tvb, offset - size);\n\n\t\t\tproto_item_append_text(item, \": 0x%08x\", data);\n\n\t\t\tcol_append_fstr(\n\t\t\t\t\tpinfo->cinfo, COL_INFO, \" = 0x%08x\",\n\t\t\t\t\tdata);\n\n\t\t\thidden_item = proto_tree_add_uint(\n\t\t\t\ttree, hf_printerdata_data_dword, tvb,\n\t\t\t\toffset - size, 4, data);\n\t\t\tproto_item_set_hidden(hidden_item);\n\n\t\t\tbreak;\n\t\t}\n\t\tcase DCERPC_REG_BINARY:\n\t\t\tcol_append_str(\n\t\t\t\t\tpinfo->cinfo, COL_INFO,\n\t\t\t\t\t\" = <binary data>\");\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tproto_item_set_len(item, size + 4);\n\n\treturn offset;\n}\n\n/*\n * SpoolssGetPrinterData\n */\n\nstatic int\nSpoolssGetPrinterData_q(tvbuff_t *tvb, int offset,\n\t\t\t\t   packet_info *pinfo, proto_tree *tree,\n\t\t\t\t   dcerpc_info *di, uint8_t *drep)\n{\n\tdcerpc_call_value *dcv = (dcerpc_call_value *)di->call_data;\n\tchar *value_name;\n\tproto_item *hidden_item;\n\n\thidden_item = proto_tree_add_uint(\n\t\ttree, hf_printerdata, tvb, offset, 0, 1);\n\tproto_item_set_hidden(hidden_item);\n\n\t/* Parse packet */\n\n\toffset = dissect_nt_policy_hnd(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_hnd, NULL, NULL,\n\t\tPIDL_POLHND_USE);\n\n\n\tvalue_name = NULL;\n\toffset = dissect_ndr_cvstring(\n\t\ttvb, offset, pinfo, tree, di, drep, sizeof(uint16_t),\n\t\thf_printerdata_value, true, &value_name);\n\t/* GetPrinterData() stores the printerdata in se_data */\n\tif(!pinfo->fd->visited){\n\t\tif(!dcv->se_data && value_name){\n\t\t\tdcv->se_data = wmem_strdup(wmem_file_scope(), value_name);\n\t\t}\n\t}\n\n\tcol_append_fstr(pinfo->cinfo, COL_INFO, \", %s\", value_name);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_offered, NULL);\n\n\treturn offset;\n}\n\nstatic int\nSpoolssGetPrinterData_r(tvbuff_t *tvb, int offset,\n\t\t\t\t   packet_info *pinfo, proto_tree *tree,\n\t\t\t\t   dcerpc_info *di, uint8_t *drep)\n{\n\tdcerpc_call_value *dcv = (dcerpc_call_value *)di->call_data;\n\tuint32_t type;\n\tproto_item *hidden_item;\n\tconst char *data;\n\n\thidden_item = proto_tree_add_uint(\n\t\ttree, hf_printerdata, tvb, offset, 0, 1);\n\tproto_item_set_hidden(hidden_item);\n\n\t/* Parse packet */\n\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, tree, di, drep,\n\t\t\t\t    hf_printerdata_type, &type);\n\n\tdata = (const char *)(dcv->se_data ? dcv->se_data : \"????\");\n\n\tcol_append_fstr(pinfo->cinfo, COL_INFO, \", %s\", data);\n\n\toffset = dissect_printerdata_data(\n\t\ttvb, offset, pinfo, tree, di, drep, type);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_needed, NULL);\n\n\toffset = dissect_doserror(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_rc, NULL);\n\n\treturn offset;\n}\n\n/*\n * SpoolssGetPrinterDataEx\n */\n\nstatic int\nSpoolssGetPrinterDataEx_q(tvbuff_t *tvb, int offset,\n\t\t\t\t     packet_info *pinfo, proto_tree *tree,\n\t\t\t\t     dcerpc_info *di, uint8_t *drep)\n{\n\tdcerpc_call_value *dcv = (dcerpc_call_value *)di->call_data;\n\tchar *key_name, *value_name;\n\tproto_item *hidden_item;\n\n\thidden_item = proto_tree_add_uint(\n\t\ttree, hf_printerdata, tvb, offset, 0, 1);\n\tproto_item_set_hidden(hidden_item);\n\n\t/* Parse packet */\n\n\toffset = dissect_nt_policy_hnd(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_hnd, NULL, NULL,\n\t\tPIDL_POLHND_USE);\n\n\tkey_name=NULL;\n\toffset = dissect_ndr_cvstring(\n\t\ttvb, offset, pinfo, tree, di, drep, sizeof(uint16_t),\n\t\thf_printerdata_key, true, &key_name);\n\n\tvalue_name=NULL;\n\toffset = dissect_ndr_cvstring(\n\t\ttvb, offset, pinfo, tree, di, drep, sizeof(uint16_t),\n\t\thf_printerdata_value, true, &value_name);\n\n\t/* GetPrinterDataEx() stores the key/value in se_data */\n\tif(!pinfo->fd->visited){\n\t\tif(!dcv->se_data){\n\t\t\tdcv->se_data = wmem_strdup_printf(wmem_file_scope(),\n\t\t\t\t\"%s==%s\",\n\t\t\t\tkey_name?key_name:\"\",\n\t\t\t\tvalue_name?value_name:\"\");\n\t\t}\n\t}\n\n\tif (dcv->se_data)\n\t\tcol_append_fstr(pinfo->cinfo, COL_INFO, \", %s\",\n\t\t\t\t(char *)dcv->se_data);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_needed, NULL);\n\n\treturn offset;\n}\n\nstatic int\nSpoolssGetPrinterDataEx_r(tvbuff_t *tvb, int offset,\n\t\t\t\t     packet_info *pinfo, proto_tree *tree,\n\t\t\t\t     dcerpc_info *di, uint8_t *drep)\n{\n\tdcerpc_call_value *dcv = (dcerpc_call_value *)di->call_data;\n\tuint32_t size, type;\n\tproto_item *hidden_item;\n\n\thidden_item = proto_tree_add_uint(\n\t\ttree, hf_printerdata, tvb, offset, 0, 1);\n\tproto_item_set_hidden(hidden_item);\n\n\t/* Parse packet */\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printerdata_type, &type);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_returned, &size);\n\n\tif (dcv->se_data) {\n\t\tcol_append_fstr(pinfo->cinfo, COL_INFO, \", %s\", (char *)dcv->se_data);\n\t}\n\n\tif (size)\n\t\tdissect_printerdata_data(tvb, offset, pinfo, tree, di, drep, type);\n\n\toffset += size;\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_needed, NULL);\n\n\toffset = dissect_doserror(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_rc, NULL);\n\n\treturn offset;\n}\n\n/*\n * SpoolssSetPrinterData\n */\n\nstatic int\nSpoolssSetPrinterData_q(tvbuff_t *tvb, int offset,\n\t\t\t\t   packet_info *pinfo, proto_tree *tree,\n\t\t\t\t   dcerpc_info *di, uint8_t *drep)\n{\n\tdcerpc_call_value *dcv = (dcerpc_call_value *)di->call_data;\n\tchar *value_name;\n\tuint32_t type;\n\tproto_item *hidden_item;\n\n\thidden_item = proto_tree_add_uint(\n\t\ttree, hf_printerdata, tvb, offset, 0, 1);\n\tproto_item_set_hidden(hidden_item);\n\n\t/* Parse packet */\n\n\toffset = dissect_nt_policy_hnd(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_hnd, NULL, NULL,\n\t\tPIDL_POLHND_USE);\n\n\tvalue_name=NULL;\n\toffset = dissect_ndr_cvstring(\n\t\ttvb, offset, pinfo, tree, di, drep, sizeof(uint16_t),\n\t\thf_printerdata_value, true, &value_name);\n\n\t/* GetPrinterDataEx() stores the key/value in se_data */\n\tif(!pinfo->fd->visited){\n\t\tif(!dcv->se_data){\n\t\t\tdcv->se_data = wmem_strdup(wmem_file_scope(),\n\t\t\t\tvalue_name?value_name:\"\");\n\t\t}\n\t}\n\n\n\tif (dcv->se_data){\n\t\tcol_append_fstr(pinfo->cinfo, COL_INFO, \", %s\", (char *)dcv->se_data);\n\t}\n\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, tree, di, drep,\n\t\t\t\t    hf_printerdata_type, &type);\n\n\toffset = dissect_printerdata_data(\n\t\ttvb, offset, pinfo, tree, di, drep, type);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_offered, NULL);\n\n\treturn offset;\n}\n\nstatic int\nSpoolssSetPrinterData_r(tvbuff_t *tvb, int offset,\n\t\t\t\t   packet_info *pinfo, proto_tree *tree,\n\t\t\t\t   dcerpc_info *di, uint8_t *drep)\n{\n\tproto_item *hidden_item;\n\n\thidden_item = proto_tree_add_uint(\n\t\ttree, hf_printerdata, tvb, offset, 0, 1);\n\tproto_item_set_hidden(hidden_item);\n\n\t/* Parse packet */\n\n\toffset = dissect_doserror(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_rc, NULL);\n\n\treturn offset;\n}\n\n/*\n * SpoolssSetPrinterDataEx\n */\n\nstatic int hf_setprinterdataex_max_len;\nstatic int hf_setprinterdataex_real_len;\nstatic int hf_setprinterdataex_data;\n\nstatic int\nSpoolssSetPrinterDataEx_q(tvbuff_t *tvb, int offset,\n\t\t\t\t     packet_info *pinfo, proto_tree *tree,\n\t\t\t\t     dcerpc_info *di, uint8_t *drep)\n{\n\tchar *key_name, *value_name;\n\tuint32_t max_len;\n\tproto_item *hidden_item;\n\n\thidden_item = proto_tree_add_uint(\n\t\ttree, hf_printerdata, tvb, offset, 0, 1);\n\tproto_item_set_hidden(hidden_item);\n\n\t/* Parse packet */\n\n\toffset = dissect_nt_policy_hnd(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_hnd, NULL, NULL,\n\t\tPIDL_POLHND_USE);\n\n\toffset = dissect_ndr_cvstring(\n\t\ttvb, offset, pinfo, tree, di, drep, sizeof(uint16_t),\n\t\thf_printerdata_key, true, &key_name);\n\n\toffset = dissect_ndr_cvstring(\n\t\ttvb, offset, pinfo, tree, di, drep, sizeof(uint16_t),\n\t\thf_printerdata_value, true, &value_name);\n\n\tcol_append_fstr(pinfo->cinfo, COL_INFO, \", %s/%s\",\n\t\t\t\tkey_name, value_name);\n\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, tree, di, drep,\n\t\t\t\t    hf_printerdata_type, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep,\n\t\thf_setprinterdataex_max_len, &max_len);\n\n\toffset = dissect_ndr_uint8s(\n\t\ttvb, offset, pinfo, tree, di, drep,\n\t\thf_setprinterdataex_data, max_len, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep,\n\t\thf_setprinterdataex_real_len, NULL);\n\n\treturn offset;\n}\n\nstatic int\nSpoolssSetPrinterDataEx_r(tvbuff_t *tvb, int offset,\n\t\t\t\t     packet_info *pinfo, proto_tree *tree,\n\t\t\t\t     dcerpc_info *di, uint8_t *drep)\n{\n\tproto_item *hidden_item;\n\n\thidden_item = proto_tree_add_uint(\n\t\ttree, hf_printerdata, tvb, offset, 0, 1);\n\tproto_item_set_hidden(hidden_item);\n\n\t/* Parse packet */\n\n\toffset = dissect_doserror(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_rc, NULL);\n\n\treturn offset;\n}\n\n/* XXX - \"name\" should be an hf_ value for an FT_STRING. */\nstatic int\ndissect_spoolss_uint16uni(tvbuff_t *tvb, int offset, packet_info *pinfo _U_,\n\t\t\t  proto_tree *tree, uint8_t *drep _U_, char **data,\n\t\t\t  int hf_name)\n{\n\tint len, remaining;\n\tchar *text;\n\n\toffset = WS_ROUNDUP_2(offset);\n\n\t/* Get remaining data in buffer as a string */\n\n\tremaining = tvb_reported_length_remaining(tvb, offset);\n\tif (remaining <= 0) {\n\t\tif (data)\n\t\t\t*data = wmem_strdup(pinfo->pool, \"\");\n\t\treturn offset;\n\t}\n\n\ttext = tvb_get_string_enc(pinfo->pool, tvb, offset, remaining, ENC_UTF_16|ENC_LITTLE_ENDIAN);\n\tlen = (int)strlen(text);\n\n\tproto_tree_add_string(tree, hf_name, tvb, offset, len * 2, text);\n\n\tif (data)\n\t\t*data = text;\n\n\treturn offset + (len + 1) * 2;\n}\n\n/*\n * DEVMODE\n */\n\n/* Devicemode orientation values */\n\nstatic const value_string devmode_orientation_vals[] =\n{\n\t{ DEVMODE_ORIENTATION_PORTRAIT, \"Portrait\" },\n\t{ DEVMODE_ORIENTATION_LANDSCAPE, \"Landscape\" },\n\t{ 0, NULL }\n};\n\n/* Paper size values.  International paper sizes is a fascinating\n   topic.  No seriously!  (-: */\n\nstatic const value_string devmode_papersize_vals[] =\n{\n\t{ DEVMODE_PAPERSIZE_LETTER, \"Letter\" },\n\t{ DEVMODE_PAPERSIZE_LETTERSMALL, \"Letter (small)\" },\n\t{ DEVMODE_PAPERSIZE_TABLOID, \"Tabloid\" },\n\t{ DEVMODE_PAPERSIZE_LEDGER, \"Ledger\" },\n\t{ DEVMODE_PAPERSIZE_LEGAL, \"Legal\" },\n\t{ DEVMODE_PAPERSIZE_STATEMENT, \"Statement\" },\n\t{ DEVMODE_PAPERSIZE_EXECUTIVE, \"Executive\" },\n\t{ DEVMODE_PAPERSIZE_A3, \"A3\" },\n\t{ DEVMODE_PAPERSIZE_A4, \"A4\" },\n\t{ DEVMODE_PAPERSIZE_A4SMALL, \"A4 (small)\" },\n\t{ DEVMODE_PAPERSIZE_A5, \"A5\" },\n\t{ DEVMODE_PAPERSIZE_B4, \"B4\" },\n\t{ DEVMODE_PAPERSIZE_B5, \"B5\" },\n\t{ DEVMODE_PAPERSIZE_FOLIO, \"Folio\" },\n\t{ DEVMODE_PAPERSIZE_QUARTO, \"Quarto\" },\n\t{ DEVMODE_PAPERSIZE_10X14, \"10x14\" },\n\t{ DEVMODE_PAPERSIZE_11X17, \"11x17\" },\n\t{ DEVMODE_PAPERSIZE_NOTE, \"Note\" },\n\t{ DEVMODE_PAPERSIZE_ENV9, \"Envelope #9\" },\n\t{ DEVMODE_PAPERSIZE_ENV10, \"Envelope #10\" },\n\t{ DEVMODE_PAPERSIZE_ENV11, \"Envelope #11\" },\n\t{ DEVMODE_PAPERSIZE_ENV12, \"Envelope #12\" },\n\t{ DEVMODE_PAPERSIZE_ENV14, \"Envelope #14\" },\n\t{ DEVMODE_PAPERSIZE_CSHEET, \"C sheet\" },\n\t{ DEVMODE_PAPERSIZE_DSHEET, \"D sheet\" },\n\t{ DEVMODE_PAPERSIZE_ESHEET, \"E sheet\" },\n\t{ DEVMODE_PAPERSIZE_ENVDL, \"Envelope DL\" },\n\t{ DEVMODE_PAPERSIZE_ENVC5, \"Envelope C5\" },\n\t{ DEVMODE_PAPERSIZE_ENVC3, \"Envelope C3\" },\n\t{ DEVMODE_PAPERSIZE_ENVC4, \"Envelope C4\" },\n\t{ DEVMODE_PAPERSIZE_ENVC6, \"Envelope C6\" },\n\t{ DEVMODE_PAPERSIZE_ENVC65, \"Envelope C65\" },\n\t{ DEVMODE_PAPERSIZE_ENVB4, \"Envelope B4\" },\n\t{ DEVMODE_PAPERSIZE_ENVB5, \"Envelope B5\" },\n\t{ DEVMODE_PAPERSIZE_ENVB6, \"Envelope B6\" },\n\t{ DEVMODE_PAPERSIZE_ENVITALY, \"Envelope (Italy)\" },\n\t{ DEVMODE_PAPERSIZE_ENVMONARCH, \"Envelope (Monarch)\" },\n\t{ DEVMODE_PAPERSIZE_ENVPERSONAL, \"Envelope (Personal)\" },\n\t{ DEVMODE_PAPERSIZE_FANFOLDUS, \"Fanfold (US)\" },\n\t{ DEVMODE_PAPERSIZE_FANFOLDSTDGERMAN, \"Fanfold (Std German)\" },\n\t{ DEVMODE_PAPERSIZE_FANFOLDLGLGERMAN, \"Fanfold (Legal German)\" },\n\t{ DEVMODE_PAPERSIZE_ISOB4, \"B4 (ISO)\" },\n\t{ DEVMODE_PAPERSIZE_JAPANESEPOSTCARD, \"Japanese postcard\" },\n\t{ DEVMODE_PAPERSIZE_9X11, \"9x11\" },\n\t{ DEVMODE_PAPERSIZE_10X11, \"10x11\" },\n\t{ DEVMODE_PAPERSIZE_15X11, \"15x11\" },\n\t{ DEVMODE_PAPERSIZE_ENVINVITE, \"Envelope (Invite)\" },\n\t{ DEVMODE_PAPERSIZE_RESERVED48, \"Reserved (48)\" },\n\t{ DEVMODE_PAPERSIZE_RESERVED49, \"Reserved (49)\" },\n\t{ DEVMODE_PAPERSIZE_LETTEREXTRA, \"Letter (Extra)\" },\n\t{ DEVMODE_PAPERSIZE_LEGALEXTRA, \"Legal (Extra)\" },\n\t{ DEVMODE_PAPERSIZE_TABLOIDEXTRA, \"Tabloid (Extra)\" },\n\t{ DEVMODE_PAPERSIZE_A4EXTRA, \"A4 (Extra)\" },\n\t{ DEVMODE_PAPERSIZE_LETTERTRANS, \"Letter (Transverse)\" },\n\t{ DEVMODE_PAPERSIZE_A4TRANS, \"A4 (Transverse)\" },\n\t{ DEVMODE_PAPERSIZE_LETTEREXTRATRANS, \"Letter (Extra, Transverse)\" },\n\t{ DEVMODE_PAPERSIZE_APLUS, \"A+\" },\n\t{ DEVMODE_PAPERSIZE_BPLUS, \"B+\" },\n\t{ DEVMODE_PAPERSIZE_LETTERPLUS, \"Letter+\" },\n\t{ DEVMODE_PAPERSIZE_A4PLUS, \"A4+\" },\n\t{ DEVMODE_PAPERSIZE_A5TRANS, \"A5 (Transverse)\" },\n\t{ DEVMODE_PAPERSIZE_B5TRANS, \"B5 (Transverse)\" },\n\t{ DEVMODE_PAPERSIZE_A3EXTRA, \"A3 (Extra)\" },\n\t{ DEVMODE_PAPERSIZE_A5EXTRA, \"A5 (Extra)\" },\n\t{ DEVMODE_PAPERSIZE_B5EXTRA, \"B5 (Extra)\" },\n\t{ DEVMODE_PAPERSIZE_A2, \"A2\" },\n\t{ DEVMODE_PAPERSIZE_A3TRANS, \"A3 (Transverse)\" },\n\t{ DEVMODE_PAPERSIZE_A3EXTRATRANS, \"A3 (Extra, Transverse\" },\n\t{ DEVMODE_PAPERSIZE_DBLJAPANESEPOSTCARD, \"Double Japanese Postcard\" },\n\t{ DEVMODE_PAPERSIZE_A6, \"A6\" },\n\t{ DEVMODE_PAPERSIZE_JENVKAKU2, \"Japanese Envelope (Kaku #2)\" },\n\t{ DEVMODE_PAPERSIZE_JENVKAKU3, \"Japanese Envelope (Kaku #3)\" },\n\t{ DEVMODE_PAPERSIZE_JENVCHOU3, \"Japanese Envelope (Chou #3)\" },\n\t{ DEVMODE_PAPERSIZE_JENVCHOU4, \"Japanese Envelope (Chou #4)\" },\n\t{ DEVMODE_PAPERSIZE_LETTERROT, \"Letter (Rotated)\" },\n\t{ DEVMODE_PAPERSIZE_A3ROT, \"A3 (Rotated)\" },\n\t{ DEVMODE_PAPERSIZE_A4ROT, \"A4 (Rotated)\" },\n\t{ DEVMODE_PAPERSIZE_A5ROT, \"A5 (Rotated)\" },\n\t{ DEVMODE_PAPERSIZE_B4JISROT, \"B4 (JIS, Rotated)\" },\n\t{ DEVMODE_PAPERSIZE_B5JISROT, \"B5 (JIS, Rotated)\"},\n\t{ DEVMODE_PAPERSIZE_JAPANESEPOSTCARDROT,\n\t  \"Japanese Postcard (Rotated)\" },\n\t{ DEVMODE_PAPERSIZE_DBLJAPANESEPOSTCARDROT82,\n\t  \"Double Japanese Postcard (Rotated)\" },\n\t{ DEVMODE_PAPERSIZE_A6ROT, \"A6 (Rotated)\" },\n\t{ DEVMODE_PAPERSIZE_JENVKAKU2ROT,\n\t  \"Japanese Envelope (Kaku #2, Rotated)\" },\n\t{ DEVMODE_PAPERSIZE_JENVKAKU3ROT,\n\t  \"Japanese Envelope (Kaku #3, Rotated)\" },\n\t{ DEVMODE_PAPERSIZE_JENVCHOU3ROT,\n\t  \"Japanese Envelope (Chou #3, Rotated)\" },\n\t{ DEVMODE_PAPERSIZE_JENVCHOU4ROT,\n\t  \"Japanese Envelope (Chou #4, Rotated)\" },\n\t{ DEVMODE_PAPERSIZE_B6JIS, \"B6 (JIS)\" },\n\t{ DEVMODE_PAPERSIZE_B6JISROT, \"B6 (JIS, Rotated)\" },\n\t{ DEVMODE_PAPERSIZE_12X11, \"12x11\" },\n\t{ DEVMODE_PAPERSIZE_JENVYOU4, \"Japanese Envelope (You #4)\" },\n\t{ DEVMODE_PAPERSIZE_JENVYOU4ROT,\n\t  \"Japanese Envelope (You #4, Rotated\" },\n\t{ DEVMODE_PAPERSIZE_P16K, \"PRC 16K\" },\n\t{ DEVMODE_PAPERSIZE_P32K, \"PRC 32K\" },\n\t{ DEVMODE_PAPERSIZE_P32KBIG, \"P32K (Big)\" },\n\t{ DEVMODE_PAPERSIZE_PENV1, \"PRC Envelope #1\" },\n\t{ DEVMODE_PAPERSIZE_PENV2, \"PRC Envelope #2\" },\n\t{ DEVMODE_PAPERSIZE_PENV3, \"PRC Envelope #3\" },\n\t{ DEVMODE_PAPERSIZE_PENV4, \"PRC Envelope #4\" },\n\t{ DEVMODE_PAPERSIZE_PENV5, \"PRC Envelope #5\" },\n\t{ DEVMODE_PAPERSIZE_PENV6, \"PRC Envelope #6\" },\n\t{ DEVMODE_PAPERSIZE_PENV7, \"PRC Envelope #7\" },\n\t{ DEVMODE_PAPERSIZE_PENV8, \"PRC Envelope #8\" },\n\t{ DEVMODE_PAPERSIZE_PENV9, \"PRC Envelope #9\" },\n\t{ DEVMODE_PAPERSIZE_PENV10, \"PRC Envelope #10\" },\n\t{ DEVMODE_PAPERSIZE_P16KROT, \"PRC 16K (Rotated)\" },\n\t{ DEVMODE_PAPERSIZE_P32KROT, \"PRC 32K (Rotated)\" },\n\t{ DEVMODE_PAPERSIZE_P32KBIGROT, \"PRC 32K (Big, Rotated)\" },\n\t{ DEVMODE_PAPERSIZE_PENV1ROT, \"PRC Envelope #1 (Rotated)\" },\n\t{ DEVMODE_PAPERSIZE_PENV2ROT, \"PRC Envelope #2 (Rotated)\" },\n\t{ DEVMODE_PAPERSIZE_PENV3ROT, \"PRC Envelope #3 (Rotated)\" },\n\t{ DEVMODE_PAPERSIZE_PENV4ROT, \"PRC Envelope #4 (Rotated)\" },\n\t{ DEVMODE_PAPERSIZE_PENV5ROT, \"PRC Envelope #5 (Rotated)\" },\n\t{ DEVMODE_PAPERSIZE_PENV6ROT, \"PRC Envelope #6 (Rotated)\" },\n\t{ DEVMODE_PAPERSIZE_PENV7ROT, \"PRC Envelope #7 (Rotated)\" },\n\t{ DEVMODE_PAPERSIZE_PENV8ROT, \"PRC Envelope #8 (Rotated)\" },\n\t{ DEVMODE_PAPERSIZE_PENV9ROT, \"PRC Envelope #9 (Rotated)\" },\n\t{ DEVMODE_PAPERSIZE_PENV10ROT, \"PRC Envelope #10 (Rotated)\" },\n\t{ 0, NULL }\n};\nstatic value_string_ext devmode_papersize_vals_ext = VALUE_STRING_EXT_INIT(devmode_papersize_vals);\n\n/* List of observed specversions */\n\nstatic const value_string devmode_specversion_vals[] =\n{\n\t{ 0x0320, \"Observed\" },\n\t{ 0x0400, \"Observed\" },\n\t{ 0x0401, \"Observed\" },\n\t{ 0x040d, \"Observed\" },\n\t{ 0, NULL }\n};\n\n/* Paper sources */\n\nstatic const value_string devmode_papersource_vals[] =\n{\n\t{ DEVMODE_PAPERSOURCE_UPPER, \"Upper\" },\n\t{ DEVMODE_PAPERSOURCE_LOWER, \"Lower\" },\n\t{ DEVMODE_PAPERSOURCE_MIDDLE, \"Middle\" },\n\t{ DEVMODE_PAPERSOURCE_MANUAL, \"Manual\" },\n\t{ DEVMODE_PAPERSOURCE_ENV, \"Envelope\" },\n\t{ DEVMODE_PAPERSOURCE_ENVMANUAL, \"Envelope Manual\" },\n\t{ DEVMODE_PAPERSOURCE_AUTO, \"Auto\" },\n\t{ DEVMODE_PAPERSOURCE_TRACTOR, \"Tractor\" },\n\t{ DEVMODE_PAPERSOURCE_SMALLFMT, \"Small Format\" },\n\t{ DEVMODE_PAPERSOURCE_LARGEFMAT, \"Large Format\" },\n\t{ DEVMODE_PAPERSOURCE_LARGECAP, \"Large Capacity\" },\n\t{ DEVMODE_PAPERSOURCE_CASSETTE, \"Cassette\" },\n\t{ DEVMODE_PAPERSOURCE_FORMSRC, \"Form Source\" },\n\t{ 0, NULL }\n};\nstatic value_string_ext devmode_papersource_vals_ext = VALUE_STRING_EXT_INIT(devmode_papersource_vals);\n\n/* Print quality */\n\nstatic const value_string devmode_printquality_vals[] =\n{\n\t{ DEVMODE_PRINTQUALITY_HIGH, \"High\" },\n\t{ DEVMODE_PRINTQUALITY_MEDIUM, \"Medium\" },\n\t{ DEVMODE_PRINTQUALITY_LOW, \"Low\" },\n\t{ DEVMODE_PRINTQUALITY_DRAFT, \"Draft\" },\n\t{ 0, NULL }\n};\n\n/* Color */\n\nstatic const value_string devmode_colour_vals[] =\n{\n\t{ DEVMODE_COLOUR_COLOUR, \"Colour\" },\n\t{ DEVMODE_COLOUR_MONO, \"Monochrome\" },\n\t{ 0, NULL }\n};\n\n/* TrueType options */\n\nstatic const value_string devmode_ttoption_vals[] =\n{\n\t{ 0, \"Not set\" },\n\t{ DEVMODE_TTOPTION_BITMAP, \"Bitmap\" },\n\t{ DEVMODE_TTOPTION_DOWNLOAD, \"Download\" },\n\t{ DEVMODE_TTOPTION_DOWNLOAD_OUTLINE, \"Download outline\" },\n\t{ DEVMODE_TTOPTION_SUBDEV, \"Substitute device fonts\" },\n\t{ 0, NULL }\n};\n\n/* Collate info */\n\nstatic const value_string devmode_collate_vals[] =\n{\n\t{ DEVMODE_COLLATE_FALSE, \"False\" },\n\t{ DEVMODE_COLLATE_TRUE, \"True\" },\n\t{ 0, NULL }\n};\n\n/* Duplex info */\n\nstatic const value_string devmode_duplex_vals[] =\n{\n\t{ DEVMODE_DUPLEX_SIMPLEX, \"Simplex\" },\n\t{ DEVMODE_DUPLEX_VERT, \"Vertical\" },\n\t{ DEVMODE_DUPLEX_HORIZ, \"Horizontal\" },\n\t{ 0, NULL }\n};\n\nstatic const value_string devmode_displayflags_vals[] =\n{\n\t{ 0, \"Colour\" },\n\t{ DEVMODE_DISPLAYFLAGS_GRAYSCALE, \"Grayscale\" },\n\t{ DEVMODE_DISPLAYFLAGS_INTERLACED, \"Interlaced\" },\n\t{ 0, NULL }\n};\n\nstatic const value_string devmode_icmmethod_vals[] =\n{\n\t{ DEVMODE_ICMMETHOD_NONE, \"None\" },\n\t{ DEVMODE_ICMMETHOD_SYSTEM, \"System\" },\n\t{ DEVMODE_ICMMETHOD_DRIVER, \"Driver\" },\n\t{ DEVMODE_ICMMETHOD_DEVICE, \"Device\" },\n\t{ 0, NULL }\n};\n\nstatic const value_string devmode_icmintent_vals[] =\n{\n\t{ 0, \"Not set\" },\n\t{ DEVMODE_ICMINTENT_SATURATE, \"Saturate\" },\n\t{ DEVMODE_ICMINTENT_CONTRAST, \"Contrast\" },\n\t{ DEVMODE_ICMINTENT_COLORIMETRIC, \"Colorimetric\" },\n\t{ DEVMODE_ICMINTENT_ABS_COLORIMETRIC, \"Absolute colorimetric\" },\n\t{ 0, NULL }\n};\n\nstatic const value_string devmode_mediatype_vals[] =\n{\n\t{ 0, \"Not set\" },\n\t{ DEVMODE_MEDIATYPE_STANDARD, \"Standard\" },\n\t{ DEVMODE_MEDIATYPE_TRANSPARENCY, \"Transparency\" },\n\t{ DEVMODE_MEDIATYPE_GLOSSY, \"Glossy\" },\n\t{ 0, NULL }\n};\n\nstatic const value_string devmode_dithertype_vals[] =\n{\n\t{ 0, \"Not set\" },\n\t{ DEVMODE_DITHERTYPE_NONE, \"None\" },\n\t{ DEVMODE_DITHERTYPE_COARSE, \"Coarse\" },\n\t{ DEVMODE_DITHERTYPE_LINE, \"Line\" },\n\t{ DEVMODE_DITHERTYPE_LINEART, \"Line art\" },\n\t{ DEVMODE_DITHERTYPE_ERRORDIFFUSION, \"Error diffusion\" },\n\t{ DEVMODE_DITHERTYPE_RESERVED6, \"Reserved 6\" },\n\t{ DEVMODE_DITHERTYPE_RESERVED7, \"Reserved 7\" },\n\t{ DEVMODE_DITHERTYPE_GRAYSCALE, \"Grayscale\" },\n\t{ 0, NULL }\n};\n\nstatic int ett_DEVMODE_fields;\n\nstatic int\ndissect_DEVMODE_fields(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t       proto_tree *tree, dcerpc_info *di, uint8_t *drep, uint32_t *pdata)\n{\n\tuint32_t fields;\n\tproto_item *hidden_item;\n\n\tstatic int * const hf_fields[] = {\n\t\t&hf_devmode_fields_orientation,\n\t\t&hf_devmode_fields_papersize,\n\t\t&hf_devmode_fields_paperlength,\n\t\t&hf_devmode_fields_paperwidth,\n\t\t&hf_devmode_fields_scale,\n\t\t&hf_devmode_fields_position,\n\t\t&hf_devmode_fields_nup,\n\t\t&hf_devmode_fields_copies,\n\t\t&hf_devmode_fields_defaultsource,\n\t\t&hf_devmode_fields_printquality,\n\t\t&hf_devmode_fields_color,\n\t\t&hf_devmode_fields_duplex,\n\t\t&hf_devmode_fields_yresolution,\n\t\t&hf_devmode_fields_ttoption,\n\t\t&hf_devmode_fields_collate,\n\t\t&hf_devmode_fields_formname,\n\t\t&hf_devmode_fields_logpixels,\n\t\t&hf_devmode_fields_bitsperpel,\n\t\t&hf_devmode_fields_pelswidth,\n\t\t&hf_devmode_fields_pelsheight,\n\t\t&hf_devmode_fields_displayflags,\n\t\t&hf_devmode_fields_displayfrequency,\n\t\t&hf_devmode_fields_icmmethod,\n\t\t&hf_devmode_fields_icmintent,\n\t\t&hf_devmode_fields_mediatype,\n\t\t&hf_devmode_fields_dithertype,\n\t\t&hf_devmode_fields_panningwidth,\n\t\t&hf_devmode_fields_panningheight,\n\t\tNULL\n\t};\n\n\thidden_item = proto_tree_add_uint(\n\t\ttree, hf_devmode, tvb, offset, 0, 1);\n\tproto_item_set_hidden(hidden_item);\n\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, NULL, di, drep, -1, &fields);\n\n\tproto_tree_add_bitmask_value_with_flags(tree, tvb, offset - 4, hf_devmode_fields,\n\t\t\t\t\tett_DEVMODE_fields, hf_fields, fields, BMT_NO_APPEND);\n\n\tif (pdata)\n\t\t*pdata = fields;\n\n\treturn offset;\n}\n\nstatic int ett_DEVMODE;\n\nstatic int\ndissect_DEVMODE(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\t   proto_tree *tree, dcerpc_info *di, uint8_t *drep)\n{\n\tproto_item *item;\n\tproto_tree *subtree;\n\tuint16_t driver_extra;\n\tint16_t print_quality;\n\tuint32_t fields;\n\tint struct_start = offset;\n\n\tif (di->conformant_run)\n\t\treturn offset;\n\n\tsubtree = proto_tree_add_subtree(tree, tvb, offset, 0, ett_DEVMODE, &item, \"Devicemode\");\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_devmode_size,\n\t\tNULL);\n\n\t/* The device name is stored in a 32-wchar buffer */\n\n\tdissect_spoolss_uint16uni(tvb, offset, pinfo, subtree, drep, NULL, hf_devmode_devicename);\n\toffset += 64;\n\n\toffset = dissect_ndr_uint16(\n\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\thf_devmode_spec_version, NULL);\n\n\toffset = dissect_ndr_uint16(\n\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\thf_devmode_driver_version, NULL);\n\n\toffset = dissect_ndr_uint16(\n\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\thf_devmode_size2, NULL);\n\n\toffset = dissect_ndr_uint16(\n\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\thf_devmode_driver_extra_len, &driver_extra);\n\n\toffset = dissect_DEVMODE_fields(\n\t\ttvb, offset, pinfo, subtree, di, drep, &fields);\n\n\toffset = dissect_ndr_uint16(\n\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\thf_devmode_orientation, NULL);\n\n\toffset = dissect_ndr_uint16(\n\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\thf_devmode_paper_size, NULL);\n\n\toffset = dissect_ndr_uint16(\n\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\thf_devmode_paper_length, NULL);\n\n\toffset = dissect_ndr_uint16(\n\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\thf_devmode_paper_width, NULL);\n\n\toffset = dissect_ndr_uint16(\n\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\thf_devmode_scale, NULL);\n\n\toffset = dissect_ndr_uint16(\n\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\thf_devmode_copies, NULL);\n\n\toffset = dissect_ndr_uint16(\n\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\thf_devmode_default_source, NULL);\n\n\toffset = dissect_ndr_uint16(\n\t\ttvb, offset, pinfo, NULL, di, drep,\n\t\thf_devmode_print_quality, &print_quality);\n\n\tif (print_quality < 0)\n\t\tproto_tree_add_item(\n\t\t\tsubtree, hf_devmode_print_quality, tvb,\n\t\t\toffset - 2, 2, DREP_ENC_INTEGER(drep));\n\telse\n\t\tproto_tree_add_uint_format_value(\n\t\t\tsubtree, hf_devmode_print_quality, tvb, offset - 4, 4,\n\t\t\tprint_quality, \"%d dpi\", print_quality);\n\n\toffset = dissect_ndr_uint16(\n\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\thf_devmode_color, NULL);\n\n\toffset = dissect_ndr_uint16(\n\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\thf_devmode_duplex, NULL);\n\n\toffset = dissect_ndr_uint16(\n\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\thf_devmode_y_resolution, NULL);\n\n\toffset = dissect_ndr_uint16(\n\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\thf_devmode_tt_option, NULL);\n\n\toffset = dissect_ndr_uint16(\n\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\thf_devmode_collate, NULL);\n\n\tdissect_spoolss_uint16uni(tvb, offset, pinfo, subtree, drep, NULL, hf_devmode_form_name);\n\toffset += 64;\n\n\toffset = dissect_ndr_uint16(\n\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\thf_devmode_log_pixels, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\thf_devmode_bits_per_pel, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\thf_devmode_pels_width, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\thf_devmode_pels_height, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\thf_devmode_display_flags, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\thf_devmode_display_freq, NULL);\n\n\t/* TODO: Some of the remaining fields are optional.  See\n\t   rpc_parse/parse_spoolss.c in the Samba source for details. */\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\thf_devmode_icm_method, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\thf_devmode_icm_intent, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\thf_devmode_media_type, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\thf_devmode_dither_type, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\thf_devmode_reserved1, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\thf_devmode_reserved2, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\thf_devmode_panning_width, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\thf_devmode_panning_height, NULL);\n\n\tif (driver_extra)\n\t\toffset = dissect_ndr_uint8s(\n\t\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\t\thf_devmode_driver_extra, driver_extra, NULL);\n\n\tproto_item_set_len(item, offset - struct_start);\n\n\treturn offset;\n}\n\n/*\n * DEVMODE_CTR\n */\n\nstatic int ett_DEVMODE_CTR;\n\nint\ndissect_DEVMODE_CTR(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\t       proto_tree *tree, dcerpc_info *di, uint8_t *drep)\n{\n\tproto_tree *subtree;\n\tuint32_t size;\n\n\tsubtree = proto_tree_add_subtree(\n\t\ttree, tvb, offset, 0, ett_DEVMODE_CTR, NULL, \"Devicemode container\");\n\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, subtree, di, drep,\n\t\t\t\t    hf_devmodectr_size, &size);\n\n\toffset = dissect_ndr_pointer(\n\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\tdissect_DEVMODE, NDR_POINTER_UNIQUE, \"Devicemode\", -1);\n\n\treturn offset;\n}\n\n/*\n * Relative string given by offset into the current buffer.  Note that\n * the offset for subsequent relstrs are against the structure start, not\n * the point where the offset is parsed from.\n */\n\nstatic int ett_RELSTR;\n\nstatic int\ndissect_spoolss_relstr(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t       proto_tree *tree, dcerpc_info *di, uint8_t *drep, int hf_index,\n\t\t       int struct_start, char **data)\n{\n\tproto_item *item;\n\tproto_tree *subtree;\n\tuint32_t relstr_offset, relstr_start, relstr_end;\n\tchar *text;\n\n\t/* Peek ahead to read the string.  We need this for the\n\t   proto_tree_add_string() call so filtering will work. */\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, NULL, di, drep, hf_offset, &relstr_offset);\n\n\trelstr_start = relstr_offset + struct_start;\n\n\tif (relstr_offset) {\n\t\trelstr_end = dissect_spoolss_uint16uni(\n\t\t\ttvb, relstr_start, pinfo, NULL, drep, &text, hf_relative_string);\n\t} else { \t\t\t/* relstr_offset == 0 is a NULL string */\n\t\ttext = wmem_strdup(pinfo->pool, \"\");\n\t\trelstr_end = relstr_start;\n\t}\n\n\t/* OK now add the proto item with the string value */\n\n\titem = proto_tree_add_string(tree, hf_index, tvb, relstr_start, relstr_end - relstr_start, text);\n\tsubtree = proto_item_add_subtree(item, ett_RELSTR);\n\n\tdissect_ndr_uint32(\n\t\ttvb, offset - 4, pinfo, subtree, di, drep, hf_offset, NULL);\n\n\tif (relstr_offset)\n\t\tdissect_spoolss_uint16uni(\n\t\t\ttvb, relstr_start, pinfo, subtree, drep, NULL, hf_relative_string);\n\n\tif (data)\n\t\t*data = text;\n\n\treturn offset;\n}\n\n/* An array of relative strings.  This is currently just a copy of the\n   dissect_spoolss_relstr() function as I can't find an example driver that\n   has more than one dependent file. */\n\nstatic int ett_RELSTR_ARRAY;\n\nstatic int\ndissect_spoolss_relstrarray(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\t    proto_tree *tree, dcerpc_info *di, uint8_t *drep, int hf_index,\n\t\t\t    int struct_start, char **data)\n{\n\tproto_item *item;\n\tproto_tree *subtree;\n\tuint32_t relstr_offset, relstr_start/*, relstr_end, relstr_len*/;\n\tchar *text;\n\n\titem = proto_tree_add_string(tree, hf_index, tvb, offset, 4, \"\");\n\n\tsubtree = proto_item_add_subtree(item, ett_RELSTR_ARRAY);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_offset, &relstr_offset);\n\n\t/* A relative offset of zero is a NULL string */\n\n\trelstr_start = relstr_offset + struct_start;\n\n\tif (relstr_offset)\n\t\t/*relstr_end = */dissect_spoolss_uint16uni(\n\t\t\ttvb, relstr_start, pinfo, subtree, drep, &text, hf_relative_string);\n\telse {\n\t\ttext = wmem_strdup(pinfo->pool, \"NULL\");\n\t\t/*relstr_end = offset;*/\n\t}\n\n\t/*relstr_len = relstr_end - relstr_start;*/\n\n\tproto_item_append_text(item, \"%s\", text);\n\n\tif (data)\n\t\t*data = text;\n\n\treturn offset;\n}\n\n/*\n * PRINTER_INFO_0\n */\n\nstatic int hf_printer_status;\n\nstatic const value_string printer_status_vals[] =\n{\n\t{ PRINTER_STATUS_OK, \"OK\" },\n\t{ PRINTER_STATUS_PAUSED, \"Paused\" },\n\t{ PRINTER_STATUS_ERROR, \"Error\" },\n\t{ PRINTER_STATUS_PENDING_DELETION, \"Pending deletion\" },\n\t{ PRINTER_STATUS_PAPER_JAM, \"Paper jam\" },\n\t{ PRINTER_STATUS_PAPER_OUT, \"Paper out\" },\n\t{ PRINTER_STATUS_MANUAL_FEED, \"Manual feed\" },\n\t{ PRINTER_STATUS_PAPER_PROBLEM, \"Paper problem\" },\n\t{ PRINTER_STATUS_OFFLINE, \"Offline\" },\n\t{ PRINTER_STATUS_IO_ACTIVE, \"IO active\" },\n\t{ PRINTER_STATUS_BUSY, \"Busy\" },\n\t{ PRINTER_STATUS_PRINTING, \"Printing\" },\n\t{ PRINTER_STATUS_OUTPUT_BIN_FULL, \"Output bin full\" },\n\t{ PRINTER_STATUS_NOT_AVAILABLE, \"Not available\" },\n\t{ PRINTER_STATUS_WAITING, \"Waiting\" },\n\t{ PRINTER_STATUS_PROCESSING, \"Processing\" },\n\t{ PRINTER_STATUS_INITIALIZING, \"Initialising\" },\n\t{ PRINTER_STATUS_WARMING_UP, \"Warming up\" },\n\t{ PRINTER_STATUS_TONER_LOW, \"Toner low\" },\n\t{ PRINTER_STATUS_NO_TONER, \"No toner\" },\n\t{ PRINTER_STATUS_PAGE_PUNT, \"Page punt\" },\n\t{ PRINTER_STATUS_USER_INTERVENTION, \"User intervention\" },\n\t{ PRINTER_STATUS_OUT_OF_MEMORY, \"Out of memory\" },\n\t{ PRINTER_STATUS_DOOR_OPEN, \"Door open\" },\n\t{ PRINTER_STATUS_SERVER_UNKNOWN, \"Server unknown\" },\n\t{ PRINTER_STATUS_POWER_SAVE, \"Power save\" },\n\t{ 0, NULL }\n};\nstatic value_string_ext printer_status_vals_ext = VALUE_STRING_EXT_INIT(printer_status_vals);\n\nstatic int ett_PRINTER_INFO_0;\n\nstatic int\ndissect_PRINTER_INFO_0(tvbuff_t *tvb, int offset,\n\t\t\t\t  packet_info *pinfo, proto_tree *tree,\n\t\t\t\t  dcerpc_info *di, uint8_t *drep)\n{\n\toffset = dissect_spoolss_relstr(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printername,\n\t\t0, NULL);\n\n\toffset = dissect_spoolss_relstr(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_servername,\n\t\t0, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printer_cjobs, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printer_total_jobs,\n\t\tNULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printer_total_bytes,\n\t\tNULL);\n\n\toffset = dissect_SYSTEM_TIME(\n\t\ttvb, offset, pinfo, tree, di, drep, \"Unknown time\", true, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printer_global_counter,\n\t\tNULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printer_total_pages,\n\t\tNULL);\n\n\toffset = dissect_ndr_uint16(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printer_major_version,\n\t\tNULL);\n\n\toffset = dissect_ndr_uint16(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printer_build_version,\n\t\tNULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printer_unk7, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printer_unk8, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printer_unk9, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printer_session_ctr,\n\t\tNULL);\n\n\toffset = dissect_ndr_uint32( tvb, offset, pinfo, tree, di, drep,\n\t\thf_printer_unk11, NULL);\n\n\toffset = dissect_ndr_uint32( tvb, offset, pinfo, tree, di, drep,\n\t\thf_printer_printer_errors, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printer_unk13, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printer_unk14, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printer_unk15, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printer_unk16, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printer_changeid, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printer_unk18, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printer_status, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printer_unk20, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printer_c_setprinter,\n\t\tNULL);\n\n\toffset = dissect_ndr_uint16(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printer_unk22, NULL);\n\n\toffset = dissect_ndr_uint16(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printer_unk23, NULL);\n\n\toffset = dissect_ndr_uint16(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printer_unk24, NULL);\n\n\toffset = dissect_ndr_uint16(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printer_unk25, NULL);\n\n\toffset = dissect_ndr_uint16(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printer_unk26, NULL);\n\n\toffset = dissect_ndr_uint16(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printer_unk27, NULL);\n\n\toffset = dissect_ndr_uint16(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printer_unk28, NULL);\n\n\toffset = dissect_ndr_uint16(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printer_unk29, NULL);\n\n\treturn offset;\n}\n\n/*\n * PRINTER_INFO_1\n */\n\nstatic int ett_PRINTER_INFO_1;\n\nstatic int\ndissect_PRINTER_INFO_1(tvbuff_t *tvb, int offset,\n\t\t\t\t  packet_info *pinfo, proto_tree *tree,\n\t\t\t\t  dcerpc_info *di, uint8_t *drep)\n{\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep,\n\t\thf_printer_flags, NULL);\n\n\toffset = dissect_spoolss_relstr(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printerdesc,\n\t\t0, NULL);\n\n\toffset = dissect_spoolss_relstr(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printername,\n\t\t0, NULL);\n\n\toffset = dissect_spoolss_relstr(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printercomment,\n\t\t0, NULL);\n\n\treturn offset;\n}\n\n/* Job status */\n\nstatic const true_false_string tfs_job_status_paused = {\n\t\"Job is paused\",\n\t\"Job is not paused\"\n};\n\nstatic const true_false_string tfs_job_status_error = {\n\t\"Job has an error\",\n\t\"Job is OK\"\n};\n\nstatic const true_false_string tfs_job_status_deleting = {\n\t\"Job is being deleted\",\n\t\"Job is not being deleted\"\n};\n\nstatic const true_false_string tfs_job_status_spooling = {\n\t\"Job is being spooled\",\n\t\"Job is not being spooled\"\n};\n\nstatic const true_false_string tfs_job_status_printing = {\n\t\"Job is being printed\",\n\t\"Job is not being printed\"\n};\n\nstatic const true_false_string tfs_job_status_offline = {\n\t\"Job is offline\",\n\t\"Job is not offline\"\n};\n\nstatic const true_false_string tfs_job_status_paperout = {\n\t\"Job is out of paper\",\n\t\"Job is not out of paper\"\n};\n\nstatic const true_false_string tfs_job_status_printed = {\n\t\"Job has completed printing\",\n\t\"Job has not completed printing\"\n};\n\nstatic const true_false_string tfs_job_status_deleted = {\n\t\"Job has been deleted\",\n\t\"Job has not been deleted\"\n};\n\nstatic const true_false_string tfs_job_status_blocked = {\n\t\"Job has been blocked\",\n\t\"Job has not been blocked\"\n};\n\nstatic const true_false_string tfs_job_status_user_intervention = {\n\t\"User intervention required\",\n\t\"User intervention not required\"\n};\n\nstatic int ett_job_status;\n\nstatic int\ndissect_job_status(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t   proto_tree *tree, dcerpc_info *di, uint8_t *drep)\n{\n\tuint32_t status;\n\tstatic int * const hf_status[] = {\n\t\t&hf_job_status_user_intervention,\n\t\t&hf_job_status_blocked,\n\t\t&hf_job_status_deleted,\n\t\t&hf_job_status_printed,\n\t\t&hf_job_status_paperout,\n\t\t&hf_job_status_offline,\n\t\t&hf_job_status_printing,\n\t\t&hf_job_status_spooling,\n\t\t&hf_job_status_deleting,\n\t\t&hf_job_status_error,\n\t\t&hf_job_status_paused,\n\t\tNULL\n\t};\n\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, NULL, di, drep, -1, &status);\n\n\tproto_tree_add_bitmask_value_with_flags(tree, tvb, offset - 4, hf_job_status,\n\t\t\t\t\tett_job_status, hf_status, status, BMT_NO_APPEND);\n\n\treturn offset;\n}\n\n/* Printer attributes */\n\nstatic int ett_printer_attributes;\n\nstatic int hf_printer_attributes;\nstatic int hf_printer_attributes_queued;\nstatic int hf_printer_attributes_direct;\nstatic int hf_printer_attributes_default;\nstatic int hf_printer_attributes_shared;\nstatic int hf_printer_attributes_network;\nstatic int hf_printer_attributes_hidden;\nstatic int hf_printer_attributes_local;\nstatic int hf_printer_attributes_enable_devq;\nstatic int hf_printer_attributes_keep_printed_jobs;\nstatic int hf_printer_attributes_do_complete_first;\nstatic int hf_printer_attributes_work_offline;\nstatic int hf_printer_attributes_enable_bidi;\nstatic int hf_printer_attributes_raw_only;\nstatic int hf_printer_attributes_published;\n\nstatic const true_false_string tfs_printer_attributes_queued = {\n\t\"The printer starts printing after last page spooled\",\n\t\"The printer starts printing while spooling\"\n};\n\nstatic const true_false_string tfs_printer_attributes_direct = {\n\t\"Jobs are sent directly to the printer\",\n\t\"Jobs are spooled to the printer before printing\"\n};\n\nstatic const true_false_string tfs_printer_attributes_default = {\n\t\"The printer is the default printer\",\n\t\"The printer is not the default printer\"\n};\n\nstatic const true_false_string tfs_printer_attributes_shared = {\n\t\"The printer is shared\",\n\t\"The printer is not shared\"\n};\n\nstatic const true_false_string tfs_printer_attributes_network = {\n\t\"The printer is a network printer connection\",\n\t\"The printer is not a network printer connection\"\n};\n\nstatic const true_false_string tfs_printer_attributes_hidden = {\n\t\"The printer is hidden from some users on the network\",\n\t\"The printer is not hidden from some users on the network\"\n};\n\nstatic const true_false_string tfs_printer_attributes_local = {\n\t\"The printer is a local printer\",\n\t\"The printer is not a local printer\"\n};\n\nstatic const true_false_string tfs_printer_attributes_enable_devq = {\n\t\"The queue on the printer is enabled if available\",\n\t\"The queue on the printer is not enabled\",\n};\n\nstatic const true_false_string tfs_printer_attributes_keep_printed_jobs = {\n\t\"Jobs are kept after they are printed\",\n\t\"Jobs are deleted after they are printed\"\n};\n\nstatic const true_false_string tfs_printer_attributes_do_complete_first = {\n\t\"Jobs that have completed spooling are scheduled before still spooling jobs\",\n\t\"Jobs are scheduled in the order they start spooling\"\n};\n\nstatic const true_false_string tfs_printer_attributes_work_offline = {\n\t\"The printer is currently connected\",\n\t\"The printer is currently not connected\"\n};\n\nstatic const true_false_string tfs_printer_attributes_enable_bidi = {\n\t\"Bidirectional communications are supported\",\n\t\"Bidirectional communications are not supported\"\n};\n\nstatic const true_false_string tfs_printer_attributes_raw_only = {\n\t\"Only raw data type print jobs can be spooled\",\n\t\"All data type print jobs can be spooled\"\n};\n\nstatic const true_false_string tfs_printer_attributes_published = {\n\t\"The printer is published in the directory\",\n\t\"The printer is not published in the directory\"\n};\n\nstatic int\ndissect_printer_attributes(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\t   proto_tree *tree, dcerpc_info *di, uint8_t *drep)\n{\n\tuint32_t attributes;\n\tstatic int * const hf_attributes[] = {\n\t\t&hf_printer_attributes_published,\n\t\t&hf_printer_attributes_raw_only,\n\t\t&hf_printer_attributes_enable_bidi,\n\t\t&hf_printer_attributes_work_offline,\n\t\t&hf_printer_attributes_do_complete_first,\n\t\t&hf_printer_attributes_keep_printed_jobs,\n\t\t&hf_printer_attributes_enable_devq,\n\t\t&hf_printer_attributes_local,\n\t\t&hf_printer_attributes_hidden,\n\t\t&hf_printer_attributes_network,\n\t\t&hf_printer_attributes_shared,\n\t\t&hf_printer_attributes_default,\n\t\t&hf_printer_attributes_direct,\n\t\t&hf_printer_attributes_queued,\n\t\tNULL\n\t};\n\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, NULL, di, drep, -1, &attributes);\n\n\tproto_tree_add_bitmask_value_with_flags(tree, tvb, offset - 4, hf_printer_attributes,\n\t\t\t\t\tett_printer_attributes, hf_attributes, attributes, BMT_NO_APPEND);\n\n\treturn offset;\n}\n\n/* Printer Driver attributes */\n\nstatic int ett_printer_driver_attributes;\n\nstatic int hf_printer_driver_attributes;\nstatic int hf_printer_driver_attributes_package_aware;\nstatic int hf_printer_driver_attributes_xps;\nstatic int hf_printer_driver_attributes_sandbox_enabled;\nstatic int hf_printer_driver_attributes_class;\nstatic int hf_printer_driver_attributes_derived;\nstatic int hf_printer_driver_attributes_not_shareable;\nstatic int hf_printer_driver_attributes_category_fax;\nstatic int hf_printer_driver_attributes_category_file;\nstatic int hf_printer_driver_attributes_category_virtual;\nstatic int hf_printer_driver_attributes_category_service;\nstatic int hf_printer_driver_attributes_soft_reset_required;\nstatic int hf_printer_driver_attributes_category_3d;\n\nstatic const true_false_string tfs_printer_driver_attributes_package_aware = {\n\t\"Printer Driver is package aware\",\n\t\"Printer Driver is not package aware\"\n};\n\nstatic const true_false_string tfs_printer_driver_attributes_xps = {\n\t\"Printer Driver is XPS based\",\n\t\"Printer Driver is not XPS based\"\n};\n\nstatic const true_false_string tfs_printer_driver_attributes_sandbox_enabled = {\n\t\"Printer Driver is sandbox enabled\",\n\t\"Printer Driver is not sandbox enabled\"\n};\n\nstatic const true_false_string tfs_printer_driver_attributes_class = {\n\t\"Printer Driver is a Class Printer Driver\",\n\t\"Printer Driver is not a Class Printer Driver\"\n};\n\nstatic const true_false_string tfs_printer_driver_attributes_derived = {\n\t\"Printer Driver is a derived Printer Driver\",\n\t\"Printer Driver is not a derived Printer Driver\"\n};\n\nstatic const true_false_string tfs_printer_driver_attributes_not_shareable = {\n\t\"Printer Driver is a not a sharable Printer Driver\",\n\t\"Printer Driver is a shareable Printer Driver\"\n};\n\nstatic const true_false_string tfs_printer_driver_attributes_category_fax = {\n\t\"Printer Driver is a Fax Printer Driver\",\n\t\"Printer Driver is not a Fax Printer Driver\"\n};\n\nstatic const true_false_string tfs_printer_driver_attributes_category_file = {\n\t\"Printer Driver is a File Printer Driver\",\n\t\"Printer Driver is not a File Printer Driver\"\n};\n\nstatic const true_false_string tfs_printer_driver_attributes_category_virtual = {\n\t\"Printer Driver is a Virtual Printer Driver\",\n\t\"Printer Driver is not a Virtual Printer Driver\"\n};\n\nstatic const true_false_string tfs_printer_driver_attributes_category_service = {\n\t\"Printer Driver is a Service Printer Driver\",\n\t\"Printer Driver is not a Service Printer Driver\"\n};\n\nstatic const true_false_string tfs_printer_driver_attributes_soft_reset_required = {\n\t\"Soft reset is required for this Printer Driver\",\n\t\"No soft reset is required for this Printer Driver\"\n};\n\nstatic const true_false_string tfs_printer_driver_attributes_category_3d = {\n\t\"Printer Driver is a 3D Printer Driver\",\n\t\"Printer Driver is not a 3D Printer Driver\"\n};\n\nstatic int\ndissect_printer_driver_attributes(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\t\t  proto_tree *tree, dcerpc_info *di, uint8_t *drep)\n{\n\tuint32_t attributes;\n\tstatic int * const hf_attributes[] = {\n\t\t&hf_printer_driver_attributes_package_aware,\n\t\t&hf_printer_driver_attributes_xps,\n\t\t&hf_printer_driver_attributes_sandbox_enabled,\n\t\t&hf_printer_driver_attributes_class,\n\t\t&hf_printer_driver_attributes_derived,\n\t\t&hf_printer_driver_attributes_not_shareable,\n\t\t&hf_printer_driver_attributes_category_fax,\n\t\t&hf_printer_driver_attributes_category_file,\n\t\t&hf_printer_driver_attributes_category_virtual,\n\t\t&hf_printer_driver_attributes_category_service,\n\t\t&hf_printer_driver_attributes_soft_reset_required,\n\t\t&hf_printer_driver_attributes_category_3d,\n\t\tNULL\n\t};\n\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, NULL, di, drep, -1, &attributes);\n\n\tproto_tree_add_bitmask_value_with_flags(tree, tvb, offset - 4, hf_printer_driver_attributes,\n\t\t\t\t\tett_printer_driver_attributes, hf_attributes, attributes, BMT_NO_APPEND);\n\n\treturn offset;\n}\n\n\n/*\n * PRINTER_INFO_2\n */\n\nstatic int ett_PRINTER_INFO_2;\n\nstatic int\ndissect_PRINTER_INFO_2(tvbuff_t *tvb, int offset,\n\t\t\t\t  packet_info *pinfo, proto_tree *tree,\n\t\t\t\t  dcerpc_info *di, uint8_t *drep)\n{\n\tuint32_t devmode_offset, secdesc_offset;\n\n\toffset = dissect_spoolss_relstr(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_servername,\n\t\t0, NULL);\n\n\toffset = dissect_spoolss_relstr(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printername,\n\t\t0, NULL);\n\n\toffset = dissect_spoolss_relstr(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_sharename,\n\t\t0, NULL);\n\n\toffset = dissect_spoolss_relstr(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_portname,\n\t\t0, NULL);\n\n\toffset = dissect_spoolss_relstr(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_drivername,\n\t\t0, NULL);\n\n\toffset = dissect_spoolss_relstr(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printercomment,\n\t\t0, NULL);\n\n\toffset = dissect_spoolss_relstr(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printerlocation,\n\t\t0, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, NULL, di, drep, hf_offset,\n\t\t&devmode_offset);\n\n\tdissect_DEVMODE(tvb, devmode_offset - 4, pinfo, tree, di, drep);\n\n\toffset = dissect_spoolss_relstr(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_sepfile,\n\t\t0, NULL);\n\n\toffset = dissect_spoolss_relstr(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printprocessor,\n\t\t0, NULL);\n\n\toffset = dissect_spoolss_relstr(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_datatype,\n\t\t0, NULL);\n\n\toffset = dissect_spoolss_relstr(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_parameters,\n\t\t0, NULL);\n\n\t/*\n\t * XXX - what *is* the length of this security descriptor?\n\t * \"prs_PRINTER_INFO_2()\" is passed to \"defer_ptr()\", but\n\t * \"defer_ptr\" takes, as an argument, a function with a\n\t * different calling sequence from \"prs_PRINTER_INFO_2()\",\n\t * lacking the \"len\" argument, so that won't work.\n\t */\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, NULL, di, drep, hf_offset,\n\t\t&secdesc_offset);\n\n\tdissect_nt_sec_desc(\n\t\ttvb, secdesc_offset, pinfo, tree, drep,\n\t\tfalse, -1,\n\t\t&spoolss_printer_access_mask_info);\n\n\toffset = dissect_printer_attributes(tvb, offset, pinfo, tree, di, drep);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, NULL, di, drep, hf_printer_priority,\n\t\tNULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, NULL, di, drep,\n\t\thf_printer_default_priority, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, NULL, di, drep, hf_start_time, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, NULL, di, drep, hf_end_time, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep,\n\t\thf_printer_status, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, NULL, di, drep, hf_printer_jobs,\n\t\tNULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, NULL, di, drep,\n\t\thf_printer_averageppm, NULL);\n\n\treturn offset;\n}\n\n/*\n * PRINTER_INFO_3\n */\n\nstatic int ett_PRINTER_INFO_3;\n\nstatic int\ndissect_PRINTER_INFO_3(tvbuff_t *tvb, int offset,\n\t\t\t\t  packet_info *pinfo, proto_tree *tree,\n\t\t\t\t  dcerpc_info *di, uint8_t *drep)\n{\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep,\n\t\thf_printer_flags, NULL);\n\n\toffset = dissect_nt_sec_desc(\n\t\ttvb, offset, pinfo, tree, drep,\n\t\tfalse, -1,\n\t\t&spoolss_printer_access_mask_info);\n\n\treturn offset;\n}\n\n/*\n * PRINTER_INFO_5\n */\n\nstatic int ett_PRINTER_INFO_5;\n\nstatic int\ndissect_PRINTER_INFO_5(tvbuff_t *tvb, int offset,\n\t\t\t\t  packet_info *pinfo, proto_tree *tree,\n\t\t\t\t  dcerpc_info *di, uint8_t *drep)\n{\n\toffset = dissect_spoolss_relstr(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printername,\n\t\t0, NULL);\n\n\toffset = dissect_spoolss_relstr(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_portname,\n\t\t0, NULL);\n\n\toffset = dissect_printer_attributes(tvb, offset, pinfo, tree, di, drep);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep,\n\t\thf_device_not_selected_timeout, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep,\n\t\thf_transmission_retry_timeout, NULL);\n\n\treturn offset;\n}\n\n\n/*\n * PRINTER_INFO_7\n */\n\nstatic int ett_PRINTER_INFO_7;\n\nstatic const value_string getprinter_action_vals[] = {\n\t{ DS_PUBLISH, \"Publish\" },\n\t{ DS_UNPUBLISH, \"Unpublish\" },\n\t{ DS_UPDATE, \"Update\" },\n\t{ DS_PENDING, \"Pending\" },\n\t{ DS_REPUBLISH, \"Republish\" },\n\t{ 0, NULL }\n};\n\nstatic int\ndissect_PRINTER_INFO_7(tvbuff_t *tvb, int offset,\n\t\t\t\t  packet_info *pinfo, proto_tree *tree,\n\t\t\t\t  dcerpc_info *di, uint8_t *drep)\n{\n\toffset = dissect_spoolss_relstr(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printer_guid,\n\t\t0, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep,\n\t\thf_printer_action, NULL);\n\n\treturn offset;\n}\n\n/*\n * PRINTER_DATATYPE structure\n */\n\nstatic int ett_PRINTER_DATATYPE;\n\nstatic int\ndissect_PRINTER_DATATYPE(tvbuff_t *tvb, int offset,\n\t\t\t\t    packet_info *pinfo, proto_tree *tree,\n\t\t\t\t    dcerpc_info *di, uint8_t *drep)\n{\n\tif (di->conformant_run)\n\t\treturn offset;\n\n\toffset = dissect_ndr_cvstring(\n\t\ttvb, offset, pinfo, tree, di, drep, sizeof(uint16_t),\n\t\thf_datatype, true, NULL);\n\n\treturn offset;\n}\n\n/*\n * USER_LEVEL_1 structure\n */\n\nstatic int ett_USER_LEVEL_1;\n\nstatic int hf_userlevel_size;\nstatic int hf_userlevel_client;\nstatic int hf_userlevel_user;\nstatic int hf_userlevel_build;\nstatic int hf_userlevel_major;\nstatic int hf_userlevel_minor;\nstatic int hf_userlevel_processor;\n\nstatic int\ndissect_USER_LEVEL_1(tvbuff_t *tvb, int offset,\n\t\t\t\tpacket_info *pinfo, proto_tree *tree,\n\t\t\t\tdcerpc_info *di, uint8_t *drep)\n{\n\tuint32_t level;\n\n\t/* Guy has pointed out that this dissection looks wrong.  In\n\t   the wireshark output for a USER_LEVEL_1 it looks like the\n\t   info level and container pointer are transposed.  I'm not\n\t   even sure this structure is a container. */\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_level, &level);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_userlevel_size, NULL);\n\n\toffset = dissect_ndr_str_pointer_item(\n\t\ttvb, offset, pinfo, tree, di, drep, NDR_POINTER_UNIQUE,\n\t\t\"Client\", hf_userlevel_client, 0);\n\n\toffset = dissect_ndr_str_pointer_item(\n\t\ttvb, offset, pinfo, tree, di, drep, NDR_POINTER_UNIQUE,\n\t\t\"User\", hf_userlevel_user, 0);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_userlevel_build, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_userlevel_major, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_userlevel_minor, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_userlevel_processor, NULL);\n\n\treturn offset;\n}\n\n/*\n * USER_LEVEL_CTR structure\n */\n\nstatic int ett_USER_LEVEL_CTR;\n\nint\ndissect_USER_LEVEL_CTR(tvbuff_t *tvb, int offset,\n\t\t\t\t  packet_info *pinfo, proto_tree *tree,\n\t\t\t\t  dcerpc_info *di, uint8_t *drep)\n{\n\tproto_tree *subtree;\n\tproto_item *item;\n\tuint32_t level;\n\n\tif (di->conformant_run)\n\t\treturn offset;\n\n\tsubtree = proto_tree_add_subtree(\n\t\ttree, tvb, offset, 0, ett_USER_LEVEL_CTR, &item, \"User level container\");\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_level, &level);\n\n\tswitch(level) {\n\tcase 1:\n\t\toffset = dissect_ndr_pointer(\n\t\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\t\tdissect_USER_LEVEL_1, NDR_POINTER_UNIQUE,\n\t\t\t\"User level 1\", -1);\n\t\tbreak;\n\tdefault:\n\t\texpert_add_info_format(pinfo, item, &ei_level, \"Info level %d not decoded\", level);\n\t\tbreak;\n\t}\n\n\treturn offset;\n}\n\n/*\n * SpoolssOpenPrinterEx\n */\n\nstatic int\nSpoolssOpenPrinterEx_q(tvbuff_t *tvb, int offset,\n\t\t\t\t  packet_info *pinfo, proto_tree *tree,\n\t\t\t\t  dcerpc_info *di, uint8_t *drep)\n{\n\tdcerpc_call_value *dcv = (dcerpc_call_value *)di->call_data;\n\tchar *name;\n\n\t/* Parse packet */\n\n\tdcv->private_data=NULL;\n\toffset = dissect_ndr_pointer_cb(\n\t\ttvb, offset, pinfo, tree, di, drep,\n\t\tdissect_ndr_wchar_cvstring, NDR_POINTER_UNIQUE,\n\t\t\"Printer name\", hf_printername, cb_wstr_postprocess,\n\t\tGINT_TO_POINTER(CB_STR_COL_INFO | CB_STR_SAVE | 1));\n\tname = (char *)dcv->private_data;\n\n\t/* OpenPrinterEx() stores the key/value in se_data */\n\tif(!pinfo->fd->visited){\n\t\tif(!dcv->se_data){\n\t\t\tdcv->se_data = wmem_strdup(wmem_file_scope(),\n\t\t\t\tname?name:\"\");\n\t\t}\n\t}\n\n\toffset = dissect_ndr_pointer(\n\t\ttvb, offset, pinfo, tree, di, drep,\n\t\tdissect_PRINTER_DATATYPE, NDR_POINTER_UNIQUE,\n\t\t\"Printer datatype\", -1);\n\n\toffset = dissect_DEVMODE_CTR(tvb, offset, pinfo, tree, di, drep);\n\n\tname=(char *)dcv->se_data;\n\tif (name) {\n\t\tif (name[0] == '\\\\' && name[1] == '\\\\')\n\t\t\tname += 2;\n\n\t\t/* Determine if we are opening a printer or a print server */\n\n\t\tif (strchr(name, '\\\\'))\n\t\t\toffset = dissect_nt_access_mask(\n\t\t\t\ttvb, offset, pinfo, tree, di, drep,\n\t\t\t\thf_access_required,\n\t\t\t\t&spoolss_printer_access_mask_info, NULL);\n\t\telse\n\t\t\toffset = dissect_nt_access_mask(\n\t\t\t\ttvb, offset, pinfo, tree, di, drep,\n\t\t\t\thf_access_required,\n\t\t\t\t&spoolss_printserver_access_mask_info, NULL);\n\t} else {\n\n\t\t/* We can't decide what type of object being opened */\n\n\t\toffset = dissect_nt_access_mask(\n\t\t\ttvb, offset, pinfo, tree, di, drep, hf_access_required,\n\t\t\tNULL, NULL);\n\t}\n\n\toffset = dissect_USER_LEVEL_CTR(tvb, offset, pinfo, tree, di, drep);\n\n\treturn offset;\n}\n\nstatic int\nSpoolssOpenPrinterEx_r(tvbuff_t *tvb, int offset,\n\t\t\t\t  packet_info *pinfo, proto_tree *tree,\n\t\t\t\t  dcerpc_info *di, uint8_t *drep)\n{\n\tdcerpc_call_value *dcv = (dcerpc_call_value *)di->call_data;\n\te_ctx_hnd policy_hnd;\n\tproto_item *hnd_item;\n\tuint32_t status;\n\n\t/* Parse packet */\n\n\toffset = dissect_nt_policy_hnd(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_hnd, &policy_hnd, &hnd_item,\n\t\tPIDL_POLHND_OPEN);\n\n\toffset = dissect_doserror(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_rc, &status);\n\n\tif( status == 0 ){\n\t\tconst char *pol_name;\n\n\t\tif (dcv->se_data){\n\t\t\tpol_name = wmem_strdup_printf(pinfo->pool,\n\t\t\t\t\"OpenPrinterEx(%s)\", (char *)dcv->se_data);\n\t\t} else {\n\t\t\tpol_name = \"Unknown OpenPrinterEx() handle\";\n\t\t}\n\t\tif(!pinfo->fd->visited){\n\t\t\tdcerpc_store_polhnd_name(&policy_hnd, pinfo, pol_name);\n\t\t}\n\n\t\tif(hnd_item)\n\t\t\tproto_item_append_text(hnd_item, \": %s\", pol_name);\n\t}\n\n\treturn offset;\n}\n\nstatic const value_string printer_notify_option_data_vals[] = {\n\t{ PRINTER_NOTIFY_SERVER_NAME, \"Server name\" },\n\t{ PRINTER_NOTIFY_PRINTER_NAME, \"Printer name\" },\n\t{ PRINTER_NOTIFY_SHARE_NAME, \"Share name\" },\n\t{ PRINTER_NOTIFY_PORT_NAME, \"Port name\" },\n\t{ PRINTER_NOTIFY_DRIVER_NAME, \"Driver name\" },\n\t{ PRINTER_NOTIFY_COMMENT, \"Comment\" },\n\t{ PRINTER_NOTIFY_LOCATION, \"Location\" },\n\t{ PRINTER_NOTIFY_DEVMODE, \"Devmode\" },\n\t{ PRINTER_NOTIFY_SEPFILE, \"Sepfile\" },\n\t{ PRINTER_NOTIFY_PRINT_PROCESSOR, \"Print processor\" },\n\t{ PRINTER_NOTIFY_PARAMETERS, \"Parameters\" },\n\t{ PRINTER_NOTIFY_DATATYPE, \"Datatype\" },\n\t{ PRINTER_NOTIFY_SECURITY_DESCRIPTOR, \"Security descriptor\" },\n\t{ PRINTER_NOTIFY_ATTRIBUTES, \"Attributes\" },\n\t{ PRINTER_NOTIFY_PRIORITY, \"Priority\" },\n\t{ PRINTER_NOTIFY_DEFAULT_PRIORITY, \"Default priority\" },\n\t{ PRINTER_NOTIFY_START_TIME, \"Start time\" },\n\t{ PRINTER_NOTIFY_UNTIL_TIME, \"Until time\" },\n\t{ PRINTER_NOTIFY_STATUS, \"Status\" },\n\t{ PRINTER_NOTIFY_STATUS_STRING, \"Status string\" },\n\t{ PRINTER_NOTIFY_CJOBS, \"Cjobs\" },\n\t{ PRINTER_NOTIFY_AVERAGE_PPM, \"Average PPM\" },\n\t{ PRINTER_NOTIFY_TOTAL_PAGES, \"Total pages\" },\n\t{ PRINTER_NOTIFY_PAGES_PRINTED, \"Pages printed\" },\n\t{ PRINTER_NOTIFY_TOTAL_BYTES, \"Total bytes\" },\n\t{ PRINTER_NOTIFY_BYTES_PRINTED, \"Bytes printed\" },\n\t{ 0, NULL}\n};\nstatic value_string_ext printer_notify_option_data_vals_ext = VALUE_STRING_EXT_INIT(printer_notify_option_data_vals);\n\nstatic const value_string job_notify_option_data_vals[] = {\n\t{ JOB_NOTIFY_PRINTER_NAME, \"Printer name\" },\n\t{ JOB_NOTIFY_MACHINE_NAME, \"Machine name\" },\n\t{ JOB_NOTIFY_PORT_NAME, \"Port name\" },\n\t{ JOB_NOTIFY_USER_NAME, \"User name\" },\n\t{ JOB_NOTIFY_NOTIFY_NAME, \"Notify name\" },\n\t{ JOB_NOTIFY_DATATYPE, \"Data type\" },\n\t{ JOB_NOTIFY_PRINT_PROCESSOR, \"Print processor\" },\n\t{ JOB_NOTIFY_PARAMETERS, \"Parameters\" },\n\t{ JOB_NOTIFY_DRIVER_NAME, \"Driver name\" },\n\t{ JOB_NOTIFY_DEVMODE, \"Devmode\" },\n\t{ JOB_NOTIFY_STATUS, \"Status\" },\n\t{ JOB_NOTIFY_STATUS_STRING, \"Status string\" },\n\t{ JOB_NOTIFY_SECURITY_DESCRIPTOR, \"Security descriptor\" },\n\t{ JOB_NOTIFY_DOCUMENT, \"Document\" },\n\t{ JOB_NOTIFY_PRIORITY, \"Priority\" },\n\t{ JOB_NOTIFY_POSITION, \"Position\" },\n\t{ JOB_NOTIFY_SUBMITTED, \"Submitted\" },\n\t{ JOB_NOTIFY_START_TIME, \"Start time\" },\n\t{ JOB_NOTIFY_UNTIL_TIME, \"Until time\" },\n\t{ JOB_NOTIFY_TIME, \"Time\" },\n\t{ JOB_NOTIFY_TOTAL_PAGES, \"Total pages\" },\n\t{ JOB_NOTIFY_PAGES_PRINTED, \"Pages printed\" },\n\t{ JOB_NOTIFY_TOTAL_BYTES, \"Total bytes\" },\n\t{ JOB_NOTIFY_BYTES_PRINTED, \"Bytes printed\" },\n\t{ 0, NULL}\n};\nstatic value_string_ext job_notify_option_data_vals_ext = VALUE_STRING_EXT_INIT(job_notify_option_data_vals);\n\nstatic int\ndissect_notify_field(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t     proto_tree *tree, dcerpc_info *di, uint8_t *drep, uint16_t type,\n\t\t     uint16_t *data)\n{\n\tuint16_t field;\n\tconst char *str;\n\n\toffset = dissect_ndr_uint16(\n\t\ttvb, offset, pinfo, NULL, di, drep,\n\t\thf_notify_field, &field);\n\n\tswitch(type) {\n\tcase PRINTER_NOTIFY_TYPE:\n\t\tstr = val_to_str_ext_const(field, &printer_notify_option_data_vals_ext,\n\t\t\t\t \"Unknown\");\n\t\tbreak;\n\tcase JOB_NOTIFY_TYPE:\n\t\tstr = val_to_str_ext_const(field, &job_notify_option_data_vals_ext,\n\t\t\t\t \"Unknown\");\n\t\tbreak;\n\tdefault:\n\t\tstr = \"Unknown notify type\";\n\t\tbreak;\n\t}\n\n\tproto_tree_add_uint_format_value(tree, hf_notify_field, tvb, offset - 2, 2, field, \"%s (%d)\", str, field);\n\n\tif (data)\n\t\t*data = field;\n\n\treturn offset;\n}\n\nstatic int\ndissect_NOTIFY_OPTION_DATA(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\t   proto_tree *tree, dcerpc_info *di, uint8_t *drep)\n{\n\tdcerpc_call_value *dcv = (dcerpc_call_value *)di->call_data;\n\tuint32_t count, i;\n\tuint16_t type;\n\n\tif (di->conformant_run)\n\t\treturn offset;\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep,\n\t\thf_notify_option_data_count, &count);\n\n\ttype = GPOINTER_TO_INT(dcv->private_data);\n\n\tfor (i = 0; i < count; i++)\n\t\toffset = dissect_notify_field(\n\t\t\ttvb, offset, pinfo, tree, di, drep, type, NULL);\n\n\treturn offset;\n}\n\nstatic const value_string printer_notify_types[] =\n{\n\t{ PRINTER_NOTIFY_TYPE, \"Printer notify\" },\n\t{ JOB_NOTIFY_TYPE, \"Job notify\" },\n\t{ 0, NULL }\n};\n\nstatic const\nchar *notify_plural(int count)\n{\n\tif (count == 1)\n\t\treturn \"notification\";\n\n\treturn \"notifies\";\n}\n\nstatic int ett_NOTIFY_OPTION;\n\nstatic int\ndissect_NOTIFY_OPTION(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t      proto_tree *tree, dcerpc_info *di, uint8_t *drep)\n{\n\tdcerpc_call_value *dcv = (dcerpc_call_value *)di->call_data;\n\tproto_item *item;\n\tproto_tree *subtree;\n\tuint16_t type;\n\tuint32_t count;\n\n\tsubtree = proto_tree_add_subtree(tree, tvb, offset, 0, ett_NOTIFY_OPTION, &item, \"Notify Option\");\n\n\toffset = dissect_ndr_uint16(tvb, offset, pinfo, subtree, di, drep,\n\t\t\t\t    hf_notify_option_type, &type);\n\n\tproto_item_append_text(\n\t\titem, \": %s\", val_to_str_wmem(pinfo->pool, type, printer_notify_types,\n\t\t\t\t\t \"Unknown (%d)\"));\n\n\toffset = dissect_ndr_uint16(tvb, offset, pinfo, subtree, di, drep,\n\t\t\t\t    hf_notify_option_reserved1, NULL);\n\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, subtree, di, drep,\n\t\t\t\t    hf_notify_option_reserved2, NULL);\n\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, subtree, di, drep,\n\t\t\t\t    hf_notify_option_reserved3, NULL);\n\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, subtree, di, drep,\n\t\t\t\t    hf_notify_option_count, &count);\n\n\tproto_item_append_text(\n\t\titem, \", %d %s\", count, notify_plural(count));\n\n\tdcv->private_data = GINT_TO_POINTER((int)type);\n\n\toffset = dissect_ndr_pointer(\n\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\tdissect_NOTIFY_OPTION_DATA, NDR_POINTER_UNIQUE,\n\t\t\"Notify Option Data\", -1);\n\n\treturn offset;\n}\n\nstatic int\ndissect_NOTIFY_OPTIONS_ARRAY(tvbuff_t *tvb, int offset,\n\t\t\t     packet_info *pinfo, proto_tree *tree,\n\t\t\t     dcerpc_info *di, uint8_t *drep)\n{\n\t/* Why is a check for di->conformant_run not required here? */\n\n\toffset = dissect_ndr_ucarray(\n\t\ttvb, offset, pinfo, tree, di, drep, dissect_NOTIFY_OPTION);\n\n\treturn offset;\n}\n\nstatic int ett_notify_options_flags;\n\nstatic const true_false_string tfs_notify_options_flags_refresh = {\n\t\"Data for all monitored fields is present\",\n\t\"Data for all monitored fields not present\"\n};\n\nstatic int\ndissect_notify_options_flags(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\t     proto_tree *tree, dcerpc_info *di, uint8_t *drep)\n{\n\tuint32_t flags;\n\tstatic int * const hf_flags[] = {\n\t\t&hf_notify_options_flags_refresh,\n\t\tNULL\n\t};\n\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, NULL, di, drep, -1, &flags);\n\n\tproto_tree_add_bitmask_value_with_flags(tree, tvb, offset - 4, hf_notify_options_flags,\n\t\t\t\t\tett_notify_options_flags, hf_flags, flags, BMT_NO_APPEND);\n\n\treturn offset;\n}\n\nint\ndissect_NOTIFY_OPTIONS_ARRAY_CTR(tvbuff_t *tvb, int offset,\n\t\t\t\t packet_info *pinfo, proto_tree *tree,\n\t\t\t\t dcerpc_info *di, uint8_t *drep)\n{\n\tif (di->conformant_run)\n\t\treturn offset;\n\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, tree, di, drep,\n\t\t\t\t    hf_notify_options_version, NULL);\n\n\toffset = dissect_notify_options_flags(tvb, offset, pinfo, tree, di, drep);\n\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, tree, di, drep,\n\t\t\t\t    hf_notify_options_count, NULL);\n\n\toffset = dissect_ndr_pointer(\n\t\ttvb, offset, pinfo, tree, di, drep,\n\t\tdissect_NOTIFY_OPTIONS_ARRAY, NDR_POINTER_UNIQUE,\n\t\t\"Notify Options Array\", -1);\n\n\treturn offset;\n}\n\n/*\n * SpoolssRFFPCNEX\n */\n\nstatic int ett_rffpcnex_flags;\n\nstatic int hf_rffpcnex_flags;\nstatic int hf_rffpcnex_options;\n\nstatic int hf_rffpcnex_flags_add_printer;\nstatic int hf_rffpcnex_flags_set_printer;\nstatic int hf_rffpcnex_flags_delete_printer;\nstatic int hf_rffpcnex_flags_failed_printer_connection;\n\nstatic const true_false_string tfs_rffpcnex_flags_add_printer = {\n\t\"Notify on add printer\",\n\t\"Don't notify on add printer\"\n};\n\nstatic const true_false_string tfs_rffpcnex_flags_set_printer = {\n\t\"Notify on set printer\",\n\t\"Don't notify on set printer\"\n};\n\nstatic const true_false_string tfs_rffpcnex_flags_delete_printer = {\n\t\"Notify on delete printer\",\n\t\"Don't notify on delete printer\"\n};\n\nstatic const true_false_string tfs_rffpcnex_flags_failed_connection_printer = {\n\t\"Notify on failed printer connection\",\n\t\"Don't notify on failed printer connection\"\n};\n\nstatic int hf_rffpcnex_flags_add_job;\nstatic int hf_rffpcnex_flags_set_job;\nstatic int hf_rffpcnex_flags_delete_job;\nstatic int hf_rffpcnex_flags_write_job;\n\nstatic const true_false_string tfs_rffpcnex_flags_add_job = {\n\t\"Notify on add job\",\n\t\"Don't notify on add job\"\n};\n\nstatic const true_false_string tfs_rffpcnex_flags_set_job = {\n\t\"Notify on set job\",\n\t\"Don't notify on set job\"\n};\n\nstatic const true_false_string tfs_rffpcnex_flags_delete_job = {\n\t\"Notify on delete job\",\n\t\"Don't notify on delete job\"\n};\n\nstatic const true_false_string tfs_rffpcnex_flags_write_job = {\n\t\"Notify on writejob\",\n\t\"Don't notify on write job\"\n};\n\nstatic int hf_rffpcnex_flags_add_form;\nstatic int hf_rffpcnex_flags_set_form;\nstatic int hf_rffpcnex_flags_delete_form;\n\nstatic const true_false_string tfs_rffpcnex_flags_add_form = {\n\t\"Notify on add form\",\n\t\"Don't notify on add form\"\n};\n\nstatic const true_false_string tfs_rffpcnex_flags_set_form = {\n\t\"Notify on set form\",\n\t\"Don't notify on set form\"\n};\n\nstatic const true_false_string tfs_rffpcnex_flags_delete_form = {\n\t\"Notify on delete form\",\n\t\"Don't notify on delete form\"\n};\n\nstatic int hf_rffpcnex_flags_add_port;\nstatic int hf_rffpcnex_flags_configure_port;\nstatic int hf_rffpcnex_flags_delete_port;\n\nstatic const true_false_string tfs_rffpcnex_flags_add_port = {\n\t\"Notify on add port\",\n\t\"Don't notify on add port\"\n};\n\nstatic const true_false_string tfs_rffpcnex_flags_configure_port = {\n\t\"Notify on configure port\",\n\t\"Don't notify on configure port\"\n};\n\nstatic const true_false_string tfs_rffpcnex_flags_delete_port = {\n\t\"Notify on delete port\",\n\t\"Don't notify on delete port\"\n};\n\nstatic int hf_rffpcnex_flags_add_print_processor;\nstatic int hf_rffpcnex_flags_delete_print_processor;\n\nstatic const true_false_string tfs_rffpcnex_flags_add_print_processor = {\n\t\"Notify on add driver\",\n\t\"Don't notify on add driver\"\n};\n\nstatic const true_false_string tfs_rffpcnex_flags_delete_print_processor = {\n\t\"Notify on add driver\",\n\t\"Don't notify on add driver\"\n};\n\nstatic int hf_rffpcnex_flags_add_driver;\nstatic int hf_rffpcnex_flags_set_driver;\nstatic int hf_rffpcnex_flags_delete_driver;\n\nstatic const true_false_string tfs_rffpcnex_flags_add_driver = {\n\t\"Notify on add driver\",\n\t\"Don't notify on add driver\"\n};\n\nstatic const true_false_string tfs_rffpcnex_flags_set_driver = {\n\t\"Notify on set driver\",\n\t\"Don't notify on set driver\"\n};\n\nstatic const true_false_string tfs_rffpcnex_flags_delete_driver = {\n\t\"Notify on delete driver\",\n\t\"Don't notify on delete driver\"\n};\n\nstatic int hf_rffpcnex_flags_timeout;\n\nstatic const true_false_string tfs_rffpcnex_flags_timeout = {\n\t\"Notify on timeout\",\n\t\"Don't notify on timeout\"\n};\n\nstatic int\nSpoolssRFFPCNEX_q(tvbuff_t *tvb, int offset,\n\t\t\t     packet_info *pinfo, proto_tree *tree,\n\t\t\t     dcerpc_info *di, uint8_t *drep)\n{\n\tuint32_t flags;\n\tstatic int * const hf_flags[] = {\n\t\t&hf_rffpcnex_flags_timeout,\n\t\t&hf_rffpcnex_flags_delete_driver,\n\t\t&hf_rffpcnex_flags_set_driver,\n\t\t&hf_rffpcnex_flags_add_driver,\n\t\t&hf_rffpcnex_flags_delete_print_processor,\n\t\t&hf_rffpcnex_flags_add_print_processor,\n\t\t&hf_rffpcnex_flags_delete_port,\n\t\t&hf_rffpcnex_flags_configure_port,\n\t\t&hf_rffpcnex_flags_add_port,\n\t\t&hf_rffpcnex_flags_delete_form,\n\t\t&hf_rffpcnex_flags_set_form,\n\t\t&hf_rffpcnex_flags_add_form,\n\t\t&hf_rffpcnex_flags_write_job,\n\t\t&hf_rffpcnex_flags_delete_job,\n\t\t&hf_rffpcnex_flags_set_job,\n\t\t&hf_rffpcnex_flags_add_job,\n\t\t&hf_rffpcnex_flags_failed_printer_connection,\n\t\t&hf_rffpcnex_flags_delete_printer,\n\t\t&hf_rffpcnex_flags_set_printer,\n\t\t&hf_rffpcnex_flags_add_printer,\n\t\tNULL\n\t};\n\n\t/* Parse packet */\n\n\toffset = dissect_nt_policy_hnd(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_hnd, NULL, NULL,\n\t\tPIDL_POLHND_USE);\n\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, NULL, di, drep, -1, &flags);\n\n\tproto_tree_add_bitmask_value(tree, tvb, offset - 4, hf_rffpcnex_flags,\n\t\t\t\t\tett_rffpcnex_flags, hf_flags, flags);\n\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, tree, di, drep,\n\t\t\t\t    hf_rffpcnex_options, NULL);\n\n\toffset = dissect_ndr_str_pointer_item(\n\t\ttvb, offset, pinfo, tree, di, drep, NDR_POINTER_UNIQUE,\n\t\t\"Server\", hf_servername, 0);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printerlocal, NULL);\n\n\toffset = dissect_ndr_pointer(\n\t\ttvb, offset, pinfo, tree, di, drep,\n\t\tdissect_NOTIFY_OPTIONS_ARRAY_CTR, NDR_POINTER_UNIQUE,\n\t\t\"Notify Options Container\", -1);\n\n\treturn offset;\n}\n\nstatic int\nSpoolssRFFPCNEX_r(tvbuff_t *tvb, int offset,\n\t\t\t     packet_info *pinfo, proto_tree *tree,\n\t\t\t     dcerpc_info *di, uint8_t *drep)\n{\n\t/* Parse packet */\n\n\toffset = dissect_doserror(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_rc, NULL);\n\n\treturn offset;\n}\n\n/*\n * SpoolssReplyOpenPrinter\n */\n\nstatic int\nSpoolssReplyOpenPrinter_q(tvbuff_t *tvb, int offset,\n\t\t\t\t     packet_info *pinfo, proto_tree *tree,\n\t\t\t\t     dcerpc_info *di, uint8_t *drep)\n{\n\tdcerpc_call_value *dcv = (dcerpc_call_value *)di->call_data;\n\tuint32_t printerlocal;\n\tchar *name;\n\n\t/* Parse packet */\n\tname=NULL;\n\toffset = dissect_ndr_cvstring(\n\t\ttvb, offset, pinfo, tree, di, drep, sizeof(uint16_t),\n\t\thf_servername, true, &name);\n\t/* ReplyOpenPrinter() stores the printername in se_data */\n\tif(!pinfo->fd->visited){\n\t\tif(!dcv->se_data){\n\t\t\tif(name){\n\t\t\t\tdcv->se_data = wmem_strdup(wmem_file_scope(), name);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (name)\n\t\tcol_append_fstr(pinfo->cinfo, COL_INFO, \", %s\", name);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printerlocal,\n\t\t&printerlocal);\n\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, tree, di, drep,\n\t\t\t\t    hf_printerdata_type, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_replyopenprinter_unk0,\n\t\tNULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_replyopenprinter_unk1,\n\t\tNULL);\n\n\treturn offset;\n}\n\nstatic int\nSpoolssReplyOpenPrinter_r(tvbuff_t *tvb, int offset,\n\t\t\t\t     packet_info *pinfo, proto_tree *tree,\n\t\t\t\t     dcerpc_info *di, uint8_t *drep)\n{\n\tdcerpc_call_value *dcv = (dcerpc_call_value *)di->call_data;\n\te_ctx_hnd policy_hnd;\n\tproto_item *hnd_item;\n\tuint32_t status;\n\n\t/* Parse packet */\n\n\toffset = dissect_nt_policy_hnd(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_hnd, &policy_hnd, &hnd_item,\n\t\tPIDL_POLHND_OPEN);\n\n\toffset = dissect_doserror(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_rc, &status);\n\n\tif( status == 0 ){\n\t\tconst char *pol_name;\n\n\t\tif (dcv->se_data){\n\t\t\tpol_name = wmem_strdup_printf(pinfo->pool,\n\t\t\t\t\"ReplyOpenPrinter(%s)\", (char *)dcv->se_data);\n\t\t} else {\n\t\t\tpol_name = \"Unknown ReplyOpenPrinter() handle\";\n\t\t}\n\t\tif(!pinfo->fd->visited){\n\t\t\tdcerpc_store_polhnd_name(&policy_hnd, pinfo, pol_name);\n\t\t}\n\n\t\tif(hnd_item)\n\t\t\tproto_item_append_text(hnd_item, \": %s\", pol_name);\n\t}\n\n\treturn offset;\n}\n\n/*\n * SpoolssGetPrinter\n */\n\n\nstatic int\nSpoolssGetPrinter_q(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\t       proto_tree *tree, dcerpc_info *di, uint8_t *drep )\n{\n\tdcerpc_call_value *dcv = (dcerpc_call_value *)di->call_data;\n\tuint32_t level;\n\n\t/* Parse packet */\n\n\toffset = dissect_nt_policy_hnd(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_hnd, NULL, NULL,\n\t\tPIDL_POLHND_USE);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_level, &level);\n\n\t/* GetPrinter() stores the level in se_data */\n\tif(!pinfo->fd->visited){\n\t\t\tdcv->se_data = GINT_TO_POINTER((int)level);\n\t}\n\n\n\tcol_append_fstr(pinfo->cinfo, COL_INFO, \", level %d\", level);\n\n\toffset = dissect_spoolss_buffer(\n\t\ttvb, offset, pinfo, tree, di, drep, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_offered, NULL);\n\n\treturn offset;\n}\n\nstatic int ett_PRINTER_INFO;\n\nstatic int\nSpoolssGetPrinter_r(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\t\tproto_tree *tree, dcerpc_info *di, uint8_t *drep)\n{\n\tdcerpc_call_value *dcv = (dcerpc_call_value *)di->call_data;\n\tBUFFER buffer;\n\tint16_t level = GPOINTER_TO_INT(dcv->se_data);\n\tproto_item *item = NULL;\n\tproto_tree *subtree = NULL;\n\n\tcol_append_fstr(pinfo->cinfo, COL_INFO, \", level %d\", level);\n\n\t/* Parse packet */\n\n\toffset = dissect_spoolss_buffer(\n\t\ttvb, offset, pinfo, tree, di, drep, &buffer);\n\n\tif (buffer.tvb) {\n\t\tsubtree = proto_tree_add_subtree_format( buffer.tree, buffer.tvb, 0, -1, ett_PRINTER_INFO, &item, \"Print info level %d\", level);\n\n\t\tswitch(level) {\n\t\tcase 0:\n\t\t\tdissect_PRINTER_INFO_0(\n\t\t\t\tbuffer.tvb, 0, pinfo, subtree, di, drep);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tdissect_PRINTER_INFO_1(\n\t\t\t\tbuffer.tvb, 0, pinfo, subtree, di, drep);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tdissect_PRINTER_INFO_2(\n\t\t\t\tbuffer.tvb, 0, pinfo, subtree, di, drep);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tdissect_PRINTER_INFO_3(\n\t\t\t\tbuffer.tvb, 0, pinfo, subtree, di, drep);\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tdissect_PRINTER_INFO_5(\n\t\t\t\tbuffer.tvb, 0, pinfo, subtree, di, drep);\n\t\t\tbreak;\n\t\tcase 7:\n\t\t\tdissect_PRINTER_INFO_7(\n\t\t\t\tbuffer.tvb, 0, pinfo, subtree, di, drep);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\texpert_add_info(pinfo, item, &ei_printer_info_level);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_needed, NULL);\n\n\toffset = dissect_doserror(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_rc, NULL);\n\n\treturn offset;\n}\n\n/*\n * SEC_DESC_BUF\n */\n\nstatic int ett_SEC_DESC_BUF;\n\nstatic int hf_secdescbuf_maxlen;\nstatic int hf_secdescbuf_undoc;\nstatic int hf_secdescbuf_len;\n\nstatic int\ndissect_SEC_DESC_BUF(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t     proto_tree *tree, dcerpc_info *di, uint8_t *drep)\n{\n\tproto_tree *subtree;\n\tuint32_t len;\n\n\t/* XXX: I think this is really a array of bytes which can be\n\t   dissected using dissect_ndr_cvstring().  The dissected data\n\t   can be passed to dissect_nt_sec_desc().  The problem is that\n\t   dissect_nt_cvstring() passes back a char * where it really\n\t   should pass back a tvb. */\n\n\tsubtree = proto_tree_add_subtree(\n\t\ttree, tvb, offset, 0, ett_SEC_DESC_BUF, NULL, \"Security descriptor buffer\");\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\thf_secdescbuf_maxlen, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\thf_secdescbuf_undoc, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\thf_secdescbuf_len, &len);\n\n\tdissect_nt_sec_desc(\n\t\ttvb, offset, pinfo, subtree, drep, true, len,\n\t\t&spoolss_printer_access_mask_info);\n\n\toffset += len;\n\n\treturn offset;\n}\n\n/*\n * SPOOL_PRINTER_INFO_LEVEL\n */\n\nstatic int ett_SPOOL_PRINTER_INFO_LEVEL;\n\n/* spool printer info */\n\nstatic int hf_spool_printer_info_devmode_ptr;\nstatic int hf_spool_printer_info_secdesc_ptr;\n\nint\ndissect_SPOOL_PRINTER_INFO(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\t   proto_tree *tree, dcerpc_info *di, uint8_t *drep)\n{\n\tproto_tree *subtree;\n\tuint32_t level;\n\tproto_tree *item;\n\n\tsubtree = proto_tree_add_subtree(\n\t\ttree, tvb, offset, 0, ett_SPOOL_PRINTER_INFO_LEVEL, &item, \"Spool printer info level\");\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_level, &level);\n\n\tswitch(level) {\n\tcase 3: {\n\t\tuint32_t devmode_ptr, secdesc_ptr;\n\n\t\t/* I can't seem to get this working with the correct\n\t\t   dissect_ndr_pointer() function so let's cheat and\n\t\t   dissect the pointers by hand. )-: */\n\n\t\toffset = dissect_ndr_uint32(\n\t\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\t\thf_spool_printer_info_devmode_ptr,\n\t\t\t&devmode_ptr);\n\n\t\toffset = dissect_ndr_uint32(\n\t\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\t\thf_spool_printer_info_secdesc_ptr,\n\t\t\t&secdesc_ptr);\n\n\t\tif (devmode_ptr)\n\t\t\toffset = dissect_DEVMODE_CTR(\n\t\t\t\ttvb, offset, pinfo, subtree, di, drep);\n\n\t\tif (secdesc_ptr)\n\t\t\toffset = dissect_SEC_DESC_BUF(\n\t\t\t\ttvb, offset, pinfo, subtree, di, drep);\n\n\tbreak;\n\t}\n\tcase 2:\n\tdefault:\n\t\texpert_add_info_format(pinfo, item, &ei_spool_printer_info_level, \"Unknown spool printer info level %d\", level);\n\t\tbreak;\n\t}\n\n\treturn offset;\n}\n\n/*\n * SpoolssSetPrinter\n */\n\nstatic int hf_setprinter_cmd;\n\nstatic const value_string setprinter_cmd_vals[] = {\n\t{ SPOOLSS_PRINTER_CONTROL_UNPAUSE, \"Unpause\" },\n\t{ SPOOLSS_PRINTER_CONTROL_PAUSE, \"Pause\" },\n\t{ SPOOLSS_PRINTER_CONTROL_RESUME, \"Resume\" },\n\t{ SPOOLSS_PRINTER_CONTROL_PURGE, \"Purge\" },\n\t{ SPOOLSS_PRINTER_CONTROL_SET_STATUS, \"Set status\" },\n\t{ 0, NULL }\n};\n\nstatic int\nSpoolssSetPrinter_q(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\t       proto_tree *tree, dcerpc_info *di, uint8_t *drep)\n{\n\tuint32_t level;\n\n\t/* Parse packet */\n\n\toffset = dissect_nt_policy_hnd(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_hnd, NULL, NULL,\n\t\tPIDL_POLHND_USE);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_level, &level);\n\n\tcol_append_fstr(pinfo->cinfo, COL_INFO, \", level %d\", level);\n\n\toffset = dissect_SPOOL_PRINTER_INFO(\n\t\ttvb, offset, pinfo, tree, di, drep);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep,\n\t\thf_setprinter_cmd, NULL);\n\n\treturn offset;\n}\n\nstatic int\nSpoolssSetPrinter_r(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\t\tproto_tree *tree, dcerpc_info *di, uint8_t *drep)\n{\n\t/* Parse packet */\n\n\toffset = dissect_doserror(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_rc, NULL);\n\n\treturn offset;\n}\n\n/*\n * FORM_REL\n */\n\nstatic const value_string form_type_vals[] =\n{\n\t{ SPOOLSS_FORM_USER, \"User\" },\n\t{ SPOOLSS_FORM_BUILTIN, \"Builtin\" },\n\t{ SPOOLSS_FORM_PRINTER, \"Printer\" },\n\t{ 0, NULL }\n};\n\nstatic int ett_FORM_REL;\n\nstatic int\ndissect_FORM_REL(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\t    proto_tree *tree, dcerpc_info *di, uint8_t *drep, int struct_start)\n{\n\tproto_item *item;\n\tproto_tree *subtree;\n\tuint32_t flags;\n\tint item_start = offset;\n\tchar *name = NULL;\n\n\tsubtree = proto_tree_add_subtree(tree, tvb, offset, 0, ett_FORM_REL, &item, \"Form\");\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_form_flags, &flags);\n\n\toffset = dissect_spoolss_relstr(\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_form_name,\n\t\tstruct_start, &name);\n\n\tif (name) {\n\t\tproto_item_append_text(item, \": %s\", name);\n\t}\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\thf_form_width, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\thf_form_height, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\thf_form_left_margin, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\thf_form_top_margin, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\thf_form_horiz_len, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\thf_form_vert_len, NULL);\n\n\tproto_item_set_len(item, offset - item_start);\n\n\treturn offset;\n}\n\n/*\n * SpoolssEnumForms\n */\n\nstatic int\nSpoolssEnumForms_q(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\t      proto_tree *tree, dcerpc_info *di, uint8_t *drep)\n{\n\tdcerpc_call_value *dcv = (dcerpc_call_value *)di->call_data;\n\tuint32_t level;\n\tproto_item *hidden_item;\n\n\thidden_item = proto_tree_add_uint(\n\t\ttree, hf_form, tvb, offset, 0, 1);\n\tproto_item_set_hidden(hidden_item);\n\n\t/* Parse packet */\n\n\toffset = dissect_nt_policy_hnd(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_hnd, NULL, NULL,\n\t\tPIDL_POLHND_USE);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_level, &level);\n\n\t/* EnumForms() stores the level in se_data */\n\tif(!pinfo->fd->visited){\n\t\t\tdcv->se_data = GINT_TO_POINTER((int)level);\n\t}\n\n\tcol_append_fstr(pinfo->cinfo, COL_INFO, \", level %d\", level);\n\n\toffset = dissect_spoolss_buffer(\n\t\ttvb, offset, pinfo, tree, di, drep, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_offered, NULL);\n\n\treturn offset;\n}\n\nstatic int\nSpoolssEnumForms_r(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\t      proto_tree *tree, dcerpc_info *di, uint8_t *drep)\n{\n\tdcerpc_call_value *dcv = (dcerpc_call_value *)di->call_data;\n\tBUFFER buffer;\n\tuint32_t level = GPOINTER_TO_UINT(dcv->se_data), i, count;\n\tint buffer_offset;\n\tproto_item *hidden_item;\n\n\thidden_item = proto_tree_add_uint(\n\t\ttree, hf_form, tvb, offset, 0, 1);\n\tproto_item_set_hidden(hidden_item);\n\n\t/* Parse packet */\n\n\toffset = dissect_spoolss_buffer(\n\t\ttvb, offset, pinfo, tree, di, drep, &buffer);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_needed, NULL);\n\n\tcol_append_fstr(pinfo->cinfo, COL_INFO, \", level %d\", level);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_enumforms_num, &count);\n\n\t/* Unfortunately this array isn't in NDR format so we can't\n\t   use prs_array().  The other weird thing is the\n\t   struct_start being inside the loop rather than outside.\n\t   Very strange. */\n\n\tbuffer_offset = 0;\n\n\tfor (i = 0; i < count; i++) {\n\t\tint struct_start = buffer_offset;\n\n\t\tbuffer_offset = dissect_FORM_REL(\n\t\t\tbuffer.tvb, buffer_offset, pinfo, buffer.tree, di, drep,\n\t\t\tstruct_start);\n\t}\n\n\toffset = dissect_doserror(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_rc, NULL);\n\n\treturn offset;\n}\n\n/*\n * SpoolssDeletePrinter\n */\n\nstatic int\nSpoolssDeletePrinter_q(tvbuff_t *tvb, int offset,\n\t\t\t\t  packet_info *pinfo, proto_tree *tree,\n\t\t\t\t  dcerpc_info *di, uint8_t *drep)\n{\n\t/* Parse packet */\n\n\toffset = dissect_nt_policy_hnd(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_hnd, NULL, NULL,\n\t\tPIDL_POLHND_USE);\n\n\treturn offset;\n}\n\nstatic int\nSpoolssDeletePrinter_r(tvbuff_t *tvb, int offset,\n\t\t\t\t  packet_info *pinfo, proto_tree *tree,\n\t\t\t\t  dcerpc_info *di, uint8_t *drep)\n{\n\t/* Parse packet */\n\n\toffset = dissect_nt_policy_hnd(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_hnd, NULL, NULL,\n\t\tPIDL_POLHND_USE);\n\n\toffset = dissect_doserror(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_rc, NULL);\n\n\treturn offset;\n}\n\nstatic int\nSpoolssAddPrinterEx_r(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\t\t proto_tree *tree, dcerpc_info *di, uint8_t *drep)\n{\n\tdcerpc_call_value *dcv = (dcerpc_call_value *)di->call_data;\n\te_ctx_hnd policy_hnd;\n\tproto_item *hnd_item;\n\tuint32_t status;\n\n\t/* Parse packet */\n\n\toffset = dissect_nt_policy_hnd(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_hnd, &policy_hnd, &hnd_item,\n\t\tPIDL_POLHND_OPEN);\n\n\toffset = dissect_doserror(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_rc, &status);\n\n\tif( status == 0 ){\n\t\tconst char *pol_name;\n\n\t\tif (dcv->se_data){\n\t\t\tpol_name = wmem_strdup_printf(pinfo->pool,\n\t\t\t\t\"AddPrinterEx(%s)\", (char *)dcv->se_data);\n\t\t} else {\n\t\t\tpol_name = \"Unknown AddPrinterEx() handle\";\n\t\t}\n\t\tif(!pinfo->fd->visited){\n\t\t\tdcerpc_store_polhnd_name(&policy_hnd, pinfo, pol_name);\n\t\t}\n\n\t\tif(hnd_item)\n\t\t\tproto_item_append_text(hnd_item, \": %s\", pol_name);\n\t}\n\n\treturn offset;\n}\n\n/*\n * SpoolssEnumPrinterData\n */\n\nstatic int hf_enumprinterdata_enumindex;\nstatic int hf_enumprinterdata_value_offered;\nstatic int hf_enumprinterdata_data_offered;\nstatic int hf_enumprinterdata_value_len;\nstatic int hf_enumprinterdata_value_needed;\nstatic int hf_enumprinterdata_data_needed;\n\nstatic int\nSpoolssEnumPrinterData_q(tvbuff_t *tvb, int offset,\n\t\t\t\t    packet_info *pinfo, proto_tree *tree,\n\t\t\t\t    dcerpc_info *di, uint8_t *drep)\n{\n\tuint32_t ndx;\n\tproto_item *hidden_item;\n\n\thidden_item = proto_tree_add_uint(\n\t\ttree, hf_printerdata, tvb, offset, 0, 1);\n\tproto_item_set_hidden(hidden_item);\n\n\t/* Parse packet */\n\n\toffset = dissect_nt_policy_hnd(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_hnd, NULL, NULL,\n\t\tPIDL_POLHND_USE);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep,\n\t\thf_enumprinterdata_enumindex, &ndx);\n\n\tcol_append_fstr(pinfo->cinfo, COL_INFO, \", index %d\", ndx);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep,\n\t\thf_enumprinterdata_value_offered, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep,\n\t\thf_enumprinterdata_data_offered, NULL);\n\n\treturn offset;\n}\n\nstatic int\nSpoolssEnumPrinterData_r(tvbuff_t *tvb, int offset,\n\t\t\t\t    packet_info *pinfo, proto_tree *tree,\n\t\t\t\t    dcerpc_info *di, uint8_t *drep)\n{\n\tuint32_t value_len, type;\n\tchar *value;\n\tproto_item *value_item;\n\tproto_tree *value_subtree;\n\tproto_item *hidden_item;\n\n\thidden_item = proto_tree_add_uint(\n\t\ttree, hf_printerdata, tvb, offset, 0, 1);\n\tproto_item_set_hidden(hidden_item);\n\n\t/* Parse packet */\n\n\tvalue_subtree = proto_tree_add_subtree(tree, tvb, offset, 0, ett_printerdata_value, &value_item, \"Value\");\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, value_subtree, di, drep,\n\t\thf_enumprinterdata_value_len, &value_len);\n\n\tif (value_len) {\n\t\tdissect_spoolss_uint16uni(\n\t\t\ttvb, offset, pinfo, value_subtree, drep, &value, hf_value_name);\n\n\t\toffset += value_len * 2;\n\n\t\tif (value && value[0])\n\t\t\tcol_append_fstr(pinfo->cinfo, COL_INFO, \", %s\", value);\n\n\t\tproto_item_append_text(value_item, \": %s\", value);\n\n\t\thidden_item = proto_tree_add_string(\n\t\t\ttree, hf_printerdata_value, tvb, offset, 0, value);\n\t\tproto_item_set_hidden(hidden_item);\n\t}\n\n\tproto_item_set_len(value_item, value_len * 2 + 4);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, value_subtree, di, drep,\n\t\thf_enumprinterdata_value_needed, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printerdata_type, &type);\n\n\toffset = dissect_printerdata_data(\n\t\ttvb, offset, pinfo, tree, di, drep, type);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep,\n\t\thf_enumprinterdata_data_needed, NULL);\n\n\toffset = dissect_doserror(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_rc, NULL);\n\n\treturn offset;\n}\n\n/*\n * SpoolssEnumPrinters\n */\n\nstatic int ett_enumprinters_flags;\n\nstatic int hf_enumprinters_flags;\nstatic int hf_enumprinters_flags_local;\nstatic int hf_enumprinters_flags_name;\nstatic int hf_enumprinters_flags_shared;\nstatic int hf_enumprinters_flags_default;\nstatic int hf_enumprinters_flags_connections;\nstatic int hf_enumprinters_flags_network;\nstatic int hf_enumprinters_flags_remote;\n\nstatic int\nSpoolssEnumPrinters_q(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\t\t proto_tree *tree, dcerpc_info *di, uint8_t *drep)\n{\n\tuint32_t level, flags;\n\tdcerpc_call_value *dcv = (dcerpc_call_value *)di->call_data;\n\tstatic int * const hf_flags[] = {\n\t\t&hf_enumprinters_flags_network,\n\t\t&hf_enumprinters_flags_shared,\n\t\t&hf_enumprinters_flags_remote,\n\t\t&hf_enumprinters_flags_name,\n\t\t&hf_enumprinters_flags_connections,\n\t\t&hf_enumprinters_flags_local,\n\t\t&hf_enumprinters_flags_default,\n\t\tNULL\n\t};\n\n\t/* Parse packet */\n\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, NULL, di, drep, -1, &flags);\n\n\tproto_tree_add_bitmask_value(tree, tvb, offset - 4, hf_enumprinters_flags,\n\t\t\t\t\tett_enumprinters_flags, hf_flags, flags);\n\n\toffset = dissect_ndr_str_pointer_item(\n\t\ttvb, offset, pinfo, tree, di, drep,\n\t\tNDR_POINTER_UNIQUE, \"Server name\", hf_servername, 0);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_level, &level);\n\n\t/* GetPrinter() stores the level in se_data */\n\tif(!pinfo->fd->visited){\n\t\tdcv->se_data = GINT_TO_POINTER((int)level);\n\t}\n\n\tcol_append_fstr(pinfo->cinfo, COL_INFO, \", level %d\", level);\n\n\toffset = dissect_spoolss_buffer(\n\t\ttvb, offset, pinfo, tree, di, drep, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_offered, NULL);\n\n\treturn offset;\n}\n\nstatic int\nSpoolssEnumPrinters_r(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\t\t proto_tree *tree, dcerpc_info *di, uint8_t *drep)\n{\n\tuint32_t num_drivers;\n\tdcerpc_call_value *dcv = (dcerpc_call_value *)di->call_data;\n\tint16_t level = GPOINTER_TO_INT(dcv->se_data);\n\tBUFFER buffer;\n\tproto_item *item;\n\tproto_tree *subtree = NULL;\n\n\tcol_append_fstr(pinfo->cinfo, COL_INFO, \", level %d\", level);\n\n\t/* Parse packet */\n\n\toffset = dissect_spoolss_buffer(\n\t\ttvb, offset, pinfo, tree, di, drep, &buffer);\n\n\tif (buffer.tvb) {\n\t\tsubtree = proto_tree_add_subtree_format( buffer.tree, buffer.tvb, 0, -1, ett_PRINTER_INFO, &item, \"Print info level %d\", level);\n\n\t\tswitch(level) {\n\t\tcase 0:\n\t\t\tdissect_PRINTER_INFO_0(\n\t\t\t\tbuffer.tvb, 0, pinfo, subtree, di, drep);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tdissect_PRINTER_INFO_1(\n\t\t\t\tbuffer.tvb, 0, pinfo, subtree, di, drep);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tdissect_PRINTER_INFO_2(\n\t\t\t\tbuffer.tvb, 0, pinfo, subtree, di, drep);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tdissect_PRINTER_INFO_3(\n\t\t\t\tbuffer.tvb, 0, pinfo, subtree, di, drep);\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tdissect_PRINTER_INFO_5(\n\t\t\t\tbuffer.tvb, 0, pinfo, subtree, di, drep);\n\t\t\tbreak;\n\t\tcase 7:\n\t\t\tdissect_PRINTER_INFO_7(\n\t\t\t\tbuffer.tvb, 0, pinfo, subtree, di, drep);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\texpert_add_info(pinfo, item, &ei_printer_info_level);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_needed, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_returned,\n\t\t&num_drivers);\n\n\toffset = dissect_doserror(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_rc, NULL);\n\n\treturn offset;\n}\n\n/*\n * AddPrinterDriver\n */\nstatic int\nSpoolssAddPrinterDriver_r(tvbuff_t *tvb, int offset,\n\t\t\t\t     packet_info *pinfo, proto_tree *tree,\n\t\t\t\t     dcerpc_info *di, uint8_t *drep)\n{\n\t/* Parse packet */\n\n\toffset = dissect_doserror(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_rc, NULL);\n\n\treturn offset;\n}\n\n/*\n * FORM_1\n */\n\nstatic int ett_FORM_1;\n\nstatic int\ndissect_FORM_1(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\t  proto_tree *tree, dcerpc_info *di, uint8_t *drep)\n{\n\tproto_tree *subtree;\n\tuint32_t flags;\n\n\tsubtree = proto_tree_add_subtree(tree, tvb, offset, 0, ett_FORM_1, NULL, \"Form level 1\");\n\n\toffset = dissect_ndr_str_pointer_item(\n\t\ttvb, offset, pinfo, subtree, di, drep, NDR_POINTER_UNIQUE,\n\t\t\"Name\", hf_form_name, 0);\n\n\t/* Eek - we need to know whether this pointer was NULL or not.\n\t   Currently there is not any way to do this. */\n\n\tif (tvb_reported_length_remaining(tvb, offset) <= 0)\n\t\tgoto done;\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_form_flags, &flags);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\thf_form_unknown, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\thf_form_width, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\thf_form_height, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\thf_form_left_margin, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\thf_form_top_margin, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\thf_form_horiz_len, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\thf_form_vert_len, NULL);\n\n done:\n\treturn offset;\n}\n\n/*\n * FORM_CTR\n */\n\nstatic int ett_FORM_CTR;\n\nint\ndissect_FORM_CTR(tvbuff_t *tvb, int offset,\n\t\t\t    packet_info *pinfo, proto_tree *tree,\n\t\t\t    dcerpc_info *di, uint8_t *drep)\n{\n\tproto_tree *subtree;\n\tproto_item *item;\n\tuint32_t level;\n\n\tsubtree = proto_tree_add_subtree(tree, tvb, offset, 0, ett_FORM_CTR, &item, \"Form container\");\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_form_level, &level);\n\n\tswitch(level) {\n\tcase 1:\n\t\toffset = dissect_FORM_1(tvb, offset, pinfo, subtree, di, drep);\n\t\tbreak;\n\n\tdefault:\n\t\texpert_add_info_format(pinfo, item, &ei_form_level, \"Unknown form info level %d\", level);\n\t\tbreak;\n\t}\n\n\treturn offset;\n}\n\n/*\n * AddForm\n */\n\nstatic int\nSpoolssAddForm_q(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\t    proto_tree *tree, dcerpc_info *di, uint8_t *drep)\n{\n\tdcerpc_call_value *dcv = (dcerpc_call_value *)di->call_data;\n\tuint32_t level;\n\tproto_item *hidden_item;\n\n\thidden_item = proto_tree_add_uint(\n\t\ttree, hf_form, tvb, offset, 0, 1);\n\tproto_item_set_hidden(hidden_item);\n\n\t/* Parse packet */\n\n\toffset = dissect_nt_policy_hnd(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_hnd, NULL, NULL,\n\t\tPIDL_POLHND_USE);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_form_level, &level);\n\n\tcol_append_fstr(pinfo->cinfo, COL_INFO, \", level %d\", level);\n\n\t/* AddForm() stores the level in se_data */\n\tif(!pinfo->fd->visited){\n\t\t\tdcv->se_data = GUINT_TO_POINTER((int)level);\n\t}\n\n\toffset = dissect_FORM_CTR(tvb, offset, pinfo, tree, di, drep);\n\n\treturn offset;\n}\n\nstatic int\nSpoolssAddForm_r(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\t    proto_tree *tree, dcerpc_info *di, uint8_t *drep)\n{\n\tproto_item *hidden_item;\n\n\thidden_item = proto_tree_add_uint(\n\t\ttree, hf_form, tvb, offset, 0, 1);\n\tproto_item_set_hidden(hidden_item);\n\n\t/* Parse packet */\n\n\toffset = dissect_doserror(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_rc, NULL);\n\n\treturn offset;\n}\n\n/*\n * DeleteForm\n */\n\nstatic int\nSpoolssDeleteForm_q(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\t       proto_tree *tree, dcerpc_info *di, uint8_t *drep)\n{\n\tproto_item *hidden_item;\n\tchar *name = NULL;\n\n\thidden_item = proto_tree_add_uint(\n\t\ttree, hf_form, tvb, offset, 0, 1);\n\tproto_item_set_hidden(hidden_item);\n\n\t/* Parse packet */\n\n\toffset = dissect_nt_policy_hnd(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_hnd, NULL, NULL,\n\t\tPIDL_POLHND_USE);\n\n\toffset = dissect_ndr_cvstring(\n\t\ttvb, offset, pinfo, tree, di, drep,\n\t\tsizeof(uint16_t), hf_form_name, true, &name);\n\n\tif (name)\n\t\tcol_append_fstr(pinfo->cinfo, COL_INFO, \", %s\", name);\n\n\treturn offset;\n}\n\nstatic int\nSpoolssDeleteForm_r(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\t    proto_tree *tree, dcerpc_info *di, uint8_t *drep)\n{\n\tproto_item *hidden_item;\n\n\thidden_item = proto_tree_add_uint(\n\t\ttree, hf_form, tvb, offset, 0, 1);\n\tproto_item_set_hidden(hidden_item);\n\n\t/* Parse packet */\n\n\toffset = dissect_doserror(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_rc, NULL);\n\n\treturn offset;\n}\n\n/*\n * SetForm\n */\n\nstatic int\nSpoolssSetForm_q(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\t    proto_tree *tree, dcerpc_info *di, uint8_t *drep)\n{\n\tchar *name = NULL;\n\tuint32_t level;\n\tproto_item *hidden_item;\n\n\thidden_item = proto_tree_add_uint(\n\t\ttree, hf_form, tvb, offset, 0, 1);\n\tproto_item_set_hidden(hidden_item);\n\n\t/* Parse packet */\n\n\toffset = dissect_nt_policy_hnd(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_hnd, NULL, NULL,\n\t\tPIDL_POLHND_USE);\n\n\toffset = dissect_ndr_cvstring(\n\t\ttvb, offset, pinfo, tree, di, drep,\n\t\tsizeof(uint16_t), hf_form_name, true, &name);\n\n\tif (name)\n\t\tcol_append_fstr(pinfo->cinfo, COL_INFO, \", %s\", name);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_form_level, &level);\n\n\tcol_append_fstr(pinfo->cinfo, COL_INFO, \", level %d\", level);\n\n\toffset = dissect_FORM_CTR(tvb, offset, pinfo, tree, di, drep);\n\n\treturn offset;\n}\n\nstatic int\nSpoolssSetForm_r(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\t    proto_tree *tree, dcerpc_info *di, uint8_t *drep)\n{\n\tproto_item *hidden_item;\n\n\thidden_item = proto_tree_add_uint(\n\t\ttree, hf_form, tvb, offset, 0, 1);\n\tproto_item_set_hidden(hidden_item);\n\n\t/* Parse packet */\n\n\toffset = dissect_doserror(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_rc, NULL);\n\n\treturn offset;\n}\n\n/*\n * GetForm\n */\n\nstatic int\nSpoolssGetForm_q(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\t    proto_tree *tree, dcerpc_info *di, uint8_t *drep)\n{\n\tdcerpc_call_value *dcv = (dcerpc_call_value *)di->call_data;\n\tproto_item *hidden_item;\n\tuint32_t level;\n\tchar *name;\n\n\thidden_item = proto_tree_add_uint(\n\t\ttree, hf_form, tvb, offset, 0, 1);\n\tproto_item_set_hidden(hidden_item);\n\n\t/* Parse packet */\n\n\toffset = dissect_nt_policy_hnd(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_hnd, NULL, NULL,\n\t\tPIDL_POLHND_USE);\n\n\toffset = dissect_ndr_cvstring(\n\t\ttvb, offset, pinfo, tree, di, drep,\n\t\tsizeof(uint16_t), hf_form_name, true, &name);\n\n\tcol_append_fstr(pinfo->cinfo, COL_INFO, \", %s\", name);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_form_level, &level);\n\n\t/* GetForm() stores the level in se_data */\n\tif(!pinfo->fd->visited){\n\t\t\tdcv->se_data = GUINT_TO_POINTER((int)level);\n\t}\n\n\tcol_append_fstr(pinfo->cinfo, COL_INFO, \", level %d\",\n\t\t\t\tlevel);\n\n\toffset = dissect_spoolss_buffer(tvb, offset, pinfo, tree, di, drep, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_offered, NULL);\n\n\treturn offset;\n}\n\nstatic int\nSpoolssGetForm_r(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\t    proto_tree *tree, dcerpc_info *di, uint8_t *drep)\n{\n\tdcerpc_call_value *dcv = (dcerpc_call_value *)di->call_data;\n\tBUFFER buffer;\n\tuint32_t level = GPOINTER_TO_UINT(dcv->se_data);\n\tproto_item *hidden_item;\n\n\thidden_item = proto_tree_add_uint(\n\t\ttree, hf_form, tvb, offset, 0, 1);\n\tproto_item_set_hidden(hidden_item);\n\n\t/* Parse packet */\n\n\toffset = dissect_spoolss_buffer(\n\t\ttvb, offset, pinfo, tree, di, drep, &buffer);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_needed, NULL);\n\n\tcol_append_fstr(pinfo->cinfo, COL_INFO, \", level %d\", level);\n\n\tif (buffer.tvb) {\n\t\tint buffer_offset = 0;\n\n\t\tswitch(level) {\n\t\tcase 1: {\n\t\t\tint struct_start = buffer_offset;\n\n\t\t\t/*buffer_offset = */dissect_FORM_REL(\n\t\t\t\tbuffer.tvb, buffer_offset, pinfo, tree, di, drep,\n\t\t\t\tstruct_start);\n\t\t\tbreak;\n\t\t}\n\n\t\tdefault:\n\t\t\tproto_tree_add_expert_format(buffer.tree, pinfo, &ei_form_level, buffer.tvb, buffer_offset, -1, \"Unknown form info level %d\", level);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\toffset = dissect_doserror(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_rc, NULL);\n\n\treturn offset;\n}\n\n\n/* A generic reply function that just parses the status code.  Useful for\n   unimplemented dissectors so the status code can be inserted into the\n   INFO column. */\n\nstatic int\nSpoolssGeneric_r(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\t    proto_tree *tree, dcerpc_info *di, uint8_t *drep)\n{\n\tint len = tvb_reported_length(tvb);\n\n\tproto_tree_add_expert(tree, pinfo, &ei_unimplemented_dissector, tvb, offset, 0);\n\n\toffset = dissect_doserror(\n\t\ttvb, len - 4, pinfo, tree, di, drep, hf_rc, NULL);\n\n\treturn offset;\n}\n\n/*\n * JOB_INFO_1\n */\n\nstatic int ett_JOB_INFO_1;\n\nstatic int\ndissect_spoolss_JOB_INFO_1(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\t   proto_tree *tree, dcerpc_info *di, uint8_t *drep)\n{\n\tproto_item *item;\n\tproto_tree *subtree;\n\tint struct_start = offset;\n\tchar *document_name;\n\n\tsubtree = proto_tree_add_subtree(tree, tvb, offset, 0, ett_JOB_INFO_1, &item, \"Job info level 1\");\n\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, subtree, di, drep,\n\t\t\t\t    hf_job_id, NULL);\n\n\toffset = dissect_spoolss_relstr(\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_printername,\n\t\tstruct_start, NULL);\n\n\toffset = dissect_spoolss_relstr(\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_servername,\n\t\tstruct_start, NULL);\n\n\toffset = dissect_spoolss_relstr(\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_username,\n\t\tstruct_start, NULL);\n\n\toffset = dissect_spoolss_relstr(\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_documentname,\n\t\tstruct_start, &document_name);\n\n\tproto_item_append_text(item, \": %s\", document_name);\n\n\toffset = dissect_spoolss_relstr(\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_datatype,\n\t\tstruct_start, NULL);\n\n\toffset = dissect_spoolss_relstr(\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_textstatus,\n\t\tstruct_start, NULL);\n\n\toffset = dissect_job_status(tvb, offset, pinfo, subtree, di, drep);\n\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, subtree, di, drep,\n\t\t\t\t    hf_job_priority, NULL);\n\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, subtree, di, drep,\n\t\t\t\t    hf_job_position, NULL);\n\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, subtree, di, drep,\n\t\t\t\t    hf_job_totalpages, NULL);\n\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, subtree, di, drep,\n\t\t\t\t    hf_job_pagesprinted, NULL);\n\n\toffset = dissect_SYSTEM_TIME(\n\t\ttvb, offset, pinfo, subtree, di, drep, \"Job Submission Time\",\n\t\ttrue, NULL);\n\n\tproto_item_set_len(item, offset - struct_start);\n\n\treturn offset;\n}\n\n/*\n * JOB_INFO_2\n */\n\nstatic int ett_JOB_INFO_2;\n\nstatic int\ndissect_spoolss_JOB_INFO_2(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\t   proto_tree *tree, dcerpc_info *di, uint8_t *drep)\n{\n\tproto_item *item;\n\tproto_tree *subtree;\n\tint struct_start = offset;\n\tchar *document_name;\n\tuint32_t devmode_offset, secdesc_offset;\n\n\tsubtree = proto_tree_add_subtree(tree, tvb, offset, 0, ett_JOB_INFO_2, &item, \"Job info level 2\");\n\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, subtree, di, drep,\n\t\t\t\t    hf_job_id, NULL);\n\n\toffset = dissect_spoolss_relstr(\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_printername,\n\t\tstruct_start, NULL);\n\n\toffset = dissect_spoolss_relstr(\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_machinename,\n\t\tstruct_start, NULL);\n\n\toffset = dissect_spoolss_relstr(\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_username,\n\t\tstruct_start, NULL);\n\n\toffset = dissect_spoolss_relstr(\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_documentname,\n\t\tstruct_start, &document_name);\n\n\tproto_item_append_text(item, \": %s\", document_name);\n\n\toffset = dissect_spoolss_relstr(\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_notifyname,\n\t\tstruct_start, NULL);\n\n\toffset = dissect_spoolss_relstr(\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_datatype,\n\t\tstruct_start, NULL);\n\n\toffset = dissect_spoolss_relstr(\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_printprocessor,\n\t\tstruct_start, NULL);\n\n\toffset = dissect_spoolss_relstr(\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_parameters,\n\t\tstruct_start, NULL);\n\n\toffset = dissect_spoolss_relstr(\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_drivername,\n\t\tstruct_start, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, NULL, di, drep, hf_offset,\n\t\t&devmode_offset);\n\n\tdissect_DEVMODE(\n\t\ttvb, devmode_offset - 4 + struct_start, pinfo, subtree, di, drep);\n\n\toffset = dissect_spoolss_relstr(\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_textstatus,\n\t\tstruct_start, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, NULL, di, drep, hf_offset,\n\t\t&secdesc_offset);\n\n\tdissect_nt_sec_desc(\n\t\ttvb, secdesc_offset, pinfo, subtree, drep,\n\t\tfalse, -1,\n\t\t&spoolss_job_access_mask_info);\n\n\toffset = dissect_job_status(tvb, offset, pinfo, subtree, di, drep);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_job_priority, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_job_position, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, NULL, di, drep, hf_start_time, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, NULL, di, drep, hf_end_time, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_job_totalpages, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_job_size, NULL);\n\n\toffset = dissect_SYSTEM_TIME(\n\t\ttvb, offset, pinfo, subtree, di, drep, \"Job Submission Time\",\n\t\ttrue, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, NULL, di, drep, hf_elapsed_time, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_job_pagesprinted, NULL);\n\n\tproto_item_set_len(item, offset - struct_start);\n\n\treturn offset;\n}\n\n/*\n * EnumJobs\n */\n\nstatic int hf_enumjobs_firstjob;\nstatic int hf_enumjobs_numjobs;\n\nstatic int\nSpoolssEnumJobs_q(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\t     proto_tree *tree, dcerpc_info *di, uint8_t *drep)\n{\n\tdcerpc_call_value *dcv = (dcerpc_call_value *)di->call_data;\n\tuint32_t level;\n\n\t/* Parse packet */\n\n\toffset = dissect_nt_policy_hnd(\n\t\ttvb, offset, pinfo, tree, di, drep,\n\t\thf_hnd, NULL, NULL, PIDL_POLHND_USE);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_enumjobs_firstjob, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_enumjobs_numjobs, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_level, &level);\n\n\t/* EnumJobs() stores the level in se_data */\n\tif(!pinfo->fd->visited){\n\t\t\tdcv->se_data = GUINT_TO_POINTER((int)level);\n\t}\n\n\tcol_append_fstr(pinfo->cinfo, COL_INFO, \", level %d\", level);\n\n\toffset = dissect_spoolss_buffer(tvb, offset, pinfo, tree, di, drep, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_offered, NULL);\n\n\treturn offset;\n}\n\nstatic int\nSpoolssEnumJobs_r(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\t     proto_tree *tree, dcerpc_info *di, uint8_t *drep)\n{\n\tdcerpc_call_value *dcv = (dcerpc_call_value *)di->call_data;\n\tint16_t level = GPOINTER_TO_UINT(dcv->se_data);\n\tBUFFER buffer;\n\tuint32_t num_jobs, i;\n\tint buffer_offset;\n\n\t/* Parse packet */\n\n\toffset = dissect_spoolss_buffer(\n\t\ttvb, offset, pinfo, tree, di, drep, &buffer);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_needed, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_enumjobs_numjobs,\n\t\t&num_jobs);\n\n\tbuffer_offset = 0;\n\n\tfor (i = 0; i < num_jobs; i++) {\n\t\tswitch(level) {\n\t\tcase 1:\n\t\t\tbuffer_offset = dissect_spoolss_JOB_INFO_1(\n\t\t\t\tbuffer.tvb, buffer_offset, pinfo,\n\t\t\t\tbuffer.tree, di, drep);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tbuffer_offset = dissect_spoolss_JOB_INFO_2(\n\t\t\t\tbuffer.tvb, buffer_offset, pinfo,\n\t\t\t\tbuffer.tree, di, drep);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tproto_tree_add_expert_format( buffer.tree, pinfo, &ei_job_info_level, buffer.tvb, 0, -1, \"Unknown job info level %d\", level);\n\t\t\tbreak;\n\t\t}\n\n\t}\n\n\toffset = dissect_doserror(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_rc, NULL);\n\n\treturn offset;\n}\n\n/*\n * SetJob\n */\n\nstatic const value_string setjob_commands[] = {\n\t{ JOB_CONTROL_PAUSE, \"Pause\" },\n\t{ JOB_CONTROL_RESUME, \"Resume\" },\n\t{ JOB_CONTROL_CANCEL, \"Cancel\" },\n\t{ JOB_CONTROL_RESTART, \"Restart\" },\n\t{ JOB_CONTROL_DELETE, \"Delete\" },\n\t{ 0, NULL }\n};\n\nstatic int hf_setjob_cmd;\n\nstatic int\nSpoolssSetJob_q(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\t   proto_tree *tree, dcerpc_info *di, uint8_t *drep)\n{\n\tuint32_t jobid, cmd;\n\n\t/* Parse packet */\n\n\toffset = dissect_nt_policy_hnd(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_hnd, NULL, NULL,\n\t\tPIDL_POLHND_USE);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_job_id, &jobid);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_level, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_setjob_cmd, &cmd);\n\n\tcol_append_fstr(\n\t\t\tpinfo->cinfo, COL_INFO, \", %s jobid %d\",\n\t\t\tval_to_str_wmem(pinfo->pool, cmd, setjob_commands, \"Unknown (%d)\"),\n\t\t\tjobid);\n\n\treturn offset;\n}\n\nstatic int\nSpoolssSetJob_r(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\t   proto_tree *tree, dcerpc_info *di, uint8_t *drep)\n{\n\t/* Parse packet */\n\n\toffset = dissect_doserror(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_rc, NULL);\n\n\treturn offset;\n}\n\n/*\n * GetJob\n */\n\nstatic int\nSpoolssGetJob_q(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\t   proto_tree *tree, dcerpc_info *di, uint8_t *drep)\n{\n\tdcerpc_call_value *dcv = (dcerpc_call_value *)di->call_data;\n\tuint32_t level, jobid;\n\n\t/* Parse packet */\n\n\toffset = dissect_nt_policy_hnd(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_hnd, NULL, NULL,\n\t\tPIDL_POLHND_USE);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_job_id, &jobid);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_level, &level);\n\n\t/* GetJob() stores the level in se_data */\n\tif(!pinfo->fd->visited){\n\t\t\tdcv->se_data = GUINT_TO_POINTER((int)level);\n\t}\n\n\tcol_append_fstr(pinfo->cinfo, COL_INFO, \", level %d, jobid %d\",\n\t\t\t\tlevel, jobid);\n\n\toffset = dissect_spoolss_buffer(tvb, offset, pinfo, tree, di, drep, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_offered, NULL);\n\n\treturn offset;\n}\n\nstatic int\nSpoolssGetJob_r(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\tproto_tree *tree, dcerpc_info *di, uint8_t *drep)\n{\n\tdcerpc_call_value *dcv = (dcerpc_call_value *)di->call_data;\n\tint32_t level = GPOINTER_TO_UINT(dcv->se_data);\n\tBUFFER buffer;\n\n\t/* Parse packet */\n\n\toffset = dissect_spoolss_buffer(tvb, offset, pinfo, tree, di, drep,\n\t\t\t\t\t&buffer);\n\n\tif (buffer.tvb) {\n\t\tint buffer_offset = 0;\n\n\t\tswitch(level) {\n\t\tcase 1:\n\t\t\t/*buffer_offset = */dissect_spoolss_JOB_INFO_1(\n\t\t\t\tbuffer.tvb, buffer_offset, pinfo,\n\t\t\t\tbuffer.tree, di, drep);\n\t\t\tbreak;\n\t\tcase 2:\n\t\tdefault:\n\t\t\tproto_tree_add_expert_format( buffer.tree, pinfo, &ei_job_info_level, buffer.tvb, buffer_offset, -1, \"Unknown job info level %d\", level);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_needed, NULL);\n\n\toffset = dissect_doserror(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_rc, NULL);\n\n\treturn offset;\n}\n\n/*\n * StartPagePrinter\n */\n\nstatic int\nSpoolssStartPagePrinter_q(tvbuff_t *tvb, int offset,\n\t\t\t\t     packet_info *pinfo, proto_tree *tree,\n\t\t\t\t     dcerpc_info *di, uint8_t *drep)\n{\n\te_ctx_hnd policy_hnd;\n\tchar *pol_name;\n\n\t/* Parse packet */\n\n\toffset = dissect_nt_policy_hnd(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_hnd, &policy_hnd, NULL,\n\t\tPIDL_POLHND_USE);\n\n\tdcerpc_fetch_polhnd_data(&policy_hnd, &pol_name, NULL, NULL, NULL,\n\t\t\t     pinfo->num);\n\n\tif (pol_name)\n\t\tcol_append_fstr(pinfo->cinfo, COL_INFO, \", %s\",\n\t\t\t\tpol_name);\n\n\treturn offset;\n}\n\nstatic int\nSpoolssStartPagePrinter_r(tvbuff_t *tvb, int offset,\n\t\t\t\t     packet_info *pinfo, proto_tree *tree,\n\t\t\t\t     dcerpc_info *di, uint8_t *drep)\n{\n\t/* Parse packet */\n\n\toffset = dissect_doserror(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_rc, NULL);\n\n\treturn offset;\n}\n\n/*\n * EndPagePrinter\n */\n\nstatic int\nSpoolssEndPagePrinter_q(tvbuff_t *tvb, int offset,\n\t\t\t\t   packet_info *pinfo, proto_tree *tree,\n\t\t\t\t   dcerpc_info *di, uint8_t *drep)\n{\n\te_ctx_hnd policy_hnd;\n\tchar *pol_name;\n\n\t/* Parse packet */\n\n\toffset = dissect_nt_policy_hnd(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_hnd, &policy_hnd, NULL,\n\t\tPIDL_POLHND_USE);\n\n\tdcerpc_fetch_polhnd_data(&policy_hnd, &pol_name, NULL, NULL, NULL,\n\t\t\t     pinfo->num);\n\n\tif (pol_name)\n\t\tcol_append_fstr(pinfo->cinfo, COL_INFO, \", %s\",\n\t\t\t\tpol_name);\n\n\treturn offset;\n}\n\nstatic int\nSpoolssEndPagePrinter_r(tvbuff_t *tvb, int offset,\n\t\t\t\t   packet_info *pinfo, proto_tree *tree,\n\t\t\t\t   dcerpc_info *di, uint8_t *drep)\n{\n\t/* Parse packet */\n\n\toffset = dissect_doserror(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_rc, NULL);\n\n\treturn offset;\n}\n\n/*\n * DOC_INFO_1\n */\n\nstatic int ett_DOC_INFO_1;\n\nstatic int\ndissect_spoolss_doc_info_1(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\t   proto_tree *tree, dcerpc_info *di, uint8_t *drep)\n{\n\tproto_tree *subtree;\n\n\tsubtree = proto_tree_add_subtree(\n\t\ttree, tvb, offset, 0, ett_DOC_INFO_1, NULL, \"Document info level 1\");\n\n\toffset = dissect_ndr_str_pointer_item(\n\t\ttvb, offset, pinfo, subtree, di, drep, NDR_POINTER_UNIQUE,\n\t\t\"Document name\", hf_documentname, 0);\n\n\toffset = dissect_ndr_str_pointer_item(\n\t\ttvb, offset, pinfo, subtree, di, drep, NDR_POINTER_UNIQUE,\n\t\t\"Output file\", hf_outputfile, 0);\n\n\toffset = dissect_ndr_str_pointer_item(\n\t\ttvb, offset, pinfo, subtree, di, drep, NDR_POINTER_UNIQUE,\n\t\t\"Data type\", hf_datatype, 0);\n\n\treturn offset;\n}\n\nstatic int\ndissect_spoolss_doc_info_data(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\t      proto_tree *tree, dcerpc_info *di, uint8_t *drep)\n{\n\tif (di->conformant_run)\n\t\treturn offset;\n\n\treturn dissect_spoolss_doc_info_1(tvb, offset, pinfo, tree, di, drep);\n}\n\n/*\n * DOC_INFO\n */\n\nstatic int ett_DOC_INFO;\n\nstatic int\ndissect_spoolss_doc_info(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\t proto_tree *tree, dcerpc_info *di, uint8_t *drep)\n{\n\tproto_tree *subtree;\n\tuint32_t level;\n\n\tsubtree = proto_tree_add_subtree(\n\t\ttree, tvb, offset, 0, ett_DOC_INFO, NULL, \"Document info\");\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_level, &level);\n\n\toffset = dissect_ndr_pointer(\n\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\tdissect_spoolss_doc_info_data,\n\t\tNDR_POINTER_UNIQUE, \"Document info\", -1);\n\n\treturn offset;\n}\n\n/*\n * DOC_INFO_CTR\n */\n\nstatic int ett_DOC_INFO_CTR;\n\nint\ndissect_spoolss_doc_info_ctr(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\t     proto_tree *tree, dcerpc_info *di, uint8_t *drep)\n{\n\tproto_tree *subtree;\n\n\tsubtree = proto_tree_add_subtree(\n\t\ttree, tvb, offset, 0, ett_DOC_INFO_CTR, NULL, \"Document info container\");\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_level, NULL);\n\n\toffset = dissect_spoolss_doc_info(\n\t\ttvb, offset, pinfo, subtree, di, drep);\n\n\treturn offset;\n}\n\n/*\n * StartDocPrinter\n */\n\nstatic int\nSpoolssStartDocPrinter_q(tvbuff_t *tvb, int offset,\n\t\t\t\t    packet_info *pinfo, proto_tree *tree,\n\t\t\t\t    dcerpc_info *di, uint8_t *drep)\n{\n\te_ctx_hnd policy_hnd;\n\tchar *pol_name;\n\n\t/* Parse packet */\n\n\toffset = dissect_nt_policy_hnd(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_hnd, &policy_hnd, NULL,\n\t\tPIDL_POLHND_USE);\n\n\tdcerpc_fetch_polhnd_data(&policy_hnd, &pol_name, NULL, NULL, NULL,\n\t\t\t     pinfo->num);\n\n\tif (pol_name)\n\t\tcol_append_fstr(pinfo->cinfo, COL_INFO, \", %s\",\n\t\t\t\tpol_name);\n\n\toffset = dissect_spoolss_doc_info_ctr(tvb, offset, pinfo, tree, di, drep);\n\n\treturn offset;\n}\n\nstatic int\nSpoolssStartDocPrinter_r(tvbuff_t *tvb, int offset,\n\t\t\t\t    packet_info *pinfo, proto_tree *tree,\n\t\t\t\t    dcerpc_info *di, uint8_t *drep)\n{\n\t/* Parse packet */\n\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, tree, di, drep,\n\t\t\t\t    hf_job_id, NULL);\n\n\toffset = dissect_doserror(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_rc, NULL);\n\n\treturn offset;\n}\n\n/*\n * EndDocPrinter\n */\n\nstatic int\nSpoolssEndDocPrinter_q(tvbuff_t *tvb, int offset,\n\t\t\t\t  packet_info *pinfo, proto_tree *tree,\n\t\t\t\t  dcerpc_info *di, uint8_t *drep)\n{\n\te_ctx_hnd policy_hnd;\n\tchar *pol_name;\n\n\t/* Parse packet */\n\n\toffset = dissect_nt_policy_hnd(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_hnd, &policy_hnd, NULL,\n\t\tPIDL_POLHND_USE);\n\n\tdcerpc_fetch_polhnd_data(&policy_hnd, &pol_name, NULL, NULL, NULL,\n\t\t\t     pinfo->num);\n\n\tif (pol_name)\n\t\tcol_append_fstr(pinfo->cinfo, COL_INFO, \", %s\",\n\t\t\t\tpol_name);\n\n\n\treturn offset;\n}\n\nstatic int\nSpoolssEndDocPrinter_r(tvbuff_t *tvb, int offset,\n\t\t\t\t  packet_info *pinfo, proto_tree *tree,\n\t\t\t\t  dcerpc_info *di, uint8_t *drep)\n{\n\t/* Parse packet */\n\n\toffset = dissect_doserror(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_rc, NULL);\n\n\treturn offset;\n}\n\n/*\n * WritePrinter\n */\n\nstatic int ett_writeprinter_buffer;\n\nstatic int hf_writeprinter_numwritten;\n\nstatic int\nSpoolssWritePrinter_q(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\t\t proto_tree *tree, dcerpc_info *di, uint8_t *drep)\n{\n\te_ctx_hnd policy_hnd;\n\tchar *pol_name;\n\tuint32_t size;\n\tproto_item *item;\n\tproto_tree *subtree;\n\n\t/* Parse packet */\n\n\toffset = dissect_nt_policy_hnd(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_hnd, &policy_hnd, NULL,\n\t\tPIDL_POLHND_USE);\n\n\tdcerpc_fetch_polhnd_data(&policy_hnd, &pol_name, NULL, NULL, NULL,\n\t\t\t     pinfo->num);\n\n\tif (pol_name)\n\t\tcol_append_fstr(pinfo->cinfo, COL_INFO, \", %s\",\n\t\t\t\tpol_name);\n\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, tree, di, drep,\n\t\t\t\t    hf_buffer_size, &size);\n\n\tcol_append_fstr(pinfo->cinfo, COL_INFO, \", %d bytes\", size);\n\n\tsubtree = proto_tree_add_subtree(tree, tvb, offset, 0, ett_writeprinter_buffer, &item, \"Buffer\");\n\n\toffset = dissect_ndr_uint8s(tvb, offset, pinfo, subtree, di, drep,\n\t\t\t\t    hf_buffer_data, size, NULL);\n\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, subtree, di, drep,\n\t\t\t\t    hf_buffer_size, NULL);\n\n\tproto_item_set_len(item, size + 4);\n\n\treturn offset;\n}\n\nstatic int\nSpoolssWritePrinter_r(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\t\t proto_tree *tree, dcerpc_info *di, uint8_t *drep)\n{\n\tuint32_t size;\n\n\t/* Parse packet */\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_writeprinter_numwritten,\n\t\t&size);\n\n\tcol_append_fstr(\n\t\t\tpinfo->cinfo, COL_INFO, \", %d bytes written\", size);\n\n\toffset = dissect_doserror(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_rc, NULL);\n\n\treturn offset;\n}\n\n/*\n * DeletePrinterData\n */\n\nstatic int\nSpoolssDeletePrinterData_q(tvbuff_t *tvb, int offset,\n\t\t\t\t      packet_info *pinfo, proto_tree *tree,\n\t\t\t\t      dcerpc_info *di, uint8_t *drep)\n{\n\tchar *value_name;\n\tproto_item *hidden_item;\n\n\thidden_item = proto_tree_add_uint(\n\t\ttree, hf_printerdata, tvb, offset, 0, 1);\n\tproto_item_set_hidden(hidden_item);\n\n\t/* Parse packet */\n\n\toffset = dissect_nt_policy_hnd(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_hnd, NULL, NULL,\n\t\tPIDL_POLHND_USE);\n\n\toffset = dissect_ndr_cvstring(\n\t\ttvb, offset, pinfo, tree, di, drep, sizeof(uint16_t),\n\t\thf_printerdata_value, true, &value_name);\n\n\tcol_append_fstr(pinfo->cinfo, COL_INFO, \", %s\", value_name);\n\n\treturn offset;\n}\n\nstatic int\nSpoolssDeletePrinterData_r(tvbuff_t *tvb, int offset,\n\t\t\t\t      packet_info *pinfo, proto_tree *tree,\n\t\t\t\t      dcerpc_info *di, uint8_t *drep)\n{\n\tproto_item *hidden_item;\n\n\thidden_item = proto_tree_add_uint(\n\t\ttree, hf_printerdata, tvb, offset, 0, 1);\n\tproto_item_set_hidden(hidden_item);\n\n\t/* Parse packet */\n\n\toffset = dissect_doserror(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_rc, NULL);\n\n\treturn offset;\n}\n\n/*\n * DRIVER_INFO_1\n */\n\nstatic int ett_DRIVER_INFO_1;\n\nstatic int\ndissect_DRIVER_INFO_1(tvbuff_t *tvb, int offset,\n\t\t\t\t packet_info *pinfo, proto_tree *tree,\n\t\t\t\t dcerpc_info *di, uint8_t *drep)\n{\n\tproto_tree *subtree;\n\tint struct_start = offset;\n\n\tsubtree = proto_tree_add_subtree(\n\t\ttree, tvb, offset, 0, ett_DRIVER_INFO_1, NULL, \"Driver info level 1\");\n\n\toffset = dissect_spoolss_relstr(\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_drivername,\n\t\tstruct_start, NULL);\n\n\treturn offset;\n}\n\n/*\n * DRIVER_INFO_2\n */\n\nstatic const value_string driverinfo_cversion_vals[] =\n{\n\t{ 0, \"Windows 95/98/Me\" },\n\t{ 2, \"Windows NT 4.0\" },\n\t{ 3, \"Windows 2000/XP\" },\n\t{ 0, NULL }\n};\n\nstatic int ett_DRIVER_INFO_2;\n\nstatic int\ndissect_DRIVER_INFO_2(tvbuff_t *tvb, int offset,\n\t packet_info *pinfo, proto_tree *tree,\n\t dcerpc_info *di, uint8_t *drep)\n{\n\tproto_tree *subtree;\n\tint struct_start = offset;\n\n\tsubtree = proto_tree_add_subtree(\n\t\t\ttree, tvb, offset, 0, ett_DRIVER_INFO_2, NULL, \"Driver info level 2\");\n\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, subtree, di, drep,\n\t\t\thf_driverinfo_cversion, NULL);\n\n\toffset = dissect_spoolss_relstr(\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_drivername,\n\t\t\tstruct_start, NULL);\n\n\toffset = dissect_spoolss_relstr(\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_environment,\n\t\t\tstruct_start, NULL);\n\n\toffset = dissect_spoolss_relstr(\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_driverpath,\n\t\t\tstruct_start, NULL);\n\n\toffset = dissect_spoolss_relstr(\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_datafile,\n\t\t\tstruct_start, NULL);\n\n\toffset = dissect_spoolss_relstr(\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_configfile,\n\t\t\tstruct_start, NULL);\n\n\treturn offset;\n}\n\n/*\n * DRIVER_INFO_3\n */\n\nstatic int ett_DRIVER_INFO_3;\n\nstatic int\ndissect_DRIVER_INFO_3(tvbuff_t *tvb, int offset,\n\t\t\t\t packet_info *pinfo, proto_tree *tree,\n\t\t\t\t dcerpc_info *di, uint8_t *drep)\n{\n\tproto_tree *subtree;\n\tint struct_start = offset;\n\n\tsubtree = proto_tree_add_subtree(\n\t\ttree, tvb, offset, 0, ett_DRIVER_INFO_3, NULL, \"Driver info level 3\");\n\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, subtree, di, drep,\n\t\t\t\t    hf_driverinfo_cversion, NULL);\n\n\toffset = dissect_spoolss_relstr(\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_drivername,\n\t\tstruct_start, NULL);\n\n\toffset = dissect_spoolss_relstr(\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_environment,\n\t\tstruct_start, NULL);\n\n\toffset = dissect_spoolss_relstr(\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_driverpath,\n\t\tstruct_start, NULL);\n\n\toffset = dissect_spoolss_relstr(\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_datafile,\n\t\tstruct_start, NULL);\n\n\toffset = dissect_spoolss_relstr(\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_configfile,\n\t\tstruct_start, NULL);\n\n\toffset = dissect_spoolss_relstr(\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_helpfile,\n\t\tstruct_start, NULL);\n\n\toffset = dissect_spoolss_relstrarray(\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_dependentfiles,\n\t\tstruct_start, NULL);\n\n\toffset = dissect_spoolss_relstr(\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_monitorname,\n\t\tstruct_start, NULL);\n\n\toffset = dissect_spoolss_relstr(\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_defaultdatatype,\n\t\tstruct_start, NULL);\n\n\treturn offset;\n}\n\n\n/*\n\tDRIVER_INFO_6\n*/\n\nstatic int ett_DRIVER_INFO_6;\n\nstatic int\ndissect_DRIVER_INFO_6(tvbuff_t *tvb, int offset,\n\t\t\t\t packet_info *pinfo, proto_tree *tree,\n\t\t\t\t dcerpc_info *di, uint8_t *drep)\n{\n\tproto_tree *subtree;\n\tint struct_start = offset;\n\n\tsubtree = proto_tree_add_subtree(\n\t\t\ttree, tvb, offset, 0, ett_DRIVER_INFO_6, NULL, \"Driver info level 6\");\n\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, subtree, di, drep,\n\t\t\thf_driverinfo_cversion, NULL);\n\n\toffset = dissect_spoolss_relstr(\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_drivername,\n\t\t\tstruct_start, NULL);\n\n\toffset = dissect_spoolss_relstr(\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_environment,\n\t\t\tstruct_start, NULL);\n\n\toffset = dissect_spoolss_relstr(\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_driverpath,\n\t\t\tstruct_start, NULL);\n\n\toffset = dissect_spoolss_relstr(\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_datafile,\n\t\t\tstruct_start, NULL);\n\n\toffset = dissect_spoolss_relstr(\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_configfile,\n\t\t\tstruct_start, NULL);\n\n\toffset = dissect_spoolss_relstr(\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_helpfile,\n\t\t\tstruct_start, NULL);\n\n\toffset = dissect_spoolss_relstr(\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_monitorname,\n\t\t\tstruct_start, NULL);\n\n\toffset = dissect_spoolss_relstr(\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_defaultdatatype,\n\t\t\tstruct_start, NULL);\n\n\toffset = dissect_spoolss_relstrarray(\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_dependentfiles,\n\t\t\tstruct_start, NULL);\n\n\toffset = dissect_spoolss_relstrarray(\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_previousdrivernames,\n\t\t\tstruct_start, NULL);\n\n\toffset = dissect_ndr_nt_NTTIME (\n\t\t\ttvb, offset, pinfo, subtree, di, drep,hf_driverdate);\n\n\toffset = dissect_ndr_uint32(\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_padding,\n\t\t\tNULL);\n\n\toffset = dissect_ndr_uint32(\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_driver_version_low,\n\t\t\tNULL);\n\n\toffset = dissect_ndr_uint32(\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_driver_version_high,\n\t\t\tNULL);\n\n\toffset = dissect_spoolss_relstr(\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_mfgname,\n\t\t\tstruct_start, NULL);\n\n\toffset = dissect_spoolss_relstr(\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_oemurl,\n\t\t\tstruct_start, NULL);\n\n\toffset = dissect_spoolss_relstr(\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_hardwareid,\n\t\t\tstruct_start, NULL);\n\n\toffset = dissect_spoolss_relstr(\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_provider,\n\t\t\tstruct_start, NULL);\n\n\treturn offset;\n}\n\n\n/*\n\tDRIVER_INFO_8\n*/\n\nstatic int ett_DRIVER_INFO_8;\n\nstatic int\ndissect_DRIVER_INFO_8(tvbuff_t *tvb, int offset,\n\t\t\t\t packet_info *pinfo, proto_tree *tree,\n\t\t\t\t dcerpc_info *di, uint8_t *drep)\n{\n\tproto_tree *subtree;\n\tint struct_start = offset;\n\n\tsubtree = proto_tree_add_subtree(\n\t\t\ttree, tvb, offset, 0, ett_DRIVER_INFO_8, NULL, \"Driver info level 8\");\n\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, subtree, di, drep,\n\t\t\thf_driverinfo_cversion, NULL);\n\n\toffset = dissect_spoolss_relstr(\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_drivername,\n\t\t\tstruct_start, NULL);\n\n\toffset = dissect_spoolss_relstr(\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_environment,\n\t\t\tstruct_start, NULL);\n\n\toffset = dissect_spoolss_relstr(\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_driverpath,\n\t\t\tstruct_start, NULL);\n\n\toffset = dissect_spoolss_relstr(\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_datafile,\n\t\t\tstruct_start, NULL);\n\n\toffset = dissect_spoolss_relstr(\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_configfile,\n\t\t\tstruct_start, NULL);\n\n\toffset = dissect_spoolss_relstr(\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_helpfile,\n\t\t\tstruct_start, NULL);\n\n\toffset = dissect_spoolss_relstrarray(\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_dependentfiles,\n\t\t\tstruct_start, NULL);\n\n\toffset = dissect_spoolss_relstr(\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_monitorname,\n\t\t\tstruct_start, NULL);\n\n\toffset = dissect_spoolss_relstr(\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_defaultdatatype,\n\t\t\tstruct_start, NULL);\n\n\toffset = dissect_spoolss_relstrarray(\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_previousdrivernames,\n\t\t\tstruct_start, NULL);\n\n\toffset = dissect_ndr_nt_NTTIME (\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_driverdate);\n\n\toffset = dissect_ndr_uint32(\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_padding,\n\t\t\tNULL);\n\n\toffset = dissect_ndr_uint32(\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_driver_version_low,\n\t\t\tNULL);\n\n\toffset = dissect_ndr_uint32(\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_driver_version_high,\n\t\t\tNULL);\n\n\toffset = dissect_spoolss_relstr(\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_mfgname,\n\t\t\tstruct_start, NULL);\n\n\toffset = dissect_spoolss_relstr(\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_oemurl,\n\t\t\tstruct_start, NULL);\n\n\toffset = dissect_spoolss_relstr(\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_hardwareid,\n\t\t\tstruct_start, NULL);\n\n\toffset = dissect_spoolss_relstr(\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_provider,\n\t\t\tstruct_start, NULL);\n\n\toffset = dissect_spoolss_relstr(\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_printprocessor,\n\t\t\tstruct_start, NULL);\n\n\toffset = dissect_spoolss_relstr(\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_vendor_setup,\n\t\t\tstruct_start, NULL);\n\n\toffset = dissect_spoolss_relstrarray(\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_color_profiles,\n\t\t\tstruct_start, NULL);\n\n\toffset = dissect_spoolss_relstr(\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_inf_path,\n\t\t\tstruct_start, NULL);\n\n\toffset = dissect_printer_driver_attributes(\n\t\t\ttvb, offset, pinfo, subtree, di, drep);\n\n\toffset = dissect_spoolss_relstrarray(\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_core_driver_dependencies,\n\t\t\tstruct_start, NULL);\n\n\toffset = dissect_ndr_nt_NTTIME (\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_min_inbox_driverdate);\n\n\toffset = dissect_ndr_uint32(\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_min_inbox_driver_version_low,\n\t\t\tNULL);\n\n\toffset = dissect_ndr_uint32(\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_min_inbox_driver_version_high,\n\t\t\tNULL);\n\n\treturn offset;\n}\n\n\nstatic int ett_DRIVER_INFO_101;\n\nstatic int\ndissect_DRIVER_INFO_101(tvbuff_t *tvb, int offset,\n\t\t\t\t packet_info *pinfo, proto_tree *tree,\n\t\t\t\t dcerpc_info *di, uint8_t *drep)\n{\n\tproto_tree *subtree;\n\tint struct_start = offset;\n\n\tsubtree = proto_tree_add_subtree(\n\t\t\ttree, tvb, offset, 0, ett_DRIVER_INFO_101, NULL, \"Driver info level 101\");\n\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, subtree, di, drep,\n\t\t\thf_driverinfo_cversion, NULL);\n\n\toffset = dissect_spoolss_relstr(\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_drivername,\n\t\t\tstruct_start, NULL);\n\n\toffset = dissect_spoolss_relstr(\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_environment,\n\t\t\tstruct_start, NULL);\n\n\tproto_tree_add_expert(subtree, pinfo, &ei_unknown_data, tvb, offset, 0);\n\n\treturn offset;\n}\n\n/*\n\tCORE_PRINTER_DRIVER\n*/\n\nstatic int ett_CORE_PRINTER_DRIVER;\n\nstatic int\ndissect_CORE_PRINTER_DRIVER(tvbuff_t *tvb, int offset,\n\t\t\t\t packet_info *pinfo, proto_tree *tree,\n\t\t\t\t dcerpc_info *di, uint8_t *drep)\n{\n\tproto_tree *subtree;\n\n\tALIGN_TO_5_BYTES;\n\n\tsubtree = proto_tree_add_subtree(\n\t\ttree, tvb, offset, 0, ett_CORE_PRINTER_DRIVER, NULL, \"Core Printer Driver\");\n\n\toffset = dissect_ndr_uuid_t(tvb, offset, pinfo, subtree, di, drep,\n\t\thf_core_driver_guid, NULL);\n\n\toffset = dissect_ndr_nt_NTTIME(tvb, offset, pinfo, subtree, di, drep,\n\t\thf_driverdate);\n\n\toffset = dissect_ndr_uint64(tvb, offset, pinfo, subtree, di, drep,\n\t\thf_driver_version, NULL);\n\n\t/* The package id is stored in a 260-wchar buffer */\n\n\tdissect_spoolss_uint16uni(tvb, offset, pinfo, subtree, drep, NULL,\n\t\thf_package_id);\n\n\toffset += 520;\n\n\tif (di->call_data->flags & DCERPC_IS_NDR64) {\n\t\tALIGN_TO_5_BYTES;\n\t}\n\n\treturn offset;\n}\n\n\n/*\n * EnumPrinterDrivers\n */\n\nstatic int\nSpoolssEnumPrinterDrivers_q(tvbuff_t *tvb, int offset,\n\t\t\t\t       packet_info *pinfo, proto_tree *tree,\n\t\t\t\t       dcerpc_info *di, uint8_t *drep)\n{\n\tdcerpc_call_value *dcv = (dcerpc_call_value *)di->call_data;\n\tuint32_t level;\n\n\t/* Parse packet */\n\n\toffset = dissect_ndr_str_pointer_item(\n\t\ttvb, offset, pinfo, tree, di, drep, NDR_POINTER_UNIQUE,\n\t\t\"Name\", hf_servername, 0);\n\n\toffset = dissect_ndr_str_pointer_item(\n\t\ttvb, offset, pinfo, tree, di, drep, NDR_POINTER_UNIQUE,\n\t\t\"Environment\", hf_environment, 0);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_level, &level);\n\n\t/* EnumPrinterDrivers() stores the level in se_data */\n\tif(!pinfo->fd->visited){\n\t\t\tdcv->se_data = GUINT_TO_POINTER((int)level);\n\t}\n\n\tcol_append_fstr(pinfo->cinfo, COL_INFO, \", level %d\", level);\n\n\toffset = dissect_spoolss_buffer(tvb, offset, pinfo, tree, di, drep, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_offered, NULL);\n\n\treturn offset;\n}\n\nstatic int\nSpoolssEnumPrinterDrivers_r(tvbuff_t *tvb, int offset,\n\t\t\t\t       packet_info *pinfo, proto_tree *tree,\n\t\t\t\t       dcerpc_info *di, uint8_t *drep)\n{\n\tdcerpc_call_value *dcv = (dcerpc_call_value *)di->call_data;\n\tuint32_t level = GPOINTER_TO_UINT(dcv->se_data), num_drivers, i;\n\tint buffer_offset;\n\tBUFFER buffer;\n\n\t/* Parse packet */\n\n\toffset = dissect_spoolss_buffer(tvb, offset, pinfo, tree, di, drep,\n\t\t\t\t\t&buffer);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_needed, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_returned,\n\t\t&num_drivers);\n\n\tbuffer_offset = 0;\n\n\tfor (i = 0; i < num_drivers; i++) {\n\t\tswitch(level) {\n\t\tcase 1:\n\t\t\tbuffer_offset = dissect_DRIVER_INFO_1(\n\t\t\t\tbuffer.tvb, buffer_offset, pinfo,\n\t\t\t\tbuffer.tree, di, drep);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tbuffer_offset = dissect_DRIVER_INFO_2(\n\t\t\t\tbuffer.tvb, buffer_offset, pinfo,\n\t\t\t\tbuffer.tree, di, drep);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tbuffer_offset = dissect_DRIVER_INFO_3(\n\t\t\t\tbuffer.tvb, buffer_offset, pinfo,\n\t\t\t\tbuffer.tree, di, drep);\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tbuffer_offset = dissect_DRIVER_INFO_6(\n\t\t\t\tbuffer.tvb, buffer_offset, pinfo,\n\t\t\t\tbuffer.tree, di, drep);\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tbuffer_offset = dissect_DRIVER_INFO_8(\n\t\t\t\tbuffer.tvb, buffer_offset, pinfo,\n\t\t\t\tbuffer.tree, di, drep);\n\t\t\tbreak;\n\t\tcase 101:\n\t\t\t/*buffer_offset =*/ dissect_DRIVER_INFO_101(\n\t\t\t\tbuffer.tvb, buffer_offset, pinfo,\n\t\t\t\tbuffer.tree, di, drep);\n\t\t\t/*break;*/\n\t\t\tgoto done; /*Not entirely implemented*/\n\t\tdefault:\n\t\t\tproto_tree_add_expert_format( buffer.tree, pinfo, &ei_driver_info_level, buffer.tvb, buffer_offset, -1, \"Unknown driver info level %d\", level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\ndone:\n\toffset = dissect_doserror(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_rc, NULL);\n\n\treturn offset;\n}\n\n/*\n * GetPrinterDriver2\n */\n\nstatic int\nSpoolssGetPrinterDriver2_q(tvbuff_t *tvb, int offset,\n\t\t\t\t      packet_info *pinfo, proto_tree *tree,\n\t\t\t\t      dcerpc_info *di, uint8_t *drep)\n{\n\tdcerpc_call_value *dcv = (dcerpc_call_value *)di->call_data;\n\te_ctx_hnd policy_hnd;\n\tchar *pol_name;\n\tuint32_t level;\n\n\t/* Parse packet */\n\n\toffset = dissect_nt_policy_hnd(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_hnd, &policy_hnd, NULL,\n\t\tPIDL_POLHND_USE);\n\n\tdcerpc_fetch_polhnd_data(&policy_hnd, &pol_name, NULL, NULL, NULL,\n\t\t\t     pinfo->num);\n\n\tcol_append_fstr(pinfo->cinfo, COL_INFO, \", %s\",\n\t\t\t\tpol_name);\n\n\toffset = dissect_ndr_str_pointer_item(\n\t\ttvb, offset, pinfo, tree, di, drep, NDR_POINTER_UNIQUE,\n\t\t\"Environment\", hf_environment, 0);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_level, &level);\n\n\t/* GetPrinterDriver2() stores the level in se_data */\n\tif(!pinfo->fd->visited){\n\t\t\tdcv->se_data = GUINT_TO_POINTER((int)level);\n\t}\n\n\tcol_append_fstr(pinfo->cinfo, COL_INFO, \", level %d\", level);\n\n\toffset = dissect_spoolss_buffer(tvb, offset, pinfo, tree, di, drep, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_offered, NULL);\n\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, tree, di, drep,\n\t\t\t\t    hf_clientmajorversion, NULL);\n\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, tree, di, drep,\n\t\t\t\t    hf_clientminorversion, NULL);\n\n\treturn offset;\n}\n\nstatic int\nSpoolssGetPrinterDriver2_r(tvbuff_t *tvb, int offset,\n\t\t\t\t      packet_info *pinfo, proto_tree *tree,\n\t\t\t\t      dcerpc_info *di, uint8_t *drep)\n{\n\tdcerpc_call_value *dcv = (dcerpc_call_value *)di->call_data;\n\tuint32_t level = GPOINTER_TO_UINT(dcv->se_data);\n\tBUFFER buffer;\n\n\t/* Parse packet */\n\n\toffset = dissect_spoolss_buffer(tvb, offset, pinfo, tree, di, drep,\n\t\t\t\t\t&buffer);\n\n\tif (buffer.tvb) {\n\t\tswitch(level) {\n\t\tcase 1:\n\t\t\tdissect_DRIVER_INFO_1(\n\t\t\t\tbuffer.tvb, 0, pinfo, buffer.tree, di, drep);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tdissect_DRIVER_INFO_2(\n\t\t\t\tbuffer.tvb, 0, pinfo, buffer.tree, di, drep);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tdissect_DRIVER_INFO_3(\n\t\t\t\tbuffer.tvb, 0, pinfo, buffer.tree, di, drep);\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tdissect_DRIVER_INFO_6(\n\t\t\t\tbuffer.tvb, 0, pinfo, buffer.tree, di, drep);\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tdissect_DRIVER_INFO_8(\n\t\t\t\tbuffer.tvb, 0, pinfo, buffer.tree, di, drep);\n\t\t\tbreak;\n\t\tcase 101:\n\t\t\tdissect_DRIVER_INFO_101(\n\t\t\t\tbuffer.tvb, 0, pinfo, buffer.tree, di, drep);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tproto_tree_add_expert_format( buffer.tree, pinfo, &ei_driver_info_level, buffer.tvb, 0, -1, \"Unknown driver info level %d\", level);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_needed, NULL);\n\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, tree, di, drep,\n\t\t\t\t    hf_servermajorversion, NULL);\n\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, tree, di, drep,\n\t\t\t\t    hf_serverminorversion, NULL);\n\n\toffset = dissect_doserror(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_rc, NULL);\n\n\treturn offset;\n}\n\nstatic int\ndissect_notify_info_data_buffer(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\t\tproto_tree *tree, dcerpc_info *di, uint8_t *drep)\n{\n\tuint32_t len;\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep,\n\t\thf_notify_info_data_buffer_len, &len);\n\n\toffset = dissect_ndr_uint16s(\n\t\ttvb, offset, pinfo, tree, di, drep,\n\t\thf_notify_info_data_buffer_data, len);\n\n\treturn offset;\n}\n\nstatic void\ncb_notify_str_postprocess(packet_info *pinfo _U_,\n\t\t\t\t      proto_tree *tree,\n\t\t\t\t      proto_item *item, dcerpc_info *di _U_, tvbuff_t *tvb,\n\t\t\t\t      int start_offset, int end_offset,\n\t\t\t\t      void *callback_args)\n{\n\tint levels, hf_index = GPOINTER_TO_INT(callback_args);\n\tuint32_t len;\n\tchar *s;\n\tproto_item *hidden_item;\n\n\t/* Align start_offset on 4-byte boundary. */\n\n\tstart_offset = WS_ROUNDUP_4(start_offset);\n\n\t/* Get string length */\n\n\tlen = tvb_get_letohl(tvb, start_offset);\n\n\ts = tvb_get_string_enc(pinfo->pool,\n\t\ttvb, start_offset + 4, (end_offset - start_offset - 4), ENC_UTF_16|ENC_LITTLE_ENDIAN);\n\n\t/* Append string to upper-level proto_items */\n\n\tlevels = 2;\n\n\tif (levels > 0 && item && s && s[0]) {\n\t\tproto_item_append_text(item, \": %s\", s);\n\t\titem = item->parent;\n\t\tlevels--;\n\t\tif (levels > 0) {\n\t\t\tproto_item_append_text(item, \": %s\", s);\n\t\t\titem = item->parent;\n\t\t\tlevels--;\n\t\t\twhile (levels > 0) {\n\t\t\t\tproto_item_append_text(item, \" %s\", s);\n\t\t\t\titem = item->parent;\n\t\t\t\tlevels--;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Add hidden field so filter brings up any notify data */\n\n\tif (hf_index > 0) {\n\t\thidden_item = proto_tree_add_string(\n\t\t\ttree, hf_index, tvb, start_offset, len, s);\n\t\tproto_item_set_hidden(hidden_item);\n\t}\n}\n\n/* Return the hf_index for a printer notify field.  This is used to\n   add a hidden string to the display so that filtering will bring\n   up relevant notify data. */\n\nstatic int\nprinter_notify_hf_index(int field)\n{\n\tint result = -1;\n\n\tswitch(field) {\n\tcase PRINTER_NOTIFY_SERVER_NAME:\n\t\tresult = hf_servername;\n\t\tbreak;\n\tcase PRINTER_NOTIFY_PRINTER_NAME:\n\t\tresult = hf_printername;\n\t\tbreak;\n\tcase PRINTER_NOTIFY_SHARE_NAME:\n\t\tresult = hf_sharename;\n\t\tbreak;\n\tcase PRINTER_NOTIFY_PORT_NAME:\n\t\tresult = hf_portname;\n\t\tbreak;\n\tcase PRINTER_NOTIFY_DRIVER_NAME:\n\t\tresult = hf_drivername;\n\t\tbreak;\n\tcase PRINTER_NOTIFY_COMMENT:\n\t\tresult = hf_printercomment;\n\t\tbreak;\n\tcase PRINTER_NOTIFY_LOCATION:\n\t\tresult = hf_printerlocation;\n\t\tbreak;\n\tcase PRINTER_NOTIFY_SEPFILE:\n\t\tresult = hf_sepfile;\n\t\tbreak;\n\tcase PRINTER_NOTIFY_PRINT_PROCESSOR:\n\t\tresult = hf_printprocessor;\n\t\tbreak;\n\tcase PRINTER_NOTIFY_PARAMETERS:\n\t\tresult = hf_parameters;\n\t\tbreak;\n\tcase PRINTER_NOTIFY_DATATYPE:\n\t\tresult = hf_parameters;\n\t\tbreak;\n\t}\n\n\treturn result;\n}\n\nstatic int\njob_notify_hf_index(int field)\n{\n\tint result = -1;\n\n\tswitch(field) {\n\tcase JOB_NOTIFY_PRINTER_NAME:\n\t\tresult = hf_printername;\n\t\tbreak;\n\tcase JOB_NOTIFY_MACHINE_NAME:\n\t\tresult = hf_machinename;\n\t\tbreak;\n\tcase JOB_NOTIFY_PORT_NAME:\n\t\tresult = hf_portname;\n\t\tbreak;\n\tcase JOB_NOTIFY_USER_NAME:\n\t\tresult = hf_username;\n\t\tbreak;\n\tcase JOB_NOTIFY_NOTIFY_NAME:\n\t\tresult = hf_notifyname;\n\t\tbreak;\n\tcase JOB_NOTIFY_DATATYPE:\n\t\tresult = hf_datatype;\n\t\tbreak;\n\tcase JOB_NOTIFY_PRINT_PROCESSOR:\n\t\tresult = hf_printprocessor;\n\t\tbreak;\n\tcase JOB_NOTIFY_DRIVER_NAME:\n\t\tresult = hf_drivername;\n\t\tbreak;\n\tcase JOB_NOTIFY_DOCUMENT:\n\t\tresult = hf_documentname;\n\t\tbreak;\n\tcase JOB_NOTIFY_PRIORITY:\n\t\tresult = hf_job_priority;\n\t\tbreak;\n\tcase JOB_NOTIFY_POSITION:\n\t\tresult = hf_job_position;\n\t\tbreak;\n\tcase JOB_NOTIFY_TOTAL_PAGES:\n\t\tresult = hf_job_totalpages;\n\t\tbreak;\n\tcase JOB_NOTIFY_PAGES_PRINTED:\n\t\tresult = hf_job_pagesprinted;\n\t\tbreak;\n\tcase JOB_NOTIFY_TOTAL_BYTES:\n\t\tresult = hf_job_totalbytes;\n\t\tbreak;\n\tcase JOB_NOTIFY_BYTES_PRINTED:\n\t\tresult = hf_job_bytesprinted;\n\t\tbreak;\n\t}\n\n\treturn result;\n}\n\nstatic int\ndissect_NOTIFY_INFO_DATA_printer(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\t\t proto_tree *tree, proto_item *item,\n\t\t\t\t dcerpc_info *di, uint8_t *drep, uint16_t field)\n{\n\tuint32_t value1;\n\n\tswitch (field) {\n\n\t\t/* String notify data */\n\n\tcase PRINTER_NOTIFY_SERVER_NAME:\n\tcase PRINTER_NOTIFY_PRINTER_NAME:\n\tcase PRINTER_NOTIFY_SHARE_NAME:\n\tcase PRINTER_NOTIFY_DRIVER_NAME:\n\tcase PRINTER_NOTIFY_COMMENT:\n\tcase PRINTER_NOTIFY_LOCATION:\n\tcase PRINTER_NOTIFY_SEPFILE:\n\tcase PRINTER_NOTIFY_PRINT_PROCESSOR:\n\tcase PRINTER_NOTIFY_PARAMETERS:\n\tcase PRINTER_NOTIFY_DATATYPE:\n\tcase PRINTER_NOTIFY_PORT_NAME:\n\n\t\toffset = dissect_ndr_uint32(\n\t\t\ttvb, offset, pinfo, tree, di, drep,\n\t\t\thf_notify_info_data_bufsize, &value1);\n\n\t\toffset = dissect_ndr_pointer_cb(\n\t\t\ttvb, offset, pinfo, tree, di, drep,\n\t\t\tdissect_notify_info_data_buffer,\n\t\t\tNDR_POINTER_UNIQUE, \"String\",\n\t\t\thf_notify_info_data_buffer,\n\t\t\tcb_notify_str_postprocess,\n\t\t\tGINT_TO_POINTER(printer_notify_hf_index(field)));\n\n\t\tbreak;\n\n\tcase PRINTER_NOTIFY_ATTRIBUTES:\n\n\t\t/* Value 1 is the printer attributes */\n\n\t\toffset = dissect_printer_attributes(\n\t\t\ttvb, offset, pinfo, tree, di, drep);\n\n\t\toffset = dissect_ndr_uint32(\n\t\t\ttvb, offset, pinfo, NULL, di, drep,\n\t\t\thf_notify_info_data_value2, NULL);\n\n\t\tbreak;\n\n\tcase PRINTER_NOTIFY_STATUS: {\n\t\tuint32_t status;\n\n\t\t/* Value 1 is the printer status */\n\n \t\toffset = dissect_ndr_uint32(\n\t\t\ttvb, offset, pinfo, tree, di, drep,\n\t\t\thf_printer_status, &status);\n\n\t\toffset = dissect_ndr_uint32(\n\t\t\ttvb, offset, pinfo, NULL, di, drep,\n\t\t\thf_notify_info_data_value2, NULL);\n\n\t\tproto_item_append_text(\n\t\t\titem, \": %s\",\n\t\t\tval_to_str_ext_const(status, &printer_status_vals_ext, \"Unknown\"));\n\n\t\tbreak;\n\t}\n\n\t\t/* Unknown notify data */\n\n\tcase PRINTER_NOTIFY_SECURITY_DESCRIPTOR: /* Secdesc */\n\tcase PRINTER_NOTIFY_DEVMODE: /* Devicemode */\n\n\t\toffset = dissect_ndr_uint32(\n\t\t\ttvb, offset, pinfo, tree, di, drep,\n\t\t\thf_notify_info_data_bufsize, &value1);\n\n\t\toffset = dissect_ndr_pointer(\n\t\t\ttvb, offset, pinfo, tree, di, drep,\n\t\t\tdissect_notify_info_data_buffer,\n\t\t\tNDR_POINTER_UNIQUE, \"Buffer\",\n\t\t\thf_notify_info_data_buffer);\n\n\t\tbreak;\n\n\tdefault:\n\t\toffset = dissect_ndr_uint32(\n\t\t\ttvb, offset, pinfo, tree, di, drep,\n\t\t\thf_notify_info_data_value1, NULL);\n\n\t\toffset = dissect_ndr_uint32(\n\t\t\ttvb, offset, pinfo, tree, di, drep,\n\t\t\thf_notify_info_data_value2, NULL);\n\n\t\tbreak;\n\t}\n\treturn offset;\n}\n\nstatic void\nnotify_job_time_cb(packet_info *pinfo _U_, proto_tree *tree _U_,\n\t\t\t       proto_item *item, dcerpc_info *di, tvbuff_t *tvb _U_,\n\t\t\t       int start_offset _U_, int end_offset _U_,\n\t\t\t       void *callback_args _U_)\n{\n\tdcerpc_call_value *dcv = (dcerpc_call_value *)di->call_data;\n\tchar *str = (char *)dcv->private_data;\n\n\t/* Append job string stored in dcv->private_data by\n\t   dissect_SYSTEM_TIME_ptr() in the current item as well\n\t   as the parent. */\n\n\tproto_item_append_text(item, \": %s\", str);\n\n\tif (item)\n\t\tproto_item_append_text(item->parent, \": %s\", str);\n}\n\nstatic int\ndissect_NOTIFY_INFO_DATA_job(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\t     proto_tree *tree, proto_item *item, dcerpc_info *di, uint8_t *drep,\n\t\t\t     uint16_t field)\n{\n\tuint32_t value1;\n\tproto_item *hidden_item;\n\n\tswitch (field) {\n\n\t\t/* String notify data */\n\n\tcase JOB_NOTIFY_PRINTER_NAME:\n\tcase JOB_NOTIFY_MACHINE_NAME:\n\tcase JOB_NOTIFY_PORT_NAME:\n\tcase JOB_NOTIFY_USER_NAME:\n\tcase JOB_NOTIFY_NOTIFY_NAME:\n\tcase JOB_NOTIFY_DATATYPE:\n\tcase JOB_NOTIFY_PRINT_PROCESSOR:\n\tcase JOB_NOTIFY_PARAMETERS:\n\tcase JOB_NOTIFY_DRIVER_NAME:\n\tcase JOB_NOTIFY_STATUS_STRING:\n\tcase JOB_NOTIFY_DOCUMENT:\n\n\t\toffset = dissect_ndr_uint32(\n\t\t\ttvb, offset, pinfo, tree, di, drep,\n\t\t\thf_notify_info_data_bufsize, &value1);\n\n\t\toffset = dissect_ndr_pointer_cb(\n\t\t\ttvb, offset, pinfo, tree, di, drep,\n\t\t\tdissect_notify_info_data_buffer,\n\t\t\tNDR_POINTER_UNIQUE, \"String\",\n\t\t\thf_notify_info_data_buffer,\n\t\t\tcb_notify_str_postprocess,\n\t\t\tGINT_TO_POINTER(job_notify_hf_index(field)));\n\n\t\tbreak;\n\n\tcase JOB_NOTIFY_STATUS:\n\t\toffset = dissect_job_status(\n\t\t\ttvb, offset, pinfo, tree, di, drep);\n\n\t\toffset = dissect_ndr_uint32(\n\t\t\ttvb, offset, pinfo, NULL, di, drep,\n\t\t\thf_notify_info_data_value2, NULL);\n\n\t\tbreak;\n\n\tcase JOB_NOTIFY_SUBMITTED:\n\n\t\t/* SYSTEM_TIME */\n\n\t\toffset = dissect_ndr_uint32(\n\t\t\ttvb, offset, pinfo, tree, di, drep,\n\t\t\thf_notify_info_data_buffer_len, NULL);\n\n\t\toffset = dissect_ndr_pointer_cb(\n\t\t\ttvb, offset, pinfo, tree, di, drep,\n\t\t\tdissect_SYSTEM_TIME_ptr, NDR_POINTER_UNIQUE,\n\t\t\t\"Time submitted\", -1, notify_job_time_cb, NULL);\n\n\t\tbreak;\n\n\tcase JOB_NOTIFY_PRIORITY:\n\tcase JOB_NOTIFY_POSITION:\n\tcase JOB_NOTIFY_TOTAL_PAGES:\n\tcase JOB_NOTIFY_PAGES_PRINTED:\n\tcase JOB_NOTIFY_TOTAL_BYTES:\n\tcase JOB_NOTIFY_BYTES_PRINTED: {\n\t\tuint32_t value;\n\n\t\toffset = dissect_ndr_uint32(\n\t\t\ttvb, offset, pinfo, tree, di, drep,\n\t\t\thf_notify_info_data_value1, &value);\n\n\t\toffset = dissect_ndr_uint32(\n\t\t\ttvb, offset, pinfo, tree, di, drep,\n\t\t\thf_notify_info_data_value2, NULL);\n\n\t\tproto_item_append_text(item, \": %d\", value);\n\n\t\thidden_item = proto_tree_add_uint(\n\t\t\ttree, job_notify_hf_index(field), tvb,\n\t\t\toffset, 4, value);\n\t\tproto_item_set_hidden(hidden_item);\n\n\t\tbreak;\n\t}\n\n\t\t/* Unknown notify data */\n\n\tcase JOB_NOTIFY_DEVMODE:\n\n\t\toffset = dissect_ndr_uint32(\n\t\t\ttvb, offset, pinfo, tree, di, drep,\n\t\t\thf_notify_info_data_bufsize, &value1);\n\n\t\toffset = dissect_ndr_pointer(\n\t\t\ttvb, offset, pinfo, tree, di, drep,\n\t\t\tdissect_notify_info_data_buffer,\n\t\t\tNDR_POINTER_UNIQUE, \"Buffer\",\n\t\t\thf_notify_info_data_buffer);\n\n\t\tbreak;\n\n\tdefault:\n\t\toffset = dissect_ndr_uint32(\n\t\t\ttvb, offset, pinfo, tree, di, drep,\n\t\t\thf_notify_info_data_value1, NULL);\n\n\t\toffset = dissect_ndr_uint32(\n\t\t\ttvb, offset, pinfo, tree, di, drep,\n\t\t\thf_notify_info_data_value2, NULL);\n\t}\n\treturn offset;\n}\n\nstatic int ett_NOTIFY_INFO_DATA;\n\nstatic int\ndissect_NOTIFY_INFO_DATA(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\t proto_tree *tree, dcerpc_info *di, uint8_t *drep)\n{\n\tproto_item *item;\n\tproto_tree *subtree;\n\tuint32_t count;\n\tuint16_t type, field;\n\tconst char *field_string;\n\n\tsubtree = proto_tree_add_subtree(tree, tvb, offset, 0, ett_NOTIFY_INFO_DATA, &item, \"\");\n\n\toffset = dissect_ndr_uint16(\n\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\thf_notify_info_data_type, &type);\n\n\toffset = dissect_notify_field(\n\t\ttvb, offset, pinfo, subtree, di, drep, type, &field);\n\n\tswitch(type) {\n\tcase PRINTER_NOTIFY_TYPE:\n\t\tfield_string = val_to_str_ext(pinfo->pool,\n\t\t\tfield, &printer_notify_option_data_vals_ext,\n\t\t\t\"Unknown (%d)\");\n\t\tbreak;\n\tcase JOB_NOTIFY_TYPE:\n\t\tfield_string = val_to_str_ext(pinfo->pool,\n\t\t\tfield, &job_notify_option_data_vals_ext,\n\t\t\t\"Unknown (%d)\");\n\t\tbreak;\n\tdefault:\n\t\tfield_string = \"Unknown field\";\n\t\tbreak;\n\t}\n\n\tproto_item_append_text(\n\t\titem, \"%s, %s\",\n\t\tval_to_str_wmem(pinfo->pool, type, printer_notify_types, \"Unknown (%d)\"),\n\t\tfield_string);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\thf_notify_info_data_count, &count);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\thf_notify_info_data_id, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\thf_notify_info_data_count, NULL);\n\n\t/* The value here depends on (type, field) */\n\n\tswitch (type) {\n\tcase PRINTER_NOTIFY_TYPE:\n\t\toffset = dissect_NOTIFY_INFO_DATA_printer(\n\t\t\ttvb, offset, pinfo, subtree, item, di, drep, field);\n\t\tbreak;\n\tcase JOB_NOTIFY_TYPE:\n\t\toffset = dissect_NOTIFY_INFO_DATA_job(\n\t\t\ttvb, offset, pinfo, subtree, item, di, drep, field);\n\t\tbreak;\n\tdefault:\n\t\texpert_add_info(pinfo, item, &ei_notify_info_data_type);\n\t\tbreak;\n\t}\n\n\treturn offset;\n}\n\nint\ndissect_NOTIFY_INFO(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t    proto_tree *tree, dcerpc_info *di, uint8_t *drep)\n{\n\tuint32_t count;\n\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, tree, di, drep,\n\t\t\t\t    hf_notify_info_version, NULL);\n\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, tree, di, drep,\n\t\t\t\t    hf_notify_info_flags, NULL);\n\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, tree, di, drep,\n\t\t\t\t    hf_notify_info_count, &count);\n\n\tif (!di->conformant_run)\n\t\tcol_append_fstr(\n\t\t\tpinfo->cinfo, COL_INFO, \", %d %s\", count,\n\t\t\tnotify_plural(count));\n\n\toffset = dissect_ndr_ucarray(tvb, offset, pinfo, tree, di, drep,\n\t\t\t\t     dissect_NOTIFY_INFO_DATA);\n\n\treturn offset;\n}\n\n/*\n * RFNPCNEX\n */\n\nstatic int\nSpoolssRFNPCNEX_q(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\t     proto_tree *tree, dcerpc_info *di, uint8_t *drep)\n{\n\tuint32_t changeid;\n\n\t/* Parse packet */\n\n\toffset = dissect_nt_policy_hnd(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_hnd, NULL, NULL,\n\t\tPIDL_POLHND_USE);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_rrpcn_changelow, &changeid);\n\n\tcol_append_fstr(\n\t\t\tpinfo->cinfo, COL_INFO, \", changeid %d\", changeid);\n\n\toffset = dissect_ndr_pointer(\n\t\ttvb, offset, pinfo, tree, di, drep,\n\t\tdissect_NOTIFY_OPTIONS_ARRAY_CTR, NDR_POINTER_UNIQUE,\n\t\t\"Notify Options Array Container\", -1);\n\n\treturn offset;\n}\n\nstatic int\nSpoolssRFNPCNEX_r(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\t     proto_tree *tree, dcerpc_info *di, uint8_t *drep)\n{\n\t/* Parse packet */\n\n\toffset = dissect_ndr_pointer(\n\t\ttvb, offset, pinfo, tree, di, drep,\n\t\tdissect_NOTIFY_INFO, NDR_POINTER_UNIQUE,\n\t\t\"Notify Info\", -1);\n\n\toffset = dissect_doserror(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_rc, NULL);\n\n\treturn offset;\n}\n\n/*\n * RRPCN\n */\n\nstatic int\nSpoolssRRPCN_q(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\t  proto_tree *tree, dcerpc_info *di, uint8_t *drep)\n{\n\tuint32_t changeid;\n\n\t/* Parse packet */\n\n\toffset = dissect_nt_policy_hnd(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_hnd, NULL, NULL,\n\t\tPIDL_POLHND_USE);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_rrpcn_changelow, &changeid);\n\n\tcol_append_fstr(\n\t\t\tpinfo->cinfo, COL_INFO, \", changeid %d\", changeid);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_rrpcn_changehigh, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_rrpcn_unk0, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_rrpcn_unk1, NULL);\n\n\toffset = dissect_ndr_pointer(\n\t\ttvb, offset, pinfo, tree, di, drep,\n\t\tdissect_NOTIFY_INFO, NDR_POINTER_UNIQUE,\n\t\t\"Notify Info\", -1);\n\n\t/* Notify info */\n\n\treturn offset;\n}\n\nstatic int\nSpoolssRRPCN_r(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\t  proto_tree *tree, dcerpc_info *di, uint8_t *drep)\n{\n\t/* Parse packet */\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_rrpcn_unk0, NULL);\n\n\toffset = dissect_doserror(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_rc, NULL);\n\n\treturn offset;\n}\n\n/*\n * ReplyClosePrinter\n */\n\nstatic int\nSpoolssReplyClosePrinter_q(tvbuff_t *tvb, int offset,\n\t\t\t\t      packet_info *pinfo, proto_tree *tree,\n\t\t\t\t      dcerpc_info *di, uint8_t *drep)\n{\n\t/* Parse packet */\n\n\toffset = dissect_nt_policy_hnd(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_hnd, NULL, NULL,\n\t\tPIDL_POLHND_CLOSE);\n\n\treturn offset;\n}\n\nstatic int\nSpoolssReplyClosePrinter_r(tvbuff_t *tvb, int offset,\n\t\t\t\t      packet_info *pinfo, proto_tree *tree,\n\t\t\t\t      dcerpc_info *di, uint8_t *drep)\n{\n\t/* Parse packet */\n\n\toffset = dissect_nt_policy_hnd(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_hnd, NULL, NULL,\n\t\tPIDL_POLHND_USE);\n\n\toffset = dissect_doserror(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_rc, NULL);\n\n\treturn offset;\n}\n\n/*\n * FCPN\n */\n\nstatic int\nSpoolssFCPN_q(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\tproto_tree *tree, dcerpc_info *di, uint8_t *drep)\n{\n\t/* Parse packet */\n\n\toffset = dissect_nt_policy_hnd(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_hnd, NULL, NULL,\n\t\tPIDL_POLHND_USE);\n\n\treturn offset;\n}\n\nstatic int\nSpoolssFCPN_r(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\tproto_tree *tree, dcerpc_info *di, uint8_t *drep)\n{\n\t/* Parse packet */\n\n\toffset = dissect_doserror(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_rc, NULL);\n\n\treturn offset;\n}\n\n/*\n * RouterReplyPrinter\n */\n\nstatic int hf_routerreplyprinter_condition;\nstatic int hf_routerreplyprinter_unknown1;\nstatic int hf_routerreplyprinter_changeid;\n\nstatic int\nSpoolssRouterReplyPrinter_q(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\t\t       proto_tree *tree, dcerpc_info *di, uint8_t *drep)\n{\n\t/* Parse packet */\n\n\toffset = dissect_nt_policy_hnd(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_hnd, NULL, NULL,\n\t\tPIDL_POLHND_USE);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep,\n\t\thf_routerreplyprinter_condition, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep,\n\t\thf_routerreplyprinter_unknown1, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep,\n\t\thf_routerreplyprinter_changeid, NULL);\n\n\treturn offset;\n}\n\nstatic int\nSpoolssRouterReplyPrinter_r(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\t\t       proto_tree *tree, dcerpc_info *di, uint8_t *drep)\n{\n\t/* Parse packet */\n\n\toffset = dissect_doserror(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_rc, NULL);\n\n\treturn offset;\n}\n\nstatic int hf_keybuffer_size;\n\nstatic int\ndissect_spoolss_keybuffer(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\t  proto_tree *tree, dcerpc_info *di, uint8_t *drep)\n{\n\tuint32_t size;\n\tint end_offset;\n\n\tif (di->conformant_run)\n\t\treturn offset;\n\n\t/* Dissect size and data */\n\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, tree, di, drep,\n\t\t\t\t    hf_keybuffer_size, &size);\n\n\tend_offset = offset + (size*2);\n\tif (end_offset < offset) {\n\t\t/*\n\t\t * Overflow - make the end offset one past the end of\n\t\t * the packet data, so we throw an exception (as the\n\t\t * size is almost certainly too big).\n\t\t */\n\t\tend_offset = tvb_reported_length_remaining(tvb, offset) + 1;\n\t}\n\n\twhile (offset > 0 && offset < end_offset) {\n\t\toffset = dissect_spoolss_uint16uni(\n\t\t\ttvb, offset, pinfo, tree, drep, NULL, hf_keybuffer);\n\t}\n\n\treturn offset;\n}\n\n\nstatic int\nSpoolssEnumPrinterKey_q(tvbuff_t *tvb, int offset,\n\t\t\t\t   packet_info *pinfo, proto_tree *tree,\n\t\t\t\t   dcerpc_info *di, uint8_t *drep)\n{\n\tchar *key_name;\n\n\t/* Parse packet */\n\n\toffset = dissect_nt_policy_hnd(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_hnd, NULL, NULL,\n\t\tPIDL_POLHND_USE);\n\n\toffset = dissect_ndr_cvstring(\n\t\ttvb, offset, pinfo, tree, di, drep, sizeof(uint16_t),\n\t\thf_printerdata_key, true, &key_name);\n\n\tif (!key_name[0])\n\t\tkey_name = \"\\\"\\\"\";\n\n\tcol_append_fstr(pinfo->cinfo, COL_INFO, \", %s\", key_name);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_needed, NULL);\n\n\treturn offset;\n}\n\nstatic int\nSpoolssEnumPrinterKey_r(tvbuff_t *tvb, int offset,\n\t\t\t\t   packet_info *pinfo, proto_tree *tree,\n\t\t\t\t   dcerpc_info *di, uint8_t *drep)\n{\n\t/* Parse packet */\n\n\toffset = dissect_spoolss_keybuffer(tvb, offset, pinfo, tree, di, drep);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_needed, NULL);\n\n\toffset = dissect_doserror(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_rc, NULL);\n\n\treturn offset;\n}\n\nstatic int hf_enumprinterdataex_name_offset;\nstatic int hf_enumprinterdataex_name_len;\nstatic int hf_enumprinterdataex_name;\nstatic int hf_enumprinterdataex_val_offset;\nstatic int hf_enumprinterdataex_val_len;\nstatic int hf_enumprinterdataex_val_dword_low;\nstatic int hf_enumprinterdataex_val_dword_high;\nstatic int hf_enumprinterdataex_value_null;\nstatic int hf_enumprinterdataex_value_uint;\nstatic int hf_enumprinterdataex_value_binary;\nstatic int hf_enumprinterdataex_value_multi_sz;\n\nstatic int\nSpoolssEnumPrinterDataEx_q(tvbuff_t *tvb, int offset,\n\t\t\t\t      packet_info *pinfo, proto_tree *tree,\n\t\t\t\t      dcerpc_info *di, uint8_t *drep)\n{\n\tchar *key_name;\n\tproto_item *hidden_item;\n\n\thidden_item = proto_tree_add_uint(\n\t\ttree, hf_printerdata, tvb, offset, 0, 1);\n\tproto_item_set_hidden(hidden_item);\n\n\t/* Parse packet */\n\n\toffset = dissect_nt_policy_hnd(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_hnd, NULL, NULL,\n\t\tPIDL_POLHND_USE);\n\n\toffset = dissect_ndr_cvstring(\n\t\ttvb, offset, pinfo, tree, di, drep, sizeof(uint16_t),\n\t\thf_printerdata_key, true, &key_name);\n\n\tcol_append_fstr(pinfo->cinfo, COL_INFO, \", %s\", key_name);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_offered, NULL);\n\n\treturn offset;\n}\n\nstatic int ett_printer_enumdataex_value;\n\nstatic int\ndissect_spoolss_printer_enum_values(tvbuff_t *tvb, int offset,\n\t\t\t\t    packet_info *pinfo, proto_tree *tree,\n\t\t\t\t    dcerpc_info *di, uint8_t *drep)\n{\n\tuint32_t start_offset = offset;\n\tuint32_t name_offset, name_len, val_offset, val_len, val_type;\n\tchar *name;\n\tproto_item *item;\n\tproto_tree *subtree;\n\n\t/* Get offset of value name */\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, NULL, di, drep,\n\t\thf_enumprinterdataex_name_offset, &name_offset);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, NULL, di, drep,\n\t\thf_enumprinterdataex_name_len, &name_len);\n\n\tdissect_spoolss_uint16uni(\n\t\ttvb, start_offset + name_offset, pinfo, NULL, drep,\n\t\t&name, hf_enumprinterdataex_name);\n\n\tsubtree = proto_tree_add_subtree_format(tree, tvb, offset, 0, ett_printer_enumdataex_value, &item, \"Name: %s\", name);\n\n\tproto_tree_add_uint(subtree, hf_enumprinterdataex_name_offset, tvb, offset - 8, 4, name_offset);\n\n\tproto_tree_add_uint(subtree, hf_enumprinterdataex_name_len, tvb, offset - 4, 4, name_len);\n\n\tproto_tree_add_string( subtree, hf_enumprinterdataex_name, tvb, start_offset + name_offset, ((int)strlen(name) + 1) * 2, name);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_printerdata_type,\n\t\t&val_type);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\thf_enumprinterdataex_val_offset, &val_offset);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\thf_enumprinterdataex_val_len, &val_len);\n\n\tif (val_len == 0) {\n\t\tproto_tree_add_uint_format_value(subtree, hf_enumprinterdataex_value_null, tvb, start_offset + val_offset, 4, 0, \"(null)\");\n\t\treturn offset;\n\t}\n\n\tswitch(val_type) {\n\tcase DCERPC_REG_DWORD: {\n\t\tuint32_t value;\n\t\tuint16_t low, high;\n\t\tint offset2 = start_offset + val_offset;\n\n\t\t/* Needs to be broken into two 16-byte ints because it may\n\t\t   not be aligned. */\n\n\t\toffset2 = dissect_ndr_uint16(\n\t\t\ttvb, offset2, pinfo, subtree, di, drep,\n\t\t\thf_enumprinterdataex_val_dword_low, &low);\n\n\t\t/*offset2 = */dissect_ndr_uint16(\n\t\t\ttvb, offset2, pinfo, subtree, di, drep,\n\t\t\thf_enumprinterdataex_val_dword_high, &high);\n\n\t\tvalue = (high << 16) | low;\n\n\t\tproto_tree_add_uint(subtree, hf_enumprinterdataex_value_uint, tvb, start_offset + val_offset, 4, value);\n\n\t\tproto_item_append_text(item, \", Value: %d\", value);\n\n\t\tbreak;\n\t}\n\tcase DCERPC_REG_SZ: {\n\t\tchar *value;\n\n\t\tdissect_spoolss_uint16uni(\n\t\t\ttvb, start_offset + val_offset, pinfo, subtree, drep,\n\t\t\t&value, hf_value_string);\n\n\t\tproto_item_append_text(item, \", Value: %s\", value);\n\n\t\tbreak;\n\t}\n\tcase DCERPC_REG_BINARY:\n\n\t\t/* FIXME: nicer way to display this */\n\n\t\tproto_tree_add_bytes_format_value( subtree, hf_enumprinterdataex_value_binary, tvb, start_offset + val_offset, val_len, NULL, \"<binary data>\");\n\t\tbreak;\n\n\tcase DCERPC_REG_MULTI_SZ:\n\n\t\t/* FIXME: implement REG_MULTI_SZ support */\n\n\t\tproto_tree_add_bytes_format_value(subtree, hf_enumprinterdataex_value_multi_sz, tvb, start_offset + val_offset, val_len, NULL, \"<REG_MULTI_SZ not implemented>\");\n\t\tbreak;\n\n\tdefault:\n\t\tproto_tree_add_expert_format( subtree, pinfo, &ei_enumprinterdataex_value, tvb, start_offset + val_offset, val_len, \"%s: unknown type %d\", name, val_type);\n\t}\n\n\treturn offset;\n}\n\nstatic int ett_PRINTER_DATA_CTR;\n\nstatic int\nSpoolssEnumPrinterDataEx_r(tvbuff_t *tvb, int offset,\n\t\t\t\t   packet_info *pinfo, proto_tree *tree,\n\t\t\t\t   dcerpc_info *di, uint8_t *drep)\n{\n\tuint32_t size, num_values;\n\tproto_item *hidden_item;\n\n\thidden_item = proto_tree_add_uint(\n\t\ttree, hf_printerdata, tvb, offset, 0, 1);\n\tproto_item_set_hidden(hidden_item);\n\n\t/* Parse packet */\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep,\n\t\thf_buffer_size, &size);\n\n\tdissect_ndr_uint32(\n\t\ttvb, offset + size + 4, pinfo, NULL, di, drep, hf_returned,\n\t\t&num_values);\n\n\tif (size) {\n\t\tproto_tree *subtree;\n\t\tint offset2 = offset;\n\t\tuint32_t i;\n\n\t\tsubtree = proto_tree_add_subtree(\n\t\t\ttree, tvb, offset, 0, ett_PRINTER_DATA_CTR, NULL, \"Printer data\");\n\n\t\tfor (i=0; i < num_values; i++)\n\t\t\toffset2 = dissect_spoolss_printer_enum_values(\n\t\t\t\ttvb, offset2, pinfo, subtree, di, drep);\n\t}\n\n\toffset += size;\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_needed, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_returned, NULL);\n\n\toffset = dissect_doserror(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_rc, NULL);\n\n\treturn offset;\n}\n\nstatic int\nSpoolssGetPrinterDriverDirectory_q(tvbuff_t *tvb, int offset,\n\t\t\t\t      packet_info *pinfo, proto_tree *tree,\n\t\t\t\t      dcerpc_info *di, uint8_t *drep)\n{\n\tuint32_t level;\n\n\t/* Parse packet */\n\n\toffset = dissect_ndr_str_pointer_item(\n\t\ttvb, offset, pinfo, tree, di, drep, NDR_POINTER_UNIQUE,\n\t\t\"Name\", hf_servername, 0);\n\n\toffset = dissect_ndr_str_pointer_item(\n\t\ttvb, offset, pinfo, tree, di, drep, NDR_POINTER_UNIQUE,\n\t\t\"Environment\", hf_environment, 0);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_level, &level);\n\n\toffset = dissect_spoolss_buffer(\n\t\ttvb, offset, pinfo, tree, di, drep, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_offered, NULL);\n\n\treturn offset;\n}\n\nstatic int\nSpoolssGetPrinterDriverDirectory_r(tvbuff_t *tvb, int offset,\n\t\t\t\t      packet_info *pinfo, proto_tree *tree,\n\t\t\t\t      dcerpc_info *di, uint8_t *drep)\n{\n\t/* Parse packet */\n\n\toffset = dissect_spoolss_string_parm(\n\t\ttvb, offset, pinfo, tree, di, drep, \"Directory\");\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_needed, NULL);\n\n\toffset = dissect_doserror(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_rc, NULL);\n\n\treturn offset;\n}\n\nstatic int\nSpoolssGetCorePrinterDrivers_q(tvbuff_t *tvb, int offset,\n\t\t\t       packet_info *pinfo, proto_tree *tree,\n\t\t\t       dcerpc_info *di, uint8_t *drep)\n{\n\t/* Parse packet */\n\n\toffset = dissect_ndr_str_pointer_item(\n\t\ttvb, offset, pinfo, tree, di, drep, NDR_POINTER_UNIQUE,\n\t\t\"Name\", hf_servername, 0);\n\n\toffset = dissect_ndr_str_pointer_item(\n\t\ttvb, offset, pinfo, tree, di, drep, NDR_POINTER_REF,\n\t\t\"Environment\", hf_environment, 0);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep,\n\t\thf_offered, NULL);\n#if 1\n\toffset = dissect_spoolss_keybuffer(\n\t\ttvb, offset, pinfo, tree, di, drep);\n#else\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep,\n\t\thf_core_driver_size, NULL);\n\n\toffset = dissect_spoolss_uint16uni(\n\t\ttvb, offset, pinfo, tree, drep,\n\t\tNULL, hf_core_printer_driver_ids);\n#endif\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep,\n\t\thf_core_printer_driver_count, NULL);\n\n\treturn offset;\n}\n\nstatic int\nSpoolssGetCorePrinterDrivers_r(tvbuff_t *tvb, int offset,\n\t\t\t       packet_info *pinfo, proto_tree *tree,\n\t\t\t       dcerpc_info *di, uint8_t *drep)\n{\n\tuint32_t num_drivers, i;\n\n\t/* Parse packet */\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep,\n\t\thf_core_printer_driver_count,\n\t\t&num_drivers);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_core_printer_driver_ids,\n\t\tNULL);\n\n\tfor (i = 0; i < num_drivers; i++) {\n\t\toffset = dissect_CORE_PRINTER_DRIVER(\n\t\t\ttvb, offset, pinfo,\n\t\t\ttree, di, drep);\n\t}\n\n\toffset = dissect_hresult(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_hresult, NULL);\n\n\treturn offset;\n}\n\nstatic int\nSpoolssGetPrinterDriverPackagePath_q(tvbuff_t *tvb, int offset,\n\t\t\t\t     packet_info *pinfo, proto_tree *tree,\n\t\t\t\t     dcerpc_info *di, uint8_t *drep)\n{\n\t/* Parse packet */\n\n\toffset = dissect_ndr_str_pointer_item(\n\t\ttvb, offset, pinfo, tree, di, drep, NDR_POINTER_UNIQUE,\n\t\t\"Name\", hf_servername, 0);\n\n\toffset = dissect_ndr_str_pointer_item(\n\t\ttvb, offset, pinfo, tree, di, drep, NDR_POINTER_REF,\n\t\t\"Environment\", hf_environment, 0);\n\n\toffset = dissect_ndr_str_pointer_item(\n\t\ttvb, offset, pinfo, tree, di, drep, NDR_POINTER_UNIQUE,\n\t\t\"Language\", hf_language, 0);\n\n\toffset = dissect_ndr_str_pointer_item(\n\t\ttvb, offset, pinfo, tree, di, drep, NDR_POINTER_REF,\n\t\t\"PackageId\", hf_package_id, 0);\n\n\toffset = dissect_spoolss_buffer(\n\t\ttvb, offset, pinfo, tree, di, drep, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep,\n\t\thf_driver_package_cab_size, NULL);\n\n\treturn offset;\n}\n\nstatic int\nSpoolssGetPrinterDriverPackagePath_r(tvbuff_t *tvb, int offset,\n\t\t\t\t     packet_info *pinfo, proto_tree *tree,\n\t\t\t\t     dcerpc_info *di, uint8_t *drep)\n{\n\t/* Parse packet */\n\n\toffset = dissect_spoolss_string_parm(\n\t\ttvb, offset, pinfo, tree, di, drep, \"DriverPackageCab\");\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_needed, NULL);\n\n\toffset = dissect_hresult(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_hresult, NULL);\n\n\treturn offset;\n}\n\n/*\n * List of subdissectors for this pipe.\n */\n\nstatic const dcerpc_sub_dissector dcerpc_spoolss_dissectors[] = {\n\t{ SPOOLSS_ENUMPRINTERS, \"EnumPrinters\",\n\t  SpoolssEnumPrinters_q, SpoolssEnumPrinters_r },\n\t{ SPOOLSS_OPENPRINTER, \"OpenPrinter\",\n\t  NULL, SpoolssGeneric_r },\n\t{ SPOOLSS_SETJOB, \"SetJob\",\n\t  SpoolssSetJob_q, SpoolssSetJob_r },\n\t{ SPOOLSS_GETJOB, \"GetJob\",\n\t  SpoolssGetJob_q, SpoolssGetJob_r },\n\t{ SPOOLSS_ENUMJOBS, \"EnumJobs\",\n\t  SpoolssEnumJobs_q, SpoolssEnumJobs_r },\n\t{ SPOOLSS_ADDPRINTER, \"AddPrinter\",\n\t  NULL, SpoolssGeneric_r },\n\t{ SPOOLSS_DELETEPRINTER, \"DeletePrinter\",\n\t  SpoolssDeletePrinter_q, SpoolssDeletePrinter_r },\n\t{ SPOOLSS_SETPRINTER, \"SetPrinter\",\n\t  SpoolssSetPrinter_q, SpoolssSetPrinter_r },\n\t{ SPOOLSS_GETPRINTER, \"GetPrinter\",\n\t  SpoolssGetPrinter_q, SpoolssGetPrinter_r },\n\t{ SPOOLSS_ADDPRINTERDRIVER, \"AddPrinterDriver\",\n\t  NULL, SpoolssAddPrinterDriver_r },\n\t{ SPOOLSS_ENUMPRINTERDRIVERS, \"EnumPrinterDrivers\",\n\t  SpoolssEnumPrinterDrivers_q, SpoolssEnumPrinterDrivers_r },\n\t{ SPOOLSS_GETPRINTERDRIVER, \"GetPrinterDriver\",\n\t  NULL, SpoolssGeneric_r },\n\t{ SPOOLSS_GETPRINTERDRIVERDIRECTORY, \"GetPrinterDriverDirectory\",\n\t  SpoolssGetPrinterDriverDirectory_q, SpoolssGetPrinterDriverDirectory_r },\n\t{ SPOOLSS_DELETEPRINTERDRIVER, \"DeletePrinterDriver\",\n\t  NULL, SpoolssGeneric_r },\n\t{ SPOOLSS_ADDPRINTPROCESSOR, \"AddPrintProcessor\",\n\t  NULL, SpoolssGeneric_r },\n\t{ SPOOLSS_ENUMPRINTPROCESSORS, \"EnumPrintProcessor\",\n\t  NULL, SpoolssGeneric_r },\n\t{ SPOOLSS_GETPRINTPROCESSORDIRECTORY, \"GetPrintProcessorDirectory\",\n\t  NULL, SpoolssGeneric_r },\n\t{ SPOOLSS_STARTDOCPRINTER, \"StartDocPrinter\",\n\t  SpoolssStartDocPrinter_q, SpoolssStartDocPrinter_r },\n\t{ SPOOLSS_STARTPAGEPRINTER, \"StartPagePrinter\",\n\t  SpoolssStartPagePrinter_q, SpoolssStartPagePrinter_r },\n\t{ SPOOLSS_WRITEPRINTER, \"WritePrinter\",\n\t  SpoolssWritePrinter_q, SpoolssWritePrinter_r },\n\t{ SPOOLSS_ENDPAGEPRINTER, \"EndPagePrinter\",\n\t  SpoolssEndPagePrinter_q, SpoolssEndPagePrinter_r },\n\t{ SPOOLSS_ABORTPRINTER, \"AbortPrinter\",\n\t  NULL, SpoolssGeneric_r },\n\t{ SPOOLSS_READPRINTER, \"ReadPrinter\",\n\t  NULL, SpoolssGeneric_r },\n\t{ SPOOLSS_ENDDOCPRINTER, \"EndDocPrinter\",\n\t  SpoolssEndDocPrinter_q, SpoolssEndDocPrinter_r },\n\t{ SPOOLSS_ADDJOB, \"AddJob\",\n\t  NULL, SpoolssGeneric_r },\n\t{ SPOOLSS_SCHEDULEJOB, \"ScheduleJob\",\n\t  NULL, SpoolssGeneric_r },\n\t{ SPOOLSS_GETPRINTERDATA, \"GetPrinterData\",\n\t  SpoolssGetPrinterData_q, SpoolssGetPrinterData_r },\n\t{ SPOOLSS_SETPRINTERDATA, \"SetPrinterData\",\n\t  SpoolssSetPrinterData_q, SpoolssSetPrinterData_r },\n\t{ SPOOLSS_WAITFORPRINTERCHANGE, \"WaitForPrinterChange\",\n\t  NULL, SpoolssGeneric_r },\n\t{ SPOOLSS_CLOSEPRINTER, \"ClosePrinter\",\n\t  SpoolssClosePrinter_q, SpoolssClosePrinter_r },\n\t{ SPOOLSS_ADDFORM, \"AddForm\",\n\t  SpoolssAddForm_q, SpoolssAddForm_r },\n\t{ SPOOLSS_DELETEFORM, \"DeleteForm\",\n\t  SpoolssDeleteForm_q, SpoolssDeleteForm_r },\n\t{ SPOOLSS_GETFORM, \"GetForm\",\n\t  SpoolssGetForm_q, SpoolssGetForm_r },\n\t{ SPOOLSS_SETFORM, \"SetForm\",\n\t  SpoolssSetForm_q, SpoolssSetForm_r },\n\t{ SPOOLSS_ENUMFORMS, \"EnumForms\",\n\t  SpoolssEnumForms_q, SpoolssEnumForms_r },\n\t{ SPOOLSS_ENUMPORTS, \"EnumPorts\",\n\t  NULL, SpoolssGeneric_r },\n\t{ SPOOLSS_ENUMMONITORS, \"EnumMonitors\",\n\t  NULL, SpoolssGeneric_r },\n\t{ SPOOLSS_ADDPORT, \"AddPort\",\n\t  NULL, SpoolssGeneric_r },\n\t{ SPOOLSS_CONFIGUREPORT, \"ConfigurePort\",\n\t  NULL, SpoolssGeneric_r },\n\t{ SPOOLSS_DELETEPORT, \"DeletePort\",\n\t  NULL, SpoolssGeneric_r },\n\t{ SPOOLSS_CREATEPRINTERIC, \"CreatePrinterIC\",\n\t  NULL, SpoolssGeneric_r },\n\t{ SPOOLSS_PLAYGDISCRIPTONPRINTERIC, \"PlayDiscriptOnPrinterIC\",\n\t  NULL, SpoolssGeneric_r },\n\t{ SPOOLSS_DELETEPRINTERIC, \"DeletePrinterIC\",\n\t  NULL, SpoolssGeneric_r },\n\t{ SPOOLSS_ADDPRINTERCONNECTION, \"AddPrinterConnection\",\n\t  NULL, SpoolssGeneric_r },\n\t{ SPOOLSS_DELETEPRINTERCONNECTION, \"DeletePrinterConnection\",\n\t  NULL, SpoolssGeneric_r },\n\t{ SPOOLSS_PRINTERMESSAGEBOX, \"PrinterMessageBox\",\n\t  NULL, SpoolssGeneric_r },\n\t{ SPOOLSS_ADDMONITOR, \"AddMonitor\",\n\t  NULL, SpoolssGeneric_r },\n\t{ SPOOLSS_DELETEMONITOR, \"DeleteMonitor\",\n\t  NULL, SpoolssGeneric_r },\n\t{ SPOOLSS_DELETEPRINTPROCESSOR, \"DeletePrintProcessor\",\n\t  NULL, SpoolssGeneric_r },\n\t{ SPOOLSS_ADDPRINTPROVIDER, \"AddPrintProvider\",\n\t  NULL, SpoolssGeneric_r },\n\t{ SPOOLSS_DELETEPRINTPROVIDER, \"DeletePrintProvider\",\n\t  NULL, SpoolssGeneric_r },\n\t{ SPOOLSS_ENUMPRINTPROCDATATYPES, \"EnumPrintProcDataTypes\",\n\t  NULL, SpoolssGeneric_r },\n\t{ SPOOLSS_RESETPRINTER, \"ResetPrinter\",\n\t  NULL, SpoolssGeneric_r },\n\t{ SPOOLSS_GETPRINTERDRIVER2, \"GetPrinterDriver2\",\n\t  SpoolssGetPrinterDriver2_q, SpoolssGetPrinterDriver2_r },\n\t{ SPOOLSS_FINDFIRSTPRINTERCHANGENOTIFICATION,\n\t  \"FindFirstPrinterChangeNotification\",\n\t  NULL, SpoolssGeneric_r },\n\t{ SPOOLSS_FINDNEXTPRINTERCHANGENOTIFICATION,\n\t  \"FindNextPrinterChangeNotification\",\n\t  NULL, SpoolssGeneric_r },\n\t{ SPOOLSS_FCPN, \"FCPN\",\n\t  SpoolssFCPN_q, SpoolssFCPN_r },\n\t{ SPOOLSS_ROUTERFINDFIRSTPRINTERNOTIFICATIONOLD,\n\t  \"RouterFindFirstPrinterNotificationOld\",\n\t  NULL, SpoolssGeneric_r },\n\t{ SPOOLSS_REPLYOPENPRINTER, \"ReplyOpenPrinter\",\n\t  SpoolssReplyOpenPrinter_q, SpoolssReplyOpenPrinter_r },\n\t{ SPOOLSS_ROUTERREPLYPRINTER, \"RouterReplyPrinter\",\n\t  SpoolssRouterReplyPrinter_q, SpoolssRouterReplyPrinter_r },\n\t{ SPOOLSS_REPLYCLOSEPRINTER, \"ReplyClosePrinter\",\n\t  SpoolssReplyClosePrinter_q, SpoolssReplyClosePrinter_r },\n\t{ SPOOLSS_ADDPORTEX, \"AddPortEx\",\n\t  NULL, SpoolssGeneric_r },\n\t{ SPOOLSS_REMOTEFINDFIRSTPRINTERCHANGENOTIFICATION,\n\t  \"RemoteFindFirstPrinterChangeNotification\",\n\t  NULL, SpoolssGeneric_r },\n\t{ SPOOLSS_SPOOLERINIT, \"SpoolerInit\",\n\t  NULL, SpoolssGeneric_r },\n\t{ SPOOLSS_RESETPRINTEREX, \"ResetPrinterEx\",\n\t  NULL, SpoolssGeneric_r },\n\t{ SPOOLSS_RFFPCNEX, \"RFFPCNEX\",\n\t  SpoolssRFFPCNEX_q, SpoolssRFFPCNEX_r },\n\t{ SPOOLSS_RRPCN, \"RRPCN\",\n\t  SpoolssRRPCN_q, SpoolssRRPCN_r },\n\t{ SPOOLSS_RFNPCNEX, \"RFNPCNEX\",\n\t  SpoolssRFNPCNEX_q, SpoolssRFNPCNEX_r },\n\t{ SPOOLSS_OPENPRINTEREX, \"OpenPrinterEx\",\n\t  SpoolssOpenPrinterEx_q, SpoolssOpenPrinterEx_r },\n\t{ SPOOLSS_ADDPRINTEREX, \"AddPrinterEx\",\n\t  NULL, SpoolssAddPrinterEx_r },\n\t{ SPOOLSS_ENUMPRINTERDATA, \"EnumPrinterData\",\n\t  SpoolssEnumPrinterData_q, SpoolssEnumPrinterData_r },\n\t{ SPOOLSS_DELETEPRINTERDATA, \"DeletePrinterData\",\n\t  SpoolssDeletePrinterData_q, SpoolssDeletePrinterData_r },\n\t{ SPOOLSS_GETPRINTERDATAEX, \"GetPrinterDataEx\",\n\t  SpoolssGetPrinterDataEx_q, SpoolssGetPrinterDataEx_r },\n\t{ SPOOLSS_SETPRINTERDATAEX, \"SetPrinterDataEx\",\n\t  SpoolssSetPrinterDataEx_q, SpoolssSetPrinterDataEx_r },\n\t{ SPOOLSS_ENUMPRINTERDATAEX, \"EnumPrinterDataEx\",\n\t  SpoolssEnumPrinterDataEx_q, SpoolssEnumPrinterDataEx_r },\n\t{ SPOOLSS_ENUMPRINTERKEY, \"EnumPrinterKey\",\n\t  SpoolssEnumPrinterKey_q, SpoolssEnumPrinterKey_r },\n\t{ SPOOLSS_DELETEPRINTERDATAEX, \"DeletePrinterDataEx\",\n\t  NULL, SpoolssGeneric_r },\n\t{ SPOOLSS_DELETEPRINTERDRIVEREX, \"DeletePrinterDriverEx\",\n\t  NULL, SpoolssGeneric_r },\n\t{ SPOOLSS_ADDPRINTERDRIVEREX, \"AddPrinterDriverEx\",\n\t  NULL, SpoolssGeneric_r },\n\t{ SPOOLSS_GETCOREPRINTERDRIVERS, \"GetCorePrinterDrivers\",\n\t  SpoolssGetCorePrinterDrivers_q, SpoolssGetCorePrinterDrivers_r },\n\t{ SPOOLSS_GETPRINTERDRIVERPACKAGEPATH, \"GetPrinterDriverPackagePath\",\n\t  SpoolssGetPrinterDriverPackagePath_q, SpoolssGetPrinterDriverPackagePath_r },\n\n\t{ 0, NULL, NULL, NULL },\n};\n\n/*\n * Dissector initialisation function\n */\n\n/* Protocol registration */\n\nstatic int proto_dcerpc_spoolss;\nstatic int ett_dcerpc_spoolss;\n\nvoid\nproto_register_dcerpc_spoolss(void)\n{\n\tstatic hf_register_info hf[] = {\n\n\t\t/* GetPrinterDriver2 */\n\n\t\t{ &hf_clientmajorversion,\n\t\t  { \"Client major version\", \"spoolss.clientmajorversion\", FT_UINT32, BASE_DEC,\n\t\t    NULL, 0x0, \"Client printer driver major version\", HFILL }},\n\t\t{ &hf_clientminorversion,\n\t\t  { \"Client minor version\", \"spoolss.clientminorversion\", FT_UINT32, BASE_DEC,\n\t\t    NULL, 0x0, \"Client printer driver minor version\", HFILL }},\n\t\t{ &hf_servermajorversion,\n\t\t  { \"Server major version\", \"spoolss.servermajorversion\", FT_UINT32, BASE_DEC,\n\t\t    NULL, 0x0, \"Server printer driver major version\", HFILL }},\n\t\t{ &hf_serverminorversion,\n\t\t  { \"Server minor version\", \"spoolss.serverminorversion\", FT_UINT32, BASE_DEC,\n\t\t    NULL, 0x0, \"Server printer driver minor version\", HFILL }},\n\t\t{ &hf_driverpath,\n\t\t  { \"Driver path\", \"spoolss.driverpath\", FT_STRING, BASE_NONE,\n\t\t    NULL, 0, NULL, HFILL }},\n\t\t{ &hf_datafile,\n\t\t  { \"Data file\", \"spoolss.datafile\", FT_STRING, BASE_NONE,\n\t\t    NULL, 0, NULL, HFILL }},\n\t\t{ &hf_configfile,\n\t\t  { \"Config file\", \"spoolss.configfile\", FT_STRING, BASE_NONE,\n\t\t    NULL, 0, \"Printer name\", HFILL }},\n\t\t{ &hf_helpfile,\n\t\t  { \"Help file\", \"spoolss.helpfile\", FT_STRING, BASE_NONE,\n\t\t    NULL, 0, NULL, HFILL }},\n\t\t{ &hf_monitorname,\n\t\t  { \"Monitor name\", \"spoolss.monitorname\", FT_STRING, BASE_NONE,\n\t\t    NULL, 0, NULL, HFILL }},\n\t\t{ &hf_defaultdatatype,\n\t\t  { \"Default data type\", \"spoolss.defaultdatatype\", FT_STRING, BASE_NONE,\n\t\t    NULL, 0, NULL, HFILL }},\n\t\t{ &hf_driverinfo_cversion,\n\t\t  { \"Driver version\", \"spoolss.drivercversion\", FT_UINT32, BASE_DEC,\n\t\t    VALS(driverinfo_cversion_vals), 0, \"Printer name\", HFILL }},\n\t\t{ &hf_dependentfiles,\n\t\t  { \"Dependent files\", \"spoolss.dependentfiles\", FT_STRING, BASE_NONE,\n\t\t    NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_printer_status,\n\t\t  { \"Status\", \"spoolss.printer_status\", FT_UINT32, BASE_DEC|BASE_EXT_STRING,\n\t\t    &printer_status_vals_ext, 0, NULL, HFILL }},\n\n\t\t{ &hf_previousdrivernames,\n\t\t  { \"Previous Driver Names\", \"spoolss.previousdrivernames\", FT_STRING, BASE_NONE,\n\t\t    NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_color_profiles,\n\t\t  { \"Color Profiles\", \"spoolss.colorprofiles\", FT_STRING, BASE_NONE,\n\t\t    NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_core_driver_dependencies,\n\t\t  { \"Core Driver Dependencies\", \"spoolss.coredriverdependencies\", FT_STRING, BASE_NONE,\n\t\t    NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_driverdate,\n\t\t  { \"Driver Date\", \"spoolss.driverdate\", FT_ABSOLUTE_TIME, ABSOLUTE_TIME_LOCAL,\n\t\t    NULL, 0, \"Date of driver creation\", HFILL }},\n\n\t\t{ &hf_min_inbox_driverdate,\n\t\t  { \"Min Inbox Driver Date\", \"spoolss.mininboxdriverdate\", FT_ABSOLUTE_TIME, ABSOLUTE_TIME_LOCAL,\n\t\t    NULL, 0, \"Min Inbox Date of driver creation\", HFILL }},\n\n\t\t{ &hf_padding,\n\t\t  { \"Padding\", \"spoolss.padding\", FT_UINT32, BASE_HEX,\n\t\t    NULL, 0, \"Some padding - conveys no semantic information\", HFILL }},\n\n\t\t{ &hf_driver_version,\n\t\t  { \"Driver Version\", \"spoolss.driverversion\", FT_UINT64, BASE_HEX,\n\t\t    NULL, 0, \"Driver Version ID\", HFILL }},\n\n\t\t{ &hf_driver_version_low,\n\t\t  { \"Minor Driver Version\", \"spoolss.minordriverversion\", FT_UINT32, BASE_HEX,\n\t\t    NULL, 0, \"Driver Version Low\", HFILL }},\n\n\t\t{ &hf_driver_version_high,\n\t\t  { \"Major Driver Version\", \"spoolss.majordriverversion\", FT_UINT32, BASE_HEX,\n\t\t    NULL, 0, \"Driver Version High\", HFILL }},\n\n\t\t{ &hf_min_inbox_driver_version_low,\n\t\t  { \"Min Inbox Minor Driver Version\", \"spoolss.mininboxminordriverversion\", FT_UINT32, BASE_HEX,\n\t\t    NULL, 0, \"Min Inbox Driver Version Low\", HFILL }},\n\n\t\t{ &hf_min_inbox_driver_version_high,\n\t\t  { \"Min Inbox Major Driver Version\", \"spoolss.mininboxmajordriverversion\", FT_UINT32, BASE_HEX,\n\t\t    NULL, 0, \"Min Inbox Driver Version High\", HFILL }},\n\n\t\t{ &hf_mfgname,\n\t\t  { \"Mfgname\", \"spoolss.mfgname\", FT_STRING, BASE_NONE,\n\t\t    NULL, 0, \"Manufacturer Name\", HFILL }},\n\n\t\t{ &hf_oemurl,\n\t\t  { \"OEM URL\", \"spoolss.oemrul\", FT_STRING, BASE_NONE,\n\t\t    NULL, 0, \"OEM URL - Website of Vendor\", HFILL }},\n\n\t\t{ &hf_hardwareid,\n\t\t  { \"Hardware ID\", \"spoolss.hardwareid\", FT_STRING, BASE_NONE,\n\t\t    NULL, 0, \"Hardware Identification Information\", HFILL }},\n\n\t   \t{ &hf_provider,\n\t   \t  { \"Provider\", \"spoolss.provider\", FT_STRING, BASE_NONE,\n\t\t    NULL, 0, \"Provider of Driver\", HFILL }},\n\n\t\t/* Setprinter RPC */\n\n\t\t{ &hf_setprinter_cmd,\n\t\t  { \"Command\", \"spoolss.setprinter_cmd\", FT_UINT32, BASE_DEC,\n\t\t   VALS(setprinter_cmd_vals), 0, NULL, HFILL }},\n\n\t\t/* Enumprinters */\n\n\t\t{ &hf_enumprinters_flags,\n\t\t  { \"Flags\", \"spoolss.enumprinters.flags\",\n\t\t    FT_UINT32, BASE_HEX, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_enumprinters_flags_local,\n\t\t  { \"Enum local\", \"spoolss.enumprinters.flags.enum_local\",\n\t\t    FT_BOOLEAN, 32, TFS(&tfs_set_notset),\n\t\t    PRINTER_ENUM_LOCAL, NULL, HFILL }},\n\n\t\t{ &hf_enumprinters_flags_name,\n\t\t  { \"Enum name\", \"spoolss.enumprinters.flags.enum_name\",\n\t\t    FT_BOOLEAN, 32, TFS(&tfs_set_notset),\n\t\t    PRINTER_ENUM_NAME, NULL, HFILL }},\n\n\t\t{ &hf_enumprinters_flags_shared,\n\t\t  { \"Enum shared\", \"spoolss.enumprinters.flags.enum_shared\",\n\t\t    FT_BOOLEAN, 32, TFS(&tfs_set_notset),\n\t\t    PRINTER_ENUM_SHARED, NULL, HFILL }},\n\n\t\t{ &hf_enumprinters_flags_default,\n\t\t  { \"Enum default\", \"spoolss.enumprinters.flags.enum_default\",\n\t\t    FT_BOOLEAN, 32, TFS(&tfs_set_notset),\n\t\t    PRINTER_ENUM_DEFAULT, NULL, HFILL }},\n\n\t\t{ &hf_enumprinters_flags_connections,\n\t\t  { \"Enum connections\", \"spoolss.enumprinters.flags.enum_connections\",\n\t\t    FT_BOOLEAN, 32, TFS(&tfs_set_notset),\n\t\t    PRINTER_ENUM_CONNECTIONS, NULL, HFILL }},\n\n\t\t{ &hf_enumprinters_flags_network,\n\t\t  { \"Enum network\", \"spoolss.enumprinters.flags.enum_network\",\n\t\t    FT_BOOLEAN, 32, TFS(&tfs_set_notset),\n\t\t    PRINTER_ENUM_NETWORK, NULL, HFILL }},\n\n\t\t{ &hf_enumprinters_flags_remote,\n\t\t  { \"Enum remote\", \"spoolss.enumprinters.flags.enum_remote\",\n\t\t    FT_BOOLEAN, 32, TFS(&tfs_set_notset),\n\t\t    PRINTER_ENUM_REMOTE, NULL, HFILL }},\n\n\t\t/* GetPrinter */\n\n\t\t{ &hf_start_time,\n\t\t  { \"Start time\", \"spoolss.start_time\",\n\t\t    FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_end_time,\n\t\t  { \"End time\", \"spoolss.end_time\",\n\t\t    FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_elapsed_time,\n\t\t  { \"Elapsed time\", \"spoolss.elapsed_time\",\n\t\t    FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_device_not_selected_timeout,\n\t\t  { \"Device Not Selected Timeout\", \"spoolss.device_not_selected_timeout\",\n\t\t    FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_transmission_retry_timeout,\n\t\t  { \"Transmission Retry Timeout\", \"spoolss.transmission_retry_timeout\",\n\t\t    FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t/*\n\t\t * New hf index values\n\t\t */\n\n\t\t{ &hf_opnum,\n\t\t  { \"Operation\", \"spoolss.opnum\", FT_UINT16, BASE_DEC,\n\t\t    NULL, 0x0, NULL, HFILL }},\n\n\t\t{ &hf_hnd,\n\t\t  { \"Context handle\", \"spoolss.hnd\", FT_BYTES, BASE_NONE,\n\t\t    NULL, 0x0, \"SPOOLSS policy handle\", HFILL }},\n\n\t\t{ &hf_rc,\n\t\t  { \"Return code\", \"spoolss.rc\", FT_UINT32, BASE_HEX | BASE_EXT_STRING,\n\t\t    &DOS_errors_ext, 0x0, \"SPOOLSS return code\", HFILL }},\n\n\t\t{ &hf_hresult,\n\t\t  { \"HRESULT return code\", \"spoolss.hresult\", FT_UINT32, BASE_HEX | BASE_EXT_STRING,\n\t\t    &HRES_errors_ext, 0x0, \"SPOOLSS HRESULT return code\", HFILL }},\n\n\t\t{ &hf_offered,\n\t\t  { \"Offered\", \"spoolss.offered\", FT_UINT32, BASE_DEC,\n\t\t    NULL, 0x0, \"Size of buffer offered in this request\",\n\t\t    HFILL }},\n\n\t\t{ &hf_needed,\n\t\t  { \"Needed\", \"spoolss.needed\", FT_UINT32, BASE_DEC,\n\t\t    NULL, 0x0, \"Size of buffer required for request\", HFILL }},\n\n\t\t{ &hf_returned,\n\t\t  { \"Returned\", \"spoolss.returned\", FT_UINT32, BASE_DEC,\n\t\t    NULL, 0x0, \"Number of items returned\", HFILL }},\n\n\t\t{ &hf_buffer_size,\n\t\t  { \"Buffer size\", \"spoolss.buffer.size\", FT_UINT32, BASE_DEC,\n\t\t    NULL, 0x0, \"Size of buffer\", HFILL }},\n\n\t\t{ &hf_buffer_data,\n\t\t  { \"Buffer data\", \"spoolss.buffer.data\", FT_BYTES, BASE_NONE,\n\t\t    NULL, 0x0, \"Contents of buffer\", HFILL }},\n\n\t\t{ &hf_string_parm_size,\n\t\t  { \"String buffer size\", \"spoolss.string.buffersize\", FT_UINT32, BASE_DEC,\n\t\t    NULL, 0x0, \"Size of string buffer\", HFILL }},\n\n\t\t{ &hf_string_parm_data,\n\t\t  { \"String data\", \"spoolss.string.data\", FT_STRINGZ, BASE_NONE,\n\t\t    NULL, 0x0, \"Contents of string\", HFILL }},\n\n\t\t{ &hf_offset,\n\t\t  { \"Offset\", \"spoolss.offset\", FT_UINT32, BASE_DEC,\n\t\t    NULL, 0x0, \"Offset of data\", HFILL }},\n\n\t\t{ &hf_level,\n\t\t  { \"Info level\", \"spoolss.enumjobs.level\", FT_UINT32,\n\t\t    BASE_DEC, NULL, 0x0, NULL, HFILL }},\n\n\n\t\t{ &hf_printername,\n\t\t  { \"Printer name\", \"spoolss.printername\", FT_STRING,\n\t\t    BASE_NONE, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_machinename,\n\t\t  { \"Machine name\", \"spoolss.machinename\", FT_STRING,\n\t\t    BASE_NONE, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_notifyname,\n\t\t  { \"Notify name\", \"spoolss.notifyname\", FT_STRING,\n\t\t    BASE_NONE, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_printerdesc,\n\t\t  { \"Printer description\", \"spoolss.printerdesc\", FT_STRING,\n\t\t    BASE_NONE, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_printercomment,\n\t\t  { \"Printer comment\", \"spoolss.printercomment\", FT_STRING,\n\t\t    BASE_NONE, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_servername,\n\t\t  { \"Server name\", \"spoolss.servername\", FT_STRING, BASE_NONE,\n\t\t    NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_sharename,\n\t\t  { \"Share name\", \"spoolss.sharename\", FT_STRING, BASE_NONE,\n\t\t    NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_portname,\n\t\t  { \"Port name\", \"spoolss.portname\", FT_STRING, BASE_NONE,\n\t\t    NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_printerlocation,\n\t\t  { \"Printer location\", \"spoolss.printerlocation\", FT_STRING,\n\t\t    BASE_NONE, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_environment,\n\t\t  { \"Environment name\", \"spoolss.environment\", FT_STRING,\n\t\t    BASE_NONE, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_drivername,\n\t\t  { \"Driver name\", \"spoolss.drivername\", FT_STRING, BASE_NONE,\n\t\t    NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_username,\n\t\t  { \"User name\", \"spoolss.username\", FT_STRING, BASE_NONE,\n\t\t    NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_documentname,\n\t\t  { \"Document name\", \"spoolss.document\", FT_STRING, BASE_NONE,\n\t\t    NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_outputfile,\n\t\t  { \"Output file\", \"spoolss.outputfile\", FT_STRING, BASE_NONE,\n\t\t    NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_datatype,\n\t\t  { \"Datatype\", \"spoolss.datatype\", FT_STRING, BASE_NONE,\n\t\t    NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_textstatus,\n\t\t  { \"Text status\", \"spoolss.textstatus\", FT_STRING, BASE_NONE,\n\t\t    NULL, 0, NULL, HFILL }},\n\n \t\t{ &hf_sepfile,\n\t\t  { \"Separator file\", \"spoolss.setpfile\", FT_STRING, BASE_NONE,\n\t\t    NULL, 0, NULL, HFILL }},\n\n \t\t{ &hf_parameters,\n\t\t  { \"Parameters\", \"spoolss.parameters\", FT_STRING, BASE_NONE,\n\t\t    NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_printprocessor,\n\t\t  { \"Print processor\", \"spoolss.printprocessor\", FT_STRING,\n\t\t    BASE_NONE, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_vendor_setup,\n\t\t  { \"Vendor Setup\", \"spoolss.vendorsetup\", FT_STRING,\n\t\t    BASE_NONE, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_inf_path,\n\t\t  { \"Inf Path\", \"spoolss.infpath\", FT_STRING,\n\t\t    BASE_NONE, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_core_printer_driver_ids,\n\t\t  { \"Core Printer Driver IDs\", \"spoolss.core_printer_driver_ids\", FT_STRING,\n\t\t    BASE_NONE, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_core_driver_guid,\n\t\t  { \"Core Printer Driver GUID\", \"spoolss.core_driver_guid\", FT_GUID,\n\t\t    BASE_NONE, NULL, 0,\tNULL, HFILL }},\n\n\t\t{ &hf_core_driver_size,\n\t\t  { \"Core Printer Driver Size\", \"spoolss.core_driver_size\", FT_UINT32,\n\t\t    BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_core_printer_driver_count,\n\t\t  { \"Core Printer Driver Count\", \"spoolss.core_printer_driver_count\", FT_UINT32,\n\t\t    BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_package_id,\n\t\t  { \"PackageId\", \"spoolss.package_id\", FT_STRING,\n\t\t    BASE_NONE, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_language,\n\t\t  { \"Language name\", \"spoolss.language\", FT_STRING,\n\t\t    BASE_NONE, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_driver_package_cab_size,\n\t\t  { \"Driver Package Cabinet Size\", \"spoolss.driver_package_cab_size\", FT_UINT32,\n\t\t    BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t/* Printer data */\n\n\t\t{ &hf_printerdata,\n\t\t  { \"Data\", \"spoolss.printerdata\", FT_UINT32,\n\t\t    BASE_HEX, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_printerdata_key,\n\t\t  { \"Key\", \"spoolss.printerdata.key\", FT_STRING,\n\t\t    BASE_NONE, NULL, 0, \"Printer data key\", HFILL }},\n\n\t\t{ &hf_printerdata_value,\n\t\t  { \"Value\", \"spoolss.printerdata.value\",\n\t\t    FT_STRING, BASE_NONE, NULL, 0, \"Printer data value\",\n\t\t    HFILL }},\n\n\t\t{ &hf_printerdata_type,\n\t\t  { \"Type\", \"spoolss.printerdata.type\",\n\t\t    FT_UINT32, BASE_DEC|BASE_EXT_STRING, &reg_datatypes_ext, 0,\n\t\t    \"Printer data type\", HFILL }},\n\n\t\t{ &hf_printerdata_size,\n\t\t  { \"Size\", \"spoolss.printerdata.size\",\n\t\t    FT_UINT32, BASE_DEC, NULL, 0, \"Printer data size\",\n\t\t    HFILL }},\n\n\t\t{ &hf_printerdata_data,\n\t\t  { \"Data\", \"spoolss.printerdata.data\", FT_BYTES, BASE_NONE,\n\t\t    NULL, 0x0, \"Printer data\", HFILL }},\n\n\t\t{ &hf_printerdata_data_dword,\n\t\t  { \"DWORD data\", \"spoolss.printerdata.data.dword\",\n\t\t    FT_UINT32, BASE_HEX, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_printerdata_data_sz,\n\t\t  { \"String data\", \"spoolss.printerdata.data.sz\",\n\t\t    FT_STRING, BASE_NONE, NULL, 0, NULL,\n\t\t    HFILL }},\n\n\t\t/* Devicemode */\n\n\t\t{ &hf_devmodectr_size,\n\t\t  { \"Devicemode ctr size\", \"spoolss.devicemodectr.size\",\n\t\t    FT_UINT32, BASE_DEC, NULL, 0, NULL,\n\t\t    HFILL }},\n\n\t\t{ &hf_devmode,\n\t\t  { \"Devicemode\", \"spoolss.devmode\", FT_UINT32,\n\t\t    BASE_HEX, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_devmode_size,\n\t\t  { \"Size\", \"spoolss.devmode.size\",\n\t\t    FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_devmode_spec_version,\n\t\t  { \"Spec version\", \"spoolss.devmode.spec_version\",\n\t\t    FT_UINT16, BASE_DEC, VALS(devmode_specversion_vals),\n\t\t    0, NULL, HFILL }},\n\n\t\t{ &hf_devmode_driver_version,\n\t\t  { \"Driver version\", \"spoolss.devmode.driver_version\",\n\t\t    FT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_devmode_size2,\n\t\t  { \"Size2\", \"spoolss.devmode.size2\",\n\t\t    FT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_devmode_fields,\n\t\t  { \"Fields\", \"spoolss.devmode.fields\",\n\t\t    FT_UINT32, BASE_HEX, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_devmode_orientation,\n\t\t  { \"Orientation\", \"spoolss.devmode.orientation\",\n\t\t    FT_UINT16, BASE_DEC, VALS(devmode_orientation_vals),\n\t\t    0, NULL, HFILL }},\n\n\t\t{ &hf_devmode_paper_size,\n\t\t  { \"Paper size\", \"spoolss.devmode.paper_size\",\n\t\t    FT_UINT16, BASE_DEC|BASE_EXT_STRING, &devmode_papersize_vals_ext,\n\t\t    0, NULL, HFILL }},\n\n\t\t{ &hf_devmode_paper_width,\n\t\t  { \"Paper width\", \"spoolss.devmode.paper_width\",\n\t\t    FT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_devmode_paper_length,\n\t\t  { \"Paper length\", \"spoolss.devmode.paper_length\",\n\t\t    FT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_devmode_scale,\n\t\t  { \"Scale\", \"spoolss.devmode.scale\",\n\t\t    FT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_devmode_copies,\n\t\t  { \"Copies\", \"spoolss.devmode.copies\",\n\t\t    FT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_devmode_default_source,\n\t\t  { \"Default source\", \"spoolss.devmode.default_source\",\n\t\t    FT_UINT16, BASE_DEC|BASE_EXT_STRING, &devmode_papersource_vals_ext,\n\t\t    0, NULL, HFILL }},\n\n\t\t{ &hf_devmode_print_quality,\n\t\t  { \"Print quality\", \"spoolss.devmode.print_quality\",\n\t\t    FT_UINT16, BASE_DEC, VALS(devmode_printquality_vals),\n\t\t    0, NULL, HFILL }},\n\n\t\t{ &hf_devmode_color,\n\t\t  { \"Color\", \"spoolss.devmode.color\",\n\t\t    FT_UINT16, BASE_DEC, VALS(devmode_colour_vals), 0,\n\t\t    NULL, HFILL }},\n\n\t\t{ &hf_devmode_duplex,\n\t\t  { \"Duplex\", \"spoolss.devmode.duplex\",\n\t\t    FT_UINT16, BASE_DEC, VALS(devmode_duplex_vals), 0,\n\t\t    NULL, HFILL }},\n\n\t\t{ &hf_devmode_y_resolution,\n\t\t  { \"Y resolution\", \"spoolss.devmode.y_resolution\",\n\t\t    FT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_devmode_tt_option,\n\t\t  { \"TT option\", \"spoolss.devmode.tt_option\",\n\t\t    FT_UINT16, BASE_DEC, VALS(devmode_ttoption_vals), 0,\n\t\t    NULL, HFILL }},\n\n\t\t{ &hf_devmode_collate,\n\t\t  { \"Collate\", \"spoolss.devmode.collate\",\n\t\t    FT_UINT16, BASE_DEC, VALS(devmode_collate_vals), 0,\n\t\t    NULL, HFILL }},\n\n\t\t{ &hf_devmode_log_pixels,\n\t\t  { \"Log pixels\", \"spoolss.devmode.log_pixels\",\n\t\t    FT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_devmode_bits_per_pel,\n\t\t  { \"Bits per pel\", \"spoolss.devmode.bits_per_pel\",\n\t\t    FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_devmode_pels_width,\n\t\t  { \"Pels width\", \"spoolss.devmode.pels_width\",\n\t\t    FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_devmode_pels_height,\n\t\t  { \"Pels height\", \"spoolss.devmode.pels_height\",\n\t\t    FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_devmode_display_flags,\n\t\t  { \"Display flags\", \"spoolss.devmode.display_flags\",\n\t\t    FT_UINT32, BASE_DEC, VALS(devmode_displayflags_vals), 0,\n\t\t    NULL, HFILL }},\n\n\t\t{ &hf_devmode_display_freq,\n\t\t  { \"Display frequency\", \"spoolss.devmode.display_freq\",\n\t\t    FT_UINT32, BASE_DEC, NULL, 0, NULL,\n\t\t    HFILL }},\n\n\t\t{ &hf_devmode_icm_method,\n\t\t  { \"ICM method\", \"spoolss.devmode.icm_method\",\n\t\t    FT_UINT32, BASE_DEC, VALS(devmode_icmmethod_vals), 0,\n\t\t    NULL, HFILL }},\n\n\t\t{ &hf_devmode_icm_intent,\n\t\t  { \"ICM intent\", \"spoolss.devmode.icm_intent\",\n\t\t    FT_UINT32, BASE_DEC, VALS(devmode_icmintent_vals), 0,\n\t\t    NULL, HFILL }},\n\n\t\t{ &hf_devmode_media_type,\n\t\t  { \"Media type\", \"spoolss.devmode.media_type\",\n\t\t    FT_UINT32, BASE_DEC, VALS(devmode_mediatype_vals), 0,\n\t\t    NULL, HFILL }},\n\n\t\t{ &hf_devmode_dither_type,\n\t\t  { \"Dither type\", \"spoolss.devmode.dither_type\",\n\t\t    FT_UINT32, BASE_DEC, VALS(devmode_dithertype_vals), 0,\n\t\t    NULL, HFILL }},\n\n\t\t{ &hf_devmode_reserved1,\n\t\t  { \"Reserved1\", \"spoolss.devmode.reserved1\",\n\t\t    FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_devmode_reserved2,\n\t\t  { \"Reserved2\", \"spoolss.devmode.reserved2\",\n\t\t    FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_devmode_panning_width,\n\t\t  { \"Panning width\", \"spoolss.devmode.panning_width\",\n\t\t    FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_devmode_panning_height,\n\t\t  { \"Panning height\", \"spoolss.devmode.panning_height\",\n\t\t    FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_devmode_driver_extra_len,\n\t\t  { \"Driver extra length\",\n\t\t    \"spoolss.devmode.driver_extra_len\",\n\t\t    FT_UINT32, BASE_DEC, NULL, 0, NULL,\n\t\t    HFILL }},\n\n\t\t{ &hf_devmode_driver_extra,\n\t\t  { \"Driver extra\", \"spoolss.devmode.driver_extra\",\n\t\t    FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL }},\n\n\t\t/* Devicemode fields */\n\n\t\t{ &hf_devmode_fields_orientation,\n\t\t  { \"Orientation\", \"spoolss.devmode.fields.orientation\",\n\t\t    FT_BOOLEAN, 32, TFS(&tfs_set_notset),\n\t\t    DEVMODE_ORIENTATION, NULL, HFILL }},\n\n\t\t{ &hf_devmode_fields_papersize,\n\t\t  { \"Paper size\", \"spoolss.devmode.fields.paper_size\",\n\t\t    FT_BOOLEAN, 32, TFS(&tfs_set_notset),\n\t\t    DEVMODE_PAPERSIZE, NULL, HFILL }},\n\n\t\t{ &hf_devmode_fields_paperlength,\n\t\t  { \"Paper length\", \"spoolss.devmode.fields.paper_length\",\n\t\t    FT_BOOLEAN, 32, TFS(&tfs_set_notset),\n\t\t    DEVMODE_PAPERLENGTH, NULL, HFILL }},\n\n\t\t{ &hf_devmode_fields_paperwidth,\n\t\t  { \"Paper width\", \"spoolss.devmode.fields.paper_width\",\n\t\t    FT_BOOLEAN, 32, TFS(&tfs_set_notset),\n\t\t    DEVMODE_PAPERWIDTH, NULL, HFILL }},\n\n\t\t{ &hf_devmode_fields_scale,\n\t\t  { \"Scale\", \"spoolss.devmode.fields.scale\",\n\t\t    FT_BOOLEAN, 32, TFS(&tfs_set_notset),\n\t\t    DEVMODE_SCALE, NULL, HFILL }},\n\n\t\t{ &hf_devmode_fields_position,\n\t\t  { \"Position\", \"spoolss.devmode.fields.position\",\n\t\t    FT_BOOLEAN, 32, TFS(&tfs_set_notset),\n\t\t    DEVMODE_POSITION, NULL, HFILL }},\n\n\t\t{ &hf_devmode_fields_nup,\n\t\t  { \"N-up\", \"spoolss.devmode.fields.nup\",\n\t\t    FT_BOOLEAN, 32, TFS(&tfs_set_notset),\n\t\t    DEVMODE_NUP, NULL, HFILL }},\n\n\t\t{ &hf_devmode_fields_copies,\n\t\t  { \"Copies\", \"spoolss.devmode.fields.copies\",\n\t\t    FT_BOOLEAN, 32, TFS(&tfs_set_notset),\n\t\t    DEVMODE_COPIES, NULL, HFILL }},\n\n\t\t{ &hf_devmode_fields_defaultsource,\n\t\t  { \"Default source\", \"spoolss.devmode.fields.default_source\",\n\t\t    FT_BOOLEAN, 32, TFS(&tfs_set_notset),\n\t\t    DEVMODE_DEFAULTSOURCE, NULL, HFILL }},\n\n\t\t{ &hf_devmode_fields_printquality,\n\t\t  { \"Print quality\", \"spoolss.devmode.fields.print_quality\",\n\t\t    FT_BOOLEAN, 32, TFS(&tfs_set_notset),\n\t\t    DEVMODE_PRINTQUALITY, NULL, HFILL }},\n\n\t\t{ &hf_devmode_fields_color,\n\t\t  { \"Color\", \"spoolss.devmode.fields.color\",\n\t\t    FT_BOOLEAN, 32, TFS(&tfs_set_notset),\n\t\t    DEVMODE_COLOR, NULL, HFILL }},\n\n\t\t{ &hf_devmode_fields_duplex,\n\t\t  { \"Duplex\", \"spoolss.devmode.fields.duplex\",\n\t\t    FT_BOOLEAN, 32, TFS(&tfs_set_notset),\n\t\t    DEVMODE_DUPLEX, NULL, HFILL }},\n\n\t\t{ &hf_devmode_fields_yresolution,\n\t\t  { \"Y resolution\", \"spoolss.devmode.fields.y_resolution\",\n\t\t    FT_BOOLEAN, 32, TFS(&tfs_set_notset),\n\t\t    DEVMODE_YRESOLUTION, NULL, HFILL }},\n\n\t\t{ &hf_devmode_fields_ttoption,\n\t\t  { \"TT option\", \"spoolss.devmode.fields.tt_option\",\n\t\t    FT_BOOLEAN, 32, TFS(&tfs_set_notset),\n\t\t    DEVMODE_TTOPTION, NULL, HFILL }},\n\n\t\t{ &hf_devmode_fields_collate,\n\t\t  { \"Collate\", \"spoolss.devmode.fields.collate\",\n\t\t    FT_BOOLEAN, 32, TFS(&tfs_set_notset),\n\t\t    DEVMODE_COLLATE, NULL, HFILL }},\n\n\t\t{ &hf_devmode_fields_formname,\n\t\t  { \"Form name\", \"spoolss.devmode.fields.form_name\",\n\t\t    FT_BOOLEAN, 32, TFS(&tfs_set_notset),\n\t\t    DEVMODE_FORMNAME, NULL, HFILL }},\n\n\t\t{ &hf_devmode_fields_logpixels,\n\t\t  { \"Log pixels\", \"spoolss.devmode.fields.log_pixels\",\n\t\t    FT_BOOLEAN, 32, TFS(&tfs_set_notset),\n\t\t    DEVMODE_LOGPIXELS, NULL, HFILL }},\n\n\t\t{ &hf_devmode_fields_bitsperpel,\n\t\t  { \"Bits per pel\", \"spoolss.devmode.fields.bits_per_pel\",\n\t\t    FT_BOOLEAN, 32, TFS(&tfs_set_notset),\n\t\t    DEVMODE_BITSPERPEL, NULL, HFILL }},\n\n\t\t{ &hf_devmode_fields_pelswidth,\n\t\t  { \"Pels width\", \"spoolss.devmode.fields.pels_width\",\n\t\t    FT_BOOLEAN, 32, TFS(&tfs_set_notset),\n\t\t    DEVMODE_PELSWIDTH, NULL, HFILL }},\n\n\t\t{ &hf_devmode_fields_pelsheight,\n\t\t  { \"Pels height\", \"spoolss.devmode.fields.pels_height\",\n\t\t    FT_BOOLEAN, 32, TFS(&tfs_set_notset),\n\t\t    DEVMODE_PELSHEIGHT, NULL, HFILL }},\n\n\t\t{ &hf_devmode_fields_displayflags,\n\t\t  { \"Display flags\", \"spoolss.devmode.fields.display_flags\",\n\t\t    FT_BOOLEAN, 32, TFS(&tfs_set_notset),\n\t\t    DEVMODE_DISPLAYFLAGS, NULL, HFILL }},\n\n\t\t{ &hf_devmode_fields_displayfrequency,\n\t\t  { \"Display frequency\",\n\t\t    \"spoolss.devmode.fields.display_frequency\",\n\t\t    FT_BOOLEAN, 32, TFS(&tfs_set_notset),\n\t\t    DEVMODE_DISPLAYFREQUENCY, NULL, HFILL }},\n\n\t\t{ &hf_devmode_fields_icmmethod,\n\t\t  { \"ICM method\", \"spoolss.devmode.fields.icm_method\",\n\t\t    FT_BOOLEAN, 32, TFS(&tfs_set_notset),\n\t\t    DEVMODE_ICMMETHOD, NULL, HFILL }},\n\n\t\t{ &hf_devmode_fields_icmintent,\n\t\t  { \"ICM intent\", \"spoolss.devmode.fields.icm_intent\",\n\t\t    FT_BOOLEAN, 32, TFS(&tfs_set_notset),\n\t\t    DEVMODE_ICMINTENT, NULL, HFILL }},\n\n\t\t{ &hf_devmode_fields_mediatype,\n\t\t  { \"Media type\", \"spoolss.devmode.fields.media_type\",\n\t\t    FT_BOOLEAN, 32, TFS(&tfs_set_notset),\n\t\t    DEVMODE_MEDIATYPE, NULL, HFILL }},\n\n\t\t{ &hf_devmode_fields_dithertype,\n\t\t  { \"Dither type\", \"spoolss.devmode.fields.dither_type\",\n\t\t    FT_BOOLEAN, 32, TFS(&tfs_set_notset),\n\t\t    DEVMODE_DITHERTYPE, NULL, HFILL }},\n\n\t\t{ &hf_devmode_fields_panningwidth,\n\t\t  { \"Panning width\", \"spoolss.devmode.fields.panning_width\",\n\t\t    FT_BOOLEAN, 32, TFS(&tfs_set_notset),\n\t\t    DEVMODE_PANNINGWIDTH, NULL, HFILL }},\n\n\t\t{ &hf_devmode_fields_panningheight,\n\t\t  { \"Panning height\", \"spoolss.devmode.fields.panning_height\",\n\t\t    FT_BOOLEAN, 32, TFS(&tfs_set_notset),\n\t\t    DEVMODE_PANNINGHEIGHT, NULL, HFILL }},\n\n\t\t/* EnumPrinterData RPC */\n\n\t\t{ &hf_enumprinterdata_enumindex,\n\t\t  { \"Enum index\", \"spoolss.enumprinterdata.enumindex\",\n\t\t    FT_UINT32, BASE_DEC, NULL, 0x0,\n\t\t    \"Index for start of enumeration\", HFILL }},\n\n\t\t{ &hf_enumprinterdata_value_offered,\n\t\t  { \"Value size offered\",\n\t\t    \"spoolss.enumprinterdata.value_offered\", FT_UINT32,\n\t\t    BASE_DEC, NULL, 0x0,\n\t\t    \"Buffer size offered for printerdata value\", HFILL }},\n\n\t\t{ &hf_enumprinterdata_data_offered,\n\t\t  { \"Data size offered\",\n\t\t    \"spoolss.enumprinterdata.data_offered\", FT_UINT32,\n\t\t    BASE_DEC, NULL, 0x0,\n\t\t    \"Buffer size offered for printerdata data\", HFILL }},\n\n\t\t{ &hf_enumprinterdata_value_len,\n\t\t  { \"Value length\",\n\t\t    \"spoolss.enumprinterdata.value_len\", FT_UINT32,\n\t\t    BASE_DEC, NULL, 0x0,\n\t\t    \"Size of printerdata value\", HFILL }},\n\n\t\t{ &hf_enumprinterdata_value_needed,\n\t\t  { \"Value size needed\",\n\t\t    \"spoolss.enumprinterdata.value_needed\", FT_UINT32,\n\t\t    BASE_DEC, NULL, 0x0,\n\t\t    \"Buffer size needed for printerdata value\", HFILL }},\n\n\t\t{ &hf_enumprinterdata_data_needed,\n\t\t  { \"Data size needed\",\n\t\t    \"spoolss.enumprinterdata.data_needed\", FT_UINT32, BASE_DEC,\n\t\t    NULL, 0x0, \"Buffer size needed for printerdata data\",\n\t\t    HFILL }},\n\n\t\t/* Print jobs */\n\n\t\t{ &hf_job_id,\n\t\t  { \"Job ID\", \"spoolss.job.id\", FT_UINT32, BASE_DEC,\n\t\t    NULL, 0x0, \"Job identification number\", HFILL }},\n\n\t\t{ &hf_job_status,\n\t\t  { \"Job status\", \"spoolss.job.status\", FT_UINT32, BASE_DEC,\n\t\t    NULL, 0x0, NULL, HFILL }},\n\n\t\t{ &hf_job_status_paused,\n\t\t  { \"Paused\", \"spoolss.job.status.paused\", FT_BOOLEAN, 32,\n\t\t    TFS(&tfs_job_status_paused), JOB_STATUS_PAUSED,\n\t\t    NULL, HFILL }},\n\n\t\t{ &hf_job_status_error,\n\t\t  { \"Error\", \"spoolss.job.status.error\", FT_BOOLEAN, 32,\n\t\t    TFS(&tfs_job_status_error), JOB_STATUS_ERROR,\n\t\t    NULL, HFILL }},\n\n\t\t{ &hf_job_status_deleting,\n\t\t  { \"Deleting\", \"spoolss.job.status.deleting\", FT_BOOLEAN, 32,\n\t\t    TFS(&tfs_job_status_deleting), JOB_STATUS_DELETING,\n\t\t    NULL, HFILL }},\n\n\t\t{ &hf_job_status_spooling,\n\t\t  { \"Spooling\", \"spoolss.job.status.spooling\", FT_BOOLEAN, 32,\n\t\t    TFS(&tfs_job_status_spooling), JOB_STATUS_SPOOLING,\n\t\t    NULL, HFILL }},\n\n\t\t{ &hf_job_status_printing,\n\t\t  { \"Printing\", \"spoolss.job.status.printing\", FT_BOOLEAN, 32,\n\t\t    TFS(&tfs_job_status_printing), JOB_STATUS_PRINTING,\n\t\t    NULL, HFILL }},\n\n\t\t{ &hf_job_status_offline,\n\t\t  { \"Offline\", \"spoolss.job.status.offline\", FT_BOOLEAN, 32,\n\t\t    TFS(&tfs_job_status_offline), JOB_STATUS_OFFLINE,\n\t\t    NULL, HFILL }},\n\n\t\t{ &hf_job_status_paperout,\n\t\t  { \"Paperout\", \"spoolss.job.status.paperout\", FT_BOOLEAN, 32,\n\t\t    TFS(&tfs_job_status_paperout), JOB_STATUS_PAPEROUT,\n\t\t    NULL, HFILL }},\n\n\t\t{ &hf_job_status_printed,\n\t\t  { \"Printed\", \"spoolss.job.status.printed\", FT_BOOLEAN, 32,\n\t\t    TFS(&tfs_job_status_printed), JOB_STATUS_PRINTED,\n\t\t    NULL, HFILL }},\n\n\t\t{ &hf_job_status_deleted,\n\t\t  { \"Deleted\", \"spoolss.job.status.deleted\", FT_BOOLEAN, 32,\n\t\t    TFS(&tfs_job_status_deleted), JOB_STATUS_DELETED,\n\t\t    NULL, HFILL }},\n\n\t\t{ &hf_job_status_blocked,\n\t\t  { \"Blocked\", \"spoolss.job.status.blocked\", FT_BOOLEAN, 32,\n\t\t    TFS(&tfs_job_status_blocked), JOB_STATUS_BLOCKED,\n\t\t    NULL, HFILL }},\n\n\t\t{ &hf_job_status_user_intervention,\n\t\t  { \"User intervention\",\n\t\t    \"spoolss.job.status.user_intervention\", FT_BOOLEAN, 32,\n\t\t    TFS(&tfs_job_status_user_intervention),\n\t\t    JOB_STATUS_USER_INTERVENTION, NULL,\n\t\t    HFILL }},\n\n\t\t{ &hf_job_priority,\n\t\t  { \"Job priority\", \"spoolss.job.priority\", FT_UINT32,\n\t\t    BASE_DEC, NULL, 0x0, NULL, HFILL }},\n\n\t\t{ &hf_job_position,\n\t\t  { \"Job position\", \"spoolss.job.position\", FT_UINT32,\n\t\t    BASE_DEC, NULL, 0x0, NULL, HFILL }},\n\n\t\t{ &hf_job_totalpages,\n\t\t  { \"Job total pages\", \"spoolss.job.totalpages\", FT_UINT32,\n\t\t    BASE_DEC, NULL, 0x0, NULL, HFILL }},\n\n\t\t{ &hf_job_totalbytes,\n\t\t  { \"Job total bytes\", \"spoolss.job.totalbytes\", FT_UINT32,\n\t\t    BASE_DEC, NULL, 0x0, NULL, HFILL }},\n\n\t\t{ &hf_job_bytesprinted,\n\t\t  { \"Job bytes printed\", \"spoolss.job.bytesprinted\",\n\t\t    FT_UINT32, BASE_DEC, NULL, 0x0, NULL,\n\t\t    HFILL }},\n\n\t\t{ &hf_job_pagesprinted,\n\t\t  { \"Job pages printed\", \"spoolss.job.pagesprinted\",\n\t\t    FT_UINT32, BASE_DEC, NULL, 0x0, NULL,\n\t\t    HFILL }},\n\n\t\t{ &hf_job_size,\n\t\t  { \"Job size\", \"spoolss.job.size\", FT_UINT32, BASE_DEC,\n\t\t    NULL, 0x0, NULL, HFILL }},\n\n\t\t/* Forms */\n\n\t\t{ &hf_form,\n\t\t  { \"Data\", \"spoolss.form\", FT_UINT32,\n\t\t    BASE_HEX, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_form_level,\n\t\t  { \"Level\", \"spoolss.form.level\", FT_UINT32,\n\t\t    BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_form_name,\n\t\t  { \"Name\", \"spoolss.form.name\", FT_STRING, BASE_NONE,\n\t\t    NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_form_flags,\n\t\t  { \"Flags\", \"spoolss.form.flags\", FT_UINT32,\n\t\t    BASE_DEC, VALS(form_type_vals), 0, NULL, HFILL }},\n\n\t\t{ &hf_form_unknown,\n\t\t  { \"Unknown\", \"spoolss.form.unknown\", FT_UINT32,\n\t\t    BASE_HEX, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_form_width,\n\t\t  { \"Width\", \"spoolss.form.width\", FT_UINT32,\n\t\t    BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_form_height,\n\t\t  { \"Height\", \"spoolss.form.height\", FT_UINT32,\n\t\t    BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_form_left_margin,\n\t\t  { \"Left margin\", \"spoolss.form.left\", FT_UINT32,\n\t\t    BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_form_top_margin,\n\t\t  { \"Top\", \"spoolss.form.top\", FT_UINT32,\n\t\t    BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_form_horiz_len,\n\t\t  { \"Horizontal\", \"spoolss.form.horiz\", FT_UINT32,\n\t\t    BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_form_vert_len,\n\t\t  { \"Vertical\", \"spoolss.form.vert\", FT_UINT32,\n\t\t    BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_enumforms_num,\n\t\t  { \"Num\", \"spoolss.enumforms.num\", FT_UINT32,\n\t\t    BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t/* Print notify */\n\n\t\t{ &hf_notify_options_version,\n\t\t  { \"Version\", \"spoolss.notify_options.version\", FT_UINT32,\n\t\t    BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_notify_options_flags,\n\t\t  { \"Flags\", \"spoolss.notify_options.flags\", FT_UINT32,\n\t\t    BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_notify_options_count,\n\t\t  { \"Count\", \"spoolss.notify_options.count\", FT_UINT32,\n\t\t    BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_notify_option_type,\n\t\t  { \"Type\", \"spoolss.notify_option.type\", FT_UINT16, BASE_DEC,\n\t\t    VALS(printer_notify_types), 0, NULL, HFILL }},\n\n\t\t{ &hf_notify_option_reserved1,\n\t\t  { \"Reserved1\", \"spoolss.notify_option.reserved1\", FT_UINT16,\n\t\t    BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_notify_option_reserved2,\n\t\t  { \"Reserved2\", \"spoolss.notify_option.reserved2\", FT_UINT32,\n\t\t    BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_notify_option_reserved3,\n\t\t  { \"Reserved3\", \"spoolss.notify_option.reserved3\", FT_UINT32,\n\t\t    BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_notify_option_count,\n\t\t  { \"Count\", \"spoolss.notify_option.count\", FT_UINT32,\n\t\t    BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_notify_option_data_count,\n\t\t  { \"Count\", \"spoolss.notify_option_data.count\", FT_UINT32,\n\t\t    BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_notify_options_flags_refresh,\n\t\t  { \"Refresh\", \"spoolss.notify_options.flags.refresh\", FT_BOOLEAN, 32,\n\t\t    TFS(&tfs_notify_options_flags_refresh),\n\t\t    PRINTER_NOTIFY_OPTIONS_REFRESH, NULL, HFILL }},\n\n\t\t{ &hf_notify_info_count,\n\t\t  { \"Count\", \"spoolss.notify_info.count\", FT_UINT32, BASE_DEC,\n\t\t    NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_notify_info_version,\n\t\t  { \"Version\", \"spoolss.notify_info.version\", FT_UINT32,\n\t\t    BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_notify_info_flags,\n\t\t  { \"Flags\", \"spoolss.notify_info.flags\", FT_UINT32, BASE_HEX,\n\t\t    NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_notify_info_data_type,\n\t\t  { \"Type\", \"spoolss.notify_info_data.type\", FT_UINT16,\n\t\t    BASE_DEC, VALS(printer_notify_types), 0, NULL, HFILL }},\n\n\t\t{ &hf_notify_field,\n\t\t  { \"Field\", \"spoolss.notify_field\", FT_UINT16, BASE_DEC,\n\t\t    NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_notify_info_data_count,\n\t\t  { \"Count\", \"spoolss.notify_info_data.count\", FT_UINT32,\n\t\t    BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_notify_info_data_id,\n\t\t  { \"Job Id\", \"spoolss.notify_info_data.jobid\", FT_UINT32,\n\t\t    BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_notify_info_data_value1,\n\t\t  { \"Value1\", \"spoolss.notify_info_data.value1\", FT_UINT32,\n\t\t    BASE_HEX, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_notify_info_data_value2,\n\t\t  { \"Value2\", \"spoolss.notify_info_data.value2\", FT_UINT32,\n\t\t    BASE_HEX, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_notify_info_data_bufsize,\n\t\t  { \"Buffer size\", \"spoolss.notify_info_data.bufsize\",\n\t\t    FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_notify_info_data_buffer,\n\t\t  { \"Buffer\", \"spoolss.notify_info_data.buffer\", FT_UINT32,\n\t\t    BASE_HEX, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_notify_info_data_buffer_len,\n\t\t  { \"Buffer length\", \"spoolss.notify_info_data.buffer.len\",\n\t\t    FT_UINT32, BASE_HEX, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_notify_info_data_buffer_data,\n\t\t  { \"Buffer data\", \"spoolss.notify_info_data.buffer.data\",\n\t\t    FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL }},\n\n\t\t/* RffpCNex RPC */\n\n\t\t{ &hf_rffpcnex_options,\n\t\t  { \"Options\", \"spoolss.rffpcnex.options\", FT_UINT32, BASE_DEC,\n\t\t    NULL, 0, \"RFFPCNEX options\", HFILL }},\n\n\t\t{ &hf_printerlocal, /* XXX: move me */\n\t\t  { \"Printer local\", \"spoolss.printer_local\", FT_UINT32,\n\t\t    BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_rffpcnex_flags,\n\t\t  { \"RFFPCNEX flags\", \"spoolss.rffpcnex.flags\", FT_UINT32,\n\t\t    BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_rffpcnex_flags_add_printer,\n\t\t  { \"Add printer\", \"spoolss.rffpcnex.flags.add_printer\",\n\t\t    FT_BOOLEAN, 32, TFS(&tfs_rffpcnex_flags_add_printer),\n\t\t    SPOOLSS_PRINTER_CHANGE_ADD_PRINTER, NULL,\n\t\t    HFILL }},\n\n\t\t{ &hf_rffpcnex_flags_set_printer,\n\t\t  { \"Set printer\", \"spoolss.rffpcnex.flags.set_printer\",\n\t\t    FT_BOOLEAN, 32, TFS(&tfs_rffpcnex_flags_set_printer),\n\t\t    SPOOLSS_PRINTER_CHANGE_SET_PRINTER, NULL,\n\t\t    HFILL }},\n\n\t\t{ &hf_rffpcnex_flags_delete_printer,\n\t\t  { \"Delete printer\", \"spoolss.rffpcnex.flags.delete_printer\",\n\t\t    FT_BOOLEAN, 32, TFS(&tfs_rffpcnex_flags_delete_printer),\n\t\t    SPOOLSS_PRINTER_CHANGE_DELETE_PRINTER, NULL,\n\t\t    HFILL }},\n\n\t\t{ &hf_rffpcnex_flags_add_job,\n\t\t  { \"Add job\", \"spoolss.rffpcnex.flags.add_job\",\n\t\t    FT_BOOLEAN, 32, TFS(&tfs_rffpcnex_flags_add_job),\n\t\t    SPOOLSS_PRINTER_CHANGE_ADD_JOB, NULL, HFILL }},\n\n\t\t{ &hf_rffpcnex_flags_set_job,\n\t\t  { \"Set job\", \"spoolss.rffpcnex.flags.set_job\",\n\t\t    FT_BOOLEAN, 32, TFS(&tfs_rffpcnex_flags_set_job),\n\t\t    SPOOLSS_PRINTER_CHANGE_SET_JOB, NULL, HFILL }},\n\n\t\t{ &hf_rffpcnex_flags_delete_job,\n\t\t  { \"Delete job\", \"spoolss.rffpcnex.flags.delete_job\",\n\t\t    FT_BOOLEAN, 32, TFS(&tfs_rffpcnex_flags_delete_job),\n\t\t    SPOOLSS_PRINTER_CHANGE_DELETE_JOB, NULL, HFILL }},\n\n\t\t{ &hf_rffpcnex_flags_write_job,\n\t\t  { \"Write job\", \"spoolss.rffpcnex.flags.write_job\",\n\t\t    FT_BOOLEAN, 32, TFS(&tfs_rffpcnex_flags_write_job),\n\t\t    SPOOLSS_PRINTER_CHANGE_WRITE_JOB, NULL, HFILL }},\n\n\t\t{ &hf_rffpcnex_flags_add_form,\n\t\t  { \"Add form\", \"spoolss.rffpcnex.flags.add_form\",\n\t\t    FT_BOOLEAN, 32, TFS(&tfs_rffpcnex_flags_add_form),\n\t\t    SPOOLSS_PRINTER_CHANGE_ADD_FORM, NULL, HFILL }},\n\n\t\t{ &hf_rffpcnex_flags_set_form,\n\t\t  { \"Set form\", \"spoolss.rffpcnex.flags.set_form\",\n\t\t    FT_BOOLEAN, 32, TFS(&tfs_rffpcnex_flags_set_form),\n\t\t    SPOOLSS_PRINTER_CHANGE_SET_FORM, NULL, HFILL }},\n\n\t\t{ &hf_rffpcnex_flags_delete_form,\n\t\t  { \"Delete form\", \"spoolss.rffpcnex.flags.delete_form\",\n\t\t    FT_BOOLEAN, 32, TFS(&tfs_rffpcnex_flags_delete_form),\n\t\t    SPOOLSS_PRINTER_CHANGE_DELETE_FORM, NULL,\n\t\t    HFILL }},\n\n\t\t{ &hf_rffpcnex_flags_add_port,\n\t\t  { \"Add port\", \"spoolss.rffpcnex.flags.add_port\",\n\t\t    FT_BOOLEAN, 32, TFS(&tfs_rffpcnex_flags_add_port),\n\t\t    SPOOLSS_PRINTER_CHANGE_ADD_PORT, NULL, HFILL }},\n\n\t\t{ &hf_rffpcnex_flags_configure_port,\n\t\t  { \"Configure port\", \"spoolss.rffpcnex.flags.configure_port\",\n\t\t    FT_BOOLEAN, 32, TFS(&tfs_rffpcnex_flags_configure_port),\n\t\t    SPOOLSS_PRINTER_CHANGE_CONFIGURE_PORT, NULL,\n\t\t    HFILL }},\n\n\t\t{ &hf_rffpcnex_flags_delete_port,\n\t\t  { \"Delete port\", \"spoolss.rffpcnex.flags.delete_port\",\n\t\t    FT_BOOLEAN, 32, TFS(&tfs_rffpcnex_flags_delete_port),\n\t\t    SPOOLSS_PRINTER_CHANGE_DELETE_PORT, NULL,\n\t\t    HFILL }},\n\n\t\t{ &hf_rffpcnex_flags_add_print_processor,\n\t\t  { \"Add processor\", \"spoolss.rffpcnex.flags.add_processor\",\n\t\t    FT_BOOLEAN, 32,\n\t\t    TFS(&tfs_rffpcnex_flags_add_print_processor),\n\t\t    SPOOLSS_PRINTER_CHANGE_ADD_PRINT_PROCESSOR,\n\t\t    NULL, HFILL }},\n\n\t\t{ &hf_rffpcnex_flags_delete_print_processor,\n\t\t  { \"Delete processor\",\n\t\t    \"spoolss.rffpcnex.flags.delete_processor\", FT_BOOLEAN, 32,\n\t\t    TFS(&tfs_rffpcnex_flags_delete_print_processor),\n\t\t    SPOOLSS_PRINTER_CHANGE_DELETE_PRINT_PROCESSOR,\n\t\t    NULL, HFILL }},\n\n\t\t{ &hf_rffpcnex_flags_add_driver,\n\t\t  { \"Add driver\", \"spoolss.rffpcnex.flags.add_driver\",\n\t\t    FT_BOOLEAN, 32, TFS(&tfs_rffpcnex_flags_add_driver),\n\t\t    SPOOLSS_PRINTER_CHANGE_ADD_PRINTER_DRIVER, NULL,\n\t\t    HFILL }},\n\n\t\t{ &hf_rffpcnex_flags_set_driver,\n\t\t  { \"Set driver\", \"spoolss.rffpcnex.flags.set_driver\",\n\t\t    FT_BOOLEAN, 32, TFS(&tfs_rffpcnex_flags_set_driver),\n\t\t    SPOOLSS_PRINTER_CHANGE_SET_PRINTER_DRIVER, NULL,\n\t\t    HFILL }},\n\n\t\t{ &hf_rffpcnex_flags_delete_driver,\n\t\t  { \"Delete driver\", \"spoolss.rffpcnex.flags.delete_driver\",\n\t\t    FT_BOOLEAN, 32, TFS(&tfs_rffpcnex_flags_delete_driver),\n\t\t    SPOOLSS_PRINTER_CHANGE_DELETE_PRINTER_DRIVER,\n\t\t    NULL, HFILL }},\n\n\t\t{ &hf_rffpcnex_flags_timeout,\n\t\t  { \"Timeout\", \"spoolss.rffpcnex.flags.timeout\",\n\t\t    FT_BOOLEAN, 32, TFS(&tfs_rffpcnex_flags_timeout),\n\t\t    SPOOLSS_PRINTER_CHANGE_TIMEOUT, NULL, HFILL }},\n\n\t\t{ &hf_rffpcnex_flags_failed_printer_connection,\n\t\t  { \"Failed printer connection\",\n\t\t    \"spoolss.rffpcnex.flags.failed_connection_printer\",\n\t\t    FT_BOOLEAN, 32,\n\t\t    TFS(&tfs_rffpcnex_flags_failed_connection_printer),\n\t\t    SPOOLSS_PRINTER_CHANGE_FAILED_CONNECTION_PRINTER,\n\t\t    NULL, HFILL }},\n\n\t\t/* RRPCN RPC */\n\n\t\t{ &hf_rrpcn_changelow,\n\t\t  { \"Change low\", \"spoolss.rrpcn.changelow\", FT_UINT32,\n\t\t    BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_rrpcn_changehigh,\n\t\t  { \"Change high\", \"spoolss.rrpcn.changehigh\", FT_UINT32,\n\t\t    BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_rrpcn_unk0,\n\t\t  { \"Unknown 0\", \"spoolss.rrpcn.unk0\", FT_UINT32, BASE_DEC,\n\t\t    NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_rrpcn_unk1,\n\t\t  { \"Unknown 1\", \"spoolss.rrpcn.unk1\", FT_UINT32, BASE_DEC,\n\t\t    NULL, 0, NULL, HFILL }},\n\n\t\t/* ReplyOpenPrinter RPC */\n\n\t\t{ &hf_replyopenprinter_unk0,\n\t\t  { \"Unknown 0\", \"spoolss.replyopenprinter.unk0\", FT_UINT32,\n\t\t    BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_replyopenprinter_unk1,\n\t\t  { \"Unknown 1\", \"spoolss.replyopenprinter.unk1\", FT_UINT32,\n\t\t    BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_devmode_devicename,\n\t\t  { \"DeviceName\", \"spoolss.devmode.devicename\", FT_STRING,\n\t\t    BASE_NONE, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_devmode_form_name,\n\t\t  { \"FormName\", \"spoolss.devmode.form_name\", FT_STRING,\n\t\t    BASE_NONE, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_relative_string,\n\t\t  { \"String\", \"spoolss.relative_string\", FT_STRING,\n\t\t    BASE_NONE, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_value_name,\n\t\t  { \"Value Name\", \"spoolss.value_name\", FT_STRING,\n\t\t    BASE_NONE, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_keybuffer,\n\t\t  { \"Key\", \"spoolss.hf_keybuffer\", FT_STRING,\n\t\t    BASE_NONE, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_value_string,\n\t\t  { \"Value\", \"spoolss.value_string\", FT_STRING,\n\t\t    BASE_NONE, NULL, 0, NULL, HFILL }},\n\n\t\t/* Printer attributes */\n\n\t\t{ &hf_printer_attributes,\n\t\t  { \"Attributes\", \"spoolss.printer_attributes\", FT_UINT32,\n\t\t    BASE_HEX, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_printer_attributes_queued,\n\t\t  { \"Queued\", \"spoolss.printer_attributes.queued\", FT_BOOLEAN,\n\t\t    32, TFS(&tfs_printer_attributes_queued),\n\t\t    PRINTER_ATTRIBUTE_QUEUED, NULL, HFILL }},\n\n\t\t{ &hf_printer_attributes_direct,\n\t\t  { \"Direct\", \"spoolss.printer_attributes.direct\", FT_BOOLEAN,\n\t\t    32, TFS(&tfs_printer_attributes_direct),\n\t\t    PRINTER_ATTRIBUTE_DIRECT, NULL, HFILL }},\n\n\t\t{ &hf_printer_attributes_default,\n\t\t  { \"Default (9x/ME only)\",\n\t\t    \"spoolss.printer_attributes.default\",FT_BOOLEAN,\n\t\t    32, TFS(&tfs_printer_attributes_default),\n\t\t    PRINTER_ATTRIBUTE_DEFAULT, NULL, HFILL }},\n\n\t\t{ &hf_printer_attributes_shared,\n\t\t  { \"Shared\", \"spoolss.printer_attributes.shared\", FT_BOOLEAN,\n\t\t    32, TFS(&tfs_printer_attributes_shared),\n\t\t    PRINTER_ATTRIBUTE_SHARED, NULL, HFILL }},\n\n\t\t{ &hf_printer_attributes_network,\n\t\t  { \"Network\", \"spoolss.printer_attributes.network\",\n\t\t    FT_BOOLEAN, 32, TFS(&tfs_printer_attributes_network),\n\t\t    PRINTER_ATTRIBUTE_NETWORK, NULL, HFILL }},\n\n\t\t{ &hf_printer_attributes_hidden,\n\t\t  { \"Hidden\", \"spoolss.printer_attributes.hidden\", FT_BOOLEAN,\n\t\t    32, TFS(&tfs_printer_attributes_hidden),\n\t\t    PRINTER_ATTRIBUTE_HIDDEN, NULL, HFILL }},\n\n\t\t{ &hf_printer_attributes_local,\n\t\t  { \"Local\", \"spoolss.printer_attributes.local\", FT_BOOLEAN,\n\t\t    32, TFS(&tfs_printer_attributes_local),\n\t\t    PRINTER_ATTRIBUTE_LOCAL, NULL, HFILL }},\n\n\t\t{ &hf_printer_attributes_enable_devq,\n\t\t  { \"Enable devq\", \"spoolss.printer_attributes.enable_devq\",\n\t\t    FT_BOOLEAN, 32, TFS(&tfs_printer_attributes_enable_devq),\n\t\t    PRINTER_ATTRIBUTE_ENABLE_DEVQ, \"Enable evq\", HFILL }},\n\n\t\t{ &hf_printer_attributes_keep_printed_jobs,\n\t\t  { \"Keep printed jobs\",\n\t\t    \"spoolss.printer_attributes.keep_printed_jobs\", FT_BOOLEAN,\n\t\t    32, TFS(&tfs_printer_attributes_keep_printed_jobs),\n\t\t    PRINTER_ATTRIBUTE_KEEPPRINTEDJOBS, NULL,\n\t\t    HFILL }},\n\n\t\t{ &hf_printer_attributes_do_complete_first,\n\t\t  { \"Do complete first\",\n\t\t    \"spoolss.printer_attributes.do_complete_first\", FT_BOOLEAN,\n\t\t    32, TFS(&tfs_printer_attributes_do_complete_first),\n\t\t    PRINTER_ATTRIBUTE_DO_COMPLETE_FIRST, NULL,\n\t\t    HFILL }},\n\n\t\t{ &hf_printer_attributes_work_offline,\n\t\t  { \"Work offline (9x/ME only)\",\n\t\t    \"spoolss.printer_attributes.work_offline\", FT_BOOLEAN,\n\t\t    32, TFS(&tfs_printer_attributes_work_offline),\n\t\t    PRINTER_ATTRIBUTE_WORK_OFFLINE, NULL, HFILL }},\n\n\t\t{ &hf_printer_attributes_enable_bidi,\n\t\t  { \"Enable bidi (9x/ME only)\",\n\t\t    \"spoolss.printer_attributes.enable_bidi\", FT_BOOLEAN,\n\t\t    32, TFS(&tfs_printer_attributes_enable_bidi),\n\t\t    PRINTER_ATTRIBUTE_ENABLE_BIDI, NULL, HFILL }},\n\n\t\t{ &hf_printer_attributes_raw_only,\n\t\t  { \"Raw only\", \"spoolss.printer_attributes.raw_only\",\n\t\t    FT_BOOLEAN, 32, TFS(&tfs_printer_attributes_raw_only),\n\t\t    PRINTER_ATTRIBUTE_RAW_ONLY, NULL, HFILL }},\n\n\t\t{ &hf_printer_attributes_published,\n\t\t  { \"Published\", \"spoolss.printer_attributes.published\",\n\t\t    FT_BOOLEAN, 32, TFS(&tfs_printer_attributes_published),\n\t\t    PRINTER_ATTRIBUTE_PUBLISHED, NULL, HFILL }},\n\n\t\t/* Printer Driver attributes */\n\n\t\t{ &hf_printer_driver_attributes,\n\t\t  { \"Driver Attributes\", \"spoolss.printer_driver_attributes\", FT_UINT32,\n\t\t    BASE_HEX, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_printer_driver_attributes_package_aware,\n\t\t  { \"Package Aware\", \"spoolss.printer_driver_attributes.packageaware\", FT_BOOLEAN,\n\t\t    32, TFS(&tfs_printer_driver_attributes_package_aware),\n\t\t    PRINTER_DRIVER_PACKAGE_AWARE, NULL, HFILL }},\n\n\t\t{ &hf_printer_driver_attributes_xps,\n\t\t  { \"XPS\", \"spoolss.printer_driver_attributes.xps\", FT_BOOLEAN,\n\t\t    32, TFS(&tfs_printer_driver_attributes_xps),\n\t\t    PRINTER_DRIVER_XPS, NULL, HFILL }},\n\n\t\t{ &hf_printer_driver_attributes_sandbox_enabled,\n\t\t  { \"Sandbox enabled\", \"spoolss.printer_driver_attributes.sandboxenabled\", FT_BOOLEAN,\n\t\t    32, TFS(&tfs_printer_driver_attributes_sandbox_enabled),\n\t\t    PRINTER_DRIVER_SANDBOX_ENABLED, NULL, HFILL }},\n\n\t\t{ &hf_printer_driver_attributes_class,\n\t\t  { \"Class Driver\", \"spoolss.printer_driver_attributes.class\", FT_BOOLEAN,\n\t\t    32, TFS(&tfs_printer_driver_attributes_class),\n\t\t    PRINTER_DRIVER_CLASS, NULL, HFILL }},\n\n\t\t{ &hf_printer_driver_attributes_derived,\n\t\t  { \"Derived Driver\", \"spoolss.printer_driver_attributes.derived\", FT_BOOLEAN,\n\t\t    32, TFS(&tfs_printer_driver_attributes_derived),\n\t\t    PRINTER_DRIVER_DERIVED, NULL, HFILL }},\n\n\t\t{ &hf_printer_driver_attributes_not_shareable,\n\t\t  { \"Not Shareable\", \"spoolss.printer_driver_attributes.notshareable\", FT_BOOLEAN,\n\t\t    32, TFS(&tfs_printer_driver_attributes_not_shareable),\n\t\t    PRINTER_DRIVER_NOT_SHAREABLE, NULL, HFILL }},\n\n\t\t{ &hf_printer_driver_attributes_category_fax,\n\t\t  { \"Category Fax\", \"spoolss.printer_driver_attributes.categoryfax\", FT_BOOLEAN,\n\t\t    32, TFS(&tfs_printer_driver_attributes_category_fax),\n\t\t    PRINTER_DRIVER_CATEGORY_FAX, NULL, HFILL }},\n\n\t\t{ &hf_printer_driver_attributes_category_file,\n\t\t  { \"Category File\", \"spoolss.printer_driver_attributes.categoryfile\", FT_BOOLEAN,\n\t\t    32, TFS(&tfs_printer_driver_attributes_category_file),\n\t\t    PRINTER_DRIVER_CATEGORY_FILE, NULL, HFILL }},\n\n\t\t{ &hf_printer_driver_attributes_category_virtual,\n\t\t  { \"Category Virtual\", \"spoolss.printer_driver_attributes.categoryvirtual\", FT_BOOLEAN,\n\t\t    32, TFS(&tfs_printer_driver_attributes_category_virtual),\n\t\t    PRINTER_DRIVER_CATEGORY_VIRTUAL, NULL, HFILL }},\n\n\t\t{ &hf_printer_driver_attributes_category_service,\n\t\t  { \"Category Service\", \"spoolss.printer_driver_attributes.categoryservice\", FT_BOOLEAN,\n\t\t    32, TFS(&tfs_printer_driver_attributes_category_service),\n\t\t    PRINTER_DRIVER_CATEGORY_SERVICE, NULL, HFILL }},\n\n\t\t{ &hf_printer_driver_attributes_soft_reset_required,\n\t\t  { \"Soft Reset Required\", \"spoolss.printer_driver_attributes.softresetrequired\", FT_BOOLEAN,\n\t\t    32, TFS(&tfs_printer_driver_attributes_soft_reset_required),\n\t\t    PRINTER_DRIVER_SOFT_RESET_REQUIRED, NULL, HFILL }},\n\n\t\t{ &hf_printer_driver_attributes_category_3d,\n\t\t  { \"Category 3D\", \"spoolss.printer_driver_attributes.category3d\", FT_BOOLEAN,\n\t\t    32, TFS(&tfs_printer_driver_attributes_category_3d),\n\t\t    PRINTER_DRIVER_CATEGORY_3D, NULL, HFILL }},\n\n\n\t\t/* Timestamps */\n\n\t\t{ &hf_time_year,\n\t\t  { \"Year\", \"spoolss.time.year\", FT_UINT32, BASE_DEC,\n\t\t    NULL, 0x0, NULL, HFILL }},\n\n\t\t{ &hf_time_month,\n\t\t  { \"Month\", \"spoolss.time.month\", FT_UINT32, BASE_DEC,\n\t\t    NULL, 0x0, NULL, HFILL }},\n\n\t\t{ &hf_time_dow,\n\t\t  { \"Day of week\", \"spoolss.time.dow\", FT_UINT32, BASE_DEC,\n\t\t    NULL, 0x0, NULL, HFILL }},\n\n\t\t{ &hf_time_day,\n\t\t  { \"Day\", \"spoolss.time.day\", FT_UINT32, BASE_DEC,\n\t\t    NULL, 0x0, NULL, HFILL }},\n\n\t\t{ &hf_time_hour,\n\t\t  { \"Hour\", \"spoolss.time.hour\", FT_UINT32, BASE_DEC,\n\t\t    NULL, 0x0, NULL, HFILL }},\n\n\t\t{ &hf_time_minute,\n\t\t  { \"Minute\", \"spoolss.time.minute\", FT_UINT32, BASE_DEC,\n\t\t    NULL, 0x0, NULL, HFILL }},\n\n\t\t{ &hf_time_second,\n\t\t  { \"Second\", \"spoolss.time.second\", FT_UINT32, BASE_DEC,\n\t\t    NULL, 0x0, NULL, HFILL }},\n\n\t\t{ &hf_time_msec,\n\t\t  { \"Millisecond\", \"spoolss.time.msec\", FT_UINT32, BASE_DEC,\n\t\t    NULL, 0x0, NULL, HFILL }},\n\n\t\t/* Userlevel */\n\n\t\t{ &hf_userlevel_size,\n\t\t  { \"Size\", \"spoolss.userlevel.size\",\n\t\t    FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_userlevel_client,\n\t\t  { \"Client\", \"spoolss.userlevel.client\", FT_STRING,\n\t\t    BASE_NONE, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_userlevel_user,\n\t\t  { \"User\", \"spoolss.userlevel.user\", FT_STRING,\n\t\t    BASE_NONE, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_userlevel_build,\n\t\t  { \"Build\", \"spoolss.userlevel.build\",\n\t\t    FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_userlevel_major,\n\t\t  { \"Major\", \"spoolss.userlevel.major\",\n\t\t    FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_userlevel_minor,\n\t\t  { \"Minor\", \"spoolss.userlevel.minor\",\n\t\t    FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_userlevel_processor,\n\t\t  { \"Processor\", \"spoolss.userlevel.processor\",\n\t\t    FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t/* EnumprinterdataEx RPC */\n\n\t\t{ &hf_enumprinterdataex_name_offset,\n\t\t  { \"Name offset\", \"spoolss.enumprinterdataex.name_offset\",\n\t\t    FT_UINT32, BASE_DEC, NULL, 0x0,\n\t\t    NULL, HFILL }},\n\n\t\t{ &hf_enumprinterdataex_name_len,\n\t\t  { \"Name len\", \"spoolss.enumprinterdataex.name_len\",\n\t\t    FT_UINT32, BASE_DEC, NULL, 0x0,\n\t\t    NULL, HFILL }},\n\n\t\t{ &hf_enumprinterdataex_name,\n\t\t  { \"Name\", \"spoolss.enumprinterdataex.name\",\n\t\t    FT_STRING, BASE_NONE, NULL, 0x0,\n\t\t    NULL, HFILL }},\n\n\t\t{ &hf_enumprinterdataex_val_offset,\n\t\t  { \"Value offset\", \"spoolss.enumprinterdataex.value_offset\",\n\t\t    FT_UINT32, BASE_DEC, NULL, 0x0,\n\t\t    NULL, HFILL }},\n\n\t\t{ &hf_enumprinterdataex_val_len,\n\t\t  { \"Value len\", \"spoolss.enumprinterdataex.value_len\",\n\t\t    FT_UINT32, BASE_DEC, NULL, 0x0,\n\t\t    NULL, HFILL }},\n\n\t\t{ &hf_enumprinterdataex_val_dword_high,\n\t\t  { \"DWORD value (high)\",\n\t\t    \"spoolss.enumprinterdataex.val_dword.high\",\n\t\t    FT_UINT16, BASE_DEC, NULL, 0x0,\n\t\t    NULL, HFILL }},\n\n\t\t{ &hf_enumprinterdataex_value_null,\n\t\t  { \"Value\",\n\t\t    \"spoolss.enumprinterdataex.val_null\",\n\t\t    FT_UINT32, BASE_DEC, NULL, 0x0,\n\t\t    NULL, HFILL }},\n\n\t\t{ &hf_enumprinterdataex_value_uint,\n\t\t  { \"Value\",\n\t\t    \"spoolss.enumprinterdataex.val_uint\",\n\t\t    FT_UINT32, BASE_DEC, NULL, 0x0,\n\t\t    NULL, HFILL }},\n\n\t\t{ &hf_enumprinterdataex_value_binary,\n\t\t  { \"Value\",\n\t\t    \"spoolss.enumprinterdataex.val_binary\",\n\t\t    FT_BYTES, BASE_NONE, NULL, 0x0,\n\t\t    NULL, HFILL }},\n\n\t\t{ &hf_enumprinterdataex_value_multi_sz,\n\t\t  { \"Value\",\n\t\t    \"spoolss.enumprinterdataex.val_multi_sz\",\n\t\t    FT_BYTES, BASE_NONE, NULL, 0x0,\n\t\t    NULL, HFILL }},\n\n\t\t{ &hf_enumprinterdataex_val_dword_low,\n\t\t  { \"DWORD value (low)\",\n\t\t    \"spoolss.enumprinterdataex.val_dword.low\",\n\t\t    FT_UINT16, BASE_DEC, NULL, 0x0,\n\t\t    NULL, HFILL }},\n\n\t\t/* RouterReplyPrinter RPC */\n\n\t\t{ &hf_routerreplyprinter_condition,\n\t\t  { \"Condition\", \"spoolss.routerreplyprinter.condition\",\n\t\t    FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_routerreplyprinter_unknown1,\n\t\t  { \"Unknown1\", \"spoolss.routerreplyprinter.unknown1\",\n\t\t    FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_routerreplyprinter_changeid,\n\t\t  { \"Change id\", \"spoolss.routerreplyprinter.changeid\",\n\t\t    FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t/* EnumPrinterKey RPC */\n\n\t\t{ &hf_keybuffer_size,\n\t\t  { \"Key Buffer size\", \"spoolss.keybuffer.size\", FT_UINT32,\n\t\t    BASE_DEC, NULL, 0x0, \"Size of buffer\", HFILL }},\n\n\t\t/* SetJob RPC */\n\n\t\t{ &hf_setjob_cmd,\n\t\t  { \"Set job command\", \"spoolss.setjob.cmd\", FT_UINT32,\n\t\t    BASE_DEC, VALS(setjob_commands), 0x0, \"Printer data name\",\n\t\t    HFILL }},\n\n\t\t/* EnumJobs RPC */\n\n\t\t{ &hf_enumjobs_firstjob,\n\t\t  { \"First job\", \"spoolss.enumjobs.firstjob\", FT_UINT32,\n\t\t    BASE_DEC, NULL, 0x0, \"Index of first job to return\",\n\t\t    HFILL }},\n\n\t\t{ &hf_enumjobs_numjobs,\n\t\t  { \"Num jobs\", \"spoolss.enumjobs.numjobs\", FT_UINT32,\n\t\t    BASE_DEC, NULL, 0x0, \"Number of jobs to return\", HFILL }},\n\n\t\t/* Security descriptor buffer */\n\n\t\t{ &hf_secdescbuf_maxlen,\n\t\t  { \"Max len\", \"spoolss.secdescbuf.max_len\",\n\t\t    FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_secdescbuf_undoc,\n\t\t  { \"Undocumented\", \"spoolss.secdescbuf.undoc\",\n\t\t    FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_secdescbuf_len,\n\t\t  { \"Length\", \"spoolss.secdescbuf.len\",\n\t\t    FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t/* Spool printer info */\n\n\t\t{ &hf_spool_printer_info_devmode_ptr,\n\t\t  { \"Devmode pointer\", \"spoolss.spoolprinterinfo.devmode_ptr\",\n\t\t    FT_UINT32, BASE_HEX, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_spool_printer_info_secdesc_ptr,\n\t\t  { \"Secdesc pointer\", \"spoolss.spoolprinterinfo.secdesc_ptr\",\n\t\t    FT_UINT32, BASE_HEX, NULL, 0, NULL, HFILL }},\n\n\t\t/* WritePrinter RPC */\n\n\t\t{ &hf_writeprinter_numwritten,\n\t\t  { \"Num written\", \"spoolss.writeprinter.numwritten\",\n\t\t    FT_UINT32, BASE_DEC, NULL, 0x0, \"Number of bytes written\",\n\t\t    HFILL }},\n\n\t\t/* Setprinterdataex RPC */\n\n\t\t{ &hf_setprinterdataex_max_len,\n\t\t  { \"Max len\", \"spoolss.setprinterdataex.max_len\",\n\t\t    FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_setprinterdataex_real_len,\n\t\t  { \"Real len\", \"spoolss.setprinterdataex.real_len\",\n\t\t    FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_setprinterdataex_data,\n\t\t  { \"Data\", \"spoolss.setprinterdataex.data\",\n\t\t    FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL }},\n\n\t\t/* Specific access rights */\n\n\t\t{ &hf_access_required,\n\t\t  { \"Access required\", \"spoolss.access_required\",\n\t\t    FT_UINT32, BASE_HEX, NULL, 0x0, NULL,\n\t\t    HFILL }},\n\n\t\t{ &hf_server_access_admin,\n\t\t  { \"Server admin\", \"spoolss.access_mask.server_admin\",\n\t\t    FT_BOOLEAN, 32, TFS(&tfs_set_notset),\n\t\t    SERVER_ACCESS_ADMINISTER, NULL, HFILL }},\n\n\t\t{ &hf_server_access_enum,\n\t\t  { \"Server enum\", \"spoolss.access_mask.server_enum\",\n\t\t    FT_BOOLEAN, 32, TFS(&tfs_set_notset),\n\t\t    SERVER_ACCESS_ENUMERATE, NULL, HFILL }},\n\n\t\t{ &hf_printer_access_admin,\n\t\t  { \"Printer admin\", \"spoolss.access_mask.printer_admin\",\n\t\t    FT_BOOLEAN, 32, TFS(&tfs_set_notset),\n\t\t    PRINTER_ACCESS_ADMINISTER, NULL, HFILL }},\n\n\t\t{ &hf_printer_access_use,\n\t\t  { \"Printer use\", \"spoolss.access_mask.printer_use\",\n\t\t    FT_BOOLEAN, 32, TFS(&tfs_set_notset),\n\t\t    PRINTER_ACCESS_USE, NULL, HFILL }},\n\n\t\t{ &hf_job_access_admin,\n\t\t  { \"Job admin\", \"spoolss.access_mask.job_admin\",\n\t\t    FT_BOOLEAN, 32, TFS(&tfs_set_notset),\n\t\t    JOB_ACCESS_ADMINISTER, NULL, HFILL }},\n\n\t\t/* Printer information */\n\n\t\t{ &hf_printer_cjobs,\n\t\t  { \"CJobs\", \"spoolss.printer.cjobs\", FT_UINT32,\n\t\t    BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_printer_total_jobs,\n\t\t  { \"Total jobs\", \"spoolss.printer.total_jobs\", FT_UINT32,\n\t\t    BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_printer_total_bytes,\n\t\t  { \"Total bytes\", \"spoolss.printer.total_bytes\", FT_UINT32,\n\t\t    BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_printer_global_counter,\n\t\t  { \"Global counter\", \"spoolss.printer.global_counter\",\n\t\t    FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_printer_total_pages,\n\t\t  { \"Total pages\", \"spoolss.printer.total_pages\", FT_UINT32,\n\t\t    BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_printer_major_version,\n\t\t  { \"Major version\", \"spoolss.printer.major_version\",\n\t\t    FT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_printer_build_version,\n\t\t  { \"Build version\", \"spoolss.printer.build_version\",\n\t\t    FT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_printer_unk7,\n\t\t  { \"Unknown 7\", \"spoolss.printer.unknown7\", FT_UINT32,\n\t\t    BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_printer_unk8,\n\t\t  { \"Unknown 8\", \"spoolss.printer.unknown8\", FT_UINT32,\n\t\t    BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_printer_unk9,\n\t\t  { \"Unknown 9\", \"spoolss.printer.unknown9\", FT_UINT32,\n\t\t    BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_printer_session_ctr,\n\t\t  { \"Session counter\", \"spoolss.printer.session_ctr\",\n\t\t    FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_printer_unk11,\n\t\t  { \"Unknown 11\", \"spoolss.printer.unknown11\", FT_UINT32,\n\t\t    BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_printer_printer_errors,\n\t\t  { \"Printer errors\", \"spoolss.printer.printer_errors\",\n\t\t    FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_printer_unk13,\n\t\t  { \"Unknown 13\", \"spoolss.printer.unknown13\", FT_UINT32,\n\t\t    BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_printer_unk14,\n\t\t  { \"Unknown 14\", \"spoolss.printer.unknown14\", FT_UINT32,\n\t\t    BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_printer_unk15,\n\t\t  { \"Unknown 15\", \"spoolss.printer.unknown15\", FT_UINT32,\n\t\t    BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_printer_unk16,\n\t\t  { \"Unknown 16\", \"spoolss.printer.unknown16\", FT_UINT32,\n\t\t    BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_printer_changeid,\n\t\t  { \"Change id\", \"spoolss.printer.changeid\", FT_UINT32,\n\t\t    BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_printer_unk18,\n\t\t  { \"Unknown 18\", \"spoolss.printer.unknown18\", FT_UINT32,\n\t\t    BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_printer_unk20,\n\t\t  { \"Unknown 20\", \"spoolss.printer.unknown20\", FT_UINT32,\n\t\t    BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_printer_c_setprinter,\n\t\t  { \"Csetprinter\", \"spoolss.printer.c_setprinter\",\n\t\t    FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_printer_unk22,\n\t\t  { \"Unknown 22\", \"spoolss.printer.unknown22\",\n\t\t    FT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_printer_unk23,\n\t\t  { \"Unknown 23\", \"spoolss.printer.unknown23\",\n\t\t    FT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_printer_unk24,\n\t\t  { \"Unknown 24\", \"spoolss.printer.unknown24\",\n\t\t    FT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_printer_unk25,\n\t\t  { \"Unknown 25\", \"spoolss.printer.unknown25\",\n\t\t    FT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_printer_unk26,\n\t\t  { \"Unknown 26\", \"spoolss.printer.unknown26\",\n\t\t    FT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_printer_unk27,\n\t\t  { \"Unknown 27\", \"spoolss.printer.unknown27\",\n\t\t    FT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_printer_unk28,\n\t\t  { \"Unknown 28\", \"spoolss.printer.unknown28\",\n\t\t    FT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_printer_unk29,\n\t\t  { \"Unknown 29\", \"spoolss.printer.unknown29\",\n\t\t    FT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_printer_flags,\n\t\t  { \"Flags\", \"spoolss.printer.flags\",\n\t\t    FT_UINT32, BASE_HEX, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_printer_priority,\n\t\t  { \"Priority\", \"spoolss.printer.priority\",\n\t\t    FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_printer_default_priority,\n\t\t  { \"Default Priority\", \"spoolss.printer.default_priority\",\n\t\t    FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_printer_averageppm,\n\t\t  { \"Average PPM\", \"spoolss.printer.averageppm\",\n\t\t    FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_printer_jobs,\n\t\t  { \"Jobs\", \"spoolss.printer.jobs\",\n\t\t    FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_printer_guid,\n\t\t  { \"GUID\", \"spoolss.printer.guid\", FT_STRING,\n\t\t    BASE_NONE, NULL, 0, NULL, HFILL }},\n\n\t\t{ &hf_printer_action,\n\t\t  { \"Action\", \"spoolss.printer.action\", FT_UINT32, BASE_DEC,\n\t\t   VALS(getprinter_action_vals), 0, NULL, HFILL }},\n\t};\n\n\tstatic int *ett[] = {\n\t\t&ett_dcerpc_spoolss,\n\t\t&ett_PRINTER_DATATYPE,\n\t\t&ett_DEVMODE_CTR,\n\t\t&ett_DEVMODE,\n\t\t&ett_DEVMODE_fields,\n\t\t&ett_USER_LEVEL_CTR,\n\t\t&ett_USER_LEVEL_1,\n\t\t&ett_BUFFER,\n\t\t&ett_PRINTER_INFO,\n\t\t&ett_SPOOL_PRINTER_INFO_LEVEL,\n\t\t&ett_PRINTER_INFO_0,\n\t\t&ett_PRINTER_INFO_1,\n\t\t&ett_PRINTER_INFO_2,\n\t\t&ett_PRINTER_INFO_3,\n\t\t&ett_PRINTER_INFO_5,\n\t\t&ett_PRINTER_INFO_7,\n\t\t&ett_RELSTR,\n\t\t&ett_RELSTR_ARRAY,\n\t\t&ett_FORM_REL,\n\t\t&ett_FORM_CTR,\n\t\t&ett_FORM_1,\n\t\t&ett_JOB_INFO_1,\n\t\t&ett_JOB_INFO_2,\n\t\t&ett_SEC_DESC_BUF,\n\t\t&ett_SYSTEM_TIME,\n\t\t&ett_DOC_INFO_1,\n\t\t&ett_DOC_INFO,\n\t\t&ett_DOC_INFO_CTR,\n\t\t&ett_printerdata_value,\n\t\t&ett_printerdata_data,\n\t\t&ett_writeprinter_buffer,\n\t\t&ett_DRIVER_INFO_1,\n\t\t&ett_DRIVER_INFO_2,\n\t\t&ett_DRIVER_INFO_3,\n\t\t&ett_DRIVER_INFO_6,\n\t\t&ett_DRIVER_INFO_8,\n\t\t&ett_DRIVER_INFO_101,\n\t\t&ett_CORE_PRINTER_DRIVER,\n\t\t&ett_rffpcnex_flags,\n\t\t&ett_notify_options_flags,\n\t\t&ett_NOTIFY_INFO_DATA,\n\t\t&ett_NOTIFY_OPTION,\n\t\t&ett_printer_attributes,\n\t\t&ett_printer_driver_attributes,\n\t\t&ett_job_status,\n\t\t&ett_enumprinters_flags,\n\t\t&ett_PRINTER_DATA_CTR,\n\t\t&ett_printer_enumdataex_value,\n\t};\n\n\tstatic ei_register_info ei[] = {\n\t\t{ &ei_unimplemented_dissector, { \"spoolss.unimplemented_dissector\", PI_UNDECODED, PI_WARN, \"Unimplemented dissector: SPOOLSS\", EXPFILL }},\n\t\t{ &ei_unknown_data, { \"spoolss.unknown_data\", PI_UNDECODED, PI_WARN, \"Unknown data follows\", EXPFILL }},\n\t\t{ &ei_printer_info_level, { \"spoolss.printer.unknown\", PI_PROTOCOL, PI_WARN, \"Unknown printer info level\", EXPFILL }},\n\t\t{ &ei_spool_printer_info_level, { \"spoolss.spool_printer.unknown\", PI_PROTOCOL, PI_WARN, \"Unknown spool printer info level\", EXPFILL }},\n\t\t{ &ei_form_level, { \"spoolss.form.level.unknown\", PI_PROTOCOL, PI_WARN, \"Unknown form info level\", EXPFILL }},\n\t\t{ &ei_job_info_level, { \"spoolss.job_info.level.unknown\", PI_PROTOCOL, PI_WARN, \"Unknown job info level\", EXPFILL }},\n\t\t{ &ei_driver_info_level, { \"spoolss.driver_info.level.unknown\", PI_PROTOCOL, PI_WARN, \"Unknown driver info level\", EXPFILL }},\n\t\t{ &ei_level, { \"spoolss.level.unknown\", PI_PROTOCOL, PI_WARN, \"Info level unknown\", EXPFILL }},\n\t\t{ &ei_notify_info_data_type, { \"spoolss.notify_info_data.type.unknown\", PI_PROTOCOL, PI_WARN, \"Unknown notify type\", EXPFILL }},\n\t\t{ &ei_enumprinterdataex_value, { \"spoolss.enumprinterdataex.val_unknown\", PI_PROTOCOL, PI_WARN, \"Unknown value type\", EXPFILL }},\n\t\t{ &ei_buffer_size_too_long, { \"spoolss.buffer.size.invalid\", PI_PROTOCOL, PI_ERROR, \"Buffer size too long\", EXPFILL }},\n\t};\n\n\texpert_module_t* expert_dcerpc_spoolss;\n\n\tproto_dcerpc_spoolss = proto_register_protocol(\"Microsoft Spool Subsystem\", \"SPOOLSS\", \"spoolss\");\n\n\tproto_register_field_array(proto_dcerpc_spoolss, hf, array_length(hf));\n\tproto_register_subtree_array(ett, array_length(ett));\n\texpert_dcerpc_spoolss = expert_register_protocol(proto_dcerpc_spoolss);\n\texpert_register_field_array(expert_dcerpc_spoolss, ei, array_length(ei));\n}\n\n/* Protocol handoff */\n\nstatic e_guid_t uuid_dcerpc_spoolss = {\n\t0x12345678, 0x1234, 0xabcd,\n\t{ 0xef, 0x00, 0x01, 0x23, 0x45, 0x67, 0x89, 0xab }\n};\n\nstatic uint16_t ver_dcerpc_spoolss = 1;\n\nvoid\nproto_reg_handoff_dcerpc_spoolss(void)\n{\n\n\t/* Register protocol as dcerpc */\n\n\tdcerpc_init_uuid(proto_dcerpc_spoolss, ett_dcerpc_spoolss,\n\t\t\t &uuid_dcerpc_spoolss, ver_dcerpc_spoolss,\n\t\t\t dcerpc_spoolss_dissectors, hf_opnum);\n}\n\n/*\n * Editor modelines  -  https://www.wireshark.org/tools/modelines.html\n *\n * Local variables:\n * c-basic-offset: 8\n * tab-width: 8\n * indent-tabs-mode: t\n * End:\n *\n * vi: set shiftwidth=8 tabstop=8 noexpandtab:\n * :indentSize=8:tabSize=8:noTabs=false:\n */\n", "patch": "@@ -1090,7 +1090,7 @@ dissect_spoolss_uint16uni(tvbuff_t *tvb, int offset, packet_info *pinfo _U_,\n \n \t/* Get remaining data in buffer as a string */\n \n-\tremaining = tvb_captured_length_remaining(tvb, offset);\n+\tremaining = tvb_reported_length_remaining(tvb, offset);\n \tif (remaining <= 0) {\n \t\tif (data)\n \t\t\t*data = g_strdup(\"\");\n@@ -6198,9 +6198,10 @@ dissect_spoolss_keybuffer(tvbuff_t *tvb, int offset, packet_info *pinfo,\n \t\tend_offset = tvb_reported_length_remaining(tvb, offset) + 1;\n \t}\n \n-\twhile (offset < end_offset)\n+\twhile (offset > 0 && offset < end_offset) {\n \t\toffset = dissect_spoolss_uint16uni(\n \t\t\ttvb, offset, pinfo, tree, drep, NULL, hf_keybuffer);\n+\t}\n \n \treturn offset;\n }", "file_path": "files/2016_8\\46", "file_language": "c", "file_name": "epan/dissectors/packet-dcerpc-spoolss.c", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}], "outdated": 0}
{"index": 13, "cve_id": "CVE-2016-5354", "cwe_id": ["CWE-476"], "cve_language": "C", "cve_description": "The USB subsystem in Wireshark 1.12.x before 1.12.12 and 2.x before 2.0.4 mishandles class types, which allows remote attackers to cause a denial of service (application crash) via a crafted packet.", "cvss": "5.9", "publish_date": "August 7, 2016", "AV": "NETWORK", "AC": "HIGH", "PR": "NONE", "UI": "NONE", "S": "UNCHANGED", "C": "NONE", "I": "NONE", "A": "HIGH", "commit_id": "2cb5985bf47bdc8bea78d28483ed224abdd33dc6", "commit_message": "Make class \"type\" for USB conversations.\n\nUSB dissectors can't assume that only their class type has been passed around in the conversation.  Make explicit check that class type expected matches the dissector and stop/prevent dissection if there isn't a match.\n\nBug: 12356\nChange-Id: Ib23973a4ebd0fbb51952ffc118daf95e3389a209\nReviewed-on: https://code.wireshark.org/review/15212\nPetri-Dish: Michael Mann <mmann78@netscape.net>\nReviewed-by: Martin Kaiser <wireshark@kaiser.cx>\nPetri-Dish: Martin Kaiser <wireshark@kaiser.cx>\nTested-by: Petri Dish Buildbot <buildbot-no-reply@wireshark.org>\nReviewed-by: Michael Mann <mmann78@netscape.net>", "commit_date": "2016-05-01T20:16:15Z", "project": "wireshark/wireshark", "url": "https://api.github.com/repos/wireshark/wireshark/commits/2cb5985bf47bdc8bea78d28483ed224abdd33dc6", "html_url": "https://github.com/wireshark/wireshark/commit/2cb5985bf47bdc8bea78d28483ed224abdd33dc6", "windows_before": "", "windows_after": "", "parents": [{"commit_id_before": "7c79da8c30e39aecb1cddab39f537d8f6a1da25f", "url_before": "https://api.github.com/repos/wireshark/wireshark/commits/7c79da8c30e39aecb1cddab39f537d8f6a1da25f", "html_url_before": "https://github.com/wireshark/wireshark/commit/7c79da8c30e39aecb1cddab39f537d8f6a1da25f"}], "details": [{"raw_url": "https://github.com/wireshark/wireshark/raw/2cb5985bf47bdc8bea78d28483ed224abdd33dc6/epan/dissectors/packet-u3v.c", "code": "/* packet-u3v.c\n* Routines for AIA USB3 Vision (TM) Protocol dissection\n* Copyright 2016, AIA (www.visiononline.org)\n*\n* USB3 Vision (TM): USB3 Vision a standard developed under the sponsorship of\n* the AIA for the benefit of the machine vision industry.\n* U3V stands for USB3 Vision (TM) Protocol.\n*\n* Wireshark - Network traffic analyzer\n* By Gerald Combs <gerald@wireshark.org>\n* Copyright 1998 Gerald Combs\n*\n* This program is free software; you can redistribute it and/or\n* modify it under the terms of the GNU General Public License\n* as published by the Free Software Foundation; either version 2\n* of the License, or (at your option) any later version.\n*\n* This program is distributed in the hope that it will be useful,\n* but WITHOUT ANY WARRANTY; without even the implied warranty of\n* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n* GNU General Public License for more details.\n*\n* You should have received a copy of the GNU General Public License\n* along with this program; if not, write to the Free Software\n* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n*/\n\n#include \"config.h\"\n\n#include <epan/packet.h>\n#include <epan/proto_data.h>\n#include <epan/dissectors/packet-usb.h>\n\n\n\n/*\nU3V descriptor constants\n*/\n#define DESCRIPTOR_TYPE_U3V_INTERFACE 0x24\n#define DESCRIPTOR_SUBTYPE_U3V_DEVICE_INFO 0x01\n\n/*\n Bootstrap registers addresses\n */\n#define U3V_ABRM_GENCP_VERSION 0x00000000\n#define U3V_ABRM_MANUFACTURER_NAME 0x00000004\n#define U3V_ABRM_MODEL_NAME 0x00000044\n#define U3V_ABRM_FAMILY_NAME 0x00000084\n#define U3V_ABRM_DEVICE_VERSION 0x000000C4\n#define U3V_ABRM_MANUFACTURER_INFO 0x00000104\n#define U3V_ABRM_SERIAL_NUMBER 0x00000144\n#define U3V_ABRM_USER_DEFINED_NAME 0x00000184\n#define U3V_ABRM_DEVICE_CAPABILITY 0x000001C4\n#define U3V_ABRM_MAXIMUM_DEVICE_RESPONSE_TIME 0x000001CC\n#define U3V_ABRM_MANIFEST_TABLE_ADDRESS 0x000001D0\n#define U3V_ABRM_SBRM_ADDRESS 0x000001D8\n#define U3V_ABRM_DEVICE_CONFIGURATION 0x000001E0\n#define U3V_ABRM_HEARTBEAT_TIMEOUT 0x000001E8\n#define U3V_ABRM_MESSAGE_CHANNEL_CHANNEL_ID 0x000001EC\n#define U3V_ABRM_TIMESTAMP 0x000001F0\n#define U3V_ABRM_TIMESTAMP_LATCH 0x000001F8\n#define U3V_ABRM_TIMESTAMP_INCREMENT 0x000001FC\n#define U3V_ABRM_ACCESS_PRIVILEGE 0x00000204\n#define U3V_ABRM_PROTOCOL_ENDIANESS 0x00000208\n#define U3V_ABRM_IMPLEMENTATION_ENDIANESS 0x0000020C\n#define U3V_SBRM_U3V_VERSION 0x00000000\n#define U3V_SBRM_U3VCP_CAPABILITY_REGISTER 0x00000004\n#define U3V_SBRM_U3VCP_CONFIGURATION_REGISTER 0x0000000C\n#define U3V_SBRM_MAXIMUM_COMMAND_TRANSFER_LENGTH 0x00000014\n#define U3V_SBRM_MAXIMUM_ACKNOWLEDGE_TRANSFER_LENGTH 0x00000018\n#define U3V_SBRM_NUMBER_OF_STREAM_CHANNELS 0x0000001C\n#define U3V_SBRM_SIRM_ADDRESS 0x00000020\n#define U3V_SBRM_SIRM_LENGTH 0x00000028\n#define U3V_SBRM_EIRM_ADDRESS 0x0000002C\n#define U3V_SBRM_EIRM_LENGTH 0x00000034\n#define U3V_SBRM_IIDC2_ADDRESS 0x00000038\n#define U3V_SBRM_CURRENT_SPEED 0x00000040\n#define U3V_SIRM_SI_INFO 0x00000000\n#define U3V_SIRM_SI_CONTROL 0x00000004\n#define U3V_SIRM_SI_REQUIRED_PAYLOAD_SIZE 0x00000008\n#define U3V_SIRM_SI_REQUIRED_LEADER_SIZE 0x00000010\n#define U3V_SIRM_SI_REQUIRED_TRAILER_SIZE 0x00000014\n#define U3V_SIRM_SI_MAXIMUM_LEADER_SIZE 0x00000018\n#define U3V_SIRM_SI_PAYLOAD_TRANSFER_SIZE 0x0000001C\n#define U3V_SIRM_SI_PAYLOAD_TRANSFER_COUNT 0x00000020\n#define U3V_SIRM_SI_PAYLOAD_FINAL_TRANSFER1_SIZE 0x00000024\n#define U3V_SIRM_SI_PAYLOAD_FINAL_TRANSFER2_SIZE 0x00000028\n#define U3V_SIRM_SI_MAXIMUM_TRAILER_SIZE 0x0000002C\n#define U3V_EIRM_EI_CONTROL 0x00000000\n#define U3V_EIRM_MAXIMUM_EVENT_TRANSFER_LENGTH 0x00000004\n#define U3V_EIRM_EVENT_TEST_CONTROL 0x00000008\n\n/*\n Command and acknowledge IDs\n*/\n#define U3V_READMEM_CMD 0x0800\n#define U3V_READMEM_ACK 0x0801\n#define U3V_WRITEMEM_CMD 0x0802\n#define U3V_WRITEMEM_ACK 0x0803\n#define U3V_PENDING_ACK 0x0805\n#define U3V_EVENT_CMD 0x0C00\n#define U3V_EVENT_ACK 0x0C01\n\n/*\n Status codes\n*/\n#define U3V_STATUS_GENCP_SUCCESS               0x0000\n#define U3V_STATUS_GENCP_NOT_IMPLEMENTED       0x8001\n#define U3V_STATUS_GENCP_INVALID_PARAMETER     0x8002\n#define U3V_STATUS_GENCP_INVALID_ADDRESS       0x8003\n#define U3V_STATUS_GENCP_WRITE_PROTECT         0x8004\n#define U3V_STATUS_GENCP_BAD_ALIGNMENT         0x8005\n#define U3V_STATUS_GENCP_ACCESS_DENIED         0x8006\n#define U3V_STATUS_GENCP_BUSY                  0x8007\n/* 0x8008 - 0x800A have been used in GEV 1.x but are now deprecated. The GenCP specification did NOT recycle these values! */\n#define U3V_STATUS_GENCP_MSG_TIMEOUT           0x800B\n/* 0x800C - 0x800D are used in GEV only. The GenCP specification did NOT recycle these values! */\n#define U3V_STATUS_GENCP_INVALID_HEADER        0x800E\n#define U3V_STATUS_GENCP_WRONG_CONFIG          0x800F\n\n#define U3V_STATUS_GENCP_ERROR                 0x8FFF\n\n#define U3V_STATUS_RESEND_NOT_SUPPORTED        0xA001\n#define U3V_STATUS_DSI_ENDPOINT_HALTED         0xA002\n#define U3V_STATUS_SI_PAYLOAD_SIZE_NOT_ALIGNED 0xA003\n#define U3V_STATUS_SI_REGISTERS_INCONSISTENT   0xA004\n#define U3V_STATUS_DATA_DISCARDED              0xA100\n\n/*\n Prefix\n*/\n#define U3V_CONTROL_PREFIX 0x43563355\n#define U3V_EVENT_PREFIX   0x45563355\n\n#define U3V_STREAM_LEADER_PREFIX  0x4C563355\n#define U3V_STREAM_TRAILER_PREFIX 0x54563355\n\n/*\n Event IDs\n*/\n#define U3V_EVENT_TESTEVENT 0x4FFF\n\n/*\n * Pixel Format IDs\n*/\n#define PFNC_U3V_MONO1P 0x01010037\n#define PFNC_U3V_CONFIDENCE1P 0x010100C5\n#define PFNC_U3V_MONO2P 0x01020038\n#define PFNC_U3V_MONO4P 0x01040039\n#define PFNC_U3V_MONO8 0x01080001\n#define PFNC_U3V_MONO8S 0x01080002\n#define PFNC_U3V_BAYERGR8 0x01080008\n#define PFNC_U3V_BAYERRG8 0x01080009\n#define PFNC_U3V_BAYERGB8 0x0108000A\n#define PFNC_U3V_BAYERBG8 0x0108000B\n#define PFNC_U3V_SCF1WBWG8 0x01080067\n#define PFNC_U3V_SCF1WGWB8 0x0108006E\n#define PFNC_U3V_SCF1WGWR8 0x01080075\n#define PFNC_U3V_SCF1WRWG8 0x0108007C\n#define PFNC_U3V_COORD3D_A8 0x010800AF\n#define PFNC_U3V_COORD3D_B8 0x010800B0\n#define PFNC_U3V_COORD3D_C8 0x010800B1\n#define PFNC_U3V_CONFIDENCE1 0x010800C4\n#define PFNC_U3V_CONFIDENCE8 0x010800C6\n#define PFNC_U3V_R8 0x010800C9\n#define PFNC_U3V_G8 0x010800CD\n#define PFNC_U3V_B8 0x010800D1\n#define PFNC_U3V_MONO10P 0x010A0046\n#define PFNC_U3V_BAYERBG10P 0x010A0052\n#define PFNC_U3V_BAYERGB10P 0x010A0054\n#define PFNC_U3V_BAYERGR10P 0x010A0056\n#define PFNC_U3V_BAYERRG10P 0x010A0058\n#define PFNC_U3V_SCF1WBWG10P 0x010A0069\n#define PFNC_U3V_SCF1WGWB10P 0x010A0070\n#define PFNC_U3V_SCF1WGWR10P 0x010A0077\n#define PFNC_U3V_SCF1WRWG10P 0x010A007E\n#define PFNC_U3V_R10 0x010A00CA\n#define PFNC_U3V_G10 0x010A00CE\n#define PFNC_U3V_B10 0x010A00D2\n#define PFNC_U3V_COORD3D_A10P 0x010A00D5\n#define PFNC_U3V_COORD3D_B10P 0x010A00D6\n#define PFNC_U3V_COORD3D_C10P 0x010A00D7\n#define PFNC_U3V_MONO10PACKED 0x010C0004\n#define PFNC_U3V_MONO12PACKED 0x010C0006\n#define PFNC_U3V_BAYERGR10PACKED 0x010C0026\n#define PFNC_U3V_BAYERRG10PACKED 0x010C0027\n#define PFNC_U3V_BAYERGB10PACKED 0x010C0028\n#define PFNC_U3V_BAYERBG10PACKED 0x010C0029\n#define PFNC_U3V_BAYERGR12PACKED 0x010C002A\n#define PFNC_U3V_BAYERRG12PACKED 0x010C002B\n#define PFNC_U3V_BAYERGB12PACKED 0x010C002C\n#define PFNC_U3V_BAYERBG12PACKED 0x010C002D\n#define PFNC_U3V_MONO12P 0x010C0047\n#define PFNC_U3V_BAYERBG12P 0x010C0053\n#define PFNC_U3V_BAYERGB12P 0x010C0055\n#define PFNC_U3V_BAYERGR12P 0x010C0057\n#define PFNC_U3V_BAYERRG12P 0x010C0059\n#define PFNC_U3V_SCF1WBWG12P 0x010C006B\n#define PFNC_U3V_SCF1WGWB12P 0x010C0072\n#define PFNC_U3V_SCF1WGWR12P 0x010C0079\n#define PFNC_U3V_SCF1WRWG12P 0x010C0080\n#define PFNC_U3V_R12 0x010C00CB\n#define PFNC_U3V_G12 0x010C00CF\n#define PFNC_U3V_B12 0x010C00D3\n#define PFNC_U3V_COORD3D_A12P 0x010C00D8\n#define PFNC_U3V_COORD3D_B12P 0x010C00D9\n#define PFNC_U3V_COORD3D_C12P 0x010C00DA\n#define PFNC_U3V_MONO10 0x01100003\n#define PFNC_U3V_MONO12 0x01100005\n#define PFNC_U3V_MONO16 0x01100007\n#define PFNC_U3V_BAYERGR10 0x0110000C\n#define PFNC_U3V_BAYERRG10 0x0110000D\n#define PFNC_U3V_BAYERGB10 0x0110000E\n#define PFNC_U3V_BAYERBG10 0x0110000F\n#define PFNC_U3V_BAYERGR12 0x01100010\n#define PFNC_U3V_BAYERRG12 0x01100011\n#define PFNC_U3V_BAYERGB12 0x01100012\n#define PFNC_U3V_BAYERBG12 0x01100013\n#define PFNC_U3V_MONO14 0x01100025\n#define PFNC_U3V_BAYERGR16 0x0110002E\n#define PFNC_U3V_BAYERRG16 0x0110002F\n#define PFNC_U3V_BAYERGB16 0x01100030\n#define PFNC_U3V_BAYERBG16 0x01100031\n#define PFNC_U3V_SCF1WBWG10 0x01100068\n#define PFNC_U3V_SCF1WBWG12 0x0110006A\n#define PFNC_U3V_SCF1WBWG14 0x0110006C\n#define PFNC_U3V_SCF1WBWG16 0x0110006D\n#define PFNC_U3V_SCF1WGWB10 0x0110006F\n#define PFNC_U3V_SCF1WGWB12 0x01100071\n#define PFNC_U3V_SCF1WGWB14 0x01100073\n#define PFNC_U3V_SCF1WGWB16 0x01100074\n#define PFNC_U3V_SCF1WGWR10 0x01100076\n#define PFNC_U3V_SCF1WGWR12 0x01100078\n#define PFNC_U3V_SCF1WGWR14 0x0110007A\n#define PFNC_U3V_SCF1WGWR16 0x0110007B\n#define PFNC_U3V_SCF1WRWG10 0x0110007D\n#define PFNC_U3V_SCF1WRWG12 0x0110007F\n#define PFNC_U3V_SCF1WRWG14 0x01100081\n#define PFNC_U3V_SCF1WRWG16 0x01100082\n#define PFNC_U3V_COORD3D_A16 0x011000B6\n#define PFNC_U3V_COORD3D_B16 0x011000B7\n#define PFNC_U3V_COORD3D_C16 0x011000B8\n#define PFNC_U3V_CONFIDENCE16 0x011000C7\n#define PFNC_U3V_R16 0x011000CC\n#define PFNC_U3V_G16 0x011000D0\n#define PFNC_U3V_B16 0x011000D4\n#define PFNC_U3V_COORD3D_A32F 0x012000BD\n#define PFNC_U3V_COORD3D_B32F 0x012000BE\n#define PFNC_U3V_COORD3D_C32F 0x012000BF\n#define PFNC_U3V_CONFIDENCE32F 0x012000C8\n#define PFNC_U3V_YUV411_8_UYYVYY 0x020C001E\n#define PFNC_U3V_YCBCR411_8_CBYYCRYY 0x020C003C\n#define PFNC_U3V_YCBCR601_411_8_CBYYCRYY 0x020C003F\n#define PFNC_U3V_YCBCR709_411_8_CBYYCRYY 0x020C0042\n#define PFNC_U3V_YCBCR411_8 0x020C005A\n#define PFNC_U3V_YUV422_8_UYVY 0x0210001F\n#define PFNC_U3V_YUV422_8 0x02100032\n#define PFNC_U3V_RGB565P 0x02100035\n#define PFNC_U3V_BGR565P 0x02100036\n#define PFNC_U3V_YCBCR422_8 0x0210003B\n#define PFNC_U3V_YCBCR601_422_8 0x0210003E\n#define PFNC_U3V_YCBCR709_422_8 0x02100041\n#define PFNC_U3V_YCBCR422_8_CBYCRY 0x02100043\n#define PFNC_U3V_YCBCR601_422_8_CBYCRY 0x02100044\n#define PFNC_U3V_YCBCR709_422_8_CBYCRY 0x02100045\n#define PFNC_U3V_BICOLORRGBG8 0x021000A5\n#define PFNC_U3V_BICOLORBGRG8 0x021000A6\n#define PFNC_U3V_COORD3D_AC8 0x021000B4\n#define PFNC_U3V_COORD3D_AC8_PLANAR 0x021000B5\n#define PFNC_U3V_YCBCR422_10P 0x02140087\n#define PFNC_U3V_YCBCR601_422_10P 0x0214008E\n#define PFNC_U3V_YCBCR709_422_10P 0x02140096\n#define PFNC_U3V_YCBCR422_10P_CBYCRY 0x0214009A\n#define PFNC_U3V_YCBCR601_422_10P_CBYCRY 0x0214009E\n#define PFNC_U3V_YCBCR709_422_10P_CBYCRY 0x021400A2\n#define PFNC_U3V_BICOLORRGBG10P 0x021400A8\n#define PFNC_U3V_BICOLORBGRG10P 0x021400AA\n#define PFNC_U3V_COORD3D_AC10P 0x021400F0\n#define PFNC_U3V_COORD3D_AC10P_PLANAR 0x021400F1\n#define PFNC_U3V_RGB8 0x02180014\n#define PFNC_U3V_BGR8 0x02180015\n#define PFNC_U3V_YUV8_UYV 0x02180020\n#define PFNC_U3V_RGB8_PLANAR 0x02180021\n#define PFNC_U3V_YCBCR8_CBYCR 0x0218003A\n#define PFNC_U3V_YCBCR601_8_CBYCR 0x0218003D\n#define PFNC_U3V_YCBCR709_8_CBYCR 0x02180040\n#define PFNC_U3V_YCBCR8 0x0218005B\n#define PFNC_U3V_YCBCR422_12P 0x02180088\n#define PFNC_U3V_YCBCR601_422_12P 0x02180090\n#define PFNC_U3V_YCBCR709_422_12P 0x02180098\n#define PFNC_U3V_YCBCR422_12P_CBYCRY 0x0218009C\n#define PFNC_U3V_YCBCR601_422_12P_CBYCRY 0x021800A0\n#define PFNC_U3V_YCBCR709_422_12P_CBYCRY 0x021800A4\n#define PFNC_U3V_BICOLORRGBG12P 0x021800AC\n#define PFNC_U3V_BICOLORBGRG12P 0x021800AE\n#define PFNC_U3V_COORD3D_ABC8 0x021800B2\n#define PFNC_U3V_COORD3D_ABC8_PLANAR 0x021800B3\n#define PFNC_U3V_COORD3D_AC12P 0x021800F2\n#define PFNC_U3V_COORD3D_AC12P_PLANAR 0x021800F3\n#define PFNC_U3V_BGR10P 0x021E0048\n#define PFNC_U3V_RGB10P 0x021E005C\n#define PFNC_U3V_YCBCR10P_CBYCR 0x021E0084\n#define PFNC_U3V_YCBCR601_10P_CBYCR 0x021E008A\n#define PFNC_U3V_YCBCR709_10P_CBYCR 0x021E0092\n#define PFNC_U3V_COORD3D_ABC10P 0x021E00DB\n#define PFNC_U3V_COORD3D_ABC10P_PLANAR 0x021E00DC\n#define PFNC_U3V_RGBA8 0x02200016\n#define PFNC_U3V_BGRA8 0x02200017\n#define PFNC_U3V_RGB10V1PACKED 0x0220001C\n#define PFNC_U3V_RGB10P32 0x0220001D\n#define PFNC_U3V_YCBCR422_10 0x02200065\n#define PFNC_U3V_YCBCR422_12 0x02200066\n#define PFNC_U3V_YCBCR601_422_10 0x0220008D\n#define PFNC_U3V_YCBCR601_422_12 0x0220008F\n#define PFNC_U3V_YCBCR709_422_10 0x02200095\n#define PFNC_U3V_YCBCR709_422_12 0x02200097\n#define PFNC_U3V_YCBCR422_10_CBYCRY 0x02200099\n#define PFNC_U3V_YCBCR422_12_CBYCRY 0x0220009B\n#define PFNC_U3V_YCBCR601_422_10_CBYCRY 0x0220009D\n#define PFNC_U3V_YCBCR601_422_12_CBYCRY 0x0220009F\n#define PFNC_U3V_YCBCR709_422_10_CBYCRY 0x022000A1\n#define PFNC_U3V_YCBCR709_422_12_CBYCRY 0x022000A3\n#define PFNC_U3V_BICOLORRGBG10 0x022000A7\n#define PFNC_U3V_BICOLORBGRG10 0x022000A9\n#define PFNC_U3V_BICOLORRGBG12 0x022000AB\n#define PFNC_U3V_BICOLORBGRG12 0x022000AD\n#define PFNC_U3V_COORD3D_AC16 0x022000BB\n#define PFNC_U3V_COORD3D_AC16_PLANAR 0x022000BC\n#define PFNC_U3V_RGB12V1PACKED 0x02240034\n#define PFNC_U3V_BGR12P 0x02240049\n#define PFNC_U3V_RGB12P 0x0224005D\n#define PFNC_U3V_YCBCR12P_CBYCR 0x02240086\n#define PFNC_U3V_YCBCR601_12P_CBYCR 0x0224008C\n#define PFNC_U3V_YCBCR709_12P_CBYCR 0x02240094\n#define PFNC_U3V_COORD3D_ABC12P 0x022400DE\n#define PFNC_U3V_COORD3D_ABC12P_PLANAR 0x022400DF\n#define PFNC_U3V_BGRA10P 0x0228004D\n#define PFNC_U3V_RGBA10P 0x02280060\n#define PFNC_U3V_RGB10 0x02300018\n#define PFNC_U3V_BGR10 0x02300019\n#define PFNC_U3V_RGB12 0x0230001A\n#define PFNC_U3V_BGR12 0x0230001B\n#define PFNC_U3V_RGB10_PLANAR 0x02300022\n#define PFNC_U3V_RGB12_PLANAR 0x02300023\n#define PFNC_U3V_RGB16_PLANAR 0x02300024\n#define PFNC_U3V_RGB16 0x02300033\n#define PFNC_U3V_BGR14 0x0230004A\n#define PFNC_U3V_BGR16 0x0230004B\n#define PFNC_U3V_BGRA12P 0x0230004F\n#define PFNC_U3V_RGB14 0x0230005E\n#define PFNC_U3V_RGBA12P 0x02300062\n#define PFNC_U3V_YCBCR10_CBYCR 0x02300083\n#define PFNC_U3V_YCBCR12_CBYCR 0x02300085\n#define PFNC_U3V_YCBCR601_10_CBYCR 0x02300089\n#define PFNC_U3V_YCBCR601_12_CBYCR 0x0230008B\n#define PFNC_U3V_YCBCR709_10_CBYCR 0x02300091\n#define PFNC_U3V_YCBCR709_12_CBYCR 0x02300093\n#define PFNC_U3V_COORD3D_ABC16 0x023000B9\n#define PFNC_U3V_COORD3D_ABC16_PLANAR 0x023000BA\n#define PFNC_U3V_BGRA10 0x0240004C\n#define PFNC_U3V_BGRA12 0x0240004E\n#define PFNC_U3V_BGRA14 0x02400050\n#define PFNC_U3V_BGRA16 0x02400051\n#define PFNC_U3V_RGBA10 0x0240005F\n#define PFNC_U3V_RGBA12 0x02400061\n#define PFNC_U3V_RGBA14 0x02400063\n#define PFNC_U3V_RGBA16 0x02400064\n#define PFNC_U3V_COORD3D_AC32F 0x024000C2\n#define PFNC_U3V_COORD3D_AC32F_PLANAR 0x024000C3\n#define PFNC_U3V_COORD3D_ABC32F 0x026000C0\n#define PFNC_U3V_COORD3D_ABC32F_PLANAR 0x026000C1\n\n/*\n Payload Types\n*/\n#define U3V_STREAM_PAYLOAD_IMAGE            0x0001\n#define U3V_STREAM_PAYLOAD_IMAGE_EXT_CHUNK  0x4001\n#define U3V_STREAM_PAYLOAD_CHUNK            0x4000\n\nvoid proto_register_u3v(void);\nvoid proto_reg_handoff_u3v(void);\n\n/* Define the u3v protocol */\nstatic int proto_u3v = -1;\n\n/* GenCP transaction tracking\n * the protocol only allows strict sequential\n * communication.\n *\n * we track the current cmd/ack/pend_ack information\n * in a struct that is created per GenCP communication\n *\n * in each request/response packet we add pointers\n * to this information, that allow navigation between packets\n * and dissection of addresses\n */\ntypedef struct _gencp_transaction_t {\n    guint32  cmd_frame;\n    guint32  ack_frame;\n    nstime_t cmd_time;\n    /* list of pending acknowledges */\n    wmem_array_t *pend_ack_frame_list;\n    /* current requested address */\n    guint64 address;\n    /* current requested count read/write */\n    guint32 count;\n} gencp_transaction_t;\n\ntypedef struct _u3v_conv_info_t {\n    guint64 abrm_addr;\n    guint64 sbrm_addr;\n    guint64 sirm_addr;\n    guint64 eirm_addr;\n    guint64 iidc2_addr;\n    guint64 manifest_addr;\n    guint32 ep_stream;\n    gencp_transaction_t *trans_info;\n} u3v_conv_info_t;\n\n/*\n \\brief IDs used for bootstrap dissection\n*/\nstatic int hf_u3v_gencp_prefix = -1;\nstatic int hf_u3v_flag = -1;\nstatic int hf_u3v_acknowledge_required_flag = -1;\nstatic int hf_u3v_command_id = -1;\nstatic int hf_u3v_length = -1;\nstatic int hf_u3v_request_id = -1;\nstatic int hf_u3v_status = -1;\nstatic int hf_u3v_address = -1;\nstatic int hf_u3v_count = -1;\nstatic int hf_u3v_eventcmd_id = -1;\nstatic int hf_u3v_eventcmd_error_id = -1;\nstatic int hf_u3v_eventcmd_device_specific_id = -1;\nstatic int hf_u3v_eventcmd_timestamp = -1;\nstatic int hf_u3v_eventcmd_data = -1;\nstatic int hf_u3v_time_to_completion = -1;\nstatic int hf_u3v_payloaddata = -1;\nstatic int hf_u3v_reserved = -1;\n\nstatic int hf_u3v_bootstrap_GenCP_Version = -1;\nstatic int hf_u3v_bootstrap_Manufacturer_Name = -1;\nstatic int hf_u3v_bootstrap_Model_Name = -1;\nstatic int hf_u3v_bootstrap_Family_Name = -1;\nstatic int hf_u3v_bootstrap_Device_Version = -1;\nstatic int hf_u3v_bootstrap_Manufacturer_Info = -1;\nstatic int hf_u3v_bootstrap_Serial_Number = -1;\nstatic int hf_u3v_bootstrap_User_Defined_Name = -1;\nstatic int hf_u3v_bootstrap_Device_Capability = -1;\nstatic int hf_u3v_bootstrap_Maximum_Device_Response_Time = -1;\nstatic int hf_u3v_bootstrap_Manifest_Table_Address = -1;\nstatic int hf_u3v_bootstrap_SBRM_Address = -1;\nstatic int hf_u3v_bootstrap_Device_Configuration = -1;\nstatic int hf_u3v_bootstrap_Heartbeat_Timeout = -1;\nstatic int hf_u3v_bootstrap_Message_Channel_channel_id = -1;\nstatic int hf_u3v_bootstrap_Timestamp = -1;\nstatic int hf_u3v_bootstrap_Timestamp_Latch = -1;\nstatic int hf_u3v_bootstrap_Timestamp_Increment = -1;\nstatic int hf_u3v_bootstrap_Access_Privilege = -1;\nstatic int hf_u3v_bootstrap_Protocol_Endianess = -1;\nstatic int hf_u3v_bootstrap_Implementation_Endianess = -1;\nstatic int hf_u3v_bootstrap_U3V_Version = -1;\nstatic int hf_u3v_bootstrap_U3VCP_Capability_Register = -1;\nstatic int hf_u3v_bootstrap_U3VCP_Configuration_Register = -1;\nstatic int hf_u3v_bootstrap_Maximum_Command_Transfer_Length = -1;\nstatic int hf_u3v_bootstrap_Maximum_Acknowledge_Transfer_Length = -1;\nstatic int hf_u3v_bootstrap_Number_of_Stream_Channels = -1;\nstatic int hf_u3v_bootstrap_SIRM_Address = -1;\nstatic int hf_u3v_bootstrap_SIRM_Length = -1;\nstatic int hf_u3v_bootstrap_EIRM_Address = -1;\nstatic int hf_u3v_bootstrap_EIRM_Length = -1;\nstatic int hf_u3v_bootstrap_IIDC2_Address = -1;\nstatic int hf_u3v_bootstrap_Current_Speed = -1;\nstatic int hf_u3v_bootstrap_SI_Info = -1;\nstatic int hf_u3v_bootstrap_SI_Control = -1;\nstatic int hf_u3v_bootstrap_SI_Required_Payload_Size = -1;\nstatic int hf_u3v_bootstrap_SI_Required_Leader_Size = -1;\nstatic int hf_u3v_bootstrap_SI_Required_Trailer_Size = -1;\nstatic int hf_u3v_bootstrap_SI_Maximum_Leader_Size = -1;\nstatic int hf_u3v_bootstrap_SI_Payload_Transfer_Size = -1;\nstatic int hf_u3v_bootstrap_SI_Payload_Transfer_Count = -1;\nstatic int hf_u3v_bootstrap_SI_Payload_Final_Transfer1_Size = -1;\nstatic int hf_u3v_bootstrap_SI_Payload_Final_Transfer2_Size = -1;\nstatic int hf_u3v_bootstrap_SI_Maximum_Trailer_Size = -1;\nstatic int hf_u3v_bootstrap_EI_Control = -1;\nstatic int hf_u3v_bootstrap_Maximum_Event_Transfer_Length = -1;\nstatic int hf_u3v_bootstrap_Event_Test_Control = -1;\nstatic int hf_u3v_custom_memory_addr = -1;\nstatic int hf_u3v_custom_memory_data = -1;\n\nstatic int hf_u3v_scd_readmem_cmd = -1;\nstatic int hf_u3v_scd_writemem_cmd = -1;\nstatic int hf_u3v_scd_event_cmd = -1;\nstatic int hf_u3v_scd_ack_readmem_ack = -1;\nstatic int hf_u3v_scd_writemem_ack = -1;\nstatic int hf_u3v_ccd_pending_ack = -1;\nstatic int hf_u3v_stream_leader = -1;\nstatic int hf_u3v_stream_trailer = -1;\nstatic int hf_u3v_stream_payload = -1;\nstatic int hf_u3v_ccd_cmd = -1;\nstatic int hf_u3v_ccd_ack = -1;\nstatic int hf_u3v_device_info_descriptor = -1;\n\n/* stream elements */\nstatic int hf_u3v_stream_reserved = -1;\nstatic int hf_u3v_stream_leader_size = -1;\n\nstatic int hf_u3v_stream_prefix = -1;\nstatic int hf_u3v_stream_trailer_size = -1;\n\nstatic int hf_u3v_stream_block_id = -1;\nstatic int hf_u3v_stream_payload_type = -1;\nstatic int hf_u3v_stream_status = -1;\nstatic int hf_u3v_stream_valid_payload_size = -1;\n\nstatic int hf_u3v_stream_timestamp = -1;\nstatic int hf_u3v_stream_pixel_format = -1;\nstatic int hf_u3v_stream_size_x = -1;\nstatic int hf_u3v_stream_size_y = -1;\nstatic int hf_u3v_stream_offset_x = -1;\nstatic int hf_u3v_stream_offset_y = -1;\nstatic int hf_u3v_stream_padding_x = -1;\nstatic int hf_u3v_stream_chunk_layout_id = -1;\n\nstatic int hf_u3v_stream_data = -1;\n\n/* U3V device info descriptor */\nstatic int hf_u3v_device_info_descriptor_bLength = -1;\nstatic int hf_u3v_device_info_descriptor_bDescriptorType = -1;\nstatic int hf_u3v_device_info_descriptor_bDescriptorSubtype = -1;\nstatic int hf_u3v_device_info_descriptor_bGenCPVersion = -1;\nstatic int hf_u3v_device_info_descriptor_bGenCPVersion_minor = -1;\nstatic int hf_u3v_device_info_descriptor_bGenCPVersion_major = -1;\nstatic int hf_u3v_device_info_descriptor_bU3VVersion = -1;\nstatic int hf_u3v_device_info_descriptor_bU3VVersion_minor = -1;\nstatic int hf_u3v_device_info_descriptor_bU3VVersion_major = -1;\nstatic int hf_u3v_device_info_descriptor_iDeviceGUID = -1;\nstatic int hf_u3v_device_info_descriptor_iVendorName = -1;\nstatic int hf_u3v_device_info_descriptor_iModelName = -1;\nstatic int hf_u3v_device_info_descriptor_iFamilyName = -1;\nstatic int hf_u3v_device_info_descriptor_iDeviceVersion = -1;\nstatic int hf_u3v_device_info_descriptor_iManufacturerInfo = -1;\nstatic int hf_u3v_device_info_descriptor_iSerialNumber = -1;\nstatic int hf_u3v_device_info_descriptor_iUserDefinedName = -1;\nstatic int hf_u3v_device_info_descriptor_bmSpeedSupport = -1;\nstatic int hf_u3v_device_info_descriptor_bmSpeedSupport_low_speed = -1;\nstatic int hf_u3v_device_info_descriptor_bmSpeedSupport_full_speed = -1;\nstatic int hf_u3v_device_info_descriptor_bmSpeedSupport_high_speed = -1;\nstatic int hf_u3v_device_info_descriptor_bmSpeedSupport_super_speed = -1;\nstatic int hf_u3v_device_info_descriptor_bmSpeedSupport_reserved = -1;\n\n/*Define the tree for u3v*/\nstatic int ett_u3v = -1;\nstatic int ett_u3v_cmd = -1;\nstatic int ett_u3v_flags = -1;\nstatic int ett_u3v_ack = -1;\nstatic int ett_u3v_payload_cmd = -1;\nstatic int ett_u3v_payload_ack = -1;\nstatic int ett_u3v_payload_cmd_subtree = -1;\nstatic int ett_u3v_payload_ack_subtree = -1;\nstatic int ett_u3v_bootstrap_fields = -1;\nstatic int ett_u3v_stream_leader = -1;\nstatic int ett_u3v_stream_trailer = -1;\nstatic int ett_u3v_stream_payload = -1;\n\nstatic int ett_u3v_device_info_descriptor = -1;\nstatic int ett_u3v_device_info_descriptor_speed_support = -1;\nstatic int ett_u3v_device_info_descriptor_gencp_version = -1;\nstatic int ett_u3v_device_info_descriptor_u3v_version = -1;\n\nstatic const value_string command_names[] =\n{\n    { U3V_READMEM_CMD, \"READMEM_CMD\" },\n    { U3V_WRITEMEM_CMD, \"WRITEMEM_CMD\" },\n    { U3V_EVENT_CMD, \"EVENT_CMD\" },\n    { U3V_READMEM_ACK, \"READMEM_ACK\" },\n    { U3V_WRITEMEM_ACK, \"WRITEMEM_ACK\" },\n    { U3V_PENDING_ACK, \"PENDING_ACK\" },\n    { U3V_EVENT_ACK, \"EVENT_ACK\" },\n    { 0, NULL }\n};\n\nstatic const value_string event_id_names[] =\n{\n    { U3V_EVENT_TESTEVENT, \"U3V_EVENT_TESTEVENT\" },\n    { 0, NULL }\n};\n\nstatic const value_string status_names[] =\n{\n    { U3V_STATUS_GENCP_SUCCESS, \"U3V_STATUS_GENCP_SUCCESS\" },\n    { U3V_STATUS_GENCP_NOT_IMPLEMENTED, \"U3V_STATUS_GENCP_NOT_IMPLEMENTED\" },\n    { U3V_STATUS_GENCP_INVALID_PARAMETER, \"U3V_STATUS_GENCP_INVALID_PARAMETER\" },\n    { U3V_STATUS_GENCP_INVALID_ADDRESS, \"U3V_STATUS_GENCP_INVALID_ADDRESS\" },\n    { U3V_STATUS_GENCP_WRITE_PROTECT, \"U3V_STATUS_GENCP_WRITE_PROTECT\" },\n    { U3V_STATUS_GENCP_BAD_ALIGNMENT, \"U3V_STATUS_GENCP_BAD_ALIGNMENT\" },\n    { U3V_STATUS_GENCP_ACCESS_DENIED, \"U3V_STATUS_GENCP_ACCESS_DENIED\" },\n    { U3V_STATUS_GENCP_BUSY, \"U3V_STATUS_GENCP_BUSY\" },\n    { U3V_STATUS_GENCP_WRONG_CONFIG, \"U3V_STATUS_GENCP_WRONG_CONFIG\" },\n    { U3V_STATUS_RESEND_NOT_SUPPORTED, \"U3V_STATUS_RESEND_NOT_SUPPORTED\" },\n    { U3V_STATUS_DSI_ENDPOINT_HALTED, \"U3V_STATUS_DSI_ENDPOINT_HALTED\" },\n    { U3V_STATUS_SI_PAYLOAD_SIZE_NOT_ALIGNED, \"U3V_STATUS_SI_PAYLOAD_SIZE_NOT_ALIGNED\" },\n    { U3V_STATUS_SI_REGISTERS_INCONSISTENT, \"U3V_STATUS_SI_REGISTERS_INCONSISTENT\" },\n    { U3V_STATUS_DATA_DISCARDED, \"U3V_STATUS_DATA_DISCARDED\" },\n    { 0, NULL }\n};\n\nstatic const value_string status_names_short[] =\n{\n    { U3V_STATUS_GENCP_SUCCESS, \"\" },\n    { U3V_STATUS_GENCP_NOT_IMPLEMENTED, \"U3V_STATUS_GENCP_NOT_IMPLEMENTED\" },\n    { U3V_STATUS_GENCP_INVALID_PARAMETER, \"U3V_STATUS_GENCP_INVALID_PARAMETER\" },\n    { U3V_STATUS_GENCP_INVALID_ADDRESS, \"U3V_STATUS_GENCP_INVALID_ADDRESS\" },\n    { U3V_STATUS_GENCP_WRITE_PROTECT, \"U3V_STATUS_GENCP_WRITE_PROTECT\" },\n    { U3V_STATUS_GENCP_BAD_ALIGNMENT, \"U3V_STATUS_GENCP_BAD_ALIGNMENT\" },\n    { U3V_STATUS_GENCP_ACCESS_DENIED, \"U3V_STATUS_GENCP_ACCESS_DENIED\" },\n    { U3V_STATUS_GENCP_BUSY, \"U3V_STATUS_GENCP_BUSY\" },\n    { U3V_STATUS_GENCP_WRONG_CONFIG, \"U3V_STATUS_GENCP_WRONG_CONFIG\" },\n    { U3V_STATUS_RESEND_NOT_SUPPORTED, \"U3V_STATUS_RESEND_NOT_SUPPORTED\" },\n    { U3V_STATUS_DSI_ENDPOINT_HALTED, \"U3V_STATUS_DSI_ENDPOINT_HALTED\" },\n    { U3V_STATUS_SI_PAYLOAD_SIZE_NOT_ALIGNED, \"U3V_STATUS_SI_PAYLOAD_SIZE_NOT_ALIGNED\" },\n    { U3V_STATUS_SI_REGISTERS_INCONSISTENT, \"U3V_STATUS_SI_REGISTERS_INCONSISTENT\" },\n    { U3V_STATUS_DATA_DISCARDED, \"U3V_STATUS_DATA_DISCARDED\" },\n    { 0, NULL }\n};\n\n/*\n \\brief Register name to address mappings\n */\nstatic const value_string bootstrap_register_names_abrm[] =\n{\n    { U3V_ABRM_GENCP_VERSION, \"[GenCP_Version]\" },\n    { U3V_ABRM_MANUFACTURER_NAME, \"[Manufacturer_Name]\" },\n    { U3V_ABRM_MODEL_NAME, \"[Model_Name]\" },\n    { U3V_ABRM_FAMILY_NAME, \"[Family_Name]\" },\n    { U3V_ABRM_DEVICE_VERSION, \"[Device_Version]\" },\n    { U3V_ABRM_MANUFACTURER_INFO, \"[Manufacturer_Info]\" },\n    { U3V_ABRM_SERIAL_NUMBER, \"[Serial_Number]\" },\n    { U3V_ABRM_USER_DEFINED_NAME, \"[User_Defined_Name]\" },\n    { U3V_ABRM_DEVICE_CAPABILITY, \"[Device_Capability]\" },\n    { U3V_ABRM_MAXIMUM_DEVICE_RESPONSE_TIME, \"[Maximum_Device_Response_Time]\" },\n    { U3V_ABRM_MANIFEST_TABLE_ADDRESS, \"[Manifest_Table_Address]\" },\n    { U3V_ABRM_SBRM_ADDRESS, \"[SBRM_Address]\" },\n    { U3V_ABRM_DEVICE_CONFIGURATION, \"[Device_Configuration]\" },\n    { U3V_ABRM_HEARTBEAT_TIMEOUT, \"[Heartbeat_Timeout]\" },\n    { U3V_ABRM_MESSAGE_CHANNEL_CHANNEL_ID, \"[Message_Channel_channel_id]\" },\n    { U3V_ABRM_TIMESTAMP, \"[Timestamp]\" },\n    { U3V_ABRM_TIMESTAMP_LATCH, \"[Timestamp_Latch]\" },\n    { U3V_ABRM_TIMESTAMP_INCREMENT, \"[Timestamp_Increment]\" },\n    { U3V_ABRM_ACCESS_PRIVILEGE, \"[Access_Privilege]\" },\n    { U3V_ABRM_PROTOCOL_ENDIANESS, \"[Protocol_Endianess]\" },\n    { U3V_ABRM_IMPLEMENTATION_ENDIANESS, \"[Implementation_Endianess]\" },\n    { 0, NULL }\n};\n\nstatic const value_string bootstrap_register_names_sbrm[] =\n{\n    { U3V_SBRM_U3V_VERSION, \"[U3V_Version]\" },\n    { U3V_SBRM_U3VCP_CAPABILITY_REGISTER, \"[U3VCP_Capability_Register]\" },\n    { U3V_SBRM_U3VCP_CONFIGURATION_REGISTER, \"[U3VCP_Configuration_Register]\" },\n    { U3V_SBRM_MAXIMUM_COMMAND_TRANSFER_LENGTH, \"[Maximum_Command_Transfer_Length]\" },\n    { U3V_SBRM_MAXIMUM_ACKNOWLEDGE_TRANSFER_LENGTH, \"[Maximum_Acknowledge_Transfer_Length]\" },\n    { U3V_SBRM_NUMBER_OF_STREAM_CHANNELS, \"[Number_of_Stream_Channels]\" },\n    { U3V_SBRM_SIRM_ADDRESS, \"[SIRM_Address]\" },\n    { U3V_SBRM_SIRM_LENGTH, \"[SIRM_Length]\" },\n    { U3V_SBRM_EIRM_ADDRESS, \"[EIRM_Address]\" },\n    { U3V_SBRM_EIRM_LENGTH, \"[EIRM_Length]\" },\n    { U3V_SBRM_IIDC2_ADDRESS, \"[IIDC2_Address]\" },\n    { U3V_SBRM_CURRENT_SPEED, \"[Current_Speed]\" },\n    { 0, NULL }\n};\n\nstatic const value_string bootstrap_register_names_sirm[] =\n{\n    { U3V_SIRM_SI_INFO, \"[SI_Info]\" },\n    { U3V_SIRM_SI_CONTROL, \"[SI_Control]\" },\n    { U3V_SIRM_SI_REQUIRED_PAYLOAD_SIZE, \"[SI_Required_Payload_Size]\" },\n    { U3V_SIRM_SI_REQUIRED_LEADER_SIZE, \"[SI_Required_Leader_Size]\" },\n    { U3V_SIRM_SI_REQUIRED_TRAILER_SIZE, \"[SI_Required_Trailer_Size]\" },\n    { U3V_SIRM_SI_MAXIMUM_LEADER_SIZE, \"[SI_Maximum_Leader_Size]\" },\n    { U3V_SIRM_SI_PAYLOAD_TRANSFER_SIZE, \"[SI_Payload_Transfer_Size]\" },\n    { U3V_SIRM_SI_PAYLOAD_TRANSFER_COUNT, \"[SI_Payload_Transfer_Count]\" },\n    { U3V_SIRM_SI_PAYLOAD_FINAL_TRANSFER1_SIZE, \"[SI_Payload_Final_Transfer1_Size]\" },\n    { U3V_SIRM_SI_PAYLOAD_FINAL_TRANSFER2_SIZE, \"[SI_Payload_Final_Transfer2_Size]\" },\n    { U3V_SIRM_SI_MAXIMUM_TRAILER_SIZE, \"[SI_Maximum_Trailer_Size]\" },\n    { 0, NULL }\n};\n\nstatic const value_string bootstrap_register_names_eirm[] =\n{\n    { U3V_EIRM_EI_CONTROL, \"[EI_Control]\" },\n    { U3V_EIRM_MAXIMUM_EVENT_TRANSFER_LENGTH, \"[Maximum_Event_Transfer_Length]\" },\n    { U3V_EIRM_EVENT_TEST_CONTROL, \"[Event_Test_Control]\" },\n    { 0, NULL }\n};\n\nstatic const value_string pixel_format_names[] =\n{\n    { PFNC_U3V_MONO1P, \"Mono1p\" },\n    { PFNC_U3V_CONFIDENCE1P, \"CONFIDENCE1p\" },\n    { PFNC_U3V_MONO2P, \"Mono2p\" },\n    { PFNC_U3V_MONO4P, \"Mono4p\" },\n    { PFNC_U3V_MONO8, \"Mono8\" },\n    { PFNC_U3V_MONO8S, \"Mono8s\" },\n    { PFNC_U3V_BAYERGR8, \"BayerGR8\" },\n    { PFNC_U3V_BAYERRG8, \"BayerRG8\" },\n    { PFNC_U3V_BAYERGB8, \"BayerGB8\" },\n    { PFNC_U3V_BAYERBG8, \"BayerBG8\" },\n    { PFNC_U3V_SCF1WBWG8, \"SCF1WBWG8\" },\n    { PFNC_U3V_SCF1WGWB8, \"SCF1WGWB8\" },\n    { PFNC_U3V_SCF1WGWR8, \"SCF1WGWR8\" },\n    { PFNC_U3V_SCF1WRWG8, \"SCF1WRWG8\" },\n    { PFNC_U3V_COORD3D_A8, \"Coord3D_A8\" },\n    { PFNC_U3V_COORD3D_B8, \"Coord3D_B8\" },\n    { PFNC_U3V_COORD3D_C8, \"Coord3D_C8\" },\n    { PFNC_U3V_CONFIDENCE1, \"CONFIDENCE1\" },\n    { PFNC_U3V_CONFIDENCE8, \"CONFIDENCE8\" },\n    { PFNC_U3V_R8, \"R8\" },\n    { PFNC_U3V_G8, \"G8\" },\n    { PFNC_U3V_B8, \"B8\" },\n    { PFNC_U3V_MONO10P, \"Mono10p\" },\n    { PFNC_U3V_BAYERBG10P, \"BayerBG10p\" },\n    { PFNC_U3V_BAYERGB10P, \"BayerGB10p\" },\n    { PFNC_U3V_BAYERGR10P, \"BayerGR10p\" },\n    { PFNC_U3V_BAYERRG10P, \"BayerRG10p\" },\n    { PFNC_U3V_SCF1WBWG10P, \"SCF1WBWG10p\" },\n    { PFNC_U3V_SCF1WGWB10P, \"SCF1WGWB10p\" },\n    { PFNC_U3V_SCF1WGWR10P, \"SCF1WGWR10p\" },\n    { PFNC_U3V_SCF1WRWG10P, \"SCF1WRWG10p\" },\n    { PFNC_U3V_R10, \"R10\" },\n    { PFNC_U3V_G10, \"G10\" },\n    { PFNC_U3V_B10, \"B10\" },\n    { PFNC_U3V_COORD3D_A10P, \"Coord3D_A10p\" },\n    { PFNC_U3V_COORD3D_B10P, \"Coord3D_B10p\" },\n    { PFNC_U3V_COORD3D_C10P, \"Coord3D_C10p\" },\n    { PFNC_U3V_MONO10PACKED, \"Mono10Packed\" },\n    { PFNC_U3V_MONO12PACKED, \"Mono12Packed\" },\n    { PFNC_U3V_BAYERGR10PACKED, \"BayerGR10Packed\" },\n    { PFNC_U3V_BAYERRG10PACKED, \"BayerRG10Packed\" },\n    { PFNC_U3V_BAYERGB10PACKED, \"BayerGB10Packed\" },\n    { PFNC_U3V_BAYERBG10PACKED, \"BayerBG10Packed\" },\n    { PFNC_U3V_BAYERGR12PACKED, \"BayerGR12Packed\" },\n    { PFNC_U3V_BAYERRG12PACKED, \"BayerRG12Packed\" },\n    { PFNC_U3V_BAYERGB12PACKED, \"BayerGB12Packed\" },\n    { PFNC_U3V_BAYERBG12PACKED, \"BayerBG12Packed\" },\n    { PFNC_U3V_MONO12P, \"Mono12p\" },\n    { PFNC_U3V_BAYERBG12P, \"BayerBG12p\" },\n    { PFNC_U3V_BAYERGB12P, \"BayerGB12p\" },\n    { PFNC_U3V_BAYERGR12P, \"BayerGR12p\" },\n    { PFNC_U3V_BAYERRG12P, \"BayerRG12p\" },\n    { PFNC_U3V_SCF1WBWG12P, \"SCF1WBWG12p\" },\n    { PFNC_U3V_SCF1WGWB12P, \"SCF1WGWB12p\" },\n    { PFNC_U3V_SCF1WGWR12P, \"SCF1WGWR12p\" },\n    { PFNC_U3V_SCF1WRWG12P, \"SCF1WRWG12p\" },\n    { PFNC_U3V_R12, \"R12\" },\n    { PFNC_U3V_G12, \"G12\" },\n    { PFNC_U3V_B12, \"B12\" },\n    { PFNC_U3V_COORD3D_A12P, \"Coord3D_A12p\" },\n    { PFNC_U3V_COORD3D_B12P, \"Coord3D_B12p\" },\n    { PFNC_U3V_COORD3D_C12P, \"Coord3D_C12p\" },\n    { PFNC_U3V_MONO10, \"Mono10\" },\n    { PFNC_U3V_MONO12, \"Mono12\" },\n    { PFNC_U3V_MONO16, \"Mono16\" },\n    { PFNC_U3V_BAYERGR10, \"BayerGR10\" },\n    { PFNC_U3V_BAYERRG10, \"BayerRG10\" },\n    { PFNC_U3V_BAYERGB10, \"BayerGB10\" },\n    { PFNC_U3V_BAYERBG10, \"BayerBG10\" },\n    { PFNC_U3V_BAYERGR12, \"BayerGR12\" },\n    { PFNC_U3V_BAYERRG12, \"BayerRG12\" },\n    { PFNC_U3V_BAYERGB12, \"BayerGB12\" },\n    { PFNC_U3V_BAYERBG12, \"BayerBG12\" },\n    { PFNC_U3V_MONO14, \"Mono14\" },\n    { PFNC_U3V_BAYERGR16, \"BayerGR16\" },\n    { PFNC_U3V_BAYERRG16, \"BayerRG16\" },\n    { PFNC_U3V_BAYERGB16, \"BayerGB16\" },\n    { PFNC_U3V_BAYERBG16, \"BayerBG16\" },\n    { PFNC_U3V_SCF1WBWG10, \"SCF1WBWG10\" },\n    { PFNC_U3V_SCF1WBWG12, \"SCF1WBWG12\" },\n    { PFNC_U3V_SCF1WBWG14, \"SCF1WBWG14\" },\n    { PFNC_U3V_SCF1WBWG16, \"SCF1WBWG16\" },\n    { PFNC_U3V_SCF1WGWB10, \"SCF1WGWB10\" },\n    { PFNC_U3V_SCF1WGWB12, \"SCF1WGWB12\" },\n    { PFNC_U3V_SCF1WGWB14, \"SCF1WGWB14\" },\n    { PFNC_U3V_SCF1WGWB16, \"SCF1WGWB16\" },\n    { PFNC_U3V_SCF1WGWR10, \"SCF1WGWR10\" },\n    { PFNC_U3V_SCF1WGWR12, \"SCF1WGWR12\" },\n    { PFNC_U3V_SCF1WGWR14, \"SCF1WGWR14\" },\n    { PFNC_U3V_SCF1WGWR16, \"SCF1WGWR16\" },\n    { PFNC_U3V_SCF1WRWG10, \"SCF1WRWG10\" },\n    { PFNC_U3V_SCF1WRWG12, \"SCF1WRWG12\" },\n    { PFNC_U3V_SCF1WRWG14, \"SCF1WRWG14\" },\n    { PFNC_U3V_SCF1WRWG16, \"SCF1WRWG16\" },\n    { PFNC_U3V_COORD3D_A16, \"Coord3D_A16\" },\n    { PFNC_U3V_COORD3D_B16, \"Coord3D_B16\" },\n    { PFNC_U3V_COORD3D_C16, \"Coord3D_C16\" },\n    { PFNC_U3V_CONFIDENCE16, \"CONFIDENCE16\" },\n    { PFNC_U3V_R16, \"R16\" },\n    { PFNC_U3V_G16, \"G16\" },\n    { PFNC_U3V_B16, \"B16\" },\n    { PFNC_U3V_COORD3D_A32F, \"Coord3D_A32F\" },\n    { PFNC_U3V_COORD3D_B32F, \"Coord3D_B32F\" },\n    { PFNC_U3V_COORD3D_C32F, \"Coord3D_C32F\" },\n    { PFNC_U3V_CONFIDENCE32F, \"CONFIDENCE32F\" },\n    { PFNC_U3V_YUV411_8_UYYVYY, \"YUV411_8_UYYVYY\" },\n    { PFNC_U3V_YCBCR411_8_CBYYCRYY, \"YCbCr411_8_CBYYCRYY\" },\n    { PFNC_U3V_YCBCR601_411_8_CBYYCRYY, \"YCbCr601_411_8_CBYYCRYY\" },\n    { PFNC_U3V_YCBCR709_411_8_CBYYCRYY, \"YCbCr709_411_8_CBYYCRYY\" },\n    { PFNC_U3V_YCBCR411_8, \"YCbCr411_8\" },\n    { PFNC_U3V_YUV422_8_UYVY, \"YUV422_8_UYVY\" },\n    { PFNC_U3V_YUV422_8, \"YUV422_8\" },\n    { PFNC_U3V_RGB565P, \"RGB565p\" },\n    { PFNC_U3V_BGR565P, \"BGR565p\" },\n    { PFNC_U3V_YCBCR422_8, \"YCbCr422_8\" },\n    { PFNC_U3V_YCBCR601_422_8, \"YCbCr601_422_8\" },\n    { PFNC_U3V_YCBCR709_422_8, \"YCbCr709_422_8\" },\n    { PFNC_U3V_YCBCR422_8_CBYCRY, \"YCbCr422_8_CBYCRY\" },\n    { PFNC_U3V_YCBCR601_422_8_CBYCRY, \"YCbCr601_422_8_CBYCRY\" },\n    { PFNC_U3V_YCBCR709_422_8_CBYCRY, \"YCbCr709_422_8_CBYCRY\" },\n    { PFNC_U3V_BICOLORRGBG8, \"BICOLORRGBG8\" },\n    { PFNC_U3V_BICOLORBGRG8, \"BICOLORBGRG8\" },\n    { PFNC_U3V_COORD3D_AC8, \"Coord3D_AC8\" },\n    { PFNC_U3V_COORD3D_AC8_PLANAR, \"Coord3D_AC8_Planar\" },\n    { PFNC_U3V_YCBCR422_10P, \"YCbCr422_10p\" },\n    { PFNC_U3V_YCBCR601_422_10P, \"YCbCr601_422_10p\" },\n    { PFNC_U3V_YCBCR709_422_10P, \"YCbCr709_422_10p\" },\n    { PFNC_U3V_YCBCR422_10P_CBYCRY, \"YCbCr422_10P_CBYCRY\" },\n    { PFNC_U3V_YCBCR601_422_10P_CBYCRY, \"YCbCr601_422_10P_CBYCRY\" },\n    { PFNC_U3V_YCBCR709_422_10P_CBYCRY, \"YCbCr709_422_10P_CBYCRY\" },\n    { PFNC_U3V_BICOLORRGBG10P, \"BICOLORRGBG10p\" },\n    { PFNC_U3V_BICOLORBGRG10P, \"BICOLORBGRG10p\" },\n    { PFNC_U3V_COORD3D_AC10P, \"Coord3D_AC10p\" },\n    { PFNC_U3V_COORD3D_AC10P_PLANAR, \"Coord3D_AC10P_Planar\" },\n    { PFNC_U3V_RGB8, \"RGB8\" },\n    { PFNC_U3V_BGR8, \"BGR8\" },\n    { PFNC_U3V_YUV8_UYV, \"YUV8_UYV\" },\n    { PFNC_U3V_RGB8_PLANAR, \"RGB8_Planar\" },\n    { PFNC_U3V_YCBCR8_CBYCR, \"YCbCr8_CBYCR\" },\n    { PFNC_U3V_YCBCR601_8_CBYCR, \"YCbCr601_8_CBYCR\" },\n    { PFNC_U3V_YCBCR709_8_CBYCR, \"YCbCr709_8_CBYCR\" },\n    { PFNC_U3V_YCBCR8, \"YCbCr8\" },\n    { PFNC_U3V_YCBCR422_12P, \"YCbCr422_12p\" },\n    { PFNC_U3V_YCBCR601_422_12P, \"YCbCr601_422_12p\" },\n    { PFNC_U3V_YCBCR709_422_12P, \"YCbCr709_422_12p\" },\n    { PFNC_U3V_YCBCR422_12P_CBYCRY, \"YCbCr422_12P_CBYCRY\" },\n    { PFNC_U3V_YCBCR601_422_12P_CBYCRY, \"YCbCr601_422_12P_CBYCRY\" },\n    { PFNC_U3V_YCBCR709_422_12P_CBYCRY, \"YCbCr709_422_12P_CBYCRY\" },\n    { PFNC_U3V_BICOLORRGBG12P, \"BICOLORRGBG12p\" },\n    { PFNC_U3V_BICOLORBGRG12P, \"BICOLORBGRG12p\" },\n    { PFNC_U3V_COORD3D_ABC8, \"Coord3D_ABC8\" },\n    { PFNC_U3V_COORD3D_ABC8_PLANAR, \"Coord3D_ABC8_Planar\" },\n    { PFNC_U3V_COORD3D_AC12P, \"Coord3D_AC12p\" },\n    { PFNC_U3V_COORD3D_AC12P_PLANAR, \"Coord3D_AC12P_Planar\" },\n    { PFNC_U3V_BGR10P, \"BGR10p\" },\n    { PFNC_U3V_RGB10P, \"RGB10p\" },\n    { PFNC_U3V_YCBCR10P_CBYCR, \"YCbCr10P_CBYCR\" },\n    { PFNC_U3V_YCBCR601_10P_CBYCR, \"YCbCr601_10P_CBYCR\" },\n    { PFNC_U3V_YCBCR709_10P_CBYCR, \"YCbCr709_10P_CBYCR\" },\n    { PFNC_U3V_COORD3D_ABC10P, \"Coord3D_ABC10p\" },\n    { PFNC_U3V_COORD3D_ABC10P_PLANAR, \"Coord3D_ABC10P_Planar\" },\n    { PFNC_U3V_RGBA8, \"RGBA8\" },\n    { PFNC_U3V_BGRA8, \"BGRA8\" },\n    { PFNC_U3V_RGB10V1PACKED, \"RGB10V1Packed\" },\n    { PFNC_U3V_RGB10P32, \"RGB10P32\" },\n    { PFNC_U3V_YCBCR422_10, \"YCbCr422_10\" },\n    { PFNC_U3V_YCBCR422_12, \"YCbCr422_12\" },\n    { PFNC_U3V_YCBCR601_422_10, \"YCbCr601_422_10\" },\n    { PFNC_U3V_YCBCR601_422_12, \"YCbCr601_422_12\" },\n    { PFNC_U3V_YCBCR709_422_10, \"YCbCr709_422_10\" },\n    { PFNC_U3V_YCBCR709_422_12, \"YCbCr709_422_12\" },\n    { PFNC_U3V_YCBCR422_10_CBYCRY, \"YCbCr422_10_CBYCRY\" },\n    { PFNC_U3V_YCBCR422_12_CBYCRY, \"YCbCr422_12_CBYCRY\" },\n    { PFNC_U3V_YCBCR601_422_10_CBYCRY, \"YCbCr601_422_10_CBYCRY\" },\n    { PFNC_U3V_YCBCR601_422_12_CBYCRY, \"YCbCr601_422_12_CBYCRY\" },\n    { PFNC_U3V_YCBCR709_422_10_CBYCRY, \"YCbCr709_422_10_CBYCRY\" },\n    { PFNC_U3V_YCBCR709_422_12_CBYCRY, \"YCbCr709_422_12_CBYCRY\" },\n    { PFNC_U3V_BICOLORRGBG10, \"BICOLORRGBG10\" },\n    { PFNC_U3V_BICOLORBGRG10, \"BICOLORBGRG10\" },\n    { PFNC_U3V_BICOLORRGBG12, \"BICOLORRGBG12\" },\n    { PFNC_U3V_BICOLORBGRG12, \"BICOLORBGRG12\" },\n    { PFNC_U3V_COORD3D_AC16, \"Coord3D_AC16\" },\n    { PFNC_U3V_COORD3D_AC16_PLANAR, \"Coord3D_AC16_Planar\" },\n    { PFNC_U3V_RGB12V1PACKED, \"RGB12V1Packed\" },\n    { PFNC_U3V_BGR12P, \"BGR12p\" },\n    { PFNC_U3V_RGB12P, \"RGB12p\" },\n    { PFNC_U3V_YCBCR12P_CBYCR, \"YCbCr12P_CBYCR\" },\n    { PFNC_U3V_YCBCR601_12P_CBYCR, \"YCbCr601_12P_CBYCR\" },\n    { PFNC_U3V_YCBCR709_12P_CBYCR, \"YCbCr709_12P_CBYCR\" },\n    { PFNC_U3V_COORD3D_ABC12P, \"Coord3D_ABC12p\" },\n    { PFNC_U3V_COORD3D_ABC12P_PLANAR, \"Coord3D_ABC12P_Planar\" },\n    { PFNC_U3V_BGRA10P, \"BGRA10p\" },\n    { PFNC_U3V_RGBA10P, \"RGBA10p\" },\n    { PFNC_U3V_RGB10, \"RGB10\" },\n    { PFNC_U3V_BGR10, \"BGR10\" },\n    { PFNC_U3V_RGB12, \"RGB12\" },\n    { PFNC_U3V_BGR12, \"BGR12\" },\n    { PFNC_U3V_RGB10_PLANAR, \"RGB10_Planar\" },\n    { PFNC_U3V_RGB12_PLANAR, \"RGB12_Planar\" },\n    { PFNC_U3V_RGB16_PLANAR, \"RGB16_Planar\" },\n    { PFNC_U3V_RGB16, \"RGB16\" },\n    { PFNC_U3V_BGR14, \"BGR14\" },\n    { PFNC_U3V_BGR16, \"BGR16\" },\n    { PFNC_U3V_BGRA12P, \"BGRA12p\" },\n    { PFNC_U3V_RGB14, \"RGB14\" },\n    { PFNC_U3V_RGBA12P, \"RGBA12p\" },\n    { PFNC_U3V_YCBCR10_CBYCR, \"YCbCr10_CBYCR\" },\n    { PFNC_U3V_YCBCR12_CBYCR, \"YCbCr12_CBYCR\" },\n    { PFNC_U3V_YCBCR601_10_CBYCR, \"YCbCr601_10_CBYCR\" },\n    { PFNC_U3V_YCBCR601_12_CBYCR, \"YCbCr601_12_CBYCR\" },\n    { PFNC_U3V_YCBCR709_10_CBYCR, \"YCbCr709_10_CBYCR\" },\n    { PFNC_U3V_YCBCR709_12_CBYCR, \"YCbCr709_12_CBYCR\" },\n    { PFNC_U3V_COORD3D_ABC16, \"Coord3D_ABC16\" },\n    { PFNC_U3V_COORD3D_ABC16_PLANAR, \"Coord3D_ABC16_Planar\" },\n    { PFNC_U3V_BGRA10, \"BGRA10\" },\n    { PFNC_U3V_BGRA12, \"BGRA12\" },\n    { PFNC_U3V_BGRA14, \"BGRA14\" },\n    { PFNC_U3V_BGRA16, \"BGRA16\" },\n    { PFNC_U3V_RGBA10, \"RGBA10\" },\n    { PFNC_U3V_RGBA12, \"RGBA12\" },\n    { PFNC_U3V_RGBA14, \"RGBA14\" },\n    { PFNC_U3V_RGBA16, \"RGBA16\" },\n    { PFNC_U3V_COORD3D_AC32F, \"Coord3D_AC32F\" },\n    { PFNC_U3V_COORD3D_AC32F_PLANAR, \"Coord3D_AC32F_Planar\" },\n    { PFNC_U3V_COORD3D_ABC32F, \"Coord3D_ABC32F\" },\n    { PFNC_U3V_COORD3D_ABC32F_PLANAR, \"Coord3D_ABC32F_Planar\" },\n    { 0, NULL }\n};\n\nstatic value_string_ext pixel_format_names_ext = VALUE_STRING_EXT_INIT(pixel_format_names);\n\n\nstatic const value_string payload_type_names[] =\n{\n    { U3V_STREAM_PAYLOAD_IMAGE, \"Image\" },\n    { U3V_STREAM_PAYLOAD_IMAGE_EXT_CHUNK, \"Image Extended Chunk\" },\n    { U3V_STREAM_PAYLOAD_CHUNK, \"Chunk\" },\n    { 0, NULL }\n};\n\nstatic const value_string u3v_descriptor_subtypes[] =\n{\n    { DESCRIPTOR_SUBTYPE_U3V_DEVICE_INFO, \"U3V DEVICE INFO\" },\n    { 0, NULL }\n};\n\nstatic const int *speed_support_fields[] = {\n    &hf_u3v_device_info_descriptor_bmSpeedSupport_low_speed,\n    &hf_u3v_device_info_descriptor_bmSpeedSupport_full_speed,\n    &hf_u3v_device_info_descriptor_bmSpeedSupport_high_speed,\n    &hf_u3v_device_info_descriptor_bmSpeedSupport_super_speed,\n    &hf_u3v_device_info_descriptor_bmSpeedSupport_reserved,\n    NULL\n};\n\n\n/*\n \\brief Returns a register name based on its address\n */\nstatic const gchar*\nget_register_name_from_address(guint64 addr, gboolean* is_custom_register, u3v_conv_info_t * u3v_conv_info)\n{\n    const gchar* address_string = NULL;\n    guint32 offset_address;\n\n    if (is_custom_register != NULL) {\n        *is_custom_register = FALSE;\n    }\n\n    /* check if this is the access to one of the base address registers */\n    if ( addr < 0x10000 ) {\n        offset_address = (guint32)addr;\n        address_string = try_val_to_str(offset_address, bootstrap_register_names_abrm);\n    }\n    if ( u3v_conv_info && u3v_conv_info->sbrm_addr != 0 &&  (addr >= u3v_conv_info->sbrm_addr)) {\n        offset_address = (guint32)( addr - u3v_conv_info->sbrm_addr);\n        address_string = try_val_to_str(offset_address, bootstrap_register_names_sbrm);\n    }\n    if ( u3v_conv_info && u3v_conv_info->sirm_addr != 0 &&  (addr >= u3v_conv_info->sirm_addr)) {\n        offset_address = (guint32)( addr - u3v_conv_info->sirm_addr);\n        address_string = try_val_to_str(offset_address, bootstrap_register_names_sirm);\n    }\n    if ( u3v_conv_info && u3v_conv_info->eirm_addr != 0 &&  (addr >= u3v_conv_info->eirm_addr)) {\n        offset_address = (guint32)( addr - u3v_conv_info->eirm_addr);\n        address_string = try_val_to_str(offset_address, bootstrap_register_names_eirm);\n    }\n\n    if (!address_string) {\n        address_string = wmem_strdup_printf(wmem_packet_scope(), \"[Addr:0x%016\" G_GINT64_MODIFIER \"X]\", addr);\n        if (is_custom_register != NULL) {\n            *is_custom_register = TRUE;\n        }\n    }\n\n    return address_string;\n}\n\n/*\n \\brief Returns true if a register (identified by its address) is a known bootstrap register\n */\nstatic int\nis_known_bootstrap_register(guint64 addr, u3v_conv_info_t * u3v_conv_info)\n{\n    const gchar* address_string = NULL;\n    guint32 offset_address;\n    /* check if this is the access to one of the base address registers */\n    if ( addr < 0x10000 ) {\n        offset_address = (guint32)addr;\n        address_string = try_val_to_str(offset_address, bootstrap_register_names_abrm);\n    }\n    if ( u3v_conv_info->sbrm_addr != 0 &&  (addr >= u3v_conv_info->sbrm_addr)) {\n        offset_address = (guint32)( addr - u3v_conv_info->sbrm_addr);\n        address_string = try_val_to_str(offset_address, bootstrap_register_names_sbrm);\n    }\n    if ( u3v_conv_info->sirm_addr != 0 &&  (addr >= u3v_conv_info->sirm_addr)) {\n        offset_address = (guint32)( addr - u3v_conv_info->sirm_addr);\n        address_string = try_val_to_str(offset_address, bootstrap_register_names_sirm);\n    }\n    if ( u3v_conv_info->eirm_addr != 0 &&  (addr >= u3v_conv_info->eirm_addr)) {\n        offset_address = (guint32)( addr - u3v_conv_info->eirm_addr);\n        address_string = try_val_to_str(offset_address, bootstrap_register_names_eirm);\n    }\n    return address_string != NULL;\n}\n\n/*\n \\brief Identify Base Address Pointer\n*/\nstatic void\ndissect_u3v_register_bases(guint64 addr, tvbuff_t *tvb, gint offset, u3v_conv_info_t * u3v_conv_info)\n{\n    if ( addr < 0x10000 ) {\n        switch (addr) {\n        case U3V_ABRM_SBRM_ADDRESS:\n            u3v_conv_info->sbrm_addr = tvb_get_letoh64(tvb, offset);\n            break;\n        case U3V_ABRM_MANIFEST_TABLE_ADDRESS:\n            u3v_conv_info->manifest_addr = tvb_get_letoh64(tvb, offset);\n            break;\n        }\n    }\n    if ( u3v_conv_info->sbrm_addr != 0 &&  (addr >= u3v_conv_info->sbrm_addr)) {\n        addr -= u3v_conv_info->sbrm_addr;\n        switch(addr) {\n        case U3V_SBRM_SIRM_ADDRESS:\n            u3v_conv_info->sirm_addr = tvb_get_letoh64(tvb, offset);\n            break;\n        case U3V_SBRM_EIRM_ADDRESS:\n            u3v_conv_info->eirm_addr = tvb_get_letoh64(tvb, offset);\n            break;\n        case U3V_SBRM_IIDC2_ADDRESS:\n            u3v_conv_info->iidc2_addr = tvb_get_letoh64(tvb, offset);\n            break;\n        }\n    }\n}\n\n/*\n \\brief Attempt to dissect a bootstrap register\n*/\nstatic int\ndissect_u3v_register(guint64 addr, proto_tree *branch, tvbuff_t *tvb, gint offset, gint length, u3v_conv_info_t * u3v_conv_info)\n{\n    gint isABRM = FALSE, isSBRM = FALSE, isSIRM = FALSE,isEIRM = FALSE;\n    /* check if this is the access to one of the base address registers */\n    if ( addr < 0x10000 ) {\n        isABRM = TRUE;\n        switch (addr) {\n        case U3V_ABRM_GENCP_VERSION:\n            proto_tree_add_item(branch, hf_u3v_bootstrap_GenCP_Version, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n            break;\n        case U3V_ABRM_MANUFACTURER_NAME:\n            if ( length <= 64 ) {\n                proto_tree_add_item(branch, hf_u3v_bootstrap_Manufacturer_Name, tvb, offset, length, ENC_ASCII|ENC_NA);\n            }\n            break;\n        case U3V_ABRM_MODEL_NAME:\n            if ( length <= 64 ) {\n                proto_tree_add_item(branch, hf_u3v_bootstrap_Model_Name, tvb, offset, length, ENC_ASCII|ENC_NA);\n            }\n            break;\n        case U3V_ABRM_FAMILY_NAME:\n            if ( length <= 64 ) {\n                proto_tree_add_item(branch, hf_u3v_bootstrap_Family_Name, tvb, offset, length, ENC_ASCII|ENC_NA);\n            }\n            break;\n        case U3V_ABRM_DEVICE_VERSION:\n            if ( length <= 64 ) {\n                proto_tree_add_item(branch, hf_u3v_bootstrap_Device_Version, tvb, offset, length, ENC_ASCII|ENC_NA);\n            }\n            break;\n        case U3V_ABRM_MANUFACTURER_INFO:\n            if ( length <= 64 ) {\n                proto_tree_add_item(branch, hf_u3v_bootstrap_Manufacturer_Info, tvb, offset, length, ENC_ASCII|ENC_NA);\n            }\n            break;\n        case U3V_ABRM_SERIAL_NUMBER:\n            if ( length <= 64 ) {\n                proto_tree_add_item(branch, hf_u3v_bootstrap_Serial_Number, tvb, offset, length, ENC_ASCII|ENC_NA);\n            }\n            break;\n        case U3V_ABRM_USER_DEFINED_NAME:\n            if ( length <= 64 ) {\n                proto_tree_add_item(branch, hf_u3v_bootstrap_User_Defined_Name, tvb, offset, length, ENC_ASCII|ENC_NA);\n            }\n            break;\n        case U3V_ABRM_DEVICE_CAPABILITY:\n            proto_tree_add_item(branch, hf_u3v_bootstrap_Device_Capability, tvb, offset, 8, ENC_LITTLE_ENDIAN);\n            break;\n        case U3V_ABRM_MAXIMUM_DEVICE_RESPONSE_TIME:\n            proto_tree_add_item(branch, hf_u3v_bootstrap_Maximum_Device_Response_Time, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n            break;\n        case U3V_ABRM_MANIFEST_TABLE_ADDRESS:\n            proto_tree_add_item(branch, hf_u3v_bootstrap_Manifest_Table_Address, tvb, offset, 8, ENC_LITTLE_ENDIAN);\n            break;\n        case U3V_ABRM_SBRM_ADDRESS:\n            proto_tree_add_item(branch, hf_u3v_bootstrap_SBRM_Address, tvb, offset, 8, ENC_LITTLE_ENDIAN);\n            break;\n        case U3V_ABRM_DEVICE_CONFIGURATION:\n            proto_tree_add_item(branch, hf_u3v_bootstrap_Device_Configuration, tvb, offset, 8, ENC_LITTLE_ENDIAN);\n            break;\n        case U3V_ABRM_HEARTBEAT_TIMEOUT:\n            proto_tree_add_item(branch, hf_u3v_bootstrap_Heartbeat_Timeout, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n            break;\n        case U3V_ABRM_MESSAGE_CHANNEL_CHANNEL_ID:\n            proto_tree_add_item(branch, hf_u3v_bootstrap_Message_Channel_channel_id, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n            break;\n        case U3V_ABRM_TIMESTAMP:\n            proto_tree_add_item(branch, hf_u3v_bootstrap_Timestamp, tvb, offset, 8, ENC_LITTLE_ENDIAN);\n            break;\n        case U3V_ABRM_TIMESTAMP_LATCH:\n            proto_tree_add_item(branch, hf_u3v_bootstrap_Timestamp_Latch, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n            break;\n        case U3V_ABRM_TIMESTAMP_INCREMENT:\n            proto_tree_add_item(branch, hf_u3v_bootstrap_Timestamp_Increment, tvb, offset, 8, ENC_LITTLE_ENDIAN);\n            break;\n        case U3V_ABRM_ACCESS_PRIVILEGE:\n            proto_tree_add_item(branch, hf_u3v_bootstrap_Access_Privilege, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n            break;\n        case U3V_ABRM_PROTOCOL_ENDIANESS:\n            proto_tree_add_item(branch, hf_u3v_bootstrap_Protocol_Endianess, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n            break;\n        case U3V_ABRM_IMPLEMENTATION_ENDIANESS:\n            proto_tree_add_item(branch, hf_u3v_bootstrap_Implementation_Endianess, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n            break;\n        default:\n            isABRM = FALSE;\n            break;\n        }\n    }\n    if ( u3v_conv_info->sbrm_addr != 0 &&  (addr >= u3v_conv_info->sbrm_addr)) {\n        guint64 map_offset = addr - u3v_conv_info->sbrm_addr;\n        isSBRM = TRUE;\n        switch(map_offset) {\n        case U3V_SBRM_U3V_VERSION:\n            proto_tree_add_item(branch, hf_u3v_bootstrap_U3V_Version, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n            break;\n        case U3V_SBRM_U3VCP_CAPABILITY_REGISTER:\n            proto_tree_add_item(branch, hf_u3v_bootstrap_U3VCP_Capability_Register, tvb, offset, 8, ENC_LITTLE_ENDIAN);\n            break;\n        case U3V_SBRM_U3VCP_CONFIGURATION_REGISTER:\n            proto_tree_add_item(branch, hf_u3v_bootstrap_U3VCP_Configuration_Register, tvb, offset, 8, ENC_LITTLE_ENDIAN);\n            break;\n        case U3V_SBRM_MAXIMUM_COMMAND_TRANSFER_LENGTH:\n            proto_tree_add_item(branch, hf_u3v_bootstrap_Maximum_Command_Transfer_Length, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n            break;\n        case U3V_SBRM_MAXIMUM_ACKNOWLEDGE_TRANSFER_LENGTH:\n            proto_tree_add_item(branch, hf_u3v_bootstrap_Maximum_Acknowledge_Transfer_Length, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n            break;\n        case U3V_SBRM_NUMBER_OF_STREAM_CHANNELS:\n            proto_tree_add_item(branch, hf_u3v_bootstrap_Number_of_Stream_Channels, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n            break;\n        case U3V_SBRM_SIRM_ADDRESS:\n            proto_tree_add_item(branch, hf_u3v_bootstrap_SIRM_Address, tvb, offset, 8, ENC_LITTLE_ENDIAN);\n            break;\n        case U3V_SBRM_SIRM_LENGTH:\n            proto_tree_add_item(branch, hf_u3v_bootstrap_SIRM_Length, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n            break;\n        case U3V_SBRM_EIRM_ADDRESS:\n            proto_tree_add_item(branch, hf_u3v_bootstrap_EIRM_Address, tvb, offset, 8, ENC_LITTLE_ENDIAN);\n            break;\n        case U3V_SBRM_EIRM_LENGTH:\n            proto_tree_add_item(branch, hf_u3v_bootstrap_EIRM_Length, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n            break;\n        case U3V_SBRM_IIDC2_ADDRESS:\n            proto_tree_add_item(branch, hf_u3v_bootstrap_IIDC2_Address, tvb, offset, 8, ENC_LITTLE_ENDIAN);\n            break;\n        case U3V_SBRM_CURRENT_SPEED:\n            proto_tree_add_item(branch, hf_u3v_bootstrap_Current_Speed, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n            break;\n        default:\n            isSBRM = FALSE;\n            break;\n        }\n    }\n    if ( u3v_conv_info->sirm_addr != 0 &&  (addr >= u3v_conv_info->sirm_addr)) {\n        guint64 map_offset = addr - u3v_conv_info->sirm_addr;\n        isSIRM = TRUE;\n        switch(map_offset) {\n        case U3V_SIRM_SI_INFO:\n            proto_tree_add_item(branch, hf_u3v_bootstrap_SI_Info, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n            break;\n        case U3V_SIRM_SI_CONTROL:\n            proto_tree_add_item(branch, hf_u3v_bootstrap_SI_Control, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n            break;\n        case U3V_SIRM_SI_REQUIRED_PAYLOAD_SIZE:\n            proto_tree_add_item(branch, hf_u3v_bootstrap_SI_Required_Payload_Size, tvb, offset, 8, ENC_LITTLE_ENDIAN);\n            break;\n        case U3V_SIRM_SI_REQUIRED_LEADER_SIZE:\n            proto_tree_add_item(branch, hf_u3v_bootstrap_SI_Required_Leader_Size, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n            break;\n        case U3V_SIRM_SI_REQUIRED_TRAILER_SIZE:\n            proto_tree_add_item(branch, hf_u3v_bootstrap_SI_Required_Trailer_Size, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n            break;\n        case U3V_SIRM_SI_MAXIMUM_LEADER_SIZE:\n            proto_tree_add_item(branch, hf_u3v_bootstrap_SI_Maximum_Leader_Size, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n            break;\n        case U3V_SIRM_SI_PAYLOAD_TRANSFER_SIZE:\n            proto_tree_add_item(branch, hf_u3v_bootstrap_SI_Payload_Transfer_Size, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n            break;\n        case U3V_SIRM_SI_PAYLOAD_TRANSFER_COUNT:\n            proto_tree_add_item(branch, hf_u3v_bootstrap_SI_Payload_Transfer_Count, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n            break;\n        case U3V_SIRM_SI_PAYLOAD_FINAL_TRANSFER1_SIZE:\n            proto_tree_add_item(branch, hf_u3v_bootstrap_SI_Payload_Final_Transfer1_Size, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n            break;\n        case U3V_SIRM_SI_PAYLOAD_FINAL_TRANSFER2_SIZE:\n            proto_tree_add_item(branch, hf_u3v_bootstrap_SI_Payload_Final_Transfer2_Size, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n            break;\n        case U3V_SIRM_SI_MAXIMUM_TRAILER_SIZE:\n            proto_tree_add_item(branch, hf_u3v_bootstrap_SI_Maximum_Trailer_Size, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n            break;\n        default:\n            isSIRM = FALSE;\n            break;\n        }\n    }\n    if ( u3v_conv_info->eirm_addr != 0 &&  (addr >= u3v_conv_info->eirm_addr)) {\n        guint64 map_offset = addr -u3v_conv_info->eirm_addr;\n        isEIRM=TRUE;\n        switch(map_offset) {\n        case U3V_EIRM_EI_CONTROL:\n            proto_tree_add_item(branch, hf_u3v_bootstrap_EI_Control, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n            break;\n        case U3V_EIRM_MAXIMUM_EVENT_TRANSFER_LENGTH:\n            proto_tree_add_item(branch, hf_u3v_bootstrap_Maximum_Event_Transfer_Length, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n            break;\n        case U3V_EIRM_EVENT_TEST_CONTROL:\n            proto_tree_add_item(branch, hf_u3v_bootstrap_Event_Test_Control, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n            break;\n        default:\n            isEIRM = FALSE;\n            break;\n        }\n    }\n    if(isABRM || isSBRM || isSIRM || isEIRM ) {\n        return 1;\n    }\n    return 0;\n}\n\n/*\n \\brief DISSECT: Read memory command\n*/\nstatic void\ndissect_u3v_read_mem_cmd(proto_tree *u3v_telegram_tree, tvbuff_t *tvb, packet_info *pinfo, gint startoffset, gint length, u3v_conv_info_t *u3v_conv_info, gencp_transaction_t * gencp_trans)\n{\n    guint64 addr = 0;\n    const gchar* address_string = NULL;\n    gboolean is_custom_register = FALSE;\n    guint16 count = 0;\n    gint offset = startoffset;\n    proto_item *item = NULL;\n\n    addr = tvb_get_letoh64(tvb, offset);\n    gencp_trans->address = addr;\n\n    address_string = get_register_name_from_address(addr, &is_custom_register, u3v_conv_info);\n    count = tvb_get_letohs(tvb, offset + 10);   /* Number of bytes to read from memory */\n\n    gencp_trans->count = count;\n    if ( 0xffffffff00000000 & addr ) {\n        col_append_fstr(pinfo->cinfo, COL_INFO, \" (0x%016\" G_GINT64_MODIFIER \"X (%d) bytes) %s\", addr, count, address_string);\n    } else {\n        col_append_fstr(pinfo->cinfo, COL_INFO, \" (0x%08X (%d) bytes)\", (guint32)addr, count);\n    }\n\n\n    item = proto_tree_add_item(u3v_telegram_tree, hf_u3v_scd_readmem_cmd, tvb, offset, length, ENC_NA);\n    u3v_telegram_tree = proto_item_add_subtree(item, ett_u3v_payload_cmd);\n\n    /* address */\n    if (is_known_bootstrap_register(addr, u3v_conv_info)) {\n        item = proto_tree_add_uint64(u3v_telegram_tree, hf_u3v_address, tvb, offset, 8, addr);\n        proto_item_append_text(item, \" %s\", address_string);\n    } else {\n        proto_tree_add_item(u3v_telegram_tree, hf_u3v_custom_memory_addr, tvb, offset, 8, ENC_LITTLE_ENDIAN);\n    }\n    offset += 8;\n\n    /* reserved field */\n    proto_tree_add_item(u3v_telegram_tree, hf_u3v_reserved, tvb, offset, 2, ENC_NA);\n    offset += 2;\n\n    /* count */\n    proto_tree_add_item(u3v_telegram_tree, hf_u3v_count, tvb, offset, 2, ENC_LITTLE_ENDIAN);\n}\n\n/*\n \\brief DISSECT: Write memory command\n*/\nstatic void\ndissect_u3v_write_mem_cmd(proto_tree *u3v_telegram_tree, tvbuff_t *tvb, packet_info *pinfo, gint startoffset, gint length, u3v_conv_info_t *u3v_conv_info, gencp_transaction_t *gencp_trans)\n{\n    const gchar* address_string = NULL;\n    gboolean is_custom_register = FALSE;\n    guint64 addr = 0;\n    guint byte_count = 0;\n    proto_item *item = NULL;\n    guint offset = startoffset + 8;\n\n    addr = tvb_get_letoh64(tvb, startoffset);\n    byte_count = length - 8;\n    address_string = get_register_name_from_address(addr, &is_custom_register, u3v_conv_info);\n\n    gencp_trans->address = addr;\n    gencp_trans->count = byte_count;\n\n    /* fill in Info column in Wireshark GUI */\n    col_append_fstr(pinfo->cinfo, COL_INFO, \"%s: %d bytes\", address_string, byte_count);\n\n\n    /* Subtree initialization for Payload Data: WRITEMEM_CMD */\n    item = proto_tree_add_item(u3v_telegram_tree, hf_u3v_scd_writemem_cmd, tvb, startoffset, length, ENC_NA);\n    u3v_telegram_tree = proto_item_add_subtree(item, ett_u3v_payload_cmd);\n\n    if (is_known_bootstrap_register(addr, u3v_conv_info)) {\n        item = proto_tree_add_uint64(u3v_telegram_tree, hf_u3v_address, tvb, startoffset, 8, addr);\n        proto_item_append_text(item, \" %s\", address_string);\n        dissect_u3v_register(addr, u3v_telegram_tree, tvb, offset, byte_count, u3v_conv_info);\n    } else {\n        proto_tree_add_item(u3v_telegram_tree, hf_u3v_custom_memory_addr, tvb, startoffset, 8, ENC_LITTLE_ENDIAN);\n        proto_tree_add_item(u3v_telegram_tree, hf_u3v_custom_memory_data, tvb, startoffset + 8, byte_count, ENC_NA);\n    }\n\n}\n\n/*\n *  \\brief DISSECT: Event command\n */\nstatic void\ndissect_u3v_event_cmd(proto_tree *u3v_telegram_tree, tvbuff_t *tvb, packet_info *pinfo, gint startoffset, gint length)\n{\n    gint32 eventid;\n    gint offset = startoffset;\n    proto_item *item = NULL;\n\n    /* Get event ID */\n    eventid = tvb_get_letohs(tvb, offset + 2);\n\n    /* fill in Info column in Wireshark GUI */\n    col_append_fstr(pinfo->cinfo, COL_INFO, \"[ID: 0x%04X]\", eventid);\n\n\n    item = proto_tree_add_item(u3v_telegram_tree, hf_u3v_scd_event_cmd, tvb, offset, length, ENC_NA);\n    u3v_telegram_tree = proto_item_add_subtree(item, ett_u3v_payload_cmd);\n\n    offset += 2;\n\n    /* Use range to determine type of event */\n    if ((eventid >= 0x0000) && (eventid <= 0x8000)) {\n        /* Standard ID */\n        proto_tree_add_item(u3v_telegram_tree, hf_u3v_eventcmd_id, tvb, offset, 2, ENC_LITTLE_ENDIAN);\n    } else if ((eventid >= 0x8001) && (eventid <= 0x8FFF)) {\n        /* Error */\n        proto_tree_add_item(u3v_telegram_tree, hf_u3v_eventcmd_error_id, tvb, offset, 2, ENC_LITTLE_ENDIAN);\n    } else if ((eventid >= 0x9000) && (eventid <= 0xFFFF)) {\n        /* Device specific */\n        proto_tree_add_item(u3v_telegram_tree, hf_u3v_eventcmd_device_specific_id, tvb, offset, 2, ENC_LITTLE_ENDIAN);\n    }\n    offset += 2;\n\n    /* Timestamp (64 bit) associated with event */\n    proto_tree_add_item(u3v_telegram_tree, hf_u3v_eventcmd_timestamp, tvb, offset, 8, ENC_LITTLE_ENDIAN);\n    offset += 8;\n\n    /* Data */\n    if (length > offset ) {\n        proto_tree_add_item(u3v_telegram_tree, hf_u3v_eventcmd_data, tvb, offset, length - 12, ENC_NA);\n    }\n}\n\n/*\n \\brief DISSECT: Read memory acknowledge\n*/\nstatic void\ndissect_u3v_read_mem_ack(proto_tree *u3v_telegram_tree, tvbuff_t *tvb, packet_info *pinfo, gint startoffset, gint length, u3v_conv_info_t *u3v_conv_info, gencp_transaction_t * gencp_trans)\n{\n    guint64 addr = 0;\n    const gchar *address_string = NULL;\n    gboolean is_custom_register = FALSE;\n    gboolean have_address = (0 != gencp_trans->cmd_frame);\n    proto_item *item = NULL;\n    guint offset = startoffset;\n    guint byte_count = (length);\n\n    addr = gencp_trans->address;\n    dissect_u3v_register_bases(addr, tvb, startoffset, u3v_conv_info);\n    if (have_address) {\n        address_string = get_register_name_from_address(addr, &is_custom_register, u3v_conv_info);\n        /* Fill in Wireshark GUI Info column */\n        col_append_fstr(pinfo->cinfo, COL_INFO, \"%s\", address_string);\n    }\n\n\n    /* Subtree initialization for Payload Data: READMEM_ACK */\n    item = proto_tree_add_item(u3v_telegram_tree, hf_u3v_scd_ack_readmem_ack, tvb, startoffset, length, ENC_NA);\n    u3v_telegram_tree = proto_item_add_subtree(item, ett_u3v_payload_cmd);\n\n    /* Bootstrap register known address */\n    if (have_address) {\n        item = proto_tree_add_uint64(u3v_telegram_tree, hf_u3v_address, tvb, 0,0 , addr);\n        PROTO_ITEM_SET_GENERATED(item);\n\n        if (is_known_bootstrap_register(addr, u3v_conv_info)) {\n            dissect_u3v_register(addr, u3v_telegram_tree, tvb, offset, byte_count, u3v_conv_info);\n        } else {\n            proto_tree_add_item(u3v_telegram_tree, hf_u3v_custom_memory_data, tvb, startoffset, length, ENC_NA);\n        }\n    }\n}\n\n/*\n \\brief DISSECT: Write memory acknowledge\n*/\nstatic void\ndissect_u3v_write_mem_ack(proto_tree *u3v_telegram_tree, tvbuff_t *tvb, packet_info *pinfo, gint startoffset, gint length, u3v_conv_info_t *u3v_conv_info , gencp_transaction_t * gencp_trans)\n{\n    guint64 addr = 0;\n    gint offset = startoffset;\n    const gchar *address_string = NULL;\n    gboolean is_custom_register = FALSE;\n    gboolean have_address = (0 != gencp_trans->cmd_frame);\n    proto_item *item = NULL;\n\n    addr = gencp_trans->address;\n    if (have_address) {\n        address_string = get_register_name_from_address(addr, &is_custom_register, u3v_conv_info);\n\n        /* Fill in Wireshark GUI Info column */\n        col_append_fstr(pinfo->cinfo, COL_INFO, \"%s\", address_string);\n    }\n\n    item = proto_tree_add_item(u3v_telegram_tree, hf_u3v_scd_writemem_ack, tvb, startoffset, length, ENC_NA);\n    u3v_telegram_tree = proto_item_add_subtree(item, ett_u3v_payload_cmd);\n\n    if (have_address) {\n            item = proto_tree_add_uint64(u3v_telegram_tree, hf_u3v_address, tvb, 0,0 , addr);\n            PROTO_ITEM_SET_GENERATED(item);\n        }\n    /* Number of bytes successfully written to the device register map */\n    if ( length == 4 ) {\n\n        /* reserved field */\n        proto_tree_add_item(u3v_telegram_tree, hf_u3v_reserved, tvb, offset, 2, ENC_NA);\n        offset += 2;\n\n        proto_tree_add_item(u3v_telegram_tree, hf_u3v_count, tvb, offset, 2, ENC_LITTLE_ENDIAN);\n    }\n}\n\n/*\n \\brief DISSECT: Pending acknowledge\n*/\nstatic void\ndissect_u3v_pending_ack(proto_tree *u3v_telegram_tree, tvbuff_t *tvb, packet_info *pinfo _U_, gint startoffset, gint length, u3v_conv_info_t *u3v_conv_info _U_, gencp_transaction_t *gencp_trans _U_)\n{\n    proto_item *item = NULL;\n    guint offset = startoffset;\n\n    /* Fill in Wireshark GUI Info column */\n    col_append_fstr(pinfo->cinfo, COL_INFO, \" %d ms\", tvb_get_letohs(tvb, startoffset+2));\n\n    item = proto_tree_add_item(u3v_telegram_tree, hf_u3v_ccd_pending_ack, tvb, startoffset, length, ENC_NA);\n    u3v_telegram_tree = proto_item_add_subtree(item, ett_u3v_payload_cmd);\n\n    /* reserved field */\n    proto_tree_add_item(u3v_telegram_tree, hf_u3v_reserved, tvb, offset, 2, ENC_NA);\n    offset += 2;\n\n    proto_tree_add_item(u3v_telegram_tree, hf_u3v_time_to_completion, tvb, offset, 2, ENC_LITTLE_ENDIAN);\n}\n\n/*\n \\brief DISSECT: Stream Leader\n*/\nstatic void\ndissect_u3v_stream_leader(proto_tree *u3v_telegram_tree, tvbuff_t *tvb, packet_info *pinfo, usb_conv_info_t *usb_conv_info _U_)\n{\n    guint32 offset = 0;\n    guint32 payload_type = 0;\n    guint64 block_id = 0;\n    proto_item *item = NULL;\n\n    /* Subtree initialization for Stream Leader */\n    item = proto_tree_add_item(u3v_telegram_tree, hf_u3v_stream_leader, tvb, 0, -1, ENC_NA);\n    u3v_telegram_tree = proto_item_add_subtree(item, ett_u3v_stream_leader);\n\n    /* Add the prefix code: */\n    proto_tree_add_item(u3v_telegram_tree, hf_u3v_stream_prefix, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n    offset += 4;\n\n    /* reserved field */\n    proto_tree_add_item(u3v_telegram_tree, hf_u3v_stream_reserved, tvb, offset, 2, ENC_NA);\n    offset += 2;\n\n    /* leader size */\n    proto_tree_add_item(u3v_telegram_tree, hf_u3v_stream_leader_size, tvb, offset, 2, ENC_LITTLE_ENDIAN);\n    offset += 2;\n\n    /* block id */\n    block_id = tvb_get_letoh64(tvb, offset);\n    proto_tree_add_item(u3v_telegram_tree, hf_u3v_stream_block_id, tvb, offset, 8, ENC_LITTLE_ENDIAN);\n    offset += 8;\n\n    /* reserved field */\n    proto_tree_add_item(u3v_telegram_tree, hf_u3v_stream_reserved, tvb, offset, 2, ENC_NA);\n    offset += 2;\n\n    /* payload type */\n    payload_type = tvb_get_letohs(tvb, offset);\n    proto_tree_add_item(u3v_telegram_tree, hf_u3v_stream_payload_type, tvb, offset, 2, ENC_LITTLE_ENDIAN);\n    offset += 2;\n\n    /* Add payload type to information string */\n    col_append_fstr(pinfo->cinfo, COL_INFO, \"Stream Leader  [ Block ID: %\" G_GINT64_MODIFIER \"u , Type %s]\",\n                    block_id,\n                    val_to_str(payload_type, payload_type_names, \"Unknown Payload Type\"));\n\n    if (payload_type == U3V_STREAM_PAYLOAD_IMAGE ||\n        payload_type == U3V_STREAM_PAYLOAD_IMAGE_EXT_CHUNK ||\n        payload_type == U3V_STREAM_PAYLOAD_CHUNK) {\n        /* timestamp */\n        proto_tree_add_item(u3v_telegram_tree, hf_u3v_stream_timestamp, tvb, offset, 8, ENC_LITTLE_ENDIAN);\n        offset += 8;\n    }\n\n    if (payload_type == U3V_STREAM_PAYLOAD_IMAGE ||\n        payload_type == U3V_STREAM_PAYLOAD_IMAGE_EXT_CHUNK ) {\n        /* pixel format */\n        proto_tree_add_item(u3v_telegram_tree, hf_u3v_stream_pixel_format, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n        offset += 4;\n\n        /* size_x */\n        proto_tree_add_item(u3v_telegram_tree, hf_u3v_stream_size_x, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n        offset += 4;\n\n        /* size_y */\n        proto_tree_add_item(u3v_telegram_tree, hf_u3v_stream_size_y, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n        offset += 4;\n\n        /* offset_x */\n        proto_tree_add_item(u3v_telegram_tree, hf_u3v_stream_offset_x, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n        offset += 4;\n\n        /* offset_x */\n        proto_tree_add_item(u3v_telegram_tree, hf_u3v_stream_offset_y, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n        offset += 4;\n\n        /* padding_x */\n        proto_tree_add_item(u3v_telegram_tree, hf_u3v_stream_padding_x, tvb, offset, 2, ENC_LITTLE_ENDIAN);\n        /* offset += 2; */\n\n        /* reserved field */\n        proto_tree_add_item(u3v_telegram_tree, hf_u3v_stream_reserved, tvb, offset, 2, ENC_NA);\n        /* offset += 2; */\n    }\n}\n\n/*\n \\brief DISSECT: Stream Trailer\n*/\nstatic void\ndissect_u3v_stream_trailer(proto_tree *u3v_telegram_tree, tvbuff_t *tvb, packet_info *pinfo, usb_conv_info_t *usb_conv_info _U_)\n{\n    gint offset = 0;\n    guint64 block_id;\n    proto_item *item = NULL;\n\n    /* Subtree initialization for Stream Leader */\n    item = proto_tree_add_item(u3v_telegram_tree, hf_u3v_stream_trailer, tvb, 0, -1, ENC_NA);\n    u3v_telegram_tree = proto_item_add_subtree(item, ett_u3v_stream_trailer);\n\n    /* Add the prefix code: */\n    proto_tree_add_item(u3v_telegram_tree, hf_u3v_stream_prefix, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n    offset += 4;\n\n    /* reserved field */\n    proto_tree_add_item(u3v_telegram_tree, hf_u3v_stream_reserved, tvb, offset, 2, ENC_NA);\n    offset += 2;\n\n    /* trailer size */\n    proto_tree_add_item(u3v_telegram_tree, hf_u3v_stream_trailer_size, tvb, offset, 2, ENC_LITTLE_ENDIAN);\n    offset += 2;\n\n    /* block id */\n    block_id = tvb_get_letoh64(tvb, offset);\n    proto_tree_add_item(u3v_telegram_tree, hf_u3v_stream_block_id, tvb, offset, 8, ENC_LITTLE_ENDIAN);\n    offset += 8;\n\n    /* status*/\n    proto_tree_add_item(u3v_telegram_tree, hf_u3v_stream_status, tvb, offset, 2, ENC_LITTLE_ENDIAN);\n    offset += 2;\n\n    /* reserved field */\n    proto_tree_add_item(u3v_telegram_tree, hf_u3v_stream_reserved, tvb, offset, 2, ENC_NA);\n    offset += 2;\n\n    /* block id */\n    proto_tree_add_item(u3v_telegram_tree, hf_u3v_stream_valid_payload_size, tvb, offset, 8, ENC_LITTLE_ENDIAN);\n    offset += 8;\n\n    /* Add payload type to information string */\n    col_append_fstr(pinfo->cinfo, COL_INFO, \"Stream Trailer [ Block ID: %\" G_GINT64_MODIFIER \"u]\", block_id);\n\n    if (tvb_captured_length_remaining(tvb,offset) >=4 ) {\n        /* size_y */\n        proto_tree_add_item(u3v_telegram_tree, hf_u3v_stream_size_y, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n        offset += 4;\n    }\n\n    if (tvb_captured_length_remaining(tvb,offset) >=4 ) {\n        /* chunk layout id */\n        proto_tree_add_item(u3v_telegram_tree, hf_u3v_stream_chunk_layout_id, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n        /* offset += 4; */\n    }\n}\n\n/*\n \\brief DISSECT: Stream Payload\n*/\nstatic void\ndissect_u3v_stream_payload(proto_tree *u3v_telegram_tree, tvbuff_t *tvb, packet_info *pinfo, usb_conv_info_t *usb_conv_info _U_)\n{\n    proto_item *item = NULL;\n\n    /* Subtree initialization for Stream Leader */\n    item = proto_tree_add_item(u3v_telegram_tree, hf_u3v_stream_payload, tvb, 0, -1, ENC_NA);\n    u3v_telegram_tree = proto_item_add_subtree(item, ett_u3v_stream_payload);\n\n    /* Data */\n    proto_tree_add_item(u3v_telegram_tree, hf_u3v_stream_data, tvb, 0, -1, ENC_NA);\n\n    /* Add payload type to information string */\n    col_append_fstr(pinfo->cinfo, COL_INFO, \"Stream Payload\");\n}\n\n/*\n  \\brief Point of entry of all U3V packet dissection\n*/\nstatic int\ndissect_u3v(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)\n{\n    gint offset = 0;\n    proto_tree *u3v_tree = NULL, *ccd_tree_flag, *u3v_telegram_tree = NULL, *ccd_tree = NULL;\n    gint data_length = 0;\n    gint req_id = 0;\n    gint command_id = -1;\n    gint status = 0;\n    guint prefix = 0;\n    proto_item *ti = NULL;\n    proto_item *item = NULL;\n    const char *command_string;\n    usb_conv_info_t *usb_conv_info;\n    gint stream_detected = FALSE;\n    gint control_detected = FALSE;\n    u3v_conv_info_t *u3v_conv_info = NULL;\n    gencp_transaction_t *gencp_trans = NULL;\n\n    usb_conv_info = (usb_conv_info_t *)data;\n\n    /* decide if this packet belongs to U3V protocol */\n    u3v_conv_info = (u3v_conv_info_t *)usb_conv_info->class_data;\n\n    if (!u3v_conv_info) {\n        u3v_conv_info = wmem_new0(wmem_file_scope(), u3v_conv_info_t);\n        usb_conv_info->class_data = u3v_conv_info;\n        usb_conv_info->class_data_type = USB_CONV_U3V;\n    } else if (usb_conv_info->class_data_type != USB_CONV_U3V) {\n        /* Don't dissect if another USB type is in the conversation */\n        return 0;\n    }\n\n    prefix = tvb_get_letohl(tvb, 0);\n    if ((tvb_reported_length(tvb) >= 4) && ( ( U3V_CONTROL_PREFIX == prefix ) || ( U3V_EVENT_PREFIX == prefix ) ) ) {\n        control_detected = TRUE;\n    }\n\n    if (((tvb_reported_length(tvb) >= 4) && (( U3V_STREAM_LEADER_PREFIX == prefix ) || ( U3V_STREAM_TRAILER_PREFIX == prefix )))\n         || (usb_conv_info->endpoint == u3v_conv_info->ep_stream)) {\n        stream_detected = TRUE;\n    }\n\n    /* initialize interface class/subclass in case no descriptors have been dissected yet */\n    if ( control_detected || stream_detected){\n        if ( usb_conv_info->interfaceClass  == IF_CLASS_UNKNOWN &&\n             usb_conv_info->interfaceSubclass  == IF_SUBCLASS_UNKNOWN){\n            usb_conv_info->interfaceClass = IF_CLASS_MISCELLANEOUS;\n            usb_conv_info->interfaceSubclass = IF_SUBCLASS_MISC_U3V;\n        }\n    }\n\n    if ( control_detected ) {\n        /* Set the protocol column */\n        col_set_str(pinfo->cinfo, COL_PROTOCOL, \"U3V\");\n\n        /* Clear out stuff in the info column */\n        col_clear(pinfo->cinfo, COL_INFO);\n\n        /* Adds \"USB3Vision\" heading to protocol tree */\n        /* We will add fields to this using the u3v_tree pointer */\n        ti = proto_tree_add_item(tree, proto_u3v, tvb, offset, -1, ENC_NA);\n        u3v_tree = proto_item_add_subtree(ti, ett_u3v);\n\n        prefix = tvb_get_letohl(tvb, offset);\n        command_id = tvb_get_letohs(tvb, offset+6);\n\n        /* decode CCD ( DCI/DCE command data layout) */\n        if ((prefix == U3V_CONTROL_PREFIX || prefix == U3V_EVENT_PREFIX) && ((command_id % 2) == 0)) {\n            command_string = val_to_str(command_id,command_names,\"Unknown Command (0x%x)\");\n            item = proto_tree_add_item(u3v_tree, hf_u3v_ccd_cmd, tvb, offset, 8, ENC_NA);\n            proto_item_append_text(item, \": %s\", command_string);\n            ccd_tree = proto_item_add_subtree(item, ett_u3v_cmd);\n\n            /* Add the prefix code: */\n            proto_tree_add_item(ccd_tree, hf_u3v_gencp_prefix, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n            offset += 4;\n\n            /* Add the flags */\n            item = proto_tree_add_item(ccd_tree, hf_u3v_flag, tvb, offset, 2, ENC_LITTLE_ENDIAN);\n            ccd_tree_flag  = proto_item_add_subtree(item, ett_u3v_flags);\n            proto_tree_add_item(ccd_tree_flag, hf_u3v_acknowledge_required_flag, tvb, offset, 2, ENC_LITTLE_ENDIAN);\n\n            offset += 2;\n            col_append_fstr(pinfo->cinfo, COL_INFO, \"> %s \", command_string);\n        } else if (prefix == U3V_CONTROL_PREFIX && ((command_id % 2) == 1)) {\n            command_string = val_to_str(command_id,command_names,\"Unknown Acknowledge (0x%x)\");\n            item = proto_tree_add_item(u3v_tree, hf_u3v_ccd_ack, tvb, offset, 8, ENC_NA);\n            proto_item_append_text(item, \": %s\", command_string);\n            ccd_tree = proto_item_add_subtree(item, ett_u3v_ack);\n\n            /* Add the prefix code: */\n            proto_tree_add_item(ccd_tree, hf_u3v_gencp_prefix, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n            offset += 4;\n\n            /* Add the status: */\n            proto_tree_add_item(ccd_tree, hf_u3v_status, tvb, offset, 2,ENC_LITTLE_ENDIAN);\n            status = tvb_get_letohs(tvb, offset);\n            offset += 2;\n            col_append_fstr(pinfo->cinfo, COL_INFO, \"< %s %s\",\n                    command_string,\n                    val_to_str(status, status_names_short, \"Unknown status (0x%04X)\"));\n        } else {\n            return 0;\n        }\n\n        /* Add the command id*/\n        proto_tree_add_item(ccd_tree, hf_u3v_command_id, tvb, offset, 2,ENC_LITTLE_ENDIAN);\n        offset += 2;\n\n        /* Parse the second part of both the command and the acknowledge header:\n        0          15 16         31\n        -------- -------- -------- --------\n        |     status      |   acknowledge   |\n        -------- -------- -------- --------\n        |     length      |      req_id     |\n        -------- -------- -------- --------\n\n        Add the data length\n        Number of valid data bytes in this message, not including this header. This\n        represents the number of bytes of payload appended after this header */\n\n        proto_tree_add_item(ccd_tree, hf_u3v_length, tvb, offset, 2, ENC_LITTLE_ENDIAN);\n        data_length = tvb_get_letohs(tvb, offset);\n        offset += 2;\n\n        /* Add the request ID */\n        proto_tree_add_item(ccd_tree, hf_u3v_request_id, tvb, offset, 2, ENC_LITTLE_ENDIAN);\n        req_id = tvb_get_letohs(tvb, offset);\n        offset += 2;\n\n        /* Add telegram subtree */\n        u3v_telegram_tree = proto_item_add_subtree(u3v_tree, ett_u3v);\n\n        if (!PINFO_FD_VISITED(pinfo)) {\n              if ((command_id % 2) == 0) {\n                    /* This is a command */\n                    gencp_trans = wmem_new(wmem_file_scope(), gencp_transaction_t);\n                    gencp_trans->cmd_frame = pinfo->fd->num;\n                    gencp_trans->ack_frame = 0;\n                    gencp_trans->cmd_time = pinfo->fd->abs_ts;\n                    /* add reference to current packet */\n                    p_add_proto_data(wmem_file_scope(), pinfo, proto_u3v, req_id, gencp_trans);\n                    /* add reference to current */\n                    u3v_conv_info->trans_info = gencp_trans;\n                } else {\n                    gencp_trans = u3v_conv_info->trans_info;\n                    if (gencp_trans) {\n                        gencp_trans->ack_frame = pinfo->fd->num;\n                        /* add reference to current packet */\n                        p_add_proto_data(wmem_file_scope(), pinfo, proto_u3v, req_id, gencp_trans);\n                    }\n                }\n         } else {\n            gencp_trans = (gencp_transaction_t*)p_get_proto_data(wmem_file_scope(),pinfo, proto_u3v, req_id);\n         }\n\n        if (!gencp_trans) {\n            /* create a \"fake\" gencp_trans structure */\n            gencp_trans = wmem_new(wmem_packet_scope(), gencp_transaction_t);\n            gencp_trans->cmd_frame = 0;\n            gencp_trans->ack_frame = 0;\n            gencp_trans->cmd_time = pinfo->fd->abs_ts;\n        }\n\n        /* dissect depending on command? */\n        switch (command_id) {\n        case U3V_READMEM_CMD:\n            dissect_u3v_read_mem_cmd(u3v_telegram_tree, tvb, pinfo, offset, data_length,u3v_conv_info,gencp_trans);\n            break;\n        case U3V_WRITEMEM_CMD:\n            dissect_u3v_write_mem_cmd(u3v_telegram_tree, tvb, pinfo, offset, data_length,u3v_conv_info,gencp_trans);\n            break;\n        case U3V_EVENT_CMD:\n            dissect_u3v_event_cmd(u3v_telegram_tree, tvb, pinfo, offset, data_length);\n            break;\n        case U3V_READMEM_ACK:\n            if ( U3V_STATUS_GENCP_SUCCESS == status ) {\n                dissect_u3v_read_mem_ack(u3v_telegram_tree, tvb, pinfo, offset, data_length,u3v_conv_info,gencp_trans);\n            }\n            break;\n        case U3V_WRITEMEM_ACK:\n            dissect_u3v_write_mem_ack(u3v_telegram_tree, tvb, pinfo, offset, data_length, u3v_conv_info,gencp_trans);\n            break;\n        case U3V_PENDING_ACK:\n            dissect_u3v_pending_ack(u3v_telegram_tree, tvb, pinfo, offset, data_length, u3v_conv_info,gencp_trans);\n            break;\n        default:\n            proto_tree_add_item(u3v_telegram_tree, hf_u3v_payloaddata, tvb, offset, data_length, ENC_NA);\n            break;\n        }\n        return data_length + 12;\n    } else if ( stream_detected ) {\n        /* this is streaming data */\n\n        /* init this stream configuration */\n        u3v_conv_info = (u3v_conv_info_t *)usb_conv_info->class_data;\n        u3v_conv_info->ep_stream = usb_conv_info->endpoint;\n\n        /* Set the protocol column */\n        col_set_str(pinfo->cinfo, COL_PROTOCOL, \"U3V\");\n\n        /* Clear out stuff in the info column */\n        col_clear(pinfo->cinfo, COL_INFO);\n\n        /* Adds \"USB3Vision\" heading to protocol tree */\n        /* We will add fields to this using the u3v_tree pointer */\n        ti = proto_tree_add_item(tree, proto_u3v, tvb, offset, -1, ENC_NA);\n        u3v_tree = proto_item_add_subtree(ti, ett_u3v);\n\n        if(tvb_captured_length(tvb) >=4) {\n            prefix = tvb_get_letohl(tvb, offset);\n            switch (prefix) {\n            case U3V_STREAM_LEADER_PREFIX:\n                dissect_u3v_stream_leader(u3v_tree, tvb, pinfo, usb_conv_info);\n                break;\n            case U3V_STREAM_TRAILER_PREFIX:\n                dissect_u3v_stream_trailer(u3v_tree, tvb, pinfo, usb_conv_info);\n                break;\n            default:\n                dissect_u3v_stream_payload(u3v_tree, tvb, pinfo, usb_conv_info);\n                break;\n            }\n        }\n        return tvb_captured_length(tvb);\n    }\n    return 0;\n}\n\n\nstatic gboolean\ndissect_u3v_heur(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)\n{\n    guint32 prefix;\n    usb_conv_info_t *usb_conv_info;\n\n    /* all control and meta data packets of U3V contain at least the prefix */\n    if (tvb_reported_length(tvb) < 4)\n        return FALSE;\n    prefix = tvb_get_letohl(tvb, 0);\n\n    /* check if stream endpoint has been already set up for this conversation */\n    usb_conv_info = (usb_conv_info_t *)data;\n    if (!usb_conv_info)\n        return FALSE;\n\n    /* either right prefix or the endpoint of the interface descriptor\n       set the correct class and subclass */\n    if ((U3V_STREAM_LEADER_PREFIX  == prefix) || (U3V_STREAM_TRAILER_PREFIX == prefix) ||\n        (U3V_CONTROL_PREFIX        == prefix) || (U3V_EVENT_PREFIX          == prefix) ||\n        ((usb_conv_info->interfaceClass == IF_CLASS_MISCELLANEOUS &&\n          usb_conv_info->interfaceSubclass == IF_SUBCLASS_MISC_U3V))) {\n        dissect_u3v(tvb, pinfo, tree, data);\n        return TRUE;\n    }\n\n    return FALSE;\n}\n\nstatic gint\ndissect_u3v_descriptors(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, void *data _U_)\n{\n    guint8          type;\n    gint            offset = 0;\n    proto_item *    ti;\n    proto_tree *    sub_tree;\n    guint32         version;\n\n\n    /* The descriptor must at least have a length and type field. */\n    if (tvb_reported_length(tvb) < 2) {\n        return 0;\n    }\n\n    /* skip len */\n    type = tvb_get_guint8(tvb, 1);\n\n    /* Check for U3V device info descriptor. */\n    if (type != DESCRIPTOR_TYPE_U3V_INTERFACE) {\n        return 0;\n    }\n\n    ti = proto_tree_add_item(tree, hf_u3v_device_info_descriptor, tvb, offset, -1, ENC_NA);\n    tree = proto_item_add_subtree(ti, ett_u3v_device_info_descriptor);\n\n    /* bLength */\n    proto_tree_add_item(tree, hf_u3v_device_info_descriptor_bLength, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    offset++;\n\n    /* bDescriptorType */\n    ti = proto_tree_add_item(tree, hf_u3v_device_info_descriptor_bDescriptorType, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    proto_item_append_text(ti, \" (U3V INTERFACE)\");\n    offset++;\n\n    /* bDescriptorSubtype */\n    proto_tree_add_item(tree, hf_u3v_device_info_descriptor_bDescriptorSubtype, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    offset++;\n\n    /* bGenCPVersion */\n    if (!tvb_bytes_exist(tvb, offset, 4)) {\n        /* Version not completely in buffer -> break dissection here. */\n        return offset;\n    }\n    version = tvb_get_letohl(tvb, offset);\n    ti = proto_tree_add_item(tree, hf_u3v_device_info_descriptor_bGenCPVersion, tvb, offset, 4, ENC_NA);\n    proto_item_append_text(ti, \": %u.%u\", version >> 16, version & 0xFFFF);\n    sub_tree = proto_item_add_subtree(ti, ett_u3v_device_info_descriptor_gencp_version);\n    proto_tree_add_item(sub_tree, hf_u3v_device_info_descriptor_bGenCPVersion_minor, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n    proto_tree_add_item(sub_tree, hf_u3v_device_info_descriptor_bGenCPVersion_major, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n    offset += 4;\n\n    /* bU3VVersion */\n    if (!tvb_bytes_exist(tvb, offset, 4)) {\n        /* Version not completely in buffer -> break dissection here. */\n        return offset;\n    }\n    version = tvb_get_letohl(tvb, offset);\n    ti = proto_tree_add_item(tree, hf_u3v_device_info_descriptor_bU3VVersion, tvb, offset, 4, ENC_NA);\n    proto_item_append_text(ti, \": %u.%u\", version >> 16, version & 0xFFFF);\n    sub_tree = proto_item_add_subtree(ti, ett_u3v_device_info_descriptor_u3v_version);\n    proto_tree_add_item(sub_tree, hf_u3v_device_info_descriptor_bU3VVersion_minor, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n    proto_tree_add_item(sub_tree, hf_u3v_device_info_descriptor_bU3VVersion_major, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n    offset += 4;\n\n    /* iDeviceGUID */\n    proto_tree_add_item(tree, hf_u3v_device_info_descriptor_iDeviceGUID, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    offset++;\n\n    /* iVendorName */\n    proto_tree_add_item(tree, hf_u3v_device_info_descriptor_iVendorName, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    offset++;\n\n    /* iModelName */\n    proto_tree_add_item(tree, hf_u3v_device_info_descriptor_iModelName, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    offset++;\n\n    /* iFamilyName */\n    proto_tree_add_item(tree, hf_u3v_device_info_descriptor_iFamilyName, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    offset++;\n\n    /* iDeviceVersion */\n    proto_tree_add_item(tree, hf_u3v_device_info_descriptor_iDeviceVersion, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    offset++;\n\n    /* iManufacturerInfo */\n    proto_tree_add_item(tree, hf_u3v_device_info_descriptor_iManufacturerInfo, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    offset++;\n\n    /* iSerialNumber */\n    proto_tree_add_item(tree, hf_u3v_device_info_descriptor_iSerialNumber, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    offset++;\n\n    /* iUserDefinedName */\n    proto_tree_add_item(tree, hf_u3v_device_info_descriptor_iUserDefinedName, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    offset++;\n\n    /* bmSpeedSupport */\n    proto_tree_add_bitmask(tree, tvb, offset, hf_u3v_device_info_descriptor_bmSpeedSupport,\n                           ett_u3v_device_info_descriptor_speed_support, speed_support_fields, ENC_LITTLE_ENDIAN);\n\n    offset++;\n\n    return offset;\n}\n\n/*\n \\brief Structures for register dissection\n */\nstatic hf_register_info hf[] =\n{\n    /* Common U3V data */\n    { &hf_u3v_gencp_prefix,\n    { \"Prefix\", \"u3v.gencp.prefix\",\n    FT_UINT8, BASE_HEX, NULL, 0x0,\n    \"U3V GenCP Prefix\", HFILL\n    } },\n\n    { &hf_u3v_flag,\n    { \"Flags\", \"u3v.gencp.flags\",\n    FT_UINT16, BASE_HEX, NULL, 0x0,\n    \"U3V Flags\", HFILL\n    } },\n\n    { &hf_u3v_acknowledge_required_flag,\n    { \"Acknowledge Required\", \"u3v.gencp.flag.acq_required\",\n    FT_BOOLEAN, 16, NULL, 0x4000,\n    \"U3V Acknowledge Required\", HFILL\n    } },\n\n    { &hf_u3v_command_id,\n    { \"Command\", \"u3v.gencp.command_id\",\n    FT_UINT16, BASE_HEX, VALS( command_names ), 0x0,\n    \"U3V Command\", HFILL\n    } },\n\n    { &hf_u3v_length,\n    { \"Payload Length\", \"u3v.gencp.payloadlength\",\n    FT_UINT16, BASE_HEX_DEC, NULL, 0x0,\n    \"U3V Payload Length\", HFILL\n    } },\n\n    { &hf_u3v_request_id,\n    { \"Request ID\", \"u3v.gencp.req_id\",\n    FT_UINT16, BASE_HEX, NULL, 0x0,\n    \"U3V Request ID\", HFILL\n    } },\n\n    { &hf_u3v_payloaddata,\n    { \"Payload Data\", \"u3v.gencp.payloaddata\",\n    FT_BYTES, BASE_NONE, NULL, 0x0,\n    \"U3V Payload\", HFILL\n    } },\n\n    { &hf_u3v_status,\n    { \"Status\", \"u3v.gencp.status\",\n    FT_UINT16, BASE_HEX, VALS( status_names ), 0x0,\n    \"U3V Status\", HFILL\n    } },\n\n    /* Read memory */\n    { &hf_u3v_address,\n    { \"Address\", \"u3v.gencp.address\",\n    FT_UINT64, BASE_HEX, NULL, 0x0,\n    \"U3V Address\", HFILL } },\n\n    { &hf_u3v_count,\n    { \"Count\", \"u3v.gencp.count\",\n    FT_UINT16, BASE_HEX_DEC, NULL, 0x0,\n    \"U3V Count\", HFILL\n    } },\n\n    /* Event */\n\n    { &hf_u3v_eventcmd_id,\n    { \"ID\", \"u3v.cmd.event.id\",\n    FT_UINT16, BASE_HEX_DEC, VALS( event_id_names ), 0x0,\n    \"U3V Event ID\", HFILL\n    } },\n\n    { &hf_u3v_eventcmd_error_id,\n    { \"Error ID\", \"u3v.cmd.event.errorid\",\n    FT_UINT16, BASE_HEX_DEC, NULL, 0x0,\n    \"U3V Event Error ID\", HFILL\n    } },\n\n    { &hf_u3v_eventcmd_device_specific_id,\n    { \"Device Specific ID\", \"u3v.cmd.event.devicespecificid\",\n    FT_UINT16, BASE_HEX_DEC, NULL, 0x0,\n    \"U3V Event Device Specific ID\", HFILL\n    } },\n\n    { &hf_u3v_eventcmd_timestamp,\n    { \"Timestamp\", \"u3v.cmd.event.timestamp\",\n    FT_UINT64, BASE_HEX_DEC, NULL, 0x0,\n    \"U3V Event Timestamp\", HFILL\n    } },\n\n    { &hf_u3v_eventcmd_data,\n    { \"Data\", \"u3v.cmd.event.data\",\n    FT_BYTES, BASE_NONE, NULL, 0x0,\n    \"U3V Event Data\", HFILL\n    } },\n\n    /* Pending acknowledge */\n    { &hf_u3v_time_to_completion,\n    { \"Time to completion\", \"u3v.gencp.timetocompletion\",\n    FT_UINT16, BASE_DEC, NULL, 0x0,\n    \"U3V Time to completion [ms]\", HFILL\n    } },\n\n    { &hf_u3v_reserved,\n    { \"Reserved\", \"u3v.reserved\",\n    FT_BYTES, BASE_NONE, NULL, 0,\n    NULL, HFILL\n    } },\n\n    /* Custom */\n    { &hf_u3v_custom_memory_addr,\n    { \"Custom Memory Address\", \"u3v.gencp.custom_addr\",\n    FT_UINT64, BASE_HEX, NULL, 0x0,\n    \"U3V Custom Memory Address\", HFILL\n    } },\n\n    { &hf_u3v_custom_memory_data,\n    { \"Custom Memory Data\", \"u3v.gencp.custom_data\",\n    FT_BYTES, BASE_NONE, NULL, 0x0,\n    \"U3V Custom Memory Data\", HFILL\n    } },\n\n    /* Bootstrap Defines */\n    { &hf_u3v_bootstrap_GenCP_Version,\n    { \"GenCP Version\", \"u3v.bootstrap.GenCP_Version\",\n    FT_UINT32, BASE_DEC, NULL, 0x0,\n    \"Complying GenCP Version\", HFILL\n    } },\n\n    { &hf_u3v_bootstrap_Manufacturer_Name,\n    { \"Manufacturer Name\", \"u3v.bootstrap.Manufacturer_Name\",\n    FT_STRING, BASE_NONE, NULL, 0x0,\n    \"String containing the self-describing name of the manufacturer\", HFILL\n    } },\n\n    { &hf_u3v_bootstrap_Model_Name,\n    { \"Model Name\", \"u3v.bootstrap.Model_Name\",\n    FT_STRING, BASE_NONE, NULL, 0x0,\n    \"String containing the self-describing name of the device model\", HFILL\n    } },\n\n    { &hf_u3v_bootstrap_Family_Name,\n    { \"Family Name\", \"u3v.bootstrap.Family_Name\",\n    FT_STRING, BASE_NONE, NULL, 0x0,\n    \"String containing the name of the family of this device\", HFILL\n    } },\n\n    { &hf_u3v_bootstrap_Device_Version,\n    { \"Device Version\", \"u3v.bootstrap.Device_Version\",\n    FT_STRING, BASE_NONE, NULL, 0x0,\n    \"String containing the version of this device\", HFILL\n    } },\n\n    { &hf_u3v_bootstrap_Manufacturer_Info,\n    { \"Manufacturer Information\", \"u3v.bootstrap.Manufacturer_Info\",\n    FT_STRING, BASE_NONE, NULL, 0x0,\n    \"String containing additional manufacturer information\", HFILL\n    } },\n\n    { &hf_u3v_bootstrap_Serial_Number,\n    { \"Serial Number\", \"u3v.bootstrap.Serial_Number\",\n    FT_STRING, BASE_NONE, NULL, 0x0,\n    \"String containing the serial number of the device\", HFILL\n    } },\n\n    { &hf_u3v_bootstrap_User_Defined_Name,\n    { \"User Defined Name\", \"u3v.bootstrap.User_Defined_Name\",\n    FT_STRING, BASE_NONE, NULL, 0x0,\n    \"String containing the user defined name of the device\", HFILL\n    } },\n\n    { &hf_u3v_bootstrap_Device_Capability,\n    { \"Device Capabilities\", \"u3v.bootstrap.Device_Capability\",\n    FT_UINT64, BASE_DEC, NULL, 0x0,\n    \"Bit field describing the device?s capabilities\", HFILL\n    } },\n\n    { &hf_u3v_bootstrap_Maximum_Device_Response_Time,\n    { \"Device Maximum response time in ms\", \"u3v.bootstrap.Maximum_Device_Response_Time\",\n    FT_UINT32, BASE_DEC, NULL, 0x0,\n    \"Maximum response time in ms\", HFILL\n    } },\n\n    { &hf_u3v_bootstrap_Manifest_Table_Address,\n    { \"Pointer to the Manifest Table\", \"u3v.bootstrap.Manifest_Table_Address\",\n    FT_UINT64, BASE_HEX, NULL, 0x0,\n    NULL, HFILL\n    } },\n\n    { &hf_u3v_bootstrap_SBRM_Address,\n    { \"Pointer to the SBRM\", \"u3v.bootstrap.SBRM_Address\",\n    FT_UINT64, BASE_HEX, NULL, 0x0,\n    \"Pointer to the Technology Specific Bootstrap Register Map\", HFILL\n    } },\n\n    { &hf_u3v_bootstrap_Device_Configuration,\n    { \"Device Configuration\", \"u3v.bootstrap.Device_Configuration\",\n    FT_UINT64, BASE_DEC, NULL, 0x0,\n    \"Bit field describing the device?s configuration\", HFILL\n    } },\n\n    { &hf_u3v_bootstrap_Heartbeat_Timeout,\n    { \"Heartbeat Timeout in ms.\", \"u3v.bootstrap.Heartbeat_Timeout\",\n    FT_UINT32, BASE_DEC, NULL, 0x0,\n    \"Heartbeat Timeout in ms. Not used for these specification.\", HFILL\n    } },\n\n    { &hf_u3v_bootstrap_Message_Channel_channel_id,\n    { \"Message channel id\", \"u3v.bootstrap.Message_Channel_channel_id\",\n    FT_UINT32, BASE_DEC, NULL, 0x0,\n    \"channel_id use for the message channel\", HFILL\n    } },\n\n    { &hf_u3v_bootstrap_Timestamp,\n    { \"Timestamp\", \"u3v.bootstrap.Timestamp\",\n    FT_UINT64, BASE_DEC, NULL, 0x0,\n    \"Current device time in ns\", HFILL\n    } },\n\n    { &hf_u3v_bootstrap_Timestamp_Latch,\n    { \"Latch Timestamp\", \"u3v.bootstrap.Timestamp_Latch\",\n    FT_UINT32, BASE_DEC, NULL, 0x0,\n    \"Timestamp Latch\", HFILL\n    } },\n\n    { &hf_u3v_bootstrap_Timestamp_Increment,\n    { \"Timestamp Increment Value\", \"u3v.bootstrap.Timestamp_Increment\",\n    FT_UINT64, BASE_DEC, NULL, 0x0,\n    \"Timestamp Increment\", HFILL\n    } },\n\n    { &hf_u3v_bootstrap_Access_Privilege,\n    { \"Access Privilege.\", \"u3v.bootstrap.Access_Privilege\",\n    FT_UINT32, BASE_DEC, NULL, 0x0,\n    \"Access Privilege. Not used for these specification.\", HFILL\n    } },\n\n    { &hf_u3v_bootstrap_Protocol_Endianess,\n    { \"Protocol Endianess\", \"u3v.bootstrap.Protocol_Endianess\",\n    FT_UINT32, BASE_DEC, NULL, 0x0,\n    \"Endianess of protocol fields and bootstrap registers. Only little endian is supported by these specification.\", HFILL\n    } },\n\n    { &hf_u3v_bootstrap_Implementation_Endianess,\n    { \"Device Endianess\", \"u3v.bootstrap.Implementation_Endianess\",\n    FT_UINT32, BASE_DEC, NULL, 0x0,\n    \"Endianess of device implementation registers.  Only little endian is supported by these specification.\", HFILL\n    } },\n\n    { &hf_u3v_bootstrap_U3V_Version,\n    { \"TL Version\", \"u3v.bootstrap.U3V_Version\",\n    FT_UINT32, BASE_DEC, NULL, 0x0,\n    \"Version of the TL specification\", HFILL\n    } },\n\n    { &hf_u3v_bootstrap_U3VCP_Capability_Register,\n    { \"Control channel capabilities\", \"u3v.bootstrap.U3VCP_Capability_Register\",\n    FT_UINT64, BASE_DEC, NULL, 0x0,\n    \"Indicates additional features on the control channel\", HFILL\n    } },\n\n    { &hf_u3v_bootstrap_U3VCP_Configuration_Register,\n    { \"Control channel configuration\", \"u3v.bootstrap.U3VCP_Configuration_Register\",\n    FT_UINT64, BASE_DEC, NULL, 0x0,\n    \"Configures additional features on the control channel\", HFILL\n    } },\n\n    { &hf_u3v_bootstrap_Maximum_Command_Transfer_Length,\n    { \"Maximum Command Transfer Length\", \"u3v.bootstrap.Maximum_Command_Transfer_Length\",\n    FT_UINT32, BASE_DEC, NULL, 0x0,\n    \"Specifies the maximum supported command transfer length of the device\", HFILL\n    } },\n\n    { &hf_u3v_bootstrap_Maximum_Acknowledge_Transfer_Length,\n    { \"Maximum Acknowledge Transfer Length\", \"u3v.bootstrap.Maximum_Acknowledge_Transfer_Length\",\n    FT_UINT32, BASE_DEC, NULL, 0x0,\n    \"Specifies the maximum supported acknowledge transfer length of the device\", HFILL\n    } },\n\n    { &hf_u3v_bootstrap_Number_of_Stream_Channels,\n    { \"Number of Stream Channels\", \"u3v.bootstrap.Number_of_Stream_Channels\",\n    FT_UINT32, BASE_DEC, NULL, 0x0,\n    \"Number of Stream Channels and its corresponding Streaming Interface Register Maps (SIRM)\", HFILL\n    } },\n\n    { &hf_u3v_bootstrap_SIRM_Address,\n    { \"Pointer to the first SIRM\", \"u3v.bootstrap.SIRM_Address\",\n    FT_UINT64, BASE_HEX, NULL, 0x0,\n    \"Pointer to the first Streaming Interface Register Map.\", HFILL\n    } },\n\n    { &hf_u3v_bootstrap_SIRM_Length,\n    { \"Length of SIRM\", \"u3v.bootstrap.SIRM_Length\",\n    FT_UINT32, BASE_HEX, NULL, 0x0,\n    \"Specifies the length of each SIRM\", HFILL\n    } },\n\n    { &hf_u3v_bootstrap_EIRM_Address,\n    { \"Pointer to the EIRM\", \"u3v.bootstrap.EIRM_Address\",\n    FT_UINT64, BASE_HEX, NULL, 0x0,\n    \"Pointer to the Event Interface Register Map.\", HFILL\n    } },\n\n    { &hf_u3v_bootstrap_EIRM_Length,\n    { \"Length of EIRM\", \"u3v.bootstrap.EIRM_Length\",\n    FT_UINT32, BASE_DEC, NULL, 0x0,\n    \"Specifies the length of the EIRM\", HFILL\n    } },\n\n    { &hf_u3v_bootstrap_IIDC2_Address,\n    { \"Pointer to the IIDC2\", \"u3v.bootstrap.IIDC2_Address\",\n    FT_UINT64, BASE_HEX, NULL, 0x0,\n    \"Pointer to the IIDC2 register set.\", HFILL\n    } },\n\n    { &hf_u3v_bootstrap_Current_Speed,\n    { \"LinkSpeed\", \"u3v.bootstrap.Current_Speed\",\n    FT_UINT32, BASE_DEC, NULL, 0x0,\n    \"Specifies the current speed of the USB link.\", HFILL\n    } },\n\n    { &hf_u3v_bootstrap_SI_Info,\n    { \"Stream Info\", \"u3v.bootstrap.SI_Info\",\n    FT_UINT32, BASE_DEC, NULL, 0x0,\n    \"Device reports information about stream interface\", HFILL\n    } },\n\n    { &hf_u3v_bootstrap_SI_Control,\n    { \"Stream Control\", \"u3v.bootstrap.SI_Control\",\n    FT_UINT32, BASE_DEC, NULL, 0x0,\n    \"Stream interface Operation Control\", HFILL\n    } },\n\n    { &hf_u3v_bootstrap_SI_Required_Payload_Size,\n    { \"Stream Max Required Payload Size\", \"u3v.bootstrap.SI_Required_Payload_Size\",\n    FT_UINT64, BASE_DEC, NULL, 0x0,\n    \"Device reports maximum payload size with current settings\", HFILL\n    } },\n\n    { &hf_u3v_bootstrap_SI_Required_Leader_Size,\n    { \"Stream Max Required Leader Size\", \"u3v.bootstrap.SI_Required_Leader_Size\",\n    FT_UINT32, BASE_DEC, NULL, 0x0,\n    \"Device reports maximum leader  size it will use\", HFILL\n    } },\n\n    { &hf_u3v_bootstrap_SI_Required_Trailer_Size,\n    { \"Stream Max Required Trailer Size\", \"u3v.bootstrap.SI_Required_Trailer_Size\",\n    FT_UINT32, BASE_DEC, NULL, 0x0,\n    \"Device reports maximum trailer  size it will use\", HFILL\n    } },\n\n    { &hf_u3v_bootstrap_SI_Maximum_Leader_Size,\n    { \"Stream Max leader size\", \"u3v.bootstrap.SI_Maximum_Leader_Size\",\n    FT_UINT32, BASE_DEC, NULL, 0x0,\n    \"Maximum leader size\", HFILL\n    } },\n\n    { &hf_u3v_bootstrap_SI_Payload_Transfer_Size,\n    { \"Stream transfer size\", \"u3v.bootstrap.SI_Payload_Transfer_Size\",\n    FT_UINT32, BASE_DEC, NULL, 0x0,\n    \"Expected Size of a single Payload Transfer\", HFILL\n    } },\n\n    { &hf_u3v_bootstrap_SI_Payload_Transfer_Count,\n    { \"Stream transfer count\", \"u3v.bootstrap.SI_Payload_Transfer_Count\",\n    FT_UINT32, BASE_DEC, NULL, 0x0,\n    \"Expected Number of Payload Transfers\", HFILL\n    } },\n\n    { &hf_u3v_bootstrap_SI_Payload_Final_Transfer1_Size,\n    { \"Stream final transfer 1 size\", \"u3v.bootstrap.SI_Payload_Final_Transfer1_Size\",\n    FT_UINT32, BASE_DEC, NULL, 0x0,\n    \"Size of first final Payload transfer\", HFILL\n    } },\n\n    { &hf_u3v_bootstrap_SI_Payload_Final_Transfer2_Size,\n    { \"Stream final transfer 2 size\", \"u3v.bootstrap.SI_Payload_Final_Transfer2_Size\",\n    FT_UINT32, BASE_DEC, NULL, 0x0,\n    \"Size of second final Payload transfer\", HFILL\n    } },\n\n    { &hf_u3v_bootstrap_SI_Maximum_Trailer_Size,\n    { \"Stream Max trailer size\", \"u3v.bootstrap.SI_Maximum_Trailer_Size\",\n    FT_UINT32, BASE_DEC, NULL, 0x0,\n    \"Maximum trailer size\", HFILL\n    } },\n\n    { &hf_u3v_bootstrap_EI_Control,\n    { \"Event Interface Control\", \"u3v.bootstrap.EI_Control\",\n    FT_UINT32, BASE_DEC, NULL, 0x0,\n    \"Event Interface Control Register\", HFILL\n    } },\n\n    { &hf_u3v_bootstrap_Maximum_Event_Transfer_Length,\n    { \"Event max Transfer size\", \"u3v.bootstrap.Maximum_Event_Transfer_Length\",\n    FT_UINT32, BASE_DEC, NULL, 0x0,\n    \"Specifies the maximum supported event command transfer length of the device.\", HFILL\n    } },\n\n    { &hf_u3v_bootstrap_Event_Test_Control,\n    { \"Event test event control\", \"u3v.bootstrap.Event_Test_Control\",\n    FT_UINT32, BASE_DEC, NULL, 0x0,\n    \"Control the generation of test events.\", HFILL\n    } },\n\n    { &hf_u3v_stream_prefix,\n    { \"Stream Prefix\", \"u3v.stream.prefix\",\n    FT_UINT32, BASE_HEX, NULL, 0,\n    \"U3V stream prefix\", HFILL\n    } },\n\n    { &hf_u3v_stream_reserved,\n    { \"Reserved\", \"u3v.stream.reserved\",\n    FT_BYTES, BASE_NONE, NULL, 0,\n    NULL, HFILL\n    } },\n\n    { &hf_u3v_stream_leader_size,\n    { \"Leader Size\", \"u3v.stream.leader_size\",\n    FT_UINT16, BASE_DEC, NULL, 0x0,\n    \"U3V stream leader size\", HFILL\n    } },\n\n    { &hf_u3v_stream_trailer_size,\n    { \"Trailer Size\", \"u3v.stream.trailer_size\",\n    FT_UINT16, BASE_DEC, NULL, 0x0,\n    \"U3V stream trailer size\", HFILL\n    } },\n\n    { &hf_u3v_stream_block_id,\n    { \"Block ID\", \"u3v.stream.block_id\",\n    FT_UINT64, BASE_DEC, NULL, 0x0,\n    \"U3V stream block id\", HFILL\n    } },\n\n    { &hf_u3v_stream_payload_type,\n    { \"Payload Type\", \"u3v.stream.payload_type\",\n    FT_UINT16, BASE_HEX, VALS( payload_type_names ), 0x0,\n    \"U3V Payload Type\", HFILL\n    } },\n\n    { &hf_u3v_stream_timestamp,\n    { \"Timestamp\", \"u3v.stream.timestamp\",\n    FT_UINT64, BASE_HEX_DEC, NULL, 0x0,\n    \"U3V Stream Timestamp\", HFILL\n    } },\n\n    { &hf_u3v_stream_pixel_format,\n    { \"Pixel Format\", \"u3v.stream.pixel_format\",\n    FT_UINT32, BASE_HEX|BASE_EXT_STRING, VALS_EXT_PTR( &pixel_format_names_ext ), 0x0,\n    \"U3V Stream Pixel Format\", HFILL\n    } },\n\n    { &hf_u3v_stream_size_x,\n    { \"Size X\", \"u3v.stream.sizex\",\n    FT_UINT32, BASE_DEC, NULL, 0x0,\n    \"U3V Stream Size X\", HFILL\n    } },\n\n    { &hf_u3v_stream_size_y,\n    { \"Size Y\", \"u3v.stream.sizey\",\n    FT_UINT32, BASE_DEC, NULL, 0x0,\n    \"U3V Stream Size Y\", HFILL\n    } },\n\n    { &hf_u3v_stream_offset_x,\n    { \"Offset X\", \"u3v.stream.offsetx\",\n    FT_UINT32, BASE_DEC, NULL, 0x0,\n    \"U3V Stream Offset X\", HFILL\n    } },\n\n    { &hf_u3v_stream_offset_y,\n    { \"Offset Y\", \"u3v.stream.offsety\",\n    FT_UINT32, BASE_DEC, NULL, 0x0,\n    \"U3V Stream Offset Y\", HFILL\n    } },\n\n    { &hf_u3v_stream_padding_x,\n    { \"Padding X\", \"u3v.stream.paddingx\",\n    FT_UINT16, BASE_DEC, NULL, 0x0,\n    \"U3V Stream Padding X\", HFILL\n    } },\n\n    { &hf_u3v_stream_chunk_layout_id,\n    { \"Chunk Layout ID\", \"u3v.stream.chunk_layout_id\",\n    FT_UINT32, BASE_HEX, NULL, 0x0,\n    \"U3V Stream Chunk Layout ID\", HFILL\n    } },\n\n    { &hf_u3v_stream_valid_payload_size,\n    { \"Valid Payload Size\", \"u3v.stream.valid_payload_size\",\n    FT_UINT64, BASE_HEX, NULL, 0x0,\n    \"U3V Stream Valid Payload Size\", HFILL\n    } },\n\n    { &hf_u3v_stream_status,\n    { \"Status\", \"u3v.stream.status\",\n    FT_UINT16, BASE_HEX, VALS( status_names ), 0x0,\n    \"U3V Stream Status\", HFILL\n    } },\n\n    { &hf_u3v_stream_data,\n    { \"Payload Data\", \"u3v.stream.data\",\n    FT_BYTES, BASE_NONE, NULL, 0x0,\n    \"U3V Stream Payload Data\", HFILL\n    } },\n\n    /* U3V device info descriptor */\n    { &hf_u3v_device_info_descriptor_bLength,\n    { \"bLength\", \"u3v.device_info.bLength\",\n    FT_UINT8, BASE_DEC, NULL, 0x0,\n    NULL, HFILL } },\n\n    { &hf_u3v_device_info_descriptor_bDescriptorType,\n    { \"bDescriptorType\", \"u3v.device_info.bDescriptorType\",\n    FT_UINT8, BASE_HEX, NULL, 0x0,\n    NULL, HFILL } },\n\n    { &hf_u3v_device_info_descriptor_bDescriptorSubtype,\n    { \"bDescriptorSubtype\", \"u3v.device_info.bDescriptorSubtype\",\n    FT_UINT8, BASE_HEX, VALS( u3v_descriptor_subtypes ), 0x0,\n    NULL, HFILL } },\n\n    { &hf_u3v_device_info_descriptor_bGenCPVersion,\n    { \"bGenCPVersion\", \"u3v.device_info.bGenCPVersion\",\n    FT_NONE, BASE_NONE, NULL, 0x0,\n    NULL, HFILL } },\n\n    { &hf_u3v_device_info_descriptor_bGenCPVersion_minor,\n    { \"Minor Version\", \"u3v.device_info.bGenCPVersion.minor\",\n    FT_UINT32, BASE_DEC, NULL, 0x0000FFFF,\n    NULL, HFILL } },\n\n    { &hf_u3v_device_info_descriptor_bGenCPVersion_major,\n    { \"Major Version\", \"u3v.device_info.bGenCPVersion.major\",\n    FT_UINT32, BASE_DEC, NULL, 0xFFFF0000,\n    NULL, HFILL } },\n\n    { &hf_u3v_device_info_descriptor_bU3VVersion,\n    { \"bU3VVersion\", \"u3v.device_info.bU3VVersion\",\n    FT_NONE, BASE_NONE, NULL, 0x0,\n    NULL, HFILL } },\n\n    { &hf_u3v_device_info_descriptor_bU3VVersion_minor,\n    { \"Minor Version\", \"u3v.device_info.bU3VVersion.minor\",\n    FT_UINT32, BASE_DEC, NULL, 0x0000FFFF,\n    NULL, HFILL } },\n\n    { &hf_u3v_device_info_descriptor_bU3VVersion_major,\n    { \"Major Version\", \"u3v.device_info.bU3VVersion.major\",\n    FT_UINT32, BASE_DEC, NULL, 0xFFFF0000,\n    NULL, HFILL } },\n\n    { &hf_u3v_device_info_descriptor_iDeviceGUID,\n    { \"iDeviceGUID\", \"u3v.device_info.iDeviceGUID\",\n    FT_UINT8, BASE_DEC, NULL, 0x0,\n    NULL, HFILL } },\n\n    { &hf_u3v_device_info_descriptor_iVendorName,\n    { \"iVendorName\", \"u3v.device_info.iVendorName\",\n    FT_UINT8, BASE_DEC, NULL, 0x0,\n    NULL, HFILL } },\n\n    { &hf_u3v_device_info_descriptor_iModelName,\n    { \"iModelName\", \"u3v.device_info.iModelName\",\n    FT_UINT8, BASE_DEC, NULL, 0x0,\n    NULL, HFILL } },\n\n    { &hf_u3v_device_info_descriptor_iFamilyName,\n    { \"iFamilyName\", \"u3v.device_info.iFamilyName\",\n    FT_UINT8, BASE_DEC, NULL, 0x0,\n    NULL, HFILL } },\n\n    { &hf_u3v_device_info_descriptor_iDeviceVersion,\n    { \"iDeviceVersion\", \"u3v.device_info.iDeviceVersion\",\n    FT_UINT8, BASE_DEC, NULL, 0x0,\n    NULL, HFILL } },\n\n    { &hf_u3v_device_info_descriptor_iManufacturerInfo,\n    { \"iManufacturerInfo\", \"u3v.device_info.iManufacturerInfo\",\n    FT_UINT8, BASE_DEC, NULL, 0x0,\n    NULL, HFILL } },\n\n    { &hf_u3v_device_info_descriptor_iSerialNumber,\n    { \"iSerialNumber\", \"u3v.device_info.iSerialNumber\",\n    FT_UINT8, BASE_DEC, NULL, 0x0,\n    NULL, HFILL } },\n\n    { &hf_u3v_device_info_descriptor_iUserDefinedName,\n    { \"iVendorName\", \"u3v.device_info.iUserDefinedName\",\n    FT_UINT8, BASE_DEC, NULL, 0x0,\n    NULL, HFILL } },\n\n    { &hf_u3v_device_info_descriptor_bmSpeedSupport,\n    { \"bmSpeedSupport\", \"u3v.device_info.bmSpeedSupport\",\n    FT_UINT8, BASE_HEX, NULL, 0x0,\n    NULL, HFILL } },\n\n    { &hf_u3v_device_info_descriptor_bmSpeedSupport_low_speed,\n    { \"Low-Speed\", \"u3v.device_info.bmSpeedSupport.lowSpeed\",\n    FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x01,\n    NULL, HFILL } },\n\n    { &hf_u3v_device_info_descriptor_bmSpeedSupport_full_speed,\n    { \"Full-Speed\", \"u3v.device_info.bmSpeedSupport.fullSpeed\",\n    FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x02,\n    NULL, HFILL } },\n\n    { &hf_u3v_device_info_descriptor_bmSpeedSupport_high_speed,\n    { \"High-Speed\", \"u3v.device_info.bmSpeedSupport.highSpeed\",\n    FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x04,\n    NULL, HFILL } },\n\n    { &hf_u3v_device_info_descriptor_bmSpeedSupport_super_speed,\n    { \"Super-Speed\", \"u3v.device_info.bmSpeedSupport.superSpeed\",\n    FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x08,\n    NULL, HFILL } },\n\n    { &hf_u3v_device_info_descriptor_bmSpeedSupport_reserved,\n    { \"Reserved\", \"u3v.device_info.bmSpeedSupport.reserved\",\n    FT_UINT8, BASE_HEX, NULL, 0xF0,\n    NULL, HFILL } },\n\n    { &hf_u3v_scd_readmem_cmd,\n    { \"SCD: READMEM_CMD\", \"u3v.scd_readmem_cmd\",\n    FT_NONE, BASE_NONE, NULL, 0x0,\n    NULL, HFILL } },\n\n    { &hf_u3v_scd_writemem_cmd,\n    { \"SCD: WRITEMEM_CMD\", \"u3v.scd_writemem_cmd\",\n    FT_NONE, BASE_NONE, NULL, 0x0,\n    NULL, HFILL } },\n\n    { &hf_u3v_scd_event_cmd,\n    { \"SCD: EVENT_CMD\", \"u3v.scd_event_cmd\",\n    FT_NONE, BASE_NONE, NULL, 0x0,\n    NULL, HFILL } },\n\n    { &hf_u3v_scd_ack_readmem_ack,\n    { \"SCD: READMEM_ACK\", \"u3v.scd_ack_readmem_ack\",\n    FT_NONE, BASE_NONE, NULL, 0x0,\n    NULL, HFILL } },\n\n    { &hf_u3v_scd_writemem_ack,\n    { \"SCD: WRITEMEM_ACK\", \"u3v.scd_writemem_ack\",\n    FT_NONE, BASE_NONE, NULL, 0x0,\n    NULL, HFILL } },\n\n    { &hf_u3v_ccd_pending_ack,\n    { \"CCD: PENDING_ACK\", \"u3v.ccd_pending_ack\",\n    FT_NONE, BASE_NONE, NULL, 0x0,\n    NULL, HFILL } },\n\n    { &hf_u3v_stream_leader,\n    { \"Stream: Leader\", \"u3v.stream_leader\",\n    FT_NONE, BASE_NONE, NULL, 0x0,\n    NULL, HFILL } },\n\n    { &hf_u3v_stream_trailer,\n    { \"Stream: Trailer\", \"u3v.stream_trailer\",\n    FT_NONE, BASE_NONE, NULL, 0x0,\n    NULL, HFILL } },\n\n    { &hf_u3v_stream_payload,\n    { \"Stream: Payload\", \"u3v.stream_payload\",\n    FT_NONE, BASE_NONE, NULL, 0x0,\n    NULL, HFILL } },\n\n    { &hf_u3v_ccd_cmd,\n    { \"CCD\", \"u3v.ccd_cmd\",\n    FT_NONE, BASE_NONE, NULL, 0x0,\n    NULL, HFILL } },\n\n    { &hf_u3v_ccd_ack,\n    { \"CCD\", \"u3v.ccd_ack\",\n    FT_NONE, BASE_NONE, NULL, 0x0,\n    NULL, HFILL } },\n\n    { &hf_u3v_device_info_descriptor,\n    { \"U3V DEVICE INFO DESCRIPTOR\", \"u3v.device_info_descriptor\",\n    FT_NONE, BASE_NONE, NULL, 0x0,\n    NULL, HFILL } }\n};\n\nvoid\nproto_register_u3v(void)\n{\n    static gint *ett[] = {\n        &ett_u3v,\n        &ett_u3v_cmd,\n        &ett_u3v_flags,\n        &ett_u3v_ack,\n        &ett_u3v_payload_cmd,\n        &ett_u3v_payload_ack,\n        &ett_u3v_payload_ack_subtree,\n        &ett_u3v_payload_cmd_subtree,\n        &ett_u3v_bootstrap_fields,\n        &ett_u3v_stream_leader,\n        &ett_u3v_stream_trailer,\n        &ett_u3v_stream_payload,\n        &ett_u3v_device_info_descriptor,\n        &ett_u3v_device_info_descriptor_speed_support,\n        &ett_u3v_device_info_descriptor_gencp_version,\n        &ett_u3v_device_info_descriptor_u3v_version,\n    };\n\n    proto_u3v = proto_register_protocol(\"USB 3 Vision\", \"U3V\", \"u3v\");\n    proto_register_field_array(proto_u3v, hf, array_length(hf));\n    proto_register_subtree_array(ett, array_length(ett));\n    register_dissector(\"u3v\", dissect_u3v, proto_u3v);\n}\n\n\n\nvoid\nproto_reg_handoff_u3v(void)\n{\n    dissector_handle_t u3v_handle = NULL;\n    dissector_handle_t u3v_descr_handle = NULL;\n\n    u3v_handle = find_dissector(\"u3v\");\n    dissector_add_uint(\"usb.bulk\", IF_CLASS_MISCELLANEOUS, u3v_handle);\n    heur_dissector_add(\"usb.bulk\", dissect_u3v_heur, \"USB3Vision Protocol\", \"u3v\", proto_u3v,HEURISTIC_ENABLE);\n    u3v_descr_handle = create_dissector_handle(dissect_u3v_descriptors, proto_u3v);\n    dissector_add_uint(\"usb.descriptor\", IF_CLASS_MISCELLANEOUS, u3v_descr_handle);\n}\n\n/*\n * Editor modelines  -  https://www.wireshark.org/tools/modelines.html\n *\n * Local variables:\n * c-basic-offset: 4\n * tab-width: 8\n * indent-tabs-mode: nil\n * End:\n *\n * vi: set shiftwidth=4 tabstop=8 expandtab:\n * :indentSize=4:tabSize=8:noTabs=true:\n */\n", "code_before": "/* packet-u3v.c\n * Routines for AIA USB3 Vision (TM) Protocol dissection\n * Copyright 2016, AIA (www.visiononline.org)\n *\n * USB3 Vision (TM): USB3 Vision a standard developed under the sponsorship of\n * the AIA for the benefit of the machine vision industry.\n * U3V stands for USB3 Vision (TM) Protocol.\n *\n * Wireshark - Network traffic analyzer\n * By Gerald Combs <gerald@wireshark.org>\n * Copyright 1998 Gerald Combs\n *\n * SPDX-License-Identifier: GPL-2.0-or-later\n */\n\n#include \"config.h\"\n\n#include <epan/packet.h>\n#include <epan/proto_data.h>\n#include \"packet-usb.h\"\n\n/*\nU3V descriptor constants\n*/\n#define DESCRIPTOR_TYPE_U3V_INTERFACE 0x24\n#define DESCRIPTOR_SUBTYPE_U3V_DEVICE_INFO 0x01\n\n/*\n Bootstrap registers addresses\n */\n#define U3V_ABRM_GENCP_VERSION 0x00000000\n#define U3V_ABRM_MANUFACTURER_NAME 0x00000004\n#define U3V_ABRM_MODEL_NAME 0x00000044\n#define U3V_ABRM_FAMILY_NAME 0x00000084\n#define U3V_ABRM_DEVICE_VERSION 0x000000C4\n#define U3V_ABRM_MANUFACTURER_INFO 0x00000104\n#define U3V_ABRM_SERIAL_NUMBER 0x00000144\n#define U3V_ABRM_USER_DEFINED_NAME 0x00000184\n#define U3V_ABRM_DEVICE_CAPABILITY 0x000001C4\n#define U3V_ABRM_MAXIMUM_DEVICE_RESPONSE_TIME 0x000001CC\n#define U3V_ABRM_MANIFEST_TABLE_ADDRESS 0x000001D0\n#define U3V_ABRM_SBRM_ADDRESS 0x000001D8\n#define U3V_ABRM_DEVICE_CONFIGURATION 0x000001E0\n#define U3V_ABRM_HEARTBEAT_TIMEOUT 0x000001E8\n#define U3V_ABRM_MESSAGE_CHANNEL_CHANNEL_ID 0x000001EC\n#define U3V_ABRM_TIMESTAMP 0x000001F0\n#define U3V_ABRM_TIMESTAMP_LATCH 0x000001F8\n#define U3V_ABRM_TIMESTAMP_INCREMENT 0x000001FC\n#define U3V_ABRM_ACCESS_PRIVILEGE 0x00000204\n#define U3V_ABRM_PROTOCOL_ENDIANNESS 0x00000208\n#define U3V_ABRM_IMPLEMENTATION_ENDIANNESS 0x0000020C\n#define U3V_SBRM_U3V_VERSION 0x00000000\n#define U3V_SBRM_U3VCP_CAPABILITY_REGISTER 0x00000004\n#define U3V_SBRM_U3VCP_CONFIGURATION_REGISTER 0x0000000C\n#define U3V_SBRM_MAXIMUM_COMMAND_TRANSFER_LENGTH 0x00000014\n#define U3V_SBRM_MAXIMUM_ACKNOWLEDGE_TRANSFER_LENGTH 0x00000018\n#define U3V_SBRM_NUMBER_OF_STREAM_CHANNELS 0x0000001C\n#define U3V_SBRM_SIRM_ADDRESS 0x00000020\n#define U3V_SBRM_SIRM_LENGTH 0x00000028\n#define U3V_SBRM_EIRM_ADDRESS 0x0000002C\n#define U3V_SBRM_EIRM_LENGTH 0x00000034\n#define U3V_SBRM_IIDC2_ADDRESS 0x00000038\n#define U3V_SBRM_CURRENT_SPEED 0x00000040\n#define U3V_SIRM_SI_INFO 0x00000000\n#define U3V_SIRM_SI_CONTROL 0x00000004\n#define U3V_SIRM_SI_REQUIRED_PAYLOAD_SIZE 0x00000008\n#define U3V_SIRM_SI_REQUIRED_LEADER_SIZE 0x00000010\n#define U3V_SIRM_SI_REQUIRED_TRAILER_SIZE 0x00000014\n#define U3V_SIRM_SI_MAXIMUM_LEADER_SIZE 0x00000018\n#define U3V_SIRM_SI_PAYLOAD_TRANSFER_SIZE 0x0000001C\n#define U3V_SIRM_SI_PAYLOAD_TRANSFER_COUNT 0x00000020\n#define U3V_SIRM_SI_PAYLOAD_FINAL_TRANSFER1_SIZE 0x00000024\n#define U3V_SIRM_SI_PAYLOAD_FINAL_TRANSFER2_SIZE 0x00000028\n#define U3V_SIRM_SI_MAXIMUM_TRAILER_SIZE 0x0000002C\n#define U3V_EIRM_EI_CONTROL 0x00000000\n#define U3V_EIRM_MAXIMUM_EVENT_TRANSFER_LENGTH 0x00000004\n#define U3V_EIRM_EVENT_TEST_CONTROL 0x00000008\n\n/*\n Command and acknowledge IDs\n*/\n#define U3V_READMEM_CMD 0x0800\n#define U3V_READMEM_ACK 0x0801\n#define U3V_WRITEMEM_CMD 0x0802\n#define U3V_WRITEMEM_ACK 0x0803\n#define U3V_PENDING_ACK 0x0805\n#define U3V_EVENT_CMD 0x0C00\n#define U3V_EVENT_ACK 0x0C01\n\n/*\n Status codes\n*/\n#define U3V_STATUS_GENCP_SUCCESS               0x0000\n#define U3V_STATUS_GENCP_NOT_IMPLEMENTED       0x8001\n#define U3V_STATUS_GENCP_INVALID_PARAMETER     0x8002\n#define U3V_STATUS_GENCP_INVALID_ADDRESS       0x8003\n#define U3V_STATUS_GENCP_WRITE_PROTECT         0x8004\n#define U3V_STATUS_GENCP_BAD_ALIGNMENT         0x8005\n#define U3V_STATUS_GENCP_ACCESS_DENIED         0x8006\n#define U3V_STATUS_GENCP_BUSY                  0x8007\n/* 0x8008 - 0x800A have been used in GEV 1.x but are now deprecated. The GenCP specification did NOT recycle these values! */\n#define U3V_STATUS_GENCP_MSG_TIMEOUT           0x800B\n/* 0x800C - 0x800D are used in GEV only. The GenCP specification did NOT recycle these values! */\n#define U3V_STATUS_GENCP_INVALID_HEADER        0x800E\n#define U3V_STATUS_GENCP_WRONG_CONFIG          0x800F\n\n#define U3V_STATUS_GENCP_ERROR                 0x8FFF\n\n#define U3V_STATUS_RESEND_NOT_SUPPORTED        0xA001\n#define U3V_STATUS_DSI_ENDPOINT_HALTED         0xA002\n#define U3V_STATUS_SI_PAYLOAD_SIZE_NOT_ALIGNED 0xA003\n#define U3V_STATUS_SI_REGISTERS_INCONSISTENT   0xA004\n#define U3V_STATUS_DATA_DISCARDED              0xA100\n#define U3V_STATUS_DATA_OVERRUN                0xA101\n\n/*\n Prefix\n*/\n#define U3V_CONTROL_PREFIX 0x43563355\n#define U3V_EVENT_PREFIX   0x45563355\n\n#define U3V_STREAM_LEADER_PREFIX  0x4C563355\n#define U3V_STREAM_TRAILER_PREFIX 0x54563355\n\n/*\n Event IDs\n*/\n#define U3V_EVENT_TESTEVENT 0x4FFF\n\n/*\n * Pixel Format IDs\n*/\n#define PFNC_U3V_MONO1P 0x01010037\n#define PFNC_U3V_MONO2P 0x01020038\n#define PFNC_U3V_MONO4P 0x01040039\n#define PFNC_U3V_MONO8 0x01080001\n#define PFNC_U3V_MONO8S 0x01080002\n#define PFNC_U3V_MONO10 0x01100003\n#define PFNC_U3V_MONO10P 0x010A0046\n#define PFNC_U3V_MONO12 0x01100005\n#define PFNC_U3V_MONO12P 0x010C0047\n#define PFNC_U3V_MONO14 0x01100025\n#define PFNC_U3V_MONO14P 0x010E0104\n#define PFNC_U3V_MONO16 0x01100007\n#define PFNC_U3V_MONO32 0x01200111\n#define PFNC_U3V_BAYERBG4P 0x01040110\n#define PFNC_U3V_BAYERBG8 0x0108000B\n#define PFNC_U3V_BAYERBG10 0x0110000F\n#define PFNC_U3V_BAYERBG10P 0x010A0052\n#define PFNC_U3V_BAYERBG12 0x01100013\n#define PFNC_U3V_BAYERBG12P 0x010C0053\n#define PFNC_U3V_BAYERBG14 0x0110010C\n#define PFNC_U3V_BAYERBG14P 0x010E0108\n#define PFNC_U3V_BAYERBG16 0x01100031\n#define PFNC_U3V_BAYERGB4P 0x0104010F\n#define PFNC_U3V_BAYERGB8 0x0108000A\n#define PFNC_U3V_BAYERGB10 0x0110000E\n#define PFNC_U3V_BAYERGB10P 0x010A0054\n#define PFNC_U3V_BAYERGB12 0x01100012\n#define PFNC_U3V_BAYERGB12P 0x010C0055\n#define PFNC_U3V_BAYERGB14 0x0110010B\n#define PFNC_U3V_BAYERGB14P 0x010E0107\n#define PFNC_U3V_BAYERGB16 0x01100030\n#define PFNC_U3V_BAYERGR4P 0x0104010D\n#define PFNC_U3V_BAYERGR8 0x01080008\n#define PFNC_U3V_BAYERGR10 0x0110000C\n#define PFNC_U3V_BAYERGR10P 0x010A0056\n#define PFNC_U3V_BAYERGR12 0x01100010\n#define PFNC_U3V_BAYERGR12P 0x010C0057\n#define PFNC_U3V_BAYERGR14 0x01100109\n#define PFNC_U3V_BAYERGR14P 0x010E0105\n#define PFNC_U3V_BAYERGR16 0x0110002E\n#define PFNC_U3V_BAYERRG4P 0x0104010E\n#define PFNC_U3V_BAYERRG8 0x01080009\n#define PFNC_U3V_BAYERRG10 0x0110000D\n#define PFNC_U3V_BAYERRG10P 0x010A0058\n#define PFNC_U3V_BAYERRG12 0x01100011\n#define PFNC_U3V_BAYERRG12P 0x010C0059\n#define PFNC_U3V_BAYERRG14 0x0110010A\n#define PFNC_U3V_BAYERRG14P 0x010E0106\n#define PFNC_U3V_BAYERRG16 0x0110002F\n#define PFNC_U3V_RGBA8 0x02200016\n#define PFNC_U3V_RGBA10 0x0240005F\n#define PFNC_U3V_RGBA10P 0x02280060\n#define PFNC_U3V_RGBA12 0x02400061\n#define PFNC_U3V_RGBA12P 0x02300062\n#define PFNC_U3V_RGBA14 0x02400063\n#define PFNC_U3V_RGBA16 0x02400064\n#define PFNC_U3V_RGB8 0x02180014\n#define PFNC_U3V_RGB8_PLANAR 0x02180021\n#define PFNC_U3V_RGB10 0x02300018\n#define PFNC_U3V_RGB10_PLANAR 0x02300022\n#define PFNC_U3V_RGB10P 0x021E005C\n#define PFNC_U3V_RGB10P32 0x0220001D\n#define PFNC_U3V_RGB12 0x0230001A\n#define PFNC_U3V_RGB12_PLANAR 0x02300023\n#define PFNC_U3V_RGB12P 0x0224005D\n#define PFNC_U3V_RGB14 0x0230005E\n#define PFNC_U3V_RGB16 0x02300033\n#define PFNC_U3V_RGB16_PLANAR 0x02300024\n#define PFNC_U3V_RGB565P 0x02100035\n#define PFNC_U3V_BGRA8 0x02200017\n#define PFNC_U3V_BGRA10 0x0240004C\n#define PFNC_U3V_BGRA10P 0x0228004D\n#define PFNC_U3V_BGRA12 0x0240004E\n#define PFNC_U3V_BGRA12P 0x0230004F\n#define PFNC_U3V_BGRA14 0x02400050\n#define PFNC_U3V_BGRA16 0x02400051\n#define PFNC_U3V_BGR8 0x02180015\n#define PFNC_U3V_BGR10 0x02300019\n#define PFNC_U3V_BGR10P 0x021E0048\n#define PFNC_U3V_BGR12 0x0230001B\n#define PFNC_U3V_BGR12P 0x02240049\n#define PFNC_U3V_BGR14 0x0230004A\n#define PFNC_U3V_BGR16 0x0230004B\n#define PFNC_U3V_BGR565P 0x02100036\n#define PFNC_U3V_R8 0x010800C9\n#define PFNC_U3V_R10 0x01100120\n#define PFNC_U3V_R10_DEPRECATED 0x010A00CA\n#define PFNC_U3V_R12 0x01100121\n#define PFNC_U3V_R12_DEPRECATED 0x010C00CB\n#define PFNC_U3V_R16 0x011000CC\n#define PFNC_U3V_G8 0x010800CD\n#define PFNC_U3V_G10 0x01100122\n#define PFNC_U3V_G10_DEPRECATED 0x010A00CE\n#define PFNC_U3V_G12 0x01100123\n#define PFNC_U3V_G12_DEPRECATED 0x010C00CF\n#define PFNC_U3V_G16 0x011000D0\n#define PFNC_U3V_B8 0x010800D1\n#define PFNC_U3V_B10 0x01100124\n#define PFNC_U3V_B10_DEPRECATED 0x010A00D2\n#define PFNC_U3V_B12 0x01100125\n#define PFNC_U3V_B12_DEPRECATED 0x010C00D3\n#define PFNC_U3V_B16 0x011000D4\n#define PFNC_U3V_COORD3D_ABC8 0x021800B2\n#define PFNC_U3V_COORD3D_ABC8_PLANAR 0x021800B3\n#define PFNC_U3V_COORD3D_ABC10P 0x021E00DB\n#define PFNC_U3V_COORD3D_ABC10P_PLANAR 0x021E00DC\n#define PFNC_U3V_COORD3D_ABC12P 0x022400DE\n#define PFNC_U3V_COORD3D_ABC12P_PLANAR 0x022400DF\n#define PFNC_U3V_COORD3D_ABC16 0x023000B9\n#define PFNC_U3V_COORD3D_ABC16_PLANAR 0x023000BA\n#define PFNC_U3V_COORD3D_ABC32F 0x026000C0\n#define PFNC_U3V_COORD3D_ABC32F_PLANAR 0x026000C1\n#define PFNC_U3V_COORD3D_AC8 0x021000B4\n#define PFNC_U3V_COORD3D_AC8_PLANAR 0x021000B5\n#define PFNC_U3V_COORD3D_AC10P 0x021400F0\n#define PFNC_U3V_COORD3D_AC10P_PLANAR 0x021400F1\n#define PFNC_U3V_COORD3D_AC12P 0x021800F2\n#define PFNC_U3V_COORD3D_AC12P_PLANAR 0x021800F3\n#define PFNC_U3V_COORD3D_AC16 0x022000BB\n#define PFNC_U3V_COORD3D_AC16_PLANAR 0x022000BC\n#define PFNC_U3V_COORD3D_AC32F 0x024000C2\n#define PFNC_U3V_COORD3D_AC32F_PLANAR 0x024000C3\n#define PFNC_U3V_COORD3D_A8 0x010800AF\n#define PFNC_U3V_COORD3D_A10P 0x010A00D5\n#define PFNC_U3V_COORD3D_A12P 0x010C00D8\n#define PFNC_U3V_COORD3D_A16 0x011000B6\n#define PFNC_U3V_COORD3D_A32F 0x012000BD\n#define PFNC_U3V_COORD3D_B8 0x010800B0\n#define PFNC_U3V_COORD3D_B10P 0x010A00D6\n#define PFNC_U3V_COORD3D_B12P 0x010C00D9\n#define PFNC_U3V_COORD3D_B16 0x011000B7\n#define PFNC_U3V_COORD3D_B32F 0x012000BE\n#define PFNC_U3V_COORD3D_C8 0x010800B1\n#define PFNC_U3V_COORD3D_C10P 0x010A00D7\n#define PFNC_U3V_COORD3D_C12P 0x010C00DA\n#define PFNC_U3V_COORD3D_C16 0x011000B8\n#define PFNC_U3V_COORD3D_C32F 0x012000BF\n#define PFNC_U3V_CONFIDENCE1 0x010800C4\n#define PFNC_U3V_CONFIDENCE1P 0x010100C5\n#define PFNC_U3V_CONFIDENCE8 0x010800C6\n#define PFNC_U3V_CONFIDENCE16 0x011000C7\n#define PFNC_U3V_CONFIDENCE32F 0x012000C8\n#define PFNC_U3V_BICOLORBGRG8 0x021000A6\n#define PFNC_U3V_BICOLORBGRG10 0x022000A9\n#define PFNC_U3V_BICOLORBGRG10P 0x021400AA\n#define PFNC_U3V_BICOLORBGRG12 0x022000AD\n#define PFNC_U3V_BICOLORBGRG12P 0x021800AE\n#define PFNC_U3V_BICOLORRGBG8 0x021000A5\n#define PFNC_U3V_BICOLORRGBG10 0x022000A7\n#define PFNC_U3V_BICOLORRGBG10P 0x021400A8\n#define PFNC_U3V_BICOLORRGBG12 0x022000AB\n#define PFNC_U3V_BICOLORRGBG12P 0x021800AC\n#define PFNC_U3V_DATA8 0x01080116\n#define PFNC_U3V_DATA8S 0x01080117\n#define PFNC_U3V_DATA16 0x01100118\n#define PFNC_U3V_DATA16S 0x01100119\n#define PFNC_U3V_DATA32 0x0120011A\n#define PFNC_U3V_DATA32F 0x0120011C\n#define PFNC_U3V_DATA32S 0x0120011B\n#define PFNC_U3V_DATA64 0x0140011D\n#define PFNC_U3V_DATA64F 0x0140011F\n#define PFNC_U3V_DATA64S 0x0140011E\n#define PFNC_U3V_SCF1WBWG8 0x01080067\n#define PFNC_U3V_SCF1WBWG10 0x01100068\n#define PFNC_U3V_SCF1WBWG10P 0x010A0069\n#define PFNC_U3V_SCF1WBWG12 0x0110006A\n#define PFNC_U3V_SCF1WBWG12P 0x010C006B\n#define PFNC_U3V_SCF1WBWG14 0x0110006C\n#define PFNC_U3V_SCF1WBWG16 0x0110006D\n#define PFNC_U3V_SCF1WGWB8 0x0108006E\n#define PFNC_U3V_SCF1WGWB10 0x0110006F\n#define PFNC_U3V_SCF1WGWB10P 0x010A0070\n#define PFNC_U3V_SCF1WGWB12 0x01100071\n#define PFNC_U3V_SCF1WGWB12P 0x010C0072\n#define PFNC_U3V_SCF1WGWB14 0x01100073\n#define PFNC_U3V_SCF1WGWB16 0x01100074\n#define PFNC_U3V_SCF1WGWR8 0x01080075\n#define PFNC_U3V_SCF1WGWR10 0x01100076\n#define PFNC_U3V_SCF1WGWR10P 0x010A0077\n#define PFNC_U3V_SCF1WGWR12 0x01100078\n#define PFNC_U3V_SCF1WGWR12P 0x010C0079\n#define PFNC_U3V_SCF1WGWR14 0x0110007A\n#define PFNC_U3V_SCF1WGWR16 0x0110007B\n#define PFNC_U3V_SCF1WRWG8 0x0108007C\n#define PFNC_U3V_SCF1WRWG10 0x0110007D\n#define PFNC_U3V_SCF1WRWG10P 0x010A007E\n#define PFNC_U3V_SCF1WRWG12 0x0110007F\n#define PFNC_U3V_SCF1WRWG12P 0x010C0080\n#define PFNC_U3V_SCF1WRWG14 0x01100081\n#define PFNC_U3V_SCF1WRWG16 0x01100082\n#define PFNC_U3V_YCBCR8 0x0218005B\n#define PFNC_U3V_YCBCR8_CBYCR 0x0218003A\n#define PFNC_U3V_YCBCR10_CBYCR 0x02300083\n#define PFNC_U3V_YCBCR10P_CBYCR 0x021E0084\n#define PFNC_U3V_YCBCR12_CBYCR 0x02300085\n#define PFNC_U3V_YCBCR12P_CBYCR 0x02240086\n#define PFNC_U3V_YCBCR411_8 0x020C005A\n#define PFNC_U3V_YCBCR411_8_CBYYCRYY 0x020C003C\n#define PFNC_U3V_YCBCR420_8_YY_CBCR_SEMIPLANAR 0x020C0112\n#define PFNC_U3V_YCBCR420_8_YY_CRCB_SEMIPLANAR 0x020C0114\n#define PFNC_U3V_YCBCR422_8 0x0210003B\n#define PFNC_U3V_YCBCR422_8_CBYCRY 0x02100043\n#define PFNC_U3V_YCBCR422_8_YY_CBCR_SEMIPLANAR 0x02100113\n#define PFNC_U3V_YCBCR422_8_YY_CRCB_SEMIPLANAR 0x02100115\n#define PFNC_U3V_YCBCR422_10 0x02200065\n#define PFNC_U3V_YCBCR422_10_CBYCRY 0x02200099\n#define PFNC_U3V_YCBCR422_10P 0x02140087\n#define PFNC_U3V_YCBCR422_10P_CBYCRY 0x0214009A\n#define PFNC_U3V_YCBCR422_12 0x02200066\n#define PFNC_U3V_YCBCR422_12_CBYCRY 0x0220009B\n#define PFNC_U3V_YCBCR422_12P 0x02180088\n#define PFNC_U3V_YCBCR422_12P_CBYCRY 0x0218009C\n#define PFNC_U3V_YCBCR601_8_CBYCR 0x0218003D\n#define PFNC_U3V_YCBCR601_10_CBYCR 0x02300089\n#define PFNC_U3V_YCBCR601_10P_CBYCR 0x021E008A\n#define PFNC_U3V_YCBCR601_12_CBYCR 0x0230008B\n#define PFNC_U3V_YCBCR601_12P_CBYCR 0x0224008C\n#define PFNC_U3V_YCBCR601_411_8_CBYYCRYY 0x020C003F\n#define PFNC_U3V_YCBCR601_422_8 0x0210003E\n#define PFNC_U3V_YCBCR601_422_8_CBYCRY 0x02100044\n#define PFNC_U3V_YCBCR601_422_10 0x0220008D\n#define PFNC_U3V_YCBCR601_422_10_CBYCRY 0x0220009D\n#define PFNC_U3V_YCBCR601_422_10P 0x0214008E\n#define PFNC_U3V_YCBCR601_422_10P_CBYCRY 0x0214009E\n#define PFNC_U3V_YCBCR601_422_12 0x0220008F\n#define PFNC_U3V_YCBCR601_422_12_CBYCRY 0x0220009F\n#define PFNC_U3V_YCBCR601_422_12P 0x02180090\n#define PFNC_U3V_YCBCR601_422_12P_CBYCRY 0x021800A0\n#define PFNC_U3V_YCBCR709_8_CBYCR 0x02180040\n#define PFNC_U3V_YCBCR709_10_CBYCR 0x02300091\n#define PFNC_U3V_YCBCR709_10P_CBYCR 0x021E0092\n#define PFNC_U3V_YCBCR709_12_CBYCR 0x02300093\n#define PFNC_U3V_YCBCR709_12P_CBYCR 0x02240094\n#define PFNC_U3V_YCBCR709_411_8_CBYYCRYY 0x020C0042\n#define PFNC_U3V_YCBCR709_422_8 0x02100041\n#define PFNC_U3V_YCBCR709_422_8_CBYCRY 0x02100045\n#define PFNC_U3V_YCBCR709_422_10 0x02200095\n#define PFNC_U3V_YCBCR709_422_10_CBYCRY 0x022000A1\n#define PFNC_U3V_YCBCR709_422_10P 0x02140096\n#define PFNC_U3V_YCBCR709_422_10P_CBYCRY 0x021400A2\n#define PFNC_U3V_YCBCR709_422_12 0x02200097\n#define PFNC_U3V_YCBCR709_422_12_CBYCRY 0x022000A3\n#define PFNC_U3V_YCBCR709_422_12P 0x02180098\n#define PFNC_U3V_YCBCR709_422_12P_CBYCRY 0x021800A4\n#define PFNC_U3V_YCBCR2020_8_CBYCR 0x021800F4\n#define PFNC_U3V_YCBCR2020_10_CBYCR 0x023000F5\n#define PFNC_U3V_YCBCR2020_10P_CBYCR 0x021E00F6\n#define PFNC_U3V_YCBCR2020_12_CBYCR 0x023000F7\n#define PFNC_U3V_YCBCR2020_12P_CBYCR 0x022400F8\n#define PFNC_U3V_YCBCR2020_411_8_CBYYCRYY 0x020C00F9\n#define PFNC_U3V_YCBCR2020_422_8 0x021000FA\n#define PFNC_U3V_YCBCR2020_422_8_CBYCRY 0x021000FB\n#define PFNC_U3V_YCBCR2020_422_10 0x022000FC\n#define PFNC_U3V_YCBCR2020_422_10_CBYCRY 0x022000FD\n#define PFNC_U3V_YCBCR2020_422_10P 0x021400FE\n#define PFNC_U3V_YCBCR2020_422_10P_CBYCRY 0x021400FF\n#define PFNC_U3V_YCBCR2020_422_12 0x02200100\n#define PFNC_U3V_YCBCR2020_422_12_CBYCRY 0x02200101\n#define PFNC_U3V_YCBCR2020_422_12P 0x02180102\n#define PFNC_U3V_YCBCR2020_422_12P_CBYCRY 0x02180103\n#define PFNC_U3V_YUV8_UYV 0x02180020\n#define PFNC_U3V_YUV411_8_UYYVYY 0x020C001E\n#define PFNC_U3V_YUV422_8 0x02100032\n#define PFNC_U3V_YUV422_8_UYVY 0x0210001F\n#define GVSP_MONO10PACKED 0x010C0004\n#define GVSP_MONO12PACKED 0x010C0006\n#define GVSP_BAYERBG10PACKED 0x010C0029\n#define GVSP_BAYERBG12PACKED 0x010C002D\n#define GVSP_BAYERGB10PACKED 0x010C0028\n#define GVSP_BAYERGB12PACKED 0x010C002C\n#define GVSP_BAYERGR10PACKED 0x010C0026\n#define GVSP_BAYERGR12PACKED 0x010C002A\n#define GVSP_BAYERRG10PACKED 0x010C0027\n#define GVSP_BAYERRG12PACKED 0x010C002B\n#define GVSP_RGB10V1PACKED 0x0220001C\n#define GVSP_RGB12V1PACKED 0x02240034\n\n/*\n Payload Types\n*/\n#define U3V_STREAM_PAYLOAD_IMAGE            0x0001\n#define U3V_STREAM_PAYLOAD_IMAGE_EXT_CHUNK  0x4001\n#define U3V_STREAM_PAYLOAD_CHUNK            0x4000\n\nvoid proto_register_u3v(void);\nvoid proto_reg_handoff_u3v(void);\n\n/* Define the u3v protocol */\nstatic int proto_u3v;\n\n/* GenCP transaction tracking\n * the protocol only allows strict sequential\n * communication.\n *\n * we track the current cmd/ack/pend_ack information\n * in a struct that is created per GenCP communication\n *\n * in each request/response packet we add pointers\n * to this information, that allow navigation between packets\n * and dissection of addresses\n */\ntypedef struct _gencp_transaction_t {\n    uint32_t cmd_frame;\n    uint32_t ack_frame;\n    nstime_t cmd_time;\n    /* list of pending acknowledges */\n    wmem_array_t *pend_ack_frame_list;\n    /* current requested address */\n    uint64_t address;\n    /* current requested count read/write */\n    uint32_t count;\n} gencp_transaction_t;\n\ntypedef struct _u3v_conv_info_t {\n    uint64_t abrm_addr;\n    uint64_t sbrm_addr;\n    uint64_t sirm_addr;\n    uint64_t eirm_addr;\n    uint64_t iidc2_addr;\n    uint64_t manifest_addr;\n    uint32_t ep_stream;\n    gencp_transaction_t *trans_info;\n} u3v_conv_info_t;\n\n/*\n \\brief IDs used for bootstrap dissection\n*/\nstatic int hf_u3v_gencp_prefix;\nstatic int hf_u3v_flag;\nstatic int hf_u3v_acknowledge_required_flag;\nstatic int hf_u3v_command_id;\nstatic int hf_u3v_length;\nstatic int hf_u3v_request_id;\nstatic int hf_u3v_status;\nstatic int hf_u3v_address;\nstatic int hf_u3v_count;\nstatic int hf_u3v_eventcmd_id;\nstatic int hf_u3v_eventcmd_error_id;\nstatic int hf_u3v_eventcmd_device_specific_id;\nstatic int hf_u3v_eventcmd_timestamp;\nstatic int hf_u3v_eventcmd_data;\nstatic int hf_u3v_time_to_completion;\nstatic int hf_u3v_payloaddata;\nstatic int hf_u3v_reserved;\n\nstatic int hf_u3v_bootstrap_GenCP_Version;\nstatic int hf_u3v_bootstrap_Manufacturer_Name;\nstatic int hf_u3v_bootstrap_Model_Name;\nstatic int hf_u3v_bootstrap_Family_Name;\nstatic int hf_u3v_bootstrap_Device_Version;\nstatic int hf_u3v_bootstrap_Manufacturer_Info;\nstatic int hf_u3v_bootstrap_Serial_Number;\nstatic int hf_u3v_bootstrap_User_Defined_Name;\nstatic int hf_u3v_bootstrap_Device_Capability;\nstatic int hf_u3v_bootstrap_Maximum_Device_Response_Time;\nstatic int hf_u3v_bootstrap_Manifest_Table_Address;\nstatic int hf_u3v_bootstrap_SBRM_Address;\nstatic int hf_u3v_bootstrap_Device_Configuration;\nstatic int hf_u3v_bootstrap_Heartbeat_Timeout;\nstatic int hf_u3v_bootstrap_Message_Channel_channel_id;\nstatic int hf_u3v_bootstrap_Timestamp;\nstatic int hf_u3v_bootstrap_Timestamp_Latch;\nstatic int hf_u3v_bootstrap_Timestamp_Increment;\nstatic int hf_u3v_bootstrap_Access_Privilege;\nstatic int hf_u3v_bootstrap_Protocol_Endianness;\nstatic int hf_u3v_bootstrap_Implementation_Endianness;\nstatic int hf_u3v_bootstrap_U3V_Version;\nstatic int hf_u3v_bootstrap_U3VCP_Capability_Register;\nstatic int hf_u3v_bootstrap_U3VCP_Configuration_Register;\nstatic int hf_u3v_bootstrap_Maximum_Command_Transfer_Length;\nstatic int hf_u3v_bootstrap_Maximum_Acknowledge_Transfer_Length;\nstatic int hf_u3v_bootstrap_Number_of_Stream_Channels;\nstatic int hf_u3v_bootstrap_SIRM_Address;\nstatic int hf_u3v_bootstrap_SIRM_Length;\nstatic int hf_u3v_bootstrap_EIRM_Address;\nstatic int hf_u3v_bootstrap_EIRM_Length;\nstatic int hf_u3v_bootstrap_IIDC2_Address;\nstatic int hf_u3v_bootstrap_Current_Speed;\nstatic int hf_u3v_bootstrap_SI_Info;\nstatic int hf_u3v_bootstrap_SI_Control;\nstatic int hf_u3v_bootstrap_SI_Required_Payload_Size;\nstatic int hf_u3v_bootstrap_SI_Required_Leader_Size;\nstatic int hf_u3v_bootstrap_SI_Required_Trailer_Size;\nstatic int hf_u3v_bootstrap_SI_Maximum_Leader_Size;\nstatic int hf_u3v_bootstrap_SI_Payload_Transfer_Size;\nstatic int hf_u3v_bootstrap_SI_Payload_Transfer_Count;\nstatic int hf_u3v_bootstrap_SI_Payload_Final_Transfer1_Size;\nstatic int hf_u3v_bootstrap_SI_Payload_Final_Transfer2_Size;\nstatic int hf_u3v_bootstrap_SI_Maximum_Trailer_Size;\nstatic int hf_u3v_bootstrap_EI_Control;\nstatic int hf_u3v_bootstrap_Maximum_Event_Transfer_Length;\nstatic int hf_u3v_bootstrap_Event_Test_Control;\nstatic int hf_u3v_custom_memory_addr;\nstatic int hf_u3v_custom_memory_data;\n\nstatic int hf_u3v_scd_readmem_cmd;\nstatic int hf_u3v_scd_writemem_cmd;\nstatic int hf_u3v_scd_event_cmd;\nstatic int hf_u3v_scd_ack_readmem_ack;\nstatic int hf_u3v_scd_writemem_ack;\nstatic int hf_u3v_ccd_pending_ack;\nstatic int hf_u3v_stream_leader;\nstatic int hf_u3v_stream_trailer;\nstatic int hf_u3v_stream_payload;\nstatic int hf_u3v_ccd_cmd;\nstatic int hf_u3v_ccd_ack;\nstatic int hf_u3v_device_info_descriptor;\n\n/* stream elements */\nstatic int hf_u3v_stream_reserved;\nstatic int hf_u3v_stream_leader_size;\n\nstatic int hf_u3v_stream_prefix;\nstatic int hf_u3v_stream_trailer_size;\n\nstatic int hf_u3v_stream_block_id;\nstatic int hf_u3v_stream_payload_type;\nstatic int hf_u3v_stream_status;\nstatic int hf_u3v_stream_valid_payload_size;\n\nstatic int hf_u3v_stream_timestamp;\nstatic int hf_u3v_stream_pixel_format;\nstatic int hf_u3v_stream_size_x;\nstatic int hf_u3v_stream_size_y;\nstatic int hf_u3v_stream_offset_x;\nstatic int hf_u3v_stream_offset_y;\nstatic int hf_u3v_stream_padding_x;\nstatic int hf_u3v_stream_chunk_layout_id;\n\nstatic int hf_u3v_stream_data;\n\n/* U3V device info descriptor */\nstatic int hf_u3v_device_info_descriptor_bLength;\nstatic int hf_u3v_device_info_descriptor_bDescriptorType;\nstatic int hf_u3v_device_info_descriptor_bDescriptorSubtype;\nstatic int hf_u3v_device_info_descriptor_bGenCPVersion;\nstatic int hf_u3v_device_info_descriptor_bGenCPVersion_minor;\nstatic int hf_u3v_device_info_descriptor_bGenCPVersion_major;\nstatic int hf_u3v_device_info_descriptor_bU3VVersion;\nstatic int hf_u3v_device_info_descriptor_bU3VVersion_minor;\nstatic int hf_u3v_device_info_descriptor_bU3VVersion_major;\nstatic int hf_u3v_device_info_descriptor_iDeviceGUID;\nstatic int hf_u3v_device_info_descriptor_iVendorName;\nstatic int hf_u3v_device_info_descriptor_iModelName;\nstatic int hf_u3v_device_info_descriptor_iFamilyName;\nstatic int hf_u3v_device_info_descriptor_iDeviceVersion;\nstatic int hf_u3v_device_info_descriptor_iManufacturerInfo;\nstatic int hf_u3v_device_info_descriptor_iSerialNumber;\nstatic int hf_u3v_device_info_descriptor_iUserDefinedName;\nstatic int hf_u3v_device_info_descriptor_bmSpeedSupport;\nstatic int hf_u3v_device_info_descriptor_bmSpeedSupport_low_speed;\nstatic int hf_u3v_device_info_descriptor_bmSpeedSupport_full_speed;\nstatic int hf_u3v_device_info_descriptor_bmSpeedSupport_high_speed;\nstatic int hf_u3v_device_info_descriptor_bmSpeedSupport_super_speed;\nstatic int hf_u3v_device_info_descriptor_bmSpeedSupport_reserved;\n\n/*Define the tree for u3v*/\nstatic int ett_u3v;\nstatic int ett_u3v_cmd;\nstatic int ett_u3v_flags;\nstatic int ett_u3v_ack;\nstatic int ett_u3v_payload_cmd;\nstatic int ett_u3v_payload_ack;\nstatic int ett_u3v_payload_cmd_subtree;\nstatic int ett_u3v_payload_ack_subtree;\nstatic int ett_u3v_bootstrap_fields;\nstatic int ett_u3v_stream_leader;\nstatic int ett_u3v_stream_trailer;\nstatic int ett_u3v_stream_payload;\n\nstatic int ett_u3v_device_info_descriptor;\nstatic int ett_u3v_device_info_descriptor_speed_support;\nstatic int ett_u3v_device_info_descriptor_gencp_version;\nstatic int ett_u3v_device_info_descriptor_u3v_version;\n\nstatic dissector_handle_t u3v_handle;\n\nstatic const value_string command_names[] =\n{\n    { U3V_READMEM_CMD, \"READMEM_CMD\" },\n    { U3V_WRITEMEM_CMD, \"WRITEMEM_CMD\" },\n    { U3V_EVENT_CMD, \"EVENT_CMD\" },\n    { U3V_READMEM_ACK, \"READMEM_ACK\" },\n    { U3V_WRITEMEM_ACK, \"WRITEMEM_ACK\" },\n    { U3V_PENDING_ACK, \"PENDING_ACK\" },\n    { U3V_EVENT_ACK, \"EVENT_ACK\" },\n    { 0, NULL }\n};\n\nstatic const value_string event_id_names[] =\n{\n    { U3V_EVENT_TESTEVENT, \"U3V_EVENT_TESTEVENT\" },\n    { 0, NULL }\n};\n\nstatic const value_string status_names[] =\n{\n    { U3V_STATUS_GENCP_SUCCESS, \"U3V_STATUS_GENCP_SUCCESS\" },\n    { U3V_STATUS_GENCP_NOT_IMPLEMENTED, \"U3V_STATUS_GENCP_NOT_IMPLEMENTED\" },\n    { U3V_STATUS_GENCP_INVALID_PARAMETER, \"U3V_STATUS_GENCP_INVALID_PARAMETER\" },\n    { U3V_STATUS_GENCP_INVALID_ADDRESS, \"U3V_STATUS_GENCP_INVALID_ADDRESS\" },\n    { U3V_STATUS_GENCP_WRITE_PROTECT, \"U3V_STATUS_GENCP_WRITE_PROTECT\" },\n    { U3V_STATUS_GENCP_BAD_ALIGNMENT, \"U3V_STATUS_GENCP_BAD_ALIGNMENT\" },\n    { U3V_STATUS_GENCP_ACCESS_DENIED, \"U3V_STATUS_GENCP_ACCESS_DENIED\" },\n    { U3V_STATUS_GENCP_BUSY, \"U3V_STATUS_GENCP_BUSY\" },\n    { U3V_STATUS_GENCP_WRONG_CONFIG, \"U3V_STATUS_GENCP_WRONG_CONFIG\" },\n    { U3V_STATUS_RESEND_NOT_SUPPORTED, \"U3V_STATUS_RESEND_NOT_SUPPORTED\" },\n    { U3V_STATUS_DSI_ENDPOINT_HALTED, \"U3V_STATUS_DSI_ENDPOINT_HALTED\" },\n    { U3V_STATUS_SI_PAYLOAD_SIZE_NOT_ALIGNED, \"U3V_STATUS_SI_PAYLOAD_SIZE_NOT_ALIGNED\" },\n    { U3V_STATUS_SI_REGISTERS_INCONSISTENT, \"U3V_STATUS_SI_REGISTERS_INCONSISTENT\" },\n    { U3V_STATUS_DATA_DISCARDED, \"U3V_STATUS_DATA_DISCARDED\" },\n    { U3V_STATUS_DATA_OVERRUN, \"U3V_STATUS_DATA_OVERRUN\" },\n    { 0, NULL }\n};\n\nstatic const value_string status_names_short[] =\n{\n    { U3V_STATUS_GENCP_SUCCESS, \"\" },\n    { U3V_STATUS_GENCP_NOT_IMPLEMENTED, \"U3V_STATUS_GENCP_NOT_IMPLEMENTED\" },\n    { U3V_STATUS_GENCP_INVALID_PARAMETER, \"U3V_STATUS_GENCP_INVALID_PARAMETER\" },\n    { U3V_STATUS_GENCP_INVALID_ADDRESS, \"U3V_STATUS_GENCP_INVALID_ADDRESS\" },\n    { U3V_STATUS_GENCP_WRITE_PROTECT, \"U3V_STATUS_GENCP_WRITE_PROTECT\" },\n    { U3V_STATUS_GENCP_BAD_ALIGNMENT, \"U3V_STATUS_GENCP_BAD_ALIGNMENT\" },\n    { U3V_STATUS_GENCP_ACCESS_DENIED, \"U3V_STATUS_GENCP_ACCESS_DENIED\" },\n    { U3V_STATUS_GENCP_BUSY, \"U3V_STATUS_GENCP_BUSY\" },\n    { U3V_STATUS_GENCP_WRONG_CONFIG, \"U3V_STATUS_GENCP_WRONG_CONFIG\" },\n    { U3V_STATUS_RESEND_NOT_SUPPORTED, \"U3V_STATUS_RESEND_NOT_SUPPORTED\" },\n    { U3V_STATUS_DSI_ENDPOINT_HALTED, \"U3V_STATUS_DSI_ENDPOINT_HALTED\" },\n    { U3V_STATUS_SI_PAYLOAD_SIZE_NOT_ALIGNED, \"U3V_STATUS_SI_PAYLOAD_SIZE_NOT_ALIGNED\" },\n    { U3V_STATUS_SI_REGISTERS_INCONSISTENT, \"U3V_STATUS_SI_REGISTERS_INCONSISTENT\" },\n    { U3V_STATUS_DATA_DISCARDED, \"U3V_STATUS_DATA_DISCARDED\" },\n    { U3V_STATUS_DATA_OVERRUN, \"U3V_STATUS_DATA_OVERRUN\" },\n    { 0, NULL }\n};\n\n/*\n \\brief Register name to address mappings\n */\nstatic const value_string bootstrap_register_names_abrm[] =\n{\n    { U3V_ABRM_GENCP_VERSION, \"[GenCP_Version]\" },\n    { U3V_ABRM_MANUFACTURER_NAME, \"[Manufacturer_Name]\" },\n    { U3V_ABRM_MODEL_NAME, \"[Model_Name]\" },\n    { U3V_ABRM_FAMILY_NAME, \"[Family_Name]\" },\n    { U3V_ABRM_DEVICE_VERSION, \"[Device_Version]\" },\n    { U3V_ABRM_MANUFACTURER_INFO, \"[Manufacturer_Info]\" },\n    { U3V_ABRM_SERIAL_NUMBER, \"[Serial_Number]\" },\n    { U3V_ABRM_USER_DEFINED_NAME, \"[User_Defined_Name]\" },\n    { U3V_ABRM_DEVICE_CAPABILITY, \"[Device_Capability]\" },\n    { U3V_ABRM_MAXIMUM_DEVICE_RESPONSE_TIME, \"[Maximum_Device_Response_Time]\" },\n    { U3V_ABRM_MANIFEST_TABLE_ADDRESS, \"[Manifest_Table_Address]\" },\n    { U3V_ABRM_SBRM_ADDRESS, \"[SBRM_Address]\" },\n    { U3V_ABRM_DEVICE_CONFIGURATION, \"[Device_Configuration]\" },\n    { U3V_ABRM_HEARTBEAT_TIMEOUT, \"[Heartbeat_Timeout]\" },\n    { U3V_ABRM_MESSAGE_CHANNEL_CHANNEL_ID, \"[Message_Channel_channel_id]\" },\n    { U3V_ABRM_TIMESTAMP, \"[Timestamp]\" },\n    { U3V_ABRM_TIMESTAMP_LATCH, \"[Timestamp_Latch]\" },\n    { U3V_ABRM_TIMESTAMP_INCREMENT, \"[Timestamp_Increment]\" },\n    { U3V_ABRM_ACCESS_PRIVILEGE, \"[Access_Privilege]\" },\n    { U3V_ABRM_PROTOCOL_ENDIANNESS, \"[Protocol_Endianness]\" },\n    { U3V_ABRM_IMPLEMENTATION_ENDIANNESS, \"[Implementation_Endianness]\" },\n    { 0, NULL }\n};\n\nstatic const value_string bootstrap_register_names_sbrm[] =\n{\n    { U3V_SBRM_U3V_VERSION, \"[U3V_Version]\" },\n    { U3V_SBRM_U3VCP_CAPABILITY_REGISTER, \"[U3VCP_Capability_Register]\" },\n    { U3V_SBRM_U3VCP_CONFIGURATION_REGISTER, \"[U3VCP_Configuration_Register]\" },\n    { U3V_SBRM_MAXIMUM_COMMAND_TRANSFER_LENGTH, \"[Maximum_Command_Transfer_Length]\" },\n    { U3V_SBRM_MAXIMUM_ACKNOWLEDGE_TRANSFER_LENGTH, \"[Maximum_Acknowledge_Transfer_Length]\" },\n    { U3V_SBRM_NUMBER_OF_STREAM_CHANNELS, \"[Number_of_Stream_Channels]\" },\n    { U3V_SBRM_SIRM_ADDRESS, \"[SIRM_Address]\" },\n    { U3V_SBRM_SIRM_LENGTH, \"[SIRM_Length]\" },\n    { U3V_SBRM_EIRM_ADDRESS, \"[EIRM_Address]\" },\n    { U3V_SBRM_EIRM_LENGTH, \"[EIRM_Length]\" },\n    { U3V_SBRM_IIDC2_ADDRESS, \"[IIDC2_Address]\" },\n    { U3V_SBRM_CURRENT_SPEED, \"[Current_Speed]\" },\n    { 0, NULL }\n};\n\nstatic const value_string bootstrap_register_names_sirm[] =\n{\n    { U3V_SIRM_SI_INFO, \"[SI_Info]\" },\n    { U3V_SIRM_SI_CONTROL, \"[SI_Control]\" },\n    { U3V_SIRM_SI_REQUIRED_PAYLOAD_SIZE, \"[SI_Required_Payload_Size]\" },\n    { U3V_SIRM_SI_REQUIRED_LEADER_SIZE, \"[SI_Required_Leader_Size]\" },\n    { U3V_SIRM_SI_REQUIRED_TRAILER_SIZE, \"[SI_Required_Trailer_Size]\" },\n    { U3V_SIRM_SI_MAXIMUM_LEADER_SIZE, \"[SI_Maximum_Leader_Size]\" },\n    { U3V_SIRM_SI_PAYLOAD_TRANSFER_SIZE, \"[SI_Payload_Transfer_Size]\" },\n    { U3V_SIRM_SI_PAYLOAD_TRANSFER_COUNT, \"[SI_Payload_Transfer_Count]\" },\n    { U3V_SIRM_SI_PAYLOAD_FINAL_TRANSFER1_SIZE, \"[SI_Payload_Final_Transfer1_Size]\" },\n    { U3V_SIRM_SI_PAYLOAD_FINAL_TRANSFER2_SIZE, \"[SI_Payload_Final_Transfer2_Size]\" },\n    { U3V_SIRM_SI_MAXIMUM_TRAILER_SIZE, \"[SI_Maximum_Trailer_Size]\" },\n    { 0, NULL }\n};\n\nstatic const value_string bootstrap_register_names_eirm[] =\n{\n    { U3V_EIRM_EI_CONTROL, \"[EI_Control]\" },\n    { U3V_EIRM_MAXIMUM_EVENT_TRANSFER_LENGTH, \"[Maximum_Event_Transfer_Length]\" },\n    { U3V_EIRM_EVENT_TEST_CONTROL, \"[Event_Test_Control]\" },\n    { 0, NULL }\n};\n\nstatic const value_string pixel_format_names[] =\n{\n    { PFNC_U3V_MONO1P, \"Mono1p (Monochrome 1-bit packed)\" },\n    { PFNC_U3V_CONFIDENCE1P, \"Confidence1p (Confidence 1-bit packed)\" },\n    { PFNC_U3V_MONO2P, \"Mono2p (Monochrome 2-bit packed)\" },\n    { PFNC_U3V_MONO4P, \"Mono4p (Monochrome 4-bit packed)\" },\n    { PFNC_U3V_BAYERGR4P, \"BayerGR4p (Bayer Green-Red 4-bit packed)\" },\n    { PFNC_U3V_BAYERRG4P, \"BayerRG4p (Bayer Red-Green 4-bit packed)\" },\n    { PFNC_U3V_BAYERGB4P, \"BayerGB4p (Bayer Green-Blue 4-bit packed)\" },\n    { PFNC_U3V_BAYERBG4P, \"BayerBG4p (Bayer Blue-Green 4-bit packed)\" },\n    { PFNC_U3V_MONO8, \"Mono8 (Monochrome 8-bit)\" },\n    { PFNC_U3V_MONO8S, \"Mono8s (Monochrome 8-bit signed)\" },\n    { PFNC_U3V_BAYERGR8, \"BayerGR8 (Bayer Green-Red 8-bit)\" },\n    { PFNC_U3V_BAYERRG8, \"BayerRG8 (Bayer Red-Green 8-bit)\" },\n    { PFNC_U3V_BAYERGB8, \"BayerGB8 (Bayer Green-Blue 8-bit)\" },\n    { PFNC_U3V_BAYERBG8, \"BayerBG8 (Bayer Blue-Green 8-bit)\" },\n    { PFNC_U3V_SCF1WBWG8, \"SCF1WBWG8 (Sparse Color Filter #1 White-Blue-White-Green 8-bit)\" },\n    { PFNC_U3V_SCF1WGWB8, \"SCF1WGWB8 (Sparse Color Filter #1 White-Green-White-Blue 8-bit)\" },\n    { PFNC_U3V_SCF1WGWR8, \"SCF1WGWR8 (Sparse Color Filter #1 White-Green-White-Red 8-bit)\" },\n    { PFNC_U3V_SCF1WRWG8, \"SCF1WRWG8 (Sparse Color Filter #1 White-Red-White-Green 8-bit)\" },\n    { PFNC_U3V_COORD3D_A8, \"Coord3D_A8 (3D coordinate A 8-bit)\" },\n    { PFNC_U3V_COORD3D_B8, \"Coord3D_B8 (3D coordinate B 8-bit)\" },\n    { PFNC_U3V_COORD3D_C8, \"Coord3D_C8 (3D coordinate C 8-bit)\" },\n    { PFNC_U3V_CONFIDENCE1, \"Confidence1 (Confidence 1-bit unpacked)\" },\n    { PFNC_U3V_CONFIDENCE8, \"Confidence8 (Confidence 8-bit)\" },\n    { PFNC_U3V_R8, \"R8 (Red 8-bit)\" },\n    { PFNC_U3V_G8, \"G8 (Green 8-bit)\" },\n    { PFNC_U3V_B8, \"B8 (Blue 8-bit)\" },\n    { PFNC_U3V_DATA8, \"Data8 (Data 8-bit)\" },\n    { PFNC_U3V_DATA8S, \"Data8s (Data 8-bit signed)\" },\n    { PFNC_U3V_MONO10P, \"Mono10p (Monochrome 10-bit packed)\" },\n    { PFNC_U3V_BAYERBG10P, \"BayerBG10p (Bayer Blue-Green 10-bit packed)\" },\n    { PFNC_U3V_BAYERGB10P, \"BayerGB10p (Bayer Green-Blue 10-bit packed)\" },\n    { PFNC_U3V_BAYERGR10P, \"BayerGR10p (Bayer Green-Red 10-bit packed)\" },\n    { PFNC_U3V_BAYERRG10P, \"BayerRG10p (Bayer Red-Green 10-bit packed)\" },\n    { PFNC_U3V_SCF1WBWG10P, \"SCF1WBWG10p (Sparse Color Filter #1 White-Blue-White-Green 10-bit packed)\" },\n    { PFNC_U3V_SCF1WGWB10P, \"SCF1WGWB10p (Sparse Color Filter #1 White-Green-White-Blue 10-bit packed)\" },\n    { PFNC_U3V_SCF1WGWR10P, \"SCF1WGWR10p (Sparse Color Filter #1 White-Green-White-Red 10-bit packed)\" },\n    { PFNC_U3V_SCF1WRWG10P, \"SCF1WRWG10p (Sparse Color Filter #1 White-Red-White-Green 10-bit packed)\" },\n    { PFNC_U3V_R10_DEPRECATED, \"R10_Deprecated (Deprecated because size field is wrong)\" },\n    { PFNC_U3V_G10_DEPRECATED, \"G10_Deprecated (Deprecated because size field is wrong)\" },\n    { PFNC_U3V_B10_DEPRECATED, \"B10_Deprecated (Deprecated because size field is wrong)\" },\n    { PFNC_U3V_COORD3D_A10P, \"Coord3D_A10p (3D coordinate A 10-bit packed)\" },\n    { PFNC_U3V_COORD3D_B10P, \"Coord3D_B10p (3D coordinate B 10-bit packed)\" },\n    { PFNC_U3V_COORD3D_C10P, \"Coord3D_C10p (3D coordinate C 10-bit packed)\" },\n    { GVSP_MONO10PACKED, \"GVSP_Mono10Packed (GigE Vision specific format, Monochrome 10-bit packed)\" },\n    { GVSP_MONO12PACKED, \"GVSP_Mono12Packed (GigE Vision specific format, Monochrome 12-bit packed)\" },\n    { GVSP_BAYERGR10PACKED, \"GVSP_BayerGR10Packed (GigE Vision specific format, Bayer Green-Red 10-bit packed)\" },\n    { GVSP_BAYERRG10PACKED, \"GVSP_BayerRG10Packed (GigE Vision specific format, Bayer Red-Green 10-bit packed)\" },\n    { GVSP_BAYERGB10PACKED, \"GVSP_BayerGB10Packed (GigE Vision specific format, Bayer Green-Blue 10-bit packed)\" },\n    { GVSP_BAYERBG10PACKED, \"GVSP_BayerBG10Packed (GigE Vision specific format, Bayer Blue-Green 10-bit packed)\" },\n    { GVSP_BAYERGR12PACKED, \"GVSP_BayerGR12Packed (GigE Vision specific format, Bayer Green-Red 12-bit packed)\" },\n    { GVSP_BAYERRG12PACKED, \"GVSP_BayerRG12Packed (GigE Vision specific format, Bayer Red-Green 12-bit packed)\" },\n    { GVSP_BAYERGB12PACKED, \"GVSP_BayerGB12Packed (GigE Vision specific format, Bayer Green-Blue 12-bit packed)\" },\n    { GVSP_BAYERBG12PACKED, \"GVSP_BayerBG12Packed (GigE Vision specific format, Bayer Blue-Green 12-bit packed)\" },\n    { PFNC_U3V_MONO12P, \"Mono12p (Monochrome 12-bit packed)\" },\n    { PFNC_U3V_BAYERBG12P, \"BayerBG12p (Bayer Blue-Green 12-bit packed)\" },\n    { PFNC_U3V_BAYERGB12P, \"BayerGB12p (Bayer Green-Blue 12-bit packed)\" },\n    { PFNC_U3V_BAYERGR12P, \"BayerGR12p (Bayer Green-Red 12-bit packed)\" },\n    { PFNC_U3V_BAYERRG12P, \"BayerRG12p (Bayer Red-Green 12-bit packed)\" },\n    { PFNC_U3V_SCF1WBWG12P, \"SCF1WBWG12p (Sparse Color Filter #1 White-Blue-White-Green 12-bit packed)\" },\n    { PFNC_U3V_SCF1WGWB12P, \"SCF1WGWB12p (Sparse Color Filter #1 White-Green-White-Blue 12-bit packed)\" },\n    { PFNC_U3V_SCF1WGWR12P, \"SCF1WGWR12p (Sparse Color Filter #1 White-Green-White-Red 12-bit packed)\" },\n    { PFNC_U3V_SCF1WRWG12P, \"SCF1WRWG12p (Sparse Color Filter #1 White-Red-White-Green 12-bit packed)\" },\n    { PFNC_U3V_R12_DEPRECATED, \"R12_Deprecated (Deprecated because size field is wrong)\" },\n    { PFNC_U3V_G12_DEPRECATED, \"G12_Deprecated (Deprecated because size field is wrong)\" },\n    { PFNC_U3V_B12_DEPRECATED, \"B12_Deprecated (Deprecated because size field is wrong)\" },\n    { PFNC_U3V_COORD3D_A12P, \"Coord3D_A12p (3D coordinate A 12-bit packed)\" },\n    { PFNC_U3V_COORD3D_B12P, \"Coord3D_B12p (3D coordinate B 12-bit packed)\" },\n    { PFNC_U3V_COORD3D_C12P, \"Coord3D_C12p (3D coordinate C 12-bit packed)\" },\n    { PFNC_U3V_MONO14P, \"Mono14p (Monochrome 14-bit packed)\" },\n    { PFNC_U3V_BAYERGR14P, \"BayerGR14p (Bayer Green-Red 14-bit packed)\" },\n    { PFNC_U3V_BAYERRG14P, \"BayerRG14p (Bayer Red-Green 14-bit packed)\" },\n    { PFNC_U3V_BAYERGB14P, \"BayerGB14p (Bayer Green-Blue 14-bit packed)\" },\n    { PFNC_U3V_BAYERBG14P, \"BayerBG14p (Bayer Blue-Green 14-bit packed)\" },\n    { PFNC_U3V_MONO10, \"Mono10 (Monochrome 10-bit unpacked)\" },\n    { PFNC_U3V_MONO12, \"Mono12 (Monochrome 12-bit unpacked)\" },\n    { PFNC_U3V_MONO16, \"Mono16 (Monochrome 16-bit)\" },\n    { PFNC_U3V_BAYERGR10, \"BayerGR10 (Bayer Green-Red 10-bit unpacked)\" },\n    { PFNC_U3V_BAYERRG10, \"BayerRG10 (Bayer Red-Green 10-bit unpacked)\" },\n    { PFNC_U3V_BAYERGB10, \"BayerGB10 (Bayer Green-Blue 10-bit unpacked)\" },\n    { PFNC_U3V_BAYERBG10, \"BayerBG10 (Bayer Blue-Green 10-bit unpacked)\" },\n    { PFNC_U3V_BAYERGR12, \"BayerGR12 (Bayer Green-Red 12-bit unpacked)\" },\n    { PFNC_U3V_BAYERRG12, \"BayerRG12 (Bayer Red-Green 12-bit unpacked)\" },\n    { PFNC_U3V_BAYERGB12, \"BayerGB12 (Bayer Green-Blue 12-bit unpacked)\" },\n    { PFNC_U3V_BAYERBG12, \"BayerBG12 (Bayer Blue-Green 12-bit unpacked)\" },\n    { PFNC_U3V_MONO14, \"Mono14 (Monochrome 14-bit unpacked)\" },\n    { PFNC_U3V_BAYERGR16, \"BayerGR16 (Bayer Green-Red 16-bit)\" },\n    { PFNC_U3V_BAYERRG16, \"BayerRG16 (Bayer Red-Green 16-bit)\" },\n    { PFNC_U3V_BAYERGB16, \"BayerGB16 (Bayer Green-Blue 16-bit)\" },\n    { PFNC_U3V_BAYERBG16, \"BayerBG16 (Bayer Blue-Green 16-bit)\" },\n    { PFNC_U3V_SCF1WBWG10, \"SCF1WBWG10 (Sparse Color Filter #1 White-Blue-White-Green 10-bit unpacked)\" },\n    { PFNC_U3V_SCF1WBWG12, \"SCF1WBWG12 (Sparse Color Filter #1 White-Blue-White-Green 12-bit unpacked)\" },\n    { PFNC_U3V_SCF1WBWG14, \"SCF1WBWG14 (Sparse Color Filter #1 White-Blue-White-Green 14-bit unpacked)\" },\n    { PFNC_U3V_SCF1WBWG16, \"SCF1WBWG16 (Sparse Color Filter #1 White-Blue-White-Green 16-bit unpacked)\" },\n    { PFNC_U3V_SCF1WGWB10, \"SCF1WGWB10 (Sparse Color Filter #1 White-Green-White-Blue 10-bit unpacked)\" },\n    { PFNC_U3V_SCF1WGWB12, \"SCF1WGWB12 (Sparse Color Filter #1 White-Green-White-Blue 12-bit unpacked)\" },\n    { PFNC_U3V_SCF1WGWB14, \"SCF1WGWB14 (Sparse Color Filter #1 White-Green-White-Blue 14-bit unpacked)\" },\n    { PFNC_U3V_SCF1WGWB16, \"SCF1WGWB16 (Sparse Color Filter #1 White-Green-White-Blue 16-bit)\" },\n    { PFNC_U3V_SCF1WGWR10, \"SCF1WGWR10 (Sparse Color Filter #1 White-Green-White-Red 10-bit unpacked)\" },\n    { PFNC_U3V_SCF1WGWR12, \"SCF1WGWR12 (Sparse Color Filter #1 White-Green-White-Red 12-bit unpacked)\" },\n    { PFNC_U3V_SCF1WGWR14, \"SCF1WGWR14 (Sparse Color Filter #1 White-Green-White-Red 14-bit unpacked)\" },\n    { PFNC_U3V_SCF1WGWR16, \"SCF1WGWR16 (Sparse Color Filter #1 White-Green-White-Red 16-bit)\" },\n    { PFNC_U3V_SCF1WRWG10, \"SCF1WRWG10 (Sparse Color Filter #1 White-Red-White-Green 10-bit unpacked)\" },\n    { PFNC_U3V_SCF1WRWG12, \"SCF1WRWG12 (Sparse Color Filter #1 White-Red-White-Green 12-bit unpacked)\" },\n    { PFNC_U3V_SCF1WRWG14, \"SCF1WRWG14 (Sparse Color Filter #1 White-Red-White-Green 14-bit unpacked)\" },\n    { PFNC_U3V_SCF1WRWG16, \"SCF1WRWG16 (Sparse Color Filter #1 White-Red-White-Green 16-bit)\" },\n    { PFNC_U3V_COORD3D_A16, \"Coord3D_A16 (3D coordinate A 16-bit)\" },\n    { PFNC_U3V_COORD3D_B16, \"Coord3D_B16 (3D coordinate B 16-bit)\" },\n    { PFNC_U3V_COORD3D_C16, \"Coord3D_C16 (3D coordinate C 16-bit)\" },\n    { PFNC_U3V_CONFIDENCE16, \"Confidence16 (Confidence 16-bit)\" },\n    { PFNC_U3V_R16, \"R16 (Red 16-bit)\" },\n    { PFNC_U3V_G16, \"G16 (Green 16-bit)\" },\n    { PFNC_U3V_B16, \"B16 (Blue 16-bit)\" },\n    { PFNC_U3V_BAYERGR14, \"BayerGR14 (Bayer Green-Red 14-bit)\" },\n    { PFNC_U3V_BAYERRG14, \"BayerRG14 (Bayer Red-Green 14-bit)\" },\n    { PFNC_U3V_BAYERGB14, \"BayerGB14 (Bayer Green-Blue 14-bit)\" },\n    { PFNC_U3V_BAYERBG14, \"BayerBG14 (Bayer Blue-Green 14-bit)\" },\n    { PFNC_U3V_DATA16, \"Data16 (Data 16-bit)\" },\n    { PFNC_U3V_DATA16S, \"Data16s (Data 16-bit signed)\" },\n    { PFNC_U3V_R10, \"R10 (Red 10-bit)\" },\n    { PFNC_U3V_R12, \"R12 (Red 12-bit)\" },\n    { PFNC_U3V_G10, \"G10 (Green 10-bit)\" },\n    { PFNC_U3V_G12, \"G12 (Green 12-bit)\" },\n    { PFNC_U3V_B10, \"B10 (Blue 10-bit)\" },\n    { PFNC_U3V_B12, \"B12 (Blue 12-bit)\" },\n    { PFNC_U3V_COORD3D_A32F, \"Coord3D_A32f (3D coordinate A 32-bit floating point)\" },\n    { PFNC_U3V_COORD3D_B32F, \"Coord3D_B32f (3D coordinate B 32-bit floating point)\" },\n    { PFNC_U3V_COORD3D_C32F, \"Coord3D_C32f (3D coordinate C 32-bit floating point)\" },\n    { PFNC_U3V_CONFIDENCE32F, \"Confidence32f (Confidence 32-bit floating point)\" },\n    { PFNC_U3V_MONO32, \"Mono32 (Monochrome 32-bit)\" },\n    { PFNC_U3V_DATA32, \"Data32 (Data 32-bit)\" },\n    { PFNC_U3V_DATA32S, \"Data32s (Data 32-bit signed)\" },\n    { PFNC_U3V_DATA32F, \"Data32f (Data 32-bit floating point)\" },\n    { PFNC_U3V_DATA64, \"Data64 (Data 64-bit)\" },\n    { PFNC_U3V_DATA64S, \"Data64s (Data 64-bit signed)\" },\n    { PFNC_U3V_DATA64F, \"Data64f (Data 64-bit floating point)\" },\n    { PFNC_U3V_YUV411_8_UYYVYY, \"YUV411_8_UYYVYY (YUV 4:1:1 8-bit)\" },\n    { PFNC_U3V_YCBCR411_8_CBYYCRYY, \"YCbCr411_8_CbYYCrYY (YCbCr 4:1:1 8-bit)\" },\n    { PFNC_U3V_YCBCR601_411_8_CBYYCRYY, \"YCbCr601_411_8_CbYYCrYY (YCbCr 4:1:1 8-bit BT.601)\" },\n    { PFNC_U3V_YCBCR709_411_8_CBYYCRYY, \"YCbCr709_411_8_CbYYCrYY (YCbCr 4:1:1 8-bit BT.709)\" },\n    { PFNC_U3V_YCBCR411_8, \"YCbCr411_8 (YCbCr 4:1:1 8-bit)\" },\n    { PFNC_U3V_YCBCR2020_411_8_CBYYCRYY, \"YCbCr2020_411_8_CbYYCrYY (YCbCr 4:1:1 8-bit BT.2020)\" },\n    { PFNC_U3V_YCBCR420_8_YY_CBCR_SEMIPLANAR, \"YCbCr420_8_YY_CbCr_Semiplanar (YCbCr 4:2:0 8-bit YY/CbCr Semiplanar)\" },\n    { PFNC_U3V_YCBCR420_8_YY_CRCB_SEMIPLANAR, \"YCbCr420_8_YY_CrCb_Semiplanar (YCbCr 4:2:0 8-bit YY/CrCb Semiplanar)\" },\n    { PFNC_U3V_YUV422_8_UYVY, \"YUV422_8_UYVY (YUV 4:2:2 8-bit)\" },\n    { PFNC_U3V_YUV422_8, \"YUV422_8 (YUV 4:2:2 8-bit)\" },\n    { PFNC_U3V_RGB565P, \"RGB565p (Red-Green-Blue 5/6/5-bit packed)\" },\n    { PFNC_U3V_BGR565P, \"BGR565p (Blue-Green-Red 5/6/5-bit packed)\" },\n    { PFNC_U3V_YCBCR422_8, \"YCbCr422_8 (YCbCr 4:2:2 8-bit)\" },\n    { PFNC_U3V_YCBCR601_422_8, \"YCbCr601_422_8 (YCbCr 4:2:2 8-bit BT.601)\" },\n    { PFNC_U3V_YCBCR709_422_8, \"YCbCr709_422_8 (YCbCr 4:2:2 8-bit BT.709)\" },\n    { PFNC_U3V_YCBCR422_8_CBYCRY, \"YCbCr422_8_CbYCrY (YCbCr 4:2:2 8-bit)\" },\n    { PFNC_U3V_YCBCR601_422_8_CBYCRY, \"YCbCr601_422_8_CbYCrY (YCbCr 4:2:2 8-bit BT.601)\" },\n    { PFNC_U3V_YCBCR709_422_8_CBYCRY, \"YCbCr709_422_8_CbYCrY (YCbCr 4:2:2 8-bit BT.709)\" },\n    { PFNC_U3V_BICOLORRGBG8, \"BiColorRGBG8 (Bi-color Red/Green - Blue/Green 8-bit)\" },\n    { PFNC_U3V_BICOLORBGRG8, \"BiColorBGRG8 (Bi-color Blue/Green - Red/Green 8-bit)\" },\n    { PFNC_U3V_COORD3D_AC8, \"Coord3D_AC8 (3D coordinate A-C 8-bit)\" },\n    { PFNC_U3V_COORD3D_AC8_PLANAR, \"Coord3D_AC8_Planar (3D coordinate A-C 8-bit planar)\" },\n    { PFNC_U3V_YCBCR2020_422_8, \"YCbCr2020_422_8 (YCbCr 4:2:2 8-bit BT.2020)\" },\n    { PFNC_U3V_YCBCR2020_422_8_CBYCRY, \"YCbCr2020_422_8_CbYCrY (YCbCr 4:2:2 8-bit BT.2020)\" },\n    { PFNC_U3V_YCBCR422_8_YY_CBCR_SEMIPLANAR, \"YCbCr422_8_YY_CbCr_Semiplanar (YCbCr 4:2:2 8-bit YY/CbCr Semiplanar)\" },\n    { PFNC_U3V_YCBCR422_8_YY_CRCB_SEMIPLANAR, \"YCbCr422_8_YY_CrCb_Semiplanar (YCbCr 4:2:2 8-bit YY/CrCb Semiplanar)\" },\n    { PFNC_U3V_YCBCR422_10P, \"YCbCr422_10p (YCbCr 4:2:2 10-bit packed)\" },\n    { PFNC_U3V_YCBCR601_422_10P, \"YCbCr601_422_10p (YCbCr 4:2:2 10-bit packed BT.601)\" },\n    { PFNC_U3V_YCBCR709_422_10P, \"YCbCr709_422_10p (YCbCr 4:2:2 10-bit packed BT.709)\" },\n    { PFNC_U3V_YCBCR422_10P_CBYCRY, \"YCbCr422_10p_CbYCrY (YCbCr 4:2:2 10-bit packed)\" },\n    { PFNC_U3V_YCBCR601_422_10P_CBYCRY, \"YCbCr601_422_10p_CbYCrY (YCbCr 4:2:2 10-bit packed BT.601)\" },\n    { PFNC_U3V_YCBCR709_422_10P_CBYCRY, \"YCbCr709_422_10p_CbYCrY (YCbCr 4:2:2 10-bit packed BT.709)\" },\n    { PFNC_U3V_BICOLORRGBG10P, \"BiColorRGBG10p (Bi-color Red/Green - Blue/Green 10-bit packed)\" },\n    { PFNC_U3V_BICOLORBGRG10P, \"BiColorBGRG10p (Bi-color Blue/Green - Red/Green 10-bit packed)\" },\n    { PFNC_U3V_COORD3D_AC10P, \"Coord3D_AC10p (3D coordinate A-C 10-bit packed)\" },\n    { PFNC_U3V_COORD3D_AC10P_PLANAR, \"Coord3D_AC10p_Planar (3D coordinate A-C 10-bit packed planar)\" },\n    { PFNC_U3V_YCBCR2020_422_10P, \"YCbCr2020_422_10p (YCbCr 4:2:2 10-bit packed BT.2020)\" },\n    { PFNC_U3V_YCBCR2020_422_10P_CBYCRY, \"YCbCr2020_422_10p_CbYCrY (YCbCr 4:2:2 10-bit packed BT.2020)\" },\n    { PFNC_U3V_RGB8, \"RGB8 (Red-Green-Blue 8-bit)\" },\n    { PFNC_U3V_BGR8, \"BGR8 (Blue-Green-Red 8-bit)\" },\n    { PFNC_U3V_YUV8_UYV, \"YUV8_UYV (YUV 4:4:4 8-bit)\" },\n    { PFNC_U3V_RGB8_PLANAR, \"RGB8_Planar (Red-Green-Blue 8-bit planar)\" },\n    { PFNC_U3V_YCBCR8_CBYCR, \"YCbCr8_CbYCr (YCbCr 4:4:4 8-bit)\" },\n    { PFNC_U3V_YCBCR601_8_CBYCR, \"YCbCr601_8_CbYCr (YCbCr 4:4:4 8-bit BT.601)\" },\n    { PFNC_U3V_YCBCR709_8_CBYCR, \"YCbCr709_8_CbYCr (YCbCr 4:4:4 8-bit BT.709)\" },\n    { PFNC_U3V_YCBCR8, \"YCbCr8 (YCbCr 4:4:4 8-bit)\" },\n    { PFNC_U3V_YCBCR422_12P, \"YCbCr422_12p (YCbCr 4:2:2 12-bit packed)\" },\n    { PFNC_U3V_YCBCR601_422_12P, \"YCbCr601_422_12p (YCbCr 4:2:2 12-bit packed BT.601)\" },\n    { PFNC_U3V_YCBCR709_422_12P, \"YCbCr709_422_12p (YCbCr 4:2:2 12-bit packed BT.709)\" },\n    { PFNC_U3V_YCBCR422_12P_CBYCRY, \"YCbCr422_12p_CbYCrY (YCbCr 4:2:2 12-bit packed)\" },\n    { PFNC_U3V_YCBCR601_422_12P_CBYCRY, \"YCbCr601_422_12p_CbYCrY (YCbCr 4:2:2 12-bit packed BT.601)\" },\n    { PFNC_U3V_YCBCR709_422_12P_CBYCRY, \"YCbCr709_422_12p_CbYCrY (YCbCr 4:2:2 12-bit packed BT.709)\" },\n    { PFNC_U3V_BICOLORRGBG12P, \"BiColorRGBG12p (Bi-color Red/Green - Blue/Green 12-bit packed)\" },\n    { PFNC_U3V_BICOLORBGRG12P, \"BiColorBGRG12p (Bi-color Blue/Green - Red/Green 12-bit packed)\" },\n    { PFNC_U3V_COORD3D_ABC8, \"Coord3D_ABC8 (3D coordinate A-B-C 8-bit)\" },\n    { PFNC_U3V_COORD3D_ABC8_PLANAR, \"Coord3D_ABC8_Planar (3D coordinate A-B-C 8-bit planar)\" },\n    { PFNC_U3V_COORD3D_AC12P, \"Coord3D_AC12p (3D coordinate A-C 12-bit packed)\" },\n    { PFNC_U3V_COORD3D_AC12P_PLANAR, \"Coord3D_AC12p_Planar (3D coordinate A-C 12-bit packed planar)\" },\n    { PFNC_U3V_YCBCR2020_8_CBYCR, \"YCbCr2020_8_CbYCr (YCbCr 4:4:4 8-bit BT.2020)\" },\n    { PFNC_U3V_YCBCR2020_422_12P, \"YCbCr2020_422_12p (YCbCr 4:2:2 12-bit packed BT.2020)\" },\n    { PFNC_U3V_YCBCR2020_422_12P_CBYCRY, \"YCbCr2020_422_12p_CbYCrY (YCbCr 4:2:2 12-bit packed BT.2020)\" },\n    { PFNC_U3V_BGR10P, \"BGR10p (Blue-Green-Red 10-bit packed)\" },\n    { PFNC_U3V_RGB10P, \"RGB10p (Red-Green-Blue 10-bit packed)\" },\n    { PFNC_U3V_YCBCR10P_CBYCR, \"YCbCr10p_CbYCr (YCbCr 4:4:4 10-bit packed)\" },\n    { PFNC_U3V_YCBCR601_10P_CBYCR, \"YCbCr601_10p_CbYCr (YCbCr 4:4:4 10-bit packed BT.601)\" },\n    { PFNC_U3V_YCBCR709_10P_CBYCR, \"YCbCr709_10p_CbYCr (YCbCr 4:4:4 10-bit packed BT.709)\" },\n    { PFNC_U3V_COORD3D_ABC10P, \"Coord3D_ABC10p (3D coordinate A-B-C 10-bit packed)\" },\n    { PFNC_U3V_COORD3D_ABC10P_PLANAR, \"Coord3D_ABC10p_Planar (3D coordinate A-B-C 10-bit packed planar)\" },\n    { PFNC_U3V_YCBCR2020_10P_CBYCR, \"YCbCr2020_10p_CbYCr (YCbCr 4:4:4 10-bit packed BT.2020)\" },\n    { PFNC_U3V_RGBA8, \"RGBa8 (Red-Green-Blue-alpha 8-bit)\" },\n    { PFNC_U3V_BGRA8, \"BGRa8 (Blue-Green-Red-alpha 8-bit)\" },\n    { GVSP_RGB10V1PACKED, \"GVSP_RGB10V1Packed (GigE Vision specific format, Red-Green-Blue 10-bit packed - variant 1)\" },\n    { PFNC_U3V_RGB10P32, \"RGB10p32 (Red-Green-Blue 10-bit packed into 32-bit)\" },\n    { PFNC_U3V_YCBCR422_10, \"YCbCr422_10 (YCbCr 4:2:2 10-bit unpacked)\" },\n    { PFNC_U3V_YCBCR422_12, \"YCbCr422_12 (YCbCr 4:2:2 12-bit unpacked)\" },\n    { PFNC_U3V_YCBCR601_422_10, \"YCbCr601_422_10 (YCbCr 4:2:2 10-bit unpacked BT.601)\" },\n    { PFNC_U3V_YCBCR601_422_12, \"YCbCr601_422_12 (YCbCr 4:2:2 12-bit unpacked BT.601)\" },\n    { PFNC_U3V_YCBCR709_422_10, \"YCbCr709_422_10 (YCbCr 4:2:2 10-bit unpacked BT.709)\" },\n    { PFNC_U3V_YCBCR709_422_12, \"YCbCr709_422_12 (YCbCr 4:2:2 12-bit unpacked BT.709)\" },\n    { PFNC_U3V_YCBCR422_10_CBYCRY, \"YCbCr422_10_CbYCrY (YCbCr 4:2:2 10-bit unpacked)\" },\n    { PFNC_U3V_YCBCR422_12_CBYCRY, \"YCbCr422_12_CbYCrY (YCbCr 4:2:2 12-bit unpacked)\" },\n    { PFNC_U3V_YCBCR601_422_10_CBYCRY, \"YCbCr601_422_10_CbYCrY (YCbCr 4:2:2 10-bit unpacked BT.601)\" },\n    { PFNC_U3V_YCBCR601_422_12_CBYCRY, \"YCbCr601_422_12_CbYCrY (YCbCr 4:2:2 12-bit unpacked BT.601)\" },\n    { PFNC_U3V_YCBCR709_422_10_CBYCRY, \"YCbCr709_422_10_CbYCrY (YCbCr 4:2:2 10-bit unpacked BT.709)\" },\n    { PFNC_U3V_YCBCR709_422_12_CBYCRY, \"YCbCr709_422_12_CbYCrY (YCbCr 4:2:2 12-bit unpacked BT.709)\" },\n    { PFNC_U3V_BICOLORRGBG10, \"BiColorRGBG10 (Bi-color Red/Green - Blue/Green 10-bit unpacked)\" },\n    { PFNC_U3V_BICOLORBGRG10, \"BiColorBGRG10 (Bi-color Blue/Green - Red/Green 10-bit unpacked)\" },\n    { PFNC_U3V_BICOLORRGBG12, \"BiColorRGBG12 (Bi-color Red/Green - Blue/Green 12-bit unpacked)\" },\n    { PFNC_U3V_BICOLORBGRG12, \"BiColorBGRG12 (Bi-color Blue/Green - Red/Green 12-bit unpacked)\" },\n    { PFNC_U3V_COORD3D_AC16, \"Coord3D_AC16 (3D coordinate A-C 16-bit)\" },\n    { PFNC_U3V_COORD3D_AC16_PLANAR, \"Coord3D_AC16_Planar (3D coordinate A-C 16-bit planar)\" },\n    { PFNC_U3V_YCBCR2020_422_10, \"YCbCr2020_422_10 (YCbCr 4:2:2 10-bit unpacked BT.2020)\" },\n    { PFNC_U3V_YCBCR2020_422_10_CBYCRY, \"YCbCr2020_422_10_CbYCrY (YCbCr 4:2:2 10-bit unpacked BT.2020)\" },\n    { PFNC_U3V_YCBCR2020_422_12, \"YCbCr2020_422_12 (YCbCr 4:2:2 12-bit unpacked BT.2020)\" },\n    { PFNC_U3V_YCBCR2020_422_12_CBYCRY, \"YCbCr2020_422_12_CbYCrY (YCbCr 4:2:2 12-bit unpacked BT.2020)\" },\n    { GVSP_RGB12V1PACKED, \"GVSP_RGB12V1Packed (GigE Vision specific format, Red-Green-Blue 12-bit packed - variant 1)\" },\n    { PFNC_U3V_BGR12P, \"BGR12p (Blue-Green-Red 12-bit packed)\" },\n    { PFNC_U3V_RGB12P, \"RGB12p (Red-Green-Blue 12-bit packed)\" },\n    { PFNC_U3V_YCBCR12P_CBYCR, \"YCbCr12p_CbYCr (YCbCr 4:4:4 12-bit packed)\" },\n    { PFNC_U3V_YCBCR601_12P_CBYCR, \"YCbCr601_12p_CbYCr (YCbCr 4:4:4 12-bit packed BT.601)\" },\n    { PFNC_U3V_YCBCR709_12P_CBYCR, \"YCbCr709_12p_CbYCr (YCbCr 4:4:4 12-bit packed BT.709)\" },\n    { PFNC_U3V_COORD3D_ABC12P, \"Coord3D_ABC12p (3D coordinate A-B-C 12-bit packed)\" },\n    { PFNC_U3V_COORD3D_ABC12P_PLANAR, \"Coord3D_ABC12p_Planar (3D coordinate A-B-C 12-bit packed planar)\" },\n    { PFNC_U3V_YCBCR2020_12P_CBYCR, \"YCbCr2020_12p_CbYCr (YCbCr 4:4:4 12-bit packed BT.2020)\" },\n    { PFNC_U3V_BGRA10P, \"BGRa10p (Blue-Green-Red-alpha 10-bit packed)\" },\n    { PFNC_U3V_RGBA10P, \"RGBa10p (Red-Green-Blue-alpha 10-bit packed)\" },\n    { PFNC_U3V_RGB10, \"RGB10 (Red-Green-Blue 10-bit unpacked)\" },\n    { PFNC_U3V_BGR10, \"BGR10 (Blue-Green-Red 10-bit unpacked)\" },\n    { PFNC_U3V_RGB12, \"RGB12 (Red-Green-Blue 12-bit unpacked)\" },\n    { PFNC_U3V_BGR12, \"BGR12 (Blue-Green-Red 12-bit unpacked)\" },\n    { PFNC_U3V_RGB10_PLANAR, \"RGB10_Planar (Red-Green-Blue 10-bit unpacked planar)\" },\n    { PFNC_U3V_RGB12_PLANAR, \"RGB12_Planar (Red-Green-Blue 12-bit unpacked planar)\" },\n    { PFNC_U3V_RGB16_PLANAR, \"RGB16_Planar (Red-Green-Blue 16-bit planar)\" },\n    { PFNC_U3V_RGB16, \"RGB16 (Red-Green-Blue 16-bit)\" },\n    { PFNC_U3V_BGR14, \"BGR14 (Blue-Green-Red 14-bit unpacked)\" },\n    { PFNC_U3V_BGR16, \"BGR16 (Blue-Green-Red 16-bit)\" },\n    { PFNC_U3V_BGRA12P, \"BGRa12p (Blue-Green-Red-alpha 12-bit packed)\" },\n    { PFNC_U3V_RGB14, \"RGB14 (Red-Green-Blue 14-bit unpacked)\" },\n    { PFNC_U3V_RGBA12P, \"RGBa12p (Red-Green-Blue-alpha 12-bit packed)\" },\n    { PFNC_U3V_YCBCR10_CBYCR, \"YCbCr10_CbYCr (YCbCr 4:4:4 10-bit unpacked)\" },\n    { PFNC_U3V_YCBCR12_CBYCR, \"YCbCr12_CbYCr (YCbCr 4:4:4 12-bit unpacked)\" },\n    { PFNC_U3V_YCBCR601_10_CBYCR, \"YCbCr601_10_CbYCr (YCbCr 4:4:4 10-bit unpacked BT.601)\" },\n    { PFNC_U3V_YCBCR601_12_CBYCR, \"YCbCr601_12_CbYCr (YCbCr 4:4:4 12-bit unpacked BT.601)\" },\n    { PFNC_U3V_YCBCR709_10_CBYCR, \"YCbCr709_10_CbYCr (YCbCr 4:4:4 10-bit unpacked BT.709)\" },\n    { PFNC_U3V_YCBCR709_12_CBYCR, \"YCbCr709_12_CbYCr (YCbCr 4:4:4 12-bit unpacked BT.709)\" },\n    { PFNC_U3V_COORD3D_ABC16, \"Coord3D_ABC16 (3D coordinate A-B-C 16-bit)\" },\n    { PFNC_U3V_COORD3D_ABC16_PLANAR, \"Coord3D_ABC16_Planar (3D coordinate A-B-C 16-bit planar)\" },\n    { PFNC_U3V_YCBCR2020_10_CBYCR, \"YCbCr2020_10_CbYCr (YCbCr 4:4:4 10-bit unpacked BT.2020)\" },\n    { PFNC_U3V_YCBCR2020_12_CBYCR, \"YCbCr2020_12_CbYCr (YCbCr 4:4:4 12-bit unpacked BT.2020)\" },\n    { PFNC_U3V_BGRA10, \"BGRa10 (Blue-Green-Red-alpha 10-bit unpacked)\" },\n    { PFNC_U3V_BGRA12, \"BGRa12 (Blue-Green-Red-alpha 12-bit unpacked)\" },\n    { PFNC_U3V_BGRA14, \"BGRa14 (Blue-Green-Red-alpha 14-bit unpacked)\" },\n    { PFNC_U3V_BGRA16, \"BGRa16 (Blue-Green-Red-alpha 16-bit)\" },\n    { PFNC_U3V_RGBA10, \"RGBa10 (Red-Green-Blue-alpha 10-bit unpacked)\" },\n    { PFNC_U3V_RGBA12, \"RGBa12 (Red-Green-Blue-alpha 12-bit unpacked)\" },\n    { PFNC_U3V_RGBA14, \"RGBa14 (Red-Green-Blue-alpha 14-bit unpacked)\" },\n    { PFNC_U3V_RGBA16, \"RGBa16 (Red-Green-Blue-alpha 16-bit)\" },\n    { PFNC_U3V_COORD3D_AC32F, \"Coord3D_AC32f (3D coordinate A-C 32-bit floating point)\" },\n    { PFNC_U3V_COORD3D_AC32F_PLANAR, \"Coord3D_AC32f_Planar (3D coordinate A-C 32-bit floating point planar)\" },\n    { PFNC_U3V_COORD3D_ABC32F, \"Coord3D_ABC32f (3D coordinate A-B-C 32-bit floating point)\" },\n    { PFNC_U3V_COORD3D_ABC32F_PLANAR, \"Coord3D_ABC32f_Planar (3D coordinate A-B-C 32-bit floating point planar)\" },\n    { 0, NULL }\n};\n\nstatic value_string_ext pixel_format_names_ext = VALUE_STRING_EXT_INIT(pixel_format_names);\n\nstatic const value_string payload_type_names[] =\n{\n    { U3V_STREAM_PAYLOAD_IMAGE, \"Image\" },\n    { U3V_STREAM_PAYLOAD_IMAGE_EXT_CHUNK, \"Image Extended Chunk\" },\n    { U3V_STREAM_PAYLOAD_CHUNK, \"Chunk\" },\n    { 0, NULL }\n};\n\nstatic const value_string u3v_descriptor_subtypes[] =\n{\n    { DESCRIPTOR_SUBTYPE_U3V_DEVICE_INFO, \"U3V DEVICE INFO\" },\n    { 0, NULL }\n};\n\nstatic int * const speed_support_fields[] = {\n    &hf_u3v_device_info_descriptor_bmSpeedSupport_low_speed,\n    &hf_u3v_device_info_descriptor_bmSpeedSupport_full_speed,\n    &hf_u3v_device_info_descriptor_bmSpeedSupport_high_speed,\n    &hf_u3v_device_info_descriptor_bmSpeedSupport_super_speed,\n    &hf_u3v_device_info_descriptor_bmSpeedSupport_reserved,\n    NULL\n};\n\n\n/*\n \\brief Returns a register name based on its address\n */\nstatic const char*\nget_register_name_from_address(uint64_t addr, wmem_allocator_t* scope, bool* is_custom_register, u3v_conv_info_t * u3v_conv_info)\n{\n    const char* address_string = NULL;\n    uint32_t offset_address;\n\n    if (is_custom_register != NULL) {\n        *is_custom_register = false;\n    }\n\n    /* check if this is the access to one of the base address registers */\n    if ( addr < 0x10000 ) {\n        offset_address = (uint32_t)addr;\n        address_string = try_val_to_str(offset_address, bootstrap_register_names_abrm);\n    }\n    if ( u3v_conv_info && u3v_conv_info->sbrm_addr != 0 && (addr >= u3v_conv_info->sbrm_addr)) {\n        offset_address = (uint32_t)( addr - u3v_conv_info->sbrm_addr);\n        address_string = try_val_to_str(offset_address, bootstrap_register_names_sbrm);\n    }\n    if ( u3v_conv_info && u3v_conv_info->sirm_addr != 0 && (addr >= u3v_conv_info->sirm_addr)) {\n        offset_address = (uint32_t)( addr - u3v_conv_info->sirm_addr);\n        address_string = try_val_to_str(offset_address, bootstrap_register_names_sirm);\n    }\n    if ( u3v_conv_info && u3v_conv_info->eirm_addr != 0 && (addr >= u3v_conv_info->eirm_addr)) {\n        offset_address = (uint32_t)( addr - u3v_conv_info->eirm_addr);\n        address_string = try_val_to_str(offset_address, bootstrap_register_names_eirm);\n    }\n\n    if (!address_string) {\n        address_string = wmem_strdup_printf(scope, \"[Addr:0x%016\" PRIX64 \"]\", addr);\n        if (is_custom_register != NULL) {\n            *is_custom_register = true;\n        }\n    }\n\n    return address_string;\n}\n\n/*\n \\brief Returns true if a register (identified by its address) is a known bootstrap register\n */\nstatic int\nis_known_bootstrap_register(uint64_t addr, u3v_conv_info_t * u3v_conv_info)\n{\n    const char* address_string = NULL;\n    uint32_t offset_address;\n    /* check if this is the access to one of the base address registers */\n    if ( addr < 0x10000 ) {\n        offset_address = (uint32_t)addr;\n        address_string = try_val_to_str(offset_address, bootstrap_register_names_abrm);\n    }\n    if ( u3v_conv_info->sbrm_addr != 0 &&  (addr >= u3v_conv_info->sbrm_addr)) {\n        offset_address = (uint32_t)( addr - u3v_conv_info->sbrm_addr);\n        address_string = try_val_to_str(offset_address, bootstrap_register_names_sbrm);\n    }\n    if ( u3v_conv_info->sirm_addr != 0 &&  (addr >= u3v_conv_info->sirm_addr)) {\n        offset_address = (uint32_t)( addr - u3v_conv_info->sirm_addr);\n        address_string = try_val_to_str(offset_address, bootstrap_register_names_sirm);\n    }\n    if ( u3v_conv_info->eirm_addr != 0 &&  (addr >= u3v_conv_info->eirm_addr)) {\n        offset_address = (uint32_t)( addr - u3v_conv_info->eirm_addr);\n        address_string = try_val_to_str(offset_address, bootstrap_register_names_eirm);\n    }\n    return address_string != NULL;\n}\n\n/*\n \\brief Identify Base Address Pointer\n*/\nstatic void\ndissect_u3v_register_bases(uint64_t addr, tvbuff_t *tvb, int offset, u3v_conv_info_t * u3v_conv_info)\n{\n    if ( addr < 0x10000 ) {\n        switch (addr) {\n        case U3V_ABRM_SBRM_ADDRESS:\n            u3v_conv_info->sbrm_addr = tvb_get_letoh64(tvb, offset);\n            break;\n        case U3V_ABRM_MANIFEST_TABLE_ADDRESS:\n            u3v_conv_info->manifest_addr = tvb_get_letoh64(tvb, offset);\n            break;\n        }\n    }\n    if ( u3v_conv_info->sbrm_addr != 0 && (addr >= u3v_conv_info->sbrm_addr)) {\n        addr -= u3v_conv_info->sbrm_addr;\n        switch(addr) {\n        case U3V_SBRM_SIRM_ADDRESS:\n            u3v_conv_info->sirm_addr = tvb_get_letoh64(tvb, offset);\n            break;\n        case U3V_SBRM_EIRM_ADDRESS:\n            u3v_conv_info->eirm_addr = tvb_get_letoh64(tvb, offset);\n            break;\n        case U3V_SBRM_IIDC2_ADDRESS:\n            u3v_conv_info->iidc2_addr = tvb_get_letoh64(tvb, offset);\n            break;\n        }\n    }\n}\n\n/*\n \\brief Attempt to dissect a bootstrap register\n*/\nstatic int\ndissect_u3v_register(uint64_t addr, proto_tree *branch, tvbuff_t *tvb, int offset, int length, u3v_conv_info_t *u3v_conv_info)\n{\n    bool isABRM = false, isSBRM = false, isSIRM = false, isEIRM = false;\n    /* check if this is the access to one of the base address registers */\n    if ( addr < 0x10000 ) {\n        isABRM = true;\n        switch (addr) {\n        case U3V_ABRM_GENCP_VERSION:\n            proto_tree_add_item(branch, hf_u3v_bootstrap_GenCP_Version, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n            break;\n        case U3V_ABRM_MANUFACTURER_NAME:\n            if ( length <= 64 ) {\n                proto_tree_add_item(branch, hf_u3v_bootstrap_Manufacturer_Name, tvb, offset, length, ENC_ASCII);\n            }\n            break;\n        case U3V_ABRM_MODEL_NAME:\n            if ( length <= 64 ) {\n                proto_tree_add_item(branch, hf_u3v_bootstrap_Model_Name, tvb, offset, length, ENC_ASCII);\n            }\n            break;\n        case U3V_ABRM_FAMILY_NAME:\n            if ( length <= 64 ) {\n                proto_tree_add_item(branch, hf_u3v_bootstrap_Family_Name, tvb, offset, length, ENC_ASCII);\n            }\n            break;\n        case U3V_ABRM_DEVICE_VERSION:\n            if ( length <= 64 ) {\n                proto_tree_add_item(branch, hf_u3v_bootstrap_Device_Version, tvb, offset, length, ENC_ASCII);\n            }\n            break;\n        case U3V_ABRM_MANUFACTURER_INFO:\n            if ( length <= 64 ) {\n                proto_tree_add_item(branch, hf_u3v_bootstrap_Manufacturer_Info, tvb, offset, length, ENC_ASCII);\n            }\n            break;\n        case U3V_ABRM_SERIAL_NUMBER:\n            if ( length <= 64 ) {\n                proto_tree_add_item(branch, hf_u3v_bootstrap_Serial_Number, tvb, offset, length, ENC_ASCII);\n            }\n            break;\n        case U3V_ABRM_USER_DEFINED_NAME:\n            if ( length <= 64 ) {\n                proto_tree_add_item(branch, hf_u3v_bootstrap_User_Defined_Name, tvb, offset, length, ENC_ASCII);\n            }\n            break;\n        case U3V_ABRM_DEVICE_CAPABILITY:\n            proto_tree_add_item(branch, hf_u3v_bootstrap_Device_Capability, tvb, offset, 8, ENC_LITTLE_ENDIAN);\n            break;\n        case U3V_ABRM_MAXIMUM_DEVICE_RESPONSE_TIME:\n            proto_tree_add_item(branch, hf_u3v_bootstrap_Maximum_Device_Response_Time, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n            break;\n        case U3V_ABRM_MANIFEST_TABLE_ADDRESS:\n            proto_tree_add_item(branch, hf_u3v_bootstrap_Manifest_Table_Address, tvb, offset, 8, ENC_LITTLE_ENDIAN);\n            break;\n        case U3V_ABRM_SBRM_ADDRESS:\n            proto_tree_add_item(branch, hf_u3v_bootstrap_SBRM_Address, tvb, offset, 8, ENC_LITTLE_ENDIAN);\n            break;\n        case U3V_ABRM_DEVICE_CONFIGURATION:\n            proto_tree_add_item(branch, hf_u3v_bootstrap_Device_Configuration, tvb, offset, 8, ENC_LITTLE_ENDIAN);\n            break;\n        case U3V_ABRM_HEARTBEAT_TIMEOUT:\n            proto_tree_add_item(branch, hf_u3v_bootstrap_Heartbeat_Timeout, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n            break;\n        case U3V_ABRM_MESSAGE_CHANNEL_CHANNEL_ID:\n            proto_tree_add_item(branch, hf_u3v_bootstrap_Message_Channel_channel_id, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n            break;\n        case U3V_ABRM_TIMESTAMP:\n            proto_tree_add_item(branch, hf_u3v_bootstrap_Timestamp, tvb, offset, 8, ENC_LITTLE_ENDIAN);\n            break;\n        case U3V_ABRM_TIMESTAMP_LATCH:\n            proto_tree_add_item(branch, hf_u3v_bootstrap_Timestamp_Latch, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n            break;\n        case U3V_ABRM_TIMESTAMP_INCREMENT:\n            proto_tree_add_item(branch, hf_u3v_bootstrap_Timestamp_Increment, tvb, offset, 8, ENC_LITTLE_ENDIAN);\n            break;\n        case U3V_ABRM_ACCESS_PRIVILEGE:\n            proto_tree_add_item(branch, hf_u3v_bootstrap_Access_Privilege, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n            break;\n        case U3V_ABRM_PROTOCOL_ENDIANNESS:\n            proto_tree_add_item(branch, hf_u3v_bootstrap_Protocol_Endianness, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n            break;\n        case U3V_ABRM_IMPLEMENTATION_ENDIANNESS:\n            proto_tree_add_item(branch, hf_u3v_bootstrap_Implementation_Endianness, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n            break;\n        default:\n            isABRM = false;\n            break;\n        }\n    }\n    if ( u3v_conv_info->sbrm_addr != 0 && (addr >= u3v_conv_info->sbrm_addr)) {\n        uint64_t map_offset = addr - u3v_conv_info->sbrm_addr;\n        isSBRM = true;\n        switch(map_offset) {\n        case U3V_SBRM_U3V_VERSION:\n            proto_tree_add_item(branch, hf_u3v_bootstrap_U3V_Version, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n            break;\n        case U3V_SBRM_U3VCP_CAPABILITY_REGISTER:\n            proto_tree_add_item(branch, hf_u3v_bootstrap_U3VCP_Capability_Register, tvb, offset, 8, ENC_LITTLE_ENDIAN);\n            break;\n        case U3V_SBRM_U3VCP_CONFIGURATION_REGISTER:\n            proto_tree_add_item(branch, hf_u3v_bootstrap_U3VCP_Configuration_Register, tvb, offset, 8, ENC_LITTLE_ENDIAN);\n            break;\n        case U3V_SBRM_MAXIMUM_COMMAND_TRANSFER_LENGTH:\n            proto_tree_add_item(branch, hf_u3v_bootstrap_Maximum_Command_Transfer_Length, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n            break;\n        case U3V_SBRM_MAXIMUM_ACKNOWLEDGE_TRANSFER_LENGTH:\n            proto_tree_add_item(branch, hf_u3v_bootstrap_Maximum_Acknowledge_Transfer_Length, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n            break;\n        case U3V_SBRM_NUMBER_OF_STREAM_CHANNELS:\n            proto_tree_add_item(branch, hf_u3v_bootstrap_Number_of_Stream_Channels, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n            break;\n        case U3V_SBRM_SIRM_ADDRESS:\n            proto_tree_add_item(branch, hf_u3v_bootstrap_SIRM_Address, tvb, offset, 8, ENC_LITTLE_ENDIAN);\n            break;\n        case U3V_SBRM_SIRM_LENGTH:\n            proto_tree_add_item(branch, hf_u3v_bootstrap_SIRM_Length, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n            break;\n        case U3V_SBRM_EIRM_ADDRESS:\n            proto_tree_add_item(branch, hf_u3v_bootstrap_EIRM_Address, tvb, offset, 8, ENC_LITTLE_ENDIAN);\n            break;\n        case U3V_SBRM_EIRM_LENGTH:\n            proto_tree_add_item(branch, hf_u3v_bootstrap_EIRM_Length, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n            break;\n        case U3V_SBRM_IIDC2_ADDRESS:\n            proto_tree_add_item(branch, hf_u3v_bootstrap_IIDC2_Address, tvb, offset, 8, ENC_LITTLE_ENDIAN);\n            break;\n        case U3V_SBRM_CURRENT_SPEED:\n            proto_tree_add_item(branch, hf_u3v_bootstrap_Current_Speed, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n            break;\n        default:\n            isSBRM = false;\n            break;\n        }\n    }\n    if ( u3v_conv_info->sirm_addr != 0 && (addr >= u3v_conv_info->sirm_addr)) {\n        uint64_t map_offset = addr - u3v_conv_info->sirm_addr;\n        isSIRM = true;\n        switch(map_offset) {\n        case U3V_SIRM_SI_INFO:\n            proto_tree_add_item(branch, hf_u3v_bootstrap_SI_Info, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n            break;\n        case U3V_SIRM_SI_CONTROL:\n            proto_tree_add_item(branch, hf_u3v_bootstrap_SI_Control, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n            break;\n        case U3V_SIRM_SI_REQUIRED_PAYLOAD_SIZE:\n            proto_tree_add_item(branch, hf_u3v_bootstrap_SI_Required_Payload_Size, tvb, offset, 8, ENC_LITTLE_ENDIAN);\n            break;\n        case U3V_SIRM_SI_REQUIRED_LEADER_SIZE:\n            proto_tree_add_item(branch, hf_u3v_bootstrap_SI_Required_Leader_Size, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n            break;\n        case U3V_SIRM_SI_REQUIRED_TRAILER_SIZE:\n            proto_tree_add_item(branch, hf_u3v_bootstrap_SI_Required_Trailer_Size, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n            break;\n        case U3V_SIRM_SI_MAXIMUM_LEADER_SIZE:\n            proto_tree_add_item(branch, hf_u3v_bootstrap_SI_Maximum_Leader_Size, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n            break;\n        case U3V_SIRM_SI_PAYLOAD_TRANSFER_SIZE:\n            proto_tree_add_item(branch, hf_u3v_bootstrap_SI_Payload_Transfer_Size, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n            break;\n        case U3V_SIRM_SI_PAYLOAD_TRANSFER_COUNT:\n            proto_tree_add_item(branch, hf_u3v_bootstrap_SI_Payload_Transfer_Count, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n            break;\n        case U3V_SIRM_SI_PAYLOAD_FINAL_TRANSFER1_SIZE:\n            proto_tree_add_item(branch, hf_u3v_bootstrap_SI_Payload_Final_Transfer1_Size, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n            break;\n        case U3V_SIRM_SI_PAYLOAD_FINAL_TRANSFER2_SIZE:\n            proto_tree_add_item(branch, hf_u3v_bootstrap_SI_Payload_Final_Transfer2_Size, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n            break;\n        case U3V_SIRM_SI_MAXIMUM_TRAILER_SIZE:\n            proto_tree_add_item(branch, hf_u3v_bootstrap_SI_Maximum_Trailer_Size, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n            break;\n        default:\n            isSIRM = false;\n            break;\n        }\n    }\n    if ( u3v_conv_info->eirm_addr != 0 && (addr >= u3v_conv_info->eirm_addr)) {\n        uint64_t map_offset = addr -u3v_conv_info->eirm_addr;\n        isEIRM=true;\n        switch(map_offset) {\n        case U3V_EIRM_EI_CONTROL:\n            proto_tree_add_item(branch, hf_u3v_bootstrap_EI_Control, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n            break;\n        case U3V_EIRM_MAXIMUM_EVENT_TRANSFER_LENGTH:\n            proto_tree_add_item(branch, hf_u3v_bootstrap_Maximum_Event_Transfer_Length, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n            break;\n        case U3V_EIRM_EVENT_TEST_CONTROL:\n            proto_tree_add_item(branch, hf_u3v_bootstrap_Event_Test_Control, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n            break;\n        default:\n            isEIRM = false;\n            break;\n        }\n    }\n    if(isABRM || isSBRM || isSIRM || isEIRM ) {\n        return 1;\n    }\n    return 0;\n}\n\n/*\n \\brief DISSECT: Read memory command\n*/\nstatic void\ndissect_u3v_read_mem_cmd(proto_tree *u3v_telegram_tree, tvbuff_t *tvb, packet_info *pinfo, int startoffset, int length, u3v_conv_info_t *u3v_conv_info, gencp_transaction_t * gencp_trans)\n{\n    uint64_t addr = 0;\n    const char* address_string = NULL;\n    bool is_custom_register = false;\n    uint16_t count = 0;\n    int offset = startoffset;\n    proto_item *item = NULL;\n\n    addr = tvb_get_letoh64(tvb, offset);\n    gencp_trans->address = addr;\n\n    address_string = get_register_name_from_address(addr, pinfo->pool, &is_custom_register, u3v_conv_info);\n    count = tvb_get_letohs(tvb, offset + 10);   /* Number of bytes to read from memory */\n\n    gencp_trans->count = count;\n    if ( 0xffffffff00000000 & addr ) {\n        col_append_fstr(pinfo->cinfo, COL_INFO, \" (0x%016\" PRIX64 \" (%d) bytes) %s\", addr, count, address_string);\n    } else {\n        col_append_fstr(pinfo->cinfo, COL_INFO, \" (0x%08X (%d) bytes)\", (uint32_t)addr, count);\n    }\n\n\n    item = proto_tree_add_item(u3v_telegram_tree, hf_u3v_scd_readmem_cmd, tvb, offset, length, ENC_NA);\n    u3v_telegram_tree = proto_item_add_subtree(item, ett_u3v_payload_cmd);\n\n    /* address */\n    if (is_known_bootstrap_register(addr, u3v_conv_info)) {\n        item = proto_tree_add_uint64(u3v_telegram_tree, hf_u3v_address, tvb, offset, 8, addr);\n        proto_item_append_text(item, \" %s\", address_string);\n    } else {\n        proto_tree_add_item(u3v_telegram_tree, hf_u3v_custom_memory_addr, tvb, offset, 8, ENC_LITTLE_ENDIAN);\n    }\n    offset += 8;\n\n    /* reserved field */\n    proto_tree_add_item(u3v_telegram_tree, hf_u3v_reserved, tvb, offset, 2, ENC_NA);\n    offset += 2;\n\n    /* count */\n    proto_tree_add_item(u3v_telegram_tree, hf_u3v_count, tvb, offset, 2, ENC_LITTLE_ENDIAN);\n}\n\n/*\n \\brief DISSECT: Write memory command\n*/\nstatic void\ndissect_u3v_write_mem_cmd(proto_tree *u3v_telegram_tree, tvbuff_t *tvb, packet_info *pinfo, int startoffset, int length, u3v_conv_info_t *u3v_conv_info, gencp_transaction_t *gencp_trans)\n{\n    const char* address_string = NULL;\n    bool is_custom_register = false;\n    uint64_t addr = 0;\n    unsigned byte_count = 0;\n    proto_item *item = NULL;\n    unsigned offset = startoffset + 8;\n\n    addr = tvb_get_letoh64(tvb, startoffset);\n    byte_count = length - 8;\n    address_string = get_register_name_from_address(addr, pinfo->pool, &is_custom_register, u3v_conv_info);\n\n    gencp_trans->address = addr;\n    gencp_trans->count = byte_count;\n\n    /* fill in Info column in Wireshark GUI */\n    col_append_fstr(pinfo->cinfo, COL_INFO, \"%s: %d bytes\", address_string, byte_count);\n\n\n    /* Subtree initialization for Payload Data: WRITEMEM_CMD */\n    item = proto_tree_add_item(u3v_telegram_tree, hf_u3v_scd_writemem_cmd, tvb, startoffset, length, ENC_NA);\n    u3v_telegram_tree = proto_item_add_subtree(item, ett_u3v_payload_cmd);\n\n    if (is_known_bootstrap_register(addr, u3v_conv_info)) {\n        item = proto_tree_add_uint64(u3v_telegram_tree, hf_u3v_address, tvb, startoffset, 8, addr);\n        proto_item_append_text(item, \" %s\", address_string);\n        dissect_u3v_register(addr, u3v_telegram_tree, tvb, offset, byte_count, u3v_conv_info);\n    } else {\n        proto_tree_add_item(u3v_telegram_tree, hf_u3v_custom_memory_addr, tvb, startoffset, 8, ENC_LITTLE_ENDIAN);\n        proto_tree_add_item(u3v_telegram_tree, hf_u3v_custom_memory_data, tvb, startoffset + 8, byte_count, ENC_NA);\n    }\n\n}\n\n/*\n *  \\brief DISSECT: Event command\n */\nstatic void\ndissect_u3v_event_cmd(proto_tree *u3v_telegram_tree, tvbuff_t *tvb, packet_info *pinfo, int startoffset, int length)\n{\n    int32_t eventid;\n    int offset = startoffset;\n    proto_item *item = NULL;\n\n    /* Get event ID */\n    eventid = tvb_get_letohs(tvb, offset + 2);\n\n    /* fill in Info column in Wireshark GUI */\n    col_append_fstr(pinfo->cinfo, COL_INFO, \"[ID: 0x%04X]\", eventid);\n\n\n    item = proto_tree_add_item(u3v_telegram_tree, hf_u3v_scd_event_cmd, tvb, offset, length, ENC_NA);\n    u3v_telegram_tree = proto_item_add_subtree(item, ett_u3v_payload_cmd);\n\n    offset += 2;\n\n    /* Use range to determine type of event */\n    if ((eventid >= 0x0000) && (eventid <= 0x8000)) {\n        /* Standard ID */\n        proto_tree_add_item(u3v_telegram_tree, hf_u3v_eventcmd_id, tvb, offset, 2, ENC_LITTLE_ENDIAN);\n    } else if ((eventid >= 0x8001) && (eventid <= 0x8FFF)) {\n        /* Error */\n        proto_tree_add_item(u3v_telegram_tree, hf_u3v_eventcmd_error_id, tvb, offset, 2, ENC_LITTLE_ENDIAN);\n    } else if ((eventid >= 0x9000) && (eventid <= 0xFFFF)) {\n        /* Device specific */\n        proto_tree_add_item(u3v_telegram_tree, hf_u3v_eventcmd_device_specific_id, tvb, offset, 2, ENC_LITTLE_ENDIAN);\n    }\n    offset += 2;\n\n    /* Timestamp (64 bit) associated with event */\n    proto_tree_add_item(u3v_telegram_tree, hf_u3v_eventcmd_timestamp, tvb, offset, 8, ENC_LITTLE_ENDIAN);\n    offset += 8;\n\n    /* Data */\n    if (length > offset ) {\n        proto_tree_add_item(u3v_telegram_tree, hf_u3v_eventcmd_data, tvb, offset, length - 12, ENC_NA);\n    }\n}\n\n/*\n \\brief DISSECT: Read memory acknowledge\n*/\nstatic void\ndissect_u3v_read_mem_ack(proto_tree *u3v_telegram_tree, tvbuff_t *tvb, packet_info *pinfo, int startoffset, int length, u3v_conv_info_t *u3v_conv_info, gencp_transaction_t * gencp_trans)\n{\n    uint64_t addr = 0;\n    const char *address_string = NULL;\n    bool is_custom_register = false;\n    bool have_address = (0 != gencp_trans->cmd_frame);\n    proto_item *item = NULL;\n    unsigned offset = startoffset;\n    unsigned byte_count = (length);\n\n    addr = gencp_trans->address;\n    dissect_u3v_register_bases(addr, tvb, startoffset, u3v_conv_info);\n    if (have_address) {\n        address_string = get_register_name_from_address(addr, pinfo->pool, &is_custom_register, u3v_conv_info);\n        /* Fill in Wireshark GUI Info column */\n        col_append_str(pinfo->cinfo, COL_INFO, address_string);\n    }\n\n\n    /* Subtree initialization for Payload Data: READMEM_ACK */\n    item = proto_tree_add_item(u3v_telegram_tree, hf_u3v_scd_ack_readmem_ack, tvb, startoffset, length, ENC_NA);\n    u3v_telegram_tree = proto_item_add_subtree(item, ett_u3v_payload_cmd);\n\n    /* Bootstrap register known address */\n    if (have_address) {\n        item = proto_tree_add_uint64(u3v_telegram_tree, hf_u3v_address, tvb, 0,0 , addr);\n        proto_item_set_generated(item);\n\n        if (is_known_bootstrap_register(addr, u3v_conv_info)) {\n            dissect_u3v_register(addr, u3v_telegram_tree, tvb, offset, byte_count, u3v_conv_info);\n        } else {\n            proto_tree_add_item(u3v_telegram_tree, hf_u3v_custom_memory_data, tvb, startoffset, length, ENC_NA);\n        }\n    }\n}\n\n/*\n \\brief DISSECT: Write memory acknowledge\n*/\nstatic void\ndissect_u3v_write_mem_ack(proto_tree *u3v_telegram_tree, tvbuff_t *tvb, packet_info *pinfo, int startoffset, int length, u3v_conv_info_t *u3v_conv_info , gencp_transaction_t * gencp_trans)\n{\n    uint64_t addr = 0;\n    int offset = startoffset;\n    const char *address_string = NULL;\n    bool is_custom_register = false;\n    bool have_address = (0 != gencp_trans->cmd_frame);\n    proto_item *item = NULL;\n\n    addr = gencp_trans->address;\n    if (have_address) {\n        address_string = get_register_name_from_address(addr, pinfo->pool, &is_custom_register, u3v_conv_info);\n\n        /* Fill in Wireshark GUI Info column */\n        col_append_str(pinfo->cinfo, COL_INFO, address_string);\n    }\n\n    item = proto_tree_add_item(u3v_telegram_tree, hf_u3v_scd_writemem_ack, tvb, startoffset, length, ENC_NA);\n    u3v_telegram_tree = proto_item_add_subtree(item, ett_u3v_payload_cmd);\n\n    if (have_address) {\n            item = proto_tree_add_uint64(u3v_telegram_tree, hf_u3v_address, tvb, 0,0 , addr);\n            proto_item_set_generated(item);\n        }\n    /* Number of bytes successfully written to the device register map */\n    if ( length == 4 ) {\n\n        /* reserved field */\n        proto_tree_add_item(u3v_telegram_tree, hf_u3v_reserved, tvb, offset, 2, ENC_NA);\n        offset += 2;\n\n        proto_tree_add_item(u3v_telegram_tree, hf_u3v_count, tvb, offset, 2, ENC_LITTLE_ENDIAN);\n    }\n}\n\n/*\n \\brief DISSECT: Pending acknowledge\n*/\nstatic void\ndissect_u3v_pending_ack(proto_tree *u3v_telegram_tree, tvbuff_t *tvb, packet_info *pinfo _U_, int startoffset, int length, u3v_conv_info_t *u3v_conv_info _U_, gencp_transaction_t *gencp_trans _U_)\n{\n    proto_item *item = NULL;\n    unsigned offset = startoffset;\n\n    /* Fill in Wireshark GUI Info column */\n    col_append_fstr(pinfo->cinfo, COL_INFO, \" %d ms\", tvb_get_letohs(tvb, startoffset+2));\n\n    item = proto_tree_add_item(u3v_telegram_tree, hf_u3v_ccd_pending_ack, tvb, startoffset, length, ENC_NA);\n    u3v_telegram_tree = proto_item_add_subtree(item, ett_u3v_payload_cmd);\n\n    /* reserved field */\n    proto_tree_add_item(u3v_telegram_tree, hf_u3v_reserved, tvb, offset, 2, ENC_NA);\n    offset += 2;\n\n    proto_tree_add_item(u3v_telegram_tree, hf_u3v_time_to_completion, tvb, offset, 2, ENC_LITTLE_ENDIAN);\n}\n\n/*\n \\brief DISSECT: Stream Leader\n*/\nstatic void\ndissect_u3v_stream_leader(proto_tree *u3v_telegram_tree, tvbuff_t *tvb, packet_info *pinfo, urb_info_t *urb _U_)\n{\n    uint32_t offset = 0;\n    uint32_t payload_type = 0;\n    uint64_t block_id = 0;\n    proto_item *item = NULL;\n\n    /* Subtree initialization for Stream Leader */\n    item = proto_tree_add_item(u3v_telegram_tree, hf_u3v_stream_leader, tvb, 0, -1, ENC_NA);\n    u3v_telegram_tree = proto_item_add_subtree(item, ett_u3v_stream_leader);\n\n    /* Add the prefix code: */\n    proto_tree_add_item(u3v_telegram_tree, hf_u3v_stream_prefix, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n    offset += 4;\n\n    /* reserved field */\n    proto_tree_add_item(u3v_telegram_tree, hf_u3v_stream_reserved, tvb, offset, 2, ENC_NA);\n    offset += 2;\n\n    /* leader size */\n    proto_tree_add_item(u3v_telegram_tree, hf_u3v_stream_leader_size, tvb, offset, 2, ENC_LITTLE_ENDIAN);\n    offset += 2;\n\n    /* block id */\n    block_id = tvb_get_letoh64(tvb, offset);\n    proto_tree_add_item(u3v_telegram_tree, hf_u3v_stream_block_id, tvb, offset, 8, ENC_LITTLE_ENDIAN);\n    offset += 8;\n\n    /* reserved field */\n    proto_tree_add_item(u3v_telegram_tree, hf_u3v_stream_reserved, tvb, offset, 2, ENC_NA);\n    offset += 2;\n\n    /* payload type */\n    payload_type = tvb_get_letohs(tvb, offset);\n    proto_tree_add_item(u3v_telegram_tree, hf_u3v_stream_payload_type, tvb, offset, 2, ENC_LITTLE_ENDIAN);\n    offset += 2;\n\n    /* Add payload type to information string */\n    col_append_fstr(pinfo->cinfo, COL_INFO, \"Stream Leader  [ Block ID: %\" PRIu64 \" , Type %s]\",\n                    block_id,\n                    val_to_str_const(payload_type, payload_type_names, \"Unknown Payload Type\"));\n\n    if (payload_type == U3V_STREAM_PAYLOAD_IMAGE ||\n        payload_type == U3V_STREAM_PAYLOAD_IMAGE_EXT_CHUNK ||\n        payload_type == U3V_STREAM_PAYLOAD_CHUNK) {\n        /* timestamp */\n        proto_tree_add_item(u3v_telegram_tree, hf_u3v_stream_timestamp, tvb, offset, 8, ENC_LITTLE_ENDIAN);\n        offset += 8;\n    }\n\n    if (payload_type == U3V_STREAM_PAYLOAD_IMAGE ||\n        payload_type == U3V_STREAM_PAYLOAD_IMAGE_EXT_CHUNK ) {\n        /* pixel format */\n        proto_tree_add_item(u3v_telegram_tree, hf_u3v_stream_pixel_format, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n        offset += 4;\n\n        /* size_x */\n        proto_tree_add_item(u3v_telegram_tree, hf_u3v_stream_size_x, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n        offset += 4;\n\n        /* size_y */\n        proto_tree_add_item(u3v_telegram_tree, hf_u3v_stream_size_y, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n        offset += 4;\n\n        /* offset_x */\n        proto_tree_add_item(u3v_telegram_tree, hf_u3v_stream_offset_x, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n        offset += 4;\n\n        /* offset_x */\n        proto_tree_add_item(u3v_telegram_tree, hf_u3v_stream_offset_y, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n        offset += 4;\n\n        /* padding_x */\n        proto_tree_add_item(u3v_telegram_tree, hf_u3v_stream_padding_x, tvb, offset, 2, ENC_LITTLE_ENDIAN);\n        /* offset += 2; */\n\n        /* reserved field */\n        proto_tree_add_item(u3v_telegram_tree, hf_u3v_stream_reserved, tvb, offset, 2, ENC_NA);\n        /* offset += 2; */\n    }\n}\n\n/*\n \\brief DISSECT: Stream Trailer\n*/\nstatic void\ndissect_u3v_stream_trailer(proto_tree *u3v_telegram_tree, tvbuff_t *tvb, packet_info *pinfo, urb_info_t *urb _U_)\n{\n    int offset = 0;\n    uint64_t block_id;\n    proto_item *item = NULL;\n\n    /* Subtree initialization for Stream Trailer */\n    item = proto_tree_add_item(u3v_telegram_tree, hf_u3v_stream_trailer, tvb, 0, -1, ENC_NA);\n    u3v_telegram_tree = proto_item_add_subtree(item, ett_u3v_stream_trailer);\n\n    /* Add the prefix code: */\n    proto_tree_add_item(u3v_telegram_tree, hf_u3v_stream_prefix, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n    offset += 4;\n\n    /* reserved field */\n    proto_tree_add_item(u3v_telegram_tree, hf_u3v_stream_reserved, tvb, offset, 2, ENC_NA);\n    offset += 2;\n\n    /* trailer size */\n    proto_tree_add_item(u3v_telegram_tree, hf_u3v_stream_trailer_size, tvb, offset, 2, ENC_LITTLE_ENDIAN);\n    offset += 2;\n\n    /* block id */\n    block_id = tvb_get_letoh64(tvb, offset);\n    proto_tree_add_item(u3v_telegram_tree, hf_u3v_stream_block_id, tvb, offset, 8, ENC_LITTLE_ENDIAN);\n    offset += 8;\n\n    /* status*/\n    proto_tree_add_item(u3v_telegram_tree, hf_u3v_stream_status, tvb, offset, 2, ENC_LITTLE_ENDIAN);\n    offset += 2;\n\n    /* reserved field */\n    proto_tree_add_item(u3v_telegram_tree, hf_u3v_stream_reserved, tvb, offset, 2, ENC_NA);\n    offset += 2;\n\n    /* block id */\n    proto_tree_add_item(u3v_telegram_tree, hf_u3v_stream_valid_payload_size, tvb, offset, 8, ENC_LITTLE_ENDIAN);\n    offset += 8;\n\n    /* Add payload type to information string */\n    col_append_fstr(pinfo->cinfo, COL_INFO, \"Stream Trailer [ Block ID: %\" PRIu64 \"]\", block_id);\n\n    if (tvb_captured_length_remaining(tvb,offset) >=4 ) {\n        /* size_y */\n        proto_tree_add_item(u3v_telegram_tree, hf_u3v_stream_size_y, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n        offset += 4;\n    }\n\n    if (tvb_captured_length_remaining(tvb,offset) >=4 ) {\n        /* chunk layout id */\n        proto_tree_add_item(u3v_telegram_tree, hf_u3v_stream_chunk_layout_id, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n        /* offset += 4; */\n    }\n}\n\n/*\n \\brief DISSECT: Stream Payload\n*/\nstatic void\ndissect_u3v_stream_payload(proto_tree *u3v_telegram_tree, tvbuff_t *tvb, packet_info *pinfo, urb_info_t *urb _U_)\n{\n    proto_item *item = NULL;\n\n    /* Subtree initialization for Stream Payload */\n    item = proto_tree_add_item(u3v_telegram_tree, hf_u3v_stream_payload, tvb, 0, -1, ENC_NA);\n    u3v_telegram_tree = proto_item_add_subtree(item, ett_u3v_stream_payload);\n\n    /* Data */\n    proto_tree_add_item(u3v_telegram_tree, hf_u3v_stream_data, tvb, 0, -1, ENC_NA);\n\n    /* Add payload type to information string */\n    col_append_str(pinfo->cinfo, COL_INFO, \"Stream Payload\");\n}\n\n/*\n  \\brief Point of entry of all U3V packet dissection\n*/\nstatic int\ndissect_u3v(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)\n{\n    int offset = 0;\n    proto_tree *u3v_tree = NULL, *ccd_tree_flag, *u3v_telegram_tree = NULL, *ccd_tree = NULL;\n    int data_length = 0;\n    int req_id = 0;\n    int command_id = -1;\n    int status = 0;\n    unsigned prefix = 0;\n    proto_item *ti = NULL;\n    proto_item *item = NULL;\n    const char *command_string;\n    urb_info_t *urb;\n    bool stream_detected = false;\n    bool control_detected = false;\n    u3v_conv_info_t *u3v_conv_info = NULL;\n    gencp_transaction_t *gencp_trans = NULL;\n\n    urb = (urb_info_t *)data;\n    if (!urb || !urb->conv) {\n        return 0;\n    }\n\n    /* decide if this packet belongs to U3V protocol */\n    u3v_conv_info = (u3v_conv_info_t *)urb->conv->class_data;\n\n    if (!u3v_conv_info) {\n        u3v_conv_info = wmem_new0(wmem_file_scope(), u3v_conv_info_t);\n        urb->conv->class_data = u3v_conv_info;\n        urb->conv->class_data_type = USB_CONV_U3V;\n    } else if (urb->conv->class_data_type != USB_CONV_U3V) {\n        /* Don't dissect if another USB type is in the conversation */\n        return 0;\n    }\n\n    prefix = tvb_get_letohl(tvb, 0);\n    if ((tvb_reported_length(tvb) >= 4) && ( ( U3V_CONTROL_PREFIX == prefix ) || ( U3V_EVENT_PREFIX == prefix ) ) ) {\n        control_detected = true;\n    }\n\n    if (((tvb_reported_length(tvb) >= 4) && (( U3V_STREAM_LEADER_PREFIX == prefix ) || ( U3V_STREAM_TRAILER_PREFIX == prefix )))\n         || (urb->endpoint == u3v_conv_info->ep_stream)) {\n        stream_detected = true;\n    }\n\n    /* initialize interface class/subclass in case no descriptors have been dissected yet */\n    if ( control_detected || stream_detected){\n        if (urb->conv->interfaceClass == IF_CLASS_UNKNOWN &&\n            urb->conv->interfaceSubclass == IF_SUBCLASS_UNKNOWN) {\n            urb->conv->interfaceClass = IF_CLASS_MISCELLANEOUS;\n            urb->conv->interfaceSubclass = IF_SUBCLASS_MISC_U3V;\n        }\n    }\n\n    if ( control_detected ) {\n        /* Set the protocol column */\n        col_set_str(pinfo->cinfo, COL_PROTOCOL, \"U3V\");\n\n        /* Clear out stuff in the info column */\n        col_clear(pinfo->cinfo, COL_INFO);\n\n        /* Adds \"USB3Vision\" heading to protocol tree */\n        /* We will add fields to this using the u3v_tree pointer */\n        ti = proto_tree_add_item(tree, proto_u3v, tvb, offset, -1, ENC_NA);\n        u3v_tree = proto_item_add_subtree(ti, ett_u3v);\n\n        prefix = tvb_get_letohl(tvb, offset);\n        command_id = tvb_get_letohs(tvb, offset+6);\n\n        /* decode CCD ( DCI/DCE command data layout) */\n        if ((prefix == U3V_CONTROL_PREFIX || prefix == U3V_EVENT_PREFIX) && ((command_id % 2) == 0)) {\n            command_string = val_to_str_wmem(pinfo->pool, command_id,command_names,\"Unknown Command (0x%x)\");\n            item = proto_tree_add_item(u3v_tree, hf_u3v_ccd_cmd, tvb, offset, 8, ENC_NA);\n            proto_item_append_text(item, \": %s\", command_string);\n            ccd_tree = proto_item_add_subtree(item, ett_u3v_cmd);\n\n            /* Add the prefix code: */\n            proto_tree_add_item(ccd_tree, hf_u3v_gencp_prefix, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n            offset += 4;\n\n            /* Add the flags */\n            item = proto_tree_add_item(ccd_tree, hf_u3v_flag, tvb, offset, 2, ENC_LITTLE_ENDIAN);\n            ccd_tree_flag  = proto_item_add_subtree(item, ett_u3v_flags);\n            proto_tree_add_item(ccd_tree_flag, hf_u3v_acknowledge_required_flag, tvb, offset, 2, ENC_LITTLE_ENDIAN);\n\n            offset += 2;\n            col_append_fstr(pinfo->cinfo, COL_INFO, \"> %s \", command_string);\n        } else if (prefix == U3V_CONTROL_PREFIX && ((command_id % 2) == 1)) {\n            command_string = val_to_str_wmem(pinfo->pool, command_id,command_names,\"Unknown Acknowledge (0x%x)\");\n            item = proto_tree_add_item(u3v_tree, hf_u3v_ccd_ack, tvb, offset, 8, ENC_NA);\n            proto_item_append_text(item, \": %s\", command_string);\n            ccd_tree = proto_item_add_subtree(item, ett_u3v_ack);\n\n            /* Add the prefix code: */\n            proto_tree_add_item(ccd_tree, hf_u3v_gencp_prefix, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n            offset += 4;\n\n            /* Add the status: */\n            proto_tree_add_item(ccd_tree, hf_u3v_status, tvb, offset, 2,ENC_LITTLE_ENDIAN);\n            status = tvb_get_letohs(tvb, offset);\n            offset += 2;\n            col_append_fstr(pinfo->cinfo, COL_INFO, \"< %s %s\",\n                    command_string,\n                    val_to_str_wmem(pinfo->pool, status, status_names_short, \"Unknown status (0x%04X)\"));\n        } else {\n            return 0;\n        }\n\n        /* Add the command id*/\n        proto_tree_add_item(ccd_tree, hf_u3v_command_id, tvb, offset, 2,ENC_LITTLE_ENDIAN);\n        offset += 2;\n\n        /* Parse the second part of both the command and the acknowledge header:\n        0          15 16         31\n        -------- -------- -------- --------\n        |     status      |   acknowledge   |\n        -------- -------- -------- --------\n        |     length      |      req_id     |\n        -------- -------- -------- --------\n\n        Add the data length\n        Number of valid data bytes in this message, not including this header. This\n        represents the number of bytes of payload appended after this header */\n\n        proto_tree_add_item(ccd_tree, hf_u3v_length, tvb, offset, 2, ENC_LITTLE_ENDIAN);\n        data_length = tvb_get_letohs(tvb, offset);\n        offset += 2;\n\n        /* Add the request ID */\n        proto_tree_add_item(ccd_tree, hf_u3v_request_id, tvb, offset, 2, ENC_LITTLE_ENDIAN);\n        req_id = tvb_get_letohs(tvb, offset);\n        offset += 2;\n\n        /* Add telegram subtree */\n        u3v_telegram_tree = proto_item_add_subtree(u3v_tree, ett_u3v);\n\n        if (!PINFO_FD_VISITED(pinfo)) {\n              if ((command_id % 2) == 0) {\n                    /* This is a command */\n                    gencp_trans = wmem_new0(wmem_file_scope(), gencp_transaction_t);\n                    gencp_trans->cmd_frame = pinfo->fd->num;\n                    gencp_trans->ack_frame = 0;\n                    gencp_trans->cmd_time = pinfo->abs_ts;\n                    /* add reference to current packet */\n                    p_add_proto_data(wmem_file_scope(), pinfo, proto_u3v, req_id, gencp_trans);\n                    /* add reference to current */\n                    u3v_conv_info->trans_info = gencp_trans;\n                } else {\n                    gencp_trans = u3v_conv_info->trans_info;\n                    if (gencp_trans) {\n                        gencp_trans->ack_frame = pinfo->fd->num;\n                        /* add reference to current packet */\n                        p_add_proto_data(wmem_file_scope(), pinfo, proto_u3v, req_id, gencp_trans);\n                    }\n                }\n         } else {\n            gencp_trans = (gencp_transaction_t*)p_get_proto_data(wmem_file_scope(),pinfo, proto_u3v, req_id);\n         }\n\n        if (!gencp_trans) {\n            /* create a \"fake\" gencp_trans structure */\n            gencp_trans = wmem_new0(pinfo->pool, gencp_transaction_t);\n            gencp_trans->cmd_frame = 0;\n            gencp_trans->ack_frame = 0;\n            gencp_trans->cmd_time = pinfo->abs_ts;\n        }\n\n        /* dissect depending on command? */\n        switch (command_id) {\n        case U3V_READMEM_CMD:\n            dissect_u3v_read_mem_cmd(u3v_telegram_tree, tvb, pinfo, offset, data_length,u3v_conv_info,gencp_trans);\n            break;\n        case U3V_WRITEMEM_CMD:\n            dissect_u3v_write_mem_cmd(u3v_telegram_tree, tvb, pinfo, offset, data_length,u3v_conv_info,gencp_trans);\n            break;\n        case U3V_EVENT_CMD:\n            dissect_u3v_event_cmd(u3v_telegram_tree, tvb, pinfo, offset, data_length);\n            break;\n        case U3V_READMEM_ACK:\n            if ( U3V_STATUS_GENCP_SUCCESS == status ) {\n                dissect_u3v_read_mem_ack(u3v_telegram_tree, tvb, pinfo, offset, data_length,u3v_conv_info,gencp_trans);\n            }\n            break;\n        case U3V_WRITEMEM_ACK:\n            dissect_u3v_write_mem_ack(u3v_telegram_tree, tvb, pinfo, offset, data_length, u3v_conv_info,gencp_trans);\n            break;\n        case U3V_PENDING_ACK:\n            dissect_u3v_pending_ack(u3v_telegram_tree, tvb, pinfo, offset, data_length, u3v_conv_info,gencp_trans);\n            break;\n        default:\n            proto_tree_add_item(u3v_telegram_tree, hf_u3v_payloaddata, tvb, offset, data_length, ENC_NA);\n            break;\n        }\n        return data_length + 12;\n    } else if ( stream_detected ) {\n        /* this is streaming data */\n\n        /* init this stream configuration */\n        u3v_conv_info = (u3v_conv_info_t *)urb->conv->class_data;\n        u3v_conv_info->ep_stream = urb->endpoint;\n\n        /* Set the protocol column */\n        col_set_str(pinfo->cinfo, COL_PROTOCOL, \"U3V\");\n\n        /* Clear out stuff in the info column */\n        col_clear(pinfo->cinfo, COL_INFO);\n\n        /* Adds \"USB3Vision\" heading to protocol tree */\n        /* We will add fields to this using the u3v_tree pointer */\n        ti = proto_tree_add_item(tree, proto_u3v, tvb, offset, -1, ENC_NA);\n        u3v_tree = proto_item_add_subtree(ti, ett_u3v);\n\n        if(tvb_captured_length(tvb) >=4) {\n            prefix = tvb_get_letohl(tvb, offset);\n            switch (prefix) {\n            case U3V_STREAM_LEADER_PREFIX:\n                dissect_u3v_stream_leader(u3v_tree, tvb, pinfo, urb);\n                break;\n            case U3V_STREAM_TRAILER_PREFIX:\n                dissect_u3v_stream_trailer(u3v_tree, tvb, pinfo, urb);\n                break;\n            default:\n                dissect_u3v_stream_payload(u3v_tree, tvb, pinfo, urb);\n                break;\n            }\n        }\n        return tvb_captured_length(tvb);\n    }\n    return 0;\n}\n\n\nstatic bool\ndissect_u3v_heur(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)\n{\n    uint32_t prefix;\n    urb_info_t *urb;\n\n    /* all control and meta data packets of U3V contain at least the prefix */\n    if (tvb_reported_length(tvb) < 4)\n        return false;\n    prefix = tvb_get_letohl(tvb, 0);\n\n    /* check if stream endpoint has been already set up for this conversation */\n    urb = (urb_info_t *)data;\n    if (!urb || !urb->conv)\n        return false;\n\n    /* either right prefix or the endpoint of the interface descriptor\n       set the correct class and subclass */\n    if ((U3V_STREAM_LEADER_PREFIX  == prefix) || (U3V_STREAM_TRAILER_PREFIX == prefix) ||\n        (U3V_CONTROL_PREFIX        == prefix) || (U3V_EVENT_PREFIX          == prefix) ||\n        ((urb->conv->interfaceClass == IF_CLASS_MISCELLANEOUS &&\n          urb->conv->interfaceSubclass == IF_SUBCLASS_MISC_U3V))) {\n        dissect_u3v(tvb, pinfo, tree, data);\n        return true;\n    }\n\n    return false;\n}\n\nstatic int\ndissect_u3v_descriptors(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, void *data _U_)\n{\n    uint8_t         type;\n    int             offset = 0;\n    proto_item *    ti;\n    proto_tree *    sub_tree;\n    uint32_t        version;\n\n\n    /* The descriptor must at least have a length and type field. */\n    if (tvb_reported_length(tvb) < 2) {\n        return 0;\n    }\n\n    /* skip len */\n    type = tvb_get_uint8(tvb, 1);\n\n    /* Check for U3V device info descriptor. */\n    if (type != DESCRIPTOR_TYPE_U3V_INTERFACE) {\n        return 0;\n    }\n\n    ti = proto_tree_add_item(tree, hf_u3v_device_info_descriptor, tvb, offset, -1, ENC_NA);\n    tree = proto_item_add_subtree(ti, ett_u3v_device_info_descriptor);\n\n    /* bLength */\n    proto_tree_add_item(tree, hf_u3v_device_info_descriptor_bLength, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    offset++;\n\n    /* bDescriptorType */\n    ti = proto_tree_add_item(tree, hf_u3v_device_info_descriptor_bDescriptorType, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    proto_item_append_text(ti, \" (U3V INTERFACE)\");\n    offset++;\n\n    /* bDescriptorSubtype */\n    proto_tree_add_item(tree, hf_u3v_device_info_descriptor_bDescriptorSubtype, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    offset++;\n\n    /* bGenCPVersion */\n    if (!tvb_bytes_exist(tvb, offset, 4)) {\n        /* Version not completely in buffer -> break dissection here. */\n        return offset;\n    }\n    version = tvb_get_letohl(tvb, offset);\n    ti = proto_tree_add_item(tree, hf_u3v_device_info_descriptor_bGenCPVersion, tvb, offset, 4, ENC_NA);\n    proto_item_append_text(ti, \": %u.%u\", version >> 16, version & 0xFFFF);\n    sub_tree = proto_item_add_subtree(ti, ett_u3v_device_info_descriptor_gencp_version);\n    proto_tree_add_item(sub_tree, hf_u3v_device_info_descriptor_bGenCPVersion_minor, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n    proto_tree_add_item(sub_tree, hf_u3v_device_info_descriptor_bGenCPVersion_major, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n    offset += 4;\n\n    /* bU3VVersion */\n    if (!tvb_bytes_exist(tvb, offset, 4)) {\n        /* Version not completely in buffer -> break dissection here. */\n        return offset;\n    }\n    version = tvb_get_letohl(tvb, offset);\n    ti = proto_tree_add_item(tree, hf_u3v_device_info_descriptor_bU3VVersion, tvb, offset, 4, ENC_NA);\n    proto_item_append_text(ti, \": %u.%u\", version >> 16, version & 0xFFFF);\n    sub_tree = proto_item_add_subtree(ti, ett_u3v_device_info_descriptor_u3v_version);\n    proto_tree_add_item(sub_tree, hf_u3v_device_info_descriptor_bU3VVersion_minor, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n    proto_tree_add_item(sub_tree, hf_u3v_device_info_descriptor_bU3VVersion_major, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n    offset += 4;\n\n    /* iDeviceGUID */\n    proto_tree_add_item(tree, hf_u3v_device_info_descriptor_iDeviceGUID, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    offset++;\n\n    /* iVendorName */\n    proto_tree_add_item(tree, hf_u3v_device_info_descriptor_iVendorName, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    offset++;\n\n    /* iModelName */\n    proto_tree_add_item(tree, hf_u3v_device_info_descriptor_iModelName, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    offset++;\n\n    /* iFamilyName */\n    proto_tree_add_item(tree, hf_u3v_device_info_descriptor_iFamilyName, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    offset++;\n\n    /* iDeviceVersion */\n    proto_tree_add_item(tree, hf_u3v_device_info_descriptor_iDeviceVersion, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    offset++;\n\n    /* iManufacturerInfo */\n    proto_tree_add_item(tree, hf_u3v_device_info_descriptor_iManufacturerInfo, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    offset++;\n\n    /* iSerialNumber */\n    proto_tree_add_item(tree, hf_u3v_device_info_descriptor_iSerialNumber, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    offset++;\n\n    /* iUserDefinedName */\n    proto_tree_add_item(tree, hf_u3v_device_info_descriptor_iUserDefinedName, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    offset++;\n\n    /* bmSpeedSupport */\n    proto_tree_add_bitmask(tree, tvb, offset, hf_u3v_device_info_descriptor_bmSpeedSupport,\n                           ett_u3v_device_info_descriptor_speed_support, speed_support_fields, ENC_LITTLE_ENDIAN);\n\n    offset++;\n\n    return offset;\n}\n\n/*\n \\brief Structures for register dissection\n */\nstatic hf_register_info hf[] =\n{\n    /* Common U3V data */\n    { &hf_u3v_gencp_prefix,\n    { \"Prefix\", \"u3v.gencp.prefix\",\n    FT_UINT32, BASE_HEX, NULL, 0x0,\n    \"U3V GenCP Prefix\", HFILL\n    } },\n\n    { &hf_u3v_flag,\n    { \"Flags\", \"u3v.gencp.flags\",\n    FT_UINT16, BASE_HEX, NULL, 0x0,\n    \"U3V Flags\", HFILL\n    } },\n\n    { &hf_u3v_acknowledge_required_flag,\n    { \"Acknowledge Required\", \"u3v.gencp.flag.acq_required\",\n    FT_BOOLEAN, 16, NULL, 0x4000,\n    \"U3V Acknowledge Required\", HFILL\n    } },\n\n    { &hf_u3v_command_id,\n    { \"Command\", \"u3v.gencp.command_id\",\n    FT_UINT16, BASE_HEX, VALS( command_names ), 0x0,\n    \"U3V Command\", HFILL\n    } },\n\n    { &hf_u3v_length,\n    { \"Payload Length\", \"u3v.gencp.payloadlength\",\n    FT_UINT16, BASE_HEX_DEC, NULL, 0x0,\n    \"U3V Payload Length\", HFILL\n    } },\n\n    { &hf_u3v_request_id,\n    { \"Request ID\", \"u3v.gencp.req_id\",\n    FT_UINT16, BASE_HEX, NULL, 0x0,\n    \"U3V Request ID\", HFILL\n    } },\n\n    { &hf_u3v_payloaddata,\n    { \"Payload Data\", \"u3v.gencp.payloaddata\",\n    FT_BYTES, BASE_NONE, NULL, 0x0,\n    \"U3V Payload\", HFILL\n    } },\n\n    { &hf_u3v_status,\n    { \"Status\", \"u3v.gencp.status\",\n    FT_UINT16, BASE_HEX, VALS( status_names ), 0x0,\n    \"U3V Status\", HFILL\n    } },\n\n    /* Read memory */\n    { &hf_u3v_address,\n    { \"Address\", \"u3v.gencp.address\",\n    FT_UINT64, BASE_HEX, NULL, 0x0,\n    \"U3V Address\", HFILL } },\n\n    { &hf_u3v_count,\n    { \"Count\", \"u3v.gencp.count\",\n    FT_UINT16, BASE_HEX_DEC, NULL, 0x0,\n    \"U3V Count\", HFILL\n    } },\n\n    /* Event */\n\n    { &hf_u3v_eventcmd_id,\n    { \"ID\", \"u3v.cmd.event.id\",\n    FT_UINT16, BASE_HEX_DEC, VALS( event_id_names ), 0x0,\n    \"U3V Event ID\", HFILL\n    } },\n\n    { &hf_u3v_eventcmd_error_id,\n    { \"Error ID\", \"u3v.cmd.event.errorid\",\n    FT_UINT16, BASE_HEX_DEC, NULL, 0x0,\n    \"U3V Event Error ID\", HFILL\n    } },\n\n    { &hf_u3v_eventcmd_device_specific_id,\n    { \"Device Specific ID\", \"u3v.cmd.event.devicespecificid\",\n    FT_UINT16, BASE_HEX_DEC, NULL, 0x0,\n    \"U3V Event Device Specific ID\", HFILL\n    } },\n\n    { &hf_u3v_eventcmd_timestamp,\n    { \"Timestamp\", \"u3v.cmd.event.timestamp\",\n    FT_UINT64, BASE_HEX_DEC, NULL, 0x0,\n    \"U3V Event Timestamp\", HFILL\n    } },\n\n    { &hf_u3v_eventcmd_data,\n    { \"Data\", \"u3v.cmd.event.data\",\n    FT_BYTES, BASE_NONE, NULL, 0x0,\n    \"U3V Event Data\", HFILL\n    } },\n\n    /* Pending acknowledge */\n    { &hf_u3v_time_to_completion,\n    { \"Time to completion\", \"u3v.gencp.timetocompletion\",\n    FT_UINT16, BASE_DEC, NULL, 0x0,\n    \"U3V Time to completion [ms]\", HFILL\n    } },\n\n    { &hf_u3v_reserved,\n    { \"Reserved\", \"u3v.reserved\",\n    FT_BYTES, BASE_NONE, NULL, 0,\n    NULL, HFILL\n    } },\n\n    /* Custom */\n    { &hf_u3v_custom_memory_addr,\n    { \"Custom Memory Address\", \"u3v.gencp.custom_addr\",\n    FT_UINT64, BASE_HEX, NULL, 0x0,\n    \"U3V Custom Memory Address\", HFILL\n    } },\n\n    { &hf_u3v_custom_memory_data,\n    { \"Custom Memory Data\", \"u3v.gencp.custom_data\",\n    FT_BYTES, BASE_NONE, NULL, 0x0,\n    \"U3V Custom Memory Data\", HFILL\n    } },\n\n    /* Bootstrap Defines */\n    { &hf_u3v_bootstrap_GenCP_Version,\n    { \"GenCP Version\", \"u3v.bootstrap.GenCP_Version\",\n    FT_UINT32, BASE_DEC, NULL, 0x0,\n    \"Complying GenCP Version\", HFILL\n    } },\n\n    { &hf_u3v_bootstrap_Manufacturer_Name,\n    { \"Manufacturer Name\", \"u3v.bootstrap.Manufacturer_Name\",\n    FT_STRING, BASE_NONE, NULL, 0x0,\n    \"String containing the self-describing name of the manufacturer\", HFILL\n    } },\n\n    { &hf_u3v_bootstrap_Model_Name,\n    { \"Model Name\", \"u3v.bootstrap.Model_Name\",\n    FT_STRING, BASE_NONE, NULL, 0x0,\n    \"String containing the self-describing name of the device model\", HFILL\n    } },\n\n    { &hf_u3v_bootstrap_Family_Name,\n    { \"Family Name\", \"u3v.bootstrap.Family_Name\",\n    FT_STRING, BASE_NONE, NULL, 0x0,\n    \"String containing the name of the family of this device\", HFILL\n    } },\n\n    { &hf_u3v_bootstrap_Device_Version,\n    { \"Device Version\", \"u3v.bootstrap.Device_Version\",\n    FT_STRING, BASE_NONE, NULL, 0x0,\n    \"String containing the version of this device\", HFILL\n    } },\n\n    { &hf_u3v_bootstrap_Manufacturer_Info,\n    { \"Manufacturer Information\", \"u3v.bootstrap.Manufacturer_Info\",\n    FT_STRING, BASE_NONE, NULL, 0x0,\n    \"String containing additional manufacturer information\", HFILL\n    } },\n\n    { &hf_u3v_bootstrap_Serial_Number,\n    { \"Serial Number\", \"u3v.bootstrap.Serial_Number\",\n    FT_STRING, BASE_NONE, NULL, 0x0,\n    \"String containing the serial number of the device\", HFILL\n    } },\n\n    { &hf_u3v_bootstrap_User_Defined_Name,\n    { \"User Defined Name\", \"u3v.bootstrap.User_Defined_Name\",\n    FT_STRING, BASE_NONE, NULL, 0x0,\n    \"String containing the user defined name of the device\", HFILL\n    } },\n\n    { &hf_u3v_bootstrap_Device_Capability,\n    { \"Device Capabilities\", \"u3v.bootstrap.Device_Capability\",\n    FT_UINT64, BASE_DEC, NULL, 0x0,\n    \"Bit field describing the device?s capabilities\", HFILL\n    } },\n\n    { &hf_u3v_bootstrap_Maximum_Device_Response_Time,\n    { \"Device Maximum response time in ms\", \"u3v.bootstrap.Maximum_Device_Response_Time\",\n    FT_UINT32, BASE_DEC, NULL, 0x0,\n    NULL, HFILL\n    } },\n\n    { &hf_u3v_bootstrap_Manifest_Table_Address,\n    { \"Pointer to the Manifest Table\", \"u3v.bootstrap.Manifest_Table_Address\",\n    FT_UINT64, BASE_HEX, NULL, 0x0,\n    NULL, HFILL\n    } },\n\n    { &hf_u3v_bootstrap_SBRM_Address,\n    { \"Pointer to the SBRM\", \"u3v.bootstrap.SBRM_Address\",\n    FT_UINT64, BASE_HEX, NULL, 0x0,\n    \"Pointer to the Technology Specific Bootstrap Register Map\", HFILL\n    } },\n\n    { &hf_u3v_bootstrap_Device_Configuration,\n    { \"Device Configuration\", \"u3v.bootstrap.Device_Configuration\",\n    FT_UINT64, BASE_DEC, NULL, 0x0,\n    \"Bit field describing the device?s configuration\", HFILL\n    } },\n\n    { &hf_u3v_bootstrap_Heartbeat_Timeout,\n    { \"Heartbeat Timeout in ms.\", \"u3v.bootstrap.Heartbeat_Timeout\",\n    FT_UINT32, BASE_DEC, NULL, 0x0,\n    \"Heartbeat Timeout in ms. Not used for these specification.\", HFILL\n    } },\n\n    { &hf_u3v_bootstrap_Message_Channel_channel_id,\n    { \"Message channel id\", \"u3v.bootstrap.Message_Channel_channel_id\",\n    FT_UINT32, BASE_DEC, NULL, 0x0,\n    \"channel_id use for the message channel\", HFILL\n    } },\n\n    { &hf_u3v_bootstrap_Timestamp,\n    { \"Timestamp\", \"u3v.bootstrap.Timestamp\",\n    FT_UINT64, BASE_DEC, NULL, 0x0,\n    \"Current device time in ns\", HFILL\n    } },\n\n    { &hf_u3v_bootstrap_Timestamp_Latch,\n    { \"Latch Timestamp\", \"u3v.bootstrap.Timestamp_Latch\",\n    FT_UINT32, BASE_DEC, NULL, 0x0,\n    NULL, HFILL\n    } },\n\n    { &hf_u3v_bootstrap_Timestamp_Increment,\n    { \"Timestamp Increment Value\", \"u3v.bootstrap.Timestamp_Increment\",\n    FT_UINT64, BASE_DEC, NULL, 0x0,\n    NULL, HFILL\n    } },\n\n    { &hf_u3v_bootstrap_Access_Privilege,\n    { \"Access Privilege.\", \"u3v.bootstrap.Access_Privilege\",\n    FT_UINT32, BASE_DEC, NULL, 0x0,\n    \"Access Privilege. Not used for these specification.\", HFILL\n    } },\n\n    { &hf_u3v_bootstrap_Protocol_Endianness,\n    { \"Protocol Endianness\", \"u3v.bootstrap.Protocol_Endianness\",\n    FT_UINT32, BASE_DEC, NULL, 0x0,\n    \"Endianness of protocol fields and bootstrap registers. Only little endian is supported by these specification.\", HFILL\n    } },\n\n    { &hf_u3v_bootstrap_Implementation_Endianness,\n    { \"Device Endianness\", \"u3v.bootstrap.Implementation_Endianness\",\n    FT_UINT32, BASE_DEC, NULL, 0x0,\n    \"Endianness of device implementation registers.  Only little endian is supported by these specification.\", HFILL\n    } },\n\n    { &hf_u3v_bootstrap_U3V_Version,\n    { \"TL Version\", \"u3v.bootstrap.U3V_Version\",\n    FT_UINT32, BASE_DEC, NULL, 0x0,\n    \"Version of the TL specification\", HFILL\n    } },\n\n    { &hf_u3v_bootstrap_U3VCP_Capability_Register,\n    { \"Control channel capabilities\", \"u3v.bootstrap.U3VCP_Capability_Register\",\n    FT_UINT64, BASE_DEC, NULL, 0x0,\n    \"Indicates additional features on the control channel\", HFILL\n    } },\n\n    { &hf_u3v_bootstrap_U3VCP_Configuration_Register,\n    { \"Control channel configuration\", \"u3v.bootstrap.U3VCP_Configuration_Register\",\n    FT_UINT64, BASE_DEC, NULL, 0x0,\n    \"Configures additional features on the control channel\", HFILL\n    } },\n\n    { &hf_u3v_bootstrap_Maximum_Command_Transfer_Length,\n    { \"Maximum Command Transfer Length\", \"u3v.bootstrap.Maximum_Command_Transfer_Length\",\n    FT_UINT32, BASE_DEC, NULL, 0x0,\n    \"Specifies the maximum supported command transfer length of the device\", HFILL\n    } },\n\n    { &hf_u3v_bootstrap_Maximum_Acknowledge_Transfer_Length,\n    { \"Maximum Acknowledge Transfer Length\", \"u3v.bootstrap.Maximum_Acknowledge_Transfer_Length\",\n    FT_UINT32, BASE_DEC, NULL, 0x0,\n    \"Specifies the maximum supported acknowledge transfer length of the device\", HFILL\n    } },\n\n    { &hf_u3v_bootstrap_Number_of_Stream_Channels,\n    { \"Number of Stream Channels\", \"u3v.bootstrap.Number_of_Stream_Channels\",\n    FT_UINT32, BASE_DEC, NULL, 0x0,\n    \"Number of Stream Channels and its corresponding Streaming Interface Register Maps (SIRM)\", HFILL\n    } },\n\n    { &hf_u3v_bootstrap_SIRM_Address,\n    { \"Pointer to the first SIRM\", \"u3v.bootstrap.SIRM_Address\",\n    FT_UINT64, BASE_HEX, NULL, 0x0,\n    \"Pointer to the first Streaming Interface Register Map.\", HFILL\n    } },\n\n    { &hf_u3v_bootstrap_SIRM_Length,\n    { \"Length of SIRM\", \"u3v.bootstrap.SIRM_Length\",\n    FT_UINT32, BASE_HEX, NULL, 0x0,\n    \"Specifies the length of each SIRM\", HFILL\n    } },\n\n    { &hf_u3v_bootstrap_EIRM_Address,\n    { \"Pointer to the EIRM\", \"u3v.bootstrap.EIRM_Address\",\n    FT_UINT64, BASE_HEX, NULL, 0x0,\n    \"Pointer to the Event Interface Register Map.\", HFILL\n    } },\n\n    { &hf_u3v_bootstrap_EIRM_Length,\n    { \"Length of EIRM\", \"u3v.bootstrap.EIRM_Length\",\n    FT_UINT32, BASE_DEC, NULL, 0x0,\n    \"Specifies the length of the EIRM\", HFILL\n    } },\n\n    { &hf_u3v_bootstrap_IIDC2_Address,\n    { \"Pointer to the IIDC2\", \"u3v.bootstrap.IIDC2_Address\",\n    FT_UINT64, BASE_HEX, NULL, 0x0,\n    \"Pointer to the IIDC2 register set.\", HFILL\n    } },\n\n    { &hf_u3v_bootstrap_Current_Speed,\n    { \"LinkSpeed\", \"u3v.bootstrap.Current_Speed\",\n    FT_UINT32, BASE_DEC, NULL, 0x0,\n    \"Specifies the current speed of the USB link.\", HFILL\n    } },\n\n    { &hf_u3v_bootstrap_SI_Info,\n    { \"Stream Info\", \"u3v.bootstrap.SI_Info\",\n    FT_UINT32, BASE_DEC, NULL, 0x0,\n    \"Device reports information about stream interface\", HFILL\n    } },\n\n    { &hf_u3v_bootstrap_SI_Control,\n    { \"Stream Control\", \"u3v.bootstrap.SI_Control\",\n    FT_UINT32, BASE_DEC, NULL, 0x0,\n    \"Stream interface Operation Control\", HFILL\n    } },\n\n    { &hf_u3v_bootstrap_SI_Required_Payload_Size,\n    { \"Stream Max Required Payload Size\", \"u3v.bootstrap.SI_Required_Payload_Size\",\n    FT_UINT64, BASE_DEC, NULL, 0x0,\n    \"Device reports maximum payload size with current settings\", HFILL\n    } },\n\n    { &hf_u3v_bootstrap_SI_Required_Leader_Size,\n    { \"Stream Max Required Leader Size\", \"u3v.bootstrap.SI_Required_Leader_Size\",\n    FT_UINT32, BASE_DEC, NULL, 0x0,\n    \"Device reports maximum leader  size it will use\", HFILL\n    } },\n\n    { &hf_u3v_bootstrap_SI_Required_Trailer_Size,\n    { \"Stream Max Required Trailer Size\", \"u3v.bootstrap.SI_Required_Trailer_Size\",\n    FT_UINT32, BASE_DEC, NULL, 0x0,\n    \"Device reports maximum trailer  size it will use\", HFILL\n    } },\n\n    { &hf_u3v_bootstrap_SI_Maximum_Leader_Size,\n    { \"Stream Max leader size\", \"u3v.bootstrap.SI_Maximum_Leader_Size\",\n    FT_UINT32, BASE_DEC, NULL, 0x0,\n    \"Maximum leader size\", HFILL\n    } },\n\n    { &hf_u3v_bootstrap_SI_Payload_Transfer_Size,\n    { \"Stream transfer size\", \"u3v.bootstrap.SI_Payload_Transfer_Size\",\n    FT_UINT32, BASE_DEC, NULL, 0x0,\n    \"Expected Size of a single Payload Transfer\", HFILL\n    } },\n\n    { &hf_u3v_bootstrap_SI_Payload_Transfer_Count,\n    { \"Stream transfer count\", \"u3v.bootstrap.SI_Payload_Transfer_Count\",\n    FT_UINT32, BASE_DEC, NULL, 0x0,\n    \"Expected Number of Payload Transfers\", HFILL\n    } },\n\n    { &hf_u3v_bootstrap_SI_Payload_Final_Transfer1_Size,\n    { \"Stream final transfer 1 size\", \"u3v.bootstrap.SI_Payload_Final_Transfer1_Size\",\n    FT_UINT32, BASE_DEC, NULL, 0x0,\n    \"Size of first final Payload transfer\", HFILL\n    } },\n\n    { &hf_u3v_bootstrap_SI_Payload_Final_Transfer2_Size,\n    { \"Stream final transfer 2 size\", \"u3v.bootstrap.SI_Payload_Final_Transfer2_Size\",\n    FT_UINT32, BASE_DEC, NULL, 0x0,\n    \"Size of second final Payload transfer\", HFILL\n    } },\n\n    { &hf_u3v_bootstrap_SI_Maximum_Trailer_Size,\n    { \"Stream Max trailer size\", \"u3v.bootstrap.SI_Maximum_Trailer_Size\",\n    FT_UINT32, BASE_DEC, NULL, 0x0,\n    \"Maximum trailer size\", HFILL\n    } },\n\n    { &hf_u3v_bootstrap_EI_Control,\n    { \"Event Interface Control\", \"u3v.bootstrap.EI_Control\",\n    FT_UINT32, BASE_DEC, NULL, 0x0,\n    \"Event Interface Control Register\", HFILL\n    } },\n\n    { &hf_u3v_bootstrap_Maximum_Event_Transfer_Length,\n    { \"Event max Transfer size\", \"u3v.bootstrap.Maximum_Event_Transfer_Length\",\n    FT_UINT32, BASE_DEC, NULL, 0x0,\n    \"Specifies the maximum supported event command transfer length of the device.\", HFILL\n    } },\n\n    { &hf_u3v_bootstrap_Event_Test_Control,\n    { \"Event test event control\", \"u3v.bootstrap.Event_Test_Control\",\n    FT_UINT32, BASE_DEC, NULL, 0x0,\n    \"Control the generation of test events.\", HFILL\n    } },\n\n    { &hf_u3v_stream_prefix,\n    { \"Stream Prefix\", \"u3v.stream.prefix\",\n    FT_UINT32, BASE_HEX, NULL, 0,\n    \"U3V stream prefix\", HFILL\n    } },\n\n    { &hf_u3v_stream_reserved,\n    { \"Reserved\", \"u3v.stream.reserved\",\n    FT_BYTES, BASE_NONE, NULL, 0,\n    NULL, HFILL\n    } },\n\n    { &hf_u3v_stream_leader_size,\n    { \"Leader Size\", \"u3v.stream.leader_size\",\n    FT_UINT16, BASE_DEC, NULL, 0x0,\n    \"U3V stream leader size\", HFILL\n    } },\n\n    { &hf_u3v_stream_trailer_size,\n    { \"Trailer Size\", \"u3v.stream.trailer_size\",\n    FT_UINT16, BASE_DEC, NULL, 0x0,\n    \"U3V stream trailer size\", HFILL\n    } },\n\n    { &hf_u3v_stream_block_id,\n    { \"Block ID\", \"u3v.stream.block_id\",\n    FT_UINT64, BASE_DEC, NULL, 0x0,\n    \"U3V stream block id\", HFILL\n    } },\n\n    { &hf_u3v_stream_payload_type,\n    { \"Payload Type\", \"u3v.stream.payload_type\",\n    FT_UINT16, BASE_HEX, VALS( payload_type_names ), 0x0,\n    \"U3V Payload Type\", HFILL\n    } },\n\n    { &hf_u3v_stream_timestamp,\n    { \"Timestamp\", \"u3v.stream.timestamp\",\n    FT_UINT64, BASE_HEX_DEC, NULL, 0x0,\n    \"U3V Stream Timestamp\", HFILL\n    } },\n\n    { &hf_u3v_stream_pixel_format,\n    { \"Pixel Format\", \"u3v.stream.pixel_format\",\n    FT_UINT32, BASE_HEX|BASE_EXT_STRING, VALS_EXT_PTR( &pixel_format_names_ext ), 0x0,\n    \"U3V Stream Pixel Format\", HFILL\n    } },\n\n    { &hf_u3v_stream_size_x,\n    { \"Size X\", \"u3v.stream.sizex\",\n    FT_UINT32, BASE_DEC, NULL, 0x0,\n    \"U3V Stream Size X\", HFILL\n    } },\n\n    { &hf_u3v_stream_size_y,\n    { \"Size Y\", \"u3v.stream.sizey\",\n    FT_UINT32, BASE_DEC, NULL, 0x0,\n    \"U3V Stream Size Y\", HFILL\n    } },\n\n    { &hf_u3v_stream_offset_x,\n    { \"Offset X\", \"u3v.stream.offsetx\",\n    FT_UINT32, BASE_DEC, NULL, 0x0,\n    \"U3V Stream Offset X\", HFILL\n    } },\n\n    { &hf_u3v_stream_offset_y,\n    { \"Offset Y\", \"u3v.stream.offsety\",\n    FT_UINT32, BASE_DEC, NULL, 0x0,\n    \"U3V Stream Offset Y\", HFILL\n    } },\n\n    { &hf_u3v_stream_padding_x,\n    { \"Padding X\", \"u3v.stream.paddingx\",\n    FT_UINT16, BASE_DEC, NULL, 0x0,\n    \"U3V Stream Padding X\", HFILL\n    } },\n\n    { &hf_u3v_stream_chunk_layout_id,\n    { \"Chunk Layout ID\", \"u3v.stream.chunk_layout_id\",\n    FT_UINT32, BASE_HEX, NULL, 0x0,\n    \"U3V Stream Chunk Layout ID\", HFILL\n    } },\n\n    { &hf_u3v_stream_valid_payload_size,\n    { \"Valid Payload Size\", \"u3v.stream.valid_payload_size\",\n    FT_UINT64, BASE_HEX, NULL, 0x0,\n    \"U3V Stream Valid Payload Size\", HFILL\n    } },\n\n    { &hf_u3v_stream_status,\n    { \"Status\", \"u3v.stream.status\",\n    FT_UINT16, BASE_HEX, VALS( status_names ), 0x0,\n    \"U3V Stream Status\", HFILL\n    } },\n\n    { &hf_u3v_stream_data,\n    { \"Payload Data\", \"u3v.stream.data\",\n    FT_BYTES, BASE_NONE, NULL, 0x0,\n    \"U3V Stream Payload Data\", HFILL\n    } },\n\n    /* U3V device info descriptor */\n    { &hf_u3v_device_info_descriptor_bLength,\n    { \"bLength\", \"u3v.device_info.bLength\",\n    FT_UINT8, BASE_DEC, NULL, 0x0,\n    NULL, HFILL } },\n\n    { &hf_u3v_device_info_descriptor_bDescriptorType,\n    { \"bDescriptorType\", \"u3v.device_info.bDescriptorType\",\n    FT_UINT8, BASE_HEX, NULL, 0x0,\n    NULL, HFILL } },\n\n    { &hf_u3v_device_info_descriptor_bDescriptorSubtype,\n    { \"bDescriptorSubtype\", \"u3v.device_info.bDescriptorSubtype\",\n    FT_UINT8, BASE_HEX, VALS( u3v_descriptor_subtypes ), 0x0,\n    NULL, HFILL } },\n\n    { &hf_u3v_device_info_descriptor_bGenCPVersion,\n    { \"bGenCPVersion\", \"u3v.device_info.bGenCPVersion\",\n    FT_NONE, BASE_NONE, NULL, 0x0,\n    NULL, HFILL } },\n\n    { &hf_u3v_device_info_descriptor_bGenCPVersion_minor,\n    { \"Minor Version\", \"u3v.device_info.bGenCPVersion.minor\",\n    FT_UINT32, BASE_DEC, NULL, 0x0000FFFF,\n    NULL, HFILL } },\n\n    { &hf_u3v_device_info_descriptor_bGenCPVersion_major,\n    { \"Major Version\", \"u3v.device_info.bGenCPVersion.major\",\n    FT_UINT32, BASE_DEC, NULL, 0xFFFF0000,\n    NULL, HFILL } },\n\n    { &hf_u3v_device_info_descriptor_bU3VVersion,\n    { \"bU3VVersion\", \"u3v.device_info.bU3VVersion\",\n    FT_NONE, BASE_NONE, NULL, 0x0,\n    NULL, HFILL } },\n\n    { &hf_u3v_device_info_descriptor_bU3VVersion_minor,\n    { \"Minor Version\", \"u3v.device_info.bU3VVersion.minor\",\n    FT_UINT32, BASE_DEC, NULL, 0x0000FFFF,\n    NULL, HFILL } },\n\n    { &hf_u3v_device_info_descriptor_bU3VVersion_major,\n    { \"Major Version\", \"u3v.device_info.bU3VVersion.major\",\n    FT_UINT32, BASE_DEC, NULL, 0xFFFF0000,\n    NULL, HFILL } },\n\n    { &hf_u3v_device_info_descriptor_iDeviceGUID,\n    { \"iDeviceGUID\", \"u3v.device_info.iDeviceGUID\",\n    FT_UINT8, BASE_DEC, NULL, 0x0,\n    NULL, HFILL } },\n\n    { &hf_u3v_device_info_descriptor_iVendorName,\n    { \"iVendorName\", \"u3v.device_info.iVendorName\",\n    FT_UINT8, BASE_DEC, NULL, 0x0,\n    NULL, HFILL } },\n\n    { &hf_u3v_device_info_descriptor_iModelName,\n    { \"iModelName\", \"u3v.device_info.iModelName\",\n    FT_UINT8, BASE_DEC, NULL, 0x0,\n    NULL, HFILL } },\n\n    { &hf_u3v_device_info_descriptor_iFamilyName,\n    { \"iFamilyName\", \"u3v.device_info.iFamilyName\",\n    FT_UINT8, BASE_DEC, NULL, 0x0,\n    NULL, HFILL } },\n\n    { &hf_u3v_device_info_descriptor_iDeviceVersion,\n    { \"iDeviceVersion\", \"u3v.device_info.iDeviceVersion\",\n    FT_UINT8, BASE_DEC, NULL, 0x0,\n    NULL, HFILL } },\n\n    { &hf_u3v_device_info_descriptor_iManufacturerInfo,\n    { \"iManufacturerInfo\", \"u3v.device_info.iManufacturerInfo\",\n    FT_UINT8, BASE_DEC, NULL, 0x0,\n    NULL, HFILL } },\n\n    { &hf_u3v_device_info_descriptor_iSerialNumber,\n    { \"iSerialNumber\", \"u3v.device_info.iSerialNumber\",\n    FT_UINT8, BASE_DEC, NULL, 0x0,\n    NULL, HFILL } },\n\n    { &hf_u3v_device_info_descriptor_iUserDefinedName,\n    { \"iUserDefinedName\", \"u3v.device_info.iUserDefinedName\",\n    FT_UINT8, BASE_DEC, NULL, 0x0,\n    NULL, HFILL } },\n\n    { &hf_u3v_device_info_descriptor_bmSpeedSupport,\n    { \"bmSpeedSupport\", \"u3v.device_info.bmSpeedSupport\",\n    FT_UINT8, BASE_HEX, NULL, 0x0,\n    NULL, HFILL } },\n\n    { &hf_u3v_device_info_descriptor_bmSpeedSupport_low_speed,\n    { \"Low-Speed\", \"u3v.device_info.bmSpeedSupport.lowSpeed\",\n    FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x01,\n    NULL, HFILL } },\n\n    { &hf_u3v_device_info_descriptor_bmSpeedSupport_full_speed,\n    { \"Full-Speed\", \"u3v.device_info.bmSpeedSupport.fullSpeed\",\n    FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x02,\n    NULL, HFILL } },\n\n    { &hf_u3v_device_info_descriptor_bmSpeedSupport_high_speed,\n    { \"High-Speed\", \"u3v.device_info.bmSpeedSupport.highSpeed\",\n    FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x04,\n    NULL, HFILL } },\n\n    { &hf_u3v_device_info_descriptor_bmSpeedSupport_super_speed,\n    { \"Super-Speed\", \"u3v.device_info.bmSpeedSupport.superSpeed\",\n    FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x08,\n    NULL, HFILL } },\n\n    { &hf_u3v_device_info_descriptor_bmSpeedSupport_reserved,\n    { \"Reserved\", \"u3v.device_info.bmSpeedSupport.reserved\",\n    FT_UINT8, BASE_HEX, NULL, 0xF0,\n    NULL, HFILL } },\n\n    { &hf_u3v_scd_readmem_cmd,\n    { \"SCD: READMEM_CMD\", \"u3v.scd_readmem_cmd\",\n    FT_NONE, BASE_NONE, NULL, 0x0,\n    NULL, HFILL } },\n\n    { &hf_u3v_scd_writemem_cmd,\n    { \"SCD: WRITEMEM_CMD\", \"u3v.scd_writemem_cmd\",\n    FT_NONE, BASE_NONE, NULL, 0x0,\n    NULL, HFILL } },\n\n    { &hf_u3v_scd_event_cmd,\n    { \"SCD: EVENT_CMD\", \"u3v.scd_event_cmd\",\n    FT_NONE, BASE_NONE, NULL, 0x0,\n    NULL, HFILL } },\n\n    { &hf_u3v_scd_ack_readmem_ack,\n    { \"SCD: READMEM_ACK\", \"u3v.scd_ack_readmem_ack\",\n    FT_NONE, BASE_NONE, NULL, 0x0,\n    NULL, HFILL } },\n\n    { &hf_u3v_scd_writemem_ack,\n    { \"SCD: WRITEMEM_ACK\", \"u3v.scd_writemem_ack\",\n    FT_NONE, BASE_NONE, NULL, 0x0,\n    NULL, HFILL } },\n\n    { &hf_u3v_ccd_pending_ack,\n    { \"CCD: PENDING_ACK\", \"u3v.ccd_pending_ack\",\n    FT_NONE, BASE_NONE, NULL, 0x0,\n    NULL, HFILL } },\n\n    { &hf_u3v_stream_leader,\n    { \"Stream: Leader\", \"u3v.stream_leader\",\n    FT_NONE, BASE_NONE, NULL, 0x0,\n    NULL, HFILL } },\n\n    { &hf_u3v_stream_trailer,\n    { \"Stream: Trailer\", \"u3v.stream_trailer\",\n    FT_NONE, BASE_NONE, NULL, 0x0,\n    NULL, HFILL } },\n\n    { &hf_u3v_stream_payload,\n    { \"Stream: Payload\", \"u3v.stream_payload\",\n    FT_NONE, BASE_NONE, NULL, 0x0,\n    NULL, HFILL } },\n\n    { &hf_u3v_ccd_cmd,\n    { \"CCD\", \"u3v.ccd_cmd\",\n    FT_NONE, BASE_NONE, NULL, 0x0,\n    NULL, HFILL } },\n\n    { &hf_u3v_ccd_ack,\n    { \"CCD\", \"u3v.ccd_ack\",\n    FT_NONE, BASE_NONE, NULL, 0x0,\n    NULL, HFILL } },\n\n    { &hf_u3v_device_info_descriptor,\n    { \"U3V DEVICE INFO DESCRIPTOR\", \"u3v.device_info_descriptor\",\n    FT_NONE, BASE_NONE, NULL, 0x0,\n    NULL, HFILL } }\n};\n\nvoid\nproto_register_u3v(void)\n{\n    static int *ett[] = {\n        &ett_u3v,\n        &ett_u3v_cmd,\n        &ett_u3v_flags,\n        &ett_u3v_ack,\n        &ett_u3v_payload_cmd,\n        &ett_u3v_payload_ack,\n        &ett_u3v_payload_ack_subtree,\n        &ett_u3v_payload_cmd_subtree,\n        &ett_u3v_bootstrap_fields,\n        &ett_u3v_stream_leader,\n        &ett_u3v_stream_trailer,\n        &ett_u3v_stream_payload,\n        &ett_u3v_device_info_descriptor,\n        &ett_u3v_device_info_descriptor_speed_support,\n        &ett_u3v_device_info_descriptor_gencp_version,\n        &ett_u3v_device_info_descriptor_u3v_version,\n    };\n\n    proto_u3v = proto_register_protocol(\"USB 3 Vision\", \"U3V\", \"u3v\");\n    proto_register_field_array(proto_u3v, hf, array_length(hf));\n    proto_register_subtree_array(ett, array_length(ett));\n    u3v_handle = register_dissector(\"u3v\", dissect_u3v, proto_u3v);\n}\n\n\n\nvoid\nproto_reg_handoff_u3v(void)\n{\n    dissector_handle_t u3v_descr_handle = NULL;\n\n    dissector_add_uint(\"usb.bulk\", IF_CLASS_MISCELLANEOUS, u3v_handle);\n    heur_dissector_add(\"usb.bulk\", dissect_u3v_heur, \"USB3Vision Protocol\", \"u3v\", proto_u3v,HEURISTIC_ENABLE);\n    u3v_descr_handle = create_dissector_handle(dissect_u3v_descriptors, proto_u3v);\n    dissector_add_uint(\"usb.descriptor\", IF_CLASS_MISCELLANEOUS, u3v_descr_handle);\n}\n\n/*\n * Editor modelines  -  https://www.wireshark.org/tools/modelines.html\n *\n * Local variables:\n * c-basic-offset: 4\n * tab-width: 8\n * indent-tabs-mode: nil\n * End:\n *\n * vi: set shiftwidth=4 tabstop=8 expandtab:\n * :indentSize=4:tabSize=8:noTabs=true:\n */\n", "patch": "@@ -1683,6 +1683,10 @@ dissect_u3v(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)\n     if (!u3v_conv_info) {\n         u3v_conv_info = wmem_new0(wmem_file_scope(), u3v_conv_info_t);\n         usb_conv_info->class_data = u3v_conv_info;\n+        usb_conv_info->class_data_type = USB_CONV_U3V;\n+    } else if (usb_conv_info->class_data_type != USB_CONV_U3V) {\n+        /* Don't dissect if another USB type is in the conversation */\n+        return 0;\n     }\n \n     prefix = tvb_get_letohl(tvb, 0);", "file_path": "files/2016_8\\47", "file_language": "c", "file_name": "epan/dissectors/packet-u3v.c", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}, {"raw_url": "https://github.com/wireshark/wireshark/raw/2cb5985bf47bdc8bea78d28483ed224abdd33dc6/epan/dissectors/packet-usb-audio.c", "code": "/* packet-usb-audio.c\n *\n * usb audio dissector\n * Tomasz Mon 2012\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version 2\n * of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */\n\n/* the parsing of audio-specific descriptors is based on\n   USB Device Class Definition for Audio Devices, Release 2.0 and\n   USB Audio Device Class Specification for Basic Audio Devices, Release 1.0 */\n\n#include \"config.h\"\n\n#include <epan/packet.h>\n#include <epan/expert.h>\n#include <epan/reassemble.h>\n#include \"packet-usb.h\"\n\n/* XXX - we use the same macro for mpeg sections,\n         can we put this in a common include file? */\n#define USB_AUDIO_BCD44_TO_DEC(x)  ((((x)&0xf0) >> 4) * 10 + ((x)&0x0f))\n\nvoid proto_register_usb_audio(void);\nvoid proto_reg_handoff_usb_audio(void);\n\n/* protocols and header fields */\nstatic int proto_usb_audio = -1;\nstatic int hf_midi_cable_number = -1;\nstatic int hf_midi_code_index = -1;\nstatic int hf_midi_event = -1;\nstatic int hf_ac_if_desc_subtype = -1;\nstatic int hf_ac_if_hdr_ver = -1;\nstatic int hf_ac_if_hdr_total_len = -1;\nstatic int hf_ac_if_hdr_bInCollection = -1;\nstatic int hf_ac_if_hdr_if_num = -1;\nstatic int hf_ac_if_input_terminalid = -1;\nstatic int hf_ac_if_input_terminaltype = -1;\nstatic int hf_ac_if_input_assocterminal = -1;\nstatic int hf_ac_if_input_nrchannels = -1;\nstatic int hf_ac_if_input_channelconfig = -1;\nstatic int hf_ac_if_input_channelnames = -1;\nstatic int hf_ac_if_input_terminal = -1;\nstatic int hf_ac_if_output_terminalid = -1;\nstatic int hf_ac_if_output_terminaltype = -1;\nstatic int hf_ac_if_output_assocterminal = -1;\nstatic int hf_ac_if_output_sourceid = -1;\nstatic int hf_ac_if_output_terminal = -1;\nstatic int hf_ac_if_fu_unitid = -1;\nstatic int hf_ac_if_fu_sourceid = -1;\nstatic int hf_ac_if_fu_controlsize = -1;\nstatic int hf_ac_if_fu_controls = -1;\nstatic int hf_ac_if_fu_control = -1;\nstatic int hf_ac_if_fu_controls_d0 = -1;\nstatic int hf_ac_if_fu_controls_d1 = -1;\nstatic int hf_ac_if_fu_controls_d2 = -1;\nstatic int hf_ac_if_fu_controls_d3 = -1;\nstatic int hf_ac_if_fu_controls_d4 = -1;\nstatic int hf_ac_if_fu_controls_d5 = -1;\nstatic int hf_ac_if_fu_controls_d6 = -1;\nstatic int hf_ac_if_fu_controls_d7 = -1;\nstatic int hf_ac_if_fu_controls_d8 = -1;\nstatic int hf_ac_if_fu_controls_d9 = -1;\nstatic int hf_ac_if_fu_controls_rsv = -1;\nstatic int hf_ac_if_fu_ifeature = -1;\nstatic int hf_as_if_desc_subtype = -1;\nstatic int hf_as_if_gen_term_id = -1;\nstatic int hf_as_if_gen_delay = -1;\nstatic int hf_as_if_gen_format = -1;\nstatic int hf_as_if_ft_formattype = -1;\nstatic int hf_as_if_ft_maxbitrate = -1;\nstatic int hf_as_if_ft_nrchannels = -1;\nstatic int hf_as_if_ft_subframesize = -1;\nstatic int hf_as_if_ft_bitresolution = -1;\nstatic int hf_as_if_ft_samplesperframe = -1;\nstatic int hf_as_if_ft_samfreqtype = -1;\nstatic int hf_as_if_ft_lowersamfreq = -1;\nstatic int hf_as_if_ft_uppersamfreq = -1;\nstatic int hf_as_if_ft_samfreq = -1;\nstatic int hf_as_ep_desc_subtype = -1;\n\nstatic reassembly_table midi_data_reassembly_table;\n\nstatic gint ett_usb_audio      = -1;\nstatic gint ett_usb_audio_desc = -1;\n\nstatic gint ett_ac_if_fu_controls = -1;\nstatic gint ett_ac_if_fu_controls0 = -1;\nstatic gint ett_ac_if_fu_controls1 = -1;\n\nstatic dissector_handle_t sysex_handle;\n\n#define AUDIO_IF_SUBCLASS_UNDEFINED        0x00\n#define AUDIO_IF_SUBCLASS_AUDIOCONTROL     0x01\n#define AUDIO_IF_SUBCLASS_AUDIOSTREAMING   0x02\n#define AUDIO_IF_SUBCLASS_MIDISTREAMING    0x03\n\n#if 0\nstatic const value_string usb_audio_subclass_vals[] = {\n    {AUDIO_IF_SUBCLASS_UNDEFINED,          \"SUBCLASS_UNDEFINED\"},\n    {AUDIO_IF_SUBCLASS_AUDIOCONTROL,       \"AUDIOCONSTROL\"},\n    {AUDIO_IF_SUBCLASS_AUDIOSTREAMING,     \"AUDIOSTREAMING\"},\n    {AUDIO_IF_SUBCLASS_MIDISTREAMING,      \"MIDISTREAMING\"},\n    {0, NULL}\n};\n#endif\n\nstatic const value_string code_index_vals[] = {\n    { 0x0, \"Miscellaneous (Reserved)\" },\n    { 0x1, \"Cable events (Reserved)\" },\n    { 0x2, \"Two-byte System Common message\" },\n    { 0x3, \"Three-byte System Common message\" },\n    { 0x4, \"SysEx starts or continues\" },\n    { 0x5, \"SysEx ends with following single byte/Single-byte System Common Message\" },\n    { 0x6, \"SysEx ends with following two bytes\" },\n    { 0x7, \"SysEx ends with following three bytes\" },\n    { 0x8, \"Note-off\" },\n    { 0x9, \"Note-on\" },\n    { 0xA, \"Poly-KeyPress\" },\n    { 0xB, \"Control Change\" },\n    { 0xC, \"Program Change\" },\n    { 0xD, \"Channel Pressure\" },\n    { 0xE, \"PitchBend Change\" },\n    { 0xF, \"Single Byte\" },\n    { 0, NULL }\n};\n\n/* USB audio specification, section A.8 */\n#define CS_INTERFACE       0x24\n#define CS_ENDPOINT        0x25\n\nstatic const value_string aud_descriptor_type_vals[] = {\n        {CS_INTERFACE, \"audio class interface\"},\n        {CS_ENDPOINT,  \"audio class endpoint\"},\n        {0,NULL}\n};\nstatic value_string_ext aud_descriptor_type_vals_ext =\n    VALUE_STRING_EXT_INIT(aud_descriptor_type_vals);\n\n#define AC_SUBTYPE_HEADER          0x01\n#define AC_SUBTYPE_INPUT_TERMINAL  0x02\n#define AC_SUBTYPE_OUTPUT_TERMINAL 0x03\n#define AC_SUBTYPE_MIXER_UNIT      0x04\n#define AC_SUBTYPE_SELECTOR_UNIT   0x05\n#define AC_SUBTYPE_FEATURE_UNIT    0x06\n\nstatic const value_string ac_subtype_vals[] = {\n    {AC_SUBTYPE_HEADER,          \"Header Descriptor\"},\n    {AC_SUBTYPE_INPUT_TERMINAL,  \"Input terminal descriptor\"},\n    {AC_SUBTYPE_OUTPUT_TERMINAL, \"Output terminal descriptor\"},\n    {AC_SUBTYPE_MIXER_UNIT,      \"Mixer unit descriptor\"},\n    {AC_SUBTYPE_SELECTOR_UNIT,   \"Selector unit descriptor\"},\n    {AC_SUBTYPE_FEATURE_UNIT,    \"Feature unit descriptor\"},\n    {0,NULL}\n};\nstatic value_string_ext ac_subtype_vals_ext =\n    VALUE_STRING_EXT_INIT(ac_subtype_vals);\n\n#define AS_SUBTYPE_GENERAL         0x01\n#define AS_SUBTYPE_FORMAT_TYPE     0x02\n#define AS_SUBTYPE_ENCODER         0x03\n\nstatic const value_string as_subtype_vals[] = {\n    {AS_SUBTYPE_GENERAL,     \"General AS Descriptor\"},\n    {AS_SUBTYPE_FORMAT_TYPE, \"Format type descriptor\"},\n    {AS_SUBTYPE_ENCODER,     \"Encoder descriptor\"},\n    {0,NULL}\n};\nstatic value_string_ext as_subtype_vals_ext =\n    VALUE_STRING_EXT_INIT(as_subtype_vals);\n\n/* From http://www.usb.org/developers/docs/devclass_docs/termt10.pdf */\nstatic const value_string terminal_types_vals[] = {\n    /* USB Terminal Types */\n    {0x0100, \"USB Undefined\"},\n    {0x0101, \"USB Streaming\"},\n    {0x01FF, \"USB vendor specific\"},\n    /* Input Terminal Tyoes */\n    {0x0200, \"Input Undefined\"},\n    {0x0201, \"Microphone\"},\n    {0x0202, \"Desktop Microphone\"},\n    {0x0203, \"Personal microphone\"},\n    {0x0204, \"Omni-directional icrophone\"},\n    {0x0205, \"Microphone array\"},\n    {0x0206, \"Processing microphone array\"},\n    {0x0300, \"Output Undefined\"},\n    {0x0301, \"Speaker\"},\n    {0x0302, \"Headphones\"},\n    {0x0303, \"Head Mounted Display Audio\"},\n    {0x0304, \"Desktop speaker\"},\n    {0x0305, \"Room speaker\"},\n    {0x0306, \"Communication speaker\"},\n    {0x0307, \"Low frequency effects speaker\"},\n    /* Bi-directional Terminal Types */\n    {0x0400, \"Bi-directional Undefined\"},\n    {0x0401, \"Handset\"},\n    {0x0402, \"Headset\"},\n    {0x0403, \"Speakerphone, no echoreduction\"},\n    {0x0404, \"Echo-suppressing speakerphone\"},\n    {0x0405, \"Echo-canceling speakerphone\"},\n    /* Telephony Terminal Types */\n    {0x0500, \"Telephony Undefined\"},\n    {0x0501, \"Phone line\"},\n    {0x0502, \"Telephone\"},\n    {0x0503, \"Down Line Pone\"},\n    /* External Terminal Types */\n    {0x0600, \"External Undefined\"},\n    {0x0601, \"Analog connector\"},\n    {0x0602, \"Digital audio interface\"},\n    {0x0603, \"Line connector\"},\n    {0x0604, \"Legacy audio connector\"},\n    {0x0605, \"S/PDIF interface\"},\n    {0x0606, \"1394 DA stream\"},\n    {0x0607, \"1394 DV stream soudtrack\"},\n    /* Embedded Funciton Terminal Types */\n    {0x0700, \"Embedded Undefined\"},\n    {0x0701, \"Level Calibration Noise Source\"},\n    {0x0702, \"Equalization Noise\"},\n    {0x0703, \"CD player\"},\n    {0x0704, \"DAT\"},\n    {0x0705, \"DCC\"},\n    {0x0706, \"MiniDisk\"},\n    {0x0707, \"Analog Tape\"},\n    {0x0708, \"Phonograph\"},\n    {0x0709, \"VCR Audio\"},\n    {0x070A, \"Video Disc Audio\"},\n    {0x070B, \"DVD Audio\"},\n    {0x070C, \"TV Tuner Audio\"},\n    {0x070D, \"Satellite Receiver Audio\"},\n    {0x070E, \"cable Tuner Audio\"},\n    {0x070F, \"DSS Audio\"},\n    {0x0710, \"Radio Receiver\"},\n    {0x0711, \"Radio Transmitter\"},\n    {0x0712, \"Multi-track Recorder\"},\n    {0x0713, \"Synthesizer\"},\n    {0,NULL}\n};\nstatic value_string_ext terminal_types_vals_ext =\n    VALUE_STRING_EXT_INIT(terminal_types_vals);\n\ntypedef struct _audio_conv_info_t {\n    /* the major version of the USB audio class specification,\n       taken from the AC header descriptor */\n    guint8 ver_major;\n} audio_conv_info_t;\n\nstatic int hf_sysex_msg_fragments = -1;\nstatic int hf_sysex_msg_fragment = -1;\nstatic int hf_sysex_msg_fragment_overlap = -1;\nstatic int hf_sysex_msg_fragment_overlap_conflicts = -1;\nstatic int hf_sysex_msg_fragment_multiple_tails = -1;\nstatic int hf_sysex_msg_fragment_too_long_fragment = -1;\nstatic int hf_sysex_msg_fragment_error = -1;\nstatic int hf_sysex_msg_fragment_count = -1;\nstatic int hf_sysex_msg_reassembled_in = -1;\nstatic int hf_sysex_msg_reassembled_length = -1;\nstatic int hf_sysex_msg_reassembled_data = -1;\n\nstatic gint ett_sysex_msg_fragment = -1;\nstatic gint ett_sysex_msg_fragments = -1;\n\nstatic expert_field ei_usb_audio_undecoded = EI_INIT;\n\nstatic const fragment_items sysex_msg_frag_items = {\n    /* Fragment subtrees */\n    &ett_sysex_msg_fragment,\n    &ett_sysex_msg_fragments,\n    /* Fragment fields */\n    &hf_sysex_msg_fragments,\n    &hf_sysex_msg_fragment,\n    &hf_sysex_msg_fragment_overlap,\n    &hf_sysex_msg_fragment_overlap_conflicts,\n    &hf_sysex_msg_fragment_multiple_tails,\n    &hf_sysex_msg_fragment_too_long_fragment,\n    &hf_sysex_msg_fragment_error,\n    &hf_sysex_msg_fragment_count,\n    /* Reassembled in field */\n    &hf_sysex_msg_reassembled_in,\n    /* Reassembled length field */\n    &hf_sysex_msg_reassembled_length,\n    &hf_sysex_msg_reassembled_data,\n    /* Tag */\n    \"Message fragments\"\n};\n\nstatic inline gboolean\nis_sysex_code(guint8 code)\n{\n    return (code == 0x04 || code == 0x05 || code == 0x06 || code == 0x07);\n}\n\nstatic gboolean\nis_last_sysex_packet_in_tvb(tvbuff_t *tvb, gint offset)\n{\n    gboolean last   = TRUE;\n    gint     length = tvb_reported_length(tvb);\n\n    offset += 4;\n    while (offset < length)\n    {\n        guint8 code = tvb_get_guint8(tvb, offset);\n        code &= 0x0F;\n\n        if (is_sysex_code(code))\n        {\n            last = FALSE;\n            break;\n        }\n\n        offset += 4;\n    }\n\n    return last;\n}\n\nstatic void\ndissect_usb_midi_event(tvbuff_t *tvb, packet_info *pinfo,\n                       proto_tree *usb_audio_tree, proto_tree *parent_tree,\n                       gint offset)\n{\n    guint8      code;\n    guint8      cable;\n    gboolean    save_fragmented;\n    proto_tree *tree = NULL;\n\n    col_set_str(pinfo->cinfo, COL_INFO, \"USB-MIDI Event Packets\");\n\n    code = tvb_get_guint8(tvb, offset);\n    cable = (code & 0xF0) >> 4;\n    code &= 0x0F;\n\n    if (parent_tree)\n    {\n        proto_item *ti;\n\n        ti = proto_tree_add_protocol_format(usb_audio_tree, proto_usb_audio, tvb, offset, 4, \"USB Midi Event Packet\");\n        tree = proto_item_add_subtree(ti, ett_usb_audio);\n        proto_tree_add_item(tree, hf_midi_cable_number, tvb, offset, 1, ENC_BIG_ENDIAN);\n        proto_tree_add_item(tree, hf_midi_code_index, tvb, offset, 1, ENC_BIG_ENDIAN);\n        proto_tree_add_item(tree, hf_midi_event, tvb, offset+1, 3, ENC_BIG_ENDIAN);\n    }\n\n    save_fragmented = pinfo->fragmented;\n\n    /* Reassemble SysEx commands */\n    if (is_sysex_code(code))\n    {\n        tvbuff_t* new_tvb = NULL;\n        fragment_head *frag_sysex_msg = NULL;\n\n        pinfo->fragmented = TRUE;\n\n        if (code == 0x04)\n        {\n            frag_sysex_msg = fragment_add_seq_next(&midi_data_reassembly_table,\n                tvb, offset+1,\n                pinfo,\n                cable, /* ID for fragments belonging together */\n                NULL,\n                3,\n                TRUE);\n        }\n        else\n        {\n            frag_sysex_msg = fragment_add_seq_next(&midi_data_reassembly_table,\n                tvb, offset+1,\n                pinfo,\n                cable, /* ID for fragments belonging together */\n                NULL,\n                (gint)(code - 4),\n                FALSE);\n        }\n\n        if (is_last_sysex_packet_in_tvb(tvb, offset))\n        {\n            new_tvb = process_reassembled_data(tvb, offset+1, pinfo,\n                \"Reassembled Message\", frag_sysex_msg, &sysex_msg_frag_items,\n                NULL, usb_audio_tree);\n\n            if (code != 0x04) { /* Reassembled */\n                col_append_str(pinfo->cinfo, COL_INFO,\n                        \" (SysEx Reassembled)\");\n            } else { /* Not last packet of reassembled Short Message */\n                col_append_str(pinfo->cinfo, COL_INFO,\n                        \" (SysEx fragment)\");\n            }\n\n            if (new_tvb)\n            {\n                call_dissector(sysex_handle, new_tvb, pinfo, parent_tree);\n            }\n        }\n    }\n\n    pinfo->fragmented = save_fragmented;\n}\n\n\n/* dissect the body of an AC interface header descriptor\n   return the number of bytes dissected (which may be smaller than the\n   body's length) */\nstatic gint\ndissect_ac_if_hdr_body(tvbuff_t *tvb, gint offset, packet_info *pinfo _U_,\n        proto_tree *tree, usb_conv_info_t *usb_conv_info)\n{\n    gint     offset_start;\n    guint16  bcdADC;\n    guint8   ver_major;\n    double   ver;\n    guint8   if_in_collection, i;\n    audio_conv_info_t *audio_conv_info;\n\n\n    offset_start = offset;\n\n    bcdADC = tvb_get_letohs(tvb, offset);\n    ver_major = USB_AUDIO_BCD44_TO_DEC(bcdADC>>8);\n    ver = ver_major + USB_AUDIO_BCD44_TO_DEC(bcdADC&0xFF) / 100.0;\n\n    proto_tree_add_double_format_value(tree, hf_ac_if_hdr_ver,\n            tvb, offset, 2, ver, \"%2.2f\", ver);\n    audio_conv_info = (audio_conv_info_t *)usb_conv_info->class_data;\n    if(!audio_conv_info) {\n        audio_conv_info = wmem_new(wmem_file_scope(), audio_conv_info_t);\n        usb_conv_info->class_data = audio_conv_info;\n        usb_conv_info->class_data_type = USB_CONV_AUDIO;\n        /* XXX - set reasonable default values for all components\n           that are not filled in by this function */\n    } else if (usb_conv_info->class_data_type != USB_CONV_AUDIO) {\n        /* Don't dissect if another USB type is in the conversation */\n        return 0;\n    }\n    audio_conv_info->ver_major = ver_major;\n    offset += 2;\n\n    /* version 1 refers to the Basic Audio Device specification,\n       version 2 is the Audio Device class specification, see above */\n    if (ver_major==1) {\n        proto_tree_add_item(tree, hf_ac_if_hdr_total_len,\n                tvb, offset, 2, ENC_LITTLE_ENDIAN);\n        offset += 2;\n        if_in_collection = tvb_get_guint8(tvb, offset);\n        proto_tree_add_item(tree, hf_ac_if_hdr_bInCollection,\n                tvb, offset, 1, ENC_LITTLE_ENDIAN);\n        offset++;\n\n        for (i=0; i<if_in_collection; i++) {\n            proto_tree_add_item(tree, hf_ac_if_hdr_if_num,\n                    tvb, offset, 1, ENC_LITTLE_ENDIAN);\n            offset++;\n        }\n    }\n\n    return offset-offset_start;\n}\n\nstatic gint\ndissect_ac_if_input_terminal(tvbuff_t *tvb, gint offset, packet_info *pinfo _U_,\n        proto_tree *tree, usb_conv_info_t *usb_conv_info _U_)\n{\n    gint     offset_start;\n    offset_start = offset;\n\n    proto_tree_add_item(tree, hf_ac_if_input_terminalid, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    offset += 1;\n\n    proto_tree_add_item(tree, hf_ac_if_input_terminaltype, tvb, offset, 2, ENC_LITTLE_ENDIAN);\n    offset += 2;\n\n    proto_tree_add_item(tree, hf_ac_if_input_assocterminal, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    offset += 1;\n\n    proto_tree_add_item(tree, hf_ac_if_input_nrchannels, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    offset += 1;\n\n    proto_tree_add_item(tree, hf_ac_if_input_channelconfig, tvb, offset, 2, ENC_LITTLE_ENDIAN);\n    offset += 2;\n\n    proto_tree_add_item(tree, hf_ac_if_input_channelnames, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    offset += 1;\n\n    proto_tree_add_item(tree, hf_ac_if_input_terminal, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    offset += 1;\n\n    return offset-offset_start;\n}\n\nstatic gint\ndissect_ac_if_output_terminal(tvbuff_t *tvb, gint offset, packet_info *pinfo _U_,\n        proto_tree *tree, usb_conv_info_t *usb_conv_info _U_)\n{\n    gint     offset_start;\n    offset_start = offset;\n\n    proto_tree_add_item(tree, hf_ac_if_output_terminalid, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    offset += 1;\n\n    proto_tree_add_item(tree, hf_ac_if_output_terminaltype, tvb, offset, 2, ENC_LITTLE_ENDIAN);\n    offset += 2;\n\n    proto_tree_add_item(tree, hf_ac_if_output_assocterminal, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    offset += 1;\n\n    proto_tree_add_item(tree, hf_ac_if_output_sourceid, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    offset += 1;\n\n    proto_tree_add_item(tree, hf_ac_if_output_terminal, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    offset += 1;\n\n    return offset-offset_start;\n}\n\nstatic gint\ndissect_ac_if_feature_unit(tvbuff_t *tvb, gint offset, packet_info *pinfo _U_,\n        proto_tree *tree, usb_conv_info_t *usb_conv_info _U_)\n{\n    gint     offset_start;\n    guint8 controlsize;\n    proto_tree *bitmap_tree;\n    proto_item *ti;\n\n    static const int *fu_controls0[] = {\n        &hf_ac_if_fu_controls_d0,\n        &hf_ac_if_fu_controls_d1,\n        &hf_ac_if_fu_controls_d2,\n        &hf_ac_if_fu_controls_d3,\n        &hf_ac_if_fu_controls_d4,\n        &hf_ac_if_fu_controls_d5,\n        &hf_ac_if_fu_controls_d6,\n        &hf_ac_if_fu_controls_d7,\n        NULL };\n\n    static const int *fu_controls1[] = {\n        &hf_ac_if_fu_controls_d8,\n        &hf_ac_if_fu_controls_d9,\n        &hf_ac_if_fu_controls_rsv,\n        NULL };\n\n    offset_start = offset;\n\n    proto_tree_add_item(tree, hf_ac_if_fu_unitid, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    offset += 1;\n\n    proto_tree_add_item(tree, hf_ac_if_fu_sourceid, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    offset += 1;\n\n    proto_tree_add_item(tree, hf_ac_if_fu_controlsize, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    controlsize = tvb_get_guint8(tvb, offset) + 1;\n    offset += 1;\n\n    ti = proto_tree_add_item(tree, hf_ac_if_fu_controls, tvb, offset, controlsize, ENC_NA);\n    bitmap_tree = proto_item_add_subtree(ti, ett_ac_if_fu_controls);\n\n    proto_tree_add_bitmask(bitmap_tree, tvb, offset, hf_ac_if_fu_control, ett_ac_if_fu_controls0, fu_controls0, ENC_LITTLE_ENDIAN);\n\n    if(controlsize >= 1){\n        proto_tree_add_bitmask(bitmap_tree, tvb, offset + 1, hf_ac_if_fu_control, ett_ac_if_fu_controls1, fu_controls1, ENC_LITTLE_ENDIAN);\n    }\n\n    offset += controlsize;\n\n    proto_tree_add_item(tree, hf_ac_if_fu_ifeature, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    offset += 1;\n\n    return offset-offset_start;\n}\n\nstatic gint\ndissect_as_if_general_body(tvbuff_t *tvb, gint offset, packet_info *pinfo _U_,\n        proto_tree *tree, usb_conv_info_t *usb_conv_info)\n{\n    audio_conv_info_t *audio_conv_info;\n    gint               offset_start;\n\n    /* the caller has already checked that usb_conv_info!=NULL */\n    audio_conv_info = (audio_conv_info_t *)usb_conv_info->class_data;\n    if (!audio_conv_info)\n        return 0;\n\n    offset_start = offset;\n\n    if (audio_conv_info->ver_major==1) {\n        proto_tree_add_item(tree, hf_as_if_gen_term_id,\n                tvb, offset, 1, ENC_LITTLE_ENDIAN);\n        offset++;\n        proto_tree_add_item(tree, hf_as_if_gen_delay,\n                tvb, offset, 1, ENC_LITTLE_ENDIAN);\n        offset++;\n        proto_tree_add_item(tree, hf_as_if_gen_format,\n                tvb, offset, 2, ENC_LITTLE_ENDIAN);\n        offset += 2;\n    }\n\n    return offset-offset_start;\n}\n\nstatic gint\ndissect_as_if_format_type_body(tvbuff_t *tvb, gint offset, packet_info *pinfo _U_,\n        proto_tree *tree, usb_conv_info_t *usb_conv_info)\n{\n    audio_conv_info_t *audio_conv_info;\n    gint               offset_start;\n    guint8 SamFreqType;\n    guint8 format_type;\n\n    /* the caller has already checked that usb_conv_info!=NULL */\n    audio_conv_info = (audio_conv_info_t *)usb_conv_info->class_data;\n    if (!audio_conv_info)\n        return 0;\n\n    offset_start = offset;\n\n    proto_tree_add_item(tree, hf_as_if_ft_formattype, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    format_type = tvb_get_guint8(tvb, offset);\n    offset++;\n\n\n    switch(format_type){\n        case 1:\n            proto_tree_add_item(tree, hf_as_if_ft_nrchannels, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n            offset += 1;\n\n            proto_tree_add_item(tree, hf_as_if_ft_subframesize, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n            offset += 1;\n\n            proto_tree_add_item(tree, hf_as_if_ft_bitresolution, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n            offset += 1;\n\n            proto_tree_add_item(tree, hf_as_if_ft_samfreqtype, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n            SamFreqType = tvb_get_guint8(tvb, offset);\n            offset++;\n\n            if(SamFreqType == 0){\n                proto_tree_add_item(tree, hf_as_if_ft_lowersamfreq, tvb, offset, 3, ENC_LITTLE_ENDIAN);\n                offset += 3;\n                proto_tree_add_item(tree, hf_as_if_ft_uppersamfreq, tvb, offset, 3, ENC_LITTLE_ENDIAN);\n                offset += 3;\n            }else {\n                while(SamFreqType){\n                    proto_tree_add_item(tree, hf_as_if_ft_samfreq, tvb, offset, 3, ENC_LITTLE_ENDIAN);\n                    offset += 3;\n                    SamFreqType--;\n                }\n            }\n        break;\n        case 2:\n            proto_tree_add_item(tree, hf_as_if_ft_maxbitrate, tvb, offset, 2, ENC_LITTLE_ENDIAN);\n            offset += 2;\n\n            proto_tree_add_item(tree, hf_as_if_ft_samplesperframe, tvb, offset, 2, ENC_LITTLE_ENDIAN);\n            offset += 2;\n\n            proto_tree_add_item(tree, hf_as_if_ft_samfreqtype, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n            SamFreqType = tvb_get_guint8(tvb, offset);\n            offset++;\n\n            if(SamFreqType == 0){\n                proto_tree_add_item(tree, hf_as_if_ft_lowersamfreq, tvb, offset, 3, ENC_LITTLE_ENDIAN);\n                offset += 3;\n                proto_tree_add_item(tree, hf_as_if_ft_uppersamfreq, tvb, offset, 3, ENC_LITTLE_ENDIAN);\n                offset += 3;\n            }else {\n                while(SamFreqType){\n                    proto_tree_add_item(tree, hf_as_if_ft_samfreq, tvb, offset, 3, ENC_LITTLE_ENDIAN);\n                    offset += 3;\n                    SamFreqType--;\n                }\n            }\n        break;\n        default:\n        break;\n    }\n\n    return offset-offset_start;\n}\n\nstatic gint\ndissect_usb_audio_descriptor(tvbuff_t *tvb, packet_info *pinfo,\n        proto_tree *tree, void *data)\n{\n    gint             offset = 0;\n    usb_conv_info_t *usb_conv_info;\n    proto_tree       *desc_tree = NULL;\n    proto_item       *desc_tree_item;\n    guint8           desc_len;\n    guint8           desc_type;\n    guint8           desc_subtype;\n    const gchar     *subtype_str;\n\n    usb_conv_info = (usb_conv_info_t *)data;\n    if (!usb_conv_info || usb_conv_info->interfaceClass!=IF_CLASS_AUDIO)\n        return 0;\n\n    desc_len  = tvb_get_guint8(tvb, offset);\n    desc_type = tvb_get_guint8(tvb, offset+1);\n\n    if (desc_type==CS_INTERFACE &&\n            usb_conv_info->interfaceSubclass==AUDIO_IF_SUBCLASS_AUDIOCONTROL) {\n\n        desc_tree = proto_tree_add_subtree(tree, tvb, offset, desc_len,\n                ett_usb_audio_desc, &desc_tree_item,\n                \"Class-specific Audio Control Interface Descriptor\");\n\n        dissect_usb_descriptor_header(desc_tree, tvb, offset,\n            &aud_descriptor_type_vals_ext);\n        offset += 2;\n\n        desc_subtype = tvb_get_guint8(tvb, offset);\n        proto_tree_add_item(desc_tree, hf_ac_if_desc_subtype,\n                tvb, offset, 1, ENC_LITTLE_ENDIAN);\n        subtype_str = try_val_to_str_ext(desc_subtype, &ac_subtype_vals_ext);\n        if (subtype_str)\n            proto_item_append_text(desc_tree_item, \": %s\", subtype_str);\n        offset++;\n\n        switch(desc_subtype) {\n            case AC_SUBTYPE_HEADER:\n                /* these subfunctions return the number of bytes dissected,\n                   this is not necessarily the length of the body\n                   as some components are not yet dissected\n                   we rely on the descriptor's length byte instead */\n                dissect_ac_if_hdr_body(tvb, offset, pinfo, desc_tree, usb_conv_info);\n                break;\n            case AC_SUBTYPE_INPUT_TERMINAL:\n                dissect_ac_if_input_terminal(tvb, offset, pinfo, desc_tree, usb_conv_info);\n                break;\n            case AC_SUBTYPE_OUTPUT_TERMINAL:\n                dissect_ac_if_output_terminal(tvb, offset, pinfo, desc_tree, usb_conv_info);\n                break;\n            case AC_SUBTYPE_FEATURE_UNIT:\n                dissect_ac_if_feature_unit(tvb, offset, pinfo, desc_tree, usb_conv_info);\n                break;\n            default:\n                proto_tree_add_expert(desc_tree, pinfo, &ei_usb_audio_undecoded, tvb, offset-3, desc_len);\n                break;\n        }\n\n    }\n    else if (desc_type==CS_INTERFACE &&\n            usb_conv_info->interfaceSubclass==AUDIO_IF_SUBCLASS_AUDIOSTREAMING) {\n\n        desc_tree = proto_tree_add_subtree(tree, tvb, offset, desc_len,\n                ett_usb_audio_desc, &desc_tree_item,\n                \"Class-specific Audio Streaming Interface Descriptor\");\n\n        dissect_usb_descriptor_header(desc_tree, tvb, offset,\n            &aud_descriptor_type_vals_ext);\n        offset += 2;\n\n        desc_subtype = tvb_get_guint8(tvb, offset);\n        proto_tree_add_item(desc_tree, hf_as_if_desc_subtype,\n                tvb, offset, 1, ENC_LITTLE_ENDIAN);\n        subtype_str = try_val_to_str_ext(desc_subtype, &as_subtype_vals_ext);\n        if (subtype_str)\n            proto_item_append_text(desc_tree_item, \": %s\", subtype_str);\n        offset++;\n\n        switch(desc_subtype) {\n            case AS_SUBTYPE_GENERAL:\n                dissect_as_if_general_body(tvb, offset, pinfo,\n                        desc_tree, usb_conv_info);\n                break;\n            case AS_SUBTYPE_FORMAT_TYPE:\n                dissect_as_if_format_type_body(tvb, offset, pinfo,\n                        desc_tree, usb_conv_info);\n                break;\n            default:\n                proto_tree_add_expert(desc_tree, pinfo, &ei_usb_audio_undecoded, tvb, offset-3, desc_len);\n                break;\n        }\n    }\n    /* there are no class-specific endpoint descriptors for audio control */\n    else if (desc_type == CS_ENDPOINT &&\n            usb_conv_info->interfaceSubclass==AUDIO_IF_SUBCLASS_AUDIOSTREAMING) {\n\n        desc_tree = proto_tree_add_subtree(tree, tvb, offset, desc_len,\n                ett_usb_audio_desc, &desc_tree_item,\n                \"Class-specific Audio Streaming Endpoint Descriptor\");\n\n        dissect_usb_descriptor_header(desc_tree, tvb, offset,\n            &aud_descriptor_type_vals_ext);\n        offset += 2;\n\n        proto_tree_add_item(desc_tree, hf_as_ep_desc_subtype,\n                tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    }\n    else\n        return 0;\n\n    return desc_len;\n}\n\n\n/* dissector for usb midi bulk data */\nstatic int\ndissect_usb_audio_bulk(tvbuff_t *tvb, packet_info *pinfo, proto_tree *parent_tree, void *data)\n{\n    usb_conv_info_t *usb_conv_info;\n    proto_tree      *tree;\n    proto_item      *ti;\n    gint             offset, length;\n    gint             i;\n\n    /* Reject the packet if data is NULL */\n    if (data == NULL)\n        return 0;\n    usb_conv_info = (usb_conv_info_t *)data;\n\n    col_set_str(pinfo->cinfo, COL_PROTOCOL, \"USBAUDIO\");\n\n    ti   = proto_tree_add_protocol_format(parent_tree, proto_usb_audio, tvb, 0, -1, \"USB Audio\");\n    tree = proto_item_add_subtree(ti, ett_usb_audio);\n\n    length = tvb_reported_length(tvb);\n    offset = 0;\n\n    switch (usb_conv_info->interfaceSubclass)\n    {\n        case AUDIO_IF_SUBCLASS_MIDISTREAMING:\n            col_set_str(pinfo->cinfo, COL_INFO, \"USB-MIDI Event Packets\");\n\n            for (i = 0; i < length / 4; i++)\n            {\n                dissect_usb_midi_event(tvb, pinfo, tree, parent_tree, offset);\n                offset += 4;\n            }\n            break;\n        default:\n            proto_tree_add_expert(tree, pinfo, &ei_usb_audio_undecoded, tvb, offset, length);\n    }\n\n    return length;\n}\n\nstatic void\nmidi_data_reassemble_init(void)\n{\n    reassembly_table_init(&midi_data_reassembly_table,\n                          &addresses_reassembly_table_functions);\n}\n\nstatic void\nmidi_data_reassemble_cleanup(void)\n{\n    reassembly_table_destroy(&midi_data_reassembly_table);\n}\n\nvoid\nproto_register_usb_audio(void)\n{\n    static hf_register_info hf[] = {\n        { &hf_midi_cable_number,\n            { \"Cable Number\", \"usbaudio.midi.cable_number\", FT_UINT8, BASE_HEX,\n              NULL, 0xF0, NULL, HFILL }},\n        { &hf_midi_code_index,\n            { \"Code Index\", \"usbaudio.midi.code_index\", FT_UINT8, BASE_HEX,\n              VALS(code_index_vals), 0x0F, NULL, HFILL }},\n        { &hf_midi_event,\n            { \"MIDI Event\", \"usbaudio.midi.event\", FT_UINT24, BASE_HEX,\n              NULL, 0, NULL, HFILL }},\n\n        { &hf_ac_if_desc_subtype,\n            { \"Subtype\", \"usbaudio.ac_if_subtype\", FT_UINT8, BASE_HEX|BASE_EXT_STRING,\n                &ac_subtype_vals_ext, 0x00, \"bDescriptorSubtype\", HFILL }},\n        { &hf_ac_if_hdr_ver,\n            { \"Version\", \"usbaudio.ac_if_hdr.bcdADC\",\n                FT_DOUBLE, BASE_NONE, NULL, 0, \"bcdADC\", HFILL }},\n        { &hf_ac_if_hdr_total_len,\n            { \"Total length\", \"usbaudio.ac_if_hdr.wTotalLength\",\n              FT_UINT16, BASE_DEC, NULL, 0x00, \"wTotalLength\", HFILL }},\n        { &hf_ac_if_hdr_bInCollection,\n            { \"Total number of interfaces\", \"usbaudio.ac_if_hdr.bInCollection\",\n              FT_UINT8, BASE_DEC, NULL, 0x00, \"bInCollection\", HFILL }},\n        { &hf_ac_if_hdr_if_num,\n            { \"Interface number\", \"usbaudio.ac_if_hdr.baInterfaceNr\",\n              FT_UINT8, BASE_DEC, NULL, 0x00, \"baInterfaceNr\", HFILL }},\n        { &hf_ac_if_input_terminalid,\n            { \"Terminal ID\", \"usbaudio.ac_if_input.bTerminalID\",\n              FT_UINT8, BASE_DEC, NULL, 0x00, \"bTerminalID\", HFILL }},\n        { &hf_ac_if_input_terminaltype,\n            { \"Terminal Type\", \"usbaudio.ac_if_input.wTerminalType\", FT_UINT16,\n              BASE_HEX|BASE_EXT_STRING, &terminal_types_vals_ext, 0x00, \"wTerminalType\", HFILL }},\n        { &hf_ac_if_input_assocterminal,\n            { \"Assoc Terminal\", \"usbaudio.ac_if_input.bAssocTerminal\",\n              FT_UINT8, BASE_DEC, NULL, 0x00, \"bAssocTerminal\", HFILL }},\n        { &hf_ac_if_input_nrchannels,\n            { \"Number Channels\", \"usbaudio.ac_if_input.bNrChannels\",\n              FT_UINT8, BASE_DEC, NULL, 0x00, \"bNrChannels\", HFILL }},\n        { &hf_ac_if_input_channelconfig,\n            { \"Channel Config\", \"usbaudio.ac_if_input.wChannelConfig\",\n              FT_UINT16, BASE_HEX, NULL, 0x00, \"wChannelConfig\", HFILL }},\n        { &hf_ac_if_input_channelnames,\n            { \"Channel Names\", \"usbaudio.ac_if_input.iChannelNames\",\n              FT_UINT8, BASE_DEC, NULL, 0x00, \"iChannelNames\", HFILL }},\n        { &hf_ac_if_input_terminal,\n            { \"Terminal\", \"usbaudio.ac_if_input.iTerminal\",\n              FT_UINT8, BASE_DEC, NULL, 0x00, \"iTerminal\", HFILL }},\n        { &hf_ac_if_output_terminalid,\n            { \"Terminal ID\", \"usbaudio.ac_if_output.bTerminalID\",\n              FT_UINT8, BASE_DEC, NULL, 0x00, \"bTerminalID\", HFILL }},\n        { &hf_ac_if_output_terminaltype,\n            { \"Terminal Type\", \"usbaudio.ac_if_output.wTerminalType\", FT_UINT16,\n               BASE_HEX|BASE_EXT_STRING, &terminal_types_vals_ext, 0x00, \"wTerminalType\", HFILL }},\n        { &hf_ac_if_output_assocterminal,\n            { \"Assoc Terminal\", \"usbaudio.ac_if_output.bAssocTerminal\",\n              FT_UINT8, BASE_DEC, NULL, 0x00, \"bAssocTerminal\", HFILL }},\n        { &hf_ac_if_output_sourceid,\n            { \"Source ID\", \"usbaudio.ac_if_output.bSourceID\",\n              FT_UINT8, BASE_DEC, NULL, 0x00, \"bSourceID\", HFILL }},\n        { &hf_ac_if_output_terminal,\n            { \"Terminal\", \"usbaudio.ac_if_output.iTerminal\",\n              FT_UINT8, BASE_DEC, NULL, 0x00, \"iTerminal\", HFILL }},\n        { &hf_ac_if_fu_unitid,\n            { \"Unit ID\", \"usbaudio.ac_if_fu.bUnitID\",\n              FT_UINT8, BASE_DEC, NULL, 0x00, \"bUnitID\", HFILL }},\n        { &hf_ac_if_fu_sourceid,\n            { \"Source ID\", \"usbaudio.ac_if_fu.bSourceID\",\n              FT_UINT8, BASE_DEC, NULL, 0x00, \"bSourceID\", HFILL }},\n        { &hf_ac_if_fu_controlsize,\n            { \"Control Size\", \"usbaudio.ac_if_fu.bControlSize\",\n              FT_UINT8, BASE_DEC, NULL, 0x00, \"bControlSize\", HFILL }},\n        { &hf_ac_if_fu_controls,\n            { \"Controls\", \"usbaudio.ac_if_fu.bmaControls\",\n              FT_BYTES, BASE_NONE, NULL, 0x00, \"bmaControls\", HFILL }},\n        { &hf_ac_if_fu_control,\n            { \"Control\", \"usbaudio.ac_if_fu.bmaControl\",\n              FT_UINT8, BASE_HEX, NULL, 0x00, \"bmaControls\", HFILL }},\n        { &hf_ac_if_fu_controls_d0,\n            { \"Mute\", \"usbaudio.ac_if_fu.bmaControls.d0\",\n              FT_BOOLEAN, 8, NULL, 0x01, NULL, HFILL }},\n        { &hf_ac_if_fu_controls_d1,\n            { \"Volume\", \"usbaudio.ac_if_fu.bmaControls.d1\",\n              FT_BOOLEAN, 8, NULL, 0x02, NULL, HFILL }},\n        { &hf_ac_if_fu_controls_d2,\n            { \"Bass\", \"usbaudio.ac_if_fu.bmaControls.d2\",\n              FT_BOOLEAN, 8, NULL, 0x04, NULL, HFILL }},\n        { &hf_ac_if_fu_controls_d3,\n            { \"Mid\", \"usbaudio.ac_if_fu.bmaControls.d3\",\n              FT_BOOLEAN, 8, NULL, 0x08, NULL, HFILL }},\n        { &hf_ac_if_fu_controls_d4,\n            { \"Treble\", \"usbaudio.ac_if_fu.bmaControls.d4\",\n              FT_BOOLEAN, 8, NULL, 0x10, NULL, HFILL }},\n        { &hf_ac_if_fu_controls_d5,\n            { \"Graphic Equalizer\", \"usbaudio.ac_if_fu.bmaControls.d5\",\n              FT_BOOLEAN, 8, NULL, 0x20, NULL, HFILL }},\n        { &hf_ac_if_fu_controls_d6,\n            { \"Automatic Gain\", \"usbaudio.ac_if_fu.bmaControls.d6\",\n              FT_BOOLEAN, 8, NULL, 0x40, NULL, HFILL }},\n        { &hf_ac_if_fu_controls_d7,\n            { \"Delay\", \"usbaudio.ac_if_fu.bmaControls.d7\",\n              FT_BOOLEAN, 8, NULL, 0x80, NULL, HFILL }},\n        { &hf_ac_if_fu_controls_d8,\n            { \"Bass Boost\", \"usbaudio.ac_if_fu.bmaControls.d8\",\n              FT_BOOLEAN, 8, NULL, 0x01, NULL, HFILL }},\n        { &hf_ac_if_fu_controls_d9,\n            { \"Loudness\", \"usbaudio.ac_if_fu.bmaControls.d9\",\n              FT_BOOLEAN, 8, NULL, 0x02, NULL, HFILL }},\n        { &hf_ac_if_fu_controls_rsv,\n            { \"Reserved\", \"usbaudio.ac_if_fu.bmaControls.rsv\",\n              FT_UINT8, BASE_HEX, NULL, 0xFC, \"Must be zero\", HFILL }},\n        { &hf_ac_if_fu_ifeature,\n            { \"Feature\", \"usbaudio.ac_if_fu.iFeature\",\n              FT_UINT8, BASE_DEC, NULL, 0x00, \"iFeature\", HFILL }},\n        { &hf_as_if_desc_subtype,\n            { \"Subtype\", \"usbaudio.as_if_subtype\", FT_UINT8, BASE_HEX|BASE_EXT_STRING,\n                &as_subtype_vals_ext, 0x00, \"bDescriptorSubtype\", HFILL }},\n        { &hf_as_if_gen_term_id,\n            { \"Terminal ID\", \"usbaudio.as_if_gen.bTerminalLink\",\n              FT_UINT8, BASE_DEC, NULL, 0x00, \"bTerminalLink\", HFILL }},\n        { &hf_as_if_gen_delay,\n            { \"Interface delay in frames\", \"usbaudio.as_if_gen.bDelay\",\n              FT_UINT8, BASE_DEC, NULL, 0x00, \"bDelay\", HFILL }},\n        { &hf_as_if_gen_format,\n            { \"Format\", \"usbaudio.as_if_gen.wFormatTag\",\n              FT_UINT16, BASE_HEX, NULL, 0x00, \"wFormatTag\", HFILL }},\n        { &hf_as_if_ft_formattype,\n            { \"FormatType\", \"usbaudio.as_if_ft.bFormatType\",\n              FT_UINT8, BASE_DEC, NULL, 0x00, \"wFormatType\", HFILL }},\n        { &hf_as_if_ft_maxbitrate,\n            { \"Max Bit Rate\", \"usbaudio.as_if_ft.wMaxBitRate\",\n              FT_UINT16, BASE_DEC, NULL, 0x00, \"wMaxBitRate\", HFILL }},\n        { &hf_as_if_ft_nrchannels,\n            { \"Number Channels\", \"usbaudio.as_if_ft.bNrChannels\",\n              FT_UINT8, BASE_DEC, NULL, 0x00, \"bNrChannels\", HFILL }},\n        { &hf_as_if_ft_subframesize,\n            { \"Subframe Size\", \"usbaudio.as_if_ft.bSubframeSize\",\n              FT_UINT8, BASE_DEC, NULL, 0x00, \"bSubframeSize\", HFILL }},\n        { &hf_as_if_ft_bitresolution,\n            { \"Bit Resolution\", \"usbaudio.as_if_ft.bBitResolution\",\n              FT_UINT8, BASE_DEC, NULL, 0x00, \"bBitResolution\", HFILL }},\n        { &hf_as_if_ft_samplesperframe,\n            { \"Samples Per Frame\", \"usbaudio.as_if_ft.wSamplesPerFrame\",\n              FT_UINT16, BASE_DEC, NULL, 0x00, \"wSamplesPerFrame\", HFILL }},\n        { &hf_as_if_ft_samfreqtype,\n            { \"Samples Frequence Type\", \"usbaudio.as_if_ft.bSamFreqType\",\n              FT_UINT8, BASE_DEC, NULL, 0x00, \"bSamFreqType\", HFILL }},\n        { &hf_as_if_ft_lowersamfreq,\n            { \"Lower Samples Frequence\", \"usbaudio.as_if_ft.tLowerSamFreq\",\n              FT_UINT24, BASE_DEC, NULL, 0x00, \"tLowerSamFreq\", HFILL }},\n        { &hf_as_if_ft_uppersamfreq,\n            { \"Upper Samples Frequence\", \"usbaudio.as_if_ft.tUpperSamFreq\",\n              FT_UINT24, BASE_DEC, NULL, 0x00, \"tUpperSamFreq\", HFILL }},\n        { &hf_as_if_ft_samfreq,\n            { \"Samples Frequence\", \"usbaudio.as_if_ft.tSamFreq\",\n              FT_UINT24, BASE_DEC, NULL, 0x00, \"tSamFreq\", HFILL }},\n        { &hf_as_ep_desc_subtype,\n            { \"Subtype\", \"usbaudio.as_ep_subtype\", FT_UINT8,\n                BASE_HEX, NULL, 0x00, \"bDescriptorSubtype\", HFILL }},\n\n        { &hf_sysex_msg_fragments,\n            { \"Message fragments\", \"usbaudio.sysex.fragments\",\n              FT_NONE, BASE_NONE, NULL, 0x00, NULL, HFILL }},\n        { &hf_sysex_msg_fragment,\n            { \"Message fragment\", \"usbaudio.sysex.fragment\",\n              FT_FRAMENUM, BASE_NONE, NULL, 0x00, NULL, HFILL }},\n        { &hf_sysex_msg_fragment_overlap,\n            { \"Message fragment overlap\", \"usbaudio.sysex.fragment.overlap\",\n              FT_BOOLEAN, 0, NULL, 0x00, NULL, HFILL }},\n        { &hf_sysex_msg_fragment_overlap_conflicts,\n            { \"Message fragment overlapping with conflicting data\",\n              \"usbaudio.sysex.fragment.overlap.conflicts\",\n              FT_BOOLEAN, 0, NULL, 0x00, NULL, HFILL }},\n        { &hf_sysex_msg_fragment_multiple_tails,\n            { \"Message has multiple tail fragments\",\n              \"usbaudio.sysex.fragment.multiple_tails\",\n              FT_BOOLEAN, 0, NULL, 0x00, NULL, HFILL }},\n        { &hf_sysex_msg_fragment_too_long_fragment,\n            { \"Message fragment too long\", \"usbaudio.sysex.fragment.too_long_fragment\",\n              FT_BOOLEAN, 0, NULL, 0x00, NULL, HFILL }},\n        { &hf_sysex_msg_fragment_error,\n            { \"Message defragmentation error\", \"usbaudio.sysex.fragment.error\",\n              FT_FRAMENUM, BASE_NONE, NULL, 0x00, NULL, HFILL }},\n        { &hf_sysex_msg_fragment_count,\n            { \"Message fragment count\", \"usbaudio.sysex.fragment.count\",\n              FT_UINT32, BASE_DEC, NULL, 0x00, NULL, HFILL }},\n        { &hf_sysex_msg_reassembled_in,\n            { \"Reassembled in\", \"usbaudio.sysex.reassembled.in\",\n              FT_FRAMENUM, BASE_NONE, NULL, 0x00, NULL, HFILL }},\n        { &hf_sysex_msg_reassembled_length,\n            { \"Reassembled length\", \"usbaudio.sysex.reassembled.length\",\n              FT_UINT32, BASE_DEC, NULL, 0x00, NULL, HFILL }},\n        { &hf_sysex_msg_reassembled_data,\n            { \"Reassembled data\", \"usbaudio.sysex.reassembled.data\",\n              FT_BYTES, BASE_NONE, NULL, 0x00, NULL, HFILL }}\n    };\n\n    static gint *usb_audio_subtrees[] = {\n        &ett_usb_audio,\n        &ett_usb_audio_desc,\n        &ett_sysex_msg_fragment,\n        &ett_sysex_msg_fragments,\n        &ett_ac_if_fu_controls,\n        &ett_ac_if_fu_controls0,\n        &ett_ac_if_fu_controls1\n    };\n\n    static ei_register_info ei[] = {\n        { &ei_usb_audio_undecoded, { \"usbaudio.undecoded\", PI_UNDECODED, PI_WARN, \"Not dissected yet (report to wireshark.org)\", EXPFILL }},\n    };\n\n    expert_module_t *expert_usb_audio;\n\n    proto_usb_audio = proto_register_protocol(\"USB Audio\", \"USBAUDIO\", \"usbaudio\");\n    proto_register_field_array(proto_usb_audio, hf, array_length(hf));\n    proto_register_subtree_array(usb_audio_subtrees, array_length(usb_audio_subtrees));\n    expert_usb_audio = expert_register_protocol(proto_usb_audio);\n    expert_register_field_array(expert_usb_audio, ei, array_length(ei));\n    register_init_routine(&midi_data_reassemble_init);\n    register_cleanup_routine(&midi_data_reassemble_cleanup);\n\n    register_dissector(\"usbaudio\", dissect_usb_audio_bulk, proto_usb_audio);\n}\n\nvoid\nproto_reg_handoff_usb_audio(void)\n{\n    dissector_handle_t usb_audio_bulk_handle, usb_audio_descr_handle;\n\n    usb_audio_descr_handle = create_dissector_handle(\n            dissect_usb_audio_descriptor, proto_usb_audio);\n    dissector_add_uint(\"usb.descriptor\", IF_CLASS_AUDIO, usb_audio_descr_handle);\n\n    usb_audio_bulk_handle = find_dissector(\"usbaudio\");\n    dissector_add_uint(\"usb.bulk\", IF_CLASS_AUDIO, usb_audio_bulk_handle);\n\n    sysex_handle = find_dissector_add_dependency(\"sysex\", proto_usb_audio);\n}\n/*\n * Editor modelines\n *\n * Local Variables:\n * c-basic-offset: 4\n * tab-width: 8\n * indent-tabs-mode: nil\n * End:\n *\n * ex: set shiftwidth=4 tabstop=8 expandtab:\n * :indentSize=4:tabSize=8:noTabs=true:\n */\n", "code_before": "/* packet-usb-audio.c\n *\n * usb audio dissector\n * Tomasz Mon 2012\n *\n * SPDX-License-Identifier: GPL-2.0-or-later\n */\n\n/* the parsing of audio-specific descriptors is based on\n   USB Audio Device Class Specification for Basic Audio Devices, Release 1.0,\n   USB Device Class Definition for Audio Devices, Release 2.0 and\n   USB Device Class Definition for MIDI Devices, Release 1.0 */\n\n#include \"config.h\"\n\n#include <epan/packet.h>\n#include <epan/expert.h>\n#include <epan/reassemble.h>\n#include \"packet-usb.h\"\n\n/* XXX - we use the same macro for mpeg sections,\n         can we put this in a common include file? */\n#define USB_AUDIO_BCD44_TO_DEC(x)  ((((x)&0xf0) >> 4) * 10 + ((x)&0x0f))\n\nvoid proto_register_usb_audio(void);\nvoid proto_reg_handoff_usb_audio(void);\n\n/* protocols and header fields */\nstatic int proto_usb_audio;\nstatic int hf_midi_cable_number;\nstatic int hf_midi_code_index;\nstatic int hf_midi_event;\nstatic int hf_midi_padding;\nstatic int hf_ac_if_desc_subtype;\nstatic int hf_ac_if_hdr_ver;\nstatic int hf_ac_if_hdr_total_len;\nstatic int hf_ac_if_hdr_bInCollection;\nstatic int hf_ac_if_hdr_if_num;\nstatic int hf_ac_if_hdr_category;\nstatic int hf_ac_if_hdr_controls;\nstatic int hf_ac_if_hdr_controls_latency;\nstatic int hf_ac_if_hdr_controls_rsv;\nstatic int hf_ac_if_input_terminalid;\nstatic int hf_ac_if_input_terminaltype;\nstatic int hf_ac_if_input_assocterminal;\nstatic int hf_ac_if_input_csourceid;\nstatic int hf_ac_if_input_nrchannels;\nstatic int hf_ac_if_input_wchannelconfig;\nstatic int hf_ac_if_input_wchannelconfig_d0;\nstatic int hf_ac_if_input_wchannelconfig_d1;\nstatic int hf_ac_if_input_wchannelconfig_d2;\nstatic int hf_ac_if_input_wchannelconfig_d3;\nstatic int hf_ac_if_input_wchannelconfig_d4;\nstatic int hf_ac_if_input_wchannelconfig_d5;\nstatic int hf_ac_if_input_wchannelconfig_d6;\nstatic int hf_ac_if_input_wchannelconfig_d7;\nstatic int hf_ac_if_input_wchannelconfig_d8;\nstatic int hf_ac_if_input_wchannelconfig_d9;\nstatic int hf_ac_if_input_wchannelconfig_d10;\nstatic int hf_ac_if_input_wchannelconfig_d11;\nstatic int hf_ac_if_input_wchannelconfig_rsv;\nstatic int hf_ac_if_input_bmchannelconfig;\nstatic int hf_ac_if_input_bmchannelconfig_d0;\nstatic int hf_ac_if_input_bmchannelconfig_d1;\nstatic int hf_ac_if_input_bmchannelconfig_d2;\nstatic int hf_ac_if_input_bmchannelconfig_d3;\nstatic int hf_ac_if_input_bmchannelconfig_d4;\nstatic int hf_ac_if_input_bmchannelconfig_d5;\nstatic int hf_ac_if_input_bmchannelconfig_d6;\nstatic int hf_ac_if_input_bmchannelconfig_d7;\nstatic int hf_ac_if_input_bmchannelconfig_d8;\nstatic int hf_ac_if_input_bmchannelconfig_d9;\nstatic int hf_ac_if_input_bmchannelconfig_d10;\nstatic int hf_ac_if_input_bmchannelconfig_d11;\nstatic int hf_ac_if_input_bmchannelconfig_d12;\nstatic int hf_ac_if_input_bmchannelconfig_d13;\nstatic int hf_ac_if_input_bmchannelconfig_d14;\nstatic int hf_ac_if_input_bmchannelconfig_d15;\nstatic int hf_ac_if_input_bmchannelconfig_d16;\nstatic int hf_ac_if_input_bmchannelconfig_d17;\nstatic int hf_ac_if_input_bmchannelconfig_d18;\nstatic int hf_ac_if_input_bmchannelconfig_d19;\nstatic int hf_ac_if_input_bmchannelconfig_d20;\nstatic int hf_ac_if_input_bmchannelconfig_d21;\nstatic int hf_ac_if_input_bmchannelconfig_d22;\nstatic int hf_ac_if_input_bmchannelconfig_d23;\nstatic int hf_ac_if_input_bmchannelconfig_d24;\nstatic int hf_ac_if_input_bmchannelconfig_d25;\nstatic int hf_ac_if_input_bmchannelconfig_d26;\nstatic int hf_ac_if_input_bmchannelconfig_rsv;\nstatic int hf_ac_if_input_bmchannelconfig_d31;\nstatic int hf_ac_if_input_channelnames;\nstatic int hf_ac_if_input_controls;\nstatic int hf_ac_if_input_controls_copy;\nstatic int hf_ac_if_input_controls_connector;\nstatic int hf_ac_if_input_controls_overload;\nstatic int hf_ac_if_input_controls_cluster;\nstatic int hf_ac_if_input_controls_underflow;\nstatic int hf_ac_if_input_controls_overflow;\nstatic int hf_ac_if_input_controls_rsv;\nstatic int hf_ac_if_input_terminal;\nstatic int hf_ac_if_output_terminalid;\nstatic int hf_ac_if_output_terminaltype;\nstatic int hf_ac_if_output_assocterminal;\nstatic int hf_ac_if_output_sourceid;\nstatic int hf_ac_if_output_clk_sourceid;\nstatic int hf_ac_if_output_controls;\nstatic int hf_ac_if_output_controls_copy;\nstatic int hf_ac_if_output_controls_connector;\nstatic int hf_ac_if_output_controls_overload;\nstatic int hf_ac_if_output_controls_underflow;\nstatic int hf_ac_if_output_controls_overflow;\nstatic int hf_ac_if_output_controls_rsv;\nstatic int hf_ac_if_output_terminal;\nstatic int hf_ac_if_fu_unitid;\nstatic int hf_ac_if_fu_sourceid;\nstatic int hf_ac_if_fu_controlsize;\nstatic int hf_ac_if_fu_controls;\nstatic int hf_ac_if_fu_control;\nstatic int hf_ac_if_fu_controls_d0;\nstatic int hf_ac_if_fu_controls_d1;\nstatic int hf_ac_if_fu_controls_d2;\nstatic int hf_ac_if_fu_controls_d3;\nstatic int hf_ac_if_fu_controls_d4;\nstatic int hf_ac_if_fu_controls_d5;\nstatic int hf_ac_if_fu_controls_d6;\nstatic int hf_ac_if_fu_controls_d7;\nstatic int hf_ac_if_fu_controls_d8;\nstatic int hf_ac_if_fu_controls_d9;\nstatic int hf_ac_if_fu_controls_rsv;\nstatic int hf_ac_if_fu_controls_v2;\nstatic int hf_ac_if_fu_control_v2;\nstatic int hf_ac_if_fu_controls_v2_d0;\nstatic int hf_ac_if_fu_controls_v2_d1;\nstatic int hf_ac_if_fu_controls_v2_d2;\nstatic int hf_ac_if_fu_controls_v2_d3;\nstatic int hf_ac_if_fu_controls_v2_d4;\nstatic int hf_ac_if_fu_controls_v2_d5;\nstatic int hf_ac_if_fu_controls_v2_d6;\nstatic int hf_ac_if_fu_controls_v2_d7;\nstatic int hf_ac_if_fu_controls_v2_d8;\nstatic int hf_ac_if_fu_controls_v2_d9;\nstatic int hf_ac_if_fu_controls_v2_d10;\nstatic int hf_ac_if_fu_controls_v2_d11;\nstatic int hf_ac_if_fu_controls_v2_d12;\nstatic int hf_ac_if_fu_controls_v2_d13;\nstatic int hf_ac_if_fu_controls_v2_d14;\nstatic int hf_ac_if_fu_controls_v2_rsv;\nstatic int hf_ac_if_fu_ifeature;\nstatic int hf_ac_if_su_unitid;\nstatic int hf_ac_if_su_nrinpins;\nstatic int hf_ac_if_su_sourceids;\nstatic int hf_ac_if_su_sourceid;\nstatic int hf_ac_if_su_controls;\nstatic int hf_ac_if_su_controls_d0;\nstatic int hf_ac_if_su_controls_rsv;\nstatic int hf_ac_if_su_iselector;\nstatic int hf_ac_if_mu_unitid;\nstatic int hf_ac_if_mu_nrinpins;\nstatic int hf_ac_if_mu_sourceid;\nstatic int hf_ac_if_mu_nrchannels;\nstatic int hf_ac_if_mu_channelconfig;\nstatic int hf_ac_if_mu_channelconfig_d0;\nstatic int hf_ac_if_mu_channelconfig_d1;\nstatic int hf_ac_if_mu_channelconfig_d2;\nstatic int hf_ac_if_mu_channelconfig_d3;\nstatic int hf_ac_if_mu_channelconfig_d4;\nstatic int hf_ac_if_mu_channelconfig_d5;\nstatic int hf_ac_if_mu_channelconfig_d6;\nstatic int hf_ac_if_mu_channelconfig_d7;\nstatic int hf_ac_if_mu_channelconfig_d8;\nstatic int hf_ac_if_mu_channelconfig_d9;\nstatic int hf_ac_if_mu_channelconfig_d10;\nstatic int hf_ac_if_mu_channelconfig_d11;\nstatic int hf_ac_if_mu_channelconfig_rsv;\nstatic int hf_ac_if_mu_channelnames;\nstatic int hf_ac_if_mu_controls;\nstatic int hf_ac_if_mu_imixer;\nstatic int hf_ac_if_clksrc_id;\nstatic int hf_ac_if_clksrc_attr;\nstatic int hf_ac_if_clksrc_attr_type;\nstatic int hf_ac_if_clksrc_attr_d2;\nstatic int hf_ac_if_clksrc_attr_rsv;\nstatic int hf_ac_if_clksrc_controls;\nstatic int hf_ac_if_clksrc_controls_freq;\nstatic int hf_ac_if_clksrc_controls_validity;\nstatic int hf_ac_if_clksrc_controls_rsv;\nstatic int hf_ac_if_clksrc_assocterminal;\nstatic int hf_ac_if_clksrc_clocksource;\nstatic int hf_ac_if_clksel_id;\nstatic int hf_ac_if_clksel_nrpins;\nstatic int hf_ac_if_clksel_sourceid;\nstatic int hf_ac_if_clksel_controls;\nstatic int hf_ac_if_clksel_controls_clksel;\nstatic int hf_ac_if_clksel_controls_rsv;\nstatic int hf_ac_if_clksel_clockselector;\nstatic int hf_as_if_desc_subtype;\nstatic int hf_ac_if_extunit_id;\nstatic int hf_ac_if_extunit_code;\nstatic int hf_ac_if_extunit_nrpins;\nstatic int hf_ac_if_extunit_sourceid;\nstatic int hf_ac_if_extunit_nrchannels;\nstatic int hf_ac_if_extunit_bmchannelconfig;\nstatic int hf_ac_if_extunit_channelnames;\nstatic int hf_ac_if_extunit_bmcontrols;\nstatic int hf_ac_if_extunit_bmcontrols_enable_ctrl;\nstatic int hf_ac_if_extunit_bmcontrols_cluster_ctrl;\nstatic int hf_ac_if_extunit_bmcontrols_underflow_ctrl;\nstatic int hf_ac_if_extunit_bmcontrols_overflowflow_ctrl;\nstatic int hf_ac_if_extunit_iext;\nstatic int hf_as_if_gen_term_link;\nstatic int hf_as_if_gen_delay;\nstatic int hf_as_if_gen_wformattag;\nstatic int hf_as_if_gen_controls;\nstatic int hf_as_if_gen_controls_active;\nstatic int hf_as_if_gen_controls_valid;\nstatic int hf_as_if_gen_controls_rsv;\nstatic int hf_as_if_gen_formattype;\nstatic int hf_as_if_gen_formats;\nstatic int hf_as_if_gen_formats_i_d0;\nstatic int hf_as_if_gen_formats_i_d1;\nstatic int hf_as_if_gen_formats_i_d2;\nstatic int hf_as_if_gen_formats_i_d3;\nstatic int hf_as_if_gen_formats_i_d4;\nstatic int hf_as_if_gen_formats_i_rsv;\nstatic int hf_as_if_gen_formats_i_d31;\nstatic int hf_as_if_gen_formats_ii_d0;\nstatic int hf_as_if_gen_formats_ii_d1;\nstatic int hf_as_if_gen_formats_ii_d2;\nstatic int hf_as_if_gen_formats_ii_d3;\nstatic int hf_as_if_gen_formats_ii_rsv;\nstatic int hf_as_if_gen_formats_ii_d31;\nstatic int hf_as_if_gen_formats_iii_d0;\nstatic int hf_as_if_gen_formats_iii_d1;\nstatic int hf_as_if_gen_formats_iii_d2;\nstatic int hf_as_if_gen_formats_iii_d3;\nstatic int hf_as_if_gen_formats_iii_d4;\nstatic int hf_as_if_gen_formats_iii_d5;\nstatic int hf_as_if_gen_formats_iii_d6;\nstatic int hf_as_if_gen_formats_iii_d7;\nstatic int hf_as_if_gen_formats_iii_d8;\nstatic int hf_as_if_gen_formats_iii_d9;\nstatic int hf_as_if_gen_formats_iii_d10;\nstatic int hf_as_if_gen_formats_iii_d11;\nstatic int hf_as_if_gen_formats_iii_d12;\nstatic int hf_as_if_gen_formats_iii_rsv;\nstatic int hf_as_if_gen_formats_iv_d0;\nstatic int hf_as_if_gen_formats_iv_d1;\nstatic int hf_as_if_gen_formats_iv_d2;\nstatic int hf_as_if_gen_formats_iv_d3;\nstatic int hf_as_if_gen_formats_iv_d4;\nstatic int hf_as_if_gen_formats_iv_d5;\nstatic int hf_as_if_gen_formats_iv_d6;\nstatic int hf_as_if_gen_formats_iv_d7;\nstatic int hf_as_if_gen_formats_iv_d8;\nstatic int hf_as_if_gen_formats_iv_d9;\nstatic int hf_as_if_gen_formats_iv_d10;\nstatic int hf_as_if_gen_formats_iv_d11;\nstatic int hf_as_if_gen_formats_iv_d12;\nstatic int hf_as_if_gen_formats_iv_d13;\nstatic int hf_as_if_gen_formats_iv_d14;\nstatic int hf_as_if_gen_formats_iv_d15;\nstatic int hf_as_if_gen_formats_iv_d16;\nstatic int hf_as_if_gen_formats_iv_d17;\nstatic int hf_as_if_gen_formats_iv_d18;\nstatic int hf_as_if_gen_formats_iv_d19;\nstatic int hf_as_if_gen_formats_iv_d20;\nstatic int hf_as_if_gen_formats_iv_d21;\nstatic int hf_as_if_gen_formats_iv_rsv;\nstatic int hf_as_if_gen_nrchannels;\nstatic int hf_as_if_gen_bmchannelconfig;\nstatic int hf_as_if_gen_bmchannelconfig_d0;\nstatic int hf_as_if_gen_bmchannelconfig_d1;\nstatic int hf_as_if_gen_bmchannelconfig_d2;\nstatic int hf_as_if_gen_bmchannelconfig_d3;\nstatic int hf_as_if_gen_bmchannelconfig_d4;\nstatic int hf_as_if_gen_bmchannelconfig_d5;\nstatic int hf_as_if_gen_bmchannelconfig_d6;\nstatic int hf_as_if_gen_bmchannelconfig_d7;\nstatic int hf_as_if_gen_bmchannelconfig_d8;\nstatic int hf_as_if_gen_bmchannelconfig_d9;\nstatic int hf_as_if_gen_bmchannelconfig_d10;\nstatic int hf_as_if_gen_bmchannelconfig_d11;\nstatic int hf_as_if_gen_bmchannelconfig_d12;\nstatic int hf_as_if_gen_bmchannelconfig_d13;\nstatic int hf_as_if_gen_bmchannelconfig_d14;\nstatic int hf_as_if_gen_bmchannelconfig_d15;\nstatic int hf_as_if_gen_bmchannelconfig_d16;\nstatic int hf_as_if_gen_bmchannelconfig_d17;\nstatic int hf_as_if_gen_bmchannelconfig_d18;\nstatic int hf_as_if_gen_bmchannelconfig_d19;\nstatic int hf_as_if_gen_bmchannelconfig_d20;\nstatic int hf_as_if_gen_bmchannelconfig_d21;\nstatic int hf_as_if_gen_bmchannelconfig_d22;\nstatic int hf_as_if_gen_bmchannelconfig_d23;\nstatic int hf_as_if_gen_bmchannelconfig_d24;\nstatic int hf_as_if_gen_bmchannelconfig_d25;\nstatic int hf_as_if_gen_bmchannelconfig_d26;\nstatic int hf_as_if_gen_bmchannelconfig_rsv;\nstatic int hf_as_if_gen_bmchannelconfig_d31;\nstatic int hf_as_if_gen_channelnames;\nstatic int hf_as_if_ft_formattype;\nstatic int hf_as_if_ft_maxbitrate;\nstatic int hf_as_if_ft_nrchannels;\nstatic int hf_as_if_ft_subframesize;\nstatic int hf_as_if_ft_subslotsize;\nstatic int hf_as_if_ft_bitresolution;\nstatic int hf_as_if_ft_samplesperframe;\nstatic int hf_as_if_ft_samfreqtype;\nstatic int hf_as_if_ft_lowersamfreq;\nstatic int hf_as_if_ft_uppersamfreq;\nstatic int hf_as_if_ft_samfreq;\nstatic int hf_as_ep_desc_subtype;\nstatic int hf_as_ep_gen_bmattributes;\nstatic int hf_as_ep_gen_bmattributes_d0;\nstatic int hf_as_ep_gen_bmattributes_d1;\nstatic int hf_as_ep_gen_bmattributes_rsv;\nstatic int hf_as_ep_gen_bmattributes_d7;\nstatic int hf_as_ep_gen_controls;\nstatic int hf_as_ep_gen_controls_pitch;\nstatic int hf_as_ep_gen_controls_data_overrun;\nstatic int hf_as_ep_gen_controls_data_underrun;\nstatic int hf_as_ep_gen_controls_rsv;\nstatic int hf_as_ep_gen_lockdelayunits;\nstatic int hf_as_ep_gen_lockdelay;\nstatic int hf_ms_if_desc_subtype;\nstatic int hf_ms_if_hdr_ver;\nstatic int hf_ms_if_hdr_total_len;\nstatic int hf_ms_if_midi_in_bjacktype;\nstatic int hf_ms_if_midi_in_bjackid;\nstatic int hf_ms_if_midi_in_ijack;\nstatic int hf_ms_if_midi_out_bjacktype;\nstatic int hf_ms_if_midi_out_bjackid;\nstatic int hf_ms_if_midi_out_bnrinputpins;\nstatic int hf_ms_if_midi_out_basourceid;\nstatic int hf_ms_if_midi_out_basourcepin;\nstatic int hf_ms_if_midi_out_ijack;\nstatic int hf_ms_ep_gen_numjacks;\nstatic int hf_ms_ep_gen_baassocjackid;\nstatic int hf_ms_ep_desc_subtype;\n\nstatic int hf_brequest_v1;\nstatic int hf_brequest_v2;\nstatic int hf_wvalue;\nstatic int hf_wvalue_channel_number;\nstatic int hf_wvalue_fu_cs_v1;\nstatic int hf_wvalue_clksrc_cs;\nstatic int hf_wvalue_clksel_cs;\nstatic int hf_windex;\nstatic int hf_windex_interface;\nstatic int hf_windex_entity_id;\nstatic int hf_windex_endpoint;\nstatic int hf_wlength;\nstatic int hf_parameter_bselector;\nstatic int hf_parameter_bmute;\nstatic int hf_parameter_wvolume;\nstatic int hf_parameter_wnumsubranges;\nstatic int hf_parameter_bcur;\nstatic int hf_parameter_bmin;\nstatic int hf_parameter_bmax;\nstatic int hf_parameter_bres;\nstatic int hf_parameter_wcur;\nstatic int hf_parameter_wmin;\nstatic int hf_parameter_wmax;\nstatic int hf_parameter_wres;\nstatic int hf_parameter_dcur;\nstatic int hf_parameter_dmin;\nstatic int hf_parameter_dmax;\nstatic int hf_parameter_dres;\n\nstatic reassembly_table midi_data_reassembly_table;\n\nstatic int ett_usb_audio;\nstatic int ett_usb_audio_desc;\n\nstatic int ett_ac_if_hdr_controls;\nstatic int ett_ac_if_fu_controls;\nstatic int ett_ac_if_fu_controls0;\nstatic int ett_ac_if_fu_controls1;\nstatic int ett_ac_if_fu_controls_v2;\nstatic int ett_ac_if_fu_control_v2;\nstatic int ett_ac_if_su_sourceids;\nstatic int ett_ac_if_su_controls;\nstatic int ett_ac_if_input_wchannelconfig;\nstatic int ett_ac_if_input_bmchannelconfig;\nstatic int ett_ac_if_input_controls;\nstatic int ett_ac_if_output_controls;\nstatic int ett_ac_if_mu_channelconfig;\nstatic int ett_ac_if_clksrc_attr;\nstatic int ett_ac_if_clksrc_controls;\nstatic int ett_ac_if_clksel_controls;\nstatic int ett_ac_if_extunit_bmchannelconfig;\nstatic int ett_ac_if_extunit_bmcontrols;\nstatic int ett_as_if_gen_controls;\nstatic int ett_as_if_gen_formats;\nstatic int ett_as_if_gen_bmchannelconfig;\nstatic int ett_as_ep_gen_attributes;\nstatic int ett_as_ep_gen_controls;\nstatic int ett_wvalue;\nstatic int ett_windex;\nstatic int ett_parameter_block;\n\nstatic dissector_handle_t sysex_handle;\nstatic dissector_handle_t usb_audio_bulk_handle;\nstatic dissector_handle_t usb_audio_descr_handle;\nstatic dissector_handle_t usb_audio_control_handle;\n\n\n#define AUDIO_IF_SUBCLASS_UNDEFINED        0x00\n#define AUDIO_IF_SUBCLASS_AUDIOCONTROL     0x01\n#define AUDIO_IF_SUBCLASS_AUDIOSTREAMING   0x02\n#define AUDIO_IF_SUBCLASS_MIDISTREAMING    0x03\n\nstatic const value_string usb_audio_subclass_vals[] = {\n    {AUDIO_IF_SUBCLASS_UNDEFINED,      \"Undefined\"},\n    {AUDIO_IF_SUBCLASS_AUDIOCONTROL,   \"Audio Control\"},\n    {AUDIO_IF_SUBCLASS_AUDIOSTREAMING, \"Audio Streaming\"},\n    {AUDIO_IF_SUBCLASS_MIDISTREAMING,  \"MIDI Streaming\"},\n    {0,NULL}\n};\nvalue_string_ext ext_usb_audio_subclass_vals =\n    VALUE_STRING_EXT_INIT(usb_audio_subclass_vals);\n\n#define AUDIO_PROTOCOL_V1                  0x00\n#define AUDIO_PROTOCOL_V2                  0x20\n\n#define V1_REQUEST_CODE_UNDEFINED          0x00\n#define V1_REQUEST_SET_CUR                 0x01\n#define V1_REQUEST_SET_MIN                 0x02\n#define V1_REQUEST_SET_MAX                 0x03\n#define V1_REQUEST_SET_RES                 0x04\n#define V1_REQUEST_SET_MEM                 0x05\n#define V1_REQUEST_GET_CUR                 0x81\n#define V1_REQUEST_GET_MIN                 0x82\n#define V1_REQUEST_GET_MAX                 0x83\n#define V1_REQUEST_GET_RES                 0x84\n#define V1_REQUEST_GET_MEM                 0x85\n#define V1_REQUEST_GET_STAT                0xFF\n\nstatic const value_string v1_brequest_vals[] = {\n    {V1_REQUEST_CODE_UNDEFINED, \"REQUEST_CODE_UNDEFINED\"},\n    {V1_REQUEST_SET_CUR,        \"SET_CUR\"},\n    {V1_REQUEST_SET_MIN,        \"SET_MIN\"},\n    {V1_REQUEST_SET_MAX,        \"SET_MAX\"},\n    {V1_REQUEST_SET_RES,        \"SET_RES\"},\n    {V1_REQUEST_SET_MEM,        \"SET_MEM\"},\n    {V1_REQUEST_GET_CUR,        \"GET_CUR\"},\n    {V1_REQUEST_GET_MIN,        \"GET_MIN\"},\n    {V1_REQUEST_GET_MAX,        \"GET_MAX\"},\n    {V1_REQUEST_GET_RES,        \"GET_RES\"},\n    {V1_REQUEST_GET_MEM,        \"GET_MEM\"},\n    {V1_REQUEST_GET_STAT,       \"GET_STAT\"},\n    {0,NULL}\n};\nstatic value_string_ext v1_brequest_vals_ext =\n    VALUE_STRING_EXT_INIT(v1_brequest_vals);\n\n/* A.17.7 Feature Unit Control Selectors */\n#define FU_CONTROL_UNDEFINED                0x00\n#define MUTE_CONTROL                        0x01\n#define VOLUME_CONTROL                      0x02\n#define BASS_CONTROL                        0x03\n#define MID_CONTROL                         0x04\n#define TREBLE_CONTROL                      0x05\n#define GRAPHIC_EQUALIZER_CONTROL           0x06\n#define AUTOMATIC_GAIN_CONTROL              0x07\n#define DELAY_CONTROL                       0x08\n#define BASS_BOOST_CONTROL                  0x09\n#define LOUDNESS_CONTROL                    0x0A\n\nstatic const value_string v1_fu_cs_vals[] = {\n    {FU_CONTROL_UNDEFINED,      \"FU_CONTROL_UNDEFINED\"},\n    {MUTE_CONTROL,              \"MUTE_CONTROL\"},\n    {VOLUME_CONTROL,            \"VOLUME_CONTROL\"},\n    {BASS_CONTROL,              \"BASS_CONTROL\"},\n    {MID_CONTROL,               \"MID_CONTROL\"},\n    {TREBLE_CONTROL,            \"TREBLE_CONTROL\"},\n    {GRAPHIC_EQUALIZER_CONTROL, \"GRAPHIC_EQUALIZER_CONTROL\"},\n    {AUTOMATIC_GAIN_CONTROL,    \"AUTOMATIC_GAIN_CONTROL\"},\n    {DELAY_CONTROL,             \"DELAY_CONTROL\"},\n    {BASS_BOOST_CONTROL,        \"BASS_BOOST_CONTROL\"},\n    {LOUDNESS_CONTROL,          \"LOUDNESS_CONTROL\"},\n    {0,NULL}\n};\nstatic value_string_ext v1_fu_cs_vals_ext =\n    VALUE_STRING_EXT_INIT(v1_fu_cs_vals);\n\n#define V2_REQUEST_CODE_UNDEFINED          0x00\n#define V2_REQUEST_CUR                     0x01\n#define V2_REQUEST_RANGE                   0x02\n#define V2_REQUEST_MEM                     0x03\n\nstatic const value_string v2_brequest_vals[] = {\n    {V2_REQUEST_CODE_UNDEFINED, \"REQUEST_CODE_UNDEFINED\"},\n    {V2_REQUEST_CUR,            \"CUR\"},\n    {V2_REQUEST_RANGE,          \"RANGE\"},\n    {V2_REQUEST_MEM,            \"MEM\"},\n    {0,NULL}\n};\nstatic value_string_ext v2_brequest_vals_ext =\n    VALUE_STRING_EXT_INIT(v2_brequest_vals);\n\n/* A.17.1 Clock Source Control Selectors */\n#define V2_CS_CONTROL_UNDEFINED            0x00\n#define V2_CS_SAM_FREQ_CONTROL             0x01\n#define V2_CS_CLOCK_VALID_CONTROL          0x02\nstatic const value_string v2_clksrc_cs_vals[] = {\n    {V2_CS_CONTROL_UNDEFINED,   \"CS_CONTROL_UNDEFINED\"},\n    {V2_CS_SAM_FREQ_CONTROL,    \"CS_SAM_FREQ_CONTROL\"},\n    {V2_CS_CLOCK_VALID_CONTROL, \"CS_CLOCK_VALID_CONTROL\"},\n    {0,NULL}\n};\n\n/* A.17.2 Clock Selector Control Selectors */\n#define V2_CX_CONTROL_UNDEFINED          0x00\n#define V2_CX_CLOCK_SELECTOR_CONTROL     0x01\nstatic const value_string v2_clksel_cs_vals[] = {\n    {V2_CX_CONTROL_UNDEFINED,      \"CX_CONTROL_UNDEFINED\"},\n    {V2_CX_CLOCK_SELECTOR_CONTROL, \"CX_CLOCK_SELECTOR_CONTROL\"},\n    {0,NULL}\n};\n\nstatic const value_string code_index_vals[] = {\n    { 0x0, \"Miscellaneous (Reserved)\" },\n    { 0x1, \"Cable events (Reserved)\" },\n    { 0x2, \"Two-byte System Common message\" },\n    { 0x3, \"Three-byte System Common message\" },\n    { 0x4, \"SysEx starts or continues\" },\n    { 0x5, \"SysEx ends with following single byte/Single-byte System Common Message\" },\n    { 0x6, \"SysEx ends with following two bytes\" },\n    { 0x7, \"SysEx ends with following three bytes\" },\n    { 0x8, \"Note-off\" },\n    { 0x9, \"Note-on\" },\n    { 0xA, \"Poly-KeyPress\" },\n    { 0xB, \"Control Change\" },\n    { 0xC, \"Program Change\" },\n    { 0xD, \"Channel Pressure\" },\n    { 0xE, \"PitchBend Change\" },\n    { 0xF, \"Single Byte\" },\n    { 0, NULL }\n};\n\n/* USB audio specification, section A.8 */\n#define CS_INTERFACE       0x24\n#define CS_ENDPOINT        0x25\n\nstatic const value_string aud_descriptor_type_vals[] = {\n        {CS_INTERFACE, \"audio class interface\"},\n        {CS_ENDPOINT,  \"audio class endpoint\"},\n        {0,NULL}\n};\nstatic value_string_ext aud_descriptor_type_vals_ext =\n    VALUE_STRING_EXT_INIT(aud_descriptor_type_vals);\n\n#define AC_SUBTYPE_HEADER                0x01\n#define AC_SUBTYPE_INPUT_TERMINAL        0x02\n#define AC_SUBTYPE_OUTPUT_TERMINAL       0x03\n#define AC_SUBTYPE_MIXER_UNIT            0x04\n#define AC_SUBTYPE_SELECTOR_UNIT         0x05\n#define AC_SUBTYPE_FEATURE_UNIT          0x06\n#define AC_SUBTYPE_EFFECT_UNIT           0x07\n#define AC_SUBTYPE_PROCESSING_UNIT       0x08\n#define AC_SUBTYPE_EXTENSION_UNIT        0x09\n#define AC_SUBTYPE_CLOCK_SOURCE          0x0A\n#define AC_SUBTYPE_CLOCK_SELECTOR        0x0B\n#define AC_SUBTYPE_CLOCK_MULTIPLIER      0x0C\n#define AC_SUBTYPE_SAMPLE_RATE_CONVERTER 0x0D\n\nstatic const value_string ac_subtype_vals[] = {\n    {AC_SUBTYPE_HEADER,                \"Header Descriptor\"},\n    {AC_SUBTYPE_INPUT_TERMINAL,        \"Input terminal descriptor\"},\n    {AC_SUBTYPE_OUTPUT_TERMINAL,       \"Output terminal descriptor\"},\n    {AC_SUBTYPE_MIXER_UNIT,            \"Mixer unit descriptor\"},\n    {AC_SUBTYPE_SELECTOR_UNIT,         \"Selector unit descriptor\"},\n    {AC_SUBTYPE_FEATURE_UNIT,          \"Feature unit descriptor\"},\n    {AC_SUBTYPE_EFFECT_UNIT,           \"Effect unit descriptor\"},\n    {AC_SUBTYPE_PROCESSING_UNIT,       \"Processing unit descriptor\"},\n    {AC_SUBTYPE_EXTENSION_UNIT,        \"Extension unit descriptor\"},\n    {AC_SUBTYPE_CLOCK_SOURCE,          \"Clock source descriptor\"},\n    {AC_SUBTYPE_CLOCK_SELECTOR,        \"Clock selector descriptor\"},\n    {AC_SUBTYPE_CLOCK_MULTIPLIER,      \"Clock multiplier descriptor\"},\n    {AC_SUBTYPE_SAMPLE_RATE_CONVERTER, \"Sample rate converter descriptor\"},\n    {0,NULL}\n};\nstatic value_string_ext ac_subtype_vals_ext =\n    VALUE_STRING_EXT_INIT(ac_subtype_vals);\n\n#define AS_SUBTYPE_GENERAL         0x01\n#define AS_SUBTYPE_FORMAT_TYPE     0x02\n#define AS_SUBTYPE_ENCODER         0x03\n\nstatic const value_string as_subtype_vals[] = {\n    {AS_SUBTYPE_GENERAL,     \"General AS Descriptor\"},\n    {AS_SUBTYPE_FORMAT_TYPE, \"Format type descriptor\"},\n    {AS_SUBTYPE_ENCODER,     \"Encoder descriptor\"},\n    {0,NULL}\n};\nstatic value_string_ext as_subtype_vals_ext =\n    VALUE_STRING_EXT_INIT(as_subtype_vals);\n\n#define AS_EP_SUBTYPE_GENERAL       0x01\nstatic const value_string as_ep_subtype_vals[] = {\n    {AS_EP_SUBTYPE_GENERAL,       \"General Descriptor\"},\n    {0,NULL}\n};\n\n#define MS_IF_SUBTYPE_HEADER        0x01\n#define MS_IF_SUBTYPE_MIDI_IN_JACK  0x02\n#define MS_IF_SUBTYPE_MIDI_OUT_JACK 0x03\n#define MS_IF_SUBTYPE_ELEMENT       0x04\nstatic const value_string ms_if_subtype_vals[] = {\n    {MS_IF_SUBTYPE_HEADER,        \"Header Descriptor\"},\n    {MS_IF_SUBTYPE_MIDI_IN_JACK,  \"MIDI IN Jack descriptor\"},\n    {MS_IF_SUBTYPE_MIDI_OUT_JACK, \"MIDI OUT Jack descriptor\"},\n    {MS_IF_SUBTYPE_ELEMENT,       \"MIDI Element descriptor\"},\n    {0,NULL}\n};\nstatic value_string_ext ms_if_subtype_vals_ext =\n    VALUE_STRING_EXT_INIT(ms_if_subtype_vals);\n\n#define MS_MIDI_JACK_TYPE_EMBEDDED  0x01\n#define MS_MIDI_JACK_TYPE_EXTERNAL  0x02\nstatic const value_string ms_midi_jack_type_vals[] = {\n    {MS_MIDI_JACK_TYPE_EMBEDDED, \"Embedded\"},\n    {MS_MIDI_JACK_TYPE_EXTERNAL, \"External\"},\n    {0,NULL}\n};\n\n#define MS_EP_SUBTYPE_GENERAL       0x01\nstatic const value_string ms_ep_subtype_vals[] = {\n    {MS_EP_SUBTYPE_GENERAL,       \"General Descriptor\"},\n    {0,NULL}\n};\n\n/* Table A-7: Audio Function Category Codes */\nstatic const value_string audio_function_categories_vals[] = {\n    {0x00, \"Undefined\"},\n    {0x01, \"Desktop speaker\"},\n    {0x02, \"Home theater\"},\n    {0x03, \"Microphone\"},\n    {0x04, \"Headset\"},\n    {0x05, \"Telephone\"},\n    {0x06, \"Converter\"},\n    {0x07, \"Voice/Sound recorder\"},\n    {0x08, \"I/O box\"},\n    {0x09, \"Musical instrument\"},\n    {0x0A, \"Pro-audio\"},\n    {0x0B, \"Audio/Video\"},\n    {0x0C, \"Control panel\"},\n    {0xFF, \"Other\"},\n    {0,NULL}\n};\nstatic value_string_ext audio_function_categories_vals_ext =\n    VALUE_STRING_EXT_INIT(audio_function_categories_vals);\n\n/* Described in 4.7.2 Class-Specific AC Interface Descriptor */\nstatic const value_string controls_capabilities_vals[] = {\n    {0x00, \"Not present\"},\n    {0x01, \"Present, read-only\"},\n    {0x02, \"Value not allowed\"},\n    {0x03, \"Host programmable\"},\n    {0,NULL}\n};\nstatic value_string_ext controls_capabilities_vals_ext =\n    VALUE_STRING_EXT_INIT(controls_capabilities_vals);\n\n/* Described in 4.9.2 Class-Specific AS Interface Descriptor */\nstatic const value_string controls_capabilities_read_only_vals[] = {\n    {0x00, \"Not present\"},\n    {0x01, \"Present, read-only\"},\n    {0x02, \"Value not allowed\"},\n    {0x03, \"Value not allowed\"},\n    {0,NULL}\n};\nstatic value_string_ext controls_capabilities_read_only_vals_ext =\n    VALUE_STRING_EXT_INIT(controls_capabilities_read_only_vals);\n\n/* Described in 4.7.2.1 Clock Source Descriptor */\nstatic const value_string clock_types_vals[] = {\n    {0x00, \"External clock\"},\n    {0x01, \"Internal fixed clock\"},\n    {0x02, \"Internal variable clock\"},\n    {0x03, \"Internal programmable clock\"},\n    {0,NULL}\n};\n\nstatic const value_string clock_sync_vals[] = {\n    {0x00, \"Free running\"},\n    {0x01, \"Synchronized to the Start of Frame\"},\n    {0,NULL}\n};\n\nstatic const value_string lock_delay_unit_vals[] = {\n    {0, \"Undefined\"},\n    {1, \"Milliseconds\"},\n    {2, \"Decoded PCM samples\"},\n    {0,NULL}\n};\n\n/* From https://www.usb.org/sites/default/files/termt10.pdf */\nstatic const value_string terminal_types_vals[] = {\n    /* USB Terminal Types */\n    {0x0100, \"USB Undefined\"},\n    {0x0101, \"USB Streaming\"},\n    {0x01FF, \"USB vendor specific\"},\n    /* Input Terminal Types */\n    {0x0200, \"Input Undefined\"},\n    {0x0201, \"Microphone\"},\n    {0x0202, \"Desktop Microphone\"},\n    {0x0203, \"Personal microphone\"},\n    {0x0204, \"Omni-directional microphone\"},\n    {0x0205, \"Microphone array\"},\n    {0x0206, \"Processing microphone array\"},\n    {0x0300, \"Output Undefined\"},\n    {0x0301, \"Speaker\"},\n    {0x0302, \"Headphones\"},\n    {0x0303, \"Head Mounted Display Audio\"},\n    {0x0304, \"Desktop speaker\"},\n    {0x0305, \"Room speaker\"},\n    {0x0306, \"Communication speaker\"},\n    {0x0307, \"Low frequency effects speaker\"},\n    /* Bi-directional Terminal Types */\n    {0x0400, \"Bi-directional Undefined\"},\n    {0x0401, \"Handset\"},\n    {0x0402, \"Headset\"},\n    {0x0403, \"Speakerphone, no echoreduction\"},\n    {0x0404, \"Echo-suppressing speakerphone\"},\n    {0x0405, \"Echo-canceling speakerphone\"},\n    /* Telephony Terminal Types */\n    {0x0500, \"Telephony Undefined\"},\n    {0x0501, \"Phone line\"},\n    {0x0502, \"Telephone\"},\n    {0x0503, \"Down Line Pone\"},\n    /* External Terminal Types */\n    {0x0600, \"External Undefined\"},\n    {0x0601, \"Analog connector\"},\n    {0x0602, \"Digital audio interface\"},\n    {0x0603, \"Line connector\"},\n    {0x0604, \"Legacy audio connector\"},\n    {0x0605, \"S/PDIF interface\"},\n    {0x0606, \"1394 DA stream\"},\n    {0x0607, \"1394 DV stream soundtrack\"},\n    /* Embedded Function Terminal Types */\n    {0x0700, \"Embedded Undefined\"},\n    {0x0701, \"Level Calibration Noise Source\"},\n    {0x0702, \"Equalization Noise\"},\n    {0x0703, \"CD player\"},\n    {0x0704, \"DAT\"},\n    {0x0705, \"DCC\"},\n    {0x0706, \"MiniDisk\"},\n    {0x0707, \"Analog Tape\"},\n    {0x0708, \"Phonograph\"},\n    {0x0709, \"VCR Audio\"},\n    {0x070A, \"Video Disc Audio\"},\n    {0x070B, \"DVD Audio\"},\n    {0x070C, \"TV Tuner Audio\"},\n    {0x070D, \"Satellite Receiver Audio\"},\n    {0x070E, \"Cable Tuner Audio\"},\n    {0x070F, \"DSS Audio\"},\n    {0x0710, \"Radio Receiver\"},\n    {0x0711, \"Radio Transmitter\"},\n    {0x0712, \"Multi-track Recorder\"},\n    {0x0713, \"Synthesizer\"},\n    {0,NULL}\n};\nstatic value_string_ext terminal_types_vals_ext =\n    VALUE_STRING_EXT_INIT(terminal_types_vals);\n\n/* From https://usb.org/sites/default/files/frmts10.pdf */\nstatic const value_string audio_data_format_tag_vals[] = {\n    /* Audio Data Format Type I Codes */\n    {0x0000, \"Type I Undefined\"},\n    {0x0001, \"PCM\"},\n    {0x0002, \"PCM8\"},\n    {0x0003, \"IEEE Float\"},\n    {0x0004, \"ALAW\"},\n    {0x0005, \"MULAW\"},\n    /* Audio Data Format Type II Codes */\n    {0x1000, \"Type II Undefined\"},\n    {0x1001, \"MPEG\"},\n    {0x1002, \"AC-3\"},\n    /* Audio Data Format Type III Codes */\n    {0x2000, \"Type III Undefined\"},\n    {0x2001, \"IEC1937 AC-3\"},\n    {0x2002, \"IEC1937 MPEG-1 Layer1\"},\n    {0x2003, \"IEC1937 MPEG-1 Layer2/3 or IEC1937 MPEG-2 NOEXT\"},\n    {0x2004, \"IEC1937 MPEG-2 EXT\"},\n    {0x2005, \"IEC1937 MPEG-2 Layer1 LS\"},\n    {0x2006, \"IEC1937 MPEG-2 Layer2/3 LS\"},\n    {0,NULL}\n};\nstatic value_string_ext audio_data_format_tag_vals_ext =\n    VALUE_STRING_EXT_INIT(audio_data_format_tag_vals);\n\n/* Enumerator with arbitrarily chosen values to map IDs to entity types */\ntypedef enum {\n    USB_AUDIO_ENTITY_UNKNOWN,\n    USB_AUDIO_ENTITY_INTERFACE,\n    USB_AUDIO_ENTITY_CLOCK_SOURCE,\n    USB_AUDIO_ENTITY_CLOCK_SELECTOR,\n    USB_AUDIO_ENTITY_CLOCK_MULTIPLIER,\n    USB_AUDIO_ENTITY_TERMINAL,\n    USB_AUDIO_ENTITY_MIXER,\n    USB_AUDIO_ENTITY_SELECTOR,\n    USB_AUDIO_ENTITY_FEATURE_UNIT,\n    USB_AUDIO_ENTITY_PARAMETRIC_EQUALIZER,\n    USB_AUDIO_ENTITY_REVERBERATION,\n    USB_AUDIO_ENTITY_MODULATION_DELAY,\n    USB_AUDIO_ENTITY_DYNAMIC_RANGE_COMPRESSOR,\n    USB_AUDIO_ENTITY_UP_DOWN_MIX,\n    USB_AUDIO_ENTITY_DOLBY_PROLOGIC,\n    USB_AUDIO_ENTITY_STEREO_EXTENDER,\n    USB_AUDIO_ENTITY_EXTENSION_UNIT,\n    USB_AUDIO_ENTITY_AUDIOSTREAMING_INTERFACE,\n    USB_AUDIO_ENTITY_ENCODER,\n    USB_AUDIO_ENTITY_MPEG_DECODER,\n    USB_AUDIO_ENTITY_AC3_DECODER,\n    USB_AUDIO_ENTITY_WMA_DECODER,\n    USB_AUDIO_ENTITY_DTS_DECODER,\n} usb_audio_entity_t;\n\ntypedef enum {\n    PARAMETER_LAYOUT_UNKNOWN,\n    PARAMETER_LAYOUT_1,\n    PARAMETER_LAYOUT_2,\n    PARAMETER_LAYOUT_3,\n} parameter_layout_t;\n\ntypedef struct _audio_conv_info_t {\n    /* Mapping from entity ID to its type. */\n    usb_audio_entity_t entity_type[256];\n} audio_conv_info_t;\n\nstatic int hf_sysex_msg_fragments;\nstatic int hf_sysex_msg_fragment;\nstatic int hf_sysex_msg_fragment_overlap;\nstatic int hf_sysex_msg_fragment_overlap_conflicts;\nstatic int hf_sysex_msg_fragment_multiple_tails;\nstatic int hf_sysex_msg_fragment_too_long_fragment;\nstatic int hf_sysex_msg_fragment_error;\nstatic int hf_sysex_msg_fragment_count;\nstatic int hf_sysex_msg_reassembled_in;\nstatic int hf_sysex_msg_reassembled_length;\nstatic int hf_sysex_msg_reassembled_data;\n\nstatic int ett_sysex_msg_fragment;\nstatic int ett_sysex_msg_fragments;\n\nstatic expert_field ei_usb_audio_undecoded;\nstatic expert_field ei_usb_audio_invalid_feature_unit_length;\nstatic expert_field ei_usb_audio_invalid_type_3_ft_nrchannels;\nstatic expert_field ei_usb_audio_invalid_type_3_ft_subframesize;\nstatic expert_field ei_usb_audio_invalid_type_3_ft_bitresolution;\n\nstatic const fragment_items sysex_msg_frag_items = {\n    /* Fragment subtrees */\n    &ett_sysex_msg_fragment,\n    &ett_sysex_msg_fragments,\n    /* Fragment fields */\n    &hf_sysex_msg_fragments,\n    &hf_sysex_msg_fragment,\n    &hf_sysex_msg_fragment_overlap,\n    &hf_sysex_msg_fragment_overlap_conflicts,\n    &hf_sysex_msg_fragment_multiple_tails,\n    &hf_sysex_msg_fragment_too_long_fragment,\n    &hf_sysex_msg_fragment_error,\n    &hf_sysex_msg_fragment_count,\n    /* Reassembled in field */\n    &hf_sysex_msg_reassembled_in,\n    /* Reassembled length field */\n    &hf_sysex_msg_reassembled_length,\n    &hf_sysex_msg_reassembled_data,\n    /* Tag */\n    \"Message fragments\"\n};\n\nstatic int\nget_midi_event_size(uint8_t code)\n{\n    switch (code)\n    {\n        case 0x0: /* Miscellaneous function codes. Reserved for future extensions. */\n        case 0x1: /* Cable events. Reserved for future expansion. */\n            /* The Event size can be 1, 2 or 3 bytes. Assume 3. */\n            return 3;\n        case 0x5: /* Single-byte System Common Message or SysEx ends with following single byte. */\n        case 0xF: /* Single Byte */\n            return 1;\n        case 0x2: /* 2 Two-byte System Common messages like MTC, SongSelect, etc. */\n        case 0x6: /* SysEx ends with following two bytes. */\n        case 0xC: /* Program Change */\n        case 0xD: /* Channel Pressure */\n            return 2;\n        case 0x3: /* Three-byte System Common messages like SPP, etc. */\n        case 0x4: /* SysEx starts or continues */\n        case 0x7: /* SysEx ends with following three bytes. */\n        case 0x8: /* Note-off */\n        case 0x9: /* Note-on */\n        case 0xA: /* Poly-KeyPress */\n        case 0xB: /* Control Change */\n        case 0xE: /* PitchBend Change */\n            return 3;\n        default:\n            /* Invalid Code Index Number */\n            return 0;\n    }\n}\n\nstatic inline bool\nis_sysex_code(uint8_t code)\n{\n    return (code == 0x04 || code == 0x05 || code == 0x06 || code == 0x07);\n}\n\nstatic bool\nis_last_sysex_packet_in_tvb(tvbuff_t *tvb, int offset)\n{\n    bool last   = true;\n    int      length = tvb_reported_length(tvb);\n\n    offset += 4;\n    while (offset < length)\n    {\n        uint8_t code = tvb_get_uint8(tvb, offset);\n        code &= 0x0F;\n\n        if (is_sysex_code(code))\n        {\n            last = false;\n            break;\n        }\n\n        offset += 4;\n    }\n\n    return last;\n}\n\nstatic void\ndissect_usb_midi_event(tvbuff_t *tvb, packet_info *pinfo,\n                       proto_tree *parent_tree,\n                       int offset)\n{\n    uint8_t     code;\n    uint8_t     cable;\n    bool        save_fragmented;\n    proto_tree *tree = NULL;\n\n    code = tvb_get_uint8(tvb, offset);\n    cable = (code & 0xF0) >> 4;\n    code &= 0x0F;\n\n    if (parent_tree)\n    {\n        proto_item *ti;\n        int event_size, padding_size;\n\n        ti = proto_tree_add_protocol_format(parent_tree, proto_usb_audio, tvb, offset, 4, \"USB Midi Event Packet: %s\",\n                 try_val_to_str(code, code_index_vals));\n        tree = proto_item_add_subtree(ti, ett_usb_audio);\n        proto_tree_add_item(tree, hf_midi_cable_number, tvb, offset, 1, ENC_BIG_ENDIAN);\n        proto_tree_add_item(tree, hf_midi_code_index, tvb, offset, 1, ENC_BIG_ENDIAN);\n\n        event_size = get_midi_event_size(code);\n        padding_size = 3 - event_size;\n        if (event_size > 0)\n        {\n            /* TODO: Create MIDI dissector and pass the event data to it */\n            const uint8_t *event_data = tvb_get_ptr(tvb, offset+1, event_size);\n            proto_tree_add_bytes(tree, hf_midi_event, tvb, offset+1, event_size, event_data);\n        }\n        if (padding_size > 0)\n        {\n            const uint8_t *padding = tvb_get_ptr(tvb, offset+1+event_size, padding_size);\n            proto_tree_add_bytes(tree, hf_midi_padding, tvb, offset+1+event_size, padding_size, padding);\n        }\n    }\n\n    save_fragmented = pinfo->fragmented;\n\n    /* Reassemble SysEx commands */\n    if (is_sysex_code(code))\n    {\n        tvbuff_t* new_tvb = NULL;\n        fragment_head *frag_sysex_msg = NULL;\n\n        pinfo->fragmented = true;\n\n        if (code == 0x04)\n        {\n            frag_sysex_msg = fragment_add_seq_next(&midi_data_reassembly_table,\n                tvb, offset+1,\n                pinfo,\n                cable, /* ID for fragments belonging together */\n                NULL,\n                3,\n                true);\n        }\n        else\n        {\n            frag_sysex_msg = fragment_add_seq_next(&midi_data_reassembly_table,\n                tvb, offset+1,\n                pinfo,\n                cable, /* ID for fragments belonging together */\n                NULL,\n                (int)(code - 4),\n                false);\n        }\n\n        if (is_last_sysex_packet_in_tvb(tvb, offset))\n        {\n            new_tvb = process_reassembled_data(tvb, offset+1, pinfo,\n                \"Reassembled Message\", frag_sysex_msg, &sysex_msg_frag_items,\n                NULL, tree);\n\n            if (code != 0x04) { /* Reassembled */\n                col_append_str(pinfo->cinfo, COL_INFO,\n                        \" (SysEx Reassembled)\");\n            } else { /* Not last packet of reassembled Short Message */\n                col_append_str(pinfo->cinfo, COL_INFO,\n                        \" (SysEx fragment)\");\n            }\n\n            if (new_tvb)\n            {\n                call_dissector(sysex_handle, new_tvb, pinfo, parent_tree);\n            }\n        }\n    }\n\n    pinfo->fragmented = save_fragmented;\n}\n\nstatic audio_conv_info_t*\nallocate_audio_conv_info(void)\n{\n    audio_conv_info_t *info = wmem_new(wmem_file_scope(), audio_conv_info_t);\n    info->entity_type[0] = USB_AUDIO_ENTITY_INTERFACE;\n    for (int i = 1; i < 256; i++) {\n        info->entity_type[i] = USB_AUDIO_ENTITY_UNKNOWN;\n    }\n    return info;\n}\n\nstatic void\nset_entity_type(urb_info_t *urb, uint8_t id, usb_audio_entity_t type)\n{\n    audio_conv_info_t *audio_conv_info = (audio_conv_info_t *)urb->conv->class_data;\n    if (!audio_conv_info) {\n        audio_conv_info = allocate_audio_conv_info();\n        urb->conv->class_data = audio_conv_info;\n        urb->conv->class_data_type = USB_CONV_AUDIO;\n    } else if (urb->conv->class_data_type != USB_CONV_AUDIO) {\n        /* XXX: Should this check be changed to assert? */\n        return;\n    }\n\n    /* Only set entity type for valid entity IDs */\n    if (id != 0) {\n        audio_conv_info->entity_type[id] = type;\n    }\n}\n\nstatic usb_audio_entity_t\nget_entity_type(urb_info_t *urb, uint8_t id)\n{\n    audio_conv_info_t *audio_conv_info = (audio_conv_info_t *)urb->conv->class_data;\n    if (!audio_conv_info || (urb->conv->class_data_type != USB_CONV_AUDIO)) {\n        return USB_AUDIO_ENTITY_UNKNOWN;\n    }\n    return audio_conv_info->entity_type[id];\n}\n\nstatic void\nbase_volume(char *buf, uint32_t value)\n{\n    if (value == 0x8000) {\n        snprintf(buf, ITEM_LABEL_LENGTH, \"-infinity dB (silence)\");\n    } else {\n        double dB = ((double)((int16_t)value)) / 256;\n        snprintf(buf, ITEM_LABEL_LENGTH, \"%.4f dB\", dB);\n    }\n}\n\n/* dissect the body of an AC interface header descriptor\n   return the number of bytes dissected (which may be smaller than the\n   body's length) */\nstatic int\ndissect_ac_if_hdr_body(tvbuff_t *tvb, int offset, packet_info *pinfo _U_,\n        proto_tree *tree, urb_info_t *urb)\n{\n    int      offset_start;\n    uint16_t bcdADC;\n    uint8_t  ver_major;\n    double   ver;\n    uint8_t  if_in_collection, i;\n\n    static int * const bm_controls[] = {\n        &hf_ac_if_hdr_controls_latency,\n        &hf_ac_if_hdr_controls_rsv,\n        NULL\n    };\n\n    offset_start = offset;\n\n    bcdADC = tvb_get_letohs(tvb, offset);\n    ver_major = USB_AUDIO_BCD44_TO_DEC(bcdADC>>8);\n    ver = ver_major + USB_AUDIO_BCD44_TO_DEC(bcdADC&0xFF) / 100.0;\n\n    proto_tree_add_double_format_value(tree, hf_ac_if_hdr_ver,\n            tvb, offset, 2, ver, \"%2.2f\", ver);\n    offset += 2;\n\n    /* version 1 refers to the Basic Audio Device specification,\n       version 2 is the Audio Device class specification, see above */\n    if (urb->conv->interfaceProtocol == AUDIO_PROTOCOL_V1) {\n        proto_tree_add_item(tree, hf_ac_if_hdr_total_len,\n                tvb, offset, 2, ENC_LITTLE_ENDIAN);\n        offset += 2;\n        if_in_collection = tvb_get_uint8(tvb, offset);\n        proto_tree_add_item(tree, hf_ac_if_hdr_bInCollection,\n                tvb, offset, 1, ENC_LITTLE_ENDIAN);\n        offset++;\n\n        for (i=0; i<if_in_collection; i++) {\n            proto_tree_add_item(tree, hf_ac_if_hdr_if_num,\n                    tvb, offset, 1, ENC_LITTLE_ENDIAN);\n            offset++;\n        }\n    }\n    else if (urb->conv->interfaceProtocol == AUDIO_PROTOCOL_V2) {\n        proto_tree_add_item(tree, hf_ac_if_hdr_category,\n                tvb, offset, 1, ENC_LITTLE_ENDIAN);\n        offset++;\n        proto_tree_add_item(tree, hf_ac_if_hdr_total_len,\n                tvb, offset, 2, ENC_LITTLE_ENDIAN);\n        offset += 2;\n        proto_tree_add_bitmask(tree, tvb, offset, hf_ac_if_hdr_controls,\n                ett_ac_if_hdr_controls, bm_controls, ENC_LITTLE_ENDIAN);\n        offset++;\n    }\n\n    return offset-offset_start;\n}\n\nstatic int\ndissect_ac_if_input_terminal(tvbuff_t *tvb, int offset, packet_info *pinfo _U_,\n        proto_tree *tree, urb_info_t *urb)\n{\n    int                offset_start;\n\n    static int * const input_wchannelconfig[] = {\n        &hf_ac_if_input_wchannelconfig_d0,\n        &hf_ac_if_input_wchannelconfig_d1,\n        &hf_ac_if_input_wchannelconfig_d2,\n        &hf_ac_if_input_wchannelconfig_d3,\n        &hf_ac_if_input_wchannelconfig_d4,\n        &hf_ac_if_input_wchannelconfig_d5,\n        &hf_ac_if_input_wchannelconfig_d6,\n        &hf_ac_if_input_wchannelconfig_d7,\n        &hf_ac_if_input_wchannelconfig_d8,\n        &hf_ac_if_input_wchannelconfig_d9,\n        &hf_ac_if_input_wchannelconfig_d10,\n        &hf_ac_if_input_wchannelconfig_d11,\n        &hf_ac_if_input_wchannelconfig_rsv,\n        NULL\n    };\n\n    static int * const input_bmchannelconfig[] = {\n        &hf_ac_if_input_bmchannelconfig_d0,\n        &hf_ac_if_input_bmchannelconfig_d1,\n        &hf_ac_if_input_bmchannelconfig_d2,\n        &hf_ac_if_input_bmchannelconfig_d3,\n        &hf_ac_if_input_bmchannelconfig_d4,\n        &hf_ac_if_input_bmchannelconfig_d5,\n        &hf_ac_if_input_bmchannelconfig_d6,\n        &hf_ac_if_input_bmchannelconfig_d7,\n        &hf_ac_if_input_bmchannelconfig_d8,\n        &hf_ac_if_input_bmchannelconfig_d9,\n        &hf_ac_if_input_bmchannelconfig_d10,\n        &hf_ac_if_input_bmchannelconfig_d11,\n        &hf_ac_if_input_bmchannelconfig_d12,\n        &hf_ac_if_input_bmchannelconfig_d13,\n        &hf_ac_if_input_bmchannelconfig_d14,\n        &hf_ac_if_input_bmchannelconfig_d15,\n        &hf_ac_if_input_bmchannelconfig_d16,\n        &hf_ac_if_input_bmchannelconfig_d17,\n        &hf_ac_if_input_bmchannelconfig_d18,\n        &hf_ac_if_input_bmchannelconfig_d19,\n        &hf_ac_if_input_bmchannelconfig_d20,\n        &hf_ac_if_input_bmchannelconfig_d21,\n        &hf_ac_if_input_bmchannelconfig_d22,\n        &hf_ac_if_input_bmchannelconfig_d23,\n        &hf_ac_if_input_bmchannelconfig_d24,\n        &hf_ac_if_input_bmchannelconfig_d25,\n        &hf_ac_if_input_bmchannelconfig_d26,\n        &hf_ac_if_input_bmchannelconfig_rsv,\n        &hf_ac_if_input_bmchannelconfig_d31,\n        NULL\n    };\n\n    static int * const controls[] = {\n        &hf_ac_if_input_controls_copy,\n        &hf_ac_if_input_controls_connector,\n        &hf_ac_if_input_controls_overload,\n        &hf_ac_if_input_controls_cluster,\n        &hf_ac_if_input_controls_underflow,\n        &hf_ac_if_input_controls_overflow,\n        &hf_ac_if_input_controls_rsv,\n        NULL\n    };\n\n    /* do not try to dissect unknown versions */\n    if (!((urb->conv->interfaceProtocol == AUDIO_PROTOCOL_V1) ||\n          (urb->conv->interfaceProtocol == AUDIO_PROTOCOL_V2)))\n        return 0;\n\n    offset_start = offset;\n\n    proto_tree_add_item(tree, hf_ac_if_input_terminalid, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    offset += 1;\n\n    proto_tree_add_item(tree, hf_ac_if_input_terminaltype, tvb, offset, 2, ENC_LITTLE_ENDIAN);\n    offset += 2;\n\n    proto_tree_add_item(tree, hf_ac_if_input_assocterminal, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    offset += 1;\n\n    if (urb->conv->interfaceProtocol == AUDIO_PROTOCOL_V2) {\n        proto_tree_add_item(tree, hf_ac_if_input_csourceid, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n        offset += 1;\n    }\n\n    proto_tree_add_item(tree, hf_ac_if_input_nrchannels, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    offset += 1;\n\n    if (urb->conv->interfaceProtocol == AUDIO_PROTOCOL_V1) {\n        proto_tree_add_bitmask(tree, tvb, offset, hf_ac_if_input_wchannelconfig, ett_ac_if_input_wchannelconfig, input_wchannelconfig, ENC_LITTLE_ENDIAN);\n        offset += 2;\n    } else if (urb->conv->interfaceProtocol == AUDIO_PROTOCOL_V2) {\n        proto_tree_add_bitmask(tree, tvb, offset, hf_ac_if_input_bmchannelconfig, ett_ac_if_input_bmchannelconfig, input_bmchannelconfig, ENC_LITTLE_ENDIAN);\n        offset += 4;\n    }\n\n    proto_tree_add_item(tree, hf_ac_if_input_channelnames, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    offset += 1;\n\n    if (urb->conv->interfaceProtocol == AUDIO_PROTOCOL_V2) {\n        proto_tree_add_bitmask(tree, tvb, offset, hf_ac_if_input_controls, ett_ac_if_input_controls, controls, ENC_LITTLE_ENDIAN);\n        offset += 2;\n    }\n\n    proto_tree_add_item(tree, hf_ac_if_input_terminal, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    offset += 1;\n\n    return offset-offset_start;\n}\n\nstatic int\ndissect_ac_if_output_terminal(tvbuff_t *tvb, int offset, packet_info *pinfo _U_,\n        proto_tree *tree, urb_info_t *urb)\n{\n    int                offset_start;\n\n    static int * const controls[] = {\n        &hf_ac_if_output_controls_copy,\n        &hf_ac_if_output_controls_connector,\n        &hf_ac_if_output_controls_overload,\n        &hf_ac_if_output_controls_underflow,\n        &hf_ac_if_output_controls_overflow,\n        &hf_ac_if_output_controls_rsv,\n        NULL\n    };\n\n    /* do not try to dissect unknown versions */\n    if (!((urb->conv->interfaceProtocol == AUDIO_PROTOCOL_V1) ||\n          (urb->conv->interfaceProtocol == AUDIO_PROTOCOL_V2)))\n        return 0;\n\n    offset_start = offset;\n\n    proto_tree_add_item(tree, hf_ac_if_output_terminalid, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    offset += 1;\n\n    proto_tree_add_item(tree, hf_ac_if_output_terminaltype, tvb, offset, 2, ENC_LITTLE_ENDIAN);\n    offset += 2;\n\n    proto_tree_add_item(tree, hf_ac_if_output_assocterminal, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    offset += 1;\n\n    proto_tree_add_item(tree, hf_ac_if_output_sourceid, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    offset += 1;\n\n    if (urb->conv->interfaceProtocol == AUDIO_PROTOCOL_V2) {\n        proto_tree_add_item(tree, hf_ac_if_output_clk_sourceid, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n        offset += 1;\n\n        proto_tree_add_bitmask(tree, tvb, offset, hf_ac_if_output_controls, ett_ac_if_output_controls, controls, ENC_LITTLE_ENDIAN);\n        offset += 2;\n    }\n\n    proto_tree_add_item(tree, hf_ac_if_output_terminal, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    offset += 1;\n\n    return offset-offset_start;\n}\n\nstatic int\ndissect_ac_if_feature_unit(tvbuff_t *tvb, int offset, packet_info *pinfo _U_,\n        proto_tree *tree, urb_info_t *urb, uint8_t desc_len)\n{\n    int offset_start;\n    int i;\n    int ch;\n    uint8_t controlsize;\n    proto_tree *bitmap_tree;\n    proto_item *ti;\n\n    static int * const fu_controls0[] = {\n        &hf_ac_if_fu_controls_d0,\n        &hf_ac_if_fu_controls_d1,\n        &hf_ac_if_fu_controls_d2,\n        &hf_ac_if_fu_controls_d3,\n        &hf_ac_if_fu_controls_d4,\n        &hf_ac_if_fu_controls_d5,\n        &hf_ac_if_fu_controls_d6,\n        &hf_ac_if_fu_controls_d7,\n        NULL };\n\n    static int * const fu_controls1[] = {\n        &hf_ac_if_fu_controls_d8,\n        &hf_ac_if_fu_controls_d9,\n        &hf_ac_if_fu_controls_rsv,\n        NULL };\n\n    static int * const v2_fu_controls[] = {\n        &hf_ac_if_fu_controls_v2_d0,\n        &hf_ac_if_fu_controls_v2_d1,\n        &hf_ac_if_fu_controls_v2_d2,\n        &hf_ac_if_fu_controls_v2_d3,\n        &hf_ac_if_fu_controls_v2_d4,\n        &hf_ac_if_fu_controls_v2_d5,\n        &hf_ac_if_fu_controls_v2_d6,\n        &hf_ac_if_fu_controls_v2_d7,\n        &hf_ac_if_fu_controls_v2_d8,\n        &hf_ac_if_fu_controls_v2_d9,\n        &hf_ac_if_fu_controls_v2_d10,\n        &hf_ac_if_fu_controls_v2_d11,\n        &hf_ac_if_fu_controls_v2_d12,\n        &hf_ac_if_fu_controls_v2_d13,\n        &hf_ac_if_fu_controls_v2_d14,\n        &hf_ac_if_fu_controls_v2_rsv,\n        NULL };\n\n    /* do not try to dissect unknown versions */\n    if (!((urb->conv->interfaceProtocol == AUDIO_PROTOCOL_V1) ||\n          (urb->conv->interfaceProtocol == AUDIO_PROTOCOL_V2)))\n        return 0;\n\n    offset_start = offset;\n\n    if (!PINFO_FD_VISITED(pinfo)) {\n        set_entity_type(urb, tvb_get_uint8(tvb, offset), USB_AUDIO_ENTITY_FEATURE_UNIT);\n    }\n    proto_tree_add_item(tree, hf_ac_if_fu_unitid, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    offset += 1;\n\n    proto_tree_add_item(tree, hf_ac_if_fu_sourceid, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    offset += 1;\n\n    if (urb->conv->interfaceProtocol == AUDIO_PROTOCOL_V1) {\n        proto_tree_add_item(tree, hf_ac_if_fu_controlsize, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n        controlsize = tvb_get_uint8(tvb, offset);\n        offset += 1;\n\n        /* Descriptor size is 7+(ch+1)*n where n is controlsize, calculate and validate ch */\n        ch = (controlsize > 0) ? (((desc_len - 7) / (controlsize)) - 1) : 0;\n        if (((7 + ((ch + 1) * controlsize)) != desc_len) || (ch < 0) || (controlsize == 0)){\n            /* Report malformed packet, do not attempt further dissection */\n            proto_tree_add_expert(tree, pinfo, &ei_usb_audio_invalid_feature_unit_length, tvb, offset, desc_len-offset);\n            offset += desc_len-offset;\n            return offset-offset_start;\n        }\n\n        ti = proto_tree_add_item(tree, hf_ac_if_fu_controls, tvb, offset, controlsize * (ch + 1), ENC_NA);\n        bitmap_tree = proto_item_add_subtree(ti, ett_ac_if_fu_controls);\n\n        /* bmaControls has 1 master channel 0 controls, and variable number of logical channel controls */\n        for (i = 0; i < (ch + 1); i++) {\n            ti = proto_tree_add_bitmask(bitmap_tree, tvb, offset, hf_ac_if_fu_control, ett_ac_if_fu_controls0, fu_controls0, ENC_LITTLE_ENDIAN);\n            proto_item_prepend_text(ti, \"%s channel %d \", (i == 0) ? \"Master\" : \"Logical\", i);\n            if (controlsize > 1) {\n                ti = proto_tree_add_bitmask(bitmap_tree, tvb, offset + 1, hf_ac_if_fu_control, ett_ac_if_fu_controls1, fu_controls1, ENC_LITTLE_ENDIAN);\n                proto_item_prepend_text(ti, \"%s channel %d\", (i == 0) ? \"Master\" : \"Logical\", i);\n            }\n            offset += controlsize;\n        }\n\n    } else if (urb->conv->interfaceProtocol == AUDIO_PROTOCOL_V2) {\n        /* Descriptor size is 6+(ch+1)*4, calculate and validate ch */\n        ch = (desc_len - 6) / 4 - 1;\n        if (((6 + (ch + 1) * 4) != desc_len) || (ch < 0)) {\n            /* Report malformed packet, do not attempt further dissection */\n            proto_tree_add_expert(tree, pinfo, &ei_usb_audio_invalid_feature_unit_length, tvb, offset, desc_len-offset);\n            offset += desc_len-offset;\n            return offset-offset_start;\n        }\n\n        ti = proto_tree_add_item(tree, hf_ac_if_fu_controls_v2, tvb, offset, 4 * (ch + 1), ENC_NA);\n        bitmap_tree = proto_item_add_subtree(ti, ett_ac_if_fu_controls_v2);\n\n        for (i = 0; i < (ch + 1); i++) {\n            ti = proto_tree_add_bitmask(bitmap_tree, tvb, offset, hf_ac_if_fu_control_v2, ett_ac_if_fu_control_v2, v2_fu_controls, ENC_LITTLE_ENDIAN);\n            proto_item_prepend_text(ti, \"%s channel %d \", (i == 0) ? \"Master\" : \"Logical\", i);\n            offset += 4;\n        }\n\n    }\n\n    proto_tree_add_item(tree, hf_ac_if_fu_ifeature, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    offset += 1;\n\n    return offset-offset_start;\n}\n\nstatic int dissect_ac_if_selector_unit(tvbuff_t *tvb, int offset, packet_info *pinfo _U_, proto_tree *tree, urb_info_t *urb)\n{\n    int offset_start;\n    uint32_t nrinpins,i;\n    uint32_t source_id;\n    proto_item *ti;\n    proto_tree *subtree;\n\n    static int * const controls[] = {\n        &hf_ac_if_su_controls_d0,\n        &hf_ac_if_su_controls_rsv,\n        NULL\n    };\n\n    /* do not try to dissect unknown versions */\n    if (!((urb->conv->interfaceProtocol == AUDIO_PROTOCOL_V1) ||\n          (urb->conv->interfaceProtocol == AUDIO_PROTOCOL_V2)))\n        return 0;\n\n    offset_start = offset;\n\n    if (!PINFO_FD_VISITED(pinfo)) {\n        set_entity_type(urb, tvb_get_uint8(tvb, offset), USB_AUDIO_ENTITY_SELECTOR);\n    }\n    proto_tree_add_item(tree, hf_ac_if_su_unitid, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    offset += 1;\n\n    proto_tree_add_item_ret_uint(tree, hf_ac_if_su_nrinpins, tvb, offset, 1, ENC_LITTLE_ENDIAN, &nrinpins);\n    offset += 1;\n\n    ti = proto_tree_add_bytes_format_value(tree, hf_ac_if_su_sourceids, tvb, offset, nrinpins, NULL, \"%s\", \"\");\n    subtree = proto_item_add_subtree(ti, ett_ac_if_su_sourceids);\n\n    for (i = 0; i < nrinpins; ++i) {\n        proto_tree_add_item_ret_uint(subtree, hf_ac_if_su_sourceid, tvb, offset, 1, ENC_LITTLE_ENDIAN, &source_id);\n        offset += 1;\n        proto_item_append_text(ti, \"%s%d\", (i > 0) ? \", \" : \"\", source_id);\n    }\n\n    if (urb->conv->interfaceProtocol == AUDIO_PROTOCOL_V2) {\n        proto_tree_add_bitmask(tree, tvb, offset, hf_ac_if_su_controls, ett_ac_if_su_controls, controls, ENC_LITTLE_ENDIAN);\n        offset += 1;\n    }\n\n    proto_tree_add_item(tree, hf_ac_if_su_iselector, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    offset += 1;\n\n    return offset - offset_start;\n}\n\nstatic int\ndissect_ac_if_mixed_unit(tvbuff_t *tvb, int offset, packet_info *pinfo _U_,\n        proto_tree *tree, urb_info_t *urb _U_)\n{\n    int      offset_start;\n    uint8_t nrinpins;\n\n    static int * const mu_channelconfig[] = {\n        &hf_ac_if_mu_channelconfig_d0,\n        &hf_ac_if_mu_channelconfig_d1,\n        &hf_ac_if_mu_channelconfig_d2,\n        &hf_ac_if_mu_channelconfig_d3,\n        &hf_ac_if_mu_channelconfig_d4,\n        &hf_ac_if_mu_channelconfig_d5,\n        &hf_ac_if_mu_channelconfig_d6,\n        &hf_ac_if_mu_channelconfig_d7,\n        &hf_ac_if_mu_channelconfig_d8,\n        &hf_ac_if_mu_channelconfig_d9,\n        &hf_ac_if_mu_channelconfig_d10,\n        &hf_ac_if_mu_channelconfig_d11,\n        &hf_ac_if_mu_channelconfig_rsv,\n        NULL\n    };\n\n    offset_start = offset;\n\n    proto_tree_add_item(tree, hf_ac_if_mu_unitid, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    offset += 1;\n\n    proto_tree_add_item(tree, hf_ac_if_mu_nrinpins, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    nrinpins = tvb_get_uint8(tvb, offset);\n    offset += 1;\n\n    while(nrinpins){\n        proto_tree_add_item(tree, hf_ac_if_mu_sourceid, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n        nrinpins--;\n        offset += 1;\n    }\n\n    proto_tree_add_item(tree, hf_ac_if_mu_nrchannels, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    offset += 1;\n\n    proto_tree_add_bitmask(tree, tvb, offset, hf_ac_if_mu_channelconfig, ett_ac_if_mu_channelconfig, mu_channelconfig, ENC_LITTLE_ENDIAN);\n    offset += 2;\n\n    proto_tree_add_item(tree, hf_ac_if_mu_channelnames, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    offset += 1;\n\n    proto_tree_add_item(tree, hf_ac_if_mu_controls, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    offset += 1;\n\n    proto_tree_add_item(tree, hf_ac_if_mu_imixer, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    offset += 1;\n\n    return offset-offset_start;\n}\n\nstatic int\ndissect_ac_if_clock_source(tvbuff_t *tvb, int offset, packet_info *pinfo _U_,\n        proto_tree *tree, urb_info_t *urb)\n{\n    int offset_start;\n    static int * const cs_attributes[] = {\n        &hf_ac_if_clksrc_attr_type,\n        &hf_ac_if_clksrc_attr_d2,\n        &hf_ac_if_clksrc_attr_rsv,\n        NULL\n    };\n    static int * const cs_controls[] = {\n        &hf_ac_if_clksrc_controls_freq,\n        &hf_ac_if_clksrc_controls_validity,\n        &hf_ac_if_clksrc_controls_rsv,\n        NULL\n    };\n    offset_start = offset;\n\n    if (!PINFO_FD_VISITED(pinfo)) {\n        set_entity_type(urb, tvb_get_uint8(tvb, offset), USB_AUDIO_ENTITY_CLOCK_SOURCE);\n    }\n    proto_tree_add_item(tree, hf_ac_if_clksrc_id, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    offset += 1;\n\n    proto_tree_add_bitmask(tree, tvb, offset, hf_ac_if_clksrc_attr, ett_ac_if_clksrc_attr, cs_attributes, ENC_LITTLE_ENDIAN);\n    offset += 1;\n\n    proto_tree_add_bitmask(tree, tvb, offset, hf_ac_if_clksrc_controls, ett_ac_if_clksrc_controls, cs_controls, ENC_LITTLE_ENDIAN);\n    offset += 1;\n\n    proto_tree_add_item(tree, hf_ac_if_clksrc_assocterminal, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    offset += 1;\n\n    proto_tree_add_item(tree, hf_ac_if_clksrc_clocksource, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    offset += 1;\n\n    return offset-offset_start;\n}\n\nstatic int\ndissect_ac_if_clock_selector(tvbuff_t *tvb, int offset, packet_info *pinfo _U_,\n        proto_tree *tree, urb_info_t *urb)\n{\n    int    offset_start;\n    uint8_t nrinpins;\n    static int * const cs_controls[] = {\n        &hf_ac_if_clksel_controls_clksel,\n        &hf_ac_if_clksel_controls_rsv,\n        NULL\n    };\n    offset_start = offset;\n\n    if (!PINFO_FD_VISITED(pinfo)) {\n        set_entity_type(urb, tvb_get_uint8(tvb, offset), USB_AUDIO_ENTITY_CLOCK_SELECTOR);\n    }\n    proto_tree_add_item(tree, hf_ac_if_clksel_id, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    offset += 1;\n\n    proto_tree_add_item(tree, hf_ac_if_clksel_nrpins, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    nrinpins = tvb_get_uint8(tvb, offset);\n    offset += 1;\n\n    while (nrinpins) {\n        proto_tree_add_item(tree, hf_ac_if_clksel_sourceid, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n        nrinpins--;\n        offset += 1;\n    }\n\n    proto_tree_add_bitmask(tree, tvb, offset, hf_ac_if_clksel_controls, ett_ac_if_clksel_controls, cs_controls, ENC_LITTLE_ENDIAN);\n    offset += 1;\n\n    proto_tree_add_item(tree, hf_ac_if_clksel_clockselector, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    offset += 1;\n\n    return offset-offset_start;\n}\n\nstatic int\ndissect_ac_if_extension_unit(tvbuff_t *tvb, int offset, packet_info *pinfo _U_,\n                             proto_tree *tree, urb_info_t *urb)\n{\n    int offset_start;\n    uint8_t nrinpins;\n    offset_start = offset;\n\n    static int * const v2_channels[] = {\n        &hf_as_if_gen_bmchannelconfig_d0,\n        &hf_as_if_gen_bmchannelconfig_d1,\n        &hf_as_if_gen_bmchannelconfig_d2,\n        &hf_as_if_gen_bmchannelconfig_d3,\n        &hf_as_if_gen_bmchannelconfig_d4,\n        &hf_as_if_gen_bmchannelconfig_d5,\n        &hf_as_if_gen_bmchannelconfig_d6,\n        &hf_as_if_gen_bmchannelconfig_d7,\n        &hf_as_if_gen_bmchannelconfig_d8,\n        &hf_as_if_gen_bmchannelconfig_d9,\n        &hf_as_if_gen_bmchannelconfig_d10,\n        &hf_as_if_gen_bmchannelconfig_d11,\n        &hf_as_if_gen_bmchannelconfig_d12,\n        &hf_as_if_gen_bmchannelconfig_d13,\n        &hf_as_if_gen_bmchannelconfig_d14,\n        &hf_as_if_gen_bmchannelconfig_d15,\n        &hf_as_if_gen_bmchannelconfig_d16,\n        &hf_as_if_gen_bmchannelconfig_d17,\n        &hf_as_if_gen_bmchannelconfig_d18,\n        &hf_as_if_gen_bmchannelconfig_d19,\n        &hf_as_if_gen_bmchannelconfig_d20,\n        &hf_as_if_gen_bmchannelconfig_d21,\n        &hf_as_if_gen_bmchannelconfig_d22,\n        &hf_as_if_gen_bmchannelconfig_d23,\n        &hf_as_if_gen_bmchannelconfig_d24,\n        &hf_as_if_gen_bmchannelconfig_d25,\n        &hf_as_if_gen_bmchannelconfig_d26,\n        &hf_as_if_gen_bmchannelconfig_rsv,\n        &hf_as_if_gen_bmchannelconfig_d31,\n        NULL\n    };\n    static int *const eu_bmcontrols[] = {\n        &hf_ac_if_extunit_bmcontrols_enable_ctrl,\n        &hf_ac_if_extunit_bmcontrols_cluster_ctrl,\n        &hf_ac_if_extunit_bmcontrols_underflow_ctrl,\n        &hf_ac_if_extunit_bmcontrols_overflowflow_ctrl,\n        NULL\n    };\n\n    if (!PINFO_FD_VISITED(pinfo)) {\n        set_entity_type(urb, tvb_get_uint8(tvb, offset), USB_AUDIO_ENTITY_EXTENSION_UNIT);\n    }\n    proto_tree_add_item(tree, hf_ac_if_extunit_id, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    offset += 1;\n    proto_tree_add_item(tree, hf_ac_if_extunit_code, tvb, offset, 2, ENC_LITTLE_ENDIAN);\n    offset += 2;\n\n    proto_tree_add_item(tree, hf_ac_if_extunit_nrpins, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    nrinpins = tvb_get_uint8(tvb, offset);\n    offset += 1;\n\n    while (nrinpins) {\n        proto_tree_add_item(tree, hf_ac_if_extunit_sourceid, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n        nrinpins--;\n        offset += 1;\n    }\n\n    proto_tree_add_item(tree, hf_ac_if_extunit_nrchannels, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    offset += 1;\n\n    // TODO:\n    // desc_tree = proto_tree_add_subtree(tree, tvb, offset, ???)\n    // offset += dissect_as_if_general_body(tvb, offset, pinfo, desc_tree, urb);\n    proto_tree_add_bitmask(tree, tvb, offset, hf_ac_if_extunit_bmchannelconfig, ett_ac_if_extunit_bmchannelconfig, v2_channels, ENC_LITTLE_ENDIAN);\n    offset += 4;\n\n    proto_tree_add_item(tree, hf_ac_if_extunit_channelnames, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    offset += 1;\n\n    proto_tree_add_bitmask(tree, tvb, offset, hf_ac_if_extunit_bmcontrols, ett_ac_if_extunit_bmcontrols, eu_bmcontrols, ENC_LITTLE_ENDIAN);\n    offset += 1;\n\n    proto_tree_add_item(tree, hf_ac_if_extunit_iext, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    offset += 1;\n\n    return offset - offset_start;\n}\n\nstatic int\ndissect_as_if_general_body(tvbuff_t *tvb, int offset, packet_info *pinfo _U_,\n        proto_tree *tree, urb_info_t *urb)\n{\n    int                offset_start;\n\n    static int * const v2_controls[] = {\n        &hf_as_if_gen_controls_active,\n        &hf_as_if_gen_controls_valid,\n        &hf_as_if_gen_controls_rsv,\n        NULL\n    };\n\n    static int * const v2_formats_type_i[] = {\n        &hf_as_if_gen_formats_i_d0,\n        &hf_as_if_gen_formats_i_d1,\n        &hf_as_if_gen_formats_i_d2,\n        &hf_as_if_gen_formats_i_d3,\n        &hf_as_if_gen_formats_i_d4,\n        &hf_as_if_gen_formats_i_rsv,\n        &hf_as_if_gen_formats_i_d31,\n        NULL\n    };\n\n    static int * const v2_formats_type_ii[] = {\n        &hf_as_if_gen_formats_ii_d0,\n        &hf_as_if_gen_formats_ii_d1,\n        &hf_as_if_gen_formats_ii_d2,\n        &hf_as_if_gen_formats_ii_d3,\n        &hf_as_if_gen_formats_ii_rsv,\n        &hf_as_if_gen_formats_ii_d31,\n        NULL\n    };\n\n    static int * const v2_formats_type_iii[] = {\n        &hf_as_if_gen_formats_iii_d0,\n        &hf_as_if_gen_formats_iii_d1,\n        &hf_as_if_gen_formats_iii_d2,\n        &hf_as_if_gen_formats_iii_d3,\n        &hf_as_if_gen_formats_iii_d4,\n        &hf_as_if_gen_formats_iii_d5,\n        &hf_as_if_gen_formats_iii_d6,\n        &hf_as_if_gen_formats_iii_d7,\n        &hf_as_if_gen_formats_iii_d8,\n        &hf_as_if_gen_formats_iii_d9,\n        &hf_as_if_gen_formats_iii_d10,\n        &hf_as_if_gen_formats_iii_d11,\n        &hf_as_if_gen_formats_iii_d12,\n        &hf_as_if_gen_formats_iii_rsv,\n        NULL\n    };\n\n    static int * const v2_formats_type_iv[] = {\n        &hf_as_if_gen_formats_iv_d0,\n        &hf_as_if_gen_formats_iv_d1,\n        &hf_as_if_gen_formats_iv_d2,\n        &hf_as_if_gen_formats_iv_d3,\n        &hf_as_if_gen_formats_iv_d4,\n        &hf_as_if_gen_formats_iv_d5,\n        &hf_as_if_gen_formats_iv_d6,\n        &hf_as_if_gen_formats_iv_d7,\n        &hf_as_if_gen_formats_iv_d8,\n        &hf_as_if_gen_formats_iv_d9,\n        &hf_as_if_gen_formats_iv_d10,\n        &hf_as_if_gen_formats_iv_d11,\n        &hf_as_if_gen_formats_iv_d12,\n        &hf_as_if_gen_formats_iv_d13,\n        &hf_as_if_gen_formats_iv_d14,\n        &hf_as_if_gen_formats_iv_d15,\n        &hf_as_if_gen_formats_iv_d16,\n        &hf_as_if_gen_formats_iv_d17,\n        &hf_as_if_gen_formats_iv_d18,\n        &hf_as_if_gen_formats_iv_d19,\n        &hf_as_if_gen_formats_iv_d20,\n        &hf_as_if_gen_formats_iv_d21,\n        &hf_as_if_gen_formats_iv_rsv,\n        NULL\n    };\n\n    static int * const v2_channels[] = {\n        &hf_as_if_gen_bmchannelconfig_d0,\n        &hf_as_if_gen_bmchannelconfig_d1,\n        &hf_as_if_gen_bmchannelconfig_d2,\n        &hf_as_if_gen_bmchannelconfig_d3,\n        &hf_as_if_gen_bmchannelconfig_d4,\n        &hf_as_if_gen_bmchannelconfig_d5,\n        &hf_as_if_gen_bmchannelconfig_d6,\n        &hf_as_if_gen_bmchannelconfig_d7,\n        &hf_as_if_gen_bmchannelconfig_d8,\n        &hf_as_if_gen_bmchannelconfig_d9,\n        &hf_as_if_gen_bmchannelconfig_d10,\n        &hf_as_if_gen_bmchannelconfig_d11,\n        &hf_as_if_gen_bmchannelconfig_d12,\n        &hf_as_if_gen_bmchannelconfig_d13,\n        &hf_as_if_gen_bmchannelconfig_d14,\n        &hf_as_if_gen_bmchannelconfig_d15,\n        &hf_as_if_gen_bmchannelconfig_d16,\n        &hf_as_if_gen_bmchannelconfig_d17,\n        &hf_as_if_gen_bmchannelconfig_d18,\n        &hf_as_if_gen_bmchannelconfig_d19,\n        &hf_as_if_gen_bmchannelconfig_d20,\n        &hf_as_if_gen_bmchannelconfig_d21,\n        &hf_as_if_gen_bmchannelconfig_d22,\n        &hf_as_if_gen_bmchannelconfig_d23,\n        &hf_as_if_gen_bmchannelconfig_d24,\n        &hf_as_if_gen_bmchannelconfig_d25,\n        &hf_as_if_gen_bmchannelconfig_d26,\n        &hf_as_if_gen_bmchannelconfig_rsv,\n        &hf_as_if_gen_bmchannelconfig_d31,\n        NULL\n    };\n\n    offset_start = offset;\n\n    if (urb->conv->interfaceProtocol == AUDIO_PROTOCOL_V1) {\n        proto_tree_add_item(tree, hf_as_if_gen_term_link, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n        offset++;\n        proto_tree_add_item(tree, hf_as_if_gen_delay, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n        offset++;\n        proto_tree_add_item(tree, hf_as_if_gen_wformattag, tvb, offset, 2, ENC_LITTLE_ENDIAN);\n        offset += 2;\n    } else if (urb->conv->interfaceProtocol == AUDIO_PROTOCOL_V2) {\n        uint8_t format_type;\n        int * const *formats_bitmask;\n\n        proto_tree_add_item(tree, hf_as_if_gen_term_link, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n        offset++;\n        proto_tree_add_bitmask(tree, tvb, offset, hf_as_if_gen_controls, ett_as_if_gen_controls, v2_controls, ENC_LITTLE_ENDIAN);\n        offset++;\n        proto_tree_add_item(tree, hf_as_if_gen_formattype, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n        format_type = tvb_get_uint8(tvb, offset);\n        offset++;\n        switch(format_type)\n        {\n            case 1:\n                formats_bitmask = v2_formats_type_i;\n                break;\n            case 2:\n                formats_bitmask = v2_formats_type_ii;\n                break;\n            case 3:\n                formats_bitmask = v2_formats_type_iii;\n                break;\n            case 4:\n                formats_bitmask = v2_formats_type_iv;\n                break;\n            default:\n                formats_bitmask = NULL;\n                break;\n        }\n        if (formats_bitmask) {\n            proto_tree_add_bitmask(tree, tvb, offset, hf_as_if_gen_formats, ett_as_if_gen_formats, formats_bitmask, ENC_LITTLE_ENDIAN);\n        } else {\n            proto_tree_add_item(tree, hf_as_if_gen_formats, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n        }\n        offset += 4;\n        proto_tree_add_item(tree, hf_as_if_gen_nrchannels, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n        offset++;\n        proto_tree_add_bitmask(tree, tvb, offset, hf_as_if_gen_bmchannelconfig, ett_as_if_gen_bmchannelconfig, v2_channels, ENC_LITTLE_ENDIAN);\n        offset += 4;\n        proto_tree_add_item(tree, hf_as_if_gen_channelnames, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n        offset++;\n    }\n\n    return offset-offset_start;\n}\n\nstatic int\ndissect_as_if_format_type_ver1_body(tvbuff_t *tvb, int offset, packet_info *pinfo _U_,\n        proto_tree *tree, urb_info_t *urb _U_)\n{\n    int    offset_start;\n    uint8_t SamFreqType;\n    uint8_t format_type;\n    uint32_t nrchannels;\n    uint32_t subframesize;\n    uint32_t bitresolution;\n    proto_item *desc_tree_item;\n\n    offset_start = offset;\n\n    proto_tree_add_item(tree, hf_as_if_ft_formattype, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    format_type = tvb_get_uint8(tvb, offset);\n    offset++;\n\n\n    switch(format_type){\n        case 1:\n            proto_tree_add_item(tree, hf_as_if_ft_nrchannels, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n            offset += 1;\n\n            proto_tree_add_item(tree, hf_as_if_ft_subframesize, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n            offset += 1;\n\n            proto_tree_add_item(tree, hf_as_if_ft_bitresolution, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n            offset += 1;\n\n            proto_tree_add_item(tree, hf_as_if_ft_samfreqtype, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n            SamFreqType = tvb_get_uint8(tvb, offset);\n            offset++;\n\n            if(SamFreqType == 0){\n                proto_tree_add_item(tree, hf_as_if_ft_lowersamfreq, tvb, offset, 3, ENC_LITTLE_ENDIAN);\n                offset += 3;\n                proto_tree_add_item(tree, hf_as_if_ft_uppersamfreq, tvb, offset, 3, ENC_LITTLE_ENDIAN);\n                offset += 3;\n            }else {\n                while(SamFreqType){\n                    proto_tree_add_item(tree, hf_as_if_ft_samfreq, tvb, offset, 3, ENC_LITTLE_ENDIAN);\n                    offset += 3;\n                    SamFreqType--;\n                }\n            }\n        break;\n        case 2:\n            proto_tree_add_item(tree, hf_as_if_ft_maxbitrate, tvb, offset, 2, ENC_LITTLE_ENDIAN);\n            offset += 2;\n\n            proto_tree_add_item(tree, hf_as_if_ft_samplesperframe, tvb, offset, 2, ENC_LITTLE_ENDIAN);\n            offset += 2;\n\n            proto_tree_add_item(tree, hf_as_if_ft_samfreqtype, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n            SamFreqType = tvb_get_uint8(tvb, offset);\n            offset++;\n\n            if(SamFreqType == 0){\n                proto_tree_add_item(tree, hf_as_if_ft_lowersamfreq, tvb, offset, 3, ENC_LITTLE_ENDIAN);\n                offset += 3;\n                proto_tree_add_item(tree, hf_as_if_ft_uppersamfreq, tvb, offset, 3, ENC_LITTLE_ENDIAN);\n                offset += 3;\n            }else {\n                while(SamFreqType){\n                    proto_tree_add_item(tree, hf_as_if_ft_samfreq, tvb, offset, 3, ENC_LITTLE_ENDIAN);\n                    offset += 3;\n                    SamFreqType--;\n                }\n            }\n        break;\n        case 3:\n            desc_tree_item = proto_tree_add_item_ret_uint(tree, hf_as_if_ft_nrchannels, tvb, offset, 1, ENC_LITTLE_ENDIAN, &nrchannels);\n            offset += 1;\n\n            if(nrchannels != 2){\n                expert_add_info(pinfo, desc_tree_item, &ei_usb_audio_invalid_type_3_ft_nrchannels);\n            }\n\n            desc_tree_item = proto_tree_add_item_ret_uint(tree, hf_as_if_ft_subframesize, tvb, offset, 1, ENC_LITTLE_ENDIAN, &subframesize);\n            offset += 1;\n\n            if(subframesize != 2){\n                expert_add_info(pinfo, desc_tree_item, &ei_usb_audio_invalid_type_3_ft_subframesize);\n            }\n\n            desc_tree_item = proto_tree_add_item_ret_uint(tree, hf_as_if_ft_bitresolution, tvb, offset, 1, ENC_LITTLE_ENDIAN, &bitresolution);\n            offset += 1;\n\n            if(bitresolution != 16){\n                expert_add_info(pinfo, desc_tree_item, &ei_usb_audio_invalid_type_3_ft_bitresolution);\n            }\n\n            proto_tree_add_item(tree, hf_as_if_ft_samfreqtype, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n            SamFreqType = tvb_get_uint8(tvb, offset);\n            offset++;\n\n            if(SamFreqType == 0){\n                proto_tree_add_item(tree, hf_as_if_ft_lowersamfreq, tvb, offset, 3, ENC_LITTLE_ENDIAN);\n                offset += 3;\n                proto_tree_add_item(tree, hf_as_if_ft_uppersamfreq, tvb, offset, 3, ENC_LITTLE_ENDIAN);\n                offset += 3;\n            }else {\n                while(SamFreqType){\n                    proto_tree_add_item(tree, hf_as_if_ft_samfreq, tvb, offset, 3, ENC_LITTLE_ENDIAN);\n                    offset += 3;\n                    SamFreqType--;\n                }\n            }\n        break;\n        default:\n        break;\n    }\n\n    return offset-offset_start;\n}\n\nstatic int\ndissect_as_if_format_type_ver2_body(tvbuff_t *tvb, int offset, packet_info *pinfo _U_,\n        proto_tree *tree, urb_info_t *urb _U_)\n{\n    int    offset_start;\n    uint8_t format_type;\n\n    offset_start = offset;\n\n    proto_tree_add_item(tree, hf_as_if_ft_formattype, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    format_type = tvb_get_uint8(tvb, offset);\n    offset++;\n\n    if (format_type==1) {\n        proto_tree_add_item(tree, hf_as_if_ft_subslotsize, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n        offset += 1;\n\n        proto_tree_add_item(tree, hf_as_if_ft_bitresolution, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n        offset += 1;\n    }\n\n    return offset-offset_start;\n}\n\nstatic int\ndissect_as_if_format_type_body(tvbuff_t *tvb, int offset, packet_info *pinfo,\n        proto_tree *tree, urb_info_t *urb)\n{\n    if (urb->conv->interfaceProtocol == AUDIO_PROTOCOL_V1) {\n        return dissect_as_if_format_type_ver1_body(tvb, offset, pinfo, tree, urb);\n    } else if (urb->conv->interfaceProtocol == AUDIO_PROTOCOL_V2) {\n        return dissect_as_if_format_type_ver2_body(tvb, offset, pinfo, tree, urb);\n    }\n\n    return 0;\n}\n\nstatic int\ndissect_as_ep_general_body(tvbuff_t *tvb, int offset, packet_info *pinfo _U_,\n        proto_tree *tree, urb_info_t *urb)\n{\n    int                offset_start = offset;\n\n    static int * const v1_attributes[] = {\n        &hf_as_ep_gen_bmattributes_d0,\n        &hf_as_ep_gen_bmattributes_d1,\n        &hf_as_ep_gen_bmattributes_rsv,\n        &hf_as_ep_gen_bmattributes_d7,\n        NULL\n    };\n    static int * const v2_attributes[] = {\n        &hf_as_ep_gen_bmattributes_d7,\n        NULL\n    };\n    static int * const controls[] = {\n        &hf_as_ep_gen_controls_pitch,\n        &hf_as_ep_gen_controls_data_overrun,\n        &hf_as_ep_gen_controls_data_underrun,\n        &hf_as_ep_gen_controls_rsv,\n        NULL\n    };\n\n    /* do not try to dissect unknown versions */\n    if (!((urb->conv->interfaceProtocol == AUDIO_PROTOCOL_V1) ||\n          (urb->conv->interfaceProtocol == AUDIO_PROTOCOL_V2)))\n        return 0;\n\n    if (urb->conv->interfaceProtocol == AUDIO_PROTOCOL_V1) {\n        proto_tree_add_bitmask(tree, tvb, offset, hf_as_ep_gen_bmattributes, ett_as_ep_gen_attributes, v1_attributes, ENC_LITTLE_ENDIAN);\n        offset++;\n    } else if (urb->conv->interfaceProtocol == AUDIO_PROTOCOL_V2) {\n        proto_tree_add_bitmask(tree, tvb, offset, hf_as_ep_gen_bmattributes, ett_as_ep_gen_attributes, v2_attributes, ENC_LITTLE_ENDIAN);\n        offset++;\n        proto_tree_add_bitmask(tree, tvb, offset, hf_as_ep_gen_controls, ett_as_ep_gen_controls, controls, ENC_LITTLE_ENDIAN);\n        offset++;\n    }\n\n    proto_tree_add_item(tree, hf_as_ep_gen_lockdelayunits, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    offset += 1;\n    proto_tree_add_item(tree, hf_as_ep_gen_lockdelay, tvb, offset, 2, ENC_LITTLE_ENDIAN);\n    offset += 2;\n\n    return offset-offset_start;\n}\n\nstatic int\ndissect_ms_if_hdr_body(tvbuff_t *tvb, int offset, packet_info *pinfo _U_,\n        proto_tree *tree, urb_info_t *urb _U_)\n{\n    int      offset_start;\n    uint16_t bcdADC;\n    uint8_t  ver_major;\n    double   ver;\n\n    offset_start = offset;\n\n    bcdADC = tvb_get_letohs(tvb, offset);\n    ver_major = USB_AUDIO_BCD44_TO_DEC(bcdADC>>8);\n    ver = ver_major + USB_AUDIO_BCD44_TO_DEC(bcdADC&0xFF) / 100.0;\n\n    proto_tree_add_double_format_value(tree, hf_ms_if_hdr_ver,\n            tvb, offset, 2, ver, \"%2.2f\", ver);\n    offset += 2;\n\n    proto_tree_add_item(tree, hf_ms_if_hdr_total_len,\n                tvb, offset, 2, ENC_LITTLE_ENDIAN);\n    offset += 2;\n\n    return offset-offset_start;\n}\n\nstatic int\ndissect_ms_if_midi_in_body(tvbuff_t *tvb, int offset, packet_info *pinfo _U_,\n        proto_tree *tree, urb_info_t *urb _U_)\n{\n    int      offset_start = offset;\n\n    proto_tree_add_item(tree, hf_ms_if_midi_in_bjacktype, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    offset += 1;\n    proto_tree_add_item(tree, hf_ms_if_midi_in_bjackid, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    offset += 1;\n    proto_tree_add_item(tree, hf_ms_if_midi_in_ijack, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    offset += 1;\n\n    return offset-offset_start;\n}\n\nstatic int\ndissect_ms_if_midi_out_body(tvbuff_t *tvb, int offset, packet_info *pinfo _U_,\n        proto_tree *tree, urb_info_t *urb _U_)\n{\n    int      offset_start = offset;\n    uint8_t  nrinputpins;\n\n    proto_tree_add_item(tree, hf_ms_if_midi_out_bjacktype, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    offset += 1;\n    proto_tree_add_item(tree, hf_ms_if_midi_out_bjackid, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    offset += 1;\n\n    proto_tree_add_item(tree, hf_ms_if_midi_out_bnrinputpins, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    nrinputpins = tvb_get_uint8(tvb, offset);\n    offset += 1;\n    while (nrinputpins)\n    {\n        proto_tree_add_item(tree, hf_ms_if_midi_out_basourceid, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n        offset += 1;\n        proto_tree_add_item(tree, hf_ms_if_midi_out_basourcepin, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n        offset += 1;\n        nrinputpins--;\n    }\n\n    proto_tree_add_item(tree, hf_ms_if_midi_out_ijack, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    offset += 1;\n\n    return offset-offset_start;\n}\n\nstatic int\ndissect_ms_ep_general_body(tvbuff_t *tvb, int offset, packet_info *pinfo _U_,\n        proto_tree *tree, urb_info_t *urb _U_)\n{\n    int      offset_start = offset;\n    uint8_t  numjacks;\n\n    proto_tree_add_item(tree, hf_ms_ep_gen_numjacks, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    numjacks = tvb_get_uint8(tvb, offset);\n    offset += 1;\n    while (numjacks)\n    {\n        proto_tree_add_item(tree, hf_ms_ep_gen_baassocjackid, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n        offset += 1;\n        numjacks--;\n    }\n\n    return offset-offset_start;\n}\n\nstatic int\ndissect_usb_audio_descriptor(tvbuff_t *tvb, packet_info *pinfo,\n        proto_tree *tree, void *data)\n{\n    int              offset = 0;\n    int              bytes_dissected = 0;\n    urb_info_t      *urb;\n    proto_tree       *desc_tree = NULL;\n    proto_item       *desc_tree_item;\n    uint8_t          desc_len;\n    uint8_t          desc_type;\n    uint8_t          desc_subtype;\n    const char      *subtype_str;\n\n    urb = (urb_info_t *)data;\n    if (!urb || !urb->conv || urb->conv->interfaceClass!=IF_CLASS_AUDIO)\n        return 0;\n\n    desc_len  = tvb_get_uint8(tvb, offset);\n    desc_type = tvb_get_uint8(tvb, offset+1);\n\n    if (desc_type == CS_INTERFACE) {\n        /* Switch to interface specific usb_conv_info */\n        urb = wmem_new(pinfo->pool, urb_info_t);\n        memcpy(urb, data, sizeof(urb_info_t));\n        urb->conv = get_usb_iface_conv_info(pinfo, urb->conv->interfaceNum);\n    }\n\n    if (desc_type==CS_INTERFACE &&\n            urb->conv->interfaceSubclass==AUDIO_IF_SUBCLASS_AUDIOCONTROL) {\n\n        desc_tree = proto_tree_add_subtree(tree, tvb, offset, desc_len,\n                ett_usb_audio_desc, &desc_tree_item,\n                \"Class-specific Audio Control Interface Descriptor\");\n\n        dissect_usb_descriptor_header(desc_tree, tvb, offset,\n            &aud_descriptor_type_vals_ext);\n        offset += 2;\n\n        desc_subtype = tvb_get_uint8(tvb, offset);\n        proto_tree_add_item(desc_tree, hf_ac_if_desc_subtype,\n                tvb, offset, 1, ENC_LITTLE_ENDIAN);\n        subtype_str = try_val_to_str_ext(desc_subtype, &ac_subtype_vals_ext);\n        if (subtype_str)\n            proto_item_append_text(desc_tree_item, \": %s\", subtype_str);\n        offset++;\n\n        bytes_dissected = offset;\n        switch(desc_subtype) {\n            case AC_SUBTYPE_HEADER:\n                /* these subfunctions return the number of bytes dissected,\n                   this is not necessarily the length of the body\n                   as some components are not yet dissected\n                   we rely on the descriptor's length byte instead */\n                bytes_dissected += dissect_ac_if_hdr_body(tvb, offset, pinfo, desc_tree, urb);\n                break;\n            case AC_SUBTYPE_INPUT_TERMINAL:\n                bytes_dissected += dissect_ac_if_input_terminal(tvb, offset, pinfo, desc_tree, urb);\n                break;\n            case AC_SUBTYPE_OUTPUT_TERMINAL:\n                bytes_dissected += dissect_ac_if_output_terminal(tvb, offset, pinfo, desc_tree, urb);\n                break;\n            case AC_SUBTYPE_MIXER_UNIT:\n                bytes_dissected += dissect_ac_if_mixed_unit(tvb, offset, pinfo, desc_tree, urb);\n                break;\n            case AC_SUBTYPE_SELECTOR_UNIT:\n                bytes_dissected += dissect_ac_if_selector_unit(tvb, offset, pinfo, desc_tree, urb);\n                break;\n            case AC_SUBTYPE_FEATURE_UNIT:\n                bytes_dissected += dissect_ac_if_feature_unit(tvb, offset, pinfo, desc_tree, urb, desc_len);\n                break;\n            case AC_SUBTYPE_CLOCK_SOURCE:\n                bytes_dissected += dissect_ac_if_clock_source(tvb, offset, pinfo, desc_tree, urb);\n                break;\n            case AC_SUBTYPE_CLOCK_SELECTOR:\n                bytes_dissected += dissect_ac_if_clock_selector(tvb, offset, pinfo, desc_tree, urb);\n                break;\n            case AC_SUBTYPE_EXTENSION_UNIT:\n                bytes_dissected += dissect_ac_if_extension_unit(tvb, offset, pinfo, desc_tree, urb);\n                break;\n            default:\n                break;\n        }\n    }\n    else if (desc_type==CS_INTERFACE &&\n            urb->conv->interfaceSubclass==AUDIO_IF_SUBCLASS_AUDIOSTREAMING) {\n\n        desc_tree = proto_tree_add_subtree(tree, tvb, offset, desc_len,\n                ett_usb_audio_desc, &desc_tree_item,\n                \"Class-specific Audio Streaming Interface Descriptor\");\n\n        dissect_usb_descriptor_header(desc_tree, tvb, offset,\n            &aud_descriptor_type_vals_ext);\n        offset += 2;\n\n        desc_subtype = tvb_get_uint8(tvb, offset);\n        proto_tree_add_item(desc_tree, hf_as_if_desc_subtype,\n                tvb, offset, 1, ENC_LITTLE_ENDIAN);\n        subtype_str = try_val_to_str_ext(desc_subtype, &as_subtype_vals_ext);\n        if (subtype_str)\n            proto_item_append_text(desc_tree_item, \": %s\", subtype_str);\n        offset++;\n\n        bytes_dissected = offset;\n        switch(desc_subtype) {\n            case AS_SUBTYPE_GENERAL:\n                bytes_dissected += dissect_as_if_general_body(tvb, offset, pinfo,\n                        desc_tree, urb);\n                break;\n            case AS_SUBTYPE_FORMAT_TYPE:\n                bytes_dissected += dissect_as_if_format_type_body(tvb, offset, pinfo,\n                        desc_tree, urb);\n                break;\n            default:\n                break;\n        }\n    }\n    /* there are no class-specific endpoint descriptors for audio control */\n    else if (desc_type == CS_ENDPOINT &&\n            urb->conv->interfaceSubclass==AUDIO_IF_SUBCLASS_AUDIOSTREAMING) {\n\n        desc_tree = proto_tree_add_subtree(tree, tvb, offset, desc_len,\n                ett_usb_audio_desc, &desc_tree_item,\n                \"Class-specific Audio Streaming Endpoint Descriptor\");\n\n        dissect_usb_descriptor_header(desc_tree, tvb, offset,\n            &aud_descriptor_type_vals_ext);\n        offset += 2;\n\n        desc_subtype = tvb_get_uint8(tvb, offset);\n        proto_tree_add_item(desc_tree, hf_as_ep_desc_subtype,\n                tvb, offset, 1, ENC_LITTLE_ENDIAN);\n        offset++;\n\n        bytes_dissected = offset;\n        switch(desc_subtype) {\n            case AS_EP_SUBTYPE_GENERAL:\n                bytes_dissected += dissect_as_ep_general_body(tvb, offset, pinfo,\n                        desc_tree, urb);\n                break;\n            default:\n                break;\n        }\n    }\n    else if (desc_type==CS_INTERFACE &&\n            urb->conv->interfaceSubclass==AUDIO_IF_SUBCLASS_MIDISTREAMING) {\n        desc_tree = proto_tree_add_subtree(tree, tvb, offset, desc_len,\n                ett_usb_audio_desc, &desc_tree_item,\n                \"Class-specific MIDI Streaming Interface Descriptor\");\n\n        dissect_usb_descriptor_header(desc_tree, tvb, offset,\n            &aud_descriptor_type_vals_ext);\n        offset += 2;\n\n        desc_subtype = tvb_get_uint8(tvb, offset);\n        proto_tree_add_item(desc_tree, hf_ms_if_desc_subtype,\n                tvb, offset, 1, ENC_LITTLE_ENDIAN);\n        subtype_str = try_val_to_str_ext(desc_subtype, &ms_if_subtype_vals_ext);\n        if (subtype_str)\n            proto_item_append_text(desc_tree_item, \": %s\", subtype_str);\n        offset++;\n\n        bytes_dissected = offset;\n        switch(desc_subtype) {\n            case MS_IF_SUBTYPE_HEADER:\n                bytes_dissected += dissect_ms_if_hdr_body(tvb, offset, pinfo,\n                        desc_tree, urb);\n                break;\n            case MS_IF_SUBTYPE_MIDI_IN_JACK:\n                bytes_dissected += dissect_ms_if_midi_in_body(tvb, offset, pinfo,\n                        desc_tree, urb);\n                break;\n            case MS_IF_SUBTYPE_MIDI_OUT_JACK:\n                bytes_dissected += dissect_ms_if_midi_out_body(tvb, offset, pinfo,\n                        desc_tree, urb);\n                break;\n            default:\n                break;\n        }\n    }\n    else if (desc_type==CS_ENDPOINT &&\n            urb->conv->interfaceSubclass==AUDIO_IF_SUBCLASS_MIDISTREAMING) {\n        desc_tree = proto_tree_add_subtree(tree, tvb, offset, desc_len,\n                ett_usb_audio_desc, &desc_tree_item,\n                \"Class-specific MIDI Streaming Endpoint Descriptor\");\n\n        dissect_usb_descriptor_header(desc_tree, tvb, offset,\n            &aud_descriptor_type_vals_ext);\n        offset += 2;\n\n        desc_subtype = tvb_get_uint8(tvb, offset);\n        proto_tree_add_item(desc_tree, hf_ms_ep_desc_subtype,\n                tvb, offset, 1, ENC_LITTLE_ENDIAN);\n        offset++;\n\n        bytes_dissected = offset;\n        switch(desc_subtype) {\n            case MS_EP_SUBTYPE_GENERAL:\n                bytes_dissected += dissect_ms_ep_general_body(tvb, offset, pinfo,\n                        desc_tree, urb);\n                break;\n            default:\n                break;\n        }\n    }\n    else\n        return 0;\n\n    if (bytes_dissected < desc_len) {\n        proto_tree_add_expert(desc_tree, pinfo, &ei_usb_audio_undecoded, tvb, bytes_dissected, desc_len-bytes_dissected);\n    }\n    return desc_len;\n}\n\nstatic usb_audio_entity_t\nget_addressed_entity_type(urb_info_t *urb)\n{\n    usb_audio_entity_t  entity = USB_AUDIO_ENTITY_UNKNOWN;\n\n    if (USB_RECIPIENT(urb->usb_trans_info->setup.requesttype) == RQT_SETUP_RECIPIENT_INTERFACE) {\n        int8_t id = (urb->usb_trans_info->setup.wIndex & 0xFF00) >> 8;\n        entity = get_entity_type(urb, id);\n    }\n\n    return entity;\n}\n\nstatic bool\nhas_data_stage(urb_info_t *urb)\n{\n    /* If the two conditions are fulfilled, then URB we got should contain data stage */\n    return (urb->usb_trans_info->setup.wLength > 0) &&\n        (urb->usb_trans_info->setup.requesttype & USB_DIR_IN) == (urb->is_request ? USB_DIR_OUT : USB_DIR_IN);\n}\n\nstatic int\ndissect_windex_and_wlength(tvbuff_t *tvb, int offset, packet_info *pinfo _U_,\n                           proto_tree *tree, urb_info_t *urb)\n{\n    int                 offset_start = offset;\n    static int * const  windex_interface[] = {\n        &hf_windex_interface,\n        &hf_windex_entity_id,\n        NULL\n    };\n    static int * const  windex_endpoint[] = {\n        &hf_windex_endpoint,\n        NULL\n    };\n\n    if (USB_RECIPIENT(urb->usb_trans_info->setup.requesttype) == RQT_SETUP_RECIPIENT_INTERFACE) {\n        proto_tree_add_bitmask(tree, tvb, offset, hf_windex, ett_windex, windex_interface, ENC_LITTLE_ENDIAN);\n    } else if (USB_RECIPIENT(urb->usb_trans_info->setup.requesttype) == RQT_SETUP_RECIPIENT_ENDPOINT) {\n        proto_tree_add_bitmask(tree, tvb, offset, hf_windex, ett_windex, windex_endpoint, ENC_LITTLE_ENDIAN);\n    }\n    offset += 2;\n\n    proto_tree_add_item(tree, hf_wlength, tvb, offset, 2, ENC_LITTLE_ENDIAN);\n    offset += 2;\n\n    return offset - offset_start;\n}\n\nstatic int\ndissect_v1_control(tvbuff_t *tvb, int offset, packet_info *pinfo,\n                   proto_tree *tree, urb_info_t *urb)\n{\n    int                 offset_start = offset;\n    proto_item         *ti;\n    const char         *request_str;\n    uint8_t             bRequest;\n    usb_audio_entity_t  entity = get_addressed_entity_type(urb);\n    const value_string *control_selector_vals = NULL;\n    uint8_t             control_selector;\n    const char         *str;\n    const char         *title = \"Unknown Parameter Block\";\n    int                *parameter_hf = NULL;\n    int                 attribute_size;\n    int                *wvalue_fields[] = {\n        NULL, /* Channel number or zero */\n        NULL, /* Control selector if known */\n        NULL\n    };\n\n    bRequest = urb->usb_trans_info->setup.request;\n    request_str = try_val_to_str_ext(bRequest, &v1_brequest_vals_ext);\n    if (request_str)\n        col_set_str(pinfo->cinfo, COL_INFO, request_str);\n\n    control_selector = (urb->usb_trans_info->setup.wValue & 0xFF00) >> 8;\n\n    switch (entity) {\n        case USB_AUDIO_ENTITY_SELECTOR:\n            col_append_str(pinfo->cinfo, COL_INFO, \" SELECTOR\");\n            parameter_hf = &hf_parameter_bselector;\n            attribute_size = 1;\n            title = \"Selector Control Parameter Block\";\n            break;\n        case USB_AUDIO_ENTITY_FEATURE_UNIT:\n            wvalue_fields[0] = &hf_wvalue_channel_number;\n            wvalue_fields[1] = &hf_wvalue_fu_cs_v1;\n            control_selector_vals = v1_fu_cs_vals;\n            if (control_selector == MUTE_CONTROL) {\n                parameter_hf = &hf_parameter_bmute;\n                attribute_size = 1;\n                title = \"Mute Control Parameter Block\";\n            } else if (control_selector == VOLUME_CONTROL) {\n                parameter_hf = &hf_parameter_wvolume;\n                attribute_size = 2;\n                title = \"Volume Control Parameter Block\";\n            }\n            break;\n        default:\n            break;\n    }\n\n    str = control_selector_vals ? try_val_to_str(control_selector, control_selector_vals) : NULL;\n    if (str) {\n        col_append_fstr(pinfo->cinfo, COL_INFO, \" %s\", str);\n    }\n\n    if (urb->is_request) {\n        proto_tree_add_item(tree, hf_brequest_v1, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n        offset++;\n\n        if (wvalue_fields[0]) {\n            proto_tree_add_bitmask(tree, tvb, offset, hf_wvalue, ett_wvalue, wvalue_fields, ENC_LITTLE_ENDIAN);\n        } else {\n            ti = proto_tree_add_item(tree, hf_wvalue, tvb, offset, 2, ENC_LITTLE_ENDIAN);\n            /* Selector doesn't use wValue (must be zero), all others do use it */\n            if (entity != USB_AUDIO_ENTITY_SELECTOR) {\n                expert_add_info(pinfo, ti, &ei_usb_audio_undecoded);\n            }\n        }\n        offset += 2;\n\n        offset += dissect_windex_and_wlength(tvb, offset, pinfo, tree, urb);\n\n    }\n\n    if (has_data_stage(urb)) {\n        proto_tree  *subtree;\n        proto_item  *subtree_item;\n\n        subtree = proto_tree_add_subtree(tree, tvb, offset, -1, ett_parameter_block, &subtree_item, title);\n\n        if (parameter_hf) {\n            proto_tree_add_item(subtree, *parameter_hf, tvb, offset, attribute_size, ENC_LITTLE_ENDIAN);\n            offset += attribute_size;\n        }\n\n        if (tvb_captured_length_remaining(tvb, offset)) {\n            expert_add_info(pinfo, subtree_item, &ei_usb_audio_undecoded);\n            offset += tvb_captured_length_remaining(tvb, offset);\n        }\n    }\n\n    return offset - offset_start;\n}\n\nstatic int\ndissect_v2_control_cur_range(tvbuff_t *tvb, int offset, packet_info *pinfo,\n                             proto_tree *tree, urb_info_t *urb)\n{\n    int                 offset_start = offset;\n    proto_item         *ti;\n    usb_audio_entity_t  entity = get_addressed_entity_type(urb);\n    const value_string *control_selector_vals = NULL;\n    uint8_t             control_selector, channel_number;\n    parameter_layout_t  layout = PARAMETER_LAYOUT_UNKNOWN;\n    const char         *parameter_str = NULL;\n    const char         *str;\n    int                *wvalue_fields[] = {\n        &hf_wvalue_channel_number,\n        NULL, /* Control selector if known */\n        NULL\n    };\n\n    control_selector = (urb->usb_trans_info->setup.wValue & 0xFF00) >> 8;\n    channel_number = urb->usb_trans_info->setup.wValue & 0x00FF;\n\n    switch (entity) {\n        case USB_AUDIO_ENTITY_CLOCK_SOURCE:\n            wvalue_fields[1] = &hf_wvalue_clksrc_cs;\n            control_selector_vals = v2_clksrc_cs_vals;\n            if ((control_selector == V2_CS_SAM_FREQ_CONTROL) && (channel_number == 0)) {\n                layout = PARAMETER_LAYOUT_3;\n                parameter_str = \"Frequency [Hz]\";\n            } else if (control_selector == V2_CS_CLOCK_VALID_CONTROL) {\n                layout = PARAMETER_LAYOUT_1;\n                parameter_str = \"Clock Validity\";\n            }\n            break;\n        case USB_AUDIO_ENTITY_CLOCK_SELECTOR:\n            wvalue_fields[1] = &hf_wvalue_clksel_cs;\n            control_selector_vals = v2_clksel_cs_vals;\n            if ((control_selector == V2_CX_CLOCK_SELECTOR_CONTROL) && (channel_number == 0)) {\n                layout = PARAMETER_LAYOUT_1;\n                parameter_str = \"Clock Input Pin\";\n            }\n            break;\n        default:\n            break;\n    }\n\n    str = control_selector_vals ? try_val_to_str(control_selector, control_selector_vals) : NULL;\n    if (str) {\n        col_append_fstr(pinfo->cinfo, COL_INFO, \" %s\", str);\n    }\n\n    if (urb->is_request) {\n        ti = proto_tree_add_bitmask(tree, tvb, offset, hf_wvalue, ett_wvalue, wvalue_fields, ENC_LITTLE_ENDIAN);\n        if (wvalue_fields[1] == NULL) {\n            /* Control selector not handled, mark as undecoded */\n            expert_add_info(pinfo, ti, &ei_usb_audio_undecoded);\n        }\n        offset += 2;\n\n        offset += dissect_windex_and_wlength(tvb, offset, pinfo, tree, urb);\n    }\n\n    if (has_data_stage(urb)) {\n        proto_tree  *subtree;\n        proto_item  *subtree_item;\n        const char *title;\n        uint32_t     n;\n        int          attribute_size;\n        int          cur_hf, min_hf, max_hf, res_hf;\n\n        switch (layout) {\n            case PARAMETER_LAYOUT_1:\n                title = \"Layout 1 Parameter Block\";\n                attribute_size = 1;\n                cur_hf = hf_parameter_bcur;\n                min_hf = hf_parameter_bmin;\n                max_hf = hf_parameter_bmax;\n                res_hf = hf_parameter_bres;\n                break;\n            case PARAMETER_LAYOUT_2:\n                title = \"Layout 2 Parameter Block\";\n                attribute_size = 2;\n                cur_hf = hf_parameter_wcur;\n                min_hf = hf_parameter_wmin;\n                max_hf = hf_parameter_wmax;\n                res_hf = hf_parameter_wres;\n                break;\n            case PARAMETER_LAYOUT_3:\n                title = \"Layout 3 Parameter Block\";\n                attribute_size = 4;\n                cur_hf = hf_parameter_dcur;\n                min_hf = hf_parameter_dmin;\n                max_hf = hf_parameter_dmax;\n                res_hf = hf_parameter_dres;\n                break;\n            default:\n                title = \"Unknown Layout Parameter Block\";\n                attribute_size = 0;\n                cur_hf = min_hf = max_hf = res_hf = 0;\n                break;\n        }\n\n        subtree = proto_tree_add_subtree(tree, tvb, offset, -1, ett_parameter_block, &subtree_item, title);\n        if (parameter_str) {\n            proto_item_append_text(subtree_item, \": %s\", parameter_str);\n        }\n\n        if (urb->usb_trans_info->setup.request == V2_REQUEST_RANGE) {\n            uint32_t  max_n;\n\n            proto_tree_add_item_ret_uint(subtree, hf_parameter_wnumsubranges, tvb, offset, 2, ENC_LITTLE_ENDIAN, &n);\n            offset += 2;\n\n            if (attribute_size == 0) {\n                max_n = 0;\n            } else if (urb->usb_trans_info->setup.wLength >= 2 + n * attribute_size) {\n                /* Host requested enough bytes to contain all data */\n                max_n = n;\n            } else if (urb->usb_trans_info->setup.wLength > 2) {\n                /* Host requested less, this is not Malformed in any way */\n                max_n = (urb->usb_trans_info->setup.wLength - 2) / (3 * attribute_size);\n            } else {\n                max_n = 0;\n            }\n\n            for (uint32_t i = 0; i < max_n; i++) {\n                proto_tree_add_item(subtree, min_hf, tvb, offset, attribute_size, ENC_LITTLE_ENDIAN);\n                offset += attribute_size;\n                proto_tree_add_item(subtree, max_hf, tvb, offset, attribute_size, ENC_LITTLE_ENDIAN);\n                offset += attribute_size;\n                proto_tree_add_item(subtree, res_hf, tvb, offset, attribute_size, ENC_LITTLE_ENDIAN);\n                offset += attribute_size;\n            }\n        } else if (attribute_size) {\n            proto_tree_add_item(subtree, cur_hf, tvb, offset, attribute_size, ENC_LITTLE_ENDIAN);\n            offset += attribute_size;\n        } else {\n            expert_add_info(pinfo, subtree_item, &ei_usb_audio_undecoded);\n            offset += tvb_captured_length_remaining(tvb, offset);\n        }\n    }\n\n    return offset - offset_start;\n}\n\nstatic int\ndissect_v2_control(tvbuff_t *tvb, int offset, packet_info *pinfo,\n                   proto_tree *tree, urb_info_t *urb)\n{\n    int          offset_start = offset;\n    const char *request_str;\n    uint8_t      bRequest;\n\n    bRequest = urb->usb_trans_info->setup.request;\n    request_str = try_val_to_str_ext(bRequest, &v2_brequest_vals_ext);\n    if (request_str)\n        col_append_fstr(pinfo->cinfo, COL_INFO, \" %s\", request_str);\n\n    if (urb->is_request) {\n        proto_tree_add_item(tree, hf_brequest_v2, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n        offset++;\n    }\n\n    if ((bRequest == V2_REQUEST_CUR) || (bRequest == V2_REQUEST_RANGE)) {\n        offset += dissect_v2_control_cur_range(tvb, offset, pinfo, tree, urb);\n    }\n\n    return offset - offset_start;\n}\n\nstatic int\ndissect_usb_audio_control(tvbuff_t *tvb, packet_info *pinfo, proto_tree *parent_tree, void *data)\n{\n    urb_info_t      *urb = (urb_info_t *)data;\n    int              offset, length;\n\n    /* Reject the packet if data is NULL */\n    if ((urb == NULL) || (urb->conv == NULL))\n        return 0;\n\n    /* Dissect only Class requests directed to interface or endpoint */\n    if ((urb->usb_trans_info == NULL) ||\n        (USB_TYPE(urb->usb_trans_info->setup.requesttype) != RQT_SETUP_TYPE_CLASS) ||\n        !(USB_RECIPIENT(urb->usb_trans_info->setup.requesttype) == RQT_SETUP_RECIPIENT_INTERFACE ||\n          USB_RECIPIENT(urb->usb_trans_info->setup.requesttype) == RQT_SETUP_RECIPIENT_ENDPOINT)) {\n        return 0;\n    }\n\n    col_set_str(pinfo->cinfo, COL_PROTOCOL, \"USBAUDIO\");\n    col_set_str(pinfo->cinfo, COL_INFO, urb->usb_trans_info->setup.requesttype & USB_DIR_IN ? \"GET\" : \"SET\");\n\n    length = tvb_reported_length(tvb);\n    offset = 0;\n\n    if ((urb->conv->interfaceClass == IF_CLASS_AUDIO) &&\n        (urb->conv->interfaceSubclass == AUDIO_IF_SUBCLASS_AUDIOCONTROL)) {\n        switch (urb->conv->interfaceProtocol) {\n            case AUDIO_PROTOCOL_V1:\n                offset += dissect_v1_control(tvb, offset, pinfo, parent_tree, urb);\n                break;\n            case AUDIO_PROTOCOL_V2:\n                offset += dissect_v2_control(tvb, offset, pinfo, parent_tree, urb);\n                break;\n            default:\n                break;\n        }\n    }\n\n    if (!urb->is_request &&\n        (((urb->usb_trans_info->setup.requesttype & USB_DIR_IN) == USB_DIR_OUT) ||\n          (urb->usb_trans_info->setup.wLength == 0))) {\n        /* We are dissecting URB status information, it is not really a \"response\" */\n        col_append_str(pinfo->cinfo, COL_INFO, \" status\");\n    } else {\n        col_append_str(pinfo->cinfo, COL_INFO, urb->is_request ? \" request\" : \" response\");\n    }\n\n    if (offset < length) {\n        proto_tree_add_expert(parent_tree, pinfo, &ei_usb_audio_undecoded, tvb, offset, length - offset);\n    }\n\n    return length;\n}\n\n/* dissector for usb midi bulk data */\nstatic int\ndissect_usb_audio_bulk(tvbuff_t *tvb, packet_info *pinfo, proto_tree *parent_tree, void *data)\n{\n    urb_info_t      *urb = (urb_info_t *)data;\n    int              offset, length;\n    int              i;\n\n    /* Reject the packet if data is NULL */\n    if ((urb == NULL) || (urb->conv == NULL))\n        return 0;\n\n    col_set_str(pinfo->cinfo, COL_PROTOCOL, \"USBAUDIO\");\n\n    length = tvb_reported_length(tvb);\n    offset = 0;\n\n    switch (urb->conv->interfaceSubclass)\n    {\n        case AUDIO_IF_SUBCLASS_MIDISTREAMING:\n            col_set_str(pinfo->cinfo, COL_INFO, \"USB-MIDI Event Packets\");\n\n            for (i = 0; i < length / 4; i++)\n            {\n                dissect_usb_midi_event(tvb, pinfo, parent_tree, offset);\n                offset += 4;\n            }\n            break;\n        default:\n            proto_tree_add_expert(parent_tree, pinfo, &ei_usb_audio_undecoded, tvb, offset, length);\n    }\n\n    return length;\n}\n\nvoid\nproto_register_usb_audio(void)\n{\n    static hf_register_info hf[] = {\n        { &hf_midi_cable_number,\n            { \"Cable Number\", \"usbaudio.midi.cable_number\", FT_UINT8, BASE_HEX,\n              NULL, 0xF0, NULL, HFILL }},\n        { &hf_midi_code_index,\n            { \"Code Index\", \"usbaudio.midi.code_index\", FT_UINT8, BASE_HEX,\n              VALS(code_index_vals), 0x0F, NULL, HFILL }},\n        { &hf_midi_event,\n            { \"MIDI Event\", \"usbaudio.midi.event\", FT_BYTES, BASE_NONE,\n              NULL, 0x0, NULL, HFILL }},\n        { &hf_midi_padding,\n            { \"Padding\", \"usbaudio.midi.padding\", FT_BYTES, BASE_NONE,\n              NULL, 0x0, \"Must be zero\", HFILL }},\n\n        { &hf_ac_if_desc_subtype,\n            { \"Subtype\", \"usbaudio.ac_if_subtype\", FT_UINT8, BASE_HEX|BASE_EXT_STRING,\n                &ac_subtype_vals_ext, 0x0, \"bDescriptorSubtype\", HFILL }},\n        { &hf_ac_if_hdr_ver,\n            { \"Version\", \"usbaudio.ac_if_hdr.bcdADC\",\n                FT_DOUBLE, BASE_NONE, NULL, 0, \"bcdADC\", HFILL }},\n        { &hf_ac_if_hdr_total_len,\n            { \"Total length\", \"usbaudio.ac_if_hdr.wTotalLength\",\n              FT_UINT16, BASE_DEC, NULL, 0x0, \"wTotalLength\", HFILL }},\n        { &hf_ac_if_hdr_bInCollection,\n            { \"Total number of interfaces\", \"usbaudio.ac_if_hdr.bInCollection\",\n              FT_UINT8, BASE_DEC, NULL, 0x0, \"bInCollection\", HFILL }},\n        { &hf_ac_if_hdr_if_num,\n            { \"Interface number\", \"usbaudio.ac_if_hdr.baInterfaceNr\",\n              FT_UINT8, BASE_DEC, NULL, 0x0, \"baInterfaceNr\", HFILL }},\n        { &hf_ac_if_hdr_category,\n            { \"Category\", \"usbaudio.ac_if_hdr.bCategory\",\n              FT_UINT8, BASE_HEX|BASE_EXT_STRING, &audio_function_categories_vals_ext, 0x00, \"bCategory\", HFILL }},\n        { &hf_ac_if_hdr_controls,\n            { \"Controls\", \"usbaudio.ac_if_hdr.bmControls\",\n              FT_UINT8, BASE_HEX, NULL, 0x0, \"bmControls\", HFILL }},\n        { &hf_ac_if_hdr_controls_latency,\n            { \"Latency Control\", \"usbaudio.ac_if_hdr.bmControls.latency\",\n              FT_UINT8, BASE_HEX|BASE_EXT_STRING, &controls_capabilities_vals_ext, 0x03, NULL, HFILL }},\n        { &hf_ac_if_hdr_controls_rsv,\n            { \"Reserved\", \"usbaudio.ac_if_hdr.bmControls.rsv\",\n              FT_UINT8, BASE_HEX, NULL, 0xFC, \"Must be zero\", HFILL }},\n        { &hf_ac_if_input_terminalid,\n            { \"Terminal ID\", \"usbaudio.ac_if_input.bTerminalID\",\n              FT_UINT8, BASE_DEC, NULL, 0x0, \"bTerminalID\", HFILL }},\n        { &hf_ac_if_input_terminaltype,\n            { \"Terminal Type\", \"usbaudio.ac_if_input.wTerminalType\", FT_UINT16,\n              BASE_HEX|BASE_EXT_STRING, &terminal_types_vals_ext, 0x00, \"wTerminalType\", HFILL }},\n        { &hf_ac_if_input_assocterminal,\n            { \"Assoc Terminal\", \"usbaudio.ac_if_input.bAssocTerminal\",\n              FT_UINT8, BASE_DEC, NULL, 0x0, \"bAssocTerminal\", HFILL }},\n        { &hf_ac_if_input_csourceid,\n            { \"Connected Clock Entity\", \"usbaudio.ac_if_input.bCSourceID\",\n              FT_UINT8, BASE_DEC, NULL, 0x0, \"bCSourceID\", HFILL }},\n        { &hf_ac_if_input_nrchannels,\n            { \"Number Channels\", \"usbaudio.ac_if_input.bNrChannels\",\n              FT_UINT8, BASE_DEC, NULL, 0x0, \"bNrChannels\", HFILL }},\n        { &hf_ac_if_input_wchannelconfig,\n            { \"Channel Config\", \"usbaudio.ac_if_input.wChannelConfig\",\n              FT_UINT16, BASE_HEX, NULL, 0x0, \"wChannelConfig\", HFILL }},\n        { &hf_ac_if_input_wchannelconfig_d0,\n            { \"Left Front\", \"usbaudio.ac_if_input.wChannelConfig.d0\",\n              FT_BOOLEAN, 16, NULL, 0x0001, NULL, HFILL }},\n        { &hf_ac_if_input_wchannelconfig_d1,\n            { \"Right Front\", \"usbaudio.ac_if_input.wChannelConfig.d1\",\n              FT_BOOLEAN, 16, NULL, 0x0002, NULL, HFILL }},\n        { &hf_ac_if_input_wchannelconfig_d2,\n            { \"Center Front\", \"usbaudio.ac_if_input.wChannelConfig.d2\",\n              FT_BOOLEAN, 16, NULL, 0x0004, NULL, HFILL }},\n        { &hf_ac_if_input_wchannelconfig_d3,\n            { \"Low Frequency Enhancement\", \"usbaudio.ac_if_input.wChannelConfig.d3\",\n              FT_BOOLEAN, 16, NULL, 0x0008, NULL, HFILL }},\n        { &hf_ac_if_input_wchannelconfig_d4,\n            { \"Left Surround\", \"usbaudio.ac_if_input.wChannelConfig.d4\",\n              FT_BOOLEAN, 16, NULL, 0x0010, NULL, HFILL }},\n        { &hf_ac_if_input_wchannelconfig_d5,\n            { \"Right Surround\", \"usbaudio.ac_if_input.wChannelConfig.d5\",\n              FT_BOOLEAN, 16, NULL, 0x0020, NULL, HFILL }},\n        { &hf_ac_if_input_wchannelconfig_d6,\n            { \"Left of Center\", \"usbaudio.ac_if_input.wChannelConfig.d6\",\n              FT_BOOLEAN, 16, NULL, 0x0040, NULL, HFILL }},\n        { &hf_ac_if_input_wchannelconfig_d7,\n            { \"Right of Center\", \"usbaudio.ac_if_input.wChannelConfig.d7\",\n              FT_BOOLEAN, 16, NULL, 0x0080, NULL, HFILL }},\n        { &hf_ac_if_input_wchannelconfig_d8,\n            { \"Surround\", \"usbaudio.ac_if_input.wChannelConfig.d8\",\n              FT_BOOLEAN, 16, NULL, 0x0100, NULL, HFILL }},\n        { &hf_ac_if_input_wchannelconfig_d9,\n            { \"Side Left\", \"usbaudio.ac_if_input.wChannelConfig.d9\",\n              FT_BOOLEAN, 16, NULL, 0x0200, NULL, HFILL }},\n        { &hf_ac_if_input_wchannelconfig_d10,\n            { \"Side Right\", \"usbaudio.ac_if_input.wChannelConfig.d10\",\n              FT_BOOLEAN, 16, NULL, 0x0400, NULL, HFILL }},\n        { &hf_ac_if_input_wchannelconfig_d11,\n            { \"Top\", \"usbaudio.ac_if_input.wChannelConfig.d11\",\n              FT_BOOLEAN, 16, NULL, 0x0800, NULL, HFILL }},\n        { &hf_ac_if_input_wchannelconfig_rsv,\n            { \"Reserved\", \"usbaudio.ac_if_input.wChannelConfig.rsv\",\n              FT_UINT16, BASE_HEX, NULL, 0xF000, NULL, HFILL }},\n        { &hf_ac_if_input_bmchannelconfig,\n            { \"Channel Config\", \"usbaudio.ac_if_input.bmChannelConfig\",\n              FT_UINT32, BASE_HEX, NULL, 0x0, \"bmChannelConfig\", HFILL }},\n        { &hf_ac_if_input_bmchannelconfig_d0,\n            { \"Front Left\", \"usbaudio.ac_if_input.bmChannelConfig.d0\",\n              FT_BOOLEAN, 32, NULL, (1u << 0), NULL, HFILL }},\n        { &hf_ac_if_input_bmchannelconfig_d1,\n            { \"Front Right\", \"usbaudio.ac_if_input.bmChannelConfig.d1\",\n              FT_BOOLEAN, 32, NULL, (1u << 1), NULL, HFILL }},\n        { &hf_ac_if_input_bmchannelconfig_d2,\n            { \"Front Center\", \"usbaudio.ac_if_input.bmChannelConfig.d2\",\n              FT_BOOLEAN, 32, NULL, (1u << 2), NULL, HFILL }},\n        { &hf_ac_if_input_bmchannelconfig_d3,\n            { \"Low Frequency Effects\", \"usbaudio.ac_if_input.bmChannelConfig.d3\",\n              FT_BOOLEAN, 32, NULL, (1u << 3), NULL, HFILL }},\n        { &hf_ac_if_input_bmchannelconfig_d4,\n            { \"Back Left\", \"usbaudio.ac_if_input.bmChannelConfig.d4\",\n              FT_BOOLEAN, 32, NULL, (1u << 4), NULL, HFILL }},\n        { &hf_ac_if_input_bmchannelconfig_d5,\n            { \"Back Right\", \"usbaudio.ac_if_input.bmChannelConfig.d5\",\n              FT_BOOLEAN, 32, NULL, (1u << 5), NULL, HFILL }},\n        { &hf_ac_if_input_bmchannelconfig_d6,\n            { \"Front Left of Center\", \"usbaudio.ac_if_input.bmChannelConfig.d6\",\n              FT_BOOLEAN, 32, NULL, (1u << 6), NULL, HFILL }},\n        { &hf_ac_if_input_bmchannelconfig_d7,\n            { \"Front Right of Center\", \"usbaudio.ac_if_input.bmChannelConfig.d7\",\n              FT_BOOLEAN, 32, NULL, (1u << 7), NULL, HFILL }},\n        { &hf_ac_if_input_bmchannelconfig_d8,\n            { \"Back Center\", \"usbaudio.ac_if_input.bmChannelConfig.d8\",\n              FT_BOOLEAN, 32, NULL, (1u << 8), NULL, HFILL }},\n        { &hf_ac_if_input_bmchannelconfig_d9,\n            { \"Side Left\", \"usbaudio.ac_if_input.bmChannelConfig.d9\",\n              FT_BOOLEAN, 32, NULL, (1u << 9), NULL, HFILL }},\n        { &hf_ac_if_input_bmchannelconfig_d10,\n            { \"Side Right\", \"usbaudio.ac_if_input.bmChannelConfig.d10\",\n              FT_BOOLEAN, 32, NULL, (1u << 10), NULL, HFILL }},\n        { &hf_ac_if_input_bmchannelconfig_d11,\n            { \"Top Center\", \"usbaudio.ac_if_input.bmChannelConfig.d11\",\n              FT_BOOLEAN, 32, NULL, (1u << 11), NULL, HFILL }},\n        { &hf_ac_if_input_bmchannelconfig_d12,\n            { \"Top Front Left\", \"usbaudio.ac_if_input.bmChannelConfig.d12\",\n              FT_BOOLEAN, 32, NULL, (1u << 12), NULL, HFILL }},\n        { &hf_ac_if_input_bmchannelconfig_d13,\n            { \"Top Front Center\", \"usbaudio.ac_if_input.bmChannelConfig.d13\",\n              FT_BOOLEAN, 32, NULL, (1u << 13), NULL, HFILL }},\n        { &hf_ac_if_input_bmchannelconfig_d14,\n            { \"Top Front Right\", \"usbaudio.ac_if_input.bmChannelConfig.d14\",\n              FT_BOOLEAN, 32, NULL, (1u << 14), NULL, HFILL }},\n        { &hf_ac_if_input_bmchannelconfig_d15,\n            { \"Top Back Left\", \"usbaudio.ac_if_input.bmChannelConfig.d15\",\n              FT_BOOLEAN, 32, NULL, (1u << 15), NULL, HFILL }},\n        { &hf_ac_if_input_bmchannelconfig_d16,\n            { \"Top Back Center\", \"usbaudio.ac_if_input.bmChannelConfig.d16\",\n              FT_BOOLEAN, 32, NULL, (1u << 16), NULL, HFILL }},\n        { &hf_ac_if_input_bmchannelconfig_d17,\n            { \"Top Back Right\", \"usbaudio.ac_if_input.bmChannelConfig.d17\",\n              FT_BOOLEAN, 32, NULL, (1u << 17), NULL, HFILL }},\n        { &hf_ac_if_input_bmchannelconfig_d18,\n            { \"Top Front Left of Center\", \"usbaudio.ac_if_input.bmChannelConfig.d18\",\n              FT_BOOLEAN, 32, NULL, (1u << 18), NULL, HFILL }},\n        { &hf_ac_if_input_bmchannelconfig_d19,\n            { \"Top Front Right of Center\", \"usbaudio.ac_if_input.bmChannelConfig.d19\",\n              FT_BOOLEAN, 32, NULL, (1u << 19), NULL, HFILL }},\n        { &hf_ac_if_input_bmchannelconfig_d20,\n            { \"Left Low Frequency Effects\", \"usbaudio.ac_if_input.bmChannelConfig.d20\",\n              FT_BOOLEAN, 32, NULL, (1u << 20), NULL, HFILL }},\n        { &hf_ac_if_input_bmchannelconfig_d21,\n            { \"Right Low Frequency Effects\", \"usbaudio.ac_if_input.bmChannelConfig.d21\",\n              FT_BOOLEAN, 32, NULL, (1u << 21), NULL, HFILL }},\n        { &hf_ac_if_input_bmchannelconfig_d22,\n            { \"Top Side Left\", \"usbaudio.ac_if_input.bmChannelConfig.d22\",\n              FT_BOOLEAN, 32, NULL, (1u << 22), NULL, HFILL }},\n        { &hf_ac_if_input_bmchannelconfig_d23,\n            { \"Top Side Right\", \"usbaudio.ac_if_input.bmChannelConfig.d23\",\n              FT_BOOLEAN, 32, NULL, (1u << 23), NULL, HFILL }},\n        { &hf_ac_if_input_bmchannelconfig_d24,\n            { \"Bottom Center\", \"usbaudio.ac_if_input.bmChannelConfig.d24\",\n              FT_BOOLEAN, 32, NULL, (1u << 24), NULL, HFILL }},\n        { &hf_ac_if_input_bmchannelconfig_d25,\n            { \"Back Left of Center\", \"usbaudio.ac_if_input.bmChannelConfig.d25\",\n              FT_BOOLEAN, 32, NULL, (1u << 25), NULL, HFILL }},\n        { &hf_ac_if_input_bmchannelconfig_d26,\n            { \"Back Right of Center\", \"usbaudio.ac_if_input.bmChannelConfig.d26\",\n              FT_BOOLEAN, 32, NULL, (1u << 26), NULL, HFILL }},\n        { &hf_ac_if_input_bmchannelconfig_rsv,\n            { \"Reserved\", \"usbaudio.ac_if_input.bmChannelConfig.rsv\",\n              FT_BOOLEAN, 32, NULL, (0xFu << 27), NULL, HFILL }},\n        { &hf_ac_if_input_bmchannelconfig_d31,\n            { \"Raw Data\", \"usbaudio.ac_if_input.bmChannelConfig.d31\",\n              FT_BOOLEAN, 32, NULL, (1u << 31), NULL, HFILL }},\n        { &hf_ac_if_input_channelnames,\n            { \"Channel Names\", \"usbaudio.ac_if_input.iChannelNames\",\n              FT_UINT8, BASE_DEC, NULL, 0x0, \"iChannelNames\", HFILL }},\n        { &hf_ac_if_input_controls,\n            { \"Controls\", \"usbaudio.ac_if_input.bmControls\",\n              FT_UINT16, BASE_HEX, NULL, 0x0, \"bmControls\", HFILL }},\n        { &hf_ac_if_input_controls_copy,\n            { \"Copy Protect Control\", \"usbaudio.ac_if_input.bmControls.copy\", FT_UINT16,\n              BASE_HEX|BASE_EXT_STRING, &controls_capabilities_vals_ext, 0x0003, NULL, HFILL }},\n        { &hf_ac_if_input_controls_connector,\n            { \"Connector Control\", \"usbaudio.ac_if_input.bmControls.connector\", FT_UINT16,\n              BASE_HEX|BASE_EXT_STRING, &controls_capabilities_vals_ext, 0x000C, NULL, HFILL }},\n        { &hf_ac_if_input_controls_overload,\n            { \"Overload Control\", \"usbaudio.ac_if_input.bmControls.overload\", FT_UINT16,\n              BASE_HEX|BASE_EXT_STRING, &controls_capabilities_vals_ext, 0x0030, NULL, HFILL }},\n        { &hf_ac_if_input_controls_cluster,\n            { \"Cluster Control\", \"usbaudio.ac_if_input.bmControls.cluster\", FT_UINT16,\n              BASE_HEX|BASE_EXT_STRING, &controls_capabilities_vals_ext, 0x00C0, NULL, HFILL }},\n        { &hf_ac_if_input_controls_underflow,\n            { \"Underflow Control\", \"usbaudio.ac_if_input.bmControls.underflow\", FT_UINT16,\n              BASE_HEX|BASE_EXT_STRING, &controls_capabilities_vals_ext, 0x0300, NULL, HFILL }},\n        { &hf_ac_if_input_controls_overflow,\n            { \"Overflow Control\", \"usbaudio.ac_if_input.bmControls.overflow\", FT_UINT16,\n              BASE_HEX|BASE_EXT_STRING, &controls_capabilities_vals_ext, 0x0C00, NULL, HFILL }},\n        { &hf_ac_if_input_controls_rsv,\n            { \"Reserved\", \"usbaudio.ac_if_input.bmControls.rsv\",\n              FT_UINT16, BASE_HEX, NULL, 0xF000, \"Must be zero\", HFILL }},\n        { &hf_ac_if_input_terminal,\n            { \"String descriptor index\", \"usbaudio.ac_if_input.iTerminal\",\n              FT_UINT8, BASE_DEC, NULL, 0x0, \"iTerminal\", HFILL }},\n        { &hf_ac_if_output_terminalid,\n            { \"Terminal ID\", \"usbaudio.ac_if_output.bTerminalID\",\n              FT_UINT8, BASE_DEC, NULL, 0x0, \"bTerminalID\", HFILL }},\n        { &hf_ac_if_output_terminaltype,\n            { \"Terminal Type\", \"usbaudio.ac_if_output.wTerminalType\", FT_UINT16,\n               BASE_HEX|BASE_EXT_STRING, &terminal_types_vals_ext, 0x00, \"wTerminalType\", HFILL }},\n        { &hf_ac_if_output_assocterminal,\n            { \"Assoc Terminal\", \"usbaudio.ac_if_output.bAssocTerminal\",\n              FT_UINT8, BASE_DEC, NULL, 0x0, \"bAssocTerminal\", HFILL }},\n        { &hf_ac_if_output_sourceid,\n            { \"Source ID\", \"usbaudio.ac_if_output.bSourceID\",\n              FT_UINT8, BASE_DEC, NULL, 0x0, \"bSourceID\", HFILL }},\n        { &hf_ac_if_output_clk_sourceid,\n            { \"Connected Clock Entity\", \"usbaudio.ac_if_output.bCSourceID\",\n              FT_UINT8, BASE_DEC, NULL, 0x0, \"bCSourceID\", HFILL }},\n        { &hf_ac_if_output_controls,\n            { \"Controls\", \"usbaudio.ac_if_output.bmControls\",\n              FT_UINT16, BASE_HEX, NULL, 0x0, \"bmControls\", HFILL }},\n        { &hf_ac_if_output_controls_copy,\n            { \"Copy Protect Control\", \"usbaudio.ac_if_output.bmControls.copy\", FT_UINT16,\n              BASE_HEX|BASE_EXT_STRING, &controls_capabilities_vals_ext, 0x0003, NULL, HFILL }},\n        { &hf_ac_if_output_controls_connector,\n            { \"Connector Control\", \"usbaudio.ac_if_output.bmControls.connector\", FT_UINT16,\n              BASE_HEX|BASE_EXT_STRING, &controls_capabilities_vals_ext, 0x000C, NULL, HFILL }},\n        { &hf_ac_if_output_controls_overload,\n            { \"Overload Control\", \"usbaudio.ac_if_output.bmControls.overload\", FT_UINT16,\n              BASE_HEX|BASE_EXT_STRING, &controls_capabilities_vals_ext, 0x0030, NULL, HFILL }},\n        { &hf_ac_if_output_controls_underflow,\n            { \"Underflow Control\", \"usbaudio.ac_if_output.bmControls.underflow\", FT_UINT16,\n              BASE_HEX|BASE_EXT_STRING, &controls_capabilities_vals_ext, 0x00C0, NULL, HFILL }},\n        { &hf_ac_if_output_controls_overflow,\n            { \"Overflow Control\", \"usbaudio.ac_if_output.bmControls.overflow\", FT_UINT16,\n              BASE_HEX|BASE_EXT_STRING, &controls_capabilities_vals_ext, 0x0300, NULL, HFILL }},\n        { &hf_ac_if_output_controls_rsv,\n            { \"Reserved\", \"usbaudio.ac_if_output.bmControls.rsv\",\n              FT_UINT16, BASE_HEX, NULL, 0xFC00, \"Must be zero\", HFILL }},\n        { &hf_ac_if_output_terminal,\n            { \"String descriptor index\", \"usbaudio.ac_if_output.iTerminal\",\n              FT_UINT8, BASE_DEC, NULL, 0x0, \"iTerminal\", HFILL }},\n        { &hf_ac_if_fu_unitid,\n            { \"Unit ID\", \"usbaudio.ac_if_fu.bUnitID\",\n              FT_UINT8, BASE_DEC, NULL, 0x0, \"bUnitID\", HFILL }},\n        { &hf_ac_if_fu_sourceid,\n            { \"Source ID\", \"usbaudio.ac_if_fu.bSourceID\",\n              FT_UINT8, BASE_DEC, NULL, 0x0, \"bSourceID\", HFILL }},\n        { &hf_ac_if_fu_controlsize,\n            { \"Control Size\", \"usbaudio.ac_if_fu.bControlSize\",\n              FT_UINT8, BASE_DEC, NULL, 0x0, \"bControlSize\", HFILL }},\n        { &hf_ac_if_fu_controls,\n            { \"Controls\", \"usbaudio.ac_if_fu.bmaControls\",\n              FT_BYTES, BASE_NONE, NULL, 0x0, \"bmaControls\", HFILL }},\n        { &hf_ac_if_fu_control,\n            { \"Control\", \"usbaudio.ac_if_fu.bmaControl\",\n              FT_UINT8, BASE_HEX, NULL, 0x0, \"bmaControls\", HFILL }},\n        { &hf_ac_if_fu_controls_d0,\n            { \"Mute\", \"usbaudio.ac_if_fu.bmaControls.d0\",\n              FT_BOOLEAN, 8, NULL, 0x01, NULL, HFILL }},\n        { &hf_ac_if_fu_controls_d1,\n            { \"Volume\", \"usbaudio.ac_if_fu.bmaControls.d1\",\n              FT_BOOLEAN, 8, NULL, 0x02, NULL, HFILL }},\n        { &hf_ac_if_fu_controls_d2,\n            { \"Bass\", \"usbaudio.ac_if_fu.bmaControls.d2\",\n              FT_BOOLEAN, 8, NULL, 0x04, NULL, HFILL }},\n        { &hf_ac_if_fu_controls_d3,\n            { \"Mid\", \"usbaudio.ac_if_fu.bmaControls.d3\",\n              FT_BOOLEAN, 8, NULL, 0x08, NULL, HFILL }},\n        { &hf_ac_if_fu_controls_d4,\n            { \"Treble\", \"usbaudio.ac_if_fu.bmaControls.d4\",\n              FT_BOOLEAN, 8, NULL, 0x10, NULL, HFILL }},\n        { &hf_ac_if_fu_controls_d5,\n            { \"Graphic Equalizer\", \"usbaudio.ac_if_fu.bmaControls.d5\",\n              FT_BOOLEAN, 8, NULL, 0x20, NULL, HFILL }},\n        { &hf_ac_if_fu_controls_d6,\n            { \"Automatic Gain\", \"usbaudio.ac_if_fu.bmaControls.d6\",\n              FT_BOOLEAN, 8, NULL, 0x40, NULL, HFILL }},\n        { &hf_ac_if_fu_controls_d7,\n            { \"Delay\", \"usbaudio.ac_if_fu.bmaControls.d7\",\n              FT_BOOLEAN, 8, NULL, 0x80, NULL, HFILL }},\n        { &hf_ac_if_fu_controls_d8,\n            { \"Bass Boost\", \"usbaudio.ac_if_fu.bmaControls.d8\",\n              FT_BOOLEAN, 8, NULL, 0x01, NULL, HFILL }},\n        { &hf_ac_if_fu_controls_d9,\n            { \"Loudness\", \"usbaudio.ac_if_fu.bmaControls.d9\",\n              FT_BOOLEAN, 8, NULL, 0x02, NULL, HFILL }},\n        { &hf_ac_if_fu_controls_rsv,\n            { \"Reserved\", \"usbaudio.ac_if_fu.bmaControls.rsv\",\n              FT_UINT8, BASE_HEX, NULL, 0xFC, \"Must be zero\", HFILL }},\n        { &hf_ac_if_fu_controls_v2,\n            { \"Controls\", \"usbaudio.ac_if_fu.bmaControls_v2\",\n              FT_BYTES, BASE_NONE, NULL, 0x0, \"bmaControls\", HFILL }},\n        { &hf_ac_if_fu_control_v2,\n            { \"Control\", \"usbaudio.ac_if_fu.bmaControl_v2\",\n              FT_UINT32, BASE_HEX, NULL, 0x0, \"bmaControls\", HFILL }},\n        { &hf_ac_if_fu_controls_v2_d0,\n            { \"Mute\", \"usbaudio.ac_if_fu.bmaControls_v2.d0\", FT_UINT32,\n              BASE_HEX|BASE_EXT_STRING, &controls_capabilities_vals_ext, (3u << 0), NULL, HFILL }},\n        { &hf_ac_if_fu_controls_v2_d1,\n            { \"Volume\", \"usbaudio.ac_if_fu.bmaControls_v2.d1\", FT_UINT32,\n              BASE_HEX|BASE_EXT_STRING, &controls_capabilities_vals_ext, (3u << 2), NULL, HFILL }},\n        { &hf_ac_if_fu_controls_v2_d2,\n            { \"Bass\", \"usbaudio.ac_if_fu.bmaControls_v2.d2\", FT_UINT32,\n              BASE_HEX|BASE_EXT_STRING, &controls_capabilities_vals_ext, (3u << 4), NULL, HFILL }},\n        { &hf_ac_if_fu_controls_v2_d3,\n            { \"Mid\", \"usbaudio.ac_if_fu.bmaControls_v2.d3\", FT_UINT32,\n              BASE_HEX|BASE_EXT_STRING, &controls_capabilities_vals_ext, (3u << 6), NULL, HFILL }},\n        { &hf_ac_if_fu_controls_v2_d4,\n            { \"Treble\", \"usbaudio.ac_if_fu.bmaControls_v2.d4\", FT_UINT32,\n              BASE_HEX|BASE_EXT_STRING, &controls_capabilities_vals_ext, (3u << 8), NULL, HFILL }},\n        { &hf_ac_if_fu_controls_v2_d5,\n            { \"Graphic Equalizer\", \"usbaudio.ac_if_fu.bmaControls_v2.d5\", FT_UINT32,\n              BASE_HEX|BASE_EXT_STRING, &controls_capabilities_vals_ext, (3u << 10), NULL, HFILL }},\n        { &hf_ac_if_fu_controls_v2_d6,\n            { \"Automatic Gain\", \"usbaudio.ac_if_fu.bmaControls_v2.d6\", FT_UINT32,\n              BASE_HEX|BASE_EXT_STRING, &controls_capabilities_vals_ext, (3u << 12), NULL, HFILL }},\n        { &hf_ac_if_fu_controls_v2_d7,\n            { \"Delay\", \"usbaudio.ac_if_fu.bmaControl_v2s.d7\", FT_UINT32,\n              BASE_HEX|BASE_EXT_STRING, &controls_capabilities_vals_ext, (3u << 14), NULL, HFILL }},\n        { &hf_ac_if_fu_controls_v2_d8,\n            { \"Bass Boost\", \"usbaudio.ac_if_fu.bmaControls_v2.d8\", FT_UINT32,\n              BASE_HEX|BASE_EXT_STRING, &controls_capabilities_vals_ext, (3u << 16), NULL, HFILL }},\n        { &hf_ac_if_fu_controls_v2_d9,\n            { \"Loudness\", \"usbaudio.ac_if_fu.bmaControls_v2.d9\", FT_UINT32,\n              BASE_HEX|BASE_EXT_STRING, &controls_capabilities_vals_ext, (3u << 18), NULL, HFILL }},\n        { &hf_ac_if_fu_controls_v2_d10,\n            { \"Input Gain\", \"usbaudio.ac_if_fu.bmaControls_v2.d10\", FT_UINT32,\n              BASE_HEX|BASE_EXT_STRING, &controls_capabilities_vals_ext, (3u << 20), NULL, HFILL }},\n        { &hf_ac_if_fu_controls_v2_d11,\n            { \"Input Gain Pad\", \"usbaudio.ac_if_fu.bmaControls_v2.d11\", FT_UINT32,\n              BASE_HEX|BASE_EXT_STRING, &controls_capabilities_vals_ext, (3u << 22), NULL, HFILL }},\n        { &hf_ac_if_fu_controls_v2_d12,\n            { \"Phase Inverter\", \"usbaudio.ac_if_fu.bmaControls_v2.d12\", FT_UINT32,\n              BASE_HEX|BASE_EXT_STRING, &controls_capabilities_vals_ext, (3u << 24), NULL, HFILL }},\n        { &hf_ac_if_fu_controls_v2_d13,\n            { \"Underflow\", \"usbaudio.ac_if_fu.bmaControls_v2.d13\", FT_UINT32,\n              BASE_HEX|BASE_EXT_STRING, &controls_capabilities_vals_ext, (3u << 26), NULL, HFILL }},\n        { &hf_ac_if_fu_controls_v2_d14,\n            { \"Overflow\", \"usbaudio.ac_if_fu.bmaControls_v2.d14\", FT_UINT32,\n              BASE_HEX|BASE_EXT_STRING, &controls_capabilities_vals_ext, (3u << 28), NULL, HFILL }},\n        { &hf_ac_if_fu_controls_v2_rsv,\n            { \"Reserved\", \"usbaudio.ac_if_fu.bmaControls_v2.rsv\", FT_UINT32,\n              BASE_HEX, NULL, (3u << 30), \"Must be zero\", HFILL }},\n        { &hf_ac_if_fu_ifeature,\n            { \"Feature\", \"usbaudio.ac_if_fu.iFeature\",\n              FT_UINT8, BASE_DEC, NULL, 0x0, \"iFeature\", HFILL }},\n        { &hf_ac_if_su_unitid,\n            { \"Unit ID\", \"usbaudio.ac_if_su.bUnitID\",\n              FT_UINT8, BASE_DEC, NULL, 0x0, \"bUnitID\", HFILL }},\n        { &hf_ac_if_su_nrinpins,\n            { \"Input Pins\", \"usbaudio.ac_if_su.bNrInPins\",\n              FT_UINT8, BASE_DEC, NULL, 0x0, \"bNrInPins\", HFILL }},\n        { &hf_ac_if_su_sourceids,\n            { \"Source IDs\", \"usbaudio.ac_if_su.baSourceIDs\",\n              FT_BYTES, BASE_NONE, NULL, 0x0, \"baSourceIDs\", HFILL }},\n        { &hf_ac_if_su_sourceid,\n            { \"Source ID\", \"usbaudio.ac_if_su.baSourceID\",\n              FT_UINT8, BASE_DEC, NULL, 0x0, \"baSourceID\", HFILL}},\n        { &hf_ac_if_su_controls,\n            { \"Controls\", \"usbaudio.ac_if_su.bmControls\",\n              FT_UINT8, BASE_HEX, NULL, 0x0, \"bmControls\", HFILL}},\n        { &hf_ac_if_su_controls_d0,\n            { \"Selector Control\", \"usbaudio.ac_if_su.bmControls.d0\",\n              FT_UINT8, BASE_HEX|BASE_EXT_STRING, &controls_capabilities_vals_ext, 0x03, NULL, HFILL}},\n        { &hf_ac_if_su_controls_rsv,\n            { \"Reserved\", \"usbaudio.ac_if_su.bmControls.rsv\",\n              FT_UINT8, BASE_HEX, NULL, 0xFC, \"Must be zero\", HFILL}},\n        { &hf_ac_if_su_iselector,\n            { \"Selector Index\", \"usbaudio.ac_if_su.iSelector\",\n              FT_UINT8, BASE_DEC, NULL, 0x0, \"iSelector\", HFILL }},\n        { &hf_ac_if_mu_unitid,\n            { \"Unit ID\", \"usbaudio.ac_if_mu.bUnitID\",\n              FT_UINT8, BASE_DEC, NULL, 0x0, \"bUnitID\", HFILL }},\n        { &hf_ac_if_mu_nrinpins,\n            { \"Number In Pins\", \"usbaudio.ac_if_mu.bNrInPins\",\n              FT_UINT8, BASE_DEC, NULL, 0x0, \"bNrInPins\", HFILL }},\n        { &hf_ac_if_mu_sourceid,\n            { \"Source ID\", \"usbaudio.ac_if_mu.baSourceID\",\n              FT_UINT8, BASE_DEC, NULL, 0x0, \"baSourceID\", HFILL }},\n        { &hf_ac_if_mu_nrchannels,\n            { \"Number Channels\", \"usbaudio.ac_if_mu.bNrChannels\",\n              FT_UINT8, BASE_DEC, NULL, 0x0, \"bNrChannels\", HFILL }},\n        { &hf_ac_if_mu_channelconfig,\n            { \"Channel Config\", \"usbaudio.ac_if_mu.wChannelConfig\",\n              FT_UINT16, BASE_HEX, NULL, 0x0, \"wChannelConfig\", HFILL }},\n        { &hf_ac_if_mu_channelconfig_d0,\n            { \"Left Front\", \"usbaudio.ac_if_mu.wChannelConfig.d0\",\n              FT_BOOLEAN, 16, NULL, 0x0001, NULL, HFILL }},\n        { &hf_ac_if_mu_channelconfig_d1,\n            { \"Right Front\", \"usbaudio.ac_if_mu.wChannelConfig.d1\",\n              FT_BOOLEAN, 16, NULL, 0x0002, NULL, HFILL }},\n        { &hf_ac_if_mu_channelconfig_d2,\n            { \"Center Front\", \"usbaudio.ac_if_mu.wChannelConfig.d2\",\n              FT_BOOLEAN, 16, NULL, 0x0004, NULL, HFILL }},\n        { &hf_ac_if_mu_channelconfig_d3,\n            { \"Low Frequency Enhancement\", \"usbaudio.ac_if_mu.wChannelConfig.d3\",\n              FT_BOOLEAN, 16, NULL, 0x0008, NULL, HFILL }},\n        { &hf_ac_if_mu_channelconfig_d4,\n            { \"Left Surround\", \"usbaudio.ac_if_mu.wChannelConfig.d4\",\n              FT_BOOLEAN, 16, NULL, 0x0010, NULL, HFILL }},\n        { &hf_ac_if_mu_channelconfig_d5,\n            { \"Right Surround\", \"usbaudio.ac_if_mu.wChannelConfig.d5\",\n              FT_BOOLEAN, 16, NULL, 0x0020, NULL, HFILL }},\n        { &hf_ac_if_mu_channelconfig_d6,\n            { \"Left of Center\", \"usbaudio.ac_if_mu.wChannelConfig.d6\",\n              FT_BOOLEAN, 16, NULL, 0x0040, NULL, HFILL }},\n        { &hf_ac_if_mu_channelconfig_d7,\n            { \"Right of Center\", \"usbaudio.ac_if_mu.wChannelConfig.d7\",\n              FT_BOOLEAN, 16, NULL, 0x0080, NULL, HFILL }},\n        { &hf_ac_if_mu_channelconfig_d8,\n            { \"Surround\", \"usbaudio.ac_if_mu.wChannelConfig.d8\",\n              FT_BOOLEAN, 16, NULL, 0x0100, NULL, HFILL }},\n        { &hf_ac_if_mu_channelconfig_d9,\n            { \"Side Left\", \"usbaudio.ac_if_mu.wChannelConfig.d9\",\n              FT_BOOLEAN, 16, NULL, 0x0200, NULL, HFILL }},\n        { &hf_ac_if_mu_channelconfig_d10,\n            { \"Side Right\", \"usbaudio.ac_if_mu.wChannelConfig.d10\",\n              FT_BOOLEAN, 16, NULL, 0x0400, NULL, HFILL }},\n        { &hf_ac_if_mu_channelconfig_d11,\n            { \"Top\", \"usbaudio.ac_if_mu.wChannelConfig.d11\",\n              FT_BOOLEAN, 16, NULL, 0x0800, NULL, HFILL }},\n        { &hf_ac_if_mu_channelconfig_rsv,\n            { \"Reserved\", \"usbaudio.ac_if_mu.wChannelConfig.rsv\",\n              FT_UINT16, BASE_HEX, NULL, 0xF000, NULL, HFILL }},\n        { &hf_ac_if_mu_channelnames,\n            { \"Channel Names\", \"usbaudio.ac_if_mu.iChannelNames\",\n              FT_UINT8, BASE_DEC, NULL, 0x0, \"iChannelNames\", HFILL }},\n        { &hf_ac_if_mu_controls,\n            { \"Controls\", \"usbaudio.ac_if_mu.bmControls\",\n              FT_UINT8, BASE_HEX, NULL, 0x0, \"bmControls\", HFILL }},\n        { &hf_ac_if_mu_imixer,\n            { \"Mixer\", \"usbaudio.ac_if_mu.iMixer\",\n              FT_UINT8, BASE_DEC, NULL, 0x0, \"iMixer\", HFILL }},\n        { &hf_ac_if_clksrc_id,\n            { \"Clock Source Entity\", \"usbaudio.ac_if_clksrc.bClockID\",\n              FT_UINT8, BASE_DEC, NULL, 0x0, \"bClockID\", HFILL }},\n        { &hf_ac_if_clksrc_attr,\n            { \"Attributes\", \"usbaudio.ac_if_clksrc.bmAttributes\",\n              FT_UINT8, BASE_HEX, NULL, 0x0, \"bmAttributes\", HFILL }},\n        { &hf_ac_if_clksrc_attr_type,\n            { \"Type\", \"usbaudio.ac_if_clksrc.bmAttributes.type\", FT_UINT8,\n              BASE_HEX, VALS(clock_types_vals), 0x03, NULL, HFILL }},\n        { &hf_ac_if_clksrc_attr_d2,\n            { \"Synchronization\", \"usbaudio.ac_if_clksrc.bmAttributes.d2\", FT_UINT8,\n              BASE_HEX, VALS(clock_sync_vals), 0x04, NULL, HFILL }},\n        { &hf_ac_if_clksrc_attr_rsv,\n            { \"Reserved\", \"usbaudio.ac_if_clksrc.bmAttributes.rsv\",\n              FT_UINT8, BASE_HEX, NULL, 0xF8, \"Must be zero\", HFILL }},\n        { &hf_ac_if_clksrc_controls,\n            { \"Controls\", \"usbaudio.ac_if_clksrc.bmControls\",\n              FT_UINT8, BASE_HEX, NULL, 0x0, \"bmControls\", HFILL }},\n        { &hf_ac_if_clksrc_controls_freq,\n            { \"Clock Frequency Control\", \"usbaudio.ac_if_clksrc.bmControls.freq\", FT_UINT8,\n              BASE_HEX|BASE_EXT_STRING, &controls_capabilities_vals_ext, 0x03, NULL, HFILL }},\n        { &hf_ac_if_clksrc_controls_validity,\n            { \"Clock Validity Control\", \"usbaudio.ac_if_clksrc.bmControls.validity\", FT_UINT8,\n              BASE_HEX|BASE_EXT_STRING, &controls_capabilities_vals_ext, 0x0C, NULL, HFILL }},\n        { &hf_ac_if_clksrc_controls_rsv,\n            { \"Reserved\", \"usbaudio.ac_if_clksrc.bmControls.rsv\",\n              FT_UINT8, BASE_HEX, NULL, 0xF0, \"Must be zero\", HFILL }},\n        { &hf_ac_if_clksrc_assocterminal,\n            { \"Terminal\", \"usbaudio.ac_if_clksrc.bAssocTerminal\",\n              FT_UINT8, BASE_DEC, NULL, 0x0, \"bAssocTerminal\", HFILL }},\n        { &hf_ac_if_clksrc_clocksource,\n            { \"String descriptor index\", \"usbaudio.ac_if_clksrc.iClockSource\",\n              FT_UINT8, BASE_DEC, NULL, 0x0, \"iClockSource\", HFILL }},\n        { &hf_ac_if_clksel_id,\n            { \"Clock Selector Entity\", \"usbaudio.ac_if_clksel.bClockID\",\n              FT_UINT8, BASE_DEC, NULL, 0x0, \"bClockID\", HFILL }},\n        { &hf_ac_if_clksel_nrpins,\n            { \"Number of Input Pins\", \"usbaudio.ac_if_clksel.bNrInPins\",\n              FT_UINT8, BASE_DEC, NULL, 0x0, \"bNrInPins\", HFILL }},\n        { &hf_ac_if_clksel_sourceid,\n            { \"Connected Clock Entity\", \"usbaudio.ac_if_clksel.baCSourceID\",\n              FT_UINT8, BASE_DEC, NULL, 0x0, \"baCSourceID\", HFILL }},\n        { &hf_ac_if_clksel_controls,\n            { \"Controls\", \"usbaudio.ac_if_clksel.bmControls\",\n              FT_UINT8, BASE_HEX, NULL, 0x0, \"bmControls\", HFILL }},\n        { &hf_ac_if_clksel_controls_clksel,\n            { \"Clock Selector Control\", \"usbaudio.ac_if_clksel.bmControls.clksel\", FT_UINT8,\n              BASE_HEX|BASE_EXT_STRING, &controls_capabilities_vals_ext, 0x03, NULL, HFILL }},\n        { &hf_ac_if_clksel_controls_rsv,\n            { \"Reserved\", \"usbaudio.ac_if_clksel.bmControls.rsv\",\n              FT_UINT8, BASE_HEX, NULL, 0xFC, \"Must be zero\", HFILL }},\n        { &hf_ac_if_clksel_clockselector,\n            { \"String descriptor index\", \"usbaudio.ac_if_clksel.iClockSelector\",\n              FT_UINT8, BASE_DEC, NULL, 0x0, \"iClockSelector\", HFILL }},\n\n        { &hf_ac_if_extunit_id,\n            { \"Extension Unit\", \"usbaudio.ac_if_extunit.bUnitID\",\n              FT_UINT8, BASE_DEC, NULL, 0x0, \"bUnitID\", HFILL }},\n        { &hf_ac_if_extunit_code,\n            { \"Extension Code\", \"usbaudio.ac_if_extunit.wExtensionCode\", FT_UINT16,\n             BASE_HEX, NULL, 0x00, \"wExtensionCode\", HFILL }},\n        { &hf_ac_if_extunit_nrpins,\n            {\"Number of Input Pins\", \"usbaudio.ac_if_extunit.bNrInPins\",\n             FT_UINT8, BASE_DEC, NULL, 0x0, \"bNrInPins\", HFILL }},\n        { &hf_ac_if_extunit_sourceid,\n            {\"Unit or Terminal Entity\", \"usbaudio.ac_if_extunit.baSourceID\",\n             FT_UINT8, BASE_DEC, NULL, 0x0, \"baSourceID\", HFILL }},\n        { &hf_ac_if_extunit_nrchannels,\n            {\"Number Channels\", \"usbaudio.ac_if_extunit.bNrChannels\",\n             FT_UINT8, BASE_DEC, NULL, 0x0, \"bNrChannels\", HFILL }},\n        { &hf_ac_if_extunit_bmchannelconfig,\n            {\"Channel Config\", \"usbaudio.ac_if_extunit.bmChannelConfig\",\n             FT_UINT32, BASE_HEX, NULL, 0x0, \"bmChannelConfig\", HFILL }},\n        // TODO: add channel config vars\n        { &hf_ac_if_extunit_channelnames,\n            {\"Channel Names\", \"usbaudio.ac_if_extunit.iChannelNames\",\n             FT_UINT8, BASE_DEC, NULL, 0x0, \"iChannelNames\", HFILL }},\n        { &hf_ac_if_extunit_bmcontrols,\n            {\"Controls\", \"usbaudio.ac_if_extunit.bmControls\",\n             FT_UINT8, BASE_HEX, NULL, 0x0, \"bmControls\", HFILL }},\n        { &hf_ac_if_extunit_bmcontrols_enable_ctrl,\n            {\"Enable Control\", \"usbaudio.ac_if_extunit.bmControls.enableCtrl\",\n             FT_UINT8, BASE_HEX, NULL, 0x03, NULL, HFILL }},\n        { &hf_ac_if_extunit_bmcontrols_cluster_ctrl,\n            {\"Cluster Control\", \"usbaudio.ac_if_extunit.bmControls.clusterCtrl\",\n             FT_UINT8, BASE_HEX, NULL, 0x0C, NULL, HFILL }},\n        { &hf_ac_if_extunit_bmcontrols_underflow_ctrl,\n            {\"Underflow Control\", \"usbaudio.ac_if_extunit.bmControls.underflowCtrl\",\n             FT_UINT8, BASE_HEX, NULL, 0x30, NULL, HFILL }},\n        { &hf_ac_if_extunit_bmcontrols_overflowflow_ctrl,\n            {\"Overflow Control\", \"usbaudio.ac_if_extunit.bmControls.overflowCtrl\",\n             FT_UINT8, BASE_HEX, NULL, 0xC0, NULL, HFILL }},\n        { &hf_ac_if_extunit_iext,\n            {\"Extension\", \"usbaudio.ac_if_extunit.iExtension\",\n             FT_UINT8, BASE_DEC, NULL, 0x0, \"iExtension\", HFILL }},\n\n        { &hf_as_if_desc_subtype,\n            { \"Subtype\", \"usbaudio.as_if_subtype\", FT_UINT8, BASE_HEX|BASE_EXT_STRING,\n                &as_subtype_vals_ext, 0x0, \"bDescriptorSubtype\", HFILL }},\n        { &hf_as_if_gen_term_link,\n            { \"Connected Terminal ID\", \"usbaudio.as_if_gen.bTerminalLink\",\n              FT_UINT8, BASE_DEC, NULL, 0x0, \"bTerminalLink\", HFILL }},\n        { &hf_as_if_gen_delay,\n            { \"Interface delay in frames\", \"usbaudio.as_if_gen.bDelay\",\n              FT_UINT8, BASE_DEC, NULL, 0x0, \"bDelay\", HFILL }},\n        { &hf_as_if_gen_wformattag,\n            { \"Format\", \"usbaudio.as_if_gen.wFormatTag\", FT_UINT16, BASE_HEX|BASE_EXT_STRING,\n              &audio_data_format_tag_vals_ext, 0x0, \"wFormatTag\", HFILL }},\n        { &hf_as_if_gen_controls,\n            { \"Controls\", \"usbaudio.as_if_gen.bmControls\",\n              FT_UINT8, BASE_HEX, NULL, 0x0, \"bmControls\", HFILL }},\n        { &hf_as_if_gen_controls_active,\n            { \"Active Alternate Setting Control\", \"usbaudio.as_if_gen.bmControls.active\", FT_UINT8,\n              BASE_HEX|BASE_EXT_STRING, &controls_capabilities_read_only_vals_ext, 0x03, NULL, HFILL }},\n        { &hf_as_if_gen_controls_valid,\n            { \"Valid Alternate Settings Control\", \"usbaudio.as_if_gen.bmControls.valid\", FT_UINT8,\n              BASE_HEX|BASE_EXT_STRING, &controls_capabilities_read_only_vals_ext, 0x0C, NULL, HFILL }},\n        { &hf_as_if_gen_controls_rsv,\n            { \"Reserved\", \"usbaudio.as_if_gen.bmControls.rsv\",\n              FT_UINT8, BASE_HEX, NULL, 0xF0, \"Must be zero\", HFILL }},\n        { &hf_as_if_gen_formattype,\n            { \"Format Type\", \"usbaudio.as_if_gen.bFormatType\",\n              FT_UINT8, BASE_DEC, NULL, 0x0, \"bFormatType\", HFILL }},\n        { &hf_as_if_gen_formats,\n            { \"Formats\", \"usbaudio.as_if_gen.bmFormats\",\n              FT_UINT32, BASE_HEX, NULL, 0x0, \"bmFormats\", HFILL }},\n\n        { &hf_as_if_gen_formats_i_d0,\n            { \"PCM\", \"usbaudio.as_if_gen.bmFormats.d0\",\n              FT_BOOLEAN, 32, NULL, (1u << 0), NULL, HFILL }},\n        { &hf_as_if_gen_formats_i_d1,\n            { \"PCM8\", \"usbaudio.as_if_gen.bmFormats.d1\",\n              FT_BOOLEAN, 32, NULL, (1u << 1), NULL, HFILL }},\n        { &hf_as_if_gen_formats_i_d2,\n            { \"IEEE Float\", \"usbaudio.as_if_gen.bmFormats.d2\",\n              FT_BOOLEAN, 32, NULL, (1u << 2), NULL, HFILL }},\n        { &hf_as_if_gen_formats_i_d3,\n            { \"ALAW\", \"usbaudio.as_if_gen.bmFormats.d3\",\n              FT_BOOLEAN, 32, NULL, (1u << 3), NULL, HFILL }},\n        { &hf_as_if_gen_formats_i_d4,\n            { \"MULAW\", \"usbaudio.as_if_gen.bmFormats.d4\",\n              FT_BOOLEAN, 32, NULL, (1u << 4), NULL, HFILL }},\n        { &hf_as_if_gen_formats_i_rsv,\n            { \"Reserved\", \"usbaudio.as_if_gen.bmFormats.rsv\",\n              FT_UINT32, BASE_HEX, NULL, (0x7FFFFFE0u), \"Must be zero\", HFILL }},\n        { &hf_as_if_gen_formats_i_d31,\n            { \"Type I Raw Data\", \"usbaudio.as_if_gen.bmFormats.d31\",\n              FT_BOOLEAN, 32, NULL, (1u << 31), NULL, HFILL }},\n\n        { &hf_as_if_gen_formats_ii_d0,\n            { \"MPEG\", \"usbaudio.as_if_gen.bmFormats.d0\",\n              FT_BOOLEAN, 32, NULL, (1u << 0), NULL, HFILL }},\n        { &hf_as_if_gen_formats_ii_d1,\n            { \"AC-3\", \"usbaudio.as_if_gen.bmFormats.d1\",\n              FT_BOOLEAN, 32, NULL, (1u << 1), NULL, HFILL }},\n        { &hf_as_if_gen_formats_ii_d2,\n            { \"WMA\", \"usbaudio.as_if_gen.bmFormats.d2\",\n              FT_BOOLEAN, 32, NULL, (1u << 2), NULL, HFILL }},\n        { &hf_as_if_gen_formats_ii_d3,\n            { \"DTS\", \"usbaudio.as_if_gen.bmFormats.d3\",\n              FT_BOOLEAN, 32, NULL, (1u << 3), NULL, HFILL }},\n        { &hf_as_if_gen_formats_ii_rsv,\n            { \"Reserved\", \"usbaudio.as_if_gen.bmFormats.rsv\",\n              FT_UINT32, BASE_HEX, NULL, (0x7FFFFFF0u), \"Must be zero\", HFILL }},\n        { &hf_as_if_gen_formats_ii_d31,\n            { \"Type II Raw Data\", \"usbaudio.as_if_gen.bmFormats.d31\",\n              FT_BOOLEAN, 32, NULL, (1u << 31), NULL, HFILL }},\n\n        { &hf_as_if_gen_formats_iii_d0,\n            { \"IEC61937 AC-3\", \"usbaudio.as_if_gen.bmFormats.d0\",\n              FT_BOOLEAN, 32, NULL, (1u << 0), NULL, HFILL }},\n        { &hf_as_if_gen_formats_iii_d1,\n            { \"IEC61937 MPEG-1 Layer1\", \"usbaudio.as_if_gen.bmFormats.d1\",\n              FT_BOOLEAN, 32, NULL, (1u << 1), NULL, HFILL }},\n        { &hf_as_if_gen_formats_iii_d2,\n            { \"IEC61937 MPEG-1 Layer2/3 or IEC61937 MPEG-2 NOEXT\", \"usbaudio.as_if_gen.bmFormats.d2\",\n              FT_BOOLEAN, 32, NULL, (1u << 2), NULL, HFILL }},\n        { &hf_as_if_gen_formats_iii_d3,\n            { \"IEC61937 MPEG-2 EXT\", \"usbaudio.as_if_gen.bmFormats.d3\",\n              FT_BOOLEAN, 32, NULL, (1u << 3), NULL, HFILL }},\n        { &hf_as_if_gen_formats_iii_d4,\n            { \"IEC61937 MPEG-2 AAC ADTS\", \"usbaudio.as_if_gen.bmFormats.d4\",\n              FT_BOOLEAN, 32, NULL, (1u << 4), NULL, HFILL }},\n        { &hf_as_if_gen_formats_iii_d5,\n            { \"IEC61937 MPEG-2 Layer1 LS\", \"usbaudio.as_if_gen.bmFormats.d5\",\n              FT_BOOLEAN, 32, NULL, (1u << 5), NULL, HFILL }},\n        { &hf_as_if_gen_formats_iii_d6,\n            { \"IEC61937 MPEG-2 Layer2/3 LS\", \"usbaudio.as_if_gen.bmFormats.d6\",\n              FT_BOOLEAN, 32, NULL, (1u << 6), NULL, HFILL }},\n        { &hf_as_if_gen_formats_iii_d7,\n            { \"IEC61937 DTS-I\", \"usbaudio.as_if_gen.bmFormats.d7\",\n              FT_BOOLEAN, 32, NULL, (1u << 7), NULL, HFILL }},\n        { &hf_as_if_gen_formats_iii_d8,\n            { \"IEC61937 DTS-II\", \"usbaudio.as_if_gen.bmFormats.d8\",\n              FT_BOOLEAN, 32, NULL, (1u << 8), NULL, HFILL }},\n        { &hf_as_if_gen_formats_iii_d9,\n            { \"IEC61937 DTS-III\", \"usbaudio.as_if_gen.bmFormats.d9\",\n              FT_BOOLEAN, 32, NULL, (1u << 9), NULL, HFILL }},\n        { &hf_as_if_gen_formats_iii_d10,\n            { \"IEC61937 ATRAC\", \"usbaudio.as_if_gen.bmFormats.d10\",\n              FT_BOOLEAN, 32, NULL, (1u << 10), NULL, HFILL }},\n        { &hf_as_if_gen_formats_iii_d11,\n            { \"IEC61937 ATRAC2/3\", \"usbaudio.as_if_gen.bmFormats.d11\",\n              FT_BOOLEAN, 32, NULL, (1u << 11), NULL, HFILL }},\n        { &hf_as_if_gen_formats_iii_d12,\n            { \"Type III WMA\", \"usbaudio.as_if_gen.bmFormats.d12\",\n              FT_BOOLEAN, 32, NULL, (1u << 12), NULL, HFILL }},\n        { &hf_as_if_gen_formats_iii_rsv,\n            { \"Reserved\", \"usbaudio.as_if_gen.bmFormats.rsv\",\n              FT_UINT32, BASE_HEX, NULL, (0xFFFFE000u), \"Must be zero\", HFILL }},\n\n        { &hf_as_if_gen_formats_iv_d0,\n            { \"PCM\", \"usbaudio.as_if_gen.bmFormats.d0\",\n              FT_BOOLEAN, 32, NULL, (1u << 0), NULL, HFILL }},\n        { &hf_as_if_gen_formats_iv_d1,\n            { \"PCM8\", \"usbaudio.as_if_gen.bmFormats.d1\",\n              FT_BOOLEAN, 32, NULL, (1u << 1), NULL, HFILL }},\n        { &hf_as_if_gen_formats_iv_d2,\n            { \"IEEE Float\", \"usbaudio.as_if_gen.bmFormats.d2\",\n              FT_BOOLEAN, 32, NULL, (1u << 2), NULL, HFILL }},\n        { &hf_as_if_gen_formats_iv_d3,\n            { \"ALAW\", \"usbaudio.as_if_gen.bmFormats.d3\",\n              FT_BOOLEAN, 32, NULL, (1u << 3), NULL, HFILL }},\n        { &hf_as_if_gen_formats_iv_d4,\n            { \"MULAW\", \"usbaudio.as_if_gen.bmFormats.d4\",\n              FT_BOOLEAN, 32, NULL, (1u << 4), NULL, HFILL }},\n        { &hf_as_if_gen_formats_iv_d5,\n            { \"MPEG\", \"usbaudio.as_if_gen.bmFormats.d5\",\n              FT_BOOLEAN, 32, NULL, (1u << 5), NULL, HFILL }},\n        { &hf_as_if_gen_formats_iv_d6,\n            { \"AC-3\", \"usbaudio.as_if_gen.bmFormats.d6\",\n              FT_BOOLEAN, 32, NULL, (1u << 6), NULL, HFILL }},\n        { &hf_as_if_gen_formats_iv_d7,\n            { \"WMA\", \"usbaudio.as_if_gen.bmFormats.d7\",\n              FT_BOOLEAN, 32, NULL, (1u << 7), NULL, HFILL }},\n        { &hf_as_if_gen_formats_iv_d8,\n            { \"IEC61937 AC-3\", \"usbaudio.as_if_gen.bmFormats.d8\",\n              FT_BOOLEAN, 32, NULL, (1u << 8), NULL, HFILL }},\n        { &hf_as_if_gen_formats_iv_d9,\n            { \"IEC61937 MPEG-1 Layer1\", \"usbaudio.as_if_gen.bmFormats.d9\",\n              FT_BOOLEAN, 32, NULL, (1u << 9), NULL, HFILL }},\n        { &hf_as_if_gen_formats_iv_d10,\n            { \"IEC61937 MPEG-1 Layer2/3 or IEC61937 MPEG-2 NOEXT\", \"usbaudio.as_if_gen.bmFormats.d10\",\n              FT_BOOLEAN, 32, NULL, (1u << 10), NULL, HFILL }},\n        { &hf_as_if_gen_formats_iv_d11,\n            { \"IEC61937 MPEG-2 EXT\", \"usbaudio.as_if_gen.bmFormats.d11\",\n              FT_BOOLEAN, 32, NULL, (1u << 11), NULL, HFILL }},\n        { &hf_as_if_gen_formats_iv_d12,\n            { \"IEC61937 MPEG-2 AAC ADTS\", \"usbaudio.as_if_gen.bmFormats.d12\",\n              FT_BOOLEAN, 32, NULL, (1u << 12), NULL, HFILL }},\n        { &hf_as_if_gen_formats_iv_d13,\n            { \"IEC61937 MPEG-2 Layer1 LS\", \"usbaudio.as_if_gen.bmFormats.d13\",\n              FT_BOOLEAN, 32, NULL, (1u << 13), NULL, HFILL }},\n        { &hf_as_if_gen_formats_iv_d14,\n            { \"IEC61937 MPEG-2 Layer2/3 LS\", \"usbaudio.as_if_gen.bmFormats.d14\",\n              FT_BOOLEAN, 32, NULL, (1u << 14), NULL, HFILL }},\n        { &hf_as_if_gen_formats_iv_d15,\n            { \"IEC61937 DTS-I\", \"usbaudio.as_if_gen.bmFormats.d15\",\n              FT_BOOLEAN, 32, NULL, (1u << 15), NULL, HFILL }},\n        { &hf_as_if_gen_formats_iv_d16,\n            { \"IEC61937 DTS-II\", \"usbaudio.as_if_gen.bmFormats.d16\",\n              FT_BOOLEAN, 32, NULL, (1u << 16), NULL, HFILL }},\n        { &hf_as_if_gen_formats_iv_d17,\n            { \"IEC61937 DTS-III\", \"usbaudio.as_if_gen.bmFormats.d17\",\n              FT_BOOLEAN, 32, NULL, (1u << 17), NULL, HFILL }},\n        { &hf_as_if_gen_formats_iv_d18,\n            { \"IEC61937 ATRAC\", \"usbaudio.as_if_gen.bmFormats.d18\",\n              FT_BOOLEAN, 32, NULL, (1u << 18), NULL, HFILL }},\n        { &hf_as_if_gen_formats_iv_d19,\n            { \"IEC61937 ATRAC2/3\", \"usbaudio.as_if_gen.bmFormats.d19\",\n              FT_BOOLEAN, 32, NULL, (1u << 19), NULL, HFILL }},\n        { &hf_as_if_gen_formats_iv_d20,\n            { \"Type III WMA\", \"usbaudio.as_if_gen.bmFormats.d20\",\n              FT_BOOLEAN, 32, NULL, (1u << 20), NULL, HFILL }},\n        { &hf_as_if_gen_formats_iv_d21,\n            { \"IEC60958 PCM\", \"usbaudio.as_if_gen.bmFormats.d21\",\n              FT_BOOLEAN, 32, NULL, (1u << 21), NULL, HFILL }},\n        { &hf_as_if_gen_formats_iv_rsv,\n            { \"Reserved\", \"usbaudio.as_if_gen.bmFormats.rsv\",\n              FT_UINT32, BASE_HEX, NULL, (0xFFE00000u), \"Must be zero\", HFILL }},\n\n        { &hf_as_if_gen_nrchannels,\n            { \"Number of channels\", \"usbaudio.as_if_gen.bNrChannels\",\n              FT_UINT8, BASE_DEC, NULL, 0x00, \"bNrChannels\", HFILL }},\n        { &hf_as_if_gen_bmchannelconfig,\n            { \"Channel Config\", \"usbaudio.as_if_gen.bmChannelConfig\",\n              FT_UINT32, BASE_HEX, NULL, 0x0, \"bmChannelConfig\", HFILL }},\n        { &hf_as_if_gen_bmchannelconfig_d0,\n            { \"Front Left\", \"usbaudio.as_if_gen.bmChannelConfig.d0\",\n              FT_BOOLEAN, 32, NULL, (1u << 0), NULL, HFILL }},\n        { &hf_as_if_gen_bmchannelconfig_d1,\n            { \"Front Right\", \"usbaudio.as_if_gen.bmChannelConfig.d1\",\n              FT_BOOLEAN, 32, NULL, (1u << 1), NULL, HFILL }},\n        { &hf_as_if_gen_bmchannelconfig_d2,\n            { \"Front Center\", \"usbaudio.as_if_gen.bmChannelConfig.d2\",\n              FT_BOOLEAN, 32, NULL, (1u << 2), NULL, HFILL }},\n        { &hf_as_if_gen_bmchannelconfig_d3,\n            { \"Low Frequency Effects\", \"usbaudio.as_if_gen.bmChannelConfig.d3\",\n              FT_BOOLEAN, 32, NULL, (1u << 3), NULL, HFILL }},\n        { &hf_as_if_gen_bmchannelconfig_d4,\n            { \"Back Left\", \"usbaudio.as_if_gen.bmChannelConfig.d4\",\n              FT_BOOLEAN, 32, NULL, (1u << 4), NULL, HFILL }},\n        { &hf_as_if_gen_bmchannelconfig_d5,\n            { \"Back Right\", \"usbaudio.as_if_gen.bmChannelConfig.d5\",\n              FT_BOOLEAN, 32, NULL, (1u << 5), NULL, HFILL }},\n        { &hf_as_if_gen_bmchannelconfig_d6,\n            { \"Front Left of Center\", \"usbaudio.as_if_gen.bmChannelConfig.d6\",\n              FT_BOOLEAN, 32, NULL, (1u << 6), NULL, HFILL }},\n        { &hf_as_if_gen_bmchannelconfig_d7,\n            { \"Front Right of Center\", \"usbaudio.as_if_gen.bmChannelConfig.d7\",\n              FT_BOOLEAN, 32, NULL, (1u << 7), NULL, HFILL }},\n        { &hf_as_if_gen_bmchannelconfig_d8,\n            { \"Back Center\", \"usbaudio.as_if_gen.bmChannelConfig.d8\",\n              FT_BOOLEAN, 32, NULL, (1u << 8), NULL, HFILL }},\n        { &hf_as_if_gen_bmchannelconfig_d9,\n            { \"Side Left\", \"usbaudio.as_if_gen.bmChannelConfig.d9\",\n              FT_BOOLEAN, 32, NULL, (1u << 9), NULL, HFILL }},\n        { &hf_as_if_gen_bmchannelconfig_d10,\n            { \"Side Right\", \"usbaudio.as_if_gen.bmChannelConfig.d10\",\n              FT_BOOLEAN, 32, NULL, (1u << 10), NULL, HFILL }},\n        { &hf_as_if_gen_bmchannelconfig_d11,\n            { \"Top Center\", \"usbaudio.as_if_gen.bmChannelConfig.d11\",\n              FT_BOOLEAN, 32, NULL, (1u << 11), NULL, HFILL }},\n        { &hf_as_if_gen_bmchannelconfig_d12,\n            { \"Top Front Left\", \"usbaudio.as_if_gen.bmChannelConfig.d12\",\n              FT_BOOLEAN, 32, NULL, (1u << 12), NULL, HFILL }},\n        { &hf_as_if_gen_bmchannelconfig_d13,\n            { \"Top Front Center\", \"usbaudio.as_if_gen.bmChannelConfig.d13\",\n              FT_BOOLEAN, 32, NULL, (1u << 13), NULL, HFILL }},\n        { &hf_as_if_gen_bmchannelconfig_d14,\n            { \"Top Front Right\", \"usbaudio.as_if_gen.bmChannelConfig.d14\",\n              FT_BOOLEAN, 32, NULL, (1u << 14), NULL, HFILL }},\n        { &hf_as_if_gen_bmchannelconfig_d15,\n            { \"Top Back Left\", \"usbaudio.as_if_gen.bmChannelConfig.d15\",\n              FT_BOOLEAN, 32, NULL, (1u << 15), NULL, HFILL }},\n        { &hf_as_if_gen_bmchannelconfig_d16,\n            { \"Top Back Center\", \"usbaudio.as_if_gen.bmChannelConfig.d16\",\n              FT_BOOLEAN, 32, NULL, (1u << 16), NULL, HFILL }},\n        { &hf_as_if_gen_bmchannelconfig_d17,\n            { \"Top Back Right\", \"usbaudio.as_if_gen.bmChannelConfig.d17\",\n              FT_BOOLEAN, 32, NULL, (1u << 17), NULL, HFILL }},\n        { &hf_as_if_gen_bmchannelconfig_d18,\n            { \"Top Front Left of Center\", \"usbaudio.as_if_gen.bmChannelConfig.d18\",\n              FT_BOOLEAN, 32, NULL, (1u << 18), NULL, HFILL }},\n        { &hf_as_if_gen_bmchannelconfig_d19,\n            { \"Top Front Right of Center\", \"usbaudio.as_if_gen.bmChannelConfig.d19\",\n              FT_BOOLEAN, 32, NULL, (1u << 19), NULL, HFILL }},\n        { &hf_as_if_gen_bmchannelconfig_d20,\n            { \"Left Low Frequency Effects\", \"usbaudio.as_if_gen.bmChannelConfig.d20\",\n              FT_BOOLEAN, 32, NULL, (1u << 20), NULL, HFILL }},\n        { &hf_as_if_gen_bmchannelconfig_d21,\n            { \"Right Low Frequency Effects\", \"usbaudio.as_if_gen.bmChannelConfig.d21\",\n              FT_BOOLEAN, 32, NULL, (1u << 21), NULL, HFILL }},\n        { &hf_as_if_gen_bmchannelconfig_d22,\n            { \"Top Side Left\", \"usbaudio.as_if_gen.bmChannelConfig.d22\",\n              FT_BOOLEAN, 32, NULL, (1u << 22), NULL, HFILL }},\n        { &hf_as_if_gen_bmchannelconfig_d23,\n            { \"Top Side Right\", \"usbaudio.as_if_gen.bmChannelConfig.d23\",\n              FT_BOOLEAN, 32, NULL, (1u << 23), NULL, HFILL }},\n        { &hf_as_if_gen_bmchannelconfig_d24,\n            { \"Bottom Center\", \"usbaudio.as_if_gen.bmChannelConfig.d24\",\n              FT_BOOLEAN, 32, NULL, (1u << 24), NULL, HFILL }},\n        { &hf_as_if_gen_bmchannelconfig_d25,\n            { \"Back Left of Center\", \"usbaudio.as_if_gen.bmChannelConfig.d25\",\n              FT_BOOLEAN, 32, NULL, (1u << 25), NULL, HFILL }},\n        { &hf_as_if_gen_bmchannelconfig_d26,\n            { \"Back Right of Center\", \"usbaudio.as_if_gen.bmChannelConfig.d26\",\n              FT_BOOLEAN, 32, NULL, (1u << 26), NULL, HFILL }},\n        { &hf_as_if_gen_bmchannelconfig_rsv,\n            { \"Reserved\", \"usbaudio.as_if_gen.bmChannelConfig.rsv\",\n              FT_BOOLEAN, 32, NULL, (0xFu << 27), NULL, HFILL }},\n        { &hf_as_if_gen_bmchannelconfig_d31,\n            { \"Raw Data\", \"usbaudio.as_if_gen.bmChannelConfig.d31\",\n              FT_BOOLEAN, 32, NULL, (1u << 31), NULL, HFILL }},\n        { &hf_as_if_gen_channelnames,\n            { \"String descriptor index\", \"usbaudio.as_if_gen.iChannelNames\",\n              FT_UINT8, BASE_DEC, NULL, 0x00, \"iChannelNames\", HFILL }},\n\n        { &hf_as_if_ft_formattype,\n            { \"FormatType\", \"usbaudio.as_if_ft.bFormatType\",\n              FT_UINT8, BASE_DEC, NULL, 0x00, \"wFormatType\", HFILL }},\n        { &hf_as_if_ft_maxbitrate,\n            { \"Max Bit Rate\", \"usbaudio.as_if_ft.wMaxBitRate\",\n              FT_UINT16, BASE_DEC, NULL, 0x00, \"wMaxBitRate\", HFILL }},\n        { &hf_as_if_ft_nrchannels,\n            { \"Number Channels\", \"usbaudio.as_if_ft.bNrChannels\",\n              FT_UINT8, BASE_DEC, NULL, 0x00, \"bNrChannels\", HFILL }},\n        { &hf_as_if_ft_subframesize,\n            { \"Subframe Size\", \"usbaudio.as_if_ft.bSubframeSize\",\n              FT_UINT8, BASE_DEC, NULL, 0x00, \"bSubframeSize\", HFILL }},\n        { &hf_as_if_ft_subslotsize,\n            { \"Subslot Size\", \"usbaudio.as_if_ft.bSubslotSize\",\n              FT_UINT8, BASE_DEC, NULL, 0x00, \"bSubslotSize\", HFILL }},\n        { &hf_as_if_ft_bitresolution,\n            { \"Bit Resolution\", \"usbaudio.as_if_ft.bBitResolution\",\n              FT_UINT8, BASE_DEC, NULL, 0x00, \"bBitResolution\", HFILL }},\n        { &hf_as_if_ft_samplesperframe,\n            { \"Samples Per Frame\", \"usbaudio.as_if_ft.wSamplesPerFrame\",\n              FT_UINT16, BASE_DEC, NULL, 0x00, \"wSamplesPerFrame\", HFILL }},\n        { &hf_as_if_ft_samfreqtype,\n            { \"Samples Frequence Type\", \"usbaudio.as_if_ft.bSamFreqType\",\n              FT_UINT8, BASE_DEC, NULL, 0x00, \"bSamFreqType\", HFILL }},\n        { &hf_as_if_ft_lowersamfreq,\n            { \"Lower Samples Frequence\", \"usbaudio.as_if_ft.tLowerSamFreq\",\n              FT_UINT24, BASE_DEC, NULL, 0x00, \"tLowerSamFreq\", HFILL }},\n        { &hf_as_if_ft_uppersamfreq,\n            { \"Upper Samples Frequence\", \"usbaudio.as_if_ft.tUpperSamFreq\",\n              FT_UINT24, BASE_DEC, NULL, 0x00, \"tUpperSamFreq\", HFILL }},\n        { &hf_as_if_ft_samfreq,\n            { \"Samples Frequence\", \"usbaudio.as_if_ft.tSamFreq\",\n              FT_UINT24, BASE_DEC, NULL, 0x00, \"tSamFreq\", HFILL }},\n        { &hf_as_ep_desc_subtype,\n            { \"Subtype\", \"usbaudio.as_ep_subtype\", FT_UINT8,\n                BASE_HEX, VALS(as_ep_subtype_vals), 0x00, \"bDescriptorSubtype\", HFILL }},\n        { &hf_as_ep_gen_bmattributes,\n            { \"Attributes\", \"usbaudio.as_ep_gen.bmAttributes\", FT_UINT8,\n              BASE_HEX, NULL, 0x00, \"bmAttributes\", HFILL }},\n        { &hf_as_ep_gen_bmattributes_d0,\n            { \"Sampling Frequency Control\", \"usbaudio.as_ep_gen.bmAttributes.d0\", FT_BOOLEAN,\n              8, NULL, (1u << 0), NULL, HFILL }},\n        { &hf_as_ep_gen_bmattributes_d1,\n            { \"Pitch Control\", \"usbaudio.as_ep_gen.bmAttributes.d1\", FT_BOOLEAN,\n              8, NULL, (1u << 1), NULL, HFILL }},\n        { &hf_as_ep_gen_bmattributes_rsv,\n            { \"Reserved\", \"usbaudio.as_ep_gen.bmAttributes.rsv\", FT_UINT8,\n              BASE_HEX, NULL, 0x7C, NULL, HFILL }},\n        { &hf_as_ep_gen_bmattributes_d7,\n            { \"MaxPacketsOnly\", \"usbaudio.as_ep_gen.bmAttributes.d7\", FT_BOOLEAN,\n              8, NULL, (1u << 7), NULL, HFILL }},\n        { &hf_as_ep_gen_controls,\n            { \"Controls\", \"usbaudio.as_ep_gen.bmControls\",\n              FT_UINT8, BASE_HEX, NULL, 0x00, \"bmControls\", HFILL }},\n        { &hf_as_ep_gen_controls_pitch,\n            { \"Pitch Control\", \"usbaudio.as_ep_gen.bmControls.pitch\", FT_UINT8,\n              BASE_HEX|BASE_EXT_STRING, &controls_capabilities_read_only_vals_ext, 0x03, NULL, HFILL }},\n        { &hf_as_ep_gen_controls_data_overrun,\n            { \"Data Overrun Control\", \"usbaudio.as_ep_gen.bmControls.overrun\", FT_UINT8,\n              BASE_HEX|BASE_EXT_STRING, &controls_capabilities_read_only_vals_ext, 0x0C, NULL, HFILL }},\n        { &hf_as_ep_gen_controls_data_underrun,\n            { \"Valid Alternate Settings Control\", \"usbaudio.as_ep_gen.bmControls.underrun\", FT_UINT8,\n              BASE_HEX|BASE_EXT_STRING, &controls_capabilities_read_only_vals_ext, 0x30, NULL, HFILL }},\n        { &hf_as_ep_gen_controls_rsv,\n            { \"Reserved\", \"usbaudio.as_ep_gen.bmControls.bmControls.rsv\",\n              FT_UINT8, BASE_HEX, NULL, 0xC0, \"Must be zero\", HFILL }},\n        { &hf_as_ep_gen_lockdelayunits,\n            { \"Lock Delay Units\", \"usbaudio.as_ep_gen.bLockDelayUnits\",\n              FT_UINT8, BASE_DEC, VALS(lock_delay_unit_vals), 0x00, NULL, HFILL }},\n        { &hf_as_ep_gen_lockdelay,\n            { \"Lock Delay\", \"usbaudio.as_ep_gen.wLockDelay\",\n              FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL }},\n\n        { &hf_ms_if_desc_subtype,\n            { \"Subtype\", \"usbaudio.ms_if_subtype\", FT_UINT8, BASE_HEX|BASE_EXT_STRING,\n              &ms_if_subtype_vals_ext, 0x0, \"bDescriptorSubtype\", HFILL }},\n        { &hf_ms_if_hdr_ver,\n            { \"Version\", \"usbaudio.ms_if_hdr.bcdADC\",\n              FT_DOUBLE, BASE_NONE, NULL, 0, \"bcdADC\", HFILL }},\n        { &hf_ms_if_hdr_total_len,\n            { \"Total length\", \"usbaudio.ms_if_hdr.wTotalLength\",\n              FT_UINT16, BASE_DEC, NULL, 0x00, \"wTotalLength\", HFILL }},\n        { &hf_ms_if_midi_in_bjacktype,\n            { \"Jack Type\", \"usbaudio.ms_if_midi_in.bJackType\",\n              FT_UINT8, BASE_HEX, VALS(ms_midi_jack_type_vals), 0x00, \"bJackType\", HFILL }},\n        { &hf_ms_if_midi_in_bjackid,\n            { \"Jack ID\", \"usbaudio.ms_if_midi_in.bJackID\",\n              FT_UINT8, BASE_DEC, NULL, 0x00, \"bJackID\", HFILL }},\n        { &hf_ms_if_midi_in_ijack,\n            { \"String descriptor index\", \"usbaudio.ms_if_midi_in.iJack\",\n              FT_UINT8, BASE_DEC, NULL, 0x00, \"iJack\", HFILL }},\n        { &hf_ms_if_midi_out_bjacktype,\n            { \"Jack Type\", \"usbaudio.ms_if_midi_out.bJackType\",\n              FT_UINT8, BASE_HEX, VALS(ms_midi_jack_type_vals), 0x00, \"bJackType\", HFILL }},\n        { &hf_ms_if_midi_out_bjackid,\n            { \"Jack ID\", \"usbaudio.ms_if_midi_out.bJackID\",\n              FT_UINT8, BASE_DEC, NULL, 0x00, \"bJackID\", HFILL }},\n       { &hf_ms_if_midi_out_bnrinputpins,\n            { \"Number of Input Pins\", \"usbaudio.ms_if_midi_out.bNrInputPins\",\n              FT_UINT8, BASE_DEC, NULL, 0x00, \"bNrInputPins\", HFILL }},\n        { &hf_ms_if_midi_out_basourceid,\n            { \"Connected MIDI Entity\", \"usbaudio.ms_if_midi_out.baSourceID\",\n              FT_UINT8, BASE_DEC, NULL, 0x00, \"baSourceID\", HFILL }},\n        { &hf_ms_if_midi_out_basourcepin,\n            { \"Entity Output Pin\", \"usbaudio.ms_if_midi_out.BaSourcePin\",\n              FT_UINT8, BASE_DEC, NULL, 0x00, \"BaSourcePin\", HFILL }},\n        { &hf_ms_if_midi_out_ijack,\n            { \"String descriptor index\", \"usbaudio.ms_if_midi_out.iJack\",\n              FT_UINT8, BASE_DEC, NULL, 0x00, \"iJack\", HFILL }},\n\n        { &hf_ms_ep_desc_subtype,\n            { \"Subtype\", \"usbaudio.ms_ep_subtype\", FT_UINT8,\n              BASE_HEX, VALS(ms_ep_subtype_vals), 0x00, \"bDescriptorSubtype\", HFILL }},\n        { &hf_ms_ep_gen_numjacks,\n            { \"Number of Embedded MIDI Jacks\", \"usbaudio.ms_ep_gen.bNumEmbMIDIJack\", FT_UINT8,\n              BASE_DEC, NULL, 0x00, \"bNumEmbMIDIJack\", HFILL }},\n        { &hf_ms_ep_gen_baassocjackid,\n            { \"Associated Embedded Jack ID\", \"usbaudio.ms_ep_gen.baAssocJackID\", FT_UINT8,\n              BASE_DEC, NULL, 0x00, \"baAssocJackID\", HFILL }},\n\n        { &hf_brequest_v1,\n            { \"bRequest\", \"usbaudio.bRequest\",\n              FT_UINT8, BASE_HEX|BASE_EXT_STRING, &v1_brequest_vals_ext, 0x0, NULL, HFILL }},\n        { &hf_brequest_v2,\n            { \"bRequest\", \"usbaudio.bRequest\",\n              FT_UINT8, BASE_HEX|BASE_EXT_STRING, &v2_brequest_vals_ext, 0x0, NULL, HFILL }},\n        { &hf_wvalue,\n            { \"wValue\", \"usbaudio.wValue\", FT_UINT16, BASE_HEX,\n              NULL, 0x0, NULL, HFILL }},\n        { &hf_wvalue_channel_number,\n            { \"Channel Number\", \"usbaudio.wValue.channel_number\",\n              FT_UINT16, BASE_HEX, NULL, 0x00FF, NULL, HFILL }},\n        { &hf_wvalue_fu_cs_v1,\n            { \"Feature Unit Control Selector\", \"usbaudio.wValue.fu_cs\",\n              FT_UINT16, BASE_HEX|BASE_EXT_STRING, &v1_fu_cs_vals_ext, 0xFF00, NULL, HFILL }},\n        { &hf_wvalue_clksrc_cs,\n            { \"Clock Source Control Selector\", \"usbaudio.wValue.clksrc_cs\",\n              FT_UINT16, BASE_HEX, VALS(v2_clksrc_cs_vals), 0xFF00, NULL, HFILL }},\n        { &hf_wvalue_clksel_cs,\n            { \"Clock Selector Control Selector\", \"usbaudio.wValue.clksel_cs\",\n              FT_UINT16, BASE_HEX, VALS(v2_clksel_cs_vals), 0xFF00, NULL, HFILL }},\n        { &hf_windex,\n            { \"wIndex\", \"usbaudio.wIndex\",\n              FT_UINT16, BASE_HEX, NULL, 0x0, NULL, HFILL }},\n        { &hf_windex_interface,\n            { \"Interface Number\", \"usbaudio.wIndex.interface\",\n              FT_UINT16, BASE_DEC, NULL, 0x00FF, NULL, HFILL }},\n        { &hf_windex_entity_id,\n            { \"Entity ID\", \"usbaudio.wIndex.entity_id\",\n              FT_UINT16, BASE_DEC, NULL, 0xFF00, NULL, HFILL }},\n        { &hf_windex_endpoint,\n            { \"Endpoint Number\", \"usbaudio.wIndex.endpoint\",\n              FT_UINT16, BASE_HEX, NULL, 0x008F, NULL, HFILL }},\n        { &hf_wlength,\n            { \"wLength\", \"usbaudio.wLength\",\n              FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL }},\n        { &hf_parameter_bselector,\n            { \"bSelector\", \"usbaudio.bSelector\",\n              FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},\n        { &hf_parameter_bmute,\n            { \"bMute\", \"usbaudio.bMute\",\n              FT_BOOLEAN, BASE_NONE, NULL, 0x0, NULL, HFILL }},\n        { &hf_parameter_wvolume,\n            { \"wVolume\", \"usbaudio.wVolume\",\n              FT_UINT16, BASE_CUSTOM, CF_FUNC(base_volume), 0x0, NULL, HFILL }},\n        { &hf_parameter_wnumsubranges,\n            { \"wNumSubRanges\", \"usbaudio.wNumSubRanges\",\n              FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL }},\n        { &hf_parameter_bcur,\n            { \"bCUR\", \"usbaudio.bCUR\",\n              FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},\n        { &hf_parameter_bmin,\n            { \"bMIN\", \"usbaudio.bMIN\",\n              FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},\n        { &hf_parameter_bmax,\n            { \"bMAX\", \"usbaudio.bMAX\",\n              FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},\n        { &hf_parameter_bres,\n            { \"bRES\", \"usbaudio.bRES\",\n              FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},\n        { &hf_parameter_wcur,\n            { \"wCUR\", \"usbaudio.wCUR\",\n              FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL }},\n        { &hf_parameter_wmin,\n            { \"wMIN\", \"usbaudio.wMIN\",\n              FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL }},\n        { &hf_parameter_wmax,\n            { \"wMAX\", \"usbaudio.wMAX\",\n              FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL }},\n        { &hf_parameter_wres,\n            { \"wRES\", \"usbaudio.wRES\",\n              FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL }},\n        { &hf_parameter_dcur,\n            { \"dCUR\", \"usbaudio.bCUR\",\n              FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL }},\n        { &hf_parameter_dmin,\n            { \"dMIN\", \"usbaudio.dMIN\",\n              FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL }},\n        { &hf_parameter_dmax,\n            { \"dMAX\", \"usbaudio.dMAX\",\n              FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL }},\n        { &hf_parameter_dres,\n            { \"dRES\", \"usbaudio.dRES\",\n              FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL }},\n\n        { &hf_sysex_msg_fragments,\n            { \"Message fragments\", \"usbaudio.sysex.fragments\",\n              FT_NONE, BASE_NONE, NULL, 0x00, NULL, HFILL }},\n        { &hf_sysex_msg_fragment,\n            { \"Message fragment\", \"usbaudio.sysex.fragment\",\n              FT_FRAMENUM, BASE_NONE, NULL, 0x00, NULL, HFILL }},\n        { &hf_sysex_msg_fragment_overlap,\n            { \"Message fragment overlap\", \"usbaudio.sysex.fragment.overlap\",\n              FT_BOOLEAN, BASE_NONE, NULL, 0x00, NULL, HFILL }},\n        { &hf_sysex_msg_fragment_overlap_conflicts,\n            { \"Message fragment overlapping with conflicting data\",\n              \"usbaudio.sysex.fragment.overlap.conflicts\",\n              FT_BOOLEAN, BASE_NONE, NULL, 0x00, NULL, HFILL }},\n        { &hf_sysex_msg_fragment_multiple_tails,\n            { \"Message has multiple tail fragments\",\n              \"usbaudio.sysex.fragment.multiple_tails\",\n              FT_BOOLEAN, BASE_NONE, NULL, 0x00, NULL, HFILL }},\n        { &hf_sysex_msg_fragment_too_long_fragment,\n            { \"Message fragment too long\", \"usbaudio.sysex.fragment.too_long_fragment\",\n              FT_BOOLEAN, BASE_NONE, NULL, 0x00, NULL, HFILL }},\n        { &hf_sysex_msg_fragment_error,\n            { \"Message defragmentation error\", \"usbaudio.sysex.fragment.error\",\n              FT_FRAMENUM, BASE_NONE, NULL, 0x00, NULL, HFILL }},\n        { &hf_sysex_msg_fragment_count,\n            { \"Message fragment count\", \"usbaudio.sysex.fragment.count\",\n              FT_UINT32, BASE_DEC, NULL, 0x00, NULL, HFILL }},\n        { &hf_sysex_msg_reassembled_in,\n            { \"Reassembled in\", \"usbaudio.sysex.reassembled.in\",\n              FT_FRAMENUM, BASE_NONE, NULL, 0x00, NULL, HFILL }},\n        { &hf_sysex_msg_reassembled_length,\n            { \"Reassembled length\", \"usbaudio.sysex.reassembled.length\",\n              FT_UINT32, BASE_DEC, NULL, 0x00, NULL, HFILL }},\n        { &hf_sysex_msg_reassembled_data,\n            { \"Reassembled data\", \"usbaudio.sysex.reassembled.data\",\n              FT_BYTES, BASE_NONE, NULL, 0x00, NULL, HFILL }}\n    };\n\n    static int *usb_audio_ett[] = {\n        &ett_usb_audio,\n        &ett_usb_audio_desc,\n        &ett_sysex_msg_fragment,\n        &ett_sysex_msg_fragments,\n        &ett_ac_if_hdr_controls,\n        &ett_ac_if_fu_controls,\n        &ett_ac_if_fu_controls0,\n        &ett_ac_if_fu_controls1,\n        &ett_ac_if_fu_controls_v2,\n        &ett_ac_if_fu_control_v2,\n        &ett_ac_if_su_sourceids,\n        &ett_ac_if_su_controls,\n        &ett_ac_if_input_wchannelconfig,\n        &ett_ac_if_input_bmchannelconfig,\n        &ett_ac_if_input_controls,\n        &ett_ac_if_output_controls,\n        &ett_ac_if_mu_channelconfig,\n        &ett_ac_if_clksrc_attr,\n        &ett_ac_if_clksrc_controls,\n        &ett_ac_if_clksel_controls,\n        &ett_as_if_gen_controls,\n        &ett_ac_if_extunit_bmchannelconfig,\n        &ett_ac_if_extunit_bmcontrols,\n        &ett_as_if_gen_formats,\n        &ett_as_if_gen_bmchannelconfig,\n        &ett_as_ep_gen_attributes,\n        &ett_as_ep_gen_controls,\n        &ett_wvalue,\n        &ett_windex,\n        &ett_parameter_block,\n    };\n\n    static ei_register_info ei[] = {\n        { &ei_usb_audio_undecoded, { \"usbaudio.undecoded\", PI_UNDECODED, PI_WARN, \"Not dissected yet (report to wireshark.org)\", EXPFILL }},\n        { &ei_usb_audio_invalid_feature_unit_length, { \"usbaudio.ac_if_fu.invalid_length\", PI_MALFORMED, PI_ERROR, \"Descriptor size is not 7+(ch+1)*n where n=bControlSize\", EXPFILL }},\n        { &ei_usb_audio_invalid_type_3_ft_nrchannels, { \"usbaudio.as_if_ft.bNrChannels.invalid_value\", PI_MALFORMED, PI_ERROR, \"bNrChannels must be 2 for Type III Format Type descriptors\", EXPFILL }},\n        { &ei_usb_audio_invalid_type_3_ft_subframesize, { \"usbaudio.as_if_ft.subframesize.invalid_value\", PI_MALFORMED, PI_ERROR, \"bSubFrameSize must be 2 for Type III Format Type descriptors\", EXPFILL }},\n        { &ei_usb_audio_invalid_type_3_ft_bitresolution, { \"usbaudio.hf_as_if_ft_bitresolution.invalid_value\", PI_MALFORMED, PI_ERROR, \"bBitResolution must be 16 for Type III Format Type descriptors\", EXPFILL }},\n    };\n\n    expert_module_t *expert_usb_audio;\n\n    proto_usb_audio = proto_register_protocol(\"USB Audio\", \"USBAUDIO\", \"usbaudio\");\n    proto_register_field_array(proto_usb_audio, hf, array_length(hf));\n    proto_register_subtree_array(usb_audio_ett, array_length(usb_audio_ett));\n    expert_usb_audio = expert_register_protocol(proto_usb_audio);\n    expert_register_field_array(expert_usb_audio, ei, array_length(ei));\n    reassembly_table_register(&midi_data_reassembly_table,\n                          &addresses_reassembly_table_functions);\n\n    usb_audio_bulk_handle = register_dissector(\"usbaudio\", dissect_usb_audio_bulk, proto_usb_audio);\n    usb_audio_descr_handle = register_dissector(\"usbaudio.bulk\",  dissect_usb_audio_descriptor, proto_usb_audio);\n    usb_audio_control_handle = register_dissector(\"usbaudio.control\", dissect_usb_audio_control, proto_usb_audio);\n}\n\nvoid\nproto_reg_handoff_usb_audio(void)\n{\n    dissector_add_uint(\"usb.descriptor\", IF_CLASS_AUDIO, usb_audio_descr_handle);\n    dissector_add_uint(\"usb.bulk\", IF_CLASS_AUDIO, usb_audio_bulk_handle);\n    dissector_add_uint(\"usb.control\", IF_CLASS_AUDIO, usb_audio_control_handle);\n\n    sysex_handle = find_dissector_add_dependency(\"sysex\", proto_usb_audio);\n}\n/*\n * Editor modelines\n *\n * Local Variables:\n * c-basic-offset: 4\n * tab-width: 8\n * indent-tabs-mode: nil\n * End:\n *\n * ex: set shiftwidth=4 tabstop=8 expandtab:\n * :indentSize=4:tabSize=8:noTabs=true:\n */\n", "patch": "@@ -435,8 +435,12 @@ dissect_ac_if_hdr_body(tvbuff_t *tvb, gint offset, packet_info *pinfo _U_,\n     if(!audio_conv_info) {\n         audio_conv_info = wmem_new(wmem_file_scope(), audio_conv_info_t);\n         usb_conv_info->class_data = audio_conv_info;\n+        usb_conv_info->class_data_type = USB_CONV_AUDIO;\n         /* XXX - set reasonable default values for all components\n            that are not filled in by this function */\n+    } else if (usb_conv_info->class_data_type != USB_CONV_AUDIO) {\n+        /* Don't dissect if another USB type is in the conversation */\n+        return 0;\n     }\n     audio_conv_info->ver_major = ver_major;\n     offset += 2;", "file_path": "files/2016_8\\48", "file_language": "c", "file_name": "epan/dissectors/packet-usb-audio.c", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}, {"raw_url": "https://github.com/wireshark/wireshark/raw/2cb5985bf47bdc8bea78d28483ed224abdd33dc6/epan/dissectors/packet-usb-masstorage.c", "code": "/* packet-usb-masstorage.c\n *\n * usb mass storage dissector\n * Ronnie Sahlberg 2006\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version 2\n * of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */\n\n\n#include \"config.h\"\n\n#include <epan/packet.h>\n#include \"packet-usb.h\"\n#include \"packet-scsi.h\"\n\nvoid proto_register_usb_ms(void);\nvoid proto_reg_handoff_usb_ms(void);\n\n/* protocols and header fields */\nstatic int proto_usb_ms = -1;\nstatic int hf_usb_ms_dCBWSignature = -1;\nstatic int hf_usb_ms_dCBWTag = -1;\nstatic int hf_usb_ms_dCBWDataTransferLength = -1;\nstatic int hf_usb_ms_dCBWFlags = -1;\nstatic int hf_usb_ms_dCBWTarget = -1;\nstatic int hf_usb_ms_dCBWLUN = -1;\nstatic int hf_usb_ms_dCBWCBLength = -1;\nstatic int hf_usb_ms_dCSWSignature = -1;\nstatic int hf_usb_ms_dCSWDataResidue = -1;\nstatic int hf_usb_ms_dCSWStatus = -1;\nstatic int hf_usb_ms_request = -1;\nstatic int hf_usb_ms_value = -1;\nstatic int hf_usb_ms_index = -1;\nstatic int hf_usb_ms_length = -1;\nstatic int hf_usb_ms_maxlun = -1;\n\nstatic gint ett_usb_ms = -1;\n\n\n/* there is one such structure for each masstorage conversation */\ntypedef struct _usb_ms_conv_info_t {\n    wmem_tree_t *itl;           /* indexed by LUN */\n    wmem_tree_t *itlq;          /* pinfo->num */\n} usb_ms_conv_info_t;\n\n\nstatic const value_string status_vals[] = {\n    {0x00,      \"Command Passed\"},\n    {0x01,      \"Command Failed\"},\n    {0x02,      \"Phase Error\"},\n    {0, NULL}\n};\n\n\n\n\nstatic void\ndissect_usb_ms_reset(packet_info *pinfo _U_, proto_tree *tree, tvbuff_t *tvb, int offset, gboolean is_request, usb_trans_info_t *usb_trans_info _U_, usb_conv_info_t *usb_conv_info _U_)\n{\n    if(is_request){\n        proto_tree_add_item(tree, hf_usb_ms_value, tvb, offset, 2, ENC_BIG_ENDIAN);\n        offset += 2;\n\n        proto_tree_add_item(tree, hf_usb_ms_index, tvb, offset, 2, ENC_BIG_ENDIAN);\n        offset += 2;\n\n        proto_tree_add_item(tree, hf_usb_ms_length, tvb, offset, 2, ENC_BIG_ENDIAN);\n        /*offset += 2;*/\n    } else {\n        /* no data in reset response */\n    }\n}\n\nstatic void\ndissect_usb_ms_get_max_lun(packet_info *pinfo _U_, proto_tree *tree, tvbuff_t *tvb, int offset, gboolean is_request, usb_trans_info_t *usb_trans_info _U_, usb_conv_info_t *usb_conv_info _U_)\n{\n    if(is_request){\n        proto_tree_add_item(tree, hf_usb_ms_value, tvb, offset, 2, ENC_BIG_ENDIAN);\n        offset += 2;\n\n        proto_tree_add_item(tree, hf_usb_ms_index, tvb, offset, 2, ENC_BIG_ENDIAN);\n        offset += 2;\n\n        proto_tree_add_item(tree, hf_usb_ms_length, tvb, offset, 2, ENC_BIG_ENDIAN);\n        /*offset += 2;*/\n    } else {\n        proto_tree_add_item(tree, hf_usb_ms_maxlun, tvb, offset, 1, ENC_BIG_ENDIAN);\n        offset++;\n    }\n}\n\n\ntypedef void (*usb_setup_dissector)(packet_info *pinfo, proto_tree *tree, tvbuff_t *tvb, int offset, gboolean is_request, usb_trans_info_t *usb_trans_info, usb_conv_info_t *usb_conv_info);\n\ntypedef struct _usb_setup_dissector_table_t {\n    guint8 request;\n    usb_setup_dissector dissector;\n} usb_setup_dissector_table_t;\n#define USB_SETUP_RESET               0xff\n#define USB_SETUP_GET_MAX_LUN         0xfe\nstatic const usb_setup_dissector_table_t setup_dissectors[] = {\n    {USB_SETUP_RESET,          dissect_usb_ms_reset},\n    {USB_SETUP_GET_MAX_LUN,    dissect_usb_ms_get_max_lun},\n    {0, NULL}\n};\nstatic const value_string setup_request_names_vals[] = {\n    {USB_SETUP_RESET,          \"RESET\"},\n    {USB_SETUP_GET_MAX_LUN,    \"GET MAX LUN\"},\n    {0, NULL}\n};\n\n/* Dissector for mass storage control .\n * Returns tvb_captured_length(tvb) if a class specific dissector was found\n * and 0 othervise.\n */\nstatic gint\ndissect_usb_ms_control(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)\n{\n    gboolean is_request;\n    usb_conv_info_t *usb_conv_info;\n    usb_trans_info_t *usb_trans_info;\n    int offset=0;\n    usb_setup_dissector dissector = NULL;\n    const usb_setup_dissector_table_t *tmp;\n\n    /* Reject the packet if data or usb_trans_info are NULL */\n    if (data == NULL || ((usb_conv_info_t *)data)->usb_trans_info == NULL)\n        return 0;\n    usb_conv_info = (usb_conv_info_t *)data;\n    usb_trans_info = usb_conv_info->usb_trans_info;\n\n    is_request=(pinfo->srcport==NO_ENDPOINT);\n\n    /* See if we can find a class specific dissector for this request */\n    for(tmp=setup_dissectors;tmp->dissector;tmp++){\n        if (tmp->request == usb_trans_info->setup.request){\n            dissector=tmp->dissector;\n            break;\n        }\n    }\n    /* No we could not find any class specific dissector for this request\n     * return 0 and let USB try any of the standard requests.\n     */\n    if(!dissector){\n        return 0;\n    }\n\n    col_set_str(pinfo->cinfo, COL_PROTOCOL, \"USBMS\");\n\n    col_add_fstr(pinfo->cinfo, COL_INFO, \"%s %s\",\n        val_to_str(usb_trans_info->setup.request, setup_request_names_vals, \"Unknown type %x\"),\n        is_request?\"Request\":\"Response\");\n\n    if(is_request){\n        proto_tree_add_item(tree, hf_usb_ms_request, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n        offset += 1;\n    }\n\n    dissector(pinfo, tree, tvb, offset, is_request, usb_trans_info, usb_conv_info);\n    return tvb_captured_length(tvb);\n}\n\n\n/* dissector for mass storage bulk data */\nstatic int\ndissect_usb_ms_bulk(tvbuff_t *tvb, packet_info *pinfo, proto_tree *parent_tree, void* data)\n{\n    usb_conv_info_t *usb_conv_info;\n    usb_ms_conv_info_t *usb_ms_conv_info;\n    proto_tree *tree;\n    proto_item *ti;\n    guint32 signature=0;\n    int offset=0;\n    gboolean is_request;\n    itl_nexus_t *itl;\n    itlq_nexus_t *itlq;\n\n    /* Reject the packet if data is NULL */\n    if (data == NULL)\n        return 0;\n    usb_conv_info = (usb_conv_info_t *)data;\n\n    /* verify that we do have a usb_ms_conv_info */\n    usb_ms_conv_info=(usb_ms_conv_info_t *)usb_conv_info->class_data;\n    if(!usb_ms_conv_info){\n        usb_ms_conv_info=wmem_new(wmem_file_scope(), usb_ms_conv_info_t);\n        usb_ms_conv_info->itl=wmem_tree_new(wmem_file_scope());\n        usb_ms_conv_info->itlq=wmem_tree_new(wmem_file_scope());\n        usb_conv_info->class_data=usb_ms_conv_info;\n        usb_conv_info->class_data_type = USB_CONV_MASS_STORAGE;\n    } else if (usb_conv_info->class_data_type != USB_CONV_MASS_STORAGE) {\n        /* Don't dissect if another USB type is in the conversation */\n        return 0;\n    }\n\n    is_request=(pinfo->srcport==NO_ENDPOINT);\n\n    col_set_str(pinfo->cinfo, COL_PROTOCOL, \"USBMS\");\n\n    col_clear(pinfo->cinfo, COL_INFO);\n\n\n    ti = proto_tree_add_protocol_format(parent_tree, proto_usb_ms, tvb, 0, -1, \"USB Mass Storage\");\n    tree = proto_item_add_subtree(ti, ett_usb_ms);\n\n    signature=tvb_get_letohl(tvb, offset);\n\n\n    /*\n     * SCSI CDB inside CBW\n     */\n    if(is_request&&(signature==0x43425355)&&(tvb_reported_length(tvb)==31)){\n        tvbuff_t *cdb_tvb;\n        int cdbrlen, cdblen;\n        guint8 lun, flags;\n        guint32 datalen;\n\n        /* dCBWSignature */\n        proto_tree_add_item(tree, hf_usb_ms_dCBWSignature, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n        offset+=4;\n\n        /* dCBWTag */\n        proto_tree_add_item(tree, hf_usb_ms_dCBWTag, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n        offset+=4;\n\n        /* dCBWDataTransferLength */\n        proto_tree_add_item(tree, hf_usb_ms_dCBWDataTransferLength, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n        datalen=tvb_get_letohl(tvb, offset);\n        offset+=4;\n\n        /* dCBWFlags */\n        proto_tree_add_item(tree, hf_usb_ms_dCBWFlags, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n        flags=tvb_get_guint8(tvb, offset);\n        offset+=1;\n\n        /* dCBWLUN */\n        proto_tree_add_item(tree, hf_usb_ms_dCBWTarget, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n        proto_tree_add_item(tree, hf_usb_ms_dCBWLUN, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n        lun=tvb_get_guint8(tvb, offset)&0x0f;\n        offset+=1;\n\n        /* make sure we have a ITL structure for this LUN */\n        itl=(itl_nexus_t *)wmem_tree_lookup32(usb_ms_conv_info->itl, lun);\n        if(!itl){\n            itl=wmem_new(wmem_file_scope(), itl_nexus_t);\n            itl->cmdset=0xff;\n            itl->conversation=NULL;\n            wmem_tree_insert32(usb_ms_conv_info->itl, lun, itl);\n        }\n\n        /* make sure we have an ITLQ structure for this LUN/transaction */\n        itlq=(itlq_nexus_t *)wmem_tree_lookup32(usb_ms_conv_info->itlq, pinfo->num);\n        if(!itlq){\n            itlq=wmem_new(wmem_file_scope(), itlq_nexus_t);\n            itlq->lun=lun;\n            itlq->scsi_opcode=0xffff;\n            itlq->task_flags=0;\n            if(datalen){\n                if(flags&0x80){\n                    itlq->task_flags|=SCSI_DATA_READ;\n                } else {\n                    itlq->task_flags|=SCSI_DATA_WRITE;\n                }\n            }\n            itlq->data_length=datalen;\n            itlq->bidir_data_length=0;\n            itlq->fc_time=pinfo->abs_ts;\n            itlq->first_exchange_frame=pinfo->num;\n            itlq->last_exchange_frame=0;\n            itlq->flags=0;\n            itlq->alloc_len=0;\n            itlq->extra_data=NULL;\n            wmem_tree_insert32(usb_ms_conv_info->itlq, pinfo->num, itlq);\n        }\n\n        /* dCBWCBLength */\n        proto_tree_add_item(tree, hf_usb_ms_dCBWCBLength, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n        cdbrlen=tvb_get_guint8(tvb, offset)&0x1f;\n        offset+=1;\n\n        cdblen=cdbrlen;\n        if(cdblen>tvb_captured_length_remaining(tvb, offset)){\n            cdblen=tvb_captured_length_remaining(tvb, offset);\n        }\n        if(cdblen){\n            cdb_tvb=tvb_new_subset(tvb, offset, cdblen, cdbrlen);\n            dissect_scsi_cdb(cdb_tvb, pinfo, parent_tree, SCSI_DEV_UNKNOWN, itlq, itl);\n        }\n        return tvb_captured_length(tvb);\n    }\n\n\n    /*\n     * SCSI RESPONSE inside CSW\n     */\n    if((!is_request)&&(signature==0x53425355)&&(tvb_reported_length(tvb)==13)){\n        guint8 status;\n\n        /* dCSWSignature */\n        proto_tree_add_item(tree, hf_usb_ms_dCSWSignature, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n        offset+=4;\n\n        /* dCSWTag */\n        proto_tree_add_item(tree, hf_usb_ms_dCBWTag, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n        offset+=4;\n\n        /* dCSWDataResidue */\n        proto_tree_add_item(tree, hf_usb_ms_dCSWDataResidue, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n        offset+=4;\n\n        /* dCSWStatus */\n        proto_tree_add_item(tree, hf_usb_ms_dCSWStatus, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n        status=tvb_get_guint8(tvb, offset);\n        /*offset+=1;*/\n\n        itlq=(itlq_nexus_t *)wmem_tree_lookup32_le(usb_ms_conv_info->itlq, pinfo->num);\n        if(!itlq){\n            return tvb_captured_length(tvb);\n        }\n        itlq->last_exchange_frame=pinfo->num;\n\n        itl=(itl_nexus_t *)wmem_tree_lookup32(usb_ms_conv_info->itl, itlq->lun);\n        if(!itl){\n            return tvb_captured_length(tvb);\n        }\n\n        if(!status){\n            dissect_scsi_rsp(tvb, pinfo, parent_tree, itlq, itl, 0);\n        } else {\n            /* just send \"check condition\" */\n            dissect_scsi_rsp(tvb, pinfo, parent_tree, itlq, itl, 0x02);\n        }\n        return tvb_captured_length(tvb);\n    }\n\n    /*\n     * Ok it was neither CDB not STATUS so just assume it is either data in/out\n     */\n    itlq=(itlq_nexus_t *)wmem_tree_lookup32_le(usb_ms_conv_info->itlq, pinfo->num);\n    if(!itlq){\n        return tvb_captured_length(tvb);\n    }\n\n    itl=(itl_nexus_t *)wmem_tree_lookup32(usb_ms_conv_info->itl, itlq->lun);\n    if(!itl){\n        return tvb_captured_length(tvb);\n    }\n\n    dissect_scsi_payload(tvb, pinfo, parent_tree, is_request, itlq, itl, 0);\n    return tvb_captured_length(tvb);\n}\n\nstatic gboolean\ndissect_usb_ms_bulk_heur(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)\n{\n    const gchar usbc[] = {0x55, 0x53, 0x42, 0x43};\n    const gchar usbs[] = {0x55, 0x53, 0x42, 0x53};\n    if (tvb_reported_length(tvb) < 4)\n        return FALSE;\n\n    if (tvb_memeql(tvb, 0, usbc, sizeof(usbc)) == 0 ||\n        tvb_memeql(tvb, 0, usbs, sizeof(usbs)) == 0) {\n        dissect_usb_ms_bulk(tvb, pinfo, tree, data);\n        return TRUE;\n    }\n\n    return FALSE;\n}\n\nvoid\nproto_register_usb_ms(void)\n{\n    static hf_register_info hf[] = {\n        { &hf_usb_ms_dCBWSignature,\n        { \"Signature\", \"usbms.dCBWSignature\", FT_UINT32, BASE_HEX,\n          NULL, 0x0, NULL, HFILL }},\n\n        { &hf_usb_ms_dCBWTag,\n        { \"Tag\", \"usbms.dCBWTag\", FT_UINT32, BASE_HEX,\n          NULL, 0x0, NULL, HFILL }},\n\n        { &hf_usb_ms_dCBWDataTransferLength,\n        { \"DataTransferLength\", \"usbms.dCBWDataTransferLength\", FT_UINT32, BASE_DEC,\n          NULL, 0x0, NULL, HFILL }},\n\n        { &hf_usb_ms_dCBWFlags,\n        { \"Flags\", \"usbms.dCBWFlags\", FT_UINT8, BASE_HEX,\n          NULL, 0x0, NULL, HFILL }},\n\n        { &hf_usb_ms_dCBWTarget,\n        { \"Target\", \"usbms.dCBWTarget\", FT_UINT8, BASE_HEX_DEC,\n          NULL, 0x70, \"Target Number when enabling multi-target mode\", HFILL }},\n\n        { &hf_usb_ms_dCBWLUN,\n        { \"LUN\", \"usbms.dCBWLUN\", FT_UINT8, BASE_HEX,\n          NULL, 0x0f, NULL, HFILL }},\n\n        { &hf_usb_ms_dCBWCBLength,\n        { \"CDB Length\", \"usbms.dCBWCBLength\", FT_UINT8, BASE_HEX,\n          NULL, 0x1f, NULL, HFILL }},\n\n        { &hf_usb_ms_dCSWSignature,\n        { \"Signature\", \"usbms.dCSWSignature\", FT_UINT32, BASE_HEX,\n          NULL, 0x0, NULL, HFILL }},\n\n        { &hf_usb_ms_dCSWDataResidue,\n        { \"DataResidue\", \"usbms.dCSWDataResidue\", FT_UINT32, BASE_DEC,\n          NULL, 0x0, NULL, HFILL }},\n\n        { &hf_usb_ms_dCSWStatus,\n        { \"Status\", \"usbms.dCSWStatus\", FT_UINT8, BASE_HEX,\n          VALS(status_vals), 0x0, NULL, HFILL }},\n\n        { &hf_usb_ms_request,\n        { \"bRequest\", \"usbms.setup.bRequest\", FT_UINT8, BASE_HEX, VALS(setup_request_names_vals), 0x0,\n                NULL, HFILL }},\n\n        { &hf_usb_ms_value,\n        { \"wValue\", \"usbms.setup.wValue\", FT_UINT16, BASE_HEX, NULL, 0x0,\n                NULL, HFILL }},\n\n        { &hf_usb_ms_index,\n        { \"wIndex\", \"usbms.setup.wIndex\", FT_UINT16, BASE_DEC, NULL, 0x0,\n                NULL, HFILL }},\n\n        { &hf_usb_ms_length,\n        { \"wLength\", \"usbms.setup.wLength\", FT_UINT16, BASE_DEC, NULL, 0x0,\n                NULL, HFILL }},\n\n        { &hf_usb_ms_maxlun,\n        { \"Max LUN\", \"usbms.setup.maxlun\", FT_UINT8, BASE_DEC, NULL, 0x0,\n                NULL, HFILL }},\n\n    };\n\n    static gint *usb_ms_subtrees[] = {\n            &ett_usb_ms,\n    };\n\n\n    proto_usb_ms = proto_register_protocol(\"USB Mass Storage\", \"USBMS\", \"usbms\");\n    proto_register_field_array(proto_usb_ms, hf, array_length(hf));\n    proto_register_subtree_array(usb_ms_subtrees, array_length(usb_ms_subtrees));\n\n    register_dissector(\"usbms\", dissect_usb_ms_bulk, proto_usb_ms);\n}\n\nvoid\nproto_reg_handoff_usb_ms(void)\n{\n    dissector_handle_t usb_ms_bulk_handle;\n    dissector_handle_t usb_ms_control_handle;\n\n    usb_ms_bulk_handle = find_dissector(\"usbms\");\n    dissector_add_uint(\"usb.bulk\", IF_CLASS_MASS_STORAGE, usb_ms_bulk_handle);\n\n    usb_ms_control_handle = create_dissector_handle(dissect_usb_ms_control, proto_usb_ms);\n    dissector_add_uint(\"usb.control\", IF_CLASS_MASS_STORAGE, usb_ms_control_handle);\n\n    heur_dissector_add(\"usb.bulk\", dissect_usb_ms_bulk_heur, \"Mass Storage USB bulk endpoint\", \"ms_usb_bulk\", proto_usb_ms, HEURISTIC_ENABLE);\n}\n\n/*\n * Editor modelines  -  http://www.wireshark.org/tools/modelines.html\n *\n * Local variables:\n * c-basic-offset: 4\n * tab-width: 8\n * indent-tabs-mode: nil\n * End:\n *\n * vi: set shiftwidth=4 tabstop=8 expandtab:\n * :indentSize=4:tabSize=8:noTabs=true:\n */\n", "code_before": "/* packet-usb-masstorage.c\n * USB Mass Storage class stub dissector\n * Copyright 2021, Aidan MacDonald <amachronic@protonmail.com>\n *\n * Wireshark - Network traffic analyzer\n * By Gerald Combs <gerald@wireshark.org>\n * Copyright 1998 Gerald Combs\n *\n * SPDX-License-Identifier: GPL-2.0-or-later\n */\n\n#include \"config.h\"\n\n#include <epan/packet.h>\n#include \"packet-usb.h\"\n\nstatic int proto_usb_ms;\n\nstatic dissector_handle_t usb_ms_bulk_handle;\nstatic dissector_handle_t usb_ms_control_handle;\nstatic dissector_handle_t usb_ms_interrupt_handle;\nstatic dissector_handle_t usb_ms_descriptor_handle;\n\nstatic dissector_table_t usb_ms_bulk_dissector_table;\nstatic dissector_table_t usb_ms_control_dissector_table;\nstatic dissector_table_t usb_ms_interrupt_dissector_table;\nstatic dissector_table_t usb_ms_descriptor_dissector_table;\n\nvoid proto_register_usb_ms(void);\nvoid proto_reg_handoff_usb_ms(void);\n\n#define MSC_SUBCLASS_SCSI_COMMAND_SET_NOT_REPORTED 0x00\n#define MSC_SUBCLASS_RBC                           0x01\n#define MSC_SUBCLASS_MMC_5_ATAPI                   0x02\n#define MSC_SUBCLASS_OBSOLETE_QIC_157              0x03\n#define MSC_SUBCLASS_UFI                           0x04\n#define MSC_SUBCLASS_OBSOLETE_SFF_8070I            0x05\n#define MSC_SUBCLASS_SCSI_TRANSPARENT_COMMAND_SET  0x06\n#define MSC_SUBCLASS_LSD_FS                        0x07\n#define MSC_SUBCLASS_IEEE_1667                     0x08\n#define MSC_SUBCLASS_VENDOR                        0xFF\n\nstatic const value_string usb_massstorage_subclass_vals[] = {\n    {MSC_SUBCLASS_SCSI_COMMAND_SET_NOT_REPORTED, \"SCSI command set not reported\"},\n    {MSC_SUBCLASS_RBC,                           \"RBC\"},\n    {MSC_SUBCLASS_MMC_5_ATAPI,                   \"MMC-5 (ATAPI)\"},\n    {MSC_SUBCLASS_OBSOLETE_QIC_157,              \"Obsolete (was QIC-157)\"},\n    {MSC_SUBCLASS_UFI,                           \"UFI\"},\n    {MSC_SUBCLASS_OBSOLETE_SFF_8070I,            \"Obsolete (was SFF-8070i)\"},\n    {MSC_SUBCLASS_SCSI_TRANSPARENT_COMMAND_SET,  \"SCSI transparent command set\"},\n    {MSC_SUBCLASS_LSD_FS,                        \"LSD FS\"},\n    {MSC_SUBCLASS_IEEE_1667,                     \"IEEE 1667\"},\n    {MSC_SUBCLASS_VENDOR,                        \"Specific to device vendor\"},\n    {0, NULL}\n};\nvalue_string_ext ext_usb_massstorage_subclass_vals = VALUE_STRING_EXT_INIT(usb_massstorage_subclass_vals);\n\n#define MSC_PROTOCOL_CBI_NO_INTERRUPT   0x00\n#define MSC_PROTOCOL_CBI_WITH_INTERRUPT 0x01\n#define MSC_PROTOCOL_OBSOLETE           0x02\n#define MSC_PROTOCOL_BULK_ONLY          0x50\n#define MSC_PROTOCOL_UAS                0x62\n#define MSC_PROTOCOL_VENDOR             0xFF\n\nstatic const value_string usb_massstorage_protocol_vals[] = {\n    {MSC_PROTOCOL_CBI_NO_INTERRUPT,   \"Control/Bulk/Interrupt (CBI) Transport with command completion interrupt\"},\n    {MSC_PROTOCOL_CBI_WITH_INTERRUPT, \"Control/Bulk/Interrupt (CBI) Transport with no command completion interrupt\"},\n    {MSC_PROTOCOL_OBSOLETE,           \"Obsolete\"},\n    {MSC_PROTOCOL_BULK_ONLY,          \"Bulk-Only (BBB) Transport\"},\n    {MSC_PROTOCOL_UAS,                \"UAS\"},\n    {MSC_PROTOCOL_VENDOR,             \"Specific to device vendor\"},\n    {0, NULL}\n};\nvalue_string_ext usb_massstorage_protocol_vals_ext = VALUE_STRING_EXT_INIT(usb_massstorage_protocol_vals);\n\nstatic int\ndissect_usb_ms_bulk(tvbuff_t *tvb, packet_info *pinfo, proto_tree *parent_tree, void *data)\n{\n    urb_info_t *urb;\n\n    urb = (urb_info_t *)data;\n\n    return dissector_try_uint_new(usb_ms_bulk_dissector_table, urb->conv->interfaceProtocol, tvb, pinfo, parent_tree, true, urb);\n}\n\nstatic int\ndissect_usb_ms_control(tvbuff_t *tvb, packet_info *pinfo, proto_tree *parent_tree, void *data)\n{\n    urb_info_t *urb;\n\n    urb = (urb_info_t *)data;\n\n    return dissector_try_uint_new(usb_ms_control_dissector_table, urb->conv->interfaceProtocol, tvb, pinfo, parent_tree, true, urb);\n}\n\nstatic int\ndissect_usb_ms_interrupt(tvbuff_t *tvb, packet_info *pinfo, proto_tree *parent_tree, void *data)\n{\n    urb_info_t *urb;\n\n    urb = (urb_info_t *)data;\n\n    return dissector_try_uint_new(usb_ms_interrupt_dissector_table, urb->conv->interfaceProtocol, tvb, pinfo, parent_tree, true, urb);\n}\n\nstatic int\ndissect_usb_ms_descriptor(tvbuff_t *tvb, packet_info *pinfo, proto_tree *parent_tree, void *data)\n{\n    urb_info_t *urb;\n\n    urb = (urb_info_t *)data;\n\n    return dissector_try_uint_new(usb_ms_descriptor_dissector_table, urb->conv->interfaceProtocol, tvb, pinfo, parent_tree, true, urb);\n}\n\nvoid\nproto_register_usb_ms(void)\n{\n    proto_usb_ms = proto_register_protocol(\"USB Mass Storage Class\", \"USBMSClass\", \"usbmsclass\");\n\n    usb_ms_bulk_handle = register_dissector(\"usbmsclass.bulk\", dissect_usb_ms_bulk, proto_usb_ms);\n    usb_ms_control_handle = register_dissector(\"usbmsclass.control\", dissect_usb_ms_control, proto_usb_ms);\n    usb_ms_interrupt_handle = register_dissector(\"usbmsclass.interrupt\", dissect_usb_ms_interrupt, proto_usb_ms);\n    usb_ms_descriptor_handle = register_dissector(\"usbmsclass.descriptor\", dissect_usb_ms_descriptor, proto_usb_ms);\n\n    usb_ms_bulk_dissector_table = register_dissector_table(\"usbms.bulk\",\n        \"USBMS bulk endpoint\", proto_usb_ms, FT_UINT8, BASE_HEX);\n    usb_ms_control_dissector_table = register_dissector_table(\"usbms.control\",\n        \"USBMS control endpoint\", proto_usb_ms, FT_UINT8, BASE_HEX);\n    usb_ms_interrupt_dissector_table = register_dissector_table(\"usbms.interrupt\",\n        \"USBMS interrupt endpoint\", proto_usb_ms, FT_UINT8, BASE_HEX);\n    usb_ms_descriptor_dissector_table = register_dissector_table(\"usbms.descriptor\",\n        \"USBMS descriptor\", proto_usb_ms, FT_UINT8, BASE_HEX);\n}\n\nvoid\nproto_reg_handoff_usb_ms(void)\n{\n    dissector_add_uint(\"usb.bulk\", IF_CLASS_MASS_STORAGE, usb_ms_bulk_handle);\n    dissector_add_uint(\"usb.control\", IF_CLASS_MASS_STORAGE, usb_ms_control_handle);\n    dissector_add_uint(\"usb.interrupt\", IF_CLASS_MASS_STORAGE, usb_ms_interrupt_handle);\n    dissector_add_uint(\"usb.descriptor\", IF_CLASS_MASS_STORAGE, usb_ms_descriptor_handle);\n}\n\n/*\n * Editor modelines  -  https://www.wireshark.org/tools/modelines.html\n *\n * Local variables:\n * c-basic-offset: 4\n * tab-width: 8\n * indent-tabs-mode: nil\n * End:\n *\n * vi: set shiftwidth=4 tabstop=8 expandtab:\n * :indentSize=4:tabSize=8:noTabs=true:\n */\n", "patch": "@@ -199,9 +199,12 @@ dissect_usb_ms_bulk(tvbuff_t *tvb, packet_info *pinfo, proto_tree *parent_tree,\n         usb_ms_conv_info->itl=wmem_tree_new(wmem_file_scope());\n         usb_ms_conv_info->itlq=wmem_tree_new(wmem_file_scope());\n         usb_conv_info->class_data=usb_ms_conv_info;\n+        usb_conv_info->class_data_type = USB_CONV_MASS_STORAGE;\n+    } else if (usb_conv_info->class_data_type != USB_CONV_MASS_STORAGE) {\n+        /* Don't dissect if another USB type is in the conversation */\n+        return 0;\n     }\n \n-\n     is_request=(pinfo->srcport==NO_ENDPOINT);\n \n     col_set_str(pinfo->cinfo, COL_PROTOCOL, \"USBMS\");", "file_path": "files/2016_8\\49", "file_language": "c", "file_name": "epan/dissectors/packet-usb-masstorage.c", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}, {"raw_url": "https://github.com/wireshark/wireshark/raw/2cb5985bf47bdc8bea78d28483ed224abdd33dc6/epan/dissectors/packet-usb-video.c", "code": "/* packet-usb-video.c\n *\n * Forked from packet-usb-masstorage.c 35224 2010-12-20 05:35:29Z guy\n * which was authored by Ronnie Sahlberg (2006)\n *\n * usb video dissector\n * Steven J. Magnani 2013\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version 2\n * of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */\n\n#include \"config.h\"\n\n#include <epan/packet.h>\n#include <epan/expert.h>\n#include \"packet-usb.h\"\n\nvoid proto_register_usb_vid(void);\nvoid proto_reg_handoff_usb_vid(void);\n\n/* References are to sections in USB Video Class specifications -\n * specifically V1.5, but versions have tended to keep\n * the same numbering (as of this writing).\n *\n * http://www.usb.org/developers/devclass_docs/USB_Video_Class_1_5.zip\n */\n\n/* Table 2-1. Interrupt originators */\n#define INT_VIDEOCONTROL               1\n#define INT_VIDEOSTREAMING             2\n\n#define INT_ORIGINATOR_MASK            0xF\n\n/* Table 2-2. Video Control Status Packet bAttribute */\n#define CONTROL_CHANGE_VALUE           0x00\n#define CONTROL_CHANGE_INFO            0x01\n#define CONTROL_CHANGE_FAILURE         0x02\n#define CONTROL_CHANGE_MIN             0x03   /* UVC 1.5+ */\n#define CONTROL_CHANGE_MAX             0x04   /* UVC 1.5+ */\n\n\n/* A.2 Video Interface Subclass Codes */\n#define SC_UNDEFINED                   0\n#define SC_VIDEOCONTROL                1\n#define SC_VIDEOSTREAMING              2\n#define SC_VIDEO_INTERFACE_COLLECTION  3\n\n/* A.4. Video Class-Specific Descriptor Types */\n#define CS_INTERFACE       0x24\n#define CS_ENDPOINT        0x25\n\n/* A.5 Video Class-Specific VC Interface Descriptor Subtypes */\n#define VC_HEADER           1\n#define VC_INPUT_TERMINAL   2\n#define VC_OUTPUT_TERMINAL  3\n#define VC_SELECTOR_UNIT    4\n#define VC_PROCESSING_UNIT  5\n#define VC_EXTENSION_UNIT   6\n#define VC_ENCODING_UNIT    7\n\n/* A.6 Video Class-Specific VS Interface Descriptor Subtypes */\n#define VS_UNDEFINED             0x00\n#define VS_INPUT_HEADER          0x01\n#define VS_OUTPUT_HEADER         0x02\n#define VS_STILL_IMAGE_FRAME     0x03\n#define VS_FORMAT_UNCOMPRESSED   0x04\n#define VS_FRAME_UNCOMPRESSED    0x05\n#define VS_FORMAT_MJPEG          0x06\n#define VS_FRAME_MJPEG           0x07\n#define VS_FORMAT_MPEG1          0x08     /* Pre-UVC 1.1 */\n#define VS_FORMAT_MPEG2PS        0x09     /* Pre-UVC 1.1 */\n#define VS_FORMAT_MPEG2TS        0x0A\n#define VS_FORMAT_MPEG4SL        0x0B     /* Pre-UVC 1.1 */\n#define VS_FORMAT_DV             0x0C\n#define VS_COLORFORMAT           0x0D\n#define VS_FORMAT_VENDOR         0x0E     /* Pre-UVC 1.1 */\n#define VS_FRAME_VENDOR          0x0F     /* Pre-UVC 1.1 */\n#define VS_FORMAT_FRAME_BASED    0x10\n#define VS_FRAME_FRAME_BASED     0x11\n#define VS_FORMAT_STREAM_BASED   0x12\n#define VS_FORMAT_H264           0x13       /* UVC 1.5 */\n#define VS_FRAME_H264            0x14       /* UVC 1.5 */\n#define VS_FORMAT_H264_SIMULCAST 0x15       /* UVC 1.5 */\n#define VS_FORMAT_VP8            0x16       /* UVC 1.5 */\n#define VS_FRAME_VP8             0x17       /* UVC 1.5 */\n#define VS_FORMAT_VP8_SIMULCAST  0x18       /* UVC 1.5 */\n\n/* A.7 Video Class-Specific Endpoint Descriptor Subtypes */\n#define EP_INTERRUPT           0x03\n\n/* A.9.1 Video Control Interface Control Selectors */\n#define VC_CONTROL_UNDEFINED                      0x00\n#define VC_VIDEO_POWER_MODE_CONTROL               0x01\n#define VC_REQUEST_ERROR_CODE_CONTROL             0x02\n#define VC_REQUEST_INDICATE_HOST_CLOCK_CONTROL    0x03  /* Pre-UVC 1.1 */\n\n/* A.9.3 Selector Unit Control Selectors */\n#define SU_CONTROL_UNDEFINED                      0x00\n#define SU_INPUT_SELECT_CONTROL                   0x01\n\n/* A.9.4 Camera Terminal Control Selectors */\n#define CT_CONTROL_UNDEFINED                      0x00\n#define CT_SCANNING_MODE_CONTROL                  0x01\n#define CT_AE_MODE_CONTROL                        0x02\n#define CT_AE_PRIORITY_CONTROL                    0x03\n#define CT_EXPOSURE_TIME_ABSOLUTE_CONTROL         0x04\n#define CT_EXPOSURE_TIME_RELATIVE_CONTROL         0x05\n#define CT_FOCUS_ABSOLUTE_CONTROL                 0x06\n#define CT_FOCUS_RELATIVE_CONTROL                 0x07\n#define CT_FOCUS_AUTO_CONTROL                     0x08\n#define CT_IRIS_ABSOLUTE_CONTROL                  0x09\n#define CT_IRIS_RELATIVE_CONTROL                  0x0A\n#define CT_ZOOM_ABSOLUTE_CONTROL                  0x0B\n#define CT_ZOOM_RELATIVE_CONTROL                  0x0C\n#define CT_PANTILT_ABSOLUTE_CONTROL               0x0D\n#define CT_PANTILT_RELATIVE_CONTROL               0x0E\n#define CT_ROLL_ABSOLUTE_CONTROL                  0x0F\n#define CT_ROLL_RELATIVE_CONTROL                  0x10\n#define CT_PRIVACY_CONTROL                        0x11\n#define CT_FOCUS_SIMPLE_CONTROL                   0x12  /* UVC 1.5 */\n#define CT_WINDOW_CONTROL                         0x13  /* UVC 1.5 */\n#define CT_REGION_OF_INTEREST_CONTROL             0x14  /* UVC 1.5 */\n\n/* A.9.5 Processing Unit Control Selectors */\n#define PU_CONTROL_UNDEFINED                      0x00\n#define PU_BACKLIGHT_COMPENSATION_CONTROL         0x01\n#define PU_BRIGHTNESS_CONTROL                     0x02\n#define PU_CONTRAST_CONTROL                       0x03\n#define PU_GAIN_CONTROL                           0x04\n#define PU_POWER_LINE_FREQUENCY_CONTROL           0x05\n#define PU_HUE_CONTROL                            0x06\n#define PU_SATURATION_CONTROL                     0x07\n#define PU_SHARPNESS_CONTROL                      0x08\n#define PU_GAMMA_CONTROL                          0x09\n#define PU_WHITE_BALANCE_TEMPERATURE_CONTROL      0x0A\n#define PU_WHITE_BALANCE_TEMPERATURE_AUTO_CONTROL 0x0B\n#define PU_WHITE_BALANCE_COMPONENT_CONTROL        0x0C\n#define PU_WHITE_BALANCE_COMPONENT_AUTO_CONTROL   0x0D\n#define PU_DIGITAL_MULTIPLIER_CONTROL             0x0E\n#define PU_DIGITAL_MULTIPLIER_LIMIT_CONTROL       0x0F\n#define PU_HUE_AUTO_CONTROL                       0x10\n#define PU_ANALOG_VIDEO_STANDARD_CONTROL          0x11\n#define PU_ANALOG_LOCK_STATUS_CONTROL             0x12\n#define PU_CONTRAST_AUTO_CONTROL                  0x13\n\n/* A.9.7 VideoStreaming Interface Control Selectors */\n#define VS_CONTROL_UNDEFINED                      0x00\n#define VS_PROBE_CONTROL                          0x01\n#define VS_COMMIT_CONTROL                         0x02\n#define VS_STILL_PROBE_CONTROL                    0x03\n#define VS_STILL_COMMIT_CONTROL                   0x04\n#define VS_STILL_IMAGE_TRIGGER_CONTROL            0x05\n#define VS_STREAM_ERROR_CODE_CONTROL              0x06\n#define VS_GENERATE_KEY_FRAME_CONTROL             0x07\n#define VS_UPDATE_FRAME_SEGMENT_CONTROL           0x08\n#define VS_SYNCH_DELAY_CONTROL                    0x09\n\n/* Appendix B Terminal Types */\n#define TT_VENDOR_SPECIFIC          0x100\n#define TT_STREAMING                0x101\n#define ITT_VENDOR_SPECIFIC         0x200\n#define ITT_CAMERA                  0x201\n#define ITT_MEDIA_TRANSPORT_INPUT   0x202\n#define OTT_VENDOR_SPECIFIC         0x300\n#define OTT_DISPLAY                 0x301\n#define OTT_MEDIA_TRANSPORT_OUTPUT  0x302\n#define EXTERNAL_VENDOR_SPECIFIC    0x400\n#define COMPOSITE_CONNECTOR         0x401\n#define SVIDEO_CONNECTOR            0x402\n#define COMPONENT_CONNECTOR         0x403\n\n/* Table 2-2 Status Packet Format (VideoControl Interface as the Originator) */\n#define CONTROL_INTERRUPT_EVENT_CONTROL_CHANGE  0\n\n/* Table 4-7 Request Error Code Control bRequestErrorCode */\n#define UVC_ERROR_NONE              0\n#define UVC_ERROR_NOT_READY         1\n#define UVC_ERROR_WRONG_STATE       2\n#define UVC_ERROR_POWER             3\n#define UVC_ERROR_OUT_OF_RANGE      4\n#define UVC_ERROR_INVALID_UNIT      5\n#define UVC_ERROR_INVALID_CONTROL   6\n#define UVC_ERROR_INVALID_REQUEST   7\n#define UVC_ERROR_INVALID_VALUE     8\n#define UVC_ERROR_UNKNOWN           255\n\n/* A.8 Video Class-Specific Request Codes */\n#define USB_SETUP_SET_CUR           0x01\n#define USB_SETUP_SET_CUR_ALL       0x11    /* UVC 1.5 */\n#define USB_SETUP_GET_CUR           0x81\n#define USB_SETUP_GET_MIN           0x82\n#define USB_SETUP_GET_MAX           0x83\n#define USB_SETUP_GET_RES           0x84\n#define USB_SETUP_GET_LEN           0x85\n#define USB_SETUP_GET_INFO          0x86\n#define USB_SETUP_GET_DEF           0x87\n#define USB_SETUP_GET_CUR_ALL       0x91    /* UVC 1.5 */\n#define USB_SETUP_GET_MIN_ALL       0x92    /* UVC 1.5 */\n#define USB_SETUP_GET_MAX_ALL       0x93    /* UVC 1.5 */\n#define USB_SETUP_GET_RES_ALL       0x94    /* UVC 1.5 */\n#define USB_SETUP_GET_DEF_ALL       0x97    /* UVC 1.5 */\n\n/* protocols and header fields */\nstatic int proto_usb_vid = -1;\n\nstatic int hf_usb_vid_control_entity    = -1;\nstatic int hf_usb_vid_control_interface = -1;\nstatic int hf_usb_vid_control_selector  = -1;\nstatic int hf_usb_vid_epdesc_subtype = -1;\nstatic int hf_usb_vid_epdesc_max_transfer_sz = -1;\nstatic int hf_usb_vid_control_ifdesc_subtype = -1;\nstatic int hf_usb_vid_control_ifdesc_terminal_id = -1;\nstatic int hf_usb_vid_control_ifdesc_terminal_type = -1;\nstatic int hf_usb_vid_control_ifdesc_assoc_terminal = -1;\nstatic int hf_usb_vid_streaming_ifdesc_subtype = -1;\nstatic int hf_usb_vid_streaming_ifdesc_bNumFormats = -1;\nstatic int hf_usb_vid_control_ifdesc_unit_id = -1;\nstatic int hf_usb_vid_request = -1;\nstatic int hf_usb_vid_length = -1;\nstatic int hf_usb_vid_interrupt_bStatusType = -1;\nstatic int hf_usb_vid_interrupt_bOriginator = -1;\nstatic int hf_usb_vid_interrupt_bAttribute = -1;\nstatic int hf_usb_vid_control_interrupt_bEvent = -1;\nstatic int hf_usb_vid_control_ifdesc_bcdUVC = -1;\nstatic int hf_usb_vid_ifdesc_wTotalLength = -1;\nstatic int hf_usb_vid_control_ifdesc_dwClockFrequency = -1;\nstatic int hf_usb_vid_control_ifdesc_bInCollection = -1;\nstatic int hf_usb_vid_control_ifdesc_baInterfaceNr = -1;\nstatic int hf_usb_vid_control_ifdesc_iTerminal = -1;\nstatic int hf_usb_vid_control_ifdesc_src_id = -1;\nstatic int hf_usb_vid_cam_objective_focal_len_min = -1;\nstatic int hf_usb_vid_cam_objective_focal_len_max = -1;\nstatic int hf_usb_vid_cam_ocular_focal_len = -1;\nstatic int hf_usb_vid_bControlSize = -1;\nstatic int hf_usb_vid_bmControl = -1;\nstatic int hf_usb_vid_bmControl_bytes = -1;\nstatic int hf_usb_vid_control_default = -1;\nstatic int hf_usb_vid_control_min = -1;\nstatic int hf_usb_vid_control_max = -1;\nstatic int hf_usb_vid_control_res = -1;\nstatic int hf_usb_vid_control_cur = -1;\nstatic int hf_usb_vid_control_info = -1;\nstatic int hf_usb_vid_control_info_D[7]   = { -1, -1, -1, -1, -1, -1, -1 };\nstatic int hf_usb_vid_control_length = -1;\nstatic int hf_usb_vid_cam_control_D[22]   = { -1, -1, -1, -1, -1, -1, -1, -1,\n                                              -1, -1, -1, -1, -1, -1, -1, -1,\n                                              -1, -1, -1, -1, -1, -1 };\nstatic int hf_usb_vid_proc_control_D[19]  = { -1, -1, -1, -1, -1, -1, -1, -1,\n                                              -1, -1, -1, -1, -1, -1, -1, -1,\n                                              -1, -1, -1 };\nstatic int hf_usb_vid_proc_standards_D[6] = { -1, -1, -1, -1, -1, -1 };\nstatic int hf_usb_vid_exten_guid = -1;\nstatic int hf_usb_vid_exten_num_controls = -1;\nstatic int hf_usb_vid_num_inputs = -1;\nstatic int hf_usb_vid_sources = -1;\nstatic int hf_usb_vid_streaming_bmInfo = -1;\nstatic int hf_usb_vid_streaming_info_D[1] = { -1 };\nstatic int hf_usb_vid_streaming_terminal_link = -1;\nstatic int hf_usb_vid_streaming_still_capture_method = -1;\nstatic int hf_usb_vid_streaming_trigger_support = -1;\nstatic int hf_usb_vid_streaming_trigger_usage = -1;\nstatic int hf_usb_vid_streaming_control_D[6] = { -1, -1, -1, -1, -1, -1 };\nstatic int hf_usb_vid_format_index = -1;\nstatic int hf_usb_vid_format_num_frame_descriptors = -1;\nstatic int hf_usb_vid_format_guid = -1;\nstatic int hf_usb_vid_format_bits_per_pixel = -1;\nstatic int hf_usb_vid_default_frame_index = -1;\nstatic int hf_usb_vid_aspect_ratio_x = -1;\nstatic int hf_usb_vid_aspect_ratio_y = -1;\nstatic int hf_usb_vid_interlace_flags = -1;\nstatic int hf_usb_vid_is_interlaced = -1;\nstatic int hf_usb_vid_interlaced_fields = -1;\nstatic int hf_usb_vid_field_1_first = -1;\nstatic int hf_usb_vid_field_pattern = -1;\nstatic int hf_usb_vid_copy_protect = -1;\nstatic int hf_usb_vid_variable_size = -1;\nstatic int hf_usb_vid_frame_index = -1;\nstatic int hf_usb_vid_frame_capabilities = -1;\nstatic int hf_usb_vid_frame_stills_supported = -1;\nstatic int hf_usb_vid_frame_fixed_frame_rate = -1;\nstatic int hf_usb_vid_frame_width = -1;\nstatic int hf_usb_vid_frame_height = -1;\nstatic int hf_usb_vid_frame_min_bit_rate = -1;\nstatic int hf_usb_vid_frame_max_bit_rate = -1;\nstatic int hf_usb_vid_frame_max_frame_sz = -1;\nstatic int hf_usb_vid_frame_default_interval = -1;\nstatic int hf_usb_vid_frame_bytes_per_line = -1;\nstatic int hf_usb_vid_mjpeg_flags = -1;\nstatic int hf_usb_vid_mjpeg_fixed_samples = -1;\nstatic int hf_usb_vid_probe_hint = -1;\nstatic int hf_usb_vid_probe_hint_D[5] = { -1, -1, -1, -1, -1 };\nstatic int hf_usb_vid_frame_interval = -1;\nstatic int hf_usb_vid_probe_key_frame_rate = -1;\nstatic int hf_usb_vid_probe_p_frame_rate = -1;\nstatic int hf_usb_vid_probe_comp_quality = -1;\nstatic int hf_usb_vid_probe_comp_window = -1;\nstatic int hf_usb_vid_probe_delay = -1;\nstatic int hf_usb_vid_probe_max_frame_sz = -1;\nstatic int hf_usb_vid_probe_max_payload_sz = -1;\nstatic int hf_usb_vid_probe_clock_freq = -1;\nstatic int hf_usb_vid_probe_framing = -1;\nstatic int hf_usb_vid_probe_framing_D[2] = { -1, -1 };\nstatic int hf_usb_vid_probe_preferred_ver = -1;\nstatic int hf_usb_vid_probe_min_ver = -1;\nstatic int hf_usb_vid_probe_max_ver = -1;\nstatic int hf_usb_vid_frame_interval_type = -1;\nstatic int hf_usb_vid_frame_min_interval = -1;\nstatic int hf_usb_vid_frame_max_interval = -1;\nstatic int hf_usb_vid_frame_step_interval = -1;\nstatic int hf_usb_vid_color_primaries = -1;\nstatic int hf_usb_vid_transfer_characteristics = -1;\nstatic int hf_usb_vid_matrix_coefficients = -1;\nstatic int hf_usb_vid_max_multiplier = -1;\nstatic int hf_usb_vid_iProcessing = -1;\nstatic int hf_usb_vid_iExtension = -1;\nstatic int hf_usb_vid_iSelector = -1;\nstatic int hf_usb_vid_proc_standards = -1;\nstatic int hf_usb_vid_request_error = -1;\nstatic int hf_usb_vid_descriptor_data = -1;\nstatic int hf_usb_vid_control_data = -1;\nstatic int hf_usb_vid_control_value = -1;\nstatic int hf_usb_vid_value_data = -1;\n\n\n/* Subtrees */\nstatic gint ett_usb_vid = -1;\nstatic gint ett_descriptor_video_endpoint = -1;\nstatic gint ett_descriptor_video_control = -1;\nstatic gint ett_descriptor_video_streaming = -1;\nstatic gint ett_camera_controls = -1;\nstatic gint ett_processing_controls = -1;\nstatic gint ett_streaming_controls = -1;\nstatic gint ett_streaming_info = -1;\nstatic gint ett_interlace_flags = -1;\nstatic gint ett_frame_capability_flags = -1;\nstatic gint ett_mjpeg_flags = -1;\nstatic gint ett_video_probe = -1;\nstatic gint ett_probe_hint = -1;\nstatic gint ett_probe_framing = -1;\nstatic gint ett_video_standards = -1;\nstatic gint ett_control_capabilities = -1;\n\nstatic expert_field ei_usb_vid_subtype_unknown = EI_INIT;\nstatic expert_field ei_usb_vid_bitmask_len = EI_INIT;\n\n/* Lookup tables */\nstatic const value_string vc_ep_descriptor_subtypes[] = {\n    { EP_INTERRUPT, \"Interrupt\" },\n    { 0, NULL }\n};\n\nstatic const value_string vid_descriptor_type_vals[] = {\n    {CS_INTERFACE, \"video class interface\"},\n    {CS_ENDPOINT, \"video class endpoint\"},\n    {0,NULL}\n};\nstatic value_string_ext vid_descriptor_type_vals_ext =\n    VALUE_STRING_EXT_INIT(vid_descriptor_type_vals);\n\nstatic const value_string vc_if_descriptor_subtypes[] = {\n    { VC_HEADER,              \"Header\" },\n    { VC_INPUT_TERMINAL,      \"Input Terminal\" },\n    { VC_OUTPUT_TERMINAL,     \"Output Terminal\" },\n    { VC_SELECTOR_UNIT,       \"Selector Unit\" },\n    { VC_PROCESSING_UNIT,     \"Processing Unit\" },\n    { VC_EXTENSION_UNIT,      \"Extension Unit\" },\n    { VC_ENCODING_UNIT,       \"Encoding Unit\" },\n    { 0, NULL }\n};\nstatic value_string_ext vc_if_descriptor_subtypes_ext =\n    VALUE_STRING_EXT_INIT(vc_if_descriptor_subtypes);\n\nstatic const value_string cs_control_interface[] = {\n    { VC_CONTROL_UNDEFINED,          \"Undefined\" },\n    { VC_VIDEO_POWER_MODE_CONTROL,   \"Video Power Mode\" },\n    { VC_REQUEST_ERROR_CODE_CONTROL, \"Request Error Code\" },\n    { VC_REQUEST_INDICATE_HOST_CLOCK_CONTROL, \"Request Indicate Host Clock\" },\n    { 0, NULL }\n};\nstatic value_string_ext cs_control_interface_ext =\n    VALUE_STRING_EXT_INIT(cs_control_interface);\n\nstatic const value_string cs_streaming_interface[] = {\n    { VS_CONTROL_UNDEFINED,            \"Undefined\" },\n    { VS_PROBE_CONTROL,                \"Probe\" },\n    { VS_COMMIT_CONTROL,               \"Commit\" },\n    { VS_STILL_PROBE_CONTROL,          \"Still Probe\" },\n    { VS_STILL_COMMIT_CONTROL,         \"Still Commit\" },\n    { VS_STILL_IMAGE_TRIGGER_CONTROL,  \"Still Image Trigger\" },\n    { VS_STREAM_ERROR_CODE_CONTROL,    \"Stream Error Code\" },\n    { VS_GENERATE_KEY_FRAME_CONTROL,   \"Generate Key Frame\" },\n    { VS_UPDATE_FRAME_SEGMENT_CONTROL, \"Update Frame Segment\" },\n    { VS_SYNCH_DELAY_CONTROL,          \"Synch Delay\" },\n    { 0, NULL }\n};\nstatic value_string_ext cs_streaming_interface_ext =\n    VALUE_STRING_EXT_INIT(cs_streaming_interface);\n\nstatic const value_string cs_selector_unit[] = {\n    { SU_CONTROL_UNDEFINED,              \"Undefined\" },\n    { SU_INPUT_SELECT_CONTROL,           \"Input Select\" },\n    { 0, NULL }\n};\nstatic value_string_ext cs_selector_unit_ext =\n    VALUE_STRING_EXT_INIT(cs_selector_unit);\n\nstatic const value_string cs_camera_terminal[] = {\n    { CT_CONTROL_UNDEFINED,              \"Undefined\" },\n    { CT_SCANNING_MODE_CONTROL,          \"Scanning Mode\" },\n    { CT_AE_MODE_CONTROL,                \"Auto-Exposure Mode\" },\n    { CT_AE_PRIORITY_CONTROL,            \"Auto-Exposure Priority\" },\n    { CT_EXPOSURE_TIME_ABSOLUTE_CONTROL, \"Exposure Time (Absolute)\" },\n    { CT_EXPOSURE_TIME_RELATIVE_CONTROL, \"Exposure Time (Relative)\" },\n    { CT_FOCUS_ABSOLUTE_CONTROL,         \"Focus (Absolute)\" },\n    { CT_FOCUS_RELATIVE_CONTROL,         \"Focus (Relative)\" },\n    { CT_FOCUS_AUTO_CONTROL,             \"Focus, Auto\" },\n    { CT_IRIS_ABSOLUTE_CONTROL,          \"Iris (Absolute)\" },\n    { CT_IRIS_RELATIVE_CONTROL,          \"Iris (Relative)\" },\n    { CT_ZOOM_ABSOLUTE_CONTROL,          \"Zoom (Absolute)\" },\n    { CT_ZOOM_RELATIVE_CONTROL,          \"Zoom (Relative)\" },\n    { CT_PANTILT_ABSOLUTE_CONTROL,       \"PanTilt (Absolute)\" },\n    { CT_PANTILT_RELATIVE_CONTROL,       \"PanTilt (Relative)\" },\n    { CT_ROLL_ABSOLUTE_CONTROL,          \"Roll (Absolute)\" },\n    { CT_ROLL_RELATIVE_CONTROL,          \"Roll (Relative)\" },\n    { CT_PRIVACY_CONTROL,                \"Privacy\" },\n    { CT_FOCUS_SIMPLE_CONTROL,           \"Focus (Simple)\" },\n    { CT_WINDOW_CONTROL,                 \"Window\" },\n    { CT_REGION_OF_INTEREST_CONTROL,     \"Region of Interest\" },\n    { 0, NULL }\n};\nstatic value_string_ext cs_camera_terminal_ext =\n    VALUE_STRING_EXT_INIT(cs_camera_terminal);\n\nstatic const value_string cs_processing_unit[] = {\n    { PU_CONTROL_UNDEFINED,                     \"Undefined\" },\n    { PU_BACKLIGHT_COMPENSATION_CONTROL,        \"Backlight Compensation\" },\n    { PU_BRIGHTNESS_CONTROL,                    \"Brightness\" },\n    { PU_CONTRAST_CONTROL,                      \"Contrast\" },\n    { PU_GAIN_CONTROL,                          \"Gain\" },\n    { PU_POWER_LINE_FREQUENCY_CONTROL,          \"Power Line Frequency\" },\n    { PU_HUE_CONTROL,                           \"Hue\" },\n    { PU_SATURATION_CONTROL,                    \"Saturation\" },\n    { PU_SHARPNESS_CONTROL,                     \"Sharpness\" },\n    { PU_GAMMA_CONTROL,                         \"Gamma\" },\n    { PU_WHITE_BALANCE_TEMPERATURE_CONTROL,     \"White Balance Temperature\" },\n    { PU_WHITE_BALANCE_TEMPERATURE_AUTO_CONTROL,\"White Balance Temperature Auto\" },\n    { PU_WHITE_BALANCE_COMPONENT_CONTROL,       \"White Balance Component\" },\n    { PU_WHITE_BALANCE_COMPONENT_AUTO_CONTROL,  \"White Balance Component Auto\" },\n    { PU_DIGITAL_MULTIPLIER_CONTROL,            \"Digital Multiplier\" },\n    { PU_DIGITAL_MULTIPLIER_LIMIT_CONTROL,      \"Digital Multiplier Limit\" },\n    { PU_HUE_AUTO_CONTROL,                      \"Hue Auto\" },\n    { PU_ANALOG_VIDEO_STANDARD_CONTROL,         \"Video Standard\" },\n    { PU_ANALOG_LOCK_STATUS_CONTROL,            \"Analog Lock Status\" },\n    { PU_CONTRAST_AUTO_CONTROL,                 \"Contrast Auto\" },\n    { 0, NULL }\n};\nstatic value_string_ext cs_processing_unit_ext =\n    VALUE_STRING_EXT_INIT(cs_processing_unit);\n\nstatic const value_string vc_terminal_types[] = {\n    { TT_VENDOR_SPECIFIC,         \"Vendor Specific\", },\n    { TT_STREAMING,               \"Streaming\" },\n    { ITT_VENDOR_SPECIFIC,        \"Vendor Specific Input\" },\n    { ITT_CAMERA,                 \"Camera Input\" },\n    { ITT_MEDIA_TRANSPORT_INPUT,  \"Media Transport Input\" },\n    { OTT_VENDOR_SPECIFIC,        \"Vendor Specific Output\" },\n    { OTT_DISPLAY,                \"Display Output\" },\n    { OTT_MEDIA_TRANSPORT_OUTPUT, \"Media Transport Output\" },\n    { EXTERNAL_VENDOR_SPECIFIC,   \"Vendor Specific External\" },\n    { COMPOSITE_CONNECTOR,        \"Composite Connector\" },\n    { SVIDEO_CONNECTOR,           \"SVideo Connector\" },\n    { COMPONENT_CONNECTOR,        \"Component Connector\" },\n    { 0, NULL }\n};\nstatic value_string_ext vc_terminal_types_ext =\n    VALUE_STRING_EXT_INIT(vc_terminal_types);\n\nstatic const value_string vs_if_descriptor_subtypes[] = {\n    { VS_UNDEFINED,             \"Undefined\" },\n    { VS_INPUT_HEADER,          \"Input Header\" },\n    { VS_OUTPUT_HEADER,         \"Output Header\" },\n    { VS_STILL_IMAGE_FRAME,     \"Still Image Frame\" },\n    { VS_FORMAT_UNCOMPRESSED,   \"Format Uncompressed\" },\n    { VS_FRAME_UNCOMPRESSED,    \"Frame Uncompressed\" },\n    { VS_FORMAT_MJPEG,          \"Format MJPEG\" },\n    { VS_FRAME_MJPEG,           \"Frame MJPEG\" },\n    { VS_FORMAT_MPEG1,          \"Format MPEG1\" },\n    { VS_FORMAT_MPEG2PS,        \"Format MPEG2-PS\" },\n    { VS_FORMAT_MPEG2TS,        \"Format MPEG2-TS\" },\n    { VS_FORMAT_MPEG4SL,        \"Format MPEG4-SL\" },\n    { VS_FORMAT_DV,             \"Format DV\" },\n    { VS_COLORFORMAT,           \"Colorformat\" },\n    { VS_FORMAT_VENDOR,         \"Format Vendor\" },\n    { VS_FRAME_VENDOR,          \"Frame Vendor\" },\n    { VS_FORMAT_FRAME_BASED,    \"Format Frame-Based\" },\n    { VS_FRAME_FRAME_BASED,     \"Frame Frame-Based\" },\n    { VS_FORMAT_STREAM_BASED,   \"Format Stream Based\" },\n    { VS_FORMAT_H264,           \"Format H.264\" },\n    { VS_FRAME_H264,            \"Frame H.264\" },\n    { VS_FORMAT_H264_SIMULCAST, \"Format H.264 Simulcast\" },\n    { VS_FORMAT_VP8,            \"Format VP8\" },\n    { VS_FRAME_VP8,             \"Frame VP8\" },\n    { VS_FORMAT_VP8_SIMULCAST,  \"Format VP8 Simulcast\" },\n    { 0, NULL }\n};\nstatic value_string_ext vs_if_descriptor_subtypes_ext =\n    VALUE_STRING_EXT_INIT(vs_if_descriptor_subtypes);\n\nstatic const value_string interrupt_status_types[] = {\n    { INT_VIDEOCONTROL,       \"VideoControl Interface\"   },\n    { INT_VIDEOSTREAMING,     \"VideoStreaming Interface\" },\n    { 0, NULL }\n};\n\nstatic const value_string control_change_types[] = {\n    { CONTROL_CHANGE_VALUE,   \"Value\" },\n    { CONTROL_CHANGE_INFO,    \"Info\" },\n    { CONTROL_CHANGE_FAILURE, \"Failure\" },\n    { CONTROL_CHANGE_MIN,     \"Min\" },\n    { CONTROL_CHANGE_MAX,     \"Max\" },\n    { 0, NULL }\n};\nstatic value_string_ext control_change_types_ext =\n    VALUE_STRING_EXT_INIT(control_change_types);\n\nstatic const value_string control_interrupt_events[] = {\n    { CONTROL_INTERRUPT_EVENT_CONTROL_CHANGE,  \"Control Change\" },\n    { 0, NULL }\n};\n\n/* Table 3-13 VS Interface Input Header Descriptor - bStillCaptureMethod field */\nstatic const value_string vs_still_capture_methods[] = {\n    { 0,  \"None\" },\n    { 1,  \"Uninterrupted streaming\" },\n    { 2,  \"Suspended streaming\" },\n    { 3,  \"Dedicated pipe\" },\n    { 0, NULL }\n};\nstatic value_string_ext vs_still_capture_methods_ext =\n    VALUE_STRING_EXT_INIT(vs_still_capture_methods);\n\n/* Table 3-13 VS Interface Input Header Descriptor - bTriggerUsage field */\nstatic const value_string vs_trigger_usage[] = {\n    { 0,  \"Initiate still image capture\" },\n    { 1,  \"General purpose button event\" },\n    { 0, NULL }\n};\n\n/* bmInterlaceFlags for format descriptors */\nstatic const true_false_string is_interlaced_meaning = {\n    \"Interlaced\",\n    \"Non-interlaced\"\n};\n\n/* bmInterlaceFlags for format descriptors */\nstatic const true_false_string interlaced_fields_meaning = {\n    \"1 field\",\n    \"2 fields\"\n};\n\n/* bmInterlaceFlags for format descriptors */\nstatic const value_string field_pattern_meaning[] = {\n    { 0,  \"Field 1 only\" },\n    { 1,  \"Field 2 only\" },\n    { 2,  \"Regular pattern of fields 1 and 2\" },\n    { 3,  \"Random pattern of fields 1 and 2\" },\n    {0, NULL},\n};\nstatic value_string_ext field_pattern_meaning_ext =\n    VALUE_STRING_EXT_INIT(field_pattern_meaning);\n\n/* bCopyProtect for format descriptors */\nstatic const value_string copy_protect_meaning[] = {\n    { 0,  \"No restrictions\" },\n    { 1,  \"Restrict duplication\" },\n    {0, NULL},\n};\n\n/* Table 4-46 Video Probe and Commit Controls - bmHint field */\nstatic const true_false_string probe_hint_meaning = {\n    \"Constant\",\n    \"Variable\"\n};\n\n/* Table 3-19 Color Matching Descriptor - bColorPrimaries field */\nstatic const value_string color_primaries_meaning[] = {\n    { 0,  \"Unspecified\" },\n    { 1,  \"BT.709, sRGB\" },\n    { 2,  \"BT.470-2 (M)\" },\n    { 3,  \"BT.470-2 (B,G)\" },\n    { 4,  \"SMPTE 170M\" },\n    { 5,  \"SMPTE 240M\" },\n    {0, NULL},\n};\nstatic value_string_ext color_primaries_meaning_ext =\n    VALUE_STRING_EXT_INIT(color_primaries_meaning);\n\n/* Table 3-19 Color Matching Descriptor - bTransferCharacteristics field */\nstatic const value_string color_transfer_characteristics[] = {\n    { 0,  \"Unspecified\" },\n    { 1,  \"BT.709\" },\n    { 2,  \"BT.470-2 (M)\" },\n    { 3,  \"BT.470-2 (B,G)\" },\n    { 4,  \"SMPTE 170M\" },\n    { 5,  \"SMPTE 240M\" },\n    { 6,  \"Linear (V=Lc)\" },\n    { 7,  \"sRGB\" },\n    {0, NULL},\n};\nstatic value_string_ext color_transfer_characteristics_ext =\n    VALUE_STRING_EXT_INIT(color_transfer_characteristics);\n\n/* Table 3-19 Color Matching Descriptor - bMatrixCoefficients field */\nstatic const value_string matrix_coefficients_meaning[] = {\n    { 0,  \"Unspecified\" },\n    { 1,  \"BT.709\" },\n    { 2,  \"FCC\" },\n    { 3,  \"BT.470-2 (B,G)\" },\n    { 4,  \"SMPTE 170M (BT.601)\" },\n    { 5,  \"SMPTE 240M\" },\n    {0, NULL},\n};\nstatic value_string_ext matrix_coefficients_meaning_ext =\n    VALUE_STRING_EXT_INIT(matrix_coefficients_meaning);\n\nstatic const value_string request_error_codes[] = {\n    { UVC_ERROR_NONE,             \"No error\" },\n    { UVC_ERROR_NOT_READY,        \"Not ready\" },\n    { UVC_ERROR_WRONG_STATE,      \"Wrong state\" },\n    { UVC_ERROR_POWER,            \"Insufficient power\" } ,\n    { UVC_ERROR_OUT_OF_RANGE,     \"Out of range\" },\n    { UVC_ERROR_INVALID_UNIT,     \"Invalid unit\" },\n    { UVC_ERROR_INVALID_CONTROL,  \"Invalid control\" },\n    { UVC_ERROR_INVALID_REQUEST,  \"Invalid request\" },\n    { UVC_ERROR_INVALID_VALUE,    \"Invalid value within range\" },\n    { UVC_ERROR_UNKNOWN,          \"Unknown\" },\n    {0, NULL},\n};\nstatic value_string_ext request_error_codes_ext =\n    VALUE_STRING_EXT_INIT(request_error_codes);\n\n/* There is one such structure per terminal or unit per interface */\ntypedef struct\n{\n    guint8  entityID;\n    guint8  subtype;\n    guint16 terminalType;\n} video_entity_t;\n\n/* video_entity_t's (units/terminals) associated with each video interface */\n/* There is one such structure for each video conversation (interface) */\ntypedef struct _video_conv_info_t {\n    wmem_tree_t* entities;      /* indexed by entity ID */\n} video_conv_info_t;\n\n/*****************************************************************************/\n/*                            UTILITY FUNCTIONS                              */\n/*****************************************************************************/\n\n/**\n * Dissector for variable-length bmControl bitmask / bControlSize pair.\n *\n * Creates an item for bControlSize, and a subtree for the bmControl bitmask.\n *\n * @param tree            protocol tree to be the parent of the bitmask subtree\n * @param tvb             the tv_buff with the (remaining) packet data\n * @param offset          where in tvb to find bControlSize field\n * @param ett_subtree     index of the subtree to use for this bitmask\n * @param bm_items        NULL-terminated array of pointers that lists all the fields\n *                        of the bitmask\n *\n * @return   offset within tvb at which dissection should continue\n */\nstatic int\ndissect_bmControl(proto_tree *tree, tvbuff_t *tvb, int offset,\n                  gint ett_subtree, const int** bm_items)\n{\n    guint8 bm_size = 0;\n\n    bm_size = tvb_get_guint8(tvb, offset);\n    proto_tree_add_item(tree, hf_usb_vid_bControlSize, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    ++offset;\n\n    if (bm_size > 0)\n    {\n        proto_tree_add_bitmask_len(tree, tvb, offset, bm_size, hf_usb_vid_bmControl,\n                                   ett_subtree, bm_items, &ei_usb_vid_bitmask_len, ENC_LITTLE_ENDIAN);\n        offset += bm_size;\n    }\n\n    return offset;\n}\n\n/*****************************************************************************/\n/*                          VIDEO CONTROL DESCRIPTORS                        */\n/*****************************************************************************/\n\n/* Dissect a Camera Terminal descriptor */\nstatic int\ndissect_usb_video_camera_terminal(proto_tree *tree, tvbuff_t *tvb, int offset)\n{\n    static const int *control_bits[] = {\n        &hf_usb_vid_cam_control_D[0],\n        &hf_usb_vid_cam_control_D[1],\n        &hf_usb_vid_cam_control_D[2],\n        &hf_usb_vid_cam_control_D[3],\n        &hf_usb_vid_cam_control_D[4],\n        &hf_usb_vid_cam_control_D[5],\n        &hf_usb_vid_cam_control_D[6],\n        &hf_usb_vid_cam_control_D[7],\n        &hf_usb_vid_cam_control_D[8],\n        &hf_usb_vid_cam_control_D[9],\n        &hf_usb_vid_cam_control_D[10],\n        &hf_usb_vid_cam_control_D[11],\n        &hf_usb_vid_cam_control_D[12],\n        &hf_usb_vid_cam_control_D[13],\n        &hf_usb_vid_cam_control_D[14],\n        &hf_usb_vid_cam_control_D[15],\n        &hf_usb_vid_cam_control_D[16],\n        &hf_usb_vid_cam_control_D[17],\n        &hf_usb_vid_cam_control_D[18],\n        &hf_usb_vid_cam_control_D[19],\n        &hf_usb_vid_cam_control_D[20],\n        &hf_usb_vid_cam_control_D[21],\n        NULL\n    };\n\n    DISSECTOR_ASSERT(array_length(control_bits) == (1+array_length(hf_usb_vid_cam_control_D)));\n\n    proto_tree_add_item(tree, hf_usb_vid_cam_objective_focal_len_min,  tvb, offset, 2, ENC_LITTLE_ENDIAN);\n    offset += 2;\n    proto_tree_add_item(tree, hf_usb_vid_cam_objective_focal_len_max,  tvb, offset, 2, ENC_LITTLE_ENDIAN);\n    offset += 2;\n    proto_tree_add_item(tree, hf_usb_vid_cam_ocular_focal_len, tvb, offset, 2, ENC_LITTLE_ENDIAN);\n    offset += 2;\n\n    offset = dissect_bmControl(tree, tvb, offset, ett_camera_controls, control_bits);\n\n    return offset;\n}\n\n/* Dissect a Processing Unit descriptor */\nstatic int\ndissect_usb_video_processing_unit(proto_tree *tree, tvbuff_t *tvb, int offset)\n{\n    static const int *control_bits[] = {\n        &hf_usb_vid_proc_control_D[0],\n        &hf_usb_vid_proc_control_D[1],\n        &hf_usb_vid_proc_control_D[2],\n        &hf_usb_vid_proc_control_D[3],\n        &hf_usb_vid_proc_control_D[4],\n        &hf_usb_vid_proc_control_D[5],\n        &hf_usb_vid_proc_control_D[6],\n        &hf_usb_vid_proc_control_D[7],\n        &hf_usb_vid_proc_control_D[8],\n        &hf_usb_vid_proc_control_D[9],\n        &hf_usb_vid_proc_control_D[10],\n        &hf_usb_vid_proc_control_D[11],\n        &hf_usb_vid_proc_control_D[12],\n        &hf_usb_vid_proc_control_D[13],\n        &hf_usb_vid_proc_control_D[14],\n        &hf_usb_vid_proc_control_D[15],\n        &hf_usb_vid_proc_control_D[16],\n        &hf_usb_vid_proc_control_D[17],\n        &hf_usb_vid_proc_control_D[18],\n        NULL\n    };\n\n    DISSECTOR_ASSERT(array_length(control_bits) == (1+array_length(hf_usb_vid_proc_control_D)));\n\n    proto_tree_add_item(tree, hf_usb_vid_control_ifdesc_src_id, tvb, offset,   1, ENC_LITTLE_ENDIAN);\n    proto_tree_add_item(tree, hf_usb_vid_max_multiplier,        tvb, offset+1, 2, ENC_LITTLE_ENDIAN);\n    offset += 3;\n\n    offset = dissect_bmControl(tree, tvb, offset, ett_processing_controls, control_bits);\n\n    proto_tree_add_item(tree, hf_usb_vid_iProcessing, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    ++offset;\n\n    /* UVC 1.1 added bmVideoStandards */\n    if (tvb_reported_length_remaining(tvb, offset) > 0)\n    {\n        static const int *standard_bits[] = {\n            &hf_usb_vid_proc_standards_D[0],\n            &hf_usb_vid_proc_standards_D[1],\n            &hf_usb_vid_proc_standards_D[2],\n            &hf_usb_vid_proc_standards_D[3],\n            &hf_usb_vid_proc_standards_D[4],\n            &hf_usb_vid_proc_standards_D[5],\n            NULL\n        };\n\n        DISSECTOR_ASSERT(array_length(standard_bits) == (1+array_length(hf_usb_vid_proc_standards_D)));\n\n        proto_tree_add_bitmask(tree, tvb, offset, hf_usb_vid_proc_standards,\n                               ett_video_standards, standard_bits, ENC_NA);\n        ++offset;\n    }\n\n    return offset;\n}\n\n/* Dissect a Selector Unit descriptor */\nstatic int\ndissect_usb_video_selector_unit(proto_tree *tree, tvbuff_t *tvb, int offset)\n{\n    guint8 num_inputs;\n\n    num_inputs = tvb_get_guint8(tvb, offset);\n    proto_tree_add_item(tree, hf_usb_vid_num_inputs, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    ++offset;\n\n    if (num_inputs > 0)\n    {\n        proto_tree_add_item(tree, hf_usb_vid_sources, tvb, offset, num_inputs, ENC_NA);\n        offset += num_inputs;\n    }\n\n    proto_tree_add_item(tree, hf_usb_vid_iSelector, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    ++offset;\n\n    return offset;\n}\n\n/* Dissect an Extension Unit descriptor */\nstatic int\ndissect_usb_video_extension_unit(proto_tree *tree, tvbuff_t *tvb, int offset)\n{\n    guint8 num_inputs;\n    guint8 control_size;\n\n    proto_tree_add_item(tree, hf_usb_vid_exten_guid,         tvb, offset,    16, ENC_LITTLE_ENDIAN);\n    proto_tree_add_item(tree, hf_usb_vid_exten_num_controls, tvb, offset+16,  1, ENC_LITTLE_ENDIAN);\n    offset += 17;\n\n    num_inputs = tvb_get_guint8(tvb, offset);\n    proto_tree_add_item(tree, hf_usb_vid_num_inputs,   tvb, offset,  1, ENC_LITTLE_ENDIAN);\n    ++offset;\n\n    if (num_inputs > 0)\n    {\n        proto_tree_add_item(tree, hf_usb_vid_sources, tvb, offset, num_inputs, ENC_NA);\n        offset += num_inputs;\n    }\n\n    control_size = tvb_get_guint8(tvb, offset);\n    proto_tree_add_item(tree, hf_usb_vid_bControlSize, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    ++offset;\n\n    if (control_size > 0)\n    {\n        if (control_size <= proto_registrar_get_length(hf_usb_vid_bmControl))\n        {\n            proto_tree_add_item(tree, hf_usb_vid_bmControl, tvb, offset, control_size,\n                                ENC_LITTLE_ENDIAN);\n        }\n        else\n        {\n            /* Too big to display as integer */\n            /* @todo Display as FT_BYTES with a big-endian disclaimer?\n             * See https://bugs.wireshark.org/bugzilla/show_bug.cgi?id=7933\n             */\n            proto_tree_add_bytes_format(tree, hf_usb_vid_bmControl_bytes, tvb, offset, control_size, NULL, \"bmControl\");\n        }\n        offset += control_size;\n    }\n\n    proto_tree_add_item(tree, hf_usb_vid_iExtension, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    ++offset;\n\n    return offset;\n}\n\n/**\n * Dissector for video class control interface descriptors\n *\n * @param parent_tree     the protocol tree to be the parent of the descriptor subtree\n * @param tvb             the tv_buff with the (remaining) packet data\n *                        On entry the gaze is set to the descriptor length field.\n * @param descriptor_len  Length of the descriptor to dissect\n * @param pinfo           Information associated with the packet being dissected\n *\n * @return   offset within tvb at which dissection should continue\n */\nstatic int\ndissect_usb_video_control_interface_descriptor(proto_tree *parent_tree, tvbuff_t *tvb,\n                                               guint8 descriptor_len, packet_info *pinfo, usb_conv_info_t *usb_conv_info)\n{\n    video_conv_info_t *video_conv_info = NULL;\n    video_entity_t    *entity          = NULL;\n    proto_item *item          = NULL;\n    proto_item *subtype_item  = NULL;\n    proto_tree *tree          = NULL;\n    guint8      entity_id     = 0;\n    guint16     terminal_type = 0;\n    int         offset        = 0;\n    guint8      subtype;\n\n    subtype = tvb_get_guint8(tvb, offset+2);\n\n    if (parent_tree)\n    {\n        const gchar *subtype_str;\n\n        subtype_str = val_to_str_ext(subtype, &vc_if_descriptor_subtypes_ext, \"Unknown (0x%x)\");\n\n        tree = proto_tree_add_subtree_format(parent_tree, tvb, offset, descriptor_len,\n                                   ett_descriptor_video_control, &item, \"VIDEO CONTROL INTERFACE DESCRIPTOR [%s]\",\n                                   subtype_str);\n    }\n\n    /* Common fields */\n    dissect_usb_descriptor_header(tree, tvb, offset, &vid_descriptor_type_vals_ext);\n    subtype_item = proto_tree_add_item(tree, hf_usb_vid_control_ifdesc_subtype, tvb, offset+2, 1, ENC_LITTLE_ENDIAN);\n    offset += 3;\n\n    if (subtype == VC_HEADER)\n    {\n        guint8 num_vs_interfaces;\n\n        proto_tree_add_item(tree, hf_usb_vid_control_ifdesc_bcdUVC,            tvb, offset,   2, ENC_LITTLE_ENDIAN);\n        proto_tree_add_item(tree, hf_usb_vid_ifdesc_wTotalLength,              tvb, offset+2, 2, ENC_LITTLE_ENDIAN);\n        proto_tree_add_item(tree, hf_usb_vid_control_ifdesc_dwClockFrequency,  tvb, offset+4, 4, ENC_LITTLE_ENDIAN);\n\n        num_vs_interfaces = tvb_get_guint8(tvb, offset+8);\n        proto_tree_add_item(tree, hf_usb_vid_control_ifdesc_bInCollection,     tvb, offset+8, 1, ENC_LITTLE_ENDIAN);\n\n        if (num_vs_interfaces > 0)\n        {\n            proto_tree_add_item(tree, hf_usb_vid_control_ifdesc_baInterfaceNr, tvb, offset+9, num_vs_interfaces, ENC_NA);\n        }\n\n        offset += 9 + num_vs_interfaces;\n    }\n    else if ((subtype == VC_INPUT_TERMINAL) || (subtype == VC_OUTPUT_TERMINAL))\n    {\n        /* Fields common to input and output terminals */\n        entity_id     = tvb_get_guint8(tvb, offset);\n        terminal_type = tvb_get_letohs(tvb, offset+1);\n\n        proto_tree_add_item(tree, hf_usb_vid_control_ifdesc_terminal_id,    tvb, offset,   1, ENC_LITTLE_ENDIAN);\n        proto_tree_add_item(tree, hf_usb_vid_control_ifdesc_terminal_type,  tvb, offset+1, 2, ENC_LITTLE_ENDIAN);\n        proto_tree_add_item(tree, hf_usb_vid_control_ifdesc_assoc_terminal, tvb, offset+3, 1, ENC_LITTLE_ENDIAN);\n        offset += 4;\n\n        if (subtype == VC_OUTPUT_TERMINAL)\n        {\n            proto_tree_add_item(tree, hf_usb_vid_control_ifdesc_src_id, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n            ++offset;\n        }\n\n        proto_tree_add_item(tree, hf_usb_vid_control_ifdesc_iTerminal, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n        ++offset;\n\n        if (subtype == VC_INPUT_TERMINAL)\n        {\n            if (terminal_type == ITT_CAMERA)\n            {\n                offset = dissect_usb_video_camera_terminal(tree, tvb, offset);\n            }\n            else if (terminal_type == ITT_MEDIA_TRANSPORT_INPUT)\n            {\n                /* @todo */\n            }\n        }\n\n        if (subtype == VC_OUTPUT_TERMINAL)\n        {\n            if (terminal_type == OTT_MEDIA_TRANSPORT_OUTPUT)\n            {\n                /* @todo */\n            }\n        }\n    }\n    else\n    {\n        /* Field common to extension / processing / selector / encoding units */\n        entity_id = tvb_get_guint8(tvb, offset);\n        proto_tree_add_item(tree, hf_usb_vid_control_ifdesc_unit_id, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n        ++offset;\n\n        if (subtype == VC_PROCESSING_UNIT)\n        {\n            offset = dissect_usb_video_processing_unit(tree, tvb, offset);\n        }\n        else if (subtype == VC_SELECTOR_UNIT)\n        {\n            offset = dissect_usb_video_selector_unit(tree, tvb, offset);\n        }\n        else if (subtype == VC_EXTENSION_UNIT)\n        {\n            offset = dissect_usb_video_extension_unit(tree, tvb, offset);\n        }\n        else if (subtype == VC_ENCODING_UNIT)\n        {\n            /* @todo UVC 1.5 */\n        }\n        else\n        {\n            expert_add_info_format(pinfo, subtype_item, &ei_usb_vid_subtype_unknown,\n                                   \"Unknown VC subtype %u\", subtype);\n        }\n    }\n\n    /* Soak up descriptor bytes beyond those we know how to dissect */\n    if (offset < descriptor_len)\n    {\n        proto_tree_add_item(tree, hf_usb_vid_descriptor_data, tvb, offset, descriptor_len-offset, ENC_NA);\n        /* offset = descriptor_len; */\n    }\n\n    if (entity_id != 0)\n        proto_item_append_text(item, \" (Entity %d)\", entity_id);\n\n    if (subtype != VC_HEADER && usb_conv_info)\n    {\n        /* Switch to the usb_conv_info of the Video Control interface */\n        usb_conv_info = get_usb_iface_conv_info(pinfo, usb_conv_info->interfaceNum);\n        video_conv_info = (video_conv_info_t *)usb_conv_info->class_data;\n\n        if (!video_conv_info)\n        {\n            video_conv_info = wmem_new(wmem_file_scope(), video_conv_info_t);\n            video_conv_info->entities = wmem_tree_new(wmem_file_scope());\n            usb_conv_info->class_data = video_conv_info;\n            usb_conv_info->class_data_type = USB_CONV_VIDEO;\n        } else if (usb_conv_info->class_data_type != USB_CONV_VIDEO) {\n            /* Stop dissection if another USB type is in the conversation */\n            return descriptor_len;\n        }\n\n        entity = (video_entity_t*) wmem_tree_lookup32(video_conv_info->entities, entity_id);\n        if (!entity)\n        {\n            entity = wmem_new(wmem_file_scope(), video_entity_t);\n            entity->entityID     = entity_id;\n            entity->subtype      = subtype;\n            entity->terminalType = terminal_type;\n\n            wmem_tree_insert32(video_conv_info->entities, entity_id, entity);\n        }\n    }\n\n    return descriptor_len;\n}\n\n/*****************************************************************************/\n/*                        VIDEO STREAMING DESCRIPTORS                        */\n/*****************************************************************************/\n\n/* Dissect a Video Streaming Input Header descriptor */\nstatic int\ndissect_usb_video_streaming_input_header(proto_tree *tree, tvbuff_t *tvb, int offset)\n{\n    guint8 num_formats;\n    guint8 bm_size;\n\n    static const int *info_bits[] = {\n        &hf_usb_vid_streaming_info_D[0],\n        NULL\n    };\n    static const int *control_bits[] = {\n        &hf_usb_vid_streaming_control_D[0],\n        &hf_usb_vid_streaming_control_D[1],\n        &hf_usb_vid_streaming_control_D[2],\n        &hf_usb_vid_streaming_control_D[3],\n        &hf_usb_vid_streaming_control_D[4],\n        &hf_usb_vid_streaming_control_D[5],\n        NULL\n    };\n\n    DISSECTOR_ASSERT(array_length(control_bits) == (1+array_length(hf_usb_vid_streaming_control_D)));\n\n    num_formats = tvb_get_guint8(tvb, offset);\n    proto_tree_add_item(tree, hf_usb_vid_streaming_ifdesc_bNumFormats, tvb, offset,   1, ENC_LITTLE_ENDIAN);\n    proto_tree_add_item(tree, hf_usb_vid_ifdesc_wTotalLength,          tvb, offset+1, 2, ENC_LITTLE_ENDIAN);\n    offset += 3;\n\n    dissect_usb_endpoint_address(tree, tvb, offset);\n    offset++;\n\n    proto_tree_add_bitmask(tree, tvb, offset, hf_usb_vid_streaming_bmInfo,\n                           ett_streaming_info, info_bits, ENC_NA);\n\n    proto_tree_add_item(tree, hf_usb_vid_streaming_terminal_link,        tvb, offset+1, 1, ENC_LITTLE_ENDIAN);\n    proto_tree_add_item(tree, hf_usb_vid_streaming_still_capture_method, tvb, offset+2, 1, ENC_LITTLE_ENDIAN);\n    offset += 3;\n\n    proto_tree_add_item(tree, hf_usb_vid_streaming_trigger_support,      tvb, offset,   1, ENC_NA);\n    if (tvb_get_guint8(tvb, offset) > 0)\n    {\n        proto_tree_add_item(tree, hf_usb_vid_streaming_trigger_usage,    tvb, offset+1, 1, ENC_LITTLE_ENDIAN);\n    }\n    else\n    {\n        proto_tree_add_uint_format_value(tree, hf_usb_vid_streaming_trigger_usage, tvb, offset+1, 1, 0, \"Not applicable\");\n    }\n\n    offset += 2;\n\n    /* NOTE: Can't use dissect_bmControl here because there's only one size\n     *       field for (potentially) multiple bmControl fields\n     */\n    bm_size = tvb_get_guint8(tvb, offset);\n    proto_tree_add_item(tree, hf_usb_vid_bControlSize, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    ++offset;\n\n    if (bm_size > 0)\n    {\n        guint8 i;\n        for (i=0; i<num_formats; ++i)\n        {\n            proto_tree_add_bitmask_len(tree, tvb, offset, bm_size, hf_usb_vid_bmControl,\n                                       ett_streaming_controls, control_bits, &ei_usb_vid_bitmask_len,\n                                       ENC_LITTLE_ENDIAN);\n            offset += bm_size;\n        }\n    }\n\n    return offset;\n}\n\n/**\n * Dissect a known Video Payload Format descriptor.\n *\n * @param tree     protocol tree to which fields should be added\n * @param tvb      the tv_buff with the (remaining) packet data\n * @param offset   where in tvb to begin dissection.\n *                 On entry this refers to the bFormatIndex field.\n * @param subtype  Type of format descriptor, from the\n *                 bDescriptorSubtype field\n *\n * @return   offset within tvb at which dissection should continue\n */\nstatic int\ndissect_usb_video_format(proto_tree *tree, tvbuff_t *tvb, int offset,\n                         guint8 subtype)\n{\n    static const int *interlace_bits[] = {\n        &hf_usb_vid_is_interlaced,\n        &hf_usb_vid_interlaced_fields,\n        &hf_usb_vid_field_1_first,\n        &hf_usb_vid_field_pattern,\n        NULL\n    };\n\n    proto_item *desc_item;\n    guint8 format_index;\n\n    /* Augment the descriptor root item with the index of this descriptor */\n    format_index = tvb_get_guint8(tvb, offset);\n    desc_item = proto_tree_get_parent(tree);\n    proto_item_append_text(desc_item, \"  (Format %u)\", format_index);\n\n    proto_tree_add_item(tree, hf_usb_vid_format_index,                  tvb, offset,    1, ENC_LITTLE_ENDIAN);\n    proto_tree_add_item(tree, hf_usb_vid_format_num_frame_descriptors,  tvb, offset+1,  1, ENC_LITTLE_ENDIAN);\n    offset += 2;\n\n    if ((subtype == VS_FORMAT_UNCOMPRESSED) || (subtype == VS_FORMAT_FRAME_BASED))\n    {\n        /* Augment the descriptor root item with the format's four-character-code */\n        char fourcc[5];\n        tvb_memcpy(tvb, (guint8 *)fourcc, offset, 4);\n        fourcc[4] = '\\0';\n        proto_item_append_text(desc_item, \": %s\", fourcc);\n\n        proto_tree_add_item(tree, hf_usb_vid_format_guid, tvb, offset,   16, ENC_LITTLE_ENDIAN);\n        proto_tree_add_item(tree, hf_usb_vid_format_bits_per_pixel,        tvb, offset+16, 1, ENC_LITTLE_ENDIAN);\n        offset += 17;\n    }\n    else if (subtype == VS_FORMAT_MJPEG)\n    {\n        static const int * flags[] = {\n            &hf_usb_vid_mjpeg_fixed_samples,\n            NULL\n        };\n\n        proto_tree_add_bitmask(tree, tvb, offset, hf_usb_vid_mjpeg_flags, ett_mjpeg_flags, flags, ENC_NA);\n        offset++;\n    }\n    else\n    {\n        /* We should only be called for known format descriptor subtypes */\n        DISSECTOR_ASSERT_NOT_REACHED();\n    }\n\n    proto_tree_add_item(tree, hf_usb_vid_default_frame_index, tvb, offset,   1, ENC_LITTLE_ENDIAN);\n    proto_tree_add_item(tree, hf_usb_vid_aspect_ratio_x,      tvb, offset+1, 1, ENC_LITTLE_ENDIAN);\n    proto_tree_add_item(tree, hf_usb_vid_aspect_ratio_y,      tvb, offset+2, 1, ENC_LITTLE_ENDIAN);\n    offset += 3;\n\n#if 0\n    /* @todo Display \"N/A\" if Camera Terminal does not support scanning mode control */\n    if (something)\n        proto_tree_add_uint_format_value(tree, hf_usb_vid_interlace_flags, tvb, offset, 1, tvb_get_guint8(tvb, offset), \"Not applicable\");\n#endif\n\n    proto_tree_add_bitmask(tree, tvb, offset, hf_usb_vid_interlace_flags,\n                                ett_interlace_flags, interlace_bits, ENC_NA);\n    offset++;\n\n    proto_tree_add_item(tree, hf_usb_vid_copy_protect, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    offset++;\n\n    if (subtype == VS_FORMAT_FRAME_BASED)\n    {\n        proto_tree_add_item(tree, hf_usb_vid_variable_size, tvb, offset, 1, ENC_NA);\n        offset++;\n    }\n\n    return offset;\n}\n\n/**\n * Dissect a known Video Frame descriptor.\n *\n * @param tree     protocol tree to which fields should be added\n * @param tvb      the tv_buff with the (remaining) packet data\n * @param offset   where in tvb to begin dissection.\n *                 On entry this refers to the bFrameIndex field.\n * @param subtype  Type of frame descriptor, from the\n *                 bDescriptorSubtype field\n *\n * @return   offset within tvb at which dissection should continue\n */\nstatic int\ndissect_usb_video_frame(proto_tree *tree, tvbuff_t *tvb, int offset,\n                        guint8 subtype)\n{\n    static const int *capability_bits[] = {\n        &hf_usb_vid_frame_stills_supported,\n        &hf_usb_vid_frame_fixed_frame_rate,\n        NULL\n    };\n    proto_item *desc_item;\n    guint8      bFrameIntervalType;\n    guint8      frame_index;\n    guint16     frame_width;\n    guint16     frame_height;\n\n    frame_index = tvb_get_guint8(tvb, offset);\n    proto_tree_add_item(tree, hf_usb_vid_frame_index, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    offset++;\n\n    proto_tree_add_bitmask(tree, tvb, offset, hf_usb_vid_frame_capabilities,\n                           ett_frame_capability_flags, capability_bits, ENC_NA);\n    offset++;\n\n    proto_tree_add_item(tree, hf_usb_vid_frame_width,        tvb, offset,    2, ENC_LITTLE_ENDIAN);\n    proto_tree_add_item(tree, hf_usb_vid_frame_height,       tvb, offset+2,  2, ENC_LITTLE_ENDIAN);\n\n    /* Augment the descriptor root item with useful information */\n    frame_width = tvb_get_letohs(tvb, offset);\n    frame_height = tvb_get_letohs(tvb, offset+2);\n    desc_item = proto_tree_get_parent(tree);\n    proto_item_append_text(desc_item, \"   (Index %2u): %4u x %4u\", frame_index, frame_width, frame_height);\n\n    proto_tree_add_item(tree, hf_usb_vid_frame_min_bit_rate, tvb, offset+4,  4, ENC_LITTLE_ENDIAN);\n    proto_tree_add_item(tree, hf_usb_vid_frame_max_bit_rate, tvb, offset+8,  4, ENC_LITTLE_ENDIAN);\n    offset += 12;\n\n    if (subtype != VS_FRAME_FRAME_BASED)\n    {\n        proto_tree_add_item(tree, hf_usb_vid_frame_max_frame_sz, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n        offset += 4;\n    }\n\n    proto_tree_add_item(tree, hf_usb_vid_frame_default_interval, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n    offset += 4;\n\n    bFrameIntervalType = tvb_get_guint8(tvb, offset);\n    if (bFrameIntervalType == 0)\n    {\n        proto_tree_add_uint_format_value(tree, hf_usb_vid_frame_interval_type, tvb, offset, 1,\n                                         bFrameIntervalType, \"Continuous (0)\");\n        offset++;\n\n        if (subtype == VS_FRAME_FRAME_BASED)\n        {\n            proto_tree_add_item(tree, hf_usb_vid_frame_bytes_per_line, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n            offset += 4;\n        }\n\n        proto_tree_add_item(tree, hf_usb_vid_frame_min_interval,  tvb, offset,   4, ENC_LITTLE_ENDIAN);\n        proto_tree_add_item(tree, hf_usb_vid_frame_max_interval,  tvb, offset+4, 4, ENC_LITTLE_ENDIAN);\n        proto_tree_add_item(tree, hf_usb_vid_frame_step_interval, tvb, offset+8, 4, ENC_LITTLE_ENDIAN);\n        offset += 12;\n    }\n    else\n    {\n        guint8 i;\n        proto_tree_add_uint_format_value(tree, hf_usb_vid_frame_interval_type, tvb, offset, 1,\n                                         bFrameIntervalType, \"Discrete (%u choice%s)\",\n                                         bFrameIntervalType, (bFrameIntervalType > 1) ? \"s\" : \"\");\n        offset++;\n\n        if (subtype == VS_FRAME_FRAME_BASED)\n        {\n            proto_tree_add_item(tree, hf_usb_vid_frame_bytes_per_line, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n            offset += 4;\n        }\n\n        for (i=0; i<bFrameIntervalType; ++i)\n        {\n            proto_tree_add_item(tree, hf_usb_vid_frame_interval,  tvb, offset, 4, ENC_LITTLE_ENDIAN);\n            offset += 4;\n        }\n    }\n\n    return offset;\n}\n\n/* Dissect a Color Matching descriptor */\nstatic int\ndissect_usb_video_colorformat(proto_tree *tree, tvbuff_t *tvb, int offset)\n{\n    proto_tree_add_item(tree, hf_usb_vid_color_primaries,          tvb, offset,   1, ENC_LITTLE_ENDIAN);\n    proto_tree_add_item(tree, hf_usb_vid_transfer_characteristics, tvb, offset+1, 1, ENC_LITTLE_ENDIAN);\n    proto_tree_add_item(tree, hf_usb_vid_matrix_coefficients,      tvb, offset+2, 1, ENC_LITTLE_ENDIAN);\n    offset +=3;\n\n    return offset;\n}\n\n/**\n * Dissector for video class streaming interface descriptors.\n *\n * @param parent_tree     the protocol tree to be the parent of the descriptor subtree\n * @param tvb             the tv_buff with the (remaining) packet data\n *                        On entry the gaze is set to the descriptor length field.\n * @param descriptor_len  Length of the descriptor to dissect\n *\n * @return   offset within tvb at which dissection should continue\n */\nstatic int\ndissect_usb_video_streaming_interface_descriptor(proto_tree *parent_tree, tvbuff_t *tvb,\n                                                 guint8 descriptor_len)\n{\n    proto_tree  *tree;\n    int          offset = 0;\n    const gchar *subtype_str;\n    guint8       subtype;\n\n    subtype = tvb_get_guint8(tvb, offset+2);\n\n    subtype_str = val_to_str_ext(subtype, &vs_if_descriptor_subtypes_ext, \"Unknown (0x%x)\");\n    tree = proto_tree_add_subtree_format(parent_tree, tvb, offset, descriptor_len,\n            ett_descriptor_video_streaming, NULL, \"VIDEO STREAMING INTERFACE DESCRIPTOR [%s]\",\n            subtype_str);\n\n    dissect_usb_descriptor_header(tree, tvb, offset, &vid_descriptor_type_vals_ext);\n    proto_tree_add_item(tree, hf_usb_vid_streaming_ifdesc_subtype, tvb, offset+2, 1, ENC_LITTLE_ENDIAN);\n    offset += 3;\n\n    switch (subtype)\n    {\n        case VS_INPUT_HEADER:\n            offset = dissect_usb_video_streaming_input_header(tree, tvb, offset);\n            break;\n\n        case VS_FORMAT_UNCOMPRESSED:\n        case VS_FORMAT_MJPEG:\n        case VS_FORMAT_FRAME_BASED:\n            offset = dissect_usb_video_format(tree, tvb, offset, subtype);\n            break;\n\n        /* @todo MPEG2, H.264, VP8, Still Image Frame */\n        /* @todo Obsolete UVC-1.0 descriptors? */\n\n        case VS_FRAME_UNCOMPRESSED:\n        case VS_FRAME_MJPEG:\n        case VS_FRAME_FRAME_BASED:\n            offset = dissect_usb_video_frame(tree, tvb, offset, subtype);\n            break;\n\n        case VS_COLORFORMAT:\n            offset = dissect_usb_video_colorformat(tree, tvb, offset);\n            break;\n\n        default:\n            break;\n    }\n\n    /* Soak up descriptor bytes beyond those we know how to dissect */\n    if (offset < descriptor_len)\n        proto_tree_add_item(tree, hf_usb_vid_descriptor_data, tvb, offset, descriptor_len-offset, ENC_NA);\n\n    return descriptor_len;\n}\n\n/*****************************************************************************/\n\n/**\n * Dissector for video class-specific endpoint descriptor.\n *\n * @param parent_tree     the protocol tree to be the parent of the descriptor subtree\n * @param tvb             the tv_buff with the (remaining) packet data\n *                        On entry the gaze is set to the descriptor length field.\n * @param descriptor_len  Length of the descriptor to dissect\n *\n * @return   offset within tvb at which dissection should continue\n */\nstatic int\ndissect_usb_video_endpoint_descriptor(proto_tree *parent_tree, tvbuff_t *tvb,\n                                      guint8 descriptor_len)\n{\n    proto_tree *tree   = NULL;\n    int         offset = 0;\n    guint8      subtype;\n\n    subtype = tvb_get_guint8(tvb, offset+2);\n\n    if (parent_tree)\n    {\n        const gchar* subtype_str;\n\n        subtype_str = val_to_str(subtype, vc_ep_descriptor_subtypes, \"Unknown (0x%x)\");\n        tree = proto_tree_add_subtree_format(parent_tree, tvb, offset, descriptor_len,\n                ett_descriptor_video_endpoint, NULL, \"VIDEO CONTROL ENDPOINT DESCRIPTOR [%s]\",\n                subtype_str);\n    }\n\n    dissect_usb_descriptor_header(tree, tvb, offset, &vid_descriptor_type_vals_ext);\n    proto_tree_add_item(tree, hf_usb_vid_epdesc_subtype, tvb, offset+2, 1, ENC_LITTLE_ENDIAN);\n    offset += 3;\n\n    if (subtype == EP_INTERRUPT)\n    {\n        proto_tree_add_item(tree, hf_usb_vid_epdesc_max_transfer_sz, tvb, offset, 2, ENC_LITTLE_ENDIAN);\n        offset += 2;\n    }\n\n    /* Soak up descriptor bytes beyond those we know how to dissect */\n    if (offset < descriptor_len)\n        proto_tree_add_item(tree, hf_usb_vid_descriptor_data, tvb, offset, descriptor_len-offset, ENC_NA);\n\n    return descriptor_len;\n}\n\n/**\n * Registered dissector for video class-specific descriptors\n *\n * @param tvb    the tv_buff with the (remaining) packet data\n *               On entry the gaze is set to the descriptor length field.\n * @param pinfo  the packet info of this packet (additional info)\n * @param tree   the protocol tree to be built or NULL\n * @param data   Not used\n *\n * @return   0   no class specific dissector was found\n * @return  <0   not enough data\n * @return  >0   amount of data in the descriptor\n */\nstatic int\ndissect_usb_vid_descriptor(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)\n{\n    int    offset = 0;\n    guint8 descriptor_len;\n    guint8 descriptor_type;\n    gint   bytes_available;\n    usb_conv_info_t  *usb_conv_info = (usb_conv_info_t *)data;\n\n    tvbuff_t         *desc_tvb;\n\n    descriptor_len  = tvb_get_guint8(tvb, offset);\n    descriptor_type = tvb_get_guint8(tvb, offset+1);\n\n    bytes_available = tvb_captured_length_remaining(tvb, offset);\n    desc_tvb = tvb_new_subset(tvb, 0, bytes_available, descriptor_len);\n\n    if (descriptor_type == CS_ENDPOINT)\n    {\n        offset = dissect_usb_video_endpoint_descriptor(tree, desc_tvb,\n                                                       descriptor_len);\n    }\n    else if (descriptor_type == CS_INTERFACE)\n    {\n        if (usb_conv_info && usb_conv_info->interfaceSubclass == SC_VIDEOCONTROL)\n        {\n            offset = dissect_usb_video_control_interface_descriptor(tree, desc_tvb,\n                                                                    descriptor_len,\n                                                                    pinfo, usb_conv_info);\n        }\n        else if (usb_conv_info && usb_conv_info->interfaceSubclass == SC_VIDEOSTREAMING)\n        {\n            offset = dissect_usb_video_streaming_interface_descriptor(tree, desc_tvb,\n                                                                      descriptor_len);\n        }\n    }\n    /* else not something we recognize, just return offset = 0 */\n\n    return offset;\n}\n\n/*****************************************************************************/\n/*                            CONTROL TRANSFERS                              */\n/*****************************************************************************/\n\n/**\n * Dissect GET/SET transactions on the Video Probe and Commit controls.\n *\n * @param  parent_tree  protocol tree to which the probe/commit subtree should be added\n * @param  tvb          the tv_buff with the (remaining) packet data\n * @param  offset       where in tvb to begin dissection.\n *                      On entry this refers to the probe/commit bmHint field.\n *\n * @return offset within tvb at which dissection should continue\n */\nstatic int\ndissect_usb_vid_probe(proto_tree *parent_tree, tvbuff_t *tvb, int offset)\n{\n    proto_tree *tree;\n\n    static const int *hint_bits[] = {\n        &hf_usb_vid_probe_hint_D[0],\n        &hf_usb_vid_probe_hint_D[1],\n        &hf_usb_vid_probe_hint_D[2],\n        &hf_usb_vid_probe_hint_D[3],\n        &hf_usb_vid_probe_hint_D[4],\n        NULL\n    };\n\n    DISSECTOR_ASSERT(array_length(hint_bits) == (1+array_length(hf_usb_vid_probe_hint_D)));\n\n    tree = proto_tree_add_subtree(parent_tree, tvb, offset, -1, ett_video_probe, NULL, \"Probe/Commit Info\");\n\n    proto_tree_add_bitmask(tree, tvb, offset, hf_usb_vid_probe_hint,\n                           ett_probe_hint, hint_bits, ENC_LITTLE_ENDIAN);\n\n    proto_tree_add_item(tree, hf_usb_vid_format_index,         tvb, offset+2,  1, ENC_LITTLE_ENDIAN);\n    proto_tree_add_item(tree, hf_usb_vid_frame_index,          tvb, offset+3,  1, ENC_LITTLE_ENDIAN);\n    proto_tree_add_item(tree, hf_usb_vid_frame_interval,       tvb, offset+4,  4, ENC_LITTLE_ENDIAN);\n    proto_tree_add_item(tree, hf_usb_vid_probe_key_frame_rate, tvb, offset+8,  2, ENC_LITTLE_ENDIAN);\n    proto_tree_add_item(tree, hf_usb_vid_probe_p_frame_rate,   tvb, offset+10, 2, ENC_LITTLE_ENDIAN);\n    proto_tree_add_item(tree, hf_usb_vid_probe_comp_quality,   tvb, offset+12, 2, ENC_LITTLE_ENDIAN);\n    proto_tree_add_item(tree, hf_usb_vid_probe_comp_window,    tvb, offset+14, 2, ENC_LITTLE_ENDIAN);\n    proto_tree_add_item(tree, hf_usb_vid_probe_delay,          tvb, offset+16, 2, ENC_LITTLE_ENDIAN);\n    proto_tree_add_item(tree, hf_usb_vid_probe_max_frame_sz,   tvb, offset+18, 4, ENC_LITTLE_ENDIAN);\n    proto_tree_add_item(tree, hf_usb_vid_probe_max_payload_sz, tvb, offset+22, 4, ENC_LITTLE_ENDIAN);\n    offset += 26;\n\n    /* UVC 1.1 fields */\n    if (tvb_reported_length_remaining(tvb, offset) > 0)\n    {\n        static const int *framing_bits[] = {\n            &hf_usb_vid_probe_framing_D[0],\n            &hf_usb_vid_probe_framing_D[1],\n            NULL\n        };\n\n        DISSECTOR_ASSERT(array_length(framing_bits) == (1+array_length(hf_usb_vid_probe_framing_D)));\n\n        proto_tree_add_item(tree, hf_usb_vid_probe_clock_freq,     tvb, offset, 4, ENC_LITTLE_ENDIAN);\n        offset += 4;\n\n        proto_tree_add_bitmask(tree, tvb, offset, hf_usb_vid_probe_framing,\n                               ett_probe_framing, framing_bits, ENC_NA);\n        offset++;\n\n        proto_tree_add_item(tree, hf_usb_vid_probe_preferred_ver, tvb, offset,   1, ENC_LITTLE_ENDIAN);\n        proto_tree_add_item(tree, hf_usb_vid_probe_min_ver,       tvb, offset+1, 1, ENC_LITTLE_ENDIAN);\n        proto_tree_add_item(tree, hf_usb_vid_probe_max_ver,       tvb, offset+2, 1, ENC_LITTLE_ENDIAN);\n        offset += 3;\n    }\n\n    return offset;\n}\n\n/**\n * Fetch the table that describes known control selectors for the specified unit/terminal.\n *\n * @param  entity_id      Unit or terminal of interest\n * @param  usb_conv_info  Information about the interface the entity is part of\n *\n * @return Table describing control selectors for the specified entity (may be NULL)\n */\nstatic value_string_ext*\nget_control_selector_values(guint8 entity_id, usb_conv_info_t *usb_conv_info)\n{\n    video_conv_info_t *video_conv_info;\n    video_entity_t    *entity = NULL;\n    value_string_ext  *selectors = NULL;\n\n    if (usb_conv_info == NULL)\n        return NULL;\n\n    video_conv_info = (video_conv_info_t *)usb_conv_info->class_data;\n    if (video_conv_info)\n        entity = (video_entity_t*) wmem_tree_lookup32(video_conv_info->entities, entity_id);\n\n    if (entity_id == 0)\n    {\n        /* Interface Request*/\n        switch (usb_conv_info->interfaceSubclass)\n        {\n            case SC_VIDEOCONTROL:\n                selectors = &cs_control_interface_ext;\n                break;\n\n            case SC_VIDEOSTREAMING:\n                selectors = &cs_streaming_interface_ext;\n                break;\n\n            default:\n                break;\n        }\n    }\n    else if (entity)\n    {\n        switch (entity->subtype)\n        {\n            case VC_INPUT_TERMINAL:\n                if (entity->terminalType == ITT_CAMERA)\n                {\n                    selectors = &cs_camera_terminal_ext;\n                }\n                break;\n\n            case VC_PROCESSING_UNIT:\n                selectors = &cs_processing_unit_ext;\n                break;\n\n            case VC_SELECTOR_UNIT:\n                selectors = &cs_selector_unit_ext;\n                break;\n\n            default:\n                break;\n        }\n    }\n\n    return selectors;\n}\n\n/**\n * Fetch the name of an entity's control.\n *\n * @param  entity_id      Unit or terminal of interest\n * @param  control_sel    Control of interest\n * @param  usb_conv_info  Information about the interface the entity is part of\n *\n * @return Table describing control selectors for the specified entity (may be NULL)\n */\nstatic const gchar*\nget_control_selector_name(guint8 entity_id, guint8 control_sel, usb_conv_info_t *usb_conv_info)\n{\n    const gchar      *control_name = NULL;\n    value_string_ext *selectors = NULL;\n\n    selectors = get_control_selector_values(entity_id, usb_conv_info);\n\n    if (selectors)\n        control_name = try_val_to_str_ext(control_sel, selectors);\n\n    return control_name;\n}\n\n/* Dissect the response to a GET INFO request */\nstatic int\ndissect_usb_vid_control_info(proto_tree *tree, tvbuff_t *tvb, int offset)\n{\n    static const int *capability_bits[] = {\n        &hf_usb_vid_control_info_D[0],\n        &hf_usb_vid_control_info_D[1],\n        &hf_usb_vid_control_info_D[2],\n        &hf_usb_vid_control_info_D[3],\n        &hf_usb_vid_control_info_D[4],\n        &hf_usb_vid_control_info_D[5],\n        &hf_usb_vid_control_info_D[6],\n        NULL\n    };\n\n    DISSECTOR_ASSERT(array_length(capability_bits) == (1+array_length(hf_usb_vid_control_info_D)));\n\n    proto_tree_add_bitmask(tree, tvb, offset, hf_usb_vid_control_info,\n                           ett_control_capabilities, capability_bits, ENC_NA);\n\n    return offset+1;\n}\n\n/* Dissect all remaining bytes in the tvb as a specified type of UVC value.\n * These are displayed as an unsigned integer where possible, otherwise just as\n * a text item.\n *\n * @param tree     the protocol tree to which an item will be added\n * @param tvb      the tv_buff with the (remaining) packet data\n * @param offset   How far into tvb the value data begins\n * @param request  Identifies type of value - either bRequest from a CONTROL\n *                 transfer (i.e., USB_SETUP_GET_MAX), or bValue from an\n *                 INTERRUPT transfer (i.e., CONTROL_CHANGE_MAX).\n */\nstatic void\ndissect_usb_vid_control_value(proto_tree *tree, tvbuff_t *tvb, int offset, guint8 request)\n{\n    gint        value_size;\n    const char *fallback_name;\n    int         hf;\n\n    switch (request)\n    {\n        case USB_SETUP_GET_DEF:\n            hf = hf_usb_vid_control_default;\n            fallback_name = \"Default Value\";\n            break;\n\n        case USB_SETUP_GET_MIN:\n        case CONTROL_CHANGE_MIN:\n            hf = hf_usb_vid_control_min;\n            fallback_name = \"Min Value\";\n            break;\n\n        case USB_SETUP_GET_MAX:\n        case CONTROL_CHANGE_MAX:\n            hf = hf_usb_vid_control_max;\n            fallback_name = \"Max Value\";\n            break;\n\n        case USB_SETUP_GET_RES:\n            hf = hf_usb_vid_control_res;\n            fallback_name = \"Resolution\";\n            break;\n\n        case USB_SETUP_GET_CUR:\n        case USB_SETUP_SET_CUR:\n        case CONTROL_CHANGE_VALUE:\n            hf = hf_usb_vid_control_cur;\n            fallback_name = \"Current Value\";\n            break;\n\n        /* @todo UVC 1.5 USB_SETUP_x_ALL?\n         *       They are poorly specified.\n         */\n\n        default:\n            hf = -1;\n            fallback_name = \"Value\";\n            break;\n    }\n\n    value_size = tvb_reported_length_remaining(tvb, offset);\n\n    if (hf != -1)\n    {\n        header_field_info *hfinfo;\n        hfinfo = proto_registrar_get_nth(hf);\n        DISSECTOR_ASSERT(IS_FT_INT(hfinfo->type) || IS_FT_UINT(hfinfo->type));\n    }\n\n    if ((hf != -1) && (value_size <= 4))\n    {\n        proto_tree_add_item(tree, hf, tvb, offset, value_size, ENC_LITTLE_ENDIAN);\n    }\n    else\n    {\n        /* @todo Display as FT_BYTES with a big-endian disclaimer?\n         * See https://bugs.wireshark.org/bugzilla/show_bug.cgi?id=7933\n         */\n        proto_tree_add_bytes_format(tree, hf_usb_vid_control_value, tvb, offset, value_size, NULL, \"%s\", fallback_name);\n    }\n}\n\n/**\n * Dissect video class GET/SET transactions.\n *\n * @param  pinfo           Information associated with the packet being dissected\n * @param  tree            protocol tree to which fields should be added\n * @param  tvb             the tv_buff with the (remaining) packet data\n * @param  offset          where in tvb to begin dissection.\n *                         On entry this refers to the bRequest field of the SETUP\n *                         transaction.\n * @param  is_request      true if the packet is host-to-device,\n *                         false if device-to-host\n * @param  usb_trans_info  Information specific to this request/response pair\n * @param  usb_conv_info   Information about the conversation with the host\n */\nstatic int\ndissect_usb_vid_get_set(packet_info *pinfo, proto_tree *tree, tvbuff_t *tvb,\n                        int offset, gboolean is_request,\n                        usb_trans_info_t *usb_trans_info,\n                        usb_conv_info_t *usb_conv_info)\n{\n    const gchar *short_name = NULL;\n    guint8       control_sel;\n    guint8       entity_id;\n\n    entity_id   = usb_trans_info->setup.wIndex >> 8;\n    control_sel = usb_trans_info->setup.wValue >> 8;\n\n    /* Display something informative in the INFO column */\n    col_append_str(pinfo->cinfo, COL_INFO, \" [\");\n    short_name = get_control_selector_name(entity_id, control_sel, usb_conv_info);\n\n    if (short_name)\n        col_append_str(pinfo->cinfo, COL_INFO, short_name);\n    else\n    {\n        short_name = \"Unknown\";\n\n        if (entity_id == 0)\n        {\n            col_append_fstr(pinfo->cinfo, COL_INFO, \"Interface %u control 0x%x\",\n                            usb_conv_info->interfaceNum, control_sel);\n        }\n        else\n        {\n            col_append_fstr(pinfo->cinfo, COL_INFO, \"Unit %u control 0x%x\",\n                            entity_id, control_sel);\n        }\n    }\n\n    col_append_str(pinfo->cinfo, COL_INFO, \"]\");\n    col_set_fence(pinfo->cinfo, COL_INFO);\n\n    /* Add information on request context,\n     * as GENERATED fields if not directly available (for filtering)\n     */\n    if (is_request)\n    {\n        /* Move gaze to control selector (MSB of wValue) */\n        offset++;\n        proto_tree_add_uint_format_value(tree, hf_usb_vid_control_selector, tvb,\n                                     offset, 1, control_sel, \"%s (0x%02x)\", short_name, control_sel);\n        offset++;\n\n        proto_tree_add_item(tree, hf_usb_vid_control_interface, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n        offset++;\n\n        proto_tree_add_item(tree, hf_usb_vid_control_entity, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n        offset++;\n\n        proto_tree_add_item(tree, hf_usb_vid_length, tvb, offset, 2, ENC_LITTLE_ENDIAN);\n        offset += 2;\n    }\n    else\n    {\n        proto_item *ti;\n\n        ti = proto_tree_add_uint(tree, hf_usb_vid_control_interface, tvb, 0, 0,\n                                 usb_trans_info->setup.wIndex & 0xFF);\n        PROTO_ITEM_SET_GENERATED(ti);\n\n        ti = proto_tree_add_uint(tree, hf_usb_vid_control_entity, tvb, 0, 0, entity_id);\n        PROTO_ITEM_SET_GENERATED(ti);\n\n        ti = proto_tree_add_uint_format_value(tree, hf_usb_vid_control_selector, tvb,\n                                     0, 0, control_sel, \"%s (0x%02x)\", short_name, control_sel);\n        PROTO_ITEM_SET_GENERATED(ti);\n    }\n\n    if (!is_request || (usb_trans_info->setup.request == USB_SETUP_SET_CUR))\n    {\n        gint value_size = tvb_reported_length_remaining(tvb, offset);\n\n        if (value_size != 0)\n        {\n            if ((entity_id == 0) && (usb_conv_info->interfaceSubclass == SC_VIDEOSTREAMING))\n            {\n                if ((control_sel == VS_PROBE_CONTROL) || (control_sel == VS_COMMIT_CONTROL))\n                {\n                    int old_offset = offset;\n                    offset = dissect_usb_vid_probe(tree, tvb, offset);\n                    value_size -= (offset - old_offset);\n                }\n            }\n            else\n            {\n                if (usb_trans_info->setup.request == USB_SETUP_GET_INFO)\n                {\n                    dissect_usb_vid_control_info(tree, tvb, offset);\n                    offset++;\n                    value_size--;\n                }\n                else if (usb_trans_info->setup.request == USB_SETUP_GET_LEN)\n                {\n                    proto_tree_add_item(tree, hf_usb_vid_control_length, tvb, offset, 2, ENC_LITTLE_ENDIAN);\n                    offset += 2;\n                    value_size -= 2;\n                }\n                else if (   (usb_trans_info->setup.request == USB_SETUP_GET_CUR)\n                         && (entity_id == 0)\n                         && (usb_conv_info->interfaceSubclass == SC_VIDEOCONTROL)\n                         && (control_sel == VC_REQUEST_ERROR_CODE_CONTROL))\n                {\n                    proto_tree_add_item(tree, hf_usb_vid_request_error, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n                    offset++;\n                    value_size--;\n                }\n                else\n                {\n                    dissect_usb_vid_control_value(tree, tvb, offset, usb_trans_info->setup.request);\n                    offset += value_size;\n                    value_size = 0;\n                }\n            }\n\n            if (value_size > 0)\n            {\n                proto_tree_add_item(tree, hf_usb_vid_control_data, tvb, offset, -1, ENC_NA);\n                offset += value_size;\n            }\n        }\n    }\n\n    return offset;\n}\n\n/* Table for dispatch of video class SETUP transactions based on bRequest.\n * At the moment this is overkill since the same function handles all defined\n * requests.\n */\ntypedef int (*usb_setup_dissector)(packet_info *pinfo, proto_tree *tree,\n        tvbuff_t *tvb, int offset,\n        gboolean is_request,\n        usb_trans_info_t *usb_trans_info,\n        usb_conv_info_t *usb_conv_info);\n\ntypedef struct _usb_setup_dissector_table_t\n{\n    guint8 request;\n    usb_setup_dissector dissector;\n} usb_setup_dissector_table_t;\n\nstatic const usb_setup_dissector_table_t setup_dissectors[] = {\n        {USB_SETUP_SET_CUR,      dissect_usb_vid_get_set},\n        {USB_SETUP_SET_CUR_ALL,  dissect_usb_vid_get_set},\n        {USB_SETUP_GET_CUR,      dissect_usb_vid_get_set},\n        {USB_SETUP_GET_MIN,      dissect_usb_vid_get_set},\n        {USB_SETUP_GET_MAX,      dissect_usb_vid_get_set},\n        {USB_SETUP_GET_RES,      dissect_usb_vid_get_set},\n        {USB_SETUP_GET_LEN,      dissect_usb_vid_get_set},\n        {USB_SETUP_GET_INFO,     dissect_usb_vid_get_set},\n        {USB_SETUP_GET_DEF,      dissect_usb_vid_get_set},\n        {USB_SETUP_GET_CUR_ALL,  dissect_usb_vid_get_set},\n        {USB_SETUP_GET_MIN_ALL,  dissect_usb_vid_get_set},\n        {USB_SETUP_GET_MAX_ALL,  dissect_usb_vid_get_set},\n        {USB_SETUP_GET_RES_ALL,  dissect_usb_vid_get_set},\n        {0, NULL}\n};\n\nstatic const value_string setup_request_names_vals[] = {\n        {USB_SETUP_SET_CUR,      \"SET CUR\"},\n        {USB_SETUP_SET_CUR_ALL,  \"SET CUR ALL\"},\n        {USB_SETUP_GET_CUR,      \"GET CUR\"},\n        {USB_SETUP_GET_MIN,      \"GET MIN\"},\n        {USB_SETUP_GET_MAX,      \"GET MAX\"},\n        {USB_SETUP_GET_RES,      \"GET RES\"},\n        {USB_SETUP_GET_LEN,      \"GET LEN\"},\n        {USB_SETUP_GET_INFO,     \"GET INFO\"},\n        {USB_SETUP_GET_DEF,      \"GET DEF\"},\n        {USB_SETUP_GET_CUR_ALL,  \"GET CUR ALL\"},\n        {USB_SETUP_GET_MIN_ALL,  \"GET MIN ALL\"},\n        {USB_SETUP_GET_MAX_ALL,  \"GET MAX ALL\"},\n        {USB_SETUP_GET_RES_ALL,  \"GET RES ALL\"},\n        {USB_SETUP_GET_DEF_ALL,  \"GET DEF ALL\"},\n        {0, NULL}\n};\n\n/* Registered dissector for video class-specific control requests.\n * Dispatch to an appropriate dissector function.\n *\n * @param tvb    the tv_buff with the (remaining) packet data.\n *               On entry, the gaze is set to SETUP bRequest field.\n * @param pinfo  the packet info of this packet (additional info)\n * @param tree   the protocol tree to be built or NULL\n * @param data   Not used\n *\n * @return   0   no class specific dissector was found\n * @return  <0   not enough data\n * @return  >0   amount of data in the descriptor\n */\nstatic int\ndissect_usb_vid_control(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)\n{\n    gboolean             is_request = (pinfo->srcport == NO_ENDPOINT);\n    usb_conv_info_t     *usb_conv_info;\n    usb_trans_info_t    *usb_trans_info;\n    int                  offset     = 0;\n    usb_setup_dissector  dissector  = NULL;\n    const usb_setup_dissector_table_t *tmp;\n\n    /* Reject the packet if data or usb_trans_info are NULL */\n    if (data == NULL || ((usb_conv_info_t *)data)->usb_trans_info == NULL)\n        return 0;\n    usb_conv_info = (usb_conv_info_t *)data;\n    usb_trans_info = usb_conv_info->usb_trans_info;\n\n    /* See if we can find a class specific dissector for this request */\n    for (tmp=setup_dissectors; tmp->dissector; tmp++)\n    {\n        if (tmp->request == usb_trans_info->setup.request)\n        {\n            dissector = tmp->dissector;\n            break;\n        }\n    }\n    /* No we could not find any class specific dissector for this request\n     * return FALSE and let USB try any of the standard requests.\n     */\n    if (!dissector)\n        return 0;\n\n    col_set_str(pinfo->cinfo, COL_PROTOCOL, \"USBVIDEO\");\n    col_add_fstr(pinfo->cinfo, COL_INFO, \"%s %s\",\n                val_to_str(usb_trans_info->setup.request, setup_request_names_vals, \"Unknown type %x\"),\n                is_request?\"Request \":\"Response\");\n\n    if (is_request)\n    {\n        proto_tree_add_item(tree, hf_usb_vid_request, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n        offset += 1;\n    }\n\n    offset = dissector(pinfo, tree, tvb, offset, is_request, usb_trans_info, usb_conv_info);\n    return offset;\n}\n\n/* Registered dissector for video class-specific URB_INTERRUPT\n *\n * @param tvb    the tv_buff with the (remaining) packet data\n * @param pinfo  the packet info of this packet (additional info)\n * @param tree   the protocol tree to be built or NULL\n * @param data   Unused API parameter\n *\n * @return   0   no class specific dissector was found\n * @return  <0   not enough data\n * @return  >0   amount of data in the descriptor\n */\nstatic int\ndissect_usb_vid_interrupt(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)\n{\n    usb_conv_info_t *usb_conv_info;\n    gint bytes_available;\n    int  offset = 0;\n\n    usb_conv_info   = (usb_conv_info_t *)data;\n    bytes_available = tvb_reported_length_remaining(tvb, offset);\n\n    col_set_str(pinfo->cinfo, COL_PROTOCOL, \"USBVIDEO\");\n\n    if (bytes_available > 0)\n    {\n        guint8 originating_interface;\n        guint8 originating_entity;\n\n        originating_interface = tvb_get_guint8(tvb, offset) & INT_ORIGINATOR_MASK;\n        proto_tree_add_item(tree, hf_usb_vid_interrupt_bStatusType, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n        offset++;\n\n        originating_entity = tvb_get_guint8(tvb, offset);\n        proto_tree_add_item(tree, hf_usb_vid_interrupt_bOriginator, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n        offset++;\n\n        if (originating_interface == INT_VIDEOCONTROL)\n        {\n            guint8 control_sel;\n            guint8 attribute;\n            const gchar *control_name;\n\n            proto_tree_add_item(tree, hf_usb_vid_control_interrupt_bEvent, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n            offset++;\n\n            control_sel = tvb_get_guint8(tvb, offset);\n            control_name = get_control_selector_name(originating_entity, control_sel, usb_conv_info);\n            if (!control_name)\n                control_name = \"Unknown\";\n\n            proto_tree_add_uint_format_value(tree, hf_usb_vid_control_selector, tvb,\n                                             offset, 1, control_sel, \"%s (0x%02x)\",\n                                             control_name, control_sel);\n            offset++;\n\n            attribute = tvb_get_guint8(tvb, offset);\n            proto_tree_add_item(tree, hf_usb_vid_interrupt_bAttribute, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n            offset++;\n\n            switch (attribute)\n            {\n                case CONTROL_CHANGE_FAILURE:\n                    proto_tree_add_item(tree, hf_usb_vid_request_error, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n                    offset++;\n                    break;\n\n                case CONTROL_CHANGE_INFO:\n                    offset = dissect_usb_vid_control_info(tree, tvb, offset);\n                    break;\n\n                case CONTROL_CHANGE_VALUE:\n                case CONTROL_CHANGE_MIN:\n                case CONTROL_CHANGE_MAX:\n                    dissect_usb_vid_control_value(tree, tvb, offset, attribute);\n                    offset += tvb_reported_length_remaining(tvb, offset);\n                    break;\n\n                default:\n                    proto_tree_add_item(tree, hf_usb_vid_value_data, tvb, offset, -1, ENC_NA);\n                    offset += tvb_reported_length_remaining(tvb, offset);\n                    break;\n            }\n        }\n        else if (originating_interface == INT_VIDEOSTREAMING)\n        {\n            /* @todo */\n        }\n    }\n    else\n        offset = -2;\n\n    return offset;\n}\n\nvoid\nproto_register_usb_vid(void)\n{\n    static hf_register_info hf[] = {\n        /***** Setup *****/\n            { &hf_usb_vid_request,\n                    { \"bRequest\", \"usbvideo.setup.bRequest\", FT_UINT8, BASE_HEX, VALS(setup_request_names_vals), 0x0,\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_length,\n                    { \"wLength\", \"usbvideo.setup.wLength\", FT_UINT16, BASE_DEC, NULL, 0x0,\n                            NULL, HFILL }\n            },\n\n        /***** Request Error Control *****/\n            { &hf_usb_vid_request_error,\n                    { \"bRequestErrorCode\", \"usbvideo.reqerror.code\",\n                            FT_UINT8, BASE_DEC | BASE_EXT_STRING,\n                            &request_error_codes_ext, 0,\n                            \"Request Error Code\", HFILL }\n            },\n\n        /***** Unit/Terminal Controls *****/\n            { &hf_usb_vid_control_selector,\n                    { \"Control Selector\", \"usbvideo.control.selector\", FT_UINT8, BASE_HEX, NULL, 0x0,\n                            \"ID of the control within its entity\", HFILL }\n            },\n\n            { &hf_usb_vid_control_entity,\n                    { \"Entity\", \"usbvideo.control.entity\", FT_UINT8, BASE_HEX, NULL, 0x0,\n                            \"Unit or terminal to which the control belongs\", HFILL }\n            },\n\n            { &hf_usb_vid_control_interface,\n                    { \"Interface\", \"usbvideo.control.interface\", FT_UINT8, BASE_HEX, NULL, 0x0,\n                            \"Interface to which the control belongs\", HFILL }\n            },\n\n            { &hf_usb_vid_control_info,\n                    { \"Info (Capabilities/State)\", \"usbvideo.control.info\",\n                            FT_UINT8, BASE_HEX, NULL, 0,\n                            \"Control capabilities and current state\", HFILL }\n            },\n\n            { &hf_usb_vid_control_info_D[0],\n                    { \"Supports GET\", \"usbvideo.control.info.D0\",\n                            FT_BOOLEAN, 8, TFS(&tfs_yes_no), (1<<0),\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_control_info_D[1],\n                    { \"Supports SET\", \"usbvideo.control.info.D1\",\n                            FT_BOOLEAN, 8, TFS(&tfs_yes_no), (1<<1),\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_control_info_D[2],\n                    { \"Disabled due to automatic mode\", \"usbvideo.control.info.D2\",\n                            FT_BOOLEAN, 8, TFS(&tfs_yes_no), (1<<2),\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_control_info_D[3],\n                    { \"Autoupdate\", \"usbvideo.control.info.D3\",\n                            FT_BOOLEAN, 8, TFS(&tfs_yes_no), (1<<3),\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_control_info_D[4],\n                    { \"Asynchronous\", \"usbvideo.control.info.D4\",\n                            FT_BOOLEAN, 8, TFS(&tfs_yes_no), (1<<4),\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_control_info_D[5],\n                    { \"Disabled due to incompatibility with Commit state\", \"usbvideo.control.info.D5\",\n                            FT_BOOLEAN, 8, TFS(&tfs_yes_no), (1<<5),\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_control_info_D[6],\n                    { \"Reserved\", \"usbvideo.control.info.D6\",\n                            FT_UINT8, BASE_HEX, NULL, (3<<6),\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_control_length,\n                    { \"Control Length\", \"usbvideo.control.len\",\n                            FT_UINT16, BASE_DEC, NULL, 0,\n                            \"Control size in bytes\", HFILL }\n            },\n\n            { &hf_usb_vid_control_default,\n                    { \"Default value\", \"usbvideo.control.value.default\",\n                            FT_UINT32, BASE_DEC_HEX, NULL, 0,\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_control_min,\n                    { \"Minimum value\", \"usbvideo.control.value.min\",\n                            FT_UINT32, BASE_DEC_HEX, NULL, 0,\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_control_max,\n                    { \"Maximum value\", \"usbvideo.control.value.max\",\n                            FT_UINT32, BASE_DEC_HEX, NULL, 0,\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_control_res,\n                    { \"Resolution\", \"usbvideo.control.value.res\",\n                            FT_UINT32, BASE_DEC_HEX, NULL, 0,\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_control_cur,\n                    { \"Current value\", \"usbvideo.control.value.cur\",\n                            FT_UINT32, BASE_DEC_HEX, NULL, 0,\n                            NULL, HFILL }\n            },\n\n        /***** Terminal Descriptors *****/\n\n            /* @todo Decide whether to unify .name fields */\n            { &hf_usb_vid_control_ifdesc_iTerminal,\n                    { \"iTerminal\", \"usbvideo.terminal.name\", FT_UINT8, BASE_DEC, NULL, 0x0,\n                            \"String Descriptor describing this terminal\", HFILL }\n            },\n\n            /* @todo Decide whether to unify .terminal.id and .unit.id under .entityID */\n            { &hf_usb_vid_control_ifdesc_terminal_id,\n                    { \"bTerminalID\", \"usbvideo.terminal.id\", FT_UINT8, BASE_DEC, NULL, 0x0,\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_control_ifdesc_terminal_type,\n                    { \"wTerminalType\", \"usbvideo.terminal.type\",\n                            FT_UINT16, BASE_HEX | BASE_EXT_STRING, &vc_terminal_types_ext, 0,\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_control_ifdesc_assoc_terminal,\n                    { \"bAssocTerminal\", \"usbvideo.terminal.assocTerminal\", FT_UINT8, BASE_DEC, NULL, 0x0,\n                            \"Associated Terminal\", HFILL }\n            },\n\n        /***** Camera Terminal Descriptor *****/\n\n            { &hf_usb_vid_cam_objective_focal_len_min,\n                    { \"wObjectiveFocalLengthMin\", \"usbvideo.camera.objectiveFocalLengthMin\",\n                            FT_UINT16, BASE_DEC, NULL, 0,\n                            \"Minimum Focal Length for Optical Zoom\", HFILL }\n            },\n\n            { &hf_usb_vid_cam_objective_focal_len_max,\n                    { \"wObjectiveFocalLengthMax\", \"usbvideo.camera.objectiveFocalLengthMax\",\n                            FT_UINT16, BASE_DEC, NULL, 0,\n                            \"Minimum Focal Length for Optical Zoom\", HFILL }\n            },\n\n            { &hf_usb_vid_cam_ocular_focal_len,\n                    { \"wOcularFocalLength\", \"usbvideo.camera.ocularFocalLength\",\n                            FT_UINT16, BASE_DEC, NULL, 0,\n                            \"Ocular Focal Length for Optical Zoom\", HFILL }\n            },\n\n            { &hf_usb_vid_cam_control_D[0],\n                    { \"Scanning Mode\", \"usbvideo.camera.control.D0\",\n                            FT_BOOLEAN,\n                            array_length(hf_usb_vid_cam_control_D),\n                            TFS(&tfs_yes_no), (1<<0),\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_cam_control_D[1],\n                    { \"Auto Exposure Mode\", \"usbvideo.camera.control.D1\",\n                            FT_BOOLEAN,\n                            array_length(hf_usb_vid_cam_control_D),\n                            TFS(&tfs_yes_no), (1<<1),\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_cam_control_D[2],\n                    { \"Auto Exposure Priority\", \"usbvideo.camera.control.D2\",\n                            FT_BOOLEAN,\n                            array_length(hf_usb_vid_cam_control_D),\n                            TFS(&tfs_yes_no), (1<<2),\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_cam_control_D[3],\n                    { \"Exposure Time (Absolute)\", \"usbvideo.camera.control.D3\",\n                            FT_BOOLEAN,\n                            array_length(hf_usb_vid_cam_control_D),\n                            TFS(&tfs_yes_no), (1<<3),\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_cam_control_D[4],\n                    { \"Exposure Time (Relative)\", \"usbvideo.camera.control.D4\",\n                            FT_BOOLEAN,\n                            array_length(hf_usb_vid_cam_control_D),\n                            TFS(&tfs_yes_no), (1<<4),\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_cam_control_D[5],\n                    { \"Focus (Absolute)\", \"usbvideo.camera.control.D5\",\n                            FT_BOOLEAN,\n                            array_length(hf_usb_vid_cam_control_D),\n                            TFS(&tfs_yes_no), (1<<5),\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_cam_control_D[6],\n                    { \"Focus (Relative)\", \"usbvideo.camera.control.D6\",\n                            FT_BOOLEAN,\n                            array_length(hf_usb_vid_cam_control_D),\n                            TFS(&tfs_yes_no), (1<<6),\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_cam_control_D[7],\n                    { \"Iris (Absolute)\", \"usbvideo.camera.control.D7\",\n                            FT_BOOLEAN,\n                            array_length(hf_usb_vid_cam_control_D),\n                            TFS(&tfs_yes_no), (1<<7),\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_cam_control_D[8],\n                    { \"Iris (Relative)\", \"usbvideo.camera.control.D8\",\n                            FT_BOOLEAN,\n                            array_length(hf_usb_vid_cam_control_D),\n                            TFS(&tfs_yes_no), (1<<8),\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_cam_control_D[9],\n                    { \"Zoom (Absolute)\", \"usbvideo.camera.control.D9\",\n                            FT_BOOLEAN,\n                            array_length(hf_usb_vid_cam_control_D),\n                            TFS(&tfs_yes_no), (1<<9),\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_cam_control_D[10],\n                    { \"Zoom (Relative)\", \"usbvideo.camera.control.D10\",\n                            FT_BOOLEAN,\n                            array_length(hf_usb_vid_cam_control_D),\n                            TFS(&tfs_yes_no), (1<<10),\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_cam_control_D[11],\n                    { \"PanTilt (Absolute)\", \"usbvideo.camera.control.D11\",\n                            FT_BOOLEAN,\n                            array_length(hf_usb_vid_cam_control_D),\n                            TFS(&tfs_yes_no), (1<<11),\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_cam_control_D[12],\n                    { \"PanTilt (Relative)\", \"usbvideo.camera.control.D12\",\n                            FT_BOOLEAN,\n                            array_length(hf_usb_vid_cam_control_D),\n                            TFS(&tfs_yes_no), (1<<12),\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_cam_control_D[13],\n                    { \"Roll (Absolute)\", \"usbvideo.camera.control.D13\",\n                            FT_BOOLEAN,\n                            array_length(hf_usb_vid_cam_control_D),\n                            TFS(&tfs_yes_no), (1<<13),\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_cam_control_D[14],\n                    { \"Roll (Relative)\", \"usbvideo.camera.control.D14\",\n                            FT_BOOLEAN,\n                            array_length(hf_usb_vid_cam_control_D),\n                            TFS(&tfs_yes_no), (1<<14),\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_cam_control_D[15],\n                    { \"D15\", \"usbvideo.camera.control.D15\",\n                            FT_BOOLEAN,\n                            array_length(hf_usb_vid_cam_control_D),\n                            TFS(&tfs_yes_no), (1<<15),\n                            \"Reserved\", HFILL }\n            },\n\n            { &hf_usb_vid_cam_control_D[16],\n                    { \"D16\", \"usbvideo.camera.control.D16\",\n                            FT_BOOLEAN,\n                            array_length(hf_usb_vid_cam_control_D),\n                            TFS(&tfs_yes_no), (1<<16),\n                            \"Reserved\", HFILL }\n            },\n\n            { &hf_usb_vid_cam_control_D[17],\n                    { \"Auto Focus\", \"usbvideo.camera.control.D17\",\n                            FT_BOOLEAN,\n                            array_length(hf_usb_vid_cam_control_D),\n                            TFS(&tfs_yes_no), (1<<17),\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_cam_control_D[18],\n                    { \"Privacy\", \"usbvideo.camera.control.D18\",\n                            FT_BOOLEAN,\n                            array_length(hf_usb_vid_cam_control_D),\n                            TFS(&tfs_yes_no), (1<<18),\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_cam_control_D[19],\n                    { \"Focus (Simple)\", \"usbvideo.camera.control.D19\",\n                            FT_BOOLEAN,\n                            array_length(hf_usb_vid_cam_control_D),\n                            TFS(&tfs_yes_no), (1<<19),\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_cam_control_D[20],\n                    { \"Window\", \"usbvideo.camera.control.D20\",\n                            FT_BOOLEAN,\n                            array_length(hf_usb_vid_cam_control_D),\n                            TFS(&tfs_yes_no), (1<<20),\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_cam_control_D[21],\n                    { \"Region of Interest\", \"usbvideo.camera.control.D21\",\n                            FT_BOOLEAN,\n                            array_length(hf_usb_vid_cam_control_D),\n                            TFS(&tfs_yes_no), (1<<21),\n                            NULL, HFILL }\n            },\n\n        /***** Unit Descriptors *****/\n\n            { &hf_usb_vid_control_ifdesc_unit_id,\n                    { \"bUnitID\", \"usbvideo.unit.id\", FT_UINT8, BASE_DEC, NULL, 0x0,\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_num_inputs,\n                    { \"bNrInPins\", \"usbvideo.unit.numInputs\",\n                            FT_UINT8, BASE_DEC, NULL, 0,\n                            \"Number of input pins\", HFILL }\n            },\n\n            { &hf_usb_vid_sources,\n                    { \"baSourceID\", \"usbvideo.unit.sources\",\n                            FT_BYTES, BASE_NONE, NULL, 0,\n                            \"Input entity IDs\", HFILL }\n            },\n\n\n        /***** Processing Unit Descriptor *****/\n\n            { &hf_usb_vid_iProcessing,\n                    { \"iProcessing\", \"usbvideo.processor.name\", FT_UINT8, BASE_DEC, NULL, 0x0,\n                            \"String Descriptor describing this terminal\", HFILL }\n            },\n\n            { &hf_usb_vid_proc_control_D[0],\n                    { \"Brightness\", \"usbvideo.processor.control.D0\",\n                            FT_BOOLEAN, 24, TFS(&tfs_yes_no), (1<<0),\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_proc_control_D[1],\n                    { \"Contrast\", \"usbvideo.processor.control.D1\",\n                            FT_BOOLEAN, 24, TFS(&tfs_yes_no), (1<<1),\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_proc_control_D[2],\n                    { \"Hue\", \"usbvideo.processor.control.D2\",\n                            FT_BOOLEAN, 24, TFS(&tfs_yes_no), (1<<2),\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_proc_control_D[3],\n                    { \"Saturation\", \"usbvideo.processor.control.D3\",\n                            FT_BOOLEAN, 24, TFS(&tfs_yes_no), (1<<3),\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_proc_control_D[4],\n                    { \"Sharpness\", \"usbvideo.processor.control.D4\",\n                            FT_BOOLEAN, 24, TFS(&tfs_yes_no), (1<<4),\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_proc_control_D[5],\n                    { \"Gamma\", \"usbvideo.processor.control.D5\",\n                            FT_BOOLEAN, 24, TFS(&tfs_yes_no), (1<<5),\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_proc_control_D[6],\n                    { \"White Balance Temperature\", \"usbvideo.processor.control.D6\",\n                            FT_BOOLEAN, 24, TFS(&tfs_yes_no), (1<<6),\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_proc_control_D[7],\n                    { \"White Balance Component\", \"usbvideo.processor.control.D7\",\n                            FT_BOOLEAN, 24, TFS(&tfs_yes_no), (1<<7),\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_proc_control_D[8],\n                    { \"Backlight Compensation\", \"usbvideo.processor.control.D8\",\n                            FT_BOOLEAN, 24, TFS(&tfs_yes_no), (1<<8),\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_proc_control_D[9],\n                    { \"Gain\", \"usbvideo.processor.control.D9\",\n                            FT_BOOLEAN, 24, TFS(&tfs_yes_no), (1<<9),\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_proc_control_D[10],\n                    { \"Power Line Frequency\", \"usbvideo.processor.control.D10\",\n                            FT_BOOLEAN, 24, TFS(&tfs_yes_no), (1<<10),\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_proc_control_D[11],\n                    { \"Hue, Auto\", \"usbvideo.processor.control.D11\",\n                            FT_BOOLEAN, 24, TFS(&tfs_yes_no), (1<<11),\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_proc_control_D[12],\n                    { \"White Balance Temperature, Auto\", \"usbvideo.processor.control.D12\",\n                            FT_BOOLEAN, 24, TFS(&tfs_yes_no), (1<<12),\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_proc_control_D[13],\n                    { \"White Balance Component, Auto\", \"usbvideo.processor.control.D13\",\n                            FT_BOOLEAN, 24, TFS(&tfs_yes_no), (1<<13),\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_proc_control_D[14],\n                    { \"Digital Multiplier\", \"usbvideo.processor.control.D14\",\n                            FT_BOOLEAN, 24, TFS(&tfs_yes_no), (1<<14),\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_proc_control_D[15],\n                    { \"Digital Multiplier Limit\", \"usbvideo.processor.control.D15\",\n                            FT_BOOLEAN, 24, TFS(&tfs_yes_no), (1<<15),\n                            \"Reserved\", HFILL }\n            },\n\n            { &hf_usb_vid_proc_control_D[16],\n                    { \"Analog Video Standard\", \"usbvideo.processor.control.D16\",\n                            FT_BOOLEAN, 24, TFS(&tfs_yes_no), (1<<16),\n                            \"Reserved\", HFILL }\n            },\n\n            { &hf_usb_vid_proc_control_D[17],\n                    { \"Analog Video Lock Status\", \"usbvideo.processor.control.D17\",\n                            FT_BOOLEAN, 24, TFS(&tfs_yes_no), (1<<17),\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_proc_control_D[18],\n                    { \"Contrast, Auto\", \"usbvideo.processor.control.D18\",\n                            FT_BOOLEAN, 24, TFS(&tfs_yes_no), (1<<18),\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_proc_standards,\n                    { \"bmVideoStandards\", \"usbvideo.processor.standards\",\n                            FT_UINT8, BASE_HEX, NULL, 0,\n                            \"Supported analog video standards\", HFILL }\n            },\n\n            { &hf_usb_vid_proc_standards_D[0],\n                    { \"None\", \"usbvideo.processor.standards.D0\",\n                            FT_BOOLEAN, 8, TFS(&tfs_yes_no), (1<<0),\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_proc_standards_D[1],\n                    { \"NTSC - 525/60\", \"usbvideo.processor.standards.D1\",\n                            FT_BOOLEAN, 8, TFS(&tfs_yes_no), (1<<1),\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_proc_standards_D[2],\n                    { \"PAL - 625/50\", \"usbvideo.processor.standards.D2\",\n                            FT_BOOLEAN, 8, TFS(&tfs_yes_no), (1<<2),\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_proc_standards_D[3],\n                    { \"SECAM - 625/50\", \"usbvideo.processor.standards.D3\",\n                            FT_BOOLEAN, 8, TFS(&tfs_yes_no), (1<<3),\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_proc_standards_D[4],\n                    { \"NTSC - 625/50\", \"usbvideo.processor.standards.D4\",\n                            FT_BOOLEAN, 8, TFS(&tfs_yes_no), (1<<4),\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_proc_standards_D[5],\n                    { \"PAL - 525/60\", \"usbvideo.processor.standards.D5\",\n                            FT_BOOLEAN, 8, TFS(&tfs_yes_no), (1<<5),\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_max_multiplier,\n                    { \"wMaxMultiplier\", \"usbvideo.processor.maxMultiplier\",\n                            FT_UINT16, BASE_DEC, NULL, 0,\n                            \"100 x max digital multiplication\", HFILL }\n            },\n\n        /***** Selector Unit Descriptor *****/\n\n            { &hf_usb_vid_iSelector,\n                    { \"iSelector\", \"usbvideo.selector.name\", FT_UINT8, BASE_DEC, NULL, 0x0,\n                            \"String Descriptor describing this terminal\", HFILL }\n            },\n\n        /***** Extension Unit Descriptor *****/\n\n            { &hf_usb_vid_iExtension,\n                    { \"iExtension\", \"usbvideo.extension.name\", FT_UINT8, BASE_DEC, NULL, 0x0,\n                            \"String Descriptor describing this terminal\", HFILL }\n            },\n\n            { &hf_usb_vid_exten_guid,\n                    { \"guid\", \"usbvideo.extension.guid\",\n                            FT_GUID, BASE_NONE, NULL, 0,\n                            \"Identifier\", HFILL }\n            },\n\n            { &hf_usb_vid_exten_num_controls,\n                    { \"bNumControls\", \"usbvideo.extension.numControls\",\n                            FT_UINT8, BASE_DEC, NULL, 0,\n                            \"Number of controls\", HFILL }\n            },\n\n        /***** Probe/Commit *****/\n\n            { &hf_usb_vid_probe_hint,\n                    { \"bmHint\", \"usbvideo.probe.hint\",\n                            FT_UINT16, BASE_HEX, NULL, 0,\n                            \"Fields to hold constant during negotiation\", HFILL }\n            },\n\n            { &hf_usb_vid_probe_hint_D[0],\n                    { \"dwFrameInterval\", \"usbvideo.probe.hint.D0\",\n                            FT_BOOLEAN, 5, TFS(&probe_hint_meaning), (1<<0),\n                            \"Frame Rate\", HFILL }\n            },\n            { &hf_usb_vid_probe_hint_D[1],\n                    { \"wKeyFrameRate\", \"usbvideo.probe.hint.D1\",\n                            FT_BOOLEAN, 5, TFS(&probe_hint_meaning), (1<<1),\n                            \"Key Frame Rate\", HFILL }\n            },\n            { &hf_usb_vid_probe_hint_D[2],\n                    { \"wPFrameRate\", \"usbvideo.probe.hint.D2\",\n                            FT_BOOLEAN, 5, TFS(&probe_hint_meaning), (1<<2),\n                            \"P-Frame Rate\", HFILL }\n            },\n            { &hf_usb_vid_probe_hint_D[3],\n                    { \"wCompQuality\", \"usbvideo.probe.hint.D3\",\n                            FT_BOOLEAN, 5, TFS(&probe_hint_meaning), (1<<3),\n                            \"Compression Quality\", HFILL }\n            },\n            { &hf_usb_vid_probe_hint_D[4],\n                    { \"wCompWindowSize\", \"usbvideo.probe.hint.D4\",\n                            FT_BOOLEAN, 5, TFS(&probe_hint_meaning), (1<<4),\n                            \"Compression Window Size\", HFILL }\n            },\n\n            { &hf_usb_vid_probe_key_frame_rate,\n                    { \"wKeyFrameRate\", \"usbvideo.probe.keyFrameRate\",\n                            FT_UINT16, BASE_DEC, NULL, 0,\n                            \"Key frame rate\", HFILL }\n            },\n\n            { &hf_usb_vid_probe_p_frame_rate,\n                    { \"wPFrameRate\", \"usbvideo.probe.pFrameRate\",\n                            FT_UINT16, BASE_DEC, NULL, 0,\n                            \"P frame rate\", HFILL }\n            },\n\n            { &hf_usb_vid_probe_comp_quality,\n                    { \"wCompQuality\", \"usbvideo.probe.compQuality\",\n                            FT_UINT16, BASE_DEC, NULL, 0,\n                            \"Compression quality [0-10000]\", HFILL }\n            },\n\n            { &hf_usb_vid_probe_comp_window,\n                    { \"wCompWindow\", \"usbvideo.probe.compWindow\",\n                            FT_UINT16, BASE_DEC, NULL, 0,\n                            \"Window size for average bit rate control\", HFILL }\n            },\n            { &hf_usb_vid_probe_delay,\n                    { \"wDelay\", \"usbvideo.probe.delay\",\n                            FT_UINT16, BASE_DEC, NULL, 0,\n                            \"Latency in ms from capture to USB\", HFILL }\n            },\n            { &hf_usb_vid_probe_max_frame_sz,\n                    { \"dwMaxVideoFrameSize\", \"usbvideo.probe.maxVideoFrameSize\",\n                            FT_UINT32, BASE_DEC, NULL, 0,\n                            NULL, HFILL }\n            },\n            { &hf_usb_vid_probe_max_payload_sz,\n                    { \"dwMaxPayloadTransferSize\", \"usbvideo.probe.maxPayloadTransferSize\",\n                            FT_UINT32, BASE_DEC, NULL, 0,\n                            NULL, HFILL }\n            },\n            { &hf_usb_vid_probe_clock_freq,\n                    { \"dwClockFrequency\", \"usbvideo.probe.clockFrequency\",\n                            FT_UINT32, BASE_DEC, NULL, 0,\n                            \"Device clock frequency in Hz\", HFILL }\n            },\n\n            { &hf_usb_vid_probe_framing,\n                    { \"bmFramingInfo\", \"usbvideo.probe.framing\",\n                            FT_UINT16, BASE_HEX, NULL, 0,\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_probe_framing_D[0],\n                    { \"Frame ID required\", \"usbvideo.probe.framing.D0\",\n                            FT_BOOLEAN, 2, TFS(&tfs_yes_no), (1<<0),\n                            NULL, HFILL }\n            },\n            { &hf_usb_vid_probe_framing_D[1],\n                    { \"EOF utilized\", \"usbvideo.probe.framing.D1\",\n                            FT_BOOLEAN, 2, TFS(&tfs_yes_no), (1<<1),\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_probe_preferred_ver,\n                    { \"bPreferredVersion\", \"usbvideo.probe.preferredVersion\",\n                            FT_UINT8, BASE_DEC, NULL, 0,\n                            \"Preferred payload format version\", HFILL }\n            },\n            { &hf_usb_vid_probe_min_ver,\n                    { \"bMinVersion\", \"usbvideo.probe.minVersion\",\n                            FT_UINT8, BASE_DEC, NULL, 0,\n                            \"Min supported payload format version\", HFILL }\n            },\n            { &hf_usb_vid_probe_max_ver,\n                    { \"bPreferredVersion\", \"usbvideo.probe.maxVer\",\n                            FT_UINT8, BASE_DEC, NULL, 0,\n                            \"Max supported payload format version\", HFILL }\n            },\n\n            { &hf_usb_vid_control_ifdesc_dwClockFrequency,\n                    { \"dwClockFrequency\", \"usbvideo.probe.clockFrequency\",\n                            FT_UINT32, BASE_DEC, NULL, 0,\n                            \"Device clock frequency (Hz) for selected format\", HFILL }\n            },\n\n        /***** Format Descriptors *****/\n\n            { &hf_usb_vid_format_index,\n                    { \"bFormatIndex\", \"usbvideo.format.index\",\n                            FT_UINT8, BASE_DEC, NULL, 0,\n                            \"Index of this format descriptor\", HFILL }\n            },\n\n            { &hf_usb_vid_format_num_frame_descriptors,\n                    { \"bNumFrameDescriptors\", \"usbvideo.format.numFrameDescriptors\",\n                            FT_UINT8, BASE_DEC, NULL, 0,\n                            \"Number of frame descriptors for this format\", HFILL }\n            },\n\n            { &hf_usb_vid_format_guid,\n                    { \"guidFormat\", \"usbvideo.format.guid\",\n                            FT_GUID, BASE_NONE, NULL, 0,\n                            \"Stream encoding format\", HFILL }\n            },\n\n            { &hf_usb_vid_format_bits_per_pixel,\n                    { \"bBitsPerPixel\", \"usbvideo.format.bitsPerPixel\",\n                            FT_UINT8, BASE_DEC, NULL, 0,\n                            \"Bits per pixel\", HFILL }\n            },\n\n            { &hf_usb_vid_default_frame_index,\n                    { \"bDefaultFrameIndex\", \"usbvideo.format.defaultFrameIndex\",\n                            FT_UINT8, BASE_DEC, NULL, 0,\n                            \"Optimum frame index for this stream\", HFILL }\n            },\n\n            { &hf_usb_vid_aspect_ratio_x,\n                    { \"bAspectRatioX\", \"usbvideo.format.aspectRatioX\",\n                            FT_UINT8, BASE_DEC, NULL, 0,\n                            \"X dimension of picture aspect ratio\", HFILL }\n            },\n\n            { &hf_usb_vid_aspect_ratio_y,\n                    { \"bAspectRatioY\", \"usbvideo.format.aspectRatioY\",\n                            FT_UINT8, BASE_DEC, NULL, 0,\n                            \"Y dimension of picture aspect ratio\", HFILL }\n            },\n\n            { &hf_usb_vid_interlace_flags,\n                    { \"bmInterlaceFlags\", \"usbvideo.format.interlace\",\n                            FT_UINT8, BASE_HEX, NULL, 0x0,\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_is_interlaced,\n                    { \"Interlaced stream\", \"usbvideo.format.interlace.D0\",\n                            FT_BOOLEAN, 8, TFS(&is_interlaced_meaning), (1<<0),\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_interlaced_fields,\n                    { \"Fields per frame\", \"usbvideo.format.interlace.D1\",\n                            FT_BOOLEAN, 8, TFS(&interlaced_fields_meaning), (1<<1),\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_field_1_first,\n                    { \"Field 1 first\", \"usbvideo.format.interlace.D2\",\n                            FT_BOOLEAN, 8, TFS(&tfs_yes_no), (1<<2),\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_field_pattern,\n                    { \"Field pattern\", \"usbvideo.format.interlace.pattern\",\n                            FT_UINT8, BASE_DEC | BASE_EXT_STRING,\n                            &field_pattern_meaning_ext, (3<<4),\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_copy_protect,\n                    { \"bCopyProtect\", \"usbvideo.format.copyProtect\",\n                            FT_UINT8, BASE_DEC, VALS(copy_protect_meaning), 0,\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_variable_size,\n                    { \"Variable size\", \"usbvideo.format.variableSize\",\n                            FT_BOOLEAN, BASE_DEC, NULL, 0,\n                            NULL, HFILL }\n            },\n\n        /***** MJPEG Format Descriptor *****/\n\n            { &hf_usb_vid_mjpeg_flags,\n                    { \"bmFlags\", \"usbvideo.mjpeg.flags\",\n                            FT_UINT8, BASE_HEX, NULL, 0,\n                            \"Characteristics\", HFILL }\n            },\n\n            { &hf_usb_vid_mjpeg_fixed_samples,\n                    { \"Fixed size samples\", \"usbvideo.mjpeg.fixed_size\",\n                            FT_BOOLEAN, 8, TFS(&tfs_yes_no), (1<<0),\n                            NULL, HFILL }\n            },\n\n        /***** Frame Descriptors *****/\n\n            { &hf_usb_vid_frame_index,\n                    { \"bFrameIndex\", \"usbvideo.frame.index\",\n                            FT_UINT8, BASE_DEC, NULL, 0,\n                            \"Index of this frame descriptor\", HFILL }\n            },\n\n            { &hf_usb_vid_frame_capabilities,\n                    { \"bmCapabilities\", \"usbvideo.frame.capabilities\",\n                            FT_UINT8, BASE_HEX, NULL, 0,\n                            \"Capabilities\", HFILL }\n            },\n\n            { &hf_usb_vid_frame_stills_supported,\n                    { \"Still image\", \"usbvideo.frame.stills\",\n                            FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), (1<<0),\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_frame_interval,\n                    { \"dwFrameInterval\", \"usbvideo.frame.interval\",\n                            FT_UINT32, BASE_DEC, NULL, 0,\n                            \"Frame interval multiple of 100 ns\", HFILL }\n            },\n\n            { &hf_usb_vid_frame_fixed_frame_rate,\n                    { \"Fixed frame rate\", \"usbvideo.frame.fixedRate\",\n                            FT_BOOLEAN, 8, TFS(&tfs_yes_no), (1<<1),\n                            NULL, HFILL }\n            },\n            { &hf_usb_vid_frame_width,\n                    { \"wWidth\", \"usbvideo.frame.width\",\n                            FT_UINT16, BASE_DEC, NULL, 0,\n                            \"Width of frame in pixels\", HFILL }\n            },\n            { &hf_usb_vid_frame_height,\n                    { \"wHeight\", \"usbvideo.frame.height\",\n                            FT_UINT16, BASE_DEC, NULL, 0,\n                            \"Height of frame in pixels\", HFILL }\n            },\n            { &hf_usb_vid_frame_min_bit_rate,\n                    { \"dwMinBitRate\", \"usbvideo.frame.minBitRate\",\n                            FT_UINT32, BASE_DEC, NULL, 0,\n                            \"Minimum bit rate in bps\", HFILL }\n            },\n            { &hf_usb_vid_frame_max_bit_rate,\n                    { \"dwMaxBitRate\", \"usbvideo.frame.maxBitRate\",\n                            FT_UINT32, BASE_DEC, NULL, 0,\n                            \"Maximum bit rate in bps\", HFILL }\n            },\n\n            { &hf_usb_vid_frame_max_frame_sz,\n                    { \"dwMaxVideoFrameBufferSize\", \"usbvideo.frame.maxBuffer\",\n                            FT_UINT32, BASE_DEC, NULL, 0,\n                            \"Maximum bytes per frame\", HFILL }\n            },\n            { &hf_usb_vid_frame_default_interval,\n                    { \"dwDefaultFrameInterval\", \"usbvideo.frame.interval.default\",\n                            FT_UINT32, BASE_DEC, NULL, 0,\n                            \"Suggested default\", HFILL }\n            },\n\n            { &hf_usb_vid_frame_interval_type,\n                    { \"bFrameIntervalType\", \"usbvideo.frame.interval.type\",\n                            FT_UINT8, BASE_DEC, NULL, 0,\n                            \"Frame rate control (continuous/discrete)\", HFILL }\n            },\n\n            { &hf_usb_vid_frame_min_interval,\n                    { \"dwMinFrameInterval\", \"usbvideo.frame.interval.min\",\n                            FT_UINT32, BASE_DEC, NULL, 0,\n                            \"Shortest frame interval (* 100 ns)\", HFILL }\n            },\n\n            { &hf_usb_vid_frame_max_interval,\n                    { \"dwMaxFrameInterval\", \"usbvideo.frame.interval.max\",\n                            FT_UINT32, BASE_DEC, NULL, 0,\n                            \"Longest frame interval (* 100 ns)\", HFILL }\n            },\n            { &hf_usb_vid_frame_step_interval,\n                    { \"dwMinFrameInterval\", \"usbvideo.frame.interval.step\",\n                            FT_UINT32, BASE_DEC, NULL, 0,\n                            \"Granularity of frame interval (* 100 ns)\", HFILL }\n            },\n\n            { &hf_usb_vid_frame_bytes_per_line,\n                    { \"dwBytesPerLine\", \"usbvideo.frame.bytesPerLine\",\n                            FT_UINT32, BASE_DEC, NULL, 0,\n                            \"Fixed number of bytes per video line\", HFILL }\n            },\n\n        /***** Colorformat Descriptor *****/\n\n            { &hf_usb_vid_color_primaries,\n                    { \"bColorPrimaries\", \"usbvideo.color.primaries\",\n                            FT_UINT8, BASE_DEC | BASE_EXT_STRING,\n                            &color_primaries_meaning_ext, 0,\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_transfer_characteristics,\n                    { \"bTransferCharacteristics\", \"usbvideo.color.transferCharacteristics\",\n                            FT_UINT8, BASE_DEC | BASE_EXT_STRING,\n                            &color_transfer_characteristics_ext, 0,\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_matrix_coefficients,\n                    { \"bMatrixCoefficients\", \"usbvideo.color.matrixCoefficients\",\n                            FT_UINT8, BASE_DEC | BASE_EXT_STRING,\n                            &matrix_coefficients_meaning_ext, 0,\n                            NULL, HFILL }\n            },\n\n        /***** Video Control Header Descriptor *****/\n\n            { &hf_usb_vid_control_ifdesc_bcdUVC,\n                    { \"bcdUVC\", \"usbvideo.bcdUVC\",\n                            FT_UINT16, BASE_HEX, NULL, 0,\n                            \"Video Device Class Specification release number\", HFILL }\n            },\n\n            { &hf_usb_vid_control_ifdesc_bInCollection,\n                    { \"bInCollection\", \"usbvideo.numStreamingInterfaces\",\n                            FT_UINT8, BASE_DEC, NULL, 0,\n                            \"Number of VideoStreaming interfaces\", HFILL }\n            },\n\n            { &hf_usb_vid_control_ifdesc_baInterfaceNr,\n                    { \"baInterfaceNr\", \"usbvideo.streamingInterfaceNumbers\",\n                            FT_BYTES, BASE_NONE, NULL, 0,\n                            \"Interface numbers of VideoStreaming interfaces\", HFILL }},\n\n        /***** Video Streaming Input Header Descriptor *****/\n\n            { &hf_usb_vid_streaming_ifdesc_bNumFormats,\n                    { \"bNumFormats\", \"usbvideo.streaming.numFormats\",\n                            FT_UINT8, BASE_DEC, NULL, 0,\n                            \"Number of video payload format descriptors\", HFILL }\n            },\n\n            { &hf_usb_vid_streaming_bmInfo,\n                    { \"bmInfo\", \"usbvideo.streaming.info\",\n                            FT_UINT8, BASE_HEX, NULL, 0,\n                            \"Capabilities\", HFILL }\n            },\n\n            { &hf_usb_vid_streaming_info_D[0],\n                    { \"Dynamic Format Change\", \"usbvideo.streaming.info.D0\",\n                            FT_BOOLEAN, 8, TFS(&tfs_yes_no), (1<<0),\n                            \"Dynamic Format Change\", HFILL }\n            },\n\n            { &hf_usb_vid_streaming_control_D[0],\n                    { \"wKeyFrameRate\", \"usbvideo.streaming.control.D0\",\n                            FT_BOOLEAN, 6, TFS(&tfs_yes_no), (1<<0),\n                            \"Probe and Commit support\", HFILL }\n            },\n\n            { &hf_usb_vid_streaming_control_D[1],\n                    { \"wPFrameRate\", \"usbvideo.streaming.control.D1\",\n                            FT_BOOLEAN, 6, TFS(&tfs_yes_no), (1<<1),\n                            \"Probe and Commit support\", HFILL }\n            },\n\n            { &hf_usb_vid_streaming_control_D[2],\n                    { \"wCompQuality\", \"usbvideo.streaming.control.D2\",\n                            FT_BOOLEAN, 6, TFS(&tfs_yes_no), (1<<2),\n                            \"Probe and Commit support\", HFILL }\n            },\n\n            { &hf_usb_vid_streaming_control_D[3],\n                    { \"wCompWindowSize\", \"usbvideo.streaming.control.D3\",\n                            FT_BOOLEAN, 6, TFS(&tfs_yes_no), (1<<3),\n                            \"Probe and Commit support\", HFILL }\n            },\n\n            { &hf_usb_vid_streaming_control_D[4],\n                    { \"Generate Key Frame\", \"usbvideo.streaming.control.D4\",\n                            FT_BOOLEAN, 6, TFS(&tfs_yes_no), (1<<4),\n                            \"Probe and Commit support\", HFILL }\n            },\n\n            { &hf_usb_vid_streaming_control_D[5],\n                    { \"Update Frame Segment\", \"usbvideo.streaming.control.D5\",\n                            FT_BOOLEAN, 6, TFS(&tfs_yes_no), (1<<5),\n                            \"Probe and Commit support\", HFILL }\n            },\n\n            { &hf_usb_vid_streaming_terminal_link,\n                    { \"bTerminalLink\", \"usbvideo.streaming.terminalLink\", FT_UINT8, BASE_DEC, NULL, 0x0,\n                            \"Output terminal ID\", HFILL }\n            },\n\n            { &hf_usb_vid_streaming_still_capture_method,\n                    { \"bStillCaptureMethod\", \"usbvideo.streaming.stillCaptureMethod\",\n                            FT_UINT8, BASE_DEC | BASE_EXT_STRING,\n                            &vs_still_capture_methods_ext, 0,\n                            \"Method of Still Image Capture\", HFILL }\n            },\n\n            { &hf_usb_vid_streaming_trigger_support,\n                    { \"HW Triggering\", \"usbvideo.streaming.triggerSupport\",\n                            FT_BOOLEAN, BASE_DEC, TFS(&tfs_supported_not_supported), 0,\n                            \"Is HW triggering supported\", HFILL }\n            },\n\n            { &hf_usb_vid_streaming_trigger_usage,\n                    { \"bTriggerUsage\", \"usbvideo.streaming.triggerUsage\",\n                            FT_UINT8, BASE_DEC, VALS(vs_trigger_usage), 0,\n                            \"How host SW should respond to trigger\", HFILL }\n            },\n\n        /***** Interrupt URB *****/\n\n            { &hf_usb_vid_interrupt_bStatusType,\n                    { \"Status Type\", \"usbvideo.interrupt.statusType\",\n                            FT_UINT8, BASE_HEX, VALS(interrupt_status_types), 0xF,\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_interrupt_bAttribute,\n                    { \"Change Type\", \"usbvideo.interrupt.attribute\",\n                            FT_UINT8, BASE_HEX | BASE_EXT_STRING,\n                            &control_change_types_ext, 0,\n                            \"Type of control change\", HFILL }\n            },\n\n            { &hf_usb_vid_interrupt_bOriginator,\n                    { \"Originator\", \"usbvideo.interrupt.originator\",\n                            FT_UINT8, BASE_DEC, NULL, 0,\n                            \"ID of the entity that reports this interrupt\", HFILL }\n            },\n\n            { &hf_usb_vid_control_interrupt_bEvent,\n                    { \"Event\", \"usbvideo.interrupt.controlEvent\",\n                            FT_UINT8, BASE_HEX, VALS(control_interrupt_events), 0,\n                            \"Type of event\", HFILL }\n            },\n\n        /***** Video Control Endpoint Descriptor *****/\n\n            { &hf_usb_vid_epdesc_subtype,\n                    { \"Subtype\", \"usbvideo.ep.descriptorSubType\",\n                            FT_UINT8, BASE_DEC, VALS(vc_ep_descriptor_subtypes), 0,\n                            \"Descriptor Subtype\", HFILL }\n            },\n\n            { &hf_usb_vid_epdesc_max_transfer_sz,\n                    { \"wMaxTransferSize\", \"usbvideo.ep.maxInterruptSize\", FT_UINT16,\n                      BASE_DEC, NULL, 0x0, \"Max interrupt structure size\", HFILL }\n            },\n\n        /***** Fields used in multiple contexts *****/\n\n            { &hf_usb_vid_ifdesc_wTotalLength,\n                    { \"wTotalLength\", \"usbvideo.totalLength\",\n                            FT_UINT16, BASE_DEC, NULL, 0,\n                            \"Video interface descriptor size\", HFILL }\n            },\n\n            { &hf_usb_vid_bControlSize,\n                    { \"bControlSize\", \"usbvideo.bmcontrolSize\",\n                            FT_UINT8, BASE_DEC, NULL, 0,\n                            \"Size of bmControls field\", HFILL }\n            },\n\n            { &hf_usb_vid_bmControl,\n                    { \"bmControl\", \"usbvideo.availableControls\",\n                            FT_UINT32, BASE_HEX, NULL, 0,\n                            \"Available controls\", HFILL }\n            },\n\n            { &hf_usb_vid_bmControl_bytes,\n                    { \"bmControl\", \"usbvideo.availableControls.bytes\",\n                            FT_BYTES, BASE_NONE, NULL, 0,\n                            \"Available controls\", HFILL }\n            },\n\n            { &hf_usb_vid_control_ifdesc_src_id,\n                    { \"bSourceID\", \"usbvideo.sourceID\", FT_UINT8, BASE_DEC, NULL, 0x0,\n                            \"Entity to which this terminal/unit is connected\", HFILL }\n            },\n\n        /**********/\n\n            { &hf_usb_vid_control_ifdesc_subtype,\n                    { \"Subtype\", \"usbvideo.control.descriptorSubType\",\n                            FT_UINT8, BASE_DEC | BASE_EXT_STRING,\n                            &vc_if_descriptor_subtypes_ext, 0,\n                            \"Descriptor Subtype\", HFILL }\n            },\n\n            { &hf_usb_vid_streaming_ifdesc_subtype,\n                    { \"Subtype\", \"usbvideo.streaming.descriptorSubType\",\n                            FT_UINT8, BASE_DEC | BASE_EXT_STRING,\n                            &vs_if_descriptor_subtypes_ext, 0,\n                            \"Descriptor Subtype\", HFILL }\n            },\n\n            { &hf_usb_vid_descriptor_data,\n                    { \"Descriptor data\", \"usbvideo.descriptor_data\", FT_BYTES, BASE_NONE, NULL, 0x0,\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_control_data,\n                    { \"Control data\", \"usbvideo.control_data\", FT_BYTES, BASE_NONE, NULL, 0x0,\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_control_value,\n                    { \"Control value\", \"usbvideo.control_value\", FT_BYTES, BASE_NONE, NULL, 0x0,\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_value_data,\n                    { \"Value data\", \"usbvideo.value_data\", FT_BYTES, BASE_NONE, NULL, 0x0,\n                            NULL, HFILL }\n            },\n    };\n\n    static gint *usb_vid_subtrees[] = {\n            &ett_usb_vid,\n            &ett_descriptor_video_endpoint,\n            &ett_descriptor_video_control,\n            &ett_descriptor_video_streaming,\n            &ett_camera_controls,\n            &ett_processing_controls,\n            &ett_streaming_controls,\n            &ett_streaming_info,\n            &ett_interlace_flags,\n            &ett_frame_capability_flags,\n            &ett_mjpeg_flags,\n            &ett_video_probe,\n            &ett_probe_hint,\n            &ett_probe_framing,\n            &ett_video_standards,\n            &ett_control_capabilities\n    };\n\n    static ei_register_info ei[] = {\n        { &ei_usb_vid_subtype_unknown, { \"usbvideo.subtype.unknown\", PI_UNDECODED, PI_WARN, \"Unknown VC subtype\", EXPFILL }},\n        { &ei_usb_vid_bitmask_len, { \"usbvideo.bitmask_len_error\", PI_UNDECODED, PI_WARN, \"Only least-significant bytes decoded\", EXPFILL }},\n    };\n\n    expert_module_t* expert_usb_vid;\n\n    proto_usb_vid = proto_register_protocol(\"USB Video\", \"USBVIDEO\", \"usbvideo\");\n    proto_register_field_array(proto_usb_vid, hf, array_length(hf));\n    proto_register_subtree_array(usb_vid_subtrees, array_length(usb_vid_subtrees));\n    expert_usb_vid = expert_register_protocol(proto_usb_vid);\n    expert_register_field_array(expert_usb_vid, ei, array_length(ei));\n}\n\nvoid\nproto_reg_handoff_usb_vid(void)\n{\n    dissector_handle_t usb_vid_control_handle;\n    dissector_handle_t usb_vid_descriptor_handle;\n    dissector_handle_t usb_vid_interrupt_handle;\n\n    usb_vid_control_handle = create_dissector_handle(dissect_usb_vid_control, proto_usb_vid);\n    dissector_add_uint(\"usb.control\", IF_CLASS_VIDEO, usb_vid_control_handle);\n\n    usb_vid_descriptor_handle = create_dissector_handle(dissect_usb_vid_descriptor, proto_usb_vid);\n    dissector_add_uint(\"usb.descriptor\", IF_CLASS_VIDEO, usb_vid_descriptor_handle);\n\n    usb_vid_interrupt_handle = create_dissector_handle(dissect_usb_vid_interrupt, proto_usb_vid);\n    dissector_add_uint(\"usb.interrupt\", IF_CLASS_VIDEO, usb_vid_interrupt_handle);\n}\n/*\n * Editor modelines  -  http://www.wireshark.org/tools/modelines.html\n *\n * Local variables:\n * c-basic-offset: 4\n * tab-width: 8\n * indent-tabs-mode: nil\n * End:\n *\n * vi: set shiftwidth=4 tabstop=8 expandtab:\n * :indentSize=4:tabSize=8:noTabs=true:\n */\n", "code_before": "/* packet-usb-video.c\n *\n * Forked from packet-usb-masstorage.c 35224 2010-12-20 05:35:29Z guy\n * which was authored by Ronnie Sahlberg (2006)\n *\n * usb video dissector\n * Steven J. Magnani 2013\n *\n * SPDX-License-Identifier: GPL-2.0-or-later\n */\n\n#include \"config.h\"\n\n#include <epan/packet.h>\n#include <epan/expert.h>\n#include <epan/tfs.h>\n\n#include <wsutil/array.h>\n#include \"packet-usb.h\"\n\nvoid proto_register_usb_vid(void);\nvoid proto_reg_handoff_usb_vid(void);\n\n/* References are to sections in USB Video Class specifications -\n * specifically V1.5, but versions have tended to keep\n * the same numbering (as of this writing).\n *\n * http://www.usb.org/developers/devclass_docs/USB_Video_Class_1_5.zip\n */\n\n/* Table 2-1. Interrupt originators */\n#define INT_VIDEOCONTROL               1\n#define INT_VIDEOSTREAMING             2\n\n#define INT_ORIGINATOR_MASK            0xF\n\n/* Table 2-2. Video Control Status Packet bAttribute */\n#define CONTROL_CHANGE_VALUE           0x00\n#define CONTROL_CHANGE_INFO            0x01\n#define CONTROL_CHANGE_FAILURE         0x02\n#define CONTROL_CHANGE_MIN             0x03   /* UVC 1.5+ */\n#define CONTROL_CHANGE_MAX             0x04   /* UVC 1.5+ */\n\n\n/* A.2 Video Interface Subclass Codes */\n#define SC_UNDEFINED                   0\n#define SC_VIDEOCONTROL                1\n#define SC_VIDEOSTREAMING              2\n#define SC_VIDEO_INTERFACE_COLLECTION  3\n\n/* A.4. Video Class-Specific Descriptor Types */\n#define CS_INTERFACE       0x24\n#define CS_ENDPOINT        0x25\n\n/* A.5 Video Class-Specific VC Interface Descriptor Subtypes */\n#define VC_HEADER           1\n#define VC_INPUT_TERMINAL   2\n#define VC_OUTPUT_TERMINAL  3\n#define VC_SELECTOR_UNIT    4\n#define VC_PROCESSING_UNIT  5\n#define VC_EXTENSION_UNIT   6\n#define VC_ENCODING_UNIT    7\n\n/* A.6 Video Class-Specific VS Interface Descriptor Subtypes */\n#define VS_UNDEFINED             0x00\n#define VS_INPUT_HEADER          0x01\n#define VS_OUTPUT_HEADER         0x02\n#define VS_STILL_IMAGE_FRAME     0x03\n#define VS_FORMAT_UNCOMPRESSED   0x04\n#define VS_FRAME_UNCOMPRESSED    0x05\n#define VS_FORMAT_MJPEG          0x06\n#define VS_FRAME_MJPEG           0x07\n#define VS_FORMAT_MPEG1          0x08     /* Pre-UVC 1.1 */\n#define VS_FORMAT_MPEG2PS        0x09     /* Pre-UVC 1.1 */\n#define VS_FORMAT_MPEG2TS        0x0A\n#define VS_FORMAT_MPEG4SL        0x0B     /* Pre-UVC 1.1 */\n#define VS_FORMAT_DV             0x0C\n#define VS_COLORFORMAT           0x0D\n#define VS_FORMAT_VENDOR         0x0E     /* Pre-UVC 1.1 */\n#define VS_FRAME_VENDOR          0x0F     /* Pre-UVC 1.1 */\n#define VS_FORMAT_FRAME_BASED    0x10\n#define VS_FRAME_FRAME_BASED     0x11\n#define VS_FORMAT_STREAM_BASED   0x12\n#define VS_FORMAT_H264           0x13       /* UVC 1.5 */\n#define VS_FRAME_H264            0x14       /* UVC 1.5 */\n#define VS_FORMAT_H264_SIMULCAST 0x15       /* UVC 1.5 */\n#define VS_FORMAT_VP8            0x16       /* UVC 1.5 */\n#define VS_FRAME_VP8             0x17       /* UVC 1.5 */\n#define VS_FORMAT_VP8_SIMULCAST  0x18       /* UVC 1.5 */\n\n/* A.7 Video Class-Specific Endpoint Descriptor Subtypes */\n#define EP_INTERRUPT           0x03\n\n/* A.9.1 Video Control Interface Control Selectors */\n#define VC_CONTROL_UNDEFINED                      0x00\n#define VC_VIDEO_POWER_MODE_CONTROL               0x01\n#define VC_REQUEST_ERROR_CODE_CONTROL             0x02\n#define VC_REQUEST_INDICATE_HOST_CLOCK_CONTROL    0x03  /* Pre-UVC 1.1 */\n\n/* A.9.3 Selector Unit Control Selectors */\n#define SU_CONTROL_UNDEFINED                      0x00\n#define SU_INPUT_SELECT_CONTROL                   0x01\n\n/* A.9.4 Camera Terminal Control Selectors */\n#define CT_CONTROL_UNDEFINED                      0x00\n#define CT_SCANNING_MODE_CONTROL                  0x01\n#define CT_AE_MODE_CONTROL                        0x02\n#define CT_AE_PRIORITY_CONTROL                    0x03\n#define CT_EXPOSURE_TIME_ABSOLUTE_CONTROL         0x04\n#define CT_EXPOSURE_TIME_RELATIVE_CONTROL         0x05\n#define CT_FOCUS_ABSOLUTE_CONTROL                 0x06\n#define CT_FOCUS_RELATIVE_CONTROL                 0x07\n#define CT_FOCUS_AUTO_CONTROL                     0x08\n#define CT_IRIS_ABSOLUTE_CONTROL                  0x09\n#define CT_IRIS_RELATIVE_CONTROL                  0x0A\n#define CT_ZOOM_ABSOLUTE_CONTROL                  0x0B\n#define CT_ZOOM_RELATIVE_CONTROL                  0x0C\n#define CT_PANTILT_ABSOLUTE_CONTROL               0x0D\n#define CT_PANTILT_RELATIVE_CONTROL               0x0E\n#define CT_ROLL_ABSOLUTE_CONTROL                  0x0F\n#define CT_ROLL_RELATIVE_CONTROL                  0x10\n#define CT_PRIVACY_CONTROL                        0x11\n#define CT_FOCUS_SIMPLE_CONTROL                   0x12  /* UVC 1.5 */\n#define CT_WINDOW_CONTROL                         0x13  /* UVC 1.5 */\n#define CT_REGION_OF_INTEREST_CONTROL             0x14  /* UVC 1.5 */\n\n/* A.9.5 Processing Unit Control Selectors */\n#define PU_CONTROL_UNDEFINED                      0x00\n#define PU_BACKLIGHT_COMPENSATION_CONTROL         0x01\n#define PU_BRIGHTNESS_CONTROL                     0x02\n#define PU_CONTRAST_CONTROL                       0x03\n#define PU_GAIN_CONTROL                           0x04\n#define PU_POWER_LINE_FREQUENCY_CONTROL           0x05\n#define PU_HUE_CONTROL                            0x06\n#define PU_SATURATION_CONTROL                     0x07\n#define PU_SHARPNESS_CONTROL                      0x08\n#define PU_GAMMA_CONTROL                          0x09\n#define PU_WHITE_BALANCE_TEMPERATURE_CONTROL      0x0A\n#define PU_WHITE_BALANCE_TEMPERATURE_AUTO_CONTROL 0x0B\n#define PU_WHITE_BALANCE_COMPONENT_CONTROL        0x0C\n#define PU_WHITE_BALANCE_COMPONENT_AUTO_CONTROL   0x0D\n#define PU_DIGITAL_MULTIPLIER_CONTROL             0x0E\n#define PU_DIGITAL_MULTIPLIER_LIMIT_CONTROL       0x0F\n#define PU_HUE_AUTO_CONTROL                       0x10\n#define PU_ANALOG_VIDEO_STANDARD_CONTROL          0x11\n#define PU_ANALOG_LOCK_STATUS_CONTROL             0x12\n#define PU_CONTRAST_AUTO_CONTROL                  0x13\n\n/* A.9.7 VideoStreaming Interface Control Selectors */\n#define VS_CONTROL_UNDEFINED                      0x00\n#define VS_PROBE_CONTROL                          0x01\n#define VS_COMMIT_CONTROL                         0x02\n#define VS_STILL_PROBE_CONTROL                    0x03\n#define VS_STILL_COMMIT_CONTROL                   0x04\n#define VS_STILL_IMAGE_TRIGGER_CONTROL            0x05\n#define VS_STREAM_ERROR_CODE_CONTROL              0x06\n#define VS_GENERATE_KEY_FRAME_CONTROL             0x07\n#define VS_UPDATE_FRAME_SEGMENT_CONTROL           0x08\n#define VS_SYNCH_DELAY_CONTROL                    0x09\n\n/* Appendix B Terminal Types */\n#define TT_VENDOR_SPECIFIC          0x100\n#define TT_STREAMING                0x101\n#define ITT_VENDOR_SPECIFIC         0x200\n#define ITT_CAMERA                  0x201\n#define ITT_MEDIA_TRANSPORT_INPUT   0x202\n#define OTT_VENDOR_SPECIFIC         0x300\n#define OTT_DISPLAY                 0x301\n#define OTT_MEDIA_TRANSPORT_OUTPUT  0x302\n#define EXTERNAL_VENDOR_SPECIFIC    0x400\n#define COMPOSITE_CONNECTOR         0x401\n#define SVIDEO_CONNECTOR            0x402\n#define COMPONENT_CONNECTOR         0x403\n\n/* Table 2-2 Status Packet Format (VideoControl Interface as the Originator) */\n#define CONTROL_INTERRUPT_EVENT_CONTROL_CHANGE  0\n\n/* Table 4-7 Request Error Code Control bRequestErrorCode */\n#define UVC_ERROR_NONE              0\n#define UVC_ERROR_NOT_READY         1\n#define UVC_ERROR_WRONG_STATE       2\n#define UVC_ERROR_POWER             3\n#define UVC_ERROR_OUT_OF_RANGE      4\n#define UVC_ERROR_INVALID_UNIT      5\n#define UVC_ERROR_INVALID_CONTROL   6\n#define UVC_ERROR_INVALID_REQUEST   7\n#define UVC_ERROR_INVALID_VALUE     8\n#define UVC_ERROR_UNKNOWN           255\n\n/* A.8 Video Class-Specific Request Codes */\n#define USB_SETUP_SET_CUR           0x01\n#define USB_SETUP_SET_CUR_ALL       0x11    /* UVC 1.5 */\n#define USB_SETUP_GET_CUR           0x81\n#define USB_SETUP_GET_MIN           0x82\n#define USB_SETUP_GET_MAX           0x83\n#define USB_SETUP_GET_RES           0x84\n#define USB_SETUP_GET_LEN           0x85\n#define USB_SETUP_GET_INFO          0x86\n#define USB_SETUP_GET_DEF           0x87\n#define USB_SETUP_GET_CUR_ALL       0x91    /* UVC 1.5 */\n#define USB_SETUP_GET_MIN_ALL       0x92    /* UVC 1.5 */\n#define USB_SETUP_GET_MAX_ALL       0x93    /* UVC 1.5 */\n#define USB_SETUP_GET_RES_ALL       0x94    /* UVC 1.5 */\n#define USB_SETUP_GET_DEF_ALL       0x97    /* UVC 1.5 */\n\n/* dissector handles */\nstatic dissector_handle_t usb_vid_control_handle;\nstatic dissector_handle_t usb_vid_descriptor_handle;\nstatic dissector_handle_t usb_vid_interrupt_handle;\n\n/* protocols and header fields */\nstatic int proto_usb_vid;\n\nstatic int hf_usb_vid_control_entity;\nstatic int hf_usb_vid_control_interface;\nstatic int hf_usb_vid_control_selector;\nstatic int hf_usb_vid_epdesc_subtype;\nstatic int hf_usb_vid_epdesc_max_transfer_sz;\nstatic int hf_usb_vid_control_ifdesc_subtype;\nstatic int hf_usb_vid_control_ifdesc_terminal_id;\nstatic int hf_usb_vid_control_ifdesc_terminal_type;\nstatic int hf_usb_vid_control_ifdesc_assoc_terminal;\nstatic int hf_usb_vid_streaming_ifdesc_subtype;\nstatic int hf_usb_vid_streaming_ifdesc_bNumFormats;\nstatic int hf_usb_vid_control_ifdesc_unit_id;\nstatic int hf_usb_vid_request;\nstatic int hf_usb_vid_length;\nstatic int hf_usb_vid_interrupt_bStatusType;\nstatic int hf_usb_vid_interrupt_bOriginator;\nstatic int hf_usb_vid_interrupt_bAttribute;\nstatic int hf_usb_vid_control_interrupt_bEvent;\nstatic int hf_usb_vid_control_ifdesc_bcdUVC;\nstatic int hf_usb_vid_ifdesc_wTotalLength;\nstatic int hf_usb_vid_control_ifdesc_dwClockFrequency;\nstatic int hf_usb_vid_control_ifdesc_bInCollection;\nstatic int hf_usb_vid_control_ifdesc_baInterfaceNr;\nstatic int hf_usb_vid_control_ifdesc_iTerminal;\nstatic int hf_usb_vid_control_ifdesc_src_id;\nstatic int hf_usb_vid_cam_objective_focal_len_min;\nstatic int hf_usb_vid_cam_objective_focal_len_max;\nstatic int hf_usb_vid_cam_ocular_focal_len;\nstatic int hf_usb_vid_bControlSize;\nstatic int hf_usb_vid_bmControl;\nstatic int hf_usb_vid_bmControl_bytes;\nstatic int hf_usb_vid_control_default;\nstatic int hf_usb_vid_control_min;\nstatic int hf_usb_vid_control_max;\nstatic int hf_usb_vid_control_res;\nstatic int hf_usb_vid_control_cur;\nstatic int hf_usb_vid_control_info;\nstatic int hf_usb_vid_control_info_D[7];\nstatic int hf_usb_vid_control_length;\nstatic int hf_usb_vid_cam_control_D[22];\nstatic int hf_usb_vid_proc_control_D[19];\nstatic int hf_usb_vid_proc_standards_D[6];\nstatic int hf_usb_vid_exten_guid;\nstatic int hf_usb_vid_exten_num_controls;\nstatic int hf_usb_vid_num_inputs;\nstatic int hf_usb_vid_sources;\nstatic int hf_usb_vid_streaming_bmInfo;\nstatic int hf_usb_vid_streaming_info_D[1];\nstatic int hf_usb_vid_streaming_terminal_link;\nstatic int hf_usb_vid_streaming_still_capture_method;\nstatic int hf_usb_vid_streaming_trigger_support;\nstatic int hf_usb_vid_streaming_trigger_usage;\nstatic int hf_usb_vid_streaming_control_D[6];\nstatic int hf_usb_vid_format_index;\nstatic int hf_usb_vid_format_num_frame_descriptors;\nstatic int hf_usb_vid_format_guid;\nstatic int hf_usb_vid_format_bits_per_pixel;\nstatic int hf_usb_vid_default_frame_index;\nstatic int hf_usb_vid_aspect_ratio_x;\nstatic int hf_usb_vid_aspect_ratio_y;\nstatic int hf_usb_vid_interlace_flags;\nstatic int hf_usb_vid_is_interlaced;\nstatic int hf_usb_vid_interlaced_fields;\nstatic int hf_usb_vid_field_1_first;\nstatic int hf_usb_vid_field_pattern;\nstatic int hf_usb_vid_copy_protect;\nstatic int hf_usb_vid_variable_size;\nstatic int hf_usb_vid_frame_index;\nstatic int hf_usb_vid_frame_capabilities;\nstatic int hf_usb_vid_frame_stills_supported;\nstatic int hf_usb_vid_frame_fixed_frame_rate;\nstatic int hf_usb_vid_frame_width;\nstatic int hf_usb_vid_frame_height;\nstatic int hf_usb_vid_frame_min_bit_rate;\nstatic int hf_usb_vid_frame_max_bit_rate;\nstatic int hf_usb_vid_frame_max_frame_sz;\nstatic int hf_usb_vid_frame_default_interval;\nstatic int hf_usb_vid_frame_bytes_per_line;\nstatic int hf_usb_vid_mjpeg_flags;\nstatic int hf_usb_vid_mjpeg_fixed_samples;\nstatic int hf_usb_vid_probe_hint;\nstatic int hf_usb_vid_probe_hint_D[5];\nstatic int hf_usb_vid_frame_interval;\nstatic int hf_usb_vid_probe_key_frame_rate;\nstatic int hf_usb_vid_probe_p_frame_rate;\nstatic int hf_usb_vid_probe_comp_quality;\nstatic int hf_usb_vid_probe_comp_window;\nstatic int hf_usb_vid_probe_delay;\nstatic int hf_usb_vid_probe_max_frame_sz;\nstatic int hf_usb_vid_probe_max_payload_sz;\nstatic int hf_usb_vid_probe_clock_freq;\nstatic int hf_usb_vid_probe_framing;\nstatic int hf_usb_vid_probe_framing_D[2];\nstatic int hf_usb_vid_probe_preferred_ver;\nstatic int hf_usb_vid_probe_min_ver;\nstatic int hf_usb_vid_probe_max_ver;\nstatic int hf_usb_vid_frame_interval_type;\nstatic int hf_usb_vid_frame_min_interval;\nstatic int hf_usb_vid_frame_max_interval;\nstatic int hf_usb_vid_frame_step_interval;\nstatic int hf_usb_vid_color_primaries;\nstatic int hf_usb_vid_transfer_characteristics;\nstatic int hf_usb_vid_matrix_coefficients;\nstatic int hf_usb_vid_max_multiplier;\nstatic int hf_usb_vid_iProcessing;\nstatic int hf_usb_vid_iExtension;\nstatic int hf_usb_vid_iSelector;\nstatic int hf_usb_vid_proc_standards;\nstatic int hf_usb_vid_request_error;\nstatic int hf_usb_vid_descriptor_data;\nstatic int hf_usb_vid_control_data;\nstatic int hf_usb_vid_control_value;\nstatic int hf_usb_vid_value_data;\n\n\n/* Subtrees */\nstatic int ett_usb_vid;\nstatic int ett_descriptor_video_endpoint;\nstatic int ett_descriptor_video_control;\nstatic int ett_descriptor_video_streaming;\nstatic int ett_camera_controls;\nstatic int ett_processing_controls;\nstatic int ett_streaming_controls;\nstatic int ett_streaming_info;\nstatic int ett_interlace_flags;\nstatic int ett_frame_capability_flags;\nstatic int ett_mjpeg_flags;\nstatic int ett_video_probe;\nstatic int ett_probe_hint;\nstatic int ett_probe_framing;\nstatic int ett_video_standards;\nstatic int ett_control_capabilities;\n\nstatic expert_field ei_usb_vid_subtype_unknown;\nstatic expert_field ei_usb_vid_bitmask_len;\n\n/* Lookup tables */\nstatic const value_string vc_ep_descriptor_subtypes[] = {\n    { EP_INTERRUPT, \"Interrupt\" },\n    { 0, NULL }\n};\n\nstatic const value_string vid_descriptor_type_vals[] = {\n    {CS_INTERFACE, \"video class interface\"},\n    {CS_ENDPOINT, \"video class endpoint\"},\n    {0,NULL}\n};\nstatic value_string_ext vid_descriptor_type_vals_ext =\n    VALUE_STRING_EXT_INIT(vid_descriptor_type_vals);\n\nstatic const value_string vc_if_descriptor_subtypes[] = {\n    { VC_HEADER,              \"Header\" },\n    { VC_INPUT_TERMINAL,      \"Input Terminal\" },\n    { VC_OUTPUT_TERMINAL,     \"Output Terminal\" },\n    { VC_SELECTOR_UNIT,       \"Selector Unit\" },\n    { VC_PROCESSING_UNIT,     \"Processing Unit\" },\n    { VC_EXTENSION_UNIT,      \"Extension Unit\" },\n    { VC_ENCODING_UNIT,       \"Encoding Unit\" },\n    { 0, NULL }\n};\nstatic value_string_ext vc_if_descriptor_subtypes_ext =\n    VALUE_STRING_EXT_INIT(vc_if_descriptor_subtypes);\n\nstatic const value_string cs_control_interface[] = {\n    { VC_CONTROL_UNDEFINED,          \"Undefined\" },\n    { VC_VIDEO_POWER_MODE_CONTROL,   \"Video Power Mode\" },\n    { VC_REQUEST_ERROR_CODE_CONTROL, \"Request Error Code\" },\n    { VC_REQUEST_INDICATE_HOST_CLOCK_CONTROL, \"Request Indicate Host Clock\" },\n    { 0, NULL }\n};\nstatic value_string_ext cs_control_interface_ext =\n    VALUE_STRING_EXT_INIT(cs_control_interface);\n\nstatic const value_string cs_streaming_interface[] = {\n    { VS_CONTROL_UNDEFINED,            \"Undefined\" },\n    { VS_PROBE_CONTROL,                \"Probe\" },\n    { VS_COMMIT_CONTROL,               \"Commit\" },\n    { VS_STILL_PROBE_CONTROL,          \"Still Probe\" },\n    { VS_STILL_COMMIT_CONTROL,         \"Still Commit\" },\n    { VS_STILL_IMAGE_TRIGGER_CONTROL,  \"Still Image Trigger\" },\n    { VS_STREAM_ERROR_CODE_CONTROL,    \"Stream Error Code\" },\n    { VS_GENERATE_KEY_FRAME_CONTROL,   \"Generate Key Frame\" },\n    { VS_UPDATE_FRAME_SEGMENT_CONTROL, \"Update Frame Segment\" },\n    { VS_SYNCH_DELAY_CONTROL,          \"Synch Delay\" },\n    { 0, NULL }\n};\nstatic value_string_ext cs_streaming_interface_ext =\n    VALUE_STRING_EXT_INIT(cs_streaming_interface);\n\nstatic const value_string cs_selector_unit[] = {\n    { SU_CONTROL_UNDEFINED,              \"Undefined\" },\n    { SU_INPUT_SELECT_CONTROL,           \"Input Select\" },\n    { 0, NULL }\n};\nstatic value_string_ext cs_selector_unit_ext =\n    VALUE_STRING_EXT_INIT(cs_selector_unit);\n\nstatic const value_string cs_camera_terminal[] = {\n    { CT_CONTROL_UNDEFINED,              \"Undefined\" },\n    { CT_SCANNING_MODE_CONTROL,          \"Scanning Mode\" },\n    { CT_AE_MODE_CONTROL,                \"Auto-Exposure Mode\" },\n    { CT_AE_PRIORITY_CONTROL,            \"Auto-Exposure Priority\" },\n    { CT_EXPOSURE_TIME_ABSOLUTE_CONTROL, \"Exposure Time (Absolute)\" },\n    { CT_EXPOSURE_TIME_RELATIVE_CONTROL, \"Exposure Time (Relative)\" },\n    { CT_FOCUS_ABSOLUTE_CONTROL,         \"Focus (Absolute)\" },\n    { CT_FOCUS_RELATIVE_CONTROL,         \"Focus (Relative)\" },\n    { CT_FOCUS_AUTO_CONTROL,             \"Focus, Auto\" },\n    { CT_IRIS_ABSOLUTE_CONTROL,          \"Iris (Absolute)\" },\n    { CT_IRIS_RELATIVE_CONTROL,          \"Iris (Relative)\" },\n    { CT_ZOOM_ABSOLUTE_CONTROL,          \"Zoom (Absolute)\" },\n    { CT_ZOOM_RELATIVE_CONTROL,          \"Zoom (Relative)\" },\n    { CT_PANTILT_ABSOLUTE_CONTROL,       \"PanTilt (Absolute)\" },\n    { CT_PANTILT_RELATIVE_CONTROL,       \"PanTilt (Relative)\" },\n    { CT_ROLL_ABSOLUTE_CONTROL,          \"Roll (Absolute)\" },\n    { CT_ROLL_RELATIVE_CONTROL,          \"Roll (Relative)\" },\n    { CT_PRIVACY_CONTROL,                \"Privacy\" },\n    { CT_FOCUS_SIMPLE_CONTROL,           \"Focus (Simple)\" },\n    { CT_WINDOW_CONTROL,                 \"Window\" },\n    { CT_REGION_OF_INTEREST_CONTROL,     \"Region of Interest\" },\n    { 0, NULL }\n};\nstatic value_string_ext cs_camera_terminal_ext =\n    VALUE_STRING_EXT_INIT(cs_camera_terminal);\n\nstatic const value_string cs_processing_unit[] = {\n    { PU_CONTROL_UNDEFINED,                     \"Undefined\" },\n    { PU_BACKLIGHT_COMPENSATION_CONTROL,        \"Backlight Compensation\" },\n    { PU_BRIGHTNESS_CONTROL,                    \"Brightness\" },\n    { PU_CONTRAST_CONTROL,                      \"Contrast\" },\n    { PU_GAIN_CONTROL,                          \"Gain\" },\n    { PU_POWER_LINE_FREQUENCY_CONTROL,          \"Power Line Frequency\" },\n    { PU_HUE_CONTROL,                           \"Hue\" },\n    { PU_SATURATION_CONTROL,                    \"Saturation\" },\n    { PU_SHARPNESS_CONTROL,                     \"Sharpness\" },\n    { PU_GAMMA_CONTROL,                         \"Gamma\" },\n    { PU_WHITE_BALANCE_TEMPERATURE_CONTROL,     \"White Balance Temperature\" },\n    { PU_WHITE_BALANCE_TEMPERATURE_AUTO_CONTROL,\"White Balance Temperature Auto\" },\n    { PU_WHITE_BALANCE_COMPONENT_CONTROL,       \"White Balance Component\" },\n    { PU_WHITE_BALANCE_COMPONENT_AUTO_CONTROL,  \"White Balance Component Auto\" },\n    { PU_DIGITAL_MULTIPLIER_CONTROL,            \"Digital Multiplier\" },\n    { PU_DIGITAL_MULTIPLIER_LIMIT_CONTROL,      \"Digital Multiplier Limit\" },\n    { PU_HUE_AUTO_CONTROL,                      \"Hue Auto\" },\n    { PU_ANALOG_VIDEO_STANDARD_CONTROL,         \"Video Standard\" },\n    { PU_ANALOG_LOCK_STATUS_CONTROL,            \"Analog Lock Status\" },\n    { PU_CONTRAST_AUTO_CONTROL,                 \"Contrast Auto\" },\n    { 0, NULL }\n};\nstatic value_string_ext cs_processing_unit_ext =\n    VALUE_STRING_EXT_INIT(cs_processing_unit);\n\nstatic const value_string vc_terminal_types[] = {\n    { TT_VENDOR_SPECIFIC,         \"Vendor Specific\", },\n    { TT_STREAMING,               \"Streaming\" },\n    { ITT_VENDOR_SPECIFIC,        \"Vendor Specific Input\" },\n    { ITT_CAMERA,                 \"Camera Input\" },\n    { ITT_MEDIA_TRANSPORT_INPUT,  \"Media Transport Input\" },\n    { OTT_VENDOR_SPECIFIC,        \"Vendor Specific Output\" },\n    { OTT_DISPLAY,                \"Display Output\" },\n    { OTT_MEDIA_TRANSPORT_OUTPUT, \"Media Transport Output\" },\n    { EXTERNAL_VENDOR_SPECIFIC,   \"Vendor Specific External\" },\n    { COMPOSITE_CONNECTOR,        \"Composite Connector\" },\n    { SVIDEO_CONNECTOR,           \"SVideo Connector\" },\n    { COMPONENT_CONNECTOR,        \"Component Connector\" },\n    { 0, NULL }\n};\nstatic value_string_ext vc_terminal_types_ext =\n    VALUE_STRING_EXT_INIT(vc_terminal_types);\n\nstatic const value_string vs_if_descriptor_subtypes[] = {\n    { VS_UNDEFINED,             \"Undefined\" },\n    { VS_INPUT_HEADER,          \"Input Header\" },\n    { VS_OUTPUT_HEADER,         \"Output Header\" },\n    { VS_STILL_IMAGE_FRAME,     \"Still Image Frame\" },\n    { VS_FORMAT_UNCOMPRESSED,   \"Format Uncompressed\" },\n    { VS_FRAME_UNCOMPRESSED,    \"Frame Uncompressed\" },\n    { VS_FORMAT_MJPEG,          \"Format MJPEG\" },\n    { VS_FRAME_MJPEG,           \"Frame MJPEG\" },\n    { VS_FORMAT_MPEG1,          \"Format MPEG1\" },\n    { VS_FORMAT_MPEG2PS,        \"Format MPEG2-PS\" },\n    { VS_FORMAT_MPEG2TS,        \"Format MPEG2-TS\" },\n    { VS_FORMAT_MPEG4SL,        \"Format MPEG4-SL\" },\n    { VS_FORMAT_DV,             \"Format DV\" },\n    { VS_COLORFORMAT,           \"Colorformat\" },\n    { VS_FORMAT_VENDOR,         \"Format Vendor\" },\n    { VS_FRAME_VENDOR,          \"Frame Vendor\" },\n    { VS_FORMAT_FRAME_BASED,    \"Format Frame-Based\" },\n    { VS_FRAME_FRAME_BASED,     \"Frame Frame-Based\" },\n    { VS_FORMAT_STREAM_BASED,   \"Format Stream Based\" },\n    { VS_FORMAT_H264,           \"Format H.264\" },\n    { VS_FRAME_H264,            \"Frame H.264\" },\n    { VS_FORMAT_H264_SIMULCAST, \"Format H.264 Simulcast\" },\n    { VS_FORMAT_VP8,            \"Format VP8\" },\n    { VS_FRAME_VP8,             \"Frame VP8\" },\n    { VS_FORMAT_VP8_SIMULCAST,  \"Format VP8 Simulcast\" },\n    { 0, NULL }\n};\nstatic value_string_ext vs_if_descriptor_subtypes_ext =\n    VALUE_STRING_EXT_INIT(vs_if_descriptor_subtypes);\n\nstatic const value_string interrupt_status_types[] = {\n    { INT_VIDEOCONTROL,       \"VideoControl Interface\"   },\n    { INT_VIDEOSTREAMING,     \"VideoStreaming Interface\" },\n    { 0, NULL }\n};\n\nstatic const value_string control_change_types[] = {\n    { CONTROL_CHANGE_VALUE,   \"Value\" },\n    { CONTROL_CHANGE_INFO,    \"Info\" },\n    { CONTROL_CHANGE_FAILURE, \"Failure\" },\n    { CONTROL_CHANGE_MIN,     \"Min\" },\n    { CONTROL_CHANGE_MAX,     \"Max\" },\n    { 0, NULL }\n};\nstatic value_string_ext control_change_types_ext =\n    VALUE_STRING_EXT_INIT(control_change_types);\n\nstatic const value_string control_interrupt_events[] = {\n    { CONTROL_INTERRUPT_EVENT_CONTROL_CHANGE,  \"Control Change\" },\n    { 0, NULL }\n};\n\n/* Table 3-13 VS Interface Input Header Descriptor - bStillCaptureMethod field */\nstatic const value_string vs_still_capture_methods[] = {\n    { 0,  \"None\" },\n    { 1,  \"Uninterrupted streaming\" },\n    { 2,  \"Suspended streaming\" },\n    { 3,  \"Dedicated pipe\" },\n    { 0, NULL }\n};\nstatic value_string_ext vs_still_capture_methods_ext =\n    VALUE_STRING_EXT_INIT(vs_still_capture_methods);\n\n/* Table 3-13 VS Interface Input Header Descriptor - bTriggerUsage field */\nstatic const value_string vs_trigger_usage[] = {\n    { 0,  \"Initiate still image capture\" },\n    { 1,  \"General purpose button event\" },\n    { 0, NULL }\n};\n\n/* bmInterlaceFlags for format descriptors */\nstatic const true_false_string is_interlaced_meaning = {\n    \"Interlaced\",\n    \"Non-interlaced\"\n};\n\n/* bmInterlaceFlags for format descriptors */\nstatic const true_false_string interlaced_fields_meaning = {\n    \"1 field\",\n    \"2 fields\"\n};\n\n/* bmInterlaceFlags for format descriptors */\nstatic const value_string field_pattern_meaning[] = {\n    { 0,  \"Field 1 only\" },\n    { 1,  \"Field 2 only\" },\n    { 2,  \"Regular pattern of fields 1 and 2\" },\n    { 3,  \"Random pattern of fields 1 and 2\" },\n    {0, NULL},\n};\nstatic value_string_ext field_pattern_meaning_ext =\n    VALUE_STRING_EXT_INIT(field_pattern_meaning);\n\n/* bCopyProtect for format descriptors */\nstatic const value_string copy_protect_meaning[] = {\n    { 0,  \"No restrictions\" },\n    { 1,  \"Restrict duplication\" },\n    {0, NULL},\n};\n\n/* Table 4-46 Video Probe and Commit Controls - bmHint field */\nstatic const true_false_string probe_hint_meaning = {\n    \"Constant\",\n    \"Variable\"\n};\n\n/* Table 3-19 Color Matching Descriptor - bColorPrimaries field */\nstatic const value_string color_primaries_meaning[] = {\n    { 0,  \"Unspecified\" },\n    { 1,  \"BT.709, sRGB\" },\n    { 2,  \"BT.470-2 (M)\" },\n    { 3,  \"BT.470-2 (B,G)\" },\n    { 4,  \"SMPTE 170M\" },\n    { 5,  \"SMPTE 240M\" },\n    {0, NULL},\n};\nstatic value_string_ext color_primaries_meaning_ext =\n    VALUE_STRING_EXT_INIT(color_primaries_meaning);\n\n/* Table 3-19 Color Matching Descriptor - bTransferCharacteristics field */\nstatic const value_string color_transfer_characteristics[] = {\n    { 0,  \"Unspecified\" },\n    { 1,  \"BT.709\" },\n    { 2,  \"BT.470-2 (M)\" },\n    { 3,  \"BT.470-2 (B,G)\" },\n    { 4,  \"SMPTE 170M\" },\n    { 5,  \"SMPTE 240M\" },\n    { 6,  \"Linear (V=Lc)\" },\n    { 7,  \"sRGB\" },\n    {0, NULL},\n};\nstatic value_string_ext color_transfer_characteristics_ext =\n    VALUE_STRING_EXT_INIT(color_transfer_characteristics);\n\n/* Table 3-19 Color Matching Descriptor - bMatrixCoefficients field */\nstatic const value_string matrix_coefficients_meaning[] = {\n    { 0,  \"Unspecified\" },\n    { 1,  \"BT.709\" },\n    { 2,  \"FCC\" },\n    { 3,  \"BT.470-2 (B,G)\" },\n    { 4,  \"SMPTE 170M (BT.601)\" },\n    { 5,  \"SMPTE 240M\" },\n    {0, NULL},\n};\nstatic value_string_ext matrix_coefficients_meaning_ext =\n    VALUE_STRING_EXT_INIT(matrix_coefficients_meaning);\n\nstatic const value_string request_error_codes[] = {\n    { UVC_ERROR_NONE,             \"No error\" },\n    { UVC_ERROR_NOT_READY,        \"Not ready\" },\n    { UVC_ERROR_WRONG_STATE,      \"Wrong state\" },\n    { UVC_ERROR_POWER,            \"Insufficient power\" } ,\n    { UVC_ERROR_OUT_OF_RANGE,     \"Out of range\" },\n    { UVC_ERROR_INVALID_UNIT,     \"Invalid unit\" },\n    { UVC_ERROR_INVALID_CONTROL,  \"Invalid control\" },\n    { UVC_ERROR_INVALID_REQUEST,  \"Invalid request\" },\n    { UVC_ERROR_INVALID_VALUE,    \"Invalid value within range\" },\n    { UVC_ERROR_UNKNOWN,          \"Unknown\" },\n    {0, NULL},\n};\nstatic value_string_ext request_error_codes_ext =\n    VALUE_STRING_EXT_INIT(request_error_codes);\n\n/* There is one such structure per terminal or unit per interface */\ntypedef struct\n{\n    uint8_t entityID;\n    uint8_t subtype;\n    uint16_t terminalType;\n} video_entity_t;\n\n/* video_entity_t's (units/terminals) associated with each video interface */\n/* There is one such structure for each video conversation (interface) */\ntypedef struct _video_conv_info_t {\n    wmem_tree_t* entities;      /* indexed by entity ID */\n} video_conv_info_t;\n\n/*****************************************************************************/\n/*                            UTILITY FUNCTIONS                              */\n/*****************************************************************************/\n\n/**\n * Dissector for variable-length bmControl bitmask / bControlSize pair.\n *\n * Creates an item for bControlSize, and a subtree for the bmControl bitmask.\n *\n * @param tree            protocol tree to be the parent of the bitmask subtree\n * @param tvb             the tv_buff with the (remaining) packet data\n * @param offset          where in tvb to find bControlSize field\n * @param ett_subtree     index of the subtree to use for this bitmask\n * @param bm_items        NULL-terminated array of pointers that lists all the fields\n *                        of the bitmask\n *\n * @return   offset within tvb at which dissection should continue\n */\nstatic int\ndissect_bmControl(proto_tree *tree, tvbuff_t *tvb, int offset,\n                  int ett_subtree, int * const *bm_items)\n{\n    uint8_t bm_size = 0;\n\n    bm_size = tvb_get_uint8(tvb, offset);\n    proto_tree_add_item(tree, hf_usb_vid_bControlSize, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    ++offset;\n\n    if (bm_size > 0)\n    {\n        proto_tree_add_bitmask_len(tree, tvb, offset, bm_size, hf_usb_vid_bmControl,\n                                   ett_subtree, bm_items, &ei_usb_vid_bitmask_len, ENC_LITTLE_ENDIAN);\n        offset += bm_size;\n    }\n\n    return offset;\n}\n\n/*****************************************************************************/\n/*                          VIDEO CONTROL DESCRIPTORS                        */\n/*****************************************************************************/\n\n/* Dissect a Camera Terminal descriptor */\nstatic int\ndissect_usb_video_camera_terminal(proto_tree *tree, tvbuff_t *tvb, int offset)\n{\n    static int * const control_bits[] = {\n        &hf_usb_vid_cam_control_D[0],\n        &hf_usb_vid_cam_control_D[1],\n        &hf_usb_vid_cam_control_D[2],\n        &hf_usb_vid_cam_control_D[3],\n        &hf_usb_vid_cam_control_D[4],\n        &hf_usb_vid_cam_control_D[5],\n        &hf_usb_vid_cam_control_D[6],\n        &hf_usb_vid_cam_control_D[7],\n        &hf_usb_vid_cam_control_D[8],\n        &hf_usb_vid_cam_control_D[9],\n        &hf_usb_vid_cam_control_D[10],\n        &hf_usb_vid_cam_control_D[11],\n        &hf_usb_vid_cam_control_D[12],\n        &hf_usb_vid_cam_control_D[13],\n        &hf_usb_vid_cam_control_D[14],\n        &hf_usb_vid_cam_control_D[15],\n        &hf_usb_vid_cam_control_D[16],\n        &hf_usb_vid_cam_control_D[17],\n        &hf_usb_vid_cam_control_D[18],\n        &hf_usb_vid_cam_control_D[19],\n        &hf_usb_vid_cam_control_D[20],\n        &hf_usb_vid_cam_control_D[21],\n        NULL\n    };\n\n    DISSECTOR_ASSERT(array_length(control_bits) == (1+array_length(hf_usb_vid_cam_control_D)));\n\n    proto_tree_add_item(tree, hf_usb_vid_cam_objective_focal_len_min,  tvb, offset, 2, ENC_LITTLE_ENDIAN);\n    offset += 2;\n    proto_tree_add_item(tree, hf_usb_vid_cam_objective_focal_len_max,  tvb, offset, 2, ENC_LITTLE_ENDIAN);\n    offset += 2;\n    proto_tree_add_item(tree, hf_usb_vid_cam_ocular_focal_len, tvb, offset, 2, ENC_LITTLE_ENDIAN);\n    offset += 2;\n\n    offset = dissect_bmControl(tree, tvb, offset, ett_camera_controls, control_bits);\n\n    return offset;\n}\n\n/* Dissect a Processing Unit descriptor */\nstatic int\ndissect_usb_video_processing_unit(proto_tree *tree, tvbuff_t *tvb, int offset)\n{\n    static int * const control_bits[] = {\n        &hf_usb_vid_proc_control_D[0],\n        &hf_usb_vid_proc_control_D[1],\n        &hf_usb_vid_proc_control_D[2],\n        &hf_usb_vid_proc_control_D[3],\n        &hf_usb_vid_proc_control_D[4],\n        &hf_usb_vid_proc_control_D[5],\n        &hf_usb_vid_proc_control_D[6],\n        &hf_usb_vid_proc_control_D[7],\n        &hf_usb_vid_proc_control_D[8],\n        &hf_usb_vid_proc_control_D[9],\n        &hf_usb_vid_proc_control_D[10],\n        &hf_usb_vid_proc_control_D[11],\n        &hf_usb_vid_proc_control_D[12],\n        &hf_usb_vid_proc_control_D[13],\n        &hf_usb_vid_proc_control_D[14],\n        &hf_usb_vid_proc_control_D[15],\n        &hf_usb_vid_proc_control_D[16],\n        &hf_usb_vid_proc_control_D[17],\n        &hf_usb_vid_proc_control_D[18],\n        NULL\n    };\n\n    DISSECTOR_ASSERT(array_length(control_bits) == (1+array_length(hf_usb_vid_proc_control_D)));\n\n    proto_tree_add_item(tree, hf_usb_vid_control_ifdesc_src_id, tvb, offset,   1, ENC_LITTLE_ENDIAN);\n    proto_tree_add_item(tree, hf_usb_vid_max_multiplier,        tvb, offset+1, 2, ENC_LITTLE_ENDIAN);\n    offset += 3;\n\n    offset = dissect_bmControl(tree, tvb, offset, ett_processing_controls, control_bits);\n\n    proto_tree_add_item(tree, hf_usb_vid_iProcessing, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    ++offset;\n\n    /* UVC 1.1 added bmVideoStandards */\n    if (tvb_reported_length_remaining(tvb, offset) > 0)\n    {\n        static int * const standard_bits[] = {\n            &hf_usb_vid_proc_standards_D[0],\n            &hf_usb_vid_proc_standards_D[1],\n            &hf_usb_vid_proc_standards_D[2],\n            &hf_usb_vid_proc_standards_D[3],\n            &hf_usb_vid_proc_standards_D[4],\n            &hf_usb_vid_proc_standards_D[5],\n            NULL\n        };\n\n        DISSECTOR_ASSERT(array_length(standard_bits) == (1+array_length(hf_usb_vid_proc_standards_D)));\n\n        proto_tree_add_bitmask(tree, tvb, offset, hf_usb_vid_proc_standards,\n                               ett_video_standards, standard_bits, ENC_NA);\n        ++offset;\n    }\n\n    return offset;\n}\n\n/* Dissect a Selector Unit descriptor */\nstatic int\ndissect_usb_video_selector_unit(proto_tree *tree, tvbuff_t *tvb, int offset)\n{\n    uint8_t num_inputs;\n\n    num_inputs = tvb_get_uint8(tvb, offset);\n    proto_tree_add_item(tree, hf_usb_vid_num_inputs, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    ++offset;\n\n    if (num_inputs > 0)\n    {\n        proto_tree_add_item(tree, hf_usb_vid_sources, tvb, offset, num_inputs, ENC_NA);\n        offset += num_inputs;\n    }\n\n    proto_tree_add_item(tree, hf_usb_vid_iSelector, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    ++offset;\n\n    return offset;\n}\n\n/* Dissect an Extension Unit descriptor */\nstatic int\ndissect_usb_video_extension_unit(proto_tree *tree, tvbuff_t *tvb, int offset)\n{\n    uint8_t num_inputs;\n    uint8_t control_size;\n\n    proto_tree_add_item(tree, hf_usb_vid_exten_guid,         tvb, offset,    16, ENC_LITTLE_ENDIAN);\n    proto_tree_add_item(tree, hf_usb_vid_exten_num_controls, tvb, offset+16,  1, ENC_LITTLE_ENDIAN);\n    offset += 17;\n\n    num_inputs = tvb_get_uint8(tvb, offset);\n    proto_tree_add_item(tree, hf_usb_vid_num_inputs,   tvb, offset,  1, ENC_LITTLE_ENDIAN);\n    ++offset;\n\n    if (num_inputs > 0)\n    {\n        proto_tree_add_item(tree, hf_usb_vid_sources, tvb, offset, num_inputs, ENC_NA);\n        offset += num_inputs;\n    }\n\n    control_size = tvb_get_uint8(tvb, offset);\n    proto_tree_add_item(tree, hf_usb_vid_bControlSize, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    ++offset;\n\n    if (control_size > 0)\n    {\n        if (control_size <= proto_registrar_get_length(hf_usb_vid_bmControl))\n        {\n            proto_tree_add_item(tree, hf_usb_vid_bmControl, tvb, offset, control_size,\n                                ENC_LITTLE_ENDIAN);\n        }\n        else\n        {\n            /* Too big to display as integer */\n            /* @todo Display as FT_BYTES with a big-endian disclaimer?\n             * See https://gitlab.com/wireshark/wireshark/-/issues/7933\n             */\n            proto_tree_add_bytes_format(tree, hf_usb_vid_bmControl_bytes, tvb, offset, control_size, NULL, \"bmControl\");\n        }\n        offset += control_size;\n    }\n\n    proto_tree_add_item(tree, hf_usb_vid_iExtension, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    ++offset;\n\n    return offset;\n}\n\n/**\n * Dissector for video class control interface descriptors\n *\n * @param parent_tree     the protocol tree to be the parent of the descriptor subtree\n * @param tvb             the tv_buff with the (remaining) packet data\n *                        On entry the gaze is set to the descriptor length field.\n * @param descriptor_len  Length of the descriptor to dissect\n * @param pinfo           Information associated with the packet being dissected\n *\n * @return   offset within tvb at which dissection should continue\n */\nstatic int\ndissect_usb_video_control_interface_descriptor(proto_tree *parent_tree, tvbuff_t *tvb,\n                                               uint8_t descriptor_len, packet_info *pinfo, urb_info_t *urb)\n{\n    video_conv_info_t *video_conv_info = NULL;\n    video_entity_t    *entity          = NULL;\n    proto_item *item          = NULL;\n    proto_item *subtype_item  = NULL;\n    proto_tree *tree          = NULL;\n    uint8_t     entity_id     = 0;\n    uint16_t    terminal_type = 0;\n    int         offset        = 0;\n    uint8_t     subtype;\n\n    subtype = tvb_get_uint8(tvb, offset+2);\n\n    if (parent_tree)\n    {\n        const char *subtype_str;\n\n        subtype_str = val_to_str_ext(pinfo->pool, subtype, &vc_if_descriptor_subtypes_ext, \"Unknown (0x%x)\");\n\n        tree = proto_tree_add_subtree_format(parent_tree, tvb, offset, descriptor_len,\n                                   ett_descriptor_video_control, &item, \"VIDEO CONTROL INTERFACE DESCRIPTOR [%s]\",\n                                   subtype_str);\n    }\n\n    /* Common fields */\n    dissect_usb_descriptor_header(tree, tvb, offset, &vid_descriptor_type_vals_ext);\n    subtype_item = proto_tree_add_item(tree, hf_usb_vid_control_ifdesc_subtype, tvb, offset+2, 1, ENC_LITTLE_ENDIAN);\n    offset += 3;\n\n    if (subtype == VC_HEADER)\n    {\n        uint8_t num_vs_interfaces;\n\n        proto_tree_add_item(tree, hf_usb_vid_control_ifdesc_bcdUVC,            tvb, offset,   2, ENC_LITTLE_ENDIAN);\n        proto_tree_add_item(tree, hf_usb_vid_ifdesc_wTotalLength,              tvb, offset+2, 2, ENC_LITTLE_ENDIAN);\n        proto_tree_add_item(tree, hf_usb_vid_control_ifdesc_dwClockFrequency,  tvb, offset+4, 4, ENC_LITTLE_ENDIAN);\n\n        num_vs_interfaces = tvb_get_uint8(tvb, offset+8);\n        proto_tree_add_item(tree, hf_usb_vid_control_ifdesc_bInCollection,     tvb, offset+8, 1, ENC_LITTLE_ENDIAN);\n\n        if (num_vs_interfaces > 0)\n        {\n            proto_tree_add_item(tree, hf_usb_vid_control_ifdesc_baInterfaceNr, tvb, offset+9, num_vs_interfaces, ENC_NA);\n        }\n\n        offset += 9 + num_vs_interfaces;\n    }\n    else if ((subtype == VC_INPUT_TERMINAL) || (subtype == VC_OUTPUT_TERMINAL))\n    {\n        /* Fields common to input and output terminals */\n        entity_id     = tvb_get_uint8(tvb, offset);\n        terminal_type = tvb_get_letohs(tvb, offset+1);\n\n        proto_tree_add_item(tree, hf_usb_vid_control_ifdesc_terminal_id,    tvb, offset,   1, ENC_LITTLE_ENDIAN);\n        proto_tree_add_item(tree, hf_usb_vid_control_ifdesc_terminal_type,  tvb, offset+1, 2, ENC_LITTLE_ENDIAN);\n        proto_tree_add_item(tree, hf_usb_vid_control_ifdesc_assoc_terminal, tvb, offset+3, 1, ENC_LITTLE_ENDIAN);\n        offset += 4;\n\n        if (subtype == VC_OUTPUT_TERMINAL)\n        {\n            proto_tree_add_item(tree, hf_usb_vid_control_ifdesc_src_id, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n            ++offset;\n        }\n\n        proto_tree_add_item(tree, hf_usb_vid_control_ifdesc_iTerminal, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n        ++offset;\n\n        if (subtype == VC_INPUT_TERMINAL)\n        {\n            if (terminal_type == ITT_CAMERA)\n            {\n                offset = dissect_usb_video_camera_terminal(tree, tvb, offset);\n            }\n            else if (terminal_type == ITT_MEDIA_TRANSPORT_INPUT)\n            {\n                /* @todo */\n            }\n        }\n\n        if (subtype == VC_OUTPUT_TERMINAL)\n        {\n            if (terminal_type == OTT_MEDIA_TRANSPORT_OUTPUT)\n            {\n                /* @todo */\n            }\n        }\n    }\n    else\n    {\n        /* Field common to extension / processing / selector / encoding units */\n        entity_id = tvb_get_uint8(tvb, offset);\n        proto_tree_add_item(tree, hf_usb_vid_control_ifdesc_unit_id, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n        ++offset;\n\n        if (subtype == VC_PROCESSING_UNIT)\n        {\n            offset = dissect_usb_video_processing_unit(tree, tvb, offset);\n        }\n        else if (subtype == VC_SELECTOR_UNIT)\n        {\n            offset = dissect_usb_video_selector_unit(tree, tvb, offset);\n        }\n        else if (subtype == VC_EXTENSION_UNIT)\n        {\n            offset = dissect_usb_video_extension_unit(tree, tvb, offset);\n        }\n        else if (subtype == VC_ENCODING_UNIT)\n        {\n            /* @todo UVC 1.5 */\n        }\n        else\n        {\n            expert_add_info_format(pinfo, subtype_item, &ei_usb_vid_subtype_unknown,\n                                   \"Unknown VC subtype %u\", subtype);\n        }\n    }\n\n    /* Soak up descriptor bytes beyond those we know how to dissect */\n    if (offset < descriptor_len)\n    {\n        proto_tree_add_item(tree, hf_usb_vid_descriptor_data, tvb, offset, descriptor_len-offset, ENC_NA);\n        /* offset = descriptor_len; */\n    }\n\n    if (entity_id != 0)\n        proto_item_append_text(item, \" (Entity %d)\", entity_id);\n\n    if (subtype != VC_HEADER && urb && urb->conv)\n    {\n        /* Switch to the usb_conv_info of the Video Control interface */\n        usb_conv_info_t *conv = get_usb_iface_conv_info(pinfo, urb->conv->interfaceNum);\n        video_conv_info = (video_conv_info_t *)conv->class_data;\n\n        if (!video_conv_info)\n        {\n            video_conv_info = wmem_new(wmem_file_scope(), video_conv_info_t);\n            video_conv_info->entities = wmem_tree_new(wmem_file_scope());\n            conv->class_data = video_conv_info;\n            conv->class_data_type = USB_CONV_VIDEO;\n        } else if (conv->class_data_type != USB_CONV_VIDEO) {\n            /* Stop dissection if another USB type is in the conversation */\n            return descriptor_len;\n        }\n\n        entity = (video_entity_t*) wmem_tree_lookup32(video_conv_info->entities, entity_id);\n        if (!entity)\n        {\n            entity = wmem_new(wmem_file_scope(), video_entity_t);\n            entity->entityID     = entity_id;\n            entity->subtype      = subtype;\n            entity->terminalType = terminal_type;\n\n            wmem_tree_insert32(video_conv_info->entities, entity_id, entity);\n        }\n    }\n\n    return descriptor_len;\n}\n\n/*****************************************************************************/\n/*                        VIDEO STREAMING DESCRIPTORS                        */\n/*****************************************************************************/\n\n/* Dissect a Video Streaming Input Header descriptor */\nstatic int\ndissect_usb_video_streaming_input_header(proto_tree *tree, tvbuff_t *tvb, int offset)\n{\n    uint8_t num_formats;\n    uint8_t bm_size;\n\n    static int * const info_bits[] = {\n        &hf_usb_vid_streaming_info_D[0],\n        NULL\n    };\n    static int * const control_bits[] = {\n        &hf_usb_vid_streaming_control_D[0],\n        &hf_usb_vid_streaming_control_D[1],\n        &hf_usb_vid_streaming_control_D[2],\n        &hf_usb_vid_streaming_control_D[3],\n        &hf_usb_vid_streaming_control_D[4],\n        &hf_usb_vid_streaming_control_D[5],\n        NULL\n    };\n\n    DISSECTOR_ASSERT(array_length(control_bits) == (1+array_length(hf_usb_vid_streaming_control_D)));\n\n    num_formats = tvb_get_uint8(tvb, offset);\n    proto_tree_add_item(tree, hf_usb_vid_streaming_ifdesc_bNumFormats, tvb, offset,   1, ENC_LITTLE_ENDIAN);\n    proto_tree_add_item(tree, hf_usb_vid_ifdesc_wTotalLength,          tvb, offset+1, 2, ENC_LITTLE_ENDIAN);\n    offset += 3;\n\n    dissect_usb_endpoint_address(tree, tvb, offset);\n    offset++;\n\n    proto_tree_add_bitmask(tree, tvb, offset, hf_usb_vid_streaming_bmInfo,\n                           ett_streaming_info, info_bits, ENC_NA);\n\n    proto_tree_add_item(tree, hf_usb_vid_streaming_terminal_link,        tvb, offset+1, 1, ENC_LITTLE_ENDIAN);\n    proto_tree_add_item(tree, hf_usb_vid_streaming_still_capture_method, tvb, offset+2, 1, ENC_LITTLE_ENDIAN);\n    offset += 3;\n\n    proto_tree_add_item(tree, hf_usb_vid_streaming_trigger_support,      tvb, offset,   1, ENC_NA);\n    if (tvb_get_uint8(tvb, offset) > 0)\n    {\n        proto_tree_add_item(tree, hf_usb_vid_streaming_trigger_usage,    tvb, offset+1, 1, ENC_LITTLE_ENDIAN);\n    }\n    else\n    {\n        proto_tree_add_uint_format_value(tree, hf_usb_vid_streaming_trigger_usage, tvb, offset+1, 1, 0, \"Not applicable\");\n    }\n\n    offset += 2;\n\n    /* NOTE: Can't use dissect_bmControl here because there's only one size\n     *       field for (potentially) multiple bmControl fields\n     */\n    bm_size = tvb_get_uint8(tvb, offset);\n    proto_tree_add_item(tree, hf_usb_vid_bControlSize, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    ++offset;\n\n    if (bm_size > 0)\n    {\n        uint8_t i;\n        for (i=0; i<num_formats; ++i)\n        {\n            proto_tree_add_bitmask_len(tree, tvb, offset, bm_size, hf_usb_vid_bmControl,\n                                       ett_streaming_controls, control_bits, &ei_usb_vid_bitmask_len,\n                                       ENC_LITTLE_ENDIAN);\n            offset += bm_size;\n        }\n    }\n\n    return offset;\n}\n\n/**\n * Dissect a known Video Payload Format descriptor.\n *\n * @param tree     protocol tree to which fields should be added\n * @param tvb      the tv_buff with the (remaining) packet data\n * @param offset   where in tvb to begin dissection.\n *                 On entry this refers to the bFormatIndex field.\n * @param subtype  Type of format descriptor, from the\n *                 bDescriptorSubtype field\n *\n * @return   offset within tvb at which dissection should continue\n */\nstatic int\ndissect_usb_video_format(proto_tree *tree, packet_info* pinfo, tvbuff_t *tvb, int offset,\n                         uint8_t subtype)\n{\n    static int * const interlace_bits[] = {\n        &hf_usb_vid_is_interlaced,\n        &hf_usb_vid_interlaced_fields,\n        &hf_usb_vid_field_1_first,\n        &hf_usb_vid_field_pattern,\n        NULL\n    };\n\n    proto_item *desc_item;\n    uint8_t format_index;\n\n    /* Augment the descriptor root item with the index of this descriptor */\n    format_index = tvb_get_uint8(tvb, offset);\n    desc_item = proto_tree_get_parent(tree);\n    proto_item_append_text(desc_item, \"  (Format %u)\", format_index);\n\n    proto_tree_add_item(tree, hf_usb_vid_format_index,                  tvb, offset,    1, ENC_LITTLE_ENDIAN);\n    proto_tree_add_item(tree, hf_usb_vid_format_num_frame_descriptors,  tvb, offset+1,  1, ENC_LITTLE_ENDIAN);\n    offset += 2;\n\n    if ((subtype == VS_FORMAT_UNCOMPRESSED) || (subtype == VS_FORMAT_FRAME_BASED))\n    {\n        /* Augment the descriptor root item with the format's four-character-code */\n        proto_item_append_text(desc_item, \": %s\", tvb_format_text(pinfo->pool, tvb, offset, 4));\n\n        proto_tree_add_item(tree, hf_usb_vid_format_guid, tvb, offset,   16, ENC_LITTLE_ENDIAN);\n        proto_tree_add_item(tree, hf_usb_vid_format_bits_per_pixel,        tvb, offset+16, 1, ENC_LITTLE_ENDIAN);\n        offset += 17;\n    }\n    else if (subtype == VS_FORMAT_MJPEG)\n    {\n        static int * const  flags[] = {\n            &hf_usb_vid_mjpeg_fixed_samples,\n            NULL\n        };\n\n        proto_tree_add_bitmask(tree, tvb, offset, hf_usb_vid_mjpeg_flags, ett_mjpeg_flags, flags, ENC_NA);\n        offset++;\n    }\n    else\n    {\n        /* We should only be called for known format descriptor subtypes */\n        DISSECTOR_ASSERT_NOT_REACHED();\n    }\n\n    proto_tree_add_item(tree, hf_usb_vid_default_frame_index, tvb, offset,   1, ENC_LITTLE_ENDIAN);\n    proto_tree_add_item(tree, hf_usb_vid_aspect_ratio_x,      tvb, offset+1, 1, ENC_LITTLE_ENDIAN);\n    proto_tree_add_item(tree, hf_usb_vid_aspect_ratio_y,      tvb, offset+2, 1, ENC_LITTLE_ENDIAN);\n    offset += 3;\n\n#if 0\n    /* @todo Display \"N/A\" if Camera Terminal does not support scanning mode control */\n    if (something)\n        proto_tree_add_uint_format_value(tree, hf_usb_vid_interlace_flags, tvb, offset, 1, tvb_get_uint8(tvb, offset), \"Not applicable\");\n#endif\n\n    proto_tree_add_bitmask(tree, tvb, offset, hf_usb_vid_interlace_flags,\n                                ett_interlace_flags, interlace_bits, ENC_NA);\n    offset++;\n\n    proto_tree_add_item(tree, hf_usb_vid_copy_protect, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    offset++;\n\n    if (subtype == VS_FORMAT_FRAME_BASED)\n    {\n        proto_tree_add_item(tree, hf_usb_vid_variable_size, tvb, offset, 1, ENC_NA);\n        offset++;\n    }\n\n    return offset;\n}\n\n/**\n * Dissect a known Video Frame descriptor.\n *\n * @param tree     protocol tree to which fields should be added\n * @param tvb      the tv_buff with the (remaining) packet data\n * @param offset   where in tvb to begin dissection.\n *                 On entry this refers to the bFrameIndex field.\n * @param subtype  Type of frame descriptor, from the\n *                 bDescriptorSubtype field\n *\n * @return   offset within tvb at which dissection should continue\n */\nstatic int\ndissect_usb_video_frame(proto_tree *tree, tvbuff_t *tvb, int offset,\n                        uint8_t subtype)\n{\n    static int * const capability_bits[] = {\n        &hf_usb_vid_frame_stills_supported,\n        &hf_usb_vid_frame_fixed_frame_rate,\n        NULL\n    };\n    proto_item *desc_item;\n    uint8_t     bFrameIntervalType;\n    uint8_t     frame_index;\n    uint16_t    frame_width;\n    uint16_t    frame_height;\n\n    frame_index = tvb_get_uint8(tvb, offset);\n    proto_tree_add_item(tree, hf_usb_vid_frame_index, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    offset++;\n\n    proto_tree_add_bitmask(tree, tvb, offset, hf_usb_vid_frame_capabilities,\n                           ett_frame_capability_flags, capability_bits, ENC_NA);\n    offset++;\n\n    proto_tree_add_item(tree, hf_usb_vid_frame_width,        tvb, offset,    2, ENC_LITTLE_ENDIAN);\n    proto_tree_add_item(tree, hf_usb_vid_frame_height,       tvb, offset+2,  2, ENC_LITTLE_ENDIAN);\n\n    /* Augment the descriptor root item with useful information */\n    frame_width = tvb_get_letohs(tvb, offset);\n    frame_height = tvb_get_letohs(tvb, offset+2);\n    desc_item = proto_tree_get_parent(tree);\n    proto_item_append_text(desc_item, \"   (Index %2u): %4u x %4u\", frame_index, frame_width, frame_height);\n\n    proto_tree_add_item(tree, hf_usb_vid_frame_min_bit_rate, tvb, offset+4,  4, ENC_LITTLE_ENDIAN);\n    proto_tree_add_item(tree, hf_usb_vid_frame_max_bit_rate, tvb, offset+8,  4, ENC_LITTLE_ENDIAN);\n    offset += 12;\n\n    if (subtype != VS_FRAME_FRAME_BASED)\n    {\n        proto_tree_add_item(tree, hf_usb_vid_frame_max_frame_sz, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n        offset += 4;\n    }\n\n    proto_tree_add_item(tree, hf_usb_vid_frame_default_interval, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n    offset += 4;\n\n    bFrameIntervalType = tvb_get_uint8(tvb, offset);\n    if (bFrameIntervalType == 0)\n    {\n        proto_tree_add_uint_format_value(tree, hf_usb_vid_frame_interval_type, tvb, offset, 1,\n                                         bFrameIntervalType, \"Continuous (0)\");\n        offset++;\n\n        if (subtype == VS_FRAME_FRAME_BASED)\n        {\n            proto_tree_add_item(tree, hf_usb_vid_frame_bytes_per_line, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n            offset += 4;\n        }\n\n        proto_tree_add_item(tree, hf_usb_vid_frame_min_interval,  tvb, offset,   4, ENC_LITTLE_ENDIAN);\n        proto_tree_add_item(tree, hf_usb_vid_frame_max_interval,  tvb, offset+4, 4, ENC_LITTLE_ENDIAN);\n        proto_tree_add_item(tree, hf_usb_vid_frame_step_interval, tvb, offset+8, 4, ENC_LITTLE_ENDIAN);\n        offset += 12;\n    }\n    else\n    {\n        uint8_t i;\n        proto_tree_add_uint_format_value(tree, hf_usb_vid_frame_interval_type, tvb, offset, 1,\n                                         bFrameIntervalType, \"Discrete (%u choice%s)\",\n                                         bFrameIntervalType, (bFrameIntervalType > 1) ? \"s\" : \"\");\n        offset++;\n\n        if (subtype == VS_FRAME_FRAME_BASED)\n        {\n            proto_tree_add_item(tree, hf_usb_vid_frame_bytes_per_line, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n            offset += 4;\n        }\n\n        for (i=0; i<bFrameIntervalType; ++i)\n        {\n            proto_tree_add_item(tree, hf_usb_vid_frame_interval,  tvb, offset, 4, ENC_LITTLE_ENDIAN);\n            offset += 4;\n        }\n    }\n\n    return offset;\n}\n\n/* Dissect a Color Matching descriptor */\nstatic int\ndissect_usb_video_colorformat(proto_tree *tree, tvbuff_t *tvb, int offset)\n{\n    proto_tree_add_item(tree, hf_usb_vid_color_primaries,          tvb, offset,   1, ENC_LITTLE_ENDIAN);\n    proto_tree_add_item(tree, hf_usb_vid_transfer_characteristics, tvb, offset+1, 1, ENC_LITTLE_ENDIAN);\n    proto_tree_add_item(tree, hf_usb_vid_matrix_coefficients,      tvb, offset+2, 1, ENC_LITTLE_ENDIAN);\n    offset +=3;\n\n    return offset;\n}\n\n/**\n * Dissector for video class streaming interface descriptors.\n *\n * @param parent_tree     the protocol tree to be the parent of the descriptor subtree\n * @param tvb             the tv_buff with the (remaining) packet data\n *                        On entry the gaze is set to the descriptor length field.\n * @param descriptor_len  Length of the descriptor to dissect\n *\n * @return   offset within tvb at which dissection should continue\n */\nstatic int\ndissect_usb_video_streaming_interface_descriptor(proto_tree *parent_tree, packet_info* pinfo, tvbuff_t *tvb,\n                                                 uint8_t descriptor_len)\n{\n    proto_tree  *tree;\n    int          offset = 0;\n    const char *subtype_str;\n    uint8_t      subtype;\n\n    subtype = tvb_get_uint8(tvb, offset+2);\n\n    subtype_str = val_to_str_ext(pinfo->pool, subtype, &vs_if_descriptor_subtypes_ext, \"Unknown (0x%x)\");\n    tree = proto_tree_add_subtree_format(parent_tree, tvb, offset, descriptor_len,\n            ett_descriptor_video_streaming, NULL, \"VIDEO STREAMING INTERFACE DESCRIPTOR [%s]\",\n            subtype_str);\n\n    dissect_usb_descriptor_header(tree, tvb, offset, &vid_descriptor_type_vals_ext);\n    proto_tree_add_item(tree, hf_usb_vid_streaming_ifdesc_subtype, tvb, offset+2, 1, ENC_LITTLE_ENDIAN);\n    offset += 3;\n\n    switch (subtype)\n    {\n        case VS_INPUT_HEADER:\n            offset = dissect_usb_video_streaming_input_header(tree, tvb, offset);\n            break;\n\n        case VS_FORMAT_UNCOMPRESSED:\n        case VS_FORMAT_MJPEG:\n        case VS_FORMAT_FRAME_BASED:\n            offset = dissect_usb_video_format(tree, pinfo, tvb, offset, subtype);\n            break;\n\n        /* @todo MPEG2, H.264, VP8, Still Image Frame */\n        /* @todo Obsolete UVC-1.0 descriptors? */\n\n        case VS_FRAME_UNCOMPRESSED:\n        case VS_FRAME_MJPEG:\n        case VS_FRAME_FRAME_BASED:\n            offset = dissect_usb_video_frame(tree, tvb, offset, subtype);\n            break;\n\n        case VS_COLORFORMAT:\n            offset = dissect_usb_video_colorformat(tree, tvb, offset);\n            break;\n\n        default:\n            break;\n    }\n\n    /* Soak up descriptor bytes beyond those we know how to dissect */\n    if (offset < descriptor_len)\n        proto_tree_add_item(tree, hf_usb_vid_descriptor_data, tvb, offset, descriptor_len-offset, ENC_NA);\n\n    return descriptor_len;\n}\n\n/*****************************************************************************/\n\n/**\n * Dissector for video class-specific endpoint descriptor.\n *\n * @param parent_tree     the protocol tree to be the parent of the descriptor subtree\n * @param tvb             the tv_buff with the (remaining) packet data\n *                        On entry the gaze is set to the descriptor length field.\n * @param descriptor_len  Length of the descriptor to dissect\n *\n * @return   offset within tvb at which dissection should continue\n */\nstatic int\ndissect_usb_video_endpoint_descriptor(proto_tree *parent_tree, packet_info* pinfo, tvbuff_t *tvb,\n                                      uint8_t descriptor_len)\n{\n    proto_tree *tree   = NULL;\n    int         offset = 0;\n    uint8_t     subtype;\n\n    subtype = tvb_get_uint8(tvb, offset+2);\n\n    if (parent_tree)\n    {\n        const char* subtype_str;\n\n        subtype_str = val_to_str_wmem(pinfo->pool, subtype, vc_ep_descriptor_subtypes, \"Unknown (0x%x)\");\n        tree = proto_tree_add_subtree_format(parent_tree, tvb, offset, descriptor_len,\n                ett_descriptor_video_endpoint, NULL, \"VIDEO CONTROL ENDPOINT DESCRIPTOR [%s]\",\n                subtype_str);\n    }\n\n    dissect_usb_descriptor_header(tree, tvb, offset, &vid_descriptor_type_vals_ext);\n    proto_tree_add_item(tree, hf_usb_vid_epdesc_subtype, tvb, offset+2, 1, ENC_LITTLE_ENDIAN);\n    offset += 3;\n\n    if (subtype == EP_INTERRUPT)\n    {\n        proto_tree_add_item(tree, hf_usb_vid_epdesc_max_transfer_sz, tvb, offset, 2, ENC_LITTLE_ENDIAN);\n        offset += 2;\n    }\n\n    /* Soak up descriptor bytes beyond those we know how to dissect */\n    if (offset < descriptor_len)\n        proto_tree_add_item(tree, hf_usb_vid_descriptor_data, tvb, offset, descriptor_len-offset, ENC_NA);\n\n    return descriptor_len;\n}\n\n/**\n * Registered dissector for video class-specific descriptors\n *\n * @param tvb    the tv_buff with the (remaining) packet data\n *               On entry the gaze is set to the descriptor length field.\n * @param pinfo  the packet info of this packet (additional info)\n * @param tree   the protocol tree to be built or NULL\n * @param data   Not used\n *\n * @return   0   no class specific dissector was found\n * @return  <0   not enough data\n * @return  >0   amount of data in the descriptor\n */\nstatic int\ndissect_usb_vid_descriptor(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)\n{\n    int    offset = 0;\n    uint8_t descriptor_len;\n    uint8_t descriptor_type;\n    int    bytes_available;\n    urb_info_t  *urb = (urb_info_t *)data;\n\n    tvbuff_t         *desc_tvb;\n\n    descriptor_len  = tvb_get_uint8(tvb, offset);\n    descriptor_type = tvb_get_uint8(tvb, offset+1);\n\n    bytes_available = tvb_captured_length_remaining(tvb, offset);\n    desc_tvb = tvb_new_subset_length_caplen(tvb, 0, bytes_available, descriptor_len);\n\n    if (descriptor_type == CS_ENDPOINT)\n    {\n        offset = dissect_usb_video_endpoint_descriptor(tree, pinfo, desc_tvb, descriptor_len);\n    }\n    else if (descriptor_type == CS_INTERFACE)\n    {\n        if (urb && urb->conv && urb->conv->interfaceSubclass == SC_VIDEOCONTROL)\n        {\n            offset = dissect_usb_video_control_interface_descriptor(tree, desc_tvb,\n                                                                    descriptor_len,\n                                                                    pinfo, urb);\n        }\n        else if (urb && urb->conv && urb->conv->interfaceSubclass == SC_VIDEOSTREAMING)\n        {\n            offset = dissect_usb_video_streaming_interface_descriptor(tree, pinfo, desc_tvb,\n                                                                      descriptor_len);\n        }\n    }\n    /* else not something we recognize, just return offset = 0 */\n\n    return offset;\n}\n\n/*****************************************************************************/\n/*                            CONTROL TRANSFERS                              */\n/*****************************************************************************/\n\n/**\n * Dissect GET/SET transactions on the Video Probe and Commit controls.\n *\n * @param  parent_tree  protocol tree to which the probe/commit subtree should be added\n * @param  tvb          the tv_buff with the (remaining) packet data\n * @param  offset       where in tvb to begin dissection.\n *                      On entry this refers to the probe/commit bmHint field.\n *\n * @return offset within tvb at which dissection should continue\n */\nstatic int\ndissect_usb_vid_probe(proto_tree *parent_tree, tvbuff_t *tvb, int offset)\n{\n    proto_tree *tree;\n\n    static int * const hint_bits[] = {\n        &hf_usb_vid_probe_hint_D[0],\n        &hf_usb_vid_probe_hint_D[1],\n        &hf_usb_vid_probe_hint_D[2],\n        &hf_usb_vid_probe_hint_D[3],\n        &hf_usb_vid_probe_hint_D[4],\n        NULL\n    };\n\n    DISSECTOR_ASSERT(array_length(hint_bits) == (1+array_length(hf_usb_vid_probe_hint_D)));\n\n    tree = proto_tree_add_subtree(parent_tree, tvb, offset, -1, ett_video_probe, NULL, \"Probe/Commit Info\");\n\n    proto_tree_add_bitmask(tree, tvb, offset, hf_usb_vid_probe_hint,\n                           ett_probe_hint, hint_bits, ENC_LITTLE_ENDIAN);\n\n    proto_tree_add_item(tree, hf_usb_vid_format_index,         tvb, offset+2,  1, ENC_LITTLE_ENDIAN);\n    proto_tree_add_item(tree, hf_usb_vid_frame_index,          tvb, offset+3,  1, ENC_LITTLE_ENDIAN);\n    proto_tree_add_item(tree, hf_usb_vid_frame_interval,       tvb, offset+4,  4, ENC_LITTLE_ENDIAN);\n    proto_tree_add_item(tree, hf_usb_vid_probe_key_frame_rate, tvb, offset+8,  2, ENC_LITTLE_ENDIAN);\n    proto_tree_add_item(tree, hf_usb_vid_probe_p_frame_rate,   tvb, offset+10, 2, ENC_LITTLE_ENDIAN);\n    proto_tree_add_item(tree, hf_usb_vid_probe_comp_quality,   tvb, offset+12, 2, ENC_LITTLE_ENDIAN);\n    proto_tree_add_item(tree, hf_usb_vid_probe_comp_window,    tvb, offset+14, 2, ENC_LITTLE_ENDIAN);\n    proto_tree_add_item(tree, hf_usb_vid_probe_delay,          tvb, offset+16, 2, ENC_LITTLE_ENDIAN);\n    proto_tree_add_item(tree, hf_usb_vid_probe_max_frame_sz,   tvb, offset+18, 4, ENC_LITTLE_ENDIAN);\n    proto_tree_add_item(tree, hf_usb_vid_probe_max_payload_sz, tvb, offset+22, 4, ENC_LITTLE_ENDIAN);\n    offset += 26;\n\n    /* UVC 1.1 fields */\n    if (tvb_reported_length_remaining(tvb, offset) > 0)\n    {\n        static int * const framing_bits[] = {\n            &hf_usb_vid_probe_framing_D[0],\n            &hf_usb_vid_probe_framing_D[1],\n            NULL\n        };\n\n        DISSECTOR_ASSERT(array_length(framing_bits) == (1+array_length(hf_usb_vid_probe_framing_D)));\n\n        proto_tree_add_item(tree, hf_usb_vid_probe_clock_freq,     tvb, offset, 4, ENC_LITTLE_ENDIAN);\n        offset += 4;\n\n        proto_tree_add_bitmask(tree, tvb, offset, hf_usb_vid_probe_framing,\n                               ett_probe_framing, framing_bits, ENC_NA);\n        offset++;\n\n        proto_tree_add_item(tree, hf_usb_vid_probe_preferred_ver, tvb, offset,   1, ENC_LITTLE_ENDIAN);\n        proto_tree_add_item(tree, hf_usb_vid_probe_min_ver,       tvb, offset+1, 1, ENC_LITTLE_ENDIAN);\n        proto_tree_add_item(tree, hf_usb_vid_probe_max_ver,       tvb, offset+2, 1, ENC_LITTLE_ENDIAN);\n        offset += 3;\n    }\n\n    return offset;\n}\n\n/**\n * Fetch the table that describes known control selectors for the specified unit/terminal.\n *\n * @param  entity_id      Unit or terminal of interest\n * @param  usb_conv_info  Information about the interface the entity is part of\n *\n * @return Table describing control selectors for the specified entity (may be NULL)\n */\nstatic value_string_ext*\nget_control_selector_values(uint8_t entity_id, usb_conv_info_t *usb_conv_info)\n{\n    video_conv_info_t *video_conv_info;\n    video_entity_t    *entity = NULL;\n    value_string_ext  *selectors = NULL;\n\n    if (usb_conv_info == NULL || usb_conv_info->class_data_type != USB_CONV_VIDEO) {\n        return NULL;\n    }\n\n    video_conv_info = (video_conv_info_t *)usb_conv_info->class_data;\n    if (video_conv_info)\n        entity = (video_entity_t*) wmem_tree_lookup32(video_conv_info->entities, entity_id);\n\n    if (entity_id == 0)\n    {\n        /* Interface Request*/\n        switch (usb_conv_info->interfaceSubclass)\n        {\n            case SC_VIDEOCONTROL:\n                selectors = &cs_control_interface_ext;\n                break;\n\n            case SC_VIDEOSTREAMING:\n                selectors = &cs_streaming_interface_ext;\n                break;\n\n            default:\n                break;\n        }\n    }\n    else if (entity)\n    {\n        switch (entity->subtype)\n        {\n            case VC_INPUT_TERMINAL:\n                if (entity->terminalType == ITT_CAMERA)\n                {\n                    selectors = &cs_camera_terminal_ext;\n                }\n                break;\n\n            case VC_PROCESSING_UNIT:\n                selectors = &cs_processing_unit_ext;\n                break;\n\n            case VC_SELECTOR_UNIT:\n                selectors = &cs_selector_unit_ext;\n                break;\n\n            default:\n                break;\n        }\n    }\n\n    return selectors;\n}\n\n/**\n * Fetch the name of an entity's control.\n *\n * @param  entity_id      Unit or terminal of interest\n * @param  control_sel    Control of interest\n * @param  usb_conv_info  Information about the interface the entity is part of\n *\n * @return Table describing control selectors for the specified entity (may be NULL)\n */\nstatic const char*\nget_control_selector_name(uint8_t entity_id, uint8_t control_sel, usb_conv_info_t *usb_conv_info)\n{\n    const char       *control_name = NULL;\n    value_string_ext *selectors = NULL;\n\n    selectors = get_control_selector_values(entity_id, usb_conv_info);\n\n    if (selectors)\n        control_name = try_val_to_str_ext(control_sel, selectors);\n\n    return control_name;\n}\n\n/* Dissect the response to a GET INFO request */\nstatic int\ndissect_usb_vid_control_info(proto_tree *tree, tvbuff_t *tvb, int offset)\n{\n    static int * const capability_bits[] = {\n        &hf_usb_vid_control_info_D[0],\n        &hf_usb_vid_control_info_D[1],\n        &hf_usb_vid_control_info_D[2],\n        &hf_usb_vid_control_info_D[3],\n        &hf_usb_vid_control_info_D[4],\n        &hf_usb_vid_control_info_D[5],\n        &hf_usb_vid_control_info_D[6],\n        NULL\n    };\n\n    DISSECTOR_ASSERT(array_length(capability_bits) == (1+array_length(hf_usb_vid_control_info_D)));\n\n    proto_tree_add_bitmask(tree, tvb, offset, hf_usb_vid_control_info,\n                           ett_control_capabilities, capability_bits, ENC_NA);\n\n    return offset+1;\n}\n\n/* Dissect all remaining bytes in the tvb as a specified type of UVC value.\n * These are displayed as an unsigned integer where possible, otherwise just as\n * a text item.\n *\n * @param tree     the protocol tree to which an item will be added\n * @param tvb      the tv_buff with the (remaining) packet data\n * @param offset   How far into tvb the value data begins\n * @param request  Identifies type of value - either bRequest from a CONTROL\n *                 transfer (i.e., USB_SETUP_GET_MAX), or bValue from an\n *                 INTERRUPT transfer (i.e., CONTROL_CHANGE_MAX).\n */\nstatic void\ndissect_usb_vid_control_value(proto_tree *tree, tvbuff_t *tvb, int offset, uint8_t request)\n{\n    int         value_size;\n    const char *fallback_name;\n    int         hf;\n\n    switch (request)\n    {\n        case USB_SETUP_GET_DEF:\n            hf = hf_usb_vid_control_default;\n            fallback_name = \"Default Value\";\n            break;\n\n        case USB_SETUP_GET_MIN:\n        case CONTROL_CHANGE_MIN:\n            hf = hf_usb_vid_control_min;\n            fallback_name = \"Min Value\";\n            break;\n\n        case USB_SETUP_GET_MAX:\n        case CONTROL_CHANGE_MAX:\n            hf = hf_usb_vid_control_max;\n            fallback_name = \"Max Value\";\n            break;\n\n        case USB_SETUP_GET_RES:\n            hf = hf_usb_vid_control_res;\n            fallback_name = \"Resolution\";\n            break;\n\n        case USB_SETUP_GET_CUR:\n        case USB_SETUP_SET_CUR:\n        case CONTROL_CHANGE_VALUE:\n            hf = hf_usb_vid_control_cur;\n            fallback_name = \"Current Value\";\n            break;\n\n        /* @todo UVC 1.5 USB_SETUP_x_ALL?\n         *       They are poorly specified.\n         */\n\n        default:\n            hf = -1;\n            fallback_name = \"Value\";\n            break;\n    }\n\n    value_size = tvb_reported_length_remaining(tvb, offset);\n\n    if (hf != -1)\n    {\n        header_field_info *hfinfo;\n        hfinfo = proto_registrar_get_nth(hf);\n        DISSECTOR_ASSERT(FT_IS_INT(hfinfo->type) || FT_IS_UINT(hfinfo->type));\n    }\n\n    if ((hf != -1) && (value_size <= 4))\n    {\n        proto_tree_add_item(tree, hf, tvb, offset, value_size, ENC_LITTLE_ENDIAN);\n    }\n    else\n    {\n        /* @todo Display as FT_BYTES with a big-endian disclaimer?\n         * See https://gitlab.com/wireshark/wireshark/-/issues/7933\n         */\n        proto_tree_add_bytes_format(tree, hf_usb_vid_control_value, tvb, offset, value_size, NULL, \"%s\", fallback_name);\n    }\n}\n\n/**\n * Dissect video class GET/SET transactions.\n *\n * @param  pinfo           Information associated with the packet being dissected\n * @param  tree            protocol tree to which fields should be added\n * @param  tvb             the tv_buff with the (remaining) packet data\n * @param  offset          where in tvb to begin dissection.\n *                         On entry this refers to the bRequest field of the SETUP\n *                         transaction.\n * @param  is_request      true if the packet is host-to-device,\n *                         false if device-to-host\n * @param  usb_trans_info  Information specific to this request/response pair\n * @param  urb             Information about the conversation with the host\n */\nstatic int\ndissect_usb_vid_get_set(packet_info *pinfo, proto_tree *tree, tvbuff_t *tvb,\n                        int offset, bool is_request,\n                        usb_trans_info_t *usb_trans_info,\n                        urb_info_t *urb)\n{\n    const char *short_name = NULL;\n    uint8_t      control_sel;\n    uint8_t      entity_id;\n\n    entity_id   = usb_trans_info->setup.wIndex >> 8;\n    control_sel = usb_trans_info->setup.wValue >> 8;\n\n    /* Display something informative in the INFO column */\n    col_append_str(pinfo->cinfo, COL_INFO, \" [\");\n    short_name = get_control_selector_name(entity_id, control_sel, urb->conv);\n\n    if (short_name)\n        col_append_str(pinfo->cinfo, COL_INFO, short_name);\n    else\n    {\n        short_name = \"Unknown\";\n\n        if (entity_id == 0)\n        {\n            col_append_fstr(pinfo->cinfo, COL_INFO, \"Interface %u control 0x%x\",\n                            urb->conv->interfaceNum, control_sel);\n        }\n        else\n        {\n            col_append_fstr(pinfo->cinfo, COL_INFO, \"Unit %u control 0x%x\",\n                            entity_id, control_sel);\n        }\n    }\n\n    col_append_str(pinfo->cinfo, COL_INFO, \"]\");\n    col_set_fence(pinfo->cinfo, COL_INFO);\n\n    /* Add information on request context,\n     * as GENERATED fields if not directly available (for filtering)\n     */\n    if (is_request)\n    {\n        /* Move gaze to control selector (MSB of wValue) */\n        offset++;\n        proto_tree_add_uint_format_value(tree, hf_usb_vid_control_selector, tvb,\n                                     offset, 1, control_sel, \"%s (0x%02x)\", short_name, control_sel);\n        offset++;\n\n        proto_tree_add_item(tree, hf_usb_vid_control_interface, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n        offset++;\n\n        proto_tree_add_item(tree, hf_usb_vid_control_entity, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n        offset++;\n\n        proto_tree_add_item(tree, hf_usb_vid_length, tvb, offset, 2, ENC_LITTLE_ENDIAN);\n        offset += 2;\n    }\n    else\n    {\n        proto_item *ti;\n\n        ti = proto_tree_add_uint(tree, hf_usb_vid_control_interface, tvb, 0, 0,\n                                 usb_trans_info->setup.wIndex & 0xFF);\n        proto_item_set_generated(ti);\n\n        ti = proto_tree_add_uint(tree, hf_usb_vid_control_entity, tvb, 0, 0, entity_id);\n        proto_item_set_generated(ti);\n\n        ti = proto_tree_add_uint_format_value(tree, hf_usb_vid_control_selector, tvb,\n                                     0, 0, control_sel, \"%s (0x%02x)\", short_name, control_sel);\n        proto_item_set_generated(ti);\n    }\n\n    if (!is_request || (usb_trans_info->setup.request == USB_SETUP_SET_CUR))\n    {\n        int value_size = tvb_reported_length_remaining(tvb, offset);\n\n        if (value_size != 0)\n        {\n            if ((entity_id == 0) && (urb->conv->interfaceSubclass == SC_VIDEOSTREAMING))\n            {\n                if ((control_sel == VS_PROBE_CONTROL) || (control_sel == VS_COMMIT_CONTROL))\n                {\n                    int old_offset = offset;\n                    offset = dissect_usb_vid_probe(tree, tvb, offset);\n                    value_size -= (offset - old_offset);\n                }\n            }\n            else\n            {\n                if (usb_trans_info->setup.request == USB_SETUP_GET_INFO)\n                {\n                    dissect_usb_vid_control_info(tree, tvb, offset);\n                    offset++;\n                    value_size--;\n                }\n                else if (usb_trans_info->setup.request == USB_SETUP_GET_LEN)\n                {\n                    proto_tree_add_item(tree, hf_usb_vid_control_length, tvb, offset, 2, ENC_LITTLE_ENDIAN);\n                    offset += 2;\n                    value_size -= 2;\n                }\n                else if (   (usb_trans_info->setup.request == USB_SETUP_GET_CUR)\n                         && (entity_id == 0)\n                         && (urb->conv->interfaceSubclass == SC_VIDEOCONTROL)\n                         && (control_sel == VC_REQUEST_ERROR_CODE_CONTROL))\n                {\n                    proto_tree_add_item(tree, hf_usb_vid_request_error, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n                    offset++;\n                    value_size--;\n                }\n                else\n                {\n                    dissect_usb_vid_control_value(tree, tvb, offset, usb_trans_info->setup.request);\n                    offset += value_size;\n                    value_size = 0;\n                }\n            }\n\n            if (value_size > 0)\n            {\n                proto_tree_add_item(tree, hf_usb_vid_control_data, tvb, offset, -1, ENC_NA);\n                offset += value_size;\n            }\n        }\n    }\n\n    return offset;\n}\n\n/* Table for dispatch of video class SETUP transactions based on bRequest.\n * At the moment this is overkill since the same function handles all defined\n * requests.\n */\ntypedef int (*usb_setup_dissector)(packet_info *pinfo, proto_tree *tree,\n        tvbuff_t *tvb, int offset,\n        bool is_request,\n        usb_trans_info_t *usb_trans_info,\n        urb_info_t *urb);\n\ntypedef struct _usb_setup_dissector_table_t\n{\n    uint8_t request;\n    usb_setup_dissector dissector;\n} usb_setup_dissector_table_t;\n\nstatic const usb_setup_dissector_table_t setup_dissectors[] = {\n        {USB_SETUP_SET_CUR,      dissect_usb_vid_get_set},\n        {USB_SETUP_SET_CUR_ALL,  dissect_usb_vid_get_set},\n        {USB_SETUP_GET_CUR,      dissect_usb_vid_get_set},\n        {USB_SETUP_GET_MIN,      dissect_usb_vid_get_set},\n        {USB_SETUP_GET_MAX,      dissect_usb_vid_get_set},\n        {USB_SETUP_GET_RES,      dissect_usb_vid_get_set},\n        {USB_SETUP_GET_LEN,      dissect_usb_vid_get_set},\n        {USB_SETUP_GET_INFO,     dissect_usb_vid_get_set},\n        {USB_SETUP_GET_DEF,      dissect_usb_vid_get_set},\n        {USB_SETUP_GET_CUR_ALL,  dissect_usb_vid_get_set},\n        {USB_SETUP_GET_MIN_ALL,  dissect_usb_vid_get_set},\n        {USB_SETUP_GET_MAX_ALL,  dissect_usb_vid_get_set},\n        {USB_SETUP_GET_RES_ALL,  dissect_usb_vid_get_set},\n        {0, NULL}\n};\n\nstatic const value_string setup_request_names_vals[] = {\n        {USB_SETUP_SET_CUR,      \"SET CUR\"},\n        {USB_SETUP_SET_CUR_ALL,  \"SET CUR ALL\"},\n        {USB_SETUP_GET_CUR,      \"GET CUR\"},\n        {USB_SETUP_GET_MIN,      \"GET MIN\"},\n        {USB_SETUP_GET_MAX,      \"GET MAX\"},\n        {USB_SETUP_GET_RES,      \"GET RES\"},\n        {USB_SETUP_GET_LEN,      \"GET LEN\"},\n        {USB_SETUP_GET_INFO,     \"GET INFO\"},\n        {USB_SETUP_GET_DEF,      \"GET DEF\"},\n        {USB_SETUP_GET_CUR_ALL,  \"GET CUR ALL\"},\n        {USB_SETUP_GET_MIN_ALL,  \"GET MIN ALL\"},\n        {USB_SETUP_GET_MAX_ALL,  \"GET MAX ALL\"},\n        {USB_SETUP_GET_RES_ALL,  \"GET RES ALL\"},\n        {USB_SETUP_GET_DEF_ALL,  \"GET DEF ALL\"},\n        {0, NULL}\n};\n\n/* Registered dissector for video class-specific control requests.\n * Dispatch to an appropriate dissector function.\n *\n * @param tvb    the tv_buff with the (remaining) packet data.\n *               On entry, the gaze is set to SETUP bRequest field.\n * @param pinfo  the packet info of this packet (additional info)\n * @param tree   the protocol tree to be built or NULL\n * @param data   Not used\n *\n * @return   0   no class specific dissector was found\n * @return  <0   not enough data\n * @return  >0   amount of data in the descriptor\n */\nstatic int\ndissect_usb_vid_control(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)\n{\n    bool                 is_request = (pinfo->srcport == NO_ENDPOINT);\n    urb_info_t          *urb = (urb_info_t *)data;\n    usb_trans_info_t    *usb_trans_info;\n    int                  offset     = 0;\n    usb_setup_dissector  dissector  = NULL;\n    const usb_setup_dissector_table_t *tmp;\n\n    /* Reject the packet if data or usb_trans_info are NULL */\n    if (urb == NULL || urb->conv == NULL || urb->usb_trans_info == NULL)\n        return 0;\n    usb_trans_info = urb->usb_trans_info;\n\n    /* See if we can find a class specific dissector for this request */\n    for (tmp=setup_dissectors; tmp->dissector; tmp++)\n    {\n        if (tmp->request == usb_trans_info->setup.request)\n        {\n            dissector = tmp->dissector;\n            break;\n        }\n    }\n    /* No we could not find any class specific dissector for this request\n     * return false and let USB try any of the standard requests.\n     */\n    if (!dissector)\n        return 0;\n\n    col_set_str(pinfo->cinfo, COL_PROTOCOL, \"USBVIDEO\");\n    col_add_fstr(pinfo->cinfo, COL_INFO, \"%s %s\",\n                val_to_str_wmem(pinfo->pool, usb_trans_info->setup.request, setup_request_names_vals, \"Unknown type %x\"),\n                is_request?\"Request \":\"Response\");\n\n    if (is_request)\n    {\n        proto_tree_add_item(tree, hf_usb_vid_request, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n        offset += 1;\n    }\n\n    offset = dissector(pinfo, tree, tvb, offset, is_request, usb_trans_info, urb);\n    return offset;\n}\n\n/* Registered dissector for video class-specific URB_INTERRUPT\n *\n * @param tvb    the tv_buff with the (remaining) packet data\n * @param pinfo  the packet info of this packet (additional info)\n * @param tree   the protocol tree to be built or NULL\n * @param data   Unused API parameter\n *\n * @return   0   no class specific dissector was found\n * @return  <0   not enough data\n * @return  >0   amount of data in the descriptor\n */\nstatic int\ndissect_usb_vid_interrupt(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)\n{\n    urb_info_t *urb;\n    int bytes_available;\n    int  offset = 0;\n\n    urb = (urb_info_t *)data;\n    bytes_available = tvb_reported_length_remaining(tvb, offset);\n\n    col_set_str(pinfo->cinfo, COL_PROTOCOL, \"USBVIDEO\");\n\n    if (bytes_available > 0)\n    {\n        uint8_t originating_interface;\n        uint8_t originating_entity;\n\n        originating_interface = tvb_get_uint8(tvb, offset) & INT_ORIGINATOR_MASK;\n        proto_tree_add_item(tree, hf_usb_vid_interrupt_bStatusType, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n        offset++;\n\n        originating_entity = tvb_get_uint8(tvb, offset);\n        proto_tree_add_item(tree, hf_usb_vid_interrupt_bOriginator, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n        offset++;\n\n        if (originating_interface == INT_VIDEOCONTROL)\n        {\n            uint8_t control_sel;\n            uint8_t attribute;\n            const char *control_name;\n\n            proto_tree_add_item(tree, hf_usb_vid_control_interrupt_bEvent, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n            offset++;\n\n            control_sel = tvb_get_uint8(tvb, offset);\n            control_name = get_control_selector_name(originating_entity, control_sel, urb->conv);\n            if (!control_name)\n                control_name = \"Unknown\";\n\n            proto_tree_add_uint_format_value(tree, hf_usb_vid_control_selector, tvb,\n                                             offset, 1, control_sel, \"%s (0x%02x)\",\n                                             control_name, control_sel);\n            offset++;\n\n            attribute = tvb_get_uint8(tvb, offset);\n            proto_tree_add_item(tree, hf_usb_vid_interrupt_bAttribute, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n            offset++;\n\n            switch (attribute)\n            {\n                case CONTROL_CHANGE_FAILURE:\n                    proto_tree_add_item(tree, hf_usb_vid_request_error, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n                    offset++;\n                    break;\n\n                case CONTROL_CHANGE_INFO:\n                    offset = dissect_usb_vid_control_info(tree, tvb, offset);\n                    break;\n\n                case CONTROL_CHANGE_VALUE:\n                case CONTROL_CHANGE_MIN:\n                case CONTROL_CHANGE_MAX:\n                    dissect_usb_vid_control_value(tree, tvb, offset, attribute);\n                    offset += tvb_reported_length_remaining(tvb, offset);\n                    break;\n\n                default:\n                    proto_tree_add_item(tree, hf_usb_vid_value_data, tvb, offset, -1, ENC_NA);\n                    offset += tvb_reported_length_remaining(tvb, offset);\n                    break;\n            }\n        }\n        else if (originating_interface == INT_VIDEOSTREAMING)\n        {\n            /* @todo */\n        }\n    }\n    else\n        offset = -2;\n\n    return offset;\n}\n\nvoid\nproto_register_usb_vid(void)\n{\n    static hf_register_info hf[] = {\n        /***** Setup *****/\n            { &hf_usb_vid_request,\n                    { \"bRequest\", \"usbvideo.setup.bRequest\", FT_UINT8, BASE_HEX, VALS(setup_request_names_vals), 0x0,\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_length,\n                    { \"wLength\", \"usbvideo.setup.wLength\", FT_UINT16, BASE_DEC, NULL, 0x0,\n                            NULL, HFILL }\n            },\n\n        /***** Request Error Control *****/\n            { &hf_usb_vid_request_error,\n                    { \"bRequestErrorCode\", \"usbvideo.reqerror.code\",\n                            FT_UINT8, BASE_DEC | BASE_EXT_STRING,\n                            &request_error_codes_ext, 0,\n                            \"Request Error Code\", HFILL }\n            },\n\n        /***** Unit/Terminal Controls *****/\n            { &hf_usb_vid_control_selector,\n                    { \"Control Selector\", \"usbvideo.control.selector\", FT_UINT8, BASE_HEX, NULL, 0x0,\n                            \"ID of the control within its entity\", HFILL }\n            },\n\n            { &hf_usb_vid_control_entity,\n                    { \"Entity\", \"usbvideo.control.entity\", FT_UINT8, BASE_HEX, NULL, 0x0,\n                            \"Unit or terminal to which the control belongs\", HFILL }\n            },\n\n            { &hf_usb_vid_control_interface,\n                    { \"Interface\", \"usbvideo.control.interface\", FT_UINT8, BASE_HEX, NULL, 0x0,\n                            \"Interface to which the control belongs\", HFILL }\n            },\n\n            { &hf_usb_vid_control_info,\n                    { \"Info (Capabilities/State)\", \"usbvideo.control.info\",\n                            FT_UINT8, BASE_HEX, NULL, 0,\n                            \"Control capabilities and current state\", HFILL }\n            },\n\n            { &hf_usb_vid_control_info_D[0],\n                    { \"Supports GET\", \"usbvideo.control.info.D0\",\n                            FT_BOOLEAN, 8, TFS(&tfs_yes_no), (1<<0),\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_control_info_D[1],\n                    { \"Supports SET\", \"usbvideo.control.info.D1\",\n                            FT_BOOLEAN, 8, TFS(&tfs_yes_no), (1<<1),\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_control_info_D[2],\n                    { \"Disabled due to automatic mode\", \"usbvideo.control.info.D2\",\n                            FT_BOOLEAN, 8, TFS(&tfs_yes_no), (1<<2),\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_control_info_D[3],\n                    { \"Autoupdate\", \"usbvideo.control.info.D3\",\n                            FT_BOOLEAN, 8, TFS(&tfs_yes_no), (1<<3),\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_control_info_D[4],\n                    { \"Asynchronous\", \"usbvideo.control.info.D4\",\n                            FT_BOOLEAN, 8, TFS(&tfs_yes_no), (1<<4),\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_control_info_D[5],\n                    { \"Disabled due to incompatibility with Commit state\", \"usbvideo.control.info.D5\",\n                            FT_BOOLEAN, 8, TFS(&tfs_yes_no), (1<<5),\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_control_info_D[6],\n                    { \"Reserved\", \"usbvideo.control.info.D6\",\n                            FT_UINT8, BASE_HEX, NULL, (3<<6),\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_control_length,\n                    { \"Control Length\", \"usbvideo.control.len\",\n                            FT_UINT16, BASE_DEC, NULL, 0,\n                            \"Control size in bytes\", HFILL }\n            },\n\n            { &hf_usb_vid_control_default,\n                    { \"Default value\", \"usbvideo.control.value.default\",\n                            FT_UINT32, BASE_DEC_HEX, NULL, 0,\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_control_min,\n                    { \"Minimum value\", \"usbvideo.control.value.min\",\n                            FT_UINT32, BASE_DEC_HEX, NULL, 0,\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_control_max,\n                    { \"Maximum value\", \"usbvideo.control.value.max\",\n                            FT_UINT32, BASE_DEC_HEX, NULL, 0,\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_control_res,\n                    { \"Resolution\", \"usbvideo.control.value.res\",\n                            FT_UINT32, BASE_DEC_HEX, NULL, 0,\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_control_cur,\n                    { \"Current value\", \"usbvideo.control.value.cur\",\n                            FT_UINT32, BASE_DEC_HEX, NULL, 0,\n                            NULL, HFILL }\n            },\n\n        /***** Terminal Descriptors *****/\n\n            /* @todo Decide whether to unify .name fields */\n            { &hf_usb_vid_control_ifdesc_iTerminal,\n                    { \"iTerminal\", \"usbvideo.terminal.name\", FT_UINT8, BASE_DEC, NULL, 0x0,\n                            \"String Descriptor describing this terminal\", HFILL }\n            },\n\n            /* @todo Decide whether to unify .terminal.id and .unit.id under .entityID */\n            { &hf_usb_vid_control_ifdesc_terminal_id,\n                    { \"bTerminalID\", \"usbvideo.terminal.id\", FT_UINT8, BASE_DEC, NULL, 0x0,\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_control_ifdesc_terminal_type,\n                    { \"wTerminalType\", \"usbvideo.terminal.type\",\n                            FT_UINT16, BASE_HEX | BASE_EXT_STRING, &vc_terminal_types_ext, 0,\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_control_ifdesc_assoc_terminal,\n                    { \"bAssocTerminal\", \"usbvideo.terminal.assocTerminal\", FT_UINT8, BASE_DEC, NULL, 0x0,\n                            \"Associated Terminal\", HFILL }\n            },\n\n        /***** Camera Terminal Descriptor *****/\n\n            { &hf_usb_vid_cam_objective_focal_len_min,\n                    { \"wObjectiveFocalLengthMin\", \"usbvideo.camera.objectiveFocalLengthMin\",\n                            FT_UINT16, BASE_DEC, NULL, 0,\n                            \"Minimum Focal Length for Optical Zoom\", HFILL }\n            },\n\n            { &hf_usb_vid_cam_objective_focal_len_max,\n                    { \"wObjectiveFocalLengthMax\", \"usbvideo.camera.objectiveFocalLengthMax\",\n                            FT_UINT16, BASE_DEC, NULL, 0,\n                            \"Minimum Focal Length for Optical Zoom\", HFILL }\n            },\n\n            { &hf_usb_vid_cam_ocular_focal_len,\n                    { \"wOcularFocalLength\", \"usbvideo.camera.ocularFocalLength\",\n                            FT_UINT16, BASE_DEC, NULL, 0,\n                            \"Ocular Focal Length for Optical Zoom\", HFILL }\n            },\n\n            { &hf_usb_vid_cam_control_D[0],\n                    { \"Scanning Mode\", \"usbvideo.camera.control.D0\",\n                            FT_BOOLEAN,\n                            array_length(hf_usb_vid_cam_control_D),\n                            TFS(&tfs_yes_no), (1<<0),\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_cam_control_D[1],\n                    { \"Auto Exposure Mode\", \"usbvideo.camera.control.D1\",\n                            FT_BOOLEAN,\n                            array_length(hf_usb_vid_cam_control_D),\n                            TFS(&tfs_yes_no), (1<<1),\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_cam_control_D[2],\n                    { \"Auto Exposure Priority\", \"usbvideo.camera.control.D2\",\n                            FT_BOOLEAN,\n                            array_length(hf_usb_vid_cam_control_D),\n                            TFS(&tfs_yes_no), (1<<2),\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_cam_control_D[3],\n                    { \"Exposure Time (Absolute)\", \"usbvideo.camera.control.D3\",\n                            FT_BOOLEAN,\n                            array_length(hf_usb_vid_cam_control_D),\n                            TFS(&tfs_yes_no), (1<<3),\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_cam_control_D[4],\n                    { \"Exposure Time (Relative)\", \"usbvideo.camera.control.D4\",\n                            FT_BOOLEAN,\n                            array_length(hf_usb_vid_cam_control_D),\n                            TFS(&tfs_yes_no), (1<<4),\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_cam_control_D[5],\n                    { \"Focus (Absolute)\", \"usbvideo.camera.control.D5\",\n                            FT_BOOLEAN,\n                            array_length(hf_usb_vid_cam_control_D),\n                            TFS(&tfs_yes_no), (1<<5),\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_cam_control_D[6],\n                    { \"Focus (Relative)\", \"usbvideo.camera.control.D6\",\n                            FT_BOOLEAN,\n                            array_length(hf_usb_vid_cam_control_D),\n                            TFS(&tfs_yes_no), (1<<6),\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_cam_control_D[7],\n                    { \"Iris (Absolute)\", \"usbvideo.camera.control.D7\",\n                            FT_BOOLEAN,\n                            array_length(hf_usb_vid_cam_control_D),\n                            TFS(&tfs_yes_no), (1<<7),\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_cam_control_D[8],\n                    { \"Iris (Relative)\", \"usbvideo.camera.control.D8\",\n                            FT_BOOLEAN,\n                            array_length(hf_usb_vid_cam_control_D),\n                            TFS(&tfs_yes_no), (1<<8),\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_cam_control_D[9],\n                    { \"Zoom (Absolute)\", \"usbvideo.camera.control.D9\",\n                            FT_BOOLEAN,\n                            array_length(hf_usb_vid_cam_control_D),\n                            TFS(&tfs_yes_no), (1<<9),\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_cam_control_D[10],\n                    { \"Zoom (Relative)\", \"usbvideo.camera.control.D10\",\n                            FT_BOOLEAN,\n                            array_length(hf_usb_vid_cam_control_D),\n                            TFS(&tfs_yes_no), (1<<10),\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_cam_control_D[11],\n                    { \"PanTilt (Absolute)\", \"usbvideo.camera.control.D11\",\n                            FT_BOOLEAN,\n                            array_length(hf_usb_vid_cam_control_D),\n                            TFS(&tfs_yes_no), (1<<11),\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_cam_control_D[12],\n                    { \"PanTilt (Relative)\", \"usbvideo.camera.control.D12\",\n                            FT_BOOLEAN,\n                            array_length(hf_usb_vid_cam_control_D),\n                            TFS(&tfs_yes_no), (1<<12),\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_cam_control_D[13],\n                    { \"Roll (Absolute)\", \"usbvideo.camera.control.D13\",\n                            FT_BOOLEAN,\n                            array_length(hf_usb_vid_cam_control_D),\n                            TFS(&tfs_yes_no), (1<<13),\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_cam_control_D[14],\n                    { \"Roll (Relative)\", \"usbvideo.camera.control.D14\",\n                            FT_BOOLEAN,\n                            array_length(hf_usb_vid_cam_control_D),\n                            TFS(&tfs_yes_no), (1<<14),\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_cam_control_D[15],\n                    { \"D15\", \"usbvideo.camera.control.D15\",\n                            FT_BOOLEAN,\n                            array_length(hf_usb_vid_cam_control_D),\n                            TFS(&tfs_yes_no), (1<<15),\n                            \"Reserved\", HFILL }\n            },\n\n            { &hf_usb_vid_cam_control_D[16],\n                    { \"D16\", \"usbvideo.camera.control.D16\",\n                            FT_BOOLEAN,\n                            array_length(hf_usb_vid_cam_control_D),\n                            TFS(&tfs_yes_no), (1<<16),\n                            \"Reserved\", HFILL }\n            },\n\n            { &hf_usb_vid_cam_control_D[17],\n                    { \"Auto Focus\", \"usbvideo.camera.control.D17\",\n                            FT_BOOLEAN,\n                            array_length(hf_usb_vid_cam_control_D),\n                            TFS(&tfs_yes_no), (1<<17),\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_cam_control_D[18],\n                    { \"Privacy\", \"usbvideo.camera.control.D18\",\n                            FT_BOOLEAN,\n                            array_length(hf_usb_vid_cam_control_D),\n                            TFS(&tfs_yes_no), (1<<18),\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_cam_control_D[19],\n                    { \"Focus (Simple)\", \"usbvideo.camera.control.D19\",\n                            FT_BOOLEAN,\n                            array_length(hf_usb_vid_cam_control_D),\n                            TFS(&tfs_yes_no), (1<<19),\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_cam_control_D[20],\n                    { \"Window\", \"usbvideo.camera.control.D20\",\n                            FT_BOOLEAN,\n                            array_length(hf_usb_vid_cam_control_D),\n                            TFS(&tfs_yes_no), (1<<20),\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_cam_control_D[21],\n                    { \"Region of Interest\", \"usbvideo.camera.control.D21\",\n                            FT_BOOLEAN,\n                            array_length(hf_usb_vid_cam_control_D),\n                            TFS(&tfs_yes_no), (1<<21),\n                            NULL, HFILL }\n            },\n\n        /***** Unit Descriptors *****/\n\n            { &hf_usb_vid_control_ifdesc_unit_id,\n                    { \"bUnitID\", \"usbvideo.unit.id\", FT_UINT8, BASE_DEC, NULL, 0x0,\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_num_inputs,\n                    { \"bNrInPins\", \"usbvideo.unit.numInputs\",\n                            FT_UINT8, BASE_DEC, NULL, 0,\n                            \"Number of input pins\", HFILL }\n            },\n\n            { &hf_usb_vid_sources,\n                    { \"baSourceID\", \"usbvideo.unit.sources\",\n                            FT_BYTES, BASE_NONE, NULL, 0,\n                            \"Input entity IDs\", HFILL }\n            },\n\n\n        /***** Processing Unit Descriptor *****/\n\n            { &hf_usb_vid_iProcessing,\n                    { \"iProcessing\", \"usbvideo.processor.name\", FT_UINT8, BASE_DEC, NULL, 0x0,\n                            \"String Descriptor describing this terminal\", HFILL }\n            },\n\n            { &hf_usb_vid_proc_control_D[0],\n                    { \"Brightness\", \"usbvideo.processor.control.D0\",\n                            FT_BOOLEAN, 24, TFS(&tfs_yes_no), (1<<0),\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_proc_control_D[1],\n                    { \"Contrast\", \"usbvideo.processor.control.D1\",\n                            FT_BOOLEAN, 24, TFS(&tfs_yes_no), (1<<1),\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_proc_control_D[2],\n                    { \"Hue\", \"usbvideo.processor.control.D2\",\n                            FT_BOOLEAN, 24, TFS(&tfs_yes_no), (1<<2),\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_proc_control_D[3],\n                    { \"Saturation\", \"usbvideo.processor.control.D3\",\n                            FT_BOOLEAN, 24, TFS(&tfs_yes_no), (1<<3),\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_proc_control_D[4],\n                    { \"Sharpness\", \"usbvideo.processor.control.D4\",\n                            FT_BOOLEAN, 24, TFS(&tfs_yes_no), (1<<4),\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_proc_control_D[5],\n                    { \"Gamma\", \"usbvideo.processor.control.D5\",\n                            FT_BOOLEAN, 24, TFS(&tfs_yes_no), (1<<5),\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_proc_control_D[6],\n                    { \"White Balance Temperature\", \"usbvideo.processor.control.D6\",\n                            FT_BOOLEAN, 24, TFS(&tfs_yes_no), (1<<6),\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_proc_control_D[7],\n                    { \"White Balance Component\", \"usbvideo.processor.control.D7\",\n                            FT_BOOLEAN, 24, TFS(&tfs_yes_no), (1<<7),\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_proc_control_D[8],\n                    { \"Backlight Compensation\", \"usbvideo.processor.control.D8\",\n                            FT_BOOLEAN, 24, TFS(&tfs_yes_no), (1<<8),\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_proc_control_D[9],\n                    { \"Gain\", \"usbvideo.processor.control.D9\",\n                            FT_BOOLEAN, 24, TFS(&tfs_yes_no), (1<<9),\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_proc_control_D[10],\n                    { \"Power Line Frequency\", \"usbvideo.processor.control.D10\",\n                            FT_BOOLEAN, 24, TFS(&tfs_yes_no), (1<<10),\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_proc_control_D[11],\n                    { \"Hue, Auto\", \"usbvideo.processor.control.D11\",\n                            FT_BOOLEAN, 24, TFS(&tfs_yes_no), (1<<11),\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_proc_control_D[12],\n                    { \"White Balance Temperature, Auto\", \"usbvideo.processor.control.D12\",\n                            FT_BOOLEAN, 24, TFS(&tfs_yes_no), (1<<12),\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_proc_control_D[13],\n                    { \"White Balance Component, Auto\", \"usbvideo.processor.control.D13\",\n                            FT_BOOLEAN, 24, TFS(&tfs_yes_no), (1<<13),\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_proc_control_D[14],\n                    { \"Digital Multiplier\", \"usbvideo.processor.control.D14\",\n                            FT_BOOLEAN, 24, TFS(&tfs_yes_no), (1<<14),\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_proc_control_D[15],\n                    { \"Digital Multiplier Limit\", \"usbvideo.processor.control.D15\",\n                            FT_BOOLEAN, 24, TFS(&tfs_yes_no), (1<<15),\n                            \"Reserved\", HFILL }\n            },\n\n            { &hf_usb_vid_proc_control_D[16],\n                    { \"Analog Video Standard\", \"usbvideo.processor.control.D16\",\n                            FT_BOOLEAN, 24, TFS(&tfs_yes_no), (1<<16),\n                            \"Reserved\", HFILL }\n            },\n\n            { &hf_usb_vid_proc_control_D[17],\n                    { \"Analog Video Lock Status\", \"usbvideo.processor.control.D17\",\n                            FT_BOOLEAN, 24, TFS(&tfs_yes_no), (1<<17),\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_proc_control_D[18],\n                    { \"Contrast, Auto\", \"usbvideo.processor.control.D18\",\n                            FT_BOOLEAN, 24, TFS(&tfs_yes_no), (1<<18),\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_proc_standards,\n                    { \"bmVideoStandards\", \"usbvideo.processor.standards\",\n                            FT_UINT8, BASE_HEX, NULL, 0,\n                            \"Supported analog video standards\", HFILL }\n            },\n\n            { &hf_usb_vid_proc_standards_D[0],\n                    { \"None\", \"usbvideo.processor.standards.D0\",\n                            FT_BOOLEAN, 8, TFS(&tfs_yes_no), (1<<0),\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_proc_standards_D[1],\n                    { \"NTSC - 525/60\", \"usbvideo.processor.standards.D1\",\n                            FT_BOOLEAN, 8, TFS(&tfs_yes_no), (1<<1),\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_proc_standards_D[2],\n                    { \"PAL - 625/50\", \"usbvideo.processor.standards.D2\",\n                            FT_BOOLEAN, 8, TFS(&tfs_yes_no), (1<<2),\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_proc_standards_D[3],\n                    { \"SECAM - 625/50\", \"usbvideo.processor.standards.D3\",\n                            FT_BOOLEAN, 8, TFS(&tfs_yes_no), (1<<3),\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_proc_standards_D[4],\n                    { \"NTSC - 625/50\", \"usbvideo.processor.standards.D4\",\n                            FT_BOOLEAN, 8, TFS(&tfs_yes_no), (1<<4),\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_proc_standards_D[5],\n                    { \"PAL - 525/60\", \"usbvideo.processor.standards.D5\",\n                            FT_BOOLEAN, 8, TFS(&tfs_yes_no), (1<<5),\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_max_multiplier,\n                    { \"wMaxMultiplier\", \"usbvideo.processor.maxMultiplier\",\n                            FT_UINT16, BASE_DEC, NULL, 0,\n                            \"100 x max digital multiplication\", HFILL }\n            },\n\n        /***** Selector Unit Descriptor *****/\n\n            { &hf_usb_vid_iSelector,\n                    { \"iSelector\", \"usbvideo.selector.name\", FT_UINT8, BASE_DEC, NULL, 0x0,\n                            \"String Descriptor describing this terminal\", HFILL }\n            },\n\n        /***** Extension Unit Descriptor *****/\n\n            { &hf_usb_vid_iExtension,\n                    { \"iExtension\", \"usbvideo.extension.name\", FT_UINT8, BASE_DEC, NULL, 0x0,\n                            \"String Descriptor describing this terminal\", HFILL }\n            },\n\n            { &hf_usb_vid_exten_guid,\n                    { \"guid\", \"usbvideo.extension.guid\",\n                            FT_GUID, BASE_NONE, NULL, 0,\n                            \"Identifier\", HFILL }\n            },\n\n            { &hf_usb_vid_exten_num_controls,\n                    { \"bNumControls\", \"usbvideo.extension.numControls\",\n                            FT_UINT8, BASE_DEC, NULL, 0,\n                            \"Number of controls\", HFILL }\n            },\n\n        /***** Probe/Commit *****/\n\n            { &hf_usb_vid_probe_hint,\n                    { \"bmHint\", \"usbvideo.probe.hint\",\n                            FT_UINT16, BASE_HEX, NULL, 0,\n                            \"Fields to hold constant during negotiation\", HFILL }\n            },\n\n            { &hf_usb_vid_probe_hint_D[0],\n                    { \"dwFrameInterval\", \"usbvideo.probe.hint.D0\",\n                            FT_BOOLEAN, 5, TFS(&probe_hint_meaning), (1<<0),\n                            \"Frame Rate\", HFILL }\n            },\n            { &hf_usb_vid_probe_hint_D[1],\n                    { \"wKeyFrameRate\", \"usbvideo.probe.hint.D1\",\n                            FT_BOOLEAN, 5, TFS(&probe_hint_meaning), (1<<1),\n                            \"Key Frame Rate\", HFILL }\n            },\n            { &hf_usb_vid_probe_hint_D[2],\n                    { \"wPFrameRate\", \"usbvideo.probe.hint.D2\",\n                            FT_BOOLEAN, 5, TFS(&probe_hint_meaning), (1<<2),\n                            \"P-Frame Rate\", HFILL }\n            },\n            { &hf_usb_vid_probe_hint_D[3],\n                    { \"wCompQuality\", \"usbvideo.probe.hint.D3\",\n                            FT_BOOLEAN, 5, TFS(&probe_hint_meaning), (1<<3),\n                            \"Compression Quality\", HFILL }\n            },\n            { &hf_usb_vid_probe_hint_D[4],\n                    { \"wCompWindowSize\", \"usbvideo.probe.hint.D4\",\n                            FT_BOOLEAN, 5, TFS(&probe_hint_meaning), (1<<4),\n                            \"Compression Window Size\", HFILL }\n            },\n\n            { &hf_usb_vid_probe_key_frame_rate,\n                    { \"wKeyFrameRate\", \"usbvideo.probe.keyFrameRate\",\n                            FT_UINT16, BASE_DEC, NULL, 0,\n                            \"Key frame rate\", HFILL }\n            },\n\n            { &hf_usb_vid_probe_p_frame_rate,\n                    { \"wPFrameRate\", \"usbvideo.probe.pFrameRate\",\n                            FT_UINT16, BASE_DEC, NULL, 0,\n                            \"P frame rate\", HFILL }\n            },\n\n            { &hf_usb_vid_probe_comp_quality,\n                    { \"wCompQuality\", \"usbvideo.probe.compQuality\",\n                            FT_UINT16, BASE_DEC, NULL, 0,\n                            \"Compression quality [0-10000]\", HFILL }\n            },\n\n            { &hf_usb_vid_probe_comp_window,\n                    { \"wCompWindow\", \"usbvideo.probe.compWindow\",\n                            FT_UINT16, BASE_DEC, NULL, 0,\n                            \"Window size for average bit rate control\", HFILL }\n            },\n            { &hf_usb_vid_probe_delay,\n                    { \"wDelay\", \"usbvideo.probe.delay\",\n                            FT_UINT16, BASE_DEC, NULL, 0,\n                            \"Latency in ms from capture to USB\", HFILL }\n            },\n            { &hf_usb_vid_probe_max_frame_sz,\n                    { \"dwMaxVideoFrameSize\", \"usbvideo.probe.maxVideoFrameSize\",\n                            FT_UINT32, BASE_DEC, NULL, 0,\n                            NULL, HFILL }\n            },\n            { &hf_usb_vid_probe_max_payload_sz,\n                    { \"dwMaxPayloadTransferSize\", \"usbvideo.probe.maxPayloadTransferSize\",\n                            FT_UINT32, BASE_DEC, NULL, 0,\n                            NULL, HFILL }\n            },\n            { &hf_usb_vid_probe_clock_freq,\n                    { \"dwClockFrequency\", \"usbvideo.probe.clockFrequency\",\n                            FT_UINT32, BASE_DEC, NULL, 0,\n                            \"Device clock frequency in Hz\", HFILL }\n            },\n\n            { &hf_usb_vid_probe_framing,\n                    { \"bmFramingInfo\", \"usbvideo.probe.framing\",\n                            FT_UINT8, BASE_HEX, NULL, 0,\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_probe_framing_D[0],\n                    { \"Frame ID required\", \"usbvideo.probe.framing.D0\",\n                            FT_BOOLEAN, 2, TFS(&tfs_yes_no), (1<<0),\n                            NULL, HFILL }\n            },\n            { &hf_usb_vid_probe_framing_D[1],\n                    { \"EOF utilized\", \"usbvideo.probe.framing.D1\",\n                            FT_BOOLEAN, 2, TFS(&tfs_yes_no), (1<<1),\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_probe_preferred_ver,\n                    { \"bPreferredVersion\", \"usbvideo.probe.preferredVersion\",\n                            FT_UINT8, BASE_DEC, NULL, 0,\n                            \"Preferred payload format version\", HFILL }\n            },\n            { &hf_usb_vid_probe_min_ver,\n                    { \"bMinVersion\", \"usbvideo.probe.minVersion\",\n                            FT_UINT8, BASE_DEC, NULL, 0,\n                            \"Min supported payload format version\", HFILL }\n            },\n            { &hf_usb_vid_probe_max_ver,\n                    { \"bMaxVersion\", \"usbvideo.probe.maxVer\",\n                            FT_UINT8, BASE_DEC, NULL, 0,\n                            \"Max supported payload format version\", HFILL }\n            },\n\n            { &hf_usb_vid_control_ifdesc_dwClockFrequency,\n                    { \"dwClockFrequency\", \"usbvideo.probe.clockFrequency\",\n                            FT_UINT32, BASE_DEC, NULL, 0,\n                            \"Device clock frequency (Hz) for selected format\", HFILL }\n            },\n\n        /***** Format Descriptors *****/\n\n            { &hf_usb_vid_format_index,\n                    { \"bFormatIndex\", \"usbvideo.format.index\",\n                            FT_UINT8, BASE_DEC, NULL, 0,\n                            \"Index of this format descriptor\", HFILL }\n            },\n\n            { &hf_usb_vid_format_num_frame_descriptors,\n                    { \"bNumFrameDescriptors\", \"usbvideo.format.numFrameDescriptors\",\n                            FT_UINT8, BASE_DEC, NULL, 0,\n                            \"Number of frame descriptors for this format\", HFILL }\n            },\n\n            { &hf_usb_vid_format_guid,\n                    { \"guidFormat\", \"usbvideo.format.guid\",\n                            FT_GUID, BASE_NONE, NULL, 0,\n                            \"Stream encoding format\", HFILL }\n            },\n\n            { &hf_usb_vid_format_bits_per_pixel,\n                    { \"bBitsPerPixel\", \"usbvideo.format.bitsPerPixel\",\n                            FT_UINT8, BASE_DEC, NULL, 0,\n                            \"Bits per pixel\", HFILL }\n            },\n\n            { &hf_usb_vid_default_frame_index,\n                    { \"bDefaultFrameIndex\", \"usbvideo.format.defaultFrameIndex\",\n                            FT_UINT8, BASE_DEC, NULL, 0,\n                            \"Optimum frame index for this stream\", HFILL }\n            },\n\n            { &hf_usb_vid_aspect_ratio_x,\n                    { \"bAspectRatioX\", \"usbvideo.format.aspectRatioX\",\n                            FT_UINT8, BASE_DEC, NULL, 0,\n                            \"X dimension of picture aspect ratio\", HFILL }\n            },\n\n            { &hf_usb_vid_aspect_ratio_y,\n                    { \"bAspectRatioY\", \"usbvideo.format.aspectRatioY\",\n                            FT_UINT8, BASE_DEC, NULL, 0,\n                            \"Y dimension of picture aspect ratio\", HFILL }\n            },\n\n            { &hf_usb_vid_interlace_flags,\n                    { \"bmInterlaceFlags\", \"usbvideo.format.interlace\",\n                            FT_UINT8, BASE_HEX, NULL, 0x0,\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_is_interlaced,\n                    { \"Interlaced stream\", \"usbvideo.format.interlace.D0\",\n                            FT_BOOLEAN, 8, TFS(&is_interlaced_meaning), (1<<0),\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_interlaced_fields,\n                    { \"Fields per frame\", \"usbvideo.format.interlace.D1\",\n                            FT_BOOLEAN, 8, TFS(&interlaced_fields_meaning), (1<<1),\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_field_1_first,\n                    { \"Field 1 first\", \"usbvideo.format.interlace.D2\",\n                            FT_BOOLEAN, 8, TFS(&tfs_yes_no), (1<<2),\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_field_pattern,\n                    { \"Field pattern\", \"usbvideo.format.interlace.pattern\",\n                            FT_UINT8, BASE_DEC | BASE_EXT_STRING,\n                            &field_pattern_meaning_ext, (3<<4),\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_copy_protect,\n                    { \"bCopyProtect\", \"usbvideo.format.copyProtect\",\n                            FT_UINT8, BASE_DEC, VALS(copy_protect_meaning), 0,\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_variable_size,\n                    { \"Variable size\", \"usbvideo.format.variableSize\",\n                            FT_BOOLEAN, BASE_NONE, NULL, 0,\n                            NULL, HFILL }\n            },\n\n        /***** MJPEG Format Descriptor *****/\n\n            { &hf_usb_vid_mjpeg_flags,\n                    { \"bmFlags\", \"usbvideo.mjpeg.flags\",\n                            FT_UINT8, BASE_HEX, NULL, 0,\n                            \"Characteristics\", HFILL }\n            },\n\n            { &hf_usb_vid_mjpeg_fixed_samples,\n                    { \"Fixed size samples\", \"usbvideo.mjpeg.fixed_size\",\n                            FT_BOOLEAN, 8, TFS(&tfs_yes_no), (1<<0),\n                            NULL, HFILL }\n            },\n\n        /***** Frame Descriptors *****/\n\n            { &hf_usb_vid_frame_index,\n                    { \"bFrameIndex\", \"usbvideo.frame.index\",\n                            FT_UINT8, BASE_DEC, NULL, 0,\n                            \"Index of this frame descriptor\", HFILL }\n            },\n\n            { &hf_usb_vid_frame_capabilities,\n                    { \"bmCapabilities\", \"usbvideo.frame.capabilities\",\n                            FT_UINT8, BASE_HEX, NULL, 0,\n                            \"Capabilities\", HFILL }\n            },\n\n            { &hf_usb_vid_frame_stills_supported,\n                    { \"Still image\", \"usbvideo.frame.stills\",\n                            FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), (1<<0),\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_frame_interval,\n                    { \"dwFrameInterval\", \"usbvideo.frame.interval\",\n                            FT_UINT32, BASE_DEC, NULL, 0,\n                            \"Frame interval multiple of 100 ns\", HFILL }\n            },\n\n            { &hf_usb_vid_frame_fixed_frame_rate,\n                    { \"Fixed frame rate\", \"usbvideo.frame.fixedRate\",\n                            FT_BOOLEAN, 8, TFS(&tfs_yes_no), (1<<1),\n                            NULL, HFILL }\n            },\n            { &hf_usb_vid_frame_width,\n                    { \"wWidth\", \"usbvideo.frame.width\",\n                            FT_UINT16, BASE_DEC, NULL, 0,\n                            \"Width of frame in pixels\", HFILL }\n            },\n            { &hf_usb_vid_frame_height,\n                    { \"wHeight\", \"usbvideo.frame.height\",\n                            FT_UINT16, BASE_DEC, NULL, 0,\n                            \"Height of frame in pixels\", HFILL }\n            },\n            { &hf_usb_vid_frame_min_bit_rate,\n                    { \"dwMinBitRate\", \"usbvideo.frame.minBitRate\",\n                            FT_UINT32, BASE_DEC, NULL, 0,\n                            \"Minimum bit rate in bps\", HFILL }\n            },\n            { &hf_usb_vid_frame_max_bit_rate,\n                    { \"dwMaxBitRate\", \"usbvideo.frame.maxBitRate\",\n                            FT_UINT32, BASE_DEC, NULL, 0,\n                            \"Maximum bit rate in bps\", HFILL }\n            },\n\n            { &hf_usb_vid_frame_max_frame_sz,\n                    { \"dwMaxVideoFrameBufferSize\", \"usbvideo.frame.maxBuffer\",\n                            FT_UINT32, BASE_DEC, NULL, 0,\n                            \"Maximum bytes per frame\", HFILL }\n            },\n            { &hf_usb_vid_frame_default_interval,\n                    { \"dwDefaultFrameInterval\", \"usbvideo.frame.interval.default\",\n                            FT_UINT32, BASE_DEC, NULL, 0,\n                            \"Suggested default\", HFILL }\n            },\n\n            { &hf_usb_vid_frame_interval_type,\n                    { \"bFrameIntervalType\", \"usbvideo.frame.interval.type\",\n                            FT_UINT8, BASE_DEC, NULL, 0,\n                            \"Frame rate control (continuous/discrete)\", HFILL }\n            },\n\n            { &hf_usb_vid_frame_min_interval,\n                    { \"dwMinFrameInterval\", \"usbvideo.frame.interval.min\",\n                            FT_UINT32, BASE_DEC, NULL, 0,\n                            \"Shortest frame interval (* 100 ns)\", HFILL }\n            },\n\n            { &hf_usb_vid_frame_max_interval,\n                    { \"dwMaxFrameInterval\", \"usbvideo.frame.interval.max\",\n                            FT_UINT32, BASE_DEC, NULL, 0,\n                            \"Longest frame interval (* 100 ns)\", HFILL }\n            },\n            { &hf_usb_vid_frame_step_interval,\n                    { \"dwMinFrameInterval\", \"usbvideo.frame.interval.step\",\n                            FT_UINT32, BASE_DEC, NULL, 0,\n                            \"Granularity of frame interval (* 100 ns)\", HFILL }\n            },\n\n            { &hf_usb_vid_frame_bytes_per_line,\n                    { \"dwBytesPerLine\", \"usbvideo.frame.bytesPerLine\",\n                            FT_UINT32, BASE_DEC, NULL, 0,\n                            \"Fixed number of bytes per video line\", HFILL }\n            },\n\n        /***** Colorformat Descriptor *****/\n\n            { &hf_usb_vid_color_primaries,\n                    { \"bColorPrimaries\", \"usbvideo.color.primaries\",\n                            FT_UINT8, BASE_DEC | BASE_EXT_STRING,\n                            &color_primaries_meaning_ext, 0,\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_transfer_characteristics,\n                    { \"bTransferCharacteristics\", \"usbvideo.color.transferCharacteristics\",\n                            FT_UINT8, BASE_DEC | BASE_EXT_STRING,\n                            &color_transfer_characteristics_ext, 0,\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_matrix_coefficients,\n                    { \"bMatrixCoefficients\", \"usbvideo.color.matrixCoefficients\",\n                            FT_UINT8, BASE_DEC | BASE_EXT_STRING,\n                            &matrix_coefficients_meaning_ext, 0,\n                            NULL, HFILL }\n            },\n\n        /***** Video Control Header Descriptor *****/\n\n            { &hf_usb_vid_control_ifdesc_bcdUVC,\n                    { \"bcdUVC\", \"usbvideo.bcdUVC\",\n                            FT_UINT16, BASE_HEX, NULL, 0,\n                            \"Video Device Class Specification release number\", HFILL }\n            },\n\n            { &hf_usb_vid_control_ifdesc_bInCollection,\n                    { \"bInCollection\", \"usbvideo.numStreamingInterfaces\",\n                            FT_UINT8, BASE_DEC, NULL, 0,\n                            \"Number of VideoStreaming interfaces\", HFILL }\n            },\n\n            { &hf_usb_vid_control_ifdesc_baInterfaceNr,\n                    { \"baInterfaceNr\", \"usbvideo.streamingInterfaceNumbers\",\n                            FT_BYTES, BASE_NONE, NULL, 0,\n                            \"Interface numbers of VideoStreaming interfaces\", HFILL }},\n\n        /***** Video Streaming Input Header Descriptor *****/\n\n            { &hf_usb_vid_streaming_ifdesc_bNumFormats,\n                    { \"bNumFormats\", \"usbvideo.streaming.numFormats\",\n                            FT_UINT8, BASE_DEC, NULL, 0,\n                            \"Number of video payload format descriptors\", HFILL }\n            },\n\n            { &hf_usb_vid_streaming_bmInfo,\n                    { \"bmInfo\", \"usbvideo.streaming.info\",\n                            FT_UINT8, BASE_HEX, NULL, 0,\n                            \"Capabilities\", HFILL }\n            },\n\n            { &hf_usb_vid_streaming_info_D[0],\n                    { \"Dynamic Format Change\", \"usbvideo.streaming.info.D0\",\n                            FT_BOOLEAN, 8, TFS(&tfs_yes_no), (1<<0),\n                            \"Dynamic Format Change\", HFILL }\n            },\n\n            { &hf_usb_vid_streaming_control_D[0],\n                    { \"wKeyFrameRate\", \"usbvideo.streaming.control.D0\",\n                            FT_BOOLEAN, 6, TFS(&tfs_yes_no), (1<<0),\n                            \"Probe and Commit support\", HFILL }\n            },\n\n            { &hf_usb_vid_streaming_control_D[1],\n                    { \"wPFrameRate\", \"usbvideo.streaming.control.D1\",\n                            FT_BOOLEAN, 6, TFS(&tfs_yes_no), (1<<1),\n                            \"Probe and Commit support\", HFILL }\n            },\n\n            { &hf_usb_vid_streaming_control_D[2],\n                    { \"wCompQuality\", \"usbvideo.streaming.control.D2\",\n                            FT_BOOLEAN, 6, TFS(&tfs_yes_no), (1<<2),\n                            \"Probe and Commit support\", HFILL }\n            },\n\n            { &hf_usb_vid_streaming_control_D[3],\n                    { \"wCompWindowSize\", \"usbvideo.streaming.control.D3\",\n                            FT_BOOLEAN, 6, TFS(&tfs_yes_no), (1<<3),\n                            \"Probe and Commit support\", HFILL }\n            },\n\n            { &hf_usb_vid_streaming_control_D[4],\n                    { \"Generate Key Frame\", \"usbvideo.streaming.control.D4\",\n                            FT_BOOLEAN, 6, TFS(&tfs_yes_no), (1<<4),\n                            \"Probe and Commit support\", HFILL }\n            },\n\n            { &hf_usb_vid_streaming_control_D[5],\n                    { \"Update Frame Segment\", \"usbvideo.streaming.control.D5\",\n                            FT_BOOLEAN, 6, TFS(&tfs_yes_no), (1<<5),\n                            \"Probe and Commit support\", HFILL }\n            },\n\n            { &hf_usb_vid_streaming_terminal_link,\n                    { \"bTerminalLink\", \"usbvideo.streaming.terminalLink\", FT_UINT8, BASE_DEC, NULL, 0x0,\n                            \"Output terminal ID\", HFILL }\n            },\n\n            { &hf_usb_vid_streaming_still_capture_method,\n                    { \"bStillCaptureMethod\", \"usbvideo.streaming.stillCaptureMethod\",\n                            FT_UINT8, BASE_DEC | BASE_EXT_STRING,\n                            &vs_still_capture_methods_ext, 0,\n                            \"Method of Still Image Capture\", HFILL }\n            },\n\n            { &hf_usb_vid_streaming_trigger_support,\n                    { \"HW Triggering\", \"usbvideo.streaming.triggerSupport\",\n                            FT_BOOLEAN, BASE_NONE, TFS(&tfs_supported_not_supported), 0,\n                            \"Is HW triggering supported\", HFILL }\n            },\n\n            { &hf_usb_vid_streaming_trigger_usage,\n                    { \"bTriggerUsage\", \"usbvideo.streaming.triggerUsage\",\n                            FT_UINT8, BASE_DEC, VALS(vs_trigger_usage), 0,\n                            \"How host SW should respond to trigger\", HFILL }\n            },\n\n        /***** Interrupt URB *****/\n\n            { &hf_usb_vid_interrupt_bStatusType,\n                    { \"Status Type\", \"usbvideo.interrupt.statusType\",\n                            FT_UINT8, BASE_HEX, VALS(interrupt_status_types), 0xF,\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_interrupt_bAttribute,\n                    { \"Change Type\", \"usbvideo.interrupt.attribute\",\n                            FT_UINT8, BASE_HEX | BASE_EXT_STRING,\n                            &control_change_types_ext, 0,\n                            \"Type of control change\", HFILL }\n            },\n\n            { &hf_usb_vid_interrupt_bOriginator,\n                    { \"Originator\", \"usbvideo.interrupt.originator\",\n                            FT_UINT8, BASE_DEC, NULL, 0,\n                            \"ID of the entity that reports this interrupt\", HFILL }\n            },\n\n            { &hf_usb_vid_control_interrupt_bEvent,\n                    { \"Event\", \"usbvideo.interrupt.controlEvent\",\n                            FT_UINT8, BASE_HEX, VALS(control_interrupt_events), 0,\n                            \"Type of event\", HFILL }\n            },\n\n        /***** Video Control Endpoint Descriptor *****/\n\n            { &hf_usb_vid_epdesc_subtype,\n                    { \"Subtype\", \"usbvideo.ep.descriptorSubType\",\n                            FT_UINT8, BASE_DEC, VALS(vc_ep_descriptor_subtypes), 0,\n                            \"Descriptor Subtype\", HFILL }\n            },\n\n            { &hf_usb_vid_epdesc_max_transfer_sz,\n                    { \"wMaxTransferSize\", \"usbvideo.ep.maxInterruptSize\", FT_UINT16,\n                      BASE_DEC, NULL, 0x0, \"Max interrupt structure size\", HFILL }\n            },\n\n        /***** Fields used in multiple contexts *****/\n\n            { &hf_usb_vid_ifdesc_wTotalLength,\n                    { \"wTotalLength\", \"usbvideo.totalLength\",\n                            FT_UINT16, BASE_DEC, NULL, 0,\n                            \"Video interface descriptor size\", HFILL }\n            },\n\n            { &hf_usb_vid_bControlSize,\n                    { \"bControlSize\", \"usbvideo.bmcontrolSize\",\n                            FT_UINT8, BASE_DEC, NULL, 0,\n                            \"Size of bmControls field\", HFILL }\n            },\n\n            { &hf_usb_vid_bmControl,\n                    { \"bmControl\", \"usbvideo.availableControls\",\n                            FT_UINT32, BASE_HEX, NULL, 0,\n                            \"Available controls\", HFILL }\n            },\n\n            { &hf_usb_vid_bmControl_bytes,\n                    { \"bmControl\", \"usbvideo.availableControls.bytes\",\n                            FT_BYTES, BASE_NONE, NULL, 0,\n                            \"Available controls\", HFILL }\n            },\n\n            { &hf_usb_vid_control_ifdesc_src_id,\n                    { \"bSourceID\", \"usbvideo.sourceID\", FT_UINT8, BASE_DEC, NULL, 0x0,\n                            \"Entity to which this terminal/unit is connected\", HFILL }\n            },\n\n        /**********/\n\n            { &hf_usb_vid_control_ifdesc_subtype,\n                    { \"Subtype\", \"usbvideo.control.descriptorSubType\",\n                            FT_UINT8, BASE_DEC | BASE_EXT_STRING,\n                            &vc_if_descriptor_subtypes_ext, 0,\n                            \"Descriptor Subtype\", HFILL }\n            },\n\n            { &hf_usb_vid_streaming_ifdesc_subtype,\n                    { \"Subtype\", \"usbvideo.streaming.descriptorSubType\",\n                            FT_UINT8, BASE_DEC | BASE_EXT_STRING,\n                            &vs_if_descriptor_subtypes_ext, 0,\n                            \"Descriptor Subtype\", HFILL }\n            },\n\n            { &hf_usb_vid_descriptor_data,\n                    { \"Descriptor data\", \"usbvideo.descriptor_data\", FT_BYTES, BASE_NONE, NULL, 0x0,\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_control_data,\n                    { \"Control data\", \"usbvideo.control_data\", FT_BYTES, BASE_NONE, NULL, 0x0,\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_control_value,\n                    { \"Control value\", \"usbvideo.control_value\", FT_BYTES, BASE_NONE, NULL, 0x0,\n                            NULL, HFILL }\n            },\n\n            { &hf_usb_vid_value_data,\n                    { \"Value data\", \"usbvideo.value_data\", FT_BYTES, BASE_NONE, NULL, 0x0,\n                            NULL, HFILL }\n            },\n    };\n\n    static int *usb_vid_ett[] = {\n            &ett_usb_vid,\n            &ett_descriptor_video_endpoint,\n            &ett_descriptor_video_control,\n            &ett_descriptor_video_streaming,\n            &ett_camera_controls,\n            &ett_processing_controls,\n            &ett_streaming_controls,\n            &ett_streaming_info,\n            &ett_interlace_flags,\n            &ett_frame_capability_flags,\n            &ett_mjpeg_flags,\n            &ett_video_probe,\n            &ett_probe_hint,\n            &ett_probe_framing,\n            &ett_video_standards,\n            &ett_control_capabilities\n    };\n\n    static ei_register_info ei[] = {\n        { &ei_usb_vid_subtype_unknown, { \"usbvideo.subtype.unknown\", PI_UNDECODED, PI_WARN, \"Unknown VC subtype\", EXPFILL }},\n        { &ei_usb_vid_bitmask_len, { \"usbvideo.bitmask_len_error\", PI_UNDECODED, PI_WARN, \"Only least-significant bytes decoded\", EXPFILL }},\n    };\n\n    expert_module_t* expert_usb_vid;\n\n    proto_usb_vid = proto_register_protocol(\"USB Video\", \"USBVIDEO\", \"usbvideo\");\n    proto_register_field_array(proto_usb_vid, hf, array_length(hf));\n    proto_register_subtree_array(usb_vid_ett, array_length(usb_vid_ett));\n    expert_usb_vid = expert_register_protocol(proto_usb_vid);\n    expert_register_field_array(expert_usb_vid, ei, array_length(ei));\n\n    usb_vid_control_handle = register_dissector(\"usbvideo.control\", dissect_usb_vid_control, proto_usb_vid);\n    usb_vid_descriptor_handle = register_dissector(\"usbvideo.descriptor\", dissect_usb_vid_descriptor, proto_usb_vid);\n    usb_vid_interrupt_handle = register_dissector(\"usbvideo.interrupt\", dissect_usb_vid_interrupt, proto_usb_vid);\n}\n\nvoid\nproto_reg_handoff_usb_vid(void)\n{\n    dissector_add_uint(\"usb.control\", IF_CLASS_VIDEO, usb_vid_control_handle);\n    dissector_add_uint(\"usb.descriptor\", IF_CLASS_VIDEO, usb_vid_descriptor_handle);\n    dissector_add_uint(\"usb.interrupt\", IF_CLASS_VIDEO, usb_vid_interrupt_handle);\n}\n/*\n * Editor modelines  -  https://www.wireshark.org/tools/modelines.html\n *\n * Local variables:\n * c-basic-offset: 4\n * tab-width: 8\n * indent-tabs-mode: nil\n * End:\n *\n * vi: set shiftwidth=4 tabstop=8 expandtab:\n * :indentSize=4:tabSize=8:noTabs=true:\n */\n", "patch": "@@ -1035,6 +1035,10 @@ dissect_usb_video_control_interface_descriptor(proto_tree *parent_tree, tvbuff_t\n             video_conv_info = wmem_new(wmem_file_scope(), video_conv_info_t);\n             video_conv_info->entities = wmem_tree_new(wmem_file_scope());\n             usb_conv_info->class_data = video_conv_info;\n+            usb_conv_info->class_data_type = USB_CONV_VIDEO;\n+        } else if (usb_conv_info->class_data_type != USB_CONV_VIDEO) {\n+            /* Stop dissection if another USB type is in the conversation */\n+            return descriptor_len;\n         }\n \n         entity = (video_entity_t*) wmem_tree_lookup32(video_conv_info->entities, entity_id);", "file_path": "files/2016_8\\50", "file_language": "c", "file_name": "epan/dissectors/packet-usb-video.c", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}, {"raw_url": "https://github.com/wireshark/wireshark/raw/2cb5985bf47bdc8bea78d28483ed224abdd33dc6/epan/dissectors/packet-usb.h", "code": "/* packet-usb.h\n *\n * Wireshark - Network traffic analyzer\n * By Gerald Combs <gerald@wireshark.org>\n * Copyright 1998 Gerald Combs\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version 2\n * of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */\n\n#ifndef __PACKET_USB_H__\n#define __PACKET_USB_H__\n\n#include <epan/value_string.h>\n#include <epan/wmem/wmem.h>\n#include <epan/conversation.h>\n\ntypedef struct _usb_address_t {\n    guint32 device;\n    guint32 endpoint;\n    guint16 bus_id;\n} usb_address_t;\n#define USB_ADDR_LEN (sizeof(usb_address_t))\n\n/* Flag used to mark usb_address_t.endpoint as an interface\n * address instead of the normal endpoint address.\n */\n#define INTERFACE_PORT\t0x80000000\n\n\ntypedef struct _usb_conv_info_t usb_conv_info_t;\n\n/* header type */\ntypedef enum {\n    USB_HEADER_LINUX_48_BYTES,\n    USB_HEADER_LINUX_64_BYTES,\n    USB_HEADER_USBPCAP,\n    USB_HEADER_MAUSB,\n    USB_HEADER_USBIP\n} usb_header_t;\n\n#define USB_HEADER_IS_LINUX(type) \\\n    ((type) == USB_HEADER_LINUX_48_BYTES || (type) == USB_HEADER_LINUX_64_BYTES)\n\n/* there is one such structure for each request/response */\ntypedef struct _usb_trans_info_t {\n    guint32 request_in;\n    guint32 response_in;\n    nstime_t req_time;\n    usb_header_t header_type;\n\n    /* Valid only for SETUP transactions */\n    struct _usb_setup {\n        guint8 requesttype;\n        guint8 request;\n        guint16 wValue;\n        guint16 wIndex;\n        guint16 wLength;\n    } setup;\n\n    /* Valid only during GET DESCRIPTOR transactions */\n    union {\n        struct {\n            guint8 type;\n            guint8 usb_index;\n        } get_descriptor;\n    } u;\n\n\n    /* used to pass the interface class from the\n     * interface descriptor onto the endpoint\n     * descriptors so that we can create a\n     * conversation with the appropriate class\n     * once we know the endpoint.\n     * Valid only during GET CONFIGURATION response.\n     */\n    usb_conv_info_t *interface_info;\n\n    guint64 usb_id;\n} usb_trans_info_t;\n\nenum usb_conv_class_data_type {USB_CONV_UNKNOWN = 0, USB_CONV_U3V, USB_CONV_AUDIO, USB_CONV_VIDEO, USB_CONV_MASS_STORAGE};\n\n/* Conversation Structure\n * there is one such structure for each device/endpoint conversation */\nstruct _usb_conv_info_t {\n    guint16  bus_id;\n    guint16  device_address;\n    guint8   endpoint;\n    gint     direction;\n    guint8   transfer_type;\n    guint32  device_protocol;\n    gboolean is_request;\n    gboolean is_setup;\n    guint8   setup_requesttype;\n\n    guint16 interfaceClass;     /* Interface Descriptor - class          */\n    guint16 interfaceSubclass;  /* Interface Descriptor - subclass       */\n    guint16 interfaceProtocol;  /* Interface Descriptor - protocol       */\n    guint8  interfaceNum;       /* Most recent interface number          */\n\n    guint16 deviceVendor;       /* Device    Descriptor - USB Vendor  ID */\n    guint32 deviceProduct;      /* Device    Descriptor - USB Product ID - MSBs only for encoding unknown */\n    wmem_tree_t *transactions;\n    usb_trans_info_t *usb_trans_info; /* pointer to the current transaction */\n\n    void *class_data;           /* private class/id decode data */\n    enum usb_conv_class_data_type class_data_type;\n\n    wmem_array_t *alt_settings;\n};\n\n/* This is what a tap will tap */\ntypedef struct _usb_tap_data_t {\n    guint8 urb_type;\n    guint8 transfer_type;\n    usb_conv_info_t *conv_info;\n    usb_trans_info_t *trans_info;\n} usb_tap_data_t;\n\n\n/* the value for \"no endpoint\" that's used usb_addr_t, e.g. for the address of the host */\n#define NO_ENDPOINT  0xffffffff\n/* the 8bit version of NO_ENDPOINT, it's used in usb_conv_info_t\n   0xff would be an invalid endpoint number (reserved bits are 1) */\n#define NO_ENDPOINT8 ((guint8)(NO_ENDPOINT& G_MAXUINT8))\n\n/*\n * Values from the Linux USB pseudo-header.\n */\n\n/*\n * event_type values\n */\n#define URB_SUBMIT        'S'\n#define URB_COMPLETE      'C'\n#define URB_ERROR         'E'\n\n/*\n * URB transfer_type values\n */\n#define URB_ISOCHRONOUS   0x0\n#define URB_INTERRUPT     0x1\n#define URB_CONTROL       0x2\n#define URB_BULK          0x3\n#define URB_UNKNOWN       0xFF\n\n#define URB_TRANSFER_IN   0x80\t\t/* to host */\n\n\n/* http://www.usb.org/developers/defined_class */\n#define IF_CLASS_DEVICE               0x00\n#define IF_CLASS_AUDIO                0x01\n#define IF_CLASS_COMMUNICATIONS       0x02\n#define IF_CLASS_HID                  0x03\n#define IF_CLASS_PHYSICAL             0x05\n#define IF_CLASS_IMAGE                0x06\n#define IF_CLASS_PRINTER              0x07\n#define IF_CLASS_MASS_STORAGE         0x08\n#define IF_CLASS_HUB                  0x09\n#define IF_CLASS_CDC_DATA             0x0a\n#define IF_CLASS_SMART_CARD           0x0b\n#define IF_CLASS_CONTENT_SECURITY     0x0d\n#define IF_CLASS_VIDEO                0x0e\n#define IF_CLASS_PERSONAL_HEALTHCARE  0x0f\n#define IF_CLASS_AUDIO_VIDEO          0x10\n#define IF_CLASS_DIAGNOSTIC_DEVICE    0xdc\n#define IF_CLASS_WIRELESS_CONTROLLER  0xe0\n#define IF_CLASS_MISCELLANEOUS        0xef\n#define IF_CLASS_APPLICATION_SPECIFIC 0xfe\n#define IF_CLASS_VENDOR_SPECIFIC      0xff\n\n#define IF_CLASS_UNKNOWN              0xffff\n#define IF_SUBCLASS_UNKNOWN           0xffff\n#define IF_PROTOCOL_UNKNOWN           0xffff\n#define DEV_VENDOR_UNKNOWN            0x0000  /* this id is unassigned */\n#define DEV_PRODUCT_UNKNOWN           0xfffffff /* 0x0000 and 0xffff are used values by vendors, so MSBs encode unknown */\n\n#define IF_SUBCLASS_MISC_U3V          0x05\n\n/* bmRequestType values */\n#define USB_DIR_OUT                     0               /* to device */\n#define USB_DIR_IN                      0x80            /* to host */\n\n#define USB_TYPE_MASK                   (0x03 << 5)\n#define USB_TYPE(type)                  (((type) & USB_TYPE_MASK) >> 5)\n#define RQT_SETUP_TYPE_STANDARD\t0\n#define RQT_SETUP_TYPE_CLASS\t1\n#define RQT_SETUP_TYPE_VENDOR\t2\n\n#define USB_RECIPIENT_MASK              0x1F\n#define USB_RECIPIENT(type)             ((type) & USB_RECIPIENT_MASK)\n#define RQT_SETUP_RECIPIENT_DEVICE      0\n#define RQT_SETUP_RECIPIENT_INTERFACE   1\n#define RQT_SETUP_RECIPIENT_ENDPOINT    2\n#define RQT_SETUP_RECIPIENT_OTHER       3\n\n/* Endpoint descriptor bmAttributes  */\n#define ENDPOINT_TYPE(ep_attrib)        ((ep_attrib) & 0x03)\n#define ENDPOINT_TYPE_CONTROL           0\n#define ENDPOINT_TYPE_ISOCHRONOUS       1\n#define ENDPOINT_TYPE_BULK              2\n#define ENDPOINT_TYPE_INTERRUPT         3\n\n\n#define USB_SETUP_GET_STATUS             0\n#define USB_SETUP_CLEAR_FEATURE          1\n#define USB_SETUP_SET_FEATURE            3\n#define USB_SETUP_SET_ADDRESS            5\n#define USB_SETUP_GET_DESCRIPTOR         6\n#define USB_SETUP_SET_DESCRIPTOR         7\n#define USB_SETUP_GET_CONFIGURATION      8\n#define USB_SETUP_SET_CONFIGURATION      9\n#define USB_SETUP_GET_INTERFACE         10\n#define USB_SETUP_SET_INTERFACE         11\n#define USB_SETUP_SYNCH_FRAME           12\n#define USB_SETUP_SET_SEL               48\n#define USB_SETUP_SET_ISOCH_DELAY       49\n\n\n/* 9.6.6 */\nextern const true_false_string tfs_endpoint_direction;\n\nextern value_string_ext usb_class_vals_ext;\n\nextern value_string_ext usb_urb_status_vals_ext;\n\nusb_conv_info_t *get_usb_iface_conv_info(packet_info *pinfo, guint8 interface_num);\n\nproto_item * dissect_usb_descriptor_header(proto_tree *tree,\n                                           tvbuff_t *tvb, int offset,\n                                           value_string_ext *type_val_str);\n\nvoid dissect_usb_endpoint_address(proto_tree *tree, tvbuff_t *tvb, int offset);\n\nint\ndissect_usb_endpoint_descriptor(packet_info *pinfo, proto_tree *parent_tree,\n                                tvbuff_t *tvb, int offset,\n                                usb_conv_info_t  *usb_conv_info);\n\nint\ndissect_usb_unknown_descriptor(packet_info *pinfo _U_, proto_tree *parent_tree,\n                               tvbuff_t *tvb, int offset,\n                               usb_conv_info_t  *usb_conv_info _U_);\n\nstruct mausb_header;\n\nvoid\ndissect_usb_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *parent,\n                   usb_header_t header_type, void *extra_data);\n\n#endif\n\n/*\n * Editor modelines  -  http://www.wireshark.org/tools/modelines.html\n *\n * Local variables:\n * c-basic-offset: 4\n * tab-width: 8\n * indent-tabs-mode: nil\n * End:\n *\n * vi: set shiftwidth=4 tabstop=8 expandtab:\n * :indentSize=4:tabSize=8:noTabs=true:\n */\n", "code_before": "/* packet-usb.h\n *\n * Wireshark - Network traffic analyzer\n * By Gerald Combs <gerald@wireshark.org>\n * Copyright 1998 Gerald Combs\n *\n * SPDX-License-Identifier: GPL-2.0-or-later\n */\n\n#ifndef __PACKET_USB_H__\n#define __PACKET_USB_H__\n\n#include <epan/packet_info.h>\n#include <epan/proto.h>\n#include <epan/tvbuff.h>\n#include <epan/value_string.h>\n#include <epan/tfs.h>\n#include <wsutil/nstime.h>\n\ntypedef struct _usb_address_t {\n    uint32_t device;\n    uint32_t endpoint;\n    uint16_t bus_id;\n} usb_address_t;\n#define USB_ADDR_LEN (sizeof(usb_address_t))\n\n/* Flag used to mark usb_address_t.endpoint as an interface\n * address instead of the normal endpoint address.\n */\n#define INTERFACE_PORT\t0x80000000\n\n\ntypedef struct _usb_conv_info_t usb_conv_info_t;\ntypedef struct _urb_info_t urb_info_t;\n\n/* Wireshark specific (i.e. numeric values are arbitrary) enum representing\n * USB device speed.\n */\ntypedef enum {\n    USB_SPEED_UNKNOWN,  /* Unknown, skip speed specific processing */\n    USB_SPEED_LOW,\n    USB_SPEED_FULL,\n    USB_SPEED_HIGH,\n} usb_speed_t;\n\n/* header type */\ntypedef enum {\n    USB_HEADER_LINUX_48_BYTES,\n    USB_HEADER_LINUX_64_BYTES,\n    USB_HEADER_USBPCAP,\n    USB_HEADER_MAUSB,\n    USB_HEADER_USBIP,\n    USB_HEADER_DARWIN,\n    USB_HEADER_PSEUDO_URB,\n} usb_header_t;\n\n#define USB_HEADER_IS_LINUX(type) \\\n    ((type) == USB_HEADER_LINUX_48_BYTES || (type) == USB_HEADER_LINUX_64_BYTES)\n\ntypedef struct _usb_pseudo_urb_t {\n    bool from_host;\n    uint8_t transfer_type;\n    uint8_t device_address;\n    uint8_t endpoint;\n    uint16_t bus_id;\n    usb_speed_t speed;\n} usb_pseudo_urb_t;\n\n/* there is one such structure for each request/response */\ntypedef struct _usb_trans_info_t {\n    uint32_t request_in;\n    uint32_t response_in;\n    nstime_t req_time;\n    usb_header_t header_type;\n\n    /* Valid only for SETUP transactions */\n    struct _usb_setup {\n        uint8_t requesttype;\n        uint8_t request;\n        uint16_t wValue;\n        uint16_t wIndex;\n        uint16_t wLength;\n    } setup;\n\n    /* Valid only during GET DESCRIPTOR transactions */\n    union {\n        struct {\n            uint8_t type;\n            uint8_t usb_index;\n        } get_descriptor;\n    } u;\n\n\n    /* used to pass the interface class from the\n     * interface descriptor onto the endpoint\n     * descriptors so that we can create a\n     * conversation with the appropriate class\n     * once we know the endpoint.\n     * Valid only during GET CONFIGURATION response.\n     */\n    uint8_t interface_endpoint;\n    usb_conv_info_t *interface_info;\n\n    uint64_t usb_id;\n} usb_trans_info_t;\n\nenum usb_conv_class_data_type {\n    USB_CONV_UNKNOWN = 0,\n    USB_CONV_U3V,\n    USB_CONV_AUDIO,\n    USB_CONV_VIDEO,\n    USB_CONV_MASS_STORAGE_BOT,\n    USB_CONV_MASS_STORAGE_UASP,\n    USB_CONV_CDC_DATA,\n};\n\n/* Conversation Structure\n * there is one such structure for each device/endpoint conversation */\nstruct _usb_conv_info_t {\n    uint8_t  descriptor_transfer_type; /* transfer type lifted from the configuration descriptor */\n    uint16_t max_packet_size; /* max packet size from configuration descriptor */\n\n    uint16_t interfaceClass;     /* Interface Descriptor - class          */\n    uint16_t interfaceSubclass;  /* Interface Descriptor - subclass       */\n    uint16_t interfaceProtocol;  /* Interface Descriptor - protocol       */\n    uint8_t interfaceNum;       /* Most recent interface number          */\n\n    uint16_t deviceVendor;       /* Device    Descriptor - USB Vendor  ID */\n    uint32_t deviceProduct;      /* Device    Descriptor - USB Product ID - MSBs only for encoding unknown */\n    uint16_t deviceVersion;      /* Device    Descriptor - USB device version number BCD */\n    uint8_t iSerialNumber;      /* Device    Descriptor - iSerialNumber (0 if no serial number available) */\n    wmem_tree_t *transactions;\n\n    void *class_data;           /* private class/id decode data */\n    enum usb_conv_class_data_type class_data_type;\n\n    wmem_array_t *alt_settings;\n};\n\n/* URB data lifetime is limited to packet scope */\nstruct _urb_info_t {\n    uint16_t bus_id;\n    uint16_t device_address;\n    uint8_t  endpoint;\n    int      direction;\n    uint8_t  transfer_type; /* transfer type from URB */\n    uint32_t device_protocol;\n    bool is_request;\n    bool is_setup;\n    uint8_t  setup_requesttype;\n    usb_speed_t speed;\n\n    usb_trans_info_t *usb_trans_info; /* pointer to the current transaction */\n\n    usb_conv_info_t *conv;\n};\n\n/* This is what a tap will tap */\ntypedef struct _usb_tap_data_t {\n    uint8_t urb_type;\n    uint8_t transfer_type;\n    urb_info_t *urb;\n    usb_trans_info_t *trans_info;\n} usb_tap_data_t;\n\n\n/* the value for \"no endpoint\" that's used usb_addr_t, e.g. for the address of the host */\n#define NO_ENDPOINT  0xffffffff\n/* the 8bit version of NO_ENDPOINT, it's used in usb_conv_info_t\n   0xff would be an invalid endpoint number (reserved bits are 1) */\n#define NO_ENDPOINT8 ((uint8_t)(NO_ENDPOINT& UINT8_MAX))\n\n/*\n * Values from the Linux USB pseudo-header.\n */\n\n/*\n * event_type values\n */\n#define URB_SUBMIT        'S'\n#define URB_COMPLETE      'C'\n#define URB_ERROR         'E'\n\n/*\n * URB transfer_type values\n */\n#define URB_ISOCHRONOUS   0x0\n#define URB_INTERRUPT     0x1\n#define URB_CONTROL       0x2\n#define URB_BULK          0x3\n#define URB_UNKNOWN       0xFF\n\n#define URB_TRANSFER_IN   0x80\t\t/* to host */\n\n\n/* http://www.usb.org/developers/defined_class */\n#define IF_CLASS_DEVICE               0x00\n#define IF_CLASS_AUDIO                0x01\n#define IF_CLASS_COMMUNICATIONS       0x02\n#define IF_CLASS_HID                  0x03\n#define IF_CLASS_PHYSICAL             0x05\n#define IF_CLASS_IMAGE                0x06\n#define IF_CLASS_PRINTER              0x07\n#define IF_CLASS_MASS_STORAGE         0x08\n#define IF_CLASS_HUB                  0x09\n#define IF_CLASS_CDC_DATA             0x0a\n#define IF_CLASS_SMART_CARD           0x0b\n#define IF_CLASS_CONTENT_SECURITY     0x0d\n#define IF_CLASS_VIDEO                0x0e\n#define IF_CLASS_PERSONAL_HEALTHCARE  0x0f\n#define IF_CLASS_AUDIO_VIDEO          0x10\n#define IF_CLASS_BILLBOARD            0x11\n#define IF_CLASS_USB_C_BRIDGE         0x12\n#define IF_CLASS_BULK_DISPLAY_PROTO   0x13\n#define IF_CLASS_MCTP_USB_EP          0x14\n#define IF_CLASS_I3C                  0x3c\n#define IF_CLASS_DIAGNOSTIC_DEVICE    0xdc\n#define IF_CLASS_WIRELESS_CONTROLLER  0xe0\n#define IF_CLASS_MISCELLANEOUS        0xef\n#define IF_CLASS_APPLICATION_SPECIFIC 0xfe\n#define IF_CLASS_VENDOR_SPECIFIC      0xff\n\n#define IF_CLASS_UNKNOWN              0xffff\n#define IF_SUBCLASS_UNKNOWN           0xffff\n#define IF_PROTOCOL_UNKNOWN           0xffff\n#define DEV_VENDOR_UNKNOWN            0x0000  /* this id is unassigned */\n#define DEV_PRODUCT_UNKNOWN           0xfffffff /* 0x0000 and 0xffff are used values by vendors, so MSBs encode unknown */\n#define DEV_VERSION_UNKNOWN           0xffff\n\n#define IF_SUBCLASS_MISC_U3V          0x05\n\n#define IF_SUBCLASS_APP_DFU           0x01\n\n#define IF_PROTOCOL_DFU_RUNTIME       0x01\n#define IF_PROTOCOL_DFU_MODE          0x02\n\n/* Key to be used with \"usb.control\", \"usb.bulk\" and/or \"usb.interrupt\"\n * dissector tables when the dissector only applies to specific triple.\n * Use class code directly if the code is not shared with other specifications.\n *\n * MSB (bit 31) is arbitrarily chosen to ensure class registered dissectors\n * won't clash with protocol key.\n */\n#define USB_PROTOCOL_KEY(class, subclass, protocol) \\\n    (1u << 31 | (class & 0xff) << 16 | (subclass & 0xff) << 8 | (protocol & 0xff))\n\n/* bmRequestType values */\n#define USB_DIR_OUT                     0               /* to device */\n#define USB_DIR_IN                      0x80            /* to host */\n\n#define USB_TYPE_MASK                   (0x03 << 5)\n#define USB_TYPE(type)                  (((type) & USB_TYPE_MASK) >> 5)\n#define RQT_SETUP_TYPE_STANDARD\t0\n#define RQT_SETUP_TYPE_CLASS\t1\n#define RQT_SETUP_TYPE_VENDOR\t2\n\n#define USB_RECIPIENT_MASK              0x1F\n#define USB_RECIPIENT(type)             ((type) & USB_RECIPIENT_MASK)\n#define RQT_SETUP_RECIPIENT_DEVICE      0\n#define RQT_SETUP_RECIPIENT_INTERFACE   1\n#define RQT_SETUP_RECIPIENT_ENDPOINT    2\n#define RQT_SETUP_RECIPIENT_OTHER       3\n\n/* Endpoint descriptor bmAttributes  */\n#define ENDPOINT_TYPE(ep_attrib)        ((ep_attrib) & 0x03)\n#define ENDPOINT_TYPE_CONTROL           0\n#define ENDPOINT_TYPE_ISOCHRONOUS       1\n#define ENDPOINT_TYPE_BULK              2\n#define ENDPOINT_TYPE_INTERRUPT         3\n#define ENDPOINT_TYPE_NOT_SET         255\n\n/* wMaxPacketSize */\n#define USB_MPS_EP_SIZE(max_packet_size) ((max_packet_size) & 0x07FF)\n#define USB_MPS_ADDNL(max_packet_size)   (((max_packet_size) & 0x1800) >> 11)\n#define USB_MPS(ep_size, addnl)          (((addnl) << 11) | (ep_size))\n#define USB_MPS_TPL(max_packet_size) \\\n    ((USB_MPS_ADDNL(max_packet_size) + 1) * USB_MPS_EP_SIZE(max_packet_size))\n\n#define USB_SETUP_GET_STATUS             0\n#define USB_SETUP_CLEAR_FEATURE          1\n#define USB_SETUP_SET_FEATURE            3\n#define USB_SETUP_SET_ADDRESS            5\n#define USB_SETUP_GET_DESCRIPTOR         6\n#define USB_SETUP_SET_DESCRIPTOR         7\n#define USB_SETUP_GET_CONFIGURATION      8\n#define USB_SETUP_SET_CONFIGURATION      9\n#define USB_SETUP_GET_INTERFACE         10\n#define USB_SETUP_SET_INTERFACE         11\n#define USB_SETUP_SYNCH_FRAME           12\n#define USB_SETUP_SET_SEL               48\n#define USB_SETUP_SET_ISOCH_DELAY       49\n\n/* transfer_flags */\n#define URB_SHORT_NOT_OK\t0x00000001\t/* report short reads as errors */\n#define URB_ISO_ASAP\t\t0x00000002\t/* iso-only; use the first unexpired\n\t\t\t\t\t * slot in the schedule */\n#define URB_NO_TRANSFER_DMA_MAP\t0x00000004\t/* urb->transfer_dma valid on submit */\n#define URB_NO_FSBR\t\t0x00000020\t/* UHCI-specific */\n#define URB_ZERO_PACKET\t\t0x00000040\t/* Finish bulk OUT with short packet */\n#define URB_NO_INTERRUPT\t0x00000080\t/* HINT: no non-error interrupt\n\t\t\t\t\t * needed */\n#define URB_FREE_BUFFER\t\t0x00000100\t/* Free transfer buffer with the URB */\n\n/* The following flags are used internally by usbcore and HCDs */\n#define URB_DIR_IN\t\t0x00000200\t/* Transfer from device to host */\n#define URB_DIR_OUT\t\t0\n#define URB_DIR_MASK\t\tURB_DIR_IN\n\n#define URB_DMA_MAP_SINGLE\t0x00010000\t/* Non-scatter-gather mapping */\n#define URB_DMA_MAP_PAGE\t0x00020000\t/* HCD-unsupported S-G */\n#define URB_DMA_MAP_SG\t\t0x00040000\t/* HCD-supported S-G */\n#define URB_MAP_LOCAL\t\t0x00080000\t/* HCD-local-memory mapping */\n#define URB_SETUP_MAP_SINGLE\t0x00100000\t/* Setup packet DMA mapped */\n#define URB_SETUP_MAP_LOCAL\t0x00200000\t/* HCD-local setup packet */\n#define URB_DMA_SG_COMBINED\t0x00400000\t/* S-G entries were combined */\n#define URB_ALIGNED_TEMP_BUFFER\t0x00800000\t/* Temp buffer was alloc'd */\n\n\n/* 9.6.6 */\nextern const true_false_string tfs_endpoint_direction;\n\nextern value_string_ext usb_class_vals_ext;\n\nusb_conv_info_t *get_usb_iface_conv_info(packet_info *pinfo, uint8_t interface_num);\nusb_conv_info_t *get_existing_usb_ep_conv_info(packet_info *pinfo, uint16_t bus_id,\n                                               uint16_t device_address, int endpoint);\n\nproto_item * dissect_usb_descriptor_header(proto_tree *tree,\n                                           tvbuff_t *tvb, int offset,\n                                           value_string_ext *type_val_str);\n\nvoid dissect_usb_endpoint_address(proto_tree *tree, tvbuff_t *tvb, int offset);\n\nunsigned int\nsanitize_usb_max_packet_size(uint8_t ep_type, usb_speed_t speed,\n                             unsigned int max_packet_size);\n\nint\ndissect_usb_endpoint_descriptor(packet_info *pinfo, proto_tree *parent_tree,\n                                tvbuff_t *tvb, int offset,\n                                urb_info_t *urb,\n                                uint8_t *out_ep_type, usb_speed_t speed);\n\nint\ndissect_usb_unknown_descriptor(packet_info *pinfo _U_, proto_tree *parent_tree,\n                               tvbuff_t *tvb, int offset,\n                               urb_info_t *urb _U_);\n\nint\ndissect_urb_transfer_flags(tvbuff_t *tvb, int offset, proto_tree* tree, int hf, int endian);\n\nstruct mausb_header;\n\nvoid\ndissect_usb_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *parent,\n                   usb_header_t header_type, void *extra_data);\n\nvoid usb_lpm_besl_str(char *buf, uint32_t value);\n\n#endif\n\n/*\n * Editor modelines  -  https://www.wireshark.org/tools/modelines.html\n *\n * Local variables:\n * c-basic-offset: 4\n * tab-width: 8\n * indent-tabs-mode: nil\n * End:\n *\n * vi: set shiftwidth=4 tabstop=8 expandtab:\n * :indentSize=4:tabSize=8:noTabs=true:\n */\n", "patch": "@@ -90,6 +90,8 @@ typedef struct _usb_trans_info_t {\n     guint64 usb_id;\n } usb_trans_info_t;\n \n+enum usb_conv_class_data_type {USB_CONV_UNKNOWN = 0, USB_CONV_U3V, USB_CONV_AUDIO, USB_CONV_VIDEO, USB_CONV_MASS_STORAGE};\n+\n /* Conversation Structure\n  * there is one such structure for each device/endpoint conversation */\n struct _usb_conv_info_t {\n@@ -113,7 +115,8 @@ struct _usb_conv_info_t {\n     wmem_tree_t *transactions;\n     usb_trans_info_t *usb_trans_info; /* pointer to the current transaction */\n \n-    void *class_data;\t/* private class/id decode data */\n+    void *class_data;           /* private class/id decode data */\n+    enum usb_conv_class_data_type class_data_type;\n \n     wmem_array_t *alt_settings;\n };", "file_path": "files/2016_8\\51", "file_language": "h", "file_name": "epan/dissectors/packet-usb.h", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}], "outdated": 0}
{"index": 14, "cve_id": "CVE-2016-5355", "cwe_id": ["CWE-20"], "cve_language": "C", "cve_description": "wiretap/toshiba.c in the Toshiba file parser in Wireshark 1.12.x before 1.12.12 and 2.x before 2.0.4 mishandles sscanf unsigned-integer processing, which allows remote attackers to cause a denial of service (application crash) via a crafted file.", "cvss": "5.9", "publish_date": "August 7, 2016", "AV": "NETWORK", "AC": "HIGH", "PR": "NONE", "UI": "NONE", "S": "UNCHANGED", "C": "NONE", "I": "NONE", "A": "HIGH", "commit_id": "5efb45231671baa2db2011d8f67f9d6e72bc455b", "commit_message": "Fix packet length handling.\n\nTreat the packet length as unsigned - it shouldn't be negative in the\nfile.  If it is, that'll probably cause the sscanf to fail, so we'll\nreport the file as bad.\n\nCheck it against WTAP_MAX_PACKET_SIZE to make sure we don't try to\nallocate a huge amount of memory, just as we do in other file readers.\n\nUse the now-validated packet size as the length in\nws_buffer_assure_space(), so we are certain to have enough space, and\ndon't allocate too much space.\n\nBug: 12394\nChange-Id: Ifa023ce70f7a2697bf151009b035a6e6cf8d5d90\nReviewed-on: https://code.wireshark.org/review/15169\nReviewed-by: Guy Harris <guy@alum.mit.edu>", "commit_date": "2016-04-29T22:20:26Z", "project": "wireshark/wireshark", "url": "https://api.github.com/repos/wireshark/wireshark/commits/5efb45231671baa2db2011d8f67f9d6e72bc455b", "html_url": "https://github.com/wireshark/wireshark/commit/5efb45231671baa2db2011d8f67f9d6e72bc455b", "windows_before": "", "windows_after": "", "parents": [{"commit_id_before": "e61ed6729878cba5a3b65c95b3370bdd9841452d", "url_before": "https://api.github.com/repos/wireshark/wireshark/commits/e61ed6729878cba5a3b65c95b3370bdd9841452d", "html_url_before": "https://github.com/wireshark/wireshark/commit/e61ed6729878cba5a3b65c95b3370bdd9841452d"}], "details": [{"raw_url": "https://github.com/wireshark/wireshark/raw/5efb45231671baa2db2011d8f67f9d6e72bc455b/wiretap/toshiba.c", "code": "/* toshiba.c\n *\n * Wiretap Library\n * Copyright (c) 1998 by Gilbert Ramirez <gram@alumni.rice.edu>\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version 2\n * of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */\n\n#include \"config.h\"\n#include \"wtap-int.h\"\n#include \"toshiba.h\"\n#include \"file_wrappers.h\"\n\n#include <stdlib.h>\n#include <string.h>\n\n/* This module reads the output of the 'snoop' command in the Toshiba\n * TR-600 and TR-650 \"Compact\" ISDN Routers. You can telnet to the\n * router and run 'snoop' on the different channels, and at different\n * detail levels. Be sure to choose the 'dump' level to get the hex dump.\n * The 'snoop' command has nothing to do with the Solaris 'snoop'\n * command, except that they both capture packets.\n */\n\n/*\n   Example 'snoop' output data:\n\nScript started on Thu Sep  9 21:48:49 1999\n\u001b]0;gram@nirvana:/tmp\u0007$ telnet 10.0.0.254\nTrying 10.0.0.254...\nConnected to 10.0.0.254.\nEscape character is '^]'.\n\n\nTR-600(tr600) System Console\n\nLogin:admin\nPassword:*******\n*--------------------------------------------------------*\n|             T O S H I B A    T R - 6 0 0               |\n|                 <  Compact Router >                    |\n|                       V1.02.02                         |\n|                                                        |\n|  (C) Copyright TOSHIBA Corp. 1997 All rights reserved. |\n*--------------------------------------------------------*\n\ntr600>snoop dump b1\n Trace start?(on/off/dump/dtl)->dump\n IP Address?->b1\nB1 Port Filetering\nTrace start(Dump Mode)...\n\ntr600>[No.1] 00:00:09.14 B1:1 Tx 207.193.26.136->151.164.1.8 DNS  SPORT=1028 LEN=38 CHKSUM=4FD4 ID=2390 Query RD QCNT=1 pow.zing.org?\nOFFSET 0001-0203-0405-0607-0809-0A0B-0C0D-0E0F 0123456789ABCDEF LEN=67\n0000 : FF03 003D C000 0008 2145 0000 3A12 6500 ...=....!E..:.e.\n0010 : 003F 11E6 58CF C11A 8897 A401 0804 0400 .?..X...........\n0020 : 3500 264F D409 5601 0000 0100 0000 0000 5.&O..V.........\n0030 : 0003 706F 7704 7A69 6E67 036F 7267 0000 ..pow.zing.org..\n0040 : 0100 01                                 ...\n\n[No.2] 00:00:09.25 B1:1 Rx 151.164.1.8->207.193.26.136 DNS  DPORT=1028 LEN=193 CHKSUM=3E06 ID=2390 Answer RD RA QCNT=1 pow.zing.org? ANCNT=1 pow.zing.org=206.57.36.90 TTL=2652\nOFFSET 0001-0203-0405-0607-0809-0A0B-0C0D-0E0F 0123456789ABCDEF LEN=222\n0000 : FF03 003D C000 0013 2145 0000 D590 9340 ...=....!E.....@\n0010 : 00F7 116F 8E97 A401 08CF C11A 8800 3504 ...o..........5.\n0020 : 0400 C13E 0609 5681 8000 0100 0100 0300 ...>..V.........\n0030 : 0303 706F 7704 7A69 6E67 036F 7267 0000 ..pow.zing.org..\n0040 : 0100 01C0 0C00 0100 0100 000A 5C00 04CE ............\\...\n0050 : 3924 5A04 5A49 4E47 036F 7267 0000 0200 9$Z.ZING.org....\n0060 : 0100 016F 5B00 0D03 4841 4E03 5449 5703 ...o[...HAN.TIW.\n0070 : 4E45 5400 C02E 0002 0001 0001 6F5B 0006 NET.........o[..\n0080 : 034E 5331 C02E C02E 0002 0001 0001 6F5B .NS1..........o[\n0090 : 001C 0854 414C 4945 5349 4E0D 434F 4E46 ...TALIESIN.CONF\n00A0 : 4142 554C 4154 494F 4E03 434F 4D00 C042 ABULATION.COM..B\n00B0 : 0001 0001 0001 51EC 0004 CE39 2406 C05B ......Q....9$..[\n00C0 : 0001 0001 0001 6F5B 0004 CE39 245A C06D ......o[...9$Z.m\n00D0 : 0001 0001 0001 4521 0004 187C 1F01      ......E!...|..\n\n */\n\n/* Magic text to check for toshiba-ness of file */\nstatic const char toshiba_hdr_magic[]  =\n{ 'T', ' ', 'O', ' ', 'S', ' ', 'H', ' ', 'I', ' ', 'B', ' ', 'A' };\n#define TOSHIBA_HDR_MAGIC_SIZE  (sizeof toshiba_hdr_magic  / sizeof toshiba_hdr_magic[0])\n\n/* Magic text for start of packet */\nstatic const char toshiba_rec_magic[]  = { '[', 'N', 'o', '.' };\n#define TOSHIBA_REC_MAGIC_SIZE  (sizeof toshiba_rec_magic  / sizeof toshiba_rec_magic[0])\n\nstatic gboolean toshiba_read(wtap *wth, int *err, gchar **err_info,\n\tgint64 *data_offset);\nstatic gboolean toshiba_seek_read(wtap *wth, gint64 seek_off,\n\tstruct wtap_pkthdr *phdr, Buffer *buf, int *err, gchar **err_info);\nstatic gboolean parse_single_hex_dump_line(char* rec, guint8 *buf,\n\tguint byte_offset);\nstatic gboolean parse_toshiba_packet(FILE_T fh, struct wtap_pkthdr *phdr,\n\tBuffer *buf, int *err, gchar **err_info);\n\n/* Seeks to the beginning of the next packet, and returns the\n   byte offset.  Returns -1 on failure, and sets \"*err\" to the error\n   and \"*err_info\" to null or an additional error string. */\nstatic gint64 toshiba_seek_next_packet(wtap *wth, int *err, gchar **err_info)\n{\n\tint byte;\n\tguint level = 0;\n\tgint64 cur_off;\n\n\twhile ((byte = file_getc(wth->fh)) != EOF) {\n\t\tif (byte == toshiba_rec_magic[level]) {\n\t\t\tlevel++;\n\t\t\tif (level >= TOSHIBA_REC_MAGIC_SIZE) {\n\t\t\t\t/* note: we're leaving file pointer right after the magic characters */\n\t\t\t\tcur_off = file_tell(wth->fh);\n\t\t\t\tif (cur_off == -1) {\n\t\t\t\t\t/* Error. */\n\t\t\t\t\t*err = file_error(wth->fh, err_info);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\treturn cur_off + 1;\n\t\t\t}\n\t\t} else {\n\t\t\tlevel = 0;\n\t\t}\n\t}\n\t/* EOF or error. */\n\t*err = file_error(wth->fh, err_info);\n\treturn -1;\n}\n\n#define TOSHIBA_HEADER_LINES_TO_CHECK\t200\n#define TOSHIBA_LINE_LENGTH\t\t240\n\n/* Look through the first part of a file to see if this is\n * a Toshiba trace file.\n *\n * Returns TRUE if it is, FALSE if it isn't or if we get an I/O error;\n * if we get an I/O error, \"*err\" will be set to a non-zero value and\n * \"*err_info\" will be set to null or an additional error string.\n */\nstatic gboolean toshiba_check_file_type(wtap *wth, int *err, gchar **err_info)\n{\n\tchar\tbuf[TOSHIBA_LINE_LENGTH];\n\tguint\ti, reclen, level, line;\n\tchar\tbyte;\n\n\tbuf[TOSHIBA_LINE_LENGTH-1] = 0;\n\n\tfor (line = 0; line < TOSHIBA_HEADER_LINES_TO_CHECK; line++) {\n\t\tif (file_gets(buf, TOSHIBA_LINE_LENGTH, wth->fh) == NULL) {\n\t\t\t/* EOF or error. */\n\t\t\t*err = file_error(wth->fh, err_info);\n\t\t\treturn FALSE;\n\t\t}\n\n\t\treclen = (guint) strlen(buf);\n\t\tif (reclen < TOSHIBA_HDR_MAGIC_SIZE) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tlevel = 0;\n\t\tfor (i = 0; i < reclen; i++) {\n\t\t\tbyte = buf[i];\n\t\t\tif (byte == toshiba_hdr_magic[level]) {\n\t\t\t\tlevel++;\n\t\t\t\tif (level >= TOSHIBA_HDR_MAGIC_SIZE) {\n\t\t\t\t\treturn TRUE;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlevel = 0;\n\t\t\t}\n\t\t}\n\t}\n\t*err = 0;\n\treturn FALSE;\n}\n\n\nwtap_open_return_val toshiba_open(wtap *wth, int *err, gchar **err_info)\n{\n\t/* Look for Toshiba header */\n\tif (!toshiba_check_file_type(wth, err, err_info)) {\n\t\tif (*err != 0 && *err != WTAP_ERR_SHORT_READ)\n\t\t\treturn WTAP_OPEN_ERROR;\n\t\treturn WTAP_OPEN_NOT_MINE;\n\t}\n\n\twth->file_encap = WTAP_ENCAP_PER_PACKET;\n\twth->file_type_subtype = WTAP_FILE_TYPE_SUBTYPE_TOSHIBA;\n\twth->snapshot_length = 0; /* not known */\n\twth->subtype_read = toshiba_read;\n\twth->subtype_seek_read = toshiba_seek_read;\n\twth->file_tsprec = WTAP_TSPREC_CSEC;\n\n\treturn WTAP_OPEN_MINE;\n}\n\n/* Find the next packet and parse it; called from wtap_read(). */\nstatic gboolean toshiba_read(wtap *wth, int *err, gchar **err_info,\n    gint64 *data_offset)\n{\n\tgint64\toffset;\n\n\t/* Find the next packet */\n\toffset = toshiba_seek_next_packet(wth, err, err_info);\n\tif (offset < 1)\n\t\treturn FALSE;\n\t*data_offset = offset;\n\n\t/* Parse the packet */\n\treturn parse_toshiba_packet(wth->fh, &wth->phdr, wth->frame_buffer,\n\t    err, err_info);\n}\n\n/* Used to read packets in random-access fashion */\nstatic gboolean\ntoshiba_seek_read(wtap *wth, gint64 seek_off,\n\tstruct wtap_pkthdr *phdr, Buffer *buf,\n\tint *err, gchar **err_info)\n{\n\tif (file_seek(wth->random_fh, seek_off - 1, SEEK_SET, err) == -1)\n\t\treturn FALSE;\n\n\tif (!parse_toshiba_packet(wth->random_fh, phdr, buf, err, err_info)) {\n\t\tif (*err == 0)\n\t\t\t*err = WTAP_ERR_SHORT_READ;\n\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}\n\n/* Parses a packet. */\nstatic gboolean\nparse_toshiba_packet(FILE_T fh, struct wtap_pkthdr *phdr, Buffer *buf,\n    int *err, gchar **err_info)\n{\n\tunion wtap_pseudo_header *pseudo_header = &phdr->pseudo_header;\n\tchar\tline[TOSHIBA_LINE_LENGTH];\n\tint\tnum_items_scanned;\n\tguint\tpkt_len;\n\tint\tpktnum, hr, min, sec, csec;\n\tchar\tchannel[10], direction[10];\n\tint\ti, hex_lines;\n\tguint8\t*pd;\n\n\t/* Our file pointer should be on the line containing the\n\t * summary information for a packet. Read in that line and\n\t * extract the useful information\n\t */\n\tif (file_gets(line, TOSHIBA_LINE_LENGTH, fh) == NULL) {\n\t\t*err = file_error(fh, err_info);\n\t\tif (*err == 0) {\n\t\t\t*err = WTAP_ERR_SHORT_READ;\n\t\t}\n\t\treturn FALSE;\n\t}\n\n\t/* Find text in line after \"[No.\". Limit the length of the\n\t * two strings since we have fixed buffers for channel[] and\n\t * direction[] */\n\tnum_items_scanned = sscanf(line, \"%9d] %2d:%2d:%2d.%9d %9s %9s\",\n\t\t\t&pktnum, &hr, &min, &sec, &csec, channel, direction);\n\n\tif (num_items_scanned != 7) {\n\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t*err_info = g_strdup(\"toshiba: record header isn't valid\");\n\t\treturn FALSE;\n\t}\n\n\t/* Scan lines until we find the OFFSET line. In a \"telnet\" trace,\n\t * this will be the next line. But if you save your telnet session\n\t * to a file from within a Windows-based telnet client, it may\n\t * put in line breaks at 80 columns (or however big your \"telnet\" box\n\t * is). CRT (a Windows telnet app from VanDyke) does this.\n\t * Here we assume that 80 columns will be the minimum size, and that\n\t * the OFFSET line is not broken in the middle. It's the previous\n\t * line that is normally long and can thus be broken at column 80.\n\t */\n\tdo {\n\t\tif (file_gets(line, TOSHIBA_LINE_LENGTH, fh) == NULL) {\n\t\t\t*err = file_error(fh, err_info);\n\t\t\tif (*err == 0) {\n\t\t\t\t*err = WTAP_ERR_SHORT_READ;\n\t\t\t}\n\t\t\treturn FALSE;\n\t\t}\n\n\t\t/* Check for \"OFFSET 0001-0203\" at beginning of line */\n\t\tline[16] = '\\0';\n\n\t} while (strcmp(line, \"OFFSET 0001-0203\") != 0);\n\n\tnum_items_scanned = sscanf(line+64, \"LEN=%9u\", &pkt_len);\n\tif (num_items_scanned != 1) {\n\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t*err_info = g_strdup(\"toshiba: OFFSET line doesn't have valid LEN item\");\n\t\treturn FALSE;\n\t}\n\tif (pkt_len > WTAP_MAX_PACKET_SIZE) {\n\t\t/*\n\t\t * Probably a corrupt capture file; don't blow up trying\n\t\t * to allocate space for an immensely-large packet.\n\t\t */\n\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t*err_info = g_strdup_printf(\"toshiba: File has %u-byte packet, bigger than maximum of %u\",\n\t\t    pkt_len, WTAP_MAX_PACKET_SIZE);\n\t\treturn FALSE;\n\t}\n\n\tphdr->rec_type = REC_TYPE_PACKET;\n\tphdr->presence_flags = WTAP_HAS_TS|WTAP_HAS_CAP_LEN;\n\tphdr->ts.secs = hr * 3600 + min * 60 + sec;\n\tphdr->ts.nsecs = csec * 10000000;\n\tphdr->caplen = pkt_len;\n\tphdr->len = pkt_len;\n\n\tswitch (channel[0]) {\n\t\tcase 'B':\n\t\t\tphdr->pkt_encap = WTAP_ENCAP_ISDN;\n\t\t\tpseudo_header->isdn.uton = (direction[0] == 'T');\n\t\t\tpseudo_header->isdn.channel = (guint8)\n\t\t\t    strtol(&channel[1], NULL, 10);\n\t\t\tbreak;\n\n\t\tcase 'D':\n\t\t\tphdr->pkt_encap = WTAP_ENCAP_ISDN;\n\t\t\tpseudo_header->isdn.uton = (direction[0] == 'T');\n\t\t\tpseudo_header->isdn.channel = 0;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tphdr->pkt_encap = WTAP_ENCAP_ETHERNET;\n\t\t\t/* XXX - is there an FCS in the frame? */\n\t\t\tpseudo_header->eth.fcs_len = -1;\n\t\t\tbreak;\n\t}\n\n\t/* Make sure we have enough room for the packet */\n\tws_buffer_assure_space(buf, pkt_len);\n\tpd = ws_buffer_start_ptr(buf);\n\n\t/* Calculate the number of hex dump lines, each\n\t * containing 16 bytes of data */\n\thex_lines = pkt_len / 16 + ((pkt_len % 16) ? 1 : 0);\n\n\tfor (i = 0; i < hex_lines; i++) {\n\t\tif (file_gets(line, TOSHIBA_LINE_LENGTH, fh) == NULL) {\n\t\t\t*err = file_error(fh, err_info);\n\t\t\tif (*err == 0) {\n\t\t\t\t*err = WTAP_ERR_SHORT_READ;\n\t\t\t}\n\t\t\treturn FALSE;\n\t\t}\n\t\tif (!parse_single_hex_dump_line(line, pd, i * 16)) {\n\t\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t\t*err_info = g_strdup(\"toshiba: hex dump not valid\");\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\treturn TRUE;\n}\n\n/*\n          1         2         3         4\n0123456789012345678901234567890123456789012345\n0000 : FF03 003D C000 0008 2145 0000 3A12 6500 ...=....!E..:.e.\n0010 : 003F 11E6 58CF C11A 8897 A401 0804 0400 .?..X...........\n0020 : 0100 01                                 ...\n*/\n\n#define START_POS\t7\n#define HEX_LENGTH\t((8 * 4) + 7) /* eight clumps of 4 bytes with 7 inner spaces */\n\n/* Take a string representing one line from a hex dump and converts the\n * text to binary data. We check the printed offset with the offset\n * we are passed to validate the record. We place the bytes in the buffer\n * at the specified offset.\n *\n * In the process, we're going to write all over the string.\n *\n * Returns TRUE if good hex dump, FALSE if bad.\n */\nstatic gboolean\nparse_single_hex_dump_line(char* rec, guint8 *buf, guint byte_offset) {\n\n\tint\t\tpos, i;\n\tchar\t\t*s;\n\tunsigned long\tvalue;\n\tguint16\t\tword_value;\n\n\t/* Get the byte_offset directly from the record */\n\trec[4] = '\\0';\n\ts = rec;\n\tvalue = strtoul(s, NULL, 16);\n\n\tif (value != byte_offset) {\n\t\treturn FALSE;\n\t}\n\n\t/* Go through the substring representing the values and:\n\t *      1. Replace any spaces with '0's\n\t *      2. Place \\0's every 5 bytes (to terminate the string)\n\t *\n\t * Then read the eight sets of hex bytes\n\t */\n\n\tfor (pos = START_POS; pos < START_POS + HEX_LENGTH; pos++) {\n\t\tif (rec[pos] == ' ') {\n\t\t\trec[pos] = '0';\n\t\t}\n\t}\n\n\tpos = START_POS;\n\tfor (i = 0; i < 8; i++) {\n\t\trec[pos+4] = '\\0';\n\n\t\tword_value = (guint16) strtoul(&rec[pos], NULL, 16);\n\t\tbuf[byte_offset + i * 2 + 0] = (guint8) (word_value >> 8);\n\t\tbuf[byte_offset + i * 2 + 1] = (guint8) (word_value & 0x00ff);\n\t\tpos += 5;\n\t}\n\n\treturn TRUE;\n}\n\n/*\n * Editor modelines  -  http://www.wireshark.org/tools/modelines.html\n *\n * Local variables:\n * c-basic-offset: 8\n * tab-width: 8\n * indent-tabs-mode: t\n * End:\n *\n * vi: set shiftwidth=8 tabstop=8 noexpandtab:\n * :indentSize=8:tabSize=8:noTabs=false:\n */\n", "code_before": "/* toshiba.c\n *\n * Wiretap Library\n * Copyright (c) 1998 by Gilbert Ramirez <gram@alumni.rice.edu>\n *\n * SPDX-License-Identifier: GPL-2.0-or-later\n */\n\n#include \"config.h\"\n#include \"toshiba.h\"\n#include \"wtap-int.h\"\n#include \"file_wrappers.h\"\n\n#include <stdlib.h>\n#include <string.h>\n\n#include <wsutil/pint.h>\n\n/*\n * Toshiba ISDN Router\n *\n * An under-documented command that the router supports in a telnet session\n * is \"snoop\" (not related to the Solaris \"snoop\" command). If you give\n * it the \"dump\" option (either by letting \"snoop\" query you for its next\n * argument, or typing \"snoop dump\" on the command line), you'll get a hex\n * dump of all packets across the router (except of your own telnet session\n * -- good thinking Toshiba!). You can select a certain channel to sniff\n * (LAN, B1, B2, D), but the default is all channels.  You save this hex\n * dump to disk with 'script' or by 'telnet | tee'. Wiretap will read the\n * ASCII hex dump and convert it to binary data.\n*/\n\n/* This module reads the output of the 'snoop' command in the Toshiba\n * TR-600 and TR-650 \"Compact\" ISDN Routers. You can telnet to the\n * router and run 'snoop' on the different channels, and at different\n * detail levels. Be sure to choose the 'dump' level to get the hex dump.\n * The 'snoop' command has nothing to do with the Solaris 'snoop'\n * command, except that they both capture packets.\n */\n\n/*\n   Example 'snoop' output data:\n\nScript started on Thu Sep  9 21:48:49 1999\n\u001b]0;gram@nirvana:/tmp\u0007$ telnet 10.0.0.254\nTrying 10.0.0.254...\nConnected to 10.0.0.254.\nEscape character is '^]'.\n\n\nTR-600(tr600) System Console\n\nLogin:admin\nPassword:*******\n*--------------------------------------------------------*\n|             T O S H I B A    T R - 6 0 0               |\n|                 <  Compact Router >                    |\n|                       V1.02.02                         |\n|                                                        |\n|  (C) Copyright TOSHIBA Corp. 1997 All rights reserved. |\n*--------------------------------------------------------*\n\ntr600>snoop dump b1\n Trace start?(on/off/dump/dtl)->dump\n IP Address?->b1\nB1 Port Filetering\nTrace start(Dump Mode)...\n\ntr600>[No.1] 00:00:09.14 B1:1 Tx 207.193.26.136->151.164.1.8 DNS  SPORT=1028 LEN=38 CHKSUM=4FD4 ID=2390 Query RD QCNT=1 pow.zing.org?\nOFFSET 0001-0203-0405-0607-0809-0A0B-0C0D-0E0F 0123456789ABCDEF LEN=67\n0000 : FF03 003D C000 0008 2145 0000 3A12 6500 ...=....!E..:.e.\n0010 : 003F 11E6 58CF C11A 8897 A401 0804 0400 .?..X...........\n0020 : 3500 264F D409 5601 0000 0100 0000 0000 5.&O..V.........\n0030 : 0003 706F 7704 7A69 6E67 036F 7267 0000 ..pow.zing.org..\n0040 : 0100 01                                 ...\n\n[No.2] 00:00:09.25 B1:1 Rx 151.164.1.8->207.193.26.136 DNS  DPORT=1028 LEN=193 CHKSUM=3E06 ID=2390 Answer RD RA QCNT=1 pow.zing.org? ANCNT=1 pow.zing.org=206.57.36.90 TTL=2652\nOFFSET 0001-0203-0405-0607-0809-0A0B-0C0D-0E0F 0123456789ABCDEF LEN=222\n0000 : FF03 003D C000 0013 2145 0000 D590 9340 ...=....!E.....@\n0010 : 00F7 116F 8E97 A401 08CF C11A 8800 3504 ...o..........5.\n0020 : 0400 C13E 0609 5681 8000 0100 0100 0300 ...>..V.........\n0030 : 0303 706F 7704 7A69 6E67 036F 7267 0000 ..pow.zing.org..\n0040 : 0100 01C0 0C00 0100 0100 000A 5C00 04CE ............\\...\n0050 : 3924 5A04 5A49 4E47 036F 7267 0000 0200 9$Z.ZING.org....\n0060 : 0100 016F 5B00 0D03 4841 4E03 5449 5703 ...o[...HAN.TIW.\n0070 : 4E45 5400 C02E 0002 0001 0001 6F5B 0006 NET.........o[..\n0080 : 034E 5331 C02E C02E 0002 0001 0001 6F5B .NS1..........o[\n0090 : 001C 0854 414C 4945 5349 4E0D 434F 4E46 ...TALIESIN.CONF\n00A0 : 4142 554C 4154 494F 4E03 434F 4D00 C042 ABULATION.COM..B\n00B0 : 0001 0001 0001 51EC 0004 CE39 2406 C05B ......Q....9$..[\n00C0 : 0001 0001 0001 6F5B 0004 CE39 245A C06D ......o[...9$Z.m\n00D0 : 0001 0001 0001 4521 0004 187C 1F01      ......E!...|..\n\n */\n\n/* Magic text to check for toshiba-ness of file */\nstatic const char toshiba_hdr_magic[]  =\n{ 'T', ' ', 'O', ' ', 'S', ' ', 'H', ' ', 'I', ' ', 'B', ' ', 'A' };\n#define TOSHIBA_HDR_MAGIC_SIZE  array_length(toshiba_hdr_magic)\n\n/* Magic text for start of packet */\nstatic const char toshiba_rec_magic[]  = { '[', 'N', 'o', '.' };\n#define TOSHIBA_REC_MAGIC_SIZE  array_length(toshiba_rec_magic)\n\nstatic bool toshiba_read(wtap *wth, wtap_rec *rec, int *err,\n\tchar **err_info, int64_t *data_offset);\nstatic bool toshiba_seek_read(wtap *wth, int64_t seek_off, wtap_rec *rec,\n\tint *err, char **err_info);\nstatic bool parse_single_hex_dump_line(char* rec, uint8_t *buf,\n\tunsigned byte_offset);\nstatic bool parse_toshiba_packet(FILE_T fh, wtap_rec *rec, int *err,\n\tchar **err_info);\n\nstatic int toshiba_file_type_subtype = -1;\n\nvoid register_toshiba(void);\n\n/* Seeks to the beginning of the next packet, and returns the\n   byte offset.  Returns -1 on failure, and sets \"*err\" to the error\n   and \"*err_info\" to null or an additional error string. */\nstatic int64_t toshiba_seek_next_packet(wtap *wth, int *err, char **err_info)\n{\n\tint byte;\n\tunsigned level = 0;\n\tint64_t cur_off;\n\n\twhile ((byte = file_getc(wth->fh)) != EOF) {\n\t\tif (byte == toshiba_rec_magic[level]) {\n\t\t\tlevel++;\n\t\t\tif (level >= TOSHIBA_REC_MAGIC_SIZE) {\n\t\t\t\t/* note: we're leaving file pointer right after the magic characters */\n\t\t\t\tcur_off = file_tell(wth->fh);\n\t\t\t\tif (cur_off == -1) {\n\t\t\t\t\t/* Error. */\n\t\t\t\t\t*err = file_error(wth->fh, err_info);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\treturn cur_off + 1;\n\t\t\t}\n\t\t} else {\n\t\t\tlevel = 0;\n\t\t}\n\t}\n\t/* EOF or error. */\n\t*err = file_error(wth->fh, err_info);\n\treturn -1;\n}\n\n#define TOSHIBA_HEADER_LINES_TO_CHECK\t200\n#define TOSHIBA_LINE_LENGTH\t\t240\n\n/* Look through the first part of a file to see if this is\n * a Toshiba trace file.\n *\n * Returns true if it is, false if it isn't or if we get an I/O error;\n * if we get an I/O error, \"*err\" will be set to a non-zero value and\n * \"*err_info\" will be set to null or an additional error string.\n */\nstatic bool toshiba_check_file_type(wtap *wth, int *err, char **err_info)\n{\n\tchar\tbuf[TOSHIBA_LINE_LENGTH];\n\tunsigned\ti, reclen, level, line;\n\tchar\tbyte;\n\n\tbuf[TOSHIBA_LINE_LENGTH-1] = 0;\n\n\tfor (line = 0; line < TOSHIBA_HEADER_LINES_TO_CHECK; line++) {\n\t\tif (file_gets(buf, TOSHIBA_LINE_LENGTH, wth->fh) == NULL) {\n\t\t\t/* EOF or error. */\n\t\t\t*err = file_error(wth->fh, err_info);\n\t\t\treturn false;\n\t\t}\n\n\t\treclen = (unsigned) strlen(buf);\n\t\tif (reclen < TOSHIBA_HDR_MAGIC_SIZE) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tlevel = 0;\n\t\tfor (i = 0; i < reclen; i++) {\n\t\t\tbyte = buf[i];\n\t\t\tif (byte == toshiba_hdr_magic[level]) {\n\t\t\t\tlevel++;\n\t\t\t\tif (level >= TOSHIBA_HDR_MAGIC_SIZE) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlevel = 0;\n\t\t\t}\n\t\t}\n\t}\n\t*err = 0;\n\treturn false;\n}\n\n\nwtap_open_return_val toshiba_open(wtap *wth, int *err, char **err_info)\n{\n\t/* Look for Toshiba header */\n\tif (!toshiba_check_file_type(wth, err, err_info)) {\n\t\tif (*err != 0 && *err != WTAP_ERR_SHORT_READ)\n\t\t\treturn WTAP_OPEN_ERROR;\n\t\treturn WTAP_OPEN_NOT_MINE;\n\t}\n\n\twth->file_encap = WTAP_ENCAP_PER_PACKET;\n\twth->file_type_subtype = toshiba_file_type_subtype;\n\twth->snapshot_length = 0; /* not known */\n\twth->subtype_read = toshiba_read;\n\twth->subtype_seek_read = toshiba_seek_read;\n\twth->file_tsprec = WTAP_TSPREC_10_MSEC;\n\n\treturn WTAP_OPEN_MINE;\n}\n\n/* Find the next packet and parse it; called from wtap_read(). */\nstatic bool toshiba_read(wtap *wth, wtap_rec *rec, int *err,\n\tchar **err_info, int64_t *data_offset)\n{\n\tint64_t\toffset;\n\n\t/* Find the next packet */\n\toffset = toshiba_seek_next_packet(wth, err, err_info);\n\tif (offset < 1)\n\t\treturn false;\n\t*data_offset = offset;\n\n\t/* Parse the packet */\n\treturn parse_toshiba_packet(wth->fh, rec, err, err_info);\n}\n\n/* Used to read packets in random-access fashion */\nstatic bool\ntoshiba_seek_read(wtap *wth, int64_t seek_off, wtap_rec *rec, int *err,\n\tchar **err_info)\n{\n\tif (file_seek(wth->random_fh, seek_off - 1, SEEK_SET, err) == -1)\n\t\treturn false;\n\n\tif (!parse_toshiba_packet(wth->random_fh, rec, err, err_info)) {\n\t\tif (*err == 0)\n\t\t\t*err = WTAP_ERR_SHORT_READ;\n\t\treturn false;\n\t}\n\treturn true;\n}\n\n/* Parses a packet. */\nstatic bool\nparse_toshiba_packet(FILE_T fh, wtap_rec *rec, int *err, char **err_info)\n{\n\tunion wtap_pseudo_header *pseudo_header = &rec->rec_header.packet_header.pseudo_header;\n\tchar\tline[TOSHIBA_LINE_LENGTH];\n\tint\tnum_items_scanned;\n\tint\tpkt_len, pktnum, hr, min, sec, csec;\n\tchar\tchannel[10], direction[10];\n\tint\ti, hex_lines;\n\tuint8_t\t*pd;\n\n\t/* Our file pointer should be on the line containing the\n\t * summary information for a packet. Read in that line and\n\t * extract the useful information\n\t */\n\tif (file_gets(line, TOSHIBA_LINE_LENGTH, fh) == NULL) {\n\t\t*err = file_error(fh, err_info);\n\t\tif (*err == 0) {\n\t\t\t*err = WTAP_ERR_SHORT_READ;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/* Find text in line after \"[No.\". Limit the length of the\n\t * two strings since we have fixed buffers for channel[] and\n\t * direction[] */\n\tnum_items_scanned = sscanf(line, \"%9d] %2d:%2d:%2d.%9d %9s %9s\",\n\t\t\t&pktnum, &hr, &min, &sec, &csec, channel, direction);\n\n\tif (num_items_scanned != 7) {\n\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t*err_info = g_strdup(\"toshiba: record header isn't valid\");\n\t\treturn false;\n\t}\n\n\t/* Scan lines until we find the OFFSET line. In a \"telnet\" trace,\n\t * this will be the next line. But if you save your telnet session\n\t * to a file from within a Windows-based telnet client, it may\n\t * put in line breaks at 80 columns (or however big your \"telnet\" box\n\t * is). CRT (a Windows telnet app from VanDyke) does this.\n\t * Here we assume that 80 columns will be the minimum size, and that\n\t * the OFFSET line is not broken in the middle. It's the previous\n\t * line that is normally long and can thus be broken at column 80.\n\t */\n\tdo {\n\t\tif (file_gets(line, TOSHIBA_LINE_LENGTH, fh) == NULL) {\n\t\t\t*err = file_error(fh, err_info);\n\t\t\tif (*err == 0) {\n\t\t\t\t*err = WTAP_ERR_SHORT_READ;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t/* Check for \"OFFSET 0001-0203\" at beginning of line */\n\t\tline[16] = '\\0';\n\n\t} while (strcmp(line, \"OFFSET 0001-0203\") != 0);\n\n\tnum_items_scanned = sscanf(line+64, \"LEN=%9d\", &pkt_len);\n\tif (num_items_scanned != 1) {\n\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t*err_info = g_strdup(\"toshiba: OFFSET line doesn't have valid LEN item\");\n\t\treturn false;\n\t}\n\tif (pkt_len < 0) {\n\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t*err_info = g_strdup(\"toshiba: packet header has a negative packet length\");\n\t\treturn false;\n\t}\n\tif ((unsigned)pkt_len > WTAP_MAX_PACKET_SIZE_STANDARD) {\n\t\t/*\n\t\t * Probably a corrupt capture file; don't blow up trying\n\t\t * to allocate space for an immensely-large packet.\n\t\t */\n\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t*err_info = ws_strdup_printf(\"toshiba: File has %u-byte packet, bigger than maximum of %u\",\n\t\t    (unsigned)pkt_len, WTAP_MAX_PACKET_SIZE_STANDARD);\n\t\treturn false;\n\t}\n\n\twtap_setup_packet_rec(rec, WTAP_ENCAP_UNKNOWN);\n\trec->block = wtap_block_create(WTAP_BLOCK_PACKET);\n\trec->presence_flags = WTAP_HAS_TS|WTAP_HAS_CAP_LEN;\n\trec->ts.secs = hr * 3600 + min * 60 + sec;\n\trec->ts.nsecs = csec * 10000000;\n\trec->rec_header.packet_header.caplen = pkt_len;\n\trec->rec_header.packet_header.len = pkt_len;\n\n\tswitch (channel[0]) {\n\t\tcase 'B':\n\t\t\trec->rec_header.packet_header.pkt_encap = WTAP_ENCAP_ISDN;\n\t\t\tpseudo_header->isdn.uton = (direction[0] == 'T');\n\t\t\tpseudo_header->isdn.channel = (uint8_t)\n\t\t\t    strtol(&channel[1], NULL, 10);\n\t\t\tbreak;\n\n\t\tcase 'D':\n\t\t\trec->rec_header.packet_header.pkt_encap = WTAP_ENCAP_ISDN;\n\t\t\tpseudo_header->isdn.uton = (direction[0] == 'T');\n\t\t\tpseudo_header->isdn.channel = 0;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\trec->rec_header.packet_header.pkt_encap = WTAP_ENCAP_ETHERNET;\n\t\t\t/* XXX - is there an FCS in the frame? */\n\t\t\tpseudo_header->eth.fcs_len = -1;\n\t\t\tbreak;\n\t}\n\n\t/* Make sure we have enough room for the packet */\n\tws_buffer_assure_space(&rec->data, pkt_len);\n\tpd = ws_buffer_start_ptr(&rec->data);\n\n\t/* Calculate the number of hex dump lines, each\n\t * containing 16 bytes of data */\n\thex_lines = pkt_len / 16 + ((pkt_len % 16) ? 1 : 0);\n\n\tfor (i = 0; i < hex_lines; i++) {\n\t\tif (file_gets(line, TOSHIBA_LINE_LENGTH, fh) == NULL) {\n\t\t\t*err = file_error(fh, err_info);\n\t\t\tif (*err == 0) {\n\t\t\t\t*err = WTAP_ERR_SHORT_READ;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\tif (!parse_single_hex_dump_line(line, pd, i * 16)) {\n\t\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t\t*err_info = g_strdup(\"toshiba: hex dump not valid\");\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\n/*\n          1         2         3         4\n0123456789012345678901234567890123456789012345\n0000 : FF03 003D C000 0008 2145 0000 3A12 6500 ...=....!E..:.e.\n0010 : 003F 11E6 58CF C11A 8897 A401 0804 0400 .?..X...........\n0020 : 0100 01                                 ...\n*/\n\n#define START_POS\t7\n#define HEX_LENGTH\t((8 * 4) + 7) /* eight clumps of 4 bytes with 7 inner spaces */\n\n/* Take a string representing one line from a hex dump and converts the\n * text to binary data. We check the printed offset with the offset\n * we are passed to validate the record. We place the bytes in the buffer\n * at the specified offset.\n *\n * In the process, we're going to write all over the string.\n *\n * Returns true if good hex dump, false if bad.\n */\nstatic bool\nparse_single_hex_dump_line(char* rec, uint8_t *buf, unsigned byte_offset) {\n\n\tint\t\tpos, i;\n\tchar\t\t*s;\n\tunsigned long\tvalue;\n\tuint16_t\t\tword_value;\n\n\t/* Get the byte_offset directly from the record */\n\trec[4] = '\\0';\n\ts = rec;\n\tvalue = strtoul(s, NULL, 16);\n\n\tif (value != byte_offset) {\n\t\treturn false;\n\t}\n\n\t/* Go through the substring representing the values and:\n\t *      1. Replace any spaces with '0's\n\t *      2. Place \\0's every 5 bytes (to terminate the string)\n\t *\n\t * Then read the eight sets of hex bytes\n\t */\n\n\tfor (pos = START_POS; pos < START_POS + HEX_LENGTH; pos++) {\n\t\tif (rec[pos] == ' ') {\n\t\t\trec[pos] = '0';\n\t\t}\n\t}\n\n\tpos = START_POS;\n\tfor (i = 0; i < 8; i++) {\n\t\trec[pos+4] = '\\0';\n\n\t\tword_value = (uint16_t) strtoul(&rec[pos], NULL, 16);\n\t\tphtonu16(&buf[byte_offset + i * 2], word_value);\n\t\tpos += 5;\n\t}\n\n\treturn true;\n}\n\nstatic const struct supported_block_type toshiba_blocks_supported[] = {\n\t/*\n\t * We support packet blocks, with no comments or other options.\n\t */\n\t{ WTAP_BLOCK_PACKET, MULTIPLE_BLOCKS_SUPPORTED, NO_OPTIONS_SUPPORTED }\n};\n\nstatic const struct file_type_subtype_info toshiba_info = {\n\t\"Toshiba Compact ISDN Router snoop\", \"toshiba\", \"txt\", NULL,\n\tfalse, BLOCKS_SUPPORTED(toshiba_blocks_supported),\n\tNULL, NULL, NULL\n};\n\nvoid register_toshiba(void)\n{\n\ttoshiba_file_type_subtype = wtap_register_file_type_subtype(&toshiba_info);\n\n\t/*\n\t * Register name for backwards compatibility with the\n\t * wtap_filetypes table in Lua.\n\t */\n\twtap_register_backwards_compatibility_lua_name(\"TOSHIBA\",\n\t    toshiba_file_type_subtype);\n}\n\n/*\n * Editor modelines  -  https://www.wireshark.org/tools/modelines.html\n *\n * Local variables:\n * c-basic-offset: 8\n * tab-width: 8\n * indent-tabs-mode: t\n * End:\n *\n * vi: set shiftwidth=8 tabstop=8 noexpandtab:\n * :indentSize=8:tabSize=8:noTabs=false:\n */\n", "patch": "@@ -98,11 +98,6 @@ static const char toshiba_hdr_magic[]  =\n static const char toshiba_rec_magic[]  = { '[', 'N', 'o', '.' };\n #define TOSHIBA_REC_MAGIC_SIZE  (sizeof toshiba_rec_magic  / sizeof toshiba_rec_magic[0])\n \n-/*\n- * XXX - is this the biggest packet we can get?\n- */\n-#define TOSHIBA_MAX_PACKET_LEN\t16384\n-\n static gboolean toshiba_read(wtap *wth, int *err, gchar **err_info,\n \tgint64 *data_offset);\n static gboolean toshiba_seek_read(wtap *wth, gint64 seek_off,\n@@ -253,7 +248,8 @@ parse_toshiba_packet(FILE_T fh, struct wtap_pkthdr *phdr, Buffer *buf,\n \tunion wtap_pseudo_header *pseudo_header = &phdr->pseudo_header;\n \tchar\tline[TOSHIBA_LINE_LENGTH];\n \tint\tnum_items_scanned;\n-\tint\tpkt_len, pktnum, hr, min, sec, csec;\n+\tguint\tpkt_len;\n+\tint\tpktnum, hr, min, sec, csec;\n \tchar\tchannel[10], direction[10];\n \tint\ti, hex_lines;\n \tguint8\t*pd;\n@@ -305,12 +301,22 @@ parse_toshiba_packet(FILE_T fh, struct wtap_pkthdr *phdr, Buffer *buf,\n \n \t} while (strcmp(line, \"OFFSET 0001-0203\") != 0);\n \n-\tnum_items_scanned = sscanf(line+64, \"LEN=%9d\", &pkt_len);\n+\tnum_items_scanned = sscanf(line+64, \"LEN=%9u\", &pkt_len);\n \tif (num_items_scanned != 1) {\n \t\t*err = WTAP_ERR_BAD_FILE;\n \t\t*err_info = g_strdup(\"toshiba: OFFSET line doesn't have valid LEN item\");\n \t\treturn FALSE;\n \t}\n+\tif (pkt_len > WTAP_MAX_PACKET_SIZE) {\n+\t\t/*\n+\t\t * Probably a corrupt capture file; don't blow up trying\n+\t\t * to allocate space for an immensely-large packet.\n+\t\t */\n+\t\t*err = WTAP_ERR_BAD_FILE;\n+\t\t*err_info = g_strdup_printf(\"toshiba: File has %u-byte packet, bigger than maximum of %u\",\n+\t\t    pkt_len, WTAP_MAX_PACKET_SIZE);\n+\t\treturn FALSE;\n+\t}\n \n \tphdr->rec_type = REC_TYPE_PACKET;\n \tphdr->presence_flags = WTAP_HAS_TS|WTAP_HAS_CAP_LEN;\n@@ -341,7 +347,7 @@ parse_toshiba_packet(FILE_T fh, struct wtap_pkthdr *phdr, Buffer *buf,\n \t}\n \n \t/* Make sure we have enough room for the packet */\n-\tws_buffer_assure_space(buf, TOSHIBA_MAX_PACKET_LEN);\n+\tws_buffer_assure_space(buf, pkt_len);\n \tpd = ws_buffer_start_ptr(buf);\n \n \t/* Calculate the number of hex dump lines, each", "file_path": "files/2016_8\\52", "file_language": "c", "file_name": "wiretap/toshiba.c", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}], "outdated": 0}
{"index": 15, "cve_id": "CVE-2016-5355", "cwe_id": ["CWE-20"], "cve_language": "C", "cve_description": "wiretap/toshiba.c in the Toshiba file parser in Wireshark 1.12.x before 1.12.12 and 2.x before 2.0.4 mishandles sscanf unsigned-integer processing, which allows remote attackers to cause a denial of service (application crash) via a crafted file.", "cvss": "5.9", "publish_date": "August 7, 2016", "AV": "NETWORK", "AC": "HIGH", "PR": "NONE", "UI": "NONE", "S": "UNCHANGED", "C": "NONE", "I": "NONE", "A": "HIGH", "commit_id": "3270dfac43da861c714df76513456b46765ff47f", "commit_message": "Don't treat the packet length as unsigned.\n\nThe scanf family of functions are as annoyingly bad at handling unsigned\nnumbers as strtoul() is - both of them are perfectly willing to accept a\nvalue beginning with a negative sign as an unsigned value.  When using\nstrtoul(), you can compensate for this by explicitly checking for a '-'\nas the first character of the string, but you can't do that with\nsscanf().\n\nSo revert to having pkt_len be signed, and scanning it with %d, but\ncheck for a negative value and fail if we see a negative value.\n\nBug: 12394\nChange-Id: I4b19b95f2e1ffc96dac5c91bff6698c246f52007\nReviewed-on: https://code.wireshark.org/review/15230\nReviewed-by: Guy Harris <guy@alum.mit.edu>", "commit_date": "2016-05-01T23:31:51Z", "project": "wireshark/wireshark", "url": "https://api.github.com/repos/wireshark/wireshark/commits/3270dfac43da861c714df76513456b46765ff47f", "html_url": "https://github.com/wireshark/wireshark/commit/3270dfac43da861c714df76513456b46765ff47f", "windows_before": "", "windows_after": "", "parents": [{"commit_id_before": "a66628e425db725df1ac52a3c573a03357060ddd", "url_before": "https://api.github.com/repos/wireshark/wireshark/commits/a66628e425db725df1ac52a3c573a03357060ddd", "html_url_before": "https://github.com/wireshark/wireshark/commit/a66628e425db725df1ac52a3c573a03357060ddd"}], "details": [{"raw_url": "https://github.com/wireshark/wireshark/raw/3270dfac43da861c714df76513456b46765ff47f/wiretap/toshiba.c", "code": "/* toshiba.c\n *\n * Wiretap Library\n * Copyright (c) 1998 by Gilbert Ramirez <gram@alumni.rice.edu>\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version 2\n * of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */\n\n#include \"config.h\"\n#include \"wtap-int.h\"\n#include \"toshiba.h\"\n#include \"file_wrappers.h\"\n\n#include <stdlib.h>\n#include <string.h>\n\n/* This module reads the output of the 'snoop' command in the Toshiba\n * TR-600 and TR-650 \"Compact\" ISDN Routers. You can telnet to the\n * router and run 'snoop' on the different channels, and at different\n * detail levels. Be sure to choose the 'dump' level to get the hex dump.\n * The 'snoop' command has nothing to do with the Solaris 'snoop'\n * command, except that they both capture packets.\n */\n\n/*\n   Example 'snoop' output data:\n\nScript started on Thu Sep  9 21:48:49 1999\n\u001b]0;gram@nirvana:/tmp\u0007$ telnet 10.0.0.254\nTrying 10.0.0.254...\nConnected to 10.0.0.254.\nEscape character is '^]'.\n\n\nTR-600(tr600) System Console\n\nLogin:admin\nPassword:*******\n*--------------------------------------------------------*\n|             T O S H I B A    T R - 6 0 0               |\n|                 <  Compact Router >                    |\n|                       V1.02.02                         |\n|                                                        |\n|  (C) Copyright TOSHIBA Corp. 1997 All rights reserved. |\n*--------------------------------------------------------*\n\ntr600>snoop dump b1\n Trace start?(on/off/dump/dtl)->dump\n IP Address?->b1\nB1 Port Filetering\nTrace start(Dump Mode)...\n\ntr600>[No.1] 00:00:09.14 B1:1 Tx 207.193.26.136->151.164.1.8 DNS  SPORT=1028 LEN=38 CHKSUM=4FD4 ID=2390 Query RD QCNT=1 pow.zing.org?\nOFFSET 0001-0203-0405-0607-0809-0A0B-0C0D-0E0F 0123456789ABCDEF LEN=67\n0000 : FF03 003D C000 0008 2145 0000 3A12 6500 ...=....!E..:.e.\n0010 : 003F 11E6 58CF C11A 8897 A401 0804 0400 .?..X...........\n0020 : 3500 264F D409 5601 0000 0100 0000 0000 5.&O..V.........\n0030 : 0003 706F 7704 7A69 6E67 036F 7267 0000 ..pow.zing.org..\n0040 : 0100 01                                 ...\n\n[No.2] 00:00:09.25 B1:1 Rx 151.164.1.8->207.193.26.136 DNS  DPORT=1028 LEN=193 CHKSUM=3E06 ID=2390 Answer RD RA QCNT=1 pow.zing.org? ANCNT=1 pow.zing.org=206.57.36.90 TTL=2652\nOFFSET 0001-0203-0405-0607-0809-0A0B-0C0D-0E0F 0123456789ABCDEF LEN=222\n0000 : FF03 003D C000 0013 2145 0000 D590 9340 ...=....!E.....@\n0010 : 00F7 116F 8E97 A401 08CF C11A 8800 3504 ...o..........5.\n0020 : 0400 C13E 0609 5681 8000 0100 0100 0300 ...>..V.........\n0030 : 0303 706F 7704 7A69 6E67 036F 7267 0000 ..pow.zing.org..\n0040 : 0100 01C0 0C00 0100 0100 000A 5C00 04CE ............\\...\n0050 : 3924 5A04 5A49 4E47 036F 7267 0000 0200 9$Z.ZING.org....\n0060 : 0100 016F 5B00 0D03 4841 4E03 5449 5703 ...o[...HAN.TIW.\n0070 : 4E45 5400 C02E 0002 0001 0001 6F5B 0006 NET.........o[..\n0080 : 034E 5331 C02E C02E 0002 0001 0001 6F5B .NS1..........o[\n0090 : 001C 0854 414C 4945 5349 4E0D 434F 4E46 ...TALIESIN.CONF\n00A0 : 4142 554C 4154 494F 4E03 434F 4D00 C042 ABULATION.COM..B\n00B0 : 0001 0001 0001 51EC 0004 CE39 2406 C05B ......Q....9$..[\n00C0 : 0001 0001 0001 6F5B 0004 CE39 245A C06D ......o[...9$Z.m\n00D0 : 0001 0001 0001 4521 0004 187C 1F01      ......E!...|..\n\n */\n\n/* Magic text to check for toshiba-ness of file */\nstatic const char toshiba_hdr_magic[]  =\n{ 'T', ' ', 'O', ' ', 'S', ' ', 'H', ' ', 'I', ' ', 'B', ' ', 'A' };\n#define TOSHIBA_HDR_MAGIC_SIZE  (sizeof toshiba_hdr_magic  / sizeof toshiba_hdr_magic[0])\n\n/* Magic text for start of packet */\nstatic const char toshiba_rec_magic[]  = { '[', 'N', 'o', '.' };\n#define TOSHIBA_REC_MAGIC_SIZE  (sizeof toshiba_rec_magic  / sizeof toshiba_rec_magic[0])\n\nstatic gboolean toshiba_read(wtap *wth, int *err, gchar **err_info,\n\tgint64 *data_offset);\nstatic gboolean toshiba_seek_read(wtap *wth, gint64 seek_off,\n\tstruct wtap_pkthdr *phdr, Buffer *buf, int *err, gchar **err_info);\nstatic gboolean parse_single_hex_dump_line(char* rec, guint8 *buf,\n\tguint byte_offset);\nstatic gboolean parse_toshiba_packet(FILE_T fh, struct wtap_pkthdr *phdr,\n\tBuffer *buf, int *err, gchar **err_info);\n\n/* Seeks to the beginning of the next packet, and returns the\n   byte offset.  Returns -1 on failure, and sets \"*err\" to the error\n   and \"*err_info\" to null or an additional error string. */\nstatic gint64 toshiba_seek_next_packet(wtap *wth, int *err, gchar **err_info)\n{\n\tint byte;\n\tguint level = 0;\n\tgint64 cur_off;\n\n\twhile ((byte = file_getc(wth->fh)) != EOF) {\n\t\tif (byte == toshiba_rec_magic[level]) {\n\t\t\tlevel++;\n\t\t\tif (level >= TOSHIBA_REC_MAGIC_SIZE) {\n\t\t\t\t/* note: we're leaving file pointer right after the magic characters */\n\t\t\t\tcur_off = file_tell(wth->fh);\n\t\t\t\tif (cur_off == -1) {\n\t\t\t\t\t/* Error. */\n\t\t\t\t\t*err = file_error(wth->fh, err_info);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\treturn cur_off + 1;\n\t\t\t}\n\t\t} else {\n\t\t\tlevel = 0;\n\t\t}\n\t}\n\t/* EOF or error. */\n\t*err = file_error(wth->fh, err_info);\n\treturn -1;\n}\n\n#define TOSHIBA_HEADER_LINES_TO_CHECK\t200\n#define TOSHIBA_LINE_LENGTH\t\t240\n\n/* Look through the first part of a file to see if this is\n * a Toshiba trace file.\n *\n * Returns TRUE if it is, FALSE if it isn't or if we get an I/O error;\n * if we get an I/O error, \"*err\" will be set to a non-zero value and\n * \"*err_info\" will be set to null or an additional error string.\n */\nstatic gboolean toshiba_check_file_type(wtap *wth, int *err, gchar **err_info)\n{\n\tchar\tbuf[TOSHIBA_LINE_LENGTH];\n\tguint\ti, reclen, level, line;\n\tchar\tbyte;\n\n\tbuf[TOSHIBA_LINE_LENGTH-1] = 0;\n\n\tfor (line = 0; line < TOSHIBA_HEADER_LINES_TO_CHECK; line++) {\n\t\tif (file_gets(buf, TOSHIBA_LINE_LENGTH, wth->fh) == NULL) {\n\t\t\t/* EOF or error. */\n\t\t\t*err = file_error(wth->fh, err_info);\n\t\t\treturn FALSE;\n\t\t}\n\n\t\treclen = (guint) strlen(buf);\n\t\tif (reclen < TOSHIBA_HDR_MAGIC_SIZE) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tlevel = 0;\n\t\tfor (i = 0; i < reclen; i++) {\n\t\t\tbyte = buf[i];\n\t\t\tif (byte == toshiba_hdr_magic[level]) {\n\t\t\t\tlevel++;\n\t\t\t\tif (level >= TOSHIBA_HDR_MAGIC_SIZE) {\n\t\t\t\t\treturn TRUE;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlevel = 0;\n\t\t\t}\n\t\t}\n\t}\n\t*err = 0;\n\treturn FALSE;\n}\n\n\nwtap_open_return_val toshiba_open(wtap *wth, int *err, gchar **err_info)\n{\n\t/* Look for Toshiba header */\n\tif (!toshiba_check_file_type(wth, err, err_info)) {\n\t\tif (*err != 0 && *err != WTAP_ERR_SHORT_READ)\n\t\t\treturn WTAP_OPEN_ERROR;\n\t\treturn WTAP_OPEN_NOT_MINE;\n\t}\n\n\twth->file_encap = WTAP_ENCAP_PER_PACKET;\n\twth->file_type_subtype = WTAP_FILE_TYPE_SUBTYPE_TOSHIBA;\n\twth->snapshot_length = 0; /* not known */\n\twth->subtype_read = toshiba_read;\n\twth->subtype_seek_read = toshiba_seek_read;\n\twth->file_tsprec = WTAP_TSPREC_CSEC;\n\n\treturn WTAP_OPEN_MINE;\n}\n\n/* Find the next packet and parse it; called from wtap_read(). */\nstatic gboolean toshiba_read(wtap *wth, int *err, gchar **err_info,\n    gint64 *data_offset)\n{\n\tgint64\toffset;\n\n\t/* Find the next packet */\n\toffset = toshiba_seek_next_packet(wth, err, err_info);\n\tif (offset < 1)\n\t\treturn FALSE;\n\t*data_offset = offset;\n\n\t/* Parse the packet */\n\treturn parse_toshiba_packet(wth->fh, &wth->phdr, wth->frame_buffer,\n\t    err, err_info);\n}\n\n/* Used to read packets in random-access fashion */\nstatic gboolean\ntoshiba_seek_read(wtap *wth, gint64 seek_off,\n\tstruct wtap_pkthdr *phdr, Buffer *buf,\n\tint *err, gchar **err_info)\n{\n\tif (file_seek(wth->random_fh, seek_off - 1, SEEK_SET, err) == -1)\n\t\treturn FALSE;\n\n\tif (!parse_toshiba_packet(wth->random_fh, phdr, buf, err, err_info)) {\n\t\tif (*err == 0)\n\t\t\t*err = WTAP_ERR_SHORT_READ;\n\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}\n\n/* Parses a packet. */\nstatic gboolean\nparse_toshiba_packet(FILE_T fh, struct wtap_pkthdr *phdr, Buffer *buf,\n    int *err, gchar **err_info)\n{\n\tunion wtap_pseudo_header *pseudo_header = &phdr->pseudo_header;\n\tchar\tline[TOSHIBA_LINE_LENGTH];\n\tint\tnum_items_scanned;\n\tint\tpkt_len, pktnum, hr, min, sec, csec;\n\tchar\tchannel[10], direction[10];\n\tint\ti, hex_lines;\n\tguint8\t*pd;\n\n\t/* Our file pointer should be on the line containing the\n\t * summary information for a packet. Read in that line and\n\t * extract the useful information\n\t */\n\tif (file_gets(line, TOSHIBA_LINE_LENGTH, fh) == NULL) {\n\t\t*err = file_error(fh, err_info);\n\t\tif (*err == 0) {\n\t\t\t*err = WTAP_ERR_SHORT_READ;\n\t\t}\n\t\treturn FALSE;\n\t}\n\n\t/* Find text in line after \"[No.\". Limit the length of the\n\t * two strings since we have fixed buffers for channel[] and\n\t * direction[] */\n\tnum_items_scanned = sscanf(line, \"%9d] %2d:%2d:%2d.%9d %9s %9s\",\n\t\t\t&pktnum, &hr, &min, &sec, &csec, channel, direction);\n\n\tif (num_items_scanned != 7) {\n\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t*err_info = g_strdup(\"toshiba: record header isn't valid\");\n\t\treturn FALSE;\n\t}\n\n\t/* Scan lines until we find the OFFSET line. In a \"telnet\" trace,\n\t * this will be the next line. But if you save your telnet session\n\t * to a file from within a Windows-based telnet client, it may\n\t * put in line breaks at 80 columns (or however big your \"telnet\" box\n\t * is). CRT (a Windows telnet app from VanDyke) does this.\n\t * Here we assume that 80 columns will be the minimum size, and that\n\t * the OFFSET line is not broken in the middle. It's the previous\n\t * line that is normally long and can thus be broken at column 80.\n\t */\n\tdo {\n\t\tif (file_gets(line, TOSHIBA_LINE_LENGTH, fh) == NULL) {\n\t\t\t*err = file_error(fh, err_info);\n\t\t\tif (*err == 0) {\n\t\t\t\t*err = WTAP_ERR_SHORT_READ;\n\t\t\t}\n\t\t\treturn FALSE;\n\t\t}\n\n\t\t/* Check for \"OFFSET 0001-0203\" at beginning of line */\n\t\tline[16] = '\\0';\n\n\t} while (strcmp(line, \"OFFSET 0001-0203\") != 0);\n\n\tnum_items_scanned = sscanf(line+64, \"LEN=%9d\", &pkt_len);\n\tif (num_items_scanned != 1) {\n\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t*err_info = g_strdup(\"toshiba: OFFSET line doesn't have valid LEN item\");\n\t\treturn FALSE;\n\t}\n\tif (pkt_len < 0) {\n\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t*err_info = g_strdup(\"toshiba: packet header has a negative packet length\");\n\t\treturn FALSE;\n\t}\n\tif (pkt_len > WTAP_MAX_PACKET_SIZE) {\n\t\t/*\n\t\t * Probably a corrupt capture file; don't blow up trying\n\t\t * to allocate space for an immensely-large packet.\n\t\t */\n\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t*err_info = g_strdup_printf(\"toshiba: File has %u-byte packet, bigger than maximum of %u\",\n\t\t    pkt_len, WTAP_MAX_PACKET_SIZE);\n\t\treturn FALSE;\n\t}\n\n\tphdr->rec_type = REC_TYPE_PACKET;\n\tphdr->presence_flags = WTAP_HAS_TS|WTAP_HAS_CAP_LEN;\n\tphdr->ts.secs = hr * 3600 + min * 60 + sec;\n\tphdr->ts.nsecs = csec * 10000000;\n\tphdr->caplen = pkt_len;\n\tphdr->len = pkt_len;\n\n\tswitch (channel[0]) {\n\t\tcase 'B':\n\t\t\tphdr->pkt_encap = WTAP_ENCAP_ISDN;\n\t\t\tpseudo_header->isdn.uton = (direction[0] == 'T');\n\t\t\tpseudo_header->isdn.channel = (guint8)\n\t\t\t    strtol(&channel[1], NULL, 10);\n\t\t\tbreak;\n\n\t\tcase 'D':\n\t\t\tphdr->pkt_encap = WTAP_ENCAP_ISDN;\n\t\t\tpseudo_header->isdn.uton = (direction[0] == 'T');\n\t\t\tpseudo_header->isdn.channel = 0;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tphdr->pkt_encap = WTAP_ENCAP_ETHERNET;\n\t\t\t/* XXX - is there an FCS in the frame? */\n\t\t\tpseudo_header->eth.fcs_len = -1;\n\t\t\tbreak;\n\t}\n\n\t/* Make sure we have enough room for the packet */\n\tws_buffer_assure_space(buf, pkt_len);\n\tpd = ws_buffer_start_ptr(buf);\n\n\t/* Calculate the number of hex dump lines, each\n\t * containing 16 bytes of data */\n\thex_lines = pkt_len / 16 + ((pkt_len % 16) ? 1 : 0);\n\n\tfor (i = 0; i < hex_lines; i++) {\n\t\tif (file_gets(line, TOSHIBA_LINE_LENGTH, fh) == NULL) {\n\t\t\t*err = file_error(fh, err_info);\n\t\t\tif (*err == 0) {\n\t\t\t\t*err = WTAP_ERR_SHORT_READ;\n\t\t\t}\n\t\t\treturn FALSE;\n\t\t}\n\t\tif (!parse_single_hex_dump_line(line, pd, i * 16)) {\n\t\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t\t*err_info = g_strdup(\"toshiba: hex dump not valid\");\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\treturn TRUE;\n}\n\n/*\n          1         2         3         4\n0123456789012345678901234567890123456789012345\n0000 : FF03 003D C000 0008 2145 0000 3A12 6500 ...=....!E..:.e.\n0010 : 003F 11E6 58CF C11A 8897 A401 0804 0400 .?..X...........\n0020 : 0100 01                                 ...\n*/\n\n#define START_POS\t7\n#define HEX_LENGTH\t((8 * 4) + 7) /* eight clumps of 4 bytes with 7 inner spaces */\n\n/* Take a string representing one line from a hex dump and converts the\n * text to binary data. We check the printed offset with the offset\n * we are passed to validate the record. We place the bytes in the buffer\n * at the specified offset.\n *\n * In the process, we're going to write all over the string.\n *\n * Returns TRUE if good hex dump, FALSE if bad.\n */\nstatic gboolean\nparse_single_hex_dump_line(char* rec, guint8 *buf, guint byte_offset) {\n\n\tint\t\tpos, i;\n\tchar\t\t*s;\n\tunsigned long\tvalue;\n\tguint16\t\tword_value;\n\n\t/* Get the byte_offset directly from the record */\n\trec[4] = '\\0';\n\ts = rec;\n\tvalue = strtoul(s, NULL, 16);\n\n\tif (value != byte_offset) {\n\t\treturn FALSE;\n\t}\n\n\t/* Go through the substring representing the values and:\n\t *      1. Replace any spaces with '0's\n\t *      2. Place \\0's every 5 bytes (to terminate the string)\n\t *\n\t * Then read the eight sets of hex bytes\n\t */\n\n\tfor (pos = START_POS; pos < START_POS + HEX_LENGTH; pos++) {\n\t\tif (rec[pos] == ' ') {\n\t\t\trec[pos] = '0';\n\t\t}\n\t}\n\n\tpos = START_POS;\n\tfor (i = 0; i < 8; i++) {\n\t\trec[pos+4] = '\\0';\n\n\t\tword_value = (guint16) strtoul(&rec[pos], NULL, 16);\n\t\tbuf[byte_offset + i * 2 + 0] = (guint8) (word_value >> 8);\n\t\tbuf[byte_offset + i * 2 + 1] = (guint8) (word_value & 0x00ff);\n\t\tpos += 5;\n\t}\n\n\treturn TRUE;\n}\n\n/*\n * Editor modelines  -  http://www.wireshark.org/tools/modelines.html\n *\n * Local variables:\n * c-basic-offset: 8\n * tab-width: 8\n * indent-tabs-mode: t\n * End:\n *\n * vi: set shiftwidth=8 tabstop=8 noexpandtab:\n * :indentSize=8:tabSize=8:noTabs=false:\n */\n", "code_before": "/* toshiba.c\n *\n * Wiretap Library\n * Copyright (c) 1998 by Gilbert Ramirez <gram@alumni.rice.edu>\n *\n * SPDX-License-Identifier: GPL-2.0-or-later\n */\n\n#include \"config.h\"\n#include \"toshiba.h\"\n#include \"wtap-int.h\"\n#include \"file_wrappers.h\"\n\n#include <stdlib.h>\n#include <string.h>\n\n#include <wsutil/pint.h>\n\n/*\n * Toshiba ISDN Router\n *\n * An under-documented command that the router supports in a telnet session\n * is \"snoop\" (not related to the Solaris \"snoop\" command). If you give\n * it the \"dump\" option (either by letting \"snoop\" query you for its next\n * argument, or typing \"snoop dump\" on the command line), you'll get a hex\n * dump of all packets across the router (except of your own telnet session\n * -- good thinking Toshiba!). You can select a certain channel to sniff\n * (LAN, B1, B2, D), but the default is all channels.  You save this hex\n * dump to disk with 'script' or by 'telnet | tee'. Wiretap will read the\n * ASCII hex dump and convert it to binary data.\n*/\n\n/* This module reads the output of the 'snoop' command in the Toshiba\n * TR-600 and TR-650 \"Compact\" ISDN Routers. You can telnet to the\n * router and run 'snoop' on the different channels, and at different\n * detail levels. Be sure to choose the 'dump' level to get the hex dump.\n * The 'snoop' command has nothing to do with the Solaris 'snoop'\n * command, except that they both capture packets.\n */\n\n/*\n   Example 'snoop' output data:\n\nScript started on Thu Sep  9 21:48:49 1999\n\u001b]0;gram@nirvana:/tmp\u0007$ telnet 10.0.0.254\nTrying 10.0.0.254...\nConnected to 10.0.0.254.\nEscape character is '^]'.\n\n\nTR-600(tr600) System Console\n\nLogin:admin\nPassword:*******\n*--------------------------------------------------------*\n|             T O S H I B A    T R - 6 0 0               |\n|                 <  Compact Router >                    |\n|                       V1.02.02                         |\n|                                                        |\n|  (C) Copyright TOSHIBA Corp. 1997 All rights reserved. |\n*--------------------------------------------------------*\n\ntr600>snoop dump b1\n Trace start?(on/off/dump/dtl)->dump\n IP Address?->b1\nB1 Port Filetering\nTrace start(Dump Mode)...\n\ntr600>[No.1] 00:00:09.14 B1:1 Tx 207.193.26.136->151.164.1.8 DNS  SPORT=1028 LEN=38 CHKSUM=4FD4 ID=2390 Query RD QCNT=1 pow.zing.org?\nOFFSET 0001-0203-0405-0607-0809-0A0B-0C0D-0E0F 0123456789ABCDEF LEN=67\n0000 : FF03 003D C000 0008 2145 0000 3A12 6500 ...=....!E..:.e.\n0010 : 003F 11E6 58CF C11A 8897 A401 0804 0400 .?..X...........\n0020 : 3500 264F D409 5601 0000 0100 0000 0000 5.&O..V.........\n0030 : 0003 706F 7704 7A69 6E67 036F 7267 0000 ..pow.zing.org..\n0040 : 0100 01                                 ...\n\n[No.2] 00:00:09.25 B1:1 Rx 151.164.1.8->207.193.26.136 DNS  DPORT=1028 LEN=193 CHKSUM=3E06 ID=2390 Answer RD RA QCNT=1 pow.zing.org? ANCNT=1 pow.zing.org=206.57.36.90 TTL=2652\nOFFSET 0001-0203-0405-0607-0809-0A0B-0C0D-0E0F 0123456789ABCDEF LEN=222\n0000 : FF03 003D C000 0013 2145 0000 D590 9340 ...=....!E.....@\n0010 : 00F7 116F 8E97 A401 08CF C11A 8800 3504 ...o..........5.\n0020 : 0400 C13E 0609 5681 8000 0100 0100 0300 ...>..V.........\n0030 : 0303 706F 7704 7A69 6E67 036F 7267 0000 ..pow.zing.org..\n0040 : 0100 01C0 0C00 0100 0100 000A 5C00 04CE ............\\...\n0050 : 3924 5A04 5A49 4E47 036F 7267 0000 0200 9$Z.ZING.org....\n0060 : 0100 016F 5B00 0D03 4841 4E03 5449 5703 ...o[...HAN.TIW.\n0070 : 4E45 5400 C02E 0002 0001 0001 6F5B 0006 NET.........o[..\n0080 : 034E 5331 C02E C02E 0002 0001 0001 6F5B .NS1..........o[\n0090 : 001C 0854 414C 4945 5349 4E0D 434F 4E46 ...TALIESIN.CONF\n00A0 : 4142 554C 4154 494F 4E03 434F 4D00 C042 ABULATION.COM..B\n00B0 : 0001 0001 0001 51EC 0004 CE39 2406 C05B ......Q....9$..[\n00C0 : 0001 0001 0001 6F5B 0004 CE39 245A C06D ......o[...9$Z.m\n00D0 : 0001 0001 0001 4521 0004 187C 1F01      ......E!...|..\n\n */\n\n/* Magic text to check for toshiba-ness of file */\nstatic const char toshiba_hdr_magic[]  =\n{ 'T', ' ', 'O', ' ', 'S', ' ', 'H', ' ', 'I', ' ', 'B', ' ', 'A' };\n#define TOSHIBA_HDR_MAGIC_SIZE  array_length(toshiba_hdr_magic)\n\n/* Magic text for start of packet */\nstatic const char toshiba_rec_magic[]  = { '[', 'N', 'o', '.' };\n#define TOSHIBA_REC_MAGIC_SIZE  array_length(toshiba_rec_magic)\n\nstatic bool toshiba_read(wtap *wth, wtap_rec *rec, int *err,\n\tchar **err_info, int64_t *data_offset);\nstatic bool toshiba_seek_read(wtap *wth, int64_t seek_off, wtap_rec *rec,\n\tint *err, char **err_info);\nstatic bool parse_single_hex_dump_line(char* rec, uint8_t *buf,\n\tunsigned byte_offset);\nstatic bool parse_toshiba_packet(FILE_T fh, wtap_rec *rec, int *err,\n\tchar **err_info);\n\nstatic int toshiba_file_type_subtype = -1;\n\nvoid register_toshiba(void);\n\n/* Seeks to the beginning of the next packet, and returns the\n   byte offset.  Returns -1 on failure, and sets \"*err\" to the error\n   and \"*err_info\" to null or an additional error string. */\nstatic int64_t toshiba_seek_next_packet(wtap *wth, int *err, char **err_info)\n{\n\tint byte;\n\tunsigned level = 0;\n\tint64_t cur_off;\n\n\twhile ((byte = file_getc(wth->fh)) != EOF) {\n\t\tif (byte == toshiba_rec_magic[level]) {\n\t\t\tlevel++;\n\t\t\tif (level >= TOSHIBA_REC_MAGIC_SIZE) {\n\t\t\t\t/* note: we're leaving file pointer right after the magic characters */\n\t\t\t\tcur_off = file_tell(wth->fh);\n\t\t\t\tif (cur_off == -1) {\n\t\t\t\t\t/* Error. */\n\t\t\t\t\t*err = file_error(wth->fh, err_info);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\treturn cur_off + 1;\n\t\t\t}\n\t\t} else {\n\t\t\tlevel = 0;\n\t\t}\n\t}\n\t/* EOF or error. */\n\t*err = file_error(wth->fh, err_info);\n\treturn -1;\n}\n\n#define TOSHIBA_HEADER_LINES_TO_CHECK\t200\n#define TOSHIBA_LINE_LENGTH\t\t240\n\n/* Look through the first part of a file to see if this is\n * a Toshiba trace file.\n *\n * Returns true if it is, false if it isn't or if we get an I/O error;\n * if we get an I/O error, \"*err\" will be set to a non-zero value and\n * \"*err_info\" will be set to null or an additional error string.\n */\nstatic bool toshiba_check_file_type(wtap *wth, int *err, char **err_info)\n{\n\tchar\tbuf[TOSHIBA_LINE_LENGTH];\n\tunsigned\ti, reclen, level, line;\n\tchar\tbyte;\n\n\tbuf[TOSHIBA_LINE_LENGTH-1] = 0;\n\n\tfor (line = 0; line < TOSHIBA_HEADER_LINES_TO_CHECK; line++) {\n\t\tif (file_gets(buf, TOSHIBA_LINE_LENGTH, wth->fh) == NULL) {\n\t\t\t/* EOF or error. */\n\t\t\t*err = file_error(wth->fh, err_info);\n\t\t\treturn false;\n\t\t}\n\n\t\treclen = (unsigned) strlen(buf);\n\t\tif (reclen < TOSHIBA_HDR_MAGIC_SIZE) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tlevel = 0;\n\t\tfor (i = 0; i < reclen; i++) {\n\t\t\tbyte = buf[i];\n\t\t\tif (byte == toshiba_hdr_magic[level]) {\n\t\t\t\tlevel++;\n\t\t\t\tif (level >= TOSHIBA_HDR_MAGIC_SIZE) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlevel = 0;\n\t\t\t}\n\t\t}\n\t}\n\t*err = 0;\n\treturn false;\n}\n\n\nwtap_open_return_val toshiba_open(wtap *wth, int *err, char **err_info)\n{\n\t/* Look for Toshiba header */\n\tif (!toshiba_check_file_type(wth, err, err_info)) {\n\t\tif (*err != 0 && *err != WTAP_ERR_SHORT_READ)\n\t\t\treturn WTAP_OPEN_ERROR;\n\t\treturn WTAP_OPEN_NOT_MINE;\n\t}\n\n\twth->file_encap = WTAP_ENCAP_PER_PACKET;\n\twth->file_type_subtype = toshiba_file_type_subtype;\n\twth->snapshot_length = 0; /* not known */\n\twth->subtype_read = toshiba_read;\n\twth->subtype_seek_read = toshiba_seek_read;\n\twth->file_tsprec = WTAP_TSPREC_10_MSEC;\n\n\treturn WTAP_OPEN_MINE;\n}\n\n/* Find the next packet and parse it; called from wtap_read(). */\nstatic bool toshiba_read(wtap *wth, wtap_rec *rec, int *err,\n\tchar **err_info, int64_t *data_offset)\n{\n\tint64_t\toffset;\n\n\t/* Find the next packet */\n\toffset = toshiba_seek_next_packet(wth, err, err_info);\n\tif (offset < 1)\n\t\treturn false;\n\t*data_offset = offset;\n\n\t/* Parse the packet */\n\treturn parse_toshiba_packet(wth->fh, rec, err, err_info);\n}\n\n/* Used to read packets in random-access fashion */\nstatic bool\ntoshiba_seek_read(wtap *wth, int64_t seek_off, wtap_rec *rec, int *err,\n\tchar **err_info)\n{\n\tif (file_seek(wth->random_fh, seek_off - 1, SEEK_SET, err) == -1)\n\t\treturn false;\n\n\tif (!parse_toshiba_packet(wth->random_fh, rec, err, err_info)) {\n\t\tif (*err == 0)\n\t\t\t*err = WTAP_ERR_SHORT_READ;\n\t\treturn false;\n\t}\n\treturn true;\n}\n\n/* Parses a packet. */\nstatic bool\nparse_toshiba_packet(FILE_T fh, wtap_rec *rec, int *err, char **err_info)\n{\n\tunion wtap_pseudo_header *pseudo_header = &rec->rec_header.packet_header.pseudo_header;\n\tchar\tline[TOSHIBA_LINE_LENGTH];\n\tint\tnum_items_scanned;\n\tint\tpkt_len, pktnum, hr, min, sec, csec;\n\tchar\tchannel[10], direction[10];\n\tint\ti, hex_lines;\n\tuint8_t\t*pd;\n\n\t/* Our file pointer should be on the line containing the\n\t * summary information for a packet. Read in that line and\n\t * extract the useful information\n\t */\n\tif (file_gets(line, TOSHIBA_LINE_LENGTH, fh) == NULL) {\n\t\t*err = file_error(fh, err_info);\n\t\tif (*err == 0) {\n\t\t\t*err = WTAP_ERR_SHORT_READ;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/* Find text in line after \"[No.\". Limit the length of the\n\t * two strings since we have fixed buffers for channel[] and\n\t * direction[] */\n\tnum_items_scanned = sscanf(line, \"%9d] %2d:%2d:%2d.%9d %9s %9s\",\n\t\t\t&pktnum, &hr, &min, &sec, &csec, channel, direction);\n\n\tif (num_items_scanned != 7) {\n\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t*err_info = g_strdup(\"toshiba: record header isn't valid\");\n\t\treturn false;\n\t}\n\n\t/* Scan lines until we find the OFFSET line. In a \"telnet\" trace,\n\t * this will be the next line. But if you save your telnet session\n\t * to a file from within a Windows-based telnet client, it may\n\t * put in line breaks at 80 columns (or however big your \"telnet\" box\n\t * is). CRT (a Windows telnet app from VanDyke) does this.\n\t * Here we assume that 80 columns will be the minimum size, and that\n\t * the OFFSET line is not broken in the middle. It's the previous\n\t * line that is normally long and can thus be broken at column 80.\n\t */\n\tdo {\n\t\tif (file_gets(line, TOSHIBA_LINE_LENGTH, fh) == NULL) {\n\t\t\t*err = file_error(fh, err_info);\n\t\t\tif (*err == 0) {\n\t\t\t\t*err = WTAP_ERR_SHORT_READ;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t/* Check for \"OFFSET 0001-0203\" at beginning of line */\n\t\tline[16] = '\\0';\n\n\t} while (strcmp(line, \"OFFSET 0001-0203\") != 0);\n\n\tnum_items_scanned = sscanf(line+64, \"LEN=%9d\", &pkt_len);\n\tif (num_items_scanned != 1) {\n\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t*err_info = g_strdup(\"toshiba: OFFSET line doesn't have valid LEN item\");\n\t\treturn false;\n\t}\n\tif (pkt_len < 0) {\n\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t*err_info = g_strdup(\"toshiba: packet header has a negative packet length\");\n\t\treturn false;\n\t}\n\tif ((unsigned)pkt_len > WTAP_MAX_PACKET_SIZE_STANDARD) {\n\t\t/*\n\t\t * Probably a corrupt capture file; don't blow up trying\n\t\t * to allocate space for an immensely-large packet.\n\t\t */\n\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t*err_info = ws_strdup_printf(\"toshiba: File has %u-byte packet, bigger than maximum of %u\",\n\t\t    (unsigned)pkt_len, WTAP_MAX_PACKET_SIZE_STANDARD);\n\t\treturn false;\n\t}\n\n\twtap_setup_packet_rec(rec, WTAP_ENCAP_UNKNOWN);\n\trec->block = wtap_block_create(WTAP_BLOCK_PACKET);\n\trec->presence_flags = WTAP_HAS_TS|WTAP_HAS_CAP_LEN;\n\trec->ts.secs = hr * 3600 + min * 60 + sec;\n\trec->ts.nsecs = csec * 10000000;\n\trec->rec_header.packet_header.caplen = pkt_len;\n\trec->rec_header.packet_header.len = pkt_len;\n\n\tswitch (channel[0]) {\n\t\tcase 'B':\n\t\t\trec->rec_header.packet_header.pkt_encap = WTAP_ENCAP_ISDN;\n\t\t\tpseudo_header->isdn.uton = (direction[0] == 'T');\n\t\t\tpseudo_header->isdn.channel = (uint8_t)\n\t\t\t    strtol(&channel[1], NULL, 10);\n\t\t\tbreak;\n\n\t\tcase 'D':\n\t\t\trec->rec_header.packet_header.pkt_encap = WTAP_ENCAP_ISDN;\n\t\t\tpseudo_header->isdn.uton = (direction[0] == 'T');\n\t\t\tpseudo_header->isdn.channel = 0;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\trec->rec_header.packet_header.pkt_encap = WTAP_ENCAP_ETHERNET;\n\t\t\t/* XXX - is there an FCS in the frame? */\n\t\t\tpseudo_header->eth.fcs_len = -1;\n\t\t\tbreak;\n\t}\n\n\t/* Make sure we have enough room for the packet */\n\tws_buffer_assure_space(&rec->data, pkt_len);\n\tpd = ws_buffer_start_ptr(&rec->data);\n\n\t/* Calculate the number of hex dump lines, each\n\t * containing 16 bytes of data */\n\thex_lines = pkt_len / 16 + ((pkt_len % 16) ? 1 : 0);\n\n\tfor (i = 0; i < hex_lines; i++) {\n\t\tif (file_gets(line, TOSHIBA_LINE_LENGTH, fh) == NULL) {\n\t\t\t*err = file_error(fh, err_info);\n\t\t\tif (*err == 0) {\n\t\t\t\t*err = WTAP_ERR_SHORT_READ;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\tif (!parse_single_hex_dump_line(line, pd, i * 16)) {\n\t\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t\t*err_info = g_strdup(\"toshiba: hex dump not valid\");\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\n/*\n          1         2         3         4\n0123456789012345678901234567890123456789012345\n0000 : FF03 003D C000 0008 2145 0000 3A12 6500 ...=....!E..:.e.\n0010 : 003F 11E6 58CF C11A 8897 A401 0804 0400 .?..X...........\n0020 : 0100 01                                 ...\n*/\n\n#define START_POS\t7\n#define HEX_LENGTH\t((8 * 4) + 7) /* eight clumps of 4 bytes with 7 inner spaces */\n\n/* Take a string representing one line from a hex dump and converts the\n * text to binary data. We check the printed offset with the offset\n * we are passed to validate the record. We place the bytes in the buffer\n * at the specified offset.\n *\n * In the process, we're going to write all over the string.\n *\n * Returns true if good hex dump, false if bad.\n */\nstatic bool\nparse_single_hex_dump_line(char* rec, uint8_t *buf, unsigned byte_offset) {\n\n\tint\t\tpos, i;\n\tchar\t\t*s;\n\tunsigned long\tvalue;\n\tuint16_t\t\tword_value;\n\n\t/* Get the byte_offset directly from the record */\n\trec[4] = '\\0';\n\ts = rec;\n\tvalue = strtoul(s, NULL, 16);\n\n\tif (value != byte_offset) {\n\t\treturn false;\n\t}\n\n\t/* Go through the substring representing the values and:\n\t *      1. Replace any spaces with '0's\n\t *      2. Place \\0's every 5 bytes (to terminate the string)\n\t *\n\t * Then read the eight sets of hex bytes\n\t */\n\n\tfor (pos = START_POS; pos < START_POS + HEX_LENGTH; pos++) {\n\t\tif (rec[pos] == ' ') {\n\t\t\trec[pos] = '0';\n\t\t}\n\t}\n\n\tpos = START_POS;\n\tfor (i = 0; i < 8; i++) {\n\t\trec[pos+4] = '\\0';\n\n\t\tword_value = (uint16_t) strtoul(&rec[pos], NULL, 16);\n\t\tphtonu16(&buf[byte_offset + i * 2], word_value);\n\t\tpos += 5;\n\t}\n\n\treturn true;\n}\n\nstatic const struct supported_block_type toshiba_blocks_supported[] = {\n\t/*\n\t * We support packet blocks, with no comments or other options.\n\t */\n\t{ WTAP_BLOCK_PACKET, MULTIPLE_BLOCKS_SUPPORTED, NO_OPTIONS_SUPPORTED }\n};\n\nstatic const struct file_type_subtype_info toshiba_info = {\n\t\"Toshiba Compact ISDN Router snoop\", \"toshiba\", \"txt\", NULL,\n\tfalse, BLOCKS_SUPPORTED(toshiba_blocks_supported),\n\tNULL, NULL, NULL\n};\n\nvoid register_toshiba(void)\n{\n\ttoshiba_file_type_subtype = wtap_register_file_type_subtype(&toshiba_info);\n\n\t/*\n\t * Register name for backwards compatibility with the\n\t * wtap_filetypes table in Lua.\n\t */\n\twtap_register_backwards_compatibility_lua_name(\"TOSHIBA\",\n\t    toshiba_file_type_subtype);\n}\n\n/*\n * Editor modelines  -  https://www.wireshark.org/tools/modelines.html\n *\n * Local variables:\n * c-basic-offset: 8\n * tab-width: 8\n * indent-tabs-mode: t\n * End:\n *\n * vi: set shiftwidth=8 tabstop=8 noexpandtab:\n * :indentSize=8:tabSize=8:noTabs=false:\n */\n", "patch": "@@ -248,8 +248,7 @@ parse_toshiba_packet(FILE_T fh, struct wtap_pkthdr *phdr, Buffer *buf,\n \tunion wtap_pseudo_header *pseudo_header = &phdr->pseudo_header;\n \tchar\tline[TOSHIBA_LINE_LENGTH];\n \tint\tnum_items_scanned;\n-\tguint\tpkt_len;\n-\tint\tpktnum, hr, min, sec, csec;\n+\tint\tpkt_len, pktnum, hr, min, sec, csec;\n \tchar\tchannel[10], direction[10];\n \tint\ti, hex_lines;\n \tguint8\t*pd;\n@@ -301,12 +300,17 @@ parse_toshiba_packet(FILE_T fh, struct wtap_pkthdr *phdr, Buffer *buf,\n \n \t} while (strcmp(line, \"OFFSET 0001-0203\") != 0);\n \n-\tnum_items_scanned = sscanf(line+64, \"LEN=%9u\", &pkt_len);\n+\tnum_items_scanned = sscanf(line+64, \"LEN=%9d\", &pkt_len);\n \tif (num_items_scanned != 1) {\n \t\t*err = WTAP_ERR_BAD_FILE;\n \t\t*err_info = g_strdup(\"toshiba: OFFSET line doesn't have valid LEN item\");\n \t\treturn FALSE;\n \t}\n+\tif (pkt_len < 0) {\n+\t\t*err = WTAP_ERR_BAD_FILE;\n+\t\t*err_info = g_strdup(\"toshiba: packet header has a negative packet length\");\n+\t\treturn FALSE;\n+\t}\n \tif (pkt_len > WTAP_MAX_PACKET_SIZE) {\n \t\t/*\n \t\t * Probably a corrupt capture file; don't blow up trying", "file_path": "files/2016_8\\53", "file_language": "c", "file_name": "wiretap/toshiba.c", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}], "outdated": 0}
{"index": 16, "cve_id": "CVE-2016-5356", "cwe_id": ["CWE-119"], "cve_language": "C", "cve_description": "wiretap/cosine.c in the CoSine file parser in Wireshark 1.12.x before 1.12.12 and 2.x before 2.0.4 mishandles sscanf unsigned-integer processing, which allows remote attackers to cause a denial of service (application crash) via a crafted file.", "cvss": "5.9", "publish_date": "August 7, 2016", "AV": "NETWORK", "AC": "HIGH", "PR": "NONE", "UI": "NONE", "S": "UNCHANGED", "C": "NONE", "I": "NONE", "A": "HIGH", "commit_id": "a66628e425db725df1ac52a3c573a03357060ddd", "commit_message": "Don't treat the packet length as unsigned.\n\nThe scanf family of functions are as annoyingly bad at handling unsigned\nnumbers as strtoul() is - both of them are perfectly willing to accept a\nvalue beginning with a negative sign as an unsigned value.  When using\nstrtoul(), you can compensate for this by explicitly checking for a '-'\nas the first character of the string, but you can't do that with\nsscanf().\n\nSo revert to having pkt_len be signed, and scanning it with %d, but\ncheck for a negative value and fail if we see a negative value.\n\nBug: 12395\nChange-Id: I43b458a73b0934e9a5c2c89d34eac5a8f21a7455\nReviewed-on: https://code.wireshark.org/review/15223\nReviewed-by: Guy Harris <guy@alum.mit.edu>", "commit_date": "2016-05-01T23:23:29Z", "project": "wireshark/wireshark", "url": "https://api.github.com/repos/wireshark/wireshark/commits/a66628e425db725df1ac52a3c573a03357060ddd", "html_url": "https://github.com/wireshark/wireshark/commit/a66628e425db725df1ac52a3c573a03357060ddd", "windows_before": "", "windows_after": "", "parents": [{"commit_id_before": "85d57b53e88cc1193c9259e13c531746b6f56c0e", "url_before": "https://api.github.com/repos/wireshark/wireshark/commits/85d57b53e88cc1193c9259e13c531746b6f56c0e", "html_url_before": "https://github.com/wireshark/wireshark/commit/85d57b53e88cc1193c9259e13c531746b6f56c0e"}], "details": [{"raw_url": "https://github.com/wireshark/wireshark/raw/a66628e425db725df1ac52a3c573a03357060ddd/wiretap/cosine.c", "code": "/* cosine.c\n *\n * CoSine IPNOS L2 debug output parsing\n * Copyright (c) 2002 by Motonori Shindo <motonori@shin.do>\n *\n * Wiretap Library\n * Copyright (c) 1998 by Gilbert Ramirez <gram@alumni.rice.edu>\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version 2\n * of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */\n\n#include \"config.h\"\n#include \"wtap-int.h\"\n#include \"cosine.h\"\n#include \"file_wrappers.h\"\n\n#include <stdlib.h>\n#include <string.h>\n\n/*\n\n  IPNOS: CONFIG VPN(100) VR(1.1.1.1)# diags\n  ipnos diags: Control (1/0) :: layer-2 ?\n  Registered commands for area \"layer-2\"\n      apply-pkt-log-profile  Configure packet logging on an interface\n      create-pkt-log-profile  Set packet-log-profile to be used for packet logging (see layer-2 pkt-log)\n      detail                Get Layer 2 low-level details\n\n  ipnos diags: Control (1/0) :: layer-2 create ?\n      create-pkt-log-profile  <pkt-log-profile-id ctl-tx-trace-length ctl-rx-trace-length data-tx-trace-length data-rx-trace-length pe-logging-or-control-blade>\n\n  ipnos diags: Control (1/0) :: layer-2 create 1 32 32 0 0 0\n  ipnos diags: Control (1/0) :: layer-2 create 2 32 32 100 100 0\n  ipnos diags: Control (1/0) :: layer-2 apply ?\n      apply-pkt-log-profile  <slot port channel subif pkt-log-profile-id>\n\n  ipnos diags: Control (1/0) :: layer-2 apply 3 0x0701 100 0 1\n  Successfully applied packet-log-profile on LI\n\n  -- Note that only the control packets are logged because the data packet size parameters are 0 in profile 1\n  IPNOS: CONFIG VPN(200) VR(3.3.3.3)# ping 20.20.20.43\n  vpn 200 : [max tries 4, timeout 5 seconds, data length 64 bytes, ttl 255]\n  ping #1 ok, RTT 0.000 seconds\n  ping #2 ok, RTT 0.000 seconds\n  ping #3 ok, RTT 0.000 seconds\n  ping #4 ok, RTT 0.000 seconds\n  [finished]\n\n  IPNOS: CONFIG VPN(200) VR(3.3.3.3)# 2000-2-1,18:19:46.8:  l2-tx (PPP:3/7/1:100), Length:16, Pro:0, Off:0, Pri:0, RM:0, Err:0 [0x4000, 0x0]\n\n\n  2000-2-1,18:19:46.8:  l2-rx (PPP:3/7/1:100), Length:16, Pro:0, Off:0, Pri:0, RM:0, Err:0 [0x4001, 0x30000]\n\n  2000-2-1,18:19:46.8:  l2-tx (PPP:3/7/1:100), Length:16, Pro:0, Off:0, Pri:0, RM:0, Err:0 [0x4000, 0x0]\n\n  2000-2-1,18:19:46.8:  l2-rx (PPP:3/7/1:100), Length:16, Pro:0, Off:0, Pri:0, RM:0, Err:0 [0x4001, 0x8030000]\n\n  ipnos diags: Control (1/0) :: layer-2 apply 3 0x0701 100 0 0\n  Successfully applied packet-log-profile on LI\n  ipnos diags: Control (1/0) :: layer-2 apply 3 0x0701 100 0 2\n  Successfully applied packet-log-profile on LI\n\n  -- Note that both control and data packets are logged because the data packet size parameter is 100 in profile 2\n     Please ignore the event-log messages getting mixed up with the ping command\n  ping 20.20.20.43 cou2000-2-1,18:20:17.0:  l2-tx (PPP:3/7/1:100), Length:16, Pro:0, Off:0, Pri:0, RM:0, Err:0 [0x4000, 0x0]\n\n          00 D0 D8 D2 FF 03 C0 21  09 29 00 08 6B 60 84 AA\n\n  2000-2-1,18:20:17.0:  l2-rx (PPP:3/7/1:100), Length:16, Pro:0, Off:0, Pri:0, RM:0, Err:0 [0x4001, 0x30000]\n          00 D0 D8 D2 FF 03 C0 21  09 29 00 08 6D FE FA AA\n\n  2000-2-1,18:20:17.0:  l2-tx (PPP:3/7/1:100), Length:16, Pro:0, Off:0, Pri:0, RM:0, Err:0 [0x4000, 0x0]\n          00 D0 D8 D2 FF 03 C0 21  0A 29 00 08 6B 60 84 AA\n\n  2000-2-1,18:20:17.0:  l2-rx (PPP:3/7/1:100), Length:16, Pro:0, Off:0, Pri:0, RM:0, Err:0 [0x4001, 0x8030000]\n          00 D0 D8 D2 FF 03 C0 21  0A 29 00 08 6D FE FA AA\n\n  nt 1 length 500\n  vpn 200 : [max tries 1, timeout 5 seconds, data length 500 bytes, ttl 255]\n  2000-2-1,18:20:24.1:  l2-tx (PPP:3/7/1:100), Length:536, Pro:1, Off:8, Pri:7, RM:0, Err:0 [0x4070, 0x801]\n          00 D0 D8 D2 FF 03 00 21  45 00 02 10 00 27 00 00\n          FF 01 69 51 14 14 14 22  14 14 14 2B 08 00 AD B8\n          00 03 00 01 10 11 12 13  14 15 16 17 18 19 1A 1B\n          1C 1D 1E 1F 20 21 22 23  24 25 26 27 28 29 2A 2B\n          2C 2D 2E 2F 30 31 32 33  34 35 36 37 38 39 3A 3B\n          3C 3D 3E 3F 40 41 42 43  44 45 46 47 48 49 4A 4B\n          4C 4D 4E 4F\n\n  ping #1 ok, RTT 0.010 seconds\n  2000-2-1,18:20:24.1:  l2-rx (PPP:3/7/1:100), Length:536, Pro:1, Off:8, Pri:7, RM:0, Err:0 [0x4071, 0x30801]\n          00 D0 D8 D2 FF 03 00 21  45 00 02 10 00 23 00 00\n          FF 01 69 55 14 14 14 2B  14 14 14 22 00 00 B5 B8\n          00 03 00 01 10 11 12 13  14 15 16 17 18 19 1A 1B\n          1C 1D 1E 1F 20 21 22 23  24 25 26 27 28 29 2A 2B\n          2C 2D 2E 2F 30 31 32 33  34 35 36 37 38 39 3A 3B\n          3C 3D 3E 3F 40 41 42 43  44 45 46 47 48 49 4A 4B\n          4C 4D 4E 4F\n\n  [finished]\n\n  IPNOS: CONFIG VPN(200) VR(3.3.3.3)# 2000-2-1,18:20:27.0:  l2-tx (PPP:3/7/1:100), Length:16, Pro:0, Off:0, Pri:0, RM:0, Err:0 [0x4000, 0x0]\n\n          00 D0 D8 D2 FF 03 C0 21  09 2A 00 08 6B 60 84 AA\n\n  2000-2-1,18:20:27.0:  l2-rx (PPP:3/7/1:100), Length:16, Pro:0, Off:0, Pri:0, RM:0, Err:0 [0x4001, 0x30000]\n          00 D0 D8 D2 FF 03 C0 21  09 2A 00 08 6D FE FA AA\n\n  2000-2-1,18:20:27.0:  l2-tx (PPP:3/7/1:100), Length:16, Pro:0, Off:0, Pri:0, RM:0, Err:0 [0x4000, 0x0]\n          00 D0 D8 D2 FF 03 C0 21  0A 2A 00 08 6B 60 84 AA\n\n  2000-2-1,18:20:27.0:  l2-rx (PPP:3/7/1:100), Length:16, Pro:0, Off:0, Pri:0, RM:0, Err:0 [0x4001, 0x30000]\n          00 D0 D8 D2 FF 03 C0 21  0A 2A 00 08 6D FE FA AA\n\n\n  ipnos diags: Control (1/0) :: layer-2 apply 3 0x0701 100 0 0\n  Successfully applied packet-log-profile on LI\n  ipnos diags: Control (1/0) ::\n\n */\n\n/* XXX TODO:\n\n  o Handle a case where an empty line doesn't exists as a delimiter of\n    each packet. If the output is sent to a control blade and\n    displayed as an event log, there's always an empty line between\n    each packet output, but it may not be true when it is an PE\n    output.\n\n  o Some telnet client on Windows may put in a line break at 80\n    columns when it save the session to a text file (\"CRT\" is such an\n    example). I don't think it's a good idea for the telnet client to\n    do so, but CRT is widely used in Windows community, I should\n    take care of that in the future.\n\n*/\n\n/* Magic text to check for CoSine L2 debug output */\n#define COSINE_HDR_MAGIC_STR1\t\"l2-tx\"\n#define COSINE_HDR_MAGIC_STR2\t\"l2-rx\"\n\n/* Magic text for start of packet */\n#define COSINE_REC_MAGIC_STR1\tCOSINE_HDR_MAGIC_STR1\n#define COSINE_REC_MAGIC_STR2\tCOSINE_HDR_MAGIC_STR2\n\n#define COSINE_HEADER_LINES_TO_CHECK\t200\n#define COSINE_LINE_LENGTH\t\t240\n\nstatic gboolean empty_line(const gchar *line);\nstatic gint64 cosine_seek_next_packet(wtap *wth, int *err, gchar **err_info,\n\tchar *hdr);\nstatic gboolean cosine_check_file_type(wtap *wth, int *err, gchar **err_info);\nstatic gboolean cosine_read(wtap *wth, int *err, gchar **err_info,\n\tgint64 *data_offset);\nstatic gboolean cosine_seek_read(wtap *wth, gint64 seek_off,\n\tstruct wtap_pkthdr *phdr, Buffer *buf, int *err, gchar **err_info);\nstatic int parse_cosine_packet(FILE_T fh, struct wtap_pkthdr *phdr, Buffer* buf,\n\tchar *line, int *err, gchar **err_info);\nstatic int parse_single_hex_dump_line(char* rec, guint8 *buf,\n\tguint byte_offset);\n\n/* Returns TRUE if the line appears to be an empty line. Otherwise it\n   returns FALSE. */\nstatic gboolean empty_line(const gchar *line)\n{\n\twhile (*line) {\n\t\tif (g_ascii_isspace(*line)) {\n\t\t\tline++;\n\t\t\tcontinue;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (*line == '\\0')\n\t\treturn TRUE;\n\telse\n\t\treturn FALSE;\n}\n\n/* Seeks to the beginning of the next packet, and returns the\n   byte offset. Copy the header line to hdr. Returns -1 on failure,\n   and sets \"*err\" to the error and sets \"*err_info\" to null or an\n   additional error string. */\nstatic gint64 cosine_seek_next_packet(wtap *wth, int *err, gchar **err_info,\n\tchar *hdr)\n{\n\tgint64 cur_off;\n\tchar buf[COSINE_LINE_LENGTH];\n\n\twhile (1) {\n\t\tcur_off = file_tell(wth->fh);\n\t\tif (cur_off == -1) {\n\t\t\t/* Error */\n\t\t\t*err = file_error(wth->fh, err_info);\n\t\t\treturn -1;\n\t\t}\n\t\tif (file_gets(buf, sizeof(buf), wth->fh) == NULL) {\n\t\t\t*err = file_error(wth->fh, err_info);\n\t\t\treturn -1;\n\t\t}\n\t\tif (strstr(buf, COSINE_REC_MAGIC_STR1) ||\n\t\t    strstr(buf, COSINE_REC_MAGIC_STR2)) {\n\t\t\tg_strlcpy(hdr, buf, COSINE_LINE_LENGTH);\n\t\t\treturn cur_off;\n\t\t}\n\t}\n\treturn -1;\n}\n\n/* Look through the first part of a file to see if this is\n * a CoSine L2 debug output.\n *\n * Returns TRUE if it is, FALSE if it isn't or if we get an I/O error;\n * if we get an I/O error, \"*err\" will be set to a non-zero value and\n * \"*err_info\" will be set to null or an additional error string.\n */\nstatic gboolean cosine_check_file_type(wtap *wth, int *err, gchar **err_info)\n{\n\tchar\tbuf[COSINE_LINE_LENGTH];\n\tgsize\treclen;\n\tguint\tline;\n\n\tbuf[COSINE_LINE_LENGTH-1] = '\\0';\n\n\tfor (line = 0; line < COSINE_HEADER_LINES_TO_CHECK; line++) {\n\t\tif (file_gets(buf, COSINE_LINE_LENGTH, wth->fh) == NULL) {\n\t\t\t/* EOF or error. */\n\t\t\t*err = file_error(wth->fh, err_info);\n\t\t\treturn FALSE;\n\t\t}\n\n\t\treclen = strlen(buf);\n\t\tif (reclen < strlen(COSINE_HDR_MAGIC_STR1) ||\n\t\t\treclen < strlen(COSINE_HDR_MAGIC_STR2)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (strstr(buf, COSINE_HDR_MAGIC_STR1) ||\n\t\t    strstr(buf, COSINE_HDR_MAGIC_STR2)) {\n\t\t\treturn TRUE;\n\t\t}\n\t}\n\t*err = 0;\n\treturn FALSE;\n}\n\n\nwtap_open_return_val cosine_open(wtap *wth, int *err, gchar **err_info)\n{\n\t/* Look for CoSine header */\n\tif (!cosine_check_file_type(wth, err, err_info)) {\n\t\tif (*err != 0 && *err != WTAP_ERR_SHORT_READ)\n\t\t\treturn WTAP_OPEN_ERROR;\n\t\treturn WTAP_OPEN_NOT_MINE;\n\t}\n\n\tif (file_seek(wth->fh, 0L, SEEK_SET, err) == -1)\t/* rewind */\n\t\treturn WTAP_OPEN_ERROR;\n\n\twth->file_encap = WTAP_ENCAP_COSINE;\n\twth->file_type_subtype = WTAP_FILE_TYPE_SUBTYPE_COSINE;\n\twth->snapshot_length = 0; /* not known */\n\twth->subtype_read = cosine_read;\n\twth->subtype_seek_read = cosine_seek_read;\n\twth->file_tsprec = WTAP_TSPREC_CSEC;\n\n\treturn WTAP_OPEN_MINE;\n}\n\n/* Find the next packet and parse it; called from wtap_read(). */\nstatic gboolean cosine_read(wtap *wth, int *err, gchar **err_info,\n    gint64 *data_offset)\n{\n\tgint64\toffset;\n\tchar\tline[COSINE_LINE_LENGTH];\n\n\t/* Find the next packet */\n\toffset = cosine_seek_next_packet(wth, err, err_info, line);\n\tif (offset < 0)\n\t\treturn FALSE;\n\t*data_offset = offset;\n\n\t/* Parse the header and convert the ASCII hex dump to binary data */\n\treturn parse_cosine_packet(wth->fh, &wth->phdr, wth->frame_buffer,\n\t    line, err, err_info);\n}\n\n/* Used to read packets in random-access fashion */\nstatic gboolean\ncosine_seek_read(wtap *wth, gint64 seek_off, struct wtap_pkthdr *phdr,\n\tBuffer *buf, int *err, gchar **err_info)\n{\n\tchar\tline[COSINE_LINE_LENGTH];\n\n\tif (file_seek(wth->random_fh, seek_off, SEEK_SET, err) == -1)\n\t\treturn FALSE;\n\n\tif (file_gets(line, COSINE_LINE_LENGTH, wth->random_fh) == NULL) {\n\t\t*err = file_error(wth->random_fh, err_info);\n\t\tif (*err == 0) {\n\t\t\t*err = WTAP_ERR_SHORT_READ;\n\t\t}\n\t\treturn FALSE;\n\t}\n\n\t/* Parse the header and convert the ASCII hex dump to binary data */\n\treturn parse_cosine_packet(wth->random_fh, phdr, buf, line, err,\n\t    err_info);\n}\n\n/* Parses a packet record header. There are two possible formats:\n    1) output to a control blade with date and time\n        2002-5-10,20:1:31.4:  l2-tx (FR:3/7/1:1), Length:18, Pro:0, Off:0, Pri:0, RM:0, Err:0 [0x4000, 0x0]\n    2) output to PE without date and time\n        l2-tx (FR:3/7/1:1), Length:18, Pro:0, Off:0, Pri:0, RM:0, Err:0 [0x4000, 0x0] */\nstatic gboolean\nparse_cosine_packet(FILE_T fh, struct wtap_pkthdr *phdr, Buffer *buf,\n    char *line, int *err, gchar **err_info)\n{\n\tunion wtap_pseudo_header *pseudo_header = &phdr->pseudo_header;\n\tint\tnum_items_scanned;\n\tint\tyy, mm, dd, hr, min, sec, csec, pkt_len;\n\tint\tpro, off, pri, rm, error;\n\tguint\tcode1, code2;\n\tchar\tif_name[COSINE_MAX_IF_NAME_LEN] = \"\", direction[6] = \"\";\n\tstruct\ttm tm;\n\tguint8 *pd;\n\tint\ti, hex_lines, n, caplen = 0;\n\n\tif (sscanf(line, \"%4d-%2d-%2d,%2d:%2d:%2d.%9d:\",\n\t\t   &yy, &mm, &dd, &hr, &min, &sec, &csec) == 7) {\n\t\t/* appears to be output to a control blade */\n\t\tnum_items_scanned = sscanf(line,\n\t\t   \"%4d-%2d-%2d,%2d:%2d:%2d.%9d: %5s (%127[A-Za-z0-9/:]), Length:%9d, Pro:%9d, Off:%9d, Pri:%9d, RM:%9d, Err:%9d [%8x, %8x]\",\n\t\t\t&yy, &mm, &dd, &hr, &min, &sec, &csec,\n\t\t\t\t   direction, if_name, &pkt_len,\n\t\t\t\t   &pro, &off, &pri, &rm, &error,\n\t\t\t\t   &code1, &code2);\n\n\t\tif (num_items_scanned != 17) {\n\t\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t\t*err_info = g_strdup(\"cosine: purported control blade line doesn't have code values\");\n\t\t\treturn FALSE;\n\t\t}\n\t} else {\n\t\t/* appears to be output to PE */\n\t\tnum_items_scanned = sscanf(line,\n\t\t   \"%5s (%127[A-Za-z0-9/:]), Length:%9d, Pro:%9d, Off:%9d, Pri:%9d, RM:%9d, Err:%9d [%8x, %8x]\",\n\t\t\t\t   direction, if_name, &pkt_len,\n\t\t\t\t   &pro, &off, &pri, &rm, &error,\n\t\t\t\t   &code1, &code2);\n\n\t\tif (num_items_scanned != 10) {\n\t\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t\t*err_info = g_strdup(\"cosine: header line is neither control blade nor PE output\");\n\t\t\treturn FALSE;\n\t\t}\n\t\tyy = mm = dd = hr = min = sec = csec = 0;\n\t}\n\tif (pkt_len < 0) {\n\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t*err_info = g_strdup(\"cosine: packet header has a negative packet length\");\n\t\treturn FALSE;\n\t}\n\tif (pkt_len > WTAP_MAX_PACKET_SIZE) {\n\t\t/*\n\t\t * Probably a corrupt capture file; don't blow up trying\n\t\t * to allocate space for an immensely-large packet.\n\t\t */\n\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t*err_info = g_strdup_printf(\"cosine: File has %u-byte packet, bigger than maximum of %u\",\n\t\t    pkt_len, WTAP_MAX_PACKET_SIZE);\n\t\treturn FALSE;\n\t}\n\n\tphdr->rec_type = REC_TYPE_PACKET;\n\tphdr->presence_flags = WTAP_HAS_TS|WTAP_HAS_CAP_LEN;\n\ttm.tm_year = yy - 1900;\n\ttm.tm_mon = mm - 1;\n\ttm.tm_mday = dd;\n\ttm.tm_hour = hr;\n\ttm.tm_min = min;\n\ttm.tm_sec = sec;\n\ttm.tm_isdst = -1;\n\tphdr->ts.secs = mktime(&tm);\n\tphdr->ts.nsecs = csec * 10000000;\n\tphdr->len = pkt_len;\n\n\t/* XXX need to handle other encapsulations like Cisco HDLC,\n\t   Frame Relay and ATM */\n\tif (strncmp(if_name, \"TEST:\", 5) == 0) {\n\t\tpseudo_header->cosine.encap = COSINE_ENCAP_TEST;\n\t} else if (strncmp(if_name, \"PPoATM:\", 7) == 0) {\n\t\tpseudo_header->cosine.encap = COSINE_ENCAP_PPoATM;\n\t} else if (strncmp(if_name, \"PPoFR:\", 6) == 0) {\n\t\tpseudo_header->cosine.encap = COSINE_ENCAP_PPoFR;\n\t} else if (strncmp(if_name, \"ATM:\", 4) == 0) {\n\t\tpseudo_header->cosine.encap = COSINE_ENCAP_ATM;\n\t} else if (strncmp(if_name, \"FR:\", 3) == 0) {\n\t\tpseudo_header->cosine.encap = COSINE_ENCAP_FR;\n\t} else if (strncmp(if_name, \"HDLC:\", 5) == 0) {\n\t\tpseudo_header->cosine.encap = COSINE_ENCAP_HDLC;\n\t} else if (strncmp(if_name, \"PPP:\", 4) == 0) {\n\t\tpseudo_header->cosine.encap = COSINE_ENCAP_PPP;\n\t} else if (strncmp(if_name, \"ETH:\", 4) == 0) {\n\t\tpseudo_header->cosine.encap = COSINE_ENCAP_ETH;\n\t} else {\n\t\tpseudo_header->cosine.encap = COSINE_ENCAP_UNKNOWN;\n\t}\n\tif (strncmp(direction, \"l2-tx\", 5) == 0) {\n\t\tpseudo_header->cosine.direction = COSINE_DIR_TX;\n\t} else if (strncmp(direction, \"l2-rx\", 5) == 0) {\n\t\tpseudo_header->cosine.direction = COSINE_DIR_RX;\n\t}\n\tg_strlcpy(pseudo_header->cosine.if_name, if_name,\n\t\tCOSINE_MAX_IF_NAME_LEN);\n\tpseudo_header->cosine.pro = pro;\n\tpseudo_header->cosine.off = off;\n\tpseudo_header->cosine.pri = pri;\n\tpseudo_header->cosine.rm = rm;\n\tpseudo_header->cosine.err = error;\n\n\t/* Make sure we have enough room for the packet */\n\tws_buffer_assure_space(buf, pkt_len);\n\tpd = ws_buffer_start_ptr(buf);\n\n\t/* Calculate the number of hex dump lines, each\n\t * containing 16 bytes of data */\n\thex_lines = pkt_len / 16 + ((pkt_len % 16) ? 1 : 0);\n\n\tfor (i = 0; i < hex_lines; i++) {\n\t\tif (file_gets(line, COSINE_LINE_LENGTH, fh) == NULL) {\n\t\t\t*err = file_error(fh, err_info);\n\t\t\tif (*err == 0) {\n\t\t\t\t*err = WTAP_ERR_SHORT_READ;\n\t\t\t}\n\t\t\treturn FALSE;\n\t\t}\n\t\tif (empty_line(line)) {\n\t\t\tbreak;\n\t\t}\n\t\tif ((n = parse_single_hex_dump_line(line, pd, i*16)) == -1) {\n\t\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t\t*err_info = g_strdup(\"cosine: hex dump line doesn't have 16 numbers\");\n\t\t\treturn FALSE;\n\t\t}\n\t\tcaplen += n;\n\t}\n\tphdr->caplen = caplen;\n\treturn TRUE;\n}\n\n/* Take a string representing one line from a hex dump and converts\n * the text to binary data. We place the bytes in the buffer at the\n * specified offset.\n *\n * Returns number of bytes successfully read, -1 if bad.  */\nstatic int\nparse_single_hex_dump_line(char* rec, guint8 *buf, guint byte_offset)\n{\n\tint num_items_scanned, i;\n\tunsigned int bytes[16];\n\n\tnum_items_scanned = sscanf(rec, \"%02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\",\n\t\t\t       &bytes[0], &bytes[1], &bytes[2], &bytes[3],\n\t\t\t       &bytes[4], &bytes[5], &bytes[6], &bytes[7],\n\t\t\t       &bytes[8], &bytes[9], &bytes[10], &bytes[11],\n\t\t\t       &bytes[12], &bytes[13], &bytes[14], &bytes[15]);\n\tif (num_items_scanned == 0)\n\t\treturn -1;\n\n\tif (num_items_scanned > 16)\n\t\tnum_items_scanned = 16;\n\n\tfor (i=0; i<num_items_scanned; i++) {\n\t\tbuf[byte_offset + i] = (guint8)bytes[i];\n\t}\n\n\treturn num_items_scanned;\n}\n\n/*\n * Editor modelines  -  http://www.wireshark.org/tools/modelines.html\n *\n * Local variables:\n * c-basic-offset: 8\n * tab-width: 8\n * indent-tabs-mode: t\n * End:\n *\n * vi: set shiftwidth=8 tabstop=8 noexpandtab:\n * :indentSize=8:tabSize=8:noTabs=false:\n */\n", "code_before": "/* cosine.c\n *\n * CoSine IPNOS L2 debug output parsing\n * Copyright (c) 2002 by Motonori Shindo <motonori@shin.do>\n *\n * Wiretap Library\n * Copyright (c) 1998 by Gilbert Ramirez <gram@alumni.rice.edu>\n *\n * SPDX-License-Identifier: GPL-2.0-or-later\n */\n\n#include \"config.h\"\n#include \"cosine.h\"\n#include \"wtap-int.h\"\n#include \"file_wrappers.h\"\n\n#include <stdlib.h>\n#include <string.h>\n\n/*\n\n  IPNOS: CONFIG VPN(100) VR(1.1.1.1)# diags\n  ipnos diags: Control (1/0) :: layer-2 ?\n  Registered commands for area \"layer-2\"\n      apply-pkt-log-profile  Configure packet logging on an interface\n      create-pkt-log-profile  Set packet-log-profile to be used for packet logging (see layer-2 pkt-log)\n      detail                Get Layer 2 low-level details\n\n  ipnos diags: Control (1/0) :: layer-2 create ?\n      create-pkt-log-profile  <pkt-log-profile-id ctl-tx-trace-length ctl-rx-trace-length data-tx-trace-length data-rx-trace-length pe-logging-or-control-blade>\n\n  ipnos diags: Control (1/0) :: layer-2 create 1 32 32 0 0 0\n  ipnos diags: Control (1/0) :: layer-2 create 2 32 32 100 100 0\n  ipnos diags: Control (1/0) :: layer-2 apply ?\n      apply-pkt-log-profile  <slot port channel subif pkt-log-profile-id>\n\n  ipnos diags: Control (1/0) :: layer-2 apply 3 0x0701 100 0 1\n  Successfully applied packet-log-profile on LI\n\n  -- Note that only the control packets are logged because the data packet size parameters are 0 in profile 1\n  IPNOS: CONFIG VPN(200) VR(3.3.3.3)# ping 20.20.20.43\n  vpn 200 : [max tries 4, timeout 5 seconds, data length 64 bytes, ttl 255]\n  ping #1 ok, RTT 0.000 seconds\n  ping #2 ok, RTT 0.000 seconds\n  ping #3 ok, RTT 0.000 seconds\n  ping #4 ok, RTT 0.000 seconds\n  [finished]\n\n  IPNOS: CONFIG VPN(200) VR(3.3.3.3)# 2000-2-1,18:19:46.8:  l2-tx (PPP:3/7/1:100), Length:16, Pro:0, Off:0, Pri:0, RM:0, Err:0 [0x4000, 0x0]\n\n\n  2000-2-1,18:19:46.8:  l2-rx (PPP:3/7/1:100), Length:16, Pro:0, Off:0, Pri:0, RM:0, Err:0 [0x4001, 0x30000]\n\n  2000-2-1,18:19:46.8:  l2-tx (PPP:3/7/1:100), Length:16, Pro:0, Off:0, Pri:0, RM:0, Err:0 [0x4000, 0x0]\n\n  2000-2-1,18:19:46.8:  l2-rx (PPP:3/7/1:100), Length:16, Pro:0, Off:0, Pri:0, RM:0, Err:0 [0x4001, 0x8030000]\n\n  ipnos diags: Control (1/0) :: layer-2 apply 3 0x0701 100 0 0\n  Successfully applied packet-log-profile on LI\n  ipnos diags: Control (1/0) :: layer-2 apply 3 0x0701 100 0 2\n  Successfully applied packet-log-profile on LI\n\n  -- Note that both control and data packets are logged because the data packet size parameter is 100 in profile 2\n     Please ignore the event-log messages getting mixed up with the ping command\n  ping 20.20.20.43 cou2000-2-1,18:20:17.0:  l2-tx (PPP:3/7/1:100), Length:16, Pro:0, Off:0, Pri:0, RM:0, Err:0 [0x4000, 0x0]\n\n          00 D0 D8 D2 FF 03 C0 21  09 29 00 08 6B 60 84 AA\n\n  2000-2-1,18:20:17.0:  l2-rx (PPP:3/7/1:100), Length:16, Pro:0, Off:0, Pri:0, RM:0, Err:0 [0x4001, 0x30000]\n          00 D0 D8 D2 FF 03 C0 21  09 29 00 08 6D FE FA AA\n\n  2000-2-1,18:20:17.0:  l2-tx (PPP:3/7/1:100), Length:16, Pro:0, Off:0, Pri:0, RM:0, Err:0 [0x4000, 0x0]\n          00 D0 D8 D2 FF 03 C0 21  0A 29 00 08 6B 60 84 AA\n\n  2000-2-1,18:20:17.0:  l2-rx (PPP:3/7/1:100), Length:16, Pro:0, Off:0, Pri:0, RM:0, Err:0 [0x4001, 0x8030000]\n          00 D0 D8 D2 FF 03 C0 21  0A 29 00 08 6D FE FA AA\n\n  nt 1 length 500\n  vpn 200 : [max tries 1, timeout 5 seconds, data length 500 bytes, ttl 255]\n  2000-2-1,18:20:24.1:  l2-tx (PPP:3/7/1:100), Length:536, Pro:1, Off:8, Pri:7, RM:0, Err:0 [0x4070, 0x801]\n          00 D0 D8 D2 FF 03 00 21  45 00 02 10 00 27 00 00\n          FF 01 69 51 14 14 14 22  14 14 14 2B 08 00 AD B8\n          00 03 00 01 10 11 12 13  14 15 16 17 18 19 1A 1B\n          1C 1D 1E 1F 20 21 22 23  24 25 26 27 28 29 2A 2B\n          2C 2D 2E 2F 30 31 32 33  34 35 36 37 38 39 3A 3B\n          3C 3D 3E 3F 40 41 42 43  44 45 46 47 48 49 4A 4B\n          4C 4D 4E 4F\n\n  ping #1 ok, RTT 0.010 seconds\n  2000-2-1,18:20:24.1:  l2-rx (PPP:3/7/1:100), Length:536, Pro:1, Off:8, Pri:7, RM:0, Err:0 [0x4071, 0x30801]\n          00 D0 D8 D2 FF 03 00 21  45 00 02 10 00 23 00 00\n          FF 01 69 55 14 14 14 2B  14 14 14 22 00 00 B5 B8\n          00 03 00 01 10 11 12 13  14 15 16 17 18 19 1A 1B\n          1C 1D 1E 1F 20 21 22 23  24 25 26 27 28 29 2A 2B\n          2C 2D 2E 2F 30 31 32 33  34 35 36 37 38 39 3A 3B\n          3C 3D 3E 3F 40 41 42 43  44 45 46 47 48 49 4A 4B\n          4C 4D 4E 4F\n\n  [finished]\n\n  IPNOS: CONFIG VPN(200) VR(3.3.3.3)# 2000-2-1,18:20:27.0:  l2-tx (PPP:3/7/1:100), Length:16, Pro:0, Off:0, Pri:0, RM:0, Err:0 [0x4000, 0x0]\n\n          00 D0 D8 D2 FF 03 C0 21  09 2A 00 08 6B 60 84 AA\n\n  2000-2-1,18:20:27.0:  l2-rx (PPP:3/7/1:100), Length:16, Pro:0, Off:0, Pri:0, RM:0, Err:0 [0x4001, 0x30000]\n          00 D0 D8 D2 FF 03 C0 21  09 2A 00 08 6D FE FA AA\n\n  2000-2-1,18:20:27.0:  l2-tx (PPP:3/7/1:100), Length:16, Pro:0, Off:0, Pri:0, RM:0, Err:0 [0x4000, 0x0]\n          00 D0 D8 D2 FF 03 C0 21  0A 2A 00 08 6B 60 84 AA\n\n  2000-2-1,18:20:27.0:  l2-rx (PPP:3/7/1:100), Length:16, Pro:0, Off:0, Pri:0, RM:0, Err:0 [0x4001, 0x30000]\n          00 D0 D8 D2 FF 03 C0 21  0A 2A 00 08 6D FE FA AA\n\n\n  ipnos diags: Control (1/0) :: layer-2 apply 3 0x0701 100 0 0\n  Successfully applied packet-log-profile on LI\n  ipnos diags: Control (1/0) ::\n\n */\n\n/* XXX TODO:\n\n  o Handle a case where an empty line doesn't exists as a delimiter of\n    each packet. If the output is sent to a control blade and\n    displayed as an event log, there's always an empty line between\n    each packet output, but it may not be true when it is an PE\n    output.\n\n  o Some telnet client on Windows may put in a line break at 80\n    columns when it save the session to a text file (\"CRT\" is such an\n    example). I don't think it's a good idea for the telnet client to\n    do so, but CRT is widely used in Windows community, I should\n    take care of that in the future.\n\n*/\n\n/* Magic text to check for CoSine L2 debug output */\n#define COSINE_HDR_MAGIC_STR1\t\"l2-tx\"\n#define COSINE_HDR_MAGIC_STR2\t\"l2-rx\"\n\n/* Magic text for start of packet */\n#define COSINE_REC_MAGIC_STR1\tCOSINE_HDR_MAGIC_STR1\n#define COSINE_REC_MAGIC_STR2\tCOSINE_HDR_MAGIC_STR2\n\n#define COSINE_HEADER_LINES_TO_CHECK\t200\n#define COSINE_LINE_LENGTH\t\t240\n\nstatic bool empty_line(const char *line);\nstatic int64_t cosine_seek_next_packet(wtap *wth, int *err, char **err_info,\n\tchar *hdr);\nstatic bool cosine_check_file_type(wtap *wth, int *err, char **err_info);\nstatic bool cosine_read(wtap *wth, wtap_rec *rec,\n\tint *err, char **err_info, int64_t *data_offset);\nstatic bool cosine_seek_read(wtap *wth, int64_t seek_off,\n\twtap_rec *rec, int *err, char **err_info);\nstatic bool parse_cosine_packet(FILE_T fh, wtap_rec *rec,\n\tchar *line, int *err, char **err_info);\nstatic int parse_single_hex_dump_line(char* rec, uint8_t *buf,\n\tunsigned byte_offset);\n\nstatic int cosine_file_type_subtype = -1;\n\nvoid register_cosine(void);\n\n/* Returns true if the line appears to be an empty line. Otherwise it\n   returns false. */\nstatic bool empty_line(const char *line)\n{\n\twhile (*line) {\n\t\tif (g_ascii_isspace(*line)) {\n\t\t\tline++;\n\t\t\tcontinue;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (*line == '\\0')\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\n/* Seeks to the beginning of the next packet, and returns the\n   byte offset. Copy the header line to hdr. Returns -1 on failure,\n   and sets \"*err\" to the error and sets \"*err_info\" to null or an\n   additional error string. */\nstatic int64_t cosine_seek_next_packet(wtap *wth, int *err, char **err_info,\n\tchar *hdr)\n{\n\tint64_t cur_off;\n\tchar buf[COSINE_LINE_LENGTH];\n\n\twhile (1) {\n\t\tcur_off = file_tell(wth->fh);\n\t\tif (cur_off == -1) {\n\t\t\t/* Error */\n\t\t\t*err = file_error(wth->fh, err_info);\n\t\t\treturn -1;\n\t\t}\n\t\tif (file_gets(buf, sizeof(buf), wth->fh) == NULL) {\n\t\t\t*err = file_error(wth->fh, err_info);\n\t\t\treturn -1;\n\t\t}\n\t\tif (strstr(buf, COSINE_REC_MAGIC_STR1) ||\n\t\t    strstr(buf, COSINE_REC_MAGIC_STR2)) {\n\t\t\t(void) g_strlcpy(hdr, buf, COSINE_LINE_LENGTH);\n\t\t\treturn cur_off;\n\t\t}\n\t}\n\treturn -1;\n}\n\n/* Look through the first part of a file to see if this is\n * a CoSine L2 debug output.\n *\n * Returns true if it is, false if it isn't or if we get an I/O error;\n * if we get an I/O error, \"*err\" will be set to a non-zero value and\n * \"*err_info\" will be set to null or an additional error string.\n */\nstatic bool cosine_check_file_type(wtap *wth, int *err, char **err_info)\n{\n\tchar\tbuf[COSINE_LINE_LENGTH];\n\tsize_t\treclen;\n\tunsigned\tline;\n\n\tbuf[COSINE_LINE_LENGTH-1] = '\\0';\n\n\tfor (line = 0; line < COSINE_HEADER_LINES_TO_CHECK; line++) {\n\t\tif (file_gets(buf, COSINE_LINE_LENGTH, wth->fh) == NULL) {\n\t\t\t/* EOF or error. */\n\t\t\t*err = file_error(wth->fh, err_info);\n\t\t\treturn false;\n\t\t}\n\n\t\treclen = strlen(buf);\n\t\tif (reclen < MIN(strlen(COSINE_HDR_MAGIC_STR1), strlen(COSINE_HDR_MAGIC_STR2))) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (strstr(buf, COSINE_HDR_MAGIC_STR1) ||\n\t\t    strstr(buf, COSINE_HDR_MAGIC_STR2)) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t*err = 0;\n\treturn false;\n}\n\n\nwtap_open_return_val cosine_open(wtap *wth, int *err, char **err_info)\n{\n\t/* Look for CoSine header */\n\tif (!cosine_check_file_type(wth, err, err_info)) {\n\t\tif (*err != 0 && *err != WTAP_ERR_SHORT_READ)\n\t\t\treturn WTAP_OPEN_ERROR;\n\t\treturn WTAP_OPEN_NOT_MINE;\n\t}\n\n\tif (file_seek(wth->fh, 0L, SEEK_SET, err) == -1)\t/* rewind */\n\t\treturn WTAP_OPEN_ERROR;\n\n\twth->file_encap = WTAP_ENCAP_COSINE;\n\twth->file_type_subtype = cosine_file_type_subtype;\n\twth->snapshot_length = 0; /* not known */\n\twth->subtype_read = cosine_read;\n\twth->subtype_seek_read = cosine_seek_read;\n\twth->file_tsprec = WTAP_TSPREC_10_MSEC;\n\n\t/*\n\t * Add an IDB; we don't know how many interfaces were\n\t * involved, so we just say one interface, about which\n\t * we only know the link-layer type, snapshot length,\n\t * and time stamp resolution.\n\t */\n\twtap_add_generated_idb(wth);\n\n\treturn WTAP_OPEN_MINE;\n}\n\n/* Find the next packet and parse it; called from wtap_read(). */\nstatic bool cosine_read(wtap *wth, wtap_rec *rec,\n    int *err, char **err_info, int64_t *data_offset)\n{\n\tint64_t\toffset;\n\tchar\tline[COSINE_LINE_LENGTH];\n\n\t/* Find the next packet */\n\toffset = cosine_seek_next_packet(wth, err, err_info, line);\n\tif (offset < 0)\n\t\treturn false;\n\t*data_offset = offset;\n\n\t/* Parse the header and convert the ASCII hex dump to binary data */\n\treturn parse_cosine_packet(wth->fh, rec, line, err, err_info);\n}\n\n/* Used to read packets in random-access fashion */\nstatic bool\ncosine_seek_read(wtap *wth, int64_t seek_off, wtap_rec *rec,\n\tint *err, char **err_info)\n{\n\tchar\tline[COSINE_LINE_LENGTH];\n\n\tif (file_seek(wth->random_fh, seek_off, SEEK_SET, err) == -1)\n\t\treturn false;\n\n\tif (file_gets(line, COSINE_LINE_LENGTH, wth->random_fh) == NULL) {\n\t\t*err = file_error(wth->random_fh, err_info);\n\t\tif (*err == 0) {\n\t\t\t*err = WTAP_ERR_SHORT_READ;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/* Parse the header and convert the ASCII hex dump to binary data */\n\treturn parse_cosine_packet(wth->random_fh, rec, line, err, err_info);\n}\n\n/* Parses a packet record header. There are two possible formats:\n    1) output to a control blade with date and time\n        2002-5-10,20:1:31.4:  l2-tx (FR:3/7/1:1), Length:18, Pro:0, Off:0, Pri:0, RM:0, Err:0 [0x4000, 0x0]\n    2) output to PE without date and time\n        l2-tx (FR:3/7/1:1), Length:18, Pro:0, Off:0, Pri:0, RM:0, Err:0 [0x4000, 0x0] */\nstatic bool\nparse_cosine_packet(FILE_T fh, wtap_rec *rec,\n    char *line, int *err, char **err_info)\n{\n\tunion wtap_pseudo_header *pseudo_header = &rec->rec_header.packet_header.pseudo_header;\n\tint\tnum_items_scanned;\n\tint\tyy, mm, dd, hr, min, sec, csec, pkt_len;\n\tint\tpro, off, pri, rm, error;\n\tunsigned\tcode1, code2;\n\tchar\tif_name[COSINE_MAX_IF_NAME_LEN] = \"\", direction[6] = \"\";\n\tstruct\ttm tm;\n\tuint8_t *pd;\n\tint\ti, hex_lines, n, caplen = 0;\n\n\tif (sscanf(line, \"%4d-%2d-%2d,%2d:%2d:%2d.%9d:\",\n\t\t   &yy, &mm, &dd, &hr, &min, &sec, &csec) == 7) {\n\t\t/* appears to be output to a control blade */\n\t\tnum_items_scanned = sscanf(line,\n\t\t   \"%4d-%2d-%2d,%2d:%2d:%2d.%9d: %5s (%127[A-Za-z0-9/:]), Length:%9d, Pro:%9d, Off:%9d, Pri:%9d, RM:%9d, Err:%9d [%8x, %8x]\",\n\t\t\t&yy, &mm, &dd, &hr, &min, &sec, &csec,\n\t\t\t\t   direction, if_name, &pkt_len,\n\t\t\t\t   &pro, &off, &pri, &rm, &error,\n\t\t\t\t   &code1, &code2);\n\n\t\tif (num_items_scanned != 17) {\n\t\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t\t*err_info = g_strdup(\"cosine: purported control blade line doesn't have code values\");\n\t\t\treturn false;\n\t\t}\n\t} else {\n\t\t/* appears to be output to PE */\n\t\tnum_items_scanned = sscanf(line,\n\t\t   \"%5s (%127[A-Za-z0-9/:]), Length:%9d, Pro:%9d, Off:%9d, Pri:%9d, RM:%9d, Err:%9d [%8x, %8x]\",\n\t\t\t\t   direction, if_name, &pkt_len,\n\t\t\t\t   &pro, &off, &pri, &rm, &error,\n\t\t\t\t   &code1, &code2);\n\n\t\tif (num_items_scanned != 10) {\n\t\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t\t*err_info = g_strdup(\"cosine: header line is neither control blade nor PE output\");\n\t\t\treturn false;\n\t\t}\n\t\tyy = mm = dd = hr = min = sec = csec = 0;\n\t}\n\tif (pkt_len < 0) {\n\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t*err_info = g_strdup(\"cosine: packet header has a negative packet length\");\n\t\treturn false;\n\t}\n\tif ((unsigned)pkt_len > WTAP_MAX_PACKET_SIZE_STANDARD) {\n\t\t/*\n\t\t * Probably a corrupt capture file; don't blow up trying\n\t\t * to allocate space for an immensely-large packet.\n\t\t */\n\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t*err_info = ws_strdup_printf(\"cosine: File has %u-byte packet, bigger than maximum of %u\",\n\t\t    (unsigned)pkt_len, WTAP_MAX_PACKET_SIZE_STANDARD);\n\t\treturn false;\n\t}\n\n\trec->rec_type = REC_TYPE_PACKET;\n\trec->block = wtap_block_create(WTAP_BLOCK_PACKET);\n\trec->presence_flags = WTAP_HAS_TS|WTAP_HAS_CAP_LEN;\n\ttm.tm_year = yy - 1900;\n\ttm.tm_mon = mm - 1;\n\ttm.tm_mday = dd;\n\ttm.tm_hour = hr;\n\ttm.tm_min = min;\n\ttm.tm_sec = sec;\n\ttm.tm_isdst = -1;\n\trec->ts.secs = mktime(&tm);\n\trec->ts.nsecs = csec * 10000000;\n\trec->rec_header.packet_header.len = pkt_len;\n\n\t/* XXX need to handle other encapsulations like Cisco HDLC,\n\t   Frame Relay and ATM */\n\tif (strncmp(if_name, \"TEST:\", 5) == 0) {\n\t\tpseudo_header->cosine.encap = COSINE_ENCAP_TEST;\n\t} else if (strncmp(if_name, \"PPoATM:\", 7) == 0) {\n\t\tpseudo_header->cosine.encap = COSINE_ENCAP_PPoATM;\n\t} else if (strncmp(if_name, \"PPoFR:\", 6) == 0) {\n\t\tpseudo_header->cosine.encap = COSINE_ENCAP_PPoFR;\n\t} else if (strncmp(if_name, \"ATM:\", 4) == 0) {\n\t\tpseudo_header->cosine.encap = COSINE_ENCAP_ATM;\n\t} else if (strncmp(if_name, \"FR:\", 3) == 0) {\n\t\tpseudo_header->cosine.encap = COSINE_ENCAP_FR;\n\t} else if (strncmp(if_name, \"HDLC:\", 5) == 0) {\n\t\tpseudo_header->cosine.encap = COSINE_ENCAP_HDLC;\n\t} else if (strncmp(if_name, \"PPP:\", 4) == 0) {\n\t\tpseudo_header->cosine.encap = COSINE_ENCAP_PPP;\n\t} else if (strncmp(if_name, \"ETH:\", 4) == 0) {\n\t\tpseudo_header->cosine.encap = COSINE_ENCAP_ETH;\n\t} else {\n\t\tpseudo_header->cosine.encap = COSINE_ENCAP_UNKNOWN;\n\t}\n\tif (strncmp(direction, \"l2-tx\", 5) == 0) {\n\t\tpseudo_header->cosine.direction = COSINE_DIR_TX;\n\t} else if (strncmp(direction, \"l2-rx\", 5) == 0) {\n\t\tpseudo_header->cosine.direction = COSINE_DIR_RX;\n\t}\n\t(void) g_strlcpy(pseudo_header->cosine.if_name, if_name,\n\t\tCOSINE_MAX_IF_NAME_LEN);\n\tpseudo_header->cosine.pro = pro;\n\tpseudo_header->cosine.off = off;\n\tpseudo_header->cosine.pri = pri;\n\tpseudo_header->cosine.rm = rm;\n\tpseudo_header->cosine.err = error;\n\n\t/* Make sure we have enough room for the packet */\n\tws_buffer_assure_space(&rec->data, pkt_len);\n\tpd = ws_buffer_start_ptr(&rec->data);\n\n\t/* Calculate the number of hex dump lines, each\n\t * containing 16 bytes of data */\n\thex_lines = pkt_len / 16 + ((pkt_len % 16) ? 1 : 0);\n\n\tfor (i = 0; i < hex_lines; i++) {\n\t\tif (file_gets(line, COSINE_LINE_LENGTH, fh) == NULL) {\n\t\t\t*err = file_error(fh, err_info);\n\t\t\tif (*err == 0) {\n\t\t\t\t*err = WTAP_ERR_SHORT_READ;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\tif (empty_line(line)) {\n\t\t\tbreak;\n\t\t}\n\t\tif ((n = parse_single_hex_dump_line(line, pd, i*16)) == -1) {\n\t\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t\t*err_info = g_strdup(\"cosine: hex dump line doesn't have 16 numbers\");\n\t\t\treturn false;\n\t\t}\n\t\tcaplen += n;\n\t}\n\trec->rec_header.packet_header.caplen = caplen;\n\treturn true;\n}\n\n/* Take a string representing one line from a hex dump and converts\n * the text to binary data. We place the bytes in the buffer at the\n * specified offset.\n *\n * Returns number of bytes successfully read, -1 if bad.  */\nstatic int\nparse_single_hex_dump_line(char* rec, uint8_t *buf, unsigned byte_offset)\n{\n\tint num_items_scanned, i;\n\tunsigned int bytes[16];\n\n\tnum_items_scanned = sscanf(rec, \"%02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\",\n\t\t\t       &bytes[0], &bytes[1], &bytes[2], &bytes[3],\n\t\t\t       &bytes[4], &bytes[5], &bytes[6], &bytes[7],\n\t\t\t       &bytes[8], &bytes[9], &bytes[10], &bytes[11],\n\t\t\t       &bytes[12], &bytes[13], &bytes[14], &bytes[15]);\n\tif (num_items_scanned == 0)\n\t\treturn -1;\n\n\tif (num_items_scanned > 16)\n\t\tnum_items_scanned = 16;\n\n\tfor (i=0; i<num_items_scanned; i++) {\n\t\tbuf[byte_offset + i] = (uint8_t)bytes[i];\n\t}\n\n\treturn num_items_scanned;\n}\n\nstatic const struct supported_block_type cosine_blocks_supported[] = {\n\t/*\n\t * We support packet blocks, with no comments or other options.\n\t */\n\t{ WTAP_BLOCK_PACKET, MULTIPLE_BLOCKS_SUPPORTED, NO_OPTIONS_SUPPORTED }\n};\n\nstatic const struct file_type_subtype_info cosine_info = {\n\t\"CoSine IPSX L2 capture\", \"cosine\", \"txt\", NULL,\n\tfalse, BLOCKS_SUPPORTED(cosine_blocks_supported),\n\tNULL, NULL, NULL\n};\n\nvoid register_cosine(void)\n{\n\tcosine_file_type_subtype = wtap_register_file_type_subtype(&cosine_info);\n\n\t/*\n\t * Register name for backwards compatibility with the\n\t * wtap_filetypes table in Lua.\n\t */\n\twtap_register_backwards_compatibility_lua_name(\"COSINE\",\n\t    cosine_file_type_subtype);\n}\n\n/*\n * Editor modelines  -  https://www.wireshark.org/tools/modelines.html\n *\n * Local variables:\n * c-basic-offset: 8\n * tab-width: 8\n * indent-tabs-mode: t\n * End:\n *\n * vi: set shiftwidth=8 tabstop=8 noexpandtab:\n * :indentSize=8:tabSize=8:noTabs=false:\n */\n", "patch": "@@ -330,8 +330,7 @@ parse_cosine_packet(FILE_T fh, struct wtap_pkthdr *phdr, Buffer *buf,\n {\n \tunion wtap_pseudo_header *pseudo_header = &phdr->pseudo_header;\n \tint\tnum_items_scanned;\n-\tint\tyy, mm, dd, hr, min, sec, csec;\n-\tguint\tpkt_len;\n+\tint\tyy, mm, dd, hr, min, sec, csec, pkt_len;\n \tint\tpro, off, pri, rm, error;\n \tguint\tcode1, code2;\n \tchar\tif_name[COSINE_MAX_IF_NAME_LEN] = \"\", direction[6] = \"\";\n@@ -343,7 +342,7 @@ parse_cosine_packet(FILE_T fh, struct wtap_pkthdr *phdr, Buffer *buf,\n \t\t   &yy, &mm, &dd, &hr, &min, &sec, &csec) == 7) {\n \t\t/* appears to be output to a control blade */\n \t\tnum_items_scanned = sscanf(line,\n-\t\t   \"%4d-%2d-%2d,%2d:%2d:%2d.%9d: %5s (%127[A-Za-z0-9/:]), Length:%9u, Pro:%9d, Off:%9d, Pri:%9d, RM:%9d, Err:%9d [%8x, %8x]\",\n+\t\t   \"%4d-%2d-%2d,%2d:%2d:%2d.%9d: %5s (%127[A-Za-z0-9/:]), Length:%9d, Pro:%9d, Off:%9d, Pri:%9d, RM:%9d, Err:%9d [%8x, %8x]\",\n \t\t\t&yy, &mm, &dd, &hr, &min, &sec, &csec,\n \t\t\t\t   direction, if_name, &pkt_len,\n \t\t\t\t   &pro, &off, &pri, &rm, &error,\n@@ -357,7 +356,7 @@ parse_cosine_packet(FILE_T fh, struct wtap_pkthdr *phdr, Buffer *buf,\n \t} else {\n \t\t/* appears to be output to PE */\n \t\tnum_items_scanned = sscanf(line,\n-\t\t   \"%5s (%127[A-Za-z0-9/:]), Length:%9u, Pro:%9d, Off:%9d, Pri:%9d, RM:%9d, Err:%9d [%8x, %8x]\",\n+\t\t   \"%5s (%127[A-Za-z0-9/:]), Length:%9d, Pro:%9d, Off:%9d, Pri:%9d, RM:%9d, Err:%9d [%8x, %8x]\",\n \t\t\t\t   direction, if_name, &pkt_len,\n \t\t\t\t   &pro, &off, &pri, &rm, &error,\n \t\t\t\t   &code1, &code2);\n@@ -369,6 +368,11 @@ parse_cosine_packet(FILE_T fh, struct wtap_pkthdr *phdr, Buffer *buf,\n \t\t}\n \t\tyy = mm = dd = hr = min = sec = csec = 0;\n \t}\n+\tif (pkt_len < 0) {\n+\t\t*err = WTAP_ERR_BAD_FILE;\n+\t\t*err_info = g_strdup(\"cosine: packet header has a negative packet length\");\n+\t\treturn FALSE;\n+\t}\n \tif (pkt_len > WTAP_MAX_PACKET_SIZE) {\n \t\t/*\n \t\t * Probably a corrupt capture file; don't blow up trying", "file_path": "files/2016_8\\54", "file_language": "c", "file_name": "wiretap/cosine.c", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}], "outdated": 0}
{"index": 17, "cve_id": "CVE-2016-5356", "cwe_id": ["CWE-119"], "cve_language": "C", "cve_description": "wiretap/cosine.c in the CoSine file parser in Wireshark 1.12.x before 1.12.12 and 2.x before 2.0.4 mishandles sscanf unsigned-integer processing, which allows remote attackers to cause a denial of service (application crash) via a crafted file.", "cvss": "5.9", "publish_date": "August 7, 2016", "AV": "NETWORK", "AC": "HIGH", "PR": "NONE", "UI": "NONE", "S": "UNCHANGED", "C": "NONE", "I": "NONE", "A": "HIGH", "commit_id": "f5ec0afb766f19519ea9623152cca3bbe2229500", "commit_message": "Fix packet length handling.\n\nTreat the packet length as unsigned - it shouldn't be negative in the\nfile.  If it is, that'll probably cause the sscanf to fail, so we'll\nreport the file as bad.\n\nCheck it against WTAP_MAX_PACKET_SIZE to make sure we don't try to\nallocate a huge amount of memory, just as we do in other file readers.\n\nUse the now-validated packet size as the length in\nws_buffer_assure_space(), so we are certain to have enough space, and\ndon't allocate too much space.\n\nMerge the header and packet data parsing routines while we're at it.\n\nBug: 12395\nChange-Id: Ia70f33b71ff28451190fcf144c333fd1362646b2\nReviewed-on: https://code.wireshark.org/review/15172\nReviewed-by: Guy Harris <guy@alum.mit.edu>", "commit_date": "2016-04-29T22:51:41Z", "project": "wireshark/wireshark", "url": "https://api.github.com/repos/wireshark/wireshark/commits/f5ec0afb766f19519ea9623152cca3bbe2229500", "html_url": "https://github.com/wireshark/wireshark/commit/f5ec0afb766f19519ea9623152cca3bbe2229500", "windows_before": "", "windows_after": "", "parents": [{"commit_id_before": "69714b7457dc02a80e7ca453b60d5f5432756158", "url_before": "https://api.github.com/repos/wireshark/wireshark/commits/69714b7457dc02a80e7ca453b60d5f5432756158", "html_url_before": "https://github.com/wireshark/wireshark/commit/69714b7457dc02a80e7ca453b60d5f5432756158"}], "details": [{"raw_url": "https://github.com/wireshark/wireshark/raw/f5ec0afb766f19519ea9623152cca3bbe2229500/wiretap/cosine.c", "code": "/* cosine.c\n *\n * CoSine IPNOS L2 debug output parsing\n * Copyright (c) 2002 by Motonori Shindo <motonori@shin.do>\n *\n * Wiretap Library\n * Copyright (c) 1998 by Gilbert Ramirez <gram@alumni.rice.edu>\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version 2\n * of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */\n\n#include \"config.h\"\n#include \"wtap-int.h\"\n#include \"cosine.h\"\n#include \"file_wrappers.h\"\n\n#include <stdlib.h>\n#include <string.h>\n\n/*\n\n  IPNOS: CONFIG VPN(100) VR(1.1.1.1)# diags\n  ipnos diags: Control (1/0) :: layer-2 ?\n  Registered commands for area \"layer-2\"\n      apply-pkt-log-profile  Configure packet logging on an interface\n      create-pkt-log-profile  Set packet-log-profile to be used for packet logging (see layer-2 pkt-log)\n      detail                Get Layer 2 low-level details\n\n  ipnos diags: Control (1/0) :: layer-2 create ?\n      create-pkt-log-profile  <pkt-log-profile-id ctl-tx-trace-length ctl-rx-trace-length data-tx-trace-length data-rx-trace-length pe-logging-or-control-blade>\n\n  ipnos diags: Control (1/0) :: layer-2 create 1 32 32 0 0 0\n  ipnos diags: Control (1/0) :: layer-2 create 2 32 32 100 100 0\n  ipnos diags: Control (1/0) :: layer-2 apply ?\n      apply-pkt-log-profile  <slot port channel subif pkt-log-profile-id>\n\n  ipnos diags: Control (1/0) :: layer-2 apply 3 0x0701 100 0 1\n  Successfully applied packet-log-profile on LI\n\n  -- Note that only the control packets are logged because the data packet size parameters are 0 in profile 1\n  IPNOS: CONFIG VPN(200) VR(3.3.3.3)# ping 20.20.20.43\n  vpn 200 : [max tries 4, timeout 5 seconds, data length 64 bytes, ttl 255]\n  ping #1 ok, RTT 0.000 seconds\n  ping #2 ok, RTT 0.000 seconds\n  ping #3 ok, RTT 0.000 seconds\n  ping #4 ok, RTT 0.000 seconds\n  [finished]\n\n  IPNOS: CONFIG VPN(200) VR(3.3.3.3)# 2000-2-1,18:19:46.8:  l2-tx (PPP:3/7/1:100), Length:16, Pro:0, Off:0, Pri:0, RM:0, Err:0 [0x4000, 0x0]\n\n\n  2000-2-1,18:19:46.8:  l2-rx (PPP:3/7/1:100), Length:16, Pro:0, Off:0, Pri:0, RM:0, Err:0 [0x4001, 0x30000]\n\n  2000-2-1,18:19:46.8:  l2-tx (PPP:3/7/1:100), Length:16, Pro:0, Off:0, Pri:0, RM:0, Err:0 [0x4000, 0x0]\n\n  2000-2-1,18:19:46.8:  l2-rx (PPP:3/7/1:100), Length:16, Pro:0, Off:0, Pri:0, RM:0, Err:0 [0x4001, 0x8030000]\n\n  ipnos diags: Control (1/0) :: layer-2 apply 3 0x0701 100 0 0\n  Successfully applied packet-log-profile on LI\n  ipnos diags: Control (1/0) :: layer-2 apply 3 0x0701 100 0 2\n  Successfully applied packet-log-profile on LI\n\n  -- Note that both control and data packets are logged because the data packet size parameter is 100 in profile 2\n     Please ignore the event-log messages getting mixed up with the ping command\n  ping 20.20.20.43 cou2000-2-1,18:20:17.0:  l2-tx (PPP:3/7/1:100), Length:16, Pro:0, Off:0, Pri:0, RM:0, Err:0 [0x4000, 0x0]\n\n          00 D0 D8 D2 FF 03 C0 21  09 29 00 08 6B 60 84 AA\n\n  2000-2-1,18:20:17.0:  l2-rx (PPP:3/7/1:100), Length:16, Pro:0, Off:0, Pri:0, RM:0, Err:0 [0x4001, 0x30000]\n          00 D0 D8 D2 FF 03 C0 21  09 29 00 08 6D FE FA AA\n\n  2000-2-1,18:20:17.0:  l2-tx (PPP:3/7/1:100), Length:16, Pro:0, Off:0, Pri:0, RM:0, Err:0 [0x4000, 0x0]\n          00 D0 D8 D2 FF 03 C0 21  0A 29 00 08 6B 60 84 AA\n\n  2000-2-1,18:20:17.0:  l2-rx (PPP:3/7/1:100), Length:16, Pro:0, Off:0, Pri:0, RM:0, Err:0 [0x4001, 0x8030000]\n          00 D0 D8 D2 FF 03 C0 21  0A 29 00 08 6D FE FA AA\n\n  nt 1 length 500\n  vpn 200 : [max tries 1, timeout 5 seconds, data length 500 bytes, ttl 255]\n  2000-2-1,18:20:24.1:  l2-tx (PPP:3/7/1:100), Length:536, Pro:1, Off:8, Pri:7, RM:0, Err:0 [0x4070, 0x801]\n          00 D0 D8 D2 FF 03 00 21  45 00 02 10 00 27 00 00\n          FF 01 69 51 14 14 14 22  14 14 14 2B 08 00 AD B8\n          00 03 00 01 10 11 12 13  14 15 16 17 18 19 1A 1B\n          1C 1D 1E 1F 20 21 22 23  24 25 26 27 28 29 2A 2B\n          2C 2D 2E 2F 30 31 32 33  34 35 36 37 38 39 3A 3B\n          3C 3D 3E 3F 40 41 42 43  44 45 46 47 48 49 4A 4B\n          4C 4D 4E 4F\n\n  ping #1 ok, RTT 0.010 seconds\n  2000-2-1,18:20:24.1:  l2-rx (PPP:3/7/1:100), Length:536, Pro:1, Off:8, Pri:7, RM:0, Err:0 [0x4071, 0x30801]\n          00 D0 D8 D2 FF 03 00 21  45 00 02 10 00 23 00 00\n          FF 01 69 55 14 14 14 2B  14 14 14 22 00 00 B5 B8\n          00 03 00 01 10 11 12 13  14 15 16 17 18 19 1A 1B\n          1C 1D 1E 1F 20 21 22 23  24 25 26 27 28 29 2A 2B\n          2C 2D 2E 2F 30 31 32 33  34 35 36 37 38 39 3A 3B\n          3C 3D 3E 3F 40 41 42 43  44 45 46 47 48 49 4A 4B\n          4C 4D 4E 4F\n\n  [finished]\n\n  IPNOS: CONFIG VPN(200) VR(3.3.3.3)# 2000-2-1,18:20:27.0:  l2-tx (PPP:3/7/1:100), Length:16, Pro:0, Off:0, Pri:0, RM:0, Err:0 [0x4000, 0x0]\n\n          00 D0 D8 D2 FF 03 C0 21  09 2A 00 08 6B 60 84 AA\n\n  2000-2-1,18:20:27.0:  l2-rx (PPP:3/7/1:100), Length:16, Pro:0, Off:0, Pri:0, RM:0, Err:0 [0x4001, 0x30000]\n          00 D0 D8 D2 FF 03 C0 21  09 2A 00 08 6D FE FA AA\n\n  2000-2-1,18:20:27.0:  l2-tx (PPP:3/7/1:100), Length:16, Pro:0, Off:0, Pri:0, RM:0, Err:0 [0x4000, 0x0]\n          00 D0 D8 D2 FF 03 C0 21  0A 2A 00 08 6B 60 84 AA\n\n  2000-2-1,18:20:27.0:  l2-rx (PPP:3/7/1:100), Length:16, Pro:0, Off:0, Pri:0, RM:0, Err:0 [0x4001, 0x30000]\n          00 D0 D8 D2 FF 03 C0 21  0A 2A 00 08 6D FE FA AA\n\n\n  ipnos diags: Control (1/0) :: layer-2 apply 3 0x0701 100 0 0\n  Successfully applied packet-log-profile on LI\n  ipnos diags: Control (1/0) ::\n\n */\n\n/* XXX TODO:\n\n  o Handle a case where an empty line doesn't exists as a delimiter of\n    each packet. If the output is sent to a control blade and\n    displayed as an event log, there's always an empty line between\n    each packet output, but it may not be true when it is an PE\n    output.\n\n  o Some telnet client on Windows may put in a line break at 80\n    columns when it save the session to a text file (\"CRT\" is such an\n    example). I don't think it's a good idea for the telnet client to\n    do so, but CRT is widely used in Windows community, I should\n    take care of that in the future.\n\n*/\n\n/* Magic text to check for CoSine L2 debug output */\n#define COSINE_HDR_MAGIC_STR1\t\"l2-tx\"\n#define COSINE_HDR_MAGIC_STR2\t\"l2-rx\"\n\n/* Magic text for start of packet */\n#define COSINE_REC_MAGIC_STR1\tCOSINE_HDR_MAGIC_STR1\n#define COSINE_REC_MAGIC_STR2\tCOSINE_HDR_MAGIC_STR2\n\n#define COSINE_HEADER_LINES_TO_CHECK\t200\n#define COSINE_LINE_LENGTH\t\t240\n\nstatic gboolean empty_line(const gchar *line);\nstatic gint64 cosine_seek_next_packet(wtap *wth, int *err, gchar **err_info,\n\tchar *hdr);\nstatic gboolean cosine_check_file_type(wtap *wth, int *err, gchar **err_info);\nstatic gboolean cosine_read(wtap *wth, int *err, gchar **err_info,\n\tgint64 *data_offset);\nstatic gboolean cosine_seek_read(wtap *wth, gint64 seek_off,\n\tstruct wtap_pkthdr *phdr, Buffer *buf, int *err, gchar **err_info);\nstatic int parse_cosine_packet(FILE_T fh, struct wtap_pkthdr *phdr, Buffer* buf,\n\tchar *line, int *err, gchar **err_info);\nstatic int parse_single_hex_dump_line(char* rec, guint8 *buf,\n\tguint byte_offset);\n\n/* Returns TRUE if the line appears to be an empty line. Otherwise it\n   returns FALSE. */\nstatic gboolean empty_line(const gchar *line)\n{\n\twhile (*line) {\n\t\tif (g_ascii_isspace(*line)) {\n\t\t\tline++;\n\t\t\tcontinue;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (*line == '\\0')\n\t\treturn TRUE;\n\telse\n\t\treturn FALSE;\n}\n\n/* Seeks to the beginning of the next packet, and returns the\n   byte offset. Copy the header line to hdr. Returns -1 on failure,\n   and sets \"*err\" to the error and sets \"*err_info\" to null or an\n   additional error string. */\nstatic gint64 cosine_seek_next_packet(wtap *wth, int *err, gchar **err_info,\n\tchar *hdr)\n{\n\tgint64 cur_off;\n\tchar buf[COSINE_LINE_LENGTH];\n\n\twhile (1) {\n\t\tcur_off = file_tell(wth->fh);\n\t\tif (cur_off == -1) {\n\t\t\t/* Error */\n\t\t\t*err = file_error(wth->fh, err_info);\n\t\t\treturn -1;\n\t\t}\n\t\tif (file_gets(buf, sizeof(buf), wth->fh) == NULL) {\n\t\t\t*err = file_error(wth->fh, err_info);\n\t\t\treturn -1;\n\t\t}\n\t\tif (strstr(buf, COSINE_REC_MAGIC_STR1) ||\n\t\t    strstr(buf, COSINE_REC_MAGIC_STR2)) {\n\t\t\tg_strlcpy(hdr, buf, COSINE_LINE_LENGTH);\n\t\t\treturn cur_off;\n\t\t}\n\t}\n\treturn -1;\n}\n\n/* Look through the first part of a file to see if this is\n * a CoSine L2 debug output.\n *\n * Returns TRUE if it is, FALSE if it isn't or if we get an I/O error;\n * if we get an I/O error, \"*err\" will be set to a non-zero value and\n * \"*err_info\" will be set to null or an additional error string.\n */\nstatic gboolean cosine_check_file_type(wtap *wth, int *err, gchar **err_info)\n{\n\tchar\tbuf[COSINE_LINE_LENGTH];\n\tgsize\treclen;\n\tguint\tline;\n\n\tbuf[COSINE_LINE_LENGTH-1] = '\\0';\n\n\tfor (line = 0; line < COSINE_HEADER_LINES_TO_CHECK; line++) {\n\t\tif (file_gets(buf, COSINE_LINE_LENGTH, wth->fh) == NULL) {\n\t\t\t/* EOF or error. */\n\t\t\t*err = file_error(wth->fh, err_info);\n\t\t\treturn FALSE;\n\t\t}\n\n\t\treclen = strlen(buf);\n\t\tif (reclen < strlen(COSINE_HDR_MAGIC_STR1) ||\n\t\t\treclen < strlen(COSINE_HDR_MAGIC_STR2)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (strstr(buf, COSINE_HDR_MAGIC_STR1) ||\n\t\t    strstr(buf, COSINE_HDR_MAGIC_STR2)) {\n\t\t\treturn TRUE;\n\t\t}\n\t}\n\t*err = 0;\n\treturn FALSE;\n}\n\n\nwtap_open_return_val cosine_open(wtap *wth, int *err, gchar **err_info)\n{\n\t/* Look for CoSine header */\n\tif (!cosine_check_file_type(wth, err, err_info)) {\n\t\tif (*err != 0 && *err != WTAP_ERR_SHORT_READ)\n\t\t\treturn WTAP_OPEN_ERROR;\n\t\treturn WTAP_OPEN_NOT_MINE;\n\t}\n\n\tif (file_seek(wth->fh, 0L, SEEK_SET, err) == -1)\t/* rewind */\n\t\treturn WTAP_OPEN_ERROR;\n\n\twth->file_encap = WTAP_ENCAP_COSINE;\n\twth->file_type_subtype = WTAP_FILE_TYPE_SUBTYPE_COSINE;\n\twth->snapshot_length = 0; /* not known */\n\twth->subtype_read = cosine_read;\n\twth->subtype_seek_read = cosine_seek_read;\n\twth->file_tsprec = WTAP_TSPREC_CSEC;\n\n\treturn WTAP_OPEN_MINE;\n}\n\n/* Find the next packet and parse it; called from wtap_read(). */\nstatic gboolean cosine_read(wtap *wth, int *err, gchar **err_info,\n    gint64 *data_offset)\n{\n\tgint64\toffset;\n\tchar\tline[COSINE_LINE_LENGTH];\n\n\t/* Find the next packet */\n\toffset = cosine_seek_next_packet(wth, err, err_info, line);\n\tif (offset < 0)\n\t\treturn FALSE;\n\t*data_offset = offset;\n\n\t/* Parse the header and convert the ASCII hex dump to binary data */\n\treturn parse_cosine_packet(wth->fh, &wth->phdr, wth->frame_buffer,\n\t    line, err, err_info);\n}\n\n/* Used to read packets in random-access fashion */\nstatic gboolean\ncosine_seek_read(wtap *wth, gint64 seek_off, struct wtap_pkthdr *phdr,\n\tBuffer *buf, int *err, gchar **err_info)\n{\n\tchar\tline[COSINE_LINE_LENGTH];\n\n\tif (file_seek(wth->random_fh, seek_off, SEEK_SET, err) == -1)\n\t\treturn FALSE;\n\n\tif (file_gets(line, COSINE_LINE_LENGTH, wth->random_fh) == NULL) {\n\t\t*err = file_error(wth->random_fh, err_info);\n\t\tif (*err == 0) {\n\t\t\t*err = WTAP_ERR_SHORT_READ;\n\t\t}\n\t\treturn FALSE;\n\t}\n\n\t/* Parse the header and convert the ASCII hex dump to binary data */\n\treturn parse_cosine_packet(wth->random_fh, phdr, buf, line, err,\n\t    err_info);\n}\n\n/* Parses a packet record header. There are two possible formats:\n    1) output to a control blade with date and time\n        2002-5-10,20:1:31.4:  l2-tx (FR:3/7/1:1), Length:18, Pro:0, Off:0, Pri:0, RM:0, Err:0 [0x4000, 0x0]\n    2) output to PE without date and time\n        l2-tx (FR:3/7/1:1), Length:18, Pro:0, Off:0, Pri:0, RM:0, Err:0 [0x4000, 0x0] */\nstatic gboolean\nparse_cosine_packet(FILE_T fh, struct wtap_pkthdr *phdr, Buffer *buf,\n    char *line, int *err, gchar **err_info)\n{\n\tunion wtap_pseudo_header *pseudo_header = &phdr->pseudo_header;\n\tint\tnum_items_scanned;\n\tint\tyy, mm, dd, hr, min, sec, csec;\n\tguint\tpkt_len;\n\tint\tpro, off, pri, rm, error;\n\tguint\tcode1, code2;\n\tchar\tif_name[COSINE_MAX_IF_NAME_LEN] = \"\", direction[6] = \"\";\n\tstruct\ttm tm;\n\tguint8 *pd;\n\tint\ti, hex_lines, n, caplen = 0;\n\n\tif (sscanf(line, \"%4d-%2d-%2d,%2d:%2d:%2d.%9d:\",\n\t\t   &yy, &mm, &dd, &hr, &min, &sec, &csec) == 7) {\n\t\t/* appears to be output to a control blade */\n\t\tnum_items_scanned = sscanf(line,\n\t\t   \"%4d-%2d-%2d,%2d:%2d:%2d.%9d: %5s (%127[A-Za-z0-9/:]), Length:%9u, Pro:%9d, Off:%9d, Pri:%9d, RM:%9d, Err:%9d [%8x, %8x]\",\n\t\t\t&yy, &mm, &dd, &hr, &min, &sec, &csec,\n\t\t\t\t   direction, if_name, &pkt_len,\n\t\t\t\t   &pro, &off, &pri, &rm, &error,\n\t\t\t\t   &code1, &code2);\n\n\t\tif (num_items_scanned != 17) {\n\t\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t\t*err_info = g_strdup(\"cosine: purported control blade line doesn't have code values\");\n\t\t\treturn FALSE;\n\t\t}\n\t} else {\n\t\t/* appears to be output to PE */\n\t\tnum_items_scanned = sscanf(line,\n\t\t   \"%5s (%127[A-Za-z0-9/:]), Length:%9u, Pro:%9d, Off:%9d, Pri:%9d, RM:%9d, Err:%9d [%8x, %8x]\",\n\t\t\t\t   direction, if_name, &pkt_len,\n\t\t\t\t   &pro, &off, &pri, &rm, &error,\n\t\t\t\t   &code1, &code2);\n\n\t\tif (num_items_scanned != 10) {\n\t\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t\t*err_info = g_strdup(\"cosine: header line is neither control blade nor PE output\");\n\t\t\treturn FALSE;\n\t\t}\n\t\tyy = mm = dd = hr = min = sec = csec = 0;\n\t}\n\tif (pkt_len > WTAP_MAX_PACKET_SIZE) {\n\t\t/*\n\t\t * Probably a corrupt capture file; don't blow up trying\n\t\t * to allocate space for an immensely-large packet.\n\t\t */\n\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t*err_info = g_strdup_printf(\"cosine: File has %u-byte packet, bigger than maximum of %u\",\n\t\t    pkt_len, WTAP_MAX_PACKET_SIZE);\n\t\treturn FALSE;\n\t}\n\n\tphdr->rec_type = REC_TYPE_PACKET;\n\tphdr->presence_flags = WTAP_HAS_TS|WTAP_HAS_CAP_LEN;\n\ttm.tm_year = yy - 1900;\n\ttm.tm_mon = mm - 1;\n\ttm.tm_mday = dd;\n\ttm.tm_hour = hr;\n\ttm.tm_min = min;\n\ttm.tm_sec = sec;\n\ttm.tm_isdst = -1;\n\tphdr->ts.secs = mktime(&tm);\n\tphdr->ts.nsecs = csec * 10000000;\n\tphdr->len = pkt_len;\n\n\t/* XXX need to handle other encapsulations like Cisco HDLC,\n\t   Frame Relay and ATM */\n\tif (strncmp(if_name, \"TEST:\", 5) == 0) {\n\t\tpseudo_header->cosine.encap = COSINE_ENCAP_TEST;\n\t} else if (strncmp(if_name, \"PPoATM:\", 7) == 0) {\n\t\tpseudo_header->cosine.encap = COSINE_ENCAP_PPoATM;\n\t} else if (strncmp(if_name, \"PPoFR:\", 6) == 0) {\n\t\tpseudo_header->cosine.encap = COSINE_ENCAP_PPoFR;\n\t} else if (strncmp(if_name, \"ATM:\", 4) == 0) {\n\t\tpseudo_header->cosine.encap = COSINE_ENCAP_ATM;\n\t} else if (strncmp(if_name, \"FR:\", 3) == 0) {\n\t\tpseudo_header->cosine.encap = COSINE_ENCAP_FR;\n\t} else if (strncmp(if_name, \"HDLC:\", 5) == 0) {\n\t\tpseudo_header->cosine.encap = COSINE_ENCAP_HDLC;\n\t} else if (strncmp(if_name, \"PPP:\", 4) == 0) {\n\t\tpseudo_header->cosine.encap = COSINE_ENCAP_PPP;\n\t} else if (strncmp(if_name, \"ETH:\", 4) == 0) {\n\t\tpseudo_header->cosine.encap = COSINE_ENCAP_ETH;\n\t} else {\n\t\tpseudo_header->cosine.encap = COSINE_ENCAP_UNKNOWN;\n\t}\n\tif (strncmp(direction, \"l2-tx\", 5) == 0) {\n\t\tpseudo_header->cosine.direction = COSINE_DIR_TX;\n\t} else if (strncmp(direction, \"l2-rx\", 5) == 0) {\n\t\tpseudo_header->cosine.direction = COSINE_DIR_RX;\n\t}\n\tg_strlcpy(pseudo_header->cosine.if_name, if_name,\n\t\tCOSINE_MAX_IF_NAME_LEN);\n\tpseudo_header->cosine.pro = pro;\n\tpseudo_header->cosine.off = off;\n\tpseudo_header->cosine.pri = pri;\n\tpseudo_header->cosine.rm = rm;\n\tpseudo_header->cosine.err = error;\n\n\t/* Make sure we have enough room for the packet */\n\tws_buffer_assure_space(buf, pkt_len);\n\tpd = ws_buffer_start_ptr(buf);\n\n\t/* Calculate the number of hex dump lines, each\n\t * containing 16 bytes of data */\n\thex_lines = pkt_len / 16 + ((pkt_len % 16) ? 1 : 0);\n\n\tfor (i = 0; i < hex_lines; i++) {\n\t\tif (file_gets(line, COSINE_LINE_LENGTH, fh) == NULL) {\n\t\t\t*err = file_error(fh, err_info);\n\t\t\tif (*err == 0) {\n\t\t\t\t*err = WTAP_ERR_SHORT_READ;\n\t\t\t}\n\t\t\treturn FALSE;\n\t\t}\n\t\tif (empty_line(line)) {\n\t\t\tbreak;\n\t\t}\n\t\tif ((n = parse_single_hex_dump_line(line, pd, i*16)) == -1) {\n\t\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t\t*err_info = g_strdup(\"cosine: hex dump line doesn't have 16 numbers\");\n\t\t\treturn FALSE;\n\t\t}\n\t\tcaplen += n;\n\t}\n\tphdr->caplen = caplen;\n\treturn TRUE;\n}\n\n/* Take a string representing one line from a hex dump and converts\n * the text to binary data. We place the bytes in the buffer at the\n * specified offset.\n *\n * Returns number of bytes successfully read, -1 if bad.  */\nstatic int\nparse_single_hex_dump_line(char* rec, guint8 *buf, guint byte_offset)\n{\n\tint num_items_scanned, i;\n\tunsigned int bytes[16];\n\n\tnum_items_scanned = sscanf(rec, \"%02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\",\n\t\t\t       &bytes[0], &bytes[1], &bytes[2], &bytes[3],\n\t\t\t       &bytes[4], &bytes[5], &bytes[6], &bytes[7],\n\t\t\t       &bytes[8], &bytes[9], &bytes[10], &bytes[11],\n\t\t\t       &bytes[12], &bytes[13], &bytes[14], &bytes[15]);\n\tif (num_items_scanned == 0)\n\t\treturn -1;\n\n\tif (num_items_scanned > 16)\n\t\tnum_items_scanned = 16;\n\n\tfor (i=0; i<num_items_scanned; i++) {\n\t\tbuf[byte_offset + i] = (guint8)bytes[i];\n\t}\n\n\treturn num_items_scanned;\n}\n\n/*\n * Editor modelines  -  http://www.wireshark.org/tools/modelines.html\n *\n * Local variables:\n * c-basic-offset: 8\n * tab-width: 8\n * indent-tabs-mode: t\n * End:\n *\n * vi: set shiftwidth=8 tabstop=8 noexpandtab:\n * :indentSize=8:tabSize=8:noTabs=false:\n */\n", "code_before": "/* cosine.c\n *\n * CoSine IPNOS L2 debug output parsing\n * Copyright (c) 2002 by Motonori Shindo <motonori@shin.do>\n *\n * Wiretap Library\n * Copyright (c) 1998 by Gilbert Ramirez <gram@alumni.rice.edu>\n *\n * SPDX-License-Identifier: GPL-2.0-or-later\n */\n\n#include \"config.h\"\n#include \"cosine.h\"\n#include \"wtap-int.h\"\n#include \"file_wrappers.h\"\n\n#include <stdlib.h>\n#include <string.h>\n\n/*\n\n  IPNOS: CONFIG VPN(100) VR(1.1.1.1)# diags\n  ipnos diags: Control (1/0) :: layer-2 ?\n  Registered commands for area \"layer-2\"\n      apply-pkt-log-profile  Configure packet logging on an interface\n      create-pkt-log-profile  Set packet-log-profile to be used for packet logging (see layer-2 pkt-log)\n      detail                Get Layer 2 low-level details\n\n  ipnos diags: Control (1/0) :: layer-2 create ?\n      create-pkt-log-profile  <pkt-log-profile-id ctl-tx-trace-length ctl-rx-trace-length data-tx-trace-length data-rx-trace-length pe-logging-or-control-blade>\n\n  ipnos diags: Control (1/0) :: layer-2 create 1 32 32 0 0 0\n  ipnos diags: Control (1/0) :: layer-2 create 2 32 32 100 100 0\n  ipnos diags: Control (1/0) :: layer-2 apply ?\n      apply-pkt-log-profile  <slot port channel subif pkt-log-profile-id>\n\n  ipnos diags: Control (1/0) :: layer-2 apply 3 0x0701 100 0 1\n  Successfully applied packet-log-profile on LI\n\n  -- Note that only the control packets are logged because the data packet size parameters are 0 in profile 1\n  IPNOS: CONFIG VPN(200) VR(3.3.3.3)# ping 20.20.20.43\n  vpn 200 : [max tries 4, timeout 5 seconds, data length 64 bytes, ttl 255]\n  ping #1 ok, RTT 0.000 seconds\n  ping #2 ok, RTT 0.000 seconds\n  ping #3 ok, RTT 0.000 seconds\n  ping #4 ok, RTT 0.000 seconds\n  [finished]\n\n  IPNOS: CONFIG VPN(200) VR(3.3.3.3)# 2000-2-1,18:19:46.8:  l2-tx (PPP:3/7/1:100), Length:16, Pro:0, Off:0, Pri:0, RM:0, Err:0 [0x4000, 0x0]\n\n\n  2000-2-1,18:19:46.8:  l2-rx (PPP:3/7/1:100), Length:16, Pro:0, Off:0, Pri:0, RM:0, Err:0 [0x4001, 0x30000]\n\n  2000-2-1,18:19:46.8:  l2-tx (PPP:3/7/1:100), Length:16, Pro:0, Off:0, Pri:0, RM:0, Err:0 [0x4000, 0x0]\n\n  2000-2-1,18:19:46.8:  l2-rx (PPP:3/7/1:100), Length:16, Pro:0, Off:0, Pri:0, RM:0, Err:0 [0x4001, 0x8030000]\n\n  ipnos diags: Control (1/0) :: layer-2 apply 3 0x0701 100 0 0\n  Successfully applied packet-log-profile on LI\n  ipnos diags: Control (1/0) :: layer-2 apply 3 0x0701 100 0 2\n  Successfully applied packet-log-profile on LI\n\n  -- Note that both control and data packets are logged because the data packet size parameter is 100 in profile 2\n     Please ignore the event-log messages getting mixed up with the ping command\n  ping 20.20.20.43 cou2000-2-1,18:20:17.0:  l2-tx (PPP:3/7/1:100), Length:16, Pro:0, Off:0, Pri:0, RM:0, Err:0 [0x4000, 0x0]\n\n          00 D0 D8 D2 FF 03 C0 21  09 29 00 08 6B 60 84 AA\n\n  2000-2-1,18:20:17.0:  l2-rx (PPP:3/7/1:100), Length:16, Pro:0, Off:0, Pri:0, RM:0, Err:0 [0x4001, 0x30000]\n          00 D0 D8 D2 FF 03 C0 21  09 29 00 08 6D FE FA AA\n\n  2000-2-1,18:20:17.0:  l2-tx (PPP:3/7/1:100), Length:16, Pro:0, Off:0, Pri:0, RM:0, Err:0 [0x4000, 0x0]\n          00 D0 D8 D2 FF 03 C0 21  0A 29 00 08 6B 60 84 AA\n\n  2000-2-1,18:20:17.0:  l2-rx (PPP:3/7/1:100), Length:16, Pro:0, Off:0, Pri:0, RM:0, Err:0 [0x4001, 0x8030000]\n          00 D0 D8 D2 FF 03 C0 21  0A 29 00 08 6D FE FA AA\n\n  nt 1 length 500\n  vpn 200 : [max tries 1, timeout 5 seconds, data length 500 bytes, ttl 255]\n  2000-2-1,18:20:24.1:  l2-tx (PPP:3/7/1:100), Length:536, Pro:1, Off:8, Pri:7, RM:0, Err:0 [0x4070, 0x801]\n          00 D0 D8 D2 FF 03 00 21  45 00 02 10 00 27 00 00\n          FF 01 69 51 14 14 14 22  14 14 14 2B 08 00 AD B8\n          00 03 00 01 10 11 12 13  14 15 16 17 18 19 1A 1B\n          1C 1D 1E 1F 20 21 22 23  24 25 26 27 28 29 2A 2B\n          2C 2D 2E 2F 30 31 32 33  34 35 36 37 38 39 3A 3B\n          3C 3D 3E 3F 40 41 42 43  44 45 46 47 48 49 4A 4B\n          4C 4D 4E 4F\n\n  ping #1 ok, RTT 0.010 seconds\n  2000-2-1,18:20:24.1:  l2-rx (PPP:3/7/1:100), Length:536, Pro:1, Off:8, Pri:7, RM:0, Err:0 [0x4071, 0x30801]\n          00 D0 D8 D2 FF 03 00 21  45 00 02 10 00 23 00 00\n          FF 01 69 55 14 14 14 2B  14 14 14 22 00 00 B5 B8\n          00 03 00 01 10 11 12 13  14 15 16 17 18 19 1A 1B\n          1C 1D 1E 1F 20 21 22 23  24 25 26 27 28 29 2A 2B\n          2C 2D 2E 2F 30 31 32 33  34 35 36 37 38 39 3A 3B\n          3C 3D 3E 3F 40 41 42 43  44 45 46 47 48 49 4A 4B\n          4C 4D 4E 4F\n\n  [finished]\n\n  IPNOS: CONFIG VPN(200) VR(3.3.3.3)# 2000-2-1,18:20:27.0:  l2-tx (PPP:3/7/1:100), Length:16, Pro:0, Off:0, Pri:0, RM:0, Err:0 [0x4000, 0x0]\n\n          00 D0 D8 D2 FF 03 C0 21  09 2A 00 08 6B 60 84 AA\n\n  2000-2-1,18:20:27.0:  l2-rx (PPP:3/7/1:100), Length:16, Pro:0, Off:0, Pri:0, RM:0, Err:0 [0x4001, 0x30000]\n          00 D0 D8 D2 FF 03 C0 21  09 2A 00 08 6D FE FA AA\n\n  2000-2-1,18:20:27.0:  l2-tx (PPP:3/7/1:100), Length:16, Pro:0, Off:0, Pri:0, RM:0, Err:0 [0x4000, 0x0]\n          00 D0 D8 D2 FF 03 C0 21  0A 2A 00 08 6B 60 84 AA\n\n  2000-2-1,18:20:27.0:  l2-rx (PPP:3/7/1:100), Length:16, Pro:0, Off:0, Pri:0, RM:0, Err:0 [0x4001, 0x30000]\n          00 D0 D8 D2 FF 03 C0 21  0A 2A 00 08 6D FE FA AA\n\n\n  ipnos diags: Control (1/0) :: layer-2 apply 3 0x0701 100 0 0\n  Successfully applied packet-log-profile on LI\n  ipnos diags: Control (1/0) ::\n\n */\n\n/* XXX TODO:\n\n  o Handle a case where an empty line doesn't exists as a delimiter of\n    each packet. If the output is sent to a control blade and\n    displayed as an event log, there's always an empty line between\n    each packet output, but it may not be true when it is an PE\n    output.\n\n  o Some telnet client on Windows may put in a line break at 80\n    columns when it save the session to a text file (\"CRT\" is such an\n    example). I don't think it's a good idea for the telnet client to\n    do so, but CRT is widely used in Windows community, I should\n    take care of that in the future.\n\n*/\n\n/* Magic text to check for CoSine L2 debug output */\n#define COSINE_HDR_MAGIC_STR1\t\"l2-tx\"\n#define COSINE_HDR_MAGIC_STR2\t\"l2-rx\"\n\n/* Magic text for start of packet */\n#define COSINE_REC_MAGIC_STR1\tCOSINE_HDR_MAGIC_STR1\n#define COSINE_REC_MAGIC_STR2\tCOSINE_HDR_MAGIC_STR2\n\n#define COSINE_HEADER_LINES_TO_CHECK\t200\n#define COSINE_LINE_LENGTH\t\t240\n\nstatic bool empty_line(const char *line);\nstatic int64_t cosine_seek_next_packet(wtap *wth, int *err, char **err_info,\n\tchar *hdr);\nstatic bool cosine_check_file_type(wtap *wth, int *err, char **err_info);\nstatic bool cosine_read(wtap *wth, wtap_rec *rec,\n\tint *err, char **err_info, int64_t *data_offset);\nstatic bool cosine_seek_read(wtap *wth, int64_t seek_off,\n\twtap_rec *rec, int *err, char **err_info);\nstatic bool parse_cosine_packet(FILE_T fh, wtap_rec *rec,\n\tchar *line, int *err, char **err_info);\nstatic int parse_single_hex_dump_line(char* rec, uint8_t *buf,\n\tunsigned byte_offset);\n\nstatic int cosine_file_type_subtype = -1;\n\nvoid register_cosine(void);\n\n/* Returns true if the line appears to be an empty line. Otherwise it\n   returns false. */\nstatic bool empty_line(const char *line)\n{\n\twhile (*line) {\n\t\tif (g_ascii_isspace(*line)) {\n\t\t\tline++;\n\t\t\tcontinue;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (*line == '\\0')\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\n/* Seeks to the beginning of the next packet, and returns the\n   byte offset. Copy the header line to hdr. Returns -1 on failure,\n   and sets \"*err\" to the error and sets \"*err_info\" to null or an\n   additional error string. */\nstatic int64_t cosine_seek_next_packet(wtap *wth, int *err, char **err_info,\n\tchar *hdr)\n{\n\tint64_t cur_off;\n\tchar buf[COSINE_LINE_LENGTH];\n\n\twhile (1) {\n\t\tcur_off = file_tell(wth->fh);\n\t\tif (cur_off == -1) {\n\t\t\t/* Error */\n\t\t\t*err = file_error(wth->fh, err_info);\n\t\t\treturn -1;\n\t\t}\n\t\tif (file_gets(buf, sizeof(buf), wth->fh) == NULL) {\n\t\t\t*err = file_error(wth->fh, err_info);\n\t\t\treturn -1;\n\t\t}\n\t\tif (strstr(buf, COSINE_REC_MAGIC_STR1) ||\n\t\t    strstr(buf, COSINE_REC_MAGIC_STR2)) {\n\t\t\t(void) g_strlcpy(hdr, buf, COSINE_LINE_LENGTH);\n\t\t\treturn cur_off;\n\t\t}\n\t}\n\treturn -1;\n}\n\n/* Look through the first part of a file to see if this is\n * a CoSine L2 debug output.\n *\n * Returns true if it is, false if it isn't or if we get an I/O error;\n * if we get an I/O error, \"*err\" will be set to a non-zero value and\n * \"*err_info\" will be set to null or an additional error string.\n */\nstatic bool cosine_check_file_type(wtap *wth, int *err, char **err_info)\n{\n\tchar\tbuf[COSINE_LINE_LENGTH];\n\tsize_t\treclen;\n\tunsigned\tline;\n\n\tbuf[COSINE_LINE_LENGTH-1] = '\\0';\n\n\tfor (line = 0; line < COSINE_HEADER_LINES_TO_CHECK; line++) {\n\t\tif (file_gets(buf, COSINE_LINE_LENGTH, wth->fh) == NULL) {\n\t\t\t/* EOF or error. */\n\t\t\t*err = file_error(wth->fh, err_info);\n\t\t\treturn false;\n\t\t}\n\n\t\treclen = strlen(buf);\n\t\tif (reclen < MIN(strlen(COSINE_HDR_MAGIC_STR1), strlen(COSINE_HDR_MAGIC_STR2))) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (strstr(buf, COSINE_HDR_MAGIC_STR1) ||\n\t\t    strstr(buf, COSINE_HDR_MAGIC_STR2)) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t*err = 0;\n\treturn false;\n}\n\n\nwtap_open_return_val cosine_open(wtap *wth, int *err, char **err_info)\n{\n\t/* Look for CoSine header */\n\tif (!cosine_check_file_type(wth, err, err_info)) {\n\t\tif (*err != 0 && *err != WTAP_ERR_SHORT_READ)\n\t\t\treturn WTAP_OPEN_ERROR;\n\t\treturn WTAP_OPEN_NOT_MINE;\n\t}\n\n\tif (file_seek(wth->fh, 0L, SEEK_SET, err) == -1)\t/* rewind */\n\t\treturn WTAP_OPEN_ERROR;\n\n\twth->file_encap = WTAP_ENCAP_COSINE;\n\twth->file_type_subtype = cosine_file_type_subtype;\n\twth->snapshot_length = 0; /* not known */\n\twth->subtype_read = cosine_read;\n\twth->subtype_seek_read = cosine_seek_read;\n\twth->file_tsprec = WTAP_TSPREC_10_MSEC;\n\n\t/*\n\t * Add an IDB; we don't know how many interfaces were\n\t * involved, so we just say one interface, about which\n\t * we only know the link-layer type, snapshot length,\n\t * and time stamp resolution.\n\t */\n\twtap_add_generated_idb(wth);\n\n\treturn WTAP_OPEN_MINE;\n}\n\n/* Find the next packet and parse it; called from wtap_read(). */\nstatic bool cosine_read(wtap *wth, wtap_rec *rec,\n    int *err, char **err_info, int64_t *data_offset)\n{\n\tint64_t\toffset;\n\tchar\tline[COSINE_LINE_LENGTH];\n\n\t/* Find the next packet */\n\toffset = cosine_seek_next_packet(wth, err, err_info, line);\n\tif (offset < 0)\n\t\treturn false;\n\t*data_offset = offset;\n\n\t/* Parse the header and convert the ASCII hex dump to binary data */\n\treturn parse_cosine_packet(wth->fh, rec, line, err, err_info);\n}\n\n/* Used to read packets in random-access fashion */\nstatic bool\ncosine_seek_read(wtap *wth, int64_t seek_off, wtap_rec *rec,\n\tint *err, char **err_info)\n{\n\tchar\tline[COSINE_LINE_LENGTH];\n\n\tif (file_seek(wth->random_fh, seek_off, SEEK_SET, err) == -1)\n\t\treturn false;\n\n\tif (file_gets(line, COSINE_LINE_LENGTH, wth->random_fh) == NULL) {\n\t\t*err = file_error(wth->random_fh, err_info);\n\t\tif (*err == 0) {\n\t\t\t*err = WTAP_ERR_SHORT_READ;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/* Parse the header and convert the ASCII hex dump to binary data */\n\treturn parse_cosine_packet(wth->random_fh, rec, line, err, err_info);\n}\n\n/* Parses a packet record header. There are two possible formats:\n    1) output to a control blade with date and time\n        2002-5-10,20:1:31.4:  l2-tx (FR:3/7/1:1), Length:18, Pro:0, Off:0, Pri:0, RM:0, Err:0 [0x4000, 0x0]\n    2) output to PE without date and time\n        l2-tx (FR:3/7/1:1), Length:18, Pro:0, Off:0, Pri:0, RM:0, Err:0 [0x4000, 0x0] */\nstatic bool\nparse_cosine_packet(FILE_T fh, wtap_rec *rec,\n    char *line, int *err, char **err_info)\n{\n\tunion wtap_pseudo_header *pseudo_header = &rec->rec_header.packet_header.pseudo_header;\n\tint\tnum_items_scanned;\n\tint\tyy, mm, dd, hr, min, sec, csec, pkt_len;\n\tint\tpro, off, pri, rm, error;\n\tunsigned\tcode1, code2;\n\tchar\tif_name[COSINE_MAX_IF_NAME_LEN] = \"\", direction[6] = \"\";\n\tstruct\ttm tm;\n\tuint8_t *pd;\n\tint\ti, hex_lines, n, caplen = 0;\n\n\tif (sscanf(line, \"%4d-%2d-%2d,%2d:%2d:%2d.%9d:\",\n\t\t   &yy, &mm, &dd, &hr, &min, &sec, &csec) == 7) {\n\t\t/* appears to be output to a control blade */\n\t\tnum_items_scanned = sscanf(line,\n\t\t   \"%4d-%2d-%2d,%2d:%2d:%2d.%9d: %5s (%127[A-Za-z0-9/:]), Length:%9d, Pro:%9d, Off:%9d, Pri:%9d, RM:%9d, Err:%9d [%8x, %8x]\",\n\t\t\t&yy, &mm, &dd, &hr, &min, &sec, &csec,\n\t\t\t\t   direction, if_name, &pkt_len,\n\t\t\t\t   &pro, &off, &pri, &rm, &error,\n\t\t\t\t   &code1, &code2);\n\n\t\tif (num_items_scanned != 17) {\n\t\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t\t*err_info = g_strdup(\"cosine: purported control blade line doesn't have code values\");\n\t\t\treturn false;\n\t\t}\n\t} else {\n\t\t/* appears to be output to PE */\n\t\tnum_items_scanned = sscanf(line,\n\t\t   \"%5s (%127[A-Za-z0-9/:]), Length:%9d, Pro:%9d, Off:%9d, Pri:%9d, RM:%9d, Err:%9d [%8x, %8x]\",\n\t\t\t\t   direction, if_name, &pkt_len,\n\t\t\t\t   &pro, &off, &pri, &rm, &error,\n\t\t\t\t   &code1, &code2);\n\n\t\tif (num_items_scanned != 10) {\n\t\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t\t*err_info = g_strdup(\"cosine: header line is neither control blade nor PE output\");\n\t\t\treturn false;\n\t\t}\n\t\tyy = mm = dd = hr = min = sec = csec = 0;\n\t}\n\tif (pkt_len < 0) {\n\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t*err_info = g_strdup(\"cosine: packet header has a negative packet length\");\n\t\treturn false;\n\t}\n\tif ((unsigned)pkt_len > WTAP_MAX_PACKET_SIZE_STANDARD) {\n\t\t/*\n\t\t * Probably a corrupt capture file; don't blow up trying\n\t\t * to allocate space for an immensely-large packet.\n\t\t */\n\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t*err_info = ws_strdup_printf(\"cosine: File has %u-byte packet, bigger than maximum of %u\",\n\t\t    (unsigned)pkt_len, WTAP_MAX_PACKET_SIZE_STANDARD);\n\t\treturn false;\n\t}\n\n\trec->rec_type = REC_TYPE_PACKET;\n\trec->block = wtap_block_create(WTAP_BLOCK_PACKET);\n\trec->presence_flags = WTAP_HAS_TS|WTAP_HAS_CAP_LEN;\n\ttm.tm_year = yy - 1900;\n\ttm.tm_mon = mm - 1;\n\ttm.tm_mday = dd;\n\ttm.tm_hour = hr;\n\ttm.tm_min = min;\n\ttm.tm_sec = sec;\n\ttm.tm_isdst = -1;\n\trec->ts.secs = mktime(&tm);\n\trec->ts.nsecs = csec * 10000000;\n\trec->rec_header.packet_header.len = pkt_len;\n\n\t/* XXX need to handle other encapsulations like Cisco HDLC,\n\t   Frame Relay and ATM */\n\tif (strncmp(if_name, \"TEST:\", 5) == 0) {\n\t\tpseudo_header->cosine.encap = COSINE_ENCAP_TEST;\n\t} else if (strncmp(if_name, \"PPoATM:\", 7) == 0) {\n\t\tpseudo_header->cosine.encap = COSINE_ENCAP_PPoATM;\n\t} else if (strncmp(if_name, \"PPoFR:\", 6) == 0) {\n\t\tpseudo_header->cosine.encap = COSINE_ENCAP_PPoFR;\n\t} else if (strncmp(if_name, \"ATM:\", 4) == 0) {\n\t\tpseudo_header->cosine.encap = COSINE_ENCAP_ATM;\n\t} else if (strncmp(if_name, \"FR:\", 3) == 0) {\n\t\tpseudo_header->cosine.encap = COSINE_ENCAP_FR;\n\t} else if (strncmp(if_name, \"HDLC:\", 5) == 0) {\n\t\tpseudo_header->cosine.encap = COSINE_ENCAP_HDLC;\n\t} else if (strncmp(if_name, \"PPP:\", 4) == 0) {\n\t\tpseudo_header->cosine.encap = COSINE_ENCAP_PPP;\n\t} else if (strncmp(if_name, \"ETH:\", 4) == 0) {\n\t\tpseudo_header->cosine.encap = COSINE_ENCAP_ETH;\n\t} else {\n\t\tpseudo_header->cosine.encap = COSINE_ENCAP_UNKNOWN;\n\t}\n\tif (strncmp(direction, \"l2-tx\", 5) == 0) {\n\t\tpseudo_header->cosine.direction = COSINE_DIR_TX;\n\t} else if (strncmp(direction, \"l2-rx\", 5) == 0) {\n\t\tpseudo_header->cosine.direction = COSINE_DIR_RX;\n\t}\n\t(void) g_strlcpy(pseudo_header->cosine.if_name, if_name,\n\t\tCOSINE_MAX_IF_NAME_LEN);\n\tpseudo_header->cosine.pro = pro;\n\tpseudo_header->cosine.off = off;\n\tpseudo_header->cosine.pri = pri;\n\tpseudo_header->cosine.rm = rm;\n\tpseudo_header->cosine.err = error;\n\n\t/* Make sure we have enough room for the packet */\n\tws_buffer_assure_space(&rec->data, pkt_len);\n\tpd = ws_buffer_start_ptr(&rec->data);\n\n\t/* Calculate the number of hex dump lines, each\n\t * containing 16 bytes of data */\n\thex_lines = pkt_len / 16 + ((pkt_len % 16) ? 1 : 0);\n\n\tfor (i = 0; i < hex_lines; i++) {\n\t\tif (file_gets(line, COSINE_LINE_LENGTH, fh) == NULL) {\n\t\t\t*err = file_error(fh, err_info);\n\t\t\tif (*err == 0) {\n\t\t\t\t*err = WTAP_ERR_SHORT_READ;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\tif (empty_line(line)) {\n\t\t\tbreak;\n\t\t}\n\t\tif ((n = parse_single_hex_dump_line(line, pd, i*16)) == -1) {\n\t\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t\t*err_info = g_strdup(\"cosine: hex dump line doesn't have 16 numbers\");\n\t\t\treturn false;\n\t\t}\n\t\tcaplen += n;\n\t}\n\trec->rec_header.packet_header.caplen = caplen;\n\treturn true;\n}\n\n/* Take a string representing one line from a hex dump and converts\n * the text to binary data. We place the bytes in the buffer at the\n * specified offset.\n *\n * Returns number of bytes successfully read, -1 if bad.  */\nstatic int\nparse_single_hex_dump_line(char* rec, uint8_t *buf, unsigned byte_offset)\n{\n\tint num_items_scanned, i;\n\tunsigned int bytes[16];\n\n\tnum_items_scanned = sscanf(rec, \"%02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\",\n\t\t\t       &bytes[0], &bytes[1], &bytes[2], &bytes[3],\n\t\t\t       &bytes[4], &bytes[5], &bytes[6], &bytes[7],\n\t\t\t       &bytes[8], &bytes[9], &bytes[10], &bytes[11],\n\t\t\t       &bytes[12], &bytes[13], &bytes[14], &bytes[15]);\n\tif (num_items_scanned == 0)\n\t\treturn -1;\n\n\tif (num_items_scanned > 16)\n\t\tnum_items_scanned = 16;\n\n\tfor (i=0; i<num_items_scanned; i++) {\n\t\tbuf[byte_offset + i] = (uint8_t)bytes[i];\n\t}\n\n\treturn num_items_scanned;\n}\n\nstatic const struct supported_block_type cosine_blocks_supported[] = {\n\t/*\n\t * We support packet blocks, with no comments or other options.\n\t */\n\t{ WTAP_BLOCK_PACKET, MULTIPLE_BLOCKS_SUPPORTED, NO_OPTIONS_SUPPORTED }\n};\n\nstatic const struct file_type_subtype_info cosine_info = {\n\t\"CoSine IPSX L2 capture\", \"cosine\", \"txt\", NULL,\n\tfalse, BLOCKS_SUPPORTED(cosine_blocks_supported),\n\tNULL, NULL, NULL\n};\n\nvoid register_cosine(void)\n{\n\tcosine_file_type_subtype = wtap_register_file_type_subtype(&cosine_info);\n\n\t/*\n\t * Register name for backwards compatibility with the\n\t * wtap_filetypes table in Lua.\n\t */\n\twtap_register_backwards_compatibility_lua_name(\"COSINE\",\n\t    cosine_file_type_subtype);\n}\n\n/*\n * Editor modelines  -  https://www.wireshark.org/tools/modelines.html\n *\n * Local variables:\n * c-basic-offset: 8\n * tab-width: 8\n * indent-tabs-mode: t\n * End:\n *\n * vi: set shiftwidth=8 tabstop=8 noexpandtab:\n * :indentSize=8:tabSize=8:noTabs=false:\n */\n", "patch": "@@ -157,8 +157,6 @@\n #define COSINE_HEADER_LINES_TO_CHECK\t200\n #define COSINE_LINE_LENGTH\t\t240\n \n-#define COSINE_MAX_PACKET_LEN\t65536\n-\n static gboolean empty_line(const gchar *line);\n static gint64 cosine_seek_next_packet(wtap *wth, int *err, gchar **err_info,\n \tchar *hdr);\n@@ -167,10 +165,8 @@ static gboolean cosine_read(wtap *wth, int *err, gchar **err_info,\n \tgint64 *data_offset);\n static gboolean cosine_seek_read(wtap *wth, gint64 seek_off,\n \tstruct wtap_pkthdr *phdr, Buffer *buf, int *err, gchar **err_info);\n-static int parse_cosine_rec_hdr(struct wtap_pkthdr *phdr, const char *line,\n-\tint *err, gchar **err_info);\n-static gboolean parse_cosine_hex_dump(FILE_T fh, struct wtap_pkthdr *phdr,\n-\tint pkt_len, Buffer* buf, int *err, gchar **err_info);\n+static int parse_cosine_packet(FILE_T fh, struct wtap_pkthdr *phdr, Buffer* buf,\n+\tchar *line, int *err, gchar **err_info);\n static int parse_single_hex_dump_line(char* rec, guint8 *buf,\n \tguint byte_offset);\n \n@@ -287,7 +283,6 @@ static gboolean cosine_read(wtap *wth, int *err, gchar **err_info,\n     gint64 *data_offset)\n {\n \tgint64\toffset;\n-\tint\tpkt_len;\n \tchar\tline[COSINE_LINE_LENGTH];\n \n \t/* Find the next packet */\n@@ -296,22 +291,16 @@ static gboolean cosine_read(wtap *wth, int *err, gchar **err_info,\n \t\treturn FALSE;\n \t*data_offset = offset;\n \n-\t/* Parse the header */\n-\tpkt_len = parse_cosine_rec_hdr(&wth->phdr, line, err, err_info);\n-\tif (pkt_len == -1)\n-\t\treturn FALSE;\n-\n-\t/* Convert the ASCII hex dump to binary data */\n-\treturn parse_cosine_hex_dump(wth->fh, &wth->phdr, pkt_len,\n-\t    wth->frame_buffer, err, err_info);\n+\t/* Parse the header and convert the ASCII hex dump to binary data */\n+\treturn parse_cosine_packet(wth->fh, &wth->phdr, wth->frame_buffer,\n+\t    line, err, err_info);\n }\n \n /* Used to read packets in random-access fashion */\n static gboolean\n cosine_seek_read(wtap *wth, gint64 seek_off, struct wtap_pkthdr *phdr,\n \tBuffer *buf, int *err, gchar **err_info)\n {\n-\tint\tpkt_len;\n \tchar\tline[COSINE_LINE_LENGTH];\n \n \tif (file_seek(wth->random_fh, seek_off, SEEK_SET, err) == -1)\n@@ -325,13 +314,8 @@ cosine_seek_read(wtap *wth, gint64 seek_off, struct wtap_pkthdr *phdr,\n \t\treturn FALSE;\n \t}\n \n-\t/* Parse the header */\n-\tpkt_len = parse_cosine_rec_hdr(phdr, line, err, err_info);\n-\tif (pkt_len == -1)\n-\t\treturn FALSE;\n-\n-\t/* Convert the ASCII hex dump to binary data */\n-\treturn parse_cosine_hex_dump(wth->random_fh, phdr, pkt_len, buf, err,\n+\t/* Parse the header and convert the ASCII hex dump to binary data */\n+\treturn parse_cosine_packet(wth->random_fh, phdr, buf, line, err,\n \t    err_info);\n }\n \n@@ -340,23 +324,26 @@ cosine_seek_read(wtap *wth, gint64 seek_off, struct wtap_pkthdr *phdr,\n         2002-5-10,20:1:31.4:  l2-tx (FR:3/7/1:1), Length:18, Pro:0, Off:0, Pri:0, RM:0, Err:0 [0x4000, 0x0]\n     2) output to PE without date and time\n         l2-tx (FR:3/7/1:1), Length:18, Pro:0, Off:0, Pri:0, RM:0, Err:0 [0x4000, 0x0] */\n-static int\n-parse_cosine_rec_hdr(struct wtap_pkthdr *phdr, const char *line,\n-     int *err, gchar **err_info)\n+static gboolean\n+parse_cosine_packet(FILE_T fh, struct wtap_pkthdr *phdr, Buffer *buf,\n+    char *line, int *err, gchar **err_info)\n {\n \tunion wtap_pseudo_header *pseudo_header = &phdr->pseudo_header;\n \tint\tnum_items_scanned;\n-\tint\tyy, mm, dd, hr, min, sec, csec, pkt_len;\n+\tint\tyy, mm, dd, hr, min, sec, csec;\n+\tguint\tpkt_len;\n \tint\tpro, off, pri, rm, error;\n \tguint\tcode1, code2;\n \tchar\tif_name[COSINE_MAX_IF_NAME_LEN] = \"\", direction[6] = \"\";\n \tstruct\ttm tm;\n+\tguint8 *pd;\n+\tint\ti, hex_lines, n, caplen = 0;\n \n \tif (sscanf(line, \"%4d-%2d-%2d,%2d:%2d:%2d.%9d:\",\n \t\t   &yy, &mm, &dd, &hr, &min, &sec, &csec) == 7) {\n \t\t/* appears to be output to a control blade */\n \t\tnum_items_scanned = sscanf(line,\n-\t\t   \"%4d-%2d-%2d,%2d:%2d:%2d.%9d: %5s (%127[A-Za-z0-9/:]), Length:%9d, Pro:%9d, Off:%9d, Pri:%9d, RM:%9d, Err:%9d [%8x, %8x]\",\n+\t\t   \"%4d-%2d-%2d,%2d:%2d:%2d.%9d: %5s (%127[A-Za-z0-9/:]), Length:%9u, Pro:%9d, Off:%9d, Pri:%9d, RM:%9d, Err:%9d [%8x, %8x]\",\n \t\t\t&yy, &mm, &dd, &hr, &min, &sec, &csec,\n \t\t\t\t   direction, if_name, &pkt_len,\n \t\t\t\t   &pro, &off, &pri, &rm, &error,\n@@ -365,23 +352,33 @@ parse_cosine_rec_hdr(struct wtap_pkthdr *phdr, const char *line,\n \t\tif (num_items_scanned != 17) {\n \t\t\t*err = WTAP_ERR_BAD_FILE;\n \t\t\t*err_info = g_strdup(\"cosine: purported control blade line doesn't have code values\");\n-\t\t\treturn -1;\n+\t\t\treturn FALSE;\n \t\t}\n \t} else {\n \t\t/* appears to be output to PE */\n \t\tnum_items_scanned = sscanf(line,\n-\t\t   \"%5s (%127[A-Za-z0-9/:]), Length:%9d, Pro:%9d, Off:%9d, Pri:%9d, RM:%9d, Err:%9d [%8x, %8x]\",\n+\t\t   \"%5s (%127[A-Za-z0-9/:]), Length:%9u, Pro:%9d, Off:%9d, Pri:%9d, RM:%9d, Err:%9d [%8x, %8x]\",\n \t\t\t\t   direction, if_name, &pkt_len,\n \t\t\t\t   &pro, &off, &pri, &rm, &error,\n \t\t\t\t   &code1, &code2);\n \n \t\tif (num_items_scanned != 10) {\n \t\t\t*err = WTAP_ERR_BAD_FILE;\n \t\t\t*err_info = g_strdup(\"cosine: header line is neither control blade nor PE output\");\n-\t\t\treturn -1;\n+\t\t\treturn FALSE;\n \t\t}\n \t\tyy = mm = dd = hr = min = sec = csec = 0;\n \t}\n+\tif (pkt_len > WTAP_MAX_PACKET_SIZE) {\n+\t\t/*\n+\t\t * Probably a corrupt capture file; don't blow up trying\n+\t\t * to allocate space for an immensely-large packet.\n+\t\t */\n+\t\t*err = WTAP_ERR_BAD_FILE;\n+\t\t*err_info = g_strdup_printf(\"cosine: File has %u-byte packet, bigger than maximum of %u\",\n+\t\t    pkt_len, WTAP_MAX_PACKET_SIZE);\n+\t\treturn FALSE;\n+\t}\n \n \tphdr->rec_type = REC_TYPE_PACKET;\n \tphdr->presence_flags = WTAP_HAS_TS|WTAP_HAS_CAP_LEN;\n@@ -430,21 +427,8 @@ parse_cosine_rec_hdr(struct wtap_pkthdr *phdr, const char *line,\n \tpseudo_header->cosine.rm = rm;\n \tpseudo_header->cosine.err = error;\n \n-\treturn pkt_len;\n-}\n-\n-/* Converts ASCII hex dump to binary data. Returns TRUE on success,\n-   FALSE if any error is encountered. */\n-static gboolean\n-parse_cosine_hex_dump(FILE_T fh, struct wtap_pkthdr *phdr, int pkt_len,\n-    Buffer* buf, int *err, gchar **err_info)\n-{\n-\tguint8 *pd;\n-\tgchar\tline[COSINE_LINE_LENGTH];\n-\tint\ti, hex_lines, n, caplen = 0;\n-\n \t/* Make sure we have enough room for the packet */\n-\tws_buffer_assure_space(buf, COSINE_MAX_PACKET_LEN);\n+\tws_buffer_assure_space(buf, pkt_len);\n \tpd = ws_buffer_start_ptr(buf);\n \n \t/* Calculate the number of hex dump lines, each\n@@ -473,7 +457,6 @@ parse_cosine_hex_dump(FILE_T fh, struct wtap_pkthdr *phdr, int pkt_len,\n \treturn TRUE;\n }\n \n-\n /* Take a string representing one line from a hex dump and converts\n  * the text to binary data. We place the bytes in the buffer at the\n  * specified offset.", "file_path": "files/2016_8\\55", "file_language": "c", "file_name": "wiretap/cosine.c", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}], "outdated": 0}
{"index": 18, "cve_id": "CVE-2016-5357", "cwe_id": ["CWE-20"], "cve_language": "C", "cve_description": "wiretap/netscreen.c in the NetScreen file parser in Wireshark 1.12.x before 1.12.12 and 2.x before 2.0.4 mishandles sscanf unsigned-integer processing, which allows remote attackers to cause a denial of service (application crash) via a crafted file.", "cvss": "5.9", "publish_date": "August 7, 2016", "AV": "NETWORK", "AC": "HIGH", "PR": "NONE", "UI": "NONE", "S": "UNCHANGED", "C": "NONE", "I": "NONE", "A": "HIGH", "commit_id": "11edc83b98a61e890d7bb01855389d40e984ea82", "commit_message": "Don't treat the packet length as unsigned.\n\nThe scanf family of functions are as annoyingly bad at handling unsigned\nnumbers as strtoul() is - both of them are perfectly willing to accept a\nvalue beginning with a negative sign as an unsigned value.  When using\nstrtoul(), you can compensate for this by explicitly checking for a '-'\nas the first character of the string, but you can't do that with\nsscanf().\n\nSo revert to having pkt_len be signed, and scanning it with %d, but\ncheck for a negative value and fail if we see a negative value.\n\nBug: 12396\nChange-Id: I54fe8f61f42c32b5ef33da633ece51bbcda8c95f\nReviewed-on: https://code.wireshark.org/review/15220\nReviewed-by: Guy Harris <guy@alum.mit.edu>", "commit_date": "2016-05-01T23:14:25Z", "project": "wireshark/wireshark", "url": "https://api.github.com/repos/wireshark/wireshark/commits/11edc83b98a61e890d7bb01855389d40e984ea82", "html_url": "https://github.com/wireshark/wireshark/commit/11edc83b98a61e890d7bb01855389d40e984ea82", "windows_before": "", "windows_after": "", "parents": [{"commit_id_before": "29c78db2a80a93653f32e4fd2f00b9b550432c43", "url_before": "https://api.github.com/repos/wireshark/wireshark/commits/29c78db2a80a93653f32e4fd2f00b9b550432c43", "html_url_before": "https://github.com/wireshark/wireshark/commit/29c78db2a80a93653f32e4fd2f00b9b550432c43"}], "details": [{"raw_url": "https://github.com/wireshark/wireshark/raw/11edc83b98a61e890d7bb01855389d40e984ea82/wiretap/netscreen.c", "code": "/* netscreen.c\n *\n * Juniper NetScreen snoop output parser\n * Created by re-using a lot of code from cosine.c\n * Copyright (c) 2007 by Sake Blok <sake@euronet.nl>\n *\n * Wiretap Library\n * Copyright (c) 1998 by Gilbert Ramirez <gram@alumni.rice.edu>\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version 2\n * of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */\n\n#include \"config.h\"\n#include \"wtap-int.h\"\n#include \"netscreen.h\"\n#include \"file_wrappers.h\"\n\n#include <stdlib.h>\n#include <string.h>\n\n/* XXX TODO:\n *\n * o  Construct a list of interfaces, with interface names, give\n *    them link-layer types based on the interface name and packet\n *    data, and supply interface IDs with each packet (i.e., make\n *    this supply a pcap-ng-style set of interfaces and associate\n *    packets with interfaces).  This is probably the right way\n *    to \"Pass the interface names and the traffic direction to either\n *    the frame-structure, a pseudo-header or use PPI.\"  See the\n *    message at\n *\n *        http://www.wireshark.org/lists/wireshark-dev/200708/msg00029.html\n *\n *    to see whether any further discussion is still needed. I suspect\n *    it doesn't; pcap-NG existed at the time, as per the final\n *    message in that thread:\n *\n *        http://www.wireshark.org/lists/wireshark-dev/200708/msg00039.html\n *\n *    but I don't think we fully *supported* it at that point.  Now\n *    that we do, we have the infrastructure to support this, except\n *    that we currently have no way to translate interface IDs to\n *    interface names in the \"frame\" dissector or to supply interface\n *    information as part of the packet metadata from Wiretap modules.\n *    That should be fixed so that we can show interface information,\n *    such as the interface name, in packet dissections from, for example,\n *    pcap-NG captures.\n */\n\nstatic gboolean info_line(const gchar *line);\nstatic gint64 netscreen_seek_next_packet(wtap *wth, int *err, gchar **err_info,\n\tchar *hdr);\nstatic gboolean netscreen_check_file_type(wtap *wth, int *err,\n\tgchar **err_info);\nstatic gboolean netscreen_read(wtap *wth, int *err, gchar **err_info,\n\tgint64 *data_offset);\nstatic gboolean netscreen_seek_read(wtap *wth, gint64 seek_off,\n\tstruct wtap_pkthdr *phdr, Buffer *buf,\n\tint *err, gchar **err_info);\nstatic gboolean parse_netscreen_packet(FILE_T fh, struct wtap_pkthdr *phdr,\n\tBuffer* buf, char *line, int *err, gchar **err_info);\nstatic int parse_single_hex_dump_line(char* rec, guint8 *buf,\n\tguint byte_offset);\n\n/* Returns TRUE if the line appears to be a line with protocol info.\n   Otherwise it returns FALSE. */\nstatic gboolean info_line(const gchar *line)\n{\n\tint i=NETSCREEN_SPACES_ON_INFO_LINE;\n\n\twhile (i-- > 0) {\n\t\tif (g_ascii_isspace(*line)) {\n\t\t\tline++;\n\t\t\tcontinue;\n\t\t} else {\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\treturn TRUE;\n}\n\n/* Seeks to the beginning of the next packet, and returns the\n   byte offset. Copy the header line to hdr. Returns -1 on failure,\n   and sets \"*err\" to the error and sets \"*err_info\" to null or an\n   additional error string. */\nstatic gint64 netscreen_seek_next_packet(wtap *wth, int *err, gchar **err_info,\n    char *hdr)\n{\n\tgint64 cur_off;\n\tchar buf[NETSCREEN_LINE_LENGTH];\n\n\twhile (1) {\n\t\tcur_off = file_tell(wth->fh);\n\t\tif (cur_off == -1) {\n\t\t\t/* Error */\n\t\t\t*err = file_error(wth->fh, err_info);\n\t\t\treturn -1;\n\t\t}\n\t\tif (file_gets(buf, sizeof(buf), wth->fh) == NULL) {\n\t\t\t/* EOF or error. */\n\t\t\t*err = file_error(wth->fh, err_info);\n\t\t\tbreak;\n\t\t}\n\t\tif (strstr(buf, NETSCREEN_REC_MAGIC_STR1) ||\n\t\t    strstr(buf, NETSCREEN_REC_MAGIC_STR2)) {\n\t\t\tg_strlcpy(hdr, buf, NETSCREEN_LINE_LENGTH);\n\t\t\treturn cur_off;\n\t\t}\n\t}\n\treturn -1;\n}\n\n/* Look through the first part of a file to see if this is\n * NetScreen snoop output.\n *\n * Returns TRUE if it is, FALSE if it isn't or if we get an I/O error;\n * if we get an I/O error, \"*err\" will be set to a non-zero value and\n * \"*err_info\" is set to null or an additional error string.\n */\nstatic gboolean netscreen_check_file_type(wtap *wth, int *err, gchar **err_info)\n{\n\tchar\tbuf[NETSCREEN_LINE_LENGTH];\n\tguint\treclen, line;\n\n\tbuf[NETSCREEN_LINE_LENGTH-1] = '\\0';\n\n\tfor (line = 0; line < NETSCREEN_HEADER_LINES_TO_CHECK; line++) {\n\t\tif (file_gets(buf, NETSCREEN_LINE_LENGTH, wth->fh) == NULL) {\n\t\t\t/* EOF or error. */\n\t\t\t*err = file_error(wth->fh, err_info);\n\t\t\treturn FALSE;\n\t\t}\n\n\t\treclen = (guint) strlen(buf);\n\t\tif (reclen < strlen(NETSCREEN_HDR_MAGIC_STR1) ||\n\t\t\treclen < strlen(NETSCREEN_HDR_MAGIC_STR2)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (strstr(buf, NETSCREEN_HDR_MAGIC_STR1) ||\n\t\t    strstr(buf, NETSCREEN_HDR_MAGIC_STR2)) {\n\t\t\treturn TRUE;\n\t\t}\n\t}\n\t*err = 0;\n\treturn FALSE;\n}\n\n\nwtap_open_return_val netscreen_open(wtap *wth, int *err, gchar **err_info)\n{\n\n\t/* Look for a NetScreen snoop header line */\n\tif (!netscreen_check_file_type(wth, err, err_info)) {\n\t\tif (*err != 0 && *err != WTAP_ERR_SHORT_READ)\n\t\t\treturn WTAP_OPEN_ERROR;\n\t\treturn WTAP_OPEN_NOT_MINE;\n\t}\n\n\tif (file_seek(wth->fh, 0L, SEEK_SET, err) == -1)\t/* rewind */\n\t\treturn WTAP_OPEN_ERROR;\n\n\twth->file_encap = WTAP_ENCAP_UNKNOWN;\n\twth->file_type_subtype = WTAP_FILE_TYPE_SUBTYPE_NETSCREEN;\n\twth->snapshot_length = 0; /* not known */\n\twth->subtype_read = netscreen_read;\n\twth->subtype_seek_read = netscreen_seek_read;\n\twth->file_tsprec = WTAP_TSPREC_DSEC;\n\n\treturn WTAP_OPEN_MINE;\n}\n\n/* Find the next packet and parse it; called from wtap_read(). */\nstatic gboolean netscreen_read(wtap *wth, int *err, gchar **err_info,\n    gint64 *data_offset)\n{\n\tgint64\t\toffset;\n\tchar\t\tline[NETSCREEN_LINE_LENGTH];\n\n\t/* Find the next packet */\n\toffset = netscreen_seek_next_packet(wth, err, err_info, line);\n\tif (offset < 0)\n\t\treturn FALSE;\n\n\t/* Parse the header and convert the ASCII hex dump to binary data */\n\tif (!parse_netscreen_packet(wth->fh, &wth->phdr,\n\t    wth->frame_buffer, line, err, err_info))\n\t\treturn FALSE;\n\n\t/*\n\t * If the per-file encapsulation isn't known, set it to this\n\t * packet's encapsulation.\n\t *\n\t * If it *is* known, and it isn't this packet's encapsulation,\n\t * set it to WTAP_ENCAP_PER_PACKET, as this file doesn't\n\t * have a single encapsulation for all packets in the file.\n\t */\n\tif (wth->file_encap == WTAP_ENCAP_UNKNOWN)\n\t\twth->file_encap = wth->phdr.pkt_encap;\n\telse {\n\t\tif (wth->file_encap != wth->phdr.pkt_encap)\n\t\t\twth->file_encap = WTAP_ENCAP_PER_PACKET;\n\t}\n\n\t*data_offset = offset;\n\treturn TRUE;\n}\n\n/* Used to read packets in random-access fashion */\nstatic gboolean\nnetscreen_seek_read(wtap *wth, gint64 seek_off,\n\tstruct wtap_pkthdr *phdr, Buffer *buf,\n\tint *err, gchar **err_info)\n{\n\tchar\t\tline[NETSCREEN_LINE_LENGTH];\n\n\tif (file_seek(wth->random_fh, seek_off, SEEK_SET, err) == -1) {\n\t\treturn FALSE;\n\t}\n\n\tif (file_gets(line, NETSCREEN_LINE_LENGTH, wth->random_fh) == NULL) {\n\t\t*err = file_error(wth->random_fh, err_info);\n\t\tif (*err == 0) {\n\t\t\t*err = WTAP_ERR_SHORT_READ;\n\t\t}\n\t\treturn FALSE;\n\t}\n\n\treturn parse_netscreen_packet(wth->random_fh, phdr, buf, line,\n\t    err, err_info);\n}\n\n/* Parses a packet record header. There are a few possible formats:\n *\n * XXX list extra formats here!\n6843828.0: trust(o) len=98:00121ebbd132->00600868d659/0800\n              192.168.1.1 -> 192.168.1.10/6\n              vhl=45, tos=00, id=37739, frag=0000, ttl=64 tlen=84\n              tcp:ports 2222->2333, seq=3452113890, ack=1540618280, flag=5018/ACK\n              00 60 08 68 d6 59 00 12 1e bb d1 32 08 00 45 00     .`.h.Y.....2..E.\n              00 54 93 6b 00 00 40 06 63 dd c0 a8 01 01 c0 a8     .T.k..@.c.......\n              01 0a 08 ae 09 1d cd c3 13 e2 5b d3 f8 28 50 18     ..........[..(P.\n              1f d4 79 21 00 00 e7 76 89 64 16 e2 19 0a 80 09     ..y!...v.d......\n              31 e7 04 28 04 58 f3 d9 b1 9f 3d 65 1a db d8 61     1..(.X....=e...a\n              2c 21 b6 d3 20 60 0c 8c 35 98 88 cf 20 91 0e a9     ,!...`..5.......\n              1d 0b                                               ..\n\n\n */\nstatic gboolean\nparse_netscreen_packet(FILE_T fh, struct wtap_pkthdr *phdr, Buffer* buf,\n    char *line, int *err, gchar **err_info)\n{\n\tint\t\tpkt_len;\n\tint\t\tsec;\n\tint\t\tdsec;\n\tchar\t\tcap_int[NETSCREEN_MAX_INT_NAME_LENGTH];\n\tchar\t\tdirection[2];\n\tchar\t\tcap_src[13];\n\tchar\t\tcap_dst[13];\n\tguint8\t\t*pd;\n\tgchar\t\t*p;\n\tint\t\tn, i = 0;\n\tint\t\toffset = 0;\n\tgchar\t\tdststr[13];\n\n\tphdr->rec_type = REC_TYPE_PACKET;\n\tphdr->presence_flags = WTAP_HAS_TS|WTAP_HAS_CAP_LEN;\n\n\tif (sscanf(line, \"%9d.%9d: %15[a-z0-9/:.-](%1[io]) len=%9d:%12s->%12s/\",\n\t\t   &sec, &dsec, cap_int, direction, &pkt_len, cap_src, cap_dst) < 5) {\n\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t*err_info = g_strdup(\"netscreen: Can't parse packet-header\");\n\t\treturn -1;\n\t}\n\tif (pkt_len < 0) {\n\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t*err_info = g_strdup(\"netscreen: packet header has a negative packet length\");\n\t\treturn FALSE;\n\t}\n\tif (pkt_len > WTAP_MAX_PACKET_SIZE) {\n\t\t/*\n\t\t * Probably a corrupt capture file; don't blow up trying\n\t\t * to allocate space for an immensely-large packet.\n\t\t */\n\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t*err_info = g_strdup_printf(\"netscreen: File has %u-byte packet, bigger than maximum of %u\",\n\t\t    pkt_len, WTAP_MAX_PACKET_SIZE);\n\t\treturn FALSE;\n\t}\n\n\t/*\n\t * If direction[0] is 'o', the direction is NETSCREEN_EGRESS,\n\t * otherwise it's NETSCREEN_INGRESS.\n\t */\n\n\tphdr->ts.secs  = sec;\n\tphdr->ts.nsecs = dsec * 100000000;\n\tphdr->len = pkt_len;\n\n\t/* Make sure we have enough room for the packet */\n\tws_buffer_assure_space(buf, pkt_len);\n\tpd = ws_buffer_start_ptr(buf);\n\n\twhile(1) {\n\n\t\t/* The last packet is not delimited by an empty line, but by EOF\n\t\t * So accept EOF as a valid delimiter too\n\t\t */\n\t\tif (file_gets(line, NETSCREEN_LINE_LENGTH, fh) == NULL) {\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Skip blanks.\n\t\t * The number of blanks is not fixed - for wireless\n\t\t * interfaces, there may be 14 extra spaces before\n\t\t * the hex data.\n\t\t */\n\t\tfor (p = &line[0]; g_ascii_isspace(*p); p++)\n\t\t\t;\n\t\t/* packets are delimited with empty lines */\n\t\tif (*p == '\\0') {\n\t\t\tbreak;\n\t\t}\n\n\t\tn = parse_single_hex_dump_line(p, pd, offset);\n\n\t\t/* the smallest packet has a length of 6 bytes, if\n\t\t * the first hex-data is less then check whether\n\t\t * it is a info-line and act accordingly\n\t\t */\n\t\tif (offset == 0 && n < 6) {\n\t\t\tif (info_line(line)) {\n\t\t\t\tif (++i <= NETSCREEN_MAX_INFOLINES) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t\t\t*err_info = g_strdup(\"netscreen: cannot parse hex-data\");\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t}\n\n\t\t/* If there is no more data and the line was not empty,\n\t\t * then there must be an error in the file\n\t\t */\n\t\tif (n == -1) {\n\t\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t\t*err_info = g_strdup(\"netscreen: cannot parse hex-data\");\n\t\t\treturn FALSE;\n\t\t}\n\n\t\t/* Adjust the offset to the data that was just added to the buffer */\n\t\toffset += n;\n\n\t\t/* If there was more hex-data than was announced in the len=x\n\t\t * header, then then there must be an error in the file\n\t\t */\n\t\tif (offset > pkt_len) {\n\t\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t\t*err_info = g_strdup(\"netscreen: too much hex-data\");\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\t/*\n\t * Determine the encapsulation type, based on the\n\t * first 4 characters of the interface name\n\t *\n\t * XXX\tconvert this to a 'case' structure when adding more\n\t *\t(non-ethernet) interfacetypes\n\t */\n\tif (strncmp(cap_int, \"adsl\", 4) == 0) {\n\t\t/* The ADSL interface can be bridged with or without\n\t\t * PPP encapsulation. Check whether the first six bytes\n\t\t * of the hex data are the same as the destination mac\n\t\t * address in the header. If they are, assume ethernet\n\t\t * LinkLayer or else PPP\n\t\t */\n\t\tg_snprintf(dststr, 13, \"%02x%02x%02x%02x%02x%02x\",\n\t\t   pd[0], pd[1], pd[2], pd[3], pd[4], pd[5]);\n\t\tif (strncmp(dststr, cap_dst, 12) == 0)\n\t\t\tphdr->pkt_encap = WTAP_ENCAP_ETHERNET;\n\t\telse\n\t\t\tphdr->pkt_encap = WTAP_ENCAP_PPP;\n\t\t}\n\telse if (strncmp(cap_int, \"seri\", 4) == 0)\n\t\tphdr->pkt_encap = WTAP_ENCAP_PPP;\n\telse\n\t\tphdr->pkt_encap = WTAP_ENCAP_ETHERNET;\n\n\tphdr->caplen = offset;\n\n\treturn TRUE;\n}\n\n/* Take a string representing one line from a hex dump, with leading white\n * space removed, and converts the text to binary data. We place the bytes\n * in the buffer at the specified offset.\n *\n * Returns number of bytes successfully read, -1 if bad.  */\nstatic int\nparse_single_hex_dump_line(char* rec, guint8 *buf, guint byte_offset)\n{\n\tint num_items_scanned;\n\tguint8 character;\n\tguint8 byte;\n\n\n\tfor (num_items_scanned = 0; num_items_scanned < 16; num_items_scanned++) {\n\t\tcharacter = *rec++;\n\t\tif (character >= '0' && character <= '9')\n\t\t\tbyte = character - '0' + 0;\n\t\telse if (character >= 'A' && character <= 'F')\n\t\t\tbyte = character - 'A' + 0xA;\n\t\telse if (character >= 'a' && character <= 'f')\n\t\t\tbyte = character - 'a' + 0xa;\n\t\telse if (character == ' ' || character == '\\r' || character == '\\n' || character == '\\0') {\n\t\t\t/* Nothing more to parse */\n\t\t\tbreak;\n\t\t} else\n\t\t\treturn -1; /* not a hex digit, space before ASCII dump, or EOL */\n\t\tbyte <<= 4;\n\t\tcharacter = *rec++ & 0xFF;\n\t\tif (character >= '0' && character <= '9')\n\t\t\tbyte += character - '0' + 0;\n\t\telse if (character >= 'A' && character <= 'F')\n\t\t\tbyte += character - 'A' + 0xA;\n\t\telse if (character >= 'a' && character <= 'f')\n\t\t\tbyte += character - 'a' + 0xa;\n\t\telse\n\t\t\treturn -1; /* not a hex digit */\n\t\tbuf[byte_offset + num_items_scanned] = byte;\n\t\tcharacter = *rec++ & 0xFF;\n\t\tif (character == '\\0' || character == '\\r' || character == '\\n') {\n\t\t\t/* Nothing more to parse */\n\t\t\tbreak;\n\t\t} else if (character != ' ') {\n\t\t\t/* not space before ASCII dump */\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (num_items_scanned == 0)\n\t\treturn -1;\n\n\treturn num_items_scanned;\n}\n\n/*\n * Editor modelines  -  http://www.wireshark.org/tools/modelines.html\n *\n * Local variables:\n * c-basic-offset: 8\n * tab-width: 8\n * indent-tabs-mode: t\n * End:\n *\n * vi: set shiftwidth=8 tabstop=8 noexpandtab:\n * :indentSize=8:tabSize=8:noTabs=false:\n */\n", "code_before": "/* netscreen.c\n *\n * Juniper NetScreen snoop output parser\n * Created by re-using a lot of code from cosine.c\n * Copyright (c) 2007 by Sake Blok <sake@euronet.nl>\n *\n * Wiretap Library\n * Copyright (c) 1998 by Gilbert Ramirez <gram@alumni.rice.edu>\n *\n * SPDX-License-Identifier: GPL-2.0-or-later\n */\n\n#include \"config.h\"\n#include \"netscreen.h\"\n#include \"wtap-int.h\"\n#include \"file_wrappers.h\"\n\n#include <stdlib.h>\n#include <string.h>\n\n/* XXX TODO:\n *\n * o  Construct a list of interfaces, with interface names, give\n *    them link-layer types based on the interface name and packet\n *    data, and supply interface IDs with each packet (i.e., make\n *    this supply a pcapng-style set of interfaces and associate\n *    packets with interfaces).  This is probably the right way\n *    to \"Pass the interface names and the traffic direction to either\n *    the frame-structure, a pseudo-header or use PPI.\"  See the\n *    message at\n *\n *        https://lists.wireshark.org/archives/wireshark-dev/200708/msg00029.html\n *\n *    to see whether any further discussion is still needed. I suspect\n *    it doesn't; pcapng existed at the time, as per the final\n *    message in that thread:\n *\n *        https://lists.wireshark.org/archives/wireshark-dev/200708/msg00039.html\n *\n *    but I don't think we fully *supported* it at that point.  Now\n *    that we do, we have the infrastructure to support this, except\n *    that we currently have no way to translate interface IDs to\n *    interface names in the \"frame\" dissector or to supply interface\n *    information as part of the packet metadata from Wiretap modules.\n *    That should be fixed so that we can show interface information,\n *    such as the interface name, in packet dissections from, for example,\n *    pcapng captures.\n */\n\nstatic bool info_line(const char *line);\nstatic int64_t netscreen_seek_next_packet(wtap *wth, int *err, char **err_info,\n\tchar *hdr);\nstatic bool netscreen_check_file_type(wtap *wth, int *err,\n\tchar **err_info);\nstatic bool netscreen_read(wtap *wth, wtap_rec *rec,\n\tint *err, char **err_info, int64_t *data_offset);\nstatic bool netscreen_seek_read(wtap *wth, int64_t seek_off,\n\twtap_rec *rec, int *err, char **err_info);\nstatic bool parse_netscreen_packet(FILE_T fh, wtap_rec *rec,\n\tchar *line, int *err, char **err_info);\nstatic int parse_single_hex_dump_line(char* rec, uint8_t *buf,\n\tunsigned byte_offset, unsigned pkt_len);\n\n/* Error returns from parse_single_hex_dump_line() */\n#define PARSE_LINE_INVALID_CHARACTER\t-1\n#define PARSE_LINE_NO_BYTES_SEEN\t-2\n#define PARSE_LINE_TOO_MANY_BYTES_SEEN\t-3\n\nstatic int netscreen_file_type_subtype = -1;\n\nvoid register_netscreen(void);\n\n/* Returns true if the line appears to be a line with protocol info.\n   Otherwise it returns false. */\nstatic bool info_line(const char *line)\n{\n\tint i=NETSCREEN_SPACES_ON_INFO_LINE;\n\n\twhile (i-- > 0) {\n\t\tif (g_ascii_isspace(*line)) {\n\t\t\tline++;\n\t\t\tcontinue;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\n/* Seeks to the beginning of the next packet, and returns the\n   byte offset. Copy the header line to hdr. Returns -1 on failure,\n   and sets \"*err\" to the error and sets \"*err_info\" to null or an\n   additional error string. */\nstatic int64_t netscreen_seek_next_packet(wtap *wth, int *err, char **err_info,\n    char *hdr)\n{\n\tint64_t cur_off;\n\tchar buf[NETSCREEN_LINE_LENGTH];\n\n\twhile (1) {\n\t\tcur_off = file_tell(wth->fh);\n\t\tif (cur_off == -1) {\n\t\t\t/* Error */\n\t\t\t*err = file_error(wth->fh, err_info);\n\t\t\treturn -1;\n\t\t}\n\t\tif (file_gets(buf, sizeof(buf), wth->fh) == NULL) {\n\t\t\t/* EOF or error. */\n\t\t\t*err = file_error(wth->fh, err_info);\n\t\t\tbreak;\n\t\t}\n\t\tif (strstr(buf, NETSCREEN_REC_MAGIC_STR1) ||\n\t\t    strstr(buf, NETSCREEN_REC_MAGIC_STR2)) {\n\t\t\t(void) g_strlcpy(hdr, buf, NETSCREEN_LINE_LENGTH);\n\t\t\treturn cur_off;\n\t\t}\n\t}\n\treturn -1;\n}\n\n/* Look through the first part of a file to see if this is\n * NetScreen snoop output.\n *\n * Returns true if it is, false if it isn't or if we get an I/O error;\n * if we get an I/O error, \"*err\" will be set to a non-zero value and\n * \"*err_info\" is set to null or an additional error string.\n */\nstatic bool netscreen_check_file_type(wtap *wth, int *err, char **err_info)\n{\n\tchar\tbuf[NETSCREEN_LINE_LENGTH];\n\tunsigned\treclen, line;\n\n\tbuf[NETSCREEN_LINE_LENGTH-1] = '\\0';\n\n\tfor (line = 0; line < NETSCREEN_HEADER_LINES_TO_CHECK; line++) {\n\t\tif (file_gets(buf, NETSCREEN_LINE_LENGTH, wth->fh) == NULL) {\n\t\t\t/* EOF or error. */\n\t\t\t*err = file_error(wth->fh, err_info);\n\t\t\treturn false;\n\t\t}\n\n\t\treclen = (unsigned) strlen(buf);\n\t\tif (reclen < MIN(strlen(NETSCREEN_HDR_MAGIC_STR1), strlen(NETSCREEN_HDR_MAGIC_STR2))) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (strstr(buf, NETSCREEN_HDR_MAGIC_STR1) ||\n\t\t    strstr(buf, NETSCREEN_HDR_MAGIC_STR2)) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t*err = 0;\n\treturn false;\n}\n\n\nwtap_open_return_val netscreen_open(wtap *wth, int *err, char **err_info)\n{\n\n\t/* Look for a NetScreen snoop header line */\n\tif (!netscreen_check_file_type(wth, err, err_info)) {\n\t\tif (*err != 0 && *err != WTAP_ERR_SHORT_READ)\n\t\t\treturn WTAP_OPEN_ERROR;\n\t\treturn WTAP_OPEN_NOT_MINE;\n\t}\n\n\tif (file_seek(wth->fh, 0L, SEEK_SET, err) == -1)\t/* rewind */\n\t\treturn WTAP_OPEN_ERROR;\n\n\twth->file_encap = WTAP_ENCAP_UNKNOWN;\n\twth->file_type_subtype = netscreen_file_type_subtype;\n\twth->snapshot_length = 0; /* not known */\n\twth->subtype_read = netscreen_read;\n\twth->subtype_seek_read = netscreen_seek_read;\n\twth->file_tsprec = WTAP_TSPREC_100_MSEC;\n\n\treturn WTAP_OPEN_MINE;\n}\n\n/* Find the next packet and parse it; called from wtap_read(). */\nstatic bool netscreen_read(wtap *wth, wtap_rec *rec,\n    int *err, char **err_info, int64_t *data_offset)\n{\n\tint64_t\t\toffset;\n\tchar\t\tline[NETSCREEN_LINE_LENGTH];\n\n\t/* Find the next packet */\n\toffset = netscreen_seek_next_packet(wth, err, err_info, line);\n\tif (offset < 0)\n\t\treturn false;\n\n\t/* Parse the header and convert the ASCII hex dump to binary data */\n\tif (!parse_netscreen_packet(wth->fh, rec, line, err, err_info))\n\t\treturn false;\n\n\t/*\n\t * If the per-file encapsulation isn't known, set it to this\n\t * packet's encapsulation.\n\t *\n\t * If it *is* known, and it isn't this packet's encapsulation,\n\t * set it to WTAP_ENCAP_PER_PACKET, as this file doesn't\n\t * have a single encapsulation for all packets in the file.\n\t */\n\tif (wth->file_encap == WTAP_ENCAP_UNKNOWN)\n\t\twth->file_encap = rec->rec_header.packet_header.pkt_encap;\n\telse {\n\t\tif (wth->file_encap != rec->rec_header.packet_header.pkt_encap)\n\t\t\twth->file_encap = WTAP_ENCAP_PER_PACKET;\n\t}\n\n\t*data_offset = offset;\n\treturn true;\n}\n\n/* Used to read packets in random-access fashion */\nstatic bool\nnetscreen_seek_read(wtap *wth, int64_t seek_off, wtap_rec *rec,\n\tint *err, char **err_info)\n{\n\tchar\t\tline[NETSCREEN_LINE_LENGTH];\n\n\tif (file_seek(wth->random_fh, seek_off, SEEK_SET, err) == -1) {\n\t\treturn false;\n\t}\n\n\tif (file_gets(line, NETSCREEN_LINE_LENGTH, wth->random_fh) == NULL) {\n\t\t*err = file_error(wth->random_fh, err_info);\n\t\tif (*err == 0) {\n\t\t\t*err = WTAP_ERR_SHORT_READ;\n\t\t}\n\t\treturn false;\n\t}\n\n\treturn parse_netscreen_packet(wth->random_fh, rec, line,\n\t    err, err_info);\n}\n\n/* Parses a packet record header. There are a few possible formats:\n *\n * XXX list extra formats here!\n6843828.0: trust(o) len=98:00121ebbd132->00600868d659/0800\n              192.168.1.1 -> 192.168.1.10/6\n              vhl=45, tos=00, id=37739, frag=0000, ttl=64 tlen=84\n              tcp:ports 2222->2333, seq=3452113890, ack=1540618280, flag=5018/ACK\n              00 60 08 68 d6 59 00 12 1e bb d1 32 08 00 45 00     .`.h.Y.....2..E.\n              00 54 93 6b 00 00 40 06 63 dd c0 a8 01 01 c0 a8     .T.k..@.c.......\n              01 0a 08 ae 09 1d cd c3 13 e2 5b d3 f8 28 50 18     ..........[..(P.\n              1f d4 79 21 00 00 e7 76 89 64 16 e2 19 0a 80 09     ..y!...v.d......\n              31 e7 04 28 04 58 f3 d9 b1 9f 3d 65 1a db d8 61     1..(.X....=e...a\n              2c 21 b6 d3 20 60 0c 8c 35 98 88 cf 20 91 0e a9     ,!...`..5.......\n              1d 0b                                               ..\n\n * The first line of a packet is in the form\n\n<secs>.<dsecs>: <iface>({i,o}) len=<length>:<llinfo>>\n\n * where:\n *\n *   <secs> and <dsecs> are a time stamp in seconds and deciseconds,\n *     giving the time since the firewall was booted;\n *\n *   <iface> is the name of the interface on which the packet was\n *     received or on which it was transmitted;\n *\n *   {i,o} is i for a received packet and o for a transmitted packet;\n *\n *   <length> is the length of the packet on the network;\n *\n *   <llinfo>, at least for Ethernet, appears to be a source MAC\n *     address, folowed by \"->\", folowed by a destination MAC\n *     address, followed by a sequence of Ethertypes, each\n *     preceded by a \"/\" (multiple Ethertypes if there are VLAN\n *     tags and the like), possibly followed by \", tag <tag>\".\n *\n * Following that may be some \"info lines\", each of which is indented\n * by 14 spaces, giving a dissection of the payload after the\n * link-layer header.\n *\n * Following that is a hex/ASCII dump of the contents of the\n * packet, with 16 octets per line.\n */\nstatic bool\nparse_netscreen_packet(FILE_T fh, wtap_rec *rec, char *line,\n    int *err, char **err_info)\n{\n\tunsigned\t\tpkt_len;\n\tint\t\tsec;\n\tint\t\tdsec;\n\tchar\t\tcap_int[NETSCREEN_MAX_INT_NAME_LENGTH];\n\tchar\t\tdirection[2];\n\tchar\t\tcap_src[13];\n\tchar\t\tcap_dst[13];\n\tuint8_t\t\t*pd;\n\tchar\t\t*p;\n\tint\t\tn, i = 0;\n\tint\t\toffset = 0;\n\tchar\t\tdststr[13];\n\n\twtap_setup_packet_rec(rec, WTAP_ENCAP_UNKNOWN);\n\trec->block = wtap_block_create(WTAP_BLOCK_PACKET);\n\trec->presence_flags = WTAP_HAS_TS|WTAP_HAS_CAP_LEN;\n\t/* Suppress compiler warnings */\n\tmemset(cap_int, 0, sizeof(cap_int));\n\tmemset(cap_dst, 0, sizeof(cap_dst));\n\n\tif (sscanf(line, \"%9d.%9d: %15[a-z0-9/:.-](%1[io]) len=%9u:%12s->%12s/\",\n\t\t   &sec, &dsec, cap_int, direction, &pkt_len, cap_src, cap_dst) < 5) {\n\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t*err_info = g_strdup(\"netscreen: Can't parse packet-header\");\n\t\treturn -1;\n\t}\n\tif (pkt_len > WTAP_MAX_PACKET_SIZE_STANDARD) {\n\t\t/*\n\t\t * Probably a corrupt capture file; don't blow up trying\n\t\t * to allocate space for an immensely-large packet.\n\t\t */\n\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t*err_info = ws_strdup_printf(\"netscreen: File has %u-byte packet, bigger than maximum of %u\",\n\t\t    pkt_len, WTAP_MAX_PACKET_SIZE_STANDARD);\n\t\treturn false;\n\t}\n\n\t/*\n\t * If direction[0] is 'o', the direction is NETSCREEN_EGRESS,\n\t * otherwise it's NETSCREEN_INGRESS.\n\t */\n\n\trec->ts.secs  = sec;\n\trec->ts.nsecs = dsec * 100000000;\n\trec->rec_header.packet_header.len = pkt_len;\n\n\t/* Make sure we have enough room for the packet */\n\tws_buffer_assure_space(&rec->data, pkt_len);\n\tpd = ws_buffer_start_ptr(&rec->data);\n\n\twhile(1) {\n\n\t\t/* The last packet is not delimited by an empty line, but by EOF\n\t\t * So accept EOF as a valid delimiter too\n\t\t */\n\t\tif (file_gets(line, NETSCREEN_LINE_LENGTH, fh) == NULL) {\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Skip blanks.\n\t\t * The number of blanks is not fixed - for wireless\n\t\t * interfaces, there may be 14 extra spaces before\n\t\t * the hex data.\n\t\t */\n\t\tfor (p = &line[0]; g_ascii_isspace(*p); p++)\n\t\t\t;\n\t\t/* packets are delimited with empty lines */\n\t\tif (*p == '\\0') {\n\t\t\tbreak;\n\t\t}\n\n\t\tn = parse_single_hex_dump_line(p, pd, offset, pkt_len);\n\n\t\t/*\n\t\t * The smallest packet has a length of 6 bytes.\n\t\t * If the first line either gets an error when\n\t\t * parsed as hex data, or has fewer than 6\n\t\t * bytes of hex data, check whether it's an\n\t\t * info line by see if it has at least\n\t\t * NETSCREEN_SPACES_ON_INFO_LINE spaces at the\n\t\t * beginning.\n\t\t *\n\t\t * If it does, count this line and, if we have,\n\t\t * so far, skipped no more than NETSCREEN_MAX_INFOLINES\n\t\t * lines, skip this line.\n\t\t */\n\t\tif (offset == 0 && n < 6) {\n\t\t\tif (info_line(line)) {\n\t\t\t\t/* Info line */\n\t\t\t\tif (++i <= NETSCREEN_MAX_INFOLINES) {\n\t\t\t\t\t/* Skip this line */\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (n >= 0) {\n\t\t\t\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t\t\t\t*err_info = g_strdup(\"netscreen: first line of packet data has only %d hex bytes, < 6\");\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t/* Otherwise, fall through to report error */\n\t\t\t}\n\t\t}\n\n\t\t/* If there is no more data and the line was not empty,\n\t\t * then there must be an error in the file\n\t\t */\n\t\tif (n < 0) {\n\t\t\tswitch (n) {\n\n\t\t\tcase PARSE_LINE_INVALID_CHARACTER:\n\t\t\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t\t\t*err_info = g_strdup(\"netscreen: invalid character in hex data\");\n\t\t\t\tbreak;\n\n\t\t\tcase PARSE_LINE_NO_BYTES_SEEN:\n\t\t\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t\t\t*err_info = g_strdup(\"netscreen: no hex bytes seen in hex data\");\n\t\t\t\tbreak;\n\n\t\t\tcase PARSE_LINE_TOO_MANY_BYTES_SEEN:\n\t\t\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t\t\t*err_info = g_strdup(\"netscreen: number of hex bytes seen in hex data is greater than the packet length\");\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\t*err = WTAP_ERR_INTERNAL;\n\t\t\t\t*err_info = g_strdup_printf(\"netscreen: unknown error %d from parse_single_hex_dump_line()\", n);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\treturn false;\n\t\t}\n\n\t\t/* Adjust the offset to the data that was just added to the buffer */\n\t\toffset += n;\n\n\t}\n\n\t/*\n\t * Determine the encapsulation type, based on the\n\t * first 4 characters of the interface name\n\t *\n\t * XXX\tconvert this to a 'case' structure when adding more\n\t *\t(non-ethernet) interfacetypes\n\t */\n\tif (strncmp(cap_int, \"adsl\", 4) == 0) {\n\t\t/* The ADSL interface can be bridged with or without\n\t\t * PPP encapsulation. Check whether the first six bytes\n\t\t * of the hex data are the same as the destination mac\n\t\t * address in the header. If they are, assume ethernet\n\t\t * LinkLayer or else PPP\n\t\t */\n\t\tsnprintf(dststr, 13, \"%02x%02x%02x%02x%02x%02x\",\n\t\t   pd[0], pd[1], pd[2], pd[3], pd[4], pd[5]);\n\t\tif (strncmp(dststr, cap_dst, 12) == 0)\n\t\t\trec->rec_header.packet_header.pkt_encap = WTAP_ENCAP_ETHERNET;\n\t\telse\n\t\t\trec->rec_header.packet_header.pkt_encap = WTAP_ENCAP_PPP;\n\t\t}\n\telse if (strncmp(cap_int, \"seri\", 4) == 0)\n\t\trec->rec_header.packet_header.pkt_encap = WTAP_ENCAP_PPP;\n\telse\n\t\trec->rec_header.packet_header.pkt_encap = WTAP_ENCAP_ETHERNET;\n\n\trec->rec_header.packet_header.caplen = offset;\n\n\treturn true;\n}\n\n/* Take a string representing one line from a hex dump, with leading white\n * space removed, and converts the text to binary data. We place the bytes\n * in the buffer at the specified offset.\n *\n * Returns number of bytes successfully read, -1 if bad.  */\nstatic int\nparse_single_hex_dump_line(char* rec, uint8_t *buf, unsigned byte_offset, unsigned pkt_len)\n{\n\tint num_items_scanned;\n\tuint8_t character;\n\tuint8_t byte;\n\n\n\tfor (num_items_scanned = 0; num_items_scanned < 16; num_items_scanned++) {\n\t\tcharacter = *rec++;\n\t\tif (character >= '0' && character <= '9')\n\t\t\tbyte = character - '0' + 0;\n\t\telse if (character >= 'A' && character <= 'F')\n\t\t\tbyte = character - 'A' + 0xA;\n\t\telse if (character >= 'a' && character <= 'f')\n\t\t\tbyte = character - 'a' + 0xa;\n\t\telse if (character == ' ' || character == '\\r' || character == '\\n' || character == '\\0') {\n\t\t\t/* Nothing more to parse */\n\t\t\tbreak;\n\t\t} else\n\t\t\treturn PARSE_LINE_INVALID_CHARACTER; /* not a hex digit, space before ASCII dump, or EOL */\n\t\tbyte <<= 4;\n\t\tcharacter = *rec++ & 0xFF;\n\t\tif (character >= '0' && character <= '9')\n\t\t\tbyte += character - '0' + 0;\n\t\telse if (character >= 'A' && character <= 'F')\n\t\t\tbyte += character - 'A' + 0xA;\n\t\telse if (character >= 'a' && character <= 'f')\n\t\t\tbyte += character - 'a' + 0xa;\n\t\telse\n\t\t\treturn PARSE_LINE_INVALID_CHARACTER; /* not a hex digit */\n\n\t\t/* If there was more hex-data than was announced in the len=x\n\t\t * header, then there must be an error in the file; quit\n\t\t * now, as adding this byte will overflow the buffer.\n\t\t */\n\t\tif (byte_offset + num_items_scanned >= pkt_len) {\n\t\t\treturn PARSE_LINE_TOO_MANY_BYTES_SEEN;\n\t\t}\n\n\t\tbuf[byte_offset + num_items_scanned] = byte;\n\t\tcharacter = *rec++ & 0xFF;\n\t\tif (character == '\\0' || character == '\\r' || character == '\\n') {\n\t\t\t/* Nothing more to parse */\n\t\t\tbreak;\n\t\t} else if (character != ' ') {\n\t\t\t/* not space before ASCII dump */\n\t\t\treturn PARSE_LINE_INVALID_CHARACTER;\n\t\t}\n\t}\n\tif (num_items_scanned == 0)\n\t\treturn PARSE_LINE_NO_BYTES_SEEN;\n\n\treturn num_items_scanned;\n}\n\nstatic const struct supported_block_type netscreen_blocks_supported[] = {\n\t/*\n\t * We support packet blocks, with no comments or other options.\n\t */\n\t{ WTAP_BLOCK_PACKET, MULTIPLE_BLOCKS_SUPPORTED, NO_OPTIONS_SUPPORTED }\n};\n\nstatic const struct file_type_subtype_info netscreen_info = {\n\t\"NetScreen snoop text file\", \"netscreen\", \"txt\", NULL,\n\tfalse, BLOCKS_SUPPORTED(netscreen_blocks_supported),\n\tNULL, NULL, NULL\n};\n\nvoid register_netscreen(void)\n{\n\tnetscreen_file_type_subtype = wtap_register_file_type_subtype(&netscreen_info);\n\n\t/*\n\t * Register name for backwards compatibility with the\n\t * wtap_filetypes table in Lua.\n\t */\n\twtap_register_backwards_compatibility_lua_name(\"NETSCREEN\",\n\t    netscreen_file_type_subtype);\n}\n\n/*\n * Editor modelines  -  https://www.wireshark.org/tools/modelines.html\n *\n * Local variables:\n * c-basic-offset: 8\n * tab-width: 8\n * indent-tabs-mode: t\n * End:\n *\n * vi: set shiftwidth=8 tabstop=8 noexpandtab:\n * :indentSize=8:tabSize=8:noTabs=false:\n */\n", "patch": "@@ -263,28 +263,33 @@ static gboolean\n parse_netscreen_packet(FILE_T fh, struct wtap_pkthdr *phdr, Buffer* buf,\n     char *line, int *err, gchar **err_info)\n {\n+\tint\t\tpkt_len;\n \tint\t\tsec;\n \tint\t\tdsec;\n \tchar\t\tcap_int[NETSCREEN_MAX_INT_NAME_LENGTH];\n \tchar\t\tdirection[2];\n-\tguint\t\tpkt_len;\n \tchar\t\tcap_src[13];\n \tchar\t\tcap_dst[13];\n \tguint8\t\t*pd;\n \tgchar\t\t*p;\n \tint\t\tn, i = 0;\n-\tguint\t\toffset = 0;\n+\tint\t\toffset = 0;\n \tgchar\t\tdststr[13];\n \n \tphdr->rec_type = REC_TYPE_PACKET;\n \tphdr->presence_flags = WTAP_HAS_TS|WTAP_HAS_CAP_LEN;\n \n-\tif (sscanf(line, \"%9d.%9d: %15[a-z0-9/:.-](%1[io]) len=%9u:%12s->%12s/\",\n+\tif (sscanf(line, \"%9d.%9d: %15[a-z0-9/:.-](%1[io]) len=%9d:%12s->%12s/\",\n \t\t   &sec, &dsec, cap_int, direction, &pkt_len, cap_src, cap_dst) < 5) {\n \t\t*err = WTAP_ERR_BAD_FILE;\n \t\t*err_info = g_strdup(\"netscreen: Can't parse packet-header\");\n \t\treturn -1;\n \t}\n+\tif (pkt_len < 0) {\n+\t\t*err = WTAP_ERR_BAD_FILE;\n+\t\t*err_info = g_strdup(\"netscreen: packet header has a negative packet length\");\n+\t\treturn FALSE;\n+\t}\n \tif (pkt_len > WTAP_MAX_PACKET_SIZE) {\n \t\t/*\n \t\t * Probably a corrupt capture file; don't blow up trying", "file_path": "files/2016_8\\56", "file_language": "c", "file_name": "wiretap/netscreen.c", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}], "outdated": 0}
{"index": 19, "cve_id": "CVE-2016-5357", "cwe_id": ["CWE-20"], "cve_language": "C", "cve_description": "wiretap/netscreen.c in the NetScreen file parser in Wireshark 1.12.x before 1.12.12 and 2.x before 2.0.4 mishandles sscanf unsigned-integer processing, which allows remote attackers to cause a denial of service (application crash) via a crafted file.", "cvss": "5.9", "publish_date": "August 7, 2016", "AV": "NETWORK", "AC": "HIGH", "PR": "NONE", "UI": "NONE", "S": "UNCHANGED", "C": "NONE", "I": "NONE", "A": "HIGH", "commit_id": "6a140eca7b78b230f1f90a739a32257476513c78", "commit_message": "Fix packet length handling.\n\nTreat the packet length as unsigned - it shouldn't be negative in the\nfile.  If it is, that'll probably cause the sscanf to fail, so we'll\nreport the file as bad.\n\nCheck it against WTAP_MAX_PACKET_SIZE to make sure we don't try to\nallocate a huge amount of memory, just as we do in other file readers.\n\nUse the now-validated packet size as the length in\nws_buffer_assure_space(), so we are certain to have enough space, and\ndon't allocate too much space.\n\nMerge the header and packet data parsing routines while we're at it.\n\nBug: 12396\nChange-Id: I7f981f9cdcbea7ecdeb88bfff2f12d875de2244f\nReviewed-on: https://code.wireshark.org/review/15176\nReviewed-by: Guy Harris <guy@alum.mit.edu>", "commit_date": "2016-04-30T00:08:48Z", "project": "wireshark/wireshark", "url": "https://api.github.com/repos/wireshark/wireshark/commits/6a140eca7b78b230f1f90a739a32257476513c78", "html_url": "https://github.com/wireshark/wireshark/commit/6a140eca7b78b230f1f90a739a32257476513c78", "windows_before": "", "windows_after": "", "parents": [{"commit_id_before": "c245be94c514079d144340bf7847f23545d76e24", "url_before": "https://api.github.com/repos/wireshark/wireshark/commits/c245be94c514079d144340bf7847f23545d76e24", "html_url_before": "https://github.com/wireshark/wireshark/commit/c245be94c514079d144340bf7847f23545d76e24"}], "details": [{"raw_url": "https://github.com/wireshark/wireshark/raw/6a140eca7b78b230f1f90a739a32257476513c78/wiretap/netscreen.c", "code": "/* netscreen.c\n *\n * Juniper NetScreen snoop output parser\n * Created by re-using a lot of code from cosine.c\n * Copyright (c) 2007 by Sake Blok <sake@euronet.nl>\n *\n * Wiretap Library\n * Copyright (c) 1998 by Gilbert Ramirez <gram@alumni.rice.edu>\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version 2\n * of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */\n\n#include \"config.h\"\n#include \"wtap-int.h\"\n#include \"netscreen.h\"\n#include \"file_wrappers.h\"\n\n#include <stdlib.h>\n#include <string.h>\n\n/* XXX TODO:\n *\n * o  Construct a list of interfaces, with interface names, give\n *    them link-layer types based on the interface name and packet\n *    data, and supply interface IDs with each packet (i.e., make\n *    this supply a pcap-ng-style set of interfaces and associate\n *    packets with interfaces).  This is probably the right way\n *    to \"Pass the interface names and the traffic direction to either\n *    the frame-structure, a pseudo-header or use PPI.\"  See the\n *    message at\n *\n *        http://www.wireshark.org/lists/wireshark-dev/200708/msg00029.html\n *\n *    to see whether any further discussion is still needed. I suspect\n *    it doesn't; pcap-NG existed at the time, as per the final\n *    message in that thread:\n *\n *        http://www.wireshark.org/lists/wireshark-dev/200708/msg00039.html\n *\n *    but I don't think we fully *supported* it at that point.  Now\n *    that we do, we have the infrastructure to support this, except\n *    that we currently have no way to translate interface IDs to\n *    interface names in the \"frame\" dissector or to supply interface\n *    information as part of the packet metadata from Wiretap modules.\n *    That should be fixed so that we can show interface information,\n *    such as the interface name, in packet dissections from, for example,\n *    pcap-NG captures.\n */\n\nstatic gboolean info_line(const gchar *line);\nstatic gint64 netscreen_seek_next_packet(wtap *wth, int *err, gchar **err_info,\n\tchar *hdr);\nstatic gboolean netscreen_check_file_type(wtap *wth, int *err,\n\tgchar **err_info);\nstatic gboolean netscreen_read(wtap *wth, int *err, gchar **err_info,\n\tgint64 *data_offset);\nstatic gboolean netscreen_seek_read(wtap *wth, gint64 seek_off,\n\tstruct wtap_pkthdr *phdr, Buffer *buf,\n\tint *err, gchar **err_info);\nstatic gboolean parse_netscreen_packet(FILE_T fh, struct wtap_pkthdr *phdr,\n\tBuffer* buf, char *line, int *err, gchar **err_info);\nstatic int parse_single_hex_dump_line(char* rec, guint8 *buf,\n\tguint byte_offset);\n\n/* Returns TRUE if the line appears to be a line with protocol info.\n   Otherwise it returns FALSE. */\nstatic gboolean info_line(const gchar *line)\n{\n\tint i=NETSCREEN_SPACES_ON_INFO_LINE;\n\n\twhile (i-- > 0) {\n\t\tif (g_ascii_isspace(*line)) {\n\t\t\tline++;\n\t\t\tcontinue;\n\t\t} else {\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\treturn TRUE;\n}\n\n/* Seeks to the beginning of the next packet, and returns the\n   byte offset. Copy the header line to hdr. Returns -1 on failure,\n   and sets \"*err\" to the error and sets \"*err_info\" to null or an\n   additional error string. */\nstatic gint64 netscreen_seek_next_packet(wtap *wth, int *err, gchar **err_info,\n    char *hdr)\n{\n\tgint64 cur_off;\n\tchar buf[NETSCREEN_LINE_LENGTH];\n\n\twhile (1) {\n\t\tcur_off = file_tell(wth->fh);\n\t\tif (cur_off == -1) {\n\t\t\t/* Error */\n\t\t\t*err = file_error(wth->fh, err_info);\n\t\t\treturn -1;\n\t\t}\n\t\tif (file_gets(buf, sizeof(buf), wth->fh) == NULL) {\n\t\t\t/* EOF or error. */\n\t\t\t*err = file_error(wth->fh, err_info);\n\t\t\tbreak;\n\t\t}\n\t\tif (strstr(buf, NETSCREEN_REC_MAGIC_STR1) ||\n\t\t    strstr(buf, NETSCREEN_REC_MAGIC_STR2)) {\n\t\t\tg_strlcpy(hdr, buf, NETSCREEN_LINE_LENGTH);\n\t\t\treturn cur_off;\n\t\t}\n\t}\n\treturn -1;\n}\n\n/* Look through the first part of a file to see if this is\n * NetScreen snoop output.\n *\n * Returns TRUE if it is, FALSE if it isn't or if we get an I/O error;\n * if we get an I/O error, \"*err\" will be set to a non-zero value and\n * \"*err_info\" is set to null or an additional error string.\n */\nstatic gboolean netscreen_check_file_type(wtap *wth, int *err, gchar **err_info)\n{\n\tchar\tbuf[NETSCREEN_LINE_LENGTH];\n\tguint\treclen, line;\n\n\tbuf[NETSCREEN_LINE_LENGTH-1] = '\\0';\n\n\tfor (line = 0; line < NETSCREEN_HEADER_LINES_TO_CHECK; line++) {\n\t\tif (file_gets(buf, NETSCREEN_LINE_LENGTH, wth->fh) == NULL) {\n\t\t\t/* EOF or error. */\n\t\t\t*err = file_error(wth->fh, err_info);\n\t\t\treturn FALSE;\n\t\t}\n\n\t\treclen = (guint) strlen(buf);\n\t\tif (reclen < strlen(NETSCREEN_HDR_MAGIC_STR1) ||\n\t\t\treclen < strlen(NETSCREEN_HDR_MAGIC_STR2)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (strstr(buf, NETSCREEN_HDR_MAGIC_STR1) ||\n\t\t    strstr(buf, NETSCREEN_HDR_MAGIC_STR2)) {\n\t\t\treturn TRUE;\n\t\t}\n\t}\n\t*err = 0;\n\treturn FALSE;\n}\n\n\nwtap_open_return_val netscreen_open(wtap *wth, int *err, gchar **err_info)\n{\n\n\t/* Look for a NetScreen snoop header line */\n\tif (!netscreen_check_file_type(wth, err, err_info)) {\n\t\tif (*err != 0 && *err != WTAP_ERR_SHORT_READ)\n\t\t\treturn WTAP_OPEN_ERROR;\n\t\treturn WTAP_OPEN_NOT_MINE;\n\t}\n\n\tif (file_seek(wth->fh, 0L, SEEK_SET, err) == -1)\t/* rewind */\n\t\treturn WTAP_OPEN_ERROR;\n\n\twth->file_encap = WTAP_ENCAP_UNKNOWN;\n\twth->file_type_subtype = WTAP_FILE_TYPE_SUBTYPE_NETSCREEN;\n\twth->snapshot_length = 0; /* not known */\n\twth->subtype_read = netscreen_read;\n\twth->subtype_seek_read = netscreen_seek_read;\n\twth->file_tsprec = WTAP_TSPREC_DSEC;\n\n\treturn WTAP_OPEN_MINE;\n}\n\n/* Find the next packet and parse it; called from wtap_read(). */\nstatic gboolean netscreen_read(wtap *wth, int *err, gchar **err_info,\n    gint64 *data_offset)\n{\n\tgint64\t\toffset;\n\tchar\t\tline[NETSCREEN_LINE_LENGTH];\n\n\t/* Find the next packet */\n\toffset = netscreen_seek_next_packet(wth, err, err_info, line);\n\tif (offset < 0)\n\t\treturn FALSE;\n\n\t/* Parse the header and convert the ASCII hex dump to binary data */\n\tif (!parse_netscreen_packet(wth->fh, &wth->phdr,\n\t    wth->frame_buffer, line, err, err_info))\n\t\treturn FALSE;\n\n\t/*\n\t * If the per-file encapsulation isn't known, set it to this\n\t * packet's encapsulation.\n\t *\n\t * If it *is* known, and it isn't this packet's encapsulation,\n\t * set it to WTAP_ENCAP_PER_PACKET, as this file doesn't\n\t * have a single encapsulation for all packets in the file.\n\t */\n\tif (wth->file_encap == WTAP_ENCAP_UNKNOWN)\n\t\twth->file_encap = wth->phdr.pkt_encap;\n\telse {\n\t\tif (wth->file_encap != wth->phdr.pkt_encap)\n\t\t\twth->file_encap = WTAP_ENCAP_PER_PACKET;\n\t}\n\n\t*data_offset = offset;\n\treturn TRUE;\n}\n\n/* Used to read packets in random-access fashion */\nstatic gboolean\nnetscreen_seek_read(wtap *wth, gint64 seek_off,\n\tstruct wtap_pkthdr *phdr, Buffer *buf,\n\tint *err, gchar **err_info)\n{\n\tchar\t\tline[NETSCREEN_LINE_LENGTH];\n\n\tif (file_seek(wth->random_fh, seek_off, SEEK_SET, err) == -1) {\n\t\treturn FALSE;\n\t}\n\n\tif (file_gets(line, NETSCREEN_LINE_LENGTH, wth->random_fh) == NULL) {\n\t\t*err = file_error(wth->random_fh, err_info);\n\t\tif (*err == 0) {\n\t\t\t*err = WTAP_ERR_SHORT_READ;\n\t\t}\n\t\treturn FALSE;\n\t}\n\n\treturn parse_netscreen_packet(wth->random_fh, phdr, buf, line,\n\t    err, err_info);\n}\n\n/* Parses a packet record header. There are a few possible formats:\n *\n * XXX list extra formats here!\n6843828.0: trust(o) len=98:00121ebbd132->00600868d659/0800\n              192.168.1.1 -> 192.168.1.10/6\n              vhl=45, tos=00, id=37739, frag=0000, ttl=64 tlen=84\n              tcp:ports 2222->2333, seq=3452113890, ack=1540618280, flag=5018/ACK\n              00 60 08 68 d6 59 00 12 1e bb d1 32 08 00 45 00     .`.h.Y.....2..E.\n              00 54 93 6b 00 00 40 06 63 dd c0 a8 01 01 c0 a8     .T.k..@.c.......\n              01 0a 08 ae 09 1d cd c3 13 e2 5b d3 f8 28 50 18     ..........[..(P.\n              1f d4 79 21 00 00 e7 76 89 64 16 e2 19 0a 80 09     ..y!...v.d......\n              31 e7 04 28 04 58 f3 d9 b1 9f 3d 65 1a db d8 61     1..(.X....=e...a\n              2c 21 b6 d3 20 60 0c 8c 35 98 88 cf 20 91 0e a9     ,!...`..5.......\n              1d 0b                                               ..\n\n\n */\nstatic gboolean\nparse_netscreen_packet(FILE_T fh, struct wtap_pkthdr *phdr, Buffer* buf,\n    char *line, int *err, gchar **err_info)\n{\n\tint\t\tsec;\n\tint\t\tdsec;\n\tchar\t\tcap_int[NETSCREEN_MAX_INT_NAME_LENGTH];\n\tchar\t\tdirection[2];\n\tguint\t\tpkt_len;\n\tchar\t\tcap_src[13];\n\tchar\t\tcap_dst[13];\n\tguint8\t\t*pd;\n\tgchar\t\t*p;\n\tint\t\tn, i = 0;\n\tguint\t\toffset = 0;\n\tgchar\t\tdststr[13];\n\n\tphdr->rec_type = REC_TYPE_PACKET;\n\tphdr->presence_flags = WTAP_HAS_TS|WTAP_HAS_CAP_LEN;\n\n\tif (sscanf(line, \"%9d.%9d: %15[a-z0-9/:.-](%1[io]) len=%9u:%12s->%12s/\",\n\t\t   &sec, &dsec, cap_int, direction, &pkt_len, cap_src, cap_dst) < 5) {\n\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t*err_info = g_strdup(\"netscreen: Can't parse packet-header\");\n\t\treturn -1;\n\t}\n\tif (pkt_len > WTAP_MAX_PACKET_SIZE) {\n\t\t/*\n\t\t * Probably a corrupt capture file; don't blow up trying\n\t\t * to allocate space for an immensely-large packet.\n\t\t */\n\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t*err_info = g_strdup_printf(\"netscreen: File has %u-byte packet, bigger than maximum of %u\",\n\t\t    pkt_len, WTAP_MAX_PACKET_SIZE);\n\t\treturn FALSE;\n\t}\n\n\t/*\n\t * If direction[0] is 'o', the direction is NETSCREEN_EGRESS,\n\t * otherwise it's NETSCREEN_INGRESS.\n\t */\n\n\tphdr->ts.secs  = sec;\n\tphdr->ts.nsecs = dsec * 100000000;\n\tphdr->len = pkt_len;\n\n\t/* Make sure we have enough room for the packet */\n\tws_buffer_assure_space(buf, pkt_len);\n\tpd = ws_buffer_start_ptr(buf);\n\n\twhile(1) {\n\n\t\t/* The last packet is not delimited by an empty line, but by EOF\n\t\t * So accept EOF as a valid delimiter too\n\t\t */\n\t\tif (file_gets(line, NETSCREEN_LINE_LENGTH, fh) == NULL) {\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Skip blanks.\n\t\t * The number of blanks is not fixed - for wireless\n\t\t * interfaces, there may be 14 extra spaces before\n\t\t * the hex data.\n\t\t */\n\t\tfor (p = &line[0]; g_ascii_isspace(*p); p++)\n\t\t\t;\n\t\t/* packets are delimited with empty lines */\n\t\tif (*p == '\\0') {\n\t\t\tbreak;\n\t\t}\n\n\t\tn = parse_single_hex_dump_line(p, pd, offset);\n\n\t\t/* the smallest packet has a length of 6 bytes, if\n\t\t * the first hex-data is less then check whether\n\t\t * it is a info-line and act accordingly\n\t\t */\n\t\tif (offset == 0 && n < 6) {\n\t\t\tif (info_line(line)) {\n\t\t\t\tif (++i <= NETSCREEN_MAX_INFOLINES) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t\t\t*err_info = g_strdup(\"netscreen: cannot parse hex-data\");\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t}\n\n\t\t/* If there is no more data and the line was not empty,\n\t\t * then there must be an error in the file\n\t\t */\n\t\tif (n == -1) {\n\t\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t\t*err_info = g_strdup(\"netscreen: cannot parse hex-data\");\n\t\t\treturn FALSE;\n\t\t}\n\n\t\t/* Adjust the offset to the data that was just added to the buffer */\n\t\toffset += n;\n\n\t\t/* If there was more hex-data than was announced in the len=x\n\t\t * header, then then there must be an error in the file\n\t\t */\n\t\tif (offset > pkt_len) {\n\t\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t\t*err_info = g_strdup(\"netscreen: too much hex-data\");\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\t/*\n\t * Determine the encapsulation type, based on the\n\t * first 4 characters of the interface name\n\t *\n\t * XXX\tconvert this to a 'case' structure when adding more\n\t *\t(non-ethernet) interfacetypes\n\t */\n\tif (strncmp(cap_int, \"adsl\", 4) == 0) {\n\t\t/* The ADSL interface can be bridged with or without\n\t\t * PPP encapsulation. Check whether the first six bytes\n\t\t * of the hex data are the same as the destination mac\n\t\t * address in the header. If they are, assume ethernet\n\t\t * LinkLayer or else PPP\n\t\t */\n\t\tg_snprintf(dststr, 13, \"%02x%02x%02x%02x%02x%02x\",\n\t\t   pd[0], pd[1], pd[2], pd[3], pd[4], pd[5]);\n\t\tif (strncmp(dststr, cap_dst, 12) == 0)\n\t\t\tphdr->pkt_encap = WTAP_ENCAP_ETHERNET;\n\t\telse\n\t\t\tphdr->pkt_encap = WTAP_ENCAP_PPP;\n\t\t}\n\telse if (strncmp(cap_int, \"seri\", 4) == 0)\n\t\tphdr->pkt_encap = WTAP_ENCAP_PPP;\n\telse\n\t\tphdr->pkt_encap = WTAP_ENCAP_ETHERNET;\n\n\tphdr->caplen = offset;\n\n\treturn TRUE;\n}\n\n/* Take a string representing one line from a hex dump, with leading white\n * space removed, and converts the text to binary data. We place the bytes\n * in the buffer at the specified offset.\n *\n * Returns number of bytes successfully read, -1 if bad.  */\nstatic int\nparse_single_hex_dump_line(char* rec, guint8 *buf, guint byte_offset)\n{\n\tint num_items_scanned;\n\tguint8 character;\n\tguint8 byte;\n\n\n\tfor (num_items_scanned = 0; num_items_scanned < 16; num_items_scanned++) {\n\t\tcharacter = *rec++;\n\t\tif (character >= '0' && character <= '9')\n\t\t\tbyte = character - '0' + 0;\n\t\telse if (character >= 'A' && character <= 'F')\n\t\t\tbyte = character - 'A' + 0xA;\n\t\telse if (character >= 'a' && character <= 'f')\n\t\t\tbyte = character - 'a' + 0xa;\n\t\telse if (character == ' ' || character == '\\r' || character == '\\n' || character == '\\0') {\n\t\t\t/* Nothing more to parse */\n\t\t\tbreak;\n\t\t} else\n\t\t\treturn -1; /* not a hex digit, space before ASCII dump, or EOL */\n\t\tbyte <<= 4;\n\t\tcharacter = *rec++ & 0xFF;\n\t\tif (character >= '0' && character <= '9')\n\t\t\tbyte += character - '0' + 0;\n\t\telse if (character >= 'A' && character <= 'F')\n\t\t\tbyte += character - 'A' + 0xA;\n\t\telse if (character >= 'a' && character <= 'f')\n\t\t\tbyte += character - 'a' + 0xa;\n\t\telse\n\t\t\treturn -1; /* not a hex digit */\n\t\tbuf[byte_offset + num_items_scanned] = byte;\n\t\tcharacter = *rec++ & 0xFF;\n\t\tif (character == '\\0' || character == '\\r' || character == '\\n') {\n\t\t\t/* Nothing more to parse */\n\t\t\tbreak;\n\t\t} else if (character != ' ') {\n\t\t\t/* not space before ASCII dump */\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (num_items_scanned == 0)\n\t\treturn -1;\n\n\treturn num_items_scanned;\n}\n\n/*\n * Editor modelines  -  http://www.wireshark.org/tools/modelines.html\n *\n * Local variables:\n * c-basic-offset: 8\n * tab-width: 8\n * indent-tabs-mode: t\n * End:\n *\n * vi: set shiftwidth=8 tabstop=8 noexpandtab:\n * :indentSize=8:tabSize=8:noTabs=false:\n */\n", "code_before": "/* netscreen.c\n *\n * Juniper NetScreen snoop output parser\n * Created by re-using a lot of code from cosine.c\n * Copyright (c) 2007 by Sake Blok <sake@euronet.nl>\n *\n * Wiretap Library\n * Copyright (c) 1998 by Gilbert Ramirez <gram@alumni.rice.edu>\n *\n * SPDX-License-Identifier: GPL-2.0-or-later\n */\n\n#include \"config.h\"\n#include \"netscreen.h\"\n#include \"wtap-int.h\"\n#include \"file_wrappers.h\"\n\n#include <stdlib.h>\n#include <string.h>\n\n/* XXX TODO:\n *\n * o  Construct a list of interfaces, with interface names, give\n *    them link-layer types based on the interface name and packet\n *    data, and supply interface IDs with each packet (i.e., make\n *    this supply a pcapng-style set of interfaces and associate\n *    packets with interfaces).  This is probably the right way\n *    to \"Pass the interface names and the traffic direction to either\n *    the frame-structure, a pseudo-header or use PPI.\"  See the\n *    message at\n *\n *        https://lists.wireshark.org/archives/wireshark-dev/200708/msg00029.html\n *\n *    to see whether any further discussion is still needed. I suspect\n *    it doesn't; pcapng existed at the time, as per the final\n *    message in that thread:\n *\n *        https://lists.wireshark.org/archives/wireshark-dev/200708/msg00039.html\n *\n *    but I don't think we fully *supported* it at that point.  Now\n *    that we do, we have the infrastructure to support this, except\n *    that we currently have no way to translate interface IDs to\n *    interface names in the \"frame\" dissector or to supply interface\n *    information as part of the packet metadata from Wiretap modules.\n *    That should be fixed so that we can show interface information,\n *    such as the interface name, in packet dissections from, for example,\n *    pcapng captures.\n */\n\nstatic bool info_line(const char *line);\nstatic int64_t netscreen_seek_next_packet(wtap *wth, int *err, char **err_info,\n\tchar *hdr);\nstatic bool netscreen_check_file_type(wtap *wth, int *err,\n\tchar **err_info);\nstatic bool netscreen_read(wtap *wth, wtap_rec *rec,\n\tint *err, char **err_info, int64_t *data_offset);\nstatic bool netscreen_seek_read(wtap *wth, int64_t seek_off,\n\twtap_rec *rec, int *err, char **err_info);\nstatic bool parse_netscreen_packet(FILE_T fh, wtap_rec *rec,\n\tchar *line, int *err, char **err_info);\nstatic int parse_single_hex_dump_line(char* rec, uint8_t *buf,\n\tunsigned byte_offset, unsigned pkt_len);\n\n/* Error returns from parse_single_hex_dump_line() */\n#define PARSE_LINE_INVALID_CHARACTER\t-1\n#define PARSE_LINE_NO_BYTES_SEEN\t-2\n#define PARSE_LINE_TOO_MANY_BYTES_SEEN\t-3\n\nstatic int netscreen_file_type_subtype = -1;\n\nvoid register_netscreen(void);\n\n/* Returns true if the line appears to be a line with protocol info.\n   Otherwise it returns false. */\nstatic bool info_line(const char *line)\n{\n\tint i=NETSCREEN_SPACES_ON_INFO_LINE;\n\n\twhile (i-- > 0) {\n\t\tif (g_ascii_isspace(*line)) {\n\t\t\tline++;\n\t\t\tcontinue;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\n/* Seeks to the beginning of the next packet, and returns the\n   byte offset. Copy the header line to hdr. Returns -1 on failure,\n   and sets \"*err\" to the error and sets \"*err_info\" to null or an\n   additional error string. */\nstatic int64_t netscreen_seek_next_packet(wtap *wth, int *err, char **err_info,\n    char *hdr)\n{\n\tint64_t cur_off;\n\tchar buf[NETSCREEN_LINE_LENGTH];\n\n\twhile (1) {\n\t\tcur_off = file_tell(wth->fh);\n\t\tif (cur_off == -1) {\n\t\t\t/* Error */\n\t\t\t*err = file_error(wth->fh, err_info);\n\t\t\treturn -1;\n\t\t}\n\t\tif (file_gets(buf, sizeof(buf), wth->fh) == NULL) {\n\t\t\t/* EOF or error. */\n\t\t\t*err = file_error(wth->fh, err_info);\n\t\t\tbreak;\n\t\t}\n\t\tif (strstr(buf, NETSCREEN_REC_MAGIC_STR1) ||\n\t\t    strstr(buf, NETSCREEN_REC_MAGIC_STR2)) {\n\t\t\t(void) g_strlcpy(hdr, buf, NETSCREEN_LINE_LENGTH);\n\t\t\treturn cur_off;\n\t\t}\n\t}\n\treturn -1;\n}\n\n/* Look through the first part of a file to see if this is\n * NetScreen snoop output.\n *\n * Returns true if it is, false if it isn't or if we get an I/O error;\n * if we get an I/O error, \"*err\" will be set to a non-zero value and\n * \"*err_info\" is set to null or an additional error string.\n */\nstatic bool netscreen_check_file_type(wtap *wth, int *err, char **err_info)\n{\n\tchar\tbuf[NETSCREEN_LINE_LENGTH];\n\tunsigned\treclen, line;\n\n\tbuf[NETSCREEN_LINE_LENGTH-1] = '\\0';\n\n\tfor (line = 0; line < NETSCREEN_HEADER_LINES_TO_CHECK; line++) {\n\t\tif (file_gets(buf, NETSCREEN_LINE_LENGTH, wth->fh) == NULL) {\n\t\t\t/* EOF or error. */\n\t\t\t*err = file_error(wth->fh, err_info);\n\t\t\treturn false;\n\t\t}\n\n\t\treclen = (unsigned) strlen(buf);\n\t\tif (reclen < MIN(strlen(NETSCREEN_HDR_MAGIC_STR1), strlen(NETSCREEN_HDR_MAGIC_STR2))) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (strstr(buf, NETSCREEN_HDR_MAGIC_STR1) ||\n\t\t    strstr(buf, NETSCREEN_HDR_MAGIC_STR2)) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t*err = 0;\n\treturn false;\n}\n\n\nwtap_open_return_val netscreen_open(wtap *wth, int *err, char **err_info)\n{\n\n\t/* Look for a NetScreen snoop header line */\n\tif (!netscreen_check_file_type(wth, err, err_info)) {\n\t\tif (*err != 0 && *err != WTAP_ERR_SHORT_READ)\n\t\t\treturn WTAP_OPEN_ERROR;\n\t\treturn WTAP_OPEN_NOT_MINE;\n\t}\n\n\tif (file_seek(wth->fh, 0L, SEEK_SET, err) == -1)\t/* rewind */\n\t\treturn WTAP_OPEN_ERROR;\n\n\twth->file_encap = WTAP_ENCAP_UNKNOWN;\n\twth->file_type_subtype = netscreen_file_type_subtype;\n\twth->snapshot_length = 0; /* not known */\n\twth->subtype_read = netscreen_read;\n\twth->subtype_seek_read = netscreen_seek_read;\n\twth->file_tsprec = WTAP_TSPREC_100_MSEC;\n\n\treturn WTAP_OPEN_MINE;\n}\n\n/* Find the next packet and parse it; called from wtap_read(). */\nstatic bool netscreen_read(wtap *wth, wtap_rec *rec,\n    int *err, char **err_info, int64_t *data_offset)\n{\n\tint64_t\t\toffset;\n\tchar\t\tline[NETSCREEN_LINE_LENGTH];\n\n\t/* Find the next packet */\n\toffset = netscreen_seek_next_packet(wth, err, err_info, line);\n\tif (offset < 0)\n\t\treturn false;\n\n\t/* Parse the header and convert the ASCII hex dump to binary data */\n\tif (!parse_netscreen_packet(wth->fh, rec, line, err, err_info))\n\t\treturn false;\n\n\t/*\n\t * If the per-file encapsulation isn't known, set it to this\n\t * packet's encapsulation.\n\t *\n\t * If it *is* known, and it isn't this packet's encapsulation,\n\t * set it to WTAP_ENCAP_PER_PACKET, as this file doesn't\n\t * have a single encapsulation for all packets in the file.\n\t */\n\tif (wth->file_encap == WTAP_ENCAP_UNKNOWN)\n\t\twth->file_encap = rec->rec_header.packet_header.pkt_encap;\n\telse {\n\t\tif (wth->file_encap != rec->rec_header.packet_header.pkt_encap)\n\t\t\twth->file_encap = WTAP_ENCAP_PER_PACKET;\n\t}\n\n\t*data_offset = offset;\n\treturn true;\n}\n\n/* Used to read packets in random-access fashion */\nstatic bool\nnetscreen_seek_read(wtap *wth, int64_t seek_off, wtap_rec *rec,\n\tint *err, char **err_info)\n{\n\tchar\t\tline[NETSCREEN_LINE_LENGTH];\n\n\tif (file_seek(wth->random_fh, seek_off, SEEK_SET, err) == -1) {\n\t\treturn false;\n\t}\n\n\tif (file_gets(line, NETSCREEN_LINE_LENGTH, wth->random_fh) == NULL) {\n\t\t*err = file_error(wth->random_fh, err_info);\n\t\tif (*err == 0) {\n\t\t\t*err = WTAP_ERR_SHORT_READ;\n\t\t}\n\t\treturn false;\n\t}\n\n\treturn parse_netscreen_packet(wth->random_fh, rec, line,\n\t    err, err_info);\n}\n\n/* Parses a packet record header. There are a few possible formats:\n *\n * XXX list extra formats here!\n6843828.0: trust(o) len=98:00121ebbd132->00600868d659/0800\n              192.168.1.1 -> 192.168.1.10/6\n              vhl=45, tos=00, id=37739, frag=0000, ttl=64 tlen=84\n              tcp:ports 2222->2333, seq=3452113890, ack=1540618280, flag=5018/ACK\n              00 60 08 68 d6 59 00 12 1e bb d1 32 08 00 45 00     .`.h.Y.....2..E.\n              00 54 93 6b 00 00 40 06 63 dd c0 a8 01 01 c0 a8     .T.k..@.c.......\n              01 0a 08 ae 09 1d cd c3 13 e2 5b d3 f8 28 50 18     ..........[..(P.\n              1f d4 79 21 00 00 e7 76 89 64 16 e2 19 0a 80 09     ..y!...v.d......\n              31 e7 04 28 04 58 f3 d9 b1 9f 3d 65 1a db d8 61     1..(.X....=e...a\n              2c 21 b6 d3 20 60 0c 8c 35 98 88 cf 20 91 0e a9     ,!...`..5.......\n              1d 0b                                               ..\n\n * The first line of a packet is in the form\n\n<secs>.<dsecs>: <iface>({i,o}) len=<length>:<llinfo>>\n\n * where:\n *\n *   <secs> and <dsecs> are a time stamp in seconds and deciseconds,\n *     giving the time since the firewall was booted;\n *\n *   <iface> is the name of the interface on which the packet was\n *     received or on which it was transmitted;\n *\n *   {i,o} is i for a received packet and o for a transmitted packet;\n *\n *   <length> is the length of the packet on the network;\n *\n *   <llinfo>, at least for Ethernet, appears to be a source MAC\n *     address, folowed by \"->\", folowed by a destination MAC\n *     address, followed by a sequence of Ethertypes, each\n *     preceded by a \"/\" (multiple Ethertypes if there are VLAN\n *     tags and the like), possibly followed by \", tag <tag>\".\n *\n * Following that may be some \"info lines\", each of which is indented\n * by 14 spaces, giving a dissection of the payload after the\n * link-layer header.\n *\n * Following that is a hex/ASCII dump of the contents of the\n * packet, with 16 octets per line.\n */\nstatic bool\nparse_netscreen_packet(FILE_T fh, wtap_rec *rec, char *line,\n    int *err, char **err_info)\n{\n\tunsigned\t\tpkt_len;\n\tint\t\tsec;\n\tint\t\tdsec;\n\tchar\t\tcap_int[NETSCREEN_MAX_INT_NAME_LENGTH];\n\tchar\t\tdirection[2];\n\tchar\t\tcap_src[13];\n\tchar\t\tcap_dst[13];\n\tuint8_t\t\t*pd;\n\tchar\t\t*p;\n\tint\t\tn, i = 0;\n\tint\t\toffset = 0;\n\tchar\t\tdststr[13];\n\n\twtap_setup_packet_rec(rec, WTAP_ENCAP_UNKNOWN);\n\trec->block = wtap_block_create(WTAP_BLOCK_PACKET);\n\trec->presence_flags = WTAP_HAS_TS|WTAP_HAS_CAP_LEN;\n\t/* Suppress compiler warnings */\n\tmemset(cap_int, 0, sizeof(cap_int));\n\tmemset(cap_dst, 0, sizeof(cap_dst));\n\n\tif (sscanf(line, \"%9d.%9d: %15[a-z0-9/:.-](%1[io]) len=%9u:%12s->%12s/\",\n\t\t   &sec, &dsec, cap_int, direction, &pkt_len, cap_src, cap_dst) < 5) {\n\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t*err_info = g_strdup(\"netscreen: Can't parse packet-header\");\n\t\treturn -1;\n\t}\n\tif (pkt_len > WTAP_MAX_PACKET_SIZE_STANDARD) {\n\t\t/*\n\t\t * Probably a corrupt capture file; don't blow up trying\n\t\t * to allocate space for an immensely-large packet.\n\t\t */\n\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t*err_info = ws_strdup_printf(\"netscreen: File has %u-byte packet, bigger than maximum of %u\",\n\t\t    pkt_len, WTAP_MAX_PACKET_SIZE_STANDARD);\n\t\treturn false;\n\t}\n\n\t/*\n\t * If direction[0] is 'o', the direction is NETSCREEN_EGRESS,\n\t * otherwise it's NETSCREEN_INGRESS.\n\t */\n\n\trec->ts.secs  = sec;\n\trec->ts.nsecs = dsec * 100000000;\n\trec->rec_header.packet_header.len = pkt_len;\n\n\t/* Make sure we have enough room for the packet */\n\tws_buffer_assure_space(&rec->data, pkt_len);\n\tpd = ws_buffer_start_ptr(&rec->data);\n\n\twhile(1) {\n\n\t\t/* The last packet is not delimited by an empty line, but by EOF\n\t\t * So accept EOF as a valid delimiter too\n\t\t */\n\t\tif (file_gets(line, NETSCREEN_LINE_LENGTH, fh) == NULL) {\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Skip blanks.\n\t\t * The number of blanks is not fixed - for wireless\n\t\t * interfaces, there may be 14 extra spaces before\n\t\t * the hex data.\n\t\t */\n\t\tfor (p = &line[0]; g_ascii_isspace(*p); p++)\n\t\t\t;\n\t\t/* packets are delimited with empty lines */\n\t\tif (*p == '\\0') {\n\t\t\tbreak;\n\t\t}\n\n\t\tn = parse_single_hex_dump_line(p, pd, offset, pkt_len);\n\n\t\t/*\n\t\t * The smallest packet has a length of 6 bytes.\n\t\t * If the first line either gets an error when\n\t\t * parsed as hex data, or has fewer than 6\n\t\t * bytes of hex data, check whether it's an\n\t\t * info line by see if it has at least\n\t\t * NETSCREEN_SPACES_ON_INFO_LINE spaces at the\n\t\t * beginning.\n\t\t *\n\t\t * If it does, count this line and, if we have,\n\t\t * so far, skipped no more than NETSCREEN_MAX_INFOLINES\n\t\t * lines, skip this line.\n\t\t */\n\t\tif (offset == 0 && n < 6) {\n\t\t\tif (info_line(line)) {\n\t\t\t\t/* Info line */\n\t\t\t\tif (++i <= NETSCREEN_MAX_INFOLINES) {\n\t\t\t\t\t/* Skip this line */\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (n >= 0) {\n\t\t\t\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t\t\t\t*err_info = g_strdup(\"netscreen: first line of packet data has only %d hex bytes, < 6\");\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t/* Otherwise, fall through to report error */\n\t\t\t}\n\t\t}\n\n\t\t/* If there is no more data and the line was not empty,\n\t\t * then there must be an error in the file\n\t\t */\n\t\tif (n < 0) {\n\t\t\tswitch (n) {\n\n\t\t\tcase PARSE_LINE_INVALID_CHARACTER:\n\t\t\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t\t\t*err_info = g_strdup(\"netscreen: invalid character in hex data\");\n\t\t\t\tbreak;\n\n\t\t\tcase PARSE_LINE_NO_BYTES_SEEN:\n\t\t\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t\t\t*err_info = g_strdup(\"netscreen: no hex bytes seen in hex data\");\n\t\t\t\tbreak;\n\n\t\t\tcase PARSE_LINE_TOO_MANY_BYTES_SEEN:\n\t\t\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t\t\t*err_info = g_strdup(\"netscreen: number of hex bytes seen in hex data is greater than the packet length\");\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\t*err = WTAP_ERR_INTERNAL;\n\t\t\t\t*err_info = g_strdup_printf(\"netscreen: unknown error %d from parse_single_hex_dump_line()\", n);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\treturn false;\n\t\t}\n\n\t\t/* Adjust the offset to the data that was just added to the buffer */\n\t\toffset += n;\n\n\t}\n\n\t/*\n\t * Determine the encapsulation type, based on the\n\t * first 4 characters of the interface name\n\t *\n\t * XXX\tconvert this to a 'case' structure when adding more\n\t *\t(non-ethernet) interfacetypes\n\t */\n\tif (strncmp(cap_int, \"adsl\", 4) == 0) {\n\t\t/* The ADSL interface can be bridged with or without\n\t\t * PPP encapsulation. Check whether the first six bytes\n\t\t * of the hex data are the same as the destination mac\n\t\t * address in the header. If they are, assume ethernet\n\t\t * LinkLayer or else PPP\n\t\t */\n\t\tsnprintf(dststr, 13, \"%02x%02x%02x%02x%02x%02x\",\n\t\t   pd[0], pd[1], pd[2], pd[3], pd[4], pd[5]);\n\t\tif (strncmp(dststr, cap_dst, 12) == 0)\n\t\t\trec->rec_header.packet_header.pkt_encap = WTAP_ENCAP_ETHERNET;\n\t\telse\n\t\t\trec->rec_header.packet_header.pkt_encap = WTAP_ENCAP_PPP;\n\t\t}\n\telse if (strncmp(cap_int, \"seri\", 4) == 0)\n\t\trec->rec_header.packet_header.pkt_encap = WTAP_ENCAP_PPP;\n\telse\n\t\trec->rec_header.packet_header.pkt_encap = WTAP_ENCAP_ETHERNET;\n\n\trec->rec_header.packet_header.caplen = offset;\n\n\treturn true;\n}\n\n/* Take a string representing one line from a hex dump, with leading white\n * space removed, and converts the text to binary data. We place the bytes\n * in the buffer at the specified offset.\n *\n * Returns number of bytes successfully read, -1 if bad.  */\nstatic int\nparse_single_hex_dump_line(char* rec, uint8_t *buf, unsigned byte_offset, unsigned pkt_len)\n{\n\tint num_items_scanned;\n\tuint8_t character;\n\tuint8_t byte;\n\n\n\tfor (num_items_scanned = 0; num_items_scanned < 16; num_items_scanned++) {\n\t\tcharacter = *rec++;\n\t\tif (character >= '0' && character <= '9')\n\t\t\tbyte = character - '0' + 0;\n\t\telse if (character >= 'A' && character <= 'F')\n\t\t\tbyte = character - 'A' + 0xA;\n\t\telse if (character >= 'a' && character <= 'f')\n\t\t\tbyte = character - 'a' + 0xa;\n\t\telse if (character == ' ' || character == '\\r' || character == '\\n' || character == '\\0') {\n\t\t\t/* Nothing more to parse */\n\t\t\tbreak;\n\t\t} else\n\t\t\treturn PARSE_LINE_INVALID_CHARACTER; /* not a hex digit, space before ASCII dump, or EOL */\n\t\tbyte <<= 4;\n\t\tcharacter = *rec++ & 0xFF;\n\t\tif (character >= '0' && character <= '9')\n\t\t\tbyte += character - '0' + 0;\n\t\telse if (character >= 'A' && character <= 'F')\n\t\t\tbyte += character - 'A' + 0xA;\n\t\telse if (character >= 'a' && character <= 'f')\n\t\t\tbyte += character - 'a' + 0xa;\n\t\telse\n\t\t\treturn PARSE_LINE_INVALID_CHARACTER; /* not a hex digit */\n\n\t\t/* If there was more hex-data than was announced in the len=x\n\t\t * header, then there must be an error in the file; quit\n\t\t * now, as adding this byte will overflow the buffer.\n\t\t */\n\t\tif (byte_offset + num_items_scanned >= pkt_len) {\n\t\t\treturn PARSE_LINE_TOO_MANY_BYTES_SEEN;\n\t\t}\n\n\t\tbuf[byte_offset + num_items_scanned] = byte;\n\t\tcharacter = *rec++ & 0xFF;\n\t\tif (character == '\\0' || character == '\\r' || character == '\\n') {\n\t\t\t/* Nothing more to parse */\n\t\t\tbreak;\n\t\t} else if (character != ' ') {\n\t\t\t/* not space before ASCII dump */\n\t\t\treturn PARSE_LINE_INVALID_CHARACTER;\n\t\t}\n\t}\n\tif (num_items_scanned == 0)\n\t\treturn PARSE_LINE_NO_BYTES_SEEN;\n\n\treturn num_items_scanned;\n}\n\nstatic const struct supported_block_type netscreen_blocks_supported[] = {\n\t/*\n\t * We support packet blocks, with no comments or other options.\n\t */\n\t{ WTAP_BLOCK_PACKET, MULTIPLE_BLOCKS_SUPPORTED, NO_OPTIONS_SUPPORTED }\n};\n\nstatic const struct file_type_subtype_info netscreen_info = {\n\t\"NetScreen snoop text file\", \"netscreen\", \"txt\", NULL,\n\tfalse, BLOCKS_SUPPORTED(netscreen_blocks_supported),\n\tNULL, NULL, NULL\n};\n\nvoid register_netscreen(void)\n{\n\tnetscreen_file_type_subtype = wtap_register_file_type_subtype(&netscreen_info);\n\n\t/*\n\t * Register name for backwards compatibility with the\n\t * wtap_filetypes table in Lua.\n\t */\n\twtap_register_backwards_compatibility_lua_name(\"NETSCREEN\",\n\t    netscreen_file_type_subtype);\n}\n\n/*\n * Editor modelines  -  https://www.wireshark.org/tools/modelines.html\n *\n * Local variables:\n * c-basic-offset: 8\n * tab-width: 8\n * indent-tabs-mode: t\n * End:\n *\n * vi: set shiftwidth=8 tabstop=8 noexpandtab:\n * :indentSize=8:tabSize=8:noTabs=false:\n */\n", "patch": "@@ -69,12 +69,8 @@ static gboolean netscreen_read(wtap *wth, int *err, gchar **err_info,\n static gboolean netscreen_seek_read(wtap *wth, gint64 seek_off,\n \tstruct wtap_pkthdr *phdr, Buffer *buf,\n \tint *err, gchar **err_info);\n-static int parse_netscreen_rec_hdr(struct wtap_pkthdr *phdr, const char *line,\n-\tchar *cap_int, gboolean *cap_dir, char *cap_dst,\n-\tint *err, gchar **err_info);\n-static gboolean parse_netscreen_hex_dump(FILE_T fh, int pkt_len,\n-\tconst char *cap_int, const char *cap_dst, struct wtap_pkthdr *phdr,\n-\tBuffer* buf, int *err, gchar **err_info);\n+static gboolean parse_netscreen_packet(FILE_T fh, struct wtap_pkthdr *phdr,\n+\tBuffer* buf, char *line, int *err, gchar **err_info);\n static int parse_single_hex_dump_line(char* rec, guint8 *buf,\n \tguint byte_offset);\n \n@@ -191,27 +187,16 @@ static gboolean netscreen_read(wtap *wth, int *err, gchar **err_info,\n     gint64 *data_offset)\n {\n \tgint64\t\toffset;\n-\tint\t\tpkt_len;\n \tchar\t\tline[NETSCREEN_LINE_LENGTH];\n-\tchar\t\tcap_int[NETSCREEN_MAX_INT_NAME_LENGTH];\n-\tgboolean\tcap_dir;\n-\tchar\t\tcap_dst[13];\n \n \t/* Find the next packet */\n \toffset = netscreen_seek_next_packet(wth, err, err_info, line);\n \tif (offset < 0)\n \t\treturn FALSE;\n \n-\t/* Parse the header */\n-\tpkt_len = parse_netscreen_rec_hdr(&wth->phdr, line, cap_int, &cap_dir,\n-\t    cap_dst, err, err_info);\n-\tif (pkt_len == -1)\n-\t\treturn FALSE;\n-\n-\t/* Convert the ASCII hex dump to binary data, and fill in some\n-\t   struct wtap_pkthdr fields */\n-\tif (!parse_netscreen_hex_dump(wth->fh, pkt_len, cap_int,\n-\t    cap_dst, &wth->phdr, wth->frame_buffer, err, err_info))\n+\t/* Parse the header and convert the ASCII hex dump to binary data */\n+\tif (!parse_netscreen_packet(wth->fh, &wth->phdr,\n+\t    wth->frame_buffer, line, err, err_info))\n \t\treturn FALSE;\n \n \t/*\n@@ -239,11 +224,7 @@ netscreen_seek_read(wtap *wth, gint64 seek_off,\n \tstruct wtap_pkthdr *phdr, Buffer *buf,\n \tint *err, gchar **err_info)\n {\n-\tint\t\tpkt_len;\n \tchar\t\tline[NETSCREEN_LINE_LENGTH];\n-\tchar\t\tcap_int[NETSCREEN_MAX_INT_NAME_LENGTH];\n-\tgboolean\tcap_dir;\n-\tchar\t\tcap_dst[13];\n \n \tif (file_seek(wth->random_fh, seek_off, SEEK_SET, err) == -1) {\n \t\treturn FALSE;\n@@ -257,15 +238,8 @@ netscreen_seek_read(wtap *wth, gint64 seek_off,\n \t\treturn FALSE;\n \t}\n \n-\tpkt_len = parse_netscreen_rec_hdr(phdr, line, cap_int, &cap_dir,\n-\t    cap_dst, err, err_info);\n-\tif (pkt_len == -1)\n-\t\treturn FALSE;\n-\n-\tif (!parse_netscreen_hex_dump(wth->random_fh, pkt_len, cap_int,\n-\t    cap_dst, phdr, buf, err, err_info))\n-\t\treturn FALSE;\n-\treturn TRUE;\n+\treturn parse_netscreen_packet(wth->random_fh, phdr, buf, line,\n+\t    err, err_info);\n }\n \n /* Parses a packet record header. There are a few possible formats:\n@@ -285,49 +259,54 @@ netscreen_seek_read(wtap *wth, gint64 seek_off,\n \n \n  */\n-static int\n-parse_netscreen_rec_hdr(struct wtap_pkthdr *phdr, const char *line, char *cap_int,\n-    gboolean *cap_dir, char *cap_dst, int *err, gchar **err_info)\n+static gboolean\n+parse_netscreen_packet(FILE_T fh, struct wtap_pkthdr *phdr, Buffer* buf,\n+    char *line, int *err, gchar **err_info)\n {\n-\tint\tsec;\n-\tint\tdsec, pkt_len;\n-\tchar\tdirection[2];\n-\tchar\tcap_src[13];\n+\tint\t\tsec;\n+\tint\t\tdsec;\n+\tchar\t\tcap_int[NETSCREEN_MAX_INT_NAME_LENGTH];\n+\tchar\t\tdirection[2];\n+\tguint\t\tpkt_len;\n+\tchar\t\tcap_src[13];\n+\tchar\t\tcap_dst[13];\n+\tguint8\t\t*pd;\n+\tgchar\t\t*p;\n+\tint\t\tn, i = 0;\n+\tguint\t\toffset = 0;\n+\tgchar\t\tdststr[13];\n \n \tphdr->rec_type = REC_TYPE_PACKET;\n \tphdr->presence_flags = WTAP_HAS_TS|WTAP_HAS_CAP_LEN;\n \n-\tif (sscanf(line, \"%9d.%9d: %15[a-z0-9/:.-](%1[io]) len=%9d:%12s->%12s/\",\n+\tif (sscanf(line, \"%9d.%9d: %15[a-z0-9/:.-](%1[io]) len=%9u:%12s->%12s/\",\n \t\t   &sec, &dsec, cap_int, direction, &pkt_len, cap_src, cap_dst) < 5) {\n \t\t*err = WTAP_ERR_BAD_FILE;\n \t\t*err_info = g_strdup(\"netscreen: Can't parse packet-header\");\n \t\treturn -1;\n \t}\n+\tif (pkt_len > WTAP_MAX_PACKET_SIZE) {\n+\t\t/*\n+\t\t * Probably a corrupt capture file; don't blow up trying\n+\t\t * to allocate space for an immensely-large packet.\n+\t\t */\n+\t\t*err = WTAP_ERR_BAD_FILE;\n+\t\t*err_info = g_strdup_printf(\"netscreen: File has %u-byte packet, bigger than maximum of %u\",\n+\t\t    pkt_len, WTAP_MAX_PACKET_SIZE);\n+\t\treturn FALSE;\n+\t}\n \n-\t*cap_dir = (direction[0] == 'o' ? NETSCREEN_EGRESS : NETSCREEN_INGRESS);\n+\t/*\n+\t * If direction[0] is 'o', the direction is NETSCREEN_EGRESS,\n+\t * otherwise it's NETSCREEN_INGRESS.\n+\t */\n \n \tphdr->ts.secs  = sec;\n \tphdr->ts.nsecs = dsec * 100000000;\n \tphdr->len = pkt_len;\n \n-\treturn pkt_len;\n-}\n-\n-/* Converts ASCII hex dump to binary data, and fills in some struct\n-   wtap_pkthdr fields.  Returns TRUE on success and FALSE on any error. */\n-static gboolean\n-parse_netscreen_hex_dump(FILE_T fh, int pkt_len, const char *cap_int,\n-    const char *cap_dst, struct wtap_pkthdr *phdr, Buffer* buf,\n-    int *err, gchar **err_info)\n-{\n-\tguint8\t*pd;\n-\tgchar\tline[NETSCREEN_LINE_LENGTH];\n-\tgchar\t*p;\n-\tint\tn, i = 0, offset = 0;\n-\tgchar\tdststr[13];\n-\n \t/* Make sure we have enough room for the packet */\n-\tws_buffer_assure_space(buf, NETSCREEN_MAX_PACKET_LEN);\n+\tws_buffer_assure_space(buf, pkt_len);\n \tpd = ws_buffer_start_ptr(buf);\n \n \twhile(1) {\n@@ -373,7 +352,7 @@ parse_netscreen_hex_dump(FILE_T fh, int pkt_len, const char *cap_int,\n \t\t/* If there is no more data and the line was not empty,\n \t\t * then there must be an error in the file\n \t\t */\n-\t\tif(n == -1) {\n+\t\tif (n == -1) {\n \t\t\t*err = WTAP_ERR_BAD_FILE;\n \t\t\t*err_info = g_strdup(\"netscreen: cannot parse hex-data\");\n \t\t\treturn FALSE;\n@@ -385,7 +364,7 @@ parse_netscreen_hex_dump(FILE_T fh, int pkt_len, const char *cap_int,\n \t\t/* If there was more hex-data than was announced in the len=x\n \t\t * header, then then there must be an error in the file\n \t\t */\n-\t\tif(offset > pkt_len) {\n+\t\tif (offset > pkt_len) {\n \t\t\t*err = WTAP_ERR_BAD_FILE;\n \t\t\t*err_info = g_strdup(\"netscreen: too much hex-data\");\n \t\t\treturn FALSE;", "file_path": "files/2016_8\\57", "file_language": "c", "file_name": "wiretap/netscreen.c", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}, {"raw_url": "https://github.com/wireshark/wireshark/raw/6a140eca7b78b230f1f90a739a32257476513c78/wiretap/netscreen.h", "code": "/* netscreen.h\n *\n * Juniper NetScreen snoop output parser\n * Created by re-using a lot of code from cosine.c\n * Copyright (c) 2007 by Sake Blok <sake@euronet.nl>\n *\n * Wiretap Library\n * Copyright (c) 1998 by Gilbert Ramirez <gram@alumni.rice.edu>\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version 2\n * of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n */\n\n#ifndef __W_NETSCREEN_H__\n#define __W_NETSCREEN_H__\n\n#include <glib.h>\n#include \"wtap.h\"\n\n/* Magic text to check for NetScreen snoop output */\n#define NETSCREEN_HDR_MAGIC_STR1\t\"(i) len=\"\n#define NETSCREEN_HDR_MAGIC_STR2\t\"(o) len=\"\n\n/* Magic text for start of packet */\n#define NETSCREEN_REC_MAGIC_STR1\tNETSCREEN_HDR_MAGIC_STR1\n#define NETSCREEN_REC_MAGIC_STR2\tNETSCREEN_HDR_MAGIC_STR2\n\n#define NETSCREEN_LINE_LENGTH\t\t128\n#define NETSCREEN_HEADER_LINES_TO_CHECK\t32\n#define NETSCREEN_MAX_INFOLINES\t\t8\n#define NETSCREEN_SPACES_ON_INFO_LINE\t14\n#define NETSCREEN_MAX_INT_NAME_LENGTH\t16\n\n#define NETSCREEN_INGRESS\t\tFALSE\n#define NETSCREEN_EGRESS\t\tTRUE\n\nwtap_open_return_val netscreen_open(wtap *wth, int *err, gchar **err_info);\n\n#endif\n", "code_before": "/** @file\n *\n * Juniper NetScreen snoop output parser\n * Created by re-using a lot of code from cosine.c\n * Copyright (c) 2007 by Sake Blok <sake@euronet.nl>\n *\n * Wiretap Library\n * Copyright (c) 1998 by Gilbert Ramirez <gram@alumni.rice.edu>\n *\n * SPDX-License-Identifier: GPL-2.0-or-later\n *\n */\n\n#ifndef __W_NETSCREEN_H__\n#define __W_NETSCREEN_H__\n\n#include <glib.h>\n#include \"wtap.h\"\n\n/* Magic text to check for NetScreen snoop output */\n#define NETSCREEN_HDR_MAGIC_STR1\t\"(i) len=\"\n#define NETSCREEN_HDR_MAGIC_STR2\t\"(o) len=\"\n\n/* Magic text for start of packet */\n#define NETSCREEN_REC_MAGIC_STR1\tNETSCREEN_HDR_MAGIC_STR1\n#define NETSCREEN_REC_MAGIC_STR2\tNETSCREEN_HDR_MAGIC_STR2\n\n#define NETSCREEN_LINE_LENGTH\t\t128\n#define NETSCREEN_HEADER_LINES_TO_CHECK\t32\n#define NETSCREEN_MAX_INFOLINES\t\t8\n#define NETSCREEN_SPACES_ON_INFO_LINE\t14\n#define NETSCREEN_MAX_INT_NAME_LENGTH\t16\n\n#define NETSCREEN_INGRESS\t\tfalse\n#define NETSCREEN_EGRESS\t\ttrue\n\nwtap_open_return_val netscreen_open(wtap *wth, int *err, char **err_info);\n\n#endif\n", "patch": "@@ -46,9 +46,6 @@\n #define NETSCREEN_INGRESS\t\tFALSE\n #define NETSCREEN_EGRESS\t\tTRUE\n \n-\n-#define NETSCREEN_MAX_PACKET_LEN\t65536\n-\n wtap_open_return_val netscreen_open(wtap *wth, int *err, gchar **err_info);\n \n #endif", "file_path": "files/2016_8\\58", "file_language": "h", "file_name": "wiretap/netscreen.h", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}], "outdated": 0}
{"index": 20, "cve_id": "CVE-2016-5352", "cwe_id": ["CWE-125"], "cve_language": "C", "cve_description": "epan/crypt/airpdcap.c in the IEEE 802.11 dissector in Wireshark 2.x before 2.0.4 mishandles certain length values, which allows remote attackers to cause a denial of service (application crash) via a crafted packet.", "cvss": "5.9", "publish_date": "August 7, 2016", "AV": "NETWORK", "AC": "HIGH", "PR": "NONE", "UI": "NONE", "S": "UNCHANGED", "C": "NONE", "I": "NONE", "A": "HIGH", "commit_id": "b6d838eebf4456192360654092e5587c5207f185", "commit_message": "Sanity check eapol_len in AirPDcapDecryptWPABroadcastKey\n\nBug: 12175\nChange-Id: Iaf977ba48f8668bf8095800a115ff9a3472dd893\nReviewed-on: https://code.wireshark.org/review/15326\nPetri-Dish: Michael Mann <mmann78@netscape.net>\nTested-by: Petri Dish Buildbot <buildbot-no-reply@wireshark.org>\nReviewed-by: Alexis La Goutte <alexis.lagoutte@gmail.com>\nReviewed-by: Peter Wu <peter@lekensteyn.nl>\nTested-by: Peter Wu <peter@lekensteyn.nl>", "commit_date": "2016-05-10T15:20:49Z", "project": "wireshark/wireshark", "url": "https://api.github.com/repos/wireshark/wireshark/commits/b6d838eebf4456192360654092e5587c5207f185", "html_url": "https://github.com/wireshark/wireshark/commit/b6d838eebf4456192360654092e5587c5207f185", "windows_before": "", "windows_after": "", "parents": [{"commit_id_before": "2bc2b3e686df39bb655c54b101b11537507fb5a3", "url_before": "https://api.github.com/repos/wireshark/wireshark/commits/2bc2b3e686df39bb655c54b101b11537507fb5a3", "html_url_before": "https://github.com/wireshark/wireshark/commit/2bc2b3e686df39bb655c54b101b11537507fb5a3"}], "details": [{"raw_url": "https://github.com/wireshark/wireshark/raw/b6d838eebf4456192360654092e5587c5207f185/epan/crypt/airpdcap.c", "code": "/* airpdcap.c\n *\n * Copyright (c) 2006 CACE Technologies, Davis (California)\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the project nor the names of its contributors\n *    may be used to endorse or promote products derived from this software\n *    without specific prior written permission.\n *\n * Alternatively, this software may be distributed under the terms of the\n * GNU General Public License (\"GPL\") version 2 as published by the Free\n * Software Foundation.\n *\n * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n\n/*\n * The files matching airpcap*.[ch] were originally developed as part of\n * Wireshark's support for AirPcap adapters. However, they've been used\n * for general 802.11 decryption for quite some time. It might make sense\n * to rename them accordingly.\n */\n\n/****************************************************************************/\n/*      File includes                                                       */\n\n#include \"config.h\"\n\n#include <glib.h>\n\n#include <wsutil/crc32.h>\n#include <wsutil/rc4.h>\n#include <wsutil/sha1.h>\n#include <wsutil/sha2.h>\n#include <wsutil/md5.h>\n#include <wsutil/pint.h>\n#include <wsutil/aes.h>\n\n#include <epan/tvbuff.h>\n#include <epan/to_str.h>\n#include <epan/strutil.h>\n#include <epan/crypt/airpdcap_rijndael.h>\n\n#include \"airpdcap_system.h\"\n#include \"airpdcap_int.h\"\n\n#include \"airpdcap_debug.h\"\n\n#include \"wep-wpadefs.h\"\n\n\n/****************************************************************************/\n\n/****************************************************************************/\n/*      Constant definitions                                                    */\n\n/*      EAPOL definitions                                                       */\n/**\n * Length of the EAPOL-Key key confirmation key (KCK) used to calculate\n * MIC over EAPOL frame and validate an EAPOL packet (128 bits)\n */\n#define AIRPDCAP_WPA_KCK_LEN    16\n/**\n *Offset of the Key MIC in the EAPOL packet body\n */\n#define AIRPDCAP_WPA_MICKEY_OFFSET      77\n/**\n * Maximum length of the EAPOL packet (it depends on the maximum MAC\n * frame size)\n */\n#define AIRPDCAP_WPA_MAX_EAPOL_LEN      4095\n/**\n * EAPOL Key Descriptor Version 1, used for all EAPOL-Key frames to and\n * from a STA when neither the group nor pairwise ciphers are CCMP for\n * Key Descriptor 1.\n * @note\n * Defined in 802.11i-2004, page 78\n */\n#define AIRPDCAP_WPA_KEY_VER_NOT_CCMP   1\n/**\n * EAPOL Key Descriptor Version 2, used for all EAPOL-Key frames to and\n * from a STA when either the pairwise or the group cipher is AES-CCMP\n * for Key Descriptor 2.\n * /note\n * Defined in 802.11i-2004, page 78\n */\n#define AIRPDCAP_WPA_KEY_VER_AES_CCMP   2\n\n/** Define EAPOL Key Descriptor type values:  use 254 for WPA and 2 for WPA2 **/\n#define AIRPDCAP_RSN_WPA_KEY_DESCRIPTOR 254\n#define AIRPDCAP_RSN_WPA2_KEY_DESCRIPTOR 2\n\n/****************************************************************************/\n\n\n\n/****************************************************************************/\n/*      Macro definitions                                                       */\n\nextern const UINT32 crc32_table[256];\n#define CRC(crc, ch)     (crc = (crc >> 8) ^ crc32_table[(crc ^ (ch)) & 0xff])\n\n#define AIRPDCAP_GET_TK(ptk)    (ptk + 32)\n\n/****************************************************************************/\n\n/****************************************************************************/\n/*      Type definitions                                                        */\n\n/*      Internal function prototype declarations                                */\n\n#ifdef  __cplusplus\nextern \"C\" {\n#endif\n\n/**\n * It is a step of the PBKDF2 (specifically the PKCS #5 v2.0) defined in\n * the RFC 2898 to derive a key (used as PMK in WPA)\n * @param ppbytes [IN] pointer to a password (sequence of between 8 and\n * 63 ASCII encoded characters)\n * @param ssid [IN] pointer to the SSID string encoded in max 32 ASCII\n * encoded characters\n * @param iterations [IN] times to hash the password (4096 for WPA)\n * @param count [IN] ???\n * @param output [OUT] pointer to a preallocated buffer of\n * SHA1_DIGEST_LEN characters that will contain a part of the key\n */\nstatic INT AirPDcapRsnaPwd2PskStep(\n    const guint8 *ppbytes,\n    const guint passLength,\n    const CHAR *ssid,\n    const size_t ssidLength,\n    const INT iterations,\n    const INT count,\n    UCHAR *output)\n    ;\n\n/**\n * It calculates the passphrase-to-PSK mapping reccomanded for use with\n * RSNAs. This implementation uses the PBKDF2 method defined in the RFC\n * 2898.\n * @param passphrase [IN] pointer to a password (sequence of between 8 and\n * 63 ASCII encoded characters)\n * @param ssid [IN] pointer to the SSID string encoded in max 32 ASCII\n * encoded characters\n * @param output [OUT] calculated PSK (to use as PMK in WPA)\n * @note\n * Described in 802.11i-2004, page 165\n */\nstatic INT AirPDcapRsnaPwd2Psk(\n    const CHAR *passphrase,\n    const CHAR *ssid,\n    const size_t ssidLength,\n    UCHAR *output)\n    ;\n\nstatic INT AirPDcapRsnaMng(\n    UCHAR *decrypt_data,\n    guint mac_header_len,\n    guint *decrypt_len,\n    PAIRPDCAP_KEY_ITEM key,\n    AIRPDCAP_SEC_ASSOCIATION *sa,\n    INT offset)\n    ;\n\nstatic INT AirPDcapWepMng(\n    PAIRPDCAP_CONTEXT ctx,\n    UCHAR *decrypt_data,\n    guint mac_header_len,\n    guint *decrypt_len,\n    PAIRPDCAP_KEY_ITEM key,\n    AIRPDCAP_SEC_ASSOCIATION *sa,\n    INT offset)\n    ;\n\nstatic INT AirPDcapRsna4WHandshake(\n    PAIRPDCAP_CONTEXT ctx,\n    const UCHAR *data,\n    AIRPDCAP_SEC_ASSOCIATION *sa,\n    INT offset,\n    const guint tot_len)\n    ;\n/**\n * It checks whether the specified key is corrected or not.\n * @note\n * For a standard WEP key the length will be changed to the standard\n * length, and the type changed in a generic WEP key.\n * @param key [IN] pointer to the key to validate\n * @return\n * - TRUE: the key contains valid fields and values\n * - FALSE: the key has some invalid field or value\n */\nstatic INT AirPDcapValidateKey(\n    PAIRPDCAP_KEY_ITEM key)\n    ;\n\nstatic INT AirPDcapRsnaMicCheck(\n    UCHAR *eapol,\n    USHORT eapol_len,\n    UCHAR KCK[AIRPDCAP_WPA_KCK_LEN],\n    USHORT key_ver)\n    ;\n\n/**\n * @param ctx [IN] pointer to the current context\n * @param id [IN] id of the association (composed by BSSID and MAC of\n * the station)\n * @return\n * - index of the Security Association structure if found\n * - -1, if the specified addresses pair BSSID-STA MAC has not been found\n */\nstatic INT AirPDcapGetSa(\n    PAIRPDCAP_CONTEXT ctx,\n    AIRPDCAP_SEC_ASSOCIATION_ID *id)\n    ;\n\nstatic INT AirPDcapStoreSa(\n    PAIRPDCAP_CONTEXT ctx,\n    AIRPDCAP_SEC_ASSOCIATION_ID *id)\n    ;\n\nstatic INT AirPDcapGetSaAddress(\n    const AIRPDCAP_MAC_FRAME_ADDR4 *frame,\n    AIRPDCAP_SEC_ASSOCIATION_ID *id)\n    ;\n\nstatic const UCHAR * AirPDcapGetStaAddress(\n    const AIRPDCAP_MAC_FRAME_ADDR4 *frame)\n    ;\n\nstatic const UCHAR * AirPDcapGetBssidAddress(\n    const AIRPDCAP_MAC_FRAME_ADDR4 *frame)\n    ;\n\nstatic void AirPDcapRsnaPrfX(\n    AIRPDCAP_SEC_ASSOCIATION *sa,\n    const UCHAR pmk[32],\n    const UCHAR snonce[32],\n    const INT x,        /*      for TKIP 512, for CCMP 384      */\n    UCHAR *ptk)\n    ;\n\n\n/**\n * @param sa  [IN/OUT] pointer to SA that will hold the key\n * @param data [IN] Frame\n * @param offset_rsne [IN] RSNE IE offset in the frame\n * @param offset_fte [IN] Fast BSS Transition IE offset in the frame\n * @param offset_timeout [IN] Timeout Interval IE offset in the frame\n * @param offset_link [IN] Link Identifier IE offset in the frame\n * @param action [IN] Tdls Action code (response or confirm)\n *\n * @return\n *  AIRPDCAP_RET_SUCCESS if Key has been sucessfully derived (and MIC verified)\n *  AIRPDCAP_RET_UNSUCCESS otherwise\n */\nstatic INT\nAirPDcapTDLSDeriveKey(\n    PAIRPDCAP_SEC_ASSOCIATION sa,\n    const guint8 *data,\n    guint offset_rsne,\n    guint offset_fte,\n    guint offset_timeout,\n    guint offset_link,\n    guint8 action)\n    ;\n#ifdef  __cplusplus\n}\n#endif\n\n/****************************************************************************/\n\n/****************************************************************************/\n/* Exported function definitions                                                */\n\n#ifdef  __cplusplus\nextern \"C\" {\n#endif\n\nconst guint8 broadcast_mac[] = { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF };\n\n#define EAPKEY_MIC_LEN  16  /* length of the MIC key for EAPoL_Key packet's MIC using MD5 */\n#define NONCE_LEN 32\n\n#define TKIP_GROUP_KEY_LEN 32\n#define CCMP_GROUP_KEY_LEN 16\n\ntypedef struct {\n    guint8  type;\n    guint8  key_information[2];  /* Make this an array to avoid alignment issues */\n    guint8  key_length[2];  /* Make this an array to avoid alignment issues */\n    guint8  replay_counter[8];\n    guint8  key_nonce[NONCE_LEN];\n    guint8  key_iv[16];\n    guint8  key_sequence_counter[8];  /* also called the RSC */\n    guint8  key_id[8];\n    guint8  key_mic[EAPKEY_MIC_LEN];\n    guint8  key_data_len[2];  /* Make this an array rather than a U16 to avoid alignment shifting */\n} EAPOL_RSN_KEY,  * P_EAPOL_RSN_KEY;\n\n/* Minimum possible key data size (at least one GTK KDE with CCMP key) */\n#define GROUP_KEY_MIN_LEN 8 + CCMP_GROUP_KEY_LEN\n/* Minimum possible group key msg size (group key msg using CCMP as cipher)*/\n#define GROUP_KEY_PAYLOAD_LEN_MIN sizeof(EAPOL_RSN_KEY) + GROUP_KEY_MIN_LEN\n\n/* XXX - what if this doesn't get the key? */\nstatic INT\nAirPDcapDecryptWPABroadcastKey(const EAPOL_RSN_KEY *pEAPKey, guint8 *decryption_key, PAIRPDCAP_SEC_ASSOCIATION sa, guint eapol_len)\n{\n    guint8 key_version;\n    guint8 *key_data;\n    guint8  *szEncryptedKey;\n    guint16 key_bytes_len = 0; /* Length of the total key data field */\n    guint16 key_len;           /* Actual group key length */\n    static AIRPDCAP_KEY_ITEM dummy_key; /* needed in case AirPDcapRsnaMng() wants the key structure */\n    AIRPDCAP_SEC_ASSOCIATION *tmp_sa;\n\n    /* We skip verifying the MIC of the key. If we were implementing a WPA supplicant we'd want to verify, but for a sniffer it's not needed. */\n\n    /* Preparation for decrypting the group key -  determine group key data length */\n    /* depending on whether the pairwise key is TKIP or AES encryption key */\n    key_version = AIRPDCAP_EAP_KEY_DESCR_VER(pEAPKey->key_information[1]);\n    if (key_version == AIRPDCAP_WPA_KEY_VER_NOT_CCMP){\n        /* TKIP */\n        key_bytes_len = pntoh16(pEAPKey->key_length);\n    }else if (key_version == AIRPDCAP_WPA_KEY_VER_AES_CCMP){\n        /* AES */\n        key_bytes_len = pntoh16(pEAPKey->key_data_len);\n\n        /* AES keys must be at least 128 bits = 16 bytes. */\n        if (key_bytes_len < 16) {\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n        }\n    }\n\n    if ((key_bytes_len < GROUP_KEY_MIN_LEN) ||\n        (eapol_len < sizeof(EAPOL_RSN_KEY)) ||\n        (key_bytes_len > eapol_len - sizeof(EAPOL_RSN_KEY))) {\n        return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n    }\n\n    /* Encrypted key is in the information element field of the EAPOL key packet */\n    key_data = (guint8 *)pEAPKey + sizeof(EAPOL_RSN_KEY);\n    szEncryptedKey = (guint8 *)g_memdup(key_data, key_bytes_len);\n\n    DEBUG_DUMP(\"Encrypted Broadcast key:\", szEncryptedKey, key_bytes_len);\n    DEBUG_DUMP(\"KeyIV:\", pEAPKey->key_iv, 16);\n    DEBUG_DUMP(\"decryption_key:\", decryption_key, 16);\n\n    /* We are rekeying, save old sa */\n    tmp_sa=(AIRPDCAP_SEC_ASSOCIATION *)g_malloc(sizeof(AIRPDCAP_SEC_ASSOCIATION));\n    memcpy(tmp_sa, sa, sizeof(AIRPDCAP_SEC_ASSOCIATION));\n    sa->next=tmp_sa;\n\n    /* As we have no concept of the prior association request at this point, we need to deduce the     */\n    /* group key cipher from the length of the key bytes. In WPA this is straightforward as the        */\n    /* keybytes just contain the GTK, and the GTK is only in the group handshake, NOT the M3.          */\n    /* In WPA2 its a little more tricky as the M3 keybytes contain an RSN_IE, but the group handshake  */\n    /* does not. Also there are other (variable length) items in the keybytes which we need to account */\n    /* for to determine the true key length, and thus the group cipher.                                */\n\n    if (key_version == AIRPDCAP_WPA_KEY_VER_NOT_CCMP){\n        guint8 new_key[32];\n        guint8 dummy[256];\n        /* TKIP key */\n        /* Per 802.11i, Draft 3.0 spec, section 8.5.2, p. 97, line 4-8, */\n        /* group key is decrypted using RC4.  Concatenate the IV with the 16 byte EK (PTK+16) to get the decryption key */\n\n        rc4_state_struct rc4_state;\n\n        /* The WPA group key just contains the GTK bytes so deducing the type is straightforward   */\n        /* Note - WPA M3 doesn't contain a group key so we'll only be here for the group handshake */\n        sa->wpa.key_ver = (key_bytes_len >=TKIP_GROUP_KEY_LEN)?AIRPDCAP_WPA_KEY_VER_NOT_CCMP:AIRPDCAP_WPA_KEY_VER_AES_CCMP;\n\n        /* Build the full decryption key based on the IV and part of the pairwise key */\n        memcpy(new_key, pEAPKey->key_iv, 16);\n        memcpy(new_key+16, decryption_key, 16);\n        DEBUG_DUMP(\"FullDecrKey:\", new_key, 32);\n\n        crypt_rc4_init(&rc4_state, new_key, sizeof(new_key));\n\n        /* Do dummy 256 iterations of the RC4 algorithm (per 802.11i, Draft 3.0, p. 97 line 6) */\n        crypt_rc4(&rc4_state, dummy, 256);\n        crypt_rc4(&rc4_state, szEncryptedKey, key_bytes_len);\n\n    } else if (key_version == AIRPDCAP_WPA_KEY_VER_AES_CCMP){\n        /* AES CCMP key */\n\n        guint8 key_found;\n        guint8 key_length;\n        guint16 key_index;\n        guint8 *decrypted_data;\n\n        /* Unwrap the key; the result is key_bytes_len in length */\n        decrypted_data = AES_unwrap(decryption_key, 16, szEncryptedKey,  key_bytes_len);\n\n        /* With WPA2 what we get after Broadcast Key decryption is an actual RSN structure.\n           The key itself is stored as a GTK KDE\n           WPA2 IE (1 byte) id = 0xdd, length (1 byte), GTK OUI (4 bytes), key index (1 byte) and 1 reserved byte. Thus we have to\n           pass pointer to the actual key with 8 bytes offset */\n\n        key_found = FALSE;\n        key_index = 0;\n\n        /* Parse Key data until we found GTK KDE */\n        /* GTK KDE = 00-0F-AC 01 */\n        while(key_index < (key_bytes_len - 6) && !key_found){\n            guint8 rsn_id;\n            guint32 type;\n\n            /* Get RSN ID */\n            rsn_id = decrypted_data[key_index];\n            type = ((decrypted_data[key_index + 2] << 24) +\n                    (decrypted_data[key_index + 3] << 16) +\n                    (decrypted_data[key_index + 4] << 8) +\n                     (decrypted_data[key_index + 5]));\n\n            if (rsn_id == 0xdd && type == 0x000fac01) {\n                key_found = TRUE;\n            } else {\n                key_index += decrypted_data[key_index+1]+2;\n            }\n        }\n\n        if (key_found){\n            key_length = decrypted_data[key_index+1] - 6;\n\n            if (key_index+8 >= key_bytes_len ||\n                key_length > key_bytes_len - key_index - 8) {\n                g_free(decrypted_data);\n                g_free(szEncryptedKey);\n                return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n            }\n\n            /* Skip over the GTK header info, and don't copy past the end of the encrypted data */\n            memcpy(szEncryptedKey, decrypted_data+key_index+8, key_length);\n        } else {\n            g_free(decrypted_data);\n            g_free(szEncryptedKey);\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n        }\n\n        if (key_length == TKIP_GROUP_KEY_LEN)\n            sa->wpa.key_ver = AIRPDCAP_WPA_KEY_VER_NOT_CCMP;\n        else\n            sa->wpa.key_ver = AIRPDCAP_WPA_KEY_VER_AES_CCMP;\n\n        g_free(decrypted_data);\n    }\n\n    key_len = (sa->wpa.key_ver==AIRPDCAP_WPA_KEY_VER_NOT_CCMP)?TKIP_GROUP_KEY_LEN:CCMP_GROUP_KEY_LEN;\n    if (key_len > key_bytes_len) {\n        /* the key required for this protocol is longer than the key that we just calculated */\n        g_free(szEncryptedKey);\n        return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n    }\n\n    /* Decrypted key is now in szEncryptedKey with len of key_len */\n    DEBUG_DUMP(\"Broadcast key:\", szEncryptedKey, key_len);\n\n    /* Load the proper key material info into the SA */\n    sa->key = &dummy_key;  /* we just need key to be not null because it is checked in AirPDcapRsnaMng().  The WPA key materials are actually in the .wpa structure */\n    sa->validKey = TRUE;\n\n    /* Since this is a GTK and its size is only 32 bytes (vs. the 64 byte size of a PTK), we fake it and put it in at a 32-byte offset so the  */\n    /* AirPDcapRsnaMng() function will extract the right piece of the GTK for decryption. (The first 16 bytes of the GTK are used for decryption.) */\n    memset(sa->wpa.ptk, 0, sizeof(sa->wpa.ptk));\n    memcpy(sa->wpa.ptk+32, szEncryptedKey, key_len);\n    g_free(szEncryptedKey);\n    return AIRPDCAP_RET_SUCCESS_HANDSHAKE;\n}\n\n\n/* Return a pointer the the requested SA. If it doesn't exist create it. */\nstatic PAIRPDCAP_SEC_ASSOCIATION\nAirPDcapGetSaPtr(\n    PAIRPDCAP_CONTEXT ctx,\n    AIRPDCAP_SEC_ASSOCIATION_ID *id)\n{\n    int sa_index;\n\n    /* search for a cached Security Association for supplied BSSID and STA MAC  */\n    if ((sa_index=AirPDcapGetSa(ctx, id))==-1) {\n        /* create a new Security Association if it doesn't currently exist      */\n        if ((sa_index=AirPDcapStoreSa(ctx, id))==-1) {\n            return NULL;\n        }\n    }\n    /* get the Security Association structure   */\n    return &ctx->sa[sa_index];\n}\n\nstatic INT AirPDcapScanForKeys(\n    PAIRPDCAP_CONTEXT ctx,\n    const guint8 *data,\n    const guint mac_header_len,\n    const guint tot_len,\n    AIRPDCAP_SEC_ASSOCIATION_ID id\n)\n{\n    const UCHAR *addr;\n    guint bodyLength;\n    PAIRPDCAP_SEC_ASSOCIATION sta_sa;\n    PAIRPDCAP_SEC_ASSOCIATION sa;\n    guint offset = 0;\n    const guint8 dot1x_header[] = {\n        0xAA,             /* DSAP=SNAP */\n        0xAA,             /* SSAP=SNAP */\n        0x03,             /* Control field=Unnumbered frame */\n        0x00, 0x00, 0x00, /* Org. code=encaps. Ethernet */\n        0x88, 0x8E        /* Type: 802.1X authentication */\n    };\n    const guint8 bt_dot1x_header[] = {\n        0xAA,             /* DSAP=SNAP */\n        0xAA,             /* SSAP=SNAP */\n        0x03,             /* Control field=Unnumbered frame */\n        0x00, 0x19, 0x58, /* Org. code=Bluetooth SIG */\n        0x00, 0x03        /* Type: Bluetooth Security */\n    };\n    const guint8 tdls_header[] = {\n        0xAA,             /* DSAP=SNAP */\n        0xAA,             /* SSAP=SNAP */\n        0x03,             /* Control field=Unnumbered frame */\n        0x00, 0x00, 0x00, /* Org. code=encaps. Ethernet */\n        0x89, 0x0D,       /* Type: 802.11 - Fast Roaming Remote Request */\n        0x02,             /* Payload Type: TDLS */\n        0X0C              /* Action Category: TDLS */\n    };\n\n    const EAPOL_RSN_KEY *pEAPKey;\n#ifdef _DEBUG\n#define MSGBUF_LEN 255\n    CHAR msgbuf[MSGBUF_LEN];\n#endif\n    AIRPDCAP_DEBUG_TRACE_START(\"AirPDcapScanForKeys\");\n\n    /* cache offset in the packet data */\n    offset = mac_header_len;\n\n    /* check if the packet has an LLC header and the packet is 802.1X authentication (IEEE 802.1X-2004, pg. 24) */\n    if (memcmp(data+offset, dot1x_header, 8) == 0 || memcmp(data+offset, bt_dot1x_header, 8) == 0) {\n\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Authentication: EAPOL packet\", AIRPDCAP_DEBUG_LEVEL_3);\n\n        /* skip LLC header */\n        offset+=8;\n\n        /* check if the packet is a EAPOL-Key (0x03) (IEEE 802.1X-2004, pg. 25) */\n        if (data[offset+1]!=3) {\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Not EAPOL-Key\", AIRPDCAP_DEBUG_LEVEL_3);\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n        }\n\n        /* get and check the body length (IEEE 802.1X-2004, pg. 25) */\n        bodyLength=pntoh16(data+offset+2);\n        if ((tot_len-offset-4) < bodyLength) { /* Only check if frame is long enough for eapol header, ignore tailing garbage, see bug 9065 */\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"EAPOL body too short\", AIRPDCAP_DEBUG_LEVEL_3);\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n        }\n\n        /* skip EAPOL MPDU and go to the first byte of the body */\n        offset+=4;\n\n        pEAPKey = (const EAPOL_RSN_KEY *) (data+offset);\n\n        /* check if the key descriptor type is valid (IEEE 802.1X-2004, pg. 27) */\n        if (/*pEAPKey->type!=0x1 &&*/ /* RC4 Key Descriptor Type (deprecated) */\n            pEAPKey->type != AIRPDCAP_RSN_WPA2_KEY_DESCRIPTOR &&             /* IEEE 802.11 Key Descriptor Type  (WPA2) */\n            pEAPKey->type != AIRPDCAP_RSN_WPA_KEY_DESCRIPTOR)           /* 254 = RSN_KEY_DESCRIPTOR - WPA,              */\n        {\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Not valid key descriptor type\", AIRPDCAP_DEBUG_LEVEL_3);\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n        }\n\n        /* start with descriptor body */\n        offset+=1;\n\n        /* search for a cached Security Association for current BSSID and AP */\n        sa = AirPDcapGetSaPtr(ctx, &id);\n        if (sa == NULL){\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"No SA for BSSID found\", AIRPDCAP_DEBUG_LEVEL_3);\n            return AIRPDCAP_RET_REQ_DATA;\n        }\n\n        /* It could be a Pairwise Key exchange, check */\n        if (AirPDcapRsna4WHandshake(ctx, data, sa, offset, tot_len) == AIRPDCAP_RET_SUCCESS_HANDSHAKE)\n            return AIRPDCAP_RET_SUCCESS_HANDSHAKE;\n\n        if (mac_header_len + GROUP_KEY_PAYLOAD_LEN_MIN > tot_len) {\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Message too short for Group Key\", AIRPDCAP_DEBUG_LEVEL_3);\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n        }\n\n        /* Verify the bitfields: Key = 0(groupwise) Mic = 1 Ack = 1 Secure = 1 */\n        if (AIRPDCAP_EAP_KEY(data[offset+1])!=0 ||\n            AIRPDCAP_EAP_ACK(data[offset+1])!=1 ||\n            AIRPDCAP_EAP_MIC(data[offset]) != 1 ||\n            AIRPDCAP_EAP_SEC(data[offset]) != 1){\n\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Key bitfields not correct for Group Key\", AIRPDCAP_DEBUG_LEVEL_3);\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n        }\n\n        /* force STA address to be the broadcast MAC so we create an SA for the groupkey */\n        memcpy(id.sta, broadcast_mac, AIRPDCAP_MAC_LEN);\n\n        /* get the Security Association structure for the broadcast MAC and AP */\n        sa = AirPDcapGetSaPtr(ctx, &id);\n        if (sa == NULL){\n            return AIRPDCAP_RET_REQ_DATA;\n        }\n\n        /* Get the SA for the STA, since we need its pairwise key to decrpyt the group key */\n\n        /* get STA address */\n        if ( (addr=AirPDcapGetStaAddress((const AIRPDCAP_MAC_FRAME_ADDR4 *)(data))) != NULL) {\n            memcpy(id.sta, addr, AIRPDCAP_MAC_LEN);\n#ifdef _DEBUG\n            g_snprintf(msgbuf, MSGBUF_LEN, \"ST_MAC: %2X.%2X.%2X.%2X.%2X.%2X\\t\", id.sta[0],id.sta[1],id.sta[2],id.sta[3],id.sta[4],id.sta[5]);\n#endif\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", msgbuf, AIRPDCAP_DEBUG_LEVEL_3);\n        } else {\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"SA not found\", AIRPDCAP_DEBUG_LEVEL_5);\n            return AIRPDCAP_RET_REQ_DATA;\n        }\n\n        sta_sa = AirPDcapGetSaPtr(ctx, &id);\n        if (sta_sa == NULL){\n            return AIRPDCAP_RET_REQ_DATA;\n        }\n\n        /* Try to extract the group key and install it in the SA */\n        return (AirPDcapDecryptWPABroadcastKey(pEAPKey, sta_sa->wpa.ptk+16, sa, tot_len-offset+1));\n\n    } else if (memcmp(data+offset, tdls_header, 10) == 0) {\n        const guint8 *initiator, *responder;\n        guint8 action;\n        guint status, offset_rsne = 0, offset_fte = 0, offset_link = 0, offset_timeout = 0;\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Authentication: TDLS Action Frame\", AIRPDCAP_DEBUG_LEVEL_3);\n\n        /* skip LLC header */\n        offset+=10;\n\n        /* check if the packet is a TDLS response or confirm */\n        action = data[offset];\n        if (action!=1 && action!=2) {\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Not Response nor confirm\", AIRPDCAP_DEBUG_LEVEL_3);\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n        }\n\n        /* check status */\n        offset++;\n        status=pntoh16(data+offset);\n        if (status!=0) {\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"TDLS setup not successfull\", AIRPDCAP_DEBUG_LEVEL_3);\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n        }\n\n        /* skip Token + capabilities */\n        offset+=5;\n\n        /* search for RSN, Fast BSS Transition, Link Identifier and Timeout Interval IEs */\n\n        while(offset < (tot_len - 2)) {\n            if (data[offset] == 48) {\n                offset_rsne = offset;\n            } else if (data[offset] == 55) {\n                offset_fte = offset;\n            } else if (data[offset] == 56) {\n                offset_timeout = offset;\n            } else if (data[offset] == 101) {\n                offset_link = offset;\n            }\n\n            if (tot_len < offset + data[offset + 1] + 2) {\n                return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n            }\n            offset += data[offset + 1] + 2;\n        }\n\n        if (offset_rsne == 0 || offset_fte == 0 ||\n            offset_timeout == 0 || offset_link == 0)\n        {\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Cannot Find all necessary IEs\", AIRPDCAP_DEBUG_LEVEL_3);\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n        }\n\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Found RSNE/Fast BSS/Timeout Interval/Link IEs\", AIRPDCAP_DEBUG_LEVEL_3);\n\n        /* Will create a Security Association between 2 STA. Need to get both MAC address */\n        initiator = &data[offset_link + 8];\n        responder = &data[offset_link + 14];\n\n        if (memcmp(initiator, responder, AIRPDCAP_MAC_LEN) < 0) {\n            memcpy(id.sta, initiator, AIRPDCAP_MAC_LEN);\n            memcpy(id.bssid, responder, AIRPDCAP_MAC_LEN);\n        } else {\n            memcpy(id.sta, responder, AIRPDCAP_MAC_LEN);\n            memcpy(id.bssid, initiator, AIRPDCAP_MAC_LEN);\n        }\n\n        sa = AirPDcapGetSaPtr(ctx, &id);\n        if (sa == NULL){\n            return AIRPDCAP_RET_REQ_DATA;\n        }\n\n        if (sa->validKey) {\n            if (memcmp(sa->wpa.nonce, data + offset_fte + 52, AIRPDCAP_WPA_NONCE_LEN) == 0) {\n                /* Already have valid key for this SA, no need to redo key derivation */\n                return AIRPDCAP_RET_SUCCESS_HANDSHAKE;\n            } else {\n                /* We are opening a new session with the same two STA, save previous sa  */\n                AIRPDCAP_SEC_ASSOCIATION *tmp_sa = g_new(AIRPDCAP_SEC_ASSOCIATION, 1);\n                memcpy(tmp_sa, sa, sizeof(AIRPDCAP_SEC_ASSOCIATION));\n                sa->next=tmp_sa;\n                sa->validKey = FALSE;\n            }\n        }\n\n        if (AirPDcapTDLSDeriveKey(sa, data, offset_rsne, offset_fte, offset_timeout, offset_link, action)\n            == AIRPDCAP_RET_SUCCESS) {\n            AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapScanForKeys\");\n            return AIRPDCAP_RET_SUCCESS_HANDSHAKE;\n        }\n    } else {\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Skipping: not an EAPOL packet\", AIRPDCAP_DEBUG_LEVEL_3);\n    }\n\n    AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapScanForKeys\");\n    return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n}\n\n\nINT AirPDcapPacketProcess(\n    PAIRPDCAP_CONTEXT ctx,\n    const guint8 *data,\n    const guint mac_header_len,\n    const guint tot_len,\n    UCHAR *decrypt_data,\n    guint *decrypt_len,\n    PAIRPDCAP_KEY_ITEM key,\n    gboolean scanHandshake)\n{\n    AIRPDCAP_SEC_ASSOCIATION_ID id;\n    UCHAR tmp_data[AIRPDCAP_MAX_CAPLEN];\n    guint tmp_len;\n\n#ifdef _DEBUG\n#define MSGBUF_LEN 255\n    CHAR msgbuf[MSGBUF_LEN];\n#endif\n\n    AIRPDCAP_DEBUG_TRACE_START(\"AirPDcapPacketProcess\");\n\n    if (ctx==NULL) {\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapPacketProcess\", \"NULL context\", AIRPDCAP_DEBUG_LEVEL_5);\n        AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapPacketProcess\");\n        return AIRPDCAP_RET_REQ_DATA;\n    }\n    if (data==NULL || tot_len==0) {\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapPacketProcess\", \"NULL data or length=0\", AIRPDCAP_DEBUG_LEVEL_5);\n        AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapPacketProcess\");\n        return AIRPDCAP_RET_REQ_DATA;\n    }\n\n    /* check if the packet is of data or robust managment type */\n    if (!((AIRPDCAP_TYPE(data[0])==AIRPDCAP_TYPE_DATA) ||\n          (AIRPDCAP_TYPE(data[0])==AIRPDCAP_TYPE_MANAGEMENT &&\n           (AIRPDCAP_SUBTYPE(data[0])==AIRPDCAP_SUBTYPE_DISASS ||\n            AIRPDCAP_SUBTYPE(data[0])==AIRPDCAP_SUBTYPE_DEAUTHENTICATION ||\n            AIRPDCAP_SUBTYPE(data[0])==AIRPDCAP_SUBTYPE_ACTION)))) {\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapPacketProcess\", \"not data nor robust mgmt packet\", AIRPDCAP_DEBUG_LEVEL_5);\n        return AIRPDCAP_RET_NO_DATA;\n    }\n\n    /* check correct packet size, to avoid wrong elaboration of encryption algorithms */\n    if (tot_len < (UINT)(mac_header_len+AIRPDCAP_CRYPTED_DATA_MINLEN)) {\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapPacketProcess\", \"minimum length violated\", AIRPDCAP_DEBUG_LEVEL_5);\n        return AIRPDCAP_RET_WRONG_DATA_SIZE;\n    }\n\n    /* Assume that the decrypt_data field is at least this size. */\n    if (tot_len > AIRPDCAP_MAX_CAPLEN) {\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapPacketProcess\", \"length too large\", AIRPDCAP_DEBUG_LEVEL_3);\n        return AIRPDCAP_RET_UNSUCCESS;\n    }\n\n    /* get STA/BSSID address */\n    if (AirPDcapGetSaAddress((const AIRPDCAP_MAC_FRAME_ADDR4 *)(data), &id) != AIRPDCAP_RET_SUCCESS) {\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapPacketProcess\", \"STA/BSSID not found\", AIRPDCAP_DEBUG_LEVEL_5);\n        return AIRPDCAP_RET_REQ_DATA;\n    }\n\n    /* check if data is encrypted (use the WEP bit in the Frame Control field) */\n    if (AIRPDCAP_WEP(data[1])==0) {\n        if (scanHandshake) {\n            /* data is sent in cleartext, check if is an authentication message or end the process */\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapPacketProcess\", \"Unencrypted data\", AIRPDCAP_DEBUG_LEVEL_3);\n            return (AirPDcapScanForKeys(ctx, data, mac_header_len, tot_len, id));\n        }\n        return AIRPDCAP_RET_NO_DATA_ENCRYPTED;\n    } else {\n        PAIRPDCAP_SEC_ASSOCIATION sa;\n        int offset = 0;\n\n        /* get the Security Association structure for the STA and AP */\n        sa = AirPDcapGetSaPtr(ctx, &id);\n        if (sa == NULL){\n            return AIRPDCAP_RET_REQ_DATA;\n        }\n\n        /* cache offset in the packet data (to scan encryption data) */\n        offset = mac_header_len;\n\n        if (decrypt_data==NULL) {\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapPacketProcess\", \"no decrypt buffer, use local\", AIRPDCAP_DEBUG_LEVEL_3);\n            decrypt_data=tmp_data;\n            decrypt_len=&tmp_len;\n        }\n\n        /* create new header and data to modify */\n        *decrypt_len = tot_len;\n        memcpy(decrypt_data, data, *decrypt_len);\n\n        /* encrypted data */\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapPacketProcess\", \"Encrypted data\", AIRPDCAP_DEBUG_LEVEL_3);\n\n        /* check the Extension IV to distinguish between WEP encryption and WPA encryption */\n        /* refer to IEEE 802.11i-2004, 8.2.1.2, pag.35 for WEP,    */\n        /*          IEEE 802.11i-2004, 8.3.2.2, pag. 45 for TKIP,  */\n        /*          IEEE 802.11i-2004, 8.3.3.2, pag. 57 for CCMP   */\n        if (AIRPDCAP_EXTIV(data[offset+3])==0) {\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapPacketProcess\", \"WEP encryption\", AIRPDCAP_DEBUG_LEVEL_3);\n            return AirPDcapWepMng(ctx, decrypt_data, mac_header_len, decrypt_len, key, sa, offset);\n        } else {\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapPacketProcess\", \"TKIP or CCMP encryption\", AIRPDCAP_DEBUG_LEVEL_3);\n\n            /* If index >= 1, then use the group key.  This will not work if the AP is using\n               more than one group key simultaneously.  I've not seen this in practice, however.\n               Usually an AP will rotate between the two key index values of 1 and 2 whenever\n               it needs to change the group key to be used. */\n            if (AIRPDCAP_KEY_INDEX(data[offset+3])>=1){\n\n                AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapPacketProcess\", \"The key index >= 1. This is encrypted with a group key.\", AIRPDCAP_DEBUG_LEVEL_3);\n\n                /* force STA address to broadcast MAC so we load the SA for the groupkey */\n                memcpy(id.sta, broadcast_mac, AIRPDCAP_MAC_LEN);\n\n#ifdef _DEBUG\n                g_snprintf(msgbuf, MSGBUF_LEN, \"ST_MAC: %2X.%2X.%2X.%2X.%2X.%2X\\t\", id.sta[0],id.sta[1],id.sta[2],id.sta[3],id.sta[4],id.sta[5]);\n                AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapPacketProcess\", msgbuf, AIRPDCAP_DEBUG_LEVEL_3);\n#endif\n\n                /* search for a cached Security Association for current BSSID and broadcast MAC */\n                sa = AirPDcapGetSaPtr(ctx, &id);\n                if (sa == NULL)\n                    return AIRPDCAP_RET_REQ_DATA;\n            }\n\n            /* Decrypt the packet using the appropriate SA */\n            if (AirPDcapRsnaMng(decrypt_data, mac_header_len, decrypt_len, key, sa, offset) == AIRPDCAP_RET_SUCCESS) {\n                /* If we successfully decrypted a packet, scan it to see if it contains a key handshake.\n                   The group key handshake could be sent at any time the AP wants to change the key (such as when\n                   it is using key rotation) and it also could be a rekey for the Pairwise key. So we must scan every packet. */\n                if (scanHandshake) {\n                    return (AirPDcapScanForKeys(ctx, decrypt_data, mac_header_len, *decrypt_len, id));\n                } else {\n                    return AIRPDCAP_RET_SUCCESS;\n                }\n            }\n        }\n    }\n    return AIRPDCAP_RET_UNSUCCESS;\n}\n\nINT AirPDcapSetKeys(\n    PAIRPDCAP_CONTEXT ctx,\n    AIRPDCAP_KEY_ITEM keys[],\n    const size_t keys_nr)\n{\n    INT i;\n    INT success;\n    AIRPDCAP_DEBUG_TRACE_START(\"AirPDcapSetKeys\");\n\n    if (ctx==NULL || keys==NULL) {\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapSetKeys\", \"NULL context or NULL keys array\", AIRPDCAP_DEBUG_LEVEL_3);\n        AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapSetKeys\");\n        return 0;\n    }\n\n    if (keys_nr>AIRPDCAP_MAX_KEYS_NR) {\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapSetKeys\", \"Keys number greater than maximum\", AIRPDCAP_DEBUG_LEVEL_3);\n        AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapSetKeys\");\n        return 0;\n    }\n\n    /* clean key and SA collections before setting new ones */\n    AirPDcapInitContext(ctx);\n\n    /* check and insert keys */\n    for (i=0, success=0; i<(INT)keys_nr; i++) {\n        if (AirPDcapValidateKey(keys+i)==TRUE) {\n            if (keys[i].KeyType==AIRPDCAP_KEY_TYPE_WPA_PWD) {\n                AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapSetKeys\", \"Set a WPA-PWD key\", AIRPDCAP_DEBUG_LEVEL_4);\n                AirPDcapRsnaPwd2Psk(keys[i].UserPwd.Passphrase, keys[i].UserPwd.Ssid, keys[i].UserPwd.SsidLen, keys[i].KeyData.Wpa.Psk);\n            }\n#ifdef _DEBUG\n            else if (keys[i].KeyType==AIRPDCAP_KEY_TYPE_WPA_PMK) {\n                AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapSetKeys\", \"Set a WPA-PMK key\", AIRPDCAP_DEBUG_LEVEL_4);\n            } else if (keys[i].KeyType==AIRPDCAP_KEY_TYPE_WEP) {\n                AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapSetKeys\", \"Set a WEP key\", AIRPDCAP_DEBUG_LEVEL_4);\n            } else {\n                AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapSetKeys\", \"Set a key\", AIRPDCAP_DEBUG_LEVEL_4);\n            }\n#endif\n            memcpy(&ctx->keys[success], &keys[i], sizeof(keys[i]));\n            success++;\n        }\n    }\n\n    ctx->keys_nr=success;\n\n    AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapSetKeys\");\n    return success;\n}\n\nstatic void\nAirPDcapCleanKeys(\n    PAIRPDCAP_CONTEXT ctx)\n{\n    AIRPDCAP_DEBUG_TRACE_START(\"AirPDcapCleanKeys\");\n\n    if (ctx==NULL) {\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapCleanKeys\", \"NULL context\", AIRPDCAP_DEBUG_LEVEL_5);\n        AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapCleanKeys\");\n        return;\n    }\n\n    memset(ctx->keys, 0, sizeof(AIRPDCAP_KEY_ITEM) * AIRPDCAP_MAX_KEYS_NR);\n\n    ctx->keys_nr=0;\n\n    AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapCleanKeys\", \"Keys collection cleaned!\", AIRPDCAP_DEBUG_LEVEL_5);\n    AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapCleanKeys\");\n}\n\nstatic void\nAirPDcapRecurseCleanSA(\n    PAIRPDCAP_SEC_ASSOCIATION sa)\n{\n    if (sa->next != NULL) {\n        AirPDcapRecurseCleanSA(sa->next);\n        g_free(sa->next);\n        sa->next = NULL;\n    }\n}\n\nstatic void\nAirPDcapCleanSecAssoc(\n    PAIRPDCAP_CONTEXT ctx)\n{\n    PAIRPDCAP_SEC_ASSOCIATION psa;\n    int i;\n\n    for (psa = ctx->sa, i = 0; i < AIRPDCAP_MAX_SEC_ASSOCIATIONS_NR; i++, psa++) {\n        /* To iterate is human, to recurse, divine */\n        AirPDcapRecurseCleanSA(psa);\n    }\n}\n\nINT AirPDcapGetKeys(\n    const PAIRPDCAP_CONTEXT ctx,\n    AIRPDCAP_KEY_ITEM keys[],\n    const size_t keys_nr)\n{\n    UINT i;\n    UINT j;\n    AIRPDCAP_DEBUG_TRACE_START(\"AirPDcapGetKeys\");\n\n    if (ctx==NULL) {\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapGetKeys\", \"NULL context\", AIRPDCAP_DEBUG_LEVEL_5);\n        AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapGetKeys\");\n        return 0;\n    } else if (keys==NULL) {\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapGetKeys\", \"NULL keys array\", AIRPDCAP_DEBUG_LEVEL_5);\n        AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapGetKeys\");\n        return (INT)ctx->keys_nr;\n    } else {\n        for (i=0, j=0; i<ctx->keys_nr && i<keys_nr && i<AIRPDCAP_MAX_KEYS_NR; i++) {\n            memcpy(&keys[j], &ctx->keys[i], sizeof(keys[j]));\n            j++;\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapGetKeys\", \"Got a key\", AIRPDCAP_DEBUG_LEVEL_5);\n        }\n\n        AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapGetKeys\");\n        return j;\n    }\n}\n\n/*\n * XXX - This won't be reliable if a packet containing SSID \"B\" shows\n * up in the middle of a 4-way handshake for SSID \"A\".\n * We should probably use a small array or hash table to keep multiple\n * SSIDs.\n */\nINT AirPDcapSetLastSSID(\n    PAIRPDCAP_CONTEXT ctx,\n    CHAR *pkt_ssid,\n    size_t pkt_ssid_len)\n{\n    if (!ctx || !pkt_ssid || pkt_ssid_len < 1 || pkt_ssid_len > WPA_SSID_MAX_SIZE)\n        return AIRPDCAP_RET_UNSUCCESS;\n\n    memcpy(ctx->pkt_ssid, pkt_ssid, pkt_ssid_len);\n    ctx->pkt_ssid_len = pkt_ssid_len;\n\n    return AIRPDCAP_RET_SUCCESS;\n}\n\nINT AirPDcapInitContext(\n    PAIRPDCAP_CONTEXT ctx)\n{\n    AIRPDCAP_DEBUG_TRACE_START(\"AirPDcapInitContext\");\n\n    if (ctx==NULL) {\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapInitContext\", \"NULL context\", AIRPDCAP_DEBUG_LEVEL_5);\n        AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapInitContext\");\n        return AIRPDCAP_RET_UNSUCCESS;\n    }\n\n    AirPDcapCleanKeys(ctx);\n\n    ctx->first_free_index=0;\n    ctx->index=-1;\n    ctx->sa_index=-1;\n    ctx->pkt_ssid_len = 0;\n\n    memset(ctx->sa, 0, AIRPDCAP_MAX_SEC_ASSOCIATIONS_NR * sizeof(AIRPDCAP_SEC_ASSOCIATION));\n\n    AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapInitContext\", \"Context initialized!\", AIRPDCAP_DEBUG_LEVEL_5);\n    AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapInitContext\");\n    return AIRPDCAP_RET_SUCCESS;\n}\n\nINT AirPDcapDestroyContext(\n    PAIRPDCAP_CONTEXT ctx)\n{\n    AIRPDCAP_DEBUG_TRACE_START(\"AirPDcapDestroyContext\");\n\n    if (ctx==NULL) {\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapDestroyContext\", \"NULL context\", AIRPDCAP_DEBUG_LEVEL_5);\n        AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapDestroyContext\");\n        return AIRPDCAP_RET_UNSUCCESS;\n    }\n\n    AirPDcapCleanKeys(ctx);\n    AirPDcapCleanSecAssoc(ctx);\n\n    ctx->first_free_index=0;\n    ctx->index=-1;\n    ctx->sa_index=-1;\n\n    AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapDestroyContext\", \"Context destroyed!\", AIRPDCAP_DEBUG_LEVEL_5);\n    AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapDestroyContext\");\n    return AIRPDCAP_RET_SUCCESS;\n}\n\n#ifdef __cplusplus\n}\n#endif\n\n/****************************************************************************/\n\n/****************************************************************************/\n/* Internal function definitions                                         */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nstatic INT\nAirPDcapRsnaMng(\n    UCHAR *decrypt_data,\n    guint mac_header_len,\n    guint *decrypt_len,\n    PAIRPDCAP_KEY_ITEM key,\n    AIRPDCAP_SEC_ASSOCIATION *sa,\n    INT offset)\n{\n    INT ret_value=1;\n    UCHAR *try_data;\n    guint try_data_len = *decrypt_len;\n\n    if (*decrypt_len > try_data_len) {\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsnaMng\", \"Invalid decryption length\", AIRPDCAP_DEBUG_LEVEL_3);\n        return AIRPDCAP_RET_UNSUCCESS;\n    }\n\n    /* allocate a temp buffer for the decryption loop */\n    try_data=(UCHAR *)g_malloc(try_data_len);\n\n    /* start of loop added by GCS */\n    for(/* sa */; sa != NULL ;sa=sa->next) {\n\n       if (sa->validKey==FALSE) {\n           AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsnaMng\", \"Key not yet valid\", AIRPDCAP_DEBUG_LEVEL_3);\n           continue;\n       }\n\n       /* copy the encrypted data into a temp buffer */\n       memcpy(try_data, decrypt_data, *decrypt_len);\n\n       if (sa->wpa.key_ver==1) {\n           /* CCMP -> HMAC-MD5 is the EAPOL-Key MIC, RC4 is the EAPOL-Key encryption algorithm */\n           AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsnaMng\", \"TKIP\", AIRPDCAP_DEBUG_LEVEL_3);\n           DEBUG_DUMP(\"ptk\", sa->wpa.ptk, 64);\n           DEBUG_DUMP(\"ptk portion used\", AIRPDCAP_GET_TK(sa->wpa.ptk), 16);\n\n           ret_value=AirPDcapTkipDecrypt(try_data+offset, *decrypt_len-offset, try_data+AIRPDCAP_TA_OFFSET, AIRPDCAP_GET_TK(sa->wpa.ptk));\n           if (ret_value){\n               AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsnaMng\", \"TKIP failed!\", AIRPDCAP_DEBUG_LEVEL_3);\n               continue;\n           }\n\n           AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsnaMng\", \"TKIP DECRYPTED!!!\", AIRPDCAP_DEBUG_LEVEL_3);\n           /* remove MIC (8bytes) and ICV (4bytes) from the end of packet */\n           *decrypt_len-=12;\n           break;\n       } else {\n           /* AES-CCMP -> HMAC-SHA1-128 is the EAPOL-Key MIC, AES wep_key wrap is the EAPOL-Key encryption algorithm */\n           AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsnaMng\", \"CCMP\", AIRPDCAP_DEBUG_LEVEL_3);\n\n           ret_value=AirPDcapCcmpDecrypt(try_data, mac_header_len, (INT)*decrypt_len, AIRPDCAP_GET_TK(sa->wpa.ptk));\n           if (ret_value)\n              continue;\n\n           AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsnaMng\", \"CCMP DECRYPTED!!!\", AIRPDCAP_DEBUG_LEVEL_3);\n           /* remove MIC (8bytes) from the end of packet */\n           *decrypt_len-=8;\n           break;\n       }\n    }\n    /* end of loop */\n\n    /* none of the keys worked */\n    if(sa == NULL) {\n        g_free(try_data);\n        return ret_value;\n    }\n\n    if (*decrypt_len > try_data_len || *decrypt_len < 8) {\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsnaMng\", \"Invalid decryption length\", AIRPDCAP_DEBUG_LEVEL_3);\n        g_free(try_data);\n        return AIRPDCAP_RET_UNSUCCESS;\n    }\n\n    /* copy the decrypted data into the decrypt buffer GCS*/\n    memcpy(decrypt_data, try_data, *decrypt_len);\n    g_free(try_data);\n\n    /* remove protection bit */\n    decrypt_data[1]&=0xBF;\n\n    /* remove TKIP/CCMP header */\n    offset = mac_header_len;\n    *decrypt_len-=8;\n    memmove(decrypt_data+offset, decrypt_data+offset+8, *decrypt_len-offset);\n\n    if (key!=NULL) {\n        if (sa->key!=NULL)\n            memcpy(key, sa->key, sizeof(AIRPDCAP_KEY_ITEM));\n        else\n            memset(key, 0, sizeof(AIRPDCAP_KEY_ITEM));\n        memcpy(key->KeyData.Wpa.Ptk, sa->wpa.ptk, AIRPDCAP_WPA_PTK_LEN); /* copy the PTK to the key structure for future use by wireshark */\n        if (sa->wpa.key_ver==AIRPDCAP_WPA_KEY_VER_NOT_CCMP)\n            key->KeyType=AIRPDCAP_KEY_TYPE_TKIP;\n        else if (sa->wpa.key_ver==AIRPDCAP_WPA_KEY_VER_AES_CCMP)\n            key->KeyType=AIRPDCAP_KEY_TYPE_CCMP;\n    }\n\n    return AIRPDCAP_RET_SUCCESS;\n}\n\nstatic INT\nAirPDcapWepMng(\n    PAIRPDCAP_CONTEXT ctx,\n    UCHAR *decrypt_data,\n    guint mac_header_len,\n    guint *decrypt_len,\n    PAIRPDCAP_KEY_ITEM key,\n    AIRPDCAP_SEC_ASSOCIATION *sa,\n    INT offset)\n{\n    UCHAR wep_key[AIRPDCAP_WEP_KEY_MAXLEN+AIRPDCAP_WEP_IVLEN];\n    size_t keylen;\n    INT ret_value=1;\n    INT key_index;\n    AIRPDCAP_KEY_ITEM *tmp_key;\n    UINT8 useCache=FALSE;\n    UCHAR *try_data;\n    guint try_data_len = *decrypt_len;\n\n    try_data = (UCHAR *)g_malloc(try_data_len);\n\n    if (sa->key!=NULL)\n        useCache=TRUE;\n\n    for (key_index=0; key_index<(INT)ctx->keys_nr; key_index++) {\n        /* use the cached one, or try all keys */\n        if (!useCache) {\n            tmp_key=&ctx->keys[key_index];\n        } else {\n            if (sa->key!=NULL && sa->key->KeyType==AIRPDCAP_KEY_TYPE_WEP) {\n                AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapWepMng\", \"Try cached WEP key...\", AIRPDCAP_DEBUG_LEVEL_3);\n                tmp_key=sa->key;\n            } else {\n                AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapWepMng\", \"Cached key is not valid, try another WEP key...\", AIRPDCAP_DEBUG_LEVEL_3);\n                tmp_key=&ctx->keys[key_index];\n            }\n        }\n\n        /* obviously, try only WEP keys... */\n        if (tmp_key->KeyType==AIRPDCAP_KEY_TYPE_WEP) {\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapWepMng\", \"Try WEP key...\", AIRPDCAP_DEBUG_LEVEL_3);\n\n            memset(wep_key, 0, sizeof(wep_key));\n            memcpy(try_data, decrypt_data, *decrypt_len);\n\n            /* Costruct the WEP seed: copy the IV in first 3 bytes and then the WEP key (refer to 802-11i-2004, 8.2.1.4.3, pag. 36) */\n            memcpy(wep_key, try_data+mac_header_len, AIRPDCAP_WEP_IVLEN);\n            keylen=tmp_key->KeyData.Wep.WepKeyLen;\n            memcpy(wep_key+AIRPDCAP_WEP_IVLEN, tmp_key->KeyData.Wep.WepKey, keylen);\n\n            ret_value=AirPDcapWepDecrypt(wep_key,\n                keylen+AIRPDCAP_WEP_IVLEN,\n                try_data + (mac_header_len+AIRPDCAP_WEP_IVLEN+AIRPDCAP_WEP_KIDLEN),\n                *decrypt_len-(mac_header_len+AIRPDCAP_WEP_IVLEN+AIRPDCAP_WEP_KIDLEN+AIRPDCAP_CRC_LEN));\n\n            if (ret_value == AIRPDCAP_RET_SUCCESS)\n                memcpy(decrypt_data, try_data, *decrypt_len);\n        }\n\n        if (!ret_value && tmp_key->KeyType==AIRPDCAP_KEY_TYPE_WEP) {\n            /* the tried key is the correct one, cached in the Security Association */\n\n            sa->key=tmp_key;\n\n            if (key!=NULL) {\n                memcpy(key, sa->key, sizeof(AIRPDCAP_KEY_ITEM));\n                key->KeyType=AIRPDCAP_KEY_TYPE_WEP;\n            }\n\n            break;\n        } else {\n            /* the cached key was not valid, try other keys */\n\n            if (useCache==TRUE) {\n                useCache=FALSE;\n                key_index--;\n            }\n        }\n    }\n\n    g_free(try_data);\n    if (ret_value)\n        return AIRPDCAP_RET_UNSUCCESS;\n\n    AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapWepMng\", \"WEP DECRYPTED!!!\", AIRPDCAP_DEBUG_LEVEL_3);\n\n    /* remove ICV (4bytes) from the end of packet */\n    *decrypt_len-=4;\n\n    if (*decrypt_len < 4) {\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapWepMng\", \"Decryption length too short\", AIRPDCAP_DEBUG_LEVEL_3);\n        return AIRPDCAP_RET_UNSUCCESS;\n    }\n\n    /* remove protection bit */\n    decrypt_data[1]&=0xBF;\n\n    /* remove IC header */\n    offset = mac_header_len;\n    *decrypt_len-=4;\n    memmove(decrypt_data+offset, decrypt_data+offset+AIRPDCAP_WEP_IVLEN+AIRPDCAP_WEP_KIDLEN, *decrypt_len-offset);\n\n    return AIRPDCAP_RET_SUCCESS;\n}\n\n/* Refer to IEEE 802.11i-2004, 8.5.3, pag. 85 */\nstatic INT\nAirPDcapRsna4WHandshake(\n    PAIRPDCAP_CONTEXT ctx,\n    const UCHAR *data,\n    AIRPDCAP_SEC_ASSOCIATION *sa,\n    INT offset,\n    const guint tot_len)\n{\n    AIRPDCAP_KEY_ITEM *tmp_key, *tmp_pkt_key, pkt_key;\n    AIRPDCAP_SEC_ASSOCIATION *tmp_sa;\n    INT key_index;\n    INT ret_value=1;\n    UCHAR useCache=FALSE;\n    UCHAR eapol[AIRPDCAP_EAPOL_MAX_LEN];\n    USHORT eapol_len;\n\n    if (sa->key!=NULL)\n        useCache=TRUE;\n\n    /* a 4-way handshake packet use a Pairwise key type (IEEE 802.11i-2004, pg. 79) */\n    if (AIRPDCAP_EAP_KEY(data[offset+1])!=1) {\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsna4WHandshake\", \"Group/STAKey message (not used)\", AIRPDCAP_DEBUG_LEVEL_5);\n        return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n    }\n\n    /* TODO timeouts? */\n\n    /* TODO consider key-index */\n\n    /* TODO considera Deauthentications */\n\n    AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsna4WHandshake\", \"4-way handshake...\", AIRPDCAP_DEBUG_LEVEL_5);\n\n    /* manage 4-way handshake packets; this step completes the 802.1X authentication process (IEEE 802.11i-2004, pag. 85) */\n\n    /* message 1: Authenticator->Supplicant (Sec=0, Mic=0, Ack=1, Inst=0, Key=1(pairwise), KeyRSC=0, Nonce=ANonce, MIC=0) */\n    if (AIRPDCAP_EAP_INST(data[offset+1])==0 &&\n        AIRPDCAP_EAP_ACK(data[offset+1])==1 &&\n        AIRPDCAP_EAP_MIC(data[offset])==0)\n    {\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsna4WHandshake\", \"4-way handshake message 1\", AIRPDCAP_DEBUG_LEVEL_3);\n\n        /* On reception of Message 1, the Supplicant determines whether the Key Replay Counter field value has been        */\n        /* used before with the current PMKSA. If the Key Replay Counter field value is less than or equal to the current  */\n        /* local value, the Supplicant discards the message.                                                               */\n        /* -> not checked, the Authenticator will be send another Message 1 (hopefully!)                                   */\n\n        /* This saves the sa since we are reauthenticating which will overwrite our current sa GCS*/\n        if( sa->handshake >= 2) {\n            tmp_sa= g_new(AIRPDCAP_SEC_ASSOCIATION, 1);\n            memcpy(tmp_sa, sa, sizeof(AIRPDCAP_SEC_ASSOCIATION));\n            sa->validKey=FALSE;\n            sa->next=tmp_sa;\n        }\n\n        /* save ANonce (from authenticator) to derive the PTK with the SNonce (from the 2 message) */\n        memcpy(sa->wpa.nonce, data+offset+12, 32);\n\n        /* get the Key Descriptor Version (to select algorithm used in decryption -CCMP or TKIP-) */\n        sa->wpa.key_ver=AIRPDCAP_EAP_KEY_DESCR_VER(data[offset+1]);\n\n        sa->handshake=1;\n\n        return AIRPDCAP_RET_SUCCESS_HANDSHAKE;\n    }\n\n    /* message 2|4: Supplicant->Authenticator (Sec=0|1, Mic=1, Ack=0, Inst=0, Key=1(pairwise), KeyRSC=0, Nonce=SNonce|0, MIC=MIC(KCK,EAPOL)) */\n    if (AIRPDCAP_EAP_INST(data[offset+1])==0 &&\n        AIRPDCAP_EAP_ACK(data[offset+1])==0 &&\n        AIRPDCAP_EAP_MIC(data[offset])==1)\n    {\n        /* Check key data length to differentiate between message 2 or 4, same as in epan/dissectors/packet-ieee80211.c */\n        if (pntoh16(data+offset+92)) {\n            /* message 2 */\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsna4WHandshake\", \"4-way handshake message 2\", AIRPDCAP_DEBUG_LEVEL_3);\n\n            /* On reception of Message 2, the Authenticator checks that the key replay counter corresponds to the */\n            /* outstanding Message 1. If not, it silently discards the message.                                   */\n            /* If the calculated MIC does not match the MIC that the Supplicant included in the EAPOL-Key frame,  */\n            /* the Authenticator silently discards Message 2.                                                     */\n            /* -> not checked; the Supplicant will send another message 2 (hopefully!)                            */\n\n            /* now you can derive the PTK */\n            for (key_index=0; key_index<(INT)ctx->keys_nr || useCache; key_index++) {\n                /* use the cached one, or try all keys */\n                if (!useCache) {\n                    AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsna4WHandshake\", \"Try WPA key...\", AIRPDCAP_DEBUG_LEVEL_3);\n                    tmp_key=&ctx->keys[key_index];\n                } else {\n                    /* there is a cached key in the security association, if it's a WPA key try it... */\n                    if (sa->key!=NULL &&\n                        (sa->key->KeyType==AIRPDCAP_KEY_TYPE_WPA_PWD ||\n                         sa->key->KeyType==AIRPDCAP_KEY_TYPE_WPA_PSK ||\n                         sa->key->KeyType==AIRPDCAP_KEY_TYPE_WPA_PMK)) {\n                            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsna4WHandshake\", \"Try cached WPA key...\", AIRPDCAP_DEBUG_LEVEL_3);\n                            tmp_key=sa->key;\n                    } else {\n                        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsna4WHandshake\", \"Cached key is of a wrong type, try WPA key...\", AIRPDCAP_DEBUG_LEVEL_3);\n                        tmp_key=&ctx->keys[key_index];\n                    }\n                }\n\n                /* obviously, try only WPA keys... */\n                if (tmp_key->KeyType==AIRPDCAP_KEY_TYPE_WPA_PWD ||\n                    tmp_key->KeyType==AIRPDCAP_KEY_TYPE_WPA_PSK ||\n                    tmp_key->KeyType==AIRPDCAP_KEY_TYPE_WPA_PMK)\n                {\n                    if (tmp_key->KeyType == AIRPDCAP_KEY_TYPE_WPA_PWD && tmp_key->UserPwd.SsidLen == 0 && ctx->pkt_ssid_len > 0 && ctx->pkt_ssid_len <= AIRPDCAP_WPA_SSID_MAX_LEN) {\n                        /* We have a \"wildcard\" SSID.  Use the one from the packet. */\n                        memcpy(&pkt_key, tmp_key, sizeof(pkt_key));\n                        memcpy(&pkt_key.UserPwd.Ssid, ctx->pkt_ssid, ctx->pkt_ssid_len);\n                         pkt_key.UserPwd.SsidLen = ctx->pkt_ssid_len;\n                        AirPDcapRsnaPwd2Psk(pkt_key.UserPwd.Passphrase, pkt_key.UserPwd.Ssid,\n                            pkt_key.UserPwd.SsidLen, pkt_key.KeyData.Wpa.Psk);\n                        tmp_pkt_key = &pkt_key;\n                    } else {\n                        tmp_pkt_key = tmp_key;\n                    }\n\n                    /* derive the PTK from the BSSID, STA MAC, PMK, SNonce, ANonce */\n                    AirPDcapRsnaPrfX(sa,                            /* authenticator nonce, bssid, station mac */\n                                     tmp_pkt_key->KeyData.Wpa.Psk,      /* PSK == PMK */\n                                     data+offset+12,                /* supplicant nonce */\n                                     512,\n                                     sa->wpa.ptk);\n\n                    /* verify the MIC (compare the MIC in the packet included in this message with a MIC calculated with the PTK) */\n                    eapol_len=pntoh16(data+offset-3)+4;\n                    memcpy(eapol, &data[offset-5], (eapol_len<AIRPDCAP_EAPOL_MAX_LEN?eapol_len:AIRPDCAP_EAPOL_MAX_LEN));\n                    ret_value=AirPDcapRsnaMicCheck(eapol,           /*      eapol frame (header also) */\n                                                   eapol_len,       /*      eapol frame length        */\n                                                   sa->wpa.ptk,     /*      Key Confirmation Key      */\n                                                   AIRPDCAP_EAP_KEY_DESCR_VER(data[offset+1])); /*  EAPOL-Key description version */\n\n                    /* If the MIC is valid, the Authenticator checks that the RSN information element bit-wise matches       */\n                    /* that from the (Re)Association Request message.                                                        */\n                    /*              i) TODO If these are not exactly the same, the Authenticator uses MLME-DEAUTHENTICATE.request */\n                    /* primitive to terminate the association.                                                               */\n                    /*              ii) If they do match bit-wise, the Authenticator constructs Message 3.                   */\n                }\n\n                if (!ret_value &&\n                    (tmp_key->KeyType==AIRPDCAP_KEY_TYPE_WPA_PWD ||\n                    tmp_key->KeyType==AIRPDCAP_KEY_TYPE_WPA_PSK ||\n                    tmp_key->KeyType==AIRPDCAP_KEY_TYPE_WPA_PMK))\n                {\n                    /* the temporary key is the correct one, cached in the Security Association */\n\n                    sa->key=tmp_key;\n                    break;\n                } else {\n                    /* the cached key was not valid, try other keys */\n\n                    if (useCache==TRUE) {\n                        useCache=FALSE;\n                        key_index--;\n                    }\n                }\n            }\n\n            if (ret_value) {\n                AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsna4WHandshake\", \"handshake step failed\", AIRPDCAP_DEBUG_LEVEL_3);\n                return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n            }\n\n            sa->handshake=2;\n            sa->validKey=TRUE; /* we can use the key to decode, even if we have not captured the other eapol packets */\n\n            return AIRPDCAP_RET_SUCCESS_HANDSHAKE;\n        } else {\n        /* message 4 */\n\n            /* TODO \"Note that when the 4-Way Handshake is first used Message 4 is sent in the clear.\" */\n\n            /* TODO check MIC and Replay Counter                                                                     */\n            /* On reception of Message 4, the Authenticator verifies that the Key Replay Counter field value is one  */\n            /* that it used on this 4-Way Handshake; if it is not, it silently discards the message.                 */\n            /* If the calculated MIC does not match the MIC that the Supplicant included in the EAPOL-Key frame, the */\n            /* Authenticator silently discards Message 4.                                                            */\n\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsna4WHandshake\", \"4-way handshake message 4\", AIRPDCAP_DEBUG_LEVEL_3);\n\n            sa->handshake=4;\n\n            return AIRPDCAP_RET_SUCCESS_HANDSHAKE;\n        }\n    }\n\n    /* message 3: Authenticator->Supplicant (Sec=1, Mic=1, Ack=1, Inst=0/1, Key=1(pairwise), KeyRSC=???, Nonce=ANonce, MIC=1) */\n    if (AIRPDCAP_EAP_ACK(data[offset+1])==1 &&\n        AIRPDCAP_EAP_MIC(data[offset])==1)\n    {\n        const EAPOL_RSN_KEY *pEAPKey;\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsna4WHandshake\", \"4-way handshake message 3\", AIRPDCAP_DEBUG_LEVEL_3);\n\n        /* On reception of Message 3, the Supplicant silently discards the message if the Key Replay Counter field     */\n        /* value has already been used or if the ANonce value in Message 3 differs from the ANonce value in Message 1. */\n        /* -> not checked, the Authenticator will send another message 3 (hopefully!)                                  */\n\n        /* TODO check page 88 (RNS) */\n\n        /* If using WPA2 PSK, message 3 will contain an RSN for the group key (GTK KDE).\n           In order to properly support decrypting WPA2-PSK packets, we need to parse this to get the group key. */\n        pEAPKey = (const EAPOL_RSN_KEY *)(&(data[offset-1]));\n        if (pEAPKey->type == AIRPDCAP_RSN_WPA2_KEY_DESCRIPTOR){\n            PAIRPDCAP_SEC_ASSOCIATION broadcast_sa;\n            AIRPDCAP_SEC_ASSOCIATION_ID id;\n\n            /* Get broadcacst SA for the current BSSID */\n            memcpy(id.sta, broadcast_mac, AIRPDCAP_MAC_LEN);\n            memcpy(id.bssid, sa->saId.bssid, AIRPDCAP_MAC_LEN);\n            broadcast_sa = AirPDcapGetSaPtr(ctx, &id);\n\n            if (broadcast_sa == NULL){\n                return AIRPDCAP_RET_REQ_DATA;\n            }\n            return (AirPDcapDecryptWPABroadcastKey(pEAPKey, sa->wpa.ptk+16, broadcast_sa, tot_len-offset+1));\n        }\n    }\n\n    return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n}\n\nstatic INT\nAirPDcapRsnaMicCheck(\n    UCHAR *eapol,\n    USHORT eapol_len,\n    UCHAR KCK[AIRPDCAP_WPA_KCK_LEN],\n    USHORT key_ver)\n{\n    UCHAR mic[AIRPDCAP_WPA_MICKEY_LEN];\n    UCHAR c_mic[20];  /* MIC 16 byte, the HMAC-SHA1 use a buffer of 20 bytes */\n\n    /* copy the MIC from the EAPOL packet */\n    memcpy(mic, eapol+AIRPDCAP_WPA_MICKEY_OFFSET+4, AIRPDCAP_WPA_MICKEY_LEN);\n\n    /* set to 0 the MIC in the EAPOL packet (to calculate the MIC) */\n    memset(eapol+AIRPDCAP_WPA_MICKEY_OFFSET+4, 0, AIRPDCAP_WPA_MICKEY_LEN);\n\n    if (key_ver==AIRPDCAP_WPA_KEY_VER_NOT_CCMP) {\n        /* use HMAC-MD5 for the EAPOL-Key MIC */\n        md5_hmac(eapol, eapol_len, KCK, AIRPDCAP_WPA_KCK_LEN, c_mic);\n    } else if (key_ver==AIRPDCAP_WPA_KEY_VER_AES_CCMP) {\n        /* use HMAC-SHA1-128 for the EAPOL-Key MIC */\n        sha1_hmac(KCK, AIRPDCAP_WPA_KCK_LEN, eapol, eapol_len, c_mic);\n    } else\n        /* key descriptor version not recognized */\n        return AIRPDCAP_RET_UNSUCCESS;\n\n    /* compare calculated MIC with the Key MIC and return result (0 means success) */\n    return memcmp(mic, c_mic, AIRPDCAP_WPA_MICKEY_LEN);\n}\n\nstatic INT\nAirPDcapValidateKey(\n    PAIRPDCAP_KEY_ITEM key)\n{\n    size_t len;\n    UCHAR ret=TRUE;\n    AIRPDCAP_DEBUG_TRACE_START(\"AirPDcapValidateKey\");\n\n    if (key==NULL) {\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapValidateKey\", \"NULL key\", AIRPDCAP_DEBUG_LEVEL_5);\n        AIRPDCAP_DEBUG_TRACE_START(\"AirPDcapValidateKey\");\n        return FALSE;\n    }\n\n    switch (key->KeyType) {\n        case AIRPDCAP_KEY_TYPE_WEP:\n            /* check key size limits */\n            len=key->KeyData.Wep.WepKeyLen;\n            if (len<AIRPDCAP_WEP_KEY_MINLEN || len>AIRPDCAP_WEP_KEY_MAXLEN) {\n                AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapValidateKey\", \"WEP key: key length not accepted\", AIRPDCAP_DEBUG_LEVEL_5);\n                ret=FALSE;\n            }\n            break;\n\n        case AIRPDCAP_KEY_TYPE_WEP_40:\n            /* set the standard length and use a generic WEP key type */\n            key->KeyData.Wep.WepKeyLen=AIRPDCAP_WEP_40_KEY_LEN;\n            key->KeyType=AIRPDCAP_KEY_TYPE_WEP;\n            break;\n\n        case AIRPDCAP_KEY_TYPE_WEP_104:\n            /* set the standard length and use a generic WEP key type */\n            key->KeyData.Wep.WepKeyLen=AIRPDCAP_WEP_104_KEY_LEN;\n            key->KeyType=AIRPDCAP_KEY_TYPE_WEP;\n            break;\n\n        case AIRPDCAP_KEY_TYPE_WPA_PWD:\n            /* check passphrase and SSID size limits */\n            len=strlen(key->UserPwd.Passphrase);\n            if (len<AIRPDCAP_WPA_PASSPHRASE_MIN_LEN || len>AIRPDCAP_WPA_PASSPHRASE_MAX_LEN) {\n                AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapValidateKey\", \"WPA-PWD key: passphrase length not accepted\", AIRPDCAP_DEBUG_LEVEL_5);\n                ret=FALSE;\n            }\n\n            len=key->UserPwd.SsidLen;\n            if (len>AIRPDCAP_WPA_SSID_MAX_LEN) {\n                AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapValidateKey\", \"WPA-PWD key: ssid length not accepted\", AIRPDCAP_DEBUG_LEVEL_5);\n                ret=FALSE;\n            }\n\n            break;\n\n        case AIRPDCAP_KEY_TYPE_WPA_PSK:\n            break;\n\n        case AIRPDCAP_KEY_TYPE_WPA_PMK:\n            break;\n\n        default:\n            ret=FALSE;\n    }\n\n    AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapValidateKey\");\n    return ret;\n}\n\nstatic INT\nAirPDcapGetSa(\n    PAIRPDCAP_CONTEXT ctx,\n    AIRPDCAP_SEC_ASSOCIATION_ID *id)\n{\n    INT sa_index;\n    if (ctx->sa_index!=-1) {\n        /* at least one association was stored                               */\n        /* search for the association from sa_index to 0 (most recent added) */\n        for (sa_index=ctx->sa_index; sa_index>=0; sa_index--) {\n            if (ctx->sa[sa_index].used) {\n                if (memcmp(id, &(ctx->sa[sa_index].saId), sizeof(AIRPDCAP_SEC_ASSOCIATION_ID))==0) {\n                    ctx->index=sa_index;\n                    return sa_index;\n                }\n            }\n        }\n    }\n\n    return -1;\n}\n\nstatic INT\nAirPDcapStoreSa(\n    PAIRPDCAP_CONTEXT ctx,\n    AIRPDCAP_SEC_ASSOCIATION_ID *id)\n{\n    INT last_free;\n    if (ctx->first_free_index>=AIRPDCAP_MAX_SEC_ASSOCIATIONS_NR) {\n        /* there is no empty space available. FAILURE */\n        return -1;\n    }\n    if (ctx->sa[ctx->first_free_index].used) {\n        /* last addition was in the middle of the array (and the first_free_index was just incremented by 1)   */\n        /* search for a free space from the first_free_index to AIRPDCAP_STA_INFOS_NR (to avoid free blocks in */\n        /*              the middle)                                                                            */\n        for (last_free=ctx->first_free_index; last_free<AIRPDCAP_MAX_SEC_ASSOCIATIONS_NR; last_free++)\n            if (!ctx->sa[last_free].used)\n                break;\n\n        if (last_free>=AIRPDCAP_MAX_SEC_ASSOCIATIONS_NR) {\n            /* there is no empty space available. FAILURE */\n            return -1;\n        }\n\n        /* store first free space index */\n        ctx->first_free_index=last_free;\n    }\n\n    /* use this info */\n    ctx->index=ctx->first_free_index;\n\n    /* reset the info structure */\n    memset(ctx->sa+ctx->index, 0, sizeof(AIRPDCAP_SEC_ASSOCIATION));\n\n    ctx->sa[ctx->index].used=1;\n\n    /* set the info structure */\n    memcpy(&(ctx->sa[ctx->index].saId), id, sizeof(AIRPDCAP_SEC_ASSOCIATION_ID));\n\n    /* increment by 1 the first_free_index (heuristic) */\n    ctx->first_free_index++;\n\n    /* set the sa_index if the added index is greater the the sa_index */\n    if (ctx->index > ctx->sa_index)\n        ctx->sa_index=ctx->index;\n\n    return ctx->index;\n}\n\n\nstatic INT\nAirPDcapGetSaAddress(\n    const AIRPDCAP_MAC_FRAME_ADDR4 *frame,\n    AIRPDCAP_SEC_ASSOCIATION_ID *id)\n{\n#ifdef _DEBUG\n#define MSGBUF_LEN 255\n    CHAR msgbuf[MSGBUF_LEN];\n#endif\n\n    if ((AIRPDCAP_TYPE(frame->fc[0])==AIRPDCAP_TYPE_DATA) &&\n        (AIRPDCAP_DS_BITS(frame->fc[1]) == 0) &&\n        (memcmp(frame->addr2, frame->addr3, AIRPDCAP_MAC_LEN) != 0) &&\n        (memcmp(frame->addr1, frame->addr3, AIRPDCAP_MAC_LEN) != 0)) {\n        /* DATA frame with fromDS=0 ToDS=0 and neither RA or SA is BSSID\n           => TDLS traffic. Use highest MAC address for bssid */\n        if (memcmp(frame->addr1, frame->addr2, AIRPDCAP_MAC_LEN) < 0) {\n            memcpy(id->sta, frame->addr1, AIRPDCAP_MAC_LEN);\n            memcpy(id->bssid, frame->addr2, AIRPDCAP_MAC_LEN);\n        } else {\n            memcpy(id->sta, frame->addr2, AIRPDCAP_MAC_LEN);\n            memcpy(id->bssid, frame->addr1, AIRPDCAP_MAC_LEN);\n        }\n    } else {\n        const UCHAR *addr;\n\n        /* Normal Case: SA between STA and AP */\n        if ((addr = AirPDcapGetBssidAddress(frame)) != NULL) {\n            memcpy(id->bssid, addr, AIRPDCAP_MAC_LEN);\n        } else {\n            return AIRPDCAP_RET_UNSUCCESS;\n        }\n\n        if ((addr = AirPDcapGetStaAddress(frame)) != NULL) {\n            memcpy(id->sta, addr, AIRPDCAP_MAC_LEN);\n        } else {\n            return AIRPDCAP_RET_UNSUCCESS;\n        }\n    }\n\n#ifdef _DEBUG\n    g_snprintf(msgbuf, MSGBUF_LEN, \"BSSID_MAC: %02X.%02X.%02X.%02X.%02X.%02X\\t\",\n               id->bssid[0],id->bssid[1],id->bssid[2],id->bssid[3],id->bssid[4],id->bssid[5]);\n    AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapGetSaAddress\", msgbuf, AIRPDCAP_DEBUG_LEVEL_3);\n    g_snprintf(msgbuf, MSGBUF_LEN, \"STA_MAC: %02X.%02X.%02X.%02X.%02X.%02X\\t\",\n               id->sta[0],id->sta[1],id->sta[2],id->sta[3],id->sta[4],id->sta[5]);\n    AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapGetSaAddress\", msgbuf, AIRPDCAP_DEBUG_LEVEL_3);\n#endif\n\n    return AIRPDCAP_RET_SUCCESS;\n}\n\n/*\n * AirPDcapGetBssidAddress() and AirPDcapGetBssidAddress() are used for\n * key caching.  In each case, it's more important to return a value than\n * to return a _correct_ value, so we fudge addresses in some cases, e.g.\n * the BSSID in bridged connections.\n * FromDS    ToDS   Sta      BSSID\n * 0         0      addr1/2  addr3\n * 0         1      addr2    addr1\n * 1         0      addr1    addr2\n * 1         1      addr2    addr1\n */\n\nstatic const UCHAR *\nAirPDcapGetStaAddress(\n    const AIRPDCAP_MAC_FRAME_ADDR4 *frame)\n{\n    switch(AIRPDCAP_DS_BITS(frame->fc[1])) { /* Bit 1 = FromDS, bit 0 = ToDS */\n        case 0:\n            if (memcmp(frame->addr2, frame->addr3, AIRPDCAP_MAC_LEN) == 0)\n                return frame->addr1;\n            else\n                return frame->addr2;\n        case 1:\n            return frame->addr2;\n        case 2:\n            return frame->addr1;\n        case 3:\n            if (memcmp(frame->addr1, frame->addr2, AIRPDCAP_MAC_LEN) < 0)\n                return frame->addr1;\n            else\n                return frame->addr2;\n\n        default:\n            return NULL;\n    }\n}\n\nstatic const UCHAR *\nAirPDcapGetBssidAddress(\n    const AIRPDCAP_MAC_FRAME_ADDR4 *frame)\n{\n    switch(AIRPDCAP_DS_BITS(frame->fc[1])) { /* Bit 1 = FromDS, bit 0 = ToDS */\n        case 0:\n            return frame->addr3;\n        case 1:\n            return frame->addr1;\n        case 2:\n            return frame->addr2;\n        case 3:\n            if (memcmp(frame->addr1, frame->addr2, AIRPDCAP_MAC_LEN) > 0)\n                return frame->addr1;\n            else\n                return frame->addr2;\n\n        default:\n            return NULL;\n    }\n}\n\n/* Function used to derive the PTK. Refer to IEEE 802.11I-2004, pag. 74\n * and IEEE 802.11i-2004, pag. 164 */\nstatic void\nAirPDcapRsnaPrfX(\n    AIRPDCAP_SEC_ASSOCIATION *sa,\n    const UCHAR pmk[32],\n    const UCHAR snonce[32],\n    const INT x,        /*      for TKIP 512, for CCMP 384 */\n    UCHAR *ptk)\n{\n    UINT8 i;\n    UCHAR R[100];\n    INT offset=sizeof(\"Pairwise key expansion\");\n    UCHAR output[80]; /* allow for sha1 overflow. */\n\n    memset(R, 0, 100);\n\n    memcpy(R, \"Pairwise key expansion\", offset);\n\n    /* Min(AA, SPA) || Max(AA, SPA) */\n    if (memcmp(sa->saId.sta, sa->saId.bssid, AIRPDCAP_MAC_LEN) < 0)\n    {\n        memcpy(R + offset, sa->saId.sta, AIRPDCAP_MAC_LEN);\n        memcpy(R + offset+AIRPDCAP_MAC_LEN, sa->saId.bssid, AIRPDCAP_MAC_LEN);\n    }\n    else\n    {\n        memcpy(R + offset, sa->saId.bssid, AIRPDCAP_MAC_LEN);\n        memcpy(R + offset+AIRPDCAP_MAC_LEN, sa->saId.sta, AIRPDCAP_MAC_LEN);\n    }\n\n    offset+=AIRPDCAP_MAC_LEN*2;\n\n    /* Min(ANonce,SNonce) || Max(ANonce,SNonce) */\n    if( memcmp(snonce, sa->wpa.nonce, 32) < 0 )\n    {\n        memcpy(R + offset, snonce, 32);\n        memcpy(R + offset + 32, sa->wpa.nonce, 32);\n    }\n    else\n    {\n        memcpy(R + offset, sa->wpa.nonce, 32);\n        memcpy(R + offset + 32, snonce, 32);\n    }\n\n    offset+=32*2;\n\n    for(i = 0; i < (x+159)/160; i++)\n    {\n        R[offset] = i;\n        sha1_hmac(pmk, 32, R, 100, &output[20 * i]);\n    }\n    memcpy(ptk, output, x/8);\n}\n\n#define MAX_SSID_LENGTH 32 /* maximum SSID length */\n\nstatic INT\nAirPDcapRsnaPwd2PskStep(\n    const guint8 *ppBytes,\n    const guint ppLength,\n    const CHAR *ssid,\n    const size_t ssidLength,\n    const INT iterations,\n    const INT count,\n    UCHAR *output)\n{\n    UCHAR digest[MAX_SSID_LENGTH+4];  /* SSID plus 4 bytes of count */\n    UCHAR digest1[SHA1_DIGEST_LEN];\n    INT i, j;\n\n    if (ssidLength > MAX_SSID_LENGTH) {\n        /* This \"should not happen\" */\n        return AIRPDCAP_RET_UNSUCCESS;\n    }\n\n    memset(digest, 0, sizeof digest);\n    memset(digest1, 0, sizeof digest1);\n\n    /* U1 = PRF(P, S || INT(i)) */\n    memcpy(digest, ssid, ssidLength);\n    digest[ssidLength] = (UCHAR)((count>>24) & 0xff);\n    digest[ssidLength+1] = (UCHAR)((count>>16) & 0xff);\n    digest[ssidLength+2] = (UCHAR)((count>>8) & 0xff);\n    digest[ssidLength+3] = (UCHAR)(count & 0xff);\n    sha1_hmac(ppBytes, ppLength, digest, (guint32) ssidLength+4, digest1);\n\n    /* output = U1 */\n    memcpy(output, digest1, SHA1_DIGEST_LEN);\n    for (i = 1; i < iterations; i++) {\n        /* Un = PRF(P, Un-1) */\n        sha1_hmac(ppBytes, ppLength, digest1, SHA1_DIGEST_LEN, digest);\n\n        memcpy(digest1, digest, SHA1_DIGEST_LEN);\n        /* output = output xor Un */\n        for (j = 0; j < SHA1_DIGEST_LEN; j++) {\n            output[j] ^= digest[j];\n        }\n    }\n\n    return AIRPDCAP_RET_SUCCESS;\n}\n\nstatic INT\nAirPDcapRsnaPwd2Psk(\n    const CHAR *passphrase,\n    const CHAR *ssid,\n    const size_t ssidLength,\n    UCHAR *output)\n{\n    UCHAR m_output[2*SHA1_DIGEST_LEN];\n    GByteArray *pp_ba = g_byte_array_new();\n\n    memset(m_output, 0, 2*SHA1_DIGEST_LEN);\n\n    if (!uri_str_to_bytes(passphrase, pp_ba)) {\n        g_byte_array_free(pp_ba, TRUE);\n        return 0;\n    }\n\n    AirPDcapRsnaPwd2PskStep(pp_ba->data, pp_ba->len, ssid, ssidLength, 4096, 1, m_output);\n    AirPDcapRsnaPwd2PskStep(pp_ba->data, pp_ba->len, ssid, ssidLength, 4096, 2, &m_output[SHA1_DIGEST_LEN]);\n\n    memcpy(output, m_output, AIRPDCAP_WPA_PSK_LEN);\n    g_byte_array_free(pp_ba, TRUE);\n\n    return 0;\n}\n\n/*\n * Returns the decryption_key_t struct given a string describing the key.\n * Returns NULL if the input_string cannot be parsed.\n */\ndecryption_key_t*\nparse_key_string(gchar* input_string, guint8 key_type)\n{\n    gchar *key, *tmp_str;\n    gchar *ssid;\n\n    GString    *key_string = NULL;\n    GByteArray *ssid_ba = NULL, *key_ba;\n    gboolean    res;\n\n    gchar **tokens;\n    guint n = 0;\n    decryption_key_t *dk;\n\n    if(input_string == NULL)\n        return NULL;\n\n    /*\n     * Parse the input_string. WEP and WPA will be just a string\n     * of hexadecimal characters (if key is wrong, null will be\n     * returned...).\n     * WPA-PWD should be in the form\n     * <key data>[:<ssid>]\n     */\n\n    switch(key_type)\n    {\n    case AIRPDCAP_KEY_TYPE_WEP:\n    case AIRPDCAP_KEY_TYPE_WEP_40:\n    case AIRPDCAP_KEY_TYPE_WEP_104:\n\n       key_ba = g_byte_array_new();\n       res = hex_str_to_bytes(input_string, key_ba, FALSE);\n\n       if (res && key_ba->len > 0) {\n           /* Key is correct! It was probably an 'old style' WEP key */\n           /* Create the decryption_key_t structure, fill it and return it*/\n           dk = (decryption_key_t *)g_malloc(sizeof(decryption_key_t));\n\n           dk->type = AIRPDCAP_KEY_TYPE_WEP;\n           /* XXX - The current key handling code in the GUI requires\n            * no separators and lower case */\n           tmp_str = bytes_to_str(NULL, key_ba->data, key_ba->len);\n           dk->key  = g_string_new(tmp_str);\n           g_string_ascii_down(dk->key);\n           dk->bits = key_ba->len * 8;\n           dk->ssid = NULL;\n\n           wmem_free(NULL, tmp_str);\n           g_byte_array_free(key_ba, TRUE);\n           return dk;\n       }\n\n       /* Key doesn't work */\n       g_byte_array_free(key_ba, TRUE);\n       return NULL;\n\n    case AIRPDCAP_KEY_TYPE_WPA_PWD:\n\n        tokens = g_strsplit(input_string,\":\",0);\n\n        /* Tokens is a null termiated array of strings ... */\n        while(tokens[n] != NULL)\n            n++;\n\n        if(n < 1)\n        {\n            /* Free the array of strings */\n            g_strfreev(tokens);\n            return NULL;\n        }\n\n        /*\n         * The first token is the key\n         */\n        key = g_strdup(tokens[0]);\n\n        ssid = NULL;\n        /* Maybe there is a second token (an ssid, if everything else is ok) */\n        if(n >= 2)\n        {\n           ssid = g_strdup(tokens[1]);\n        }\n\n        /* Create a new string */\n        key_string = g_string_new(key);\n        ssid_ba = NULL;\n\n        /* Two (or more) tokens mean that the user entered a WPA-PWD key ... */\n        if( ((key_string->len) > WPA_KEY_MAX_CHAR_SIZE) || ((key_string->len) < WPA_KEY_MIN_CHAR_SIZE))\n        {\n            g_string_free(key_string, TRUE);\n\n            g_free(key);\n            g_free(ssid);\n\n            /* Free the array of strings */\n            g_strfreev(tokens);\n            return NULL;\n        }\n\n        if(ssid != NULL) /* more than two tokens found, means that the user specified the ssid */\n        {\n            ssid_ba = g_byte_array_new();\n            if (! uri_str_to_bytes(ssid, ssid_ba)) {\n                g_string_free(key_string, TRUE);\n                g_byte_array_free(ssid_ba, TRUE);\n                g_free(key);\n                g_free(ssid);\n                /* Free the array of strings */\n                g_strfreev(tokens);\n                return NULL;\n            }\n\n            if(ssid_ba->len > WPA_SSID_MAX_CHAR_SIZE)\n            {\n                g_string_free(key_string, TRUE);\n                g_byte_array_free(ssid_ba, TRUE);\n\n                g_free(key);\n                g_free(ssid);\n\n                /* Free the array of strings */\n                g_strfreev(tokens);\n                return NULL;\n            }\n        }\n\n        /* Key was correct!!! Create the new decryption_key_t ... */\n        dk = (decryption_key_t*)g_malloc(sizeof(decryption_key_t));\n\n        dk->type = AIRPDCAP_KEY_TYPE_WPA_PWD;\n        dk->key  = g_string_new(key);\n        dk->bits = 256; /* This is the length of the array pf bytes that will be generated using key+ssid ...*/\n        dk->ssid = byte_array_dup(ssid_ba); /* NULL if ssid_ba is NULL */\n\n        g_string_free(key_string, TRUE);\n        if (ssid_ba != NULL)\n            g_byte_array_free(ssid_ba, TRUE);\n\n        g_free(key);\n        if(ssid != NULL)\n            g_free(ssid);\n\n        /* Free the array of strings */\n        g_strfreev(tokens);\n        return dk;\n\n    case AIRPDCAP_KEY_TYPE_WPA_PSK:\n\n        key_ba = g_byte_array_new();\n        res = hex_str_to_bytes(input_string, key_ba, FALSE);\n\n        /* Two tokens means that the user should have entered a WPA-BIN key ... */\n        if(!res || ((key_ba->len) != WPA_PSK_KEY_SIZE))\n        {\n            g_byte_array_free(key_ba, TRUE);\n\n            /* No ssid has been created ... */\n            return NULL;\n        }\n\n        /* Key was correct!!! Create the new decryption_key_t ... */\n        dk = (decryption_key_t*)g_malloc(sizeof(decryption_key_t));\n\n        dk->type = AIRPDCAP_KEY_TYPE_WPA_PSK;\n        dk->key  = g_string_new(input_string);\n        dk->bits = (guint) dk->key->len * 4;\n        dk->ssid = NULL;\n\n        g_byte_array_free(key_ba, TRUE);\n        return dk;\n    }\n\n    /* Type not supported */\n    return NULL;\n}\n\nvoid\nfree_key_string(decryption_key_t *dk)\n{\n    if (dk->key)\n        g_string_free(dk->key, TRUE);\n    if (dk->ssid)\n        g_byte_array_free(dk->ssid, TRUE);\n    g_free(dk);\n}\n\n/*\n * Returns a newly allocated string representing the given decryption_key_t\n * struct, or NULL if something is wrong...\n */\ngchar*\nget_key_string(decryption_key_t* dk)\n{\n    gchar* output_string = NULL;\n\n    if(dk == NULL || dk->key == NULL)\n        return NULL;\n\n    switch(dk->type) {\n        case AIRPDCAP_KEY_TYPE_WEP:\n            output_string = g_strdup(dk->key->str);\n            break;\n        case AIRPDCAP_KEY_TYPE_WPA_PWD:\n            if(dk->ssid == NULL)\n                output_string = g_strdup(dk->key->str);\n            else\n                output_string = g_strdup_printf(\"%s:%s\",\n                    dk->key->str, format_uri(dk->ssid, \":\"));\n            break;\n        case AIRPDCAP_KEY_TYPE_WPA_PMK:\n            output_string = g_strdup(dk->key->str);\n            break;\n        default:\n            return NULL;\n    }\n\n    return output_string;\n}\n\nstatic INT\nAirPDcapTDLSDeriveKey(\n    PAIRPDCAP_SEC_ASSOCIATION sa,\n    const guint8 *data,\n    guint offset_rsne,\n    guint offset_fte,\n    guint offset_timeout,\n    guint offset_link,\n    guint8 action)\n{\n\n    sha256_hmac_context sha_ctx;\n    aes_cmac_ctx aes_ctx;\n    const guint8 *snonce, *anonce, *initiator, *responder, *bssid;\n    guint8 key_input[SHA256_DIGEST_LEN];\n    guint8 mic[16], iter[2], length[2], seq_num = action + 1;\n\n    /* Get key input */\n    anonce = &data[offset_fte + 20];\n    snonce = &data[offset_fte + 52];\n    sha256_starts(&(sha_ctx.ctx));\n    if (memcmp(anonce, snonce, AIRPDCAP_WPA_NONCE_LEN) < 0) {\n        sha256_update(&(sha_ctx.ctx), anonce, AIRPDCAP_WPA_NONCE_LEN);\n        sha256_update(&(sha_ctx.ctx), snonce, AIRPDCAP_WPA_NONCE_LEN);\n    } else {\n        sha256_update(&(sha_ctx.ctx), snonce, AIRPDCAP_WPA_NONCE_LEN);\n        sha256_update(&(sha_ctx.ctx), anonce, AIRPDCAP_WPA_NONCE_LEN);\n    }\n    sha256_finish(&(sha_ctx.ctx), key_input);\n\n    /* Derive key */\n    bssid = &data[offset_link + 2];\n    initiator = &data[offset_link + 8];\n    responder = &data[offset_link + 14];\n    sha256_hmac_starts(&sha_ctx, key_input, SHA256_DIGEST_LEN);\n    iter[0] = 1;\n    iter[1] = 0;\n    sha256_hmac_update(&sha_ctx, (const guint8 *)&iter, 2);\n    sha256_hmac_update(&sha_ctx, \"TDLS PMK\", 8);\n    if (memcmp(initiator, responder, AIRPDCAP_MAC_LEN) < 0) {\n        sha256_hmac_update(&sha_ctx, initiator, AIRPDCAP_MAC_LEN);\n        sha256_hmac_update(&sha_ctx, responder, AIRPDCAP_MAC_LEN);\n    } else {\n        sha256_hmac_update(&sha_ctx, responder, AIRPDCAP_MAC_LEN);\n        sha256_hmac_update(&sha_ctx, initiator, AIRPDCAP_MAC_LEN);\n    }\n    sha256_hmac_update(&sha_ctx, bssid, AIRPDCAP_MAC_LEN);\n    length[0] = 256 & 0xff;\n    length[1] = (256 >> 8) & 0xff;\n    sha256_hmac_update(&sha_ctx, (const guint8 *)&length, 2);\n    sha256_hmac_finish(&sha_ctx, key_input);\n\n    /* Check MIC */\n    aes_cmac_encrypt_starts(&aes_ctx, key_input, 16);\n    aes_cmac_encrypt_update(&aes_ctx, initiator, AIRPDCAP_MAC_LEN);\n    aes_cmac_encrypt_update(&aes_ctx, responder, AIRPDCAP_MAC_LEN);\n    aes_cmac_encrypt_update(&aes_ctx, &seq_num, 1);\n    aes_cmac_encrypt_update(&aes_ctx, &data[offset_link], data[offset_link + 1] + 2);\n    aes_cmac_encrypt_update(&aes_ctx, &data[offset_rsne], data[offset_rsne + 1] + 2);\n    aes_cmac_encrypt_update(&aes_ctx, &data[offset_timeout], data[offset_timeout + 1] + 2);\n    aes_cmac_encrypt_update(&aes_ctx, &data[offset_fte], 4);\n    memset(mic, 0, 16);\n    aes_cmac_encrypt_update(&aes_ctx, mic, 16);\n    aes_cmac_encrypt_update(&aes_ctx, &data[offset_fte + 20], data[offset_fte + 1] + 2 - 20);\n    aes_cmac_encrypt_finish(&aes_ctx, mic);\n\n    if (memcmp(mic, &data[offset_fte + 4],16)) {\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapTDLSDeriveKey\", \"MIC verification failed\", AIRPDCAP_DEBUG_LEVEL_3);\n        return AIRPDCAP_RET_UNSUCCESS;\n    }\n\n    memcpy(AIRPDCAP_GET_TK(sa->wpa.ptk), &key_input[16], 16);\n    memcpy(sa->wpa.nonce, snonce, AIRPDCAP_WPA_NONCE_LEN);\n    sa->validKey = TRUE;\n    sa->wpa.key_ver = AIRPDCAP_WPA_KEY_VER_AES_CCMP;\n    AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapTDLSDeriveKey\", \"MIC verified\", AIRPDCAP_DEBUG_LEVEL_3);\n    return  AIRPDCAP_RET_SUCCESS;\n}\n\n\n#ifdef __cplusplus\n}\n#endif\n\n/****************************************************************************/\n\n/*\n * Editor modelines\n *\n * Local Variables:\n * c-basic-offset: 4\n * tab-width: 8\n * indent-tabs-mode: nil\n * End:\n *\n * ex: set shiftwidth=4 tabstop=8 expandtab:\n * :indentSize=4:tabSize=8:noTabs=true:\n */\n", "code_before": "/* airpdcap.c\n *\n * Copyright (c) 2006 CACE Technologies, Davis (California)\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the project nor the names of its contributors\n *    may be used to endorse or promote products derived from this software\n *    without specific prior written permission.\n *\n * Alternatively, this software may be distributed under the terms of the\n * GNU General Public License (\"GPL\") version 2 as published by the Free\n * Software Foundation.\n *\n * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n\n/*\n * The files matching airpcap*.[ch] were originally developed as part of\n * Wireshark's support for AirPcap adapters. However, they've been used\n * for general 802.11 decryption for quite some time. It might make sense\n * to rename them accordingly.\n */\n\n/****************************************************************************/\n/*      File includes                                                       */\n\n#include \"config.h\"\n\n#include <glib.h>\n\n#include <wsutil/wsgcrypt.h>\n#include <wsutil/crc32.h>\n#include <wsutil/pint.h>\n\n#include <epan/tvbuff.h>\n#include <epan/to_str.h>\n#include <epan/strutil.h>\n#include <epan/crypt/airpdcap_rijndael.h>\n\n#include \"airpdcap_system.h\"\n#include \"airpdcap_int.h\"\n\n#include \"airpdcap_debug.h\"\n\n#include \"wep-wpadefs.h\"\n\n\n/****************************************************************************/\n\n/****************************************************************************/\n/*      Constant definitions                                                    */\n\n/*      EAPOL definitions                                                       */\n/**\n * Length of the EAPOL-Key key confirmation key (KCK) used to calculate\n * MIC over EAPOL frame and validate an EAPOL packet (128 bits)\n */\n#define AIRPDCAP_WPA_KCK_LEN    16\n/**\n *Offset of the Key MIC in the EAPOL packet body\n */\n#define AIRPDCAP_WPA_MICKEY_OFFSET      77\n/**\n * Maximum length of the EAPOL packet (it depends on the maximum MAC\n * frame size)\n */\n#define AIRPDCAP_WPA_MAX_EAPOL_LEN      4095\n/**\n * EAPOL Key Descriptor Version 1, used for all EAPOL-Key frames to and\n * from a STA when neither the group nor pairwise ciphers are CCMP for\n * Key Descriptor 1.\n * @note\n * Defined in 802.11i-2004, page 78\n */\n#define AIRPDCAP_WPA_KEY_VER_NOT_CCMP   1\n/**\n * EAPOL Key Descriptor Version 2, used for all EAPOL-Key frames to and\n * from a STA when either the pairwise or the group cipher is AES-CCMP\n * for Key Descriptor 2.\n * /note\n * Defined in 802.11i-2004, page 78\n */\n#define AIRPDCAP_WPA_KEY_VER_AES_CCMP   2\n\n/** Define EAPOL Key Descriptor type values:  use 254 for WPA and 2 for WPA2 **/\n#define AIRPDCAP_RSN_WPA_KEY_DESCRIPTOR 254\n#define AIRPDCAP_RSN_WPA2_KEY_DESCRIPTOR 2\n\n/****************************************************************************/\n\n\n\n/****************************************************************************/\n/*      Macro definitions                                                       */\n\nextern const UINT32 crc32_table[256];\n#define CRC(crc, ch)     (crc = (crc >> 8) ^ crc32_table[(crc ^ (ch)) & 0xff])\n\n#define AIRPDCAP_GET_TK(ptk)    (ptk + 32)\n\n/****************************************************************************/\n\n/****************************************************************************/\n/*      Type definitions                                                        */\n\n/*      Internal function prototype declarations                                */\n\n#ifdef  __cplusplus\nextern \"C\" {\n#endif\n\n/**\n * It is a step of the PBKDF2 (specifically the PKCS #5 v2.0) defined in\n * the RFC 2898 to derive a key (used as PMK in WPA)\n * @param ppbytes [IN] pointer to a password (sequence of between 8 and\n * 63 ASCII encoded characters)\n * @param ssid [IN] pointer to the SSID string encoded in max 32 ASCII\n * encoded characters\n * @param iterations [IN] times to hash the password (4096 for WPA)\n * @param count [IN] ???\n * @param output [OUT] pointer to a preallocated buffer of\n * SHA1_DIGEST_LEN characters that will contain a part of the key\n */\nstatic INT AirPDcapRsnaPwd2PskStep(\n    const guint8 *ppbytes,\n    const guint passLength,\n    const CHAR *ssid,\n    const size_t ssidLength,\n    const INT iterations,\n    const INT count,\n    UCHAR *output)\n    ;\n\n/**\n * It calculates the passphrase-to-PSK mapping reccomanded for use with\n * RSNAs. This implementation uses the PBKDF2 method defined in the RFC\n * 2898.\n * @param passphrase [IN] pointer to a password (sequence of between 8 and\n * 63 ASCII encoded characters)\n * @param ssid [IN] pointer to the SSID string encoded in max 32 ASCII\n * encoded characters\n * @param output [OUT] calculated PSK (to use as PMK in WPA)\n * @note\n * Described in 802.11i-2004, page 165\n */\nstatic INT AirPDcapRsnaPwd2Psk(\n    const CHAR *passphrase,\n    const CHAR *ssid,\n    const size_t ssidLength,\n    UCHAR *output)\n    ;\n\nstatic INT AirPDcapRsnaMng(\n    UCHAR *decrypt_data,\n    guint mac_header_len,\n    guint *decrypt_len,\n    PAIRPDCAP_KEY_ITEM key,\n    AIRPDCAP_SEC_ASSOCIATION *sa,\n    INT offset)\n    ;\n\nstatic INT AirPDcapWepMng(\n    PAIRPDCAP_CONTEXT ctx,\n    UCHAR *decrypt_data,\n    guint mac_header_len,\n    guint *decrypt_len,\n    PAIRPDCAP_KEY_ITEM key,\n    AIRPDCAP_SEC_ASSOCIATION *sa,\n    INT offset)\n    ;\n\nstatic INT AirPDcapRsna4WHandshake(\n    PAIRPDCAP_CONTEXT ctx,\n    const UCHAR *data,\n    AIRPDCAP_SEC_ASSOCIATION *sa,\n    INT offset,\n    const guint tot_len)\n    ;\n/**\n * It checks whether the specified key is corrected or not.\n * @note\n * For a standard WEP key the length will be changed to the standard\n * length, and the type changed in a generic WEP key.\n * @param key [IN] pointer to the key to validate\n * @return\n * - TRUE: the key contains valid fields and values\n * - FALSE: the key has some invalid field or value\n */\nstatic INT AirPDcapValidateKey(\n    PAIRPDCAP_KEY_ITEM key)\n    ;\n\nstatic INT AirPDcapRsnaMicCheck(\n    UCHAR *eapol,\n    USHORT eapol_len,\n    UCHAR KCK[AIRPDCAP_WPA_KCK_LEN],\n    USHORT key_ver)\n    ;\n\n/**\n * @param ctx [IN] pointer to the current context\n * @param id [IN] id of the association (composed by BSSID and MAC of\n * the station)\n * @return\n * - index of the Security Association structure if found\n * - -1, if the specified addresses pair BSSID-STA MAC has not been found\n */\nstatic INT AirPDcapGetSa(\n    PAIRPDCAP_CONTEXT ctx,\n    AIRPDCAP_SEC_ASSOCIATION_ID *id)\n    ;\n\nstatic INT AirPDcapStoreSa(\n    PAIRPDCAP_CONTEXT ctx,\n    AIRPDCAP_SEC_ASSOCIATION_ID *id)\n    ;\n\nstatic INT AirPDcapGetSaAddress(\n    const AIRPDCAP_MAC_FRAME_ADDR4 *frame,\n    AIRPDCAP_SEC_ASSOCIATION_ID *id)\n    ;\n\nstatic const UCHAR * AirPDcapGetStaAddress(\n    const AIRPDCAP_MAC_FRAME_ADDR4 *frame)\n    ;\n\nstatic const UCHAR * AirPDcapGetBssidAddress(\n    const AIRPDCAP_MAC_FRAME_ADDR4 *frame)\n    ;\n\nstatic void AirPDcapRsnaPrfX(\n    AIRPDCAP_SEC_ASSOCIATION *sa,\n    const UCHAR pmk[32],\n    const UCHAR snonce[32],\n    const INT x,        /*      for TKIP 512, for CCMP 384      */\n    UCHAR *ptk)\n    ;\n\n\n/**\n * @param sa  [IN/OUT] pointer to SA that will hold the key\n * @param data [IN] Frame\n * @param offset_rsne [IN] RSNE IE offset in the frame\n * @param offset_fte [IN] Fast BSS Transition IE offset in the frame\n * @param offset_timeout [IN] Timeout Interval IE offset in the frame\n * @param offset_link [IN] Link Identifier IE offset in the frame\n * @param action [IN] Tdls Action code (response or confirm)\n *\n * @return\n *  AIRPDCAP_RET_SUCCESS if Key has been sucessfully derived (and MIC verified)\n *  AIRPDCAP_RET_UNSUCCESS otherwise\n */\nstatic INT\nAirPDcapTDLSDeriveKey(\n    PAIRPDCAP_SEC_ASSOCIATION sa,\n    const guint8 *data,\n    guint offset_rsne,\n    guint offset_fte,\n    guint offset_timeout,\n    guint offset_link,\n    guint8 action)\n    ;\n#ifdef  __cplusplus\n}\n#endif\n\n/****************************************************************************/\n\n/****************************************************************************/\n/* Exported function definitions                                                */\n\n#ifdef  __cplusplus\nextern \"C\" {\n#endif\n\nconst guint8 broadcast_mac[] = { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF };\n\n#define EAPKEY_MIC_LEN  16  /* length of the MIC key for EAPoL_Key packet's MIC using MD5 */\n#define NONCE_LEN 32\n\n#define TKIP_GROUP_KEY_LEN 32\n#define CCMP_GROUP_KEY_LEN 16\n\ntypedef struct {\n    guint8  type;\n    guint8  key_information[2];  /* Make this an array to avoid alignment issues */\n    guint8  key_length[2];  /* Make this an array to avoid alignment issues */\n    guint8  replay_counter[8];\n    guint8  key_nonce[NONCE_LEN];\n    guint8  key_iv[16];\n    guint8  key_sequence_counter[8];  /* also called the RSC */\n    guint8  key_id[8];\n    guint8  key_mic[EAPKEY_MIC_LEN];\n    guint8  key_data_len[2];  /* Make this an array rather than a U16 to avoid alignment shifting */\n} EAPOL_RSN_KEY,  * P_EAPOL_RSN_KEY;\n\n/* Minimum possible key data size (at least one GTK KDE with CCMP key) */\n#define GROUP_KEY_MIN_LEN 8 + CCMP_GROUP_KEY_LEN\n/* Minimum possible group key msg size (group key msg using CCMP as cipher)*/\n#define GROUP_KEY_PAYLOAD_LEN_MIN sizeof(EAPOL_RSN_KEY) + GROUP_KEY_MIN_LEN\n\n/* XXX - what if this doesn't get the key? */\nstatic INT\nAirPDcapDecryptWPABroadcastKey(const EAPOL_RSN_KEY *pEAPKey, guint8 *decryption_key, PAIRPDCAP_SEC_ASSOCIATION sa, guint eapol_len)\n{\n    guint8 key_version;\n    const guint8 *key_data;\n    guint8  *szEncryptedKey;\n    guint16 key_bytes_len = 0; /* Length of the total key data field */\n    guint16 key_len;           /* Actual group key length */\n    static AIRPDCAP_KEY_ITEM dummy_key; /* needed in case AirPDcapRsnaMng() wants the key structure */\n    AIRPDCAP_SEC_ASSOCIATION *tmp_sa;\n\n    /* We skip verifying the MIC of the key. If we were implementing a WPA supplicant we'd want to verify, but for a sniffer it's not needed. */\n\n    /* Preparation for decrypting the group key -  determine group key data length */\n    /* depending on whether the pairwise key is TKIP or AES encryption key */\n    key_version = AIRPDCAP_EAP_KEY_DESCR_VER(pEAPKey->key_information[1]);\n    if (key_version == AIRPDCAP_WPA_KEY_VER_NOT_CCMP){\n        /* TKIP */\n        key_bytes_len = pntoh16(pEAPKey->key_length);\n    }else if (key_version == AIRPDCAP_WPA_KEY_VER_AES_CCMP){\n        /* AES */\n        key_bytes_len = pntoh16(pEAPKey->key_data_len);\n\n        /* AES keys must be at least 128 bits = 16 bytes. */\n        if (key_bytes_len < 16) {\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n        }\n    }\n\n    if ((key_bytes_len < GROUP_KEY_MIN_LEN) ||\n        (eapol_len < sizeof(EAPOL_RSN_KEY)) ||\n        (key_bytes_len > eapol_len - sizeof(EAPOL_RSN_KEY))) {\n        return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n    }\n\n    /* Encrypted key is in the information element field of the EAPOL key packet */\n    key_data = (const guint8 *)pEAPKey + sizeof(EAPOL_RSN_KEY);\n    szEncryptedKey = (guint8 *)g_memdup(key_data, key_bytes_len);\n\n    DEBUG_DUMP(\"Encrypted Broadcast key:\", szEncryptedKey, key_bytes_len);\n    DEBUG_DUMP(\"KeyIV:\", pEAPKey->key_iv, 16);\n    DEBUG_DUMP(\"decryption_key:\", decryption_key, 16);\n\n    /* We are rekeying, save old sa */\n    tmp_sa=(AIRPDCAP_SEC_ASSOCIATION *)g_malloc(sizeof(AIRPDCAP_SEC_ASSOCIATION));\n    memcpy(tmp_sa, sa, sizeof(AIRPDCAP_SEC_ASSOCIATION));\n    sa->next=tmp_sa;\n\n    /* As we have no concept of the prior association request at this point, we need to deduce the     */\n    /* group key cipher from the length of the key bytes. In WPA this is straightforward as the        */\n    /* keybytes just contain the GTK, and the GTK is only in the group handshake, NOT the M3.          */\n    /* In WPA2 its a little more tricky as the M3 keybytes contain an RSN_IE, but the group handshake  */\n    /* does not. Also there are other (variable length) items in the keybytes which we need to account */\n    /* for to determine the true key length, and thus the group cipher.                                */\n\n    if (key_version == AIRPDCAP_WPA_KEY_VER_NOT_CCMP){\n        guint8 new_key[32];\n        guint8 dummy[256] = { 0 };\n        /* TKIP key */\n        /* Per 802.11i, Draft 3.0 spec, section 8.5.2, p. 97, line 4-8, */\n        /* group key is decrypted using RC4.  Concatenate the IV with the 16 byte EK (PTK+16) to get the decryption key */\n\n        gcry_cipher_hd_t  rc4_handle;\n\n        /* The WPA group key just contains the GTK bytes so deducing the type is straightforward   */\n        /* Note - WPA M3 doesn't contain a group key so we'll only be here for the group handshake */\n        sa->wpa.key_ver = (key_bytes_len >=TKIP_GROUP_KEY_LEN)?AIRPDCAP_WPA_KEY_VER_NOT_CCMP:AIRPDCAP_WPA_KEY_VER_AES_CCMP;\n\n        /* Build the full decryption key based on the IV and part of the pairwise key */\n        memcpy(new_key, pEAPKey->key_iv, 16);\n        memcpy(new_key+16, decryption_key, 16);\n        DEBUG_DUMP(\"FullDecrKey:\", new_key, 32);\n\n        if (gcry_cipher_open (&rc4_handle, GCRY_CIPHER_ARCFOUR, GCRY_CIPHER_MODE_STREAM, 0)) {\n          return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n        }\n        if (gcry_cipher_setkey(rc4_handle, new_key, sizeof(new_key))) {\n          gcry_cipher_close(rc4_handle);\n          return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n        }\n\n        /* Do dummy 256 iterations of the RC4 algorithm (per 802.11i, Draft 3.0, p. 97 line 6) */\n        gcry_cipher_decrypt(rc4_handle, dummy, 256, NULL, 0);\n        gcry_cipher_decrypt(rc4_handle, szEncryptedKey, key_bytes_len, NULL, 0);\n        gcry_cipher_close(rc4_handle);\n\n    } else if (key_version == AIRPDCAP_WPA_KEY_VER_AES_CCMP){\n        /* AES CCMP key */\n\n        guint8 key_found;\n        guint8 key_length;\n        guint16 key_index;\n        guint8 *decrypted_data;\n\n        /* Unwrap the key; the result is key_bytes_len in length */\n        decrypted_data = AES_unwrap(decryption_key, 16, szEncryptedKey,  key_bytes_len);\n\n        /* With WPA2 what we get after Broadcast Key decryption is an actual RSN structure.\n           The key itself is stored as a GTK KDE\n           WPA2 IE (1 byte) id = 0xdd, length (1 byte), GTK OUI (4 bytes), key index (1 byte) and 1 reserved byte. Thus we have to\n           pass pointer to the actual key with 8 bytes offset */\n\n        key_found = FALSE;\n        key_index = 0;\n\n        /* Parse Key data until we found GTK KDE */\n        /* GTK KDE = 00-0F-AC 01 */\n        while(key_index < (key_bytes_len - 6) && !key_found){\n            guint8 rsn_id;\n            guint32 type;\n\n            /* Get RSN ID */\n            rsn_id = decrypted_data[key_index];\n            type = ((decrypted_data[key_index + 2] << 24) +\n                    (decrypted_data[key_index + 3] << 16) +\n                    (decrypted_data[key_index + 4] << 8) +\n                     (decrypted_data[key_index + 5]));\n\n            if (rsn_id == 0xdd && type == 0x000fac01) {\n                key_found = TRUE;\n            } else {\n                key_index += decrypted_data[key_index+1]+2;\n            }\n        }\n\n        if (key_found){\n            if (decrypted_data[key_index+1] <= 6) {\n                g_free(decrypted_data);\n                g_free(szEncryptedKey);\n                return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n            }\n            key_length = decrypted_data[key_index+1] - 6;\n\n            if (key_index+8 >= key_bytes_len ||\n                key_length > key_bytes_len - key_index - 8) {\n                g_free(decrypted_data);\n                g_free(szEncryptedKey);\n                return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n            }\n\n            /* Skip over the GTK header info, and don't copy past the end of the encrypted data */\n            memcpy(szEncryptedKey, decrypted_data+key_index+8, key_length);\n        } else {\n            g_free(decrypted_data);\n            g_free(szEncryptedKey);\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n        }\n\n        if (key_length == TKIP_GROUP_KEY_LEN)\n            sa->wpa.key_ver = AIRPDCAP_WPA_KEY_VER_NOT_CCMP;\n        else\n            sa->wpa.key_ver = AIRPDCAP_WPA_KEY_VER_AES_CCMP;\n\n        g_free(decrypted_data);\n    }\n\n    key_len = (sa->wpa.key_ver==AIRPDCAP_WPA_KEY_VER_NOT_CCMP)?TKIP_GROUP_KEY_LEN:CCMP_GROUP_KEY_LEN;\n    if (key_len > key_bytes_len) {\n        /* the key required for this protocol is longer than the key that we just calculated */\n        g_free(szEncryptedKey);\n        return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n    }\n\n    /* Decrypted key is now in szEncryptedKey with len of key_len */\n    DEBUG_DUMP(\"Broadcast key:\", szEncryptedKey, key_len);\n\n    /* Load the proper key material info into the SA */\n    sa->key = &dummy_key;  /* we just need key to be not null because it is checked in AirPDcapRsnaMng().  The WPA key materials are actually in the .wpa structure */\n    sa->validKey = TRUE;\n\n    /* Since this is a GTK and its size is only 32 bytes (vs. the 64 byte size of a PTK), we fake it and put it in at a 32-byte offset so the  */\n    /* AirPDcapRsnaMng() function will extract the right piece of the GTK for decryption. (The first 16 bytes of the GTK are used for decryption.) */\n    memset(sa->wpa.ptk, 0, sizeof(sa->wpa.ptk));\n    memcpy(sa->wpa.ptk+32, szEncryptedKey, key_len);\n    g_free(szEncryptedKey);\n    return AIRPDCAP_RET_SUCCESS_HANDSHAKE;\n}\n\n\n/* Return a pointer the the requested SA. If it doesn't exist create it. */\nstatic PAIRPDCAP_SEC_ASSOCIATION\nAirPDcapGetSaPtr(\n    PAIRPDCAP_CONTEXT ctx,\n    AIRPDCAP_SEC_ASSOCIATION_ID *id)\n{\n    int sa_index;\n\n    /* search for a cached Security Association for supplied BSSID and STA MAC  */\n    if ((sa_index=AirPDcapGetSa(ctx, id))==-1) {\n        /* create a new Security Association if it doesn't currently exist      */\n        if ((sa_index=AirPDcapStoreSa(ctx, id))==-1) {\n            return NULL;\n        }\n    }\n    /* get the Security Association structure   */\n    return &ctx->sa[sa_index];\n}\n\nstatic INT AirPDcapScanForKeys(\n    PAIRPDCAP_CONTEXT ctx,\n    const guint8 *data,\n    const guint mac_header_len,\n    const guint tot_len,\n    AIRPDCAP_SEC_ASSOCIATION_ID id\n)\n{\n    const UCHAR *addr;\n    guint bodyLength;\n    PAIRPDCAP_SEC_ASSOCIATION sta_sa;\n    PAIRPDCAP_SEC_ASSOCIATION sa;\n    guint offset = 0;\n    const guint8 dot1x_header[] = {\n        0xAA,             /* DSAP=SNAP */\n        0xAA,             /* SSAP=SNAP */\n        0x03,             /* Control field=Unnumbered frame */\n        0x00, 0x00, 0x00, /* Org. code=encaps. Ethernet */\n        0x88, 0x8E        /* Type: 802.1X authentication */\n    };\n    const guint8 bt_dot1x_header[] = {\n        0xAA,             /* DSAP=SNAP */\n        0xAA,             /* SSAP=SNAP */\n        0x03,             /* Control field=Unnumbered frame */\n        0x00, 0x19, 0x58, /* Org. code=Bluetooth SIG */\n        0x00, 0x03        /* Type: Bluetooth Security */\n    };\n    const guint8 tdls_header[] = {\n        0xAA,             /* DSAP=SNAP */\n        0xAA,             /* SSAP=SNAP */\n        0x03,             /* Control field=Unnumbered frame */\n        0x00, 0x00, 0x00, /* Org. code=encaps. Ethernet */\n        0x89, 0x0D,       /* Type: 802.11 - Fast Roaming Remote Request */\n        0x02,             /* Payload Type: TDLS */\n        0X0C              /* Action Category: TDLS */\n    };\n\n    const EAPOL_RSN_KEY *pEAPKey;\n#ifdef AIRPDCAP_DEBUG\n#define MSGBUF_LEN 255\n    CHAR msgbuf[MSGBUF_LEN];\n#endif\n    AIRPDCAP_DEBUG_TRACE_START(\"AirPDcapScanForKeys\");\n\n    /* cache offset in the packet data */\n    offset = mac_header_len;\n\n    /* check if the packet has an LLC header and the packet is 802.1X authentication (IEEE 802.1X-2004, pg. 24) */\n    if (memcmp(data+offset, dot1x_header, 8) == 0 || memcmp(data+offset, bt_dot1x_header, 8) == 0) {\n\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Authentication: EAPOL packet\", AIRPDCAP_DEBUG_LEVEL_3);\n\n        /* skip LLC header */\n        offset+=8;\n\n        /* check if the packet is a EAPOL-Key (0x03) (IEEE 802.1X-2004, pg. 25) */\n        if (data[offset+1]!=3) {\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Not EAPOL-Key\", AIRPDCAP_DEBUG_LEVEL_3);\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n        }\n\n        /* get and check the body length (IEEE 802.1X-2004, pg. 25) */\n        bodyLength=pntoh16(data+offset+2);\n        if (((tot_len-offset-4) < bodyLength) || (bodyLength < sizeof(EAPOL_RSN_KEY))) { /* Only check if frame is long enough for eapol header, ignore tailing garbage, see bug 9065 */\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"EAPOL body too short\", AIRPDCAP_DEBUG_LEVEL_3);\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n        }\n\n        /* skip EAPOL MPDU and go to the first byte of the body */\n        offset+=4;\n\n        pEAPKey = (const EAPOL_RSN_KEY *) (data+offset);\n\n        /* check if the key descriptor type is valid (IEEE 802.1X-2004, pg. 27) */\n        if (/*pEAPKey->type!=0x1 &&*/ /* RC4 Key Descriptor Type (deprecated) */\n            pEAPKey->type != AIRPDCAP_RSN_WPA2_KEY_DESCRIPTOR &&             /* IEEE 802.11 Key Descriptor Type  (WPA2) */\n            pEAPKey->type != AIRPDCAP_RSN_WPA_KEY_DESCRIPTOR)           /* 254 = RSN_KEY_DESCRIPTOR - WPA,              */\n        {\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Not valid key descriptor type\", AIRPDCAP_DEBUG_LEVEL_3);\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n        }\n\n        /* start with descriptor body */\n        offset+=1;\n\n        /* search for a cached Security Association for current BSSID and AP */\n        sa = AirPDcapGetSaPtr(ctx, &id);\n        if (sa == NULL){\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"No SA for BSSID found\", AIRPDCAP_DEBUG_LEVEL_3);\n            return AIRPDCAP_RET_REQ_DATA;\n        }\n\n        /* It could be a Pairwise Key exchange, check */\n        if (AirPDcapRsna4WHandshake(ctx, data, sa, offset, tot_len) == AIRPDCAP_RET_SUCCESS_HANDSHAKE)\n            return AIRPDCAP_RET_SUCCESS_HANDSHAKE;\n\n        if (mac_header_len + GROUP_KEY_PAYLOAD_LEN_MIN > tot_len) {\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Message too short for Group Key\", AIRPDCAP_DEBUG_LEVEL_3);\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n        }\n\n        /* Verify the bitfields: Key = 0(groupwise) Mic = 1 Ack = 1 Secure = 1 */\n        if (AIRPDCAP_EAP_KEY(data[offset+1])!=0 ||\n            AIRPDCAP_EAP_ACK(data[offset+1])!=1 ||\n            AIRPDCAP_EAP_MIC(data[offset]) != 1 ||\n            AIRPDCAP_EAP_SEC(data[offset]) != 1){\n\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Key bitfields not correct for Group Key\", AIRPDCAP_DEBUG_LEVEL_3);\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n        }\n\n        /* force STA address to be the broadcast MAC so we create an SA for the groupkey */\n        memcpy(id.sta, broadcast_mac, AIRPDCAP_MAC_LEN);\n\n        /* get the Security Association structure for the broadcast MAC and AP */\n        sa = AirPDcapGetSaPtr(ctx, &id);\n        if (sa == NULL){\n            return AIRPDCAP_RET_REQ_DATA;\n        }\n\n        /* Get the SA for the STA, since we need its pairwise key to decrpyt the group key */\n\n        /* get STA address */\n        if ( (addr=AirPDcapGetStaAddress((const AIRPDCAP_MAC_FRAME_ADDR4 *)(data))) != NULL) {\n            memcpy(id.sta, addr, AIRPDCAP_MAC_LEN);\n#ifdef AIRPDCAP_DEBUG\n            g_snprintf(msgbuf, MSGBUF_LEN, \"ST_MAC: %2X.%2X.%2X.%2X.%2X.%2X\\t\", id.sta[0],id.sta[1],id.sta[2],id.sta[3],id.sta[4],id.sta[5]);\n#endif\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", msgbuf, AIRPDCAP_DEBUG_LEVEL_3);\n        } else {\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"SA not found\", AIRPDCAP_DEBUG_LEVEL_5);\n            return AIRPDCAP_RET_REQ_DATA;\n        }\n\n        sta_sa = AirPDcapGetSaPtr(ctx, &id);\n        if (sta_sa == NULL){\n            return AIRPDCAP_RET_REQ_DATA;\n        }\n\n        /* Try to extract the group key and install it in the SA */\n        return (AirPDcapDecryptWPABroadcastKey(pEAPKey, sta_sa->wpa.ptk+16, sa, tot_len-offset+1));\n\n    } else if (memcmp(data+offset, tdls_header, 10) == 0) {\n        const guint8 *initiator, *responder;\n        guint8 action;\n        guint status, offset_rsne = 0, offset_fte = 0, offset_link = 0, offset_timeout = 0;\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Authentication: TDLS Action Frame\", AIRPDCAP_DEBUG_LEVEL_3);\n\n        /* skip LLC header */\n        offset+=10;\n\n        /* check if the packet is a TDLS response or confirm */\n        action = data[offset];\n        if (action!=1 && action!=2) {\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Not Response nor confirm\", AIRPDCAP_DEBUG_LEVEL_3);\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n        }\n\n        /* check status */\n        offset++;\n        status=pntoh16(data+offset);\n        if (status!=0) {\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"TDLS setup not successfull\", AIRPDCAP_DEBUG_LEVEL_3);\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n        }\n\n        /* skip Token + capabilities */\n        offset+=5;\n\n        /* search for RSN, Fast BSS Transition, Link Identifier and Timeout Interval IEs */\n\n        while(offset < (tot_len - 2)) {\n            if (data[offset] == 48) {\n                offset_rsne = offset;\n            } else if (data[offset] == 55) {\n                offset_fte = offset;\n            } else if (data[offset] == 56) {\n                offset_timeout = offset;\n            } else if (data[offset] == 101) {\n                offset_link = offset;\n            }\n\n            if (tot_len < offset + data[offset + 1] + 2) {\n                return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n            }\n            offset += data[offset + 1] + 2;\n        }\n\n        if (offset_rsne == 0 || offset_fte == 0 ||\n            offset_timeout == 0 || offset_link == 0)\n        {\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Cannot Find all necessary IEs\", AIRPDCAP_DEBUG_LEVEL_3);\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n        }\n\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Found RSNE/Fast BSS/Timeout Interval/Link IEs\", AIRPDCAP_DEBUG_LEVEL_3);\n\n        /* Will create a Security Association between 2 STA. Need to get both MAC address */\n        initiator = &data[offset_link + 8];\n        responder = &data[offset_link + 14];\n\n        if (memcmp(initiator, responder, AIRPDCAP_MAC_LEN) < 0) {\n            memcpy(id.sta, initiator, AIRPDCAP_MAC_LEN);\n            memcpy(id.bssid, responder, AIRPDCAP_MAC_LEN);\n        } else {\n            memcpy(id.sta, responder, AIRPDCAP_MAC_LEN);\n            memcpy(id.bssid, initiator, AIRPDCAP_MAC_LEN);\n        }\n\n        sa = AirPDcapGetSaPtr(ctx, &id);\n        if (sa == NULL){\n            return AIRPDCAP_RET_REQ_DATA;\n        }\n\n        if (sa->validKey) {\n            if (memcmp(sa->wpa.nonce, data + offset_fte + 52, AIRPDCAP_WPA_NONCE_LEN) == 0) {\n                /* Already have valid key for this SA, no need to redo key derivation */\n                return AIRPDCAP_RET_SUCCESS_HANDSHAKE;\n            } else {\n                /* We are opening a new session with the same two STA, save previous sa  */\n                AIRPDCAP_SEC_ASSOCIATION *tmp_sa = g_new(AIRPDCAP_SEC_ASSOCIATION, 1);\n                memcpy(tmp_sa, sa, sizeof(AIRPDCAP_SEC_ASSOCIATION));\n                sa->next=tmp_sa;\n                sa->validKey = FALSE;\n            }\n        }\n\n        if (AirPDcapTDLSDeriveKey(sa, data, offset_rsne, offset_fte, offset_timeout, offset_link, action)\n            == AIRPDCAP_RET_SUCCESS) {\n            AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapScanForKeys\");\n            return AIRPDCAP_RET_SUCCESS_HANDSHAKE;\n        }\n    } else {\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Skipping: not an EAPOL packet\", AIRPDCAP_DEBUG_LEVEL_3);\n    }\n\n    AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapScanForKeys\");\n    return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n}\n\n\nINT AirPDcapPacketProcess(\n    PAIRPDCAP_CONTEXT ctx,\n    const guint8 *data,\n    const guint mac_header_len,\n    const guint tot_len,\n    UCHAR *decrypt_data,\n    guint *decrypt_len,\n    PAIRPDCAP_KEY_ITEM key,\n    gboolean scanHandshake)\n{\n    AIRPDCAP_SEC_ASSOCIATION_ID id;\n    UCHAR tmp_data[AIRPDCAP_MAX_CAPLEN];\n    guint tmp_len;\n\n#ifdef AIRPDCAP_DEBUG\n#define MSGBUF_LEN 255\n    CHAR msgbuf[MSGBUF_LEN];\n#endif\n\n    AIRPDCAP_DEBUG_TRACE_START(\"AirPDcapPacketProcess\");\n\n    if (ctx==NULL) {\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapPacketProcess\", \"NULL context\", AIRPDCAP_DEBUG_LEVEL_5);\n        AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapPacketProcess\");\n        return AIRPDCAP_RET_REQ_DATA;\n    }\n    if (data==NULL || tot_len==0) {\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapPacketProcess\", \"NULL data or length=0\", AIRPDCAP_DEBUG_LEVEL_5);\n        AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapPacketProcess\");\n        return AIRPDCAP_RET_REQ_DATA;\n    }\n\n    /* check if the packet is of data or robust managment type */\n    if (!((AIRPDCAP_TYPE(data[0])==AIRPDCAP_TYPE_DATA) ||\n          (AIRPDCAP_TYPE(data[0])==AIRPDCAP_TYPE_MANAGEMENT &&\n           (AIRPDCAP_SUBTYPE(data[0])==AIRPDCAP_SUBTYPE_DISASS ||\n            AIRPDCAP_SUBTYPE(data[0])==AIRPDCAP_SUBTYPE_DEAUTHENTICATION ||\n            AIRPDCAP_SUBTYPE(data[0])==AIRPDCAP_SUBTYPE_ACTION)))) {\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapPacketProcess\", \"not data nor robust mgmt packet\", AIRPDCAP_DEBUG_LEVEL_5);\n        return AIRPDCAP_RET_NO_DATA;\n    }\n\n    /* check correct packet size, to avoid wrong elaboration of encryption algorithms */\n    if (tot_len < (UINT)(mac_header_len+AIRPDCAP_CRYPTED_DATA_MINLEN)) {\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapPacketProcess\", \"minimum length violated\", AIRPDCAP_DEBUG_LEVEL_5);\n        return AIRPDCAP_RET_WRONG_DATA_SIZE;\n    }\n\n    /* Assume that the decrypt_data field is at least this size. */\n    if (tot_len > AIRPDCAP_MAX_CAPLEN) {\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapPacketProcess\", \"length too large\", AIRPDCAP_DEBUG_LEVEL_3);\n        return AIRPDCAP_RET_UNSUCCESS;\n    }\n\n    /* get STA/BSSID address */\n    if (AirPDcapGetSaAddress((const AIRPDCAP_MAC_FRAME_ADDR4 *)(data), &id) != AIRPDCAP_RET_SUCCESS) {\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapPacketProcess\", \"STA/BSSID not found\", AIRPDCAP_DEBUG_LEVEL_5);\n        return AIRPDCAP_RET_REQ_DATA;\n    }\n\n    /* check if data is encrypted (use the WEP bit in the Frame Control field) */\n    if (AIRPDCAP_WEP(data[1])==0) {\n        if (scanHandshake) {\n            /* data is sent in cleartext, check if is an authentication message or end the process */\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapPacketProcess\", \"Unencrypted data\", AIRPDCAP_DEBUG_LEVEL_3);\n            return (AirPDcapScanForKeys(ctx, data, mac_header_len, tot_len, id));\n        }\n        return AIRPDCAP_RET_NO_DATA_ENCRYPTED;\n    } else {\n        PAIRPDCAP_SEC_ASSOCIATION sa;\n        int offset = 0;\n\n        /* get the Security Association structure for the STA and AP */\n        sa = AirPDcapGetSaPtr(ctx, &id);\n        if (sa == NULL){\n            return AIRPDCAP_RET_REQ_DATA;\n        }\n\n        /* cache offset in the packet data (to scan encryption data) */\n        offset = mac_header_len;\n\n        if (decrypt_data==NULL) {\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapPacketProcess\", \"no decrypt buffer, use local\", AIRPDCAP_DEBUG_LEVEL_3);\n            decrypt_data=tmp_data;\n            decrypt_len=&tmp_len;\n        }\n\n        /* create new header and data to modify */\n        *decrypt_len = tot_len;\n        memcpy(decrypt_data, data, *decrypt_len);\n\n        /* encrypted data */\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapPacketProcess\", \"Encrypted data\", AIRPDCAP_DEBUG_LEVEL_3);\n\n        /* check the Extension IV to distinguish between WEP encryption and WPA encryption */\n        /* refer to IEEE 802.11i-2004, 8.2.1.2, pag.35 for WEP,    */\n        /*          IEEE 802.11i-2004, 8.3.2.2, pag. 45 for TKIP,  */\n        /*          IEEE 802.11i-2004, 8.3.3.2, pag. 57 for CCMP   */\n        if (AIRPDCAP_EXTIV(data[offset+3])==0) {\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapPacketProcess\", \"WEP encryption\", AIRPDCAP_DEBUG_LEVEL_3);\n            return AirPDcapWepMng(ctx, decrypt_data, mac_header_len, decrypt_len, key, sa, offset);\n        } else {\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapPacketProcess\", \"TKIP or CCMP encryption\", AIRPDCAP_DEBUG_LEVEL_3);\n\n            /* If index >= 1, then use the group key.  This will not work if the AP is using\n               more than one group key simultaneously.  I've not seen this in practice, however.\n               Usually an AP will rotate between the two key index values of 1 and 2 whenever\n               it needs to change the group key to be used. */\n            if (AIRPDCAP_KEY_INDEX(data[offset+3])>=1){\n\n                AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapPacketProcess\", \"The key index >= 1. This is encrypted with a group key.\", AIRPDCAP_DEBUG_LEVEL_3);\n\n                /* force STA address to broadcast MAC so we load the SA for the groupkey */\n                memcpy(id.sta, broadcast_mac, AIRPDCAP_MAC_LEN);\n\n#ifdef AIRPDCAP_DEBUG\n                g_snprintf(msgbuf, MSGBUF_LEN, \"ST_MAC: %2X.%2X.%2X.%2X.%2X.%2X\\t\", id.sta[0],id.sta[1],id.sta[2],id.sta[3],id.sta[4],id.sta[5]);\n                AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapPacketProcess\", msgbuf, AIRPDCAP_DEBUG_LEVEL_3);\n#endif\n\n                /* search for a cached Security Association for current BSSID and broadcast MAC */\n                sa = AirPDcapGetSaPtr(ctx, &id);\n                if (sa == NULL)\n                    return AIRPDCAP_RET_REQ_DATA;\n            }\n\n            /* Decrypt the packet using the appropriate SA */\n            if (AirPDcapRsnaMng(decrypt_data, mac_header_len, decrypt_len, key, sa, offset) == AIRPDCAP_RET_SUCCESS) {\n                /* If we successfully decrypted a packet, scan it to see if it contains a key handshake.\n                   The group key handshake could be sent at any time the AP wants to change the key (such as when\n                   it is using key rotation) and it also could be a rekey for the Pairwise key. So we must scan every packet. */\n                if (scanHandshake) {\n                    return (AirPDcapScanForKeys(ctx, decrypt_data, mac_header_len, *decrypt_len, id));\n                } else {\n                    return AIRPDCAP_RET_SUCCESS;\n                }\n            }\n        }\n    }\n    return AIRPDCAP_RET_UNSUCCESS;\n}\n\nINT AirPDcapSetKeys(\n    PAIRPDCAP_CONTEXT ctx,\n    AIRPDCAP_KEY_ITEM keys[],\n    const size_t keys_nr)\n{\n    INT i;\n    INT success;\n    AIRPDCAP_DEBUG_TRACE_START(\"AirPDcapSetKeys\");\n\n    if (ctx==NULL || keys==NULL) {\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapSetKeys\", \"NULL context or NULL keys array\", AIRPDCAP_DEBUG_LEVEL_3);\n        AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapSetKeys\");\n        return 0;\n    }\n\n    if (keys_nr>AIRPDCAP_MAX_KEYS_NR) {\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapSetKeys\", \"Keys number greater than maximum\", AIRPDCAP_DEBUG_LEVEL_3);\n        AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapSetKeys\");\n        return 0;\n    }\n\n    /* clean key and SA collections before setting new ones */\n    AirPDcapInitContext(ctx);\n\n    /* check and insert keys */\n    for (i=0, success=0; i<(INT)keys_nr; i++) {\n        if (AirPDcapValidateKey(keys+i)==TRUE) {\n            if (keys[i].KeyType==AIRPDCAP_KEY_TYPE_WPA_PWD) {\n                AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapSetKeys\", \"Set a WPA-PWD key\", AIRPDCAP_DEBUG_LEVEL_4);\n                AirPDcapRsnaPwd2Psk(keys[i].UserPwd.Passphrase, keys[i].UserPwd.Ssid, keys[i].UserPwd.SsidLen, keys[i].KeyData.Wpa.Psk);\n            }\n#ifdef AIRPDCAP_DEBUG\n            else if (keys[i].KeyType==AIRPDCAP_KEY_TYPE_WPA_PMK) {\n                AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapSetKeys\", \"Set a WPA-PMK key\", AIRPDCAP_DEBUG_LEVEL_4);\n            } else if (keys[i].KeyType==AIRPDCAP_KEY_TYPE_WEP) {\n                AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapSetKeys\", \"Set a WEP key\", AIRPDCAP_DEBUG_LEVEL_4);\n            } else {\n                AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapSetKeys\", \"Set a key\", AIRPDCAP_DEBUG_LEVEL_4);\n            }\n#endif\n            memcpy(&ctx->keys[success], &keys[i], sizeof(keys[i]));\n            success++;\n        }\n    }\n\n    ctx->keys_nr=success;\n\n    AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapSetKeys\");\n    return success;\n}\n\nstatic void\nAirPDcapCleanKeys(\n    PAIRPDCAP_CONTEXT ctx)\n{\n    AIRPDCAP_DEBUG_TRACE_START(\"AirPDcapCleanKeys\");\n\n    if (ctx==NULL) {\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapCleanKeys\", \"NULL context\", AIRPDCAP_DEBUG_LEVEL_5);\n        AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapCleanKeys\");\n        return;\n    }\n\n    memset(ctx->keys, 0, sizeof(AIRPDCAP_KEY_ITEM) * AIRPDCAP_MAX_KEYS_NR);\n\n    ctx->keys_nr=0;\n\n    AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapCleanKeys\", \"Keys collection cleaned!\", AIRPDCAP_DEBUG_LEVEL_5);\n    AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapCleanKeys\");\n}\n\nstatic void\nAirPDcapRecurseCleanSA(\n    PAIRPDCAP_SEC_ASSOCIATION sa)\n{\n    if (sa->next != NULL) {\n        AirPDcapRecurseCleanSA(sa->next);\n        g_free(sa->next);\n        sa->next = NULL;\n    }\n}\n\nstatic void\nAirPDcapCleanSecAssoc(\n    PAIRPDCAP_CONTEXT ctx)\n{\n    PAIRPDCAP_SEC_ASSOCIATION psa;\n    int i;\n\n    for (psa = ctx->sa, i = 0; i < AIRPDCAP_MAX_SEC_ASSOCIATIONS_NR; i++, psa++) {\n        /* To iterate is human, to recurse, divine */\n        AirPDcapRecurseCleanSA(psa);\n    }\n}\n\nINT AirPDcapGetKeys(\n    const PAIRPDCAP_CONTEXT ctx,\n    AIRPDCAP_KEY_ITEM keys[],\n    const size_t keys_nr)\n{\n    UINT i;\n    UINT j;\n    AIRPDCAP_DEBUG_TRACE_START(\"AirPDcapGetKeys\");\n\n    if (ctx==NULL) {\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapGetKeys\", \"NULL context\", AIRPDCAP_DEBUG_LEVEL_5);\n        AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapGetKeys\");\n        return 0;\n    } else if (keys==NULL) {\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapGetKeys\", \"NULL keys array\", AIRPDCAP_DEBUG_LEVEL_5);\n        AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapGetKeys\");\n        return (INT)ctx->keys_nr;\n    } else {\n        for (i=0, j=0; i<ctx->keys_nr && i<keys_nr && i<AIRPDCAP_MAX_KEYS_NR; i++) {\n            memcpy(&keys[j], &ctx->keys[i], sizeof(keys[j]));\n            j++;\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapGetKeys\", \"Got a key\", AIRPDCAP_DEBUG_LEVEL_5);\n        }\n\n        AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapGetKeys\");\n        return j;\n    }\n}\n\n/*\n * XXX - This won't be reliable if a packet containing SSID \"B\" shows\n * up in the middle of a 4-way handshake for SSID \"A\".\n * We should probably use a small array or hash table to keep multiple\n * SSIDs.\n */\nINT AirPDcapSetLastSSID(\n    PAIRPDCAP_CONTEXT ctx,\n    CHAR *pkt_ssid,\n    size_t pkt_ssid_len)\n{\n    if (!ctx || !pkt_ssid || pkt_ssid_len < 1 || pkt_ssid_len > WPA_SSID_MAX_SIZE)\n        return AIRPDCAP_RET_UNSUCCESS;\n\n    memcpy(ctx->pkt_ssid, pkt_ssid, pkt_ssid_len);\n    ctx->pkt_ssid_len = pkt_ssid_len;\n\n    return AIRPDCAP_RET_SUCCESS;\n}\n\nINT AirPDcapInitContext(\n    PAIRPDCAP_CONTEXT ctx)\n{\n    AIRPDCAP_DEBUG_TRACE_START(\"AirPDcapInitContext\");\n\n    if (ctx==NULL) {\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapInitContext\", \"NULL context\", AIRPDCAP_DEBUG_LEVEL_5);\n        AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapInitContext\");\n        return AIRPDCAP_RET_UNSUCCESS;\n    }\n\n    AirPDcapCleanKeys(ctx);\n\n    ctx->first_free_index=0;\n    ctx->index=-1;\n    ctx->sa_index=-1;\n    ctx->pkt_ssid_len = 0;\n\n    memset(ctx->sa, 0, AIRPDCAP_MAX_SEC_ASSOCIATIONS_NR * sizeof(AIRPDCAP_SEC_ASSOCIATION));\n\n    AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapInitContext\", \"Context initialized!\", AIRPDCAP_DEBUG_LEVEL_5);\n    AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapInitContext\");\n    return AIRPDCAP_RET_SUCCESS;\n}\n\nINT AirPDcapDestroyContext(\n    PAIRPDCAP_CONTEXT ctx)\n{\n    AIRPDCAP_DEBUG_TRACE_START(\"AirPDcapDestroyContext\");\n\n    if (ctx==NULL) {\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapDestroyContext\", \"NULL context\", AIRPDCAP_DEBUG_LEVEL_5);\n        AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapDestroyContext\");\n        return AIRPDCAP_RET_UNSUCCESS;\n    }\n\n    AirPDcapCleanKeys(ctx);\n    AirPDcapCleanSecAssoc(ctx);\n\n    ctx->first_free_index=0;\n    ctx->index=-1;\n    ctx->sa_index=-1;\n\n    AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapDestroyContext\", \"Context destroyed!\", AIRPDCAP_DEBUG_LEVEL_5);\n    AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapDestroyContext\");\n    return AIRPDCAP_RET_SUCCESS;\n}\n\n#ifdef __cplusplus\n}\n#endif\n\n/****************************************************************************/\n\n/****************************************************************************/\n/* Internal function definitions                                         */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nstatic INT\nAirPDcapRsnaMng(\n    UCHAR *decrypt_data,\n    guint mac_header_len,\n    guint *decrypt_len,\n    PAIRPDCAP_KEY_ITEM key,\n    AIRPDCAP_SEC_ASSOCIATION *sa,\n    INT offset)\n{\n    INT ret_value=1;\n    UCHAR *try_data;\n    guint try_data_len = *decrypt_len;\n\n    if (*decrypt_len > try_data_len) {\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsnaMng\", \"Invalid decryption length\", AIRPDCAP_DEBUG_LEVEL_3);\n        return AIRPDCAP_RET_UNSUCCESS;\n    }\n\n    /* allocate a temp buffer for the decryption loop */\n    try_data=(UCHAR *)g_malloc(try_data_len);\n\n    /* start of loop added by GCS */\n    for(/* sa */; sa != NULL ;sa=sa->next) {\n\n       if (sa->validKey==FALSE) {\n           AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsnaMng\", \"Key not yet valid\", AIRPDCAP_DEBUG_LEVEL_3);\n           continue;\n       }\n\n       /* copy the encrypted data into a temp buffer */\n       memcpy(try_data, decrypt_data, *decrypt_len);\n\n       if (sa->wpa.key_ver==1) {\n           /* CCMP -> HMAC-MD5 is the EAPOL-Key MIC, RC4 is the EAPOL-Key encryption algorithm */\n           AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsnaMng\", \"TKIP\", AIRPDCAP_DEBUG_LEVEL_3);\n           DEBUG_DUMP(\"ptk\", sa->wpa.ptk, 64);\n           DEBUG_DUMP(\"ptk portion used\", AIRPDCAP_GET_TK(sa->wpa.ptk), 16);\n\n           ret_value=AirPDcapTkipDecrypt(try_data+offset, *decrypt_len-offset, try_data+AIRPDCAP_TA_OFFSET, AIRPDCAP_GET_TK(sa->wpa.ptk));\n           if (ret_value){\n               AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsnaMng\", \"TKIP failed!\", AIRPDCAP_DEBUG_LEVEL_3);\n               continue;\n           }\n\n           AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsnaMng\", \"TKIP DECRYPTED!!!\", AIRPDCAP_DEBUG_LEVEL_3);\n           /* remove MIC (8bytes) and ICV (4bytes) from the end of packet */\n           *decrypt_len-=12;\n           break;\n       } else {\n           /* AES-CCMP -> HMAC-SHA1-128 is the EAPOL-Key MIC, AES wep_key wrap is the EAPOL-Key encryption algorithm */\n           AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsnaMng\", \"CCMP\", AIRPDCAP_DEBUG_LEVEL_3);\n\n           ret_value=AirPDcapCcmpDecrypt(try_data, mac_header_len, (INT)*decrypt_len, AIRPDCAP_GET_TK(sa->wpa.ptk));\n           if (ret_value)\n              continue;\n\n           AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsnaMng\", \"CCMP DECRYPTED!!!\", AIRPDCAP_DEBUG_LEVEL_3);\n           /* remove MIC (8bytes) from the end of packet */\n           *decrypt_len-=8;\n           break;\n       }\n    }\n    /* end of loop */\n\n    /* none of the keys worked */\n    if(sa == NULL) {\n        g_free(try_data);\n        return ret_value;\n    }\n\n    if (*decrypt_len > try_data_len || *decrypt_len < 8) {\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsnaMng\", \"Invalid decryption length\", AIRPDCAP_DEBUG_LEVEL_3);\n        g_free(try_data);\n        return AIRPDCAP_RET_UNSUCCESS;\n    }\n\n    /* copy the decrypted data into the decrypt buffer GCS*/\n    memcpy(decrypt_data, try_data, *decrypt_len);\n    g_free(try_data);\n\n    /* remove protection bit */\n    decrypt_data[1]&=0xBF;\n\n    /* remove TKIP/CCMP header */\n    offset = mac_header_len;\n    *decrypt_len-=8;\n    memmove(decrypt_data+offset, decrypt_data+offset+8, *decrypt_len-offset);\n\n    if (key!=NULL) {\n        if (sa->key!=NULL)\n            memcpy(key, sa->key, sizeof(AIRPDCAP_KEY_ITEM));\n        else\n            memset(key, 0, sizeof(AIRPDCAP_KEY_ITEM));\n        memcpy(key->KeyData.Wpa.Ptk, sa->wpa.ptk, AIRPDCAP_WPA_PTK_LEN); /* copy the PTK to the key structure for future use by wireshark */\n        if (sa->wpa.key_ver==AIRPDCAP_WPA_KEY_VER_NOT_CCMP)\n            key->KeyType=AIRPDCAP_KEY_TYPE_TKIP;\n        else if (sa->wpa.key_ver==AIRPDCAP_WPA_KEY_VER_AES_CCMP)\n            key->KeyType=AIRPDCAP_KEY_TYPE_CCMP;\n    }\n\n    return AIRPDCAP_RET_SUCCESS;\n}\n\nstatic INT\nAirPDcapWepMng(\n    PAIRPDCAP_CONTEXT ctx,\n    UCHAR *decrypt_data,\n    guint mac_header_len,\n    guint *decrypt_len,\n    PAIRPDCAP_KEY_ITEM key,\n    AIRPDCAP_SEC_ASSOCIATION *sa,\n    INT offset)\n{\n    UCHAR wep_key[AIRPDCAP_WEP_KEY_MAXLEN+AIRPDCAP_WEP_IVLEN];\n    size_t keylen;\n    INT ret_value=1;\n    INT key_index;\n    AIRPDCAP_KEY_ITEM *tmp_key;\n    UINT8 useCache=FALSE;\n    UCHAR *try_data;\n    guint try_data_len = *decrypt_len;\n\n    try_data = (UCHAR *)g_malloc(try_data_len);\n\n    if (sa->key!=NULL)\n        useCache=TRUE;\n\n    for (key_index=0; key_index<(INT)ctx->keys_nr; key_index++) {\n        /* use the cached one, or try all keys */\n        if (!useCache) {\n            tmp_key=&ctx->keys[key_index];\n        } else {\n            if (sa->key!=NULL && sa->key->KeyType==AIRPDCAP_KEY_TYPE_WEP) {\n                AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapWepMng\", \"Try cached WEP key...\", AIRPDCAP_DEBUG_LEVEL_3);\n                tmp_key=sa->key;\n            } else {\n                AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapWepMng\", \"Cached key is not valid, try another WEP key...\", AIRPDCAP_DEBUG_LEVEL_3);\n                tmp_key=&ctx->keys[key_index];\n            }\n        }\n\n        /* obviously, try only WEP keys... */\n        if (tmp_key->KeyType==AIRPDCAP_KEY_TYPE_WEP) {\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapWepMng\", \"Try WEP key...\", AIRPDCAP_DEBUG_LEVEL_3);\n\n            memset(wep_key, 0, sizeof(wep_key));\n            memcpy(try_data, decrypt_data, *decrypt_len);\n\n            /* Costruct the WEP seed: copy the IV in first 3 bytes and then the WEP key (refer to 802-11i-2004, 8.2.1.4.3, pag. 36) */\n            memcpy(wep_key, try_data+mac_header_len, AIRPDCAP_WEP_IVLEN);\n            keylen=tmp_key->KeyData.Wep.WepKeyLen;\n            memcpy(wep_key+AIRPDCAP_WEP_IVLEN, tmp_key->KeyData.Wep.WepKey, keylen);\n\n            ret_value=AirPDcapWepDecrypt(wep_key,\n                keylen+AIRPDCAP_WEP_IVLEN,\n                try_data + (mac_header_len+AIRPDCAP_WEP_IVLEN+AIRPDCAP_WEP_KIDLEN),\n                *decrypt_len-(mac_header_len+AIRPDCAP_WEP_IVLEN+AIRPDCAP_WEP_KIDLEN+AIRPDCAP_CRC_LEN));\n\n            if (ret_value == AIRPDCAP_RET_SUCCESS)\n                memcpy(decrypt_data, try_data, *decrypt_len);\n        }\n\n        if (!ret_value && tmp_key->KeyType==AIRPDCAP_KEY_TYPE_WEP) {\n            /* the tried key is the correct one, cached in the Security Association */\n\n            sa->key=tmp_key;\n\n            if (key!=NULL) {\n                memcpy(key, sa->key, sizeof(AIRPDCAP_KEY_ITEM));\n                key->KeyType=AIRPDCAP_KEY_TYPE_WEP;\n            }\n\n            break;\n        } else {\n            /* the cached key was not valid, try other keys */\n\n            if (useCache==TRUE) {\n                useCache=FALSE;\n                key_index--;\n            }\n        }\n    }\n\n    g_free(try_data);\n    if (ret_value)\n        return AIRPDCAP_RET_UNSUCCESS;\n\n    AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapWepMng\", \"WEP DECRYPTED!!!\", AIRPDCAP_DEBUG_LEVEL_3);\n\n    /* remove ICV (4bytes) from the end of packet */\n    *decrypt_len-=4;\n\n    if (*decrypt_len < 4) {\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapWepMng\", \"Decryption length too short\", AIRPDCAP_DEBUG_LEVEL_3);\n        return AIRPDCAP_RET_UNSUCCESS;\n    }\n\n    /* remove protection bit */\n    decrypt_data[1]&=0xBF;\n\n    /* remove IC header */\n    offset = mac_header_len;\n    *decrypt_len-=4;\n    memmove(decrypt_data+offset, decrypt_data+offset+AIRPDCAP_WEP_IVLEN+AIRPDCAP_WEP_KIDLEN, *decrypt_len-offset);\n\n    return AIRPDCAP_RET_SUCCESS;\n}\n\n/* Refer to IEEE 802.11i-2004, 8.5.3, pag. 85 */\nstatic INT\nAirPDcapRsna4WHandshake(\n    PAIRPDCAP_CONTEXT ctx,\n    const UCHAR *data,\n    AIRPDCAP_SEC_ASSOCIATION *sa,\n    INT offset,\n    const guint tot_len)\n{\n    AIRPDCAP_KEY_ITEM *tmp_key, *tmp_pkt_key, pkt_key;\n    AIRPDCAP_SEC_ASSOCIATION *tmp_sa;\n    INT key_index;\n    INT ret_value=1;\n    UCHAR useCache=FALSE;\n    UCHAR eapol[AIRPDCAP_EAPOL_MAX_LEN];\n    USHORT eapol_len;\n\n    if (sa->key!=NULL)\n        useCache=TRUE;\n\n    /* a 4-way handshake packet use a Pairwise key type (IEEE 802.11i-2004, pg. 79) */\n    if (AIRPDCAP_EAP_KEY(data[offset+1])!=1) {\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsna4WHandshake\", \"Group/STAKey message (not used)\", AIRPDCAP_DEBUG_LEVEL_5);\n        return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n    }\n\n    /* TODO timeouts? */\n\n    /* TODO consider key-index */\n\n    /* TODO considera Deauthentications */\n\n    AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsna4WHandshake\", \"4-way handshake...\", AIRPDCAP_DEBUG_LEVEL_5);\n\n    /* manage 4-way handshake packets; this step completes the 802.1X authentication process (IEEE 802.11i-2004, pag. 85) */\n\n    /* message 1: Authenticator->Supplicant (Sec=0, Mic=0, Ack=1, Inst=0, Key=1(pairwise), KeyRSC=0, Nonce=ANonce, MIC=0) */\n    if (AIRPDCAP_EAP_INST(data[offset+1])==0 &&\n        AIRPDCAP_EAP_ACK(data[offset+1])==1 &&\n        AIRPDCAP_EAP_MIC(data[offset])==0)\n    {\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsna4WHandshake\", \"4-way handshake message 1\", AIRPDCAP_DEBUG_LEVEL_3);\n\n        /* On reception of Message 1, the Supplicant determines whether the Key Replay Counter field value has been        */\n        /* used before with the current PMKSA. If the Key Replay Counter field value is less than or equal to the current  */\n        /* local value, the Supplicant discards the message.                                                               */\n        /* -> not checked, the Authenticator will be send another Message 1 (hopefully!)                                   */\n\n        /* This saves the sa since we are reauthenticating which will overwrite our current sa GCS*/\n        if( sa->handshake >= 2) {\n            tmp_sa= g_new(AIRPDCAP_SEC_ASSOCIATION, 1);\n            memcpy(tmp_sa, sa, sizeof(AIRPDCAP_SEC_ASSOCIATION));\n            sa->validKey=FALSE;\n            sa->next=tmp_sa;\n        }\n\n        /* save ANonce (from authenticator) to derive the PTK with the SNonce (from the 2 message) */\n        memcpy(sa->wpa.nonce, data+offset+12, 32);\n\n        /* get the Key Descriptor Version (to select algorithm used in decryption -CCMP or TKIP-) */\n        sa->wpa.key_ver=AIRPDCAP_EAP_KEY_DESCR_VER(data[offset+1]);\n\n        sa->handshake=1;\n\n        return AIRPDCAP_RET_SUCCESS_HANDSHAKE;\n    }\n\n    /* message 2|4: Supplicant->Authenticator (Sec=0|1, Mic=1, Ack=0, Inst=0, Key=1(pairwise), KeyRSC=0, Nonce=SNonce|0, MIC=MIC(KCK,EAPOL)) */\n    if (AIRPDCAP_EAP_INST(data[offset+1])==0 &&\n        AIRPDCAP_EAP_ACK(data[offset+1])==0 &&\n        AIRPDCAP_EAP_MIC(data[offset])==1)\n    {\n        /* Check key data length to differentiate between message 2 or 4, same as in epan/dissectors/packet-ieee80211.c */\n        if (pntoh16(data+offset+92)) {\n            /* message 2 */\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsna4WHandshake\", \"4-way handshake message 2\", AIRPDCAP_DEBUG_LEVEL_3);\n\n            /* On reception of Message 2, the Authenticator checks that the key replay counter corresponds to the */\n            /* outstanding Message 1. If not, it silently discards the message.                                   */\n            /* If the calculated MIC does not match the MIC that the Supplicant included in the EAPOL-Key frame,  */\n            /* the Authenticator silently discards Message 2.                                                     */\n            /* -> not checked; the Supplicant will send another message 2 (hopefully!)                            */\n\n            /* now you can derive the PTK */\n            for (key_index=0; key_index<(INT)ctx->keys_nr || useCache; key_index++) {\n                /* use the cached one, or try all keys */\n                if (!useCache) {\n                    AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsna4WHandshake\", \"Try WPA key...\", AIRPDCAP_DEBUG_LEVEL_3);\n                    tmp_key=&ctx->keys[key_index];\n                } else {\n                    /* there is a cached key in the security association, if it's a WPA key try it... */\n                    if (sa->key!=NULL &&\n                        (sa->key->KeyType==AIRPDCAP_KEY_TYPE_WPA_PWD ||\n                         sa->key->KeyType==AIRPDCAP_KEY_TYPE_WPA_PSK ||\n                         sa->key->KeyType==AIRPDCAP_KEY_TYPE_WPA_PMK)) {\n                            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsna4WHandshake\", \"Try cached WPA key...\", AIRPDCAP_DEBUG_LEVEL_3);\n                            tmp_key=sa->key;\n                    } else {\n                        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsna4WHandshake\", \"Cached key is of a wrong type, try WPA key...\", AIRPDCAP_DEBUG_LEVEL_3);\n                        tmp_key=&ctx->keys[key_index];\n                    }\n                }\n\n                /* obviously, try only WPA keys... */\n                if (tmp_key->KeyType==AIRPDCAP_KEY_TYPE_WPA_PWD ||\n                    tmp_key->KeyType==AIRPDCAP_KEY_TYPE_WPA_PSK ||\n                    tmp_key->KeyType==AIRPDCAP_KEY_TYPE_WPA_PMK)\n                {\n                    if (tmp_key->KeyType == AIRPDCAP_KEY_TYPE_WPA_PWD && tmp_key->UserPwd.SsidLen == 0 && ctx->pkt_ssid_len > 0 && ctx->pkt_ssid_len <= AIRPDCAP_WPA_SSID_MAX_LEN) {\n                        /* We have a \"wildcard\" SSID.  Use the one from the packet. */\n                        memcpy(&pkt_key, tmp_key, sizeof(pkt_key));\n                        memcpy(&pkt_key.UserPwd.Ssid, ctx->pkt_ssid, ctx->pkt_ssid_len);\n                         pkt_key.UserPwd.SsidLen = ctx->pkt_ssid_len;\n                        AirPDcapRsnaPwd2Psk(pkt_key.UserPwd.Passphrase, pkt_key.UserPwd.Ssid,\n                            pkt_key.UserPwd.SsidLen, pkt_key.KeyData.Wpa.Psk);\n                        tmp_pkt_key = &pkt_key;\n                    } else {\n                        tmp_pkt_key = tmp_key;\n                    }\n\n                    /* derive the PTK from the BSSID, STA MAC, PMK, SNonce, ANonce */\n                    AirPDcapRsnaPrfX(sa,                            /* authenticator nonce, bssid, station mac */\n                                     tmp_pkt_key->KeyData.Wpa.Psk,      /* PSK == PMK */\n                                     data+offset+12,                /* supplicant nonce */\n                                     512,\n                                     sa->wpa.ptk);\n\n                    /* verify the MIC (compare the MIC in the packet included in this message with a MIC calculated with the PTK) */\n                    eapol_len=pntoh16(data+offset-3)+4;\n                    memcpy(eapol, &data[offset-5], (eapol_len<AIRPDCAP_EAPOL_MAX_LEN?eapol_len:AIRPDCAP_EAPOL_MAX_LEN));\n                    ret_value=AirPDcapRsnaMicCheck(eapol,           /*      eapol frame (header also) */\n                                                   eapol_len,       /*      eapol frame length        */\n                                                   sa->wpa.ptk,     /*      Key Confirmation Key      */\n                                                   AIRPDCAP_EAP_KEY_DESCR_VER(data[offset+1])); /*  EAPOL-Key description version */\n\n                    /* If the MIC is valid, the Authenticator checks that the RSN information element bit-wise matches       */\n                    /* that from the (Re)Association Request message.                                                        */\n                    /*              i) TODO If these are not exactly the same, the Authenticator uses MLME-DEAUTHENTICATE.request */\n                    /* primitive to terminate the association.                                                               */\n                    /*              ii) If they do match bit-wise, the Authenticator constructs Message 3.                   */\n                }\n\n                if (!ret_value &&\n                    (tmp_key->KeyType==AIRPDCAP_KEY_TYPE_WPA_PWD ||\n                    tmp_key->KeyType==AIRPDCAP_KEY_TYPE_WPA_PSK ||\n                    tmp_key->KeyType==AIRPDCAP_KEY_TYPE_WPA_PMK))\n                {\n                    /* the temporary key is the correct one, cached in the Security Association */\n\n                    sa->key=tmp_key;\n                    break;\n                } else {\n                    /* the cached key was not valid, try other keys */\n\n                    if (useCache==TRUE) {\n                        useCache=FALSE;\n                        key_index--;\n                    }\n                }\n            }\n\n            if (ret_value) {\n                AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsna4WHandshake\", \"handshake step failed\", AIRPDCAP_DEBUG_LEVEL_3);\n                return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n            }\n\n            sa->handshake=2;\n            sa->validKey=TRUE; /* we can use the key to decode, even if we have not captured the other eapol packets */\n\n            return AIRPDCAP_RET_SUCCESS_HANDSHAKE;\n        } else {\n        /* message 4 */\n\n            /* TODO \"Note that when the 4-Way Handshake is first used Message 4 is sent in the clear.\" */\n\n            /* TODO check MIC and Replay Counter                                                                     */\n            /* On reception of Message 4, the Authenticator verifies that the Key Replay Counter field value is one  */\n            /* that it used on this 4-Way Handshake; if it is not, it silently discards the message.                 */\n            /* If the calculated MIC does not match the MIC that the Supplicant included in the EAPOL-Key frame, the */\n            /* Authenticator silently discards Message 4.                                                            */\n\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsna4WHandshake\", \"4-way handshake message 4\", AIRPDCAP_DEBUG_LEVEL_3);\n\n            sa->handshake=4;\n\n            return AIRPDCAP_RET_SUCCESS_HANDSHAKE;\n        }\n    }\n\n    /* message 3: Authenticator->Supplicant (Sec=1, Mic=1, Ack=1, Inst=0/1, Key=1(pairwise), KeyRSC=???, Nonce=ANonce, MIC=1) */\n    if (AIRPDCAP_EAP_ACK(data[offset+1])==1 &&\n        AIRPDCAP_EAP_MIC(data[offset])==1)\n    {\n        const EAPOL_RSN_KEY *pEAPKey;\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsna4WHandshake\", \"4-way handshake message 3\", AIRPDCAP_DEBUG_LEVEL_3);\n\n        /* On reception of Message 3, the Supplicant silently discards the message if the Key Replay Counter field     */\n        /* value has already been used or if the ANonce value in Message 3 differs from the ANonce value in Message 1. */\n        /* -> not checked, the Authenticator will send another message 3 (hopefully!)                                  */\n\n        /* TODO check page 88 (RNS) */\n\n        /* If using WPA2 PSK, message 3 will contain an RSN for the group key (GTK KDE).\n           In order to properly support decrypting WPA2-PSK packets, we need to parse this to get the group key. */\n        pEAPKey = (const EAPOL_RSN_KEY *)(&(data[offset-1]));\n        if (pEAPKey->type == AIRPDCAP_RSN_WPA2_KEY_DESCRIPTOR){\n            PAIRPDCAP_SEC_ASSOCIATION broadcast_sa;\n            AIRPDCAP_SEC_ASSOCIATION_ID id;\n\n            /* Get broadcacst SA for the current BSSID */\n            memcpy(id.sta, broadcast_mac, AIRPDCAP_MAC_LEN);\n            memcpy(id.bssid, sa->saId.bssid, AIRPDCAP_MAC_LEN);\n            broadcast_sa = AirPDcapGetSaPtr(ctx, &id);\n\n            if (broadcast_sa == NULL){\n                return AIRPDCAP_RET_REQ_DATA;\n            }\n            return (AirPDcapDecryptWPABroadcastKey(pEAPKey, sa->wpa.ptk+16, broadcast_sa, tot_len-offset+1));\n        }\n    }\n\n    return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n}\n\nstatic INT\nAirPDcapRsnaMicCheck(\n    UCHAR *eapol,\n    USHORT eapol_len,\n    UCHAR KCK[AIRPDCAP_WPA_KCK_LEN],\n    USHORT key_ver)\n{\n    UCHAR mic[AIRPDCAP_WPA_MICKEY_LEN];\n    UCHAR c_mic[HASH_SHA1_LENGTH] = { 0 };  /* MIC 16 byte, the HMAC-SHA1 use a buffer of 20 bytes */\n    int algo;\n\n    /* copy the MIC from the EAPOL packet */\n    memcpy(mic, eapol+AIRPDCAP_WPA_MICKEY_OFFSET+4, AIRPDCAP_WPA_MICKEY_LEN);\n\n    /* set to 0 the MIC in the EAPOL packet (to calculate the MIC) */\n    memset(eapol+AIRPDCAP_WPA_MICKEY_OFFSET+4, 0, AIRPDCAP_WPA_MICKEY_LEN);\n\n    if (key_ver==AIRPDCAP_WPA_KEY_VER_NOT_CCMP) {\n        /* use HMAC-MD5 for the EAPOL-Key MIC */\n        algo = GCRY_MD_MD5;\n    } else if (key_ver==AIRPDCAP_WPA_KEY_VER_AES_CCMP) {\n        /* use HMAC-SHA1-128 for the EAPOL-Key MIC */\n        algo = GCRY_MD_SHA1;\n    } else {\n        /* key descriptor version not recognized */\n        return AIRPDCAP_RET_UNSUCCESS;\n    }\n\n    if (ws_hmac_buffer(algo, c_mic, eapol, eapol_len, KCK, AIRPDCAP_WPA_KCK_LEN)) {\n        return AIRPDCAP_RET_UNSUCCESS;\n    }\n\n    /* compare calculated MIC with the Key MIC and return result (0 means success) */\n    return memcmp(mic, c_mic, AIRPDCAP_WPA_MICKEY_LEN);\n}\n\nstatic INT\nAirPDcapValidateKey(\n    PAIRPDCAP_KEY_ITEM key)\n{\n    size_t len;\n    UCHAR ret=TRUE;\n    AIRPDCAP_DEBUG_TRACE_START(\"AirPDcapValidateKey\");\n\n    if (key==NULL) {\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapValidateKey\", \"NULL key\", AIRPDCAP_DEBUG_LEVEL_5);\n        AIRPDCAP_DEBUG_TRACE_START(\"AirPDcapValidateKey\");\n        return FALSE;\n    }\n\n    switch (key->KeyType) {\n        case AIRPDCAP_KEY_TYPE_WEP:\n            /* check key size limits */\n            len=key->KeyData.Wep.WepKeyLen;\n            if (len<AIRPDCAP_WEP_KEY_MINLEN || len>AIRPDCAP_WEP_KEY_MAXLEN) {\n                AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapValidateKey\", \"WEP key: key length not accepted\", AIRPDCAP_DEBUG_LEVEL_5);\n                ret=FALSE;\n            }\n            break;\n\n        case AIRPDCAP_KEY_TYPE_WEP_40:\n            /* set the standard length and use a generic WEP key type */\n            key->KeyData.Wep.WepKeyLen=AIRPDCAP_WEP_40_KEY_LEN;\n            key->KeyType=AIRPDCAP_KEY_TYPE_WEP;\n            break;\n\n        case AIRPDCAP_KEY_TYPE_WEP_104:\n            /* set the standard length and use a generic WEP key type */\n            key->KeyData.Wep.WepKeyLen=AIRPDCAP_WEP_104_KEY_LEN;\n            key->KeyType=AIRPDCAP_KEY_TYPE_WEP;\n            break;\n\n        case AIRPDCAP_KEY_TYPE_WPA_PWD:\n            /* check passphrase and SSID size limits */\n            len=strlen(key->UserPwd.Passphrase);\n            if (len<AIRPDCAP_WPA_PASSPHRASE_MIN_LEN || len>AIRPDCAP_WPA_PASSPHRASE_MAX_LEN) {\n                AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapValidateKey\", \"WPA-PWD key: passphrase length not accepted\", AIRPDCAP_DEBUG_LEVEL_5);\n                ret=FALSE;\n            }\n\n            len=key->UserPwd.SsidLen;\n            if (len>AIRPDCAP_WPA_SSID_MAX_LEN) {\n                AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapValidateKey\", \"WPA-PWD key: ssid length not accepted\", AIRPDCAP_DEBUG_LEVEL_5);\n                ret=FALSE;\n            }\n\n            break;\n\n        case AIRPDCAP_KEY_TYPE_WPA_PSK:\n            break;\n\n        case AIRPDCAP_KEY_TYPE_WPA_PMK:\n            break;\n\n        default:\n            ret=FALSE;\n    }\n\n    AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapValidateKey\");\n    return ret;\n}\n\nstatic INT\nAirPDcapGetSa(\n    PAIRPDCAP_CONTEXT ctx,\n    AIRPDCAP_SEC_ASSOCIATION_ID *id)\n{\n    INT sa_index;\n    if (ctx->sa_index!=-1) {\n        /* at least one association was stored                               */\n        /* search for the association from sa_index to 0 (most recent added) */\n        for (sa_index=ctx->sa_index; sa_index>=0; sa_index--) {\n            if (ctx->sa[sa_index].used) {\n                if (memcmp(id, &(ctx->sa[sa_index].saId), sizeof(AIRPDCAP_SEC_ASSOCIATION_ID))==0) {\n                    ctx->index=sa_index;\n                    return sa_index;\n                }\n            }\n        }\n    }\n\n    return -1;\n}\n\nstatic INT\nAirPDcapStoreSa(\n    PAIRPDCAP_CONTEXT ctx,\n    AIRPDCAP_SEC_ASSOCIATION_ID *id)\n{\n    INT last_free;\n    if (ctx->first_free_index>=AIRPDCAP_MAX_SEC_ASSOCIATIONS_NR) {\n        /* there is no empty space available. FAILURE */\n        return -1;\n    }\n    if (ctx->sa[ctx->first_free_index].used) {\n        /* last addition was in the middle of the array (and the first_free_index was just incremented by 1)   */\n        /* search for a free space from the first_free_index to AIRPDCAP_STA_INFOS_NR (to avoid free blocks in */\n        /*              the middle)                                                                            */\n        for (last_free=ctx->first_free_index; last_free<AIRPDCAP_MAX_SEC_ASSOCIATIONS_NR; last_free++)\n            if (!ctx->sa[last_free].used)\n                break;\n\n        if (last_free>=AIRPDCAP_MAX_SEC_ASSOCIATIONS_NR) {\n            /* there is no empty space available. FAILURE */\n            return -1;\n        }\n\n        /* store first free space index */\n        ctx->first_free_index=last_free;\n    }\n\n    /* use this info */\n    ctx->index=ctx->first_free_index;\n\n    /* reset the info structure */\n    memset(ctx->sa+ctx->index, 0, sizeof(AIRPDCAP_SEC_ASSOCIATION));\n\n    ctx->sa[ctx->index].used=1;\n\n    /* set the info structure */\n    memcpy(&(ctx->sa[ctx->index].saId), id, sizeof(AIRPDCAP_SEC_ASSOCIATION_ID));\n\n    /* increment by 1 the first_free_index (heuristic) */\n    ctx->first_free_index++;\n\n    /* set the sa_index if the added index is greater the the sa_index */\n    if (ctx->index > ctx->sa_index)\n        ctx->sa_index=ctx->index;\n\n    return ctx->index;\n}\n\n\nstatic INT\nAirPDcapGetSaAddress(\n    const AIRPDCAP_MAC_FRAME_ADDR4 *frame,\n    AIRPDCAP_SEC_ASSOCIATION_ID *id)\n{\n#ifdef AIRPDCAP_DEBUG\n#define MSGBUF_LEN 255\n    CHAR msgbuf[MSGBUF_LEN];\n#endif\n\n    if ((AIRPDCAP_TYPE(frame->fc[0])==AIRPDCAP_TYPE_DATA) &&\n        (AIRPDCAP_DS_BITS(frame->fc[1]) == 0) &&\n        (memcmp(frame->addr2, frame->addr3, AIRPDCAP_MAC_LEN) != 0) &&\n        (memcmp(frame->addr1, frame->addr3, AIRPDCAP_MAC_LEN) != 0)) {\n        /* DATA frame with fromDS=0 ToDS=0 and neither RA or SA is BSSID\n           => TDLS traffic. Use highest MAC address for bssid */\n        if (memcmp(frame->addr1, frame->addr2, AIRPDCAP_MAC_LEN) < 0) {\n            memcpy(id->sta, frame->addr1, AIRPDCAP_MAC_LEN);\n            memcpy(id->bssid, frame->addr2, AIRPDCAP_MAC_LEN);\n        } else {\n            memcpy(id->sta, frame->addr2, AIRPDCAP_MAC_LEN);\n            memcpy(id->bssid, frame->addr1, AIRPDCAP_MAC_LEN);\n        }\n    } else {\n        const UCHAR *addr;\n\n        /* Normal Case: SA between STA and AP */\n        if ((addr = AirPDcapGetBssidAddress(frame)) != NULL) {\n            memcpy(id->bssid, addr, AIRPDCAP_MAC_LEN);\n        } else {\n            return AIRPDCAP_RET_UNSUCCESS;\n        }\n\n        if ((addr = AirPDcapGetStaAddress(frame)) != NULL) {\n            memcpy(id->sta, addr, AIRPDCAP_MAC_LEN);\n        } else {\n            return AIRPDCAP_RET_UNSUCCESS;\n        }\n    }\n\n#ifdef AIRPDCAP_DEBUG\n    g_snprintf(msgbuf, MSGBUF_LEN, \"BSSID_MAC: %02X.%02X.%02X.%02X.%02X.%02X\\t\",\n               id->bssid[0],id->bssid[1],id->bssid[2],id->bssid[3],id->bssid[4],id->bssid[5]);\n    AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapGetSaAddress\", msgbuf, AIRPDCAP_DEBUG_LEVEL_3);\n    g_snprintf(msgbuf, MSGBUF_LEN, \"STA_MAC: %02X.%02X.%02X.%02X.%02X.%02X\\t\",\n               id->sta[0],id->sta[1],id->sta[2],id->sta[3],id->sta[4],id->sta[5]);\n    AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapGetSaAddress\", msgbuf, AIRPDCAP_DEBUG_LEVEL_3);\n#endif\n\n    return AIRPDCAP_RET_SUCCESS;\n}\n\n/*\n * AirPDcapGetBssidAddress() and AirPDcapGetBssidAddress() are used for\n * key caching.  In each case, it's more important to return a value than\n * to return a _correct_ value, so we fudge addresses in some cases, e.g.\n * the BSSID in bridged connections.\n * FromDS    ToDS   Sta      BSSID\n * 0         0      addr1/2  addr3\n * 0         1      addr2    addr1\n * 1         0      addr1    addr2\n * 1         1      addr2    addr1\n */\n\nstatic const UCHAR *\nAirPDcapGetStaAddress(\n    const AIRPDCAP_MAC_FRAME_ADDR4 *frame)\n{\n    switch(AIRPDCAP_DS_BITS(frame->fc[1])) { /* Bit 1 = FromDS, bit 0 = ToDS */\n        case 0:\n            if (memcmp(frame->addr2, frame->addr3, AIRPDCAP_MAC_LEN) == 0)\n                return frame->addr1;\n            else\n                return frame->addr2;\n        case 1:\n            return frame->addr2;\n        case 2:\n            return frame->addr1;\n        case 3:\n            if (memcmp(frame->addr1, frame->addr2, AIRPDCAP_MAC_LEN) < 0)\n                return frame->addr1;\n            else\n                return frame->addr2;\n\n        default:\n            return NULL;\n    }\n}\n\nstatic const UCHAR *\nAirPDcapGetBssidAddress(\n    const AIRPDCAP_MAC_FRAME_ADDR4 *frame)\n{\n    switch(AIRPDCAP_DS_BITS(frame->fc[1])) { /* Bit 1 = FromDS, bit 0 = ToDS */\n        case 0:\n            return frame->addr3;\n        case 1:\n            return frame->addr1;\n        case 2:\n            return frame->addr2;\n        case 3:\n            if (memcmp(frame->addr1, frame->addr2, AIRPDCAP_MAC_LEN) > 0)\n                return frame->addr1;\n            else\n                return frame->addr2;\n\n        default:\n            return NULL;\n    }\n}\n\n/* Function used to derive the PTK. Refer to IEEE 802.11I-2004, pag. 74\n * and IEEE 802.11i-2004, pag. 164 */\nstatic void\nAirPDcapRsnaPrfX(\n    AIRPDCAP_SEC_ASSOCIATION *sa,\n    const UCHAR pmk[32],\n    const UCHAR snonce[32],\n    const INT x,        /*      for TKIP 512, for CCMP 384 */\n    UCHAR *ptk)\n{\n    UINT8 i;\n    UCHAR R[100];\n    INT offset=sizeof(\"Pairwise key expansion\");\n    UCHAR output[80]; /* allow for sha1 overflow. */\n\n    memset(R, 0, 100);\n\n    memcpy(R, \"Pairwise key expansion\", offset);\n\n    /* Min(AA, SPA) || Max(AA, SPA) */\n    if (memcmp(sa->saId.sta, sa->saId.bssid, AIRPDCAP_MAC_LEN) < 0)\n    {\n        memcpy(R + offset, sa->saId.sta, AIRPDCAP_MAC_LEN);\n        memcpy(R + offset+AIRPDCAP_MAC_LEN, sa->saId.bssid, AIRPDCAP_MAC_LEN);\n    }\n    else\n    {\n        memcpy(R + offset, sa->saId.bssid, AIRPDCAP_MAC_LEN);\n        memcpy(R + offset+AIRPDCAP_MAC_LEN, sa->saId.sta, AIRPDCAP_MAC_LEN);\n    }\n\n    offset+=AIRPDCAP_MAC_LEN*2;\n\n    /* Min(ANonce,SNonce) || Max(ANonce,SNonce) */\n    if( memcmp(snonce, sa->wpa.nonce, 32) < 0 )\n    {\n        memcpy(R + offset, snonce, 32);\n        memcpy(R + offset + 32, sa->wpa.nonce, 32);\n    }\n    else\n    {\n        memcpy(R + offset, sa->wpa.nonce, 32);\n        memcpy(R + offset + 32, snonce, 32);\n    }\n\n    offset+=32*2;\n\n    for(i = 0; i < (x+159)/160; i++)\n    {\n        R[offset] = i;\n        if (ws_hmac_buffer(GCRY_MD_SHA1, &output[HASH_SHA1_LENGTH * i], R, 100, pmk, 32)) {\n          return;\n        }\n    }\n    memcpy(ptk, output, x/8);\n}\n\n#define MAX_SSID_LENGTH 32 /* maximum SSID length */\n\nstatic INT\nAirPDcapRsnaPwd2PskStep(\n    const guint8 *ppBytes,\n    const guint ppLength,\n    const CHAR *ssid,\n    const size_t ssidLength,\n    const INT iterations,\n    const INT count,\n    UCHAR *output)\n{\n    UCHAR digest[MAX_SSID_LENGTH+4] = { 0 };  /* SSID plus 4 bytes of count */\n    INT i, j;\n\n    if (ssidLength > MAX_SSID_LENGTH) {\n        /* This \"should not happen\" */\n        return AIRPDCAP_RET_UNSUCCESS;\n    }\n\n    /* U1 = PRF(P, S || INT(i)) */\n    memcpy(digest, ssid, ssidLength);\n    digest[ssidLength] = (UCHAR)((count>>24) & 0xff);\n    digest[ssidLength+1] = (UCHAR)((count>>16) & 0xff);\n    digest[ssidLength+2] = (UCHAR)((count>>8) & 0xff);\n    digest[ssidLength+3] = (UCHAR)(count & 0xff);\n    if (ws_hmac_buffer(GCRY_MD_SHA1, digest, digest, (guint32) ssidLength + 4, ppBytes, ppLength)) {\n      return AIRPDCAP_RET_UNSUCCESS;\n    }\n\n    /* output = U1 */\n    memcpy(output, digest, 20);\n    for (i = 1; i < iterations; i++) {\n        /* Un = PRF(P, Un-1) */\n        if (ws_hmac_buffer(GCRY_MD_SHA1, digest, digest, HASH_SHA1_LENGTH, ppBytes, ppLength)) {\n          return AIRPDCAP_RET_UNSUCCESS;\n        }\n\n        /* output = output xor Un */\n        for (j = 0; j < 20; j++) {\n            output[j] ^= digest[j];\n        }\n    }\n\n    return AIRPDCAP_RET_SUCCESS;\n}\n\nstatic INT\nAirPDcapRsnaPwd2Psk(\n    const CHAR *passphrase,\n    const CHAR *ssid,\n    const size_t ssidLength,\n    UCHAR *output)\n{\n    UCHAR m_output[40] = { 0 };\n    GByteArray *pp_ba = g_byte_array_new();\n\n    if (!uri_str_to_bytes(passphrase, pp_ba)) {\n        g_byte_array_free(pp_ba, TRUE);\n        return 0;\n    }\n\n    AirPDcapRsnaPwd2PskStep(pp_ba->data, pp_ba->len, ssid, ssidLength, 4096, 1, m_output);\n    AirPDcapRsnaPwd2PskStep(pp_ba->data, pp_ba->len, ssid, ssidLength, 4096, 2, &m_output[20]);\n\n    memcpy(output, m_output, AIRPDCAP_WPA_PSK_LEN);\n    g_byte_array_free(pp_ba, TRUE);\n\n    return 0;\n}\n\n/*\n * Returns the decryption_key_t struct given a string describing the key.\n * Returns NULL if the input_string cannot be parsed.\n */\ndecryption_key_t*\nparse_key_string(gchar* input_string, guint8 key_type)\n{\n    gchar *key, *tmp_str;\n    gchar *ssid;\n\n    GString    *key_string = NULL;\n    GByteArray *ssid_ba = NULL, *key_ba;\n    gboolean    res;\n\n    gchar **tokens;\n    guint n = 0;\n    decryption_key_t *dk;\n\n    if(input_string == NULL)\n        return NULL;\n\n    /*\n     * Parse the input_string. WEP and WPA will be just a string\n     * of hexadecimal characters (if key is wrong, null will be\n     * returned...).\n     * WPA-PWD should be in the form\n     * <key data>[:<ssid>]\n     */\n\n    switch(key_type)\n    {\n    case AIRPDCAP_KEY_TYPE_WEP:\n    case AIRPDCAP_KEY_TYPE_WEP_40:\n    case AIRPDCAP_KEY_TYPE_WEP_104:\n\n       key_ba = g_byte_array_new();\n       res = hex_str_to_bytes(input_string, key_ba, FALSE);\n\n       if (res && key_ba->len > 0) {\n           /* Key is correct! It was probably an 'old style' WEP key */\n           /* Create the decryption_key_t structure, fill it and return it*/\n           dk = (decryption_key_t *)g_malloc(sizeof(decryption_key_t));\n\n           dk->type = AIRPDCAP_KEY_TYPE_WEP;\n           /* XXX - The current key handling code in the GUI requires\n            * no separators and lower case */\n           tmp_str = bytes_to_str(NULL, key_ba->data, key_ba->len);\n           dk->key  = g_string_new(tmp_str);\n           g_string_ascii_down(dk->key);\n           dk->bits = key_ba->len * 8;\n           dk->ssid = NULL;\n\n           wmem_free(NULL, tmp_str);\n           g_byte_array_free(key_ba, TRUE);\n           return dk;\n       }\n\n       /* Key doesn't work */\n       g_byte_array_free(key_ba, TRUE);\n       return NULL;\n\n    case AIRPDCAP_KEY_TYPE_WPA_PWD:\n\n        tokens = g_strsplit(input_string,\":\",0);\n\n        /* Tokens is a null termiated array of strings ... */\n        while(tokens[n] != NULL)\n            n++;\n\n        if(n < 1)\n        {\n            /* Free the array of strings */\n            g_strfreev(tokens);\n            return NULL;\n        }\n\n        /*\n         * The first token is the key\n         */\n        key = g_strdup(tokens[0]);\n\n        ssid = NULL;\n        /* Maybe there is a second token (an ssid, if everything else is ok) */\n        if(n >= 2)\n        {\n           ssid = g_strdup(tokens[1]);\n        }\n\n        /* Create a new string */\n        key_string = g_string_new(key);\n        ssid_ba = NULL;\n\n        /* Two (or more) tokens mean that the user entered a WPA-PWD key ... */\n        if( ((key_string->len) > WPA_KEY_MAX_CHAR_SIZE) || ((key_string->len) < WPA_KEY_MIN_CHAR_SIZE))\n        {\n            g_string_free(key_string, TRUE);\n\n            g_free(key);\n            g_free(ssid);\n\n            /* Free the array of strings */\n            g_strfreev(tokens);\n            return NULL;\n        }\n\n        if(ssid != NULL) /* more than two tokens found, means that the user specified the ssid */\n        {\n            ssid_ba = g_byte_array_new();\n            if (! uri_str_to_bytes(ssid, ssid_ba)) {\n                g_string_free(key_string, TRUE);\n                g_byte_array_free(ssid_ba, TRUE);\n                g_free(key);\n                g_free(ssid);\n                /* Free the array of strings */\n                g_strfreev(tokens);\n                return NULL;\n            }\n\n            if(ssid_ba->len > WPA_SSID_MAX_CHAR_SIZE)\n            {\n                g_string_free(key_string, TRUE);\n                g_byte_array_free(ssid_ba, TRUE);\n\n                g_free(key);\n                g_free(ssid);\n\n                /* Free the array of strings */\n                g_strfreev(tokens);\n                return NULL;\n            }\n        }\n\n        /* Key was correct!!! Create the new decryption_key_t ... */\n        dk = (decryption_key_t*)g_malloc(sizeof(decryption_key_t));\n\n        dk->type = AIRPDCAP_KEY_TYPE_WPA_PWD;\n        dk->key  = g_string_new(key);\n        dk->bits = 256; /* This is the length of the array pf bytes that will be generated using key+ssid ...*/\n        dk->ssid = byte_array_dup(ssid_ba); /* NULL if ssid_ba is NULL */\n\n        g_string_free(key_string, TRUE);\n        if (ssid_ba != NULL)\n            g_byte_array_free(ssid_ba, TRUE);\n\n        g_free(key);\n        g_free(ssid);\n\n        /* Free the array of strings */\n        g_strfreev(tokens);\n        return dk;\n\n    case AIRPDCAP_KEY_TYPE_WPA_PSK:\n\n        key_ba = g_byte_array_new();\n        res = hex_str_to_bytes(input_string, key_ba, FALSE);\n\n        /* Two tokens means that the user should have entered a WPA-BIN key ... */\n        if(!res || ((key_ba->len) != WPA_PSK_KEY_SIZE))\n        {\n            g_byte_array_free(key_ba, TRUE);\n\n            /* No ssid has been created ... */\n            return NULL;\n        }\n\n        /* Key was correct!!! Create the new decryption_key_t ... */\n        dk = (decryption_key_t*)g_malloc(sizeof(decryption_key_t));\n\n        dk->type = AIRPDCAP_KEY_TYPE_WPA_PSK;\n        dk->key  = g_string_new(input_string);\n        dk->bits = (guint) dk->key->len * 4;\n        dk->ssid = NULL;\n\n        g_byte_array_free(key_ba, TRUE);\n        return dk;\n    }\n\n    /* Type not supported */\n    return NULL;\n}\n\nvoid\nfree_key_string(decryption_key_t *dk)\n{\n    if (dk->key)\n        g_string_free(dk->key, TRUE);\n    if (dk->ssid)\n        g_byte_array_free(dk->ssid, TRUE);\n    g_free(dk);\n}\n\n/*\n * Returns a newly allocated string representing the given decryption_key_t\n * struct, or NULL if something is wrong...\n */\ngchar*\nget_key_string(decryption_key_t* dk)\n{\n    gchar* output_string = NULL;\n\n    if(dk == NULL || dk->key == NULL)\n        return NULL;\n\n    switch(dk->type) {\n        case AIRPDCAP_KEY_TYPE_WEP:\n            output_string = g_strdup(dk->key->str);\n            break;\n        case AIRPDCAP_KEY_TYPE_WPA_PWD:\n            if(dk->ssid == NULL)\n                output_string = g_strdup(dk->key->str);\n            else {\n                gchar* ssid = format_uri(NULL, dk->ssid, \":\");\n                output_string = g_strdup_printf(\"%s:%s\",\n                    dk->key->str, ssid);\n                wmem_free(NULL, ssid);\n            }\n            break;\n        case AIRPDCAP_KEY_TYPE_WPA_PMK:\n            output_string = g_strdup(dk->key->str);\n            break;\n        default:\n            return NULL;\n    }\n\n    return output_string;\n}\n\nstatic INT\nAirPDcapTDLSDeriveKey(\n    PAIRPDCAP_SEC_ASSOCIATION sa,\n    const guint8 *data,\n#if GCRYPT_VERSION_NUMBER >= 0x010600\n    guint offset_rsne,\n#else\n    guint offset_rsne _U_,\n#endif\n    guint offset_fte,\n#if GCRYPT_VERSION_NUMBER >= 0x010600\n    guint offset_timeout,\n#else\n    guint offset_timeout _U_,\n#endif\n    guint offset_link,\n#if GCRYPT_VERSION_NUMBER >= 0x010600\n    guint8 action)\n#else\n    guint8 action _U_)\n#endif\n{\n\n    gcry_md_hd_t sha256_handle;\n    gcry_md_hd_t hmac_handle;\n    const guint8 *snonce, *anonce, *initiator, *responder, *bssid;\n    guint8 key_input[32];\n#if GCRYPT_VERSION_NUMBER >= 0x010600\n    guint8 mic[16], seq_num = action + 1;\n    guint8 zeros[16] = { 0 };\n    gcry_mac_hd_t cmac_handle;\n    size_t cmac_len = 16;\n    size_t cmac_write_len;\n#endif\n\n    /* Get key input */\n    anonce = &data[offset_fte + 20];\n    snonce = &data[offset_fte + 52];\n\n    gcry_md_open (&sha256_handle, GCRY_MD_SHA256, 0);\n    if (memcmp(anonce, snonce, AIRPDCAP_WPA_NONCE_LEN) < 0) {\n        gcry_md_write(sha256_handle, anonce, AIRPDCAP_WPA_NONCE_LEN);\n        gcry_md_write(sha256_handle, snonce, AIRPDCAP_WPA_NONCE_LEN);\n    } else {\n        gcry_md_write(sha256_handle, snonce, AIRPDCAP_WPA_NONCE_LEN);\n        gcry_md_write(sha256_handle, anonce, AIRPDCAP_WPA_NONCE_LEN);\n    }\n    memcpy(key_input, gcry_md_read(sha256_handle, 0), 32);\n    gcry_md_close(sha256_handle);\n\n    /* Derive key */\n    bssid = &data[offset_link + 2];\n    initiator = &data[offset_link + 8];\n    responder = &data[offset_link + 14];\n    if (gcry_md_open(&hmac_handle, GCRY_MD_SHA256, GCRY_MD_FLAG_HMAC)) {\n        return AIRPDCAP_RET_UNSUCCESS;\n    }\n    if (gcry_md_setkey(hmac_handle, key_input, 32)) {\n        gcry_md_close(hmac_handle);\n        return AIRPDCAP_RET_UNSUCCESS;\n    }\n    gcry_md_putc(hmac_handle, 1);\n    gcry_md_putc(hmac_handle, 0);\n    gcry_md_write(hmac_handle, \"TDLS PMK\", 8);\n    if (memcmp(initiator, responder, AIRPDCAP_MAC_LEN) < 0) {\n          gcry_md_write(hmac_handle, initiator, AIRPDCAP_MAC_LEN);\n          gcry_md_write(hmac_handle, responder, AIRPDCAP_MAC_LEN);\n    } else {\n          gcry_md_write(hmac_handle, responder, AIRPDCAP_MAC_LEN);\n          gcry_md_write(hmac_handle, initiator, AIRPDCAP_MAC_LEN);\n    }\n    gcry_md_write(hmac_handle, bssid, AIRPDCAP_MAC_LEN);\n    gcry_md_putc(hmac_handle, 0);\n    gcry_md_putc(hmac_handle, 1);\n    memcpy(key_input, gcry_md_read(hmac_handle, 0), 32);\n    gcry_md_close(hmac_handle);\n\n    /* Check MIC */\n#if GCRYPT_VERSION_NUMBER >= 0x010600\n    if (gcry_mac_open(&cmac_handle, GCRY_MAC_CMAC_AES, 0, NULL)) {\n        return AIRPDCAP_RET_UNSUCCESS;\n    }\n    if (gcry_mac_setkey(cmac_handle, key_input, 16)) {\n        gcry_mac_close(cmac_handle);\n        return AIRPDCAP_RET_UNSUCCESS;\n    }\n    gcry_mac_write(cmac_handle, initiator, AIRPDCAP_MAC_LEN);\n    gcry_mac_write(cmac_handle, responder, AIRPDCAP_MAC_LEN);\n    gcry_mac_write(cmac_handle, &seq_num, 1);\n    gcry_mac_write(cmac_handle, &data[offset_link], data[offset_link + 1] + 2);\n    gcry_mac_write(cmac_handle, &data[offset_rsne], data[offset_rsne + 1] + 2);\n    gcry_mac_write(cmac_handle, &data[offset_timeout], data[offset_timeout + 1] + 2);\n    gcry_mac_write(cmac_handle, &data[offset_fte], 4);\n    gcry_mac_write(cmac_handle, zeros, 16);\n    cmac_write_len = data[offset_fte + 1] + 2;\n    if (cmac_write_len < 20) {\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapTDLSDeriveKey\", \"Bad MAC len\", AIRPDCAP_DEBUG_LEVEL_3);\n        gcry_mac_close(cmac_handle);\n        return AIRPDCAP_RET_UNSUCCESS;\n    }\n    gcry_mac_write(cmac_handle, &data[offset_fte + 20], cmac_write_len - 20);\n    if (gcry_mac_read(cmac_handle, mic, &cmac_len) != GPG_ERR_NO_ERROR) {\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapTDLSDeriveKey\", \"MAC read error\", AIRPDCAP_DEBUG_LEVEL_3);\n        gcry_mac_close(cmac_handle);\n        return AIRPDCAP_RET_UNSUCCESS;\n    }\n    if (memcmp(mic, &data[offset_fte + 4], 16)) {\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapTDLSDeriveKey\", \"MIC verification failed\", AIRPDCAP_DEBUG_LEVEL_3);\n        gcry_mac_close(cmac_handle);\n        return AIRPDCAP_RET_UNSUCCESS;\n    }\n    gcry_mac_close(cmac_handle);\n#else\n    AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapTDLSDeriveKey\", \"MIC verification failed, need libgcrypt >= 1.6\", AIRPDCAP_DEBUG_LEVEL_3);\n    return AIRPDCAP_RET_UNSUCCESS;\n#endif\n    memcpy(AIRPDCAP_GET_TK(sa->wpa.ptk), &key_input[16], 16);\n    memcpy(sa->wpa.nonce, snonce, AIRPDCAP_WPA_NONCE_LEN);\n    sa->validKey = TRUE;\n    sa->wpa.key_ver = AIRPDCAP_WPA_KEY_VER_AES_CCMP;\n    AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapTDLSDeriveKey\", \"MIC verified\", AIRPDCAP_DEBUG_LEVEL_3);\n    return  AIRPDCAP_RET_SUCCESS;\n}\n\n\n#ifdef __cplusplus\n}\n#endif\n\n/****************************************************************************/\n\n/*\n * Editor modelines\n *\n * Local Variables:\n * c-basic-offset: 4\n * tab-width: 8\n * indent-tabs-mode: nil\n * End:\n *\n * ex: set shiftwidth=4 tabstop=8 expandtab:\n * :indentSize=4:tabSize=8:noTabs=true:\n */\n", "patch": "@@ -351,7 +351,9 @@ AirPDcapDecryptWPABroadcastKey(const EAPOL_RSN_KEY *pEAPKey, guint8 *decryption_\n         }\n     }\n \n-    if (key_bytes_len < GROUP_KEY_MIN_LEN || key_bytes_len > eapol_len - sizeof(EAPOL_RSN_KEY)) {\n+    if ((key_bytes_len < GROUP_KEY_MIN_LEN) ||\n+        (eapol_len < sizeof(EAPOL_RSN_KEY)) ||\n+        (key_bytes_len > eapol_len - sizeof(EAPOL_RSN_KEY))) {\n         return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n     }\n ", "file_path": "files/2016_8\\59", "file_language": "c", "file_name": "epan/crypt/airpdcap.c", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}], "outdated": 0}
{"index": 21, "cve_id": "CVE-2016-5358", "cwe_id": ["CWE-20"], "cve_language": "C", "cve_description": "epan/dissectors/packet-pktap.c in the Ethernet dissector in Wireshark 2.x before 2.0.4 mishandles the packet-header data type, which allows remote attackers to cause a denial of service (application crash) via a crafted packet.", "cvss": "5.9", "publish_date": "August 7, 2016", "AV": "NETWORK", "AC": "HIGH", "PR": "NONE", "UI": "NONE", "S": "UNCHANGED", "C": "NONE", "I": "NONE", "A": "HIGH", "commit_id": "2c13e97d656c1c0ac4d76eb9d307664aae0e0cf7", "commit_message": "The WTAP_ENCAP_ETHERNET dissector needs to be passed a struct eth_phdr.\n\nWe now require that.  Make it so.\n\nBug: 12440\nChange-Id: Iffee520976b013800699bde3c6092a3e86be0d76\nReviewed-on: https://code.wireshark.org/review/15424\nReviewed-by: Guy Harris <guy@alum.mit.edu>", "commit_date": "2016-05-14T08:49:15Z", "project": "wireshark/wireshark", "url": "https://api.github.com/repos/wireshark/wireshark/commits/2c13e97d656c1c0ac4d76eb9d307664aae0e0cf7", "html_url": "https://github.com/wireshark/wireshark/commit/2c13e97d656c1c0ac4d76eb9d307664aae0e0cf7", "windows_before": "", "windows_after": "", "parents": [{"commit_id_before": "7d8c7230fe7f99a88b2fd27e53999c01c10bfa11", "url_before": "https://api.github.com/repos/wireshark/wireshark/commits/7d8c7230fe7f99a88b2fd27e53999c01c10bfa11", "html_url_before": "https://github.com/wireshark/wireshark/commit/7d8c7230fe7f99a88b2fd27e53999c01c10bfa11"}], "details": [{"raw_url": "https://github.com/wireshark/wireshark/raw/2c13e97d656c1c0ac4d76eb9d307664aae0e0cf7/epan/dissectors/packet-pktap.c", "code": "/*\n * packet-pktap.c\n * Routines for dissecting Apple's PKTAP header\n *\n * Wireshark - Network traffic analyzer\n * By Gerald Combs <gerald@wireshark.org>\n * Copyright 2007 Gerald Combs\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version 2\n * of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */\n\n#include \"config.h\"\n\n#include <epan/packet.h>\n#include <epan/expert.h>\n#include <wsutil/pint.h>\n\n\n#include \"packet-frame.h\"\n#include \"packet-eth.h\"\n#include \"packet-pktap.h\"\n\n/* Needed for wtap_pcap_encap_to_wtap_encap(). */\n#include <wiretap/pcap-encap.h>\n\nvoid proto_register_pktap(void);\nvoid proto_reg_handoff_pktap(void);\n\n/*\n * Apple's PKTAP header.\n */\n\n/*\n * Minimum header length.\n *\n * XXX - I'm assuming the header begins with a length field so that it\n * can be transparently *extended*, not so that fields in the current\n * header can be *omitted*.\n */\n#define MIN_PKTAP_HDR_LEN\t108\n\n/*\n * Record types.\n */\n#define PKT_REC_NONE\t0\t/* nothing follows the header */\n#define PKT_REC_PACKET\t1\t/* a packet follows the header */\n\n/* Protocol */\nstatic int proto_pktap = -1;\n\nstatic int hf_pktap_hdrlen = -1;\nstatic int hf_pktap_rectype = -1;\nstatic int hf_pktap_dlt = -1;\nstatic int hf_pktap_ifname = -1;\nstatic int hf_pktap_flags = -1;\nstatic int hf_pktap_pfamily = -1;\nstatic int hf_pktap_llhdrlen = -1;\nstatic int hf_pktap_lltrlrlen = -1;\nstatic int hf_pktap_pid = -1;\nstatic int hf_pktap_cmdname = -1;\nstatic int hf_pktap_svc_class = -1;\nstatic int hf_pktap_iftype = -1;\nstatic int hf_pktap_ifunit = -1;\nstatic int hf_pktap_epid = -1;\nstatic int hf_pktap_ecmdname = -1;\n\nstatic gint ett_pktap = -1;\n\nstatic expert_field ei_pktap_hdrlen_too_short = EI_INIT;\n\nstatic dissector_handle_t pktap_handle;\n\n/*\n * XXX - these are little-endian in the captures I've seen, but Apple\n * no longer make any big-endian machines (Macs use x86, iOS machines\n * use ARM and run it little-endian), so that might be by definition\n * or they might be host-endian.\n *\n * If a big-endian PKTAP file ever shows up, and it comes from a\n * big-endian machine, presumably these are host-endian, and we need\n * to just fetch the fields in host byte order here but byte-swap them\n * to host byte order in libwiretap.\n */\n\nvoid\ncapture_pktap(const guchar *pd, int len, packet_counts *ld)\n{\n\tguint32  hdrlen, rectype, dlt;\n\n\thdrlen = pletoh32(pd);\n\tif (hdrlen < MIN_PKTAP_HDR_LEN || !BYTES_ARE_IN_FRAME(0, len, hdrlen)) {\n\t\tld->other++;\n\t\treturn;\n\t}\n\n\trectype = pletoh32(pd+4);\n\tif (rectype != PKT_REC_PACKET) {\n\t\tld->other++;\n\t\treturn;\n\t}\n\n\tdlt = pletoh32(pd+4);\n\n\t/* XXX - We should probably combine this with capture_info.c:capture_info_packet() */\n\tswitch (dlt) {\n\n\tcase 1: /* DLT_EN10MB */\n\t\tcapture_eth(pd, hdrlen, len, ld);\n\t\treturn;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\tld->other++;\n}\n\nstatic void\ndissect_pktap(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)\n{\n\tproto_tree *pktap_tree = NULL;\n\tproto_item *ti = NULL;\n\ttvbuff_t *next_tvb;\n\tint offset = 0;\n\tguint32 pkt_len, rectype, dlt;\n\tint wtap_encap;\n\tstruct eth_phdr eth;\n\tvoid *phdr;\n\n\tcol_set_str(pinfo->cinfo, COL_PROTOCOL, \"PKTAP\");\n\tcol_clear(pinfo->cinfo, COL_INFO);\n\n\tpkt_len = tvb_get_letohl(tvb, offset);\n\tcol_add_fstr(pinfo->cinfo, COL_INFO, \"PKTAP, %u byte header\", pkt_len);\n\n\t/* Dissect the packet */\n\tti = proto_tree_add_item(tree, proto_pktap, tvb, offset, pkt_len, ENC_NA);\n\tpktap_tree = proto_item_add_subtree(ti, ett_pktap);\n\n\tproto_tree_add_item(pktap_tree, hf_pktap_hdrlen, tvb, offset, 4,\n\t    ENC_LITTLE_ENDIAN);\n\tif (pkt_len < MIN_PKTAP_HDR_LEN) {\n\t\tproto_tree_add_expert(tree, pinfo, &ei_pktap_hdrlen_too_short,\n\t\t    tvb, offset, 4);\n\t\treturn;\n\t}\n\toffset += 4;\n\n\tproto_tree_add_item(pktap_tree, hf_pktap_rectype, tvb, offset, 4,\n\t    ENC_LITTLE_ENDIAN);\n\trectype = tvb_get_letohl(tvb, offset);\n\toffset += 4;\n\tproto_tree_add_item(pktap_tree, hf_pktap_dlt, tvb, offset, 4,\n\t    ENC_LITTLE_ENDIAN);\n\tdlt = tvb_get_letohl(tvb, offset);\n\toffset += 4;\n\tproto_tree_add_item(pktap_tree, hf_pktap_ifname, tvb, offset, 24,\n\t    ENC_ASCII|ENC_NA);\n\toffset += 24;\n\tproto_tree_add_item(pktap_tree, hf_pktap_flags, tvb, offset, 4,\n\t    ENC_LITTLE_ENDIAN);\n\toffset += 4;\n\tproto_tree_add_item(pktap_tree, hf_pktap_pfamily, tvb, offset, 4,\n\t    ENC_LITTLE_ENDIAN);\n\toffset += 4;\n\tproto_tree_add_item(pktap_tree, hf_pktap_llhdrlen, tvb, offset, 4,\n\t    ENC_LITTLE_ENDIAN);\n\toffset += 4;\n\tproto_tree_add_item(pktap_tree, hf_pktap_lltrlrlen, tvb, offset, 4,\n\t    ENC_LITTLE_ENDIAN);\n\toffset += 4;\n\tproto_tree_add_item(pktap_tree, hf_pktap_pid, tvb, offset, 4,\n\t    ENC_LITTLE_ENDIAN);\n\toffset += 4;\n\tproto_tree_add_item(pktap_tree, hf_pktap_cmdname, tvb, offset, 20,\n\t    ENC_UTF_8|ENC_NA);\n\toffset += 20;\n\tproto_tree_add_item(pktap_tree, hf_pktap_svc_class, tvb, offset, 4,\n\t    ENC_LITTLE_ENDIAN);\n\toffset += 4;\n\tproto_tree_add_item(pktap_tree, hf_pktap_iftype, tvb, offset, 2,\n\t    ENC_LITTLE_ENDIAN);\n\toffset += 2;\n\tproto_tree_add_item(pktap_tree, hf_pktap_ifunit, tvb, offset, 2,\n\t    ENC_LITTLE_ENDIAN);\n\toffset += 2;\n\tproto_tree_add_item(pktap_tree, hf_pktap_epid, tvb, offset, 4,\n\t    ENC_LITTLE_ENDIAN);\n\toffset += 4;\n\tproto_tree_add_item(pktap_tree, hf_pktap_ecmdname, tvb, offset, 20,\n\t    ENC_UTF_8|ENC_NA);\n\t/*offset += 20;*/\n\n\tif (rectype == PKT_REC_PACKET) {\n\t\tnext_tvb = tvb_new_subset_remaining(tvb, pkt_len);\n\t\twtap_encap = wtap_pcap_encap_to_wtap_encap(dlt);\n\t\tswitch (wtap_encap) {\n\n\t\tcase WTAP_ENCAP_ETHERNET:\n\t\t\teth.fcs_len = -1;    /* Unknown whether we have an FCS */\n\t\t\tphdr = &eth;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tphdr = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tdissector_try_uint_new(wtap_encap_dissector_table,\n\t\t    wtap_encap, next_tvb, pinfo, tree, TRUE, phdr);\n\t}\n}\n\nvoid\nproto_register_pktap(void)\n{\n\tstatic hf_register_info hf[] = {\n\t  { &hf_pktap_hdrlen,\n\t    { \"Header length\", \"pktap.hdrlen\",\n\t      FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL } },\n\t  { &hf_pktap_rectype,\n\t    { \"Record type\", \"pktap.rectype\",\n\t      FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL } },\n\t  { &hf_pktap_dlt,\n\t    { \"DLT\", \"pktap.dlt\",\n\t      FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL } },\n\t  { &hf_pktap_ifname,\t/* fixed length *and* null-terminated */\n\t    { \"Interface name\", \"pktap.ifname\",\n\t      FT_STRINGZ, BASE_NONE, NULL, 0x0, NULL, HFILL } },\n\t  { &hf_pktap_flags,\n\t    { \"Flags\", \"pktap.flags\",\n\t      FT_UINT32, BASE_HEX, NULL, 0x0, NULL, HFILL } },\n\t  { &hf_pktap_pfamily,\n\t    { \"Protocol family\", \"pktap.pfamily\",\n\t      FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL } },\n\t  { &hf_pktap_llhdrlen,\n\t    { \"Link-layer header length\", \"pktap.llhdrlen\",\n\t      FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL } },\n\t  { &hf_pktap_lltrlrlen,\n\t    { \"Link-layer trailer length\", \"pktap.lltrlrlen\",\n\t      FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL } },\n\t  { &hf_pktap_pid,\n\t    { \"Process ID\", \"pktap.pid\",\n\t      FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL } },\n\t  { &hf_pktap_cmdname,\t/* fixed length *and* null-terminated */\n\t    { \"Command name\", \"pktap.cmdname\",\n\t      FT_STRINGZ, BASE_NONE, NULL, 0x0, NULL, HFILL } },\n\t  { &hf_pktap_svc_class,\n\t    { \"Service class\", \"pktap.svc_class\",\n\t      FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL } },\n\t  { &hf_pktap_iftype,\n\t    { \"Interface type\", \"pktap.iftype\",\n\t      FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL } },\n\t  { &hf_pktap_ifunit,\n\t    { \"Interface unit\", \"pktap.ifunit\",\n\t      FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL } },\n\t  { &hf_pktap_epid,\n\t    { \"Effective process ID\", \"pktap.epid\",\n\t      FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL } },\n\t  { &hf_pktap_ecmdname,\t/* fixed length *and* null-terminated */\n\t    { \"Effective command name\", \"pktap.ecmdname\",\n\t      FT_STRINGZ, BASE_NONE, NULL, 0x0, NULL, HFILL } },\n\t};\n\n\tstatic gint *ett[] = {\n\t\t&ett_pktap,\n\t};\n\n\tstatic ei_register_info ei[] = {\n\t    { &ei_pktap_hdrlen_too_short,\n\t      { \"pktap.hdrlen_too_short\", PI_MALFORMED, PI_ERROR,\n\t        \"Header length is too short\", EXPFILL }},\n\t};\n\n\texpert_module_t* expert_pktap;\n\n\tproto_pktap = proto_register_protocol(\"PKTAP packet header\", \"PKTAP\",\n\t    \"pktap\");\n\tproto_register_field_array(proto_pktap, hf, array_length(hf));\n\tproto_register_subtree_array(ett, array_length(ett));\n\texpert_pktap = expert_register_protocol(proto_pktap);\n\texpert_register_field_array(expert_pktap, ei, array_length(ei));\n\n\tpktap_handle = register_dissector(\"pktap\", dissect_pktap, proto_pktap);\n}\n\nvoid\nproto_reg_handoff_pktap(void)\n{\n\tdissector_add_uint(\"wtap_encap\", WTAP_ENCAP_PKTAP, pktap_handle);\n}\n\n/*\n * Editor modelines  -  http://www.wireshark.org/tools/modelines.html\n *\n * Local variables:\n * c-basic-offset: 8\n * tab-width: 8\n * indent-tabs-mode: t\n * End:\n *\n * vi: set shiftwidth=8 tabstop=8 noexpandtab:\n * :indentSize=8:tabSize=8:noTabs=false:\n */\n", "code_before": "/*\n * packet-pktap.c\n * Routines for dissecting Apple's PKTAP header\n *\n * Wireshark - Network traffic analyzer\n * By Gerald Combs <gerald@wireshark.org>\n * Copyright 2007 Gerald Combs\n *\n * SPDX-License-Identifier: GPL-2.0-or-later\n */\n\n#include \"config.h\"\n\n#include <epan/packet.h>\n#include <epan/capture_dissectors.h>\n#include <epan/expert.h>\n#include <wsutil/pint.h>\n\n#include \"packet-eth.h\"\n\nstatic dissector_handle_t pcap_pktdata_handle;\n\nvoid proto_register_pktap(void);\nvoid proto_reg_handoff_pktap(void);\n\n/*\n * Apple's PKTAP header.\n */\n\n/*\n * Minimum header length.\n *\n * XXX - I'm assuming the header begins with a length field so that it\n * can be transparently *extended*, not so that fields in the current\n * header can be *omitted*.\n */\n#define MIN_PKTAP_HDR_LEN\t108\n\n/*\n * Record types.\n */\n#define PKT_REC_NONE\t0\t/* nothing follows the header */\n#define PKT_REC_PACKET\t1\t/* a packet follows the header */\n\n/* Protocol */\nstatic int proto_pktap;\n\nstatic int hf_pktap_hdrlen;\nstatic int hf_pktap_rectype;\nstatic int hf_pktap_dlt;\nstatic int hf_pktap_ifname;\nstatic int hf_pktap_flags;\nstatic int hf_pktap_pfamily;\nstatic int hf_pktap_llhdrlen;\nstatic int hf_pktap_lltrlrlen;\nstatic int hf_pktap_pid;\nstatic int hf_pktap_cmdname;\nstatic int hf_pktap_svc_class;\nstatic int hf_pktap_iftype;\nstatic int hf_pktap_ifunit;\nstatic int hf_pktap_epid;\nstatic int hf_pktap_ecmdname;\n\nstatic int ett_pktap;\n\nstatic expert_field ei_pktap_hdrlen_too_short;\n\nstatic dissector_handle_t pktap_handle;\nstatic capture_dissector_handle_t eth_cap_handle;\n\n/*\n * XXX - these are only little-endian because they've been created on\n * little-endian machines; the code in bsd/net/pktap.c in XNU writes\n * the structure out in host byte order.\n *\n * We haven't been treating it as host-endian in libpcap and libwiretap,\n * i.e. we haven't been byte-swapping its members when reading it on\n * a machine whose byte order differs from the byte order of the machine\n * on which the file is being read.\n *\n * Furthermore, the header is extensible, so we don't necessarily know\n * what fields to swap.\n *\n * Fortunately, the length of the PKTAP header is a 32-bit field and is\n * *presumably* never going to be 65536 or greater, so if any of the upper\n * 16 bits appear to be set, it means we're looking at it in the wrong\n * byte order, and it's never going to be zero, so those bits *will* be\n * set if it's >= 65536, so we can determine its byte order.\n *\n * We should do that here.\n */\n\nstatic bool\ncapture_pktap(const unsigned char *pd, int offset _U_, int len, capture_packet_info_t *cpinfo, const union wtap_pseudo_header *pseudo_header _U_)\n{\n\tuint32_t hdrlen, rectype, dlt;\n\n\thdrlen = pletoh32(pd);\n\tif (hdrlen < MIN_PKTAP_HDR_LEN || !BYTES_ARE_IN_FRAME(0, len, hdrlen))\n\t\treturn false;\n\n\trectype = pletoh32(pd+4);\n\tif (rectype != PKT_REC_PACKET)\n\t\treturn false;\n\n\tdlt = pletoh32(pd+4);\n\n\t/* XXX - We should probably combine this with capture_info.c:capture_info_packet() */\n\tswitch (dlt) {\n\n\tcase 1: /* DLT_EN10MB */\n\t\treturn call_capture_dissector(eth_cap_handle, pd, hdrlen, len, cpinfo, pseudo_header);\n\n\t}\n\n\treturn false;\n}\n\nstatic int\ndissect_pktap(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\n{\n\tproto_tree *pktap_tree = NULL;\n\tproto_item *ti = NULL;\n\ttvbuff_t *next_tvb;\n\tint offset = 0;\n\tuint32_t pkt_len, rectype, dlt;\n\n\tcol_set_str(pinfo->cinfo, COL_PROTOCOL, \"PKTAP\");\n\tcol_clear(pinfo->cinfo, COL_INFO);\n\n\tpkt_len = tvb_get_letohl(tvb, offset);\n\tcol_add_fstr(pinfo->cinfo, COL_INFO, \"PKTAP, %u byte header\", pkt_len);\n\n\t/* Dissect the packet */\n\tti = proto_tree_add_item(tree, proto_pktap, tvb, offset, pkt_len, ENC_NA);\n\tpktap_tree = proto_item_add_subtree(ti, ett_pktap);\n\n\tproto_tree_add_item(pktap_tree, hf_pktap_hdrlen, tvb, offset, 4,\n\t    ENC_LITTLE_ENDIAN);\n\tif (pkt_len < MIN_PKTAP_HDR_LEN) {\n\t\tproto_tree_add_expert(tree, pinfo, &ei_pktap_hdrlen_too_short,\n\t\t    tvb, offset, 4);\n\t\treturn tvb_captured_length(tvb);\n\t}\n\toffset += 4;\n\n\tproto_tree_add_item(pktap_tree, hf_pktap_rectype, tvb, offset, 4,\n\t    ENC_LITTLE_ENDIAN);\n\trectype = tvb_get_letohl(tvb, offset);\n\toffset += 4;\n\tproto_tree_add_item(pktap_tree, hf_pktap_dlt, tvb, offset, 4,\n\t    ENC_LITTLE_ENDIAN);\n\tdlt = tvb_get_letohl(tvb, offset);\n\toffset += 4;\n\tproto_tree_add_item(pktap_tree, hf_pktap_ifname, tvb, offset, 24,\n\t    ENC_ASCII);\n\toffset += 24;\n\tproto_tree_add_item(pktap_tree, hf_pktap_flags, tvb, offset, 4,\n\t    ENC_LITTLE_ENDIAN);\n\toffset += 4;\n\tproto_tree_add_item(pktap_tree, hf_pktap_pfamily, tvb, offset, 4,\n\t    ENC_LITTLE_ENDIAN);\n\toffset += 4;\n\tproto_tree_add_item(pktap_tree, hf_pktap_llhdrlen, tvb, offset, 4,\n\t    ENC_LITTLE_ENDIAN);\n\toffset += 4;\n\tproto_tree_add_item(pktap_tree, hf_pktap_lltrlrlen, tvb, offset, 4,\n\t    ENC_LITTLE_ENDIAN);\n\toffset += 4;\n\tproto_tree_add_item(pktap_tree, hf_pktap_pid, tvb, offset, 4,\n\t    ENC_LITTLE_ENDIAN);\n\toffset += 4;\n\tproto_tree_add_item(pktap_tree, hf_pktap_cmdname, tvb, offset, 20,\n\t    ENC_UTF_8);\n\toffset += 20;\n\tproto_tree_add_item(pktap_tree, hf_pktap_svc_class, tvb, offset, 4,\n\t    ENC_LITTLE_ENDIAN);\n\toffset += 4;\n\tproto_tree_add_item(pktap_tree, hf_pktap_iftype, tvb, offset, 2,\n\t    ENC_LITTLE_ENDIAN);\n\toffset += 2;\n\tproto_tree_add_item(pktap_tree, hf_pktap_ifunit, tvb, offset, 2,\n\t    ENC_LITTLE_ENDIAN);\n\toffset += 2;\n\tproto_tree_add_item(pktap_tree, hf_pktap_epid, tvb, offset, 4,\n\t    ENC_LITTLE_ENDIAN);\n\toffset += 4;\n\tproto_tree_add_item(pktap_tree, hf_pktap_ecmdname, tvb, offset, 20,\n\t    ENC_UTF_8);\n\t/*offset += 20;*/\n\n\tif (rectype == PKT_REC_PACKET) {\n\t\tnext_tvb = tvb_new_subset_remaining(tvb, pkt_len);\n\t\tcall_dissector_with_data(pcap_pktdata_handle, next_tvb,\n\t\t    pinfo, tree, &dlt);\n\t}\n\treturn tvb_captured_length(tvb);\n}\n\nvoid\nproto_register_pktap(void)\n{\n\tstatic hf_register_info hf[] = {\n\t  { &hf_pktap_hdrlen,\n\t    { \"Header length\", \"pktap.hdrlen\",\n\t      FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL } },\n\t  { &hf_pktap_rectype,\n\t    { \"Record type\", \"pktap.rectype\",\n\t      FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL } },\n\t  { &hf_pktap_dlt,\n\t    { \"DLT\", \"pktap.dlt\",\n\t      FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL } },\n\t  { &hf_pktap_ifname,\t/* fixed length *and* null-terminated */\n\t    { \"Interface name\", \"pktap.ifname\",\n\t      FT_STRINGZ, BASE_NONE, NULL, 0x0, NULL, HFILL } },\n\t  { &hf_pktap_flags,\n\t    { \"Flags\", \"pktap.flags\",\n\t      FT_UINT32, BASE_HEX, NULL, 0x0, NULL, HFILL } },\n\t  { &hf_pktap_pfamily,\n\t    { \"Protocol family\", \"pktap.pfamily\",\n\t      FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL } },\n\t  { &hf_pktap_llhdrlen,\n\t    { \"Link-layer header length\", \"pktap.llhdrlen\",\n\t      FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL } },\n\t  { &hf_pktap_lltrlrlen,\n\t    { \"Link-layer trailer length\", \"pktap.lltrlrlen\",\n\t      FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL } },\n\t  { &hf_pktap_pid,\n\t    { \"Process ID\", \"pktap.pid\",\n\t      FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL } },\n\t  { &hf_pktap_cmdname,\t/* fixed length *and* null-terminated */\n\t    { \"Command name\", \"pktap.cmdname\",\n\t      FT_STRINGZ, BASE_NONE, NULL, 0x0, NULL, HFILL } },\n\t  { &hf_pktap_svc_class,\n\t    { \"Service class\", \"pktap.svc_class\",\n\t      FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL } },\n\t  { &hf_pktap_iftype,\n\t    { \"Interface type\", \"pktap.iftype\",\n\t      FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL } },\n\t  { &hf_pktap_ifunit,\n\t    { \"Interface unit\", \"pktap.ifunit\",\n\t      FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL } },\n\t  { &hf_pktap_epid,\n\t    { \"Effective process ID\", \"pktap.epid\",\n\t      FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL } },\n\t  { &hf_pktap_ecmdname,\t/* fixed length *and* null-terminated */\n\t    { \"Effective command name\", \"pktap.ecmdname\",\n\t      FT_STRINGZ, BASE_NONE, NULL, 0x0, NULL, HFILL } },\n\t};\n\n\tstatic int *ett[] = {\n\t\t&ett_pktap,\n\t};\n\n\tstatic ei_register_info ei[] = {\n\t    { &ei_pktap_hdrlen_too_short,\n\t      { \"pktap.hdrlen_too_short\", PI_MALFORMED, PI_ERROR,\n\t        \"Header length is too short\", EXPFILL }},\n\t};\n\n\texpert_module_t* expert_pktap;\n\n\tproto_pktap = proto_register_protocol(\"PKTAP packet header\", \"PKTAP\",\n\t    \"pktap\");\n\tproto_register_field_array(proto_pktap, hf, array_length(hf));\n\tproto_register_subtree_array(ett, array_length(ett));\n\texpert_pktap = expert_register_protocol(proto_pktap);\n\texpert_register_field_array(expert_pktap, ei, array_length(ei));\n\n\tpktap_handle = register_dissector(\"pktap\", dissect_pktap, proto_pktap);\n}\n\nvoid\nproto_reg_handoff_pktap(void)\n{\n\tcapture_dissector_handle_t pktap_cap_handle;\n\n\tdissector_add_uint(\"wtap_encap\", WTAP_ENCAP_PKTAP, pktap_handle);\n\n\tpcap_pktdata_handle = find_dissector_add_dependency(\"pcap_pktdata\", proto_pktap);\n\n\t/* XXX - WTAP_ENCAP_USER2 to handle Mavericks' botch wherein it\n\t\tuses DLT_USER2 for PKTAP; if you are using DLT_USER2 for your\n\t\town purposes, feel free to call your own capture_ routine for\n\t\tWTAP_ENCAP_USER2. */\n\tpktap_cap_handle = create_capture_dissector_handle(capture_pktap, proto_pktap);\n\tcapture_dissector_add_uint(\"wtap_encap\", WTAP_ENCAP_PKTAP, pktap_cap_handle);\n\tcapture_dissector_add_uint(\"wtap_encap\", WTAP_ENCAP_USER2, pktap_cap_handle);\n\n\teth_cap_handle = find_capture_dissector(\"eth\");\n}\n\n/*\n * Editor modelines  -  https://www.wireshark.org/tools/modelines.html\n *\n * Local variables:\n * c-basic-offset: 8\n * tab-width: 8\n * indent-tabs-mode: t\n * End:\n *\n * vi: set shiftwidth=8 tabstop=8 noexpandtab:\n * :indentSize=8:tabSize=8:noTabs=false:\n */\n", "patch": "@@ -135,6 +135,9 @@ dissect_pktap(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)\n \ttvbuff_t *next_tvb;\n \tint offset = 0;\n \tguint32 pkt_len, rectype, dlt;\n+\tint wtap_encap;\n+\tstruct eth_phdr eth;\n+\tvoid *phdr;\n \n \tcol_set_str(pinfo->cinfo, COL_PROTOCOL, \"PKTAP\");\n \tcol_clear(pinfo->cinfo, COL_INFO);\n@@ -202,8 +205,20 @@ dissect_pktap(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)\n \n \tif (rectype == PKT_REC_PACKET) {\n \t\tnext_tvb = tvb_new_subset_remaining(tvb, pkt_len);\n-\t\tdissector_try_uint(wtap_encap_dissector_table,\n-\t\t    wtap_pcap_encap_to_wtap_encap(dlt), next_tvb, pinfo, tree);\n+\t\twtap_encap = wtap_pcap_encap_to_wtap_encap(dlt);\n+\t\tswitch (wtap_encap) {\n+\n+\t\tcase WTAP_ENCAP_ETHERNET:\n+\t\t\teth.fcs_len = -1;    /* Unknown whether we have an FCS */\n+\t\t\tphdr = &eth;\n+\t\t\tbreak;\n+\n+\t\tdefault:\n+\t\t\tphdr = NULL;\n+\t\t\tbreak;\n+\t\t}\n+\t\tdissector_try_uint_new(wtap_encap_dissector_table,\n+\t\t    wtap_encap, next_tvb, pinfo, tree, TRUE, phdr);\n \t}\n }\n ", "file_path": "files/2016_8\\60", "file_language": "c", "file_name": "epan/dissectors/packet-pktap.c", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}, {"raw_url": "https://github.com/wireshark/wireshark/raw/2c13e97d656c1c0ac4d76eb9d307664aae0e0cf7/epan/dissectors/packet-ppi.c", "code": "/*\n * packet-ppi.c\n * Routines for PPI Packet Header dissection\n *\n * Wireshark - Network traffic analyzer\n * By Gerald Combs <gerald@wireshark.org>\n * Copyright 2007 Gerald Combs\n *\n * Copyright (c) 2006 CACE Technologies, Davis (California)\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the project nor the names of its contributors\n *    may be used to endorse or promote products derived from this software\n *    without specific prior written permission.\n *\n * Alternatively, this software may be distributed under the terms of the\n * GNU General Public License (\"GPL\") version 2 as published by the Free\n * Software Foundation.\n *\n * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n *\n *\n * Dustin Johnson - Dustin@Dustinj.us, Dustin.Johnson@cacetech.com\n *     May 7, 2008 - Added 'Aggregation Extension' and '802.3 Extension'\n */\n\n\n#include \"config.h\"\n\n#include <epan/packet.h>\n#include <epan/exceptions.h>\n#include <epan/ptvcursor.h>\n#include <epan/prefs.h>\n#include <epan/expert.h>\n#include <epan/reassemble.h>\n#include <wsutil/frequency-utils.h>\n#include <wsutil/pint.h>\n\n/* Needed for wtap_pcap_encap_to_wtap_encap(). */\n#include <wiretap/pcap-encap.h>\n\n#include \"packet-frame.h\"\n#include \"packet-eth.h\"\n#include \"packet-ieee80211.h\"\n#include \"packet-ppi.h\"\n\n/*\n * Per-Packet Information (PPI) header.\n * See the PPI Packet Header documentation at http://www.cacetech.com/documents\n * for details.\n */\n\n/*\n * PPI headers have the following format:\n *\n * ,---------------------------------------------------------.\n * | PPH | PFH 1 | Field data 1 | PFH 2 | Field data 2 | ... |\n * `---------------------------------------------------------'\n *\n * The PPH struct has the following format:\n *\n * typedef struct ppi_packetheader {\n *     guint8  pph_version;     // Version.  Currently 0\n *     guint8  pph_flags;       // Flags.\n *     guint16 pph_len; // Length of entire message, including this header and TLV payload.\n *     guint32 pph_dlt; // libpcap Data Link Type of the captured packet data.\n * } ppi_packetheader_t;\n *\n * The PFH struct has the following format:\n *\n * typedef struct ppi_fieldheader {\n *     guint16 pfh_type;        // Type\n *     guint16 pfh_datalen;     // Length of data\n * } ppi_fieldheader_t;\n *\n * Anyone looking to add their own PPI dissector would probably do well to imitate the GPS\n * ones separation into a distinct file.  Here is a step by step guide:\n * 1) add the number you received to the enum ppi_field_type declaration.\n * 2) Add a value string for your number into vs_ppi_field_type\n * 3) declare a dissector handle by the ppi_gps_handle, and initialize it inside proto_reg_handoff\n * 4) add  case inside dissect_ppi to call your new handle.\n * 5) Write your parser, and get it loaded.\n * Following these steps will result in less churn inside the ppi proper parser, and avoid namespace issues.\n */\n\n\n#define PPI_PADDED (1 << 0)\n\n#define PPI_V0_HEADER_LEN 8\n#define PPI_80211_COMMON_LEN 20\n#define PPI_80211N_MAC_LEN 12\n#define PPI_80211N_MAC_PHY_OFF 9\n#define PPI_80211N_MAC_PHY_LEN 48\n#define PPI_AGGREGATION_EXTENSION_LEN 4\n#define PPI_8023_EXTENSION_LEN 8\n\n#define PPI_FLAG_ALIGN 0x01\n#define IS_PPI_FLAG_ALIGN(x) ((x) & PPI_FLAG_ALIGN)\n\n#define DOT11_FLAG_HAVE_FCS     0x0001\n#define DOT11_FLAG_TSF_TIMER_MS 0x0002\n#define DOT11_FLAG_FCS_INVALID  0x0004\n#define DOT11_FLAG_PHY_ERROR    0x0008\n\n#define DOT11N_FLAG_GREENFIELD      0x0001\n#define DOT11N_FLAG_HT40            0x0002\n#define DOT11N_FLAG_SHORT_GI        0x0004\n#define DOT11N_FLAG_DUPLICATE_RX    0x0008\n#define DOT11N_FLAG_IS_AGGREGATE    0x0010\n#define DOT11N_FLAG_MORE_AGGREGATES 0x0020\n#define DOT11N_FLAG_AGG_CRC_ERROR   0x0040\n\n#define DOT11N_IS_AGGREGATE(flags)      (flags & DOT11N_FLAG_IS_AGGREGATE)\n#define DOT11N_MORE_AGGREGATES(flags)   ( \\\n    (flags & DOT11N_FLAG_MORE_AGGREGATES) && \\\n    !(flags & DOT11N_FLAG_AGG_CRC_ERROR))\n#define AGGREGATE_MAX 65535\n#define AMPDU_MAX 16383\n\n/* XXX - Start - Copied from packet-radiotap.c */\n/* Channel flags. */\n#define IEEE80211_CHAN_TURBO    0x0010  /* Turbo channel */\n#define IEEE80211_CHAN_CCK      0x0020  /* CCK channel */\n#define IEEE80211_CHAN_OFDM     0x0040  /* OFDM channel */\n#define IEEE80211_CHAN_2GHZ     0x0080  /* 2 GHz spectrum channel. */\n#define IEEE80211_CHAN_5GHZ     0x0100  /* 5 GHz spectrum channel */\n#define IEEE80211_CHAN_PASSIVE  0x0200  /* Only passive scan allowed */\n#define IEEE80211_CHAN_DYN      0x0400  /* Dynamic CCK-OFDM channel */\n#define IEEE80211_CHAN_GFSK     0x0800  /* GFSK channel (FHSS PHY) */\n\n#define\tIEEE80211_CHAN_ALL \\\n\t(IEEE80211_CHAN_2GHZ | IEEE80211_CHAN_5GHZ | IEEE80211_CHAN_GFSK | \\\n         IEEE80211_CHAN_CCK | IEEE80211_CHAN_OFDM | IEEE80211_CHAN_DYN)\n#define\tIEEE80211_CHAN_ALLTURBO \\\n\t(IEEE80211_CHAN_ALL | IEEE80211_CHAN_TURBO)\n\n/*\n * Useful combinations of channel characteristics.\n */\n#define IEEE80211_CHAN_FHSS \\\n        (IEEE80211_CHAN_2GHZ | IEEE80211_CHAN_GFSK)\n#define\tIEEE80211_CHAN_DSSS \\\n\t(IEEE80211_CHAN_2GHZ)\n#define IEEE80211_CHAN_A \\\n        (IEEE80211_CHAN_5GHZ | IEEE80211_CHAN_OFDM)\n#define IEEE80211_CHAN_B \\\n        (IEEE80211_CHAN_2GHZ | IEEE80211_CHAN_CCK)\n#define IEEE80211_CHAN_PUREG \\\n        (IEEE80211_CHAN_2GHZ | IEEE80211_CHAN_OFDM)\n#define IEEE80211_CHAN_G \\\n        (IEEE80211_CHAN_2GHZ | IEEE80211_CHAN_DYN)\n#define\tIEEE80211_CHAN_108A \\\n\t(IEEE80211_CHAN_A | IEEE80211_CHAN_TURBO)\n#define IEEE80211_CHAN_108G \\\n        (IEEE80211_CHAN_G | IEEE80211_CHAN_TURBO)\n#define IEEE80211_CHAN_108PUREG \\\n        (IEEE80211_CHAN_PUREG | IEEE80211_CHAN_TURBO)\n/* XXX - End - Copied from packet-radiotap.c */\n\nvoid proto_register_ppi(void);\nvoid proto_reg_handoff_ppi(void);\n\ntypedef enum {\n    /* 0 - 29999: Public types */\n    PPI_80211_COMMON          =  2,\n    PPI_80211N_MAC            =  3,\n    PPI_80211N_MAC_PHY        =  4,\n    PPI_SPECTRUM_MAP          =  5,\n    PPI_PROCESS_INFO          =  6,\n    PPI_CAPTURE_INFO          =  7,\n    PPI_AGGREGATION_EXTENSION =  8,\n    PPI_8023_EXTENSION        =  9,\n    /* 11 - 29999: RESERVED */\n\n    /* 30000 - 65535: Private types */\n    INTEL_CORP_PRIVATE           = 30000,\n    MOHAMED_THAGA_PRIVATE        = 30001,\n    PPI_GPS_INFO                 = 30002, /* 30002 - 30005 described in PPI-GEOLOCATION specifcation */\n    PPI_VECTOR_INFO              = 30003, /* currently available in draft from. jellch@harris.com */\n    PPI_SENSOR_INFO              = 30004,\n    PPI_ANTENNA_INFO             = 30005,\n    FNET_PRIVATE                 = 0xC017,\n    CACE_PRIVATE                 = 0xCACE\n    /* All others RESERVED.  Contact the WinPcap team for an assignment */\n} ppi_field_type;\n\n/* Protocol */\nstatic int proto_ppi = -1;\n\n/* Packet header */\nstatic int hf_ppi_head_version = -1;\nstatic int hf_ppi_head_flags = -1;\nstatic int hf_ppi_head_flag_alignment = -1;\nstatic int hf_ppi_head_flag_reserved = -1;\nstatic int hf_ppi_head_len = -1;\nstatic int hf_ppi_head_dlt = -1;\n\n/* Field header */\nstatic int hf_ppi_field_type = -1;\nstatic int hf_ppi_field_len = -1;\n\n/* 802.11 Common */\nstatic int hf_80211_common_tsft = -1;\nstatic int hf_80211_common_flags = -1;\nstatic int hf_80211_common_flags_fcs = -1;\nstatic int hf_80211_common_flags_tsft = -1;\nstatic int hf_80211_common_flags_fcs_valid = -1;\nstatic int hf_80211_common_flags_phy_err = -1;\nstatic int hf_80211_common_rate = -1;\nstatic int hf_80211_common_chan_freq = -1;\nstatic int hf_80211_common_chan_flags = -1;\n\nstatic int hf_80211_common_chan_flags_turbo = -1;\nstatic int hf_80211_common_chan_flags_cck = -1;\nstatic int hf_80211_common_chan_flags_ofdm = -1;\nstatic int hf_80211_common_chan_flags_2ghz = -1;\nstatic int hf_80211_common_chan_flags_5ghz = -1;\nstatic int hf_80211_common_chan_flags_passive = -1;\nstatic int hf_80211_common_chan_flags_dynamic = -1;\nstatic int hf_80211_common_chan_flags_gfsk = -1;\n\nstatic int hf_80211_common_fhss_hopset = -1;\nstatic int hf_80211_common_fhss_pattern = -1;\nstatic int hf_80211_common_dbm_antsignal = -1;\nstatic int hf_80211_common_dbm_antnoise = -1;\n\n/* 802.11n MAC */\nstatic int hf_80211n_mac_flags = -1;\nstatic int hf_80211n_mac_flags_greenfield = -1;\nstatic int hf_80211n_mac_flags_ht20_40 = -1;\nstatic int hf_80211n_mac_flags_rx_guard_interval = -1;\nstatic int hf_80211n_mac_flags_duplicate_rx = -1;\nstatic int hf_80211n_mac_flags_more_aggregates = -1;\nstatic int hf_80211n_mac_flags_aggregate = -1;\nstatic int hf_80211n_mac_flags_delimiter_crc_after = -1;\nstatic int hf_80211n_mac_ampdu_id = -1;\nstatic int hf_80211n_mac_num_delimiters = -1;\nstatic int hf_80211n_mac_reserved = -1;\n\n/* 802.11n MAC+PHY */\nstatic int hf_80211n_mac_phy_mcs = -1;\nstatic int hf_80211n_mac_phy_num_streams = -1;\nstatic int hf_80211n_mac_phy_rssi_combined = -1;\nstatic int hf_80211n_mac_phy_rssi_ant0_ctl = -1;\nstatic int hf_80211n_mac_phy_rssi_ant1_ctl = -1;\nstatic int hf_80211n_mac_phy_rssi_ant2_ctl = -1;\nstatic int hf_80211n_mac_phy_rssi_ant3_ctl = -1;\nstatic int hf_80211n_mac_phy_rssi_ant0_ext = -1;\nstatic int hf_80211n_mac_phy_rssi_ant1_ext = -1;\nstatic int hf_80211n_mac_phy_rssi_ant2_ext = -1;\nstatic int hf_80211n_mac_phy_rssi_ant3_ext = -1;\nstatic int hf_80211n_mac_phy_ext_chan_freq = -1;\nstatic int hf_80211n_mac_phy_ext_chan_flags = -1;\nstatic int hf_80211n_mac_phy_ext_chan_flags_turbo = -1;\nstatic int hf_80211n_mac_phy_ext_chan_flags_cck = -1;\nstatic int hf_80211n_mac_phy_ext_chan_flags_ofdm = -1;\nstatic int hf_80211n_mac_phy_ext_chan_flags_2ghz = -1;\nstatic int hf_80211n_mac_phy_ext_chan_flags_5ghz = -1;\nstatic int hf_80211n_mac_phy_ext_chan_flags_passive = -1;\nstatic int hf_80211n_mac_phy_ext_chan_flags_dynamic = -1;\nstatic int hf_80211n_mac_phy_ext_chan_flags_gfsk = -1;\nstatic int hf_80211n_mac_phy_dbm_ant0signal = -1;\nstatic int hf_80211n_mac_phy_dbm_ant0noise = -1;\nstatic int hf_80211n_mac_phy_dbm_ant1signal = -1;\nstatic int hf_80211n_mac_phy_dbm_ant1noise = -1;\nstatic int hf_80211n_mac_phy_dbm_ant2signal = -1;\nstatic int hf_80211n_mac_phy_dbm_ant2noise = -1;\nstatic int hf_80211n_mac_phy_dbm_ant3signal = -1;\nstatic int hf_80211n_mac_phy_dbm_ant3noise = -1;\nstatic int hf_80211n_mac_phy_evm0 = -1;\nstatic int hf_80211n_mac_phy_evm1 = -1;\nstatic int hf_80211n_mac_phy_evm2 = -1;\nstatic int hf_80211n_mac_phy_evm3 = -1;\n\n/* 802.11n-Extensions A-MPDU fragments */\nstatic int hf_ampdu_reassembled_in = -1;\n/* static int hf_ampdu_segments = -1; */\nstatic int hf_ampdu_segment = -1;\nstatic int hf_ampdu_count  = -1;\n\n/* Spectrum-Map */\nstatic int hf_spectrum_map = -1;\n\n/* Process-Info */\nstatic int hf_process_info = -1;\n\n/* Capture-Info */\nstatic int hf_capture_info = -1;\n\n/* Aggregation Extension */\nstatic int hf_aggregation_extension_interface_id = -1;\n\n/* 802.3 Extension */\nstatic int hf_8023_extension_flags = -1;\nstatic int hf_8023_extension_flags_fcs_present = -1;\nstatic int hf_8023_extension_errors = -1;\nstatic int hf_8023_extension_errors_fcs = -1;\nstatic int hf_8023_extension_errors_sequence = -1;\nstatic int hf_8023_extension_errors_symbol = -1;\nstatic int hf_8023_extension_errors_data = -1;\n\n/* Generated from convert_proto_tree_add_text.pl */\nstatic int hf_ppi_antenna = -1;\nstatic int hf_ppi_harris = -1;\nstatic int hf_ppi_reserved = -1;\nstatic int hf_ppi_vector = -1;\nstatic int hf_ppi_fnet = -1;\nstatic int hf_ppi_gps = -1;\n\nstatic gint ett_ppi_pph = -1;\nstatic gint ett_ppi_flags = -1;\nstatic gint ett_dot11_common = -1;\nstatic gint ett_dot11_common_flags = -1;\nstatic gint ett_dot11_common_channel_flags = -1;\nstatic gint ett_dot11n_mac = -1;\nstatic gint ett_dot11n_mac_flags = -1;\nstatic gint ett_dot11n_mac_phy = -1;\nstatic gint ett_dot11n_mac_phy_ext_channel_flags = -1;\nstatic gint ett_ampdu_segments = -1;\nstatic gint ett_ampdu = -1;\nstatic gint ett_ampdu_segment  = -1;\nstatic gint ett_aggregation_extension = -1;\nstatic gint ett_8023_extension = -1;\nstatic gint ett_8023_extension_flags = -1;\nstatic gint ett_8023_extension_errors = -1;\n\n/* Generated from convert_proto_tree_add_text.pl */\nstatic expert_field ei_ppi_invalid_length = EI_INIT;\n\nstatic dissector_handle_t ppi_handle;\n\nstatic dissector_handle_t data_handle;\nstatic dissector_handle_t ieee80211_radio_handle;\nstatic dissector_handle_t ppi_gps_handle, ppi_vector_handle, ppi_sensor_handle, ppi_antenna_handle;\nstatic dissector_handle_t ppi_fnet_handle;\n\nstatic const true_false_string tfs_ppi_head_flag_alignment = { \"32-bit aligned\", \"Not aligned\" };\nstatic const true_false_string tfs_tsft_ms = { \"milliseconds\", \"microseconds\" };\nstatic const true_false_string tfs_ht20_40 = { \"HT40\", \"HT20\" };\nstatic const true_false_string tfs_phy_error = { \"PHY error\", \"No errors\"};\n\nstatic const value_string vs_ppi_field_type[] = {\n    {PPI_80211_COMMON,          \"802.11-Common\"},\n    {PPI_80211N_MAC,            \"802.11n MAC Extensions\"},\n    {PPI_80211N_MAC_PHY,        \"802.11n MAC+PHY Extensions\"},\n    {PPI_SPECTRUM_MAP,          \"Spectrum-Map\"},\n    {PPI_PROCESS_INFO,          \"Process-Info\"},\n    {PPI_CAPTURE_INFO,          \"Capture-Info\"},\n    {PPI_AGGREGATION_EXTENSION, \"Aggregation Extension\"},\n    {PPI_8023_EXTENSION,        \"802.3 Extension\"},\n\n    {INTEL_CORP_PRIVATE,        \"Intel Corporation (private)\"},\n    {MOHAMED_THAGA_PRIVATE,     \"Mohamed Thaga (private)\"},\n    {PPI_GPS_INFO,              \"GPS Tagging\"},\n    {PPI_VECTOR_INFO,           \"Vector Tagging\"},\n    {PPI_SENSOR_INFO,           \"Sensor tagging\"},\n    {PPI_ANTENNA_INFO,          \"Antenna Tagging\"},\n    {FNET_PRIVATE,              \"FlukeNetworks (private)\"},\n    {CACE_PRIVATE,              \"CACE Technologies (private)\"},\n    {0, NULL}\n};\n\n/* Table for A-MPDU reassembly */\nstatic reassembly_table ampdu_reassembly_table;\n\n/* Reassemble A-MPDUs? */\nstatic gboolean ppi_ampdu_reassemble = TRUE;\n\n\nvoid\ncapture_ppi(const guchar *pd, int len, packet_counts *ld)\n{\n    guint32  dlt;\n    guint    ppi_len;\n\n    ppi_len = pletoh16(pd+2);\n    if(ppi_len < PPI_V0_HEADER_LEN || !BYTES_ARE_IN_FRAME(0, len, ppi_len)) {\n        ld->other++;\n        return;\n    }\n\n    dlt = pletoh32(pd+4);\n\n    /* XXX - We should probably combine this with capture_info.c:capture_info_packet() */\n    switch(dlt) {\n        case 1: /* DLT_EN10MB */\n            capture_eth(pd, ppi_len, len, ld);\n            return;\n        case 105: /* DLT_DLT_IEEE802_11 */\n            capture_ieee80211(pd, ppi_len, len, ld);\n            return;\n        default:\n            break;\n    }\n\n    ld->other++;\n}\n\nstatic void\nptvcursor_add_invalid_check(ptvcursor_t *csr, int hf, gint len, guint64 invalid_val) {\n    proto_item *ti;\n    guint64     val = invalid_val;\n\n    switch (len) {\n        case 8:\n            val = tvb_get_letoh64(ptvcursor_tvbuff(csr),\n                ptvcursor_current_offset(csr));\n            break;\n        case 4:\n            val = tvb_get_letohl(ptvcursor_tvbuff(csr),\n                ptvcursor_current_offset(csr));\n            break;\n        case 2:\n            val = tvb_get_letohs(ptvcursor_tvbuff(csr),\n                ptvcursor_current_offset(csr));\n            break;\n        case 1:\n            val = tvb_get_guint8(ptvcursor_tvbuff(csr),\n                ptvcursor_current_offset(csr));\n            break;\n        default:\n            DISSECTOR_ASSERT_NOT_REACHED();\n    }\n\n    ti = ptvcursor_add(csr, hf, len, ENC_LITTLE_ENDIAN);\n    if (val == invalid_val)\n        proto_item_append_text(ti, \" [invalid]\");\n}\n\nstatic void\nadd_ppi_field_header(tvbuff_t *tvb, proto_tree *tree, int *offset)\n{\n    ptvcursor_t *csr;\n\n    csr = ptvcursor_new(tree, tvb, *offset);\n    ptvcursor_add(csr, hf_ppi_field_type, 2, ENC_LITTLE_ENDIAN);\n    ptvcursor_add(csr, hf_ppi_field_len, 2, ENC_LITTLE_ENDIAN);\n    ptvcursor_free(csr);\n    *offset=ptvcursor_current_offset(csr);\n}\n\n/* XXX - The main dissection function in the 802.11 dissector has the same name. */\nstatic void\ndissect_80211_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, int offset, int data_len, struct ieee_802_11_phdr *phdr)\n{\n    proto_tree  *ftree;\n    proto_item  *ti;\n    ptvcursor_t *csr;\n    guint64      tsft_raw;\n    guint        rate_raw;\n    guint        rate_kbps;\n    guint32      common_flags;\n    guint16      common_frequency;\n    guint16      chan_flags;\n    gint8        dbm_value;\n    gchar       *chan_str;\n\n    ftree = proto_tree_add_subtree(tree, tvb, offset, data_len, ett_dot11_common, NULL, \"802.11-Common\");\n    add_ppi_field_header(tvb, ftree, &offset);\n    data_len -= 4; /* Subtract field header length */\n\n    if (data_len != PPI_80211_COMMON_LEN) {\n        proto_tree_add_expert_format(ftree, pinfo, &ei_ppi_invalid_length, tvb, offset, data_len, \"Invalid length: %u\", data_len);\n        THROW(ReportedBoundsError);\n    }\n\n    common_flags = tvb_get_letohs(tvb, offset + 8);\n    if (common_flags & DOT11_FLAG_HAVE_FCS)\n        phdr->fcs_len = 4;\n    else\n        phdr->fcs_len = 0;\n\n    csr = ptvcursor_new(ftree, tvb, offset);\n\n    tsft_raw = tvb_get_letoh64(tvb, offset);\n    if (tsft_raw != 0) {\n        phdr->presence_flags |= PHDR_802_11_HAS_TSF_TIMESTAMP;\n        if (common_flags & DOT11_FLAG_TSF_TIMER_MS)\n            phdr->tsf_timestamp = tsft_raw * 1000;\n        else\n            phdr->tsf_timestamp = tsft_raw;\n    }\n\n    ptvcursor_add_invalid_check(csr, hf_80211_common_tsft, 8, 0);\n\n    ptvcursor_add_with_subtree(csr, hf_80211_common_flags, 2, ENC_LITTLE_ENDIAN,\n                               ett_dot11_common_flags);\n    ptvcursor_add_no_advance(csr, hf_80211_common_flags_fcs, 2, ENC_LITTLE_ENDIAN);\n    ptvcursor_add_no_advance(csr, hf_80211_common_flags_tsft, 2, ENC_LITTLE_ENDIAN);\n    ptvcursor_add_no_advance(csr, hf_80211_common_flags_fcs_valid, 2, ENC_LITTLE_ENDIAN);\n    ptvcursor_add(csr, hf_80211_common_flags_phy_err, 2, ENC_LITTLE_ENDIAN);\n    ptvcursor_pop_subtree(csr);\n\n    rate_raw = tvb_get_letohs(tvb, ptvcursor_current_offset(csr));\n    if (rate_raw != 0) {\n        phdr->presence_flags |= PHDR_802_11_HAS_DATA_RATE;\n        phdr->data_rate = rate_raw;\n    }\n    rate_kbps = rate_raw * 500;\n    ti = proto_tree_add_uint_format(ftree, hf_80211_common_rate, tvb,\n                                    ptvcursor_current_offset(csr), 2, rate_kbps, \"Rate: %.1f Mbps\",\n                                    rate_kbps / 1000.0);\n    if (rate_kbps == 0)\n        proto_item_append_text(ti, \" [invalid]\");\n    col_add_fstr(pinfo->cinfo, COL_TX_RATE, \"%.1f Mbps\", rate_kbps / 1000.0);\n    ptvcursor_advance(csr, 2);\n\n    common_frequency = tvb_get_letohs(ptvcursor_tvbuff(csr), ptvcursor_current_offset(csr));\n    if (common_frequency != 0) {\n        gint calc_channel;\n\n        phdr->presence_flags |= PHDR_802_11_HAS_FREQUENCY;\n        phdr->frequency = common_frequency;\n        calc_channel = ieee80211_mhz_to_chan(common_frequency);\n        if (calc_channel != -1) {\n            phdr->presence_flags |= PHDR_802_11_HAS_CHANNEL;\n            phdr->channel = calc_channel;\n        }\n    }\n    chan_str = ieee80211_mhz_to_str(common_frequency);\n    proto_tree_add_uint_format_value(ptvcursor_tree(csr), hf_80211_common_chan_freq, ptvcursor_tvbuff(csr),\n                               ptvcursor_current_offset(csr), 2, common_frequency, \"%s\", chan_str);\n    col_add_fstr(pinfo->cinfo, COL_FREQ_CHAN, \"%s\", chan_str);\n    g_free(chan_str);\n    ptvcursor_advance(csr, 2);\n\n    chan_flags = tvb_get_letohs(ptvcursor_tvbuff(csr), ptvcursor_current_offset(csr));\n    switch (chan_flags & IEEE80211_CHAN_ALLTURBO) {\n\n    case IEEE80211_CHAN_FHSS:\n        phdr->phy = PHDR_802_11_PHY_11_FHSS;\n        phdr->phy_info.info_11_fhss.presence_flags =\n            PHDR_802_11_FHSS_HAS_HOP_SET |\n            PHDR_802_11_FHSS_HAS_HOP_PATTERN;\n        break;\n\n    case IEEE80211_CHAN_DSSS:\n        phdr->phy = PHDR_802_11_PHY_11_DSSS;\n        break;\n\n    case IEEE80211_CHAN_A:\n        phdr->phy = PHDR_802_11_PHY_11A;\n        phdr->phy_info.info_11a.presence_flags = PHDR_802_11A_HAS_TURBO_TYPE;\n        phdr->phy_info.info_11a.turbo_type = PHDR_802_11A_TURBO_TYPE_NORMAL;\n        break;\n\n    case IEEE80211_CHAN_B:\n        phdr->phy = PHDR_802_11_PHY_11B;\n        phdr->phy_info.info_11b.presence_flags = 0;\n        break;\n\n    case IEEE80211_CHAN_PUREG:\n        phdr->phy = PHDR_802_11_PHY_11G;\n        phdr->phy_info.info_11g.presence_flags = PHDR_802_11G_HAS_MODE;\n        phdr->phy_info.info_11g.mode = PHDR_802_11G_MODE_NORMAL;\n        break;\n\n    case IEEE80211_CHAN_G:\n        phdr->phy = PHDR_802_11_PHY_11G;\n        phdr->phy_info.info_11g.presence_flags = PHDR_802_11G_HAS_MODE;\n        phdr->phy_info.info_11g.mode = PHDR_802_11G_MODE_NORMAL;\n        break;\n\n    case IEEE80211_CHAN_108A:\n        phdr->phy = PHDR_802_11_PHY_11A;\n        phdr->phy_info.info_11a.presence_flags = PHDR_802_11A_HAS_TURBO_TYPE;\n        /* We assume non-STURBO is dynamic turbo */\n        phdr->phy_info.info_11a.turbo_type = PHDR_802_11A_TURBO_TYPE_DYNAMIC_TURBO;\n        break;\n\n    case IEEE80211_CHAN_108PUREG:\n        phdr->phy = PHDR_802_11_PHY_11G;\n        phdr->phy_info.info_11g.presence_flags = PHDR_802_11G_HAS_MODE;\n        phdr->phy_info.info_11g.mode = PHDR_802_11G_MODE_SUPER_G;\n        break;\n    }\n    ptvcursor_add_with_subtree(csr, hf_80211_common_chan_flags, 2, ENC_LITTLE_ENDIAN,\n                               ett_dot11_common_channel_flags);\n    ptvcursor_add_no_advance(csr, hf_80211_common_chan_flags_turbo, 2, ENC_LITTLE_ENDIAN);\n    ptvcursor_add_no_advance(csr, hf_80211_common_chan_flags_cck, 2, ENC_LITTLE_ENDIAN);\n    ptvcursor_add_no_advance(csr, hf_80211_common_chan_flags_ofdm, 2, ENC_LITTLE_ENDIAN);\n    ptvcursor_add_no_advance(csr, hf_80211_common_chan_flags_2ghz, 2, ENC_LITTLE_ENDIAN);\n    ptvcursor_add_no_advance(csr, hf_80211_common_chan_flags_5ghz, 2, ENC_LITTLE_ENDIAN);\n    ptvcursor_add_no_advance(csr, hf_80211_common_chan_flags_passive, 2, ENC_LITTLE_ENDIAN);\n    ptvcursor_add_no_advance(csr, hf_80211_common_chan_flags_dynamic, 2, ENC_LITTLE_ENDIAN);\n    ptvcursor_add(csr, hf_80211_common_chan_flags_gfsk, 2, ENC_LITTLE_ENDIAN);\n    ptvcursor_pop_subtree(csr);\n\n\n    if (phdr->phy == PHDR_802_11_PHY_11_FHSS)\n        phdr->phy_info.info_11_fhss.hop_set = tvb_get_guint8(ptvcursor_tvbuff(csr), ptvcursor_current_offset(csr));\n    ptvcursor_add(csr, hf_80211_common_fhss_hopset, 1, ENC_LITTLE_ENDIAN);\n    if (phdr->phy == PHDR_802_11_PHY_11_FHSS)\n        phdr->phy_info.info_11_fhss.hop_pattern = tvb_get_guint8(ptvcursor_tvbuff(csr), ptvcursor_current_offset(csr));\n    ptvcursor_add(csr, hf_80211_common_fhss_pattern, 1, ENC_LITTLE_ENDIAN);\n\n    dbm_value = (gint8) tvb_get_guint8(tvb, ptvcursor_current_offset(csr));\n    if (dbm_value != -128 && dbm_value != 0) {\n        /*\n         * XXX - the spec says -128 is invalid, presumably meaning \"use\n         * -128 if you don't have the signal strength\", but some captures\n         * have 0 for noise, presumably meaning it's incorrectly being\n         * used for \"don't have it\", so we check for it as well.\n         */\n        col_add_fstr(pinfo->cinfo, COL_RSSI, \"%d dBm\", dbm_value);\n        phdr->presence_flags |= PHDR_802_11_HAS_SIGNAL_DBM;\n        phdr->signal_dbm = dbm_value;\n    }\n    ptvcursor_add_invalid_check(csr, hf_80211_common_dbm_antsignal, 1, 0x80); /* -128 */\n\n    dbm_value = (gint8) tvb_get_guint8(tvb, ptvcursor_current_offset(csr));\n    if (dbm_value != -128 && dbm_value != 0) {\n        /*\n         * XXX - the spec says -128 is invalid, presumably meaning \"use\n         * -128 if you don't have the noise level\", but some captures\n         * have 0, presumably meaning it's incorrectly being used for\n         * \"don't have it\", so we check for it as well.\n         */\n        phdr->presence_flags |= PHDR_802_11_HAS_NOISE_DBM;\n        phdr->noise_dbm = dbm_value;\n    }\n    ptvcursor_add_invalid_check(csr, hf_80211_common_dbm_antnoise, 1, 0x80);\n\n    ptvcursor_free(csr);\n}\n\nstatic void\ndissect_80211n_mac(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, int offset, int data_len, gboolean add_subtree, guint32 *n_mac_flags, guint32 *ampdu_id, struct ieee_802_11_phdr *phdr)\n{\n    proto_tree  *ftree       = tree;\n    ptvcursor_t *csr;\n    int          subtree_off = add_subtree ? 4 : 0;\n    guint32      flags;\n\n    phdr->phy = PHDR_802_11_PHY_11N;\n\n    *n_mac_flags = tvb_get_letohl(tvb, offset + subtree_off);\n    *ampdu_id = tvb_get_letohl(tvb, offset + 4 + subtree_off);\n\n    if (add_subtree) {\n        ftree = proto_tree_add_subtree(tree, tvb, offset, data_len, ett_dot11n_mac, NULL, \"802.11n MAC\");\n        add_ppi_field_header(tvb, ftree, &offset);\n        data_len -= 4; /* Subtract field header length */\n    }\n\n    if (data_len != PPI_80211N_MAC_LEN) {\n        proto_tree_add_expert_format(ftree, pinfo, &ei_ppi_invalid_length, tvb, offset, data_len, \"Invalid length: %u\", data_len);\n        THROW(ReportedBoundsError);\n    }\n\n    csr = ptvcursor_new(ftree, tvb, offset);\n\n    flags = tvb_get_letohl(tvb, ptvcursor_current_offset(csr));\n    phdr->phy_info.info_11n.presence_flags = PHDR_802_11N_HAS_SHORT_GI|PHDR_802_11N_HAS_GREENFIELD;\n    phdr->phy_info.info_11n.short_gi = ((flags & DOT11N_FLAG_SHORT_GI) != 0);\n    phdr->phy_info.info_11n.greenfield = ((flags & DOT11N_FLAG_GREENFIELD) != 0);\n    ptvcursor_add_with_subtree(csr, hf_80211n_mac_flags, 4, ENC_LITTLE_ENDIAN,\n                               ett_dot11n_mac_flags);\n    ptvcursor_add_no_advance(csr, hf_80211n_mac_flags_greenfield, 4, ENC_LITTLE_ENDIAN);\n    ptvcursor_add_no_advance(csr, hf_80211n_mac_flags_ht20_40, 4, ENC_LITTLE_ENDIAN);\n    ptvcursor_add_no_advance(csr, hf_80211n_mac_flags_rx_guard_interval, 4, ENC_LITTLE_ENDIAN);\n    ptvcursor_add_no_advance(csr, hf_80211n_mac_flags_duplicate_rx, 4, ENC_LITTLE_ENDIAN);\n    ptvcursor_add_no_advance(csr, hf_80211n_mac_flags_aggregate, 4, ENC_LITTLE_ENDIAN);\n    ptvcursor_add_no_advance(csr, hf_80211n_mac_flags_more_aggregates, 4, ENC_LITTLE_ENDIAN);\n    ptvcursor_add(csr, hf_80211n_mac_flags_delimiter_crc_after, 4, ENC_LITTLE_ENDIAN); /* Last */\n    ptvcursor_pop_subtree(csr);\n\n    ptvcursor_add(csr, hf_80211n_mac_ampdu_id, 4, ENC_LITTLE_ENDIAN);\n    ptvcursor_add(csr, hf_80211n_mac_num_delimiters, 1, ENC_LITTLE_ENDIAN);\n\n    if (add_subtree) {\n        ptvcursor_add(csr, hf_80211n_mac_reserved, 3, ENC_LITTLE_ENDIAN);\n    }\n\n    ptvcursor_free(csr);\n}\n\nstatic void\ndissect_80211n_mac_phy(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, int offset, int data_len, guint32 *n_mac_flags, guint32 *ampdu_id, struct ieee_802_11_phdr *phdr)\n{\n    proto_tree  *ftree;\n    proto_item  *ti;\n    ptvcursor_t *csr;\n    guint8       mcs;\n    guint8       ness;\n    guint16      ext_frequency;\n    gchar       *chan_str;\n\n    ftree = proto_tree_add_subtree(tree, tvb, offset, data_len, ett_dot11n_mac_phy, NULL, \"802.11n MAC+PHY\");\n    add_ppi_field_header(tvb, ftree, &offset);\n    data_len -= 4; /* Subtract field header length */\n\n    if (data_len != PPI_80211N_MAC_PHY_LEN) {\n        proto_tree_add_expert_format(ftree, pinfo, &ei_ppi_invalid_length, tvb, offset, data_len, \"Invalid length: %u\", data_len);\n        THROW(ReportedBoundsError);\n    }\n\n    dissect_80211n_mac(tvb, pinfo, ftree, offset, PPI_80211N_MAC_LEN,\n                       FALSE, n_mac_flags, ampdu_id, phdr);\n    offset += PPI_80211N_MAC_PHY_OFF;\n\n    csr = ptvcursor_new(ftree, tvb, offset);\n\n    mcs = tvb_get_guint8(tvb, ptvcursor_current_offset(csr));\n    if (mcs != 255) {\n        phdr->phy_info.info_11n.presence_flags |= PHDR_802_11N_HAS_MCS_INDEX;\n        phdr->phy_info.info_11n.mcs_index = mcs;\n    }\n    ptvcursor_add_invalid_check(csr, hf_80211n_mac_phy_mcs, 1, 255);\n\n    ness = tvb_get_guint8(tvb, ptvcursor_current_offset(csr));\n    phdr->phy_info.info_11n.presence_flags |= PHDR_802_11N_HAS_NESS;\n    phdr->phy_info.info_11n.ness = ness;\n    ti = ptvcursor_add(csr, hf_80211n_mac_phy_num_streams, 1, ENC_LITTLE_ENDIAN);\n    if (tvb_get_guint8(tvb, ptvcursor_current_offset(csr) - 1) == 0)\n        proto_item_append_text(ti, \" (unknown)\");\n    ptvcursor_add_invalid_check(csr, hf_80211n_mac_phy_rssi_combined, 1, 255);\n    ptvcursor_add_invalid_check(csr, hf_80211n_mac_phy_rssi_ant0_ctl, 1, 255);\n    ptvcursor_add_invalid_check(csr, hf_80211n_mac_phy_rssi_ant1_ctl, 1, 255);\n    ptvcursor_add_invalid_check(csr, hf_80211n_mac_phy_rssi_ant2_ctl, 1, 255);\n    ptvcursor_add_invalid_check(csr, hf_80211n_mac_phy_rssi_ant3_ctl, 1, 255);\n    ptvcursor_add_invalid_check(csr, hf_80211n_mac_phy_rssi_ant0_ext, 1, 255);\n    ptvcursor_add_invalid_check(csr, hf_80211n_mac_phy_rssi_ant1_ext, 1, 255);\n    ptvcursor_add_invalid_check(csr, hf_80211n_mac_phy_rssi_ant2_ext, 1, 255);\n    ptvcursor_add_invalid_check(csr, hf_80211n_mac_phy_rssi_ant3_ext, 1, 255);\n\n    ext_frequency = tvb_get_letohs(ptvcursor_tvbuff(csr), ptvcursor_current_offset(csr));\n    chan_str = ieee80211_mhz_to_str(ext_frequency);\n    proto_tree_add_uint_format(ptvcursor_tree(csr), hf_80211n_mac_phy_ext_chan_freq, ptvcursor_tvbuff(csr),\n                               ptvcursor_current_offset(csr), 2, ext_frequency, \"Ext. Channel frequency: %s\", chan_str);\n    g_free(chan_str);\n    ptvcursor_advance(csr, 2);\n\n    ptvcursor_add_with_subtree(csr, hf_80211n_mac_phy_ext_chan_flags, 2, ENC_LITTLE_ENDIAN,\n                               ett_dot11n_mac_phy_ext_channel_flags);\n    ptvcursor_add_no_advance(csr, hf_80211n_mac_phy_ext_chan_flags_turbo, 2, ENC_LITTLE_ENDIAN);\n    ptvcursor_add_no_advance(csr, hf_80211n_mac_phy_ext_chan_flags_cck, 2, ENC_LITTLE_ENDIAN);\n    ptvcursor_add_no_advance(csr, hf_80211n_mac_phy_ext_chan_flags_ofdm, 2, ENC_LITTLE_ENDIAN);\n    ptvcursor_add_no_advance(csr, hf_80211n_mac_phy_ext_chan_flags_2ghz, 2, ENC_LITTLE_ENDIAN);\n    ptvcursor_add_no_advance(csr, hf_80211n_mac_phy_ext_chan_flags_5ghz, 2, ENC_LITTLE_ENDIAN);\n    ptvcursor_add_no_advance(csr, hf_80211n_mac_phy_ext_chan_flags_passive, 2, ENC_LITTLE_ENDIAN);\n    ptvcursor_add_no_advance(csr, hf_80211n_mac_phy_ext_chan_flags_dynamic, 2, ENC_LITTLE_ENDIAN);\n    ptvcursor_add(csr, hf_80211n_mac_phy_ext_chan_flags_gfsk, 2, ENC_LITTLE_ENDIAN);\n    ptvcursor_pop_subtree(csr);\n\n    ptvcursor_add_invalid_check(csr, hf_80211n_mac_phy_dbm_ant0signal, 1, 0x80); /* -128 */\n    ptvcursor_add_invalid_check(csr, hf_80211n_mac_phy_dbm_ant0noise, 1, 0x80);\n    ptvcursor_add_invalid_check(csr, hf_80211n_mac_phy_dbm_ant1signal, 1, 0x80);\n    ptvcursor_add_invalid_check(csr, hf_80211n_mac_phy_dbm_ant1noise, 1, 0x80);\n    ptvcursor_add_invalid_check(csr, hf_80211n_mac_phy_dbm_ant2signal, 1, 0x80);\n    ptvcursor_add_invalid_check(csr, hf_80211n_mac_phy_dbm_ant2noise, 1, 0x80);\n    ptvcursor_add_invalid_check(csr, hf_80211n_mac_phy_dbm_ant3signal, 1, 0x80);\n    ptvcursor_add_invalid_check(csr, hf_80211n_mac_phy_dbm_ant3noise, 1, 0x80);\n    ptvcursor_add_invalid_check(csr, hf_80211n_mac_phy_evm0, 4, 0);\n    ptvcursor_add_invalid_check(csr, hf_80211n_mac_phy_evm1, 4, 0);\n    ptvcursor_add_invalid_check(csr, hf_80211n_mac_phy_evm2, 4, 0);\n    ptvcursor_add_invalid_check(csr, hf_80211n_mac_phy_evm3, 4, 0);\n\n    ptvcursor_free(csr);\n}\n\nstatic void\ndissect_aggregation_extension(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, int offset, int data_len)\n{\n    proto_tree *ftree;\n    ptvcursor_t *csr;\n\n    ftree = proto_tree_add_subtree(tree, tvb, offset, data_len, ett_aggregation_extension, NULL, \"Aggregation Extension\");\n    add_ppi_field_header(tvb, ftree, &offset);\n    data_len -= 4; /* Subtract field header length */\n\n    if (data_len != PPI_AGGREGATION_EXTENSION_LEN) {\n        proto_tree_add_expert_format(ftree, pinfo, &ei_ppi_invalid_length, tvb, offset, data_len, \"Invalid length: %u\", data_len);\n        THROW(ReportedBoundsError);\n    }\n\n    csr = ptvcursor_new(ftree, tvb, offset);\n\n    ptvcursor_add(csr, hf_aggregation_extension_interface_id, 4, ENC_LITTLE_ENDIAN); /* Last */\n    ptvcursor_free(csr);\n}\n\nstatic void\ndissect_8023_extension(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, int offset, int data_len)\n{\n    proto_tree  *ftree;\n    ptvcursor_t *csr;\n\n    ftree = proto_tree_add_subtree(tree, tvb, offset, data_len, ett_8023_extension, NULL, \"802.3 Extension\");\n    add_ppi_field_header(tvb, ftree, &offset);\n    data_len -= 4; /* Subtract field header length */\n\n    if (data_len != PPI_8023_EXTENSION_LEN) {\n        proto_tree_add_expert_format(ftree, pinfo, &ei_ppi_invalid_length, tvb, offset, data_len, \"Invalid length: %u\", data_len);\n        THROW(ReportedBoundsError);\n    }\n\n    csr = ptvcursor_new(ftree, tvb, offset);\n\n    ptvcursor_add_with_subtree(csr, hf_8023_extension_flags, 4, ENC_LITTLE_ENDIAN, ett_8023_extension_flags);\n    ptvcursor_add(csr, hf_8023_extension_flags_fcs_present, 4, ENC_LITTLE_ENDIAN);\n    ptvcursor_pop_subtree(csr);\n\n    ptvcursor_add_with_subtree(csr, hf_8023_extension_errors, 4, ENC_LITTLE_ENDIAN, ett_8023_extension_errors);\n    ptvcursor_add_no_advance(csr, hf_8023_extension_errors_fcs, 4, ENC_LITTLE_ENDIAN);\n    ptvcursor_add_no_advance(csr, hf_8023_extension_errors_sequence, 4, ENC_LITTLE_ENDIAN);\n    ptvcursor_add_no_advance(csr, hf_8023_extension_errors_symbol, 4, ENC_LITTLE_ENDIAN);\n    ptvcursor_add(csr, hf_8023_extension_errors_data, 4, ENC_LITTLE_ENDIAN);\n    ptvcursor_pop_subtree(csr);\n\n    ptvcursor_free(csr);\n}\n\n\n#define PADDING4(x) ((((x + 3) >> 2) << 2) - x)\n#define ADD_BASIC_TAG(hf_tag) \\\n    if (tree)   \\\n        proto_tree_add_item(ppi_tree, hf_tag, tvb, offset, data_len, ENC_NA)\n\nstatic void\ndissect_ppi(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)\n{\n    proto_tree    *ppi_tree    = NULL, *ppi_flags_tree = NULL, *seg_tree = NULL, *ampdu_tree = NULL;\n    proto_tree    *agg_tree    = NULL;\n    proto_item    *ti          = NULL;\n    tvbuff_t      *next_tvb;\n    int            offset      = 0;\n    guint          version, flags;\n    gint           tot_len, data_len;\n    guint          data_type;\n    guint32        dlt;\n    guint32        n_ext_flags = 0;\n    guint32        ampdu_id    = 0;\n    fragment_head *fd_head     = NULL;\n    fragment_item *ft_fdh      = NULL;\n    gint           mpdu_count  = 0;\n    gchar         *mpdu_str;\n    gboolean       first_mpdu  = TRUE;\n    guint          last_frame  = 0;\n    gint len_remain, /*pad_len = 0,*/ ampdu_len = 0;\n    struct ieee_802_11_phdr phdr;\n    int            wtap_encap;\n    struct eth_phdr eth;\n    void          *phdrp;\n\n    col_set_str(pinfo->cinfo, COL_PROTOCOL, \"PPI\");\n    col_clear(pinfo->cinfo, COL_INFO);\n\n    version = tvb_get_guint8(tvb, offset);\n    flags = tvb_get_guint8(tvb, offset + 1);\n\n    tot_len = tvb_get_letohs(tvb, offset+2);\n    dlt = tvb_get_letohl(tvb, offset+4);\n\n    col_add_fstr(pinfo->cinfo, COL_INFO, \"PPI version %u, %u bytes\",\n                 version, tot_len);\n\n    /* Dissect the packet */\n    if (tree) {\n        ti = proto_tree_add_protocol_format(tree, proto_ppi,\n                                            tvb, 0, tot_len, \"PPI version %u, %u bytes\", version, tot_len);\n        ppi_tree = proto_item_add_subtree(ti, ett_ppi_pph);\n        proto_tree_add_item(ppi_tree, hf_ppi_head_version,\n                            tvb, offset, 1, ENC_LITTLE_ENDIAN);\n\n        ti = proto_tree_add_item(ppi_tree, hf_ppi_head_flags,\n                                 tvb, offset + 1, 1, ENC_LITTLE_ENDIAN);\n        ppi_flags_tree = proto_item_add_subtree(ti, ett_ppi_flags);\n        proto_tree_add_item(ppi_flags_tree, hf_ppi_head_flag_alignment,\n                            tvb, offset + 1, 1, ENC_LITTLE_ENDIAN);\n        proto_tree_add_item(ppi_flags_tree, hf_ppi_head_flag_reserved,\n                            tvb, offset + 1, 1, ENC_LITTLE_ENDIAN);\n\n        proto_tree_add_item(ppi_tree, hf_ppi_head_len,\n                                 tvb, offset + 2, 2, ENC_LITTLE_ENDIAN);\n        proto_tree_add_item(ppi_tree, hf_ppi_head_dlt,\n                                 tvb, offset + 4, 4, ENC_LITTLE_ENDIAN);\n    }\n\n    tot_len -= PPI_V0_HEADER_LEN;\n    offset += 8;\n\n    /* We don't have any 802.11 metadata yet. */\n    memset(&phdr, 0, sizeof(phdr));\n    phdr.fcs_len = -1;\n    phdr.decrypted = FALSE;\n    phdr.datapad = FALSE;\n    phdr.phy = PHDR_802_11_PHY_UNKNOWN;\n    phdr.presence_flags = 0;\n\n    while (tot_len > 0) {\n        data_type = tvb_get_letohs(tvb, offset);\n        data_len = tvb_get_letohs(tvb, offset + 2) + 4;\n        tot_len -= data_len;\n\n        switch (data_type) {\n\n        case PPI_80211_COMMON:\n            dissect_80211_common(tvb, pinfo, ppi_tree, offset, data_len, &phdr);\n            break;\n\n        case PPI_80211N_MAC:\n            dissect_80211n_mac(tvb, pinfo, ppi_tree, offset, data_len,\n                TRUE, &n_ext_flags, &ampdu_id, &phdr);\n            break;\n\n        case PPI_80211N_MAC_PHY:\n            dissect_80211n_mac_phy(tvb, pinfo, ppi_tree, offset,\n                data_len, &n_ext_flags, &ampdu_id, &phdr);\n            break;\n\n        case PPI_SPECTRUM_MAP:\n            ADD_BASIC_TAG(hf_spectrum_map);\n            break;\n\n        case PPI_PROCESS_INFO:\n            ADD_BASIC_TAG(hf_process_info);\n            break;\n\n        case PPI_CAPTURE_INFO:\n            ADD_BASIC_TAG(hf_capture_info);\n            break;\n\n        case PPI_AGGREGATION_EXTENSION:\n            dissect_aggregation_extension(tvb, pinfo, ppi_tree, offset, data_len);\n            break;\n\n        case PPI_8023_EXTENSION:\n            dissect_8023_extension(tvb, pinfo, ppi_tree, offset, data_len);\n            break;\n\n        case PPI_GPS_INFO:\n            if (ppi_gps_handle == NULL)\n            {\n                proto_tree_add_item(ppi_tree, hf_ppi_gps, tvb, offset, data_len, ENC_NA);\n            }\n            else /* we found a suitable dissector */\n            {\n                /* skip over the ppi_fieldheader, and pass it off to the dedicated GPS dissetor */\n                next_tvb = tvb_new_subset(tvb, offset + 4, data_len - 4 , -1);\n                call_dissector(ppi_gps_handle, next_tvb, pinfo, ppi_tree);\n            }\n            break;\n\n        case PPI_VECTOR_INFO:\n            if (ppi_vector_handle == NULL)\n            {\n                proto_tree_add_item(ppi_tree, hf_ppi_vector, tvb, offset, data_len, ENC_NA);\n            }\n            else /* we found a suitable dissector */\n            {\n                /* skip over the ppi_fieldheader, and pass it off to the dedicated VECTOR dissetor */\n                next_tvb = tvb_new_subset(tvb, offset + 4, data_len - 4 , -1);\n                call_dissector(ppi_vector_handle, next_tvb, pinfo, ppi_tree);\n            }\n            break;\n\n        case PPI_SENSOR_INFO:\n            if (ppi_sensor_handle == NULL)\n            {\n                proto_tree_add_item(ppi_tree, hf_ppi_harris, tvb, offset, data_len, ENC_NA);\n            }\n            else /* we found a suitable dissector */\n            {\n                /* skip over the ppi_fieldheader, and pass it off to the dedicated SENSOR dissetor */\n                next_tvb = tvb_new_subset(tvb, offset + 4, data_len - 4 , -1);\n                call_dissector(ppi_sensor_handle, next_tvb, pinfo, ppi_tree);\n            }\n            break;\n\n        case PPI_ANTENNA_INFO:\n            if (ppi_antenna_handle == NULL)\n            {\n                proto_tree_add_item(ppi_tree, hf_ppi_antenna, tvb, offset, data_len, ENC_NA);\n            }\n            else /* we found a suitable dissector */\n            {\n                /* skip over the ppi_fieldheader, and pass it off to the dedicated ANTENNA dissetor */\n                next_tvb = tvb_new_subset(tvb, offset + 4, data_len - 4 , -1);\n                call_dissector(ppi_antenna_handle, next_tvb, pinfo, ppi_tree);\n            }\n            break;\n\n        case FNET_PRIVATE:\n            if (ppi_fnet_handle == NULL)\n            {\n                proto_tree_add_item(ppi_tree, hf_ppi_fnet, tvb, offset, data_len, ENC_NA);\n            }\n            else /* we found a suitable dissector */\n            {\n                /* skip over the ppi_fieldheader, and pass it off to the dedicated FNET dissetor */\n                next_tvb = tvb_new_subset(tvb, offset + 4, data_len - 4 , -1);\n                call_dissector(ppi_fnet_handle, next_tvb, pinfo, ppi_tree);\n            }\n            break;\n\n        default:\n            proto_tree_add_item(ppi_tree, hf_ppi_reserved, tvb, offset, data_len, ENC_NA);\n        }\n\n        offset += data_len;\n        if (IS_PPI_FLAG_ALIGN(flags)){\n            offset += PADDING4(offset);\n        }\n    }\n\n    if (ppi_ampdu_reassemble && DOT11N_IS_AGGREGATE(n_ext_flags)) {\n        len_remain = tvb_captured_length_remaining(tvb, offset);\n#if 0 /* XXX: pad_len never actually used ?? */\n        if (DOT11N_MORE_AGGREGATES(n_ext_flags)) {\n            pad_len = PADDING4(len_remain);\n        }\n#endif\n        pinfo->fragmented = TRUE;\n\n        /* Make sure we aren't going to go past AGGREGATE_MAX\n         * and caclulate our full A-MPDU length */\n        fd_head = fragment_get(&ampdu_reassembly_table, pinfo, ampdu_id, NULL);\n        while (fd_head) {\n            ampdu_len += fd_head->len + PADDING4(fd_head->len) + 4;\n            fd_head = fd_head->next;\n        }\n        if (ampdu_len > AGGREGATE_MAX) {\n            if (tree) {\n                proto_tree_add_expert_format(ppi_tree, pinfo, &ei_ppi_invalid_length, tvb, offset, -1, \"Aggregate length greater than maximum (%u)\", AGGREGATE_MAX);\n                THROW(ReportedBoundsError);\n            } else {\n                return;\n            }\n        }\n\n        /*\n         * Note that we never actually reassemble our A-MPDUs.  Doing\n         * so would require prepending each MPDU with an A-MPDU delimiter\n         * and appending it with padding, only to hand it off to some\n         * routine which would un-do the work we just did.  We're using\n         * the reassembly code to track MPDU sizes and frame numbers.\n         */\n        /*??fd_head = */fragment_add_seq_next(&ampdu_reassembly_table,\n            tvb, offset, pinfo, ampdu_id, NULL, len_remain, TRUE);\n        pinfo->fragmented = TRUE;\n\n        /* Do reassembly? */\n        fd_head = fragment_get(&ampdu_reassembly_table, pinfo, ampdu_id, NULL);\n\n        /* Show our fragments */\n        if (fd_head && tree) {\n            ft_fdh = fd_head;\n            /* List our fragments */\n            seg_tree = proto_tree_add_subtree_format(ppi_tree, tvb, offset, -1,\n                    ett_ampdu_segments, &ti, \"A-MPDU (%u bytes w/hdrs):\", ampdu_len);\n            PROTO_ITEM_SET_GENERATED(ti);\n\n            while (ft_fdh) {\n                if (ft_fdh->tvb_data && ft_fdh->len) {\n                    last_frame = ft_fdh->frame;\n                    if (!first_mpdu)\n                        proto_item_append_text(ti, \",\");\n                    first_mpdu = FALSE;\n                    proto_item_append_text(ti, \" #%u(%u)\",\n                        ft_fdh->frame, ft_fdh->len);\n                    proto_tree_add_uint_format(seg_tree, hf_ampdu_segment,\n                        tvb, 0, 0, last_frame,\n                        \"Frame: %u (%u byte%s)\",\n                        last_frame,\n                        ft_fdh->len,\n                        plurality(ft_fdh->len, \"\", \"s\"));\n                }\n                ft_fdh = ft_fdh->next;\n            }\n            if (last_frame && last_frame != pinfo->fd->num)\n                proto_tree_add_uint(seg_tree, hf_ampdu_reassembled_in,\n                    tvb, 0, 0, last_frame);\n        }\n\n        if (fd_head && !DOT11N_MORE_AGGREGATES(n_ext_flags)) {\n            if (tree) {\n                ti = proto_tree_add_protocol_format(tree,\n                    proto_get_id_by_filter_name(\"wlan_aggregate\"),\n                    tvb, 0, tot_len, \"IEEE 802.11 Aggregate MPDU\");\n                agg_tree = proto_item_add_subtree(ti, ett_ampdu);\n            }\n\n            while (fd_head) {\n                if (fd_head->tvb_data && fd_head->len) {\n                    mpdu_count++;\n                    mpdu_str = wmem_strdup_printf(wmem_packet_scope(), \"MPDU #%d\", mpdu_count);\n\n                    next_tvb = tvb_new_chain(tvb, fd_head->tvb_data);\n                    add_new_data_source(pinfo, next_tvb, mpdu_str);\n\n                    ampdu_tree = proto_tree_add_subtree(agg_tree, next_tvb, 0, -1, ett_ampdu_segment, NULL, mpdu_str);\n                    call_dissector_with_data(ieee80211_radio_handle, next_tvb, pinfo, ampdu_tree, &phdr);\n                }\n                fd_head = fd_head->next;\n            }\n            proto_tree_add_uint(seg_tree, hf_ampdu_count, tvb, 0, 0, mpdu_count);\n            pinfo->fragmented=FALSE;\n        } else {\n            next_tvb = tvb_new_subset_remaining(tvb, offset);\n            col_set_str(pinfo->cinfo, COL_PROTOCOL, \"IEEE 802.11n\");\n            col_set_str(pinfo->cinfo, COL_INFO, \"Unreassembled A-MPDU data\");\n            call_dissector(data_handle, next_tvb, pinfo, tree);\n        }\n        return;\n    }\n\n    next_tvb = tvb_new_subset_remaining(tvb, offset);\n    /*\n     * You can't just call an arbitrary subdissector based on a\n     * LINKTYPE_ value, because they may expect a particular\n     * pseudo-header to be passed to them.\n     *\n     * So we look for LINKTYPE_IEEE802_11, which is 105, and, if\n     * that's what the LINKTYPE_ value is, pass it a pointer\n     * to a struct ieee_802_11_phdr; otherwise, we pass it\n     * a null pointer - if it actually matters, we need to\n     * construct the appropriate pseudo-header and pass that.\n     */\n    if (dlt == 105) {\n        /* LINKTYPE_IEEE802_11 */\n        call_dissector_with_data(ieee80211_radio_handle, next_tvb, pinfo, tree, &phdr);\n    } else {\n        /* Everything else.  This will pass a NULL data argument. */\n        wtap_encap = wtap_pcap_encap_to_wtap_encap(dlt);\n        switch (wtap_encap) {\n\n        case WTAP_ENCAP_ETHERNET:\n            eth.fcs_len = -1;    /* Unknown whether we have an FCS */\n            phdrp = &eth;\n            break;\n\n        default:\n            phdrp = NULL;\n            break;\n        }\n        dissector_try_uint_new(wtap_encap_dissector_table,\n            wtap_encap, next_tvb, pinfo, tree, TRUE, phdrp);\n    }\n}\n\n/* Establish our beachead */\n\nstatic void\nampdu_reassemble_init(void)\n{\n    reassembly_table_init(&ampdu_reassembly_table,\n                          &addresses_reassembly_table_functions);\n}\n\nstatic void\nampdu_reassemble_cleanup(void)\n{\n    reassembly_table_destroy(&ampdu_reassembly_table);\n}\n\nvoid\nproto_register_ppi(void)\n{\n    static hf_register_info hf[] = {\n    { &hf_ppi_head_version,\n      { \"Version\", \"ppi.version\",\n        FT_UINT8, BASE_DEC, NULL, 0x0,\n        \"PPI header format version\", HFILL } },\n    { &hf_ppi_head_flags,\n      { \"Flags\", \"ppi.flags\",\n        FT_UINT8, BASE_HEX, NULL, 0x0,\n        \"PPI header flags\", HFILL } },\n    { &hf_ppi_head_flag_alignment,\n      { \"Alignment\", \"ppi.flags.alignment\",\n        FT_BOOLEAN, 8, TFS(&tfs_ppi_head_flag_alignment), 0x01,\n        \"PPI header flags - 32bit Alignment\", HFILL } },\n    { &hf_ppi_head_flag_reserved,\n      { \"Reserved\", \"ppi.flags.reserved\",\n        FT_UINT8, BASE_HEX, NULL, 0xFE,\n        \"PPI header flags - Reserved Flags\", HFILL } },\n    { &hf_ppi_head_len,\n       { \"Header length\", \"ppi.length\",\n         FT_UINT16, BASE_DEC, NULL, 0x0,\n         \"Length of header including payload\", HFILL } },\n    { &hf_ppi_head_dlt,\n       { \"DLT\", \"ppi.dlt\",\n         FT_UINT32, BASE_DEC, NULL, 0x0, \"libpcap Data Link Type (DLT) of the payload\", HFILL } },\n\n    { &hf_ppi_field_type,\n       { \"Field type\", \"ppi.field_type\",\n         FT_UINT16, BASE_DEC, VALS(vs_ppi_field_type), 0x0, \"PPI data field type\", HFILL } },\n    { &hf_ppi_field_len,\n       { \"Field length\", \"ppi.field_len\",\n         FT_UINT16, BASE_DEC, NULL, 0x0, \"PPI data field length\", HFILL } },\n\n    { &hf_80211_common_tsft,\n       { \"TSFT\", \"ppi.80211-common.tsft\",\n         FT_UINT64, BASE_DEC, NULL, 0x0, \"PPI 802.11-Common Timing Synchronization Function Timer (TSFT)\", HFILL } },\n    { &hf_80211_common_flags,\n       { \"Flags\", \"ppi.80211-common.flags\",\n         FT_UINT16, BASE_HEX, NULL, 0x0, \"PPI 802.11-Common Flags\", HFILL } },\n    { &hf_80211_common_flags_fcs,\n       { \"FCS present flag\", \"ppi.80211-common.flags.fcs\",\n         FT_BOOLEAN, 16, TFS(&tfs_present_absent), DOT11_FLAG_HAVE_FCS, \"PPI 802.11-Common Frame Check Sequence (FCS) Present Flag\", HFILL } },\n    { &hf_80211_common_flags_tsft,\n       { \"TSFT flag\", \"ppi.80211-common.flags.tsft\",\n         FT_BOOLEAN, 16, TFS(&tfs_tsft_ms), DOT11_FLAG_TSF_TIMER_MS, \"PPI 802.11-Common Timing Synchronization Function Timer (TSFT) msec/usec flag\", HFILL } },\n    { &hf_80211_common_flags_fcs_valid,\n       { \"FCS validity\", \"ppi.80211-common.flags.fcs-invalid\",\n         FT_BOOLEAN, 16, TFS(&tfs_invalid_valid), DOT11_FLAG_FCS_INVALID, \"PPI 802.11-Common Frame Check Sequence (FCS) Validity flag\", HFILL } },\n    { &hf_80211_common_flags_phy_err,\n       { \"PHY error flag\", \"ppi.80211-common.flags.phy-err\",\n         FT_BOOLEAN, 16, TFS(&tfs_phy_error), DOT11_FLAG_PHY_ERROR, \"PPI 802.11-Common Physical level (PHY) Error\", HFILL } },\n    { &hf_80211_common_rate,\n       { \"Data rate\", \"ppi.80211-common.rate\",\n         FT_UINT16, BASE_DEC, NULL, 0x0, \"PPI 802.11-Common Data Rate (x 500 Kbps)\", HFILL } },\n    { &hf_80211_common_chan_freq,\n       { \"Channel frequency\", \"ppi.80211-common.chan.freq\",\n         FT_UINT16, BASE_DEC, NULL, 0x0,\n        \"PPI 802.11-Common Channel Frequency\", HFILL } },\n    { &hf_80211_common_chan_flags,\n       { \"Channel flags\", \"ppi.80211-common.chan.flags\",\n         FT_UINT16, BASE_HEX, NULL, 0x0, \"PPI 802.11-Common Channel Flags\", HFILL } },\n\n    { &hf_80211_common_chan_flags_turbo,\n       { \"Turbo\", \"ppi.80211-common.chan.flags.turbo\",\n         FT_BOOLEAN, 16, NULL, IEEE80211_CHAN_TURBO, \"PPI 802.11-Common Channel Flags Turbo\", HFILL } },\n    { &hf_80211_common_chan_flags_cck,\n       { \"Complementary Code Keying (CCK)\", \"ppi.80211-common.chan.flags.cck\",\n         FT_BOOLEAN, 16, NULL, IEEE80211_CHAN_CCK, \"PPI 802.11-Common Channel Flags Complementary Code Keying (CCK) Modulation\", HFILL } },\n    { &hf_80211_common_chan_flags_ofdm,\n       { \"Orthogonal Frequency-Division Multiplexing (OFDM)\", \"ppi.80211-common.chan.flags.ofdm\",\n         FT_BOOLEAN, 16, NULL, IEEE80211_CHAN_OFDM, \"PPI 802.11-Common Channel Flags Orthogonal Frequency-Division Multiplexing (OFDM)\", HFILL } },\n    { &hf_80211_common_chan_flags_2ghz,\n       { \"2 GHz spectrum\", \"ppi.80211-common.chan.flags.2ghz\",\n         FT_BOOLEAN, 16, NULL, IEEE80211_CHAN_2GHZ, \"PPI 802.11-Common Channel Flags 2 GHz spectrum\", HFILL } },\n    { &hf_80211_common_chan_flags_5ghz,\n       { \"5 GHz spectrum\", \"ppi.80211-common.chan.flags.5ghz\",\n         FT_BOOLEAN, 16, NULL, IEEE80211_CHAN_5GHZ, \"PPI 802.11-Common Channel Flags 5 GHz spectrum\", HFILL } },\n    { &hf_80211_common_chan_flags_passive,\n       { \"Passive\", \"ppi.80211-common.chan.flags.passive\",\n         FT_BOOLEAN, 16, NULL, IEEE80211_CHAN_PASSIVE, \"PPI 802.11-Common Channel Flags Passive\", HFILL } },\n    { &hf_80211_common_chan_flags_dynamic,\n       { \"Dynamic CCK-OFDM\", \"ppi.80211-common.chan.flags.dynamic\",\n         FT_BOOLEAN, 16, NULL, IEEE80211_CHAN_DYN, \"PPI 802.11-Common Channel Flags Dynamic CCK-OFDM Channel\", HFILL } },\n    { &hf_80211_common_chan_flags_gfsk,\n       { \"Gaussian Frequency Shift Keying (GFSK)\", \"ppi.80211-common.chan.flags.gfsk\",\n         FT_BOOLEAN, 16, NULL, IEEE80211_CHAN_GFSK, \"PPI 802.11-Common Channel Flags Gaussian Frequency Shift Keying (GFSK) Modulation\", HFILL } },\n\n    { &hf_80211_common_fhss_hopset,\n       { \"FHSS hopset\", \"ppi.80211-common.fhss.hopset\",\n         FT_UINT8, BASE_HEX, NULL, 0x0, \"PPI 802.11-Common Frequency-Hopping Spread Spectrum (FHSS) Hopset\", HFILL } },\n    { &hf_80211_common_fhss_pattern,\n       { \"FHSS pattern\", \"ppi.80211-common.fhss.pattern\",\n         FT_UINT8, BASE_HEX, NULL, 0x0, \"PPI 802.11-Common Frequency-Hopping Spread Spectrum (FHSS) Pattern\", HFILL } },\n    { &hf_80211_common_dbm_antsignal,\n       { \"dBm antenna signal\", \"ppi.80211-common.dbm.antsignal\",\n         FT_INT8, BASE_DEC, NULL, 0x0, \"PPI 802.11-Common dBm Antenna Signal\", HFILL } },\n    { &hf_80211_common_dbm_antnoise,\n       { \"dBm antenna noise\", \"ppi.80211-common.dbm.antnoise\",\n         FT_INT8, BASE_DEC, NULL, 0x0, \"PPI 802.11-Common dBm Antenna Noise\", HFILL } },\n\n    /* 802.11n MAC */\n    { &hf_80211n_mac_flags,\n       { \"MAC flags\", \"ppi.80211n-mac.flags\",\n         FT_UINT32, BASE_HEX, NULL, 0x0, \"PPI 802.11n MAC flags\", HFILL } },\n    { &hf_80211n_mac_flags_greenfield,\n       { \"Greenfield flag\", \"ppi.80211n-mac.flags.greenfield\",\n         FT_BOOLEAN, 32, TFS(&tfs_true_false), DOT11N_FLAG_GREENFIELD, \"PPI 802.11n MAC Greenfield Flag\", HFILL } },\n    { &hf_80211n_mac_flags_ht20_40,\n       { \"HT20/HT40 flag\", \"ppi.80211n-mac.flags.ht20_40\",\n         FT_BOOLEAN, 32, TFS(&tfs_ht20_40), DOT11N_FLAG_HT40, \"PPI 802.11n MAC HT20/HT40 Flag\", HFILL } },\n    { &hf_80211n_mac_flags_rx_guard_interval,\n       { \"RX Short Guard Interval (SGI) flag\", \"ppi.80211n-mac.flags.rx.short_guard_interval\",\n         FT_BOOLEAN, 32, TFS(&tfs_true_false), DOT11N_FLAG_SHORT_GI, \"PPI 802.11n MAC RX Short Guard Interval (SGI) Flag\", HFILL } },\n    { &hf_80211n_mac_flags_duplicate_rx,\n       { \"Duplicate RX flag\", \"ppi.80211n-mac.flags.rx.duplicate\",\n         FT_BOOLEAN, 32, TFS(&tfs_true_false), DOT11N_FLAG_DUPLICATE_RX, \"PPI 802.11n MAC Duplicate RX Flag\", HFILL } },\n    { &hf_80211n_mac_flags_aggregate,\n       { \"Aggregate flag\", \"ppi.80211n-mac.flags.agg\",\n         FT_BOOLEAN, 32, TFS(&tfs_true_false), DOT11N_FLAG_IS_AGGREGATE, \"PPI 802.11 MAC Aggregate Flag\", HFILL } },\n    { &hf_80211n_mac_flags_more_aggregates,\n       { \"More aggregates flag\", \"ppi.80211n-mac.flags.more_agg\",\n         FT_BOOLEAN, 32, TFS(&tfs_true_false), DOT11N_FLAG_MORE_AGGREGATES, \"PPI 802.11n MAC More Aggregates Flag\", HFILL } },\n    { &hf_80211n_mac_flags_delimiter_crc_after,\n       { \"A-MPDU Delimiter CRC error after this frame flag\", \"ppi.80211n-mac.flags.delim_crc_error_after\",\n         FT_BOOLEAN, 32, TFS(&tfs_true_false), DOT11N_FLAG_AGG_CRC_ERROR, \"PPI 802.11n MAC A-MPDU Delimiter CRC Error After This Frame Flag\", HFILL } },\n    { &hf_80211n_mac_ampdu_id,\n       { \"AMPDU-ID\", \"ppi.80211n-mac.ampdu_id\",\n         FT_UINT32, BASE_HEX, NULL, 0x0, \"PPI 802.11n MAC AMPDU-ID\", HFILL } },\n    { &hf_80211n_mac_num_delimiters,\n       { \"Num-Delimiters\", \"ppi.80211n-mac.num_delimiters\",\n         FT_UINT8, BASE_DEC, NULL, 0x0, \"PPI 802.11n MAC number of zero-length pad delimiters\", HFILL } },\n    { &hf_80211n_mac_reserved,\n       { \"Reserved\", \"ppi.80211n-mac.reserved\",\n         FT_UINT24, BASE_HEX, NULL, 0x0, \"PPI 802.11n MAC Reserved\", HFILL } },\n\n\n    /* 802.11n MAC+PHY */\n    { &hf_80211n_mac_phy_mcs,\n       { \"MCS\", \"ppi.80211n-mac-phy.mcs\",\n         FT_UINT8, BASE_DEC, NULL, 0x0, \"PPI 802.11n MAC+PHY Modulation Coding Scheme (MCS)\", HFILL } },\n    { &hf_80211n_mac_phy_num_streams,\n       { \"Number of spatial streams\", \"ppi.80211n-mac-phy.num_streams\",\n         FT_UINT8, BASE_DEC, NULL, 0x0, \"PPI 802.11n MAC+PHY number of spatial streams\", HFILL } },\n    { &hf_80211n_mac_phy_rssi_combined,\n       { \"RSSI combined\", \"ppi.80211n-mac-phy.rssi.combined\",\n         FT_UINT8, BASE_DEC, NULL, 0x0, \"PPI 802.11n MAC+PHY Received Signal Strength Indication (RSSI) Combined\", HFILL } },\n    { &hf_80211n_mac_phy_rssi_ant0_ctl,\n       { \"Antenna 0 control RSSI\", \"ppi.80211n-mac-phy.rssi.ant0ctl\",\n         FT_UINT8, BASE_DEC, NULL, 0x0, \"PPI 802.11n MAC+PHY Antenna 0 Control Channel Received Signal Strength Indication (RSSI)\", HFILL } },\n    { &hf_80211n_mac_phy_rssi_ant1_ctl,\n       { \"Antenna 1 control RSSI\", \"ppi.80211n-mac-phy.rssi.ant1ctl\",\n         FT_UINT8, BASE_DEC, NULL, 0x0, \"PPI 802.11n MAC+PHY Antenna 1 Control Channel Received Signal Strength Indication (RSSI)\", HFILL } },\n    { &hf_80211n_mac_phy_rssi_ant2_ctl,\n       { \"Antenna 2 control RSSI\", \"ppi.80211n-mac-phy.rssi.ant2ctl\",\n         FT_UINT8, BASE_DEC, NULL, 0x0, \"PPI 802.11n MAC+PHY Antenna 2 Control Channel Received Signal Strength Indication (RSSI)\", HFILL } },\n    { &hf_80211n_mac_phy_rssi_ant3_ctl,\n       { \"Antenna 3 control RSSI\", \"ppi.80211n-mac-phy.rssi.ant3ctl\",\n         FT_UINT8, BASE_DEC, NULL, 0x0, \"PPI 802.11n MAC+PHY Antenna 3 Control Channel Received Signal Strength Indication (RSSI)\", HFILL } },\n    { &hf_80211n_mac_phy_rssi_ant0_ext,\n       { \"Antenna 0 extension RSSI\", \"ppi.80211n-mac-phy.rssi.ant0ext\",\n         FT_UINT8, BASE_DEC, NULL, 0x0, \"PPI 802.11n MAC+PHY Antenna 0 Extension Channel Received Signal Strength Indication (RSSI)\", HFILL } },\n    { &hf_80211n_mac_phy_rssi_ant1_ext,\n       { \"Antenna 1 extension RSSI\", \"ppi.80211n-mac-phy.rssi.ant1ext\",\n         FT_UINT8, BASE_DEC, NULL, 0x0, \"PPI 802.11n MAC+PHY Antenna 1 Extension Channel Received Signal Strength Indication (RSSI)\", HFILL } },\n    { &hf_80211n_mac_phy_rssi_ant2_ext,\n       { \"Antenna 2 extension RSSI\", \"ppi.80211n-mac-phy.rssi.ant2ext\",\n         FT_UINT8, BASE_DEC, NULL, 0x0, \"PPI 802.11n MAC+PHY Antenna 2 Extension Channel Received Signal Strength Indication (RSSI)\", HFILL } },\n    { &hf_80211n_mac_phy_rssi_ant3_ext,\n       { \"Antenna 3 extension RSSI\", \"ppi.80211n-mac-phy.rssi.ant3ext\",\n         FT_UINT8, BASE_DEC, NULL, 0x0, \"PPI 802.11n MAC+PHY Antenna 3 Extension Channel Received Signal Strength Indication (RSSI)\", HFILL } },\n    { &hf_80211n_mac_phy_ext_chan_freq,\n       { \"Extended channel frequency\", \"ppi.80211-mac-phy.ext-chan.freq\",\n         FT_UINT16, BASE_DEC, NULL, 0x0, \"PPI 802.11n MAC+PHY Extended Channel Frequency\", HFILL } },\n    { &hf_80211n_mac_phy_ext_chan_flags,\n       { \"Channel flags\", \"ppi.80211-mac-phy.ext-chan.flags\",\n         FT_UINT16, BASE_HEX, NULL, 0x0, \"PPI 802.11n MAC+PHY Channel Flags\", HFILL } },\n    { &hf_80211n_mac_phy_ext_chan_flags_turbo,\n       { \"Turbo\", \"ppi.80211-mac-phy.ext-chan.flags.turbo\",\n         FT_BOOLEAN, 16, NULL, 0x0010, \"PPI 802.11n MAC+PHY Channel Flags Turbo\", HFILL } },\n    { &hf_80211n_mac_phy_ext_chan_flags_cck,\n       { \"Complementary Code Keying (CCK)\", \"ppi.80211-mac-phy.ext-chan.flags.cck\",\n         FT_BOOLEAN, 16, NULL, 0x0020, \"PPI 802.11n MAC+PHY Channel Flags Complementary Code Keying (CCK) Modulation\", HFILL } },\n    { &hf_80211n_mac_phy_ext_chan_flags_ofdm,\n       { \"Orthogonal Frequency-Division Multiplexing (OFDM)\", \"ppi.80211-mac-phy.ext-chan.flags.ofdm\",\n         FT_BOOLEAN, 16, NULL, 0x0040, \"PPI 802.11n MAC+PHY Channel Flags Orthogonal Frequency-Division Multiplexing (OFDM)\", HFILL } },\n    { &hf_80211n_mac_phy_ext_chan_flags_2ghz,\n       { \"2 GHz spectrum\", \"ppi.80211-mac-phy.ext-chan.flags.2ghz\",\n         FT_BOOLEAN, 16, NULL, 0x0080, \"PPI 802.11n MAC+PHY Channel Flags 2 GHz spectrum\", HFILL } },\n    { &hf_80211n_mac_phy_ext_chan_flags_5ghz,\n       { \"5 GHz spectrum\", \"ppi.80211-mac-phy.ext-chan.flags.5ghz\",\n         FT_BOOLEAN, 16, NULL, 0x0100, \"PPI 802.11n MAC+PHY Channel Flags 5 GHz spectrum\", HFILL } },\n    { &hf_80211n_mac_phy_ext_chan_flags_passive,\n       { \"Passive\", \"ppi.80211-mac-phy.ext-chan.flags.passive\",\n         FT_BOOLEAN, 16, NULL, 0x0200, \"PPI 802.11n MAC+PHY Channel Flags Passive\", HFILL } },\n    { &hf_80211n_mac_phy_ext_chan_flags_dynamic,\n       { \"Dynamic CCK-OFDM\", \"ppi.80211-mac-phy.ext-chan.flags.dynamic\",\n         FT_BOOLEAN, 16, NULL, 0x0400, \"PPI 802.11n MAC+PHY Channel Flags Dynamic CCK-OFDM Channel\", HFILL } },\n    { &hf_80211n_mac_phy_ext_chan_flags_gfsk,\n       { \"Gaussian Frequency Shift Keying (GFSK)\", \"ppi.80211-mac-phy.ext-chan.flags.gfsk\",\n         FT_BOOLEAN, 16, NULL, 0x0800, \"PPI 802.11n MAC+PHY Channel Flags Gaussian Frequency Shift Keying (GFSK) Modulation\", HFILL } },\n    { &hf_80211n_mac_phy_dbm_ant0signal,\n       { \"dBm antenna 0 signal\", \"ppi.80211n-mac-phy.dbmant0.signal\",\n         FT_INT8, BASE_DEC, NULL, 0x0, \"PPI 802.11n MAC+PHY dBm Antenna 0 Signal\", HFILL } },\n    { &hf_80211n_mac_phy_dbm_ant0noise,\n       { \"dBm antenna 0 noise\", \"ppi.80211n-mac-phy.dbmant0.noise\",\n         FT_INT8, BASE_DEC, NULL, 0x0, \"PPI 802.11n MAC+PHY dBm Antenna 0 Noise\", HFILL } },\n    { &hf_80211n_mac_phy_dbm_ant1signal,\n       { \"dBm antenna 1 signal\", \"ppi.80211n-mac-phy.dbmant1.signal\",\n         FT_INT8, BASE_DEC, NULL, 0x0, \"PPI 802.11n MAC+PHY dBm Antenna 1 Signal\", HFILL } },\n    { &hf_80211n_mac_phy_dbm_ant1noise,\n       { \"dBm antenna 1 noise\", \"ppi.80211n-mac-phy.dbmant1.noise\",\n         FT_INT8, BASE_DEC, NULL, 0x0, \"PPI 802.11n MAC+PHY dBm Antenna 1 Noise\", HFILL } },\n    { &hf_80211n_mac_phy_dbm_ant2signal,\n       { \"dBm antenna 2 signal\", \"ppi.80211n-mac-phy.dbmant2.signal\",\n         FT_INT8, BASE_DEC, NULL, 0x0, \"PPI 802.11n MAC+PHY dBm Antenna 2 Signal\", HFILL } },\n    { &hf_80211n_mac_phy_dbm_ant2noise,\n       { \"dBm antenna 2 noise\", \"ppi.80211n-mac-phy.dbmant2.noise\",\n         FT_INT8, BASE_DEC, NULL, 0x0, \"PPI 802.11n MAC+PHY dBm Antenna 2 Noise\", HFILL } },\n    { &hf_80211n_mac_phy_dbm_ant3signal,\n       { \"dBm antenna 3 signal\", \"ppi.80211n-mac-phy.dbmant3.signal\",\n         FT_INT8, BASE_DEC, NULL, 0x0, \"PPI 802.11n MAC+PHY dBm Antenna 3 Signal\", HFILL } },\n    { &hf_80211n_mac_phy_dbm_ant3noise,\n       { \"dBm antenna 3 noise\", \"ppi.80211n-mac-phy.dbmant3.noise\",\n         FT_INT8, BASE_DEC, NULL, 0x0, \"PPI 802.11n MAC+PHY dBm Antenna 3 Noise\", HFILL } },\n    { &hf_80211n_mac_phy_evm0,\n       { \"EVM-0\", \"ppi.80211n-mac-phy.evm0\",\n         FT_UINT32, BASE_DEC, NULL, 0x0, \"PPI 802.11n MAC+PHY Error Vector Magnitude (EVM) for chain 0\", HFILL } },\n    { &hf_80211n_mac_phy_evm1,\n       { \"EVM-1\", \"ppi.80211n-mac-phy.evm1\",\n         FT_UINT32, BASE_DEC, NULL, 0x0, \"PPI 802.11n MAC+PHY Error Vector Magnitude (EVM) for chain 1\", HFILL } },\n    { &hf_80211n_mac_phy_evm2,\n       { \"EVM-2\", \"ppi.80211n-mac-phy.evm2\",\n         FT_UINT32, BASE_DEC, NULL, 0x0, \"PPI 802.11n MAC+PHY Error Vector Magnitude (EVM) for chain 2\", HFILL } },\n    { &hf_80211n_mac_phy_evm3,\n       { \"EVM-3\", \"ppi.80211n-mac-phy.evm3\",\n         FT_UINT32, BASE_DEC, NULL, 0x0, \"PPI 802.11n MAC+PHY Error Vector Magnitude (EVM) for chain 3\", HFILL } },\n\n    { &hf_ampdu_segment,\n        { \"A-MPDU\", \"ppi.80211n-mac.ampdu\",\n            FT_FRAMENUM, BASE_NONE, NULL, 0x0, \"802.11n Aggregated MAC Protocol Data Unit (A-MPDU)\", HFILL }},\n#if 0\n    { &hf_ampdu_segments,\n        { \"Reassembled A-MPDU\", \"ppi.80211n-mac.ampdu.reassembled\",\n            FT_NONE, BASE_NONE, NULL, 0x0, \"Reassembled Aggregated MAC Protocol Data Unit (A-MPDU)\", HFILL }},\n#endif\n    { &hf_ampdu_reassembled_in,\n        { \"Reassembled A-MPDU in frame\", \"ppi.80211n-mac.ampdu.reassembled_in\",\n            FT_FRAMENUM, BASE_NONE, NULL, 0x0,\n            \"The A-MPDU that doesn't end in this segment is reassembled in this frame\",\n            HFILL }},\n    { &hf_ampdu_count,\n        { \"MPDU count\", \"ppi.80211n-mac.ampdu.count\",\n            FT_UINT16, BASE_DEC, NULL, 0x0, \"The number of aggregated MAC Protocol Data Units (MPDUs)\", HFILL }},\n\n    { &hf_spectrum_map,\n       { \"Radio spectrum map\", \"ppi.spectrum-map\",\n            FT_BYTES, BASE_NONE, NULL, 0x0, \"PPI Radio spectrum map\", HFILL } },\n    { &hf_process_info,\n       { \"Process information\", \"ppi.proc-info\",\n            FT_BYTES, BASE_NONE, NULL, 0x0, \"PPI Process information\", HFILL } },\n    { &hf_capture_info,\n       { \"Capture information\", \"ppi.cap-info\",\n            FT_BYTES, BASE_NONE, NULL, 0x0, \"PPI Capture information\", HFILL } },\n\n    /* Aggregtion Extension */\n    { &hf_aggregation_extension_interface_id,\n       { \"Interface ID\", \"ppi.aggregation_extension.interface_id\",\n            FT_UINT32, BASE_DEC, NULL, 0x0, \"Zero-based index of the physical interface the packet was captured from\", HFILL } },\n\n    /* 802.3 Extension */\n    { &hf_8023_extension_flags,\n       { \"Flags\", \"ppi.8023_extension.flags\",\n            FT_UINT32, BASE_HEX, NULL, 0x0, \"PPI 802.3 Extension Flags\", HFILL } },\n    { &hf_8023_extension_flags_fcs_present,\n       { \"FCS Present Flag\", \"ppi.8023_extension.flags.fcs_present\",\n            FT_BOOLEAN, 32, TFS(&tfs_true_false), 0x0001, \"FCS (4 bytes) is present at the end of the packet\", HFILL } },\n    { &hf_8023_extension_errors,\n       { \"Errors\", \"ppi.8023_extension.errors\",\n            FT_UINT32, BASE_HEX, NULL, 0x0, \"PPI 802.3 Extension Errors\", HFILL } },\n    { &hf_8023_extension_errors_fcs,\n       { \"FCS Error\", \"ppi.8023_extension.errors.fcs\",\n            FT_BOOLEAN, 32, TFS(&tfs_true_false), 0x0001,\n            \"PPI 802.3 Extension FCS Error\", HFILL } },\n    { &hf_8023_extension_errors_sequence,\n       { \"Sequence Error\", \"ppi.8023_extension.errors.sequence\",\n            FT_BOOLEAN, 32, TFS(&tfs_true_false), 0x0002,\n            \"PPI 802.3 Extension Sequence Error\", HFILL } },\n    { &hf_8023_extension_errors_symbol,\n       { \"Symbol Error\", \"ppi.8023_extension.errors.symbol\",\n            FT_BOOLEAN, 32, TFS(&tfs_true_false), 0x0004,\n            \"PPI 802.3 Extension Symbol Error\", HFILL } },\n    { &hf_8023_extension_errors_data,\n       { \"Data Error\", \"ppi.8023_extension.errors.data\",\n            FT_BOOLEAN, 32, TFS(&tfs_true_false), 0x0008,\n            \"PPI 802.3 Extension Data Error\", HFILL } },\n\n      /* Generated from convert_proto_tree_add_text.pl */\n      { &hf_ppi_gps, { \"GPS\", \"ppi.gps\", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},\n      { &hf_ppi_vector, { \"VECTOR\", \"ppi.vector\", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},\n      { &hf_ppi_harris, { \"HARRIS\", \"ppi.harris\", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},\n      { &hf_ppi_antenna, { \"ANTENNA\", \"ppi.antenna\", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},\n      { &hf_ppi_fnet, { \"FNET\", \"ppi.fnet\", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},\n      { &hf_ppi_reserved, { \"Reserved\", \"ppi.reserved\", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},\n    };\n\n    static gint *ett[] = {\n        &ett_ppi_pph,\n        &ett_ppi_flags,\n        &ett_dot11_common,\n        &ett_dot11_common_flags,\n        &ett_dot11_common_channel_flags,\n        &ett_dot11n_mac,\n        &ett_dot11n_mac_flags,\n        &ett_dot11n_mac_phy,\n        &ett_dot11n_mac_phy_ext_channel_flags,\n        &ett_ampdu_segments,\n        &ett_ampdu,\n        &ett_ampdu_segment,\n        &ett_aggregation_extension,\n        &ett_8023_extension,\n        &ett_8023_extension_flags,\n        &ett_8023_extension_errors\n    };\n\n    static ei_register_info ei[] = {\n        { &ei_ppi_invalid_length, { \"ppi.invalid_length\", PI_MALFORMED, PI_ERROR, \"Invalid length\", EXPFILL }},\n    };\n\n    module_t *ppi_module;\n    expert_module_t* expert_ppi;\n\n    proto_ppi = proto_register_protocol(\"PPI Packet Header\", \"PPI\", \"ppi\");\n    proto_register_field_array(proto_ppi, hf, array_length(hf));\n    proto_register_subtree_array(ett, array_length(ett));\n    expert_ppi = expert_register_protocol(proto_ppi);\n    expert_register_field_array(expert_ppi, ei, array_length(ei));\n\n    ppi_handle = register_dissector(\"ppi\", dissect_ppi, proto_ppi);\n\n    register_init_routine(ampdu_reassemble_init);\n    register_cleanup_routine(ampdu_reassemble_cleanup);\n\n    /* Configuration options */\n    ppi_module = prefs_register_protocol(proto_ppi, NULL);\n    prefs_register_bool_preference(ppi_module, \"reassemble\",\n                                   \"Reassemble fragmented 802.11 A-MPDUs\",\n                                   \"Whether fragmented 802.11 aggregated MPDUs should be reassembled\",\n                                   &ppi_ampdu_reassemble);\n}\n\nvoid\nproto_reg_handoff_ppi(void)\n{\n    data_handle = find_dissector(\"data\");\n    ieee80211_radio_handle = find_dissector(\"wlan_radio\");\n    ppi_gps_handle = find_dissector(\"ppi_gps\");\n    ppi_vector_handle = find_dissector(\"ppi_vector\");\n    ppi_sensor_handle = find_dissector(\"ppi_sensor\");\n    ppi_antenna_handle = find_dissector(\"ppi_antenna\");\n    ppi_fnet_handle = find_dissector(\"ppi_fnet\");\n\n    dissector_add_uint(\"wtap_encap\", WTAP_ENCAP_PPI, ppi_handle);\n}\n\n/*\n * Editor modelines\n *\n * Local Variables:\n * c-basic-offset: 4\n * tab-width: 8\n * indent-tabs-mode: nil\n * End:\n *\n * ex: set shiftwidth=4 tabstop=8 expandtab:\n * :indentSize=4:tabSize=8:noTabs=true:\n */\n", "code_before": "/*\n * packet-ppi.c\n * Routines for PPI Packet Header dissection\n *\n * Wireshark - Network traffic analyzer\n * By Gerald Combs <gerald@wireshark.org>\n * Copyright 2007 Gerald Combs\n *\n * Copyright (c) 2006 CACE Technologies, Davis (California)\n * All rights reserved.\n *\n * SPDX-License-Identifier: (BSD-3-Clause OR GPL-2.0-only)\n *\n *\n * Dustin Johnson - Dustin@Dustinj.us, Dustin.Johnson@cacetech.com\n *     May 7, 2008 - Added 'Aggregation Extension' and '802.3 Extension'\n */\n\n\n#include \"config.h\"\n\n#include <epan/packet.h>\n#include <epan/capture_dissectors.h>\n#include <epan/tfs.h>\n#include <epan/ptvcursor.h>\n#include <epan/prefs.h>\n#include <epan/expert.h>\n#include <epan/reassemble.h>\n#include <wsutil/802_11-utils.h>\n#include <wsutil/pint.h>\n#include <wsutil/str_util.h>\n#include <wsutil/array.h>\n\n/*\n * Per-Packet Information (PPI) header.\n * See the PPI Packet Header documentation at\n *\n *     https://wayback.archive.org/web/20120525190041/https://www.cacetech.com/documents/PPI%20Header%20format%201.0.10.pdf\n *\n * for details.\n */\n\n/*\n * PPI headers have the following format:\n *\n * ,---------------------------------------------------------.\n * | PPH | PFH 1 | Field data 1 | PFH 2 | Field data 2 | ... |\n * `---------------------------------------------------------'\n *\n * The PPH struct has the following format:\n *\n * typedef struct ppi_packetheader {\n *     uint8_t pph_version;     // Version.  Currently 0\n *     uint8_t pph_flags;       // Flags.\n *     uint16_t pph_len; // Length of entire message, including this header and TLV payload.\n *     uint32_t pph_dlt; // libpcap Data Link Type of the captured packet data.\n * } ppi_packetheader_t;\n *\n * The PFH struct has the following format:\n *\n * typedef struct ppi_fieldheader {\n *     uint16_t pfh_type;        // Type\n *     uint16_t pfh_datalen;     // Length of data\n * } ppi_fieldheader_t;\n *\n * Anyone looking to add their own PPI dissector would probably do well to imitate the GPS\n * ones separation into a distinct file.  Here is a step by step guide:\n * 1) add the number you received to the enum ppi_field_type declaration.\n * 2) Add a value string for your number into vs_ppi_field_type\n * 3) declare a dissector handle by the ppi_gps_handle, and initialize it inside proto_reg_handoff\n * 4) add  case inside dissect_ppi to call your new handle.\n * 5) Write your parser, and get it loaded.\n * Following these steps will result in less churn inside the ppi proper parser, and avoid namespace issues.\n */\n\n\n#define PPI_PADDED (1 << 0)\n\n#define PPI_V0_HEADER_LEN 8\n#define PPI_80211_COMMON_LEN 20\n#define PPI_80211N_MAC_LEN 12\n#define PPI_80211N_MAC_PHY_OFF 9\n#define PPI_80211N_MAC_PHY_LEN 48\n#define PPI_AGGREGATION_EXTENSION_LEN 4\n#define PPI_8023_EXTENSION_LEN 8\n\n#define PPI_FLAG_ALIGN 0x01\n#define IS_PPI_FLAG_ALIGN(x) ((x) & PPI_FLAG_ALIGN)\n\n#define DOT11_FLAG_HAVE_FCS     0x0001\n#define DOT11_FLAG_TSF_TIMER_MS 0x0002\n#define DOT11_FLAG_FCS_INVALID  0x0004\n#define DOT11_FLAG_PHY_ERROR    0x0008\n\n#define DOT11N_FLAG_GREENFIELD      0x00000001\n#define DOT11N_FLAG_HT40            0x00000002\n#define DOT11N_FLAG_SHORT_GI        0x00000004\n#define DOT11N_FLAG_DUPLICATE_RX    0x00000008\n#define DOT11N_FLAG_IS_AGGREGATE    0x00000010\n#define DOT11N_FLAG_MORE_AGGREGATES 0x00000020\n#define DOT11N_FLAG_AGG_CRC_ERROR   0x00000040\n\n#define DOT11N_IS_AGGREGATE(flags)      (flags & DOT11N_FLAG_IS_AGGREGATE)\n#define DOT11N_MORE_AGGREGATES(flags)   ( \\\n    (flags & DOT11N_FLAG_MORE_AGGREGATES) && \\\n    !(flags & DOT11N_FLAG_AGG_CRC_ERROR))\n#define AGGREGATE_MAX 65535\n#define AMPDU_MAX 16383\n\n/* XXX - Start - Copied from packet-radiotap.c */\n/* Channel flags. */\n#define IEEE80211_CHAN_TURBO    0x0010  /* Turbo channel */\n#define IEEE80211_CHAN_CCK      0x0020  /* CCK channel */\n#define IEEE80211_CHAN_OFDM     0x0040  /* OFDM channel */\n#define IEEE80211_CHAN_2GHZ     0x0080  /* 2 GHz spectrum channel. */\n#define IEEE80211_CHAN_5GHZ     0x0100  /* 5 GHz spectrum channel */\n#define IEEE80211_CHAN_PASSIVE  0x0200  /* Only passive scan allowed */\n#define IEEE80211_CHAN_DYN      0x0400  /* Dynamic CCK-OFDM channel */\n#define IEEE80211_CHAN_GFSK     0x0800  /* GFSK channel (FHSS PHY) */\n\n#define\tIEEE80211_CHAN_ALL \\\n\t(IEEE80211_CHAN_2GHZ | IEEE80211_CHAN_5GHZ | IEEE80211_CHAN_GFSK | \\\n         IEEE80211_CHAN_CCK | IEEE80211_CHAN_OFDM | IEEE80211_CHAN_DYN)\n#define\tIEEE80211_CHAN_ALLTURBO \\\n\t(IEEE80211_CHAN_ALL | IEEE80211_CHAN_TURBO)\n\n/*\n * Useful combinations of channel characteristics.\n */\n#define IEEE80211_CHAN_FHSS \\\n        (IEEE80211_CHAN_2GHZ | IEEE80211_CHAN_GFSK)\n#define\tIEEE80211_CHAN_DSSS \\\n\t(IEEE80211_CHAN_2GHZ)\n#define IEEE80211_CHAN_A \\\n        (IEEE80211_CHAN_5GHZ | IEEE80211_CHAN_OFDM)\n#define IEEE80211_CHAN_B \\\n        (IEEE80211_CHAN_2GHZ | IEEE80211_CHAN_CCK)\n#define IEEE80211_CHAN_PUREG \\\n        (IEEE80211_CHAN_2GHZ | IEEE80211_CHAN_OFDM)\n#define IEEE80211_CHAN_G \\\n        (IEEE80211_CHAN_2GHZ | IEEE80211_CHAN_DYN)\n#define\tIEEE80211_CHAN_108A \\\n\t(IEEE80211_CHAN_A | IEEE80211_CHAN_TURBO)\n#define IEEE80211_CHAN_108G \\\n        (IEEE80211_CHAN_G | IEEE80211_CHAN_TURBO)\n#define IEEE80211_CHAN_108PUREG \\\n        (IEEE80211_CHAN_PUREG | IEEE80211_CHAN_TURBO)\n/* XXX - End - Copied from packet-radiotap.c */\n\nvoid proto_register_ppi(void);\nvoid proto_reg_handoff_ppi(void);\n\ntypedef enum {\n    /* 0 - 29999: Public types */\n    PPI_80211_COMMON          =  2,\n    PPI_80211N_MAC            =  3,\n    PPI_80211N_MAC_PHY        =  4,\n    PPI_SPECTRUM_MAP          =  5,\n    PPI_PROCESS_INFO          =  6,\n    PPI_CAPTURE_INFO          =  7,\n    PPI_AGGREGATION_EXTENSION =  8,\n    PPI_8023_EXTENSION        =  9,\n    /* 11 - 29999: RESERVED */\n\n    /* 30000 - 65535: Private types */\n    INTEL_CORP_PRIVATE           = 30000,\n    MOHAMED_THAGA_PRIVATE        = 30001,\n    PPI_GPS_INFO                 = 30002, /* 30002 - 30005 described in PPI-GEOLOCATION specification */\n    PPI_VECTOR_INFO              = 30003, /* currently available in draft from. jellch@harris.com */\n    PPI_SENSOR_INFO              = 30004,\n    PPI_ANTENNA_INFO             = 30005,\n    FNET_PRIVATE                 = 0xC017,\n    CACE_PRIVATE                 = 0xCACE\n    /* All others RESERVED.  Contact the WinPcap team for an assignment */\n} ppi_field_type;\n\n/* Protocol */\nstatic int proto_ppi;\n\n/* Packet header */\nstatic int hf_ppi_head_version;\nstatic int hf_ppi_head_flags;\nstatic int hf_ppi_head_flag_alignment;\nstatic int hf_ppi_head_flag_reserved;\nstatic int hf_ppi_head_len;\nstatic int hf_ppi_head_dlt;\n\n/* Field header */\nstatic int hf_ppi_field_type;\nstatic int hf_ppi_field_len;\n\n/* 802.11 Common */\nstatic int hf_80211_common_tsft;\nstatic int hf_80211_common_flags;\nstatic int hf_80211_common_flags_fcs;\nstatic int hf_80211_common_flags_tsft;\nstatic int hf_80211_common_flags_fcs_valid;\nstatic int hf_80211_common_flags_phy_err;\nstatic int hf_80211_common_rate;\nstatic int hf_80211_common_chan_freq;\nstatic int hf_80211_common_chan_flags;\n\nstatic int hf_80211_common_chan_flags_turbo;\nstatic int hf_80211_common_chan_flags_cck;\nstatic int hf_80211_common_chan_flags_ofdm;\nstatic int hf_80211_common_chan_flags_2ghz;\nstatic int hf_80211_common_chan_flags_5ghz;\nstatic int hf_80211_common_chan_flags_passive;\nstatic int hf_80211_common_chan_flags_dynamic;\nstatic int hf_80211_common_chan_flags_gfsk;\n\nstatic int hf_80211_common_fhss_hopset;\nstatic int hf_80211_common_fhss_pattern;\nstatic int hf_80211_common_dbm_antsignal;\nstatic int hf_80211_common_dbm_antnoise;\n\n/* 802.11n MAC */\nstatic int hf_80211n_mac_flags;\nstatic int hf_80211n_mac_flags_greenfield;\nstatic int hf_80211n_mac_flags_ht20_40;\nstatic int hf_80211n_mac_flags_rx_guard_interval;\nstatic int hf_80211n_mac_flags_duplicate_rx;\nstatic int hf_80211n_mac_flags_more_aggregates;\nstatic int hf_80211n_mac_flags_aggregate;\nstatic int hf_80211n_mac_flags_delimiter_crc_after;\nstatic int hf_80211n_mac_ampdu_id;\nstatic int hf_80211n_mac_num_delimiters;\nstatic int hf_80211n_mac_reserved;\n\n/* 802.11n MAC+PHY */\nstatic int hf_80211n_mac_phy_mcs;\nstatic int hf_80211n_mac_phy_num_streams;\nstatic int hf_80211n_mac_phy_rssi_combined;\nstatic int hf_80211n_mac_phy_rssi_ant0_ctl;\nstatic int hf_80211n_mac_phy_rssi_ant1_ctl;\nstatic int hf_80211n_mac_phy_rssi_ant2_ctl;\nstatic int hf_80211n_mac_phy_rssi_ant3_ctl;\nstatic int hf_80211n_mac_phy_rssi_ant0_ext;\nstatic int hf_80211n_mac_phy_rssi_ant1_ext;\nstatic int hf_80211n_mac_phy_rssi_ant2_ext;\nstatic int hf_80211n_mac_phy_rssi_ant3_ext;\nstatic int hf_80211n_mac_phy_ext_chan_freq;\nstatic int hf_80211n_mac_phy_ext_chan_flags;\nstatic int hf_80211n_mac_phy_ext_chan_flags_turbo;\nstatic int hf_80211n_mac_phy_ext_chan_flags_cck;\nstatic int hf_80211n_mac_phy_ext_chan_flags_ofdm;\nstatic int hf_80211n_mac_phy_ext_chan_flags_2ghz;\nstatic int hf_80211n_mac_phy_ext_chan_flags_5ghz;\nstatic int hf_80211n_mac_phy_ext_chan_flags_passive;\nstatic int hf_80211n_mac_phy_ext_chan_flags_dynamic;\nstatic int hf_80211n_mac_phy_ext_chan_flags_gfsk;\nstatic int hf_80211n_mac_phy_dbm_ant0signal;\nstatic int hf_80211n_mac_phy_dbm_ant0noise;\nstatic int hf_80211n_mac_phy_dbm_ant1signal;\nstatic int hf_80211n_mac_phy_dbm_ant1noise;\nstatic int hf_80211n_mac_phy_dbm_ant2signal;\nstatic int hf_80211n_mac_phy_dbm_ant2noise;\nstatic int hf_80211n_mac_phy_dbm_ant3signal;\nstatic int hf_80211n_mac_phy_dbm_ant3noise;\nstatic int hf_80211n_mac_phy_evm0;\nstatic int hf_80211n_mac_phy_evm1;\nstatic int hf_80211n_mac_phy_evm2;\nstatic int hf_80211n_mac_phy_evm3;\n\n/* 802.11n-Extensions A-MPDU fragments */\nstatic int hf_ampdu_reassembled_in;\n/* static int hf_ampdu_segments; */\nstatic int hf_ampdu_segment;\nstatic int hf_ampdu_count;\n\n/* Spectrum-Map */\nstatic int hf_spectrum_map;\n\n/* Process-Info */\nstatic int hf_process_info;\n\n/* Capture-Info */\nstatic int hf_capture_info;\n\n/* Aggregation Extension */\nstatic int hf_aggregation_extension_interface_id;\n\n/* 802.3 Extension */\nstatic int hf_8023_extension_flags;\nstatic int hf_8023_extension_flags_fcs_present;\nstatic int hf_8023_extension_errors;\nstatic int hf_8023_extension_errors_fcs;\nstatic int hf_8023_extension_errors_sequence;\nstatic int hf_8023_extension_errors_symbol;\nstatic int hf_8023_extension_errors_data;\n\n/* Generated from convert_proto_tree_add_text.pl */\nstatic int hf_ppi_antenna;\nstatic int hf_ppi_harris;\nstatic int hf_ppi_reserved;\nstatic int hf_ppi_vector;\nstatic int hf_ppi_fnet;\nstatic int hf_ppi_gps;\n\nstatic int ett_ppi_pph;\nstatic int ett_ppi_flags;\nstatic int ett_dot11_common;\nstatic int ett_dot11_common_flags;\nstatic int ett_dot11_common_channel_flags;\nstatic int ett_dot11n_mac;\nstatic int ett_dot11n_mac_flags;\nstatic int ett_dot11n_mac_phy;\nstatic int ett_dot11n_mac_phy_ext_channel_flags;\nstatic int ett_ampdu_segments;\nstatic int ett_ampdu;\nstatic int ett_ampdu_segment;\nstatic int ett_aggregation_extension;\nstatic int ett_8023_extension;\nstatic int ett_8023_extension_flags;\nstatic int ett_8023_extension_errors;\n\n/* Generated from convert_proto_tree_add_text.pl */\nstatic expert_field ei_ppi_invalid_length;\n\nstatic dissector_handle_t ppi_handle;\n\nstatic dissector_handle_t ieee80211_radio_handle;\nstatic dissector_handle_t pcap_pktdata_handle;\nstatic dissector_handle_t ppi_gps_handle, ppi_vector_handle, ppi_sensor_handle, ppi_antenna_handle;\nstatic dissector_handle_t ppi_fnet_handle;\n\n/* Cached protocol identifier */\nstatic int proto_aggregate;\n\nstatic const true_false_string tfs_ppi_head_flag_alignment = { \"32-bit aligned\", \"Not aligned\" };\nstatic const true_false_string tfs_tsft_ms = { \"milliseconds\", \"microseconds\" };\nstatic const true_false_string tfs_ht20_40 = { \"HT40\", \"HT20\" };\nstatic const true_false_string tfs_phy_error = { \"PHY error\", \"No errors\"};\n\nstatic const value_string vs_ppi_field_type[] = {\n    {PPI_80211_COMMON,          \"802.11-Common\"},\n    {PPI_80211N_MAC,            \"802.11n MAC Extensions\"},\n    {PPI_80211N_MAC_PHY,        \"802.11n MAC+PHY Extensions\"},\n    {PPI_SPECTRUM_MAP,          \"Spectrum-Map\"},\n    {PPI_PROCESS_INFO,          \"Process-Info\"},\n    {PPI_CAPTURE_INFO,          \"Capture-Info\"},\n    {PPI_AGGREGATION_EXTENSION, \"Aggregation Extension\"},\n    {PPI_8023_EXTENSION,        \"802.3 Extension\"},\n\n    {INTEL_CORP_PRIVATE,        \"Intel Corporation (private)\"},\n    {MOHAMED_THAGA_PRIVATE,     \"Mohamed Thaga (private)\"},\n    {PPI_GPS_INFO,              \"GPS Tagging\"},\n    {PPI_VECTOR_INFO,           \"Vector Tagging\"},\n    {PPI_SENSOR_INFO,           \"Sensor tagging\"},\n    {PPI_ANTENNA_INFO,          \"Antenna Tagging\"},\n    {FNET_PRIVATE,              \"FlukeNetworks (private)\"},\n    {CACE_PRIVATE,              \"CACE Technologies (private)\"},\n    {0, NULL}\n};\n\n/* Table for A-MPDU reassembly */\nstatic reassembly_table ampdu_reassembly_table;\n\n/* Reassemble A-MPDUs? */\nstatic bool ppi_ampdu_reassemble = true;\n\n\nstatic bool\ncapture_ppi(const unsigned char *pd, int offset _U_, int len, capture_packet_info_t *cpinfo, const union wtap_pseudo_header *pseudo_header _U_)\n{\n    uint32_t dlt;\n    unsigned ppi_len;\n\n    ppi_len = pletoh16(pd+2);\n    if(ppi_len < PPI_V0_HEADER_LEN || !BYTES_ARE_IN_FRAME(0, len, ppi_len))\n        return false;\n\n    dlt = pletoh32(pd+4);\n\n    return try_capture_dissector(\"ppi\", dlt, pd, ppi_len, len, cpinfo, pseudo_header);\n}\n\nstatic void\nptvcursor_add_invalid_check(ptvcursor_t *csr, int hf, int len, uint64_t invalid_val) {\n    proto_item *ti;\n    uint64_t    val = invalid_val;\n\n    switch (len) {\n        case 8:\n            val = tvb_get_letoh64(ptvcursor_tvbuff(csr),\n                ptvcursor_current_offset(csr));\n            break;\n        case 4:\n            val = tvb_get_letohl(ptvcursor_tvbuff(csr),\n                ptvcursor_current_offset(csr));\n            break;\n        case 2:\n            val = tvb_get_letohs(ptvcursor_tvbuff(csr),\n                ptvcursor_current_offset(csr));\n            break;\n        case 1:\n            val = tvb_get_uint8(ptvcursor_tvbuff(csr),\n                ptvcursor_current_offset(csr));\n            break;\n        default:\n            DISSECTOR_ASSERT_NOT_REACHED();\n    }\n\n    ti = ptvcursor_add(csr, hf, len, ENC_LITTLE_ENDIAN);\n    if (val == invalid_val)\n        proto_item_append_text(ti, \" [invalid]\");\n}\n\nstatic void\nadd_ppi_field_header(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, int *offset)\n{\n    ptvcursor_t *csr;\n\n    csr = ptvcursor_new(pinfo->pool, tree, tvb, *offset);\n    ptvcursor_add(csr, hf_ppi_field_type, 2, ENC_LITTLE_ENDIAN);\n    ptvcursor_add(csr, hf_ppi_field_len, 2, ENC_LITTLE_ENDIAN);\n    ptvcursor_free(csr);\n    *offset=ptvcursor_current_offset(csr);\n}\n\n/* XXX - The main dissection function in the 802.11 dissector has the same name. */\nstatic void\ndissect_80211_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, int offset, int data_len, struct ieee_802_11_phdr *phdr)\n{\n    proto_tree  *ftree;\n    proto_item  *ti;\n    ptvcursor_t *csr;\n    uint64_t     tsft_raw;\n    unsigned     rate_raw;\n    unsigned     rate_kbps;\n    uint32_t     common_flags;\n    uint16_t     common_frequency;\n    uint16_t     chan_flags;\n    int8_t       dbm_value;\n    char        *chan_str;\n\n    ftree = proto_tree_add_subtree(tree, tvb, offset, data_len, ett_dot11_common, NULL, \"802.11-Common\");\n    add_ppi_field_header(tvb, pinfo, ftree, &offset);\n    data_len -= 4; /* Subtract field header length */\n\n    if (data_len != PPI_80211_COMMON_LEN) {\n        proto_tree_add_expert_format(ftree, pinfo, &ei_ppi_invalid_length, tvb, offset, data_len, \"Invalid length: %u\", data_len);\n        return;\n    }\n\n    common_flags = tvb_get_letohs(tvb, offset + 8);\n    if (common_flags & DOT11_FLAG_HAVE_FCS)\n        phdr->fcs_len = 4;\n    else\n        phdr->fcs_len = 0;\n\n    csr = ptvcursor_new(pinfo->pool, ftree, tvb, offset);\n\n    tsft_raw = tvb_get_letoh64(tvb, offset);\n    if (tsft_raw != 0) {\n        phdr->has_tsf_timestamp = true;\n        if (common_flags & DOT11_FLAG_TSF_TIMER_MS)\n            phdr->tsf_timestamp = tsft_raw * 1000;\n        else\n            phdr->tsf_timestamp = tsft_raw;\n    }\n\n    ptvcursor_add_invalid_check(csr, hf_80211_common_tsft, 8, 0);\n\n    ptvcursor_add_with_subtree(csr, hf_80211_common_flags, 2, ENC_LITTLE_ENDIAN,\n                               ett_dot11_common_flags);\n    ptvcursor_add_no_advance(csr, hf_80211_common_flags_fcs, 2, ENC_LITTLE_ENDIAN);\n    ptvcursor_add_no_advance(csr, hf_80211_common_flags_tsft, 2, ENC_LITTLE_ENDIAN);\n    ptvcursor_add_no_advance(csr, hf_80211_common_flags_fcs_valid, 2, ENC_LITTLE_ENDIAN);\n    ptvcursor_add(csr, hf_80211_common_flags_phy_err, 2, ENC_LITTLE_ENDIAN);\n    ptvcursor_pop_subtree(csr);\n\n    rate_raw = tvb_get_letohs(tvb, ptvcursor_current_offset(csr));\n    if (rate_raw != 0) {\n        phdr->has_data_rate = true;\n        phdr->data_rate = rate_raw;\n    }\n    rate_kbps = rate_raw * 500;\n    ti = proto_tree_add_uint_format(ftree, hf_80211_common_rate, tvb,\n                                    ptvcursor_current_offset(csr), 2, rate_kbps, \"Rate: %.1f Mbps\",\n                                    rate_kbps / 1000.0);\n    if (rate_kbps == 0)\n        proto_item_append_text(ti, \" [invalid]\");\n    col_add_fstr(pinfo->cinfo, COL_TX_RATE, \"%.1f Mbps\", rate_kbps / 1000.0);\n    ptvcursor_advance(csr, 2);\n\n    common_frequency = tvb_get_letohs(ptvcursor_tvbuff(csr), ptvcursor_current_offset(csr));\n    if (common_frequency != 0) {\n        int calc_channel;\n\n        phdr->has_frequency = true;\n        phdr->frequency = common_frequency;\n        calc_channel = ieee80211_mhz_to_chan(common_frequency);\n        if (calc_channel != -1) {\n            phdr->has_channel = true;\n            phdr->channel = calc_channel;\n        }\n    }\n    chan_str = ieee80211_mhz_to_str(common_frequency);\n    proto_tree_add_uint_format_value(ptvcursor_tree(csr), hf_80211_common_chan_freq, ptvcursor_tvbuff(csr),\n                               ptvcursor_current_offset(csr), 2, common_frequency, \"%s\", chan_str);\n    col_add_str(pinfo->cinfo, COL_FREQ_CHAN, chan_str);\n    g_free(chan_str);\n    ptvcursor_advance(csr, 2);\n\n    memset(&phdr->phy_info, 0, sizeof(phdr->phy_info));\n    chan_flags = tvb_get_letohs(ptvcursor_tvbuff(csr), ptvcursor_current_offset(csr));\n    switch (chan_flags & IEEE80211_CHAN_ALLTURBO) {\n\n    case IEEE80211_CHAN_FHSS:\n        phdr->phy = PHDR_802_11_PHY_11_FHSS;\n        break;\n\n    case IEEE80211_CHAN_DSSS:\n        phdr->phy = PHDR_802_11_PHY_11_DSSS;\n        break;\n\n    case IEEE80211_CHAN_A:\n        phdr->phy = PHDR_802_11_PHY_11A;\n        phdr->phy_info.info_11a.has_turbo_type = true;\n        phdr->phy_info.info_11a.turbo_type = PHDR_802_11A_TURBO_TYPE_NORMAL;\n        break;\n\n    case IEEE80211_CHAN_B:\n        phdr->phy = PHDR_802_11_PHY_11B;\n        break;\n\n    case IEEE80211_CHAN_PUREG:\n        phdr->phy = PHDR_802_11_PHY_11G;\n        phdr->phy_info.info_11g.has_mode = true;\n        phdr->phy_info.info_11g.mode = PHDR_802_11G_MODE_NORMAL;\n        break;\n\n    case IEEE80211_CHAN_G:\n        phdr->phy = PHDR_802_11_PHY_11G;\n        phdr->phy_info.info_11g.has_mode = true;\n        phdr->phy_info.info_11g.mode = PHDR_802_11G_MODE_NORMAL;\n        break;\n\n    case IEEE80211_CHAN_108A:\n        phdr->phy = PHDR_802_11_PHY_11A;\n        phdr->phy_info.info_11a.has_turbo_type = true;\n        /* We assume non-STURBO is dynamic turbo */\n        phdr->phy_info.info_11a.turbo_type = PHDR_802_11A_TURBO_TYPE_DYNAMIC_TURBO;\n        break;\n\n    case IEEE80211_CHAN_108PUREG:\n        phdr->phy = PHDR_802_11_PHY_11G;\n        phdr->phy_info.info_11g.has_mode = true;\n        phdr->phy_info.info_11g.mode = PHDR_802_11G_MODE_SUPER_G;\n        break;\n    }\n    ptvcursor_add_with_subtree(csr, hf_80211_common_chan_flags, 2, ENC_LITTLE_ENDIAN,\n                               ett_dot11_common_channel_flags);\n    ptvcursor_add_no_advance(csr, hf_80211_common_chan_flags_turbo, 2, ENC_LITTLE_ENDIAN);\n    ptvcursor_add_no_advance(csr, hf_80211_common_chan_flags_cck, 2, ENC_LITTLE_ENDIAN);\n    ptvcursor_add_no_advance(csr, hf_80211_common_chan_flags_ofdm, 2, ENC_LITTLE_ENDIAN);\n    ptvcursor_add_no_advance(csr, hf_80211_common_chan_flags_2ghz, 2, ENC_LITTLE_ENDIAN);\n    ptvcursor_add_no_advance(csr, hf_80211_common_chan_flags_5ghz, 2, ENC_LITTLE_ENDIAN);\n    ptvcursor_add_no_advance(csr, hf_80211_common_chan_flags_passive, 2, ENC_LITTLE_ENDIAN);\n    ptvcursor_add_no_advance(csr, hf_80211_common_chan_flags_dynamic, 2, ENC_LITTLE_ENDIAN);\n    ptvcursor_add(csr, hf_80211_common_chan_flags_gfsk, 2, ENC_LITTLE_ENDIAN);\n    ptvcursor_pop_subtree(csr);\n\n\n    if (phdr->phy == PHDR_802_11_PHY_11_FHSS) {\n        phdr->phy_info.info_11_fhss.has_hop_set = true;\n        phdr->phy_info.info_11_fhss.hop_set = tvb_get_uint8(ptvcursor_tvbuff(csr), ptvcursor_current_offset(csr));\n    }\n    ptvcursor_add(csr, hf_80211_common_fhss_hopset, 1, ENC_LITTLE_ENDIAN);\n    if (phdr->phy == PHDR_802_11_PHY_11_FHSS) {\n        phdr->phy_info.info_11_fhss.has_hop_pattern = true;\n        phdr->phy_info.info_11_fhss.hop_pattern = tvb_get_uint8(ptvcursor_tvbuff(csr), ptvcursor_current_offset(csr));\n    }\n    ptvcursor_add(csr, hf_80211_common_fhss_pattern, 1, ENC_LITTLE_ENDIAN);\n\n    dbm_value = tvb_get_int8(tvb, ptvcursor_current_offset(csr));\n    if (dbm_value != -128 && dbm_value != 0) {\n        /*\n         * XXX - the spec says -128 is invalid, presumably meaning \"use\n         * -128 if you don't have the signal strength\", but some captures\n         * have 0 for noise, presumably meaning it's incorrectly being\n         * used for \"don't have it\", so we check for it as well.\n         */\n        col_add_fstr(pinfo->cinfo, COL_RSSI, \"%d dBm\", dbm_value);\n        phdr->has_signal_dbm = true;\n        phdr->signal_dbm = dbm_value;\n    }\n    ptvcursor_add_invalid_check(csr, hf_80211_common_dbm_antsignal, 1, 0x80); /* -128 */\n\n    dbm_value = tvb_get_int8(tvb, ptvcursor_current_offset(csr));\n    if (dbm_value != -128 && dbm_value != 0) {\n        /*\n         * XXX - the spec says -128 is invalid, presumably meaning \"use\n         * -128 if you don't have the noise level\", but some captures\n         * have 0, presumably meaning it's incorrectly being used for\n         * \"don't have it\", so we check for it as well.\n         */\n        phdr->has_noise_dbm = true;\n        phdr->noise_dbm = dbm_value;\n    }\n    ptvcursor_add_invalid_check(csr, hf_80211_common_dbm_antnoise, 1, 0x80);\n\n    ptvcursor_free(csr);\n}\n\nstatic void\ndissect_80211n_mac(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, int offset, int data_len, bool add_subtree, uint32_t *n_mac_flags, uint32_t *ampdu_id, struct ieee_802_11_phdr *phdr)\n{\n    proto_tree  *ftree       = tree;\n    ptvcursor_t *csr;\n    uint32_t     flags;\n\n    phdr->phy = PHDR_802_11_PHY_11N;\n\n    if (add_subtree) {\n        ftree = proto_tree_add_subtree(tree, tvb, offset, data_len, ett_dot11n_mac, NULL, \"802.11n MAC\");\n        add_ppi_field_header(tvb, pinfo, ftree, &offset);\n        data_len -= 4; /* Subtract field header length */\n    }\n\n    if (data_len != PPI_80211N_MAC_LEN) {\n        proto_tree_add_expert_format(ftree, pinfo, &ei_ppi_invalid_length, tvb, offset, data_len, \"Invalid length: %u\", data_len);\n        return;\n    }\n\n    csr = ptvcursor_new(pinfo->pool, ftree, tvb, offset);\n\n    flags = tvb_get_letohl(tvb, ptvcursor_current_offset(csr));\n    *n_mac_flags = flags;\n    phdr->phy_info.info_11n.has_bandwidth = true;\n    phdr->phy_info.info_11n.has_short_gi = true;\n    phdr->phy_info.info_11n.has_greenfield = true;\n    phdr->phy_info.info_11n.bandwidth = ((flags & DOT11N_FLAG_HT40) != 0);\n    phdr->phy_info.info_11n.short_gi = ((flags & DOT11N_FLAG_SHORT_GI) != 0);\n    phdr->phy_info.info_11n.greenfield = ((flags & DOT11N_FLAG_GREENFIELD) != 0);\n    if (DOT11N_IS_AGGREGATE(flags)) {\n        phdr->has_aggregate_info = 1;\n        phdr->aggregate_flags = 0;\n        if (!(flags & DOT11N_FLAG_MORE_AGGREGATES))\n            phdr->aggregate_flags |= PHDR_802_11_LAST_PART_OF_A_MPDU;\n        if (flags & DOT11N_FLAG_AGG_CRC_ERROR)\n            phdr->aggregate_flags |= PHDR_802_11_A_MPDU_DELIM_CRC_ERROR;\n    }\n    ptvcursor_add_with_subtree(csr, hf_80211n_mac_flags, 4, ENC_LITTLE_ENDIAN,\n                               ett_dot11n_mac_flags);\n    ptvcursor_add_no_advance(csr, hf_80211n_mac_flags_greenfield, 4, ENC_LITTLE_ENDIAN);\n    ptvcursor_add_no_advance(csr, hf_80211n_mac_flags_ht20_40, 4, ENC_LITTLE_ENDIAN);\n    ptvcursor_add_no_advance(csr, hf_80211n_mac_flags_rx_guard_interval, 4, ENC_LITTLE_ENDIAN);\n    ptvcursor_add_no_advance(csr, hf_80211n_mac_flags_duplicate_rx, 4, ENC_LITTLE_ENDIAN);\n    ptvcursor_add_no_advance(csr, hf_80211n_mac_flags_aggregate, 4, ENC_LITTLE_ENDIAN);\n    ptvcursor_add_no_advance(csr, hf_80211n_mac_flags_more_aggregates, 4, ENC_LITTLE_ENDIAN);\n    ptvcursor_add(csr, hf_80211n_mac_flags_delimiter_crc_after, 4, ENC_LITTLE_ENDIAN); /* Last */\n    ptvcursor_pop_subtree(csr);\n\n    if (DOT11N_IS_AGGREGATE(flags)) {\n        *ampdu_id = tvb_get_letohl(tvb, ptvcursor_current_offset(csr));\n        phdr->aggregate_id = *ampdu_id;\n    }\n    ptvcursor_add(csr, hf_80211n_mac_ampdu_id, 4, ENC_LITTLE_ENDIAN);\n    ptvcursor_add(csr, hf_80211n_mac_num_delimiters, 1, ENC_LITTLE_ENDIAN);\n\n    if (add_subtree) {\n        ptvcursor_add(csr, hf_80211n_mac_reserved, 3, ENC_LITTLE_ENDIAN);\n    }\n\n    ptvcursor_free(csr);\n}\n\nstatic void\ndissect_80211n_mac_phy(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, int offset, int data_len, uint32_t *n_mac_flags, uint32_t *ampdu_id, struct ieee_802_11_phdr *phdr)\n{\n    proto_tree  *ftree;\n    proto_item  *ti;\n    ptvcursor_t *csr;\n    uint8_t      mcs;\n    uint8_t      ness;\n    uint16_t     ext_frequency;\n    char        *chan_str;\n\n    ftree = proto_tree_add_subtree(tree, tvb, offset, data_len, ett_dot11n_mac_phy, NULL, \"802.11n MAC+PHY\");\n    add_ppi_field_header(tvb, pinfo, ftree, &offset);\n    data_len -= 4; /* Subtract field header length */\n\n    if (data_len != PPI_80211N_MAC_PHY_LEN) {\n        proto_tree_add_expert_format(ftree, pinfo, &ei_ppi_invalid_length, tvb, offset, data_len, \"Invalid length: %u\", data_len);\n        return;\n    }\n\n    dissect_80211n_mac(tvb, pinfo, ftree, offset, PPI_80211N_MAC_LEN,\n                       false, n_mac_flags, ampdu_id, phdr);\n    offset += PPI_80211N_MAC_PHY_OFF;\n\n    csr = ptvcursor_new(pinfo->pool, ftree, tvb, offset);\n\n    mcs = tvb_get_uint8(tvb, ptvcursor_current_offset(csr));\n    if (mcs != 255) {\n        phdr->phy_info.info_11n.has_mcs_index = true;\n        phdr->phy_info.info_11n.mcs_index = mcs;\n    }\n    ptvcursor_add_invalid_check(csr, hf_80211n_mac_phy_mcs, 1, 255);\n\n    ness = tvb_get_uint8(tvb, ptvcursor_current_offset(csr));\n    phdr->phy_info.info_11n.has_ness = true;\n    phdr->phy_info.info_11n.ness = ness;\n    ti = ptvcursor_add(csr, hf_80211n_mac_phy_num_streams, 1, ENC_LITTLE_ENDIAN);\n    if (tvb_get_uint8(tvb, ptvcursor_current_offset(csr) - 1) == 0)\n        proto_item_append_text(ti, \" (unknown)\");\n    ptvcursor_add_invalid_check(csr, hf_80211n_mac_phy_rssi_combined, 1, 255);\n    ptvcursor_add_invalid_check(csr, hf_80211n_mac_phy_rssi_ant0_ctl, 1, 255);\n    ptvcursor_add_invalid_check(csr, hf_80211n_mac_phy_rssi_ant1_ctl, 1, 255);\n    ptvcursor_add_invalid_check(csr, hf_80211n_mac_phy_rssi_ant2_ctl, 1, 255);\n    ptvcursor_add_invalid_check(csr, hf_80211n_mac_phy_rssi_ant3_ctl, 1, 255);\n    ptvcursor_add_invalid_check(csr, hf_80211n_mac_phy_rssi_ant0_ext, 1, 255);\n    ptvcursor_add_invalid_check(csr, hf_80211n_mac_phy_rssi_ant1_ext, 1, 255);\n    ptvcursor_add_invalid_check(csr, hf_80211n_mac_phy_rssi_ant2_ext, 1, 255);\n    ptvcursor_add_invalid_check(csr, hf_80211n_mac_phy_rssi_ant3_ext, 1, 255);\n\n    ext_frequency = tvb_get_letohs(ptvcursor_tvbuff(csr), ptvcursor_current_offset(csr));\n    chan_str = ieee80211_mhz_to_str(ext_frequency);\n    proto_tree_add_uint_format(ptvcursor_tree(csr), hf_80211n_mac_phy_ext_chan_freq, ptvcursor_tvbuff(csr),\n                               ptvcursor_current_offset(csr), 2, ext_frequency, \"Ext. Channel frequency: %s\", chan_str);\n    g_free(chan_str);\n    ptvcursor_advance(csr, 2);\n\n    ptvcursor_add_with_subtree(csr, hf_80211n_mac_phy_ext_chan_flags, 2, ENC_LITTLE_ENDIAN,\n                               ett_dot11n_mac_phy_ext_channel_flags);\n    ptvcursor_add_no_advance(csr, hf_80211n_mac_phy_ext_chan_flags_turbo, 2, ENC_LITTLE_ENDIAN);\n    ptvcursor_add_no_advance(csr, hf_80211n_mac_phy_ext_chan_flags_cck, 2, ENC_LITTLE_ENDIAN);\n    ptvcursor_add_no_advance(csr, hf_80211n_mac_phy_ext_chan_flags_ofdm, 2, ENC_LITTLE_ENDIAN);\n    ptvcursor_add_no_advance(csr, hf_80211n_mac_phy_ext_chan_flags_2ghz, 2, ENC_LITTLE_ENDIAN);\n    ptvcursor_add_no_advance(csr, hf_80211n_mac_phy_ext_chan_flags_5ghz, 2, ENC_LITTLE_ENDIAN);\n    ptvcursor_add_no_advance(csr, hf_80211n_mac_phy_ext_chan_flags_passive, 2, ENC_LITTLE_ENDIAN);\n    ptvcursor_add_no_advance(csr, hf_80211n_mac_phy_ext_chan_flags_dynamic, 2, ENC_LITTLE_ENDIAN);\n    ptvcursor_add(csr, hf_80211n_mac_phy_ext_chan_flags_gfsk, 2, ENC_LITTLE_ENDIAN);\n    ptvcursor_pop_subtree(csr);\n\n    ptvcursor_add_invalid_check(csr, hf_80211n_mac_phy_dbm_ant0signal, 1, 0x80); /* -128 */\n    ptvcursor_add_invalid_check(csr, hf_80211n_mac_phy_dbm_ant0noise, 1, 0x80);\n    ptvcursor_add_invalid_check(csr, hf_80211n_mac_phy_dbm_ant1signal, 1, 0x80);\n    ptvcursor_add_invalid_check(csr, hf_80211n_mac_phy_dbm_ant1noise, 1, 0x80);\n    ptvcursor_add_invalid_check(csr, hf_80211n_mac_phy_dbm_ant2signal, 1, 0x80);\n    ptvcursor_add_invalid_check(csr, hf_80211n_mac_phy_dbm_ant2noise, 1, 0x80);\n    ptvcursor_add_invalid_check(csr, hf_80211n_mac_phy_dbm_ant3signal, 1, 0x80);\n    ptvcursor_add_invalid_check(csr, hf_80211n_mac_phy_dbm_ant3noise, 1, 0x80);\n    ptvcursor_add_invalid_check(csr, hf_80211n_mac_phy_evm0, 4, 0);\n    ptvcursor_add_invalid_check(csr, hf_80211n_mac_phy_evm1, 4, 0);\n    ptvcursor_add_invalid_check(csr, hf_80211n_mac_phy_evm2, 4, 0);\n    ptvcursor_add_invalid_check(csr, hf_80211n_mac_phy_evm3, 4, 0);\n\n    ptvcursor_free(csr);\n}\n\nstatic void\ndissect_aggregation_extension(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, int offset, int data_len)\n{\n    proto_tree *ftree;\n    ptvcursor_t *csr;\n\n    ftree = proto_tree_add_subtree(tree, tvb, offset, data_len, ett_aggregation_extension, NULL, \"Aggregation Extension\");\n    add_ppi_field_header(tvb, pinfo, ftree, &offset);\n    data_len -= 4; /* Subtract field header length */\n\n    if (data_len != PPI_AGGREGATION_EXTENSION_LEN) {\n        proto_tree_add_expert_format(ftree, pinfo, &ei_ppi_invalid_length, tvb, offset, data_len, \"Invalid length: %u\", data_len);\n        return;\n    }\n\n    csr = ptvcursor_new(pinfo->pool, ftree, tvb, offset);\n\n    ptvcursor_add(csr, hf_aggregation_extension_interface_id, 4, ENC_LITTLE_ENDIAN); /* Last */\n    ptvcursor_free(csr);\n}\n\nstatic void\ndissect_8023_extension(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, int offset, int data_len)\n{\n    proto_tree  *ftree;\n    ptvcursor_t *csr;\n\n    ftree = proto_tree_add_subtree(tree, tvb, offset, data_len, ett_8023_extension, NULL, \"802.3 Extension\");\n    add_ppi_field_header(tvb, pinfo, ftree, &offset);\n    data_len -= 4; /* Subtract field header length */\n\n    if (data_len != PPI_8023_EXTENSION_LEN) {\n        proto_tree_add_expert_format(ftree, pinfo, &ei_ppi_invalid_length, tvb, offset, data_len, \"Invalid length: %u\", data_len);\n        return;\n    }\n\n    csr = ptvcursor_new(pinfo->pool, ftree, tvb, offset);\n\n    ptvcursor_add_with_subtree(csr, hf_8023_extension_flags, 4, ENC_LITTLE_ENDIAN, ett_8023_extension_flags);\n    ptvcursor_add(csr, hf_8023_extension_flags_fcs_present, 4, ENC_LITTLE_ENDIAN);\n    ptvcursor_pop_subtree(csr);\n\n    ptvcursor_add_with_subtree(csr, hf_8023_extension_errors, 4, ENC_LITTLE_ENDIAN, ett_8023_extension_errors);\n    ptvcursor_add_no_advance(csr, hf_8023_extension_errors_fcs, 4, ENC_LITTLE_ENDIAN);\n    ptvcursor_add_no_advance(csr, hf_8023_extension_errors_sequence, 4, ENC_LITTLE_ENDIAN);\n    ptvcursor_add_no_advance(csr, hf_8023_extension_errors_symbol, 4, ENC_LITTLE_ENDIAN);\n    ptvcursor_add(csr, hf_8023_extension_errors_data, 4, ENC_LITTLE_ENDIAN);\n    ptvcursor_pop_subtree(csr);\n\n    ptvcursor_free(csr);\n}\n\n\n#define PADDING4(x) ((((x + 3) >> 2) << 2) - x)\n#define ADD_BASIC_TAG(hf_tag) \\\n    if (tree)   \\\n        proto_tree_add_item(ppi_tree, hf_tag, tvb, offset, data_len, ENC_NA)\n\nstatic int\ndissect_ppi(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\n{\n    proto_tree    *ppi_tree    = NULL, *ppi_flags_tree = NULL, *seg_tree = NULL, *ampdu_tree = NULL;\n    proto_tree    *agg_tree    = NULL;\n    proto_item    *ti          = NULL;\n    tvbuff_t      *next_tvb;\n    int            offset      = 0;\n    unsigned       version, flags;\n    int            tot_len, data_len;\n    unsigned       data_type;\n    uint32_t       dlt;\n    uint32_t       n_ext_flags = 0;\n    uint32_t       ampdu_id    = 0;\n    fragment_head *fd_head     = NULL;\n    fragment_item *ft_fdh      = NULL;\n    int            mpdu_count  = 0;\n    char          *mpdu_str;\n    bool           first_mpdu  = true;\n    unsigned       last_frame  = 0;\n    int len_remain, /*pad_len = 0,*/ ampdu_len = 0;\n    struct ieee_802_11_phdr phdr;\n\n    col_set_str(pinfo->cinfo, COL_PROTOCOL, \"PPI\");\n    col_clear(pinfo->cinfo, COL_INFO);\n\n    version = tvb_get_uint8(tvb, offset);\n    flags = tvb_get_uint8(tvb, offset + 1);\n\n    tot_len = tvb_get_letohs(tvb, offset+2);\n    dlt = tvb_get_letohl(tvb, offset+4);\n\n    col_add_fstr(pinfo->cinfo, COL_INFO, \"PPI version %u, %u bytes\",\n                 version, tot_len);\n\n    /* Dissect the packet */\n    if (tree) {\n        ti = proto_tree_add_protocol_format(tree, proto_ppi,\n                                            tvb, 0, tot_len, \"PPI version %u, %u bytes\", version, tot_len);\n        ppi_tree = proto_item_add_subtree(ti, ett_ppi_pph);\n        proto_tree_add_item(ppi_tree, hf_ppi_head_version,\n                            tvb, offset, 1, ENC_LITTLE_ENDIAN);\n\n        ti = proto_tree_add_item(ppi_tree, hf_ppi_head_flags,\n                                 tvb, offset + 1, 1, ENC_LITTLE_ENDIAN);\n        ppi_flags_tree = proto_item_add_subtree(ti, ett_ppi_flags);\n        proto_tree_add_item(ppi_flags_tree, hf_ppi_head_flag_alignment,\n                            tvb, offset + 1, 1, ENC_LITTLE_ENDIAN);\n        proto_tree_add_item(ppi_flags_tree, hf_ppi_head_flag_reserved,\n                            tvb, offset + 1, 1, ENC_LITTLE_ENDIAN);\n\n        proto_tree_add_item(ppi_tree, hf_ppi_head_len,\n                                 tvb, offset + 2, 2, ENC_LITTLE_ENDIAN);\n        proto_tree_add_item(ppi_tree, hf_ppi_head_dlt,\n                                 tvb, offset + 4, 4, ENC_LITTLE_ENDIAN);\n    }\n\n    tot_len -= PPI_V0_HEADER_LEN;\n    offset += 8;\n\n    /* We don't have any 802.11 metadata yet. */\n    memset(&phdr, 0, sizeof(phdr));\n    phdr.fcs_len = -1;\n    phdr.decrypted = false;\n    phdr.datapad = false;\n    phdr.phy = PHDR_802_11_PHY_UNKNOWN;\n\n    while (tot_len > 0) {\n        data_type = tvb_get_letohs(tvb, offset);\n        data_len = tvb_get_letohs(tvb, offset + 2) + 4;\n        tot_len -= data_len;\n\n        switch (data_type) {\n\n        case PPI_80211_COMMON:\n            dissect_80211_common(tvb, pinfo, ppi_tree, offset, data_len, &phdr);\n            break;\n\n        case PPI_80211N_MAC:\n            dissect_80211n_mac(tvb, pinfo, ppi_tree, offset, data_len,\n                true, &n_ext_flags, &ampdu_id, &phdr);\n            break;\n\n        case PPI_80211N_MAC_PHY:\n            dissect_80211n_mac_phy(tvb, pinfo, ppi_tree, offset,\n                data_len, &n_ext_flags, &ampdu_id, &phdr);\n            break;\n\n        case PPI_SPECTRUM_MAP:\n            ADD_BASIC_TAG(hf_spectrum_map);\n            break;\n\n        case PPI_PROCESS_INFO:\n            ADD_BASIC_TAG(hf_process_info);\n            break;\n\n        case PPI_CAPTURE_INFO:\n            ADD_BASIC_TAG(hf_capture_info);\n            break;\n\n        case PPI_AGGREGATION_EXTENSION:\n            dissect_aggregation_extension(tvb, pinfo, ppi_tree, offset, data_len);\n            break;\n\n        case PPI_8023_EXTENSION:\n            dissect_8023_extension(tvb, pinfo, ppi_tree, offset, data_len);\n            break;\n\n        case PPI_GPS_INFO:\n            if (ppi_gps_handle == NULL)\n            {\n                proto_tree_add_item(ppi_tree, hf_ppi_gps, tvb, offset, data_len, ENC_NA);\n            }\n            else /* we found a suitable dissector */\n            {\n                /* skip over the ppi_fieldheader, and pass it off to the dedicated GPS dissector */\n                next_tvb = tvb_new_subset_length_caplen(tvb, offset + 4, data_len - 4 , -1);\n                call_dissector(ppi_gps_handle, next_tvb, pinfo, ppi_tree);\n            }\n            break;\n\n        case PPI_VECTOR_INFO:\n            if (ppi_vector_handle == NULL)\n            {\n                proto_tree_add_item(ppi_tree, hf_ppi_vector, tvb, offset, data_len, ENC_NA);\n            }\n            else /* we found a suitable dissector */\n            {\n                /* skip over the ppi_fieldheader, and pass it off to the dedicated VECTOR dissector */\n                next_tvb = tvb_new_subset_length_caplen(tvb, offset + 4, data_len - 4 , -1);\n                call_dissector(ppi_vector_handle, next_tvb, pinfo, ppi_tree);\n            }\n            break;\n\n        case PPI_SENSOR_INFO:\n            if (ppi_sensor_handle == NULL)\n            {\n                proto_tree_add_item(ppi_tree, hf_ppi_harris, tvb, offset, data_len, ENC_NA);\n            }\n            else /* we found a suitable dissector */\n            {\n                /* skip over the ppi_fieldheader, and pass it off to the dedicated SENSOR dissector */\n                next_tvb = tvb_new_subset_length_caplen(tvb, offset + 4, data_len - 4 , -1);\n                call_dissector(ppi_sensor_handle, next_tvb, pinfo, ppi_tree);\n            }\n            break;\n\n        case PPI_ANTENNA_INFO:\n            if (ppi_antenna_handle == NULL)\n            {\n                proto_tree_add_item(ppi_tree, hf_ppi_antenna, tvb, offset, data_len, ENC_NA);\n            }\n            else /* we found a suitable dissector */\n            {\n                /* skip over the ppi_fieldheader, and pass it off to the dedicated ANTENNA dissector */\n                next_tvb = tvb_new_subset_length_caplen(tvb, offset + 4, data_len - 4 , -1);\n                call_dissector(ppi_antenna_handle, next_tvb, pinfo, ppi_tree);\n            }\n            break;\n\n        case FNET_PRIVATE:\n            if (ppi_fnet_handle == NULL)\n            {\n                proto_tree_add_item(ppi_tree, hf_ppi_fnet, tvb, offset, data_len, ENC_NA);\n            }\n            else /* we found a suitable dissector */\n            {\n                /* skip over the ppi_fieldheader, and pass it off to the dedicated FNET dissector */\n                next_tvb = tvb_new_subset_length_caplen(tvb, offset + 4, data_len - 4 , -1);\n                call_dissector(ppi_fnet_handle, next_tvb, pinfo, ppi_tree);\n            }\n            break;\n\n        default:\n            proto_tree_add_item(ppi_tree, hf_ppi_reserved, tvb, offset, data_len, ENC_NA);\n        }\n\n        offset += data_len;\n        if (IS_PPI_FLAG_ALIGN(flags)){\n            offset += PADDING4(offset);\n        }\n    }\n\n    /*\n     * The Channel-Flags field is described as \"Radiotap-formatted\n     * channel flags\".  The comment in the radiotap.org page about\n     * the suggested xchannel field says:\n     *\n     *  As used, this field conflates channel properties (which\n     *  need not be stored per packet but are more or less fixed)\n     *  with packet properties (like the modulation).\n     *\n     * The radiotap channel field, in practice, seems to be used,\n     * in some cases, to indicate channel properties (from which\n     * the packet modulation cannot be inferred) and, in other\n     * cases, to indicate the packet's modulation.\n     *\n     * The same applies to the Channel-Flags field.  There is a capture\n     * in which the Channel-Flags field indicates that the channel is\n     * an OFDM-only channel with a center frequency of 2422 MHz, and\n     * the data rate field indicates a 2 Mb/s rate, which means you can't\n     * rely on the CCK/OFDM/dynamic CCK/OFDM bits in the channel field\n     * to indicate anything.\n     *\n     * That makes the Channel-Flags field unusable either for determining\n     * the channel type or for determining the packet modulation,\n     * as it cannot be determined how it's being used.\n     *\n     * Fortunately, there are other ways to determine the packet\n     * modulation:\n     *\n     *  if there's an FHSS flag, the packet was transmitted\n     *  using the 802.11 legacy FHSS modulation;\n     *\n     *  otherwise:\n     *\n     *    if there's an 802.11n MAC Extension header or an 802.11n\n     *    MAC+PHY Extension header, the packet was transmitted using\n     *    one of the 11n HT PHY's specified modulations;\n     *\n     *    otherwise:\n     *\n     *      if the data rate is 1 Mb/s or 2 Mb/s, the packet was\n     *      transmitted using the 802.11 legacy DSSS modulation\n     *      (we ignore the IR PHY - was it ever implemented?);\n     *\n     *      if the data rate is 5 Mb/s or 11 Mb/s, the packet\n     *      was transmitted using the 802.11b DSSS/CCK modulation\n     *      (or the now-obsolete DSSS/PBCC modulation; *if* we can\n     *      rely on the channel/xchannel field's \"CCK channel\" and\n     *      \"Dynamic CCK-OFDM channel\" flags, the absence of either\n     *      flag would presumably indicate DSSS/PBCC);\n     *\n     *      if the data rate is 22 Mb/s or 33 Mb/s, the packet was\n     *      transmitted using the 802.11b DSSS/PBCC modulation (as\n     *      those speeds aren't supported by DSSS/CCK);\n     *\n     *      if the data rate is one of the OFDM rates for the 11a\n     *      OFDM PHY and the OFDM part of the 11g ERP PHY, the\n     *      packet was transmitted with the 11g/11a OFDM modulation.\n     *\n     * We've already handled the 11n headers, and may have attempted\n     * to use the Channel-Flags field to guess the modulation.  That\n     * guess might get the wrong answer for 11g \"Dynamic CCK-OFDM\"\n     * channels.\n     *\n     * If we have the data rate, we use it to:\n     *\n     *  fix up the 11g channels;\n     *\n     *  determine the modulation if we haven't been able to\n     *  determine it any other way.\n     */\n    if (phdr.has_data_rate) {\n        if (phdr.phy == PHDR_802_11_PHY_UNKNOWN) {\n            /*\n             * We don't know they PHY, but we do have the\n             * data rate; try to guess it based on the\n             * data rate and channel/center frequency.\n             */\n            if (RATE_IS_DSSS(phdr.data_rate)) {\n                /* 11b */\n                phdr.phy = PHDR_802_11_PHY_11B;\n            } else if (RATE_IS_OFDM(phdr.data_rate)) {\n                /* 11a or 11g, depending on the band. */\n                if (phdr.has_frequency) {\n                    if (FREQ_IS_BG(phdr.frequency)) {\n                        /* 11g */\n                        phdr.phy = PHDR_802_11_PHY_11G;\n                    } else {\n                        /* 11a */\n                        phdr.phy = PHDR_802_11_PHY_11A;\n                    }\n                }\n            }\n        } else if (phdr.phy == PHDR_802_11_PHY_11G) {\n            if (RATE_IS_DSSS(phdr.data_rate)) {\n                /* DSSS, so 11b. */\n                phdr.phy = PHDR_802_11_PHY_11B;\n            }\n        }\n    }\n\n    /*\n     * There is no indication, for HR/DSSS (11b/11g), whether\n     * the packet had a long or short preamble.\n     */\n    if (phdr.phy == PHDR_802_11_PHY_11B)\n        phdr.phy_info.info_11b.has_short_preamble = false;\n\n    if (ppi_ampdu_reassemble && DOT11N_IS_AGGREGATE(n_ext_flags)) {\n        len_remain = tvb_captured_length_remaining(tvb, offset);\n#if 0 /* XXX: pad_len never actually used ?? */\n        if (DOT11N_MORE_AGGREGATES(n_ext_flags)) {\n            pad_len = PADDING4(len_remain);\n        }\n#endif\n        pinfo->fragmented = true;\n\n        /* Make sure we aren't going to go past AGGREGATE_MAX\n         * and caclulate our full A-MPDU length */\n        fd_head = fragment_get(&ampdu_reassembly_table, pinfo, ampdu_id, NULL);\n        if (fd_head) {\n            for (ft_fdh = fd_head->next; ft_fdh; ft_fdh = ft_fdh->next) {\n                ampdu_len += ft_fdh->len + PADDING4(ft_fdh->len) + 4;\n            }\n        }\n        if (ampdu_len > AGGREGATE_MAX) {\n            proto_tree_add_expert_format(ppi_tree, pinfo, &ei_ppi_invalid_length, tvb, offset, -1, \"Aggregate length greater than maximum (%u)\", AGGREGATE_MAX);\n            return offset;\n        }\n\n        /*\n         * Note that we never actually reassemble our A-MPDUs.  Doing\n         * so would require prepending each MPDU with an A-MPDU delimiter\n         * and appending it with padding, only to hand it off to some\n         * routine which would un-do the work we just did.  We're using\n         * the reassembly code to track MPDU sizes and frame numbers.\n         */\n        /*??fd_head = */fragment_add_seq_next(&ampdu_reassembly_table,\n            tvb, offset, pinfo, ampdu_id, NULL, len_remain, true);\n        pinfo->fragmented = true;\n\n        /* Do reassembly? */\n        fd_head = fragment_get(&ampdu_reassembly_table, pinfo, ampdu_id, NULL);\n\n        /* Show our fragments */\n        if (fd_head && tree) {\n            ft_fdh = fd_head->next;\n            /* List our fragments */\n            seg_tree = proto_tree_add_subtree_format(ppi_tree, tvb, offset, -1,\n                    ett_ampdu_segments, &ti, \"A-MPDU (%u bytes w/hdrs):\", ampdu_len);\n            proto_item_set_generated(ti);\n\n            while (ft_fdh) {\n                if (ft_fdh->tvb_data && ft_fdh->len) {\n                    last_frame = ft_fdh->frame;\n                    if (!first_mpdu)\n                        proto_item_append_text(ti, \",\");\n                    first_mpdu = false;\n                    proto_item_append_text(ti, \" #%u(%u)\",\n                        ft_fdh->frame, ft_fdh->len);\n                    proto_tree_add_uint_format(seg_tree, hf_ampdu_segment,\n                        tvb, 0, 0, last_frame,\n                        \"Frame: %u (%u byte%s)\",\n                        last_frame,\n                        ft_fdh->len,\n                        plurality(ft_fdh->len, \"\", \"s\"));\n                }\n                ft_fdh = ft_fdh->next;\n            }\n            if (last_frame && last_frame != pinfo->num)\n                proto_tree_add_uint(seg_tree, hf_ampdu_reassembled_in,\n                    tvb, 0, 0, last_frame);\n        }\n\n        if (fd_head && !DOT11N_MORE_AGGREGATES(n_ext_flags)) {\n            if (tree) {\n                ti = proto_tree_add_protocol_format(tree, proto_aggregate,\n                    tvb, 0, tot_len, \"IEEE 802.11 Aggregate MPDU\");\n                agg_tree = proto_item_add_subtree(ti, ett_ampdu);\n            }\n\n            for (ft_fdh = fd_head->next; ft_fdh; ft_fdh = ft_fdh->next) {\n                if (ft_fdh->tvb_data && ft_fdh->len) {\n                    mpdu_count++;\n                    mpdu_str = wmem_strdup_printf(pinfo->pool, \"MPDU #%d\", mpdu_count);\n\n                    next_tvb = tvb_new_chain(tvb, ft_fdh->tvb_data);\n                    add_new_data_source(pinfo, next_tvb, mpdu_str);\n\n                    ampdu_tree = proto_tree_add_subtree(agg_tree, next_tvb, 0, -1, ett_ampdu_segment, NULL, mpdu_str);\n                    call_dissector_with_data(ieee80211_radio_handle, next_tvb, pinfo, ampdu_tree, &phdr);\n                }\n            }\n            proto_tree_add_uint(seg_tree, hf_ampdu_count, tvb, 0, 0, mpdu_count);\n            pinfo->fragmented=false;\n        } else {\n            next_tvb = tvb_new_subset_remaining(tvb, offset);\n            col_set_str(pinfo->cinfo, COL_PROTOCOL, \"IEEE 802.11n\");\n            col_set_str(pinfo->cinfo, COL_INFO, \"Unreassembled A-MPDU data\");\n            call_data_dissector(next_tvb, pinfo, tree);\n        }\n        return tvb_captured_length(tvb);\n    }\n\n    next_tvb = tvb_new_subset_remaining(tvb, offset);\n    /*\n     * Handle LINKTYPE_IEEE802_11, which is 105, specially; call the\n     * \"802.11 with radio information\" dissector, and pass it a pointer\n     * to the struct ieee_802_11_phdr we've constructed from the PPI data,\n     * so that it can display that information.\n     *\n     * Handle everything else with the pcap_pktdata dissector, letting\n     * it do whatever needs to be done about pseudo-headers.\n     */\n    if (dlt == 105) {\n        /* LINKTYPE_IEEE802_11 */\n        call_dissector_with_data(ieee80211_radio_handle, next_tvb, pinfo, tree, &phdr);\n    } else {\n        /* Everything else. */\n        call_dissector_with_data(pcap_pktdata_handle, next_tvb, pinfo, tree, &dlt);\n    }\n    return tvb_captured_length(tvb);\n}\n\n/* Establish our beachhead */\n\nvoid\nproto_register_ppi(void)\n{\n    static hf_register_info hf[] = {\n    { &hf_ppi_head_version,\n      { \"Version\", \"ppi.version\",\n        FT_UINT8, BASE_DEC, NULL, 0x0,\n        \"PPI header format version\", HFILL } },\n    { &hf_ppi_head_flags,\n      { \"Flags\", \"ppi.flags\",\n        FT_UINT8, BASE_HEX, NULL, 0x0,\n        \"PPI header flags\", HFILL } },\n    { &hf_ppi_head_flag_alignment,\n      { \"Alignment\", \"ppi.flags.alignment\",\n        FT_BOOLEAN, 8, TFS(&tfs_ppi_head_flag_alignment), 0x01,\n        \"PPI header flags - 32bit Alignment\", HFILL } },\n    { &hf_ppi_head_flag_reserved,\n      { \"Reserved\", \"ppi.flags.reserved\",\n        FT_UINT8, BASE_HEX, NULL, 0xFE,\n        \"PPI header flags - Reserved Flags\", HFILL } },\n    { &hf_ppi_head_len,\n       { \"Header length\", \"ppi.length\",\n         FT_UINT16, BASE_DEC, NULL, 0x0,\n         \"Length of header including payload\", HFILL } },\n    { &hf_ppi_head_dlt,\n       { \"DLT\", \"ppi.dlt\",\n         FT_UINT32, BASE_DEC, NULL, 0x0, \"libpcap Data Link Type (DLT) of the payload\", HFILL } },\n\n    { &hf_ppi_field_type,\n       { \"Field type\", \"ppi.field_type\",\n         FT_UINT16, BASE_DEC, VALS(vs_ppi_field_type), 0x0, \"PPI data field type\", HFILL } },\n    { &hf_ppi_field_len,\n       { \"Field length\", \"ppi.field_len\",\n         FT_UINT16, BASE_DEC, NULL, 0x0, \"PPI data field length\", HFILL } },\n\n    { &hf_80211_common_tsft,\n       { \"TSFT\", \"ppi.80211-common.tsft\",\n         FT_UINT64, BASE_DEC, NULL, 0x0, \"PPI 802.11-Common Timing Synchronization Function Timer (TSFT)\", HFILL } },\n    { &hf_80211_common_flags,\n       { \"Flags\", \"ppi.80211-common.flags\",\n         FT_UINT16, BASE_HEX, NULL, 0x0, \"PPI 802.11-Common Flags\", HFILL } },\n    { &hf_80211_common_flags_fcs,\n       { \"FCS present flag\", \"ppi.80211-common.flags.fcs\",\n         FT_BOOLEAN, 16, TFS(&tfs_present_absent), DOT11_FLAG_HAVE_FCS, \"PPI 802.11-Common Frame Check Sequence (FCS) Present Flag\", HFILL } },\n    { &hf_80211_common_flags_tsft,\n       { \"TSFT flag\", \"ppi.80211-common.flags.tsft\",\n         FT_BOOLEAN, 16, TFS(&tfs_tsft_ms), DOT11_FLAG_TSF_TIMER_MS, \"PPI 802.11-Common Timing Synchronization Function Timer (TSFT) msec/usec flag\", HFILL } },\n    { &hf_80211_common_flags_fcs_valid,\n       { \"FCS validity\", \"ppi.80211-common.flags.fcs-invalid\",\n         FT_BOOLEAN, 16, TFS(&tfs_invalid_valid), DOT11_FLAG_FCS_INVALID, \"PPI 802.11-Common Frame Check Sequence (FCS) Validity flag\", HFILL } },\n    { &hf_80211_common_flags_phy_err,\n       { \"PHY error flag\", \"ppi.80211-common.flags.phy-err\",\n         FT_BOOLEAN, 16, TFS(&tfs_phy_error), DOT11_FLAG_PHY_ERROR, \"PPI 802.11-Common Physical level (PHY) Error\", HFILL } },\n    { &hf_80211_common_rate,\n       { \"Data rate\", \"ppi.80211-common.rate\",\n         FT_UINT16, BASE_DEC, NULL, 0x0, \"PPI 802.11-Common Data Rate (x 500 Kbps)\", HFILL } },\n    { &hf_80211_common_chan_freq,\n       { \"Channel frequency\", \"ppi.80211-common.chan.freq\",\n         FT_UINT16, BASE_DEC, NULL, 0x0,\n        \"PPI 802.11-Common Channel Frequency\", HFILL } },\n    { &hf_80211_common_chan_flags,\n       { \"Channel flags\", \"ppi.80211-common.chan.flags\",\n         FT_UINT16, BASE_HEX, NULL, 0x0, \"PPI 802.11-Common Channel Flags\", HFILL } },\n\n    { &hf_80211_common_chan_flags_turbo,\n       { \"Turbo\", \"ppi.80211-common.chan.flags.turbo\",\n         FT_BOOLEAN, 16, NULL, IEEE80211_CHAN_TURBO, \"PPI 802.11-Common Channel Flags Turbo\", HFILL } },\n    { &hf_80211_common_chan_flags_cck,\n       { \"Complementary Code Keying (CCK)\", \"ppi.80211-common.chan.flags.cck\",\n         FT_BOOLEAN, 16, NULL, IEEE80211_CHAN_CCK, \"PPI 802.11-Common Channel Flags Complementary Code Keying (CCK) Modulation\", HFILL } },\n    { &hf_80211_common_chan_flags_ofdm,\n       { \"Orthogonal Frequency-Division Multiplexing (OFDM)\", \"ppi.80211-common.chan.flags.ofdm\",\n         FT_BOOLEAN, 16, NULL, IEEE80211_CHAN_OFDM, \"PPI 802.11-Common Channel Flags Orthogonal Frequency-Division Multiplexing (OFDM)\", HFILL } },\n    { &hf_80211_common_chan_flags_2ghz,\n       { \"2 GHz spectrum\", \"ppi.80211-common.chan.flags.2ghz\",\n         FT_BOOLEAN, 16, NULL, IEEE80211_CHAN_2GHZ, \"PPI 802.11-Common Channel Flags 2 GHz spectrum\", HFILL } },\n    { &hf_80211_common_chan_flags_5ghz,\n       { \"5 GHz spectrum\", \"ppi.80211-common.chan.flags.5ghz\",\n         FT_BOOLEAN, 16, NULL, IEEE80211_CHAN_5GHZ, \"PPI 802.11-Common Channel Flags 5 GHz spectrum\", HFILL } },\n    { &hf_80211_common_chan_flags_passive,\n       { \"Passive\", \"ppi.80211-common.chan.flags.passive\",\n         FT_BOOLEAN, 16, NULL, IEEE80211_CHAN_PASSIVE, \"PPI 802.11-Common Channel Flags Passive\", HFILL } },\n    { &hf_80211_common_chan_flags_dynamic,\n       { \"Dynamic CCK-OFDM\", \"ppi.80211-common.chan.flags.dynamic\",\n         FT_BOOLEAN, 16, NULL, IEEE80211_CHAN_DYN, \"PPI 802.11-Common Channel Flags Dynamic CCK-OFDM Channel\", HFILL } },\n    { &hf_80211_common_chan_flags_gfsk,\n       { \"Gaussian Frequency Shift Keying (GFSK)\", \"ppi.80211-common.chan.flags.gfsk\",\n         FT_BOOLEAN, 16, NULL, IEEE80211_CHAN_GFSK, \"PPI 802.11-Common Channel Flags Gaussian Frequency Shift Keying (GFSK) Modulation\", HFILL } },\n\n    { &hf_80211_common_fhss_hopset,\n       { \"FHSS hopset\", \"ppi.80211-common.fhss.hopset\",\n         FT_UINT8, BASE_HEX, NULL, 0x0, \"PPI 802.11-Common Frequency-Hopping Spread Spectrum (FHSS) Hopset\", HFILL } },\n    { &hf_80211_common_fhss_pattern,\n       { \"FHSS pattern\", \"ppi.80211-common.fhss.pattern\",\n         FT_UINT8, BASE_HEX, NULL, 0x0, \"PPI 802.11-Common Frequency-Hopping Spread Spectrum (FHSS) Pattern\", HFILL } },\n    { &hf_80211_common_dbm_antsignal,\n       { \"dBm antenna signal\", \"ppi.80211-common.dbm.antsignal\",\n         FT_INT8, BASE_DEC, NULL, 0x0, \"PPI 802.11-Common dBm Antenna Signal\", HFILL } },\n    { &hf_80211_common_dbm_antnoise,\n       { \"dBm antenna noise\", \"ppi.80211-common.dbm.antnoise\",\n         FT_INT8, BASE_DEC, NULL, 0x0, \"PPI 802.11-Common dBm Antenna Noise\", HFILL } },\n\n    /* 802.11n MAC */\n    { &hf_80211n_mac_flags,\n       { \"MAC flags\", \"ppi.80211n-mac.flags\",\n         FT_UINT32, BASE_HEX, NULL, 0x0, \"PPI 802.11n MAC flags\", HFILL } },\n    { &hf_80211n_mac_flags_greenfield,\n       { \"Greenfield flag\", \"ppi.80211n-mac.flags.greenfield\",\n         FT_BOOLEAN, 32, NULL, DOT11N_FLAG_GREENFIELD, \"PPI 802.11n MAC Greenfield Flag\", HFILL } },\n    { &hf_80211n_mac_flags_ht20_40,\n       { \"HT20/HT40 flag\", \"ppi.80211n-mac.flags.ht20_40\",\n         FT_BOOLEAN, 32, TFS(&tfs_ht20_40), DOT11N_FLAG_HT40, \"PPI 802.11n MAC HT20/HT40 Flag\", HFILL } },\n    { &hf_80211n_mac_flags_rx_guard_interval,\n       { \"RX Short Guard Interval (SGI) flag\", \"ppi.80211n-mac.flags.rx.short_guard_interval\",\n         FT_BOOLEAN, 32, NULL, DOT11N_FLAG_SHORT_GI, \"PPI 802.11n MAC RX Short Guard Interval (SGI) Flag\", HFILL } },\n    { &hf_80211n_mac_flags_duplicate_rx,\n       { \"Duplicate RX flag\", \"ppi.80211n-mac.flags.rx.duplicate\",\n         FT_BOOLEAN, 32, NULL, DOT11N_FLAG_DUPLICATE_RX, \"PPI 802.11n MAC Duplicate RX Flag\", HFILL } },\n    { &hf_80211n_mac_flags_aggregate,\n       { \"Aggregate flag\", \"ppi.80211n-mac.flags.agg\",\n         FT_BOOLEAN, 32, NULL, DOT11N_FLAG_IS_AGGREGATE, \"PPI 802.11 MAC Aggregate Flag\", HFILL } },\n    { &hf_80211n_mac_flags_more_aggregates,\n       { \"More aggregates flag\", \"ppi.80211n-mac.flags.more_agg\",\n         FT_BOOLEAN, 32, NULL, DOT11N_FLAG_MORE_AGGREGATES, \"PPI 802.11n MAC More Aggregates Flag\", HFILL } },\n    { &hf_80211n_mac_flags_delimiter_crc_after,\n       { \"A-MPDU Delimiter CRC error after this frame flag\", \"ppi.80211n-mac.flags.delim_crc_error_after\",\n         FT_BOOLEAN, 32, NULL, DOT11N_FLAG_AGG_CRC_ERROR, \"PPI 802.11n MAC A-MPDU Delimiter CRC Error After This Frame Flag\", HFILL } },\n    { &hf_80211n_mac_ampdu_id,\n       { \"AMPDU-ID\", \"ppi.80211n-mac.ampdu_id\",\n         FT_UINT32, BASE_HEX, NULL, 0x0, \"PPI 802.11n MAC AMPDU-ID\", HFILL } },\n    { &hf_80211n_mac_num_delimiters,\n       { \"Num-Delimiters\", \"ppi.80211n-mac.num_delimiters\",\n         FT_UINT8, BASE_DEC, NULL, 0x0, \"PPI 802.11n MAC number of zero-length pad delimiters\", HFILL } },\n    { &hf_80211n_mac_reserved,\n       { \"Reserved\", \"ppi.80211n-mac.reserved\",\n         FT_UINT24, BASE_HEX, NULL, 0x0, \"PPI 802.11n MAC Reserved\", HFILL } },\n\n\n    /* 802.11n MAC+PHY */\n    { &hf_80211n_mac_phy_mcs,\n       { \"MCS\", \"ppi.80211n-mac-phy.mcs\",\n         FT_UINT8, BASE_DEC, NULL, 0x0, \"PPI 802.11n MAC+PHY Modulation Coding Scheme (MCS)\", HFILL } },\n    { &hf_80211n_mac_phy_num_streams,\n       { \"Number of spatial streams\", \"ppi.80211n-mac-phy.num_streams\",\n         FT_UINT8, BASE_DEC, NULL, 0x0, \"PPI 802.11n MAC+PHY number of spatial streams\", HFILL } },\n    { &hf_80211n_mac_phy_rssi_combined,\n       { \"RSSI combined\", \"ppi.80211n-mac-phy.rssi.combined\",\n         FT_UINT8, BASE_DEC, NULL, 0x0, \"PPI 802.11n MAC+PHY Received Signal Strength Indication (RSSI) Combined\", HFILL } },\n    { &hf_80211n_mac_phy_rssi_ant0_ctl,\n       { \"Antenna 0 control RSSI\", \"ppi.80211n-mac-phy.rssi.ant0ctl\",\n         FT_UINT8, BASE_DEC, NULL, 0x0, \"PPI 802.11n MAC+PHY Antenna 0 Control Channel Received Signal Strength Indication (RSSI)\", HFILL } },\n    { &hf_80211n_mac_phy_rssi_ant1_ctl,\n       { \"Antenna 1 control RSSI\", \"ppi.80211n-mac-phy.rssi.ant1ctl\",\n         FT_UINT8, BASE_DEC, NULL, 0x0, \"PPI 802.11n MAC+PHY Antenna 1 Control Channel Received Signal Strength Indication (RSSI)\", HFILL } },\n    { &hf_80211n_mac_phy_rssi_ant2_ctl,\n       { \"Antenna 2 control RSSI\", \"ppi.80211n-mac-phy.rssi.ant2ctl\",\n         FT_UINT8, BASE_DEC, NULL, 0x0, \"PPI 802.11n MAC+PHY Antenna 2 Control Channel Received Signal Strength Indication (RSSI)\", HFILL } },\n    { &hf_80211n_mac_phy_rssi_ant3_ctl,\n       { \"Antenna 3 control RSSI\", \"ppi.80211n-mac-phy.rssi.ant3ctl\",\n         FT_UINT8, BASE_DEC, NULL, 0x0, \"PPI 802.11n MAC+PHY Antenna 3 Control Channel Received Signal Strength Indication (RSSI)\", HFILL } },\n    { &hf_80211n_mac_phy_rssi_ant0_ext,\n       { \"Antenna 0 extension RSSI\", \"ppi.80211n-mac-phy.rssi.ant0ext\",\n         FT_UINT8, BASE_DEC, NULL, 0x0, \"PPI 802.11n MAC+PHY Antenna 0 Extension Channel Received Signal Strength Indication (RSSI)\", HFILL } },\n    { &hf_80211n_mac_phy_rssi_ant1_ext,\n       { \"Antenna 1 extension RSSI\", \"ppi.80211n-mac-phy.rssi.ant1ext\",\n         FT_UINT8, BASE_DEC, NULL, 0x0, \"PPI 802.11n MAC+PHY Antenna 1 Extension Channel Received Signal Strength Indication (RSSI)\", HFILL } },\n    { &hf_80211n_mac_phy_rssi_ant2_ext,\n       { \"Antenna 2 extension RSSI\", \"ppi.80211n-mac-phy.rssi.ant2ext\",\n         FT_UINT8, BASE_DEC, NULL, 0x0, \"PPI 802.11n MAC+PHY Antenna 2 Extension Channel Received Signal Strength Indication (RSSI)\", HFILL } },\n    { &hf_80211n_mac_phy_rssi_ant3_ext,\n       { \"Antenna 3 extension RSSI\", \"ppi.80211n-mac-phy.rssi.ant3ext\",\n         FT_UINT8, BASE_DEC, NULL, 0x0, \"PPI 802.11n MAC+PHY Antenna 3 Extension Channel Received Signal Strength Indication (RSSI)\", HFILL } },\n    { &hf_80211n_mac_phy_ext_chan_freq,\n       { \"Extended channel frequency\", \"ppi.80211-mac-phy.ext-chan.freq\",\n         FT_UINT16, BASE_DEC, NULL, 0x0, \"PPI 802.11n MAC+PHY Extended Channel Frequency\", HFILL } },\n    { &hf_80211n_mac_phy_ext_chan_flags,\n       { \"Channel flags\", \"ppi.80211-mac-phy.ext-chan.flags\",\n         FT_UINT16, BASE_HEX, NULL, 0x0, \"PPI 802.11n MAC+PHY Channel Flags\", HFILL } },\n    { &hf_80211n_mac_phy_ext_chan_flags_turbo,\n       { \"Turbo\", \"ppi.80211-mac-phy.ext-chan.flags.turbo\",\n         FT_BOOLEAN, 16, NULL, 0x0010, \"PPI 802.11n MAC+PHY Channel Flags Turbo\", HFILL } },\n    { &hf_80211n_mac_phy_ext_chan_flags_cck,\n       { \"Complementary Code Keying (CCK)\", \"ppi.80211-mac-phy.ext-chan.flags.cck\",\n         FT_BOOLEAN, 16, NULL, 0x0020, \"PPI 802.11n MAC+PHY Channel Flags Complementary Code Keying (CCK) Modulation\", HFILL } },\n    { &hf_80211n_mac_phy_ext_chan_flags_ofdm,\n       { \"Orthogonal Frequency-Division Multiplexing (OFDM)\", \"ppi.80211-mac-phy.ext-chan.flags.ofdm\",\n         FT_BOOLEAN, 16, NULL, 0x0040, \"PPI 802.11n MAC+PHY Channel Flags Orthogonal Frequency-Division Multiplexing (OFDM)\", HFILL } },\n    { &hf_80211n_mac_phy_ext_chan_flags_2ghz,\n       { \"2 GHz spectrum\", \"ppi.80211-mac-phy.ext-chan.flags.2ghz\",\n         FT_BOOLEAN, 16, NULL, 0x0080, \"PPI 802.11n MAC+PHY Channel Flags 2 GHz spectrum\", HFILL } },\n    { &hf_80211n_mac_phy_ext_chan_flags_5ghz,\n       { \"5 GHz spectrum\", \"ppi.80211-mac-phy.ext-chan.flags.5ghz\",\n         FT_BOOLEAN, 16, NULL, 0x0100, \"PPI 802.11n MAC+PHY Channel Flags 5 GHz spectrum\", HFILL } },\n    { &hf_80211n_mac_phy_ext_chan_flags_passive,\n       { \"Passive\", \"ppi.80211-mac-phy.ext-chan.flags.passive\",\n         FT_BOOLEAN, 16, NULL, 0x0200, \"PPI 802.11n MAC+PHY Channel Flags Passive\", HFILL } },\n    { &hf_80211n_mac_phy_ext_chan_flags_dynamic,\n       { \"Dynamic CCK-OFDM\", \"ppi.80211-mac-phy.ext-chan.flags.dynamic\",\n         FT_BOOLEAN, 16, NULL, 0x0400, \"PPI 802.11n MAC+PHY Channel Flags Dynamic CCK-OFDM Channel\", HFILL } },\n    { &hf_80211n_mac_phy_ext_chan_flags_gfsk,\n       { \"Gaussian Frequency Shift Keying (GFSK)\", \"ppi.80211-mac-phy.ext-chan.flags.gfsk\",\n         FT_BOOLEAN, 16, NULL, 0x0800, \"PPI 802.11n MAC+PHY Channel Flags Gaussian Frequency Shift Keying (GFSK) Modulation\", HFILL } },\n    { &hf_80211n_mac_phy_dbm_ant0signal,\n       { \"dBm antenna 0 signal\", \"ppi.80211n-mac-phy.dbmant0.signal\",\n         FT_INT8, BASE_DEC, NULL, 0x0, \"PPI 802.11n MAC+PHY dBm Antenna 0 Signal\", HFILL } },\n    { &hf_80211n_mac_phy_dbm_ant0noise,\n       { \"dBm antenna 0 noise\", \"ppi.80211n-mac-phy.dbmant0.noise\",\n         FT_INT8, BASE_DEC, NULL, 0x0, \"PPI 802.11n MAC+PHY dBm Antenna 0 Noise\", HFILL } },\n    { &hf_80211n_mac_phy_dbm_ant1signal,\n       { \"dBm antenna 1 signal\", \"ppi.80211n-mac-phy.dbmant1.signal\",\n         FT_INT8, BASE_DEC, NULL, 0x0, \"PPI 802.11n MAC+PHY dBm Antenna 1 Signal\", HFILL } },\n    { &hf_80211n_mac_phy_dbm_ant1noise,\n       { \"dBm antenna 1 noise\", \"ppi.80211n-mac-phy.dbmant1.noise\",\n         FT_INT8, BASE_DEC, NULL, 0x0, \"PPI 802.11n MAC+PHY dBm Antenna 1 Noise\", HFILL } },\n    { &hf_80211n_mac_phy_dbm_ant2signal,\n       { \"dBm antenna 2 signal\", \"ppi.80211n-mac-phy.dbmant2.signal\",\n         FT_INT8, BASE_DEC, NULL, 0x0, \"PPI 802.11n MAC+PHY dBm Antenna 2 Signal\", HFILL } },\n    { &hf_80211n_mac_phy_dbm_ant2noise,\n       { \"dBm antenna 2 noise\", \"ppi.80211n-mac-phy.dbmant2.noise\",\n         FT_INT8, BASE_DEC, NULL, 0x0, \"PPI 802.11n MAC+PHY dBm Antenna 2 Noise\", HFILL } },\n    { &hf_80211n_mac_phy_dbm_ant3signal,\n       { \"dBm antenna 3 signal\", \"ppi.80211n-mac-phy.dbmant3.signal\",\n         FT_INT8, BASE_DEC, NULL, 0x0, \"PPI 802.11n MAC+PHY dBm Antenna 3 Signal\", HFILL } },\n    { &hf_80211n_mac_phy_dbm_ant3noise,\n       { \"dBm antenna 3 noise\", \"ppi.80211n-mac-phy.dbmant3.noise\",\n         FT_INT8, BASE_DEC, NULL, 0x0, \"PPI 802.11n MAC+PHY dBm Antenna 3 Noise\", HFILL } },\n    { &hf_80211n_mac_phy_evm0,\n       { \"EVM-0\", \"ppi.80211n-mac-phy.evm0\",\n         FT_UINT32, BASE_DEC, NULL, 0x0, \"PPI 802.11n MAC+PHY Error Vector Magnitude (EVM) for chain 0\", HFILL } },\n    { &hf_80211n_mac_phy_evm1,\n       { \"EVM-1\", \"ppi.80211n-mac-phy.evm1\",\n         FT_UINT32, BASE_DEC, NULL, 0x0, \"PPI 802.11n MAC+PHY Error Vector Magnitude (EVM) for chain 1\", HFILL } },\n    { &hf_80211n_mac_phy_evm2,\n       { \"EVM-2\", \"ppi.80211n-mac-phy.evm2\",\n         FT_UINT32, BASE_DEC, NULL, 0x0, \"PPI 802.11n MAC+PHY Error Vector Magnitude (EVM) for chain 2\", HFILL } },\n    { &hf_80211n_mac_phy_evm3,\n       { \"EVM-3\", \"ppi.80211n-mac-phy.evm3\",\n         FT_UINT32, BASE_DEC, NULL, 0x0, \"PPI 802.11n MAC+PHY Error Vector Magnitude (EVM) for chain 3\", HFILL } },\n\n    { &hf_ampdu_segment,\n        { \"A-MPDU\", \"ppi.80211n-mac.ampdu\",\n            FT_FRAMENUM, BASE_NONE, NULL, 0x0, \"802.11n Aggregated MAC Protocol Data Unit (A-MPDU)\", HFILL }},\n#if 0\n    { &hf_ampdu_segments,\n        { \"Reassembled A-MPDU\", \"ppi.80211n-mac.ampdu.reassembled\",\n            FT_NONE, BASE_NONE, NULL, 0x0, \"Reassembled Aggregated MAC Protocol Data Unit (A-MPDU)\", HFILL }},\n#endif\n    { &hf_ampdu_reassembled_in,\n        { \"Reassembled A-MPDU in frame\", \"ppi.80211n-mac.ampdu.reassembled_in\",\n            FT_FRAMENUM, BASE_NONE, NULL, 0x0,\n            \"The A-MPDU that doesn't end in this segment is reassembled in this frame\",\n            HFILL }},\n    { &hf_ampdu_count,\n        { \"MPDU count\", \"ppi.80211n-mac.ampdu.count\",\n            FT_UINT16, BASE_DEC, NULL, 0x0, \"The number of aggregated MAC Protocol Data Units (MPDUs)\", HFILL }},\n\n    { &hf_spectrum_map,\n       { \"Radio spectrum map\", \"ppi.spectrum-map\",\n            FT_BYTES, BASE_NONE, NULL, 0x0, \"PPI Radio spectrum map\", HFILL } },\n    { &hf_process_info,\n       { \"Process information\", \"ppi.proc-info\",\n            FT_BYTES, BASE_NONE, NULL, 0x0, \"PPI Process information\", HFILL } },\n    { &hf_capture_info,\n       { \"Capture information\", \"ppi.cap-info\",\n            FT_BYTES, BASE_NONE, NULL, 0x0, \"PPI Capture information\", HFILL } },\n\n    /* Aggregation Extension */\n    { &hf_aggregation_extension_interface_id,\n       { \"Interface ID\", \"ppi.aggregation_extension.interface_id\",\n            FT_UINT32, BASE_DEC, NULL, 0x0, \"Zero-based index of the physical interface the packet was captured from\", HFILL } },\n\n    /* 802.3 Extension */\n    { &hf_8023_extension_flags,\n       { \"Flags\", \"ppi.8023_extension.flags\",\n            FT_UINT32, BASE_HEX, NULL, 0x0, \"PPI 802.3 Extension Flags\", HFILL } },\n    { &hf_8023_extension_flags_fcs_present,\n       { \"FCS Present Flag\", \"ppi.8023_extension.flags.fcs_present\",\n            FT_BOOLEAN, 32, NULL, 0x00000001, \"FCS (4 bytes) is present at the end of the packet\", HFILL } },\n    { &hf_8023_extension_errors,\n       { \"Errors\", \"ppi.8023_extension.errors\",\n            FT_UINT32, BASE_HEX, NULL, 0x0, \"PPI 802.3 Extension Errors\", HFILL } },\n    { &hf_8023_extension_errors_fcs,\n       { \"FCS Error\", \"ppi.8023_extension.errors.fcs\",\n            FT_BOOLEAN, 32, NULL, 0x00000001,\n            \"PPI 802.3 Extension FCS Error\", HFILL } },\n    { &hf_8023_extension_errors_sequence,\n       { \"Sequence Error\", \"ppi.8023_extension.errors.sequence\",\n            FT_BOOLEAN, 32, NULL, 0x00000002,\n            \"PPI 802.3 Extension Sequence Error\", HFILL } },\n    { &hf_8023_extension_errors_symbol,\n       { \"Symbol Error\", \"ppi.8023_extension.errors.symbol\",\n            FT_BOOLEAN, 32, NULL, 0x00000004,\n            \"PPI 802.3 Extension Symbol Error\", HFILL } },\n    { &hf_8023_extension_errors_data,\n       { \"Data Error\", \"ppi.8023_extension.errors.data\",\n            FT_BOOLEAN, 32, NULL, 0x00000008,\n            \"PPI 802.3 Extension Data Error\", HFILL } },\n\n      /* Generated from convert_proto_tree_add_text.pl */\n      { &hf_ppi_gps, { \"GPS\", \"ppi.gps\", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},\n      { &hf_ppi_vector, { \"VECTOR\", \"ppi.vector\", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},\n      { &hf_ppi_harris, { \"HARRIS\", \"ppi.harris\", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},\n      { &hf_ppi_antenna, { \"ANTENNA\", \"ppi.antenna\", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},\n      { &hf_ppi_fnet, { \"FNET\", \"ppi.fnet\", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},\n      { &hf_ppi_reserved, { \"Reserved\", \"ppi.reserved\", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},\n    };\n\n    static int *ett[] = {\n        &ett_ppi_pph,\n        &ett_ppi_flags,\n        &ett_dot11_common,\n        &ett_dot11_common_flags,\n        &ett_dot11_common_channel_flags,\n        &ett_dot11n_mac,\n        &ett_dot11n_mac_flags,\n        &ett_dot11n_mac_phy,\n        &ett_dot11n_mac_phy_ext_channel_flags,\n        &ett_ampdu_segments,\n        &ett_ampdu,\n        &ett_ampdu_segment,\n        &ett_aggregation_extension,\n        &ett_8023_extension,\n        &ett_8023_extension_flags,\n        &ett_8023_extension_errors\n    };\n\n    static ei_register_info ei[] = {\n        { &ei_ppi_invalid_length, { \"ppi.invalid_length\", PI_MALFORMED, PI_ERROR, \"Invalid length\", EXPFILL }},\n    };\n\n    module_t *ppi_module;\n    expert_module_t* expert_ppi;\n\n    proto_ppi = proto_register_protocol(\"PPI Packet Header\", \"PPI\", \"ppi\");\n    proto_register_field_array(proto_ppi, hf, array_length(hf));\n    proto_register_subtree_array(ett, array_length(ett));\n    expert_ppi = expert_register_protocol(proto_ppi);\n    expert_register_field_array(expert_ppi, ei, array_length(ei));\n\n    ppi_handle = register_dissector(\"ppi\", dissect_ppi, proto_ppi);\n    register_capture_dissector_table(\"ppi\", \"PPI\");\n\n    reassembly_table_register(&ampdu_reassembly_table,\n                          &addresses_reassembly_table_functions);\n\n    /* Configuration options */\n    ppi_module = prefs_register_protocol(proto_ppi, NULL);\n    prefs_register_bool_preference(ppi_module, \"reassemble\",\n                                   \"Reassemble fragmented 802.11 A-MPDUs\",\n                                   \"Whether fragmented 802.11 aggregated MPDUs should be reassembled\",\n                                   &ppi_ampdu_reassemble);\n}\n\nvoid\nproto_reg_handoff_ppi(void)\n{\n    capture_dissector_handle_t ppi_cap_handle;\n\n    ieee80211_radio_handle = find_dissector_add_dependency(\"wlan_radio\", proto_ppi);\n    pcap_pktdata_handle = find_dissector_add_dependency(\"pcap_pktdata\", proto_ppi);\n    ppi_gps_handle = find_dissector_add_dependency(\"ppi_gps\", proto_ppi);\n    ppi_vector_handle = find_dissector_add_dependency(\"ppi_vector\", proto_ppi);\n    ppi_sensor_handle = find_dissector_add_dependency(\"ppi_sensor\", proto_ppi);\n    ppi_antenna_handle = find_dissector_add_dependency(\"ppi_antenna\", proto_ppi);\n    ppi_fnet_handle = find_dissector_add_dependency(\"ppi_fnet\", proto_ppi);\n\n    dissector_add_uint(\"wtap_encap\", WTAP_ENCAP_PPI, ppi_handle);\n    ppi_cap_handle = create_capture_dissector_handle(capture_ppi, proto_ppi);\n    capture_dissector_add_uint(\"wtap_encap\", WTAP_ENCAP_PPI, ppi_cap_handle);\n\n    proto_aggregate = proto_get_id_by_filter_name(\"wlan_aggregate\");\n}\n\n/*\n * Editor modelines\n *\n * Local Variables:\n * c-basic-offset: 4\n * tab-width: 8\n * indent-tabs-mode: nil\n * End:\n *\n * ex: set shiftwidth=4 tabstop=8 expandtab:\n * :indentSize=4:tabSize=8:noTabs=true:\n */\n", "patch": "@@ -857,6 +857,9 @@ dissect_ppi(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)\n     guint          last_frame  = 0;\n     gint len_remain, /*pad_len = 0,*/ ampdu_len = 0;\n     struct ieee_802_11_phdr phdr;\n+    int            wtap_encap;\n+    struct eth_phdr eth;\n+    void          *phdrp;\n \n     col_set_str(pinfo->cinfo, COL_PROTOCOL, \"PPI\");\n     col_clear(pinfo->cinfo, COL_INFO);\n@@ -1137,8 +1140,20 @@ dissect_ppi(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)\n         call_dissector_with_data(ieee80211_radio_handle, next_tvb, pinfo, tree, &phdr);\n     } else {\n         /* Everything else.  This will pass a NULL data argument. */\n-        dissector_try_uint(wtap_encap_dissector_table,\n-            wtap_pcap_encap_to_wtap_encap(dlt), next_tvb, pinfo, tree);\n+        wtap_encap = wtap_pcap_encap_to_wtap_encap(dlt);\n+        switch (wtap_encap) {\n+\n+        case WTAP_ENCAP_ETHERNET:\n+            eth.fcs_len = -1;    /* Unknown whether we have an FCS */\n+            phdrp = &eth;\n+            break;\n+\n+        default:\n+            phdrp = NULL;\n+            break;\n+        }\n+        dissector_try_uint_new(wtap_encap_dissector_table,\n+            wtap_encap, next_tvb, pinfo, tree, TRUE, phdrp);\n     }\n }\n ", "file_path": "files/2016_8\\61", "file_language": "c", "file_name": "epan/dissectors/packet-ppi.c", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}, {"raw_url": "https://github.com/wireshark/wireshark/raw/2c13e97d656c1c0ac4d76eb9d307664aae0e0cf7/epan/dissectors/packet-rpcap.c", "code": "/* packet-rpcap.c\n *\n * Routines for RPCAP message formats.\n *\n * Copyright 2008, Stig Bjorlykke <stig@bjorlykke.org>, Thales Norway AS\n *\n * Wireshark - Network traffic analyzer\n * By Gerald Combs <gerald@wireshark.org>\n * Copyright 1998 Gerald Combs\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version 2\n * of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */\n\n#include \"config.h\"\n\n#include <epan/packet.h>\n#include <epan/aftypes.h>\n#include <epan/prefs.h>\n#include <epan/to_str.h>\n#include <epan/expert.h>\n#include <wiretap/wtap.h>\n\n#include \"packet-frame.h\"\n#include \"packet-tcp.h\"\n\n#define PNAME  \"Remote Packet Capture\"\n#define PSNAME \"RPCAP\"\n#define PFNAME \"rpcap\"\n\n#define RPCAP_MSG_ERROR               1\n#define RPCAP_MSG_FINDALLIF_REQ       2\n#define RPCAP_MSG_OPEN_REQ            3\n#define RPCAP_MSG_STARTCAP_REQ        4\n#define RPCAP_MSG_UPDATEFILTER_REQ    5\n#define RPCAP_MSG_CLOSE               6\n#define RPCAP_MSG_PACKET              7\n#define RPCAP_MSG_AUTH_REQ            8\n#define RPCAP_MSG_STATS_REQ           9\n#define RPCAP_MSG_ENDCAP_REQ          10\n#define RPCAP_MSG_SETSAMPLING_REQ     11\n\n#define RPCAP_MSG_FINDALLIF_REPLY     (128+RPCAP_MSG_FINDALLIF_REQ)\n#define RPCAP_MSG_OPEN_REPLY          (128+RPCAP_MSG_OPEN_REQ)\n#define RPCAP_MSG_STARTCAP_REPLY      (128+RPCAP_MSG_STARTCAP_REQ)\n#define RPCAP_MSG_UPDATEFILTER_REPLY  (128+RPCAP_MSG_UPDATEFILTER_REQ)\n#define RPCAP_MSG_AUTH_REPLY          (128+RPCAP_MSG_AUTH_REQ)\n#define RPCAP_MSG_STATS_REPLY         (128+RPCAP_MSG_STATS_REQ)\n#define RPCAP_MSG_ENDCAP_REPLY        (128+RPCAP_MSG_ENDCAP_REQ)\n#define RPCAP_MSG_SETSAMPLING_REPLY   (128+RPCAP_MSG_SETSAMPLING_REQ)\n\n#define RPCAP_ERR_NETW            1\n#define RPCAP_ERR_INITTIMEOUT     2\n#define RPCAP_ERR_AUTH            3\n#define RPCAP_ERR_FINDALLIF       4\n#define RPCAP_ERR_NOREMOTEIF      5\n#define RPCAP_ERR_OPEN            6\n#define RPCAP_ERR_UPDATEFILTER    7\n#define RPCAP_ERR_GETSTATS        8\n#define RPCAP_ERR_READEX          9\n#define RPCAP_ERR_HOSTNOAUTH      10\n#define RPCAP_ERR_REMOTEACCEPT    11\n#define RPCAP_ERR_STARTCAPTURE    12\n#define RPCAP_ERR_ENDCAPTURE      13\n#define RPCAP_ERR_RUNTIMETIMEOUT  14\n#define RPCAP_ERR_SETSAMPLING     15\n#define RPCAP_ERR_WRONGMSG        16\n#define RPCAP_ERR_WRONGVER        17\n\n#define RPCAP_SAMP_NOSAMP            0\n#define RPCAP_SAMP_1_EVERY_N         1\n#define RPCAP_SAMP_FIRST_AFTER_N_MS  2\n\n#define RPCAP_RMTAUTH_NULL  0\n#define RPCAP_RMTAUTH_PWD   1\n\n#define FLAG_PROMISC     0x0001\n#define FLAG_DGRAM       0x0002\n#define FLAG_SERVEROPEN  0x0004\n#define FLAG_INBOUND     0x0008\n#define FLAG_OUTBOUND    0x0010\n\nvoid proto_register_rpcap (void);\nvoid proto_reg_handoff_rpcap (void);\n\nstatic int proto_rpcap = -1;\n\nstatic int hf_version = -1;\nstatic int hf_type = -1;\nstatic int hf_value = -1;\nstatic int hf_plen = -1;\n\nstatic int hf_error = -1;\nstatic int hf_error_value = -1;\n\nstatic int hf_packet = -1;\nstatic int hf_timestamp = -1;\nstatic int hf_caplen = -1;\nstatic int hf_len = -1;\nstatic int hf_npkt = -1;\n\nstatic int hf_auth_request = -1;\nstatic int hf_auth_type = -1;\nstatic int hf_auth_slen1 = -1;\nstatic int hf_auth_slen2 = -1;\nstatic int hf_auth_username = -1;\nstatic int hf_auth_password = -1;\n\nstatic int hf_open_request = -1;\n\nstatic int hf_open_reply = -1;\nstatic int hf_linktype = -1;\nstatic int hf_tzoff = -1;\n\nstatic int hf_startcap_request = -1;\nstatic int hf_snaplen = -1;\nstatic int hf_read_timeout = -1;\nstatic int hf_flags = -1;\nstatic int hf_flags_promisc = -1;\nstatic int hf_flags_dgram = -1;\nstatic int hf_flags_serveropen = -1;\nstatic int hf_flags_inbound = -1;\nstatic int hf_flags_outbound = -1;\nstatic int hf_client_port = -1;\nstatic int hf_startcap_reply = -1;\nstatic int hf_bufsize = -1;\nstatic int hf_server_port = -1;\nstatic int hf_dummy = -1;\n\nstatic int hf_filter = -1;\nstatic int hf_filtertype = -1;\nstatic int hf_nitems = -1;\n\nstatic int hf_filterbpf_insn = -1;\nstatic int hf_code = -1;\nstatic int hf_code_class = -1;\nstatic int hf_code_fields = -1;\nstatic int hf_code_ld_size = -1;\nstatic int hf_code_ld_mode = -1;\nstatic int hf_code_alu_op = -1;\nstatic int hf_code_jmp_op = -1;\nstatic int hf_code_src = -1;\nstatic int hf_code_rval = -1;\nstatic int hf_code_misc_op = -1;\nstatic int hf_jt = -1;\nstatic int hf_jf = -1;\nstatic int hf_instr_value = -1;\n\nstatic int hf_stats_reply = -1;\nstatic int hf_ifrecv = -1;\nstatic int hf_ifdrop = -1;\nstatic int hf_krnldrop = -1;\nstatic int hf_srvcapt = -1;\n\nstatic int hf_findalldevs_reply = -1;\nstatic int hf_findalldevs_if = -1;\nstatic int hf_namelen = -1;\nstatic int hf_desclen = -1;\nstatic int hf_if_flags = -1;\nstatic int hf_naddr = -1;\nstatic int hf_if_name = -1;\nstatic int hf_if_desc = -1;\n\nstatic int hf_findalldevs_ifaddr = -1;\nstatic int hf_if_addr = -1;\nstatic int hf_if_netmask = -1;\nstatic int hf_if_broadaddr = -1;\nstatic int hf_if_dstaddr = -1;\nstatic int hf_if_af = -1;\nstatic int hf_if_port = -1;\nstatic int hf_if_ip = -1;\nstatic int hf_if_padding = -1;\nstatic int hf_if_unknown = -1;\n\nstatic int hf_sampling_request = -1;\nstatic int hf_sampling_method = -1;\nstatic int hf_sampling_dummy1 = -1;\nstatic int hf_sampling_dummy2 = -1;\nstatic int hf_sampling_value = -1;\n\nstatic gint ett_rpcap = -1;\nstatic gint ett_error = -1;\nstatic gint ett_packet = -1;\nstatic gint ett_auth_request = -1;\nstatic gint ett_open_reply = -1;\nstatic gint ett_startcap_request = -1;\nstatic gint ett_startcap_reply = -1;\nstatic gint ett_startcap_flags = -1;\nstatic gint ett_filter = -1;\nstatic gint ett_filterbpf_insn = -1;\nstatic gint ett_filterbpf_insn_code = -1;\nstatic gint ett_stats_reply = -1;\nstatic gint ett_findalldevs_reply = -1;\nstatic gint ett_findalldevs_if = -1;\nstatic gint ett_findalldevs_ifaddr = -1;\nstatic gint ett_ifaddr = -1;\nstatic gint ett_sampling_request = -1;\n\nstatic expert_field ei_error = EI_INIT;\nstatic expert_field ei_if_unknown = EI_INIT;\nstatic expert_field ei_no_more_data = EI_INIT;\nstatic expert_field ei_caplen_too_big = EI_INIT;\n\nstatic dissector_handle_t data_handle;\n\n/* User definable values */\nstatic gboolean rpcap_desegment = TRUE;\nstatic gboolean decode_content = TRUE;\nstatic guint32 global_linktype = WTAP_ENCAP_UNKNOWN;\n\n/* Global variables */\nstatic guint32 linktype = WTAP_ENCAP_UNKNOWN;\nstatic gboolean info_added = FALSE;\n\nstatic const true_false_string open_closed = {\n  \"Open\", \"Closed\"\n};\n\nstatic const value_string message_type[] = {\n  { RPCAP_MSG_ERROR,              \"Error\"                       },\n  { RPCAP_MSG_FINDALLIF_REQ,      \"Find all interfaces request\" },\n  { RPCAP_MSG_OPEN_REQ,           \"Open request\"                },\n  { RPCAP_MSG_STARTCAP_REQ,       \"Start capture request\"       },\n  { RPCAP_MSG_UPDATEFILTER_REQ,   \"Update filter request\"       },\n  { RPCAP_MSG_CLOSE,              \"Close\"                       },\n  { RPCAP_MSG_PACKET,             \"Packet\"                      },\n  { RPCAP_MSG_AUTH_REQ,           \"Authentication request\"      },\n  { RPCAP_MSG_STATS_REQ,          \"Statistics request\"          },\n  { RPCAP_MSG_ENDCAP_REQ,         \"End capture request\"         },\n  { RPCAP_MSG_SETSAMPLING_REQ,    \"Set sampling request\"        },\n  { RPCAP_MSG_FINDALLIF_REPLY,    \"Find all interfaces reply\"   },\n  { RPCAP_MSG_OPEN_REPLY,         \"Open reply\"                  },\n  { RPCAP_MSG_STARTCAP_REPLY,     \"Start capture reply\"         },\n  { RPCAP_MSG_UPDATEFILTER_REPLY, \"Update filter reply\"         },\n  { RPCAP_MSG_AUTH_REPLY,         \"Authentication reply\"        },\n  { RPCAP_MSG_STATS_REPLY,        \"Statistics reply\"            },\n  { RPCAP_MSG_ENDCAP_REPLY,       \"End capture reply\"           },\n  { RPCAP_MSG_SETSAMPLING_REPLY,  \"Set sampling reply\"          },\n  { 0,   NULL }\n};\n\nstatic const value_string error_codes[] = {\n  { RPCAP_ERR_NETW,            \"Network error\"                        },\n  { RPCAP_ERR_INITTIMEOUT,     \"Initial timeout has expired\"          },\n  { RPCAP_ERR_AUTH,            \"Authentication error\"                 },\n  { RPCAP_ERR_FINDALLIF,       \"Generic findalldevs error\"            },\n  { RPCAP_ERR_NOREMOTEIF,      \"No remote interfaces\"                 },\n  { RPCAP_ERR_OPEN,            \"Generic pcap_open error\"              },\n  { RPCAP_ERR_UPDATEFILTER,    \"Generic updatefilter error\"           },\n  { RPCAP_ERR_GETSTATS,        \"Generic pcap_stats error\"             },\n  { RPCAP_ERR_READEX,          \"Generic pcap_next_ex error\"           },\n  { RPCAP_ERR_HOSTNOAUTH,      \"The host is not authorized\"           },\n  { RPCAP_ERR_REMOTEACCEPT,    \"Generic pcap_remoteaccept error\"      },\n  { RPCAP_ERR_STARTCAPTURE,    \"Generic pcap_startcapture error\"      },\n  { RPCAP_ERR_ENDCAPTURE,      \"Generic pcap_endcapture error\"        },\n  { RPCAP_ERR_RUNTIMETIMEOUT,  \"Runtime timeout has expired\"          },\n  { RPCAP_ERR_SETSAMPLING,     \"Error in setting sampling parameters\" },\n  { RPCAP_ERR_WRONGMSG,        \"Unrecognized message\"                 },\n  { RPCAP_ERR_WRONGVER,        \"Incompatible version\"                 },\n  { 0,   NULL }\n};\n\nstatic const value_string sampling_method[] = {\n  { RPCAP_SAMP_NOSAMP,            \"No sampling\"      },\n  { RPCAP_SAMP_1_EVERY_N,         \"1 every N\"        },\n  { RPCAP_SAMP_FIRST_AFTER_N_MS,  \"First after N ms\" },\n  { 0,   NULL }\n};\n\nstatic const value_string auth_type[] = {\n  { RPCAP_RMTAUTH_NULL, \"None\"     },\n  { RPCAP_RMTAUTH_PWD,  \"Password\" },\n  { 0,   NULL }\n};\n\nstatic const value_string address_family[] = {\n  { COMMON_AF_UNSPEC,   \"AF_UNSPEC\" },\n  { COMMON_AF_INET,     \"AF_INET\"   },\n  { 0,   NULL }\n};\n\nstatic const value_string bpf_class[] = {\n  { 0x00, \"ld\"   },\n  { 0x01, \"ldx\"  },\n  { 0x02, \"st\"   },\n  { 0x03, \"stx\"  },\n  { 0x04, \"alu\"  },\n  { 0x05, \"jmp\"  },\n  { 0x06, \"ret\"  },\n  { 0x07, \"misc\" },\n  { 0, NULL }\n};\n\nstatic const value_string bpf_size[] = {\n  { 0x00, \"w\" },\n  { 0x01, \"h\" },\n  { 0x02, \"b\" },\n  { 0, NULL }\n};\n\nstatic const value_string bpf_mode[] = {\n  { 0x00, \"imm\" },\n  { 0x01, \"abs\" },\n  { 0x02, \"ind\" },\n  { 0x03, \"mem\" },\n  { 0x04, \"len\" },\n  { 0x05, \"msh\" },\n  { 0, NULL }\n};\n\nstatic const value_string bpf_alu_op[] = {\n  { 0x00, \"add\" },\n  { 0x01, \"sub\" },\n  { 0x02, \"mul\" },\n  { 0x03, \"div\" },\n  { 0x04, \"or\"  },\n  { 0x05, \"and\" },\n  { 0x06, \"lsh\" },\n  { 0x07, \"rsh\" },\n  { 0x08, \"neg\" },\n  { 0, NULL }\n};\n\nstatic const value_string bpf_jmp_op[] = {\n  { 0x00, \"ja\"   },\n  { 0x01, \"jeq\"  },\n  { 0x02, \"jgt\"  },\n  { 0x03, \"jge\"  },\n  { 0x04, \"jset\" },\n  { 0, NULL }\n};\n\nstatic const value_string bpf_src[] = {\n  { 0x00, \"k\" },\n  { 0x01, \"x\" },\n  { 0, NULL }\n};\n\nstatic const value_string bpf_rval[] = {\n  { 0x00, \"k\" },\n  { 0x01, \"x\" },\n  { 0x02, \"a\" },\n  { 0, NULL }\n};\n\nstatic const value_string bpf_misc_op[] = {\n  { 0x00, \"tax\" },\n  { 0x10, \"txa\" },\n  { 0, NULL }\n};\n\n\nstatic void rpcap_frame_end (void)\n{\n  info_added = FALSE;\n}\n\n\nstatic void\ndissect_rpcap_error (tvbuff_t *tvb, packet_info *pinfo,\n                     proto_tree *parent_tree, gint offset)\n{\n  proto_item *ti;\n  gint len;\n\n  len = tvb_captured_length_remaining (tvb, offset);\n  if (len <= 0)\n    return;\n\n  col_append_fstr (pinfo->cinfo, COL_INFO, \": %s\",\n                   tvb_format_text_wsp (tvb, offset, len));\n\n  ti = proto_tree_add_item (parent_tree, hf_error, tvb, offset, len, ENC_ASCII|ENC_NA);\n  expert_add_info_format(pinfo, ti, &ei_error,\n                         \"Error: %s\", tvb_format_text_wsp (tvb, offset, len));\n}\n\n\nstatic gint\ndissect_rpcap_ifaddr (tvbuff_t *tvb, packet_info *pinfo,\n                      proto_tree *parent_tree, gint offset, int hf_id,\n                      proto_item *parent_item)\n{\n  proto_tree *tree;\n  proto_item *ti;\n  gchar ipaddr[MAX_ADDR_STR_LEN];\n  guint32 ipv4;\n  guint16 af;\n\n  ti = proto_tree_add_item (parent_tree, hf_id, tvb, offset, 128, ENC_BIG_ENDIAN);\n  tree = proto_item_add_subtree (ti, ett_ifaddr);\n\n  af = tvb_get_ntohs (tvb, offset);\n  proto_tree_add_item (tree, hf_if_af, tvb, offset, 2, ENC_BIG_ENDIAN);\n  offset += 2;\n\n  if (af == COMMON_AF_INET) {\n    proto_tree_add_item (tree, hf_if_port, tvb, offset, 2, ENC_BIG_ENDIAN);\n    offset += 2;\n\n    ipv4 = tvb_get_ipv4 (tvb, offset);\n    ip_to_str_buf((guint8 *)&ipv4, ipaddr, MAX_ADDR_STR_LEN);\n    proto_item_append_text (ti, \": %s\", ipaddr);\n    if (parent_item) {\n      proto_item_append_text (parent_item, \": %s\", ipaddr);\n    }\n    proto_tree_add_item (tree, hf_if_ip, tvb, offset, 4, ENC_BIG_ENDIAN);\n    offset += 4;\n\n    proto_tree_add_item (tree, hf_if_padding, tvb, offset, 120, ENC_NA);\n    offset += 120;\n  } else {\n    ti = proto_tree_add_item (tree, hf_if_unknown, tvb, offset, 126, ENC_NA);\n    if (af != COMMON_AF_UNSPEC) {\n      expert_add_info_format(pinfo, ti, &ei_if_unknown,\n                             \"Unknown address family: %d\", af);\n    }\n    offset += 126;\n  }\n\n  return offset;\n}\n\n\nstatic gint\ndissect_rpcap_findalldevs_ifaddr (tvbuff_t *tvb, packet_info *pinfo _U_,\n                                  proto_tree *parent_tree, gint offset)\n{\n  proto_tree *tree;\n  proto_item *ti;\n  gint boffset = offset;\n\n  ti = proto_tree_add_item (parent_tree, hf_findalldevs_ifaddr, tvb, offset, -1, ENC_NA);\n  tree = proto_item_add_subtree (ti, ett_findalldevs_ifaddr);\n\n  offset = dissect_rpcap_ifaddr (tvb, pinfo, tree, offset, hf_if_addr, ti);\n  offset = dissect_rpcap_ifaddr (tvb, pinfo, tree, offset, hf_if_netmask, NULL);\n  offset = dissect_rpcap_ifaddr (tvb, pinfo, tree, offset, hf_if_broadaddr, NULL);\n  offset = dissect_rpcap_ifaddr (tvb, pinfo, tree, offset, hf_if_dstaddr, NULL);\n\n  proto_item_set_len (ti, offset - boffset);\n\n  return offset;\n}\n\n\nstatic gint\ndissect_rpcap_findalldevs_if (tvbuff_t *tvb, packet_info *pinfo _U_,\n                              proto_tree *parent_tree, gint offset)\n{\n  proto_tree *tree;\n  proto_item *ti;\n  guint16 namelen, desclen, naddr, i;\n  gint boffset = offset;\n\n  ti = proto_tree_add_item (parent_tree, hf_findalldevs_if, tvb, offset, -1, ENC_NA);\n  tree = proto_item_add_subtree (ti, ett_findalldevs_if);\n\n  namelen = tvb_get_ntohs (tvb, offset);\n  proto_tree_add_item (tree, hf_namelen, tvb, offset, 2, ENC_BIG_ENDIAN);\n  offset += 2;\n\n  desclen = tvb_get_ntohs (tvb, offset);\n  proto_tree_add_item (tree, hf_desclen, tvb, offset, 2, ENC_BIG_ENDIAN);\n  offset += 2;\n\n  proto_tree_add_item (tree, hf_if_flags, tvb, offset, 4, ENC_BIG_ENDIAN);\n  offset += 4;\n\n  naddr = tvb_get_ntohs (tvb, offset);\n  proto_tree_add_item (tree, hf_naddr, tvb, offset, 2, ENC_BIG_ENDIAN);\n  offset += 2;\n\n  proto_tree_add_item (tree, hf_dummy, tvb, offset, 2, ENC_BIG_ENDIAN);\n  offset += 2;\n\n  if (namelen) {\n    proto_item_append_text (ti, \": %s\", tvb_get_string_enc(wmem_packet_scope(), tvb, offset, namelen, ENC_ASCII));\n    proto_tree_add_item (tree, hf_if_name, tvb, offset, namelen, ENC_ASCII|ENC_NA);\n    offset += namelen;\n  }\n\n  if (desclen) {\n    proto_tree_add_item (tree, hf_if_desc, tvb, offset, desclen, ENC_ASCII|ENC_NA);\n    offset += desclen;\n  }\n\n  for (i = 0; i < naddr; i++) {\n    offset = dissect_rpcap_findalldevs_ifaddr (tvb, pinfo, tree, offset);\n    if (tvb_reported_length_remaining (tvb, offset) < 0) {\n      /* No more data in packet */\n      expert_add_info(pinfo, ti, &ei_no_more_data);\n      break;\n    }\n  }\n\n  proto_item_set_len (ti, offset - boffset);\n\n  return offset;\n}\n\n\nstatic void\ndissect_rpcap_findalldevs_reply (tvbuff_t *tvb, packet_info *pinfo _U_,\n                                 proto_tree *parent_tree, gint offset, guint16 no_devs)\n{\n  proto_tree *tree;\n  proto_item *ti;\n  guint16 i;\n\n  ti = proto_tree_add_item (parent_tree, hf_findalldevs_reply, tvb, offset, -1, ENC_NA);\n  tree = proto_item_add_subtree (ti, ett_findalldevs_reply);\n\n  for (i = 0; i < no_devs; i++) {\n    offset = dissect_rpcap_findalldevs_if (tvb, pinfo, tree, offset);\n    if (tvb_reported_length_remaining (tvb, offset) < 0) {\n      /* No more data in packet */\n      expert_add_info(pinfo, ti, &ei_no_more_data);\n      break;\n    }\n  }\n\n  proto_item_append_text (ti, \", %d item%s\", no_devs, plurality (no_devs, \"\", \"s\"));\n}\n\n\nstatic gint\ndissect_rpcap_filterbpf_insn (tvbuff_t *tvb, packet_info *pinfo _U_,\n                              proto_tree *parent_tree, gint offset)\n{\n  proto_tree *tree, *code_tree;\n  proto_item *ti, *code_ti;\n  guint8 inst_class;\n\n  ti = proto_tree_add_item (parent_tree, hf_filterbpf_insn, tvb, offset, 8, ENC_NA);\n  tree = proto_item_add_subtree (ti, ett_filterbpf_insn);\n\n  code_ti = proto_tree_add_item (tree, hf_code, tvb, offset, 2, ENC_BIG_ENDIAN);\n  code_tree = proto_item_add_subtree (code_ti, ett_filterbpf_insn_code);\n  proto_tree_add_item (code_tree, hf_code_class, tvb, offset, 2, ENC_BIG_ENDIAN);\n  inst_class = tvb_get_guint8 (tvb, offset + 1) & 0x07;\n  proto_item_append_text (ti, \": %s\", val_to_str_const (inst_class, bpf_class, \"\"));\n  switch (inst_class) {\n  case 0x00: /* ld */\n  case 0x01: /* ldx */\n    proto_tree_add_item (code_tree, hf_code_ld_size, tvb, offset, 2, ENC_BIG_ENDIAN);\n    proto_tree_add_item (code_tree, hf_code_ld_mode, tvb, offset, 2, ENC_BIG_ENDIAN);\n    break;\n  case 0x04: /* alu */\n    proto_tree_add_item (code_tree, hf_code_src, tvb, offset, 2, ENC_BIG_ENDIAN);\n    proto_tree_add_item (code_tree, hf_code_alu_op, tvb, offset, 2, ENC_BIG_ENDIAN);\n    break;\n  case 0x05: /* jmp */\n    proto_tree_add_item (code_tree, hf_code_src, tvb, offset, 2, ENC_BIG_ENDIAN);\n    proto_tree_add_item (code_tree, hf_code_jmp_op, tvb, offset, 2, ENC_BIG_ENDIAN);\n    break;\n  case 0x06: /* ret */\n    proto_tree_add_item (code_tree, hf_code_rval, tvb, offset, 2, ENC_BIG_ENDIAN);\n    break;\n  case 0x07: /* misc */\n    proto_tree_add_item (code_tree, hf_code_misc_op, tvb, offset, 2, ENC_BIG_ENDIAN);\n    break;\n  default:\n    proto_tree_add_item (code_tree, hf_code_fields, tvb, offset, 2, ENC_BIG_ENDIAN);\n    break;\n  }\n  offset += 2;\n\n  proto_tree_add_item (tree, hf_jt, tvb, offset, 1, ENC_BIG_ENDIAN);\n  offset += 1;\n\n  proto_tree_add_item (tree, hf_jf, tvb, offset, 1, ENC_BIG_ENDIAN);\n  offset += 1;\n\n  proto_tree_add_item (tree, hf_instr_value, tvb, offset, 4, ENC_BIG_ENDIAN);\n  offset += 4;\n\n  return offset;\n}\n\n\nstatic void\ndissect_rpcap_filter (tvbuff_t *tvb, packet_info *pinfo,\n                      proto_tree *parent_tree, gint offset)\n{\n  proto_tree *tree;\n  proto_item *ti;\n  guint32 nitems, i;\n\n  ti = proto_tree_add_item (parent_tree, hf_filter, tvb, offset, -1, ENC_NA);\n  tree = proto_item_add_subtree (ti, ett_filter);\n\n  proto_tree_add_item (tree, hf_filtertype, tvb, offset, 2, ENC_BIG_ENDIAN);\n  offset += 2;\n\n  proto_tree_add_item (tree, hf_dummy, tvb, offset, 2, ENC_BIG_ENDIAN);\n  offset += 2;\n\n  nitems = tvb_get_ntohl (tvb, offset);\n  proto_tree_add_item (tree, hf_nitems, tvb, offset, 4, ENC_BIG_ENDIAN);\n  offset += 4;\n\n  for (i = 0; i < nitems; i++) {\n    offset = dissect_rpcap_filterbpf_insn (tvb, pinfo, tree, offset);\n    if (tvb_reported_length_remaining (tvb, offset) < 0) {\n      /* No more data in packet */\n      expert_add_info(pinfo, ti, &ei_no_more_data);\n      break;\n    }\n  }\n}\n\n\nstatic int\ndissect_rpcap_auth_request (tvbuff_t *tvb, packet_info *pinfo _U_,\n                            proto_tree *parent_tree, gint offset)\n{\n  proto_tree *tree;\n  proto_item *ti;\n  guint16 type, slen1, slen2;\n\n  ti = proto_tree_add_item (parent_tree, hf_auth_request, tvb, offset, -1, ENC_NA);\n  tree = proto_item_add_subtree (ti, ett_auth_request);\n\n  type = tvb_get_ntohs (tvb, offset);\n  proto_tree_add_item (tree, hf_auth_type, tvb, offset, 2, ENC_BIG_ENDIAN);\n  offset += 2;\n\n  proto_tree_add_item (tree, hf_dummy, tvb, offset, 2, ENC_BIG_ENDIAN);\n  offset += 2;\n\n  slen1 = tvb_get_ntohs (tvb, offset);\n  proto_tree_add_item (tree, hf_auth_slen1, tvb, offset, 2, ENC_BIG_ENDIAN);\n  offset += 2;\n\n  slen2 = tvb_get_ntohs (tvb, offset);\n  proto_tree_add_item (tree, hf_auth_slen2, tvb, offset, 2, ENC_BIG_ENDIAN);\n  offset += 2;\n\n  if (type == RPCAP_RMTAUTH_NULL) {\n    proto_item_append_text (ti, \" (none)\");\n  } else if (type == RPCAP_RMTAUTH_PWD) {\n    guint8 *username, *password;\n\n    username = tvb_get_string_enc(wmem_packet_scope(), tvb, offset, slen1, ENC_ASCII);\n    proto_tree_add_item (tree, hf_auth_username, tvb, offset, slen1, ENC_ASCII|ENC_NA);\n    offset += slen1;\n\n    password = tvb_get_string_enc(wmem_packet_scope(), tvb, offset, slen2, ENC_ASCII);\n    proto_tree_add_item (tree, hf_auth_password, tvb, offset, slen2, ENC_ASCII|ENC_NA);\n    offset += slen2;\n\n    proto_item_append_text (ti, \" (%s/%s)\", username, password);\n  }\n  return offset;\n}\n\n\nstatic void\ndissect_rpcap_open_request (tvbuff_t *tvb, packet_info *pinfo _U_,\n                            proto_tree *parent_tree, gint offset)\n{\n  gint len;\n\n  len = tvb_captured_length_remaining (tvb, offset);\n  proto_tree_add_item (parent_tree, hf_open_request, tvb, offset, len, ENC_ASCII|ENC_NA);\n}\n\n\nstatic void\ndissect_rpcap_open_reply (tvbuff_t *tvb, packet_info *pinfo _U_,\n                          proto_tree *parent_tree, gint offset)\n{\n  proto_tree *tree;\n  proto_item *ti;\n\n  ti = proto_tree_add_item (parent_tree, hf_open_reply, tvb, offset, -1, ENC_NA);\n  tree = proto_item_add_subtree (ti, ett_open_reply);\n\n  linktype = tvb_get_ntohl (tvb, offset);\n  proto_tree_add_item (tree, hf_linktype, tvb, offset, 4, ENC_BIG_ENDIAN);\n  offset += 4;\n\n  proto_tree_add_item (tree, hf_tzoff, tvb, offset, 4, ENC_BIG_ENDIAN);\n}\n\n\nstatic void\ndissect_rpcap_startcap_request (tvbuff_t *tvb, packet_info *pinfo,\n                                proto_tree *parent_tree, gint offset)\n{\n  proto_tree *tree, *field_tree;\n  proto_item *ti, *field_ti;\n  guint16 flags;\n\n  ti = proto_tree_add_item (parent_tree, hf_startcap_request, tvb, offset, -1, ENC_NA);\n  tree = proto_item_add_subtree (ti, ett_startcap_request);\n\n  proto_tree_add_item (tree, hf_snaplen, tvb, offset, 4, ENC_BIG_ENDIAN);\n  offset += 4;\n\n  proto_tree_add_item (tree, hf_read_timeout, tvb, offset, 4, ENC_BIG_ENDIAN);\n  offset += 4;\n\n  flags = tvb_get_ntohs (tvb, offset);\n  field_ti = proto_tree_add_uint_format (tree, hf_flags, tvb, offset, 2, flags, \"Flags\");\n  field_tree = proto_item_add_subtree (field_ti, ett_startcap_flags);\n  proto_tree_add_item (field_tree, hf_flags_promisc, tvb, offset, 2, ENC_BIG_ENDIAN);\n  proto_tree_add_item (field_tree, hf_flags_dgram, tvb, offset, 2, ENC_BIG_ENDIAN);\n  proto_tree_add_item (field_tree, hf_flags_serveropen, tvb, offset, 2, ENC_BIG_ENDIAN);\n  proto_tree_add_item (field_tree, hf_flags_inbound, tvb, offset, 2, ENC_BIG_ENDIAN);\n  proto_tree_add_item (field_tree, hf_flags_outbound, tvb, offset, 2, ENC_BIG_ENDIAN);\n\n  if (flags & 0x1F) {\n    gchar *flagstr = wmem_strdup_printf (wmem_packet_scope(), \"%s%s%s%s%s\",\n          (flags & FLAG_PROMISC)    ? \", Promiscuous\" : \"\",\n          (flags & FLAG_DGRAM)      ? \", Datagram\"    : \"\",\n          (flags & FLAG_SERVEROPEN) ? \", ServerOpen\"  : \"\",\n          (flags & FLAG_INBOUND)    ? \", Inbound\"     : \"\",\n          (flags & FLAG_OUTBOUND)   ? \", Outbound\"    : \"\");\n    proto_item_append_text (field_ti, \":%s\", &flagstr[1]);\n  } else {\n    proto_item_append_text (field_ti, \" (none)\");\n  }\n  offset += 2;\n\n  proto_tree_add_item (tree, hf_client_port, tvb, offset, 2, ENC_BIG_ENDIAN);\n  offset += 2;\n\n  dissect_rpcap_filter (tvb, pinfo, tree, offset);\n}\n\n\nstatic void\ndissect_rpcap_startcap_reply (tvbuff_t *tvb, packet_info *pinfo _U_,\n                              proto_tree *parent_tree, gint offset)\n{\n  proto_tree *tree;\n  proto_item *ti;\n\n  ti = proto_tree_add_item (parent_tree, hf_startcap_reply, tvb, offset, -1, ENC_NA);\n  tree = proto_item_add_subtree (ti, ett_startcap_reply);\n\n  proto_tree_add_item (tree, hf_bufsize, tvb, offset, 4, ENC_BIG_ENDIAN);\n  offset += 4;\n\n  proto_tree_add_item (tree, hf_server_port, tvb, offset, 2, ENC_BIG_ENDIAN);\n  offset += 2;\n\n  proto_tree_add_item (tree, hf_dummy, tvb, offset, 2, ENC_BIG_ENDIAN);\n}\n\n\nstatic void\ndissect_rpcap_stats_reply (tvbuff_t *tvb, packet_info *pinfo _U_,\n                           proto_tree *parent_tree, gint offset)\n{\n  proto_tree *tree;\n  proto_item *ti;\n\n  ti = proto_tree_add_item (parent_tree, hf_stats_reply, tvb, offset, 16, ENC_NA);\n  tree = proto_item_add_subtree (ti, ett_stats_reply);\n\n  proto_tree_add_item (tree, hf_ifrecv, tvb, offset, 4, ENC_BIG_ENDIAN);\n  offset += 4;\n\n  proto_tree_add_item (tree, hf_ifdrop, tvb, offset, 4, ENC_BIG_ENDIAN);\n  offset += 4;\n\n  proto_tree_add_item (tree, hf_krnldrop, tvb, offset, 4, ENC_BIG_ENDIAN);\n  offset += 4;\n\n  proto_tree_add_item (tree, hf_srvcapt, tvb, offset, 4, ENC_BIG_ENDIAN);\n}\n\n\nstatic int\ndissect_rpcap_sampling_request (tvbuff_t *tvb, packet_info *pinfo _U_,\n                                proto_tree *parent_tree, gint offset)\n{\n  proto_tree *tree;\n  proto_item *ti;\n  guint32 value;\n  guint8 method;\n\n  ti = proto_tree_add_item (parent_tree, hf_sampling_request, tvb, offset, -1, ENC_NA);\n  tree = proto_item_add_subtree (ti, ett_sampling_request);\n\n  method = tvb_get_guint8 (tvb, offset);\n  proto_tree_add_item (tree, hf_sampling_method, tvb, offset, 1, ENC_BIG_ENDIAN);\n  offset += 1;\n\n  proto_tree_add_item (tree, hf_sampling_dummy1, tvb, offset, 1, ENC_BIG_ENDIAN);\n  offset += 1;\n\n  proto_tree_add_item (tree, hf_sampling_dummy2, tvb, offset, 2, ENC_BIG_ENDIAN);\n  offset += 2;\n\n  value = tvb_get_ntohl (tvb, offset);\n  proto_tree_add_item (tree, hf_sampling_value, tvb, offset, 4, ENC_BIG_ENDIAN);\n  offset += 4;\n\n  switch (method) {\n  case RPCAP_SAMP_NOSAMP:\n    proto_item_append_text (ti, \": None\");\n    break;\n  case RPCAP_SAMP_1_EVERY_N:\n    proto_item_append_text (ti, \": 1 every %d\", value);\n    break;\n  case RPCAP_SAMP_FIRST_AFTER_N_MS:\n    proto_item_append_text (ti, \": First after %d ms\", value);\n    break;\n  default:\n    break;\n  }\n  return offset;\n}\n\n\nstatic void\ndissect_rpcap_packet (tvbuff_t *tvb, packet_info *pinfo, proto_tree *top_tree,\n                      proto_tree *parent_tree, gint offset, proto_item *top_item)\n{\n  proto_tree *tree;\n  proto_item *ti;\n  nstime_t ts;\n  tvbuff_t *new_tvb;\n  guint caplen, len, frame_no;\n  gint reported_length_remaining;\n  struct eth_phdr eth;\n  void *phdr;\n\n  ti = proto_tree_add_item (parent_tree, hf_packet, tvb, offset, 20, ENC_NA);\n  tree = proto_item_add_subtree (ti, ett_packet);\n\n  ts.secs = tvb_get_ntohl (tvb, offset);\n  ts.nsecs = tvb_get_ntohl (tvb, offset + 4) * 1000;\n  proto_tree_add_time(tree, hf_timestamp, tvb, offset, 8, &ts);\n  offset += 8;\n\n  caplen = tvb_get_ntohl (tvb, offset);\n  ti = proto_tree_add_item (tree, hf_caplen, tvb, offset, 4, ENC_BIG_ENDIAN);\n  offset += 4;\n\n  len = tvb_get_ntohl (tvb, offset);\n  proto_tree_add_item (tree, hf_len, tvb, offset, 4, ENC_BIG_ENDIAN);\n  offset += 4;\n\n  frame_no = tvb_get_ntohl (tvb, offset);\n  proto_tree_add_item (tree, hf_npkt, tvb, offset, 4, ENC_BIG_ENDIAN);\n  offset += 4;\n\n  proto_item_append_text (ti, \", Frame %u\", frame_no);\n  proto_item_append_text (top_item, \" Frame %u\", frame_no);\n\n  /*\n   * reported_length_remaining should not be -1, as offset is at\n   * most right past the end of the available data in the packet.\n   */\n  reported_length_remaining = tvb_reported_length_remaining (tvb, offset);\n  if (caplen > (guint)reported_length_remaining) {\n    expert_add_info(pinfo, ti, &ei_caplen_too_big);\n    return;\n  }\n\n  new_tvb = tvb_new_subset (tvb, offset, caplen, len);\n  if (decode_content && linktype != WTAP_ENCAP_UNKNOWN) {\n    switch (linktype) {\n\n    case WTAP_ENCAP_ETHERNET:\n      eth.fcs_len = -1;    /* Unknown whether we have an FCS */\n      phdr = &eth;\n      break;\n\n    default:\n      phdr = NULL;\n      break;\n    }\n    dissector_try_uint_new(wtap_encap_dissector_table, linktype, new_tvb, pinfo, top_tree, TRUE, phdr);\n\n    if (!info_added) {\n      /* Only indicate when not added before */\n      /* Indicate RPCAP in the protocol column */\n      col_prepend_fence_fstr(pinfo->cinfo, COL_PROTOCOL, \"R|\");\n\n      /* Indicate RPCAP in the info column */\n      col_prepend_fence_fstr (pinfo->cinfo, COL_INFO, \"Remote | \");\n      info_added = TRUE;\n      register_frame_end_routine(pinfo, rpcap_frame_end);\n    }\n  } else {\n    if (linktype == WTAP_ENCAP_UNKNOWN) {\n      proto_item_append_text (ti, \", Unknown link-layer type\");\n    }\n    call_dissector (data_handle, new_tvb, pinfo, top_tree);\n  }\n}\n\n\nstatic int\ndissect_rpcap (tvbuff_t *tvb, packet_info *pinfo, proto_tree *top_tree, void* data _U_)\n{\n  proto_tree *tree;\n  proto_item *ti;\n  tvbuff_t *new_tvb;\n  gint len, offset = 0;\n  guint8 msg_type;\n  guint16 msg_value;\n\n  col_set_str (pinfo->cinfo, COL_PROTOCOL, PSNAME);\n\n  col_clear(pinfo->cinfo, COL_INFO);\n\n  ti = proto_tree_add_item (top_tree, proto_rpcap, tvb, offset, -1, ENC_NA);\n  tree = proto_item_add_subtree (ti, ett_rpcap);\n\n  proto_tree_add_item (tree, hf_version, tvb, offset, 1, ENC_BIG_ENDIAN);\n  offset++;\n\n  msg_type = tvb_get_guint8 (tvb, offset);\n  proto_tree_add_item (tree, hf_type, tvb, offset, 1, ENC_BIG_ENDIAN);\n  offset++;\n\n  col_append_fstr (pinfo->cinfo, COL_INFO, \"%s\",\n                     val_to_str (msg_type, message_type, \"Unknown: %d\"));\n\n  proto_item_append_text (ti, \", %s\", val_to_str (msg_type, message_type, \"Unknown: %d\"));\n\n  msg_value = tvb_get_ntohs (tvb, offset);\n  if (msg_type == RPCAP_MSG_ERROR) {\n    proto_tree_add_item (tree, hf_error_value, tvb, offset, 2, ENC_BIG_ENDIAN);\n  } else {\n    proto_tree_add_item (tree, hf_value, tvb, offset, 2, ENC_BIG_ENDIAN);\n  }\n  offset += 2;\n\n  proto_tree_add_item (tree, hf_plen, tvb, offset, 4, ENC_BIG_ENDIAN);\n  offset += 4;\n\n\n  switch (msg_type) {\n  case RPCAP_MSG_ERROR:\n    dissect_rpcap_error (tvb, pinfo, tree, offset);\n    break;\n  case RPCAP_MSG_OPEN_REQ:\n    dissect_rpcap_open_request (tvb, pinfo, tree, offset);\n    break;\n  case RPCAP_MSG_STARTCAP_REQ:\n    dissect_rpcap_startcap_request (tvb, pinfo, tree, offset);\n    break;\n  case RPCAP_MSG_UPDATEFILTER_REQ:\n    dissect_rpcap_filter (tvb, pinfo, tree, offset);\n    break;\n  case RPCAP_MSG_PACKET:\n    proto_item_set_len (ti, 28);\n    dissect_rpcap_packet (tvb, pinfo, top_tree, tree, offset, ti);\n    break;\n  case RPCAP_MSG_AUTH_REQ:\n    dissect_rpcap_auth_request (tvb, pinfo, tree, offset);\n    break;\n  case RPCAP_MSG_SETSAMPLING_REQ:\n    dissect_rpcap_sampling_request (tvb, pinfo, tree, offset);\n    break;\n  case RPCAP_MSG_FINDALLIF_REPLY:\n    dissect_rpcap_findalldevs_reply (tvb, pinfo, tree, offset, msg_value);\n    break;\n  case RPCAP_MSG_OPEN_REPLY:\n    dissect_rpcap_open_reply (tvb, pinfo, tree, offset);\n    break;\n  case RPCAP_MSG_STARTCAP_REPLY:\n    dissect_rpcap_startcap_reply (tvb, pinfo, tree, offset);\n    break;\n  case RPCAP_MSG_STATS_REPLY:\n    dissect_rpcap_stats_reply (tvb, pinfo, tree, offset);\n    break;\n  default:\n    len = tvb_reported_length_remaining (tvb, offset);\n    if (len) {\n      /* Yet unknown, dump as data */\n      proto_item_set_len (ti, 8);\n      new_tvb = tvb_new_subset_remaining (tvb, offset);\n      call_dissector (data_handle, new_tvb, pinfo, top_tree);\n    }\n    break;\n  }\n\n  return tvb_captured_length(tvb);\n}\n\n\nstatic gboolean\ncheck_rpcap_heur (tvbuff_t *tvb, gboolean tcp)\n{\n  gint offset = 0;\n  guint8 version, msg_type;\n  guint16 msg_value;\n  guint32 plen, len, caplen;\n\n  if (tvb_captured_length (tvb) < 8)\n    /* Too short */\n    return FALSE;\n\n  version = tvb_get_guint8 (tvb, offset);\n  if (version != 0)\n    /* Incorrect version */\n    return FALSE;\n  offset++;\n\n  msg_type = tvb_get_guint8 (tvb, offset);\n  if (!tcp && msg_type != 7) {\n    /* UDP is only used for packets */\n    return FALSE;\n  }\n  if (try_val_to_str(msg_type, message_type) == NULL)\n    /* Unknown message type */\n    return FALSE;\n  offset++;\n\n  msg_value = tvb_get_ntohs (tvb, offset);\n  if (msg_value > 0) {\n    if (msg_type == RPCAP_MSG_ERROR) {\n      /* Must have a valid error code */\n      if (try_val_to_str(msg_value, error_codes) == NULL)\n        return FALSE;\n    } else if (msg_type != RPCAP_MSG_FINDALLIF_REPLY) {\n      return FALSE;\n    }\n  }\n  offset += 2;\n\n  plen = tvb_get_ntohl (tvb, offset);\n  offset += 4;\n  len = (guint32) tvb_reported_length_remaining (tvb, offset);\n\n  switch (msg_type) {\n\n  case RPCAP_MSG_FINDALLIF_REQ:\n  case RPCAP_MSG_UPDATEFILTER_REPLY:\n  case RPCAP_MSG_AUTH_REPLY:\n  case RPCAP_MSG_STATS_REQ:\n  case RPCAP_MSG_CLOSE:\n  case RPCAP_MSG_SETSAMPLING_REPLY:\n  case RPCAP_MSG_ENDCAP_REQ:\n  case RPCAP_MSG_ENDCAP_REPLY:\n    /* Empty payload */\n    if (plen != 0 || len != 0)\n      return FALSE;\n    break;\n\n  case RPCAP_MSG_OPEN_REPLY:\n  case RPCAP_MSG_STARTCAP_REPLY:\n  case RPCAP_MSG_SETSAMPLING_REQ:\n    /* Always 8 bytes */\n    if (plen != 8 || len != 8)\n      return FALSE;\n    break;\n\n  case RPCAP_MSG_STATS_REPLY:\n    /* Always 16 bytes */\n    if (plen != 16 || len != 16)\n      return FALSE;\n    break;\n\n  case RPCAP_MSG_PACKET:\n    /* Must have the frame header */\n    if (plen < 20)\n      return FALSE;\n\n    /* Check if capture length is valid */\n    caplen = tvb_get_ntohl (tvb, offset+8);\n    /* Always 20 bytes less than packet length */\n    if (caplen != (plen - 20) || caplen > 65535)\n      return FALSE;\n    break;\n\n  case RPCAP_MSG_FINDALLIF_REPLY:\n  case RPCAP_MSG_ERROR:\n  case RPCAP_MSG_OPEN_REQ:\n  case RPCAP_MSG_STARTCAP_REQ:\n  case RPCAP_MSG_UPDATEFILTER_REQ:\n  case RPCAP_MSG_AUTH_REQ:\n    /* Variable length */\n    if (plen != len)\n      return FALSE;\n    break;\n  default:\n    /* Unknown message type */\n    return FALSE;\n  }\n\n  return TRUE;\n}\n\n\nstatic guint\nget_rpcap_pdu_len (packet_info *pinfo _U_, tvbuff_t *tvb, int offset, void *data _U_)\n{\n  return tvb_get_ntohl (tvb, offset + 4) + 8;\n}\n\n\nstatic gboolean\ndissect_rpcap_heur_tcp (tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)\n{\n  if (check_rpcap_heur (tvb, TRUE)) {\n    /* This is probably a rpcap tcp package */\n    tcp_dissect_pdus (tvb, pinfo, tree, rpcap_desegment, 8,\n                      get_rpcap_pdu_len, dissect_rpcap, data);\n\n    return TRUE;\n  }\n\n  return FALSE;\n}\n\n\nstatic gboolean\ndissect_rpcap_heur_udp (tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)\n{\n  if (check_rpcap_heur (tvb, FALSE)) {\n    /* This is probably a rpcap udp package */\n    dissect_rpcap (tvb, pinfo, tree, data);\n\n    return TRUE;\n  }\n\n  return FALSE;\n}\n\n\nvoid\nproto_register_rpcap (void)\n{\n  static hf_register_info hf[] = {\n    /* Common header for all messages */\n    { &hf_version,\n      { \"Version\", \"rpcap.version\", FT_UINT8, BASE_DEC,\n        NULL, 0x0, NULL, HFILL } },\n    { &hf_type,\n      { \"Message type\", \"rpcap.type\", FT_UINT8, BASE_DEC,\n        VALS(message_type), 0x0, NULL, HFILL } },\n    { &hf_value,\n      { \"Message value\", \"rpcap.value\", FT_UINT16, BASE_DEC,\n        NULL, 0x0, NULL, HFILL } },\n    { &hf_plen,\n      { \"Payload length\", \"rpcap.len\", FT_UINT32, BASE_DEC,\n        NULL, 0x0, NULL, HFILL } },\n\n    /* Error */\n    { &hf_error,\n      { \"Error\", \"rpcap.error\", FT_STRING, BASE_NONE,\n        NULL, 0x0, \"Error text\", HFILL } },\n    { &hf_error_value,\n      { \"Error value\", \"rpcap.error_value\", FT_UINT16, BASE_DEC,\n        VALS(error_codes), 0x0, NULL, HFILL } },\n\n    /* Packet header */\n    { &hf_packet,\n      { \"Packet\", \"rpcap.packet\", FT_NONE, BASE_NONE,\n        NULL, 0x0, \"Packet data\", HFILL } },\n    { &hf_timestamp,\n      { \"Arrival time\", \"rpcap.time\", FT_ABSOLUTE_TIME, ABSOLUTE_TIME_LOCAL,\n        NULL, 0x0, NULL, HFILL } },\n    { &hf_caplen,\n      { \"Capture length\", \"rpcap.cap_len\", FT_UINT32, BASE_DEC,\n        NULL, 0x0, NULL, HFILL } },\n    { &hf_len,\n      { \"Frame length\", \"rpcap.len\", FT_UINT32, BASE_DEC,\n        NULL, 0x0, \"Frame length (off wire)\", HFILL } },\n    { &hf_npkt,\n      { \"Frame number\", \"rpcap.number\", FT_UINT32, BASE_DEC,\n        NULL, 0x0, NULL, HFILL } },\n\n    /* Authentication request */\n    { &hf_auth_request,\n      { \"Authentication\", \"rpcap.auth\", FT_NONE, BASE_NONE,\n        NULL, 0x0, NULL, HFILL } },\n    { &hf_auth_type,\n      { \"Authentication type\", \"rpcap.auth_type\", FT_UINT16, BASE_DEC,\n        VALS(auth_type), 0x0, NULL, HFILL } },\n    { &hf_auth_slen1,\n      { \"Authentication item length 1\", \"rpcap.auth_len1\", FT_UINT16, BASE_DEC,\n        NULL, 0x0, NULL, HFILL } },\n    { &hf_auth_slen2,\n      { \"Authentication item length 2\", \"rpcap.auth_len2\", FT_UINT16, BASE_DEC,\n        NULL, 0x0, NULL, HFILL } },\n    { &hf_auth_username,\n      { \"Username\", \"rpcap.username\", FT_STRING, BASE_NONE,\n        NULL, 0x0, NULL, HFILL } },\n    { &hf_auth_password,\n      { \"Password\", \"rpcap.password\", FT_STRING, BASE_NONE,\n        NULL, 0x0, NULL, HFILL } },\n\n    /* Open request */\n    { &hf_open_request,\n      { \"Open request\", \"rpcap.open_request\", FT_STRING, BASE_NONE,\n        NULL, 0x0, NULL, HFILL } },\n\n    /* Open reply */\n    { &hf_open_reply,\n      { \"Open reply\", \"rpcap.open_reply\", FT_NONE, BASE_NONE,\n        NULL, 0x0, NULL, HFILL } },\n    { &hf_linktype,\n      { \"Link type\", \"rpcap.linktype\", FT_UINT32, BASE_DEC,\n        NULL, 0x0, NULL, HFILL } },\n    { &hf_tzoff,\n      { \"Timezone offset\", \"rpcap.tzoff\", FT_UINT32, BASE_DEC,\n        NULL, 0x0, NULL, HFILL } },\n\n    /* Start capture request */\n    { &hf_startcap_request,\n      { \"Start capture request\", \"rpcap.startcap_request\", FT_NONE, BASE_NONE,\n        NULL, 0x0, NULL, HFILL } },\n    { &hf_snaplen,\n      { \"Snap length\", \"rpcap.snaplen\", FT_UINT32, BASE_DEC,\n        NULL, 0x0, NULL, HFILL } },\n    { &hf_read_timeout,\n      { \"Read timeout\", \"rpcap.read_timeout\", FT_UINT32, BASE_DEC,\n        NULL, 0x0, NULL, HFILL } },\n    { &hf_flags,\n      { \"Flags\", \"rpcap.flags\", FT_UINT16, BASE_DEC,\n        NULL, 0x0, \"Capture flags\", HFILL } },\n    { &hf_flags_promisc,\n      { \"Promiscuous mode\", \"rpcap.flags.promisc\", FT_BOOLEAN, 16,\n        TFS(&tfs_enabled_disabled), FLAG_PROMISC, NULL, HFILL } },\n    { &hf_flags_dgram,\n      { \"Use Datagram\", \"rpcap.flags.dgram\", FT_BOOLEAN, 16,\n        TFS(&tfs_yes_no), FLAG_DGRAM, NULL, HFILL } },\n    { &hf_flags_serveropen,\n      { \"Server open\", \"rpcap.flags.serveropen\", FT_BOOLEAN, 16,\n        TFS(&open_closed), FLAG_SERVEROPEN, NULL, HFILL } },\n    { &hf_flags_inbound,\n      { \"Inbound\", \"rpcap.flags.inbound\", FT_BOOLEAN, 16,\n        TFS(&tfs_yes_no), FLAG_INBOUND, NULL, HFILL } },\n    { &hf_flags_outbound,\n      { \"Outbound\", \"rpcap.flags.outbound\", FT_BOOLEAN, 16,\n        TFS(&tfs_yes_no), FLAG_OUTBOUND, NULL, HFILL } },\n    { &hf_client_port,\n      { \"Client Port\", \"rpcap.client_port\", FT_UINT16, BASE_DEC,\n        NULL, 0x0, NULL, HFILL } },\n\n    /* Start capture reply */\n    { &hf_startcap_reply,\n      { \"Start capture reply\", \"rpcap.startcap_reply\", FT_NONE, BASE_NONE,\n        NULL, 0x0, NULL, HFILL } },\n    { &hf_bufsize,\n      { \"Buffer size\", \"rpcap.bufsize\", FT_UINT32, BASE_DEC,\n        NULL, 0x0, NULL, HFILL } },\n    { &hf_server_port,\n      { \"Server port\", \"rpcap.server_port\", FT_UINT16, BASE_DEC,\n        NULL, 0x0, NULL, HFILL } },\n    { &hf_dummy,\n      { \"Dummy\", \"rpcap.dummy\", FT_UINT16, BASE_DEC,\n        NULL, 0x0, NULL, HFILL } },\n\n    /* Filter */\n    { &hf_filter,\n      { \"Filter\", \"rpcap.filter\", FT_NONE, BASE_NONE,\n        NULL, 0x0, NULL, HFILL } },\n    { &hf_filtertype,\n      { \"Filter type\", \"rpcap.filtertype\", FT_UINT16, BASE_DEC,\n        NULL, 0x0, \"Filter type (BPF)\", HFILL } },\n    { &hf_nitems,\n      { \"Number of items\", \"rpcap.nitems\", FT_UINT32, BASE_DEC,\n        NULL, 0x0, NULL, HFILL } },\n\n    /* Filter BPF instruction */\n    { &hf_filterbpf_insn,\n      { \"Filter BPF instruction\", \"rpcap.filterbpf_insn\", FT_NONE, BASE_NONE,\n        NULL, 0x0, NULL, HFILL } },\n    { &hf_code,\n      { \"Op code\", \"rpcap.opcode\", FT_UINT16, BASE_HEX,\n        NULL, 0x0, \"Operation code\", HFILL } },\n    { &hf_code_class,\n      { \"Class\", \"rpcap.opcode.class\", FT_UINT16, BASE_HEX,\n        VALS(bpf_class), 0x07, \"Instruction Class\", HFILL } },\n    { &hf_code_fields,\n      { \"Fields\", \"rpcap.opcode.fields\", FT_UINT16, BASE_HEX,\n        NULL, 0xF8, \"Class Fields\", HFILL } },\n    { &hf_code_ld_size,\n      { \"Size\", \"rpcap.opcode.size\", FT_UINT16, BASE_HEX,\n        VALS(bpf_size), 0x18, NULL, HFILL } },\n    { &hf_code_ld_mode,\n      { \"Mode\", \"rpcap.opcode.mode\", FT_UINT16, BASE_HEX,\n        VALS(bpf_mode), 0xE0, NULL, HFILL } },\n    { &hf_code_alu_op,\n      { \"Op\", \"rpcap.opcode.aluop\", FT_UINT16, BASE_HEX,\n        VALS(bpf_alu_op), 0xF0, NULL, HFILL } },\n    { &hf_code_jmp_op,\n      { \"Op\", \"rpcap.opcode.jmpop\", FT_UINT16, BASE_HEX,\n        VALS(bpf_jmp_op), 0xF0, NULL, HFILL } },\n    { &hf_code_src,\n      { \"Src\", \"rpcap.opcode.src\", FT_UINT16, BASE_HEX,\n        VALS(bpf_src), 0x08, NULL, HFILL } },\n    { &hf_code_rval,\n      { \"Rval\", \"rpcap.opcode.rval\", FT_UINT16, BASE_HEX,\n        VALS(bpf_rval), 0x18, NULL, HFILL } },\n    { &hf_code_misc_op,\n      { \"Op\", \"rpcap.opcode.miscop\", FT_UINT16, BASE_HEX,\n        VALS(bpf_misc_op), 0xF8, NULL, HFILL } },\n    { &hf_jt,\n      { \"JT\", \"rpcap.jt\", FT_UINT8, BASE_DEC,\n        NULL, 0x0, NULL, HFILL } },\n    { &hf_jf,\n      { \"JF\", \"rpcap.jf\", FT_UINT8, BASE_DEC,\n        NULL, 0x0, NULL, HFILL } },\n    { &hf_instr_value,\n      { \"Instruction value\", \"rpcap.instr_value\", FT_UINT32, BASE_DEC,\n        NULL, 0x0, \"Instruction-Dependent value\", HFILL } },\n\n    /* Statistics reply */\n    { &hf_stats_reply,\n      { \"Statistics\", \"rpcap.stats_reply\", FT_NONE, BASE_NONE,\n        NULL, 0x0, \"Statistics reply data\", HFILL } },\n    { &hf_ifrecv,\n      { \"Received by kernel filter\", \"rpcap.ifrecv\", FT_UINT32, BASE_DEC,\n        NULL, 0x0, \"Received by kernel\", HFILL } },\n    { &hf_ifdrop,\n      { \"Dropped by network interface\", \"rpcap.ifdrop\", FT_UINT32, BASE_DEC,\n        NULL, 0x0, NULL, HFILL } },\n    { &hf_krnldrop,\n      { \"Dropped by kernel filter\", \"rpcap.krnldrop\", FT_UINT32, BASE_DEC,\n        NULL, 0x0, NULL, HFILL } },\n    { &hf_srvcapt,\n      { \"Captured by rpcapd\", \"rpcap.srvcapt\", FT_UINT32, BASE_DEC,\n        NULL, 0x0, \"Captured by RPCAP daemon\", HFILL } },\n\n    /* Find all devices reply */\n    { &hf_findalldevs_reply,\n      { \"Find all devices\", \"rpcap.findalldevs_reply\", FT_NONE, BASE_NONE,\n        NULL, 0x0, NULL, HFILL } },\n    { &hf_findalldevs_if,\n      { \"Interface\", \"rpcap.if\", FT_NONE, BASE_NONE,\n        NULL, 0x0, NULL, HFILL } },\n    { &hf_namelen,\n      { \"Name length\", \"rpcap.namelen\", FT_UINT16, BASE_DEC,\n        NULL, 0x0, NULL, HFILL } },\n    { &hf_desclen,\n      { \"Description length\", \"rpcap.desclen\", FT_UINT32, BASE_DEC,\n        NULL, 0x0, NULL, HFILL } },\n    { &hf_if_flags,\n      { \"Interface flags\", \"rpcap.if.flags\", FT_UINT32, BASE_DEC,\n        NULL, 0x0, NULL, HFILL } },\n    { &hf_naddr,\n      { \"Number of addresses\", \"rpcap.naddr\", FT_UINT32, BASE_DEC,\n        NULL, 0x0, NULL, HFILL } },\n    { &hf_if_name,\n      { \"Name\", \"rpcap.ifname\", FT_STRING, BASE_NONE,\n        NULL, 0x0, \"Interface name\", HFILL } },\n    { &hf_if_desc,\n      { \"Description\", \"rpcap.ifdesc\", FT_STRING, BASE_NONE,\n        NULL, 0x0, \"Interface description\", HFILL } },\n\n    /* Find all devices / Interface addresses */\n    { &hf_findalldevs_ifaddr,\n      { \"Interface address\", \"rpcap.ifaddr\", FT_NONE, BASE_NONE,\n        NULL, 0x0, NULL, HFILL } },\n    { &hf_if_addr,\n      { \"Address\", \"rpcap.addr\", FT_NONE, BASE_NONE,\n        NULL, 0x0, \"Network address\", HFILL } },\n    { &hf_if_netmask,\n      { \"Netmask\", \"rpcap.netmask\", FT_NONE, BASE_NONE,\n        NULL, 0x0, NULL, HFILL } },\n    { &hf_if_broadaddr,\n      { \"Broadcast\", \"rpcap.broadaddr\", FT_NONE, BASE_NONE,\n        NULL, 0x0, NULL, HFILL } },\n    { &hf_if_dstaddr,\n      { \"P2P destination address\", \"rpcap.dstaddr\", FT_NONE, BASE_NONE,\n        NULL, 0x0, NULL, HFILL } },\n    { &hf_if_af,\n      { \"Address family\", \"rpcap.if.af\", FT_UINT16, BASE_HEX,\n        VALS(address_family), 0x0, NULL, HFILL } },\n    { &hf_if_port,\n      { \"Port\", \"rpcap.if.port\", FT_UINT16, BASE_DEC,\n        NULL, 0x0, \"Port number\", HFILL } },\n    { &hf_if_ip,\n      { \"IP address\", \"rpcap.if.ip\", FT_IPv4, BASE_NONE,\n        NULL, 0x0, NULL, HFILL } },\n    { &hf_if_padding,\n      { \"Padding\", \"rpcap.if.padding\", FT_BYTES, BASE_NONE,\n        NULL, 0x0, NULL, HFILL } },\n    { &hf_if_unknown,\n      { \"Unknown address\", \"rpcap.if.unknown\", FT_BYTES, BASE_NONE,\n        NULL, 0x0, NULL, HFILL } },\n\n    /* Sampling request */\n    { &hf_sampling_request,\n      { \"Sampling\", \"rpcap.sampling_request\", FT_NONE, BASE_NONE,\n        NULL, 0x0, NULL, HFILL } },\n    { &hf_sampling_method,\n      { \"Method\", \"rpcap.sampling_method\", FT_UINT8, BASE_DEC,\n        VALS(sampling_method), 0x0, \"Sampling method\", HFILL } },\n    { &hf_sampling_dummy1,\n      { \"Dummy1\", \"rpcap.dummy\", FT_UINT8, BASE_DEC,\n        NULL, 0x0, NULL, HFILL } },\n    { &hf_sampling_dummy2,\n      { \"Dummy2\", \"rpcap.dummy\", FT_UINT16, BASE_DEC,\n        NULL, 0x0, NULL, HFILL } },\n    { &hf_sampling_value,\n      { \"Value\", \"rpcap.sampling_value\", FT_UINT32, BASE_DEC,\n        NULL, 0x0, NULL, HFILL } },\n  };\n\n  static gint *ett[] = {\n    &ett_rpcap,\n    &ett_error,\n    &ett_packet,\n    &ett_auth_request,\n    &ett_open_reply,\n    &ett_startcap_request,\n    &ett_startcap_reply,\n    &ett_startcap_flags,\n    &ett_filter,\n    &ett_filterbpf_insn,\n    &ett_filterbpf_insn_code,\n    &ett_stats_reply,\n    &ett_findalldevs_reply,\n    &ett_findalldevs_if,\n    &ett_findalldevs_ifaddr,\n    &ett_ifaddr,\n    &ett_sampling_request\n  };\n\n  static ei_register_info ei[] = {\n     { &ei_error, { \"rpcap.error.expert\", PI_SEQUENCE, PI_NOTE, \"Error\", EXPFILL }},\n     { &ei_if_unknown, { \"rpcap.if_unknown\", PI_SEQUENCE, PI_NOTE, \"Unknown address family\", EXPFILL }},\n     { &ei_no_more_data, { \"rpcap.no_more_data\", PI_MALFORMED, PI_ERROR, \"No more data in packet\", EXPFILL }},\n     { &ei_caplen_too_big, { \"rpcap.caplen_too_big\", PI_MALFORMED, PI_ERROR, \"Caplen is bigger than the remaining message length\", EXPFILL }},\n  };\n\n  module_t *rpcap_module;\n  expert_module_t* expert_rpcap;\n\n  proto_rpcap = proto_register_protocol (PNAME, PSNAME, PFNAME);\n  new_register_dissector (PFNAME, dissect_rpcap, proto_rpcap);\n  expert_rpcap = expert_register_protocol(proto_rpcap);\n  expert_register_field_array(expert_rpcap, ei, array_length(ei));\n\n  proto_register_field_array (proto_rpcap, hf, array_length (hf));\n  proto_register_subtree_array (ett, array_length (ett));\n\n  /* Register our configuration options */\n  rpcap_module = prefs_register_protocol (proto_rpcap, proto_reg_handoff_rpcap);\n\n  prefs_register_bool_preference (rpcap_module, \"desegment_pdus\",\n                                  \"Reassemble PDUs spanning multiple TCP segments\",\n                                  \"Whether the RPCAP dissector should reassemble PDUs\"\n                                  \" spanning multiple TCP segments.\"\n                                  \" To use this option, you must also enable \\\"Allow subdissectors\"\n                                  \" to reassemble TCP streams\\\" in the TCP protocol settings.\",\n                                  &rpcap_desegment);\n  prefs_register_bool_preference (rpcap_module, \"decode_content\",\n                                  \"Decode content according to link-layer type\",\n                                  \"Whether the packets should be decoded according to\"\n                                  \" the link-layer type.\",\n                                  &decode_content);\n  prefs_register_uint_preference (rpcap_module, \"linktype\",\n                                  \"Default link-layer type\",\n                                  \"Default link-layer type to use if an Open Reply packet\"\n                                  \" has not been received.\",\n                                  10, &global_linktype);\n}\n\nvoid\nproto_reg_handoff_rpcap (void)\n{\n  static gboolean rpcap_prefs_initialized = FALSE;\n\n  if (!rpcap_prefs_initialized) {\n    data_handle = find_dissector (\"data\");\n    rpcap_prefs_initialized = TRUE;\n\n    heur_dissector_add (\"tcp\", dissect_rpcap_heur_tcp, \"RPCAP over TCP\", \"rpcap_tcp\", proto_rpcap, HEURISTIC_ENABLE);\n    heur_dissector_add (\"udp\", dissect_rpcap_heur_udp, \"RPCAP over UDP\", \"rpcap_udp\", proto_rpcap, HEURISTIC_ENABLE);\n  }\n\n  info_added = FALSE;\n  linktype = global_linktype;\n}\n\n/*\n * Editor modelines  -  http://www.wireshark.org/tools/modelines.html\n *\n * Local Variables:\n * c-basic-offset: 2\n * tab-width: 8\n * indent-tabs-mode: nil\n * End:\n *\n * ex: set shiftwidth=2 tabstop=8 expandtab:\n * :indentSize=2:tabSize=8:noTabs=true:\n */\n", "code_before": "/* packet-rpcap.c\n *\n * Routines for RPCAP message formats.\n *\n * Copyright 2008, Stig Bjorlykke <stig@bjorlykke.org>, Thales Norway AS\n *\n * Wireshark - Network traffic analyzer\n * By Gerald Combs <gerald@wireshark.org>\n * Copyright 1998 Gerald Combs\n *\n * SPDX-License-Identifier: GPL-2.0-or-later\n */\n\n#include \"config.h\"\n\n#include <epan/packet.h>\n#include <epan/aftypes.h>\n#include <epan/prefs.h>\n#include <epan/to_str.h>\n#include <epan/expert.h>\n#include <epan/exceptions.h>\n#include <epan/show_exception.h>\n#include <epan/tfs.h>\n#include <wsutil/array.h>\n#include <wsutil/str_util.h>\n\n#include \"packet-frame.h\"\n#include \"packet-pcap_pktdata.h\"\n#include \"packet-tcp.h\"\n\n#define PNAME  \"Remote Packet Capture\"\n#define PSNAME \"RPCAP\"\n#define PFNAME \"rpcap\"\n\n#define RPCAP_MSG_ERROR               0x01\n#define RPCAP_MSG_FINDALLIF_REQ       0x02\n#define RPCAP_MSG_OPEN_REQ            0x03\n#define RPCAP_MSG_STARTCAP_REQ        0x04\n#define RPCAP_MSG_UPDATEFILTER_REQ    0x05\n#define RPCAP_MSG_CLOSE               0x06\n#define RPCAP_MSG_PACKET              0x07\n#define RPCAP_MSG_AUTH_REQ            0x08\n#define RPCAP_MSG_STATS_REQ           0x09\n#define RPCAP_MSG_ENDCAP_REQ          0x0A\n#define RPCAP_MSG_SETSAMPLING_REQ     0x0B\n\n#define RPCAP_MSG_FINDALLIF_REPLY     (0x80+RPCAP_MSG_FINDALLIF_REQ)\n#define RPCAP_MSG_OPEN_REPLY          (0x80+RPCAP_MSG_OPEN_REQ)\n#define RPCAP_MSG_STARTCAP_REPLY      (0x80+RPCAP_MSG_STARTCAP_REQ)\n#define RPCAP_MSG_UPDATEFILTER_REPLY  (0x80+RPCAP_MSG_UPDATEFILTER_REQ)\n#define RPCAP_MSG_AUTH_REPLY          (0x80+RPCAP_MSG_AUTH_REQ)\n#define RPCAP_MSG_STATS_REPLY         (0x80+RPCAP_MSG_STATS_REQ)\n#define RPCAP_MSG_ENDCAP_REPLY        (0x80+RPCAP_MSG_ENDCAP_REQ)\n#define RPCAP_MSG_SETSAMPLING_REPLY   (0x80+RPCAP_MSG_SETSAMPLING_REQ)\n\n#define RPCAP_ERR_NETW            1\n#define RPCAP_ERR_INITTIMEOUT     2\n#define RPCAP_ERR_AUTH            3\n#define RPCAP_ERR_FINDALLIF       4\n#define RPCAP_ERR_NOREMOTEIF      5\n#define RPCAP_ERR_OPEN            6\n#define RPCAP_ERR_UPDATEFILTER    7\n#define RPCAP_ERR_GETSTATS        8\n#define RPCAP_ERR_READEX          9\n#define RPCAP_ERR_HOSTNOAUTH      10\n#define RPCAP_ERR_REMOTEACCEPT    11\n#define RPCAP_ERR_STARTCAPTURE    12\n#define RPCAP_ERR_ENDCAPTURE      13\n#define RPCAP_ERR_RUNTIMETIMEOUT  14\n#define RPCAP_ERR_SETSAMPLING     15\n#define RPCAP_ERR_WRONGMSG        16\n#define RPCAP_ERR_WRONGVER        17\n\n#define RPCAP_SAMP_NOSAMP            0\n#define RPCAP_SAMP_1_EVERY_N         1\n#define RPCAP_SAMP_FIRST_AFTER_N_MS  2\n\n#define RPCAP_RMTAUTH_NULL  0\n#define RPCAP_RMTAUTH_PWD   1\n\n#define FLAG_PROMISC     0x0001\n#define FLAG_DGRAM       0x0002\n#define FLAG_SERVEROPEN  0x0004\n#define FLAG_INBOUND     0x0008\n#define FLAG_OUTBOUND    0x0010\n\nvoid proto_register_rpcap (void);\nvoid proto_reg_handoff_rpcap (void);\n\nstatic int proto_rpcap;\n\nstatic int hf_version;\nstatic int hf_type;\nstatic int hf_value;\nstatic int hf_plen;\n\nstatic int hf_error;\nstatic int hf_error_value;\n\nstatic int hf_packet;\nstatic int hf_timestamp;\nstatic int hf_caplen;\nstatic int hf_len;\nstatic int hf_npkt;\n\nstatic int hf_auth_request;\nstatic int hf_auth_type;\nstatic int hf_auth_slen1;\nstatic int hf_auth_slen2;\nstatic int hf_auth_username;\nstatic int hf_auth_password;\n\nstatic int hf_auth_reply;\nstatic int hf_auth_minvers;\nstatic int hf_auth_maxvers;\n\nstatic int hf_open_request;\n\nstatic int hf_open_reply;\nstatic int hf_linktype;\nstatic int hf_tzoff;\n\nstatic int hf_startcap_request;\nstatic int hf_snaplen;\nstatic int hf_read_timeout;\nstatic int hf_flags;\nstatic int hf_flags_promisc;\nstatic int hf_flags_dgram;\nstatic int hf_flags_serveropen;\nstatic int hf_flags_inbound;\nstatic int hf_flags_outbound;\nstatic int hf_client_port;\nstatic int hf_startcap_reply;\nstatic int hf_bufsize;\nstatic int hf_server_port;\nstatic int hf_dummy;\n\nstatic int hf_filter;\nstatic int hf_filtertype;\nstatic int hf_nitems;\n\nstatic int hf_filterbpf_insn;\nstatic int hf_code;\nstatic int hf_code_class;\nstatic int hf_code_fields;\nstatic int hf_code_ld_size;\nstatic int hf_code_ld_mode;\nstatic int hf_code_alu_op;\nstatic int hf_code_jmp_op;\nstatic int hf_code_src;\nstatic int hf_code_rval;\nstatic int hf_code_misc_op;\nstatic int hf_jt;\nstatic int hf_jf;\nstatic int hf_instr_value;\n\nstatic int hf_stats_reply;\nstatic int hf_ifrecv;\nstatic int hf_ifdrop;\nstatic int hf_krnldrop;\nstatic int hf_srvcapt;\n\nstatic int hf_findalldevs_reply;\nstatic int hf_findalldevs_if;\nstatic int hf_namelen;\nstatic int hf_desclen;\nstatic int hf_if_flags;\nstatic int hf_naddr;\nstatic int hf_if_name;\nstatic int hf_if_desc;\n\nstatic int hf_findalldevs_ifaddr;\nstatic int hf_if_addr;\nstatic int hf_if_netmask;\nstatic int hf_if_broadaddr;\nstatic int hf_if_dstaddr;\nstatic int hf_if_af;\nstatic int hf_if_port;\nstatic int hf_if_ipv4;\nstatic int hf_if_flowinfo;\nstatic int hf_if_ipv6;\nstatic int hf_if_scopeid;\nstatic int hf_if_padding;\nstatic int hf_if_unknown;\n\nstatic int hf_sampling_request;\nstatic int hf_sampling_method;\nstatic int hf_sampling_dummy1;\nstatic int hf_sampling_dummy2;\nstatic int hf_sampling_value;\n\nstatic int ett_rpcap;\nstatic int ett_error;\nstatic int ett_packet;\nstatic int ett_auth_request;\nstatic int ett_auth_reply;\nstatic int ett_open_reply;\nstatic int ett_startcap_request;\nstatic int ett_startcap_reply;\nstatic int ett_startcap_flags;\nstatic int ett_filter;\nstatic int ett_filterbpf_insn;\nstatic int ett_filterbpf_insn_code;\nstatic int ett_stats_reply;\nstatic int ett_findalldevs_reply;\nstatic int ett_findalldevs_if;\nstatic int ett_findalldevs_ifaddr;\nstatic int ett_ifaddr;\nstatic int ett_sampling_request;\n\nstatic expert_field ei_error;\nstatic expert_field ei_if_unknown;\nstatic expert_field ei_no_more_data;\nstatic expert_field ei_caplen_too_big;\n\nstatic dissector_handle_t pcap_pktdata_handle;\nstatic dissector_handle_t rpcap_tcp_handle;\n\n/* User definable values */\nstatic bool rpcap_desegment = true;\nstatic bool decode_content = true;\nstatic int global_linktype = -1;\n\n/* Global variables */\nstatic int linktype = -1;\nstatic bool info_added;\n\nstatic const value_string message_type[] = {\n  { RPCAP_MSG_ERROR,              \"Error\"                       },\n  { RPCAP_MSG_FINDALLIF_REQ,      \"Find all interfaces request\" },\n  { RPCAP_MSG_OPEN_REQ,           \"Open request\"                },\n  { RPCAP_MSG_STARTCAP_REQ,       \"Start capture request\"       },\n  { RPCAP_MSG_UPDATEFILTER_REQ,   \"Update filter request\"       },\n  { RPCAP_MSG_CLOSE,              \"Close\"                       },\n  { RPCAP_MSG_PACKET,             \"Packet\"                      },\n  { RPCAP_MSG_AUTH_REQ,           \"Authentication request\"      },\n  { RPCAP_MSG_STATS_REQ,          \"Statistics request\"          },\n  { RPCAP_MSG_ENDCAP_REQ,         \"End capture request\"         },\n  { RPCAP_MSG_SETSAMPLING_REQ,    \"Set sampling request\"        },\n  { RPCAP_MSG_FINDALLIF_REPLY,    \"Find all interfaces reply\"   },\n  { RPCAP_MSG_OPEN_REPLY,         \"Open reply\"                  },\n  { RPCAP_MSG_STARTCAP_REPLY,     \"Start capture reply\"         },\n  { RPCAP_MSG_UPDATEFILTER_REPLY, \"Update filter reply\"         },\n  { RPCAP_MSG_AUTH_REPLY,         \"Authentication reply\"        },\n  { RPCAP_MSG_STATS_REPLY,        \"Statistics reply\"            },\n  { RPCAP_MSG_ENDCAP_REPLY,       \"End capture reply\"           },\n  { RPCAP_MSG_SETSAMPLING_REPLY,  \"Set sampling reply\"          },\n  { 0,   NULL }\n};\n\nstatic const value_string error_codes[] = {\n  { RPCAP_ERR_NETW,            \"Network error\"                        },\n  { RPCAP_ERR_INITTIMEOUT,     \"Initial timeout has expired\"          },\n  { RPCAP_ERR_AUTH,            \"Authentication error\"                 },\n  { RPCAP_ERR_FINDALLIF,       \"Generic findalldevs error\"            },\n  { RPCAP_ERR_NOREMOTEIF,      \"No remote interfaces\"                 },\n  { RPCAP_ERR_OPEN,            \"Generic pcap_open error\"              },\n  { RPCAP_ERR_UPDATEFILTER,    \"Generic updatefilter error\"           },\n  { RPCAP_ERR_GETSTATS,        \"Generic pcap_stats error\"             },\n  { RPCAP_ERR_READEX,          \"Generic pcap_next_ex error\"           },\n  { RPCAP_ERR_HOSTNOAUTH,      \"The host is not authorized\"           },\n  { RPCAP_ERR_REMOTEACCEPT,    \"Generic pcap_remoteaccept error\"      },\n  { RPCAP_ERR_STARTCAPTURE,    \"Generic pcap_startcapture error\"      },\n  { RPCAP_ERR_ENDCAPTURE,      \"Generic pcap_endcapture error\"        },\n  { RPCAP_ERR_RUNTIMETIMEOUT,  \"Runtime timeout has expired\"          },\n  { RPCAP_ERR_SETSAMPLING,     \"Error in setting sampling parameters\" },\n  { RPCAP_ERR_WRONGMSG,        \"Unrecognized message\"                 },\n  { RPCAP_ERR_WRONGVER,        \"Incompatible version\"                 },\n  { 0,   NULL }\n};\n\nstatic const value_string sampling_method[] = {\n  { RPCAP_SAMP_NOSAMP,            \"No sampling\"      },\n  { RPCAP_SAMP_1_EVERY_N,         \"1 every N\"        },\n  { RPCAP_SAMP_FIRST_AFTER_N_MS,  \"First after N ms\" },\n  { 0,   NULL }\n};\n\nstatic const value_string auth_type[] = {\n  { RPCAP_RMTAUTH_NULL, \"None\"     },\n  { RPCAP_RMTAUTH_PWD,  \"Password\" },\n  { 0,   NULL }\n};\n\nstatic const value_string bpf_class[] = {\n  { 0x00, \"ld\"   },\n  { 0x01, \"ldx\"  },\n  { 0x02, \"st\"   },\n  { 0x03, \"stx\"  },\n  { 0x04, \"alu\"  },\n  { 0x05, \"jmp\"  },\n  { 0x06, \"ret\"  },\n  { 0x07, \"misc\" },\n  { 0, NULL }\n};\n\nstatic const value_string bpf_size[] = {\n  { 0x00, \"w\" },\n  { 0x01, \"h\" },\n  { 0x02, \"b\" },\n  { 0, NULL }\n};\n\nstatic const value_string bpf_mode[] = {\n  { 0x00, \"imm\" },\n  { 0x01, \"abs\" },\n  { 0x02, \"ind\" },\n  { 0x03, \"mem\" },\n  { 0x04, \"len\" },\n  { 0x05, \"msh\" },\n  { 0, NULL }\n};\n\nstatic const value_string bpf_alu_op[] = {\n  { 0x00, \"add\" },\n  { 0x01, \"sub\" },\n  { 0x02, \"mul\" },\n  { 0x03, \"div\" },\n  { 0x04, \"or\"  },\n  { 0x05, \"and\" },\n  { 0x06, \"lsh\" },\n  { 0x07, \"rsh\" },\n  { 0x08, \"neg\" },\n  { 0, NULL }\n};\n\nstatic const value_string bpf_jmp_op[] = {\n  { 0x00, \"ja\"   },\n  { 0x01, \"jeq\"  },\n  { 0x02, \"jgt\"  },\n  { 0x03, \"jge\"  },\n  { 0x04, \"jset\" },\n  { 0, NULL }\n};\n\nstatic const value_string bpf_src[] = {\n  { 0x00, \"k\" },\n  { 0x01, \"x\" },\n  { 0, NULL }\n};\n\nstatic const value_string bpf_rval[] = {\n  { 0x00, \"k\" },\n  { 0x01, \"x\" },\n  { 0x02, \"a\" },\n  { 0, NULL }\n};\n\nstatic const value_string bpf_misc_op[] = {\n  { 0x00, \"tax\" },\n  { 0x10, \"txa\" },\n  { 0, NULL }\n};\n\n\nstatic void rpcap_frame_end (void)\n{\n  info_added = false;\n}\n\n\nstatic void\ndissect_rpcap_error (tvbuff_t *tvb, packet_info *pinfo,\n                     proto_tree *parent_tree, int offset)\n{\n  proto_item *ti;\n  int len;\n  char *str;\n\n  len = tvb_reported_length_remaining (tvb, offset);\n  if (len <= 0)\n    return;\n\n  ti = proto_tree_add_item_ret_display_string(parent_tree, hf_error, tvb, offset, len, ENC_ASCII, pinfo->pool, &str);\n  expert_add_info_format(pinfo, ti, &ei_error, \"Error: %s\", str);\n  col_append_fstr(pinfo->cinfo, COL_INFO, \": %s\", str);\n}\n\n/*\n * There's some painful history with this part of a findalldevs reply.\n *\n * Older RPCAPDs sent the addresses over the wire in the OS's native\n * structure format.  For most OSes, this looks like the over-the-wire\n * format, but might have a different value for AF_INET6 than the value\n * on the machine receiving the reply.  For OSes with the newer BSD-style\n * sockaddr structures, this has, instead of a 2-byte address family,\n * a 1-byte structure length followed by a 1-byte address family.  The\n * RPCAPD code would put the address family in network byte order before\n * sending it; that would set it to 0 on a little-endian machine, as\n * htons() of any value between 1 and 255 would result in a value > 255,\n * with its lower 8 bits zero, so putting that back into a 1-byte field\n * would set it to 0.\n *\n * Therefore, for older RPCAPDs running on an OS with newer BSD-style\n * sockaddr structures, the family field, if treated as a big-endian\n * (network byte order) 16-bit field, would be:\n *\n *\t(length << 8) | family if sent by a big-endian machine\n *\t(length << 8) if sent by a little-endian machine\n *\n * For current RPCAPDs, and for older RPCAPDs running on an OS with\n * older BSD-style sockaddr structures, the family field, if treated\n * as a big-endian 16-bit field, would just contain the family.\n *\n * (An additional bit of pain was that the structure was sent over the\n * wire as a network-byte-order struct sockaddr_storage, which does\n * *not* have the same size on all platforms.  On most platforms, the\n * structure is 128 bytes long; on Solaris, however, it's 256 bytes\n * long.  Neither the rpcap client code in libpcap, nor we, try to\n * detect Solaris addresses and deal with them.)\n *\n * The current rpcapd serializes the socket addresses as 128-byte\n * structures, containing:\n *\n *\ta 2-octet address family value, in network byte order;\n *\n *\ta 4-octet IPv4 address, if the address family value is 2\n *\t(the AF_INET value on all supported platforms);\n *\n *\ta 16-octet IPv6 address, if the address family value is\n *\t23 (the Windows AF_INET6 value, chosen because Windows\n *\twas, before rpcap was changed to standardize the format,\n *\tthe only platform for which precompiled binaries for\n *\trpcapd were generally available);\n *\n *\tpadding up to 128 bytes.\n *\n * The rpcap client code, and we, check for those address family values,\n * as well as other values that might have been produced by the old\n * code on various platforms.\n */\n\n/*\n * Possible IPv4 family values other than the designated over-the-wire value,\n * which is 2 (because everybody uses 2 for AF_INET4).\n */\n#define SOCKADDR_IN_LEN\t\t16\t/* length of struct sockaddr_in */\n#define NEW_BSD_AF_INET_BE\t((SOCKADDR_IN_LEN << 8) | BSD_AF_INET)\n#define NEW_BSD_AF_INET_LE\t(SOCKADDR_IN_LEN << 8)\n\n/*\n * Possible IPv6 family values other than the designated over-the-wire value,\n * which is 23 (because that's what Windows uses, and most RPCAP servers\n * out there are probably running Windows, as WinPcap includes the server\n * but few if any UN*Xes build and ship it).  Some are defined in\n * <epan/aftypes.h>.\n *\n * The new BSD sockaddr structure format was in place before 4.4-Lite, so\n * all the free-software BSDs use it.\n */\n#define SOCKADDR_IN6_LEN\t28\t/* length of struct sockaddr_in6 */\n#define NEW_BSD_AF_INET6_BSD_BE\t\t((SOCKADDR_IN6_LEN << 8) | BSD_AF_INET6_BSD)\t/* NetBSD, OpenBSD, BSD/OS */\n#define NEW_BSD_AF_INET6_FREEBSD_BE\t((SOCKADDR_IN6_LEN << 8) | BSD_AF_INET6_FREEBSD)\t/* FreeBSD, DragonFly BSD */\n#define NEW_BSD_AF_INET6_DARWIN_BE\t((SOCKADDR_IN6_LEN << 8) | BSD_AF_INET6_DARWIN)\t/* macOS, iOS, anything else Darwin-based */\n#define NEW_BSD_AF_INET6_LE\t\t(SOCKADDR_IN6_LEN << 8)\n#define HPUX_AF_INET6\t\t\t22\n#define AIX_AF_INET6\t\t\t24\n\nstatic const value_string address_family[] = {\n  { COMMON_AF_UNSPEC,            \"AF_UNSPEC\" },\n  { COMMON_AF_INET,              \"AF_INET\"   },\n  { NEW_BSD_AF_INET_BE,          \"AF_INET (old server code on big-endian 4.4-Lite-based OS)\" },\n  { NEW_BSD_AF_INET_LE,          \"AF_INET (old server code on little-endian 4.4-Lite-based OS)\" },\n  { WINSOCK_AF_INET6,            \"AF_INET6\"  },\n  { NEW_BSD_AF_INET6_BSD_BE,     \"AF_INET6 (old server code on big-endian NetBSD, OpenBSD, BSD/OS)\"  },\n  { NEW_BSD_AF_INET6_FREEBSD_BE, \"AF_INET6 (old server code on big-endian FreeBSD)\"  },\n  { NEW_BSD_AF_INET6_DARWIN_BE,  \"AF_INET6 (old server code on big-endian Mac OS X)\"  },\n  { NEW_BSD_AF_INET6_LE,         \"AF_INET6 (old server code on little-endian 4.4-Lite-based OS)\" },\n  { LINUX_AF_INET6,              \"AF_INET6 (old server code on Linux)\"  },\n  { HPUX_AF_INET6,               \"AF_INET6 (old server code on HP-UX)\"  },\n  { AIX_AF_INET6,                \"AF_INET6 (old server code on AIX)\"  },\n  { SOLARIS_AF_INET6,            \"AF_INET6 (old server code on Solaris)\"  },\n  { 0,   NULL }\n};\n\nstatic int\ndissect_rpcap_ifaddr (tvbuff_t *tvb, packet_info *pinfo,\n                      proto_tree *parent_tree, int offset, int hf_id,\n                      proto_item *parent_item)\n{\n  proto_tree *tree;\n  proto_item *ti;\n  uint16_t af;\n  ws_in4_addr ipv4;\n  ws_in6_addr ipv6;\n  char ipaddr[MAX_ADDR_STR_LEN];\n\n  ti = proto_tree_add_item (parent_tree, hf_id, tvb, offset, 128, ENC_BIG_ENDIAN);\n  tree = proto_item_add_subtree (ti, ett_ifaddr);\n\n  af = tvb_get_ntohs (tvb, offset);\n  proto_tree_add_item (tree, hf_if_af, tvb, offset, 2, ENC_BIG_ENDIAN);\n  offset += 2;\n\n  switch (af) {\n\n  case COMMON_AF_INET:\n  case NEW_BSD_AF_INET_BE:\n  case NEW_BSD_AF_INET_LE:\n    proto_tree_add_item (tree, hf_if_port, tvb, offset, 2, ENC_BIG_ENDIAN);\n    offset += 2;\n\n    ipv4 = tvb_get_ipv4 (tvb, offset);\n    ip_addr_to_str_buf(&ipv4, ipaddr, MAX_ADDR_STR_LEN);\n    proto_item_append_text (ti, \": %s\", ipaddr);\n    if (parent_item) {\n      proto_item_append_text (parent_item, \": %s\", ipaddr);\n    }\n    proto_tree_add_item (tree, hf_if_ipv4, tvb, offset, 4, ENC_BIG_ENDIAN);\n    offset += 4;\n\n    proto_tree_add_item (tree, hf_if_padding, tvb, offset, 120, ENC_NA);\n    offset += 120;\n    break;\n\n  case WINSOCK_AF_INET6:\n  case NEW_BSD_AF_INET6_BSD_BE:\n  case NEW_BSD_AF_INET6_FREEBSD_BE:\n  case NEW_BSD_AF_INET6_DARWIN_BE:\n  case NEW_BSD_AF_INET6_LE:\n  case LINUX_AF_INET6:\n  case HPUX_AF_INET6:\n  case AIX_AF_INET6:\n  case SOLARIS_AF_INET6:\n    proto_tree_add_item (tree, hf_if_port, tvb, offset, 2, ENC_BIG_ENDIAN);\n    offset += 2;\n\n    proto_tree_add_item (tree, hf_if_flowinfo, tvb, offset, 4, ENC_BIG_ENDIAN);\n    offset += 4;\n\n    tvb_get_ipv6 (tvb, offset, &ipv6);\n    ip6_to_str_buf(&ipv6, ipaddr, MAX_ADDR_STR_LEN);\n    proto_item_append_text (ti, \": %s\", ipaddr);\n    if (parent_item) {\n      proto_item_append_text (parent_item, \": %s\", ipaddr);\n    }\n    proto_tree_add_item (tree, hf_if_ipv6, tvb, offset, 16, ENC_NA);\n    offset += 16;\n\n    proto_tree_add_item (tree, hf_if_scopeid, tvb, offset, 4, ENC_BIG_ENDIAN);\n    offset += 4;\n\n    proto_tree_add_item (tree, hf_if_padding, tvb, offset, 108, ENC_NA);\n    offset += 100;\n    break;\n\n  default:\n    ti = proto_tree_add_item (tree, hf_if_unknown, tvb, offset, 126, ENC_NA);\n    if (af != COMMON_AF_UNSPEC) {\n      expert_add_info_format(pinfo, ti, &ei_if_unknown,\n                             \"Unknown address family: %d\", af);\n    }\n    offset += 126;\n    break;\n  }\n\n  return offset;\n}\n\n\nstatic int\ndissect_rpcap_findalldevs_ifaddr (tvbuff_t *tvb, packet_info *pinfo _U_,\n                                  proto_tree *parent_tree, int offset)\n{\n  proto_tree *tree;\n  proto_item *ti;\n  int boffset = offset;\n\n  ti = proto_tree_add_item (parent_tree, hf_findalldevs_ifaddr, tvb, offset, -1, ENC_NA);\n  tree = proto_item_add_subtree (ti, ett_findalldevs_ifaddr);\n\n  offset = dissect_rpcap_ifaddr (tvb, pinfo, tree, offset, hf_if_addr, ti);\n  offset = dissect_rpcap_ifaddr (tvb, pinfo, tree, offset, hf_if_netmask, NULL);\n  offset = dissect_rpcap_ifaddr (tvb, pinfo, tree, offset, hf_if_broadaddr, NULL);\n  offset = dissect_rpcap_ifaddr (tvb, pinfo, tree, offset, hf_if_dstaddr, NULL);\n\n  proto_item_set_len (ti, offset - boffset);\n\n  return offset;\n}\n\n\nstatic int\ndissect_rpcap_findalldevs_if (tvbuff_t *tvb, packet_info *pinfo _U_,\n                              proto_tree *parent_tree, int offset)\n{\n  proto_tree *tree;\n  proto_item *ti;\n  uint16_t namelen, desclen, naddr, i;\n  int boffset = offset;\n\n  ti = proto_tree_add_item (parent_tree, hf_findalldevs_if, tvb, offset, -1, ENC_NA);\n  tree = proto_item_add_subtree (ti, ett_findalldevs_if);\n\n  namelen = tvb_get_ntohs (tvb, offset);\n  proto_tree_add_item (tree, hf_namelen, tvb, offset, 2, ENC_BIG_ENDIAN);\n  offset += 2;\n\n  desclen = tvb_get_ntohs (tvb, offset);\n  proto_tree_add_item (tree, hf_desclen, tvb, offset, 2, ENC_BIG_ENDIAN);\n  offset += 2;\n\n  proto_tree_add_item (tree, hf_if_flags, tvb, offset, 4, ENC_BIG_ENDIAN);\n  offset += 4;\n\n  naddr = tvb_get_ntohs (tvb, offset);\n  proto_tree_add_item (tree, hf_naddr, tvb, offset, 2, ENC_BIG_ENDIAN);\n  offset += 2;\n\n  proto_tree_add_item (tree, hf_dummy, tvb, offset, 2, ENC_BIG_ENDIAN);\n  offset += 2;\n\n  if (namelen) {\n    const uint8_t* name;\n    proto_tree_add_item_ret_string(tree, hf_if_name, tvb, offset, namelen, ENC_ASCII|ENC_NA, pinfo->pool, &name);\n    proto_item_append_text (ti, \": %s\", name);\n    offset += namelen;\n  }\n\n  if (desclen) {\n    proto_tree_add_item (tree, hf_if_desc, tvb, offset, desclen, ENC_ASCII);\n    offset += desclen;\n  }\n\n  for (i = 0; i < naddr; i++) {\n    offset = dissect_rpcap_findalldevs_ifaddr (tvb, pinfo, tree, offset);\n    if (tvb_reported_length_remaining (tvb, offset) < 0) {\n      /* No more data in packet */\n      expert_add_info(pinfo, ti, &ei_no_more_data);\n      break;\n    }\n  }\n\n  proto_item_set_len (ti, offset - boffset);\n\n  return offset;\n}\n\n\nstatic void\ndissect_rpcap_findalldevs_reply (tvbuff_t *tvb, packet_info *pinfo _U_,\n                                 proto_tree *parent_tree, int offset, uint16_t no_devs)\n{\n  proto_tree *tree;\n  proto_item *ti;\n  uint16_t i;\n\n  ti = proto_tree_add_item (parent_tree, hf_findalldevs_reply, tvb, offset, -1, ENC_NA);\n  tree = proto_item_add_subtree (ti, ett_findalldevs_reply);\n\n  for (i = 0; i < no_devs; i++) {\n    offset = dissect_rpcap_findalldevs_if (tvb, pinfo, tree, offset);\n    if (tvb_reported_length_remaining (tvb, offset) < 0) {\n      /* No more data in packet */\n      expert_add_info(pinfo, ti, &ei_no_more_data);\n      break;\n    }\n  }\n\n  proto_item_append_text (ti, \", %d item%s\", no_devs, plurality (no_devs, \"\", \"s\"));\n}\n\n\nstatic int\ndissect_rpcap_filterbpf_insn (tvbuff_t *tvb, packet_info *pinfo _U_,\n                              proto_tree *parent_tree, int offset)\n{\n  proto_tree *tree, *code_tree;\n  proto_item *ti, *code_ti;\n  uint8_t inst_class;\n\n  ti = proto_tree_add_item (parent_tree, hf_filterbpf_insn, tvb, offset, 8, ENC_NA);\n  tree = proto_item_add_subtree (ti, ett_filterbpf_insn);\n\n  code_ti = proto_tree_add_item (tree, hf_code, tvb, offset, 2, ENC_BIG_ENDIAN);\n  code_tree = proto_item_add_subtree (code_ti, ett_filterbpf_insn_code);\n  proto_tree_add_item (code_tree, hf_code_class, tvb, offset, 2, ENC_BIG_ENDIAN);\n  inst_class = tvb_get_uint8 (tvb, offset + 1) & 0x07;\n  proto_item_append_text (ti, \": %s\", val_to_str_const (inst_class, bpf_class, \"\"));\n  switch (inst_class) {\n  case 0x00: /* ld */\n  case 0x01: /* ldx */\n    proto_tree_add_item (code_tree, hf_code_ld_size, tvb, offset, 2, ENC_BIG_ENDIAN);\n    proto_tree_add_item (code_tree, hf_code_ld_mode, tvb, offset, 2, ENC_BIG_ENDIAN);\n    break;\n  case 0x04: /* alu */\n    proto_tree_add_item (code_tree, hf_code_src, tvb, offset, 2, ENC_BIG_ENDIAN);\n    proto_tree_add_item (code_tree, hf_code_alu_op, tvb, offset, 2, ENC_BIG_ENDIAN);\n    break;\n  case 0x05: /* jmp */\n    proto_tree_add_item (code_tree, hf_code_src, tvb, offset, 2, ENC_BIG_ENDIAN);\n    proto_tree_add_item (code_tree, hf_code_jmp_op, tvb, offset, 2, ENC_BIG_ENDIAN);\n    break;\n  case 0x06: /* ret */\n    proto_tree_add_item (code_tree, hf_code_rval, tvb, offset, 2, ENC_BIG_ENDIAN);\n    break;\n  case 0x07: /* misc */\n    proto_tree_add_item (code_tree, hf_code_misc_op, tvb, offset, 2, ENC_BIG_ENDIAN);\n    break;\n  default:\n    proto_tree_add_item (code_tree, hf_code_fields, tvb, offset, 2, ENC_BIG_ENDIAN);\n    break;\n  }\n  offset += 2;\n\n  proto_tree_add_item (tree, hf_jt, tvb, offset, 1, ENC_BIG_ENDIAN);\n  offset += 1;\n\n  proto_tree_add_item (tree, hf_jf, tvb, offset, 1, ENC_BIG_ENDIAN);\n  offset += 1;\n\n  proto_tree_add_item (tree, hf_instr_value, tvb, offset, 4, ENC_BIG_ENDIAN);\n  offset += 4;\n\n  return offset;\n}\n\n\nstatic void\ndissect_rpcap_filter (tvbuff_t *tvb, packet_info *pinfo,\n                      proto_tree *parent_tree, int offset)\n{\n  proto_tree *tree;\n  proto_item *ti;\n  uint32_t nitems, i;\n\n  ti = proto_tree_add_item (parent_tree, hf_filter, tvb, offset, -1, ENC_NA);\n  tree = proto_item_add_subtree (ti, ett_filter);\n\n  proto_tree_add_item (tree, hf_filtertype, tvb, offset, 2, ENC_BIG_ENDIAN);\n  offset += 2;\n\n  proto_tree_add_item (tree, hf_dummy, tvb, offset, 2, ENC_BIG_ENDIAN);\n  offset += 2;\n\n  nitems = tvb_get_ntohl (tvb, offset);\n  proto_tree_add_item (tree, hf_nitems, tvb, offset, 4, ENC_BIG_ENDIAN);\n  offset += 4;\n\n  for (i = 0; i < nitems; i++) {\n    offset = dissect_rpcap_filterbpf_insn (tvb, pinfo, tree, offset);\n    if (tvb_reported_length_remaining (tvb, offset) < 0) {\n      /* No more data in packet */\n      expert_add_info(pinfo, ti, &ei_no_more_data);\n      break;\n    }\n  }\n}\n\n\nstatic int\ndissect_rpcap_auth_request (tvbuff_t *tvb, packet_info *pinfo _U_,\n                            proto_tree *parent_tree, int offset)\n{\n  proto_tree *tree;\n  proto_item *ti;\n  uint16_t type, slen1, slen2;\n\n  ti = proto_tree_add_item (parent_tree, hf_auth_request, tvb, offset, -1, ENC_NA);\n  tree = proto_item_add_subtree (ti, ett_auth_request);\n\n  type = tvb_get_ntohs (tvb, offset);\n  proto_tree_add_item (tree, hf_auth_type, tvb, offset, 2, ENC_BIG_ENDIAN);\n  offset += 2;\n\n  proto_tree_add_item (tree, hf_dummy, tvb, offset, 2, ENC_BIG_ENDIAN);\n  offset += 2;\n\n  slen1 = tvb_get_ntohs (tvb, offset);\n  proto_tree_add_item (tree, hf_auth_slen1, tvb, offset, 2, ENC_BIG_ENDIAN);\n  offset += 2;\n\n  slen2 = tvb_get_ntohs (tvb, offset);\n  proto_tree_add_item (tree, hf_auth_slen2, tvb, offset, 2, ENC_BIG_ENDIAN);\n  offset += 2;\n\n  if (type == RPCAP_RMTAUTH_NULL) {\n    proto_item_append_text (ti, \" (none)\");\n  } else if (type == RPCAP_RMTAUTH_PWD) {\n    const uint8_t *username, *password;\n\n    proto_tree_add_item_ret_string(tree, hf_auth_username, tvb, offset, slen1, ENC_ASCII|ENC_NA, pinfo->pool, &username);\n    offset += slen1;\n\n    proto_tree_add_item_ret_string(tree, hf_auth_password, tvb, offset, slen2, ENC_ASCII|ENC_NA, pinfo->pool, &password);\n    offset += slen2;\n\n    proto_item_append_text (ti, \" (%s/%s)\", username, password);\n  }\n  return offset;\n}\n\n\nstatic void\ndissect_rpcap_auth_reply (tvbuff_t *tvb, packet_info *pinfo _U_,\n                          proto_tree *parent_tree, int offset)\n{\n  proto_tree *tree;\n  proto_item *ti;\n  uint32_t minvers, maxvers;\n\n  /*\n   * Authentication replies from older servers have no payload.\n   * Replies from newer servers have a payload.\n   * Dissect the payload if we have any.\n   */\n  if (tvb_reported_length_remaining(tvb, offset) != 0) {\n    ti = proto_tree_add_item (parent_tree, hf_auth_reply, tvb, offset, -1, ENC_NA);\n    tree = proto_item_add_subtree (ti, ett_auth_reply);\n\n    proto_tree_add_item_ret_uint (tree, hf_auth_minvers, tvb, offset, 1, ENC_BIG_ENDIAN, &minvers);\n    offset += 1;\n\n    proto_tree_add_item_ret_uint (tree, hf_auth_maxvers, tvb, offset, 1, ENC_BIG_ENDIAN, &maxvers);\n\n    proto_item_append_text (ti, \", minimum version %u, maximum version %u\", minvers, maxvers);\n  }\n}\n\n\nstatic void\ndissect_rpcap_open_request (tvbuff_t *tvb, packet_info *pinfo _U_,\n                            proto_tree *parent_tree, int offset)\n{\n  int len;\n\n  len = tvb_reported_length_remaining (tvb, offset);\n  proto_tree_add_item (parent_tree, hf_open_request, tvb, offset, len, ENC_ASCII);\n}\n\n\nstatic void\ndissect_rpcap_open_reply (tvbuff_t *tvb, packet_info *pinfo _U_,\n                          proto_tree *parent_tree, int offset)\n{\n  proto_tree *tree;\n  proto_item *ti;\n\n  ti = proto_tree_add_item (parent_tree, hf_open_reply, tvb, offset, -1, ENC_NA);\n  tree = proto_item_add_subtree (ti, ett_open_reply);\n\n  linktype = tvb_get_ntohl (tvb, offset);\n  proto_tree_add_item (tree, hf_linktype, tvb, offset, 4, ENC_BIG_ENDIAN);\n  offset += 4;\n\n  proto_tree_add_item (tree, hf_tzoff, tvb, offset, 4, ENC_BIG_ENDIAN);\n}\n\n\nstatic void\ndissect_rpcap_startcap_request (tvbuff_t *tvb, packet_info *pinfo,\n                                proto_tree *parent_tree, int offset)\n{\n  proto_tree *tree, *field_tree;\n  proto_item *ti, *field_ti;\n  uint16_t flags;\n\n  ti = proto_tree_add_item (parent_tree, hf_startcap_request, tvb, offset, -1, ENC_NA);\n  tree = proto_item_add_subtree (ti, ett_startcap_request);\n\n  proto_tree_add_item (tree, hf_snaplen, tvb, offset, 4, ENC_BIG_ENDIAN);\n  offset += 4;\n\n  proto_tree_add_item (tree, hf_read_timeout, tvb, offset, 4, ENC_BIG_ENDIAN);\n  offset += 4;\n\n  flags = tvb_get_ntohs (tvb, offset);\n  field_ti = proto_tree_add_uint_format (tree, hf_flags, tvb, offset, 2, flags, \"Flags\");\n  field_tree = proto_item_add_subtree (field_ti, ett_startcap_flags);\n  proto_tree_add_item (field_tree, hf_flags_promisc, tvb, offset, 2, ENC_BIG_ENDIAN);\n  proto_tree_add_item (field_tree, hf_flags_dgram, tvb, offset, 2, ENC_BIG_ENDIAN);\n  proto_tree_add_item (field_tree, hf_flags_serveropen, tvb, offset, 2, ENC_BIG_ENDIAN);\n  proto_tree_add_item (field_tree, hf_flags_inbound, tvb, offset, 2, ENC_BIG_ENDIAN);\n  proto_tree_add_item (field_tree, hf_flags_outbound, tvb, offset, 2, ENC_BIG_ENDIAN);\n\n  if (flags & 0x1F) {\n    char *flagstr = wmem_strdup_printf (pinfo->pool, \"%s%s%s%s%s\",\n          (flags & FLAG_PROMISC)    ? \", Promiscuous\" : \"\",\n          (flags & FLAG_DGRAM)      ? \", Datagram\"    : \"\",\n          (flags & FLAG_SERVEROPEN) ? \", ServerOpen\"  : \"\",\n          (flags & FLAG_INBOUND)    ? \", Inbound\"     : \"\",\n          (flags & FLAG_OUTBOUND)   ? \", Outbound\"    : \"\");\n    proto_item_append_text (field_ti, \":%s\", &flagstr[1]);\n  } else {\n    proto_item_append_text (field_ti, \" (none)\");\n  }\n  offset += 2;\n\n  proto_tree_add_item (tree, hf_client_port, tvb, offset, 2, ENC_BIG_ENDIAN);\n  offset += 2;\n\n  dissect_rpcap_filter (tvb, pinfo, tree, offset);\n}\n\n\nstatic void\ndissect_rpcap_startcap_reply (tvbuff_t *tvb, packet_info *pinfo _U_,\n                              proto_tree *parent_tree, int offset)\n{\n  proto_tree *tree;\n  proto_item *ti;\n\n  ti = proto_tree_add_item (parent_tree, hf_startcap_reply, tvb, offset, -1, ENC_NA);\n  tree = proto_item_add_subtree (ti, ett_startcap_reply);\n\n  proto_tree_add_item (tree, hf_bufsize, tvb, offset, 4, ENC_BIG_ENDIAN);\n  offset += 4;\n\n  proto_tree_add_item (tree, hf_server_port, tvb, offset, 2, ENC_BIG_ENDIAN);\n  offset += 2;\n\n  proto_tree_add_item (tree, hf_dummy, tvb, offset, 2, ENC_BIG_ENDIAN);\n}\n\n\nstatic void\ndissect_rpcap_stats_reply (tvbuff_t *tvb, packet_info *pinfo _U_,\n                           proto_tree *parent_tree, int offset)\n{\n  proto_tree *tree;\n  proto_item *ti;\n\n  ti = proto_tree_add_item (parent_tree, hf_stats_reply, tvb, offset, 16, ENC_NA);\n  tree = proto_item_add_subtree (ti, ett_stats_reply);\n\n  proto_tree_add_item (tree, hf_ifrecv, tvb, offset, 4, ENC_BIG_ENDIAN);\n  offset += 4;\n\n  proto_tree_add_item (tree, hf_ifdrop, tvb, offset, 4, ENC_BIG_ENDIAN);\n  offset += 4;\n\n  proto_tree_add_item (tree, hf_krnldrop, tvb, offset, 4, ENC_BIG_ENDIAN);\n  offset += 4;\n\n  proto_tree_add_item (tree, hf_srvcapt, tvb, offset, 4, ENC_BIG_ENDIAN);\n}\n\n\nstatic int\ndissect_rpcap_sampling_request (tvbuff_t *tvb, packet_info *pinfo _U_,\n                                proto_tree *parent_tree, int offset)\n{\n  proto_tree *tree;\n  proto_item *ti;\n  uint32_t value;\n  uint8_t method;\n\n  ti = proto_tree_add_item (parent_tree, hf_sampling_request, tvb, offset, -1, ENC_NA);\n  tree = proto_item_add_subtree (ti, ett_sampling_request);\n\n  method = tvb_get_uint8 (tvb, offset);\n  proto_tree_add_item (tree, hf_sampling_method, tvb, offset, 1, ENC_BIG_ENDIAN);\n  offset += 1;\n\n  proto_tree_add_item (tree, hf_sampling_dummy1, tvb, offset, 1, ENC_BIG_ENDIAN);\n  offset += 1;\n\n  proto_tree_add_item (tree, hf_sampling_dummy2, tvb, offset, 2, ENC_BIG_ENDIAN);\n  offset += 2;\n\n  value = tvb_get_ntohl (tvb, offset);\n  proto_tree_add_item (tree, hf_sampling_value, tvb, offset, 4, ENC_BIG_ENDIAN);\n  offset += 4;\n\n  switch (method) {\n  case RPCAP_SAMP_NOSAMP:\n    proto_item_append_text (ti, \": None\");\n    break;\n  case RPCAP_SAMP_1_EVERY_N:\n    proto_item_append_text (ti, \": 1 every %d\", value);\n    break;\n  case RPCAP_SAMP_FIRST_AFTER_N_MS:\n    proto_item_append_text (ti, \": First after %d ms\", value);\n    break;\n  default:\n    break;\n  }\n  return offset;\n}\n\n\nstatic void\ndissect_rpcap_packet (tvbuff_t *tvb, packet_info *pinfo, proto_tree *top_tree,\n                      proto_tree *parent_tree, int offset, proto_item *top_item)\n{\n  proto_tree *tree;\n  proto_item *ti;\n  tvbuff_t *new_tvb;\n  unsigned caplen, len, frame_no;\n  int reported_length_remaining;\n\n  ti = proto_tree_add_item (parent_tree, hf_packet, tvb, offset, 20, ENC_NA);\n  tree = proto_item_add_subtree (ti, ett_packet);\n\n  proto_tree_add_item(tree, hf_timestamp, tvb, offset, 8, ENC_TIME_SECS_USECS|ENC_BIG_ENDIAN);\n  offset += 8;\n\n  caplen = tvb_get_ntohl (tvb, offset);\n  ti = proto_tree_add_item (tree, hf_caplen, tvb, offset, 4, ENC_BIG_ENDIAN);\n  offset += 4;\n\n  len = tvb_get_ntohl (tvb, offset);\n  proto_tree_add_item (tree, hf_len, tvb, offset, 4, ENC_BIG_ENDIAN);\n  offset += 4;\n\n  frame_no = tvb_get_ntohl (tvb, offset);\n  proto_tree_add_item (tree, hf_npkt, tvb, offset, 4, ENC_BIG_ENDIAN);\n  offset += 4;\n\n  proto_item_append_text (ti, \", Frame %u\", frame_no);\n  proto_item_append_text (top_item, \" Frame %u\", frame_no);\n\n  /*\n   * reported_length_remaining should not be -1, as offset is at\n   * most right past the end of the available data in the packet.\n   */\n  reported_length_remaining = tvb_reported_length_remaining (tvb, offset);\n  if (caplen > (unsigned)reported_length_remaining) {\n    expert_add_info(pinfo, ti, &ei_caplen_too_big);\n    return;\n  }\n\n  new_tvb = tvb_new_subset_length_caplen (tvb, offset, caplen, len);\n  if (decode_content && linktype != -1) {\n    TRY {\n      call_dissector_with_data(pcap_pktdata_handle, new_tvb, pinfo, top_tree, &linktype);\n    }\n    CATCH_BOUNDS_ERRORS {\n      show_exception(tvb, pinfo, top_tree, EXCEPT_CODE, GET_MESSAGE);\n    }\n    ENDTRY;\n\n    if (!info_added) {\n      /* Only indicate when not added before */\n      /* Indicate RPCAP in the protocol column */\n      col_prepend_fence_fstr(pinfo->cinfo, COL_PROTOCOL, \"R|\");\n\n      /* Indicate RPCAP in the info column */\n      col_prepend_fence_fstr (pinfo->cinfo, COL_INFO, \"Remote | \");\n      info_added = true;\n      register_frame_end_routine(pinfo, rpcap_frame_end);\n    }\n  } else {\n    if (linktype == -1) {\n      proto_item_append_text (ti, \", Unknown link-layer type\");\n    }\n    call_data_dissector(new_tvb, pinfo, top_tree);\n  }\n}\n\n\nstatic int\ndissect_rpcap (tvbuff_t *tvb, packet_info *pinfo, proto_tree *top_tree, void* data _U_)\n{\n  proto_tree *tree;\n  proto_item *ti;\n  tvbuff_t *new_tvb;\n  int len, offset = 0;\n  uint32_t msg_type;\n  uint16_t msg_value;\n  char* str_message_type;\n\n  col_set_str (pinfo->cinfo, COL_PROTOCOL, PSNAME);\n\n  col_clear(pinfo->cinfo, COL_INFO);\n\n  ti = proto_tree_add_item (top_tree, proto_rpcap, tvb, offset, -1, ENC_NA);\n  tree = proto_item_add_subtree (ti, ett_rpcap);\n\n  proto_tree_add_item (tree, hf_version, tvb, offset, 1, ENC_BIG_ENDIAN);\n  offset++;\n\n  proto_tree_add_item_ret_uint(tree, hf_type, tvb, offset, 1, ENC_BIG_ENDIAN, &msg_type);\n  offset++;\n\n  str_message_type = val_to_str_wmem(pinfo->pool, msg_type, message_type, \"Unknown: 0x%02x\");\n  col_append_str (pinfo->cinfo, COL_INFO, str_message_type);\n\n  proto_item_append_text (ti, \", %s\", str_message_type);\n\n  msg_value = tvb_get_ntohs (tvb, offset);\n  if (msg_type == RPCAP_MSG_ERROR) {\n    proto_tree_add_item (tree, hf_error_value, tvb, offset, 2, ENC_BIG_ENDIAN);\n  } else {\n    proto_tree_add_item (tree, hf_value, tvb, offset, 2, ENC_BIG_ENDIAN);\n  }\n  offset += 2;\n\n  proto_tree_add_item (tree, hf_plen, tvb, offset, 4, ENC_BIG_ENDIAN);\n  offset += 4;\n\n\n  switch (msg_type) {\n  case RPCAP_MSG_ERROR:\n    dissect_rpcap_error (tvb, pinfo, tree, offset);\n    break;\n  case RPCAP_MSG_OPEN_REQ:\n    dissect_rpcap_open_request (tvb, pinfo, tree, offset);\n    break;\n  case RPCAP_MSG_STARTCAP_REQ:\n    dissect_rpcap_startcap_request (tvb, pinfo, tree, offset);\n    break;\n  case RPCAP_MSG_UPDATEFILTER_REQ:\n    dissect_rpcap_filter (tvb, pinfo, tree, offset);\n    break;\n  case RPCAP_MSG_PACKET:\n    proto_item_set_len (ti, 28);\n    dissect_rpcap_packet (tvb, pinfo, top_tree, tree, offset, ti);\n    break;\n  case RPCAP_MSG_AUTH_REQ:\n    dissect_rpcap_auth_request (tvb, pinfo, tree, offset);\n    break;\n  case RPCAP_MSG_SETSAMPLING_REQ:\n    dissect_rpcap_sampling_request (tvb, pinfo, tree, offset);\n    break;\n  case RPCAP_MSG_AUTH_REPLY:\n    dissect_rpcap_auth_reply (tvb, pinfo, tree, offset);\n    break;\n  case RPCAP_MSG_FINDALLIF_REPLY:\n    dissect_rpcap_findalldevs_reply (tvb, pinfo, tree, offset, msg_value);\n    break;\n  case RPCAP_MSG_OPEN_REPLY:\n    dissect_rpcap_open_reply (tvb, pinfo, tree, offset);\n    break;\n  case RPCAP_MSG_STARTCAP_REPLY:\n    dissect_rpcap_startcap_reply (tvb, pinfo, tree, offset);\n    break;\n  case RPCAP_MSG_STATS_REPLY:\n    dissect_rpcap_stats_reply (tvb, pinfo, tree, offset);\n    break;\n  default:\n    len = tvb_reported_length_remaining (tvb, offset);\n    if (len) {\n      /* Yet unknown, dump as data */\n      proto_item_set_len (ti, 8);\n      new_tvb = tvb_new_subset_remaining (tvb, offset);\n      call_data_dissector(new_tvb, pinfo, top_tree);\n    }\n    break;\n  }\n\n  return tvb_captured_length(tvb);\n}\n\n\nstatic bool\ncheck_rpcap_heur (tvbuff_t *tvb, bool tcp)\n{\n  int offset = 0;\n  uint8_t version, msg_type;\n  uint16_t msg_value;\n  uint32_t plen, len, caplen;\n\n  if (tvb_captured_length (tvb) < 8)\n    /* Too short */\n    return false;\n\n  version = tvb_get_uint8 (tvb, offset);\n  if (version != 0)\n    /* Incorrect version */\n    return false;\n  offset++;\n\n  msg_type = tvb_get_uint8 (tvb, offset);\n  if (!tcp && msg_type != 7) {\n    /* UDP is only used for packets */\n    return false;\n  }\n  if (try_val_to_str(msg_type, message_type) == NULL)\n    /* Unknown message type */\n    return false;\n  offset++;\n\n  msg_value = tvb_get_ntohs (tvb, offset);\n  if (msg_value > 0) {\n    if (msg_type == RPCAP_MSG_ERROR) {\n      /* Must have a valid error code */\n      if (try_val_to_str(msg_value, error_codes) == NULL)\n        return false;\n    } else if (msg_type != RPCAP_MSG_FINDALLIF_REPLY) {\n      return false;\n    }\n  }\n  offset += 2;\n\n  plen = tvb_get_ntohl (tvb, offset);\n  offset += 4;\n  len = (uint32_t) tvb_reported_length_remaining (tvb, offset);\n\n  switch (msg_type) {\n\n  case RPCAP_MSG_FINDALLIF_REQ:\n  case RPCAP_MSG_UPDATEFILTER_REPLY:\n  case RPCAP_MSG_STATS_REQ:\n  case RPCAP_MSG_CLOSE:\n  case RPCAP_MSG_SETSAMPLING_REPLY:\n  case RPCAP_MSG_ENDCAP_REQ:\n  case RPCAP_MSG_ENDCAP_REPLY:\n    /* Empty payload */\n    if (plen != 0 || len != 0)\n      return false;\n    break;\n\n  case RPCAP_MSG_OPEN_REPLY:\n  case RPCAP_MSG_STARTCAP_REPLY:\n  case RPCAP_MSG_SETSAMPLING_REQ:\n    /* Always 8 bytes */\n    if (plen != 8 || len != 8)\n      return false;\n    break;\n\n  case RPCAP_MSG_STATS_REPLY:\n    /* Always 16 bytes */\n    if (plen != 16 || len != 16)\n      return false;\n    break;\n\n  case RPCAP_MSG_PACKET:\n    /* Must have the frame header */\n    if (plen < 20)\n      return false;\n\n    /* Check if capture length is valid */\n    caplen = tvb_get_ntohl (tvb, offset+8);\n    /* Always 20 bytes less than packet length */\n    if (caplen != (plen - 20) || caplen > 65535)\n      return false;\n    break;\n\n  case RPCAP_MSG_FINDALLIF_REPLY:\n  case RPCAP_MSG_ERROR:\n  case RPCAP_MSG_OPEN_REQ:\n  case RPCAP_MSG_STARTCAP_REQ:\n  case RPCAP_MSG_UPDATEFILTER_REQ:\n  case RPCAP_MSG_AUTH_REQ:\n  case RPCAP_MSG_AUTH_REPLY:\n    /* Variable length */\n    if (plen != len)\n      return false;\n    break;\n  default:\n    /* Unknown message type */\n    return false;\n  }\n\n  return true;\n}\n\n\nstatic unsigned\nget_rpcap_pdu_len (packet_info *pinfo _U_, tvbuff_t *tvb, int offset, void *data _U_)\n{\n  return tvb_get_ntohl (tvb, offset + 4) + 8;\n}\n\n\nstatic int\ndissect_rpcap_tcp (tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)\n{\n  tcp_dissect_pdus (tvb, pinfo, tree, rpcap_desegment, 8,\n                    get_rpcap_pdu_len, dissect_rpcap, data);\n  return tvb_captured_length (tvb);\n}\n\nstatic bool\ndissect_rpcap_heur_tcp (tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)\n{\n  if (check_rpcap_heur (tvb, true)) {\n    /*\n     * This is probably a rpcap TCP packet.\n     * Make the dissector for this conversation the non-heuristic\n     * rpcap dissector, so that malformed rpcap packets are reported\n     * as such.\n     */\n    conversation_t *conversation = find_conversation_pinfo (pinfo, 0);\n    if (conversation)\n      conversation_set_dissector_from_frame_number (conversation,\n                                                  pinfo->num,\n                                                  rpcap_tcp_handle);\n    tcp_dissect_pdus (tvb, pinfo, tree, rpcap_desegment, 8,\n                      get_rpcap_pdu_len, dissect_rpcap, data);\n\n    return true;\n  }\n\n  return false;\n}\n\n\nstatic bool\ndissect_rpcap_heur_udp (tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)\n{\n  if (check_rpcap_heur (tvb, false)) {\n    /* This is probably a rpcap udp package */\n    dissect_rpcap (tvb, pinfo, tree, data);\n\n    return true;\n  }\n\n  return false;\n}\n\n\nvoid\nproto_register_rpcap (void)\n{\n  static hf_register_info hf[] = {\n    /* Common header for all messages */\n    { &hf_version,\n      { \"Version\", \"rpcap.version\", FT_UINT8, BASE_DEC,\n        NULL, 0x0, NULL, HFILL } },\n    { &hf_type,\n      { \"Message type\", \"rpcap.type\", FT_UINT8, BASE_HEX,\n        VALS(message_type), 0x0, NULL, HFILL } },\n    { &hf_value,\n      { \"Message value\", \"rpcap.value\", FT_UINT16, BASE_DEC,\n        NULL, 0x0, NULL, HFILL } },\n    { &hf_plen,\n      { \"Payload length\", \"rpcap.len\", FT_UINT32, BASE_DEC,\n        NULL, 0x0, NULL, HFILL } },\n\n    /* Error */\n    { &hf_error,\n      { \"Error\", \"rpcap.error\", FT_STRING, BASE_STR_WSP,\n        NULL, 0x0, \"Error text\", HFILL } },\n    { &hf_error_value,\n      { \"Error value\", \"rpcap.error_value\", FT_UINT16, BASE_DEC,\n        VALS(error_codes), 0x0, NULL, HFILL } },\n\n    /* Packet header */\n    { &hf_packet,\n      { \"Packet\", \"rpcap.packet\", FT_NONE, BASE_NONE,\n        NULL, 0x0, \"Packet data\", HFILL } },\n    { &hf_timestamp,\n      { \"Arrival time\", \"rpcap.time\", FT_ABSOLUTE_TIME, ABSOLUTE_TIME_LOCAL,\n        NULL, 0x0, NULL, HFILL } },\n    { &hf_caplen,\n      { \"Capture length\", \"rpcap.cap_len\", FT_UINT32, BASE_DEC,\n        NULL, 0x0, NULL, HFILL } },\n    { &hf_len,\n      { \"Frame length\", \"rpcap.len\", FT_UINT32, BASE_DEC,\n        NULL, 0x0, \"Frame length (off wire)\", HFILL } },\n    { &hf_npkt,\n      { \"Frame number\", \"rpcap.number\", FT_UINT32, BASE_DEC,\n        NULL, 0x0, NULL, HFILL } },\n\n    /* Authentication request */\n    { &hf_auth_request,\n      { \"Authentication request\", \"rpcap.auth_request\", FT_NONE, BASE_NONE,\n        NULL, 0x0, NULL, HFILL } },\n    { &hf_auth_type,\n      { \"Authentication type\", \"rpcap.auth_type\", FT_UINT16, BASE_DEC,\n        VALS(auth_type), 0x0, NULL, HFILL } },\n    { &hf_auth_slen1,\n      { \"Authentication item length 1\", \"rpcap.auth_len1\", FT_UINT16, BASE_DEC,\n        NULL, 0x0, NULL, HFILL } },\n    { &hf_auth_slen2,\n      { \"Authentication item length 2\", \"rpcap.auth_len2\", FT_UINT16, BASE_DEC,\n        NULL, 0x0, NULL, HFILL } },\n    { &hf_auth_username,\n      { \"Username\", \"rpcap.username\", FT_STRING, BASE_NONE,\n        NULL, 0x0, NULL, HFILL } },\n    { &hf_auth_password,\n      { \"Password\", \"rpcap.password\", FT_STRING, BASE_NONE,\n        NULL, 0x0, NULL, HFILL } },\n\n    /* Authentication reply */\n    { &hf_auth_reply,\n      { \"Authentication reply\", \"rpcap.auth_reply\", FT_NONE, BASE_NONE,\n        NULL, 0x0, NULL, HFILL } },\n    { &hf_auth_minvers,\n      { \"Minimum version number supported\", \"rpcap.auth_minvers\", FT_UINT8, BASE_DEC,\n        NULL, 0x0, NULL, HFILL } },\n    { &hf_auth_maxvers,\n      { \"Maximum version number supported\", \"rpcap.auth_maxvers\", FT_UINT8, BASE_DEC,\n        NULL, 0x0, NULL, HFILL } },\n\n    /* Open request */\n    { &hf_open_request,\n      { \"Open request\", \"rpcap.open_request\", FT_STRING, BASE_NONE,\n        NULL, 0x0, NULL, HFILL } },\n\n    /* Open reply */\n    { &hf_open_reply,\n      { \"Open reply\", \"rpcap.open_reply\", FT_NONE, BASE_NONE,\n        NULL, 0x0, NULL, HFILL } },\n    /*\n     * XXX - the code probably sends a DLT_ value over the wire, but\n     * it should really send a LINKTYPE_ value, so that if the client\n     * and server are running OSes that disagree on the numerical value\n     * of that DLT_, they won't get confused (LINKTYPE_ values aren't\n     * platform-dependent).  The vast majority of LINKTYPE_ values and\n     * DLT_ values are the same for the same link-layer type.\n     */\n    { &hf_linktype,\n      { \"Link type\", \"rpcap.linktype\", FT_UINT32, BASE_DEC,\n        VALS(link_type_vals), 0x0, NULL, HFILL } },\n    { &hf_tzoff,\n      { \"Timezone offset\", \"rpcap.tzoff\", FT_UINT32, BASE_DEC,\n        NULL, 0x0, NULL, HFILL } },\n\n    /* Start capture request */\n    { &hf_startcap_request,\n      { \"Start capture request\", \"rpcap.startcap_request\", FT_NONE, BASE_NONE,\n        NULL, 0x0, NULL, HFILL } },\n    { &hf_snaplen,\n      { \"Snap length\", \"rpcap.snaplen\", FT_UINT32, BASE_DEC,\n        NULL, 0x0, NULL, HFILL } },\n    { &hf_read_timeout,\n      { \"Read timeout\", \"rpcap.read_timeout\", FT_UINT32, BASE_DEC,\n        NULL, 0x0, NULL, HFILL } },\n    { &hf_flags,\n      { \"Flags\", \"rpcap.flags\", FT_UINT16, BASE_DEC,\n        NULL, 0x0, \"Capture flags\", HFILL } },\n    { &hf_flags_promisc,\n      { \"Promiscuous mode\", \"rpcap.flags.promisc\", FT_BOOLEAN, 16,\n        TFS(&tfs_enabled_disabled), FLAG_PROMISC, NULL, HFILL } },\n    { &hf_flags_dgram,\n      { \"Use Datagram\", \"rpcap.flags.dgram\", FT_BOOLEAN, 16,\n        TFS(&tfs_yes_no), FLAG_DGRAM, NULL, HFILL } },\n    { &hf_flags_serveropen,\n      { \"Server open\", \"rpcap.flags.serveropen\", FT_BOOLEAN, 16,\n        TFS(&tfs_open_closed), FLAG_SERVEROPEN, NULL, HFILL } },\n    { &hf_flags_inbound,\n      { \"Inbound\", \"rpcap.flags.inbound\", FT_BOOLEAN, 16,\n        TFS(&tfs_yes_no), FLAG_INBOUND, NULL, HFILL } },\n    { &hf_flags_outbound,\n      { \"Outbound\", \"rpcap.flags.outbound\", FT_BOOLEAN, 16,\n        TFS(&tfs_yes_no), FLAG_OUTBOUND, NULL, HFILL } },\n    { &hf_client_port,\n      { \"Client Port\", \"rpcap.client_port\", FT_UINT16, BASE_DEC,\n        NULL, 0x0, NULL, HFILL } },\n\n    /* Start capture reply */\n    { &hf_startcap_reply,\n      { \"Start capture reply\", \"rpcap.startcap_reply\", FT_NONE, BASE_NONE,\n        NULL, 0x0, NULL, HFILL } },\n    { &hf_bufsize,\n      { \"Buffer size\", \"rpcap.bufsize\", FT_UINT32, BASE_DEC,\n        NULL, 0x0, NULL, HFILL } },\n    { &hf_server_port,\n      { \"Server port\", \"rpcap.server_port\", FT_UINT16, BASE_DEC,\n        NULL, 0x0, NULL, HFILL } },\n    { &hf_dummy,\n      { \"Dummy\", \"rpcap.dummy\", FT_UINT16, BASE_DEC,\n        NULL, 0x0, NULL, HFILL } },\n\n    /* Filter */\n    { &hf_filter,\n      { \"Filter\", \"rpcap.filter\", FT_NONE, BASE_NONE,\n        NULL, 0x0, NULL, HFILL } },\n    { &hf_filtertype,\n      { \"Filter type\", \"rpcap.filtertype\", FT_UINT16, BASE_DEC,\n        NULL, 0x0, \"Filter type (BPF)\", HFILL } },\n    { &hf_nitems,\n      { \"Number of items\", \"rpcap.nitems\", FT_UINT32, BASE_DEC,\n        NULL, 0x0, NULL, HFILL } },\n\n    /* Filter BPF instruction */\n    { &hf_filterbpf_insn,\n      { \"Filter BPF instruction\", \"rpcap.filterbpf_insn\", FT_NONE, BASE_NONE,\n        NULL, 0x0, NULL, HFILL } },\n    { &hf_code,\n      { \"Op code\", \"rpcap.opcode\", FT_UINT16, BASE_HEX,\n        NULL, 0x0, \"Operation code\", HFILL } },\n    { &hf_code_class,\n      { \"Class\", \"rpcap.opcode.class\", FT_UINT16, BASE_HEX,\n        VALS(bpf_class), 0x07, \"Instruction Class\", HFILL } },\n    { &hf_code_fields,\n      { \"Fields\", \"rpcap.opcode.fields\", FT_UINT16, BASE_HEX,\n        NULL, 0xF8, \"Class Fields\", HFILL } },\n    { &hf_code_ld_size,\n      { \"Size\", \"rpcap.opcode.size\", FT_UINT16, BASE_HEX,\n        VALS(bpf_size), 0x18, NULL, HFILL } },\n    { &hf_code_ld_mode,\n      { \"Mode\", \"rpcap.opcode.mode\", FT_UINT16, BASE_HEX,\n        VALS(bpf_mode), 0xE0, NULL, HFILL } },\n    { &hf_code_alu_op,\n      { \"Op\", \"rpcap.opcode.aluop\", FT_UINT16, BASE_HEX,\n        VALS(bpf_alu_op), 0xF0, NULL, HFILL } },\n    { &hf_code_jmp_op,\n      { \"Op\", \"rpcap.opcode.jmpop\", FT_UINT16, BASE_HEX,\n        VALS(bpf_jmp_op), 0xF0, NULL, HFILL } },\n    { &hf_code_src,\n      { \"Src\", \"rpcap.opcode.src\", FT_UINT16, BASE_HEX,\n        VALS(bpf_src), 0x08, NULL, HFILL } },\n    { &hf_code_rval,\n      { \"Rval\", \"rpcap.opcode.rval\", FT_UINT16, BASE_HEX,\n        VALS(bpf_rval), 0x18, NULL, HFILL } },\n    { &hf_code_misc_op,\n      { \"Op\", \"rpcap.opcode.miscop\", FT_UINT16, BASE_HEX,\n        VALS(bpf_misc_op), 0xF8, NULL, HFILL } },\n    { &hf_jt,\n      { \"JT\", \"rpcap.jt\", FT_UINT8, BASE_DEC,\n        NULL, 0x0, NULL, HFILL } },\n    { &hf_jf,\n      { \"JF\", \"rpcap.jf\", FT_UINT8, BASE_DEC,\n        NULL, 0x0, NULL, HFILL } },\n    { &hf_instr_value,\n      { \"Instruction value\", \"rpcap.instr_value\", FT_UINT32, BASE_DEC,\n        NULL, 0x0, \"Instruction-Dependent value\", HFILL } },\n\n    /* Statistics reply */\n    { &hf_stats_reply,\n      { \"Statistics\", \"rpcap.stats_reply\", FT_NONE, BASE_NONE,\n        NULL, 0x0, \"Statistics reply data\", HFILL } },\n    { &hf_ifrecv,\n      { \"Received by kernel filter\", \"rpcap.ifrecv\", FT_UINT32, BASE_DEC,\n        NULL, 0x0, NULL, HFILL } },\n    { &hf_ifdrop,\n      { \"Dropped by network interface\", \"rpcap.ifdrop\", FT_UINT32, BASE_DEC,\n        NULL, 0x0, NULL, HFILL } },\n    { &hf_krnldrop,\n      { \"Dropped by kernel filter\", \"rpcap.krnldrop\", FT_UINT32, BASE_DEC,\n        NULL, 0x0, NULL, HFILL } },\n    { &hf_srvcapt,\n      { \"Captured by rpcapd\", \"rpcap.srvcapt\", FT_UINT32, BASE_DEC,\n        NULL, 0x0, \"Captured by RPCAP daemon\", HFILL } },\n\n    /* Find all devices reply */\n    { &hf_findalldevs_reply,\n      { \"Find all devices\", \"rpcap.findalldevs_reply\", FT_NONE, BASE_NONE,\n        NULL, 0x0, NULL, HFILL } },\n    { &hf_findalldevs_if,\n      { \"Interface\", \"rpcap.if\", FT_NONE, BASE_NONE,\n        NULL, 0x0, NULL, HFILL } },\n    { &hf_namelen,\n      { \"Name length\", \"rpcap.namelen\", FT_UINT16, BASE_DEC,\n        NULL, 0x0, NULL, HFILL } },\n    { &hf_desclen,\n      { \"Description length\", \"rpcap.desclen\", FT_UINT32, BASE_DEC,\n        NULL, 0x0, NULL, HFILL } },\n    { &hf_if_flags,\n      { \"Interface flags\", \"rpcap.if.flags\", FT_UINT32, BASE_DEC,\n        NULL, 0x0, NULL, HFILL } },\n    { &hf_naddr,\n      { \"Number of addresses\", \"rpcap.naddr\", FT_UINT32, BASE_DEC,\n        NULL, 0x0, NULL, HFILL } },\n    { &hf_if_name,\n      { \"Name\", \"rpcap.ifname\", FT_STRING, BASE_NONE,\n        NULL, 0x0, \"Interface name\", HFILL } },\n    { &hf_if_desc,\n      { \"Description\", \"rpcap.ifdesc\", FT_STRING, BASE_NONE,\n        NULL, 0x0, \"Interface description\", HFILL } },\n\n    /* Find all devices / Interface addresses */\n    { &hf_findalldevs_ifaddr,\n      { \"Interface address\", \"rpcap.ifaddr\", FT_NONE, BASE_NONE,\n        NULL, 0x0, NULL, HFILL } },\n    { &hf_if_addr,\n      { \"Address\", \"rpcap.addr\", FT_NONE, BASE_NONE,\n        NULL, 0x0, \"Network address\", HFILL } },\n    { &hf_if_netmask,\n      { \"Netmask\", \"rpcap.netmask\", FT_NONE, BASE_NONE,\n        NULL, 0x0, NULL, HFILL } },\n    { &hf_if_broadaddr,\n      { \"Broadcast\", \"rpcap.broadaddr\", FT_NONE, BASE_NONE,\n        NULL, 0x0, NULL, HFILL } },\n    { &hf_if_dstaddr,\n      { \"P2P destination address\", \"rpcap.dstaddr\", FT_NONE, BASE_NONE,\n        NULL, 0x0, NULL, HFILL } },\n    { &hf_if_af,\n      { \"Address family\", \"rpcap.if.af\", FT_UINT16, BASE_HEX,\n        VALS(address_family), 0x0, NULL, HFILL } },\n    { &hf_if_port,\n      { \"Port\", \"rpcap.if.port\", FT_UINT16, BASE_DEC,\n        NULL, 0x0, \"Port number\", HFILL } },\n    { &hf_if_ipv4,\n      { \"IPv4 address\", \"rpcap.if.ipv4\", FT_IPv4, BASE_NONE,\n        NULL, 0x0, NULL, HFILL } },\n    { &hf_if_flowinfo,\n      { \"Flow information\", \"rpcap.if.flowinfo\", FT_UINT32, BASE_HEX,\n        NULL, 0x0, NULL, HFILL } },\n    { &hf_if_ipv6,\n      { \"IPv6 address\", \"rpcap.if.ipv6\", FT_IPv6, BASE_NONE,\n        NULL, 0x0, NULL, HFILL } },\n    { &hf_if_scopeid,\n      { \"Scope ID\", \"rpcap.if.scopeid\", FT_UINT32, BASE_HEX,\n        NULL, 0x0, NULL, HFILL } },\n    { &hf_if_padding,\n      { \"Padding\", \"rpcap.if.padding\", FT_BYTES, BASE_NONE,\n        NULL, 0x0, NULL, HFILL } },\n    { &hf_if_unknown,\n      { \"Unknown address\", \"rpcap.if.unknown\", FT_BYTES, BASE_NONE,\n        NULL, 0x0, NULL, HFILL } },\n\n    /* Sampling request */\n    { &hf_sampling_request,\n      { \"Sampling\", \"rpcap.sampling_request\", FT_NONE, BASE_NONE,\n        NULL, 0x0, NULL, HFILL } },\n    { &hf_sampling_method,\n      { \"Method\", \"rpcap.sampling_method\", FT_UINT8, BASE_DEC,\n        VALS(sampling_method), 0x0, \"Sampling method\", HFILL } },\n    { &hf_sampling_dummy1,\n      { \"Dummy1\", \"rpcap.dummy\", FT_UINT8, BASE_DEC,\n        NULL, 0x0, NULL, HFILL } },\n    { &hf_sampling_dummy2,\n      { \"Dummy2\", \"rpcap.dummy\", FT_UINT16, BASE_DEC,\n        NULL, 0x0, NULL, HFILL } },\n    { &hf_sampling_value,\n      { \"Value\", \"rpcap.sampling_value\", FT_UINT32, BASE_DEC,\n        NULL, 0x0, NULL, HFILL } },\n  };\n\n  static int *ett[] = {\n    &ett_rpcap,\n    &ett_error,\n    &ett_packet,\n    &ett_auth_request,\n    &ett_auth_reply,\n    &ett_open_reply,\n    &ett_startcap_request,\n    &ett_startcap_reply,\n    &ett_startcap_flags,\n    &ett_filter,\n    &ett_filterbpf_insn,\n    &ett_filterbpf_insn_code,\n    &ett_stats_reply,\n    &ett_findalldevs_reply,\n    &ett_findalldevs_if,\n    &ett_findalldevs_ifaddr,\n    &ett_ifaddr,\n    &ett_sampling_request\n  };\n\n  static ei_register_info ei[] = {\n     { &ei_error, { \"rpcap.error.expert\", PI_SEQUENCE, PI_NOTE, \"Error\", EXPFILL }},\n     { &ei_if_unknown, { \"rpcap.if_unknown\", PI_SEQUENCE, PI_NOTE, \"Unknown address family\", EXPFILL }},\n     { &ei_no_more_data, { \"rpcap.no_more_data\", PI_MALFORMED, PI_ERROR, \"No more data in packet\", EXPFILL }},\n     { &ei_caplen_too_big, { \"rpcap.caplen_too_big\", PI_MALFORMED, PI_ERROR, \"Caplen is bigger than the remaining message length\", EXPFILL }},\n  };\n\n  module_t *rpcap_module;\n  expert_module_t* expert_rpcap;\n\n  proto_rpcap = proto_register_protocol (PNAME, PSNAME, PFNAME);\n  register_dissector (PFNAME, dissect_rpcap, proto_rpcap);\n  rpcap_tcp_handle = register_dissector(PFNAME \".tcp\", dissect_rpcap_tcp, proto_rpcap);\n  expert_rpcap = expert_register_protocol(proto_rpcap);\n  expert_register_field_array(expert_rpcap, ei, array_length(ei));\n\n  proto_register_field_array (proto_rpcap, hf, array_length (hf));\n  proto_register_subtree_array (ett, array_length (ett));\n\n  /* Register our configuration options */\n  rpcap_module = prefs_register_protocol (proto_rpcap, proto_reg_handoff_rpcap);\n\n  prefs_register_bool_preference (rpcap_module, \"desegment_pdus\",\n                                  \"Reassemble PDUs spanning multiple TCP segments\",\n                                  \"Whether the RPCAP dissector should reassemble PDUs\"\n                                  \" spanning multiple TCP segments.\"\n                                  \" To use this option, you must also enable \\\"Allow subdissectors\"\n                                  \" to reassemble TCP streams\\\" in the TCP protocol settings.\",\n                                  &rpcap_desegment);\n  prefs_register_bool_preference (rpcap_module, \"decode_content\",\n                                  \"Decode content according to link-layer type\",\n                                  \"Whether the packets should be decoded according to\"\n                                  \" the link-layer type.\",\n                                  &decode_content);\n  prefs_register_uint_preference (rpcap_module, \"linktype\",\n                                  \"Default link-layer type\",\n                                  \"Default link-layer type to use if an Open Reply packet\"\n                                  \" has not been captured.\",\n                                  10, &global_linktype);\n}\n\nvoid\nproto_reg_handoff_rpcap (void)\n{\n  static bool rpcap_prefs_initialized = false;\n\n  if (!rpcap_prefs_initialized) {\n    pcap_pktdata_handle = find_dissector_add_dependency(\"pcap_pktdata\", proto_rpcap);\n    rpcap_prefs_initialized = true;\n\n    heur_dissector_add (\"tcp\", dissect_rpcap_heur_tcp, \"RPCAP over TCP\", \"rpcap_tcp\", proto_rpcap, HEURISTIC_ENABLE);\n    heur_dissector_add (\"udp\", dissect_rpcap_heur_udp, \"RPCAP over UDP\", \"rpcap_udp\", proto_rpcap, HEURISTIC_ENABLE);\n  }\n\n  info_added = false;\n  linktype = global_linktype;\n}\n\n/*\n * Editor modelines  -  https://www.wireshark.org/tools/modelines.html\n *\n * Local Variables:\n * c-basic-offset: 2\n * tab-width: 8\n * indent-tabs-mode: nil\n * End:\n *\n * ex: set shiftwidth=2 tabstop=8 expandtab:\n * :indentSize=2:tabSize=8:noTabs=true:\n */\n", "patch": "@@ -838,6 +838,8 @@ dissect_rpcap_packet (tvbuff_t *tvb, packet_info *pinfo, proto_tree *top_tree,\n   tvbuff_t *new_tvb;\n   guint caplen, len, frame_no;\n   gint reported_length_remaining;\n+  struct eth_phdr eth;\n+  void *phdr;\n \n   ti = proto_tree_add_item (parent_tree, hf_packet, tvb, offset, 20, ENC_NA);\n   tree = proto_item_add_subtree (ti, ett_packet);\n@@ -874,7 +876,18 @@ dissect_rpcap_packet (tvbuff_t *tvb, packet_info *pinfo, proto_tree *top_tree,\n \n   new_tvb = tvb_new_subset (tvb, offset, caplen, len);\n   if (decode_content && linktype != WTAP_ENCAP_UNKNOWN) {\n-    dissector_try_uint(wtap_encap_dissector_table, linktype, new_tvb, pinfo, top_tree);\n+    switch (linktype) {\n+\n+    case WTAP_ENCAP_ETHERNET:\n+      eth.fcs_len = -1;    /* Unknown whether we have an FCS */\n+      phdr = &eth;\n+      break;\n+\n+    default:\n+      phdr = NULL;\n+      break;\n+    }\n+    dissector_try_uint_new(wtap_encap_dissector_table, linktype, new_tvb, pinfo, top_tree, TRUE, phdr);\n \n     if (!info_added) {\n       /* Only indicate when not added before */", "file_path": "files/2016_8\\62", "file_language": "c", "file_name": "epan/dissectors/packet-rpcap.c", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}], "outdated": 0}
