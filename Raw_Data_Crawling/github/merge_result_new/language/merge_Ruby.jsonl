{"index": 5, "cve_id": "CVE-2016-6319", "cwe_id": ["CWE-79"], "cve_language": "Ruby", "cve_description": "Cross-site scripting (XSS) vulnerability in app/helpers/form_helper.rb in Foreman before 1.12.2, as used by Remote Execution and possibly other plugins, allows remote attackers to inject arbitrary web script or HTML via the label parameter.", "cvss": "6.1", "publish_date": "August 19, 2016", "AV": "NETWORK", "AC": "LOW", "PR": "NONE", "UI": "REQUIRED", "S": "CHANGED", "C": "LOW", "I": "LOW", "A": "NONE", "commit_id": "0f35fe14acf0d0d3b55e9337bc5e2b9640ff2372", "commit_message": "Fixes #16024 - escape labels of form fields", "commit_date": "2016-08-10T10:26:59Z", "project": "theforeman/foreman", "url": "https://api.github.com/repos/theforeman/foreman/commits/0f35fe14acf0d0d3b55e9337bc5e2b9640ff2372", "html_url": "https://github.com/theforeman/foreman/commit/0f35fe14acf0d0d3b55e9337bc5e2b9640ff2372", "windows_before": "", "windows_after": "", "parents": [{"commit_id_before": "e2a57bfe537f7a5f1ef6aca7087df2f1fdea5905", "url_before": "https://api.github.com/repos/theforeman/foreman/commits/e2a57bfe537f7a5f1ef6aca7087df2f1fdea5905", "html_url_before": "https://github.com/theforeman/foreman/commit/e2a57bfe537f7a5f1ef6aca7087df2f1fdea5905"}], "details": [{"raw_url": "https://github.com/theforeman/foreman/raw/0f35fe14acf0d0d3b55e9337bc5e2b9640ff2372/app/helpers/form_helper.rb", "code": "module FormHelper\n  def text_f(f, attr, options = {})\n    field(f, attr, options) do\n      addClass options, \"form-control\"\n      options[:focus_on_load] ||= attr.to_s == 'name'\n      f.text_field attr, options\n    end\n  end\n\n  def textarea_f(f, attr, options = {})\n    field(f, attr, options) do\n      options[:rows] = line_count(f, attr) if options[:rows] == :auto\n      addClass options, \"form-control\"\n      f.text_area(attr, options)\n    end\n  end\n\n  def button_input_group(content, options = {}, glyph = nil)\n    options[:type] ||= 'button'\n    options[:herf] ||= '#'\n    options[:class] ||= 'btn btn-default'\n    content_tag :span, class: 'input-group-btn' do\n      content_tag :button, content, options  do\n        content_tag :span,content, :class => glyph\n      end\n    end\n  end\n\n  def password_f(f, attr, options = {})\n    unset_button = options.delete(:unset)\n    password_field_tag(:fakepassword, nil, :style => 'display: none') +\n        field(f, attr, options) do\n          options[:autocomplete]   ||= 'off'\n          options[:placeholder]    ||= password_placeholder(f.object, attr)\n          options[:disabled] = true if unset_button\n          addClass options, 'form-control'\n          pass = f.password_field(attr, options) +\n              '<span class=\"glyphicon glyphicon-warning-sign input-addon\"\n             title=\"'.html_safe + _('Caps lock ON') +\n              '\" style=\"display:none\"></span>'.html_safe\n          if unset_button\n            button = button_input_group '', {:id => 'disable-pass-btn', :onclick => \"toggle_input_group(this)\", :title => _(\"Change the password\")}, 'glyphicon glyphicon-pencil'\n            input_group pass, button\n          else\n            pass\n          end\n        end\n  end\n\n  def checkbox_f(f, attr, options = {}, checked_value = \"1\", unchecked_value = \"0\")\n    text = options.delete(:help_text)\n    inline = options.delete(:help_inline)\n    field(f, attr, options) do\n      help_inline = inline.blank? ? '' : content_tag(:span, inline, :class => \"help-inline\")\n      f.check_box(attr, options, checked_value, unchecked_value) + \" #{text} \" + help_inline.html_safe\n    end\n  end\n\n  def multiple_checkboxes(f, attr, klass, associations, options = {}, html_options = {})\n    if associations.count > 5\n      associated_obj = klass.send(ActiveModel::Naming.plural(associations.first))\n      selected_ids = associated_obj.select(\"#{associations.first.class.table_name}.id\").map(&:id)\n      multiple_selects(f, attr, associations, selected_ids, options, html_options)\n    else\n      field(f, attr, options) do\n        authorized_edit_habtm klass, associations, options[:prefix], html_options\n      end\n    end\n  end\n\n  # add hidden field for options[:disabled]\n  def multiple_selects(f, attr, associations, selected_ids, options = {}, html_options = {})\n    options.merge!(:size => \"col-md-10\")\n    authorized = AssociationAuthorizer.authorized_associations(associations).all\n\n    # select2.js breaks the multiselects disabled items location\n    # http://projects.theforeman.org/issues/12028\n    html_options[\"class\"] ||= \"\"\n    html_options[\"class\"] += \" without_select2\"\n    html_options[\"class\"].strip!\n\n    unauthorized = selected_ids.blank? ? [] : selected_ids - authorized.map(&:id)\n    field(f, attr, options) do\n      attr_ids = (attr.to_s.singularize+\"_ids\").to_sym\n      hidden_fields = ''\n      html_options[\"data-useds\"] ||= \"[]\"\n      JSON.parse(html_options[\"data-useds\"]).each do |disabled_value|\n        hidden_fields += f.hidden_field(attr_ids, :multiple => true, :value => disabled_value, :id=>'')\n      end\n      unauthorized.each do |unauthorized_value|\n        hidden_fields += f.hidden_field(attr_ids, :multiple => true, :value => unauthorized_value, :id=>'')\n      end\n      hidden_fields + f.collection_select(attr_ids, authorized.sort_by { |a| a.to_s },\n                                          :id, :to_label, options.merge(:selected => selected_ids),\n                                          html_options.merge(:multiple => true))\n    end\n  end\n\n  def line_count(f, attr)\n    rows = f.object.try(attr).to_s.lines.count rescue 1\n    rows == 0 ? 1 : rows\n  end\n\n  def radio_button_f(f, attr, options = {})\n    text = options.delete(:text)\n    value = options.delete(:value)\n    label_tag('', :class=>\"radio-inline\") do\n      f.radio_button(attr, value, options) + \" #{text} \"\n    end\n  end\n\n  def select_f(f, attr, array, id, method, select_options = {}, html_options = {})\n    array = array.to_a.dup\n    disable_button = select_options.delete(:disable_button)\n    include_blank = select_options.delete(:include_blank)\n    disable_button_enabled = select_options.delete(:disable_button_enabled)\n    user_set = !!select_options.delete(:user_set)\n\n    if include_blank\n      blank_value = include_blank.is_a?(TrueClass) ? nil : include_blank\n      blank_option = OpenStruct.new({id => '', method => blank_value })\n      # if the method is to_s, OpenStruct will respond with its own version.\n      # in this case, I need to undefine its own alias to to_s, and use the attribute\n      # that was defined in the struct.\n      blank_option.instance_eval('undef to_s') if method.to_s == 'to_s' || id.to_s == 'to_s'\n      array.insert(0, blank_option)\n    end\n\n    select_options[:disabled] = '' if select_options[:disabled] == include_blank\n    html_options.merge!(:disabled => true) if disable_button_enabled\n\n    html_options.merge!(:size => 'col-md-10') if html_options[:multiple]\n    field(f, attr, html_options) do\n      addClass html_options, \"form-control\"\n\n      collection_select = f.collection_select(attr, array, id, method, select_options, html_options)\n\n      if disable_button\n        button_part =\n            content_tag :span, class: 'input-group-btn' do\n              content_tag(:button, disable_button, :type => 'button', :href => '#',\n                          :name => 'is_overridden_btn',\n                          :onclick => \"disableButtonToggle(this)\",\n                          :class => 'btn btn-default btn-can-disable' + (disable_button_enabled ? ' active' : ''),\n                          :data => { :toggle => 'button', :explicit => user_set })\n            end\n\n        input_group collection_select, button_part\n      else\n        collection_select\n      end\n    end\n  end\n\n  def addClass(options = {}, new_class = '')\n    options[:class] = \"#{new_class} #{options[:class]}\"\n  end\n\n  def input_group(*controls)\n    content_tag :div, class: 'input-group' do\n      controls.map { |control_html| concat(control_html) }\n    end\n  end\n\n  def input_group_btn(*controls)\n    content_tag :span, class: 'input-group-btn' do\n      controls.join(' ').html_safe\n    end\n  end\n\n  def time_zone_select_f(f, attr, default_timezone, select_options = {}, html_options = {})\n    field(f, attr, html_options) do\n      addClass html_options, \"form-control\"\n      f.time_zone_select(attr, [default_timezone], select_options, html_options)\n    end\n  end\n\n  def selectable_f(f, attr, array, select_options = {}, html_options = {})\n    html_options.merge!(:size => 'col-md-10') if html_options[:multiple]\n    field(f, attr, html_options) do\n      addClass html_options, \"form-control\"\n      f.select attr, array, select_options, html_options\n    end\n  end\n\n  def file_field_f(f, attr, options = {})\n    field(f, attr, options) do\n      f.file_field attr, options\n    end\n  end\n\n  def autocomplete_f(f, attr, options = {})\n    field(f, attr, options) do\n      path = options.delete(:path) || send(\"#{f.object.class.pluralize.underscore}_path\") if options[:full_path].nil?\n      auto_complete_search(attr,\n                           f.object.send(attr).try(:squeeze, \" \"),\n                           options.merge(\n                               :placeholder => _(\"Filter\") + ' ...',\n                               :path        => path,\n                               :name        => \"#{f.object_name}[#{attr}]\"\n                           )\n      ).html_safe\n    end\n  end\n\n  def form_to_submit_id(f)\n    object = f.object.respond_to?(:to_model) ? f.object.to_model : f.object\n    key = if object.present?\n            object.persisted? ? :update : :create\n          else\n            :submit\n          end\n    model = if object.class.respond_to?(:humanize_class_name)\n              object.class.humanize_class_name.downcase\n            elsif object.class.respond_to?(:model_name)\n              object.class.model_name.human.downcase\n            else\n              f.object_name.to_s\n            end.gsub(/\\W+/, '_')\n    \"aid_#{key}_#{model}\"\n  end\n\n  def submit_or_cancel(f, overwrite = false, args = { })\n    args[:cancel_path] ||= send(\"#{controller_name}_path\")\n    content_tag(:div, :class => \"clearfix\") do\n      content_tag(:div, :class => \"form-actions\") do\n        text    = overwrite ? _(\"Overwrite\") : _(\"Submit\")\n        options = {}\n        options[:class] = \"btn btn-#{overwrite ? 'danger' : 'primary'} remove_form_templates\"\n        options.merge! :'data-id' => form_to_submit_id(f) unless options.has_key?(:'data-id')\n        link_to(_(\"Cancel\"), args[:cancel_path], :class => \"btn btn-default\") + \" \" + f.submit(text, options)\n      end\n    end\n  end\n\n  def add_help_to_label(size_class, label, help_inline)\n    label.html_safe +\n        content_tag(:div, :class => size_class) do\n          yield\n        end.html_safe + help_inline.html_safe\n  end\n\n  def is_required?(f, attr)\n    return false unless f && f.object.class.respond_to?(:validators_on)\n    f.object.class.validators_on(attr).any? do |validator|\n      options = validator.options.keys.map(&:to_s)\n      validator.is_a?(ActiveModel::Validations::PresenceValidator) && !options.include?('if') && !options.include?('unless')\n    end\n  end\n\n  def form_for(record_or_name_or_array, *args, &proc)\n    if args.last.is_a?(Hash)\n      args.last[:html] = {:class=>\"form-horizontal well\"}.merge(args.last[:html]||{})\n    else\n      args << {:html=>{:class=>\"form-horizontal well\"}}\n    end\n    super record_or_name_or_array, *args, &proc\n  end\n\n  def number_f(f, attr, options = {})\n    field(f, attr, options) do\n      addClass options, \"form-control\"\n      f.number_field attr, options\n    end\n  end\n\n  def help_inline(inline, error)\n    help_inline = error.empty? ? inline : content_tag(:span, error.to_sentence.html_safe, :class => 'error-message')\n    case help_inline\n      when blank?\n        \"\"\n      when :indicator\n        content_tag(:span, content_tag(:div, '', :class => 'hide spinner spinner-xs'),\n                    :class => 'help-block').html_safe\n      else\n        content_tag(:span, help_inline, :class => \"help-block help-inline\")\n    end\n  end\n\n  def add_label options, f, attr\n    label_size = options.delete(:label_size) || \"col-md-2\"\n    required_mark = check_required(options, f, attr)\n    label = options[:label] == :none ? '' : options.delete(:label)\n    label ||= ((clazz = f.object.class).respond_to?(:gettext_translation_for_attribute_name) &&\n        s_(clazz.gettext_translation_for_attribute_name attr)) if f\n    label = label.present? ? label_tag(attr, \"#{label}#{required_mark}\", :class => label_size + \" control-label\") : ''\n    label\n  end\n\n  def check_required options, f, attr\n    required = options.delete(:required) # we don't want to use html5 required attr so we delete the option\n    return ' *' if required.nil? ? is_required?(f, attr) : required\n  end\n\n  def blank_or_inherit_f(f, attr)\n    return true unless f.object.respond_to?(:parent_id) && f.object.parent_id\n    inherited_value   = f.object.send(attr).try(:name_method)\n    inherited_value ||= _(\"no value\")\n    _(\"Inherit parent (%s)\") % inherited_value\n  end\n\n  def link_to_remove_fields(name, f, options = {})\n    f.hidden_field(:_destroy) + link_to_function(icon_text('close', name, :kind => 'pficon'), \"remove_fields(this)\", options.merge(:title => _(\"Remove Parameter\")))\n  end\n\n  # Creates a link to a javascript function that creates field entries for the association on the web page\n  # +name+       : String containing links's text\n  # +f+          : FormBuiler object\n  # +association : The field are created to allow entry into this association\n  # +partial+    : String containing an optional partial into which we render\n  def link_to_add_fields(name, f, association, partial = nil, options = {})\n    new_object = f.object.class.reflect_on_association(association).klass.new\n    fields = f.fields_for(association, new_object, :child_index => \"new_#{association}\") do |builder|\n      render((partial.nil? ? association.to_s.singularize + \"_fields\" : partial), :f => builder)\n    end\n    options[:class] = \"btn btn-primary #{options[:class]}\"\n    link_to_function(name, (\"add_fields('#{options[:target]}', '#{association}', '#{escape_javascript(fields)}')\").html_safe, options)\n  end\n\n  def field(f, attr, options = {})\n    table_field = options.delete(:table_field)\n    error       = options.delete(:error) || f.object.errors[attr] if f && f.object.respond_to?(:errors)\n    help_inline = help_inline(options.delete(:help_inline), error)\n    size_class  = options.delete(:size) || \"col-md-4\"\n    wrapper_class = options.delete(:wrapper_class) || \"form-group\"\n\n    label = options[:no_label] ? \"\" : add_label(options, f, attr)\n\n    if table_field\n      add_help_to_label(size_class, label, help_inline) do\n        yield\n      end.html_safe\n    else\n      help_block = content_tag(:span, options.delete(:help_block), :class => \"help-block\")\n\n      content_tag(:div, :class => \"clearfix\") do\n        content_tag(:div, :class => \"#{wrapper_class} #{error.empty? ? '' : 'has-error'}\",\n                    :id => options.delete(:control_group_id)) do\n          input = capture do\n            if options[:fullscreen]\n              content_tag(:div, yield.html_safe + fullscreen_input, :class => \"input-group\")\n            else\n              yield.html_safe\n            end\n          end\n          add_help_to_label(size_class, label, help_inline) do\n            input + help_block.html_safe\n          end\n        end.html_safe\n      end\n    end\n  end\nend\n", "code_before": "module FormHelper\n  def text_f(f, attr, options = {})\n    field(f, attr, options) do\n      addClass options, \"form-control\"\n      if attr.to_s == 'name'\n        options[:focus_on_load] ||= true\n        options[:autocomplete] ||= \"section-#{f.object_name} name\"\n      end\n      f.text_field attr, options\n    end\n  end\n\n  def textarea_f(f, attr, options = {})\n    field(f, attr, options) do\n      options[:rows] = line_count(f, attr) if options[:rows] == :auto\n      addClass options, \"form-control\"\n      f.text_area(attr, options)\n    end\n  end\n\n  def password_f(f, attr, options = {})\n    unset_button = options.delete(:unset)\n    value = f.object[attr] if options.delete(:keep_value)\n    password_field_tag(:fakepassword, value, :style => 'display: none', :autocomplete => 'new-password-fake') +\n        field(f, attr, options) do\n          options[:autocomplete]   ||= 'new-password'\n          options[:placeholder]    ||= password_placeholder(f.object, attr)\n          options[:disabled] = true if unset_button\n          options[:value] = value if value.present?\n          addClass options, 'form-control'\n          pass = f.password_field(attr, options) +\n              '<span class=\"glyphicon glyphicon-warning-sign input-addon\"\n             title=\"'.html_safe + _('Caps lock ON') +\n              '\" style=\"display:none\"></span>'.html_safe\n          if unset_button\n            button = link_to_function(icon_text(\"edit\", \"\", :kind => \"pficon\"), 'toggle_input_group(this)', {:id => 'disable-pass-btn', :class => 'btn btn-default', :title => _(\"Change the password\")})\n            input_group(pass, input_group_btn(button))\n          else\n            pass\n          end\n        end\n  end\n\n  def checkbox_f(f, attr, options = {}, checked_value = \"1\", unchecked_value = \"0\")\n    text = options.delete(:help_text)\n    inline = options.delete(:help_inline)\n    field(f, attr, options) do\n      help_inline = inline.blank? ? '' : content_tag(:span, inline, :class => \"help-inline\")\n      f.check_box(attr, options, checked_value, unchecked_value) + \" #{text} \" + help_inline.html_safe\n    end\n  end\n\n  def multiple_checkboxes(f, attr, klass, associations, options = {}, html_options = {})\n    association_name = attr || ActiveModel::Naming.plural(associations)\n    associated_obj = klass.send(association_name)\n    selected_ids = options.delete(:selected_ids) || associated_obj.map(&:id)\n    multiple_selects(f, attr, associations, selected_ids, options, html_options)\n  end\n\n  # add hidden field for options[:disabled]\n  def multiple_selects(f, attr, associations, selected_ids, options = {}, html_options = {})\n    options[:size] = \"col-md-10\"\n    case attr\n      when :organizations\n        klass = Organization\n      when :locations\n        klass = Location\n      else\n        klass = nil\n    end\n    authorized = AssociationAuthorizer.authorized_associations(associations.reorder(nil), klass).all\n\n    # select2.js breaks the multiselects disabled items location\n    # http://projects.theforeman.org/issues/12028\n    html_options[\"class\"] ||= \"\"\n    html_options[\"class\"] += \" without_select2\"\n    html_options[\"class\"].strip!\n\n    unauthorized = selected_ids.blank? ? [] : selected_ids - authorized.map(&:id)\n    field(f, attr, options) do\n      attr_ids = attr.to_s\n      attr_ids = (attr_ids.singularize + '_ids').to_sym unless attr_ids.end_with?('_ids')\n      hidden_fields = ''\n      html_options[\"data-useds\"] ||= \"[]\"\n      JSON.parse(html_options[\"data-useds\"]).each do |disabled_value|\n        hidden_fields += f.hidden_field(attr_ids, :multiple => true, :value => disabled_value, :id => '')\n      end\n      unauthorized.each do |unauthorized_value|\n        hidden_fields += f.hidden_field(attr_ids, :multiple => true, :value => unauthorized_value, :id => '')\n      end\n      hidden_fields + f.collection_select(attr_ids, authorized.sort_by { |a| a.to_s },\n        :id, options.delete(:object_label_method) || :to_label, options.merge(:selected => selected_ids),\n        html_options.merge(:multiple => true))\n    end\n  end\n\n  def line_count(f, attr)\n    rows = f.object.try(attr).to_s.lines.count rescue 1\n    (rows == 0) ? 1 : rows\n  end\n\n  def radio_button_f(f, attr, options = {})\n    text = options.delete(:text)\n    value = options.delete(:value)\n    label_tag('', :class => \"radio-inline\") do\n      f.radio_button(attr, value, options) + \" #{text} \"\n    end\n  end\n\n  def select_f(f, attr, array, id, method, select_options = {}, html_options = {})\n    array = array.to_a.dup\n    disable_button = select_options.delete(:disable_button)\n    include_blank = select_options.delete(:include_blank)\n    disable_button_enabled = select_options.delete(:disable_button_enabled)\n    user_set = !!select_options.delete(:user_set)\n\n    if include_blank\n      blank_value = include_blank.is_a?(TrueClass) ? nil : include_blank\n      blank_option = OpenStruct.new({id => '', method => blank_value })\n      # if the method is to_s, OpenStruct will respond with its own version.\n      # in this case, I need to undefine its own alias to to_s, and use the attribute\n      # that was defined in the struct.\n      blank_option.instance_eval('undef to_s', __FILE__, __LINE__) if method.to_s == 'to_s' || id.to_s == 'to_s'\n      array.insert(0, blank_option)\n      html_options['data-placeholder'] = blank_value || html_options[:placeholder]\n    elsif html_options[:placeholder]\n      html_options['data-placeholder'] = html_options[:placeholder]\n    end\n\n    select_options[:disabled] = '' if select_options[:disabled] == include_blank\n    html_options[:disabled] = true if disable_button_enabled\n\n    html_options[:size] = 'col-md-10' if html_options[:multiple]\n    field(f, attr, html_options) do\n      addClass html_options, \"form-control\"\n      if include_blank.is_a?(TrueClass)\n        addClass html_options, \"include_blank\"\n      end\n      collection_select = f.collection_select(attr, array, id, method, select_options, html_options)\n\n      if disable_button\n        button_part =\n          content_tag :span, class: 'input-group-btn' do\n            content_tag(:button, disable_button, :type => 'button', :href => '#',\n                        :name => 'is_overridden_btn',\n                        :onclick => \"disableButtonToggle(this)\",\n                        :class => 'btn btn-default btn-can-disable' + (disable_button_enabled ? ' active' : ''),\n                        :data => { :toggle => 'button', :explicit => user_set })\n          end\n\n        input_group collection_select, button_part\n      else\n        collection_select\n      end\n    end\n  end\n\n  def addClass(options = {}, new_class = '')\n    options[:class] = \"#{new_class} #{options[:class]}\"\n  end\n\n  def input_group(*controls)\n    content_tag :div, class: 'input-group' do\n      controls.map { |control_html| concat(control_html) }\n    end\n  end\n\n  def input_group_btn(*controls)\n    content_tag :span, class: 'input-group-btn' do\n      controls.join(' ').html_safe\n    end\n  end\n\n  def time_zone_select_f(f, attr, default_timezone, select_options = {}, html_options = {})\n    field(f, attr, html_options) do\n      addClass html_options, \"form-control\"\n      f.time_zone_select(attr, [default_timezone], select_options, html_options)\n    end\n  end\n\n  def selectable_f(f, attr, array, select_options = {}, html_options = {})\n    html_options[:size] = 'col-md-10' if html_options[:multiple]\n    field(f, attr, html_options) do\n      form_select_f(f, attr, array, select_options, html_options)\n    end\n  end\n\n  def selectable_f_inline(f, attr, array, select_options = {}, html_options = {})\n    html_options[:size] = 'col-md-10' if html_options[:multiple]\n    form_select_f(f, attr, array, select_options, html_options)\n  end\n\n  def spinner_button_f(f, caption, action, html_options = {})\n    html_options[:class] ||= 'btn-default'\n    html_options[:class] = \"btn btn-spinner #{html_options[:class]}\"\n    caption = '<div class=\"caption\">' + caption + '</div>'\n    caption += hidden_spinner('', :id => html_options[:spinner_id], :class => html_options[:spinner_class])\n    link_to_function(caption.html_safe, action, html_options)\n  end\n\n  def file_field_f(f, attr, options = {})\n    if options[:file_name]\n      html =  content_tag(:b) { options.delete(:file_name) }\n      html += content_tag(:hr)\n      html += content_tag(:div, :style => \"margin-bottom: 10px\") { _(\"Choose a new file:\") }\n    end\n    field(f, attr, options) do\n      (html || \" \") + (f.file_field attr, options)\n    end\n  end\n\n  # Returns an AutoComplete React input tailored for accessing a specified attribute (identified by +attr+) on an object\n  # assigned to the form (identified by +f+). Additional properties on the input tag can be passed as a\n  # hash with +options+. These options will be tagged onto the React Component as an props as in the example\n  # shown.\n  #\n  # ==== Options\n  # * Creates standard React props for the component.\n  # * <tt>:url</tt> - path where the search results should be fetched from.\n  # * <tt>:disabled</tt> - If set to true, the user will not be able to use this input.\n  # * <tt>:search_query</tt> - Default search query.\n  #\n  # ==== Examples\n  #   form_for(@user) do |f|\n  #     autocomplete_f(f, :country, url: api_countries_path, search_query: 'Czech')\n  #   end\n  #   # => <AutoComplete id=\"user_country\" name=\"user[country]\" url=\"/api/countries/auto_complete_country\" searchQuery=\"Czech\" />\n  def autocomplete_f(f, attr, options = {})\n    options[:data] = {\n      autocomplete: {\n        searchQuery: options[:search_query] || f.object&.search || '',\n        url: options[:full_path] || (options[:path] || send(\"#{auto_complete_controller_name}_path\")) + \"/auto_complete_#{attr}\",\n      },\n      controller: options[:path] || auto_complete_controller_name,\n      disabled: options[:disabled] || false,\n    }\n    options[:onSearch] = nil\n    react_form_input('autocomplete', f, attr, options)\n  end\n\n  def byte_size_f(f, attr, options = {})\n    react_form_input('memory', f, attr, options)\n  end\n\n  def counter_f(f, attr, options = {})\n    react_form_input('counter', f, attr, options)\n  end\n\n  def submit_or_cancel(f, overwrite = false, args = { })\n    args[:cancel_path] ||= resource_path(controller_name)\n    cancel_btn = args[:react_cancel_button] ? react_cancel_button(args) : link_to(_(\"Cancel\"), args[:cancel_path], :class => \"btn btn-default\")\n    content_tag(:div, :class => \"clearfix\") do\n      content_tag(:div, :class => \"form-actions\") do\n        text    = overwrite ? _(\"Overwrite\") : args.delete(:button_text) || _(\"Submit\")\n        options = options_for_submit_or_cancel(f, overwrite, args)\n        f.submit(text, options) + \" \" + cancel_btn\n      end\n    end\n  end\n\n  def react_cancel_button(args)\n    react_component('RedirectCancelButton', { :cancelPath => args[:cancel_path] })\n  end\n\n  def options_for_submit_or_cancel(f, overwrite, args)\n    options = {}\n    options[:disabled] = true if args[:disabled]\n    options[:class] = \"btn btn-#{overwrite ? 'danger' : 'primary'} remove_form_templates\"\n    options[:data] = args[:data] if args.key?(:data)\n    options\n  end\n\n  def add_help_to_label(size_class, label, help_inline, &block)\n    label.html_safe +\n        content_tag(:div, :class => size_class, &block).html_safe + help_inline.html_safe\n  end\n\n  def is_required?(f, attr)\n    return false unless f && f.object.class.respond_to?(:validators_on)\n    f.object.class.validators_on(attr).any? do |validator|\n      options = validator.options.keys.map(&:to_s)\n      validator.is_a?(ActiveModel::Validations::PresenceValidator) && !options.include?('if') && !options.include?('unless')\n    end\n  end\n\n  def form_for(record_or_name_or_array, *args, &proc)\n    if args.last.is_a?(Hash)\n      args.last[:html] = {:class => \"form-horizontal well\"}.merge(args.last[:html] || {})\n    else\n      args << {:html => {:class => \"form-horizontal well\"}}\n    end\n    super record_or_name_or_array, *args, &proc\n  end\n\n  def number_f(f, attr, options = {})\n    field(f, attr, options) do\n      addClass options, \"form-control\"\n      f.number_field attr, options\n    end\n  end\n\n  def help_inline(inline, error)\n    help_inline = error.empty? ? inline : content_tag(:span, error.to_sentence, :class => 'error-message')\n    case help_inline\n      when blank?\n        \"\"\n      when :indicator\n        content_tag(:span, content_tag(:div, '', :class => 'hide spinner spinner-xs'),\n          :class => 'help-block').html_safe\n      else\n        content_tag(:span, help_inline, :class => \"help-block help-inline\")\n    end\n  end\n\n  def add_label(options, f, attr)\n    return ''.html_safe if options[:label] == :none\n\n    label_size = options.delete(:label_size) || \"col-md-2\"\n    required_mark = check_required(options, f, attr)\n    label = ''.html_safe + options.delete(:label)\n    label = get_attr_label(f, attr).to_s.html_safe if label.empty?\n\n    if options[:label_help].present?\n      label += ' '.html_safe + popover(\"\", options[:label_help], options[:label_help_options] || {})\n    end\n    label.present? ? label_tag(attr, label.to_s + required_mark.to_s, :class => label_size + \" control-label\") : ''\n  end\n\n  def check_required(options, f, attr)\n    required = options.delete(:required) # we don't want to use html5 required attr so we delete the option\n    return ' *'.html_safe if required.nil? ? is_required?(f, attr) : required\n  end\n\n  def blank_or_inherit_f(f, attr, blank_value: _(\"no value\"))\n    return true unless f.object.respond_to?(:parent_id) && f.object.parent_id\n    inherited_value   = f.object.send(attr)\n    inherited_value   = inherited_value.name_method if inherited_value.present? && inherited_value.respond_to?(:name_method)\n    inherited_value ||= blank_value\n    _(\"Inherit parent (%s)\") % inherited_value\n  end\n\n  def link_to_remove_fields(name, f, options = {})\n    options[:title] ||= _(\"Remove Parameter\")\n    method_name = f.object.respond_to?(:_destroy) ? :_destroy : :_delete\n    f.hidden_field(method_name) + link_to_function(icon_text('remove', name, :kind => 'pficon'), \"remove_fields(this)\", options)\n  end\n\n  # Creates a link to a javascript function that creates field entries for the association on the web page\n  # +name+       : String containing links's text\n  # +f+          : FormBuiler object\n  # +association : The field are created to allow entry into this association\n  # +partial+    : String containing an optional partial into which we render\n  def link_to_add_fields(name, f, association, partial = nil, options = {})\n    new_object = options.delete(:object) || f.object.class.reflect_on_association(association).klass.new\n    locals_option = options.delete(:locals) || {}\n    fields = f.fields_for(association, new_object, :child_index => \"new_#{association}\") do |builder|\n      render((partial.nil? ? association.to_s.singularize + \"_fields\" : partial),\n        { :f => builder }.merge(locals_option))\n    end\n    options[:class] = link_to_add_fields_classes(options)\n    link_to_function(name, \"add_fields('#{options[:target]}', '#{association}', '#{escape_javascript(fields)}', '#{options[:direction] || 'append'}')\".html_safe, options)\n  end\n\n  def field(f, attr, options = {}, &block)\n    table_field = options.delete(:table_field)\n    error       = options.delete(:error) || get_attr_error(f, attr)\n    help_inline = help_inline(options.delete(:help_inline), error)\n    help_inline += options[:help_inline_permanent] unless options[:help_inline_permanent].nil?\n    size_class = options.delete(:size) || \"col-md-4\"\n    wrapper_class = options.delete(:wrapper_class) || \"form-group\"\n\n    label = options[:no_label] ? \"\" : add_label(options, f, attr)\n\n    if table_field\n      add_help_to_label(size_class, label, help_inline, &block).html_safe\n    else\n      help_block = content_tag(:span, options.delete(:help_block), :class => \"help-block\")\n\n      content_tag(:div, :class => \"clearfix\") do\n        content_tag(:div, :class => \"#{wrapper_class} #{error.empty? ? '' : 'has-error'}\",\n                    :id => options.delete(:control_group_id)) do\n          input = capture do\n            if (group_btn = options.delete(:input_group_btn))\n              input_group(yield.html_safe, input_group_btn(group_btn))\n            else\n              yield.html_safe\n            end\n          end\n          add_help_to_label(size_class, label, help_inline) do\n            input + help_block.html_safe\n          end\n        end.html_safe\n      end\n    end\n  end\n\n  def date_local_f(f, attr, options = {})\n    react_form_input('date', f, attr, options)\n  end\n\n  def datetime_local_f(f, attr, options = {})\n    react_form_input('dateTime', f, attr, options)\n  end\n\n  def orderable_select_f(f, attr, choices, select_options = {}, html_options = {})\n    options = choices.collect { |choice| { label: choice[0], value: choice[1] } } if choices.is_a?(Array)\n    options = choices.collect { |(key, val)| { label: val, value: key } } if choices.is_a?(Hash)\n    input_props = select_options.merge(options: options)\n    react_form_input('orderableSelect', f, attr, html_options.merge(input_props: input_props))\n  end\n\n  def react_form_input(type, f, attr, options = {})\n    options[:label] ||= get_attr_label(f, attr)\n    options[:error] ||= get_attr_error(f, attr)\n    options[:error] = options[:error]&.to_sentence\n    options[:required] = is_required?(f, attr) unless options.key?(:required)\n\n    Tags::ReactInput.new(f.object_name, attr, self, options.merge(type: type, object: f.object)).render\n  end\n\n  def advanced_switch_f(default_text, switch_text)\n    content_tag :div, :class => 'form-group' do\n      content_tag(:div, '', :class => 'col-md-2 control-label') +\n        content_tag(:div, :class => 'col-md-4') do\n          content_tag(:i, '', :class => 'fa fa-angle-right') + ' ' +\n            link_to(default_text, '#', :class => 'advanced_fields_switch', :'data-alternative-label' => switch_text)\n        end\n    end\n  end\n\n  private\n\n  def get_attr_label(f, attr)\n    if f.try(:object) && (clazz = f.object.class).respond_to?(:gettext_translation_for_attribute_name)\n      s_(clazz.gettext_translation_for_attribute_name(attr)).titleize\n    end\n  end\n\n  def get_attr_error(f, attr)\n    f.object.errors[attr] if f&.object.respond_to?(:errors)\n  end\n\n  def form_select_f(f, attr, array, select_options = {}, html_options = {})\n    addClass html_options, \"form-control\"\n    include_blank = select_options[:include_blank]\n    if include_blank\n      addClass html_options, \"include_blank\"\n      blank_value = include_blank.is_a?(TrueClass) ? nil : include_blank\n      if array.kind_of?(Array) # incase array is options_for_select\n        array = array.to_a.dup\n        blank_option = [blank_value, nil]\n        array.insert(0, blank_option)\n        select_options.delete(:include_blank)\n      end\n      html_options['data-placeholder'] = blank_value || html_options[:placeholder]\n    elsif html_options[:placeholder]\n      html_options['data-placeholder'] = html_options[:placeholder]\n    end\n    f.select attr, array, select_options, html_options\n  end\n\n  def link_to_add_fields_classes(options = {})\n    classes = \"btn btn-default #{options[:class]}\"\n    classes << ' btn-primary' if options.fetch(:primary_button, true)\n    classes\n  end\nend\n", "patch": "@@ -283,7 +283,7 @@ def add_label options, f, attr\n     label = options[:label] == :none ? '' : options.delete(:label)\n     label ||= ((clazz = f.object.class).respond_to?(:gettext_translation_for_attribute_name) &&\n         s_(clazz.gettext_translation_for_attribute_name attr)) if f\n-    label = label.present? ? label_tag(attr, \"#{label}#{required_mark}\".html_safe, :class => label_size + \" control-label\") : ''\n+    label = label.present? ? label_tag(attr, \"#{label}#{required_mark}\", :class => label_size + \" control-label\") : ''\n     label\n   end\n ", "file_path": "files/2016_8\\32", "file_language": "rb", "file_name": "app/helpers/form_helper.rb", "outdated_file_modify": null, "outdated_file_before": null, "outdated_file_after": null}], "outdated": 0}
