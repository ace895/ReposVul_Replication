{"repo_after": "10ef1dca63d62433fda13309b4a228782db823f7", "repo_before": "e6399f5a470f50285cef173e438638ae5bc741e0", "functions_before": [{"name": "gdImageCreateFromTgaCtx", "content": "BGD_DECLARE(gdImagePtr) gdImageCreateFromTgaCtx(gdIOCtx* ctx)\n{\n\tint bitmap_caret = 0;\n\toTga *tga = NULL;\n\t/*\tint pixel_block_size = 0;\n\t\tint image_block_size = 0; */\n\tvolatile gdImagePtr image = NULL;\n\tint x = 0;\n\tint y = 0;\n\n\ttga = (oTga *) gdMalloc(sizeof(oTga));\n\tif (!tga) {\n\t\treturn NULL;\n\t}\n\n\ttga->bitmap = NULL;\n\ttga->ident = NULL;\n\n\tif (read_header_tga(ctx, tga) < 0) {\n\t\tfree_tga(tga);\n\t\treturn NULL;\n\t}\n\n\t/*TODO: Will this be used?\n\t\tpixel_block_size = tga->bits / 8;\n\t\timage_block_size = (tga->width * tga->height) * pixel_block_size;\n\t*/\n\n\tif (read_image_tga(ctx, tga) < 0) {\n\t\tfree_tga(tga);\n\t\treturn NULL;\n\t}\n\n\timage = gdImageCreateTrueColor((int)tga->width, (int)tga->height );\n\n\tif (image == 0) {\n\t\tfree_tga( tga );\n\t\treturn NULL;\n\t}\n\n\t/*!\t\\brief Populate GD image object\n\t *  Copy the pixel data from our tga bitmap buffer into the GD image\n\t *  Disable blending and save the alpha channel per default\n\t */\n\tif (tga->alphabits) {\n\t\tgdImageAlphaBlending(image, 0);\n\t\tgdImageSaveAlpha(image, 1);\n\t}\n\n\t/* TODO: use alphabits as soon as we support 24bit and other alpha bps (ie != 8bits) */\n\tfor (y = 0; y < tga->height; y++) {\n\t\tregister int *tpix = image->tpixels[y];\n\t\tfor ( x = 0; x < tga->width; x++, tpix++) {\n\t\t\tif (tga->bits == TGA_BPP_24) {\n\t\t\t\t*tpix = gdTrueColor(tga->bitmap[bitmap_caret + 2], tga->bitmap[bitmap_caret + 1], tga->bitmap[bitmap_caret]);\n\t\t\t\tbitmap_caret += 3;\n\t\t\t} else if (tga->bits == TGA_BPP_32 || tga->alphabits) {\n\t\t\t\tregister int a = tga->bitmap[bitmap_caret + 3];\n\n\t\t\t\t*tpix = gdTrueColorAlpha(tga->bitmap[bitmap_caret + 2], tga->bitmap[bitmap_caret + 1], tga->bitmap[bitmap_caret], gdAlphaMax - (a >> 1));\n\t\t\t\tbitmap_caret += 4;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (tga->flipv && tga->fliph) {\n\t\tgdImageFlipBoth(image);\n\t} else if (tga->flipv) {\n\t\tgdImageFlipVertical(image);\n\t} else if (tga->fliph) {\n\t\tgdImageFlipHorizontal(image);\n\t}\n\n\tfree_tga(tga);\n\n\treturn image;\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos_before\\2016_8\\e6399f5a470f50285cef173e438638ae5bc741e0_before\\libgd-e6399f5a470f50285cef173e438638ae5bc741e0\\src\\gd_tga.c", "callees": [], "callers": []}, {"name": "read_header_tga", "content": "int read_header_tga(gdIOCtx *ctx, oTga *tga)\n{\n\n\tunsigned char header[18];\n\n\tif (gdGetBuf(header, sizeof(header), ctx) < 18) {\n\t\tgd_error(\"fail to read header\");\n\t\treturn -1;\n\t}\n\n\ttga->identsize = header[0];\n\ttga->colormaptype = header[1];\n\ttga->imagetype = header[2];\n\ttga->colormapstart = header[3] + (header[4] << 8);\n\ttga->colormaplength = header[5] + (header[6] << 8);\n\ttga->colormapbits = header[7];\n\ttga->xstart = header[8] + (header[9] << 8);\n\ttga->ystart = header[10] + (header[11] << 8);\n\ttga->width = header[12] + (header[13] << 8);\n\ttga->height = header[14] + (header[15] << 8);\n\ttga->bits = header[16];\n\ttga->alphabits = header[17] & 0x0f;\n\ttga->fliph = (header[17] & 0x10) ? 1 : 0;\n\ttga->flipv = (header[17] & 0x20) ? 0 : 1;\n\n#if DEBUG\n\tprintf(\"format bps: %i\\n\", tga->bits);\n\tprintf(\"flip h/v: %i / %i\\n\", tga->fliph, tga->flipv);\n\tprintf(\"alpha: %i\\n\", tga->alphabits);\n\tprintf(\"wxh: %i %i\\n\", tga->width, tga->height);\n#endif\n\n\tswitch(tga->bits) {\n\tcase 8:\n\tcase 16:\n\tcase 24:\n\tcase 32:\n\t\tbreak;\n\tdefault:\n\t\tgd_error(\"bps %i not supported\", tga->bits);\n\t\treturn -1;\n\t\tbreak;\n\t}\n\n\ttga->ident = NULL;\n\n\tif (tga->identsize > 0) {\n\t\ttga->ident = (char *) gdMalloc(tga->identsize * sizeof(char));\n\t\tif(tga->ident == NULL) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tgdGetBuf(tga->ident, tga->identsize, ctx);\n\t}\n\n\treturn 1;\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos_before\\2016_8\\e6399f5a470f50285cef173e438638ae5bc741e0_before\\libgd-e6399f5a470f50285cef173e438638ae5bc741e0\\src\\gd_tga.c", "callees": ["gdMalloc", "gdGetBuf", "gd_error", "printf"], "callers": []}], "functions_after": [{"name": "gdImageCreateFromTgaCtx", "content": "BGD_DECLARE(gdImagePtr) gdImageCreateFromTgaCtx(gdIOCtx* ctx)\n{\n\tint bitmap_caret = 0;\n\toTga *tga = NULL;\n\t/*\tint pixel_block_size = 0;\n\t\tint image_block_size = 0; */\n\tvolatile gdImagePtr image = NULL;\n\tint x = 0;\n\tint y = 0;\n\n\ttga = (oTga *) gdMalloc(sizeof(oTga));\n\tif (!tga) {\n\t\treturn NULL;\n\t}\n\n\ttga->bitmap = NULL;\n\ttga->ident = NULL;\n\n\tif (read_header_tga(ctx, tga) < 0) {\n\t\tfree_tga(tga);\n\t\treturn NULL;\n\t}\n\n\t/*TODO: Will this be used?\n\t\tpixel_block_size = tga->bits / 8;\n\t\timage_block_size = (tga->width * tga->height) * pixel_block_size;\n\t*/\n\n\tif (read_image_tga(ctx, tga) < 0) {\n\t\tfree_tga(tga);\n\t\treturn NULL;\n\t}\n\n\timage = gdImageCreateTrueColor((int)tga->width, (int)tga->height );\n\n\tif (image == 0) {\n\t\tfree_tga( tga );\n\t\treturn NULL;\n\t}\n\n\t/*!\t\\brief Populate GD image object\n\t *  Copy the pixel data from our tga bitmap buffer into the GD image\n\t *  Disable blending and save the alpha channel per default\n\t */\n\tif (tga->alphabits) {\n\t\tgdImageAlphaBlending(image, 0);\n\t\tgdImageSaveAlpha(image, 1);\n\t}\n\n\t/* TODO: use alphabits as soon as we support 24bit and other alpha bps (ie != 8bits) */\n\tfor (y = 0; y < tga->height; y++) {\n\t\tregister int *tpix = image->tpixels[y];\n\t\tfor ( x = 0; x < tga->width; x++, tpix++) {\n\t\t\tif (tga->bits == TGA_BPP_24) {\n\t\t\t\t*tpix = gdTrueColor(tga->bitmap[bitmap_caret + 2], tga->bitmap[bitmap_caret + 1], tga->bitmap[bitmap_caret]);\n\t\t\t\tbitmap_caret += 3;\n\t\t\t} else if (tga->bits == TGA_BPP_32 && tga->alphabits) {\n\t\t\t\tregister int a = tga->bitmap[bitmap_caret + 3];\n\n\t\t\t\t*tpix = gdTrueColorAlpha(tga->bitmap[bitmap_caret + 2], tga->bitmap[bitmap_caret + 1], tga->bitmap[bitmap_caret], gdAlphaMax - (a >> 1));\n\t\t\t\tbitmap_caret += 4;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (tga->flipv && tga->fliph) {\n\t\tgdImageFlipBoth(image);\n\t} else if (tga->flipv) {\n\t\tgdImageFlipVertical(image);\n\t} else if (tga->fliph) {\n\t\tgdImageFlipHorizontal(image);\n\t}\n\n\tfree_tga(tga);\n\n\treturn image;\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos\\2016_8\\10ef1dca63d62433fda13309b4a228782db823f7_after\\libgd-10ef1dca63d62433fda13309b4a228782db823f7\\src\\gd_tga.c", "callees": [], "callers": []}, {"name": "read_header_tga", "content": "int read_header_tga(gdIOCtx *ctx, oTga *tga)\n{\n\n\tunsigned char header[18];\n\n\tif (gdGetBuf(header, sizeof(header), ctx) < 18) {\n\t\tgd_error(\"fail to read header\");\n\t\treturn -1;\n\t}\n\n\ttga->identsize = header[0];\n\ttga->colormaptype = header[1];\n\ttga->imagetype = header[2];\n\ttga->colormapstart = header[3] + (header[4] << 8);\n\ttga->colormaplength = header[5] + (header[6] << 8);\n\ttga->colormapbits = header[7];\n\ttga->xstart = header[8] + (header[9] << 8);\n\ttga->ystart = header[10] + (header[11] << 8);\n\ttga->width = header[12] + (header[13] << 8);\n\ttga->height = header[14] + (header[15] << 8);\n\ttga->bits = header[16];\n\ttga->alphabits = header[17] & 0x0f;\n\ttga->fliph = (header[17] & 0x10) ? 1 : 0;\n\ttga->flipv = (header[17] & 0x20) ? 0 : 1;\n\n#if DEBUG\n\tprintf(\"format bps: %i\\n\", tga->bits);\n\tprintf(\"flip h/v: %i / %i\\n\", tga->fliph, tga->flipv);\n\tprintf(\"alpha: %i\\n\", tga->alphabits);\n\tprintf(\"wxh: %i %i\\n\", tga->width, tga->height);\n#endif\n\n\tif (!((tga->bits == TGA_BPP_24 && tga->alphabits == 0)\n\t\t|| (tga->bits == TGA_BPP_32 && tga->alphabits == 8)))\n\t{\n\t\tgd_error_ex(GD_WARNING, \"gd-tga: %u bits per pixel with %u alpha bits not supported\\n\",\n\t\t\ttga->bits, tga->alphabits);\n\t\treturn -1;\n\t}\n\n\ttga->ident = NULL;\n\n\tif (tga->identsize > 0) {\n\t\ttga->ident = (char *) gdMalloc(tga->identsize * sizeof(char));\n\t\tif(tga->ident == NULL) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tgdGetBuf(tga->ident, tga->identsize, ctx);\n\t}\n\n\treturn 1;\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos\\2016_8\\10ef1dca63d62433fda13309b4a228782db823f7_after\\libgd-10ef1dca63d62433fda13309b4a228782db823f7\\src\\gd_tga.c", "callees": ["gdGetBuf", "gd_error", "gdMalloc", "gd_error_ex", "printf"], "callers": []}], "callerTree_before": {"read_header_tga": ["gdMalloc", "gdGetBuf", "gd_error", "printf"]}, "calleeTree_before": {"gdGetBuf": ["read_header_tga"], "gd_error": ["read_header_tga"], "printf": ["read_header_tga"], "gdMalloc": ["read_header_tga"]}, "callerTree_after": {"read_header_tga": ["gdGetBuf", "gd_error", "gdMalloc", "gd_error_ex", "printf"]}, "calleeTree_after": {"gdGetBuf": ["read_header_tga"], "gd_error": ["read_header_tga"], "printf": ["read_header_tga"], "gd_error_ex": ["read_header_tga"], "gdMalloc": ["read_header_tga"]}}
{"repo_after": "cf0aa7751f6ef8445e9310a64b14dc81460ca156", "repo_before": "90a5ab519805acb6c5d1ae91d8e3f494ec179db4", "functions_before": [{"name": "dbd_db_login", "content": "int dbd_db_login(SV* dbh, imp_dbh_t* imp_dbh, char* dbname, char* user,\n\t\t char* password) {\n#ifdef dTHR\n  dTHR;\n#endif\n  dTHX; \n  D_imp_xxh(dbh);\n\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n\t\t  \"imp_dbh->connect: dsn = %s, uid = %s, pwd = %s\\n\",\n\t\t  dbname ? dbname : \"NULL\",\n\t\t  user ? user : \"NULL\",\n\t\t  password ? password : \"NULL\");\n\n  imp_dbh->stats.auto_reconnects_ok= 0;\n  imp_dbh->stats.auto_reconnects_failed= 0;\n  imp_dbh->bind_type_guessing= FALSE;\n  imp_dbh->bind_comment_placeholders= FALSE;\n  imp_dbh->has_transactions= TRUE;\n /* Safer we flip this to TRUE perl side if we detect a mod_perl env. */\n  imp_dbh->auto_reconnect = FALSE;\n\n  /* HELMUT */\n#if defined(sv_utf8_decode) && MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION\n  imp_dbh->enable_utf8 = FALSE;     /* initialize mysql_enable_utf8 */\n  imp_dbh->enable_utf8mb4 = FALSE;  /* initialize mysql_enable_utf8mb4 */\n#endif\n\n  if (!my_login(aTHX_ dbh, imp_dbh))\n  {\n    if(imp_dbh->pmysql)\n        do_error(dbh, mysql_errno(imp_dbh->pmysql),\n                mysql_error(imp_dbh->pmysql) ,mysql_sqlstate(imp_dbh->pmysql));\n    return FALSE;\n  }\n\n    /*\n     *  Tell DBI, that dbh->disconnect should be called for this handle\n     */\n    DBIc_ACTIVE_on(imp_dbh);\n\n    /* Tell DBI, that dbh->destroy should be called for this handle */\n    DBIc_on(imp_dbh, DBIcf_IMPSET);\n\n    return TRUE;\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos_before\\2016_8\\90a5ab519805acb6c5d1ae91d8e3f494ec179db4_before\\DBD-mysql-90a5ab519805acb6c5d1ae91d8e3f494ec179db4\\dbdimp.c", "callees": ["DBIc_on", "DBIc_TRACE_LEVEL", "do_error", "DBIc_LOGPIO", "mysql_errno", "DBIc_ACTIVE_on", "mysql_error", "my_login", "mysql_sqlstate", "D_imp_xxh", "PerlIO_printf"], "callers": []}], "functions_after": [{"name": "dbd_db_login", "content": "int dbd_db_login(SV* dbh, imp_dbh_t* imp_dbh, char* dbname, char* user,\n\t\t char* password) {\n#ifdef dTHR\n  dTHR;\n#endif\n  dTHX; \n  D_imp_xxh(dbh);\n\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n\t\t  \"imp_dbh->connect: dsn = %s, uid = %s, pwd = %s\\n\",\n\t\t  dbname ? dbname : \"NULL\",\n\t\t  user ? user : \"NULL\",\n\t\t  password ? password : \"NULL\");\n\n  imp_dbh->stats.auto_reconnects_ok= 0;\n  imp_dbh->stats.auto_reconnects_failed= 0;\n  imp_dbh->bind_type_guessing= FALSE;\n  imp_dbh->bind_comment_placeholders= FALSE;\n  imp_dbh->has_transactions= TRUE;\n /* Safer we flip this to TRUE perl side if we detect a mod_perl env. */\n  imp_dbh->auto_reconnect = FALSE;\n\n  /* HELMUT */\n#if defined(sv_utf8_decode) && MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION\n  imp_dbh->enable_utf8 = FALSE;     /* initialize mysql_enable_utf8 */\n  imp_dbh->enable_utf8mb4 = FALSE;  /* initialize mysql_enable_utf8mb4 */\n#endif\n\n  if (!my_login(aTHX_ dbh, imp_dbh))\n  {\n    if(imp_dbh->pmysql) {\n        do_error(dbh, mysql_errno(imp_dbh->pmysql),\n                mysql_error(imp_dbh->pmysql) ,mysql_sqlstate(imp_dbh->pmysql));\n        Safefree(imp_dbh->pmysql);\n\n    }\n    return FALSE;\n  }\n\n    /*\n     *  Tell DBI, that dbh->disconnect should be called for this handle\n     */\n    DBIc_ACTIVE_on(imp_dbh);\n\n    /* Tell DBI, that dbh->destroy should be called for this handle */\n    DBIc_on(imp_dbh, DBIcf_IMPSET);\n\n    return TRUE;\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos\\2016_8\\cf0aa7751f6ef8445e9310a64b14dc81460ca156_after\\DBD-mysql-cf0aa7751f6ef8445e9310a64b14dc81460ca156\\dbdimp.c", "callees": ["DBIc_on", "DBIc_TRACE_LEVEL", "do_error", "DBIc_LOGPIO", "mysql_errno", "DBIc_ACTIVE_on", "mysql_error", "my_login", "mysql_sqlstate", "D_imp_xxh", "Safefree", "PerlIO_printf"], "callers": []}], "callerTree_before": {"dbd_db_login": ["DBIc_on", "DBIc_TRACE_LEVEL", "do_error", "DBIc_LOGPIO", "mysql_errno", "DBIc_ACTIVE_on", "mysql_error", "my_login", "mysql_sqlstate", "D_imp_xxh", "PerlIO_printf"]}, "calleeTree_before": {"D_imp_xxh": ["dbd_db_login"], "DBIc_TRACE_LEVEL": ["dbd_db_login"], "PerlIO_printf": ["dbd_db_login"], "DBIc_LOGPIO": ["dbd_db_login"], "my_login": ["dbd_db_login"], "do_error": ["dbd_db_login"], "mysql_errno": ["dbd_db_login"], "mysql_error": ["dbd_db_login"], "mysql_sqlstate": ["dbd_db_login"], "DBIc_ACTIVE_on": ["dbd_db_login"], "DBIc_on": ["dbd_db_login"]}, "callerTree_after": {"dbd_db_login": ["DBIc_on", "DBIc_TRACE_LEVEL", "do_error", "DBIc_LOGPIO", "mysql_errno", "DBIc_ACTIVE_on", "mysql_error", "my_login", "mysql_sqlstate", "D_imp_xxh", "Safefree", "PerlIO_printf"]}, "calleeTree_after": {"D_imp_xxh": ["dbd_db_login"], "DBIc_TRACE_LEVEL": ["dbd_db_login"], "PerlIO_printf": ["dbd_db_login"], "DBIc_LOGPIO": ["dbd_db_login"], "my_login": ["dbd_db_login"], "do_error": ["dbd_db_login"], "mysql_errno": ["dbd_db_login"], "mysql_error": ["dbd_db_login"], "mysql_sqlstate": ["dbd_db_login"], "Safefree": ["dbd_db_login"], "DBIc_ACTIVE_on": ["dbd_db_login"], "DBIc_on": ["dbd_db_login"]}}
{"repo_after": "a56ae87a4c1c1fead7d09c3653905841ccccf1cc", "repo_before": "3e09017a24367d04156fce07f3f48a5fdb8c5db8", "functions_before": [{"name": "my_login", "content": "static int my_login(pTHX_ SV* dbh, imp_dbh_t *imp_dbh)\n{\n  SV* sv;\n  HV* hv;\n  char* dbname;\n  char* host;\n  char* port;\n  char* user;\n  char* password;\n  char* mysql_socket;\n  int   result;\n  D_imp_xxh(dbh);\n\n  /* TODO- resolve this so that it is set only if DBI is 1.607 */\n#define TAKE_IMP_DATA_VERSION 1\n#if TAKE_IMP_DATA_VERSION\n  if (DBIc_has(imp_dbh, DBIcf_IMPSET))\n  { /* eg from take_imp_data() */\n    if (DBIc_has(imp_dbh, DBIcf_ACTIVE))\n    {\n      if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n        PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"my_login skip connect\\n\");\n      /* tell our parent we've adopted an active child */\n      ++DBIc_ACTIVE_KIDS(DBIc_PARENT_COM(imp_dbh));\n      return TRUE;\n    }\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                    \"my_login IMPSET but not ACTIVE so connect not skipped\\n\");\n  }\n#endif\n\n  sv = DBIc_IMP_DATA(imp_dbh);\n\n  if (!sv  ||  !SvROK(sv))\n    return FALSE;\n\n  hv = (HV*) SvRV(sv);\n  if (SvTYPE(hv) != SVt_PVHV)\n    return FALSE;\n\n  host=\t\tsafe_hv_fetch(aTHX_ hv, \"host\", 4);\n  port=\t\tsafe_hv_fetch(aTHX_ hv, \"port\", 4);\n  user=\t\tsafe_hv_fetch(aTHX_ hv, \"user\", 4);\n  password=\tsafe_hv_fetch(aTHX_ hv, \"password\", 8);\n  dbname=\tsafe_hv_fetch(aTHX_ hv, \"database\", 8);\n  mysql_socket=\tsafe_hv_fetch(aTHX_ hv, \"mysql_socket\", 12);\n\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n\t\t  \"imp_dbh->my_login : dbname = %s, uid = %s, pwd = %s,\" \\\n\t\t  \"host = %s, port = %s\\n\",\n\t\t  dbname ? dbname : \"NULL\",\n\t\t  user ? user : \"NULL\",\n\t\t  password ? password : \"NULL\",\n\t\t  host ? host : \"NULL\",\n\t\t  port ? port : \"NULL\");\n\n  if (!imp_dbh->pmysql) {\n     Newz(908, imp_dbh->pmysql, 1, MYSQL);\n  }\n  result = mysql_dr_connect(dbh, imp_dbh->pmysql, mysql_socket, host, port, user,\n\t\t\t  password, dbname, imp_dbh) ? TRUE : FALSE;\n  if (!result)\n      Safefree(imp_dbh->pmysql);\n  return result;\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos_before\\2016_8\\3e09017a24367d04156fce07f3f48a5fdb8c5db8_before\\DBD-mysql-3e09017a24367d04156fce07f3f48a5fdb8c5db8\\dbdimp.c", "callees": ["SvTYPE", "DBIc_IMP_DATA", "DBIc_TRACE_LEVEL", "DBIc_ACTIVE_KIDS", "Newz", "DBIc_LOGPIO", "mysql_dr_connect", "SvROK", "DBIc_PARENT_COM", "SvRV", "safe_hv_fetch", "D_imp_xxh", "DBIc_has", "Safefree", "PerlIO_printf"], "callers": ["dbd_db_login"]}, {"name": "dbd_db_login", "content": "int dbd_db_login(SV* dbh, imp_dbh_t* imp_dbh, char* dbname, char* user,\n\t\t char* password) {\n#ifdef dTHR\n  dTHR;\n#endif\n  dTHX; \n  D_imp_xxh(dbh);\n\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n\t\t  \"imp_dbh->connect: dsn = %s, uid = %s, pwd = %s\\n\",\n\t\t  dbname ? dbname : \"NULL\",\n\t\t  user ? user : \"NULL\",\n\t\t  password ? password : \"NULL\");\n\n  imp_dbh->stats.auto_reconnects_ok= 0;\n  imp_dbh->stats.auto_reconnects_failed= 0;\n  imp_dbh->bind_type_guessing= FALSE;\n  imp_dbh->bind_comment_placeholders= FALSE;\n  imp_dbh->has_transactions= TRUE;\n /* Safer we flip this to TRUE perl side if we detect a mod_perl env. */\n  imp_dbh->auto_reconnect = FALSE;\n\n  /* HELMUT */\n#if defined(sv_utf8_decode) && MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION\n  imp_dbh->enable_utf8 = FALSE;  /* initialize mysql_enable_utf8 */\n#endif\n\n  if (!my_login(aTHX_ dbh, imp_dbh))\n  {\n    do_error(dbh, mysql_errno(imp_dbh->pmysql),\n            mysql_error(imp_dbh->pmysql) ,mysql_sqlstate(imp_dbh->pmysql));\n    return FALSE;\n  }\n\n    /*\n     *  Tell DBI, that dbh->disconnect should be called for this handle\n     */\n    DBIc_ACTIVE_on(imp_dbh);\n\n    /* Tell DBI, that dbh->destroy should be called for this handle */\n    DBIc_on(imp_dbh, DBIcf_IMPSET);\n\n    return TRUE;\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos_before\\2016_8\\3e09017a24367d04156fce07f3f48a5fdb8c5db8_before\\DBD-mysql-3e09017a24367d04156fce07f3f48a5fdb8c5db8\\dbdimp.c", "callees": ["DBIc_on", "DBIc_TRACE_LEVEL", "do_error", "DBIc_LOGPIO", "mysql_errno", "DBIc_ACTIVE_on", "mysql_error", "my_login", "mysql_sqlstate", "D_imp_xxh", "PerlIO_printf"], "callers": []}], "functions_after": [{"name": "my_login", "content": "static int my_login(pTHX_ SV* dbh, imp_dbh_t *imp_dbh)\n{\n  SV* sv;\n  HV* hv;\n  char* dbname;\n  char* host;\n  char* port;\n  char* user;\n  char* password;\n  char* mysql_socket;\n  int   result;\n  int\tfresh = 0;\n  D_imp_xxh(dbh);\n\n  /* TODO- resolve this so that it is set only if DBI is 1.607 */\n#define TAKE_IMP_DATA_VERSION 1\n#if TAKE_IMP_DATA_VERSION\n  if (DBIc_has(imp_dbh, DBIcf_IMPSET))\n  { /* eg from take_imp_data() */\n    if (DBIc_has(imp_dbh, DBIcf_ACTIVE))\n    {\n      if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n        PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"my_login skip connect\\n\");\n      /* tell our parent we've adopted an active child */\n      ++DBIc_ACTIVE_KIDS(DBIc_PARENT_COM(imp_dbh));\n      return TRUE;\n    }\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                    \"my_login IMPSET but not ACTIVE so connect not skipped\\n\");\n  }\n#endif\n\n  sv = DBIc_IMP_DATA(imp_dbh);\n\n  if (!sv  ||  !SvROK(sv))\n    return FALSE;\n\n  hv = (HV*) SvRV(sv);\n  if (SvTYPE(hv) != SVt_PVHV)\n    return FALSE;\n\n  host=\t\tsafe_hv_fetch(aTHX_ hv, \"host\", 4);\n  port=\t\tsafe_hv_fetch(aTHX_ hv, \"port\", 4);\n  user=\t\tsafe_hv_fetch(aTHX_ hv, \"user\", 4);\n  password=\tsafe_hv_fetch(aTHX_ hv, \"password\", 8);\n  dbname=\tsafe_hv_fetch(aTHX_ hv, \"database\", 8);\n  mysql_socket=\tsafe_hv_fetch(aTHX_ hv, \"mysql_socket\", 12);\n\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n\t\t  \"imp_dbh->my_login : dbname = %s, uid = %s, pwd = %s,\" \\\n\t\t  \"host = %s, port = %s\\n\",\n\t\t  dbname ? dbname : \"NULL\",\n\t\t  user ? user : \"NULL\",\n\t\t  password ? password : \"NULL\",\n\t\t  host ? host : \"NULL\",\n\t\t  port ? port : \"NULL\");\n\n  if (!imp_dbh->pmysql) {\n     fresh = 1;\n     Newz(908, imp_dbh->pmysql, 1, MYSQL);\n  }\n  result = mysql_dr_connect(dbh, imp_dbh->pmysql, mysql_socket, host, port, user,\n\t\t\t  password, dbname, imp_dbh) ? TRUE : FALSE;\n  if (fresh && !result) {\n      /* Prevent leaks, but do not free in case of a reconnect. See #97625 */\n      do_error(dbh, mysql_errno(imp_dbh->pmysql),\n              mysql_error(imp_dbh->pmysql) ,mysql_sqlstate(imp_dbh->pmysql));\n      Safefree(imp_dbh->pmysql);\n      imp_dbh->pmysql = NULL;\n  }\n  return result;\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos\\2016_8\\a56ae87a4c1c1fead7d09c3653905841ccccf1cc_after\\DBD-mysql-a56ae87a4c1c1fead7d09c3653905841ccccf1cc\\dbdimp.c", "callees": ["DBIc_LOGPIO", "SvROK", "safe_hv_fetch", "SvTYPE", "mysql_error", "mysql_sqlstate", "SvRV", "DBIc_TRACE_LEVEL", "DBIc_ACTIVE_KIDS", "PerlIO_printf", "DBIc_PARENT_COM", "D_imp_xxh", "do_error", "Newz", "mysql_errno", "DBIc_IMP_DATA", "DBIc_has", "Safefree", "mysql_dr_connect"], "callers": ["dbd_db_login"]}, {"name": "dbd_db_login", "content": "int dbd_db_login(SV* dbh, imp_dbh_t* imp_dbh, char* dbname, char* user,\n\t\t char* password) {\n#ifdef dTHR\n  dTHR;\n#endif\n  dTHX; \n  D_imp_xxh(dbh);\n\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n\t\t  \"imp_dbh->connect: dsn = %s, uid = %s, pwd = %s\\n\",\n\t\t  dbname ? dbname : \"NULL\",\n\t\t  user ? user : \"NULL\",\n\t\t  password ? password : \"NULL\");\n\n  imp_dbh->stats.auto_reconnects_ok= 0;\n  imp_dbh->stats.auto_reconnects_failed= 0;\n  imp_dbh->bind_type_guessing= FALSE;\n  imp_dbh->bind_comment_placeholders= FALSE;\n  imp_dbh->has_transactions= TRUE;\n /* Safer we flip this to TRUE perl side if we detect a mod_perl env. */\n  imp_dbh->auto_reconnect = FALSE;\n\n  /* HELMUT */\n#if defined(sv_utf8_decode) && MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION\n  imp_dbh->enable_utf8 = FALSE;  /* initialize mysql_enable_utf8 */\n#endif\n\n  if (!my_login(aTHX_ dbh, imp_dbh))\n  {\n    if(imp_dbh->pmysql)\n        do_error(dbh, mysql_errno(imp_dbh->pmysql),\n                mysql_error(imp_dbh->pmysql) ,mysql_sqlstate(imp_dbh->pmysql));\n    return FALSE;\n  }\n\n    /*\n     *  Tell DBI, that dbh->disconnect should be called for this handle\n     */\n    DBIc_ACTIVE_on(imp_dbh);\n\n    /* Tell DBI, that dbh->destroy should be called for this handle */\n    DBIc_on(imp_dbh, DBIcf_IMPSET);\n\n    return TRUE;\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos\\2016_8\\a56ae87a4c1c1fead7d09c3653905841ccccf1cc_after\\DBD-mysql-a56ae87a4c1c1fead7d09c3653905841ccccf1cc\\dbdimp.c", "callees": ["DBIc_on", "DBIc_TRACE_LEVEL", "do_error", "DBIc_LOGPIO", "mysql_errno", "DBIc_ACTIVE_on", "mysql_error", "my_login", "mysql_sqlstate", "D_imp_xxh", "PerlIO_printf"], "callers": []}], "callerTree_before": {"my_login": ["SvTYPE", "DBIc_IMP_DATA", "DBIc_TRACE_LEVEL", "DBIc_ACTIVE_KIDS", "Newz", "DBIc_LOGPIO", "mysql_dr_connect", "SvROK", "DBIc_PARENT_COM", "SvRV", "safe_hv_fetch", "D_imp_xxh", "DBIc_has", "Safefree", "PerlIO_printf"], "dbd_db_login": ["DBIc_on", "DBIc_TRACE_LEVEL", "do_error", "DBIc_LOGPIO", "mysql_errno", "DBIc_ACTIVE_on", "mysql_error", "my_login", "mysql_sqlstate", "D_imp_xxh", "PerlIO_printf"]}, "calleeTree_before": {"D_imp_xxh": ["my_login", "dbd_db_login"], "DBIc_has": ["my_login"], "DBIc_TRACE_LEVEL": ["my_login", "dbd_db_login"], "PerlIO_printf": ["my_login", "dbd_db_login"], "DBIc_LOGPIO": ["my_login", "dbd_db_login"], "DBIc_ACTIVE_KIDS": ["my_login"], "DBIc_PARENT_COM": ["my_login"], "DBIc_IMP_DATA": ["my_login"], "SvROK": ["my_login"], "SvRV": ["my_login"], "SvTYPE": ["my_login"], "safe_hv_fetch": ["my_login"], "Newz": ["my_login"], "mysql_dr_connect": ["my_login"], "Safefree": ["my_login"], "my_login": ["dbd_db_login"], "do_error": ["dbd_db_login"], "mysql_errno": ["dbd_db_login"], "mysql_error": ["dbd_db_login"], "mysql_sqlstate": ["dbd_db_login"], "DBIc_ACTIVE_on": ["dbd_db_login"], "DBIc_on": ["dbd_db_login"]}, "callerTree_after": {"my_login": ["DBIc_LOGPIO", "SvROK", "safe_hv_fetch", "SvTYPE", "mysql_error", "mysql_sqlstate", "SvRV", "DBIc_TRACE_LEVEL", "DBIc_ACTIVE_KIDS", "PerlIO_printf", "DBIc_PARENT_COM", "D_imp_xxh", "do_error", "Newz", "mysql_errno", "DBIc_IMP_DATA", "DBIc_has", "Safefree", "mysql_dr_connect"], "dbd_db_login": ["DBIc_on", "DBIc_TRACE_LEVEL", "do_error", "DBIc_LOGPIO", "mysql_errno", "DBIc_ACTIVE_on", "mysql_error", "my_login", "mysql_sqlstate", "D_imp_xxh", "PerlIO_printf"]}, "calleeTree_after": {"D_imp_xxh": ["my_login", "dbd_db_login"], "DBIc_has": ["my_login"], "DBIc_TRACE_LEVEL": ["my_login", "dbd_db_login"], "PerlIO_printf": ["my_login", "dbd_db_login"], "DBIc_LOGPIO": ["my_login", "dbd_db_login"], "DBIc_ACTIVE_KIDS": ["my_login"], "DBIc_PARENT_COM": ["my_login"], "DBIc_IMP_DATA": ["my_login"], "SvROK": ["my_login"], "SvRV": ["my_login"], "SvTYPE": ["my_login"], "safe_hv_fetch": ["my_login"], "Newz": ["my_login"], "mysql_dr_connect": ["my_login"], "do_error": ["my_login", "dbd_db_login"], "mysql_errno": ["my_login", "dbd_db_login"], "mysql_error": ["my_login", "dbd_db_login"], "mysql_sqlstate": ["my_login", "dbd_db_login"], "Safefree": ["my_login"], "my_login": ["dbd_db_login"], "DBIc_ACTIVE_on": ["dbd_db_login"], "DBIc_on": ["dbd_db_login"]}}
{"repo_after": "1ccfe21e14c4d18336f9da8515cd17db88c3de61", "repo_before": "3fe0a7128bac5000fdcfab888bd2a75ec0c9447d", "functions_before": [{"name": "gdImageCropThreshold", "content": "BGD_DECLARE(gdImagePtr) gdImageCropThreshold(gdImagePtr im, const unsigned int color, const float threshold)\n{\n\tconst int width = gdImageSX(im);\n\tconst int height = gdImageSY(im);\n\n\tint x,y;\n\tint match;\n\tgdRect crop;\n\n\tcrop.x = 0;\n\tcrop.y = 0;\n\tcrop.width = 0;\n\tcrop.height = 0;\n\n\t/* Pierre: crop everything sounds bad */\n\tif (threshold > 100.0) {\n\t\treturn NULL;\n\t}\n\n\t/* TODO: Add gdImageGetRowPtr and works with ptr at the row level\n\t * for the true color and palette images\n\t * new formats will simply work with ptr\n\t */\n\tmatch = 1;\n\tfor (y = 0; match && y < height; y++) {\n\t\tfor (x = 0; match && x < width; x++) {\n\t\t\tmatch = (gdColorMatch(im, color, gdImageGetPixel(im, x,y), threshold)) > 0;\n\t\t}\n\t}\n\n\t/* Pierre\n\t * Nothing to do > bye\n\t * Duplicate the image?\n\t */\n\tif (y == height - 1) {\n\t\treturn NULL;\n\t}\n\n\tcrop.y = y -1;\n\tmatch = 1;\n\tfor (y = height - 1; match && y >= 0; y--) {\n\t\tfor (x = 0; match && x < width; x++) {\n\t\t\tmatch = (gdColorMatch(im, color, gdImageGetPixel(im, x, y), threshold)) > 0;\n\t\t}\n\t}\n\n\tif (y == 0) {\n\t\tcrop.height = height - crop.y + 1;\n\t} else {\n\t\tcrop.height = y - crop.y + 2;\n\t}\n\n\tmatch = 1;\n\tfor (x = 0; match && x < width; x++) {\n\t\tfor (y = 0; match && y < crop.y + crop.height - 1; y++) {\n\t\t\tmatch = (gdColorMatch(im, color, gdImageGetPixel(im, x,y), threshold)) > 0;\n\t\t}\n\t}\n\tcrop.x = x - 1;\n\n\tmatch = 1;\n\tfor (x = width - 1; match && x >= 0; x--) {\n\t\tfor (y = 0; match &&  y < crop.y + crop.height - 1; y++) {\n\t\t\tmatch = (gdColorMatch(im, color, gdImageGetPixel(im, x,y), threshold)) > 0;\n\t\t}\n\t}\n\tcrop.width = x - crop.x + 2;\n\n\treturn gdImageCrop(im, &crop);\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos_before\\2016_8\\3fe0a7128bac5000fdcfab888bd2a75ec0c9447d_before\\libgd-3fe0a7128bac5000fdcfab888bd2a75ec0c9447d\\src\\gd_crop.c", "callees": [], "callers": []}], "functions_after": [{"name": "gdImageCropThreshold", "content": "BGD_DECLARE(gdImagePtr) gdImageCropThreshold(gdImagePtr im, const unsigned int color, const float threshold)\n{\n\tconst int width = gdImageSX(im);\n\tconst int height = gdImageSY(im);\n\n\tint x,y;\n\tint match;\n\tgdRect crop;\n\n\tcrop.x = 0;\n\tcrop.y = 0;\n\tcrop.width = 0;\n\tcrop.height = 0;\n\n\t/* Pierre: crop everything sounds bad */\n\tif (threshold > 100.0) {\n\t\treturn NULL;\n\t}\n\n\tif (color < 0 || (!gdImageTrueColor(im) && color >= gdImageColorsTotal(im))) {\n\t\treturn NULL;\n\t}\n\n\t/* TODO: Add gdImageGetRowPtr and works with ptr at the row level\n\t * for the true color and palette images\n\t * new formats will simply work with ptr\n\t */\n\tmatch = 1;\n\tfor (y = 0; match && y < height; y++) {\n\t\tfor (x = 0; match && x < width; x++) {\n\t\t\tmatch = (gdColorMatch(im, color, gdImageGetPixel(im, x,y), threshold)) > 0;\n\t\t}\n\t}\n\n\t/* Pierre\n\t * Nothing to do > bye\n\t * Duplicate the image?\n\t */\n\tif (y == height - 1) {\n\t\treturn NULL;\n\t}\n\n\tcrop.y = y -1;\n\tmatch = 1;\n\tfor (y = height - 1; match && y >= 0; y--) {\n\t\tfor (x = 0; match && x < width; x++) {\n\t\t\tmatch = (gdColorMatch(im, color, gdImageGetPixel(im, x, y), threshold)) > 0;\n\t\t}\n\t}\n\n\tif (y == 0) {\n\t\tcrop.height = height - crop.y + 1;\n\t} else {\n\t\tcrop.height = y - crop.y + 2;\n\t}\n\n\tmatch = 1;\n\tfor (x = 0; match && x < width; x++) {\n\t\tfor (y = 0; match && y < crop.y + crop.height - 1; y++) {\n\t\t\tmatch = (gdColorMatch(im, color, gdImageGetPixel(im, x,y), threshold)) > 0;\n\t\t}\n\t}\n\tcrop.x = x - 1;\n\n\tmatch = 1;\n\tfor (x = width - 1; match && x >= 0; x--) {\n\t\tfor (y = 0; match &&  y < crop.y + crop.height - 1; y++) {\n\t\t\tmatch = (gdColorMatch(im, color, gdImageGetPixel(im, x,y), threshold)) > 0;\n\t\t}\n\t}\n\tcrop.width = x - crop.x + 2;\n\n\treturn gdImageCrop(im, &crop);\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos\\2016_8\\1ccfe21e14c4d18336f9da8515cd17db88c3de61_after\\libgd-1ccfe21e14c4d18336f9da8515cd17db88c3de61\\src\\gd_crop.c", "callees": [], "callers": []}], "callerTree_before": {"gdGuessBackgroundColorFromCorners": ["gdImageGetPixel", "gdImageBlue", "gdImageSY", "gdImageGreen", "gdImageRed", "gdImageAlpha", "gdImageColorClosestAlpha", "gdImageSX"]}, "calleeTree_before": {"gdImageGetPixel": ["gdGuessBackgroundColorFromCorners"], "gdImageSX": ["gdGuessBackgroundColorFromCorners"], "gdImageSY": ["gdGuessBackgroundColorFromCorners"], "gdImageRed": ["gdGuessBackgroundColorFromCorners"], "gdImageGreen": ["gdGuessBackgroundColorFromCorners"], "gdImageBlue": ["gdGuessBackgroundColorFromCorners"], "gdImageAlpha": ["gdGuessBackgroundColorFromCorners"], "gdImageColorClosestAlpha": ["gdGuessBackgroundColorFromCorners"]}, "callerTree_after": {"gdGuessBackgroundColorFromCorners": ["gdImageGetPixel", "gdImageBlue", "gdImageSY", "gdImageGreen", "gdImageRed", "gdImageAlpha", "gdImageColorClosestAlpha", "gdImageSX"]}, "calleeTree_after": {"gdImageGetPixel": ["gdGuessBackgroundColorFromCorners"], "gdImageSX": ["gdGuessBackgroundColorFromCorners"], "gdImageSY": ["gdGuessBackgroundColorFromCorners"], "gdImageRed": ["gdGuessBackgroundColorFromCorners"], "gdImageGreen": ["gdGuessBackgroundColorFromCorners"], "gdImageBlue": ["gdGuessBackgroundColorFromCorners"], "gdImageAlpha": ["gdGuessBackgroundColorFromCorners"], "gdImageColorClosestAlpha": ["gdGuessBackgroundColorFromCorners"]}}
{"repo_after": "b69d11727d4f0f8cf719c79e3fb700f55ca03e9a", "repo_before": "b9cede3c19693b7663219691d8604e037cea673a", "functions_before": [{"name": "send_auth", "content": "static void send_auth(char *username, char *password) {\n\tstruct mt_packet data;\n\tunsigned short width = 0;\n\tunsigned short height = 0;\n\tchar *terminal = getenv(\"TERM\");\n\tchar md5data[100];\n\tunsigned char md5sum[17];\n\tint plen;\n\tmd5_state_t state;\n\n#if defined(__linux__) && defined(_POSIX_MEMLOCK_RANGE)\n\tmlock(md5data, sizeof(md5data));\n\tmlock(md5sum, sizeof(md5data));\n#endif\n\n\t/* Concat string of 0 + password + pass_salt */\n\tmd5data[0] = 0;\n\tstrncpy(md5data + 1, password, 82);\n\tmd5data[83] = '\\0';\n\tmemcpy(md5data + 1 + strlen(password), pass_salt, 16);\n\n\t/* Generate md5 sum of md5data with a leading 0 */\n\tmd5_init(&state);\n\tmd5_append(&state, (const md5_byte_t *)md5data, strlen(password) + 17);\n\tmd5_finish(&state, (md5_byte_t *)md5sum + 1);\n\tmd5sum[0] = 0;\n\n\t/* Send combined packet to server */\n\tinit_packet(&data, MT_PTYPE_DATA, srcmac, dstmac, sessionkey, outcounter);\n\tplen = add_control_packet(&data, MT_CPTYPE_PASSWORD, md5sum, 17);\n\tplen += add_control_packet(&data, MT_CPTYPE_USERNAME, username, strlen(username));\n\tplen += add_control_packet(&data, MT_CPTYPE_TERM_TYPE, terminal, strlen(terminal));\n\t\n\tif (is_a_tty && get_terminal_size(&width, &height) != -1) {\n\t\twidth = htole16(width);\n\t\theight = htole16(height);\n\t\tplen += add_control_packet(&data, MT_CPTYPE_TERM_WIDTH, &width, 2);\n\t\tplen += add_control_packet(&data, MT_CPTYPE_TERM_HEIGHT, &height, 2);\n\t}\n\n\toutcounter += plen;\n\n\t/* TODO: handle result */\n\tsend_udp(&data, 1);\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos_before\\2016_8\\b9cede3c19693b7663219691d8604e037cea673a_before\\MAC-Telnet-b9cede3c19693b7663219691d8604e037cea673a\\mactelnet.c", "callees": ["md5_append", "md5_finish", "strncpy", "send_udp", "init_packet", "htole16", "md5_init", "getenv", "strlen", "get_terminal_size", "add_control_packet", "memcpy", "mlock"], "callers": ["handle_packet"]}, {"name": "handle_packet", "content": "static int handle_packet(unsigned char *data, int data_len) {\n\tstruct mt_mactelnet_hdr pkthdr;\n\n\t/* Minimal size checks (pings are not supported here) */\n\tif (data_len < MT_HEADER_LEN){\n\t\treturn -1;\n\t}\n\tparse_packet(data, &pkthdr);\n\n\t/* We only care about packets with correct sessionkey */\n\tif (pkthdr.seskey != sessionkey) {\n\t\treturn -1;\n\t}\n\n\t/* Handle data packets */\n\tif (pkthdr.ptype == MT_PTYPE_DATA) {\n\t\tstruct mt_packet odata;\n\t\tstruct mt_mactelnet_control_hdr cpkt;\n\t\tint success = 0;\n\n\t\t/* Always transmit ACKNOWLEDGE packets in response to DATA packets */\n\t\tinit_packet(&odata, MT_PTYPE_ACK, srcmac, dstmac, sessionkey, pkthdr.counter + (data_len - MT_HEADER_LEN));\n\t\tsend_udp(&odata, 0);\n\n\t\t/* Accept first packet, and all packets greater than incounter, and if counter has\n\t\twrapped around. */\n\t\tif (pkthdr.counter > incounter || (incounter - pkthdr.counter) > 65535) {\n\t\t\tincounter = pkthdr.counter;\n\t\t} else {\n\t\t\t/* Ignore double or old packets */\n\t\t\treturn -1;\n\t\t}\n\n\t\t/* Parse controlpacket data */\n\t\tsuccess = parse_control_packet(data + MT_HEADER_LEN, data_len - MT_HEADER_LEN, &cpkt);\n\n\t\twhile (success) {\n\n\t\t\t/* If we receive pass_salt, transmit auth data back */\n\t\t\tif (cpkt.cptype == MT_CPTYPE_PASSSALT) {\n\t\t\t\tmemcpy(pass_salt, cpkt.data, cpkt.length);\n\t\t\t\tsend_auth(username, password);\n\t\t\t}\n\n\t\t\t/* If the (remaining) data did not have a control-packet magic byte sequence,\n\t\t\t   the data is raw terminal data to be outputted to the terminal. */\n\t\t\telse if (cpkt.cptype == MT_CPTYPE_PLAINDATA) {\n\t\t\t\tfwrite((const void *)cpkt.data, 1, cpkt.length, stdout);\n\t\t\t}\n\n\t\t\t/* END_AUTH means that the user/password negotiation is done, and after this point\n\t\t\t   terminal data may arrive, so we set up the terminal to raw mode. */\n\t\t\telse if (cpkt.cptype == MT_CPTYPE_END_AUTH) {\n\n\t\t\t\t/* we have entered \"terminal mode\" */\n\t\t\t\tterminal_mode = 1;\n\n\t\t\t\tif (is_a_tty) {\n\t\t\t\t\t/* stop input buffering at all levels. Give full control of terminal to RouterOS */\n\t\t\t\t\traw_term();\n\n\t\t\t\t\tsetvbuf(stdin,  (char*)NULL, _IONBF, 0);\n\n\t\t\t\t\t/* Add resize signal handler */\n\t\t\t\t\tsignal(SIGWINCH, sig_winch);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* Parse next controlpacket */\n\t\t\tsuccess = parse_control_packet(NULL, 0, &cpkt);\n\t\t}\n\t}\n\telse if (pkthdr.ptype == MT_PTYPE_ACK) {\n\t\t/* Handled elsewhere */\n\t}\n\n\t/* The server wants to terminate the connection, we have to oblige */\n\telse if (pkthdr.ptype == MT_PTYPE_END) {\n\t\tstruct mt_packet odata;\n\n\t\t/* Acknowledge the disconnection by sending a END packet in return */\n\t\tinit_packet(&odata, MT_PTYPE_END, srcmac, dstmac, pkthdr.seskey, 0);\n\t\tsend_udp(&odata, 0);\n\n\t\tif (!quiet_mode) {\n\t\t\tfprintf(stderr, _(\"Connection closed.\\n\"));\n\t\t}\n\n\t\t/* exit */\n\t\trunning = 0;\n\t} else {\n\t\tfprintf(stderr, _(\"Unhandeled packet type: %d received from server %s\\n\"), pkthdr.ptype, ether_ntoa((struct ether_addr *)dstmac));\n\t\treturn -1;\n\t}\n\n\treturn pkthdr.ptype;\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos_before\\2016_8\\b9cede3c19693b7663219691d8604e037cea673a_before\\MAC-Telnet-b9cede3c19693b7663219691d8604e037cea673a\\mactelnet.c", "callees": ["sig_winch", "fwrite", "send_udp", "fprintf", "init_packet", "send_auth", "parse_control_packet", "parse_packet", "signal", "setvbuf", "ether_ntoa", "raw_term", "memcpy"], "callers": []}, {"name": "user_login", "content": "static void user_login(struct mt_connection *curconn, struct mt_mactelnet_hdr *pkthdr) {\n\tstruct mt_packet pdata;\n\tunsigned char md5sum[17];\n\tchar md5data[100];\n\tstruct mt_credentials *user;\n\tchar *slavename;\n\n\t/* Reparse user file before each login */\n\tread_userfile();\n\n\tif ((user = find_user(curconn->username)) != NULL) {\n\t\tmd5_state_t state;\n#if defined(__linux__) && defined(_POSIX_MEMLOCK_RANGE)\n\t\tmlock(md5data, sizeof(md5data));\n\t\tmlock(md5sum, sizeof(md5sum));\n\t\tif (user->password != NULL) {\n\t\t\tmlock(user->password, strlen(user->password));\n\t\t}\n#endif\n\n\t\t/* Concat string of 0 + password + pass_salt */\n\t\tmd5data[0] = 0;\n\t\tstrncpy(md5data + 1, user->password, 82);\n\t\tmemcpy(md5data + 1 + strlen(user->password), curconn->pass_salt, 16);\n\n\t\t/* Generate md5 sum of md5data with a leading 0 */\n\t\tmd5_init(&state);\n\t\tmd5_append(&state, (const md5_byte_t *)md5data, strlen(user->password) + 17);\n\t\tmd5_finish(&state, (md5_byte_t *)md5sum + 1);\n\t\tmd5sum[0] = 0;\n\n\t\tinit_packet(&pdata, MT_PTYPE_DATA, pkthdr->dstaddr, pkthdr->srcaddr, pkthdr->seskey, curconn->outcounter);\n\t\tcurconn->outcounter += add_control_packet(&pdata, MT_CPTYPE_END_AUTH, NULL, 0);\n\t\tsend_udp(curconn, &pdata);\n\n\t\tif (curconn->state == STATE_ACTIVE) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (user == NULL || memcmp(md5sum, curconn->trypassword, 17) != 0) {\n\t\tsyslog(LOG_NOTICE, _(\"(%d) Invalid login by %s.\"), curconn->seskey, curconn->username);\n\n\t\t/*_ Please include both \\r and \\n in translation, this is needed for the terminal emulator. */\n\t\tabort_connection(curconn, pkthdr, _(\"Login failed, incorrect username or password\\r\\n\"));\n\n\t\t/* TODO: should wait some time (not with sleep) before returning, to minimalize brute force attacks */\n\t\treturn;\n\t}\n\n\t/* User is logged in */\n\tcurconn->state = STATE_ACTIVE;\n\n\t/* Enter terminal mode */\n\tcurconn->terminal_mode = 1;\n\n\t/* Open pts handle */\n\tcurconn->ptsfd = posix_openpt(O_RDWR);\n\tif (curconn->ptsfd == -1 || grantpt(curconn->ptsfd) == -1 || unlockpt(curconn->ptsfd) == -1) {\n\t\t\tsyslog(LOG_ERR, \"posix_openpt: %s\", strerror(errno));\n\t\t\t/*_ Please include both \\r and \\n in translation, this is needed for the terminal emulator. */\n\t\t\tabort_connection(curconn, pkthdr, _(\"Terminal error\\r\\n\"));\n\t\t\treturn;\n\t}\n\n\t/* Get file path for our pts */\n\tslavename = ptsname(curconn->ptsfd);\n\tif (slavename != NULL) {\n\t\tpid_t pid;\n\t\tstruct stat sb;\n\t\tstruct passwd *user = (struct passwd *)malloc(sizeof(struct passwd));\n\t\tstruct passwd *tmpuser=user;\n\t\tchar *buffer = malloc(1024);\n\n\t\tif (user == NULL || buffer == NULL) {\n\t\t\tsyslog(LOG_CRIT, _(\"(%d) Error allocating memory.\"), curconn->seskey);\n\t\t\t/*_ Please include both \\r and \\n in translation, this is needed for the terminal emulator. */\n\t\t\tabort_connection(curconn, pkthdr, _(\"System error, out of memory\\r\\n\"));\n\t\t\treturn;\n\t\t}\n\n\t\tif (getpwnam_r(curconn->username, user, buffer, 1024, &tmpuser) != 0) {\n\t\t\tsyslog(LOG_WARNING, _(\"(%d) Login ok, but local user not accessible (%s).\"), curconn->seskey, curconn->username);\n\t\t\t/*_ Please include both \\r and \\n in translation, this is needed for the terminal emulator. */\n\t\t\tabort_connection(curconn, pkthdr, _(\"Local user not accessible\\r\\n\"));\n\t\t\tfree(user);\n\t\t\tfree(buffer);\n\t\t\treturn;\n\t\t}\n\n\t\t/* Change the owner of the slave pts */\n\t\tchown(slavename, user->pw_uid, user->pw_gid);\n\n\t\tcurconn->slavefd = open(slavename, O_RDWR);\n\t\tif (curconn->slavefd == -1) {\n\t\t\tsyslog(LOG_ERR, _(\"Error opening %s: %s\"), slavename, strerror(errno));\n\t\t\t/*_ Please include both \\r and \\n in translation, this is needed for the terminal emulator. */\n\t\t\tabort_connection(curconn, pkthdr, _(\"Error opening terminal\\r\\n\"));\n\t\t\tlist_remove_connection(curconn);\n\t\t\treturn;\n\t\t}\n\n\t\tif ((pid = fork()) == 0) {\n\t\t\tstruct net_interface *interface;\n\n\t\t\t/* Add login information to utmp/wtmp */\n\t\t\tuwtmp_login(curconn);\n\n\t\t\tsyslog(LOG_INFO, _(\"(%d) User %s logged in.\"), curconn->seskey, curconn->username);\n\n\t\t\t/* Initialize terminal environment */\n\t\t\tsetenv(\"USER\", user->pw_name, 1);\n\t\t\tsetenv(\"HOME\", user->pw_dir, 1);\n\t\t\tsetenv(\"SHELL\", user->pw_shell, 1);\n\t\t\tsetenv(\"TERM\", curconn->terminal_type, 1);\n\t\t\tclose(sockfd);\n\t\t\tclose(insockfd);\n\n\t\t\tDL_FOREACH(interfaces, interface) {\n\t\t\t\tif (interface->socketfd > 0) {\n\t\t\t\t\tclose(interface->socketfd);\n\t\t\t\t}\n\t\t\t}\n\t\t\tsetsid();\n\n\t\t\t/* Don't let shell process inherit slavefd */\n\t\t\tfcntl (curconn->slavefd, F_SETFD, FD_CLOEXEC);\n\t\t\tclose(curconn->ptsfd);\n\n\t\t\t/* Redirect STDIN/STDIO/STDERR */\n\t\t\tclose(0);\n\t\t\tdup(curconn->slavefd);\n\t\t\tclose(1);\n\t\t\tdup(curconn->slavefd);\n\t\t\tclose(2);\n\t\t\tdup(curconn->slavefd);\n\n\t\t\t/* Set controlling terminal */\n\t\t\tioctl(0, TIOCSCTTY, 1);\n\t\t\ttcsetpgrp(0, getpid());\n\n\t\t\t/* Set user id/group id */\n\t\t\tif ((setgid(user->pw_gid) != 0) || (setuid(user->pw_uid) != 0)) {\n\t\t\t\tsyslog(LOG_ERR, _(\"(%d) Could not log in %s (%d:%d): setuid/setgid: %s\"), curconn->seskey, curconn->username, user->pw_uid, user->pw_gid, strerror(errno));\n\t\t\t\t/*_ Please include both \\r and \\n in translation, this is needed for the terminal emulator. */\n\t\t\t\tabort_connection(curconn, pkthdr, _(\"Internal error\\r\\n\"));\n\t\t\t\texit(0);\n\t\t\t}\n\n\t\t\t/* Abort login if /etc/nologin exists */\n\t\t\tif (stat(_PATH_NOLOGIN, &sb) == 0 && getuid() != 0) {\n\t\t\t\tsyslog(LOG_NOTICE, _(\"(%d) User %s disconnected with \" _PATH_NOLOGIN \" message.\"), curconn->seskey, curconn->username);\n\t\t\t\tdisplay_nologin();\n\t\t\t\tcurconn->state = STATE_CLOSED;\n\t\t\t\tinit_packet(&pdata, MT_PTYPE_END, pkthdr->dstaddr, pkthdr->srcaddr, pkthdr->seskey, curconn->outcounter);\n\t\t\t\tsend_udp(curconn, &pdata);\n\t\t\t\texit(0);\n\t\t\t}\n\n\t\t\t/* Display MOTD */\n\t\t\tdisplay_motd();\n\n\t\t\tchdir(user->pw_dir);\n\n\t\t\t/* Spawn shell */\n\t\t\t/* TODO: Maybe use \"login -f USER\" instead? renders motd and executes shell correctly for system */\n\t\t\texecl(user->pw_shell, user->pw_shell, \"-\", (char *) 0);\n\t\t\texit(0); // just to be sure.\n\t\t}\n\t\tfree(user);\n\t\tfree(buffer);\n\t\tclose(curconn->slavefd);\n\t\tcurconn->pid = pid;\n\t\tset_terminal_size(curconn->ptsfd, curconn->terminal_width, curconn->terminal_height);\n\t}\n\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos_before\\2016_8\\b9cede3c19693b7663219691d8604e037cea673a_before\\MAC-Telnet-b9cede3c19693b7663219691d8604e037cea673a\\mactelnetd.c", "callees": [], "callers": []}, {"name": "handle_data_packet", "content": "static void handle_data_packet(struct mt_connection *curconn, struct mt_mactelnet_hdr *pkthdr, int data_len) {\n\tstruct mt_mactelnet_control_hdr cpkt;\n\tstruct mt_packet pdata;\n\tunsigned char *data = pkthdr->data;\n\tunsigned int act_size = 0;\n\tint got_user_packet = 0;\n\tint got_pass_packet = 0;\n\tint got_width_packet = 0;\n\tint got_height_packet = 0;\n\tint success;\n\n\t/* Parse first control packet */\n\tsuccess = parse_control_packet(data, data_len - MT_HEADER_LEN, &cpkt);\n\n\twhile (success) {\n\t\tif (cpkt.cptype == MT_CPTYPE_BEGINAUTH) {\n\t\t\tint plen,i;\n\t\t\tif (!curconn->have_pass_salt) {\n\t\t\t\tfor (i = 0; i < 16; ++i) {\n\t\t\t\t\tcurconn->pass_salt[i] = rand() % 256;\n\t\t\t\t}\n\t\t\t\tcurconn->have_pass_salt = 1;\n\n\t\t\t\tmemset(curconn->trypassword, 0, sizeof(curconn->trypassword));\n\t\t\t}\n\t\t\tinit_packet(&pdata, MT_PTYPE_DATA, pkthdr->dstaddr, pkthdr->srcaddr, pkthdr->seskey, curconn->outcounter);\n\t\t\tplen = add_control_packet(&pdata, MT_CPTYPE_PASSSALT, (curconn->pass_salt), 16);\n\t\t\tcurconn->outcounter += plen;\n\n\t\t\tsend_udp(curconn, &pdata);\n\t\t\n\t\t/* Don't change the username after the state is active */\n\t\t} else if (cpkt.cptype == MT_CPTYPE_USERNAME && curconn->state != STATE_ACTIVE) {\n\t\t\tmemcpy(curconn->username, cpkt.data, act_size = (cpkt.length > MT_MNDP_MAX_STRING_SIZE - 1 ? MT_MNDP_MAX_STRING_SIZE - 1 : cpkt.length));\n\t\t\tcurconn->username[act_size] = 0;\n\t\t\tgot_user_packet = 1;\n\n\t\t} else if (cpkt.cptype == MT_CPTYPE_TERM_WIDTH && cpkt.length >= 2) {\n\t\t\tunsigned short width;\n\n\t\t\tmemcpy(&width, cpkt.data, 2);\n\t\t\tcurconn->terminal_width = le16toh(width);\n\t\t\tgot_width_packet = 1;\n\n\t\t} else if (cpkt.cptype == MT_CPTYPE_TERM_HEIGHT && cpkt.length >= 2) {\n\t\t\tunsigned short height;\n\n\t\t\tmemcpy(&height, cpkt.data, 2);\n\t\t\tcurconn->terminal_height = le16toh(height);\n\t\t\tgot_height_packet = 1;\n\n\t\t} else if (cpkt.cptype == MT_CPTYPE_TERM_TYPE) {\n\n\t\t\tmemcpy(curconn->terminal_type, cpkt.data, act_size = (cpkt.length > 30 - 1 ? 30 - 1 : cpkt.length));\n\t\t\tcurconn->terminal_type[act_size] = 0;\n\n\t\t} else if (cpkt.cptype == MT_CPTYPE_PASSWORD) {\n\n#if defined(__linux__) && defined(_POSIX_MEMLOCK_RANGE)\n\t\t\tmlock(curconn->trypassword, 17);\n#endif\n\t\t\tmemcpy(curconn->trypassword, cpkt.data, 17);\n\t\t\tgot_pass_packet = 1;\n\n\t\t} else if (cpkt.cptype == MT_CPTYPE_PLAINDATA) {\n\n\t\t\t/* relay data from client to shell */\n\t\t\tif (curconn->state == STATE_ACTIVE && curconn->ptsfd != -1) {\n\t\t\t\twrite(curconn->ptsfd, cpkt.data, cpkt.length);\n\t\t\t}\n\n\t\t} else {\n\t\t\tsyslog(LOG_WARNING, _(\"(%d) Unhandeled control packet type: %d\"), curconn->seskey, cpkt.cptype);\n\t\t}\n\n\t\t/* Parse next control packet */\n\t\tsuccess = parse_control_packet(NULL, 0, &cpkt);\n\t}\n\n\tif (got_user_packet && got_pass_packet) {\n\t\tuser_login(curconn, pkthdr);\n\t}\n\n\tif (curconn->state == STATE_ACTIVE && (got_width_packet || got_height_packet)) {\n\t\tset_terminal_size(curconn->ptsfd, curconn->terminal_width, curconn->terminal_height);\n\n\t}\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos_before\\2016_8\\b9cede3c19693b7663219691d8604e037cea673a_before\\MAC-Telnet-b9cede3c19693b7663219691d8604e037cea673a\\mactelnetd.c", "callees": [], "callers": []}, {"name": "add_control_packet", "content": "int add_control_packet(struct mt_packet *packet, enum mt_cptype cptype, void *cpdata, unsigned short data_len) {\n\tunsigned char *data = packet->data + packet->size;\n\tunsigned int act_size = data_len + (cptype == MT_CPTYPE_PLAINDATA ? 0 : MT_CPHEADER_LEN);\n\n\t/* Something is really wrong. Packets should never become over 1500 bytes */\n\tif (packet->size + act_size > MT_PACKET_LEN) {\n\t\tfprintf(stderr, _(\"add_control_packet: ERROR, too large packet. Exceeds %d bytes\\n\"), MT_PACKET_LEN);\n\t\treturn -1;\n\t\t//exit(1);\n\t}\n\n\t/* PLAINDATA isn't really a controlpacket, but we handle it here, since\n\t   parseControlPacket also parses raw data as PLAINDATA */\n\tif (cptype == MT_CPTYPE_PLAINDATA) {\n\t\tmemcpy(data, cpdata, data_len);\n\t\tpacket->size += data_len;\n\t\treturn data_len;\n\t}\n\n\t/* Control Packet Magic id */\n\tmemcpy(data, mt_mactelnet_cpmagic, sizeof(mt_mactelnet_cpmagic));\n\n\t/* Control packet type */\n\tdata[4] = cptype;\n\n\t/* Data length */\n#if BYTE_ORDER == LITTLE_ENDIAN\n\t{\n\t\tunsigned int templen;\n\t\ttemplen = htonl(data_len);\n\t\tmemcpy(data + 5, &templen, sizeof(templen));\n\t}\n#else\n\tmemcpy(data + 5, &data_len, sizeof(data_len));\n#endif\n\n\t/* Insert data */\n\tif (data_len > 0) {\n\t\tmemcpy(data + MT_CPHEADER_LEN, cpdata, data_len);\n\t}\n\n\tpacket->size += act_size;\n\t/* Control packet header length + data length */\n\treturn act_size;\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos_before\\2016_8\\b9cede3c19693b7663219691d8604e037cea673a_before\\MAC-Telnet-b9cede3c19693b7663219691d8604e037cea673a\\protocol.c", "callees": ["fprintf", "htonl", "memcpy"], "callers": ["send_auth"]}, {"name": "add_packetdata", "content": "int add_packetdata(struct mt_packet *packet, unsigned char *data, unsigned short length) {\n\tif (packet->size + length > MT_PACKET_LEN) {\n\t\tfprintf(stderr, _(\"add_control_packet: ERROR, too large packet. Exceeds %d bytes\\n\"), MT_PACKET_LEN);\n\t\treturn -1;\n\t}\n\n\tmemcpy(packet->data + packet->size, data, length);\n\tpacket->size += length;\n\n\treturn length;\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos_before\\2016_8\\b9cede3c19693b7663219691d8604e037cea673a_before\\MAC-Telnet-b9cede3c19693b7663219691d8604e037cea673a\\protocol.c", "callees": ["fprintf", "memcpy"], "callers": []}, {"name": "mndp_add_attribute", "content": "int mndp_add_attribute(struct mt_packet *packet, enum mt_mndp_attrtype attrtype, void *attrdata, unsigned short data_len) {\n\tunsigned char *data = packet->data + packet->size;\n\tunsigned short type = attrtype;\n\tunsigned short len = data_len;\n\n\t/* Something is really wrong. Packets should never become over 1500 bytes */\n\tif (packet->size + 4 + data_len > MT_PACKET_LEN) {\n\t\tfprintf(stderr, _(\"mndp_add_attribute: ERROR, too large packet. Exceeds %d bytes\\n\"), MT_PACKET_LEN);\n\t\treturn -1;\n\t}\n\n\ttype = htons(type);\n\tmemcpy(data, &type, sizeof(type));\n\n\tlen = htons(len);\n\tmemcpy(data + 2, &len, sizeof(len));\n\n\tmemcpy(data + 4, attrdata, data_len);\n\n\tpacket->size += 4 + data_len;\n\n\treturn 4 + data_len;\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos_before\\2016_8\\b9cede3c19693b7663219691d8604e037cea673a_before\\MAC-Telnet-b9cede3c19693b7663219691d8604e037cea673a\\protocol.c", "callees": ["fprintf", "memcpy", "htons"], "callers": []}], "functions_after": [{"name": "send_auth", "content": "static void send_auth(char *username, char *password) {\n\tstruct mt_packet data;\n\tunsigned short width = 0;\n\tunsigned short height = 0;\n\tchar *terminal = getenv(\"TERM\");\n\tchar md5data[100];\n\tunsigned char md5sum[17];\n\tint plen, act_pass_len;\n\tmd5_state_t state;\n\n#if defined(__linux__) && defined(_POSIX_MEMLOCK_RANGE)\n\tmlock(md5data, sizeof(md5data));\n\tmlock(md5sum, sizeof(md5data));\n#endif\n\n\t/* calculate the actual password's length */\n\tact_pass_len = strnlen(password, 82);\n\n\t/* Concat string of 0 + password + pass_salt */\n\tmd5data[0] = 0;\n\tmemcpy(md5data + 1, password, act_pass_len);\n\t/* in case that password is long, calculate only using the used-up parts */\n\tmemcpy(md5data + 1 + act_pass_len, pass_salt, 16);\n\n\t/* Generate md5 sum of md5data with a leading 0 */\n\tmd5_init(&state);\n\tmd5_append(&state, (const md5_byte_t *)md5data, 1 + act_pass_len + 16);\n\tmd5_finish(&state, (md5_byte_t *)md5sum + 1);\n\tmd5sum[0] = 0;\n\n\t/* Send combined packet to server */\n\tinit_packet(&data, MT_PTYPE_DATA, srcmac, dstmac, sessionkey, outcounter);\n\tplen = add_control_packet(&data, MT_CPTYPE_PASSWORD, md5sum, 17);\n\tplen += add_control_packet(&data, MT_CPTYPE_USERNAME, username, strlen(username));\n\tplen += add_control_packet(&data, MT_CPTYPE_TERM_TYPE, terminal, strlen(terminal));\n\t\n\tif (is_a_tty && get_terminal_size(&width, &height) != -1) {\n\t\twidth = htole16(width);\n\t\theight = htole16(height);\n\t\tplen += add_control_packet(&data, MT_CPTYPE_TERM_WIDTH, &width, 2);\n\t\tplen += add_control_packet(&data, MT_CPTYPE_TERM_HEIGHT, &height, 2);\n\t}\n\n\toutcounter += plen;\n\n\t/* TODO: handle result */\n\tsend_udp(&data, 1);\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos\\2016_8\\b69d11727d4f0f8cf719c79e3fb700f55ca03e9a_after\\MAC-Telnet-b69d11727d4f0f8cf719c79e3fb700f55ca03e9a\\mactelnet.c", "callees": ["md5_append", "md5_finish", "send_udp", "init_packet", "htole16", "md5_init", "getenv", "strlen", "get_terminal_size", "strnlen", "add_control_packet", "memcpy", "mlock"], "callers": ["handle_packet"]}, {"name": "handle_packet", "content": "static int handle_packet(unsigned char *data, int data_len) {\n\tstruct mt_mactelnet_hdr pkthdr;\n\n\t/* Minimal size checks (pings are not supported here) */\n\tif (data_len < MT_HEADER_LEN){\n\t\treturn -1;\n\t}\n\tparse_packet(data, &pkthdr);\n\n\t/* We only care about packets with correct sessionkey */\n\tif (pkthdr.seskey != sessionkey) {\n\t\treturn -1;\n\t}\n\n\t/* Handle data packets */\n\tif (pkthdr.ptype == MT_PTYPE_DATA) {\n\t\tstruct mt_packet odata;\n\t\tstruct mt_mactelnet_control_hdr cpkt;\n\t\tint success = 0;\n\n\t\t/* Always transmit ACKNOWLEDGE packets in response to DATA packets */\n\t\tinit_packet(&odata, MT_PTYPE_ACK, srcmac, dstmac, sessionkey, pkthdr.counter + (data_len - MT_HEADER_LEN));\n\t\tsend_udp(&odata, 0);\n\n\t\t/* Accept first packet, and all packets greater than incounter, and if counter has\n\t\twrapped around. */\n\t\tif (pkthdr.counter > incounter || (incounter - pkthdr.counter) > 65535) {\n\t\t\tincounter = pkthdr.counter;\n\t\t} else {\n\t\t\t/* Ignore double or old packets */\n\t\t\treturn -1;\n\t\t}\n\n\t\t/* Parse controlpacket data */\n\t\tsuccess = parse_control_packet(data + MT_HEADER_LEN, data_len - MT_HEADER_LEN, &cpkt);\n\n\t\twhile (success) {\n\n\t\t\t/* If we receive pass_salt, transmit auth data back */\n\t\t\tif (cpkt.cptype == MT_CPTYPE_PASSSALT) {\n\t\t\t\t/* check validity, server sends exactly 16 bytes */\n\t\t\t\tif (cpkt.length != 16) {\n\t\t\t\t\tfprintf(stderr, _(\"Invalid salt length: %d (instead of 16) received from server %s\\n\"), cpkt.length, ether_ntoa((struct ether_addr *)dstmac));\n\t\t\t\t}\n\t\t\t\tmemcpy(pass_salt, cpkt.data, 16);\n\t\t\t\tsend_auth(username, password);\n\t\t\t}\n\n\t\t\t/* If the (remaining) data did not have a control-packet magic byte sequence,\n\t\t\t   the data is raw terminal data to be outputted to the terminal. */\n\t\t\telse if (cpkt.cptype == MT_CPTYPE_PLAINDATA) {\n\t\t\t\tfwrite((const void *)cpkt.data, 1, cpkt.length, stdout);\n\t\t\t}\n\n\t\t\t/* END_AUTH means that the user/password negotiation is done, and after this point\n\t\t\t   terminal data may arrive, so we set up the terminal to raw mode. */\n\t\t\telse if (cpkt.cptype == MT_CPTYPE_END_AUTH) {\n\n\t\t\t\t/* we have entered \"terminal mode\" */\n\t\t\t\tterminal_mode = 1;\n\n\t\t\t\tif (is_a_tty) {\n\t\t\t\t\t/* stop input buffering at all levels. Give full control of terminal to RouterOS */\n\t\t\t\t\traw_term();\n\n\t\t\t\t\tsetvbuf(stdin,  (char*)NULL, _IONBF, 0);\n\n\t\t\t\t\t/* Add resize signal handler */\n\t\t\t\t\tsignal(SIGWINCH, sig_winch);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* Parse next controlpacket */\n\t\t\tsuccess = parse_control_packet(NULL, 0, &cpkt);\n\t\t}\n\t}\n\telse if (pkthdr.ptype == MT_PTYPE_ACK) {\n\t\t/* Handled elsewhere */\n\t}\n\n\t/* The server wants to terminate the connection, we have to oblige */\n\telse if (pkthdr.ptype == MT_PTYPE_END) {\n\t\tstruct mt_packet odata;\n\n\t\t/* Acknowledge the disconnection by sending a END packet in return */\n\t\tinit_packet(&odata, MT_PTYPE_END, srcmac, dstmac, pkthdr.seskey, 0);\n\t\tsend_udp(&odata, 0);\n\n\t\tif (!quiet_mode) {\n\t\t\tfprintf(stderr, _(\"Connection closed.\\n\"));\n\t\t}\n\n\t\t/* exit */\n\t\trunning = 0;\n\t} else {\n\t\tfprintf(stderr, _(\"Unhandeled packet type: %d received from server %s\\n\"), pkthdr.ptype, ether_ntoa((struct ether_addr *)dstmac));\n\t\treturn -1;\n\t}\n\n\treturn pkthdr.ptype;\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos\\2016_8\\b69d11727d4f0f8cf719c79e3fb700f55ca03e9a_after\\MAC-Telnet-b69d11727d4f0f8cf719c79e3fb700f55ca03e9a\\mactelnet.c", "callees": ["sig_winch", "fwrite", "send_udp", "fprintf", "init_packet", "send_auth", "parse_control_packet", "parse_packet", "signal", "setvbuf", "ether_ntoa", "raw_term", "memcpy"], "callers": []}, {"name": "user_login", "content": "static void user_login(struct mt_connection *curconn, struct mt_mactelnet_hdr *pkthdr) {\n\tstruct mt_packet pdata;\n\tunsigned char md5sum[17];\n\tchar md5data[100];\n\tstruct mt_credentials *user;\n\tchar *slavename;\n\tint act_pass_len;\n\n\t/* Reparse user file before each login */\n\tread_userfile();\n\n\tif ((user = find_user(curconn->username)) != NULL) {\n\t\tmd5_state_t state;\n#if defined(__linux__) && defined(_POSIX_MEMLOCK_RANGE)\n\t\tmlock(md5data, sizeof(md5data));\n\t\tmlock(md5sum, sizeof(md5sum));\n\t\tif (user->password != NULL) {\n\t\t\tmlock(user->password, strlen(user->password));\n\t\t}\n#endif\n\n\t\t/* calculate the password's actual length */\n\t\tact_pass_len = strlen(user->password);\n\t\tact_pass_len = act_pass_len <= 82 ? act_pass_len : 82;\n\n\t\t/* Concat string of 0 + password + pass_salt */\n\t\tmd5data[0] = 0;\n\t\tmemcpy(md5data + 1, user->password, act_pass_len);\n\t\tmemcpy(md5data + 1 + act_pass_len, curconn->pass_salt, 16);\n\n\t\t/* Generate md5 sum of md5data with a leading 0 */\n\t\tmd5_init(&state);\n\t\tmd5_append(&state, (const md5_byte_t *)md5data, 1 + act_pass_len + 16);\n\t\tmd5_finish(&state, (md5_byte_t *)md5sum + 1);\n\t\tmd5sum[0] = 0;\n\n\t\tinit_packet(&pdata, MT_PTYPE_DATA, pkthdr->dstaddr, pkthdr->srcaddr, pkthdr->seskey, curconn->outcounter);\n\t\tcurconn->outcounter += add_control_packet(&pdata, MT_CPTYPE_END_AUTH, NULL, 0);\n\t\tsend_udp(curconn, &pdata);\n\n\t\tif (curconn->state == STATE_ACTIVE) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (user == NULL || memcmp(md5sum, curconn->trypassword, 17) != 0) {\n\t\tsyslog(LOG_NOTICE, _(\"(%d) Invalid login by %s.\"), curconn->seskey, curconn->username);\n\n\t\t/*_ Please include both \\r and \\n in translation, this is needed for the terminal emulator. */\n\t\tabort_connection(curconn, pkthdr, _(\"Login failed, incorrect username or password\\r\\n\"));\n\n\t\t/* TODO: should wait some time (not with sleep) before returning, to minimalize brute force attacks */\n\t\treturn;\n\t}\n\n\t/* User is logged in */\n\tcurconn->state = STATE_ACTIVE;\n\n\t/* Enter terminal mode */\n\tcurconn->terminal_mode = 1;\n\n\t/* Open pts handle */\n\tcurconn->ptsfd = posix_openpt(O_RDWR);\n\tif (curconn->ptsfd == -1 || grantpt(curconn->ptsfd) == -1 || unlockpt(curconn->ptsfd) == -1) {\n\t\t\tsyslog(LOG_ERR, \"posix_openpt: %s\", strerror(errno));\n\t\t\t/*_ Please include both \\r and \\n in translation, this is needed for the terminal emulator. */\n\t\t\tabort_connection(curconn, pkthdr, _(\"Terminal error\\r\\n\"));\n\t\t\treturn;\n\t}\n\n\t/* Get file path for our pts */\n\tslavename = ptsname(curconn->ptsfd);\n\tif (slavename != NULL) {\n\t\tpid_t pid;\n\t\tstruct stat sb;\n\t\tstruct passwd *user = (struct passwd *)malloc(sizeof(struct passwd));\n\t\tstruct passwd *tmpuser=user;\n\t\tchar *buffer = malloc(1024);\n\n\t\tif (user == NULL || buffer == NULL) {\n\t\t\tsyslog(LOG_CRIT, _(\"(%d) Error allocating memory.\"), curconn->seskey);\n\t\t\t/*_ Please include both \\r and \\n in translation, this is needed for the terminal emulator. */\n\t\t\tabort_connection(curconn, pkthdr, _(\"System error, out of memory\\r\\n\"));\n\t\t\treturn;\n\t\t}\n\n\t\tif (getpwnam_r(curconn->username, user, buffer, 1024, &tmpuser) != 0) {\n\t\t\tsyslog(LOG_WARNING, _(\"(%d) Login ok, but local user not accessible (%s).\"), curconn->seskey, curconn->username);\n\t\t\t/*_ Please include both \\r and \\n in translation, this is needed for the terminal emulator. */\n\t\t\tabort_connection(curconn, pkthdr, _(\"Local user not accessible\\r\\n\"));\n\t\t\tfree(user);\n\t\t\tfree(buffer);\n\t\t\treturn;\n\t\t}\n\n\t\t/* Change the owner of the slave pts */\n\t\tchown(slavename, user->pw_uid, user->pw_gid);\n\n\t\tcurconn->slavefd = open(slavename, O_RDWR);\n\t\tif (curconn->slavefd == -1) {\n\t\t\tsyslog(LOG_ERR, _(\"Error opening %s: %s\"), slavename, strerror(errno));\n\t\t\t/*_ Please include both \\r and \\n in translation, this is needed for the terminal emulator. */\n\t\t\tabort_connection(curconn, pkthdr, _(\"Error opening terminal\\r\\n\"));\n\t\t\tlist_remove_connection(curconn);\n\t\t\treturn;\n\t\t}\n\n\t\tif ((pid = fork()) == 0) {\n\t\t\tstruct net_interface *interface;\n\n\t\t\t/* Add login information to utmp/wtmp */\n\t\t\tuwtmp_login(curconn);\n\n\t\t\tsyslog(LOG_INFO, _(\"(%d) User %s logged in.\"), curconn->seskey, curconn->username);\n\n\t\t\t/* Initialize terminal environment */\n\t\t\tsetenv(\"USER\", user->pw_name, 1);\n\t\t\tsetenv(\"HOME\", user->pw_dir, 1);\n\t\t\tsetenv(\"SHELL\", user->pw_shell, 1);\n\t\t\tsetenv(\"TERM\", curconn->terminal_type, 1);\n\t\t\tclose(sockfd);\n\t\t\tclose(insockfd);\n\n\t\t\tDL_FOREACH(interfaces, interface) {\n\t\t\t\tif (interface->socketfd > 0) {\n\t\t\t\t\tclose(interface->socketfd);\n\t\t\t\t}\n\t\t\t}\n\t\t\tsetsid();\n\n\t\t\t/* Don't let shell process inherit slavefd */\n\t\t\tfcntl (curconn->slavefd, F_SETFD, FD_CLOEXEC);\n\t\t\tclose(curconn->ptsfd);\n\n\t\t\t/* Redirect STDIN/STDIO/STDERR */\n\t\t\tclose(0);\n\t\t\tdup(curconn->slavefd);\n\t\t\tclose(1);\n\t\t\tdup(curconn->slavefd);\n\t\t\tclose(2);\n\t\t\tdup(curconn->slavefd);\n\n\t\t\t/* Set controlling terminal */\n\t\t\tioctl(0, TIOCSCTTY, 1);\n\t\t\ttcsetpgrp(0, getpid());\n\n\t\t\t/* Set user id/group id */\n\t\t\tif ((setgid(user->pw_gid) != 0) || (setuid(user->pw_uid) != 0)) {\n\t\t\t\tsyslog(LOG_ERR, _(\"(%d) Could not log in %s (%d:%d): setuid/setgid: %s\"), curconn->seskey, curconn->username, user->pw_uid, user->pw_gid, strerror(errno));\n\t\t\t\t/*_ Please include both \\r and \\n in translation, this is needed for the terminal emulator. */\n\t\t\t\tabort_connection(curconn, pkthdr, _(\"Internal error\\r\\n\"));\n\t\t\t\texit(0);\n\t\t\t}\n\n\t\t\t/* Abort login if /etc/nologin exists */\n\t\t\tif (stat(_PATH_NOLOGIN, &sb) == 0 && getuid() != 0) {\n\t\t\t\tsyslog(LOG_NOTICE, _(\"(%d) User %s disconnected with \" _PATH_NOLOGIN \" message.\"), curconn->seskey, curconn->username);\n\t\t\t\tdisplay_nologin();\n\t\t\t\tcurconn->state = STATE_CLOSED;\n\t\t\t\tinit_packet(&pdata, MT_PTYPE_END, pkthdr->dstaddr, pkthdr->srcaddr, pkthdr->seskey, curconn->outcounter);\n\t\t\t\tsend_udp(curconn, &pdata);\n\t\t\t\texit(0);\n\t\t\t}\n\n\t\t\t/* Display MOTD */\n\t\t\tdisplay_motd();\n\n\t\t\tchdir(user->pw_dir);\n\n\t\t\t/* Spawn shell */\n\t\t\t/* TODO: Maybe use \"login -f USER\" instead? renders motd and executes shell correctly for system */\n\t\t\texecl(user->pw_shell, user->pw_shell, \"-\", (char *) 0);\n\t\t\texit(0); // just to be sure.\n\t\t}\n\t\tfree(user);\n\t\tfree(buffer);\n\t\tclose(curconn->slavefd);\n\t\tcurconn->pid = pid;\n\t\tset_terminal_size(curconn->ptsfd, curconn->terminal_width, curconn->terminal_height);\n\t}\n\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos\\2016_8\\b69d11727d4f0f8cf719c79e3fb700f55ca03e9a_after\\MAC-Telnet-b69d11727d4f0f8cf719c79e3fb700f55ca03e9a\\mactelnetd.c", "callees": [], "callers": []}, {"name": "handle_data_packet", "content": "static void handle_data_packet(struct mt_connection *curconn, struct mt_mactelnet_hdr *pkthdr, int data_len) {\n\tstruct mt_mactelnet_control_hdr cpkt;\n\tstruct mt_packet pdata;\n\tunsigned char *data = pkthdr->data;\n\tunsigned int act_size = 0;\n\tint got_user_packet = 0;\n\tint got_pass_packet = 0;\n\tint got_width_packet = 0;\n\tint got_height_packet = 0;\n\tint success;\n\n\t/* Parse first control packet */\n\tsuccess = parse_control_packet(data, data_len - MT_HEADER_LEN, &cpkt);\n\n\twhile (success) {\n\t\tif (cpkt.cptype == MT_CPTYPE_BEGINAUTH) {\n\t\t\tint plen,i;\n\t\t\tif (!curconn->have_pass_salt) {\n\t\t\t\tfor (i = 0; i < 16; ++i) {\n\t\t\t\t\tcurconn->pass_salt[i] = rand() % 256;\n\t\t\t\t}\n\t\t\t\tcurconn->have_pass_salt = 1;\n\n\t\t\t\tmemset(curconn->trypassword, 0, sizeof(curconn->trypassword));\n\t\t\t}\n\t\t\tinit_packet(&pdata, MT_PTYPE_DATA, pkthdr->dstaddr, pkthdr->srcaddr, pkthdr->seskey, curconn->outcounter);\n\t\t\tplen = add_control_packet(&pdata, MT_CPTYPE_PASSSALT, (curconn->pass_salt), 16);\n\t\t\tcurconn->outcounter += plen;\n\n\t\t\tsend_udp(curconn, &pdata);\n\t\t\n\t\t/* Don't change the username after the state is active */\n\t\t} else if (cpkt.cptype == MT_CPTYPE_USERNAME && curconn->state != STATE_ACTIVE) {\n\t\t\tmemcpy(curconn->username, cpkt.data, act_size = (cpkt.length > MT_MNDP_MAX_STRING_SIZE - 1 ? MT_MNDP_MAX_STRING_SIZE - 1 : cpkt.length));\n\t\t\tcurconn->username[act_size] = 0;\n\t\t\tgot_user_packet = 1;\n\n\t\t} else if (cpkt.cptype == MT_CPTYPE_TERM_WIDTH && cpkt.length >= 2) {\n\t\t\tunsigned short width;\n\n\t\t\tmemcpy(&width, cpkt.data, 2);\n\t\t\tcurconn->terminal_width = le16toh(width);\n\t\t\tgot_width_packet = 1;\n\n\t\t} else if (cpkt.cptype == MT_CPTYPE_TERM_HEIGHT && cpkt.length >= 2) {\n\t\t\tunsigned short height;\n\n\t\t\tmemcpy(&height, cpkt.data, 2);\n\t\t\tcurconn->terminal_height = le16toh(height);\n\t\t\tgot_height_packet = 1;\n\n\t\t} else if (cpkt.cptype == MT_CPTYPE_TERM_TYPE) {\n\n\t\t\tmemcpy(curconn->terminal_type, cpkt.data, act_size = (cpkt.length > 30 - 1 ? 30 - 1 : cpkt.length));\n\t\t\tcurconn->terminal_type[act_size] = 0;\n\n\t\t} else if (cpkt.cptype == MT_CPTYPE_PASSWORD && cpkt.length == 17) {\n\n#if defined(__linux__) && defined(_POSIX_MEMLOCK_RANGE)\n\t\t\tmlock(curconn->trypassword, 17);\n#endif\n\t\t\tmemcpy(curconn->trypassword, cpkt.data, 17);\n\t\t\tgot_pass_packet = 1;\n\n\t\t} else if (cpkt.cptype == MT_CPTYPE_PLAINDATA) {\n\n\t\t\t/* relay data from client to shell */\n\t\t\tif (curconn->state == STATE_ACTIVE && curconn->ptsfd != -1) {\n\t\t\t\twrite(curconn->ptsfd, cpkt.data, cpkt.length);\n\t\t\t}\n\n\t\t} else {\n\t\t\tsyslog(LOG_WARNING, _(\"(%d) Unhandeled control packet type: %d, length: %d\"), curconn->seskey, cpkt.cptype, cpkt.length);\n\t\t}\n\n\t\t/* Parse next control packet */\n\t\tsuccess = parse_control_packet(NULL, 0, &cpkt);\n\t}\n\n\tif (got_user_packet && got_pass_packet) {\n\t\tuser_login(curconn, pkthdr);\n\t}\n\n\tif (curconn->state == STATE_ACTIVE && (got_width_packet || got_height_packet)) {\n\t\tset_terminal_size(curconn->ptsfd, curconn->terminal_width, curconn->terminal_height);\n\n\t}\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos\\2016_8\\b69d11727d4f0f8cf719c79e3fb700f55ca03e9a_after\\MAC-Telnet-b69d11727d4f0f8cf719c79e3fb700f55ca03e9a\\mactelnetd.c", "callees": [], "callers": []}, {"name": "add_control_packet", "content": "int add_control_packet(struct mt_packet *packet, enum mt_cptype cptype, void *cpdata, unsigned short data_len) {\n\tunsigned char *data = packet->data + packet->size;\n\tunsigned int act_size = data_len + (cptype == MT_CPTYPE_PLAINDATA ? 0 : MT_CPHEADER_LEN);\n\n\t/* Something is really wrong. Packets should never become over 1500 bytes,\n       perform an Integer-Overflow safe check */\n\tif (act_size > MT_PACKET_LEN - packet->size) {\n\t\tfprintf(stderr, _(\"add_control_packet: ERROR, too large packet. Exceeds %d bytes\\n\"), MT_PACKET_LEN);\n\t\treturn -1;\n\t\t//exit(1);\n\t}\n\n\t/* PLAINDATA isn't really a controlpacket, but we handle it here, since\n\t   parseControlPacket also parses raw data as PLAINDATA */\n\tif (cptype == MT_CPTYPE_PLAINDATA) {\n\t\tmemcpy(data, cpdata, data_len);\n\t\tpacket->size += data_len;\n\t\treturn data_len;\n\t}\n\n\t/* Control Packet Magic id */\n\tmemcpy(data, mt_mactelnet_cpmagic, sizeof(mt_mactelnet_cpmagic));\n\n\t/* Control packet type */\n\tdata[4] = cptype;\n\n\t/* Data length */\n#if BYTE_ORDER == LITTLE_ENDIAN\n\t{\n\t\tunsigned int templen;\n\t\ttemplen = htonl(data_len);\n\t\tmemcpy(data + 5, &templen, sizeof(templen));\n\t}\n#else\n\tmemcpy(data + 5, &data_len, sizeof(data_len));\n#endif\n\n\t/* Insert data */\n\tif (data_len > 0) {\n\t\tmemcpy(data + MT_CPHEADER_LEN, cpdata, data_len);\n\t}\n\n\tpacket->size += act_size;\n\t/* Control packet header length + data length */\n\treturn act_size;\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos\\2016_8\\b69d11727d4f0f8cf719c79e3fb700f55ca03e9a_after\\MAC-Telnet-b69d11727d4f0f8cf719c79e3fb700f55ca03e9a\\protocol.c", "callees": ["fprintf", "htonl", "memcpy"], "callers": ["send_auth"]}, {"name": "add_packetdata", "content": "int add_packetdata(struct mt_packet *packet, unsigned char *data, unsigned short length) {\n\t/* Integer-Overflow safe check */\n\tif (length > MT_PACKET_LEN - packet->size) {\n\t\tfprintf(stderr, _(\"add_control_packet: ERROR, too large packet. Exceeds %d bytes\\n\"), MT_PACKET_LEN);\n\t\treturn -1;\n\t}\n\n\tmemcpy(packet->data + packet->size, data, length);\n\tpacket->size += length;\n\n\treturn length;\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos\\2016_8\\b69d11727d4f0f8cf719c79e3fb700f55ca03e9a_after\\MAC-Telnet-b69d11727d4f0f8cf719c79e3fb700f55ca03e9a\\protocol.c", "callees": ["fprintf", "memcpy"], "callers": []}, {"name": "mndp_add_attribute", "content": "int mndp_add_attribute(struct mt_packet *packet, enum mt_mndp_attrtype attrtype, void *attrdata, unsigned short data_len) {\n\tunsigned char *data = packet->data + packet->size;\n\tunsigned short type = attrtype;\n\tunsigned short len = data_len;\n\n\t/* Something is really wrong. Packets should never become over 1500 bytes */\n\tif (data_len > MT_PACKET_LEN - 4 - packet->size) {\n\t\tfprintf(stderr, _(\"mndp_add_attribute: ERROR, too large packet. Exceeds %d bytes\\n\"), MT_PACKET_LEN);\n\t\treturn -1;\n\t}\n\n\ttype = htons(type);\n\tmemcpy(data, &type, sizeof(type));\n\n\tlen = htons(len);\n\tmemcpy(data + 2, &len, sizeof(len));\n\n\tmemcpy(data + 4, attrdata, data_len);\n\n\tpacket->size += 4 + data_len;\n\n\treturn 4 + data_len;\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos\\2016_8\\b69d11727d4f0f8cf719c79e3fb700f55ca03e9a_after\\MAC-Telnet-b69d11727d4f0f8cf719c79e3fb700f55ca03e9a\\protocol.c", "callees": ["fprintf", "memcpy", "htons"], "callers": []}], "callerTree_before": {"send_auth": ["md5_append", "md5_finish", "strncpy", "send_udp", "init_packet", "htole16", "md5_init", "getenv", "strlen", "get_terminal_size", "add_control_packet", "memcpy", "mlock"], "handle_packet": ["sig_winch", "fwrite", "send_udp", "fprintf", "init_packet", "send_auth", "parse_control_packet", "parse_packet", "signal", "setvbuf", "ether_ntoa", "raw_term", "memcpy"], "add_control_packet": ["fprintf", "htonl", "memcpy"], "add_packetdata": ["fprintf", "memcpy"], "mndp_add_attribute": ["fprintf", "memcpy", "htons"]}, "calleeTree_before": {"getenv": ["send_auth"], "mlock": ["send_auth"], "strncpy": ["send_auth"], "memcpy": ["handle_packet", "send_auth", "mndp_add_attribute", "add_control_packet", "add_packetdata"], "strlen": ["send_auth"], "md5_init": ["send_auth"], "md5_append": ["send_auth"], "md5_finish": ["send_auth"], "init_packet": ["send_auth", "handle_packet"], "add_control_packet": ["send_auth"], "get_terminal_size": ["send_auth"], "htole16": ["send_auth"], "send_udp": ["send_auth", "handle_packet"], "parse_packet": ["handle_packet"], "parse_control_packet": ["handle_packet"], "send_auth": ["handle_packet"], "fwrite": ["handle_packet"], "raw_term": ["handle_packet"], "setvbuf": ["handle_packet"], "signal": ["handle_packet"], "sig_winch": ["handle_packet"], "fprintf": ["add_control_packet", "mndp_add_attribute", "add_packetdata", "handle_packet"], "ether_ntoa": ["handle_packet"], "htonl": ["add_control_packet"], "htons": ["mndp_add_attribute"]}, "callerTree_after": {"send_auth": ["md5_append", "md5_finish", "send_udp", "init_packet", "htole16", "md5_init", "getenv", "strlen", "get_terminal_size", "strnlen", "add_control_packet", "memcpy", "mlock"], "handle_packet": ["sig_winch", "fwrite", "send_udp", "fprintf", "init_packet", "send_auth", "parse_control_packet", "parse_packet", "signal", "setvbuf", "ether_ntoa", "raw_term", "memcpy"], "add_control_packet": ["fprintf", "htonl", "memcpy"], "add_packetdata": ["fprintf", "memcpy"], "mndp_add_attribute": ["fprintf", "memcpy", "htons"]}, "calleeTree_after": {"getenv": ["send_auth"], "mlock": ["send_auth"], "strnlen": ["send_auth"], "memcpy": ["handle_packet", "send_auth", "mndp_add_attribute", "add_control_packet", "add_packetdata"], "md5_init": ["send_auth"], "md5_append": ["send_auth"], "md5_finish": ["send_auth"], "init_packet": ["send_auth", "handle_packet"], "add_control_packet": ["send_auth"], "strlen": ["send_auth"], "get_terminal_size": ["send_auth"], "htole16": ["send_auth"], "send_udp": ["send_auth", "handle_packet"], "parse_packet": ["handle_packet"], "parse_control_packet": ["handle_packet"], "fprintf": ["add_control_packet", "mndp_add_attribute", "add_packetdata", "handle_packet"], "ether_ntoa": ["handle_packet"], "send_auth": ["handle_packet"], "fwrite": ["handle_packet"], "raw_term": ["handle_packet"], "setvbuf": ["handle_packet"], "signal": ["handle_packet"], "sig_winch": ["handle_packet"], "htonl": ["add_control_packet"], "htons": ["mndp_add_attribute"]}}
{"repo_after": "4dc1a2d7931017d3625f2d7cff70a17ce58b53b4", "repo_before": "b083ec17ad9cba4ad9fe7fac1c6a168d90dd1a31", "functions_before": [{"name": "gdCtxPrintf", "content": "static void gdCtxPrintf(gdIOCtx * out, const char *format, ...)\n{\n\tchar buf[4096];\n\tint len;\n\tva_list args;\n\n\tva_start(args, format);\n\tlen = vsnprintf(buf, sizeof(buf)-1, format, args);\n\tva_end(args);\n\tout->putBuf(out, buf, len);\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos_before\\2016_8\\b083ec17ad9cba4ad9fe7fac1c6a168d90dd1a31_before\\libgd-b083ec17ad9cba4ad9fe7fac1c6a168d90dd1a31\\src\\gd_xbm.c", "callees": ["va_end", "vsnprintf", "va_start"], "callers": []}, {"name": "gdImageXbmCtx", "content": "BGD_DECLARE(void) gdImageXbmCtx(gdImagePtr image, char* file_name, int fg, gdIOCtx * out)\n{\n\tint x, y, c, b, sx, sy, p;\n\tchar *name, *f;\n\tsize_t i, l;\n\n\tname = file_name;\n\tif ((f = strrchr(name, '/')) != NULL) name = f+1;\n\tif ((f = strrchr(name, '\\\\')) != NULL) name = f+1;\n\tname = strdup(name);\n\tif ((f = strrchr(name, '.')) != NULL && !strcasecmp(f, \".XBM\")) *f = '\\0';\n\tif ((l = strlen(name)) == 0) {\n\t\tfree(name);\n\t\tname = strdup(\"image\");\n\t} else {\n\t\tfor (i=0; i<l; i++) {\n\t\t\t/* only in C-locale isalnum() would work */\n\t\t\tif (!isupper(name[i]) && !islower(name[i]) && !isdigit(name[i])) {\n\t\t\t\tname[i] = '_';\n\t\t\t}\n\t\t}\n\t}\n\n\tgdCtxPrintf(out, \"#define %s_width %d\\n\", name, gdImageSX(image));\n\tgdCtxPrintf(out, \"#define %s_height %d\\n\", name, gdImageSY(image));\n\tgdCtxPrintf(out, \"static unsigned char %s_bits[] = {\\n  \", name);\n\n\tfree(name);\n\n\tb = 1;\n\tp = 0;\n\tc = 0;\n\tsx = gdImageSX(image);\n\tsy = gdImageSY(image);\n\tfor (y = 0; y < sy; y++) {\n\t\tfor (x = 0; x < sx; x++) {\n\t\t\tif (gdImageGetPixel(image, x, y) == fg) {\n\t\t\t\tc |= b;\n\t\t\t}\n\t\t\tif ((b == 128) || (x == sx && y == sy)) {\n\t\t\t\tb = 1;\n\t\t\t\tif (p) {\n\t\t\t\t\tgdCtxPrintf(out, \", \");\n\t\t\t\t\tif (!(p%12)) {\n\t\t\t\t\t\tgdCtxPrintf(out, \"\\n  \");\n\t\t\t\t\t\tp = 12;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tp++;\n\t\t\t\tgdCtxPrintf(out, \"0x%02X\", c);\n\t\t\t\tc = 0;\n\t\t\t} else {\n\t\t\t\tb <<= 1;\n\t\t\t}\n\t\t}\n\t}\n\tgdCtxPrintf(out, \"};\\n\");\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos_before\\2016_8\\b083ec17ad9cba4ad9fe7fac1c6a168d90dd1a31_before\\libgd-b083ec17ad9cba4ad9fe7fac1c6a168d90dd1a31\\src\\gd_xbm.c", "callees": [], "callers": []}], "functions_after": [{"name": "gdCtxPrintf", "content": "static void gdCtxPrintf(gdIOCtx * out, const char *format, ...)\n{\n\tchar buf[1024];\n\tint len;\n\tva_list args;\n\n\tva_start(args, format);\n\tlen = vsnprintf(buf, sizeof(buf)-1, format, args);\n\tva_end(args);\n\tout->putBuf(out, buf, len);\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos\\2016_8\\4dc1a2d7931017d3625f2d7cff70a17ce58b53b4_after\\libgd-4dc1a2d7931017d3625f2d7cff70a17ce58b53b4\\src\\gd_xbm.c", "callees": ["va_end", "vsnprintf", "va_start"], "callers": []}, {"name": "gdImageXbmCtx", "content": "BGD_DECLARE(void) gdImageXbmCtx(gdImagePtr image, char* file_name, int fg, gdIOCtx * out)\n{\n\tint x, y, c, b, sx, sy, p;\n\tchar *name, *f;\n\tsize_t i, l;\n\n\tname = file_name;\n\tif ((f = strrchr(name, '/')) != NULL) name = f+1;\n\tif ((f = strrchr(name, '\\\\')) != NULL) name = f+1;\n\tname = strdup(name);\n\tif ((f = strrchr(name, '.')) != NULL && !strcasecmp(f, \".XBM\")) *f = '\\0';\n\tif ((l = strlen(name)) == 0) {\n\t\tfree(name);\n\t\tname = strdup(\"image\");\n\t} else {\n\t\tfor (i=0; i<l; i++) {\n\t\t\t/* only in C-locale isalnum() would work */\n\t\t\tif (!isupper(name[i]) && !islower(name[i]) && !isdigit(name[i])) {\n\t\t\t\tname[i] = '_';\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Since \"name\" comes from the user, run it through a direct puts.\n\t * Trying to printf it into a local buffer means we'd need a large\n\t * or dynamic buffer to hold it all. */\n\n\t/* #define <name>_width 1234 */\n\tgdCtxPuts(out, \"#define \");\n\tgdCtxPuts(out, name);\n\tgdCtxPuts(out, \"_width \");\n\tgdCtxPrintf(out, \"%d\\n\", gdImageSX(image));\n\n\t/* #define <name>_height 1234 */\n\tgdCtxPuts(out, \"#define \");\n\tgdCtxPuts(out, name);\n\tgdCtxPuts(out, \"_height \");\n\tgdCtxPrintf(out, \"%d\\n\", gdImageSY(image));\n\n\t/* static unsigned char <name>_bits[] = {\\n */\n\tgdCtxPuts(out, \"static unsigned char \");\n\tgdCtxPuts(out, name);\n\tgdCtxPuts(out, \"_bits[] = {\\n  \");\n\n\tfree(name);\n\n\tb = 1;\n\tp = 0;\n\tc = 0;\n\tsx = gdImageSX(image);\n\tsy = gdImageSY(image);\n\tfor (y = 0; y < sy; y++) {\n\t\tfor (x = 0; x < sx; x++) {\n\t\t\tif (gdImageGetPixel(image, x, y) == fg) {\n\t\t\t\tc |= b;\n\t\t\t}\n\t\t\tif ((b == 128) || (x == sx && y == sy)) {\n\t\t\t\tb = 1;\n\t\t\t\tif (p) {\n\t\t\t\t\tgdCtxPuts(out, \", \");\n\t\t\t\t\tif (!(p%12)) {\n\t\t\t\t\t\tgdCtxPuts(out, \"\\n  \");\n\t\t\t\t\t\tp = 12;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tp++;\n\t\t\t\tgdCtxPrintf(out, \"0x%02X\", c);\n\t\t\t\tc = 0;\n\t\t\t} else {\n\t\t\t\tb <<= 1;\n\t\t\t}\n\t\t}\n\t}\n\tgdCtxPuts(out, \"};\\n\");\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos\\2016_8\\4dc1a2d7931017d3625f2d7cff70a17ce58b53b4_after\\libgd-4dc1a2d7931017d3625f2d7cff70a17ce58b53b4\\src\\gd_xbm.c", "callees": [], "callers": []}], "callerTree_before": {"gdCtxPrintf": ["va_end", "vsnprintf", "va_start"]}, "calleeTree_before": {"va_start": ["gdCtxPrintf"], "vsnprintf": ["gdCtxPrintf"], "va_end": ["gdCtxPrintf"]}, "callerTree_after": {"gdCtxPrintf": ["va_end", "vsnprintf", "va_start"]}, "calleeTree_after": {"va_start": ["gdCtxPrintf"], "vsnprintf": ["gdCtxPrintf"], "va_end": ["gdCtxPrintf"]}}
{"repo_after": "fcd135c9df440bcd2d5870405ad3311743d78d97", "repo_before": "324583e8fb3935690be58790425793df619c6d4d", "functions_before": [{"name": "auth_password", "content": "int\nauth_password(Authctxt *authctxt, const char *password)\n{\n\tstruct passwd * pw = authctxt->pw;\n\tint result, ok = authctxt->valid;\n#if defined(USE_SHADOW) && defined(HAS_SHADOW_EXPIRE)\n\tstatic int expire_checked = 0;\n#endif\n\n#ifndef HAVE_CYGWIN\n\tif (pw->pw_uid == 0 && options.permit_root_login != PERMIT_YES)\n\t\tok = 0;\n#endif\n\tif (*password == '\\0' && options.permit_empty_passwd == 0)\n\t\treturn 0;\n\n#ifdef KRB5\n\tif (options.kerberos_authentication == 1) {\n\t\tint ret = auth_krb5_password(authctxt, password);\n\t\tif (ret == 1 || ret == 0)\n\t\t\treturn ret && ok;\n\t\t/* Fall back to ordinary passwd authentication. */\n\t}\n#endif\n#ifdef HAVE_CYGWIN\n\t{\n\t\tHANDLE hToken = cygwin_logon_user(pw, password);\n\n\t\tif (hToken == INVALID_HANDLE_VALUE)\n\t\t\treturn 0;\n\t\tcygwin_set_impersonation_token(hToken);\n\t\treturn ok;\n\t}\n#endif\n#ifdef USE_PAM\n\tif (options.use_pam)\n\t\treturn (sshpam_auth_passwd(authctxt, password) && ok);\n#endif\n#if defined(USE_SHADOW) && defined(HAS_SHADOW_EXPIRE)\n\tif (!expire_checked) {\n\t\texpire_checked = 1;\n\t\tif (auth_shadow_pwexpired(authctxt))\n\t\t\tauthctxt->force_pwchange = 1;\n\t}\n#endif\n\tresult = sys_auth_passwd(authctxt, password);\n\tif (authctxt->force_pwchange)\n\t\tdisable_forwarding();\n\treturn (result && ok);\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos_before\\2016_8\\324583e8fb3935690be58790425793df619c6d4d_before\\openssh-portable-324583e8fb3935690be58790425793df619c6d4d\\auth-passwd.c", "callees": ["cygwin_logon_user", "auth_krb5_password", "disable_forwarding", "sshpam_auth_passwd", "auth_shadow_pwexpired", "cygwin_set_impersonation_token", "sys_auth_passwd"], "callers": []}], "functions_after": [{"name": "auth_password", "content": "int\nauth_password(Authctxt *authctxt, const char *password)\n{\n\tstruct passwd * pw = authctxt->pw;\n\tint result, ok = authctxt->valid;\n#if defined(USE_SHADOW) && defined(HAS_SHADOW_EXPIRE)\n\tstatic int expire_checked = 0;\n#endif\n\n\tif (strlen(password) > MAX_PASSWORD_LEN)\n\t\treturn 0;\n\n#ifndef HAVE_CYGWIN\n\tif (pw->pw_uid == 0 && options.permit_root_login != PERMIT_YES)\n\t\tok = 0;\n#endif\n\tif (*password == '\\0' && options.permit_empty_passwd == 0)\n\t\treturn 0;\n\n#ifdef KRB5\n\tif (options.kerberos_authentication == 1) {\n\t\tint ret = auth_krb5_password(authctxt, password);\n\t\tif (ret == 1 || ret == 0)\n\t\t\treturn ret && ok;\n\t\t/* Fall back to ordinary passwd authentication. */\n\t}\n#endif\n#ifdef HAVE_CYGWIN\n\t{\n\t\tHANDLE hToken = cygwin_logon_user(pw, password);\n\n\t\tif (hToken == INVALID_HANDLE_VALUE)\n\t\t\treturn 0;\n\t\tcygwin_set_impersonation_token(hToken);\n\t\treturn ok;\n\t}\n#endif\n#ifdef USE_PAM\n\tif (options.use_pam)\n\t\treturn (sshpam_auth_passwd(authctxt, password) && ok);\n#endif\n#if defined(USE_SHADOW) && defined(HAS_SHADOW_EXPIRE)\n\tif (!expire_checked) {\n\t\texpire_checked = 1;\n\t\tif (auth_shadow_pwexpired(authctxt))\n\t\t\tauthctxt->force_pwchange = 1;\n\t}\n#endif\n\tresult = sys_auth_passwd(authctxt, password);\n\tif (authctxt->force_pwchange)\n\t\tdisable_forwarding();\n\treturn (result && ok);\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos\\2016_8\\fcd135c9df440bcd2d5870405ad3311743d78d97_after\\openssh-portable-fcd135c9df440bcd2d5870405ad3311743d78d97\\auth-passwd.c", "callees": ["cygwin_logon_user", "auth_krb5_password", "disable_forwarding", "sshpam_auth_passwd", "auth_shadow_pwexpired", "cygwin_set_impersonation_token", "sys_auth_passwd", "strlen"], "callers": []}], "callerTree_before": {"auth_password": ["cygwin_logon_user", "auth_krb5_password", "disable_forwarding", "sshpam_auth_passwd", "auth_shadow_pwexpired", "cygwin_set_impersonation_token", "sys_auth_passwd"]}, "calleeTree_before": {"auth_krb5_password": ["auth_password"], "cygwin_logon_user": ["auth_password"], "cygwin_set_impersonation_token": ["auth_password"], "sshpam_auth_passwd": ["auth_password"], "auth_shadow_pwexpired": ["auth_password"], "sys_auth_passwd": ["auth_password"], "disable_forwarding": ["auth_password"]}, "callerTree_after": {"auth_password": ["cygwin_logon_user", "auth_krb5_password", "disable_forwarding", "sshpam_auth_passwd", "auth_shadow_pwexpired", "cygwin_set_impersonation_token", "sys_auth_passwd", "strlen"]}, "calleeTree_after": {"strlen": ["auth_password"], "auth_krb5_password": ["auth_password"], "cygwin_logon_user": ["auth_password"], "cygwin_set_impersonation_token": ["auth_password"], "sshpam_auth_passwd": ["auth_password"], "auth_shadow_pwexpired": ["auth_password"], "sys_auth_passwd": ["auth_password"], "disable_forwarding": ["auth_password"]}}
{"repo_after": "b69d11727d4f0f8cf719c79e3fb700f55ca03e9a", "repo_before": "b9cede3c19693b7663219691d8604e037cea673a", "functions_before": [{"name": "send_auth", "content": "static void send_auth(char *username, char *password) {\n\tstruct mt_packet data;\n\tunsigned short width = 0;\n\tunsigned short height = 0;\n\tchar *terminal = getenv(\"TERM\");\n\tchar md5data[100];\n\tunsigned char md5sum[17];\n\tint plen;\n\tmd5_state_t state;\n\n#if defined(__linux__) && defined(_POSIX_MEMLOCK_RANGE)\n\tmlock(md5data, sizeof(md5data));\n\tmlock(md5sum, sizeof(md5data));\n#endif\n\n\t/* Concat string of 0 + password + pass_salt */\n\tmd5data[0] = 0;\n\tstrncpy(md5data + 1, password, 82);\n\tmd5data[83] = '\\0';\n\tmemcpy(md5data + 1 + strlen(password), pass_salt, 16);\n\n\t/* Generate md5 sum of md5data with a leading 0 */\n\tmd5_init(&state);\n\tmd5_append(&state, (const md5_byte_t *)md5data, strlen(password) + 17);\n\tmd5_finish(&state, (md5_byte_t *)md5sum + 1);\n\tmd5sum[0] = 0;\n\n\t/* Send combined packet to server */\n\tinit_packet(&data, MT_PTYPE_DATA, srcmac, dstmac, sessionkey, outcounter);\n\tplen = add_control_packet(&data, MT_CPTYPE_PASSWORD, md5sum, 17);\n\tplen += add_control_packet(&data, MT_CPTYPE_USERNAME, username, strlen(username));\n\tplen += add_control_packet(&data, MT_CPTYPE_TERM_TYPE, terminal, strlen(terminal));\n\t\n\tif (is_a_tty && get_terminal_size(&width, &height) != -1) {\n\t\twidth = htole16(width);\n\t\theight = htole16(height);\n\t\tplen += add_control_packet(&data, MT_CPTYPE_TERM_WIDTH, &width, 2);\n\t\tplen += add_control_packet(&data, MT_CPTYPE_TERM_HEIGHT, &height, 2);\n\t}\n\n\toutcounter += plen;\n\n\t/* TODO: handle result */\n\tsend_udp(&data, 1);\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos_before\\2016_8\\b9cede3c19693b7663219691d8604e037cea673a_before\\MAC-Telnet-b9cede3c19693b7663219691d8604e037cea673a\\mactelnet.c", "callees": ["md5_append", "md5_finish", "strncpy", "send_udp", "init_packet", "htole16", "md5_init", "getenv", "strlen", "get_terminal_size", "add_control_packet", "memcpy", "mlock"], "callers": ["handle_packet"]}, {"name": "handle_packet", "content": "static int handle_packet(unsigned char *data, int data_len) {\n\tstruct mt_mactelnet_hdr pkthdr;\n\n\t/* Minimal size checks (pings are not supported here) */\n\tif (data_len < MT_HEADER_LEN){\n\t\treturn -1;\n\t}\n\tparse_packet(data, &pkthdr);\n\n\t/* We only care about packets with correct sessionkey */\n\tif (pkthdr.seskey != sessionkey) {\n\t\treturn -1;\n\t}\n\n\t/* Handle data packets */\n\tif (pkthdr.ptype == MT_PTYPE_DATA) {\n\t\tstruct mt_packet odata;\n\t\tstruct mt_mactelnet_control_hdr cpkt;\n\t\tint success = 0;\n\n\t\t/* Always transmit ACKNOWLEDGE packets in response to DATA packets */\n\t\tinit_packet(&odata, MT_PTYPE_ACK, srcmac, dstmac, sessionkey, pkthdr.counter + (data_len - MT_HEADER_LEN));\n\t\tsend_udp(&odata, 0);\n\n\t\t/* Accept first packet, and all packets greater than incounter, and if counter has\n\t\twrapped around. */\n\t\tif (pkthdr.counter > incounter || (incounter - pkthdr.counter) > 65535) {\n\t\t\tincounter = pkthdr.counter;\n\t\t} else {\n\t\t\t/* Ignore double or old packets */\n\t\t\treturn -1;\n\t\t}\n\n\t\t/* Parse controlpacket data */\n\t\tsuccess = parse_control_packet(data + MT_HEADER_LEN, data_len - MT_HEADER_LEN, &cpkt);\n\n\t\twhile (success) {\n\n\t\t\t/* If we receive pass_salt, transmit auth data back */\n\t\t\tif (cpkt.cptype == MT_CPTYPE_PASSSALT) {\n\t\t\t\tmemcpy(pass_salt, cpkt.data, cpkt.length);\n\t\t\t\tsend_auth(username, password);\n\t\t\t}\n\n\t\t\t/* If the (remaining) data did not have a control-packet magic byte sequence,\n\t\t\t   the data is raw terminal data to be outputted to the terminal. */\n\t\t\telse if (cpkt.cptype == MT_CPTYPE_PLAINDATA) {\n\t\t\t\tfwrite((const void *)cpkt.data, 1, cpkt.length, stdout);\n\t\t\t}\n\n\t\t\t/* END_AUTH means that the user/password negotiation is done, and after this point\n\t\t\t   terminal data may arrive, so we set up the terminal to raw mode. */\n\t\t\telse if (cpkt.cptype == MT_CPTYPE_END_AUTH) {\n\n\t\t\t\t/* we have entered \"terminal mode\" */\n\t\t\t\tterminal_mode = 1;\n\n\t\t\t\tif (is_a_tty) {\n\t\t\t\t\t/* stop input buffering at all levels. Give full control of terminal to RouterOS */\n\t\t\t\t\traw_term();\n\n\t\t\t\t\tsetvbuf(stdin,  (char*)NULL, _IONBF, 0);\n\n\t\t\t\t\t/* Add resize signal handler */\n\t\t\t\t\tsignal(SIGWINCH, sig_winch);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* Parse next controlpacket */\n\t\t\tsuccess = parse_control_packet(NULL, 0, &cpkt);\n\t\t}\n\t}\n\telse if (pkthdr.ptype == MT_PTYPE_ACK) {\n\t\t/* Handled elsewhere */\n\t}\n\n\t/* The server wants to terminate the connection, we have to oblige */\n\telse if (pkthdr.ptype == MT_PTYPE_END) {\n\t\tstruct mt_packet odata;\n\n\t\t/* Acknowledge the disconnection by sending a END packet in return */\n\t\tinit_packet(&odata, MT_PTYPE_END, srcmac, dstmac, pkthdr.seskey, 0);\n\t\tsend_udp(&odata, 0);\n\n\t\tif (!quiet_mode) {\n\t\t\tfprintf(stderr, _(\"Connection closed.\\n\"));\n\t\t}\n\n\t\t/* exit */\n\t\trunning = 0;\n\t} else {\n\t\tfprintf(stderr, _(\"Unhandeled packet type: %d received from server %s\\n\"), pkthdr.ptype, ether_ntoa((struct ether_addr *)dstmac));\n\t\treturn -1;\n\t}\n\n\treturn pkthdr.ptype;\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos_before\\2016_8\\b9cede3c19693b7663219691d8604e037cea673a_before\\MAC-Telnet-b9cede3c19693b7663219691d8604e037cea673a\\mactelnet.c", "callees": ["sig_winch", "fwrite", "send_udp", "fprintf", "init_packet", "send_auth", "parse_control_packet", "parse_packet", "signal", "setvbuf", "ether_ntoa", "raw_term", "memcpy"], "callers": []}, {"name": "user_login", "content": "static void user_login(struct mt_connection *curconn, struct mt_mactelnet_hdr *pkthdr) {\n\tstruct mt_packet pdata;\n\tunsigned char md5sum[17];\n\tchar md5data[100];\n\tstruct mt_credentials *user;\n\tchar *slavename;\n\n\t/* Reparse user file before each login */\n\tread_userfile();\n\n\tif ((user = find_user(curconn->username)) != NULL) {\n\t\tmd5_state_t state;\n#if defined(__linux__) && defined(_POSIX_MEMLOCK_RANGE)\n\t\tmlock(md5data, sizeof(md5data));\n\t\tmlock(md5sum, sizeof(md5sum));\n\t\tif (user->password != NULL) {\n\t\t\tmlock(user->password, strlen(user->password));\n\t\t}\n#endif\n\n\t\t/* Concat string of 0 + password + pass_salt */\n\t\tmd5data[0] = 0;\n\t\tstrncpy(md5data + 1, user->password, 82);\n\t\tmemcpy(md5data + 1 + strlen(user->password), curconn->pass_salt, 16);\n\n\t\t/* Generate md5 sum of md5data with a leading 0 */\n\t\tmd5_init(&state);\n\t\tmd5_append(&state, (const md5_byte_t *)md5data, strlen(user->password) + 17);\n\t\tmd5_finish(&state, (md5_byte_t *)md5sum + 1);\n\t\tmd5sum[0] = 0;\n\n\t\tinit_packet(&pdata, MT_PTYPE_DATA, pkthdr->dstaddr, pkthdr->srcaddr, pkthdr->seskey, curconn->outcounter);\n\t\tcurconn->outcounter += add_control_packet(&pdata, MT_CPTYPE_END_AUTH, NULL, 0);\n\t\tsend_udp(curconn, &pdata);\n\n\t\tif (curconn->state == STATE_ACTIVE) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (user == NULL || memcmp(md5sum, curconn->trypassword, 17) != 0) {\n\t\tsyslog(LOG_NOTICE, _(\"(%d) Invalid login by %s.\"), curconn->seskey, curconn->username);\n\n\t\t/*_ Please include both \\r and \\n in translation, this is needed for the terminal emulator. */\n\t\tabort_connection(curconn, pkthdr, _(\"Login failed, incorrect username or password\\r\\n\"));\n\n\t\t/* TODO: should wait some time (not with sleep) before returning, to minimalize brute force attacks */\n\t\treturn;\n\t}\n\n\t/* User is logged in */\n\tcurconn->state = STATE_ACTIVE;\n\n\t/* Enter terminal mode */\n\tcurconn->terminal_mode = 1;\n\n\t/* Open pts handle */\n\tcurconn->ptsfd = posix_openpt(O_RDWR);\n\tif (curconn->ptsfd == -1 || grantpt(curconn->ptsfd) == -1 || unlockpt(curconn->ptsfd) == -1) {\n\t\t\tsyslog(LOG_ERR, \"posix_openpt: %s\", strerror(errno));\n\t\t\t/*_ Please include both \\r and \\n in translation, this is needed for the terminal emulator. */\n\t\t\tabort_connection(curconn, pkthdr, _(\"Terminal error\\r\\n\"));\n\t\t\treturn;\n\t}\n\n\t/* Get file path for our pts */\n\tslavename = ptsname(curconn->ptsfd);\n\tif (slavename != NULL) {\n\t\tpid_t pid;\n\t\tstruct stat sb;\n\t\tstruct passwd *user = (struct passwd *)malloc(sizeof(struct passwd));\n\t\tstruct passwd *tmpuser=user;\n\t\tchar *buffer = malloc(1024);\n\n\t\tif (user == NULL || buffer == NULL) {\n\t\t\tsyslog(LOG_CRIT, _(\"(%d) Error allocating memory.\"), curconn->seskey);\n\t\t\t/*_ Please include both \\r and \\n in translation, this is needed for the terminal emulator. */\n\t\t\tabort_connection(curconn, pkthdr, _(\"System error, out of memory\\r\\n\"));\n\t\t\treturn;\n\t\t}\n\n\t\tif (getpwnam_r(curconn->username, user, buffer, 1024, &tmpuser) != 0) {\n\t\t\tsyslog(LOG_WARNING, _(\"(%d) Login ok, but local user not accessible (%s).\"), curconn->seskey, curconn->username);\n\t\t\t/*_ Please include both \\r and \\n in translation, this is needed for the terminal emulator. */\n\t\t\tabort_connection(curconn, pkthdr, _(\"Local user not accessible\\r\\n\"));\n\t\t\tfree(user);\n\t\t\tfree(buffer);\n\t\t\treturn;\n\t\t}\n\n\t\t/* Change the owner of the slave pts */\n\t\tchown(slavename, user->pw_uid, user->pw_gid);\n\n\t\tcurconn->slavefd = open(slavename, O_RDWR);\n\t\tif (curconn->slavefd == -1) {\n\t\t\tsyslog(LOG_ERR, _(\"Error opening %s: %s\"), slavename, strerror(errno));\n\t\t\t/*_ Please include both \\r and \\n in translation, this is needed for the terminal emulator. */\n\t\t\tabort_connection(curconn, pkthdr, _(\"Error opening terminal\\r\\n\"));\n\t\t\tlist_remove_connection(curconn);\n\t\t\treturn;\n\t\t}\n\n\t\tif ((pid = fork()) == 0) {\n\t\t\tstruct net_interface *interface;\n\n\t\t\t/* Add login information to utmp/wtmp */\n\t\t\tuwtmp_login(curconn);\n\n\t\t\tsyslog(LOG_INFO, _(\"(%d) User %s logged in.\"), curconn->seskey, curconn->username);\n\n\t\t\t/* Initialize terminal environment */\n\t\t\tsetenv(\"USER\", user->pw_name, 1);\n\t\t\tsetenv(\"HOME\", user->pw_dir, 1);\n\t\t\tsetenv(\"SHELL\", user->pw_shell, 1);\n\t\t\tsetenv(\"TERM\", curconn->terminal_type, 1);\n\t\t\tclose(sockfd);\n\t\t\tclose(insockfd);\n\n\t\t\tDL_FOREACH(interfaces, interface) {\n\t\t\t\tif (interface->socketfd > 0) {\n\t\t\t\t\tclose(interface->socketfd);\n\t\t\t\t}\n\t\t\t}\n\t\t\tsetsid();\n\n\t\t\t/* Don't let shell process inherit slavefd */\n\t\t\tfcntl (curconn->slavefd, F_SETFD, FD_CLOEXEC);\n\t\t\tclose(curconn->ptsfd);\n\n\t\t\t/* Redirect STDIN/STDIO/STDERR */\n\t\t\tclose(0);\n\t\t\tdup(curconn->slavefd);\n\t\t\tclose(1);\n\t\t\tdup(curconn->slavefd);\n\t\t\tclose(2);\n\t\t\tdup(curconn->slavefd);\n\n\t\t\t/* Set controlling terminal */\n\t\t\tioctl(0, TIOCSCTTY, 1);\n\t\t\ttcsetpgrp(0, getpid());\n\n\t\t\t/* Set user id/group id */\n\t\t\tif ((setgid(user->pw_gid) != 0) || (setuid(user->pw_uid) != 0)) {\n\t\t\t\tsyslog(LOG_ERR, _(\"(%d) Could not log in %s (%d:%d): setuid/setgid: %s\"), curconn->seskey, curconn->username, user->pw_uid, user->pw_gid, strerror(errno));\n\t\t\t\t/*_ Please include both \\r and \\n in translation, this is needed for the terminal emulator. */\n\t\t\t\tabort_connection(curconn, pkthdr, _(\"Internal error\\r\\n\"));\n\t\t\t\texit(0);\n\t\t\t}\n\n\t\t\t/* Abort login if /etc/nologin exists */\n\t\t\tif (stat(_PATH_NOLOGIN, &sb) == 0 && getuid() != 0) {\n\t\t\t\tsyslog(LOG_NOTICE, _(\"(%d) User %s disconnected with \" _PATH_NOLOGIN \" message.\"), curconn->seskey, curconn->username);\n\t\t\t\tdisplay_nologin();\n\t\t\t\tcurconn->state = STATE_CLOSED;\n\t\t\t\tinit_packet(&pdata, MT_PTYPE_END, pkthdr->dstaddr, pkthdr->srcaddr, pkthdr->seskey, curconn->outcounter);\n\t\t\t\tsend_udp(curconn, &pdata);\n\t\t\t\texit(0);\n\t\t\t}\n\n\t\t\t/* Display MOTD */\n\t\t\tdisplay_motd();\n\n\t\t\tchdir(user->pw_dir);\n\n\t\t\t/* Spawn shell */\n\t\t\t/* TODO: Maybe use \"login -f USER\" instead? renders motd and executes shell correctly for system */\n\t\t\texecl(user->pw_shell, user->pw_shell, \"-\", (char *) 0);\n\t\t\texit(0); // just to be sure.\n\t\t}\n\t\tfree(user);\n\t\tfree(buffer);\n\t\tclose(curconn->slavefd);\n\t\tcurconn->pid = pid;\n\t\tset_terminal_size(curconn->ptsfd, curconn->terminal_width, curconn->terminal_height);\n\t}\n\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos_before\\2016_8\\b9cede3c19693b7663219691d8604e037cea673a_before\\MAC-Telnet-b9cede3c19693b7663219691d8604e037cea673a\\mactelnetd.c", "callees": [], "callers": []}, {"name": "handle_data_packet", "content": "static void handle_data_packet(struct mt_connection *curconn, struct mt_mactelnet_hdr *pkthdr, int data_len) {\n\tstruct mt_mactelnet_control_hdr cpkt;\n\tstruct mt_packet pdata;\n\tunsigned char *data = pkthdr->data;\n\tunsigned int act_size = 0;\n\tint got_user_packet = 0;\n\tint got_pass_packet = 0;\n\tint got_width_packet = 0;\n\tint got_height_packet = 0;\n\tint success;\n\n\t/* Parse first control packet */\n\tsuccess = parse_control_packet(data, data_len - MT_HEADER_LEN, &cpkt);\n\n\twhile (success) {\n\t\tif (cpkt.cptype == MT_CPTYPE_BEGINAUTH) {\n\t\t\tint plen,i;\n\t\t\tif (!curconn->have_pass_salt) {\n\t\t\t\tfor (i = 0; i < 16; ++i) {\n\t\t\t\t\tcurconn->pass_salt[i] = rand() % 256;\n\t\t\t\t}\n\t\t\t\tcurconn->have_pass_salt = 1;\n\n\t\t\t\tmemset(curconn->trypassword, 0, sizeof(curconn->trypassword));\n\t\t\t}\n\t\t\tinit_packet(&pdata, MT_PTYPE_DATA, pkthdr->dstaddr, pkthdr->srcaddr, pkthdr->seskey, curconn->outcounter);\n\t\t\tplen = add_control_packet(&pdata, MT_CPTYPE_PASSSALT, (curconn->pass_salt), 16);\n\t\t\tcurconn->outcounter += plen;\n\n\t\t\tsend_udp(curconn, &pdata);\n\t\t\n\t\t/* Don't change the username after the state is active */\n\t\t} else if (cpkt.cptype == MT_CPTYPE_USERNAME && curconn->state != STATE_ACTIVE) {\n\t\t\tmemcpy(curconn->username, cpkt.data, act_size = (cpkt.length > MT_MNDP_MAX_STRING_SIZE - 1 ? MT_MNDP_MAX_STRING_SIZE - 1 : cpkt.length));\n\t\t\tcurconn->username[act_size] = 0;\n\t\t\tgot_user_packet = 1;\n\n\t\t} else if (cpkt.cptype == MT_CPTYPE_TERM_WIDTH && cpkt.length >= 2) {\n\t\t\tunsigned short width;\n\n\t\t\tmemcpy(&width, cpkt.data, 2);\n\t\t\tcurconn->terminal_width = le16toh(width);\n\t\t\tgot_width_packet = 1;\n\n\t\t} else if (cpkt.cptype == MT_CPTYPE_TERM_HEIGHT && cpkt.length >= 2) {\n\t\t\tunsigned short height;\n\n\t\t\tmemcpy(&height, cpkt.data, 2);\n\t\t\tcurconn->terminal_height = le16toh(height);\n\t\t\tgot_height_packet = 1;\n\n\t\t} else if (cpkt.cptype == MT_CPTYPE_TERM_TYPE) {\n\n\t\t\tmemcpy(curconn->terminal_type, cpkt.data, act_size = (cpkt.length > 30 - 1 ? 30 - 1 : cpkt.length));\n\t\t\tcurconn->terminal_type[act_size] = 0;\n\n\t\t} else if (cpkt.cptype == MT_CPTYPE_PASSWORD) {\n\n#if defined(__linux__) && defined(_POSIX_MEMLOCK_RANGE)\n\t\t\tmlock(curconn->trypassword, 17);\n#endif\n\t\t\tmemcpy(curconn->trypassword, cpkt.data, 17);\n\t\t\tgot_pass_packet = 1;\n\n\t\t} else if (cpkt.cptype == MT_CPTYPE_PLAINDATA) {\n\n\t\t\t/* relay data from client to shell */\n\t\t\tif (curconn->state == STATE_ACTIVE && curconn->ptsfd != -1) {\n\t\t\t\twrite(curconn->ptsfd, cpkt.data, cpkt.length);\n\t\t\t}\n\n\t\t} else {\n\t\t\tsyslog(LOG_WARNING, _(\"(%d) Unhandeled control packet type: %d\"), curconn->seskey, cpkt.cptype);\n\t\t}\n\n\t\t/* Parse next control packet */\n\t\tsuccess = parse_control_packet(NULL, 0, &cpkt);\n\t}\n\n\tif (got_user_packet && got_pass_packet) {\n\t\tuser_login(curconn, pkthdr);\n\t}\n\n\tif (curconn->state == STATE_ACTIVE && (got_width_packet || got_height_packet)) {\n\t\tset_terminal_size(curconn->ptsfd, curconn->terminal_width, curconn->terminal_height);\n\n\t}\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos_before\\2016_8\\b9cede3c19693b7663219691d8604e037cea673a_before\\MAC-Telnet-b9cede3c19693b7663219691d8604e037cea673a\\mactelnetd.c", "callees": [], "callers": []}, {"name": "add_control_packet", "content": "int add_control_packet(struct mt_packet *packet, enum mt_cptype cptype, void *cpdata, unsigned short data_len) {\n\tunsigned char *data = packet->data + packet->size;\n\tunsigned int act_size = data_len + (cptype == MT_CPTYPE_PLAINDATA ? 0 : MT_CPHEADER_LEN);\n\n\t/* Something is really wrong. Packets should never become over 1500 bytes */\n\tif (packet->size + act_size > MT_PACKET_LEN) {\n\t\tfprintf(stderr, _(\"add_control_packet: ERROR, too large packet. Exceeds %d bytes\\n\"), MT_PACKET_LEN);\n\t\treturn -1;\n\t\t//exit(1);\n\t}\n\n\t/* PLAINDATA isn't really a controlpacket, but we handle it here, since\n\t   parseControlPacket also parses raw data as PLAINDATA */\n\tif (cptype == MT_CPTYPE_PLAINDATA) {\n\t\tmemcpy(data, cpdata, data_len);\n\t\tpacket->size += data_len;\n\t\treturn data_len;\n\t}\n\n\t/* Control Packet Magic id */\n\tmemcpy(data, mt_mactelnet_cpmagic, sizeof(mt_mactelnet_cpmagic));\n\n\t/* Control packet type */\n\tdata[4] = cptype;\n\n\t/* Data length */\n#if BYTE_ORDER == LITTLE_ENDIAN\n\t{\n\t\tunsigned int templen;\n\t\ttemplen = htonl(data_len);\n\t\tmemcpy(data + 5, &templen, sizeof(templen));\n\t}\n#else\n\tmemcpy(data + 5, &data_len, sizeof(data_len));\n#endif\n\n\t/* Insert data */\n\tif (data_len > 0) {\n\t\tmemcpy(data + MT_CPHEADER_LEN, cpdata, data_len);\n\t}\n\n\tpacket->size += act_size;\n\t/* Control packet header length + data length */\n\treturn act_size;\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos_before\\2016_8\\b9cede3c19693b7663219691d8604e037cea673a_before\\MAC-Telnet-b9cede3c19693b7663219691d8604e037cea673a\\protocol.c", "callees": ["fprintf", "htonl", "memcpy"], "callers": ["send_auth"]}, {"name": "add_packetdata", "content": "int add_packetdata(struct mt_packet *packet, unsigned char *data, unsigned short length) {\n\tif (packet->size + length > MT_PACKET_LEN) {\n\t\tfprintf(stderr, _(\"add_control_packet: ERROR, too large packet. Exceeds %d bytes\\n\"), MT_PACKET_LEN);\n\t\treturn -1;\n\t}\n\n\tmemcpy(packet->data + packet->size, data, length);\n\tpacket->size += length;\n\n\treturn length;\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos_before\\2016_8\\b9cede3c19693b7663219691d8604e037cea673a_before\\MAC-Telnet-b9cede3c19693b7663219691d8604e037cea673a\\protocol.c", "callees": ["fprintf", "memcpy"], "callers": []}, {"name": "mndp_add_attribute", "content": "int mndp_add_attribute(struct mt_packet *packet, enum mt_mndp_attrtype attrtype, void *attrdata, unsigned short data_len) {\n\tunsigned char *data = packet->data + packet->size;\n\tunsigned short type = attrtype;\n\tunsigned short len = data_len;\n\n\t/* Something is really wrong. Packets should never become over 1500 bytes */\n\tif (packet->size + 4 + data_len > MT_PACKET_LEN) {\n\t\tfprintf(stderr, _(\"mndp_add_attribute: ERROR, too large packet. Exceeds %d bytes\\n\"), MT_PACKET_LEN);\n\t\treturn -1;\n\t}\n\n\ttype = htons(type);\n\tmemcpy(data, &type, sizeof(type));\n\n\tlen = htons(len);\n\tmemcpy(data + 2, &len, sizeof(len));\n\n\tmemcpy(data + 4, attrdata, data_len);\n\n\tpacket->size += 4 + data_len;\n\n\treturn 4 + data_len;\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos_before\\2016_8\\b9cede3c19693b7663219691d8604e037cea673a_before\\MAC-Telnet-b9cede3c19693b7663219691d8604e037cea673a\\protocol.c", "callees": ["fprintf", "memcpy", "htons"], "callers": []}], "functions_after": [{"name": "send_auth", "content": "static void send_auth(char *username, char *password) {\n\tstruct mt_packet data;\n\tunsigned short width = 0;\n\tunsigned short height = 0;\n\tchar *terminal = getenv(\"TERM\");\n\tchar md5data[100];\n\tunsigned char md5sum[17];\n\tint plen, act_pass_len;\n\tmd5_state_t state;\n\n#if defined(__linux__) && defined(_POSIX_MEMLOCK_RANGE)\n\tmlock(md5data, sizeof(md5data));\n\tmlock(md5sum, sizeof(md5data));\n#endif\n\n\t/* calculate the actual password's length */\n\tact_pass_len = strnlen(password, 82);\n\n\t/* Concat string of 0 + password + pass_salt */\n\tmd5data[0] = 0;\n\tmemcpy(md5data + 1, password, act_pass_len);\n\t/* in case that password is long, calculate only using the used-up parts */\n\tmemcpy(md5data + 1 + act_pass_len, pass_salt, 16);\n\n\t/* Generate md5 sum of md5data with a leading 0 */\n\tmd5_init(&state);\n\tmd5_append(&state, (const md5_byte_t *)md5data, 1 + act_pass_len + 16);\n\tmd5_finish(&state, (md5_byte_t *)md5sum + 1);\n\tmd5sum[0] = 0;\n\n\t/* Send combined packet to server */\n\tinit_packet(&data, MT_PTYPE_DATA, srcmac, dstmac, sessionkey, outcounter);\n\tplen = add_control_packet(&data, MT_CPTYPE_PASSWORD, md5sum, 17);\n\tplen += add_control_packet(&data, MT_CPTYPE_USERNAME, username, strlen(username));\n\tplen += add_control_packet(&data, MT_CPTYPE_TERM_TYPE, terminal, strlen(terminal));\n\t\n\tif (is_a_tty && get_terminal_size(&width, &height) != -1) {\n\t\twidth = htole16(width);\n\t\theight = htole16(height);\n\t\tplen += add_control_packet(&data, MT_CPTYPE_TERM_WIDTH, &width, 2);\n\t\tplen += add_control_packet(&data, MT_CPTYPE_TERM_HEIGHT, &height, 2);\n\t}\n\n\toutcounter += plen;\n\n\t/* TODO: handle result */\n\tsend_udp(&data, 1);\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos\\2016_8\\b69d11727d4f0f8cf719c79e3fb700f55ca03e9a_after\\MAC-Telnet-b69d11727d4f0f8cf719c79e3fb700f55ca03e9a\\mactelnet.c", "callees": ["md5_append", "md5_finish", "send_udp", "init_packet", "htole16", "md5_init", "getenv", "strlen", "get_terminal_size", "strnlen", "add_control_packet", "memcpy", "mlock"], "callers": ["handle_packet"]}, {"name": "handle_packet", "content": "static int handle_packet(unsigned char *data, int data_len) {\n\tstruct mt_mactelnet_hdr pkthdr;\n\n\t/* Minimal size checks (pings are not supported here) */\n\tif (data_len < MT_HEADER_LEN){\n\t\treturn -1;\n\t}\n\tparse_packet(data, &pkthdr);\n\n\t/* We only care about packets with correct sessionkey */\n\tif (pkthdr.seskey != sessionkey) {\n\t\treturn -1;\n\t}\n\n\t/* Handle data packets */\n\tif (pkthdr.ptype == MT_PTYPE_DATA) {\n\t\tstruct mt_packet odata;\n\t\tstruct mt_mactelnet_control_hdr cpkt;\n\t\tint success = 0;\n\n\t\t/* Always transmit ACKNOWLEDGE packets in response to DATA packets */\n\t\tinit_packet(&odata, MT_PTYPE_ACK, srcmac, dstmac, sessionkey, pkthdr.counter + (data_len - MT_HEADER_LEN));\n\t\tsend_udp(&odata, 0);\n\n\t\t/* Accept first packet, and all packets greater than incounter, and if counter has\n\t\twrapped around. */\n\t\tif (pkthdr.counter > incounter || (incounter - pkthdr.counter) > 65535) {\n\t\t\tincounter = pkthdr.counter;\n\t\t} else {\n\t\t\t/* Ignore double or old packets */\n\t\t\treturn -1;\n\t\t}\n\n\t\t/* Parse controlpacket data */\n\t\tsuccess = parse_control_packet(data + MT_HEADER_LEN, data_len - MT_HEADER_LEN, &cpkt);\n\n\t\twhile (success) {\n\n\t\t\t/* If we receive pass_salt, transmit auth data back */\n\t\t\tif (cpkt.cptype == MT_CPTYPE_PASSSALT) {\n\t\t\t\t/* check validity, server sends exactly 16 bytes */\n\t\t\t\tif (cpkt.length != 16) {\n\t\t\t\t\tfprintf(stderr, _(\"Invalid salt length: %d (instead of 16) received from server %s\\n\"), cpkt.length, ether_ntoa((struct ether_addr *)dstmac));\n\t\t\t\t}\n\t\t\t\tmemcpy(pass_salt, cpkt.data, 16);\n\t\t\t\tsend_auth(username, password);\n\t\t\t}\n\n\t\t\t/* If the (remaining) data did not have a control-packet magic byte sequence,\n\t\t\t   the data is raw terminal data to be outputted to the terminal. */\n\t\t\telse if (cpkt.cptype == MT_CPTYPE_PLAINDATA) {\n\t\t\t\tfwrite((const void *)cpkt.data, 1, cpkt.length, stdout);\n\t\t\t}\n\n\t\t\t/* END_AUTH means that the user/password negotiation is done, and after this point\n\t\t\t   terminal data may arrive, so we set up the terminal to raw mode. */\n\t\t\telse if (cpkt.cptype == MT_CPTYPE_END_AUTH) {\n\n\t\t\t\t/* we have entered \"terminal mode\" */\n\t\t\t\tterminal_mode = 1;\n\n\t\t\t\tif (is_a_tty) {\n\t\t\t\t\t/* stop input buffering at all levels. Give full control of terminal to RouterOS */\n\t\t\t\t\traw_term();\n\n\t\t\t\t\tsetvbuf(stdin,  (char*)NULL, _IONBF, 0);\n\n\t\t\t\t\t/* Add resize signal handler */\n\t\t\t\t\tsignal(SIGWINCH, sig_winch);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* Parse next controlpacket */\n\t\t\tsuccess = parse_control_packet(NULL, 0, &cpkt);\n\t\t}\n\t}\n\telse if (pkthdr.ptype == MT_PTYPE_ACK) {\n\t\t/* Handled elsewhere */\n\t}\n\n\t/* The server wants to terminate the connection, we have to oblige */\n\telse if (pkthdr.ptype == MT_PTYPE_END) {\n\t\tstruct mt_packet odata;\n\n\t\t/* Acknowledge the disconnection by sending a END packet in return */\n\t\tinit_packet(&odata, MT_PTYPE_END, srcmac, dstmac, pkthdr.seskey, 0);\n\t\tsend_udp(&odata, 0);\n\n\t\tif (!quiet_mode) {\n\t\t\tfprintf(stderr, _(\"Connection closed.\\n\"));\n\t\t}\n\n\t\t/* exit */\n\t\trunning = 0;\n\t} else {\n\t\tfprintf(stderr, _(\"Unhandeled packet type: %d received from server %s\\n\"), pkthdr.ptype, ether_ntoa((struct ether_addr *)dstmac));\n\t\treturn -1;\n\t}\n\n\treturn pkthdr.ptype;\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos\\2016_8\\b69d11727d4f0f8cf719c79e3fb700f55ca03e9a_after\\MAC-Telnet-b69d11727d4f0f8cf719c79e3fb700f55ca03e9a\\mactelnet.c", "callees": ["sig_winch", "fwrite", "send_udp", "fprintf", "init_packet", "send_auth", "parse_control_packet", "parse_packet", "signal", "setvbuf", "ether_ntoa", "raw_term", "memcpy"], "callers": []}, {"name": "user_login", "content": "static void user_login(struct mt_connection *curconn, struct mt_mactelnet_hdr *pkthdr) {\n\tstruct mt_packet pdata;\n\tunsigned char md5sum[17];\n\tchar md5data[100];\n\tstruct mt_credentials *user;\n\tchar *slavename;\n\tint act_pass_len;\n\n\t/* Reparse user file before each login */\n\tread_userfile();\n\n\tif ((user = find_user(curconn->username)) != NULL) {\n\t\tmd5_state_t state;\n#if defined(__linux__) && defined(_POSIX_MEMLOCK_RANGE)\n\t\tmlock(md5data, sizeof(md5data));\n\t\tmlock(md5sum, sizeof(md5sum));\n\t\tif (user->password != NULL) {\n\t\t\tmlock(user->password, strlen(user->password));\n\t\t}\n#endif\n\n\t\t/* calculate the password's actual length */\n\t\tact_pass_len = strlen(user->password);\n\t\tact_pass_len = act_pass_len <= 82 ? act_pass_len : 82;\n\n\t\t/* Concat string of 0 + password + pass_salt */\n\t\tmd5data[0] = 0;\n\t\tmemcpy(md5data + 1, user->password, act_pass_len);\n\t\tmemcpy(md5data + 1 + act_pass_len, curconn->pass_salt, 16);\n\n\t\t/* Generate md5 sum of md5data with a leading 0 */\n\t\tmd5_init(&state);\n\t\tmd5_append(&state, (const md5_byte_t *)md5data, 1 + act_pass_len + 16);\n\t\tmd5_finish(&state, (md5_byte_t *)md5sum + 1);\n\t\tmd5sum[0] = 0;\n\n\t\tinit_packet(&pdata, MT_PTYPE_DATA, pkthdr->dstaddr, pkthdr->srcaddr, pkthdr->seskey, curconn->outcounter);\n\t\tcurconn->outcounter += add_control_packet(&pdata, MT_CPTYPE_END_AUTH, NULL, 0);\n\t\tsend_udp(curconn, &pdata);\n\n\t\tif (curconn->state == STATE_ACTIVE) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (user == NULL || memcmp(md5sum, curconn->trypassword, 17) != 0) {\n\t\tsyslog(LOG_NOTICE, _(\"(%d) Invalid login by %s.\"), curconn->seskey, curconn->username);\n\n\t\t/*_ Please include both \\r and \\n in translation, this is needed for the terminal emulator. */\n\t\tabort_connection(curconn, pkthdr, _(\"Login failed, incorrect username or password\\r\\n\"));\n\n\t\t/* TODO: should wait some time (not with sleep) before returning, to minimalize brute force attacks */\n\t\treturn;\n\t}\n\n\t/* User is logged in */\n\tcurconn->state = STATE_ACTIVE;\n\n\t/* Enter terminal mode */\n\tcurconn->terminal_mode = 1;\n\n\t/* Open pts handle */\n\tcurconn->ptsfd = posix_openpt(O_RDWR);\n\tif (curconn->ptsfd == -1 || grantpt(curconn->ptsfd) == -1 || unlockpt(curconn->ptsfd) == -1) {\n\t\t\tsyslog(LOG_ERR, \"posix_openpt: %s\", strerror(errno));\n\t\t\t/*_ Please include both \\r and \\n in translation, this is needed for the terminal emulator. */\n\t\t\tabort_connection(curconn, pkthdr, _(\"Terminal error\\r\\n\"));\n\t\t\treturn;\n\t}\n\n\t/* Get file path for our pts */\n\tslavename = ptsname(curconn->ptsfd);\n\tif (slavename != NULL) {\n\t\tpid_t pid;\n\t\tstruct stat sb;\n\t\tstruct passwd *user = (struct passwd *)malloc(sizeof(struct passwd));\n\t\tstruct passwd *tmpuser=user;\n\t\tchar *buffer = malloc(1024);\n\n\t\tif (user == NULL || buffer == NULL) {\n\t\t\tsyslog(LOG_CRIT, _(\"(%d) Error allocating memory.\"), curconn->seskey);\n\t\t\t/*_ Please include both \\r and \\n in translation, this is needed for the terminal emulator. */\n\t\t\tabort_connection(curconn, pkthdr, _(\"System error, out of memory\\r\\n\"));\n\t\t\treturn;\n\t\t}\n\n\t\tif (getpwnam_r(curconn->username, user, buffer, 1024, &tmpuser) != 0) {\n\t\t\tsyslog(LOG_WARNING, _(\"(%d) Login ok, but local user not accessible (%s).\"), curconn->seskey, curconn->username);\n\t\t\t/*_ Please include both \\r and \\n in translation, this is needed for the terminal emulator. */\n\t\t\tabort_connection(curconn, pkthdr, _(\"Local user not accessible\\r\\n\"));\n\t\t\tfree(user);\n\t\t\tfree(buffer);\n\t\t\treturn;\n\t\t}\n\n\t\t/* Change the owner of the slave pts */\n\t\tchown(slavename, user->pw_uid, user->pw_gid);\n\n\t\tcurconn->slavefd = open(slavename, O_RDWR);\n\t\tif (curconn->slavefd == -1) {\n\t\t\tsyslog(LOG_ERR, _(\"Error opening %s: %s\"), slavename, strerror(errno));\n\t\t\t/*_ Please include both \\r and \\n in translation, this is needed for the terminal emulator. */\n\t\t\tabort_connection(curconn, pkthdr, _(\"Error opening terminal\\r\\n\"));\n\t\t\tlist_remove_connection(curconn);\n\t\t\treturn;\n\t\t}\n\n\t\tif ((pid = fork()) == 0) {\n\t\t\tstruct net_interface *interface;\n\n\t\t\t/* Add login information to utmp/wtmp */\n\t\t\tuwtmp_login(curconn);\n\n\t\t\tsyslog(LOG_INFO, _(\"(%d) User %s logged in.\"), curconn->seskey, curconn->username);\n\n\t\t\t/* Initialize terminal environment */\n\t\t\tsetenv(\"USER\", user->pw_name, 1);\n\t\t\tsetenv(\"HOME\", user->pw_dir, 1);\n\t\t\tsetenv(\"SHELL\", user->pw_shell, 1);\n\t\t\tsetenv(\"TERM\", curconn->terminal_type, 1);\n\t\t\tclose(sockfd);\n\t\t\tclose(insockfd);\n\n\t\t\tDL_FOREACH(interfaces, interface) {\n\t\t\t\tif (interface->socketfd > 0) {\n\t\t\t\t\tclose(interface->socketfd);\n\t\t\t\t}\n\t\t\t}\n\t\t\tsetsid();\n\n\t\t\t/* Don't let shell process inherit slavefd */\n\t\t\tfcntl (curconn->slavefd, F_SETFD, FD_CLOEXEC);\n\t\t\tclose(curconn->ptsfd);\n\n\t\t\t/* Redirect STDIN/STDIO/STDERR */\n\t\t\tclose(0);\n\t\t\tdup(curconn->slavefd);\n\t\t\tclose(1);\n\t\t\tdup(curconn->slavefd);\n\t\t\tclose(2);\n\t\t\tdup(curconn->slavefd);\n\n\t\t\t/* Set controlling terminal */\n\t\t\tioctl(0, TIOCSCTTY, 1);\n\t\t\ttcsetpgrp(0, getpid());\n\n\t\t\t/* Set user id/group id */\n\t\t\tif ((setgid(user->pw_gid) != 0) || (setuid(user->pw_uid) != 0)) {\n\t\t\t\tsyslog(LOG_ERR, _(\"(%d) Could not log in %s (%d:%d): setuid/setgid: %s\"), curconn->seskey, curconn->username, user->pw_uid, user->pw_gid, strerror(errno));\n\t\t\t\t/*_ Please include both \\r and \\n in translation, this is needed for the terminal emulator. */\n\t\t\t\tabort_connection(curconn, pkthdr, _(\"Internal error\\r\\n\"));\n\t\t\t\texit(0);\n\t\t\t}\n\n\t\t\t/* Abort login if /etc/nologin exists */\n\t\t\tif (stat(_PATH_NOLOGIN, &sb) == 0 && getuid() != 0) {\n\t\t\t\tsyslog(LOG_NOTICE, _(\"(%d) User %s disconnected with \" _PATH_NOLOGIN \" message.\"), curconn->seskey, curconn->username);\n\t\t\t\tdisplay_nologin();\n\t\t\t\tcurconn->state = STATE_CLOSED;\n\t\t\t\tinit_packet(&pdata, MT_PTYPE_END, pkthdr->dstaddr, pkthdr->srcaddr, pkthdr->seskey, curconn->outcounter);\n\t\t\t\tsend_udp(curconn, &pdata);\n\t\t\t\texit(0);\n\t\t\t}\n\n\t\t\t/* Display MOTD */\n\t\t\tdisplay_motd();\n\n\t\t\tchdir(user->pw_dir);\n\n\t\t\t/* Spawn shell */\n\t\t\t/* TODO: Maybe use \"login -f USER\" instead? renders motd and executes shell correctly for system */\n\t\t\texecl(user->pw_shell, user->pw_shell, \"-\", (char *) 0);\n\t\t\texit(0); // just to be sure.\n\t\t}\n\t\tfree(user);\n\t\tfree(buffer);\n\t\tclose(curconn->slavefd);\n\t\tcurconn->pid = pid;\n\t\tset_terminal_size(curconn->ptsfd, curconn->terminal_width, curconn->terminal_height);\n\t}\n\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos\\2016_8\\b69d11727d4f0f8cf719c79e3fb700f55ca03e9a_after\\MAC-Telnet-b69d11727d4f0f8cf719c79e3fb700f55ca03e9a\\mactelnetd.c", "callees": [], "callers": []}, {"name": "handle_data_packet", "content": "static void handle_data_packet(struct mt_connection *curconn, struct mt_mactelnet_hdr *pkthdr, int data_len) {\n\tstruct mt_mactelnet_control_hdr cpkt;\n\tstruct mt_packet pdata;\n\tunsigned char *data = pkthdr->data;\n\tunsigned int act_size = 0;\n\tint got_user_packet = 0;\n\tint got_pass_packet = 0;\n\tint got_width_packet = 0;\n\tint got_height_packet = 0;\n\tint success;\n\n\t/* Parse first control packet */\n\tsuccess = parse_control_packet(data, data_len - MT_HEADER_LEN, &cpkt);\n\n\twhile (success) {\n\t\tif (cpkt.cptype == MT_CPTYPE_BEGINAUTH) {\n\t\t\tint plen,i;\n\t\t\tif (!curconn->have_pass_salt) {\n\t\t\t\tfor (i = 0; i < 16; ++i) {\n\t\t\t\t\tcurconn->pass_salt[i] = rand() % 256;\n\t\t\t\t}\n\t\t\t\tcurconn->have_pass_salt = 1;\n\n\t\t\t\tmemset(curconn->trypassword, 0, sizeof(curconn->trypassword));\n\t\t\t}\n\t\t\tinit_packet(&pdata, MT_PTYPE_DATA, pkthdr->dstaddr, pkthdr->srcaddr, pkthdr->seskey, curconn->outcounter);\n\t\t\tplen = add_control_packet(&pdata, MT_CPTYPE_PASSSALT, (curconn->pass_salt), 16);\n\t\t\tcurconn->outcounter += plen;\n\n\t\t\tsend_udp(curconn, &pdata);\n\t\t\n\t\t/* Don't change the username after the state is active */\n\t\t} else if (cpkt.cptype == MT_CPTYPE_USERNAME && curconn->state != STATE_ACTIVE) {\n\t\t\tmemcpy(curconn->username, cpkt.data, act_size = (cpkt.length > MT_MNDP_MAX_STRING_SIZE - 1 ? MT_MNDP_MAX_STRING_SIZE - 1 : cpkt.length));\n\t\t\tcurconn->username[act_size] = 0;\n\t\t\tgot_user_packet = 1;\n\n\t\t} else if (cpkt.cptype == MT_CPTYPE_TERM_WIDTH && cpkt.length >= 2) {\n\t\t\tunsigned short width;\n\n\t\t\tmemcpy(&width, cpkt.data, 2);\n\t\t\tcurconn->terminal_width = le16toh(width);\n\t\t\tgot_width_packet = 1;\n\n\t\t} else if (cpkt.cptype == MT_CPTYPE_TERM_HEIGHT && cpkt.length >= 2) {\n\t\t\tunsigned short height;\n\n\t\t\tmemcpy(&height, cpkt.data, 2);\n\t\t\tcurconn->terminal_height = le16toh(height);\n\t\t\tgot_height_packet = 1;\n\n\t\t} else if (cpkt.cptype == MT_CPTYPE_TERM_TYPE) {\n\n\t\t\tmemcpy(curconn->terminal_type, cpkt.data, act_size = (cpkt.length > 30 - 1 ? 30 - 1 : cpkt.length));\n\t\t\tcurconn->terminal_type[act_size] = 0;\n\n\t\t} else if (cpkt.cptype == MT_CPTYPE_PASSWORD && cpkt.length == 17) {\n\n#if defined(__linux__) && defined(_POSIX_MEMLOCK_RANGE)\n\t\t\tmlock(curconn->trypassword, 17);\n#endif\n\t\t\tmemcpy(curconn->trypassword, cpkt.data, 17);\n\t\t\tgot_pass_packet = 1;\n\n\t\t} else if (cpkt.cptype == MT_CPTYPE_PLAINDATA) {\n\n\t\t\t/* relay data from client to shell */\n\t\t\tif (curconn->state == STATE_ACTIVE && curconn->ptsfd != -1) {\n\t\t\t\twrite(curconn->ptsfd, cpkt.data, cpkt.length);\n\t\t\t}\n\n\t\t} else {\n\t\t\tsyslog(LOG_WARNING, _(\"(%d) Unhandeled control packet type: %d, length: %d\"), curconn->seskey, cpkt.cptype, cpkt.length);\n\t\t}\n\n\t\t/* Parse next control packet */\n\t\tsuccess = parse_control_packet(NULL, 0, &cpkt);\n\t}\n\n\tif (got_user_packet && got_pass_packet) {\n\t\tuser_login(curconn, pkthdr);\n\t}\n\n\tif (curconn->state == STATE_ACTIVE && (got_width_packet || got_height_packet)) {\n\t\tset_terminal_size(curconn->ptsfd, curconn->terminal_width, curconn->terminal_height);\n\n\t}\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos\\2016_8\\b69d11727d4f0f8cf719c79e3fb700f55ca03e9a_after\\MAC-Telnet-b69d11727d4f0f8cf719c79e3fb700f55ca03e9a\\mactelnetd.c", "callees": [], "callers": []}, {"name": "add_control_packet", "content": "int add_control_packet(struct mt_packet *packet, enum mt_cptype cptype, void *cpdata, unsigned short data_len) {\n\tunsigned char *data = packet->data + packet->size;\n\tunsigned int act_size = data_len + (cptype == MT_CPTYPE_PLAINDATA ? 0 : MT_CPHEADER_LEN);\n\n\t/* Something is really wrong. Packets should never become over 1500 bytes,\n       perform an Integer-Overflow safe check */\n\tif (act_size > MT_PACKET_LEN - packet->size) {\n\t\tfprintf(stderr, _(\"add_control_packet: ERROR, too large packet. Exceeds %d bytes\\n\"), MT_PACKET_LEN);\n\t\treturn -1;\n\t\t//exit(1);\n\t}\n\n\t/* PLAINDATA isn't really a controlpacket, but we handle it here, since\n\t   parseControlPacket also parses raw data as PLAINDATA */\n\tif (cptype == MT_CPTYPE_PLAINDATA) {\n\t\tmemcpy(data, cpdata, data_len);\n\t\tpacket->size += data_len;\n\t\treturn data_len;\n\t}\n\n\t/* Control Packet Magic id */\n\tmemcpy(data, mt_mactelnet_cpmagic, sizeof(mt_mactelnet_cpmagic));\n\n\t/* Control packet type */\n\tdata[4] = cptype;\n\n\t/* Data length */\n#if BYTE_ORDER == LITTLE_ENDIAN\n\t{\n\t\tunsigned int templen;\n\t\ttemplen = htonl(data_len);\n\t\tmemcpy(data + 5, &templen, sizeof(templen));\n\t}\n#else\n\tmemcpy(data + 5, &data_len, sizeof(data_len));\n#endif\n\n\t/* Insert data */\n\tif (data_len > 0) {\n\t\tmemcpy(data + MT_CPHEADER_LEN, cpdata, data_len);\n\t}\n\n\tpacket->size += act_size;\n\t/* Control packet header length + data length */\n\treturn act_size;\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos\\2016_8\\b69d11727d4f0f8cf719c79e3fb700f55ca03e9a_after\\MAC-Telnet-b69d11727d4f0f8cf719c79e3fb700f55ca03e9a\\protocol.c", "callees": ["fprintf", "htonl", "memcpy"], "callers": ["send_auth"]}, {"name": "add_packetdata", "content": "int add_packetdata(struct mt_packet *packet, unsigned char *data, unsigned short length) {\n\t/* Integer-Overflow safe check */\n\tif (length > MT_PACKET_LEN - packet->size) {\n\t\tfprintf(stderr, _(\"add_control_packet: ERROR, too large packet. Exceeds %d bytes\\n\"), MT_PACKET_LEN);\n\t\treturn -1;\n\t}\n\n\tmemcpy(packet->data + packet->size, data, length);\n\tpacket->size += length;\n\n\treturn length;\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos\\2016_8\\b69d11727d4f0f8cf719c79e3fb700f55ca03e9a_after\\MAC-Telnet-b69d11727d4f0f8cf719c79e3fb700f55ca03e9a\\protocol.c", "callees": ["fprintf", "memcpy"], "callers": []}, {"name": "mndp_add_attribute", "content": "int mndp_add_attribute(struct mt_packet *packet, enum mt_mndp_attrtype attrtype, void *attrdata, unsigned short data_len) {\n\tunsigned char *data = packet->data + packet->size;\n\tunsigned short type = attrtype;\n\tunsigned short len = data_len;\n\n\t/* Something is really wrong. Packets should never become over 1500 bytes */\n\tif (data_len > MT_PACKET_LEN - 4 - packet->size) {\n\t\tfprintf(stderr, _(\"mndp_add_attribute: ERROR, too large packet. Exceeds %d bytes\\n\"), MT_PACKET_LEN);\n\t\treturn -1;\n\t}\n\n\ttype = htons(type);\n\tmemcpy(data, &type, sizeof(type));\n\n\tlen = htons(len);\n\tmemcpy(data + 2, &len, sizeof(len));\n\n\tmemcpy(data + 4, attrdata, data_len);\n\n\tpacket->size += 4 + data_len;\n\n\treturn 4 + data_len;\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos\\2016_8\\b69d11727d4f0f8cf719c79e3fb700f55ca03e9a_after\\MAC-Telnet-b69d11727d4f0f8cf719c79e3fb700f55ca03e9a\\protocol.c", "callees": ["fprintf", "memcpy", "htons"], "callers": []}], "callerTree_before": {"send_auth": ["md5_append", "md5_finish", "strncpy", "send_udp", "init_packet", "htole16", "md5_init", "getenv", "strlen", "get_terminal_size", "add_control_packet", "memcpy", "mlock"], "handle_packet": ["sig_winch", "fwrite", "send_udp", "fprintf", "init_packet", "send_auth", "parse_control_packet", "parse_packet", "signal", "setvbuf", "ether_ntoa", "raw_term", "memcpy"], "add_control_packet": ["fprintf", "htonl", "memcpy"], "add_packetdata": ["fprintf", "memcpy"], "mndp_add_attribute": ["fprintf", "memcpy", "htons"]}, "calleeTree_before": {"getenv": ["send_auth"], "mlock": ["send_auth"], "strncpy": ["send_auth"], "memcpy": ["handle_packet", "send_auth", "mndp_add_attribute", "add_control_packet", "add_packetdata"], "strlen": ["send_auth"], "md5_init": ["send_auth"], "md5_append": ["send_auth"], "md5_finish": ["send_auth"], "init_packet": ["send_auth", "handle_packet"], "add_control_packet": ["send_auth"], "get_terminal_size": ["send_auth"], "htole16": ["send_auth"], "send_udp": ["send_auth", "handle_packet"], "parse_packet": ["handle_packet"], "parse_control_packet": ["handle_packet"], "send_auth": ["handle_packet"], "fwrite": ["handle_packet"], "raw_term": ["handle_packet"], "setvbuf": ["handle_packet"], "signal": ["handle_packet"], "sig_winch": ["handle_packet"], "fprintf": ["add_control_packet", "mndp_add_attribute", "add_packetdata", "handle_packet"], "ether_ntoa": ["handle_packet"], "htonl": ["add_control_packet"], "htons": ["mndp_add_attribute"]}, "callerTree_after": {"send_auth": ["md5_append", "md5_finish", "send_udp", "init_packet", "htole16", "md5_init", "getenv", "strlen", "get_terminal_size", "strnlen", "add_control_packet", "memcpy", "mlock"], "handle_packet": ["sig_winch", "fwrite", "send_udp", "fprintf", "init_packet", "send_auth", "parse_control_packet", "parse_packet", "signal", "setvbuf", "ether_ntoa", "raw_term", "memcpy"], "add_control_packet": ["fprintf", "htonl", "memcpy"], "add_packetdata": ["fprintf", "memcpy"], "mndp_add_attribute": ["fprintf", "memcpy", "htons"]}, "calleeTree_after": {"getenv": ["send_auth"], "mlock": ["send_auth"], "strnlen": ["send_auth"], "memcpy": ["handle_packet", "send_auth", "mndp_add_attribute", "add_control_packet", "add_packetdata"], "md5_init": ["send_auth"], "md5_append": ["send_auth"], "md5_finish": ["send_auth"], "init_packet": ["send_auth", "handle_packet"], "add_control_packet": ["send_auth"], "strlen": ["send_auth"], "get_terminal_size": ["send_auth"], "htole16": ["send_auth"], "send_udp": ["send_auth", "handle_packet"], "parse_packet": ["handle_packet"], "parse_control_packet": ["handle_packet"], "fprintf": ["add_control_packet", "mndp_add_attribute", "add_packetdata", "handle_packet"], "ether_ntoa": ["handle_packet"], "send_auth": ["handle_packet"], "fwrite": ["handle_packet"], "raw_term": ["handle_packet"], "setvbuf": ["handle_packet"], "signal": ["handle_packet"], "sig_winch": ["handle_packet"], "htonl": ["add_control_packet"], "htons": ["mndp_add_attribute"]}}
{"repo_after": "cf0aa7751f6ef8445e9310a64b14dc81460ca156", "repo_before": "90a5ab519805acb6c5d1ae91d8e3f494ec179db4", "functions_before": [{"name": "dbd_db_login", "content": "int dbd_db_login(SV* dbh, imp_dbh_t* imp_dbh, char* dbname, char* user,\n\t\t char* password) {\n#ifdef dTHR\n  dTHR;\n#endif\n  dTHX; \n  D_imp_xxh(dbh);\n\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n\t\t  \"imp_dbh->connect: dsn = %s, uid = %s, pwd = %s\\n\",\n\t\t  dbname ? dbname : \"NULL\",\n\t\t  user ? user : \"NULL\",\n\t\t  password ? password : \"NULL\");\n\n  imp_dbh->stats.auto_reconnects_ok= 0;\n  imp_dbh->stats.auto_reconnects_failed= 0;\n  imp_dbh->bind_type_guessing= FALSE;\n  imp_dbh->bind_comment_placeholders= FALSE;\n  imp_dbh->has_transactions= TRUE;\n /* Safer we flip this to TRUE perl side if we detect a mod_perl env. */\n  imp_dbh->auto_reconnect = FALSE;\n\n  /* HELMUT */\n#if defined(sv_utf8_decode) && MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION\n  imp_dbh->enable_utf8 = FALSE;     /* initialize mysql_enable_utf8 */\n  imp_dbh->enable_utf8mb4 = FALSE;  /* initialize mysql_enable_utf8mb4 */\n#endif\n\n  if (!my_login(aTHX_ dbh, imp_dbh))\n  {\n    if(imp_dbh->pmysql)\n        do_error(dbh, mysql_errno(imp_dbh->pmysql),\n                mysql_error(imp_dbh->pmysql) ,mysql_sqlstate(imp_dbh->pmysql));\n    return FALSE;\n  }\n\n    /*\n     *  Tell DBI, that dbh->disconnect should be called for this handle\n     */\n    DBIc_ACTIVE_on(imp_dbh);\n\n    /* Tell DBI, that dbh->destroy should be called for this handle */\n    DBIc_on(imp_dbh, DBIcf_IMPSET);\n\n    return TRUE;\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos_before\\2016_8\\90a5ab519805acb6c5d1ae91d8e3f494ec179db4_before\\DBD-mysql-90a5ab519805acb6c5d1ae91d8e3f494ec179db4\\dbdimp.c", "callees": ["DBIc_on", "DBIc_TRACE_LEVEL", "do_error", "DBIc_LOGPIO", "mysql_errno", "DBIc_ACTIVE_on", "mysql_error", "my_login", "mysql_sqlstate", "D_imp_xxh", "PerlIO_printf"], "callers": []}], "functions_after": [{"name": "dbd_db_login", "content": "int dbd_db_login(SV* dbh, imp_dbh_t* imp_dbh, char* dbname, char* user,\n\t\t char* password) {\n#ifdef dTHR\n  dTHR;\n#endif\n  dTHX; \n  D_imp_xxh(dbh);\n\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n\t\t  \"imp_dbh->connect: dsn = %s, uid = %s, pwd = %s\\n\",\n\t\t  dbname ? dbname : \"NULL\",\n\t\t  user ? user : \"NULL\",\n\t\t  password ? password : \"NULL\");\n\n  imp_dbh->stats.auto_reconnects_ok= 0;\n  imp_dbh->stats.auto_reconnects_failed= 0;\n  imp_dbh->bind_type_guessing= FALSE;\n  imp_dbh->bind_comment_placeholders= FALSE;\n  imp_dbh->has_transactions= TRUE;\n /* Safer we flip this to TRUE perl side if we detect a mod_perl env. */\n  imp_dbh->auto_reconnect = FALSE;\n\n  /* HELMUT */\n#if defined(sv_utf8_decode) && MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION\n  imp_dbh->enable_utf8 = FALSE;     /* initialize mysql_enable_utf8 */\n  imp_dbh->enable_utf8mb4 = FALSE;  /* initialize mysql_enable_utf8mb4 */\n#endif\n\n  if (!my_login(aTHX_ dbh, imp_dbh))\n  {\n    if(imp_dbh->pmysql) {\n        do_error(dbh, mysql_errno(imp_dbh->pmysql),\n                mysql_error(imp_dbh->pmysql) ,mysql_sqlstate(imp_dbh->pmysql));\n        Safefree(imp_dbh->pmysql);\n\n    }\n    return FALSE;\n  }\n\n    /*\n     *  Tell DBI, that dbh->disconnect should be called for this handle\n     */\n    DBIc_ACTIVE_on(imp_dbh);\n\n    /* Tell DBI, that dbh->destroy should be called for this handle */\n    DBIc_on(imp_dbh, DBIcf_IMPSET);\n\n    return TRUE;\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos\\2016_8\\cf0aa7751f6ef8445e9310a64b14dc81460ca156_after\\DBD-mysql-cf0aa7751f6ef8445e9310a64b14dc81460ca156\\dbdimp.c", "callees": ["DBIc_on", "DBIc_TRACE_LEVEL", "do_error", "DBIc_LOGPIO", "mysql_errno", "DBIc_ACTIVE_on", "mysql_error", "my_login", "mysql_sqlstate", "D_imp_xxh", "Safefree", "PerlIO_printf"], "callers": []}], "callerTree_before": {"dbd_db_login": ["DBIc_on", "DBIc_TRACE_LEVEL", "do_error", "DBIc_LOGPIO", "mysql_errno", "DBIc_ACTIVE_on", "mysql_error", "my_login", "mysql_sqlstate", "D_imp_xxh", "PerlIO_printf"]}, "calleeTree_before": {"D_imp_xxh": ["dbd_db_login"], "DBIc_TRACE_LEVEL": ["dbd_db_login"], "PerlIO_printf": ["dbd_db_login"], "DBIc_LOGPIO": ["dbd_db_login"], "my_login": ["dbd_db_login"], "do_error": ["dbd_db_login"], "mysql_errno": ["dbd_db_login"], "mysql_error": ["dbd_db_login"], "mysql_sqlstate": ["dbd_db_login"], "DBIc_ACTIVE_on": ["dbd_db_login"], "DBIc_on": ["dbd_db_login"]}, "callerTree_after": {"dbd_db_login": ["DBIc_on", "DBIc_TRACE_LEVEL", "do_error", "DBIc_LOGPIO", "mysql_errno", "DBIc_ACTIVE_on", "mysql_error", "my_login", "mysql_sqlstate", "D_imp_xxh", "Safefree", "PerlIO_printf"]}, "calleeTree_after": {"D_imp_xxh": ["dbd_db_login"], "DBIc_TRACE_LEVEL": ["dbd_db_login"], "PerlIO_printf": ["dbd_db_login"], "DBIc_LOGPIO": ["dbd_db_login"], "my_login": ["dbd_db_login"], "do_error": ["dbd_db_login"], "mysql_errno": ["dbd_db_login"], "mysql_error": ["dbd_db_login"], "mysql_sqlstate": ["dbd_db_login"], "Safefree": ["dbd_db_login"], "DBIc_ACTIVE_on": ["dbd_db_login"], "DBIc_on": ["dbd_db_login"]}}
{"repo_after": "a56ae87a4c1c1fead7d09c3653905841ccccf1cc", "repo_before": "3e09017a24367d04156fce07f3f48a5fdb8c5db8", "functions_before": [{"name": "my_login", "content": "static int my_login(pTHX_ SV* dbh, imp_dbh_t *imp_dbh)\n{\n  SV* sv;\n  HV* hv;\n  char* dbname;\n  char* host;\n  char* port;\n  char* user;\n  char* password;\n  char* mysql_socket;\n  int   result;\n  D_imp_xxh(dbh);\n\n  /* TODO- resolve this so that it is set only if DBI is 1.607 */\n#define TAKE_IMP_DATA_VERSION 1\n#if TAKE_IMP_DATA_VERSION\n  if (DBIc_has(imp_dbh, DBIcf_IMPSET))\n  { /* eg from take_imp_data() */\n    if (DBIc_has(imp_dbh, DBIcf_ACTIVE))\n    {\n      if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n        PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"my_login skip connect\\n\");\n      /* tell our parent we've adopted an active child */\n      ++DBIc_ACTIVE_KIDS(DBIc_PARENT_COM(imp_dbh));\n      return TRUE;\n    }\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                    \"my_login IMPSET but not ACTIVE so connect not skipped\\n\");\n  }\n#endif\n\n  sv = DBIc_IMP_DATA(imp_dbh);\n\n  if (!sv  ||  !SvROK(sv))\n    return FALSE;\n\n  hv = (HV*) SvRV(sv);\n  if (SvTYPE(hv) != SVt_PVHV)\n    return FALSE;\n\n  host=\t\tsafe_hv_fetch(aTHX_ hv, \"host\", 4);\n  port=\t\tsafe_hv_fetch(aTHX_ hv, \"port\", 4);\n  user=\t\tsafe_hv_fetch(aTHX_ hv, \"user\", 4);\n  password=\tsafe_hv_fetch(aTHX_ hv, \"password\", 8);\n  dbname=\tsafe_hv_fetch(aTHX_ hv, \"database\", 8);\n  mysql_socket=\tsafe_hv_fetch(aTHX_ hv, \"mysql_socket\", 12);\n\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n\t\t  \"imp_dbh->my_login : dbname = %s, uid = %s, pwd = %s,\" \\\n\t\t  \"host = %s, port = %s\\n\",\n\t\t  dbname ? dbname : \"NULL\",\n\t\t  user ? user : \"NULL\",\n\t\t  password ? password : \"NULL\",\n\t\t  host ? host : \"NULL\",\n\t\t  port ? port : \"NULL\");\n\n  if (!imp_dbh->pmysql) {\n     Newz(908, imp_dbh->pmysql, 1, MYSQL);\n  }\n  result = mysql_dr_connect(dbh, imp_dbh->pmysql, mysql_socket, host, port, user,\n\t\t\t  password, dbname, imp_dbh) ? TRUE : FALSE;\n  if (!result)\n      Safefree(imp_dbh->pmysql);\n  return result;\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos_before\\2016_8\\3e09017a24367d04156fce07f3f48a5fdb8c5db8_before\\DBD-mysql-3e09017a24367d04156fce07f3f48a5fdb8c5db8\\dbdimp.c", "callees": ["SvTYPE", "DBIc_IMP_DATA", "DBIc_TRACE_LEVEL", "DBIc_ACTIVE_KIDS", "Newz", "DBIc_LOGPIO", "mysql_dr_connect", "SvROK", "DBIc_PARENT_COM", "SvRV", "safe_hv_fetch", "D_imp_xxh", "DBIc_has", "Safefree", "PerlIO_printf"], "callers": ["dbd_db_login"]}, {"name": "dbd_db_login", "content": "int dbd_db_login(SV* dbh, imp_dbh_t* imp_dbh, char* dbname, char* user,\n\t\t char* password) {\n#ifdef dTHR\n  dTHR;\n#endif\n  dTHX; \n  D_imp_xxh(dbh);\n\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n\t\t  \"imp_dbh->connect: dsn = %s, uid = %s, pwd = %s\\n\",\n\t\t  dbname ? dbname : \"NULL\",\n\t\t  user ? user : \"NULL\",\n\t\t  password ? password : \"NULL\");\n\n  imp_dbh->stats.auto_reconnects_ok= 0;\n  imp_dbh->stats.auto_reconnects_failed= 0;\n  imp_dbh->bind_type_guessing= FALSE;\n  imp_dbh->bind_comment_placeholders= FALSE;\n  imp_dbh->has_transactions= TRUE;\n /* Safer we flip this to TRUE perl side if we detect a mod_perl env. */\n  imp_dbh->auto_reconnect = FALSE;\n\n  /* HELMUT */\n#if defined(sv_utf8_decode) && MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION\n  imp_dbh->enable_utf8 = FALSE;  /* initialize mysql_enable_utf8 */\n#endif\n\n  if (!my_login(aTHX_ dbh, imp_dbh))\n  {\n    do_error(dbh, mysql_errno(imp_dbh->pmysql),\n            mysql_error(imp_dbh->pmysql) ,mysql_sqlstate(imp_dbh->pmysql));\n    return FALSE;\n  }\n\n    /*\n     *  Tell DBI, that dbh->disconnect should be called for this handle\n     */\n    DBIc_ACTIVE_on(imp_dbh);\n\n    /* Tell DBI, that dbh->destroy should be called for this handle */\n    DBIc_on(imp_dbh, DBIcf_IMPSET);\n\n    return TRUE;\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos_before\\2016_8\\3e09017a24367d04156fce07f3f48a5fdb8c5db8_before\\DBD-mysql-3e09017a24367d04156fce07f3f48a5fdb8c5db8\\dbdimp.c", "callees": ["DBIc_on", "DBIc_TRACE_LEVEL", "do_error", "DBIc_LOGPIO", "mysql_errno", "DBIc_ACTIVE_on", "mysql_error", "my_login", "mysql_sqlstate", "D_imp_xxh", "PerlIO_printf"], "callers": []}], "functions_after": [{"name": "my_login", "content": "static int my_login(pTHX_ SV* dbh, imp_dbh_t *imp_dbh)\n{\n  SV* sv;\n  HV* hv;\n  char* dbname;\n  char* host;\n  char* port;\n  char* user;\n  char* password;\n  char* mysql_socket;\n  int   result;\n  int\tfresh = 0;\n  D_imp_xxh(dbh);\n\n  /* TODO- resolve this so that it is set only if DBI is 1.607 */\n#define TAKE_IMP_DATA_VERSION 1\n#if TAKE_IMP_DATA_VERSION\n  if (DBIc_has(imp_dbh, DBIcf_IMPSET))\n  { /* eg from take_imp_data() */\n    if (DBIc_has(imp_dbh, DBIcf_ACTIVE))\n    {\n      if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n        PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"my_login skip connect\\n\");\n      /* tell our parent we've adopted an active child */\n      ++DBIc_ACTIVE_KIDS(DBIc_PARENT_COM(imp_dbh));\n      return TRUE;\n    }\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                    \"my_login IMPSET but not ACTIVE so connect not skipped\\n\");\n  }\n#endif\n\n  sv = DBIc_IMP_DATA(imp_dbh);\n\n  if (!sv  ||  !SvROK(sv))\n    return FALSE;\n\n  hv = (HV*) SvRV(sv);\n  if (SvTYPE(hv) != SVt_PVHV)\n    return FALSE;\n\n  host=\t\tsafe_hv_fetch(aTHX_ hv, \"host\", 4);\n  port=\t\tsafe_hv_fetch(aTHX_ hv, \"port\", 4);\n  user=\t\tsafe_hv_fetch(aTHX_ hv, \"user\", 4);\n  password=\tsafe_hv_fetch(aTHX_ hv, \"password\", 8);\n  dbname=\tsafe_hv_fetch(aTHX_ hv, \"database\", 8);\n  mysql_socket=\tsafe_hv_fetch(aTHX_ hv, \"mysql_socket\", 12);\n\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n\t\t  \"imp_dbh->my_login : dbname = %s, uid = %s, pwd = %s,\" \\\n\t\t  \"host = %s, port = %s\\n\",\n\t\t  dbname ? dbname : \"NULL\",\n\t\t  user ? user : \"NULL\",\n\t\t  password ? password : \"NULL\",\n\t\t  host ? host : \"NULL\",\n\t\t  port ? port : \"NULL\");\n\n  if (!imp_dbh->pmysql) {\n     fresh = 1;\n     Newz(908, imp_dbh->pmysql, 1, MYSQL);\n  }\n  result = mysql_dr_connect(dbh, imp_dbh->pmysql, mysql_socket, host, port, user,\n\t\t\t  password, dbname, imp_dbh) ? TRUE : FALSE;\n  if (fresh && !result) {\n      /* Prevent leaks, but do not free in case of a reconnect. See #97625 */\n      do_error(dbh, mysql_errno(imp_dbh->pmysql),\n              mysql_error(imp_dbh->pmysql) ,mysql_sqlstate(imp_dbh->pmysql));\n      Safefree(imp_dbh->pmysql);\n      imp_dbh->pmysql = NULL;\n  }\n  return result;\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos\\2016_8\\a56ae87a4c1c1fead7d09c3653905841ccccf1cc_after\\DBD-mysql-a56ae87a4c1c1fead7d09c3653905841ccccf1cc\\dbdimp.c", "callees": ["DBIc_LOGPIO", "SvROK", "safe_hv_fetch", "SvTYPE", "mysql_error", "mysql_sqlstate", "SvRV", "DBIc_TRACE_LEVEL", "DBIc_ACTIVE_KIDS", "PerlIO_printf", "DBIc_PARENT_COM", "D_imp_xxh", "do_error", "Newz", "mysql_errno", "DBIc_IMP_DATA", "DBIc_has", "Safefree", "mysql_dr_connect"], "callers": ["dbd_db_login"]}, {"name": "dbd_db_login", "content": "int dbd_db_login(SV* dbh, imp_dbh_t* imp_dbh, char* dbname, char* user,\n\t\t char* password) {\n#ifdef dTHR\n  dTHR;\n#endif\n  dTHX; \n  D_imp_xxh(dbh);\n\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n\t\t  \"imp_dbh->connect: dsn = %s, uid = %s, pwd = %s\\n\",\n\t\t  dbname ? dbname : \"NULL\",\n\t\t  user ? user : \"NULL\",\n\t\t  password ? password : \"NULL\");\n\n  imp_dbh->stats.auto_reconnects_ok= 0;\n  imp_dbh->stats.auto_reconnects_failed= 0;\n  imp_dbh->bind_type_guessing= FALSE;\n  imp_dbh->bind_comment_placeholders= FALSE;\n  imp_dbh->has_transactions= TRUE;\n /* Safer we flip this to TRUE perl side if we detect a mod_perl env. */\n  imp_dbh->auto_reconnect = FALSE;\n\n  /* HELMUT */\n#if defined(sv_utf8_decode) && MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION\n  imp_dbh->enable_utf8 = FALSE;  /* initialize mysql_enable_utf8 */\n#endif\n\n  if (!my_login(aTHX_ dbh, imp_dbh))\n  {\n    if(imp_dbh->pmysql)\n        do_error(dbh, mysql_errno(imp_dbh->pmysql),\n                mysql_error(imp_dbh->pmysql) ,mysql_sqlstate(imp_dbh->pmysql));\n    return FALSE;\n  }\n\n    /*\n     *  Tell DBI, that dbh->disconnect should be called for this handle\n     */\n    DBIc_ACTIVE_on(imp_dbh);\n\n    /* Tell DBI, that dbh->destroy should be called for this handle */\n    DBIc_on(imp_dbh, DBIcf_IMPSET);\n\n    return TRUE;\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos\\2016_8\\a56ae87a4c1c1fead7d09c3653905841ccccf1cc_after\\DBD-mysql-a56ae87a4c1c1fead7d09c3653905841ccccf1cc\\dbdimp.c", "callees": ["DBIc_on", "DBIc_TRACE_LEVEL", "do_error", "DBIc_LOGPIO", "mysql_errno", "DBIc_ACTIVE_on", "mysql_error", "my_login", "mysql_sqlstate", "D_imp_xxh", "PerlIO_printf"], "callers": []}], "callerTree_before": {"my_login": ["SvTYPE", "DBIc_IMP_DATA", "DBIc_TRACE_LEVEL", "DBIc_ACTIVE_KIDS", "Newz", "DBIc_LOGPIO", "mysql_dr_connect", "SvROK", "DBIc_PARENT_COM", "SvRV", "safe_hv_fetch", "D_imp_xxh", "DBIc_has", "Safefree", "PerlIO_printf"], "dbd_db_login": ["DBIc_on", "DBIc_TRACE_LEVEL", "do_error", "DBIc_LOGPIO", "mysql_errno", "DBIc_ACTIVE_on", "mysql_error", "my_login", "mysql_sqlstate", "D_imp_xxh", "PerlIO_printf"]}, "calleeTree_before": {"D_imp_xxh": ["my_login", "dbd_db_login"], "DBIc_has": ["my_login"], "DBIc_TRACE_LEVEL": ["my_login", "dbd_db_login"], "PerlIO_printf": ["my_login", "dbd_db_login"], "DBIc_LOGPIO": ["my_login", "dbd_db_login"], "DBIc_ACTIVE_KIDS": ["my_login"], "DBIc_PARENT_COM": ["my_login"], "DBIc_IMP_DATA": ["my_login"], "SvROK": ["my_login"], "SvRV": ["my_login"], "SvTYPE": ["my_login"], "safe_hv_fetch": ["my_login"], "Newz": ["my_login"], "mysql_dr_connect": ["my_login"], "Safefree": ["my_login"], "my_login": ["dbd_db_login"], "do_error": ["dbd_db_login"], "mysql_errno": ["dbd_db_login"], "mysql_error": ["dbd_db_login"], "mysql_sqlstate": ["dbd_db_login"], "DBIc_ACTIVE_on": ["dbd_db_login"], "DBIc_on": ["dbd_db_login"]}, "callerTree_after": {"my_login": ["DBIc_LOGPIO", "SvROK", "safe_hv_fetch", "SvTYPE", "mysql_error", "mysql_sqlstate", "SvRV", "DBIc_TRACE_LEVEL", "DBIc_ACTIVE_KIDS", "PerlIO_printf", "DBIc_PARENT_COM", "D_imp_xxh", "do_error", "Newz", "mysql_errno", "DBIc_IMP_DATA", "DBIc_has", "Safefree", "mysql_dr_connect"], "dbd_db_login": ["DBIc_on", "DBIc_TRACE_LEVEL", "do_error", "DBIc_LOGPIO", "mysql_errno", "DBIc_ACTIVE_on", "mysql_error", "my_login", "mysql_sqlstate", "D_imp_xxh", "PerlIO_printf"]}, "calleeTree_after": {"D_imp_xxh": ["my_login", "dbd_db_login"], "DBIc_has": ["my_login"], "DBIc_TRACE_LEVEL": ["my_login", "dbd_db_login"], "PerlIO_printf": ["my_login", "dbd_db_login"], "DBIc_LOGPIO": ["my_login", "dbd_db_login"], "DBIc_ACTIVE_KIDS": ["my_login"], "DBIc_PARENT_COM": ["my_login"], "DBIc_IMP_DATA": ["my_login"], "SvROK": ["my_login"], "SvRV": ["my_login"], "SvTYPE": ["my_login"], "safe_hv_fetch": ["my_login"], "Newz": ["my_login"], "mysql_dr_connect": ["my_login"], "do_error": ["my_login", "dbd_db_login"], "mysql_errno": ["my_login", "dbd_db_login"], "mysql_error": ["my_login", "dbd_db_login"], "mysql_sqlstate": ["my_login", "dbd_db_login"], "Safefree": ["my_login"], "my_login": ["dbd_db_login"], "DBIc_ACTIVE_on": ["dbd_db_login"], "DBIc_on": ["dbd_db_login"]}}
{"repo_after": "10ef1dca63d62433fda13309b4a228782db823f7", "repo_before": "e6399f5a470f50285cef173e438638ae5bc741e0", "functions_before": [{"name": "gdImageCreateFromTgaCtx", "content": "BGD_DECLARE(gdImagePtr) gdImageCreateFromTgaCtx(gdIOCtx* ctx)\n{\n\tint bitmap_caret = 0;\n\toTga *tga = NULL;\n\t/*\tint pixel_block_size = 0;\n\t\tint image_block_size = 0; */\n\tvolatile gdImagePtr image = NULL;\n\tint x = 0;\n\tint y = 0;\n\n\ttga = (oTga *) gdMalloc(sizeof(oTga));\n\tif (!tga) {\n\t\treturn NULL;\n\t}\n\n\ttga->bitmap = NULL;\n\ttga->ident = NULL;\n\n\tif (read_header_tga(ctx, tga) < 0) {\n\t\tfree_tga(tga);\n\t\treturn NULL;\n\t}\n\n\t/*TODO: Will this be used?\n\t\tpixel_block_size = tga->bits / 8;\n\t\timage_block_size = (tga->width * tga->height) * pixel_block_size;\n\t*/\n\n\tif (read_image_tga(ctx, tga) < 0) {\n\t\tfree_tga(tga);\n\t\treturn NULL;\n\t}\n\n\timage = gdImageCreateTrueColor((int)tga->width, (int)tga->height );\n\n\tif (image == 0) {\n\t\tfree_tga( tga );\n\t\treturn NULL;\n\t}\n\n\t/*!\t\\brief Populate GD image object\n\t *  Copy the pixel data from our tga bitmap buffer into the GD image\n\t *  Disable blending and save the alpha channel per default\n\t */\n\tif (tga->alphabits) {\n\t\tgdImageAlphaBlending(image, 0);\n\t\tgdImageSaveAlpha(image, 1);\n\t}\n\n\t/* TODO: use alphabits as soon as we support 24bit and other alpha bps (ie != 8bits) */\n\tfor (y = 0; y < tga->height; y++) {\n\t\tregister int *tpix = image->tpixels[y];\n\t\tfor ( x = 0; x < tga->width; x++, tpix++) {\n\t\t\tif (tga->bits == TGA_BPP_24) {\n\t\t\t\t*tpix = gdTrueColor(tga->bitmap[bitmap_caret + 2], tga->bitmap[bitmap_caret + 1], tga->bitmap[bitmap_caret]);\n\t\t\t\tbitmap_caret += 3;\n\t\t\t} else if (tga->bits == TGA_BPP_32 || tga->alphabits) {\n\t\t\t\tregister int a = tga->bitmap[bitmap_caret + 3];\n\n\t\t\t\t*tpix = gdTrueColorAlpha(tga->bitmap[bitmap_caret + 2], tga->bitmap[bitmap_caret + 1], tga->bitmap[bitmap_caret], gdAlphaMax - (a >> 1));\n\t\t\t\tbitmap_caret += 4;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (tga->flipv && tga->fliph) {\n\t\tgdImageFlipBoth(image);\n\t} else if (tga->flipv) {\n\t\tgdImageFlipVertical(image);\n\t} else if (tga->fliph) {\n\t\tgdImageFlipHorizontal(image);\n\t}\n\n\tfree_tga(tga);\n\n\treturn image;\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos_before\\2016_8\\e6399f5a470f50285cef173e438638ae5bc741e0_before\\libgd-e6399f5a470f50285cef173e438638ae5bc741e0\\src\\gd_tga.c", "callees": [], "callers": []}, {"name": "read_header_tga", "content": "int read_header_tga(gdIOCtx *ctx, oTga *tga)\n{\n\n\tunsigned char header[18];\n\n\tif (gdGetBuf(header, sizeof(header), ctx) < 18) {\n\t\tgd_error(\"fail to read header\");\n\t\treturn -1;\n\t}\n\n\ttga->identsize = header[0];\n\ttga->colormaptype = header[1];\n\ttga->imagetype = header[2];\n\ttga->colormapstart = header[3] + (header[4] << 8);\n\ttga->colormaplength = header[5] + (header[6] << 8);\n\ttga->colormapbits = header[7];\n\ttga->xstart = header[8] + (header[9] << 8);\n\ttga->ystart = header[10] + (header[11] << 8);\n\ttga->width = header[12] + (header[13] << 8);\n\ttga->height = header[14] + (header[15] << 8);\n\ttga->bits = header[16];\n\ttga->alphabits = header[17] & 0x0f;\n\ttga->fliph = (header[17] & 0x10) ? 1 : 0;\n\ttga->flipv = (header[17] & 0x20) ? 0 : 1;\n\n#if DEBUG\n\tprintf(\"format bps: %i\\n\", tga->bits);\n\tprintf(\"flip h/v: %i / %i\\n\", tga->fliph, tga->flipv);\n\tprintf(\"alpha: %i\\n\", tga->alphabits);\n\tprintf(\"wxh: %i %i\\n\", tga->width, tga->height);\n#endif\n\n\tswitch(tga->bits) {\n\tcase 8:\n\tcase 16:\n\tcase 24:\n\tcase 32:\n\t\tbreak;\n\tdefault:\n\t\tgd_error(\"bps %i not supported\", tga->bits);\n\t\treturn -1;\n\t\tbreak;\n\t}\n\n\ttga->ident = NULL;\n\n\tif (tga->identsize > 0) {\n\t\ttga->ident = (char *) gdMalloc(tga->identsize * sizeof(char));\n\t\tif(tga->ident == NULL) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tgdGetBuf(tga->ident, tga->identsize, ctx);\n\t}\n\n\treturn 1;\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos_before\\2016_8\\e6399f5a470f50285cef173e438638ae5bc741e0_before\\libgd-e6399f5a470f50285cef173e438638ae5bc741e0\\src\\gd_tga.c", "callees": ["gdMalloc", "gdGetBuf", "gd_error", "printf"], "callers": []}], "functions_after": [{"name": "gdImageCreateFromTgaCtx", "content": "BGD_DECLARE(gdImagePtr) gdImageCreateFromTgaCtx(gdIOCtx* ctx)\n{\n\tint bitmap_caret = 0;\n\toTga *tga = NULL;\n\t/*\tint pixel_block_size = 0;\n\t\tint image_block_size = 0; */\n\tvolatile gdImagePtr image = NULL;\n\tint x = 0;\n\tint y = 0;\n\n\ttga = (oTga *) gdMalloc(sizeof(oTga));\n\tif (!tga) {\n\t\treturn NULL;\n\t}\n\n\ttga->bitmap = NULL;\n\ttga->ident = NULL;\n\n\tif (read_header_tga(ctx, tga) < 0) {\n\t\tfree_tga(tga);\n\t\treturn NULL;\n\t}\n\n\t/*TODO: Will this be used?\n\t\tpixel_block_size = tga->bits / 8;\n\t\timage_block_size = (tga->width * tga->height) * pixel_block_size;\n\t*/\n\n\tif (read_image_tga(ctx, tga) < 0) {\n\t\tfree_tga(tga);\n\t\treturn NULL;\n\t}\n\n\timage = gdImageCreateTrueColor((int)tga->width, (int)tga->height );\n\n\tif (image == 0) {\n\t\tfree_tga( tga );\n\t\treturn NULL;\n\t}\n\n\t/*!\t\\brief Populate GD image object\n\t *  Copy the pixel data from our tga bitmap buffer into the GD image\n\t *  Disable blending and save the alpha channel per default\n\t */\n\tif (tga->alphabits) {\n\t\tgdImageAlphaBlending(image, 0);\n\t\tgdImageSaveAlpha(image, 1);\n\t}\n\n\t/* TODO: use alphabits as soon as we support 24bit and other alpha bps (ie != 8bits) */\n\tfor (y = 0; y < tga->height; y++) {\n\t\tregister int *tpix = image->tpixels[y];\n\t\tfor ( x = 0; x < tga->width; x++, tpix++) {\n\t\t\tif (tga->bits == TGA_BPP_24) {\n\t\t\t\t*tpix = gdTrueColor(tga->bitmap[bitmap_caret + 2], tga->bitmap[bitmap_caret + 1], tga->bitmap[bitmap_caret]);\n\t\t\t\tbitmap_caret += 3;\n\t\t\t} else if (tga->bits == TGA_BPP_32 && tga->alphabits) {\n\t\t\t\tregister int a = tga->bitmap[bitmap_caret + 3];\n\n\t\t\t\t*tpix = gdTrueColorAlpha(tga->bitmap[bitmap_caret + 2], tga->bitmap[bitmap_caret + 1], tga->bitmap[bitmap_caret], gdAlphaMax - (a >> 1));\n\t\t\t\tbitmap_caret += 4;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (tga->flipv && tga->fliph) {\n\t\tgdImageFlipBoth(image);\n\t} else if (tga->flipv) {\n\t\tgdImageFlipVertical(image);\n\t} else if (tga->fliph) {\n\t\tgdImageFlipHorizontal(image);\n\t}\n\n\tfree_tga(tga);\n\n\treturn image;\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos\\2016_8\\10ef1dca63d62433fda13309b4a228782db823f7_after\\libgd-10ef1dca63d62433fda13309b4a228782db823f7\\src\\gd_tga.c", "callees": [], "callers": []}, {"name": "read_header_tga", "content": "int read_header_tga(gdIOCtx *ctx, oTga *tga)\n{\n\n\tunsigned char header[18];\n\n\tif (gdGetBuf(header, sizeof(header), ctx) < 18) {\n\t\tgd_error(\"fail to read header\");\n\t\treturn -1;\n\t}\n\n\ttga->identsize = header[0];\n\ttga->colormaptype = header[1];\n\ttga->imagetype = header[2];\n\ttga->colormapstart = header[3] + (header[4] << 8);\n\ttga->colormaplength = header[5] + (header[6] << 8);\n\ttga->colormapbits = header[7];\n\ttga->xstart = header[8] + (header[9] << 8);\n\ttga->ystart = header[10] + (header[11] << 8);\n\ttga->width = header[12] + (header[13] << 8);\n\ttga->height = header[14] + (header[15] << 8);\n\ttga->bits = header[16];\n\ttga->alphabits = header[17] & 0x0f;\n\ttga->fliph = (header[17] & 0x10) ? 1 : 0;\n\ttga->flipv = (header[17] & 0x20) ? 0 : 1;\n\n#if DEBUG\n\tprintf(\"format bps: %i\\n\", tga->bits);\n\tprintf(\"flip h/v: %i / %i\\n\", tga->fliph, tga->flipv);\n\tprintf(\"alpha: %i\\n\", tga->alphabits);\n\tprintf(\"wxh: %i %i\\n\", tga->width, tga->height);\n#endif\n\n\tif (!((tga->bits == TGA_BPP_24 && tga->alphabits == 0)\n\t\t|| (tga->bits == TGA_BPP_32 && tga->alphabits == 8)))\n\t{\n\t\tgd_error_ex(GD_WARNING, \"gd-tga: %u bits per pixel with %u alpha bits not supported\\n\",\n\t\t\ttga->bits, tga->alphabits);\n\t\treturn -1;\n\t}\n\n\ttga->ident = NULL;\n\n\tif (tga->identsize > 0) {\n\t\ttga->ident = (char *) gdMalloc(tga->identsize * sizeof(char));\n\t\tif(tga->ident == NULL) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tgdGetBuf(tga->ident, tga->identsize, ctx);\n\t}\n\n\treturn 1;\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos\\2016_8\\10ef1dca63d62433fda13309b4a228782db823f7_after\\libgd-10ef1dca63d62433fda13309b4a228782db823f7\\src\\gd_tga.c", "callees": ["gdGetBuf", "gd_error", "gdMalloc", "gd_error_ex", "printf"], "callers": []}], "callerTree_before": {"read_header_tga": ["gdMalloc", "gdGetBuf", "gd_error", "printf"]}, "calleeTree_before": {"gdGetBuf": ["read_header_tga"], "gd_error": ["read_header_tga"], "printf": ["read_header_tga"], "gdMalloc": ["read_header_tga"]}, "callerTree_after": {"read_header_tga": ["gdGetBuf", "gd_error", "gdMalloc", "gd_error_ex", "printf"]}, "calleeTree_after": {"gdGetBuf": ["read_header_tga"], "gd_error": ["read_header_tga"], "printf": ["read_header_tga"], "gd_error_ex": ["read_header_tga"], "gdMalloc": ["read_header_tga"]}}
{"repo_after": "1ccfe21e14c4d18336f9da8515cd17db88c3de61", "repo_before": "3fe0a7128bac5000fdcfab888bd2a75ec0c9447d", "functions_before": [{"name": "gdImageCropThreshold", "content": "BGD_DECLARE(gdImagePtr) gdImageCropThreshold(gdImagePtr im, const unsigned int color, const float threshold)\n{\n\tconst int width = gdImageSX(im);\n\tconst int height = gdImageSY(im);\n\n\tint x,y;\n\tint match;\n\tgdRect crop;\n\n\tcrop.x = 0;\n\tcrop.y = 0;\n\tcrop.width = 0;\n\tcrop.height = 0;\n\n\t/* Pierre: crop everything sounds bad */\n\tif (threshold > 100.0) {\n\t\treturn NULL;\n\t}\n\n\t/* TODO: Add gdImageGetRowPtr and works with ptr at the row level\n\t * for the true color and palette images\n\t * new formats will simply work with ptr\n\t */\n\tmatch = 1;\n\tfor (y = 0; match && y < height; y++) {\n\t\tfor (x = 0; match && x < width; x++) {\n\t\t\tmatch = (gdColorMatch(im, color, gdImageGetPixel(im, x,y), threshold)) > 0;\n\t\t}\n\t}\n\n\t/* Pierre\n\t * Nothing to do > bye\n\t * Duplicate the image?\n\t */\n\tif (y == height - 1) {\n\t\treturn NULL;\n\t}\n\n\tcrop.y = y -1;\n\tmatch = 1;\n\tfor (y = height - 1; match && y >= 0; y--) {\n\t\tfor (x = 0; match && x < width; x++) {\n\t\t\tmatch = (gdColorMatch(im, color, gdImageGetPixel(im, x, y), threshold)) > 0;\n\t\t}\n\t}\n\n\tif (y == 0) {\n\t\tcrop.height = height - crop.y + 1;\n\t} else {\n\t\tcrop.height = y - crop.y + 2;\n\t}\n\n\tmatch = 1;\n\tfor (x = 0; match && x < width; x++) {\n\t\tfor (y = 0; match && y < crop.y + crop.height - 1; y++) {\n\t\t\tmatch = (gdColorMatch(im, color, gdImageGetPixel(im, x,y), threshold)) > 0;\n\t\t}\n\t}\n\tcrop.x = x - 1;\n\n\tmatch = 1;\n\tfor (x = width - 1; match && x >= 0; x--) {\n\t\tfor (y = 0; match &&  y < crop.y + crop.height - 1; y++) {\n\t\t\tmatch = (gdColorMatch(im, color, gdImageGetPixel(im, x,y), threshold)) > 0;\n\t\t}\n\t}\n\tcrop.width = x - crop.x + 2;\n\n\treturn gdImageCrop(im, &crop);\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos_before\\2016_8\\3fe0a7128bac5000fdcfab888bd2a75ec0c9447d_before\\libgd-3fe0a7128bac5000fdcfab888bd2a75ec0c9447d\\src\\gd_crop.c", "callees": [], "callers": []}], "functions_after": [{"name": "gdImageCropThreshold", "content": "BGD_DECLARE(gdImagePtr) gdImageCropThreshold(gdImagePtr im, const unsigned int color, const float threshold)\n{\n\tconst int width = gdImageSX(im);\n\tconst int height = gdImageSY(im);\n\n\tint x,y;\n\tint match;\n\tgdRect crop;\n\n\tcrop.x = 0;\n\tcrop.y = 0;\n\tcrop.width = 0;\n\tcrop.height = 0;\n\n\t/* Pierre: crop everything sounds bad */\n\tif (threshold > 100.0) {\n\t\treturn NULL;\n\t}\n\n\tif (color < 0 || (!gdImageTrueColor(im) && color >= gdImageColorsTotal(im))) {\n\t\treturn NULL;\n\t}\n\n\t/* TODO: Add gdImageGetRowPtr and works with ptr at the row level\n\t * for the true color and palette images\n\t * new formats will simply work with ptr\n\t */\n\tmatch = 1;\n\tfor (y = 0; match && y < height; y++) {\n\t\tfor (x = 0; match && x < width; x++) {\n\t\t\tmatch = (gdColorMatch(im, color, gdImageGetPixel(im, x,y), threshold)) > 0;\n\t\t}\n\t}\n\n\t/* Pierre\n\t * Nothing to do > bye\n\t * Duplicate the image?\n\t */\n\tif (y == height - 1) {\n\t\treturn NULL;\n\t}\n\n\tcrop.y = y -1;\n\tmatch = 1;\n\tfor (y = height - 1; match && y >= 0; y--) {\n\t\tfor (x = 0; match && x < width; x++) {\n\t\t\tmatch = (gdColorMatch(im, color, gdImageGetPixel(im, x, y), threshold)) > 0;\n\t\t}\n\t}\n\n\tif (y == 0) {\n\t\tcrop.height = height - crop.y + 1;\n\t} else {\n\t\tcrop.height = y - crop.y + 2;\n\t}\n\n\tmatch = 1;\n\tfor (x = 0; match && x < width; x++) {\n\t\tfor (y = 0; match && y < crop.y + crop.height - 1; y++) {\n\t\t\tmatch = (gdColorMatch(im, color, gdImageGetPixel(im, x,y), threshold)) > 0;\n\t\t}\n\t}\n\tcrop.x = x - 1;\n\n\tmatch = 1;\n\tfor (x = width - 1; match && x >= 0; x--) {\n\t\tfor (y = 0; match &&  y < crop.y + crop.height - 1; y++) {\n\t\t\tmatch = (gdColorMatch(im, color, gdImageGetPixel(im, x,y), threshold)) > 0;\n\t\t}\n\t}\n\tcrop.width = x - crop.x + 2;\n\n\treturn gdImageCrop(im, &crop);\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos\\2016_8\\1ccfe21e14c4d18336f9da8515cd17db88c3de61_after\\libgd-1ccfe21e14c4d18336f9da8515cd17db88c3de61\\src\\gd_crop.c", "callees": [], "callers": []}], "callerTree_before": {"gdGuessBackgroundColorFromCorners": ["gdImageGetPixel", "gdImageBlue", "gdImageSY", "gdImageGreen", "gdImageRed", "gdImageAlpha", "gdImageColorClosestAlpha", "gdImageSX"]}, "calleeTree_before": {"gdImageGetPixel": ["gdGuessBackgroundColorFromCorners"], "gdImageSX": ["gdGuessBackgroundColorFromCorners"], "gdImageSY": ["gdGuessBackgroundColorFromCorners"], "gdImageRed": ["gdGuessBackgroundColorFromCorners"], "gdImageGreen": ["gdGuessBackgroundColorFromCorners"], "gdImageBlue": ["gdGuessBackgroundColorFromCorners"], "gdImageAlpha": ["gdGuessBackgroundColorFromCorners"], "gdImageColorClosestAlpha": ["gdGuessBackgroundColorFromCorners"]}, "callerTree_after": {"gdGuessBackgroundColorFromCorners": ["gdImageGetPixel", "gdImageBlue", "gdImageSY", "gdImageGreen", "gdImageRed", "gdImageAlpha", "gdImageColorClosestAlpha", "gdImageSX"]}, "calleeTree_after": {"gdImageGetPixel": ["gdGuessBackgroundColorFromCorners"], "gdImageSX": ["gdGuessBackgroundColorFromCorners"], "gdImageSY": ["gdGuessBackgroundColorFromCorners"], "gdImageRed": ["gdGuessBackgroundColorFromCorners"], "gdImageGreen": ["gdGuessBackgroundColorFromCorners"], "gdImageBlue": ["gdGuessBackgroundColorFromCorners"], "gdImageAlpha": ["gdGuessBackgroundColorFromCorners"], "gdImageColorClosestAlpha": ["gdGuessBackgroundColorFromCorners"]}}
{"repo_after": "4dc1a2d7931017d3625f2d7cff70a17ce58b53b4", "repo_before": "b083ec17ad9cba4ad9fe7fac1c6a168d90dd1a31", "functions_before": [{"name": "gdCtxPrintf", "content": "static void gdCtxPrintf(gdIOCtx * out, const char *format, ...)\n{\n\tchar buf[4096];\n\tint len;\n\tva_list args;\n\n\tva_start(args, format);\n\tlen = vsnprintf(buf, sizeof(buf)-1, format, args);\n\tva_end(args);\n\tout->putBuf(out, buf, len);\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos_before\\2016_8\\b083ec17ad9cba4ad9fe7fac1c6a168d90dd1a31_before\\libgd-b083ec17ad9cba4ad9fe7fac1c6a168d90dd1a31\\src\\gd_xbm.c", "callees": ["va_end", "vsnprintf", "va_start"], "callers": []}, {"name": "gdImageXbmCtx", "content": "BGD_DECLARE(void) gdImageXbmCtx(gdImagePtr image, char* file_name, int fg, gdIOCtx * out)\n{\n\tint x, y, c, b, sx, sy, p;\n\tchar *name, *f;\n\tsize_t i, l;\n\n\tname = file_name;\n\tif ((f = strrchr(name, '/')) != NULL) name = f+1;\n\tif ((f = strrchr(name, '\\\\')) != NULL) name = f+1;\n\tname = strdup(name);\n\tif ((f = strrchr(name, '.')) != NULL && !strcasecmp(f, \".XBM\")) *f = '\\0';\n\tif ((l = strlen(name)) == 0) {\n\t\tfree(name);\n\t\tname = strdup(\"image\");\n\t} else {\n\t\tfor (i=0; i<l; i++) {\n\t\t\t/* only in C-locale isalnum() would work */\n\t\t\tif (!isupper(name[i]) && !islower(name[i]) && !isdigit(name[i])) {\n\t\t\t\tname[i] = '_';\n\t\t\t}\n\t\t}\n\t}\n\n\tgdCtxPrintf(out, \"#define %s_width %d\\n\", name, gdImageSX(image));\n\tgdCtxPrintf(out, \"#define %s_height %d\\n\", name, gdImageSY(image));\n\tgdCtxPrintf(out, \"static unsigned char %s_bits[] = {\\n  \", name);\n\n\tfree(name);\n\n\tb = 1;\n\tp = 0;\n\tc = 0;\n\tsx = gdImageSX(image);\n\tsy = gdImageSY(image);\n\tfor (y = 0; y < sy; y++) {\n\t\tfor (x = 0; x < sx; x++) {\n\t\t\tif (gdImageGetPixel(image, x, y) == fg) {\n\t\t\t\tc |= b;\n\t\t\t}\n\t\t\tif ((b == 128) || (x == sx && y == sy)) {\n\t\t\t\tb = 1;\n\t\t\t\tif (p) {\n\t\t\t\t\tgdCtxPrintf(out, \", \");\n\t\t\t\t\tif (!(p%12)) {\n\t\t\t\t\t\tgdCtxPrintf(out, \"\\n  \");\n\t\t\t\t\t\tp = 12;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tp++;\n\t\t\t\tgdCtxPrintf(out, \"0x%02X\", c);\n\t\t\t\tc = 0;\n\t\t\t} else {\n\t\t\t\tb <<= 1;\n\t\t\t}\n\t\t}\n\t}\n\tgdCtxPrintf(out, \"};\\n\");\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos_before\\2016_8\\b083ec17ad9cba4ad9fe7fac1c6a168d90dd1a31_before\\libgd-b083ec17ad9cba4ad9fe7fac1c6a168d90dd1a31\\src\\gd_xbm.c", "callees": [], "callers": []}], "functions_after": [{"name": "gdCtxPrintf", "content": "static void gdCtxPrintf(gdIOCtx * out, const char *format, ...)\n{\n\tchar buf[1024];\n\tint len;\n\tva_list args;\n\n\tva_start(args, format);\n\tlen = vsnprintf(buf, sizeof(buf)-1, format, args);\n\tva_end(args);\n\tout->putBuf(out, buf, len);\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos\\2016_8\\4dc1a2d7931017d3625f2d7cff70a17ce58b53b4_after\\libgd-4dc1a2d7931017d3625f2d7cff70a17ce58b53b4\\src\\gd_xbm.c", "callees": ["va_end", "vsnprintf", "va_start"], "callers": []}, {"name": "gdImageXbmCtx", "content": "BGD_DECLARE(void) gdImageXbmCtx(gdImagePtr image, char* file_name, int fg, gdIOCtx * out)\n{\n\tint x, y, c, b, sx, sy, p;\n\tchar *name, *f;\n\tsize_t i, l;\n\n\tname = file_name;\n\tif ((f = strrchr(name, '/')) != NULL) name = f+1;\n\tif ((f = strrchr(name, '\\\\')) != NULL) name = f+1;\n\tname = strdup(name);\n\tif ((f = strrchr(name, '.')) != NULL && !strcasecmp(f, \".XBM\")) *f = '\\0';\n\tif ((l = strlen(name)) == 0) {\n\t\tfree(name);\n\t\tname = strdup(\"image\");\n\t} else {\n\t\tfor (i=0; i<l; i++) {\n\t\t\t/* only in C-locale isalnum() would work */\n\t\t\tif (!isupper(name[i]) && !islower(name[i]) && !isdigit(name[i])) {\n\t\t\t\tname[i] = '_';\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Since \"name\" comes from the user, run it through a direct puts.\n\t * Trying to printf it into a local buffer means we'd need a large\n\t * or dynamic buffer to hold it all. */\n\n\t/* #define <name>_width 1234 */\n\tgdCtxPuts(out, \"#define \");\n\tgdCtxPuts(out, name);\n\tgdCtxPuts(out, \"_width \");\n\tgdCtxPrintf(out, \"%d\\n\", gdImageSX(image));\n\n\t/* #define <name>_height 1234 */\n\tgdCtxPuts(out, \"#define \");\n\tgdCtxPuts(out, name);\n\tgdCtxPuts(out, \"_height \");\n\tgdCtxPrintf(out, \"%d\\n\", gdImageSY(image));\n\n\t/* static unsigned char <name>_bits[] = {\\n */\n\tgdCtxPuts(out, \"static unsigned char \");\n\tgdCtxPuts(out, name);\n\tgdCtxPuts(out, \"_bits[] = {\\n  \");\n\n\tfree(name);\n\n\tb = 1;\n\tp = 0;\n\tc = 0;\n\tsx = gdImageSX(image);\n\tsy = gdImageSY(image);\n\tfor (y = 0; y < sy; y++) {\n\t\tfor (x = 0; x < sx; x++) {\n\t\t\tif (gdImageGetPixel(image, x, y) == fg) {\n\t\t\t\tc |= b;\n\t\t\t}\n\t\t\tif ((b == 128) || (x == sx && y == sy)) {\n\t\t\t\tb = 1;\n\t\t\t\tif (p) {\n\t\t\t\t\tgdCtxPuts(out, \", \");\n\t\t\t\t\tif (!(p%12)) {\n\t\t\t\t\t\tgdCtxPuts(out, \"\\n  \");\n\t\t\t\t\t\tp = 12;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tp++;\n\t\t\t\tgdCtxPrintf(out, \"0x%02X\", c);\n\t\t\t\tc = 0;\n\t\t\t} else {\n\t\t\t\tb <<= 1;\n\t\t\t}\n\t\t}\n\t}\n\tgdCtxPuts(out, \"};\\n\");\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos\\2016_8\\4dc1a2d7931017d3625f2d7cff70a17ce58b53b4_after\\libgd-4dc1a2d7931017d3625f2d7cff70a17ce58b53b4\\src\\gd_xbm.c", "callees": [], "callers": []}], "callerTree_before": {"gdCtxPrintf": ["va_end", "vsnprintf", "va_start"]}, "calleeTree_before": {"va_start": ["gdCtxPrintf"], "vsnprintf": ["gdCtxPrintf"], "va_end": ["gdCtxPrintf"]}, "callerTree_after": {"gdCtxPrintf": ["va_end", "vsnprintf", "va_start"]}, "calleeTree_after": {"va_start": ["gdCtxPrintf"], "vsnprintf": ["gdCtxPrintf"], "va_end": ["gdCtxPrintf"]}}
{"repo_after": "fcd135c9df440bcd2d5870405ad3311743d78d97", "repo_before": "324583e8fb3935690be58790425793df619c6d4d", "functions_before": [{"name": "auth_password", "content": "int\nauth_password(Authctxt *authctxt, const char *password)\n{\n\tstruct passwd * pw = authctxt->pw;\n\tint result, ok = authctxt->valid;\n#if defined(USE_SHADOW) && defined(HAS_SHADOW_EXPIRE)\n\tstatic int expire_checked = 0;\n#endif\n\n#ifndef HAVE_CYGWIN\n\tif (pw->pw_uid == 0 && options.permit_root_login != PERMIT_YES)\n\t\tok = 0;\n#endif\n\tif (*password == '\\0' && options.permit_empty_passwd == 0)\n\t\treturn 0;\n\n#ifdef KRB5\n\tif (options.kerberos_authentication == 1) {\n\t\tint ret = auth_krb5_password(authctxt, password);\n\t\tif (ret == 1 || ret == 0)\n\t\t\treturn ret && ok;\n\t\t/* Fall back to ordinary passwd authentication. */\n\t}\n#endif\n#ifdef HAVE_CYGWIN\n\t{\n\t\tHANDLE hToken = cygwin_logon_user(pw, password);\n\n\t\tif (hToken == INVALID_HANDLE_VALUE)\n\t\t\treturn 0;\n\t\tcygwin_set_impersonation_token(hToken);\n\t\treturn ok;\n\t}\n#endif\n#ifdef USE_PAM\n\tif (options.use_pam)\n\t\treturn (sshpam_auth_passwd(authctxt, password) && ok);\n#endif\n#if defined(USE_SHADOW) && defined(HAS_SHADOW_EXPIRE)\n\tif (!expire_checked) {\n\t\texpire_checked = 1;\n\t\tif (auth_shadow_pwexpired(authctxt))\n\t\t\tauthctxt->force_pwchange = 1;\n\t}\n#endif\n\tresult = sys_auth_passwd(authctxt, password);\n\tif (authctxt->force_pwchange)\n\t\tdisable_forwarding();\n\treturn (result && ok);\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos_before\\2016_8\\324583e8fb3935690be58790425793df619c6d4d_before\\openssh-portable-324583e8fb3935690be58790425793df619c6d4d\\auth-passwd.c", "callees": ["cygwin_logon_user", "auth_krb5_password", "disable_forwarding", "sshpam_auth_passwd", "auth_shadow_pwexpired", "cygwin_set_impersonation_token", "sys_auth_passwd"], "callers": []}], "functions_after": [{"name": "auth_password", "content": "int\nauth_password(Authctxt *authctxt, const char *password)\n{\n\tstruct passwd * pw = authctxt->pw;\n\tint result, ok = authctxt->valid;\n#if defined(USE_SHADOW) && defined(HAS_SHADOW_EXPIRE)\n\tstatic int expire_checked = 0;\n#endif\n\n\tif (strlen(password) > MAX_PASSWORD_LEN)\n\t\treturn 0;\n\n#ifndef HAVE_CYGWIN\n\tif (pw->pw_uid == 0 && options.permit_root_login != PERMIT_YES)\n\t\tok = 0;\n#endif\n\tif (*password == '\\0' && options.permit_empty_passwd == 0)\n\t\treturn 0;\n\n#ifdef KRB5\n\tif (options.kerberos_authentication == 1) {\n\t\tint ret = auth_krb5_password(authctxt, password);\n\t\tif (ret == 1 || ret == 0)\n\t\t\treturn ret && ok;\n\t\t/* Fall back to ordinary passwd authentication. */\n\t}\n#endif\n#ifdef HAVE_CYGWIN\n\t{\n\t\tHANDLE hToken = cygwin_logon_user(pw, password);\n\n\t\tif (hToken == INVALID_HANDLE_VALUE)\n\t\t\treturn 0;\n\t\tcygwin_set_impersonation_token(hToken);\n\t\treturn ok;\n\t}\n#endif\n#ifdef USE_PAM\n\tif (options.use_pam)\n\t\treturn (sshpam_auth_passwd(authctxt, password) && ok);\n#endif\n#if defined(USE_SHADOW) && defined(HAS_SHADOW_EXPIRE)\n\tif (!expire_checked) {\n\t\texpire_checked = 1;\n\t\tif (auth_shadow_pwexpired(authctxt))\n\t\t\tauthctxt->force_pwchange = 1;\n\t}\n#endif\n\tresult = sys_auth_passwd(authctxt, password);\n\tif (authctxt->force_pwchange)\n\t\tdisable_forwarding();\n\treturn (result && ok);\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos\\2016_8\\fcd135c9df440bcd2d5870405ad3311743d78d97_after\\openssh-portable-fcd135c9df440bcd2d5870405ad3311743d78d97\\auth-passwd.c", "callees": ["cygwin_logon_user", "auth_krb5_password", "disable_forwarding", "sshpam_auth_passwd", "auth_shadow_pwexpired", "cygwin_set_impersonation_token", "sys_auth_passwd", "strlen"], "callers": []}], "callerTree_before": {"auth_password": ["cygwin_logon_user", "auth_krb5_password", "disable_forwarding", "sshpam_auth_passwd", "auth_shadow_pwexpired", "cygwin_set_impersonation_token", "sys_auth_passwd"]}, "calleeTree_before": {"auth_krb5_password": ["auth_password"], "cygwin_logon_user": ["auth_password"], "cygwin_set_impersonation_token": ["auth_password"], "sshpam_auth_passwd": ["auth_password"], "auth_shadow_pwexpired": ["auth_password"], "sys_auth_passwd": ["auth_password"], "disable_forwarding": ["auth_password"]}, "callerTree_after": {"auth_password": ["cygwin_logon_user", "auth_krb5_password", "disable_forwarding", "sshpam_auth_passwd", "auth_shadow_pwexpired", "cygwin_set_impersonation_token", "sys_auth_passwd", "strlen"]}, "calleeTree_after": {"strlen": ["auth_password"], "auth_krb5_password": ["auth_password"], "cygwin_logon_user": ["auth_password"], "cygwin_set_impersonation_token": ["auth_password"], "sshpam_auth_passwd": ["auth_password"], "auth_shadow_pwexpired": ["auth_password"], "sys_auth_passwd": ["auth_password"], "disable_forwarding": ["auth_password"]}}
{"repo_after": "a56ae87a4c1c1fead7d09c3653905841ccccf1cc", "repo_before": "3e09017a24367d04156fce07f3f48a5fdb8c5db8", "functions_before": [{"name": "my_login", "content": "static int my_login(pTHX_ SV* dbh, imp_dbh_t *imp_dbh)\n{\n  SV* sv;\n  HV* hv;\n  char* dbname;\n  char* host;\n  char* port;\n  char* user;\n  char* password;\n  char* mysql_socket;\n  int   result;\n  D_imp_xxh(dbh);\n\n  /* TODO- resolve this so that it is set only if DBI is 1.607 */\n#define TAKE_IMP_DATA_VERSION 1\n#if TAKE_IMP_DATA_VERSION\n  if (DBIc_has(imp_dbh, DBIcf_IMPSET))\n  { /* eg from take_imp_data() */\n    if (DBIc_has(imp_dbh, DBIcf_ACTIVE))\n    {\n      if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n        PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"my_login skip connect\\n\");\n      /* tell our parent we've adopted an active child */\n      ++DBIc_ACTIVE_KIDS(DBIc_PARENT_COM(imp_dbh));\n      return TRUE;\n    }\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                    \"my_login IMPSET but not ACTIVE so connect not skipped\\n\");\n  }\n#endif\n\n  sv = DBIc_IMP_DATA(imp_dbh);\n\n  if (!sv  ||  !SvROK(sv))\n    return FALSE;\n\n  hv = (HV*) SvRV(sv);\n  if (SvTYPE(hv) != SVt_PVHV)\n    return FALSE;\n\n  host=\t\tsafe_hv_fetch(aTHX_ hv, \"host\", 4);\n  port=\t\tsafe_hv_fetch(aTHX_ hv, \"port\", 4);\n  user=\t\tsafe_hv_fetch(aTHX_ hv, \"user\", 4);\n  password=\tsafe_hv_fetch(aTHX_ hv, \"password\", 8);\n  dbname=\tsafe_hv_fetch(aTHX_ hv, \"database\", 8);\n  mysql_socket=\tsafe_hv_fetch(aTHX_ hv, \"mysql_socket\", 12);\n\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n\t\t  \"imp_dbh->my_login : dbname = %s, uid = %s, pwd = %s,\" \\\n\t\t  \"host = %s, port = %s\\n\",\n\t\t  dbname ? dbname : \"NULL\",\n\t\t  user ? user : \"NULL\",\n\t\t  password ? password : \"NULL\",\n\t\t  host ? host : \"NULL\",\n\t\t  port ? port : \"NULL\");\n\n  if (!imp_dbh->pmysql) {\n     Newz(908, imp_dbh->pmysql, 1, MYSQL);\n  }\n  result = mysql_dr_connect(dbh, imp_dbh->pmysql, mysql_socket, host, port, user,\n\t\t\t  password, dbname, imp_dbh) ? TRUE : FALSE;\n  if (!result)\n      Safefree(imp_dbh->pmysql);\n  return result;\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos_before\\2016_8\\3e09017a24367d04156fce07f3f48a5fdb8c5db8_before\\DBD-mysql-3e09017a24367d04156fce07f3f48a5fdb8c5db8\\dbdimp.c", "callees": ["SvTYPE", "DBIc_IMP_DATA", "DBIc_TRACE_LEVEL", "DBIc_ACTIVE_KIDS", "Newz", "DBIc_LOGPIO", "mysql_dr_connect", "SvROK", "DBIc_PARENT_COM", "SvRV", "safe_hv_fetch", "D_imp_xxh", "DBIc_has", "Safefree", "PerlIO_printf"], "callers": ["dbd_db_login"]}, {"name": "dbd_db_login", "content": "int dbd_db_login(SV* dbh, imp_dbh_t* imp_dbh, char* dbname, char* user,\n\t\t char* password) {\n#ifdef dTHR\n  dTHR;\n#endif\n  dTHX; \n  D_imp_xxh(dbh);\n\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n\t\t  \"imp_dbh->connect: dsn = %s, uid = %s, pwd = %s\\n\",\n\t\t  dbname ? dbname : \"NULL\",\n\t\t  user ? user : \"NULL\",\n\t\t  password ? password : \"NULL\");\n\n  imp_dbh->stats.auto_reconnects_ok= 0;\n  imp_dbh->stats.auto_reconnects_failed= 0;\n  imp_dbh->bind_type_guessing= FALSE;\n  imp_dbh->bind_comment_placeholders= FALSE;\n  imp_dbh->has_transactions= TRUE;\n /* Safer we flip this to TRUE perl side if we detect a mod_perl env. */\n  imp_dbh->auto_reconnect = FALSE;\n\n  /* HELMUT */\n#if defined(sv_utf8_decode) && MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION\n  imp_dbh->enable_utf8 = FALSE;  /* initialize mysql_enable_utf8 */\n#endif\n\n  if (!my_login(aTHX_ dbh, imp_dbh))\n  {\n    do_error(dbh, mysql_errno(imp_dbh->pmysql),\n            mysql_error(imp_dbh->pmysql) ,mysql_sqlstate(imp_dbh->pmysql));\n    return FALSE;\n  }\n\n    /*\n     *  Tell DBI, that dbh->disconnect should be called for this handle\n     */\n    DBIc_ACTIVE_on(imp_dbh);\n\n    /* Tell DBI, that dbh->destroy should be called for this handle */\n    DBIc_on(imp_dbh, DBIcf_IMPSET);\n\n    return TRUE;\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos_before\\2016_8\\3e09017a24367d04156fce07f3f48a5fdb8c5db8_before\\DBD-mysql-3e09017a24367d04156fce07f3f48a5fdb8c5db8\\dbdimp.c", "callees": ["DBIc_on", "DBIc_TRACE_LEVEL", "do_error", "DBIc_LOGPIO", "mysql_errno", "DBIc_ACTIVE_on", "mysql_error", "my_login", "mysql_sqlstate", "D_imp_xxh", "PerlIO_printf"], "callers": []}], "functions_after": [{"name": "my_login", "content": "static int my_login(pTHX_ SV* dbh, imp_dbh_t *imp_dbh)\n{\n  SV* sv;\n  HV* hv;\n  char* dbname;\n  char* host;\n  char* port;\n  char* user;\n  char* password;\n  char* mysql_socket;\n  int   result;\n  int\tfresh = 0;\n  D_imp_xxh(dbh);\n\n  /* TODO- resolve this so that it is set only if DBI is 1.607 */\n#define TAKE_IMP_DATA_VERSION 1\n#if TAKE_IMP_DATA_VERSION\n  if (DBIc_has(imp_dbh, DBIcf_IMPSET))\n  { /* eg from take_imp_data() */\n    if (DBIc_has(imp_dbh, DBIcf_ACTIVE))\n    {\n      if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n        PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"my_login skip connect\\n\");\n      /* tell our parent we've adopted an active child */\n      ++DBIc_ACTIVE_KIDS(DBIc_PARENT_COM(imp_dbh));\n      return TRUE;\n    }\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                    \"my_login IMPSET but not ACTIVE so connect not skipped\\n\");\n  }\n#endif\n\n  sv = DBIc_IMP_DATA(imp_dbh);\n\n  if (!sv  ||  !SvROK(sv))\n    return FALSE;\n\n  hv = (HV*) SvRV(sv);\n  if (SvTYPE(hv) != SVt_PVHV)\n    return FALSE;\n\n  host=\t\tsafe_hv_fetch(aTHX_ hv, \"host\", 4);\n  port=\t\tsafe_hv_fetch(aTHX_ hv, \"port\", 4);\n  user=\t\tsafe_hv_fetch(aTHX_ hv, \"user\", 4);\n  password=\tsafe_hv_fetch(aTHX_ hv, \"password\", 8);\n  dbname=\tsafe_hv_fetch(aTHX_ hv, \"database\", 8);\n  mysql_socket=\tsafe_hv_fetch(aTHX_ hv, \"mysql_socket\", 12);\n\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n\t\t  \"imp_dbh->my_login : dbname = %s, uid = %s, pwd = %s,\" \\\n\t\t  \"host = %s, port = %s\\n\",\n\t\t  dbname ? dbname : \"NULL\",\n\t\t  user ? user : \"NULL\",\n\t\t  password ? password : \"NULL\",\n\t\t  host ? host : \"NULL\",\n\t\t  port ? port : \"NULL\");\n\n  if (!imp_dbh->pmysql) {\n     fresh = 1;\n     Newz(908, imp_dbh->pmysql, 1, MYSQL);\n  }\n  result = mysql_dr_connect(dbh, imp_dbh->pmysql, mysql_socket, host, port, user,\n\t\t\t  password, dbname, imp_dbh) ? TRUE : FALSE;\n  if (fresh && !result) {\n      /* Prevent leaks, but do not free in case of a reconnect. See #97625 */\n      do_error(dbh, mysql_errno(imp_dbh->pmysql),\n              mysql_error(imp_dbh->pmysql) ,mysql_sqlstate(imp_dbh->pmysql));\n      Safefree(imp_dbh->pmysql);\n      imp_dbh->pmysql = NULL;\n  }\n  return result;\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos\\2016_8\\a56ae87a4c1c1fead7d09c3653905841ccccf1cc_after\\DBD-mysql-a56ae87a4c1c1fead7d09c3653905841ccccf1cc\\dbdimp.c", "callees": ["DBIc_LOGPIO", "SvROK", "safe_hv_fetch", "SvTYPE", "mysql_error", "mysql_sqlstate", "SvRV", "DBIc_TRACE_LEVEL", "DBIc_ACTIVE_KIDS", "PerlIO_printf", "DBIc_PARENT_COM", "D_imp_xxh", "do_error", "Newz", "mysql_errno", "DBIc_IMP_DATA", "DBIc_has", "Safefree", "mysql_dr_connect"], "callers": ["dbd_db_login"]}, {"name": "dbd_db_login", "content": "int dbd_db_login(SV* dbh, imp_dbh_t* imp_dbh, char* dbname, char* user,\n\t\t char* password) {\n#ifdef dTHR\n  dTHR;\n#endif\n  dTHX; \n  D_imp_xxh(dbh);\n\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n\t\t  \"imp_dbh->connect: dsn = %s, uid = %s, pwd = %s\\n\",\n\t\t  dbname ? dbname : \"NULL\",\n\t\t  user ? user : \"NULL\",\n\t\t  password ? password : \"NULL\");\n\n  imp_dbh->stats.auto_reconnects_ok= 0;\n  imp_dbh->stats.auto_reconnects_failed= 0;\n  imp_dbh->bind_type_guessing= FALSE;\n  imp_dbh->bind_comment_placeholders= FALSE;\n  imp_dbh->has_transactions= TRUE;\n /* Safer we flip this to TRUE perl side if we detect a mod_perl env. */\n  imp_dbh->auto_reconnect = FALSE;\n\n  /* HELMUT */\n#if defined(sv_utf8_decode) && MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION\n  imp_dbh->enable_utf8 = FALSE;  /* initialize mysql_enable_utf8 */\n#endif\n\n  if (!my_login(aTHX_ dbh, imp_dbh))\n  {\n    if(imp_dbh->pmysql)\n        do_error(dbh, mysql_errno(imp_dbh->pmysql),\n                mysql_error(imp_dbh->pmysql) ,mysql_sqlstate(imp_dbh->pmysql));\n    return FALSE;\n  }\n\n    /*\n     *  Tell DBI, that dbh->disconnect should be called for this handle\n     */\n    DBIc_ACTIVE_on(imp_dbh);\n\n    /* Tell DBI, that dbh->destroy should be called for this handle */\n    DBIc_on(imp_dbh, DBIcf_IMPSET);\n\n    return TRUE;\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos\\2016_8\\a56ae87a4c1c1fead7d09c3653905841ccccf1cc_after\\DBD-mysql-a56ae87a4c1c1fead7d09c3653905841ccccf1cc\\dbdimp.c", "callees": ["DBIc_on", "DBIc_TRACE_LEVEL", "do_error", "DBIc_LOGPIO", "mysql_errno", "DBIc_ACTIVE_on", "mysql_error", "my_login", "mysql_sqlstate", "D_imp_xxh", "PerlIO_printf"], "callers": []}], "callerTree_before": {"my_login": ["SvTYPE", "DBIc_IMP_DATA", "DBIc_TRACE_LEVEL", "DBIc_ACTIVE_KIDS", "Newz", "DBIc_LOGPIO", "mysql_dr_connect", "SvROK", "DBIc_PARENT_COM", "SvRV", "safe_hv_fetch", "D_imp_xxh", "DBIc_has", "Safefree", "PerlIO_printf"], "dbd_db_login": ["DBIc_on", "DBIc_TRACE_LEVEL", "do_error", "DBIc_LOGPIO", "mysql_errno", "DBIc_ACTIVE_on", "mysql_error", "my_login", "mysql_sqlstate", "D_imp_xxh", "PerlIO_printf"]}, "calleeTree_before": {"D_imp_xxh": ["my_login", "dbd_db_login"], "DBIc_has": ["my_login"], "DBIc_TRACE_LEVEL": ["my_login", "dbd_db_login"], "PerlIO_printf": ["my_login", "dbd_db_login"], "DBIc_LOGPIO": ["my_login", "dbd_db_login"], "DBIc_ACTIVE_KIDS": ["my_login"], "DBIc_PARENT_COM": ["my_login"], "DBIc_IMP_DATA": ["my_login"], "SvROK": ["my_login"], "SvRV": ["my_login"], "SvTYPE": ["my_login"], "safe_hv_fetch": ["my_login"], "Newz": ["my_login"], "mysql_dr_connect": ["my_login"], "Safefree": ["my_login"], "my_login": ["dbd_db_login"], "do_error": ["dbd_db_login"], "mysql_errno": ["dbd_db_login"], "mysql_error": ["dbd_db_login"], "mysql_sqlstate": ["dbd_db_login"], "DBIc_ACTIVE_on": ["dbd_db_login"], "DBIc_on": ["dbd_db_login"]}, "callerTree_after": {"my_login": ["DBIc_LOGPIO", "SvROK", "safe_hv_fetch", "SvTYPE", "mysql_error", "mysql_sqlstate", "SvRV", "DBIc_TRACE_LEVEL", "DBIc_ACTIVE_KIDS", "PerlIO_printf", "DBIc_PARENT_COM", "D_imp_xxh", "do_error", "Newz", "mysql_errno", "DBIc_IMP_DATA", "DBIc_has", "Safefree", "mysql_dr_connect"], "dbd_db_login": ["DBIc_on", "DBIc_TRACE_LEVEL", "do_error", "DBIc_LOGPIO", "mysql_errno", "DBIc_ACTIVE_on", "mysql_error", "my_login", "mysql_sqlstate", "D_imp_xxh", "PerlIO_printf"]}, "calleeTree_after": {"D_imp_xxh": ["my_login", "dbd_db_login"], "DBIc_has": ["my_login"], "DBIc_TRACE_LEVEL": ["my_login", "dbd_db_login"], "PerlIO_printf": ["my_login", "dbd_db_login"], "DBIc_LOGPIO": ["my_login", "dbd_db_login"], "DBIc_ACTIVE_KIDS": ["my_login"], "DBIc_PARENT_COM": ["my_login"], "DBIc_IMP_DATA": ["my_login"], "SvROK": ["my_login"], "SvRV": ["my_login"], "SvTYPE": ["my_login"], "safe_hv_fetch": ["my_login"], "Newz": ["my_login"], "mysql_dr_connect": ["my_login"], "do_error": ["my_login", "dbd_db_login"], "mysql_errno": ["my_login", "dbd_db_login"], "mysql_error": ["my_login", "dbd_db_login"], "mysql_sqlstate": ["my_login", "dbd_db_login"], "Safefree": ["my_login"], "my_login": ["dbd_db_login"], "DBIc_ACTIVE_on": ["dbd_db_login"], "DBIc_on": ["dbd_db_login"]}}
{"repo_after": "cf0aa7751f6ef8445e9310a64b14dc81460ca156", "repo_before": "90a5ab519805acb6c5d1ae91d8e3f494ec179db4", "functions_before": [{"name": "dbd_db_login", "content": "int dbd_db_login(SV* dbh, imp_dbh_t* imp_dbh, char* dbname, char* user,\n\t\t char* password) {\n#ifdef dTHR\n  dTHR;\n#endif\n  dTHX; \n  D_imp_xxh(dbh);\n\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n\t\t  \"imp_dbh->connect: dsn = %s, uid = %s, pwd = %s\\n\",\n\t\t  dbname ? dbname : \"NULL\",\n\t\t  user ? user : \"NULL\",\n\t\t  password ? password : \"NULL\");\n\n  imp_dbh->stats.auto_reconnects_ok= 0;\n  imp_dbh->stats.auto_reconnects_failed= 0;\n  imp_dbh->bind_type_guessing= FALSE;\n  imp_dbh->bind_comment_placeholders= FALSE;\n  imp_dbh->has_transactions= TRUE;\n /* Safer we flip this to TRUE perl side if we detect a mod_perl env. */\n  imp_dbh->auto_reconnect = FALSE;\n\n  /* HELMUT */\n#if defined(sv_utf8_decode) && MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION\n  imp_dbh->enable_utf8 = FALSE;     /* initialize mysql_enable_utf8 */\n  imp_dbh->enable_utf8mb4 = FALSE;  /* initialize mysql_enable_utf8mb4 */\n#endif\n\n  if (!my_login(aTHX_ dbh, imp_dbh))\n  {\n    if(imp_dbh->pmysql)\n        do_error(dbh, mysql_errno(imp_dbh->pmysql),\n                mysql_error(imp_dbh->pmysql) ,mysql_sqlstate(imp_dbh->pmysql));\n    return FALSE;\n  }\n\n    /*\n     *  Tell DBI, that dbh->disconnect should be called for this handle\n     */\n    DBIc_ACTIVE_on(imp_dbh);\n\n    /* Tell DBI, that dbh->destroy should be called for this handle */\n    DBIc_on(imp_dbh, DBIcf_IMPSET);\n\n    return TRUE;\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos_before\\2016_8\\90a5ab519805acb6c5d1ae91d8e3f494ec179db4_before\\DBD-mysql-90a5ab519805acb6c5d1ae91d8e3f494ec179db4\\dbdimp.c", "callees": ["DBIc_on", "DBIc_TRACE_LEVEL", "do_error", "DBIc_LOGPIO", "mysql_errno", "DBIc_ACTIVE_on", "mysql_error", "my_login", "mysql_sqlstate", "D_imp_xxh", "PerlIO_printf"], "callers": []}], "functions_after": [{"name": "dbd_db_login", "content": "int dbd_db_login(SV* dbh, imp_dbh_t* imp_dbh, char* dbname, char* user,\n\t\t char* password) {\n#ifdef dTHR\n  dTHR;\n#endif\n  dTHX; \n  D_imp_xxh(dbh);\n\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n\t\t  \"imp_dbh->connect: dsn = %s, uid = %s, pwd = %s\\n\",\n\t\t  dbname ? dbname : \"NULL\",\n\t\t  user ? user : \"NULL\",\n\t\t  password ? password : \"NULL\");\n\n  imp_dbh->stats.auto_reconnects_ok= 0;\n  imp_dbh->stats.auto_reconnects_failed= 0;\n  imp_dbh->bind_type_guessing= FALSE;\n  imp_dbh->bind_comment_placeholders= FALSE;\n  imp_dbh->has_transactions= TRUE;\n /* Safer we flip this to TRUE perl side if we detect a mod_perl env. */\n  imp_dbh->auto_reconnect = FALSE;\n\n  /* HELMUT */\n#if defined(sv_utf8_decode) && MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION\n  imp_dbh->enable_utf8 = FALSE;     /* initialize mysql_enable_utf8 */\n  imp_dbh->enable_utf8mb4 = FALSE;  /* initialize mysql_enable_utf8mb4 */\n#endif\n\n  if (!my_login(aTHX_ dbh, imp_dbh))\n  {\n    if(imp_dbh->pmysql) {\n        do_error(dbh, mysql_errno(imp_dbh->pmysql),\n                mysql_error(imp_dbh->pmysql) ,mysql_sqlstate(imp_dbh->pmysql));\n        Safefree(imp_dbh->pmysql);\n\n    }\n    return FALSE;\n  }\n\n    /*\n     *  Tell DBI, that dbh->disconnect should be called for this handle\n     */\n    DBIc_ACTIVE_on(imp_dbh);\n\n    /* Tell DBI, that dbh->destroy should be called for this handle */\n    DBIc_on(imp_dbh, DBIcf_IMPSET);\n\n    return TRUE;\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos\\2016_8\\cf0aa7751f6ef8445e9310a64b14dc81460ca156_after\\DBD-mysql-cf0aa7751f6ef8445e9310a64b14dc81460ca156\\dbdimp.c", "callees": ["DBIc_on", "DBIc_TRACE_LEVEL", "do_error", "DBIc_LOGPIO", "mysql_errno", "DBIc_ACTIVE_on", "mysql_error", "my_login", "mysql_sqlstate", "D_imp_xxh", "Safefree", "PerlIO_printf"], "callers": []}], "callerTree_before": {"dbd_db_login": ["DBIc_on", "DBIc_TRACE_LEVEL", "do_error", "DBIc_LOGPIO", "mysql_errno", "DBIc_ACTIVE_on", "mysql_error", "my_login", "mysql_sqlstate", "D_imp_xxh", "PerlIO_printf"]}, "calleeTree_before": {"D_imp_xxh": ["dbd_db_login"], "DBIc_TRACE_LEVEL": ["dbd_db_login"], "PerlIO_printf": ["dbd_db_login"], "DBIc_LOGPIO": ["dbd_db_login"], "my_login": ["dbd_db_login"], "do_error": ["dbd_db_login"], "mysql_errno": ["dbd_db_login"], "mysql_error": ["dbd_db_login"], "mysql_sqlstate": ["dbd_db_login"], "DBIc_ACTIVE_on": ["dbd_db_login"], "DBIc_on": ["dbd_db_login"]}, "callerTree_after": {"dbd_db_login": ["DBIc_on", "DBIc_TRACE_LEVEL", "do_error", "DBIc_LOGPIO", "mysql_errno", "DBIc_ACTIVE_on", "mysql_error", "my_login", "mysql_sqlstate", "D_imp_xxh", "Safefree", "PerlIO_printf"]}, "calleeTree_after": {"D_imp_xxh": ["dbd_db_login"], "DBIc_TRACE_LEVEL": ["dbd_db_login"], "PerlIO_printf": ["dbd_db_login"], "DBIc_LOGPIO": ["dbd_db_login"], "my_login": ["dbd_db_login"], "do_error": ["dbd_db_login"], "mysql_errno": ["dbd_db_login"], "mysql_error": ["dbd_db_login"], "mysql_sqlstate": ["dbd_db_login"], "Safefree": ["dbd_db_login"], "DBIc_ACTIVE_on": ["dbd_db_login"], "DBIc_on": ["dbd_db_login"]}}
{"repo_after": "10ef1dca63d62433fda13309b4a228782db823f7", "repo_before": "e6399f5a470f50285cef173e438638ae5bc741e0", "functions_before": [{"name": "gdImageCreateFromTgaCtx", "content": "BGD_DECLARE(gdImagePtr) gdImageCreateFromTgaCtx(gdIOCtx* ctx)\n{\n\tint bitmap_caret = 0;\n\toTga *tga = NULL;\n\t/*\tint pixel_block_size = 0;\n\t\tint image_block_size = 0; */\n\tvolatile gdImagePtr image = NULL;\n\tint x = 0;\n\tint y = 0;\n\n\ttga = (oTga *) gdMalloc(sizeof(oTga));\n\tif (!tga) {\n\t\treturn NULL;\n\t}\n\n\ttga->bitmap = NULL;\n\ttga->ident = NULL;\n\n\tif (read_header_tga(ctx, tga) < 0) {\n\t\tfree_tga(tga);\n\t\treturn NULL;\n\t}\n\n\t/*TODO: Will this be used?\n\t\tpixel_block_size = tga->bits / 8;\n\t\timage_block_size = (tga->width * tga->height) * pixel_block_size;\n\t*/\n\n\tif (read_image_tga(ctx, tga) < 0) {\n\t\tfree_tga(tga);\n\t\treturn NULL;\n\t}\n\n\timage = gdImageCreateTrueColor((int)tga->width, (int)tga->height );\n\n\tif (image == 0) {\n\t\tfree_tga( tga );\n\t\treturn NULL;\n\t}\n\n\t/*!\t\\brief Populate GD image object\n\t *  Copy the pixel data from our tga bitmap buffer into the GD image\n\t *  Disable blending and save the alpha channel per default\n\t */\n\tif (tga->alphabits) {\n\t\tgdImageAlphaBlending(image, 0);\n\t\tgdImageSaveAlpha(image, 1);\n\t}\n\n\t/* TODO: use alphabits as soon as we support 24bit and other alpha bps (ie != 8bits) */\n\tfor (y = 0; y < tga->height; y++) {\n\t\tregister int *tpix = image->tpixels[y];\n\t\tfor ( x = 0; x < tga->width; x++, tpix++) {\n\t\t\tif (tga->bits == TGA_BPP_24) {\n\t\t\t\t*tpix = gdTrueColor(tga->bitmap[bitmap_caret + 2], tga->bitmap[bitmap_caret + 1], tga->bitmap[bitmap_caret]);\n\t\t\t\tbitmap_caret += 3;\n\t\t\t} else if (tga->bits == TGA_BPP_32 || tga->alphabits) {\n\t\t\t\tregister int a = tga->bitmap[bitmap_caret + 3];\n\n\t\t\t\t*tpix = gdTrueColorAlpha(tga->bitmap[bitmap_caret + 2], tga->bitmap[bitmap_caret + 1], tga->bitmap[bitmap_caret], gdAlphaMax - (a >> 1));\n\t\t\t\tbitmap_caret += 4;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (tga->flipv && tga->fliph) {\n\t\tgdImageFlipBoth(image);\n\t} else if (tga->flipv) {\n\t\tgdImageFlipVertical(image);\n\t} else if (tga->fliph) {\n\t\tgdImageFlipHorizontal(image);\n\t}\n\n\tfree_tga(tga);\n\n\treturn image;\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos_before\\2016_8\\e6399f5a470f50285cef173e438638ae5bc741e0_before\\libgd-e6399f5a470f50285cef173e438638ae5bc741e0\\src\\gd_tga.c", "callees": [], "callers": []}, {"name": "read_header_tga", "content": "int read_header_tga(gdIOCtx *ctx, oTga *tga)\n{\n\n\tunsigned char header[18];\n\n\tif (gdGetBuf(header, sizeof(header), ctx) < 18) {\n\t\tgd_error(\"fail to read header\");\n\t\treturn -1;\n\t}\n\n\ttga->identsize = header[0];\n\ttga->colormaptype = header[1];\n\ttga->imagetype = header[2];\n\ttga->colormapstart = header[3] + (header[4] << 8);\n\ttga->colormaplength = header[5] + (header[6] << 8);\n\ttga->colormapbits = header[7];\n\ttga->xstart = header[8] + (header[9] << 8);\n\ttga->ystart = header[10] + (header[11] << 8);\n\ttga->width = header[12] + (header[13] << 8);\n\ttga->height = header[14] + (header[15] << 8);\n\ttga->bits = header[16];\n\ttga->alphabits = header[17] & 0x0f;\n\ttga->fliph = (header[17] & 0x10) ? 1 : 0;\n\ttga->flipv = (header[17] & 0x20) ? 0 : 1;\n\n#if DEBUG\n\tprintf(\"format bps: %i\\n\", tga->bits);\n\tprintf(\"flip h/v: %i / %i\\n\", tga->fliph, tga->flipv);\n\tprintf(\"alpha: %i\\n\", tga->alphabits);\n\tprintf(\"wxh: %i %i\\n\", tga->width, tga->height);\n#endif\n\n\tswitch(tga->bits) {\n\tcase 8:\n\tcase 16:\n\tcase 24:\n\tcase 32:\n\t\tbreak;\n\tdefault:\n\t\tgd_error(\"bps %i not supported\", tga->bits);\n\t\treturn -1;\n\t\tbreak;\n\t}\n\n\ttga->ident = NULL;\n\n\tif (tga->identsize > 0) {\n\t\ttga->ident = (char *) gdMalloc(tga->identsize * sizeof(char));\n\t\tif(tga->ident == NULL) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tgdGetBuf(tga->ident, tga->identsize, ctx);\n\t}\n\n\treturn 1;\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos_before\\2016_8\\e6399f5a470f50285cef173e438638ae5bc741e0_before\\libgd-e6399f5a470f50285cef173e438638ae5bc741e0\\src\\gd_tga.c", "callees": ["gdMalloc", "gdGetBuf", "gd_error", "printf"], "callers": []}], "functions_after": [{"name": "gdImageCreateFromTgaCtx", "content": "BGD_DECLARE(gdImagePtr) gdImageCreateFromTgaCtx(gdIOCtx* ctx)\n{\n\tint bitmap_caret = 0;\n\toTga *tga = NULL;\n\t/*\tint pixel_block_size = 0;\n\t\tint image_block_size = 0; */\n\tvolatile gdImagePtr image = NULL;\n\tint x = 0;\n\tint y = 0;\n\n\ttga = (oTga *) gdMalloc(sizeof(oTga));\n\tif (!tga) {\n\t\treturn NULL;\n\t}\n\n\ttga->bitmap = NULL;\n\ttga->ident = NULL;\n\n\tif (read_header_tga(ctx, tga) < 0) {\n\t\tfree_tga(tga);\n\t\treturn NULL;\n\t}\n\n\t/*TODO: Will this be used?\n\t\tpixel_block_size = tga->bits / 8;\n\t\timage_block_size = (tga->width * tga->height) * pixel_block_size;\n\t*/\n\n\tif (read_image_tga(ctx, tga) < 0) {\n\t\tfree_tga(tga);\n\t\treturn NULL;\n\t}\n\n\timage = gdImageCreateTrueColor((int)tga->width, (int)tga->height );\n\n\tif (image == 0) {\n\t\tfree_tga( tga );\n\t\treturn NULL;\n\t}\n\n\t/*!\t\\brief Populate GD image object\n\t *  Copy the pixel data from our tga bitmap buffer into the GD image\n\t *  Disable blending and save the alpha channel per default\n\t */\n\tif (tga->alphabits) {\n\t\tgdImageAlphaBlending(image, 0);\n\t\tgdImageSaveAlpha(image, 1);\n\t}\n\n\t/* TODO: use alphabits as soon as we support 24bit and other alpha bps (ie != 8bits) */\n\tfor (y = 0; y < tga->height; y++) {\n\t\tregister int *tpix = image->tpixels[y];\n\t\tfor ( x = 0; x < tga->width; x++, tpix++) {\n\t\t\tif (tga->bits == TGA_BPP_24) {\n\t\t\t\t*tpix = gdTrueColor(tga->bitmap[bitmap_caret + 2], tga->bitmap[bitmap_caret + 1], tga->bitmap[bitmap_caret]);\n\t\t\t\tbitmap_caret += 3;\n\t\t\t} else if (tga->bits == TGA_BPP_32 && tga->alphabits) {\n\t\t\t\tregister int a = tga->bitmap[bitmap_caret + 3];\n\n\t\t\t\t*tpix = gdTrueColorAlpha(tga->bitmap[bitmap_caret + 2], tga->bitmap[bitmap_caret + 1], tga->bitmap[bitmap_caret], gdAlphaMax - (a >> 1));\n\t\t\t\tbitmap_caret += 4;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (tga->flipv && tga->fliph) {\n\t\tgdImageFlipBoth(image);\n\t} else if (tga->flipv) {\n\t\tgdImageFlipVertical(image);\n\t} else if (tga->fliph) {\n\t\tgdImageFlipHorizontal(image);\n\t}\n\n\tfree_tga(tga);\n\n\treturn image;\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos\\2016_8\\10ef1dca63d62433fda13309b4a228782db823f7_after\\libgd-10ef1dca63d62433fda13309b4a228782db823f7\\src\\gd_tga.c", "callees": [], "callers": []}, {"name": "read_header_tga", "content": "int read_header_tga(gdIOCtx *ctx, oTga *tga)\n{\n\n\tunsigned char header[18];\n\n\tif (gdGetBuf(header, sizeof(header), ctx) < 18) {\n\t\tgd_error(\"fail to read header\");\n\t\treturn -1;\n\t}\n\n\ttga->identsize = header[0];\n\ttga->colormaptype = header[1];\n\ttga->imagetype = header[2];\n\ttga->colormapstart = header[3] + (header[4] << 8);\n\ttga->colormaplength = header[5] + (header[6] << 8);\n\ttga->colormapbits = header[7];\n\ttga->xstart = header[8] + (header[9] << 8);\n\ttga->ystart = header[10] + (header[11] << 8);\n\ttga->width = header[12] + (header[13] << 8);\n\ttga->height = header[14] + (header[15] << 8);\n\ttga->bits = header[16];\n\ttga->alphabits = header[17] & 0x0f;\n\ttga->fliph = (header[17] & 0x10) ? 1 : 0;\n\ttga->flipv = (header[17] & 0x20) ? 0 : 1;\n\n#if DEBUG\n\tprintf(\"format bps: %i\\n\", tga->bits);\n\tprintf(\"flip h/v: %i / %i\\n\", tga->fliph, tga->flipv);\n\tprintf(\"alpha: %i\\n\", tga->alphabits);\n\tprintf(\"wxh: %i %i\\n\", tga->width, tga->height);\n#endif\n\n\tif (!((tga->bits == TGA_BPP_24 && tga->alphabits == 0)\n\t\t|| (tga->bits == TGA_BPP_32 && tga->alphabits == 8)))\n\t{\n\t\tgd_error_ex(GD_WARNING, \"gd-tga: %u bits per pixel with %u alpha bits not supported\\n\",\n\t\t\ttga->bits, tga->alphabits);\n\t\treturn -1;\n\t}\n\n\ttga->ident = NULL;\n\n\tif (tga->identsize > 0) {\n\t\ttga->ident = (char *) gdMalloc(tga->identsize * sizeof(char));\n\t\tif(tga->ident == NULL) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tgdGetBuf(tga->ident, tga->identsize, ctx);\n\t}\n\n\treturn 1;\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos\\2016_8\\10ef1dca63d62433fda13309b4a228782db823f7_after\\libgd-10ef1dca63d62433fda13309b4a228782db823f7\\src\\gd_tga.c", "callees": ["gdGetBuf", "gd_error", "gdMalloc", "gd_error_ex", "printf"], "callers": []}], "callerTree_before": {"read_header_tga": ["gdMalloc", "gdGetBuf", "gd_error", "printf"]}, "calleeTree_before": {"gdGetBuf": ["read_header_tga"], "gd_error": ["read_header_tga"], "printf": ["read_header_tga"], "gdMalloc": ["read_header_tga"]}, "callerTree_after": {"read_header_tga": ["gdGetBuf", "gd_error", "gdMalloc", "gd_error_ex", "printf"]}, "calleeTree_after": {"gdGetBuf": ["read_header_tga"], "gd_error": ["read_header_tga"], "printf": ["read_header_tga"], "gd_error_ex": ["read_header_tga"], "gdMalloc": ["read_header_tga"]}}
{"repo_after": "b69d11727d4f0f8cf719c79e3fb700f55ca03e9a", "repo_before": "b9cede3c19693b7663219691d8604e037cea673a", "functions_before": [{"name": "send_auth", "content": "static void send_auth(char *username, char *password) {\n\tstruct mt_packet data;\n\tunsigned short width = 0;\n\tunsigned short height = 0;\n\tchar *terminal = getenv(\"TERM\");\n\tchar md5data[100];\n\tunsigned char md5sum[17];\n\tint plen;\n\tmd5_state_t state;\n\n#if defined(__linux__) && defined(_POSIX_MEMLOCK_RANGE)\n\tmlock(md5data, sizeof(md5data));\n\tmlock(md5sum, sizeof(md5data));\n#endif\n\n\t/* Concat string of 0 + password + pass_salt */\n\tmd5data[0] = 0;\n\tstrncpy(md5data + 1, password, 82);\n\tmd5data[83] = '\\0';\n\tmemcpy(md5data + 1 + strlen(password), pass_salt, 16);\n\n\t/* Generate md5 sum of md5data with a leading 0 */\n\tmd5_init(&state);\n\tmd5_append(&state, (const md5_byte_t *)md5data, strlen(password) + 17);\n\tmd5_finish(&state, (md5_byte_t *)md5sum + 1);\n\tmd5sum[0] = 0;\n\n\t/* Send combined packet to server */\n\tinit_packet(&data, MT_PTYPE_DATA, srcmac, dstmac, sessionkey, outcounter);\n\tplen = add_control_packet(&data, MT_CPTYPE_PASSWORD, md5sum, 17);\n\tplen += add_control_packet(&data, MT_CPTYPE_USERNAME, username, strlen(username));\n\tplen += add_control_packet(&data, MT_CPTYPE_TERM_TYPE, terminal, strlen(terminal));\n\t\n\tif (is_a_tty && get_terminal_size(&width, &height) != -1) {\n\t\twidth = htole16(width);\n\t\theight = htole16(height);\n\t\tplen += add_control_packet(&data, MT_CPTYPE_TERM_WIDTH, &width, 2);\n\t\tplen += add_control_packet(&data, MT_CPTYPE_TERM_HEIGHT, &height, 2);\n\t}\n\n\toutcounter += plen;\n\n\t/* TODO: handle result */\n\tsend_udp(&data, 1);\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos_before\\2016_8\\b9cede3c19693b7663219691d8604e037cea673a_before\\MAC-Telnet-b9cede3c19693b7663219691d8604e037cea673a\\mactelnet.c", "callees": ["md5_append", "md5_finish", "strncpy", "send_udp", "init_packet", "htole16", "md5_init", "getenv", "strlen", "get_terminal_size", "add_control_packet", "memcpy", "mlock"], "callers": ["handle_packet"]}, {"name": "handle_packet", "content": "static int handle_packet(unsigned char *data, int data_len) {\n\tstruct mt_mactelnet_hdr pkthdr;\n\n\t/* Minimal size checks (pings are not supported here) */\n\tif (data_len < MT_HEADER_LEN){\n\t\treturn -1;\n\t}\n\tparse_packet(data, &pkthdr);\n\n\t/* We only care about packets with correct sessionkey */\n\tif (pkthdr.seskey != sessionkey) {\n\t\treturn -1;\n\t}\n\n\t/* Handle data packets */\n\tif (pkthdr.ptype == MT_PTYPE_DATA) {\n\t\tstruct mt_packet odata;\n\t\tstruct mt_mactelnet_control_hdr cpkt;\n\t\tint success = 0;\n\n\t\t/* Always transmit ACKNOWLEDGE packets in response to DATA packets */\n\t\tinit_packet(&odata, MT_PTYPE_ACK, srcmac, dstmac, sessionkey, pkthdr.counter + (data_len - MT_HEADER_LEN));\n\t\tsend_udp(&odata, 0);\n\n\t\t/* Accept first packet, and all packets greater than incounter, and if counter has\n\t\twrapped around. */\n\t\tif (pkthdr.counter > incounter || (incounter - pkthdr.counter) > 65535) {\n\t\t\tincounter = pkthdr.counter;\n\t\t} else {\n\t\t\t/* Ignore double or old packets */\n\t\t\treturn -1;\n\t\t}\n\n\t\t/* Parse controlpacket data */\n\t\tsuccess = parse_control_packet(data + MT_HEADER_LEN, data_len - MT_HEADER_LEN, &cpkt);\n\n\t\twhile (success) {\n\n\t\t\t/* If we receive pass_salt, transmit auth data back */\n\t\t\tif (cpkt.cptype == MT_CPTYPE_PASSSALT) {\n\t\t\t\tmemcpy(pass_salt, cpkt.data, cpkt.length);\n\t\t\t\tsend_auth(username, password);\n\t\t\t}\n\n\t\t\t/* If the (remaining) data did not have a control-packet magic byte sequence,\n\t\t\t   the data is raw terminal data to be outputted to the terminal. */\n\t\t\telse if (cpkt.cptype == MT_CPTYPE_PLAINDATA) {\n\t\t\t\tfwrite((const void *)cpkt.data, 1, cpkt.length, stdout);\n\t\t\t}\n\n\t\t\t/* END_AUTH means that the user/password negotiation is done, and after this point\n\t\t\t   terminal data may arrive, so we set up the terminal to raw mode. */\n\t\t\telse if (cpkt.cptype == MT_CPTYPE_END_AUTH) {\n\n\t\t\t\t/* we have entered \"terminal mode\" */\n\t\t\t\tterminal_mode = 1;\n\n\t\t\t\tif (is_a_tty) {\n\t\t\t\t\t/* stop input buffering at all levels. Give full control of terminal to RouterOS */\n\t\t\t\t\traw_term();\n\n\t\t\t\t\tsetvbuf(stdin,  (char*)NULL, _IONBF, 0);\n\n\t\t\t\t\t/* Add resize signal handler */\n\t\t\t\t\tsignal(SIGWINCH, sig_winch);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* Parse next controlpacket */\n\t\t\tsuccess = parse_control_packet(NULL, 0, &cpkt);\n\t\t}\n\t}\n\telse if (pkthdr.ptype == MT_PTYPE_ACK) {\n\t\t/* Handled elsewhere */\n\t}\n\n\t/* The server wants to terminate the connection, we have to oblige */\n\telse if (pkthdr.ptype == MT_PTYPE_END) {\n\t\tstruct mt_packet odata;\n\n\t\t/* Acknowledge the disconnection by sending a END packet in return */\n\t\tinit_packet(&odata, MT_PTYPE_END, srcmac, dstmac, pkthdr.seskey, 0);\n\t\tsend_udp(&odata, 0);\n\n\t\tif (!quiet_mode) {\n\t\t\tfprintf(stderr, _(\"Connection closed.\\n\"));\n\t\t}\n\n\t\t/* exit */\n\t\trunning = 0;\n\t} else {\n\t\tfprintf(stderr, _(\"Unhandeled packet type: %d received from server %s\\n\"), pkthdr.ptype, ether_ntoa((struct ether_addr *)dstmac));\n\t\treturn -1;\n\t}\n\n\treturn pkthdr.ptype;\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos_before\\2016_8\\b9cede3c19693b7663219691d8604e037cea673a_before\\MAC-Telnet-b9cede3c19693b7663219691d8604e037cea673a\\mactelnet.c", "callees": ["sig_winch", "fwrite", "send_udp", "fprintf", "init_packet", "send_auth", "parse_control_packet", "parse_packet", "signal", "setvbuf", "ether_ntoa", "raw_term", "memcpy"], "callers": []}, {"name": "user_login", "content": "static void user_login(struct mt_connection *curconn, struct mt_mactelnet_hdr *pkthdr) {\n\tstruct mt_packet pdata;\n\tunsigned char md5sum[17];\n\tchar md5data[100];\n\tstruct mt_credentials *user;\n\tchar *slavename;\n\n\t/* Reparse user file before each login */\n\tread_userfile();\n\n\tif ((user = find_user(curconn->username)) != NULL) {\n\t\tmd5_state_t state;\n#if defined(__linux__) && defined(_POSIX_MEMLOCK_RANGE)\n\t\tmlock(md5data, sizeof(md5data));\n\t\tmlock(md5sum, sizeof(md5sum));\n\t\tif (user->password != NULL) {\n\t\t\tmlock(user->password, strlen(user->password));\n\t\t}\n#endif\n\n\t\t/* Concat string of 0 + password + pass_salt */\n\t\tmd5data[0] = 0;\n\t\tstrncpy(md5data + 1, user->password, 82);\n\t\tmemcpy(md5data + 1 + strlen(user->password), curconn->pass_salt, 16);\n\n\t\t/* Generate md5 sum of md5data with a leading 0 */\n\t\tmd5_init(&state);\n\t\tmd5_append(&state, (const md5_byte_t *)md5data, strlen(user->password) + 17);\n\t\tmd5_finish(&state, (md5_byte_t *)md5sum + 1);\n\t\tmd5sum[0] = 0;\n\n\t\tinit_packet(&pdata, MT_PTYPE_DATA, pkthdr->dstaddr, pkthdr->srcaddr, pkthdr->seskey, curconn->outcounter);\n\t\tcurconn->outcounter += add_control_packet(&pdata, MT_CPTYPE_END_AUTH, NULL, 0);\n\t\tsend_udp(curconn, &pdata);\n\n\t\tif (curconn->state == STATE_ACTIVE) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (user == NULL || memcmp(md5sum, curconn->trypassword, 17) != 0) {\n\t\tsyslog(LOG_NOTICE, _(\"(%d) Invalid login by %s.\"), curconn->seskey, curconn->username);\n\n\t\t/*_ Please include both \\r and \\n in translation, this is needed for the terminal emulator. */\n\t\tabort_connection(curconn, pkthdr, _(\"Login failed, incorrect username or password\\r\\n\"));\n\n\t\t/* TODO: should wait some time (not with sleep) before returning, to minimalize brute force attacks */\n\t\treturn;\n\t}\n\n\t/* User is logged in */\n\tcurconn->state = STATE_ACTIVE;\n\n\t/* Enter terminal mode */\n\tcurconn->terminal_mode = 1;\n\n\t/* Open pts handle */\n\tcurconn->ptsfd = posix_openpt(O_RDWR);\n\tif (curconn->ptsfd == -1 || grantpt(curconn->ptsfd) == -1 || unlockpt(curconn->ptsfd) == -1) {\n\t\t\tsyslog(LOG_ERR, \"posix_openpt: %s\", strerror(errno));\n\t\t\t/*_ Please include both \\r and \\n in translation, this is needed for the terminal emulator. */\n\t\t\tabort_connection(curconn, pkthdr, _(\"Terminal error\\r\\n\"));\n\t\t\treturn;\n\t}\n\n\t/* Get file path for our pts */\n\tslavename = ptsname(curconn->ptsfd);\n\tif (slavename != NULL) {\n\t\tpid_t pid;\n\t\tstruct stat sb;\n\t\tstruct passwd *user = (struct passwd *)malloc(sizeof(struct passwd));\n\t\tstruct passwd *tmpuser=user;\n\t\tchar *buffer = malloc(1024);\n\n\t\tif (user == NULL || buffer == NULL) {\n\t\t\tsyslog(LOG_CRIT, _(\"(%d) Error allocating memory.\"), curconn->seskey);\n\t\t\t/*_ Please include both \\r and \\n in translation, this is needed for the terminal emulator. */\n\t\t\tabort_connection(curconn, pkthdr, _(\"System error, out of memory\\r\\n\"));\n\t\t\treturn;\n\t\t}\n\n\t\tif (getpwnam_r(curconn->username, user, buffer, 1024, &tmpuser) != 0) {\n\t\t\tsyslog(LOG_WARNING, _(\"(%d) Login ok, but local user not accessible (%s).\"), curconn->seskey, curconn->username);\n\t\t\t/*_ Please include both \\r and \\n in translation, this is needed for the terminal emulator. */\n\t\t\tabort_connection(curconn, pkthdr, _(\"Local user not accessible\\r\\n\"));\n\t\t\tfree(user);\n\t\t\tfree(buffer);\n\t\t\treturn;\n\t\t}\n\n\t\t/* Change the owner of the slave pts */\n\t\tchown(slavename, user->pw_uid, user->pw_gid);\n\n\t\tcurconn->slavefd = open(slavename, O_RDWR);\n\t\tif (curconn->slavefd == -1) {\n\t\t\tsyslog(LOG_ERR, _(\"Error opening %s: %s\"), slavename, strerror(errno));\n\t\t\t/*_ Please include both \\r and \\n in translation, this is needed for the terminal emulator. */\n\t\t\tabort_connection(curconn, pkthdr, _(\"Error opening terminal\\r\\n\"));\n\t\t\tlist_remove_connection(curconn);\n\t\t\treturn;\n\t\t}\n\n\t\tif ((pid = fork()) == 0) {\n\t\t\tstruct net_interface *interface;\n\n\t\t\t/* Add login information to utmp/wtmp */\n\t\t\tuwtmp_login(curconn);\n\n\t\t\tsyslog(LOG_INFO, _(\"(%d) User %s logged in.\"), curconn->seskey, curconn->username);\n\n\t\t\t/* Initialize terminal environment */\n\t\t\tsetenv(\"USER\", user->pw_name, 1);\n\t\t\tsetenv(\"HOME\", user->pw_dir, 1);\n\t\t\tsetenv(\"SHELL\", user->pw_shell, 1);\n\t\t\tsetenv(\"TERM\", curconn->terminal_type, 1);\n\t\t\tclose(sockfd);\n\t\t\tclose(insockfd);\n\n\t\t\tDL_FOREACH(interfaces, interface) {\n\t\t\t\tif (interface->socketfd > 0) {\n\t\t\t\t\tclose(interface->socketfd);\n\t\t\t\t}\n\t\t\t}\n\t\t\tsetsid();\n\n\t\t\t/* Don't let shell process inherit slavefd */\n\t\t\tfcntl (curconn->slavefd, F_SETFD, FD_CLOEXEC);\n\t\t\tclose(curconn->ptsfd);\n\n\t\t\t/* Redirect STDIN/STDIO/STDERR */\n\t\t\tclose(0);\n\t\t\tdup(curconn->slavefd);\n\t\t\tclose(1);\n\t\t\tdup(curconn->slavefd);\n\t\t\tclose(2);\n\t\t\tdup(curconn->slavefd);\n\n\t\t\t/* Set controlling terminal */\n\t\t\tioctl(0, TIOCSCTTY, 1);\n\t\t\ttcsetpgrp(0, getpid());\n\n\t\t\t/* Set user id/group id */\n\t\t\tif ((setgid(user->pw_gid) != 0) || (setuid(user->pw_uid) != 0)) {\n\t\t\t\tsyslog(LOG_ERR, _(\"(%d) Could not log in %s (%d:%d): setuid/setgid: %s\"), curconn->seskey, curconn->username, user->pw_uid, user->pw_gid, strerror(errno));\n\t\t\t\t/*_ Please include both \\r and \\n in translation, this is needed for the terminal emulator. */\n\t\t\t\tabort_connection(curconn, pkthdr, _(\"Internal error\\r\\n\"));\n\t\t\t\texit(0);\n\t\t\t}\n\n\t\t\t/* Abort login if /etc/nologin exists */\n\t\t\tif (stat(_PATH_NOLOGIN, &sb) == 0 && getuid() != 0) {\n\t\t\t\tsyslog(LOG_NOTICE, _(\"(%d) User %s disconnected with \" _PATH_NOLOGIN \" message.\"), curconn->seskey, curconn->username);\n\t\t\t\tdisplay_nologin();\n\t\t\t\tcurconn->state = STATE_CLOSED;\n\t\t\t\tinit_packet(&pdata, MT_PTYPE_END, pkthdr->dstaddr, pkthdr->srcaddr, pkthdr->seskey, curconn->outcounter);\n\t\t\t\tsend_udp(curconn, &pdata);\n\t\t\t\texit(0);\n\t\t\t}\n\n\t\t\t/* Display MOTD */\n\t\t\tdisplay_motd();\n\n\t\t\tchdir(user->pw_dir);\n\n\t\t\t/* Spawn shell */\n\t\t\t/* TODO: Maybe use \"login -f USER\" instead? renders motd and executes shell correctly for system */\n\t\t\texecl(user->pw_shell, user->pw_shell, \"-\", (char *) 0);\n\t\t\texit(0); // just to be sure.\n\t\t}\n\t\tfree(user);\n\t\tfree(buffer);\n\t\tclose(curconn->slavefd);\n\t\tcurconn->pid = pid;\n\t\tset_terminal_size(curconn->ptsfd, curconn->terminal_width, curconn->terminal_height);\n\t}\n\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos_before\\2016_8\\b9cede3c19693b7663219691d8604e037cea673a_before\\MAC-Telnet-b9cede3c19693b7663219691d8604e037cea673a\\mactelnetd.c", "callees": [], "callers": []}, {"name": "handle_data_packet", "content": "static void handle_data_packet(struct mt_connection *curconn, struct mt_mactelnet_hdr *pkthdr, int data_len) {\n\tstruct mt_mactelnet_control_hdr cpkt;\n\tstruct mt_packet pdata;\n\tunsigned char *data = pkthdr->data;\n\tunsigned int act_size = 0;\n\tint got_user_packet = 0;\n\tint got_pass_packet = 0;\n\tint got_width_packet = 0;\n\tint got_height_packet = 0;\n\tint success;\n\n\t/* Parse first control packet */\n\tsuccess = parse_control_packet(data, data_len - MT_HEADER_LEN, &cpkt);\n\n\twhile (success) {\n\t\tif (cpkt.cptype == MT_CPTYPE_BEGINAUTH) {\n\t\t\tint plen,i;\n\t\t\tif (!curconn->have_pass_salt) {\n\t\t\t\tfor (i = 0; i < 16; ++i) {\n\t\t\t\t\tcurconn->pass_salt[i] = rand() % 256;\n\t\t\t\t}\n\t\t\t\tcurconn->have_pass_salt = 1;\n\n\t\t\t\tmemset(curconn->trypassword, 0, sizeof(curconn->trypassword));\n\t\t\t}\n\t\t\tinit_packet(&pdata, MT_PTYPE_DATA, pkthdr->dstaddr, pkthdr->srcaddr, pkthdr->seskey, curconn->outcounter);\n\t\t\tplen = add_control_packet(&pdata, MT_CPTYPE_PASSSALT, (curconn->pass_salt), 16);\n\t\t\tcurconn->outcounter += plen;\n\n\t\t\tsend_udp(curconn, &pdata);\n\t\t\n\t\t/* Don't change the username after the state is active */\n\t\t} else if (cpkt.cptype == MT_CPTYPE_USERNAME && curconn->state != STATE_ACTIVE) {\n\t\t\tmemcpy(curconn->username, cpkt.data, act_size = (cpkt.length > MT_MNDP_MAX_STRING_SIZE - 1 ? MT_MNDP_MAX_STRING_SIZE - 1 : cpkt.length));\n\t\t\tcurconn->username[act_size] = 0;\n\t\t\tgot_user_packet = 1;\n\n\t\t} else if (cpkt.cptype == MT_CPTYPE_TERM_WIDTH && cpkt.length >= 2) {\n\t\t\tunsigned short width;\n\n\t\t\tmemcpy(&width, cpkt.data, 2);\n\t\t\tcurconn->terminal_width = le16toh(width);\n\t\t\tgot_width_packet = 1;\n\n\t\t} else if (cpkt.cptype == MT_CPTYPE_TERM_HEIGHT && cpkt.length >= 2) {\n\t\t\tunsigned short height;\n\n\t\t\tmemcpy(&height, cpkt.data, 2);\n\t\t\tcurconn->terminal_height = le16toh(height);\n\t\t\tgot_height_packet = 1;\n\n\t\t} else if (cpkt.cptype == MT_CPTYPE_TERM_TYPE) {\n\n\t\t\tmemcpy(curconn->terminal_type, cpkt.data, act_size = (cpkt.length > 30 - 1 ? 30 - 1 : cpkt.length));\n\t\t\tcurconn->terminal_type[act_size] = 0;\n\n\t\t} else if (cpkt.cptype == MT_CPTYPE_PASSWORD) {\n\n#if defined(__linux__) && defined(_POSIX_MEMLOCK_RANGE)\n\t\t\tmlock(curconn->trypassword, 17);\n#endif\n\t\t\tmemcpy(curconn->trypassword, cpkt.data, 17);\n\t\t\tgot_pass_packet = 1;\n\n\t\t} else if (cpkt.cptype == MT_CPTYPE_PLAINDATA) {\n\n\t\t\t/* relay data from client to shell */\n\t\t\tif (curconn->state == STATE_ACTIVE && curconn->ptsfd != -1) {\n\t\t\t\twrite(curconn->ptsfd, cpkt.data, cpkt.length);\n\t\t\t}\n\n\t\t} else {\n\t\t\tsyslog(LOG_WARNING, _(\"(%d) Unhandeled control packet type: %d\"), curconn->seskey, cpkt.cptype);\n\t\t}\n\n\t\t/* Parse next control packet */\n\t\tsuccess = parse_control_packet(NULL, 0, &cpkt);\n\t}\n\n\tif (got_user_packet && got_pass_packet) {\n\t\tuser_login(curconn, pkthdr);\n\t}\n\n\tif (curconn->state == STATE_ACTIVE && (got_width_packet || got_height_packet)) {\n\t\tset_terminal_size(curconn->ptsfd, curconn->terminal_width, curconn->terminal_height);\n\n\t}\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos_before\\2016_8\\b9cede3c19693b7663219691d8604e037cea673a_before\\MAC-Telnet-b9cede3c19693b7663219691d8604e037cea673a\\mactelnetd.c", "callees": [], "callers": []}, {"name": "add_control_packet", "content": "int add_control_packet(struct mt_packet *packet, enum mt_cptype cptype, void *cpdata, unsigned short data_len) {\n\tunsigned char *data = packet->data + packet->size;\n\tunsigned int act_size = data_len + (cptype == MT_CPTYPE_PLAINDATA ? 0 : MT_CPHEADER_LEN);\n\n\t/* Something is really wrong. Packets should never become over 1500 bytes */\n\tif (packet->size + act_size > MT_PACKET_LEN) {\n\t\tfprintf(stderr, _(\"add_control_packet: ERROR, too large packet. Exceeds %d bytes\\n\"), MT_PACKET_LEN);\n\t\treturn -1;\n\t\t//exit(1);\n\t}\n\n\t/* PLAINDATA isn't really a controlpacket, but we handle it here, since\n\t   parseControlPacket also parses raw data as PLAINDATA */\n\tif (cptype == MT_CPTYPE_PLAINDATA) {\n\t\tmemcpy(data, cpdata, data_len);\n\t\tpacket->size += data_len;\n\t\treturn data_len;\n\t}\n\n\t/* Control Packet Magic id */\n\tmemcpy(data, mt_mactelnet_cpmagic, sizeof(mt_mactelnet_cpmagic));\n\n\t/* Control packet type */\n\tdata[4] = cptype;\n\n\t/* Data length */\n#if BYTE_ORDER == LITTLE_ENDIAN\n\t{\n\t\tunsigned int templen;\n\t\ttemplen = htonl(data_len);\n\t\tmemcpy(data + 5, &templen, sizeof(templen));\n\t}\n#else\n\tmemcpy(data + 5, &data_len, sizeof(data_len));\n#endif\n\n\t/* Insert data */\n\tif (data_len > 0) {\n\t\tmemcpy(data + MT_CPHEADER_LEN, cpdata, data_len);\n\t}\n\n\tpacket->size += act_size;\n\t/* Control packet header length + data length */\n\treturn act_size;\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos_before\\2016_8\\b9cede3c19693b7663219691d8604e037cea673a_before\\MAC-Telnet-b9cede3c19693b7663219691d8604e037cea673a\\protocol.c", "callees": ["fprintf", "htonl", "memcpy"], "callers": ["send_auth"]}, {"name": "add_packetdata", "content": "int add_packetdata(struct mt_packet *packet, unsigned char *data, unsigned short length) {\n\tif (packet->size + length > MT_PACKET_LEN) {\n\t\tfprintf(stderr, _(\"add_control_packet: ERROR, too large packet. Exceeds %d bytes\\n\"), MT_PACKET_LEN);\n\t\treturn -1;\n\t}\n\n\tmemcpy(packet->data + packet->size, data, length);\n\tpacket->size += length;\n\n\treturn length;\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos_before\\2016_8\\b9cede3c19693b7663219691d8604e037cea673a_before\\MAC-Telnet-b9cede3c19693b7663219691d8604e037cea673a\\protocol.c", "callees": ["fprintf", "memcpy"], "callers": []}, {"name": "mndp_add_attribute", "content": "int mndp_add_attribute(struct mt_packet *packet, enum mt_mndp_attrtype attrtype, void *attrdata, unsigned short data_len) {\n\tunsigned char *data = packet->data + packet->size;\n\tunsigned short type = attrtype;\n\tunsigned short len = data_len;\n\n\t/* Something is really wrong. Packets should never become over 1500 bytes */\n\tif (packet->size + 4 + data_len > MT_PACKET_LEN) {\n\t\tfprintf(stderr, _(\"mndp_add_attribute: ERROR, too large packet. Exceeds %d bytes\\n\"), MT_PACKET_LEN);\n\t\treturn -1;\n\t}\n\n\ttype = htons(type);\n\tmemcpy(data, &type, sizeof(type));\n\n\tlen = htons(len);\n\tmemcpy(data + 2, &len, sizeof(len));\n\n\tmemcpy(data + 4, attrdata, data_len);\n\n\tpacket->size += 4 + data_len;\n\n\treturn 4 + data_len;\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos_before\\2016_8\\b9cede3c19693b7663219691d8604e037cea673a_before\\MAC-Telnet-b9cede3c19693b7663219691d8604e037cea673a\\protocol.c", "callees": ["fprintf", "memcpy", "htons"], "callers": []}], "functions_after": [{"name": "send_auth", "content": "static void send_auth(char *username, char *password) {\n\tstruct mt_packet data;\n\tunsigned short width = 0;\n\tunsigned short height = 0;\n\tchar *terminal = getenv(\"TERM\");\n\tchar md5data[100];\n\tunsigned char md5sum[17];\n\tint plen, act_pass_len;\n\tmd5_state_t state;\n\n#if defined(__linux__) && defined(_POSIX_MEMLOCK_RANGE)\n\tmlock(md5data, sizeof(md5data));\n\tmlock(md5sum, sizeof(md5data));\n#endif\n\n\t/* calculate the actual password's length */\n\tact_pass_len = strnlen(password, 82);\n\n\t/* Concat string of 0 + password + pass_salt */\n\tmd5data[0] = 0;\n\tmemcpy(md5data + 1, password, act_pass_len);\n\t/* in case that password is long, calculate only using the used-up parts */\n\tmemcpy(md5data + 1 + act_pass_len, pass_salt, 16);\n\n\t/* Generate md5 sum of md5data with a leading 0 */\n\tmd5_init(&state);\n\tmd5_append(&state, (const md5_byte_t *)md5data, 1 + act_pass_len + 16);\n\tmd5_finish(&state, (md5_byte_t *)md5sum + 1);\n\tmd5sum[0] = 0;\n\n\t/* Send combined packet to server */\n\tinit_packet(&data, MT_PTYPE_DATA, srcmac, dstmac, sessionkey, outcounter);\n\tplen = add_control_packet(&data, MT_CPTYPE_PASSWORD, md5sum, 17);\n\tplen += add_control_packet(&data, MT_CPTYPE_USERNAME, username, strlen(username));\n\tplen += add_control_packet(&data, MT_CPTYPE_TERM_TYPE, terminal, strlen(terminal));\n\t\n\tif (is_a_tty && get_terminal_size(&width, &height) != -1) {\n\t\twidth = htole16(width);\n\t\theight = htole16(height);\n\t\tplen += add_control_packet(&data, MT_CPTYPE_TERM_WIDTH, &width, 2);\n\t\tplen += add_control_packet(&data, MT_CPTYPE_TERM_HEIGHT, &height, 2);\n\t}\n\n\toutcounter += plen;\n\n\t/* TODO: handle result */\n\tsend_udp(&data, 1);\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos\\2016_8\\b69d11727d4f0f8cf719c79e3fb700f55ca03e9a_after\\MAC-Telnet-b69d11727d4f0f8cf719c79e3fb700f55ca03e9a\\mactelnet.c", "callees": ["md5_append", "md5_finish", "send_udp", "init_packet", "htole16", "md5_init", "getenv", "strlen", "get_terminal_size", "strnlen", "add_control_packet", "memcpy", "mlock"], "callers": ["handle_packet"]}, {"name": "handle_packet", "content": "static int handle_packet(unsigned char *data, int data_len) {\n\tstruct mt_mactelnet_hdr pkthdr;\n\n\t/* Minimal size checks (pings are not supported here) */\n\tif (data_len < MT_HEADER_LEN){\n\t\treturn -1;\n\t}\n\tparse_packet(data, &pkthdr);\n\n\t/* We only care about packets with correct sessionkey */\n\tif (pkthdr.seskey != sessionkey) {\n\t\treturn -1;\n\t}\n\n\t/* Handle data packets */\n\tif (pkthdr.ptype == MT_PTYPE_DATA) {\n\t\tstruct mt_packet odata;\n\t\tstruct mt_mactelnet_control_hdr cpkt;\n\t\tint success = 0;\n\n\t\t/* Always transmit ACKNOWLEDGE packets in response to DATA packets */\n\t\tinit_packet(&odata, MT_PTYPE_ACK, srcmac, dstmac, sessionkey, pkthdr.counter + (data_len - MT_HEADER_LEN));\n\t\tsend_udp(&odata, 0);\n\n\t\t/* Accept first packet, and all packets greater than incounter, and if counter has\n\t\twrapped around. */\n\t\tif (pkthdr.counter > incounter || (incounter - pkthdr.counter) > 65535) {\n\t\t\tincounter = pkthdr.counter;\n\t\t} else {\n\t\t\t/* Ignore double or old packets */\n\t\t\treturn -1;\n\t\t}\n\n\t\t/* Parse controlpacket data */\n\t\tsuccess = parse_control_packet(data + MT_HEADER_LEN, data_len - MT_HEADER_LEN, &cpkt);\n\n\t\twhile (success) {\n\n\t\t\t/* If we receive pass_salt, transmit auth data back */\n\t\t\tif (cpkt.cptype == MT_CPTYPE_PASSSALT) {\n\t\t\t\t/* check validity, server sends exactly 16 bytes */\n\t\t\t\tif (cpkt.length != 16) {\n\t\t\t\t\tfprintf(stderr, _(\"Invalid salt length: %d (instead of 16) received from server %s\\n\"), cpkt.length, ether_ntoa((struct ether_addr *)dstmac));\n\t\t\t\t}\n\t\t\t\tmemcpy(pass_salt, cpkt.data, 16);\n\t\t\t\tsend_auth(username, password);\n\t\t\t}\n\n\t\t\t/* If the (remaining) data did not have a control-packet magic byte sequence,\n\t\t\t   the data is raw terminal data to be outputted to the terminal. */\n\t\t\telse if (cpkt.cptype == MT_CPTYPE_PLAINDATA) {\n\t\t\t\tfwrite((const void *)cpkt.data, 1, cpkt.length, stdout);\n\t\t\t}\n\n\t\t\t/* END_AUTH means that the user/password negotiation is done, and after this point\n\t\t\t   terminal data may arrive, so we set up the terminal to raw mode. */\n\t\t\telse if (cpkt.cptype == MT_CPTYPE_END_AUTH) {\n\n\t\t\t\t/* we have entered \"terminal mode\" */\n\t\t\t\tterminal_mode = 1;\n\n\t\t\t\tif (is_a_tty) {\n\t\t\t\t\t/* stop input buffering at all levels. Give full control of terminal to RouterOS */\n\t\t\t\t\traw_term();\n\n\t\t\t\t\tsetvbuf(stdin,  (char*)NULL, _IONBF, 0);\n\n\t\t\t\t\t/* Add resize signal handler */\n\t\t\t\t\tsignal(SIGWINCH, sig_winch);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* Parse next controlpacket */\n\t\t\tsuccess = parse_control_packet(NULL, 0, &cpkt);\n\t\t}\n\t}\n\telse if (pkthdr.ptype == MT_PTYPE_ACK) {\n\t\t/* Handled elsewhere */\n\t}\n\n\t/* The server wants to terminate the connection, we have to oblige */\n\telse if (pkthdr.ptype == MT_PTYPE_END) {\n\t\tstruct mt_packet odata;\n\n\t\t/* Acknowledge the disconnection by sending a END packet in return */\n\t\tinit_packet(&odata, MT_PTYPE_END, srcmac, dstmac, pkthdr.seskey, 0);\n\t\tsend_udp(&odata, 0);\n\n\t\tif (!quiet_mode) {\n\t\t\tfprintf(stderr, _(\"Connection closed.\\n\"));\n\t\t}\n\n\t\t/* exit */\n\t\trunning = 0;\n\t} else {\n\t\tfprintf(stderr, _(\"Unhandeled packet type: %d received from server %s\\n\"), pkthdr.ptype, ether_ntoa((struct ether_addr *)dstmac));\n\t\treturn -1;\n\t}\n\n\treturn pkthdr.ptype;\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos\\2016_8\\b69d11727d4f0f8cf719c79e3fb700f55ca03e9a_after\\MAC-Telnet-b69d11727d4f0f8cf719c79e3fb700f55ca03e9a\\mactelnet.c", "callees": ["sig_winch", "fwrite", "send_udp", "fprintf", "init_packet", "send_auth", "parse_control_packet", "parse_packet", "signal", "setvbuf", "ether_ntoa", "raw_term", "memcpy"], "callers": []}, {"name": "user_login", "content": "static void user_login(struct mt_connection *curconn, struct mt_mactelnet_hdr *pkthdr) {\n\tstruct mt_packet pdata;\n\tunsigned char md5sum[17];\n\tchar md5data[100];\n\tstruct mt_credentials *user;\n\tchar *slavename;\n\tint act_pass_len;\n\n\t/* Reparse user file before each login */\n\tread_userfile();\n\n\tif ((user = find_user(curconn->username)) != NULL) {\n\t\tmd5_state_t state;\n#if defined(__linux__) && defined(_POSIX_MEMLOCK_RANGE)\n\t\tmlock(md5data, sizeof(md5data));\n\t\tmlock(md5sum, sizeof(md5sum));\n\t\tif (user->password != NULL) {\n\t\t\tmlock(user->password, strlen(user->password));\n\t\t}\n#endif\n\n\t\t/* calculate the password's actual length */\n\t\tact_pass_len = strlen(user->password);\n\t\tact_pass_len = act_pass_len <= 82 ? act_pass_len : 82;\n\n\t\t/* Concat string of 0 + password + pass_salt */\n\t\tmd5data[0] = 0;\n\t\tmemcpy(md5data + 1, user->password, act_pass_len);\n\t\tmemcpy(md5data + 1 + act_pass_len, curconn->pass_salt, 16);\n\n\t\t/* Generate md5 sum of md5data with a leading 0 */\n\t\tmd5_init(&state);\n\t\tmd5_append(&state, (const md5_byte_t *)md5data, 1 + act_pass_len + 16);\n\t\tmd5_finish(&state, (md5_byte_t *)md5sum + 1);\n\t\tmd5sum[0] = 0;\n\n\t\tinit_packet(&pdata, MT_PTYPE_DATA, pkthdr->dstaddr, pkthdr->srcaddr, pkthdr->seskey, curconn->outcounter);\n\t\tcurconn->outcounter += add_control_packet(&pdata, MT_CPTYPE_END_AUTH, NULL, 0);\n\t\tsend_udp(curconn, &pdata);\n\n\t\tif (curconn->state == STATE_ACTIVE) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (user == NULL || memcmp(md5sum, curconn->trypassword, 17) != 0) {\n\t\tsyslog(LOG_NOTICE, _(\"(%d) Invalid login by %s.\"), curconn->seskey, curconn->username);\n\n\t\t/*_ Please include both \\r and \\n in translation, this is needed for the terminal emulator. */\n\t\tabort_connection(curconn, pkthdr, _(\"Login failed, incorrect username or password\\r\\n\"));\n\n\t\t/* TODO: should wait some time (not with sleep) before returning, to minimalize brute force attacks */\n\t\treturn;\n\t}\n\n\t/* User is logged in */\n\tcurconn->state = STATE_ACTIVE;\n\n\t/* Enter terminal mode */\n\tcurconn->terminal_mode = 1;\n\n\t/* Open pts handle */\n\tcurconn->ptsfd = posix_openpt(O_RDWR);\n\tif (curconn->ptsfd == -1 || grantpt(curconn->ptsfd) == -1 || unlockpt(curconn->ptsfd) == -1) {\n\t\t\tsyslog(LOG_ERR, \"posix_openpt: %s\", strerror(errno));\n\t\t\t/*_ Please include both \\r and \\n in translation, this is needed for the terminal emulator. */\n\t\t\tabort_connection(curconn, pkthdr, _(\"Terminal error\\r\\n\"));\n\t\t\treturn;\n\t}\n\n\t/* Get file path for our pts */\n\tslavename = ptsname(curconn->ptsfd);\n\tif (slavename != NULL) {\n\t\tpid_t pid;\n\t\tstruct stat sb;\n\t\tstruct passwd *user = (struct passwd *)malloc(sizeof(struct passwd));\n\t\tstruct passwd *tmpuser=user;\n\t\tchar *buffer = malloc(1024);\n\n\t\tif (user == NULL || buffer == NULL) {\n\t\t\tsyslog(LOG_CRIT, _(\"(%d) Error allocating memory.\"), curconn->seskey);\n\t\t\t/*_ Please include both \\r and \\n in translation, this is needed for the terminal emulator. */\n\t\t\tabort_connection(curconn, pkthdr, _(\"System error, out of memory\\r\\n\"));\n\t\t\treturn;\n\t\t}\n\n\t\tif (getpwnam_r(curconn->username, user, buffer, 1024, &tmpuser) != 0) {\n\t\t\tsyslog(LOG_WARNING, _(\"(%d) Login ok, but local user not accessible (%s).\"), curconn->seskey, curconn->username);\n\t\t\t/*_ Please include both \\r and \\n in translation, this is needed for the terminal emulator. */\n\t\t\tabort_connection(curconn, pkthdr, _(\"Local user not accessible\\r\\n\"));\n\t\t\tfree(user);\n\t\t\tfree(buffer);\n\t\t\treturn;\n\t\t}\n\n\t\t/* Change the owner of the slave pts */\n\t\tchown(slavename, user->pw_uid, user->pw_gid);\n\n\t\tcurconn->slavefd = open(slavename, O_RDWR);\n\t\tif (curconn->slavefd == -1) {\n\t\t\tsyslog(LOG_ERR, _(\"Error opening %s: %s\"), slavename, strerror(errno));\n\t\t\t/*_ Please include both \\r and \\n in translation, this is needed for the terminal emulator. */\n\t\t\tabort_connection(curconn, pkthdr, _(\"Error opening terminal\\r\\n\"));\n\t\t\tlist_remove_connection(curconn);\n\t\t\treturn;\n\t\t}\n\n\t\tif ((pid = fork()) == 0) {\n\t\t\tstruct net_interface *interface;\n\n\t\t\t/* Add login information to utmp/wtmp */\n\t\t\tuwtmp_login(curconn);\n\n\t\t\tsyslog(LOG_INFO, _(\"(%d) User %s logged in.\"), curconn->seskey, curconn->username);\n\n\t\t\t/* Initialize terminal environment */\n\t\t\tsetenv(\"USER\", user->pw_name, 1);\n\t\t\tsetenv(\"HOME\", user->pw_dir, 1);\n\t\t\tsetenv(\"SHELL\", user->pw_shell, 1);\n\t\t\tsetenv(\"TERM\", curconn->terminal_type, 1);\n\t\t\tclose(sockfd);\n\t\t\tclose(insockfd);\n\n\t\t\tDL_FOREACH(interfaces, interface) {\n\t\t\t\tif (interface->socketfd > 0) {\n\t\t\t\t\tclose(interface->socketfd);\n\t\t\t\t}\n\t\t\t}\n\t\t\tsetsid();\n\n\t\t\t/* Don't let shell process inherit slavefd */\n\t\t\tfcntl (curconn->slavefd, F_SETFD, FD_CLOEXEC);\n\t\t\tclose(curconn->ptsfd);\n\n\t\t\t/* Redirect STDIN/STDIO/STDERR */\n\t\t\tclose(0);\n\t\t\tdup(curconn->slavefd);\n\t\t\tclose(1);\n\t\t\tdup(curconn->slavefd);\n\t\t\tclose(2);\n\t\t\tdup(curconn->slavefd);\n\n\t\t\t/* Set controlling terminal */\n\t\t\tioctl(0, TIOCSCTTY, 1);\n\t\t\ttcsetpgrp(0, getpid());\n\n\t\t\t/* Set user id/group id */\n\t\t\tif ((setgid(user->pw_gid) != 0) || (setuid(user->pw_uid) != 0)) {\n\t\t\t\tsyslog(LOG_ERR, _(\"(%d) Could not log in %s (%d:%d): setuid/setgid: %s\"), curconn->seskey, curconn->username, user->pw_uid, user->pw_gid, strerror(errno));\n\t\t\t\t/*_ Please include both \\r and \\n in translation, this is needed for the terminal emulator. */\n\t\t\t\tabort_connection(curconn, pkthdr, _(\"Internal error\\r\\n\"));\n\t\t\t\texit(0);\n\t\t\t}\n\n\t\t\t/* Abort login if /etc/nologin exists */\n\t\t\tif (stat(_PATH_NOLOGIN, &sb) == 0 && getuid() != 0) {\n\t\t\t\tsyslog(LOG_NOTICE, _(\"(%d) User %s disconnected with \" _PATH_NOLOGIN \" message.\"), curconn->seskey, curconn->username);\n\t\t\t\tdisplay_nologin();\n\t\t\t\tcurconn->state = STATE_CLOSED;\n\t\t\t\tinit_packet(&pdata, MT_PTYPE_END, pkthdr->dstaddr, pkthdr->srcaddr, pkthdr->seskey, curconn->outcounter);\n\t\t\t\tsend_udp(curconn, &pdata);\n\t\t\t\texit(0);\n\t\t\t}\n\n\t\t\t/* Display MOTD */\n\t\t\tdisplay_motd();\n\n\t\t\tchdir(user->pw_dir);\n\n\t\t\t/* Spawn shell */\n\t\t\t/* TODO: Maybe use \"login -f USER\" instead? renders motd and executes shell correctly for system */\n\t\t\texecl(user->pw_shell, user->pw_shell, \"-\", (char *) 0);\n\t\t\texit(0); // just to be sure.\n\t\t}\n\t\tfree(user);\n\t\tfree(buffer);\n\t\tclose(curconn->slavefd);\n\t\tcurconn->pid = pid;\n\t\tset_terminal_size(curconn->ptsfd, curconn->terminal_width, curconn->terminal_height);\n\t}\n\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos\\2016_8\\b69d11727d4f0f8cf719c79e3fb700f55ca03e9a_after\\MAC-Telnet-b69d11727d4f0f8cf719c79e3fb700f55ca03e9a\\mactelnetd.c", "callees": [], "callers": []}, {"name": "handle_data_packet", "content": "static void handle_data_packet(struct mt_connection *curconn, struct mt_mactelnet_hdr *pkthdr, int data_len) {\n\tstruct mt_mactelnet_control_hdr cpkt;\n\tstruct mt_packet pdata;\n\tunsigned char *data = pkthdr->data;\n\tunsigned int act_size = 0;\n\tint got_user_packet = 0;\n\tint got_pass_packet = 0;\n\tint got_width_packet = 0;\n\tint got_height_packet = 0;\n\tint success;\n\n\t/* Parse first control packet */\n\tsuccess = parse_control_packet(data, data_len - MT_HEADER_LEN, &cpkt);\n\n\twhile (success) {\n\t\tif (cpkt.cptype == MT_CPTYPE_BEGINAUTH) {\n\t\t\tint plen,i;\n\t\t\tif (!curconn->have_pass_salt) {\n\t\t\t\tfor (i = 0; i < 16; ++i) {\n\t\t\t\t\tcurconn->pass_salt[i] = rand() % 256;\n\t\t\t\t}\n\t\t\t\tcurconn->have_pass_salt = 1;\n\n\t\t\t\tmemset(curconn->trypassword, 0, sizeof(curconn->trypassword));\n\t\t\t}\n\t\t\tinit_packet(&pdata, MT_PTYPE_DATA, pkthdr->dstaddr, pkthdr->srcaddr, pkthdr->seskey, curconn->outcounter);\n\t\t\tplen = add_control_packet(&pdata, MT_CPTYPE_PASSSALT, (curconn->pass_salt), 16);\n\t\t\tcurconn->outcounter += plen;\n\n\t\t\tsend_udp(curconn, &pdata);\n\t\t\n\t\t/* Don't change the username after the state is active */\n\t\t} else if (cpkt.cptype == MT_CPTYPE_USERNAME && curconn->state != STATE_ACTIVE) {\n\t\t\tmemcpy(curconn->username, cpkt.data, act_size = (cpkt.length > MT_MNDP_MAX_STRING_SIZE - 1 ? MT_MNDP_MAX_STRING_SIZE - 1 : cpkt.length));\n\t\t\tcurconn->username[act_size] = 0;\n\t\t\tgot_user_packet = 1;\n\n\t\t} else if (cpkt.cptype == MT_CPTYPE_TERM_WIDTH && cpkt.length >= 2) {\n\t\t\tunsigned short width;\n\n\t\t\tmemcpy(&width, cpkt.data, 2);\n\t\t\tcurconn->terminal_width = le16toh(width);\n\t\t\tgot_width_packet = 1;\n\n\t\t} else if (cpkt.cptype == MT_CPTYPE_TERM_HEIGHT && cpkt.length >= 2) {\n\t\t\tunsigned short height;\n\n\t\t\tmemcpy(&height, cpkt.data, 2);\n\t\t\tcurconn->terminal_height = le16toh(height);\n\t\t\tgot_height_packet = 1;\n\n\t\t} else if (cpkt.cptype == MT_CPTYPE_TERM_TYPE) {\n\n\t\t\tmemcpy(curconn->terminal_type, cpkt.data, act_size = (cpkt.length > 30 - 1 ? 30 - 1 : cpkt.length));\n\t\t\tcurconn->terminal_type[act_size] = 0;\n\n\t\t} else if (cpkt.cptype == MT_CPTYPE_PASSWORD && cpkt.length == 17) {\n\n#if defined(__linux__) && defined(_POSIX_MEMLOCK_RANGE)\n\t\t\tmlock(curconn->trypassword, 17);\n#endif\n\t\t\tmemcpy(curconn->trypassword, cpkt.data, 17);\n\t\t\tgot_pass_packet = 1;\n\n\t\t} else if (cpkt.cptype == MT_CPTYPE_PLAINDATA) {\n\n\t\t\t/* relay data from client to shell */\n\t\t\tif (curconn->state == STATE_ACTIVE && curconn->ptsfd != -1) {\n\t\t\t\twrite(curconn->ptsfd, cpkt.data, cpkt.length);\n\t\t\t}\n\n\t\t} else {\n\t\t\tsyslog(LOG_WARNING, _(\"(%d) Unhandeled control packet type: %d, length: %d\"), curconn->seskey, cpkt.cptype, cpkt.length);\n\t\t}\n\n\t\t/* Parse next control packet */\n\t\tsuccess = parse_control_packet(NULL, 0, &cpkt);\n\t}\n\n\tif (got_user_packet && got_pass_packet) {\n\t\tuser_login(curconn, pkthdr);\n\t}\n\n\tif (curconn->state == STATE_ACTIVE && (got_width_packet || got_height_packet)) {\n\t\tset_terminal_size(curconn->ptsfd, curconn->terminal_width, curconn->terminal_height);\n\n\t}\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos\\2016_8\\b69d11727d4f0f8cf719c79e3fb700f55ca03e9a_after\\MAC-Telnet-b69d11727d4f0f8cf719c79e3fb700f55ca03e9a\\mactelnetd.c", "callees": [], "callers": []}, {"name": "add_control_packet", "content": "int add_control_packet(struct mt_packet *packet, enum mt_cptype cptype, void *cpdata, unsigned short data_len) {\n\tunsigned char *data = packet->data + packet->size;\n\tunsigned int act_size = data_len + (cptype == MT_CPTYPE_PLAINDATA ? 0 : MT_CPHEADER_LEN);\n\n\t/* Something is really wrong. Packets should never become over 1500 bytes,\n       perform an Integer-Overflow safe check */\n\tif (act_size > MT_PACKET_LEN - packet->size) {\n\t\tfprintf(stderr, _(\"add_control_packet: ERROR, too large packet. Exceeds %d bytes\\n\"), MT_PACKET_LEN);\n\t\treturn -1;\n\t\t//exit(1);\n\t}\n\n\t/* PLAINDATA isn't really a controlpacket, but we handle it here, since\n\t   parseControlPacket also parses raw data as PLAINDATA */\n\tif (cptype == MT_CPTYPE_PLAINDATA) {\n\t\tmemcpy(data, cpdata, data_len);\n\t\tpacket->size += data_len;\n\t\treturn data_len;\n\t}\n\n\t/* Control Packet Magic id */\n\tmemcpy(data, mt_mactelnet_cpmagic, sizeof(mt_mactelnet_cpmagic));\n\n\t/* Control packet type */\n\tdata[4] = cptype;\n\n\t/* Data length */\n#if BYTE_ORDER == LITTLE_ENDIAN\n\t{\n\t\tunsigned int templen;\n\t\ttemplen = htonl(data_len);\n\t\tmemcpy(data + 5, &templen, sizeof(templen));\n\t}\n#else\n\tmemcpy(data + 5, &data_len, sizeof(data_len));\n#endif\n\n\t/* Insert data */\n\tif (data_len > 0) {\n\t\tmemcpy(data + MT_CPHEADER_LEN, cpdata, data_len);\n\t}\n\n\tpacket->size += act_size;\n\t/* Control packet header length + data length */\n\treturn act_size;\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos\\2016_8\\b69d11727d4f0f8cf719c79e3fb700f55ca03e9a_after\\MAC-Telnet-b69d11727d4f0f8cf719c79e3fb700f55ca03e9a\\protocol.c", "callees": ["fprintf", "htonl", "memcpy"], "callers": ["send_auth"]}, {"name": "add_packetdata", "content": "int add_packetdata(struct mt_packet *packet, unsigned char *data, unsigned short length) {\n\t/* Integer-Overflow safe check */\n\tif (length > MT_PACKET_LEN - packet->size) {\n\t\tfprintf(stderr, _(\"add_control_packet: ERROR, too large packet. Exceeds %d bytes\\n\"), MT_PACKET_LEN);\n\t\treturn -1;\n\t}\n\n\tmemcpy(packet->data + packet->size, data, length);\n\tpacket->size += length;\n\n\treturn length;\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos\\2016_8\\b69d11727d4f0f8cf719c79e3fb700f55ca03e9a_after\\MAC-Telnet-b69d11727d4f0f8cf719c79e3fb700f55ca03e9a\\protocol.c", "callees": ["fprintf", "memcpy"], "callers": []}, {"name": "mndp_add_attribute", "content": "int mndp_add_attribute(struct mt_packet *packet, enum mt_mndp_attrtype attrtype, void *attrdata, unsigned short data_len) {\n\tunsigned char *data = packet->data + packet->size;\n\tunsigned short type = attrtype;\n\tunsigned short len = data_len;\n\n\t/* Something is really wrong. Packets should never become over 1500 bytes */\n\tif (data_len > MT_PACKET_LEN - 4 - packet->size) {\n\t\tfprintf(stderr, _(\"mndp_add_attribute: ERROR, too large packet. Exceeds %d bytes\\n\"), MT_PACKET_LEN);\n\t\treturn -1;\n\t}\n\n\ttype = htons(type);\n\tmemcpy(data, &type, sizeof(type));\n\n\tlen = htons(len);\n\tmemcpy(data + 2, &len, sizeof(len));\n\n\tmemcpy(data + 4, attrdata, data_len);\n\n\tpacket->size += 4 + data_len;\n\n\treturn 4 + data_len;\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos\\2016_8\\b69d11727d4f0f8cf719c79e3fb700f55ca03e9a_after\\MAC-Telnet-b69d11727d4f0f8cf719c79e3fb700f55ca03e9a\\protocol.c", "callees": ["fprintf", "memcpy", "htons"], "callers": []}], "callerTree_before": {"send_auth": ["md5_append", "md5_finish", "strncpy", "send_udp", "init_packet", "htole16", "md5_init", "getenv", "strlen", "get_terminal_size", "add_control_packet", "memcpy", "mlock"], "handle_packet": ["sig_winch", "fwrite", "send_udp", "fprintf", "init_packet", "send_auth", "parse_control_packet", "parse_packet", "signal", "setvbuf", "ether_ntoa", "raw_term", "memcpy"], "add_control_packet": ["fprintf", "htonl", "memcpy"], "add_packetdata": ["fprintf", "memcpy"], "mndp_add_attribute": ["fprintf", "memcpy", "htons"]}, "calleeTree_before": {"getenv": ["send_auth"], "mlock": ["send_auth"], "strncpy": ["send_auth"], "memcpy": ["handle_packet", "send_auth", "mndp_add_attribute", "add_control_packet", "add_packetdata"], "strlen": ["send_auth"], "md5_init": ["send_auth"], "md5_append": ["send_auth"], "md5_finish": ["send_auth"], "init_packet": ["send_auth", "handle_packet"], "add_control_packet": ["send_auth"], "get_terminal_size": ["send_auth"], "htole16": ["send_auth"], "send_udp": ["send_auth", "handle_packet"], "parse_packet": ["handle_packet"], "parse_control_packet": ["handle_packet"], "send_auth": ["handle_packet"], "fwrite": ["handle_packet"], "raw_term": ["handle_packet"], "setvbuf": ["handle_packet"], "signal": ["handle_packet"], "sig_winch": ["handle_packet"], "fprintf": ["add_control_packet", "mndp_add_attribute", "add_packetdata", "handle_packet"], "ether_ntoa": ["handle_packet"], "htonl": ["add_control_packet"], "htons": ["mndp_add_attribute"]}, "callerTree_after": {"send_auth": ["md5_append", "md5_finish", "send_udp", "init_packet", "htole16", "md5_init", "getenv", "strlen", "get_terminal_size", "strnlen", "add_control_packet", "memcpy", "mlock"], "handle_packet": ["sig_winch", "fwrite", "send_udp", "fprintf", "init_packet", "send_auth", "parse_control_packet", "parse_packet", "signal", "setvbuf", "ether_ntoa", "raw_term", "memcpy"], "add_control_packet": ["fprintf", "htonl", "memcpy"], "add_packetdata": ["fprintf", "memcpy"], "mndp_add_attribute": ["fprintf", "memcpy", "htons"]}, "calleeTree_after": {"getenv": ["send_auth"], "mlock": ["send_auth"], "strnlen": ["send_auth"], "memcpy": ["handle_packet", "send_auth", "mndp_add_attribute", "add_control_packet", "add_packetdata"], "md5_init": ["send_auth"], "md5_append": ["send_auth"], "md5_finish": ["send_auth"], "init_packet": ["send_auth", "handle_packet"], "add_control_packet": ["send_auth"], "strlen": ["send_auth"], "get_terminal_size": ["send_auth"], "htole16": ["send_auth"], "send_udp": ["send_auth", "handle_packet"], "parse_packet": ["handle_packet"], "parse_control_packet": ["handle_packet"], "fprintf": ["add_control_packet", "mndp_add_attribute", "add_packetdata", "handle_packet"], "ether_ntoa": ["handle_packet"], "send_auth": ["handle_packet"], "fwrite": ["handle_packet"], "raw_term": ["handle_packet"], "setvbuf": ["handle_packet"], "signal": ["handle_packet"], "sig_winch": ["handle_packet"], "htonl": ["add_control_packet"], "htons": ["mndp_add_attribute"]}}
{"repo_after": "1ccfe21e14c4d18336f9da8515cd17db88c3de61", "repo_before": "3fe0a7128bac5000fdcfab888bd2a75ec0c9447d", "functions_before": [{"name": "gdImageCropThreshold", "content": "BGD_DECLARE(gdImagePtr) gdImageCropThreshold(gdImagePtr im, const unsigned int color, const float threshold)\n{\n\tconst int width = gdImageSX(im);\n\tconst int height = gdImageSY(im);\n\n\tint x,y;\n\tint match;\n\tgdRect crop;\n\n\tcrop.x = 0;\n\tcrop.y = 0;\n\tcrop.width = 0;\n\tcrop.height = 0;\n\n\t/* Pierre: crop everything sounds bad */\n\tif (threshold > 100.0) {\n\t\treturn NULL;\n\t}\n\n\t/* TODO: Add gdImageGetRowPtr and works with ptr at the row level\n\t * for the true color and palette images\n\t * new formats will simply work with ptr\n\t */\n\tmatch = 1;\n\tfor (y = 0; match && y < height; y++) {\n\t\tfor (x = 0; match && x < width; x++) {\n\t\t\tmatch = (gdColorMatch(im, color, gdImageGetPixel(im, x,y), threshold)) > 0;\n\t\t}\n\t}\n\n\t/* Pierre\n\t * Nothing to do > bye\n\t * Duplicate the image?\n\t */\n\tif (y == height - 1) {\n\t\treturn NULL;\n\t}\n\n\tcrop.y = y -1;\n\tmatch = 1;\n\tfor (y = height - 1; match && y >= 0; y--) {\n\t\tfor (x = 0; match && x < width; x++) {\n\t\t\tmatch = (gdColorMatch(im, color, gdImageGetPixel(im, x, y), threshold)) > 0;\n\t\t}\n\t}\n\n\tif (y == 0) {\n\t\tcrop.height = height - crop.y + 1;\n\t} else {\n\t\tcrop.height = y - crop.y + 2;\n\t}\n\n\tmatch = 1;\n\tfor (x = 0; match && x < width; x++) {\n\t\tfor (y = 0; match && y < crop.y + crop.height - 1; y++) {\n\t\t\tmatch = (gdColorMatch(im, color, gdImageGetPixel(im, x,y), threshold)) > 0;\n\t\t}\n\t}\n\tcrop.x = x - 1;\n\n\tmatch = 1;\n\tfor (x = width - 1; match && x >= 0; x--) {\n\t\tfor (y = 0; match &&  y < crop.y + crop.height - 1; y++) {\n\t\t\tmatch = (gdColorMatch(im, color, gdImageGetPixel(im, x,y), threshold)) > 0;\n\t\t}\n\t}\n\tcrop.width = x - crop.x + 2;\n\n\treturn gdImageCrop(im, &crop);\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos_before\\2016_8\\3fe0a7128bac5000fdcfab888bd2a75ec0c9447d_before\\libgd-3fe0a7128bac5000fdcfab888bd2a75ec0c9447d\\src\\gd_crop.c", "callees": [], "callers": []}], "functions_after": [{"name": "gdImageCropThreshold", "content": "BGD_DECLARE(gdImagePtr) gdImageCropThreshold(gdImagePtr im, const unsigned int color, const float threshold)\n{\n\tconst int width = gdImageSX(im);\n\tconst int height = gdImageSY(im);\n\n\tint x,y;\n\tint match;\n\tgdRect crop;\n\n\tcrop.x = 0;\n\tcrop.y = 0;\n\tcrop.width = 0;\n\tcrop.height = 0;\n\n\t/* Pierre: crop everything sounds bad */\n\tif (threshold > 100.0) {\n\t\treturn NULL;\n\t}\n\n\tif (color < 0 || (!gdImageTrueColor(im) && color >= gdImageColorsTotal(im))) {\n\t\treturn NULL;\n\t}\n\n\t/* TODO: Add gdImageGetRowPtr and works with ptr at the row level\n\t * for the true color and palette images\n\t * new formats will simply work with ptr\n\t */\n\tmatch = 1;\n\tfor (y = 0; match && y < height; y++) {\n\t\tfor (x = 0; match && x < width; x++) {\n\t\t\tmatch = (gdColorMatch(im, color, gdImageGetPixel(im, x,y), threshold)) > 0;\n\t\t}\n\t}\n\n\t/* Pierre\n\t * Nothing to do > bye\n\t * Duplicate the image?\n\t */\n\tif (y == height - 1) {\n\t\treturn NULL;\n\t}\n\n\tcrop.y = y -1;\n\tmatch = 1;\n\tfor (y = height - 1; match && y >= 0; y--) {\n\t\tfor (x = 0; match && x < width; x++) {\n\t\t\tmatch = (gdColorMatch(im, color, gdImageGetPixel(im, x, y), threshold)) > 0;\n\t\t}\n\t}\n\n\tif (y == 0) {\n\t\tcrop.height = height - crop.y + 1;\n\t} else {\n\t\tcrop.height = y - crop.y + 2;\n\t}\n\n\tmatch = 1;\n\tfor (x = 0; match && x < width; x++) {\n\t\tfor (y = 0; match && y < crop.y + crop.height - 1; y++) {\n\t\t\tmatch = (gdColorMatch(im, color, gdImageGetPixel(im, x,y), threshold)) > 0;\n\t\t}\n\t}\n\tcrop.x = x - 1;\n\n\tmatch = 1;\n\tfor (x = width - 1; match && x >= 0; x--) {\n\t\tfor (y = 0; match &&  y < crop.y + crop.height - 1; y++) {\n\t\t\tmatch = (gdColorMatch(im, color, gdImageGetPixel(im, x,y), threshold)) > 0;\n\t\t}\n\t}\n\tcrop.width = x - crop.x + 2;\n\n\treturn gdImageCrop(im, &crop);\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos\\2016_8\\1ccfe21e14c4d18336f9da8515cd17db88c3de61_after\\libgd-1ccfe21e14c4d18336f9da8515cd17db88c3de61\\src\\gd_crop.c", "callees": [], "callers": []}], "callerTree_before": {"gdGuessBackgroundColorFromCorners": ["gdImageGetPixel", "gdImageBlue", "gdImageSY", "gdImageGreen", "gdImageRed", "gdImageAlpha", "gdImageColorClosestAlpha", "gdImageSX"]}, "calleeTree_before": {"gdImageGetPixel": ["gdGuessBackgroundColorFromCorners"], "gdImageSX": ["gdGuessBackgroundColorFromCorners"], "gdImageSY": ["gdGuessBackgroundColorFromCorners"], "gdImageRed": ["gdGuessBackgroundColorFromCorners"], "gdImageGreen": ["gdGuessBackgroundColorFromCorners"], "gdImageBlue": ["gdGuessBackgroundColorFromCorners"], "gdImageAlpha": ["gdGuessBackgroundColorFromCorners"], "gdImageColorClosestAlpha": ["gdGuessBackgroundColorFromCorners"]}, "callerTree_after": {"gdGuessBackgroundColorFromCorners": ["gdImageGetPixel", "gdImageBlue", "gdImageSY", "gdImageGreen", "gdImageRed", "gdImageAlpha", "gdImageColorClosestAlpha", "gdImageSX"]}, "calleeTree_after": {"gdImageGetPixel": ["gdGuessBackgroundColorFromCorners"], "gdImageSX": ["gdGuessBackgroundColorFromCorners"], "gdImageSY": ["gdGuessBackgroundColorFromCorners"], "gdImageRed": ["gdGuessBackgroundColorFromCorners"], "gdImageGreen": ["gdGuessBackgroundColorFromCorners"], "gdImageBlue": ["gdGuessBackgroundColorFromCorners"], "gdImageAlpha": ["gdGuessBackgroundColorFromCorners"], "gdImageColorClosestAlpha": ["gdGuessBackgroundColorFromCorners"]}}
{"repo_after": "fcd135c9df440bcd2d5870405ad3311743d78d97", "repo_before": "324583e8fb3935690be58790425793df619c6d4d", "functions_before": [{"name": "auth_password", "content": "int\nauth_password(Authctxt *authctxt, const char *password)\n{\n\tstruct passwd * pw = authctxt->pw;\n\tint result, ok = authctxt->valid;\n#if defined(USE_SHADOW) && defined(HAS_SHADOW_EXPIRE)\n\tstatic int expire_checked = 0;\n#endif\n\n#ifndef HAVE_CYGWIN\n\tif (pw->pw_uid == 0 && options.permit_root_login != PERMIT_YES)\n\t\tok = 0;\n#endif\n\tif (*password == '\\0' && options.permit_empty_passwd == 0)\n\t\treturn 0;\n\n#ifdef KRB5\n\tif (options.kerberos_authentication == 1) {\n\t\tint ret = auth_krb5_password(authctxt, password);\n\t\tif (ret == 1 || ret == 0)\n\t\t\treturn ret && ok;\n\t\t/* Fall back to ordinary passwd authentication. */\n\t}\n#endif\n#ifdef HAVE_CYGWIN\n\t{\n\t\tHANDLE hToken = cygwin_logon_user(pw, password);\n\n\t\tif (hToken == INVALID_HANDLE_VALUE)\n\t\t\treturn 0;\n\t\tcygwin_set_impersonation_token(hToken);\n\t\treturn ok;\n\t}\n#endif\n#ifdef USE_PAM\n\tif (options.use_pam)\n\t\treturn (sshpam_auth_passwd(authctxt, password) && ok);\n#endif\n#if defined(USE_SHADOW) && defined(HAS_SHADOW_EXPIRE)\n\tif (!expire_checked) {\n\t\texpire_checked = 1;\n\t\tif (auth_shadow_pwexpired(authctxt))\n\t\t\tauthctxt->force_pwchange = 1;\n\t}\n#endif\n\tresult = sys_auth_passwd(authctxt, password);\n\tif (authctxt->force_pwchange)\n\t\tdisable_forwarding();\n\treturn (result && ok);\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos_before\\2016_8\\324583e8fb3935690be58790425793df619c6d4d_before\\openssh-portable-324583e8fb3935690be58790425793df619c6d4d\\auth-passwd.c", "callees": ["cygwin_logon_user", "auth_krb5_password", "disable_forwarding", "sshpam_auth_passwd", "auth_shadow_pwexpired", "cygwin_set_impersonation_token", "sys_auth_passwd"], "callers": []}], "functions_after": [{"name": "auth_password", "content": "int\nauth_password(Authctxt *authctxt, const char *password)\n{\n\tstruct passwd * pw = authctxt->pw;\n\tint result, ok = authctxt->valid;\n#if defined(USE_SHADOW) && defined(HAS_SHADOW_EXPIRE)\n\tstatic int expire_checked = 0;\n#endif\n\n\tif (strlen(password) > MAX_PASSWORD_LEN)\n\t\treturn 0;\n\n#ifndef HAVE_CYGWIN\n\tif (pw->pw_uid == 0 && options.permit_root_login != PERMIT_YES)\n\t\tok = 0;\n#endif\n\tif (*password == '\\0' && options.permit_empty_passwd == 0)\n\t\treturn 0;\n\n#ifdef KRB5\n\tif (options.kerberos_authentication == 1) {\n\t\tint ret = auth_krb5_password(authctxt, password);\n\t\tif (ret == 1 || ret == 0)\n\t\t\treturn ret && ok;\n\t\t/* Fall back to ordinary passwd authentication. */\n\t}\n#endif\n#ifdef HAVE_CYGWIN\n\t{\n\t\tHANDLE hToken = cygwin_logon_user(pw, password);\n\n\t\tif (hToken == INVALID_HANDLE_VALUE)\n\t\t\treturn 0;\n\t\tcygwin_set_impersonation_token(hToken);\n\t\treturn ok;\n\t}\n#endif\n#ifdef USE_PAM\n\tif (options.use_pam)\n\t\treturn (sshpam_auth_passwd(authctxt, password) && ok);\n#endif\n#if defined(USE_SHADOW) && defined(HAS_SHADOW_EXPIRE)\n\tif (!expire_checked) {\n\t\texpire_checked = 1;\n\t\tif (auth_shadow_pwexpired(authctxt))\n\t\t\tauthctxt->force_pwchange = 1;\n\t}\n#endif\n\tresult = sys_auth_passwd(authctxt, password);\n\tif (authctxt->force_pwchange)\n\t\tdisable_forwarding();\n\treturn (result && ok);\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos\\2016_8\\fcd135c9df440bcd2d5870405ad3311743d78d97_after\\openssh-portable-fcd135c9df440bcd2d5870405ad3311743d78d97\\auth-passwd.c", "callees": ["cygwin_logon_user", "auth_krb5_password", "disable_forwarding", "sshpam_auth_passwd", "auth_shadow_pwexpired", "cygwin_set_impersonation_token", "sys_auth_passwd", "strlen"], "callers": []}], "callerTree_before": {"auth_password": ["cygwin_logon_user", "auth_krb5_password", "disable_forwarding", "sshpam_auth_passwd", "auth_shadow_pwexpired", "cygwin_set_impersonation_token", "sys_auth_passwd"]}, "calleeTree_before": {"auth_krb5_password": ["auth_password"], "cygwin_logon_user": ["auth_password"], "cygwin_set_impersonation_token": ["auth_password"], "sshpam_auth_passwd": ["auth_password"], "auth_shadow_pwexpired": ["auth_password"], "sys_auth_passwd": ["auth_password"], "disable_forwarding": ["auth_password"]}, "callerTree_after": {"auth_password": ["cygwin_logon_user", "auth_krb5_password", "disable_forwarding", "sshpam_auth_passwd", "auth_shadow_pwexpired", "cygwin_set_impersonation_token", "sys_auth_passwd", "strlen"]}, "calleeTree_after": {"strlen": ["auth_password"], "auth_krb5_password": ["auth_password"], "cygwin_logon_user": ["auth_password"], "cygwin_set_impersonation_token": ["auth_password"], "sshpam_auth_passwd": ["auth_password"], "auth_shadow_pwexpired": ["auth_password"], "sys_auth_passwd": ["auth_password"], "disable_forwarding": ["auth_password"]}}
{"repo_after": "4dc1a2d7931017d3625f2d7cff70a17ce58b53b4", "repo_before": "b083ec17ad9cba4ad9fe7fac1c6a168d90dd1a31", "functions_before": [{"name": "gdCtxPrintf", "content": "static void gdCtxPrintf(gdIOCtx * out, const char *format, ...)\n{\n\tchar buf[4096];\n\tint len;\n\tva_list args;\n\n\tva_start(args, format);\n\tlen = vsnprintf(buf, sizeof(buf)-1, format, args);\n\tva_end(args);\n\tout->putBuf(out, buf, len);\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos_before\\2016_8\\b083ec17ad9cba4ad9fe7fac1c6a168d90dd1a31_before\\libgd-b083ec17ad9cba4ad9fe7fac1c6a168d90dd1a31\\src\\gd_xbm.c", "callees": ["va_end", "vsnprintf", "va_start"], "callers": []}, {"name": "gdImageXbmCtx", "content": "BGD_DECLARE(void) gdImageXbmCtx(gdImagePtr image, char* file_name, int fg, gdIOCtx * out)\n{\n\tint x, y, c, b, sx, sy, p;\n\tchar *name, *f;\n\tsize_t i, l;\n\n\tname = file_name;\n\tif ((f = strrchr(name, '/')) != NULL) name = f+1;\n\tif ((f = strrchr(name, '\\\\')) != NULL) name = f+1;\n\tname = strdup(name);\n\tif ((f = strrchr(name, '.')) != NULL && !strcasecmp(f, \".XBM\")) *f = '\\0';\n\tif ((l = strlen(name)) == 0) {\n\t\tfree(name);\n\t\tname = strdup(\"image\");\n\t} else {\n\t\tfor (i=0; i<l; i++) {\n\t\t\t/* only in C-locale isalnum() would work */\n\t\t\tif (!isupper(name[i]) && !islower(name[i]) && !isdigit(name[i])) {\n\t\t\t\tname[i] = '_';\n\t\t\t}\n\t\t}\n\t}\n\n\tgdCtxPrintf(out, \"#define %s_width %d\\n\", name, gdImageSX(image));\n\tgdCtxPrintf(out, \"#define %s_height %d\\n\", name, gdImageSY(image));\n\tgdCtxPrintf(out, \"static unsigned char %s_bits[] = {\\n  \", name);\n\n\tfree(name);\n\n\tb = 1;\n\tp = 0;\n\tc = 0;\n\tsx = gdImageSX(image);\n\tsy = gdImageSY(image);\n\tfor (y = 0; y < sy; y++) {\n\t\tfor (x = 0; x < sx; x++) {\n\t\t\tif (gdImageGetPixel(image, x, y) == fg) {\n\t\t\t\tc |= b;\n\t\t\t}\n\t\t\tif ((b == 128) || (x == sx && y == sy)) {\n\t\t\t\tb = 1;\n\t\t\t\tif (p) {\n\t\t\t\t\tgdCtxPrintf(out, \", \");\n\t\t\t\t\tif (!(p%12)) {\n\t\t\t\t\t\tgdCtxPrintf(out, \"\\n  \");\n\t\t\t\t\t\tp = 12;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tp++;\n\t\t\t\tgdCtxPrintf(out, \"0x%02X\", c);\n\t\t\t\tc = 0;\n\t\t\t} else {\n\t\t\t\tb <<= 1;\n\t\t\t}\n\t\t}\n\t}\n\tgdCtxPrintf(out, \"};\\n\");\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos_before\\2016_8\\b083ec17ad9cba4ad9fe7fac1c6a168d90dd1a31_before\\libgd-b083ec17ad9cba4ad9fe7fac1c6a168d90dd1a31\\src\\gd_xbm.c", "callees": [], "callers": []}], "functions_after": [{"name": "gdCtxPrintf", "content": "static void gdCtxPrintf(gdIOCtx * out, const char *format, ...)\n{\n\tchar buf[1024];\n\tint len;\n\tva_list args;\n\n\tva_start(args, format);\n\tlen = vsnprintf(buf, sizeof(buf)-1, format, args);\n\tva_end(args);\n\tout->putBuf(out, buf, len);\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos\\2016_8\\4dc1a2d7931017d3625f2d7cff70a17ce58b53b4_after\\libgd-4dc1a2d7931017d3625f2d7cff70a17ce58b53b4\\src\\gd_xbm.c", "callees": ["va_end", "vsnprintf", "va_start"], "callers": []}, {"name": "gdImageXbmCtx", "content": "BGD_DECLARE(void) gdImageXbmCtx(gdImagePtr image, char* file_name, int fg, gdIOCtx * out)\n{\n\tint x, y, c, b, sx, sy, p;\n\tchar *name, *f;\n\tsize_t i, l;\n\n\tname = file_name;\n\tif ((f = strrchr(name, '/')) != NULL) name = f+1;\n\tif ((f = strrchr(name, '\\\\')) != NULL) name = f+1;\n\tname = strdup(name);\n\tif ((f = strrchr(name, '.')) != NULL && !strcasecmp(f, \".XBM\")) *f = '\\0';\n\tif ((l = strlen(name)) == 0) {\n\t\tfree(name);\n\t\tname = strdup(\"image\");\n\t} else {\n\t\tfor (i=0; i<l; i++) {\n\t\t\t/* only in C-locale isalnum() would work */\n\t\t\tif (!isupper(name[i]) && !islower(name[i]) && !isdigit(name[i])) {\n\t\t\t\tname[i] = '_';\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Since \"name\" comes from the user, run it through a direct puts.\n\t * Trying to printf it into a local buffer means we'd need a large\n\t * or dynamic buffer to hold it all. */\n\n\t/* #define <name>_width 1234 */\n\tgdCtxPuts(out, \"#define \");\n\tgdCtxPuts(out, name);\n\tgdCtxPuts(out, \"_width \");\n\tgdCtxPrintf(out, \"%d\\n\", gdImageSX(image));\n\n\t/* #define <name>_height 1234 */\n\tgdCtxPuts(out, \"#define \");\n\tgdCtxPuts(out, name);\n\tgdCtxPuts(out, \"_height \");\n\tgdCtxPrintf(out, \"%d\\n\", gdImageSY(image));\n\n\t/* static unsigned char <name>_bits[] = {\\n */\n\tgdCtxPuts(out, \"static unsigned char \");\n\tgdCtxPuts(out, name);\n\tgdCtxPuts(out, \"_bits[] = {\\n  \");\n\n\tfree(name);\n\n\tb = 1;\n\tp = 0;\n\tc = 0;\n\tsx = gdImageSX(image);\n\tsy = gdImageSY(image);\n\tfor (y = 0; y < sy; y++) {\n\t\tfor (x = 0; x < sx; x++) {\n\t\t\tif (gdImageGetPixel(image, x, y) == fg) {\n\t\t\t\tc |= b;\n\t\t\t}\n\t\t\tif ((b == 128) || (x == sx && y == sy)) {\n\t\t\t\tb = 1;\n\t\t\t\tif (p) {\n\t\t\t\t\tgdCtxPuts(out, \", \");\n\t\t\t\t\tif (!(p%12)) {\n\t\t\t\t\t\tgdCtxPuts(out, \"\\n  \");\n\t\t\t\t\t\tp = 12;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tp++;\n\t\t\t\tgdCtxPrintf(out, \"0x%02X\", c);\n\t\t\t\tc = 0;\n\t\t\t} else {\n\t\t\t\tb <<= 1;\n\t\t\t}\n\t\t}\n\t}\n\tgdCtxPuts(out, \"};\\n\");\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos\\2016_8\\4dc1a2d7931017d3625f2d7cff70a17ce58b53b4_after\\libgd-4dc1a2d7931017d3625f2d7cff70a17ce58b53b4\\src\\gd_xbm.c", "callees": [], "callers": []}], "callerTree_before": {"gdCtxPrintf": ["va_end", "vsnprintf", "va_start"]}, "calleeTree_before": {"va_start": ["gdCtxPrintf"], "vsnprintf": ["gdCtxPrintf"], "va_end": ["gdCtxPrintf"]}, "callerTree_after": {"gdCtxPrintf": ["va_end", "vsnprintf", "va_start"]}, "calleeTree_after": {"va_start": ["gdCtxPrintf"], "vsnprintf": ["gdCtxPrintf"], "va_end": ["gdCtxPrintf"]}}
{"repo_after": "b69d11727d4f0f8cf719c79e3fb700f55ca03e9a", "repo_before": "b9cede3c19693b7663219691d8604e037cea673a", "functions_before": [{"name": "send_auth", "content": "static void send_auth(char *username, char *password) {\n\tstruct mt_packet data;\n\tunsigned short width = 0;\n\tunsigned short height = 0;\n\tchar *terminal = getenv(\"TERM\");\n\tchar md5data[100];\n\tunsigned char md5sum[17];\n\tint plen;\n\tmd5_state_t state;\n\n#if defined(__linux__) && defined(_POSIX_MEMLOCK_RANGE)\n\tmlock(md5data, sizeof(md5data));\n\tmlock(md5sum, sizeof(md5data));\n#endif\n\n\t/* Concat string of 0 + password + pass_salt */\n\tmd5data[0] = 0;\n\tstrncpy(md5data + 1, password, 82);\n\tmd5data[83] = '\\0';\n\tmemcpy(md5data + 1 + strlen(password), pass_salt, 16);\n\n\t/* Generate md5 sum of md5data with a leading 0 */\n\tmd5_init(&state);\n\tmd5_append(&state, (const md5_byte_t *)md5data, strlen(password) + 17);\n\tmd5_finish(&state, (md5_byte_t *)md5sum + 1);\n\tmd5sum[0] = 0;\n\n\t/* Send combined packet to server */\n\tinit_packet(&data, MT_PTYPE_DATA, srcmac, dstmac, sessionkey, outcounter);\n\tplen = add_control_packet(&data, MT_CPTYPE_PASSWORD, md5sum, 17);\n\tplen += add_control_packet(&data, MT_CPTYPE_USERNAME, username, strlen(username));\n\tplen += add_control_packet(&data, MT_CPTYPE_TERM_TYPE, terminal, strlen(terminal));\n\t\n\tif (is_a_tty && get_terminal_size(&width, &height) != -1) {\n\t\twidth = htole16(width);\n\t\theight = htole16(height);\n\t\tplen += add_control_packet(&data, MT_CPTYPE_TERM_WIDTH, &width, 2);\n\t\tplen += add_control_packet(&data, MT_CPTYPE_TERM_HEIGHT, &height, 2);\n\t}\n\n\toutcounter += plen;\n\n\t/* TODO: handle result */\n\tsend_udp(&data, 1);\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos_before\\2016_8\\b9cede3c19693b7663219691d8604e037cea673a_before\\MAC-Telnet-b9cede3c19693b7663219691d8604e037cea673a\\mactelnet.c", "callees": ["md5_append", "md5_finish", "strncpy", "send_udp", "init_packet", "htole16", "md5_init", "getenv", "strlen", "get_terminal_size", "add_control_packet", "memcpy", "mlock"], "callers": ["handle_packet"]}, {"name": "handle_packet", "content": "static int handle_packet(unsigned char *data, int data_len) {\n\tstruct mt_mactelnet_hdr pkthdr;\n\n\t/* Minimal size checks (pings are not supported here) */\n\tif (data_len < MT_HEADER_LEN){\n\t\treturn -1;\n\t}\n\tparse_packet(data, &pkthdr);\n\n\t/* We only care about packets with correct sessionkey */\n\tif (pkthdr.seskey != sessionkey) {\n\t\treturn -1;\n\t}\n\n\t/* Handle data packets */\n\tif (pkthdr.ptype == MT_PTYPE_DATA) {\n\t\tstruct mt_packet odata;\n\t\tstruct mt_mactelnet_control_hdr cpkt;\n\t\tint success = 0;\n\n\t\t/* Always transmit ACKNOWLEDGE packets in response to DATA packets */\n\t\tinit_packet(&odata, MT_PTYPE_ACK, srcmac, dstmac, sessionkey, pkthdr.counter + (data_len - MT_HEADER_LEN));\n\t\tsend_udp(&odata, 0);\n\n\t\t/* Accept first packet, and all packets greater than incounter, and if counter has\n\t\twrapped around. */\n\t\tif (pkthdr.counter > incounter || (incounter - pkthdr.counter) > 65535) {\n\t\t\tincounter = pkthdr.counter;\n\t\t} else {\n\t\t\t/* Ignore double or old packets */\n\t\t\treturn -1;\n\t\t}\n\n\t\t/* Parse controlpacket data */\n\t\tsuccess = parse_control_packet(data + MT_HEADER_LEN, data_len - MT_HEADER_LEN, &cpkt);\n\n\t\twhile (success) {\n\n\t\t\t/* If we receive pass_salt, transmit auth data back */\n\t\t\tif (cpkt.cptype == MT_CPTYPE_PASSSALT) {\n\t\t\t\tmemcpy(pass_salt, cpkt.data, cpkt.length);\n\t\t\t\tsend_auth(username, password);\n\t\t\t}\n\n\t\t\t/* If the (remaining) data did not have a control-packet magic byte sequence,\n\t\t\t   the data is raw terminal data to be outputted to the terminal. */\n\t\t\telse if (cpkt.cptype == MT_CPTYPE_PLAINDATA) {\n\t\t\t\tfwrite((const void *)cpkt.data, 1, cpkt.length, stdout);\n\t\t\t}\n\n\t\t\t/* END_AUTH means that the user/password negotiation is done, and after this point\n\t\t\t   terminal data may arrive, so we set up the terminal to raw mode. */\n\t\t\telse if (cpkt.cptype == MT_CPTYPE_END_AUTH) {\n\n\t\t\t\t/* we have entered \"terminal mode\" */\n\t\t\t\tterminal_mode = 1;\n\n\t\t\t\tif (is_a_tty) {\n\t\t\t\t\t/* stop input buffering at all levels. Give full control of terminal to RouterOS */\n\t\t\t\t\traw_term();\n\n\t\t\t\t\tsetvbuf(stdin,  (char*)NULL, _IONBF, 0);\n\n\t\t\t\t\t/* Add resize signal handler */\n\t\t\t\t\tsignal(SIGWINCH, sig_winch);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* Parse next controlpacket */\n\t\t\tsuccess = parse_control_packet(NULL, 0, &cpkt);\n\t\t}\n\t}\n\telse if (pkthdr.ptype == MT_PTYPE_ACK) {\n\t\t/* Handled elsewhere */\n\t}\n\n\t/* The server wants to terminate the connection, we have to oblige */\n\telse if (pkthdr.ptype == MT_PTYPE_END) {\n\t\tstruct mt_packet odata;\n\n\t\t/* Acknowledge the disconnection by sending a END packet in return */\n\t\tinit_packet(&odata, MT_PTYPE_END, srcmac, dstmac, pkthdr.seskey, 0);\n\t\tsend_udp(&odata, 0);\n\n\t\tif (!quiet_mode) {\n\t\t\tfprintf(stderr, _(\"Connection closed.\\n\"));\n\t\t}\n\n\t\t/* exit */\n\t\trunning = 0;\n\t} else {\n\t\tfprintf(stderr, _(\"Unhandeled packet type: %d received from server %s\\n\"), pkthdr.ptype, ether_ntoa((struct ether_addr *)dstmac));\n\t\treturn -1;\n\t}\n\n\treturn pkthdr.ptype;\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos_before\\2016_8\\b9cede3c19693b7663219691d8604e037cea673a_before\\MAC-Telnet-b9cede3c19693b7663219691d8604e037cea673a\\mactelnet.c", "callees": ["sig_winch", "fwrite", "send_udp", "fprintf", "init_packet", "send_auth", "parse_control_packet", "parse_packet", "signal", "setvbuf", "ether_ntoa", "raw_term", "memcpy"], "callers": []}, {"name": "user_login", "content": "static void user_login(struct mt_connection *curconn, struct mt_mactelnet_hdr *pkthdr) {\n\tstruct mt_packet pdata;\n\tunsigned char md5sum[17];\n\tchar md5data[100];\n\tstruct mt_credentials *user;\n\tchar *slavename;\n\n\t/* Reparse user file before each login */\n\tread_userfile();\n\n\tif ((user = find_user(curconn->username)) != NULL) {\n\t\tmd5_state_t state;\n#if defined(__linux__) && defined(_POSIX_MEMLOCK_RANGE)\n\t\tmlock(md5data, sizeof(md5data));\n\t\tmlock(md5sum, sizeof(md5sum));\n\t\tif (user->password != NULL) {\n\t\t\tmlock(user->password, strlen(user->password));\n\t\t}\n#endif\n\n\t\t/* Concat string of 0 + password + pass_salt */\n\t\tmd5data[0] = 0;\n\t\tstrncpy(md5data + 1, user->password, 82);\n\t\tmemcpy(md5data + 1 + strlen(user->password), curconn->pass_salt, 16);\n\n\t\t/* Generate md5 sum of md5data with a leading 0 */\n\t\tmd5_init(&state);\n\t\tmd5_append(&state, (const md5_byte_t *)md5data, strlen(user->password) + 17);\n\t\tmd5_finish(&state, (md5_byte_t *)md5sum + 1);\n\t\tmd5sum[0] = 0;\n\n\t\tinit_packet(&pdata, MT_PTYPE_DATA, pkthdr->dstaddr, pkthdr->srcaddr, pkthdr->seskey, curconn->outcounter);\n\t\tcurconn->outcounter += add_control_packet(&pdata, MT_CPTYPE_END_AUTH, NULL, 0);\n\t\tsend_udp(curconn, &pdata);\n\n\t\tif (curconn->state == STATE_ACTIVE) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (user == NULL || memcmp(md5sum, curconn->trypassword, 17) != 0) {\n\t\tsyslog(LOG_NOTICE, _(\"(%d) Invalid login by %s.\"), curconn->seskey, curconn->username);\n\n\t\t/*_ Please include both \\r and \\n in translation, this is needed for the terminal emulator. */\n\t\tabort_connection(curconn, pkthdr, _(\"Login failed, incorrect username or password\\r\\n\"));\n\n\t\t/* TODO: should wait some time (not with sleep) before returning, to minimalize brute force attacks */\n\t\treturn;\n\t}\n\n\t/* User is logged in */\n\tcurconn->state = STATE_ACTIVE;\n\n\t/* Enter terminal mode */\n\tcurconn->terminal_mode = 1;\n\n\t/* Open pts handle */\n\tcurconn->ptsfd = posix_openpt(O_RDWR);\n\tif (curconn->ptsfd == -1 || grantpt(curconn->ptsfd) == -1 || unlockpt(curconn->ptsfd) == -1) {\n\t\t\tsyslog(LOG_ERR, \"posix_openpt: %s\", strerror(errno));\n\t\t\t/*_ Please include both \\r and \\n in translation, this is needed for the terminal emulator. */\n\t\t\tabort_connection(curconn, pkthdr, _(\"Terminal error\\r\\n\"));\n\t\t\treturn;\n\t}\n\n\t/* Get file path for our pts */\n\tslavename = ptsname(curconn->ptsfd);\n\tif (slavename != NULL) {\n\t\tpid_t pid;\n\t\tstruct stat sb;\n\t\tstruct passwd *user = (struct passwd *)malloc(sizeof(struct passwd));\n\t\tstruct passwd *tmpuser=user;\n\t\tchar *buffer = malloc(1024);\n\n\t\tif (user == NULL || buffer == NULL) {\n\t\t\tsyslog(LOG_CRIT, _(\"(%d) Error allocating memory.\"), curconn->seskey);\n\t\t\t/*_ Please include both \\r and \\n in translation, this is needed for the terminal emulator. */\n\t\t\tabort_connection(curconn, pkthdr, _(\"System error, out of memory\\r\\n\"));\n\t\t\treturn;\n\t\t}\n\n\t\tif (getpwnam_r(curconn->username, user, buffer, 1024, &tmpuser) != 0) {\n\t\t\tsyslog(LOG_WARNING, _(\"(%d) Login ok, but local user not accessible (%s).\"), curconn->seskey, curconn->username);\n\t\t\t/*_ Please include both \\r and \\n in translation, this is needed for the terminal emulator. */\n\t\t\tabort_connection(curconn, pkthdr, _(\"Local user not accessible\\r\\n\"));\n\t\t\tfree(user);\n\t\t\tfree(buffer);\n\t\t\treturn;\n\t\t}\n\n\t\t/* Change the owner of the slave pts */\n\t\tchown(slavename, user->pw_uid, user->pw_gid);\n\n\t\tcurconn->slavefd = open(slavename, O_RDWR);\n\t\tif (curconn->slavefd == -1) {\n\t\t\tsyslog(LOG_ERR, _(\"Error opening %s: %s\"), slavename, strerror(errno));\n\t\t\t/*_ Please include both \\r and \\n in translation, this is needed for the terminal emulator. */\n\t\t\tabort_connection(curconn, pkthdr, _(\"Error opening terminal\\r\\n\"));\n\t\t\tlist_remove_connection(curconn);\n\t\t\treturn;\n\t\t}\n\n\t\tif ((pid = fork()) == 0) {\n\t\t\tstruct net_interface *interface;\n\n\t\t\t/* Add login information to utmp/wtmp */\n\t\t\tuwtmp_login(curconn);\n\n\t\t\tsyslog(LOG_INFO, _(\"(%d) User %s logged in.\"), curconn->seskey, curconn->username);\n\n\t\t\t/* Initialize terminal environment */\n\t\t\tsetenv(\"USER\", user->pw_name, 1);\n\t\t\tsetenv(\"HOME\", user->pw_dir, 1);\n\t\t\tsetenv(\"SHELL\", user->pw_shell, 1);\n\t\t\tsetenv(\"TERM\", curconn->terminal_type, 1);\n\t\t\tclose(sockfd);\n\t\t\tclose(insockfd);\n\n\t\t\tDL_FOREACH(interfaces, interface) {\n\t\t\t\tif (interface->socketfd > 0) {\n\t\t\t\t\tclose(interface->socketfd);\n\t\t\t\t}\n\t\t\t}\n\t\t\tsetsid();\n\n\t\t\t/* Don't let shell process inherit slavefd */\n\t\t\tfcntl (curconn->slavefd, F_SETFD, FD_CLOEXEC);\n\t\t\tclose(curconn->ptsfd);\n\n\t\t\t/* Redirect STDIN/STDIO/STDERR */\n\t\t\tclose(0);\n\t\t\tdup(curconn->slavefd);\n\t\t\tclose(1);\n\t\t\tdup(curconn->slavefd);\n\t\t\tclose(2);\n\t\t\tdup(curconn->slavefd);\n\n\t\t\t/* Set controlling terminal */\n\t\t\tioctl(0, TIOCSCTTY, 1);\n\t\t\ttcsetpgrp(0, getpid());\n\n\t\t\t/* Set user id/group id */\n\t\t\tif ((setgid(user->pw_gid) != 0) || (setuid(user->pw_uid) != 0)) {\n\t\t\t\tsyslog(LOG_ERR, _(\"(%d) Could not log in %s (%d:%d): setuid/setgid: %s\"), curconn->seskey, curconn->username, user->pw_uid, user->pw_gid, strerror(errno));\n\t\t\t\t/*_ Please include both \\r and \\n in translation, this is needed for the terminal emulator. */\n\t\t\t\tabort_connection(curconn, pkthdr, _(\"Internal error\\r\\n\"));\n\t\t\t\texit(0);\n\t\t\t}\n\n\t\t\t/* Abort login if /etc/nologin exists */\n\t\t\tif (stat(_PATH_NOLOGIN, &sb) == 0 && getuid() != 0) {\n\t\t\t\tsyslog(LOG_NOTICE, _(\"(%d) User %s disconnected with \" _PATH_NOLOGIN \" message.\"), curconn->seskey, curconn->username);\n\t\t\t\tdisplay_nologin();\n\t\t\t\tcurconn->state = STATE_CLOSED;\n\t\t\t\tinit_packet(&pdata, MT_PTYPE_END, pkthdr->dstaddr, pkthdr->srcaddr, pkthdr->seskey, curconn->outcounter);\n\t\t\t\tsend_udp(curconn, &pdata);\n\t\t\t\texit(0);\n\t\t\t}\n\n\t\t\t/* Display MOTD */\n\t\t\tdisplay_motd();\n\n\t\t\tchdir(user->pw_dir);\n\n\t\t\t/* Spawn shell */\n\t\t\t/* TODO: Maybe use \"login -f USER\" instead? renders motd and executes shell correctly for system */\n\t\t\texecl(user->pw_shell, user->pw_shell, \"-\", (char *) 0);\n\t\t\texit(0); // just to be sure.\n\t\t}\n\t\tfree(user);\n\t\tfree(buffer);\n\t\tclose(curconn->slavefd);\n\t\tcurconn->pid = pid;\n\t\tset_terminal_size(curconn->ptsfd, curconn->terminal_width, curconn->terminal_height);\n\t}\n\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos_before\\2016_8\\b9cede3c19693b7663219691d8604e037cea673a_before\\MAC-Telnet-b9cede3c19693b7663219691d8604e037cea673a\\mactelnetd.c", "callees": [], "callers": []}, {"name": "handle_data_packet", "content": "static void handle_data_packet(struct mt_connection *curconn, struct mt_mactelnet_hdr *pkthdr, int data_len) {\n\tstruct mt_mactelnet_control_hdr cpkt;\n\tstruct mt_packet pdata;\n\tunsigned char *data = pkthdr->data;\n\tunsigned int act_size = 0;\n\tint got_user_packet = 0;\n\tint got_pass_packet = 0;\n\tint got_width_packet = 0;\n\tint got_height_packet = 0;\n\tint success;\n\n\t/* Parse first control packet */\n\tsuccess = parse_control_packet(data, data_len - MT_HEADER_LEN, &cpkt);\n\n\twhile (success) {\n\t\tif (cpkt.cptype == MT_CPTYPE_BEGINAUTH) {\n\t\t\tint plen,i;\n\t\t\tif (!curconn->have_pass_salt) {\n\t\t\t\tfor (i = 0; i < 16; ++i) {\n\t\t\t\t\tcurconn->pass_salt[i] = rand() % 256;\n\t\t\t\t}\n\t\t\t\tcurconn->have_pass_salt = 1;\n\n\t\t\t\tmemset(curconn->trypassword, 0, sizeof(curconn->trypassword));\n\t\t\t}\n\t\t\tinit_packet(&pdata, MT_PTYPE_DATA, pkthdr->dstaddr, pkthdr->srcaddr, pkthdr->seskey, curconn->outcounter);\n\t\t\tplen = add_control_packet(&pdata, MT_CPTYPE_PASSSALT, (curconn->pass_salt), 16);\n\t\t\tcurconn->outcounter += plen;\n\n\t\t\tsend_udp(curconn, &pdata);\n\t\t\n\t\t/* Don't change the username after the state is active */\n\t\t} else if (cpkt.cptype == MT_CPTYPE_USERNAME && curconn->state != STATE_ACTIVE) {\n\t\t\tmemcpy(curconn->username, cpkt.data, act_size = (cpkt.length > MT_MNDP_MAX_STRING_SIZE - 1 ? MT_MNDP_MAX_STRING_SIZE - 1 : cpkt.length));\n\t\t\tcurconn->username[act_size] = 0;\n\t\t\tgot_user_packet = 1;\n\n\t\t} else if (cpkt.cptype == MT_CPTYPE_TERM_WIDTH && cpkt.length >= 2) {\n\t\t\tunsigned short width;\n\n\t\t\tmemcpy(&width, cpkt.data, 2);\n\t\t\tcurconn->terminal_width = le16toh(width);\n\t\t\tgot_width_packet = 1;\n\n\t\t} else if (cpkt.cptype == MT_CPTYPE_TERM_HEIGHT && cpkt.length >= 2) {\n\t\t\tunsigned short height;\n\n\t\t\tmemcpy(&height, cpkt.data, 2);\n\t\t\tcurconn->terminal_height = le16toh(height);\n\t\t\tgot_height_packet = 1;\n\n\t\t} else if (cpkt.cptype == MT_CPTYPE_TERM_TYPE) {\n\n\t\t\tmemcpy(curconn->terminal_type, cpkt.data, act_size = (cpkt.length > 30 - 1 ? 30 - 1 : cpkt.length));\n\t\t\tcurconn->terminal_type[act_size] = 0;\n\n\t\t} else if (cpkt.cptype == MT_CPTYPE_PASSWORD) {\n\n#if defined(__linux__) && defined(_POSIX_MEMLOCK_RANGE)\n\t\t\tmlock(curconn->trypassword, 17);\n#endif\n\t\t\tmemcpy(curconn->trypassword, cpkt.data, 17);\n\t\t\tgot_pass_packet = 1;\n\n\t\t} else if (cpkt.cptype == MT_CPTYPE_PLAINDATA) {\n\n\t\t\t/* relay data from client to shell */\n\t\t\tif (curconn->state == STATE_ACTIVE && curconn->ptsfd != -1) {\n\t\t\t\twrite(curconn->ptsfd, cpkt.data, cpkt.length);\n\t\t\t}\n\n\t\t} else {\n\t\t\tsyslog(LOG_WARNING, _(\"(%d) Unhandeled control packet type: %d\"), curconn->seskey, cpkt.cptype);\n\t\t}\n\n\t\t/* Parse next control packet */\n\t\tsuccess = parse_control_packet(NULL, 0, &cpkt);\n\t}\n\n\tif (got_user_packet && got_pass_packet) {\n\t\tuser_login(curconn, pkthdr);\n\t}\n\n\tif (curconn->state == STATE_ACTIVE && (got_width_packet || got_height_packet)) {\n\t\tset_terminal_size(curconn->ptsfd, curconn->terminal_width, curconn->terminal_height);\n\n\t}\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos_before\\2016_8\\b9cede3c19693b7663219691d8604e037cea673a_before\\MAC-Telnet-b9cede3c19693b7663219691d8604e037cea673a\\mactelnetd.c", "callees": [], "callers": []}, {"name": "add_control_packet", "content": "int add_control_packet(struct mt_packet *packet, enum mt_cptype cptype, void *cpdata, unsigned short data_len) {\n\tunsigned char *data = packet->data + packet->size;\n\tunsigned int act_size = data_len + (cptype == MT_CPTYPE_PLAINDATA ? 0 : MT_CPHEADER_LEN);\n\n\t/* Something is really wrong. Packets should never become over 1500 bytes */\n\tif (packet->size + act_size > MT_PACKET_LEN) {\n\t\tfprintf(stderr, _(\"add_control_packet: ERROR, too large packet. Exceeds %d bytes\\n\"), MT_PACKET_LEN);\n\t\treturn -1;\n\t\t//exit(1);\n\t}\n\n\t/* PLAINDATA isn't really a controlpacket, but we handle it here, since\n\t   parseControlPacket also parses raw data as PLAINDATA */\n\tif (cptype == MT_CPTYPE_PLAINDATA) {\n\t\tmemcpy(data, cpdata, data_len);\n\t\tpacket->size += data_len;\n\t\treturn data_len;\n\t}\n\n\t/* Control Packet Magic id */\n\tmemcpy(data, mt_mactelnet_cpmagic, sizeof(mt_mactelnet_cpmagic));\n\n\t/* Control packet type */\n\tdata[4] = cptype;\n\n\t/* Data length */\n#if BYTE_ORDER == LITTLE_ENDIAN\n\t{\n\t\tunsigned int templen;\n\t\ttemplen = htonl(data_len);\n\t\tmemcpy(data + 5, &templen, sizeof(templen));\n\t}\n#else\n\tmemcpy(data + 5, &data_len, sizeof(data_len));\n#endif\n\n\t/* Insert data */\n\tif (data_len > 0) {\n\t\tmemcpy(data + MT_CPHEADER_LEN, cpdata, data_len);\n\t}\n\n\tpacket->size += act_size;\n\t/* Control packet header length + data length */\n\treturn act_size;\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos_before\\2016_8\\b9cede3c19693b7663219691d8604e037cea673a_before\\MAC-Telnet-b9cede3c19693b7663219691d8604e037cea673a\\protocol.c", "callees": ["fprintf", "htonl", "memcpy"], "callers": ["send_auth"]}, {"name": "add_packetdata", "content": "int add_packetdata(struct mt_packet *packet, unsigned char *data, unsigned short length) {\n\tif (packet->size + length > MT_PACKET_LEN) {\n\t\tfprintf(stderr, _(\"add_control_packet: ERROR, too large packet. Exceeds %d bytes\\n\"), MT_PACKET_LEN);\n\t\treturn -1;\n\t}\n\n\tmemcpy(packet->data + packet->size, data, length);\n\tpacket->size += length;\n\n\treturn length;\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos_before\\2016_8\\b9cede3c19693b7663219691d8604e037cea673a_before\\MAC-Telnet-b9cede3c19693b7663219691d8604e037cea673a\\protocol.c", "callees": ["fprintf", "memcpy"], "callers": []}, {"name": "mndp_add_attribute", "content": "int mndp_add_attribute(struct mt_packet *packet, enum mt_mndp_attrtype attrtype, void *attrdata, unsigned short data_len) {\n\tunsigned char *data = packet->data + packet->size;\n\tunsigned short type = attrtype;\n\tunsigned short len = data_len;\n\n\t/* Something is really wrong. Packets should never become over 1500 bytes */\n\tif (packet->size + 4 + data_len > MT_PACKET_LEN) {\n\t\tfprintf(stderr, _(\"mndp_add_attribute: ERROR, too large packet. Exceeds %d bytes\\n\"), MT_PACKET_LEN);\n\t\treturn -1;\n\t}\n\n\ttype = htons(type);\n\tmemcpy(data, &type, sizeof(type));\n\n\tlen = htons(len);\n\tmemcpy(data + 2, &len, sizeof(len));\n\n\tmemcpy(data + 4, attrdata, data_len);\n\n\tpacket->size += 4 + data_len;\n\n\treturn 4 + data_len;\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos_before\\2016_8\\b9cede3c19693b7663219691d8604e037cea673a_before\\MAC-Telnet-b9cede3c19693b7663219691d8604e037cea673a\\protocol.c", "callees": ["fprintf", "memcpy", "htons"], "callers": []}], "functions_after": [{"name": "send_auth", "content": "static void send_auth(char *username, char *password) {\n\tstruct mt_packet data;\n\tunsigned short width = 0;\n\tunsigned short height = 0;\n\tchar *terminal = getenv(\"TERM\");\n\tchar md5data[100];\n\tunsigned char md5sum[17];\n\tint plen, act_pass_len;\n\tmd5_state_t state;\n\n#if defined(__linux__) && defined(_POSIX_MEMLOCK_RANGE)\n\tmlock(md5data, sizeof(md5data));\n\tmlock(md5sum, sizeof(md5data));\n#endif\n\n\t/* calculate the actual password's length */\n\tact_pass_len = strnlen(password, 82);\n\n\t/* Concat string of 0 + password + pass_salt */\n\tmd5data[0] = 0;\n\tmemcpy(md5data + 1, password, act_pass_len);\n\t/* in case that password is long, calculate only using the used-up parts */\n\tmemcpy(md5data + 1 + act_pass_len, pass_salt, 16);\n\n\t/* Generate md5 sum of md5data with a leading 0 */\n\tmd5_init(&state);\n\tmd5_append(&state, (const md5_byte_t *)md5data, 1 + act_pass_len + 16);\n\tmd5_finish(&state, (md5_byte_t *)md5sum + 1);\n\tmd5sum[0] = 0;\n\n\t/* Send combined packet to server */\n\tinit_packet(&data, MT_PTYPE_DATA, srcmac, dstmac, sessionkey, outcounter);\n\tplen = add_control_packet(&data, MT_CPTYPE_PASSWORD, md5sum, 17);\n\tplen += add_control_packet(&data, MT_CPTYPE_USERNAME, username, strlen(username));\n\tplen += add_control_packet(&data, MT_CPTYPE_TERM_TYPE, terminal, strlen(terminal));\n\t\n\tif (is_a_tty && get_terminal_size(&width, &height) != -1) {\n\t\twidth = htole16(width);\n\t\theight = htole16(height);\n\t\tplen += add_control_packet(&data, MT_CPTYPE_TERM_WIDTH, &width, 2);\n\t\tplen += add_control_packet(&data, MT_CPTYPE_TERM_HEIGHT, &height, 2);\n\t}\n\n\toutcounter += plen;\n\n\t/* TODO: handle result */\n\tsend_udp(&data, 1);\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos\\2016_8\\b69d11727d4f0f8cf719c79e3fb700f55ca03e9a_after\\MAC-Telnet-b69d11727d4f0f8cf719c79e3fb700f55ca03e9a\\mactelnet.c", "callees": ["md5_append", "md5_finish", "send_udp", "init_packet", "htole16", "md5_init", "getenv", "strlen", "get_terminal_size", "strnlen", "add_control_packet", "memcpy", "mlock"], "callers": ["handle_packet"]}, {"name": "handle_packet", "content": "static int handle_packet(unsigned char *data, int data_len) {\n\tstruct mt_mactelnet_hdr pkthdr;\n\n\t/* Minimal size checks (pings are not supported here) */\n\tif (data_len < MT_HEADER_LEN){\n\t\treturn -1;\n\t}\n\tparse_packet(data, &pkthdr);\n\n\t/* We only care about packets with correct sessionkey */\n\tif (pkthdr.seskey != sessionkey) {\n\t\treturn -1;\n\t}\n\n\t/* Handle data packets */\n\tif (pkthdr.ptype == MT_PTYPE_DATA) {\n\t\tstruct mt_packet odata;\n\t\tstruct mt_mactelnet_control_hdr cpkt;\n\t\tint success = 0;\n\n\t\t/* Always transmit ACKNOWLEDGE packets in response to DATA packets */\n\t\tinit_packet(&odata, MT_PTYPE_ACK, srcmac, dstmac, sessionkey, pkthdr.counter + (data_len - MT_HEADER_LEN));\n\t\tsend_udp(&odata, 0);\n\n\t\t/* Accept first packet, and all packets greater than incounter, and if counter has\n\t\twrapped around. */\n\t\tif (pkthdr.counter > incounter || (incounter - pkthdr.counter) > 65535) {\n\t\t\tincounter = pkthdr.counter;\n\t\t} else {\n\t\t\t/* Ignore double or old packets */\n\t\t\treturn -1;\n\t\t}\n\n\t\t/* Parse controlpacket data */\n\t\tsuccess = parse_control_packet(data + MT_HEADER_LEN, data_len - MT_HEADER_LEN, &cpkt);\n\n\t\twhile (success) {\n\n\t\t\t/* If we receive pass_salt, transmit auth data back */\n\t\t\tif (cpkt.cptype == MT_CPTYPE_PASSSALT) {\n\t\t\t\t/* check validity, server sends exactly 16 bytes */\n\t\t\t\tif (cpkt.length != 16) {\n\t\t\t\t\tfprintf(stderr, _(\"Invalid salt length: %d (instead of 16) received from server %s\\n\"), cpkt.length, ether_ntoa((struct ether_addr *)dstmac));\n\t\t\t\t}\n\t\t\t\tmemcpy(pass_salt, cpkt.data, 16);\n\t\t\t\tsend_auth(username, password);\n\t\t\t}\n\n\t\t\t/* If the (remaining) data did not have a control-packet magic byte sequence,\n\t\t\t   the data is raw terminal data to be outputted to the terminal. */\n\t\t\telse if (cpkt.cptype == MT_CPTYPE_PLAINDATA) {\n\t\t\t\tfwrite((const void *)cpkt.data, 1, cpkt.length, stdout);\n\t\t\t}\n\n\t\t\t/* END_AUTH means that the user/password negotiation is done, and after this point\n\t\t\t   terminal data may arrive, so we set up the terminal to raw mode. */\n\t\t\telse if (cpkt.cptype == MT_CPTYPE_END_AUTH) {\n\n\t\t\t\t/* we have entered \"terminal mode\" */\n\t\t\t\tterminal_mode = 1;\n\n\t\t\t\tif (is_a_tty) {\n\t\t\t\t\t/* stop input buffering at all levels. Give full control of terminal to RouterOS */\n\t\t\t\t\traw_term();\n\n\t\t\t\t\tsetvbuf(stdin,  (char*)NULL, _IONBF, 0);\n\n\t\t\t\t\t/* Add resize signal handler */\n\t\t\t\t\tsignal(SIGWINCH, sig_winch);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* Parse next controlpacket */\n\t\t\tsuccess = parse_control_packet(NULL, 0, &cpkt);\n\t\t}\n\t}\n\telse if (pkthdr.ptype == MT_PTYPE_ACK) {\n\t\t/* Handled elsewhere */\n\t}\n\n\t/* The server wants to terminate the connection, we have to oblige */\n\telse if (pkthdr.ptype == MT_PTYPE_END) {\n\t\tstruct mt_packet odata;\n\n\t\t/* Acknowledge the disconnection by sending a END packet in return */\n\t\tinit_packet(&odata, MT_PTYPE_END, srcmac, dstmac, pkthdr.seskey, 0);\n\t\tsend_udp(&odata, 0);\n\n\t\tif (!quiet_mode) {\n\t\t\tfprintf(stderr, _(\"Connection closed.\\n\"));\n\t\t}\n\n\t\t/* exit */\n\t\trunning = 0;\n\t} else {\n\t\tfprintf(stderr, _(\"Unhandeled packet type: %d received from server %s\\n\"), pkthdr.ptype, ether_ntoa((struct ether_addr *)dstmac));\n\t\treturn -1;\n\t}\n\n\treturn pkthdr.ptype;\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos\\2016_8\\b69d11727d4f0f8cf719c79e3fb700f55ca03e9a_after\\MAC-Telnet-b69d11727d4f0f8cf719c79e3fb700f55ca03e9a\\mactelnet.c", "callees": ["sig_winch", "fwrite", "send_udp", "fprintf", "init_packet", "send_auth", "parse_control_packet", "parse_packet", "signal", "setvbuf", "ether_ntoa", "raw_term", "memcpy"], "callers": []}, {"name": "user_login", "content": "static void user_login(struct mt_connection *curconn, struct mt_mactelnet_hdr *pkthdr) {\n\tstruct mt_packet pdata;\n\tunsigned char md5sum[17];\n\tchar md5data[100];\n\tstruct mt_credentials *user;\n\tchar *slavename;\n\tint act_pass_len;\n\n\t/* Reparse user file before each login */\n\tread_userfile();\n\n\tif ((user = find_user(curconn->username)) != NULL) {\n\t\tmd5_state_t state;\n#if defined(__linux__) && defined(_POSIX_MEMLOCK_RANGE)\n\t\tmlock(md5data, sizeof(md5data));\n\t\tmlock(md5sum, sizeof(md5sum));\n\t\tif (user->password != NULL) {\n\t\t\tmlock(user->password, strlen(user->password));\n\t\t}\n#endif\n\n\t\t/* calculate the password's actual length */\n\t\tact_pass_len = strlen(user->password);\n\t\tact_pass_len = act_pass_len <= 82 ? act_pass_len : 82;\n\n\t\t/* Concat string of 0 + password + pass_salt */\n\t\tmd5data[0] = 0;\n\t\tmemcpy(md5data + 1, user->password, act_pass_len);\n\t\tmemcpy(md5data + 1 + act_pass_len, curconn->pass_salt, 16);\n\n\t\t/* Generate md5 sum of md5data with a leading 0 */\n\t\tmd5_init(&state);\n\t\tmd5_append(&state, (const md5_byte_t *)md5data, 1 + act_pass_len + 16);\n\t\tmd5_finish(&state, (md5_byte_t *)md5sum + 1);\n\t\tmd5sum[0] = 0;\n\n\t\tinit_packet(&pdata, MT_PTYPE_DATA, pkthdr->dstaddr, pkthdr->srcaddr, pkthdr->seskey, curconn->outcounter);\n\t\tcurconn->outcounter += add_control_packet(&pdata, MT_CPTYPE_END_AUTH, NULL, 0);\n\t\tsend_udp(curconn, &pdata);\n\n\t\tif (curconn->state == STATE_ACTIVE) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (user == NULL || memcmp(md5sum, curconn->trypassword, 17) != 0) {\n\t\tsyslog(LOG_NOTICE, _(\"(%d) Invalid login by %s.\"), curconn->seskey, curconn->username);\n\n\t\t/*_ Please include both \\r and \\n in translation, this is needed for the terminal emulator. */\n\t\tabort_connection(curconn, pkthdr, _(\"Login failed, incorrect username or password\\r\\n\"));\n\n\t\t/* TODO: should wait some time (not with sleep) before returning, to minimalize brute force attacks */\n\t\treturn;\n\t}\n\n\t/* User is logged in */\n\tcurconn->state = STATE_ACTIVE;\n\n\t/* Enter terminal mode */\n\tcurconn->terminal_mode = 1;\n\n\t/* Open pts handle */\n\tcurconn->ptsfd = posix_openpt(O_RDWR);\n\tif (curconn->ptsfd == -1 || grantpt(curconn->ptsfd) == -1 || unlockpt(curconn->ptsfd) == -1) {\n\t\t\tsyslog(LOG_ERR, \"posix_openpt: %s\", strerror(errno));\n\t\t\t/*_ Please include both \\r and \\n in translation, this is needed for the terminal emulator. */\n\t\t\tabort_connection(curconn, pkthdr, _(\"Terminal error\\r\\n\"));\n\t\t\treturn;\n\t}\n\n\t/* Get file path for our pts */\n\tslavename = ptsname(curconn->ptsfd);\n\tif (slavename != NULL) {\n\t\tpid_t pid;\n\t\tstruct stat sb;\n\t\tstruct passwd *user = (struct passwd *)malloc(sizeof(struct passwd));\n\t\tstruct passwd *tmpuser=user;\n\t\tchar *buffer = malloc(1024);\n\n\t\tif (user == NULL || buffer == NULL) {\n\t\t\tsyslog(LOG_CRIT, _(\"(%d) Error allocating memory.\"), curconn->seskey);\n\t\t\t/*_ Please include both \\r and \\n in translation, this is needed for the terminal emulator. */\n\t\t\tabort_connection(curconn, pkthdr, _(\"System error, out of memory\\r\\n\"));\n\t\t\treturn;\n\t\t}\n\n\t\tif (getpwnam_r(curconn->username, user, buffer, 1024, &tmpuser) != 0) {\n\t\t\tsyslog(LOG_WARNING, _(\"(%d) Login ok, but local user not accessible (%s).\"), curconn->seskey, curconn->username);\n\t\t\t/*_ Please include both \\r and \\n in translation, this is needed for the terminal emulator. */\n\t\t\tabort_connection(curconn, pkthdr, _(\"Local user not accessible\\r\\n\"));\n\t\t\tfree(user);\n\t\t\tfree(buffer);\n\t\t\treturn;\n\t\t}\n\n\t\t/* Change the owner of the slave pts */\n\t\tchown(slavename, user->pw_uid, user->pw_gid);\n\n\t\tcurconn->slavefd = open(slavename, O_RDWR);\n\t\tif (curconn->slavefd == -1) {\n\t\t\tsyslog(LOG_ERR, _(\"Error opening %s: %s\"), slavename, strerror(errno));\n\t\t\t/*_ Please include both \\r and \\n in translation, this is needed for the terminal emulator. */\n\t\t\tabort_connection(curconn, pkthdr, _(\"Error opening terminal\\r\\n\"));\n\t\t\tlist_remove_connection(curconn);\n\t\t\treturn;\n\t\t}\n\n\t\tif ((pid = fork()) == 0) {\n\t\t\tstruct net_interface *interface;\n\n\t\t\t/* Add login information to utmp/wtmp */\n\t\t\tuwtmp_login(curconn);\n\n\t\t\tsyslog(LOG_INFO, _(\"(%d) User %s logged in.\"), curconn->seskey, curconn->username);\n\n\t\t\t/* Initialize terminal environment */\n\t\t\tsetenv(\"USER\", user->pw_name, 1);\n\t\t\tsetenv(\"HOME\", user->pw_dir, 1);\n\t\t\tsetenv(\"SHELL\", user->pw_shell, 1);\n\t\t\tsetenv(\"TERM\", curconn->terminal_type, 1);\n\t\t\tclose(sockfd);\n\t\t\tclose(insockfd);\n\n\t\t\tDL_FOREACH(interfaces, interface) {\n\t\t\t\tif (interface->socketfd > 0) {\n\t\t\t\t\tclose(interface->socketfd);\n\t\t\t\t}\n\t\t\t}\n\t\t\tsetsid();\n\n\t\t\t/* Don't let shell process inherit slavefd */\n\t\t\tfcntl (curconn->slavefd, F_SETFD, FD_CLOEXEC);\n\t\t\tclose(curconn->ptsfd);\n\n\t\t\t/* Redirect STDIN/STDIO/STDERR */\n\t\t\tclose(0);\n\t\t\tdup(curconn->slavefd);\n\t\t\tclose(1);\n\t\t\tdup(curconn->slavefd);\n\t\t\tclose(2);\n\t\t\tdup(curconn->slavefd);\n\n\t\t\t/* Set controlling terminal */\n\t\t\tioctl(0, TIOCSCTTY, 1);\n\t\t\ttcsetpgrp(0, getpid());\n\n\t\t\t/* Set user id/group id */\n\t\t\tif ((setgid(user->pw_gid) != 0) || (setuid(user->pw_uid) != 0)) {\n\t\t\t\tsyslog(LOG_ERR, _(\"(%d) Could not log in %s (%d:%d): setuid/setgid: %s\"), curconn->seskey, curconn->username, user->pw_uid, user->pw_gid, strerror(errno));\n\t\t\t\t/*_ Please include both \\r and \\n in translation, this is needed for the terminal emulator. */\n\t\t\t\tabort_connection(curconn, pkthdr, _(\"Internal error\\r\\n\"));\n\t\t\t\texit(0);\n\t\t\t}\n\n\t\t\t/* Abort login if /etc/nologin exists */\n\t\t\tif (stat(_PATH_NOLOGIN, &sb) == 0 && getuid() != 0) {\n\t\t\t\tsyslog(LOG_NOTICE, _(\"(%d) User %s disconnected with \" _PATH_NOLOGIN \" message.\"), curconn->seskey, curconn->username);\n\t\t\t\tdisplay_nologin();\n\t\t\t\tcurconn->state = STATE_CLOSED;\n\t\t\t\tinit_packet(&pdata, MT_PTYPE_END, pkthdr->dstaddr, pkthdr->srcaddr, pkthdr->seskey, curconn->outcounter);\n\t\t\t\tsend_udp(curconn, &pdata);\n\t\t\t\texit(0);\n\t\t\t}\n\n\t\t\t/* Display MOTD */\n\t\t\tdisplay_motd();\n\n\t\t\tchdir(user->pw_dir);\n\n\t\t\t/* Spawn shell */\n\t\t\t/* TODO: Maybe use \"login -f USER\" instead? renders motd and executes shell correctly for system */\n\t\t\texecl(user->pw_shell, user->pw_shell, \"-\", (char *) 0);\n\t\t\texit(0); // just to be sure.\n\t\t}\n\t\tfree(user);\n\t\tfree(buffer);\n\t\tclose(curconn->slavefd);\n\t\tcurconn->pid = pid;\n\t\tset_terminal_size(curconn->ptsfd, curconn->terminal_width, curconn->terminal_height);\n\t}\n\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos\\2016_8\\b69d11727d4f0f8cf719c79e3fb700f55ca03e9a_after\\MAC-Telnet-b69d11727d4f0f8cf719c79e3fb700f55ca03e9a\\mactelnetd.c", "callees": [], "callers": []}, {"name": "handle_data_packet", "content": "static void handle_data_packet(struct mt_connection *curconn, struct mt_mactelnet_hdr *pkthdr, int data_len) {\n\tstruct mt_mactelnet_control_hdr cpkt;\n\tstruct mt_packet pdata;\n\tunsigned char *data = pkthdr->data;\n\tunsigned int act_size = 0;\n\tint got_user_packet = 0;\n\tint got_pass_packet = 0;\n\tint got_width_packet = 0;\n\tint got_height_packet = 0;\n\tint success;\n\n\t/* Parse first control packet */\n\tsuccess = parse_control_packet(data, data_len - MT_HEADER_LEN, &cpkt);\n\n\twhile (success) {\n\t\tif (cpkt.cptype == MT_CPTYPE_BEGINAUTH) {\n\t\t\tint plen,i;\n\t\t\tif (!curconn->have_pass_salt) {\n\t\t\t\tfor (i = 0; i < 16; ++i) {\n\t\t\t\t\tcurconn->pass_salt[i] = rand() % 256;\n\t\t\t\t}\n\t\t\t\tcurconn->have_pass_salt = 1;\n\n\t\t\t\tmemset(curconn->trypassword, 0, sizeof(curconn->trypassword));\n\t\t\t}\n\t\t\tinit_packet(&pdata, MT_PTYPE_DATA, pkthdr->dstaddr, pkthdr->srcaddr, pkthdr->seskey, curconn->outcounter);\n\t\t\tplen = add_control_packet(&pdata, MT_CPTYPE_PASSSALT, (curconn->pass_salt), 16);\n\t\t\tcurconn->outcounter += plen;\n\n\t\t\tsend_udp(curconn, &pdata);\n\t\t\n\t\t/* Don't change the username after the state is active */\n\t\t} else if (cpkt.cptype == MT_CPTYPE_USERNAME && curconn->state != STATE_ACTIVE) {\n\t\t\tmemcpy(curconn->username, cpkt.data, act_size = (cpkt.length > MT_MNDP_MAX_STRING_SIZE - 1 ? MT_MNDP_MAX_STRING_SIZE - 1 : cpkt.length));\n\t\t\tcurconn->username[act_size] = 0;\n\t\t\tgot_user_packet = 1;\n\n\t\t} else if (cpkt.cptype == MT_CPTYPE_TERM_WIDTH && cpkt.length >= 2) {\n\t\t\tunsigned short width;\n\n\t\t\tmemcpy(&width, cpkt.data, 2);\n\t\t\tcurconn->terminal_width = le16toh(width);\n\t\t\tgot_width_packet = 1;\n\n\t\t} else if (cpkt.cptype == MT_CPTYPE_TERM_HEIGHT && cpkt.length >= 2) {\n\t\t\tunsigned short height;\n\n\t\t\tmemcpy(&height, cpkt.data, 2);\n\t\t\tcurconn->terminal_height = le16toh(height);\n\t\t\tgot_height_packet = 1;\n\n\t\t} else if (cpkt.cptype == MT_CPTYPE_TERM_TYPE) {\n\n\t\t\tmemcpy(curconn->terminal_type, cpkt.data, act_size = (cpkt.length > 30 - 1 ? 30 - 1 : cpkt.length));\n\t\t\tcurconn->terminal_type[act_size] = 0;\n\n\t\t} else if (cpkt.cptype == MT_CPTYPE_PASSWORD && cpkt.length == 17) {\n\n#if defined(__linux__) && defined(_POSIX_MEMLOCK_RANGE)\n\t\t\tmlock(curconn->trypassword, 17);\n#endif\n\t\t\tmemcpy(curconn->trypassword, cpkt.data, 17);\n\t\t\tgot_pass_packet = 1;\n\n\t\t} else if (cpkt.cptype == MT_CPTYPE_PLAINDATA) {\n\n\t\t\t/* relay data from client to shell */\n\t\t\tif (curconn->state == STATE_ACTIVE && curconn->ptsfd != -1) {\n\t\t\t\twrite(curconn->ptsfd, cpkt.data, cpkt.length);\n\t\t\t}\n\n\t\t} else {\n\t\t\tsyslog(LOG_WARNING, _(\"(%d) Unhandeled control packet type: %d, length: %d\"), curconn->seskey, cpkt.cptype, cpkt.length);\n\t\t}\n\n\t\t/* Parse next control packet */\n\t\tsuccess = parse_control_packet(NULL, 0, &cpkt);\n\t}\n\n\tif (got_user_packet && got_pass_packet) {\n\t\tuser_login(curconn, pkthdr);\n\t}\n\n\tif (curconn->state == STATE_ACTIVE && (got_width_packet || got_height_packet)) {\n\t\tset_terminal_size(curconn->ptsfd, curconn->terminal_width, curconn->terminal_height);\n\n\t}\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos\\2016_8\\b69d11727d4f0f8cf719c79e3fb700f55ca03e9a_after\\MAC-Telnet-b69d11727d4f0f8cf719c79e3fb700f55ca03e9a\\mactelnetd.c", "callees": [], "callers": []}, {"name": "add_control_packet", "content": "int add_control_packet(struct mt_packet *packet, enum mt_cptype cptype, void *cpdata, unsigned short data_len) {\n\tunsigned char *data = packet->data + packet->size;\n\tunsigned int act_size = data_len + (cptype == MT_CPTYPE_PLAINDATA ? 0 : MT_CPHEADER_LEN);\n\n\t/* Something is really wrong. Packets should never become over 1500 bytes,\n       perform an Integer-Overflow safe check */\n\tif (act_size > MT_PACKET_LEN - packet->size) {\n\t\tfprintf(stderr, _(\"add_control_packet: ERROR, too large packet. Exceeds %d bytes\\n\"), MT_PACKET_LEN);\n\t\treturn -1;\n\t\t//exit(1);\n\t}\n\n\t/* PLAINDATA isn't really a controlpacket, but we handle it here, since\n\t   parseControlPacket also parses raw data as PLAINDATA */\n\tif (cptype == MT_CPTYPE_PLAINDATA) {\n\t\tmemcpy(data, cpdata, data_len);\n\t\tpacket->size += data_len;\n\t\treturn data_len;\n\t}\n\n\t/* Control Packet Magic id */\n\tmemcpy(data, mt_mactelnet_cpmagic, sizeof(mt_mactelnet_cpmagic));\n\n\t/* Control packet type */\n\tdata[4] = cptype;\n\n\t/* Data length */\n#if BYTE_ORDER == LITTLE_ENDIAN\n\t{\n\t\tunsigned int templen;\n\t\ttemplen = htonl(data_len);\n\t\tmemcpy(data + 5, &templen, sizeof(templen));\n\t}\n#else\n\tmemcpy(data + 5, &data_len, sizeof(data_len));\n#endif\n\n\t/* Insert data */\n\tif (data_len > 0) {\n\t\tmemcpy(data + MT_CPHEADER_LEN, cpdata, data_len);\n\t}\n\n\tpacket->size += act_size;\n\t/* Control packet header length + data length */\n\treturn act_size;\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos\\2016_8\\b69d11727d4f0f8cf719c79e3fb700f55ca03e9a_after\\MAC-Telnet-b69d11727d4f0f8cf719c79e3fb700f55ca03e9a\\protocol.c", "callees": ["fprintf", "htonl", "memcpy"], "callers": ["send_auth"]}, {"name": "add_packetdata", "content": "int add_packetdata(struct mt_packet *packet, unsigned char *data, unsigned short length) {\n\t/* Integer-Overflow safe check */\n\tif (length > MT_PACKET_LEN - packet->size) {\n\t\tfprintf(stderr, _(\"add_control_packet: ERROR, too large packet. Exceeds %d bytes\\n\"), MT_PACKET_LEN);\n\t\treturn -1;\n\t}\n\n\tmemcpy(packet->data + packet->size, data, length);\n\tpacket->size += length;\n\n\treturn length;\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos\\2016_8\\b69d11727d4f0f8cf719c79e3fb700f55ca03e9a_after\\MAC-Telnet-b69d11727d4f0f8cf719c79e3fb700f55ca03e9a\\protocol.c", "callees": ["fprintf", "memcpy"], "callers": []}, {"name": "mndp_add_attribute", "content": "int mndp_add_attribute(struct mt_packet *packet, enum mt_mndp_attrtype attrtype, void *attrdata, unsigned short data_len) {\n\tunsigned char *data = packet->data + packet->size;\n\tunsigned short type = attrtype;\n\tunsigned short len = data_len;\n\n\t/* Something is really wrong. Packets should never become over 1500 bytes */\n\tif (data_len > MT_PACKET_LEN - 4 - packet->size) {\n\t\tfprintf(stderr, _(\"mndp_add_attribute: ERROR, too large packet. Exceeds %d bytes\\n\"), MT_PACKET_LEN);\n\t\treturn -1;\n\t}\n\n\ttype = htons(type);\n\tmemcpy(data, &type, sizeof(type));\n\n\tlen = htons(len);\n\tmemcpy(data + 2, &len, sizeof(len));\n\n\tmemcpy(data + 4, attrdata, data_len);\n\n\tpacket->size += 4 + data_len;\n\n\treturn 4 + data_len;\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos\\2016_8\\b69d11727d4f0f8cf719c79e3fb700f55ca03e9a_after\\MAC-Telnet-b69d11727d4f0f8cf719c79e3fb700f55ca03e9a\\protocol.c", "callees": ["fprintf", "memcpy", "htons"], "callers": []}], "callerTree_before": {"send_auth": ["md5_append", "md5_finish", "strncpy", "send_udp", "init_packet", "htole16", "md5_init", "getenv", "strlen", "get_terminal_size", "add_control_packet", "memcpy", "mlock"], "handle_packet": ["sig_winch", "fwrite", "send_udp", "fprintf", "init_packet", "send_auth", "parse_control_packet", "parse_packet", "signal", "setvbuf", "ether_ntoa", "raw_term", "memcpy"], "add_control_packet": ["fprintf", "htonl", "memcpy"], "add_packetdata": ["fprintf", "memcpy"], "mndp_add_attribute": ["fprintf", "memcpy", "htons"]}, "calleeTree_before": {"getenv": ["send_auth"], "mlock": ["send_auth"], "strncpy": ["send_auth"], "memcpy": ["handle_packet", "send_auth", "mndp_add_attribute", "add_control_packet", "add_packetdata"], "strlen": ["send_auth"], "md5_init": ["send_auth"], "md5_append": ["send_auth"], "md5_finish": ["send_auth"], "init_packet": ["send_auth", "handle_packet"], "add_control_packet": ["send_auth"], "get_terminal_size": ["send_auth"], "htole16": ["send_auth"], "send_udp": ["send_auth", "handle_packet"], "parse_packet": ["handle_packet"], "parse_control_packet": ["handle_packet"], "send_auth": ["handle_packet"], "fwrite": ["handle_packet"], "raw_term": ["handle_packet"], "setvbuf": ["handle_packet"], "signal": ["handle_packet"], "sig_winch": ["handle_packet"], "fprintf": ["add_control_packet", "mndp_add_attribute", "add_packetdata", "handle_packet"], "ether_ntoa": ["handle_packet"], "htonl": ["add_control_packet"], "htons": ["mndp_add_attribute"]}, "callerTree_after": {"send_auth": ["md5_append", "md5_finish", "send_udp", "init_packet", "htole16", "md5_init", "getenv", "strlen", "get_terminal_size", "strnlen", "add_control_packet", "memcpy", "mlock"], "handle_packet": ["sig_winch", "fwrite", "send_udp", "fprintf", "init_packet", "send_auth", "parse_control_packet", "parse_packet", "signal", "setvbuf", "ether_ntoa", "raw_term", "memcpy"], "add_control_packet": ["fprintf", "htonl", "memcpy"], "add_packetdata": ["fprintf", "memcpy"], "mndp_add_attribute": ["fprintf", "memcpy", "htons"]}, "calleeTree_after": {"getenv": ["send_auth"], "mlock": ["send_auth"], "strnlen": ["send_auth"], "memcpy": ["handle_packet", "send_auth", "mndp_add_attribute", "add_control_packet", "add_packetdata"], "md5_init": ["send_auth"], "md5_append": ["send_auth"], "md5_finish": ["send_auth"], "init_packet": ["send_auth", "handle_packet"], "add_control_packet": ["send_auth"], "strlen": ["send_auth"], "get_terminal_size": ["send_auth"], "htole16": ["send_auth"], "send_udp": ["send_auth", "handle_packet"], "parse_packet": ["handle_packet"], "parse_control_packet": ["handle_packet"], "fprintf": ["add_control_packet", "mndp_add_attribute", "add_packetdata", "handle_packet"], "ether_ntoa": ["handle_packet"], "send_auth": ["handle_packet"], "fwrite": ["handle_packet"], "raw_term": ["handle_packet"], "setvbuf": ["handle_packet"], "signal": ["handle_packet"], "sig_winch": ["handle_packet"], "htonl": ["add_control_packet"], "htons": ["mndp_add_attribute"]}}
{"repo_after": "cf0aa7751f6ef8445e9310a64b14dc81460ca156", "repo_before": "90a5ab519805acb6c5d1ae91d8e3f494ec179db4", "functions_before": [{"name": "dbd_db_login", "content": "int dbd_db_login(SV* dbh, imp_dbh_t* imp_dbh, char* dbname, char* user,\n\t\t char* password) {\n#ifdef dTHR\n  dTHR;\n#endif\n  dTHX; \n  D_imp_xxh(dbh);\n\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n\t\t  \"imp_dbh->connect: dsn = %s, uid = %s, pwd = %s\\n\",\n\t\t  dbname ? dbname : \"NULL\",\n\t\t  user ? user : \"NULL\",\n\t\t  password ? password : \"NULL\");\n\n  imp_dbh->stats.auto_reconnects_ok= 0;\n  imp_dbh->stats.auto_reconnects_failed= 0;\n  imp_dbh->bind_type_guessing= FALSE;\n  imp_dbh->bind_comment_placeholders= FALSE;\n  imp_dbh->has_transactions= TRUE;\n /* Safer we flip this to TRUE perl side if we detect a mod_perl env. */\n  imp_dbh->auto_reconnect = FALSE;\n\n  /* HELMUT */\n#if defined(sv_utf8_decode) && MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION\n  imp_dbh->enable_utf8 = FALSE;     /* initialize mysql_enable_utf8 */\n  imp_dbh->enable_utf8mb4 = FALSE;  /* initialize mysql_enable_utf8mb4 */\n#endif\n\n  if (!my_login(aTHX_ dbh, imp_dbh))\n  {\n    if(imp_dbh->pmysql)\n        do_error(dbh, mysql_errno(imp_dbh->pmysql),\n                mysql_error(imp_dbh->pmysql) ,mysql_sqlstate(imp_dbh->pmysql));\n    return FALSE;\n  }\n\n    /*\n     *  Tell DBI, that dbh->disconnect should be called for this handle\n     */\n    DBIc_ACTIVE_on(imp_dbh);\n\n    /* Tell DBI, that dbh->destroy should be called for this handle */\n    DBIc_on(imp_dbh, DBIcf_IMPSET);\n\n    return TRUE;\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos_before\\2016_8\\90a5ab519805acb6c5d1ae91d8e3f494ec179db4_before\\DBD-mysql-90a5ab519805acb6c5d1ae91d8e3f494ec179db4\\dbdimp.c", "callees": ["DBIc_on", "DBIc_TRACE_LEVEL", "do_error", "DBIc_LOGPIO", "mysql_errno", "DBIc_ACTIVE_on", "mysql_error", "my_login", "mysql_sqlstate", "D_imp_xxh", "PerlIO_printf"], "callers": []}], "functions_after": [{"name": "dbd_db_login", "content": "int dbd_db_login(SV* dbh, imp_dbh_t* imp_dbh, char* dbname, char* user,\n\t\t char* password) {\n#ifdef dTHR\n  dTHR;\n#endif\n  dTHX; \n  D_imp_xxh(dbh);\n\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n\t\t  \"imp_dbh->connect: dsn = %s, uid = %s, pwd = %s\\n\",\n\t\t  dbname ? dbname : \"NULL\",\n\t\t  user ? user : \"NULL\",\n\t\t  password ? password : \"NULL\");\n\n  imp_dbh->stats.auto_reconnects_ok= 0;\n  imp_dbh->stats.auto_reconnects_failed= 0;\n  imp_dbh->bind_type_guessing= FALSE;\n  imp_dbh->bind_comment_placeholders= FALSE;\n  imp_dbh->has_transactions= TRUE;\n /* Safer we flip this to TRUE perl side if we detect a mod_perl env. */\n  imp_dbh->auto_reconnect = FALSE;\n\n  /* HELMUT */\n#if defined(sv_utf8_decode) && MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION\n  imp_dbh->enable_utf8 = FALSE;     /* initialize mysql_enable_utf8 */\n  imp_dbh->enable_utf8mb4 = FALSE;  /* initialize mysql_enable_utf8mb4 */\n#endif\n\n  if (!my_login(aTHX_ dbh, imp_dbh))\n  {\n    if(imp_dbh->pmysql) {\n        do_error(dbh, mysql_errno(imp_dbh->pmysql),\n                mysql_error(imp_dbh->pmysql) ,mysql_sqlstate(imp_dbh->pmysql));\n        Safefree(imp_dbh->pmysql);\n\n    }\n    return FALSE;\n  }\n\n    /*\n     *  Tell DBI, that dbh->disconnect should be called for this handle\n     */\n    DBIc_ACTIVE_on(imp_dbh);\n\n    /* Tell DBI, that dbh->destroy should be called for this handle */\n    DBIc_on(imp_dbh, DBIcf_IMPSET);\n\n    return TRUE;\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos\\2016_8\\cf0aa7751f6ef8445e9310a64b14dc81460ca156_after\\DBD-mysql-cf0aa7751f6ef8445e9310a64b14dc81460ca156\\dbdimp.c", "callees": ["DBIc_on", "DBIc_TRACE_LEVEL", "do_error", "DBIc_LOGPIO", "mysql_errno", "DBIc_ACTIVE_on", "mysql_error", "my_login", "mysql_sqlstate", "D_imp_xxh", "Safefree", "PerlIO_printf"], "callers": []}], "callerTree_before": {"dbd_db_login": ["DBIc_on", "DBIc_TRACE_LEVEL", "do_error", "DBIc_LOGPIO", "mysql_errno", "DBIc_ACTIVE_on", "mysql_error", "my_login", "mysql_sqlstate", "D_imp_xxh", "PerlIO_printf"]}, "calleeTree_before": {"D_imp_xxh": ["dbd_db_login"], "DBIc_TRACE_LEVEL": ["dbd_db_login"], "PerlIO_printf": ["dbd_db_login"], "DBIc_LOGPIO": ["dbd_db_login"], "my_login": ["dbd_db_login"], "do_error": ["dbd_db_login"], "mysql_errno": ["dbd_db_login"], "mysql_error": ["dbd_db_login"], "mysql_sqlstate": ["dbd_db_login"], "DBIc_ACTIVE_on": ["dbd_db_login"], "DBIc_on": ["dbd_db_login"]}, "callerTree_after": {"dbd_db_login": ["DBIc_on", "DBIc_TRACE_LEVEL", "do_error", "DBIc_LOGPIO", "mysql_errno", "DBIc_ACTIVE_on", "mysql_error", "my_login", "mysql_sqlstate", "D_imp_xxh", "Safefree", "PerlIO_printf"]}, "calleeTree_after": {"D_imp_xxh": ["dbd_db_login"], "DBIc_TRACE_LEVEL": ["dbd_db_login"], "PerlIO_printf": ["dbd_db_login"], "DBIc_LOGPIO": ["dbd_db_login"], "my_login": ["dbd_db_login"], "do_error": ["dbd_db_login"], "mysql_errno": ["dbd_db_login"], "mysql_error": ["dbd_db_login"], "mysql_sqlstate": ["dbd_db_login"], "Safefree": ["dbd_db_login"], "DBIc_ACTIVE_on": ["dbd_db_login"], "DBIc_on": ["dbd_db_login"]}}
{"repo_after": "a56ae87a4c1c1fead7d09c3653905841ccccf1cc", "repo_before": "3e09017a24367d04156fce07f3f48a5fdb8c5db8", "functions_before": [{"name": "my_login", "content": "static int my_login(pTHX_ SV* dbh, imp_dbh_t *imp_dbh)\n{\n  SV* sv;\n  HV* hv;\n  char* dbname;\n  char* host;\n  char* port;\n  char* user;\n  char* password;\n  char* mysql_socket;\n  int   result;\n  D_imp_xxh(dbh);\n\n  /* TODO- resolve this so that it is set only if DBI is 1.607 */\n#define TAKE_IMP_DATA_VERSION 1\n#if TAKE_IMP_DATA_VERSION\n  if (DBIc_has(imp_dbh, DBIcf_IMPSET))\n  { /* eg from take_imp_data() */\n    if (DBIc_has(imp_dbh, DBIcf_ACTIVE))\n    {\n      if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n        PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"my_login skip connect\\n\");\n      /* tell our parent we've adopted an active child */\n      ++DBIc_ACTIVE_KIDS(DBIc_PARENT_COM(imp_dbh));\n      return TRUE;\n    }\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                    \"my_login IMPSET but not ACTIVE so connect not skipped\\n\");\n  }\n#endif\n\n  sv = DBIc_IMP_DATA(imp_dbh);\n\n  if (!sv  ||  !SvROK(sv))\n    return FALSE;\n\n  hv = (HV*) SvRV(sv);\n  if (SvTYPE(hv) != SVt_PVHV)\n    return FALSE;\n\n  host=\t\tsafe_hv_fetch(aTHX_ hv, \"host\", 4);\n  port=\t\tsafe_hv_fetch(aTHX_ hv, \"port\", 4);\n  user=\t\tsafe_hv_fetch(aTHX_ hv, \"user\", 4);\n  password=\tsafe_hv_fetch(aTHX_ hv, \"password\", 8);\n  dbname=\tsafe_hv_fetch(aTHX_ hv, \"database\", 8);\n  mysql_socket=\tsafe_hv_fetch(aTHX_ hv, \"mysql_socket\", 12);\n\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n\t\t  \"imp_dbh->my_login : dbname = %s, uid = %s, pwd = %s,\" \\\n\t\t  \"host = %s, port = %s\\n\",\n\t\t  dbname ? dbname : \"NULL\",\n\t\t  user ? user : \"NULL\",\n\t\t  password ? password : \"NULL\",\n\t\t  host ? host : \"NULL\",\n\t\t  port ? port : \"NULL\");\n\n  if (!imp_dbh->pmysql) {\n     Newz(908, imp_dbh->pmysql, 1, MYSQL);\n  }\n  result = mysql_dr_connect(dbh, imp_dbh->pmysql, mysql_socket, host, port, user,\n\t\t\t  password, dbname, imp_dbh) ? TRUE : FALSE;\n  if (!result)\n      Safefree(imp_dbh->pmysql);\n  return result;\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos_before\\2016_8\\3e09017a24367d04156fce07f3f48a5fdb8c5db8_before\\DBD-mysql-3e09017a24367d04156fce07f3f48a5fdb8c5db8\\dbdimp.c", "callees": ["SvTYPE", "DBIc_IMP_DATA", "DBIc_TRACE_LEVEL", "DBIc_ACTIVE_KIDS", "Newz", "DBIc_LOGPIO", "mysql_dr_connect", "SvROK", "DBIc_PARENT_COM", "SvRV", "safe_hv_fetch", "D_imp_xxh", "DBIc_has", "Safefree", "PerlIO_printf"], "callers": ["dbd_db_login"]}, {"name": "dbd_db_login", "content": "int dbd_db_login(SV* dbh, imp_dbh_t* imp_dbh, char* dbname, char* user,\n\t\t char* password) {\n#ifdef dTHR\n  dTHR;\n#endif\n  dTHX; \n  D_imp_xxh(dbh);\n\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n\t\t  \"imp_dbh->connect: dsn = %s, uid = %s, pwd = %s\\n\",\n\t\t  dbname ? dbname : \"NULL\",\n\t\t  user ? user : \"NULL\",\n\t\t  password ? password : \"NULL\");\n\n  imp_dbh->stats.auto_reconnects_ok= 0;\n  imp_dbh->stats.auto_reconnects_failed= 0;\n  imp_dbh->bind_type_guessing= FALSE;\n  imp_dbh->bind_comment_placeholders= FALSE;\n  imp_dbh->has_transactions= TRUE;\n /* Safer we flip this to TRUE perl side if we detect a mod_perl env. */\n  imp_dbh->auto_reconnect = FALSE;\n\n  /* HELMUT */\n#if defined(sv_utf8_decode) && MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION\n  imp_dbh->enable_utf8 = FALSE;  /* initialize mysql_enable_utf8 */\n#endif\n\n  if (!my_login(aTHX_ dbh, imp_dbh))\n  {\n    do_error(dbh, mysql_errno(imp_dbh->pmysql),\n            mysql_error(imp_dbh->pmysql) ,mysql_sqlstate(imp_dbh->pmysql));\n    return FALSE;\n  }\n\n    /*\n     *  Tell DBI, that dbh->disconnect should be called for this handle\n     */\n    DBIc_ACTIVE_on(imp_dbh);\n\n    /* Tell DBI, that dbh->destroy should be called for this handle */\n    DBIc_on(imp_dbh, DBIcf_IMPSET);\n\n    return TRUE;\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos_before\\2016_8\\3e09017a24367d04156fce07f3f48a5fdb8c5db8_before\\DBD-mysql-3e09017a24367d04156fce07f3f48a5fdb8c5db8\\dbdimp.c", "callees": ["DBIc_on", "DBIc_TRACE_LEVEL", "do_error", "DBIc_LOGPIO", "mysql_errno", "DBIc_ACTIVE_on", "mysql_error", "my_login", "mysql_sqlstate", "D_imp_xxh", "PerlIO_printf"], "callers": []}], "functions_after": [{"name": "my_login", "content": "static int my_login(pTHX_ SV* dbh, imp_dbh_t *imp_dbh)\n{\n  SV* sv;\n  HV* hv;\n  char* dbname;\n  char* host;\n  char* port;\n  char* user;\n  char* password;\n  char* mysql_socket;\n  int   result;\n  int\tfresh = 0;\n  D_imp_xxh(dbh);\n\n  /* TODO- resolve this so that it is set only if DBI is 1.607 */\n#define TAKE_IMP_DATA_VERSION 1\n#if TAKE_IMP_DATA_VERSION\n  if (DBIc_has(imp_dbh, DBIcf_IMPSET))\n  { /* eg from take_imp_data() */\n    if (DBIc_has(imp_dbh, DBIcf_ACTIVE))\n    {\n      if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n        PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"my_login skip connect\\n\");\n      /* tell our parent we've adopted an active child */\n      ++DBIc_ACTIVE_KIDS(DBIc_PARENT_COM(imp_dbh));\n      return TRUE;\n    }\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                    \"my_login IMPSET but not ACTIVE so connect not skipped\\n\");\n  }\n#endif\n\n  sv = DBIc_IMP_DATA(imp_dbh);\n\n  if (!sv  ||  !SvROK(sv))\n    return FALSE;\n\n  hv = (HV*) SvRV(sv);\n  if (SvTYPE(hv) != SVt_PVHV)\n    return FALSE;\n\n  host=\t\tsafe_hv_fetch(aTHX_ hv, \"host\", 4);\n  port=\t\tsafe_hv_fetch(aTHX_ hv, \"port\", 4);\n  user=\t\tsafe_hv_fetch(aTHX_ hv, \"user\", 4);\n  password=\tsafe_hv_fetch(aTHX_ hv, \"password\", 8);\n  dbname=\tsafe_hv_fetch(aTHX_ hv, \"database\", 8);\n  mysql_socket=\tsafe_hv_fetch(aTHX_ hv, \"mysql_socket\", 12);\n\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n\t\t  \"imp_dbh->my_login : dbname = %s, uid = %s, pwd = %s,\" \\\n\t\t  \"host = %s, port = %s\\n\",\n\t\t  dbname ? dbname : \"NULL\",\n\t\t  user ? user : \"NULL\",\n\t\t  password ? password : \"NULL\",\n\t\t  host ? host : \"NULL\",\n\t\t  port ? port : \"NULL\");\n\n  if (!imp_dbh->pmysql) {\n     fresh = 1;\n     Newz(908, imp_dbh->pmysql, 1, MYSQL);\n  }\n  result = mysql_dr_connect(dbh, imp_dbh->pmysql, mysql_socket, host, port, user,\n\t\t\t  password, dbname, imp_dbh) ? TRUE : FALSE;\n  if (fresh && !result) {\n      /* Prevent leaks, but do not free in case of a reconnect. See #97625 */\n      do_error(dbh, mysql_errno(imp_dbh->pmysql),\n              mysql_error(imp_dbh->pmysql) ,mysql_sqlstate(imp_dbh->pmysql));\n      Safefree(imp_dbh->pmysql);\n      imp_dbh->pmysql = NULL;\n  }\n  return result;\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos\\2016_8\\a56ae87a4c1c1fead7d09c3653905841ccccf1cc_after\\DBD-mysql-a56ae87a4c1c1fead7d09c3653905841ccccf1cc\\dbdimp.c", "callees": ["DBIc_LOGPIO", "SvROK", "safe_hv_fetch", "SvTYPE", "mysql_error", "mysql_sqlstate", "SvRV", "DBIc_TRACE_LEVEL", "DBIc_ACTIVE_KIDS", "PerlIO_printf", "DBIc_PARENT_COM", "D_imp_xxh", "do_error", "Newz", "mysql_errno", "DBIc_IMP_DATA", "DBIc_has", "Safefree", "mysql_dr_connect"], "callers": ["dbd_db_login"]}, {"name": "dbd_db_login", "content": "int dbd_db_login(SV* dbh, imp_dbh_t* imp_dbh, char* dbname, char* user,\n\t\t char* password) {\n#ifdef dTHR\n  dTHR;\n#endif\n  dTHX; \n  D_imp_xxh(dbh);\n\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n\t\t  \"imp_dbh->connect: dsn = %s, uid = %s, pwd = %s\\n\",\n\t\t  dbname ? dbname : \"NULL\",\n\t\t  user ? user : \"NULL\",\n\t\t  password ? password : \"NULL\");\n\n  imp_dbh->stats.auto_reconnects_ok= 0;\n  imp_dbh->stats.auto_reconnects_failed= 0;\n  imp_dbh->bind_type_guessing= FALSE;\n  imp_dbh->bind_comment_placeholders= FALSE;\n  imp_dbh->has_transactions= TRUE;\n /* Safer we flip this to TRUE perl side if we detect a mod_perl env. */\n  imp_dbh->auto_reconnect = FALSE;\n\n  /* HELMUT */\n#if defined(sv_utf8_decode) && MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION\n  imp_dbh->enable_utf8 = FALSE;  /* initialize mysql_enable_utf8 */\n#endif\n\n  if (!my_login(aTHX_ dbh, imp_dbh))\n  {\n    if(imp_dbh->pmysql)\n        do_error(dbh, mysql_errno(imp_dbh->pmysql),\n                mysql_error(imp_dbh->pmysql) ,mysql_sqlstate(imp_dbh->pmysql));\n    return FALSE;\n  }\n\n    /*\n     *  Tell DBI, that dbh->disconnect should be called for this handle\n     */\n    DBIc_ACTIVE_on(imp_dbh);\n\n    /* Tell DBI, that dbh->destroy should be called for this handle */\n    DBIc_on(imp_dbh, DBIcf_IMPSET);\n\n    return TRUE;\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos\\2016_8\\a56ae87a4c1c1fead7d09c3653905841ccccf1cc_after\\DBD-mysql-a56ae87a4c1c1fead7d09c3653905841ccccf1cc\\dbdimp.c", "callees": ["DBIc_on", "DBIc_TRACE_LEVEL", "do_error", "DBIc_LOGPIO", "mysql_errno", "DBIc_ACTIVE_on", "mysql_error", "my_login", "mysql_sqlstate", "D_imp_xxh", "PerlIO_printf"], "callers": []}], "callerTree_before": {"my_login": ["SvTYPE", "DBIc_IMP_DATA", "DBIc_TRACE_LEVEL", "DBIc_ACTIVE_KIDS", "Newz", "DBIc_LOGPIO", "mysql_dr_connect", "SvROK", "DBIc_PARENT_COM", "SvRV", "safe_hv_fetch", "D_imp_xxh", "DBIc_has", "Safefree", "PerlIO_printf"], "dbd_db_login": ["DBIc_on", "DBIc_TRACE_LEVEL", "do_error", "DBIc_LOGPIO", "mysql_errno", "DBIc_ACTIVE_on", "mysql_error", "my_login", "mysql_sqlstate", "D_imp_xxh", "PerlIO_printf"]}, "calleeTree_before": {"D_imp_xxh": ["my_login", "dbd_db_login"], "DBIc_has": ["my_login"], "DBIc_TRACE_LEVEL": ["my_login", "dbd_db_login"], "PerlIO_printf": ["my_login", "dbd_db_login"], "DBIc_LOGPIO": ["my_login", "dbd_db_login"], "DBIc_ACTIVE_KIDS": ["my_login"], "DBIc_PARENT_COM": ["my_login"], "DBIc_IMP_DATA": ["my_login"], "SvROK": ["my_login"], "SvRV": ["my_login"], "SvTYPE": ["my_login"], "safe_hv_fetch": ["my_login"], "Newz": ["my_login"], "mysql_dr_connect": ["my_login"], "Safefree": ["my_login"], "my_login": ["dbd_db_login"], "do_error": ["dbd_db_login"], "mysql_errno": ["dbd_db_login"], "mysql_error": ["dbd_db_login"], "mysql_sqlstate": ["dbd_db_login"], "DBIc_ACTIVE_on": ["dbd_db_login"], "DBIc_on": ["dbd_db_login"]}, "callerTree_after": {"my_login": ["DBIc_LOGPIO", "SvROK", "safe_hv_fetch", "SvTYPE", "mysql_error", "mysql_sqlstate", "SvRV", "DBIc_TRACE_LEVEL", "DBIc_ACTIVE_KIDS", "PerlIO_printf", "DBIc_PARENT_COM", "D_imp_xxh", "do_error", "Newz", "mysql_errno", "DBIc_IMP_DATA", "DBIc_has", "Safefree", "mysql_dr_connect"], "dbd_db_login": ["DBIc_on", "DBIc_TRACE_LEVEL", "do_error", "DBIc_LOGPIO", "mysql_errno", "DBIc_ACTIVE_on", "mysql_error", "my_login", "mysql_sqlstate", "D_imp_xxh", "PerlIO_printf"]}, "calleeTree_after": {"D_imp_xxh": ["my_login", "dbd_db_login"], "DBIc_has": ["my_login"], "DBIc_TRACE_LEVEL": ["my_login", "dbd_db_login"], "PerlIO_printf": ["my_login", "dbd_db_login"], "DBIc_LOGPIO": ["my_login", "dbd_db_login"], "DBIc_ACTIVE_KIDS": ["my_login"], "DBIc_PARENT_COM": ["my_login"], "DBIc_IMP_DATA": ["my_login"], "SvROK": ["my_login"], "SvRV": ["my_login"], "SvTYPE": ["my_login"], "safe_hv_fetch": ["my_login"], "Newz": ["my_login"], "mysql_dr_connect": ["my_login"], "do_error": ["my_login", "dbd_db_login"], "mysql_errno": ["my_login", "dbd_db_login"], "mysql_error": ["my_login", "dbd_db_login"], "mysql_sqlstate": ["my_login", "dbd_db_login"], "Safefree": ["my_login"], "my_login": ["dbd_db_login"], "DBIc_ACTIVE_on": ["dbd_db_login"], "DBIc_on": ["dbd_db_login"]}}
{"repo_after": "10ef1dca63d62433fda13309b4a228782db823f7", "repo_before": "e6399f5a470f50285cef173e438638ae5bc741e0", "functions_before": [{"name": "gdImageCreateFromTgaCtx", "content": "BGD_DECLARE(gdImagePtr) gdImageCreateFromTgaCtx(gdIOCtx* ctx)\n{\n\tint bitmap_caret = 0;\n\toTga *tga = NULL;\n\t/*\tint pixel_block_size = 0;\n\t\tint image_block_size = 0; */\n\tvolatile gdImagePtr image = NULL;\n\tint x = 0;\n\tint y = 0;\n\n\ttga = (oTga *) gdMalloc(sizeof(oTga));\n\tif (!tga) {\n\t\treturn NULL;\n\t}\n\n\ttga->bitmap = NULL;\n\ttga->ident = NULL;\n\n\tif (read_header_tga(ctx, tga) < 0) {\n\t\tfree_tga(tga);\n\t\treturn NULL;\n\t}\n\n\t/*TODO: Will this be used?\n\t\tpixel_block_size = tga->bits / 8;\n\t\timage_block_size = (tga->width * tga->height) * pixel_block_size;\n\t*/\n\n\tif (read_image_tga(ctx, tga) < 0) {\n\t\tfree_tga(tga);\n\t\treturn NULL;\n\t}\n\n\timage = gdImageCreateTrueColor((int)tga->width, (int)tga->height );\n\n\tif (image == 0) {\n\t\tfree_tga( tga );\n\t\treturn NULL;\n\t}\n\n\t/*!\t\\brief Populate GD image object\n\t *  Copy the pixel data from our tga bitmap buffer into the GD image\n\t *  Disable blending and save the alpha channel per default\n\t */\n\tif (tga->alphabits) {\n\t\tgdImageAlphaBlending(image, 0);\n\t\tgdImageSaveAlpha(image, 1);\n\t}\n\n\t/* TODO: use alphabits as soon as we support 24bit and other alpha bps (ie != 8bits) */\n\tfor (y = 0; y < tga->height; y++) {\n\t\tregister int *tpix = image->tpixels[y];\n\t\tfor ( x = 0; x < tga->width; x++, tpix++) {\n\t\t\tif (tga->bits == TGA_BPP_24) {\n\t\t\t\t*tpix = gdTrueColor(tga->bitmap[bitmap_caret + 2], tga->bitmap[bitmap_caret + 1], tga->bitmap[bitmap_caret]);\n\t\t\t\tbitmap_caret += 3;\n\t\t\t} else if (tga->bits == TGA_BPP_32 || tga->alphabits) {\n\t\t\t\tregister int a = tga->bitmap[bitmap_caret + 3];\n\n\t\t\t\t*tpix = gdTrueColorAlpha(tga->bitmap[bitmap_caret + 2], tga->bitmap[bitmap_caret + 1], tga->bitmap[bitmap_caret], gdAlphaMax - (a >> 1));\n\t\t\t\tbitmap_caret += 4;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (tga->flipv && tga->fliph) {\n\t\tgdImageFlipBoth(image);\n\t} else if (tga->flipv) {\n\t\tgdImageFlipVertical(image);\n\t} else if (tga->fliph) {\n\t\tgdImageFlipHorizontal(image);\n\t}\n\n\tfree_tga(tga);\n\n\treturn image;\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos_before\\2016_8\\e6399f5a470f50285cef173e438638ae5bc741e0_before\\libgd-e6399f5a470f50285cef173e438638ae5bc741e0\\src\\gd_tga.c", "callees": [], "callers": []}, {"name": "read_header_tga", "content": "int read_header_tga(gdIOCtx *ctx, oTga *tga)\n{\n\n\tunsigned char header[18];\n\n\tif (gdGetBuf(header, sizeof(header), ctx) < 18) {\n\t\tgd_error(\"fail to read header\");\n\t\treturn -1;\n\t}\n\n\ttga->identsize = header[0];\n\ttga->colormaptype = header[1];\n\ttga->imagetype = header[2];\n\ttga->colormapstart = header[3] + (header[4] << 8);\n\ttga->colormaplength = header[5] + (header[6] << 8);\n\ttga->colormapbits = header[7];\n\ttga->xstart = header[8] + (header[9] << 8);\n\ttga->ystart = header[10] + (header[11] << 8);\n\ttga->width = header[12] + (header[13] << 8);\n\ttga->height = header[14] + (header[15] << 8);\n\ttga->bits = header[16];\n\ttga->alphabits = header[17] & 0x0f;\n\ttga->fliph = (header[17] & 0x10) ? 1 : 0;\n\ttga->flipv = (header[17] & 0x20) ? 0 : 1;\n\n#if DEBUG\n\tprintf(\"format bps: %i\\n\", tga->bits);\n\tprintf(\"flip h/v: %i / %i\\n\", tga->fliph, tga->flipv);\n\tprintf(\"alpha: %i\\n\", tga->alphabits);\n\tprintf(\"wxh: %i %i\\n\", tga->width, tga->height);\n#endif\n\n\tswitch(tga->bits) {\n\tcase 8:\n\tcase 16:\n\tcase 24:\n\tcase 32:\n\t\tbreak;\n\tdefault:\n\t\tgd_error(\"bps %i not supported\", tga->bits);\n\t\treturn -1;\n\t\tbreak;\n\t}\n\n\ttga->ident = NULL;\n\n\tif (tga->identsize > 0) {\n\t\ttga->ident = (char *) gdMalloc(tga->identsize * sizeof(char));\n\t\tif(tga->ident == NULL) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tgdGetBuf(tga->ident, tga->identsize, ctx);\n\t}\n\n\treturn 1;\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos_before\\2016_8\\e6399f5a470f50285cef173e438638ae5bc741e0_before\\libgd-e6399f5a470f50285cef173e438638ae5bc741e0\\src\\gd_tga.c", "callees": ["gdMalloc", "gdGetBuf", "gd_error", "printf"], "callers": []}], "functions_after": [{"name": "gdImageCreateFromTgaCtx", "content": "BGD_DECLARE(gdImagePtr) gdImageCreateFromTgaCtx(gdIOCtx* ctx)\n{\n\tint bitmap_caret = 0;\n\toTga *tga = NULL;\n\t/*\tint pixel_block_size = 0;\n\t\tint image_block_size = 0; */\n\tvolatile gdImagePtr image = NULL;\n\tint x = 0;\n\tint y = 0;\n\n\ttga = (oTga *) gdMalloc(sizeof(oTga));\n\tif (!tga) {\n\t\treturn NULL;\n\t}\n\n\ttga->bitmap = NULL;\n\ttga->ident = NULL;\n\n\tif (read_header_tga(ctx, tga) < 0) {\n\t\tfree_tga(tga);\n\t\treturn NULL;\n\t}\n\n\t/*TODO: Will this be used?\n\t\tpixel_block_size = tga->bits / 8;\n\t\timage_block_size = (tga->width * tga->height) * pixel_block_size;\n\t*/\n\n\tif (read_image_tga(ctx, tga) < 0) {\n\t\tfree_tga(tga);\n\t\treturn NULL;\n\t}\n\n\timage = gdImageCreateTrueColor((int)tga->width, (int)tga->height );\n\n\tif (image == 0) {\n\t\tfree_tga( tga );\n\t\treturn NULL;\n\t}\n\n\t/*!\t\\brief Populate GD image object\n\t *  Copy the pixel data from our tga bitmap buffer into the GD image\n\t *  Disable blending and save the alpha channel per default\n\t */\n\tif (tga->alphabits) {\n\t\tgdImageAlphaBlending(image, 0);\n\t\tgdImageSaveAlpha(image, 1);\n\t}\n\n\t/* TODO: use alphabits as soon as we support 24bit and other alpha bps (ie != 8bits) */\n\tfor (y = 0; y < tga->height; y++) {\n\t\tregister int *tpix = image->tpixels[y];\n\t\tfor ( x = 0; x < tga->width; x++, tpix++) {\n\t\t\tif (tga->bits == TGA_BPP_24) {\n\t\t\t\t*tpix = gdTrueColor(tga->bitmap[bitmap_caret + 2], tga->bitmap[bitmap_caret + 1], tga->bitmap[bitmap_caret]);\n\t\t\t\tbitmap_caret += 3;\n\t\t\t} else if (tga->bits == TGA_BPP_32 && tga->alphabits) {\n\t\t\t\tregister int a = tga->bitmap[bitmap_caret + 3];\n\n\t\t\t\t*tpix = gdTrueColorAlpha(tga->bitmap[bitmap_caret + 2], tga->bitmap[bitmap_caret + 1], tga->bitmap[bitmap_caret], gdAlphaMax - (a >> 1));\n\t\t\t\tbitmap_caret += 4;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (tga->flipv && tga->fliph) {\n\t\tgdImageFlipBoth(image);\n\t} else if (tga->flipv) {\n\t\tgdImageFlipVertical(image);\n\t} else if (tga->fliph) {\n\t\tgdImageFlipHorizontal(image);\n\t}\n\n\tfree_tga(tga);\n\n\treturn image;\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos\\2016_8\\10ef1dca63d62433fda13309b4a228782db823f7_after\\libgd-10ef1dca63d62433fda13309b4a228782db823f7\\src\\gd_tga.c", "callees": [], "callers": []}, {"name": "read_header_tga", "content": "int read_header_tga(gdIOCtx *ctx, oTga *tga)\n{\n\n\tunsigned char header[18];\n\n\tif (gdGetBuf(header, sizeof(header), ctx) < 18) {\n\t\tgd_error(\"fail to read header\");\n\t\treturn -1;\n\t}\n\n\ttga->identsize = header[0];\n\ttga->colormaptype = header[1];\n\ttga->imagetype = header[2];\n\ttga->colormapstart = header[3] + (header[4] << 8);\n\ttga->colormaplength = header[5] + (header[6] << 8);\n\ttga->colormapbits = header[7];\n\ttga->xstart = header[8] + (header[9] << 8);\n\ttga->ystart = header[10] + (header[11] << 8);\n\ttga->width = header[12] + (header[13] << 8);\n\ttga->height = header[14] + (header[15] << 8);\n\ttga->bits = header[16];\n\ttga->alphabits = header[17] & 0x0f;\n\ttga->fliph = (header[17] & 0x10) ? 1 : 0;\n\ttga->flipv = (header[17] & 0x20) ? 0 : 1;\n\n#if DEBUG\n\tprintf(\"format bps: %i\\n\", tga->bits);\n\tprintf(\"flip h/v: %i / %i\\n\", tga->fliph, tga->flipv);\n\tprintf(\"alpha: %i\\n\", tga->alphabits);\n\tprintf(\"wxh: %i %i\\n\", tga->width, tga->height);\n#endif\n\n\tif (!((tga->bits == TGA_BPP_24 && tga->alphabits == 0)\n\t\t|| (tga->bits == TGA_BPP_32 && tga->alphabits == 8)))\n\t{\n\t\tgd_error_ex(GD_WARNING, \"gd-tga: %u bits per pixel with %u alpha bits not supported\\n\",\n\t\t\ttga->bits, tga->alphabits);\n\t\treturn -1;\n\t}\n\n\ttga->ident = NULL;\n\n\tif (tga->identsize > 0) {\n\t\ttga->ident = (char *) gdMalloc(tga->identsize * sizeof(char));\n\t\tif(tga->ident == NULL) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tgdGetBuf(tga->ident, tga->identsize, ctx);\n\t}\n\n\treturn 1;\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos\\2016_8\\10ef1dca63d62433fda13309b4a228782db823f7_after\\libgd-10ef1dca63d62433fda13309b4a228782db823f7\\src\\gd_tga.c", "callees": ["gdGetBuf", "gd_error", "gdMalloc", "gd_error_ex", "printf"], "callers": []}], "callerTree_before": {"read_header_tga": ["gdMalloc", "gdGetBuf", "gd_error", "printf"]}, "calleeTree_before": {"gdGetBuf": ["read_header_tga"], "gd_error": ["read_header_tga"], "printf": ["read_header_tga"], "gdMalloc": ["read_header_tga"]}, "callerTree_after": {"read_header_tga": ["gdGetBuf", "gd_error", "gdMalloc", "gd_error_ex", "printf"]}, "calleeTree_after": {"gdGetBuf": ["read_header_tga"], "gd_error": ["read_header_tga"], "printf": ["read_header_tga"], "gd_error_ex": ["read_header_tga"], "gdMalloc": ["read_header_tga"]}}
{"repo_after": "1ccfe21e14c4d18336f9da8515cd17db88c3de61", "repo_before": "3fe0a7128bac5000fdcfab888bd2a75ec0c9447d", "functions_before": [{"name": "gdImageCropThreshold", "content": "BGD_DECLARE(gdImagePtr) gdImageCropThreshold(gdImagePtr im, const unsigned int color, const float threshold)\n{\n\tconst int width = gdImageSX(im);\n\tconst int height = gdImageSY(im);\n\n\tint x,y;\n\tint match;\n\tgdRect crop;\n\n\tcrop.x = 0;\n\tcrop.y = 0;\n\tcrop.width = 0;\n\tcrop.height = 0;\n\n\t/* Pierre: crop everything sounds bad */\n\tif (threshold > 100.0) {\n\t\treturn NULL;\n\t}\n\n\t/* TODO: Add gdImageGetRowPtr and works with ptr at the row level\n\t * for the true color and palette images\n\t * new formats will simply work with ptr\n\t */\n\tmatch = 1;\n\tfor (y = 0; match && y < height; y++) {\n\t\tfor (x = 0; match && x < width; x++) {\n\t\t\tmatch = (gdColorMatch(im, color, gdImageGetPixel(im, x,y), threshold)) > 0;\n\t\t}\n\t}\n\n\t/* Pierre\n\t * Nothing to do > bye\n\t * Duplicate the image?\n\t */\n\tif (y == height - 1) {\n\t\treturn NULL;\n\t}\n\n\tcrop.y = y -1;\n\tmatch = 1;\n\tfor (y = height - 1; match && y >= 0; y--) {\n\t\tfor (x = 0; match && x < width; x++) {\n\t\t\tmatch = (gdColorMatch(im, color, gdImageGetPixel(im, x, y), threshold)) > 0;\n\t\t}\n\t}\n\n\tif (y == 0) {\n\t\tcrop.height = height - crop.y + 1;\n\t} else {\n\t\tcrop.height = y - crop.y + 2;\n\t}\n\n\tmatch = 1;\n\tfor (x = 0; match && x < width; x++) {\n\t\tfor (y = 0; match && y < crop.y + crop.height - 1; y++) {\n\t\t\tmatch = (gdColorMatch(im, color, gdImageGetPixel(im, x,y), threshold)) > 0;\n\t\t}\n\t}\n\tcrop.x = x - 1;\n\n\tmatch = 1;\n\tfor (x = width - 1; match && x >= 0; x--) {\n\t\tfor (y = 0; match &&  y < crop.y + crop.height - 1; y++) {\n\t\t\tmatch = (gdColorMatch(im, color, gdImageGetPixel(im, x,y), threshold)) > 0;\n\t\t}\n\t}\n\tcrop.width = x - crop.x + 2;\n\n\treturn gdImageCrop(im, &crop);\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos_before\\2016_8\\3fe0a7128bac5000fdcfab888bd2a75ec0c9447d_before\\libgd-3fe0a7128bac5000fdcfab888bd2a75ec0c9447d\\src\\gd_crop.c", "callees": [], "callers": []}], "functions_after": [{"name": "gdImageCropThreshold", "content": "BGD_DECLARE(gdImagePtr) gdImageCropThreshold(gdImagePtr im, const unsigned int color, const float threshold)\n{\n\tconst int width = gdImageSX(im);\n\tconst int height = gdImageSY(im);\n\n\tint x,y;\n\tint match;\n\tgdRect crop;\n\n\tcrop.x = 0;\n\tcrop.y = 0;\n\tcrop.width = 0;\n\tcrop.height = 0;\n\n\t/* Pierre: crop everything sounds bad */\n\tif (threshold > 100.0) {\n\t\treturn NULL;\n\t}\n\n\tif (color < 0 || (!gdImageTrueColor(im) && color >= gdImageColorsTotal(im))) {\n\t\treturn NULL;\n\t}\n\n\t/* TODO: Add gdImageGetRowPtr and works with ptr at the row level\n\t * for the true color and palette images\n\t * new formats will simply work with ptr\n\t */\n\tmatch = 1;\n\tfor (y = 0; match && y < height; y++) {\n\t\tfor (x = 0; match && x < width; x++) {\n\t\t\tmatch = (gdColorMatch(im, color, gdImageGetPixel(im, x,y), threshold)) > 0;\n\t\t}\n\t}\n\n\t/* Pierre\n\t * Nothing to do > bye\n\t * Duplicate the image?\n\t */\n\tif (y == height - 1) {\n\t\treturn NULL;\n\t}\n\n\tcrop.y = y -1;\n\tmatch = 1;\n\tfor (y = height - 1; match && y >= 0; y--) {\n\t\tfor (x = 0; match && x < width; x++) {\n\t\t\tmatch = (gdColorMatch(im, color, gdImageGetPixel(im, x, y), threshold)) > 0;\n\t\t}\n\t}\n\n\tif (y == 0) {\n\t\tcrop.height = height - crop.y + 1;\n\t} else {\n\t\tcrop.height = y - crop.y + 2;\n\t}\n\n\tmatch = 1;\n\tfor (x = 0; match && x < width; x++) {\n\t\tfor (y = 0; match && y < crop.y + crop.height - 1; y++) {\n\t\t\tmatch = (gdColorMatch(im, color, gdImageGetPixel(im, x,y), threshold)) > 0;\n\t\t}\n\t}\n\tcrop.x = x - 1;\n\n\tmatch = 1;\n\tfor (x = width - 1; match && x >= 0; x--) {\n\t\tfor (y = 0; match &&  y < crop.y + crop.height - 1; y++) {\n\t\t\tmatch = (gdColorMatch(im, color, gdImageGetPixel(im, x,y), threshold)) > 0;\n\t\t}\n\t}\n\tcrop.width = x - crop.x + 2;\n\n\treturn gdImageCrop(im, &crop);\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos\\2016_8\\1ccfe21e14c4d18336f9da8515cd17db88c3de61_after\\libgd-1ccfe21e14c4d18336f9da8515cd17db88c3de61\\src\\gd_crop.c", "callees": [], "callers": []}], "callerTree_before": {"gdGuessBackgroundColorFromCorners": ["gdImageGetPixel", "gdImageBlue", "gdImageSY", "gdImageGreen", "gdImageRed", "gdImageAlpha", "gdImageColorClosestAlpha", "gdImageSX"]}, "calleeTree_before": {"gdImageGetPixel": ["gdGuessBackgroundColorFromCorners"], "gdImageSX": ["gdGuessBackgroundColorFromCorners"], "gdImageSY": ["gdGuessBackgroundColorFromCorners"], "gdImageRed": ["gdGuessBackgroundColorFromCorners"], "gdImageGreen": ["gdGuessBackgroundColorFromCorners"], "gdImageBlue": ["gdGuessBackgroundColorFromCorners"], "gdImageAlpha": ["gdGuessBackgroundColorFromCorners"], "gdImageColorClosestAlpha": ["gdGuessBackgroundColorFromCorners"]}, "callerTree_after": {"gdGuessBackgroundColorFromCorners": ["gdImageGetPixel", "gdImageBlue", "gdImageSY", "gdImageGreen", "gdImageRed", "gdImageAlpha", "gdImageColorClosestAlpha", "gdImageSX"]}, "calleeTree_after": {"gdImageGetPixel": ["gdGuessBackgroundColorFromCorners"], "gdImageSX": ["gdGuessBackgroundColorFromCorners"], "gdImageSY": ["gdGuessBackgroundColorFromCorners"], "gdImageRed": ["gdGuessBackgroundColorFromCorners"], "gdImageGreen": ["gdGuessBackgroundColorFromCorners"], "gdImageBlue": ["gdGuessBackgroundColorFromCorners"], "gdImageAlpha": ["gdGuessBackgroundColorFromCorners"], "gdImageColorClosestAlpha": ["gdGuessBackgroundColorFromCorners"]}}
{"repo_after": "4dc1a2d7931017d3625f2d7cff70a17ce58b53b4", "repo_before": "b083ec17ad9cba4ad9fe7fac1c6a168d90dd1a31", "functions_before": [{"name": "gdCtxPrintf", "content": "static void gdCtxPrintf(gdIOCtx * out, const char *format, ...)\n{\n\tchar buf[4096];\n\tint len;\n\tva_list args;\n\n\tva_start(args, format);\n\tlen = vsnprintf(buf, sizeof(buf)-1, format, args);\n\tva_end(args);\n\tout->putBuf(out, buf, len);\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos_before\\2016_8\\b083ec17ad9cba4ad9fe7fac1c6a168d90dd1a31_before\\libgd-b083ec17ad9cba4ad9fe7fac1c6a168d90dd1a31\\src\\gd_xbm.c", "callees": ["va_end", "vsnprintf", "va_start"], "callers": []}, {"name": "gdImageXbmCtx", "content": "BGD_DECLARE(void) gdImageXbmCtx(gdImagePtr image, char* file_name, int fg, gdIOCtx * out)\n{\n\tint x, y, c, b, sx, sy, p;\n\tchar *name, *f;\n\tsize_t i, l;\n\n\tname = file_name;\n\tif ((f = strrchr(name, '/')) != NULL) name = f+1;\n\tif ((f = strrchr(name, '\\\\')) != NULL) name = f+1;\n\tname = strdup(name);\n\tif ((f = strrchr(name, '.')) != NULL && !strcasecmp(f, \".XBM\")) *f = '\\0';\n\tif ((l = strlen(name)) == 0) {\n\t\tfree(name);\n\t\tname = strdup(\"image\");\n\t} else {\n\t\tfor (i=0; i<l; i++) {\n\t\t\t/* only in C-locale isalnum() would work */\n\t\t\tif (!isupper(name[i]) && !islower(name[i]) && !isdigit(name[i])) {\n\t\t\t\tname[i] = '_';\n\t\t\t}\n\t\t}\n\t}\n\n\tgdCtxPrintf(out, \"#define %s_width %d\\n\", name, gdImageSX(image));\n\tgdCtxPrintf(out, \"#define %s_height %d\\n\", name, gdImageSY(image));\n\tgdCtxPrintf(out, \"static unsigned char %s_bits[] = {\\n  \", name);\n\n\tfree(name);\n\n\tb = 1;\n\tp = 0;\n\tc = 0;\n\tsx = gdImageSX(image);\n\tsy = gdImageSY(image);\n\tfor (y = 0; y < sy; y++) {\n\t\tfor (x = 0; x < sx; x++) {\n\t\t\tif (gdImageGetPixel(image, x, y) == fg) {\n\t\t\t\tc |= b;\n\t\t\t}\n\t\t\tif ((b == 128) || (x == sx && y == sy)) {\n\t\t\t\tb = 1;\n\t\t\t\tif (p) {\n\t\t\t\t\tgdCtxPrintf(out, \", \");\n\t\t\t\t\tif (!(p%12)) {\n\t\t\t\t\t\tgdCtxPrintf(out, \"\\n  \");\n\t\t\t\t\t\tp = 12;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tp++;\n\t\t\t\tgdCtxPrintf(out, \"0x%02X\", c);\n\t\t\t\tc = 0;\n\t\t\t} else {\n\t\t\t\tb <<= 1;\n\t\t\t}\n\t\t}\n\t}\n\tgdCtxPrintf(out, \"};\\n\");\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos_before\\2016_8\\b083ec17ad9cba4ad9fe7fac1c6a168d90dd1a31_before\\libgd-b083ec17ad9cba4ad9fe7fac1c6a168d90dd1a31\\src\\gd_xbm.c", "callees": [], "callers": []}], "functions_after": [{"name": "gdCtxPrintf", "content": "static void gdCtxPrintf(gdIOCtx * out, const char *format, ...)\n{\n\tchar buf[1024];\n\tint len;\n\tva_list args;\n\n\tva_start(args, format);\n\tlen = vsnprintf(buf, sizeof(buf)-1, format, args);\n\tva_end(args);\n\tout->putBuf(out, buf, len);\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos\\2016_8\\4dc1a2d7931017d3625f2d7cff70a17ce58b53b4_after\\libgd-4dc1a2d7931017d3625f2d7cff70a17ce58b53b4\\src\\gd_xbm.c", "callees": ["va_end", "vsnprintf", "va_start"], "callers": []}, {"name": "gdImageXbmCtx", "content": "BGD_DECLARE(void) gdImageXbmCtx(gdImagePtr image, char* file_name, int fg, gdIOCtx * out)\n{\n\tint x, y, c, b, sx, sy, p;\n\tchar *name, *f;\n\tsize_t i, l;\n\n\tname = file_name;\n\tif ((f = strrchr(name, '/')) != NULL) name = f+1;\n\tif ((f = strrchr(name, '\\\\')) != NULL) name = f+1;\n\tname = strdup(name);\n\tif ((f = strrchr(name, '.')) != NULL && !strcasecmp(f, \".XBM\")) *f = '\\0';\n\tif ((l = strlen(name)) == 0) {\n\t\tfree(name);\n\t\tname = strdup(\"image\");\n\t} else {\n\t\tfor (i=0; i<l; i++) {\n\t\t\t/* only in C-locale isalnum() would work */\n\t\t\tif (!isupper(name[i]) && !islower(name[i]) && !isdigit(name[i])) {\n\t\t\t\tname[i] = '_';\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Since \"name\" comes from the user, run it through a direct puts.\n\t * Trying to printf it into a local buffer means we'd need a large\n\t * or dynamic buffer to hold it all. */\n\n\t/* #define <name>_width 1234 */\n\tgdCtxPuts(out, \"#define \");\n\tgdCtxPuts(out, name);\n\tgdCtxPuts(out, \"_width \");\n\tgdCtxPrintf(out, \"%d\\n\", gdImageSX(image));\n\n\t/* #define <name>_height 1234 */\n\tgdCtxPuts(out, \"#define \");\n\tgdCtxPuts(out, name);\n\tgdCtxPuts(out, \"_height \");\n\tgdCtxPrintf(out, \"%d\\n\", gdImageSY(image));\n\n\t/* static unsigned char <name>_bits[] = {\\n */\n\tgdCtxPuts(out, \"static unsigned char \");\n\tgdCtxPuts(out, name);\n\tgdCtxPuts(out, \"_bits[] = {\\n  \");\n\n\tfree(name);\n\n\tb = 1;\n\tp = 0;\n\tc = 0;\n\tsx = gdImageSX(image);\n\tsy = gdImageSY(image);\n\tfor (y = 0; y < sy; y++) {\n\t\tfor (x = 0; x < sx; x++) {\n\t\t\tif (gdImageGetPixel(image, x, y) == fg) {\n\t\t\t\tc |= b;\n\t\t\t}\n\t\t\tif ((b == 128) || (x == sx && y == sy)) {\n\t\t\t\tb = 1;\n\t\t\t\tif (p) {\n\t\t\t\t\tgdCtxPuts(out, \", \");\n\t\t\t\t\tif (!(p%12)) {\n\t\t\t\t\t\tgdCtxPuts(out, \"\\n  \");\n\t\t\t\t\t\tp = 12;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tp++;\n\t\t\t\tgdCtxPrintf(out, \"0x%02X\", c);\n\t\t\t\tc = 0;\n\t\t\t} else {\n\t\t\t\tb <<= 1;\n\t\t\t}\n\t\t}\n\t}\n\tgdCtxPuts(out, \"};\\n\");\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos\\2016_8\\4dc1a2d7931017d3625f2d7cff70a17ce58b53b4_after\\libgd-4dc1a2d7931017d3625f2d7cff70a17ce58b53b4\\src\\gd_xbm.c", "callees": [], "callers": []}], "callerTree_before": {"gdCtxPrintf": ["va_end", "vsnprintf", "va_start"]}, "calleeTree_before": {"va_start": ["gdCtxPrintf"], "vsnprintf": ["gdCtxPrintf"], "va_end": ["gdCtxPrintf"]}, "callerTree_after": {"gdCtxPrintf": ["va_end", "vsnprintf", "va_start"]}, "calleeTree_after": {"va_start": ["gdCtxPrintf"], "vsnprintf": ["gdCtxPrintf"], "va_end": ["gdCtxPrintf"]}}
{"repo_after": "fcd135c9df440bcd2d5870405ad3311743d78d97", "repo_before": "324583e8fb3935690be58790425793df619c6d4d", "functions_before": [{"name": "auth_password", "content": "int\nauth_password(Authctxt *authctxt, const char *password)\n{\n\tstruct passwd * pw = authctxt->pw;\n\tint result, ok = authctxt->valid;\n#if defined(USE_SHADOW) && defined(HAS_SHADOW_EXPIRE)\n\tstatic int expire_checked = 0;\n#endif\n\n#ifndef HAVE_CYGWIN\n\tif (pw->pw_uid == 0 && options.permit_root_login != PERMIT_YES)\n\t\tok = 0;\n#endif\n\tif (*password == '\\0' && options.permit_empty_passwd == 0)\n\t\treturn 0;\n\n#ifdef KRB5\n\tif (options.kerberos_authentication == 1) {\n\t\tint ret = auth_krb5_password(authctxt, password);\n\t\tif (ret == 1 || ret == 0)\n\t\t\treturn ret && ok;\n\t\t/* Fall back to ordinary passwd authentication. */\n\t}\n#endif\n#ifdef HAVE_CYGWIN\n\t{\n\t\tHANDLE hToken = cygwin_logon_user(pw, password);\n\n\t\tif (hToken == INVALID_HANDLE_VALUE)\n\t\t\treturn 0;\n\t\tcygwin_set_impersonation_token(hToken);\n\t\treturn ok;\n\t}\n#endif\n#ifdef USE_PAM\n\tif (options.use_pam)\n\t\treturn (sshpam_auth_passwd(authctxt, password) && ok);\n#endif\n#if defined(USE_SHADOW) && defined(HAS_SHADOW_EXPIRE)\n\tif (!expire_checked) {\n\t\texpire_checked = 1;\n\t\tif (auth_shadow_pwexpired(authctxt))\n\t\t\tauthctxt->force_pwchange = 1;\n\t}\n#endif\n\tresult = sys_auth_passwd(authctxt, password);\n\tif (authctxt->force_pwchange)\n\t\tdisable_forwarding();\n\treturn (result && ok);\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos_before\\2016_8\\324583e8fb3935690be58790425793df619c6d4d_before\\openssh-portable-324583e8fb3935690be58790425793df619c6d4d\\auth-passwd.c", "callees": ["cygwin_logon_user", "auth_krb5_password", "disable_forwarding", "sshpam_auth_passwd", "auth_shadow_pwexpired", "cygwin_set_impersonation_token", "sys_auth_passwd"], "callers": []}], "functions_after": [{"name": "auth_password", "content": "int\nauth_password(Authctxt *authctxt, const char *password)\n{\n\tstruct passwd * pw = authctxt->pw;\n\tint result, ok = authctxt->valid;\n#if defined(USE_SHADOW) && defined(HAS_SHADOW_EXPIRE)\n\tstatic int expire_checked = 0;\n#endif\n\n\tif (strlen(password) > MAX_PASSWORD_LEN)\n\t\treturn 0;\n\n#ifndef HAVE_CYGWIN\n\tif (pw->pw_uid == 0 && options.permit_root_login != PERMIT_YES)\n\t\tok = 0;\n#endif\n\tif (*password == '\\0' && options.permit_empty_passwd == 0)\n\t\treturn 0;\n\n#ifdef KRB5\n\tif (options.kerberos_authentication == 1) {\n\t\tint ret = auth_krb5_password(authctxt, password);\n\t\tif (ret == 1 || ret == 0)\n\t\t\treturn ret && ok;\n\t\t/* Fall back to ordinary passwd authentication. */\n\t}\n#endif\n#ifdef HAVE_CYGWIN\n\t{\n\t\tHANDLE hToken = cygwin_logon_user(pw, password);\n\n\t\tif (hToken == INVALID_HANDLE_VALUE)\n\t\t\treturn 0;\n\t\tcygwin_set_impersonation_token(hToken);\n\t\treturn ok;\n\t}\n#endif\n#ifdef USE_PAM\n\tif (options.use_pam)\n\t\treturn (sshpam_auth_passwd(authctxt, password) && ok);\n#endif\n#if defined(USE_SHADOW) && defined(HAS_SHADOW_EXPIRE)\n\tif (!expire_checked) {\n\t\texpire_checked = 1;\n\t\tif (auth_shadow_pwexpired(authctxt))\n\t\t\tauthctxt->force_pwchange = 1;\n\t}\n#endif\n\tresult = sys_auth_passwd(authctxt, password);\n\tif (authctxt->force_pwchange)\n\t\tdisable_forwarding();\n\treturn (result && ok);\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos\\2016_8\\fcd135c9df440bcd2d5870405ad3311743d78d97_after\\openssh-portable-fcd135c9df440bcd2d5870405ad3311743d78d97\\auth-passwd.c", "callees": ["cygwin_logon_user", "auth_krb5_password", "disable_forwarding", "sshpam_auth_passwd", "auth_shadow_pwexpired", "cygwin_set_impersonation_token", "sys_auth_passwd", "strlen"], "callers": []}], "callerTree_before": {"auth_password": ["cygwin_logon_user", "auth_krb5_password", "disable_forwarding", "sshpam_auth_passwd", "auth_shadow_pwexpired", "cygwin_set_impersonation_token", "sys_auth_passwd"]}, "calleeTree_before": {"auth_krb5_password": ["auth_password"], "cygwin_logon_user": ["auth_password"], "cygwin_set_impersonation_token": ["auth_password"], "sshpam_auth_passwd": ["auth_password"], "auth_shadow_pwexpired": ["auth_password"], "sys_auth_passwd": ["auth_password"], "disable_forwarding": ["auth_password"]}, "callerTree_after": {"auth_password": ["cygwin_logon_user", "auth_krb5_password", "disable_forwarding", "sshpam_auth_passwd", "auth_shadow_pwexpired", "cygwin_set_impersonation_token", "sys_auth_passwd", "strlen"]}, "calleeTree_after": {"strlen": ["auth_password"], "auth_krb5_password": ["auth_password"], "cygwin_logon_user": ["auth_password"], "cygwin_set_impersonation_token": ["auth_password"], "sshpam_auth_passwd": ["auth_password"], "auth_shadow_pwexpired": ["auth_password"], "sys_auth_passwd": ["auth_password"], "disable_forwarding": ["auth_password"]}}
