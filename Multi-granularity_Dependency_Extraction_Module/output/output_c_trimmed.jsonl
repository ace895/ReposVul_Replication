{"function_id": null, "caller": {}, "callee": {}, "function_name": "free_tga"}
{"function_id": null, "caller": {".oshiba_check_file_type": "static bool toshiba_check_file_type(wtap *wth, int *err, char **err_info)\r\n{\r\n\tchar\tbuf[TOSHIBA_LINE_LENGTH];\r\n\tunsigned\ti, reclen, level, line;\r\n\tchar\tbyte;\r\n\r\n\tbuf[TOSHIBA_LINE_LENGTH-1] = 0;\r\n\r\n\tfor (line = 0; line < TOSHIBA_HEADER_LINES_TO_CHECK; line++) {\r\n\t\tif (file_gets(buf, TOSHIBA_LINE_LENGTH, wth->fh) == NULL) {\r\n\t\t\t/* EOF or error. */\r\n\t\t\t*err = file_error(wth->fh, err_info);\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\treclen = (unsigned) strlen(buf);\r\n\t\tif (reclen < TOSHIBA_HDR_MAGIC_SIZE) {\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\tlevel = 0;\r\n\t\tfor (i = 0; i < reclen; i++) {\r\n\t\t\tbyte = buf[i];\r\n\t\t\tif (byte == toshiba_hdr_magic[level]) {\r\n\t\t\t\tlevel++;\r\n\t\t\t\tif (level >= TOSHIBA_HDR_MAGIC_SIZE) {\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tlevel = 0;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t*err = 0;\r\n\treturn false;\r\n}", ".oshiba_read": "static bool toshiba_read(wtap *wth, wtap_rec *rec, int *err,\r\n\tchar **err_info, int64_t *data_offset)\r\n{\r\n\tint64_t\toffset;\r\n\r\n\t/* Find the next packet */\r\n\toffset = toshiba_seek_next_packet(wth, err, err_info);\r\n\tif (offset < 1)\r\n\t\treturn false;\r\n\t*data_offset = offset;\r\n\r\n\t/* Parse the packet */\r\n\treturn parse_toshiba_packet(wth->fh, rec, err, err_info);\r\n}", ".oshiba_seek_read": "static bool\r\ntoshiba_seek_read(wtap *wth, int64_t seek_off, wtap_rec *rec, int *err,\r\n\tchar **err_info)\r\n{\r\n\tif (file_seek(wth->random_fh, seek_off - 1, SEEK_SET, err) == -1)\r\n\t\treturn false;\r\n\r\n\tif (!parse_toshiba_packet(wth->random_fh, rec, err, err_info)) {\r\n\t\tif (*err == 0)\r\n\t\t\t*err = WTAP_ERR_SHORT_READ;\r\n\t\treturn false;\r\n\t}\r\n\treturn true;\r\n}", ".oshiba_seek_next_packet": "static int64_t toshiba_seek_next_packet(wtap *wth, int *err, char **err_info)\r\n{\r\n\tint byte;\r\n\tunsigned level = 0;\r\n\tint64_t cur_off;\r\n\r\n\twhile ((byte = file_getc(wth->fh)) != EOF) {\r\n\t\tif (byte == toshiba_rec_magic[level]) {\r\n\t\t\tlevel++;\r\n\t\t\tif (level >= TOSHIBA_REC_MAGIC_SIZE) {\r\n\t\t\t\t/* note: we're leaving file pointer right after the magic characters */\r\n\t\t\t\tcur_off = file_tell(wth->fh);\r\n\t\t\t\tif (cur_off == -1) {\r\n\t\t\t\t\t/* Error. */\r\n\t\t\t\t\t*err = file_error(wth->fh, err_info);\r\n\t\t\t\t\treturn -1;\r\n\t\t\t\t}\r\n\t\t\t\treturn cur_off + 1;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tlevel = 0;\r\n\t\t}\r\n\t}\r\n\t/* EOF or error. */\r\n\t*err = file_error(wth->fh, err_info);\r\n\treturn -1;\r\n}", ".arse_toshiba_packet": "static bool\r\nparse_toshiba_packet(FILE_T fh, wtap_rec *rec, int *err, char **err_info)\r\n{\r\n\tunion wtap_pseudo_header *pseudo_header = &rec->rec_header.packet_header.pseudo_header;\r\n\tchar\tline[TOSHIBA_LINE_LENGTH];\r\n\tint\tnum_items_scanned;\r\n\tint\tpkt_len, pktnum, hr, min, sec, csec;\r\n\tchar\tchannel[10], direction[10];\r\n\tint\ti, hex_lines;\r\n\tuint8_t\t*pd;\r\n\r\n\t/* Our file pointer should be on the line containing the\r\n\t * summary information for a packet. Read in that line and\r\n\t * extract the useful information\r\n\t */\r\n\tif (file_gets(line, TOSHIBA_LINE_LENGTH, fh) == NULL) {\r\n\t\t*err = file_error(fh, err_info);\r\n\t\tif (*err == 0) {\r\n\t\t\t*err = WTAP_ERR_SHORT_READ;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\t/* Find text in line after \"[No.\". Limit the length of the\r\n\t * two strings since we have fixed buffers for channel[] and\r\n\t * direction[] */\r\n\tnum_items_scanned = sscanf(line, \"%9d] %2d:%2d:%2d.%9d %9s %9s\",\r\n\t\t\t&pktnum, &hr, &min, &sec, &csec, channel, direction);\r\n\r\n\tif (num_items_scanned != 7) {\r\n\t\t*err = WTAP_ERR_BAD_FILE;\r\n\t\t*err_info = g_strdup(\"toshiba: record header isn't valid\");\r\n\t\treturn false;\r\n\t}\r\n\r\n\t/* Scan lines until we find the OFFSET line. In a \"telnet\" trace,\r\n\t * this will be the next line. But if you save your telnet session\r\n\t * to a file from within a Windows-based telnet client, it may\r\n\t * put in line breaks at 80 columns (or however big your \"telnet\" box\r\n\t * is). CRT (a Windows telnet app from VanDyke) does this.\r\n\t * Here we assume that 80 columns will be the minimum size, and that\r\n\t * the OFFSET line is not broken in the middle. It's the previous\r\n\t * line that is normally long and can thus be broken at column 80.\r\n\t */\r\n\tdo {\r\n\t\tif (file_gets(line, TOSHIBA_LINE_LENGTH, fh) == NULL) {\r\n\t\t\t*err = file_error(fh, err_info);\r\n\t\t\tif (*err == 0) {\r\n\t\t\t\t*err = WTAP_ERR_SHORT_READ;\r\n\t\t\t}\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\t/* Check for \"OFFSET 0001-0203\" at beginning of line */\r\n\t\tline[16] = '\\0';\r\n\r\n\t} while (strcmp(line, \"OFFSET 0001-0203\") != 0);\r\n\r\n\tnum_items_scanned = sscanf(line+64, \"LEN=%9d\", &pkt_len);\r\n\tif (num_items_scanned != 1) {\r\n\t\t*err = WTAP_ERR_BAD_FILE;\r\n\t\t*err_info = g_strdup(\"toshiba: OFFSET line doesn't have valid LEN item\");\r\n\t\treturn false;\r\n\t}\r\n\tif (pkt_len < 0) {\r\n\t\t*err = WTAP_ERR_BAD_FILE;\r\n\t\t*err_info = g_strdup(\"toshiba: packet header has a negative packet length\");\r\n\t\treturn false;\r\n\t}\r\n\tif ((unsigned)pkt_len > WTAP_MAX_PACKET_SIZE_STANDARD) {\r\n\t\t/*\r\n\t\t * Probably a corrupt capture file; don't blow up trying\r\n\t\t * to allocate space for an immensely-large packet.\r\n\t\t */\r\n\t\t*err = WTAP_ERR_BAD_FILE;\r\n\t\t*err_info = ws_strdup_printf(\"toshiba: File has %u-byte packet, bigger than maximum of %u\",\r\n\t\t    (unsigned)pkt_len, WTAP_MAX_PACKET_SIZE_STANDARD);\r\n\t\treturn false;\r\n\t}\r\n\r\n\twtap_setup_packet_rec(rec, WTAP_ENCAP_UNKNOWN);\r\n\trec->block = wtap_block_create(WTAP_BLOCK_PACKET);\r\n\trec->presence_flags = WTAP_HAS_TS|WTAP_HAS_CAP_LEN;\r\n\trec->ts.secs = hr * 3600 + min * 60 + sec;\r\n\trec->ts.nsecs = csec * 10000000;\r\n\trec->rec_header.packet_header.caplen = pkt_len;\r\n\trec->rec_header.packet_header.len = pkt_len;\r\n\r\n\tswitch (channel[0]) {\r\n\t\tcase 'B':\r\n\t\t\trec->rec_header.packet_header.pkt_encap = WTAP_ENCAP_ISDN;\r\n\t\t\tpseudo_header->isdn.uton = (direction[0] == 'T');\r\n\t\t\tpseudo_header->isdn.channel = (uint8_t)\r\n\t\t\t    strtol(&channel[1], NULL, 10);\r\n\t\t\tbreak;\r\n\r\n\t\tcase 'D':\r\n\t\t\trec->rec_header.packet_header.pkt_encap = WTAP_ENCAP_ISDN;\r\n\t\t\tpseudo_header->isdn.uton = (direction[0] == 'T');\r\n\t\t\tpseudo_header->isdn.channel = 0;\r\n\t\t\tbreak;\r\n\r\n\t\tdefault:\r\n\t\t\trec->rec_header.packet_header.pkt_encap = WTAP_ENCAP_ETHERNET;\r\n\t\t\t/* XXX - is there an FCS in the frame? */\r\n\t\t\tpseudo_header->eth.fcs_len = -1;\r\n\t\t\tbreak;\r\n\t}\r\n\r\n\t/* Make sure we have enough room for the packet */\r\n\tws_buffer_assure_space(&rec->data, pkt_len);\r\n\tpd = ws_buffer_start_ptr(&rec->data);\r\n\r\n\t/* Calculate the number of hex dump lines, each\r\n\t * containing 16 bytes of data */\r\n\thex_lines = pkt_len / 16 + ((pkt_len % 16) ? 1 : 0);\r\n\r\n\tfor (i = 0; i < hex_lines; i++) {\r\n\t\tif (file_gets(line, TOSHIBA_LINE_LENGTH, fh) == NULL) {\r\n\t\t\t*err = file_error(fh, err_info);\r\n\t\t\tif (*err == 0) {\r\n\t\t\t\t*err = WTAP_ERR_SHORT_READ;\r\n\t\t\t}\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tif (!parse_single_hex_dump_line(line, pd, i * 16)) {\r\n\t\t\t*err = WTAP_ERR_BAD_FILE;\r\n\t\t\t*err_info = g_strdup(\"toshiba: hex dump not valid\");\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\treturn true;\r\n}", ".arse_single_hex_dump_line": "static bool\r\nparse_single_hex_dump_line(char* rec, uint8_t *buf, unsigned byte_offset) {\r\n\r\n\tint\t\tpos, i;\r\n\tchar\t\t*s;\r\n\tunsigned long\tvalue;\r\n\tuint16_t\t\tword_value;\r\n\r\n\t/* Get the byte_offset directly from the record */\r\n\trec[4] = '\\0';\r\n\ts = rec;\r\n\tvalue = strtoul(s, NULL, 16);\r\n\r\n\tif (value != byte_offset) {\r\n\t\treturn false;\r\n\t}\r\n\r\n\t/* Go through the substring representing the values and:\r\n\t *      1. Replace any spaces with '0's\r\n\t *      2. Place \\0's every 5 bytes (to terminate the string)\r\n\t *\r\n\t * Then read the eight sets of hex bytes\r\n\t */\r\n\r\n\tfor (pos = START_POS; pos < START_POS + HEX_LENGTH; pos++) {\r\n\t\tif (rec[pos] == ' ') {\r\n\t\t\trec[pos] = '0';\r\n\t\t}\r\n\t}\r\n\r\n\tpos = START_POS;\r\n\tfor (i = 0; i < 8; i++) {\r\n\t\trec[pos+4] = '\\0';\r\n\r\n\t\tword_value = (uint16_t) strtoul(&rec[pos], NULL, 16);\r\n\t\tphtonu16(&buf[byte_offset + i * 2], word_value);\r\n\t\tpos += 5;\r\n\t}\r\n\r\n\treturn true;\r\n}"}, "callee": {".oshiba_read": "static bool toshiba_read(wtap *wth, wtap_rec *rec, int *err,\r\n\tchar **err_info, int64_t *data_offset)\r\n{\r\n\tint64_t\toffset;\r\n\r\n\t/* Find the next packet */\r\n\toffset = toshiba_seek_next_packet(wth, err, err_info);\r\n\tif (offset < 1)\r\n\t\treturn false;\r\n\t*data_offset = offset;\r\n\r\n\t/* Parse the packet */\r\n\treturn parse_toshiba_packet(wth->fh, rec, err, err_info);\r\n}", ".oshiba_open": "wtap_open_return_val toshiba_open(wtap *wth, int *err, char **err_info)\r\n{\r\n\t/* Look for Toshiba header */\r\n\tif (!toshiba_check_file_type(wth, err, err_info)) {\r\n\t\tif (*err != 0 && *err != WTAP_ERR_SHORT_READ)\r\n\t\t\treturn WTAP_OPEN_ERROR;\r\n\t\treturn WTAP_OPEN_NOT_MINE;\r\n\t}\r\n\r\n\twth->file_encap = WTAP_ENCAP_PER_PACKET;\r\n\twth->file_type_subtype = toshiba_file_type_subtype;\r\n\twth->snapshot_length = 0; /* not known */\r\n\twth->subtype_read = toshiba_read;\r\n\twth->subtype_seek_read = toshiba_seek_read;\r\n\twth->file_tsprec = WTAP_TSPREC_10_MSEC;\r\n\r\n\treturn WTAP_OPEN_MINE;\r\n}", ".oshiba_seek_read": "static bool\r\ntoshiba_seek_read(wtap *wth, int64_t seek_off, wtap_rec *rec, int *err,\r\n\tchar **err_info)\r\n{\r\n\tif (file_seek(wth->random_fh, seek_off - 1, SEEK_SET, err) == -1)\r\n\t\treturn false;\r\n\r\n\tif (!parse_toshiba_packet(wth->random_fh, rec, err, err_info)) {\r\n\t\tif (*err == 0)\r\n\t\t\t*err = WTAP_ERR_SHORT_READ;\r\n\t\treturn false;\r\n\t}\r\n\treturn true;\r\n}", ".arse_toshiba_packet": "static bool\r\nparse_toshiba_packet(FILE_T fh, wtap_rec *rec, int *err, char **err_info)\r\n{\r\n\tunion wtap_pseudo_header *pseudo_header = &rec->rec_header.packet_header.pseudo_header;\r\n\tchar\tline[TOSHIBA_LINE_LENGTH];\r\n\tint\tnum_items_scanned;\r\n\tint\tpkt_len, pktnum, hr, min, sec, csec;\r\n\tchar\tchannel[10], direction[10];\r\n\tint\ti, hex_lines;\r\n\tuint8_t\t*pd;\r\n\r\n\t/* Our file pointer should be on the line containing the\r\n\t * summary information for a packet. Read in that line and\r\n\t * extract the useful information\r\n\t */\r\n\tif (file_gets(line, TOSHIBA_LINE_LENGTH, fh) == NULL) {\r\n\t\t*err = file_error(fh, err_info);\r\n\t\tif (*err == 0) {\r\n\t\t\t*err = WTAP_ERR_SHORT_READ;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\t/* Find text in line after \"[No.\". Limit the length of the\r\n\t * two strings since we have fixed buffers for channel[] and\r\n\t * direction[] */\r\n\tnum_items_scanned = sscanf(line, \"%9d] %2d:%2d:%2d.%9d %9s %9s\",\r\n\t\t\t&pktnum, &hr, &min, &sec, &csec, channel, direction);\r\n\r\n\tif (num_items_scanned != 7) {\r\n\t\t*err = WTAP_ERR_BAD_FILE;\r\n\t\t*err_info = g_strdup(\"toshiba: record header isn't valid\");\r\n\t\treturn false;\r\n\t}\r\n\r\n\t/* Scan lines until we find the OFFSET line. In a \"telnet\" trace,\r\n\t * this will be the next line. But if you save your telnet session\r\n\t * to a file from within a Windows-based telnet client, it may\r\n\t * put in line breaks at 80 columns (or however big your \"telnet\" box\r\n\t * is). CRT (a Windows telnet app from VanDyke) does this.\r\n\t * Here we assume that 80 columns will be the minimum size, and that\r\n\t * the OFFSET line is not broken in the middle. It's the previous\r\n\t * line that is normally long and can thus be broken at column 80.\r\n\t */\r\n\tdo {\r\n\t\tif (file_gets(line, TOSHIBA_LINE_LENGTH, fh) == NULL) {\r\n\t\t\t*err = file_error(fh, err_info);\r\n\t\t\tif (*err == 0) {\r\n\t\t\t\t*err = WTAP_ERR_SHORT_READ;\r\n\t\t\t}\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\t/* Check for \"OFFSET 0001-0203\" at beginning of line */\r\n\t\tline[16] = '\\0';\r\n\r\n\t} while (strcmp(line, \"OFFSET 0001-0203\") != 0);\r\n\r\n\tnum_items_scanned = sscanf(line+64, \"LEN=%9d\", &pkt_len);\r\n\tif (num_items_scanned != 1) {\r\n\t\t*err = WTAP_ERR_BAD_FILE;\r\n\t\t*err_info = g_strdup(\"toshiba: OFFSET line doesn't have valid LEN item\");\r\n\t\treturn false;\r\n\t}\r\n\tif (pkt_len < 0) {\r\n\t\t*err = WTAP_ERR_BAD_FILE;\r\n\t\t*err_info = g_strdup(\"toshiba: packet header has a negative packet length\");\r\n\t\treturn false;\r\n\t}\r\n\tif ((unsigned)pkt_len > WTAP_MAX_PACKET_SIZE_STANDARD) {\r\n\t\t/*\r\n\t\t * Probably a corrupt capture file; don't blow up trying\r\n\t\t * to allocate space for an immensely-large packet.\r\n\t\t */\r\n\t\t*err = WTAP_ERR_BAD_FILE;\r\n\t\t*err_info = ws_strdup_printf(\"toshiba: File has %u-byte packet, bigger than maximum of %u\",\r\n\t\t    (unsigned)pkt_len, WTAP_MAX_PACKET_SIZE_STANDARD);\r\n\t\treturn false;\r\n\t}\r\n\r\n\twtap_setup_packet_rec(rec, WTAP_ENCAP_UNKNOWN);\r\n\trec->block = wtap_block_create(WTAP_BLOCK_PACKET);\r\n\trec->presence_flags = WTAP_HAS_TS|WTAP_HAS_CAP_LEN;\r\n\trec->ts.secs = hr * 3600 + min * 60 + sec;\r\n\trec->ts.nsecs = csec * 10000000;\r\n\trec->rec_header.packet_header.caplen = pkt_len;\r\n\trec->rec_header.packet_header.len = pkt_len;\r\n\r\n\tswitch (channel[0]) {\r\n\t\tcase 'B':\r\n\t\t\trec->rec_header.packet_header.pkt_encap = WTAP_ENCAP_ISDN;\r\n\t\t\tpseudo_header->isdn.uton = (direction[0] == 'T');\r\n\t\t\tpseudo_header->isdn.channel = (uint8_t)\r\n\t\t\t    strtol(&channel[1], NULL, 10);\r\n\t\t\tbreak;\r\n\r\n\t\tcase 'D':\r\n\t\t\trec->rec_header.packet_header.pkt_encap = WTAP_ENCAP_ISDN;\r\n\t\t\tpseudo_header->isdn.uton = (direction[0] == 'T');\r\n\t\t\tpseudo_header->isdn.channel = 0;\r\n\t\t\tbreak;\r\n\r\n\t\tdefault:\r\n\t\t\trec->rec_header.packet_header.pkt_encap = WTAP_ENCAP_ETHERNET;\r\n\t\t\t/* XXX - is there an FCS in the frame? */\r\n\t\t\tpseudo_header->eth.fcs_len = -1;\r\n\t\t\tbreak;\r\n\t}\r\n\r\n\t/* Make sure we have enough room for the packet */\r\n\tws_buffer_assure_space(&rec->data, pkt_len);\r\n\tpd = ws_buffer_start_ptr(&rec->data);\r\n\r\n\t/* Calculate the number of hex dump lines, each\r\n\t * containing 16 bytes of data */\r\n\thex_lines = pkt_len / 16 + ((pkt_len % 16) ? 1 : 0);\r\n\r\n\tfor (i = 0; i < hex_lines; i++) {\r\n\t\tif (file_gets(line, TOSHIBA_LINE_LENGTH, fh) == NULL) {\r\n\t\t\t*err = file_error(fh, err_info);\r\n\t\t\tif (*err == 0) {\r\n\t\t\t\t*err = WTAP_ERR_SHORT_READ;\r\n\t\t\t}\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tif (!parse_single_hex_dump_line(line, pd, i * 16)) {\r\n\t\t\t*err = WTAP_ERR_BAD_FILE;\r\n\t\t\t*err_info = g_strdup(\"toshiba: hex dump not valid\");\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\treturn true;\r\n}"}, "function_name": "register_toshiba"}
{"function_id": null, "caller": {".oshiba_check_file_type": "static bool toshiba_check_file_type(wtap *wth, int *err, char **err_info)\r\n{\r\n\tchar\tbuf[TOSHIBA_LINE_LENGTH];\r\n\tunsigned\ti, reclen, level, line;\r\n\tchar\tbyte;\r\n\r\n\tbuf[TOSHIBA_LINE_LENGTH-1] = 0;\r\n\r\n\tfor (line = 0; line < TOSHIBA_HEADER_LINES_TO_CHECK; line++) {\r\n\t\tif (file_gets(buf, TOSHIBA_LINE_LENGTH, wth->fh) == NULL) {\r\n\t\t\t/* EOF or error. */\r\n\t\t\t*err = file_error(wth->fh, err_info);\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\treclen = (unsigned) strlen(buf);\r\n\t\tif (reclen < TOSHIBA_HDR_MAGIC_SIZE) {\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\tlevel = 0;\r\n\t\tfor (i = 0; i < reclen; i++) {\r\n\t\t\tbyte = buf[i];\r\n\t\t\tif (byte == toshiba_hdr_magic[level]) {\r\n\t\t\t\tlevel++;\r\n\t\t\t\tif (level >= TOSHIBA_HDR_MAGIC_SIZE) {\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tlevel = 0;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t*err = 0;\r\n\treturn false;\r\n}", ".oshiba_read": "static bool toshiba_read(wtap *wth, wtap_rec *rec, int *err,\r\n\tchar **err_info, int64_t *data_offset)\r\n{\r\n\tint64_t\toffset;\r\n\r\n\t/* Find the next packet */\r\n\toffset = toshiba_seek_next_packet(wth, err, err_info);\r\n\tif (offset < 1)\r\n\t\treturn false;\r\n\t*data_offset = offset;\r\n\r\n\t/* Parse the packet */\r\n\treturn parse_toshiba_packet(wth->fh, rec, err, err_info);\r\n}", ".oshiba_seek_read": "static bool\r\ntoshiba_seek_read(wtap *wth, int64_t seek_off, wtap_rec *rec, int *err,\r\n\tchar **err_info)\r\n{\r\n\tif (file_seek(wth->random_fh, seek_off - 1, SEEK_SET, err) == -1)\r\n\t\treturn false;\r\n\r\n\tif (!parse_toshiba_packet(wth->random_fh, rec, err, err_info)) {\r\n\t\tif (*err == 0)\r\n\t\t\t*err = WTAP_ERR_SHORT_READ;\r\n\t\treturn false;\r\n\t}\r\n\treturn true;\r\n}", ".oshiba_seek_next_packet": "static int64_t toshiba_seek_next_packet(wtap *wth, int *err, char **err_info)\r\n{\r\n\tint byte;\r\n\tunsigned level = 0;\r\n\tint64_t cur_off;\r\n\r\n\twhile ((byte = file_getc(wth->fh)) != EOF) {\r\n\t\tif (byte == toshiba_rec_magic[level]) {\r\n\t\t\tlevel++;\r\n\t\t\tif (level >= TOSHIBA_REC_MAGIC_SIZE) {\r\n\t\t\t\t/* note: we're leaving file pointer right after the magic characters */\r\n\t\t\t\tcur_off = file_tell(wth->fh);\r\n\t\t\t\tif (cur_off == -1) {\r\n\t\t\t\t\t/* Error. */\r\n\t\t\t\t\t*err = file_error(wth->fh, err_info);\r\n\t\t\t\t\treturn -1;\r\n\t\t\t\t}\r\n\t\t\t\treturn cur_off + 1;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tlevel = 0;\r\n\t\t}\r\n\t}\r\n\t/* EOF or error. */\r\n\t*err = file_error(wth->fh, err_info);\r\n\treturn -1;\r\n}", ".arse_toshiba_packet": "static bool\r\nparse_toshiba_packet(FILE_T fh, wtap_rec *rec, int *err, char **err_info)\r\n{\r\n\tunion wtap_pseudo_header *pseudo_header = &rec->rec_header.packet_header.pseudo_header;\r\n\tchar\tline[TOSHIBA_LINE_LENGTH];\r\n\tint\tnum_items_scanned;\r\n\tint\tpkt_len, pktnum, hr, min, sec, csec;\r\n\tchar\tchannel[10], direction[10];\r\n\tint\ti, hex_lines;\r\n\tuint8_t\t*pd;\r\n\r\n\t/* Our file pointer should be on the line containing the\r\n\t * summary information for a packet. Read in that line and\r\n\t * extract the useful information\r\n\t */\r\n\tif (file_gets(line, TOSHIBA_LINE_LENGTH, fh) == NULL) {\r\n\t\t*err = file_error(fh, err_info);\r\n\t\tif (*err == 0) {\r\n\t\t\t*err = WTAP_ERR_SHORT_READ;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\t/* Find text in line after \"[No.\". Limit the length of the\r\n\t * two strings since we have fixed buffers for channel[] and\r\n\t * direction[] */\r\n\tnum_items_scanned = sscanf(line, \"%9d] %2d:%2d:%2d.%9d %9s %9s\",\r\n\t\t\t&pktnum, &hr, &min, &sec, &csec, channel, direction);\r\n\r\n\tif (num_items_scanned != 7) {\r\n\t\t*err = WTAP_ERR_BAD_FILE;\r\n\t\t*err_info = g_strdup(\"toshiba: record header isn't valid\");\r\n\t\treturn false;\r\n\t}\r\n\r\n\t/* Scan lines until we find the OFFSET line. In a \"telnet\" trace,\r\n\t * this will be the next line. But if you save your telnet session\r\n\t * to a file from within a Windows-based telnet client, it may\r\n\t * put in line breaks at 80 columns (or however big your \"telnet\" box\r\n\t * is). CRT (a Windows telnet app from VanDyke) does this.\r\n\t * Here we assume that 80 columns will be the minimum size, and that\r\n\t * the OFFSET line is not broken in the middle. It's the previous\r\n\t * line that is normally long and can thus be broken at column 80.\r\n\t */\r\n\tdo {\r\n\t\tif (file_gets(line, TOSHIBA_LINE_LENGTH, fh) == NULL) {\r\n\t\t\t*err = file_error(fh, err_info);\r\n\t\t\tif (*err == 0) {\r\n\t\t\t\t*err = WTAP_ERR_SHORT_READ;\r\n\t\t\t}\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\t/* Check for \"OFFSET 0001-0203\" at beginning of line */\r\n\t\tline[16] = '\\0';\r\n\r\n\t} while (strcmp(line, \"OFFSET 0001-0203\") != 0);\r\n\r\n\tnum_items_scanned = sscanf(line+64, \"LEN=%9d\", &pkt_len);\r\n\tif (num_items_scanned != 1) {\r\n\t\t*err = WTAP_ERR_BAD_FILE;\r\n\t\t*err_info = g_strdup(\"toshiba: OFFSET line doesn't have valid LEN item\");\r\n\t\treturn false;\r\n\t}\r\n\tif (pkt_len < 0) {\r\n\t\t*err = WTAP_ERR_BAD_FILE;\r\n\t\t*err_info = g_strdup(\"toshiba: packet header has a negative packet length\");\r\n\t\treturn false;\r\n\t}\r\n\tif ((unsigned)pkt_len > WTAP_MAX_PACKET_SIZE_STANDARD) {\r\n\t\t/*\r\n\t\t * Probably a corrupt capture file; don't blow up trying\r\n\t\t * to allocate space for an immensely-large packet.\r\n\t\t */\r\n\t\t*err = WTAP_ERR_BAD_FILE;\r\n\t\t*err_info = ws_strdup_printf(\"toshiba: File has %u-byte packet, bigger than maximum of %u\",\r\n\t\t    (unsigned)pkt_len, WTAP_MAX_PACKET_SIZE_STANDARD);\r\n\t\treturn false;\r\n\t}\r\n\r\n\twtap_setup_packet_rec(rec, WTAP_ENCAP_UNKNOWN);\r\n\trec->block = wtap_block_create(WTAP_BLOCK_PACKET);\r\n\trec->presence_flags = WTAP_HAS_TS|WTAP_HAS_CAP_LEN;\r\n\trec->ts.secs = hr * 3600 + min * 60 + sec;\r\n\trec->ts.nsecs = csec * 10000000;\r\n\trec->rec_header.packet_header.caplen = pkt_len;\r\n\trec->rec_header.packet_header.len = pkt_len;\r\n\r\n\tswitch (channel[0]) {\r\n\t\tcase 'B':\r\n\t\t\trec->rec_header.packet_header.pkt_encap = WTAP_ENCAP_ISDN;\r\n\t\t\tpseudo_header->isdn.uton = (direction[0] == 'T');\r\n\t\t\tpseudo_header->isdn.channel = (uint8_t)\r\n\t\t\t    strtol(&channel[1], NULL, 10);\r\n\t\t\tbreak;\r\n\r\n\t\tcase 'D':\r\n\t\t\trec->rec_header.packet_header.pkt_encap = WTAP_ENCAP_ISDN;\r\n\t\t\tpseudo_header->isdn.uton = (direction[0] == 'T');\r\n\t\t\tpseudo_header->isdn.channel = 0;\r\n\t\t\tbreak;\r\n\r\n\t\tdefault:\r\n\t\t\trec->rec_header.packet_header.pkt_encap = WTAP_ENCAP_ETHERNET;\r\n\t\t\t/* XXX - is there an FCS in the frame? */\r\n\t\t\tpseudo_header->eth.fcs_len = -1;\r\n\t\t\tbreak;\r\n\t}\r\n\r\n\t/* Make sure we have enough room for the packet */\r\n\tws_buffer_assure_space(&rec->data, pkt_len);\r\n\tpd = ws_buffer_start_ptr(&rec->data);\r\n\r\n\t/* Calculate the number of hex dump lines, each\r\n\t * containing 16 bytes of data */\r\n\thex_lines = pkt_len / 16 + ((pkt_len % 16) ? 1 : 0);\r\n\r\n\tfor (i = 0; i < hex_lines; i++) {\r\n\t\tif (file_gets(line, TOSHIBA_LINE_LENGTH, fh) == NULL) {\r\n\t\t\t*err = file_error(fh, err_info);\r\n\t\t\tif (*err == 0) {\r\n\t\t\t\t*err = WTAP_ERR_SHORT_READ;\r\n\t\t\t}\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tif (!parse_single_hex_dump_line(line, pd, i * 16)) {\r\n\t\t\t*err = WTAP_ERR_BAD_FILE;\r\n\t\t\t*err_info = g_strdup(\"toshiba: hex dump not valid\");\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\treturn true;\r\n}", ".arse_single_hex_dump_line": "static bool\r\nparse_single_hex_dump_line(char* rec, uint8_t *buf, unsigned byte_offset) {\r\n\r\n\tint\t\tpos, i;\r\n\tchar\t\t*s;\r\n\tunsigned long\tvalue;\r\n\tuint16_t\t\tword_value;\r\n\r\n\t/* Get the byte_offset directly from the record */\r\n\trec[4] = '\\0';\r\n\ts = rec;\r\n\tvalue = strtoul(s, NULL, 16);\r\n\r\n\tif (value != byte_offset) {\r\n\t\treturn false;\r\n\t}\r\n\r\n\t/* Go through the substring representing the values and:\r\n\t *      1. Replace any spaces with '0's\r\n\t *      2. Place \\0's every 5 bytes (to terminate the string)\r\n\t *\r\n\t * Then read the eight sets of hex bytes\r\n\t */\r\n\r\n\tfor (pos = START_POS; pos < START_POS + HEX_LENGTH; pos++) {\r\n\t\tif (rec[pos] == ' ') {\r\n\t\t\trec[pos] = '0';\r\n\t\t}\r\n\t}\r\n\r\n\tpos = START_POS;\r\n\tfor (i = 0; i < 8; i++) {\r\n\t\trec[pos+4] = '\\0';\r\n\r\n\t\tword_value = (uint16_t) strtoul(&rec[pos], NULL, 16);\r\n\t\tphtonu16(&buf[byte_offset + i * 2], word_value);\r\n\t\tpos += 5;\r\n\t}\r\n\r\n\treturn true;\r\n}"}, "callee": {".oshiba_read": "static bool toshiba_read(wtap *wth, wtap_rec *rec, int *err,\r\n\tchar **err_info, int64_t *data_offset)\r\n{\r\n\tint64_t\toffset;\r\n\r\n\t/* Find the next packet */\r\n\toffset = toshiba_seek_next_packet(wth, err, err_info);\r\n\tif (offset < 1)\r\n\t\treturn false;\r\n\t*data_offset = offset;\r\n\r\n\t/* Parse the packet */\r\n\treturn parse_toshiba_packet(wth->fh, rec, err, err_info);\r\n}", ".oshiba_open": "wtap_open_return_val toshiba_open(wtap *wth, int *err, char **err_info)\r\n{\r\n\t/* Look for Toshiba header */\r\n\tif (!toshiba_check_file_type(wth, err, err_info)) {\r\n\t\tif (*err != 0 && *err != WTAP_ERR_SHORT_READ)\r\n\t\t\treturn WTAP_OPEN_ERROR;\r\n\t\treturn WTAP_OPEN_NOT_MINE;\r\n\t}\r\n\r\n\twth->file_encap = WTAP_ENCAP_PER_PACKET;\r\n\twth->file_type_subtype = toshiba_file_type_subtype;\r\n\twth->snapshot_length = 0; /* not known */\r\n\twth->subtype_read = toshiba_read;\r\n\twth->subtype_seek_read = toshiba_seek_read;\r\n\twth->file_tsprec = WTAP_TSPREC_10_MSEC;\r\n\r\n\treturn WTAP_OPEN_MINE;\r\n}", ".oshiba_seek_read": "static bool\r\ntoshiba_seek_read(wtap *wth, int64_t seek_off, wtap_rec *rec, int *err,\r\n\tchar **err_info)\r\n{\r\n\tif (file_seek(wth->random_fh, seek_off - 1, SEEK_SET, err) == -1)\r\n\t\treturn false;\r\n\r\n\tif (!parse_toshiba_packet(wth->random_fh, rec, err, err_info)) {\r\n\t\tif (*err == 0)\r\n\t\t\t*err = WTAP_ERR_SHORT_READ;\r\n\t\treturn false;\r\n\t}\r\n\treturn true;\r\n}", ".arse_toshiba_packet": "static bool\r\nparse_toshiba_packet(FILE_T fh, wtap_rec *rec, int *err, char **err_info)\r\n{\r\n\tunion wtap_pseudo_header *pseudo_header = &rec->rec_header.packet_header.pseudo_header;\r\n\tchar\tline[TOSHIBA_LINE_LENGTH];\r\n\tint\tnum_items_scanned;\r\n\tint\tpkt_len, pktnum, hr, min, sec, csec;\r\n\tchar\tchannel[10], direction[10];\r\n\tint\ti, hex_lines;\r\n\tuint8_t\t*pd;\r\n\r\n\t/* Our file pointer should be on the line containing the\r\n\t * summary information for a packet. Read in that line and\r\n\t * extract the useful information\r\n\t */\r\n\tif (file_gets(line, TOSHIBA_LINE_LENGTH, fh) == NULL) {\r\n\t\t*err = file_error(fh, err_info);\r\n\t\tif (*err == 0) {\r\n\t\t\t*err = WTAP_ERR_SHORT_READ;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\t/* Find text in line after \"[No.\". Limit the length of the\r\n\t * two strings since we have fixed buffers for channel[] and\r\n\t * direction[] */\r\n\tnum_items_scanned = sscanf(line, \"%9d] %2d:%2d:%2d.%9d %9s %9s\",\r\n\t\t\t&pktnum, &hr, &min, &sec, &csec, channel, direction);\r\n\r\n\tif (num_items_scanned != 7) {\r\n\t\t*err = WTAP_ERR_BAD_FILE;\r\n\t\t*err_info = g_strdup(\"toshiba: record header isn't valid\");\r\n\t\treturn false;\r\n\t}\r\n\r\n\t/* Scan lines until we find the OFFSET line. In a \"telnet\" trace,\r\n\t * this will be the next line. But if you save your telnet session\r\n\t * to a file from within a Windows-based telnet client, it may\r\n\t * put in line breaks at 80 columns (or however big your \"telnet\" box\r\n\t * is). CRT (a Windows telnet app from VanDyke) does this.\r\n\t * Here we assume that 80 columns will be the minimum size, and that\r\n\t * the OFFSET line is not broken in the middle. It's the previous\r\n\t * line that is normally long and can thus be broken at column 80.\r\n\t */\r\n\tdo {\r\n\t\tif (file_gets(line, TOSHIBA_LINE_LENGTH, fh) == NULL) {\r\n\t\t\t*err = file_error(fh, err_info);\r\n\t\t\tif (*err == 0) {\r\n\t\t\t\t*err = WTAP_ERR_SHORT_READ;\r\n\t\t\t}\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\t/* Check for \"OFFSET 0001-0203\" at beginning of line */\r\n\t\tline[16] = '\\0';\r\n\r\n\t} while (strcmp(line, \"OFFSET 0001-0203\") != 0);\r\n\r\n\tnum_items_scanned = sscanf(line+64, \"LEN=%9d\", &pkt_len);\r\n\tif (num_items_scanned != 1) {\r\n\t\t*err = WTAP_ERR_BAD_FILE;\r\n\t\t*err_info = g_strdup(\"toshiba: OFFSET line doesn't have valid LEN item\");\r\n\t\treturn false;\r\n\t}\r\n\tif (pkt_len < 0) {\r\n\t\t*err = WTAP_ERR_BAD_FILE;\r\n\t\t*err_info = g_strdup(\"toshiba: packet header has a negative packet length\");\r\n\t\treturn false;\r\n\t}\r\n\tif ((unsigned)pkt_len > WTAP_MAX_PACKET_SIZE_STANDARD) {\r\n\t\t/*\r\n\t\t * Probably a corrupt capture file; don't blow up trying\r\n\t\t * to allocate space for an immensely-large packet.\r\n\t\t */\r\n\t\t*err = WTAP_ERR_BAD_FILE;\r\n\t\t*err_info = ws_strdup_printf(\"toshiba: File has %u-byte packet, bigger than maximum of %u\",\r\n\t\t    (unsigned)pkt_len, WTAP_MAX_PACKET_SIZE_STANDARD);\r\n\t\treturn false;\r\n\t}\r\n\r\n\twtap_setup_packet_rec(rec, WTAP_ENCAP_UNKNOWN);\r\n\trec->block = wtap_block_create(WTAP_BLOCK_PACKET);\r\n\trec->presence_flags = WTAP_HAS_TS|WTAP_HAS_CAP_LEN;\r\n\trec->ts.secs = hr * 3600 + min * 60 + sec;\r\n\trec->ts.nsecs = csec * 10000000;\r\n\trec->rec_header.packet_header.caplen = pkt_len;\r\n\trec->rec_header.packet_header.len = pkt_len;\r\n\r\n\tswitch (channel[0]) {\r\n\t\tcase 'B':\r\n\t\t\trec->rec_header.packet_header.pkt_encap = WTAP_ENCAP_ISDN;\r\n\t\t\tpseudo_header->isdn.uton = (direction[0] == 'T');\r\n\t\t\tpseudo_header->isdn.channel = (uint8_t)\r\n\t\t\t    strtol(&channel[1], NULL, 10);\r\n\t\t\tbreak;\r\n\r\n\t\tcase 'D':\r\n\t\t\trec->rec_header.packet_header.pkt_encap = WTAP_ENCAP_ISDN;\r\n\t\t\tpseudo_header->isdn.uton = (direction[0] == 'T');\r\n\t\t\tpseudo_header->isdn.channel = 0;\r\n\t\t\tbreak;\r\n\r\n\t\tdefault:\r\n\t\t\trec->rec_header.packet_header.pkt_encap = WTAP_ENCAP_ETHERNET;\r\n\t\t\t/* XXX - is there an FCS in the frame? */\r\n\t\t\tpseudo_header->eth.fcs_len = -1;\r\n\t\t\tbreak;\r\n\t}\r\n\r\n\t/* Make sure we have enough room for the packet */\r\n\tws_buffer_assure_space(&rec->data, pkt_len);\r\n\tpd = ws_buffer_start_ptr(&rec->data);\r\n\r\n\t/* Calculate the number of hex dump lines, each\r\n\t * containing 16 bytes of data */\r\n\thex_lines = pkt_len / 16 + ((pkt_len % 16) ? 1 : 0);\r\n\r\n\tfor (i = 0; i < hex_lines; i++) {\r\n\t\tif (file_gets(line, TOSHIBA_LINE_LENGTH, fh) == NULL) {\r\n\t\t\t*err = file_error(fh, err_info);\r\n\t\t\tif (*err == 0) {\r\n\t\t\t\t*err = WTAP_ERR_SHORT_READ;\r\n\t\t\t}\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tif (!parse_single_hex_dump_line(line, pd, i * 16)) {\r\n\t\t\t*err = WTAP_ERR_BAD_FILE;\r\n\t\t\t*err_info = g_strdup(\"toshiba: hex dump not valid\");\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\treturn true;\r\n}"}, "function_name": "register_toshiba"}
{"function_id": null, "caller": {".osine_check_file_type": "static bool cosine_check_file_type(wtap *wth, int *err, char **err_info)\r\n{\r\n\tchar\tbuf[COSINE_LINE_LENGTH];\r\n\tsize_t\treclen;\r\n\tunsigned\tline;\r\n\r\n\tbuf[COSINE_LINE_LENGTH-1] = '\\0';\r\n\r\n\tfor (line = 0; line < COSINE_HEADER_LINES_TO_CHECK; line++) {\r\n\t\tif (file_gets(buf, COSINE_LINE_LENGTH, wth->fh) == NULL) {\r\n\t\t\t/* EOF or error. */\r\n\t\t\t*err = file_error(wth->fh, err_info);\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\treclen = strlen(buf);\r\n\t\tif (reclen < MIN(strlen(COSINE_HDR_MAGIC_STR1), strlen(COSINE_HDR_MAGIC_STR2))) {\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\tif (strstr(buf, COSINE_HDR_MAGIC_STR1) ||\r\n\t\t    strstr(buf, COSINE_HDR_MAGIC_STR2)) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t}\r\n\t*err = 0;\r\n\treturn false;\r\n}", ".osine_read": "static bool cosine_read(wtap *wth, wtap_rec *rec,\r\n    int *err, char **err_info, int64_t *data_offset)\r\n{\r\n\tint64_t\toffset;\r\n\tchar\tline[COSINE_LINE_LENGTH];\r\n\r\n\t/* Find the next packet */\r\n\toffset = cosine_seek_next_packet(wth, err, err_info, line);\r\n\tif (offset < 0)\r\n\t\treturn false;\r\n\t*data_offset = offset;\r\n\r\n\t/* Parse the header and convert the ASCII hex dump to binary data */\r\n\treturn parse_cosine_packet(wth->fh, rec, line, err, err_info);\r\n}", ".osine_seek_read": "static bool\r\ncosine_seek_read(wtap *wth, int64_t seek_off, wtap_rec *rec,\r\n\tint *err, char **err_info)\r\n{\r\n\tchar\tline[COSINE_LINE_LENGTH];\r\n\r\n\tif (file_seek(wth->random_fh, seek_off, SEEK_SET, err) == -1)\r\n\t\treturn false;\r\n\r\n\tif (file_gets(line, COSINE_LINE_LENGTH, wth->random_fh) == NULL) {\r\n\t\t*err = file_error(wth->random_fh, err_info);\r\n\t\tif (*err == 0) {\r\n\t\t\t*err = WTAP_ERR_SHORT_READ;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\t/* Parse the header and convert the ASCII hex dump to binary data */\r\n\treturn parse_cosine_packet(wth->random_fh, rec, line, err, err_info);\r\n}", ".osine_seek_next_packet": "static int64_t cosine_seek_next_packet(wtap *wth, int *err, char **err_info,\r\n\tchar *hdr)\r\n{\r\n\tint64_t cur_off;\r\n\tchar buf[COSINE_LINE_LENGTH];\r\n\r\n\twhile (1) {\r\n\t\tcur_off = file_tell(wth->fh);\r\n\t\tif (cur_off == -1) {\r\n\t\t\t/* Error */\r\n\t\t\t*err = file_error(wth->fh, err_info);\r\n\t\t\treturn -1;\r\n\t\t}\r\n\t\tif (file_gets(buf, sizeof(buf), wth->fh) == NULL) {\r\n\t\t\t*err = file_error(wth->fh, err_info);\r\n\t\t\treturn -1;\r\n\t\t}\r\n\t\tif (strstr(buf, COSINE_REC_MAGIC_STR1) ||\r\n\t\t    strstr(buf, COSINE_REC_MAGIC_STR2)) {\r\n\t\t\t(void) g_strlcpy(hdr, buf, COSINE_LINE_LENGTH);\r\n\t\t\treturn cur_off;\r\n\t\t}\r\n\t}\r\n\treturn -1;\r\n}", ".arse_cosine_packet": "static bool\r\nparse_cosine_packet(FILE_T fh, wtap_rec *rec,\r\n    char *line, int *err, char **err_info)\r\n{\r\n\tunion wtap_pseudo_header *pseudo_header = &rec->rec_header.packet_header.pseudo_header;\r\n\tint\tnum_items_scanned;\r\n\tint\tyy, mm, dd, hr, min, sec, csec, pkt_len;\r\n\tint\tpro, off, pri, rm, error;\r\n\tunsigned\tcode1, code2;\r\n\tchar\tif_name[COSINE_MAX_IF_NAME_LEN] = \"\", direction[6] = \"\";\r\n\tstruct\ttm tm;\r\n\tuint8_t *pd;\r\n\tint\ti, hex_lines, n, caplen = 0;\r\n\r\n\tif (sscanf(line, \"%4d-%2d-%2d,%2d:%2d:%2d.%9d:\",\r\n\t\t   &yy, &mm, &dd, &hr, &min, &sec, &csec) == 7) {\r\n\t\t/* appears to be output to a control blade */\r\n\t\tnum_items_scanned = sscanf(line,\r\n\t\t   \"%4d-%2d-%2d,%2d:%2d:%2d.%9d: %5s (%127[A-Za-z0-9/:]), Length:%9d, Pro:%9d, Off:%9d, Pri:%9d, RM:%9d, Err:%9d [%8x, %8x]\",\r\n\t\t\t&yy, &mm, &dd, &hr, &min, &sec, &csec,\r\n\t\t\t\t   direction, if_name, &pkt_len,\r\n\t\t\t\t   &pro, &off, &pri, &rm, &error,\r\n\t\t\t\t   &code1, &code2);\r\n\r\n\t\tif (num_items_scanned != 17) {\r\n\t\t\t*err = WTAP_ERR_BAD_FILE;\r\n\t\t\t*err_info = g_strdup(\"cosine: purported control blade line doesn't have code values\");\r\n\t\t\treturn false;\r\n\t\t}\r\n\t} else {\r\n\t\t/* appears to be output to PE */\r\n\t\tnum_items_scanned = sscanf(line,\r\n\t\t   \"%5s (%127[A-Za-z0-9/:]), Length:%9d, Pro:%9d, Off:%9d, Pri:%9d, RM:%9d, Err:%9d [%8x, %8x]\",\r\n\t\t\t\t   direction, if_name, &pkt_len,\r\n\t\t\t\t   &pro, &off, &pri, &rm, &error,\r\n\t\t\t\t   &code1, &code2);\r\n\r\n\t\tif (num_items_scanned != 10) {\r\n\t\t\t*err = WTAP_ERR_BAD_FILE;\r\n\t\t\t*err_info = g_strdup(\"cosine: header line is neither control blade nor PE output\");\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tyy = mm = dd = hr = min = sec = csec = 0;\r\n\t}\r\n\tif (pkt_len < 0) {\r\n\t\t*err = WTAP_ERR_BAD_FILE;\r\n\t\t*err_info = g_strdup(\"cosine: packet header has a negative packet length\");\r\n\t\treturn false;\r\n\t}\r\n\tif ((unsigned)pkt_len > WTAP_MAX_PACKET_SIZE_STANDARD) {\r\n\t\t/*\r\n\t\t * Probably a corrupt capture file; don't blow up trying\r\n\t\t * to allocate space for an immensely-large packet.\r\n\t\t */\r\n\t\t*err = WTAP_ERR_BAD_FILE;\r\n\t\t*err_info = ws_strdup_printf(\"cosine: File has %u-byte packet, bigger than maximum of %u\",\r\n\t\t    (unsigned)pkt_len, WTAP_MAX_PACKET_SIZE_STANDARD);\r\n\t\treturn false;\r\n\t}\r\n\r\n\trec->rec_type = REC_TYPE_PACKET;\r\n\trec->block = wtap_block_create(WTAP_BLOCK_PACKET);\r\n\trec->presence_flags = WTAP_HAS_TS|WTAP_HAS_CAP_LEN;\r\n\ttm.tm_year = yy - 1900;\r\n\ttm.tm_mon = mm - 1;\r\n\ttm.tm_mday = dd;\r\n\ttm.tm_hour = hr;\r\n\ttm.tm_min = min;\r\n\ttm.tm_sec = sec;\r\n\ttm.tm_isdst = -1;\r\n\trec->ts.secs = mktime(&tm);\r\n\trec->ts.nsecs = csec * 10000000;\r\n\trec->rec_header.packet_header.len = pkt_len;\r\n\r\n\t/* XXX need to handle other encapsulations like Cisco HDLC,\r\n\t   Frame Relay and ATM */\r\n\tif (strncmp(if_name, \"TEST:\", 5) == 0) {\r\n\t\tpseudo_header->cosine.encap = COSINE_ENCAP_TEST;\r\n\t} else if (strncmp(if_name, \"PPoATM:\", 7) == 0) {\r\n\t\tpseudo_header->cosine.encap = COSINE_ENCAP_PPoATM;\r\n\t} else if (strncmp(if_name, \"PPoFR:\", 6) == 0) {\r\n\t\tpseudo_header->cosine.encap = COSINE_ENCAP_PPoFR;\r\n\t} else if (strncmp(if_name, \"ATM:\", 4) == 0) {\r\n\t\tpseudo_header->cosine.encap = COSINE_ENCAP_ATM;\r\n\t} else if (strncmp(if_name, \"FR:\", 3) == 0) {\r\n\t\tpseudo_header->cosine.encap = COSINE_ENCAP_FR;\r\n\t} else if (strncmp(if_name, \"HDLC:\", 5) == 0) {\r\n\t\tpseudo_header->cosine.encap = COSINE_ENCAP_HDLC;\r\n\t} else if (strncmp(if_name, \"PPP:\", 4) == 0) {\r\n\t\tpseudo_header->cosine.encap = COSINE_ENCAP_PPP;\r\n\t} else if (strncmp(if_name, \"ETH:\", 4) == 0) {\r\n\t\tpseudo_header->cosine.encap = COSINE_ENCAP_ETH;\r\n\t} else {\r\n\t\tpseudo_header->cosine.encap = COSINE_ENCAP_UNKNOWN;\r\n\t}\r\n\tif (strncmp(direction, \"l2-tx\", 5) == 0) {\r\n\t\tpseudo_header->cosine.direction = COSINE_DIR_TX;\r\n\t} else if (strncmp(direction, \"l2-rx\", 5) == 0) {\r\n\t\tpseudo_header->cosine.direction = COSINE_DIR_RX;\r\n\t}\r\n\t(void) g_strlcpy(pseudo_header->cosine.if_name, if_name,\r\n\t\tCOSINE_MAX_IF_NAME_LEN);\r\n\tpseudo_header->cosine.pro = pro;\r\n\tpseudo_header->cosine.off = off;\r\n\tpseudo_header->cosine.pri = pri;\r\n\tpseudo_header->cosine.rm = rm;\r\n\tpseudo_header->cosine.err = error;\r\n\r\n\t/* Make sure we have enough room for the packet */\r\n\tws_buffer_assure_space(&rec->data, pkt_len);\r\n\tpd = ws_buffer_start_ptr(&rec->data);\r\n\r\n\t/* Calculate the number of hex dump lines, each\r\n\t * containing 16 bytes of data */\r\n\thex_lines = pkt_len / 16 + ((pkt_len % 16) ? 1 : 0);\r\n\r\n\tfor (i = 0; i < hex_lines; i++) {\r\n\t\tif (file_gets(line, COSINE_LINE_LENGTH, fh) == NULL) {\r\n\t\t\t*err = file_error(fh, err_info);\r\n\t\t\tif (*err == 0) {\r\n\t\t\t\t*err = WTAP_ERR_SHORT_READ;\r\n\t\t\t}\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tif (empty_line(line)) {\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tif ((n = parse_single_hex_dump_line(line, pd, i*16)) == -1) {\r\n\t\t\t*err = WTAP_ERR_BAD_FILE;\r\n\t\t\t*err_info = g_strdup(\"cosine: hex dump line doesn't have 16 numbers\");\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tcaplen += n;\r\n\t}\r\n\trec->rec_header.packet_header.caplen = caplen;\r\n\treturn true;\r\n}", ".mpty_line": "static bool empty_line(const char *line)\r\n{\r\n\twhile (*line) {\r\n\t\tif (g_ascii_isspace(*line)) {\r\n\t\t\tline++;\r\n\t\t\tcontinue;\r\n\t\t} else {\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\tif (*line == '\\0')\r\n\t\treturn true;\r\n\telse\r\n\t\treturn false;\r\n}", ".arse_single_hex_dump_line": "static int\r\nparse_single_hex_dump_line(char* rec, uint8_t *buf, unsigned byte_offset)\r\n{\r\n\tint num_items_scanned, i;\r\n\tunsigned int bytes[16];\r\n\r\n\tnum_items_scanned = sscanf(rec, \"%02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\",\r\n\t\t\t       &bytes[0], &bytes[1], &bytes[2], &bytes[3],\r\n\t\t\t       &bytes[4], &bytes[5], &bytes[6], &bytes[7],\r\n\t\t\t       &bytes[8], &bytes[9], &bytes[10], &bytes[11],\r\n\t\t\t       &bytes[12], &bytes[13], &bytes[14], &bytes[15]);\r\n\tif (num_items_scanned == 0)\r\n\t\treturn -1;\r\n\r\n\tif (num_items_scanned > 16)\r\n\t\tnum_items_scanned = 16;\r\n\r\n\tfor (i=0; i<num_items_scanned; i++) {\r\n\t\tbuf[byte_offset + i] = (uint8_t)bytes[i];\r\n\t}\r\n\r\n\treturn num_items_scanned;\r\n}"}, "callee": {".arse_cosine_packet": "static bool\r\nparse_cosine_packet(FILE_T fh, wtap_rec *rec,\r\n    char *line, int *err, char **err_info)\r\n{\r\n\tunion wtap_pseudo_header *pseudo_header = &rec->rec_header.packet_header.pseudo_header;\r\n\tint\tnum_items_scanned;\r\n\tint\tyy, mm, dd, hr, min, sec, csec, pkt_len;\r\n\tint\tpro, off, pri, rm, error;\r\n\tunsigned\tcode1, code2;\r\n\tchar\tif_name[COSINE_MAX_IF_NAME_LEN] = \"\", direction[6] = \"\";\r\n\tstruct\ttm tm;\r\n\tuint8_t *pd;\r\n\tint\ti, hex_lines, n, caplen = 0;\r\n\r\n\tif (sscanf(line, \"%4d-%2d-%2d,%2d:%2d:%2d.%9d:\",\r\n\t\t   &yy, &mm, &dd, &hr, &min, &sec, &csec) == 7) {\r\n\t\t/* appears to be output to a control blade */\r\n\t\tnum_items_scanned = sscanf(line,\r\n\t\t   \"%4d-%2d-%2d,%2d:%2d:%2d.%9d: %5s (%127[A-Za-z0-9/:]), Length:%9d, Pro:%9d, Off:%9d, Pri:%9d, RM:%9d, Err:%9d [%8x, %8x]\",\r\n\t\t\t&yy, &mm, &dd, &hr, &min, &sec, &csec,\r\n\t\t\t\t   direction, if_name, &pkt_len,\r\n\t\t\t\t   &pro, &off, &pri, &rm, &error,\r\n\t\t\t\t   &code1, &code2);\r\n\r\n\t\tif (num_items_scanned != 17) {\r\n\t\t\t*err = WTAP_ERR_BAD_FILE;\r\n\t\t\t*err_info = g_strdup(\"cosine: purported control blade line doesn't have code values\");\r\n\t\t\treturn false;\r\n\t\t}\r\n\t} else {\r\n\t\t/* appears to be output to PE */\r\n\t\tnum_items_scanned = sscanf(line,\r\n\t\t   \"%5s (%127[A-Za-z0-9/:]), Length:%9d, Pro:%9d, Off:%9d, Pri:%9d, RM:%9d, Err:%9d [%8x, %8x]\",\r\n\t\t\t\t   direction, if_name, &pkt_len,\r\n\t\t\t\t   &pro, &off, &pri, &rm, &error,\r\n\t\t\t\t   &code1, &code2);\r\n\r\n\t\tif (num_items_scanned != 10) {\r\n\t\t\t*err = WTAP_ERR_BAD_FILE;\r\n\t\t\t*err_info = g_strdup(\"cosine: header line is neither control blade nor PE output\");\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tyy = mm = dd = hr = min = sec = csec = 0;\r\n\t}\r\n\tif (pkt_len < 0) {\r\n\t\t*err = WTAP_ERR_BAD_FILE;\r\n\t\t*err_info = g_strdup(\"cosine: packet header has a negative packet length\");\r\n\t\treturn false;\r\n\t}\r\n\tif ((unsigned)pkt_len > WTAP_MAX_PACKET_SIZE_STANDARD) {\r\n\t\t/*\r\n\t\t * Probably a corrupt capture file; don't blow up trying\r\n\t\t * to allocate space for an immensely-large packet.\r\n\t\t */\r\n\t\t*err = WTAP_ERR_BAD_FILE;\r\n\t\t*err_info = ws_strdup_printf(\"cosine: File has %u-byte packet, bigger than maximum of %u\",\r\n\t\t    (unsigned)pkt_len, WTAP_MAX_PACKET_SIZE_STANDARD);\r\n\t\treturn false;\r\n\t}\r\n\r\n\trec->rec_type = REC_TYPE_PACKET;\r\n\trec->block = wtap_block_create(WTAP_BLOCK_PACKET);\r\n\trec->presence_flags = WTAP_HAS_TS|WTAP_HAS_CAP_LEN;\r\n\ttm.tm_year = yy - 1900;\r\n\ttm.tm_mon = mm - 1;\r\n\ttm.tm_mday = dd;\r\n\ttm.tm_hour = hr;\r\n\ttm.tm_min = min;\r\n\ttm.tm_sec = sec;\r\n\ttm.tm_isdst = -1;\r\n\trec->ts.secs = mktime(&tm);\r\n\trec->ts.nsecs = csec * 10000000;\r\n\trec->rec_header.packet_header.len = pkt_len;\r\n\r\n\t/* XXX need to handle other encapsulations like Cisco HDLC,\r\n\t   Frame Relay and ATM */\r\n\tif (strncmp(if_name, \"TEST:\", 5) == 0) {\r\n\t\tpseudo_header->cosine.encap = COSINE_ENCAP_TEST;\r\n\t} else if (strncmp(if_name, \"PPoATM:\", 7) == 0) {\r\n\t\tpseudo_header->cosine.encap = COSINE_ENCAP_PPoATM;\r\n\t} else if (strncmp(if_name, \"PPoFR:\", 6) == 0) {\r\n\t\tpseudo_header->cosine.encap = COSINE_ENCAP_PPoFR;\r\n\t} else if (strncmp(if_name, \"ATM:\", 4) == 0) {\r\n\t\tpseudo_header->cosine.encap = COSINE_ENCAP_ATM;\r\n\t} else if (strncmp(if_name, \"FR:\", 3) == 0) {\r\n\t\tpseudo_header->cosine.encap = COSINE_ENCAP_FR;\r\n\t} else if (strncmp(if_name, \"HDLC:\", 5) == 0) {\r\n\t\tpseudo_header->cosine.encap = COSINE_ENCAP_HDLC;\r\n\t} else if (strncmp(if_name, \"PPP:\", 4) == 0) {\r\n\t\tpseudo_header->cosine.encap = COSINE_ENCAP_PPP;\r\n\t} else if (strncmp(if_name, \"ETH:\", 4) == 0) {\r\n\t\tpseudo_header->cosine.encap = COSINE_ENCAP_ETH;\r\n\t} else {\r\n\t\tpseudo_header->cosine.encap = COSINE_ENCAP_UNKNOWN;\r\n\t}\r\n\tif (strncmp(direction, \"l2-tx\", 5) == 0) {\r\n\t\tpseudo_header->cosine.direction = COSINE_DIR_TX;\r\n\t} else if (strncmp(direction, \"l2-rx\", 5) == 0) {\r\n\t\tpseudo_header->cosine.direction = COSINE_DIR_RX;\r\n\t}\r\n\t(void) g_strlcpy(pseudo_header->cosine.if_name, if_name,\r\n\t\tCOSINE_MAX_IF_NAME_LEN);\r\n\tpseudo_header->cosine.pro = pro;\r\n\tpseudo_header->cosine.off = off;\r\n\tpseudo_header->cosine.pri = pri;\r\n\tpseudo_header->cosine.rm = rm;\r\n\tpseudo_header->cosine.err = error;\r\n\r\n\t/* Make sure we have enough room for the packet */\r\n\tws_buffer_assure_space(&rec->data, pkt_len);\r\n\tpd = ws_buffer_start_ptr(&rec->data);\r\n\r\n\t/* Calculate the number of hex dump lines, each\r\n\t * containing 16 bytes of data */\r\n\thex_lines = pkt_len / 16 + ((pkt_len % 16) ? 1 : 0);\r\n\r\n\tfor (i = 0; i < hex_lines; i++) {\r\n\t\tif (file_gets(line, COSINE_LINE_LENGTH, fh) == NULL) {\r\n\t\t\t*err = file_error(fh, err_info);\r\n\t\t\tif (*err == 0) {\r\n\t\t\t\t*err = WTAP_ERR_SHORT_READ;\r\n\t\t\t}\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tif (empty_line(line)) {\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tif ((n = parse_single_hex_dump_line(line, pd, i*16)) == -1) {\r\n\t\t\t*err = WTAP_ERR_BAD_FILE;\r\n\t\t\t*err_info = g_strdup(\"cosine: hex dump line doesn't have 16 numbers\");\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tcaplen += n;\r\n\t}\r\n\trec->rec_header.packet_header.caplen = caplen;\r\n\treturn true;\r\n}", ".osine_read": "static bool cosine_read(wtap *wth, wtap_rec *rec,\r\n    int *err, char **err_info, int64_t *data_offset)\r\n{\r\n\tint64_t\toffset;\r\n\tchar\tline[COSINE_LINE_LENGTH];\r\n\r\n\t/* Find the next packet */\r\n\toffset = cosine_seek_next_packet(wth, err, err_info, line);\r\n\tif (offset < 0)\r\n\t\treturn false;\r\n\t*data_offset = offset;\r\n\r\n\t/* Parse the header and convert the ASCII hex dump to binary data */\r\n\treturn parse_cosine_packet(wth->fh, rec, line, err, err_info);\r\n}", ".osine_open": "wtap_open_return_val cosine_open(wtap *wth, int *err, char **err_info)\r\n{\r\n\t/* Look for CoSine header */\r\n\tif (!cosine_check_file_type(wth, err, err_info)) {\r\n\t\tif (*err != 0 && *err != WTAP_ERR_SHORT_READ)\r\n\t\t\treturn WTAP_OPEN_ERROR;\r\n\t\treturn WTAP_OPEN_NOT_MINE;\r\n\t}\r\n\r\n\tif (file_seek(wth->fh, 0L, SEEK_SET, err) == -1)\t/* rewind */\r\n\t\treturn WTAP_OPEN_ERROR;\r\n\r\n\twth->file_encap = WTAP_ENCAP_COSINE;\r\n\twth->file_type_subtype = cosine_file_type_subtype;\r\n\twth->snapshot_length = 0; /* not known */\r\n\twth->subtype_read = cosine_read;\r\n\twth->subtype_seek_read = cosine_seek_read;\r\n\twth->file_tsprec = WTAP_TSPREC_10_MSEC;\r\n\r\n\t/*\r\n\t * Add an IDB; we don't know how many interfaces were\r\n\t * involved, so we just say one interface, about which\r\n\t * we only know the link-layer type, snapshot length,\r\n\t * and time stamp resolution.\r\n\t */\r\n\twtap_add_generated_idb(wth);\r\n\r\n\treturn WTAP_OPEN_MINE;\r\n}", ".osine_seek_read": "static bool\r\ncosine_seek_read(wtap *wth, int64_t seek_off, wtap_rec *rec,\r\n\tint *err, char **err_info)\r\n{\r\n\tchar\tline[COSINE_LINE_LENGTH];\r\n\r\n\tif (file_seek(wth->random_fh, seek_off, SEEK_SET, err) == -1)\r\n\t\treturn false;\r\n\r\n\tif (file_gets(line, COSINE_LINE_LENGTH, wth->random_fh) == NULL) {\r\n\t\t*err = file_error(wth->random_fh, err_info);\r\n\t\tif (*err == 0) {\r\n\t\t\t*err = WTAP_ERR_SHORT_READ;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\t/* Parse the header and convert the ASCII hex dump to binary data */\r\n\treturn parse_cosine_packet(wth->random_fh, rec, line, err, err_info);\r\n}"}, "function_name": "register_cosine"}
{"function_id": null, "caller": {".osine_check_file_type": "static bool cosine_check_file_type(wtap *wth, int *err, char **err_info)\r\n{\r\n\tchar\tbuf[COSINE_LINE_LENGTH];\r\n\tsize_t\treclen;\r\n\tunsigned\tline;\r\n\r\n\tbuf[COSINE_LINE_LENGTH-1] = '\\0';\r\n\r\n\tfor (line = 0; line < COSINE_HEADER_LINES_TO_CHECK; line++) {\r\n\t\tif (file_gets(buf, COSINE_LINE_LENGTH, wth->fh) == NULL) {\r\n\t\t\t/* EOF or error. */\r\n\t\t\t*err = file_error(wth->fh, err_info);\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\treclen = strlen(buf);\r\n\t\tif (reclen < MIN(strlen(COSINE_HDR_MAGIC_STR1), strlen(COSINE_HDR_MAGIC_STR2))) {\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\tif (strstr(buf, COSINE_HDR_MAGIC_STR1) ||\r\n\t\t    strstr(buf, COSINE_HDR_MAGIC_STR2)) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t}\r\n\t*err = 0;\r\n\treturn false;\r\n}", ".osine_read": "static bool cosine_read(wtap *wth, wtap_rec *rec,\r\n    int *err, char **err_info, int64_t *data_offset)\r\n{\r\n\tint64_t\toffset;\r\n\tchar\tline[COSINE_LINE_LENGTH];\r\n\r\n\t/* Find the next packet */\r\n\toffset = cosine_seek_next_packet(wth, err, err_info, line);\r\n\tif (offset < 0)\r\n\t\treturn false;\r\n\t*data_offset = offset;\r\n\r\n\t/* Parse the header and convert the ASCII hex dump to binary data */\r\n\treturn parse_cosine_packet(wth->fh, rec, line, err, err_info);\r\n}", ".osine_seek_read": "static bool\r\ncosine_seek_read(wtap *wth, int64_t seek_off, wtap_rec *rec,\r\n\tint *err, char **err_info)\r\n{\r\n\tchar\tline[COSINE_LINE_LENGTH];\r\n\r\n\tif (file_seek(wth->random_fh, seek_off, SEEK_SET, err) == -1)\r\n\t\treturn false;\r\n\r\n\tif (file_gets(line, COSINE_LINE_LENGTH, wth->random_fh) == NULL) {\r\n\t\t*err = file_error(wth->random_fh, err_info);\r\n\t\tif (*err == 0) {\r\n\t\t\t*err = WTAP_ERR_SHORT_READ;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\t/* Parse the header and convert the ASCII hex dump to binary data */\r\n\treturn parse_cosine_packet(wth->random_fh, rec, line, err, err_info);\r\n}", ".osine_seek_next_packet": "static int64_t cosine_seek_next_packet(wtap *wth, int *err, char **err_info,\r\n\tchar *hdr)\r\n{\r\n\tint64_t cur_off;\r\n\tchar buf[COSINE_LINE_LENGTH];\r\n\r\n\twhile (1) {\r\n\t\tcur_off = file_tell(wth->fh);\r\n\t\tif (cur_off == -1) {\r\n\t\t\t/* Error */\r\n\t\t\t*err = file_error(wth->fh, err_info);\r\n\t\t\treturn -1;\r\n\t\t}\r\n\t\tif (file_gets(buf, sizeof(buf), wth->fh) == NULL) {\r\n\t\t\t*err = file_error(wth->fh, err_info);\r\n\t\t\treturn -1;\r\n\t\t}\r\n\t\tif (strstr(buf, COSINE_REC_MAGIC_STR1) ||\r\n\t\t    strstr(buf, COSINE_REC_MAGIC_STR2)) {\r\n\t\t\t(void) g_strlcpy(hdr, buf, COSINE_LINE_LENGTH);\r\n\t\t\treturn cur_off;\r\n\t\t}\r\n\t}\r\n\treturn -1;\r\n}", ".arse_cosine_packet": "static bool\r\nparse_cosine_packet(FILE_T fh, wtap_rec *rec,\r\n    char *line, int *err, char **err_info)\r\n{\r\n\tunion wtap_pseudo_header *pseudo_header = &rec->rec_header.packet_header.pseudo_header;\r\n\tint\tnum_items_scanned;\r\n\tint\tyy, mm, dd, hr, min, sec, csec, pkt_len;\r\n\tint\tpro, off, pri, rm, error;\r\n\tunsigned\tcode1, code2;\r\n\tchar\tif_name[COSINE_MAX_IF_NAME_LEN] = \"\", direction[6] = \"\";\r\n\tstruct\ttm tm;\r\n\tuint8_t *pd;\r\n\tint\ti, hex_lines, n, caplen = 0;\r\n\r\n\tif (sscanf(line, \"%4d-%2d-%2d,%2d:%2d:%2d.%9d:\",\r\n\t\t   &yy, &mm, &dd, &hr, &min, &sec, &csec) == 7) {\r\n\t\t/* appears to be output to a control blade */\r\n\t\tnum_items_scanned = sscanf(line,\r\n\t\t   \"%4d-%2d-%2d,%2d:%2d:%2d.%9d: %5s (%127[A-Za-z0-9/:]), Length:%9d, Pro:%9d, Off:%9d, Pri:%9d, RM:%9d, Err:%9d [%8x, %8x]\",\r\n\t\t\t&yy, &mm, &dd, &hr, &min, &sec, &csec,\r\n\t\t\t\t   direction, if_name, &pkt_len,\r\n\t\t\t\t   &pro, &off, &pri, &rm, &error,\r\n\t\t\t\t   &code1, &code2);\r\n\r\n\t\tif (num_items_scanned != 17) {\r\n\t\t\t*err = WTAP_ERR_BAD_FILE;\r\n\t\t\t*err_info = g_strdup(\"cosine: purported control blade line doesn't have code values\");\r\n\t\t\treturn false;\r\n\t\t}\r\n\t} else {\r\n\t\t/* appears to be output to PE */\r\n\t\tnum_items_scanned = sscanf(line,\r\n\t\t   \"%5s (%127[A-Za-z0-9/:]), Length:%9d, Pro:%9d, Off:%9d, Pri:%9d, RM:%9d, Err:%9d [%8x, %8x]\",\r\n\t\t\t\t   direction, if_name, &pkt_len,\r\n\t\t\t\t   &pro, &off, &pri, &rm, &error,\r\n\t\t\t\t   &code1, &code2);\r\n\r\n\t\tif (num_items_scanned != 10) {\r\n\t\t\t*err = WTAP_ERR_BAD_FILE;\r\n\t\t\t*err_info = g_strdup(\"cosine: header line is neither control blade nor PE output\");\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tyy = mm = dd = hr = min = sec = csec = 0;\r\n\t}\r\n\tif (pkt_len < 0) {\r\n\t\t*err = WTAP_ERR_BAD_FILE;\r\n\t\t*err_info = g_strdup(\"cosine: packet header has a negative packet length\");\r\n\t\treturn false;\r\n\t}\r\n\tif ((unsigned)pkt_len > WTAP_MAX_PACKET_SIZE_STANDARD) {\r\n\t\t/*\r\n\t\t * Probably a corrupt capture file; don't blow up trying\r\n\t\t * to allocate space for an immensely-large packet.\r\n\t\t */\r\n\t\t*err = WTAP_ERR_BAD_FILE;\r\n\t\t*err_info = ws_strdup_printf(\"cosine: File has %u-byte packet, bigger than maximum of %u\",\r\n\t\t    (unsigned)pkt_len, WTAP_MAX_PACKET_SIZE_STANDARD);\r\n\t\treturn false;\r\n\t}\r\n\r\n\trec->rec_type = REC_TYPE_PACKET;\r\n\trec->block = wtap_block_create(WTAP_BLOCK_PACKET);\r\n\trec->presence_flags = WTAP_HAS_TS|WTAP_HAS_CAP_LEN;\r\n\ttm.tm_year = yy - 1900;\r\n\ttm.tm_mon = mm - 1;\r\n\ttm.tm_mday = dd;\r\n\ttm.tm_hour = hr;\r\n\ttm.tm_min = min;\r\n\ttm.tm_sec = sec;\r\n\ttm.tm_isdst = -1;\r\n\trec->ts.secs = mktime(&tm);\r\n\trec->ts.nsecs = csec * 10000000;\r\n\trec->rec_header.packet_header.len = pkt_len;\r\n\r\n\t/* XXX need to handle other encapsulations like Cisco HDLC,\r\n\t   Frame Relay and ATM */\r\n\tif (strncmp(if_name, \"TEST:\", 5) == 0) {\r\n\t\tpseudo_header->cosine.encap = COSINE_ENCAP_TEST;\r\n\t} else if (strncmp(if_name, \"PPoATM:\", 7) == 0) {\r\n\t\tpseudo_header->cosine.encap = COSINE_ENCAP_PPoATM;\r\n\t} else if (strncmp(if_name, \"PPoFR:\", 6) == 0) {\r\n\t\tpseudo_header->cosine.encap = COSINE_ENCAP_PPoFR;\r\n\t} else if (strncmp(if_name, \"ATM:\", 4) == 0) {\r\n\t\tpseudo_header->cosine.encap = COSINE_ENCAP_ATM;\r\n\t} else if (strncmp(if_name, \"FR:\", 3) == 0) {\r\n\t\tpseudo_header->cosine.encap = COSINE_ENCAP_FR;\r\n\t} else if (strncmp(if_name, \"HDLC:\", 5) == 0) {\r\n\t\tpseudo_header->cosine.encap = COSINE_ENCAP_HDLC;\r\n\t} else if (strncmp(if_name, \"PPP:\", 4) == 0) {\r\n\t\tpseudo_header->cosine.encap = COSINE_ENCAP_PPP;\r\n\t} else if (strncmp(if_name, \"ETH:\", 4) == 0) {\r\n\t\tpseudo_header->cosine.encap = COSINE_ENCAP_ETH;\r\n\t} else {\r\n\t\tpseudo_header->cosine.encap = COSINE_ENCAP_UNKNOWN;\r\n\t}\r\n\tif (strncmp(direction, \"l2-tx\", 5) == 0) {\r\n\t\tpseudo_header->cosine.direction = COSINE_DIR_TX;\r\n\t} else if (strncmp(direction, \"l2-rx\", 5) == 0) {\r\n\t\tpseudo_header->cosine.direction = COSINE_DIR_RX;\r\n\t}\r\n\t(void) g_strlcpy(pseudo_header->cosine.if_name, if_name,\r\n\t\tCOSINE_MAX_IF_NAME_LEN);\r\n\tpseudo_header->cosine.pro = pro;\r\n\tpseudo_header->cosine.off = off;\r\n\tpseudo_header->cosine.pri = pri;\r\n\tpseudo_header->cosine.rm = rm;\r\n\tpseudo_header->cosine.err = error;\r\n\r\n\t/* Make sure we have enough room for the packet */\r\n\tws_buffer_assure_space(&rec->data, pkt_len);\r\n\tpd = ws_buffer_start_ptr(&rec->data);\r\n\r\n\t/* Calculate the number of hex dump lines, each\r\n\t * containing 16 bytes of data */\r\n\thex_lines = pkt_len / 16 + ((pkt_len % 16) ? 1 : 0);\r\n\r\n\tfor (i = 0; i < hex_lines; i++) {\r\n\t\tif (file_gets(line, COSINE_LINE_LENGTH, fh) == NULL) {\r\n\t\t\t*err = file_error(fh, err_info);\r\n\t\t\tif (*err == 0) {\r\n\t\t\t\t*err = WTAP_ERR_SHORT_READ;\r\n\t\t\t}\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tif (empty_line(line)) {\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tif ((n = parse_single_hex_dump_line(line, pd, i*16)) == -1) {\r\n\t\t\t*err = WTAP_ERR_BAD_FILE;\r\n\t\t\t*err_info = g_strdup(\"cosine: hex dump line doesn't have 16 numbers\");\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tcaplen += n;\r\n\t}\r\n\trec->rec_header.packet_header.caplen = caplen;\r\n\treturn true;\r\n}", ".mpty_line": "static bool empty_line(const char *line)\r\n{\r\n\twhile (*line) {\r\n\t\tif (g_ascii_isspace(*line)) {\r\n\t\t\tline++;\r\n\t\t\tcontinue;\r\n\t\t} else {\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\tif (*line == '\\0')\r\n\t\treturn true;\r\n\telse\r\n\t\treturn false;\r\n}", ".arse_single_hex_dump_line": "static int\r\nparse_single_hex_dump_line(char* rec, uint8_t *buf, unsigned byte_offset)\r\n{\r\n\tint num_items_scanned, i;\r\n\tunsigned int bytes[16];\r\n\r\n\tnum_items_scanned = sscanf(rec, \"%02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\",\r\n\t\t\t       &bytes[0], &bytes[1], &bytes[2], &bytes[3],\r\n\t\t\t       &bytes[4], &bytes[5], &bytes[6], &bytes[7],\r\n\t\t\t       &bytes[8], &bytes[9], &bytes[10], &bytes[11],\r\n\t\t\t       &bytes[12], &bytes[13], &bytes[14], &bytes[15]);\r\n\tif (num_items_scanned == 0)\r\n\t\treturn -1;\r\n\r\n\tif (num_items_scanned > 16)\r\n\t\tnum_items_scanned = 16;\r\n\r\n\tfor (i=0; i<num_items_scanned; i++) {\r\n\t\tbuf[byte_offset + i] = (uint8_t)bytes[i];\r\n\t}\r\n\r\n\treturn num_items_scanned;\r\n}"}, "callee": {".arse_cosine_packet": "static bool\r\nparse_cosine_packet(FILE_T fh, wtap_rec *rec,\r\n    char *line, int *err, char **err_info)\r\n{\r\n\tunion wtap_pseudo_header *pseudo_header = &rec->rec_header.packet_header.pseudo_header;\r\n\tint\tnum_items_scanned;\r\n\tint\tyy, mm, dd, hr, min, sec, csec, pkt_len;\r\n\tint\tpro, off, pri, rm, error;\r\n\tunsigned\tcode1, code2;\r\n\tchar\tif_name[COSINE_MAX_IF_NAME_LEN] = \"\", direction[6] = \"\";\r\n\tstruct\ttm tm;\r\n\tuint8_t *pd;\r\n\tint\ti, hex_lines, n, caplen = 0;\r\n\r\n\tif (sscanf(line, \"%4d-%2d-%2d,%2d:%2d:%2d.%9d:\",\r\n\t\t   &yy, &mm, &dd, &hr, &min, &sec, &csec) == 7) {\r\n\t\t/* appears to be output to a control blade */\r\n\t\tnum_items_scanned = sscanf(line,\r\n\t\t   \"%4d-%2d-%2d,%2d:%2d:%2d.%9d: %5s (%127[A-Za-z0-9/:]), Length:%9d, Pro:%9d, Off:%9d, Pri:%9d, RM:%9d, Err:%9d [%8x, %8x]\",\r\n\t\t\t&yy, &mm, &dd, &hr, &min, &sec, &csec,\r\n\t\t\t\t   direction, if_name, &pkt_len,\r\n\t\t\t\t   &pro, &off, &pri, &rm, &error,\r\n\t\t\t\t   &code1, &code2);\r\n\r\n\t\tif (num_items_scanned != 17) {\r\n\t\t\t*err = WTAP_ERR_BAD_FILE;\r\n\t\t\t*err_info = g_strdup(\"cosine: purported control blade line doesn't have code values\");\r\n\t\t\treturn false;\r\n\t\t}\r\n\t} else {\r\n\t\t/* appears to be output to PE */\r\n\t\tnum_items_scanned = sscanf(line,\r\n\t\t   \"%5s (%127[A-Za-z0-9/:]), Length:%9d, Pro:%9d, Off:%9d, Pri:%9d, RM:%9d, Err:%9d [%8x, %8x]\",\r\n\t\t\t\t   direction, if_name, &pkt_len,\r\n\t\t\t\t   &pro, &off, &pri, &rm, &error,\r\n\t\t\t\t   &code1, &code2);\r\n\r\n\t\tif (num_items_scanned != 10) {\r\n\t\t\t*err = WTAP_ERR_BAD_FILE;\r\n\t\t\t*err_info = g_strdup(\"cosine: header line is neither control blade nor PE output\");\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tyy = mm = dd = hr = min = sec = csec = 0;\r\n\t}\r\n\tif (pkt_len < 0) {\r\n\t\t*err = WTAP_ERR_BAD_FILE;\r\n\t\t*err_info = g_strdup(\"cosine: packet header has a negative packet length\");\r\n\t\treturn false;\r\n\t}\r\n\tif ((unsigned)pkt_len > WTAP_MAX_PACKET_SIZE_STANDARD) {\r\n\t\t/*\r\n\t\t * Probably a corrupt capture file; don't blow up trying\r\n\t\t * to allocate space for an immensely-large packet.\r\n\t\t */\r\n\t\t*err = WTAP_ERR_BAD_FILE;\r\n\t\t*err_info = ws_strdup_printf(\"cosine: File has %u-byte packet, bigger than maximum of %u\",\r\n\t\t    (unsigned)pkt_len, WTAP_MAX_PACKET_SIZE_STANDARD);\r\n\t\treturn false;\r\n\t}\r\n\r\n\trec->rec_type = REC_TYPE_PACKET;\r\n\trec->block = wtap_block_create(WTAP_BLOCK_PACKET);\r\n\trec->presence_flags = WTAP_HAS_TS|WTAP_HAS_CAP_LEN;\r\n\ttm.tm_year = yy - 1900;\r\n\ttm.tm_mon = mm - 1;\r\n\ttm.tm_mday = dd;\r\n\ttm.tm_hour = hr;\r\n\ttm.tm_min = min;\r\n\ttm.tm_sec = sec;\r\n\ttm.tm_isdst = -1;\r\n\trec->ts.secs = mktime(&tm);\r\n\trec->ts.nsecs = csec * 10000000;\r\n\trec->rec_header.packet_header.len = pkt_len;\r\n\r\n\t/* XXX need to handle other encapsulations like Cisco HDLC,\r\n\t   Frame Relay and ATM */\r\n\tif (strncmp(if_name, \"TEST:\", 5) == 0) {\r\n\t\tpseudo_header->cosine.encap = COSINE_ENCAP_TEST;\r\n\t} else if (strncmp(if_name, \"PPoATM:\", 7) == 0) {\r\n\t\tpseudo_header->cosine.encap = COSINE_ENCAP_PPoATM;\r\n\t} else if (strncmp(if_name, \"PPoFR:\", 6) == 0) {\r\n\t\tpseudo_header->cosine.encap = COSINE_ENCAP_PPoFR;\r\n\t} else if (strncmp(if_name, \"ATM:\", 4) == 0) {\r\n\t\tpseudo_header->cosine.encap = COSINE_ENCAP_ATM;\r\n\t} else if (strncmp(if_name, \"FR:\", 3) == 0) {\r\n\t\tpseudo_header->cosine.encap = COSINE_ENCAP_FR;\r\n\t} else if (strncmp(if_name, \"HDLC:\", 5) == 0) {\r\n\t\tpseudo_header->cosine.encap = COSINE_ENCAP_HDLC;\r\n\t} else if (strncmp(if_name, \"PPP:\", 4) == 0) {\r\n\t\tpseudo_header->cosine.encap = COSINE_ENCAP_PPP;\r\n\t} else if (strncmp(if_name, \"ETH:\", 4) == 0) {\r\n\t\tpseudo_header->cosine.encap = COSINE_ENCAP_ETH;\r\n\t} else {\r\n\t\tpseudo_header->cosine.encap = COSINE_ENCAP_UNKNOWN;\r\n\t}\r\n\tif (strncmp(direction, \"l2-tx\", 5) == 0) {\r\n\t\tpseudo_header->cosine.direction = COSINE_DIR_TX;\r\n\t} else if (strncmp(direction, \"l2-rx\", 5) == 0) {\r\n\t\tpseudo_header->cosine.direction = COSINE_DIR_RX;\r\n\t}\r\n\t(void) g_strlcpy(pseudo_header->cosine.if_name, if_name,\r\n\t\tCOSINE_MAX_IF_NAME_LEN);\r\n\tpseudo_header->cosine.pro = pro;\r\n\tpseudo_header->cosine.off = off;\r\n\tpseudo_header->cosine.pri = pri;\r\n\tpseudo_header->cosine.rm = rm;\r\n\tpseudo_header->cosine.err = error;\r\n\r\n\t/* Make sure we have enough room for the packet */\r\n\tws_buffer_assure_space(&rec->data, pkt_len);\r\n\tpd = ws_buffer_start_ptr(&rec->data);\r\n\r\n\t/* Calculate the number of hex dump lines, each\r\n\t * containing 16 bytes of data */\r\n\thex_lines = pkt_len / 16 + ((pkt_len % 16) ? 1 : 0);\r\n\r\n\tfor (i = 0; i < hex_lines; i++) {\r\n\t\tif (file_gets(line, COSINE_LINE_LENGTH, fh) == NULL) {\r\n\t\t\t*err = file_error(fh, err_info);\r\n\t\t\tif (*err == 0) {\r\n\t\t\t\t*err = WTAP_ERR_SHORT_READ;\r\n\t\t\t}\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tif (empty_line(line)) {\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tif ((n = parse_single_hex_dump_line(line, pd, i*16)) == -1) {\r\n\t\t\t*err = WTAP_ERR_BAD_FILE;\r\n\t\t\t*err_info = g_strdup(\"cosine: hex dump line doesn't have 16 numbers\");\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tcaplen += n;\r\n\t}\r\n\trec->rec_header.packet_header.caplen = caplen;\r\n\treturn true;\r\n}", ".osine_read": "static bool cosine_read(wtap *wth, wtap_rec *rec,\r\n    int *err, char **err_info, int64_t *data_offset)\r\n{\r\n\tint64_t\toffset;\r\n\tchar\tline[COSINE_LINE_LENGTH];\r\n\r\n\t/* Find the next packet */\r\n\toffset = cosine_seek_next_packet(wth, err, err_info, line);\r\n\tif (offset < 0)\r\n\t\treturn false;\r\n\t*data_offset = offset;\r\n\r\n\t/* Parse the header and convert the ASCII hex dump to binary data */\r\n\treturn parse_cosine_packet(wth->fh, rec, line, err, err_info);\r\n}", ".osine_open": "wtap_open_return_val cosine_open(wtap *wth, int *err, char **err_info)\r\n{\r\n\t/* Look for CoSine header */\r\n\tif (!cosine_check_file_type(wth, err, err_info)) {\r\n\t\tif (*err != 0 && *err != WTAP_ERR_SHORT_READ)\r\n\t\t\treturn WTAP_OPEN_ERROR;\r\n\t\treturn WTAP_OPEN_NOT_MINE;\r\n\t}\r\n\r\n\tif (file_seek(wth->fh, 0L, SEEK_SET, err) == -1)\t/* rewind */\r\n\t\treturn WTAP_OPEN_ERROR;\r\n\r\n\twth->file_encap = WTAP_ENCAP_COSINE;\r\n\twth->file_type_subtype = cosine_file_type_subtype;\r\n\twth->snapshot_length = 0; /* not known */\r\n\twth->subtype_read = cosine_read;\r\n\twth->subtype_seek_read = cosine_seek_read;\r\n\twth->file_tsprec = WTAP_TSPREC_10_MSEC;\r\n\r\n\t/*\r\n\t * Add an IDB; we don't know how many interfaces were\r\n\t * involved, so we just say one interface, about which\r\n\t * we only know the link-layer type, snapshot length,\r\n\t * and time stamp resolution.\r\n\t */\r\n\twtap_add_generated_idb(wth);\r\n\r\n\treturn WTAP_OPEN_MINE;\r\n}", ".osine_seek_read": "static bool\r\ncosine_seek_read(wtap *wth, int64_t seek_off, wtap_rec *rec,\r\n\tint *err, char **err_info)\r\n{\r\n\tchar\tline[COSINE_LINE_LENGTH];\r\n\r\n\tif (file_seek(wth->random_fh, seek_off, SEEK_SET, err) == -1)\r\n\t\treturn false;\r\n\r\n\tif (file_gets(line, COSINE_LINE_LENGTH, wth->random_fh) == NULL) {\r\n\t\t*err = file_error(wth->random_fh, err_info);\r\n\t\tif (*err == 0) {\r\n\t\t\t*err = WTAP_ERR_SHORT_READ;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\t/* Parse the header and convert the ASCII hex dump to binary data */\r\n\treturn parse_cosine_packet(wth->random_fh, rec, line, err, err_info);\r\n}"}, "function_name": "register_cosine"}
{"function_id": null, "caller": {}, "callee": {}, "function_name": "main"}
{"function_id": null, "caller": {}, "callee": {}, "function_name": "gdGuessBackgroundColorFromCorners"}
{"function_id": null, "caller": {".etscreen_check_file_type": "static bool netscreen_check_file_type(wtap *wth, int *err, char **err_info)\r\n{\r\n\tchar\tbuf[NETSCREEN_LINE_LENGTH];\r\n\tunsigned\treclen, line;\r\n\r\n\tbuf[NETSCREEN_LINE_LENGTH-1] = '\\0';\r\n\r\n\tfor (line = 0; line < NETSCREEN_HEADER_LINES_TO_CHECK; line++) {\r\n\t\tif (file_gets(buf, NETSCREEN_LINE_LENGTH, wth->fh) == NULL) {\r\n\t\t\t/* EOF or error. */\r\n\t\t\t*err = file_error(wth->fh, err_info);\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\treclen = (unsigned) strlen(buf);\r\n\t\tif (reclen < MIN(strlen(NETSCREEN_HDR_MAGIC_STR1), strlen(NETSCREEN_HDR_MAGIC_STR2))) {\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\tif (strstr(buf, NETSCREEN_HDR_MAGIC_STR1) ||\r\n\t\t    strstr(buf, NETSCREEN_HDR_MAGIC_STR2)) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t}\r\n\t*err = 0;\r\n\treturn false;\r\n}", ".etscreen_read": "static bool netscreen_read(wtap *wth, wtap_rec *rec,\r\n    int *err, char **err_info, int64_t *data_offset)\r\n{\r\n\tint64_t\t\toffset;\r\n\tchar\t\tline[NETSCREEN_LINE_LENGTH];\r\n\r\n\t/* Find the next packet */\r\n\toffset = netscreen_seek_next_packet(wth, err, err_info, line);\r\n\tif (offset < 0)\r\n\t\treturn false;\r\n\r\n\t/* Parse the header and convert the ASCII hex dump to binary data */\r\n\tif (!parse_netscreen_packet(wth->fh, rec, line, err, err_info))\r\n\t\treturn false;\r\n\r\n\t/*\r\n\t * If the per-file encapsulation isn't known, set it to this\r\n\t * packet's encapsulation.\r\n\t *\r\n\t * If it *is* known, and it isn't this packet's encapsulation,\r\n\t * set it to WTAP_ENCAP_PER_PACKET, as this file doesn't\r\n\t * have a single encapsulation for all packets in the file.\r\n\t */\r\n\tif (wth->file_encap == WTAP_ENCAP_UNKNOWN)\r\n\t\twth->file_encap = rec->rec_header.packet_header.pkt_encap;\r\n\telse {\r\n\t\tif (wth->file_encap != rec->rec_header.packet_header.pkt_encap)\r\n\t\t\twth->file_encap = WTAP_ENCAP_PER_PACKET;\r\n\t}\r\n\r\n\t*data_offset = offset;\r\n\treturn true;\r\n}", ".etscreen_seek_read": "static bool\r\nnetscreen_seek_read(wtap *wth, int64_t seek_off, wtap_rec *rec,\r\n\tint *err, char **err_info)\r\n{\r\n\tchar\t\tline[NETSCREEN_LINE_LENGTH];\r\n\r\n\tif (file_seek(wth->random_fh, seek_off, SEEK_SET, err) == -1) {\r\n\t\treturn false;\r\n\t}\r\n\r\n\tif (file_gets(line, NETSCREEN_LINE_LENGTH, wth->random_fh) == NULL) {\r\n\t\t*err = file_error(wth->random_fh, err_info);\r\n\t\tif (*err == 0) {\r\n\t\t\t*err = WTAP_ERR_SHORT_READ;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\treturn parse_netscreen_packet(wth->random_fh, rec, line,\r\n\t    err, err_info);\r\n}", ".etscreen_seek_next_packet": "static int64_t netscreen_seek_next_packet(wtap *wth, int *err, char **err_info,\r\n    char *hdr)\r\n{\r\n\tint64_t cur_off;\r\n\tchar buf[NETSCREEN_LINE_LENGTH];\r\n\r\n\twhile (1) {\r\n\t\tcur_off = file_tell(wth->fh);\r\n\t\tif (cur_off == -1) {\r\n\t\t\t/* Error */\r\n\t\t\t*err = file_error(wth->fh, err_info);\r\n\t\t\treturn -1;\r\n\t\t}\r\n\t\tif (file_gets(buf, sizeof(buf), wth->fh) == NULL) {\r\n\t\t\t/* EOF or error. */\r\n\t\t\t*err = file_error(wth->fh, err_info);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tif (strstr(buf, NETSCREEN_REC_MAGIC_STR1) ||\r\n\t\t    strstr(buf, NETSCREEN_REC_MAGIC_STR2)) {\r\n\t\t\t(void) g_strlcpy(hdr, buf, NETSCREEN_LINE_LENGTH);\r\n\t\t\treturn cur_off;\r\n\t\t}\r\n\t}\r\n\treturn -1;\r\n}", ".arse_netscreen_packet": "static bool\r\nparse_netscreen_packet(FILE_T fh, wtap_rec *rec, char *line,\r\n    int *err, char **err_info)\r\n{\r\n\tunsigned\t\tpkt_len;\r\n\tint\t\tsec;\r\n\tint\t\tdsec;\r\n\tchar\t\tcap_int[NETSCREEN_MAX_INT_NAME_LENGTH];\r\n\tchar\t\tdirection[2];\r\n\tchar\t\tcap_src[13];\r\n\tchar\t\tcap_dst[13];\r\n\tuint8_t\t\t*pd;\r\n\tchar\t\t*p;\r\n\tint\t\tn, i = 0;\r\n\tint\t\toffset = 0;\r\n\tchar\t\tdststr[13];\r\n\r\n\twtap_setup_packet_rec(rec, WTAP_ENCAP_UNKNOWN);\r\n\trec->block = wtap_block_create(WTAP_BLOCK_PACKET);\r\n\trec->presence_flags = WTAP_HAS_TS|WTAP_HAS_CAP_LEN;\r\n\t/* Suppress compiler warnings */\r\n\tmemset(cap_int, 0, sizeof(cap_int));\r\n\tmemset(cap_dst, 0, sizeof(cap_dst));\r\n\r\n\tif (sscanf(line, \"%9d.%9d: %15[a-z0-9/:.-](%1[io]) len=%9u:%12s->%12s/\",\r\n\t\t   &sec, &dsec, cap_int, direction, &pkt_len, cap_src, cap_dst) < 5) {\r\n\t\t*err = WTAP_ERR_BAD_FILE;\r\n\t\t*err_info = g_strdup(\"netscreen: Can't parse packet-header\");\r\n\t\treturn -1;\r\n\t}\r\n\tif (pkt_len > WTAP_MAX_PACKET_SIZE_STANDARD) {\r\n\t\t/*\r\n\t\t * Probably a corrupt capture file; don't blow up trying\r\n\t\t * to allocate space for an immensely-large packet.\r\n\t\t */\r\n\t\t*err = WTAP_ERR_BAD_FILE;\r\n\t\t*err_info = ws_strdup_printf(\"netscreen: File has %u-byte packet, bigger than maximum of %u\",\r\n\t\t    pkt_len, WTAP_MAX_PACKET_SIZE_STANDARD);\r\n\t\treturn false;\r\n\t}\r\n\r\n\t/*\r\n\t * If direction[0] is 'o', the direction is NETSCREEN_EGRESS,\r\n\t * otherwise it's NETSCREEN_INGRESS.\r\n\t */\r\n\r\n\trec->ts.secs  = sec;\r\n\trec->ts.nsecs = dsec * 100000000;\r\n\trec->rec_header.packet_header.len = pkt_len;\r\n\r\n\t/* Make sure we have enough room for the packet */\r\n\tws_buffer_assure_space(&rec->data, pkt_len);\r\n\tpd = ws_buffer_start_ptr(&rec->data);\r\n\r\n\twhile(1) {\r\n\r\n\t\t/* The last packet is not delimited by an empty line, but by EOF\r\n\t\t * So accept EOF as a valid delimiter too\r\n\t\t */\r\n\t\tif (file_gets(line, NETSCREEN_LINE_LENGTH, fh) == NULL) {\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\t/*\r\n\t\t * Skip blanks.\r\n\t\t * The number of blanks is not fixed - for wireless\r\n\t\t * interfaces, there may be 14 extra spaces before\r\n\t\t * the hex data.\r\n\t\t */\r\n\t\tfor (p = &line[0]; g_ascii_isspace(*p); p++)\r\n\t\t\t;\r\n\t\t/* packets are delimited with empty lines */\r\n\t\tif (*p == '\\0') {\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\tn = parse_single_hex_dump_line(p, pd, offset, pkt_len);\r\n\r\n\t\t/*\r\n\t\t * The smallest packet has a length of 6 bytes.\r\n\t\t * If the first line either gets an error when\r\n\t\t * parsed as hex data, or has fewer than 6\r\n\t\t * bytes of hex data, check whether it's an\r\n\t\t * info line by see if it has at least\r\n\t\t * NETSCREEN_SPACES_ON_INFO_LINE spaces at the\r\n\t\t * beginning.\r\n\t\t *\r\n\t\t * If it does, count this line and, if we have,\r\n\t\t * so far, skipped no more than NETSCREEN_MAX_INFOLINES\r\n\t\t * lines, skip this line.\r\n\t\t */\r\n\t\tif (offset == 0 && n < 6) {\r\n\t\t\tif (info_line(line)) {\r\n\t\t\t\t/* Info line */\r\n\t\t\t\tif (++i <= NETSCREEN_MAX_INFOLINES) {\r\n\t\t\t\t\t/* Skip this line */\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tif (n >= 0) {\r\n\t\t\t\t\t*err = WTAP_ERR_BAD_FILE;\r\n\t\t\t\t\t*err_info = g_strdup(\"netscreen: first line of packet data has only %d hex bytes, < 6\");\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t\t/* Otherwise, fall through to report error */\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t/* If there is no more data and the line was not empty,\r\n\t\t * then there must be an error in the file\r\n\t\t */\r\n\t\tif (n < 0) {\r\n\t\t\tswitch (n) {\r\n\r\n\t\t\tcase PARSE_LINE_INVALID_CHARACTER:\r\n\t\t\t\t*err = WTAP_ERR_BAD_FILE;\r\n\t\t\t\t*err_info = g_strdup(\"netscreen: invalid character in hex data\");\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase PARSE_LINE_NO_BYTES_SEEN:\r\n\t\t\t\t*err = WTAP_ERR_BAD_FILE;\r\n\t\t\t\t*err_info = g_strdup(\"netscreen: no hex bytes seen in hex data\");\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase PARSE_LINE_TOO_MANY_BYTES_SEEN:\r\n\t\t\t\t*err = WTAP_ERR_BAD_FILE;\r\n\t\t\t\t*err_info = g_strdup(\"netscreen: number of hex bytes seen in hex data is greater than the packet length\");\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tdefault:\r\n\t\t\t\t*err = WTAP_ERR_INTERNAL;\r\n\t\t\t\t*err_info = g_strdup_printf(\"netscreen: unknown error %d from parse_single_hex_dump_line()\", n);\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\t/* Adjust the offset to the data that was just added to the buffer */\r\n\t\toffset += n;\r\n\r\n\t}\r\n\r\n\t/*\r\n\t * Determine the encapsulation type, based on the\r\n\t * first 4 characters of the interface name\r\n\t *\r\n\t * XXX\tconvert this to a 'case' structure when adding more\r\n\t *\t(non-ethernet) interfacetypes\r\n\t */\r\n\tif (strncmp(cap_int, \"adsl\", 4) == 0) {\r\n\t\t/* The ADSL interface can be bridged with or without\r\n\t\t * PPP encapsulation. Check whether the first six bytes\r\n\t\t * of the hex data are the same as the destination mac\r\n\t\t * address in the header. If they are, assume ethernet\r\n\t\t * LinkLayer or else PPP\r\n\t\t */\r\n\t\tsnprintf(dststr, 13, \"%02x%02x%02x%02x%02x%02x\",\r\n\t\t   pd[0], pd[1], pd[2], pd[3], pd[4], pd[5]);\r\n\t\tif (strncmp(dststr, cap_dst, 12) == 0)\r\n\t\t\trec->rec_header.packet_header.pkt_encap = WTAP_ENCAP_ETHERNET;\r\n\t\telse\r\n\t\t\trec->rec_header.packet_header.pkt_encap = WTAP_ENCAP_PPP;\r\n\t\t}\r\n\telse if (strncmp(cap_int, \"seri\", 4) == 0)\r\n\t\trec->rec_header.packet_header.pkt_encap = WTAP_ENCAP_PPP;\r\n\telse\r\n\t\trec->rec_header.packet_header.pkt_encap = WTAP_ENCAP_ETHERNET;\r\n\r\n\trec->rec_header.packet_header.caplen = offset;\r\n\r\n\treturn true;\r\n}", ".arse_single_hex_dump_line": "static int\r\nparse_single_hex_dump_line(char* rec, uint8_t *buf, unsigned byte_offset, unsigned pkt_len)\r\n{\r\n\tint num_items_scanned;\r\n\tuint8_t character;\r\n\tuint8_t byte;\r\n\r\n\r\n\tfor (num_items_scanned = 0; num_items_scanned < 16; num_items_scanned++) {\r\n\t\tcharacter = *rec++;\r\n\t\tif (character >= '0' && character <= '9')\r\n\t\t\tbyte = character - '0' + 0;\r\n\t\telse if (character >= 'A' && character <= 'F')\r\n\t\t\tbyte = character - 'A' + 0xA;\r\n\t\telse if (character >= 'a' && character <= 'f')\r\n\t\t\tbyte = character - 'a' + 0xa;\r\n\t\telse if (character == ' ' || character == '\\r' || character == '\\n' || character == '\\0') {\r\n\t\t\t/* Nothing more to parse */\r\n\t\t\tbreak;\r\n\t\t} else\r\n\t\t\treturn PARSE_LINE_INVALID_CHARACTER; /* not a hex digit, space before ASCII dump, or EOL */\r\n\t\tbyte <<= 4;\r\n\t\tcharacter = *rec++ & 0xFF;\r\n\t\tif (character >= '0' && character <= '9')\r\n\t\t\tbyte += character - '0' + 0;\r\n\t\telse if (character >= 'A' && character <= 'F')\r\n\t\t\tbyte += character - 'A' + 0xA;\r\n\t\telse if (character >= 'a' && character <= 'f')\r\n\t\t\tbyte += character - 'a' + 0xa;\r\n\t\telse\r\n\t\t\treturn PARSE_LINE_INVALID_CHARACTER; /* not a hex digit */\r\n\r\n\t\t/* If there was more hex-data than was announced in the len=x\r\n\t\t * header, then there must be an error in the file; quit\r\n\t\t * now, as adding this byte will overflow the buffer.\r\n\t\t */\r\n\t\tif (byte_offset + num_items_scanned >= pkt_len) {\r\n\t\t\treturn PARSE_LINE_TOO_MANY_BYTES_SEEN;\r\n\t\t}\r\n\r\n\t\tbuf[byte_offset + num_items_scanned] = byte;\r\n\t\tcharacter = *rec++ & 0xFF;\r\n\t\tif (character == '\\0' || character == '\\r' || character == '\\n') {\r\n\t\t\t/* Nothing more to parse */\r\n\t\t\tbreak;\r\n\t\t} else if (character != ' ') {\r\n\t\t\t/* not space before ASCII dump */\r\n\t\t\treturn PARSE_LINE_INVALID_CHARACTER;\r\n\t\t}\r\n\t}\r\n\tif (num_items_scanned == 0)\r\n\t\treturn PARSE_LINE_NO_BYTES_SEEN;\r\n\r\n\treturn num_items_scanned;\r\n}", ".nfo_line": "static bool info_line(const char *line)\r\n{\r\n\tint i=NETSCREEN_SPACES_ON_INFO_LINE;\r\n\r\n\twhile (i-- > 0) {\r\n\t\tif (g_ascii_isspace(*line)) {\r\n\t\t\tline++;\r\n\t\t\tcontinue;\r\n\t\t} else {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\treturn true;\r\n}"}, "callee": {".arse_netscreen_packet": "static bool\r\nparse_netscreen_packet(FILE_T fh, wtap_rec *rec, char *line,\r\n    int *err, char **err_info)\r\n{\r\n\tunsigned\t\tpkt_len;\r\n\tint\t\tsec;\r\n\tint\t\tdsec;\r\n\tchar\t\tcap_int[NETSCREEN_MAX_INT_NAME_LENGTH];\r\n\tchar\t\tdirection[2];\r\n\tchar\t\tcap_src[13];\r\n\tchar\t\tcap_dst[13];\r\n\tuint8_t\t\t*pd;\r\n\tchar\t\t*p;\r\n\tint\t\tn, i = 0;\r\n\tint\t\toffset = 0;\r\n\tchar\t\tdststr[13];\r\n\r\n\twtap_setup_packet_rec(rec, WTAP_ENCAP_UNKNOWN);\r\n\trec->block = wtap_block_create(WTAP_BLOCK_PACKET);\r\n\trec->presence_flags = WTAP_HAS_TS|WTAP_HAS_CAP_LEN;\r\n\t/* Suppress compiler warnings */\r\n\tmemset(cap_int, 0, sizeof(cap_int));\r\n\tmemset(cap_dst, 0, sizeof(cap_dst));\r\n\r\n\tif (sscanf(line, \"%9d.%9d: %15[a-z0-9/:.-](%1[io]) len=%9u:%12s->%12s/\",\r\n\t\t   &sec, &dsec, cap_int, direction, &pkt_len, cap_src, cap_dst) < 5) {\r\n\t\t*err = WTAP_ERR_BAD_FILE;\r\n\t\t*err_info = g_strdup(\"netscreen: Can't parse packet-header\");\r\n\t\treturn -1;\r\n\t}\r\n\tif (pkt_len > WTAP_MAX_PACKET_SIZE_STANDARD) {\r\n\t\t/*\r\n\t\t * Probably a corrupt capture file; don't blow up trying\r\n\t\t * to allocate space for an immensely-large packet.\r\n\t\t */\r\n\t\t*err = WTAP_ERR_BAD_FILE;\r\n\t\t*err_info = ws_strdup_printf(\"netscreen: File has %u-byte packet, bigger than maximum of %u\",\r\n\t\t    pkt_len, WTAP_MAX_PACKET_SIZE_STANDARD);\r\n\t\treturn false;\r\n\t}\r\n\r\n\t/*\r\n\t * If direction[0] is 'o', the direction is NETSCREEN_EGRESS,\r\n\t * otherwise it's NETSCREEN_INGRESS.\r\n\t */\r\n\r\n\trec->ts.secs  = sec;\r\n\trec->ts.nsecs = dsec * 100000000;\r\n\trec->rec_header.packet_header.len = pkt_len;\r\n\r\n\t/* Make sure we have enough room for the packet */\r\n\tws_buffer_assure_space(&rec->data, pkt_len);\r\n\tpd = ws_buffer_start_ptr(&rec->data);\r\n\r\n\twhile(1) {\r\n\r\n\t\t/* The last packet is not delimited by an empty line, but by EOF\r\n\t\t * So accept EOF as a valid delimiter too\r\n\t\t */\r\n\t\tif (file_gets(line, NETSCREEN_LINE_LENGTH, fh) == NULL) {\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\t/*\r\n\t\t * Skip blanks.\r\n\t\t * The number of blanks is not fixed - for wireless\r\n\t\t * interfaces, there may be 14 extra spaces before\r\n\t\t * the hex data.\r\n\t\t */\r\n\t\tfor (p = &line[0]; g_ascii_isspace(*p); p++)\r\n\t\t\t;\r\n\t\t/* packets are delimited with empty lines */\r\n\t\tif (*p == '\\0') {\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\tn = parse_single_hex_dump_line(p, pd, offset, pkt_len);\r\n\r\n\t\t/*\r\n\t\t * The smallest packet has a length of 6 bytes.\r\n\t\t * If the first line either gets an error when\r\n\t\t * parsed as hex data, or has fewer than 6\r\n\t\t * bytes of hex data, check whether it's an\r\n\t\t * info line by see if it has at least\r\n\t\t * NETSCREEN_SPACES_ON_INFO_LINE spaces at the\r\n\t\t * beginning.\r\n\t\t *\r\n\t\t * If it does, count this line and, if we have,\r\n\t\t * so far, skipped no more than NETSCREEN_MAX_INFOLINES\r\n\t\t * lines, skip this line.\r\n\t\t */\r\n\t\tif (offset == 0 && n < 6) {\r\n\t\t\tif (info_line(line)) {\r\n\t\t\t\t/* Info line */\r\n\t\t\t\tif (++i <= NETSCREEN_MAX_INFOLINES) {\r\n\t\t\t\t\t/* Skip this line */\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tif (n >= 0) {\r\n\t\t\t\t\t*err = WTAP_ERR_BAD_FILE;\r\n\t\t\t\t\t*err_info = g_strdup(\"netscreen: first line of packet data has only %d hex bytes, < 6\");\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t\t/* Otherwise, fall through to report error */\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t/* If there is no more data and the line was not empty,\r\n\t\t * then there must be an error in the file\r\n\t\t */\r\n\t\tif (n < 0) {\r\n\t\t\tswitch (n) {\r\n\r\n\t\t\tcase PARSE_LINE_INVALID_CHARACTER:\r\n\t\t\t\t*err = WTAP_ERR_BAD_FILE;\r\n\t\t\t\t*err_info = g_strdup(\"netscreen: invalid character in hex data\");\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase PARSE_LINE_NO_BYTES_SEEN:\r\n\t\t\t\t*err = WTAP_ERR_BAD_FILE;\r\n\t\t\t\t*err_info = g_strdup(\"netscreen: no hex bytes seen in hex data\");\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase PARSE_LINE_TOO_MANY_BYTES_SEEN:\r\n\t\t\t\t*err = WTAP_ERR_BAD_FILE;\r\n\t\t\t\t*err_info = g_strdup(\"netscreen: number of hex bytes seen in hex data is greater than the packet length\");\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tdefault:\r\n\t\t\t\t*err = WTAP_ERR_INTERNAL;\r\n\t\t\t\t*err_info = g_strdup_printf(\"netscreen: unknown error %d from parse_single_hex_dump_line()\", n);\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\t/* Adjust the offset to the data that was just added to the buffer */\r\n\t\toffset += n;\r\n\r\n\t}\r\n\r\n\t/*\r\n\t * Determine the encapsulation type, based on the\r\n\t * first 4 characters of the interface name\r\n\t *\r\n\t * XXX\tconvert this to a 'case' structure when adding more\r\n\t *\t(non-ethernet) interfacetypes\r\n\t */\r\n\tif (strncmp(cap_int, \"adsl\", 4) == 0) {\r\n\t\t/* The ADSL interface can be bridged with or without\r\n\t\t * PPP encapsulation. Check whether the first six bytes\r\n\t\t * of the hex data are the same as the destination mac\r\n\t\t * address in the header. If they are, assume ethernet\r\n\t\t * LinkLayer or else PPP\r\n\t\t */\r\n\t\tsnprintf(dststr, 13, \"%02x%02x%02x%02x%02x%02x\",\r\n\t\t   pd[0], pd[1], pd[2], pd[3], pd[4], pd[5]);\r\n\t\tif (strncmp(dststr, cap_dst, 12) == 0)\r\n\t\t\trec->rec_header.packet_header.pkt_encap = WTAP_ENCAP_ETHERNET;\r\n\t\telse\r\n\t\t\trec->rec_header.packet_header.pkt_encap = WTAP_ENCAP_PPP;\r\n\t\t}\r\n\telse if (strncmp(cap_int, \"seri\", 4) == 0)\r\n\t\trec->rec_header.packet_header.pkt_encap = WTAP_ENCAP_PPP;\r\n\telse\r\n\t\trec->rec_header.packet_header.pkt_encap = WTAP_ENCAP_ETHERNET;\r\n\r\n\trec->rec_header.packet_header.caplen = offset;\r\n\r\n\treturn true;\r\n}", ".etscreen_read": "static bool netscreen_read(wtap *wth, wtap_rec *rec,\r\n    int *err, char **err_info, int64_t *data_offset)\r\n{\r\n\tint64_t\t\toffset;\r\n\tchar\t\tline[NETSCREEN_LINE_LENGTH];\r\n\r\n\t/* Find the next packet */\r\n\toffset = netscreen_seek_next_packet(wth, err, err_info, line);\r\n\tif (offset < 0)\r\n\t\treturn false;\r\n\r\n\t/* Parse the header and convert the ASCII hex dump to binary data */\r\n\tif (!parse_netscreen_packet(wth->fh, rec, line, err, err_info))\r\n\t\treturn false;\r\n\r\n\t/*\r\n\t * If the per-file encapsulation isn't known, set it to this\r\n\t * packet's encapsulation.\r\n\t *\r\n\t * If it *is* known, and it isn't this packet's encapsulation,\r\n\t * set it to WTAP_ENCAP_PER_PACKET, as this file doesn't\r\n\t * have a single encapsulation for all packets in the file.\r\n\t */\r\n\tif (wth->file_encap == WTAP_ENCAP_UNKNOWN)\r\n\t\twth->file_encap = rec->rec_header.packet_header.pkt_encap;\r\n\telse {\r\n\t\tif (wth->file_encap != rec->rec_header.packet_header.pkt_encap)\r\n\t\t\twth->file_encap = WTAP_ENCAP_PER_PACKET;\r\n\t}\r\n\r\n\t*data_offset = offset;\r\n\treturn true;\r\n}", ".etscreen_open": "wtap_open_return_val netscreen_open(wtap *wth, int *err, char **err_info)\r\n{\r\n\r\n\t/* Look for a NetScreen snoop header line */\r\n\tif (!netscreen_check_file_type(wth, err, err_info)) {\r\n\t\tif (*err != 0 && *err != WTAP_ERR_SHORT_READ)\r\n\t\t\treturn WTAP_OPEN_ERROR;\r\n\t\treturn WTAP_OPEN_NOT_MINE;\r\n\t}\r\n\r\n\tif (file_seek(wth->fh, 0L, SEEK_SET, err) == -1)\t/* rewind */\r\n\t\treturn WTAP_OPEN_ERROR;\r\n\r\n\twth->file_encap = WTAP_ENCAP_UNKNOWN;\r\n\twth->file_type_subtype = netscreen_file_type_subtype;\r\n\twth->snapshot_length = 0; /* not known */\r\n\twth->subtype_read = netscreen_read;\r\n\twth->subtype_seek_read = netscreen_seek_read;\r\n\twth->file_tsprec = WTAP_TSPREC_100_MSEC;\r\n\r\n\treturn WTAP_OPEN_MINE;\r\n}", ".etscreen_seek_read": "static bool\r\nnetscreen_seek_read(wtap *wth, int64_t seek_off, wtap_rec *rec,\r\n\tint *err, char **err_info)\r\n{\r\n\tchar\t\tline[NETSCREEN_LINE_LENGTH];\r\n\r\n\tif (file_seek(wth->random_fh, seek_off, SEEK_SET, err) == -1) {\r\n\t\treturn false;\r\n\t}\r\n\r\n\tif (file_gets(line, NETSCREEN_LINE_LENGTH, wth->random_fh) == NULL) {\r\n\t\t*err = file_error(wth->random_fh, err_info);\r\n\t\tif (*err == 0) {\r\n\t\t\t*err = WTAP_ERR_SHORT_READ;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\treturn parse_netscreen_packet(wth->random_fh, rec, line,\r\n\t    err, err_info);\r\n}"}, "function_name": "register_netscreen"}
{"function_id": null, "caller": {".y_login": "static int my_login(pTHX_ SV* dbh, imp_dbh_t *imp_dbh)\r\n{\r\n  SV* sv;\r\n  HV* hv;\r\n  char* dbname;\r\n  char* host;\r\n  char* port;\r\n  char* user;\r\n  char* password;\r\n  char* mysql_socket;\r\n  int   result;\r\n  D_imp_xxh(dbh);\r\n\r\n  /* TODO- resolve this so that it is set only if DBI is 1.607 */\r\n#define TAKE_IMP_DATA_VERSION 1\r\n#if TAKE_IMP_DATA_VERSION\r\n  if (DBIc_has(imp_dbh, DBIcf_IMPSET))\r\n  { /* eg from take_imp_data() */\r\n    if (DBIc_has(imp_dbh, DBIcf_ACTIVE))\r\n    {\r\n      if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n        PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"my_login skip connect\\n\");\r\n      /* tell our parent we've adopted an active child */\r\n      ++DBIc_ACTIVE_KIDS(DBIc_PARENT_COM(imp_dbh));\r\n      return TRUE;\r\n    }\r\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                    \"my_login IMPSET but not ACTIVE so connect not skipped\\n\");\r\n  }\r\n#endif\r\n\r\n  sv = DBIc_IMP_DATA(imp_dbh);\r\n\r\n  if (!sv  ||  !SvROK(sv))\r\n    return FALSE;\r\n\r\n  hv = (HV*) SvRV(sv);\r\n  if (SvTYPE(hv) != SVt_PVHV)\r\n    return FALSE;\r\n\r\n  host=\t\tsafe_hv_fetch(aTHX_ hv, \"host\", 4);\r\n  port=\t\tsafe_hv_fetch(aTHX_ hv, \"port\", 4);\r\n  user=\t\tsafe_hv_fetch(aTHX_ hv, \"user\", 4);\r\n  password=\tsafe_hv_fetch(aTHX_ hv, \"password\", 8);\r\n  dbname=\tsafe_hv_fetch(aTHX_ hv, \"database\", 8);\r\n  mysql_socket=\tsafe_hv_fetch(aTHX_ hv, \"mysql_socket\", 12);\r\n\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n\t\t  \"imp_dbh->my_login : dbname = %s, uid = %s, pwd = %s,\" \\\r\n\t\t  \"host = %s, port = %s\\n\",\r\n\t\t  dbname ? dbname : \"NULL\",\r\n\t\t  user ? user : \"NULL\",\r\n\t\t  password ? password : \"NULL\",\r\n\t\t  host ? host : \"NULL\",\r\n\t\t  port ? port : \"NULL\");\r\n\r\n  if (!imp_dbh->pmysql) {\r\n     Newz(908, imp_dbh->pmysql, 1, MYSQL);\r\n     imp_dbh->pmysql->net.fd = -1;\r\n  }\r\n  result = mysql_dr_connect(dbh, imp_dbh->pmysql, mysql_socket, host, port, user,\r\n\t\t\t  password, dbname, imp_dbh) ? TRUE : FALSE;\r\n  return result;\r\n}", ".o_error": "void do_error(SV* h, int rc, const char* what, const char* sqlstate)\r\n{\r\n  dTHX;\r\n  D_imp_xxh(h);\r\n  SV *errstr;\r\n  SV *errstate;\r\n\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\t--> do_error\\n\");\r\n  errstr= DBIc_ERRSTR(imp_xxh);\r\n  sv_setiv(DBIc_ERR(imp_xxh), (IV)rc);\t/* set err early\t*/\r\n  sv_setpv(errstr, what);\r\n\r\n  if (sqlstate)\r\n  {\r\n    errstate= DBIc_STATE(imp_xxh);\r\n    sv_setpvn(errstate, sqlstate, 5);\r\n  }\r\n\r\n  /* NO EFFECT DBIh_EVENT2(h, ERROR_event, DBIc_ERR(imp_xxh), errstr); */\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"%s error %d recorded: %s\\n\",\r\n    what, rc, SvPV_nolen(errstr));\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\t<-- do_error\\n\");\r\n}", ".o_warn": "void do_warn(SV* h, int rc, char* what)\r\n{\r\n  dTHX;\r\n  D_imp_xxh(h);\r\n\r\n  SV *errstr = DBIc_ERRSTR(imp_xxh);\r\n  sv_setiv(DBIc_ERR(imp_xxh), (IV)rc);\t/* set err early\t*/\r\n  sv_setpv(errstr, what);\r\n  /* NO EFFECT DBIh_EVENT2(h, WARN_event, DBIc_ERR(imp_xxh), errstr);*/\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"%s warning %d recorded: %s\\n\",\r\n    what, rc, SvPV_nolen(errstr));\r\n  warn(\"%s\", what);\r\n}", ".bd_db_disconnect": "int dbd_db_disconnect(SV* dbh, imp_dbh_t* imp_dbh)\r\n{\r\n#ifdef dTHR\r\n  dTHR;\r\n#endif\r\n  dTHX;\r\n  D_imp_xxh(dbh);\r\n\r\n  /* We assume that disconnect will always work       */\r\n  /* since most errors imply already disconnected.    */\r\n  DBIc_ACTIVE_off(imp_dbh);\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"imp_dbh->pmysql: %p\\n\",\r\n\t\t              imp_dbh->pmysql);\r\n  mysql_close(imp_dbh->pmysql );\r\n  imp_dbh->pmysql->net.fd = -1;\r\n\r\n  /* We don't free imp_dbh since a reference still exists    */\r\n  /* The DESTROY method is the only one to 'free' memory.    */\r\n  return TRUE;\r\n}", ".ysql_st_free_result_sets": "int mysql_st_free_result_sets (SV * sth, imp_sth_t * imp_sth)\r\n{\r\n  dTHX;\r\n  D_imp_dbh_from_sth;\r\n  D_imp_xxh(sth);\r\n  int next_result_rc= -1;\r\n\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t>- dbd_st_free_result_sets\\n\");\r\n\r\n  do\r\n  {\r\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t<- dbd_st_free_result_sets RC %d\\n\", next_result_rc);\r\n\r\n    if (next_result_rc == 0)\r\n    {\r\n      if (!(imp_sth->result = mysql_use_result(imp_dbh->pmysql)))\r\n      {\r\n        /* Check for possible error */\r\n        if (mysql_field_count(imp_dbh->pmysql))\r\n        {\r\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n          PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t<- dbd_st_free_result_sets ERROR: %s\\n\",\r\n                                  mysql_error(imp_dbh->pmysql));\r\n\r\n          do_error(sth, mysql_errno(imp_dbh->pmysql), mysql_error(imp_dbh->pmysql),\r\n                   mysql_sqlstate(imp_dbh->pmysql));\r\n          return 0;\r\n        }\r\n      }\r\n    }\r\n    if (imp_sth->result)\r\n    {\r\n      mysql_free_result(imp_sth->result);\r\n      imp_sth->result=NULL;\r\n    }\r\n  } while ((next_result_rc=mysql_next_result(imp_dbh->pmysql))==0);\r\n\r\n  if (next_result_rc > 0)\r\n  {\r\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t<- dbd_st_free_result_sets: Error while processing multi-result set: %s\\n\",\r\n                    mysql_error(imp_dbh->pmysql));\r\n\r\n    do_error(sth, mysql_errno(imp_dbh->pmysql), mysql_error(imp_dbh->pmysql),\r\n             mysql_sqlstate(imp_dbh->pmysql));\r\n  }\r\n\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t<- dbd_st_free_result_sets\\n\");\r\n\r\n  return 1;\r\n}", ".ount_params": "static int\r\ncount_params(imp_xxh_t *imp_xxh, pTHX_ char *statement, bool bind_comment_placeholders)\r\n{\r\n  bool comment_end= false;\r\n  char* ptr= statement;\r\n  int num_params= 0;\r\n  int comment_length= 0;\r\n  char c;\r\n\r\n  if (DBIc_DBISTATE(imp_xxh)->debug >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \">count_params statement %s\\n\", statement);\r\n\r\n  while ( (c = *ptr++) )\r\n  {\r\n    switch (c) {\r\n      /* so, this is a -- comment, so let's burn up characters */\r\n    case '-':\r\n      {\r\n          if (bind_comment_placeholders)\r\n          {\r\n              c = *ptr++;\r\n              break;\r\n          }\r\n          else\r\n          {\r\n              comment_length= 1;\r\n              /* let's see if the next one is a dash */\r\n              c = *ptr++;\r\n\r\n              if  (c == '-') {\r\n                  /* if two dashes, ignore everything until newline */\r\n                  while ((c = *ptr))\r\n                  {\r\n                      if (DBIc_DBISTATE(imp_xxh)->debug >= 2)\r\n                          PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"%c\\n\", c);\r\n                      ptr++;\r\n                      comment_length++;\r\n                      if (c == '\\n')\r\n                      {\r\n                          comment_end= true;\r\n                          break;\r\n                      }\r\n                  }\r\n                  /*\r\n                    if not comment_end, the comment never ended and we need to iterate\r\n                    back to the beginning of where we started and let the database \r\n                    handle whatever is in the statement\r\n                */\r\n                  if (! comment_end)\r\n                      ptr-= comment_length;\r\n              }\r\n              /* otherwise, only one dash/hyphen, backtrack by one */\r\n              else\r\n                  ptr--;\r\n              break;\r\n          }\r\n      }\r\n    /* c-type comments */\r\n    case '/':\r\n      {\r\n          if (bind_comment_placeholders)\r\n          {\r\n              c = *ptr++;\r\n              break;\r\n          }\r\n          else\r\n          {\r\n              c = *ptr++;\r\n              /* let's check if the next one is an asterisk */\r\n              if  (c == '*')\r\n              {\r\n                  comment_length= 0;\r\n                  comment_end= false;\r\n                  /* ignore everything until closing comment */\r\n                  while ((c= *ptr))\r\n                  {\r\n                      ptr++;\r\n                      comment_length++;\r\n\r\n                      if (c == '*')\r\n                      {\r\n                          c = *ptr++;\r\n                          /* alas, end of comment */\r\n                          if (c == '/')\r\n                          {\r\n                              comment_end= true;\r\n                              break;\r\n                          }\r\n                          /*\r\n                            nope, just an asterisk, not so fast, not\r\n                            end of comment, go back one\r\n                        */\r\n                          else\r\n                              ptr--;\r\n                      }\r\n                  }\r\n                  /*\r\n                    if the end of the comment was never found, we have\r\n                    to backtrack to wherever we first started skipping\r\n                    over the possible comment.\r\n                    This means we will pass the statement to the database\r\n                    to see its own fate and issue the error\r\n                */\r\n                  if (!comment_end)\r\n                      ptr -= comment_length;\r\n              }\r\n              else\r\n                  ptr--;\r\n              break;\r\n          }\r\n      }\r\n    case '`':\r\n    case '\"':\r\n    case '\\'':\r\n      /* Skip string */\r\n      {\r\n        char end_token = c;\r\n        while ((c = *ptr)  &&  c != end_token)\r\n        {\r\n          if (c == '\\\\')\r\n            if (! *(++ptr))\r\n              continue;\r\n\r\n          ++ptr;\r\n        }\r\n        if (c)\r\n          ++ptr;\r\n        break;\r\n      }\r\n\r\n    case '?':\r\n      ++num_params;\r\n      break;\r\n\r\n    default:\r\n      break;\r\n    }\r\n  }\r\n  return num_params;\r\n}", ".ysql_db_reconnect": "int mysql_db_reconnect(SV* h)\r\n{\r\n  dTHX;\r\n  D_imp_xxh(h);\r\n  imp_dbh_t* imp_dbh;\r\n  MYSQL save_socket;\r\n\r\n  if (DBIc_DBISTATE(imp_xxh)->debug >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"reconnecting\\n\");\r\n\r\n  if (DBIc_TYPE(imp_xxh) == DBIt_ST)\r\n  {\r\n    imp_dbh = (imp_dbh_t*) DBIc_PARENT_COM(imp_xxh);\r\n    h = DBIc_PARENT_H(imp_xxh);\r\n  }\r\n  else\r\n    imp_dbh= (imp_dbh_t*) imp_xxh;\r\n\r\n  /* reconnect a closed connection, used in do() for implicit reconnect */\r\n  if (!DBIc_has(imp_dbh, DBIcf_ACTIVE) && DBIc_has(imp_dbh, DBIcf_AutoCommit)) {\r\n    if (my_login(aTHX_ h, imp_dbh)) {\r\n      DBIc_ACTIVE_on(imp_dbh);\r\n      DBIc_set(imp_dbh, DBIcf_AutoCommit, TRUE);\r\n      return TRUE;\r\n    }\r\n    return FALSE;\r\n  }\r\n\r\n  if (mysql_errno(imp_dbh->pmysql) != CR_SERVER_GONE_ERROR &&\r\n#ifdef ER_CLIENT_INTERACTION_TIMEOUT /* Added in 8.0.24 */\r\n          mysql_errno(imp_dbh->pmysql) != ER_CLIENT_INTERACTION_TIMEOUT &&\r\n#endif\r\n          mysql_errno(imp_dbh->pmysql) != CR_SERVER_LOST) {\r\n    /* Other error */\r\n    if (DBIc_DBISTATE(imp_xxh)->debug >= 2)\r\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"Can't reconnect on unexpected error %d\\n\",\r\n          mysql_errno(imp_dbh->pmysql));\r\n    return FALSE;\r\n  }\r\n\r\n  if (!DBIc_has(imp_dbh, DBIcf_AutoCommit) || !imp_dbh->auto_reconnect)\r\n  {\r\n    /* We never reconnect if AutoCommit is turned off.\r\n     * Otherwise we might get an inconsistent transaction\r\n     * state.\r\n     */\r\n    if (DBIc_DBISTATE(imp_xxh)->debug >= 2)\r\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"Can't reconnect as AutoCommit is turned off\\n\");\r\n    return FALSE;\r\n  }\r\n\r\n  /* my_login will blow away imp_dbh->mysql so we save a copy of\r\n   * imp_dbh->mysql and put it back where it belongs if the reconnect\r\n   * fail.  Think server is down & reconnect fails but the application eval{}s\r\n   * the execute, so next time $dbh->quote() gets called, instant SIGSEGV!\r\n   */\r\n  save_socket= *(imp_dbh->pmysql);\r\n  memcpy (&save_socket, imp_dbh->pmysql,sizeof(save_socket));\r\n  memset (imp_dbh->pmysql,0,sizeof(*(imp_dbh->pmysql)));\r\n\r\n  /* we should disconnect the db handle before reconnecting, this will\r\n   * prevent my_login from thinking it's adopting an active child which\r\n   * would prevent the handle from actually reconnecting\r\n   */\r\n  if (!dbd_db_disconnect(h, imp_dbh) || !my_login(aTHX_ h, imp_dbh))\r\n  {\r\n    do_error(h, mysql_errno(imp_dbh->pmysql), mysql_error(imp_dbh->pmysql),\r\n             mysql_sqlstate(imp_dbh->pmysql));\r\n    memcpy (imp_dbh->pmysql, &save_socket, sizeof(save_socket));\r\n    ++imp_dbh->stats.auto_reconnects_failed;\r\n    return FALSE;\r\n  }\r\n\r\n  /*\r\n   *  Tell DBI, that dbh->disconnect should be called for this handle\r\n   */\r\n  DBIc_ACTIVE_on(imp_dbh);\r\n\r\n  ++imp_dbh->stats.auto_reconnects_ok;\r\n  return TRUE;\r\n}", ".ysql_to_perl_type": "static enum enum_field_types mysql_to_perl_type(enum enum_field_types type)\r\n{\r\n  enum enum_field_types enum_type;\r\n\r\n  switch (type) {\r\n  case MYSQL_TYPE_DOUBLE:\r\n  case MYSQL_TYPE_FLOAT:\r\n    enum_type= MYSQL_TYPE_DOUBLE;\r\n    break;\r\n\r\n  case MYSQL_TYPE_SHORT:\r\n  case MYSQL_TYPE_TINY:\r\n  case MYSQL_TYPE_LONG:\r\n  case MYSQL_TYPE_INT24:\r\n  case MYSQL_TYPE_YEAR:\r\n#if IVSIZE >= 8\r\n  case MYSQL_TYPE_LONGLONG:\r\n    enum_type= MYSQL_TYPE_LONGLONG;\r\n#else\r\n    enum_type= MYSQL_TYPE_LONG;\r\n#endif\r\n    break;\r\n\r\n  case MYSQL_TYPE_BIT:\r\n    enum_type= MYSQL_TYPE_BIT;\r\n    break;\r\n\r\n  case MYSQL_TYPE_NEWDECIMAL:\r\n  case MYSQL_TYPE_DECIMAL:\r\n    enum_type= MYSQL_TYPE_DECIMAL;\r\n    break;\r\n\r\n#if IVSIZE < 8\r\n  case MYSQL_TYPE_LONGLONG:\r\n#endif\r\n  case MYSQL_TYPE_DATE:\r\n  case MYSQL_TYPE_TIME:\r\n  case MYSQL_TYPE_DATETIME:\r\n  case MYSQL_TYPE_NEWDATE:\r\n  case MYSQL_TYPE_TIMESTAMP:\r\n  case MYSQL_TYPE_VAR_STRING:\r\n  case MYSQL_TYPE_VARCHAR:\r\n  case MYSQL_TYPE_STRING:\r\n    enum_type= MYSQL_TYPE_STRING;\r\n    break;\r\n\r\n  case MYSQL_TYPE_GEOMETRY:\r\n  case MYSQL_TYPE_BLOB:\r\n  case MYSQL_TYPE_TINY_BLOB:\r\n    enum_type= MYSQL_TYPE_BLOB;\r\n    break;\r\n\r\n  default:\r\n    enum_type= MYSQL_TYPE_STRING;    /* MySQL can handle all types as strings */\r\n  }\r\n  return(enum_type);\r\n}", ".ysql_st_internal_execute41": "my_ulonglong mysql_st_internal_execute41(\r\n                                         SV *sth,\r\n                                         int num_params,\r\n                                         MYSQL_RES **result,\r\n                                         MYSQL_STMT *stmt,\r\n                                         MYSQL_BIND *bind,\r\n                                         int *has_been_bound\r\n                                        )\r\n{\r\n  int i;\r\n  enum enum_field_types enum_type;\r\n  dTHX;\r\n  int execute_retval;\r\n  my_ulonglong rows=0;\r\n  D_imp_xxh(sth);\r\n\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                  \"\\t-> mysql_st_internal_execute41\\n\");\r\n\r\n  /* free result if exists */\r\n  if (*result)\r\n  {\r\n    mysql_free_result(*result);\r\n    *result= 0;\r\n  }\r\n\r\n  /*\r\n    If were performed any changes with ph variables\r\n    we have to rebind them\r\n  */\r\n\r\n  if (num_params > 0 && !(*has_been_bound))\r\n  {\r\n#if MYSQL_VERSION_ID >= 80300\r\n    if (mysql_stmt_bind_named_param(stmt,bind,num_params, NULL))\r\n#else\r\n    if (mysql_stmt_bind_param(stmt,bind))\r\n#endif\r\n      goto error;\r\n\r\n    *has_been_bound= 1;\r\n  }\r\n\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                  \"\\t\\tmysql_st_internal_execute41 calling mysql_execute with %d num_params\\n\",\r\n                  num_params);\r\n\r\n  execute_retval= mysql_stmt_execute(stmt);\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                  \"\\t\\tmysql_stmt_execute returned %d\\n\",\r\n                  execute_retval);\r\n  if (execute_retval)\r\n    goto error;\r\n\r\n  /*\r\n   This statement does not return a result set (INSERT, UPDATE...)\r\n  */\r\n  if (!(*result= mysql_stmt_result_metadata(stmt)))\r\n  {\r\n    if (mysql_stmt_errno(stmt))\r\n      goto error;\r\n\r\n    rows= mysql_stmt_affected_rows(stmt);\r\n\r\n    /* mysql_stmt_affected_rows(): -1 indicates that the query returned an error */\r\n    if (rows == (my_ulonglong)-1)\r\n      goto error;\r\n  }\r\n  /*\r\n    This statement returns a result set (SELECT...)\r\n  */\r\n  else\r\n  {\r\n    for (i = mysql_stmt_field_count(stmt) - 1; i >=0; --i) {\r\n        enum_type = mysql_to_perl_type(stmt->fields[i].type);\r\n        if (enum_type != MYSQL_TYPE_DOUBLE && enum_type != MYSQL_TYPE_LONG && enum_type != MYSQL_TYPE_LONGLONG && enum_type != MYSQL_TYPE_BIT)\r\n        {\r\n            /* mysql_stmt_store_result to update MYSQL_FIELD->max_length */\r\n            bool on = 1;\r\n            mysql_stmt_attr_set(stmt, STMT_ATTR_UPDATE_MAX_LENGTH, &on);\r\n            break;\r\n        }\r\n    }\r\n    /* Get the total rows affected and return */\r\n    if (mysql_stmt_store_result(stmt))\r\n      goto error;\r\n    else\r\n      rows= mysql_stmt_num_rows(stmt);\r\n  }\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                  \"\\t<- mysql_internal_execute_41 returning %lu rows\\n\",\r\n                  rows);\r\n  return(rows);\r\n\r\nerror:\r\n  if (*result)\r\n  {\r\n    mysql_free_result(*result);\r\n    *result= 0;\r\n  }\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                  \"     errno %d err message %s\\n\",\r\n                  mysql_stmt_errno(stmt),\r\n                  mysql_stmt_error(stmt));\r\n  do_error(sth, mysql_stmt_errno(stmt), mysql_stmt_error(stmt),\r\n           mysql_stmt_sqlstate(stmt));\r\n  mysql_stmt_reset(stmt);\r\n\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                  \"\\t<- mysql_st_internal_execute41\\n\");\r\n  return -2;\r\n\r\n}", ".ysql_st_internal_execute": "my_ulonglong mysql_st_internal_execute(\r\n                                       SV *h, /* could be sth or dbh */\r\n                                       SV *statement,\r\n                                       SV *attribs,\r\n                                       int num_params,\r\n                                       imp_sth_ph_t *params,\r\n                                       MYSQL_RES **result,\r\n                                       MYSQL *svsock,\r\n                                       int use_mysql_use_result\r\n                                      )\r\n{\r\n  dTHX;\r\n  bool bind_type_guessing= FALSE;\r\n  bool bind_comment_placeholders= TRUE;\r\n  STRLEN slen;\r\n  char *sbuf = SvPV(statement, slen);\r\n  char *salloc;\r\n  int htype;\r\n  bool async = FALSE;\r\n  my_ulonglong rows= 0;\r\n  /* thank you DBI.c for this info! */\r\n  D_imp_xxh(h);\r\n  attribs= attribs;\r\n\r\n  htype= DBIc_TYPE(imp_xxh);\r\n  /*\r\n    It is important to import imp_dbh properly according to the htype\r\n    that it is! Also, one might ask why bind_type_guessing is assigned\r\n    in each block. Well, it's because D_imp_ macros called in these\r\n    blocks make it so imp_dbh is not \"visible\" or defined outside of the\r\n    if/else (when compiled, it fails for imp_dbh not being defined).\r\n  */\r\n  /* h is a dbh */\r\n  if (htype == DBIt_DB)\r\n  {\r\n    D_imp_dbh(h);\r\n    /* if imp_dbh is not available, it causes segfault (proper) on OpenBSD */\r\n    if (imp_dbh)\r\n    {\r\n      bind_type_guessing= imp_dbh->bind_type_guessing;\r\n      bind_comment_placeholders= imp_dbh->bind_comment_placeholders;\r\n    }\r\n    async = (bool) (imp_dbh->async_query_in_flight != NULL);\r\n  }\r\n  /* h is a sth */\r\n  else\r\n  {\r\n    D_imp_sth(h);\r\n    D_imp_dbh_from_sth;\r\n    /* if imp_dbh is not available, it causes segfault (proper) on OpenBSD */\r\n    if (imp_dbh)\r\n    {\r\n      bind_type_guessing= imp_dbh->bind_type_guessing;\r\n      bind_comment_placeholders= imp_dbh->bind_comment_placeholders;\r\n    }\r\n    async = imp_sth->is_async;\r\n    if(async) {\r\n        imp_dbh->async_query_in_flight = imp_sth;\r\n    } else {\r\n        imp_dbh->async_query_in_flight = NULL;\r\n    }\r\n  }\r\n\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"mysql_st_internal_execute MYSQL_VERSION_ID %d\\n\",\r\n                  MYSQL_VERSION_ID );\r\n\r\n  salloc= parse_params(imp_xxh,\r\n                              aTHX_ svsock,\r\n                              sbuf,\r\n                              &slen,\r\n                              params,\r\n                              num_params,\r\n                              bind_type_guessing,\r\n                              bind_comment_placeholders);\r\n\r\n  if (salloc)\r\n  {\r\n    sbuf= salloc;\r\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"Binding parameters: %s\\n\", sbuf);\r\n  }\r\n\r\n  if(async) {\r\n    if((mysql_send_query(svsock, sbuf, slen)) &&\r\n       (!mysql_db_reconnect(h) ||\r\n        (mysql_send_query(svsock, sbuf, slen))))\r\n    {\r\n        rows = -2;\r\n    } else {\r\n        rows = 0;\r\n    }\r\n  } else {\r\n      if ((mysql_real_query(svsock, sbuf, slen))  &&\r\n          (!mysql_db_reconnect(h)  ||\r\n           (mysql_real_query(svsock, sbuf, slen))))\r\n      {\r\n        rows = -2;\r\n      } else {\r\n          /** Store the result from the Query */\r\n          *result= use_mysql_use_result ?\r\n            mysql_use_result(svsock) : mysql_store_result(svsock);\r\n\r\n          if (mysql_errno(svsock))\r\n            rows = -2;\r\n          else if (*result)\r\n            rows = mysql_num_rows(*result);\r\n          else {\r\n            rows = mysql_affected_rows(svsock);\r\n            /* mysql_affected_rows(): -1 indicates that the query returned an error */\r\n            if (rows == (my_ulonglong)-1)\r\n              rows = -2;\r\n          }\r\n      }\r\n  }\r\n\r\n  if (salloc)\r\n    Safefree(salloc);\r\n\r\n  if(rows == (my_ulonglong)-2) {\r\n    do_error(h, mysql_errno(svsock), mysql_error(svsock), \r\n             mysql_sqlstate(svsock));\r\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"IGNORING ERROR errno %d\\n\", mysql_errno(svsock));\r\n  }\r\n  return(rows);\r\n}", ".bd_describe": "int dbd_describe(SV* sth, imp_sth_t* imp_sth)\r\n{\r\n  dTHX;\r\n  D_imp_xxh(sth);\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t--> dbd_describe\\n\");\r\n\r\n\r\n  if (imp_sth->use_server_side_prepare)\r\n  {\r\n    int i;\r\n    int col_type;\r\n    int num_fields= DBIc_NUM_FIELDS(imp_sth);\r\n    imp_sth_fbh_t *fbh;\r\n    MYSQL_BIND *buffer;\r\n    MYSQL_FIELD *fields;\r\n\r\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tdbd_describe() num_fields %d\\n\",\r\n                    num_fields);\r\n\r\n    if (imp_sth->done_desc)\r\n      return TRUE;\r\n\r\n    if (!num_fields || !imp_sth->result)\r\n    {\r\n      /* no metadata */\r\n      do_error(sth, JW_ERR_SEQUENCE,\r\n               \"no metadata information while trying describe result set\",\r\n               NULL);\r\n      return 0;\r\n    }\r\n\r\n    /* allocate fields buffers  */\r\n    if (  !(imp_sth->fbh= alloc_fbuffer(num_fields))\r\n          || !(imp_sth->buffer= alloc_bind(num_fields)) )\r\n    {\r\n      /* Out of memory */\r\n      do_error(sth, JW_ERR_SEQUENCE,\r\n               \"Out of memory in dbd_sescribe()\",NULL);\r\n      return 0;\r\n    }\r\n\r\n    fields= mysql_fetch_fields(imp_sth->result);\r\n\r\n    for (\r\n         fbh= imp_sth->fbh, buffer= (MYSQL_BIND*)imp_sth->buffer, i= 0;\r\n         i < num_fields;\r\n         i++, fbh++, buffer++\r\n        )\r\n    {\r\n      /* get the column type */\r\n      col_type = fields ? fields[i].type : MYSQL_TYPE_STRING;\r\n\r\n      if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n      {\r\n        PerlIO_printf(DBIc_LOGPIO(imp_xxh),\"\\t\\ti %d col_type %d fbh->length %lu\\n\",\r\n                      i, col_type, fbh->length);\r\n        PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                      \"\\t\\tfields[i].length %lu fields[i].max_length %lu fields[i].type %d fields[i].charsetnr %d\\n\",\r\n                      fields[i].length, fields[i].max_length, fields[i].type,\r\n                      fields[i].charsetnr);\r\n      }\r\n      fbh->charsetnr = fields[i].charsetnr;\r\n\r\n      buffer->buffer_type= mysql_to_perl_type(col_type);\r\n      if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n        PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tmysql_to_perl_type returned %d\\n\",\r\n                      col_type);\r\n      buffer->length= &(fbh->length);\r\n      buffer->is_null= &(fbh->is_null);\r\n      buffer->error= (bool*) &(fbh->error);\r\n\r\n      if (fields[i].flags & ZEROFILL_FLAG)\r\n        buffer->buffer_type = MYSQL_TYPE_STRING;\r\n\r\n      switch (buffer->buffer_type) {\r\n      case MYSQL_TYPE_DOUBLE:\r\n        buffer->buffer_length= sizeof(fbh->ddata);\r\n        buffer->buffer= (char*) &fbh->ddata;\r\n        break;\r\n\r\n      case MYSQL_TYPE_LONG:\r\n      case MYSQL_TYPE_LONGLONG:\r\n        buffer->buffer_length= sizeof(fbh->ldata);\r\n        buffer->buffer= (char*) &fbh->ldata;\r\n        buffer->is_unsigned= (fields[i].flags & UNSIGNED_FLAG) ? 1 : 0;\r\n        break;\r\n\r\n      case MYSQL_TYPE_BIT:\r\n        buffer->buffer_length= 8;\r\n        Newz(908, fbh->data, buffer->buffer_length, char);\r\n        buffer->buffer= (char *) fbh->data;\r\n        break;\r\n\r\n      default:\r\n        buffer->buffer_length= fields[i].max_length ? fields[i].max_length : 1;\r\n        Newz(908, fbh->data, buffer->buffer_length, char);\r\n        buffer->buffer= (char *) fbh->data;\r\n      }\r\n    }\r\n\r\n    if (mysql_stmt_bind_result(imp_sth->stmt, imp_sth->buffer))\r\n    {\r\n      do_error(sth, mysql_stmt_errno(imp_sth->stmt),\r\n               mysql_stmt_error(imp_sth->stmt),\r\n               mysql_stmt_sqlstate(imp_sth->stmt));\r\n      return 0;\r\n    }\r\n  }\r\n\r\n  imp_sth->done_desc= 1;\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t<- dbd_describe\\n\");\r\n  return TRUE;\r\n}", ".ysql_db_async_result": "int mysql_db_async_result(SV* h, MYSQL_RES** resp)\r\n{\r\n  dTHX;\r\n  D_imp_xxh(h);\r\n  imp_dbh_t* dbh;\r\n  MYSQL* svsock = NULL;\r\n  MYSQL_RES* _res;\r\n  int retval = 0;\r\n  int htype;\r\n  bool async_sth = FALSE;\r\n\r\n  if(! resp) {\r\n      resp = &_res;\r\n  }\r\n  htype = DBIc_TYPE(imp_xxh);\r\n\r\n\r\n  if(htype == DBIt_DB) {\r\n      D_imp_dbh(h);\r\n      dbh = imp_dbh;\r\n  } else {\r\n      D_imp_sth(h);\r\n      D_imp_dbh_from_sth;\r\n      dbh = imp_dbh;\r\n      async_sth = imp_sth->is_async;\r\n      retval = imp_sth->row_num;\r\n  }\r\n\r\n  if(! dbh->async_query_in_flight) {\r\n      if (async_sth)\r\n          return retval;\r\n      do_error(h, 2000, \"Gathering asynchronous results for a synchronous handle\", \"HY000\");\r\n      return -1;\r\n  }\r\n  if(dbh->async_query_in_flight != imp_xxh) {\r\n      do_error(h, 2000, \"Gathering async_query_in_flight results for the wrong handle\", \"HY000\");\r\n      return -1;\r\n  }\r\n  dbh->async_query_in_flight = NULL;\r\n\r\n  svsock= dbh->pmysql;\r\n  retval= mysql_read_query_result(svsock);\r\n  if(! retval) {\r\n    *resp= mysql_store_result(svsock);\r\n\r\n    if (mysql_errno(svsock))\r\n      do_error(h, mysql_errno(svsock), mysql_error(svsock), mysql_sqlstate(svsock));\r\n    if (!*resp)\r\n      retval= mysql_affected_rows(svsock);\r\n    else {\r\n      retval= mysql_num_rows(*resp);\r\n      if(resp == &_res) {\r\n        mysql_free_result(*resp);\r\n        *resp= NULL;\r\n      }\r\n    }\r\n    if(htype == DBIt_ST) {\r\n      D_imp_sth(h);\r\n      D_imp_dbh_from_sth;\r\n\r\n      if((my_ulonglong)retval+1 != (my_ulonglong)-1) {\r\n        if(! *resp) {\r\n          imp_sth->insertid= mysql_insert_id(svsock);\r\n          if(! mysql_more_results(svsock))\r\n            DBIc_ACTIVE_off(imp_sth);\r\n        } else {\r\n          DBIc_NUM_FIELDS(imp_sth)= mysql_num_fields(imp_sth->result);\r\n          imp_sth->done_desc= 0;\r\n          imp_sth->fetch_done= 0;\r\n        }\r\n      }\r\n      imp_sth->warning_count = mysql_warning_count(imp_dbh->pmysql);\r\n    }\r\n  } else {\r\n     do_error(h, mysql_errno(svsock), mysql_error(svsock),\r\n              mysql_sqlstate(svsock));\r\n     return -1;\r\n  }\r\n return retval;\r\n}", ".ysql_st_clean_cursor": "int mysql_st_clean_cursor(SV* sth, imp_sth_t* imp_sth) {\r\n\r\n  if (DBIc_ACTIVE(imp_sth) && dbd_describe(sth, imp_sth) &&\r\n      !imp_sth->fetch_done)\r\n    mysql_stmt_free_result(imp_sth->stmt);\r\n  return 1;\r\n}", ".ree_bind": "static void free_bind(MYSQL_BIND *bind)\r\n{\r\n  if (bind)\r\n    Safefree(bind);\r\n}", ".ree_fbind": "static void free_fbind(imp_sth_phb_t *fbind)\r\n{\r\n  if (fbind)\r\n    Safefree(fbind);\r\n}", ".ree_fbuffer": "static void free_fbuffer(imp_sth_fbh_t *fbh)\r\n{\r\n  if (fbh)\r\n    Safefree(fbh);\r\n}", ".ree_param": "static void\r\nfree_param(pTHX_ imp_sth_ph_t *params, int num_params)\r\n{\r\n  if (params)\r\n  {\r\n    int i;\r\n    for (i= 0;  i < num_params;  i++)\r\n    {\r\n      imp_sth_ph_t *ph= params+i;\r\n      if (ph->value)\r\n      {\r\n        (void) SvREFCNT_dec(ph->value);\r\n        ph->value= NULL;\r\n      }\r\n    }\r\n    Safefree(params);\r\n  }\r\n}", ".ind_param": "int bind_param(imp_sth_ph_t *ph, SV *value, IV sql_type)\r\n{\r\n  dTHX;\r\n  if (ph->value)\r\n  {\r\n    if (SvMAGICAL(ph->value))\r\n      mg_get(ph->value);\r\n    (void) SvREFCNT_dec(ph->value);\r\n  }\r\n\r\n  ph->value= newSVsv(value);\r\n\r\n  if (sql_type)\r\n    ph->type = sql_type;\r\n\r\n  return TRUE;\r\n}"}, "callee": {".bd_st_prepare": "int\r\ndbd_st_prepare(\r\n  SV *sth,\r\n  imp_sth_t *imp_sth,\r\n  char *statement,\r\n  SV *attribs)\r\n{\r\n  int i;\r\n  SV **svp;\r\n  dTHX;\r\n  int prepare_retval;\r\n  MYSQL_BIND *bind, *bind_end;\r\n  imp_sth_phb_t *fbind;\r\n  D_imp_xxh(sth);\r\n  D_imp_dbh_from_sth;\r\n\r\n  if (!DBIc_ACTIVE(imp_dbh)) {\r\n    do_error(sth, JW_ERR_NOT_ACTIVE, \"Statement not active\" ,NULL);\r\n    return FALSE;\r\n  }\r\n\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                 \"\\t-> dbd_st_prepare MYSQL_VERSION_ID %d, SQL statement: %s\\n\",\r\n                  MYSQL_VERSION_ID, statement);\r\n\r\n /* Set default value of 'mysql_server_prepare' attribute for sth from dbh */\r\n  imp_sth->use_server_side_prepare= imp_dbh->use_server_side_prepare;\r\n  imp_sth->disable_fallback_for_server_prepare= imp_dbh->disable_fallback_for_server_prepare;\r\n  if (attribs)\r\n  {\r\n    svp= DBD_ATTRIB_GET_SVP(attribs, \"mysql_server_prepare\", 20);\r\n    imp_sth->use_server_side_prepare = (svp) ?\r\n      SvTRUE(*svp) : imp_dbh->use_server_side_prepare;\r\n\r\n    svp= DBD_ATTRIB_GET_SVP(attribs, \"mysql_server_prepare_disable_fallback\", 37);\r\n    imp_sth->disable_fallback_for_server_prepare = (svp) ?\r\n      SvTRUE(*svp) : imp_dbh->disable_fallback_for_server_prepare;\r\n\r\n    svp = DBD_ATTRIB_GET_SVP(attribs, \"async\", 5);\r\n\r\n    if(svp && SvTRUE(*svp)) {\r\n        imp_sth->is_async = TRUE;\r\n        if (imp_sth->disable_fallback_for_server_prepare)\r\n        {\r\n          do_error(sth, ER_UNSUPPORTED_PS,\r\n                   \"Async option not supported with server side prepare\", \"HY000\");\r\n          return 0;\r\n        }\r\n        imp_sth->use_server_side_prepare = FALSE;\r\n    }\r\n  }\r\n\r\n  imp_sth->fetch_done= 0;\r\n  imp_sth->done_desc= 0;\r\n  imp_sth->result= NULL;\r\n  imp_sth->currow= 0;\r\n\r\n  /* Set default value of 'mysql_use_result' attribute for sth from dbh */\r\n  svp= DBD_ATTRIB_GET_SVP(attribs, \"mysql_use_result\", 16);\r\n  imp_sth->use_mysql_use_result= svp ?\r\n    SvTRUE(*svp) : imp_dbh->use_mysql_use_result;\r\n\r\n  for (i= 0; i < AV_ATTRIB_LAST; i++)\r\n    imp_sth->av_attr[i]= Nullav;\r\n\r\n  /*\r\n     Clean-up previous result set(s) for sth to prevent\r\n     'Commands out of sync' error \r\n  */\r\n  mysql_st_free_result_sets(sth, imp_sth);\r\n\r\n\r\n  if (imp_sth->use_server_side_prepare)\r\n  {\r\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                    \"\\t\\tuse_server_side_prepare set\\n\");\r\n    /* do we really need this? If we do, we should return, not just continue */\r\n    if (imp_sth->stmt)\r\n      fprintf(stderr,\r\n              \"ERROR: Trying to prepare new stmt while we have \\\r\n              already not closed one \\n\");\r\n\r\n    imp_sth->stmt= mysql_stmt_init(imp_dbh->pmysql);\r\n\r\n    if (! imp_sth->stmt)\r\n    {\r\n      if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n        PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                      \"\\t\\tERROR: Unable to return MYSQL_STMT structure \\\r\n                      from mysql_stmt_init(): ERROR NO: %d ERROR MSG:%s\\n\",\r\n                      mysql_errno(imp_dbh->pmysql),\r\n                      mysql_error(imp_dbh->pmysql));\r\n    }\r\n\r\n    prepare_retval= mysql_stmt_prepare(imp_sth->stmt,\r\n                                       statement,\r\n                                       strlen(statement));\r\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n        PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                      \"\\t\\tmysql_stmt_prepare returned %d\\n\",\r\n                      prepare_retval);\r\n\r\n    if (prepare_retval)\r\n    {\r\n      if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n        PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                      \"\\t\\tmysql_stmt_prepare %d %s\\n\",\r\n                      mysql_stmt_errno(imp_sth->stmt),\r\n                      mysql_stmt_error(imp_sth->stmt));\r\n\r\n      /* For commands that are not supported by server side prepared statement\r\n         mechanism lets try to pass them through regular API */\r\n      if (!imp_sth->disable_fallback_for_server_prepare && mysql_stmt_errno(imp_sth->stmt) == ER_UNSUPPORTED_PS)\r\n      {\r\n        if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n          PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                    \"\\t\\tSETTING imp_sth->use_server_side_prepare to 0\\n\");\r\n        imp_sth->use_server_side_prepare= 0;\r\n      }\r\n      else\r\n      {\r\n        do_error(sth, mysql_stmt_errno(imp_sth->stmt),\r\n                 mysql_stmt_error(imp_sth->stmt),\r\n                mysql_sqlstate(imp_dbh->pmysql));\r\n        mysql_stmt_close(imp_sth->stmt);\r\n        imp_sth->stmt= NULL;\r\n        return FALSE;\r\n      }\r\n    }\r\n    else\r\n    {\r\n      DBIc_NUM_PARAMS(imp_sth)= mysql_stmt_param_count(imp_sth->stmt);\r\n      /* mysql_stmt_param_count */\r\n\r\n      if (DBIc_NUM_PARAMS(imp_sth) > 0)\r\n      {\r\n        /* Allocate memory for bind variables */\r\n        imp_sth->bind=            alloc_bind(DBIc_NUM_PARAMS(imp_sth));\r\n        imp_sth->fbind=           alloc_fbind(DBIc_NUM_PARAMS(imp_sth));\r\n        imp_sth->has_been_bound=  0;\r\n\r\n        /* Initialize ph variables with  NULL values */\r\n        for (i= 0,\r\n             bind=      imp_sth->bind,\r\n             fbind=     imp_sth->fbind,\r\n             bind_end=  bind+DBIc_NUM_PARAMS(imp_sth);\r\n             bind < bind_end ;\r\n             bind++, fbind++, i++ )\r\n        {\r\n          bind->buffer_type=  MYSQL_TYPE_STRING;\r\n          bind->buffer=       NULL;\r\n          bind->length=       &(fbind->length);\r\n          bind->is_null=      &(fbind->is_null);\r\n          fbind->is_null=     1;\r\n          fbind->length=      0;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /* Count the number of parameters (driver, vs server-side) */\r\n  if (imp_sth->use_server_side_prepare == 0)\r\n    DBIc_NUM_PARAMS(imp_sth) = count_params((imp_xxh_t *)imp_dbh, aTHX_ statement,\r\n                                            imp_dbh->bind_comment_placeholders);\r\n\r\n  /* Allocate memory for parameters */\r\n  imp_sth->params= alloc_param(DBIc_NUM_PARAMS(imp_sth));\r\n  DBIc_IMPSET_on(imp_sth);\r\n\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t<- dbd_st_prepare\\n\");\r\n  return 1;\r\n}", ".bd_st_destroy": "void dbd_st_destroy(SV *sth, imp_sth_t *imp_sth) {\r\n  dTHX;\r\n  D_imp_xxh(sth);\r\n\r\n#if defined (dTHR)\r\n  dTHR;\r\n#endif\r\n\r\n  int i;\r\n\r\n  imp_sth_fbh_t *fbh;\r\n  int n;\r\n\r\n  n= DBIc_NUM_PARAMS(imp_sth);\r\n  if (n)\r\n  {\r\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\tFreeing %d parameters, bind %p fbind %p\\n\",\r\n          n, imp_sth->bind, imp_sth->fbind);\r\n\r\n    free_bind(imp_sth->bind);\r\n    free_fbind(imp_sth->fbind);\r\n  }\r\n\r\n  fbh= imp_sth->fbh;\r\n  if (fbh)\r\n  {\r\n    n = DBIc_NUM_FIELDS(imp_sth);\r\n    i = 0;\r\n    while (i < n)\r\n    {\r\n      if (fbh[i].data) Safefree(fbh[i].data);\r\n      ++i;\r\n    }\r\n\r\n    free_fbuffer(fbh);\r\n    if (imp_sth->buffer)\r\n      free_bind(imp_sth->buffer);\r\n  }\r\n\r\n  if (imp_sth->stmt)\r\n  {\r\n    mysql_stmt_close(imp_sth->stmt);\r\n    imp_sth->stmt= NULL;\r\n  }\r\n\r\n  /* dbd_st_finish has already been called by .xs code if needed.\t*/\r\n\r\n  /* Free values allocated by dbd_bind_ph */\r\n  if (imp_sth->params)\r\n  {\r\n    free_param(aTHX_ imp_sth->params, DBIc_NUM_PARAMS(imp_sth));\r\n    imp_sth->params= NULL;\r\n  }\r\n\r\n  /* Free cached array attributes */\r\n  for (i= 0; i < AV_ATTRIB_LAST; i++)\r\n  {\r\n    if (imp_sth->av_attr[i])\r\n      SvREFCNT_dec(imp_sth->av_attr[i]);\r\n    imp_sth->av_attr[i]= Nullav;\r\n  }\r\n  /* let DBI know we've done it   */\r\n  DBIc_IMPSET_off(imp_sth);\r\n}", ".ysql_st_internal_execute41": "my_ulonglong mysql_st_internal_execute41(\r\n                                         SV *sth,\r\n                                         int num_params,\r\n                                         MYSQL_RES **result,\r\n                                         MYSQL_STMT *stmt,\r\n                                         MYSQL_BIND *bind,\r\n                                         int *has_been_bound\r\n                                        )\r\n{\r\n  int i;\r\n  enum enum_field_types enum_type;\r\n  dTHX;\r\n  int execute_retval;\r\n  my_ulonglong rows=0;\r\n  D_imp_xxh(sth);\r\n\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                  \"\\t-> mysql_st_internal_execute41\\n\");\r\n\r\n  /* free result if exists */\r\n  if (*result)\r\n  {\r\n    mysql_free_result(*result);\r\n    *result= 0;\r\n  }\r\n\r\n  /*\r\n    If were performed any changes with ph variables\r\n    we have to rebind them\r\n  */\r\n\r\n  if (num_params > 0 && !(*has_been_bound))\r\n  {\r\n#if MYSQL_VERSION_ID >= 80300\r\n    if (mysql_stmt_bind_named_param(stmt,bind,num_params, NULL))\r\n#else\r\n    if (mysql_stmt_bind_param(stmt,bind))\r\n#endif\r\n      goto error;\r\n\r\n    *has_been_bound= 1;\r\n  }\r\n\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                  \"\\t\\tmysql_st_internal_execute41 calling mysql_execute with %d num_params\\n\",\r\n                  num_params);\r\n\r\n  execute_retval= mysql_stmt_execute(stmt);\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                  \"\\t\\tmysql_stmt_execute returned %d\\n\",\r\n                  execute_retval);\r\n  if (execute_retval)\r\n    goto error;\r\n\r\n  /*\r\n   This statement does not return a result set (INSERT, UPDATE...)\r\n  */\r\n  if (!(*result= mysql_stmt_result_metadata(stmt)))\r\n  {\r\n    if (mysql_stmt_errno(stmt))\r\n      goto error;\r\n\r\n    rows= mysql_stmt_affected_rows(stmt);\r\n\r\n    /* mysql_stmt_affected_rows(): -1 indicates that the query returned an error */\r\n    if (rows == (my_ulonglong)-1)\r\n      goto error;\r\n  }\r\n  /*\r\n    This statement returns a result set (SELECT...)\r\n  */\r\n  else\r\n  {\r\n    for (i = mysql_stmt_field_count(stmt) - 1; i >=0; --i) {\r\n        enum_type = mysql_to_perl_type(stmt->fields[i].type);\r\n        if (enum_type != MYSQL_TYPE_DOUBLE && enum_type != MYSQL_TYPE_LONG && enum_type != MYSQL_TYPE_LONGLONG && enum_type != MYSQL_TYPE_BIT)\r\n        {\r\n            /* mysql_stmt_store_result to update MYSQL_FIELD->max_length */\r\n            bool on = 1;\r\n            mysql_stmt_attr_set(stmt, STMT_ATTR_UPDATE_MAX_LENGTH, &on);\r\n            break;\r\n        }\r\n    }\r\n    /* Get the total rows affected and return */\r\n    if (mysql_stmt_store_result(stmt))\r\n      goto error;\r\n    else\r\n      rows= mysql_stmt_num_rows(stmt);\r\n  }\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                  \"\\t<- mysql_internal_execute_41 returning %lu rows\\n\",\r\n                  rows);\r\n  return(rows);\r\n\r\nerror:\r\n  if (*result)\r\n  {\r\n    mysql_free_result(*result);\r\n    *result= 0;\r\n  }\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                  \"     errno %d err message %s\\n\",\r\n                  mysql_stmt_errno(stmt),\r\n                  mysql_stmt_error(stmt));\r\n  do_error(sth, mysql_stmt_errno(stmt), mysql_stmt_error(stmt),\r\n           mysql_stmt_sqlstate(stmt));\r\n  mysql_stmt_reset(stmt);\r\n\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                  \"\\t<- mysql_st_internal_execute41\\n\");\r\n  return -2;\r\n\r\n}", ".bd_describe": "int dbd_describe(SV* sth, imp_sth_t* imp_sth)\r\n{\r\n  dTHX;\r\n  D_imp_xxh(sth);\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t--> dbd_describe\\n\");\r\n\r\n\r\n  if (imp_sth->use_server_side_prepare)\r\n  {\r\n    int i;\r\n    int col_type;\r\n    int num_fields= DBIc_NUM_FIELDS(imp_sth);\r\n    imp_sth_fbh_t *fbh;\r\n    MYSQL_BIND *buffer;\r\n    MYSQL_FIELD *fields;\r\n\r\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tdbd_describe() num_fields %d\\n\",\r\n                    num_fields);\r\n\r\n    if (imp_sth->done_desc)\r\n      return TRUE;\r\n\r\n    if (!num_fields || !imp_sth->result)\r\n    {\r\n      /* no metadata */\r\n      do_error(sth, JW_ERR_SEQUENCE,\r\n               \"no metadata information while trying describe result set\",\r\n               NULL);\r\n      return 0;\r\n    }\r\n\r\n    /* allocate fields buffers  */\r\n    if (  !(imp_sth->fbh= alloc_fbuffer(num_fields))\r\n          || !(imp_sth->buffer= alloc_bind(num_fields)) )\r\n    {\r\n      /* Out of memory */\r\n      do_error(sth, JW_ERR_SEQUENCE,\r\n               \"Out of memory in dbd_sescribe()\",NULL);\r\n      return 0;\r\n    }\r\n\r\n    fields= mysql_fetch_fields(imp_sth->result);\r\n\r\n    for (\r\n         fbh= imp_sth->fbh, buffer= (MYSQL_BIND*)imp_sth->buffer, i= 0;\r\n         i < num_fields;\r\n         i++, fbh++, buffer++\r\n        )\r\n    {\r\n      /* get the column type */\r\n      col_type = fields ? fields[i].type : MYSQL_TYPE_STRING;\r\n\r\n      if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n      {\r\n        PerlIO_printf(DBIc_LOGPIO(imp_xxh),\"\\t\\ti %d col_type %d fbh->length %lu\\n\",\r\n                      i, col_type, fbh->length);\r\n        PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                      \"\\t\\tfields[i].length %lu fields[i].max_length %lu fields[i].type %d fields[i].charsetnr %d\\n\",\r\n                      fields[i].length, fields[i].max_length, fields[i].type,\r\n                      fields[i].charsetnr);\r\n      }\r\n      fbh->charsetnr = fields[i].charsetnr;\r\n\r\n      buffer->buffer_type= mysql_to_perl_type(col_type);\r\n      if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n        PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tmysql_to_perl_type returned %d\\n\",\r\n                      col_type);\r\n      buffer->length= &(fbh->length);\r\n      buffer->is_null= &(fbh->is_null);\r\n      buffer->error= (bool*) &(fbh->error);\r\n\r\n      if (fields[i].flags & ZEROFILL_FLAG)\r\n        buffer->buffer_type = MYSQL_TYPE_STRING;\r\n\r\n      switch (buffer->buffer_type) {\r\n      case MYSQL_TYPE_DOUBLE:\r\n        buffer->buffer_length= sizeof(fbh->ddata);\r\n        buffer->buffer= (char*) &fbh->ddata;\r\n        break;\r\n\r\n      case MYSQL_TYPE_LONG:\r\n      case MYSQL_TYPE_LONGLONG:\r\n        buffer->buffer_length= sizeof(fbh->ldata);\r\n        buffer->buffer= (char*) &fbh->ldata;\r\n        buffer->is_unsigned= (fields[i].flags & UNSIGNED_FLAG) ? 1 : 0;\r\n        break;\r\n\r\n      case MYSQL_TYPE_BIT:\r\n        buffer->buffer_length= 8;\r\n        Newz(908, fbh->data, buffer->buffer_length, char);\r\n        buffer->buffer= (char *) fbh->data;\r\n        break;\r\n\r\n      default:\r\n        buffer->buffer_length= fields[i].max_length ? fields[i].max_length : 1;\r\n        Newz(908, fbh->data, buffer->buffer_length, char);\r\n        buffer->buffer= (char *) fbh->data;\r\n      }\r\n    }\r\n\r\n    if (mysql_stmt_bind_result(imp_sth->stmt, imp_sth->buffer))\r\n    {\r\n      do_error(sth, mysql_stmt_errno(imp_sth->stmt),\r\n               mysql_stmt_error(imp_sth->stmt),\r\n               mysql_stmt_sqlstate(imp_sth->stmt));\r\n      return 0;\r\n    }\r\n  }\r\n\r\n  imp_sth->done_desc= 1;\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t<- dbd_describe\\n\");\r\n  return TRUE;\r\n}", ".bd_bind_ph": "int dbd_bind_ph(SV *sth, imp_sth_t *imp_sth, SV *param, SV *value,\r\n\t\t IV sql_type, SV *attribs, int is_inout, IV maxlen) {\r\n  dTHX;\r\n  int rc;\r\n  int param_num= SvIV(param);\r\n  int idx= param_num - 1;\r\n  char *err_msg;\r\n  D_imp_xxh(sth);\r\n\r\n  STRLEN slen;\r\n  char *buffer= NULL;\r\n  int buffer_is_null= 0;\r\n  int buffer_is_unsigned= 0;\r\n  int buffer_length= 0;\r\n  unsigned int buffer_type= 0;\r\n\r\n  D_imp_dbh_from_sth;\r\n  ASYNC_CHECK_RETURN(sth, FALSE);\r\n\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                  \"   Called: dbd_bind_ph\\n\");\r\n\r\n  attribs= attribs;\r\n  maxlen= maxlen;\r\n\r\n  if (param_num <= 0  ||  param_num > DBIc_NUM_PARAMS(imp_sth))\r\n  {\r\n    do_error(sth, JW_ERR_ILLEGAL_PARAM_NUM, \"Illegal parameter number\", NULL);\r\n    return FALSE;\r\n  }\r\n\r\n  /*\r\n     This fixes the bug whereby no warning was issued upon binding a\r\n     defined non-numeric as numeric\r\n   */\r\n  if (SvOK(value) &&\r\n      (sql_type == SQL_NUMERIC  ||\r\n       sql_type == SQL_DECIMAL  ||\r\n       sql_type == SQL_INTEGER  ||\r\n       sql_type == SQL_SMALLINT ||\r\n       sql_type == SQL_FLOAT    ||\r\n       sql_type == SQL_REAL     ||\r\n       sql_type == SQL_DOUBLE) )\r\n  {\r\n    if (! looks_like_number(value))\r\n    {\r\n      err_msg = SvPVX(sv_2mortal(newSVpvf(\r\n              \"Binding non-numeric field %d, value %s as a numeric!\",\r\n              param_num, neatsvpv(value,0))));\r\n      do_error(sth, JW_ERR_ILLEGAL_PARAM_NUM, err_msg, NULL);\r\n    }\r\n  }\r\n\r\n  if (is_inout)\r\n  {\r\n    do_error(sth, JW_ERR_NOT_IMPLEMENTED, \"Output parameters not implemented\", NULL);\r\n    return FALSE;\r\n  }\r\n\r\n  rc = bind_param(&imp_sth->params[idx], value, sql_type);\r\n\r\n  if (imp_sth->use_server_side_prepare)\r\n  {\r\n      switch(sql_type) {\r\n      case SQL_NUMERIC:\r\n      case SQL_INTEGER:\r\n      case SQL_SMALLINT:\r\n      case SQL_TINYINT:\r\n#if IVSIZE >= 8\r\n      case SQL_BIGINT:\r\n          buffer_type= MYSQL_TYPE_LONGLONG;\r\n#else\r\n          buffer_type= MYSQL_TYPE_LONG;\r\n#endif\r\n          break;\r\n      case SQL_DOUBLE:\r\n      case SQL_DECIMAL: \r\n      case SQL_FLOAT: \r\n      case SQL_REAL:\r\n          buffer_type= MYSQL_TYPE_DOUBLE;\r\n          break;\r\n      case SQL_CHAR: \r\n      case SQL_VARCHAR: \r\n      case SQL_DATE: \r\n      case SQL_TIME: \r\n      case SQL_TIMESTAMP: \r\n      case SQL_LONGVARCHAR: \r\n      case SQL_BINARY: \r\n      case SQL_VARBINARY: \r\n      case SQL_LONGVARBINARY:\r\n          buffer_type= MYSQL_TYPE_BLOB;\r\n          break;\r\n      default:\r\n          buffer_type= MYSQL_TYPE_STRING;\r\n    }\r\n    buffer_is_null = !(SvOK(imp_sth->params[idx].value) && imp_sth->params[idx].value);\r\n    if (! buffer_is_null) {\r\n      switch(buffer_type) {\r\n        case MYSQL_TYPE_LONG:\r\n        case MYSQL_TYPE_LONGLONG:\r\n          /* INT */\r\n          if (!SvIOK(imp_sth->params[idx].value) && DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tTRY TO BIND AN INT NUMBER\\n\");\r\n          buffer_length = sizeof imp_sth->fbind[idx].numeric_val.lval;\r\n          imp_sth->fbind[idx].numeric_val.lval= SvIV(imp_sth->params[idx].value);\r\n          buffer=(void*)&(imp_sth->fbind[idx].numeric_val.lval);\r\n          if (!SvIOK(imp_sth->params[idx].value))\r\n          {\r\n            if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n              PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                            \"   Conversion to INT NUMBER was not successful -> '%s' --> (unsigned) '%\"UVuf\"' / (signed) '%\"IVdf\"' <- fallback to STRING\\n\",\r\n                            SvPV_nolen(imp_sth->params[idx].value), imp_sth->fbind[idx].numeric_val.lval, imp_sth->fbind[idx].numeric_val.lval);\r\n            buffer_type = MYSQL_TYPE_STRING;\r\n            break;\r\n          }\r\n          if (SvIsUV(imp_sth->params[idx].value))\r\n            buffer_is_unsigned= 1;\r\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                          \"   SCALAR type %\"IVdf\" ->%\"IVdf\"<- IS AN INT NUMBER\\n\",\r\n                          sql_type, *(IV *)buffer);\r\n          break;\r\n\r\n        case MYSQL_TYPE_DOUBLE:\r\n          if (!SvNOK(imp_sth->params[idx].value) && DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tTRY TO BIND A FLOAT NUMBER\\n\");\r\n          buffer_length = sizeof imp_sth->fbind[idx].numeric_val.dval;\r\n          imp_sth->fbind[idx].numeric_val.dval= SvNV(imp_sth->params[idx].value);\r\n          buffer=(char*)&(imp_sth->fbind[idx].numeric_val.dval);\r\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                          \"   SCALAR type %\"IVdf\" ->%f<- IS A FLOAT NUMBER\\n\",\r\n                          sql_type, (double)(*buffer));\r\n          break;\r\n\r\n        case MYSQL_TYPE_BLOB:\r\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                          \"   SCALAR type BLOB\\n\");\r\n          break;\r\n\r\n        case MYSQL_TYPE_STRING:\r\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                          \"   SCALAR type STRING %\"IVdf\", buffertype=%d\\n\", sql_type, buffer_type);\r\n          break;\r\n\r\n        default:\r\n          croak(\"Bug in DBD::Mysql file dbdimp.c#dbd_bind_ph: do not know how to handle unknown buffer type.\");\r\n      }\r\n\r\n      if (buffer_type == MYSQL_TYPE_STRING || buffer_type == MYSQL_TYPE_BLOB)\r\n      {\r\n        buffer= SvPV(imp_sth->params[idx].value, slen);\r\n        buffer_length= slen;\r\n        if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n          PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                        \" SCALAR type %\"IVdf\" ->length %d<- IS A STRING or BLOB\\n\",\r\n                        sql_type, buffer_length);\r\n      }\r\n    }\r\n    else\r\n    {\r\n      /*case: buffer_is_null != 0*/\r\n      buffer= NULL;\r\n      if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n        PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                      \"   SCALAR NULL VALUE: buffer type is: %d\\n\", buffer_type);\r\n    }\r\n\r\n    /* Type of column was changed. Force to rebind */\r\n    if (imp_sth->bind[idx].buffer_type != buffer_type || imp_sth->bind[idx].is_unsigned != buffer_is_unsigned) {\r\n      if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n          PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                        \"   FORCE REBIND: buffer type changed from %d to %d, sql-type=%\"IVdf\"\\n\",\r\n                        (int) imp_sth->bind[idx].buffer_type, buffer_type, sql_type);\r\n      imp_sth->has_been_bound = 0;\r\n    }\r\n\r\n    /* prepare has been called */\r\n    if (imp_sth->has_been_bound)\r\n    {\r\n      imp_sth->stmt->params[idx].buffer= buffer;\r\n      imp_sth->stmt->params[idx].buffer_length= buffer_length;\r\n    }\r\n\r\n    imp_sth->bind[idx].buffer_type= buffer_type;\r\n    imp_sth->bind[idx].buffer= buffer;\r\n    imp_sth->bind[idx].buffer_length= buffer_length;\r\n    imp_sth->bind[idx].is_unsigned= buffer_is_unsigned;\r\n\r\n    imp_sth->fbind[idx].length= buffer_length;\r\n    imp_sth->fbind[idx].is_null= buffer_is_null;\r\n  }\r\n  return rc;\r\n}", ".bd_db_login": "int dbd_db_login(SV* dbh, imp_dbh_t* imp_dbh, char* dbname, char* user,\r\n\t\t char* password) {\r\n#ifdef dTHR\r\n  dTHR;\r\n#endif\r\n  dTHX; \r\n  D_imp_xxh(dbh);\r\n\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n\t\t  \"imp_dbh->connect: dsn = %s, uid = %s, pwd = %s\\n\",\r\n\t\t  dbname ? dbname : \"NULL\",\r\n\t\t  user ? user : \"NULL\",\r\n\t\t  password ? password : \"NULL\");\r\n\r\n  imp_dbh->stats.auto_reconnects_ok= 0;\r\n  imp_dbh->stats.auto_reconnects_failed= 0;\r\n  imp_dbh->bind_type_guessing= FALSE;\r\n  imp_dbh->bind_comment_placeholders= FALSE;\r\n  imp_dbh->has_transactions= TRUE;\r\n /* Safer we flip this to TRUE perl side if we detect a mod_perl env. */\r\n  imp_dbh->auto_reconnect = FALSE;\r\n\r\n  imp_dbh->enable_utf8 = FALSE;     /* initialize mysql_enable_utf8 */\r\n  imp_dbh->enable_utf8mb4 = FALSE;  /* initialize mysql_enable_utf8mb4 */\r\n\r\n  if (!my_login(aTHX_ dbh, imp_dbh))\r\n  {\r\n    if(imp_dbh->pmysql) {\r\n        do_error(dbh, mysql_errno(imp_dbh->pmysql),\r\n                mysql_error(imp_dbh->pmysql) ,mysql_sqlstate(imp_dbh->pmysql));\r\n        Safefree(imp_dbh->pmysql);\r\n\r\n    }\r\n    return FALSE;\r\n  }\r\n\r\n    /*\r\n     *  Tell DBI, that dbh->disconnect should be called for this handle\r\n     */\r\n    DBIc_ACTIVE_on(imp_dbh);\r\n\r\n    /* Tell DBI, that dbh->destroy should be called for this handle */\r\n    DBIc_on(imp_dbh, DBIcf_IMPSET);\r\n\r\n    return TRUE;\r\n}", ".bd_db_commit": "int\r\ndbd_db_commit(SV* dbh, imp_dbh_t* imp_dbh)\r\n{\r\n  if (DBIc_has(imp_dbh, DBIcf_AutoCommit))\r\n    return FALSE;\r\n\r\n  ASYNC_CHECK_RETURN(dbh, FALSE);\r\n\r\n  if (imp_dbh->has_transactions)\r\n  {\r\n    if (mysql_commit(imp_dbh->pmysql))\r\n    {\r\n      do_error(dbh, mysql_errno(imp_dbh->pmysql), mysql_error(imp_dbh->pmysql)\r\n               ,mysql_sqlstate(imp_dbh->pmysql));\r\n      return FALSE;\r\n    }\r\n  }\r\n  else\r\n    do_warn(dbh, JW_ERR_NOT_IMPLEMENTED,\r\n            \"Commit ineffective because transactions are not available\");\r\n  return TRUE;\r\n}", ".bd_db_rollback": "int\r\ndbd_db_rollback(SV* dbh, imp_dbh_t* imp_dbh) {\r\n  /* croak, if not in AutoCommit mode */\r\n  if (DBIc_has(imp_dbh, DBIcf_AutoCommit))\r\n    return FALSE;\r\n\r\n  ASYNC_CHECK_RETURN(dbh, FALSE);\r\n\r\n  if (imp_dbh->has_transactions)\r\n  {\r\n      if (mysql_rollback(imp_dbh->pmysql))\r\n      {\r\n        do_error(dbh, mysql_errno(imp_dbh->pmysql),\r\n                 mysql_error(imp_dbh->pmysql) ,mysql_sqlstate(imp_dbh->pmysql));\r\n        return FALSE;\r\n      }\r\n  }\r\n  else\r\n    do_error(dbh, JW_ERR_NOT_IMPLEMENTED,\r\n             \"Rollback ineffective because transactions are not available\" ,NULL);\r\n  return TRUE;\r\n}", ".bd_db_destroy": "void dbd_db_destroy(SV* dbh, imp_dbh_t* imp_dbh) {\r\n\r\n    /*\r\n     *  Being on the safe side never hurts ...\r\n     */\r\n  if (DBIc_ACTIVE(imp_dbh))\r\n  {\r\n    if (imp_dbh->has_transactions)\r\n    {\r\n      if (!DBIc_has(imp_dbh, DBIcf_AutoCommit))\r\n        if (mysql_rollback(imp_dbh->pmysql))\r\n            do_error(dbh, TX_ERR_ROLLBACK,\"ROLLBACK failed\" ,NULL);\r\n    }\r\n    dbd_db_disconnect(dbh, imp_dbh);\r\n  }\r\n  Safefree(imp_dbh->pmysql);\r\n\r\n  /* Tell DBI, that dbh->destroy must no longer be called */\r\n  DBIc_off(imp_dbh, DBIcf_IMPSET);\r\n}", ".bd_db_STORE_attrib": "int\r\ndbd_db_STORE_attrib(\r\n                    SV* dbh,\r\n                    imp_dbh_t* imp_dbh,\r\n                    SV* keysv,\r\n                    SV* valuesv\r\n                   )\r\n{\r\n  dTHX;\r\n  STRLEN kl;\r\n  char *key = SvPV(keysv, kl);\r\n  SV *cachesv = Nullsv;\r\n  int cacheit = FALSE;\r\n  const bool bool_value = SvTRUE(valuesv);\r\n\r\n  if (kl==10 && strEQ(key, \"AutoCommit\"))\r\n  {\r\n    if (imp_dbh->has_transactions)\r\n    {\r\n      bool oldval = DBIc_has(imp_dbh,DBIcf_AutoCommit) ? 1 : 0;\r\n\r\n      if (bool_value == oldval)\r\n        return TRUE;\r\n\r\n      /* if setting AutoCommit on ... */\r\n      if (!imp_dbh->no_autocommit_cmd)\r\n      {\r\n        if (\r\n            mysql_autocommit(imp_dbh->pmysql, bool_value)\r\n           )\r\n        {\r\n          do_error(dbh, TX_ERR_AUTOCOMMIT,\r\n                   bool_value ?\r\n                   \"Turning on AutoCommit failed\" :\r\n                   \"Turning off AutoCommit failed\"\r\n                   ,NULL);\r\n          return TRUE;  /* TRUE means we handled it - important to avoid spurious errors */\r\n        }\r\n      }\r\n      DBIc_set(imp_dbh, DBIcf_AutoCommit, bool_value);\r\n    }\r\n    else\r\n    {\r\n      /*\r\n       *  We do support neither transactions nor \"AutoCommit\".\r\n       *  But we stub it. :-)\r\n      */\r\n      if (!bool_value)\r\n      {\r\n        do_error(dbh, JW_ERR_NOT_IMPLEMENTED,\r\n                 \"Transactions not supported by database\" ,NULL);\r\n        croak(\"Transactions not supported by database\");\r\n      }\r\n    }\r\n  }\r\n  else if (kl == 16 && strEQ(key,\"mysql_use_result\"))\r\n    imp_dbh->use_mysql_use_result = bool_value;\r\n  else if (kl == 20 && strEQ(key,\"mysql_auto_reconnect\"))\r\n    imp_dbh->auto_reconnect = bool_value;\r\n  else if (kl == 20 && strEQ(key, \"mysql_server_prepare\"))\r\n    imp_dbh->use_server_side_prepare = bool_value;\r\n  else if (kl == 37 && strEQ(key, \"mysql_server_prepare_disable_fallback\"))\r\n    imp_dbh->disable_fallback_for_server_prepare = bool_value;\r\n  else if (kl == 23 && strEQ(key,\"mysql_no_autocommit_cmd\"))\r\n    imp_dbh->no_autocommit_cmd = bool_value;\r\n  else if (kl == 24 && strEQ(key,\"mysql_bind_type_guessing\"))\r\n    imp_dbh->bind_type_guessing = bool_value;\r\n  else if (kl == 31 && strEQ(key,\"mysql_bind_comment_placeholders\"))\r\n    imp_dbh->bind_type_guessing = bool_value;\r\n  else if (kl == 17 && strEQ(key, \"mysql_enable_utf8\"))\r\n    imp_dbh->enable_utf8 = bool_value;\r\n  else if (kl == 20 && strEQ(key, \"mysql_enable_utf8mb4\"))\r\n    imp_dbh->enable_utf8mb4 = bool_value;\r\n  else\r\n    return FALSE;\t\t\t\t/* Unknown key */\r\n\r\n  if (cacheit) /* cache value for later DBI 'quick' fetch? */\r\n    (void)hv_store((HV*)SvRV(dbh), key, kl, cachesv, 0);\r\n  return TRUE;\r\n}", ".ysql_st_free_result_sets": "int mysql_st_free_result_sets (SV * sth, imp_sth_t * imp_sth)\r\n{\r\n  dTHX;\r\n  D_imp_dbh_from_sth;\r\n  D_imp_xxh(sth);\r\n  int next_result_rc= -1;\r\n\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t>- dbd_st_free_result_sets\\n\");\r\n\r\n  do\r\n  {\r\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t<- dbd_st_free_result_sets RC %d\\n\", next_result_rc);\r\n\r\n    if (next_result_rc == 0)\r\n    {\r\n      if (!(imp_sth->result = mysql_use_result(imp_dbh->pmysql)))\r\n      {\r\n        /* Check for possible error */\r\n        if (mysql_field_count(imp_dbh->pmysql))\r\n        {\r\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n          PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t<- dbd_st_free_result_sets ERROR: %s\\n\",\r\n                                  mysql_error(imp_dbh->pmysql));\r\n\r\n          do_error(sth, mysql_errno(imp_dbh->pmysql), mysql_error(imp_dbh->pmysql),\r\n                   mysql_sqlstate(imp_dbh->pmysql));\r\n          return 0;\r\n        }\r\n      }\r\n    }\r\n    if (imp_sth->result)\r\n    {\r\n      mysql_free_result(imp_sth->result);\r\n      imp_sth->result=NULL;\r\n    }\r\n  } while ((next_result_rc=mysql_next_result(imp_dbh->pmysql))==0);\r\n\r\n  if (next_result_rc > 0)\r\n  {\r\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t<- dbd_st_free_result_sets: Error while processing multi-result set: %s\\n\",\r\n                    mysql_error(imp_dbh->pmysql));\r\n\r\n    do_error(sth, mysql_errno(imp_dbh->pmysql), mysql_error(imp_dbh->pmysql),\r\n             mysql_sqlstate(imp_dbh->pmysql));\r\n  }\r\n\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t<- dbd_st_free_result_sets\\n\");\r\n\r\n  return 1;\r\n}", ".bd_st_more_results": "int dbd_st_more_results(SV* sth, imp_sth_t* imp_sth)\r\n{\r\n  dTHX;\r\n  D_imp_dbh_from_sth;\r\n  D_imp_xxh(sth);\r\n\r\n  int use_mysql_use_result=imp_sth->use_mysql_use_result;\r\n  int next_result_return_code, i;\r\n  MYSQL* svsock= imp_dbh->pmysql;\r\n\r\n  if (!SvROK(sth) || SvTYPE(SvRV(sth)) != SVt_PVHV)\r\n    croak(\"Expected hash array\");\r\n\r\n  if (!mysql_more_results(svsock))\r\n  {\r\n    /* No more pending result set(s)*/\r\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n\t\t    \"\\n      <- dbs_st_more_results no more results\\n\");\r\n    return 0;\r\n  }\r\n\r\n  if (imp_sth->use_server_side_prepare)\r\n  {\r\n    do_warn(sth, JW_ERR_NOT_IMPLEMENTED,\r\n            \"Processing of multiple result set is not possible with server side prepare\");\r\n    return 0;\r\n  }\r\n\r\n  /*\r\n   *  Free cached array attributes\r\n   */\r\n  for (i= 0; i < AV_ATTRIB_LAST;  i++)\r\n  {\r\n    if (imp_sth->av_attr[i])\r\n      SvREFCNT_dec(imp_sth->av_attr[i]);\r\n\r\n    imp_sth->av_attr[i]= Nullav;\r\n  }\r\n\r\n  /* Release previous MySQL result*/\r\n  if (imp_sth->result)\r\n  {\r\n    mysql_free_result(imp_sth->result);\r\n    imp_sth->result= NULL;\r\n  }\r\n\r\n  if (DBIc_ACTIVE(imp_sth))\r\n    DBIc_ACTIVE_off(imp_sth);\r\n\r\n  next_result_return_code= mysql_next_result(svsock);\r\n\r\n  imp_sth->warning_count = mysql_warning_count(imp_dbh->pmysql);\r\n\r\n  /*\r\n    mysql_next_result returns\r\n      0 if there are more results\r\n     -1 if there are no more results\r\n     >0 if there was an error\r\n   */\r\n  if (next_result_return_code > 0)\r\n  {\r\n    do_error(sth, mysql_errno(svsock), mysql_error(svsock),\r\n             mysql_sqlstate(svsock));\r\n\r\n    return 0;\r\n  }\r\n  else if(next_result_return_code == -1)                                                                                                                  \r\n  {                                                                                                                                                       \r\n    return 0;                                                                                                                                             \r\n  }  \r\n  else\r\n  {\r\n    /* Store the result from the Query */\r\n    imp_sth->result = use_mysql_use_result ?\r\n     mysql_use_result(svsock) : mysql_store_result(svsock);\r\n\r\n    if (mysql_errno(svsock))\r\n    {\r\n      do_error(sth, mysql_errno(svsock), mysql_error(svsock), \r\n               mysql_sqlstate(svsock));\r\n      return 0;\r\n    }\r\n\r\n    imp_sth->row_num= mysql_affected_rows(imp_dbh->pmysql);\r\n\r\n    if (imp_sth->result == NULL)\r\n    {\r\n      /* No \"real\" rowset*/\r\n      DBIc_NUM_FIELDS(imp_sth)= 0; /* for DBI <= 1.53 */\r\n      DBIS->set_attr_k(sth, sv_2mortal(newSVpvn(\"NUM_OF_FIELDS\",13)), 0,\r\n\t\t\t               sv_2mortal(newSViv(0)));\r\n      return 1;\r\n    }\r\n    else\r\n    {\r\n      /* We have a new rowset */\r\n      imp_sth->currow=0;\r\n\r\n\r\n      /* delete cached handle attributes */\r\n      /* XXX should be driven by a list to ease maintenance */\r\n      (void)hv_delete((HV*)SvRV(sth), \"NAME\", 4, G_DISCARD);\r\n      (void)hv_delete((HV*)SvRV(sth), \"NULLABLE\", 8, G_DISCARD);\r\n      (void)hv_delete((HV*)SvRV(sth), \"NUM_OF_FIELDS\", 13, G_DISCARD);\r\n      (void)hv_delete((HV*)SvRV(sth), \"PRECISION\", 9, G_DISCARD);\r\n      (void)hv_delete((HV*)SvRV(sth), \"SCALE\", 5, G_DISCARD);\r\n      (void)hv_delete((HV*)SvRV(sth), \"TYPE\", 4, G_DISCARD);\r\n      (void)hv_delete((HV*)SvRV(sth), \"mysql_insertid\", 14, G_DISCARD);\r\n      (void)hv_delete((HV*)SvRV(sth), \"mysql_is_auto_increment\", 23, G_DISCARD);\r\n      (void)hv_delete((HV*)SvRV(sth), \"mysql_is_blob\", 13, G_DISCARD);\r\n      (void)hv_delete((HV*)SvRV(sth), \"mysql_is_key\", 12, G_DISCARD);\r\n      (void)hv_delete((HV*)SvRV(sth), \"mysql_is_num\", 12, G_DISCARD);\r\n      (void)hv_delete((HV*)SvRV(sth), \"mysql_is_pri_key\", 16, G_DISCARD);\r\n      (void)hv_delete((HV*)SvRV(sth), \"mysql_length\", 12, G_DISCARD);\r\n      (void)hv_delete((HV*)SvRV(sth), \"mysql_max_length\", 16, G_DISCARD);\r\n      (void)hv_delete((HV*)SvRV(sth), \"mysql_table\", 11, G_DISCARD);\r\n      (void)hv_delete((HV*)SvRV(sth), \"mysql_type\", 10, G_DISCARD);\r\n      (void)hv_delete((HV*)SvRV(sth), \"mysql_type_name\", 15, G_DISCARD);\r\n      (void)hv_delete((HV*)SvRV(sth), \"mysql_warning_count\", 20, G_DISCARD);\r\n\r\n      /* Adjust NUM_OF_FIELDS - which also adjusts the row buffer size */\r\n      DBIc_NUM_FIELDS(imp_sth)= 0; /* for DBI <= 1.53 */\r\n      DBIc_DBISTATE(imp_sth)->set_attr_k(sth, sv_2mortal(newSVpvn(\"NUM_OF_FIELDS\",13)), 0,\r\n          sv_2mortal(newSViv(mysql_num_fields(imp_sth->result)))\r\n      );\r\n\r\n      DBIc_ACTIVE_on(imp_sth);\r\n\r\n      imp_sth->done_desc = 0;\r\n    }\r\n    imp_dbh->pmysql->net.last_errno= 0;\r\n    return 1;\r\n  }\r\n}", ".ysql_st_internal_execute": "my_ulonglong mysql_st_internal_execute(\r\n                                       SV *h, /* could be sth or dbh */\r\n                                       SV *statement,\r\n                                       SV *attribs,\r\n                                       int num_params,\r\n                                       imp_sth_ph_t *params,\r\n                                       MYSQL_RES **result,\r\n                                       MYSQL *svsock,\r\n                                       int use_mysql_use_result\r\n                                      )\r\n{\r\n  dTHX;\r\n  bool bind_type_guessing= FALSE;\r\n  bool bind_comment_placeholders= TRUE;\r\n  STRLEN slen;\r\n  char *sbuf = SvPV(statement, slen);\r\n  char *salloc;\r\n  int htype;\r\n  bool async = FALSE;\r\n  my_ulonglong rows= 0;\r\n  /* thank you DBI.c for this info! */\r\n  D_imp_xxh(h);\r\n  attribs= attribs;\r\n\r\n  htype= DBIc_TYPE(imp_xxh);\r\n  /*\r\n    It is important to import imp_dbh properly according to the htype\r\n    that it is! Also, one might ask why bind_type_guessing is assigned\r\n    in each block. Well, it's because D_imp_ macros called in these\r\n    blocks make it so imp_dbh is not \"visible\" or defined outside of the\r\n    if/else (when compiled, it fails for imp_dbh not being defined).\r\n  */\r\n  /* h is a dbh */\r\n  if (htype == DBIt_DB)\r\n  {\r\n    D_imp_dbh(h);\r\n    /* if imp_dbh is not available, it causes segfault (proper) on OpenBSD */\r\n    if (imp_dbh)\r\n    {\r\n      bind_type_guessing= imp_dbh->bind_type_guessing;\r\n      bind_comment_placeholders= imp_dbh->bind_comment_placeholders;\r\n    }\r\n    async = (bool) (imp_dbh->async_query_in_flight != NULL);\r\n  }\r\n  /* h is a sth */\r\n  else\r\n  {\r\n    D_imp_sth(h);\r\n    D_imp_dbh_from_sth;\r\n    /* if imp_dbh is not available, it causes segfault (proper) on OpenBSD */\r\n    if (imp_dbh)\r\n    {\r\n      bind_type_guessing= imp_dbh->bind_type_guessing;\r\n      bind_comment_placeholders= imp_dbh->bind_comment_placeholders;\r\n    }\r\n    async = imp_sth->is_async;\r\n    if(async) {\r\n        imp_dbh->async_query_in_flight = imp_sth;\r\n    } else {\r\n        imp_dbh->async_query_in_flight = NULL;\r\n    }\r\n  }\r\n\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"mysql_st_internal_execute MYSQL_VERSION_ID %d\\n\",\r\n                  MYSQL_VERSION_ID );\r\n\r\n  salloc= parse_params(imp_xxh,\r\n                              aTHX_ svsock,\r\n                              sbuf,\r\n                              &slen,\r\n                              params,\r\n                              num_params,\r\n                              bind_type_guessing,\r\n                              bind_comment_placeholders);\r\n\r\n  if (salloc)\r\n  {\r\n    sbuf= salloc;\r\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"Binding parameters: %s\\n\", sbuf);\r\n  }\r\n\r\n  if(async) {\r\n    if((mysql_send_query(svsock, sbuf, slen)) &&\r\n       (!mysql_db_reconnect(h) ||\r\n        (mysql_send_query(svsock, sbuf, slen))))\r\n    {\r\n        rows = -2;\r\n    } else {\r\n        rows = 0;\r\n    }\r\n  } else {\r\n      if ((mysql_real_query(svsock, sbuf, slen))  &&\r\n          (!mysql_db_reconnect(h)  ||\r\n           (mysql_real_query(svsock, sbuf, slen))))\r\n      {\r\n        rows = -2;\r\n      } else {\r\n          /** Store the result from the Query */\r\n          *result= use_mysql_use_result ?\r\n            mysql_use_result(svsock) : mysql_store_result(svsock);\r\n\r\n          if (mysql_errno(svsock))\r\n            rows = -2;\r\n          else if (*result)\r\n            rows = mysql_num_rows(*result);\r\n          else {\r\n            rows = mysql_affected_rows(svsock);\r\n            /* mysql_affected_rows(): -1 indicates that the query returned an error */\r\n            if (rows == (my_ulonglong)-1)\r\n              rows = -2;\r\n          }\r\n      }\r\n  }\r\n\r\n  if (salloc)\r\n    Safefree(salloc);\r\n\r\n  if(rows == (my_ulonglong)-2) {\r\n    do_error(h, mysql_errno(svsock), mysql_error(svsock), \r\n             mysql_sqlstate(svsock));\r\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"IGNORING ERROR errno %d\\n\", mysql_errno(svsock));\r\n  }\r\n  return(rows);\r\n}", ".bd_st_execute": "int dbd_st_execute(SV* sth, imp_sth_t* imp_sth)\r\n{\r\n  dTHX;\r\n  char actual_row_num[64];\r\n  int i;\r\n  SV **statement;\r\n  D_imp_dbh_from_sth;\r\n  D_imp_xxh(sth);\r\n#if defined (dTHR)\r\n  dTHR;\r\n#endif\r\n  int use_server_side_prepare = imp_sth->use_server_side_prepare;\r\n  int disable_fallback_for_server_prepare = imp_sth->disable_fallback_for_server_prepare;\r\n\r\n  ASYNC_CHECK_RETURN(sth, -2);\r\n\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n      \" -> dbd_st_execute for %p\\n\", sth);\r\n\r\n  if (!SvROK(sth)  ||  SvTYPE(SvRV(sth)) != SVt_PVHV)\r\n    croak(\"Expected hash array\");\r\n\r\n  /* Free cached array attributes */\r\n  for (i= 0;  i < AV_ATTRIB_LAST;  i++)\r\n  {\r\n    if (imp_sth->av_attr[i])\r\n      SvREFCNT_dec(imp_sth->av_attr[i]);\r\n\r\n    imp_sth->av_attr[i]= Nullav;\r\n  }\r\n\r\n  statement= hv_fetch((HV*) SvRV(sth), \"Statement\", 9, FALSE);\r\n\r\n  /* \r\n     Clean-up previous result set(s) for sth to prevent\r\n     'Commands out of sync' error \r\n  */\r\n  mysql_st_free_result_sets (sth, imp_sth);\r\n\r\n  if (use_server_side_prepare)\r\n  {\r\n    if (imp_sth->use_mysql_use_result)\r\n    {\r\n      if (disable_fallback_for_server_prepare)\r\n      {\r\n        do_error(sth, ER_UNSUPPORTED_PS,\r\n                 \"\\\"mysql_use_result\\\" not supported with server side prepare\",\r\n                 \"HY000\");\r\n        return 0;\r\n      }\r\n      use_server_side_prepare = 0;\r\n    }\r\n\r\n    if (use_server_side_prepare)\r\n    {\r\n      imp_sth->row_num= mysql_st_internal_execute41(\r\n                                                    sth,\r\n                                                    DBIc_NUM_PARAMS(imp_sth),\r\n                                                    &imp_sth->result,\r\n                                                    imp_sth->stmt,\r\n                                                    imp_sth->bind,\r\n                                                    &imp_sth->has_been_bound\r\n                                                   );\r\n      if (imp_sth->row_num == (my_ulonglong)-2) /* -2 means error */\r\n      {\r\n        SV *err = DBIc_ERR(imp_xxh);\r\n        if (!disable_fallback_for_server_prepare && SvIV(err) == ER_UNSUPPORTED_PS)\r\n        {\r\n          use_server_side_prepare = 0;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  if (!use_server_side_prepare)\r\n  {\r\n    imp_sth->row_num= mysql_st_internal_execute(\r\n                                                sth,\r\n                                                *statement,\r\n                                                NULL,\r\n                                                DBIc_NUM_PARAMS(imp_sth),\r\n                                                imp_sth->params,\r\n                                                &imp_sth->result,\r\n                                                imp_dbh->pmysql,\r\n                                                imp_sth->use_mysql_use_result\r\n                                               );\r\n    if(imp_dbh->async_query_in_flight) {\r\n        DBIc_ACTIVE_on(imp_sth);\r\n        return 0;\r\n    }\r\n  }\r\n\r\n  if (imp_sth->row_num+1 != (my_ulonglong)-1)\r\n  {\r\n    if (!imp_sth->result)\r\n    {\r\n      imp_sth->insertid= mysql_insert_id(imp_dbh->pmysql);\r\n      if (mysql_more_results(imp_dbh->pmysql))\r\n        DBIc_ACTIVE_on(imp_sth);\r\n    }\r\n    else\r\n    {\r\n      /** Store the result in the current statement handle */\r\n      DBIc_NUM_FIELDS(imp_sth)= mysql_num_fields(imp_sth->result);\r\n      DBIc_ACTIVE_on(imp_sth);\r\n      if (!use_server_side_prepare)\r\n        imp_sth->done_desc= 0;\r\n      imp_sth->fetch_done= 0;\r\n    }\r\n  }\r\n\r\n  imp_sth->warning_count = mysql_warning_count(imp_dbh->pmysql);\r\n\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n  {\r\n    /* \r\n      PerlIO_printf doesn't always handle imp_sth->row_num %llu \r\n      consistently!!\r\n    */\r\n    sprintf(actual_row_num, \"%lu\", imp_sth->row_num);\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                  \" <- dbd_st_execute returning imp_sth->row_num %s\\n\",\r\n                  actual_row_num);\r\n  }\r\n\r\n  return (int)imp_sth->row_num;\r\n}", ".bd_st_finish": "int dbd_st_finish(SV* sth, imp_sth_t* imp_sth) {\r\n  dTHX;\r\n  D_imp_xxh(sth);\r\n\r\n#if defined (dTHR)\r\n  dTHR;\r\n#endif\r\n\r\n  D_imp_dbh_from_sth;\r\n  if(imp_dbh->async_query_in_flight) {\r\n    mysql_db_async_result(sth, &imp_sth->result);\r\n  }\r\n\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n  {\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\n--> dbd_st_finish\\n\");\r\n  }\r\n\r\n  if (imp_sth->use_server_side_prepare)\r\n  {\r\n    if (imp_sth && imp_sth->stmt)\r\n    {\r\n      if (!mysql_st_clean_cursor(sth, imp_sth))\r\n      {\r\n        do_error(sth, JW_ERR_SEQUENCE,\r\n                 \"Error happened while tried to clean up stmt\",NULL);\r\n        return 0;\r\n      }\r\n    }\r\n  }\r\n\r\n  /*\r\n    Cancel further fetches from this cursor.\r\n    We don't close the cursor till DESTROY.\r\n    The application may re execute it.\r\n  */\r\n  if (imp_sth && DBIc_ACTIVE(imp_sth))\r\n  {\r\n    /*\r\n      Clean-up previous result set(s) for sth to prevent\r\n      'Commands out of sync' error\r\n    */\r\n    mysql_st_free_result_sets(sth, imp_sth);\r\n  }\r\n  DBIc_ACTIVE_off(imp_sth);\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n  {\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\n<-- dbd_st_finish\\n\");\r\n  }\r\n  return 1;\r\n}", ".ysql_db_reconnect": "int mysql_db_reconnect(SV* h)\r\n{\r\n  dTHX;\r\n  D_imp_xxh(h);\r\n  imp_dbh_t* imp_dbh;\r\n  MYSQL save_socket;\r\n\r\n  if (DBIc_DBISTATE(imp_xxh)->debug >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"reconnecting\\n\");\r\n\r\n  if (DBIc_TYPE(imp_xxh) == DBIt_ST)\r\n  {\r\n    imp_dbh = (imp_dbh_t*) DBIc_PARENT_COM(imp_xxh);\r\n    h = DBIc_PARENT_H(imp_xxh);\r\n  }\r\n  else\r\n    imp_dbh= (imp_dbh_t*) imp_xxh;\r\n\r\n  /* reconnect a closed connection, used in do() for implicit reconnect */\r\n  if (!DBIc_has(imp_dbh, DBIcf_ACTIVE) && DBIc_has(imp_dbh, DBIcf_AutoCommit)) {\r\n    if (my_login(aTHX_ h, imp_dbh)) {\r\n      DBIc_ACTIVE_on(imp_dbh);\r\n      DBIc_set(imp_dbh, DBIcf_AutoCommit, TRUE);\r\n      return TRUE;\r\n    }\r\n    return FALSE;\r\n  }\r\n\r\n  if (mysql_errno(imp_dbh->pmysql) != CR_SERVER_GONE_ERROR &&\r\n#ifdef ER_CLIENT_INTERACTION_TIMEOUT /* Added in 8.0.24 */\r\n          mysql_errno(imp_dbh->pmysql) != ER_CLIENT_INTERACTION_TIMEOUT &&\r\n#endif\r\n          mysql_errno(imp_dbh->pmysql) != CR_SERVER_LOST) {\r\n    /* Other error */\r\n    if (DBIc_DBISTATE(imp_xxh)->debug >= 2)\r\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"Can't reconnect on unexpected error %d\\n\",\r\n          mysql_errno(imp_dbh->pmysql));\r\n    return FALSE;\r\n  }\r\n\r\n  if (!DBIc_has(imp_dbh, DBIcf_AutoCommit) || !imp_dbh->auto_reconnect)\r\n  {\r\n    /* We never reconnect if AutoCommit is turned off.\r\n     * Otherwise we might get an inconsistent transaction\r\n     * state.\r\n     */\r\n    if (DBIc_DBISTATE(imp_xxh)->debug >= 2)\r\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"Can't reconnect as AutoCommit is turned off\\n\");\r\n    return FALSE;\r\n  }\r\n\r\n  /* my_login will blow away imp_dbh->mysql so we save a copy of\r\n   * imp_dbh->mysql and put it back where it belongs if the reconnect\r\n   * fail.  Think server is down & reconnect fails but the application eval{}s\r\n   * the execute, so next time $dbh->quote() gets called, instant SIGSEGV!\r\n   */\r\n  save_socket= *(imp_dbh->pmysql);\r\n  memcpy (&save_socket, imp_dbh->pmysql,sizeof(save_socket));\r\n  memset (imp_dbh->pmysql,0,sizeof(*(imp_dbh->pmysql)));\r\n\r\n  /* we should disconnect the db handle before reconnecting, this will\r\n   * prevent my_login from thinking it's adopting an active child which\r\n   * would prevent the handle from actually reconnecting\r\n   */\r\n  if (!dbd_db_disconnect(h, imp_dbh) || !my_login(aTHX_ h, imp_dbh))\r\n  {\r\n    do_error(h, mysql_errno(imp_dbh->pmysql), mysql_error(imp_dbh->pmysql),\r\n             mysql_sqlstate(imp_dbh->pmysql));\r\n    memcpy (imp_dbh->pmysql, &save_socket, sizeof(save_socket));\r\n    ++imp_dbh->stats.auto_reconnects_failed;\r\n    return FALSE;\r\n  }\r\n\r\n  /*\r\n   *  Tell DBI, that dbh->disconnect should be called for this handle\r\n   */\r\n  DBIc_ACTIVE_on(imp_dbh);\r\n\r\n  ++imp_dbh->stats.auto_reconnects_ok;\r\n  return TRUE;\r\n}", ".ysql_db_async_result": "int mysql_db_async_result(SV* h, MYSQL_RES** resp)\r\n{\r\n  dTHX;\r\n  D_imp_xxh(h);\r\n  imp_dbh_t* dbh;\r\n  MYSQL* svsock = NULL;\r\n  MYSQL_RES* _res;\r\n  int retval = 0;\r\n  int htype;\r\n  bool async_sth = FALSE;\r\n\r\n  if(! resp) {\r\n      resp = &_res;\r\n  }\r\n  htype = DBIc_TYPE(imp_xxh);\r\n\r\n\r\n  if(htype == DBIt_DB) {\r\n      D_imp_dbh(h);\r\n      dbh = imp_dbh;\r\n  } else {\r\n      D_imp_sth(h);\r\n      D_imp_dbh_from_sth;\r\n      dbh = imp_dbh;\r\n      async_sth = imp_sth->is_async;\r\n      retval = imp_sth->row_num;\r\n  }\r\n\r\n  if(! dbh->async_query_in_flight) {\r\n      if (async_sth)\r\n          return retval;\r\n      do_error(h, 2000, \"Gathering asynchronous results for a synchronous handle\", \"HY000\");\r\n      return -1;\r\n  }\r\n  if(dbh->async_query_in_flight != imp_xxh) {\r\n      do_error(h, 2000, \"Gathering async_query_in_flight results for the wrong handle\", \"HY000\");\r\n      return -1;\r\n  }\r\n  dbh->async_query_in_flight = NULL;\r\n\r\n  svsock= dbh->pmysql;\r\n  retval= mysql_read_query_result(svsock);\r\n  if(! retval) {\r\n    *resp= mysql_store_result(svsock);\r\n\r\n    if (mysql_errno(svsock))\r\n      do_error(h, mysql_errno(svsock), mysql_error(svsock), mysql_sqlstate(svsock));\r\n    if (!*resp)\r\n      retval= mysql_affected_rows(svsock);\r\n    else {\r\n      retval= mysql_num_rows(*resp);\r\n      if(resp == &_res) {\r\n        mysql_free_result(*resp);\r\n        *resp= NULL;\r\n      }\r\n    }\r\n    if(htype == DBIt_ST) {\r\n      D_imp_sth(h);\r\n      D_imp_dbh_from_sth;\r\n\r\n      if((my_ulonglong)retval+1 != (my_ulonglong)-1) {\r\n        if(! *resp) {\r\n          imp_sth->insertid= mysql_insert_id(svsock);\r\n          if(! mysql_more_results(svsock))\r\n            DBIc_ACTIVE_off(imp_sth);\r\n        } else {\r\n          DBIc_NUM_FIELDS(imp_sth)= mysql_num_fields(imp_sth->result);\r\n          imp_sth->done_desc= 0;\r\n          imp_sth->fetch_done= 0;\r\n        }\r\n      }\r\n      imp_sth->warning_count = mysql_warning_count(imp_dbh->pmysql);\r\n    }\r\n  } else {\r\n     do_error(h, mysql_errno(svsock), mysql_error(svsock),\r\n              mysql_sqlstate(svsock));\r\n     return -1;\r\n  }\r\n return retval;\r\n}", ".ysql_db_async_ready": "int mysql_db_async_ready(SV* h)\r\n{\r\n  dTHX;\r\n  D_imp_xxh(h);\r\n  imp_dbh_t* dbh;\r\n  int htype;\r\n  bool async_sth = FALSE;\r\n  bool async_active = FALSE;\r\n\r\n  htype = DBIc_TYPE(imp_xxh);\r\n  \r\n  if(htype == DBIt_DB) {\r\n      D_imp_dbh(h);\r\n      dbh = imp_dbh;\r\n  } else {\r\n      D_imp_sth(h);\r\n      D_imp_dbh_from_sth;\r\n      dbh = imp_dbh;\r\n      async_sth = imp_sth->is_async;\r\n      async_active = !!DBIc_ACTIVE(imp_sth);\r\n  }\r\n\r\n  if(dbh->async_query_in_flight) {\r\n      if(dbh->async_query_in_flight == imp_xxh && dbh->pmysql->net.fd != -1) {\r\n          int retval = mysql_socket_ready(dbh->pmysql->net.fd);\r\n          if(retval < 0) {\r\n              do_error(h, -retval, strerror(-retval), \"HY000\");\r\n          }\r\n          return retval;\r\n      } else {\r\n          do_error(h, 2000, \"Calling mysql_async_ready on the wrong handle\", \"HY000\");\r\n          return -1;\r\n      }\r\n  } else {\r\n      if (async_sth) {\r\n          if (async_active)\r\n              return 1;\r\n          do_error(h, 2000, \"Asynchronous handle was not executed yet\", \"HY000\");\r\n          return -1;\r\n      }\r\n      do_error(h, 2000, \"Handle is not in asynchronous mode\", \"HY000\");\r\n      return -1;\r\n  }\r\n}", ".ysql_st_clean_cursor": "int mysql_st_clean_cursor(SV* sth, imp_sth_t* imp_sth) {\r\n\r\n  if (DBIc_ACTIVE(imp_sth) && dbd_describe(sth, imp_sth) &&\r\n      !imp_sth->fetch_done)\r\n    mysql_stmt_free_result(imp_sth->stmt);\r\n  return 1;\r\n}"}, "function_name": "parse_number"}
{"function_id": null, "caller": {".y_login": "static int my_login(pTHX_ SV* dbh, imp_dbh_t *imp_dbh)\r\n{\r\n  SV* sv;\r\n  HV* hv;\r\n  char* dbname;\r\n  char* host;\r\n  char* port;\r\n  char* user;\r\n  char* password;\r\n  char* mysql_socket;\r\n  int   result;\r\n  D_imp_xxh(dbh);\r\n\r\n  /* TODO- resolve this so that it is set only if DBI is 1.607 */\r\n#define TAKE_IMP_DATA_VERSION 1\r\n#if TAKE_IMP_DATA_VERSION\r\n  if (DBIc_has(imp_dbh, DBIcf_IMPSET))\r\n  { /* eg from take_imp_data() */\r\n    if (DBIc_has(imp_dbh, DBIcf_ACTIVE))\r\n    {\r\n      if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n        PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"my_login skip connect\\n\");\r\n      /* tell our parent we've adopted an active child */\r\n      ++DBIc_ACTIVE_KIDS(DBIc_PARENT_COM(imp_dbh));\r\n      return TRUE;\r\n    }\r\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                    \"my_login IMPSET but not ACTIVE so connect not skipped\\n\");\r\n  }\r\n#endif\r\n\r\n  sv = DBIc_IMP_DATA(imp_dbh);\r\n\r\n  if (!sv  ||  !SvROK(sv))\r\n    return FALSE;\r\n\r\n  hv = (HV*) SvRV(sv);\r\n  if (SvTYPE(hv) != SVt_PVHV)\r\n    return FALSE;\r\n\r\n  host=\t\tsafe_hv_fetch(aTHX_ hv, \"host\", 4);\r\n  port=\t\tsafe_hv_fetch(aTHX_ hv, \"port\", 4);\r\n  user=\t\tsafe_hv_fetch(aTHX_ hv, \"user\", 4);\r\n  password=\tsafe_hv_fetch(aTHX_ hv, \"password\", 8);\r\n  dbname=\tsafe_hv_fetch(aTHX_ hv, \"database\", 8);\r\n  mysql_socket=\tsafe_hv_fetch(aTHX_ hv, \"mysql_socket\", 12);\r\n\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n\t\t  \"imp_dbh->my_login : dbname = %s, uid = %s, pwd = %s,\" \\\r\n\t\t  \"host = %s, port = %s\\n\",\r\n\t\t  dbname ? dbname : \"NULL\",\r\n\t\t  user ? user : \"NULL\",\r\n\t\t  password ? password : \"NULL\",\r\n\t\t  host ? host : \"NULL\",\r\n\t\t  port ? port : \"NULL\");\r\n\r\n  if (!imp_dbh->pmysql) {\r\n     Newz(908, imp_dbh->pmysql, 1, MYSQL);\r\n     imp_dbh->pmysql->net.fd = -1;\r\n  }\r\n  result = mysql_dr_connect(dbh, imp_dbh->pmysql, mysql_socket, host, port, user,\r\n\t\t\t  password, dbname, imp_dbh) ? TRUE : FALSE;\r\n  return result;\r\n}", ".o_error": "void do_error(SV* h, int rc, const char* what, const char* sqlstate)\r\n{\r\n  dTHX;\r\n  D_imp_xxh(h);\r\n  SV *errstr;\r\n  SV *errstate;\r\n\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\t--> do_error\\n\");\r\n  errstr= DBIc_ERRSTR(imp_xxh);\r\n  sv_setiv(DBIc_ERR(imp_xxh), (IV)rc);\t/* set err early\t*/\r\n  sv_setpv(errstr, what);\r\n\r\n  if (sqlstate)\r\n  {\r\n    errstate= DBIc_STATE(imp_xxh);\r\n    sv_setpvn(errstate, sqlstate, 5);\r\n  }\r\n\r\n  /* NO EFFECT DBIh_EVENT2(h, ERROR_event, DBIc_ERR(imp_xxh), errstr); */\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"%s error %d recorded: %s\\n\",\r\n    what, rc, SvPV_nolen(errstr));\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\t<-- do_error\\n\");\r\n}", ".o_warn": "void do_warn(SV* h, int rc, char* what)\r\n{\r\n  dTHX;\r\n  D_imp_xxh(h);\r\n\r\n  SV *errstr = DBIc_ERRSTR(imp_xxh);\r\n  sv_setiv(DBIc_ERR(imp_xxh), (IV)rc);\t/* set err early\t*/\r\n  sv_setpv(errstr, what);\r\n  /* NO EFFECT DBIh_EVENT2(h, WARN_event, DBIc_ERR(imp_xxh), errstr);*/\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"%s warning %d recorded: %s\\n\",\r\n    what, rc, SvPV_nolen(errstr));\r\n  warn(\"%s\", what);\r\n}", ".bd_db_disconnect": "int dbd_db_disconnect(SV* dbh, imp_dbh_t* imp_dbh)\r\n{\r\n#ifdef dTHR\r\n  dTHR;\r\n#endif\r\n  dTHX;\r\n  D_imp_xxh(dbh);\r\n\r\n  /* We assume that disconnect will always work       */\r\n  /* since most errors imply already disconnected.    */\r\n  DBIc_ACTIVE_off(imp_dbh);\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"imp_dbh->pmysql: %p\\n\",\r\n\t\t              imp_dbh->pmysql);\r\n  mysql_close(imp_dbh->pmysql );\r\n  imp_dbh->pmysql->net.fd = -1;\r\n\r\n  /* We don't free imp_dbh since a reference still exists    */\r\n  /* The DESTROY method is the only one to 'free' memory.    */\r\n  return TRUE;\r\n}", ".ysql_st_free_result_sets": "int mysql_st_free_result_sets (SV * sth, imp_sth_t * imp_sth)\r\n{\r\n  dTHX;\r\n  D_imp_dbh_from_sth;\r\n  D_imp_xxh(sth);\r\n  int next_result_rc= -1;\r\n\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t>- dbd_st_free_result_sets\\n\");\r\n\r\n  do\r\n  {\r\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t<- dbd_st_free_result_sets RC %d\\n\", next_result_rc);\r\n\r\n    if (next_result_rc == 0)\r\n    {\r\n      if (!(imp_sth->result = mysql_use_result(imp_dbh->pmysql)))\r\n      {\r\n        /* Check for possible error */\r\n        if (mysql_field_count(imp_dbh->pmysql))\r\n        {\r\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n          PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t<- dbd_st_free_result_sets ERROR: %s\\n\",\r\n                                  mysql_error(imp_dbh->pmysql));\r\n\r\n          do_error(sth, mysql_errno(imp_dbh->pmysql), mysql_error(imp_dbh->pmysql),\r\n                   mysql_sqlstate(imp_dbh->pmysql));\r\n          return 0;\r\n        }\r\n      }\r\n    }\r\n    if (imp_sth->result)\r\n    {\r\n      mysql_free_result(imp_sth->result);\r\n      imp_sth->result=NULL;\r\n    }\r\n  } while ((next_result_rc=mysql_next_result(imp_dbh->pmysql))==0);\r\n\r\n  if (next_result_rc > 0)\r\n  {\r\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t<- dbd_st_free_result_sets: Error while processing multi-result set: %s\\n\",\r\n                    mysql_error(imp_dbh->pmysql));\r\n\r\n    do_error(sth, mysql_errno(imp_dbh->pmysql), mysql_error(imp_dbh->pmysql),\r\n             mysql_sqlstate(imp_dbh->pmysql));\r\n  }\r\n\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t<- dbd_st_free_result_sets\\n\");\r\n\r\n  return 1;\r\n}", ".ount_params": "static int\r\ncount_params(imp_xxh_t *imp_xxh, pTHX_ char *statement, bool bind_comment_placeholders)\r\n{\r\n  bool comment_end= false;\r\n  char* ptr= statement;\r\n  int num_params= 0;\r\n  int comment_length= 0;\r\n  char c;\r\n\r\n  if (DBIc_DBISTATE(imp_xxh)->debug >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \">count_params statement %s\\n\", statement);\r\n\r\n  while ( (c = *ptr++) )\r\n  {\r\n    switch (c) {\r\n      /* so, this is a -- comment, so let's burn up characters */\r\n    case '-':\r\n      {\r\n          if (bind_comment_placeholders)\r\n          {\r\n              c = *ptr++;\r\n              break;\r\n          }\r\n          else\r\n          {\r\n              comment_length= 1;\r\n              /* let's see if the next one is a dash */\r\n              c = *ptr++;\r\n\r\n              if  (c == '-') {\r\n                  /* if two dashes, ignore everything until newline */\r\n                  while ((c = *ptr))\r\n                  {\r\n                      if (DBIc_DBISTATE(imp_xxh)->debug >= 2)\r\n                          PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"%c\\n\", c);\r\n                      ptr++;\r\n                      comment_length++;\r\n                      if (c == '\\n')\r\n                      {\r\n                          comment_end= true;\r\n                          break;\r\n                      }\r\n                  }\r\n                  /*\r\n                    if not comment_end, the comment never ended and we need to iterate\r\n                    back to the beginning of where we started and let the database \r\n                    handle whatever is in the statement\r\n                */\r\n                  if (! comment_end)\r\n                      ptr-= comment_length;\r\n              }\r\n              /* otherwise, only one dash/hyphen, backtrack by one */\r\n              else\r\n                  ptr--;\r\n              break;\r\n          }\r\n      }\r\n    /* c-type comments */\r\n    case '/':\r\n      {\r\n          if (bind_comment_placeholders)\r\n          {\r\n              c = *ptr++;\r\n              break;\r\n          }\r\n          else\r\n          {\r\n              c = *ptr++;\r\n              /* let's check if the next one is an asterisk */\r\n              if  (c == '*')\r\n              {\r\n                  comment_length= 0;\r\n                  comment_end= false;\r\n                  /* ignore everything until closing comment */\r\n                  while ((c= *ptr))\r\n                  {\r\n                      ptr++;\r\n                      comment_length++;\r\n\r\n                      if (c == '*')\r\n                      {\r\n                          c = *ptr++;\r\n                          /* alas, end of comment */\r\n                          if (c == '/')\r\n                          {\r\n                              comment_end= true;\r\n                              break;\r\n                          }\r\n                          /*\r\n                            nope, just an asterisk, not so fast, not\r\n                            end of comment, go back one\r\n                        */\r\n                          else\r\n                              ptr--;\r\n                      }\r\n                  }\r\n                  /*\r\n                    if the end of the comment was never found, we have\r\n                    to backtrack to wherever we first started skipping\r\n                    over the possible comment.\r\n                    This means we will pass the statement to the database\r\n                    to see its own fate and issue the error\r\n                */\r\n                  if (!comment_end)\r\n                      ptr -= comment_length;\r\n              }\r\n              else\r\n                  ptr--;\r\n              break;\r\n          }\r\n      }\r\n    case '`':\r\n    case '\"':\r\n    case '\\'':\r\n      /* Skip string */\r\n      {\r\n        char end_token = c;\r\n        while ((c = *ptr)  &&  c != end_token)\r\n        {\r\n          if (c == '\\\\')\r\n            if (! *(++ptr))\r\n              continue;\r\n\r\n          ++ptr;\r\n        }\r\n        if (c)\r\n          ++ptr;\r\n        break;\r\n      }\r\n\r\n    case '?':\r\n      ++num_params;\r\n      break;\r\n\r\n    default:\r\n      break;\r\n    }\r\n  }\r\n  return num_params;\r\n}", ".ysql_db_reconnect": "int mysql_db_reconnect(SV* h)\r\n{\r\n  dTHX;\r\n  D_imp_xxh(h);\r\n  imp_dbh_t* imp_dbh;\r\n  MYSQL save_socket;\r\n\r\n  if (DBIc_DBISTATE(imp_xxh)->debug >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"reconnecting\\n\");\r\n\r\n  if (DBIc_TYPE(imp_xxh) == DBIt_ST)\r\n  {\r\n    imp_dbh = (imp_dbh_t*) DBIc_PARENT_COM(imp_xxh);\r\n    h = DBIc_PARENT_H(imp_xxh);\r\n  }\r\n  else\r\n    imp_dbh= (imp_dbh_t*) imp_xxh;\r\n\r\n  /* reconnect a closed connection, used in do() for implicit reconnect */\r\n  if (!DBIc_has(imp_dbh, DBIcf_ACTIVE) && DBIc_has(imp_dbh, DBIcf_AutoCommit)) {\r\n    if (my_login(aTHX_ h, imp_dbh)) {\r\n      DBIc_ACTIVE_on(imp_dbh);\r\n      DBIc_set(imp_dbh, DBIcf_AutoCommit, TRUE);\r\n      return TRUE;\r\n    }\r\n    return FALSE;\r\n  }\r\n\r\n  if (mysql_errno(imp_dbh->pmysql) != CR_SERVER_GONE_ERROR &&\r\n#ifdef ER_CLIENT_INTERACTION_TIMEOUT /* Added in 8.0.24 */\r\n          mysql_errno(imp_dbh->pmysql) != ER_CLIENT_INTERACTION_TIMEOUT &&\r\n#endif\r\n          mysql_errno(imp_dbh->pmysql) != CR_SERVER_LOST) {\r\n    /* Other error */\r\n    if (DBIc_DBISTATE(imp_xxh)->debug >= 2)\r\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"Can't reconnect on unexpected error %d\\n\",\r\n          mysql_errno(imp_dbh->pmysql));\r\n    return FALSE;\r\n  }\r\n\r\n  if (!DBIc_has(imp_dbh, DBIcf_AutoCommit) || !imp_dbh->auto_reconnect)\r\n  {\r\n    /* We never reconnect if AutoCommit is turned off.\r\n     * Otherwise we might get an inconsistent transaction\r\n     * state.\r\n     */\r\n    if (DBIc_DBISTATE(imp_xxh)->debug >= 2)\r\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"Can't reconnect as AutoCommit is turned off\\n\");\r\n    return FALSE;\r\n  }\r\n\r\n  /* my_login will blow away imp_dbh->mysql so we save a copy of\r\n   * imp_dbh->mysql and put it back where it belongs if the reconnect\r\n   * fail.  Think server is down & reconnect fails but the application eval{}s\r\n   * the execute, so next time $dbh->quote() gets called, instant SIGSEGV!\r\n   */\r\n  save_socket= *(imp_dbh->pmysql);\r\n  memcpy (&save_socket, imp_dbh->pmysql,sizeof(save_socket));\r\n  memset (imp_dbh->pmysql,0,sizeof(*(imp_dbh->pmysql)));\r\n\r\n  /* we should disconnect the db handle before reconnecting, this will\r\n   * prevent my_login from thinking it's adopting an active child which\r\n   * would prevent the handle from actually reconnecting\r\n   */\r\n  if (!dbd_db_disconnect(h, imp_dbh) || !my_login(aTHX_ h, imp_dbh))\r\n  {\r\n    do_error(h, mysql_errno(imp_dbh->pmysql), mysql_error(imp_dbh->pmysql),\r\n             mysql_sqlstate(imp_dbh->pmysql));\r\n    memcpy (imp_dbh->pmysql, &save_socket, sizeof(save_socket));\r\n    ++imp_dbh->stats.auto_reconnects_failed;\r\n    return FALSE;\r\n  }\r\n\r\n  /*\r\n   *  Tell DBI, that dbh->disconnect should be called for this handle\r\n   */\r\n  DBIc_ACTIVE_on(imp_dbh);\r\n\r\n  ++imp_dbh->stats.auto_reconnects_ok;\r\n  return TRUE;\r\n}", ".ysql_to_perl_type": "static enum enum_field_types mysql_to_perl_type(enum enum_field_types type)\r\n{\r\n  enum enum_field_types enum_type;\r\n\r\n  switch (type) {\r\n  case MYSQL_TYPE_DOUBLE:\r\n  case MYSQL_TYPE_FLOAT:\r\n    enum_type= MYSQL_TYPE_DOUBLE;\r\n    break;\r\n\r\n  case MYSQL_TYPE_SHORT:\r\n  case MYSQL_TYPE_TINY:\r\n  case MYSQL_TYPE_LONG:\r\n  case MYSQL_TYPE_INT24:\r\n  case MYSQL_TYPE_YEAR:\r\n#if IVSIZE >= 8\r\n  case MYSQL_TYPE_LONGLONG:\r\n    enum_type= MYSQL_TYPE_LONGLONG;\r\n#else\r\n    enum_type= MYSQL_TYPE_LONG;\r\n#endif\r\n    break;\r\n\r\n  case MYSQL_TYPE_BIT:\r\n    enum_type= MYSQL_TYPE_BIT;\r\n    break;\r\n\r\n  case MYSQL_TYPE_NEWDECIMAL:\r\n  case MYSQL_TYPE_DECIMAL:\r\n    enum_type= MYSQL_TYPE_DECIMAL;\r\n    break;\r\n\r\n#if IVSIZE < 8\r\n  case MYSQL_TYPE_LONGLONG:\r\n#endif\r\n  case MYSQL_TYPE_DATE:\r\n  case MYSQL_TYPE_TIME:\r\n  case MYSQL_TYPE_DATETIME:\r\n  case MYSQL_TYPE_NEWDATE:\r\n  case MYSQL_TYPE_TIMESTAMP:\r\n  case MYSQL_TYPE_VAR_STRING:\r\n  case MYSQL_TYPE_VARCHAR:\r\n  case MYSQL_TYPE_STRING:\r\n    enum_type= MYSQL_TYPE_STRING;\r\n    break;\r\n\r\n  case MYSQL_TYPE_GEOMETRY:\r\n  case MYSQL_TYPE_BLOB:\r\n  case MYSQL_TYPE_TINY_BLOB:\r\n    enum_type= MYSQL_TYPE_BLOB;\r\n    break;\r\n\r\n  default:\r\n    enum_type= MYSQL_TYPE_STRING;    /* MySQL can handle all types as strings */\r\n  }\r\n  return(enum_type);\r\n}", ".ysql_st_internal_execute41": "my_ulonglong mysql_st_internal_execute41(\r\n                                         SV *sth,\r\n                                         int num_params,\r\n                                         MYSQL_RES **result,\r\n                                         MYSQL_STMT *stmt,\r\n                                         MYSQL_BIND *bind,\r\n                                         int *has_been_bound\r\n                                        )\r\n{\r\n  int i;\r\n  enum enum_field_types enum_type;\r\n  dTHX;\r\n  int execute_retval;\r\n  my_ulonglong rows=0;\r\n  D_imp_xxh(sth);\r\n\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                  \"\\t-> mysql_st_internal_execute41\\n\");\r\n\r\n  /* free result if exists */\r\n  if (*result)\r\n  {\r\n    mysql_free_result(*result);\r\n    *result= 0;\r\n  }\r\n\r\n  /*\r\n    If were performed any changes with ph variables\r\n    we have to rebind them\r\n  */\r\n\r\n  if (num_params > 0 && !(*has_been_bound))\r\n  {\r\n#if MYSQL_VERSION_ID >= 80300\r\n    if (mysql_stmt_bind_named_param(stmt,bind,num_params, NULL))\r\n#else\r\n    if (mysql_stmt_bind_param(stmt,bind))\r\n#endif\r\n      goto error;\r\n\r\n    *has_been_bound= 1;\r\n  }\r\n\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                  \"\\t\\tmysql_st_internal_execute41 calling mysql_execute with %d num_params\\n\",\r\n                  num_params);\r\n\r\n  execute_retval= mysql_stmt_execute(stmt);\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                  \"\\t\\tmysql_stmt_execute returned %d\\n\",\r\n                  execute_retval);\r\n  if (execute_retval)\r\n    goto error;\r\n\r\n  /*\r\n   This statement does not return a result set (INSERT, UPDATE...)\r\n  */\r\n  if (!(*result= mysql_stmt_result_metadata(stmt)))\r\n  {\r\n    if (mysql_stmt_errno(stmt))\r\n      goto error;\r\n\r\n    rows= mysql_stmt_affected_rows(stmt);\r\n\r\n    /* mysql_stmt_affected_rows(): -1 indicates that the query returned an error */\r\n    if (rows == (my_ulonglong)-1)\r\n      goto error;\r\n  }\r\n  /*\r\n    This statement returns a result set (SELECT...)\r\n  */\r\n  else\r\n  {\r\n    for (i = mysql_stmt_field_count(stmt) - 1; i >=0; --i) {\r\n        enum_type = mysql_to_perl_type(stmt->fields[i].type);\r\n        if (enum_type != MYSQL_TYPE_DOUBLE && enum_type != MYSQL_TYPE_LONG && enum_type != MYSQL_TYPE_LONGLONG && enum_type != MYSQL_TYPE_BIT)\r\n        {\r\n            /* mysql_stmt_store_result to update MYSQL_FIELD->max_length */\r\n            bool on = 1;\r\n            mysql_stmt_attr_set(stmt, STMT_ATTR_UPDATE_MAX_LENGTH, &on);\r\n            break;\r\n        }\r\n    }\r\n    /* Get the total rows affected and return */\r\n    if (mysql_stmt_store_result(stmt))\r\n      goto error;\r\n    else\r\n      rows= mysql_stmt_num_rows(stmt);\r\n  }\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                  \"\\t<- mysql_internal_execute_41 returning %lu rows\\n\",\r\n                  rows);\r\n  return(rows);\r\n\r\nerror:\r\n  if (*result)\r\n  {\r\n    mysql_free_result(*result);\r\n    *result= 0;\r\n  }\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                  \"     errno %d err message %s\\n\",\r\n                  mysql_stmt_errno(stmt),\r\n                  mysql_stmt_error(stmt));\r\n  do_error(sth, mysql_stmt_errno(stmt), mysql_stmt_error(stmt),\r\n           mysql_stmt_sqlstate(stmt));\r\n  mysql_stmt_reset(stmt);\r\n\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                  \"\\t<- mysql_st_internal_execute41\\n\");\r\n  return -2;\r\n\r\n}", ".ysql_st_internal_execute": "my_ulonglong mysql_st_internal_execute(\r\n                                       SV *h, /* could be sth or dbh */\r\n                                       SV *statement,\r\n                                       SV *attribs,\r\n                                       int num_params,\r\n                                       imp_sth_ph_t *params,\r\n                                       MYSQL_RES **result,\r\n                                       MYSQL *svsock,\r\n                                       int use_mysql_use_result\r\n                                      )\r\n{\r\n  dTHX;\r\n  bool bind_type_guessing= FALSE;\r\n  bool bind_comment_placeholders= TRUE;\r\n  STRLEN slen;\r\n  char *sbuf = SvPV(statement, slen);\r\n  char *salloc;\r\n  int htype;\r\n  bool async = FALSE;\r\n  my_ulonglong rows= 0;\r\n  /* thank you DBI.c for this info! */\r\n  D_imp_xxh(h);\r\n  attribs= attribs;\r\n\r\n  htype= DBIc_TYPE(imp_xxh);\r\n  /*\r\n    It is important to import imp_dbh properly according to the htype\r\n    that it is! Also, one might ask why bind_type_guessing is assigned\r\n    in each block. Well, it's because D_imp_ macros called in these\r\n    blocks make it so imp_dbh is not \"visible\" or defined outside of the\r\n    if/else (when compiled, it fails for imp_dbh not being defined).\r\n  */\r\n  /* h is a dbh */\r\n  if (htype == DBIt_DB)\r\n  {\r\n    D_imp_dbh(h);\r\n    /* if imp_dbh is not available, it causes segfault (proper) on OpenBSD */\r\n    if (imp_dbh)\r\n    {\r\n      bind_type_guessing= imp_dbh->bind_type_guessing;\r\n      bind_comment_placeholders= imp_dbh->bind_comment_placeholders;\r\n    }\r\n    async = (bool) (imp_dbh->async_query_in_flight != NULL);\r\n  }\r\n  /* h is a sth */\r\n  else\r\n  {\r\n    D_imp_sth(h);\r\n    D_imp_dbh_from_sth;\r\n    /* if imp_dbh is not available, it causes segfault (proper) on OpenBSD */\r\n    if (imp_dbh)\r\n    {\r\n      bind_type_guessing= imp_dbh->bind_type_guessing;\r\n      bind_comment_placeholders= imp_dbh->bind_comment_placeholders;\r\n    }\r\n    async = imp_sth->is_async;\r\n    if(async) {\r\n        imp_dbh->async_query_in_flight = imp_sth;\r\n    } else {\r\n        imp_dbh->async_query_in_flight = NULL;\r\n    }\r\n  }\r\n\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"mysql_st_internal_execute MYSQL_VERSION_ID %d\\n\",\r\n                  MYSQL_VERSION_ID );\r\n\r\n  salloc= parse_params(imp_xxh,\r\n                              aTHX_ svsock,\r\n                              sbuf,\r\n                              &slen,\r\n                              params,\r\n                              num_params,\r\n                              bind_type_guessing,\r\n                              bind_comment_placeholders);\r\n\r\n  if (salloc)\r\n  {\r\n    sbuf= salloc;\r\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"Binding parameters: %s\\n\", sbuf);\r\n  }\r\n\r\n  if(async) {\r\n    if((mysql_send_query(svsock, sbuf, slen)) &&\r\n       (!mysql_db_reconnect(h) ||\r\n        (mysql_send_query(svsock, sbuf, slen))))\r\n    {\r\n        rows = -2;\r\n    } else {\r\n        rows = 0;\r\n    }\r\n  } else {\r\n      if ((mysql_real_query(svsock, sbuf, slen))  &&\r\n          (!mysql_db_reconnect(h)  ||\r\n           (mysql_real_query(svsock, sbuf, slen))))\r\n      {\r\n        rows = -2;\r\n      } else {\r\n          /** Store the result from the Query */\r\n          *result= use_mysql_use_result ?\r\n            mysql_use_result(svsock) : mysql_store_result(svsock);\r\n\r\n          if (mysql_errno(svsock))\r\n            rows = -2;\r\n          else if (*result)\r\n            rows = mysql_num_rows(*result);\r\n          else {\r\n            rows = mysql_affected_rows(svsock);\r\n            /* mysql_affected_rows(): -1 indicates that the query returned an error */\r\n            if (rows == (my_ulonglong)-1)\r\n              rows = -2;\r\n          }\r\n      }\r\n  }\r\n\r\n  if (salloc)\r\n    Safefree(salloc);\r\n\r\n  if(rows == (my_ulonglong)-2) {\r\n    do_error(h, mysql_errno(svsock), mysql_error(svsock), \r\n             mysql_sqlstate(svsock));\r\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"IGNORING ERROR errno %d\\n\", mysql_errno(svsock));\r\n  }\r\n  return(rows);\r\n}", ".bd_describe": "int dbd_describe(SV* sth, imp_sth_t* imp_sth)\r\n{\r\n  dTHX;\r\n  D_imp_xxh(sth);\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t--> dbd_describe\\n\");\r\n\r\n\r\n  if (imp_sth->use_server_side_prepare)\r\n  {\r\n    int i;\r\n    int col_type;\r\n    int num_fields= DBIc_NUM_FIELDS(imp_sth);\r\n    imp_sth_fbh_t *fbh;\r\n    MYSQL_BIND *buffer;\r\n    MYSQL_FIELD *fields;\r\n\r\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tdbd_describe() num_fields %d\\n\",\r\n                    num_fields);\r\n\r\n    if (imp_sth->done_desc)\r\n      return TRUE;\r\n\r\n    if (!num_fields || !imp_sth->result)\r\n    {\r\n      /* no metadata */\r\n      do_error(sth, JW_ERR_SEQUENCE,\r\n               \"no metadata information while trying describe result set\",\r\n               NULL);\r\n      return 0;\r\n    }\r\n\r\n    /* allocate fields buffers  */\r\n    if (  !(imp_sth->fbh= alloc_fbuffer(num_fields))\r\n          || !(imp_sth->buffer= alloc_bind(num_fields)) )\r\n    {\r\n      /* Out of memory */\r\n      do_error(sth, JW_ERR_SEQUENCE,\r\n               \"Out of memory in dbd_sescribe()\",NULL);\r\n      return 0;\r\n    }\r\n\r\n    fields= mysql_fetch_fields(imp_sth->result);\r\n\r\n    for (\r\n         fbh= imp_sth->fbh, buffer= (MYSQL_BIND*)imp_sth->buffer, i= 0;\r\n         i < num_fields;\r\n         i++, fbh++, buffer++\r\n        )\r\n    {\r\n      /* get the column type */\r\n      col_type = fields ? fields[i].type : MYSQL_TYPE_STRING;\r\n\r\n      if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n      {\r\n        PerlIO_printf(DBIc_LOGPIO(imp_xxh),\"\\t\\ti %d col_type %d fbh->length %lu\\n\",\r\n                      i, col_type, fbh->length);\r\n        PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                      \"\\t\\tfields[i].length %lu fields[i].max_length %lu fields[i].type %d fields[i].charsetnr %d\\n\",\r\n                      fields[i].length, fields[i].max_length, fields[i].type,\r\n                      fields[i].charsetnr);\r\n      }\r\n      fbh->charsetnr = fields[i].charsetnr;\r\n\r\n      buffer->buffer_type= mysql_to_perl_type(col_type);\r\n      if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n        PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tmysql_to_perl_type returned %d\\n\",\r\n                      col_type);\r\n      buffer->length= &(fbh->length);\r\n      buffer->is_null= &(fbh->is_null);\r\n      buffer->error= (bool*) &(fbh->error);\r\n\r\n      if (fields[i].flags & ZEROFILL_FLAG)\r\n        buffer->buffer_type = MYSQL_TYPE_STRING;\r\n\r\n      switch (buffer->buffer_type) {\r\n      case MYSQL_TYPE_DOUBLE:\r\n        buffer->buffer_length= sizeof(fbh->ddata);\r\n        buffer->buffer= (char*) &fbh->ddata;\r\n        break;\r\n\r\n      case MYSQL_TYPE_LONG:\r\n      case MYSQL_TYPE_LONGLONG:\r\n        buffer->buffer_length= sizeof(fbh->ldata);\r\n        buffer->buffer= (char*) &fbh->ldata;\r\n        buffer->is_unsigned= (fields[i].flags & UNSIGNED_FLAG) ? 1 : 0;\r\n        break;\r\n\r\n      case MYSQL_TYPE_BIT:\r\n        buffer->buffer_length= 8;\r\n        Newz(908, fbh->data, buffer->buffer_length, char);\r\n        buffer->buffer= (char *) fbh->data;\r\n        break;\r\n\r\n      default:\r\n        buffer->buffer_length= fields[i].max_length ? fields[i].max_length : 1;\r\n        Newz(908, fbh->data, buffer->buffer_length, char);\r\n        buffer->buffer= (char *) fbh->data;\r\n      }\r\n    }\r\n\r\n    if (mysql_stmt_bind_result(imp_sth->stmt, imp_sth->buffer))\r\n    {\r\n      do_error(sth, mysql_stmt_errno(imp_sth->stmt),\r\n               mysql_stmt_error(imp_sth->stmt),\r\n               mysql_stmt_sqlstate(imp_sth->stmt));\r\n      return 0;\r\n    }\r\n  }\r\n\r\n  imp_sth->done_desc= 1;\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t<- dbd_describe\\n\");\r\n  return TRUE;\r\n}", ".ysql_db_async_result": "int mysql_db_async_result(SV* h, MYSQL_RES** resp)\r\n{\r\n  dTHX;\r\n  D_imp_xxh(h);\r\n  imp_dbh_t* dbh;\r\n  MYSQL* svsock = NULL;\r\n  MYSQL_RES* _res;\r\n  int retval = 0;\r\n  int htype;\r\n  bool async_sth = FALSE;\r\n\r\n  if(! resp) {\r\n      resp = &_res;\r\n  }\r\n  htype = DBIc_TYPE(imp_xxh);\r\n\r\n\r\n  if(htype == DBIt_DB) {\r\n      D_imp_dbh(h);\r\n      dbh = imp_dbh;\r\n  } else {\r\n      D_imp_sth(h);\r\n      D_imp_dbh_from_sth;\r\n      dbh = imp_dbh;\r\n      async_sth = imp_sth->is_async;\r\n      retval = imp_sth->row_num;\r\n  }\r\n\r\n  if(! dbh->async_query_in_flight) {\r\n      if (async_sth)\r\n          return retval;\r\n      do_error(h, 2000, \"Gathering asynchronous results for a synchronous handle\", \"HY000\");\r\n      return -1;\r\n  }\r\n  if(dbh->async_query_in_flight != imp_xxh) {\r\n      do_error(h, 2000, \"Gathering async_query_in_flight results for the wrong handle\", \"HY000\");\r\n      return -1;\r\n  }\r\n  dbh->async_query_in_flight = NULL;\r\n\r\n  svsock= dbh->pmysql;\r\n  retval= mysql_read_query_result(svsock);\r\n  if(! retval) {\r\n    *resp= mysql_store_result(svsock);\r\n\r\n    if (mysql_errno(svsock))\r\n      do_error(h, mysql_errno(svsock), mysql_error(svsock), mysql_sqlstate(svsock));\r\n    if (!*resp)\r\n      retval= mysql_affected_rows(svsock);\r\n    else {\r\n      retval= mysql_num_rows(*resp);\r\n      if(resp == &_res) {\r\n        mysql_free_result(*resp);\r\n        *resp= NULL;\r\n      }\r\n    }\r\n    if(htype == DBIt_ST) {\r\n      D_imp_sth(h);\r\n      D_imp_dbh_from_sth;\r\n\r\n      if((my_ulonglong)retval+1 != (my_ulonglong)-1) {\r\n        if(! *resp) {\r\n          imp_sth->insertid= mysql_insert_id(svsock);\r\n          if(! mysql_more_results(svsock))\r\n            DBIc_ACTIVE_off(imp_sth);\r\n        } else {\r\n          DBIc_NUM_FIELDS(imp_sth)= mysql_num_fields(imp_sth->result);\r\n          imp_sth->done_desc= 0;\r\n          imp_sth->fetch_done= 0;\r\n        }\r\n      }\r\n      imp_sth->warning_count = mysql_warning_count(imp_dbh->pmysql);\r\n    }\r\n  } else {\r\n     do_error(h, mysql_errno(svsock), mysql_error(svsock),\r\n              mysql_sqlstate(svsock));\r\n     return -1;\r\n  }\r\n return retval;\r\n}", ".ysql_st_clean_cursor": "int mysql_st_clean_cursor(SV* sth, imp_sth_t* imp_sth) {\r\n\r\n  if (DBIc_ACTIVE(imp_sth) && dbd_describe(sth, imp_sth) &&\r\n      !imp_sth->fetch_done)\r\n    mysql_stmt_free_result(imp_sth->stmt);\r\n  return 1;\r\n}", ".ree_bind": "static void free_bind(MYSQL_BIND *bind)\r\n{\r\n  if (bind)\r\n    Safefree(bind);\r\n}", ".ree_fbind": "static void free_fbind(imp_sth_phb_t *fbind)\r\n{\r\n  if (fbind)\r\n    Safefree(fbind);\r\n}", ".ree_fbuffer": "static void free_fbuffer(imp_sth_fbh_t *fbh)\r\n{\r\n  if (fbh)\r\n    Safefree(fbh);\r\n}", ".ree_param": "static void\r\nfree_param(pTHX_ imp_sth_ph_t *params, int num_params)\r\n{\r\n  if (params)\r\n  {\r\n    int i;\r\n    for (i= 0;  i < num_params;  i++)\r\n    {\r\n      imp_sth_ph_t *ph= params+i;\r\n      if (ph->value)\r\n      {\r\n        (void) SvREFCNT_dec(ph->value);\r\n        ph->value= NULL;\r\n      }\r\n    }\r\n    Safefree(params);\r\n  }\r\n}", ".ind_param": "int bind_param(imp_sth_ph_t *ph, SV *value, IV sql_type)\r\n{\r\n  dTHX;\r\n  if (ph->value)\r\n  {\r\n    if (SvMAGICAL(ph->value))\r\n      mg_get(ph->value);\r\n    (void) SvREFCNT_dec(ph->value);\r\n  }\r\n\r\n  ph->value= newSVsv(value);\r\n\r\n  if (sql_type)\r\n    ph->type = sql_type;\r\n\r\n  return TRUE;\r\n}"}, "callee": {".bd_st_prepare": "int\r\ndbd_st_prepare(\r\n  SV *sth,\r\n  imp_sth_t *imp_sth,\r\n  char *statement,\r\n  SV *attribs)\r\n{\r\n  int i;\r\n  SV **svp;\r\n  dTHX;\r\n  int prepare_retval;\r\n  MYSQL_BIND *bind, *bind_end;\r\n  imp_sth_phb_t *fbind;\r\n  D_imp_xxh(sth);\r\n  D_imp_dbh_from_sth;\r\n\r\n  if (!DBIc_ACTIVE(imp_dbh)) {\r\n    do_error(sth, JW_ERR_NOT_ACTIVE, \"Statement not active\" ,NULL);\r\n    return FALSE;\r\n  }\r\n\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                 \"\\t-> dbd_st_prepare MYSQL_VERSION_ID %d, SQL statement: %s\\n\",\r\n                  MYSQL_VERSION_ID, statement);\r\n\r\n /* Set default value of 'mysql_server_prepare' attribute for sth from dbh */\r\n  imp_sth->use_server_side_prepare= imp_dbh->use_server_side_prepare;\r\n  imp_sth->disable_fallback_for_server_prepare= imp_dbh->disable_fallback_for_server_prepare;\r\n  if (attribs)\r\n  {\r\n    svp= DBD_ATTRIB_GET_SVP(attribs, \"mysql_server_prepare\", 20);\r\n    imp_sth->use_server_side_prepare = (svp) ?\r\n      SvTRUE(*svp) : imp_dbh->use_server_side_prepare;\r\n\r\n    svp= DBD_ATTRIB_GET_SVP(attribs, \"mysql_server_prepare_disable_fallback\", 37);\r\n    imp_sth->disable_fallback_for_server_prepare = (svp) ?\r\n      SvTRUE(*svp) : imp_dbh->disable_fallback_for_server_prepare;\r\n\r\n    svp = DBD_ATTRIB_GET_SVP(attribs, \"async\", 5);\r\n\r\n    if(svp && SvTRUE(*svp)) {\r\n        imp_sth->is_async = TRUE;\r\n        if (imp_sth->disable_fallback_for_server_prepare)\r\n        {\r\n          do_error(sth, ER_UNSUPPORTED_PS,\r\n                   \"Async option not supported with server side prepare\", \"HY000\");\r\n          return 0;\r\n        }\r\n        imp_sth->use_server_side_prepare = FALSE;\r\n    }\r\n  }\r\n\r\n  imp_sth->fetch_done= 0;\r\n  imp_sth->done_desc= 0;\r\n  imp_sth->result= NULL;\r\n  imp_sth->currow= 0;\r\n\r\n  /* Set default value of 'mysql_use_result' attribute for sth from dbh */\r\n  svp= DBD_ATTRIB_GET_SVP(attribs, \"mysql_use_result\", 16);\r\n  imp_sth->use_mysql_use_result= svp ?\r\n    SvTRUE(*svp) : imp_dbh->use_mysql_use_result;\r\n\r\n  for (i= 0; i < AV_ATTRIB_LAST; i++)\r\n    imp_sth->av_attr[i]= Nullav;\r\n\r\n  /*\r\n     Clean-up previous result set(s) for sth to prevent\r\n     'Commands out of sync' error \r\n  */\r\n  mysql_st_free_result_sets(sth, imp_sth);\r\n\r\n\r\n  if (imp_sth->use_server_side_prepare)\r\n  {\r\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                    \"\\t\\tuse_server_side_prepare set\\n\");\r\n    /* do we really need this? If we do, we should return, not just continue */\r\n    if (imp_sth->stmt)\r\n      fprintf(stderr,\r\n              \"ERROR: Trying to prepare new stmt while we have \\\r\n              already not closed one \\n\");\r\n\r\n    imp_sth->stmt= mysql_stmt_init(imp_dbh->pmysql);\r\n\r\n    if (! imp_sth->stmt)\r\n    {\r\n      if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n        PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                      \"\\t\\tERROR: Unable to return MYSQL_STMT structure \\\r\n                      from mysql_stmt_init(): ERROR NO: %d ERROR MSG:%s\\n\",\r\n                      mysql_errno(imp_dbh->pmysql),\r\n                      mysql_error(imp_dbh->pmysql));\r\n    }\r\n\r\n    prepare_retval= mysql_stmt_prepare(imp_sth->stmt,\r\n                                       statement,\r\n                                       strlen(statement));\r\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n        PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                      \"\\t\\tmysql_stmt_prepare returned %d\\n\",\r\n                      prepare_retval);\r\n\r\n    if (prepare_retval)\r\n    {\r\n      if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n        PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                      \"\\t\\tmysql_stmt_prepare %d %s\\n\",\r\n                      mysql_stmt_errno(imp_sth->stmt),\r\n                      mysql_stmt_error(imp_sth->stmt));\r\n\r\n      /* For commands that are not supported by server side prepared statement\r\n         mechanism lets try to pass them through regular API */\r\n      if (!imp_sth->disable_fallback_for_server_prepare && mysql_stmt_errno(imp_sth->stmt) == ER_UNSUPPORTED_PS)\r\n      {\r\n        if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n          PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                    \"\\t\\tSETTING imp_sth->use_server_side_prepare to 0\\n\");\r\n        imp_sth->use_server_side_prepare= 0;\r\n      }\r\n      else\r\n      {\r\n        do_error(sth, mysql_stmt_errno(imp_sth->stmt),\r\n                 mysql_stmt_error(imp_sth->stmt),\r\n                mysql_sqlstate(imp_dbh->pmysql));\r\n        mysql_stmt_close(imp_sth->stmt);\r\n        imp_sth->stmt= NULL;\r\n        return FALSE;\r\n      }\r\n    }\r\n    else\r\n    {\r\n      DBIc_NUM_PARAMS(imp_sth)= mysql_stmt_param_count(imp_sth->stmt);\r\n      /* mysql_stmt_param_count */\r\n\r\n      if (DBIc_NUM_PARAMS(imp_sth) > 0)\r\n      {\r\n        /* Allocate memory for bind variables */\r\n        imp_sth->bind=            alloc_bind(DBIc_NUM_PARAMS(imp_sth));\r\n        imp_sth->fbind=           alloc_fbind(DBIc_NUM_PARAMS(imp_sth));\r\n        imp_sth->has_been_bound=  0;\r\n\r\n        /* Initialize ph variables with  NULL values */\r\n        for (i= 0,\r\n             bind=      imp_sth->bind,\r\n             fbind=     imp_sth->fbind,\r\n             bind_end=  bind+DBIc_NUM_PARAMS(imp_sth);\r\n             bind < bind_end ;\r\n             bind++, fbind++, i++ )\r\n        {\r\n          bind->buffer_type=  MYSQL_TYPE_STRING;\r\n          bind->buffer=       NULL;\r\n          bind->length=       &(fbind->length);\r\n          bind->is_null=      &(fbind->is_null);\r\n          fbind->is_null=     1;\r\n          fbind->length=      0;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /* Count the number of parameters (driver, vs server-side) */\r\n  if (imp_sth->use_server_side_prepare == 0)\r\n    DBIc_NUM_PARAMS(imp_sth) = count_params((imp_xxh_t *)imp_dbh, aTHX_ statement,\r\n                                            imp_dbh->bind_comment_placeholders);\r\n\r\n  /* Allocate memory for parameters */\r\n  imp_sth->params= alloc_param(DBIc_NUM_PARAMS(imp_sth));\r\n  DBIc_IMPSET_on(imp_sth);\r\n\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t<- dbd_st_prepare\\n\");\r\n  return 1;\r\n}", ".bd_st_destroy": "void dbd_st_destroy(SV *sth, imp_sth_t *imp_sth) {\r\n  dTHX;\r\n  D_imp_xxh(sth);\r\n\r\n#if defined (dTHR)\r\n  dTHR;\r\n#endif\r\n\r\n  int i;\r\n\r\n  imp_sth_fbh_t *fbh;\r\n  int n;\r\n\r\n  n= DBIc_NUM_PARAMS(imp_sth);\r\n  if (n)\r\n  {\r\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\tFreeing %d parameters, bind %p fbind %p\\n\",\r\n          n, imp_sth->bind, imp_sth->fbind);\r\n\r\n    free_bind(imp_sth->bind);\r\n    free_fbind(imp_sth->fbind);\r\n  }\r\n\r\n  fbh= imp_sth->fbh;\r\n  if (fbh)\r\n  {\r\n    n = DBIc_NUM_FIELDS(imp_sth);\r\n    i = 0;\r\n    while (i < n)\r\n    {\r\n      if (fbh[i].data) Safefree(fbh[i].data);\r\n      ++i;\r\n    }\r\n\r\n    free_fbuffer(fbh);\r\n    if (imp_sth->buffer)\r\n      free_bind(imp_sth->buffer);\r\n  }\r\n\r\n  if (imp_sth->stmt)\r\n  {\r\n    mysql_stmt_close(imp_sth->stmt);\r\n    imp_sth->stmt= NULL;\r\n  }\r\n\r\n  /* dbd_st_finish has already been called by .xs code if needed.\t*/\r\n\r\n  /* Free values allocated by dbd_bind_ph */\r\n  if (imp_sth->params)\r\n  {\r\n    free_param(aTHX_ imp_sth->params, DBIc_NUM_PARAMS(imp_sth));\r\n    imp_sth->params= NULL;\r\n  }\r\n\r\n  /* Free cached array attributes */\r\n  for (i= 0; i < AV_ATTRIB_LAST; i++)\r\n  {\r\n    if (imp_sth->av_attr[i])\r\n      SvREFCNT_dec(imp_sth->av_attr[i]);\r\n    imp_sth->av_attr[i]= Nullav;\r\n  }\r\n  /* let DBI know we've done it   */\r\n  DBIc_IMPSET_off(imp_sth);\r\n}", ".ysql_st_internal_execute41": "my_ulonglong mysql_st_internal_execute41(\r\n                                         SV *sth,\r\n                                         int num_params,\r\n                                         MYSQL_RES **result,\r\n                                         MYSQL_STMT *stmt,\r\n                                         MYSQL_BIND *bind,\r\n                                         int *has_been_bound\r\n                                        )\r\n{\r\n  int i;\r\n  enum enum_field_types enum_type;\r\n  dTHX;\r\n  int execute_retval;\r\n  my_ulonglong rows=0;\r\n  D_imp_xxh(sth);\r\n\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                  \"\\t-> mysql_st_internal_execute41\\n\");\r\n\r\n  /* free result if exists */\r\n  if (*result)\r\n  {\r\n    mysql_free_result(*result);\r\n    *result= 0;\r\n  }\r\n\r\n  /*\r\n    If were performed any changes with ph variables\r\n    we have to rebind them\r\n  */\r\n\r\n  if (num_params > 0 && !(*has_been_bound))\r\n  {\r\n#if MYSQL_VERSION_ID >= 80300\r\n    if (mysql_stmt_bind_named_param(stmt,bind,num_params, NULL))\r\n#else\r\n    if (mysql_stmt_bind_param(stmt,bind))\r\n#endif\r\n      goto error;\r\n\r\n    *has_been_bound= 1;\r\n  }\r\n\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                  \"\\t\\tmysql_st_internal_execute41 calling mysql_execute with %d num_params\\n\",\r\n                  num_params);\r\n\r\n  execute_retval= mysql_stmt_execute(stmt);\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                  \"\\t\\tmysql_stmt_execute returned %d\\n\",\r\n                  execute_retval);\r\n  if (execute_retval)\r\n    goto error;\r\n\r\n  /*\r\n   This statement does not return a result set (INSERT, UPDATE...)\r\n  */\r\n  if (!(*result= mysql_stmt_result_metadata(stmt)))\r\n  {\r\n    if (mysql_stmt_errno(stmt))\r\n      goto error;\r\n\r\n    rows= mysql_stmt_affected_rows(stmt);\r\n\r\n    /* mysql_stmt_affected_rows(): -1 indicates that the query returned an error */\r\n    if (rows == (my_ulonglong)-1)\r\n      goto error;\r\n  }\r\n  /*\r\n    This statement returns a result set (SELECT...)\r\n  */\r\n  else\r\n  {\r\n    for (i = mysql_stmt_field_count(stmt) - 1; i >=0; --i) {\r\n        enum_type = mysql_to_perl_type(stmt->fields[i].type);\r\n        if (enum_type != MYSQL_TYPE_DOUBLE && enum_type != MYSQL_TYPE_LONG && enum_type != MYSQL_TYPE_LONGLONG && enum_type != MYSQL_TYPE_BIT)\r\n        {\r\n            /* mysql_stmt_store_result to update MYSQL_FIELD->max_length */\r\n            bool on = 1;\r\n            mysql_stmt_attr_set(stmt, STMT_ATTR_UPDATE_MAX_LENGTH, &on);\r\n            break;\r\n        }\r\n    }\r\n    /* Get the total rows affected and return */\r\n    if (mysql_stmt_store_result(stmt))\r\n      goto error;\r\n    else\r\n      rows= mysql_stmt_num_rows(stmt);\r\n  }\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                  \"\\t<- mysql_internal_execute_41 returning %lu rows\\n\",\r\n                  rows);\r\n  return(rows);\r\n\r\nerror:\r\n  if (*result)\r\n  {\r\n    mysql_free_result(*result);\r\n    *result= 0;\r\n  }\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                  \"     errno %d err message %s\\n\",\r\n                  mysql_stmt_errno(stmt),\r\n                  mysql_stmt_error(stmt));\r\n  do_error(sth, mysql_stmt_errno(stmt), mysql_stmt_error(stmt),\r\n           mysql_stmt_sqlstate(stmt));\r\n  mysql_stmt_reset(stmt);\r\n\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                  \"\\t<- mysql_st_internal_execute41\\n\");\r\n  return -2;\r\n\r\n}", ".bd_describe": "int dbd_describe(SV* sth, imp_sth_t* imp_sth)\r\n{\r\n  dTHX;\r\n  D_imp_xxh(sth);\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t--> dbd_describe\\n\");\r\n\r\n\r\n  if (imp_sth->use_server_side_prepare)\r\n  {\r\n    int i;\r\n    int col_type;\r\n    int num_fields= DBIc_NUM_FIELDS(imp_sth);\r\n    imp_sth_fbh_t *fbh;\r\n    MYSQL_BIND *buffer;\r\n    MYSQL_FIELD *fields;\r\n\r\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tdbd_describe() num_fields %d\\n\",\r\n                    num_fields);\r\n\r\n    if (imp_sth->done_desc)\r\n      return TRUE;\r\n\r\n    if (!num_fields || !imp_sth->result)\r\n    {\r\n      /* no metadata */\r\n      do_error(sth, JW_ERR_SEQUENCE,\r\n               \"no metadata information while trying describe result set\",\r\n               NULL);\r\n      return 0;\r\n    }\r\n\r\n    /* allocate fields buffers  */\r\n    if (  !(imp_sth->fbh= alloc_fbuffer(num_fields))\r\n          || !(imp_sth->buffer= alloc_bind(num_fields)) )\r\n    {\r\n      /* Out of memory */\r\n      do_error(sth, JW_ERR_SEQUENCE,\r\n               \"Out of memory in dbd_sescribe()\",NULL);\r\n      return 0;\r\n    }\r\n\r\n    fields= mysql_fetch_fields(imp_sth->result);\r\n\r\n    for (\r\n         fbh= imp_sth->fbh, buffer= (MYSQL_BIND*)imp_sth->buffer, i= 0;\r\n         i < num_fields;\r\n         i++, fbh++, buffer++\r\n        )\r\n    {\r\n      /* get the column type */\r\n      col_type = fields ? fields[i].type : MYSQL_TYPE_STRING;\r\n\r\n      if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n      {\r\n        PerlIO_printf(DBIc_LOGPIO(imp_xxh),\"\\t\\ti %d col_type %d fbh->length %lu\\n\",\r\n                      i, col_type, fbh->length);\r\n        PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                      \"\\t\\tfields[i].length %lu fields[i].max_length %lu fields[i].type %d fields[i].charsetnr %d\\n\",\r\n                      fields[i].length, fields[i].max_length, fields[i].type,\r\n                      fields[i].charsetnr);\r\n      }\r\n      fbh->charsetnr = fields[i].charsetnr;\r\n\r\n      buffer->buffer_type= mysql_to_perl_type(col_type);\r\n      if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n        PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tmysql_to_perl_type returned %d\\n\",\r\n                      col_type);\r\n      buffer->length= &(fbh->length);\r\n      buffer->is_null= &(fbh->is_null);\r\n      buffer->error= (bool*) &(fbh->error);\r\n\r\n      if (fields[i].flags & ZEROFILL_FLAG)\r\n        buffer->buffer_type = MYSQL_TYPE_STRING;\r\n\r\n      switch (buffer->buffer_type) {\r\n      case MYSQL_TYPE_DOUBLE:\r\n        buffer->buffer_length= sizeof(fbh->ddata);\r\n        buffer->buffer= (char*) &fbh->ddata;\r\n        break;\r\n\r\n      case MYSQL_TYPE_LONG:\r\n      case MYSQL_TYPE_LONGLONG:\r\n        buffer->buffer_length= sizeof(fbh->ldata);\r\n        buffer->buffer= (char*) &fbh->ldata;\r\n        buffer->is_unsigned= (fields[i].flags & UNSIGNED_FLAG) ? 1 : 0;\r\n        break;\r\n\r\n      case MYSQL_TYPE_BIT:\r\n        buffer->buffer_length= 8;\r\n        Newz(908, fbh->data, buffer->buffer_length, char);\r\n        buffer->buffer= (char *) fbh->data;\r\n        break;\r\n\r\n      default:\r\n        buffer->buffer_length= fields[i].max_length ? fields[i].max_length : 1;\r\n        Newz(908, fbh->data, buffer->buffer_length, char);\r\n        buffer->buffer= (char *) fbh->data;\r\n      }\r\n    }\r\n\r\n    if (mysql_stmt_bind_result(imp_sth->stmt, imp_sth->buffer))\r\n    {\r\n      do_error(sth, mysql_stmt_errno(imp_sth->stmt),\r\n               mysql_stmt_error(imp_sth->stmt),\r\n               mysql_stmt_sqlstate(imp_sth->stmt));\r\n      return 0;\r\n    }\r\n  }\r\n\r\n  imp_sth->done_desc= 1;\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t<- dbd_describe\\n\");\r\n  return TRUE;\r\n}", ".bd_bind_ph": "int dbd_bind_ph(SV *sth, imp_sth_t *imp_sth, SV *param, SV *value,\r\n\t\t IV sql_type, SV *attribs, int is_inout, IV maxlen) {\r\n  dTHX;\r\n  int rc;\r\n  int param_num= SvIV(param);\r\n  int idx= param_num - 1;\r\n  char *err_msg;\r\n  D_imp_xxh(sth);\r\n\r\n  STRLEN slen;\r\n  char *buffer= NULL;\r\n  int buffer_is_null= 0;\r\n  int buffer_is_unsigned= 0;\r\n  int buffer_length= 0;\r\n  unsigned int buffer_type= 0;\r\n\r\n  D_imp_dbh_from_sth;\r\n  ASYNC_CHECK_RETURN(sth, FALSE);\r\n\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                  \"   Called: dbd_bind_ph\\n\");\r\n\r\n  attribs= attribs;\r\n  maxlen= maxlen;\r\n\r\n  if (param_num <= 0  ||  param_num > DBIc_NUM_PARAMS(imp_sth))\r\n  {\r\n    do_error(sth, JW_ERR_ILLEGAL_PARAM_NUM, \"Illegal parameter number\", NULL);\r\n    return FALSE;\r\n  }\r\n\r\n  /*\r\n     This fixes the bug whereby no warning was issued upon binding a\r\n     defined non-numeric as numeric\r\n   */\r\n  if (SvOK(value) &&\r\n      (sql_type == SQL_NUMERIC  ||\r\n       sql_type == SQL_DECIMAL  ||\r\n       sql_type == SQL_INTEGER  ||\r\n       sql_type == SQL_SMALLINT ||\r\n       sql_type == SQL_FLOAT    ||\r\n       sql_type == SQL_REAL     ||\r\n       sql_type == SQL_DOUBLE) )\r\n  {\r\n    if (! looks_like_number(value))\r\n    {\r\n      err_msg = SvPVX(sv_2mortal(newSVpvf(\r\n              \"Binding non-numeric field %d, value %s as a numeric!\",\r\n              param_num, neatsvpv(value,0))));\r\n      do_error(sth, JW_ERR_ILLEGAL_PARAM_NUM, err_msg, NULL);\r\n    }\r\n  }\r\n\r\n  if (is_inout)\r\n  {\r\n    do_error(sth, JW_ERR_NOT_IMPLEMENTED, \"Output parameters not implemented\", NULL);\r\n    return FALSE;\r\n  }\r\n\r\n  rc = bind_param(&imp_sth->params[idx], value, sql_type);\r\n\r\n  if (imp_sth->use_server_side_prepare)\r\n  {\r\n      switch(sql_type) {\r\n      case SQL_NUMERIC:\r\n      case SQL_INTEGER:\r\n      case SQL_SMALLINT:\r\n      case SQL_TINYINT:\r\n#if IVSIZE >= 8\r\n      case SQL_BIGINT:\r\n          buffer_type= MYSQL_TYPE_LONGLONG;\r\n#else\r\n          buffer_type= MYSQL_TYPE_LONG;\r\n#endif\r\n          break;\r\n      case SQL_DOUBLE:\r\n      case SQL_DECIMAL: \r\n      case SQL_FLOAT: \r\n      case SQL_REAL:\r\n          buffer_type= MYSQL_TYPE_DOUBLE;\r\n          break;\r\n      case SQL_CHAR: \r\n      case SQL_VARCHAR: \r\n      case SQL_DATE: \r\n      case SQL_TIME: \r\n      case SQL_TIMESTAMP: \r\n      case SQL_LONGVARCHAR: \r\n      case SQL_BINARY: \r\n      case SQL_VARBINARY: \r\n      case SQL_LONGVARBINARY:\r\n          buffer_type= MYSQL_TYPE_BLOB;\r\n          break;\r\n      default:\r\n          buffer_type= MYSQL_TYPE_STRING;\r\n    }\r\n    buffer_is_null = !(SvOK(imp_sth->params[idx].value) && imp_sth->params[idx].value);\r\n    if (! buffer_is_null) {\r\n      switch(buffer_type) {\r\n        case MYSQL_TYPE_LONG:\r\n        case MYSQL_TYPE_LONGLONG:\r\n          /* INT */\r\n          if (!SvIOK(imp_sth->params[idx].value) && DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tTRY TO BIND AN INT NUMBER\\n\");\r\n          buffer_length = sizeof imp_sth->fbind[idx].numeric_val.lval;\r\n          imp_sth->fbind[idx].numeric_val.lval= SvIV(imp_sth->params[idx].value);\r\n          buffer=(void*)&(imp_sth->fbind[idx].numeric_val.lval);\r\n          if (!SvIOK(imp_sth->params[idx].value))\r\n          {\r\n            if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n              PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                            \"   Conversion to INT NUMBER was not successful -> '%s' --> (unsigned) '%\"UVuf\"' / (signed) '%\"IVdf\"' <- fallback to STRING\\n\",\r\n                            SvPV_nolen(imp_sth->params[idx].value), imp_sth->fbind[idx].numeric_val.lval, imp_sth->fbind[idx].numeric_val.lval);\r\n            buffer_type = MYSQL_TYPE_STRING;\r\n            break;\r\n          }\r\n          if (SvIsUV(imp_sth->params[idx].value))\r\n            buffer_is_unsigned= 1;\r\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                          \"   SCALAR type %\"IVdf\" ->%\"IVdf\"<- IS AN INT NUMBER\\n\",\r\n                          sql_type, *(IV *)buffer);\r\n          break;\r\n\r\n        case MYSQL_TYPE_DOUBLE:\r\n          if (!SvNOK(imp_sth->params[idx].value) && DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tTRY TO BIND A FLOAT NUMBER\\n\");\r\n          buffer_length = sizeof imp_sth->fbind[idx].numeric_val.dval;\r\n          imp_sth->fbind[idx].numeric_val.dval= SvNV(imp_sth->params[idx].value);\r\n          buffer=(char*)&(imp_sth->fbind[idx].numeric_val.dval);\r\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                          \"   SCALAR type %\"IVdf\" ->%f<- IS A FLOAT NUMBER\\n\",\r\n                          sql_type, (double)(*buffer));\r\n          break;\r\n\r\n        case MYSQL_TYPE_BLOB:\r\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                          \"   SCALAR type BLOB\\n\");\r\n          break;\r\n\r\n        case MYSQL_TYPE_STRING:\r\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                          \"   SCALAR type STRING %\"IVdf\", buffertype=%d\\n\", sql_type, buffer_type);\r\n          break;\r\n\r\n        default:\r\n          croak(\"Bug in DBD::Mysql file dbdimp.c#dbd_bind_ph: do not know how to handle unknown buffer type.\");\r\n      }\r\n\r\n      if (buffer_type == MYSQL_TYPE_STRING || buffer_type == MYSQL_TYPE_BLOB)\r\n      {\r\n        buffer= SvPV(imp_sth->params[idx].value, slen);\r\n        buffer_length= slen;\r\n        if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n          PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                        \" SCALAR type %\"IVdf\" ->length %d<- IS A STRING or BLOB\\n\",\r\n                        sql_type, buffer_length);\r\n      }\r\n    }\r\n    else\r\n    {\r\n      /*case: buffer_is_null != 0*/\r\n      buffer= NULL;\r\n      if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n        PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                      \"   SCALAR NULL VALUE: buffer type is: %d\\n\", buffer_type);\r\n    }\r\n\r\n    /* Type of column was changed. Force to rebind */\r\n    if (imp_sth->bind[idx].buffer_type != buffer_type || imp_sth->bind[idx].is_unsigned != buffer_is_unsigned) {\r\n      if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n          PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                        \"   FORCE REBIND: buffer type changed from %d to %d, sql-type=%\"IVdf\"\\n\",\r\n                        (int) imp_sth->bind[idx].buffer_type, buffer_type, sql_type);\r\n      imp_sth->has_been_bound = 0;\r\n    }\r\n\r\n    /* prepare has been called */\r\n    if (imp_sth->has_been_bound)\r\n    {\r\n      imp_sth->stmt->params[idx].buffer= buffer;\r\n      imp_sth->stmt->params[idx].buffer_length= buffer_length;\r\n    }\r\n\r\n    imp_sth->bind[idx].buffer_type= buffer_type;\r\n    imp_sth->bind[idx].buffer= buffer;\r\n    imp_sth->bind[idx].buffer_length= buffer_length;\r\n    imp_sth->bind[idx].is_unsigned= buffer_is_unsigned;\r\n\r\n    imp_sth->fbind[idx].length= buffer_length;\r\n    imp_sth->fbind[idx].is_null= buffer_is_null;\r\n  }\r\n  return rc;\r\n}", ".bd_db_login": "int dbd_db_login(SV* dbh, imp_dbh_t* imp_dbh, char* dbname, char* user,\r\n\t\t char* password) {\r\n#ifdef dTHR\r\n  dTHR;\r\n#endif\r\n  dTHX; \r\n  D_imp_xxh(dbh);\r\n\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n\t\t  \"imp_dbh->connect: dsn = %s, uid = %s, pwd = %s\\n\",\r\n\t\t  dbname ? dbname : \"NULL\",\r\n\t\t  user ? user : \"NULL\",\r\n\t\t  password ? password : \"NULL\");\r\n\r\n  imp_dbh->stats.auto_reconnects_ok= 0;\r\n  imp_dbh->stats.auto_reconnects_failed= 0;\r\n  imp_dbh->bind_type_guessing= FALSE;\r\n  imp_dbh->bind_comment_placeholders= FALSE;\r\n  imp_dbh->has_transactions= TRUE;\r\n /* Safer we flip this to TRUE perl side if we detect a mod_perl env. */\r\n  imp_dbh->auto_reconnect = FALSE;\r\n\r\n  imp_dbh->enable_utf8 = FALSE;     /* initialize mysql_enable_utf8 */\r\n  imp_dbh->enable_utf8mb4 = FALSE;  /* initialize mysql_enable_utf8mb4 */\r\n\r\n  if (!my_login(aTHX_ dbh, imp_dbh))\r\n  {\r\n    if(imp_dbh->pmysql) {\r\n        do_error(dbh, mysql_errno(imp_dbh->pmysql),\r\n                mysql_error(imp_dbh->pmysql) ,mysql_sqlstate(imp_dbh->pmysql));\r\n        Safefree(imp_dbh->pmysql);\r\n\r\n    }\r\n    return FALSE;\r\n  }\r\n\r\n    /*\r\n     *  Tell DBI, that dbh->disconnect should be called for this handle\r\n     */\r\n    DBIc_ACTIVE_on(imp_dbh);\r\n\r\n    /* Tell DBI, that dbh->destroy should be called for this handle */\r\n    DBIc_on(imp_dbh, DBIcf_IMPSET);\r\n\r\n    return TRUE;\r\n}", ".bd_db_commit": "int\r\ndbd_db_commit(SV* dbh, imp_dbh_t* imp_dbh)\r\n{\r\n  if (DBIc_has(imp_dbh, DBIcf_AutoCommit))\r\n    return FALSE;\r\n\r\n  ASYNC_CHECK_RETURN(dbh, FALSE);\r\n\r\n  if (imp_dbh->has_transactions)\r\n  {\r\n    if (mysql_commit(imp_dbh->pmysql))\r\n    {\r\n      do_error(dbh, mysql_errno(imp_dbh->pmysql), mysql_error(imp_dbh->pmysql)\r\n               ,mysql_sqlstate(imp_dbh->pmysql));\r\n      return FALSE;\r\n    }\r\n  }\r\n  else\r\n    do_warn(dbh, JW_ERR_NOT_IMPLEMENTED,\r\n            \"Commit ineffective because transactions are not available\");\r\n  return TRUE;\r\n}", ".bd_db_rollback": "int\r\ndbd_db_rollback(SV* dbh, imp_dbh_t* imp_dbh) {\r\n  /* croak, if not in AutoCommit mode */\r\n  if (DBIc_has(imp_dbh, DBIcf_AutoCommit))\r\n    return FALSE;\r\n\r\n  ASYNC_CHECK_RETURN(dbh, FALSE);\r\n\r\n  if (imp_dbh->has_transactions)\r\n  {\r\n      if (mysql_rollback(imp_dbh->pmysql))\r\n      {\r\n        do_error(dbh, mysql_errno(imp_dbh->pmysql),\r\n                 mysql_error(imp_dbh->pmysql) ,mysql_sqlstate(imp_dbh->pmysql));\r\n        return FALSE;\r\n      }\r\n  }\r\n  else\r\n    do_error(dbh, JW_ERR_NOT_IMPLEMENTED,\r\n             \"Rollback ineffective because transactions are not available\" ,NULL);\r\n  return TRUE;\r\n}", ".bd_db_destroy": "void dbd_db_destroy(SV* dbh, imp_dbh_t* imp_dbh) {\r\n\r\n    /*\r\n     *  Being on the safe side never hurts ...\r\n     */\r\n  if (DBIc_ACTIVE(imp_dbh))\r\n  {\r\n    if (imp_dbh->has_transactions)\r\n    {\r\n      if (!DBIc_has(imp_dbh, DBIcf_AutoCommit))\r\n        if (mysql_rollback(imp_dbh->pmysql))\r\n            do_error(dbh, TX_ERR_ROLLBACK,\"ROLLBACK failed\" ,NULL);\r\n    }\r\n    dbd_db_disconnect(dbh, imp_dbh);\r\n  }\r\n  Safefree(imp_dbh->pmysql);\r\n\r\n  /* Tell DBI, that dbh->destroy must no longer be called */\r\n  DBIc_off(imp_dbh, DBIcf_IMPSET);\r\n}", ".bd_db_STORE_attrib": "int\r\ndbd_db_STORE_attrib(\r\n                    SV* dbh,\r\n                    imp_dbh_t* imp_dbh,\r\n                    SV* keysv,\r\n                    SV* valuesv\r\n                   )\r\n{\r\n  dTHX;\r\n  STRLEN kl;\r\n  char *key = SvPV(keysv, kl);\r\n  SV *cachesv = Nullsv;\r\n  int cacheit = FALSE;\r\n  const bool bool_value = SvTRUE(valuesv);\r\n\r\n  if (kl==10 && strEQ(key, \"AutoCommit\"))\r\n  {\r\n    if (imp_dbh->has_transactions)\r\n    {\r\n      bool oldval = DBIc_has(imp_dbh,DBIcf_AutoCommit) ? 1 : 0;\r\n\r\n      if (bool_value == oldval)\r\n        return TRUE;\r\n\r\n      /* if setting AutoCommit on ... */\r\n      if (!imp_dbh->no_autocommit_cmd)\r\n      {\r\n        if (\r\n            mysql_autocommit(imp_dbh->pmysql, bool_value)\r\n           )\r\n        {\r\n          do_error(dbh, TX_ERR_AUTOCOMMIT,\r\n                   bool_value ?\r\n                   \"Turning on AutoCommit failed\" :\r\n                   \"Turning off AutoCommit failed\"\r\n                   ,NULL);\r\n          return TRUE;  /* TRUE means we handled it - important to avoid spurious errors */\r\n        }\r\n      }\r\n      DBIc_set(imp_dbh, DBIcf_AutoCommit, bool_value);\r\n    }\r\n    else\r\n    {\r\n      /*\r\n       *  We do support neither transactions nor \"AutoCommit\".\r\n       *  But we stub it. :-)\r\n      */\r\n      if (!bool_value)\r\n      {\r\n        do_error(dbh, JW_ERR_NOT_IMPLEMENTED,\r\n                 \"Transactions not supported by database\" ,NULL);\r\n        croak(\"Transactions not supported by database\");\r\n      }\r\n    }\r\n  }\r\n  else if (kl == 16 && strEQ(key,\"mysql_use_result\"))\r\n    imp_dbh->use_mysql_use_result = bool_value;\r\n  else if (kl == 20 && strEQ(key,\"mysql_auto_reconnect\"))\r\n    imp_dbh->auto_reconnect = bool_value;\r\n  else if (kl == 20 && strEQ(key, \"mysql_server_prepare\"))\r\n    imp_dbh->use_server_side_prepare = bool_value;\r\n  else if (kl == 37 && strEQ(key, \"mysql_server_prepare_disable_fallback\"))\r\n    imp_dbh->disable_fallback_for_server_prepare = bool_value;\r\n  else if (kl == 23 && strEQ(key,\"mysql_no_autocommit_cmd\"))\r\n    imp_dbh->no_autocommit_cmd = bool_value;\r\n  else if (kl == 24 && strEQ(key,\"mysql_bind_type_guessing\"))\r\n    imp_dbh->bind_type_guessing = bool_value;\r\n  else if (kl == 31 && strEQ(key,\"mysql_bind_comment_placeholders\"))\r\n    imp_dbh->bind_type_guessing = bool_value;\r\n  else if (kl == 17 && strEQ(key, \"mysql_enable_utf8\"))\r\n    imp_dbh->enable_utf8 = bool_value;\r\n  else if (kl == 20 && strEQ(key, \"mysql_enable_utf8mb4\"))\r\n    imp_dbh->enable_utf8mb4 = bool_value;\r\n  else\r\n    return FALSE;\t\t\t\t/* Unknown key */\r\n\r\n  if (cacheit) /* cache value for later DBI 'quick' fetch? */\r\n    (void)hv_store((HV*)SvRV(dbh), key, kl, cachesv, 0);\r\n  return TRUE;\r\n}", ".ysql_st_free_result_sets": "int mysql_st_free_result_sets (SV * sth, imp_sth_t * imp_sth)\r\n{\r\n  dTHX;\r\n  D_imp_dbh_from_sth;\r\n  D_imp_xxh(sth);\r\n  int next_result_rc= -1;\r\n\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t>- dbd_st_free_result_sets\\n\");\r\n\r\n  do\r\n  {\r\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t<- dbd_st_free_result_sets RC %d\\n\", next_result_rc);\r\n\r\n    if (next_result_rc == 0)\r\n    {\r\n      if (!(imp_sth->result = mysql_use_result(imp_dbh->pmysql)))\r\n      {\r\n        /* Check for possible error */\r\n        if (mysql_field_count(imp_dbh->pmysql))\r\n        {\r\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n          PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t<- dbd_st_free_result_sets ERROR: %s\\n\",\r\n                                  mysql_error(imp_dbh->pmysql));\r\n\r\n          do_error(sth, mysql_errno(imp_dbh->pmysql), mysql_error(imp_dbh->pmysql),\r\n                   mysql_sqlstate(imp_dbh->pmysql));\r\n          return 0;\r\n        }\r\n      }\r\n    }\r\n    if (imp_sth->result)\r\n    {\r\n      mysql_free_result(imp_sth->result);\r\n      imp_sth->result=NULL;\r\n    }\r\n  } while ((next_result_rc=mysql_next_result(imp_dbh->pmysql))==0);\r\n\r\n  if (next_result_rc > 0)\r\n  {\r\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t<- dbd_st_free_result_sets: Error while processing multi-result set: %s\\n\",\r\n                    mysql_error(imp_dbh->pmysql));\r\n\r\n    do_error(sth, mysql_errno(imp_dbh->pmysql), mysql_error(imp_dbh->pmysql),\r\n             mysql_sqlstate(imp_dbh->pmysql));\r\n  }\r\n\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t<- dbd_st_free_result_sets\\n\");\r\n\r\n  return 1;\r\n}", ".bd_st_more_results": "int dbd_st_more_results(SV* sth, imp_sth_t* imp_sth)\r\n{\r\n  dTHX;\r\n  D_imp_dbh_from_sth;\r\n  D_imp_xxh(sth);\r\n\r\n  int use_mysql_use_result=imp_sth->use_mysql_use_result;\r\n  int next_result_return_code, i;\r\n  MYSQL* svsock= imp_dbh->pmysql;\r\n\r\n  if (!SvROK(sth) || SvTYPE(SvRV(sth)) != SVt_PVHV)\r\n    croak(\"Expected hash array\");\r\n\r\n  if (!mysql_more_results(svsock))\r\n  {\r\n    /* No more pending result set(s)*/\r\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n\t\t    \"\\n      <- dbs_st_more_results no more results\\n\");\r\n    return 0;\r\n  }\r\n\r\n  if (imp_sth->use_server_side_prepare)\r\n  {\r\n    do_warn(sth, JW_ERR_NOT_IMPLEMENTED,\r\n            \"Processing of multiple result set is not possible with server side prepare\");\r\n    return 0;\r\n  }\r\n\r\n  /*\r\n   *  Free cached array attributes\r\n   */\r\n  for (i= 0; i < AV_ATTRIB_LAST;  i++)\r\n  {\r\n    if (imp_sth->av_attr[i])\r\n      SvREFCNT_dec(imp_sth->av_attr[i]);\r\n\r\n    imp_sth->av_attr[i]= Nullav;\r\n  }\r\n\r\n  /* Release previous MySQL result*/\r\n  if (imp_sth->result)\r\n  {\r\n    mysql_free_result(imp_sth->result);\r\n    imp_sth->result= NULL;\r\n  }\r\n\r\n  if (DBIc_ACTIVE(imp_sth))\r\n    DBIc_ACTIVE_off(imp_sth);\r\n\r\n  next_result_return_code= mysql_next_result(svsock);\r\n\r\n  imp_sth->warning_count = mysql_warning_count(imp_dbh->pmysql);\r\n\r\n  /*\r\n    mysql_next_result returns\r\n      0 if there are more results\r\n     -1 if there are no more results\r\n     >0 if there was an error\r\n   */\r\n  if (next_result_return_code > 0)\r\n  {\r\n    do_error(sth, mysql_errno(svsock), mysql_error(svsock),\r\n             mysql_sqlstate(svsock));\r\n\r\n    return 0;\r\n  }\r\n  else if(next_result_return_code == -1)                                                                                                                  \r\n  {                                                                                                                                                       \r\n    return 0;                                                                                                                                             \r\n  }  \r\n  else\r\n  {\r\n    /* Store the result from the Query */\r\n    imp_sth->result = use_mysql_use_result ?\r\n     mysql_use_result(svsock) : mysql_store_result(svsock);\r\n\r\n    if (mysql_errno(svsock))\r\n    {\r\n      do_error(sth, mysql_errno(svsock), mysql_error(svsock), \r\n               mysql_sqlstate(svsock));\r\n      return 0;\r\n    }\r\n\r\n    imp_sth->row_num= mysql_affected_rows(imp_dbh->pmysql);\r\n\r\n    if (imp_sth->result == NULL)\r\n    {\r\n      /* No \"real\" rowset*/\r\n      DBIc_NUM_FIELDS(imp_sth)= 0; /* for DBI <= 1.53 */\r\n      DBIS->set_attr_k(sth, sv_2mortal(newSVpvn(\"NUM_OF_FIELDS\",13)), 0,\r\n\t\t\t               sv_2mortal(newSViv(0)));\r\n      return 1;\r\n    }\r\n    else\r\n    {\r\n      /* We have a new rowset */\r\n      imp_sth->currow=0;\r\n\r\n\r\n      /* delete cached handle attributes */\r\n      /* XXX should be driven by a list to ease maintenance */\r\n      (void)hv_delete((HV*)SvRV(sth), \"NAME\", 4, G_DISCARD);\r\n      (void)hv_delete((HV*)SvRV(sth), \"NULLABLE\", 8, G_DISCARD);\r\n      (void)hv_delete((HV*)SvRV(sth), \"NUM_OF_FIELDS\", 13, G_DISCARD);\r\n      (void)hv_delete((HV*)SvRV(sth), \"PRECISION\", 9, G_DISCARD);\r\n      (void)hv_delete((HV*)SvRV(sth), \"SCALE\", 5, G_DISCARD);\r\n      (void)hv_delete((HV*)SvRV(sth), \"TYPE\", 4, G_DISCARD);\r\n      (void)hv_delete((HV*)SvRV(sth), \"mysql_insertid\", 14, G_DISCARD);\r\n      (void)hv_delete((HV*)SvRV(sth), \"mysql_is_auto_increment\", 23, G_DISCARD);\r\n      (void)hv_delete((HV*)SvRV(sth), \"mysql_is_blob\", 13, G_DISCARD);\r\n      (void)hv_delete((HV*)SvRV(sth), \"mysql_is_key\", 12, G_DISCARD);\r\n      (void)hv_delete((HV*)SvRV(sth), \"mysql_is_num\", 12, G_DISCARD);\r\n      (void)hv_delete((HV*)SvRV(sth), \"mysql_is_pri_key\", 16, G_DISCARD);\r\n      (void)hv_delete((HV*)SvRV(sth), \"mysql_length\", 12, G_DISCARD);\r\n      (void)hv_delete((HV*)SvRV(sth), \"mysql_max_length\", 16, G_DISCARD);\r\n      (void)hv_delete((HV*)SvRV(sth), \"mysql_table\", 11, G_DISCARD);\r\n      (void)hv_delete((HV*)SvRV(sth), \"mysql_type\", 10, G_DISCARD);\r\n      (void)hv_delete((HV*)SvRV(sth), \"mysql_type_name\", 15, G_DISCARD);\r\n      (void)hv_delete((HV*)SvRV(sth), \"mysql_warning_count\", 20, G_DISCARD);\r\n\r\n      /* Adjust NUM_OF_FIELDS - which also adjusts the row buffer size */\r\n      DBIc_NUM_FIELDS(imp_sth)= 0; /* for DBI <= 1.53 */\r\n      DBIc_DBISTATE(imp_sth)->set_attr_k(sth, sv_2mortal(newSVpvn(\"NUM_OF_FIELDS\",13)), 0,\r\n          sv_2mortal(newSViv(mysql_num_fields(imp_sth->result)))\r\n      );\r\n\r\n      DBIc_ACTIVE_on(imp_sth);\r\n\r\n      imp_sth->done_desc = 0;\r\n    }\r\n    imp_dbh->pmysql->net.last_errno= 0;\r\n    return 1;\r\n  }\r\n}", ".ysql_st_internal_execute": "my_ulonglong mysql_st_internal_execute(\r\n                                       SV *h, /* could be sth or dbh */\r\n                                       SV *statement,\r\n                                       SV *attribs,\r\n                                       int num_params,\r\n                                       imp_sth_ph_t *params,\r\n                                       MYSQL_RES **result,\r\n                                       MYSQL *svsock,\r\n                                       int use_mysql_use_result\r\n                                      )\r\n{\r\n  dTHX;\r\n  bool bind_type_guessing= FALSE;\r\n  bool bind_comment_placeholders= TRUE;\r\n  STRLEN slen;\r\n  char *sbuf = SvPV(statement, slen);\r\n  char *salloc;\r\n  int htype;\r\n  bool async = FALSE;\r\n  my_ulonglong rows= 0;\r\n  /* thank you DBI.c for this info! */\r\n  D_imp_xxh(h);\r\n  attribs= attribs;\r\n\r\n  htype= DBIc_TYPE(imp_xxh);\r\n  /*\r\n    It is important to import imp_dbh properly according to the htype\r\n    that it is! Also, one might ask why bind_type_guessing is assigned\r\n    in each block. Well, it's because D_imp_ macros called in these\r\n    blocks make it so imp_dbh is not \"visible\" or defined outside of the\r\n    if/else (when compiled, it fails for imp_dbh not being defined).\r\n  */\r\n  /* h is a dbh */\r\n  if (htype == DBIt_DB)\r\n  {\r\n    D_imp_dbh(h);\r\n    /* if imp_dbh is not available, it causes segfault (proper) on OpenBSD */\r\n    if (imp_dbh)\r\n    {\r\n      bind_type_guessing= imp_dbh->bind_type_guessing;\r\n      bind_comment_placeholders= imp_dbh->bind_comment_placeholders;\r\n    }\r\n    async = (bool) (imp_dbh->async_query_in_flight != NULL);\r\n  }\r\n  /* h is a sth */\r\n  else\r\n  {\r\n    D_imp_sth(h);\r\n    D_imp_dbh_from_sth;\r\n    /* if imp_dbh is not available, it causes segfault (proper) on OpenBSD */\r\n    if (imp_dbh)\r\n    {\r\n      bind_type_guessing= imp_dbh->bind_type_guessing;\r\n      bind_comment_placeholders= imp_dbh->bind_comment_placeholders;\r\n    }\r\n    async = imp_sth->is_async;\r\n    if(async) {\r\n        imp_dbh->async_query_in_flight = imp_sth;\r\n    } else {\r\n        imp_dbh->async_query_in_flight = NULL;\r\n    }\r\n  }\r\n\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"mysql_st_internal_execute MYSQL_VERSION_ID %d\\n\",\r\n                  MYSQL_VERSION_ID );\r\n\r\n  salloc= parse_params(imp_xxh,\r\n                              aTHX_ svsock,\r\n                              sbuf,\r\n                              &slen,\r\n                              params,\r\n                              num_params,\r\n                              bind_type_guessing,\r\n                              bind_comment_placeholders);\r\n\r\n  if (salloc)\r\n  {\r\n    sbuf= salloc;\r\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"Binding parameters: %s\\n\", sbuf);\r\n  }\r\n\r\n  if(async) {\r\n    if((mysql_send_query(svsock, sbuf, slen)) &&\r\n       (!mysql_db_reconnect(h) ||\r\n        (mysql_send_query(svsock, sbuf, slen))))\r\n    {\r\n        rows = -2;\r\n    } else {\r\n        rows = 0;\r\n    }\r\n  } else {\r\n      if ((mysql_real_query(svsock, sbuf, slen))  &&\r\n          (!mysql_db_reconnect(h)  ||\r\n           (mysql_real_query(svsock, sbuf, slen))))\r\n      {\r\n        rows = -2;\r\n      } else {\r\n          /** Store the result from the Query */\r\n          *result= use_mysql_use_result ?\r\n            mysql_use_result(svsock) : mysql_store_result(svsock);\r\n\r\n          if (mysql_errno(svsock))\r\n            rows = -2;\r\n          else if (*result)\r\n            rows = mysql_num_rows(*result);\r\n          else {\r\n            rows = mysql_affected_rows(svsock);\r\n            /* mysql_affected_rows(): -1 indicates that the query returned an error */\r\n            if (rows == (my_ulonglong)-1)\r\n              rows = -2;\r\n          }\r\n      }\r\n  }\r\n\r\n  if (salloc)\r\n    Safefree(salloc);\r\n\r\n  if(rows == (my_ulonglong)-2) {\r\n    do_error(h, mysql_errno(svsock), mysql_error(svsock), \r\n             mysql_sqlstate(svsock));\r\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"IGNORING ERROR errno %d\\n\", mysql_errno(svsock));\r\n  }\r\n  return(rows);\r\n}", ".bd_st_execute": "int dbd_st_execute(SV* sth, imp_sth_t* imp_sth)\r\n{\r\n  dTHX;\r\n  char actual_row_num[64];\r\n  int i;\r\n  SV **statement;\r\n  D_imp_dbh_from_sth;\r\n  D_imp_xxh(sth);\r\n#if defined (dTHR)\r\n  dTHR;\r\n#endif\r\n  int use_server_side_prepare = imp_sth->use_server_side_prepare;\r\n  int disable_fallback_for_server_prepare = imp_sth->disable_fallback_for_server_prepare;\r\n\r\n  ASYNC_CHECK_RETURN(sth, -2);\r\n\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n      \" -> dbd_st_execute for %p\\n\", sth);\r\n\r\n  if (!SvROK(sth)  ||  SvTYPE(SvRV(sth)) != SVt_PVHV)\r\n    croak(\"Expected hash array\");\r\n\r\n  /* Free cached array attributes */\r\n  for (i= 0;  i < AV_ATTRIB_LAST;  i++)\r\n  {\r\n    if (imp_sth->av_attr[i])\r\n      SvREFCNT_dec(imp_sth->av_attr[i]);\r\n\r\n    imp_sth->av_attr[i]= Nullav;\r\n  }\r\n\r\n  statement= hv_fetch((HV*) SvRV(sth), \"Statement\", 9, FALSE);\r\n\r\n  /* \r\n     Clean-up previous result set(s) for sth to prevent\r\n     'Commands out of sync' error \r\n  */\r\n  mysql_st_free_result_sets (sth, imp_sth);\r\n\r\n  if (use_server_side_prepare)\r\n  {\r\n    if (imp_sth->use_mysql_use_result)\r\n    {\r\n      if (disable_fallback_for_server_prepare)\r\n      {\r\n        do_error(sth, ER_UNSUPPORTED_PS,\r\n                 \"\\\"mysql_use_result\\\" not supported with server side prepare\",\r\n                 \"HY000\");\r\n        return 0;\r\n      }\r\n      use_server_side_prepare = 0;\r\n    }\r\n\r\n    if (use_server_side_prepare)\r\n    {\r\n      imp_sth->row_num= mysql_st_internal_execute41(\r\n                                                    sth,\r\n                                                    DBIc_NUM_PARAMS(imp_sth),\r\n                                                    &imp_sth->result,\r\n                                                    imp_sth->stmt,\r\n                                                    imp_sth->bind,\r\n                                                    &imp_sth->has_been_bound\r\n                                                   );\r\n      if (imp_sth->row_num == (my_ulonglong)-2) /* -2 means error */\r\n      {\r\n        SV *err = DBIc_ERR(imp_xxh);\r\n        if (!disable_fallback_for_server_prepare && SvIV(err) == ER_UNSUPPORTED_PS)\r\n        {\r\n          use_server_side_prepare = 0;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  if (!use_server_side_prepare)\r\n  {\r\n    imp_sth->row_num= mysql_st_internal_execute(\r\n                                                sth,\r\n                                                *statement,\r\n                                                NULL,\r\n                                                DBIc_NUM_PARAMS(imp_sth),\r\n                                                imp_sth->params,\r\n                                                &imp_sth->result,\r\n                                                imp_dbh->pmysql,\r\n                                                imp_sth->use_mysql_use_result\r\n                                               );\r\n    if(imp_dbh->async_query_in_flight) {\r\n        DBIc_ACTIVE_on(imp_sth);\r\n        return 0;\r\n    }\r\n  }\r\n\r\n  if (imp_sth->row_num+1 != (my_ulonglong)-1)\r\n  {\r\n    if (!imp_sth->result)\r\n    {\r\n      imp_sth->insertid= mysql_insert_id(imp_dbh->pmysql);\r\n      if (mysql_more_results(imp_dbh->pmysql))\r\n        DBIc_ACTIVE_on(imp_sth);\r\n    }\r\n    else\r\n    {\r\n      /** Store the result in the current statement handle */\r\n      DBIc_NUM_FIELDS(imp_sth)= mysql_num_fields(imp_sth->result);\r\n      DBIc_ACTIVE_on(imp_sth);\r\n      if (!use_server_side_prepare)\r\n        imp_sth->done_desc= 0;\r\n      imp_sth->fetch_done= 0;\r\n    }\r\n  }\r\n\r\n  imp_sth->warning_count = mysql_warning_count(imp_dbh->pmysql);\r\n\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n  {\r\n    /* \r\n      PerlIO_printf doesn't always handle imp_sth->row_num %llu \r\n      consistently!!\r\n    */\r\n    sprintf(actual_row_num, \"%lu\", imp_sth->row_num);\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                  \" <- dbd_st_execute returning imp_sth->row_num %s\\n\",\r\n                  actual_row_num);\r\n  }\r\n\r\n  return (int)imp_sth->row_num;\r\n}", ".bd_st_finish": "int dbd_st_finish(SV* sth, imp_sth_t* imp_sth) {\r\n  dTHX;\r\n  D_imp_xxh(sth);\r\n\r\n#if defined (dTHR)\r\n  dTHR;\r\n#endif\r\n\r\n  D_imp_dbh_from_sth;\r\n  if(imp_dbh->async_query_in_flight) {\r\n    mysql_db_async_result(sth, &imp_sth->result);\r\n  }\r\n\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n  {\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\n--> dbd_st_finish\\n\");\r\n  }\r\n\r\n  if (imp_sth->use_server_side_prepare)\r\n  {\r\n    if (imp_sth && imp_sth->stmt)\r\n    {\r\n      if (!mysql_st_clean_cursor(sth, imp_sth))\r\n      {\r\n        do_error(sth, JW_ERR_SEQUENCE,\r\n                 \"Error happened while tried to clean up stmt\",NULL);\r\n        return 0;\r\n      }\r\n    }\r\n  }\r\n\r\n  /*\r\n    Cancel further fetches from this cursor.\r\n    We don't close the cursor till DESTROY.\r\n    The application may re execute it.\r\n  */\r\n  if (imp_sth && DBIc_ACTIVE(imp_sth))\r\n  {\r\n    /*\r\n      Clean-up previous result set(s) for sth to prevent\r\n      'Commands out of sync' error\r\n    */\r\n    mysql_st_free_result_sets(sth, imp_sth);\r\n  }\r\n  DBIc_ACTIVE_off(imp_sth);\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n  {\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\n<-- dbd_st_finish\\n\");\r\n  }\r\n  return 1;\r\n}", ".ysql_db_reconnect": "int mysql_db_reconnect(SV* h)\r\n{\r\n  dTHX;\r\n  D_imp_xxh(h);\r\n  imp_dbh_t* imp_dbh;\r\n  MYSQL save_socket;\r\n\r\n  if (DBIc_DBISTATE(imp_xxh)->debug >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"reconnecting\\n\");\r\n\r\n  if (DBIc_TYPE(imp_xxh) == DBIt_ST)\r\n  {\r\n    imp_dbh = (imp_dbh_t*) DBIc_PARENT_COM(imp_xxh);\r\n    h = DBIc_PARENT_H(imp_xxh);\r\n  }\r\n  else\r\n    imp_dbh= (imp_dbh_t*) imp_xxh;\r\n\r\n  /* reconnect a closed connection, used in do() for implicit reconnect */\r\n  if (!DBIc_has(imp_dbh, DBIcf_ACTIVE) && DBIc_has(imp_dbh, DBIcf_AutoCommit)) {\r\n    if (my_login(aTHX_ h, imp_dbh)) {\r\n      DBIc_ACTIVE_on(imp_dbh);\r\n      DBIc_set(imp_dbh, DBIcf_AutoCommit, TRUE);\r\n      return TRUE;\r\n    }\r\n    return FALSE;\r\n  }\r\n\r\n  if (mysql_errno(imp_dbh->pmysql) != CR_SERVER_GONE_ERROR &&\r\n#ifdef ER_CLIENT_INTERACTION_TIMEOUT /* Added in 8.0.24 */\r\n          mysql_errno(imp_dbh->pmysql) != ER_CLIENT_INTERACTION_TIMEOUT &&\r\n#endif\r\n          mysql_errno(imp_dbh->pmysql) != CR_SERVER_LOST) {\r\n    /* Other error */\r\n    if (DBIc_DBISTATE(imp_xxh)->debug >= 2)\r\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"Can't reconnect on unexpected error %d\\n\",\r\n          mysql_errno(imp_dbh->pmysql));\r\n    return FALSE;\r\n  }\r\n\r\n  if (!DBIc_has(imp_dbh, DBIcf_AutoCommit) || !imp_dbh->auto_reconnect)\r\n  {\r\n    /* We never reconnect if AutoCommit is turned off.\r\n     * Otherwise we might get an inconsistent transaction\r\n     * state.\r\n     */\r\n    if (DBIc_DBISTATE(imp_xxh)->debug >= 2)\r\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"Can't reconnect as AutoCommit is turned off\\n\");\r\n    return FALSE;\r\n  }\r\n\r\n  /* my_login will blow away imp_dbh->mysql so we save a copy of\r\n   * imp_dbh->mysql and put it back where it belongs if the reconnect\r\n   * fail.  Think server is down & reconnect fails but the application eval{}s\r\n   * the execute, so next time $dbh->quote() gets called, instant SIGSEGV!\r\n   */\r\n  save_socket= *(imp_dbh->pmysql);\r\n  memcpy (&save_socket, imp_dbh->pmysql,sizeof(save_socket));\r\n  memset (imp_dbh->pmysql,0,sizeof(*(imp_dbh->pmysql)));\r\n\r\n  /* we should disconnect the db handle before reconnecting, this will\r\n   * prevent my_login from thinking it's adopting an active child which\r\n   * would prevent the handle from actually reconnecting\r\n   */\r\n  if (!dbd_db_disconnect(h, imp_dbh) || !my_login(aTHX_ h, imp_dbh))\r\n  {\r\n    do_error(h, mysql_errno(imp_dbh->pmysql), mysql_error(imp_dbh->pmysql),\r\n             mysql_sqlstate(imp_dbh->pmysql));\r\n    memcpy (imp_dbh->pmysql, &save_socket, sizeof(save_socket));\r\n    ++imp_dbh->stats.auto_reconnects_failed;\r\n    return FALSE;\r\n  }\r\n\r\n  /*\r\n   *  Tell DBI, that dbh->disconnect should be called for this handle\r\n   */\r\n  DBIc_ACTIVE_on(imp_dbh);\r\n\r\n  ++imp_dbh->stats.auto_reconnects_ok;\r\n  return TRUE;\r\n}", ".ysql_db_async_result": "int mysql_db_async_result(SV* h, MYSQL_RES** resp)\r\n{\r\n  dTHX;\r\n  D_imp_xxh(h);\r\n  imp_dbh_t* dbh;\r\n  MYSQL* svsock = NULL;\r\n  MYSQL_RES* _res;\r\n  int retval = 0;\r\n  int htype;\r\n  bool async_sth = FALSE;\r\n\r\n  if(! resp) {\r\n      resp = &_res;\r\n  }\r\n  htype = DBIc_TYPE(imp_xxh);\r\n\r\n\r\n  if(htype == DBIt_DB) {\r\n      D_imp_dbh(h);\r\n      dbh = imp_dbh;\r\n  } else {\r\n      D_imp_sth(h);\r\n      D_imp_dbh_from_sth;\r\n      dbh = imp_dbh;\r\n      async_sth = imp_sth->is_async;\r\n      retval = imp_sth->row_num;\r\n  }\r\n\r\n  if(! dbh->async_query_in_flight) {\r\n      if (async_sth)\r\n          return retval;\r\n      do_error(h, 2000, \"Gathering asynchronous results for a synchronous handle\", \"HY000\");\r\n      return -1;\r\n  }\r\n  if(dbh->async_query_in_flight != imp_xxh) {\r\n      do_error(h, 2000, \"Gathering async_query_in_flight results for the wrong handle\", \"HY000\");\r\n      return -1;\r\n  }\r\n  dbh->async_query_in_flight = NULL;\r\n\r\n  svsock= dbh->pmysql;\r\n  retval= mysql_read_query_result(svsock);\r\n  if(! retval) {\r\n    *resp= mysql_store_result(svsock);\r\n\r\n    if (mysql_errno(svsock))\r\n      do_error(h, mysql_errno(svsock), mysql_error(svsock), mysql_sqlstate(svsock));\r\n    if (!*resp)\r\n      retval= mysql_affected_rows(svsock);\r\n    else {\r\n      retval= mysql_num_rows(*resp);\r\n      if(resp == &_res) {\r\n        mysql_free_result(*resp);\r\n        *resp= NULL;\r\n      }\r\n    }\r\n    if(htype == DBIt_ST) {\r\n      D_imp_sth(h);\r\n      D_imp_dbh_from_sth;\r\n\r\n      if((my_ulonglong)retval+1 != (my_ulonglong)-1) {\r\n        if(! *resp) {\r\n          imp_sth->insertid= mysql_insert_id(svsock);\r\n          if(! mysql_more_results(svsock))\r\n            DBIc_ACTIVE_off(imp_sth);\r\n        } else {\r\n          DBIc_NUM_FIELDS(imp_sth)= mysql_num_fields(imp_sth->result);\r\n          imp_sth->done_desc= 0;\r\n          imp_sth->fetch_done= 0;\r\n        }\r\n      }\r\n      imp_sth->warning_count = mysql_warning_count(imp_dbh->pmysql);\r\n    }\r\n  } else {\r\n     do_error(h, mysql_errno(svsock), mysql_error(svsock),\r\n              mysql_sqlstate(svsock));\r\n     return -1;\r\n  }\r\n return retval;\r\n}", ".ysql_db_async_ready": "int mysql_db_async_ready(SV* h)\r\n{\r\n  dTHX;\r\n  D_imp_xxh(h);\r\n  imp_dbh_t* dbh;\r\n  int htype;\r\n  bool async_sth = FALSE;\r\n  bool async_active = FALSE;\r\n\r\n  htype = DBIc_TYPE(imp_xxh);\r\n  \r\n  if(htype == DBIt_DB) {\r\n      D_imp_dbh(h);\r\n      dbh = imp_dbh;\r\n  } else {\r\n      D_imp_sth(h);\r\n      D_imp_dbh_from_sth;\r\n      dbh = imp_dbh;\r\n      async_sth = imp_sth->is_async;\r\n      async_active = !!DBIc_ACTIVE(imp_sth);\r\n  }\r\n\r\n  if(dbh->async_query_in_flight) {\r\n      if(dbh->async_query_in_flight == imp_xxh && dbh->pmysql->net.fd != -1) {\r\n          int retval = mysql_socket_ready(dbh->pmysql->net.fd);\r\n          if(retval < 0) {\r\n              do_error(h, -retval, strerror(-retval), \"HY000\");\r\n          }\r\n          return retval;\r\n      } else {\r\n          do_error(h, 2000, \"Calling mysql_async_ready on the wrong handle\", \"HY000\");\r\n          return -1;\r\n      }\r\n  } else {\r\n      if (async_sth) {\r\n          if (async_active)\r\n              return 1;\r\n          do_error(h, 2000, \"Asynchronous handle was not executed yet\", \"HY000\");\r\n          return -1;\r\n      }\r\n      do_error(h, 2000, \"Handle is not in asynchronous mode\", \"HY000\");\r\n      return -1;\r\n  }\r\n}", ".ysql_st_clean_cursor": "int mysql_st_clean_cursor(SV* sth, imp_sth_t* imp_sth) {\r\n\r\n  if (DBIc_ACTIVE(imp_sth) && dbd_describe(sth, imp_sth) &&\r\n      !imp_sth->fetch_done)\r\n    mysql_stmt_free_result(imp_sth->stmt);\r\n  return 1;\r\n}"}, "function_name": "parse_number"}
{"function_id": null, "caller": {".andle_packet": "static int handle_packet(unsigned char *data, int data_len) {\r\n\tstruct mt_mactelnet_hdr pkthdr;\r\n\r\n\t/* Minimal size checks (pings are not supported here) */\r\n\tif (data_len < MT_HEADER_LEN){\r\n\t\treturn -1;\r\n\t}\r\n\tparse_packet(data, &pkthdr);\r\n\r\n\t/* We only care about packets with correct sessionkey */\r\n\tif (pkthdr.seskey != sessionkey) {\r\n\t\treturn -1;\r\n\t}\r\n\r\n\t/* Handle data packets */\r\n\tif (pkthdr.ptype == MT_PTYPE_DATA) {\r\n\t\tstruct mt_packet odata;\r\n\t\tstruct mt_mactelnet_control_hdr cpkt;\r\n\t\tint success = 0;\r\n\r\n\t\t/* Always transmit ACKNOWLEDGE packets in response to DATA packets */\r\n\t\tinit_packet(&odata, MT_PTYPE_ACK, srcmac, dstmac, sessionkey, pkthdr.counter + (data_len - MT_HEADER_LEN));\r\n\t\tsend_udp(&odata, 0);\r\n\r\n\t\t/* Accept first packet, and all packets greater than incounter, and if counter has\r\n\t\twrapped around. */\r\n\t\tif (pkthdr.counter > incounter || (incounter - pkthdr.counter) > 65535) {\r\n\t\t\tincounter = pkthdr.counter;\r\n\t\t} else {\r\n\t\t\t/* Ignore double or old packets */\r\n\t\t\treturn -1;\r\n\t\t}\r\n\r\n\t\t/* Parse controlpacket data */\r\n\t\tsuccess = parse_control_packet(data + MT_HEADER_LEN, data_len - MT_HEADER_LEN, &cpkt);\r\n\r\n\t\twhile (success) {\r\n\r\n\t\t\t/* If we receive pass_salt, transmit auth data back */\r\n\t\t\tif (cpkt.cptype == MT_CPTYPE_PASSSALT) {\r\n\t\t\t\t/* check validity, server sends exactly 16 bytes */\r\n\t\t\t\tif (cpkt.length != 16) {\r\n\t\t\t\t\tfprintf(stderr, _(\"Invalid salt length: %d (instead of 16) received from server %s\\n\"), cpkt.length, ether_ntoa((struct ether_addr *)dstmac));\r\n\t\t\t\t}\r\n\t\t\t\tmemcpy(pass_salt, cpkt.data, 16);\r\n\t\t\t\tsend_auth(username, password);\r\n\t\t\t}\r\n\r\n\t\t\t/* If the (remaining) data did not have a control-packet magic byte sequence,\r\n\t\t\t   the data is raw terminal data to be outputted to the terminal. */\r\n\t\t\telse if (cpkt.cptype == MT_CPTYPE_PLAINDATA) {\r\n\t\t\t\tfwrite((const void *)cpkt.data, 1, cpkt.length, stdout);\r\n\t\t\t}\r\n\r\n\t\t\t/* END_AUTH means that the user/password negotiation is done, and after this point\r\n\t\t\t   terminal data may arrive, so we set up the terminal to raw mode. */\r\n\t\t\telse if (cpkt.cptype == MT_CPTYPE_END_AUTH) {\r\n\r\n\t\t\t\t/* we have entered \"terminal mode\" */\r\n\t\t\t\tterminal_mode = 1;\r\n\r\n\t\t\t\tif (is_a_tty) {\r\n\t\t\t\t\t/* stop input buffering at all levels. Give full control of terminal to RouterOS */\r\n\t\t\t\t\traw_term();\r\n\r\n\t\t\t\t\tsetvbuf(stdin,  (char*)NULL, _IONBF, 0);\r\n\r\n\t\t\t\t\t/* Add resize signal handler */\r\n\t\t\t\t\tsignal(SIGWINCH, sig_winch);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t/* Parse next controlpacket */\r\n\t\t\tsuccess = parse_control_packet(NULL, 0, &cpkt);\r\n\t\t}\r\n\t}\r\n\telse if (pkthdr.ptype == MT_PTYPE_ACK) {\r\n\t\t/* Handled elsewhere */\r\n\t}\r\n\r\n\t/* The server wants to terminate the connection, we have to oblige */\r\n\telse if (pkthdr.ptype == MT_PTYPE_END) {\r\n\t\tstruct mt_packet odata;\r\n\r\n\t\t/* Acknowledge the disconnection by sending a END packet in return */\r\n\t\tinit_packet(&odata, MT_PTYPE_END, srcmac, dstmac, pkthdr.seskey, 0);\r\n\t\tsend_udp(&odata, 0);\r\n\r\n\t\tif (!quiet_mode) {\r\n\t\t\tfprintf(stderr, _(\"Connection closed.\\n\"));\r\n\t\t}\r\n\r\n\t\t/* exit */\r\n\t\trunning = 0;\r\n\t} else {\r\n\t\tfprintf(stderr, _(\"Unhandeled packet type: %d received from server %s\\n\"), pkthdr.ptype, ether_ntoa((struct ether_addr *)dstmac));\r\n\t\treturn -1;\r\n\t}\r\n\r\n\treturn pkthdr.ptype;\r\n}", ".nit_packet": "int init_packet(struct mt_packet *packet, enum mt_ptype ptype, unsigned char *srcmac, unsigned char *dstmac, unsigned short sessionkey, unsigned int counter) {\r\n\tunsigned char *data = packet->data;\r\n\r\n\t/* Packet version */\r\n\tdata[0] = 1;\r\n\r\n\t/* Packet type */\r\n\tdata[1] = ptype;\r\n\r\n\t/* src ethernet address */\r\n\tmemcpy(data + 2, srcmac, ETH_ALEN);\r\n\r\n\t/* dst ethernet address */\r\n\tmemcpy(data + 8, dstmac, ETH_ALEN);\r\n\r\n\t/* Session key */\r\n\tsessionkey = htons(sessionkey);\r\n\tmemcpy(data + (mt_direction_fromserver ? 16 : 14), &sessionkey, sizeof(sessionkey));\r\n\r\n\t/* Client type: Mac Telnet */\r\n\tmemcpy(data + (mt_direction_fromserver ? 14 : 16), &mt_mactelnet_clienttype, sizeof(mt_mactelnet_clienttype));\r\n\r\n\t/* Received/sent data counter */\r\n\tcounter = htonl(counter);\r\n\tmemcpy(data + 18, &counter, sizeof(counter));\r\n\r\n\t/* 22 bytes header */\r\n\tpacket->size = 22;\r\n\treturn 22;\r\n}", ".dd_control_packet": "int add_control_packet(struct mt_packet *packet, enum mt_cptype cptype, void *cpdata, unsigned short data_len) {\r\n\tunsigned char *data = packet->data + packet->size;\r\n\tunsigned int act_size = data_len + (cptype == MT_CPTYPE_PLAINDATA ? 0 : MT_CPHEADER_LEN);\r\n\r\n\t/* Something is really wrong. Packets should never become over 1500 bytes,\r\n       perform an Integer-Overflow safe check */\r\n\tif (act_size > MT_PACKET_LEN - packet->size) {\r\n\t\tfprintf(stderr, _(\"add_control_packet: ERROR, too large packet. Exceeds %d bytes\\n\"), MT_PACKET_LEN);\r\n\t\treturn -1;\r\n\t\t//exit(1);\r\n\t}\r\n\r\n\t/* PLAINDATA isn't really a controlpacket, but we handle it here, since\r\n\t   parseControlPacket also parses raw data as PLAINDATA */\r\n\tif (cptype == MT_CPTYPE_PLAINDATA) {\r\n\t\tmemcpy(data, cpdata, data_len);\r\n\t\tpacket->size += data_len;\r\n\t\treturn data_len;\r\n\t}\r\n\r\n\t/* Control Packet Magic id */\r\n\tmemcpy(data, mt_mactelnet_cpmagic, sizeof(mt_mactelnet_cpmagic));\r\n\r\n\t/* Control packet type */\r\n\tdata[4] = cptype;\r\n\r\n\t/* Data length */\r\n#if BYTE_ORDER == LITTLE_ENDIAN\r\n\t{\r\n\t\tunsigned int templen;\r\n\t\ttemplen = htonl(data_len);\r\n\t\tmemcpy(data + 5, &templen, sizeof(templen));\r\n\t}\r\n#else\r\n\tmemcpy(data + 5, &data_len, sizeof(data_len));\r\n#endif\r\n\r\n\t/* Insert data */\r\n\tif (data_len > 0) {\r\n\t\tmemcpy(data + MT_CPHEADER_LEN, cpdata, data_len);\r\n\t}\r\n\r\n\tpacket->size += act_size;\r\n\t/* Control packet header length + data length */\r\n\treturn act_size;\r\n}", ".end_udp": "static int send_udp(struct mt_packet *packet, int retransmit) {\r\n\tint sent_bytes;\r\n\r\n\t/* Clear keepalive counter */\r\n\tkeepalive_counter = 0;\r\n\r\n\tif (!use_raw_socket) {\r\n\t\t/* Init SendTo struct */\r\n\t\tstruct sockaddr_in socket_address;\r\n\t\tsocket_address.sin_family = AF_INET;\r\n\t\tsocket_address.sin_port = htons(MT_MACTELNET_PORT);\r\n\t\tsocket_address.sin_addr.s_addr = htonl(INADDR_BROADCAST);\r\n\r\n\t\tsent_bytes = sendto(send_socket, packet->data, packet->size, 0, (struct sockaddr*)&socket_address, sizeof(socket_address));\r\n\t} else {\r\n\t\tsent_bytes = net_send_udp(sockfd, active_interface, srcmac, dstmac, &sourceip,  sourceport, &destip, MT_MACTELNET_PORT, packet->data, packet->size);\r\n\t}\r\n\r\n\t/* \r\n\t * Retransmit packet if no data is received within\r\n\t * retransmit_intervals milliseconds.\r\n\t */\r\n\tif (retransmit) {\r\n\t\tint i;\r\n\r\n\t\tfor (i = 0; i < MAX_RETRANSMIT_INTERVALS; ++i) {\r\n\t\t\tfd_set read_fds;\r\n\t\t\tint reads;\r\n\t\t\tstruct timeval timeout;\r\n\t\t\tint interval = retransmit_intervals[i] * 1000;\r\n\r\n\t\t\t/* Init select */\r\n\t\t\tFD_ZERO(&read_fds);\r\n\t\t\tFD_SET(insockfd, &read_fds);\r\n\t\t\ttimeout.tv_sec = 0;\r\n\t\t\ttimeout.tv_usec = interval;\r\n\r\n\t\t\t/* Wait for data or timeout */\r\n\t\t\treads = select(insockfd + 1, &read_fds, NULL, NULL, &timeout);\r\n\t\t\tif (reads && FD_ISSET(insockfd, &read_fds)) {\r\n\t\t\t\tunsigned char buff[MT_PACKET_LEN];\r\n\t\t\t\tint result;\r\n\r\n\t\t\t\tbzero(buff, sizeof(buff));\r\n\t\t\t\tresult = recvfrom(insockfd, buff, sizeof(buff), 0, 0, 0);\r\n\r\n\t\t\t\t/* Handle incoming packets, waiting for an ack */\r\n\t\t\t\tif (result > 0 && handle_packet(buff, result) == MT_PTYPE_ACK) {\r\n\t\t\t\t\treturn sent_bytes;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t/* Retransmit */\r\n\t\t\tsend_udp(packet, 0);\r\n\t\t}\r\n\r\n\t\tif (is_a_tty && terminal_mode) {\r\n\t\t\treset_term();\r\n\t\t}\r\n\r\n\t\tfprintf(stderr, _(\"\\nConnection timed out\\n\"));\r\n\t\texit(1);\r\n\t}\r\n\treturn sent_bytes;\r\n}", ".arse_packet": "void parse_packet(unsigned char *data, struct mt_mactelnet_hdr *pkthdr) {\r\n\t/* Packet version */\r\n\tpkthdr->ver = data[0];\r\n\r\n\t/* Packet type */\r\n\tpkthdr->ptype = data[1];\r\n\r\n\t/* src ethernet addr */\r\n\tmemcpy(pkthdr->srcaddr, data + 2, ETH_ALEN);\r\n\r\n\t/* dst ethernet addr */\r\n\tmemcpy(pkthdr->dstaddr, data + 8, ETH_ALEN);\r\n\r\n\t/* Session key */\r\n\tmemcpy(&(pkthdr->seskey), data + (mt_direction_fromserver ? 14 : 16), sizeof(pkthdr->seskey));\r\n\tpkthdr->seskey = ntohs(pkthdr->seskey);\r\n\r\n\t/* server type */\r\n\tmemcpy(&(pkthdr->clienttype), data + (mt_direction_fromserver ? 16 : 14), 2);\r\n\r\n\t/* Received/sent data counter */\r\n\tmemcpy(&(pkthdr->counter), data + 18, sizeof(pkthdr->counter));\r\n\tpkthdr->counter = ntohl(pkthdr->counter);\r\n\r\n\t/* Set pointer to actual data */\r\n\tpkthdr->data = data + 22;\r\n}", ".arse_control_packet": "int parse_control_packet(unsigned char *packetdata, unsigned short data_len, struct mt_mactelnet_control_hdr *cpkthdr) {\r\n\tstatic unsigned char *int_data;\r\n\tstatic unsigned int int_data_len;\r\n\tstatic unsigned int int_pos;\r\n\tunsigned char *data;\r\n\r\n\t/* Store info so we can call this function once with data,\r\n\t   and then several times for each control packets. Letting this function\r\n\t   control the data position. */\r\n\tif (packetdata != NULL) {\r\n\t\tif (data_len == 0) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\r\n\t\tint_data = packetdata;\r\n\t\tint_data_len = data_len;\r\n\t\tint_pos = 0;\r\n\t}\r\n\r\n\t/* No more data to parse? */\r\n\tif (int_pos >= int_data_len) {\r\n\t\treturn 0;\r\n\t}\r\n\r\n\t/* Set current position in data buffer */\r\n\tdata = int_data + int_pos;\r\n\r\n\t/* Check for valid minimum packet length & magic header */\r\n\tif ((int_data_len - int_pos) >= MT_CPHEADER_LEN && memcmp(data, &mt_mactelnet_cpmagic, 4) == 0) {\r\n\r\n\t\t/* Control packet type */\r\n\t\tcpkthdr->cptype = data[4];\r\n\r\n\t\t/* Control packet data length */\r\n\t\tmemcpy(&(cpkthdr->length), data + 5, sizeof(cpkthdr->length));\r\n\t\tcpkthdr->length = ntohl(cpkthdr->length);\r\n\r\n\t\t/* We want no buffer overflows */\r\n\t\tif (cpkthdr->length > int_data_len - MT_CPHEADER_LEN - int_pos) {\r\n\t\t\tcpkthdr->length = int_data_len - MT_CPHEADER_LEN - int_pos;\r\n\t\t}\r\n\r\n\t\t/* Set pointer to actual data */\r\n\t\tcpkthdr->data = data + MT_CPHEADER_LEN;\r\n\r\n\t\t/* Remember old position, for next call */\r\n\t\tint_pos += cpkthdr->length + MT_CPHEADER_LEN;\r\n\r\n\t\t/* Read data successfully */\r\n\t\treturn 1;\r\n\r\n\t} else {\r\n\t\t/* Mark data as raw terminal data */\r\n\t\tcpkthdr->cptype = MT_CPTYPE_PLAINDATA;\r\n\t\tcpkthdr->length = int_data_len - int_pos;\r\n\t\tcpkthdr->data = data;\r\n\r\n\t\t/* Consume the whole rest of the packet */\r\n\t\tint_pos = int_data_len;\r\n\r\n\t\t/* Read data successfully */\r\n\t\treturn 1;\r\n\t}\r\n}", ".end_auth": "static void send_auth(char *username, char *password) {\r\n\tstruct mt_packet data;\r\n\tunsigned short width = 0;\r\n\tunsigned short height = 0;\r\n\tchar *terminal = getenv(\"TERM\");\r\n\tchar md5data[100];\r\n\tunsigned char md5sum[17];\r\n\tint plen, act_pass_len;\r\n\tmd5_state_t state;\r\n\r\n#if defined(__linux__) && defined(_POSIX_MEMLOCK_RANGE)\r\n\tmlock(md5data, sizeof(md5data));\r\n\tmlock(md5sum, sizeof(md5data));\r\n#endif\r\n\r\n\t/* calculate the actual password's length */\r\n\tact_pass_len = strnlen(password, 82);\r\n\r\n\t/* Concat string of 0 + password + pass_salt */\r\n\tmd5data[0] = 0;\r\n\tmemcpy(md5data + 1, password, act_pass_len);\r\n\t/* in case that password is long, calculate only using the used-up parts */\r\n\tmemcpy(md5data + 1 + act_pass_len, pass_salt, 16);\r\n\r\n\t/* Generate md5 sum of md5data with a leading 0 */\r\n\tmd5_init(&state);\r\n\tmd5_append(&state, (const md5_byte_t *)md5data, 1 + act_pass_len + 16);\r\n\tmd5_finish(&state, (md5_byte_t *)md5sum + 1);\r\n\tmd5sum[0] = 0;\r\n\r\n\t/* Send combined packet to server */\r\n\tinit_packet(&data, MT_PTYPE_DATA, srcmac, dstmac, sessionkey, outcounter);\r\n\tplen = add_control_packet(&data, MT_CPTYPE_PASSWORD, md5sum, 17);\r\n\tplen += add_control_packet(&data, MT_CPTYPE_USERNAME, username, strlen(username));\r\n\tplen += add_control_packet(&data, MT_CPTYPE_TERM_TYPE, terminal, strlen(terminal));\r\n\t\r\n\tif (is_a_tty && get_terminal_size(&width, &height) != -1) {\r\n\t\twidth = htole16(width);\r\n\t\theight = htole16(height);\r\n\t\tplen += add_control_packet(&data, MT_CPTYPE_TERM_WIDTH, &width, 2);\r\n\t\tplen += add_control_packet(&data, MT_CPTYPE_TERM_HEIGHT, &height, 2);\r\n\t}\r\n\r\n\toutcounter += plen;\r\n\r\n\t/* TODO: handle result */\r\n\tsend_udp(&data, 1);\r\n}", ".ig_winch": "static void sig_winch(int sig) {\r\n\tunsigned short width,height;\r\n\tstruct mt_packet data;\r\n\tint plen;\r\n\r\n\t/* terminal height/width has changed, inform server */\r\n\tif (get_terminal_size(&width, &height) != -1) {\r\n\t\tinit_packet(&data, MT_PTYPE_DATA, srcmac, dstmac, sessionkey, outcounter);\r\n\t\twidth = htole16(width);\r\n\t\theight = htole16(height);\r\n\t\tplen = add_control_packet(&data, MT_CPTYPE_TERM_WIDTH, &width, 2);\r\n\t\tplen += add_control_packet(&data, MT_CPTYPE_TERM_HEIGHT, &height, 2);\r\n\t\toutcounter += plen;\r\n\r\n\t\tsend_udp(&data, 1);\r\n\t}\r\n\r\n\t/* reinstate signal handler */\r\n\tsignal(SIGWINCH, sig_winch);\r\n}", ".rint_version": "static void print_version() {\r\n\tfprintf(stderr, PROGRAM_NAME \" \" PROGRAM_VERSION \"\\n\");\r\n}", ".rop_privileges": "void drop_privileges(char *username) {\r\n\tstruct passwd *user = (struct passwd *) getpwnam(username);\r\n\tif (user == NULL) {\r\n\t\tfprintf(stderr, _(\"Failed dropping privileges. The user %s is not a valid username on local system.\\n\"), username);\r\n\t\texit(1);\r\n\t}\r\n\tif (getuid() == 0) {\r\n\t\t/* process is running as root, drop privileges */\r\n\t\tif (setgid(user->pw_gid) != 0) {\r\n\t\t\tfprintf(stderr, _(\"setgid: Error dropping group privileges\\n\"));\r\n\t\t\texit(1);\r\n\t\t}\r\n\t\tif (setuid(user->pw_uid) != 0) {\r\n\t\t\tfprintf(stderr, _(\"setuid: Error dropping user privileges\\n\"));\r\n\t\t\texit(1);\r\n\t\t}\r\n\t\t/* Verify if the privileges were developed. */\r\n\t\tif (setuid(0) != -1) {\r\n\t\t\tfprintf(stderr, _(\"Failed to drop privileges\\n\"));\r\n\t\t\texit(1);\r\n\t\t}\r\n\t}\r\n}", ".uery_mndp_or_mac": "int query_mndp_or_mac(char *address, unsigned char *dstmac, int verbose) {\r\n\tchar *p = address;\r\n\tint colons = 0;\r\n\tint dashs = 0;\r\n\r\n\twhile (*p++) {\r\n\t\tif (*p == ':') {\r\n\t\t\tcolons++;\r\n\t\t}\r\n\t\telse if (*p == '-') {\r\n\t\t\tdashs++;\r\n\t\t}\r\n\t}\r\n\r\n\t/* \r\n\t* Windows users often enter macs with dash instead\r\n\t* of colon.\r\n\t*/\r\n\tif (colons == 0 && dashs == 5) {\r\n\t\tp = address;\r\n\t\twhile (*p++) {\r\n\t\t\tif (*p == '-') {\r\n\t\t\t\t*p = ':';\r\n\t\t\t}\r\n\t\t}\r\n\t\tcolons = dashs;\r\n\t}\r\n\r\n\tif (colons != 5) {\r\n\t\t/* \r\n\t\t * Not a valid mac-address.\r\n\t\t * Search for Router by identity name, using MNDP\r\n\t\t */\r\n\t\tif (verbose) {\r\n\t\t\tfprintf(stderr, _(\"Searching for '%s'...\"), address);\r\n\t\t}\r\n\t\tif (!query_mndp(address, dstmac)) {\r\n\t\t\tif (verbose) {\r\n\t\t\t\tfprintf(stderr, _(\"not found\\n\"));\r\n\t\t\t}\r\n\t\t\treturn 0;\r\n\t\t}\r\n\r\n\t\t/* Router found, display mac and continue */\r\n\t\tif (verbose) {\r\n\t\t\tfprintf(stderr, _(\"found\\n\"));\r\n\t\t}\r\n\t} else {\r\n\t\t/* Convert mac address string to ether_addr struct */\r\n#if defined(__APPLE__)\r\n\t\tstruct ether_addr* dstmac_buf = ether_aton(address);\r\n\t\tmemcpy(dstmac, dstmac_buf, sizeof(struct ether_addr));\r\n#else\r\n\t\tether_aton_r(address, (struct ether_addr *)dstmac);\r\n#endif\r\n\t}\r\n\r\n\treturn 1;\r\n}", ".ind_interface": "static int find_interface() {\r\n\tfd_set read_fds;\r\n\tstruct mt_packet data;\r\n\tstruct sockaddr_in myip;\r\n\tunsigned char emptymac[ETH_ALEN];\r\n\tint testsocket;\r\n\tstruct timeval timeout;\r\n\tint optval = 1;\r\n\tstruct net_interface *interface;\r\n\r\n\t/* TODO: reread interfaces on HUP */\r\n\t//bzero(&interfaces, sizeof(struct net_interface) * MAX_INTERFACES);\r\n\r\n\tbzero(emptymac, ETH_ALEN);\r\n\r\n\tif (net_get_interfaces(&interfaces) <= 0) {\r\n\t\tfprintf(stderr, _(\"Error: No suitable devices found\\n\"));\r\n\t\texit(1);\r\n\t}\r\n\r\n\tDL_FOREACH(interfaces, interface) {\r\n\t\t/* Skip loopback interfaces */\r\n\t\tif (memcmp(\"lo\", interface->name, 2) == 0) {\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\t/* Initialize receiving socket on the device chosen */\r\n\t\tmyip.sin_family = AF_INET;\r\n\t\tmemcpy((void *)&myip.sin_addr, interface->ipv4_addr, IPV4_ALEN);\r\n\t\tmyip.sin_port = htons(sourceport);\r\n\r\n\t\t/* Initialize socket and bind to udp port */\r\n\t\tif ((testsocket = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)) < 0) {\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\tsetsockopt(testsocket, SOL_SOCKET, SO_BROADCAST, &optval, sizeof(optval));\r\n\t\tsetsockopt(testsocket, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval));\r\n\r\n\t\tif (bind(testsocket, (struct sockaddr *)&myip, sizeof(struct sockaddr_in)) == -1) {\r\n\t\t\tclose(testsocket);\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\t/* Ensure that we have mac-address for this interface  */\r\n\t\tif (!interface->has_mac) {\r\n\t\t\tclose(testsocket);\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\t/* Set the global socket handle and source mac address for send_udp() */\r\n\t\tsend_socket = testsocket;\r\n\t\tmemcpy(srcmac, interface->mac_addr, ETH_ALEN);\r\n\t\tactive_interface = interface;\r\n\r\n\t\t/* Send a SESSIONSTART message with the current device */\r\n\t\tinit_packet(&data, MT_PTYPE_SESSIONSTART, srcmac, dstmac, sessionkey, 0);\r\n\t\tsend_udp(&data, 0);\r\n\r\n\t\ttimeout.tv_sec = connect_timeout;\r\n\t\ttimeout.tv_usec = 0;\r\n\r\n\t\tFD_ZERO(&read_fds);\r\n\t\tFD_SET(insockfd, &read_fds);\r\n\t\tselect(insockfd + 1, &read_fds, NULL, NULL, &timeout);\r\n\t\tif (FD_ISSET(insockfd, &read_fds)) {\r\n\t\t\t/* We got a response, this is the correct device to use */\r\n\t\t\treturn 1;\r\n\t\t}\r\n\r\n\t\tclose(testsocket);\r\n\t}\r\n\treturn 0;\r\n}"}, "callee": {".ain": "int main (int argc, char **argv) {\r\n\tint result;\r\n\tstruct mt_packet data;\r\n\tstruct sockaddr_in si_me;\r\n\tstruct autologin_profile *login_profile;\r\n\tstruct net_interface *interface, *tmp;\r\n\tunsigned char buff[MT_PACKET_LEN];\r\n\tunsigned char print_help = 0, have_username = 0, have_password = 0;\r\n\tunsigned char drop_priv = 0;\r\n\tint c;\r\n\tint optval = 1;\r\n\r\n\tstrncpy(autologin_path, AUTOLOGIN_PATH, sizeof(autologin_path));\r\n\r\n\tsetlocale(LC_ALL, \"\");\r\n\tbindtextdomain(\"mactelnet\",\"/usr/share/locale\");\r\n\ttextdomain(\"mactelnet\");\r\n\r\n\twhile (1) {\r\n\t\tc = getopt(argc, argv, \"lnqt:u:p:U:vh?BAa:\");\r\n\r\n\t\tif (c == -1) {\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\tswitch (c) {\r\n\r\n\t\t\tcase 'n':\r\n\t\t\t\tuse_raw_socket = 1;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 'u':\r\n\t\t\t\t/* Save username */\r\n\t\t\t\tstrncpy(username, optarg, sizeof(username) - 1);\r\n\t\t\t\tusername[sizeof(username) - 1] = '\\0';\r\n\t\t\t\thave_username = 1;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 'p':\r\n\t\t\t\t/* Save password */\r\n#if defined(__linux__) && defined(_POSIX_MEMLOCK_RANGE)\r\n\t\t\t\tmlock(password, sizeof(password));\r\n#endif\r\n\t\t\t\tstrncpy(password, optarg, sizeof(password) - 1);\r\n\t\t\t\tpassword[sizeof(password) - 1] = '\\0';\r\n\t\t\t\thave_password = 1;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 'U':\r\n\t\t\t\t/* Save nonpriv_username */\r\n\t\t\t\tstrncpy(nonpriv_username, optarg, sizeof(nonpriv_username) - 1);\r\n\t\t\t\tnonpriv_username[sizeof(nonpriv_username) - 1] = '\\0';\r\n\t\t\t\tdrop_priv = 1;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 't':\r\n\t\t\t\tconnect_timeout = atoi(optarg);\r\n\t\t\t\tmndp_timeout = connect_timeout;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 'v':\r\n\t\t\t\tprint_version();\r\n\t\t\t\texit(0);\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 'q':\r\n\t\t\t\tquiet_mode = 1;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 'l':\r\n\t\t\t\trun_mndp = 1;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 'B':\r\n\t\t\t\tbatch_mode = 1;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 'A':\r\n\t\t\t\tno_autologin = 1;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 'a':\r\n\t\t\t\tstrncpy(autologin_path, optarg, sizeof(autologin_path) - 1);\r\n\t\t\t\tautologin_path[sizeof(autologin_path) - 1] = '\\0';\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 'h':\r\n\t\t\tcase '?':\r\n\t\t\t\tprint_help = 1;\r\n\t\t\t\tbreak;\r\n\r\n\t\t}\r\n\t}\r\n\tif (run_mndp) {\r\n\t\treturn mndp(mndp_timeout, batch_mode);\r\n\t}\r\n\tif (argc - optind < 1 || print_help) {\r\n\t\tprint_version();\r\n\t\tfprintf(stderr, _(\"Usage: %s <MAC|identity> [-h] [-n] [-a <path>] [-A] [-t <timeout>] [-u <user>] [-p <password>] [-U <user>] | -l [-B] [-t <timeout>]\\n\"), argv[0]);\r\n\r\n\t\tif (print_help) {\r\n\t\t\tfprintf(stderr, _(\"\\nParameters:\\n\"\r\n\t\t\t\"  MAC            MAC-Address of the RouterOS/mactelnetd device. Use mndp to\\n\"\r\n\t\t\t\"                 discover it.\\n\"\r\n\t\t\t\"  identity       The identity/name of your destination device. Uses\\n\"\r\n\t\t\t\"                 MNDP protocol to find it.\\n\"\r\n\t\t\t\"  -l             List/Search for routers nearby (MNDP). You may use -t to set timeout.\\n\"\r\n\t\t\t\"  -B             Batch mode. Use computer readable output (CSV), for use with -l.\\n\"\r\n\t\t\t\"  -n             Do not use broadcast packets. Less insecure but requires\\n\"\r\n\t\t\t\"                 root privileges.\\n\"\r\n\t\t\t\"  -a <path>      Use specified path instead of the default: \" AUTOLOGIN_PATH \" for autologin config file.\\n\"\r\n\t\t\t\"  -A             Disable autologin feature.\\n\"\r\n\t\t\t\"  -t <timeout>   Amount of seconds to wait for a response on each interface.\\n\"\r\n\t\t\t\"  -u <user>      Specify username on command line.\\n\"\r\n\t\t\t\"  -p <password>  Specify password on command line.\\n\"\r\n\t\t\t\"  -U <user>      Drop privileges to this user. Used in conjunction with -n\\n\"\r\n\t\t\t\"                 for security.\\n\"\r\n\t\t\t\"  -q             Quiet mode.\\n\"\r\n\t\t\t\"  -h             This help.\\n\"\r\n\t\t\t\"\\n\"));\r\n\t\t}\r\n\t\treturn 1;\r\n\t}\r\n\r\n\tis_a_tty = isatty(fileno(stdout)) && isatty(fileno(stdin));\r\n\tif (!is_a_tty) {\r\n\t\tquiet_mode = 1;\r\n\t}\r\n\r\n\tif (!no_autologin) {\r\n\t\tautologin_readfile(autologin_path);\r\n\t\tlogin_profile = autologin_find_profile(argv[optind]);\r\n\r\n\t\tif (!quiet_mode && login_profile != NULL && (login_profile->hasUsername || login_profile->hasPassword)) {\r\n\t\t\tfprintf(stderr, _(\"Using autologin credentials from %s\\n\"), autologin_path);\r\n\t\t}\r\n\t\tif (!have_username) {\r\n\t\t\tif (login_profile != NULL && login_profile->hasUsername) {\r\n\t\t\t\thave_username = 1;\r\n\t\t\t\tstrncpy(username, login_profile->username, sizeof(username) - 1);\r\n\t\t\t\tusername[sizeof(username) - 1] = '\\0';\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (!have_password) {\r\n\t\t\tif (login_profile != NULL && login_profile->hasPassword) {\r\n\t\t\t\thave_password = 1;\r\n\t\t\t\tstrncpy(password, login_profile->password, sizeof(password) - 1);\r\n\t\t\t\tpassword[sizeof(password) - 1] = '\\0';\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/* Seed randomizer */\r\n\tsrand(time(NULL));\r\n\r\n\tif (use_raw_socket) {\r\n\t\tif (geteuid() != 0) {\r\n\t\t\tfprintf(stderr, _(\"You need to have root privileges to use the -n parameter.\\n\"));\r\n\t\t\treturn 1;\r\n\t\t}\r\n\r\n\t\tsockfd = net_init_raw_socket();\r\n\r\n\t\tif (drop_priv) {\r\n\t\t\tdrop_privileges(nonpriv_username);\r\n\t\t}\r\n\t} else if (drop_priv) {\r\n\t\tfprintf(stderr, _(\"The -U option must be used in conjunction with the -n parameter.\\n\"));\r\n\t\treturn 1;\r\n\t}\r\n\r\n\t/* Receive regular udp packets with this socket */\r\n\tinsockfd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);\r\n\tif (insockfd < 0) {\r\n\t\tperror(\"insockfd\");\r\n\t\treturn 1;\r\n\t}\r\n\r\n\tif (!use_raw_socket) {\r\n\t\tif (setsockopt(insockfd, SOL_SOCKET, SO_BROADCAST, &optval, sizeof (optval))==-1) {\r\n\t\t\tperror(\"SO_BROADCAST\");\r\n\t\t\treturn 1;\r\n\t\t}\r\n\t}\r\n\r\n\t/* Need to use, to be able to autodetect which interface to use */\r\n\tsetsockopt(insockfd, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof (optval));\r\n\r\n\t/* Get mac-address from string, or check for hostname via mndp */\r\n\tif (!query_mndp_or_mac(argv[optind], dstmac, !quiet_mode)) {\r\n\t\t/* No valid mac address found, abort */\r\n\t\treturn 1;\r\n\t}\r\n\r\n\tif (!have_username) {\r\n\t\tif (!quiet_mode) {\r\n\t\t\tprintf(_(\"Login: \"));\r\n\t\t\tfflush(stdout);\r\n\t\t}\r\n\t\tscanf(\"%127s\", username);\r\n\t}\r\n\r\n\tif (!have_password) {\r\n\t\tchar *tmp;\r\n\t\ttmp = getpass(quiet_mode ? \"\" : _(\"Password: \"));\r\n#if defined(__linux__) && defined(_POSIX_MEMLOCK_RANGE)\r\n\t\tmlock(password, sizeof(password));\r\n#endif\r\n\t\tstrncpy(password, tmp, sizeof(password) - 1);\r\n\t\tpassword[sizeof(password) - 1] = '\\0';\r\n\t\t/* security */\r\n\t\tmemset(tmp, 0, strlen(tmp));\r\n#ifdef __linux__\r\n\t\tfree(tmp);\r\n#endif\r\n\t}\r\n\r\n\r\n\t/* Set random source port */\r\n\tsourceport = 1024 + (rand() % 1024);\r\n\r\n\t/* Set up global info about the connection */\r\n\tinet_pton(AF_INET, (char *)\"255.255.255.255\", &destip);\r\n\tmemcpy(&sourceip, &(si_me.sin_addr), IPV4_ALEN);\r\n\r\n\t/* Session key */\r\n\tsessionkey = rand() % 65535;\r\n\r\n\t/* stop output buffering */\r\n\tsetvbuf(stdout, (char*)NULL, _IONBF, 0);\r\n\r\n\tif (!quiet_mode) {\r\n\t\tprintf(_(\"Connecting to %s...\"), ether_ntoa((struct ether_addr *)dstmac));\r\n\t}\r\n\r\n\t/* Initialize receiving socket on the device chosen */\r\n\tmemset((char *) &si_me, 0, sizeof(si_me));\r\n\tsi_me.sin_family = AF_INET;\r\n\tsi_me.sin_port = htons(sourceport);\r\n\r\n\t/* Bind to udp port */\r\n\tif (bind(insockfd, (struct sockaddr *)&si_me, sizeof(si_me)) == -1) {\r\n\t\tfprintf(stderr, _(\"Error binding to %s:%d, %s\\n\"), inet_ntoa(si_me.sin_addr), sourceport, strerror(errno));\r\n\t\treturn 1;\r\n\t}\r\n\r\n\tif (!find_interface() || (result = recvfrom(insockfd, buff, sizeof(buff), 0, 0, 0)) < 1) {\r\n\t\tfprintf(stderr, _(\"Connection failed.\\n\"));\r\n\t\treturn 1;\r\n\t}\r\n\tif (!quiet_mode) {\r\n\t\tprintf(_(\"done\\n\"));\r\n\t}\r\n\r\n\t/* Handle first received packet */\r\n\thandle_packet(buff, result);\r\n\r\n\tinit_packet(&data, MT_PTYPE_DATA, srcmac, dstmac, sessionkey, 0);\r\n\toutcounter += add_control_packet(&data, MT_CPTYPE_BEGINAUTH, NULL, 0);\r\n\r\n\t/* TODO: handle result of send_udp */\r\n\tresult = send_udp(&data, 1);\r\n\r\n\twhile (running) {\r\n\t\tfd_set read_fds;\r\n\t\tint reads;\r\n\t\tstatic int terminal_gone = 0;\r\n\t\tstruct timeval timeout;\r\n\r\n\t\t/* Init select */\r\n\t\tFD_ZERO(&read_fds);\r\n\t\tif (!terminal_gone) {\r\n\t\t\tFD_SET(0, &read_fds);\r\n\t\t}\r\n\t\tFD_SET(insockfd, &read_fds);\r\n\r\n\t\ttimeout.tv_sec = 1;\r\n\t\ttimeout.tv_usec = 0;\r\n\r\n\t\t/* Wait for data or timeout */\r\n\t\treads = select(insockfd+1, &read_fds, NULL, NULL, &timeout);\r\n\t\tif (reads > 0) {\r\n\t\t\t/* Handle data from server */\r\n\t\t\tif (FD_ISSET(insockfd, &read_fds)) {\r\n\t\t\t\tbzero(buff, sizeof(buff));\r\n\t\t\t\tresult = recvfrom(insockfd, buff, sizeof(buff), 0, 0, 0);\r\n\t\t\t\thandle_packet(buff, result);\r\n\t\t\t}\r\n\t\t\t/* Handle data from keyboard/local terminal */\r\n\t\t\tif (FD_ISSET(0, &read_fds) && terminal_mode) {\r\n\t\t\t\tunsigned char keydata[512];\r\n\t\t\t\tint datalen;\r\n\r\n\t\t\t\tdatalen = read(STDIN_FILENO, &keydata, sizeof(keydata));\r\n\r\n\t\t\t\tif (datalen > 0) {\r\n\t\t\t\t\t/* Data received, transmit to server */\r\n\t\t\t\t\tinit_packet(&data, MT_PTYPE_DATA, srcmac, dstmac, sessionkey, outcounter);\r\n\t\t\t\t\tadd_control_packet(&data, MT_CPTYPE_PLAINDATA, &keydata, datalen);\r\n\t\t\t\t\toutcounter += datalen;\r\n\t\t\t\t\tsend_udp(&data, 1);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tterminal_gone = 1;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t/* Handle select() timeout */\r\n\t\t} else {\r\n\t\t\t/* handle keepalive counter, transmit keepalive packet every 10 seconds\r\n\t\t\t   of inactivity  */\r\n\t\t\tif (keepalive_counter++ == 10) {\r\n\t\t\t\tstruct mt_packet odata;\r\n\t\t\t\tinit_packet(&odata, MT_PTYPE_ACK, srcmac, dstmac, sessionkey, outcounter);\r\n\t\t\t\tsend_udp(&odata, 0);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tif (is_a_tty && terminal_mode) {\r\n\t\t/* Reset terminal back to old settings */\r\n\t\treset_term();\r\n\t}\r\n\r\n\tclose(sockfd);\r\n\tclose(insockfd);\r\n\r\n\tDL_FOREACH_SAFE(interfaces, interface, tmp) {\r\n\t\tDL_DELETE(interfaces, interface);\r\n\t\tfree(interface);\r\n\t}\r\n\r\n\treturn 0;\r\n}", ".end_auth": "static void send_auth(char *username, char *password) {\r\n\tstruct mt_packet data;\r\n\tunsigned short width = 0;\r\n\tunsigned short height = 0;\r\n\tchar *terminal = getenv(\"TERM\");\r\n\tchar md5data[100];\r\n\tunsigned char md5sum[17];\r\n\tint plen, act_pass_len;\r\n\tmd5_state_t state;\r\n\r\n#if defined(__linux__) && defined(_POSIX_MEMLOCK_RANGE)\r\n\tmlock(md5data, sizeof(md5data));\r\n\tmlock(md5sum, sizeof(md5data));\r\n#endif\r\n\r\n\t/* calculate the actual password's length */\r\n\tact_pass_len = strnlen(password, 82);\r\n\r\n\t/* Concat string of 0 + password + pass_salt */\r\n\tmd5data[0] = 0;\r\n\tmemcpy(md5data + 1, password, act_pass_len);\r\n\t/* in case that password is long, calculate only using the used-up parts */\r\n\tmemcpy(md5data + 1 + act_pass_len, pass_salt, 16);\r\n\r\n\t/* Generate md5 sum of md5data with a leading 0 */\r\n\tmd5_init(&state);\r\n\tmd5_append(&state, (const md5_byte_t *)md5data, 1 + act_pass_len + 16);\r\n\tmd5_finish(&state, (md5_byte_t *)md5sum + 1);\r\n\tmd5sum[0] = 0;\r\n\r\n\t/* Send combined packet to server */\r\n\tinit_packet(&data, MT_PTYPE_DATA, srcmac, dstmac, sessionkey, outcounter);\r\n\tplen = add_control_packet(&data, MT_CPTYPE_PASSWORD, md5sum, 17);\r\n\tplen += add_control_packet(&data, MT_CPTYPE_USERNAME, username, strlen(username));\r\n\tplen += add_control_packet(&data, MT_CPTYPE_TERM_TYPE, terminal, strlen(terminal));\r\n\t\r\n\tif (is_a_tty && get_terminal_size(&width, &height) != -1) {\r\n\t\twidth = htole16(width);\r\n\t\theight = htole16(height);\r\n\t\tplen += add_control_packet(&data, MT_CPTYPE_TERM_WIDTH, &width, 2);\r\n\t\tplen += add_control_packet(&data, MT_CPTYPE_TERM_HEIGHT, &height, 2);\r\n\t}\r\n\r\n\toutcounter += plen;\r\n\r\n\t/* TODO: handle result */\r\n\tsend_udp(&data, 1);\r\n}", ".ig_winch": "static void sig_winch(int sig) {\r\n\tunsigned short width,height;\r\n\tstruct mt_packet data;\r\n\tint plen;\r\n\r\n\t/* terminal height/width has changed, inform server */\r\n\tif (get_terminal_size(&width, &height) != -1) {\r\n\t\tinit_packet(&data, MT_PTYPE_DATA, srcmac, dstmac, sessionkey, outcounter);\r\n\t\twidth = htole16(width);\r\n\t\theight = htole16(height);\r\n\t\tplen = add_control_packet(&data, MT_CPTYPE_TERM_WIDTH, &width, 2);\r\n\t\tplen += add_control_packet(&data, MT_CPTYPE_TERM_HEIGHT, &height, 2);\r\n\t\toutcounter += plen;\r\n\r\n\t\tsend_udp(&data, 1);\r\n\t}\r\n\r\n\t/* reinstate signal handler */\r\n\tsignal(SIGWINCH, sig_winch);\r\n}", ".andle_packet": "static int handle_packet(unsigned char *data, int data_len) {\r\n\tstruct mt_mactelnet_hdr pkthdr;\r\n\r\n\t/* Minimal size checks (pings are not supported here) */\r\n\tif (data_len < MT_HEADER_LEN){\r\n\t\treturn -1;\r\n\t}\r\n\tparse_packet(data, &pkthdr);\r\n\r\n\t/* We only care about packets with correct sessionkey */\r\n\tif (pkthdr.seskey != sessionkey) {\r\n\t\treturn -1;\r\n\t}\r\n\r\n\t/* Handle data packets */\r\n\tif (pkthdr.ptype == MT_PTYPE_DATA) {\r\n\t\tstruct mt_packet odata;\r\n\t\tstruct mt_mactelnet_control_hdr cpkt;\r\n\t\tint success = 0;\r\n\r\n\t\t/* Always transmit ACKNOWLEDGE packets in response to DATA packets */\r\n\t\tinit_packet(&odata, MT_PTYPE_ACK, srcmac, dstmac, sessionkey, pkthdr.counter + (data_len - MT_HEADER_LEN));\r\n\t\tsend_udp(&odata, 0);\r\n\r\n\t\t/* Accept first packet, and all packets greater than incounter, and if counter has\r\n\t\twrapped around. */\r\n\t\tif (pkthdr.counter > incounter || (incounter - pkthdr.counter) > 65535) {\r\n\t\t\tincounter = pkthdr.counter;\r\n\t\t} else {\r\n\t\t\t/* Ignore double or old packets */\r\n\t\t\treturn -1;\r\n\t\t}\r\n\r\n\t\t/* Parse controlpacket data */\r\n\t\tsuccess = parse_control_packet(data + MT_HEADER_LEN, data_len - MT_HEADER_LEN, &cpkt);\r\n\r\n\t\twhile (success) {\r\n\r\n\t\t\t/* If we receive pass_salt, transmit auth data back */\r\n\t\t\tif (cpkt.cptype == MT_CPTYPE_PASSSALT) {\r\n\t\t\t\t/* check validity, server sends exactly 16 bytes */\r\n\t\t\t\tif (cpkt.length != 16) {\r\n\t\t\t\t\tfprintf(stderr, _(\"Invalid salt length: %d (instead of 16) received from server %s\\n\"), cpkt.length, ether_ntoa((struct ether_addr *)dstmac));\r\n\t\t\t\t}\r\n\t\t\t\tmemcpy(pass_salt, cpkt.data, 16);\r\n\t\t\t\tsend_auth(username, password);\r\n\t\t\t}\r\n\r\n\t\t\t/* If the (remaining) data did not have a control-packet magic byte sequence,\r\n\t\t\t   the data is raw terminal data to be outputted to the terminal. */\r\n\t\t\telse if (cpkt.cptype == MT_CPTYPE_PLAINDATA) {\r\n\t\t\t\tfwrite((const void *)cpkt.data, 1, cpkt.length, stdout);\r\n\t\t\t}\r\n\r\n\t\t\t/* END_AUTH means that the user/password negotiation is done, and after this point\r\n\t\t\t   terminal data may arrive, so we set up the terminal to raw mode. */\r\n\t\t\telse if (cpkt.cptype == MT_CPTYPE_END_AUTH) {\r\n\r\n\t\t\t\t/* we have entered \"terminal mode\" */\r\n\t\t\t\tterminal_mode = 1;\r\n\r\n\t\t\t\tif (is_a_tty) {\r\n\t\t\t\t\t/* stop input buffering at all levels. Give full control of terminal to RouterOS */\r\n\t\t\t\t\traw_term();\r\n\r\n\t\t\t\t\tsetvbuf(stdin,  (char*)NULL, _IONBF, 0);\r\n\r\n\t\t\t\t\t/* Add resize signal handler */\r\n\t\t\t\t\tsignal(SIGWINCH, sig_winch);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t/* Parse next controlpacket */\r\n\t\t\tsuccess = parse_control_packet(NULL, 0, &cpkt);\r\n\t\t}\r\n\t}\r\n\telse if (pkthdr.ptype == MT_PTYPE_ACK) {\r\n\t\t/* Handled elsewhere */\r\n\t}\r\n\r\n\t/* The server wants to terminate the connection, we have to oblige */\r\n\telse if (pkthdr.ptype == MT_PTYPE_END) {\r\n\t\tstruct mt_packet odata;\r\n\r\n\t\t/* Acknowledge the disconnection by sending a END packet in return */\r\n\t\tinit_packet(&odata, MT_PTYPE_END, srcmac, dstmac, pkthdr.seskey, 0);\r\n\t\tsend_udp(&odata, 0);\r\n\r\n\t\tif (!quiet_mode) {\r\n\t\t\tfprintf(stderr, _(\"Connection closed.\\n\"));\r\n\t\t}\r\n\r\n\t\t/* exit */\r\n\t\trunning = 0;\r\n\t} else {\r\n\t\tfprintf(stderr, _(\"Unhandeled packet type: %d received from server %s\\n\"), pkthdr.ptype, ether_ntoa((struct ether_addr *)dstmac));\r\n\t\treturn -1;\r\n\t}\r\n\r\n\treturn pkthdr.ptype;\r\n}", ".ind_interface": "static int find_interface() {\r\n\tfd_set read_fds;\r\n\tstruct mt_packet data;\r\n\tstruct sockaddr_in myip;\r\n\tunsigned char emptymac[ETH_ALEN];\r\n\tint testsocket;\r\n\tstruct timeval timeout;\r\n\tint optval = 1;\r\n\tstruct net_interface *interface;\r\n\r\n\t/* TODO: reread interfaces on HUP */\r\n\t//bzero(&interfaces, sizeof(struct net_interface) * MAX_INTERFACES);\r\n\r\n\tbzero(emptymac, ETH_ALEN);\r\n\r\n\tif (net_get_interfaces(&interfaces) <= 0) {\r\n\t\tfprintf(stderr, _(\"Error: No suitable devices found\\n\"));\r\n\t\texit(1);\r\n\t}\r\n\r\n\tDL_FOREACH(interfaces, interface) {\r\n\t\t/* Skip loopback interfaces */\r\n\t\tif (memcmp(\"lo\", interface->name, 2) == 0) {\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\t/* Initialize receiving socket on the device chosen */\r\n\t\tmyip.sin_family = AF_INET;\r\n\t\tmemcpy((void *)&myip.sin_addr, interface->ipv4_addr, IPV4_ALEN);\r\n\t\tmyip.sin_port = htons(sourceport);\r\n\r\n\t\t/* Initialize socket and bind to udp port */\r\n\t\tif ((testsocket = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)) < 0) {\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\tsetsockopt(testsocket, SOL_SOCKET, SO_BROADCAST, &optval, sizeof(optval));\r\n\t\tsetsockopt(testsocket, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval));\r\n\r\n\t\tif (bind(testsocket, (struct sockaddr *)&myip, sizeof(struct sockaddr_in)) == -1) {\r\n\t\t\tclose(testsocket);\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\t/* Ensure that we have mac-address for this interface  */\r\n\t\tif (!interface->has_mac) {\r\n\t\t\tclose(testsocket);\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\t/* Set the global socket handle and source mac address for send_udp() */\r\n\t\tsend_socket = testsocket;\r\n\t\tmemcpy(srcmac, interface->mac_addr, ETH_ALEN);\r\n\t\tactive_interface = interface;\r\n\r\n\t\t/* Send a SESSIONSTART message with the current device */\r\n\t\tinit_packet(&data, MT_PTYPE_SESSIONSTART, srcmac, dstmac, sessionkey, 0);\r\n\t\tsend_udp(&data, 0);\r\n\r\n\t\ttimeout.tv_sec = connect_timeout;\r\n\t\ttimeout.tv_usec = 0;\r\n\r\n\t\tFD_ZERO(&read_fds);\r\n\t\tFD_SET(insockfd, &read_fds);\r\n\t\tselect(insockfd + 1, &read_fds, NULL, NULL, &timeout);\r\n\t\tif (FD_ISSET(insockfd, &read_fds)) {\r\n\t\t\t/* We got a response, this is the correct device to use */\r\n\t\t\treturn 1;\r\n\t\t}\r\n\r\n\t\tclose(testsocket);\r\n\t}\r\n\treturn 0;\r\n}", ".end_udp": "static int send_udp(struct mt_packet *packet, int retransmit) {\r\n\tint sent_bytes;\r\n\r\n\t/* Clear keepalive counter */\r\n\tkeepalive_counter = 0;\r\n\r\n\tif (!use_raw_socket) {\r\n\t\t/* Init SendTo struct */\r\n\t\tstruct sockaddr_in socket_address;\r\n\t\tsocket_address.sin_family = AF_INET;\r\n\t\tsocket_address.sin_port = htons(MT_MACTELNET_PORT);\r\n\t\tsocket_address.sin_addr.s_addr = htonl(INADDR_BROADCAST);\r\n\r\n\t\tsent_bytes = sendto(send_socket, packet->data, packet->size, 0, (struct sockaddr*)&socket_address, sizeof(socket_address));\r\n\t} else {\r\n\t\tsent_bytes = net_send_udp(sockfd, active_interface, srcmac, dstmac, &sourceip,  sourceport, &destip, MT_MACTELNET_PORT, packet->data, packet->size);\r\n\t}\r\n\r\n\t/* \r\n\t * Retransmit packet if no data is received within\r\n\t * retransmit_intervals milliseconds.\r\n\t */\r\n\tif (retransmit) {\r\n\t\tint i;\r\n\r\n\t\tfor (i = 0; i < MAX_RETRANSMIT_INTERVALS; ++i) {\r\n\t\t\tfd_set read_fds;\r\n\t\t\tint reads;\r\n\t\t\tstruct timeval timeout;\r\n\t\t\tint interval = retransmit_intervals[i] * 1000;\r\n\r\n\t\t\t/* Init select */\r\n\t\t\tFD_ZERO(&read_fds);\r\n\t\t\tFD_SET(insockfd, &read_fds);\r\n\t\t\ttimeout.tv_sec = 0;\r\n\t\t\ttimeout.tv_usec = interval;\r\n\r\n\t\t\t/* Wait for data or timeout */\r\n\t\t\treads = select(insockfd + 1, &read_fds, NULL, NULL, &timeout);\r\n\t\t\tif (reads && FD_ISSET(insockfd, &read_fds)) {\r\n\t\t\t\tunsigned char buff[MT_PACKET_LEN];\r\n\t\t\t\tint result;\r\n\r\n\t\t\t\tbzero(buff, sizeof(buff));\r\n\t\t\t\tresult = recvfrom(insockfd, buff, sizeof(buff), 0, 0, 0);\r\n\r\n\t\t\t\t/* Handle incoming packets, waiting for an ack */\r\n\t\t\t\tif (result > 0 && handle_packet(buff, result) == MT_PTYPE_ACK) {\r\n\t\t\t\t\treturn sent_bytes;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t/* Retransmit */\r\n\t\t\tsend_udp(packet, 0);\r\n\t\t}\r\n\r\n\t\tif (is_a_tty && terminal_mode) {\r\n\t\t\treset_term();\r\n\t\t}\r\n\r\n\t\tfprintf(stderr, _(\"\\nConnection timed out\\n\"));\r\n\t\texit(1);\r\n\t}\r\n\treturn sent_bytes;\r\n}"}, "function_name": "main"}
{"function_id": null, "caller": {".heck_notify_received": "static bool check_notify_received(const notification_t *n) /* {{{ */\r\n{\r\n  for (notification_meta_t *ptr = n->meta; ptr != NULL; ptr = ptr->next)\r\n    if ((strcmp(\"network:received\", ptr->name) == 0) &&\r\n        (ptr->type == NM_TYPE_BOOLEAN))\r\n      return (bool)ptr->nm_value.nm_boolean;\r\n\r\n  return 0;\r\n}", ".heck_receive_okay": "static bool check_receive_okay(const value_list_t *vl) /* {{{ */\r\n{\r\n  uint64_t time_sent = 0;\r\n  int status;\r\n\r\n  status = uc_meta_data_get_unsigned_int(vl, \"network:time_sent\", &time_sent);\r\n\r\n  /* This is a value we already sent. Don't allow it to be received again in\r\n   * order to avoid looping. */\r\n  if ((status == 0) && (time_sent >= ((uint64_t)vl->time)))\r\n    return 0;\r\n\r\n  return 1;\r\n}", ".arse_packet": "static int parse_packet(sockent_t *se, /* {{{ */\r\n                        void *buffer, size_t buffer_size, int flags,\r\n                        const char *username,\r\n                        struct sockaddr_storage *address) {\r\n  int status;\r\n\r\n  value_list_t vl = VALUE_LIST_INIT;\r\n  notification_t n = {0};\r\n\r\n#if HAVE_GCRYPT_H\r\n  int packet_was_signed = (flags & PP_SIGNED);\r\n  int packet_was_encrypted = (flags & PP_ENCRYPTED);\r\n  int printed_ignore_warning = 0;\r\n#endif /* HAVE_GCRYPT_H */\r\n\r\n  memset(&vl, '\\0', sizeof(vl));\r\n  status = 0;\r\n\r\n  while ((status == 0) && (0 < buffer_size) &&\r\n         ((unsigned int)buffer_size > sizeof(part_header_t))) {\r\n    uint16_t pkg_length;\r\n    uint16_t pkg_type;\r\n\r\n    memcpy((void *)&pkg_type, (void *)buffer, sizeof(pkg_type));\r\n    memcpy((void *)&pkg_length, (void *)(((char *)buffer) + sizeof(pkg_type)),\r\n           sizeof(pkg_length));\r\n\r\n    pkg_length = ntohs(pkg_length);\r\n    pkg_type = ntohs(pkg_type);\r\n\r\n    if (pkg_length > buffer_size)\r\n      break;\r\n    /* Ensure that this loop terminates eventually */\r\n    if (pkg_length < (2 * sizeof(uint16_t)))\r\n      break;\r\n\r\n    if (pkg_type == TYPE_ENCR_AES256) {\r\n      status =\r\n          parse_part_encr_aes256(se, &buffer, &buffer_size, flags, address);\r\n      if (status != 0) {\r\n        ERROR(\"network plugin: Decrypting AES256 \"\r\n              \"part failed \"\r\n              \"with status %i.\",\r\n              status);\r\n        break;\r\n      }\r\n    }\r\n#if HAVE_GCRYPT_H\r\n    else if ((se->data.server.security_level == SECURITY_LEVEL_ENCRYPT) &&\r\n             (packet_was_encrypted == 0)) {\r\n      if (printed_ignore_warning == 0) {\r\n        INFO(\"network plugin: Unencrypted packet or \"\r\n             \"part has been ignored.\");\r\n        printed_ignore_warning = 1;\r\n      }\r\n      buffer = ((char *)buffer) + pkg_length;\r\n      buffer_size -= (size_t)pkg_length;\r\n      continue;\r\n    }\r\n#endif /* HAVE_GCRYPT_H */\r\n    else if (pkg_type == TYPE_SIGN_SHA256) {\r\n      status =\r\n          parse_part_sign_sha256(se, &buffer, &buffer_size, flags, address);\r\n      if (status != 0) {\r\n        ERROR(\"network plugin: Verifying HMAC-SHA-256 \"\r\n              \"signature failed \"\r\n              \"with status %i.\",\r\n              status);\r\n        break;\r\n      }\r\n    }\r\n#if HAVE_GCRYPT_H\r\n    else if ((se->data.server.security_level == SECURITY_LEVEL_SIGN) &&\r\n             (packet_was_encrypted == 0) && (packet_was_signed == 0)) {\r\n      if (printed_ignore_warning == 0) {\r\n        INFO(\"network plugin: Unsigned packet or \"\r\n             \"part has been ignored.\");\r\n        printed_ignore_warning = 1;\r\n      }\r\n      buffer = ((char *)buffer) + pkg_length;\r\n      buffer_size -= (size_t)pkg_length;\r\n      continue;\r\n    }\r\n#endif /* HAVE_GCRYPT_H */\r\n    else if (pkg_type == TYPE_VALUES) {\r\n      status =\r\n          parse_part_values(&buffer, &buffer_size, &vl.values, &vl.values_len);\r\n      if (status != 0)\r\n        break;\r\n\r\n      network_dispatch_values(&vl, username, address);\r\n\r\n      sfree(vl.values);\r\n    } else if (pkg_type == TYPE_TIME) {\r\n      uint64_t tmp = 0;\r\n      status = parse_part_number(&buffer, &buffer_size, &tmp);\r\n      if (status == 0) {\r\n        vl.time = TIME_T_TO_CDTIME_T(tmp);\r\n        n.time = TIME_T_TO_CDTIME_T(tmp);\r\n      }\r\n    } else if (pkg_type == TYPE_TIME_HR) {\r\n      uint64_t tmp = 0;\r\n      status = parse_part_number(&buffer, &buffer_size, &tmp);\r\n      if (status == 0) {\r\n        vl.time = (cdtime_t)tmp;\r\n        n.time = (cdtime_t)tmp;\r\n      }\r\n    } else if (pkg_type == TYPE_INTERVAL) {\r\n      uint64_t tmp = 0;\r\n      status = parse_part_number(&buffer, &buffer_size, &tmp);\r\n      if (status == 0)\r\n        vl.interval = TIME_T_TO_CDTIME_T(tmp);\r\n    } else if (pkg_type == TYPE_INTERVAL_HR) {\r\n      uint64_t tmp = 0;\r\n      status = parse_part_number(&buffer, &buffer_size, &tmp);\r\n      if (status == 0)\r\n        vl.interval = (cdtime_t)tmp;\r\n    } else if (pkg_type == TYPE_HOST) {\r\n      status =\r\n          parse_part_string(&buffer, &buffer_size, vl.host, sizeof(vl.host));\r\n      if (status == 0)\r\n        sstrncpy(n.host, vl.host, sizeof(n.host));\r\n    } else if (pkg_type == TYPE_PLUGIN) {\r\n      status = parse_part_string(&buffer, &buffer_size, vl.plugin,\r\n                                 sizeof(vl.plugin));\r\n      if (status == 0)\r\n        sstrncpy(n.plugin, vl.plugin, sizeof(n.plugin));\r\n    } else if (pkg_type == TYPE_PLUGIN_INSTANCE) {\r\n      status = parse_part_string(&buffer, &buffer_size, vl.plugin_instance,\r\n                                 sizeof(vl.plugin_instance));\r\n      if (status == 0)\r\n        sstrncpy(n.plugin_instance, vl.plugin_instance,\r\n                 sizeof(n.plugin_instance));\r\n    } else if (pkg_type == TYPE_TYPE) {\r\n      status =\r\n          parse_part_string(&buffer, &buffer_size, vl.type, sizeof(vl.type));\r\n      if (status == 0)\r\n        sstrncpy(n.type, vl.type, sizeof(n.type));\r\n    } else if (pkg_type == TYPE_TYPE_INSTANCE) {\r\n      status = parse_part_string(&buffer, &buffer_size, vl.type_instance,\r\n                                 sizeof(vl.type_instance));\r\n      if (status == 0)\r\n        sstrncpy(n.type_instance, vl.type_instance, sizeof(n.type_instance));\r\n    } else if (pkg_type == TYPE_MESSAGE) {\r\n      status = parse_part_string(&buffer, &buffer_size, n.message,\r\n                                 sizeof(n.message));\r\n\r\n      if (status != 0) {\r\n        /* do nothing */\r\n      } else if ((n.severity != NOTIF_FAILURE) &&\r\n                 (n.severity != NOTIF_WARNING) && (n.severity != NOTIF_OKAY)) {\r\n        INFO(\"network plugin: \"\r\n             \"Ignoring notification with \"\r\n             \"unknown severity %i.\",\r\n             n.severity);\r\n      } else if (n.time == 0) {\r\n        INFO(\"network plugin: \"\r\n             \"Ignoring notification with \"\r\n             \"time == 0.\");\r\n      } else if (strlen(n.message) == 0) {\r\n        INFO(\"network plugin: \"\r\n             \"Ignoring notification with \"\r\n             \"an empty message.\");\r\n      } else {\r\n        network_dispatch_notification(&n);\r\n      }\r\n    } else if (pkg_type == TYPE_SEVERITY) {\r\n      uint64_t tmp = 0;\r\n      status = parse_part_number(&buffer, &buffer_size, &tmp);\r\n      if (status == 0)\r\n        n.severity = (int)tmp;\r\n    } else {\r\n      DEBUG(\"network plugin: parse_packet: Unknown part\"\r\n            \" type: 0x%04hx\",\r\n            pkg_type);\r\n      buffer = ((char *)buffer) + pkg_length;\r\n      buffer_size -= (size_t)pkg_length;\r\n    }\r\n  } /* while (buffer_size > sizeof (part_header_t)) */\r\n\r\n  if (status == 0 && buffer_size > 0)\r\n    WARNING(\"network plugin: parse_packet: Received truncated \"\r\n            \"packet, try increasing `MaxPacketSize'\");\r\n\r\n  return status;\r\n}", ".etwork_get_aes256_cypher": "static gcry_cipher_hd_t network_get_aes256_cypher(sockent_t *se, /* {{{ */\r\n                                                  const void *iv,\r\n                                                  size_t iv_size,\r\n                                                  const char *username) {\r\n  gcry_error_t err;\r\n  gcry_cipher_hd_t *cyper_ptr;\r\n  unsigned char password_hash[32];\r\n\r\n  if (se->type == SOCKENT_TYPE_CLIENT) {\r\n    cyper_ptr = &se->data.client.cypher;\r\n    memcpy(password_hash, se->data.client.password_hash, sizeof(password_hash));\r\n  } else {\r\n    char *secret;\r\n\r\n    cyper_ptr = &se->data.server.cypher;\r\n\r\n    if (username == NULL)\r\n      return NULL;\r\n\r\n    secret = fbh_get(se->data.server.userdb, username);\r\n    if (secret == NULL)\r\n      return NULL;\r\n\r\n    gcry_md_hash_buffer(GCRY_MD_SHA256, password_hash, secret, strlen(secret));\r\n\r\n    sfree(secret);\r\n  }\r\n\r\n  if (*cyper_ptr == NULL) {\r\n    err = gcry_cipher_open(cyper_ptr, GCRY_CIPHER_AES256, GCRY_CIPHER_MODE_OFB,\r\n                           /* flags = */ 0);\r\n    if (err != 0) {\r\n      ERROR(\"network plugin: gcry_cipher_open returned: %s\",\r\n            gcry_strerror(err));\r\n      *cyper_ptr = NULL;\r\n      return NULL;\r\n    }\r\n  } else {\r\n    gcry_cipher_reset(*cyper_ptr);\r\n  }\r\n  assert(*cyper_ptr != NULL);\r\n\r\n  err = gcry_cipher_setkey(*cyper_ptr, password_hash, sizeof(password_hash));\r\n  if (err != 0) {\r\n    ERROR(\"network plugin: gcry_cipher_setkey returned: %s\",\r\n          gcry_strerror(err));\r\n    gcry_cipher_close(*cyper_ptr);\r\n    *cyper_ptr = NULL;\r\n    return NULL;\r\n  }\r\n\r\n  err = gcry_cipher_setiv(*cyper_ptr, iv, iv_size);\r\n  if (err != 0) {\r\n    ERROR(\"network plugin: gcry_cipher_setkey returned: %s\",\r\n          gcry_strerror(err));\r\n    gcry_cipher_close(*cyper_ptr);\r\n    *cyper_ptr = NULL;\r\n    return NULL;\r\n  }\r\n\r\n  return *cyper_ptr;\r\n}", ".arse_part_encr_aes256": "static int parse_part_encr_aes256(sockent_t *se, /* {{{ */\r\n                                  void **ret_buffer, size_t *ret_buffer_len,\r\n                                  int flags, struct sockaddr_storage *sender) {\r\n  char *buffer = *ret_buffer;\r\n  size_t buffer_len = *ret_buffer_len;\r\n  size_t payload_len;\r\n  size_t part_size;\r\n  size_t buffer_offset;\r\n  uint16_t username_len;\r\n  part_encryption_aes256_t pea;\r\n  unsigned char hash[sizeof(pea.hash)] = {0};\r\n\r\n  gcry_cipher_hd_t cypher;\r\n  gcry_error_t err;\r\n\r\n  /* Make sure at least the header if available. */\r\n  if (buffer_len <= PART_ENCRYPTION_AES256_SIZE) {\r\n    NOTICE(\"network plugin: parse_part_encr_aes256: \"\r\n           \"Discarding short packet.\");\r\n    return -1;\r\n  }\r\n\r\n  buffer_offset = 0;\r\n\r\n  /* Copy the unencrypted information into `pea'. */\r\n  BUFFER_READ(&pea.head.type, sizeof(pea.head.type));\r\n  BUFFER_READ(&pea.head.length, sizeof(pea.head.length));\r\n\r\n  /* Check the `part size'. */\r\n  part_size = ntohs(pea.head.length);\r\n  if ((part_size <= PART_ENCRYPTION_AES256_SIZE) || (part_size > buffer_len)) {\r\n    NOTICE(\"network plugin: parse_part_encr_aes256: \"\r\n           \"Discarding part with invalid size.\");\r\n    return -1;\r\n  }\r\n\r\n  /* Read the username */\r\n  BUFFER_READ(&username_len, sizeof(username_len));\r\n  username_len = ntohs(username_len);\r\n\r\n  if ((username_len == 0) ||\r\n      (username_len > (part_size - (PART_ENCRYPTION_AES256_SIZE + 1)))) {\r\n    NOTICE(\"network plugin: parse_part_encr_aes256: \"\r\n           \"Discarding part with invalid username length.\");\r\n    return -1;\r\n  }\r\n\r\n  assert(username_len > 0);\r\n  pea.username = malloc(username_len + 1);\r\n  if (pea.username == NULL)\r\n    return -ENOMEM;\r\n  BUFFER_READ(pea.username, username_len);\r\n  pea.username[username_len] = 0;\r\n\r\n  /* Last but not least, the initialization vector */\r\n  BUFFER_READ(pea.iv, sizeof(pea.iv));\r\n\r\n  /* Make sure we are at the right position */\r\n  assert(buffer_offset ==\r\n         (username_len + PART_ENCRYPTION_AES256_SIZE - sizeof(pea.hash)));\r\n\r\n  cypher = network_get_aes256_cypher(se, pea.iv, sizeof(pea.iv), pea.username);\r\n  if (cypher == NULL) {\r\n    ERROR(\"network plugin: Failed to get cypher. Username: %s\", pea.username);\r\n    sfree(pea.username);\r\n    return -1;\r\n  }\r\n\r\n  payload_len = part_size - (PART_ENCRYPTION_AES256_SIZE + username_len);\r\n  assert(payload_len > 0);\r\n\r\n  /* Decrypt the packet in-place */\r\n  err = gcry_cipher_decrypt(cypher, buffer + buffer_offset,\r\n                            part_size - buffer_offset,\r\n                            /* in = */ NULL, /* in len = */ 0);\r\n  if (err != 0) {\r\n    ERROR(\"network plugin: gcry_cipher_decrypt returned: %s. Username: %s\",\r\n          gcry_strerror(err), pea.username);\r\n    sfree(pea.username);\r\n    return -1;\r\n  }\r\n\r\n  /* Read the hash */\r\n  BUFFER_READ(pea.hash, sizeof(pea.hash));\r\n\r\n  /* Make sure we're at the right position - again */\r\n  assert(buffer_offset == (username_len + PART_ENCRYPTION_AES256_SIZE));\r\n  assert(buffer_offset == (part_size - payload_len));\r\n\r\n  /* Check hash sum */\r\n  gcry_md_hash_buffer(GCRY_MD_SHA1, hash, buffer + buffer_offset, payload_len);\r\n  if (memcmp(hash, pea.hash, sizeof(hash)) != 0) {\r\n    ERROR(\"network plugin: Checksum mismatch. Username: %s\", pea.username);\r\n    sfree(pea.username);\r\n    return -1;\r\n  }\r\n\r\n  parse_packet(se, buffer + buffer_offset, payload_len, flags | PP_ENCRYPTED,\r\n               pea.username, sender);\r\n\r\n  /* Update return values */\r\n  *ret_buffer = buffer + part_size;\r\n  *ret_buffer_len = buffer_len - part_size;\r\n\r\n  sfree(pea.username);\r\n\r\n  return 0;\r\n}", ".arse_part_sign_sha256": "static int parse_part_sign_sha256(sockent_t *se, /* {{{ */\r\n                                  void **ret_buffer, size_t *ret_buffer_len,\r\n                                  int flags, struct sockaddr_storage *sender) {\r\n  static c_complain_t complain_no_users = C_COMPLAIN_INIT_STATIC;\r\n\r\n  char *buffer;\r\n  size_t buffer_len;\r\n  size_t buffer_offset;\r\n\r\n  size_t username_len;\r\n  char *secret;\r\n\r\n  part_signature_sha256_t pss;\r\n  uint16_t pss_head_length;\r\n  char hash[sizeof(pss.hash)];\r\n\r\n  gcry_md_hd_t hd;\r\n  gcry_error_t err;\r\n  unsigned char *hash_ptr;\r\n\r\n  buffer = *ret_buffer;\r\n  buffer_len = *ret_buffer_len;\r\n  buffer_offset = 0;\r\n\r\n  /* Check if the buffer has enough data for this structure. */\r\n  if (buffer_len <= PART_SIGNATURE_SHA256_SIZE)\r\n    return -ENOMEM;\r\n\r\n  /* Read type and length header */\r\n  BUFFER_READ(&pss.head.type, sizeof(pss.head.type));\r\n  BUFFER_READ(&pss.head.length, sizeof(pss.head.length));\r\n  pss_head_length = ntohs(pss.head.length);\r\n\r\n  /* Check if the `pss_head_length' is within bounds. */\r\n  if ((pss_head_length <= PART_SIGNATURE_SHA256_SIZE) ||\r\n      (pss_head_length > buffer_len)) {\r\n    ERROR(\"network plugin: HMAC-SHA-256 with invalid length received.\");\r\n    return -1;\r\n  }\r\n\r\n  if (se->data.server.userdb == NULL) {\r\n    c_complain(\r\n        LOG_NOTICE, &complain_no_users,\r\n        \"network plugin: Received signed network packet but can't verify it \"\r\n        \"because no user DB has been configured. Will accept it.\");\r\n\r\n    *ret_buffer = buffer + pss_head_length;\r\n    *ret_buffer_len -= pss_head_length;\r\n\r\n    return 0;\r\n  }\r\n\r\n  /* Copy the hash. */\r\n  BUFFER_READ(pss.hash, sizeof(pss.hash));\r\n\r\n  /* Calculate username length (without null byte) and allocate memory */\r\n  username_len = pss_head_length - PART_SIGNATURE_SHA256_SIZE;\r\n  pss.username = malloc(username_len + 1);\r\n  if (pss.username == NULL)\r\n    return -ENOMEM;\r\n\r\n  /* Read the username */\r\n  BUFFER_READ(pss.username, username_len);\r\n  pss.username[username_len] = 0;\r\n\r\n  assert(buffer_offset == pss_head_length);\r\n\r\n  /* Query the password */\r\n  secret = fbh_get(se->data.server.userdb, pss.username);\r\n  if (secret == NULL) {\r\n    ERROR(\"network plugin: Unknown user: %s\", pss.username);\r\n    sfree(pss.username);\r\n    return -ENOENT;\r\n  }\r\n\r\n  /* Create a hash device and check the HMAC */\r\n  hd = NULL;\r\n  err = gcry_md_open(&hd, GCRY_MD_SHA256, GCRY_MD_FLAG_HMAC);\r\n  if (err != 0) {\r\n    ERROR(\"network plugin: Creating HMAC-SHA-256 object failed: %s\",\r\n          gcry_strerror(err));\r\n    sfree(secret);\r\n    sfree(pss.username);\r\n    return -1;\r\n  }\r\n\r\n  err = gcry_md_setkey(hd, secret, strlen(secret));\r\n  if (err != 0) {\r\n    ERROR(\"network plugin: gcry_md_setkey failed: %s\", gcry_strerror(err));\r\n    gcry_md_close(hd);\r\n    sfree(secret);\r\n    sfree(pss.username);\r\n    return -1;\r\n  }\r\n\r\n  gcry_md_write(hd, buffer + PART_SIGNATURE_SHA256_SIZE,\r\n                buffer_len - PART_SIGNATURE_SHA256_SIZE);\r\n  hash_ptr = gcry_md_read(hd, GCRY_MD_SHA256);\r\n  if (hash_ptr == NULL) {\r\n    ERROR(\"network plugin: gcry_md_read failed.\");\r\n    gcry_md_close(hd);\r\n    sfree(secret);\r\n    sfree(pss.username);\r\n    return -1;\r\n  }\r\n  memcpy(hash, hash_ptr, sizeof(hash));\r\n\r\n  /* Clean up */\r\n  gcry_md_close(hd);\r\n  hd = NULL;\r\n\r\n  if (memcmp(pss.hash, hash, sizeof(pss.hash)) != 0) {\r\n    WARNING(\"network plugin: Verifying HMAC-SHA-256 signature failed: \"\r\n            \"Hash mismatch. Username: %s\",\r\n            pss.username);\r\n  } else {\r\n    parse_packet(se, buffer + buffer_offset, buffer_len - buffer_offset,\r\n                 flags | PP_SIGNED, pss.username, sender);\r\n  }\r\n\r\n  sfree(secret);\r\n  sfree(pss.username);\r\n\r\n  *ret_buffer = buffer + buffer_len;\r\n  *ret_buffer_len = 0;\r\n\r\n  return 0;\r\n}", ".arse_part_values": "static int parse_part_values(void **ret_buffer, size_t *ret_buffer_len,\r\n                             value_t **ret_values, size_t *ret_num_values) {\r\n  char *buffer = *ret_buffer;\r\n  size_t buffer_len = *ret_buffer_len;\r\n\r\n  uint16_t tmp16;\r\n  size_t exp_size;\r\n\r\n  uint16_t pkg_length;\r\n  uint16_t pkg_type;\r\n  size_t pkg_numval;\r\n\r\n  uint8_t *pkg_types;\r\n  value_t *pkg_values;\r\n\r\n  if (buffer_len < 15) {\r\n    NOTICE(\"network plugin: packet is too short: \"\r\n           \"buffer_len = %\" PRIsz,\r\n           buffer_len);\r\n    return -1;\r\n  }\r\n\r\n  memcpy((void *)&tmp16, buffer, sizeof(tmp16));\r\n  buffer += sizeof(tmp16);\r\n  pkg_type = ntohs(tmp16);\r\n\r\n  memcpy((void *)&tmp16, buffer, sizeof(tmp16));\r\n  buffer += sizeof(tmp16);\r\n  pkg_length = ntohs(tmp16);\r\n\r\n  memcpy((void *)&tmp16, buffer, sizeof(tmp16));\r\n  buffer += sizeof(tmp16);\r\n  pkg_numval = (size_t)ntohs(tmp16);\r\n\r\n  assert(pkg_type == TYPE_VALUES);\r\n\r\n  exp_size =\r\n      3 * sizeof(uint16_t) + pkg_numval * (sizeof(uint8_t) + sizeof(value_t));\r\n  if (buffer_len < exp_size) {\r\n    WARNING(\"network plugin: parse_part_values: \"\r\n            \"Packet too short: \"\r\n            \"Chunk of size %\" PRIsz \" expected, \"\r\n            \"but buffer has only %\" PRIsz \" bytes left.\",\r\n            exp_size, buffer_len);\r\n    return -1;\r\n  }\r\n  assert(pkg_numval <= ((buffer_len - 6) / 9));\r\n\r\n  if (pkg_length != exp_size) {\r\n    WARNING(\"network plugin: parse_part_values: \"\r\n            \"Length and number of values \"\r\n            \"in the packet don't match.\");\r\n    return -1;\r\n  }\r\n\r\n  pkg_types = calloc(pkg_numval, sizeof(*pkg_types));\r\n  pkg_values = calloc(pkg_numval, sizeof(*pkg_values));\r\n  if ((pkg_types == NULL) || (pkg_values == NULL)) {\r\n    sfree(pkg_types);\r\n    sfree(pkg_values);\r\n    ERROR(\"network plugin: parse_part_values: calloc failed.\");\r\n    return -1;\r\n  }\r\n\r\n  memcpy(pkg_types, buffer, pkg_numval * sizeof(*pkg_types));\r\n  buffer += pkg_numval * sizeof(*pkg_types);\r\n  memcpy(pkg_values, buffer, pkg_numval * sizeof(*pkg_values));\r\n  buffer += pkg_numval * sizeof(*pkg_values);\r\n\r\n  for (size_t i = 0; i < pkg_numval; i++) {\r\n    switch (pkg_types[i]) {\r\n    case DS_TYPE_COUNTER:\r\n      pkg_values[i].counter = (counter_t)ntohll(pkg_values[i].counter);\r\n      break;\r\n\r\n    case DS_TYPE_GAUGE:\r\n      pkg_values[i].gauge = (gauge_t)ntohd(pkg_values[i].gauge);\r\n      break;\r\n\r\n    case DS_TYPE_DERIVE:\r\n      pkg_values[i].derive = (derive_t)ntohll(pkg_values[i].derive);\r\n      break;\r\n\r\n    case DS_TYPE_ABSOLUTE:\r\n      pkg_values[i].absolute = (absolute_t)ntohll(pkg_values[i].absolute);\r\n      break;\r\n\r\n    default:\r\n      NOTICE(\"network plugin: parse_part_values: \"\r\n             \"Don't know how to handle data source type %\" PRIu8,\r\n             pkg_types[i]);\r\n      sfree(pkg_types);\r\n      sfree(pkg_values);\r\n      return -1;\r\n    } /* switch (pkg_types[i]) */\r\n  }\r\n\r\n  *ret_buffer = buffer;\r\n  *ret_buffer_len = buffer_len - pkg_length;\r\n  *ret_num_values = pkg_numval;\r\n  *ret_values = pkg_values;\r\n\r\n  sfree(pkg_types);\r\n\r\n  return 0;\r\n}", ".etwork_dispatch_values": "static int network_dispatch_values(value_list_t *vl, /* {{{ */\r\n                                   const char *username,\r\n                                   struct sockaddr_storage *address) {\r\n  int status;\r\n\r\n  if ((vl->time == 0) || (strlen(vl->host) == 0) || (strlen(vl->plugin) == 0) ||\r\n      (strlen(vl->type) == 0))\r\n    return -EINVAL;\r\n\r\n  if (!check_receive_okay(vl)) {\r\n#if COLLECT_DEBUG\r\n    char name[6 * DATA_MAX_NAME_LEN];\r\n    FORMAT_VL(name, sizeof(name), vl);\r\n    name[sizeof(name) - 1] = '\\0';\r\n    DEBUG(\"network plugin: network_dispatch_values: \"\r\n          \"NOT dispatching %s.\",\r\n          name);\r\n#endif\r\n    stats_values_not_dispatched++;\r\n    return 0;\r\n  }\r\n\r\n  assert(vl->meta == NULL);\r\n\r\n  vl->meta = meta_data_create();\r\n  if (vl->meta == NULL) {\r\n    ERROR(\"network plugin: meta_data_create failed.\");\r\n    return -ENOMEM;\r\n  }\r\n\r\n  status = meta_data_add_boolean(vl->meta, \"network:received\", 1);\r\n  if (status != 0) {\r\n    ERROR(\"network plugin: meta_data_add_boolean failed.\");\r\n    meta_data_destroy(vl->meta);\r\n    vl->meta = NULL;\r\n    return status;\r\n  }\r\n\r\n  if (username != NULL) {\r\n    status = meta_data_add_string(vl->meta, \"network:username\", username);\r\n    if (status != 0) {\r\n      ERROR(\"network plugin: meta_data_add_string failed.\");\r\n      meta_data_destroy(vl->meta);\r\n      vl->meta = NULL;\r\n      return status;\r\n    }\r\n  }\r\n\r\n  if (address != NULL) {\r\n    char host[48];\r\n    size_t len = sizeof(struct sockaddr_storage);\r\n\r\n#ifdef __NetBSD__\r\n    if (address->ss_family == AF_INET) {\r\n      len = sizeof(struct sockaddr_in);\r\n    } else if (address->ss_family == AF_INET6) {\r\n      len = sizeof(struct sockaddr_in6);\r\n    }\r\n#endif\r\n\r\n    status = getnameinfo((struct sockaddr *)address, len, host, sizeof(host),\r\n                         NULL, 0, NI_NUMERICHOST | NI_NUMERICSERV);\r\n    if (status != 0) {\r\n      ERROR(\"network plugin: getnameinfo failed: %s\", gai_strerror(status));\r\n      meta_data_destroy(vl->meta);\r\n      vl->meta = NULL;\r\n      return status;\r\n    }\r\n\r\n    status = meta_data_add_string(vl->meta, \"network:ip_address\", host);\r\n    if (status != 0) {\r\n      ERROR(\"network plugin: meta_data_add_string failed.\");\r\n      meta_data_destroy(vl->meta);\r\n      vl->meta = NULL;\r\n      return status;\r\n    }\r\n  }\r\n\r\n  plugin_dispatch_values(vl);\r\n  stats_values_dispatched++;\r\n\r\n  meta_data_destroy(vl->meta);\r\n  vl->meta = NULL;\r\n\r\n  return 0;\r\n}", ".arse_part_number": "static int parse_part_number(void **ret_buffer, size_t *ret_buffer_len,\r\n                             uint64_t *value) {\r\n  char *buffer = *ret_buffer;\r\n  size_t buffer_len = *ret_buffer_len;\r\n\r\n  uint16_t tmp16;\r\n  uint64_t tmp64;\r\n  size_t exp_size = 2 * sizeof(uint16_t) + sizeof(uint64_t);\r\n\r\n  uint16_t pkg_length;\r\n\r\n  if (buffer_len < exp_size) {\r\n    WARNING(\"network plugin: parse_part_number: \"\r\n            \"Packet too short: \"\r\n            \"Chunk of size %\" PRIsz \" expected, \"\r\n            \"but buffer has only %\" PRIsz \" bytes left.\",\r\n            exp_size, buffer_len);\r\n    return -1;\r\n  }\r\n\r\n  memcpy((void *)&tmp16, buffer, sizeof(tmp16));\r\n  buffer += sizeof(tmp16);\r\n  /* pkg_type = ntohs (tmp16); */\r\n\r\n  memcpy((void *)&tmp16, buffer, sizeof(tmp16));\r\n  buffer += sizeof(tmp16);\r\n  pkg_length = ntohs(tmp16);\r\n\r\n  memcpy((void *)&tmp64, buffer, sizeof(tmp64));\r\n  buffer += sizeof(tmp64);\r\n  *value = ntohll(tmp64);\r\n\r\n  *ret_buffer = buffer;\r\n  *ret_buffer_len = buffer_len - pkg_length;\r\n\r\n  return 0;\r\n}", ".arse_part_string": "static int parse_part_string(void **ret_buffer, size_t *ret_buffer_len,\r\n                             char *output, size_t const output_len) {\r\n  char *buffer = *ret_buffer;\r\n  size_t buffer_len = *ret_buffer_len;\r\n\r\n  uint16_t tmp16;\r\n  size_t const header_size = 2 * sizeof(uint16_t);\r\n\r\n  uint16_t pkg_length;\r\n  size_t payload_size;\r\n\r\n  if (output_len == 0)\r\n    return EINVAL;\r\n\r\n  if (buffer_len < header_size) {\r\n    WARNING(\"network plugin: parse_part_string: \"\r\n            \"Packet too short: \"\r\n            \"Chunk of at least size %\" PRIsz \" expected, \"\r\n            \"but buffer has only %\" PRIsz \" bytes left.\",\r\n            header_size, buffer_len);\r\n    return -1;\r\n  }\r\n\r\n  memcpy((void *)&tmp16, buffer, sizeof(tmp16));\r\n  buffer += sizeof(tmp16);\r\n  /* pkg_type = ntohs (tmp16); */\r\n\r\n  memcpy((void *)&tmp16, buffer, sizeof(tmp16));\r\n  buffer += sizeof(tmp16);\r\n  pkg_length = ntohs(tmp16);\r\n  payload_size = ((size_t)pkg_length) - header_size;\r\n\r\n  /* Check that packet fits in the input buffer */\r\n  if (pkg_length > buffer_len) {\r\n    WARNING(\"network plugin: parse_part_string: \"\r\n            \"Packet too big: \"\r\n            \"Chunk of size %\" PRIu16 \" received, \"\r\n            \"but buffer has only %\" PRIsz \" bytes left.\",\r\n            pkg_length, buffer_len);\r\n    return -1;\r\n  }\r\n\r\n  /* Check that pkg_length is in the valid range */\r\n  if (pkg_length <= header_size) {\r\n    WARNING(\"network plugin: parse_part_string: \"\r\n            \"Packet too short: \"\r\n            \"Header claims this packet is only %hu \"\r\n            \"bytes long.\",\r\n            pkg_length);\r\n    return -1;\r\n  }\r\n\r\n  /* Check that the package data fits into the output buffer.\r\n   * The previous if-statement ensures that:\r\n   * `pkg_length > header_size' */\r\n  if (output_len < payload_size) {\r\n    WARNING(\"network plugin: parse_part_string: \"\r\n            \"Buffer too small: \"\r\n            \"Output buffer holds %\" PRIsz \" bytes, \"\r\n            \"which is too small to hold the received \"\r\n            \"%\" PRIsz \" byte string.\",\r\n            output_len, payload_size);\r\n    return -1;\r\n  }\r\n\r\n  /* All sanity checks successfull, let's copy the data over */\r\n  memcpy((void *)output, (void *)buffer, payload_size);\r\n  buffer += payload_size;\r\n\r\n  /* For some very weird reason '\\0' doesn't do the trick on SPARC in\r\n   * this statement. */\r\n  if (output[payload_size - 1] != 0) {\r\n    WARNING(\"network plugin: parse_part_string: \"\r\n            \"Received string does not end \"\r\n            \"with a NULL-byte.\");\r\n    return -1;\r\n  }\r\n\r\n  *ret_buffer = buffer;\r\n  *ret_buffer_len = buffer_len - pkg_length;\r\n\r\n  return 0;\r\n}", ".etwork_dispatch_notification": "static int network_dispatch_notification(notification_t *n) /* {{{ */\r\n{\r\n  int status;\r\n\r\n  assert(n->meta == NULL);\r\n\r\n  status = plugin_notification_meta_add_boolean(n, \"network:received\", 1);\r\n  if (status != 0) {\r\n    ERROR(\"network plugin: plugin_notification_meta_add_boolean failed.\");\r\n    plugin_notification_meta_free(n->meta);\r\n    n->meta = NULL;\r\n    return status;\r\n  }\r\n\r\n  status = plugin_dispatch_notification(n);\r\n\r\n  plugin_notification_meta_free(n->meta);\r\n  n->meta = NULL;\r\n\r\n  return status;\r\n}", ".ree_sockent_client": "static void free_sockent_client(struct sockent_client *sec) /* {{{ */\r\n{\r\n  if (sec->fd >= 0) {\r\n    close(sec->fd);\r\n    sec->fd = -1;\r\n  }\r\n  sfree(sec->addr);\r\n  sfree(sec->bind_addr);\r\n#if HAVE_GCRYPT_H\r\n  sfree(sec->username);\r\n  sfree(sec->password);\r\n  if (sec->cypher != NULL)\r\n    gcry_cipher_close(sec->cypher);\r\n#endif\r\n}", ".ree_sockent_server": "static void free_sockent_server(struct sockent_server *ses) /* {{{ */\r\n{\r\n  for (size_t i = 0; i < ses->fd_num; i++) {\r\n    if (ses->fd[i] >= 0) {\r\n      close(ses->fd[i]);\r\n      ses->fd[i] = -1;\r\n    }\r\n  }\r\n\r\n  sfree(ses->fd);\r\n#if HAVE_GCRYPT_H\r\n  sfree(ses->auth_file);\r\n  fbh_destroy(ses->userdb);\r\n  if (ses->cypher != NULL)\r\n    gcry_cipher_close(ses->cypher);\r\n#endif\r\n}", ".etwork_init_gcrypt": "static int network_init_gcrypt(void) /* {{{ */\r\n{\r\n  gcry_error_t err;\r\n\r\n  /* http://lists.gnupg.org/pipermail/gcrypt-devel/2003-August/000458.html\r\n   * Because you can't know in a library whether another library has\r\n   * already initialized the library */\r\n  if (gcry_control(GCRYCTL_ANY_INITIALIZATION_P))\r\n    return 0;\r\n\r\n/* http://www.gnupg.org/documentation/manuals/gcrypt/Multi_002dThreading.html\r\n * To ensure thread-safety, it's important to set GCRYCTL_SET_THREAD_CBS\r\n * *before* initalizing Libgcrypt with gcry_check_version(), which itself must\r\n * be called before any other gcry_* function. GCRYCTL_ANY_INITIALIZATION_P\r\n * above doesn't count, as it doesn't implicitly initalize Libgcrypt.\r\n *\r\n * tl;dr: keep all these gry_* statements in this exact order please. */\r\n#if GCRYPT_VERSION_NUMBER < 0x010600\r\n  err = gcry_control(GCRYCTL_SET_THREAD_CBS, &gcry_threads_pthread);\r\n  if (err) {\r\n    ERROR(\"network plugin: gcry_control (GCRYCTL_SET_THREAD_CBS) failed: %s\",\r\n          gcry_strerror(err));\r\n    return -1;\r\n  }\r\n#endif\r\n\r\n  gcry_check_version(NULL);\r\n\r\n  err = gcry_control(GCRYCTL_INIT_SECMEM, 32768);\r\n  if (err) {\r\n    ERROR(\"network plugin: gcry_control (GCRYCTL_INIT_SECMEM) failed: %s\",\r\n          gcry_strerror(err));\r\n    return -1;\r\n  }\r\n\r\n  gcry_control(GCRYCTL_INITIALIZATION_FINISHED);\r\n  return 0;\r\n}", ".ockent_client_connect": "static int sockent_client_connect(sockent_t *se) /* {{{ */\r\n{\r\n  static c_complain_t complaint = C_COMPLAIN_INIT_STATIC;\r\n\r\n  struct sockent_client *client;\r\n  struct addrinfo *ai_list;\r\n  int status;\r\n  bool reconnect = false;\r\n  cdtime_t now;\r\n\r\n  if ((se == NULL) || (se->type != SOCKENT_TYPE_CLIENT))\r\n    return EINVAL;\r\n\r\n  client = &se->data.client;\r\n\r\n  now = cdtime();\r\n  if (client->resolve_interval != 0 && client->next_resolve_reconnect < now) {\r\n    DEBUG(\"network plugin: Reconnecting socket, resolve_interval = %lf, \"\r\n          \"next_resolve_reconnect = %lf\",\r\n          CDTIME_T_TO_DOUBLE(client->resolve_interval),\r\n          CDTIME_T_TO_DOUBLE(client->next_resolve_reconnect));\r\n    reconnect = true;\r\n  }\r\n\r\n  if (client->fd >= 0 && !reconnect) /* already connected and not stale*/\r\n    return 0;\r\n\r\n  struct addrinfo ai_hints = {.ai_family = AF_UNSPEC,\r\n                              .ai_flags = AI_ADDRCONFIG,\r\n                              .ai_protocol = IPPROTO_UDP,\r\n                              .ai_socktype = SOCK_DGRAM};\r\n\r\n  status = getaddrinfo(se->node,\r\n                       (se->service != NULL) ? se->service : NET_DEFAULT_PORT,\r\n                       &ai_hints, &ai_list);\r\n  if (status != 0) {\r\n    c_complain(\r\n        LOG_ERR, &complaint, \"network plugin: getaddrinfo (%s, %s) failed: %s\",\r\n        (se->node == NULL) ? \"(null)\" : se->node,\r\n        (se->service == NULL) ? \"(null)\" : se->service, gai_strerror(status));\r\n    return -1;\r\n  } else {\r\n    c_release(LOG_NOTICE, &complaint,\r\n              \"network plugin: Successfully resolved \\\"%s\\\".\", se->node);\r\n  }\r\n\r\n  for (struct addrinfo *ai_ptr = ai_list; ai_ptr != NULL;\r\n       ai_ptr = ai_ptr->ai_next) {\r\n    if (client->fd >= 0) /* when we reconnect */\r\n      sockent_client_disconnect(se);\r\n\r\n    client->fd =\r\n        socket(ai_ptr->ai_family, ai_ptr->ai_socktype, ai_ptr->ai_protocol);\r\n    if (client->fd < 0) {\r\n      ERROR(\"network plugin: socket(2) failed: %s\", STRERRNO);\r\n      continue;\r\n    }\r\n\r\n    client->addr = calloc(1, sizeof(*client->addr));\r\n    if (client->addr == NULL) {\r\n      ERROR(\"network plugin: calloc failed.\");\r\n      close(client->fd);\r\n      client->fd = -1;\r\n      continue;\r\n    }\r\n    DEBUG(\"network plugin: alloc (se = %p, addr = %p);\", (void *)se,\r\n          (void *)client->addr);\r\n\r\n    assert(sizeof(*client->addr) >= ai_ptr->ai_addrlen);\r\n    memcpy(client->addr, ai_ptr->ai_addr, ai_ptr->ai_addrlen);\r\n    client->addrlen = ai_ptr->ai_addrlen;\r\n\r\n    network_set_ttl(se, ai_ptr);\r\n    network_set_interface(se, ai_ptr);\r\n    network_bind_socket_to_addr(se, ai_ptr);\r\n\r\n    /* We don't open more than one write-socket per\r\n     * node/service pair.. */\r\n    break;\r\n  }\r\n\r\n  freeaddrinfo(ai_list);\r\n  if (client->fd < 0)\r\n    return -1;\r\n\r\n  if (client->resolve_interval > 0)\r\n    client->next_resolve_reconnect = now + client->resolve_interval;\r\n  return 0;\r\n}", ".ockent_client_disconnect": "static int sockent_client_disconnect(sockent_t *se) /* {{{ */\r\n{\r\n  struct sockent_client *client;\r\n\r\n  if ((se == NULL) || (se->type != SOCKENT_TYPE_CLIENT))\r\n    return EINVAL;\r\n\r\n  client = &se->data.client;\r\n  if (client->fd >= 0) /* connected */\r\n  {\r\n    close(client->fd);\r\n    client->fd = -1;\r\n  }\r\n\r\n  DEBUG(\"network plugin: free (se = %p, addr = %p);\", (void *)se,\r\n        (void *)client->addr);\r\n  sfree(client->addr);\r\n  client->addrlen = 0;\r\n\r\n  return 0;\r\n}", ".etwork_send_buffer_plain": "static void network_send_buffer_plain(sockent_t *se, /* {{{ */\r\n                                      const char *buffer, size_t buffer_size) {\r\n  int status;\r\n\r\n  while (42) {\r\n    status = sockent_client_connect(se);\r\n    if (status != 0)\r\n      return;\r\n\r\n    status = sendto(se->data.client.fd, buffer, buffer_size,\r\n                    /* flags = */ 0, (struct sockaddr *)se->data.client.addr,\r\n                    se->data.client.addrlen);\r\n    if (status < 0) {\r\n      if ((errno == EINTR) || (errno == EAGAIN))\r\n        continue;\r\n\r\n      ERROR(\"network plugin: sendto failed: %s. Closing sending socket.\",\r\n            STRERRNO);\r\n      sockent_client_disconnect(se);\r\n      return;\r\n    }\r\n\r\n    break;\r\n  } /* while (42) */\r\n}", ".rite_part_string": "static int write_part_string(char **ret_buffer, size_t *ret_buffer_len,\r\n                             int type, const char *str, size_t str_len) {\r\n  char *buffer;\r\n  size_t buffer_len;\r\n\r\n  uint16_t pkg_type;\r\n  uint16_t pkg_length;\r\n\r\n  size_t offset;\r\n\r\n  buffer_len = 2 * sizeof(uint16_t) + str_len + 1;\r\n  if (*ret_buffer_len < buffer_len)\r\n    return -1;\r\n\r\n  pkg_type = htons(type);\r\n  pkg_length = htons(buffer_len);\r\n\r\n  buffer = *ret_buffer;\r\n  offset = 0;\r\n  memcpy(buffer + offset, (void *)&pkg_type, sizeof(pkg_type));\r\n  offset += sizeof(pkg_type);\r\n  memcpy(buffer + offset, (void *)&pkg_length, sizeof(pkg_length));\r\n  offset += sizeof(pkg_length);\r\n  memcpy(buffer + offset, str, str_len);\r\n  offset += str_len;\r\n  memset(buffer + offset, '\\0', 1);\r\n  offset += 1;\r\n\r\n  assert(offset == buffer_len);\r\n\r\n  *ret_buffer = buffer + buffer_len;\r\n  *ret_buffer_len -= buffer_len;\r\n\r\n  return 0;\r\n}", ".rite_part_number": "static int write_part_number(char **ret_buffer, size_t *ret_buffer_len,\r\n                             int type, uint64_t value) {\r\n  char *packet_ptr;\r\n  size_t packet_len;\r\n\r\n  part_header_t pkg_head;\r\n  uint64_t pkg_value;\r\n\r\n  size_t offset;\r\n\r\n  packet_len = sizeof(pkg_head) + sizeof(pkg_value);\r\n\r\n  if (*ret_buffer_len < packet_len)\r\n    return -1;\r\n\r\n  pkg_head.type = htons(type);\r\n  pkg_head.length = htons(packet_len);\r\n  pkg_value = htonll(value);\r\n\r\n  packet_ptr = *ret_buffer;\r\n  offset = 0;\r\n  memcpy(packet_ptr + offset, &pkg_head, sizeof(pkg_head));\r\n  offset += sizeof(pkg_head);\r\n  memcpy(packet_ptr + offset, &pkg_value, sizeof(pkg_value));\r\n  offset += sizeof(pkg_value);\r\n\r\n  assert(offset == packet_len);\r\n\r\n  *ret_buffer = packet_ptr + packet_len;\r\n  *ret_buffer_len -= packet_len;\r\n\r\n  return 0;\r\n}", ".rite_part_values": "static int write_part_values(char **ret_buffer, size_t *ret_buffer_len,\r\n                             const data_set_t *ds, const value_list_t *vl) {\r\n  char *packet_ptr;\r\n  size_t packet_len;\r\n  int num_values;\r\n\r\n  part_header_t pkg_ph;\r\n  uint16_t pkg_num_values;\r\n  uint8_t *pkg_values_types;\r\n  value_t *pkg_values;\r\n\r\n  size_t offset;\r\n\r\n  num_values = vl->values_len;\r\n  packet_len = sizeof(part_header_t) + sizeof(uint16_t) +\r\n               (num_values * sizeof(uint8_t)) + (num_values * sizeof(value_t));\r\n\r\n  if (*ret_buffer_len < packet_len)\r\n    return -1;\r\n\r\n  pkg_values_types = malloc(num_values * sizeof(*pkg_values_types));\r\n  if (pkg_values_types == NULL) {\r\n    ERROR(\"network plugin: write_part_values: malloc failed.\");\r\n    return -1;\r\n  }\r\n\r\n  pkg_values = malloc(num_values * sizeof(*pkg_values));\r\n  if (pkg_values == NULL) {\r\n    free(pkg_values_types);\r\n    ERROR(\"network plugin: write_part_values: malloc failed.\");\r\n    return -1;\r\n  }\r\n\r\n  pkg_ph.type = htons(TYPE_VALUES);\r\n  pkg_ph.length = htons(packet_len);\r\n\r\n  pkg_num_values = htons((uint16_t)vl->values_len);\r\n\r\n  for (int i = 0; i < num_values; i++) {\r\n    pkg_values_types[i] = (uint8_t)ds->ds[i].type;\r\n    switch (ds->ds[i].type) {\r\n    case DS_TYPE_COUNTER:\r\n      pkg_values[i].counter = htonll(vl->values[i].counter);\r\n      break;\r\n\r\n    case DS_TYPE_GAUGE:\r\n      pkg_values[i].gauge = htond(vl->values[i].gauge);\r\n      break;\r\n\r\n    case DS_TYPE_DERIVE:\r\n      pkg_values[i].derive = htonll(vl->values[i].derive);\r\n      break;\r\n\r\n    case DS_TYPE_ABSOLUTE:\r\n      pkg_values[i].absolute = htonll(vl->values[i].absolute);\r\n      break;\r\n\r\n    default:\r\n      free(pkg_values_types);\r\n      free(pkg_values);\r\n      ERROR(\"network plugin: write_part_values: \"\r\n            \"Unknown data source type: %i\",\r\n            ds->ds[i].type);\r\n      return -1;\r\n    } /* switch (ds->ds[i].type) */\r\n  }   /* for (num_values) */\r\n\r\n  /*\r\n   * Use `memcpy' to write everything to the buffer, because the pointer\r\n   * may be unaligned and some architectures, such as SPARC, can't handle\r\n   * that.\r\n   */\r\n  packet_ptr = *ret_buffer;\r\n  offset = 0;\r\n  memcpy(packet_ptr + offset, &pkg_ph, sizeof(pkg_ph));\r\n  offset += sizeof(pkg_ph);\r\n  memcpy(packet_ptr + offset, &pkg_num_values, sizeof(pkg_num_values));\r\n  offset += sizeof(pkg_num_values);\r\n  memcpy(packet_ptr + offset, pkg_values_types, num_values * sizeof(uint8_t));\r\n  offset += num_values * sizeof(uint8_t);\r\n  memcpy(packet_ptr + offset, pkg_values, num_values * sizeof(value_t));\r\n  offset += num_values * sizeof(value_t);\r\n\r\n  assert(offset == packet_len);\r\n\r\n  *ret_buffer = packet_ptr + packet_len;\r\n  *ret_buffer_len -= packet_len;\r\n\r\n  free(pkg_values_types);\r\n  free(pkg_values);\r\n\r\n  return 0;\r\n}", ".etwork_send_buffer": "static void network_send_buffer(char *buffer, size_t buffer_len) /* {{{ */\r\n{\r\n  DEBUG(\"network plugin: network_send_buffer: buffer_len = %\" PRIsz,\r\n        buffer_len);\r\n\r\n  for (sockent_t *se = sending_sockets; se != NULL; se = se->next) {\r\n    pthread_mutex_lock(&se->lock);\r\n#if HAVE_GCRYPT_H\r\n    if (se->data.client.security_level == SECURITY_LEVEL_ENCRYPT)\r\n      network_send_buffer_encrypted(se, buffer, buffer_len);\r\n    else if (se->data.client.security_level == SECURITY_LEVEL_SIGN)\r\n      network_send_buffer_signed(se, buffer, buffer_len);\r\n    else /* if (se->data.client.security_level == SECURITY_LEVEL_NONE) */\r\n#endif   /* HAVE_GCRYPT_H */\r\n      network_send_buffer_plain(se, buffer, buffer_len);\r\n    pthread_mutex_unlock(&se->lock);\r\n  } /* for (sending_sockets) */\r\n}", ".etwork_init_buffer": "static void network_init_buffer(void) {\r\n  memset(send_buffer, 0, network_config_packet_size);\r\n  send_buffer_ptr = send_buffer;\r\n  send_buffer_fill = 0;\r\n  send_buffer_last_update = 0;\r\n\r\n  memset(&send_buffer_vl, 0, sizeof(send_buffer_vl));\r\n}", ".heck_send_okay": "static bool check_send_okay(const value_list_t *vl) /* {{{ */\r\n{\r\n  bool received = 0;\r\n  int status;\r\n\r\n  if (network_config_forward)\r\n    return 1;\r\n\r\n  if (vl->meta == NULL)\r\n    return 1;\r\n\r\n  status = meta_data_get_boolean(vl->meta, \"network:received\", &received);\r\n  if (status == -ENOENT)\r\n    return 1;\r\n  else if (status != 0) {\r\n    ERROR(\"network plugin: check_send_okay: meta_data_get_boolean failed \"\r\n          \"with status %i.\",\r\n          status);\r\n    return 1;\r\n  }\r\n\r\n  /* By default, only *send* value lists that were not *received* by the\r\n   * network plugin. */\r\n  return !received;\r\n}", ".dd_to_buffer": "static int add_to_buffer(char *buffer, size_t buffer_size, /* {{{ */\r\n                         value_list_t *vl_def, const data_set_t *ds,\r\n                         const value_list_t *vl) {\r\n  char *buffer_orig = buffer;\r\n\r\n  if (strcmp(vl_def->host, vl->host) != 0) {\r\n    if (write_part_string(&buffer, &buffer_size, TYPE_HOST, vl->host,\r\n                          strlen(vl->host)) != 0)\r\n      return -1;\r\n    sstrncpy(vl_def->host, vl->host, sizeof(vl_def->host));\r\n  }\r\n\r\n  if (vl_def->time != vl->time) {\r\n    if (write_part_number(&buffer, &buffer_size, TYPE_TIME_HR,\r\n                          (uint64_t)vl->time))\r\n      return -1;\r\n    vl_def->time = vl->time;\r\n  }\r\n\r\n  if (vl_def->interval != vl->interval) {\r\n    if (write_part_number(&buffer, &buffer_size, TYPE_INTERVAL_HR,\r\n                          (uint64_t)vl->interval))\r\n      return -1;\r\n    vl_def->interval = vl->interval;\r\n  }\r\n\r\n  if (strcmp(vl_def->plugin, vl->plugin) != 0) {\r\n    if (write_part_string(&buffer, &buffer_size, TYPE_PLUGIN, vl->plugin,\r\n                          strlen(vl->plugin)) != 0)\r\n      return -1;\r\n    sstrncpy(vl_def->plugin, vl->plugin, sizeof(vl_def->plugin));\r\n  }\r\n\r\n  if (strcmp(vl_def->plugin_instance, vl->plugin_instance) != 0) {\r\n    if (write_part_string(&buffer, &buffer_size, TYPE_PLUGIN_INSTANCE,\r\n                          vl->plugin_instance,\r\n                          strlen(vl->plugin_instance)) != 0)\r\n      return -1;\r\n    sstrncpy(vl_def->plugin_instance, vl->plugin_instance,\r\n             sizeof(vl_def->plugin_instance));\r\n  }\r\n\r\n  if (strcmp(vl_def->type, vl->type) != 0) {\r\n    if (write_part_string(&buffer, &buffer_size, TYPE_TYPE, vl->type,\r\n                          strlen(vl->type)) != 0)\r\n      return -1;\r\n    sstrncpy(vl_def->type, ds->type, sizeof(vl_def->type));\r\n  }\r\n\r\n  if (strcmp(vl_def->type_instance, vl->type_instance) != 0) {\r\n    if (write_part_string(&buffer, &buffer_size, TYPE_TYPE_INSTANCE,\r\n                          vl->type_instance, strlen(vl->type_instance)) != 0)\r\n      return -1;\r\n    sstrncpy(vl_def->type_instance, vl->type_instance,\r\n             sizeof(vl_def->type_instance));\r\n  }\r\n\r\n  if (write_part_values(&buffer, &buffer_size, ds, vl) != 0)\r\n    return -1;\r\n\r\n  return buffer - buffer_orig;\r\n}", ".lush_buffer": "static void flush_buffer(void) {\r\n  DEBUG(\"network plugin: flush_buffer: send_buffer_fill = %i\",\r\n        send_buffer_fill);\r\n\r\n  network_send_buffer(send_buffer, (size_t)send_buffer_fill);\r\n\r\n  stats_octets_tx += ((uint64_t)send_buffer_fill);\r\n  stats_packets_tx++;\r\n\r\n  network_init_buffer();\r\n}", ".ockent_destroy": "static void sockent_destroy(sockent_t *se) /* {{{ */\r\n{\r\n  sockent_t *next;\r\n\r\n  DEBUG(\"network plugin: sockent_destroy (se = %p);\", (void *)se);\r\n\r\n  while (se != NULL) {\r\n    next = se->next;\r\n\r\n    sfree(se->node);\r\n    sfree(se->service);\r\n    pthread_mutex_destroy(&se->lock);\r\n\r\n    if (se->type == SOCKENT_TYPE_CLIENT)\r\n      free_sockent_client(&se->data.client);\r\n    else\r\n      free_sockent_server(&se->data.server);\r\n\r\n    sfree(se);\r\n    se = next;\r\n  }\r\n}", ".ockent_init_crypto": "static int sockent_init_crypto(sockent_t *se) /* {{{ */\r\n{\r\n#if HAVE_GCRYPT_H /* {{{ */\r\n  if (se->type == SOCKENT_TYPE_CLIENT) {\r\n    if (se->data.client.security_level > SECURITY_LEVEL_NONE) {\r\n      if (network_init_gcrypt() < 0) {\r\n        ERROR(\"network plugin: Cannot configure client socket with \"\r\n              \"security: Failed to initialize crypto library.\");\r\n        return -1;\r\n      }\r\n\r\n      if ((se->data.client.username == NULL) ||\r\n          (se->data.client.password == NULL)) {\r\n        ERROR(\"network plugin: Client socket with \"\r\n              \"security requested, but no \"\r\n              \"credentials are configured.\");\r\n        return -1;\r\n      }\r\n      gcry_md_hash_buffer(GCRY_MD_SHA256, se->data.client.password_hash,\r\n                          se->data.client.password,\r\n                          strlen(se->data.client.password));\r\n    }\r\n  } else /* (se->type == SOCKENT_TYPE_SERVER) */\r\n  {\r\n    if ((se->data.server.security_level > SECURITY_LEVEL_NONE) &&\r\n        (se->data.server.auth_file == NULL)) {\r\n      ERROR(\"network plugin: Server socket with security requested, \"\r\n            \"but no \\\"AuthFile\\\" is configured.\");\r\n      return -1;\r\n    }\r\n    if (se->data.server.auth_file != NULL) {\r\n      if (network_init_gcrypt() < 0) {\r\n        ERROR(\"network plugin: Cannot configure server socket with security: \"\r\n              \"Failed to initialize crypto library.\");\r\n        return -1;\r\n      }\r\n\r\n      se->data.server.userdb = fbh_create(se->data.server.auth_file);\r\n      if (se->data.server.userdb == NULL) {\r\n        ERROR(\"network plugin: Reading password file \\\"%s\\\" failed.\",\r\n              se->data.server.auth_file);\r\n        return -1;\r\n      }\r\n    }\r\n  }\r\n#endif /* }}} HAVE_GCRYPT_H */\r\n\r\n  return 0;\r\n}", ".ockent_server_listen": "static int sockent_server_listen(sockent_t *se) /* {{{ */\r\n{\r\n  struct addrinfo *ai_list;\r\n  int status;\r\n\r\n  const char *node;\r\n  const char *service;\r\n\r\n  if (se == NULL)\r\n    return -1;\r\n\r\n  assert(se->data.server.fd == NULL);\r\n  assert(se->data.server.fd_num == 0);\r\n\r\n  node = se->node;\r\n  service = se->service;\r\n\r\n  if (service == NULL)\r\n    service = NET_DEFAULT_PORT;\r\n\r\n  DEBUG(\"network plugin: sockent_server_listen: node = %s; service = %s;\", node,\r\n        service);\r\n\r\n  struct addrinfo ai_hints = {.ai_family = AF_UNSPEC,\r\n                              .ai_flags = AI_ADDRCONFIG | AI_PASSIVE,\r\n                              .ai_protocol = IPPROTO_UDP,\r\n                              .ai_socktype = SOCK_DGRAM};\r\n\r\n  status = getaddrinfo(node, service, &ai_hints, &ai_list);\r\n  if (status != 0) {\r\n    ERROR(\"network plugin: getaddrinfo (%s, %s) failed: %s\",\r\n          (se->node == NULL) ? \"(null)\" : se->node,\r\n          (se->service == NULL) ? \"(null)\" : se->service, gai_strerror(status));\r\n    return -1;\r\n  }\r\n\r\n  for (struct addrinfo *ai_ptr = ai_list; ai_ptr != NULL;\r\n       ai_ptr = ai_ptr->ai_next) {\r\n    int *tmp;\r\n\r\n    tmp = realloc(se->data.server.fd,\r\n                  sizeof(*tmp) * (se->data.server.fd_num + 1));\r\n    if (tmp == NULL) {\r\n      ERROR(\"network plugin: realloc failed.\");\r\n      continue;\r\n    }\r\n    se->data.server.fd = tmp;\r\n    tmp = se->data.server.fd + se->data.server.fd_num;\r\n\r\n    *tmp = socket(ai_ptr->ai_family, ai_ptr->ai_socktype, ai_ptr->ai_protocol);\r\n    if (*tmp < 0) {\r\n      ERROR(\"network plugin: socket(2) failed: %s\", STRERRNO);\r\n      continue;\r\n    }\r\n\r\n    status = network_bind_socket(*tmp, ai_ptr, se->interface);\r\n    if (status != 0) {\r\n      close(*tmp);\r\n      *tmp = -1;\r\n      continue;\r\n    }\r\n\r\n    se->data.server.fd_num++;\r\n    continue;\r\n  } /* for (ai_list) */\r\n\r\n  freeaddrinfo(ai_list);\r\n\r\n  if (se->data.server.fd_num == 0)\r\n    return -1;\r\n  return 0;\r\n}", ".ockent_add": "static int sockent_add(sockent_t *se) /* {{{ */\r\n{\r\n  sockent_t *last_ptr;\r\n\r\n  if (se == NULL)\r\n    return -1;\r\n\r\n  if (se->type == SOCKENT_TYPE_SERVER) {\r\n    struct pollfd *tmp;\r\n\r\n    tmp = realloc(listen_sockets_pollfd,\r\n                  sizeof(*tmp) * (listen_sockets_num + se->data.server.fd_num));\r\n    if (tmp == NULL) {\r\n      ERROR(\"network plugin: realloc failed.\");\r\n      return -1;\r\n    }\r\n    listen_sockets_pollfd = tmp;\r\n    tmp = listen_sockets_pollfd + listen_sockets_num;\r\n\r\n    for (size_t i = 0; i < se->data.server.fd_num; i++) {\r\n      memset(tmp + i, 0, sizeof(*tmp));\r\n      tmp[i].fd = se->data.server.fd[i];\r\n      tmp[i].events = POLLIN | POLLPRI;\r\n      tmp[i].revents = 0;\r\n    }\r\n\r\n    listen_sockets_num += se->data.server.fd_num;\r\n\r\n    if (listen_sockets == NULL) {\r\n      listen_sockets = se;\r\n      return 0;\r\n    }\r\n    last_ptr = listen_sockets;\r\n  } else /* if (se->type == SOCKENT_TYPE_CLIENT) */\r\n  {\r\n    if (sending_sockets == NULL) {\r\n      sending_sockets = se;\r\n      return 0;\r\n    }\r\n    last_ptr = sending_sockets;\r\n  }\r\n\r\n  while (last_ptr->next != NULL)\r\n    last_ptr = last_ptr->next;\r\n  last_ptr->next = se;\r\n\r\n  return 0;\r\n}", ".heck_send_notify_okay": "static bool check_send_notify_okay(const notification_t *n) /* {{{ */\r\n{\r\n  static c_complain_t complain_forwarding = C_COMPLAIN_INIT_STATIC;\r\n  bool received = 0;\r\n\r\n  if (n->meta == NULL)\r\n    return 1;\r\n\r\n  received = check_notify_received(n);\r\n\r\n  if (network_config_forward && received) {\r\n    c_complain_once(\r\n        LOG_ERR, &complain_forwarding,\r\n        \"network plugin: A notification has been received via the network \"\r\n        \"and forwarding is enabled. Forwarding of notifications is currently \"\r\n        \"not supported, because there is not loop-detection available. \"\r\n        \"Please contact the collectd mailing list if you need this \"\r\n        \"feature.\");\r\n  }\r\n\r\n  /* By default, only *send* value lists that were not *received* by the\r\n   * network plugin. */\r\n  return !received;\r\n}", ".etwork_stats_read": "static int network_stats_read(void) /* {{{ */\r\n{\r\n  derive_t copy_octets_rx;\r\n  derive_t copy_octets_tx;\r\n  derive_t copy_packets_rx;\r\n  derive_t copy_packets_tx;\r\n  derive_t copy_values_dispatched;\r\n  derive_t copy_values_not_dispatched;\r\n  derive_t copy_values_sent;\r\n  derive_t copy_values_not_sent;\r\n  derive_t copy_receive_list_length;\r\n  value_list_t vl = VALUE_LIST_INIT;\r\n  value_t values[2];\r\n\r\n  copy_octets_rx = stats_octets_rx;\r\n  copy_octets_tx = stats_octets_tx;\r\n  copy_packets_rx = stats_packets_rx;\r\n  copy_packets_tx = stats_packets_tx;\r\n  copy_values_dispatched = stats_values_dispatched;\r\n  copy_values_not_dispatched = stats_values_not_dispatched;\r\n  copy_values_sent = stats_values_sent;\r\n  copy_values_not_sent = stats_values_not_sent;\r\n  copy_receive_list_length = receive_list_length;\r\n\r\n  /* Initialize `vl' */\r\n  vl.values = values;\r\n  vl.values_len = 2;\r\n  vl.time = 0;\r\n  sstrncpy(vl.plugin, \"network\", sizeof(vl.plugin));\r\n\r\n  /* Octets received / sent */\r\n  vl.values[0].derive = (derive_t)copy_octets_rx;\r\n  vl.values[1].derive = (derive_t)copy_octets_tx;\r\n  sstrncpy(vl.type, \"if_octets\", sizeof(vl.type));\r\n  plugin_dispatch_values(&vl);\r\n\r\n  /* Packets received / send */\r\n  vl.values[0].derive = (derive_t)copy_packets_rx;\r\n  vl.values[1].derive = (derive_t)copy_packets_tx;\r\n  sstrncpy(vl.type, \"if_packets\", sizeof(vl.type));\r\n  plugin_dispatch_values(&vl);\r\n\r\n  /* Values (not) dispatched and (not) send */\r\n  sstrncpy(vl.type, \"total_values\", sizeof(vl.type));\r\n  vl.values_len = 1;\r\n\r\n  vl.values[0].derive = (derive_t)copy_values_dispatched;\r\n  sstrncpy(vl.type_instance, \"dispatch-accepted\", sizeof(vl.type_instance));\r\n  plugin_dispatch_values(&vl);\r\n\r\n  vl.values[0].derive = (derive_t)copy_values_not_dispatched;\r\n  sstrncpy(vl.type_instance, \"dispatch-rejected\", sizeof(vl.type_instance));\r\n  plugin_dispatch_values(&vl);\r\n\r\n  vl.values[0].derive = (derive_t)copy_values_sent;\r\n  sstrncpy(vl.type_instance, \"send-accepted\", sizeof(vl.type_instance));\r\n  plugin_dispatch_values(&vl);\r\n\r\n  vl.values[0].derive = (derive_t)copy_values_not_sent;\r\n  sstrncpy(vl.type_instance, \"send-rejected\", sizeof(vl.type_instance));\r\n  plugin_dispatch_values(&vl);\r\n\r\n  /* Receive queue length */\r\n  vl.values[0].gauge = (gauge_t)copy_receive_list_length;\r\n  sstrncpy(vl.type, \"queue_length\", sizeof(vl.type));\r\n  vl.type_instance[0] = 0;\r\n  plugin_dispatch_values(&vl);\r\n\r\n  return 0;\r\n}", ".etwork_shutdown": "static int network_shutdown(void) {\r\n  listen_loop++;\r\n\r\n  /* Kill the listening thread */\r\n  if (receive_thread_running != 0) {\r\n    INFO(\"network plugin: Stopping receive thread.\");\r\n    pthread_kill(receive_thread_id, SIGTERM);\r\n    pthread_join(receive_thread_id, NULL /* no return value */);\r\n    memset(&receive_thread_id, 0, sizeof(receive_thread_id));\r\n    receive_thread_running = 0;\r\n  }\r\n\r\n  /* Shutdown the dispatching thread */\r\n  if (dispatch_thread_running != 0) {\r\n    INFO(\"network plugin: Stopping dispatch thread.\");\r\n    pthread_mutex_lock(&receive_list_lock);\r\n    pthread_cond_broadcast(&receive_list_cond);\r\n    pthread_mutex_unlock(&receive_list_lock);\r\n    pthread_join(dispatch_thread_id, /* ret = */ NULL);\r\n    dispatch_thread_running = 0;\r\n  }\r\n\r\n  sockent_destroy(listen_sockets);\r\n\r\n  if (send_buffer_fill > 0)\r\n    flush_buffer();\r\n\r\n  sfree(send_buffer);\r\n\r\n  for (sockent_t *se = sending_sockets; se != NULL; se = se->next)\r\n    sockent_client_disconnect(se);\r\n  sockent_destroy(sending_sockets);\r\n\r\n  plugin_unregister_config(\"network\");\r\n  plugin_unregister_init(\"network\");\r\n  plugin_unregister_write(\"network\");\r\n  plugin_unregister_shutdown(\"network\");\r\n\r\n  return 0;\r\n}", ".etwork_write": "static int network_write(const data_set_t *ds, const value_list_t *vl,\r\n                         user_data_t __attribute__((unused)) * user_data) {\r\n  int status;\r\n\r\n  /* listen_loop is set to non-zero in the shutdown callback, which is\r\n   * guaranteed to be called *after* all the write threads have been shut\r\n   * down. */\r\n  assert(listen_loop == 0);\r\n\r\n  if (!check_send_okay(vl)) {\r\n#if COLLECT_DEBUG\r\n    char name[6 * DATA_MAX_NAME_LEN];\r\n    FORMAT_VL(name, sizeof(name), vl);\r\n    name[sizeof(name) - 1] = '\\0';\r\n    DEBUG(\"network plugin: network_write: \"\r\n          \"NOT sending %s.\",\r\n          name);\r\n#endif\r\n    /* Counter is not protected by another lock and may be reached by\r\n     * multiple threads */\r\n    pthread_mutex_lock(&stats_lock);\r\n    stats_values_not_sent++;\r\n    pthread_mutex_unlock(&stats_lock);\r\n    return 0;\r\n  }\r\n\r\n  uc_meta_data_add_unsigned_int(vl, \"network:time_sent\", (uint64_t)vl->time);\r\n\r\n  pthread_mutex_lock(&send_buffer_lock);\r\n\r\n  status = add_to_buffer(send_buffer_ptr,\r\n                         network_config_packet_size -\r\n                             (send_buffer_fill + BUFF_SIG_SIZE),\r\n                         &send_buffer_vl, ds, vl);\r\n  if (status >= 0) {\r\n    /* status == bytes added to the buffer */\r\n    send_buffer_fill += status;\r\n    send_buffer_ptr += status;\r\n    send_buffer_last_update = cdtime();\r\n\r\n    stats_values_sent++;\r\n  } else {\r\n    flush_buffer();\r\n\r\n    status = add_to_buffer(send_buffer_ptr,\r\n                           network_config_packet_size -\r\n                               (send_buffer_fill + BUFF_SIG_SIZE),\r\n                           &send_buffer_vl, ds, vl);\r\n\r\n    if (status >= 0) {\r\n      send_buffer_fill += status;\r\n      send_buffer_ptr += status;\r\n\r\n      stats_values_sent++;\r\n    }\r\n  }\r\n\r\n  if (status < 0) {\r\n    ERROR(\"network plugin: Unable to append to the \"\r\n          \"buffer for some weird reason\");\r\n  } else if ((network_config_packet_size - send_buffer_fill) < 15) {\r\n    flush_buffer();\r\n  }\r\n\r\n  pthread_mutex_unlock(&send_buffer_lock);\r\n\r\n  return (status < 0) ? -1 : 0;\r\n}", ".etwork_notification": "static int network_notification(const notification_t *n,\r\n                                user_data_t __attribute__((unused)) *\r\n                                    user_data) {\r\n  char buffer[network_config_packet_size];\r\n  char *buffer_ptr = buffer;\r\n  size_t buffer_free = sizeof(buffer);\r\n  int status;\r\n\r\n  if (!check_send_notify_okay(n))\r\n    return 0;\r\n\r\n  memset(buffer, 0, sizeof(buffer));\r\n\r\n  status = write_part_number(&buffer_ptr, &buffer_free, TYPE_TIME_HR,\r\n                             (uint64_t)n->time);\r\n  if (status != 0)\r\n    return -1;\r\n\r\n  status = write_part_number(&buffer_ptr, &buffer_free, TYPE_SEVERITY,\r\n                             (uint64_t)n->severity);\r\n  if (status != 0)\r\n    return -1;\r\n\r\n  if (strlen(n->host) > 0) {\r\n    status = write_part_string(&buffer_ptr, &buffer_free, TYPE_HOST, n->host,\r\n                               strlen(n->host));\r\n    if (status != 0)\r\n      return -1;\r\n  }\r\n\r\n  if (strlen(n->plugin) > 0) {\r\n    status = write_part_string(&buffer_ptr, &buffer_free, TYPE_PLUGIN,\r\n                               n->plugin, strlen(n->plugin));\r\n    if (status != 0)\r\n      return -1;\r\n  }\r\n\r\n  if (strlen(n->plugin_instance) > 0) {\r\n    status = write_part_string(&buffer_ptr, &buffer_free, TYPE_PLUGIN_INSTANCE,\r\n                               n->plugin_instance, strlen(n->plugin_instance));\r\n    if (status != 0)\r\n      return -1;\r\n  }\r\n\r\n  if (strlen(n->type) > 0) {\r\n    status = write_part_string(&buffer_ptr, &buffer_free, TYPE_TYPE, n->type,\r\n                               strlen(n->type));\r\n    if (status != 0)\r\n      return -1;\r\n  }\r\n\r\n  if (strlen(n->type_instance) > 0) {\r\n    status = write_part_string(&buffer_ptr, &buffer_free, TYPE_TYPE_INSTANCE,\r\n                               n->type_instance, strlen(n->type_instance));\r\n    if (status != 0)\r\n      return -1;\r\n  }\r\n\r\n  status = write_part_string(&buffer_ptr, &buffer_free, TYPE_MESSAGE,\r\n                             n->message, strlen(n->message));\r\n  if (status != 0)\r\n    return -1;\r\n\r\n  network_send_buffer(buffer, sizeof(buffer) - buffer_free);\r\n\r\n  return 0;\r\n}", ".etwork_config": "static int network_config(oconfig_item_t *ci) /* {{{ */\r\n{\r\n  /* The options need to be applied first */\r\n  for (int i = 0; i < ci->children_num; i++) {\r\n    oconfig_item_t *child = ci->children + i;\r\n    if (strcasecmp(\"TimeToLive\", child->key) == 0)\r\n      network_config_set_ttl(child);\r\n  }\r\n\r\n  for (int i = 0; i < ci->children_num; i++) {\r\n    oconfig_item_t *child = ci->children + i;\r\n\r\n    if (strcasecmp(\"Listen\", child->key) == 0)\r\n      network_config_add_listen(child);\r\n    else if (strcasecmp(\"Server\", child->key) == 0)\r\n      network_config_add_server(child);\r\n    else if (strcasecmp(\"TimeToLive\", child->key) == 0) {\r\n      /* Handled earlier */\r\n    } else if (strcasecmp(\"MaxPacketSize\", child->key) == 0)\r\n      network_config_set_buffer_size(child);\r\n    else if (strcasecmp(\"Forward\", child->key) == 0)\r\n      cf_util_get_boolean(child, &network_config_forward);\r\n    else if (strcasecmp(\"ReportStats\", child->key) == 0)\r\n      cf_util_get_boolean(child, &network_config_stats);\r\n    else {\r\n      WARNING(\"network plugin: Option `%s' is not allowed here.\", child->key);\r\n    }\r\n  }\r\n\r\n  return 0;\r\n}", ".etwork_init": "static int network_init(void) {\r\n  static bool have_init;\r\n\r\n  /* Check if we were already initialized. If so, just return - there's\r\n   * nothing more to do (for now, that is). */\r\n  if (have_init)\r\n    return 0;\r\n  have_init = true;\r\n\r\n  if (network_config_stats)\r\n    plugin_register_read(\"network\", network_stats_read);\r\n\r\n  plugin_register_shutdown(\"network\", network_shutdown);\r\n\r\n  send_buffer = malloc(network_config_packet_size);\r\n  if (send_buffer == NULL) {\r\n    ERROR(\"network plugin: malloc failed.\");\r\n    return -1;\r\n  }\r\n  network_init_buffer();\r\n\r\n  /* setup socket(s) and so on */\r\n  if (sending_sockets != NULL) {\r\n    plugin_register_write(\"network\", network_write,\r\n                          /* user_data = */ NULL);\r\n    plugin_register_notification(\"network\", network_notification,\r\n                                 /* user_data = */ NULL);\r\n  }\r\n\r\n  /* If no threads need to be started, return here. */\r\n  if ((listen_sockets_num == 0) ||\r\n      ((dispatch_thread_running != 0) && (receive_thread_running != 0)))\r\n    return 0;\r\n\r\n  if (dispatch_thread_running == 0) {\r\n    int status;\r\n    status = plugin_thread_create(&dispatch_thread_id, dispatch_thread,\r\n                                  NULL /* no argument */, \"network disp\");\r\n    if (status != 0) {\r\n      ERROR(\"network: pthread_create failed: %s\", STRERRNO);\r\n    } else {\r\n      dispatch_thread_running = 1;\r\n    }\r\n  }\r\n\r\n  if (receive_thread_running == 0) {\r\n    int status;\r\n    status = plugin_thread_create(&receive_thread_id, receive_thread,\r\n                                  NULL /* no argument */, \"network recv\");\r\n    if (status != 0) {\r\n      ERROR(\"network: pthread_create failed: %s\", STRERRNO);\r\n    } else {\r\n      receive_thread_running = 1;\r\n    }\r\n  }\r\n\r\n  return 0;\r\n}", ".etwork_flush": "static int network_flush(cdtime_t timeout,\r\n                         __attribute__((unused)) const char *identifier,\r\n                         __attribute__((unused)) user_data_t *user_data) {\r\n  pthread_mutex_lock(&send_buffer_lock);\r\n\r\n  if (send_buffer_fill > 0) {\r\n    if (timeout > 0) {\r\n      cdtime_t now = cdtime();\r\n      if ((send_buffer_last_update + timeout) > now) {\r\n        pthread_mutex_unlock(&send_buffer_lock);\r\n        return 0;\r\n      }\r\n    }\r\n    flush_buffer();\r\n  }\r\n  pthread_mutex_unlock(&send_buffer_lock);\r\n\r\n  return 0;\r\n}"}, "callee": {".etwork_dispatch_values": "static int network_dispatch_values(value_list_t *vl, /* {{{ */\r\n                                   const char *username,\r\n                                   struct sockaddr_storage *address) {\r\n  int status;\r\n\r\n  if ((vl->time == 0) || (strlen(vl->host) == 0) || (strlen(vl->plugin) == 0) ||\r\n      (strlen(vl->type) == 0))\r\n    return -EINVAL;\r\n\r\n  if (!check_receive_okay(vl)) {\r\n#if COLLECT_DEBUG\r\n    char name[6 * DATA_MAX_NAME_LEN];\r\n    FORMAT_VL(name, sizeof(name), vl);\r\n    name[sizeof(name) - 1] = '\\0';\r\n    DEBUG(\"network plugin: network_dispatch_values: \"\r\n          \"NOT dispatching %s.\",\r\n          name);\r\n#endif\r\n    stats_values_not_dispatched++;\r\n    return 0;\r\n  }\r\n\r\n  assert(vl->meta == NULL);\r\n\r\n  vl->meta = meta_data_create();\r\n  if (vl->meta == NULL) {\r\n    ERROR(\"network plugin: meta_data_create failed.\");\r\n    return -ENOMEM;\r\n  }\r\n\r\n  status = meta_data_add_boolean(vl->meta, \"network:received\", 1);\r\n  if (status != 0) {\r\n    ERROR(\"network plugin: meta_data_add_boolean failed.\");\r\n    meta_data_destroy(vl->meta);\r\n    vl->meta = NULL;\r\n    return status;\r\n  }\r\n\r\n  if (username != NULL) {\r\n    status = meta_data_add_string(vl->meta, \"network:username\", username);\r\n    if (status != 0) {\r\n      ERROR(\"network plugin: meta_data_add_string failed.\");\r\n      meta_data_destroy(vl->meta);\r\n      vl->meta = NULL;\r\n      return status;\r\n    }\r\n  }\r\n\r\n  if (address != NULL) {\r\n    char host[48];\r\n    size_t len = sizeof(struct sockaddr_storage);\r\n\r\n#ifdef __NetBSD__\r\n    if (address->ss_family == AF_INET) {\r\n      len = sizeof(struct sockaddr_in);\r\n    } else if (address->ss_family == AF_INET6) {\r\n      len = sizeof(struct sockaddr_in6);\r\n    }\r\n#endif\r\n\r\n    status = getnameinfo((struct sockaddr *)address, len, host, sizeof(host),\r\n                         NULL, 0, NI_NUMERICHOST | NI_NUMERICSERV);\r\n    if (status != 0) {\r\n      ERROR(\"network plugin: getnameinfo failed: %s\", gai_strerror(status));\r\n      meta_data_destroy(vl->meta);\r\n      vl->meta = NULL;\r\n      return status;\r\n    }\r\n\r\n    status = meta_data_add_string(vl->meta, \"network:ip_address\", host);\r\n    if (status != 0) {\r\n      ERROR(\"network plugin: meta_data_add_string failed.\");\r\n      meta_data_destroy(vl->meta);\r\n      vl->meta = NULL;\r\n      return status;\r\n    }\r\n  }\r\n\r\n  plugin_dispatch_values(vl);\r\n  stats_values_dispatched++;\r\n\r\n  meta_data_destroy(vl->meta);\r\n  vl->meta = NULL;\r\n\r\n  return 0;\r\n}", ".etwork_write": "static int network_write(const data_set_t *ds, const value_list_t *vl,\r\n                         user_data_t __attribute__((unused)) * user_data) {\r\n  int status;\r\n\r\n  /* listen_loop is set to non-zero in the shutdown callback, which is\r\n   * guaranteed to be called *after* all the write threads have been shut\r\n   * down. */\r\n  assert(listen_loop == 0);\r\n\r\n  if (!check_send_okay(vl)) {\r\n#if COLLECT_DEBUG\r\n    char name[6 * DATA_MAX_NAME_LEN];\r\n    FORMAT_VL(name, sizeof(name), vl);\r\n    name[sizeof(name) - 1] = '\\0';\r\n    DEBUG(\"network plugin: network_write: \"\r\n          \"NOT sending %s.\",\r\n          name);\r\n#endif\r\n    /* Counter is not protected by another lock and may be reached by\r\n     * multiple threads */\r\n    pthread_mutex_lock(&stats_lock);\r\n    stats_values_not_sent++;\r\n    pthread_mutex_unlock(&stats_lock);\r\n    return 0;\r\n  }\r\n\r\n  uc_meta_data_add_unsigned_int(vl, \"network:time_sent\", (uint64_t)vl->time);\r\n\r\n  pthread_mutex_lock(&send_buffer_lock);\r\n\r\n  status = add_to_buffer(send_buffer_ptr,\r\n                         network_config_packet_size -\r\n                             (send_buffer_fill + BUFF_SIG_SIZE),\r\n                         &send_buffer_vl, ds, vl);\r\n  if (status >= 0) {\r\n    /* status == bytes added to the buffer */\r\n    send_buffer_fill += status;\r\n    send_buffer_ptr += status;\r\n    send_buffer_last_update = cdtime();\r\n\r\n    stats_values_sent++;\r\n  } else {\r\n    flush_buffer();\r\n\r\n    status = add_to_buffer(send_buffer_ptr,\r\n                           network_config_packet_size -\r\n                               (send_buffer_fill + BUFF_SIG_SIZE),\r\n                           &send_buffer_vl, ds, vl);\r\n\r\n    if (status >= 0) {\r\n      send_buffer_fill += status;\r\n      send_buffer_ptr += status;\r\n\r\n      stats_values_sent++;\r\n    }\r\n  }\r\n\r\n  if (status < 0) {\r\n    ERROR(\"network plugin: Unable to append to the \"\r\n          \"buffer for some weird reason\");\r\n  } else if ((network_config_packet_size - send_buffer_fill) < 15) {\r\n    flush_buffer();\r\n  }\r\n\r\n  pthread_mutex_unlock(&send_buffer_lock);\r\n\r\n  return (status < 0) ? -1 : 0;\r\n}", ".heck_send_notify_okay": "static bool check_send_notify_okay(const notification_t *n) /* {{{ */\r\n{\r\n  static c_complain_t complain_forwarding = C_COMPLAIN_INIT_STATIC;\r\n  bool received = 0;\r\n\r\n  if (n->meta == NULL)\r\n    return 1;\r\n\r\n  received = check_notify_received(n);\r\n\r\n  if (network_config_forward && received) {\r\n    c_complain_once(\r\n        LOG_ERR, &complain_forwarding,\r\n        \"network plugin: A notification has been received via the network \"\r\n        \"and forwarding is enabled. Forwarding of notifications is currently \"\r\n        \"not supported, because there is not loop-detection available. \"\r\n        \"Please contact the collectd mailing list if you need this \"\r\n        \"feature.\");\r\n  }\r\n\r\n  /* By default, only *send* value lists that were not *received* by the\r\n   * network plugin. */\r\n  return !received;\r\n}", ".etwork_notification": "static int network_notification(const notification_t *n,\r\n                                user_data_t __attribute__((unused)) *\r\n                                    user_data) {\r\n  char buffer[network_config_packet_size];\r\n  char *buffer_ptr = buffer;\r\n  size_t buffer_free = sizeof(buffer);\r\n  int status;\r\n\r\n  if (!check_send_notify_okay(n))\r\n    return 0;\r\n\r\n  memset(buffer, 0, sizeof(buffer));\r\n\r\n  status = write_part_number(&buffer_ptr, &buffer_free, TYPE_TIME_HR,\r\n                             (uint64_t)n->time);\r\n  if (status != 0)\r\n    return -1;\r\n\r\n  status = write_part_number(&buffer_ptr, &buffer_free, TYPE_SEVERITY,\r\n                             (uint64_t)n->severity);\r\n  if (status != 0)\r\n    return -1;\r\n\r\n  if (strlen(n->host) > 0) {\r\n    status = write_part_string(&buffer_ptr, &buffer_free, TYPE_HOST, n->host,\r\n                               strlen(n->host));\r\n    if (status != 0)\r\n      return -1;\r\n  }\r\n\r\n  if (strlen(n->plugin) > 0) {\r\n    status = write_part_string(&buffer_ptr, &buffer_free, TYPE_PLUGIN,\r\n                               n->plugin, strlen(n->plugin));\r\n    if (status != 0)\r\n      return -1;\r\n  }\r\n\r\n  if (strlen(n->plugin_instance) > 0) {\r\n    status = write_part_string(&buffer_ptr, &buffer_free, TYPE_PLUGIN_INSTANCE,\r\n                               n->plugin_instance, strlen(n->plugin_instance));\r\n    if (status != 0)\r\n      return -1;\r\n  }\r\n\r\n  if (strlen(n->type) > 0) {\r\n    status = write_part_string(&buffer_ptr, &buffer_free, TYPE_TYPE, n->type,\r\n                               strlen(n->type));\r\n    if (status != 0)\r\n      return -1;\r\n  }\r\n\r\n  if (strlen(n->type_instance) > 0) {\r\n    status = write_part_string(&buffer_ptr, &buffer_free, TYPE_TYPE_INSTANCE,\r\n                               n->type_instance, strlen(n->type_instance));\r\n    if (status != 0)\r\n      return -1;\r\n  }\r\n\r\n  status = write_part_string(&buffer_ptr, &buffer_free, TYPE_MESSAGE,\r\n                             n->message, strlen(n->message));\r\n  if (status != 0)\r\n    return -1;\r\n\r\n  network_send_buffer(buffer, sizeof(buffer) - buffer_free);\r\n\r\n  return 0;\r\n}", ".arse_packet": "static int parse_packet(sockent_t *se, /* {{{ */\r\n                        void *buffer, size_t buffer_size, int flags,\r\n                        const char *username,\r\n                        struct sockaddr_storage *address) {\r\n  int status;\r\n\r\n  value_list_t vl = VALUE_LIST_INIT;\r\n  notification_t n = {0};\r\n\r\n#if HAVE_GCRYPT_H\r\n  int packet_was_signed = (flags & PP_SIGNED);\r\n  int packet_was_encrypted = (flags & PP_ENCRYPTED);\r\n  int printed_ignore_warning = 0;\r\n#endif /* HAVE_GCRYPT_H */\r\n\r\n  memset(&vl, '\\0', sizeof(vl));\r\n  status = 0;\r\n\r\n  while ((status == 0) && (0 < buffer_size) &&\r\n         ((unsigned int)buffer_size > sizeof(part_header_t))) {\r\n    uint16_t pkg_length;\r\n    uint16_t pkg_type;\r\n\r\n    memcpy((void *)&pkg_type, (void *)buffer, sizeof(pkg_type));\r\n    memcpy((void *)&pkg_length, (void *)(((char *)buffer) + sizeof(pkg_type)),\r\n           sizeof(pkg_length));\r\n\r\n    pkg_length = ntohs(pkg_length);\r\n    pkg_type = ntohs(pkg_type);\r\n\r\n    if (pkg_length > buffer_size)\r\n      break;\r\n    /* Ensure that this loop terminates eventually */\r\n    if (pkg_length < (2 * sizeof(uint16_t)))\r\n      break;\r\n\r\n    if (pkg_type == TYPE_ENCR_AES256) {\r\n      status =\r\n          parse_part_encr_aes256(se, &buffer, &buffer_size, flags, address);\r\n      if (status != 0) {\r\n        ERROR(\"network plugin: Decrypting AES256 \"\r\n              \"part failed \"\r\n              \"with status %i.\",\r\n              status);\r\n        break;\r\n      }\r\n    }\r\n#if HAVE_GCRYPT_H\r\n    else if ((se->data.server.security_level == SECURITY_LEVEL_ENCRYPT) &&\r\n             (packet_was_encrypted == 0)) {\r\n      if (printed_ignore_warning == 0) {\r\n        INFO(\"network plugin: Unencrypted packet or \"\r\n             \"part has been ignored.\");\r\n        printed_ignore_warning = 1;\r\n      }\r\n      buffer = ((char *)buffer) + pkg_length;\r\n      buffer_size -= (size_t)pkg_length;\r\n      continue;\r\n    }\r\n#endif /* HAVE_GCRYPT_H */\r\n    else if (pkg_type == TYPE_SIGN_SHA256) {\r\n      status =\r\n          parse_part_sign_sha256(se, &buffer, &buffer_size, flags, address);\r\n      if (status != 0) {\r\n        ERROR(\"network plugin: Verifying HMAC-SHA-256 \"\r\n              \"signature failed \"\r\n              \"with status %i.\",\r\n              status);\r\n        break;\r\n      }\r\n    }\r\n#if HAVE_GCRYPT_H\r\n    else if ((se->data.server.security_level == SECURITY_LEVEL_SIGN) &&\r\n             (packet_was_encrypted == 0) && (packet_was_signed == 0)) {\r\n      if (printed_ignore_warning == 0) {\r\n        INFO(\"network plugin: Unsigned packet or \"\r\n             \"part has been ignored.\");\r\n        printed_ignore_warning = 1;\r\n      }\r\n      buffer = ((char *)buffer) + pkg_length;\r\n      buffer_size -= (size_t)pkg_length;\r\n      continue;\r\n    }\r\n#endif /* HAVE_GCRYPT_H */\r\n    else if (pkg_type == TYPE_VALUES) {\r\n      status =\r\n          parse_part_values(&buffer, &buffer_size, &vl.values, &vl.values_len);\r\n      if (status != 0)\r\n        break;\r\n\r\n      network_dispatch_values(&vl, username, address);\r\n\r\n      sfree(vl.values);\r\n    } else if (pkg_type == TYPE_TIME) {\r\n      uint64_t tmp = 0;\r\n      status = parse_part_number(&buffer, &buffer_size, &tmp);\r\n      if (status == 0) {\r\n        vl.time = TIME_T_TO_CDTIME_T(tmp);\r\n        n.time = TIME_T_TO_CDTIME_T(tmp);\r\n      }\r\n    } else if (pkg_type == TYPE_TIME_HR) {\r\n      uint64_t tmp = 0;\r\n      status = parse_part_number(&buffer, &buffer_size, &tmp);\r\n      if (status == 0) {\r\n        vl.time = (cdtime_t)tmp;\r\n        n.time = (cdtime_t)tmp;\r\n      }\r\n    } else if (pkg_type == TYPE_INTERVAL) {\r\n      uint64_t tmp = 0;\r\n      status = parse_part_number(&buffer, &buffer_size, &tmp);\r\n      if (status == 0)\r\n        vl.interval = TIME_T_TO_CDTIME_T(tmp);\r\n    } else if (pkg_type == TYPE_INTERVAL_HR) {\r\n      uint64_t tmp = 0;\r\n      status = parse_part_number(&buffer, &buffer_size, &tmp);\r\n      if (status == 0)\r\n        vl.interval = (cdtime_t)tmp;\r\n    } else if (pkg_type == TYPE_HOST) {\r\n      status =\r\n          parse_part_string(&buffer, &buffer_size, vl.host, sizeof(vl.host));\r\n      if (status == 0)\r\n        sstrncpy(n.host, vl.host, sizeof(n.host));\r\n    } else if (pkg_type == TYPE_PLUGIN) {\r\n      status = parse_part_string(&buffer, &buffer_size, vl.plugin,\r\n                                 sizeof(vl.plugin));\r\n      if (status == 0)\r\n        sstrncpy(n.plugin, vl.plugin, sizeof(n.plugin));\r\n    } else if (pkg_type == TYPE_PLUGIN_INSTANCE) {\r\n      status = parse_part_string(&buffer, &buffer_size, vl.plugin_instance,\r\n                                 sizeof(vl.plugin_instance));\r\n      if (status == 0)\r\n        sstrncpy(n.plugin_instance, vl.plugin_instance,\r\n                 sizeof(n.plugin_instance));\r\n    } else if (pkg_type == TYPE_TYPE) {\r\n      status =\r\n          parse_part_string(&buffer, &buffer_size, vl.type, sizeof(vl.type));\r\n      if (status == 0)\r\n        sstrncpy(n.type, vl.type, sizeof(n.type));\r\n    } else if (pkg_type == TYPE_TYPE_INSTANCE) {\r\n      status = parse_part_string(&buffer, &buffer_size, vl.type_instance,\r\n                                 sizeof(vl.type_instance));\r\n      if (status == 0)\r\n        sstrncpy(n.type_instance, vl.type_instance, sizeof(n.type_instance));\r\n    } else if (pkg_type == TYPE_MESSAGE) {\r\n      status = parse_part_string(&buffer, &buffer_size, n.message,\r\n                                 sizeof(n.message));\r\n\r\n      if (status != 0) {\r\n        /* do nothing */\r\n      } else if ((n.severity != NOTIF_FAILURE) &&\r\n                 (n.severity != NOTIF_WARNING) && (n.severity != NOTIF_OKAY)) {\r\n        INFO(\"network plugin: \"\r\n             \"Ignoring notification with \"\r\n             \"unknown severity %i.\",\r\n             n.severity);\r\n      } else if (n.time == 0) {\r\n        INFO(\"network plugin: \"\r\n             \"Ignoring notification with \"\r\n             \"time == 0.\");\r\n      } else if (strlen(n.message) == 0) {\r\n        INFO(\"network plugin: \"\r\n             \"Ignoring notification with \"\r\n             \"an empty message.\");\r\n      } else {\r\n        network_dispatch_notification(&n);\r\n      }\r\n    } else if (pkg_type == TYPE_SEVERITY) {\r\n      uint64_t tmp = 0;\r\n      status = parse_part_number(&buffer, &buffer_size, &tmp);\r\n      if (status == 0)\r\n        n.severity = (int)tmp;\r\n    } else {\r\n      DEBUG(\"network plugin: parse_packet: Unknown part\"\r\n            \" type: 0x%04hx\",\r\n            pkg_type);\r\n      buffer = ((char *)buffer) + pkg_length;\r\n      buffer_size -= (size_t)pkg_length;\r\n    }\r\n  } /* while (buffer_size > sizeof (part_header_t)) */\r\n\r\n  if (status == 0 && buffer_size > 0)\r\n    WARNING(\"network plugin: parse_packet: Received truncated \"\r\n            \"packet, try increasing `MaxPacketSize'\");\r\n\r\n  return status;\r\n}", ".ockent_init_crypto": "static int sockent_init_crypto(sockent_t *se) /* {{{ */\r\n{\r\n#if HAVE_GCRYPT_H /* {{{ */\r\n  if (se->type == SOCKENT_TYPE_CLIENT) {\r\n    if (se->data.client.security_level > SECURITY_LEVEL_NONE) {\r\n      if (network_init_gcrypt() < 0) {\r\n        ERROR(\"network plugin: Cannot configure client socket with \"\r\n              \"security: Failed to initialize crypto library.\");\r\n        return -1;\r\n      }\r\n\r\n      if ((se->data.client.username == NULL) ||\r\n          (se->data.client.password == NULL)) {\r\n        ERROR(\"network plugin: Client socket with \"\r\n              \"security requested, but no \"\r\n              \"credentials are configured.\");\r\n        return -1;\r\n      }\r\n      gcry_md_hash_buffer(GCRY_MD_SHA256, se->data.client.password_hash,\r\n                          se->data.client.password,\r\n                          strlen(se->data.client.password));\r\n    }\r\n  } else /* (se->type == SOCKENT_TYPE_SERVER) */\r\n  {\r\n    if ((se->data.server.security_level > SECURITY_LEVEL_NONE) &&\r\n        (se->data.server.auth_file == NULL)) {\r\n      ERROR(\"network plugin: Server socket with security requested, \"\r\n            \"but no \\\"AuthFile\\\" is configured.\");\r\n      return -1;\r\n    }\r\n    if (se->data.server.auth_file != NULL) {\r\n      if (network_init_gcrypt() < 0) {\r\n        ERROR(\"network plugin: Cannot configure server socket with security: \"\r\n              \"Failed to initialize crypto library.\");\r\n        return -1;\r\n      }\r\n\r\n      se->data.server.userdb = fbh_create(se->data.server.auth_file);\r\n      if (se->data.server.userdb == NULL) {\r\n        ERROR(\"network plugin: Reading password file \\\"%s\\\" failed.\",\r\n              se->data.server.auth_file);\r\n        return -1;\r\n      }\r\n    }\r\n  }\r\n#endif /* }}} HAVE_GCRYPT_H */\r\n\r\n  return 0;\r\n}", ".arse_part_encr_aes256": "static int parse_part_encr_aes256(sockent_t *se, /* {{{ */\r\n                                  void **ret_buffer, size_t *ret_buffer_len,\r\n                                  int flags, struct sockaddr_storage *sender) {\r\n  char *buffer = *ret_buffer;\r\n  size_t buffer_len = *ret_buffer_len;\r\n  size_t payload_len;\r\n  size_t part_size;\r\n  size_t buffer_offset;\r\n  uint16_t username_len;\r\n  part_encryption_aes256_t pea;\r\n  unsigned char hash[sizeof(pea.hash)] = {0};\r\n\r\n  gcry_cipher_hd_t cypher;\r\n  gcry_error_t err;\r\n\r\n  /* Make sure at least the header if available. */\r\n  if (buffer_len <= PART_ENCRYPTION_AES256_SIZE) {\r\n    NOTICE(\"network plugin: parse_part_encr_aes256: \"\r\n           \"Discarding short packet.\");\r\n    return -1;\r\n  }\r\n\r\n  buffer_offset = 0;\r\n\r\n  /* Copy the unencrypted information into `pea'. */\r\n  BUFFER_READ(&pea.head.type, sizeof(pea.head.type));\r\n  BUFFER_READ(&pea.head.length, sizeof(pea.head.length));\r\n\r\n  /* Check the `part size'. */\r\n  part_size = ntohs(pea.head.length);\r\n  if ((part_size <= PART_ENCRYPTION_AES256_SIZE) || (part_size > buffer_len)) {\r\n    NOTICE(\"network plugin: parse_part_encr_aes256: \"\r\n           \"Discarding part with invalid size.\");\r\n    return -1;\r\n  }\r\n\r\n  /* Read the username */\r\n  BUFFER_READ(&username_len, sizeof(username_len));\r\n  username_len = ntohs(username_len);\r\n\r\n  if ((username_len == 0) ||\r\n      (username_len > (part_size - (PART_ENCRYPTION_AES256_SIZE + 1)))) {\r\n    NOTICE(\"network plugin: parse_part_encr_aes256: \"\r\n           \"Discarding part with invalid username length.\");\r\n    return -1;\r\n  }\r\n\r\n  assert(username_len > 0);\r\n  pea.username = malloc(username_len + 1);\r\n  if (pea.username == NULL)\r\n    return -ENOMEM;\r\n  BUFFER_READ(pea.username, username_len);\r\n  pea.username[username_len] = 0;\r\n\r\n  /* Last but not least, the initialization vector */\r\n  BUFFER_READ(pea.iv, sizeof(pea.iv));\r\n\r\n  /* Make sure we are at the right position */\r\n  assert(buffer_offset ==\r\n         (username_len + PART_ENCRYPTION_AES256_SIZE - sizeof(pea.hash)));\r\n\r\n  cypher = network_get_aes256_cypher(se, pea.iv, sizeof(pea.iv), pea.username);\r\n  if (cypher == NULL) {\r\n    ERROR(\"network plugin: Failed to get cypher. Username: %s\", pea.username);\r\n    sfree(pea.username);\r\n    return -1;\r\n  }\r\n\r\n  payload_len = part_size - (PART_ENCRYPTION_AES256_SIZE + username_len);\r\n  assert(payload_len > 0);\r\n\r\n  /* Decrypt the packet in-place */\r\n  err = gcry_cipher_decrypt(cypher, buffer + buffer_offset,\r\n                            part_size - buffer_offset,\r\n                            /* in = */ NULL, /* in len = */ 0);\r\n  if (err != 0) {\r\n    ERROR(\"network plugin: gcry_cipher_decrypt returned: %s. Username: %s\",\r\n          gcry_strerror(err), pea.username);\r\n    sfree(pea.username);\r\n    return -1;\r\n  }\r\n\r\n  /* Read the hash */\r\n  BUFFER_READ(pea.hash, sizeof(pea.hash));\r\n\r\n  /* Make sure we're at the right position - again */\r\n  assert(buffer_offset == (username_len + PART_ENCRYPTION_AES256_SIZE));\r\n  assert(buffer_offset == (part_size - payload_len));\r\n\r\n  /* Check hash sum */\r\n  gcry_md_hash_buffer(GCRY_MD_SHA1, hash, buffer + buffer_offset, payload_len);\r\n  if (memcmp(hash, pea.hash, sizeof(hash)) != 0) {\r\n    ERROR(\"network plugin: Checksum mismatch. Username: %s\", pea.username);\r\n    sfree(pea.username);\r\n    return -1;\r\n  }\r\n\r\n  parse_packet(se, buffer + buffer_offset, payload_len, flags | PP_ENCRYPTED,\r\n               pea.username, sender);\r\n\r\n  /* Update return values */\r\n  *ret_buffer = buffer + part_size;\r\n  *ret_buffer_len = buffer_len - part_size;\r\n\r\n  sfree(pea.username);\r\n\r\n  return 0;\r\n}", ".etwork_send_buffer_encrypted": "static void network_send_buffer_encrypted(sockent_t *se, /* {{{ */\r\n                                          const char *in_buffer,\r\n                                          size_t in_buffer_size) {\r\n  char buffer[BUFF_SIG_SIZE + in_buffer_size];\r\n  size_t buffer_size;\r\n  size_t buffer_offset;\r\n  size_t header_size;\r\n  size_t username_len;\r\n  gcry_error_t err;\r\n  gcry_cipher_hd_t cypher;\r\n\r\n  /* Initialize the header fields */\r\n  part_encryption_aes256_t pea = {.head.type = htons(TYPE_ENCR_AES256),\r\n                                  .username = se->data.client.username};\r\n\r\n  username_len = strlen(pea.username);\r\n  if ((PART_ENCRYPTION_AES256_SIZE + username_len) > BUFF_SIG_SIZE) {\r\n    ERROR(\"network plugin: Username too long: %s\", pea.username);\r\n    return;\r\n  }\r\n\r\n  buffer_size = PART_ENCRYPTION_AES256_SIZE + username_len + in_buffer_size;\r\n  header_size = PART_ENCRYPTION_AES256_SIZE + username_len - sizeof(pea.hash);\r\n\r\n  assert(buffer_size <= sizeof(buffer));\r\n  DEBUG(\"network plugin: network_send_buffer_encrypted: \"\r\n        \"buffer_size = %\" PRIsz \";\",\r\n        buffer_size);\r\n\r\n  pea.head.length = htons(\r\n      (uint16_t)(PART_ENCRYPTION_AES256_SIZE + username_len + in_buffer_size));\r\n  pea.username_length = htons((uint16_t)username_len);\r\n\r\n  /* Chose a random initialization vector. */\r\n  gcry_randomize((void *)&pea.iv, sizeof(pea.iv), GCRY_STRONG_RANDOM);\r\n\r\n  /* Create hash of the payload */\r\n  gcry_md_hash_buffer(GCRY_MD_SHA1, pea.hash, in_buffer, in_buffer_size);\r\n\r\n  /* Initialize the buffer */\r\n  buffer_offset = 0;\r\n  memset(buffer, 0, sizeof(buffer));\r\n\r\n  BUFFER_ADD(&pea.head.type, sizeof(pea.head.type));\r\n  BUFFER_ADD(&pea.head.length, sizeof(pea.head.length));\r\n  BUFFER_ADD(&pea.username_length, sizeof(pea.username_length));\r\n  BUFFER_ADD(pea.username, username_len);\r\n  BUFFER_ADD(pea.iv, sizeof(pea.iv));\r\n  assert(buffer_offset == header_size);\r\n  BUFFER_ADD(pea.hash, sizeof(pea.hash));\r\n  BUFFER_ADD(in_buffer, in_buffer_size);\r\n\r\n  assert(buffer_offset == buffer_size);\r\n\r\n  cypher = network_get_aes256_cypher(se, pea.iv, sizeof(pea.iv),\r\n                                     se->data.client.password);\r\n  if (cypher == NULL)\r\n    return;\r\n\r\n  /* Encrypt the buffer in-place */\r\n  err = gcry_cipher_encrypt(cypher, buffer + header_size,\r\n                            buffer_size - header_size,\r\n                            /* in = */ NULL, /* in len = */ 0);\r\n  if (err != 0) {\r\n    ERROR(\"network plugin: gcry_cipher_encrypt returned: %s\",\r\n          gcry_strerror(err));\r\n    return;\r\n  }\r\n\r\n  /* Send it out without further modifications */\r\n  network_send_buffer_plain(se, buffer, buffer_size);\r\n}", ".dd_to_buffer": "static int add_to_buffer(char *buffer, size_t buffer_size, /* {{{ */\r\n                         value_list_t *vl_def, const data_set_t *ds,\r\n                         const value_list_t *vl) {\r\n  char *buffer_orig = buffer;\r\n\r\n  if (strcmp(vl_def->host, vl->host) != 0) {\r\n    if (write_part_string(&buffer, &buffer_size, TYPE_HOST, vl->host,\r\n                          strlen(vl->host)) != 0)\r\n      return -1;\r\n    sstrncpy(vl_def->host, vl->host, sizeof(vl_def->host));\r\n  }\r\n\r\n  if (vl_def->time != vl->time) {\r\n    if (write_part_number(&buffer, &buffer_size, TYPE_TIME_HR,\r\n                          (uint64_t)vl->time))\r\n      return -1;\r\n    vl_def->time = vl->time;\r\n  }\r\n\r\n  if (vl_def->interval != vl->interval) {\r\n    if (write_part_number(&buffer, &buffer_size, TYPE_INTERVAL_HR,\r\n                          (uint64_t)vl->interval))\r\n      return -1;\r\n    vl_def->interval = vl->interval;\r\n  }\r\n\r\n  if (strcmp(vl_def->plugin, vl->plugin) != 0) {\r\n    if (write_part_string(&buffer, &buffer_size, TYPE_PLUGIN, vl->plugin,\r\n                          strlen(vl->plugin)) != 0)\r\n      return -1;\r\n    sstrncpy(vl_def->plugin, vl->plugin, sizeof(vl_def->plugin));\r\n  }\r\n\r\n  if (strcmp(vl_def->plugin_instance, vl->plugin_instance) != 0) {\r\n    if (write_part_string(&buffer, &buffer_size, TYPE_PLUGIN_INSTANCE,\r\n                          vl->plugin_instance,\r\n                          strlen(vl->plugin_instance)) != 0)\r\n      return -1;\r\n    sstrncpy(vl_def->plugin_instance, vl->plugin_instance,\r\n             sizeof(vl_def->plugin_instance));\r\n  }\r\n\r\n  if (strcmp(vl_def->type, vl->type) != 0) {\r\n    if (write_part_string(&buffer, &buffer_size, TYPE_TYPE, vl->type,\r\n                          strlen(vl->type)) != 0)\r\n      return -1;\r\n    sstrncpy(vl_def->type, ds->type, sizeof(vl_def->type));\r\n  }\r\n\r\n  if (strcmp(vl_def->type_instance, vl->type_instance) != 0) {\r\n    if (write_part_string(&buffer, &buffer_size, TYPE_TYPE_INSTANCE,\r\n                          vl->type_instance, strlen(vl->type_instance)) != 0)\r\n      return -1;\r\n    sstrncpy(vl_def->type_instance, vl->type_instance,\r\n             sizeof(vl_def->type_instance));\r\n  }\r\n\r\n  if (write_part_values(&buffer, &buffer_size, ds, vl) != 0)\r\n    return -1;\r\n\r\n  return buffer - buffer_orig;\r\n}", ".arse_part_sign_sha256": "static int parse_part_sign_sha256(sockent_t *se, /* {{{ */\r\n                                  void **ret_buffer, size_t *ret_buffer_len,\r\n                                  int flags, struct sockaddr_storage *sender) {\r\n  static c_complain_t complain_no_users = C_COMPLAIN_INIT_STATIC;\r\n\r\n  char *buffer;\r\n  size_t buffer_len;\r\n  size_t buffer_offset;\r\n\r\n  size_t username_len;\r\n  char *secret;\r\n\r\n  part_signature_sha256_t pss;\r\n  uint16_t pss_head_length;\r\n  char hash[sizeof(pss.hash)];\r\n\r\n  gcry_md_hd_t hd;\r\n  gcry_error_t err;\r\n  unsigned char *hash_ptr;\r\n\r\n  buffer = *ret_buffer;\r\n  buffer_len = *ret_buffer_len;\r\n  buffer_offset = 0;\r\n\r\n  /* Check if the buffer has enough data for this structure. */\r\n  if (buffer_len <= PART_SIGNATURE_SHA256_SIZE)\r\n    return -ENOMEM;\r\n\r\n  /* Read type and length header */\r\n  BUFFER_READ(&pss.head.type, sizeof(pss.head.type));\r\n  BUFFER_READ(&pss.head.length, sizeof(pss.head.length));\r\n  pss_head_length = ntohs(pss.head.length);\r\n\r\n  /* Check if the `pss_head_length' is within bounds. */\r\n  if ((pss_head_length <= PART_SIGNATURE_SHA256_SIZE) ||\r\n      (pss_head_length > buffer_len)) {\r\n    ERROR(\"network plugin: HMAC-SHA-256 with invalid length received.\");\r\n    return -1;\r\n  }\r\n\r\n  if (se->data.server.userdb == NULL) {\r\n    c_complain(\r\n        LOG_NOTICE, &complain_no_users,\r\n        \"network plugin: Received signed network packet but can't verify it \"\r\n        \"because no user DB has been configured. Will accept it.\");\r\n\r\n    *ret_buffer = buffer + pss_head_length;\r\n    *ret_buffer_len -= pss_head_length;\r\n\r\n    return 0;\r\n  }\r\n\r\n  /* Copy the hash. */\r\n  BUFFER_READ(pss.hash, sizeof(pss.hash));\r\n\r\n  /* Calculate username length (without null byte) and allocate memory */\r\n  username_len = pss_head_length - PART_SIGNATURE_SHA256_SIZE;\r\n  pss.username = malloc(username_len + 1);\r\n  if (pss.username == NULL)\r\n    return -ENOMEM;\r\n\r\n  /* Read the username */\r\n  BUFFER_READ(pss.username, username_len);\r\n  pss.username[username_len] = 0;\r\n\r\n  assert(buffer_offset == pss_head_length);\r\n\r\n  /* Query the password */\r\n  secret = fbh_get(se->data.server.userdb, pss.username);\r\n  if (secret == NULL) {\r\n    ERROR(\"network plugin: Unknown user: %s\", pss.username);\r\n    sfree(pss.username);\r\n    return -ENOENT;\r\n  }\r\n\r\n  /* Create a hash device and check the HMAC */\r\n  hd = NULL;\r\n  err = gcry_md_open(&hd, GCRY_MD_SHA256, GCRY_MD_FLAG_HMAC);\r\n  if (err != 0) {\r\n    ERROR(\"network plugin: Creating HMAC-SHA-256 object failed: %s\",\r\n          gcry_strerror(err));\r\n    sfree(secret);\r\n    sfree(pss.username);\r\n    return -1;\r\n  }\r\n\r\n  err = gcry_md_setkey(hd, secret, strlen(secret));\r\n  if (err != 0) {\r\n    ERROR(\"network plugin: gcry_md_setkey failed: %s\", gcry_strerror(err));\r\n    gcry_md_close(hd);\r\n    sfree(secret);\r\n    sfree(pss.username);\r\n    return -1;\r\n  }\r\n\r\n  gcry_md_write(hd, buffer + PART_SIGNATURE_SHA256_SIZE,\r\n                buffer_len - PART_SIGNATURE_SHA256_SIZE);\r\n  hash_ptr = gcry_md_read(hd, GCRY_MD_SHA256);\r\n  if (hash_ptr == NULL) {\r\n    ERROR(\"network plugin: gcry_md_read failed.\");\r\n    gcry_md_close(hd);\r\n    sfree(secret);\r\n    sfree(pss.username);\r\n    return -1;\r\n  }\r\n  memcpy(hash, hash_ptr, sizeof(hash));\r\n\r\n  /* Clean up */\r\n  gcry_md_close(hd);\r\n  hd = NULL;\r\n\r\n  if (memcmp(pss.hash, hash, sizeof(pss.hash)) != 0) {\r\n    WARNING(\"network plugin: Verifying HMAC-SHA-256 signature failed: \"\r\n            \"Hash mismatch. Username: %s\",\r\n            pss.username);\r\n  } else {\r\n    parse_packet(se, buffer + buffer_offset, buffer_len - buffer_offset,\r\n                 flags | PP_SIGNED, pss.username, sender);\r\n  }\r\n\r\n  sfree(secret);\r\n  sfree(pss.username);\r\n\r\n  *ret_buffer = buffer + buffer_len;\r\n  *ret_buffer_len = 0;\r\n\r\n  return 0;\r\n}", ".ockent_destroy": "static void sockent_destroy(sockent_t *se) /* {{{ */\r\n{\r\n  sockent_t *next;\r\n\r\n  DEBUG(\"network plugin: sockent_destroy (se = %p);\", (void *)se);\r\n\r\n  while (se != NULL) {\r\n    next = se->next;\r\n\r\n    sfree(se->node);\r\n    sfree(se->service);\r\n    pthread_mutex_destroy(&se->lock);\r\n\r\n    if (se->type == SOCKENT_TYPE_CLIENT)\r\n      free_sockent_client(&se->data.client);\r\n    else\r\n      free_sockent_server(&se->data.server);\r\n\r\n    sfree(se);\r\n    se = next;\r\n  }\r\n}", ".etwork_config_add_listen": "static int network_config_add_listen(const oconfig_item_t *ci) /* {{{ */\r\n{\r\n  sockent_t *se;\r\n  int status;\r\n\r\n  if ((ci->values_num < 1) || (ci->values_num > 2) ||\r\n      (ci->values[0].type != OCONFIG_TYPE_STRING) ||\r\n      ((ci->values_num > 1) && (ci->values[1].type != OCONFIG_TYPE_STRING))) {\r\n    ERROR(\"network plugin: The `%s' config option needs \"\r\n          \"one or two string arguments.\",\r\n          ci->key);\r\n    return -1;\r\n  }\r\n\r\n  se = sockent_create(SOCKENT_TYPE_SERVER);\r\n  if (se == NULL) {\r\n    ERROR(\"network plugin: sockent_create failed.\");\r\n    return -1;\r\n  }\r\n\r\n  se->node = strdup(ci->values[0].value.string);\r\n  if (ci->values_num >= 2)\r\n    se->service = strdup(ci->values[1].value.string);\r\n\r\n  for (int i = 0; i < ci->children_num; i++) {\r\n    oconfig_item_t *child = ci->children + i;\r\n\r\n#if HAVE_GCRYPT_H\r\n    if (strcasecmp(\"AuthFile\", child->key) == 0)\r\n      cf_util_get_string(child, &se->data.server.auth_file);\r\n    else if (strcasecmp(\"SecurityLevel\", child->key) == 0)\r\n      network_config_set_security_level(child, &se->data.server.security_level);\r\n    else\r\n#endif /* HAVE_GCRYPT_H */\r\n        if (strcasecmp(\"Interface\", child->key) == 0)\r\n      network_config_set_interface(child, &se->interface);\r\n    else {\r\n      WARNING(\"network plugin: Option `%s' is not allowed here.\", child->key);\r\n    }\r\n  }\r\n\r\n#if HAVE_GCRYPT_H\r\n  if ((se->data.server.security_level > SECURITY_LEVEL_NONE) &&\r\n      (se->data.server.auth_file == NULL)) {\r\n    ERROR(\"network plugin: A security level higher than `none' was \"\r\n          \"requested, but no AuthFile option was given. Cowardly refusing to \"\r\n          \"open this socket!\");\r\n    sockent_destroy(se);\r\n    return -1;\r\n  }\r\n#endif /* HAVE_GCRYPT_H */\r\n\r\n  status = sockent_init_crypto(se);\r\n  if (status != 0) {\r\n    ERROR(\"network plugin: network_config_add_listen: sockent_init_crypto() \"\r\n          \"failed.\");\r\n    sockent_destroy(se);\r\n    return -1;\r\n  }\r\n\r\n  status = sockent_server_listen(se);\r\n  if (status != 0) {\r\n    ERROR(\"network plugin: network_config_add_listen: sockent_server_listen \"\r\n          \"failed.\");\r\n    sockent_destroy(se);\r\n    return -1;\r\n  }\r\n\r\n  status = sockent_add(se);\r\n  if (status != 0) {\r\n    ERROR(\"network plugin: network_config_add_listen: sockent_add failed.\");\r\n    sockent_destroy(se);\r\n    return -1;\r\n  }\r\n\r\n  return 0;\r\n}", ".etwork_config_add_server": "static int network_config_add_server(const oconfig_item_t *ci) /* {{{ */\r\n{\r\n  sockent_t *se;\r\n  int status;\r\n\r\n  if ((ci->values_num < 1) || (ci->values_num > 2) ||\r\n      (ci->values[0].type != OCONFIG_TYPE_STRING) ||\r\n      ((ci->values_num > 1) && (ci->values[1].type != OCONFIG_TYPE_STRING))) {\r\n    ERROR(\"network plugin: The `%s' config option needs \"\r\n          \"one or two string arguments.\",\r\n          ci->key);\r\n    return -1;\r\n  }\r\n\r\n  se = sockent_create(SOCKENT_TYPE_CLIENT);\r\n  if (se == NULL) {\r\n    ERROR(\"network plugin: sockent_create failed.\");\r\n    return -1;\r\n  }\r\n\r\n  se->node = strdup(ci->values[0].value.string);\r\n  if (ci->values_num >= 2)\r\n    se->service = strdup(ci->values[1].value.string);\r\n\r\n  for (int i = 0; i < ci->children_num; i++) {\r\n    oconfig_item_t *child = ci->children + i;\r\n\r\n#if HAVE_GCRYPT_H\r\n    if (strcasecmp(\"Username\", child->key) == 0)\r\n      cf_util_get_string(child, &se->data.client.username);\r\n    else if (strcasecmp(\"Password\", child->key) == 0)\r\n      cf_util_get_string(child, &se->data.client.password);\r\n    else if (strcasecmp(\"SecurityLevel\", child->key) == 0)\r\n      network_config_set_security_level(child, &se->data.client.security_level);\r\n    else\r\n#endif /* HAVE_GCRYPT_H */\r\n        if (strcasecmp(\"Interface\", child->key) == 0)\r\n      network_config_set_interface(child, &se->interface);\r\n    else if (strcasecmp(\"BindAddress\", child->key) == 0)\r\n      network_config_set_bind_address(child, &se->data.client.bind_addr);\r\n    else if (strcasecmp(\"ResolveInterval\", child->key) == 0)\r\n      cf_util_get_cdtime(child, &se->data.client.resolve_interval);\r\n    else {\r\n      WARNING(\"network plugin: Option `%s' is not allowed here.\", child->key);\r\n    }\r\n  }\r\n\r\n#if HAVE_GCRYPT_H\r\n  if ((se->data.client.security_level > SECURITY_LEVEL_NONE) &&\r\n      ((se->data.client.username == NULL) ||\r\n       (se->data.client.password == NULL))) {\r\n    ERROR(\"network plugin: A security level higher than `none' was \"\r\n          \"requested, but no Username or Password option was given. \"\r\n          \"Cowardly refusing to open this socket!\");\r\n    sockent_destroy(se);\r\n    return -1;\r\n  }\r\n#endif /* HAVE_GCRYPT_H */\r\n\r\n  status = sockent_init_crypto(se);\r\n  if (status != 0) {\r\n    ERROR(\"network plugin: network_config_add_server: sockent_init_crypto() \"\r\n          \"failed.\");\r\n    sockent_destroy(se);\r\n    return -1;\r\n  }\r\n\r\n  /* No call to sockent_client_connect() here -- it is called from\r\n   * network_send_buffer_plain(). */\r\n\r\n  status = sockent_add(se);\r\n  if (status != 0) {\r\n    ERROR(\"network plugin: network_config_add_server: sockent_add failed.\");\r\n    sockent_destroy(se);\r\n    return -1;\r\n  }\r\n\r\n  return 0;\r\n}", ".etwork_shutdown": "static int network_shutdown(void) {\r\n  listen_loop++;\r\n\r\n  /* Kill the listening thread */\r\n  if (receive_thread_running != 0) {\r\n    INFO(\"network plugin: Stopping receive thread.\");\r\n    pthread_kill(receive_thread_id, SIGTERM);\r\n    pthread_join(receive_thread_id, NULL /* no return value */);\r\n    memset(&receive_thread_id, 0, sizeof(receive_thread_id));\r\n    receive_thread_running = 0;\r\n  }\r\n\r\n  /* Shutdown the dispatching thread */\r\n  if (dispatch_thread_running != 0) {\r\n    INFO(\"network plugin: Stopping dispatch thread.\");\r\n    pthread_mutex_lock(&receive_list_lock);\r\n    pthread_cond_broadcast(&receive_list_cond);\r\n    pthread_mutex_unlock(&receive_list_lock);\r\n    pthread_join(dispatch_thread_id, /* ret = */ NULL);\r\n    dispatch_thread_running = 0;\r\n  }\r\n\r\n  sockent_destroy(listen_sockets);\r\n\r\n  if (send_buffer_fill > 0)\r\n    flush_buffer();\r\n\r\n  sfree(send_buffer);\r\n\r\n  for (sockent_t *se = sending_sockets; se != NULL; se = se->next)\r\n    sockent_client_disconnect(se);\r\n  sockent_destroy(sending_sockets);\r\n\r\n  plugin_unregister_config(\"network\");\r\n  plugin_unregister_init(\"network\");\r\n  plugin_unregister_write(\"network\");\r\n  plugin_unregister_shutdown(\"network\");\r\n\r\n  return 0;\r\n}", ".etwork_send_buffer_plain": "static void network_send_buffer_plain(sockent_t *se, /* {{{ */\r\n                                      const char *buffer, size_t buffer_size) {\r\n  int status;\r\n\r\n  while (42) {\r\n    status = sockent_client_connect(se);\r\n    if (status != 0)\r\n      return;\r\n\r\n    status = sendto(se->data.client.fd, buffer, buffer_size,\r\n                    /* flags = */ 0, (struct sockaddr *)se->data.client.addr,\r\n                    se->data.client.addrlen);\r\n    if (status < 0) {\r\n      if ((errno == EINTR) || (errno == EAGAIN))\r\n        continue;\r\n\r\n      ERROR(\"network plugin: sendto failed: %s. Closing sending socket.\",\r\n            STRERRNO);\r\n      sockent_client_disconnect(se);\r\n      return;\r\n    }\r\n\r\n    break;\r\n  } /* while (42) */\r\n}", ".lush_buffer": "static void flush_buffer(void) {\r\n  DEBUG(\"network plugin: flush_buffer: send_buffer_fill = %i\",\r\n        send_buffer_fill);\r\n\r\n  network_send_buffer(send_buffer, (size_t)send_buffer_fill);\r\n\r\n  stats_octets_tx += ((uint64_t)send_buffer_fill);\r\n  stats_packets_tx++;\r\n\r\n  network_init_buffer();\r\n}", ".etwork_init": "static int network_init(void) {\r\n  static bool have_init;\r\n\r\n  /* Check if we were already initialized. If so, just return - there's\r\n   * nothing more to do (for now, that is). */\r\n  if (have_init)\r\n    return 0;\r\n  have_init = true;\r\n\r\n  if (network_config_stats)\r\n    plugin_register_read(\"network\", network_stats_read);\r\n\r\n  plugin_register_shutdown(\"network\", network_shutdown);\r\n\r\n  send_buffer = malloc(network_config_packet_size);\r\n  if (send_buffer == NULL) {\r\n    ERROR(\"network plugin: malloc failed.\");\r\n    return -1;\r\n  }\r\n  network_init_buffer();\r\n\r\n  /* setup socket(s) and so on */\r\n  if (sending_sockets != NULL) {\r\n    plugin_register_write(\"network\", network_write,\r\n                          /* user_data = */ NULL);\r\n    plugin_register_notification(\"network\", network_notification,\r\n                                 /* user_data = */ NULL);\r\n  }\r\n\r\n  /* If no threads need to be started, return here. */\r\n  if ((listen_sockets_num == 0) ||\r\n      ((dispatch_thread_running != 0) && (receive_thread_running != 0)))\r\n    return 0;\r\n\r\n  if (dispatch_thread_running == 0) {\r\n    int status;\r\n    status = plugin_thread_create(&dispatch_thread_id, dispatch_thread,\r\n                                  NULL /* no argument */, \"network disp\");\r\n    if (status != 0) {\r\n      ERROR(\"network: pthread_create failed: %s\", STRERRNO);\r\n    } else {\r\n      dispatch_thread_running = 1;\r\n    }\r\n  }\r\n\r\n  if (receive_thread_running == 0) {\r\n    int status;\r\n    status = plugin_thread_create(&receive_thread_id, receive_thread,\r\n                                  NULL /* no argument */, \"network recv\");\r\n    if (status != 0) {\r\n      ERROR(\"network: pthread_create failed: %s\", STRERRNO);\r\n    } else {\r\n      receive_thread_running = 1;\r\n    }\r\n  }\r\n\r\n  return 0;\r\n}", ".etwork_send_buffer_signed": "static void network_send_buffer_signed(sockent_t *se, /* {{{ */\r\n                                       const char *in_buffer,\r\n                                       size_t in_buffer_size) {\r\n  char buffer[BUFF_SIG_SIZE + in_buffer_size];\r\n  size_t buffer_offset;\r\n  size_t username_len;\r\n\r\n  gcry_md_hd_t hd;\r\n  gcry_error_t err;\r\n  unsigned char *hash;\r\n\r\n  hd = NULL;\r\n  err = gcry_md_open(&hd, GCRY_MD_SHA256, GCRY_MD_FLAG_HMAC);\r\n  if (err != 0) {\r\n    ERROR(\"network plugin: Creating HMAC object failed: %s\",\r\n          gcry_strerror(err));\r\n    return;\r\n  }\r\n\r\n  err = gcry_md_setkey(hd, se->data.client.password,\r\n                       strlen(se->data.client.password));\r\n  if (err != 0) {\r\n    ERROR(\"network plugin: gcry_md_setkey failed: %s\", gcry_strerror(err));\r\n    gcry_md_close(hd);\r\n    return;\r\n  }\r\n\r\n  username_len = strlen(se->data.client.username);\r\n  if (username_len > (BUFF_SIG_SIZE - PART_SIGNATURE_SHA256_SIZE)) {\r\n    ERROR(\"network plugin: Username too long: %s\", se->data.client.username);\r\n    return;\r\n  }\r\n\r\n  memcpy(buffer + PART_SIGNATURE_SHA256_SIZE, se->data.client.username,\r\n         username_len);\r\n  memcpy(buffer + PART_SIGNATURE_SHA256_SIZE + username_len, in_buffer,\r\n         in_buffer_size);\r\n\r\n  /* Initialize the `ps' structure. */\r\n  part_signature_sha256_t ps = {\r\n      .head.type = htons(TYPE_SIGN_SHA256),\r\n      .head.length = htons(PART_SIGNATURE_SHA256_SIZE + username_len)};\r\n\r\n  /* Calculate the hash value. */\r\n  gcry_md_write(hd, buffer + PART_SIGNATURE_SHA256_SIZE,\r\n                username_len + in_buffer_size);\r\n  hash = gcry_md_read(hd, GCRY_MD_SHA256);\r\n  if (hash == NULL) {\r\n    ERROR(\"network plugin: gcry_md_read failed.\");\r\n    gcry_md_close(hd);\r\n    return;\r\n  }\r\n  memcpy(ps.hash, hash, sizeof(ps.hash));\r\n\r\n  /* Add the header */\r\n  buffer_offset = 0;\r\n\r\n  BUFFER_ADD(&ps.head.type, sizeof(ps.head.type));\r\n  BUFFER_ADD(&ps.head.length, sizeof(ps.head.length));\r\n  BUFFER_ADD(ps.hash, sizeof(ps.hash));\r\n\r\n  assert(buffer_offset == PART_SIGNATURE_SHA256_SIZE);\r\n\r\n  gcry_md_close(hd);\r\n  hd = NULL;\r\n\r\n  buffer_offset = PART_SIGNATURE_SHA256_SIZE + username_len + in_buffer_size;\r\n  network_send_buffer_plain(se, buffer, buffer_offset);\r\n}", ".etwork_flush": "static int network_flush(cdtime_t timeout,\r\n                         __attribute__((unused)) const char *identifier,\r\n                         __attribute__((unused)) user_data_t *user_data) {\r\n  pthread_mutex_lock(&send_buffer_lock);\r\n\r\n  if (send_buffer_fill > 0) {\r\n    if (timeout > 0) {\r\n      cdtime_t now = cdtime();\r\n      if ((send_buffer_last_update + timeout) > now) {\r\n        pthread_mutex_unlock(&send_buffer_lock);\r\n        return 0;\r\n      }\r\n    }\r\n    flush_buffer();\r\n  }\r\n  pthread_mutex_unlock(&send_buffer_lock);\r\n\r\n  return 0;\r\n}", ".odule_register": "void module_register(void) {\r\n  plugin_register_complex_config(\"network\", network_config);\r\n  plugin_register_init(\"network\", network_init);\r\n  plugin_register_flush(\"network\", network_flush,\r\n                        /* user_data = */ NULL);\r\n}"}, "function_name": "module_register"}
{"function_id": null, "caller": {}, "callee": {}, "function_name": ""}
{"function_id": null, "caller": {".indOffset": "static int16_t findOffset(const char* const* list, const char* key)\r\n{\r\n\tconst char* const* anchor = list;\r\n\twhile (*list != NULL) {\r\n\t\tif (strcasecmp(key, *list) == 0) {\r\n\t\t\treturn (int16_t)(list - anchor);\r\n\t\t}\r\n\t\tlist++;\r\n\t}\r\n\r\n\treturn -1;\r\n\r\n}", ".dd_prefix": "static void add_prefix(smart_str* loc_name, char* key_name)\r\n{\r\n\tif( strncmp(key_name , LOC_PRIVATE_TAG , 7) == 0 ){\r\n\t\tsmart_str_appendl(loc_name, SEPARATOR , sizeof(SEPARATOR)-1);\r\n\t\tsmart_str_appendl(loc_name, PRIVATE_PREFIX , sizeof(PRIVATE_PREFIX)-1);\r\n\t}\r\n}"}, "callee": {".et_icu_disp_value_src_php": "static void get_icu_disp_value_src_php( char* tag_name, INTERNAL_FUNCTION_PARAMETERS)\r\n{\r\n\tchar*          loc_name        \t= NULL;\r\n\tsize_t         loc_name_len    \t= 0;\r\n\r\n\tchar*       disp_loc_name       = NULL;\r\n\tsize_t      disp_loc_name_len   = 0;\r\n\tint         free_loc_name       = 0;\r\n\r\n\tUChar*      disp_name      \t= NULL;\r\n\tint32_t     disp_name_len  \t= 0;\r\n\r\n\tchar*       mod_loc_name        = NULL;\r\n\r\n\tint32_t     buflen          \t= 512;\r\n\tUErrorCode  status          \t= U_ZERO_ERROR;\r\n\r\n\tzend_string* u8str;\r\n\r\n\tchar*       msg             \t= NULL;\r\n\r\n\tintl_error_reset( NULL );\r\n\r\n\tZEND_PARSE_PARAMETERS_START(1, 2)\r\n\t\tZ_PARAM_PATH(loc_name, loc_name_len)\r\n\t\tZ_PARAM_OPTIONAL\r\n\t\tZ_PARAM_PATH_OR_NULL(disp_loc_name, disp_loc_name_len)\r\n\tZEND_PARSE_PARAMETERS_END();\r\n\r\n\tif(loc_name_len > ULOC_FULLNAME_CAPACITY) {\r\n\t\t/* See bug 67397: overlong locale names cause trouble in uloc_getDisplayName */\r\n\t\tspprintf(&msg , 0, \"locale_get_display_%s : name too long\", tag_name );\r\n\t\tintl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,  msg , 1 );\r\n\t\tefree(msg);\r\n\t\tRETURN_FALSE;\r\n\t}\r\n\r\n\tif(loc_name_len == 0) {\r\n\t\tloc_name = (char *)intl_locale_get_default();\r\n\t}\r\n\r\n\tif( strcmp(tag_name, DISP_NAME) != 0 ){\r\n\t\t/* Handle grandfathered languages */\r\n\t\tint grOffset = findOffset( LOC_GRANDFATHERED , loc_name );\r\n\t\tif( grOffset >= 0 ){\r\n\t\t\tif( strcmp(tag_name , LOC_LANG_TAG)==0 ){\r\n\t\t\t\tmod_loc_name = getPreferredTag( loc_name );\r\n\t\t\t} else {\r\n\t\t\t\t/* Since Grandfathered, no value, do nothing, return NULL */\r\n\t\t\t\tRETURN_FALSE;\r\n\t\t\t}\r\n\t\t}\r\n\t} /* end of if != LOC_CANONICAL_TAG */\r\n\r\n\tif( mod_loc_name==NULL ){\r\n\t\tmod_loc_name = estrdup( loc_name );\r\n\t}\r\n\r\n\t/* Check if disp_loc_name passed , if not use default locale */\r\n\tif( !disp_loc_name){\r\n\t\tdisp_loc_name = estrdup(intl_locale_get_default());\r\n\t\tfree_loc_name = 1;\r\n\t}\r\n\r\n\t/* Get the disp_value for the given locale */\r\n\tdo{\r\n\t\tdisp_name = erealloc( disp_name , buflen * sizeof(UChar)  );\r\n\t\tdisp_name_len = buflen;\r\n\r\n\t\tif( strcmp(tag_name , LOC_LANG_TAG)==0 ){\r\n\t\t\tbuflen = uloc_getDisplayLanguage ( mod_loc_name , disp_loc_name , disp_name , disp_name_len , &status);\r\n\t\t} else if( strcmp(tag_name , LOC_SCRIPT_TAG)==0 ){\r\n\t\t\tbuflen = uloc_getDisplayScript ( mod_loc_name , disp_loc_name , disp_name , disp_name_len , &status);\r\n\t\t} else if( strcmp(tag_name , LOC_REGION_TAG)==0 ){\r\n\t\t\tbuflen = uloc_getDisplayCountry ( mod_loc_name , disp_loc_name , disp_name , disp_name_len , &status);\r\n\t\t} else if( strcmp(tag_name , LOC_VARIANT_TAG)==0 ){\r\n\t\t\tbuflen = uloc_getDisplayVariant ( mod_loc_name , disp_loc_name , disp_name , disp_name_len , &status);\r\n\t\t} else if( strcmp(tag_name , DISP_NAME)==0 ){\r\n\t\t\tbuflen = uloc_getDisplayName ( mod_loc_name , disp_loc_name , disp_name , disp_name_len , &status);\r\n\t\t}\r\n\r\n\t\t/* U_STRING_NOT_TERMINATED_WARNING is admissible here; don't look for it */\r\n\t\tif( U_FAILURE( status ) )\r\n\t\t{\r\n\t\t\tif( status == U_BUFFER_OVERFLOW_ERROR )\r\n\t\t\t{\r\n\t\t\t\tstatus = U_ZERO_ERROR;\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tspprintf(&msg, 0, \"locale_get_display_%s : unable to get locale %s\", tag_name , tag_name );\r\n\t\t\tintl_error_set( NULL, status, msg , 1 );\r\n\t\t\tefree(msg);\r\n\t\t\tif( disp_name){\r\n\t\t\t\tefree( disp_name );\r\n\t\t\t}\r\n\t\t\tif( mod_loc_name){\r\n\t\t\t\tefree( mod_loc_name );\r\n\t\t\t}\r\n\t\t\tif (free_loc_name) {\r\n\t\t\t\tefree((void *)disp_loc_name);\r\n\t\t\t\tdisp_loc_name = NULL;\r\n\t\t\t}\r\n\t\t\tRETURN_FALSE;\r\n\t\t}\r\n\t} while( buflen > disp_name_len );\r\n\r\n\tif( mod_loc_name){\r\n\t\tefree( mod_loc_name );\r\n\t}\r\n\tif (free_loc_name) {\r\n\t\tefree((void *)disp_loc_name);\r\n\t\tdisp_loc_name = NULL;\r\n\t}\r\n\t/* Convert display locale name from UTF-16 to UTF-8. */\r\n\tu8str = intl_convert_utf16_to_utf8(disp_name, buflen, &status );\r\n\tefree( disp_name );\r\n\tif( !u8str )\r\n\t{\r\n\t\tspprintf(&msg, 0, \"locale_get_display_%s :error converting display name for %s to UTF-8\", tag_name , tag_name );\r\n\t\tintl_error_set( NULL, status, msg , 1 );\r\n\t\tefree(msg);\r\n\t\tRETURN_FALSE;\r\n\t}\r\n\r\n\tRETVAL_NEW_STR( u8str );\r\n}", ".ppend_multiple_key_values": "static int append_multiple_key_values(smart_str* loc_name, HashTable* hash_arr, char* key_name)\r\n{\r\n\tzval\t*ele_value;\r\n\tint \tisFirstSubtag \t= 0;\r\n\r\n\t/* Variant/ Extlang/Private etc. */\r\n\tif ((ele_value = zend_hash_str_find_deref( hash_arr , key_name , strlen(key_name))) != NULL) {\r\n\t\tif( Z_TYPE_P(ele_value) == IS_STRING ){\r\n\t\t\tadd_prefix( loc_name , key_name);\r\n\r\n\t\t\tsmart_str_appendl(loc_name, SEPARATOR , sizeof(SEPARATOR)-1);\r\n\t\t\tsmart_str_appendl(loc_name, Z_STRVAL_P(ele_value) , Z_STRLEN_P(ele_value));\r\n\t\t\treturn SUCCESS;\r\n\t\t} else if(Z_TYPE_P(ele_value) == IS_ARRAY ) {\r\n\t\t\tHashTable *arr = Z_ARRVAL_P(ele_value);\r\n\t\t\tzval *data;\r\n\r\n\t\t\tZEND_HASH_FOREACH_VAL(arr, data) {\r\n\t\t\t\tZVAL_DEREF(data);\r\n\t\t\t\tif(Z_TYPE_P(data) != IS_STRING) {\r\n\t\t\t\t\treturn FAILURE;\r\n\t\t\t\t}\r\n\t\t\t\tif (isFirstSubtag++ == 0){\r\n\t\t\t\t\tadd_prefix(loc_name , key_name);\r\n\t\t\t\t}\r\n\t\t\t\tsmart_str_appendl(loc_name, SEPARATOR , sizeof(SEPARATOR)-1);\r\n\t\t\t\tsmart_str_appendl(loc_name, Z_STRVAL_P(data) , Z_STRLEN_P(data));\r\n\t\t\t} ZEND_HASH_FOREACH_END();\r\n\t\t\treturn SUCCESS;\r\n\t\t} else {\r\n\t\t\treturn FAILURE;\r\n\t\t}\r\n\t} else {\r\n\t\tchar cur_key_name[31];\r\n\t\tint  max_value = 0, i;\r\n\t\t/* Decide the max_value: the max. no. of elements allowed */\r\n\t\tif( strcmp(key_name , LOC_VARIANT_TAG) ==0 ){\r\n\t\t\tmax_value  = MAX_NO_VARIANT;\r\n\t\t}\r\n\t\tif( strcmp(key_name , LOC_EXTLANG_TAG) ==0 ){\r\n\t\t\tmax_value  = MAX_NO_EXTLANG;\r\n\t\t}\r\n\t\tif( strcmp(key_name , LOC_PRIVATE_TAG) ==0 ){\r\n\t\t\tmax_value  = MAX_NO_PRIVATE;\r\n\t\t}\r\n\r\n\t\t/* Multiple variant values as variant0, variant1 ,variant2 */\r\n\t\tisFirstSubtag = 0;\r\n\t\tfor( i=0 ; i< max_value; i++ ){\r\n\t\t\tsnprintf( cur_key_name , 30, \"%s%d\", key_name , i);\r\n\t\t\tif ((ele_value = zend_hash_str_find_deref( hash_arr , cur_key_name , strlen(cur_key_name))) != NULL) {\r\n\t\t\t\tif( Z_TYPE_P(ele_value)!= IS_STRING ){\r\n\t\t\t\t\t/* variant is not a string */\r\n\t\t\t\t\treturn FAILURE;\r\n\t\t\t\t}\r\n\t\t\t\t/* Add the contents */\r\n\t\t\t\tif (isFirstSubtag++ == 0){\r\n\t\t\t\t\tadd_prefix(loc_name , cur_key_name);\r\n\t\t\t\t}\r\n\t\t\t\tsmart_str_appendl(loc_name, SEPARATOR , sizeof(SEPARATOR)-1);\r\n\t\t\t\tsmart_str_appendl(loc_name, Z_STRVAL_P(ele_value) , Z_STRLEN_P(ele_value));\r\n\t\t\t}\r\n\t\t} /* end of for */\r\n\t} /* end of else */\r\n\r\n\treturn SUCCESS;\r\n}"}, "function_name": "array_cleanup"}
{"function_id": null, "caller": {".hp_zip_progress_callback_free": "static void php_zip_progress_callback_free(void *ptr)\r\n{\r\n\tze_zip_object *obj = ptr;\r\n\r\n\tif (ZEND_FCC_INITIALIZED(obj->progress_callback)) {\r\n\t\tzend_fcc_dtor(&obj->progress_callback);\r\n\t}\r\n}", ".hp_zip_cancel_callback_free": "static void php_zip_cancel_callback_free(void *ptr)\r\n{\r\n\tze_zip_object *obj = ptr;\r\n\r\n\tif (ZEND_FCC_INITIALIZED(obj->cancel_callback)) {\r\n\t\tzend_fcc_dtor(&obj->cancel_callback);\r\n\t}\r\n}"}, "callee": {".hp_zip_object_free_storage": "static void php_zip_object_free_storage(zend_object *object) /* {{{ */\r\n{\r\n\tze_zip_object * intern = php_zip_fetch_object(object);\r\n\tint i;\r\n\r\n\tif (intern->za) {\r\n\t\tif (zip_close(intern->za) != 0) {\r\n\t\t\tphp_error_docref(NULL, E_WARNING, \"Cannot destroy the zip context: %s\", zip_strerror(intern->za));\r\n\t\t\tzip_discard(intern->za);\r\n\t\t}\r\n\t}\r\n\r\n\tif (intern->buffers_cnt>0) {\r\n\t\tfor (i=0; i<intern->buffers_cnt; i++) {\r\n\t\t\tefree(intern->buffers[i]);\r\n\t\t}\r\n\t\tefree(intern->buffers);\r\n\t}\r\n\r\n#ifdef HAVE_PROGRESS_CALLBACK\r\n\t/* if not properly called by libzip */\r\n\tphp_zip_progress_callback_free(intern);\r\n#endif\r\n\r\n#ifdef HAVE_CANCEL_CALLBACK\r\n\t/* if not properly called by libzip */\r\n\tphp_zip_cancel_callback_free(intern);\r\n#endif\r\n\r\n\tintern->za = NULL;\r\n\tzend_object_std_dtor(&intern->zo);\r\n\r\n\tif (intern->filename) {\r\n\t\tefree(intern->filename);\r\n\t}\r\n}"}, "function_name": "php_zip_free_prop_handler"}
{"function_id": null, "caller": {}, "callee": {}, "function_name": "gdImageXbmCtx"}
{"function_id": null, "caller": {".etscreen_check_file_type": "static bool netscreen_check_file_type(wtap *wth, int *err, char **err_info)\r\n{\r\n\tchar\tbuf[NETSCREEN_LINE_LENGTH];\r\n\tunsigned\treclen, line;\r\n\r\n\tbuf[NETSCREEN_LINE_LENGTH-1] = '\\0';\r\n\r\n\tfor (line = 0; line < NETSCREEN_HEADER_LINES_TO_CHECK; line++) {\r\n\t\tif (file_gets(buf, NETSCREEN_LINE_LENGTH, wth->fh) == NULL) {\r\n\t\t\t/* EOF or error. */\r\n\t\t\t*err = file_error(wth->fh, err_info);\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\treclen = (unsigned) strlen(buf);\r\n\t\tif (reclen < MIN(strlen(NETSCREEN_HDR_MAGIC_STR1), strlen(NETSCREEN_HDR_MAGIC_STR2))) {\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\tif (strstr(buf, NETSCREEN_HDR_MAGIC_STR1) ||\r\n\t\t    strstr(buf, NETSCREEN_HDR_MAGIC_STR2)) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t}\r\n\t*err = 0;\r\n\treturn false;\r\n}", ".etscreen_read": "static bool netscreen_read(wtap *wth, wtap_rec *rec,\r\n    int *err, char **err_info, int64_t *data_offset)\r\n{\r\n\tint64_t\t\toffset;\r\n\tchar\t\tline[NETSCREEN_LINE_LENGTH];\r\n\r\n\t/* Find the next packet */\r\n\toffset = netscreen_seek_next_packet(wth, err, err_info, line);\r\n\tif (offset < 0)\r\n\t\treturn false;\r\n\r\n\t/* Parse the header and convert the ASCII hex dump to binary data */\r\n\tif (!parse_netscreen_packet(wth->fh, rec, line, err, err_info))\r\n\t\treturn false;\r\n\r\n\t/*\r\n\t * If the per-file encapsulation isn't known, set it to this\r\n\t * packet's encapsulation.\r\n\t *\r\n\t * If it *is* known, and it isn't this packet's encapsulation,\r\n\t * set it to WTAP_ENCAP_PER_PACKET, as this file doesn't\r\n\t * have a single encapsulation for all packets in the file.\r\n\t */\r\n\tif (wth->file_encap == WTAP_ENCAP_UNKNOWN)\r\n\t\twth->file_encap = rec->rec_header.packet_header.pkt_encap;\r\n\telse {\r\n\t\tif (wth->file_encap != rec->rec_header.packet_header.pkt_encap)\r\n\t\t\twth->file_encap = WTAP_ENCAP_PER_PACKET;\r\n\t}\r\n\r\n\t*data_offset = offset;\r\n\treturn true;\r\n}", ".etscreen_seek_read": "static bool\r\nnetscreen_seek_read(wtap *wth, int64_t seek_off, wtap_rec *rec,\r\n\tint *err, char **err_info)\r\n{\r\n\tchar\t\tline[NETSCREEN_LINE_LENGTH];\r\n\r\n\tif (file_seek(wth->random_fh, seek_off, SEEK_SET, err) == -1) {\r\n\t\treturn false;\r\n\t}\r\n\r\n\tif (file_gets(line, NETSCREEN_LINE_LENGTH, wth->random_fh) == NULL) {\r\n\t\t*err = file_error(wth->random_fh, err_info);\r\n\t\tif (*err == 0) {\r\n\t\t\t*err = WTAP_ERR_SHORT_READ;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\treturn parse_netscreen_packet(wth->random_fh, rec, line,\r\n\t    err, err_info);\r\n}", ".etscreen_seek_next_packet": "static int64_t netscreen_seek_next_packet(wtap *wth, int *err, char **err_info,\r\n    char *hdr)\r\n{\r\n\tint64_t cur_off;\r\n\tchar buf[NETSCREEN_LINE_LENGTH];\r\n\r\n\twhile (1) {\r\n\t\tcur_off = file_tell(wth->fh);\r\n\t\tif (cur_off == -1) {\r\n\t\t\t/* Error */\r\n\t\t\t*err = file_error(wth->fh, err_info);\r\n\t\t\treturn -1;\r\n\t\t}\r\n\t\tif (file_gets(buf, sizeof(buf), wth->fh) == NULL) {\r\n\t\t\t/* EOF or error. */\r\n\t\t\t*err = file_error(wth->fh, err_info);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tif (strstr(buf, NETSCREEN_REC_MAGIC_STR1) ||\r\n\t\t    strstr(buf, NETSCREEN_REC_MAGIC_STR2)) {\r\n\t\t\t(void) g_strlcpy(hdr, buf, NETSCREEN_LINE_LENGTH);\r\n\t\t\treturn cur_off;\r\n\t\t}\r\n\t}\r\n\treturn -1;\r\n}", ".arse_netscreen_packet": "static bool\r\nparse_netscreen_packet(FILE_T fh, wtap_rec *rec, char *line,\r\n    int *err, char **err_info)\r\n{\r\n\tunsigned\t\tpkt_len;\r\n\tint\t\tsec;\r\n\tint\t\tdsec;\r\n\tchar\t\tcap_int[NETSCREEN_MAX_INT_NAME_LENGTH];\r\n\tchar\t\tdirection[2];\r\n\tchar\t\tcap_src[13];\r\n\tchar\t\tcap_dst[13];\r\n\tuint8_t\t\t*pd;\r\n\tchar\t\t*p;\r\n\tint\t\tn, i = 0;\r\n\tint\t\toffset = 0;\r\n\tchar\t\tdststr[13];\r\n\r\n\twtap_setup_packet_rec(rec, WTAP_ENCAP_UNKNOWN);\r\n\trec->block = wtap_block_create(WTAP_BLOCK_PACKET);\r\n\trec->presence_flags = WTAP_HAS_TS|WTAP_HAS_CAP_LEN;\r\n\t/* Suppress compiler warnings */\r\n\tmemset(cap_int, 0, sizeof(cap_int));\r\n\tmemset(cap_dst, 0, sizeof(cap_dst));\r\n\r\n\tif (sscanf(line, \"%9d.%9d: %15[a-z0-9/:.-](%1[io]) len=%9u:%12s->%12s/\",\r\n\t\t   &sec, &dsec, cap_int, direction, &pkt_len, cap_src, cap_dst) < 5) {\r\n\t\t*err = WTAP_ERR_BAD_FILE;\r\n\t\t*err_info = g_strdup(\"netscreen: Can't parse packet-header\");\r\n\t\treturn -1;\r\n\t}\r\n\tif (pkt_len > WTAP_MAX_PACKET_SIZE_STANDARD) {\r\n\t\t/*\r\n\t\t * Probably a corrupt capture file; don't blow up trying\r\n\t\t * to allocate space for an immensely-large packet.\r\n\t\t */\r\n\t\t*err = WTAP_ERR_BAD_FILE;\r\n\t\t*err_info = ws_strdup_printf(\"netscreen: File has %u-byte packet, bigger than maximum of %u\",\r\n\t\t    pkt_len, WTAP_MAX_PACKET_SIZE_STANDARD);\r\n\t\treturn false;\r\n\t}\r\n\r\n\t/*\r\n\t * If direction[0] is 'o', the direction is NETSCREEN_EGRESS,\r\n\t * otherwise it's NETSCREEN_INGRESS.\r\n\t */\r\n\r\n\trec->ts.secs  = sec;\r\n\trec->ts.nsecs = dsec * 100000000;\r\n\trec->rec_header.packet_header.len = pkt_len;\r\n\r\n\t/* Make sure we have enough room for the packet */\r\n\tws_buffer_assure_space(&rec->data, pkt_len);\r\n\tpd = ws_buffer_start_ptr(&rec->data);\r\n\r\n\twhile(1) {\r\n\r\n\t\t/* The last packet is not delimited by an empty line, but by EOF\r\n\t\t * So accept EOF as a valid delimiter too\r\n\t\t */\r\n\t\tif (file_gets(line, NETSCREEN_LINE_LENGTH, fh) == NULL) {\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\t/*\r\n\t\t * Skip blanks.\r\n\t\t * The number of blanks is not fixed - for wireless\r\n\t\t * interfaces, there may be 14 extra spaces before\r\n\t\t * the hex data.\r\n\t\t */\r\n\t\tfor (p = &line[0]; g_ascii_isspace(*p); p++)\r\n\t\t\t;\r\n\t\t/* packets are delimited with empty lines */\r\n\t\tif (*p == '\\0') {\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\tn = parse_single_hex_dump_line(p, pd, offset, pkt_len);\r\n\r\n\t\t/*\r\n\t\t * The smallest packet has a length of 6 bytes.\r\n\t\t * If the first line either gets an error when\r\n\t\t * parsed as hex data, or has fewer than 6\r\n\t\t * bytes of hex data, check whether it's an\r\n\t\t * info line by see if it has at least\r\n\t\t * NETSCREEN_SPACES_ON_INFO_LINE spaces at the\r\n\t\t * beginning.\r\n\t\t *\r\n\t\t * If it does, count this line and, if we have,\r\n\t\t * so far, skipped no more than NETSCREEN_MAX_INFOLINES\r\n\t\t * lines, skip this line.\r\n\t\t */\r\n\t\tif (offset == 0 && n < 6) {\r\n\t\t\tif (info_line(line)) {\r\n\t\t\t\t/* Info line */\r\n\t\t\t\tif (++i <= NETSCREEN_MAX_INFOLINES) {\r\n\t\t\t\t\t/* Skip this line */\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tif (n >= 0) {\r\n\t\t\t\t\t*err = WTAP_ERR_BAD_FILE;\r\n\t\t\t\t\t*err_info = g_strdup(\"netscreen: first line of packet data has only %d hex bytes, < 6\");\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t\t/* Otherwise, fall through to report error */\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t/* If there is no more data and the line was not empty,\r\n\t\t * then there must be an error in the file\r\n\t\t */\r\n\t\tif (n < 0) {\r\n\t\t\tswitch (n) {\r\n\r\n\t\t\tcase PARSE_LINE_INVALID_CHARACTER:\r\n\t\t\t\t*err = WTAP_ERR_BAD_FILE;\r\n\t\t\t\t*err_info = g_strdup(\"netscreen: invalid character in hex data\");\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase PARSE_LINE_NO_BYTES_SEEN:\r\n\t\t\t\t*err = WTAP_ERR_BAD_FILE;\r\n\t\t\t\t*err_info = g_strdup(\"netscreen: no hex bytes seen in hex data\");\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase PARSE_LINE_TOO_MANY_BYTES_SEEN:\r\n\t\t\t\t*err = WTAP_ERR_BAD_FILE;\r\n\t\t\t\t*err_info = g_strdup(\"netscreen: number of hex bytes seen in hex data is greater than the packet length\");\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tdefault:\r\n\t\t\t\t*err = WTAP_ERR_INTERNAL;\r\n\t\t\t\t*err_info = g_strdup_printf(\"netscreen: unknown error %d from parse_single_hex_dump_line()\", n);\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\t/* Adjust the offset to the data that was just added to the buffer */\r\n\t\toffset += n;\r\n\r\n\t}\r\n\r\n\t/*\r\n\t * Determine the encapsulation type, based on the\r\n\t * first 4 characters of the interface name\r\n\t *\r\n\t * XXX\tconvert this to a 'case' structure when adding more\r\n\t *\t(non-ethernet) interfacetypes\r\n\t */\r\n\tif (strncmp(cap_int, \"adsl\", 4) == 0) {\r\n\t\t/* The ADSL interface can be bridged with or without\r\n\t\t * PPP encapsulation. Check whether the first six bytes\r\n\t\t * of the hex data are the same as the destination mac\r\n\t\t * address in the header. If they are, assume ethernet\r\n\t\t * LinkLayer or else PPP\r\n\t\t */\r\n\t\tsnprintf(dststr, 13, \"%02x%02x%02x%02x%02x%02x\",\r\n\t\t   pd[0], pd[1], pd[2], pd[3], pd[4], pd[5]);\r\n\t\tif (strncmp(dststr, cap_dst, 12) == 0)\r\n\t\t\trec->rec_header.packet_header.pkt_encap = WTAP_ENCAP_ETHERNET;\r\n\t\telse\r\n\t\t\trec->rec_header.packet_header.pkt_encap = WTAP_ENCAP_PPP;\r\n\t\t}\r\n\telse if (strncmp(cap_int, \"seri\", 4) == 0)\r\n\t\trec->rec_header.packet_header.pkt_encap = WTAP_ENCAP_PPP;\r\n\telse\r\n\t\trec->rec_header.packet_header.pkt_encap = WTAP_ENCAP_ETHERNET;\r\n\r\n\trec->rec_header.packet_header.caplen = offset;\r\n\r\n\treturn true;\r\n}", ".arse_single_hex_dump_line": "static int\r\nparse_single_hex_dump_line(char* rec, uint8_t *buf, unsigned byte_offset, unsigned pkt_len)\r\n{\r\n\tint num_items_scanned;\r\n\tuint8_t character;\r\n\tuint8_t byte;\r\n\r\n\r\n\tfor (num_items_scanned = 0; num_items_scanned < 16; num_items_scanned++) {\r\n\t\tcharacter = *rec++;\r\n\t\tif (character >= '0' && character <= '9')\r\n\t\t\tbyte = character - '0' + 0;\r\n\t\telse if (character >= 'A' && character <= 'F')\r\n\t\t\tbyte = character - 'A' + 0xA;\r\n\t\telse if (character >= 'a' && character <= 'f')\r\n\t\t\tbyte = character - 'a' + 0xa;\r\n\t\telse if (character == ' ' || character == '\\r' || character == '\\n' || character == '\\0') {\r\n\t\t\t/* Nothing more to parse */\r\n\t\t\tbreak;\r\n\t\t} else\r\n\t\t\treturn PARSE_LINE_INVALID_CHARACTER; /* not a hex digit, space before ASCII dump, or EOL */\r\n\t\tbyte <<= 4;\r\n\t\tcharacter = *rec++ & 0xFF;\r\n\t\tif (character >= '0' && character <= '9')\r\n\t\t\tbyte += character - '0' + 0;\r\n\t\telse if (character >= 'A' && character <= 'F')\r\n\t\t\tbyte += character - 'A' + 0xA;\r\n\t\telse if (character >= 'a' && character <= 'f')\r\n\t\t\tbyte += character - 'a' + 0xa;\r\n\t\telse\r\n\t\t\treturn PARSE_LINE_INVALID_CHARACTER; /* not a hex digit */\r\n\r\n\t\t/* If there was more hex-data than was announced in the len=x\r\n\t\t * header, then there must be an error in the file; quit\r\n\t\t * now, as adding this byte will overflow the buffer.\r\n\t\t */\r\n\t\tif (byte_offset + num_items_scanned >= pkt_len) {\r\n\t\t\treturn PARSE_LINE_TOO_MANY_BYTES_SEEN;\r\n\t\t}\r\n\r\n\t\tbuf[byte_offset + num_items_scanned] = byte;\r\n\t\tcharacter = *rec++ & 0xFF;\r\n\t\tif (character == '\\0' || character == '\\r' || character == '\\n') {\r\n\t\t\t/* Nothing more to parse */\r\n\t\t\tbreak;\r\n\t\t} else if (character != ' ') {\r\n\t\t\t/* not space before ASCII dump */\r\n\t\t\treturn PARSE_LINE_INVALID_CHARACTER;\r\n\t\t}\r\n\t}\r\n\tif (num_items_scanned == 0)\r\n\t\treturn PARSE_LINE_NO_BYTES_SEEN;\r\n\r\n\treturn num_items_scanned;\r\n}", ".nfo_line": "static bool info_line(const char *line)\r\n{\r\n\tint i=NETSCREEN_SPACES_ON_INFO_LINE;\r\n\r\n\twhile (i-- > 0) {\r\n\t\tif (g_ascii_isspace(*line)) {\r\n\t\t\tline++;\r\n\t\t\tcontinue;\r\n\t\t} else {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\treturn true;\r\n}"}, "callee": {".arse_netscreen_packet": "static bool\r\nparse_netscreen_packet(FILE_T fh, wtap_rec *rec, char *line,\r\n    int *err, char **err_info)\r\n{\r\n\tunsigned\t\tpkt_len;\r\n\tint\t\tsec;\r\n\tint\t\tdsec;\r\n\tchar\t\tcap_int[NETSCREEN_MAX_INT_NAME_LENGTH];\r\n\tchar\t\tdirection[2];\r\n\tchar\t\tcap_src[13];\r\n\tchar\t\tcap_dst[13];\r\n\tuint8_t\t\t*pd;\r\n\tchar\t\t*p;\r\n\tint\t\tn, i = 0;\r\n\tint\t\toffset = 0;\r\n\tchar\t\tdststr[13];\r\n\r\n\twtap_setup_packet_rec(rec, WTAP_ENCAP_UNKNOWN);\r\n\trec->block = wtap_block_create(WTAP_BLOCK_PACKET);\r\n\trec->presence_flags = WTAP_HAS_TS|WTAP_HAS_CAP_LEN;\r\n\t/* Suppress compiler warnings */\r\n\tmemset(cap_int, 0, sizeof(cap_int));\r\n\tmemset(cap_dst, 0, sizeof(cap_dst));\r\n\r\n\tif (sscanf(line, \"%9d.%9d: %15[a-z0-9/:.-](%1[io]) len=%9u:%12s->%12s/\",\r\n\t\t   &sec, &dsec, cap_int, direction, &pkt_len, cap_src, cap_dst) < 5) {\r\n\t\t*err = WTAP_ERR_BAD_FILE;\r\n\t\t*err_info = g_strdup(\"netscreen: Can't parse packet-header\");\r\n\t\treturn -1;\r\n\t}\r\n\tif (pkt_len > WTAP_MAX_PACKET_SIZE_STANDARD) {\r\n\t\t/*\r\n\t\t * Probably a corrupt capture file; don't blow up trying\r\n\t\t * to allocate space for an immensely-large packet.\r\n\t\t */\r\n\t\t*err = WTAP_ERR_BAD_FILE;\r\n\t\t*err_info = ws_strdup_printf(\"netscreen: File has %u-byte packet, bigger than maximum of %u\",\r\n\t\t    pkt_len, WTAP_MAX_PACKET_SIZE_STANDARD);\r\n\t\treturn false;\r\n\t}\r\n\r\n\t/*\r\n\t * If direction[0] is 'o', the direction is NETSCREEN_EGRESS,\r\n\t * otherwise it's NETSCREEN_INGRESS.\r\n\t */\r\n\r\n\trec->ts.secs  = sec;\r\n\trec->ts.nsecs = dsec * 100000000;\r\n\trec->rec_header.packet_header.len = pkt_len;\r\n\r\n\t/* Make sure we have enough room for the packet */\r\n\tws_buffer_assure_space(&rec->data, pkt_len);\r\n\tpd = ws_buffer_start_ptr(&rec->data);\r\n\r\n\twhile(1) {\r\n\r\n\t\t/* The last packet is not delimited by an empty line, but by EOF\r\n\t\t * So accept EOF as a valid delimiter too\r\n\t\t */\r\n\t\tif (file_gets(line, NETSCREEN_LINE_LENGTH, fh) == NULL) {\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\t/*\r\n\t\t * Skip blanks.\r\n\t\t * The number of blanks is not fixed - for wireless\r\n\t\t * interfaces, there may be 14 extra spaces before\r\n\t\t * the hex data.\r\n\t\t */\r\n\t\tfor (p = &line[0]; g_ascii_isspace(*p); p++)\r\n\t\t\t;\r\n\t\t/* packets are delimited with empty lines */\r\n\t\tif (*p == '\\0') {\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\tn = parse_single_hex_dump_line(p, pd, offset, pkt_len);\r\n\r\n\t\t/*\r\n\t\t * The smallest packet has a length of 6 bytes.\r\n\t\t * If the first line either gets an error when\r\n\t\t * parsed as hex data, or has fewer than 6\r\n\t\t * bytes of hex data, check whether it's an\r\n\t\t * info line by see if it has at least\r\n\t\t * NETSCREEN_SPACES_ON_INFO_LINE spaces at the\r\n\t\t * beginning.\r\n\t\t *\r\n\t\t * If it does, count this line and, if we have,\r\n\t\t * so far, skipped no more than NETSCREEN_MAX_INFOLINES\r\n\t\t * lines, skip this line.\r\n\t\t */\r\n\t\tif (offset == 0 && n < 6) {\r\n\t\t\tif (info_line(line)) {\r\n\t\t\t\t/* Info line */\r\n\t\t\t\tif (++i <= NETSCREEN_MAX_INFOLINES) {\r\n\t\t\t\t\t/* Skip this line */\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tif (n >= 0) {\r\n\t\t\t\t\t*err = WTAP_ERR_BAD_FILE;\r\n\t\t\t\t\t*err_info = g_strdup(\"netscreen: first line of packet data has only %d hex bytes, < 6\");\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t\t/* Otherwise, fall through to report error */\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t/* If there is no more data and the line was not empty,\r\n\t\t * then there must be an error in the file\r\n\t\t */\r\n\t\tif (n < 0) {\r\n\t\t\tswitch (n) {\r\n\r\n\t\t\tcase PARSE_LINE_INVALID_CHARACTER:\r\n\t\t\t\t*err = WTAP_ERR_BAD_FILE;\r\n\t\t\t\t*err_info = g_strdup(\"netscreen: invalid character in hex data\");\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase PARSE_LINE_NO_BYTES_SEEN:\r\n\t\t\t\t*err = WTAP_ERR_BAD_FILE;\r\n\t\t\t\t*err_info = g_strdup(\"netscreen: no hex bytes seen in hex data\");\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase PARSE_LINE_TOO_MANY_BYTES_SEEN:\r\n\t\t\t\t*err = WTAP_ERR_BAD_FILE;\r\n\t\t\t\t*err_info = g_strdup(\"netscreen: number of hex bytes seen in hex data is greater than the packet length\");\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tdefault:\r\n\t\t\t\t*err = WTAP_ERR_INTERNAL;\r\n\t\t\t\t*err_info = g_strdup_printf(\"netscreen: unknown error %d from parse_single_hex_dump_line()\", n);\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\t/* Adjust the offset to the data that was just added to the buffer */\r\n\t\toffset += n;\r\n\r\n\t}\r\n\r\n\t/*\r\n\t * Determine the encapsulation type, based on the\r\n\t * first 4 characters of the interface name\r\n\t *\r\n\t * XXX\tconvert this to a 'case' structure when adding more\r\n\t *\t(non-ethernet) interfacetypes\r\n\t */\r\n\tif (strncmp(cap_int, \"adsl\", 4) == 0) {\r\n\t\t/* The ADSL interface can be bridged with or without\r\n\t\t * PPP encapsulation. Check whether the first six bytes\r\n\t\t * of the hex data are the same as the destination mac\r\n\t\t * address in the header. If they are, assume ethernet\r\n\t\t * LinkLayer or else PPP\r\n\t\t */\r\n\t\tsnprintf(dststr, 13, \"%02x%02x%02x%02x%02x%02x\",\r\n\t\t   pd[0], pd[1], pd[2], pd[3], pd[4], pd[5]);\r\n\t\tif (strncmp(dststr, cap_dst, 12) == 0)\r\n\t\t\trec->rec_header.packet_header.pkt_encap = WTAP_ENCAP_ETHERNET;\r\n\t\telse\r\n\t\t\trec->rec_header.packet_header.pkt_encap = WTAP_ENCAP_PPP;\r\n\t\t}\r\n\telse if (strncmp(cap_int, \"seri\", 4) == 0)\r\n\t\trec->rec_header.packet_header.pkt_encap = WTAP_ENCAP_PPP;\r\n\telse\r\n\t\trec->rec_header.packet_header.pkt_encap = WTAP_ENCAP_ETHERNET;\r\n\r\n\trec->rec_header.packet_header.caplen = offset;\r\n\r\n\treturn true;\r\n}", ".etscreen_read": "static bool netscreen_read(wtap *wth, wtap_rec *rec,\r\n    int *err, char **err_info, int64_t *data_offset)\r\n{\r\n\tint64_t\t\toffset;\r\n\tchar\t\tline[NETSCREEN_LINE_LENGTH];\r\n\r\n\t/* Find the next packet */\r\n\toffset = netscreen_seek_next_packet(wth, err, err_info, line);\r\n\tif (offset < 0)\r\n\t\treturn false;\r\n\r\n\t/* Parse the header and convert the ASCII hex dump to binary data */\r\n\tif (!parse_netscreen_packet(wth->fh, rec, line, err, err_info))\r\n\t\treturn false;\r\n\r\n\t/*\r\n\t * If the per-file encapsulation isn't known, set it to this\r\n\t * packet's encapsulation.\r\n\t *\r\n\t * If it *is* known, and it isn't this packet's encapsulation,\r\n\t * set it to WTAP_ENCAP_PER_PACKET, as this file doesn't\r\n\t * have a single encapsulation for all packets in the file.\r\n\t */\r\n\tif (wth->file_encap == WTAP_ENCAP_UNKNOWN)\r\n\t\twth->file_encap = rec->rec_header.packet_header.pkt_encap;\r\n\telse {\r\n\t\tif (wth->file_encap != rec->rec_header.packet_header.pkt_encap)\r\n\t\t\twth->file_encap = WTAP_ENCAP_PER_PACKET;\r\n\t}\r\n\r\n\t*data_offset = offset;\r\n\treturn true;\r\n}", ".etscreen_open": "wtap_open_return_val netscreen_open(wtap *wth, int *err, char **err_info)\r\n{\r\n\r\n\t/* Look for a NetScreen snoop header line */\r\n\tif (!netscreen_check_file_type(wth, err, err_info)) {\r\n\t\tif (*err != 0 && *err != WTAP_ERR_SHORT_READ)\r\n\t\t\treturn WTAP_OPEN_ERROR;\r\n\t\treturn WTAP_OPEN_NOT_MINE;\r\n\t}\r\n\r\n\tif (file_seek(wth->fh, 0L, SEEK_SET, err) == -1)\t/* rewind */\r\n\t\treturn WTAP_OPEN_ERROR;\r\n\r\n\twth->file_encap = WTAP_ENCAP_UNKNOWN;\r\n\twth->file_type_subtype = netscreen_file_type_subtype;\r\n\twth->snapshot_length = 0; /* not known */\r\n\twth->subtype_read = netscreen_read;\r\n\twth->subtype_seek_read = netscreen_seek_read;\r\n\twth->file_tsprec = WTAP_TSPREC_100_MSEC;\r\n\r\n\treturn WTAP_OPEN_MINE;\r\n}", ".etscreen_seek_read": "static bool\r\nnetscreen_seek_read(wtap *wth, int64_t seek_off, wtap_rec *rec,\r\n\tint *err, char **err_info)\r\n{\r\n\tchar\t\tline[NETSCREEN_LINE_LENGTH];\r\n\r\n\tif (file_seek(wth->random_fh, seek_off, SEEK_SET, err) == -1) {\r\n\t\treturn false;\r\n\t}\r\n\r\n\tif (file_gets(line, NETSCREEN_LINE_LENGTH, wth->random_fh) == NULL) {\r\n\t\t*err = file_error(wth->random_fh, err_info);\r\n\t\tif (*err == 0) {\r\n\t\t\t*err = WTAP_ERR_SHORT_READ;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\treturn parse_netscreen_packet(wth->random_fh, rec, line,\r\n\t    err, err_info);\r\n}"}, "function_name": "register_netscreen"}
{"function_id": null, "caller": {".ys_auth_passwd": "int\r\nsys_auth_passwd(struct ssh *ssh, const char *password)\r\n{\r\n\tAuthctxt *authctxt = ssh->authctxt;\r\n\tauth_session_t *as;\r\n\tstatic int expire_checked = 0;\r\n\r\n\tas = auth_usercheck(authctxt->pw->pw_name, authctxt->style, \"auth-ssh\",\r\n\t    (char *)password);\r\n\tif (as == NULL)\r\n\t\treturn (0);\r\n\tif (auth_getstate(as) & AUTH_PWEXPIRED) {\r\n\t\tauth_close(as);\r\n\t\tauth_restrict_session(ssh);\r\n\t\tauthctxt->force_pwchange = 1;\r\n\t\treturn (1);\r\n\t} else {\r\n\t\tif (!expire_checked) {\r\n\t\t\texpire_checked = 1;\r\n\t\t\twarn_expiry(authctxt, as);\r\n\t\t}\r\n\t\treturn (auth_close(as));\r\n\t}\r\n}", ".arn_expiry": "static void\r\nwarn_expiry(Authctxt *authctxt, auth_session_t *as)\r\n{\r\n\tint r;\r\n\tquad_t pwtimeleft, actimeleft, daysleft, pwwarntime, acwarntime;\r\n\r\n\tpwwarntime = acwarntime = TWO_WEEKS;\r\n\r\n\tpwtimeleft = auth_check_change(as);\r\n\tactimeleft = auth_check_expire(as);\r\n#ifdef HAVE_LOGIN_CAP\r\n\tif (authctxt->valid) {\r\n\t\tpwwarntime = login_getcaptime(lc, \"password-warn\", TWO_WEEKS,\r\n\t\t    TWO_WEEKS);\r\n\t\tacwarntime = login_getcaptime(lc, \"expire-warn\", TWO_WEEKS,\r\n\t\t    TWO_WEEKS);\r\n\t}\r\n#endif\r\n\tif (pwtimeleft != 0 && pwtimeleft < pwwarntime) {\r\n\t\tdaysleft = pwtimeleft / DAY + 1;\r\n\t\tif ((r = sshbuf_putf(loginmsg,\r\n\t\t    \"Your password will expire in %lld day%s.\\n\",\r\n\t\t    daysleft, daysleft == 1 ? \"\" : \"s\")) != 0)\r\n\t\t\tfatal_fr(r, \"buffer error\");\r\n\t}\r\n\tif (actimeleft != 0 && actimeleft < acwarntime) {\r\n\t\tdaysleft = actimeleft / DAY + 1;\r\n\t\tif ((r = sshbuf_putf(loginmsg,\r\n\t\t    \"Your account will expire in %lld day%s.\\n\",\r\n\t\t    daysleft, daysleft == 1 ? \"\" : \"s\")) != 0)\r\n\t\t\tfatal_fr(r, \"buffer error\");\r\n\t}\r\n}"}, "callee": {".ys_auth_passwd": "int\r\nsys_auth_passwd(struct ssh *ssh, const char *password)\r\n{\r\n\tAuthctxt *authctxt = ssh->authctxt;\r\n\tauth_session_t *as;\r\n\tstatic int expire_checked = 0;\r\n\r\n\tas = auth_usercheck(authctxt->pw->pw_name, authctxt->style, \"auth-ssh\",\r\n\t    (char *)password);\r\n\tif (as == NULL)\r\n\t\treturn (0);\r\n\tif (auth_getstate(as) & AUTH_PWEXPIRED) {\r\n\t\tauth_close(as);\r\n\t\tauth_restrict_session(ssh);\r\n\t\tauthctxt->force_pwchange = 1;\r\n\t\treturn (1);\r\n\t} else {\r\n\t\tif (!expire_checked) {\r\n\t\t\texpire_checked = 1;\r\n\t\t\twarn_expiry(authctxt, as);\r\n\t\t}\r\n\t\treturn (auth_close(as));\r\n\t}\r\n}", ".uth_password": "int\r\nauth_password(struct ssh *ssh, const char *password)\r\n{\r\n\tAuthctxt *authctxt = ssh->authctxt;\r\n\tstruct passwd *pw = authctxt->pw;\r\n\tint result, ok = authctxt->valid;\r\n#if defined(USE_SHADOW) && defined(HAS_SHADOW_EXPIRE)\r\n\tstatic int expire_checked = 0;\r\n#endif\r\n\r\n\tif (strlen(password) > MAX_PASSWORD_LEN)\r\n\t\treturn 0;\r\n\r\n#ifndef HAVE_CYGWIN\r\n\tif (pw->pw_uid == 0 && options.permit_root_login != PERMIT_YES)\r\n\t\tok = 0;\r\n#endif\r\n\tif (*password == '\\0' && options.permit_empty_passwd == 0)\r\n\t\treturn 0;\r\n\r\n#ifdef KRB5\r\n\tif (options.kerberos_authentication == 1) {\r\n\t\tint ret = auth_krb5_password(authctxt, password);\r\n\t\tif (ret == 1 || ret == 0)\r\n\t\t\treturn ret && ok;\r\n\t\t/* Fall back to ordinary passwd authentication. */\r\n\t}\r\n#endif\r\n#ifdef HAVE_CYGWIN\r\n\t{\r\n\t\tHANDLE hToken = cygwin_logon_user(pw, password);\r\n\r\n\t\tif (hToken == INVALID_HANDLE_VALUE)\r\n\t\t\treturn 0;\r\n\t\tcygwin_set_impersonation_token(hToken);\r\n\t\treturn ok;\r\n\t}\r\n#endif\r\n#ifdef USE_PAM\r\n\tif (options.use_pam)\r\n\t\treturn (sshpam_auth_passwd(authctxt, password) && ok);\r\n#endif\r\n#if defined(USE_SHADOW) && defined(HAS_SHADOW_EXPIRE)\r\n\tif (!expire_checked) {\r\n\t\texpire_checked = 1;\r\n\t\tif (auth_shadow_pwexpired(authctxt))\r\n\t\t\tauthctxt->force_pwchange = 1;\r\n\t}\r\n#endif\r\n\tresult = sys_auth_passwd(ssh, password);\r\n\tif (authctxt->force_pwchange)\r\n\t\tauth_restrict_session(ssh);\r\n\treturn (result && ok);\r\n}"}, "function_name": "sys_auth_passwd"}
{"function_id": null, "caller": {".et_next_char": "static inline unsigned int get_next_char(\r\n\t\tenum entity_charset charset,\r\n\t\tconst unsigned char *str,\r\n\t\tsize_t str_len,\r\n\t\tsize_t *cursor,\r\n\t\tzend_result *status)\r\n{\r\n\tsize_t pos = *cursor;\r\n\tunsigned int this_char = 0;\r\n\r\n\t*status = SUCCESS;\r\n\tassert(pos <= str_len);\r\n\r\n\tif (!CHECK_LEN(pos, 1))\r\n\t\tMB_FAILURE(pos, 1);\r\n\r\n\tswitch (charset) {\r\n\tcase cs_utf_8:\r\n\t\t{\r\n\t\t\t/* We'll follow strategy 2. from section 3.6.1 of UTR #36:\r\n\t\t\t * \"In a reported illegal byte sequence, do not include any\r\n\t\t\t *  non-initial byte that encodes a valid character or is a leading\r\n\t\t\t *  byte for a valid sequence.\" */\r\n\t\t\tunsigned char c;\r\n\t\t\tc = str[pos];\r\n\t\t\tif (c < 0x80) {\r\n\t\t\t\tthis_char = c;\r\n\t\t\t\tpos++;\r\n\t\t\t} else if (c < 0xc2) {\r\n\t\t\t\tMB_FAILURE(pos, 1);\r\n\t\t\t} else if (c < 0xe0) {\r\n\t\t\t\tif (!CHECK_LEN(pos, 2))\r\n\t\t\t\t\tMB_FAILURE(pos, 1);\r\n\r\n\t\t\t\tif (!utf8_trail(str[pos + 1])) {\r\n\t\t\t\t\tMB_FAILURE(pos, utf8_lead(str[pos + 1]) ? 1 : 2);\r\n\t\t\t\t}\r\n\t\t\t\tthis_char = ((c & 0x1f) << 6) | (str[pos + 1] & 0x3f);\r\n\t\t\t\tif (this_char < 0x80) { /* non-shortest form */\r\n\t\t\t\t\tMB_FAILURE(pos, 2);\r\n\t\t\t\t}\r\n\t\t\t\tpos += 2;\r\n\t\t\t} else if (c < 0xf0) {\r\n\t\t\t\tsize_t avail = str_len - pos;\r\n\r\n\t\t\t\tif (avail < 3 ||\r\n\t\t\t\t\t\t!utf8_trail(str[pos + 1]) || !utf8_trail(str[pos + 2])) {\r\n\t\t\t\t\tif (avail < 2 || utf8_lead(str[pos + 1]))\r\n\t\t\t\t\t\tMB_FAILURE(pos, 1);\r\n\t\t\t\t\telse if (avail < 3 || utf8_lead(str[pos + 2]))\r\n\t\t\t\t\t\tMB_FAILURE(pos, 2);\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tMB_FAILURE(pos, 3);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis_char = ((c & 0x0f) << 12) | ((str[pos + 1] & 0x3f) << 6) | (str[pos + 2] & 0x3f);\r\n\t\t\t\tif (this_char < 0x800) { /* non-shortest form */\r\n\t\t\t\t\tMB_FAILURE(pos, 3);\r\n\t\t\t\t} else if (this_char >= 0xd800 && this_char <= 0xdfff) { /* surrogate */\r\n\t\t\t\t\tMB_FAILURE(pos, 3);\r\n\t\t\t\t}\r\n\t\t\t\tpos += 3;\r\n\t\t\t} else if (c < 0xf5) {\r\n\t\t\t\tsize_t avail = str_len - pos;\r\n\r\n\t\t\t\tif (avail < 4 ||\r\n\t\t\t\t\t\t!utf8_trail(str[pos + 1]) || !utf8_trail(str[pos + 2]) ||\r\n\t\t\t\t\t\t!utf8_trail(str[pos + 3])) {\r\n\t\t\t\t\tif (avail < 2 || utf8_lead(str[pos + 1]))\r\n\t\t\t\t\t\tMB_FAILURE(pos, 1);\r\n\t\t\t\t\telse if (avail < 3 || utf8_lead(str[pos + 2]))\r\n\t\t\t\t\t\tMB_FAILURE(pos, 2);\r\n\t\t\t\t\telse if (avail < 4 || utf8_lead(str[pos + 3]))\r\n\t\t\t\t\t\tMB_FAILURE(pos, 3);\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tMB_FAILURE(pos, 4);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis_char = ((c & 0x07) << 18) | ((str[pos + 1] & 0x3f) << 12) | ((str[pos + 2] & 0x3f) << 6) | (str[pos + 3] & 0x3f);\r\n\t\t\t\tif (this_char < 0x10000 || this_char > 0x10FFFF) { /* non-shortest form or outside range */\r\n\t\t\t\t\tMB_FAILURE(pos, 4);\r\n\t\t\t\t}\r\n\t\t\t\tpos += 4;\r\n\t\t\t} else {\r\n\t\t\t\tMB_FAILURE(pos, 1);\r\n\t\t\t}\r\n\t\t}\r\n\t\tbreak;\r\n\r\n\tcase cs_big5:\r\n\t\t/* reference http://demo.icu-project.org/icu-bin/convexp?conv=big5 */\r\n\t\t{\r\n\t\t\tunsigned char c = str[pos];\r\n\t\t\tif (c >= 0x81 && c <= 0xFE) {\r\n\t\t\t\tunsigned char next;\r\n\t\t\t\tif (!CHECK_LEN(pos, 2))\r\n\t\t\t\t\tMB_FAILURE(pos, 1);\r\n\r\n\t\t\t\tnext = str[pos + 1];\r\n\r\n\t\t\t\tif ((next >= 0x40 && next <= 0x7E) ||\r\n\t\t\t\t\t\t(next >= 0xA1 && next <= 0xFE)) {\r\n\t\t\t\t\tthis_char = (c << 8) | next;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tMB_FAILURE(pos, 1);\r\n\t\t\t\t}\r\n\t\t\t\tpos += 2;\r\n\t\t\t} else {\r\n\t\t\t\tthis_char = c;\r\n\t\t\t\tpos += 1;\r\n\t\t\t}\r\n\t\t}\r\n\t\tbreak;\r\n\r\n\tcase cs_big5hkscs:\r\n\t\t{\r\n\t\t\tunsigned char c = str[pos];\r\n\t\t\tif (c >= 0x81 && c <= 0xFE) {\r\n\t\t\t\tunsigned char next;\r\n\t\t\t\tif (!CHECK_LEN(pos, 2))\r\n\t\t\t\t\tMB_FAILURE(pos, 1);\r\n\r\n\t\t\t\tnext = str[pos + 1];\r\n\r\n\t\t\t\tif ((next >= 0x40 && next <= 0x7E) ||\r\n\t\t\t\t\t\t(next >= 0xA1 && next <= 0xFE)) {\r\n\t\t\t\t\tthis_char = (c << 8) | next;\r\n\t\t\t\t} else if (next != 0x80 && next != 0xFF) {\r\n\t\t\t\t\tMB_FAILURE(pos, 1);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tMB_FAILURE(pos, 2);\r\n\t\t\t\t}\r\n\t\t\t\tpos += 2;\r\n\t\t\t} else {\r\n\t\t\t\tthis_char = c;\r\n\t\t\t\tpos += 1;\r\n\t\t\t}\r\n\t\t}\r\n\t\tbreak;\r\n\r\n\tcase cs_gb2312: /* EUC-CN */\r\n\t\t{\r\n\t\t\tunsigned char c = str[pos];\r\n\t\t\tif (c >= 0xA1 && c <= 0xFE) {\r\n\t\t\t\tunsigned char next;\r\n\t\t\t\tif (!CHECK_LEN(pos, 2))\r\n\t\t\t\t\tMB_FAILURE(pos, 1);\r\n\r\n\t\t\t\tnext = str[pos + 1];\r\n\r\n\t\t\t\tif (gb2312_trail(next)) {\r\n\t\t\t\t\tthis_char = (c << 8) | next;\r\n\t\t\t\t} else if (gb2312_lead(next)) {\r\n\t\t\t\t\tMB_FAILURE(pos, 1);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tMB_FAILURE(pos, 2);\r\n\t\t\t\t}\r\n\t\t\t\tpos += 2;\r\n\t\t\t} else if (gb2312_lead(c)) {\r\n\t\t\t\tthis_char = c;\r\n\t\t\t\tpos += 1;\r\n\t\t\t} else {\r\n\t\t\t\tMB_FAILURE(pos, 1);\r\n\t\t\t}\r\n\t\t}\r\n\t\tbreak;\r\n\r\n\tcase cs_sjis:\r\n\t\t{\r\n\t\t\tunsigned char c = str[pos];\r\n\t\t\tif ((c >= 0x81 && c <= 0x9F) || (c >= 0xE0 && c <= 0xFC)) {\r\n\t\t\t\tunsigned char next;\r\n\t\t\t\tif (!CHECK_LEN(pos, 2))\r\n\t\t\t\t\tMB_FAILURE(pos, 1);\r\n\r\n\t\t\t\tnext = str[pos + 1];\r\n\r\n\t\t\t\tif (sjis_trail(next)) {\r\n\t\t\t\t\tthis_char = (c << 8) | next;\r\n\t\t\t\t} else if (sjis_lead(next)) {\r\n\t\t\t\t\tMB_FAILURE(pos, 1);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tMB_FAILURE(pos, 2);\r\n\t\t\t\t}\r\n\t\t\t\tpos += 2;\r\n\t\t\t} else if (c < 0x80 || (c >= 0xA1 && c <= 0xDF)) {\r\n\t\t\t\tthis_char = c;\r\n\t\t\t\tpos += 1;\r\n\t\t\t} else {\r\n\t\t\t\tMB_FAILURE(pos, 1);\r\n\t\t\t}\r\n\t\t}\r\n\t\tbreak;\r\n\r\n\tcase cs_eucjp:\r\n\t\t{\r\n\t\t\tunsigned char c = str[pos];\r\n\r\n\t\t\tif (c >= 0xA1 && c <= 0xFE) {\r\n\t\t\t\tunsigned next;\r\n\t\t\t\tif (!CHECK_LEN(pos, 2))\r\n\t\t\t\t\tMB_FAILURE(pos, 1);\r\n\t\t\t\tnext = str[pos + 1];\r\n\r\n\t\t\t\tif (next >= 0xA1 && next <= 0xFE) {\r\n\t\t\t\t\t/* this a jis kanji char */\r\n\t\t\t\t\tthis_char = (c << 8) | next;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tMB_FAILURE(pos, (next != 0xA0 && next != 0xFF) ? 1 : 2);\r\n\t\t\t\t}\r\n\t\t\t\tpos += 2;\r\n\t\t\t} else if (c == 0x8E) {\r\n\t\t\t\tunsigned next;\r\n\t\t\t\tif (!CHECK_LEN(pos, 2))\r\n\t\t\t\t\tMB_FAILURE(pos, 1);\r\n\r\n\t\t\t\tnext = str[pos + 1];\r\n\t\t\t\tif (next >= 0xA1 && next <= 0xDF) {\r\n\t\t\t\t\t/* JIS X 0201 kana */\r\n\t\t\t\t\tthis_char = (c << 8) | next;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tMB_FAILURE(pos, (next != 0xA0 && next != 0xFF) ? 1 : 2);\r\n\t\t\t\t}\r\n\t\t\t\tpos += 2;\r\n\t\t\t} else if (c == 0x8F) {\r\n\t\t\t\tsize_t avail = str_len - pos;\r\n\r\n\t\t\t\tif (avail < 3 || !(str[pos + 1] >= 0xA1 && str[pos + 1] <= 0xFE) ||\r\n\t\t\t\t\t\t!(str[pos + 2] >= 0xA1 && str[pos + 2] <= 0xFE)) {\r\n\t\t\t\t\tif (avail < 2 || (str[pos + 1] != 0xA0 && str[pos + 1] != 0xFF))\r\n\t\t\t\t\t\tMB_FAILURE(pos, 1);\r\n\t\t\t\t\telse if (avail < 3 || (str[pos + 2] != 0xA0 && str[pos + 2] != 0xFF))\r\n\t\t\t\t\t\tMB_FAILURE(pos, 2);\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tMB_FAILURE(pos, 3);\r\n\t\t\t\t} else {\r\n\t\t\t\t\t/* JIS X 0212 hojo-kanji */\r\n\t\t\t\t\tthis_char = (c << 16) | (str[pos + 1] << 8) | str[pos + 2];\r\n\t\t\t\t}\r\n\t\t\t\tpos += 3;\r\n\t\t\t} else if (c != 0xA0 && c != 0xFF) {\r\n\t\t\t\t/* character encoded in 1 code unit */\r\n\t\t\t\tthis_char = c;\r\n\t\t\t\tpos += 1;\r\n\t\t\t} else {\r\n\t\t\t\tMB_FAILURE(pos, 1);\r\n\t\t\t}\r\n\t\t}\r\n\t\tbreak;\r\n\tdefault:\r\n\t\t/* single-byte charsets */\r\n\t\tthis_char = str[pos++];\r\n\t\tbreak;\r\n\t}\r\n\r\n\t*cursor = pos;\r\n\treturn this_char;\r\n}", ".nimap_bsearch": "static inline unsigned char unimap_bsearch(const uni_to_enc *table, unsigned code_key_a, size_t num)\r\n{\r\n\tconst uni_to_enc *l = table,\r\n\t\t\t\t\t *h = &table[num-1],\r\n\t\t\t\t\t *m;\r\n\tunsigned short code_key;\r\n\r\n\t/* we have no mappings outside the BMP */\r\n\tif (code_key_a > 0xFFFFU)\r\n\t\treturn 0;\r\n\r\n\tcode_key = (unsigned short) code_key_a;\r\n\r\n\twhile (l <= h) {\r\n\t\tm = l + (h - l) / 2;\r\n\t\tif (code_key < m->un_code_point)\r\n\t\t\th = m - 1;\r\n\t\telse if (code_key > m->un_code_point)\r\n\t\t\tl = m + 1;\r\n\t\telse\r\n\t\t\treturn m->cs_code;\r\n\t}\r\n\treturn 0;\r\n}", ".nicode_cp_is_allowed": "static inline int unicode_cp_is_allowed(unsigned uni_cp, int document_type)\r\n{\r\n\t/* XML 1.0\t\t\t\tHTML 4.01\t\t\tHTML 5\r\n\t * 0x09..0x0A\t\t\t0x09..0x0A\t\t\t0x09..0x0A\r\n\t * 0x0D\t\t\t\t\t0x0D\t\t\t\t0x0C..0x0D\r\n\t * 0x0020..0xD7FF\t\t0x20..0x7E\t\t\t0x20..0x7E\r\n\t *\t\t\t\t\t\t0x00A0..0xD7FF\t\t0x00A0..0xD7FF\r\n\t * 0xE000..0xFFFD\t\t0xE000..0x10FFFF\t0xE000..0xFDCF\r\n\t * 0x010000..0x10FFFF\t\t\t\t\t\t0xFDF0..0x10FFFF (*)\r\n\t *\r\n\t * (*) exclude code points where ((code & 0xFFFF) >= 0xFFFE)\r\n\t *\r\n\t * References:\r\n\t * XML 1.0:   <http://www.w3.org/TR/REC-xml/#charsets>\r\n\t * HTML 4.01: <http://www.w3.org/TR/1999/PR-html40-19990824/sgml/sgmldecl.html>\r\n\t * HTML 5:    <http://dev.w3.org/html5/spec/Overview.html#preprocessing-the-input-stream>\r\n\t *\r\n\t * Not sure this is the relevant part for HTML 5, though. I opted to\r\n\t * disallow the characters that would result in a parse error when\r\n\t * preprocessing of the input stream. See also section 8.1.3.\r\n\t *\r\n\t * It's unclear if XHTML 1.0 allows C1 characters. I'll opt to apply to\r\n\t * XHTML 1.0 the same rules as for XML 1.0.\r\n\t * See <http://cmsmcq.com/2007/C1.xml>.\r\n\t */\r\n\r\n\tswitch (document_type) {\r\n\tcase ENT_HTML_DOC_HTML401:\r\n\t\treturn (uni_cp >= 0x20 && uni_cp <= 0x7E) ||\r\n\t\t\t(uni_cp == 0x0A || uni_cp == 0x09 || uni_cp == 0x0D) ||\r\n\t\t\t(uni_cp >= 0xA0 && uni_cp <= 0xD7FF) ||\r\n\t\t\t(uni_cp >= 0xE000 && uni_cp <= 0x10FFFF);\r\n\tcase ENT_HTML_DOC_HTML5:\r\n\t\treturn (uni_cp >= 0x20 && uni_cp <= 0x7E) ||\r\n\t\t\t(uni_cp >= 0x09 && uni_cp <= 0x0D && uni_cp != 0x0B) || /* form feed U+0C allowed */\r\n\t\t\t(uni_cp >= 0xA0 && uni_cp <= 0xD7FF) ||\r\n\t\t\t(uni_cp >= 0xE000 && uni_cp <= 0x10FFFF &&\r\n\t\t\t\t((uni_cp & 0xFFFF) < 0xFFFE) && /* last two of each plane (nonchars) disallowed */\r\n\t\t\t\t(uni_cp < 0xFDD0 || uni_cp > 0xFDEF)); /* U+FDD0-U+FDEF (nonchars) disallowed */\r\n\tcase ENT_HTML_DOC_XHTML:\r\n\tcase ENT_HTML_DOC_XML1:\r\n\t\treturn (uni_cp >= 0x20 && uni_cp <= 0xD7FF) ||\r\n\t\t\t(uni_cp == 0x0A || uni_cp == 0x09 || uni_cp == 0x0D) ||\r\n\t\t\t(uni_cp >= 0xE000 && uni_cp <= 0x10FFFF && uni_cp != 0xFFFE && uni_cp != 0xFFFF);\r\n\tdefault:\r\n\t\treturn 1;\r\n\t}\r\n}", ".hp_utf32_utf8": "static inline size_t php_utf32_utf8(unsigned char *buf, unsigned k)\r\n{\r\n\tsize_t retval = 0;\r\n\r\n\t/* assert(0x0 <= k <= 0x10FFFF); */\r\n\r\n\tif (k < 0x80) {\r\n\t\tbuf[0] = k;\r\n\t\tretval = 1;\r\n\t} else if (k < 0x800) {\r\n\t\tbuf[0] = 0xc0 | (k >> 6);\r\n\t\tbuf[1] = 0x80 | (k & 0x3f);\r\n\t\tretval = 2;\r\n\t} else if (k < 0x10000) {\r\n\t\tbuf[0] = 0xe0 | (k >> 12);\r\n\t\tbuf[1] = 0x80 | ((k >> 6) & 0x3f);\r\n\t\tbuf[2] = 0x80 | (k & 0x3f);\r\n\t\tretval = 3;\r\n\t} else {\r\n\t\tbuf[0] = 0xf0 | (k >> 18);\r\n\t\tbuf[1] = 0x80 | ((k >> 12) & 0x3f);\r\n\t\tbuf[2] = 0x80 | ((k >> 6) & 0x3f);\r\n\t\tbuf[3] = 0x80 | (k & 0x3f);\r\n\t\tretval = 4;\r\n\t}\r\n\t/* UTF-8 has been restricted to max 4 bytes since RFC 3629 */\r\n\r\n\treturn retval;\r\n}", ".rocess_numeric_entity": "static inline zend_result process_numeric_entity(const char **buf, unsigned *code_point)\r\n{\r\n\tzend_long code_l;\r\n\tint hexadecimal = (**buf == 'x' || **buf == 'X'); /* TODO: XML apparently disallows \"X\" */\r\n\tchar *endptr;\r\n\r\n\tif (hexadecimal)\r\n\t\t(*buf)++;\r\n\r\n\t/* strtol allows whitespace and other stuff in the beginning\r\n\t\t* we're not interested */\r\n\tif ((hexadecimal && !isxdigit(**buf)) ||\r\n\t\t\t(!hexadecimal && !isdigit(**buf))) {\r\n\t\treturn FAILURE;\r\n\t}\r\n\r\n\tcode_l = ZEND_STRTOL(*buf, &endptr, hexadecimal ? 16 : 10);\r\n\t/* we're guaranteed there were valid digits, so *endptr > buf */\r\n\t*buf = endptr;\r\n\r\n\tif (**buf != ';')\r\n\t\treturn FAILURE;\r\n\r\n\t/* many more are invalid, but that depends on whether it's HTML\r\n\t * (and which version) or XML. */\r\n\tif (code_l > Z_L(0x10FFFF))\r\n\t\treturn FAILURE;\r\n\r\n\tif (code_point != NULL)\r\n\t\t*code_point = (unsigned)code_l;\r\n\r\n\treturn SUCCESS;\r\n}", ".esolve_named_entity_html": "static zend_result resolve_named_entity_html(const char *start, size_t length, const entity_ht *ht, unsigned *uni_cp1, unsigned *uni_cp2)\r\n{\r\n\tconst entity_cp_map *s;\r\n\tzend_ulong hash = zend_inline_hash_func(start, length);\r\n\r\n\ts = ht->buckets[hash % ht->num_elems];\r\n\twhile (s->entity) {\r\n\t\tif (s->entity_len == length) {\r\n\t\t\tif (memcmp(start, s->entity, length) == 0) {\r\n\t\t\t\t*uni_cp1 = s->codepoint1;\r\n\t\t\t\t*uni_cp2 = s->codepoint2;\r\n\t\t\t\treturn SUCCESS;\r\n\t\t\t}\r\n\t\t}\r\n\t\ts++;\r\n\t}\r\n\treturn FAILURE;\r\n}", ".ap_from_unicode": "static inline zend_result map_from_unicode(unsigned code, enum entity_charset charset, unsigned *res)\r\n{\r\n\tunsigned char found;\r\n\tconst uni_to_enc *table;\r\n\tsize_t table_size;\r\n\r\n\tswitch (charset) {\r\n\tcase cs_8859_1:\r\n\t\t/* identity mapping of code points to unicode */\r\n\t\tif (code > 0xFF) {\r\n\t\t\treturn FAILURE;\r\n\t\t}\r\n\t\t*res = code;\r\n\t\tbreak;\r\n\r\n\tcase cs_8859_5:\r\n\t\tif (code <= 0xA0 || code == 0xAD /* soft hyphen */) {\r\n\t\t\t*res = code;\r\n\t\t} else if (code == 0x2116) {\r\n\t\t\t*res = 0xF0; /* numero sign */\r\n\t\t} else if (code == 0xA7) {\r\n\t\t\t*res = 0xFD; /* section sign */\r\n\t\t} else if (code >= 0x0401 && code <= 0x045F) {\r\n\t\t\tif (code == 0x040D || code == 0x0450 || code == 0x045D)\r\n\t\t\t\treturn FAILURE;\r\n\t\t\t*res = code - 0x360;\r\n\t\t} else {\r\n\t\t\treturn FAILURE;\r\n\t\t}\r\n\t\tbreak;\r\n\r\n\tcase cs_8859_15:\r\n\t\tif (code < 0xA4 || (code > 0xBE && code <= 0xFF)) {\r\n\t\t\t*res = code;\r\n\t\t} else { /* between A4 and 0xBE */\r\n\t\t\tfound = unimap_bsearch(unimap_iso885915,\r\n\t\t\t\tcode, sizeof(unimap_iso885915) / sizeof(*unimap_iso885915));\r\n\t\t\tif (found)\r\n\t\t\t\t*res = found;\r\n\t\t\telse\r\n\t\t\t\treturn FAILURE;\r\n\t\t}\r\n\t\tbreak;\r\n\r\n\tcase cs_cp1252:\r\n\t\tif (code <= 0x7F || (code >= 0xA0 && code <= 0xFF)) {\r\n\t\t\t*res = code;\r\n\t\t} else {\r\n\t\t\tfound = unimap_bsearch(unimap_win1252,\r\n\t\t\t\tcode, sizeof(unimap_win1252) / sizeof(*unimap_win1252));\r\n\t\t\tif (found)\r\n\t\t\t\t*res = found;\r\n\t\t\telse\r\n\t\t\t\treturn FAILURE;\r\n\t\t}\r\n\t\tbreak;\r\n\r\n\tcase cs_macroman:\r\n\t\tif (code == 0x7F)\r\n\t\t\treturn FAILURE;\r\n\t\ttable = unimap_macroman;\r\n\t\ttable_size = sizeof(unimap_macroman) / sizeof(*unimap_macroman);\r\n\t\tgoto table_over_7F;\r\n\tcase cs_cp1251:\r\n\t\ttable = unimap_win1251;\r\n\t\ttable_size = sizeof(unimap_win1251) / sizeof(*unimap_win1251);\r\n\t\tgoto table_over_7F;\r\n\tcase cs_koi8r:\r\n\t\ttable = unimap_koi8r;\r\n\t\ttable_size = sizeof(unimap_koi8r) / sizeof(*unimap_koi8r);\r\n\t\tgoto table_over_7F;\r\n\tcase cs_cp866:\r\n\t\ttable = unimap_cp866;\r\n\t\ttable_size = sizeof(unimap_cp866) / sizeof(*unimap_cp866);\r\n\r\ntable_over_7F:\r\n\t\tif (code <= 0x7F) {\r\n\t\t\t*res = code;\r\n\t\t} else {\r\n\t\t\tfound = unimap_bsearch(table, code, table_size);\r\n\t\t\tif (found)\r\n\t\t\t\t*res = found;\r\n\t\t\telse\r\n\t\t\t\treturn FAILURE;\r\n\t\t}\r\n\t\tbreak;\r\n\r\n\t/* from here on, only map the possible characters in the ASCII range.\r\n\t * to improve support here, it's a matter of building the unicode mappings.\r\n\t * See <http://www.unicode.org/Public/6.0.0/ucd/Unihan.zip> */\r\n\tcase cs_sjis:\r\n\tcase cs_eucjp:\r\n\t\t/* we interpret 0x5C as the Yen symbol. This is not universal.\r\n\t\t * See <http://www.w3.org/Submission/japanese-xml/#ambiguity_of_yen> */\r\n\t\tif (code >= 0x20 && code <= 0x7D) {\r\n\t\t\tif (code == 0x5C)\r\n\t\t\t\treturn FAILURE;\r\n\t\t\t*res = code;\r\n\t\t} else {\r\n\t\t\treturn FAILURE;\r\n\t\t}\r\n\t\tbreak;\r\n\r\n\tcase cs_big5:\r\n\tcase cs_big5hkscs:\r\n\tcase cs_gb2312:\r\n\t\tif (code >= 0x20 && code <= 0x7D) {\r\n\t\t\t*res = code;\r\n\t\t} else {\r\n\t\t\treturn FAILURE;\r\n\t\t}\r\n\t\tbreak;\r\n\r\n\tdefault:\r\n\t\treturn FAILURE;\r\n\t}\r\n\r\n\treturn SUCCESS;\r\n}", ".rite_octet_sequence": "static inline size_t write_octet_sequence(unsigned char *buf, enum entity_charset charset, unsigned code) {\r\n\t/* code is not necessarily a unicode code point */\r\n\tswitch (charset) {\r\n\tcase cs_utf_8:\r\n\t\treturn php_utf32_utf8(buf, code);\r\n\r\n\tcase cs_8859_1:\r\n\tcase cs_cp1252:\r\n\tcase cs_8859_15:\r\n\tcase cs_koi8r:\r\n\tcase cs_cp1251:\r\n\tcase cs_8859_5:\r\n\tcase cs_cp866:\r\n\tcase cs_macroman:\r\n\t\t/* single byte stuff */\r\n\t\t*buf = code;\r\n\t\treturn 1;\r\n\r\n\tcase cs_big5:\r\n\tcase cs_big5hkscs:\r\n\tcase cs_sjis:\r\n\tcase cs_gb2312:\r\n\t\t/* we don't have complete unicode mappings for these yet in entity_decode,\r\n\t\t * and we opt to pass through the octet sequences for these in htmlentities\r\n\t\t * instead of converting to an int and then converting back. */\r\n#if 0\r\n\t\treturn php_mb2_int_to_char(buf, code);\r\n#else\r\n\t\tZEND_ASSERT(code <= 0xFFU);\r\n\t\t*buf = code;\r\n\t\treturn 1;\r\n#endif\r\n\r\n\tcase cs_eucjp:\r\n#if 0 /* idem */\r\n\t\treturn php_mb2_int_to_char(buf, code);\r\n#else\r\n\t\tZEND_ASSERT(code <= 0xFFU);\r\n\t\t*buf = code;\r\n\t\treturn 1;\r\n#endif\r\n\r\n\tdefault:\r\n\t\tassert(0);\r\n\t\treturn 0;\r\n\t}\r\n}"}, "callee": {".hp_next_utf8_char": "PHPAPI unsigned int php_next_utf8_char(\r\n\t\tconst unsigned char *str,\r\n\t\tsize_t str_len,\r\n\t\tsize_t *cursor,\r\n\t\tzend_result *status)\r\n{\r\n\treturn get_next_char(cs_utf_8, str, str_len, cursor, status);\r\n}", ".ind_entity_for_char": "static inline void find_entity_for_char(\r\n\tunsigned int k,\r\n\tenum entity_charset charset,\r\n\tconst entity_stage1_row *table,\r\n\tconst unsigned char **entity,\r\n\tsize_t *entity_len,\r\n\tconst unsigned char *old,\r\n\tsize_t oldlen,\r\n\tsize_t *cursor)\r\n{\r\n\tunsigned stage1_idx = ENT_STAGE1_INDEX(k);\r\n\tconst entity_stage3_row *c;\r\n\r\n\tif (stage1_idx > 0x1D) {\r\n\t\t*entity     = NULL;\r\n\t\t*entity_len = 0;\r\n\t\treturn;\r\n\t}\r\n\r\n\tc = &table[stage1_idx][ENT_STAGE2_INDEX(k)][ENT_STAGE3_INDEX(k)];\r\n\r\n\tif (!c->ambiguous) {\r\n\t\t*entity     = (const unsigned char *)c->data.ent.entity;\r\n\t\t*entity_len = c->data.ent.entity_len;\r\n\t} else {\r\n\t\t/* peek at next char */\r\n\t\tsize_t cursor_before = *cursor;\r\n\t\tzend_result status = SUCCESS;\r\n\t\tunsigned next_char;\r\n\r\n\t\tif (!(*cursor < oldlen))\r\n\t\t\tgoto no_suitable_2nd;\r\n\r\n\t\tnext_char = get_next_char(charset, old, oldlen, cursor, &status);\r\n\r\n\t\tif (status == FAILURE)\r\n\t\t\tgoto no_suitable_2nd;\r\n\r\n\t\t{\r\n\t\t\tconst entity_multicodepoint_row *s, *e;\r\n\r\n\t\t\ts = &c->data.multicodepoint_table[1];\r\n\t\t\te = s - 1 + c->data.multicodepoint_table[0].leading_entry.size;\r\n\t\t\t/* we could do a binary search but it's not worth it since we have\r\n\t\t\t * at most two entries... */\r\n\t\t\tfor ( ; s <= e; s++) {\r\n\t\t\t\tif (s->normal_entry.second_cp == next_char) {\r\n\t\t\t\t\t*entity     = (const unsigned char *) s->normal_entry.entity;\r\n\t\t\t\t\t*entity_len = s->normal_entry.entity_len;\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\nno_suitable_2nd:\r\n\t\t*cursor = cursor_before;\r\n\t\t*entity = (const unsigned char *)\r\n\t\t\tc->data.multicodepoint_table[0].leading_entry.default_entity;\r\n\t\t*entity_len = c->data.multicodepoint_table[0].leading_entry.default_entity_len;\r\n\t}\r\n}", ".rite_octet_sequence": "static inline size_t write_octet_sequence(unsigned char *buf, enum entity_charset charset, unsigned code) {\r\n\t/* code is not necessarily a unicode code point */\r\n\tswitch (charset) {\r\n\tcase cs_utf_8:\r\n\t\treturn php_utf32_utf8(buf, code);\r\n\r\n\tcase cs_8859_1:\r\n\tcase cs_cp1252:\r\n\tcase cs_8859_15:\r\n\tcase cs_koi8r:\r\n\tcase cs_cp1251:\r\n\tcase cs_8859_5:\r\n\tcase cs_cp866:\r\n\tcase cs_macroman:\r\n\t\t/* single byte stuff */\r\n\t\t*buf = code;\r\n\t\treturn 1;\r\n\r\n\tcase cs_big5:\r\n\tcase cs_big5hkscs:\r\n\tcase cs_sjis:\r\n\tcase cs_gb2312:\r\n\t\t/* we don't have complete unicode mappings for these yet in entity_decode,\r\n\t\t * and we opt to pass through the octet sequences for these in htmlentities\r\n\t\t * instead of converting to an int and then converting back. */\r\n#if 0\r\n\t\treturn php_mb2_int_to_char(buf, code);\r\n#else\r\n\t\tZEND_ASSERT(code <= 0xFFU);\r\n\t\t*buf = code;\r\n\t\treturn 1;\r\n#endif\r\n\r\n\tcase cs_eucjp:\r\n#if 0 /* idem */\r\n\t\treturn php_mb2_int_to_char(buf, code);\r\n#else\r\n\t\tZEND_ASSERT(code <= 0xFFU);\r\n\t\t*buf = code;\r\n\t\treturn 1;\r\n#endif\r\n\r\n\tdefault:\r\n\t\tassert(0);\r\n\t\treturn 0;\r\n\t}\r\n}", ".ap_from_unicode": "static inline zend_result map_from_unicode(unsigned code, enum entity_charset charset, unsigned *res)\r\n{\r\n\tunsigned char found;\r\n\tconst uni_to_enc *table;\r\n\tsize_t table_size;\r\n\r\n\tswitch (charset) {\r\n\tcase cs_8859_1:\r\n\t\t/* identity mapping of code points to unicode */\r\n\t\tif (code > 0xFF) {\r\n\t\t\treturn FAILURE;\r\n\t\t}\r\n\t\t*res = code;\r\n\t\tbreak;\r\n\r\n\tcase cs_8859_5:\r\n\t\tif (code <= 0xA0 || code == 0xAD /* soft hyphen */) {\r\n\t\t\t*res = code;\r\n\t\t} else if (code == 0x2116) {\r\n\t\t\t*res = 0xF0; /* numero sign */\r\n\t\t} else if (code == 0xA7) {\r\n\t\t\t*res = 0xFD; /* section sign */\r\n\t\t} else if (code >= 0x0401 && code <= 0x045F) {\r\n\t\t\tif (code == 0x040D || code == 0x0450 || code == 0x045D)\r\n\t\t\t\treturn FAILURE;\r\n\t\t\t*res = code - 0x360;\r\n\t\t} else {\r\n\t\t\treturn FAILURE;\r\n\t\t}\r\n\t\tbreak;\r\n\r\n\tcase cs_8859_15:\r\n\t\tif (code < 0xA4 || (code > 0xBE && code <= 0xFF)) {\r\n\t\t\t*res = code;\r\n\t\t} else { /* between A4 and 0xBE */\r\n\t\t\tfound = unimap_bsearch(unimap_iso885915,\r\n\t\t\t\tcode, sizeof(unimap_iso885915) / sizeof(*unimap_iso885915));\r\n\t\t\tif (found)\r\n\t\t\t\t*res = found;\r\n\t\t\telse\r\n\t\t\t\treturn FAILURE;\r\n\t\t}\r\n\t\tbreak;\r\n\r\n\tcase cs_cp1252:\r\n\t\tif (code <= 0x7F || (code >= 0xA0 && code <= 0xFF)) {\r\n\t\t\t*res = code;\r\n\t\t} else {\r\n\t\t\tfound = unimap_bsearch(unimap_win1252,\r\n\t\t\t\tcode, sizeof(unimap_win1252) / sizeof(*unimap_win1252));\r\n\t\t\tif (found)\r\n\t\t\t\t*res = found;\r\n\t\t\telse\r\n\t\t\t\treturn FAILURE;\r\n\t\t}\r\n\t\tbreak;\r\n\r\n\tcase cs_macroman:\r\n\t\tif (code == 0x7F)\r\n\t\t\treturn FAILURE;\r\n\t\ttable = unimap_macroman;\r\n\t\ttable_size = sizeof(unimap_macroman) / sizeof(*unimap_macroman);\r\n\t\tgoto table_over_7F;\r\n\tcase cs_cp1251:\r\n\t\ttable = unimap_win1251;\r\n\t\ttable_size = sizeof(unimap_win1251) / sizeof(*unimap_win1251);\r\n\t\tgoto table_over_7F;\r\n\tcase cs_koi8r:\r\n\t\ttable = unimap_koi8r;\r\n\t\ttable_size = sizeof(unimap_koi8r) / sizeof(*unimap_koi8r);\r\n\t\tgoto table_over_7F;\r\n\tcase cs_cp866:\r\n\t\ttable = unimap_cp866;\r\n\t\ttable_size = sizeof(unimap_cp866) / sizeof(*unimap_cp866);\r\n\r\ntable_over_7F:\r\n\t\tif (code <= 0x7F) {\r\n\t\t\t*res = code;\r\n\t\t} else {\r\n\t\t\tfound = unimap_bsearch(table, code, table_size);\r\n\t\t\tif (found)\r\n\t\t\t\t*res = found;\r\n\t\t\telse\r\n\t\t\t\treturn FAILURE;\r\n\t\t}\r\n\t\tbreak;\r\n\r\n\t/* from here on, only map the possible characters in the ASCII range.\r\n\t * to improve support here, it's a matter of building the unicode mappings.\r\n\t * See <http://www.unicode.org/Public/6.0.0/ucd/Unihan.zip> */\r\n\tcase cs_sjis:\r\n\tcase cs_eucjp:\r\n\t\t/* we interpret 0x5C as the Yen symbol. This is not universal.\r\n\t\t * See <http://www.w3.org/Submission/japanese-xml/#ambiguity_of_yen> */\r\n\t\tif (code >= 0x20 && code <= 0x7D) {\r\n\t\t\tif (code == 0x5C)\r\n\t\t\t\treturn FAILURE;\r\n\t\t\t*res = code;\r\n\t\t} else {\r\n\t\t\treturn FAILURE;\r\n\t\t}\r\n\t\tbreak;\r\n\r\n\tcase cs_big5:\r\n\tcase cs_big5hkscs:\r\n\tcase cs_gb2312:\r\n\t\tif (code >= 0x20 && code <= 0x7D) {\r\n\t\t\t*res = code;\r\n\t\t} else {\r\n\t\t\treturn FAILURE;\r\n\t\t}\r\n\t\tbreak;\r\n\r\n\tdefault:\r\n\t\treturn FAILURE;\r\n\t}\r\n\r\n\treturn SUCCESS;\r\n}", ".raverse_for_entities": "static void traverse_for_entities(\r\n\tconst zend_string *input,\r\n\tzend_string *output, /* should have allocated TRAVERSE_FOR_ENTITIES_EXPAND_SIZE(olden) */\r\n\tconst int all,\r\n\tconst int flags,\r\n\tconst entity_ht *inv_map,\r\n\tconst enum entity_charset charset)\r\n{\r\n\tconst char *current_ptr = ZSTR_VAL(input);\r\n\tconst char *input_end   = current_ptr + ZSTR_LEN(input); /* terminator address */\r\n\tchar *output_ptr\t\t= ZSTR_VAL(output);\r\n\tconst int doctype\t   = flags & ENT_HTML_DOC_TYPE_MASK;\r\n\r\n\twhile (current_ptr < input_end) {\r\n\t\tconst char *ampersand_ptr = memchr(current_ptr, '&', input_end - current_ptr);\r\n\t\tif (!ampersand_ptr) {\r\n\t\t\tconst size_t tail_len = input_end - current_ptr;\r\n\t\t\tif (tail_len > 0) {\r\n\t\t\t\tmemcpy(output_ptr, current_ptr, tail_len);\r\n\t\t\t\toutput_ptr += tail_len;\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\t/* Copy everything up to the found '&' */\r\n\t\tconst size_t chunk_len = ampersand_ptr - current_ptr;\r\n\t\tif (chunk_len > 0) {\r\n\t\t\tmemcpy(output_ptr, current_ptr, chunk_len);\r\n\t\t\toutput_ptr += chunk_len;\r\n\t\t}\r\n\r\n\t\t/* Now current_ptr points to the '&' character. */\r\n\t\tcurrent_ptr = ampersand_ptr;\r\n\r\n\t\t/* If there are less than 4 bytes remaining, there isn't enough for an entity - \r\n\t\t * copy '&' as a normal character. */\r\n\t\tif (input_end - current_ptr < 4) {\r\n\t\t\tconst size_t remaining = input_end - current_ptr;\r\n\t\t\tmemcpy(output_ptr, current_ptr, remaining);\r\n\t\t\toutput_ptr += remaining;\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\tunsigned code = 0, code2 = 0;\r\n\t\tconst char *entity_end_ptr = NULL;\r\n\r\n\t\tif (current_ptr[1] == '#') {\r\n\t\t\t/* Processing numeric entity */\r\n\t\t\tconst char *num_start = current_ptr + 2;\r\n\t\t\tentity_end_ptr = num_start;\r\n\t\t\tif (process_numeric_entity(&entity_end_ptr, &code) == FAILURE) {\r\n\t\t\t\tgoto invalid_incomplete_entity;\r\n\t\t\t}\r\n\t\t\tif (!all && (code > 63U || stage3_table_be_apos_00000[code].data.ent.entity == NULL)) {\r\n\t\t\t\t/* If we're in htmlspecialchars_decode, we're only decoding entities\r\n\t\t\t\t * that represent &, <, >, \" and '. Is this one of them? */\r\n\t\t\t\tgoto invalid_incomplete_entity;\r\n\t\t\t} else if (!unicode_cp_is_allowed(code, doctype) ||\r\n\t\t\t\t\t   (doctype == ENT_HTML_DOC_HTML5 && code == 0x0D)) {\r\n\t\t\t\t/* are we allowed to decode this entity in this document type?\r\n\t\t\t\t * HTML 5 is the only that has a character that cannot be used in\r\n\t\t\t\t * a numeric entity but is allowed literally (U+000D). The\r\n\t\t\t\t * unoptimized version would be ... || !numeric_entity_is_allowed(code) */\r\n\t\t\t\tgoto invalid_incomplete_entity;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\t/* Processing named entity */\r\n\t\t\tconst char *name_start = current_ptr + 1;\r\n\t\t\t/* Search for ';' */\r\n\t\t\tconst size_t max_search_len = MIN(LONGEST_ENTITY_LENGTH + 1, input_end - name_start);\r\n\t\t\tconst char *semi_colon_ptr = memchr(name_start, ';', max_search_len);\r\n\t\t\tif (!semi_colon_ptr) {\r\n\t\t\t\tgoto invalid_incomplete_entity;\r\n\t\t\t} else {\r\n\t\t\t\tconst size_t name_len = semi_colon_ptr - name_start;\r\n\t\t\t\tif (name_len == 0) {\r\n\t\t\t\t\tgoto invalid_incomplete_entity;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (resolve_named_entity_html(name_start, name_len, inv_map, &code, &code2) == FAILURE) {\r\n\t\t\t\t\t\tif (doctype == ENT_HTML_DOC_XHTML && name_len == 4 &&\r\n\t\t\t\t\t\t\tname_start[0] == 'a' && name_start[1] == 'p' &&\r\n\t\t\t\t\t\t\tname_start[2] == 'o' && name_start[3] == 's')\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t/* uses html4 inv_map, which doesn't include apos;. This is a\r\n\t\t\t\t\t\t\t * hack to support it */\r\n\t\t\t\t\t\t\tcode = (unsigned)'\\'';\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tgoto invalid_incomplete_entity;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tentity_end_ptr = semi_colon_ptr;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t/* At this stage the entity_end_ptr should be always set. */\r\n\t\tZEND_ASSERT(entity_end_ptr != NULL);\r\n\r\n\t\t/* Check if quotes are allowed for entities representing ' or \" */\r\n\t\tif ((code == '\\'' && !(flags & ENT_HTML_QUOTE_SINGLE)) ||\r\n\t\t\t(code == '\"'  && !(flags & ENT_HTML_QUOTE_DOUBLE)))\r\n\t\t{\r\n\t\t\tgoto invalid_complete_entity;\r\n\t\t}\r\n\r\n\t\t/* UTF-8 doesn't need mapping (ISO-8859-1 doesn't either, but\r\n\t\t * the call is needed to ensure the codepoint <= U+00FF)  */\r\n\t\tif (charset != cs_utf_8) {\r\n\t\t\t/* replace unicode code point */\r\n\t\t\tif (map_from_unicode(code, charset, &code) == FAILURE || code2 != 0) {\r\n\t\t\t\tgoto invalid_complete_entity;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t/* Write the parsed entity into the output buffer */\r\n\t\toutput_ptr += write_octet_sequence((unsigned char*)output_ptr, charset, code);\r\n\t\tif (code2) {\r\n\t\t\toutput_ptr += write_octet_sequence((unsigned char*)output_ptr, charset, code2);\r\n\t\t}\r\n\t\t/* Move current_ptr past the semicolon */\r\n\t\tcurrent_ptr = entity_end_ptr + 1;\r\n\t\tcontinue;\r\n\r\ninvalid_incomplete_entity:\r\n\t\t/* If the entity is invalid at parse stage or entity_end_ptr was never found, copy '&' as normal */\r\n\t\t*output_ptr++ = *current_ptr++;\r\n\t\tcontinue;\r\n\r\ninvalid_complete_entity:\r\n\t\t/* If the entity became invalid after we found entity_end_ptr */\r\n\t\tif (entity_end_ptr) {\r\n\t\t\tconst size_t len = entity_end_ptr - current_ptr;\r\n\t\t\tmemcpy(output_ptr, current_ptr, len);\r\n\t\t\toutput_ptr += len;\r\n\t\t\tcurrent_ptr = entity_end_ptr;\r\n\t\t} else {\r\n\t\t\t*output_ptr++ = *current_ptr++;\r\n\t\t}\r\n\t\tcontinue;\r\n\t}\r\n\r\n\t*output_ptr = '\\0';\r\n\tZSTR_LEN(output) = (size_t)(output_ptr - ZSTR_VAL(output));\r\n}", ".umeric_entity_is_allowed": "static inline int numeric_entity_is_allowed(unsigned uni_cp, int document_type)\r\n{\r\n\t/* less restrictive than unicode_cp_is_allowed */\r\n\tswitch (document_type) {\r\n\tcase ENT_HTML_DOC_HTML401:\r\n\t\t/* all non-SGML characters (those marked with UNUSED in DESCSET) should be\r\n\t\t * representable with numeric entities */\r\n\t\treturn uni_cp <= 0x10FFFF;\r\n\tcase ENT_HTML_DOC_HTML5:\r\n\t\t/* 8.1.4. The numeric character reference forms described above are allowed to\r\n\t\t * reference any Unicode code point other than U+0000, U+000D, permanently\r\n\t\t * undefined Unicode characters (noncharacters), and control characters other\r\n\t\t * than space characters (U+0009, U+000A, U+000C and U+000D) */\r\n\t\t/* seems to allow surrogate characters, then */\r\n\t\treturn (uni_cp >= 0x20 && uni_cp <= 0x7E) ||\r\n\t\t\t(uni_cp >= 0x09 && uni_cp <= 0x0C && uni_cp != 0x0B) || /* form feed U+0C allowed, but not U+0D */\r\n\t\t\t(uni_cp >= 0xA0 && uni_cp <= 0x10FFFF &&\r\n\t\t\t\t((uni_cp & 0xFFFF) < 0xFFFE) && /* last two of each plane (nonchars) disallowed */\r\n\t\t\t\t(uni_cp < 0xFDD0 || uni_cp > 0xFDEF)); /* U+FDD0-U+FDEF (nonchars) disallowed */\r\n\tcase ENT_HTML_DOC_XHTML:\r\n\tcase ENT_HTML_DOC_XML1:\r\n\t\t/* OTOH, XML 1.0 requires \"character references to match the production for Char\r\n\t\t * See <http://www.w3.org/TR/REC-xml/#NT-CharRef> */\r\n\t\treturn unicode_cp_is_allowed(uni_cp, document_type);\r\n\tdefault:\r\n\t\treturn 1;\r\n\t}\r\n}"}, "function_name": "php_html_entities"}
{"function_id": null, "caller": {".ernelBessel_J1": "static double KernelBessel_J1(const double x)\r\n{\r\n\tdouble p, q;\r\n\r\n\tregister long i;\r\n\r\n\tstatic const double\r\n\tPone[] =\r\n\t{\r\n\t\t0.581199354001606143928050809e+21,\r\n\t\t-0.6672106568924916298020941484e+20,\r\n\t\t0.2316433580634002297931815435e+19,\r\n\t\t-0.3588817569910106050743641413e+17,\r\n\t\t0.2908795263834775409737601689e+15,\r\n\t\t-0.1322983480332126453125473247e+13,\r\n\t\t0.3413234182301700539091292655e+10,\r\n\t\t-0.4695753530642995859767162166e+7,\r\n\t\t0.270112271089232341485679099e+4\r\n\t},\r\n\tQone[] =\r\n\t{\r\n\t\t0.11623987080032122878585294e+22,\r\n\t\t0.1185770712190320999837113348e+20,\r\n\t\t0.6092061398917521746105196863e+17,\r\n\t\t0.2081661221307607351240184229e+15,\r\n\t\t0.5243710262167649715406728642e+12,\r\n\t\t0.1013863514358673989967045588e+10,\r\n\t\t0.1501793594998585505921097578e+7,\r\n\t\t0.1606931573481487801970916749e+4,\r\n\t\t0.1e+1\r\n\t};\r\n\r\n\tp = Pone[8];\r\n\tq = Qone[8];\r\n\tfor (i=7; i >= 0; i--)\r\n\t{\r\n\t\tp = p*x*x+Pone[i];\r\n\t\tq = q*x*x+Qone[i];\r\n\t}\r\n\treturn (double)(p/q);\r\n}", ".ernelBessel_P1": "static double KernelBessel_P1(const double x)\r\n{\r\n\tdouble p, q;\r\n\r\n\tregister long i;\r\n\r\n\tstatic const double\r\n\tPone[] =\r\n\t{\r\n\t\t0.352246649133679798341724373e+5,\r\n\t\t0.62758845247161281269005675e+5,\r\n\t\t0.313539631109159574238669888e+5,\r\n\t\t0.49854832060594338434500455e+4,\r\n\t\t0.2111529182853962382105718e+3,\r\n\t\t0.12571716929145341558495e+1\r\n\t},\r\n\tQone[] =\r\n\t{\r\n\t\t0.352246649133679798068390431e+5,\r\n\t\t0.626943469593560511888833731e+5,\r\n\t\t0.312404063819041039923015703e+5,\r\n\t\t0.4930396490181088979386097e+4,\r\n\t\t0.2030775189134759322293574e+3,\r\n\t\t0.1e+1\r\n\t};\r\n\r\n\tp = Pone[5];\r\n\tq = Qone[5];\r\n\tfor (i=4; i >= 0; i--)\r\n\t{\r\n\t\tp = p*(8.0/x)*(8.0/x)+Pone[i];\r\n\t\tq = q*(8.0/x)*(8.0/x)+Qone[i];\r\n\t}\r\n\treturn (double)(p/q);\r\n}", ".ernelBessel_Q1": "static double KernelBessel_Q1(const double x)\r\n{\r\n\tdouble p, q;\r\n\r\n\tregister long i;\r\n\r\n\tstatic const double\r\n\tPone[] =\r\n\t{\r\n\t\t0.3511751914303552822533318e+3,\r\n\t\t0.7210391804904475039280863e+3,\r\n\t\t0.4259873011654442389886993e+3,\r\n\t\t0.831898957673850827325226e+2,\r\n\t\t0.45681716295512267064405e+1,\r\n\t\t0.3532840052740123642735e-1\r\n\t},\r\n\tQone[] =\r\n\t{\r\n\t\t0.74917374171809127714519505e+4,\r\n\t\t0.154141773392650970499848051e+5,\r\n\t\t0.91522317015169922705904727e+4,\r\n\t\t0.18111867005523513506724158e+4,\r\n\t\t0.1038187585462133728776636e+3,\r\n\t\t0.1e+1\r\n\t};\r\n\r\n\tp = Pone[5];\r\n\tq = Qone[5];\r\n\tfor (i=4; i >= 0; i--)\r\n\t{\r\n\t\tp = p*(8.0/x)*(8.0/x)+Pone[i];\r\n\t\tq = q*(8.0/x)*(8.0/x)+Qone[i];\r\n\t}\r\n\treturn (double)(p/q);\r\n}", ".ernelBessel_Order1": "static double KernelBessel_Order1(double x)\r\n{\r\n\tdouble p, q;\r\n\r\n\tif (x == 0.0)\r\n\t\treturn (0.0f);\r\n\tp = x;\r\n\tif (x < 0.0)\r\n\t\tx=(-x);\r\n\tif (x < 8.0)\r\n\t\treturn (p*KernelBessel_J1(x));\r\n\tq = (double)sqrt(2.0f/(M_PI*x))*(double)(KernelBessel_P1(x)*(1.0f/sqrt(2.0f)*(sin(x)-cos(x)))-8.0f/x*KernelBessel_Q1(x)*\r\n\t\t(-1.0f/sqrt(2.0f)*(sin(x)+cos(x))));\r\n\tif (p < 0.0f)\r\n\t\tq = (-q);\r\n\treturn (q);\r\n}", ".ilter_blackman": "static double filter_blackman(const double x, const double support)\r\n{\r\n\tARG_NOT_USED(support);\r\n\treturn (0.42f+0.5f*(double)cos(M_PI*x)+0.08f*(double)cos(2.0f*M_PI*x));\r\n}", ".ilter_bessel": "static double filter_bessel(const double x, const double support)\r\n{\r\n\tARG_NOT_USED(support);\r\n\tif (x == 0.0f)\r\n\t\treturn (double)(M_PI/4.0f);\r\n\treturn (KernelBessel_Order1((double)M_PI*x)/(2.0f*x));\r\n}", ".ilter_sinc": "static double filter_sinc(const double x, const double support)\r\n{\r\n\tARG_NOT_USED(support);\r\n\t/* X-scaled Sinc(x) function. */\r\n\tif (x == 0.0) return(1.0);\r\n\treturn (sin(M_PI * (double) x) / (M_PI * (double) x));\r\n}", ".etPixelOverflowTC": "static inline int getPixelOverflowTC(gdImagePtr im, const int x, const int y, const int bgColor /* 31bit ARGB TC */)\r\n{\r\n\tif (gdImageBoundsSafe(im, x, y)) {\r\n\t\tconst int c = im->tpixels[y][x];\r\n\t\tif (c == im->transparent) {\r\n\t\t\treturn bgColor == -1 ? gdTrueColorAlpha(0, 0, 0, 127) : bgColor;\r\n\t\t}\r\n\t\treturn c;  /* 31bit ARGB TC */\r\n\t} else {\r\n\t\treturn bgColor;  /* 31bit ARGB TC */\r\n\t}\r\n}", ".etPixelOverflowPalette": "static inline int getPixelOverflowPalette(gdImagePtr im, const int x, const int y, const int bgColor  /* 31bit ARGB TC */)\r\n{\r\n\tif (gdImageBoundsSafe(im, x, y)) {\r\n\t\tconst int c = im->pixels[y][x];\r\n\t\tif (c == im->transparent) {\r\n\t\t\treturn bgColor == -1 ? gdTrueColorAlpha(0, 0, 0, 127) : bgColor;\r\n\t\t}\r\n\t\treturn colorIndex2RGBA(c);\r\n\t} else {\r\n\t\treturn bgColor;  /* 31bit ARGB TC */\r\n\t}\r\n}", ".etPixelInterpolateWeight": "static int getPixelInterpolateWeight(gdImagePtr im, const double x, const double y, const int bgColor)\r\n{\r\n\t/* Closest pixel <= (xf,yf) */\r\n\tint sx = (int)(x);\r\n\tint sy = (int)(y);\r\n\tconst double xf = x - (double)sx;\r\n\tconst double yf = y - (double)sy;\r\n\tconst double nxf = (double) 1.0 - xf;\r\n\tconst double nyf = (double) 1.0 - yf;\r\n\tconst double m1 = xf * yf;\r\n\tconst double m2 = nxf * yf;\r\n\tconst double m3 = xf * nyf;\r\n\tconst double m4 = nxf * nyf;\r\n\r\n\t/* get color values of neighbouring pixels */\r\n\tconst int c1 = im->trueColor == 1 ? getPixelOverflowTC(im, sx, sy, bgColor)         : getPixelOverflowPalette(im, sx, sy, bgColor);\r\n\tconst int c2 = im->trueColor == 1 ? getPixelOverflowTC(im, sx - 1, sy, bgColor)     : getPixelOverflowPalette(im, sx - 1, sy, bgColor);\r\n\tconst int c3 = im->trueColor == 1 ? getPixelOverflowTC(im, sx, sy - 1, bgColor)     : getPixelOverflowPalette(im, sx, sy - 1, bgColor);\r\n\tconst int c4 = im->trueColor == 1 ? getPixelOverflowTC(im, sx - 1, sy - 1, bgColor) : getPixelOverflowPalette(im, sx, sy - 1, bgColor);\r\n\tint r, g, b, a;\r\n\r\n\tif (x < 0) sx--;\r\n\tif (y < 0) sy--;\r\n\r\n\t/* component-wise summing-up of color values */\r\n\tr = (int)(m1*gdTrueColorGetRed(c1)   + m2*gdTrueColorGetRed(c2)   + m3*gdTrueColorGetRed(c3)   + m4*gdTrueColorGetRed(c4));\r\n\tg = (int)(m1*gdTrueColorGetGreen(c1) + m2*gdTrueColorGetGreen(c2) + m3*gdTrueColorGetGreen(c3) + m4*gdTrueColorGetGreen(c4));\r\n\tb = (int)(m1*gdTrueColorGetBlue(c1)  + m2*gdTrueColorGetBlue(c2)  + m3*gdTrueColorGetBlue(c3)  + m4*gdTrueColorGetBlue(c4));\r\n\ta = (int)(m1*gdTrueColorGetAlpha(c1) + m2*gdTrueColorGetAlpha(c2) + m3*gdTrueColorGetAlpha(c3) + m4*gdTrueColorGetAlpha(c4));\r\n\r\n\tr = CLAMP(r, 0, 255);\r\n\tg = CLAMP(g, 0, 255);\r\n\tb = CLAMP(b, 0, 255);\r\n\ta = CLAMP(a, 0, gdAlphaMax);\r\n\treturn gdTrueColorAlpha(r, g, b, a);\r\n}", ".dImageScaleBilinearTC": "static gdImagePtr gdImageScaleBilinearTC(gdImagePtr im, const unsigned int new_width, const unsigned int new_height)\r\n{\r\n\tlong dst_w = MAX(1, new_width);\r\n\tlong dst_h = MAX(1, new_height);\r\n\tfloat dx = (float)gdImageSX(im) / (float)dst_w;\r\n\tfloat dy = (float)gdImageSY(im) / (float)dst_h;\r\n\tgdFixed f_dx = gd_ftofx(dx);\r\n\tgdFixed f_dy = gd_ftofx(dy);\r\n\tgdFixed f_1 = gd_itofx(1);\r\n\r\n\tint dst_offset_h;\r\n\tint dst_offset_v = 0;\r\n\tlong i;\r\n\tgdImagePtr new_img;\r\n\r\n\tnew_img = gdImageCreateTrueColor(new_width, new_height);\r\n\tif (!new_img){\r\n\t\treturn NULL;\r\n\t}\r\n\r\n\tfor (i=0; i < dst_h; i++) {\r\n\t\tlong j;\r\n\t\tdst_offset_h = 0;\r\n\t\tfor (j=0; j < dst_w; j++) {\r\n\t\t\t/* Update bitmap */\r\n\t\t\tgdFixed f_i = gd_itofx(i);\r\n\t\t\tgdFixed f_j = gd_itofx(j);\r\n\t\t\tgdFixed f_a = gd_mulfx(f_i, f_dy);\r\n\t\t\tgdFixed f_b = gd_mulfx(f_j, f_dx);\r\n\t\t\tconst long m = gd_fxtoi(f_a);\r\n\t\t\tconst long n = gd_fxtoi(f_b);\r\n\t\t\tgdFixed f_f = f_a - gd_itofx(m);\r\n\t\t\tgdFixed f_g = f_b - gd_itofx(n);\r\n\r\n\t\t\tconst gdFixed f_w1 = gd_mulfx(f_1-f_f, f_1-f_g);\r\n\t\t\tconst gdFixed f_w2 = gd_mulfx(f_1-f_f, f_g);\r\n\t\t\tconst gdFixed f_w3 = gd_mulfx(f_f, f_1-f_g);\r\n\t\t\tconst gdFixed f_w4 = gd_mulfx(f_f, f_g);\r\n\t\t\tunsigned int pixel1;\r\n\t\t\tunsigned int pixel2;\r\n\t\t\tunsigned int pixel3;\r\n\t\t\tunsigned int pixel4;\r\n\t\t\tregister gdFixed f_r1, f_r2, f_r3, f_r4,\r\n\t\t\t\t\tf_g1, f_g2, f_g3, f_g4,\r\n\t\t\t\t\tf_b1, f_b2, f_b3, f_b4,\r\n\t\t\t\t\tf_a1, f_a2, f_a3, f_a4;\r\n\t\t\t/* 0 for bgColor; (n,m) is supposed to be valid anyway */\r\n\t\t\tpixel1 = getPixelOverflowTC(im, n, m, 0);\r\n\t\t\tpixel2 = getPixelOverflowTC(im, n + 1, m, pixel1);\r\n\t\t\tpixel3 = getPixelOverflowTC(im, n, m + 1, pixel1);\r\n\t\t\tpixel4 = getPixelOverflowTC(im, n + 1, m + 1, pixel1);\r\n\r\n\t\t\tf_r1 = gd_itofx(gdTrueColorGetRed(pixel1));\r\n\t\t\tf_r2 = gd_itofx(gdTrueColorGetRed(pixel2));\r\n\t\t\tf_r3 = gd_itofx(gdTrueColorGetRed(pixel3));\r\n\t\t\tf_r4 = gd_itofx(gdTrueColorGetRed(pixel4));\r\n\t\t\tf_g1 = gd_itofx(gdTrueColorGetGreen(pixel1));\r\n\t\t\tf_g2 = gd_itofx(gdTrueColorGetGreen(pixel2));\r\n\t\t\tf_g3 = gd_itofx(gdTrueColorGetGreen(pixel3));\r\n\t\t\tf_g4 = gd_itofx(gdTrueColorGetGreen(pixel4));\r\n\t\t\tf_b1 = gd_itofx(gdTrueColorGetBlue(pixel1));\r\n\t\t\tf_b2 = gd_itofx(gdTrueColorGetBlue(pixel2));\r\n\t\t\tf_b3 = gd_itofx(gdTrueColorGetBlue(pixel3));\r\n\t\t\tf_b4 = gd_itofx(gdTrueColorGetBlue(pixel4));\r\n\t\t\tf_a1 = gd_itofx(gdTrueColorGetAlpha(pixel1));\r\n\t\t\tf_a2 = gd_itofx(gdTrueColorGetAlpha(pixel2));\r\n\t\t\tf_a3 = gd_itofx(gdTrueColorGetAlpha(pixel3));\r\n\t\t\tf_a4 = gd_itofx(gdTrueColorGetAlpha(pixel4));\r\n\t\t\t{\r\n\t\t\t\tconst unsigned char red   = (unsigned char) gd_fxtoi(gd_mulfx(f_w1, f_r1) + gd_mulfx(f_w2, f_r2) + gd_mulfx(f_w3, f_r3) + gd_mulfx(f_w4, f_r4));\r\n\t\t\t\tconst unsigned char green = (unsigned char) gd_fxtoi(gd_mulfx(f_w1, f_g1) + gd_mulfx(f_w2, f_g2) + gd_mulfx(f_w3, f_g3) + gd_mulfx(f_w4, f_g4));\r\n\t\t\t\tconst unsigned char blue  = (unsigned char) gd_fxtoi(gd_mulfx(f_w1, f_b1) + gd_mulfx(f_w2, f_b2) + gd_mulfx(f_w3, f_b3) + gd_mulfx(f_w4, f_b4));\r\n\t\t\t\tconst unsigned char alpha = (unsigned char) gd_fxtoi(gd_mulfx(f_w1, f_a1) + gd_mulfx(f_w2, f_a2) + gd_mulfx(f_w3, f_a3) + gd_mulfx(f_w4, f_a4));\r\n\r\n\t\t\t\tnew_img->tpixels[dst_offset_v][dst_offset_h] = gdTrueColorAlpha(red, green, blue, alpha);\r\n\t\t\t}\r\n\r\n\t\t\tdst_offset_h++;\r\n\t\t}\r\n\r\n\t\tdst_offset_v++;\r\n\t}\r\n\treturn new_img;\r\n}", ".dImageScaleBilinearPalette": "static gdImagePtr gdImageScaleBilinearPalette(gdImagePtr im, const unsigned int new_width, const unsigned int new_height)\r\n{\r\n\tlong _width = MAX(1, new_width);\r\n\tlong _height = MAX(1, new_height);\r\n\tfloat dx = (float)gdImageSX(im) / (float)_width;\r\n\tfloat dy = (float)gdImageSY(im) / (float)_height;\r\n\tgdFixed f_dx = gd_ftofx(dx);\r\n\tgdFixed f_dy = gd_ftofx(dy);\r\n\tgdFixed f_1 = gd_itofx(1);\r\n\r\n\tint dst_offset_h;\r\n\tint dst_offset_v = 0;\r\n\tlong i;\r\n\tgdImagePtr new_img;\r\n\tconst int transparent = im->transparent;\r\n\r\n\tnew_img = gdImageCreateTrueColor(new_width, new_height);\r\n\tif (new_img == NULL) {\r\n\t\treturn NULL;\r\n\t}\r\n\r\n\tif (transparent < 0) {\r\n\t\t/* uninitialized */\r\n\t\tnew_img->transparent = -1;\r\n\t} else {\r\n\t\tnew_img->transparent = gdTrueColorAlpha(im->red[transparent], im->green[transparent], im->blue[transparent], im->alpha[transparent]);\r\n\t}\r\n\r\n\tfor (i=0; i < _height; i++) {\r\n\t\tlong j;\r\n\t\tconst gdFixed f_i = gd_itofx(i);\r\n\t\tconst gdFixed f_a = gd_mulfx(f_i, f_dy);\r\n\t\tregister long m = gd_fxtoi(f_a);\r\n\r\n\t\tdst_offset_h = 0;\r\n\r\n\t\tfor (j=0; j < _width; j++) {\r\n\t\t\t/* Update bitmap */\r\n\t\t\tgdFixed f_j = gd_itofx(j);\r\n\t\t\tgdFixed f_b = gd_mulfx(f_j, f_dx);\r\n\r\n\t\t\tconst long n = gd_fxtoi(f_b);\r\n\t\t\tgdFixed f_f = f_a - gd_itofx(m);\r\n\t\t\tgdFixed f_g = f_b - gd_itofx(n);\r\n\r\n\t\t\tconst gdFixed f_w1 = gd_mulfx(f_1-f_f, f_1-f_g);\r\n\t\t\tconst gdFixed f_w2 = gd_mulfx(f_1-f_f, f_g);\r\n\t\t\tconst gdFixed f_w3 = gd_mulfx(f_f, f_1-f_g);\r\n\t\t\tconst gdFixed f_w4 = gd_mulfx(f_f, f_g);\r\n\t\t\tunsigned int pixel1;\r\n\t\t\tunsigned int pixel2;\r\n\t\t\tunsigned int pixel3;\r\n\t\t\tunsigned int pixel4;\r\n\t\t\tregister gdFixed f_r1, f_r2, f_r3, f_r4,\r\n\t\t\t\t\tf_g1, f_g2, f_g3, f_g4,\r\n\t\t\t\t\tf_b1, f_b2, f_b3, f_b4,\r\n\t\t\t\t\tf_a1, f_a2, f_a3, f_a4;\r\n\r\n\t\t\t/* 0 for bgColor; (n,m) is supposed to be valid anyway */\r\n\t\t\tpixel1 = getPixelOverflowPalette(im, n, m, 0);\r\n\t\t\tpixel2 = getPixelOverflowPalette(im, n + 1, m, pixel1);\r\n\t\t\tpixel3 = getPixelOverflowPalette(im, n, m + 1, pixel1);\r\n\t\t\tpixel4 = getPixelOverflowPalette(im, n + 1, m + 1, pixel1);\r\n\r\n\t\t\tf_r1 = gd_itofx(gdTrueColorGetRed(pixel1));\r\n\t\t\tf_r2 = gd_itofx(gdTrueColorGetRed(pixel2));\r\n\t\t\tf_r3 = gd_itofx(gdTrueColorGetRed(pixel3));\r\n\t\t\tf_r4 = gd_itofx(gdTrueColorGetRed(pixel4));\r\n\t\t\tf_g1 = gd_itofx(gdTrueColorGetGreen(pixel1));\r\n\t\t\tf_g2 = gd_itofx(gdTrueColorGetGreen(pixel2));\r\n\t\t\tf_g3 = gd_itofx(gdTrueColorGetGreen(pixel3));\r\n\t\t\tf_g4 = gd_itofx(gdTrueColorGetGreen(pixel4));\r\n\t\t\tf_b1 = gd_itofx(gdTrueColorGetBlue(pixel1));\r\n\t\t\tf_b2 = gd_itofx(gdTrueColorGetBlue(pixel2));\r\n\t\t\tf_b3 = gd_itofx(gdTrueColorGetBlue(pixel3));\r\n\t\t\tf_b4 = gd_itofx(gdTrueColorGetBlue(pixel4));\r\n\t\t\tf_a1 = gd_itofx(gdTrueColorGetAlpha(pixel1));\r\n\t\t\tf_a2 = gd_itofx(gdTrueColorGetAlpha(pixel2));\r\n\t\t\tf_a3 = gd_itofx(gdTrueColorGetAlpha(pixel3));\r\n\t\t\tf_a4 = gd_itofx(gdTrueColorGetAlpha(pixel4));\r\n\r\n\t\t\t{\r\n\t\t\t\tconst unsigned char red = (unsigned char) gd_fxtoi(gd_mulfx(f_w1, f_r1) + gd_mulfx(f_w2, f_r2) + gd_mulfx(f_w3, f_r3) + gd_mulfx(f_w4, f_r4));\r\n\t\t\t\tconst unsigned char green = (unsigned char) gd_fxtoi(gd_mulfx(f_w1, f_g1) + gd_mulfx(f_w2, f_g2) + gd_mulfx(f_w3, f_g3) + gd_mulfx(f_w4, f_g4));\r\n\t\t\t\tconst unsigned char blue = (unsigned char) gd_fxtoi(gd_mulfx(f_w1, f_b1) + gd_mulfx(f_w2, f_b2) + gd_mulfx(f_w3, f_b3) + gd_mulfx(f_w4, f_b4));\r\n\t\t\t\tconst unsigned char alpha = (unsigned char) gd_fxtoi(gd_mulfx(f_w1, f_a1) + gd_mulfx(f_w2, f_a2) + gd_mulfx(f_w3, f_a3) + gd_mulfx(f_w4, f_a4));\r\n\r\n\t\t\t\tnew_img->tpixels[dst_offset_v][dst_offset_h] = gdTrueColorAlpha(red, green, blue, alpha);\r\n\t\t\t}\r\n\r\n\t\t\tdst_offset_h++;\r\n\t\t}\r\n\r\n\t\tdst_offset_v++;\r\n\t}\r\n\treturn new_img;\r\n}", ".dRotatedImageSize": "static int gdRotatedImageSize(gdImagePtr src, const float angle, gdRectPtr bbox)\r\n{\r\n    gdRect src_area;\r\n    double m[6];\r\n\r\n    gdAffineRotate(m, angle);\r\n    src_area.x = 0;\r\n    src_area.y = 0;\r\n    src_area.width = gdImageSX(src);\r\n    src_area.height = gdImageSY(src);\r\n    if (gdTransformAffineBoundingBox(&src_area, m, bbox) != GD_TRUE) {\r\n        return GD_FALSE;\r\n    }\r\n\r\n    return GD_TRUE;\r\n}", ".etPixelInterpolated": "static int getPixelInterpolated(gdImagePtr im, const double x, const double y, const int bgColor)\r\n{\r\n\tconst int xi=(int)(x);\r\n\tconst int yi=(int)(y);\r\n\tint yii;\r\n\tint i;\r\n\tdouble kernel, kernel_cache_y;\r\n\tdouble kernel_x[12], kernel_y[4];\r\n\tdouble new_r = 0.0f, new_g = 0.0f, new_b = 0.0f, new_a = 0.0f;\r\n\r\n\t/* These methods use special implementations */\r\n\tif (im->interpolation_id == GD_NEAREST_NEIGHBOUR) {\r\n\t\treturn -1;\r\n\t}\r\n\r\n\tif (im->interpolation_id == GD_WEIGHTED4) {\r\n\t\treturn getPixelInterpolateWeight(im, x, y, bgColor);\r\n\t}\r\n\r\n\tif (im->interpolation) {\r\n\t\tfor (i=0; i<4; i++) {\r\n\t\t\tkernel_x[i] = (double) im->interpolation((double)(xi+i-1-x), 1.0);\r\n\t\t\tkernel_y[i] = (double) im->interpolation((double)(yi+i-1-y), 1.0);\r\n\t\t}\r\n\t} else {\r\n\t\treturn -1;\r\n\t}\r\n\r\n\t/*\r\n\t * TODO: use the known fast rgba multiplication implementation once\r\n\t * the new formats are in place\r\n\t */\r\n\tfor (yii = yi-1; yii < yi+3; yii++) {\r\n\t\tint xii;\r\n\t\tkernel_cache_y = kernel_y[yii-(yi-1)];\r\n\t\tif (im->trueColor) {\r\n\t\t\tfor (xii=xi-1; xii<xi+3; xii++) {\r\n\t\t\t\tconst int rgbs = getPixelOverflowTC(im, xii, yii, bgColor);\r\n\r\n\t\t\t\tkernel = kernel_cache_y * kernel_x[xii-(xi-1)];\r\n\t\t\t\tnew_r += kernel * gdTrueColorGetRed(rgbs);\r\n\t\t\t\tnew_g += kernel * gdTrueColorGetGreen(rgbs);\r\n\t\t\t\tnew_b += kernel * gdTrueColorGetBlue(rgbs);\r\n\t\t\t\tnew_a += kernel * gdTrueColorGetAlpha(rgbs);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tfor (xii=xi-1; xii<xi+3; xii++) {\r\n\t\t\t\tconst int rgbs = getPixelOverflowPalette(im, xii, yii, bgColor);\r\n\r\n\t\t\t\tkernel = kernel_cache_y * kernel_x[xii-(xi-1)];\r\n\t\t\t\tnew_r += kernel * gdTrueColorGetRed(rgbs);\r\n\t\t\t\tnew_g += kernel * gdTrueColorGetGreen(rgbs);\r\n\t\t\t\tnew_b += kernel * gdTrueColorGetBlue(rgbs);\r\n\t\t\t\tnew_a += kernel * gdTrueColorGetAlpha(rgbs);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tnew_r = CLAMP(new_r, 0, 255);\r\n\tnew_g = CLAMP(new_g, 0, 255);\r\n\tnew_b = CLAMP(new_b, 0, 255);\r\n\tnew_a = CLAMP(new_a, 0, gdAlphaMax);\r\n\r\n\treturn gdTrueColorAlpha(((int)new_r), ((int)new_g), ((int)new_b), ((int)new_a));\r\n}"}, "callee": {".ernelBessel_Order1": "static double KernelBessel_Order1(double x)\r\n{\r\n\tdouble p, q;\r\n\r\n\tif (x == 0.0)\r\n\t\treturn (0.0f);\r\n\tp = x;\r\n\tif (x < 0.0)\r\n\t\tx=(-x);\r\n\tif (x < 8.0)\r\n\t\treturn (p*KernelBessel_J1(x));\r\n\tq = (double)sqrt(2.0f/(M_PI*x))*(double)(KernelBessel_P1(x)*(1.0f/sqrt(2.0f)*(sin(x)-cos(x)))-8.0f/x*KernelBessel_Q1(x)*\r\n\t\t(-1.0f/sqrt(2.0f)*(sin(x)+cos(x))));\r\n\tif (p < 0.0f)\r\n\t\tq = (-q);\r\n\treturn (q);\r\n}", ".ilter_bessel": "static double filter_bessel(const double x, const double support)\r\n{\r\n\tARG_NOT_USED(support);\r\n\tif (x == 0.0f)\r\n\t\treturn (double)(M_PI/4.0f);\r\n\treturn (KernelBessel_Order1((double)M_PI*x)/(2.0f*x));\r\n}", ".ilter_blackman_sinc": "static double filter_blackman_sinc(const double x, const double support)\r\n{\r\n\tARG_NOT_USED(support);\r\n\treturn(filter_blackman(x/support,support)*filter_sinc(x,support));\r\n}", ".ilter_lanczos3": "static double filter_lanczos3(const double x1, const double support)\r\n{\r\n  if (x1 < -3.0)\r\n    return(0.0);\r\n  if (x1 < 0.0)\r\n    return(filter_sinc(-x1,support)*filter_sinc(-x1/3.0,support));\r\n  if (x1 < 3.0)\r\n    return(filter_sinc(x1,support)*filter_sinc(x1/3.0,support));\r\n  return(0.0);\r\n}", ".ilter_blackman_bessel": "static double filter_blackman_bessel(const double x, const double support)\r\n{\r\n\tARG_NOT_USED(support);\r\n\treturn(filter_blackman(x/support,support)*filter_bessel(x,support));\r\n}", ".etPixelInterpolateWeight": "static int getPixelInterpolateWeight(gdImagePtr im, const double x, const double y, const int bgColor)\r\n{\r\n\t/* Closest pixel <= (xf,yf) */\r\n\tint sx = (int)(x);\r\n\tint sy = (int)(y);\r\n\tconst double xf = x - (double)sx;\r\n\tconst double yf = y - (double)sy;\r\n\tconst double nxf = (double) 1.0 - xf;\r\n\tconst double nyf = (double) 1.0 - yf;\r\n\tconst double m1 = xf * yf;\r\n\tconst double m2 = nxf * yf;\r\n\tconst double m3 = xf * nyf;\r\n\tconst double m4 = nxf * nyf;\r\n\r\n\t/* get color values of neighbouring pixels */\r\n\tconst int c1 = im->trueColor == 1 ? getPixelOverflowTC(im, sx, sy, bgColor)         : getPixelOverflowPalette(im, sx, sy, bgColor);\r\n\tconst int c2 = im->trueColor == 1 ? getPixelOverflowTC(im, sx - 1, sy, bgColor)     : getPixelOverflowPalette(im, sx - 1, sy, bgColor);\r\n\tconst int c3 = im->trueColor == 1 ? getPixelOverflowTC(im, sx, sy - 1, bgColor)     : getPixelOverflowPalette(im, sx, sy - 1, bgColor);\r\n\tconst int c4 = im->trueColor == 1 ? getPixelOverflowTC(im, sx - 1, sy - 1, bgColor) : getPixelOverflowPalette(im, sx, sy - 1, bgColor);\r\n\tint r, g, b, a;\r\n\r\n\tif (x < 0) sx--;\r\n\tif (y < 0) sy--;\r\n\r\n\t/* component-wise summing-up of color values */\r\n\tr = (int)(m1*gdTrueColorGetRed(c1)   + m2*gdTrueColorGetRed(c2)   + m3*gdTrueColorGetRed(c3)   + m4*gdTrueColorGetRed(c4));\r\n\tg = (int)(m1*gdTrueColorGetGreen(c1) + m2*gdTrueColorGetGreen(c2) + m3*gdTrueColorGetGreen(c3) + m4*gdTrueColorGetGreen(c4));\r\n\tb = (int)(m1*gdTrueColorGetBlue(c1)  + m2*gdTrueColorGetBlue(c2)  + m3*gdTrueColorGetBlue(c3)  + m4*gdTrueColorGetBlue(c4));\r\n\ta = (int)(m1*gdTrueColorGetAlpha(c1) + m2*gdTrueColorGetAlpha(c2) + m3*gdTrueColorGetAlpha(c3) + m4*gdTrueColorGetAlpha(c4));\r\n\r\n\tr = CLAMP(r, 0, 255);\r\n\tg = CLAMP(g, 0, 255);\r\n\tb = CLAMP(b, 0, 255);\r\n\ta = CLAMP(a, 0, gdAlphaMax);\r\n\treturn gdTrueColorAlpha(r, g, b, a);\r\n}", ".etPixelInterpolated": "static int getPixelInterpolated(gdImagePtr im, const double x, const double y, const int bgColor)\r\n{\r\n\tconst int xi=(int)(x);\r\n\tconst int yi=(int)(y);\r\n\tint yii;\r\n\tint i;\r\n\tdouble kernel, kernel_cache_y;\r\n\tdouble kernel_x[12], kernel_y[4];\r\n\tdouble new_r = 0.0f, new_g = 0.0f, new_b = 0.0f, new_a = 0.0f;\r\n\r\n\t/* These methods use special implementations */\r\n\tif (im->interpolation_id == GD_NEAREST_NEIGHBOUR) {\r\n\t\treturn -1;\r\n\t}\r\n\r\n\tif (im->interpolation_id == GD_WEIGHTED4) {\r\n\t\treturn getPixelInterpolateWeight(im, x, y, bgColor);\r\n\t}\r\n\r\n\tif (im->interpolation) {\r\n\t\tfor (i=0; i<4; i++) {\r\n\t\t\tkernel_x[i] = (double) im->interpolation((double)(xi+i-1-x), 1.0);\r\n\t\t\tkernel_y[i] = (double) im->interpolation((double)(yi+i-1-y), 1.0);\r\n\t\t}\r\n\t} else {\r\n\t\treturn -1;\r\n\t}\r\n\r\n\t/*\r\n\t * TODO: use the known fast rgba multiplication implementation once\r\n\t * the new formats are in place\r\n\t */\r\n\tfor (yii = yi-1; yii < yi+3; yii++) {\r\n\t\tint xii;\r\n\t\tkernel_cache_y = kernel_y[yii-(yi-1)];\r\n\t\tif (im->trueColor) {\r\n\t\t\tfor (xii=xi-1; xii<xi+3; xii++) {\r\n\t\t\t\tconst int rgbs = getPixelOverflowTC(im, xii, yii, bgColor);\r\n\r\n\t\t\t\tkernel = kernel_cache_y * kernel_x[xii-(xi-1)];\r\n\t\t\t\tnew_r += kernel * gdTrueColorGetRed(rgbs);\r\n\t\t\t\tnew_g += kernel * gdTrueColorGetGreen(rgbs);\r\n\t\t\t\tnew_b += kernel * gdTrueColorGetBlue(rgbs);\r\n\t\t\t\tnew_a += kernel * gdTrueColorGetAlpha(rgbs);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tfor (xii=xi-1; xii<xi+3; xii++) {\r\n\t\t\t\tconst int rgbs = getPixelOverflowPalette(im, xii, yii, bgColor);\r\n\r\n\t\t\t\tkernel = kernel_cache_y * kernel_x[xii-(xi-1)];\r\n\t\t\t\tnew_r += kernel * gdTrueColorGetRed(rgbs);\r\n\t\t\t\tnew_g += kernel * gdTrueColorGetGreen(rgbs);\r\n\t\t\t\tnew_b += kernel * gdTrueColorGetBlue(rgbs);\r\n\t\t\t\tnew_a += kernel * gdTrueColorGetAlpha(rgbs);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tnew_r = CLAMP(new_r, 0, 255);\r\n\tnew_g = CLAMP(new_g, 0, 255);\r\n\tnew_b = CLAMP(new_b, 0, 255);\r\n\tnew_a = CLAMP(new_a, 0, gdAlphaMax);\r\n\r\n\treturn gdTrueColorAlpha(((int)new_r), ((int)new_g), ((int)new_b), ((int)new_a));\r\n}", ".dImageScaleBilinearTC": "static gdImagePtr gdImageScaleBilinearTC(gdImagePtr im, const unsigned int new_width, const unsigned int new_height)\r\n{\r\n\tlong dst_w = MAX(1, new_width);\r\n\tlong dst_h = MAX(1, new_height);\r\n\tfloat dx = (float)gdImageSX(im) / (float)dst_w;\r\n\tfloat dy = (float)gdImageSY(im) / (float)dst_h;\r\n\tgdFixed f_dx = gd_ftofx(dx);\r\n\tgdFixed f_dy = gd_ftofx(dy);\r\n\tgdFixed f_1 = gd_itofx(1);\r\n\r\n\tint dst_offset_h;\r\n\tint dst_offset_v = 0;\r\n\tlong i;\r\n\tgdImagePtr new_img;\r\n\r\n\tnew_img = gdImageCreateTrueColor(new_width, new_height);\r\n\tif (!new_img){\r\n\t\treturn NULL;\r\n\t}\r\n\r\n\tfor (i=0; i < dst_h; i++) {\r\n\t\tlong j;\r\n\t\tdst_offset_h = 0;\r\n\t\tfor (j=0; j < dst_w; j++) {\r\n\t\t\t/* Update bitmap */\r\n\t\t\tgdFixed f_i = gd_itofx(i);\r\n\t\t\tgdFixed f_j = gd_itofx(j);\r\n\t\t\tgdFixed f_a = gd_mulfx(f_i, f_dy);\r\n\t\t\tgdFixed f_b = gd_mulfx(f_j, f_dx);\r\n\t\t\tconst long m = gd_fxtoi(f_a);\r\n\t\t\tconst long n = gd_fxtoi(f_b);\r\n\t\t\tgdFixed f_f = f_a - gd_itofx(m);\r\n\t\t\tgdFixed f_g = f_b - gd_itofx(n);\r\n\r\n\t\t\tconst gdFixed f_w1 = gd_mulfx(f_1-f_f, f_1-f_g);\r\n\t\t\tconst gdFixed f_w2 = gd_mulfx(f_1-f_f, f_g);\r\n\t\t\tconst gdFixed f_w3 = gd_mulfx(f_f, f_1-f_g);\r\n\t\t\tconst gdFixed f_w4 = gd_mulfx(f_f, f_g);\r\n\t\t\tunsigned int pixel1;\r\n\t\t\tunsigned int pixel2;\r\n\t\t\tunsigned int pixel3;\r\n\t\t\tunsigned int pixel4;\r\n\t\t\tregister gdFixed f_r1, f_r2, f_r3, f_r4,\r\n\t\t\t\t\tf_g1, f_g2, f_g3, f_g4,\r\n\t\t\t\t\tf_b1, f_b2, f_b3, f_b4,\r\n\t\t\t\t\tf_a1, f_a2, f_a3, f_a4;\r\n\t\t\t/* 0 for bgColor; (n,m) is supposed to be valid anyway */\r\n\t\t\tpixel1 = getPixelOverflowTC(im, n, m, 0);\r\n\t\t\tpixel2 = getPixelOverflowTC(im, n + 1, m, pixel1);\r\n\t\t\tpixel3 = getPixelOverflowTC(im, n, m + 1, pixel1);\r\n\t\t\tpixel4 = getPixelOverflowTC(im, n + 1, m + 1, pixel1);\r\n\r\n\t\t\tf_r1 = gd_itofx(gdTrueColorGetRed(pixel1));\r\n\t\t\tf_r2 = gd_itofx(gdTrueColorGetRed(pixel2));\r\n\t\t\tf_r3 = gd_itofx(gdTrueColorGetRed(pixel3));\r\n\t\t\tf_r4 = gd_itofx(gdTrueColorGetRed(pixel4));\r\n\t\t\tf_g1 = gd_itofx(gdTrueColorGetGreen(pixel1));\r\n\t\t\tf_g2 = gd_itofx(gdTrueColorGetGreen(pixel2));\r\n\t\t\tf_g3 = gd_itofx(gdTrueColorGetGreen(pixel3));\r\n\t\t\tf_g4 = gd_itofx(gdTrueColorGetGreen(pixel4));\r\n\t\t\tf_b1 = gd_itofx(gdTrueColorGetBlue(pixel1));\r\n\t\t\tf_b2 = gd_itofx(gdTrueColorGetBlue(pixel2));\r\n\t\t\tf_b3 = gd_itofx(gdTrueColorGetBlue(pixel3));\r\n\t\t\tf_b4 = gd_itofx(gdTrueColorGetBlue(pixel4));\r\n\t\t\tf_a1 = gd_itofx(gdTrueColorGetAlpha(pixel1));\r\n\t\t\tf_a2 = gd_itofx(gdTrueColorGetAlpha(pixel2));\r\n\t\t\tf_a3 = gd_itofx(gdTrueColorGetAlpha(pixel3));\r\n\t\t\tf_a4 = gd_itofx(gdTrueColorGetAlpha(pixel4));\r\n\t\t\t{\r\n\t\t\t\tconst unsigned char red   = (unsigned char) gd_fxtoi(gd_mulfx(f_w1, f_r1) + gd_mulfx(f_w2, f_r2) + gd_mulfx(f_w3, f_r3) + gd_mulfx(f_w4, f_r4));\r\n\t\t\t\tconst unsigned char green = (unsigned char) gd_fxtoi(gd_mulfx(f_w1, f_g1) + gd_mulfx(f_w2, f_g2) + gd_mulfx(f_w3, f_g3) + gd_mulfx(f_w4, f_g4));\r\n\t\t\t\tconst unsigned char blue  = (unsigned char) gd_fxtoi(gd_mulfx(f_w1, f_b1) + gd_mulfx(f_w2, f_b2) + gd_mulfx(f_w3, f_b3) + gd_mulfx(f_w4, f_b4));\r\n\t\t\t\tconst unsigned char alpha = (unsigned char) gd_fxtoi(gd_mulfx(f_w1, f_a1) + gd_mulfx(f_w2, f_a2) + gd_mulfx(f_w3, f_a3) + gd_mulfx(f_w4, f_a4));\r\n\r\n\t\t\t\tnew_img->tpixels[dst_offset_v][dst_offset_h] = gdTrueColorAlpha(red, green, blue, alpha);\r\n\t\t\t}\r\n\r\n\t\t\tdst_offset_h++;\r\n\t\t}\r\n\r\n\t\tdst_offset_v++;\r\n\t}\r\n\treturn new_img;\r\n}", ".dImageScaleBilinearPalette": "static gdImagePtr gdImageScaleBilinearPalette(gdImagePtr im, const unsigned int new_width, const unsigned int new_height)\r\n{\r\n\tlong _width = MAX(1, new_width);\r\n\tlong _height = MAX(1, new_height);\r\n\tfloat dx = (float)gdImageSX(im) / (float)_width;\r\n\tfloat dy = (float)gdImageSY(im) / (float)_height;\r\n\tgdFixed f_dx = gd_ftofx(dx);\r\n\tgdFixed f_dy = gd_ftofx(dy);\r\n\tgdFixed f_1 = gd_itofx(1);\r\n\r\n\tint dst_offset_h;\r\n\tint dst_offset_v = 0;\r\n\tlong i;\r\n\tgdImagePtr new_img;\r\n\tconst int transparent = im->transparent;\r\n\r\n\tnew_img = gdImageCreateTrueColor(new_width, new_height);\r\n\tif (new_img == NULL) {\r\n\t\treturn NULL;\r\n\t}\r\n\r\n\tif (transparent < 0) {\r\n\t\t/* uninitialized */\r\n\t\tnew_img->transparent = -1;\r\n\t} else {\r\n\t\tnew_img->transparent = gdTrueColorAlpha(im->red[transparent], im->green[transparent], im->blue[transparent], im->alpha[transparent]);\r\n\t}\r\n\r\n\tfor (i=0; i < _height; i++) {\r\n\t\tlong j;\r\n\t\tconst gdFixed f_i = gd_itofx(i);\r\n\t\tconst gdFixed f_a = gd_mulfx(f_i, f_dy);\r\n\t\tregister long m = gd_fxtoi(f_a);\r\n\r\n\t\tdst_offset_h = 0;\r\n\r\n\t\tfor (j=0; j < _width; j++) {\r\n\t\t\t/* Update bitmap */\r\n\t\t\tgdFixed f_j = gd_itofx(j);\r\n\t\t\tgdFixed f_b = gd_mulfx(f_j, f_dx);\r\n\r\n\t\t\tconst long n = gd_fxtoi(f_b);\r\n\t\t\tgdFixed f_f = f_a - gd_itofx(m);\r\n\t\t\tgdFixed f_g = f_b - gd_itofx(n);\r\n\r\n\t\t\tconst gdFixed f_w1 = gd_mulfx(f_1-f_f, f_1-f_g);\r\n\t\t\tconst gdFixed f_w2 = gd_mulfx(f_1-f_f, f_g);\r\n\t\t\tconst gdFixed f_w3 = gd_mulfx(f_f, f_1-f_g);\r\n\t\t\tconst gdFixed f_w4 = gd_mulfx(f_f, f_g);\r\n\t\t\tunsigned int pixel1;\r\n\t\t\tunsigned int pixel2;\r\n\t\t\tunsigned int pixel3;\r\n\t\t\tunsigned int pixel4;\r\n\t\t\tregister gdFixed f_r1, f_r2, f_r3, f_r4,\r\n\t\t\t\t\tf_g1, f_g2, f_g3, f_g4,\r\n\t\t\t\t\tf_b1, f_b2, f_b3, f_b4,\r\n\t\t\t\t\tf_a1, f_a2, f_a3, f_a4;\r\n\r\n\t\t\t/* 0 for bgColor; (n,m) is supposed to be valid anyway */\r\n\t\t\tpixel1 = getPixelOverflowPalette(im, n, m, 0);\r\n\t\t\tpixel2 = getPixelOverflowPalette(im, n + 1, m, pixel1);\r\n\t\t\tpixel3 = getPixelOverflowPalette(im, n, m + 1, pixel1);\r\n\t\t\tpixel4 = getPixelOverflowPalette(im, n + 1, m + 1, pixel1);\r\n\r\n\t\t\tf_r1 = gd_itofx(gdTrueColorGetRed(pixel1));\r\n\t\t\tf_r2 = gd_itofx(gdTrueColorGetRed(pixel2));\r\n\t\t\tf_r3 = gd_itofx(gdTrueColorGetRed(pixel3));\r\n\t\t\tf_r4 = gd_itofx(gdTrueColorGetRed(pixel4));\r\n\t\t\tf_g1 = gd_itofx(gdTrueColorGetGreen(pixel1));\r\n\t\t\tf_g2 = gd_itofx(gdTrueColorGetGreen(pixel2));\r\n\t\t\tf_g3 = gd_itofx(gdTrueColorGetGreen(pixel3));\r\n\t\t\tf_g4 = gd_itofx(gdTrueColorGetGreen(pixel4));\r\n\t\t\tf_b1 = gd_itofx(gdTrueColorGetBlue(pixel1));\r\n\t\t\tf_b2 = gd_itofx(gdTrueColorGetBlue(pixel2));\r\n\t\t\tf_b3 = gd_itofx(gdTrueColorGetBlue(pixel3));\r\n\t\t\tf_b4 = gd_itofx(gdTrueColorGetBlue(pixel4));\r\n\t\t\tf_a1 = gd_itofx(gdTrueColorGetAlpha(pixel1));\r\n\t\t\tf_a2 = gd_itofx(gdTrueColorGetAlpha(pixel2));\r\n\t\t\tf_a3 = gd_itofx(gdTrueColorGetAlpha(pixel3));\r\n\t\t\tf_a4 = gd_itofx(gdTrueColorGetAlpha(pixel4));\r\n\r\n\t\t\t{\r\n\t\t\t\tconst unsigned char red = (unsigned char) gd_fxtoi(gd_mulfx(f_w1, f_r1) + gd_mulfx(f_w2, f_r2) + gd_mulfx(f_w3, f_r3) + gd_mulfx(f_w4, f_r4));\r\n\t\t\t\tconst unsigned char green = (unsigned char) gd_fxtoi(gd_mulfx(f_w1, f_g1) + gd_mulfx(f_w2, f_g2) + gd_mulfx(f_w3, f_g3) + gd_mulfx(f_w4, f_g4));\r\n\t\t\t\tconst unsigned char blue = (unsigned char) gd_fxtoi(gd_mulfx(f_w1, f_b1) + gd_mulfx(f_w2, f_b2) + gd_mulfx(f_w3, f_b3) + gd_mulfx(f_w4, f_b4));\r\n\t\t\t\tconst unsigned char alpha = (unsigned char) gd_fxtoi(gd_mulfx(f_w1, f_a1) + gd_mulfx(f_w2, f_a2) + gd_mulfx(f_w3, f_a3) + gd_mulfx(f_w4, f_a4));\r\n\r\n\t\t\t\tnew_img->tpixels[dst_offset_v][dst_offset_h] = gdTrueColorAlpha(red, green, blue, alpha);\r\n\t\t\t}\r\n\r\n\t\t\tdst_offset_h++;\r\n\t\t}\r\n\r\n\t\tdst_offset_v++;\r\n\t}\r\n\treturn new_img;\r\n}", ".dImageRotateGeneric": "static gdImagePtr\r\ngdImageRotateGeneric(gdImagePtr src, const float degrees, const int bgColor)\r\n{\r\n\tfloat _angle = ((float) (-degrees / 180.0f) * (float)M_PI);\r\n\tconst int src_w  = gdImageSX(src);\r\n\tconst int src_h = gdImageSY(src);\r\n\tconst gdFixed f_H = gd_itofx(src_h/2);\r\n\tconst gdFixed f_W = gd_itofx(src_w/2);\r\n\tconst gdFixed f_cos = gd_ftofx(cos(-_angle));\r\n\tconst gdFixed f_sin = gd_ftofx(sin(-_angle));\r\n\r\n\tunsigned int dst_offset_x;\r\n\tunsigned int dst_offset_y = 0;\r\n\tunsigned int i;\r\n\tgdImagePtr dst;\r\n\tunsigned int new_width, new_height;\r\n\tgdRect bbox;\r\n\r\n\tif (bgColor < 0) {\r\n\t\treturn NULL;\r\n\t}\r\n\r\n\tif (src->interpolation == NULL) {\r\n\t\tgdImageSetInterpolationMethod(src, GD_DEFAULT);\r\n\t}\r\n\r\n    gdRotatedImageSize(src, degrees, &bbox);\r\n    new_width = bbox.width;\r\n    new_height = bbox.height;\r\n\r\n\tdst = gdImageCreateTrueColor(new_width, new_height);\r\n\tif (!dst) {\r\n\t\treturn NULL;\r\n\t}\r\n\tdst->saveAlphaFlag = 1;\r\n\r\n\tfor (i = 0; i < new_height; i++) {\r\n\t\tunsigned int j;\r\n\t\tdst_offset_x = 0;\r\n\t\tfor (j = 0; j < new_width; j++) {\r\n\t\t\tgdFixed f_i = gd_itofx((int)i - (int)new_height / 2);\r\n\t\t\tgdFixed f_j = gd_itofx((int)j - (int)new_width  / 2);\r\n\t\t\tgdFixed f_m = gd_mulfx(f_j,f_sin) + gd_mulfx(f_i,f_cos) + f_H;\r\n\t\t\tgdFixed f_n = gd_mulfx(f_j,f_cos) - gd_mulfx(f_i,f_sin)  + f_W;\r\n\t\t\tlong m = gd_fxtoi(f_m);\r\n\t\t\tlong n = gd_fxtoi(f_n);\r\n\r\n\t\t\tif (m < -1 || n < -1 || m >= src_h || n >= src_w ) {\r\n\t\t\t\tdst->tpixels[dst_offset_y][dst_offset_x++] = bgColor;\r\n\t\t\t} else {\r\n\t\t\t\tdst->tpixels[dst_offset_y][dst_offset_x++] = getPixelInterpolated(src, gd_fxtod(f_n), gd_fxtod(f_m), bgColor);\r\n\t\t\t}\r\n\t\t}\r\n\t\tdst_offset_y++;\r\n\t}\r\n\treturn dst;\r\n}", ".dImageScaleBilinear": "static gdImagePtr\r\ngdImageScaleBilinear(gdImagePtr im, const unsigned int new_width,\r\n                     const unsigned int new_height)\r\n{\r\n\tif (im->trueColor) {\r\n\t\treturn gdImageScaleBilinearTC(im, new_width, new_height);\r\n\t} else {\r\n\t\treturn gdImageScaleBilinearPalette(im, new_width, new_height);\r\n\t}\r\n}", ".dImageRotateNearestNeighbour": "static gdImagePtr\r\ngdImageRotateNearestNeighbour(gdImagePtr src, const float degrees,\r\n                              const int bgColor)\r\n{\r\n\tfloat _angle = ((float) (-degrees / 180.0f) * (float)M_PI);\r\n\tconst int src_w  = gdImageSX(src);\r\n\tconst int src_h = gdImageSY(src);\r\n\tconst gdFixed f_0_5 = gd_ftofx(0.5f);\r\n\tconst gdFixed f_H = gd_itofx(src_h/2);\r\n\tconst gdFixed f_W = gd_itofx(src_w/2);\r\n\tconst gdFixed f_cos = gd_ftofx(cos(-_angle));\r\n\tconst gdFixed f_sin = gd_ftofx(sin(-_angle));\r\n\r\n\tunsigned int dst_offset_x;\r\n\tunsigned int dst_offset_y = 0;\r\n\tunsigned int i;\r\n\tgdImagePtr dst;\r\n\tgdRect bbox;\r\n\tunsigned int new_height, new_width;\r\n\r\n    gdRotatedImageSize(src, degrees, &bbox);\r\n    new_width = bbox.width;\r\n    new_height = bbox.height;\r\n\r\n\tdst = gdImageCreateTrueColor(new_width, new_height);\r\n\tif (!dst) {\r\n\t\treturn NULL;\r\n\t}\r\n\tdst->saveAlphaFlag = 1;\r\n\tfor (i = 0; i < new_height; i++) {\r\n\t\tunsigned int j;\r\n\t\tdst_offset_x = 0;\r\n\t\tfor (j = 0; j < new_width; j++) {\r\n\t\t\tgdFixed f_i = gd_itofx((int)i - (int)new_height / 2);\r\n\t\t\tgdFixed f_j = gd_itofx((int)j - (int)new_width  / 2);\r\n\t\t\tgdFixed f_m = gd_mulfx(f_j,f_sin) + gd_mulfx(f_i,f_cos) + f_0_5 + f_H;\r\n\t\t\tgdFixed f_n = gd_mulfx(f_j,f_cos) - gd_mulfx(f_i,f_sin) + f_0_5 + f_W;\r\n\t\t\tlong m = gd_fxtoi(f_m);\r\n\t\t\tlong n = gd_fxtoi(f_n);\r\n\r\n\t\t\tif ((m > 0) && (m < src_h-1) && (n > 0) && (n < src_w-1)) {\r\n\t\t\t\tif (dst_offset_y < new_height) {\r\n\t\t\t\t\tdst->tpixels[dst_offset_y][dst_offset_x++] = src->tpixels[m][n];\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tif (dst_offset_y < new_height) {\r\n\t\t\t\t\tdst->tpixels[dst_offset_y][dst_offset_x++] = bgColor;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tdst_offset_y++;\r\n\t}\r\n\treturn dst;\r\n}"}, "function_name": "gdImageGetInterpolationMethod"}
{"function_id": null, "caller": {}, "callee": {}, "function_name": ""}
{"function_id": null, "caller": {".c_get_version": "static int ec_get_version(struct cros_ec_dev *ec, char *str, int maxlen)\r\n{\r\n\tstruct ec_response_get_version *resp;\r\n\tstatic const char * const current_image_name[] = {\r\n\t\t\"unknown\", \"read-only\", \"read-write\", \"invalid\",\r\n\t};\r\n\tstruct cros_ec_command *msg;\r\n\tint ret;\r\n\r\n\tmsg = kmalloc(sizeof(*msg) + sizeof(*resp), GFP_KERNEL);\r\n\tif (!msg)\r\n\t\treturn -ENOMEM;\r\n\r\n\tmsg->version = 0;\r\n\tmsg->command = EC_CMD_GET_VERSION + ec->cmd_offset;\r\n\tmsg->insize = sizeof(*resp);\r\n\tmsg->outsize = 0;\r\n\r\n\tret = cros_ec_cmd_xfer(ec->ec_dev, msg);\r\n\tif (ret < 0)\r\n\t\tgoto exit;\r\n\r\n\tif (msg->result != EC_RES_SUCCESS) {\r\n\t\tsnprintf(str, maxlen,\r\n\t\t\t \"%s\\nUnknown EC version: EC returned %d\\n\",\r\n\t\t\t CROS_EC_DEV_VERSION, msg->result);\r\n\t\tret = -EINVAL;\r\n\t\tgoto exit;\r\n\t}\r\n\r\n\tresp = (struct ec_response_get_version *)msg->data;\r\n\tif (resp->current_image >= ARRAY_SIZE(current_image_name))\r\n\t\tresp->current_image = 3; /* invalid */\r\n\r\n\tsnprintf(str, maxlen, \"%s\\n%s\\n%s\\n%s\\n\", CROS_EC_DEV_VERSION,\r\n\t\t resp->version_string_ro, resp->version_string_rw,\r\n\t\t current_image_name[resp->current_image]);\r\n\r\n\tret = 0;\r\nexit:\r\n\tkfree(msg);\r\n\treturn ret;\r\n}", ".c_device_ioctl_xcmd": "static long ec_device_ioctl_xcmd(struct cros_ec_dev *ec, void __user *arg)\r\n{\r\n\tlong ret;\r\n\tstruct cros_ec_command u_cmd;\r\n\tstruct cros_ec_command *s_cmd;\r\n\r\n\tif (copy_from_user(&u_cmd, arg, sizeof(u_cmd)))\r\n\t\treturn -EFAULT;\r\n\r\n\tif ((u_cmd.outsize > EC_MAX_MSG_BYTES) ||\r\n\t    (u_cmd.insize > EC_MAX_MSG_BYTES))\r\n\t\treturn -EINVAL;\r\n\r\n\ts_cmd = kmalloc(sizeof(*s_cmd) + max(u_cmd.outsize, u_cmd.insize),\r\n\t\t\tGFP_KERNEL);\r\n\tif (!s_cmd)\r\n\t\treturn -ENOMEM;\r\n\r\n\tif (copy_from_user(s_cmd, arg, sizeof(*s_cmd) + u_cmd.outsize)) {\r\n\t\tret = -EFAULT;\r\n\t\tgoto exit;\r\n\t}\r\n\r\n\tif (u_cmd.outsize != s_cmd->outsize ||\r\n\t    u_cmd.insize != s_cmd->insize) {\r\n\t\tret = -EINVAL;\r\n\t\tgoto exit;\r\n\t}\r\n\r\n\ts_cmd->command += ec->cmd_offset;\r\n\tret = cros_ec_cmd_xfer(ec->ec_dev, s_cmd);\r\n\t/* Only copy data to userland if data was received. */\r\n\tif (ret < 0)\r\n\t\tgoto exit;\r\n\r\n\tif (copy_to_user(arg, s_cmd, sizeof(*s_cmd) + s_cmd->insize))\r\n\t\tret = -EFAULT;\r\nexit:\r\n\tkfree(s_cmd);\r\n\treturn ret;\r\n}", ".c_device_ioctl_readmem": "static long ec_device_ioctl_readmem(struct cros_ec_dev *ec, void __user *arg)\r\n{\r\n\tstruct cros_ec_device *ec_dev = ec->ec_dev;\r\n\tstruct cros_ec_readmem s_mem = { };\r\n\tlong num;\r\n\r\n\t/* Not every platform supports direct reads */\r\n\tif (!ec_dev->cmd_readmem)\r\n\t\treturn -ENOTTY;\r\n\r\n\tif (copy_from_user(&s_mem, arg, sizeof(s_mem)))\r\n\t\treturn -EFAULT;\r\n\r\n\tnum = ec_dev->cmd_readmem(ec_dev, s_mem.offset, s_mem.bytes,\r\n\t\t\t\t  s_mem.buffer);\r\n\tif (num <= 0)\r\n\t\treturn num;\r\n\r\n\tif (copy_to_user((void __user *)arg, &s_mem, sizeof(s_mem)))\r\n\t\treturn -EFAULT;\r\n\r\n\treturn 0;\r\n}", ".ros_ec_check_features": "static int cros_ec_check_features(struct cros_ec_dev *ec, int feature)\r\n{\r\n\tstruct cros_ec_command *msg;\r\n\tint ret;\r\n\r\n\tif (ec->features[0] == -1U && ec->features[1] == -1U) {\r\n\t\t/* features bitmap not read yet */\r\n\r\n\t\tmsg = kmalloc(sizeof(*msg) + sizeof(ec->features), GFP_KERNEL);\r\n\t\tif (!msg)\r\n\t\t\treturn -ENOMEM;\r\n\r\n\t\tmsg->version = 0;\r\n\t\tmsg->command = EC_CMD_GET_FEATURES + ec->cmd_offset;\r\n\t\tmsg->insize = sizeof(ec->features);\r\n\t\tmsg->outsize = 0;\r\n\r\n\t\tret = cros_ec_cmd_xfer(ec->ec_dev, msg);\r\n\t\tif (ret < 0 || msg->result != EC_RES_SUCCESS) {\r\n\t\t\tdev_warn(ec->dev, \"cannot get EC features: %d/%d\\n\",\r\n\t\t\t\t ret, msg->result);\r\n\t\t\tmemset(ec->features, 0, sizeof(ec->features));\r\n\t\t}\r\n\r\n\t\tmemcpy(ec->features, msg->data, sizeof(ec->features));\r\n\r\n\t\tdev_dbg(ec->dev, \"EC features %08x %08x\\n\",\r\n\t\t\tec->features[0], ec->features[1]);\r\n\r\n\t\tkfree(msg);\r\n\t}\r\n\r\n\treturn ec->features[feature / 32] & EC_FEATURE_MASK_0(feature);\r\n}", ".ros_ec_sensors_register": "static void cros_ec_sensors_register(struct cros_ec_dev *ec)\r\n{\r\n\t/*\r\n\t * Issue a command to get the number of sensor reported.\r\n\t * Build an array of sensors driver and register them all.\r\n\t */\r\n\tint ret, i, id, sensor_num;\r\n\tstruct mfd_cell *sensor_cells;\r\n\tstruct cros_ec_sensor_platform *sensor_platforms;\r\n\tint sensor_type[MOTIONSENSE_TYPE_MAX];\r\n\tstruct ec_params_motion_sense *params;\r\n\tstruct ec_response_motion_sense *resp;\r\n\tstruct cros_ec_command *msg;\r\n\r\n\tmsg = kzalloc(sizeof(struct cros_ec_command) +\r\n\t\t      max(sizeof(*params), sizeof(*resp)), GFP_KERNEL);\r\n\tif (msg == NULL)\r\n\t\treturn;\r\n\r\n\tmsg->version = 2;\r\n\tmsg->command = EC_CMD_MOTION_SENSE_CMD + ec->cmd_offset;\r\n\tmsg->outsize = sizeof(*params);\r\n\tmsg->insize = sizeof(*resp);\r\n\r\n\tparams = (struct ec_params_motion_sense *)msg->data;\r\n\tparams->cmd = MOTIONSENSE_CMD_DUMP;\r\n\r\n\tret = cros_ec_cmd_xfer(ec->ec_dev, msg);\r\n\tif (ret < 0 || msg->result != EC_RES_SUCCESS) {\r\n\t\tdev_warn(ec->dev, \"cannot get EC sensor information: %d/%d\\n\",\r\n\t\t\t ret, msg->result);\r\n\t\tgoto error;\r\n\t}\r\n\r\n\tresp = (struct ec_response_motion_sense *)msg->data;\r\n\tsensor_num = resp->dump.sensor_count;\r\n\t/* Allocate 2 extra sensors in case lid angle or FIFO are needed */\r\n\tsensor_cells = kzalloc(sizeof(struct mfd_cell) * (sensor_num + 2),\r\n\t\t\t       GFP_KERNEL);\r\n\tif (sensor_cells == NULL)\r\n\t\tgoto error;\r\n\r\n\tsensor_platforms = kzalloc(sizeof(struct cros_ec_sensor_platform) *\r\n\t\t  (sensor_num + 1), GFP_KERNEL);\r\n\tif (sensor_platforms == NULL)\r\n\t\tgoto error_platforms;\r\n\r\n\tmemset(sensor_type, 0, sizeof(sensor_type));\r\n\tid = 0;\r\n\tfor (i = 0; i < sensor_num; i++) {\r\n\t\tparams->cmd = MOTIONSENSE_CMD_INFO;\r\n\t\tparams->info.sensor_num = i;\r\n\t\tret = cros_ec_cmd_xfer(ec->ec_dev, msg);\r\n\t\tif (ret < 0 || msg->result != EC_RES_SUCCESS) {\r\n\t\t\tdev_warn(ec->dev, \"no info for EC sensor %d : %d/%d\\n\",\r\n\t\t\t\t i, ret, msg->result);\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tswitch (resp->info.type) {\r\n\t\tcase MOTIONSENSE_TYPE_ACCEL:\r\n\t\t\tsensor_cells[id].name = \"cros-ec-accel\";\r\n\t\t\tbreak;\r\n\t\tcase MOTIONSENSE_TYPE_BARO:\r\n\t\t\tsensor_cells[id].name = \"cros-ec-baro\";\r\n\t\t\tbreak;\r\n\t\tcase MOTIONSENSE_TYPE_GYRO:\r\n\t\t\tsensor_cells[id].name = \"cros-ec-gyro\";\r\n\t\t\tbreak;\r\n\t\tcase MOTIONSENSE_TYPE_MAG:\r\n\t\t\tsensor_cells[id].name = \"cros-ec-mag\";\r\n\t\t\tbreak;\r\n\t\tcase MOTIONSENSE_TYPE_PROX:\r\n\t\t\tsensor_cells[id].name = \"cros-ec-prox\";\r\n\t\t\tbreak;\r\n\t\tcase MOTIONSENSE_TYPE_LIGHT:\r\n\t\t\tsensor_cells[id].name = \"cros-ec-light\";\r\n\t\t\tbreak;\r\n\t\tcase MOTIONSENSE_TYPE_ACTIVITY:\r\n\t\t\tsensor_cells[id].name = \"cros-ec-activity\";\r\n\t\t\tbreak;\r\n\t\tdefault:\r\n\t\t\tdev_warn(ec->dev, \"unknown type %d\\n\", resp->info.type);\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tsensor_platforms[id].sensor_num = i;\r\n\t\tsensor_cells[id].id = sensor_type[resp->info.type];\r\n\t\tsensor_cells[id].platform_data = &sensor_platforms[id];\r\n\t\tsensor_cells[id].pdata_size =\r\n\t\t\tsizeof(struct cros_ec_sensor_platform);\r\n\r\n\t\tsensor_type[resp->info.type]++;\r\n\t\tid++;\r\n\t}\r\n\tif (sensor_type[MOTIONSENSE_TYPE_ACCEL] >= 2) {\r\n\t\tsensor_platforms[id].sensor_num = sensor_num;\r\n\r\n\t\tsensor_cells[id].name = \"cros-ec-angle\";\r\n\t\tsensor_cells[id].id = 0;\r\n\t\tsensor_cells[id].platform_data = &sensor_platforms[id];\r\n\t\tsensor_cells[id].pdata_size =\r\n\t\t\tsizeof(struct cros_ec_sensor_platform);\r\n\t\tid++;\r\n\t}\r\n\tif (cros_ec_check_features(ec, EC_FEATURE_MOTION_SENSE_FIFO)) {\r\n\t\tsensor_cells[id].name = \"cros-ec-ring\";\r\n\t\tid++;\r\n\t}\r\n\r\n\tret = mfd_add_devices(ec->dev, 0, sensor_cells, id,\r\n\t\t\t      NULL, 0, NULL);\r\n\tif (ret)\r\n\t\tdev_err(ec->dev, \"failed to add EC sensors\\n\");\r\n\r\n\tkfree(sensor_platforms);\r\nerror_platforms:\r\n\tkfree(sensor_cells);\r\nerror:\r\n\tkfree(msg);\r\n}"}, "callee": {".c_device_read": "static ssize_t ec_device_read(struct file *filp, char __user *buffer,\r\n\t\t\t      size_t length, loff_t *offset)\r\n{\r\n\tstruct cros_ec_dev *ec = filp->private_data;\r\n\tchar msg[sizeof(struct ec_response_get_version) +\r\n\t\t sizeof(CROS_EC_DEV_VERSION)];\r\n\tsize_t count;\r\n\tint ret;\r\n\r\n\tif (*offset != 0)\r\n\t\treturn 0;\r\n\r\n\tret = ec_get_version(ec, msg, sizeof(msg));\r\n\tif (ret)\r\n\t\treturn ret;\r\n\r\n\tcount = min(length, strlen(msg));\r\n\r\n\tif (copy_to_user(buffer, msg, count))\r\n\t\treturn -EFAULT;\r\n\r\n\t*offset = count;\r\n\treturn count;\r\n}", ".ros_ec_sensors_register": "static void cros_ec_sensors_register(struct cros_ec_dev *ec)\r\n{\r\n\t/*\r\n\t * Issue a command to get the number of sensor reported.\r\n\t * Build an array of sensors driver and register them all.\r\n\t */\r\n\tint ret, i, id, sensor_num;\r\n\tstruct mfd_cell *sensor_cells;\r\n\tstruct cros_ec_sensor_platform *sensor_platforms;\r\n\tint sensor_type[MOTIONSENSE_TYPE_MAX];\r\n\tstruct ec_params_motion_sense *params;\r\n\tstruct ec_response_motion_sense *resp;\r\n\tstruct cros_ec_command *msg;\r\n\r\n\tmsg = kzalloc(sizeof(struct cros_ec_command) +\r\n\t\t      max(sizeof(*params), sizeof(*resp)), GFP_KERNEL);\r\n\tif (msg == NULL)\r\n\t\treturn;\r\n\r\n\tmsg->version = 2;\r\n\tmsg->command = EC_CMD_MOTION_SENSE_CMD + ec->cmd_offset;\r\n\tmsg->outsize = sizeof(*params);\r\n\tmsg->insize = sizeof(*resp);\r\n\r\n\tparams = (struct ec_params_motion_sense *)msg->data;\r\n\tparams->cmd = MOTIONSENSE_CMD_DUMP;\r\n\r\n\tret = cros_ec_cmd_xfer(ec->ec_dev, msg);\r\n\tif (ret < 0 || msg->result != EC_RES_SUCCESS) {\r\n\t\tdev_warn(ec->dev, \"cannot get EC sensor information: %d/%d\\n\",\r\n\t\t\t ret, msg->result);\r\n\t\tgoto error;\r\n\t}\r\n\r\n\tresp = (struct ec_response_motion_sense *)msg->data;\r\n\tsensor_num = resp->dump.sensor_count;\r\n\t/* Allocate 2 extra sensors in case lid angle or FIFO are needed */\r\n\tsensor_cells = kzalloc(sizeof(struct mfd_cell) * (sensor_num + 2),\r\n\t\t\t       GFP_KERNEL);\r\n\tif (sensor_cells == NULL)\r\n\t\tgoto error;\r\n\r\n\tsensor_platforms = kzalloc(sizeof(struct cros_ec_sensor_platform) *\r\n\t\t  (sensor_num + 1), GFP_KERNEL);\r\n\tif (sensor_platforms == NULL)\r\n\t\tgoto error_platforms;\r\n\r\n\tmemset(sensor_type, 0, sizeof(sensor_type));\r\n\tid = 0;\r\n\tfor (i = 0; i < sensor_num; i++) {\r\n\t\tparams->cmd = MOTIONSENSE_CMD_INFO;\r\n\t\tparams->info.sensor_num = i;\r\n\t\tret = cros_ec_cmd_xfer(ec->ec_dev, msg);\r\n\t\tif (ret < 0 || msg->result != EC_RES_SUCCESS) {\r\n\t\t\tdev_warn(ec->dev, \"no info for EC sensor %d : %d/%d\\n\",\r\n\t\t\t\t i, ret, msg->result);\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tswitch (resp->info.type) {\r\n\t\tcase MOTIONSENSE_TYPE_ACCEL:\r\n\t\t\tsensor_cells[id].name = \"cros-ec-accel\";\r\n\t\t\tbreak;\r\n\t\tcase MOTIONSENSE_TYPE_BARO:\r\n\t\t\tsensor_cells[id].name = \"cros-ec-baro\";\r\n\t\t\tbreak;\r\n\t\tcase MOTIONSENSE_TYPE_GYRO:\r\n\t\t\tsensor_cells[id].name = \"cros-ec-gyro\";\r\n\t\t\tbreak;\r\n\t\tcase MOTIONSENSE_TYPE_MAG:\r\n\t\t\tsensor_cells[id].name = \"cros-ec-mag\";\r\n\t\t\tbreak;\r\n\t\tcase MOTIONSENSE_TYPE_PROX:\r\n\t\t\tsensor_cells[id].name = \"cros-ec-prox\";\r\n\t\t\tbreak;\r\n\t\tcase MOTIONSENSE_TYPE_LIGHT:\r\n\t\t\tsensor_cells[id].name = \"cros-ec-light\";\r\n\t\t\tbreak;\r\n\t\tcase MOTIONSENSE_TYPE_ACTIVITY:\r\n\t\t\tsensor_cells[id].name = \"cros-ec-activity\";\r\n\t\t\tbreak;\r\n\t\tdefault:\r\n\t\t\tdev_warn(ec->dev, \"unknown type %d\\n\", resp->info.type);\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tsensor_platforms[id].sensor_num = i;\r\n\t\tsensor_cells[id].id = sensor_type[resp->info.type];\r\n\t\tsensor_cells[id].platform_data = &sensor_platforms[id];\r\n\t\tsensor_cells[id].pdata_size =\r\n\t\t\tsizeof(struct cros_ec_sensor_platform);\r\n\r\n\t\tsensor_type[resp->info.type]++;\r\n\t\tid++;\r\n\t}\r\n\tif (sensor_type[MOTIONSENSE_TYPE_ACCEL] >= 2) {\r\n\t\tsensor_platforms[id].sensor_num = sensor_num;\r\n\r\n\t\tsensor_cells[id].name = \"cros-ec-angle\";\r\n\t\tsensor_cells[id].id = 0;\r\n\t\tsensor_cells[id].platform_data = &sensor_platforms[id];\r\n\t\tsensor_cells[id].pdata_size =\r\n\t\t\tsizeof(struct cros_ec_sensor_platform);\r\n\t\tid++;\r\n\t}\r\n\tif (cros_ec_check_features(ec, EC_FEATURE_MOTION_SENSE_FIFO)) {\r\n\t\tsensor_cells[id].name = \"cros-ec-ring\";\r\n\t\tid++;\r\n\t}\r\n\r\n\tret = mfd_add_devices(ec->dev, 0, sensor_cells, id,\r\n\t\t\t      NULL, 0, NULL);\r\n\tif (ret)\r\n\t\tdev_err(ec->dev, \"failed to add EC sensors\\n\");\r\n\r\n\tkfree(sensor_platforms);\r\nerror_platforms:\r\n\tkfree(sensor_cells);\r\nerror:\r\n\tkfree(msg);\r\n}", ".c_device_probe": "static int ec_device_probe(struct platform_device *pdev)\r\n{\r\n\tint retval = -ENOMEM;\r\n\tstruct device *dev = &pdev->dev;\r\n\tstruct cros_ec_platform *ec_platform = dev_get_platdata(dev);\r\n\tstruct cros_ec_dev *ec = kzalloc(sizeof(*ec), GFP_KERNEL);\r\n\r\n\tif (!ec)\r\n\t\treturn retval;\r\n\r\n\tdev_set_drvdata(dev, ec);\r\n\tec->ec_dev = dev_get_drvdata(dev->parent);\r\n\tec->dev = dev;\r\n\tec->cmd_offset = ec_platform->cmd_offset;\r\n\tec->features[0] = -1U; /* Not cached yet */\r\n\tec->features[1] = -1U; /* Not cached yet */\r\n\tdevice_initialize(&ec->class_dev);\r\n\tcdev_init(&ec->cdev, &fops);\r\n\r\n\t/*\r\n\t * Add the class device\r\n\t * Link to the character device for creating the /dev entry\r\n\t * in devtmpfs.\r\n\t */\r\n\tec->class_dev.devt = MKDEV(ec_major, pdev->id);\r\n\tec->class_dev.class = &cros_class;\r\n\tec->class_dev.parent = dev;\r\n\tec->class_dev.release = __remove;\r\n\r\n\tretval = dev_set_name(&ec->class_dev, \"%s\", ec_platform->ec_name);\r\n\tif (retval) {\r\n\t\tdev_err(dev, \"dev_set_name failed => %d\\n\", retval);\r\n\t\tgoto failed;\r\n\t}\r\n\r\n\tretval = cdev_device_add(&ec->cdev, &ec->class_dev);\r\n\tif (retval) {\r\n\t\tdev_err(dev, \"cdev_device_add failed => %d\\n\", retval);\r\n\t\tgoto failed;\r\n\t}\r\n\r\n\tif (cros_ec_debugfs_init(ec))\r\n\t\tdev_warn(dev, \"failed to create debugfs directory\\n\");\r\n\r\n\t/* check whether this EC is a sensor hub. */\r\n\tif (cros_ec_check_features(ec, EC_FEATURE_MOTION_SENSE))\r\n\t\tcros_ec_sensors_register(ec);\r\n\r\n\t/* Take control of the lightbar from the EC. */\r\n\tlb_manual_suspend_ctrl(ec, 1);\r\n\r\n\treturn 0;\r\n\r\nfailed:\r\n\tput_device(&ec->class_dev);\r\n\treturn retval;\r\n}", ".c_device_ioctl": "static long ec_device_ioctl(struct file *filp, unsigned int cmd,\r\n\t\t\t    unsigned long arg)\r\n{\r\n\tstruct cros_ec_dev *ec = filp->private_data;\r\n\r\n\tif (_IOC_TYPE(cmd) != CROS_EC_DEV_IOC)\r\n\t\treturn -ENOTTY;\r\n\r\n\tswitch (cmd) {\r\n\tcase CROS_EC_DEV_IOCXCMD:\r\n\t\treturn ec_device_ioctl_xcmd(ec, (void __user *)arg);\r\n\tcase CROS_EC_DEV_IOCRDMEM:\r\n\t\treturn ec_device_ioctl_readmem(ec, (void __user *)arg);\r\n\t}\r\n\r\n\treturn -ENOTTY;\r\n}"}, "function_name": "cros_ec_dev_exit"}
{"function_id": null, "caller": {}, "callee": {}, "function_name": ""}
{"function_id": null, "caller": {".hp_flock_common": "PHPAPI void php_flock_common(php_stream *stream, zend_long operation,\r\n\tuint32_t operation_arg_num, zval *wouldblock, zval *return_value)\r\n{\r\n\tint flock_values[] = { LOCK_SH, LOCK_EX, LOCK_UN };\r\n\tint act;\r\n\r\n\tact = operation & PHP_LOCK_UN;\r\n\tif (act < 1 || act > 3) {\r\n\t\tzend_argument_value_error(operation_arg_num, \"must be one of LOCK_SH, LOCK_EX, or LOCK_UN\");\r\n\t\tRETURN_THROWS();\r\n\t}\r\n\r\n\tif (wouldblock) {\r\n\t\tZEND_TRY_ASSIGN_REF_LONG(wouldblock, 0);\r\n\t}\r\n\r\n\t/* flock_values contains all possible actions if (operation & PHP_LOCK_NB) we won't block on the lock */\r\n\tact = flock_values[act - 1] | (operation & PHP_LOCK_NB ? LOCK_NB : 0);\r\n\tif (php_stream_lock(stream, act)) {\r\n\t\tif (operation && errno == EWOULDBLOCK && wouldblock) {\r\n\t\t\tZEND_TRY_ASSIGN_REF_LONG(wouldblock, 1);\r\n\t\t}\r\n\t\tRETURN_FALSE;\r\n\t}\r\n\tRETURN_TRUE;\r\n}"}, "callee": {".HP_FUNCTION": "PHPAPI PHP_FUNCTION(fclose)\r\n{\r\n\tphp_stream *stream;\r\n\r\n\tZEND_PARSE_PARAMETERS_START(1, 1)\r\n\t\tPHP_Z_PARAM_STREAM(stream)\r\n\tZEND_PARSE_PARAMETERS_END();\r\n\r\n\tif ((stream->flags & PHP_STREAM_FLAG_NO_FCLOSE) != 0) {\r\n\t\tphp_error_docref(NULL, E_WARNING, \"cannot close the provided stream, as it must not be manually closed\");\r\n\t\tRETURN_FALSE;\r\n\t}\r\n\r\n\tphp_stream_free(stream,\r\n\t\tPHP_STREAM_FREE_KEEP_RSRC |\r\n\t\t(stream->is_persistent ? PHP_STREAM_FREE_CLOSE_PERSISTENT : PHP_STREAM_FREE_CLOSE));\r\n\r\n\tRETURN_TRUE;\r\n}"}, "function_name": "PHP_FUNCTION"}
{"function_id": null, "caller": {".irspy_convert_stream": "static unsigned int airspy_convert_stream(struct airspy *s,\r\n\t\tvoid *dst, void *src, unsigned int src_len)\r\n{\r\n\tunsigned int dst_len;\r\n\r\n\tif (s->pixelformat == V4L2_SDR_FMT_RU12LE) {\r\n\t\tmemcpy(dst, src, src_len);\r\n\t\tdst_len = src_len;\r\n\t} else {\r\n\t\tdst_len = 0;\r\n\t}\r\n\r\n\t/* calculate sample rate and output it in 10 seconds intervals */\r\n\tif (unlikely(time_is_before_jiffies(s->jiffies_next))) {\r\n\t\t#define MSECS 10000UL\r\n\t\tunsigned int msecs = jiffies_to_msecs(jiffies -\r\n\t\t\t\ts->jiffies_next + msecs_to_jiffies(MSECS));\r\n\t\tunsigned int samples = s->sample - s->sample_measured;\r\n\r\n\t\ts->jiffies_next = jiffies + msecs_to_jiffies(MSECS);\r\n\t\ts->sample_measured = s->sample;\r\n\t\tdev_dbg(s->dev, \"slen=%u samples=%u msecs=%u sample rate=%lu\\n\",\r\n\t\t\t\tsrc_len, samples, msecs,\r\n\t\t\t\tsamples * 1000UL / msecs);\r\n\t}\r\n\r\n\t/* total number of samples */\r\n\ts->sample += src_len / 2;\r\n\r\n\treturn dst_len;\r\n}", ".irspy_kill_urbs": "static int airspy_kill_urbs(struct airspy *s)\r\n{\r\n\tint i;\r\n\r\n\tfor (i = s->urbs_submitted - 1; i >= 0; i--) {\r\n\t\tdev_dbg(s->dev, \"kill urb=%d\\n\", i);\r\n\t\t/* stop the URB */\r\n\t\tusb_kill_urb(s->urb_list[i]);\r\n\t}\r\n\ts->urbs_submitted = 0;\r\n\r\n\treturn 0;\r\n}", ".irspy_free_stream_bufs": "static int airspy_free_stream_bufs(struct airspy *s)\r\n{\r\n\tif (test_bit(USB_STATE_URB_BUF, &s->flags)) {\r\n\t\twhile (s->buf_num) {\r\n\t\t\ts->buf_num--;\r\n\t\t\tdev_dbg(s->dev, \"free buf=%d\\n\", s->buf_num);\r\n\t\t\tusb_free_coherent(s->udev, s->buf_size,\r\n\t\t\t\t\t  s->buf_list[s->buf_num],\r\n\t\t\t\t\t  s->dma_addr[s->buf_num]);\r\n\t\t}\r\n\t}\r\n\tclear_bit(USB_STATE_URB_BUF, &s->flags);\r\n\r\n\treturn 0;\r\n}", ".irspy_urb_complete": "static void airspy_urb_complete(struct urb *urb)\r\n{\r\n\tstruct airspy *s = urb->context;\r\n\tstruct airspy_frame_buf *fbuf;\r\n\r\n\tdev_dbg_ratelimited(s->dev, \"status=%d length=%d/%d errors=%d\\n\",\r\n\t\t\turb->status, urb->actual_length,\r\n\t\t\turb->transfer_buffer_length, urb->error_count);\r\n\r\n\tswitch (urb->status) {\r\n\tcase 0:             /* success */\r\n\tcase -ETIMEDOUT:    /* NAK */\r\n\t\tbreak;\r\n\tcase -ECONNRESET:   /* kill */\r\n\tcase -ENOENT:\r\n\tcase -ESHUTDOWN:\r\n\t\treturn;\r\n\tdefault:            /* error */\r\n\t\tdev_err_ratelimited(s->dev, \"URB failed %d\\n\", urb->status);\r\n\t\tbreak;\r\n\t}\r\n\r\n\tif (likely(urb->actual_length > 0)) {\r\n\t\tvoid *ptr;\r\n\t\tunsigned int len;\r\n\t\t/* get free framebuffer */\r\n\t\tfbuf = airspy_get_next_fill_buf(s);\r\n\t\tif (unlikely(fbuf == NULL)) {\r\n\t\t\ts->vb_full++;\r\n\t\t\tdev_notice_ratelimited(s->dev,\r\n\t\t\t\t\t\"video buffer is full, %d packets dropped\\n\",\r\n\t\t\t\t\ts->vb_full);\r\n\t\t\tgoto skip;\r\n\t\t}\r\n\r\n\t\t/* fill framebuffer */\r\n\t\tptr = vb2_plane_vaddr(&fbuf->vb.vb2_buf, 0);\r\n\t\tlen = airspy_convert_stream(s, ptr, urb->transfer_buffer,\r\n\t\t\t\turb->actual_length);\r\n\t\tvb2_set_plane_payload(&fbuf->vb.vb2_buf, 0, len);\r\n\t\tfbuf->vb.vb2_buf.timestamp = ktime_get_ns();\r\n\t\tfbuf->vb.sequence = s->sequence++;\r\n\t\tvb2_buffer_done(&fbuf->vb.vb2_buf, VB2_BUF_STATE_DONE);\r\n\t}\r\nskip:\r\n\tusb_submit_urb(urb, GFP_ATOMIC);\r\n}", ".irspy_alloc_stream_bufs": "static int airspy_alloc_stream_bufs(struct airspy *s)\r\n{\r\n\ts->buf_num = 0;\r\n\ts->buf_size = BULK_BUFFER_SIZE;\r\n\r\n\tdev_dbg(s->dev, \"all in all I will use %u bytes for streaming\\n\",\r\n\t\t\tMAX_BULK_BUFS * BULK_BUFFER_SIZE);\r\n\r\n\tfor (s->buf_num = 0; s->buf_num < MAX_BULK_BUFS; s->buf_num++) {\r\n\t\ts->buf_list[s->buf_num] = usb_alloc_coherent(s->udev,\r\n\t\t\t\tBULK_BUFFER_SIZE, GFP_ATOMIC,\r\n\t\t\t\t&s->dma_addr[s->buf_num]);\r\n\t\tif (!s->buf_list[s->buf_num]) {\r\n\t\t\tdev_dbg(s->dev, \"alloc buf=%d failed\\n\", s->buf_num);\r\n\t\t\tairspy_free_stream_bufs(s);\r\n\t\t\treturn -ENOMEM;\r\n\t\t}\r\n\r\n\t\tdev_dbg(s->dev, \"alloc buf=%d %p (dma %llu)\\n\", s->buf_num,\r\n\t\t\t\ts->buf_list[s->buf_num],\r\n\t\t\t\t(long long)s->dma_addr[s->buf_num]);\r\n\t\tset_bit(USB_STATE_URB_BUF, &s->flags);\r\n\t}\r\n\r\n\treturn 0;\r\n}", ".irspy_alloc_urbs": "static int airspy_alloc_urbs(struct airspy *s)\r\n{\r\n\tint i, j;\r\n\r\n\t/* allocate the URBs */\r\n\tfor (i = 0; i < MAX_BULK_BUFS; i++) {\r\n\t\tdev_dbg(s->dev, \"alloc urb=%d\\n\", i);\r\n\t\ts->urb_list[i] = usb_alloc_urb(0, GFP_ATOMIC);\r\n\t\tif (!s->urb_list[i]) {\r\n\t\t\tfor (j = 0; j < i; j++) {\r\n\t\t\t\tusb_free_urb(s->urb_list[j]);\r\n\t\t\t\ts->urb_list[j] = NULL;\r\n\t\t\t}\r\n\t\t\ts->urbs_initialized = 0;\r\n\t\t\treturn -ENOMEM;\r\n\t\t}\r\n\t\tusb_fill_bulk_urb(s->urb_list[i],\r\n\t\t\t\ts->udev,\r\n\t\t\t\tusb_rcvbulkpipe(s->udev, 0x81),\r\n\t\t\t\ts->buf_list[i],\r\n\t\t\t\tBULK_BUFFER_SIZE,\r\n\t\t\t\tairspy_urb_complete, s);\r\n\r\n\t\ts->urb_list[i]->transfer_flags = URB_NO_TRANSFER_DMA_MAP;\r\n\t\ts->urb_list[i]->transfer_dma = s->dma_addr[i];\r\n\t\ts->urbs_initialized++;\r\n\t}\r\n\r\n\treturn 0;\r\n}", ".irspy_submit_urbs": "static int airspy_submit_urbs(struct airspy *s)\r\n{\r\n\tint i, ret;\r\n\r\n\tfor (i = 0; i < s->urbs_initialized; i++) {\r\n\t\tdev_dbg(s->dev, \"submit urb=%d\\n\", i);\r\n\t\tret = usb_submit_urb(s->urb_list[i], GFP_ATOMIC);\r\n\t\tif (ret) {\r\n\t\t\tdev_err(s->dev, \"Could not submit URB no. %d - get them all back\\n\",\r\n\t\t\t\t\ti);\r\n\t\t\tairspy_kill_urbs(s);\r\n\t\t\treturn ret;\r\n\t\t}\r\n\t\ts->urbs_submitted++;\r\n\t}\r\n\r\n\treturn 0;\r\n}", ".irspy_ctrl_msg": "static int airspy_ctrl_msg(struct airspy *s, u8 request, u16 value, u16 index,\r\n\t\tu8 *data, u16 size)\r\n{\r\n\tint ret;\r\n\tunsigned int pipe;\r\n\tu8 requesttype;\r\n\r\n\tswitch (request) {\r\n\tcase CMD_RECEIVER_MODE:\r\n\tcase CMD_SET_FREQ:\r\n\t\tpipe = usb_sndctrlpipe(s->udev, 0);\r\n\t\trequesttype = (USB_TYPE_VENDOR | USB_DIR_OUT);\r\n\t\tbreak;\r\n\tcase CMD_BOARD_ID_READ:\r\n\tcase CMD_VERSION_STRING_READ:\r\n\tcase CMD_BOARD_PARTID_SERIALNO_READ:\r\n\tcase CMD_SET_LNA_GAIN:\r\n\tcase CMD_SET_MIXER_GAIN:\r\n\tcase CMD_SET_VGA_GAIN:\r\n\tcase CMD_SET_LNA_AGC:\r\n\tcase CMD_SET_MIXER_AGC:\r\n\t\tpipe = usb_rcvctrlpipe(s->udev, 0);\r\n\t\trequesttype = (USB_TYPE_VENDOR | USB_DIR_IN);\r\n\t\tbreak;\r\n\tdefault:\r\n\t\tdev_err(s->dev, \"Unknown command %02x\\n\", request);\r\n\t\tret = -EINVAL;\r\n\t\tgoto err;\r\n\t}\r\n\r\n\t/* write request */\r\n\tif (!(requesttype & USB_DIR_IN))\r\n\t\tmemcpy(s->buf, data, size);\r\n\r\n\tret = usb_control_msg(s->udev, pipe, request, requesttype, value,\r\n\t\t\tindex, s->buf, size, 1000);\r\n\tairspy_dbg_usb_control_msg(s->dev, request, requesttype, value,\r\n\t\t\tindex, s->buf, size);\r\n\tif (ret < 0) {\r\n\t\tdev_err(s->dev, \"usb_control_msg() failed %d request %02x\\n\",\r\n\t\t\t\tret, request);\r\n\t\tgoto err;\r\n\t}\r\n\r\n\t/* read request */\r\n\tif (requesttype & USB_DIR_IN)\r\n\t\tmemcpy(data, s->buf, size);\r\n\r\n\treturn 0;\r\nerr:\r\n\treturn ret;\r\n}", ".irspy_free_urbs": "static int airspy_free_urbs(struct airspy *s)\r\n{\r\n\tint i;\r\n\r\n\tairspy_kill_urbs(s);\r\n\r\n\tfor (i = s->urbs_initialized - 1; i >= 0; i--) {\r\n\t\tif (s->urb_list[i]) {\r\n\t\t\tdev_dbg(s->dev, \"free urb=%d\\n\", i);\r\n\t\t\t/* free the URBs */\r\n\t\t\tusb_free_urb(s->urb_list[i]);\r\n\t\t}\r\n\t}\r\n\ts->urbs_initialized = 0;\r\n\r\n\treturn 0;\r\n}", ".irspy_cleanup_queued_bufs": "static void airspy_cleanup_queued_bufs(struct airspy *s)\r\n{\r\n\tunsigned long flags;\r\n\r\n\tdev_dbg(s->dev, \"\\n\");\r\n\r\n\tspin_lock_irqsave(&s->queued_bufs_lock, flags);\r\n\twhile (!list_empty(&s->queued_bufs)) {\r\n\t\tstruct airspy_frame_buf *buf;\r\n\r\n\t\tbuf = list_entry(s->queued_bufs.next,\r\n\t\t\t\tstruct airspy_frame_buf, list);\r\n\t\tlist_del(&buf->list);\r\n\t\tvb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_ERROR);\r\n\t}\r\n\tspin_unlock_irqrestore(&s->queued_bufs_lock, flags);\r\n}", ".irspy_set_lna_gain": "static int airspy_set_lna_gain(struct airspy *s)\r\n{\r\n\tint ret;\r\n\tu8 u8tmp;\r\n\r\n\tdev_dbg(s->dev, \"lna auto=%d->%d val=%d->%d\\n\",\r\n\t\t\ts->lna_gain_auto->cur.val, s->lna_gain_auto->val,\r\n\t\t\ts->lna_gain->cur.val, s->lna_gain->val);\r\n\r\n\tret = airspy_ctrl_msg(s, CMD_SET_LNA_AGC, 0, s->lna_gain_auto->val,\r\n\t\t\t&u8tmp, 1);\r\n\tif (ret)\r\n\t\tgoto err;\r\n\r\n\tif (s->lna_gain_auto->val == false) {\r\n\t\tret = airspy_ctrl_msg(s, CMD_SET_LNA_GAIN, 0, s->lna_gain->val,\r\n\t\t\t\t&u8tmp, 1);\r\n\t\tif (ret)\r\n\t\t\tgoto err;\r\n\t}\r\nerr:\r\n\tif (ret)\r\n\t\tdev_dbg(s->dev, \"failed=%d\\n\", ret);\r\n\r\n\treturn ret;\r\n}", ".irspy_set_mixer_gain": "static int airspy_set_mixer_gain(struct airspy *s)\r\n{\r\n\tint ret;\r\n\tu8 u8tmp;\r\n\r\n\tdev_dbg(s->dev, \"mixer auto=%d->%d val=%d->%d\\n\",\r\n\t\t\ts->mixer_gain_auto->cur.val, s->mixer_gain_auto->val,\r\n\t\t\ts->mixer_gain->cur.val, s->mixer_gain->val);\r\n\r\n\tret = airspy_ctrl_msg(s, CMD_SET_MIXER_AGC, 0, s->mixer_gain_auto->val,\r\n\t\t\t&u8tmp, 1);\r\n\tif (ret)\r\n\t\tgoto err;\r\n\r\n\tif (s->mixer_gain_auto->val == false) {\r\n\t\tret = airspy_ctrl_msg(s, CMD_SET_MIXER_GAIN, 0,\r\n\t\t\t\ts->mixer_gain->val, &u8tmp, 1);\r\n\t\tif (ret)\r\n\t\t\tgoto err;\r\n\t}\r\nerr:\r\n\tif (ret)\r\n\t\tdev_dbg(s->dev, \"failed=%d\\n\", ret);\r\n\r\n\treturn ret;\r\n}", ".irspy_set_if_gain": "static int airspy_set_if_gain(struct airspy *s)\r\n{\r\n\tint ret;\r\n\tu8 u8tmp;\r\n\r\n\tdev_dbg(s->dev, \"val=%d->%d\\n\", s->if_gain->cur.val, s->if_gain->val);\r\n\r\n\tret = airspy_ctrl_msg(s, CMD_SET_VGA_GAIN, 0, s->if_gain->val,\r\n\t\t\t&u8tmp, 1);\r\n\tif (ret)\r\n\t\tdev_dbg(s->dev, \"failed=%d\\n\", ret);\r\n\r\n\treturn ret;\r\n}", ".irspy_video_release": "static void airspy_video_release(struct v4l2_device *v)\r\n{\r\n\tstruct airspy *s = container_of(v, struct airspy, v4l2_dev);\r\n\r\n\tv4l2_ctrl_handler_free(&s->hdl);\r\n\tv4l2_device_unregister(&s->v4l2_dev);\r\n\tkfree(s->buf);\r\n\tkfree(s);\r\n}"}, "callee": {".irspy_start_streaming": "static int airspy_start_streaming(struct vb2_queue *vq, unsigned int count)\r\n{\r\n\tstruct airspy *s = vb2_get_drv_priv(vq);\r\n\tint ret;\r\n\r\n\tdev_dbg(s->dev, \"\\n\");\r\n\r\n\tif (!s->udev)\r\n\t\treturn -ENODEV;\r\n\r\n\tmutex_lock(&s->v4l2_lock);\r\n\r\n\ts->sequence = 0;\r\n\r\n\tset_bit(POWER_ON, &s->flags);\r\n\r\n\tret = airspy_alloc_stream_bufs(s);\r\n\tif (ret)\r\n\t\tgoto err_clear_bit;\r\n\r\n\tret = airspy_alloc_urbs(s);\r\n\tif (ret)\r\n\t\tgoto err_free_stream_bufs;\r\n\r\n\tret = airspy_submit_urbs(s);\r\n\tif (ret)\r\n\t\tgoto err_free_urbs;\r\n\r\n\t/* start hardware streaming */\r\n\tret = airspy_ctrl_msg(s, CMD_RECEIVER_MODE, 1, 0, NULL, 0);\r\n\tif (ret)\r\n\t\tgoto err_kill_urbs;\r\n\r\n\tgoto exit_mutex_unlock;\r\n\r\nerr_kill_urbs:\r\n\tairspy_kill_urbs(s);\r\nerr_free_urbs:\r\n\tairspy_free_urbs(s);\r\nerr_free_stream_bufs:\r\n\tairspy_free_stream_bufs(s);\r\nerr_clear_bit:\r\n\tclear_bit(POWER_ON, &s->flags);\r\n\r\n\t/* return all queued buffers to vb2 */\r\n\t{\r\n\t\tstruct airspy_frame_buf *buf, *tmp;\r\n\r\n\t\tlist_for_each_entry_safe(buf, tmp, &s->queued_bufs, list) {\r\n\t\t\tlist_del(&buf->list);\r\n\t\t\tvb2_buffer_done(&buf->vb.vb2_buf,\r\n\t\t\t\t\tVB2_BUF_STATE_QUEUED);\r\n\t\t}\r\n\t}\r\n\r\nexit_mutex_unlock:\r\n\tmutex_unlock(&s->v4l2_lock);\r\n\r\n\treturn ret;\r\n}", ".irspy_stop_streaming": "static void airspy_stop_streaming(struct vb2_queue *vq)\r\n{\r\n\tstruct airspy *s = vb2_get_drv_priv(vq);\r\n\r\n\tdev_dbg(s->dev, \"\\n\");\r\n\r\n\tmutex_lock(&s->v4l2_lock);\r\n\r\n\t/* stop hardware streaming */\r\n\tairspy_ctrl_msg(s, CMD_RECEIVER_MODE, 0, 0, NULL, 0);\r\n\r\n\tairspy_kill_urbs(s);\r\n\tairspy_free_urbs(s);\r\n\tairspy_free_stream_bufs(s);\r\n\r\n\tairspy_cleanup_queued_bufs(s);\r\n\r\n\tclear_bit(POWER_ON, &s->flags);\r\n\r\n\tmutex_unlock(&s->v4l2_lock);\r\n}", ".irspy_s_frequency": "static int airspy_s_frequency(struct file *file, void *priv,\r\n\t\tconst struct v4l2_frequency *f)\r\n{\r\n\tstruct airspy *s = video_drvdata(file);\r\n\tint ret;\r\n\tu8 buf[4];\r\n\r\n\tif (f->tuner == 0) {\r\n\t\ts->f_adc = clamp_t(unsigned int, f->frequency,\r\n\t\t\t\tbands[0].rangelow,\r\n\t\t\t\tbands[0].rangehigh);\r\n\t\tdev_dbg(s->dev, \"ADC frequency=%u Hz\\n\", s->f_adc);\r\n\t\tret = 0;\r\n\t} else if (f->tuner == 1) {\r\n\t\ts->f_rf = clamp_t(unsigned int, f->frequency,\r\n\t\t\t\tbands_rf[0].rangelow,\r\n\t\t\t\tbands_rf[0].rangehigh);\r\n\t\tdev_dbg(s->dev, \"RF frequency=%u Hz\\n\", s->f_rf);\r\n\t\tbuf[0] = (s->f_rf >>  0) & 0xff;\r\n\t\tbuf[1] = (s->f_rf >>  8) & 0xff;\r\n\t\tbuf[2] = (s->f_rf >> 16) & 0xff;\r\n\t\tbuf[3] = (s->f_rf >> 24) & 0xff;\r\n\t\tret = airspy_ctrl_msg(s, CMD_SET_FREQ, 0, 0, buf, 4);\r\n\t} else {\r\n\t\tret = -EINVAL;\r\n\t}\r\n\r\n\treturn ret;\r\n}", ".irspy_set_lna_gain": "static int airspy_set_lna_gain(struct airspy *s)\r\n{\r\n\tint ret;\r\n\tu8 u8tmp;\r\n\r\n\tdev_dbg(s->dev, \"lna auto=%d->%d val=%d->%d\\n\",\r\n\t\t\ts->lna_gain_auto->cur.val, s->lna_gain_auto->val,\r\n\t\t\ts->lna_gain->cur.val, s->lna_gain->val);\r\n\r\n\tret = airspy_ctrl_msg(s, CMD_SET_LNA_AGC, 0, s->lna_gain_auto->val,\r\n\t\t\t&u8tmp, 1);\r\n\tif (ret)\r\n\t\tgoto err;\r\n\r\n\tif (s->lna_gain_auto->val == false) {\r\n\t\tret = airspy_ctrl_msg(s, CMD_SET_LNA_GAIN, 0, s->lna_gain->val,\r\n\t\t\t\t&u8tmp, 1);\r\n\t\tif (ret)\r\n\t\t\tgoto err;\r\n\t}\r\nerr:\r\n\tif (ret)\r\n\t\tdev_dbg(s->dev, \"failed=%d\\n\", ret);\r\n\r\n\treturn ret;\r\n}", ".irspy_set_mixer_gain": "static int airspy_set_mixer_gain(struct airspy *s)\r\n{\r\n\tint ret;\r\n\tu8 u8tmp;\r\n\r\n\tdev_dbg(s->dev, \"mixer auto=%d->%d val=%d->%d\\n\",\r\n\t\t\ts->mixer_gain_auto->cur.val, s->mixer_gain_auto->val,\r\n\t\t\ts->mixer_gain->cur.val, s->mixer_gain->val);\r\n\r\n\tret = airspy_ctrl_msg(s, CMD_SET_MIXER_AGC, 0, s->mixer_gain_auto->val,\r\n\t\t\t&u8tmp, 1);\r\n\tif (ret)\r\n\t\tgoto err;\r\n\r\n\tif (s->mixer_gain_auto->val == false) {\r\n\t\tret = airspy_ctrl_msg(s, CMD_SET_MIXER_GAIN, 0,\r\n\t\t\t\ts->mixer_gain->val, &u8tmp, 1);\r\n\t\tif (ret)\r\n\t\t\tgoto err;\r\n\t}\r\nerr:\r\n\tif (ret)\r\n\t\tdev_dbg(s->dev, \"failed=%d\\n\", ret);\r\n\r\n\treturn ret;\r\n}", ".irspy_set_if_gain": "static int airspy_set_if_gain(struct airspy *s)\r\n{\r\n\tint ret;\r\n\tu8 u8tmp;\r\n\r\n\tdev_dbg(s->dev, \"val=%d->%d\\n\", s->if_gain->cur.val, s->if_gain->val);\r\n\r\n\tret = airspy_ctrl_msg(s, CMD_SET_VGA_GAIN, 0, s->if_gain->val,\r\n\t\t\t&u8tmp, 1);\r\n\tif (ret)\r\n\t\tdev_dbg(s->dev, \"failed=%d\\n\", ret);\r\n\r\n\treturn ret;\r\n}", ".irspy_probe": "static int airspy_probe(struct usb_interface *intf,\r\n\t\tconst struct usb_device_id *id)\r\n{\r\n\tstruct airspy *s;\r\n\tint ret;\r\n\tu8 u8tmp, *buf;\r\n\r\n\tbuf = NULL;\r\n\tret = -ENOMEM;\r\n\r\n\ts = kzalloc(sizeof(struct airspy), GFP_KERNEL);\r\n\tif (s == NULL) {\r\n\t\tdev_err(&intf->dev, \"Could not allocate memory for state\\n\");\r\n\t\treturn -ENOMEM;\r\n\t}\r\n\r\n\ts->buf = kzalloc(BUF_SIZE, GFP_KERNEL);\r\n\tif (!s->buf)\r\n\t\tgoto err_free_mem;\r\n\tbuf = kzalloc(BUF_SIZE, GFP_KERNEL);\r\n\tif (!buf)\r\n\t\tgoto err_free_mem;\r\n\r\n\tmutex_init(&s->v4l2_lock);\r\n\tmutex_init(&s->vb_queue_lock);\r\n\tspin_lock_init(&s->queued_bufs_lock);\r\n\tINIT_LIST_HEAD(&s->queued_bufs);\r\n\ts->dev = &intf->dev;\r\n\ts->udev = interface_to_usbdev(intf);\r\n\ts->f_adc = bands[0].rangelow;\r\n\ts->f_rf = bands_rf[0].rangelow;\r\n\ts->pixelformat = formats[0].pixelformat;\r\n\ts->buffersize = formats[0].buffersize;\r\n\r\n\t/* Detect device */\r\n\tret = airspy_ctrl_msg(s, CMD_BOARD_ID_READ, 0, 0, &u8tmp, 1);\r\n\tif (ret == 0)\r\n\t\tret = airspy_ctrl_msg(s, CMD_VERSION_STRING_READ, 0, 0,\r\n\t\t\t\tbuf, BUF_SIZE);\r\n\tif (ret) {\r\n\t\tdev_err(s->dev, \"Could not detect board\\n\");\r\n\t\tgoto err_free_mem;\r\n\t}\r\n\r\n\tbuf[BUF_SIZE - 1] = '\\0';\r\n\r\n\tdev_info(s->dev, \"Board ID: %02x\\n\", u8tmp);\r\n\tdev_info(s->dev, \"Firmware version: %s\\n\", buf);\r\n\r\n\t/* Init videobuf2 queue structure */\r\n\ts->vb_queue.type = V4L2_BUF_TYPE_SDR_CAPTURE;\r\n\ts->vb_queue.io_modes = VB2_MMAP | VB2_USERPTR | VB2_READ;\r\n\ts->vb_queue.drv_priv = s;\r\n\ts->vb_queue.buf_struct_size = sizeof(struct airspy_frame_buf);\r\n\ts->vb_queue.ops = &airspy_vb2_ops;\r\n\ts->vb_queue.mem_ops = &vb2_vmalloc_memops;\r\n\ts->vb_queue.timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\r\n\ts->vb_queue.lock = &s->vb_queue_lock;\r\n\tret = vb2_queue_init(&s->vb_queue);\r\n\tif (ret) {\r\n\t\tdev_err(s->dev, \"Could not initialize vb2 queue\\n\");\r\n\t\tgoto err_free_mem;\r\n\t}\r\n\r\n\t/* Init video_device structure */\r\n\ts->vdev = airspy_template;\r\n\ts->vdev.queue = &s->vb_queue;\r\n\tvideo_set_drvdata(&s->vdev, s);\r\n\r\n\t/* Register the v4l2_device structure */\r\n\ts->v4l2_dev.release = airspy_video_release;\r\n\tret = v4l2_device_register(&intf->dev, &s->v4l2_dev);\r\n\tif (ret) {\r\n\t\tdev_err(s->dev, \"Failed to register v4l2-device (%d)\\n\", ret);\r\n\t\tgoto err_free_mem;\r\n\t}\r\n\r\n\t/* Register controls */\r\n\tv4l2_ctrl_handler_init(&s->hdl, 5);\r\n\ts->lna_gain_auto = v4l2_ctrl_new_std(&s->hdl, &airspy_ctrl_ops,\r\n\t\t\tV4L2_CID_RF_TUNER_LNA_GAIN_AUTO, 0, 1, 1, 0);\r\n\ts->lna_gain = v4l2_ctrl_new_std(&s->hdl, &airspy_ctrl_ops,\r\n\t\t\tV4L2_CID_RF_TUNER_LNA_GAIN, 0, 14, 1, 8);\r\n\tv4l2_ctrl_auto_cluster(2, &s->lna_gain_auto, 0, false);\r\n\ts->mixer_gain_auto = v4l2_ctrl_new_std(&s->hdl, &airspy_ctrl_ops,\r\n\t\t\tV4L2_CID_RF_TUNER_MIXER_GAIN_AUTO, 0, 1, 1, 0);\r\n\ts->mixer_gain = v4l2_ctrl_new_std(&s->hdl, &airspy_ctrl_ops,\r\n\t\t\tV4L2_CID_RF_TUNER_MIXER_GAIN, 0, 15, 1, 8);\r\n\tv4l2_ctrl_auto_cluster(2, &s->mixer_gain_auto, 0, false);\r\n\ts->if_gain = v4l2_ctrl_new_std(&s->hdl, &airspy_ctrl_ops,\r\n\t\t\tV4L2_CID_RF_TUNER_IF_GAIN, 0, 15, 1, 0);\r\n\tif (s->hdl.error) {\r\n\t\tret = s->hdl.error;\r\n\t\tdev_err(s->dev, \"Could not initialize controls\\n\");\r\n\t\tgoto err_free_controls;\r\n\t}\r\n\r\n\tv4l2_ctrl_handler_setup(&s->hdl);\r\n\r\n\ts->v4l2_dev.ctrl_handler = &s->hdl;\r\n\ts->vdev.v4l2_dev = &s->v4l2_dev;\r\n\ts->vdev.lock = &s->v4l2_lock;\r\n\ts->vdev.device_caps = V4L2_CAP_SDR_CAPTURE | V4L2_CAP_STREAMING |\r\n\t\t\t      V4L2_CAP_READWRITE | V4L2_CAP_TUNER;\r\n\r\n\tret = video_register_device(&s->vdev, VFL_TYPE_SDR, -1);\r\n\tif (ret) {\r\n\t\tdev_err(s->dev, \"Failed to register as video device (%d)\\n\",\r\n\t\t\t\tret);\r\n\t\tgoto err_free_controls;\r\n\t}\r\n\r\n\t/* Free buf if success*/\r\n\tkfree(buf);\r\n\r\n\tdev_info(s->dev, \"Registered as %s\\n\",\r\n\t\t\tvideo_device_node_name(&s->vdev));\r\n\tdev_notice(s->dev, \"SDR API is still slightly experimental and functionality changes may follow\\n\");\r\n\treturn 0;\r\n\r\nerr_free_controls:\r\n\tv4l2_ctrl_handler_free(&s->hdl);\r\n\tv4l2_device_unregister(&s->v4l2_dev);\r\nerr_free_mem:\r\n\tkfree(buf);\r\n\tkfree(s->buf);\r\n\tkfree(s);\r\n\treturn ret;\r\n}", ".irspy_urb_complete": "static void airspy_urb_complete(struct urb *urb)\r\n{\r\n\tstruct airspy *s = urb->context;\r\n\tstruct airspy_frame_buf *fbuf;\r\n\r\n\tdev_dbg_ratelimited(s->dev, \"status=%d length=%d/%d errors=%d\\n\",\r\n\t\t\turb->status, urb->actual_length,\r\n\t\t\turb->transfer_buffer_length, urb->error_count);\r\n\r\n\tswitch (urb->status) {\r\n\tcase 0:             /* success */\r\n\tcase -ETIMEDOUT:    /* NAK */\r\n\t\tbreak;\r\n\tcase -ECONNRESET:   /* kill */\r\n\tcase -ENOENT:\r\n\tcase -ESHUTDOWN:\r\n\t\treturn;\r\n\tdefault:            /* error */\r\n\t\tdev_err_ratelimited(s->dev, \"URB failed %d\\n\", urb->status);\r\n\t\tbreak;\r\n\t}\r\n\r\n\tif (likely(urb->actual_length > 0)) {\r\n\t\tvoid *ptr;\r\n\t\tunsigned int len;\r\n\t\t/* get free framebuffer */\r\n\t\tfbuf = airspy_get_next_fill_buf(s);\r\n\t\tif (unlikely(fbuf == NULL)) {\r\n\t\t\ts->vb_full++;\r\n\t\t\tdev_notice_ratelimited(s->dev,\r\n\t\t\t\t\t\"video buffer is full, %d packets dropped\\n\",\r\n\t\t\t\t\ts->vb_full);\r\n\t\t\tgoto skip;\r\n\t\t}\r\n\r\n\t\t/* fill framebuffer */\r\n\t\tptr = vb2_plane_vaddr(&fbuf->vb.vb2_buf, 0);\r\n\t\tlen = airspy_convert_stream(s, ptr, urb->transfer_buffer,\r\n\t\t\t\turb->actual_length);\r\n\t\tvb2_set_plane_payload(&fbuf->vb.vb2_buf, 0, len);\r\n\t\tfbuf->vb.vb2_buf.timestamp = ktime_get_ns();\r\n\t\tfbuf->vb.sequence = s->sequence++;\r\n\t\tvb2_buffer_done(&fbuf->vb.vb2_buf, VB2_BUF_STATE_DONE);\r\n\t}\r\nskip:\r\n\tusb_submit_urb(urb, GFP_ATOMIC);\r\n}", ".irspy_alloc_urbs": "static int airspy_alloc_urbs(struct airspy *s)\r\n{\r\n\tint i, j;\r\n\r\n\t/* allocate the URBs */\r\n\tfor (i = 0; i < MAX_BULK_BUFS; i++) {\r\n\t\tdev_dbg(s->dev, \"alloc urb=%d\\n\", i);\r\n\t\ts->urb_list[i] = usb_alloc_urb(0, GFP_ATOMIC);\r\n\t\tif (!s->urb_list[i]) {\r\n\t\t\tfor (j = 0; j < i; j++) {\r\n\t\t\t\tusb_free_urb(s->urb_list[j]);\r\n\t\t\t\ts->urb_list[j] = NULL;\r\n\t\t\t}\r\n\t\t\ts->urbs_initialized = 0;\r\n\t\t\treturn -ENOMEM;\r\n\t\t}\r\n\t\tusb_fill_bulk_urb(s->urb_list[i],\r\n\t\t\t\ts->udev,\r\n\t\t\t\tusb_rcvbulkpipe(s->udev, 0x81),\r\n\t\t\t\ts->buf_list[i],\r\n\t\t\t\tBULK_BUFFER_SIZE,\r\n\t\t\t\tairspy_urb_complete, s);\r\n\r\n\t\ts->urb_list[i]->transfer_flags = URB_NO_TRANSFER_DMA_MAP;\r\n\t\ts->urb_list[i]->transfer_dma = s->dma_addr[i];\r\n\t\ts->urbs_initialized++;\r\n\t}\r\n\r\n\treturn 0;\r\n}", ".irspy_submit_urbs": "static int airspy_submit_urbs(struct airspy *s)\r\n{\r\n\tint i, ret;\r\n\r\n\tfor (i = 0; i < s->urbs_initialized; i++) {\r\n\t\tdev_dbg(s->dev, \"submit urb=%d\\n\", i);\r\n\t\tret = usb_submit_urb(s->urb_list[i], GFP_ATOMIC);\r\n\t\tif (ret) {\r\n\t\t\tdev_err(s->dev, \"Could not submit URB no. %d - get them all back\\n\",\r\n\t\t\t\t\ti);\r\n\t\t\tairspy_kill_urbs(s);\r\n\t\t\treturn ret;\r\n\t\t}\r\n\t\ts->urbs_submitted++;\r\n\t}\r\n\r\n\treturn 0;\r\n}", ".irspy_free_urbs": "static int airspy_free_urbs(struct airspy *s)\r\n{\r\n\tint i;\r\n\r\n\tairspy_kill_urbs(s);\r\n\r\n\tfor (i = s->urbs_initialized - 1; i >= 0; i--) {\r\n\t\tif (s->urb_list[i]) {\r\n\t\t\tdev_dbg(s->dev, \"free urb=%d\\n\", i);\r\n\t\t\t/* free the URBs */\r\n\t\t\tusb_free_urb(s->urb_list[i]);\r\n\t\t}\r\n\t}\r\n\ts->urbs_initialized = 0;\r\n\r\n\treturn 0;\r\n}", ".irspy_alloc_stream_bufs": "static int airspy_alloc_stream_bufs(struct airspy *s)\r\n{\r\n\ts->buf_num = 0;\r\n\ts->buf_size = BULK_BUFFER_SIZE;\r\n\r\n\tdev_dbg(s->dev, \"all in all I will use %u bytes for streaming\\n\",\r\n\t\t\tMAX_BULK_BUFS * BULK_BUFFER_SIZE);\r\n\r\n\tfor (s->buf_num = 0; s->buf_num < MAX_BULK_BUFS; s->buf_num++) {\r\n\t\ts->buf_list[s->buf_num] = usb_alloc_coherent(s->udev,\r\n\t\t\t\tBULK_BUFFER_SIZE, GFP_ATOMIC,\r\n\t\t\t\t&s->dma_addr[s->buf_num]);\r\n\t\tif (!s->buf_list[s->buf_num]) {\r\n\t\t\tdev_dbg(s->dev, \"alloc buf=%d failed\\n\", s->buf_num);\r\n\t\t\tairspy_free_stream_bufs(s);\r\n\t\t\treturn -ENOMEM;\r\n\t\t}\r\n\r\n\t\tdev_dbg(s->dev, \"alloc buf=%d %p (dma %llu)\\n\", s->buf_num,\r\n\t\t\t\ts->buf_list[s->buf_num],\r\n\t\t\t\t(long long)s->dma_addr[s->buf_num]);\r\n\t\tset_bit(USB_STATE_URB_BUF, &s->flags);\r\n\t}\r\n\r\n\treturn 0;\r\n}", ".irspy_s_ctrl": "static int airspy_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\n\tstruct airspy *s = container_of(ctrl->handler, struct airspy, hdl);\r\n\tint ret;\r\n\r\n\tswitch (ctrl->id) {\r\n\tcase  V4L2_CID_RF_TUNER_LNA_GAIN_AUTO:\r\n\tcase  V4L2_CID_RF_TUNER_LNA_GAIN:\r\n\t\tret = airspy_set_lna_gain(s);\r\n\t\tbreak;\r\n\tcase  V4L2_CID_RF_TUNER_MIXER_GAIN_AUTO:\r\n\tcase  V4L2_CID_RF_TUNER_MIXER_GAIN:\r\n\t\tret = airspy_set_mixer_gain(s);\r\n\t\tbreak;\r\n\tcase  V4L2_CID_RF_TUNER_IF_GAIN:\r\n\t\tret = airspy_set_if_gain(s);\r\n\t\tbreak;\r\n\tdefault:\r\n\t\tdev_dbg(s->dev, \"unknown ctrl: id=%d name=%s\\n\",\r\n\t\t\t\tctrl->id, ctrl->name);\r\n\t\tret = -EINVAL;\r\n\t}\r\n\r\n\treturn ret;\r\n}"}, "function_name": "airspy_probe"}
{"function_id": null, "caller": {".issect_pktap": "static int\r\ndissect_pktap(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\n\tproto_tree *pktap_tree = NULL;\r\n\tproto_item *ti = NULL;\r\n\ttvbuff_t *next_tvb;\r\n\tint offset = 0;\r\n\tuint32_t pkt_len, rectype, dlt;\r\n\r\n\tcol_set_str(pinfo->cinfo, COL_PROTOCOL, \"PKTAP\");\r\n\tcol_clear(pinfo->cinfo, COL_INFO);\r\n\r\n\tpkt_len = tvb_get_letohl(tvb, offset);\r\n\tcol_add_fstr(pinfo->cinfo, COL_INFO, \"PKTAP, %u byte header\", pkt_len);\r\n\r\n\t/* Dissect the packet */\r\n\tti = proto_tree_add_item(tree, proto_pktap, tvb, offset, pkt_len, ENC_NA);\r\n\tpktap_tree = proto_item_add_subtree(ti, ett_pktap);\r\n\r\n\tproto_tree_add_item(pktap_tree, hf_pktap_hdrlen, tvb, offset, 4,\r\n\t    ENC_LITTLE_ENDIAN);\r\n\tif (pkt_len < MIN_PKTAP_HDR_LEN) {\r\n\t\tproto_tree_add_expert(tree, pinfo, &ei_pktap_hdrlen_too_short,\r\n\t\t    tvb, offset, 4);\r\n\t\treturn tvb_captured_length(tvb);\r\n\t}\r\n\toffset += 4;\r\n\r\n\tproto_tree_add_item(pktap_tree, hf_pktap_rectype, tvb, offset, 4,\r\n\t    ENC_LITTLE_ENDIAN);\r\n\trectype = tvb_get_letohl(tvb, offset);\r\n\toffset += 4;\r\n\tproto_tree_add_item(pktap_tree, hf_pktap_dlt, tvb, offset, 4,\r\n\t    ENC_LITTLE_ENDIAN);\r\n\tdlt = tvb_get_letohl(tvb, offset);\r\n\toffset += 4;\r\n\tproto_tree_add_item(pktap_tree, hf_pktap_ifname, tvb, offset, 24,\r\n\t    ENC_ASCII);\r\n\toffset += 24;\r\n\tproto_tree_add_item(pktap_tree, hf_pktap_flags, tvb, offset, 4,\r\n\t    ENC_LITTLE_ENDIAN);\r\n\toffset += 4;\r\n\tproto_tree_add_item(pktap_tree, hf_pktap_pfamily, tvb, offset, 4,\r\n\t    ENC_LITTLE_ENDIAN);\r\n\toffset += 4;\r\n\tproto_tree_add_item(pktap_tree, hf_pktap_llhdrlen, tvb, offset, 4,\r\n\t    ENC_LITTLE_ENDIAN);\r\n\toffset += 4;\r\n\tproto_tree_add_item(pktap_tree, hf_pktap_lltrlrlen, tvb, offset, 4,\r\n\t    ENC_LITTLE_ENDIAN);\r\n\toffset += 4;\r\n\tproto_tree_add_item(pktap_tree, hf_pktap_pid, tvb, offset, 4,\r\n\t    ENC_LITTLE_ENDIAN);\r\n\toffset += 4;\r\n\tproto_tree_add_item(pktap_tree, hf_pktap_cmdname, tvb, offset, 20,\r\n\t    ENC_UTF_8);\r\n\toffset += 20;\r\n\tproto_tree_add_item(pktap_tree, hf_pktap_svc_class, tvb, offset, 4,\r\n\t    ENC_LITTLE_ENDIAN);\r\n\toffset += 4;\r\n\tproto_tree_add_item(pktap_tree, hf_pktap_iftype, tvb, offset, 2,\r\n\t    ENC_LITTLE_ENDIAN);\r\n\toffset += 2;\r\n\tproto_tree_add_item(pktap_tree, hf_pktap_ifunit, tvb, offset, 2,\r\n\t    ENC_LITTLE_ENDIAN);\r\n\toffset += 2;\r\n\tproto_tree_add_item(pktap_tree, hf_pktap_epid, tvb, offset, 4,\r\n\t    ENC_LITTLE_ENDIAN);\r\n\toffset += 4;\r\n\tproto_tree_add_item(pktap_tree, hf_pktap_ecmdname, tvb, offset, 20,\r\n\t    ENC_UTF_8);\r\n\t/*offset += 20;*/\r\n\r\n\tif (rectype == PKT_REC_PACKET) {\r\n\t\tnext_tvb = tvb_new_subset_remaining(tvb, pkt_len);\r\n\t\tcall_dissector_with_data(pcap_pktdata_handle, next_tvb,\r\n\t\t    pinfo, tree, &dlt);\r\n\t}\r\n\treturn tvb_captured_length(tvb);\r\n}", ".apture_pktap": "static bool\r\ncapture_pktap(const unsigned char *pd, int offset _U_, int len, capture_packet_info_t *cpinfo, const union wtap_pseudo_header *pseudo_header _U_)\r\n{\r\n\tuint32_t hdrlen, rectype, dlt;\r\n\r\n\thdrlen = pletoh32(pd);\r\n\tif (hdrlen < MIN_PKTAP_HDR_LEN || !BYTES_ARE_IN_FRAME(0, len, hdrlen))\r\n\t\treturn false;\r\n\r\n\trectype = pletoh32(pd+4);\r\n\tif (rectype != PKT_REC_PACKET)\r\n\t\treturn false;\r\n\r\n\tdlt = pletoh32(pd+4);\r\n\r\n\t/* XXX - We should probably combine this with capture_info.c:capture_info_packet() */\r\n\tswitch (dlt) {\r\n\r\n\tcase 1: /* DLT_EN10MB */\r\n\t\treturn call_capture_dissector(eth_cap_handle, pd, hdrlen, len, cpinfo, pseudo_header);\r\n\r\n\t}\r\n\r\n\treturn false;\r\n}"}, "callee": {".roto_reg_handoff_pktap": "void\r\nproto_reg_handoff_pktap(void)\r\n{\r\n\tcapture_dissector_handle_t pktap_cap_handle;\r\n\r\n\tdissector_add_uint(\"wtap_encap\", WTAP_ENCAP_PKTAP, pktap_handle);\r\n\r\n\tpcap_pktdata_handle = find_dissector_add_dependency(\"pcap_pktdata\", proto_pktap);\r\n\r\n\t/* XXX - WTAP_ENCAP_USER2 to handle Mavericks' botch wherein it\r\n\t\tuses DLT_USER2 for PKTAP; if you are using DLT_USER2 for your\r\n\t\town purposes, feel free to call your own capture_ routine for\r\n\t\tWTAP_ENCAP_USER2. */\r\n\tpktap_cap_handle = create_capture_dissector_handle(capture_pktap, proto_pktap);\r\n\tcapture_dissector_add_uint(\"wtap_encap\", WTAP_ENCAP_PKTAP, pktap_cap_handle);\r\n\tcapture_dissector_add_uint(\"wtap_encap\", WTAP_ENCAP_USER2, pktap_cap_handle);\r\n\r\n\teth_cap_handle = find_capture_dissector(\"eth\");\r\n}", ".roto_register_pktap": "void\r\nproto_register_pktap(void)\r\n{\r\n\tstatic hf_register_info hf[] = {\r\n\t  { &hf_pktap_hdrlen,\r\n\t    { \"Header length\", \"pktap.hdrlen\",\r\n\t      FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL } },\r\n\t  { &hf_pktap_rectype,\r\n\t    { \"Record type\", \"pktap.rectype\",\r\n\t      FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL } },\r\n\t  { &hf_pktap_dlt,\r\n\t    { \"DLT\", \"pktap.dlt\",\r\n\t      FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL } },\r\n\t  { &hf_pktap_ifname,\t/* fixed length *and* null-terminated */\r\n\t    { \"Interface name\", \"pktap.ifname\",\r\n\t      FT_STRINGZ, BASE_NONE, NULL, 0x0, NULL, HFILL } },\r\n\t  { &hf_pktap_flags,\r\n\t    { \"Flags\", \"pktap.flags\",\r\n\t      FT_UINT32, BASE_HEX, NULL, 0x0, NULL, HFILL } },\r\n\t  { &hf_pktap_pfamily,\r\n\t    { \"Protocol family\", \"pktap.pfamily\",\r\n\t      FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL } },\r\n\t  { &hf_pktap_llhdrlen,\r\n\t    { \"Link-layer header length\", \"pktap.llhdrlen\",\r\n\t      FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL } },\r\n\t  { &hf_pktap_lltrlrlen,\r\n\t    { \"Link-layer trailer length\", \"pktap.lltrlrlen\",\r\n\t      FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL } },\r\n\t  { &hf_pktap_pid,\r\n\t    { \"Process ID\", \"pktap.pid\",\r\n\t      FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL } },\r\n\t  { &hf_pktap_cmdname,\t/* fixed length *and* null-terminated */\r\n\t    { \"Command name\", \"pktap.cmdname\",\r\n\t      FT_STRINGZ, BASE_NONE, NULL, 0x0, NULL, HFILL } },\r\n\t  { &hf_pktap_svc_class,\r\n\t    { \"Service class\", \"pktap.svc_class\",\r\n\t      FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL } },\r\n\t  { &hf_pktap_iftype,\r\n\t    { \"Interface type\", \"pktap.iftype\",\r\n\t      FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL } },\r\n\t  { &hf_pktap_ifunit,\r\n\t    { \"Interface unit\", \"pktap.ifunit\",\r\n\t      FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL } },\r\n\t  { &hf_pktap_epid,\r\n\t    { \"Effective process ID\", \"pktap.epid\",\r\n\t      FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL } },\r\n\t  { &hf_pktap_ecmdname,\t/* fixed length *and* null-terminated */\r\n\t    { \"Effective command name\", \"pktap.ecmdname\",\r\n\t      FT_STRINGZ, BASE_NONE, NULL, 0x0, NULL, HFILL } },\r\n\t};\r\n\r\n\tstatic int *ett[] = {\r\n\t\t&ett_pktap,\r\n\t};\r\n\r\n\tstatic ei_register_info ei[] = {\r\n\t    { &ei_pktap_hdrlen_too_short,\r\n\t      { \"pktap.hdrlen_too_short\", PI_MALFORMED, PI_ERROR,\r\n\t        \"Header length is too short\", EXPFILL }},\r\n\t};\r\n\r\n\texpert_module_t* expert_pktap;\r\n\r\n\tproto_pktap = proto_register_protocol(\"PKTAP packet header\", \"PKTAP\",\r\n\t    \"pktap\");\r\n\tproto_register_field_array(proto_pktap, hf, array_length(hf));\r\n\tproto_register_subtree_array(ett, array_length(ett));\r\n\texpert_pktap = expert_register_protocol(proto_pktap);\r\n\texpert_register_field_array(expert_pktap, ei, array_length(ei));\r\n\r\n\tpktap_handle = register_dissector(\"pktap\", dissect_pktap, proto_pktap);\r\n}"}, "function_name": "proto_reg_handoff_pktap"}
{"function_id": null, "caller": {".arse_wbxml_attribute_list_defined": "static uint32_t\r\nparse_wbxml_attribute_list_defined (proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo,\r\n\t\t\t\t    uint32_t offset, uint32_t str_tbl, uint8_t *codepage_attr,\r\n\t\t\t\t    const wbxml_decoding *map)\r\n{\r\n\tuint32_t     tvb_len = tvb_reported_length (tvb);\r\n\tuint32_t     off     = offset;\r\n\tuint32_t     len;\r\n\tunsigned     str_len;\r\n\tuint32_t     ent;\r\n\tuint32_t     idx;\r\n\tuint8_t      peek;\r\n\tuint8_t      attr_save_known   = 0; /* Will contain peek & 0x3F (attr identity) */\r\n\tconst char  *attr_save_literal = NULL; /* Will contain the LITERAL attr identity */\r\n\tconst char *str;\r\n\tunsigned     recursion_level = p_get_proto_depth(pinfo, proto_wbxml);\r\n\tunsigned     encoding = GPOINTER_TO_UINT(p_get_proto_data(pinfo->pool, pinfo, proto_wbxml, 0));\r\n\r\n\tDebugLog((\"parse_wbxml_attr_defined (level = %u, offset = %u)\\n\", recursion_level, offset));\r\n\t/* Parse attributes */\r\n\twhile (off < tvb_len) {\r\n\t\tpeek = tvb_get_uint8 (tvb, off);\r\n\t\tDebugLog((\"ATTR: (top of while) level = %3u, peek = 0x%02X, \"\r\n\t\t\t  \"off = %u, tvb_len = %u\\n\", recursion_level, peek, off, tvb_len));\r\n\t\tif ((peek & 0x3F) < 5) switch (peek) { /* Global tokens\r\n\t\t\t\t\t\t\t  in state = ATTR */\r\n\t\tcase 0x00: /* SWITCH_PAGE */\r\n\t\t\t*codepage_attr = tvb_get_uint8 (tvb, off+1);\r\n\t\t\tproto_tree_add_uint_format(tree, hf_wbxml_switch_page, tvb, off, 2, *codepage_attr,\r\n                         \"      |  Attr | A -->%3d | SWITCH_PAGE (Attr code page)    |\",\r\n\t\t\t\t\t     *codepage_attr);\r\n\t\t\toff += 2;\r\n\t\t\tbreak;\r\n\t\tcase 0x01: /* END */\r\n\t\t\t/* BEWARE\r\n\t\t\t *   The Attribute END token means either \">\" or \"/>\"\r\n\t\t\t *   and as a consequence both must be treated separately.\r\n\t\t\t *   This is done in the TAG state parser.\r\n\t\t\t */\r\n\t\t\toff++;\r\n\t\t\tDebugLog((\"ATTR: level = %u, Return: len = %u\\n\",\r\n\t\t\t\t  recursion_level, off - offset));\r\n\t\t\treturn (off - offset);\r\n\t\tcase 0x02: /* ENTITY */\r\n\t\t\tent = tvb_get_uintvar (tvb, off+1, &len, pinfo, &ei_wbxml_oversized_uintvar);\r\n\t\t\tif (len <= tvb_len) {\r\n\t\t\t\tproto_tree_add_uint_format(tree, hf_wbxml_entity, tvb, off, 1+len, ent,\r\n\t\t\t\t\t         \"  %3d |  Attr | A %3d    | ENTITY                          |     %s'&#%u;'\",\r\n\t\t\t\t\t         recursion_level, *codepage_attr, Indent (recursion_level), ent);\r\n\t\t\t\toff += 1+len;\r\n\t\t\t} else {\r\n\t\t\t\t/* Stop processing as it is impossible to parse now */\r\n\t\t\t\toff = tvb_len;\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\tcase 0x03: /* STR_I */\r\n\t\t\tstr = tvb_get_stringz_enc(pinfo->pool, tvb, off+1, &len, encoding);\r\n\t\t\tproto_tree_add_string_format(tree, hf_wbxml_str_i, tvb, off, 1+len, str,\r\n\t\t\t\t\t     \"  %3d |  Attr | A %3d    | STR_I (Inline string)           |     %s\\'%s\\'\",\r\n\t\t\t\t\t     recursion_level, *codepage_attr, Indent (recursion_level), str);\r\n\t\t\toff += 1+len;\r\n\t\t\tbreak;\r\n\t\tcase 0x04: /* LITERAL */\r\n\t\t\t/* ALWAYS means the start of a new attribute,\r\n\t\t\t * and may only contain the NAME of the attribute.\r\n\t\t\t */\r\n\t\t\tidx = tvb_get_uintvar (tvb, off+1, &len, pinfo, &ei_wbxml_oversized_uintvar);\r\n\t\t\tif (len <= tvb_len) {\r\n\t\t\t\tattr_save_known = 0;\r\n\t\t\t\tattr_save_literal = tvb_get_stringz_enc(pinfo->pool, tvb, str_tbl+idx, &str_len, encoding);\r\n\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_literal, tvb, off, 1+len, attr_save_literal,\r\n\t\t\t\t\t         \"  %3d |  Attr | A %3d    | LITERAL (Literal Attribute)     |   %s<%s />\",\r\n\t\t\t\t\t         recursion_level, *codepage_attr, Indent (recursion_level), attr_save_literal);\r\n\t\t\t\toff += 1+len;\r\n\t\t\t} else {\r\n\t\t\t\t/* Stop processing as it is impossible to parse now */\r\n\t\t\t\toff = tvb_len;\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\tcase 0x40: /* EXT_I_0 */\r\n\t\tcase 0x41: /* EXT_I_1 */\r\n\t\tcase 0x42: /* EXT_I_2 */\r\n\t\t\t/* Extension tokens */\r\n\t\t\tstr = tvb_get_stringz_enc(pinfo->pool, tvb, off+1, &len, encoding);\r\n\t\t\tproto_tree_add_string_format(tree, hf_wbxml_ext_i, tvb, off, 1+len, str,\r\n\t\t\t\t\t     \"  %3d |  Attr | A %3d    | EXT_I_%1x    (Extension Token)    |     %s(%s: \\'%s\\')\",\r\n\t\t\t\t\t     recursion_level, *codepage_attr, peek & 0x0f, Indent (recursion_level),\r\n\t\t\t\t\t     ((map != NULL) ? map_token (map->global, 0, peek) : \"Inline string extension\"), str);\r\n\t\t\toff += 1+len;\r\n\t\t\tbreak;\r\n\t\t\t/* 0x43 impossible in ATTR state */\r\n\t\t\t/* 0x44 impossible in ATTR state */\r\n\t\tcase 0x80: /* EXT_T_0 */\r\n\t\tcase 0x81: /* EXT_T_1 */\r\n\t\tcase 0x82: /* EXT_T_2 */\r\n\t\t\t/* Extension tokens */\r\n\t\t\tidx = tvb_get_uintvar (tvb, off+1, &len, pinfo, &ei_wbxml_oversized_uintvar);\r\n\t\t\t{\r\n\t\t\t\tchar *s;\r\n\t\t\t\tif (map != NULL) {\r\n\r\n\t\t\t\t\tif (map->ext_t[peek & 0x03])\r\n\t\t\t\t\t\ts = (map->ext_t[peek & 0x03])(pinfo->pool, tvb, idx, str_tbl);\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\ts = wmem_strdup_printf(pinfo->pool, \"EXT_T_%1x (%s)\", peek & 0x03,\r\n\t\t\t\t\t\t\t\t    map_token (map->global, 0, peek));\r\n\t\t\t\t} else {\r\n\t\t\t\t\ts = wmem_strdup_printf(pinfo->pool, \"Extension Token, integer value: (%u\", idx);\r\n\t\t\t\t}\r\n\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_ext_t, tvb, off, 1+len, s,\r\n\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    | EXT_T_%1x    (Extension Token)    | %s%s)\",\r\n\t\t\t\t\t\t     recursion_level, *codepage_attr, peek & 0x0f, Indent (recursion_level),\r\n\t\t\t\t\t\t     s);\r\n\t\t\t}\r\n\t\t\tif (len <= tvb_len) {\r\n\t\t\t\toff += 1+len;\r\n\t\t\t} else {\r\n\t\t\t\t/* Stop processing as it is impossible to parse now */\r\n\t\t\t\toff = tvb_len;\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\tcase 0x83: /* STR_T */\r\n\t\t\tidx = tvb_get_uintvar (tvb, off+1, &len, pinfo, &ei_wbxml_oversized_uintvar);\r\n\t\t\tif (len <= tvb_len) {\r\n\t\t\t\tstr = tvb_get_stringz_enc(pinfo->pool, tvb, str_tbl+idx, &str_len, encoding);\r\n\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_str_t, tvb, off, 1+len, str,\r\n\t\t\t\t\t         \"  %3d |  Attr | A %3d    | STR_T (Tableref string)         |     %s\\'%s\\'\",\r\n\t\t\t\t\t         recursion_level, *codepage_attr, Indent (recursion_level), str);\r\n\t\t\t\toff += 1+len;\r\n\t\t\t} else {\r\n\t\t\t\t/* Stop processing as it is impossible to parse now */\r\n\t\t\t\toff = tvb_len;\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\t\t/* 0x84 impossible in ATTR state */\r\n\t\tcase 0xC0: /* EXT_0 */\r\n\t\tcase 0xC1: /* EXT_1 */\r\n\t\tcase 0xC2: /* EXT_2 */\r\n\t\t\t/* Extension tokens */\r\n\t\t\tstr = (map != NULL) ? map_token (map->global, 0, peek) : \"Single-byte extension\";\r\n\t\t\tproto_tree_add_string_format(tree, hf_wbxml_extension_token, tvb, off, 1, str,\r\n\t\t\t\t\t     \"  %3d |  Attr | A %3d    | EXT_%1x      (Extension Token)    |     %s(%s)\",\r\n\t\t\t\t\t     recursion_level, *codepage_attr, peek & 0x0f, Indent (recursion_level), str);\r\n\t\t\toff++;\r\n\t\t\tbreak;\r\n\t\tcase 0xC3: /* OPAQUE - WBXML 1.1 and newer */\r\n\t\t\tif (tvb_get_uint8 (tvb, 0)) { /* WBXML 1.x (x > 0) */\r\n\t\t\t\tif (map != NULL) {\r\n\t\t\t\t\tchar *tmp_str;\r\n\t\t\t\t\tif (attr_save_known) { /* Knwon attribute */\r\n\t\t\t\t\t\tif (map->opaque_binary_attr) {\r\n\t\t\t\t\t\t\ttmp_str = map->opaque_binary_attr(tvb, off + 1,\r\n\t\t\t\t\t\t\t\t\t      attr_save_known, *codepage_attr, &len, pinfo);\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\ttmp_str = default_opaque_binary_attr(tvb, off + 1,\r\n\t\t\t\t\t\t\t\t\t\t attr_save_known, *codepage_attr, &len, pinfo);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else { /* lITERAL attribute */\r\n\t\t\t\t\t\tif (map->opaque_literal_tag) {\r\n\t\t\t\t\t\t\ttmp_str = map->opaque_literal_attr(tvb, off + 1,\r\n\t\t\t\t\t\t\t\t\t       attr_save_literal, *codepage_attr, &len, pinfo);\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\ttmp_str = default_opaque_literal_attr(tvb, off + 1,\r\n\t\t\t\t\t\t\t\t\t\t  attr_save_literal, *codepage_attr, &len, pinfo);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (len <= tvb_len) {\r\n\t\t\t\t\t\tproto_tree_add_bytes_format(tree, hf_wbxml_opaque_data, tvb, off, 1 + len, NULL,\r\n\t\t\t\t\t\t\t         \"  %3d |  Attr | A %3d    | OPAQUE (Opaque data)            |       %s%s\",\r\n\t\t\t\t\t\t\t         recursion_level, *codepage_attr, Indent (recursion_level), tmp_str);\r\n\t\t\t\t\t\toff += 1 + len;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t/* Stop processing as it is impossible to parse now */\r\n\t\t\t\t\t\toff = tvb_len;\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tidx = tvb_get_uintvar (tvb, off+1, &len, pinfo, &ei_wbxml_oversized_uintvar);\r\n\t\t\t\t\tif ((len <= tvb_len) && (idx < tvb_len)) {\r\n\t\t\t\t\t\tproto_tree_add_bytes_format(tree, hf_wbxml_opaque_data, tvb, off, 1 + len + idx, NULL,\r\n\t\t\t\t\t\t\t     \"  %3d |  Attr | A %3d    | OPAQUE (Opaque data)            |       %s(%u bytes of opaque data)\",\r\n\t\t\t\t\t\t\t     recursion_level, *codepage_attr, Indent (recursion_level), idx);\r\n\t\t\t\t\t\toff += 1+len+idx;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t/* Stop processing as it is impossible to parse now */\r\n\t\t\t\t\t\toff = tvb_len;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} else { /* WBXML 1.0 - RESERVED_2 token (invalid) */\r\n\t\t\t\tproto_tree_add_none_format(tree, hf_wbxml_reserved_2, tvb, off, 1,\r\n\t\t\t\t\t\t\t     \"  %3d |  Attr | A %3d    | RESERVED_2     (Invalid Token!) | WBXML 1.0 parsing stops here.\",\r\n\t\t\t\t\t\t\t     recursion_level, *codepage_attr);\r\n\t\t\t\t/* Stop processing as it is impossible to parse now */\r\n\t\t\t\toff = tvb_len;\r\n\t\t\t\tDebugLog((\"ATTR: level = %u, Return: len = %u\\n\",\r\n\t\t\t\t\t  recursion_level, off - offset));\r\n\t\t\t\treturn (off - offset);\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\t\t/* 0xC4 impossible in ATTR state */\r\n\t\tdefault:\r\n\t\t\tproto_tree_add_none_format(tree, hf_wbxml_invalid_token, tvb, off, 1,\r\n\t\t\t\t\t     \"  %3d |  Attr | A %3d    | %-10s     (Invalid Token!) | WBXML parsing stops here.\",\r\n\t\t\t\t\t     recursion_level, *codepage_attr, val_to_str_ext(pinfo->pool, peek, &vals_wbxml1x_global_tokens_ext, \"(unknown 0x%x)\"));\r\n\t\t\t/* Move to end of buffer */\r\n\t\t\toff = tvb_len;\r\n\t\t\tbreak;\r\n\t\t} else { /* Known attribute token */\r\n\t\t\tconst char* s;\r\n\t\t\tif (peek & 0x80) { /* attrValue */\r\n\t\t\t\tif (map != NULL) {\r\n\t\t\t\t\ts = map_token (map->attrValue, *codepage_attr, peek);\r\n\t\t\t\t} else {\r\n\t\t\t\t\ts = wmem_strdup_printf(pinfo->pool, \"attrValue_0x%02X\", peek);\r\n\t\t\t\t}\r\n\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_known_attrvalue, tvb, off, 1, s,\r\n\t\t\t\t\t\t     \"  %3d |  Attr | A %3d    |   Known attrValue 0x%02X          |       %s%s\",\r\n\t\t\t\t\t\t     recursion_level, *codepage_attr, peek & 0x7f, Indent (recursion_level),\r\n\t\t\t\t\t\t     s);\r\n\t\t\t\toff++;\r\n\t\t\t} else { /* attrStart */\r\n\t\t\t\tattr_save_known = peek & 0x7f;\r\n\t\t\t\tif (map != NULL) {\r\n\t\t\t\t\ts = map_token (map->attrStart, *codepage_attr, peek);\r\n\t\t\t\t} else {\r\n\t\t\t\t\ts = wmem_strdup_printf(pinfo->pool, \"attrStart_0x%02X\", peek);\r\n\t\t\t\t}\r\n\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_known_attrstart, tvb, off, 1, s,\r\n\t\t\t\t\t\t     \"  %3d |  Attr | A %3d    |   Known attrStart 0x%02X          |   %s%s\",\r\n\t\t\t\t\t\t     recursion_level, *codepage_attr, attr_save_known, Indent (recursion_level),\r\n\t\t\t\t\t\t     s);\r\n\t\t\t\toff++;\r\n\t\t\t}\r\n\t\t}\r\n\t} /* End WHILE */\r\n\tDebugLog((\"ATTR: level = %u, Return: len = %u (end of function body)\\n\",\r\n\t\t  recursion_level, off - offset));\r\n\treturn (off - offset);\r\n}", ".how_wbxml_string_table": "static void\r\nshow_wbxml_string_table (proto_tree *tree, packet_info* pinfo, tvbuff_t *tvb, uint32_t str_tbl,\r\n\t\t\t uint32_t str_tbl_len, unsigned charset)\r\n{\r\n\tunsigned encoding = mibenum_charset_to_encoding(charset);\r\n\tuint32_t off = str_tbl;\r\n\tuint32_t end = str_tbl + str_tbl_len;\r\n\tproto_tree *item_tree;\r\n\tproto_item *ti;\r\n\tconst uint8_t *str;\r\n\tint len;\r\n\r\n\twhile (off < end) {\r\n\t\t/*\r\n\t\t * XXX - use the string encoding.\r\n\t\t */\r\n\t\titem_tree = proto_tree_add_subtree_format (tree, tvb, off, 0,\r\n\t\t\t\t\t\t\t   ett_wbxml_string_table_item,\r\n\t\t\t\t\t\t\t   &ti,\r\n\t\t\t\t\t\t\t   \"%u:\",\r\n\t\t\t\t\t\t\t   off - str_tbl);\r\n\t\tproto_tree_add_uint (item_tree,\r\n\t\t    hf_wbxml_string_table_item_offset,\r\n\t\t    tvb, 0, 0, off - str_tbl);\r\n\t\tproto_tree_add_item_ret_string_and_length (item_tree,\r\n\t\t    hf_wbxml_string_table_item_string,\r\n\t\t    tvb, off, -1, encoding, pinfo->pool, &str, &len);\r\n\t\tproto_item_append_text(ti, \" '%s'\", format_text(pinfo->pool, str, strlen(str)));\r\n\t\tproto_item_set_len(ti, len);\r\n\t\toff += len;\r\n\t}\r\n}", ".arse_wbxml_tag_defined": "static uint32_t\r\n// NOLINTNEXTLINE(misc-no-recursion)\r\nparse_wbxml_tag_defined (proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo, uint32_t offset,\r\n\t\t\t uint32_t str_tbl, uint8_t *codepage_stag, uint8_t *codepage_attr,\r\n\t\t\t const wbxml_decoding *map)\r\n{\r\n\tuint32_t     tvb_len  = tvb_reported_length (tvb);\r\n\tuint32_t     off      = offset;\r\n\tuint32_t     len;\r\n\tunsigned     str_len;\r\n\tuint32_t     ent;\r\n\tuint32_t     idx;\r\n\tuint8_t      peek;\r\n\tuint32_t     tag_len;                     /* Length of the index (uintvar) from a LITERAL tag */\r\n\tuint8_t      tag_save_known      = 0;     /* Will contain peek & 0x3F (tag identity) */\r\n\tuint8_t      tag_new_known       = 0;     /* Will contain peek & 0x3F (tag identity) */\r\n\tconst char  *tag_save_literal    = NULL;  /* Will contain the LITERAL tag identity */\r\n\tconst char  *tag_new_literal;             /* Will contain the LITERAL tag identity */\r\n\tconst char *str;\r\n\tuint8_t      parsing_tag_content = false; /* Are we parsing content from a\r\n\t\t\t\t\t\t     tag with content: <x>Content</x>\r\n\r\n\t\t\t\t\t\t     The initial state is false.\r\n\t\t\t\t\t\t     This state will trigger recursion. */\r\n\r\n\tunsigned     recursion_level = p_get_proto_depth(pinfo, proto_wbxml);\r\n\tunsigned     encoding = GPOINTER_TO_UINT(p_get_proto_data(pinfo->pool, pinfo, proto_wbxml, 0));\r\n\tif (recursion_level >= WBXML_MAX_RECURSION_LEVEL) {\r\n\t\tproto_tree_add_expert(tree, pinfo, &ei_wbxml_too_much_recursion, tvb, offset, tvb_captured_length_remaining(tvb, offset));\r\n\t\treturn tvb_len;\r\n\t}\r\n\tDebugLog((\"parse_wbxml_tag_defined (level = %u, offset = %u)\\n\", recursion_level, offset));\r\n\twhile (off < tvb_len) {\r\n\t\tpeek = tvb_get_uint8 (tvb, off);\r\n\t\tDebugLog((\"STAG: (top of while) level = %3u, peek = 0x%02X, off = %u, tvb_len = %u\\n\", recursion_level, peek, off, tvb_len));\r\n\t\tif ((peek & 0x3F) < 4) switch (peek) { /* Global tokens in state = STAG\r\n\t\t\t\t\t\t\t  but not the LITERAL tokens */\r\n\t\tcase 0x00: /* SWITCH_PAGE */\r\n\t\t\t*codepage_stag = tvb_get_uint8 (tvb, off+1);\r\n\t\t\tproto_tree_add_uint_format(tree, hf_wbxml_switch_page, tvb, off, 2, *codepage_stag,\r\n\t\t\t\t\t     \"      | Tag   | T -->%3d | SWITCH_PAGE (Tag code page)     |\",\r\n\t\t\t\t\t     *codepage_stag);\r\n\t\t\toff += 2;\r\n\t\t\tbreak;\r\n\t\tcase 0x01: /* END: only possible for Tag with Content */\r\n\t\t\tif (tag_save_known) { /* Known TAG */\r\n\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_end_known_tag, tvb, off, 1, tag_save_literal,\r\n\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    | END (Known Tag 0x%02X)            | %s</%s>\",\r\n\t\t\t\t\t\t     recursion_level, *codepage_stag,\r\n\t\t\t\t\t\t     tag_save_known, Indent (recursion_level),\r\n\t\t\t\t\t\t     tag_save_literal); /* We already looked it up! */\r\n\t\t\t} else { /* Literal TAG */\r\n\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_end_literal_tag, tvb, off, 1, tag_save_literal ? tag_save_literal : \"\",\r\n\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    | END (Literal Tag)               | %s</%s>\",\r\n\t\t\t\t\t\t     recursion_level, *codepage_stag, Indent (recursion_level), tag_save_literal ? tag_save_literal : \"\");\r\n\t\t\t}\r\n\t\t\trecursion_level--;\r\n\t\t\tp_set_proto_depth(pinfo, proto_wbxml, recursion_level);\r\n\t\t\toff++;\r\n\t\t\t/* Reset code page: not needed as return from recursion */\r\n\t\t\tDebugLog((\"STAG: level = %u, Return: len = %u\\n\", recursion_level, off - offset));\r\n\t\t\treturn (off - offset);\r\n\t\tcase 0x02: /* ENTITY */\r\n\t\t\tent = tvb_get_uintvar (tvb, off+1, &len, pinfo, &ei_wbxml_oversized_uintvar);\r\n\t\t\tproto_tree_add_uint_format(tree, hf_wbxml_entity, tvb, off, 1+len, ent,\r\n\t\t\t\t\t     \"  %3d | Tag   | T %3d    | ENTITY                          | %s'&#%u;'\",\r\n\t\t\t\t\t     recursion_level, *codepage_stag, Indent (recursion_level), ent);\r\n\t\t\toff += 1+len;\r\n\t\t\tbreak;\r\n\t\tcase 0x03: /* STR_I */\r\n\t\t\tstr = tvb_get_stringz_enc(pinfo->pool, tvb, off+1, &len, encoding);\r\n\t\t\tproto_tree_add_string_format(tree, hf_wbxml_str_i, tvb, off, 1+len, str,\r\n\t\t\t\t\t     \"  %3d | Tag   | T %3d    | STR_I (Inline string)           | %s\\'%s\\'\",\r\n\t\t\t\t\t     recursion_level, *codepage_stag, Indent(recursion_level),\r\n\t\t\t\t\t     str);\r\n\t\t\toff += 1+len;\r\n\t\t\tbreak;\r\n\t\tcase 0x40: /* EXT_I_0 */\r\n\t\tcase 0x41: /* EXT_I_1 */\r\n\t\tcase 0x42: /* EXT_I_2 */\r\n\t\t\t/* Extension tokens */\r\n\t\t\tstr = tvb_get_stringz_enc(pinfo->pool, tvb, off+1, &len, encoding);\r\n\t\t\tproto_tree_add_string_format(tree, hf_wbxml_ext_i, tvb, off, 1+len, str,\r\n\t\t\t\t\t     \"  %3d | Tag   | T %3d    | EXT_I_%1x    (Extension Token)    | %s(%s: \\'%s\\')\",\r\n\t\t\t\t\t     recursion_level, *codepage_stag,\r\n\t\t\t\t\t     peek & 0x0f, Indent (recursion_level),\r\n\t\t\t\t\t     ((map != NULL) ? map_token (map->global, 0, peek) : \"Inline string extension\"),\r\n\t\t\t\t\t     str);\r\n\t\t\toff += 1+len;\r\n\t\t\tbreak;\r\n\t\tcase 0x43: /* PI */\r\n\t\t\tproto_tree_add_none_format(tree, hf_wbxml_pi_xml, tvb, off, 1,\r\n\t\t\t\t\t     \"  %3d | Tag   | T %3d    | PI (XML Processing Instruction) | %s<?xml\",\r\n\t\t\t\t\t     recursion_level, *codepage_stag, Indent (recursion_level));\r\n\t\t\tlen = parse_wbxml_attribute_list_defined (tree, tvb, pinfo, off,\r\n\t\t\t\t\t\t\t\t  str_tbl, codepage_attr, map);\r\n\t\t\t/* Check that there is still room in packet */\r\n\t\t\toff += len;\r\n\t\t\tif (off >= tvb_len) {\r\n\t\t\t\tDebugLog((\"STAG: level = %u, ThrowException: len = %u (short frame)\\n\",\r\n\t\t\t\t\t\t\trecursion_level, off - offset));\r\n\t\t\t}\r\n\r\n\t\t\tproto_tree_add_none_format(tree, hf_wbxml_end_pi, tvb, off-1, 1,\r\n\t\t\t\t\t     \"  %3d | Tag   | T %3d    | END (PI)                        | %s?>\",\r\n\t\t\t\t\t     recursion_level, *codepage_stag, Indent (recursion_level));\r\n\t\t\tbreak;\r\n\t\tcase 0x80: /* EXT_T_0 */\r\n\t\tcase 0x81: /* EXT_T_1 */\r\n\t\tcase 0x82: /* EXT_T_2 */\r\n\t\t\t/* Extension tokens */\r\n\t\t\tidx = tvb_get_uintvar (tvb, off+1, &len, pinfo, &ei_wbxml_oversized_uintvar);\r\n\t\t\t{\r\n\t\t\t\tchar *s;\r\n\t\t\t\tif (map)\r\n\t\t\t\t{\r\n\t\t\t\t\tif (map->ext_t[peek & 0x03])\r\n\t\t\t\t\t\ts = (map->ext_t[peek & 0x03])(pinfo->pool, tvb, idx, str_tbl);\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\ts = wmem_strdup_printf(pinfo->pool, \"EXT_T_%1x (%s)\", peek & 0x03,\r\n\t\t\t\t\t\t\t        map_token (map->global, 0, peek));\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\ts = wmem_strdup_printf(pinfo->pool, \"(Extension Token, integer value: %u)\", idx);\r\n\t\t\t\t}\r\n\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_ext_t, tvb, off, 1+len, s,\r\n\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    | EXT_T_%1x    (Extension Token)    | %s%s\",\r\n\t\t\t\t\t\t     recursion_level, *codepage_stag, peek & 0x0f, Indent (recursion_level), s);\r\n\t\t\t}\r\n\t\t\toff += 1+len;\r\n\t\t\tbreak;\r\n\t\tcase 0x83: /* STR_T */\r\n\t\t\tidx = tvb_get_uintvar (tvb, off+1, &len, pinfo, &ei_wbxml_oversized_uintvar);\r\n\t\t\tstr = tvb_get_stringz_enc(pinfo->pool, tvb, str_tbl+idx, &str_len, encoding);\r\n\t\t\tproto_tree_add_string_format(tree, hf_wbxml_str_t, tvb, off, 1+len, str,\r\n\t\t\t\t\t     \"  %3d | Tag   | T %3d    | STR_T (Tableref string)         | %s\\'%s\\'\",\r\n\t\t\t\t\t     recursion_level, *codepage_stag, Indent (recursion_level), str);\r\n\t\t\toff += 1+len;\r\n\t\t\tbreak;\r\n\t\tcase 0xC0: /* EXT_0 */\r\n\t\tcase 0xC1: /* EXT_1 */\r\n\t\tcase 0xC2: /* EXT_2 */\r\n\t\t\t/* Extension tokens */\r\n\t\t\tstr = (map != NULL) ? map_token (map->global, 0, peek) : \"Single-byte extension\";\r\n\t\t\tproto_tree_add_string_format(tree, hf_wbxml_extension_token, tvb, off, 1, str,\r\n\t\t\t\t\t     \"  %3d | Tag   | T %3d    | EXT_%1x      (Extension Token)    | %s(%s)\",\r\n\t\t\t\t\t     recursion_level, *codepage_stag, peek & 0x0f, Indent (recursion_level), str);\r\n\t\t\toff++;\r\n\t\t\tbreak;\r\n\t\tcase 0xC3: /* OPAQUE - WBXML 1.1 and newer */\r\n\t\t\tif (tvb_get_uint8 (tvb, 0)) { /* WBXML 1.x (x > 0) */\r\n\t\t\t\tif (map != NULL)\r\n\t\t\t\t{\r\n\t\t\t\t\tchar *tmp_str;\r\n\t\t\t\t\tif (tag_save_known) { /* Known tag */\r\n\t\t\t\t\t\tif (map->opaque_binary_tag) {\r\n\t\t\t\t\t\t\ttmp_str = map->opaque_binary_tag(tvb, off + 1,\r\n\t\t\t\t\t\t\t\t\t\t     tag_save_known, *codepage_stag, &len, pinfo);\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\ttmp_str = default_opaque_binary_tag(tvb, off + 1,\r\n\t\t\t\t\t\t\t\t\t\t\ttag_save_known, *codepage_stag, &len, pinfo);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else { /* lITERAL tag */\r\n\t\t\t\t\t\tif (map->opaque_literal_tag) {\r\n\t\t\t\t\t\t\ttmp_str = map->opaque_literal_tag(tvb, off + 1,\r\n\t\t\t\t\t\t\t\t\t\t      tag_save_literal, *codepage_stag, &len, pinfo);\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\ttmp_str = default_opaque_literal_tag(tvb, off + 1,\r\n\t\t\t\t\t\t\t\t\t\t\t tag_save_literal, *codepage_stag, &len, pinfo);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tproto_tree_add_bytes_format(tree, hf_wbxml_opaque_data, tvb, off, 1 + len, NULL,\r\n\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    | OPAQUE (Opaque data)            | %s%s\",\r\n\t\t\t\t\t\t     recursion_level, *codepage_stag, Indent (recursion_level), tmp_str);\r\n\t\t\t\t\toff += 1 + len;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tidx = tvb_get_uintvar (tvb, off+1, &len, pinfo, &ei_wbxml_oversized_uintvar);\r\n\t\t\t\t\tif ((len <= tvb_len) && (idx < tvb_len))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tproto_tree_add_bytes_format(tree, hf_wbxml_opaque_data, tvb, off, 1 + len + idx, NULL,\r\n\t\t\t\t\t\t         \"  %3d | Tag   | T %3d    | OPAQUE (Opaque data)            | %s(%u bytes of opaque data)\",\r\n\t\t\t\t\t\t         recursion_level, *codepage_stag, Indent (recursion_level), idx);\r\n\t\t\t\t\t\toff += 1+len+idx;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t/* Stop processing as it is impossible to parse now */\r\n\t\t\t\t\t\toff = tvb_len;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} else { /* WBXML 1.0 - RESERVED_2 token (invalid) */\r\n\t\t\t\tproto_tree_add_none_format(tree, hf_wbxml_reserved_2, tvb, off, 1,\r\n\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    | RESERVED_2     (Invalid Token!) | WBXML 1.0 parsing stops here.\",\r\n\t\t\t\t\t\t     recursion_level, *codepage_stag);\r\n\t\t\t\t/* Stop processing as it is impossible to parse now */\r\n\t\t\t\toff = tvb_len;\r\n\t\t\t\tDebugLog((\"STAG: level = %u, Return: len = %u\\n\", recursion_level, off - offset));\r\n\t\t\t\treturn (off - offset);\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\r\n\t\t\t/* No default clause, as all cases have been treated */\r\n\t\t} else { /* LITERAL or Known TAG */\r\n\t\t\t/* We must store the initial tag, and also retrieve the new tag.\r\n\t\t\t * For efficiency reasons, we store the literal tag representation\r\n\t\t\t * for known tags too, so we can easily close the tag without the\r\n\t\t\t * need of a new lookup and avoiding storage of token codepage.\r\n\t\t\t *\r\n\t\t\t * There are 4 possibilities:\r\n\t\t\t *\r\n\t\t\t *  1. Known tag followed by a known tag\r\n\t\t\t *  2. Known tag followed by a LITERAL tag\r\n\t\t\t *  3. LITERAL tag followed by Known tag\r\n\t\t\t *  4. LITERAL tag followed by LITERAL tag\r\n\t\t\t */\r\n\r\n\t\t\t/* Store the new tag */\r\n\t\t\ttag_len = 0;\r\n\t\t\tif ((peek & 0x3F) == 4) { /* LITERAL */\r\n\t\t\t\tDebugLog((\"STAG: LITERAL tag (peek = 0x%02X, off = %u) - TableRef follows!\\n\", peek, off));\r\n\t\t\t\tidx = tvb_get_uintvar (tvb, off+1, &tag_len, pinfo, &ei_wbxml_oversized_uintvar);\r\n\t\t\t\ttag_new_literal = tvb_get_stringz_enc(pinfo->pool, tvb, str_tbl+idx, &str_len, encoding);\r\n\t\t\t\ttag_new_known = 0; /* invalidate known tag_new */\r\n\t\t\t} else { /* Known tag */\r\n\t\t\t\ttag_new_known = peek & 0x3F;\r\n\t\t\t\tif (map != NULL) {\r\n\t\t\t\t\ttag_new_literal = map_token (map->tags, *codepage_stag,\r\n\t\t\t\t\t\t\t     tag_new_known);\r\n\t\t\t\t} else {\r\n\t\t\t\t\ttag_new_literal = wmem_strdup_printf(pinfo->pool, \"Tag_0x%02X\",\r\n\t\t\t\t\t\t\ttag_new_known);\r\n\t\t\t\t}\r\n\t\t\t\t/* Stored looked up tag name string */\r\n\t\t\t}\r\n\r\n\t\t\t/* Parsing of TAG starts HERE */\r\n\t\t\tif (peek & 0x40) { /* Content present */\r\n\t\t\t\t/* Content follows\r\n\t\t\t\t * [!] An explicit END token is expected in these cases!\r\n\t\t\t\t * ==> Recursion possible if we encounter a tag with content;\r\n\t\t\t\t *     recursion will return at the explicit END token.\r\n\t\t\t\t */\r\n\t\t\t\tif (parsing_tag_content) { /* Recurse */\r\n\t\t\t\t\tDebugLog((\"STAG: Tag in Tag - RECURSE! (off = %u)\\n\", off));\r\n\t\t\t\t\t/* Do not process the attribute list:\r\n\t\t\t\t\t * recursion will take care of it */\r\n\t\t\t\t\tp_set_proto_depth(pinfo, proto_wbxml, recursion_level + 1);\r\n\t\t\t\t\tlen = parse_wbxml_tag_defined (tree, tvb, pinfo, off, str_tbl,\r\n\t\t\t\t\t\t\t\t       codepage_stag, codepage_attr, map);\r\n\t\t\t\t\toff += len;\r\n\t\t\t\t} else { /* Now we will have content to parse */\r\n\t\t\t\t\t/* Save the start tag so we can properly close it later. */\r\n\t\t\t\t\tif ((peek & 0x3F) == 4) { /* Literal tag */\r\n\t\t\t\t\t\ttag_save_literal = tag_new_literal;\r\n\t\t\t\t\t\ttag_save_known = 0;\r\n\t\t\t\t\t} else { /* Known tag */\r\n\t\t\t\t\t\ttag_save_known = tag_new_known;\r\n\t\t\t\t\t\ttag_save_literal = tag_new_literal;\r\n\t\t\t\t\t\t/* The last statement avoids needless lookups */\r\n\t\t\t\t\t}\r\n\t\t\t\t\t/* Process the attribute list if present */\r\n\t\t\t\t\tif (peek & 0x80) { /* Content and Attribute list present */\r\n\t\t\t\t\t\tif (tag_new_known) { /* Known tag */\r\n\t\t\t\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_known_tag, tvb, off, 1, tag_new_literal,\r\n\t\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    |   Known Tag 0x%02X           (AC) | %s<%s\",\r\n\t\t\t\t\t\t\t\t\t     recursion_level, *codepage_stag, tag_new_known,\r\n\t\t\t\t\t\t\t\t\t     Indent (recursion_level), tag_new_literal);\r\n\t\t\t\t\t\t\t/* Tag string already looked up earlier! */\r\n\t\t\t\t\t\t\toff++;\r\n\t\t\t\t\t\t} else { /* LITERAL tag */\r\n\t\t\t\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_literal_ac, tvb, off, 1, tag_new_literal,\r\n\t\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    | LITERAL_AC (Literal tag)   (AC) | %s<%s\",\r\n\t\t\t\t\t\t\t\t\t     recursion_level, *codepage_stag, Indent (recursion_level), tag_new_literal);\r\n\t\t\t\t\t\t\toff += 1 + tag_len;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tlen = parse_wbxml_attribute_list_defined (tree, tvb, pinfo,\r\n\t\t\t\t\t\t\t\t\t\t\t  off, str_tbl, codepage_attr, map);\r\n\t\t\t\t\t\t/* Check that there is still room in packet */\r\n\t\t\t\t\t\toff += len;\r\n\t\t\t\t\t\tif (off >= tvb_len) {\r\n\t\t\t\t\t\t\tDebugLog((\"STAG: level = %u, ThrowException: len = %u (short frame)\\n\",\r\n\t\t\t\t\t\t\t\t  recursion_level, off - offset));\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tproto_tree_add_none_format(tree, hf_wbxml_end_attribute_list, tvb, off-1, 1,\r\n\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    | END (attribute list)            | %s>\",\r\n\t\t\t\t\t\t\t\t     recursion_level, *codepage_stag, Indent (recursion_level));\r\n\t\t\t\t\t} else { /* Content, no Attribute list */\r\n\t\t\t\t\t\tif (tag_new_known) { /* Known tag */\r\n\t\t\t\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_known_tag, tvb, off, 1, tag_new_literal,\r\n\t\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    |   Known Tag 0x%02X           (.C) | %s<%s>\",\r\n\t\t\t\t\t\t\t\t\t     recursion_level, *codepage_stag, tag_new_known,\r\n\t\t\t\t\t\t\t\t\t     Indent (recursion_level), tag_new_literal);\r\n\t\t\t\t\t\t\t/* Tag string already looked up earlier! */\r\n\t\t\t\t\t\t\toff++;\r\n\t\t\t\t\t\t} else { /* LITERAL tag */\r\n\t\t\t\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_literal_c, tvb, off, 1, tag_new_literal,\r\n\t\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    | LITERAL_C  (Literal Tag)   (.C) | %s<%s>\",\r\n\t\t\t\t\t\t\t\t\t     recursion_level, *codepage_stag, Indent (recursion_level), tag_new_literal);\r\n\t\t\t\t\t\t\toff += 1 + tag_len;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\t/* The data that follows in the parsing process\r\n\t\t\t\t\t * represents content for the opening tag\r\n\t\t\t\t\t * we've just processed in the lines above.\r\n\t\t\t\t\t * Next time we encounter a tag with content: recurse\r\n\t\t\t\t\t */\r\n\t\t\t\t\tparsing_tag_content = true;\r\n\t\t\t\t\tDebugLog((\"Tag in Tag - No recursion this time! (off = %u)\\n\", off));\r\n\t\t\t\t}\r\n\t\t\t} else { /* No Content */\r\n\t\t\t\tDebugLog((\"<Tag/> in Tag - No recursion! (off = %u)\\n\", off));\r\n\t\t\t\trecursion_level++;\r\n\t\t\t\tp_set_proto_depth(pinfo, proto_wbxml, recursion_level);\r\n\t\t\t\tif (peek & 0x80) { /* No Content, Attribute list present */\r\n\t\t\t\t\tif (tag_new_known) { /* Known tag */\r\n\t\t\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_known_tag, tvb, off, 1, tag_new_literal,\r\n\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    |   Known Tag 0x%02X           (A.) | %s<%s\",\r\n\t\t\t\t\t\t\t\t     recursion_level, *codepage_stag, tag_new_known,\r\n\t\t\t\t\t\t\t\t     Indent (recursion_level), tag_new_literal);\r\n\t\t\t\t\t\t/* Tag string already looked up earlier! */\r\n\t\t\t\t\t\toff++;\r\n\t\t\t\t\t\tlen = parse_wbxml_attribute_list_defined (tree, tvb, pinfo,\r\n\t\t\t\t\t\t\t\t\t\t\t  off, str_tbl, codepage_attr, map);\r\n\t\t\t\t\t\t/* Check that there is still room in packet */\r\n\t\t\t\t\t\toff += len;\r\n\t\t\t\t\t\tif (off > tvb_len) {\r\n\t\t\t\t\t\t\tDebugLog((\"STAG: level = %u, ThrowException: len = %u (short frame)\\n\",\r\n\t\t\t\t\t\t\t\t\t\trecursion_level, off - offset));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tproto_tree_add_uint_format(tree, hf_wbxml_end_known_tag_uint, tvb, off-1, 1, *codepage_stag,\r\n\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    | END (Known Tag)                 | %s/>\",\r\n\t\t\t\t\t\t\t\t     recursion_level, *codepage_stag, Indent (recursion_level));\r\n\t\t\t\t\t} else { /* LITERAL tag */\r\n\t\t\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_literal_a, tvb, off, 1, tag_new_literal,\r\n\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    | LITERAL_A  (Literal Tag)   (A.) | %s<%s\",\r\n\t\t\t\t\t\t\t\t     recursion_level, *codepage_stag, Indent (recursion_level), tag_new_literal);\r\n\t\t\t\t\t\toff += 1 + tag_len;\r\n\t\t\t\t\t\tlen = parse_wbxml_attribute_list_defined (tree, tvb, pinfo,\r\n\t\t\t\t\t\t\t\t\t\t\t  off, str_tbl, codepage_attr, map);\r\n\t\t\t\t\t\t/* Check that there is still room in packet */\r\n\t\t\t\t\t\toff += len;\r\n\t\t\t\t\t\tif (off >= tvb_len) {\r\n\t\t\t\t\t\t\tDebugLog((\"STAG: level = %u, ThrowException: len = %u (short frame)\\n\",\r\n\t\t\t\t\t\t\t\t\t\trecursion_level, off - offset));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_end_literal_tag, tvb, off-1, 1, \"\",\r\n\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    | END (Literal Tag)               | %s/>\",\r\n\t\t\t\t\t\t\t\t     recursion_level, *codepage_stag, Indent (recursion_level));\r\n\t\t\t\t\t}\r\n\t\t\t\t} else { /* No Content, No Attribute list */\r\n\t\t\t\t\tif (tag_new_known) { /* Known tag */\r\n\t\t\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_known_tag, tvb, off, 1, tag_new_literal,\r\n\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    |   Known Tag 0x%02x           (..) | %s<%s />\",\r\n\t\t\t\t\t\t\t\t     recursion_level, *codepage_stag, tag_new_known,\r\n\t\t\t\t\t\t\t\t     Indent (recursion_level), tag_new_literal);\r\n\t\t\t\t\t\t/* Tag string already looked up earlier! */\r\n\t\t\t\t\t\toff++;\r\n\t\t\t\t\t} else { /* LITERAL tag */\r\n\t\t\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_literal, tvb, off, 1, tag_new_literal,\r\n\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    | LITERAL    (Literal Tag)   (..) | %s<%s />\",\r\n\t\t\t\t\t\t\t\t     recursion_level, *codepage_stag, Indent (recursion_level),\r\n\t\t\t\t\t\t\t\t     tag_new_literal);\r\n\t\t\t\t\t\toff += 1 + tag_len;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\trecursion_level--;\r\n\t\t\t\tp_set_proto_depth(pinfo, proto_wbxml, recursion_level);\r\n\t\t\t\t/* TODO: Do I have to reset code page here? */\r\n\t\t\t}\r\n\t\t} /* if (tag & 0x3F) >= 5 */\r\n\t} /* while */\r\n\tDebugLog((\"STAG: level = %u, Return: len = %u (end of function body)\\n\", recursion_level, off - offset));\r\n\treturn (off - offset);\r\n}", ".issect_wbxml_common": "static void\r\ndissect_wbxml_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\r\n\t\t     const wbxml_decoding *override_content_map)\r\n{\r\n\t/* Set up structures needed to add the protocol subtree and manage it */\r\n\tproto_item           *ti;\r\n\tproto_tree           *wbxml_tree;          /* Main WBXML tree */\r\n\tproto_tree           *wbxml_str_tbl_tree;  /* String table subtree */\r\n\tproto_tree           *wbxml_content_tree;  /* Content subtree */\r\n\tproto_tree           *tag_tree;\r\n\tuint8_t               version;\r\n\tunsigned              offset          = 0;\r\n\tuint32_t              len;\r\n\tuint32_t              charset         = 0;\r\n\tuint32_t              charset_len     = 0;\r\n\tunsigned              encoding;\r\n\tuint32_t              publicid;\r\n\tuint32_t              publicid_index  = 0;\r\n\tuint32_t              publicid_len;\r\n\tuint32_t              str_tbl;\r\n\tuint32_t              str_tbl_len;\r\n\tuint32_t              str_tbl_len_len = 0;\r\n\tconst wbxml_decoding *content_map     = NULL;\r\n\tchar                 *summary         = NULL;\r\n\tuint8_t               codepage_stag   = 0;\r\n\tuint8_t               codepage_attr   = 0;\r\n\r\n\tDebugLog((\"dissect_wbxml: Dissecting packet %u\\n\", pinfo->num));\r\n\t/* WBXML format\r\n\t *\r\n\t * Version 1.0: version publicid         strtbl BODY\r\n\t * Version 1.x: version publicid charset strtbl BODY\r\n\t *\r\n\t * Last valid format: WBXML 1.3\r\n\t */\r\n\tswitch ( version = tvb_get_uint8 (tvb, 0) ) {\r\n\tcase 0x00: /* WBXML/1.0 */\r\n\t\tbreak;\r\n\r\n\tcase 0x01: /* WBXML/1.1 */\r\n\tcase 0x02: /* WBXML/1.2 */\r\n\tcase 0x03: /* WBXML/1.3 */\r\n\t\tbreak;\r\n\r\n\tdefault:\r\n\t\t/* Put some information here, so that the user knows what's going on. */\r\n\r\n\t\t/* Add summary to INFO column if it is enabled */\r\n\t\tcol_append_fstr(pinfo->cinfo, COL_INFO, \" (Unknown WBXML version 0x%02x)\", version);\r\n\t\tti = proto_tree_add_item (tree, proto_wbxml, tvb, 0, -1, ENC_NA);\r\n\t\tproto_item_append_text(ti, \", Unknown version 0x%02x\", version);\r\n\t\treturn;\r\n\t}\r\n\r\n\t/* In order to properly construct the packet summary,\r\n\t * I need to read the entire WBXML header\r\n\t * up to the string table length.\r\n\t */\r\n\r\n\t/* Public ID */\r\n\tpublicid = tvb_get_uintvar(tvb, 1, &publicid_len, pinfo, &ei_wbxml_oversized_uintvar);\r\n\tif (! publicid) {\r\n\t\t/* Public identifier in string table */\r\n\t\tpublicid_index = tvb_get_uintvar (tvb, 1+publicid_len, &len, pinfo, &ei_wbxml_oversized_uintvar);\r\n\t\tpublicid_len += len;\r\n\t}\r\n\toffset = 1 + publicid_len;\r\n\r\n\t/* Version-specific handling of Charset */\r\n\tswitch ( version ) {\r\n\tcase 0x00: /* WBXML/1.0 */\r\n\t\t/* No charset */\r\n\t\tbreak;\r\n\r\n\tcase 0x01: /* WBXML/1.1 */\r\n\tcase 0x02: /* WBXML/1.2 */\r\n\tcase 0x03: /* WBXML/1.3 */\r\n\t\t/* Get charset */\r\n\t\tcharset = tvb_get_uintvar (tvb, offset, &charset_len, pinfo, &ei_wbxml_oversized_uintvar);\r\n\t\toffset += charset_len;\r\n\t\tbreak;\r\n\r\n\tdefault: /* Impossible since we returned already earlier */\r\n\t\tDISSECTOR_ASSERT_NOT_REACHED();\r\n\t\tbreak;\r\n\t}\r\n\r\n\tif (charset) {\r\n\t\tencoding = mibenum_charset_to_encoding(charset);\r\n\t} else {\r\n\t\t/* XXX: If the charset is 0 we should look if there is a charset\r\n\t\t * parameter in the Content-Type / media_type if passed to\r\n\t\t * the dissector. Otherwise the default is UTF-8.\r\n\t\t */\r\n\t\tencoding = ENC_UTF_8;\r\n\t}\r\n\tp_add_proto_data(pinfo->pool, pinfo, proto_wbxml, 0, GUINT_TO_POINTER(encoding));\r\n\r\n\t/* String table: read string table length in bytes */\r\n\ttvb_get_uintvar (tvb, offset, &str_tbl_len_len, pinfo, &ei_wbxml_oversized_uintvar);\r\n\tstr_tbl = offset + str_tbl_len_len; /* Start of 1st string in string table */\r\n\r\n\t/* Compose the summary line */\r\n\tif ( publicid ) {\r\n\t\tsummary = wmem_strdup_printf(pinfo->pool, \"%s, Public ID: \\\"%s\\\"\",\r\n\t\t\t\t\t  val_to_str_ext(pinfo->pool, version, &vals_wbxml_versions_ext, \"(unknown 0x%x)\"),\r\n\t\t\t\t\t  val_to_str_ext(pinfo->pool, publicid, &vals_wbxml_public_ids_ext, \"(unknown 0x%x)\"));\r\n\t} else {\r\n\t\t/* Read length of Public ID from string table */\r\n\t\tsummary = wmem_strdup_printf(pinfo->pool, \"%s, Public ID: \\\"%s\\\"\",\r\n\t\t\t\t\t  val_to_str_ext(pinfo->pool, version, &vals_wbxml_versions_ext, \"(unknown 0x%x)\"),\r\n\t\t\t\t\t  tvb_get_stringz_enc(pinfo->pool, tvb, str_tbl + publicid_index, &len, encoding));\r\n\t}\r\n\r\n\t/* Add summary to INFO column if it is enabled */\r\n\tcol_append_fstr(pinfo->cinfo, COL_INFO, \" (WBXML %s)\", summary);\r\n\r\n\t/* create display subtree for the protocol */\r\n\tti = proto_tree_add_item (tree, proto_wbxml, tvb, 0, -1, ENC_NA);\r\n\tproto_item_append_text(ti, \", Version: %s\", summary);\r\n\r\n\t/*\r\n\t * Now show the protocol subtree, if tree is set.\r\n\t */\r\n\twbxml_tree = proto_item_add_subtree(ti, ett_wbxml);\r\n\r\n\t/* WBXML Version */\r\n\tproto_tree_add_uint (wbxml_tree, hf_wbxml_version,\r\n\t\t\t\t    tvb, 0, 1, version);\r\n\r\n\t/* Public ID */\r\n\tif (publicid) { /* Known Public ID */\r\n\t\tproto_tree_add_uint(wbxml_tree, hf_wbxml_public_id_known,\r\n\t\t\t\t\ttvb, 1, publicid_len, publicid);\r\n\t} else { /* Public identifier in string table */\r\n\t\tproto_tree_add_item (wbxml_tree, hf_wbxml_public_id_literal,\r\n\t\t\t\t\t    tvb, 1, publicid_len, ENC_ASCII);\r\n\t}\r\n\toffset = 1 + publicid_len;\r\n\r\n\tif ( charset ) { /* Charset */\r\n\t\tproto_tree_add_uint (wbxml_tree, hf_wbxml_charset,\r\n\t\t\t\t\t    tvb, 1 + publicid_len, charset_len, charset);\r\n\t\toffset += charset_len;\r\n\t}\r\n\r\n\tstr_tbl_len = tvb_get_uintvar (tvb, offset, &len, pinfo, &ei_wbxml_oversized_uintvar);\r\n\tstr_tbl = offset + len; /* Start of 1st string in string table */\r\n\r\n\t/* String Table */\r\n\twbxml_str_tbl_tree = proto_tree_add_subtree_format(wbxml_tree,\r\n\t\t\t\t\ttvb, offset, len + str_tbl_len, ett_wbxml_str_tbl, NULL, \"String table: %u bytes\",\r\n\t\t\t\t\tstr_tbl_len);\r\n\r\n\tif (str_tbl_len) { /* Display string table as subtree */\r\n\t\tshow_wbxml_string_table (wbxml_str_tbl_tree, pinfo, tvb,\r\n\t\t\t\t\t\tstr_tbl, str_tbl_len,\r\n\t\t\t\t\t\tcharset);\r\n\t}\r\n\r\n\t/* Data starts HERE */\r\n\toffset += len + str_tbl_len;\r\n\r\n\twbxml_content_tree = proto_tree_add_subtree(wbxml_tree, tvb, offset, -1,\r\n\t\t\t\t\tett_wbxml_content, &ti, \"Data representation\");\r\n\t/* The WBXML BODY starts here */\r\n\tif (disable_wbxml_token_parsing) {\r\n\t\texpert_add_info(pinfo, ti, &ei_wbxml_data_not_shown);\r\n\t\treturn;\r\n\t}\r\n\r\n\t/* The parse_wbxml_X() functions will process the content correctly,\r\n\t\t* irrespective of the WBXML version used. For the WBXML body, this\r\n\t\t* means that there is a different processing for the global token\r\n\t\t* RESERVED_2 (WBXML 1.0) or OPAQUE (WBXML 1.x with x > 0).  */\r\n\tif (override_content_map != NULL) {\r\n\t\tcontent_map = override_content_map;\r\n\t\tproto_item_append_text(ti,\r\n\t\t\t\t\t\t\" is based on: %s\",\r\n\t\t\t\t\t\tcontent_map->name);\r\n\t} else {\r\n\t\t/* Retrieve the content token mapping if available */\r\n\t\tcontent_map = get_wbxml_decoding_from_public_id (publicid);\r\n\t\tif (! content_map) {\r\n\t\t\tcontent_map = get_wbxml_decoding_from_content_type(\r\n\t\t\t\t\t\t\t\t\t\tpinfo->match_string, tvb, offset);\r\n\t\t\tif (! content_map) {\r\n\t\t\t\texpert_add_info(pinfo, ti, &ei_wbxml_content_type_not_supported);\r\n\t\t\t} else {\r\n\t\t\t\tproto_item_append_text(ti,\r\n\t\t\t\t\t\t\t\t\" is based on Content-Type: %s \"\r\n\t\t\t\t\t\t\t\t\"(chosen decoding: %s)\",\r\n\t\t\t\t\t\t\t\tpinfo->match_string, content_map->name);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tif (content_map && skip_wbxml_token_mapping) {\r\n\t\texpert_add_info(pinfo, ti, &ei_wbxml_content_type_disabled);\r\n\t\tcontent_map = NULL;\r\n\t}\r\n\ttag_tree = proto_tree_add_subtree(wbxml_content_tree, tvb, offset, -1, ett_wbxml_tags, NULL,\r\n\t\t\t\t\t\"Level | State | Codepage | WBXML Token Description         | Rendering\");\r\n\r\n\t/* If content_map == NULL, WBXML only, no interpretation of the content */\r\n\tparse_wbxml_tag_defined (tag_tree,\r\n\t\t\t\t\t\t\ttvb, pinfo, offset, str_tbl, &codepage_stag,\r\n\t\t\t\t\t\t\t&codepage_attr, content_map);\r\n}", ".issect_wbxml": "static int\r\ndissect_wbxml(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\n\tdissect_wbxml_common(tvb, pinfo, tree, NULL);\r\n\treturn tvb_captured_length(tvb);\r\n}", ".issect_uaprof": "static int\r\ndissect_uaprof(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\n\tdissect_wbxml_common(tvb, pinfo, tree, &decode_uaprof_wap_248);\r\n\treturn tvb_captured_length(tvb);\r\n}"}, "callee": {".issect_wbxml_common": "static void\r\ndissect_wbxml_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\r\n\t\t     const wbxml_decoding *override_content_map)\r\n{\r\n\t/* Set up structures needed to add the protocol subtree and manage it */\r\n\tproto_item           *ti;\r\n\tproto_tree           *wbxml_tree;          /* Main WBXML tree */\r\n\tproto_tree           *wbxml_str_tbl_tree;  /* String table subtree */\r\n\tproto_tree           *wbxml_content_tree;  /* Content subtree */\r\n\tproto_tree           *tag_tree;\r\n\tuint8_t               version;\r\n\tunsigned              offset          = 0;\r\n\tuint32_t              len;\r\n\tuint32_t              charset         = 0;\r\n\tuint32_t              charset_len     = 0;\r\n\tunsigned              encoding;\r\n\tuint32_t              publicid;\r\n\tuint32_t              publicid_index  = 0;\r\n\tuint32_t              publicid_len;\r\n\tuint32_t              str_tbl;\r\n\tuint32_t              str_tbl_len;\r\n\tuint32_t              str_tbl_len_len = 0;\r\n\tconst wbxml_decoding *content_map     = NULL;\r\n\tchar                 *summary         = NULL;\r\n\tuint8_t               codepage_stag   = 0;\r\n\tuint8_t               codepage_attr   = 0;\r\n\r\n\tDebugLog((\"dissect_wbxml: Dissecting packet %u\\n\", pinfo->num));\r\n\t/* WBXML format\r\n\t *\r\n\t * Version 1.0: version publicid         strtbl BODY\r\n\t * Version 1.x: version publicid charset strtbl BODY\r\n\t *\r\n\t * Last valid format: WBXML 1.3\r\n\t */\r\n\tswitch ( version = tvb_get_uint8 (tvb, 0) ) {\r\n\tcase 0x00: /* WBXML/1.0 */\r\n\t\tbreak;\r\n\r\n\tcase 0x01: /* WBXML/1.1 */\r\n\tcase 0x02: /* WBXML/1.2 */\r\n\tcase 0x03: /* WBXML/1.3 */\r\n\t\tbreak;\r\n\r\n\tdefault:\r\n\t\t/* Put some information here, so that the user knows what's going on. */\r\n\r\n\t\t/* Add summary to INFO column if it is enabled */\r\n\t\tcol_append_fstr(pinfo->cinfo, COL_INFO, \" (Unknown WBXML version 0x%02x)\", version);\r\n\t\tti = proto_tree_add_item (tree, proto_wbxml, tvb, 0, -1, ENC_NA);\r\n\t\tproto_item_append_text(ti, \", Unknown version 0x%02x\", version);\r\n\t\treturn;\r\n\t}\r\n\r\n\t/* In order to properly construct the packet summary,\r\n\t * I need to read the entire WBXML header\r\n\t * up to the string table length.\r\n\t */\r\n\r\n\t/* Public ID */\r\n\tpublicid = tvb_get_uintvar(tvb, 1, &publicid_len, pinfo, &ei_wbxml_oversized_uintvar);\r\n\tif (! publicid) {\r\n\t\t/* Public identifier in string table */\r\n\t\tpublicid_index = tvb_get_uintvar (tvb, 1+publicid_len, &len, pinfo, &ei_wbxml_oversized_uintvar);\r\n\t\tpublicid_len += len;\r\n\t}\r\n\toffset = 1 + publicid_len;\r\n\r\n\t/* Version-specific handling of Charset */\r\n\tswitch ( version ) {\r\n\tcase 0x00: /* WBXML/1.0 */\r\n\t\t/* No charset */\r\n\t\tbreak;\r\n\r\n\tcase 0x01: /* WBXML/1.1 */\r\n\tcase 0x02: /* WBXML/1.2 */\r\n\tcase 0x03: /* WBXML/1.3 */\r\n\t\t/* Get charset */\r\n\t\tcharset = tvb_get_uintvar (tvb, offset, &charset_len, pinfo, &ei_wbxml_oversized_uintvar);\r\n\t\toffset += charset_len;\r\n\t\tbreak;\r\n\r\n\tdefault: /* Impossible since we returned already earlier */\r\n\t\tDISSECTOR_ASSERT_NOT_REACHED();\r\n\t\tbreak;\r\n\t}\r\n\r\n\tif (charset) {\r\n\t\tencoding = mibenum_charset_to_encoding(charset);\r\n\t} else {\r\n\t\t/* XXX: If the charset is 0 we should look if there is a charset\r\n\t\t * parameter in the Content-Type / media_type if passed to\r\n\t\t * the dissector. Otherwise the default is UTF-8.\r\n\t\t */\r\n\t\tencoding = ENC_UTF_8;\r\n\t}\r\n\tp_add_proto_data(pinfo->pool, pinfo, proto_wbxml, 0, GUINT_TO_POINTER(encoding));\r\n\r\n\t/* String table: read string table length in bytes */\r\n\ttvb_get_uintvar (tvb, offset, &str_tbl_len_len, pinfo, &ei_wbxml_oversized_uintvar);\r\n\tstr_tbl = offset + str_tbl_len_len; /* Start of 1st string in string table */\r\n\r\n\t/* Compose the summary line */\r\n\tif ( publicid ) {\r\n\t\tsummary = wmem_strdup_printf(pinfo->pool, \"%s, Public ID: \\\"%s\\\"\",\r\n\t\t\t\t\t  val_to_str_ext(pinfo->pool, version, &vals_wbxml_versions_ext, \"(unknown 0x%x)\"),\r\n\t\t\t\t\t  val_to_str_ext(pinfo->pool, publicid, &vals_wbxml_public_ids_ext, \"(unknown 0x%x)\"));\r\n\t} else {\r\n\t\t/* Read length of Public ID from string table */\r\n\t\tsummary = wmem_strdup_printf(pinfo->pool, \"%s, Public ID: \\\"%s\\\"\",\r\n\t\t\t\t\t  val_to_str_ext(pinfo->pool, version, &vals_wbxml_versions_ext, \"(unknown 0x%x)\"),\r\n\t\t\t\t\t  tvb_get_stringz_enc(pinfo->pool, tvb, str_tbl + publicid_index, &len, encoding));\r\n\t}\r\n\r\n\t/* Add summary to INFO column if it is enabled */\r\n\tcol_append_fstr(pinfo->cinfo, COL_INFO, \" (WBXML %s)\", summary);\r\n\r\n\t/* create display subtree for the protocol */\r\n\tti = proto_tree_add_item (tree, proto_wbxml, tvb, 0, -1, ENC_NA);\r\n\tproto_item_append_text(ti, \", Version: %s\", summary);\r\n\r\n\t/*\r\n\t * Now show the protocol subtree, if tree is set.\r\n\t */\r\n\twbxml_tree = proto_item_add_subtree(ti, ett_wbxml);\r\n\r\n\t/* WBXML Version */\r\n\tproto_tree_add_uint (wbxml_tree, hf_wbxml_version,\r\n\t\t\t\t    tvb, 0, 1, version);\r\n\r\n\t/* Public ID */\r\n\tif (publicid) { /* Known Public ID */\r\n\t\tproto_tree_add_uint(wbxml_tree, hf_wbxml_public_id_known,\r\n\t\t\t\t\ttvb, 1, publicid_len, publicid);\r\n\t} else { /* Public identifier in string table */\r\n\t\tproto_tree_add_item (wbxml_tree, hf_wbxml_public_id_literal,\r\n\t\t\t\t\t    tvb, 1, publicid_len, ENC_ASCII);\r\n\t}\r\n\toffset = 1 + publicid_len;\r\n\r\n\tif ( charset ) { /* Charset */\r\n\t\tproto_tree_add_uint (wbxml_tree, hf_wbxml_charset,\r\n\t\t\t\t\t    tvb, 1 + publicid_len, charset_len, charset);\r\n\t\toffset += charset_len;\r\n\t}\r\n\r\n\tstr_tbl_len = tvb_get_uintvar (tvb, offset, &len, pinfo, &ei_wbxml_oversized_uintvar);\r\n\tstr_tbl = offset + len; /* Start of 1st string in string table */\r\n\r\n\t/* String Table */\r\n\twbxml_str_tbl_tree = proto_tree_add_subtree_format(wbxml_tree,\r\n\t\t\t\t\ttvb, offset, len + str_tbl_len, ett_wbxml_str_tbl, NULL, \"String table: %u bytes\",\r\n\t\t\t\t\tstr_tbl_len);\r\n\r\n\tif (str_tbl_len) { /* Display string table as subtree */\r\n\t\tshow_wbxml_string_table (wbxml_str_tbl_tree, pinfo, tvb,\r\n\t\t\t\t\t\tstr_tbl, str_tbl_len,\r\n\t\t\t\t\t\tcharset);\r\n\t}\r\n\r\n\t/* Data starts HERE */\r\n\toffset += len + str_tbl_len;\r\n\r\n\twbxml_content_tree = proto_tree_add_subtree(wbxml_tree, tvb, offset, -1,\r\n\t\t\t\t\tett_wbxml_content, &ti, \"Data representation\");\r\n\t/* The WBXML BODY starts here */\r\n\tif (disable_wbxml_token_parsing) {\r\n\t\texpert_add_info(pinfo, ti, &ei_wbxml_data_not_shown);\r\n\t\treturn;\r\n\t}\r\n\r\n\t/* The parse_wbxml_X() functions will process the content correctly,\r\n\t\t* irrespective of the WBXML version used. For the WBXML body, this\r\n\t\t* means that there is a different processing for the global token\r\n\t\t* RESERVED_2 (WBXML 1.0) or OPAQUE (WBXML 1.x with x > 0).  */\r\n\tif (override_content_map != NULL) {\r\n\t\tcontent_map = override_content_map;\r\n\t\tproto_item_append_text(ti,\r\n\t\t\t\t\t\t\" is based on: %s\",\r\n\t\t\t\t\t\tcontent_map->name);\r\n\t} else {\r\n\t\t/* Retrieve the content token mapping if available */\r\n\t\tcontent_map = get_wbxml_decoding_from_public_id (publicid);\r\n\t\tif (! content_map) {\r\n\t\t\tcontent_map = get_wbxml_decoding_from_content_type(\r\n\t\t\t\t\t\t\t\t\t\tpinfo->match_string, tvb, offset);\r\n\t\t\tif (! content_map) {\r\n\t\t\t\texpert_add_info(pinfo, ti, &ei_wbxml_content_type_not_supported);\r\n\t\t\t} else {\r\n\t\t\t\tproto_item_append_text(ti,\r\n\t\t\t\t\t\t\t\t\" is based on Content-Type: %s \"\r\n\t\t\t\t\t\t\t\t\"(chosen decoding: %s)\",\r\n\t\t\t\t\t\t\t\tpinfo->match_string, content_map->name);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tif (content_map && skip_wbxml_token_mapping) {\r\n\t\texpert_add_info(pinfo, ti, &ei_wbxml_content_type_disabled);\r\n\t\tcontent_map = NULL;\r\n\t}\r\n\ttag_tree = proto_tree_add_subtree(wbxml_content_tree, tvb, offset, -1, ett_wbxml_tags, NULL,\r\n\t\t\t\t\t\"Level | State | Codepage | WBXML Token Description         | Rendering\");\r\n\r\n\t/* If content_map == NULL, WBXML only, no interpretation of the content */\r\n\tparse_wbxml_tag_defined (tag_tree,\r\n\t\t\t\t\t\t\ttvb, pinfo, offset, str_tbl, &codepage_stag,\r\n\t\t\t\t\t\t\t&codepage_attr, content_map);\r\n}", ".arse_wbxml_tag_defined": "static uint32_t\r\n// NOLINTNEXTLINE(misc-no-recursion)\r\nparse_wbxml_tag_defined (proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo, uint32_t offset,\r\n\t\t\t uint32_t str_tbl, uint8_t *codepage_stag, uint8_t *codepage_attr,\r\n\t\t\t const wbxml_decoding *map)\r\n{\r\n\tuint32_t     tvb_len  = tvb_reported_length (tvb);\r\n\tuint32_t     off      = offset;\r\n\tuint32_t     len;\r\n\tunsigned     str_len;\r\n\tuint32_t     ent;\r\n\tuint32_t     idx;\r\n\tuint8_t      peek;\r\n\tuint32_t     tag_len;                     /* Length of the index (uintvar) from a LITERAL tag */\r\n\tuint8_t      tag_save_known      = 0;     /* Will contain peek & 0x3F (tag identity) */\r\n\tuint8_t      tag_new_known       = 0;     /* Will contain peek & 0x3F (tag identity) */\r\n\tconst char  *tag_save_literal    = NULL;  /* Will contain the LITERAL tag identity */\r\n\tconst char  *tag_new_literal;             /* Will contain the LITERAL tag identity */\r\n\tconst char *str;\r\n\tuint8_t      parsing_tag_content = false; /* Are we parsing content from a\r\n\t\t\t\t\t\t     tag with content: <x>Content</x>\r\n\r\n\t\t\t\t\t\t     The initial state is false.\r\n\t\t\t\t\t\t     This state will trigger recursion. */\r\n\r\n\tunsigned     recursion_level = p_get_proto_depth(pinfo, proto_wbxml);\r\n\tunsigned     encoding = GPOINTER_TO_UINT(p_get_proto_data(pinfo->pool, pinfo, proto_wbxml, 0));\r\n\tif (recursion_level >= WBXML_MAX_RECURSION_LEVEL) {\r\n\t\tproto_tree_add_expert(tree, pinfo, &ei_wbxml_too_much_recursion, tvb, offset, tvb_captured_length_remaining(tvb, offset));\r\n\t\treturn tvb_len;\r\n\t}\r\n\tDebugLog((\"parse_wbxml_tag_defined (level = %u, offset = %u)\\n\", recursion_level, offset));\r\n\twhile (off < tvb_len) {\r\n\t\tpeek = tvb_get_uint8 (tvb, off);\r\n\t\tDebugLog((\"STAG: (top of while) level = %3u, peek = 0x%02X, off = %u, tvb_len = %u\\n\", recursion_level, peek, off, tvb_len));\r\n\t\tif ((peek & 0x3F) < 4) switch (peek) { /* Global tokens in state = STAG\r\n\t\t\t\t\t\t\t  but not the LITERAL tokens */\r\n\t\tcase 0x00: /* SWITCH_PAGE */\r\n\t\t\t*codepage_stag = tvb_get_uint8 (tvb, off+1);\r\n\t\t\tproto_tree_add_uint_format(tree, hf_wbxml_switch_page, tvb, off, 2, *codepage_stag,\r\n\t\t\t\t\t     \"      | Tag   | T -->%3d | SWITCH_PAGE (Tag code page)     |\",\r\n\t\t\t\t\t     *codepage_stag);\r\n\t\t\toff += 2;\r\n\t\t\tbreak;\r\n\t\tcase 0x01: /* END: only possible for Tag with Content */\r\n\t\t\tif (tag_save_known) { /* Known TAG */\r\n\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_end_known_tag, tvb, off, 1, tag_save_literal,\r\n\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    | END (Known Tag 0x%02X)            | %s</%s>\",\r\n\t\t\t\t\t\t     recursion_level, *codepage_stag,\r\n\t\t\t\t\t\t     tag_save_known, Indent (recursion_level),\r\n\t\t\t\t\t\t     tag_save_literal); /* We already looked it up! */\r\n\t\t\t} else { /* Literal TAG */\r\n\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_end_literal_tag, tvb, off, 1, tag_save_literal ? tag_save_literal : \"\",\r\n\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    | END (Literal Tag)               | %s</%s>\",\r\n\t\t\t\t\t\t     recursion_level, *codepage_stag, Indent (recursion_level), tag_save_literal ? tag_save_literal : \"\");\r\n\t\t\t}\r\n\t\t\trecursion_level--;\r\n\t\t\tp_set_proto_depth(pinfo, proto_wbxml, recursion_level);\r\n\t\t\toff++;\r\n\t\t\t/* Reset code page: not needed as return from recursion */\r\n\t\t\tDebugLog((\"STAG: level = %u, Return: len = %u\\n\", recursion_level, off - offset));\r\n\t\t\treturn (off - offset);\r\n\t\tcase 0x02: /* ENTITY */\r\n\t\t\tent = tvb_get_uintvar (tvb, off+1, &len, pinfo, &ei_wbxml_oversized_uintvar);\r\n\t\t\tproto_tree_add_uint_format(tree, hf_wbxml_entity, tvb, off, 1+len, ent,\r\n\t\t\t\t\t     \"  %3d | Tag   | T %3d    | ENTITY                          | %s'&#%u;'\",\r\n\t\t\t\t\t     recursion_level, *codepage_stag, Indent (recursion_level), ent);\r\n\t\t\toff += 1+len;\r\n\t\t\tbreak;\r\n\t\tcase 0x03: /* STR_I */\r\n\t\t\tstr = tvb_get_stringz_enc(pinfo->pool, tvb, off+1, &len, encoding);\r\n\t\t\tproto_tree_add_string_format(tree, hf_wbxml_str_i, tvb, off, 1+len, str,\r\n\t\t\t\t\t     \"  %3d | Tag   | T %3d    | STR_I (Inline string)           | %s\\'%s\\'\",\r\n\t\t\t\t\t     recursion_level, *codepage_stag, Indent(recursion_level),\r\n\t\t\t\t\t     str);\r\n\t\t\toff += 1+len;\r\n\t\t\tbreak;\r\n\t\tcase 0x40: /* EXT_I_0 */\r\n\t\tcase 0x41: /* EXT_I_1 */\r\n\t\tcase 0x42: /* EXT_I_2 */\r\n\t\t\t/* Extension tokens */\r\n\t\t\tstr = tvb_get_stringz_enc(pinfo->pool, tvb, off+1, &len, encoding);\r\n\t\t\tproto_tree_add_string_format(tree, hf_wbxml_ext_i, tvb, off, 1+len, str,\r\n\t\t\t\t\t     \"  %3d | Tag   | T %3d    | EXT_I_%1x    (Extension Token)    | %s(%s: \\'%s\\')\",\r\n\t\t\t\t\t     recursion_level, *codepage_stag,\r\n\t\t\t\t\t     peek & 0x0f, Indent (recursion_level),\r\n\t\t\t\t\t     ((map != NULL) ? map_token (map->global, 0, peek) : \"Inline string extension\"),\r\n\t\t\t\t\t     str);\r\n\t\t\toff += 1+len;\r\n\t\t\tbreak;\r\n\t\tcase 0x43: /* PI */\r\n\t\t\tproto_tree_add_none_format(tree, hf_wbxml_pi_xml, tvb, off, 1,\r\n\t\t\t\t\t     \"  %3d | Tag   | T %3d    | PI (XML Processing Instruction) | %s<?xml\",\r\n\t\t\t\t\t     recursion_level, *codepage_stag, Indent (recursion_level));\r\n\t\t\tlen = parse_wbxml_attribute_list_defined (tree, tvb, pinfo, off,\r\n\t\t\t\t\t\t\t\t  str_tbl, codepage_attr, map);\r\n\t\t\t/* Check that there is still room in packet */\r\n\t\t\toff += len;\r\n\t\t\tif (off >= tvb_len) {\r\n\t\t\t\tDebugLog((\"STAG: level = %u, ThrowException: len = %u (short frame)\\n\",\r\n\t\t\t\t\t\t\trecursion_level, off - offset));\r\n\t\t\t}\r\n\r\n\t\t\tproto_tree_add_none_format(tree, hf_wbxml_end_pi, tvb, off-1, 1,\r\n\t\t\t\t\t     \"  %3d | Tag   | T %3d    | END (PI)                        | %s?>\",\r\n\t\t\t\t\t     recursion_level, *codepage_stag, Indent (recursion_level));\r\n\t\t\tbreak;\r\n\t\tcase 0x80: /* EXT_T_0 */\r\n\t\tcase 0x81: /* EXT_T_1 */\r\n\t\tcase 0x82: /* EXT_T_2 */\r\n\t\t\t/* Extension tokens */\r\n\t\t\tidx = tvb_get_uintvar (tvb, off+1, &len, pinfo, &ei_wbxml_oversized_uintvar);\r\n\t\t\t{\r\n\t\t\t\tchar *s;\r\n\t\t\t\tif (map)\r\n\t\t\t\t{\r\n\t\t\t\t\tif (map->ext_t[peek & 0x03])\r\n\t\t\t\t\t\ts = (map->ext_t[peek & 0x03])(pinfo->pool, tvb, idx, str_tbl);\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\ts = wmem_strdup_printf(pinfo->pool, \"EXT_T_%1x (%s)\", peek & 0x03,\r\n\t\t\t\t\t\t\t        map_token (map->global, 0, peek));\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\ts = wmem_strdup_printf(pinfo->pool, \"(Extension Token, integer value: %u)\", idx);\r\n\t\t\t\t}\r\n\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_ext_t, tvb, off, 1+len, s,\r\n\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    | EXT_T_%1x    (Extension Token)    | %s%s\",\r\n\t\t\t\t\t\t     recursion_level, *codepage_stag, peek & 0x0f, Indent (recursion_level), s);\r\n\t\t\t}\r\n\t\t\toff += 1+len;\r\n\t\t\tbreak;\r\n\t\tcase 0x83: /* STR_T */\r\n\t\t\tidx = tvb_get_uintvar (tvb, off+1, &len, pinfo, &ei_wbxml_oversized_uintvar);\r\n\t\t\tstr = tvb_get_stringz_enc(pinfo->pool, tvb, str_tbl+idx, &str_len, encoding);\r\n\t\t\tproto_tree_add_string_format(tree, hf_wbxml_str_t, tvb, off, 1+len, str,\r\n\t\t\t\t\t     \"  %3d | Tag   | T %3d    | STR_T (Tableref string)         | %s\\'%s\\'\",\r\n\t\t\t\t\t     recursion_level, *codepage_stag, Indent (recursion_level), str);\r\n\t\t\toff += 1+len;\r\n\t\t\tbreak;\r\n\t\tcase 0xC0: /* EXT_0 */\r\n\t\tcase 0xC1: /* EXT_1 */\r\n\t\tcase 0xC2: /* EXT_2 */\r\n\t\t\t/* Extension tokens */\r\n\t\t\tstr = (map != NULL) ? map_token (map->global, 0, peek) : \"Single-byte extension\";\r\n\t\t\tproto_tree_add_string_format(tree, hf_wbxml_extension_token, tvb, off, 1, str,\r\n\t\t\t\t\t     \"  %3d | Tag   | T %3d    | EXT_%1x      (Extension Token)    | %s(%s)\",\r\n\t\t\t\t\t     recursion_level, *codepage_stag, peek & 0x0f, Indent (recursion_level), str);\r\n\t\t\toff++;\r\n\t\t\tbreak;\r\n\t\tcase 0xC3: /* OPAQUE - WBXML 1.1 and newer */\r\n\t\t\tif (tvb_get_uint8 (tvb, 0)) { /* WBXML 1.x (x > 0) */\r\n\t\t\t\tif (map != NULL)\r\n\t\t\t\t{\r\n\t\t\t\t\tchar *tmp_str;\r\n\t\t\t\t\tif (tag_save_known) { /* Known tag */\r\n\t\t\t\t\t\tif (map->opaque_binary_tag) {\r\n\t\t\t\t\t\t\ttmp_str = map->opaque_binary_tag(tvb, off + 1,\r\n\t\t\t\t\t\t\t\t\t\t     tag_save_known, *codepage_stag, &len, pinfo);\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\ttmp_str = default_opaque_binary_tag(tvb, off + 1,\r\n\t\t\t\t\t\t\t\t\t\t\ttag_save_known, *codepage_stag, &len, pinfo);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else { /* lITERAL tag */\r\n\t\t\t\t\t\tif (map->opaque_literal_tag) {\r\n\t\t\t\t\t\t\ttmp_str = map->opaque_literal_tag(tvb, off + 1,\r\n\t\t\t\t\t\t\t\t\t\t      tag_save_literal, *codepage_stag, &len, pinfo);\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\ttmp_str = default_opaque_literal_tag(tvb, off + 1,\r\n\t\t\t\t\t\t\t\t\t\t\t tag_save_literal, *codepage_stag, &len, pinfo);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tproto_tree_add_bytes_format(tree, hf_wbxml_opaque_data, tvb, off, 1 + len, NULL,\r\n\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    | OPAQUE (Opaque data)            | %s%s\",\r\n\t\t\t\t\t\t     recursion_level, *codepage_stag, Indent (recursion_level), tmp_str);\r\n\t\t\t\t\toff += 1 + len;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tidx = tvb_get_uintvar (tvb, off+1, &len, pinfo, &ei_wbxml_oversized_uintvar);\r\n\t\t\t\t\tif ((len <= tvb_len) && (idx < tvb_len))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tproto_tree_add_bytes_format(tree, hf_wbxml_opaque_data, tvb, off, 1 + len + idx, NULL,\r\n\t\t\t\t\t\t         \"  %3d | Tag   | T %3d    | OPAQUE (Opaque data)            | %s(%u bytes of opaque data)\",\r\n\t\t\t\t\t\t         recursion_level, *codepage_stag, Indent (recursion_level), idx);\r\n\t\t\t\t\t\toff += 1+len+idx;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t/* Stop processing as it is impossible to parse now */\r\n\t\t\t\t\t\toff = tvb_len;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} else { /* WBXML 1.0 - RESERVED_2 token (invalid) */\r\n\t\t\t\tproto_tree_add_none_format(tree, hf_wbxml_reserved_2, tvb, off, 1,\r\n\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    | RESERVED_2     (Invalid Token!) | WBXML 1.0 parsing stops here.\",\r\n\t\t\t\t\t\t     recursion_level, *codepage_stag);\r\n\t\t\t\t/* Stop processing as it is impossible to parse now */\r\n\t\t\t\toff = tvb_len;\r\n\t\t\t\tDebugLog((\"STAG: level = %u, Return: len = %u\\n\", recursion_level, off - offset));\r\n\t\t\t\treturn (off - offset);\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\r\n\t\t\t/* No default clause, as all cases have been treated */\r\n\t\t} else { /* LITERAL or Known TAG */\r\n\t\t\t/* We must store the initial tag, and also retrieve the new tag.\r\n\t\t\t * For efficiency reasons, we store the literal tag representation\r\n\t\t\t * for known tags too, so we can easily close the tag without the\r\n\t\t\t * need of a new lookup and avoiding storage of token codepage.\r\n\t\t\t *\r\n\t\t\t * There are 4 possibilities:\r\n\t\t\t *\r\n\t\t\t *  1. Known tag followed by a known tag\r\n\t\t\t *  2. Known tag followed by a LITERAL tag\r\n\t\t\t *  3. LITERAL tag followed by Known tag\r\n\t\t\t *  4. LITERAL tag followed by LITERAL tag\r\n\t\t\t */\r\n\r\n\t\t\t/* Store the new tag */\r\n\t\t\ttag_len = 0;\r\n\t\t\tif ((peek & 0x3F) == 4) { /* LITERAL */\r\n\t\t\t\tDebugLog((\"STAG: LITERAL tag (peek = 0x%02X, off = %u) - TableRef follows!\\n\", peek, off));\r\n\t\t\t\tidx = tvb_get_uintvar (tvb, off+1, &tag_len, pinfo, &ei_wbxml_oversized_uintvar);\r\n\t\t\t\ttag_new_literal = tvb_get_stringz_enc(pinfo->pool, tvb, str_tbl+idx, &str_len, encoding);\r\n\t\t\t\ttag_new_known = 0; /* invalidate known tag_new */\r\n\t\t\t} else { /* Known tag */\r\n\t\t\t\ttag_new_known = peek & 0x3F;\r\n\t\t\t\tif (map != NULL) {\r\n\t\t\t\t\ttag_new_literal = map_token (map->tags, *codepage_stag,\r\n\t\t\t\t\t\t\t     tag_new_known);\r\n\t\t\t\t} else {\r\n\t\t\t\t\ttag_new_literal = wmem_strdup_printf(pinfo->pool, \"Tag_0x%02X\",\r\n\t\t\t\t\t\t\ttag_new_known);\r\n\t\t\t\t}\r\n\t\t\t\t/* Stored looked up tag name string */\r\n\t\t\t}\r\n\r\n\t\t\t/* Parsing of TAG starts HERE */\r\n\t\t\tif (peek & 0x40) { /* Content present */\r\n\t\t\t\t/* Content follows\r\n\t\t\t\t * [!] An explicit END token is expected in these cases!\r\n\t\t\t\t * ==> Recursion possible if we encounter a tag with content;\r\n\t\t\t\t *     recursion will return at the explicit END token.\r\n\t\t\t\t */\r\n\t\t\t\tif (parsing_tag_content) { /* Recurse */\r\n\t\t\t\t\tDebugLog((\"STAG: Tag in Tag - RECURSE! (off = %u)\\n\", off));\r\n\t\t\t\t\t/* Do not process the attribute list:\r\n\t\t\t\t\t * recursion will take care of it */\r\n\t\t\t\t\tp_set_proto_depth(pinfo, proto_wbxml, recursion_level + 1);\r\n\t\t\t\t\tlen = parse_wbxml_tag_defined (tree, tvb, pinfo, off, str_tbl,\r\n\t\t\t\t\t\t\t\t       codepage_stag, codepage_attr, map);\r\n\t\t\t\t\toff += len;\r\n\t\t\t\t} else { /* Now we will have content to parse */\r\n\t\t\t\t\t/* Save the start tag so we can properly close it later. */\r\n\t\t\t\t\tif ((peek & 0x3F) == 4) { /* Literal tag */\r\n\t\t\t\t\t\ttag_save_literal = tag_new_literal;\r\n\t\t\t\t\t\ttag_save_known = 0;\r\n\t\t\t\t\t} else { /* Known tag */\r\n\t\t\t\t\t\ttag_save_known = tag_new_known;\r\n\t\t\t\t\t\ttag_save_literal = tag_new_literal;\r\n\t\t\t\t\t\t/* The last statement avoids needless lookups */\r\n\t\t\t\t\t}\r\n\t\t\t\t\t/* Process the attribute list if present */\r\n\t\t\t\t\tif (peek & 0x80) { /* Content and Attribute list present */\r\n\t\t\t\t\t\tif (tag_new_known) { /* Known tag */\r\n\t\t\t\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_known_tag, tvb, off, 1, tag_new_literal,\r\n\t\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    |   Known Tag 0x%02X           (AC) | %s<%s\",\r\n\t\t\t\t\t\t\t\t\t     recursion_level, *codepage_stag, tag_new_known,\r\n\t\t\t\t\t\t\t\t\t     Indent (recursion_level), tag_new_literal);\r\n\t\t\t\t\t\t\t/* Tag string already looked up earlier! */\r\n\t\t\t\t\t\t\toff++;\r\n\t\t\t\t\t\t} else { /* LITERAL tag */\r\n\t\t\t\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_literal_ac, tvb, off, 1, tag_new_literal,\r\n\t\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    | LITERAL_AC (Literal tag)   (AC) | %s<%s\",\r\n\t\t\t\t\t\t\t\t\t     recursion_level, *codepage_stag, Indent (recursion_level), tag_new_literal);\r\n\t\t\t\t\t\t\toff += 1 + tag_len;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tlen = parse_wbxml_attribute_list_defined (tree, tvb, pinfo,\r\n\t\t\t\t\t\t\t\t\t\t\t  off, str_tbl, codepage_attr, map);\r\n\t\t\t\t\t\t/* Check that there is still room in packet */\r\n\t\t\t\t\t\toff += len;\r\n\t\t\t\t\t\tif (off >= tvb_len) {\r\n\t\t\t\t\t\t\tDebugLog((\"STAG: level = %u, ThrowException: len = %u (short frame)\\n\",\r\n\t\t\t\t\t\t\t\t  recursion_level, off - offset));\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tproto_tree_add_none_format(tree, hf_wbxml_end_attribute_list, tvb, off-1, 1,\r\n\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    | END (attribute list)            | %s>\",\r\n\t\t\t\t\t\t\t\t     recursion_level, *codepage_stag, Indent (recursion_level));\r\n\t\t\t\t\t} else { /* Content, no Attribute list */\r\n\t\t\t\t\t\tif (tag_new_known) { /* Known tag */\r\n\t\t\t\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_known_tag, tvb, off, 1, tag_new_literal,\r\n\t\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    |   Known Tag 0x%02X           (.C) | %s<%s>\",\r\n\t\t\t\t\t\t\t\t\t     recursion_level, *codepage_stag, tag_new_known,\r\n\t\t\t\t\t\t\t\t\t     Indent (recursion_level), tag_new_literal);\r\n\t\t\t\t\t\t\t/* Tag string already looked up earlier! */\r\n\t\t\t\t\t\t\toff++;\r\n\t\t\t\t\t\t} else { /* LITERAL tag */\r\n\t\t\t\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_literal_c, tvb, off, 1, tag_new_literal,\r\n\t\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    | LITERAL_C  (Literal Tag)   (.C) | %s<%s>\",\r\n\t\t\t\t\t\t\t\t\t     recursion_level, *codepage_stag, Indent (recursion_level), tag_new_literal);\r\n\t\t\t\t\t\t\toff += 1 + tag_len;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\t/* The data that follows in the parsing process\r\n\t\t\t\t\t * represents content for the opening tag\r\n\t\t\t\t\t * we've just processed in the lines above.\r\n\t\t\t\t\t * Next time we encounter a tag with content: recurse\r\n\t\t\t\t\t */\r\n\t\t\t\t\tparsing_tag_content = true;\r\n\t\t\t\t\tDebugLog((\"Tag in Tag - No recursion this time! (off = %u)\\n\", off));\r\n\t\t\t\t}\r\n\t\t\t} else { /* No Content */\r\n\t\t\t\tDebugLog((\"<Tag/> in Tag - No recursion! (off = %u)\\n\", off));\r\n\t\t\t\trecursion_level++;\r\n\t\t\t\tp_set_proto_depth(pinfo, proto_wbxml, recursion_level);\r\n\t\t\t\tif (peek & 0x80) { /* No Content, Attribute list present */\r\n\t\t\t\t\tif (tag_new_known) { /* Known tag */\r\n\t\t\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_known_tag, tvb, off, 1, tag_new_literal,\r\n\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    |   Known Tag 0x%02X           (A.) | %s<%s\",\r\n\t\t\t\t\t\t\t\t     recursion_level, *codepage_stag, tag_new_known,\r\n\t\t\t\t\t\t\t\t     Indent (recursion_level), tag_new_literal);\r\n\t\t\t\t\t\t/* Tag string already looked up earlier! */\r\n\t\t\t\t\t\toff++;\r\n\t\t\t\t\t\tlen = parse_wbxml_attribute_list_defined (tree, tvb, pinfo,\r\n\t\t\t\t\t\t\t\t\t\t\t  off, str_tbl, codepage_attr, map);\r\n\t\t\t\t\t\t/* Check that there is still room in packet */\r\n\t\t\t\t\t\toff += len;\r\n\t\t\t\t\t\tif (off > tvb_len) {\r\n\t\t\t\t\t\t\tDebugLog((\"STAG: level = %u, ThrowException: len = %u (short frame)\\n\",\r\n\t\t\t\t\t\t\t\t\t\trecursion_level, off - offset));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tproto_tree_add_uint_format(tree, hf_wbxml_end_known_tag_uint, tvb, off-1, 1, *codepage_stag,\r\n\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    | END (Known Tag)                 | %s/>\",\r\n\t\t\t\t\t\t\t\t     recursion_level, *codepage_stag, Indent (recursion_level));\r\n\t\t\t\t\t} else { /* LITERAL tag */\r\n\t\t\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_literal_a, tvb, off, 1, tag_new_literal,\r\n\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    | LITERAL_A  (Literal Tag)   (A.) | %s<%s\",\r\n\t\t\t\t\t\t\t\t     recursion_level, *codepage_stag, Indent (recursion_level), tag_new_literal);\r\n\t\t\t\t\t\toff += 1 + tag_len;\r\n\t\t\t\t\t\tlen = parse_wbxml_attribute_list_defined (tree, tvb, pinfo,\r\n\t\t\t\t\t\t\t\t\t\t\t  off, str_tbl, codepage_attr, map);\r\n\t\t\t\t\t\t/* Check that there is still room in packet */\r\n\t\t\t\t\t\toff += len;\r\n\t\t\t\t\t\tif (off >= tvb_len) {\r\n\t\t\t\t\t\t\tDebugLog((\"STAG: level = %u, ThrowException: len = %u (short frame)\\n\",\r\n\t\t\t\t\t\t\t\t\t\trecursion_level, off - offset));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_end_literal_tag, tvb, off-1, 1, \"\",\r\n\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    | END (Literal Tag)               | %s/>\",\r\n\t\t\t\t\t\t\t\t     recursion_level, *codepage_stag, Indent (recursion_level));\r\n\t\t\t\t\t}\r\n\t\t\t\t} else { /* No Content, No Attribute list */\r\n\t\t\t\t\tif (tag_new_known) { /* Known tag */\r\n\t\t\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_known_tag, tvb, off, 1, tag_new_literal,\r\n\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    |   Known Tag 0x%02x           (..) | %s<%s />\",\r\n\t\t\t\t\t\t\t\t     recursion_level, *codepage_stag, tag_new_known,\r\n\t\t\t\t\t\t\t\t     Indent (recursion_level), tag_new_literal);\r\n\t\t\t\t\t\t/* Tag string already looked up earlier! */\r\n\t\t\t\t\t\toff++;\r\n\t\t\t\t\t} else { /* LITERAL tag */\r\n\t\t\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_literal, tvb, off, 1, tag_new_literal,\r\n\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    | LITERAL    (Literal Tag)   (..) | %s<%s />\",\r\n\t\t\t\t\t\t\t\t     recursion_level, *codepage_stag, Indent (recursion_level),\r\n\t\t\t\t\t\t\t\t     tag_new_literal);\r\n\t\t\t\t\t\toff += 1 + tag_len;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\trecursion_level--;\r\n\t\t\t\tp_set_proto_depth(pinfo, proto_wbxml, recursion_level);\r\n\t\t\t\t/* TODO: Do I have to reset code page here? */\r\n\t\t\t}\r\n\t\t} /* if (tag & 0x3F) >= 5 */\r\n\t} /* while */\r\n\tDebugLog((\"STAG: level = %u, Return: len = %u (end of function body)\\n\", recursion_level, off - offset));\r\n\treturn (off - offset);\r\n}", ".issect_wbxml": "static int\r\ndissect_wbxml(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\n\tdissect_wbxml_common(tvb, pinfo, tree, NULL);\r\n\treturn tvb_captured_length(tvb);\r\n}", ".issect_uaprof": "static int\r\ndissect_uaprof(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\n\tdissect_wbxml_common(tvb, pinfo, tree, &decode_uaprof_wap_248);\r\n\treturn tvb_captured_length(tvb);\r\n}", ".roto_register_wbxml": "void\r\nproto_register_wbxml(void)\r\n{\r\n\tmodule_t *wbxml_module;\t/* WBXML Preferences */\r\n\r\n\t/* Setup list of header fields. */\r\n\tstatic hf_register_info hf[] = {\r\n\t\t{ &hf_wbxml_version,\r\n\t\t  { \"Version\",\r\n\t\t    \"wbxml.version\",\r\n\t\t    FT_UINT8, BASE_HEX|BASE_EXT_STRING,\r\n\t\t    &vals_wbxml_versions_ext, 0x00,\r\n\t\t    \"WBXML Version\", HFILL }\r\n\t\t},\r\n\t\t{ &hf_wbxml_public_id_known,\r\n\t\t  { \"Public Identifier (known)\",\r\n\t\t    \"wbxml.public_id.known\",\r\n\t\t    FT_UINT32, BASE_HEX|BASE_EXT_STRING,\r\n\t\t    &vals_wbxml_public_ids_ext, 0x00,\r\n\t\t    \"WBXML Known Public Identifier (integer)\", HFILL }\r\n\t\t},\r\n\t\t{ &hf_wbxml_public_id_literal,\r\n\t\t  { \"Public Identifier (literal)\",\r\n\t\t    \"wbxml.public_id.literal\",\r\n\t\t    FT_STRING, BASE_NONE,\r\n\t\t    NULL, 0x00,\r\n\t\t    \"WBXML Literal Public Identifier (text string)\", HFILL }\r\n\t\t},\r\n\t\t{ &hf_wbxml_charset,\r\n\t\t  { \"Character Set\",\r\n\t\t    \"wbxml.charset\",\r\n\t\t    FT_UINT32, BASE_DEC|BASE_EXT_STRING,\r\n\t\t    &mibenum_vals_character_sets_ext, 0x00,\r\n\t\t    \"WBXML Character Set\", HFILL }\r\n\t\t},\r\n\t\t{ &hf_wbxml_string_table_item_offset,\r\n\t\t  { \"Offset\",\r\n\t\t    \"wbxml.string_table_item_offset\",\r\n\t\t    FT_UINT32, BASE_DEC,\r\n\t\t    NULL, 0x00,\r\n\t\t    NULL, HFILL }\r\n\t\t},\r\n\t\t{ &hf_wbxml_string_table_item_string,\r\n\t\t  { \"String\",\r\n\t\t    \"wbxml.string_table_item_string\",\r\n\t\t    FT_STRINGZ, BASE_NONE,\r\n\t\t    NULL, 0x00,\r\n\t\t    NULL, HFILL }\r\n\t\t},\r\n\t\t{ &hf_wbxml_switch_page,\r\n\t\t  { \"SWITCH_PAGE\",\r\n\t\t    \"wbxml.switch_page\",\r\n\t\t    FT_UINT32, BASE_DEC,\r\n\t\t    NULL, 0x00,\r\n\t\t    NULL, HFILL }\r\n\t\t},\r\n\t\t{ &hf_wbxml_known_tag,\r\n\t\t  { \"Known Tag\",\r\n\t\t    \"wbxml.known_tag\",\r\n\t\t    FT_STRING, BASE_NONE,\r\n\t\t    NULL, 0x00,\r\n\t\t    NULL, HFILL }\r\n\t\t},\r\n\t\t{ &hf_wbxml_end_known_tag,\r\n\t\t  { \"END Known Tag\",\r\n\t\t    \"wbxml.end_known_tag\",\r\n\t\t    FT_STRING, BASE_NONE,\r\n\t\t    NULL, 0x00,\r\n\t\t    NULL, HFILL }\r\n\t\t},\r\n\t\t{ &hf_wbxml_end_known_tag_uint,\r\n\t\t  { \"END Known Tag\",\r\n\t\t    \"wbxml.end_known_tag.uint\",\r\n\t\t    FT_UINT32, BASE_DEC,\r\n\t\t    NULL, 0x00,\r\n\t\t    NULL, HFILL }\r\n\t\t},\r\n\t\t{ &hf_wbxml_str_i,\r\n\t\t  { \"STR_I\",\r\n\t\t    \"wbxml.str_i\",\r\n\t\t    FT_STRING, BASE_NONE,\r\n\t\t    NULL, 0x00,\r\n\t\t    NULL, HFILL }\r\n\t\t},\r\n\t\t{ &hf_wbxml_str_t,\r\n\t\t  { \"STR_T\",\r\n\t\t    \"wbxml.str_t\",\r\n\t\t    FT_STRING, BASE_NONE,\r\n\t\t    NULL, 0x00,\r\n\t\t    NULL, HFILL }\r\n\t\t},\r\n\t\t{ &hf_wbxml_opaque_data,\r\n\t\t  { \"Opaque Data\",\r\n\t\t    \"wbxml.opaque_data\",\r\n\t\t    FT_BYTES, BASE_NONE,\r\n\t\t    NULL, 0x00,\r\n\t\t    NULL, HFILL }\r\n\t\t},\r\n\t\t{ &hf_wbxml_entity,\r\n\t\t  { \"ENTITY\",\r\n\t\t    \"wbxml.entity\",\r\n\t\t    FT_UINT32, BASE_DEC,\r\n\t\t    NULL, 0x00,\r\n\t\t    NULL, HFILL }\r\n\t\t},\r\n\t\t{ &hf_wbxml_literal,\r\n\t\t  { \"LITERAL\",\r\n\t\t    \"wbxml.literal\",\r\n\t\t    FT_STRING, BASE_NONE,\r\n\t\t    NULL, 0x00,\r\n\t\t    NULL, HFILL }\r\n\t\t},\r\n\t\t{ &hf_wbxml_ext_i,\r\n\t\t  { \"EXT_I\",\r\n\t\t    \"wbxml.ext_i\",\r\n\t\t    FT_STRING, BASE_NONE,\r\n\t\t    NULL, 0x00,\r\n\t\t    NULL, HFILL }\r\n\t\t},\r\n\t\t{ &hf_wbxml_ext_t,\r\n\t\t  { \"EXT_T\",\r\n\t\t    \"wbxml.ext_t\",\r\n\t\t    FT_STRING, BASE_NONE,\r\n\t\t    NULL, 0x00,\r\n\t\t    NULL, HFILL }\r\n\t\t},\r\n\t\t{ &hf_wbxml_extension_token,\r\n\t\t  { \"Extension Token\",\r\n\t\t    \"wbxml.extension_token\",\r\n\t\t    FT_STRING, BASE_NONE,\r\n\t\t    NULL, 0x00,\r\n\t\t    NULL, HFILL }\r\n\t\t},\r\n\t\t{ &hf_wbxml_reserved_2,\r\n\t\t  { \"RESERVED_2\",\r\n\t\t    \"wbxml.reserved_2\",\r\n\t\t    FT_NONE, BASE_NONE,\r\n\t\t    NULL, 0x00,\r\n\t\t    NULL, HFILL }\r\n\t\t},\r\n\t\t{ &hf_wbxml_invalid_token,\r\n\t\t  { \"Invalid token\",\r\n\t\t    \"wbxml.invalid_token\",\r\n\t\t    FT_NONE, BASE_NONE,\r\n\t\t    NULL, 0x00,\r\n\t\t    NULL, HFILL }\r\n\t\t},\r\n\t\t{ &hf_wbxml_known_attrvalue,\r\n\t\t  { \"Known attrValue\",\r\n\t\t    \"wbxml.known_attrvalue\",\r\n\t\t    FT_STRING, BASE_NONE,\r\n\t\t    NULL, 0x00,\r\n\t\t    NULL, HFILL }\r\n\t\t},\r\n\t\t{ &hf_wbxml_known_attrstart,\r\n\t\t  { \"Known attrStart\",\r\n\t\t    \"wbxml.known_attrstart\",\r\n\t\t    FT_STRING, BASE_NONE,\r\n\t\t    NULL, 0x00,\r\n\t\t    NULL, HFILL }\r\n\t\t},\r\n\t\t{ &hf_wbxml_end_literal_tag,\r\n\t\t  { \"END (Literal Tag)\",\r\n\t\t    \"wbxml.end_literal_tag\",\r\n\t\t    FT_STRING, BASE_NONE,\r\n\t\t    NULL, 0x00,\r\n\t\t    NULL, HFILL }\r\n\t\t},\r\n\t\t{ &hf_wbxml_literal_a,\r\n\t\t  { \"LITERAL_A\",\r\n\t\t    \"wbxml.literal_a\",\r\n\t\t    FT_STRING, BASE_NONE,\r\n\t\t    NULL, 0x00,\r\n\t\t    NULL, HFILL }\r\n\t\t},\r\n\t\t{ &hf_wbxml_literal_c,\r\n\t\t  { \"LITERAL_C\",\r\n\t\t    \"wbxml.literal_c\",\r\n\t\t    FT_STRING, BASE_NONE,\r\n\t\t    NULL, 0x00,\r\n\t\t    NULL, HFILL }\r\n\t\t},\r\n\t\t{ &hf_wbxml_literal_ac,\r\n\t\t  { \"LITERAL_AC\",\r\n\t\t    \"wbxml.literal_ac\",\r\n\t\t    FT_STRING, BASE_NONE,\r\n\t\t    NULL, 0x00,\r\n\t\t    NULL, HFILL }\r\n\t\t},\r\n\t\t{ &hf_wbxml_end_pi,\r\n\t\t  { \"END (PI)\",\r\n\t\t    \"wbxml.end_pi\",\r\n\t\t    FT_NONE, BASE_NONE,\r\n\t\t    NULL, 0x00,\r\n\t\t    NULL, HFILL }\r\n\t\t},\r\n\t\t{ &hf_wbxml_end_attribute_list,\r\n\t\t  { \"END (attribute list)\",\r\n\t\t    \"wbxml.end_attribute_list\",\r\n\t\t    FT_NONE, BASE_NONE,\r\n\t\t    NULL, 0x00,\r\n\t\t    NULL, HFILL }\r\n\t\t},\r\n\t\t{ &hf_wbxml_pi_xml,\r\n\t\t  { \"PI (XML Processing Instruction)\",\r\n\t\t    \"wbxml.pi_xml\",\r\n\t\t    FT_NONE, BASE_NONE,\r\n\t\t    NULL, 0x00,\r\n\t\t    NULL, HFILL }\r\n\t\t},\r\n\t};\r\n\r\n\t/* Setup protocol subtree array */\r\n\tstatic int *ett[] = {\r\n\t\t&ett_wbxml,\r\n\t\t&ett_wbxml_str_tbl,\r\n\t\t&ett_wbxml_content,\r\n\t\t&ett_wbxml_tags,\r\n\t\t&ett_wbxml_string_table_item,\r\n\t};\r\n\r\n\tstatic ei_register_info ei[] = {\r\n\t\t{ &ei_wbxml_data_not_shown, { \"wbxml.data_not_shown\", PI_PROTOCOL, PI_NOTE, \"Data representation not shown (edit WBXML preferences to show)\", EXPFILL }},\r\n\t\t{ &ei_wbxml_content_type_not_supported, { \"wbxml.content_type.not_supported\", PI_UNDECODED, PI_WARN, \"Rendering of this content type not (yet) supported\", EXPFILL }},\r\n\t\t{ &ei_wbxml_content_type_disabled, { \"wbxml.content_type.disabled\", PI_PROTOCOL, PI_NOTE, \"Rendering of this content type has been disabled (edit WBXML preferences to enable)\", EXPFILL }},\r\n\t\t{ &ei_wbxml_oversized_uintvar, { \"wbxml.oversized_uintvar\", PI_MALFORMED, PI_ERROR, \"Uintvar is oversized\", EXPFILL }},\r\n\t\t{ &ei_wbxml_too_much_recursion, { \"wbxml.too_much_recursion\", PI_UNDECODED, PI_WARN, \"Too much recursion\", EXPFILL }}\r\n\t};\r\n\r\n\texpert_module_t* expert_wbxml;\r\n\r\n\t/* Register the protocol name and description */\r\n\tproto_wbxml = proto_register_protocol(\"WAP Binary XML\", \"WBXML\", \"wbxml\");\r\n\r\n\t/* Required function calls to register the header fields\r\n\t * and subtrees used */\r\n\tproto_register_field_array(proto_wbxml, hf, array_length(hf));\r\n\tproto_register_subtree_array(ett, array_length(ett));\r\n\texpert_wbxml = expert_register_protocol(proto_wbxml);\r\n\texpert_register_field_array(expert_wbxml, ei, array_length(ei));\r\n\r\n\t/* Preferences */\r\n\twbxml_module = prefs_register_protocol(proto_wbxml, NULL);\r\n\tprefs_register_bool_preference(wbxml_module,\r\n\t\t\t\t       \"skip_wbxml_token_mapping\",\r\n\t\t\t\t       \"Skip the mapping of WBXML tokens to media type tokens.\",\r\n\t\t\t\t       \"Enable this preference if you want to view the WBXML \"\r\n\t\t\t\t       \"tokens without the representation in a media type \"\r\n\t\t\t\t       \"(e.g., WML). Tokens will show up as Tag_0x12, \"\r\n\t\t\t\t       \"attrStart_0x08 or attrValue_0x0B for example.\",\r\n\t\t\t\t       &skip_wbxml_token_mapping);\r\n\tprefs_register_bool_preference(wbxml_module,\r\n\t\t\t\t       \"disable_wbxml_token_parsing\",\r\n\t\t\t\t       \"Disable the parsing of the WBXML tokens.\",\r\n\t\t\t\t       \"Enable this preference if you want to skip the \"\r\n\t\t\t\t       \"parsing of the WBXML tokens that constitute the body \"\r\n\t\t\t\t       \"of the WBXML document. Only the WBXML header will be \"\r\n\t\t\t\t       \"dissected (and visualized) then.\",\r\n\t\t\t\t       &disable_wbxml_token_parsing);\r\n\r\n\tregister_dissector(\"wbxml\", dissect_wbxml, proto_wbxml);\r\n\tregister_dissector(\"wbxml-uaprof\", dissect_uaprof, proto_wbxml);\r\n}"}, "function_name": "proto_reg_handoff_wbxml"}
{"function_id": null, "caller": {".vl_cleanup_locked": "static int ovl_cleanup_locked(struct ovl_fs *ofs, struct inode *wdir,\r\n\t\t\t      struct dentry *wdentry)\r\n{\r\n\tint err;\r\n\r\n\tdget(wdentry);\r\n\tif (d_is_dir(wdentry))\r\n\t\terr = ovl_do_rmdir(ofs, wdir, wdentry);\r\n\telse\r\n\t\terr = ovl_do_unlink(ofs, wdir, wdentry);\r\n\tdput(wdentry);\r\n\r\n\tif (err) {\r\n\t\tpr_err(\"cleanup of '%pd2' failed (%i)\\n\",\r\n\t\t       wdentry, err);\r\n\t}\r\n\r\n\treturn err;\r\n}", ".vl_cleanup": "int ovl_cleanup(struct ovl_fs *ofs, struct dentry *workdir,\r\n\t\tstruct dentry *wdentry)\r\n{\r\n\tint err;\r\n\r\n\terr = ovl_parent_lock(workdir, wdentry);\r\n\tif (err)\r\n\t\treturn err;\r\n\r\n\tovl_cleanup_locked(ofs, workdir->d_inode, wdentry);\r\n\tovl_parent_unlock(workdir);\r\n\r\n\treturn 0;\r\n}", ".vl_set_opaque_xerr": "static int ovl_set_opaque_xerr(struct dentry *dentry, struct dentry *upper,\r\n\t\t\t       int xerr)\r\n{\r\n\tstruct ovl_fs *ofs = OVL_FS(dentry->d_sb);\r\n\tint err;\r\n\r\n\terr = ovl_check_setxattr(ofs, upper, OVL_XATTR_OPAQUE, \"y\", 1, xerr);\r\n\tif (!err)\r\n\t\tovl_dentry_set_opaque(dentry);\r\n\r\n\treturn err;\r\n}", ".vl_type_merge": "static bool ovl_type_merge(struct dentry *dentry)\r\n{\r\n\treturn OVL_TYPE_MERGE(ovl_path_type(dentry));\r\n}", ".vl_set_opaque": "static int ovl_set_opaque(struct dentry *dentry, struct dentry *upperdentry)\r\n{\r\n\t/*\r\n\t * Fail with -EIO when trying to create opaque dir and upper doesn't\r\n\t * support xattrs. ovl_rename() calls ovl_set_opaque_xerr(-EXDEV) to\r\n\t * return a specific error for noxattr case.\r\n\t */\r\n\treturn ovl_set_opaque_xerr(dentry, upperdentry, -EIO);\r\n}", ".vl_instantiate": "static int ovl_instantiate(struct dentry *dentry, struct inode *inode,\r\n\t\t\t   struct dentry *newdentry, bool hardlink, struct file *tmpfile)\r\n{\r\n\tstruct ovl_inode_params oip = {\r\n\t\t.upperdentry = newdentry,\r\n\t\t.newinode = inode,\r\n\t};\r\n\r\n\tovl_dentry_set_upper_alias(dentry);\r\n\tovl_dentry_init_reval(dentry, newdentry, NULL);\r\n\r\n\tif (!hardlink) {\r\n\t\t/*\r\n\t\t * ovl_obtain_alias() can be called after ovl_create_real()\r\n\t\t * and before we get here, so we may get an inode from cache\r\n\t\t * with the same real upperdentry that is not the inode we\r\n\t\t * pre-allocated.  In this case we will use the cached inode\r\n\t\t * to instantiate the new dentry.\r\n\t\t *\r\n\t\t * XXX: if we ever use ovl_obtain_alias() to decode directory\r\n\t\t * file handles, need to use ovl_get_inode_locked() and\r\n\t\t * d_instantiate_new() here to prevent from creating two\r\n\t\t * hashed directory inode aliases.  We then need to return\r\n\t\t * the obtained alias to ovl_mkdir().\r\n\t\t */\r\n\t\tinode = ovl_get_inode(dentry->d_sb, &oip);\r\n\t\tif (IS_ERR(inode))\r\n\t\t\treturn PTR_ERR(inode);\r\n\t\tif (inode == oip.newinode)\r\n\t\t\tovl_set_flag(OVL_UPPERDATA, inode);\r\n\t} else {\r\n\t\tWARN_ON(ovl_inode_real(inode) != d_inode(newdentry));\r\n\t\tdput(newdentry);\r\n\t\tinc_nlink(inode);\r\n\t}\r\n\r\n\tif (tmpfile)\r\n\t\td_mark_tmpfile(tmpfile, inode);\r\n\r\n\td_instantiate(dentry, inode);\r\n\tif (inode != oip.newinode) {\r\n\t\tpr_warn_ratelimited(\"newly created inode found in cache (%pd2)\\n\",\r\n\t\t\t\t    dentry);\r\n\t}\r\n\r\n\t/* Force lookup of new upper hardlink to find its lower */\r\n\tif (hardlink)\r\n\t\td_drop(dentry);\r\n\r\n\treturn 0;\r\n}", ".vl_set_upper_acl": "static int ovl_set_upper_acl(struct ovl_fs *ofs, struct dentry *upperdentry,\r\n\t\t\t     const char *acl_name, struct posix_acl *acl)\r\n{\r\n\tif (!IS_ENABLED(CONFIG_FS_POSIX_ACL) || !acl)\r\n\t\treturn 0;\r\n\r\n\treturn ovl_do_set_acl(ofs, upperdentry, acl_name, acl);\r\n}", ".vl_create_upper": "static int ovl_create_upper(struct dentry *dentry, struct inode *inode,\r\n\t\t\t    struct ovl_cattr *attr)\r\n{\r\n\tstruct ovl_fs *ofs = OVL_FS(dentry->d_sb);\r\n\tstruct dentry *upperdir = ovl_dentry_upper(dentry->d_parent);\r\n\tstruct inode *udir = upperdir->d_inode;\r\n\tstruct dentry *newdentry;\r\n\tint err;\r\n\r\n\tinode_lock_nested(udir, I_MUTEX_PARENT);\r\n\tnewdentry = ovl_create_real(ofs, upperdir,\r\n\t\t\t\t    ovl_lookup_upper(ofs, dentry->d_name.name,\r\n\t\t\t\t\t\t     upperdir, dentry->d_name.len),\r\n\t\t\t\t    attr);\r\n\tinode_unlock(udir);\r\n\tif (IS_ERR(newdentry))\r\n\t\treturn PTR_ERR(newdentry);\r\n\r\n\tif (ovl_type_merge(dentry->d_parent) && d_is_dir(newdentry) &&\r\n\t    !ovl_allow_offline_changes(ofs)) {\r\n\t\t/* Setting opaque here is just an optimization, allow to fail */\r\n\t\tovl_set_opaque(dentry, newdentry);\r\n\t}\r\n\r\n\tovl_dir_modified(dentry->d_parent, false);\r\n\terr = ovl_instantiate(dentry, inode, newdentry, !!attr->hardlink, NULL);\r\n\tif (err)\r\n\t\tgoto out_cleanup;\r\n\treturn 0;\r\n\r\nout_cleanup:\r\n\tovl_cleanup(ofs, upperdir, newdentry);\r\n\tdput(newdentry);\r\n\treturn err;\r\n}", ".vl_create_over_whiteout": "static int ovl_create_over_whiteout(struct dentry *dentry, struct inode *inode,\r\n\t\t\t\t    struct ovl_cattr *cattr)\r\n{\r\n\tstruct ovl_fs *ofs = OVL_FS(dentry->d_sb);\r\n\tstruct dentry *workdir = ovl_workdir(dentry);\r\n\tstruct dentry *upperdir = ovl_dentry_upper(dentry->d_parent);\r\n\tstruct dentry *upper;\r\n\tstruct dentry *newdentry;\r\n\tint err;\r\n\tstruct posix_acl *acl, *default_acl;\r\n\tbool hardlink = !!cattr->hardlink;\r\n\r\n\tif (WARN_ON(!workdir))\r\n\t\treturn -EROFS;\r\n\r\n\tif (!hardlink) {\r\n\t\terr = posix_acl_create(dentry->d_parent->d_inode,\r\n\t\t\t\t       &cattr->mode, &default_acl, &acl);\r\n\t\tif (err)\r\n\t\t\treturn err;\r\n\t}\r\n\r\n\tupper = ovl_lookup_upper_unlocked(ofs, dentry->d_name.name, upperdir,\r\n\t\t\t\t\t  dentry->d_name.len);\r\n\terr = PTR_ERR(upper);\r\n\tif (IS_ERR(upper))\r\n\t\tgoto out;\r\n\r\n\terr = -ESTALE;\r\n\tif (d_is_negative(upper) || !ovl_upper_is_whiteout(ofs, upper))\r\n\t\tgoto out_dput;\r\n\r\n\tnewdentry = ovl_create_temp(ofs, workdir, cattr);\r\n\terr = PTR_ERR(newdentry);\r\n\tif (IS_ERR(newdentry))\r\n\t\tgoto out_dput;\r\n\r\n\terr = ovl_lock_rename_workdir(workdir, newdentry, upperdir, upper);\r\n\tif (err)\r\n\t\tgoto out_cleanup_unlocked;\r\n\r\n\t/*\r\n\t * mode could have been mutilated due to umask (e.g. sgid directory)\r\n\t */\r\n\tif (!hardlink &&\r\n\t    !S_ISLNK(cattr->mode) &&\r\n\t    newdentry->d_inode->i_mode != cattr->mode) {\r\n\t\tstruct iattr attr = {\r\n\t\t\t.ia_valid = ATTR_MODE,\r\n\t\t\t.ia_mode = cattr->mode,\r\n\t\t};\r\n\t\tinode_lock(newdentry->d_inode);\r\n\t\terr = ovl_do_notify_change(ofs, newdentry, &attr);\r\n\t\tinode_unlock(newdentry->d_inode);\r\n\t\tif (err)\r\n\t\t\tgoto out_cleanup;\r\n\t}\r\n\tif (!hardlink) {\r\n\t\terr = ovl_set_upper_acl(ofs, newdentry,\r\n\t\t\t\t\tXATTR_NAME_POSIX_ACL_ACCESS, acl);\r\n\t\tif (err)\r\n\t\t\tgoto out_cleanup;\r\n\r\n\t\terr = ovl_set_upper_acl(ofs, newdentry,\r\n\t\t\t\t\tXATTR_NAME_POSIX_ACL_DEFAULT, default_acl);\r\n\t\tif (err)\r\n\t\t\tgoto out_cleanup;\r\n\t}\r\n\r\n\tif (!hardlink && S_ISDIR(cattr->mode)) {\r\n\t\terr = ovl_set_opaque(dentry, newdentry);\r\n\t\tif (err)\r\n\t\t\tgoto out_cleanup;\r\n\r\n\t\terr = ovl_do_rename(ofs, workdir, newdentry, upperdir, upper,\r\n\t\t\t\t    RENAME_EXCHANGE);\r\n\t\tunlock_rename(workdir, upperdir);\r\n\t\tif (err)\r\n\t\t\tgoto out_cleanup_unlocked;\r\n\r\n\t\tovl_cleanup(ofs, workdir, upper);\r\n\t} else {\r\n\t\terr = ovl_do_rename(ofs, workdir, newdentry, upperdir, upper, 0);\r\n\t\tunlock_rename(workdir, upperdir);\r\n\t\tif (err)\r\n\t\t\tgoto out_cleanup_unlocked;\r\n\t}\r\n\tovl_dir_modified(dentry->d_parent, false);\r\n\terr = ovl_instantiate(dentry, inode, newdentry, hardlink, NULL);\r\n\tif (err) {\r\n\t\tovl_cleanup(ofs, upperdir, newdentry);\r\n\t\tdput(newdentry);\r\n\t}\r\nout_dput:\r\n\tdput(upper);\r\nout:\r\n\tif (!hardlink) {\r\n\t\tposix_acl_release(acl);\r\n\t\tposix_acl_release(default_acl);\r\n\t}\r\n\treturn err;\r\n\r\nout_cleanup:\r\n\tunlock_rename(workdir, upperdir);\r\nout_cleanup_unlocked:\r\n\tovl_cleanup(ofs, workdir, newdentry);\r\n\tdput(newdentry);\r\n\tgoto out_dput;\r\n}", ".vl_create_or_link": "static int ovl_create_or_link(struct dentry *dentry, struct inode *inode,\r\n\t\t\t      struct ovl_cattr *attr, bool origin)\r\n{\r\n\tint err;\r\n\tconst struct cred *old_cred, *new_cred = NULL;\r\n\tstruct dentry *parent = dentry->d_parent;\r\n\r\n\told_cred = ovl_override_creds(dentry->d_sb);\r\n\r\n\t/*\r\n\t * When linking a file with copy up origin into a new parent, mark the\r\n\t * new parent dir \"impure\".\r\n\t */\r\n\tif (origin) {\r\n\t\terr = ovl_set_impure(parent, ovl_dentry_upper(parent));\r\n\t\tif (err)\r\n\t\t\tgoto out_revert_creds;\r\n\t}\r\n\r\n\tif (!attr->hardlink) {\r\n\t\t/*\r\n\t\t * In the creation cases(create, mkdir, mknod, symlink),\r\n\t\t * ovl should transfer current's fs{u,g}id to underlying\r\n\t\t * fs. Because underlying fs want to initialize its new\r\n\t\t * inode owner using current's fs{u,g}id. And in this\r\n\t\t * case, the @inode is a new inode that is initialized\r\n\t\t * in inode_init_owner() to current's fs{u,g}id. So use\r\n\t\t * the inode's i_{u,g}id to override the cred's fs{u,g}id.\r\n\t\t *\r\n\t\t * But in the other hardlink case, ovl_link() does not\r\n\t\t * create a new inode, so just use the ovl mounter's\r\n\t\t * fs{u,g}id.\r\n\t\t */\r\n\t\tnew_cred = ovl_setup_cred_for_create(dentry, inode, attr->mode,\r\n\t\t\t\t\t\t     old_cred);\r\n\t\terr = PTR_ERR(new_cred);\r\n\t\tif (IS_ERR(new_cred)) {\r\n\t\t\tnew_cred = NULL;\r\n\t\t\tgoto out_revert_creds;\r\n\t\t}\r\n\t}\r\n\r\n\tif (!ovl_dentry_is_whiteout(dentry))\r\n\t\terr = ovl_create_upper(dentry, inode, attr);\r\n\telse\r\n\t\terr = ovl_create_over_whiteout(dentry, inode, attr);\r\n\r\nout_revert_creds:\r\n\tovl_revert_creds(old_cred);\r\n\tput_cred(new_cred);\r\n\treturn err;\r\n}", ".vl_create_object": "static int ovl_create_object(struct dentry *dentry, int mode, dev_t rdev,\r\n\t\t\t     const char *link)\r\n{\r\n\tint err;\r\n\tstruct inode *inode;\r\n\tstruct ovl_cattr attr = {\r\n\t\t.rdev = rdev,\r\n\t\t.link = link,\r\n\t};\r\n\r\n\terr = ovl_copy_up(dentry->d_parent);\r\n\tif (err)\r\n\t\treturn err;\r\n\r\n\terr = ovl_want_write(dentry);\r\n\tif (err)\r\n\t\tgoto out;\r\n\r\n\t/* Preallocate inode to be used by ovl_get_inode() */\r\n\terr = -ENOMEM;\r\n\tinode = ovl_new_inode(dentry->d_sb, mode, rdev);\r\n\tif (!inode)\r\n\t\tgoto out_drop_write;\r\n\r\n\tspin_lock(&inode->i_lock);\r\n\tinode->i_state |= I_CREATING;\r\n\tspin_unlock(&inode->i_lock);\r\n\r\n\tinode_init_owner(&nop_mnt_idmap, inode, dentry->d_parent->d_inode, mode);\r\n\tattr.mode = inode->i_mode;\r\n\r\n\terr = ovl_create_or_link(dentry, inode, &attr, false);\r\n\t/* Did we end up using the preallocated inode? */\r\n\tif (inode != d_inode(dentry))\r\n\t\tiput(inode);\r\n\r\nout_drop_write:\r\n\tovl_drop_write(dentry);\r\nout:\r\n\treturn err;\r\n}", ".vl_set_redirect": "static int ovl_set_redirect(struct dentry *dentry, bool samedir)\r\n{\r\n\tint err;\r\n\tstruct ovl_fs *ofs = OVL_FS(dentry->d_sb);\r\n\tconst char *redirect = ovl_dentry_get_redirect(dentry);\r\n\tbool absolute_redirect = ovl_need_absolute_redirect(dentry, samedir);\r\n\r\n\tif (redirect && (!absolute_redirect || redirect[0] == '/'))\r\n\t\treturn 0;\r\n\r\n\tredirect = ovl_get_redirect(dentry, absolute_redirect);\r\n\tif (IS_ERR(redirect))\r\n\t\treturn PTR_ERR(redirect);\r\n\r\n\terr = ovl_check_setxattr(ofs, ovl_dentry_upper(dentry),\r\n\t\t\t\t OVL_XATTR_REDIRECT,\r\n\t\t\t\t redirect, strlen(redirect), -EXDEV);\r\n\tif (!err) {\r\n\t\tspin_lock(&dentry->d_lock);\r\n\t\tovl_dentry_set_redirect(dentry, redirect);\r\n\t\tspin_unlock(&dentry->d_lock);\r\n\t} else {\r\n\t\tkfree(redirect);\r\n\t\tpr_warn_ratelimited(\"failed to set redirect (%i)\\n\",\r\n\t\t\t\t    err);\r\n\t\t/* Fall back to userspace copy-up */\r\n\t\terr = -EXDEV;\r\n\t}\r\n\treturn err;\r\n}", ".vl_set_link_redirect": "static int ovl_set_link_redirect(struct dentry *dentry)\r\n{\r\n\tconst struct cred *old_cred;\r\n\tint err;\r\n\r\n\told_cred = ovl_override_creds(dentry->d_sb);\r\n\terr = ovl_set_redirect(dentry, false);\r\n\tovl_revert_creds(old_cred);\r\n\r\n\treturn err;\r\n}", ".vl_type_origin": "static bool ovl_type_origin(struct dentry *dentry)\r\n{\r\n\treturn OVL_TYPE_ORIGIN(ovl_path_type(dentry));\r\n}", ".vl_matches_upper": "static bool ovl_matches_upper(struct dentry *dentry, struct dentry *upper)\r\n{\r\n\treturn d_inode(ovl_dentry_upper(dentry)) == d_inode(upper);\r\n}", ".vl_cleanup_and_whiteout": "int ovl_cleanup_and_whiteout(struct ovl_fs *ofs, struct dentry *dir,\r\n\t\t\t     struct dentry *dentry)\r\n{\r\n\tstruct dentry *whiteout;\r\n\tint err;\r\n\tint flags = 0;\r\n\r\n\twhiteout = ovl_whiteout(ofs);\r\n\terr = PTR_ERR(whiteout);\r\n\tif (IS_ERR(whiteout))\r\n\t\treturn err;\r\n\r\n\tif (d_is_dir(dentry))\r\n\t\tflags = RENAME_EXCHANGE;\r\n\r\n\terr = ovl_lock_rename_workdir(ofs->workdir, whiteout, dir, dentry);\r\n\tif (!err) {\r\n\t\terr = ovl_do_rename(ofs, ofs->workdir, whiteout, dir, dentry, flags);\r\n\t\tunlock_rename(ofs->workdir, dir);\r\n\t}\r\n\tif (err)\r\n\t\tgoto kill_whiteout;\r\n\tif (flags)\r\n\t\tovl_cleanup(ofs, ofs->workdir, dentry);\r\n\r\nout:\r\n\tdput(whiteout);\r\n\treturn err;\r\n\r\nkill_whiteout:\r\n\tovl_cleanup(ofs, ofs->workdir, whiteout);\r\n\tgoto out;\r\n}", ".vl_pure_upper": "static bool ovl_pure_upper(struct dentry *dentry)\r\n{\r\n\treturn !ovl_dentry_lower(dentry) &&\r\n\t       !ovl_test_flag(OVL_WHITEOUTS, d_inode(dentry));\r\n}", ".vl_remove_upper": "static int ovl_remove_upper(struct dentry *dentry, bool is_dir,\r\n\t\t\t    struct list_head *list)\r\n{\r\n\tstruct ovl_fs *ofs = OVL_FS(dentry->d_sb);\r\n\tstruct dentry *upperdir = ovl_dentry_upper(dentry->d_parent);\r\n\tstruct inode *dir = upperdir->d_inode;\r\n\tstruct dentry *upper;\r\n\tstruct dentry *opaquedir = NULL;\r\n\tint err;\r\n\r\n\tif (!list_empty(list)) {\r\n\t\topaquedir = ovl_clear_empty(dentry, list);\r\n\t\terr = PTR_ERR(opaquedir);\r\n\t\tif (IS_ERR(opaquedir))\r\n\t\t\tgoto out;\r\n\t}\r\n\r\n\tinode_lock_nested(dir, I_MUTEX_PARENT);\r\n\tupper = ovl_lookup_upper(ofs, dentry->d_name.name, upperdir,\r\n\t\t\t\t dentry->d_name.len);\r\n\terr = PTR_ERR(upper);\r\n\tif (IS_ERR(upper))\r\n\t\tgoto out_unlock;\r\n\r\n\terr = -ESTALE;\r\n\tif ((opaquedir && upper != opaquedir) ||\r\n\t    (!opaquedir && !ovl_matches_upper(dentry, upper)))\r\n\t\tgoto out_dput_upper;\r\n\r\n\tif (is_dir)\r\n\t\terr = ovl_do_rmdir(ofs, dir, upper);\r\n\telse\r\n\t\terr = ovl_do_unlink(ofs, dir, upper);\r\n\tovl_dir_modified(dentry->d_parent, ovl_type_origin(dentry));\r\n\r\n\t/*\r\n\t * Keeping this dentry hashed would mean having to release\r\n\t * upperpath/lowerpath, which could only be done if we are the\r\n\t * sole user of this dentry.  Too tricky...  Just unhash for\r\n\t * now.\r\n\t */\r\n\tif (!err)\r\n\t\td_drop(dentry);\r\nout_dput_upper:\r\n\tdput(upper);\r\nout_unlock:\r\n\tinode_unlock(dir);\r\n\tdput(opaquedir);\r\nout:\r\n\treturn err;\r\n}", ".vl_remove_and_whiteout": "static int ovl_remove_and_whiteout(struct dentry *dentry,\r\n\t\t\t\t   struct list_head *list)\r\n{\r\n\tstruct ovl_fs *ofs = OVL_FS(dentry->d_sb);\r\n\tstruct dentry *workdir = ovl_workdir(dentry);\r\n\tstruct dentry *upperdir = ovl_dentry_upper(dentry->d_parent);\r\n\tstruct dentry *upper;\r\n\tstruct dentry *opaquedir = NULL;\r\n\tint err;\r\n\r\n\tif (WARN_ON(!workdir))\r\n\t\treturn -EROFS;\r\n\r\n\tif (!list_empty(list)) {\r\n\t\topaquedir = ovl_clear_empty(dentry, list);\r\n\t\terr = PTR_ERR(opaquedir);\r\n\t\tif (IS_ERR(opaquedir))\r\n\t\t\tgoto out;\r\n\t}\r\n\r\n\tupper = ovl_lookup_upper_unlocked(ofs, dentry->d_name.name, upperdir,\r\n\t\t\t\t\t  dentry->d_name.len);\r\n\terr = PTR_ERR(upper);\r\n\tif (IS_ERR(upper))\r\n\t\tgoto out_dput;\r\n\r\n\terr = -ESTALE;\r\n\tif ((opaquedir && upper != opaquedir) ||\r\n\t    (!opaquedir && ovl_dentry_upper(dentry) &&\r\n\t     !ovl_matches_upper(dentry, upper))) {\r\n\t\tgoto out_dput_upper;\r\n\t}\r\n\r\n\terr = ovl_cleanup_and_whiteout(ofs, upperdir, upper);\r\n\tif (!err)\r\n\t\tovl_dir_modified(dentry->d_parent, true);\r\n\r\n\td_drop(dentry);\r\nout_dput_upper:\r\n\tdput(upper);\r\nout_dput:\r\n\tdput(opaquedir);\r\nout:\r\n\treturn err;\r\n}", ".vl_drop_nlink": "static void ovl_drop_nlink(struct dentry *dentry)\r\n{\r\n\tstruct inode *inode = d_inode(dentry);\r\n\tstruct dentry *alias;\r\n\r\n\t/* Try to find another, hashed alias */\r\n\tspin_lock(&inode->i_lock);\r\n\thlist_for_each_entry(alias, &inode->i_dentry, d_u.d_alias) {\r\n\t\tif (alias != dentry && !d_unhashed(alias))\r\n\t\t\tbreak;\r\n\t}\r\n\tspin_unlock(&inode->i_lock);\r\n\r\n\t/*\r\n\t * Changes to underlying layers may cause i_nlink to lose sync with\r\n\t * reality.  In this case prevent the link count from going to zero\r\n\t * prematurely.\r\n\t */\r\n\tif (inode->i_nlink > !!alias)\r\n\t\tdrop_nlink(inode);\r\n}", ".vl_do_remove": "static int ovl_do_remove(struct dentry *dentry, bool is_dir)\r\n{\r\n\tint err;\r\n\tconst struct cred *old_cred;\r\n\tbool lower_positive = ovl_lower_positive(dentry);\r\n\tLIST_HEAD(list);\r\n\r\n\t/* No need to clean pure upper removed by vfs_rmdir() */\r\n\tif (is_dir && (lower_positive || !ovl_pure_upper(dentry))) {\r\n\t\terr = ovl_check_empty_dir(dentry, &list);\r\n\t\tif (err)\r\n\t\t\tgoto out;\r\n\t}\r\n\r\n\terr = ovl_copy_up(dentry->d_parent);\r\n\tif (err)\r\n\t\tgoto out;\r\n\r\n\terr = ovl_nlink_start(dentry);\r\n\tif (err)\r\n\t\tgoto out;\r\n\r\n\told_cred = ovl_override_creds(dentry->d_sb);\r\n\tif (!lower_positive)\r\n\t\terr = ovl_remove_upper(dentry, is_dir, &list);\r\n\telse\r\n\t\terr = ovl_remove_and_whiteout(dentry, &list);\r\n\tovl_revert_creds(old_cred);\r\n\tif (!err) {\r\n\t\tif (is_dir)\r\n\t\t\tclear_nlink(dentry->d_inode);\r\n\t\telse\r\n\t\t\tovl_drop_nlink(dentry);\r\n\t}\r\n\tovl_nlink_end(dentry);\r\n\r\n\t/*\r\n\t * Copy ctime\r\n\t *\r\n\t * Note: we fail to update ctime if there was no copy-up, only a\r\n\t * whiteout\r\n\t */\r\n\tif (ovl_dentry_upper(dentry))\r\n\t\tovl_copyattr(d_inode(dentry));\r\n\r\nout:\r\n\tovl_cache_free(&list);\r\n\treturn err;\r\n}", ".vl_type_merge_or_lower": "static bool ovl_type_merge_or_lower(struct dentry *dentry)\r\n{\r\n\tenum ovl_path_type type = ovl_path_type(dentry);\r\n\r\n\treturn OVL_TYPE_MERGE(type) || !OVL_TYPE_UPPER(type);\r\n}", ".vl_need_absolute_redirect": "static bool ovl_need_absolute_redirect(struct dentry *dentry, bool samedir)\r\n{\r\n\tstruct dentry *lowerdentry;\r\n\r\n\tif (!samedir)\r\n\t\treturn true;\r\n\r\n\tif (d_is_dir(dentry))\r\n\t\treturn false;\r\n\r\n\t/*\r\n\t * For non-dir hardlinked files, we need absolute redirects\r\n\t * in general as two upper hardlinks could be in different\r\n\t * dirs. We could put a relative redirect now and convert\r\n\t * it to absolute redirect later. But when nlink > 1 and\r\n\t * indexing is on, that means relative redirect needs to be\r\n\t * converted to absolute during copy up of another lower\r\n\t * hardllink as well.\r\n\t *\r\n\t * So without optimizing too much, just check if lower is\r\n\t * a hard link or not. If lower is hard link, put absolute\r\n\t * redirect.\r\n\t */\r\n\tlowerdentry = ovl_dentry_lower(dentry);\r\n\treturn (d_inode(lowerdentry)->i_nlink > 1);\r\n}", ".vl_can_move": "static bool ovl_can_move(struct dentry *dentry)\r\n{\r\n\treturn ovl_redirect_dir(OVL_FS(dentry->d_sb)) ||\r\n\t\t!d_is_dir(dentry) || !ovl_type_merge_or_lower(dentry);\r\n}", ".vl_create_tmpfile": "static int ovl_create_tmpfile(struct file *file, struct dentry *dentry,\r\n\t\t\t      struct inode *inode, umode_t mode)\r\n{\r\n\tconst struct cred *old_cred, *new_cred = NULL;\r\n\tstruct path realparentpath;\r\n\tstruct file *realfile;\r\n\tstruct ovl_file *of;\r\n\tstruct dentry *newdentry;\r\n\t/* It's okay to set O_NOATIME, since the owner will be current fsuid */\r\n\tint flags = file->f_flags | OVL_OPEN_FLAGS;\r\n\tint err;\r\n\r\n\told_cred = ovl_override_creds(dentry->d_sb);\r\n\tnew_cred = ovl_setup_cred_for_create(dentry, inode, mode, old_cred);\r\n\terr = PTR_ERR(new_cred);\r\n\tif (IS_ERR(new_cred)) {\r\n\t\tnew_cred = NULL;\r\n\t\tgoto out_revert_creds;\r\n\t}\r\n\r\n\tovl_path_upper(dentry->d_parent, &realparentpath);\r\n\trealfile = backing_tmpfile_open(&file->f_path, flags, &realparentpath,\r\n\t\t\t\t\tmode, current_cred());\r\n\terr = PTR_ERR_OR_ZERO(realfile);\r\n\tpr_debug(\"tmpfile/open(%pd2, 0%o) = %i\\n\", realparentpath.dentry, mode, err);\r\n\tif (err)\r\n\t\tgoto out_revert_creds;\r\n\r\n\tof = ovl_file_alloc(realfile);\r\n\tif (!of) {\r\n\t\tfput(realfile);\r\n\t\terr = -ENOMEM;\r\n\t\tgoto out_revert_creds;\r\n\t}\r\n\r\n\t/* ovl_instantiate() consumes the newdentry reference on success */\r\n\tnewdentry = dget(realfile->f_path.dentry);\r\n\terr = ovl_instantiate(dentry, inode, newdentry, false, file);\r\n\tif (!err) {\r\n\t\tfile->private_data = of;\r\n\t} else {\r\n\t\tdput(newdentry);\r\n\t\tovl_file_free(of);\r\n\t}\r\nout_revert_creds:\r\n\tovl_revert_creds(old_cred);\r\n\tput_cred(new_cred);\r\n\treturn err;\r\n}", ".vl_dummy_open": "static int ovl_dummy_open(struct inode *inode, struct file *file)\r\n{\r\n\treturn 0;\r\n}"}, "callee": {".vl_cleanup": "int ovl_cleanup(struct ovl_fs *ofs, struct dentry *workdir,\r\n\t\tstruct dentry *wdentry)\r\n{\r\n\tint err;\r\n\r\n\terr = ovl_parent_lock(workdir, wdentry);\r\n\tif (err)\r\n\t\treturn err;\r\n\r\n\tovl_cleanup_locked(ofs, workdir->d_inode, wdentry);\r\n\tovl_parent_unlock(workdir);\r\n\r\n\treturn 0;\r\n}", ".vl_cleanup_and_whiteout": "int ovl_cleanup_and_whiteout(struct ovl_fs *ofs, struct dentry *dir,\r\n\t\t\t     struct dentry *dentry)\r\n{\r\n\tstruct dentry *whiteout;\r\n\tint err;\r\n\tint flags = 0;\r\n\r\n\twhiteout = ovl_whiteout(ofs);\r\n\terr = PTR_ERR(whiteout);\r\n\tif (IS_ERR(whiteout))\r\n\t\treturn err;\r\n\r\n\tif (d_is_dir(dentry))\r\n\t\tflags = RENAME_EXCHANGE;\r\n\r\n\terr = ovl_lock_rename_workdir(ofs->workdir, whiteout, dir, dentry);\r\n\tif (!err) {\r\n\t\terr = ovl_do_rename(ofs, ofs->workdir, whiteout, dir, dentry, flags);\r\n\t\tunlock_rename(ofs->workdir, dir);\r\n\t}\r\n\tif (err)\r\n\t\tgoto kill_whiteout;\r\n\tif (flags)\r\n\t\tovl_cleanup(ofs, ofs->workdir, dentry);\r\n\r\nout:\r\n\tdput(whiteout);\r\n\treturn err;\r\n\r\nkill_whiteout:\r\n\tovl_cleanup(ofs, ofs->workdir, whiteout);\r\n\tgoto out;\r\n}", ".vl_create_upper": "static int ovl_create_upper(struct dentry *dentry, struct inode *inode,\r\n\t\t\t    struct ovl_cattr *attr)\r\n{\r\n\tstruct ovl_fs *ofs = OVL_FS(dentry->d_sb);\r\n\tstruct dentry *upperdir = ovl_dentry_upper(dentry->d_parent);\r\n\tstruct inode *udir = upperdir->d_inode;\r\n\tstruct dentry *newdentry;\r\n\tint err;\r\n\r\n\tinode_lock_nested(udir, I_MUTEX_PARENT);\r\n\tnewdentry = ovl_create_real(ofs, upperdir,\r\n\t\t\t\t    ovl_lookup_upper(ofs, dentry->d_name.name,\r\n\t\t\t\t\t\t     upperdir, dentry->d_name.len),\r\n\t\t\t\t    attr);\r\n\tinode_unlock(udir);\r\n\tif (IS_ERR(newdentry))\r\n\t\treturn PTR_ERR(newdentry);\r\n\r\n\tif (ovl_type_merge(dentry->d_parent) && d_is_dir(newdentry) &&\r\n\t    !ovl_allow_offline_changes(ofs)) {\r\n\t\t/* Setting opaque here is just an optimization, allow to fail */\r\n\t\tovl_set_opaque(dentry, newdentry);\r\n\t}\r\n\r\n\tovl_dir_modified(dentry->d_parent, false);\r\n\terr = ovl_instantiate(dentry, inode, newdentry, !!attr->hardlink, NULL);\r\n\tif (err)\r\n\t\tgoto out_cleanup;\r\n\treturn 0;\r\n\r\nout_cleanup:\r\n\tovl_cleanup(ofs, upperdir, newdentry);\r\n\tdput(newdentry);\r\n\treturn err;\r\n}", ".vl_create_over_whiteout": "static int ovl_create_over_whiteout(struct dentry *dentry, struct inode *inode,\r\n\t\t\t\t    struct ovl_cattr *cattr)\r\n{\r\n\tstruct ovl_fs *ofs = OVL_FS(dentry->d_sb);\r\n\tstruct dentry *workdir = ovl_workdir(dentry);\r\n\tstruct dentry *upperdir = ovl_dentry_upper(dentry->d_parent);\r\n\tstruct dentry *upper;\r\n\tstruct dentry *newdentry;\r\n\tint err;\r\n\tstruct posix_acl *acl, *default_acl;\r\n\tbool hardlink = !!cattr->hardlink;\r\n\r\n\tif (WARN_ON(!workdir))\r\n\t\treturn -EROFS;\r\n\r\n\tif (!hardlink) {\r\n\t\terr = posix_acl_create(dentry->d_parent->d_inode,\r\n\t\t\t\t       &cattr->mode, &default_acl, &acl);\r\n\t\tif (err)\r\n\t\t\treturn err;\r\n\t}\r\n\r\n\tupper = ovl_lookup_upper_unlocked(ofs, dentry->d_name.name, upperdir,\r\n\t\t\t\t\t  dentry->d_name.len);\r\n\terr = PTR_ERR(upper);\r\n\tif (IS_ERR(upper))\r\n\t\tgoto out;\r\n\r\n\terr = -ESTALE;\r\n\tif (d_is_negative(upper) || !ovl_upper_is_whiteout(ofs, upper))\r\n\t\tgoto out_dput;\r\n\r\n\tnewdentry = ovl_create_temp(ofs, workdir, cattr);\r\n\terr = PTR_ERR(newdentry);\r\n\tif (IS_ERR(newdentry))\r\n\t\tgoto out_dput;\r\n\r\n\terr = ovl_lock_rename_workdir(workdir, newdentry, upperdir, upper);\r\n\tif (err)\r\n\t\tgoto out_cleanup_unlocked;\r\n\r\n\t/*\r\n\t * mode could have been mutilated due to umask (e.g. sgid directory)\r\n\t */\r\n\tif (!hardlink &&\r\n\t    !S_ISLNK(cattr->mode) &&\r\n\t    newdentry->d_inode->i_mode != cattr->mode) {\r\n\t\tstruct iattr attr = {\r\n\t\t\t.ia_valid = ATTR_MODE,\r\n\t\t\t.ia_mode = cattr->mode,\r\n\t\t};\r\n\t\tinode_lock(newdentry->d_inode);\r\n\t\terr = ovl_do_notify_change(ofs, newdentry, &attr);\r\n\t\tinode_unlock(newdentry->d_inode);\r\n\t\tif (err)\r\n\t\t\tgoto out_cleanup;\r\n\t}\r\n\tif (!hardlink) {\r\n\t\terr = ovl_set_upper_acl(ofs, newdentry,\r\n\t\t\t\t\tXATTR_NAME_POSIX_ACL_ACCESS, acl);\r\n\t\tif (err)\r\n\t\t\tgoto out_cleanup;\r\n\r\n\t\terr = ovl_set_upper_acl(ofs, newdentry,\r\n\t\t\t\t\tXATTR_NAME_POSIX_ACL_DEFAULT, default_acl);\r\n\t\tif (err)\r\n\t\t\tgoto out_cleanup;\r\n\t}\r\n\r\n\tif (!hardlink && S_ISDIR(cattr->mode)) {\r\n\t\terr = ovl_set_opaque(dentry, newdentry);\r\n\t\tif (err)\r\n\t\t\tgoto out_cleanup;\r\n\r\n\t\terr = ovl_do_rename(ofs, workdir, newdentry, upperdir, upper,\r\n\t\t\t\t    RENAME_EXCHANGE);\r\n\t\tunlock_rename(workdir, upperdir);\r\n\t\tif (err)\r\n\t\t\tgoto out_cleanup_unlocked;\r\n\r\n\t\tovl_cleanup(ofs, workdir, upper);\r\n\t} else {\r\n\t\terr = ovl_do_rename(ofs, workdir, newdentry, upperdir, upper, 0);\r\n\t\tunlock_rename(workdir, upperdir);\r\n\t\tif (err)\r\n\t\t\tgoto out_cleanup_unlocked;\r\n\t}\r\n\tovl_dir_modified(dentry->d_parent, false);\r\n\terr = ovl_instantiate(dentry, inode, newdentry, hardlink, NULL);\r\n\tif (err) {\r\n\t\tovl_cleanup(ofs, upperdir, newdentry);\r\n\t\tdput(newdentry);\r\n\t}\r\nout_dput:\r\n\tdput(upper);\r\nout:\r\n\tif (!hardlink) {\r\n\t\tposix_acl_release(acl);\r\n\t\tposix_acl_release(default_acl);\r\n\t}\r\n\treturn err;\r\n\r\nout_cleanup:\r\n\tunlock_rename(workdir, upperdir);\r\nout_cleanup_unlocked:\r\n\tovl_cleanup(ofs, workdir, newdentry);\r\n\tdput(newdentry);\r\n\tgoto out_dput;\r\n}", ".vl_rename": "static int ovl_rename(struct mnt_idmap *idmap, struct inode *olddir,\r\n\t\t      struct dentry *old, struct inode *newdir,\r\n\t\t      struct dentry *new, unsigned int flags)\r\n{\r\n\tint err;\r\n\tstruct dentry *old_upperdir;\r\n\tstruct dentry *new_upperdir;\r\n\tstruct dentry *olddentry = NULL;\r\n\tstruct dentry *newdentry = NULL;\r\n\tstruct dentry *trap, *de;\r\n\tbool old_opaque;\r\n\tbool new_opaque;\r\n\tbool cleanup_whiteout = false;\r\n\tbool update_nlink = false;\r\n\tbool overwrite = !(flags & RENAME_EXCHANGE);\r\n\tbool is_dir = d_is_dir(old);\r\n\tbool new_is_dir = d_is_dir(new);\r\n\tbool samedir = olddir == newdir;\r\n\tstruct dentry *opaquedir = NULL;\r\n\tconst struct cred *old_cred = NULL;\r\n\tstruct ovl_fs *ofs = OVL_FS(old->d_sb);\r\n\tLIST_HEAD(list);\r\n\r\n\terr = -EINVAL;\r\n\tif (flags & ~(RENAME_EXCHANGE | RENAME_NOREPLACE))\r\n\t\tgoto out;\r\n\r\n\tflags &= ~RENAME_NOREPLACE;\r\n\r\n\t/* Don't copy up directory trees */\r\n\terr = -EXDEV;\r\n\tif (!ovl_can_move(old))\r\n\t\tgoto out;\r\n\tif (!overwrite && !ovl_can_move(new))\r\n\t\tgoto out;\r\n\r\n\tif (overwrite && new_is_dir && !ovl_pure_upper(new)) {\r\n\t\terr = ovl_check_empty_dir(new, &list);\r\n\t\tif (err)\r\n\t\t\tgoto out;\r\n\t}\r\n\r\n\tif (overwrite) {\r\n\t\tif (ovl_lower_positive(old)) {\r\n\t\t\tif (!ovl_dentry_is_whiteout(new)) {\r\n\t\t\t\t/* Whiteout source */\r\n\t\t\t\tflags |= RENAME_WHITEOUT;\r\n\t\t\t} else {\r\n\t\t\t\t/* Switch whiteouts */\r\n\t\t\t\tflags |= RENAME_EXCHANGE;\r\n\t\t\t}\r\n\t\t} else if (is_dir && ovl_dentry_is_whiteout(new)) {\r\n\t\t\tflags |= RENAME_EXCHANGE;\r\n\t\t\tcleanup_whiteout = true;\r\n\t\t}\r\n\t}\r\n\r\n\terr = ovl_copy_up(old);\r\n\tif (err)\r\n\t\tgoto out;\r\n\r\n\terr = ovl_copy_up(new->d_parent);\r\n\tif (err)\r\n\t\tgoto out;\r\n\tif (!overwrite) {\r\n\t\terr = ovl_copy_up(new);\r\n\t\tif (err)\r\n\t\t\tgoto out;\r\n\t} else if (d_inode(new)) {\r\n\t\terr = ovl_nlink_start(new);\r\n\t\tif (err)\r\n\t\t\tgoto out;\r\n\r\n\t\tupdate_nlink = true;\r\n\t}\r\n\r\n\tif (!update_nlink) {\r\n\t\t/* ovl_nlink_start() took ovl_want_write() */\r\n\t\terr = ovl_want_write(old);\r\n\t\tif (err)\r\n\t\t\tgoto out;\r\n\t}\r\n\r\n\told_cred = ovl_override_creds(old->d_sb);\r\n\r\n\tif (!list_empty(&list)) {\r\n\t\topaquedir = ovl_clear_empty(new, &list);\r\n\t\terr = PTR_ERR(opaquedir);\r\n\t\tif (IS_ERR(opaquedir)) {\r\n\t\t\topaquedir = NULL;\r\n\t\t\tgoto out_revert_creds;\r\n\t\t}\r\n\t}\r\n\r\n\told_upperdir = ovl_dentry_upper(old->d_parent);\r\n\tnew_upperdir = ovl_dentry_upper(new->d_parent);\r\n\r\n\tif (!samedir) {\r\n\t\t/*\r\n\t\t * When moving a merge dir or non-dir with copy up origin into\r\n\t\t * a new parent, we are marking the new parent dir \"impure\".\r\n\t\t * When ovl_iterate() iterates an \"impure\" upper dir, it will\r\n\t\t * lookup the origin inodes of the entries to fill d_ino.\r\n\t\t */\r\n\t\tif (ovl_type_origin(old)) {\r\n\t\t\terr = ovl_set_impure(new->d_parent, new_upperdir);\r\n\t\t\tif (err)\r\n\t\t\t\tgoto out_revert_creds;\r\n\t\t}\r\n\t\tif (!overwrite && ovl_type_origin(new)) {\r\n\t\t\terr = ovl_set_impure(old->d_parent, old_upperdir);\r\n\t\t\tif (err)\r\n\t\t\t\tgoto out_revert_creds;\r\n\t\t}\r\n\t}\r\n\r\n\ttrap = lock_rename(new_upperdir, old_upperdir);\r\n\tif (IS_ERR(trap)) {\r\n\t\terr = PTR_ERR(trap);\r\n\t\tgoto out_revert_creds;\r\n\t}\r\n\r\n\tde = ovl_lookup_upper(ofs, old->d_name.name, old_upperdir,\r\n\t\t\t      old->d_name.len);\r\n\terr = PTR_ERR(de);\r\n\tif (IS_ERR(de))\r\n\t\tgoto out_unlock;\r\n\tolddentry = de;\r\n\r\n\terr = -ESTALE;\r\n\tif (!ovl_matches_upper(old, olddentry))\r\n\t\tgoto out_unlock;\r\n\r\n\tde = ovl_lookup_upper(ofs, new->d_name.name, new_upperdir,\r\n\t\t\t      new->d_name.len);\r\n\terr = PTR_ERR(de);\r\n\tif (IS_ERR(de))\r\n\t\tgoto out_unlock;\r\n\tnewdentry = de;\r\n\r\n\told_opaque = ovl_dentry_is_opaque(old);\r\n\tnew_opaque = ovl_dentry_is_opaque(new);\r\n\r\n\terr = -ESTALE;\r\n\tif (d_inode(new) && ovl_dentry_upper(new)) {\r\n\t\tif (opaquedir) {\r\n\t\t\tif (newdentry != opaquedir)\r\n\t\t\t\tgoto out_unlock;\r\n\t\t} else {\r\n\t\t\tif (!ovl_matches_upper(new, newdentry))\r\n\t\t\t\tgoto out_unlock;\r\n\t\t}\r\n\t} else {\r\n\t\tif (!d_is_negative(newdentry)) {\r\n\t\t\tif (!new_opaque || !ovl_upper_is_whiteout(ofs, newdentry))\r\n\t\t\t\tgoto out_unlock;\r\n\t\t} else {\r\n\t\t\tif (flags & RENAME_EXCHANGE)\r\n\t\t\t\tgoto out_unlock;\r\n\t\t}\r\n\t}\r\n\r\n\tif (olddentry == trap)\r\n\t\tgoto out_unlock;\r\n\tif (newdentry == trap)\r\n\t\tgoto out_unlock;\r\n\r\n\tif (olddentry->d_inode == newdentry->d_inode)\r\n\t\tgoto out_unlock;\r\n\r\n\terr = 0;\r\n\tif (ovl_type_merge_or_lower(old))\r\n\t\terr = ovl_set_redirect(old, samedir);\r\n\telse if (is_dir && !old_opaque && ovl_type_merge(new->d_parent))\r\n\t\terr = ovl_set_opaque_xerr(old, olddentry, -EXDEV);\r\n\tif (err)\r\n\t\tgoto out_unlock;\r\n\r\n\tif (!overwrite && ovl_type_merge_or_lower(new))\r\n\t\terr = ovl_set_redirect(new, samedir);\r\n\telse if (!overwrite && new_is_dir && !new_opaque &&\r\n\t\t ovl_type_merge(old->d_parent))\r\n\t\terr = ovl_set_opaque_xerr(new, newdentry, -EXDEV);\r\n\tif (err)\r\n\t\tgoto out_unlock;\r\n\r\n\terr = ovl_do_rename(ofs, old_upperdir, olddentry,\r\n\t\t\t    new_upperdir, newdentry, flags);\r\n\tunlock_rename(new_upperdir, old_upperdir);\r\n\tif (err)\r\n\t\tgoto out_revert_creds;\r\n\r\n\tif (cleanup_whiteout)\r\n\t\tovl_cleanup(ofs, old_upperdir, newdentry);\r\n\r\n\tif (overwrite && d_inode(new)) {\r\n\t\tif (new_is_dir)\r\n\t\t\tclear_nlink(d_inode(new));\r\n\t\telse\r\n\t\t\tovl_drop_nlink(new);\r\n\t}\r\n\r\n\tovl_dir_modified(old->d_parent, ovl_type_origin(old) ||\r\n\t\t\t (!overwrite && ovl_type_origin(new)));\r\n\tovl_dir_modified(new->d_parent, ovl_type_origin(old) ||\r\n\t\t\t (d_inode(new) && ovl_type_origin(new)));\r\n\r\n\t/* copy ctime: */\r\n\tovl_copyattr(d_inode(old));\r\n\tif (d_inode(new) && ovl_dentry_upper(new))\r\n\t\tovl_copyattr(d_inode(new));\r\n\r\nout_revert_creds:\r\n\tovl_revert_creds(old_cred);\r\n\tif (update_nlink)\r\n\t\tovl_nlink_end(new);\r\n\telse\r\n\t\tovl_drop_write(old);\r\nout:\r\n\tdput(newdentry);\r\n\tdput(olddentry);\r\n\tdput(opaquedir);\r\n\tovl_cache_free(&list);\r\n\treturn err;\r\n\r\nout_unlock:\r\n\tunlock_rename(new_upperdir, old_upperdir);\r\n\tgoto out_revert_creds;\r\n}", ".vl_remove_and_whiteout": "static int ovl_remove_and_whiteout(struct dentry *dentry,\r\n\t\t\t\t   struct list_head *list)\r\n{\r\n\tstruct ovl_fs *ofs = OVL_FS(dentry->d_sb);\r\n\tstruct dentry *workdir = ovl_workdir(dentry);\r\n\tstruct dentry *upperdir = ovl_dentry_upper(dentry->d_parent);\r\n\tstruct dentry *upper;\r\n\tstruct dentry *opaquedir = NULL;\r\n\tint err;\r\n\r\n\tif (WARN_ON(!workdir))\r\n\t\treturn -EROFS;\r\n\r\n\tif (!list_empty(list)) {\r\n\t\topaquedir = ovl_clear_empty(dentry, list);\r\n\t\terr = PTR_ERR(opaquedir);\r\n\t\tif (IS_ERR(opaquedir))\r\n\t\t\tgoto out;\r\n\t}\r\n\r\n\tupper = ovl_lookup_upper_unlocked(ofs, dentry->d_name.name, upperdir,\r\n\t\t\t\t\t  dentry->d_name.len);\r\n\terr = PTR_ERR(upper);\r\n\tif (IS_ERR(upper))\r\n\t\tgoto out_dput;\r\n\r\n\terr = -ESTALE;\r\n\tif ((opaquedir && upper != opaquedir) ||\r\n\t    (!opaquedir && ovl_dentry_upper(dentry) &&\r\n\t     !ovl_matches_upper(dentry, upper))) {\r\n\t\tgoto out_dput_upper;\r\n\t}\r\n\r\n\terr = ovl_cleanup_and_whiteout(ofs, upperdir, upper);\r\n\tif (!err)\r\n\t\tovl_dir_modified(dentry->d_parent, true);\r\n\r\n\td_drop(dentry);\r\nout_dput_upper:\r\n\tdput(upper);\r\nout_dput:\r\n\tdput(opaquedir);\r\nout:\r\n\treturn err;\r\n}", ".vl_set_opaque": "static int ovl_set_opaque(struct dentry *dentry, struct dentry *upperdentry)\r\n{\r\n\t/*\r\n\t * Fail with -EIO when trying to create opaque dir and upper doesn't\r\n\t * support xattrs. ovl_rename() calls ovl_set_opaque_xerr(-EXDEV) to\r\n\t * return a specific error for noxattr case.\r\n\t */\r\n\treturn ovl_set_opaque_xerr(dentry, upperdentry, -EIO);\r\n}", ".vl_create_tmpfile": "static int ovl_create_tmpfile(struct file *file, struct dentry *dentry,\r\n\t\t\t      struct inode *inode, umode_t mode)\r\n{\r\n\tconst struct cred *old_cred, *new_cred = NULL;\r\n\tstruct path realparentpath;\r\n\tstruct file *realfile;\r\n\tstruct ovl_file *of;\r\n\tstruct dentry *newdentry;\r\n\t/* It's okay to set O_NOATIME, since the owner will be current fsuid */\r\n\tint flags = file->f_flags | OVL_OPEN_FLAGS;\r\n\tint err;\r\n\r\n\told_cred = ovl_override_creds(dentry->d_sb);\r\n\tnew_cred = ovl_setup_cred_for_create(dentry, inode, mode, old_cred);\r\n\terr = PTR_ERR(new_cred);\r\n\tif (IS_ERR(new_cred)) {\r\n\t\tnew_cred = NULL;\r\n\t\tgoto out_revert_creds;\r\n\t}\r\n\r\n\tovl_path_upper(dentry->d_parent, &realparentpath);\r\n\trealfile = backing_tmpfile_open(&file->f_path, flags, &realparentpath,\r\n\t\t\t\t\tmode, current_cred());\r\n\terr = PTR_ERR_OR_ZERO(realfile);\r\n\tpr_debug(\"tmpfile/open(%pd2, 0%o) = %i\\n\", realparentpath.dentry, mode, err);\r\n\tif (err)\r\n\t\tgoto out_revert_creds;\r\n\r\n\tof = ovl_file_alloc(realfile);\r\n\tif (!of) {\r\n\t\tfput(realfile);\r\n\t\terr = -ENOMEM;\r\n\t\tgoto out_revert_creds;\r\n\t}\r\n\r\n\t/* ovl_instantiate() consumes the newdentry reference on success */\r\n\tnewdentry = dget(realfile->f_path.dentry);\r\n\terr = ovl_instantiate(dentry, inode, newdentry, false, file);\r\n\tif (!err) {\r\n\t\tfile->private_data = of;\r\n\t} else {\r\n\t\tdput(newdentry);\r\n\t\tovl_file_free(of);\r\n\t}\r\nout_revert_creds:\r\n\tovl_revert_creds(old_cred);\r\n\tput_cred(new_cred);\r\n\treturn err;\r\n}", ".vl_can_move": "static bool ovl_can_move(struct dentry *dentry)\r\n{\r\n\treturn ovl_redirect_dir(OVL_FS(dentry->d_sb)) ||\r\n\t\t!d_is_dir(dentry) || !ovl_type_merge_or_lower(dentry);\r\n}", ".vl_link": "static int ovl_link(struct dentry *old, struct inode *newdir,\r\n\t\t    struct dentry *new)\r\n{\r\n\tint err;\r\n\tstruct inode *inode;\r\n\r\n\terr = ovl_copy_up(old);\r\n\tif (err)\r\n\t\tgoto out;\r\n\r\n\terr = ovl_copy_up(new->d_parent);\r\n\tif (err)\r\n\t\tgoto out;\r\n\r\n\terr = ovl_nlink_start(old);\r\n\tif (err)\r\n\t\tgoto out;\r\n\r\n\tif (ovl_is_metacopy_dentry(old)) {\r\n\t\terr = ovl_set_link_redirect(old);\r\n\t\tif (err)\r\n\t\t\tgoto out_nlink_end;\r\n\t}\r\n\r\n\tinode = d_inode(old);\r\n\tihold(inode);\r\n\r\n\terr = ovl_create_or_link(new, inode,\r\n\t\t\t&(struct ovl_cattr) {.hardlink = ovl_dentry_upper(old)},\r\n\t\t\tovl_type_origin(old));\r\n\tif (err)\r\n\t\tiput(inode);\r\n\r\nout_nlink_end:\r\n\tovl_nlink_end(old);\r\nout:\r\n\treturn err;\r\n}", ".vl_remove_upper": "static int ovl_remove_upper(struct dentry *dentry, bool is_dir,\r\n\t\t\t    struct list_head *list)\r\n{\r\n\tstruct ovl_fs *ofs = OVL_FS(dentry->d_sb);\r\n\tstruct dentry *upperdir = ovl_dentry_upper(dentry->d_parent);\r\n\tstruct inode *dir = upperdir->d_inode;\r\n\tstruct dentry *upper;\r\n\tstruct dentry *opaquedir = NULL;\r\n\tint err;\r\n\r\n\tif (!list_empty(list)) {\r\n\t\topaquedir = ovl_clear_empty(dentry, list);\r\n\t\terr = PTR_ERR(opaquedir);\r\n\t\tif (IS_ERR(opaquedir))\r\n\t\t\tgoto out;\r\n\t}\r\n\r\n\tinode_lock_nested(dir, I_MUTEX_PARENT);\r\n\tupper = ovl_lookup_upper(ofs, dentry->d_name.name, upperdir,\r\n\t\t\t\t dentry->d_name.len);\r\n\terr = PTR_ERR(upper);\r\n\tif (IS_ERR(upper))\r\n\t\tgoto out_unlock;\r\n\r\n\terr = -ESTALE;\r\n\tif ((opaquedir && upper != opaquedir) ||\r\n\t    (!opaquedir && !ovl_matches_upper(dentry, upper)))\r\n\t\tgoto out_dput_upper;\r\n\r\n\tif (is_dir)\r\n\t\terr = ovl_do_rmdir(ofs, dir, upper);\r\n\telse\r\n\t\terr = ovl_do_unlink(ofs, dir, upper);\r\n\tovl_dir_modified(dentry->d_parent, ovl_type_origin(dentry));\r\n\r\n\t/*\r\n\t * Keeping this dentry hashed would mean having to release\r\n\t * upperpath/lowerpath, which could only be done if we are the\r\n\t * sole user of this dentry.  Too tricky...  Just unhash for\r\n\t * now.\r\n\t */\r\n\tif (!err)\r\n\t\td_drop(dentry);\r\nout_dput_upper:\r\n\tdput(upper);\r\nout_unlock:\r\n\tinode_unlock(dir);\r\n\tdput(opaquedir);\r\nout:\r\n\treturn err;\r\n}", ".vl_create_or_link": "static int ovl_create_or_link(struct dentry *dentry, struct inode *inode,\r\n\t\t\t      struct ovl_cattr *attr, bool origin)\r\n{\r\n\tint err;\r\n\tconst struct cred *old_cred, *new_cred = NULL;\r\n\tstruct dentry *parent = dentry->d_parent;\r\n\r\n\told_cred = ovl_override_creds(dentry->d_sb);\r\n\r\n\t/*\r\n\t * When linking a file with copy up origin into a new parent, mark the\r\n\t * new parent dir \"impure\".\r\n\t */\r\n\tif (origin) {\r\n\t\terr = ovl_set_impure(parent, ovl_dentry_upper(parent));\r\n\t\tif (err)\r\n\t\t\tgoto out_revert_creds;\r\n\t}\r\n\r\n\tif (!attr->hardlink) {\r\n\t\t/*\r\n\t\t * In the creation cases(create, mkdir, mknod, symlink),\r\n\t\t * ovl should transfer current's fs{u,g}id to underlying\r\n\t\t * fs. Because underlying fs want to initialize its new\r\n\t\t * inode owner using current's fs{u,g}id. And in this\r\n\t\t * case, the @inode is a new inode that is initialized\r\n\t\t * in inode_init_owner() to current's fs{u,g}id. So use\r\n\t\t * the inode's i_{u,g}id to override the cred's fs{u,g}id.\r\n\t\t *\r\n\t\t * But in the other hardlink case, ovl_link() does not\r\n\t\t * create a new inode, so just use the ovl mounter's\r\n\t\t * fs{u,g}id.\r\n\t\t */\r\n\t\tnew_cred = ovl_setup_cred_for_create(dentry, inode, attr->mode,\r\n\t\t\t\t\t\t     old_cred);\r\n\t\terr = PTR_ERR(new_cred);\r\n\t\tif (IS_ERR(new_cred)) {\r\n\t\t\tnew_cred = NULL;\r\n\t\t\tgoto out_revert_creds;\r\n\t\t}\r\n\t}\r\n\r\n\tif (!ovl_dentry_is_whiteout(dentry))\r\n\t\terr = ovl_create_upper(dentry, inode, attr);\r\n\telse\r\n\t\terr = ovl_create_over_whiteout(dentry, inode, attr);\r\n\r\nout_revert_creds:\r\n\tovl_revert_creds(old_cred);\r\n\tput_cred(new_cred);\r\n\treturn err;\r\n}", ".vl_create_object": "static int ovl_create_object(struct dentry *dentry, int mode, dev_t rdev,\r\n\t\t\t     const char *link)\r\n{\r\n\tint err;\r\n\tstruct inode *inode;\r\n\tstruct ovl_cattr attr = {\r\n\t\t.rdev = rdev,\r\n\t\t.link = link,\r\n\t};\r\n\r\n\terr = ovl_copy_up(dentry->d_parent);\r\n\tif (err)\r\n\t\treturn err;\r\n\r\n\terr = ovl_want_write(dentry);\r\n\tif (err)\r\n\t\tgoto out;\r\n\r\n\t/* Preallocate inode to be used by ovl_get_inode() */\r\n\terr = -ENOMEM;\r\n\tinode = ovl_new_inode(dentry->d_sb, mode, rdev);\r\n\tif (!inode)\r\n\t\tgoto out_drop_write;\r\n\r\n\tspin_lock(&inode->i_lock);\r\n\tinode->i_state |= I_CREATING;\r\n\tspin_unlock(&inode->i_lock);\r\n\r\n\tinode_init_owner(&nop_mnt_idmap, inode, dentry->d_parent->d_inode, mode);\r\n\tattr.mode = inode->i_mode;\r\n\r\n\terr = ovl_create_or_link(dentry, inode, &attr, false);\r\n\t/* Did we end up using the preallocated inode? */\r\n\tif (inode != d_inode(dentry))\r\n\t\tiput(inode);\r\n\r\nout_drop_write:\r\n\tovl_drop_write(dentry);\r\nout:\r\n\treturn err;\r\n}", ".vl_create": "static int ovl_create(struct mnt_idmap *idmap, struct inode *dir,\r\n\t\t      struct dentry *dentry, umode_t mode, bool excl)\r\n{\r\n\treturn ovl_create_object(dentry, (mode & 07777) | S_IFREG, 0, NULL);\r\n}", ".vl_mknod": "static int ovl_mknod(struct mnt_idmap *idmap, struct inode *dir,\r\n\t\t     struct dentry *dentry, umode_t mode, dev_t rdev)\r\n{\r\n\t/* Don't allow creation of \"whiteout\" on overlay */\r\n\tif (S_ISCHR(mode) && rdev == WHITEOUT_DEV)\r\n\t\treturn -EPERM;\r\n\r\n\treturn ovl_create_object(dentry, mode, rdev, NULL);\r\n}", ".vl_symlink": "static int ovl_symlink(struct mnt_idmap *idmap, struct inode *dir,\r\n\t\t       struct dentry *dentry, const char *link)\r\n{\r\n\treturn ovl_create_object(dentry, S_IFLNK, 0, link);\r\n}", ".vl_tmpfile": "static int ovl_tmpfile(struct mnt_idmap *idmap, struct inode *dir,\r\n\t\t       struct file *file, umode_t mode)\r\n{\r\n\tint err;\r\n\tstruct dentry *dentry = file->f_path.dentry;\r\n\tstruct inode *inode;\r\n\r\n\tif (!OVL_FS(dentry->d_sb)->tmpfile)\r\n\t\treturn -EOPNOTSUPP;\r\n\r\n\terr = ovl_copy_up(dentry->d_parent);\r\n\tif (err)\r\n\t\treturn err;\r\n\r\n\terr = ovl_want_write(dentry);\r\n\tif (err)\r\n\t\treturn err;\r\n\r\n\terr = -ENOMEM;\r\n\tinode = ovl_new_inode(dentry->d_sb, mode, 0);\r\n\tif (!inode)\r\n\t\tgoto drop_write;\r\n\r\n\tinode_init_owner(&nop_mnt_idmap, inode, dir, mode);\r\n\terr = ovl_create_tmpfile(file, dentry, inode, inode->i_mode);\r\n\tif (err)\r\n\t\tgoto put_inode;\r\n\r\n\t/*\r\n\t * Check if the preallocated inode was actually used.  Having something\r\n\t * else assigned to the dentry shouldn't happen as that would indicate\r\n\t * that the backing tmpfile \"leaked\" out of overlayfs.\r\n\t */\r\n\terr = -EIO;\r\n\tif (WARN_ON(inode != d_inode(dentry)))\r\n\t\tgoto put_realfile;\r\n\r\n\t/* inode reference was transferred to dentry */\r\n\tinode = NULL;\r\n\terr = finish_open(file, dentry, ovl_dummy_open);\r\nput_realfile:\r\n\t/* Without FMODE_OPENED ->release() won't be called on @file */\r\n\tif (!(file->f_mode & FMODE_OPENED))\r\n\t\tovl_file_free(file->private_data);\r\nput_inode:\r\n\tiput(inode);\r\ndrop_write:\r\n\tovl_drop_write(dentry);\r\n\treturn err;\r\n}", ".vl_do_remove": "static int ovl_do_remove(struct dentry *dentry, bool is_dir)\r\n{\r\n\tint err;\r\n\tconst struct cred *old_cred;\r\n\tbool lower_positive = ovl_lower_positive(dentry);\r\n\tLIST_HEAD(list);\r\n\r\n\t/* No need to clean pure upper removed by vfs_rmdir() */\r\n\tif (is_dir && (lower_positive || !ovl_pure_upper(dentry))) {\r\n\t\terr = ovl_check_empty_dir(dentry, &list);\r\n\t\tif (err)\r\n\t\t\tgoto out;\r\n\t}\r\n\r\n\terr = ovl_copy_up(dentry->d_parent);\r\n\tif (err)\r\n\t\tgoto out;\r\n\r\n\terr = ovl_nlink_start(dentry);\r\n\tif (err)\r\n\t\tgoto out;\r\n\r\n\told_cred = ovl_override_creds(dentry->d_sb);\r\n\tif (!lower_positive)\r\n\t\terr = ovl_remove_upper(dentry, is_dir, &list);\r\n\telse\r\n\t\terr = ovl_remove_and_whiteout(dentry, &list);\r\n\tovl_revert_creds(old_cred);\r\n\tif (!err) {\r\n\t\tif (is_dir)\r\n\t\t\tclear_nlink(dentry->d_inode);\r\n\t\telse\r\n\t\t\tovl_drop_nlink(dentry);\r\n\t}\r\n\tovl_nlink_end(dentry);\r\n\r\n\t/*\r\n\t * Copy ctime\r\n\t *\r\n\t * Note: we fail to update ctime if there was no copy-up, only a\r\n\t * whiteout\r\n\t */\r\n\tif (ovl_dentry_upper(dentry))\r\n\t\tovl_copyattr(d_inode(dentry));\r\n\r\nout:\r\n\tovl_cache_free(&list);\r\n\treturn err;\r\n}", ".vl_unlink": "static int ovl_unlink(struct inode *dir, struct dentry *dentry)\r\n{\r\n\treturn ovl_do_remove(dentry, false);\r\n}", ".vl_rmdir": "static int ovl_rmdir(struct inode *dir, struct dentry *dentry)\r\n{\r\n\treturn ovl_do_remove(dentry, true);\r\n}", ".vl_set_redirect": "static int ovl_set_redirect(struct dentry *dentry, bool samedir)\r\n{\r\n\tint err;\r\n\tstruct ovl_fs *ofs = OVL_FS(dentry->d_sb);\r\n\tconst char *redirect = ovl_dentry_get_redirect(dentry);\r\n\tbool absolute_redirect = ovl_need_absolute_redirect(dentry, samedir);\r\n\r\n\tif (redirect && (!absolute_redirect || redirect[0] == '/'))\r\n\t\treturn 0;\r\n\r\n\tredirect = ovl_get_redirect(dentry, absolute_redirect);\r\n\tif (IS_ERR(redirect))\r\n\t\treturn PTR_ERR(redirect);\r\n\r\n\terr = ovl_check_setxattr(ofs, ovl_dentry_upper(dentry),\r\n\t\t\t\t OVL_XATTR_REDIRECT,\r\n\t\t\t\t redirect, strlen(redirect), -EXDEV);\r\n\tif (!err) {\r\n\t\tspin_lock(&dentry->d_lock);\r\n\t\tovl_dentry_set_redirect(dentry, redirect);\r\n\t\tspin_unlock(&dentry->d_lock);\r\n\t} else {\r\n\t\tkfree(redirect);\r\n\t\tpr_warn_ratelimited(\"failed to set redirect (%i)\\n\",\r\n\t\t\t\t    err);\r\n\t\t/* Fall back to userspace copy-up */\r\n\t\terr = -EXDEV;\r\n\t}\r\n\treturn err;\r\n}", ".vl_set_link_redirect": "static int ovl_set_link_redirect(struct dentry *dentry)\r\n{\r\n\tconst struct cred *old_cred;\r\n\tint err;\r\n\r\n\told_cred = ovl_override_creds(dentry->d_sb);\r\n\terr = ovl_set_redirect(dentry, false);\r\n\tovl_revert_creds(old_cred);\r\n\r\n\treturn err;\r\n}"}, "function_name": "ovl_tmpfile"}
{"function_id": null, "caller": {".octl_file_clone": "static int ioctl_file_clone(struct file *dst_file, unsigned long srcfd,\r\n\t\t\t    u64 off, u64 olen, u64 destoff)\r\n{\r\n\tCLASS(fd, src_file)(srcfd);\r\n\tloff_t cloned;\r\n\tint ret;\r\n\r\n\tif (fd_empty(src_file))\r\n\t\treturn -EBADF;\r\n\tcloned = vfs_clone_file_range(fd_file(src_file), off, dst_file, destoff,\r\n\t\t\t\t      olen, 0);\r\n\tif (cloned < 0)\r\n\t\tret = cloned;\r\n\telse if (olen && cloned != olen)\r\n\t\tret = -EINVAL;\r\n\telse\r\n\t\tret = 0;\r\n\treturn ret;\r\n}", ".octl_fibmap": "static int ioctl_fibmap(struct file *filp, int __user *p)\r\n{\r\n\tstruct inode *inode = file_inode(filp);\r\n\tstruct super_block *sb = inode->i_sb;\r\n\tint error, ur_block;\r\n\tsector_t block;\r\n\r\n\tif (!capable(CAP_SYS_RAWIO))\r\n\t\treturn -EPERM;\r\n\r\n\terror = get_user(ur_block, p);\r\n\tif (error)\r\n\t\treturn error;\r\n\r\n\tif (ur_block < 0)\r\n\t\treturn -EINVAL;\r\n\r\n\tblock = ur_block;\r\n\terror = bmap(inode, &block);\r\n\r\n\tif (block > INT_MAX) {\r\n\t\terror = -ERANGE;\r\n\t\tpr_warn_ratelimited(\"[%s/%d] FS: %s File: %pD4 would truncate fibmap result\\n\",\r\n\t\t\t\t    current->comm, task_pid_nr(current),\r\n\t\t\t\t    sb->s_id, filp);\r\n\t}\r\n\r\n\tif (error)\r\n\t\tur_block = 0;\r\n\telse\r\n\t\tur_block = block;\r\n\r\n\tif (put_user(ur_block, p))\r\n\t\terror = -EFAULT;\r\n\r\n\treturn error;\r\n}", ".octl_preallocate": "static int ioctl_preallocate(struct file *filp, int mode, void __user *argp)\r\n{\r\n\tstruct inode *inode = file_inode(filp);\r\n\tstruct space_resv sr;\r\n\r\n\tif (copy_from_user(&sr, argp, sizeof(sr)))\r\n\t\treturn -EFAULT;\r\n\r\n\tswitch (sr.l_whence) {\r\n\tcase SEEK_SET:\r\n\t\tbreak;\r\n\tcase SEEK_CUR:\r\n\t\tsr.l_start += filp->f_pos;\r\n\t\tbreak;\r\n\tcase SEEK_END:\r\n\t\tsr.l_start += i_size_read(inode);\r\n\t\tbreak;\r\n\tdefault:\r\n\t\treturn -EINVAL;\r\n\t}\r\n\r\n\treturn vfs_fallocate(filp, mode | FALLOC_FL_KEEP_SIZE, sr.l_start,\r\n\t\t\tsr.l_len);\r\n}", ".octl_fionbio": "static int ioctl_fionbio(struct file *filp, int __user *argp)\r\n{\r\n\tunsigned int flag;\r\n\tint on, error;\r\n\r\n\terror = get_user(on, argp);\r\n\tif (error)\r\n\t\treturn error;\r\n\tflag = O_NONBLOCK;\r\n#ifdef __sparc__\r\n\t/* SunOS compatibility item. */\r\n\tif (O_NONBLOCK != O_NDELAY)\r\n\t\tflag |= O_NDELAY;\r\n#endif\r\n\tspin_lock(&filp->f_lock);\r\n\tif (on)\r\n\t\tfilp->f_flags |= flag;\r\n\telse\r\n\t\tfilp->f_flags &= ~flag;\r\n\tspin_unlock(&filp->f_lock);\r\n\treturn error;\r\n}", ".octl_fioasync": "static int ioctl_fioasync(unsigned int fd, struct file *filp,\r\n\t\t\t  int __user *argp)\r\n{\r\n\tunsigned int flag;\r\n\tint on, error;\r\n\r\n\terror = get_user(on, argp);\r\n\tif (error)\r\n\t\treturn error;\r\n\tflag = on ? FASYNC : 0;\r\n\r\n\t/* Did FASYNC state change ? */\r\n\tif ((flag ^ filp->f_flags) & FASYNC) {\r\n\t\tif (filp->f_op->fasync)\r\n\t\t\t/* fasync() adjusts filp->f_flags */\r\n\t\t\terror = filp->f_op->fasync(fd, filp, on);\r\n\t\telse\r\n\t\t\terror = -ENOTTY;\r\n\t}\r\n\treturn error < 0 ? error : 0;\r\n}", ".octl_fsfreeze": "static int ioctl_fsfreeze(struct file *filp)\r\n{\r\n\tstruct super_block *sb = file_inode(filp)->i_sb;\r\n\r\n\tif (!ns_capable(sb->s_user_ns, CAP_SYS_ADMIN))\r\n\t\treturn -EPERM;\r\n\r\n\t/* If filesystem doesn't support freeze feature, return. */\r\n\tif (sb->s_op->freeze_fs == NULL && sb->s_op->freeze_super == NULL)\r\n\t\treturn -EOPNOTSUPP;\r\n\r\n\t/* Freeze */\r\n\tif (sb->s_op->freeze_super)\r\n\t\treturn sb->s_op->freeze_super(sb, FREEZE_HOLDER_USERSPACE, NULL);\r\n\treturn freeze_super(sb, FREEZE_HOLDER_USERSPACE, NULL);\r\n}", ".octl_fsthaw": "static int ioctl_fsthaw(struct file *filp)\r\n{\r\n\tstruct super_block *sb = file_inode(filp)->i_sb;\r\n\r\n\tif (!ns_capable(sb->s_user_ns, CAP_SYS_ADMIN))\r\n\t\treturn -EPERM;\r\n\r\n\t/* Thaw */\r\n\tif (sb->s_op->thaw_super)\r\n\t\treturn sb->s_op->thaw_super(sb, FREEZE_HOLDER_USERSPACE, NULL);\r\n\treturn thaw_super(sb, FREEZE_HOLDER_USERSPACE, NULL);\r\n}", ".octl_fiemap": "static int ioctl_fiemap(struct file *filp, struct fiemap __user *ufiemap)\r\n{\r\n\tstruct fiemap fiemap;\r\n\tstruct fiemap_extent_info fieinfo = { 0, };\r\n\tstruct inode *inode = file_inode(filp);\r\n\tint error;\r\n\r\n\tif (!inode->i_op->fiemap)\r\n\t\treturn -EOPNOTSUPP;\r\n\r\n\tif (copy_from_user(&fiemap, ufiemap, sizeof(fiemap)))\r\n\t\treturn -EFAULT;\r\n\r\n\tif (fiemap.fm_extent_count > FIEMAP_MAX_EXTENTS)\r\n\t\treturn -EINVAL;\r\n\r\n\tfieinfo.fi_flags = fiemap.fm_flags;\r\n\tfieinfo.fi_extents_max = fiemap.fm_extent_count;\r\n\tfieinfo.fi_extents_start = ufiemap->fm_extents;\r\n\r\n\terror = inode->i_op->fiemap(inode, &fieinfo, fiemap.fm_start,\r\n\t\t\tfiemap.fm_length);\r\n\r\n\tfiemap.fm_flags = fieinfo.fi_flags;\r\n\tfiemap.fm_mapped_extents = fieinfo.fi_extents_mapped;\r\n\tif (copy_to_user(ufiemap, &fiemap, sizeof(fiemap)))\r\n\t\terror = -EFAULT;\r\n\r\n\treturn error;\r\n}", ".octl_file_clone_range": "static int ioctl_file_clone_range(struct file *file,\r\n\t\t\t\t  struct file_clone_range __user *argp)\r\n{\r\n\tstruct file_clone_range args;\r\n\r\n\tif (copy_from_user(&args, argp, sizeof(args)))\r\n\t\treturn -EFAULT;\r\n\treturn ioctl_file_clone(file, args.src_fd, args.src_offset,\r\n\t\t\t\targs.src_length, args.dest_offset);\r\n}", ".octl_file_dedupe_range": "static int ioctl_file_dedupe_range(struct file *file,\r\n\t\t\t\t   struct file_dedupe_range __user *argp)\r\n{\r\n\tstruct file_dedupe_range *same = NULL;\r\n\tint ret;\r\n\tunsigned long size;\r\n\tu16 count;\r\n\r\n\tif (get_user(count, &argp->dest_count)) {\r\n\t\tret = -EFAULT;\r\n\t\tgoto out;\r\n\t}\r\n\r\n\tsize = struct_size(same, info, count);\r\n\tif (size > PAGE_SIZE) {\r\n\t\tret = -ENOMEM;\r\n\t\tgoto out;\r\n\t}\r\n\r\n\tsame = memdup_user(argp, size);\r\n\tif (IS_ERR(same)) {\r\n\t\tret = PTR_ERR(same);\r\n\t\tsame = NULL;\r\n\t\tgoto out;\r\n\t}\r\n\r\n\tsame->dest_count = count;\r\n\tret = vfs_dedupe_file_range(file, same);\r\n\tif (ret)\r\n\t\tgoto out;\r\n\r\n\tret = copy_to_user(argp, same, size);\r\n\tif (ret)\r\n\t\tret = -EFAULT;\r\n\r\nout:\r\n\tkfree(same);\r\n\treturn ret;\r\n}", ".fs_ioctl": "int vfs_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\r\n{\r\n\tint error = -ENOTTY;\r\n\r\n\tif (!filp->f_op->unlocked_ioctl)\r\n\t\tgoto out;\r\n\r\n\terror = filp->f_op->unlocked_ioctl(filp, cmd, arg);\r\n\tif (error == -ENOIOCTLCMD)\r\n\t\terror = -ENOTTY;\r\n out:\r\n\treturn error;\r\n}", ".octl_getfsuuid": "static int ioctl_getfsuuid(struct file *file, void __user *argp)\r\n{\r\n\tstruct super_block *sb = file_inode(file)->i_sb;\r\n\tstruct fsuuid2 u = { .len = sb->s_uuid_len, };\r\n\r\n\tif (!sb->s_uuid_len)\r\n\t\treturn -ENOTTY;\r\n\r\n\tmemcpy(&u.uuid[0], &sb->s_uuid, sb->s_uuid_len);\r\n\r\n\treturn copy_to_user(argp, &u, sizeof(u)) ? -EFAULT : 0;\r\n}", ".octl_get_fs_sysfs_path": "static int ioctl_get_fs_sysfs_path(struct file *file, void __user *argp)\r\n{\r\n\tstruct super_block *sb = file_inode(file)->i_sb;\r\n\r\n\tif (!strlen(sb->s_sysfs_name))\r\n\t\treturn -ENOTTY;\r\n\r\n\tstruct fs_sysfs_path u = {};\r\n\r\n\tu.len = scnprintf(u.name, sizeof(u.name), \"%s/%s\", sb->s_type->name, sb->s_sysfs_name);\r\n\r\n\treturn copy_to_user(argp, &u, sizeof(u)) ? -EFAULT : 0;\r\n}", ".ile_ioctl": "static int file_ioctl(struct file *filp, unsigned int cmd, int __user *p)\r\n{\r\n\tswitch (cmd) {\r\n\tcase FIBMAP:\r\n\t\treturn ioctl_fibmap(filp, p);\r\n\tcase FS_IOC_RESVSP:\r\n\tcase FS_IOC_RESVSP64:\r\n\t\treturn ioctl_preallocate(filp, 0, p);\r\n\tcase FS_IOC_UNRESVSP:\r\n\tcase FS_IOC_UNRESVSP64:\r\n\t\treturn ioctl_preallocate(filp, FALLOC_FL_PUNCH_HOLE, p);\r\n\tcase FS_IOC_ZERO_RANGE:\r\n\t\treturn ioctl_preallocate(filp, FALLOC_FL_ZERO_RANGE, p);\r\n\t}\r\n\r\n\treturn -ENOIOCTLCMD;\r\n}"}, "callee": {".o_vfs_ioctl": "static int do_vfs_ioctl(struct file *filp, unsigned int fd,\r\n\t\t\tunsigned int cmd, unsigned long arg)\r\n{\r\n\tvoid __user *argp = (void __user *)arg;\r\n\tstruct inode *inode = file_inode(filp);\r\n\r\n\tswitch (cmd) {\r\n\tcase FIOCLEX:\r\n\t\tset_close_on_exec(fd, 1);\r\n\t\treturn 0;\r\n\r\n\tcase FIONCLEX:\r\n\t\tset_close_on_exec(fd, 0);\r\n\t\treturn 0;\r\n\r\n\tcase FIONBIO:\r\n\t\treturn ioctl_fionbio(filp, argp);\r\n\r\n\tcase FIOASYNC:\r\n\t\treturn ioctl_fioasync(fd, filp, argp);\r\n\r\n\tcase FIOQSIZE:\r\n\t\tif (S_ISDIR(inode->i_mode) ||\r\n\t\t    (S_ISREG(inode->i_mode) && !IS_ANON_FILE(inode)) ||\r\n\t\t    S_ISLNK(inode->i_mode)) {\r\n\t\t\tloff_t res = inode_get_bytes(inode);\r\n\t\t\treturn copy_to_user(argp, &res, sizeof(res)) ?\r\n\t\t\t\t\t    -EFAULT : 0;\r\n\t\t}\r\n\r\n\t\treturn -ENOTTY;\r\n\r\n\tcase FIFREEZE:\r\n\t\treturn ioctl_fsfreeze(filp);\r\n\r\n\tcase FITHAW:\r\n\t\treturn ioctl_fsthaw(filp);\r\n\r\n\tcase FS_IOC_FIEMAP:\r\n\t\treturn ioctl_fiemap(filp, argp);\r\n\r\n\tcase FIGETBSZ:\r\n\t\t/* anon_bdev filesystems may not have a block size */\r\n\t\tif (!inode->i_sb->s_blocksize)\r\n\t\t\treturn -EINVAL;\r\n\r\n\t\treturn put_user(inode->i_sb->s_blocksize, (int __user *)argp);\r\n\r\n\tcase FICLONE:\r\n\t\treturn ioctl_file_clone(filp, arg, 0, 0, 0);\r\n\r\n\tcase FICLONERANGE:\r\n\t\treturn ioctl_file_clone_range(filp, argp);\r\n\r\n\tcase FIDEDUPERANGE:\r\n\t\treturn ioctl_file_dedupe_range(filp, argp);\r\n\r\n\tcase FIONREAD:\r\n\t\tif (!S_ISREG(inode->i_mode) || IS_ANON_FILE(inode))\r\n\t\t\treturn vfs_ioctl(filp, cmd, arg);\r\n\r\n\t\treturn put_user(i_size_read(inode) - filp->f_pos,\r\n\t\t\t\t(int __user *)argp);\r\n\r\n\tcase FS_IOC_GETFLAGS:\r\n\t\treturn ioctl_getflags(filp, argp);\r\n\r\n\tcase FS_IOC_SETFLAGS:\r\n\t\treturn ioctl_setflags(filp, argp);\r\n\r\n\tcase FS_IOC_FSGETXATTR:\r\n\t\treturn ioctl_fsgetxattr(filp, argp);\r\n\r\n\tcase FS_IOC_FSSETXATTR:\r\n\t\treturn ioctl_fssetxattr(filp, argp);\r\n\r\n\tcase FS_IOC_GETFSUUID:\r\n\t\treturn ioctl_getfsuuid(filp, argp);\r\n\r\n\tcase FS_IOC_GETFSSYSFSPATH:\r\n\t\treturn ioctl_get_fs_sysfs_path(filp, argp);\r\n\r\n\tdefault:\r\n\t\tif (S_ISREG(inode->i_mode) && !IS_ANON_FILE(inode))\r\n\t\t\treturn file_ioctl(filp, cmd, argp);\r\n\t\tbreak;\r\n\t}\r\n\r\n\treturn -ENOIOCTLCMD;\r\n}", ".ile_ioctl": "static int file_ioctl(struct file *filp, unsigned int cmd, int __user *p)\r\n{\r\n\tswitch (cmd) {\r\n\tcase FIBMAP:\r\n\t\treturn ioctl_fibmap(filp, p);\r\n\tcase FS_IOC_RESVSP:\r\n\tcase FS_IOC_RESVSP64:\r\n\t\treturn ioctl_preallocate(filp, 0, p);\r\n\tcase FS_IOC_UNRESVSP:\r\n\tcase FS_IOC_UNRESVSP64:\r\n\t\treturn ioctl_preallocate(filp, FALLOC_FL_PUNCH_HOLE, p);\r\n\tcase FS_IOC_ZERO_RANGE:\r\n\t\treturn ioctl_preallocate(filp, FALLOC_FL_ZERO_RANGE, p);\r\n\t}\r\n\r\n\treturn -ENOIOCTLCMD;\r\n}", ".octl_file_clone_range": "static int ioctl_file_clone_range(struct file *file,\r\n\t\t\t\t  struct file_clone_range __user *argp)\r\n{\r\n\tstruct file_clone_range args;\r\n\r\n\tif (copy_from_user(&args, argp, sizeof(args)))\r\n\t\treturn -EFAULT;\r\n\treturn ioctl_file_clone(file, args.src_fd, args.src_offset,\r\n\t\t\t\targs.src_length, args.dest_offset);\r\n}"}, "function_name": "compat_ptr_ioctl"}
{"function_id": null, "caller": {".o_truncate": "int do_truncate(struct mnt_idmap *idmap, struct dentry *dentry,\r\n\t\tloff_t length, unsigned int time_attrs, struct file *filp)\r\n{\r\n\tint ret;\r\n\tstruct iattr newattrs;\r\n\r\n\t/* Not pretty: \"inode->i_size\" shouldn't really be signed. But it is. */\r\n\tif (length < 0)\r\n\t\treturn -EINVAL;\r\n\r\n\tnewattrs.ia_size = length;\r\n\tnewattrs.ia_valid = ATTR_SIZE | time_attrs;\r\n\tif (filp) {\r\n\t\tnewattrs.ia_file = filp;\r\n\t\tnewattrs.ia_valid |= ATTR_FILE;\r\n\t}\r\n\r\n\t/* Remove suid, sgid, and file capabilities on truncate too */\r\n\tret = dentry_needs_remove_privs(idmap, dentry);\r\n\tif (ret < 0)\r\n\t\treturn ret;\r\n\tif (ret)\r\n\t\tnewattrs.ia_valid |= ret | ATTR_FORCE;\r\n\r\n\tret = inode_lock_killable(dentry->d_inode);\r\n\tif (ret)\r\n\t\treturn ret;\r\n\r\n\t/* Note any delegations or leases have already been broken: */\r\n\tret = notify_change(idmap, dentry, &newattrs, NULL);\r\n\tinode_unlock(dentry->d_inode);\r\n\treturn ret;\r\n}", ".fs_truncate": "int vfs_truncate(const struct path *path, loff_t length)\r\n{\r\n\tstruct mnt_idmap *idmap;\r\n\tstruct inode *inode;\r\n\tint error;\r\n\r\n\tinode = path->dentry->d_inode;\r\n\r\n\t/* For directories it's -EISDIR, for other non-regulars - -EINVAL */\r\n\tif (S_ISDIR(inode->i_mode))\r\n\t\treturn -EISDIR;\r\n\tif (!S_ISREG(inode->i_mode))\r\n\t\treturn -EINVAL;\r\n\r\n\tidmap = mnt_idmap(path->mnt);\r\n\terror = inode_permission(idmap, inode, MAY_WRITE);\r\n\tif (error)\r\n\t\treturn error;\r\n\r\n\terror = fsnotify_truncate_perm(path, length);\r\n\tif (error)\r\n\t\treturn error;\r\n\r\n\terror = mnt_want_write(path->mnt);\r\n\tif (error)\r\n\t\treturn error;\r\n\r\n\terror = -EPERM;\r\n\tif (IS_APPEND(inode))\r\n\t\tgoto mnt_drop_write_and_out;\r\n\r\n\terror = get_write_access(inode);\r\n\tif (error)\r\n\t\tgoto mnt_drop_write_and_out;\r\n\r\n\t/*\r\n\t * Make sure that there are no leases.  get_write_access() protects\r\n\t * against the truncate racing with a lease-granting setlease().\r\n\t */\r\n\terror = break_lease(inode, O_WRONLY);\r\n\tif (error)\r\n\t\tgoto put_write_and_out;\r\n\r\n\terror = security_path_truncate(path);\r\n\tif (!error)\r\n\t\terror = do_truncate(idmap, path->dentry, length, 0, NULL);\r\n\r\nput_write_and_out:\r\n\tput_write_access(inode);\r\nmnt_drop_write_and_out:\r\n\tmnt_drop_write(path->mnt);\r\n\r\n\treturn error;\r\n}", ".o_ftruncate": "int do_ftruncate(struct file *file, loff_t length, int small)\r\n{\r\n\tstruct inode *inode;\r\n\tstruct dentry *dentry;\r\n\tint error;\r\n\r\n\t/* explicitly opened as large or we are on 64-bit box */\r\n\tif (file->f_flags & O_LARGEFILE)\r\n\t\tsmall = 0;\r\n\r\n\tdentry = file->f_path.dentry;\r\n\tinode = dentry->d_inode;\r\n\tif (!S_ISREG(inode->i_mode) || !(file->f_mode & FMODE_WRITE))\r\n\t\treturn -EINVAL;\r\n\r\n\t/* Cannot ftruncate over 2^31 bytes without large file support */\r\n\tif (small && length > MAX_NON_LFS)\r\n\t\treturn -EINVAL;\r\n\r\n\t/* Check IS_APPEND on real upper inode */\r\n\tif (IS_APPEND(file_inode(file)))\r\n\t\treturn -EPERM;\r\n\r\n\terror = security_file_truncate(file);\r\n\tif (error)\r\n\t\treturn error;\r\n\r\n\terror = fsnotify_truncate_perm(&file->f_path, length);\r\n\tif (error)\r\n\t\treturn error;\r\n\r\n\tsb_start_write(inode->i_sb);\r\n\terror = do_truncate(file_mnt_idmap(file), dentry, length,\r\n\t\t\t    ATTR_MTIME | ATTR_CTIME, file);\r\n\tsb_end_write(inode->i_sb);\r\n\r\n\treturn error;\r\n}", ".fs_fallocate": "int vfs_fallocate(struct file *file, int mode, loff_t offset, loff_t len)\r\n{\r\n\tstruct inode *inode = file_inode(file);\r\n\tint ret;\r\n\tloff_t sum;\r\n\r\n\tif (offset < 0 || len <= 0)\r\n\t\treturn -EINVAL;\r\n\r\n\tif (mode & ~(FALLOC_FL_MODE_MASK | FALLOC_FL_KEEP_SIZE))\r\n\t\treturn -EOPNOTSUPP;\r\n\r\n\t/*\r\n\t * Modes are exclusive, even if that is not obvious from the encoding\r\n\t * as bit masks and the mix with the flag in the same namespace.\r\n\t *\r\n\t * To make things even more complicated, FALLOC_FL_ALLOCATE_RANGE is\r\n\t * encoded as no bit set.\r\n\t */\r\n\tswitch (mode & FALLOC_FL_MODE_MASK) {\r\n\tcase FALLOC_FL_ALLOCATE_RANGE:\r\n\tcase FALLOC_FL_UNSHARE_RANGE:\r\n\tcase FALLOC_FL_ZERO_RANGE:\r\n\t\tbreak;\r\n\tcase FALLOC_FL_PUNCH_HOLE:\r\n\t\tif (!(mode & FALLOC_FL_KEEP_SIZE))\r\n\t\t\treturn -EOPNOTSUPP;\r\n\t\tbreak;\r\n\tcase FALLOC_FL_COLLAPSE_RANGE:\r\n\tcase FALLOC_FL_INSERT_RANGE:\r\n\tcase FALLOC_FL_WRITE_ZEROES:\r\n\t\tif (mode & FALLOC_FL_KEEP_SIZE)\r\n\t\t\treturn -EOPNOTSUPP;\r\n\t\tbreak;\r\n\tdefault:\r\n\t\treturn -EOPNOTSUPP;\r\n\t}\r\n\r\n\tif (!(file->f_mode & FMODE_WRITE))\r\n\t\treturn -EBADF;\r\n\r\n\t/*\r\n\t * On append-only files only space preallocation is supported.\r\n\t */\r\n\tif ((mode & ~FALLOC_FL_KEEP_SIZE) && IS_APPEND(inode))\r\n\t\treturn -EPERM;\r\n\r\n\tif (IS_IMMUTABLE(inode))\r\n\t\treturn -EPERM;\r\n\r\n\t/*\r\n\t * We cannot allow any fallocate operation on an active swapfile\r\n\t */\r\n\tif (IS_SWAPFILE(inode))\r\n\t\treturn -ETXTBSY;\r\n\r\n\t/*\r\n\t * Revalidate the write permissions, in case security policy has\r\n\t * changed since the files were opened.\r\n\t */\r\n\tret = security_file_permission(file, MAY_WRITE);\r\n\tif (ret)\r\n\t\treturn ret;\r\n\r\n\tret = fsnotify_file_area_perm(file, MAY_WRITE, &offset, len);\r\n\tif (ret)\r\n\t\treturn ret;\r\n\r\n\tif (S_ISFIFO(inode->i_mode))\r\n\t\treturn -ESPIPE;\r\n\r\n\tif (S_ISDIR(inode->i_mode))\r\n\t\treturn -EISDIR;\r\n\r\n\tif (!S_ISREG(inode->i_mode) && !S_ISBLK(inode->i_mode))\r\n\t\treturn -ENODEV;\r\n\r\n\t/* Check for wraparound */\r\n\tif (check_add_overflow(offset, len, &sum))\r\n\t\treturn -EFBIG;\r\n\r\n\tif (sum > inode->i_sb->s_maxbytes)\r\n\t\treturn -EFBIG;\r\n\r\n\tif (!file->f_op->fallocate)\r\n\t\treturn -EOPNOTSUPP;\r\n\r\n\tfile_start_write(file);\r\n\tret = file->f_op->fallocate(file, mode, offset, len);\r\n\r\n\t/*\r\n\t * Create inotify and fanotify events.\r\n\t *\r\n\t * To keep the logic simple always create events if fallocate succeeds.\r\n\t * This implies that events are even created if the file size remains\r\n\t * unchanged, e.g. when using flag FALLOC_FL_KEEP_SIZE.\r\n\t */\r\n\tif (ret == 0)\r\n\t\tfsnotify_modify(file);\r\n\r\n\tfile_end_write(file);\r\n\treturn ret;\r\n}", ".ccess_need_override_creds": "static bool access_need_override_creds(int flags)\r\n{\r\n\tconst struct cred *cred;\r\n\r\n\tif (flags & AT_EACCESS)\r\n\t\treturn false;\r\n\r\n\tcred = current_cred();\r\n\tif (!uid_eq(cred->fsuid, cred->uid) ||\r\n\t    !gid_eq(cred->fsgid, cred->gid))\r\n\t\treturn true;\r\n\r\n\tif (!issecure(SECURE_NO_SETUID_FIXUP)) {\r\n\t\tkuid_t root_uid = make_kuid(cred->user_ns, 0);\r\n\t\tif (!uid_eq(cred->uid, root_uid)) {\r\n\t\t\tif (!cap_isclear(cred->cap_effective))\r\n\t\t\t\treturn true;\r\n\t\t} else {\r\n\t\t\tif (!cap_isidentical(cred->cap_effective,\r\n\t\t\t    cred->cap_permitted))\r\n\t\t\t\treturn true;\r\n\t\t}\r\n\t}\r\n\r\n\treturn false;\r\n}", ".hmod_common": "int chmod_common(const struct path *path, umode_t mode)\r\n{\r\n\tstruct inode *inode = path->dentry->d_inode;\r\n\tstruct inode *delegated_inode = NULL;\r\n\tstruct iattr newattrs;\r\n\tint error;\r\n\r\n\terror = mnt_want_write(path->mnt);\r\n\tif (error)\r\n\t\treturn error;\r\nretry_deleg:\r\n\terror = inode_lock_killable(inode);\r\n\tif (error)\r\n\t\tgoto out_mnt_unlock;\r\n\terror = security_path_chmod(path, mode);\r\n\tif (error)\r\n\t\tgoto out_unlock;\r\n\tnewattrs.ia_mode = (mode & S_IALLUGO) | (inode->i_mode & ~S_IALLUGO);\r\n\tnewattrs.ia_valid = ATTR_MODE | ATTR_CTIME;\r\n\terror = notify_change(mnt_idmap(path->mnt), path->dentry,\r\n\t\t\t      &newattrs, &delegated_inode);\r\nout_unlock:\r\n\tinode_unlock(inode);\r\n\tif (delegated_inode) {\r\n\t\terror = break_deleg_wait(&delegated_inode);\r\n\t\tif (!error)\r\n\t\t\tgoto retry_deleg;\r\n\t}\r\nout_mnt_unlock:\r\n\tmnt_drop_write(path->mnt);\r\n\treturn error;\r\n}", ".etattr_vfsuid": "static inline bool setattr_vfsuid(struct iattr *attr, kuid_t kuid)\r\n{\r\n\tif (!uid_valid(kuid))\r\n\t\treturn false;\r\n\tattr->ia_valid |= ATTR_UID;\r\n\tattr->ia_vfsuid = VFSUIDT_INIT(kuid);\r\n\treturn true;\r\n}", ".etattr_vfsgid": "static inline bool setattr_vfsgid(struct iattr *attr, kgid_t kgid)\r\n{\r\n\tif (!gid_valid(kgid))\r\n\t\treturn false;\r\n\tattr->ia_valid |= ATTR_GID;\r\n\tattr->ia_vfsgid = VFSGIDT_INIT(kgid);\r\n\treturn true;\r\n}", ".hown_common": "int chown_common(const struct path *path, uid_t user, gid_t group)\r\n{\r\n\tstruct mnt_idmap *idmap;\r\n\tstruct user_namespace *fs_userns;\r\n\tstruct inode *inode = path->dentry->d_inode;\r\n\tstruct inode *delegated_inode = NULL;\r\n\tint error;\r\n\tstruct iattr newattrs;\r\n\tkuid_t uid;\r\n\tkgid_t gid;\r\n\r\n\tuid = make_kuid(current_user_ns(), user);\r\n\tgid = make_kgid(current_user_ns(), group);\r\n\r\n\tidmap = mnt_idmap(path->mnt);\r\n\tfs_userns = i_user_ns(inode);\r\n\r\nretry_deleg:\r\n\tnewattrs.ia_vfsuid = INVALID_VFSUID;\r\n\tnewattrs.ia_vfsgid = INVALID_VFSGID;\r\n\tnewattrs.ia_valid =  ATTR_CTIME;\r\n\tif ((user != (uid_t)-1) && !setattr_vfsuid(&newattrs, uid))\r\n\t\treturn -EINVAL;\r\n\tif ((group != (gid_t)-1) && !setattr_vfsgid(&newattrs, gid))\r\n\t\treturn -EINVAL;\r\n\terror = inode_lock_killable(inode);\r\n\tif (error)\r\n\t\treturn error;\r\n\tif (!S_ISDIR(inode->i_mode))\r\n\t\tnewattrs.ia_valid |= ATTR_KILL_SUID | ATTR_KILL_PRIV |\r\n\t\t\t\t     setattr_should_drop_sgid(idmap, inode);\r\n\t/* Continue to send actual fs values, not the mount values. */\r\n\terror = security_path_chown(\r\n\t\tpath,\r\n\t\tfrom_vfsuid(idmap, fs_userns, newattrs.ia_vfsuid),\r\n\t\tfrom_vfsgid(idmap, fs_userns, newattrs.ia_vfsgid));\r\n\tif (!error)\r\n\t\terror = notify_change(idmap, path->dentry, &newattrs,\r\n\t\t\t\t      &delegated_inode);\r\n\tinode_unlock(inode);\r\n\tif (delegated_inode) {\r\n\t\terror = break_deleg_wait(&delegated_inode);\r\n\t\tif (!error)\r\n\t\t\tgoto retry_deleg;\r\n\t}\r\n\treturn error;\r\n}", ".fs_fchown": "int vfs_fchown(struct file *file, uid_t user, gid_t group)\r\n{\r\n\tint error;\r\n\r\n\terror = mnt_want_write_file(file);\r\n\tif (error)\r\n\t\treturn error;\r\n\taudit_file(file);\r\n\terror = chown_common(&file->f_path, user, group);\r\n\tmnt_drop_write_file(file);\r\n\treturn error;\r\n}", ".ile_get_write_access": "static inline int file_get_write_access(struct file *f)\r\n{\r\n\tint error;\r\n\r\n\terror = get_write_access(f->f_inode);\r\n\tif (unlikely(error))\r\n\t\treturn error;\r\n\terror = mnt_get_write_access(f->f_path.mnt);\r\n\tif (unlikely(error))\r\n\t\tgoto cleanup_inode;\r\n\tif (unlikely(f->f_mode & FMODE_BACKING)) {\r\n\t\terror = mnt_get_write_access(backing_file_user_path(f)->mnt);\r\n\t\tif (unlikely(error))\r\n\t\t\tgoto cleanup_mnt;\r\n\t}\r\n\treturn 0;\r\n\r\ncleanup_mnt:\r\n\tmnt_put_write_access(f->f_path.mnt);\r\ncleanup_inode:\r\n\tput_write_access(f->f_inode);\r\n\treturn error;\r\n}", ".o_dentry_open": "static int do_dentry_open(struct file *f,\r\n\t\t\t  int (*open)(struct inode *, struct file *))\r\n{\r\n\tstatic const struct file_operations empty_fops = {};\r\n\tstruct inode *inode = f->f_path.dentry->d_inode;\r\n\tint error;\r\n\r\n\tpath_get(&f->f_path);\r\n\tf->f_inode = inode;\r\n\tf->f_mapping = inode->i_mapping;\r\n\tf->f_wb_err = filemap_sample_wb_err(f->f_mapping);\r\n\tf->f_sb_err = file_sample_sb_err(f);\r\n\r\n\tif (unlikely(f->f_flags & O_PATH)) {\r\n\t\tf->f_mode = FMODE_PATH | FMODE_OPENED;\r\n\t\tfile_set_fsnotify_mode(f, FMODE_NONOTIFY);\r\n\t\tf->f_op = &empty_fops;\r\n\t\treturn 0;\r\n\t}\r\n\r\n\tif ((f->f_mode & (FMODE_READ | FMODE_WRITE)) == FMODE_READ) {\r\n\t\ti_readcount_inc(inode);\r\n\t} else if (f->f_mode & FMODE_WRITE && !special_file(inode->i_mode)) {\r\n\t\terror = file_get_write_access(f);\r\n\t\tif (unlikely(error))\r\n\t\t\tgoto cleanup_file;\r\n\t\tf->f_mode |= FMODE_WRITER;\r\n\t}\r\n\r\n\t/* POSIX.1-2008/SUSv4 Section XSI 2.9.7 */\r\n\tif (S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode))\r\n\t\tf->f_mode |= FMODE_ATOMIC_POS;\r\n\r\n\tf->f_op = fops_get(inode->i_fop);\r\n\tif (WARN_ON(!f->f_op)) {\r\n\t\terror = -ENODEV;\r\n\t\tgoto cleanup_all;\r\n\t}\r\n\r\n\terror = security_file_open(f);\r\n\tif (error)\r\n\t\tgoto cleanup_all;\r\n\r\n\t/*\r\n\t * Call fsnotify open permission hook and set FMODE_NONOTIFY_* bits\r\n\t * according to existing permission watches.\r\n\t * If FMODE_NONOTIFY mode was already set for an fanotify fd or for a\r\n\t * pseudo file, this call will not change the mode.\r\n\t */\r\n\terror = fsnotify_open_perm_and_set_mode(f);\r\n\tif (error)\r\n\t\tgoto cleanup_all;\r\n\r\n\terror = break_lease(file_inode(f), f->f_flags);\r\n\tif (error)\r\n\t\tgoto cleanup_all;\r\n\r\n\t/* normally all 3 are set; ->open() can clear them if needed */\r\n\tf->f_mode |= FMODE_LSEEK | FMODE_PREAD | FMODE_PWRITE;\r\n\tif (!open)\r\n\t\topen = f->f_op->open;\r\n\tif (open) {\r\n\t\terror = open(inode, f);\r\n\t\tif (error)\r\n\t\t\tgoto cleanup_all;\r\n\t}\r\n\tf->f_mode |= FMODE_OPENED;\r\n\tif ((f->f_mode & FMODE_READ) &&\r\n\t     likely(f->f_op->read || f->f_op->read_iter))\r\n\t\tf->f_mode |= FMODE_CAN_READ;\r\n\tif ((f->f_mode & FMODE_WRITE) &&\r\n\t     likely(f->f_op->write || f->f_op->write_iter))\r\n\t\tf->f_mode |= FMODE_CAN_WRITE;\r\n\tif ((f->f_mode & FMODE_LSEEK) && !f->f_op->llseek)\r\n\t\tf->f_mode &= ~FMODE_LSEEK;\r\n\tif (f->f_mapping->a_ops && f->f_mapping->a_ops->direct_IO)\r\n\t\tf->f_mode |= FMODE_CAN_ODIRECT;\r\n\r\n\tf->f_flags &= ~(O_CREAT | O_EXCL | O_NOCTTY | O_TRUNC);\r\n\tf->f_iocb_flags = iocb_flags(f);\r\n\r\n\tfile_ra_state_init(&f->f_ra, f->f_mapping->host->i_mapping);\r\n\r\n\tif ((f->f_flags & O_DIRECT) && !(f->f_mode & FMODE_CAN_ODIRECT))\r\n\t\treturn -EINVAL;\r\n\r\n\t/*\r\n\t * XXX: Huge page cache doesn't support writing yet. Drop all page\r\n\t * cache for this file before processing writes.\r\n\t */\r\n\tif (f->f_mode & FMODE_WRITE) {\r\n\t\t/*\r\n\t\t * Depends on full fence from get_write_access() to synchronize\r\n\t\t * against collapse_file() regarding i_writecount and nr_thps\r\n\t\t * updates. Ensures subsequent insertion of THPs into the page\r\n\t\t * cache will fail.\r\n\t\t */\r\n\t\tif (filemap_nr_thps(inode->i_mapping)) {\r\n\t\t\tstruct address_space *mapping = inode->i_mapping;\r\n\r\n\t\t\tfilemap_invalidate_lock(inode->i_mapping);\r\n\t\t\t/*\r\n\t\t\t * unmap_mapping_range just need to be called once\r\n\t\t\t * here, because the private pages is not need to be\r\n\t\t\t * unmapped mapping (e.g. data segment of dynamic\r\n\t\t\t * shared libraries here).\r\n\t\t\t */\r\n\t\t\tunmap_mapping_range(mapping, 0, 0, 0);\r\n\t\t\ttruncate_inode_pages(mapping, 0);\r\n\t\t\tfilemap_invalidate_unlock(inode->i_mapping);\r\n\t\t}\r\n\t}\r\n\r\n\treturn 0;\r\n\r\ncleanup_all:\r\n\tif (WARN_ON_ONCE(error > 0))\r\n\t\terror = -EINVAL;\r\n\tfops_put(f->f_op);\r\n\tput_file_access(f);\r\ncleanup_file:\r\n\tpath_put(&f->f_path);\r\n\tf->__f_path.mnt = NULL;\r\n\tf->__f_path.dentry = NULL;\r\n\tf->f_inode = NULL;\r\n\treturn error;\r\n}", ".uild_open_flags": "inline int build_open_flags(const struct open_how *how, struct open_flags *op)\r\n{\r\n\tu64 flags = how->flags;\r\n\tu64 strip = O_CLOEXEC;\r\n\tint lookup_flags = 0;\r\n\tint acc_mode = ACC_MODE(flags);\r\n\r\n\tBUILD_BUG_ON_MSG(upper_32_bits(VALID_OPEN_FLAGS),\r\n\t\t\t \"struct open_flags doesn't yet handle flags > 32 bits\");\r\n\r\n\t/*\r\n\t * Strip flags that aren't relevant in determining struct open_flags.\r\n\t */\r\n\tflags &= ~strip;\r\n\r\n\t/*\r\n\t * Older syscalls implicitly clear all of the invalid flags or argument\r\n\t * values before calling build_open_flags(), but openat2(2) checks all\r\n\t * of its arguments.\r\n\t */\r\n\tif (flags & ~VALID_OPEN_FLAGS)\r\n\t\treturn -EINVAL;\r\n\tif (how->resolve & ~VALID_RESOLVE_FLAGS)\r\n\t\treturn -EINVAL;\r\n\r\n\t/* Scoping flags are mutually exclusive. */\r\n\tif ((how->resolve & RESOLVE_BENEATH) && (how->resolve & RESOLVE_IN_ROOT))\r\n\t\treturn -EINVAL;\r\n\r\n\t/* Deal with the mode. */\r\n\tif (WILL_CREATE(flags)) {\r\n\t\tif (how->mode & ~S_IALLUGO)\r\n\t\t\treturn -EINVAL;\r\n\t\top->mode = how->mode | S_IFREG;\r\n\t} else {\r\n\t\tif (how->mode != 0)\r\n\t\t\treturn -EINVAL;\r\n\t\top->mode = 0;\r\n\t}\r\n\r\n\t/*\r\n\t * Block bugs where O_DIRECTORY | O_CREAT created regular files.\r\n\t * Note, that blocking O_DIRECTORY | O_CREAT here also protects\r\n\t * O_TMPFILE below which requires O_DIRECTORY being raised.\r\n\t */\r\n\tif ((flags & (O_DIRECTORY | O_CREAT)) == (O_DIRECTORY | O_CREAT))\r\n\t\treturn -EINVAL;\r\n\r\n\t/* Now handle the creative implementation of O_TMPFILE. */\r\n\tif (flags & __O_TMPFILE) {\r\n\t\t/*\r\n\t\t * In order to ensure programs get explicit errors when trying\r\n\t\t * to use O_TMPFILE on old kernels we enforce that O_DIRECTORY\r\n\t\t * is raised alongside __O_TMPFILE.\r\n\t\t */\r\n\t\tif (!(flags & O_DIRECTORY))\r\n\t\t\treturn -EINVAL;\r\n\t\tif (!(acc_mode & MAY_WRITE))\r\n\t\t\treturn -EINVAL;\r\n\t}\r\n\tif (flags & O_PATH) {\r\n\t\t/* O_PATH only permits certain other flags to be set. */\r\n\t\tif (flags & ~O_PATH_FLAGS)\r\n\t\t\treturn -EINVAL;\r\n\t\tacc_mode = 0;\r\n\t}\r\n\r\n\t/*\r\n\t * O_SYNC is implemented as __O_SYNC|O_DSYNC.  As many places only\r\n\t * check for O_DSYNC if the need any syncing at all we enforce it's\r\n\t * always set instead of having to deal with possibly weird behaviour\r\n\t * for malicious applications setting only __O_SYNC.\r\n\t */\r\n\tif (flags & __O_SYNC)\r\n\t\tflags |= O_DSYNC;\r\n\r\n\top->open_flag = flags;\r\n\r\n\t/* O_TRUNC implies we need access checks for write permissions */\r\n\tif (flags & O_TRUNC)\r\n\t\tacc_mode |= MAY_WRITE;\r\n\r\n\t/* Allow the LSM permission hook to distinguish append\r\n\t   access from general write access. */\r\n\tif (flags & O_APPEND)\r\n\t\tacc_mode |= MAY_APPEND;\r\n\r\n\top->acc_mode = acc_mode;\r\n\r\n\top->intent = flags & O_PATH ? 0 : LOOKUP_OPEN;\r\n\r\n\tif (flags & O_CREAT) {\r\n\t\top->intent |= LOOKUP_CREATE;\r\n\t\tif (flags & O_EXCL) {\r\n\t\t\top->intent |= LOOKUP_EXCL;\r\n\t\t\tflags |= O_NOFOLLOW;\r\n\t\t}\r\n\t}\r\n\r\n\tif (flags & O_DIRECTORY)\r\n\t\tlookup_flags |= LOOKUP_DIRECTORY;\r\n\tif (!(flags & O_NOFOLLOW))\r\n\t\tlookup_flags |= LOOKUP_FOLLOW;\r\n\r\n\tif (how->resolve & RESOLVE_NO_XDEV)\r\n\t\tlookup_flags |= LOOKUP_NO_XDEV;\r\n\tif (how->resolve & RESOLVE_NO_MAGICLINKS)\r\n\t\tlookup_flags |= LOOKUP_NO_MAGICLINKS;\r\n\tif (how->resolve & RESOLVE_NO_SYMLINKS)\r\n\t\tlookup_flags |= LOOKUP_NO_SYMLINKS;\r\n\tif (how->resolve & RESOLVE_BENEATH)\r\n\t\tlookup_flags |= LOOKUP_BENEATH;\r\n\tif (how->resolve & RESOLVE_IN_ROOT)\r\n\t\tlookup_flags |= LOOKUP_IN_ROOT;\r\n\tif (how->resolve & RESOLVE_CACHED) {\r\n\t\t/* Don't bother even trying for create/truncate/tmpfile open */\r\n\t\tif (flags & (O_TRUNC | O_CREAT | __O_TMPFILE))\r\n\t\t\treturn -EAGAIN;\r\n\t\tlookup_flags |= LOOKUP_CACHED;\r\n\t}\r\n\r\n\top->lookup_flags = lookup_flags;\r\n\treturn 0;\r\n}", ".uild_open_how": "inline struct open_how build_open_how(int flags, umode_t mode)\r\n{\r\n\tstruct open_how how = {\r\n\t\t.flags = flags & VALID_OPEN_FLAGS,\r\n\t\t.mode = mode & S_IALLUGO,\r\n\t};\r\n\r\n\t/* O_PATH beats everything else. */\r\n\tif (how.flags & O_PATH)\r\n\t\thow.flags &= O_PATH_FLAGS;\r\n\t/* Modes should only be set for create-like flags. */\r\n\tif (!WILL_CREATE(how.flags))\r\n\t\thow.mode = 0;\r\n\treturn how;\r\n}", ".o_sys_openat2": "static int do_sys_openat2(int dfd, const char __user *filename,\r\n\t\t\t  struct open_how *how)\r\n{\r\n\tstruct open_flags op;\r\n\tstruct filename *tmp;\r\n\tint err, fd;\r\n\r\n\terr = build_open_flags(how, &op);\r\n\tif (unlikely(err))\r\n\t\treturn err;\r\n\r\n\ttmp = getname(filename);\r\n\tif (IS_ERR(tmp))\r\n\t\treturn PTR_ERR(tmp);\r\n\r\n\tfd = get_unused_fd_flags(how->flags);\r\n\tif (likely(fd >= 0)) {\r\n\t\tstruct file *f = do_filp_open(dfd, tmp, &op);\r\n\t\tif (IS_ERR(f)) {\r\n\t\t\tput_unused_fd(fd);\r\n\t\t\tfd = PTR_ERR(f);\r\n\t\t} else {\r\n\t\t\tfd_install(fd, f);\r\n\t\t}\r\n\t}\r\n\tputname(tmp);\r\n\treturn fd;\r\n}", ".ilp_flush": "static int filp_flush(struct file *filp, fl_owner_t id)\r\n{\r\n\tint retval = 0;\r\n\r\n\tif (CHECK_DATA_CORRUPTION(file_count(filp) == 0, filp,\r\n\t\t\t\"VFS: Close: file count is 0 (f_op=%ps)\",\r\n\t\t\tfilp->f_op)) {\r\n\t\treturn 0;\r\n\t}\r\n\r\n\tif (filp->f_op->flush)\r\n\t\tretval = filp->f_op->flush(filp, id);\r\n\r\n\tif (likely(!(filp->f_mode & FMODE_PATH))) {\r\n\t\tdnotify_flush(filp, id);\r\n\t\tlocks_remove_posix(filp, id);\r\n\t}\r\n\treturn retval;\r\n}"}, "callee": {".fs_truncate": "int vfs_truncate(const struct path *path, loff_t length)\r\n{\r\n\tstruct mnt_idmap *idmap;\r\n\tstruct inode *inode;\r\n\tint error;\r\n\r\n\tinode = path->dentry->d_inode;\r\n\r\n\t/* For directories it's -EISDIR, for other non-regulars - -EINVAL */\r\n\tif (S_ISDIR(inode->i_mode))\r\n\t\treturn -EISDIR;\r\n\tif (!S_ISREG(inode->i_mode))\r\n\t\treturn -EINVAL;\r\n\r\n\tidmap = mnt_idmap(path->mnt);\r\n\terror = inode_permission(idmap, inode, MAY_WRITE);\r\n\tif (error)\r\n\t\treturn error;\r\n\r\n\terror = fsnotify_truncate_perm(path, length);\r\n\tif (error)\r\n\t\treturn error;\r\n\r\n\terror = mnt_want_write(path->mnt);\r\n\tif (error)\r\n\t\treturn error;\r\n\r\n\terror = -EPERM;\r\n\tif (IS_APPEND(inode))\r\n\t\tgoto mnt_drop_write_and_out;\r\n\r\n\terror = get_write_access(inode);\r\n\tif (error)\r\n\t\tgoto mnt_drop_write_and_out;\r\n\r\n\t/*\r\n\t * Make sure that there are no leases.  get_write_access() protects\r\n\t * against the truncate racing with a lease-granting setlease().\r\n\t */\r\n\terror = break_lease(inode, O_WRONLY);\r\n\tif (error)\r\n\t\tgoto put_write_and_out;\r\n\r\n\terror = security_path_truncate(path);\r\n\tif (!error)\r\n\t\terror = do_truncate(idmap, path->dentry, length, 0, NULL);\r\n\r\nput_write_and_out:\r\n\tput_write_access(inode);\r\nmnt_drop_write_and_out:\r\n\tmnt_drop_write(path->mnt);\r\n\r\n\treturn error;\r\n}", ".o_ftruncate": "int do_ftruncate(struct file *file, loff_t length, int small)\r\n{\r\n\tstruct inode *inode;\r\n\tstruct dentry *dentry;\r\n\tint error;\r\n\r\n\t/* explicitly opened as large or we are on 64-bit box */\r\n\tif (file->f_flags & O_LARGEFILE)\r\n\t\tsmall = 0;\r\n\r\n\tdentry = file->f_path.dentry;\r\n\tinode = dentry->d_inode;\r\n\tif (!S_ISREG(inode->i_mode) || !(file->f_mode & FMODE_WRITE))\r\n\t\treturn -EINVAL;\r\n\r\n\t/* Cannot ftruncate over 2^31 bytes without large file support */\r\n\tif (small && length > MAX_NON_LFS)\r\n\t\treturn -EINVAL;\r\n\r\n\t/* Check IS_APPEND on real upper inode */\r\n\tif (IS_APPEND(file_inode(file)))\r\n\t\treturn -EPERM;\r\n\r\n\terror = security_file_truncate(file);\r\n\tif (error)\r\n\t\treturn error;\r\n\r\n\terror = fsnotify_truncate_perm(&file->f_path, length);\r\n\tif (error)\r\n\t\treturn error;\r\n\r\n\tsb_start_write(inode->i_sb);\r\n\terror = do_truncate(file_mnt_idmap(file), dentry, length,\r\n\t\t\t    ATTR_MTIME | ATTR_CTIME, file);\r\n\tsb_end_write(inode->i_sb);\r\n\r\n\treturn error;\r\n}", ".o_sys_truncate": "int do_sys_truncate(const char __user *pathname, loff_t length)\r\n{\r\n\tunsigned int lookup_flags = LOOKUP_FOLLOW;\r\n\tstruct path path;\r\n\tint error;\r\n\r\n\tif (length < 0)\t/* sorry, but loff_t says... */\r\n\t\treturn -EINVAL;\r\n\r\nretry:\r\n\terror = user_path_at(AT_FDCWD, pathname, lookup_flags, &path);\r\n\tif (!error) {\r\n\t\terror = vfs_truncate(&path, length);\r\n\t\tpath_put(&path);\r\n\t}\r\n\tif (retry_estale(error, lookup_flags)) {\r\n\t\tlookup_flags |= LOOKUP_REVAL;\r\n\t\tgoto retry;\r\n\t}\r\n\treturn error;\r\n}", ".o_sys_ftruncate": "int do_sys_ftruncate(unsigned int fd, loff_t length, int small)\r\n{\r\n\tif (length < 0)\r\n\t\treturn -EINVAL;\r\n\tCLASS(fd, f)(fd);\r\n\tif (fd_empty(f))\r\n\t\treturn -EBADF;\r\n\r\n\treturn do_ftruncate(fd_file(f), length, small);\r\n}", ".sys_fallocate": "int ksys_fallocate(int fd, int mode, loff_t offset, loff_t len)\r\n{\r\n\tCLASS(fd, f)(fd);\r\n\r\n\tif (fd_empty(f))\r\n\t\treturn -EBADF;\r\n\r\n\treturn vfs_fallocate(fd_file(f), mode, offset, len);\r\n}", ".o_faccessat": "static int do_faccessat(int dfd, const char __user *filename, int mode, int flags)\r\n{\r\n\tstruct path path;\r\n\tstruct inode *inode;\r\n\tint res;\r\n\tunsigned int lookup_flags = LOOKUP_FOLLOW;\r\n\tconst struct cred *old_cred = NULL;\r\n\r\n\tif (mode & ~S_IRWXO)\t/* where's F_OK, X_OK, W_OK, R_OK? */\r\n\t\treturn -EINVAL;\r\n\r\n\tif (flags & ~(AT_EACCESS | AT_SYMLINK_NOFOLLOW | AT_EMPTY_PATH))\r\n\t\treturn -EINVAL;\r\n\r\n\tif (flags & AT_SYMLINK_NOFOLLOW)\r\n\t\tlookup_flags &= ~LOOKUP_FOLLOW;\r\n\tif (flags & AT_EMPTY_PATH)\r\n\t\tlookup_flags |= LOOKUP_EMPTY;\r\n\r\n\tif (access_need_override_creds(flags)) {\r\n\t\told_cred = access_override_creds();\r\n\t\tif (!old_cred)\r\n\t\t\treturn -ENOMEM;\r\n\t}\r\n\r\nretry:\r\n\tres = user_path_at(dfd, filename, lookup_flags, &path);\r\n\tif (res)\r\n\t\tgoto out;\r\n\r\n\tinode = d_backing_inode(path.dentry);\r\n\r\n\tif ((mode & MAY_EXEC) && S_ISREG(inode->i_mode)) {\r\n\t\t/*\r\n\t\t * MAY_EXEC on regular files is denied if the fs is mounted\r\n\t\t * with the \"noexec\" flag.\r\n\t\t */\r\n\t\tres = -EACCES;\r\n\t\tif (path_noexec(&path))\r\n\t\t\tgoto out_path_release;\r\n\t}\r\n\r\n\tres = inode_permission(mnt_idmap(path.mnt), inode, mode | MAY_ACCESS);\r\n\t/* SuS v2 requires we report a read only fs too */\r\n\tif (res || !(mode & S_IWOTH) || special_file(inode->i_mode))\r\n\t\tgoto out_path_release;\r\n\t/*\r\n\t * This is a rare case where using __mnt_is_readonly()\r\n\t * is OK without a mnt_want/drop_write() pair.  Since\r\n\t * no actual write to the fs is performed here, we do\r\n\t * not need to telegraph to that to anyone.\r\n\t *\r\n\t * By doing this, we accept that this access is\r\n\t * inherently racy and know that the fs may change\r\n\t * state before we even see this result.\r\n\t */\r\n\tif (__mnt_is_readonly(path.mnt))\r\n\t\tres = -EROFS;\r\n\r\nout_path_release:\r\n\tpath_put(&path);\r\n\tif (retry_estale(res, lookup_flags)) {\r\n\t\tlookup_flags |= LOOKUP_REVAL;\r\n\t\tgoto retry;\r\n\t}\r\nout:\r\n\tif (old_cred)\r\n\t\tput_cred(revert_creds(old_cred));\r\n\r\n\treturn res;\r\n}", ".fs_fchmod": "int vfs_fchmod(struct file *file, umode_t mode)\r\n{\r\n\taudit_file(file);\r\n\treturn chmod_common(&file->f_path, mode);\r\n}", ".o_fchmodat": "static int do_fchmodat(int dfd, const char __user *filename, umode_t mode,\r\n\t\t       unsigned int flags)\r\n{\r\n\tstruct path path;\r\n\tint error;\r\n\tunsigned int lookup_flags;\r\n\r\n\tif (unlikely(flags & ~(AT_SYMLINK_NOFOLLOW | AT_EMPTY_PATH)))\r\n\t\treturn -EINVAL;\r\n\r\n\tlookup_flags = (flags & AT_SYMLINK_NOFOLLOW) ? 0 : LOOKUP_FOLLOW;\r\n\tif (flags & AT_EMPTY_PATH)\r\n\t\tlookup_flags |= LOOKUP_EMPTY;\r\n\r\nretry:\r\n\terror = user_path_at(dfd, filename, lookup_flags, &path);\r\n\tif (!error) {\r\n\t\terror = chmod_common(&path, mode);\r\n\t\tpath_put(&path);\r\n\t\tif (retry_estale(error, lookup_flags)) {\r\n\t\t\tlookup_flags |= LOOKUP_REVAL;\r\n\t\t\tgoto retry;\r\n\t\t}\r\n\t}\r\n\treturn error;\r\n}", ".hown_common": "int chown_common(const struct path *path, uid_t user, gid_t group)\r\n{\r\n\tstruct mnt_idmap *idmap;\r\n\tstruct user_namespace *fs_userns;\r\n\tstruct inode *inode = path->dentry->d_inode;\r\n\tstruct inode *delegated_inode = NULL;\r\n\tint error;\r\n\tstruct iattr newattrs;\r\n\tkuid_t uid;\r\n\tkgid_t gid;\r\n\r\n\tuid = make_kuid(current_user_ns(), user);\r\n\tgid = make_kgid(current_user_ns(), group);\r\n\r\n\tidmap = mnt_idmap(path->mnt);\r\n\tfs_userns = i_user_ns(inode);\r\n\r\nretry_deleg:\r\n\tnewattrs.ia_vfsuid = INVALID_VFSUID;\r\n\tnewattrs.ia_vfsgid = INVALID_VFSGID;\r\n\tnewattrs.ia_valid =  ATTR_CTIME;\r\n\tif ((user != (uid_t)-1) && !setattr_vfsuid(&newattrs, uid))\r\n\t\treturn -EINVAL;\r\n\tif ((group != (gid_t)-1) && !setattr_vfsgid(&newattrs, gid))\r\n\t\treturn -EINVAL;\r\n\terror = inode_lock_killable(inode);\r\n\tif (error)\r\n\t\treturn error;\r\n\tif (!S_ISDIR(inode->i_mode))\r\n\t\tnewattrs.ia_valid |= ATTR_KILL_SUID | ATTR_KILL_PRIV |\r\n\t\t\t\t     setattr_should_drop_sgid(idmap, inode);\r\n\t/* Continue to send actual fs values, not the mount values. */\r\n\terror = security_path_chown(\r\n\t\tpath,\r\n\t\tfrom_vfsuid(idmap, fs_userns, newattrs.ia_vfsuid),\r\n\t\tfrom_vfsgid(idmap, fs_userns, newattrs.ia_vfsgid));\r\n\tif (!error)\r\n\t\terror = notify_change(idmap, path->dentry, &newattrs,\r\n\t\t\t\t      &delegated_inode);\r\n\tinode_unlock(inode);\r\n\tif (delegated_inode) {\r\n\t\terror = break_deleg_wait(&delegated_inode);\r\n\t\tif (!error)\r\n\t\t\tgoto retry_deleg;\r\n\t}\r\n\treturn error;\r\n}", ".o_fchownat": "int do_fchownat(int dfd, const char __user *filename, uid_t user, gid_t group,\r\n\t\tint flag)\r\n{\r\n\tstruct path path;\r\n\tint error = -EINVAL;\r\n\tint lookup_flags;\r\n\r\n\tif ((flag & ~(AT_SYMLINK_NOFOLLOW | AT_EMPTY_PATH)) != 0)\r\n\t\tgoto out;\r\n\r\n\tlookup_flags = (flag & AT_SYMLINK_NOFOLLOW) ? 0 : LOOKUP_FOLLOW;\r\n\tif (flag & AT_EMPTY_PATH)\r\n\t\tlookup_flags |= LOOKUP_EMPTY;\r\nretry:\r\n\terror = user_path_at(dfd, filename, lookup_flags, &path);\r\n\tif (error)\r\n\t\tgoto out;\r\n\terror = mnt_want_write(path.mnt);\r\n\tif (error)\r\n\t\tgoto out_release;\r\n\terror = chown_common(&path, user, group);\r\n\tmnt_drop_write(path.mnt);\r\nout_release:\r\n\tpath_put(&path);\r\n\tif (retry_estale(error, lookup_flags)) {\r\n\t\tlookup_flags |= LOOKUP_REVAL;\r\n\t\tgoto retry;\r\n\t}\r\nout:\r\n\treturn error;\r\n}", ".fs_fchown": "int vfs_fchown(struct file *file, uid_t user, gid_t group)\r\n{\r\n\tint error;\r\n\r\n\terror = mnt_want_write_file(file);\r\n\tif (error)\r\n\t\treturn error;\r\n\taudit_file(file);\r\n\terror = chown_common(&file->f_path, user, group);\r\n\tmnt_drop_write_file(file);\r\n\treturn error;\r\n}", ".sys_fchown": "int ksys_fchown(unsigned int fd, uid_t user, gid_t group)\r\n{\r\n\tCLASS(fd, f)(fd);\r\n\r\n\tif (fd_empty(f))\r\n\t\treturn -EBADF;\r\n\r\n\treturn vfs_fchown(fd_file(f), user, group);\r\n}", ".o_dentry_open": "static int do_dentry_open(struct file *f,\r\n\t\t\t  int (*open)(struct inode *, struct file *))\r\n{\r\n\tstatic const struct file_operations empty_fops = {};\r\n\tstruct inode *inode = f->f_path.dentry->d_inode;\r\n\tint error;\r\n\r\n\tpath_get(&f->f_path);\r\n\tf->f_inode = inode;\r\n\tf->f_mapping = inode->i_mapping;\r\n\tf->f_wb_err = filemap_sample_wb_err(f->f_mapping);\r\n\tf->f_sb_err = file_sample_sb_err(f);\r\n\r\n\tif (unlikely(f->f_flags & O_PATH)) {\r\n\t\tf->f_mode = FMODE_PATH | FMODE_OPENED;\r\n\t\tfile_set_fsnotify_mode(f, FMODE_NONOTIFY);\r\n\t\tf->f_op = &empty_fops;\r\n\t\treturn 0;\r\n\t}\r\n\r\n\tif ((f->f_mode & (FMODE_READ | FMODE_WRITE)) == FMODE_READ) {\r\n\t\ti_readcount_inc(inode);\r\n\t} else if (f->f_mode & FMODE_WRITE && !special_file(inode->i_mode)) {\r\n\t\terror = file_get_write_access(f);\r\n\t\tif (unlikely(error))\r\n\t\t\tgoto cleanup_file;\r\n\t\tf->f_mode |= FMODE_WRITER;\r\n\t}\r\n\r\n\t/* POSIX.1-2008/SUSv4 Section XSI 2.9.7 */\r\n\tif (S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode))\r\n\t\tf->f_mode |= FMODE_ATOMIC_POS;\r\n\r\n\tf->f_op = fops_get(inode->i_fop);\r\n\tif (WARN_ON(!f->f_op)) {\r\n\t\terror = -ENODEV;\r\n\t\tgoto cleanup_all;\r\n\t}\r\n\r\n\terror = security_file_open(f);\r\n\tif (error)\r\n\t\tgoto cleanup_all;\r\n\r\n\t/*\r\n\t * Call fsnotify open permission hook and set FMODE_NONOTIFY_* bits\r\n\t * according to existing permission watches.\r\n\t * If FMODE_NONOTIFY mode was already set for an fanotify fd or for a\r\n\t * pseudo file, this call will not change the mode.\r\n\t */\r\n\terror = fsnotify_open_perm_and_set_mode(f);\r\n\tif (error)\r\n\t\tgoto cleanup_all;\r\n\r\n\terror = break_lease(file_inode(f), f->f_flags);\r\n\tif (error)\r\n\t\tgoto cleanup_all;\r\n\r\n\t/* normally all 3 are set; ->open() can clear them if needed */\r\n\tf->f_mode |= FMODE_LSEEK | FMODE_PREAD | FMODE_PWRITE;\r\n\tif (!open)\r\n\t\topen = f->f_op->open;\r\n\tif (open) {\r\n\t\terror = open(inode, f);\r\n\t\tif (error)\r\n\t\t\tgoto cleanup_all;\r\n\t}\r\n\tf->f_mode |= FMODE_OPENED;\r\n\tif ((f->f_mode & FMODE_READ) &&\r\n\t     likely(f->f_op->read || f->f_op->read_iter))\r\n\t\tf->f_mode |= FMODE_CAN_READ;\r\n\tif ((f->f_mode & FMODE_WRITE) &&\r\n\t     likely(f->f_op->write || f->f_op->write_iter))\r\n\t\tf->f_mode |= FMODE_CAN_WRITE;\r\n\tif ((f->f_mode & FMODE_LSEEK) && !f->f_op->llseek)\r\n\t\tf->f_mode &= ~FMODE_LSEEK;\r\n\tif (f->f_mapping->a_ops && f->f_mapping->a_ops->direct_IO)\r\n\t\tf->f_mode |= FMODE_CAN_ODIRECT;\r\n\r\n\tf->f_flags &= ~(O_CREAT | O_EXCL | O_NOCTTY | O_TRUNC);\r\n\tf->f_iocb_flags = iocb_flags(f);\r\n\r\n\tfile_ra_state_init(&f->f_ra, f->f_mapping->host->i_mapping);\r\n\r\n\tif ((f->f_flags & O_DIRECT) && !(f->f_mode & FMODE_CAN_ODIRECT))\r\n\t\treturn -EINVAL;\r\n\r\n\t/*\r\n\t * XXX: Huge page cache doesn't support writing yet. Drop all page\r\n\t * cache for this file before processing writes.\r\n\t */\r\n\tif (f->f_mode & FMODE_WRITE) {\r\n\t\t/*\r\n\t\t * Depends on full fence from get_write_access() to synchronize\r\n\t\t * against collapse_file() regarding i_writecount and nr_thps\r\n\t\t * updates. Ensures subsequent insertion of THPs into the page\r\n\t\t * cache will fail.\r\n\t\t */\r\n\t\tif (filemap_nr_thps(inode->i_mapping)) {\r\n\t\t\tstruct address_space *mapping = inode->i_mapping;\r\n\r\n\t\t\tfilemap_invalidate_lock(inode->i_mapping);\r\n\t\t\t/*\r\n\t\t\t * unmap_mapping_range just need to be called once\r\n\t\t\t * here, because the private pages is not need to be\r\n\t\t\t * unmapped mapping (e.g. data segment of dynamic\r\n\t\t\t * shared libraries here).\r\n\t\t\t */\r\n\t\t\tunmap_mapping_range(mapping, 0, 0, 0);\r\n\t\t\ttruncate_inode_pages(mapping, 0);\r\n\t\t\tfilemap_invalidate_unlock(inode->i_mapping);\r\n\t\t}\r\n\t}\r\n\r\n\treturn 0;\r\n\r\ncleanup_all:\r\n\tif (WARN_ON_ONCE(error > 0))\r\n\t\terror = -EINVAL;\r\n\tfops_put(f->f_op);\r\n\tput_file_access(f);\r\ncleanup_file:\r\n\tpath_put(&f->f_path);\r\n\tf->__f_path.mnt = NULL;\r\n\tf->__f_path.dentry = NULL;\r\n\tf->f_inode = NULL;\r\n\treturn error;\r\n}", ".inish_open": "int finish_open(struct file *file, struct dentry *dentry,\r\n\t\tint (*open)(struct inode *, struct file *))\r\n{\r\n\tBUG_ON(file->f_mode & FMODE_OPENED); /* once it's opened, it's opened */\r\n\r\n\tfile->__f_path.dentry = dentry;\r\n\treturn do_dentry_open(file, open);\r\n}", ".fs_open": "int vfs_open(const struct path *path, struct file *file)\r\n{\r\n\tint ret;\r\n\r\n\tfile->__f_path = *path;\r\n\tret = do_dentry_open(file, NULL);\r\n\tif (!ret) {\r\n\t\t/*\r\n\t\t * Once we return a file with FMODE_OPENED, __fput() will call\r\n\t\t * fsnotify_close(), so we need fsnotify_open() here for\r\n\t\t * symmetry.\r\n\t\t */\r\n\t\tfsnotify_open(file);\r\n\t}\r\n\treturn ret;\r\n}", ".o_sys_open": "int do_sys_open(int dfd, const char __user *filename, int flags, umode_t mode)\r\n{\r\n\tstruct open_how how = build_open_how(flags, mode);\r\n\treturn do_sys_openat2(dfd, filename, &how);\r\n}", ".o_sys_openat2": "static int do_sys_openat2(int dfd, const char __user *filename,\r\n\t\t\t  struct open_how *how)\r\n{\r\n\tstruct open_flags op;\r\n\tstruct filename *tmp;\r\n\tint err, fd;\r\n\r\n\terr = build_open_flags(how, &op);\r\n\tif (unlikely(err))\r\n\t\treturn err;\r\n\r\n\ttmp = getname(filename);\r\n\tif (IS_ERR(tmp))\r\n\t\treturn PTR_ERR(tmp);\r\n\r\n\tfd = get_unused_fd_flags(how->flags);\r\n\tif (likely(fd >= 0)) {\r\n\t\tstruct file *f = do_filp_open(dfd, tmp, &op);\r\n\t\tif (IS_ERR(f)) {\r\n\t\t\tput_unused_fd(fd);\r\n\t\t\tfd = PTR_ERR(f);\r\n\t\t} else {\r\n\t\t\tfd_install(fd, f);\r\n\t\t}\r\n\t}\r\n\tputname(tmp);\r\n\treturn fd;\r\n}", ".ilp_close": "int filp_close(struct file *filp, fl_owner_t id)\r\n{\r\n\tint retval;\r\n\r\n\tretval = filp_flush(filp, id);\r\n\tfput_close(filp);\r\n\r\n\treturn retval;\r\n}"}, "function_name": "stream_open"}
{"function_id": null, "caller": {".ommon_perm": "static int common_perm(const char *op, const struct path *path, u32 mask,\r\n\t\t       struct path_cond *cond)\r\n{\r\n\tstruct aa_label *label;\r\n\tint error = 0;\r\n\tbool needput;\r\n\r\n\tlabel = __begin_current_label_crit_section(&needput);\r\n\tif (!unconfined(label))\r\n\t\terror = aa_path_perm(op, current_cred(), label, path, 0, mask,\r\n\t\t\t\t     cond);\r\n\t__end_current_label_crit_section(label, needput);\r\n\r\n\treturn error;\r\n}", ".ommon_perm_dir_dentry": "static int common_perm_dir_dentry(const char *op, const struct path *dir,\r\n\t\t\t\t  struct dentry *dentry, u32 mask,\r\n\t\t\t\t  struct path_cond *cond)\r\n{\r\n\tstruct path path = { .mnt = dir->mnt, .dentry = dentry };\r\n\r\n\treturn common_perm(op, &path, mask, cond);\r\n}", ".ommon_perm_rm": "static int common_perm_rm(const char *op, const struct path *dir,\r\n\t\t\t  struct dentry *dentry, u32 mask)\r\n{\r\n\tstruct inode *inode = d_backing_inode(dentry);\r\n\tstruct path_cond cond = { };\r\n\tvfsuid_t vfsuid;\r\n\r\n\tif (!inode || !path_mediated_fs(dentry))\r\n\t\treturn 0;\r\n\r\n\tvfsuid = i_uid_into_vfsuid(mnt_idmap(dir->mnt), inode);\r\n\tcond.uid = vfsuid_into_kuid(vfsuid);\r\n\tcond.mode = inode->i_mode;\r\n\r\n\treturn common_perm_dir_dentry(op, dir, dentry, mask, &cond);\r\n}", ".ommon_perm_create": "static int common_perm_create(const char *op, const struct path *dir,\r\n\t\t\t      struct dentry *dentry, u32 mask, umode_t mode)\r\n{\r\n\tstruct path_cond cond = { current_fsuid(), mode };\r\n\r\n\tif (!path_mediated_fs(dir->dentry))\r\n\t\treturn 0;\r\n\r\n\treturn common_perm_dir_dentry(op, dir, dentry, mask, &cond);\r\n}", ".ommon_perm_cond": "static int common_perm_cond(const char *op, const struct path *path, u32 mask)\r\n{\r\n\tvfsuid_t vfsuid = i_uid_into_vfsuid(mnt_idmap(path->mnt),\r\n\t\t\t\t\t    d_backing_inode(path->dentry));\r\n\tstruct path_cond cond = {\r\n\t\tvfsuid_into_kuid(vfsuid),\r\n\t\td_backing_inode(path->dentry)->i_mode\r\n\t};\r\n\r\n\tif (!path_mediated_fs(path->dentry))\r\n\t\treturn 0;\r\n\r\n\treturn common_perm(op, path, mask, &cond);\r\n}", ".pparmor_path_truncate": "static int apparmor_path_truncate(const struct path *path)\r\n{\r\n\treturn common_perm_cond(OP_TRUNC, path, MAY_WRITE | AA_MAY_SETATTR);\r\n}", ".ommon_file_perm": "static int common_file_perm(const char *op, struct file *file, u32 mask,\r\n\t\t\t    bool in_atomic)\r\n{\r\n\tstruct aa_label *label;\r\n\tint error = 0;\r\n\tbool needput;\r\n\r\n\t/* don't reaudit files closed during inheritance */\r\n\tif (unlikely(file->f_path.dentry == aa_null.dentry))\r\n\t\treturn -EACCES;\r\n\r\n\tlabel = __begin_current_label_crit_section(&needput);\r\n\terror = aa_file_perm(op, current_cred(), label, file, mask, in_atomic);\r\n\t__end_current_label_crit_section(label, needput);\r\n\r\n\treturn error;\r\n}", ".ommon_mmap": "static int common_mmap(const char *op, struct file *file, unsigned long prot,\r\n\t\t       unsigned long flags, bool in_atomic)\r\n{\r\n\tint mask = 0;\r\n\r\n\tif (!file || !file_ctx(file))\r\n\t\treturn 0;\r\n\r\n\tif (prot & PROT_READ)\r\n\t\tmask |= MAY_READ;\r\n\t/*\r\n\t * Private mappings don't require write perms since they don't\r\n\t * write back to the files\r\n\t */\r\n\tif ((prot & PROT_WRITE) && !(flags & MAP_PRIVATE))\r\n\t\tmask |= MAY_WRITE;\r\n\tif (prot & PROT_EXEC)\r\n\t\tmask |= AA_EXEC_MMAP;\r\n\r\n\treturn common_file_perm(op, file, mask, in_atomic);\r\n}", ".udit_uring_cb": "static void audit_uring_cb(struct audit_buffer *ab, void *va)\r\n{\r\n\tstruct apparmor_audit_data *ad = aad_of_va(va);\r\n\r\n\tif (ad->request & AA_URING_PERM_MASK) {\r\n\t\taudit_log_format(ab, \" requested=\\\"%s\\\"\",\r\n\t\t\t\t audit_uring_mask(ad->request));\r\n\t\tif (ad->denied & AA_URING_PERM_MASK) {\r\n\t\t\taudit_log_format(ab, \" denied=\\\"%s\\\"\",\r\n\t\t\t\t\t audit_uring_mask(ad->denied));\r\n\t\t}\r\n\t}\r\n\tif (ad->uring.target) {\r\n\t\taudit_log_format(ab, \" tcontext=\");\r\n\t\taa_label_xaudit(ab, labels_ns(ad->subj_label),\r\n\t\t\t\tad->uring.target,\r\n\t\t\t\tFLAGS_NONE, GFP_ATOMIC);\r\n\t}\r\n}", ".rofile_uring": "static int profile_uring(struct aa_profile *profile, u32 request,\r\n\t\t\t struct aa_label *new, int cap,\r\n\t\t\t struct apparmor_audit_data *ad)\r\n{\r\n\tunsigned int state;\r\n\tstruct aa_ruleset *rules;\r\n\tint error = 0;\r\n\r\n\tAA_BUG(!profile);\r\n\r\n\trules = profile->label.rules[0];\r\n\tstate = RULE_MEDIATES(rules, AA_CLASS_IO_URING);\r\n\tif (state) {\r\n\t\tstruct aa_perms perms = { };\r\n\r\n\t\tif (new) {\r\n\t\t\taa_label_match(profile, rules, new, state,\r\n\t\t\t\t       false, request, &perms);\r\n\t\t} else {\r\n\t\t\tperms = *aa_lookup_perms(rules->policy, state);\r\n\t\t}\r\n\t\taa_apply_modes_to_perms(profile, &perms);\r\n\t\terror = aa_check_perms(profile, &perms, request, ad,\r\n\t\t\t\t       audit_uring_cb);\r\n\t}\r\n\r\n\treturn error;\r\n}", ".o_setattr": "static int do_setattr(u64 attr, void *value, size_t size)\r\n{\r\n\tchar *command, *largs = NULL, *args = value;\r\n\tsize_t arg_size;\r\n\tint error;\r\n\tDEFINE_AUDIT_DATA(ad, LSM_AUDIT_DATA_NONE, AA_CLASS_NONE,\r\n\t\t\t  OP_SETPROCATTR);\r\n\r\n\tif (size == 0)\r\n\t\treturn -EINVAL;\r\n\r\n\t/* AppArmor requires that the buffer must be null terminated atm */\r\n\tif (args[size - 1] != '\\0') {\r\n\t\t/* null terminate */\r\n\t\tlargs = args = kmalloc(size + 1, GFP_KERNEL);\r\n\t\tif (!args)\r\n\t\t\treturn -ENOMEM;\r\n\t\tmemcpy(args, value, size);\r\n\t\targs[size] = '\\0';\r\n\t}\r\n\r\n\terror = -EINVAL;\r\n\targs = strim(args);\r\n\tcommand = strsep(&args, \" \");\r\n\tif (!args)\r\n\t\tgoto out;\r\n\targs = skip_spaces(args);\r\n\tif (!*args)\r\n\t\tgoto out;\r\n\r\n\targ_size = size - (args - (largs ? largs : (char *) value));\r\n\tif (attr == LSM_ATTR_CURRENT) {\r\n\t\tif (strcmp(command, \"changehat\") == 0) {\r\n\t\t\terror = aa_setprocattr_changehat(args, arg_size,\r\n\t\t\t\t\t\t\t AA_CHANGE_NOFLAGS);\r\n\t\t} else if (strcmp(command, \"permhat\") == 0) {\r\n\t\t\terror = aa_setprocattr_changehat(args, arg_size,\r\n\t\t\t\t\t\t\t AA_CHANGE_TEST);\r\n\t\t} else if (strcmp(command, \"changeprofile\") == 0) {\r\n\t\t\terror = aa_change_profile(args, AA_CHANGE_NOFLAGS);\r\n\t\t} else if (strcmp(command, \"permprofile\") == 0) {\r\n\t\t\terror = aa_change_profile(args, AA_CHANGE_TEST);\r\n\t\t} else if (strcmp(command, \"stack\") == 0) {\r\n\t\t\terror = aa_change_profile(args, AA_CHANGE_STACK);\r\n\t\t} else\r\n\t\t\tgoto fail;\r\n\t} else if (attr == LSM_ATTR_EXEC) {\r\n\t\tif (strcmp(command, \"exec\") == 0)\r\n\t\t\terror = aa_change_profile(args, AA_CHANGE_ONEXEC);\r\n\t\telse if (strcmp(command, \"stack\") == 0)\r\n\t\t\terror = aa_change_profile(args, (AA_CHANGE_ONEXEC |\r\n\t\t\t\t\t\t\t AA_CHANGE_STACK));\r\n\t\telse\r\n\t\t\tgoto fail;\r\n\t} else\r\n\t\t/* only support the \"current\" and \"exec\" process attributes */\r\n\t\tgoto fail;\r\n\r\n\tif (!error)\r\n\t\terror = size;\r\nout:\r\n\tkfree(largs);\r\n\treturn error;\r\n\r\nfail:\r\n\tad.subj_label = begin_current_label_crit_section();\r\n\tif (attr == LSM_ATTR_CURRENT)\r\n\t\tad.info = \"current\";\r\n\telse if (attr == LSM_ATTR_EXEC)\r\n\t\tad.info = \"exec\";\r\n\telse\r\n\t\tad.info = \"invalid\";\r\n\tad.error = error = -EINVAL;\r\n\taa_audit_msg(AUDIT_APPARMOR_DENIED, &ad, NULL);\r\n\tend_current_label_crit_section(ad.subj_label);\r\n\tgoto out;\r\n}", ".nix_connect_perm": "static int unix_connect_perm(const struct cred *cred, struct aa_label *label,\r\n\t\t\t     struct sock *sk, struct sock *peer_sk)\r\n{\r\n\tstruct aa_sk_ctx *peer_ctx = aa_sock(peer_sk);\r\n\tint error;\r\n\r\n\terror = aa_unix_peer_perm(cred, label, OP_CONNECT,\r\n\t\t\t\t(AA_MAY_CONNECT | AA_MAY_SEND | AA_MAY_RECEIVE),\r\n\t\t\t\t  sk, peer_sk,\r\n\t\t\t\t  rcu_dereference_protected(peer_ctx->label,\r\n\t\t\t\t     lockdep_is_held(&unix_sk(peer_sk)->lock)));\r\n\tif (!is_unix_fs(peer_sk)) {\r\n\t\tlast_error(error,\r\n\t\t\t   aa_unix_peer_perm(cred,\r\n\t\t\t\trcu_dereference_protected(peer_ctx->label,\r\n\t\t\t\t     lockdep_is_held(&unix_sk(peer_sk)->lock)),\r\n\t\t\t\tOP_CONNECT,\r\n\t\t\t\t(AA_MAY_ACCEPT | AA_MAY_SEND | AA_MAY_RECEIVE),\r\n\t\t\t\t\t\t\t  peer_sk, sk, label));\r\n\t}\r\n\r\n\treturn error;\r\n}", ".nix_connect_peers": "static void unix_connect_peers(struct aa_sk_ctx *sk_ctx,\r\n\t\t\t       struct aa_sk_ctx *peer_ctx)\r\n{\r\n\t/* Cross reference the peer labels for SO_PEERSEC */\r\n\tstruct aa_label *label = rcu_dereference_protected(sk_ctx->label, true);\r\n\r\n\taa_get_label(label);\r\n\taa_put_label(rcu_dereference_protected(peer_ctx->peer,\r\n\t\t\t\t\t     true));\r\n\trcu_assign_pointer(peer_ctx->peer, label);\t/* transfer cnt */\r\n\r\n\tlabel = aa_get_label(rcu_dereference_protected(peer_ctx->label,\r\n\t\t\t\t\t     true));\r\n\t//spin_unlock(&peer_ctx->lock);\r\n\r\n\t//spin_lock(&sk_ctx->lock);\r\n\taa_put_label(rcu_dereference_protected(sk_ctx->peer,\r\n\t\t\t\t\t       true));\r\n\taa_put_label(rcu_dereference_protected(sk_ctx->peer_lastupdate,\r\n\t\t\t\t\t       true));\r\n\r\n\trcu_assign_pointer(sk_ctx->peer, aa_get_label(label));\r\n\trcu_assign_pointer(sk_ctx->peer_lastupdate, label);     /* transfer cnt */\r\n\t//spin_unlock(&sk_ctx->lock);\r\n}", ".a_sock_msg_perm": "static int aa_sock_msg_perm(const char *op, u32 request, struct socket *sock,\r\n\t\t\t    struct msghdr *msg, int size)\r\n{\r\n\tAA_BUG(!sock);\r\n\tAA_BUG(!sock->sk);\r\n\tAA_BUG(!msg);\r\n\tAA_BUG(in_interrupt());\r\n\r\n\t/* PF_UNIX goes through unix_may_send */\r\n\tif (sock->sk->sk_family == PF_UNIX)\r\n\t\treturn 0;\r\n\treturn aa_sk_perm(op, request, sock->sk);\r\n}", ".a_sock_perm": "static int aa_sock_perm(const char *op, u32 request, struct socket *sock)\r\n{\r\n\tAA_BUG(!sock);\r\n\tAA_BUG(!sock->sk);\r\n\tAA_BUG(in_interrupt());\r\n\r\n\tif (sock->sk->sk_family == PF_UNIX)\r\n\t\treturn aa_unix_sock_perm(op, request, sock);\r\n\treturn aa_sk_perm(op, request, sock->sk);\r\n}", ".a_sock_opt_perm": "static int aa_sock_opt_perm(const char *op, u32 request, struct socket *sock,\r\n\t\t\t    int level, int optname)\r\n{\r\n\tAA_BUG(!sock);\r\n\tAA_BUG(!sock->sk);\r\n\tAA_BUG(in_interrupt());\r\n\r\n\tif (sock->sk->sk_family == PF_UNIX)\r\n\t\treturn aa_unix_opt_perm(op, request, sock, level, optname);\r\n\treturn aa_sk_perm(op, request, sock->sk);\r\n}", ".estroy_buffers": "static void destroy_buffers(void)\r\n{\r\n\tunion aa_buffer *aa_buf;\r\n\r\n\tspin_lock(&aa_buffers_lock);\r\n\twhile (!list_empty(&aa_global_buffers)) {\r\n\t\taa_buf = list_first_entry(&aa_global_buffers, union aa_buffer,\r\n\t\t\t\t\t list);\r\n\t\tlist_del(&aa_buf->list);\r\n\t\tspin_unlock(&aa_buffers_lock);\r\n\t\tkfree(aa_buf);\r\n\t\tspin_lock(&aa_buffers_lock);\r\n\t}\r\n\tspin_unlock(&aa_buffers_lock);\r\n}", ".a_put_buffer": "void aa_put_buffer(char *buf)\r\n{\r\n\tunion aa_buffer *aa_buf;\r\n\tstruct aa_local_cache *cache;\r\n\r\n\tif (!buf)\r\n\t\treturn;\r\n\taa_buf = container_of(buf, union aa_buffer, buffer[0]);\r\n\r\n\tcache = get_cpu_ptr(&aa_local_buffers);\r\n\tif (!cache->hold) {\r\n\t\tput_cpu_ptr(&aa_local_buffers);\r\n\r\n\t\tif (spin_trylock(&aa_buffers_lock)) {\r\n\t\t\t/* put back on global list */\r\n\t\t\tlist_add(&aa_buf->list, &aa_global_buffers);\r\n\t\t\tbuffer_count++;\r\n\t\t\tspin_unlock(&aa_buffers_lock);\r\n\t\t\tcache = get_cpu_ptr(&aa_local_buffers);\r\n\t\t\tput_cpu_ptr(&aa_local_buffers);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\t/* contention on global list, fallback to percpu */\r\n\t\tcache = get_cpu_ptr(&aa_local_buffers);\r\n\t\tcache->hold += 1;\r\n\t}\r\n\r\n\t/* cache in percpu list */\r\n\tlist_add(&aa_buf->list, &cache->head);\r\n\tcache->count++;\r\n\tput_cpu_ptr(&aa_local_buffers);\r\n}", ".a_setup_dfa_engine": "static int __init aa_setup_dfa_engine(void)\r\n{\r\n\tint error = -ENOMEM;\r\n\r\n\tnullpdb = aa_alloc_pdb(GFP_KERNEL);\r\n\tif (!nullpdb)\r\n\t\treturn -ENOMEM;\r\n\r\n\tnulldfa = aa_dfa_unpack(nulldfa_src, sizeof(nulldfa_src),\r\n\t\t\t    TO_ACCEPT1_FLAG(YYTD_DATA32) |\r\n\t\t\t    TO_ACCEPT2_FLAG(YYTD_DATA32));\r\n\tif (IS_ERR(nulldfa)) {\r\n\t\terror = PTR_ERR(nulldfa);\r\n\t\tgoto fail;\r\n\t}\r\n\tnullpdb->dfa = aa_get_dfa(nulldfa);\r\n\tnullpdb->perms = kcalloc(2, sizeof(struct aa_perms), GFP_KERNEL);\r\n\tif (!nullpdb->perms)\r\n\t\tgoto fail;\r\n\tnullpdb->size = 2;\r\n\r\n\tstacksplitdfa = aa_dfa_unpack(stacksplitdfa_src,\r\n\t\t\t\t      sizeof(stacksplitdfa_src),\r\n\t\t\t\t      TO_ACCEPT1_FLAG(YYTD_DATA32) |\r\n\t\t\t\t      TO_ACCEPT2_FLAG(YYTD_DATA32));\r\n\tif (IS_ERR(stacksplitdfa)) {\r\n\t\terror = PTR_ERR(stacksplitdfa);\r\n\t\tgoto fail;\r\n\t}\r\n\r\n\treturn 0;\r\n\r\nfail:\r\n\taa_put_pdb(nullpdb);\r\n\taa_put_dfa(nulldfa);\r\n\tnullpdb = NULL;\r\n\tnulldfa = NULL;\r\n\tstacksplitdfa = NULL;\r\n\r\n\treturn error;\r\n}", ".pparmor_init_sysctl": "static int __init apparmor_init_sysctl(void)\r\n{\r\n\treturn register_sysctl(\"kernel\", apparmor_sysctl_table) ? 0 : -ENOMEM;\r\n}", ".lloc_buffers": "static int __init alloc_buffers(void)\r\n{\r\n\tunion aa_buffer *aa_buf;\r\n\tint i, num;\r\n\r\n\t/*\r\n\t * per cpu set of cached allocated buffers used to help reduce\r\n\t * lock contention\r\n\t */\r\n\tfor_each_possible_cpu(i) {\r\n\t\tper_cpu(aa_local_buffers, i).hold = 0;\r\n\t\tper_cpu(aa_local_buffers, i).count = 0;\r\n\t\tINIT_LIST_HEAD(&per_cpu(aa_local_buffers, i).head);\r\n\t}\r\n\t/*\r\n\t * A function may require two buffers at once. Usually the buffers are\r\n\t * used for a short period of time and are shared. On UP kernel buffers\r\n\t * two should be enough, with more CPUs it is possible that more\r\n\t * buffers will be used simultaneously. The preallocated pool may grow.\r\n\t * This preallocation has also the side-effect that AppArmor will be\r\n\t * disabled early at boot if aa_g_path_max is extremely high.\r\n\t */\r\n\tif (num_online_cpus() > 1)\r\n\t\tnum = 4 + RESERVE_COUNT;\r\n\telse\r\n\t\tnum = 2 + RESERVE_COUNT;\r\n\r\n\tfor (i = 0; i < num; i++) {\r\n\r\n\t\taa_buf = kmalloc(aa_g_path_max, GFP_KERNEL |\r\n\t\t\t\t __GFP_RETRY_MAYFAIL | __GFP_NOWARN);\r\n\t\tif (!aa_buf) {\r\n\t\t\tdestroy_buffers();\r\n\t\t\treturn -ENOMEM;\r\n\t\t}\r\n\t\taa_put_buffer(aa_buf->buffer);\r\n\t}\r\n\treturn 0;\r\n}", ".et_init_ctx": "static int __init set_init_ctx(void)\r\n{\r\n\tstruct cred *cred = (__force struct cred *)current->real_cred;\r\n\r\n\tset_cred_label(cred, aa_get_label(ns_unconfined(root_ns)));\r\n\r\n\treturn 0;\r\n}", ".a_teardown_dfa_engine": "static void __init aa_teardown_dfa_engine(void)\r\n{\r\n\taa_put_dfa(stacksplitdfa);\r\n\taa_put_dfa(nulldfa);\r\n\taa_put_pdb(nullpdb);\r\n\tnullpdb = NULL;\r\n\tstacksplitdfa = NULL;\r\n\tnulldfa = NULL;\r\n}"}, "callee": {".ommon_perm_cond": "static int common_perm_cond(const char *op, const struct path *path, u32 mask)\r\n{\r\n\tvfsuid_t vfsuid = i_uid_into_vfsuid(mnt_idmap(path->mnt),\r\n\t\t\t\t\t    d_backing_inode(path->dentry));\r\n\tstruct path_cond cond = {\r\n\t\tvfsuid_into_kuid(vfsuid),\r\n\t\td_backing_inode(path->dentry)->i_mode\r\n\t};\r\n\r\n\tif (!path_mediated_fs(path->dentry))\r\n\t\treturn 0;\r\n\r\n\treturn common_perm(op, path, mask, &cond);\r\n}", ".ommon_perm_dir_dentry": "static int common_perm_dir_dentry(const char *op, const struct path *dir,\r\n\t\t\t\t  struct dentry *dentry, u32 mask,\r\n\t\t\t\t  struct path_cond *cond)\r\n{\r\n\tstruct path path = { .mnt = dir->mnt, .dentry = dentry };\r\n\r\n\treturn common_perm(op, &path, mask, cond);\r\n}", ".pparmor_path_truncate": "static int apparmor_path_truncate(const struct path *path)\r\n{\r\n\treturn common_perm_cond(OP_TRUNC, path, MAY_WRITE | AA_MAY_SETATTR);\r\n}", ".pparmor_path_chmod": "static int apparmor_path_chmod(const struct path *path, umode_t mode)\r\n{\r\n\treturn common_perm_cond(OP_CHMOD, path, AA_MAY_CHMOD);\r\n}", ".pparmor_path_chown": "static int apparmor_path_chown(const struct path *path, kuid_t uid, kgid_t gid)\r\n{\r\n\treturn common_perm_cond(OP_CHOWN, path, AA_MAY_CHOWN);\r\n}", ".pparmor_inode_getattr": "static int apparmor_inode_getattr(const struct path *path)\r\n{\r\n\treturn common_perm_cond(OP_GETATTR, path, AA_MAY_GETATTR);\r\n}", ".pparmor_path_mkdir": "static int apparmor_path_mkdir(const struct path *dir, struct dentry *dentry,\r\n\t\t\t       umode_t mode)\r\n{\r\n\treturn common_perm_create(OP_MKDIR, dir, dentry, AA_MAY_CREATE,\r\n\t\t\t\t  S_IFDIR);\r\n}", ".pparmor_path_mknod": "static int apparmor_path_mknod(const struct path *dir, struct dentry *dentry,\r\n\t\t\t       umode_t mode, unsigned int dev)\r\n{\r\n\treturn common_perm_create(OP_MKNOD, dir, dentry, AA_MAY_CREATE, mode);\r\n}", ".pparmor_path_symlink": "static int apparmor_path_symlink(const struct path *dir, struct dentry *dentry,\r\n\t\t\t\t const char *old_name)\r\n{\r\n\treturn common_perm_create(OP_SYMLINK, dir, dentry, AA_MAY_CREATE,\r\n\t\t\t\t  S_IFLNK);\r\n}", ".ommon_perm_rm": "static int common_perm_rm(const char *op, const struct path *dir,\r\n\t\t\t  struct dentry *dentry, u32 mask)\r\n{\r\n\tstruct inode *inode = d_backing_inode(dentry);\r\n\tstruct path_cond cond = { };\r\n\tvfsuid_t vfsuid;\r\n\r\n\tif (!inode || !path_mediated_fs(dentry))\r\n\t\treturn 0;\r\n\r\n\tvfsuid = i_uid_into_vfsuid(mnt_idmap(dir->mnt), inode);\r\n\tcond.uid = vfsuid_into_kuid(vfsuid);\r\n\tcond.mode = inode->i_mode;\r\n\r\n\treturn common_perm_dir_dentry(op, dir, dentry, mask, &cond);\r\n}", ".ommon_perm_create": "static int common_perm_create(const char *op, const struct path *dir,\r\n\t\t\t      struct dentry *dentry, u32 mask, umode_t mode)\r\n{\r\n\tstruct path_cond cond = { current_fsuid(), mode };\r\n\r\n\tif (!path_mediated_fs(dir->dentry))\r\n\t\treturn 0;\r\n\r\n\treturn common_perm_dir_dentry(op, dir, dentry, mask, &cond);\r\n}", ".pparmor_path_unlink": "static int apparmor_path_unlink(const struct path *dir, struct dentry *dentry)\r\n{\r\n\treturn common_perm_rm(OP_UNLINK, dir, dentry, AA_MAY_DELETE);\r\n}", ".pparmor_path_rmdir": "static int apparmor_path_rmdir(const struct path *dir, struct dentry *dentry)\r\n{\r\n\treturn common_perm_rm(OP_RMDIR, dir, dentry, AA_MAY_DELETE);\r\n}", ".pparmor_file_truncate": "static int apparmor_file_truncate(struct file *file)\r\n{\r\n\treturn apparmor_path_truncate(&file->f_path);\r\n}", ".pparmor_file_receive": "static int apparmor_file_receive(struct file *file)\r\n{\r\n\treturn common_file_perm(OP_FRECEIVE, file, aa_map_file_to_perms(file),\r\n\t\t\t\tfalse);\r\n}", ".pparmor_file_permission": "static int apparmor_file_permission(struct file *file, int mask)\r\n{\r\n\treturn common_file_perm(OP_FPERM, file, mask, false);\r\n}", ".pparmor_file_lock": "static int apparmor_file_lock(struct file *file, unsigned int cmd)\r\n{\r\n\tu32 mask = AA_MAY_LOCK;\r\n\r\n\tif (cmd == F_WRLCK)\r\n\t\tmask |= MAY_WRITE;\r\n\r\n\treturn common_file_perm(OP_FLOCK, file, mask, false);\r\n}", ".ommon_mmap": "static int common_mmap(const char *op, struct file *file, unsigned long prot,\r\n\t\t       unsigned long flags, bool in_atomic)\r\n{\r\n\tint mask = 0;\r\n\r\n\tif (!file || !file_ctx(file))\r\n\t\treturn 0;\r\n\r\n\tif (prot & PROT_READ)\r\n\t\tmask |= MAY_READ;\r\n\t/*\r\n\t * Private mappings don't require write perms since they don't\r\n\t * write back to the files\r\n\t */\r\n\tif ((prot & PROT_WRITE) && !(flags & MAP_PRIVATE))\r\n\t\tmask |= MAY_WRITE;\r\n\tif (prot & PROT_EXEC)\r\n\t\tmask |= AA_EXEC_MMAP;\r\n\r\n\treturn common_file_perm(op, file, mask, in_atomic);\r\n}", ".pparmor_mmap_file": "static int apparmor_mmap_file(struct file *file, unsigned long reqprot,\r\n\t\t\t      unsigned long prot, unsigned long flags)\r\n{\r\n\treturn common_mmap(OP_FMMAP, file, prot, flags, GFP_ATOMIC);\r\n}", ".pparmor_file_mprotect": "static int apparmor_file_mprotect(struct vm_area_struct *vma,\r\n\t\t\t\t  unsigned long reqprot, unsigned long prot)\r\n{\r\n\treturn common_mmap(OP_FMPROT, vma->vm_file, prot,\r\n\t\t\t   !(vma->vm_flags & VM_SHARED) ? MAP_PRIVATE : 0,\r\n\t\t\t   false);\r\n}", ".rofile_uring": "static int profile_uring(struct aa_profile *profile, u32 request,\r\n\t\t\t struct aa_label *new, int cap,\r\n\t\t\t struct apparmor_audit_data *ad)\r\n{\r\n\tunsigned int state;\r\n\tstruct aa_ruleset *rules;\r\n\tint error = 0;\r\n\r\n\tAA_BUG(!profile);\r\n\r\n\trules = profile->label.rules[0];\r\n\tstate = RULE_MEDIATES(rules, AA_CLASS_IO_URING);\r\n\tif (state) {\r\n\t\tstruct aa_perms perms = { };\r\n\r\n\t\tif (new) {\r\n\t\t\taa_label_match(profile, rules, new, state,\r\n\t\t\t\t       false, request, &perms);\r\n\t\t} else {\r\n\t\t\tperms = *aa_lookup_perms(rules->policy, state);\r\n\t\t}\r\n\t\taa_apply_modes_to_perms(profile, &perms);\r\n\t\terror = aa_check_perms(profile, &perms, request, ad,\r\n\t\t\t\t       audit_uring_cb);\r\n\t}\r\n\r\n\treturn error;\r\n}", ".pparmor_uring_override_creds": "static int apparmor_uring_override_creds(const struct cred *new)\r\n{\r\n\tstruct aa_profile *profile;\r\n\tstruct aa_label *label;\r\n\tint error;\r\n\tbool needput;\r\n\tDEFINE_AUDIT_DATA(ad, LSM_AUDIT_DATA_NONE, AA_CLASS_IO_URING,\r\n\t\t\t  OP_URING_OVERRIDE);\r\n\r\n\tad.uring.target = cred_label(new);\r\n\tlabel = __begin_current_label_crit_section(&needput);\r\n\terror = fn_for_each(label, profile,\r\n\t\t\tprofile_uring(profile, AA_MAY_OVERRIDE_CRED,\r\n\t\t\t\t      cred_label(new), CAP_SYS_ADMIN, &ad));\r\n\t__end_current_label_crit_section(label, needput);\r\n\r\n\treturn error;\r\n}", ".pparmor_uring_sqpoll": "static int apparmor_uring_sqpoll(void)\r\n{\r\n\tstruct aa_profile *profile;\r\n\tstruct aa_label *label;\r\n\tint error;\r\n\tbool needput;\r\n\tDEFINE_AUDIT_DATA(ad, LSM_AUDIT_DATA_NONE, AA_CLASS_IO_URING,\r\n\t\t\t  OP_URING_SQPOLL);\r\n\r\n\tlabel = __begin_current_label_crit_section(&needput);\r\n\terror = fn_for_each(label, profile,\r\n\t\t\tprofile_uring(profile, AA_MAY_CREATE_SQPOLL,\r\n\t\t\t\t      NULL, CAP_SYS_ADMIN, &ad));\r\n\t__end_current_label_crit_section(label, needput);\r\n\r\n\treturn error;\r\n}", ".pparmor_setselfattr": "static int apparmor_setselfattr(unsigned int attr, struct lsm_ctx *ctx,\r\n\t\t\t\tu32 size, u32 flags)\r\n{\r\n\tint rc;\r\n\r\n\tif (attr != LSM_ATTR_CURRENT && attr != LSM_ATTR_EXEC)\r\n\t\treturn -EOPNOTSUPP;\r\n\r\n\trc = do_setattr(attr, ctx->ctx, ctx->ctx_len);\r\n\tif (rc > 0)\r\n\t\treturn 0;\r\n\treturn rc;\r\n}", ".pparmor_setprocattr": "static int apparmor_setprocattr(const char *name, void *value,\r\n\t\t\t\tsize_t size)\r\n{\r\n\tint attr = lsm_name_to_attr(name);\r\n\r\n\tif (attr)\r\n\t\treturn do_setattr(attr, value, size);\r\n\treturn -EINVAL;\r\n}", ".pparmor_unix_stream_connect": "static int apparmor_unix_stream_connect(struct sock *sk, struct sock *peer_sk,\r\n\t\t\t\t\tstruct sock *newsk)\r\n{\r\n\tstruct aa_sk_ctx *sk_ctx = aa_sock(sk);\r\n\tstruct aa_sk_ctx *peer_ctx = aa_sock(peer_sk);\r\n\tstruct aa_sk_ctx *new_ctx = aa_sock(newsk);\r\n\tstruct aa_label *label;\r\n\tint error;\r\n\tbool needput;\r\n\r\n\tlabel = __begin_current_label_crit_section(&needput);\r\n\terror = unix_connect_perm(current_cred(), label, sk, peer_sk);\r\n\t__end_current_label_crit_section(label, needput);\r\n\r\n\tif (error)\r\n\t\treturn error;\r\n\r\n\t/* newsk doesn't go through post_create, but does go through\r\n\t * security_sk_alloc()\r\n\t */\r\n\trcu_assign_pointer(new_ctx->label,\r\n\t\t\t   aa_get_label(rcu_dereference_protected(peer_ctx->label,\r\n\t\t\t\t\t\t\t\t  true)));\r\n\r\n\t/* Cross reference the peer labels for SO_PEERSEC */\r\n\tunix_connect_peers(sk_ctx, new_ctx);\r\n\r\n\treturn 0;\r\n}", ".pparmor_socket_socketpair": "static int apparmor_socket_socketpair(struct socket *socka,\r\n\t\t\t\t      struct socket *sockb)\r\n{\r\n\tstruct aa_sk_ctx *a_ctx = aa_sock(socka->sk);\r\n\tstruct aa_sk_ctx *b_ctx = aa_sock(sockb->sk);\r\n\tstruct aa_label *label;\r\n\r\n\t/* socks not live yet - initial values set in sk_alloc */\r\n\tlabel = begin_current_label_crit_section();\r\n\tif (rcu_access_pointer(a_ctx->label) != label) {\r\n\t\tAA_BUG(\"a_ctx != label\");\r\n\t\taa_put_label(rcu_dereference_protected(a_ctx->label, true));\r\n\t\trcu_assign_pointer(a_ctx->label, aa_get_label(label));\r\n\t}\r\n\tif (rcu_access_pointer(b_ctx->label) != label) {\r\n\t\tAA_BUG(\"b_ctx != label\");\r\n\t\taa_put_label(rcu_dereference_protected(b_ctx->label, true));\r\n\t\trcu_assign_pointer(b_ctx->label, aa_get_label(label));\r\n\t}\r\n\r\n\tif (socka->sk->sk_family == PF_UNIX) {\r\n\t\t/* unix socket pairs by-pass unix_stream_connect */\r\n\t\tunix_connect_peers(a_ctx, b_ctx);\r\n\t}\r\n\tend_current_label_crit_section(label);\r\n\r\n\treturn 0;\r\n}", ".pparmor_socket_sendmsg": "static int apparmor_socket_sendmsg(struct socket *sock,\r\n\t\t\t\t   struct msghdr *msg, int size)\r\n{\r\n\treturn aa_sock_msg_perm(OP_SENDMSG, AA_MAY_SEND, sock, msg, size);\r\n}", ".pparmor_socket_recvmsg": "static int apparmor_socket_recvmsg(struct socket *sock,\r\n\t\t\t\t   struct msghdr *msg, int size, int flags)\r\n{\r\n\treturn aa_sock_msg_perm(OP_RECVMSG, AA_MAY_RECEIVE, sock, msg, size);\r\n}", ".pparmor_socket_getsockname": "static int apparmor_socket_getsockname(struct socket *sock)\r\n{\r\n\treturn aa_sock_perm(OP_GETSOCKNAME, AA_MAY_GETATTR, sock);\r\n}", ".pparmor_socket_getpeername": "static int apparmor_socket_getpeername(struct socket *sock)\r\n{\r\n\treturn aa_sock_perm(OP_GETPEERNAME, AA_MAY_GETATTR, sock);\r\n}", ".pparmor_socket_shutdown": "static int apparmor_socket_shutdown(struct socket *sock, int how)\r\n{\r\n\treturn aa_sock_perm(OP_SHUTDOWN, AA_MAY_SHUTDOWN, sock);\r\n}", ".pparmor_socket_getsockopt": "static int apparmor_socket_getsockopt(struct socket *sock, int level,\r\n\t\t\t\t      int optname)\r\n{\r\n\treturn aa_sock_opt_perm(OP_GETSOCKOPT, AA_MAY_GETOPT, sock,\r\n\t\t\t\tlevel, optname);\r\n}", ".pparmor_socket_setsockopt": "static int apparmor_socket_setsockopt(struct socket *sock, int level,\r\n\t\t\t\t      int optname)\r\n{\r\n\treturn aa_sock_opt_perm(OP_SETSOCKOPT, AA_MAY_SETOPT, sock,\r\n\t\t\t\tlevel, optname);\r\n}", ".lloc_buffers": "static int __init alloc_buffers(void)\r\n{\r\n\tunion aa_buffer *aa_buf;\r\n\tint i, num;\r\n\r\n\t/*\r\n\t * per cpu set of cached allocated buffers used to help reduce\r\n\t * lock contention\r\n\t */\r\n\tfor_each_possible_cpu(i) {\r\n\t\tper_cpu(aa_local_buffers, i).hold = 0;\r\n\t\tper_cpu(aa_local_buffers, i).count = 0;\r\n\t\tINIT_LIST_HEAD(&per_cpu(aa_local_buffers, i).head);\r\n\t}\r\n\t/*\r\n\t * A function may require two buffers at once. Usually the buffers are\r\n\t * used for a short period of time and are shared. On UP kernel buffers\r\n\t * two should be enough, with more CPUs it is possible that more\r\n\t * buffers will be used simultaneously. The preallocated pool may grow.\r\n\t * This preallocation has also the side-effect that AppArmor will be\r\n\t * disabled early at boot if aa_g_path_max is extremely high.\r\n\t */\r\n\tif (num_online_cpus() > 1)\r\n\t\tnum = 4 + RESERVE_COUNT;\r\n\telse\r\n\t\tnum = 2 + RESERVE_COUNT;\r\n\r\n\tfor (i = 0; i < num; i++) {\r\n\r\n\t\taa_buf = kmalloc(aa_g_path_max, GFP_KERNEL |\r\n\t\t\t\t __GFP_RETRY_MAYFAIL | __GFP_NOWARN);\r\n\t\tif (!aa_buf) {\r\n\t\t\tdestroy_buffers();\r\n\t\t\treturn -ENOMEM;\r\n\t\t}\r\n\t\taa_put_buffer(aa_buf->buffer);\r\n\t}\r\n\treturn 0;\r\n}", ".pparmor_init": "static int __init apparmor_init(void)\r\n{\r\n\tint error;\r\n\r\n\terror = aa_setup_dfa_engine();\r\n\tif (error) {\r\n\t\tAA_ERROR(\"Unable to setup dfa engine\\n\");\r\n\t\tgoto alloc_out;\r\n\t}\r\n\r\n\terror = aa_alloc_root_ns();\r\n\tif (error) {\r\n\t\tAA_ERROR(\"Unable to allocate default profile namespace\\n\");\r\n\t\tgoto alloc_out;\r\n\t}\r\n\r\n\terror = apparmor_init_sysctl();\r\n\tif (error) {\r\n\t\tAA_ERROR(\"Unable to register sysctls\\n\");\r\n\t\tgoto alloc_out;\r\n\r\n\t}\r\n\r\n\terror = alloc_buffers();\r\n\tif (error) {\r\n\t\tAA_ERROR(\"Unable to allocate work buffers\\n\");\r\n\t\tgoto alloc_out;\r\n\t}\r\n\r\n\terror = set_init_ctx();\r\n\tif (error) {\r\n\t\tAA_ERROR(\"Failed to set context on init task\\n\");\r\n\t\taa_free_root_ns();\r\n\t\tgoto buffers_out;\r\n\t}\r\n\tsecurity_add_hooks(apparmor_hooks, ARRAY_SIZE(apparmor_hooks),\r\n\t\t\t\t&apparmor_lsmid);\r\n\r\n\t/* Report that AppArmor successfully initialized */\r\n\tapparmor_initialized = 1;\r\n\tif (aa_g_profile_mode == APPARMOR_COMPLAIN)\r\n\t\taa_info_message(\"AppArmor initialized: complain mode enabled\");\r\n\telse if (aa_g_profile_mode == APPARMOR_KILL)\r\n\t\taa_info_message(\"AppArmor initialized: kill mode enabled\");\r\n\telse\r\n\t\taa_info_message(\"AppArmor initialized\");\r\n\r\n\treturn error;\r\n\r\nbuffers_out:\r\n\tdestroy_buffers();\r\nalloc_out:\r\n\taa_destroy_aafs();\r\n\taa_teardown_dfa_engine();\r\n\r\n\tapparmor_enabled = false;\r\n\treturn error;\r\n}"}, "function_name": "apparmor_init"}
{"function_id": null, "caller": {".edia_device_kpad_to_upad": "static void media_device_kpad_to_upad(const struct media_pad *kpad,\r\n\t\t\t\t      struct media_pad_desc *upad)\r\n{\r\n\tupad->entity = media_entity_id(kpad->entity);\r\n\tupad->index = kpad->index;\r\n\tupad->flags = kpad->flags;\r\n}"}, "callee": {".edia_device_enum_links": "static long media_device_enum_links(struct media_device *mdev, void *arg)\r\n{\r\n\tstruct media_links_enum *links = arg;\r\n\tstruct media_entity *entity;\r\n\r\n\tentity = find_entity(mdev, links->entity);\r\n\tif (entity == NULL)\r\n\t\treturn -EINVAL;\r\n\r\n\tif (links->pads) {\r\n\t\tunsigned int p;\r\n\r\n\t\tfor (p = 0; p < entity->num_pads; p++) {\r\n\t\t\tstruct media_pad_desc pad;\r\n\r\n\t\t\tmemset(&pad, 0, sizeof(pad));\r\n\t\t\tmedia_device_kpad_to_upad(&entity->pads[p], &pad);\r\n\t\t\tif (copy_to_user(&links->pads[p], &pad, sizeof(pad)))\r\n\t\t\t\treturn -EFAULT;\r\n\t\t}\r\n\t}\r\n\r\n\tif (links->links) {\r\n\t\tstruct media_link *link;\r\n\t\tstruct media_link_desc __user *ulink_desc = links->links;\r\n\r\n\t\tlist_for_each_entry(link, &entity->links, list) {\r\n\t\t\tstruct media_link_desc klink_desc;\r\n\r\n\t\t\t/* Ignore backlinks. */\r\n\t\t\tif (link->source->entity != entity)\r\n\t\t\t\tcontinue;\r\n\t\t\tmemset(&klink_desc, 0, sizeof(klink_desc));\r\n\t\t\tmedia_device_kpad_to_upad(link->source,\r\n\t\t\t\t\t\t  &klink_desc.source);\r\n\t\t\tmedia_device_kpad_to_upad(link->sink,\r\n\t\t\t\t\t\t  &klink_desc.sink);\r\n\t\t\tklink_desc.flags = link->flags;\r\n\t\t\tif (copy_to_user(ulink_desc, &klink_desc,\r\n\t\t\t\t\t sizeof(*ulink_desc)))\r\n\t\t\t\treturn -EFAULT;\r\n\t\t\tulink_desc++;\r\n\t\t}\r\n\t}\r\n\tmemset(links->reserved, 0, sizeof(links->reserved));\r\n\r\n\treturn 0;\r\n}"}, "function_name": "__media_device_usb_init"}
{"function_id": null, "caller": {".elease_iommu_mapping": "static void release_iommu_mapping(struct kref *kref)\r\n{\r\n\tint i;\r\n\tstruct dma_iommu_mapping *mapping =\r\n\t\tcontainer_of(kref, struct dma_iommu_mapping, kref);\r\n\r\n\tiommu_domain_free(mapping->domain);\r\n\tfor (i = 0; i < mapping->nr_bitmaps; i++)\r\n\t\tkfree(mapping->bitmaps[i]);\r\n\tkfree(mapping->bitmaps);\r\n\tkfree(mapping);\r\n}", ".rm_iommu_release_mapping": "void arm_iommu_release_mapping(struct dma_iommu_mapping *mapping)\r\n{\r\n\tif (mapping)\r\n\t\tkref_put(&mapping->kref, release_iommu_mapping);\r\n}", ".rm_iommu_detach_device": "void arm_iommu_detach_device(struct device *dev)\r\n{\r\n\tstruct dma_iommu_mapping *mapping;\r\n\r\n\tmapping = to_dma_iommu_mapping(dev);\r\n\tif (!mapping) {\r\n\t\tdev_warn(dev, \"Not attached\\n\");\r\n\t\treturn;\r\n\t}\r\n\r\n\tiommu_detach_device(mapping->domain, dev);\r\n\tkref_put(&mapping->kref, release_iommu_mapping);\r\n\tto_dma_iommu_mapping(dev) = NULL;\r\n\tset_dma_ops(dev, NULL);\r\n\r\n\tpr_debug(\"Detached IOMMU controller from %s device.\\n\", dev_name(dev));\r\n}", ".rm_setup_iommu_dma_ops": "static void arm_setup_iommu_dma_ops(struct device *dev)\r\n{\r\n\tstruct dma_iommu_mapping *mapping;\r\n\tu64 dma_base = 0, size = 1ULL << 32;\r\n\r\n\tif (dev->dma_range_map) {\r\n\t\tdma_base = dma_range_map_min(dev->dma_range_map);\r\n\t\tsize = dma_range_map_max(dev->dma_range_map) - dma_base;\r\n\t}\r\n\tmapping = arm_iommu_create_mapping(dev, dma_base, size);\r\n\tif (IS_ERR(mapping)) {\r\n\t\tpr_warn(\"Failed to create %llu-byte IOMMU mapping for device %s\\n\",\r\n\t\t\t\tsize, dev_name(dev));\r\n\t\treturn;\r\n\t}\r\n\r\n\tif (__arm_iommu_attach_device(dev, mapping)) {\r\n\t\tpr_warn(\"Failed to attached device %s to IOMMU_mapping\\n\",\r\n\t\t\t\tdev_name(dev));\r\n\t\tarm_iommu_release_mapping(mapping);\r\n\t\treturn;\r\n\t}\r\n\r\n\tset_dma_ops(dev, &iommu_ops);\r\n}", ".rm_teardown_iommu_dma_ops": "static void arm_teardown_iommu_dma_ops(struct device *dev)\r\n{\r\n\tstruct dma_iommu_mapping *mapping = to_dma_iommu_mapping(dev);\r\n\r\n\tif (!mapping)\r\n\t\treturn;\r\n\r\n\tarm_iommu_detach_device(dev);\r\n\tarm_iommu_release_mapping(mapping);\r\n}"}, "callee": {".rm_iommu_release_mapping": "void arm_iommu_release_mapping(struct dma_iommu_mapping *mapping)\r\n{\r\n\tif (mapping)\r\n\t\tkref_put(&mapping->kref, release_iommu_mapping);\r\n}", ".rm_iommu_detach_device": "void arm_iommu_detach_device(struct device *dev)\r\n{\r\n\tstruct dma_iommu_mapping *mapping;\r\n\r\n\tmapping = to_dma_iommu_mapping(dev);\r\n\tif (!mapping) {\r\n\t\tdev_warn(dev, \"Not attached\\n\");\r\n\t\treturn;\r\n\t}\r\n\r\n\tiommu_detach_device(mapping->domain, dev);\r\n\tkref_put(&mapping->kref, release_iommu_mapping);\r\n\tto_dma_iommu_mapping(dev) = NULL;\r\n\tset_dma_ops(dev, NULL);\r\n\r\n\tpr_debug(\"Detached IOMMU controller from %s device.\\n\", dev_name(dev));\r\n}", ".rm_setup_iommu_dma_ops": "static void arm_setup_iommu_dma_ops(struct device *dev)\r\n{\r\n\tstruct dma_iommu_mapping *mapping;\r\n\tu64 dma_base = 0, size = 1ULL << 32;\r\n\r\n\tif (dev->dma_range_map) {\r\n\t\tdma_base = dma_range_map_min(dev->dma_range_map);\r\n\t\tsize = dma_range_map_max(dev->dma_range_map) - dma_base;\r\n\t}\r\n\tmapping = arm_iommu_create_mapping(dev, dma_base, size);\r\n\tif (IS_ERR(mapping)) {\r\n\t\tpr_warn(\"Failed to create %llu-byte IOMMU mapping for device %s\\n\",\r\n\t\t\t\tsize, dev_name(dev));\r\n\t\treturn;\r\n\t}\r\n\r\n\tif (__arm_iommu_attach_device(dev, mapping)) {\r\n\t\tpr_warn(\"Failed to attached device %s to IOMMU_mapping\\n\",\r\n\t\t\t\tdev_name(dev));\r\n\t\tarm_iommu_release_mapping(mapping);\r\n\t\treturn;\r\n\t}\r\n\r\n\tset_dma_ops(dev, &iommu_ops);\r\n}", ".rm_teardown_iommu_dma_ops": "static void arm_teardown_iommu_dma_ops(struct device *dev)\r\n{\r\n\tstruct dma_iommu_mapping *mapping = to_dma_iommu_mapping(dev);\r\n\r\n\tif (!mapping)\r\n\t\treturn;\r\n\r\n\tarm_iommu_detach_device(dev);\r\n\tarm_iommu_release_mapping(mapping);\r\n}", ".rch_setup_dma_ops": "void arch_setup_dma_ops(struct device *dev, bool coherent)\r\n{\r\n\t/*\r\n\t * Due to legacy code that sets the ->dma_coherent flag from a bus\r\n\t * notifier we can't just assign coherent to the ->dma_coherent flag\r\n\t * here, but instead have to make sure we only set but never clear it\r\n\t * for now.\r\n\t */\r\n\tif (coherent)\r\n\t\tdev->dma_coherent = true;\r\n\r\n\t/*\r\n\t * Don't override the dma_ops if they have already been set. Ideally\r\n\t * this should be the only location where dma_ops are set, remove this\r\n\t * check when all other callers of set_dma_ops will have disappeared.\r\n\t */\r\n\tif (dev->dma_ops)\r\n\t\treturn;\r\n\r\n\tif (device_iommu_mapped(dev))\r\n\t\tarm_setup_iommu_dma_ops(dev);\r\n\r\n\txen_setup_dma_ops(dev);\r\n\tdev->archdata.dma_ops_setup = true;\r\n}", ".rch_teardown_dma_ops": "void arch_teardown_dma_ops(struct device *dev)\r\n{\r\n\tif (!dev->archdata.dma_ops_setup)\r\n\t\treturn;\r\n\r\n\tarm_teardown_iommu_dma_ops(dev);\r\n\t/* Let arch_setup_dma_ops() start again from scratch upon re-probe */\r\n\tset_dma_ops(dev, NULL);\r\n}"}, "function_name": "arch_dma_free"}
{"function_id": null, "caller": {".issect_spoolss_buffer_data": "static int\r\ndissect_spoolss_buffer_data(tvbuff_t *tvb, int offset, packet_info *pinfo,\r\n\t\t\t    proto_tree *tree, dcerpc_info *di, uint8_t *drep)\r\n{\r\n\tBUFFER *b = (BUFFER *)di->private_data;\r\n\tproto_item *item;\r\n\tuint32_t size;\r\n\tconst uint8_t *data;\r\n\r\n\tif (di->conformant_run)\r\n\t\treturn offset;\r\n\r\n\t/* Dissect size and data */\r\n\r\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, tree, di, drep,\r\n\t\t\t\t    hf_buffer_size, &size);\r\n\r\n\t/* Before going any further, we must ensure the bytes\r\n\t   actually esist in the tvb */\r\n\tif ((uint32_t)tvb_reported_length_remaining(tvb, offset) < size) {\r\n\t\texpert_add_info(pinfo, tree, &ei_buffer_size_too_long);\r\n\t\treturn offset;\r\n\t}\r\n\r\n\toffset = dissect_ndr_uint8s(tvb, offset, pinfo, NULL, di, drep,\r\n\t\t\t\t    hf_buffer_data, size, &data);\r\n\r\n\titem = proto_tree_add_item(\r\n\t\ttree, hf_buffer_data, tvb, offset - size,\r\n\t\tsize, ENC_NA);\r\n\r\n\t/* Return buffer info */\r\n\r\n\tif (b) {\r\n\r\n\t\t/* I'm not sure about this.  Putting the buffer into\r\n\t\t   its own tvb makes sense and the dissection code is\r\n\t\t   much clearer, but the data is a proper subset of\r\n\t\t   the actual tvb.  Not adding the new data source\r\n\t\t   makes the hex display confusing as it switches\r\n\t\t   between the 'DCERPC over SMB' tvb and the buffer\r\n\t\t   tvb with no visual cues as to what is going on. */\r\n\r\n\t\tb->tvb = tvb_new_child_real_data(tvb, data, size, size);\r\n\t\tadd_new_data_source(pinfo, b->tvb, \"SPOOLSS buffer\");\r\n\r\n\t\tb->item = item;\r\n\t\tb->tree = proto_item_add_subtree(item, ett_BUFFER);\r\n\t}\r\n\r\n\treturn offset;\r\n}", ".issect_spoolss_string_parm_data": "static int\r\ndissect_spoolss_string_parm_data(tvbuff_t *tvb, int offset, packet_info *pinfo,\r\n\t\t\t    proto_tree *tree, dcerpc_info *di, uint8_t *drep)\r\n{\r\n\tuint32_t buffer_len, len;\r\n\tchar *s;\r\n\tproto_item *item = NULL;\r\n\r\n\tif (di->conformant_run)\r\n\t\treturn offset;\r\n\r\n\t/* Dissect size and data */\r\n\r\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, tree, di, drep,\r\n\t\t\t\thf_string_parm_size, &buffer_len);\r\n\r\n\ts = tvb_get_stringz_enc(pinfo->pool, tvb, offset, &len, ENC_UTF_16|ENC_LITTLE_ENDIAN);\r\n\r\n\tif (tree && buffer_len) {\r\n\t\ttvb_ensure_bytes_exist(tvb, offset, buffer_len);\r\n\r\n\t\titem = proto_tree_add_string(\r\n\t\t\ttree, hf_string_parm_data, tvb, offset, len, s);\r\n\t}\r\n\toffset += buffer_len;\r\n\r\n\tcol_append_fstr(pinfo->cinfo, COL_INFO, \", %s\", s);\r\n\r\n\t/* Append string to upper level item */\r\n\tif (tree && item) {\r\n\t\titem = item->parent != NULL ? item->parent : item;\r\n\t\tproto_item_append_text(item, \": %s\", s);\r\n\t}\r\n\r\n\treturn offset;\r\n}", ".issect_SYSTEM_TIME": "static int\r\ndissect_SYSTEM_TIME(tvbuff_t *tvb, int offset, packet_info *pinfo,\r\n\t\t    proto_tree *tree, dcerpc_info *di, uint8_t *drep, const char *name,\r\n\t\t    bool add_subtree, char **data)\r\n{\r\n\tproto_item *item = NULL;\r\n\tproto_tree *subtree = tree;\r\n\tuint16_t year, month, day, hour, minute, second, millisecond;\r\n\tchar *str;\r\n\r\n\tif (add_subtree) {\r\n\t\tsubtree = proto_tree_add_subtree(tree, tvb, offset, 16, ett_SYSTEM_TIME, &item, name);\r\n\t}\r\n\r\n\toffset = dissect_ndr_uint16(\r\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_time_year, &year);\r\n\r\n\toffset = dissect_ndr_uint16(\r\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_time_month, &month);\r\n\r\n\toffset = dissect_ndr_uint16(\r\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_time_dow, NULL);\r\n\r\n\toffset = dissect_ndr_uint16(\r\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_time_day, &day);\r\n\r\n\toffset = dissect_ndr_uint16(\r\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_time_hour, &hour);\r\n\r\n\toffset = dissect_ndr_uint16(\r\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_time_minute, &minute);\r\n\r\n\toffset = dissect_ndr_uint16(\r\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_time_second, &second);\r\n\r\n\toffset = dissect_ndr_uint16(\r\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_time_msec, &millisecond);\r\n\r\n\tstr = wmem_strdup_printf(pinfo->pool,\r\n\t\t\t      \"%d/%02d/%02d %02d:%02d:%02d.%03d\",\r\n\t\t\t      year, month, day, hour, minute, second,\r\n\t\t\t      millisecond);\r\n\r\n\tif (add_subtree)\r\n\t\tproto_item_append_text(item, \": %s\", str);\r\n\r\n\tif (data)\r\n\t\t*data = str;\r\n\r\n\treturn offset;\r\n}", ".issect_printerdata_data": "static int\r\ndissect_printerdata_data(tvbuff_t *tvb, int offset,\r\n\t\t\t\t    packet_info *pinfo, proto_tree *tree,\r\n\t\t\t\t    dcerpc_info *di, uint8_t *drep, uint32_t type)\r\n{\r\n\tproto_item *item, *hidden_item;\r\n\tproto_tree *subtree;\r\n\tuint32_t size;\r\n\r\n\tsubtree = proto_tree_add_subtree(tree, tvb, offset, 0, ett_printerdata_data, &item, \"Data\");\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_printerdata_size, &size);\r\n\r\n\tif (size) {\r\n\r\n\t\toffset = dissect_ndr_uint8s(\r\n\t\t\ttvb, offset, pinfo, subtree, di, drep,\r\n\t\t\thf_printerdata_data, size, NULL);\r\n\r\n\t\tswitch(type) {\r\n\t\tcase DCERPC_REG_SZ: {\r\n\t\t\tconst uint8_t *data;\r\n\r\n\t\t\thidden_item = proto_tree_add_item_ret_string(\r\n\t\t\t\ttree, hf_printerdata_data_sz, tvb,\r\n\t\t\t\toffset - size, size, ENC_UTF_16|ENC_LITTLE_ENDIAN, pinfo->pool, &data);\r\n\t\t\tproto_item_set_hidden(hidden_item);\r\n\r\n\t\t\tproto_item_append_text(item, \": %s\", data);\r\n\r\n\t\t\tcol_append_fstr(pinfo->cinfo, COL_INFO, \" = %s\", data);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tcase DCERPC_REG_DWORD: {\r\n\t\t\tuint32_t data = tvb_get_letohl(tvb, offset - size);\r\n\r\n\t\t\tproto_item_append_text(item, \": 0x%08x\", data);\r\n\r\n\t\t\tcol_append_fstr(\r\n\t\t\t\t\tpinfo->cinfo, COL_INFO, \" = 0x%08x\",\r\n\t\t\t\t\tdata);\r\n\r\n\t\t\thidden_item = proto_tree_add_uint(\r\n\t\t\t\ttree, hf_printerdata_data_dword, tvb,\r\n\t\t\t\toffset - size, 4, data);\r\n\t\t\tproto_item_set_hidden(hidden_item);\r\n\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tcase DCERPC_REG_BINARY:\r\n\t\t\tcol_append_str(\r\n\t\t\t\t\tpinfo->cinfo, COL_INFO,\r\n\t\t\t\t\t\" = <binary data>\");\r\n\t\t\tbreak;\r\n\r\n\t\tdefault:\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\r\n\tproto_item_set_len(item, size + 4);\r\n\r\n\treturn offset;\r\n}", ".issect_spoolss_uint16uni": "static int\r\ndissect_spoolss_uint16uni(tvbuff_t *tvb, int offset, packet_info *pinfo _U_,\r\n\t\t\t  proto_tree *tree, uint8_t *drep _U_, char **data,\r\n\t\t\t  int hf_name)\r\n{\r\n\tint len, remaining;\r\n\tchar *text;\r\n\r\n\toffset = WS_ROUNDUP_2(offset);\r\n\r\n\t/* Get remaining data in buffer as a string */\r\n\r\n\tremaining = tvb_reported_length_remaining(tvb, offset);\r\n\tif (remaining <= 0) {\r\n\t\tif (data)\r\n\t\t\t*data = wmem_strdup(pinfo->pool, \"\");\r\n\t\treturn offset;\r\n\t}\r\n\r\n\ttext = tvb_get_string_enc(pinfo->pool, tvb, offset, remaining, ENC_UTF_16|ENC_LITTLE_ENDIAN);\r\n\tlen = (int)strlen(text);\r\n\r\n\tproto_tree_add_string(tree, hf_name, tvb, offset, len * 2, text);\r\n\r\n\tif (data)\r\n\t\t*data = text;\r\n\r\n\treturn offset + (len + 1) * 2;\r\n}", ".issect_DEVMODE_fields": "static int\r\ndissect_DEVMODE_fields(tvbuff_t *tvb, int offset, packet_info *pinfo,\r\n\t\t       proto_tree *tree, dcerpc_info *di, uint8_t *drep, uint32_t *pdata)\r\n{\r\n\tuint32_t fields;\r\n\tproto_item *hidden_item;\r\n\r\n\tstatic int * const hf_fields[] = {\r\n\t\t&hf_devmode_fields_orientation,\r\n\t\t&hf_devmode_fields_papersize,\r\n\t\t&hf_devmode_fields_paperlength,\r\n\t\t&hf_devmode_fields_paperwidth,\r\n\t\t&hf_devmode_fields_scale,\r\n\t\t&hf_devmode_fields_position,\r\n\t\t&hf_devmode_fields_nup,\r\n\t\t&hf_devmode_fields_copies,\r\n\t\t&hf_devmode_fields_defaultsource,\r\n\t\t&hf_devmode_fields_printquality,\r\n\t\t&hf_devmode_fields_color,\r\n\t\t&hf_devmode_fields_duplex,\r\n\t\t&hf_devmode_fields_yresolution,\r\n\t\t&hf_devmode_fields_ttoption,\r\n\t\t&hf_devmode_fields_collate,\r\n\t\t&hf_devmode_fields_formname,\r\n\t\t&hf_devmode_fields_logpixels,\r\n\t\t&hf_devmode_fields_bitsperpel,\r\n\t\t&hf_devmode_fields_pelswidth,\r\n\t\t&hf_devmode_fields_pelsheight,\r\n\t\t&hf_devmode_fields_displayflags,\r\n\t\t&hf_devmode_fields_displayfrequency,\r\n\t\t&hf_devmode_fields_icmmethod,\r\n\t\t&hf_devmode_fields_icmintent,\r\n\t\t&hf_devmode_fields_mediatype,\r\n\t\t&hf_devmode_fields_dithertype,\r\n\t\t&hf_devmode_fields_panningwidth,\r\n\t\t&hf_devmode_fields_panningheight,\r\n\t\tNULL\r\n\t};\r\n\r\n\thidden_item = proto_tree_add_uint(\r\n\t\ttree, hf_devmode, tvb, offset, 0, 1);\r\n\tproto_item_set_hidden(hidden_item);\r\n\r\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, NULL, di, drep, -1, &fields);\r\n\r\n\tproto_tree_add_bitmask_value_with_flags(tree, tvb, offset - 4, hf_devmode_fields,\r\n\t\t\t\t\tett_DEVMODE_fields, hf_fields, fields, BMT_NO_APPEND);\r\n\r\n\tif (pdata)\r\n\t\t*pdata = fields;\r\n\r\n\treturn offset;\r\n}", ".issect_DEVMODE": "static int\r\ndissect_DEVMODE(tvbuff_t *tvb, int offset, packet_info *pinfo,\r\n\t\t\t   proto_tree *tree, dcerpc_info *di, uint8_t *drep)\r\n{\r\n\tproto_item *item;\r\n\tproto_tree *subtree;\r\n\tuint16_t driver_extra;\r\n\tint16_t print_quality;\r\n\tuint32_t fields;\r\n\tint struct_start = offset;\r\n\r\n\tif (di->conformant_run)\r\n\t\treturn offset;\r\n\r\n\tsubtree = proto_tree_add_subtree(tree, tvb, offset, 0, ett_DEVMODE, &item, \"Devicemode\");\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_devmode_size,\r\n\t\tNULL);\r\n\r\n\t/* The device name is stored in a 32-wchar buffer */\r\n\r\n\tdissect_spoolss_uint16uni(tvb, offset, pinfo, subtree, drep, NULL, hf_devmode_devicename);\r\n\toffset += 64;\r\n\r\n\toffset = dissect_ndr_uint16(\r\n\t\ttvb, offset, pinfo, subtree, di, drep,\r\n\t\thf_devmode_spec_version, NULL);\r\n\r\n\toffset = dissect_ndr_uint16(\r\n\t\ttvb, offset, pinfo, subtree, di, drep,\r\n\t\thf_devmode_driver_version, NULL);\r\n\r\n\toffset = dissect_ndr_uint16(\r\n\t\ttvb, offset, pinfo, subtree, di, drep,\r\n\t\thf_devmode_size2, NULL);\r\n\r\n\toffset = dissect_ndr_uint16(\r\n\t\ttvb, offset, pinfo, subtree, di, drep,\r\n\t\thf_devmode_driver_extra_len, &driver_extra);\r\n\r\n\toffset = dissect_DEVMODE_fields(\r\n\t\ttvb, offset, pinfo, subtree, di, drep, &fields);\r\n\r\n\toffset = dissect_ndr_uint16(\r\n\t\ttvb, offset, pinfo, subtree, di, drep,\r\n\t\thf_devmode_orientation, NULL);\r\n\r\n\toffset = dissect_ndr_uint16(\r\n\t\ttvb, offset, pinfo, subtree, di, drep,\r\n\t\thf_devmode_paper_size, NULL);\r\n\r\n\toffset = dissect_ndr_uint16(\r\n\t\ttvb, offset, pinfo, subtree, di, drep,\r\n\t\thf_devmode_paper_length, NULL);\r\n\r\n\toffset = dissect_ndr_uint16(\r\n\t\ttvb, offset, pinfo, subtree, di, drep,\r\n\t\thf_devmode_paper_width, NULL);\r\n\r\n\toffset = dissect_ndr_uint16(\r\n\t\ttvb, offset, pinfo, subtree, di, drep,\r\n\t\thf_devmode_scale, NULL);\r\n\r\n\toffset = dissect_ndr_uint16(\r\n\t\ttvb, offset, pinfo, subtree, di, drep,\r\n\t\thf_devmode_copies, NULL);\r\n\r\n\toffset = dissect_ndr_uint16(\r\n\t\ttvb, offset, pinfo, subtree, di, drep,\r\n\t\thf_devmode_default_source, NULL);\r\n\r\n\toffset = dissect_ndr_uint16(\r\n\t\ttvb, offset, pinfo, NULL, di, drep,\r\n\t\thf_devmode_print_quality, &print_quality);\r\n\r\n\tif (print_quality < 0)\r\n\t\tproto_tree_add_item(\r\n\t\t\tsubtree, hf_devmode_print_quality, tvb,\r\n\t\t\toffset - 2, 2, DREP_ENC_INTEGER(drep));\r\n\telse\r\n\t\tproto_tree_add_uint_format_value(\r\n\t\t\tsubtree, hf_devmode_print_quality, tvb, offset - 4, 4,\r\n\t\t\tprint_quality, \"%d dpi\", print_quality);\r\n\r\n\toffset = dissect_ndr_uint16(\r\n\t\ttvb, offset, pinfo, subtree, di, drep,\r\n\t\thf_devmode_color, NULL);\r\n\r\n\toffset = dissect_ndr_uint16(\r\n\t\ttvb, offset, pinfo, subtree, di, drep,\r\n\t\thf_devmode_duplex, NULL);\r\n\r\n\toffset = dissect_ndr_uint16(\r\n\t\ttvb, offset, pinfo, subtree, di, drep,\r\n\t\thf_devmode_y_resolution, NULL);\r\n\r\n\toffset = dissect_ndr_uint16(\r\n\t\ttvb, offset, pinfo, subtree, di, drep,\r\n\t\thf_devmode_tt_option, NULL);\r\n\r\n\toffset = dissect_ndr_uint16(\r\n\t\ttvb, offset, pinfo, subtree, di, drep,\r\n\t\thf_devmode_collate, NULL);\r\n\r\n\tdissect_spoolss_uint16uni(tvb, offset, pinfo, subtree, drep, NULL, hf_devmode_form_name);\r\n\toffset += 64;\r\n\r\n\toffset = dissect_ndr_uint16(\r\n\t\ttvb, offset, pinfo, subtree, di, drep,\r\n\t\thf_devmode_log_pixels, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, subtree, di, drep,\r\n\t\thf_devmode_bits_per_pel, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, subtree, di, drep,\r\n\t\thf_devmode_pels_width, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, subtree, di, drep,\r\n\t\thf_devmode_pels_height, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, subtree, di, drep,\r\n\t\thf_devmode_display_flags, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, subtree, di, drep,\r\n\t\thf_devmode_display_freq, NULL);\r\n\r\n\t/* TODO: Some of the remaining fields are optional.  See\r\n\t   rpc_parse/parse_spoolss.c in the Samba source for details. */\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, subtree, di, drep,\r\n\t\thf_devmode_icm_method, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, subtree, di, drep,\r\n\t\thf_devmode_icm_intent, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, subtree, di, drep,\r\n\t\thf_devmode_media_type, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, subtree, di, drep,\r\n\t\thf_devmode_dither_type, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, subtree, di, drep,\r\n\t\thf_devmode_reserved1, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, subtree, di, drep,\r\n\t\thf_devmode_reserved2, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, subtree, di, drep,\r\n\t\thf_devmode_panning_width, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, subtree, di, drep,\r\n\t\thf_devmode_panning_height, NULL);\r\n\r\n\tif (driver_extra)\r\n\t\toffset = dissect_ndr_uint8s(\r\n\t\t\ttvb, offset, pinfo, subtree, di, drep,\r\n\t\t\thf_devmode_driver_extra, driver_extra, NULL);\r\n\r\n\tproto_item_set_len(item, offset - struct_start);\r\n\r\n\treturn offset;\r\n}", ".issect_spoolss_relstr": "static int\r\ndissect_spoolss_relstr(tvbuff_t *tvb, int offset, packet_info *pinfo,\r\n\t\t       proto_tree *tree, dcerpc_info *di, uint8_t *drep, int hf_index,\r\n\t\t       int struct_start, char **data)\r\n{\r\n\tproto_item *item;\r\n\tproto_tree *subtree;\r\n\tuint32_t relstr_offset, relstr_start, relstr_end;\r\n\tchar *text;\r\n\r\n\t/* Peek ahead to read the string.  We need this for the\r\n\t   proto_tree_add_string() call so filtering will work. */\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, NULL, di, drep, hf_offset, &relstr_offset);\r\n\r\n\trelstr_start = relstr_offset + struct_start;\r\n\r\n\tif (relstr_offset) {\r\n\t\trelstr_end = dissect_spoolss_uint16uni(\r\n\t\t\ttvb, relstr_start, pinfo, NULL, drep, &text, hf_relative_string);\r\n\t} else { \t\t\t/* relstr_offset == 0 is a NULL string */\r\n\t\ttext = wmem_strdup(pinfo->pool, \"\");\r\n\t\trelstr_end = relstr_start;\r\n\t}\r\n\r\n\t/* OK now add the proto item with the string value */\r\n\r\n\titem = proto_tree_add_string(tree, hf_index, tvb, relstr_start, relstr_end - relstr_start, text);\r\n\tsubtree = proto_item_add_subtree(item, ett_RELSTR);\r\n\r\n\tdissect_ndr_uint32(\r\n\t\ttvb, offset - 4, pinfo, subtree, di, drep, hf_offset, NULL);\r\n\r\n\tif (relstr_offset)\r\n\t\tdissect_spoolss_uint16uni(\r\n\t\t\ttvb, relstr_start, pinfo, subtree, drep, NULL, hf_relative_string);\r\n\r\n\tif (data)\r\n\t\t*data = text;\r\n\r\n\treturn offset;\r\n}", ".issect_printer_attributes": "static int\r\ndissect_printer_attributes(tvbuff_t *tvb, int offset, packet_info *pinfo,\r\n\t\t\t   proto_tree *tree, dcerpc_info *di, uint8_t *drep)\r\n{\r\n\tuint32_t attributes;\r\n\tstatic int * const hf_attributes[] = {\r\n\t\t&hf_printer_attributes_published,\r\n\t\t&hf_printer_attributes_raw_only,\r\n\t\t&hf_printer_attributes_enable_bidi,\r\n\t\t&hf_printer_attributes_work_offline,\r\n\t\t&hf_printer_attributes_do_complete_first,\r\n\t\t&hf_printer_attributes_keep_printed_jobs,\r\n\t\t&hf_printer_attributes_enable_devq,\r\n\t\t&hf_printer_attributes_local,\r\n\t\t&hf_printer_attributes_hidden,\r\n\t\t&hf_printer_attributes_network,\r\n\t\t&hf_printer_attributes_shared,\r\n\t\t&hf_printer_attributes_default,\r\n\t\t&hf_printer_attributes_direct,\r\n\t\t&hf_printer_attributes_queued,\r\n\t\tNULL\r\n\t};\r\n\r\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, NULL, di, drep, -1, &attributes);\r\n\r\n\tproto_tree_add_bitmask_value_with_flags(tree, tvb, offset - 4, hf_printer_attributes,\r\n\t\t\t\t\tett_printer_attributes, hf_attributes, attributes, BMT_NO_APPEND);\r\n\r\n\treturn offset;\r\n}", ".issect_USER_LEVEL_1": "static int\r\ndissect_USER_LEVEL_1(tvbuff_t *tvb, int offset,\r\n\t\t\t\tpacket_info *pinfo, proto_tree *tree,\r\n\t\t\t\tdcerpc_info *di, uint8_t *drep)\r\n{\r\n\tuint32_t level;\r\n\r\n\t/* Guy has pointed out that this dissection looks wrong.  In\r\n\t   the wireshark output for a USER_LEVEL_1 it looks like the\r\n\t   info level and container pointer are transposed.  I'm not\r\n\t   even sure this structure is a container. */\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_level, &level);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_userlevel_size, NULL);\r\n\r\n\toffset = dissect_ndr_str_pointer_item(\r\n\t\ttvb, offset, pinfo, tree, di, drep, NDR_POINTER_UNIQUE,\r\n\t\t\"Client\", hf_userlevel_client, 0);\r\n\r\n\toffset = dissect_ndr_str_pointer_item(\r\n\t\ttvb, offset, pinfo, tree, di, drep, NDR_POINTER_UNIQUE,\r\n\t\t\"User\", hf_userlevel_user, 0);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_userlevel_build, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_userlevel_major, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_userlevel_minor, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_userlevel_processor, NULL);\r\n\r\n\treturn offset;\r\n}", ".issect_PRINTER_DATATYPE": "static int\r\ndissect_PRINTER_DATATYPE(tvbuff_t *tvb, int offset,\r\n\t\t\t\t    packet_info *pinfo, proto_tree *tree,\r\n\t\t\t\t    dcerpc_info *di, uint8_t *drep)\r\n{\r\n\tif (di->conformant_run)\r\n\t\treturn offset;\r\n\r\n\toffset = dissect_ndr_cvstring(\r\n\t\ttvb, offset, pinfo, tree, di, drep, sizeof(uint16_t),\r\n\t\thf_datatype, true, NULL);\r\n\r\n\treturn offset;\r\n}", ".issect_DEVMODE_CTR": "int\r\ndissect_DEVMODE_CTR(tvbuff_t *tvb, int offset, packet_info *pinfo,\r\n\t\t\t       proto_tree *tree, dcerpc_info *di, uint8_t *drep)\r\n{\r\n\tproto_tree *subtree;\r\n\tuint32_t size;\r\n\r\n\tsubtree = proto_tree_add_subtree(\r\n\t\ttree, tvb, offset, 0, ett_DEVMODE_CTR, NULL, \"Devicemode container\");\r\n\r\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, subtree, di, drep,\r\n\t\t\t\t    hf_devmodectr_size, &size);\r\n\r\n\toffset = dissect_ndr_pointer(\r\n\t\ttvb, offset, pinfo, subtree, di, drep,\r\n\t\tdissect_DEVMODE, NDR_POINTER_UNIQUE, \"Devicemode\", -1);\r\n\r\n\treturn offset;\r\n}", ".issect_USER_LEVEL_CTR": "int\r\ndissect_USER_LEVEL_CTR(tvbuff_t *tvb, int offset,\r\n\t\t\t\t  packet_info *pinfo, proto_tree *tree,\r\n\t\t\t\t  dcerpc_info *di, uint8_t *drep)\r\n{\r\n\tproto_tree *subtree;\r\n\tproto_item *item;\r\n\tuint32_t level;\r\n\r\n\tif (di->conformant_run)\r\n\t\treturn offset;\r\n\r\n\tsubtree = proto_tree_add_subtree(\r\n\t\ttree, tvb, offset, 0, ett_USER_LEVEL_CTR, &item, \"User level container\");\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_level, &level);\r\n\r\n\tswitch(level) {\r\n\tcase 1:\r\n\t\toffset = dissect_ndr_pointer(\r\n\t\t\ttvb, offset, pinfo, subtree, di, drep,\r\n\t\t\tdissect_USER_LEVEL_1, NDR_POINTER_UNIQUE,\r\n\t\t\t\"User level 1\", -1);\r\n\t\tbreak;\r\n\tdefault:\r\n\t\texpert_add_info_format(pinfo, item, &ei_level, \"Info level %d not decoded\", level);\r\n\t\tbreak;\r\n\t}\r\n\r\n\treturn offset;\r\n}", ".issect_notify_field": "static int\r\ndissect_notify_field(tvbuff_t *tvb, int offset, packet_info *pinfo,\r\n\t\t     proto_tree *tree, dcerpc_info *di, uint8_t *drep, uint16_t type,\r\n\t\t     uint16_t *data)\r\n{\r\n\tuint16_t field;\r\n\tconst char *str;\r\n\r\n\toffset = dissect_ndr_uint16(\r\n\t\ttvb, offset, pinfo, NULL, di, drep,\r\n\t\thf_notify_field, &field);\r\n\r\n\tswitch(type) {\r\n\tcase PRINTER_NOTIFY_TYPE:\r\n\t\tstr = val_to_str_ext_const(field, &printer_notify_option_data_vals_ext,\r\n\t\t\t\t \"Unknown\");\r\n\t\tbreak;\r\n\tcase JOB_NOTIFY_TYPE:\r\n\t\tstr = val_to_str_ext_const(field, &job_notify_option_data_vals_ext,\r\n\t\t\t\t \"Unknown\");\r\n\t\tbreak;\r\n\tdefault:\r\n\t\tstr = \"Unknown notify type\";\r\n\t\tbreak;\r\n\t}\r\n\r\n\tproto_tree_add_uint_format_value(tree, hf_notify_field, tvb, offset - 2, 2, field, \"%s (%d)\", str, field);\r\n\r\n\tif (data)\r\n\t\t*data = field;\r\n\r\n\treturn offset;\r\n}", ".issect_NOTIFY_OPTION_DATA": "static int\r\ndissect_NOTIFY_OPTION_DATA(tvbuff_t *tvb, int offset, packet_info *pinfo,\r\n\t\t\t   proto_tree *tree, dcerpc_info *di, uint8_t *drep)\r\n{\r\n\tdcerpc_call_value *dcv = (dcerpc_call_value *)di->call_data;\r\n\tuint32_t count, i;\r\n\tuint16_t type;\r\n\r\n\tif (di->conformant_run)\r\n\t\treturn offset;\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, tree, di, drep,\r\n\t\thf_notify_option_data_count, &count);\r\n\r\n\ttype = GPOINTER_TO_INT(dcv->private_data);\r\n\r\n\tfor (i = 0; i < count; i++)\r\n\t\toffset = dissect_notify_field(\r\n\t\t\ttvb, offset, pinfo, tree, di, drep, type, NULL);\r\n\r\n\treturn offset;\r\n}", ".issect_NOTIFY_OPTION": "static int\r\ndissect_NOTIFY_OPTION(tvbuff_t *tvb, int offset, packet_info *pinfo,\r\n\t\t      proto_tree *tree, dcerpc_info *di, uint8_t *drep)\r\n{\r\n\tdcerpc_call_value *dcv = (dcerpc_call_value *)di->call_data;\r\n\tproto_item *item;\r\n\tproto_tree *subtree;\r\n\tuint16_t type;\r\n\tuint32_t count;\r\n\r\n\tsubtree = proto_tree_add_subtree(tree, tvb, offset, 0, ett_NOTIFY_OPTION, &item, \"Notify Option\");\r\n\r\n\toffset = dissect_ndr_uint16(tvb, offset, pinfo, subtree, di, drep,\r\n\t\t\t\t    hf_notify_option_type, &type);\r\n\r\n\tproto_item_append_text(\r\n\t\titem, \": %s\", val_to_str_wmem(pinfo->pool, type, printer_notify_types,\r\n\t\t\t\t\t \"Unknown (%d)\"));\r\n\r\n\toffset = dissect_ndr_uint16(tvb, offset, pinfo, subtree, di, drep,\r\n\t\t\t\t    hf_notify_option_reserved1, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, subtree, di, drep,\r\n\t\t\t\t    hf_notify_option_reserved2, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, subtree, di, drep,\r\n\t\t\t\t    hf_notify_option_reserved3, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, subtree, di, drep,\r\n\t\t\t\t    hf_notify_option_count, &count);\r\n\r\n\tproto_item_append_text(\r\n\t\titem, \", %d %s\", count, notify_plural(count));\r\n\r\n\tdcv->private_data = GINT_TO_POINTER((int)type);\r\n\r\n\toffset = dissect_ndr_pointer(\r\n\t\ttvb, offset, pinfo, subtree, di, drep,\r\n\t\tdissect_NOTIFY_OPTION_DATA, NDR_POINTER_UNIQUE,\r\n\t\t\"Notify Option Data\", -1);\r\n\r\n\treturn offset;\r\n}", ".issect_notify_options_flags": "static int\r\ndissect_notify_options_flags(tvbuff_t *tvb, int offset, packet_info *pinfo,\r\n\t\t\t     proto_tree *tree, dcerpc_info *di, uint8_t *drep)\r\n{\r\n\tuint32_t flags;\r\n\tstatic int * const hf_flags[] = {\r\n\t\t&hf_notify_options_flags_refresh,\r\n\t\tNULL\r\n\t};\r\n\r\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, NULL, di, drep, -1, &flags);\r\n\r\n\tproto_tree_add_bitmask_value_with_flags(tree, tvb, offset - 4, hf_notify_options_flags,\r\n\t\t\t\t\tett_notify_options_flags, hf_flags, flags, BMT_NO_APPEND);\r\n\r\n\treturn offset;\r\n}", ".issect_NOTIFY_OPTIONS_ARRAY": "static int\r\ndissect_NOTIFY_OPTIONS_ARRAY(tvbuff_t *tvb, int offset,\r\n\t\t\t     packet_info *pinfo, proto_tree *tree,\r\n\t\t\t     dcerpc_info *di, uint8_t *drep)\r\n{\r\n\t/* Why is a check for di->conformant_run not required here? */\r\n\r\n\toffset = dissect_ndr_ucarray(\r\n\t\ttvb, offset, pinfo, tree, di, drep, dissect_NOTIFY_OPTION);\r\n\r\n\treturn offset;\r\n}", ".issect_NOTIFY_OPTIONS_ARRAY_CTR": "int\r\ndissect_NOTIFY_OPTIONS_ARRAY_CTR(tvbuff_t *tvb, int offset,\r\n\t\t\t\t packet_info *pinfo, proto_tree *tree,\r\n\t\t\t\t dcerpc_info *di, uint8_t *drep)\r\n{\r\n\tif (di->conformant_run)\r\n\t\treturn offset;\r\n\r\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, tree, di, drep,\r\n\t\t\t\t    hf_notify_options_version, NULL);\r\n\r\n\toffset = dissect_notify_options_flags(tvb, offset, pinfo, tree, di, drep);\r\n\r\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, tree, di, drep,\r\n\t\t\t\t    hf_notify_options_count, NULL);\r\n\r\n\toffset = dissect_ndr_pointer(\r\n\t\ttvb, offset, pinfo, tree, di, drep,\r\n\t\tdissect_NOTIFY_OPTIONS_ARRAY, NDR_POINTER_UNIQUE,\r\n\t\t\"Notify Options Array\", -1);\r\n\r\n\treturn offset;\r\n}", ".issect_spoolss_buffer": "static int\r\ndissect_spoolss_buffer(tvbuff_t *tvb, int offset, packet_info *pinfo,\r\n\t\t       proto_tree *tree, dcerpc_info *di, uint8_t *drep, BUFFER *b)\r\n{\r\n\tif (b)\r\n\t\tmemset(b, 0, sizeof(BUFFER));\r\n\r\n\tdi->private_data = b;\r\n\r\n\toffset = dissect_ndr_pointer(\r\n\t\ttvb, offset, pinfo, tree, di, drep,\r\n\t\tdissect_spoolss_buffer_data, NDR_POINTER_UNIQUE,\r\n\t\t\"Buffer\", -1);\r\n\r\n\treturn offset;\r\n}", ".issect_PRINTER_INFO_0": "static int\r\ndissect_PRINTER_INFO_0(tvbuff_t *tvb, int offset,\r\n\t\t\t\t  packet_info *pinfo, proto_tree *tree,\r\n\t\t\t\t  dcerpc_info *di, uint8_t *drep)\r\n{\r\n\toffset = dissect_spoolss_relstr(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printername,\r\n\t\t0, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_servername,\r\n\t\t0, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printer_cjobs, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printer_total_jobs,\r\n\t\tNULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printer_total_bytes,\r\n\t\tNULL);\r\n\r\n\toffset = dissect_SYSTEM_TIME(\r\n\t\ttvb, offset, pinfo, tree, di, drep, \"Unknown time\", true, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printer_global_counter,\r\n\t\tNULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printer_total_pages,\r\n\t\tNULL);\r\n\r\n\toffset = dissect_ndr_uint16(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printer_major_version,\r\n\t\tNULL);\r\n\r\n\toffset = dissect_ndr_uint16(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printer_build_version,\r\n\t\tNULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printer_unk7, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printer_unk8, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printer_unk9, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printer_session_ctr,\r\n\t\tNULL);\r\n\r\n\toffset = dissect_ndr_uint32( tvb, offset, pinfo, tree, di, drep,\r\n\t\thf_printer_unk11, NULL);\r\n\r\n\toffset = dissect_ndr_uint32( tvb, offset, pinfo, tree, di, drep,\r\n\t\thf_printer_printer_errors, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printer_unk13, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printer_unk14, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printer_unk15, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printer_unk16, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printer_changeid, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printer_unk18, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printer_status, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printer_unk20, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printer_c_setprinter,\r\n\t\tNULL);\r\n\r\n\toffset = dissect_ndr_uint16(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printer_unk22, NULL);\r\n\r\n\toffset = dissect_ndr_uint16(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printer_unk23, NULL);\r\n\r\n\toffset = dissect_ndr_uint16(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printer_unk24, NULL);\r\n\r\n\toffset = dissect_ndr_uint16(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printer_unk25, NULL);\r\n\r\n\toffset = dissect_ndr_uint16(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printer_unk26, NULL);\r\n\r\n\toffset = dissect_ndr_uint16(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printer_unk27, NULL);\r\n\r\n\toffset = dissect_ndr_uint16(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printer_unk28, NULL);\r\n\r\n\toffset = dissect_ndr_uint16(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printer_unk29, NULL);\r\n\r\n\treturn offset;\r\n}", ".issect_PRINTER_INFO_1": "static int\r\ndissect_PRINTER_INFO_1(tvbuff_t *tvb, int offset,\r\n\t\t\t\t  packet_info *pinfo, proto_tree *tree,\r\n\t\t\t\t  dcerpc_info *di, uint8_t *drep)\r\n{\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, tree, di, drep,\r\n\t\thf_printer_flags, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printerdesc,\r\n\t\t0, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printername,\r\n\t\t0, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printercomment,\r\n\t\t0, NULL);\r\n\r\n\treturn offset;\r\n}", ".issect_PRINTER_INFO_2": "static int\r\ndissect_PRINTER_INFO_2(tvbuff_t *tvb, int offset,\r\n\t\t\t\t  packet_info *pinfo, proto_tree *tree,\r\n\t\t\t\t  dcerpc_info *di, uint8_t *drep)\r\n{\r\n\tuint32_t devmode_offset, secdesc_offset;\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_servername,\r\n\t\t0, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printername,\r\n\t\t0, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_sharename,\r\n\t\t0, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_portname,\r\n\t\t0, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_drivername,\r\n\t\t0, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printercomment,\r\n\t\t0, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printerlocation,\r\n\t\t0, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, NULL, di, drep, hf_offset,\r\n\t\t&devmode_offset);\r\n\r\n\tdissect_DEVMODE(tvb, devmode_offset - 4, pinfo, tree, di, drep);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_sepfile,\r\n\t\t0, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printprocessor,\r\n\t\t0, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_datatype,\r\n\t\t0, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_parameters,\r\n\t\t0, NULL);\r\n\r\n\t/*\r\n\t * XXX - what *is* the length of this security descriptor?\r\n\t * \"prs_PRINTER_INFO_2()\" is passed to \"defer_ptr()\", but\r\n\t * \"defer_ptr\" takes, as an argument, a function with a\r\n\t * different calling sequence from \"prs_PRINTER_INFO_2()\",\r\n\t * lacking the \"len\" argument, so that won't work.\r\n\t */\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, NULL, di, drep, hf_offset,\r\n\t\t&secdesc_offset);\r\n\r\n\tdissect_nt_sec_desc(\r\n\t\ttvb, secdesc_offset, pinfo, tree, drep,\r\n\t\tfalse, -1,\r\n\t\t&spoolss_printer_access_mask_info);\r\n\r\n\toffset = dissect_printer_attributes(tvb, offset, pinfo, tree, di, drep);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, NULL, di, drep, hf_printer_priority,\r\n\t\tNULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, NULL, di, drep,\r\n\t\thf_printer_default_priority, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, NULL, di, drep, hf_start_time, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, NULL, di, drep, hf_end_time, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, tree, di, drep,\r\n\t\thf_printer_status, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, NULL, di, drep, hf_printer_jobs,\r\n\t\tNULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, NULL, di, drep,\r\n\t\thf_printer_averageppm, NULL);\r\n\r\n\treturn offset;\r\n}", ".issect_PRINTER_INFO_3": "static int\r\ndissect_PRINTER_INFO_3(tvbuff_t *tvb, int offset,\r\n\t\t\t\t  packet_info *pinfo, proto_tree *tree,\r\n\t\t\t\t  dcerpc_info *di, uint8_t *drep)\r\n{\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, tree, di, drep,\r\n\t\thf_printer_flags, NULL);\r\n\r\n\toffset = dissect_nt_sec_desc(\r\n\t\ttvb, offset, pinfo, tree, drep,\r\n\t\tfalse, -1,\r\n\t\t&spoolss_printer_access_mask_info);\r\n\r\n\treturn offset;\r\n}", ".issect_PRINTER_INFO_5": "static int\r\ndissect_PRINTER_INFO_5(tvbuff_t *tvb, int offset,\r\n\t\t\t\t  packet_info *pinfo, proto_tree *tree,\r\n\t\t\t\t  dcerpc_info *di, uint8_t *drep)\r\n{\r\n\toffset = dissect_spoolss_relstr(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printername,\r\n\t\t0, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_portname,\r\n\t\t0, NULL);\r\n\r\n\toffset = dissect_printer_attributes(tvb, offset, pinfo, tree, di, drep);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, tree, di, drep,\r\n\t\thf_device_not_selected_timeout, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, tree, di, drep,\r\n\t\thf_transmission_retry_timeout, NULL);\r\n\r\n\treturn offset;\r\n}", ".issect_PRINTER_INFO_7": "static int\r\ndissect_PRINTER_INFO_7(tvbuff_t *tvb, int offset,\r\n\t\t\t\t  packet_info *pinfo, proto_tree *tree,\r\n\t\t\t\t  dcerpc_info *di, uint8_t *drep)\r\n{\r\n\toffset = dissect_spoolss_relstr(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printer_guid,\r\n\t\t0, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, tree, di, drep,\r\n\t\thf_printer_action, NULL);\r\n\r\n\treturn offset;\r\n}", ".issect_SEC_DESC_BUF": "static int\r\ndissect_SEC_DESC_BUF(tvbuff_t *tvb, int offset, packet_info *pinfo,\r\n\t\t     proto_tree *tree, dcerpc_info *di, uint8_t *drep)\r\n{\r\n\tproto_tree *subtree;\r\n\tuint32_t len;\r\n\r\n\t/* XXX: I think this is really a array of bytes which can be\r\n\t   dissected using dissect_ndr_cvstring().  The dissected data\r\n\t   can be passed to dissect_nt_sec_desc().  The problem is that\r\n\t   dissect_nt_cvstring() passes back a char * where it really\r\n\t   should pass back a tvb. */\r\n\r\n\tsubtree = proto_tree_add_subtree(\r\n\t\ttree, tvb, offset, 0, ett_SEC_DESC_BUF, NULL, \"Security descriptor buffer\");\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, subtree, di, drep,\r\n\t\thf_secdescbuf_maxlen, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, subtree, di, drep,\r\n\t\thf_secdescbuf_undoc, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, subtree, di, drep,\r\n\t\thf_secdescbuf_len, &len);\r\n\r\n\tdissect_nt_sec_desc(\r\n\t\ttvb, offset, pinfo, subtree, drep, true, len,\r\n\t\t&spoolss_printer_access_mask_info);\r\n\r\n\toffset += len;\r\n\r\n\treturn offset;\r\n}", ".issect_SPOOL_PRINTER_INFO": "int\r\ndissect_SPOOL_PRINTER_INFO(tvbuff_t *tvb, int offset, packet_info *pinfo,\r\n\t\t\t   proto_tree *tree, dcerpc_info *di, uint8_t *drep)\r\n{\r\n\tproto_tree *subtree;\r\n\tuint32_t level;\r\n\tproto_tree *item;\r\n\r\n\tsubtree = proto_tree_add_subtree(\r\n\t\ttree, tvb, offset, 0, ett_SPOOL_PRINTER_INFO_LEVEL, &item, \"Spool printer info level\");\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_level, &level);\r\n\r\n\tswitch(level) {\r\n\tcase 3: {\r\n\t\tuint32_t devmode_ptr, secdesc_ptr;\r\n\r\n\t\t/* I can't seem to get this working with the correct\r\n\t\t   dissect_ndr_pointer() function so let's cheat and\r\n\t\t   dissect the pointers by hand. )-: */\r\n\r\n\t\toffset = dissect_ndr_uint32(\r\n\t\t\ttvb, offset, pinfo, subtree, di, drep,\r\n\t\t\thf_spool_printer_info_devmode_ptr,\r\n\t\t\t&devmode_ptr);\r\n\r\n\t\toffset = dissect_ndr_uint32(\r\n\t\t\ttvb, offset, pinfo, subtree, di, drep,\r\n\t\t\thf_spool_printer_info_secdesc_ptr,\r\n\t\t\t&secdesc_ptr);\r\n\r\n\t\tif (devmode_ptr)\r\n\t\t\toffset = dissect_DEVMODE_CTR(\r\n\t\t\t\ttvb, offset, pinfo, subtree, di, drep);\r\n\r\n\t\tif (secdesc_ptr)\r\n\t\t\toffset = dissect_SEC_DESC_BUF(\r\n\t\t\t\ttvb, offset, pinfo, subtree, di, drep);\r\n\r\n\tbreak;\r\n\t}\r\n\tcase 2:\r\n\tdefault:\r\n\t\texpert_add_info_format(pinfo, item, &ei_spool_printer_info_level, \"Unknown spool printer info level %d\", level);\r\n\t\tbreak;\r\n\t}\r\n\r\n\treturn offset;\r\n}", ".issect_FORM_REL": "static int\r\ndissect_FORM_REL(tvbuff_t *tvb, int offset, packet_info *pinfo,\r\n\t\t\t    proto_tree *tree, dcerpc_info *di, uint8_t *drep, int struct_start)\r\n{\r\n\tproto_item *item;\r\n\tproto_tree *subtree;\r\n\tuint32_t flags;\r\n\tint item_start = offset;\r\n\tchar *name = NULL;\r\n\r\n\tsubtree = proto_tree_add_subtree(tree, tvb, offset, 0, ett_FORM_REL, &item, \"Form\");\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_form_flags, &flags);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_form_name,\r\n\t\tstruct_start, &name);\r\n\r\n\tif (name) {\r\n\t\tproto_item_append_text(item, \": %s\", name);\r\n\t}\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, subtree, di, drep,\r\n\t\thf_form_width, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, subtree, di, drep,\r\n\t\thf_form_height, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, subtree, di, drep,\r\n\t\thf_form_left_margin, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, subtree, di, drep,\r\n\t\thf_form_top_margin, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, subtree, di, drep,\r\n\t\thf_form_horiz_len, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, subtree, di, drep,\r\n\t\thf_form_vert_len, NULL);\r\n\r\n\tproto_item_set_len(item, offset - item_start);\r\n\r\n\treturn offset;\r\n}", ".issect_FORM_1": "static int\r\ndissect_FORM_1(tvbuff_t *tvb, int offset, packet_info *pinfo,\r\n\t\t\t  proto_tree *tree, dcerpc_info *di, uint8_t *drep)\r\n{\r\n\tproto_tree *subtree;\r\n\tuint32_t flags;\r\n\r\n\tsubtree = proto_tree_add_subtree(tree, tvb, offset, 0, ett_FORM_1, NULL, \"Form level 1\");\r\n\r\n\toffset = dissect_ndr_str_pointer_item(\r\n\t\ttvb, offset, pinfo, subtree, di, drep, NDR_POINTER_UNIQUE,\r\n\t\t\"Name\", hf_form_name, 0);\r\n\r\n\t/* Eek - we need to know whether this pointer was NULL or not.\r\n\t   Currently there is not any way to do this. */\r\n\r\n\tif (tvb_reported_length_remaining(tvb, offset) <= 0)\r\n\t\tgoto done;\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_form_flags, &flags);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, subtree, di, drep,\r\n\t\thf_form_unknown, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, subtree, di, drep,\r\n\t\thf_form_width, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, subtree, di, drep,\r\n\t\thf_form_height, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, subtree, di, drep,\r\n\t\thf_form_left_margin, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, subtree, di, drep,\r\n\t\thf_form_top_margin, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, subtree, di, drep,\r\n\t\thf_form_horiz_len, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, subtree, di, drep,\r\n\t\thf_form_vert_len, NULL);\r\n\r\n done:\r\n\treturn offset;\r\n}", ".issect_FORM_CTR": "int\r\ndissect_FORM_CTR(tvbuff_t *tvb, int offset,\r\n\t\t\t    packet_info *pinfo, proto_tree *tree,\r\n\t\t\t    dcerpc_info *di, uint8_t *drep)\r\n{\r\n\tproto_tree *subtree;\r\n\tproto_item *item;\r\n\tuint32_t level;\r\n\r\n\tsubtree = proto_tree_add_subtree(tree, tvb, offset, 0, ett_FORM_CTR, &item, \"Form container\");\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_form_level, &level);\r\n\r\n\tswitch(level) {\r\n\tcase 1:\r\n\t\toffset = dissect_FORM_1(tvb, offset, pinfo, subtree, di, drep);\r\n\t\tbreak;\r\n\r\n\tdefault:\r\n\t\texpert_add_info_format(pinfo, item, &ei_form_level, \"Unknown form info level %d\", level);\r\n\t\tbreak;\r\n\t}\r\n\r\n\treturn offset;\r\n}", ".issect_job_status": "static int\r\ndissect_job_status(tvbuff_t *tvb, int offset, packet_info *pinfo,\r\n\t\t   proto_tree *tree, dcerpc_info *di, uint8_t *drep)\r\n{\r\n\tuint32_t status;\r\n\tstatic int * const hf_status[] = {\r\n\t\t&hf_job_status_user_intervention,\r\n\t\t&hf_job_status_blocked,\r\n\t\t&hf_job_status_deleted,\r\n\t\t&hf_job_status_printed,\r\n\t\t&hf_job_status_paperout,\r\n\t\t&hf_job_status_offline,\r\n\t\t&hf_job_status_printing,\r\n\t\t&hf_job_status_spooling,\r\n\t\t&hf_job_status_deleting,\r\n\t\t&hf_job_status_error,\r\n\t\t&hf_job_status_paused,\r\n\t\tNULL\r\n\t};\r\n\r\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, NULL, di, drep, -1, &status);\r\n\r\n\tproto_tree_add_bitmask_value_with_flags(tree, tvb, offset - 4, hf_job_status,\r\n\t\t\t\t\tett_job_status, hf_status, status, BMT_NO_APPEND);\r\n\r\n\treturn offset;\r\n}", ".issect_spoolss_JOB_INFO_1": "static int\r\ndissect_spoolss_JOB_INFO_1(tvbuff_t *tvb, int offset, packet_info *pinfo,\r\n\t\t\t   proto_tree *tree, dcerpc_info *di, uint8_t *drep)\r\n{\r\n\tproto_item *item;\r\n\tproto_tree *subtree;\r\n\tint struct_start = offset;\r\n\tchar *document_name;\r\n\r\n\tsubtree = proto_tree_add_subtree(tree, tvb, offset, 0, ett_JOB_INFO_1, &item, \"Job info level 1\");\r\n\r\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, subtree, di, drep,\r\n\t\t\t\t    hf_job_id, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_printername,\r\n\t\tstruct_start, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_servername,\r\n\t\tstruct_start, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_username,\r\n\t\tstruct_start, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_documentname,\r\n\t\tstruct_start, &document_name);\r\n\r\n\tproto_item_append_text(item, \": %s\", document_name);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_datatype,\r\n\t\tstruct_start, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_textstatus,\r\n\t\tstruct_start, NULL);\r\n\r\n\toffset = dissect_job_status(tvb, offset, pinfo, subtree, di, drep);\r\n\r\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, subtree, di, drep,\r\n\t\t\t\t    hf_job_priority, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, subtree, di, drep,\r\n\t\t\t\t    hf_job_position, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, subtree, di, drep,\r\n\t\t\t\t    hf_job_totalpages, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, subtree, di, drep,\r\n\t\t\t\t    hf_job_pagesprinted, NULL);\r\n\r\n\toffset = dissect_SYSTEM_TIME(\r\n\t\ttvb, offset, pinfo, subtree, di, drep, \"Job Submission Time\",\r\n\t\ttrue, NULL);\r\n\r\n\tproto_item_set_len(item, offset - struct_start);\r\n\r\n\treturn offset;\r\n}", ".issect_spoolss_JOB_INFO_2": "static int\r\ndissect_spoolss_JOB_INFO_2(tvbuff_t *tvb, int offset, packet_info *pinfo,\r\n\t\t\t   proto_tree *tree, dcerpc_info *di, uint8_t *drep)\r\n{\r\n\tproto_item *item;\r\n\tproto_tree *subtree;\r\n\tint struct_start = offset;\r\n\tchar *document_name;\r\n\tuint32_t devmode_offset, secdesc_offset;\r\n\r\n\tsubtree = proto_tree_add_subtree(tree, tvb, offset, 0, ett_JOB_INFO_2, &item, \"Job info level 2\");\r\n\r\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, subtree, di, drep,\r\n\t\t\t\t    hf_job_id, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_printername,\r\n\t\tstruct_start, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_machinename,\r\n\t\tstruct_start, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_username,\r\n\t\tstruct_start, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_documentname,\r\n\t\tstruct_start, &document_name);\r\n\r\n\tproto_item_append_text(item, \": %s\", document_name);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_notifyname,\r\n\t\tstruct_start, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_datatype,\r\n\t\tstruct_start, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_printprocessor,\r\n\t\tstruct_start, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_parameters,\r\n\t\tstruct_start, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_drivername,\r\n\t\tstruct_start, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, NULL, di, drep, hf_offset,\r\n\t\t&devmode_offset);\r\n\r\n\tdissect_DEVMODE(\r\n\t\ttvb, devmode_offset - 4 + struct_start, pinfo, subtree, di, drep);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_textstatus,\r\n\t\tstruct_start, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, NULL, di, drep, hf_offset,\r\n\t\t&secdesc_offset);\r\n\r\n\tdissect_nt_sec_desc(\r\n\t\ttvb, secdesc_offset, pinfo, subtree, drep,\r\n\t\tfalse, -1,\r\n\t\t&spoolss_job_access_mask_info);\r\n\r\n\toffset = dissect_job_status(tvb, offset, pinfo, subtree, di, drep);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_job_priority, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_job_position, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, NULL, di, drep, hf_start_time, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, NULL, di, drep, hf_end_time, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_job_totalpages, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_job_size, NULL);\r\n\r\n\toffset = dissect_SYSTEM_TIME(\r\n\t\ttvb, offset, pinfo, subtree, di, drep, \"Job Submission Time\",\r\n\t\ttrue, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, NULL, di, drep, hf_elapsed_time, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_job_pagesprinted, NULL);\r\n\r\n\tproto_item_set_len(item, offset - struct_start);\r\n\r\n\treturn offset;\r\n}", ".issect_spoolss_doc_info_1": "static int\r\ndissect_spoolss_doc_info_1(tvbuff_t *tvb, int offset, packet_info *pinfo,\r\n\t\t\t   proto_tree *tree, dcerpc_info *di, uint8_t *drep)\r\n{\r\n\tproto_tree *subtree;\r\n\r\n\tsubtree = proto_tree_add_subtree(\r\n\t\ttree, tvb, offset, 0, ett_DOC_INFO_1, NULL, \"Document info level 1\");\r\n\r\n\toffset = dissect_ndr_str_pointer_item(\r\n\t\ttvb, offset, pinfo, subtree, di, drep, NDR_POINTER_UNIQUE,\r\n\t\t\"Document name\", hf_documentname, 0);\r\n\r\n\toffset = dissect_ndr_str_pointer_item(\r\n\t\ttvb, offset, pinfo, subtree, di, drep, NDR_POINTER_UNIQUE,\r\n\t\t\"Output file\", hf_outputfile, 0);\r\n\r\n\toffset = dissect_ndr_str_pointer_item(\r\n\t\ttvb, offset, pinfo, subtree, di, drep, NDR_POINTER_UNIQUE,\r\n\t\t\"Data type\", hf_datatype, 0);\r\n\r\n\treturn offset;\r\n}", ".issect_spoolss_doc_info_data": "static int\r\ndissect_spoolss_doc_info_data(tvbuff_t *tvb, int offset, packet_info *pinfo,\r\n\t\t\t      proto_tree *tree, dcerpc_info *di, uint8_t *drep)\r\n{\r\n\tif (di->conformant_run)\r\n\t\treturn offset;\r\n\r\n\treturn dissect_spoolss_doc_info_1(tvb, offset, pinfo, tree, di, drep);\r\n}", ".issect_spoolss_doc_info": "static int\r\ndissect_spoolss_doc_info(tvbuff_t *tvb, int offset, packet_info *pinfo,\r\n\t\t\t proto_tree *tree, dcerpc_info *di, uint8_t *drep)\r\n{\r\n\tproto_tree *subtree;\r\n\tuint32_t level;\r\n\r\n\tsubtree = proto_tree_add_subtree(\r\n\t\ttree, tvb, offset, 0, ett_DOC_INFO, NULL, \"Document info\");\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_level, &level);\r\n\r\n\toffset = dissect_ndr_pointer(\r\n\t\ttvb, offset, pinfo, subtree, di, drep,\r\n\t\tdissect_spoolss_doc_info_data,\r\n\t\tNDR_POINTER_UNIQUE, \"Document info\", -1);\r\n\r\n\treturn offset;\r\n}", ".issect_spoolss_doc_info_ctr": "int\r\ndissect_spoolss_doc_info_ctr(tvbuff_t *tvb, int offset, packet_info *pinfo,\r\n\t\t\t     proto_tree *tree, dcerpc_info *di, uint8_t *drep)\r\n{\r\n\tproto_tree *subtree;\r\n\r\n\tsubtree = proto_tree_add_subtree(\r\n\t\ttree, tvb, offset, 0, ett_DOC_INFO_CTR, NULL, \"Document info container\");\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_level, NULL);\r\n\r\n\toffset = dissect_spoolss_doc_info(\r\n\t\ttvb, offset, pinfo, subtree, di, drep);\r\n\r\n\treturn offset;\r\n}", ".issect_spoolss_relstrarray": "static int\r\ndissect_spoolss_relstrarray(tvbuff_t *tvb, int offset, packet_info *pinfo,\r\n\t\t\t    proto_tree *tree, dcerpc_info *di, uint8_t *drep, int hf_index,\r\n\t\t\t    int struct_start, char **data)\r\n{\r\n\tproto_item *item;\r\n\tproto_tree *subtree;\r\n\tuint32_t relstr_offset, relstr_start/*, relstr_end, relstr_len*/;\r\n\tchar *text;\r\n\r\n\titem = proto_tree_add_string(tree, hf_index, tvb, offset, 4, \"\");\r\n\r\n\tsubtree = proto_item_add_subtree(item, ett_RELSTR_ARRAY);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_offset, &relstr_offset);\r\n\r\n\t/* A relative offset of zero is a NULL string */\r\n\r\n\trelstr_start = relstr_offset + struct_start;\r\n\r\n\tif (relstr_offset)\r\n\t\t/*relstr_end = */dissect_spoolss_uint16uni(\r\n\t\t\ttvb, relstr_start, pinfo, subtree, drep, &text, hf_relative_string);\r\n\telse {\r\n\t\ttext = wmem_strdup(pinfo->pool, \"NULL\");\r\n\t\t/*relstr_end = offset;*/\r\n\t}\r\n\r\n\t/*relstr_len = relstr_end - relstr_start;*/\r\n\r\n\tproto_item_append_text(item, \"%s\", text);\r\n\r\n\tif (data)\r\n\t\t*data = text;\r\n\r\n\treturn offset;\r\n}", ".issect_printer_driver_attributes": "static int\r\ndissect_printer_driver_attributes(tvbuff_t *tvb, int offset, packet_info *pinfo,\r\n\t\t\t\t  proto_tree *tree, dcerpc_info *di, uint8_t *drep)\r\n{\r\n\tuint32_t attributes;\r\n\tstatic int * const hf_attributes[] = {\r\n\t\t&hf_printer_driver_attributes_package_aware,\r\n\t\t&hf_printer_driver_attributes_xps,\r\n\t\t&hf_printer_driver_attributes_sandbox_enabled,\r\n\t\t&hf_printer_driver_attributes_class,\r\n\t\t&hf_printer_driver_attributes_derived,\r\n\t\t&hf_printer_driver_attributes_not_shareable,\r\n\t\t&hf_printer_driver_attributes_category_fax,\r\n\t\t&hf_printer_driver_attributes_category_file,\r\n\t\t&hf_printer_driver_attributes_category_virtual,\r\n\t\t&hf_printer_driver_attributes_category_service,\r\n\t\t&hf_printer_driver_attributes_soft_reset_required,\r\n\t\t&hf_printer_driver_attributes_category_3d,\r\n\t\tNULL\r\n\t};\r\n\r\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, NULL, di, drep, -1, &attributes);\r\n\r\n\tproto_tree_add_bitmask_value_with_flags(tree, tvb, offset - 4, hf_printer_driver_attributes,\r\n\t\t\t\t\tett_printer_driver_attributes, hf_attributes, attributes, BMT_NO_APPEND);\r\n\r\n\treturn offset;\r\n}", ".issect_DRIVER_INFO_1": "static int\r\ndissect_DRIVER_INFO_1(tvbuff_t *tvb, int offset,\r\n\t\t\t\t packet_info *pinfo, proto_tree *tree,\r\n\t\t\t\t dcerpc_info *di, uint8_t *drep)\r\n{\r\n\tproto_tree *subtree;\r\n\tint struct_start = offset;\r\n\r\n\tsubtree = proto_tree_add_subtree(\r\n\t\ttree, tvb, offset, 0, ett_DRIVER_INFO_1, NULL, \"Driver info level 1\");\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_drivername,\r\n\t\tstruct_start, NULL);\r\n\r\n\treturn offset;\r\n}", ".issect_DRIVER_INFO_2": "static int\r\ndissect_DRIVER_INFO_2(tvbuff_t *tvb, int offset,\r\n\t packet_info *pinfo, proto_tree *tree,\r\n\t dcerpc_info *di, uint8_t *drep)\r\n{\r\n\tproto_tree *subtree;\r\n\tint struct_start = offset;\r\n\r\n\tsubtree = proto_tree_add_subtree(\r\n\t\t\ttree, tvb, offset, 0, ett_DRIVER_INFO_2, NULL, \"Driver info level 2\");\r\n\r\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, subtree, di, drep,\r\n\t\t\thf_driverinfo_cversion, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_drivername,\r\n\t\t\tstruct_start, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_environment,\r\n\t\t\tstruct_start, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_driverpath,\r\n\t\t\tstruct_start, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_datafile,\r\n\t\t\tstruct_start, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_configfile,\r\n\t\t\tstruct_start, NULL);\r\n\r\n\treturn offset;\r\n}", ".issect_DRIVER_INFO_3": "static int\r\ndissect_DRIVER_INFO_3(tvbuff_t *tvb, int offset,\r\n\t\t\t\t packet_info *pinfo, proto_tree *tree,\r\n\t\t\t\t dcerpc_info *di, uint8_t *drep)\r\n{\r\n\tproto_tree *subtree;\r\n\tint struct_start = offset;\r\n\r\n\tsubtree = proto_tree_add_subtree(\r\n\t\ttree, tvb, offset, 0, ett_DRIVER_INFO_3, NULL, \"Driver info level 3\");\r\n\r\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, subtree, di, drep,\r\n\t\t\t\t    hf_driverinfo_cversion, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_drivername,\r\n\t\tstruct_start, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_environment,\r\n\t\tstruct_start, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_driverpath,\r\n\t\tstruct_start, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_datafile,\r\n\t\tstruct_start, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_configfile,\r\n\t\tstruct_start, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_helpfile,\r\n\t\tstruct_start, NULL);\r\n\r\n\toffset = dissect_spoolss_relstrarray(\r\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_dependentfiles,\r\n\t\tstruct_start, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_monitorname,\r\n\t\tstruct_start, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_defaultdatatype,\r\n\t\tstruct_start, NULL);\r\n\r\n\treturn offset;\r\n}", ".issect_DRIVER_INFO_6": "static int\r\ndissect_DRIVER_INFO_6(tvbuff_t *tvb, int offset,\r\n\t\t\t\t packet_info *pinfo, proto_tree *tree,\r\n\t\t\t\t dcerpc_info *di, uint8_t *drep)\r\n{\r\n\tproto_tree *subtree;\r\n\tint struct_start = offset;\r\n\r\n\tsubtree = proto_tree_add_subtree(\r\n\t\t\ttree, tvb, offset, 0, ett_DRIVER_INFO_6, NULL, \"Driver info level 6\");\r\n\r\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, subtree, di, drep,\r\n\t\t\thf_driverinfo_cversion, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_drivername,\r\n\t\t\tstruct_start, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_environment,\r\n\t\t\tstruct_start, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_driverpath,\r\n\t\t\tstruct_start, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_datafile,\r\n\t\t\tstruct_start, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_configfile,\r\n\t\t\tstruct_start, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_helpfile,\r\n\t\t\tstruct_start, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_monitorname,\r\n\t\t\tstruct_start, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_defaultdatatype,\r\n\t\t\tstruct_start, NULL);\r\n\r\n\toffset = dissect_spoolss_relstrarray(\r\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_dependentfiles,\r\n\t\t\tstruct_start, NULL);\r\n\r\n\toffset = dissect_spoolss_relstrarray(\r\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_previousdrivernames,\r\n\t\t\tstruct_start, NULL);\r\n\r\n\toffset = dissect_ndr_nt_NTTIME (\r\n\t\t\ttvb, offset, pinfo, subtree, di, drep,hf_driverdate);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_padding,\r\n\t\t\tNULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_driver_version_low,\r\n\t\t\tNULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_driver_version_high,\r\n\t\t\tNULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_mfgname,\r\n\t\t\tstruct_start, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_oemurl,\r\n\t\t\tstruct_start, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_hardwareid,\r\n\t\t\tstruct_start, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_provider,\r\n\t\t\tstruct_start, NULL);\r\n\r\n\treturn offset;\r\n}", ".issect_DRIVER_INFO_8": "static int\r\ndissect_DRIVER_INFO_8(tvbuff_t *tvb, int offset,\r\n\t\t\t\t packet_info *pinfo, proto_tree *tree,\r\n\t\t\t\t dcerpc_info *di, uint8_t *drep)\r\n{\r\n\tproto_tree *subtree;\r\n\tint struct_start = offset;\r\n\r\n\tsubtree = proto_tree_add_subtree(\r\n\t\t\ttree, tvb, offset, 0, ett_DRIVER_INFO_8, NULL, \"Driver info level 8\");\r\n\r\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, subtree, di, drep,\r\n\t\t\thf_driverinfo_cversion, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_drivername,\r\n\t\t\tstruct_start, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_environment,\r\n\t\t\tstruct_start, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_driverpath,\r\n\t\t\tstruct_start, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_datafile,\r\n\t\t\tstruct_start, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_configfile,\r\n\t\t\tstruct_start, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_helpfile,\r\n\t\t\tstruct_start, NULL);\r\n\r\n\toffset = dissect_spoolss_relstrarray(\r\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_dependentfiles,\r\n\t\t\tstruct_start, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_monitorname,\r\n\t\t\tstruct_start, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_defaultdatatype,\r\n\t\t\tstruct_start, NULL);\r\n\r\n\toffset = dissect_spoolss_relstrarray(\r\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_previousdrivernames,\r\n\t\t\tstruct_start, NULL);\r\n\r\n\toffset = dissect_ndr_nt_NTTIME (\r\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_driverdate);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_padding,\r\n\t\t\tNULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_driver_version_low,\r\n\t\t\tNULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_driver_version_high,\r\n\t\t\tNULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_mfgname,\r\n\t\t\tstruct_start, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_oemurl,\r\n\t\t\tstruct_start, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_hardwareid,\r\n\t\t\tstruct_start, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_provider,\r\n\t\t\tstruct_start, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_printprocessor,\r\n\t\t\tstruct_start, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_vendor_setup,\r\n\t\t\tstruct_start, NULL);\r\n\r\n\toffset = dissect_spoolss_relstrarray(\r\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_color_profiles,\r\n\t\t\tstruct_start, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_inf_path,\r\n\t\t\tstruct_start, NULL);\r\n\r\n\toffset = dissect_printer_driver_attributes(\r\n\t\t\ttvb, offset, pinfo, subtree, di, drep);\r\n\r\n\toffset = dissect_spoolss_relstrarray(\r\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_core_driver_dependencies,\r\n\t\t\tstruct_start, NULL);\r\n\r\n\toffset = dissect_ndr_nt_NTTIME (\r\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_min_inbox_driverdate);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_min_inbox_driver_version_low,\r\n\t\t\tNULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_min_inbox_driver_version_high,\r\n\t\t\tNULL);\r\n\r\n\treturn offset;\r\n}", ".issect_DRIVER_INFO_101": "static int\r\ndissect_DRIVER_INFO_101(tvbuff_t *tvb, int offset,\r\n\t\t\t\t packet_info *pinfo, proto_tree *tree,\r\n\t\t\t\t dcerpc_info *di, uint8_t *drep)\r\n{\r\n\tproto_tree *subtree;\r\n\tint struct_start = offset;\r\n\r\n\tsubtree = proto_tree_add_subtree(\r\n\t\t\ttree, tvb, offset, 0, ett_DRIVER_INFO_101, NULL, \"Driver info level 101\");\r\n\r\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, subtree, di, drep,\r\n\t\t\thf_driverinfo_cversion, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_drivername,\r\n\t\t\tstruct_start, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_environment,\r\n\t\t\tstruct_start, NULL);\r\n\r\n\tproto_tree_add_expert(subtree, pinfo, &ei_unknown_data, tvb, offset, 0);\r\n\r\n\treturn offset;\r\n}", ".issect_notify_info_data_buffer": "static int\r\ndissect_notify_info_data_buffer(tvbuff_t *tvb, int offset, packet_info *pinfo,\r\n\t\t\t\tproto_tree *tree, dcerpc_info *di, uint8_t *drep)\r\n{\r\n\tuint32_t len;\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, tree, di, drep,\r\n\t\thf_notify_info_data_buffer_len, &len);\r\n\r\n\toffset = dissect_ndr_uint16s(\r\n\t\ttvb, offset, pinfo, tree, di, drep,\r\n\t\thf_notify_info_data_buffer_data, len);\r\n\r\n\treturn offset;\r\n}", ".b_notify_str_postprocess": "static void\r\ncb_notify_str_postprocess(packet_info *pinfo _U_,\r\n\t\t\t\t      proto_tree *tree,\r\n\t\t\t\t      proto_item *item, dcerpc_info *di _U_, tvbuff_t *tvb,\r\n\t\t\t\t      int start_offset, int end_offset,\r\n\t\t\t\t      void *callback_args)\r\n{\r\n\tint levels, hf_index = GPOINTER_TO_INT(callback_args);\r\n\tuint32_t len;\r\n\tchar *s;\r\n\tproto_item *hidden_item;\r\n\r\n\t/* Align start_offset on 4-byte boundary. */\r\n\r\n\tstart_offset = WS_ROUNDUP_4(start_offset);\r\n\r\n\t/* Get string length */\r\n\r\n\tlen = tvb_get_letohl(tvb, start_offset);\r\n\r\n\ts = tvb_get_string_enc(pinfo->pool,\r\n\t\ttvb, start_offset + 4, (end_offset - start_offset - 4), ENC_UTF_16|ENC_LITTLE_ENDIAN);\r\n\r\n\t/* Append string to upper-level proto_items */\r\n\r\n\tlevels = 2;\r\n\r\n\tif (levels > 0 && item && s && s[0]) {\r\n\t\tproto_item_append_text(item, \": %s\", s);\r\n\t\titem = item->parent;\r\n\t\tlevels--;\r\n\t\tif (levels > 0) {\r\n\t\t\tproto_item_append_text(item, \": %s\", s);\r\n\t\t\titem = item->parent;\r\n\t\t\tlevels--;\r\n\t\t\twhile (levels > 0) {\r\n\t\t\t\tproto_item_append_text(item, \" %s\", s);\r\n\t\t\t\titem = item->parent;\r\n\t\t\t\tlevels--;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/* Add hidden field so filter brings up any notify data */\r\n\r\n\tif (hf_index > 0) {\r\n\t\thidden_item = proto_tree_add_string(\r\n\t\t\ttree, hf_index, tvb, start_offset, len, s);\r\n\t\tproto_item_set_hidden(hidden_item);\r\n\t}\r\n}", ".rinter_notify_hf_index": "static int\r\nprinter_notify_hf_index(int field)\r\n{\r\n\tint result = -1;\r\n\r\n\tswitch(field) {\r\n\tcase PRINTER_NOTIFY_SERVER_NAME:\r\n\t\tresult = hf_servername;\r\n\t\tbreak;\r\n\tcase PRINTER_NOTIFY_PRINTER_NAME:\r\n\t\tresult = hf_printername;\r\n\t\tbreak;\r\n\tcase PRINTER_NOTIFY_SHARE_NAME:\r\n\t\tresult = hf_sharename;\r\n\t\tbreak;\r\n\tcase PRINTER_NOTIFY_PORT_NAME:\r\n\t\tresult = hf_portname;\r\n\t\tbreak;\r\n\tcase PRINTER_NOTIFY_DRIVER_NAME:\r\n\t\tresult = hf_drivername;\r\n\t\tbreak;\r\n\tcase PRINTER_NOTIFY_COMMENT:\r\n\t\tresult = hf_printercomment;\r\n\t\tbreak;\r\n\tcase PRINTER_NOTIFY_LOCATION:\r\n\t\tresult = hf_printerlocation;\r\n\t\tbreak;\r\n\tcase PRINTER_NOTIFY_SEPFILE:\r\n\t\tresult = hf_sepfile;\r\n\t\tbreak;\r\n\tcase PRINTER_NOTIFY_PRINT_PROCESSOR:\r\n\t\tresult = hf_printprocessor;\r\n\t\tbreak;\r\n\tcase PRINTER_NOTIFY_PARAMETERS:\r\n\t\tresult = hf_parameters;\r\n\t\tbreak;\r\n\tcase PRINTER_NOTIFY_DATATYPE:\r\n\t\tresult = hf_parameters;\r\n\t\tbreak;\r\n\t}\r\n\r\n\treturn result;\r\n}", ".ob_notify_hf_index": "static int\r\njob_notify_hf_index(int field)\r\n{\r\n\tint result = -1;\r\n\r\n\tswitch(field) {\r\n\tcase JOB_NOTIFY_PRINTER_NAME:\r\n\t\tresult = hf_printername;\r\n\t\tbreak;\r\n\tcase JOB_NOTIFY_MACHINE_NAME:\r\n\t\tresult = hf_machinename;\r\n\t\tbreak;\r\n\tcase JOB_NOTIFY_PORT_NAME:\r\n\t\tresult = hf_portname;\r\n\t\tbreak;\r\n\tcase JOB_NOTIFY_USER_NAME:\r\n\t\tresult = hf_username;\r\n\t\tbreak;\r\n\tcase JOB_NOTIFY_NOTIFY_NAME:\r\n\t\tresult = hf_notifyname;\r\n\t\tbreak;\r\n\tcase JOB_NOTIFY_DATATYPE:\r\n\t\tresult = hf_datatype;\r\n\t\tbreak;\r\n\tcase JOB_NOTIFY_PRINT_PROCESSOR:\r\n\t\tresult = hf_printprocessor;\r\n\t\tbreak;\r\n\tcase JOB_NOTIFY_DRIVER_NAME:\r\n\t\tresult = hf_drivername;\r\n\t\tbreak;\r\n\tcase JOB_NOTIFY_DOCUMENT:\r\n\t\tresult = hf_documentname;\r\n\t\tbreak;\r\n\tcase JOB_NOTIFY_PRIORITY:\r\n\t\tresult = hf_job_priority;\r\n\t\tbreak;\r\n\tcase JOB_NOTIFY_POSITION:\r\n\t\tresult = hf_job_position;\r\n\t\tbreak;\r\n\tcase JOB_NOTIFY_TOTAL_PAGES:\r\n\t\tresult = hf_job_totalpages;\r\n\t\tbreak;\r\n\tcase JOB_NOTIFY_PAGES_PRINTED:\r\n\t\tresult = hf_job_pagesprinted;\r\n\t\tbreak;\r\n\tcase JOB_NOTIFY_TOTAL_BYTES:\r\n\t\tresult = hf_job_totalbytes;\r\n\t\tbreak;\r\n\tcase JOB_NOTIFY_BYTES_PRINTED:\r\n\t\tresult = hf_job_bytesprinted;\r\n\t\tbreak;\r\n\t}\r\n\r\n\treturn result;\r\n}", ".issect_SYSTEM_TIME_ptr": "static int\r\ndissect_SYSTEM_TIME_ptr(tvbuff_t *tvb, int offset, packet_info *pinfo,\r\n\t\t\tproto_tree *tree, dcerpc_info *di, uint8_t *drep)\r\n{\r\n\tdcerpc_call_value *dcv = (dcerpc_call_value *)di->call_data;\r\n\tchar *str;\r\n\r\n\r\n\toffset =  dissect_SYSTEM_TIME(\r\n\t\ttvb, offset, pinfo, tree, di, drep, NULL, false, &str);\r\n\tdcv->private_data = wmem_strdup(wmem_file_scope(), str);\r\n\r\n\treturn offset;\r\n}", ".otify_job_time_cb": "static void\r\nnotify_job_time_cb(packet_info *pinfo _U_, proto_tree *tree _U_,\r\n\t\t\t       proto_item *item, dcerpc_info *di, tvbuff_t *tvb _U_,\r\n\t\t\t       int start_offset _U_, int end_offset _U_,\r\n\t\t\t       void *callback_args _U_)\r\n{\r\n\tdcerpc_call_value *dcv = (dcerpc_call_value *)di->call_data;\r\n\tchar *str = (char *)dcv->private_data;\r\n\r\n\t/* Append job string stored in dcv->private_data by\r\n\t   dissect_SYSTEM_TIME_ptr() in the current item as well\r\n\t   as the parent. */\r\n\r\n\tproto_item_append_text(item, \": %s\", str);\r\n\r\n\tif (item)\r\n\t\tproto_item_append_text(item->parent, \": %s\", str);\r\n}", ".issect_NOTIFY_INFO_DATA_printer": "static int\r\ndissect_NOTIFY_INFO_DATA_printer(tvbuff_t *tvb, int offset, packet_info *pinfo,\r\n\t\t\t\t proto_tree *tree, proto_item *item,\r\n\t\t\t\t dcerpc_info *di, uint8_t *drep, uint16_t field)\r\n{\r\n\tuint32_t value1;\r\n\r\n\tswitch (field) {\r\n\r\n\t\t/* String notify data */\r\n\r\n\tcase PRINTER_NOTIFY_SERVER_NAME:\r\n\tcase PRINTER_NOTIFY_PRINTER_NAME:\r\n\tcase PRINTER_NOTIFY_SHARE_NAME:\r\n\tcase PRINTER_NOTIFY_DRIVER_NAME:\r\n\tcase PRINTER_NOTIFY_COMMENT:\r\n\tcase PRINTER_NOTIFY_LOCATION:\r\n\tcase PRINTER_NOTIFY_SEPFILE:\r\n\tcase PRINTER_NOTIFY_PRINT_PROCESSOR:\r\n\tcase PRINTER_NOTIFY_PARAMETERS:\r\n\tcase PRINTER_NOTIFY_DATATYPE:\r\n\tcase PRINTER_NOTIFY_PORT_NAME:\r\n\r\n\t\toffset = dissect_ndr_uint32(\r\n\t\t\ttvb, offset, pinfo, tree, di, drep,\r\n\t\t\thf_notify_info_data_bufsize, &value1);\r\n\r\n\t\toffset = dissect_ndr_pointer_cb(\r\n\t\t\ttvb, offset, pinfo, tree, di, drep,\r\n\t\t\tdissect_notify_info_data_buffer,\r\n\t\t\tNDR_POINTER_UNIQUE, \"String\",\r\n\t\t\thf_notify_info_data_buffer,\r\n\t\t\tcb_notify_str_postprocess,\r\n\t\t\tGINT_TO_POINTER(printer_notify_hf_index(field)));\r\n\r\n\t\tbreak;\r\n\r\n\tcase PRINTER_NOTIFY_ATTRIBUTES:\r\n\r\n\t\t/* Value 1 is the printer attributes */\r\n\r\n\t\toffset = dissect_printer_attributes(\r\n\t\t\ttvb, offset, pinfo, tree, di, drep);\r\n\r\n\t\toffset = dissect_ndr_uint32(\r\n\t\t\ttvb, offset, pinfo, NULL, di, drep,\r\n\t\t\thf_notify_info_data_value2, NULL);\r\n\r\n\t\tbreak;\r\n\r\n\tcase PRINTER_NOTIFY_STATUS: {\r\n\t\tuint32_t status;\r\n\r\n\t\t/* Value 1 is the printer status */\r\n\r\n \t\toffset = dissect_ndr_uint32(\r\n\t\t\ttvb, offset, pinfo, tree, di, drep,\r\n\t\t\thf_printer_status, &status);\r\n\r\n\t\toffset = dissect_ndr_uint32(\r\n\t\t\ttvb, offset, pinfo, NULL, di, drep,\r\n\t\t\thf_notify_info_data_value2, NULL);\r\n\r\n\t\tproto_item_append_text(\r\n\t\t\titem, \": %s\",\r\n\t\t\tval_to_str_ext_const(status, &printer_status_vals_ext, \"Unknown\"));\r\n\r\n\t\tbreak;\r\n\t}\r\n\r\n\t\t/* Unknown notify data */\r\n\r\n\tcase PRINTER_NOTIFY_SECURITY_DESCRIPTOR: /* Secdesc */\r\n\tcase PRINTER_NOTIFY_DEVMODE: /* Devicemode */\r\n\r\n\t\toffset = dissect_ndr_uint32(\r\n\t\t\ttvb, offset, pinfo, tree, di, drep,\r\n\t\t\thf_notify_info_data_bufsize, &value1);\r\n\r\n\t\toffset = dissect_ndr_pointer(\r\n\t\t\ttvb, offset, pinfo, tree, di, drep,\r\n\t\t\tdissect_notify_info_data_buffer,\r\n\t\t\tNDR_POINTER_UNIQUE, \"Buffer\",\r\n\t\t\thf_notify_info_data_buffer);\r\n\r\n\t\tbreak;\r\n\r\n\tdefault:\r\n\t\toffset = dissect_ndr_uint32(\r\n\t\t\ttvb, offset, pinfo, tree, di, drep,\r\n\t\t\thf_notify_info_data_value1, NULL);\r\n\r\n\t\toffset = dissect_ndr_uint32(\r\n\t\t\ttvb, offset, pinfo, tree, di, drep,\r\n\t\t\thf_notify_info_data_value2, NULL);\r\n\r\n\t\tbreak;\r\n\t}\r\n\treturn offset;\r\n}", ".issect_NOTIFY_INFO_DATA_job": "static int\r\ndissect_NOTIFY_INFO_DATA_job(tvbuff_t *tvb, int offset, packet_info *pinfo,\r\n\t\t\t     proto_tree *tree, proto_item *item, dcerpc_info *di, uint8_t *drep,\r\n\t\t\t     uint16_t field)\r\n{\r\n\tuint32_t value1;\r\n\tproto_item *hidden_item;\r\n\r\n\tswitch (field) {\r\n\r\n\t\t/* String notify data */\r\n\r\n\tcase JOB_NOTIFY_PRINTER_NAME:\r\n\tcase JOB_NOTIFY_MACHINE_NAME:\r\n\tcase JOB_NOTIFY_PORT_NAME:\r\n\tcase JOB_NOTIFY_USER_NAME:\r\n\tcase JOB_NOTIFY_NOTIFY_NAME:\r\n\tcase JOB_NOTIFY_DATATYPE:\r\n\tcase JOB_NOTIFY_PRINT_PROCESSOR:\r\n\tcase JOB_NOTIFY_PARAMETERS:\r\n\tcase JOB_NOTIFY_DRIVER_NAME:\r\n\tcase JOB_NOTIFY_STATUS_STRING:\r\n\tcase JOB_NOTIFY_DOCUMENT:\r\n\r\n\t\toffset = dissect_ndr_uint32(\r\n\t\t\ttvb, offset, pinfo, tree, di, drep,\r\n\t\t\thf_notify_info_data_bufsize, &value1);\r\n\r\n\t\toffset = dissect_ndr_pointer_cb(\r\n\t\t\ttvb, offset, pinfo, tree, di, drep,\r\n\t\t\tdissect_notify_info_data_buffer,\r\n\t\t\tNDR_POINTER_UNIQUE, \"String\",\r\n\t\t\thf_notify_info_data_buffer,\r\n\t\t\tcb_notify_str_postprocess,\r\n\t\t\tGINT_TO_POINTER(job_notify_hf_index(field)));\r\n\r\n\t\tbreak;\r\n\r\n\tcase JOB_NOTIFY_STATUS:\r\n\t\toffset = dissect_job_status(\r\n\t\t\ttvb, offset, pinfo, tree, di, drep);\r\n\r\n\t\toffset = dissect_ndr_uint32(\r\n\t\t\ttvb, offset, pinfo, NULL, di, drep,\r\n\t\t\thf_notify_info_data_value2, NULL);\r\n\r\n\t\tbreak;\r\n\r\n\tcase JOB_NOTIFY_SUBMITTED:\r\n\r\n\t\t/* SYSTEM_TIME */\r\n\r\n\t\toffset = dissect_ndr_uint32(\r\n\t\t\ttvb, offset, pinfo, tree, di, drep,\r\n\t\t\thf_notify_info_data_buffer_len, NULL);\r\n\r\n\t\toffset = dissect_ndr_pointer_cb(\r\n\t\t\ttvb, offset, pinfo, tree, di, drep,\r\n\t\t\tdissect_SYSTEM_TIME_ptr, NDR_POINTER_UNIQUE,\r\n\t\t\t\"Time submitted\", -1, notify_job_time_cb, NULL);\r\n\r\n\t\tbreak;\r\n\r\n\tcase JOB_NOTIFY_PRIORITY:\r\n\tcase JOB_NOTIFY_POSITION:\r\n\tcase JOB_NOTIFY_TOTAL_PAGES:\r\n\tcase JOB_NOTIFY_PAGES_PRINTED:\r\n\tcase JOB_NOTIFY_TOTAL_BYTES:\r\n\tcase JOB_NOTIFY_BYTES_PRINTED: {\r\n\t\tuint32_t value;\r\n\r\n\t\toffset = dissect_ndr_uint32(\r\n\t\t\ttvb, offset, pinfo, tree, di, drep,\r\n\t\t\thf_notify_info_data_value1, &value);\r\n\r\n\t\toffset = dissect_ndr_uint32(\r\n\t\t\ttvb, offset, pinfo, tree, di, drep,\r\n\t\t\thf_notify_info_data_value2, NULL);\r\n\r\n\t\tproto_item_append_text(item, \": %d\", value);\r\n\r\n\t\thidden_item = proto_tree_add_uint(\r\n\t\t\ttree, job_notify_hf_index(field), tvb,\r\n\t\t\toffset, 4, value);\r\n\t\tproto_item_set_hidden(hidden_item);\r\n\r\n\t\tbreak;\r\n\t}\r\n\r\n\t\t/* Unknown notify data */\r\n\r\n\tcase JOB_NOTIFY_DEVMODE:\r\n\r\n\t\toffset = dissect_ndr_uint32(\r\n\t\t\ttvb, offset, pinfo, tree, di, drep,\r\n\t\t\thf_notify_info_data_bufsize, &value1);\r\n\r\n\t\toffset = dissect_ndr_pointer(\r\n\t\t\ttvb, offset, pinfo, tree, di, drep,\r\n\t\t\tdissect_notify_info_data_buffer,\r\n\t\t\tNDR_POINTER_UNIQUE, \"Buffer\",\r\n\t\t\thf_notify_info_data_buffer);\r\n\r\n\t\tbreak;\r\n\r\n\tdefault:\r\n\t\toffset = dissect_ndr_uint32(\r\n\t\t\ttvb, offset, pinfo, tree, di, drep,\r\n\t\t\thf_notify_info_data_value1, NULL);\r\n\r\n\t\toffset = dissect_ndr_uint32(\r\n\t\t\ttvb, offset, pinfo, tree, di, drep,\r\n\t\t\thf_notify_info_data_value2, NULL);\r\n\t}\r\n\treturn offset;\r\n}", ".issect_NOTIFY_INFO_DATA": "static int\r\ndissect_NOTIFY_INFO_DATA(tvbuff_t *tvb, int offset, packet_info *pinfo,\r\n\t\t\t proto_tree *tree, dcerpc_info *di, uint8_t *drep)\r\n{\r\n\tproto_item *item;\r\n\tproto_tree *subtree;\r\n\tuint32_t count;\r\n\tuint16_t type, field;\r\n\tconst char *field_string;\r\n\r\n\tsubtree = proto_tree_add_subtree(tree, tvb, offset, 0, ett_NOTIFY_INFO_DATA, &item, \"\");\r\n\r\n\toffset = dissect_ndr_uint16(\r\n\t\ttvb, offset, pinfo, subtree, di, drep,\r\n\t\thf_notify_info_data_type, &type);\r\n\r\n\toffset = dissect_notify_field(\r\n\t\ttvb, offset, pinfo, subtree, di, drep, type, &field);\r\n\r\n\tswitch(type) {\r\n\tcase PRINTER_NOTIFY_TYPE:\r\n\t\tfield_string = val_to_str_ext(pinfo->pool,\r\n\t\t\tfield, &printer_notify_option_data_vals_ext,\r\n\t\t\t\"Unknown (%d)\");\r\n\t\tbreak;\r\n\tcase JOB_NOTIFY_TYPE:\r\n\t\tfield_string = val_to_str_ext(pinfo->pool,\r\n\t\t\tfield, &job_notify_option_data_vals_ext,\r\n\t\t\t\"Unknown (%d)\");\r\n\t\tbreak;\r\n\tdefault:\r\n\t\tfield_string = \"Unknown field\";\r\n\t\tbreak;\r\n\t}\r\n\r\n\tproto_item_append_text(\r\n\t\titem, \"%s, %s\",\r\n\t\tval_to_str_wmem(pinfo->pool, type, printer_notify_types, \"Unknown (%d)\"),\r\n\t\tfield_string);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, subtree, di, drep,\r\n\t\thf_notify_info_data_count, &count);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, subtree, di, drep,\r\n\t\thf_notify_info_data_id, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, subtree, di, drep,\r\n\t\thf_notify_info_data_count, NULL);\r\n\r\n\t/* The value here depends on (type, field) */\r\n\r\n\tswitch (type) {\r\n\tcase PRINTER_NOTIFY_TYPE:\r\n\t\toffset = dissect_NOTIFY_INFO_DATA_printer(\r\n\t\t\ttvb, offset, pinfo, subtree, item, di, drep, field);\r\n\t\tbreak;\r\n\tcase JOB_NOTIFY_TYPE:\r\n\t\toffset = dissect_NOTIFY_INFO_DATA_job(\r\n\t\t\ttvb, offset, pinfo, subtree, item, di, drep, field);\r\n\t\tbreak;\r\n\tdefault:\r\n\t\texpert_add_info(pinfo, item, &ei_notify_info_data_type);\r\n\t\tbreak;\r\n\t}\r\n\r\n\treturn offset;\r\n}", ".issect_NOTIFY_INFO": "int\r\ndissect_NOTIFY_INFO(tvbuff_t *tvb, int offset, packet_info *pinfo,\r\n\t\t    proto_tree *tree, dcerpc_info *di, uint8_t *drep)\r\n{\r\n\tuint32_t count;\r\n\r\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, tree, di, drep,\r\n\t\t\t\t    hf_notify_info_version, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, tree, di, drep,\r\n\t\t\t\t    hf_notify_info_flags, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, tree, di, drep,\r\n\t\t\t\t    hf_notify_info_count, &count);\r\n\r\n\tif (!di->conformant_run)\r\n\t\tcol_append_fstr(\r\n\t\t\tpinfo->cinfo, COL_INFO, \", %d %s\", count,\r\n\t\t\tnotify_plural(count));\r\n\r\n\toffset = dissect_ndr_ucarray(tvb, offset, pinfo, tree, di, drep,\r\n\t\t\t\t     dissect_NOTIFY_INFO_DATA);\r\n\r\n\treturn offset;\r\n}", ".issect_spoolss_keybuffer": "static int\r\ndissect_spoolss_keybuffer(tvbuff_t *tvb, int offset, packet_info *pinfo,\r\n\t\t\t  proto_tree *tree, dcerpc_info *di, uint8_t *drep)\r\n{\r\n\tuint32_t size;\r\n\tint end_offset;\r\n\r\n\tif (di->conformant_run)\r\n\t\treturn offset;\r\n\r\n\t/* Dissect size and data */\r\n\r\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, tree, di, drep,\r\n\t\t\t\t    hf_keybuffer_size, &size);\r\n\r\n\tend_offset = offset + (size*2);\r\n\tif (end_offset < offset) {\r\n\t\t/*\r\n\t\t * Overflow - make the end offset one past the end of\r\n\t\t * the packet data, so we throw an exception (as the\r\n\t\t * size is almost certainly too big).\r\n\t\t */\r\n\t\tend_offset = tvb_reported_length_remaining(tvb, offset) + 1;\r\n\t}\r\n\r\n\twhile (offset > 0 && offset < end_offset) {\r\n\t\toffset = dissect_spoolss_uint16uni(\r\n\t\t\ttvb, offset, pinfo, tree, drep, NULL, hf_keybuffer);\r\n\t}\r\n\r\n\treturn offset;\r\n}", ".issect_spoolss_printer_enum_values": "static int\r\ndissect_spoolss_printer_enum_values(tvbuff_t *tvb, int offset,\r\n\t\t\t\t    packet_info *pinfo, proto_tree *tree,\r\n\t\t\t\t    dcerpc_info *di, uint8_t *drep)\r\n{\r\n\tuint32_t start_offset = offset;\r\n\tuint32_t name_offset, name_len, val_offset, val_len, val_type;\r\n\tchar *name;\r\n\tproto_item *item;\r\n\tproto_tree *subtree;\r\n\r\n\t/* Get offset of value name */\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, NULL, di, drep,\r\n\t\thf_enumprinterdataex_name_offset, &name_offset);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, NULL, di, drep,\r\n\t\thf_enumprinterdataex_name_len, &name_len);\r\n\r\n\tdissect_spoolss_uint16uni(\r\n\t\ttvb, start_offset + name_offset, pinfo, NULL, drep,\r\n\t\t&name, hf_enumprinterdataex_name);\r\n\r\n\tsubtree = proto_tree_add_subtree_format(tree, tvb, offset, 0, ett_printer_enumdataex_value, &item, \"Name: %s\", name);\r\n\r\n\tproto_tree_add_uint(subtree, hf_enumprinterdataex_name_offset, tvb, offset - 8, 4, name_offset);\r\n\r\n\tproto_tree_add_uint(subtree, hf_enumprinterdataex_name_len, tvb, offset - 4, 4, name_len);\r\n\r\n\tproto_tree_add_string( subtree, hf_enumprinterdataex_name, tvb, start_offset + name_offset, ((int)strlen(name) + 1) * 2, name);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_printerdata_type,\r\n\t\t&val_type);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, subtree, di, drep,\r\n\t\thf_enumprinterdataex_val_offset, &val_offset);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, subtree, di, drep,\r\n\t\thf_enumprinterdataex_val_len, &val_len);\r\n\r\n\tif (val_len == 0) {\r\n\t\tproto_tree_add_uint_format_value(subtree, hf_enumprinterdataex_value_null, tvb, start_offset + val_offset, 4, 0, \"(null)\");\r\n\t\treturn offset;\r\n\t}\r\n\r\n\tswitch(val_type) {\r\n\tcase DCERPC_REG_DWORD: {\r\n\t\tuint32_t value;\r\n\t\tuint16_t low, high;\r\n\t\tint offset2 = start_offset + val_offset;\r\n\r\n\t\t/* Needs to be broken into two 16-byte ints because it may\r\n\t\t   not be aligned. */\r\n\r\n\t\toffset2 = dissect_ndr_uint16(\r\n\t\t\ttvb, offset2, pinfo, subtree, di, drep,\r\n\t\t\thf_enumprinterdataex_val_dword_low, &low);\r\n\r\n\t\t/*offset2 = */dissect_ndr_uint16(\r\n\t\t\ttvb, offset2, pinfo, subtree, di, drep,\r\n\t\t\thf_enumprinterdataex_val_dword_high, &high);\r\n\r\n\t\tvalue = (high << 16) | low;\r\n\r\n\t\tproto_tree_add_uint(subtree, hf_enumprinterdataex_value_uint, tvb, start_offset + val_offset, 4, value);\r\n\r\n\t\tproto_item_append_text(item, \", Value: %d\", value);\r\n\r\n\t\tbreak;\r\n\t}\r\n\tcase DCERPC_REG_SZ: {\r\n\t\tchar *value;\r\n\r\n\t\tdissect_spoolss_uint16uni(\r\n\t\t\ttvb, start_offset + val_offset, pinfo, subtree, drep,\r\n\t\t\t&value, hf_value_string);\r\n\r\n\t\tproto_item_append_text(item, \", Value: %s\", value);\r\n\r\n\t\tbreak;\r\n\t}\r\n\tcase DCERPC_REG_BINARY:\r\n\r\n\t\t/* FIXME: nicer way to display this */\r\n\r\n\t\tproto_tree_add_bytes_format_value( subtree, hf_enumprinterdataex_value_binary, tvb, start_offset + val_offset, val_len, NULL, \"<binary data>\");\r\n\t\tbreak;\r\n\r\n\tcase DCERPC_REG_MULTI_SZ:\r\n\r\n\t\t/* FIXME: implement REG_MULTI_SZ support */\r\n\r\n\t\tproto_tree_add_bytes_format_value(subtree, hf_enumprinterdataex_value_multi_sz, tvb, start_offset + val_offset, val_len, NULL, \"<REG_MULTI_SZ not implemented>\");\r\n\t\tbreak;\r\n\r\n\tdefault:\r\n\t\tproto_tree_add_expert_format( subtree, pinfo, &ei_enumprinterdataex_value, tvb, start_offset + val_offset, val_len, \"%s: unknown type %d\", name, val_type);\r\n\t}\r\n\r\n\treturn offset;\r\n}", ".issect_spoolss_string_parm": "static int\r\ndissect_spoolss_string_parm(tvbuff_t *tvb, int offset, packet_info *pinfo,\r\n\t\t       proto_tree *tree, dcerpc_info *di, uint8_t *drep, const char *text)\r\n{\r\n\toffset = dissect_ndr_pointer(\r\n\t\ttvb, offset, pinfo, tree, di, drep,\r\n\t\tdissect_spoolss_string_parm_data, NDR_POINTER_UNIQUE,\r\n\t\ttext, -1);\r\n\r\n\treturn offset;\r\n}", ".issect_CORE_PRINTER_DRIVER": "static int\r\ndissect_CORE_PRINTER_DRIVER(tvbuff_t *tvb, int offset,\r\n\t\t\t\t packet_info *pinfo, proto_tree *tree,\r\n\t\t\t\t dcerpc_info *di, uint8_t *drep)\r\n{\r\n\tproto_tree *subtree;\r\n\r\n\tALIGN_TO_5_BYTES;\r\n\r\n\tsubtree = proto_tree_add_subtree(\r\n\t\ttree, tvb, offset, 0, ett_CORE_PRINTER_DRIVER, NULL, \"Core Printer Driver\");\r\n\r\n\toffset = dissect_ndr_uuid_t(tvb, offset, pinfo, subtree, di, drep,\r\n\t\thf_core_driver_guid, NULL);\r\n\r\n\toffset = dissect_ndr_nt_NTTIME(tvb, offset, pinfo, subtree, di, drep,\r\n\t\thf_driverdate);\r\n\r\n\toffset = dissect_ndr_uint64(tvb, offset, pinfo, subtree, di, drep,\r\n\t\thf_driver_version, NULL);\r\n\r\n\t/* The package id is stored in a 260-wchar buffer */\r\n\r\n\tdissect_spoolss_uint16uni(tvb, offset, pinfo, subtree, drep, NULL,\r\n\t\thf_package_id);\r\n\r\n\toffset += 520;\r\n\r\n\tif (di->call_data->flags & DCERPC_IS_NDR64) {\r\n\t\tALIGN_TO_5_BYTES;\r\n\t}\r\n\r\n\treturn offset;\r\n}"}, "callee": {".issect_spoolss_buffer": "static int\r\ndissect_spoolss_buffer(tvbuff_t *tvb, int offset, packet_info *pinfo,\r\n\t\t       proto_tree *tree, dcerpc_info *di, uint8_t *drep, BUFFER *b)\r\n{\r\n\tif (b)\r\n\t\tmemset(b, 0, sizeof(BUFFER));\r\n\r\n\tdi->private_data = b;\r\n\r\n\toffset = dissect_ndr_pointer(\r\n\t\ttvb, offset, pinfo, tree, di, drep,\r\n\t\tdissect_spoolss_buffer_data, NDR_POINTER_UNIQUE,\r\n\t\t\"Buffer\", -1);\r\n\r\n\treturn offset;\r\n}", ".poolssGetPrinter_q": "static int\r\nSpoolssGetPrinter_q(tvbuff_t *tvb, int offset, packet_info *pinfo,\r\n\t\t\t       proto_tree *tree, dcerpc_info *di, uint8_t *drep )\r\n{\r\n\tdcerpc_call_value *dcv = (dcerpc_call_value *)di->call_data;\r\n\tuint32_t level;\r\n\r\n\t/* Parse packet */\r\n\r\n\toffset = dissect_nt_policy_hnd(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_hnd, NULL, NULL,\r\n\t\tPIDL_POLHND_USE);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_level, &level);\r\n\r\n\t/* GetPrinter() stores the level in se_data */\r\n\tif(!pinfo->fd->visited){\r\n\t\t\tdcv->se_data = GINT_TO_POINTER((int)level);\r\n\t}\r\n\r\n\r\n\tcol_append_fstr(pinfo->cinfo, COL_INFO, \", level %d\", level);\r\n\r\n\toffset = dissect_spoolss_buffer(\r\n\t\ttvb, offset, pinfo, tree, di, drep, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_offered, NULL);\r\n\r\n\treturn offset;\r\n}", ".poolssGetPrinter_r": "static int\r\nSpoolssGetPrinter_r(tvbuff_t *tvb, int offset, packet_info *pinfo,\r\n\t\t\t\tproto_tree *tree, dcerpc_info *di, uint8_t *drep)\r\n{\r\n\tdcerpc_call_value *dcv = (dcerpc_call_value *)di->call_data;\r\n\tBUFFER buffer;\r\n\tint16_t level = GPOINTER_TO_INT(dcv->se_data);\r\n\tproto_item *item = NULL;\r\n\tproto_tree *subtree = NULL;\r\n\r\n\tcol_append_fstr(pinfo->cinfo, COL_INFO, \", level %d\", level);\r\n\r\n\t/* Parse packet */\r\n\r\n\toffset = dissect_spoolss_buffer(\r\n\t\ttvb, offset, pinfo, tree, di, drep, &buffer);\r\n\r\n\tif (buffer.tvb) {\r\n\t\tsubtree = proto_tree_add_subtree_format( buffer.tree, buffer.tvb, 0, -1, ett_PRINTER_INFO, &item, \"Print info level %d\", level);\r\n\r\n\t\tswitch(level) {\r\n\t\tcase 0:\r\n\t\t\tdissect_PRINTER_INFO_0(\r\n\t\t\t\tbuffer.tvb, 0, pinfo, subtree, di, drep);\r\n\t\t\tbreak;\r\n\t\tcase 1:\r\n\t\t\tdissect_PRINTER_INFO_1(\r\n\t\t\t\tbuffer.tvb, 0, pinfo, subtree, di, drep);\r\n\t\t\tbreak;\r\n\t\tcase 2:\r\n\t\t\tdissect_PRINTER_INFO_2(\r\n\t\t\t\tbuffer.tvb, 0, pinfo, subtree, di, drep);\r\n\t\t\tbreak;\r\n\t\tcase 3:\r\n\t\t\tdissect_PRINTER_INFO_3(\r\n\t\t\t\tbuffer.tvb, 0, pinfo, subtree, di, drep);\r\n\t\t\tbreak;\r\n\t\tcase 5:\r\n\t\t\tdissect_PRINTER_INFO_5(\r\n\t\t\t\tbuffer.tvb, 0, pinfo, subtree, di, drep);\r\n\t\t\tbreak;\r\n\t\tcase 7:\r\n\t\t\tdissect_PRINTER_INFO_7(\r\n\t\t\t\tbuffer.tvb, 0, pinfo, subtree, di, drep);\r\n\t\t\tbreak;\r\n\t\tdefault:\r\n\t\t\texpert_add_info(pinfo, item, &ei_printer_info_level);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_needed, NULL);\r\n\r\n\toffset = dissect_doserror(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_rc, NULL);\r\n\r\n\treturn offset;\r\n}", ".poolssEnumForms_q": "static int\r\nSpoolssEnumForms_q(tvbuff_t *tvb, int offset, packet_info *pinfo,\r\n\t\t\t      proto_tree *tree, dcerpc_info *di, uint8_t *drep)\r\n{\r\n\tdcerpc_call_value *dcv = (dcerpc_call_value *)di->call_data;\r\n\tuint32_t level;\r\n\tproto_item *hidden_item;\r\n\r\n\thidden_item = proto_tree_add_uint(\r\n\t\ttree, hf_form, tvb, offset, 0, 1);\r\n\tproto_item_set_hidden(hidden_item);\r\n\r\n\t/* Parse packet */\r\n\r\n\toffset = dissect_nt_policy_hnd(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_hnd, NULL, NULL,\r\n\t\tPIDL_POLHND_USE);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_level, &level);\r\n\r\n\t/* EnumForms() stores the level in se_data */\r\n\tif(!pinfo->fd->visited){\r\n\t\t\tdcv->se_data = GINT_TO_POINTER((int)level);\r\n\t}\r\n\r\n\tcol_append_fstr(pinfo->cinfo, COL_INFO, \", level %d\", level);\r\n\r\n\toffset = dissect_spoolss_buffer(\r\n\t\ttvb, offset, pinfo, tree, di, drep, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_offered, NULL);\r\n\r\n\treturn offset;\r\n}", ".poolssEnumForms_r": "static int\r\nSpoolssEnumForms_r(tvbuff_t *tvb, int offset, packet_info *pinfo,\r\n\t\t\t      proto_tree *tree, dcerpc_info *di, uint8_t *drep)\r\n{\r\n\tdcerpc_call_value *dcv = (dcerpc_call_value *)di->call_data;\r\n\tBUFFER buffer;\r\n\tuint32_t level = GPOINTER_TO_UINT(dcv->se_data), i, count;\r\n\tint buffer_offset;\r\n\tproto_item *hidden_item;\r\n\r\n\thidden_item = proto_tree_add_uint(\r\n\t\ttree, hf_form, tvb, offset, 0, 1);\r\n\tproto_item_set_hidden(hidden_item);\r\n\r\n\t/* Parse packet */\r\n\r\n\toffset = dissect_spoolss_buffer(\r\n\t\ttvb, offset, pinfo, tree, di, drep, &buffer);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_needed, NULL);\r\n\r\n\tcol_append_fstr(pinfo->cinfo, COL_INFO, \", level %d\", level);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_enumforms_num, &count);\r\n\r\n\t/* Unfortunately this array isn't in NDR format so we can't\r\n\t   use prs_array().  The other weird thing is the\r\n\t   struct_start being inside the loop rather than outside.\r\n\t   Very strange. */\r\n\r\n\tbuffer_offset = 0;\r\n\r\n\tfor (i = 0; i < count; i++) {\r\n\t\tint struct_start = buffer_offset;\r\n\r\n\t\tbuffer_offset = dissect_FORM_REL(\r\n\t\t\tbuffer.tvb, buffer_offset, pinfo, buffer.tree, di, drep,\r\n\t\t\tstruct_start);\r\n\t}\r\n\r\n\toffset = dissect_doserror(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_rc, NULL);\r\n\r\n\treturn offset;\r\n}", ".poolssEnumPrinters_q": "static int\r\nSpoolssEnumPrinters_q(tvbuff_t *tvb, int offset, packet_info *pinfo,\r\n\t\t\t\t proto_tree *tree, dcerpc_info *di, uint8_t *drep)\r\n{\r\n\tuint32_t level, flags;\r\n\tdcerpc_call_value *dcv = (dcerpc_call_value *)di->call_data;\r\n\tstatic int * const hf_flags[] = {\r\n\t\t&hf_enumprinters_flags_network,\r\n\t\t&hf_enumprinters_flags_shared,\r\n\t\t&hf_enumprinters_flags_remote,\r\n\t\t&hf_enumprinters_flags_name,\r\n\t\t&hf_enumprinters_flags_connections,\r\n\t\t&hf_enumprinters_flags_local,\r\n\t\t&hf_enumprinters_flags_default,\r\n\t\tNULL\r\n\t};\r\n\r\n\t/* Parse packet */\r\n\r\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, NULL, di, drep, -1, &flags);\r\n\r\n\tproto_tree_add_bitmask_value(tree, tvb, offset - 4, hf_enumprinters_flags,\r\n\t\t\t\t\tett_enumprinters_flags, hf_flags, flags);\r\n\r\n\toffset = dissect_ndr_str_pointer_item(\r\n\t\ttvb, offset, pinfo, tree, di, drep,\r\n\t\tNDR_POINTER_UNIQUE, \"Server name\", hf_servername, 0);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_level, &level);\r\n\r\n\t/* GetPrinter() stores the level in se_data */\r\n\tif(!pinfo->fd->visited){\r\n\t\tdcv->se_data = GINT_TO_POINTER((int)level);\r\n\t}\r\n\r\n\tcol_append_fstr(pinfo->cinfo, COL_INFO, \", level %d\", level);\r\n\r\n\toffset = dissect_spoolss_buffer(\r\n\t\ttvb, offset, pinfo, tree, di, drep, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_offered, NULL);\r\n\r\n\treturn offset;\r\n}", ".poolssEnumPrinters_r": "static int\r\nSpoolssEnumPrinters_r(tvbuff_t *tvb, int offset, packet_info *pinfo,\r\n\t\t\t\t proto_tree *tree, dcerpc_info *di, uint8_t *drep)\r\n{\r\n\tuint32_t num_drivers;\r\n\tdcerpc_call_value *dcv = (dcerpc_call_value *)di->call_data;\r\n\tint16_t level = GPOINTER_TO_INT(dcv->se_data);\r\n\tBUFFER buffer;\r\n\tproto_item *item;\r\n\tproto_tree *subtree = NULL;\r\n\r\n\tcol_append_fstr(pinfo->cinfo, COL_INFO, \", level %d\", level);\r\n\r\n\t/* Parse packet */\r\n\r\n\toffset = dissect_spoolss_buffer(\r\n\t\ttvb, offset, pinfo, tree, di, drep, &buffer);\r\n\r\n\tif (buffer.tvb) {\r\n\t\tsubtree = proto_tree_add_subtree_format( buffer.tree, buffer.tvb, 0, -1, ett_PRINTER_INFO, &item, \"Print info level %d\", level);\r\n\r\n\t\tswitch(level) {\r\n\t\tcase 0:\r\n\t\t\tdissect_PRINTER_INFO_0(\r\n\t\t\t\tbuffer.tvb, 0, pinfo, subtree, di, drep);\r\n\t\t\tbreak;\r\n\t\tcase 1:\r\n\t\t\tdissect_PRINTER_INFO_1(\r\n\t\t\t\tbuffer.tvb, 0, pinfo, subtree, di, drep);\r\n\t\t\tbreak;\r\n\t\tcase 2:\r\n\t\t\tdissect_PRINTER_INFO_2(\r\n\t\t\t\tbuffer.tvb, 0, pinfo, subtree, di, drep);\r\n\t\t\tbreak;\r\n\t\tcase 3:\r\n\t\t\tdissect_PRINTER_INFO_3(\r\n\t\t\t\tbuffer.tvb, 0, pinfo, subtree, di, drep);\r\n\t\t\tbreak;\r\n\t\tcase 5:\r\n\t\t\tdissect_PRINTER_INFO_5(\r\n\t\t\t\tbuffer.tvb, 0, pinfo, subtree, di, drep);\r\n\t\t\tbreak;\r\n\t\tcase 7:\r\n\t\t\tdissect_PRINTER_INFO_7(\r\n\t\t\t\tbuffer.tvb, 0, pinfo, subtree, di, drep);\r\n\t\t\tbreak;\r\n\t\tdefault:\r\n\t\t\texpert_add_info(pinfo, item, &ei_printer_info_level);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_needed, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_returned,\r\n\t\t&num_drivers);\r\n\r\n\toffset = dissect_doserror(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_rc, NULL);\r\n\r\n\treturn offset;\r\n}", ".poolssGetForm_q": "static int\r\nSpoolssGetForm_q(tvbuff_t *tvb, int offset, packet_info *pinfo,\r\n\t\t\t    proto_tree *tree, dcerpc_info *di, uint8_t *drep)\r\n{\r\n\tdcerpc_call_value *dcv = (dcerpc_call_value *)di->call_data;\r\n\tproto_item *hidden_item;\r\n\tuint32_t level;\r\n\tchar *name;\r\n\r\n\thidden_item = proto_tree_add_uint(\r\n\t\ttree, hf_form, tvb, offset, 0, 1);\r\n\tproto_item_set_hidden(hidden_item);\r\n\r\n\t/* Parse packet */\r\n\r\n\toffset = dissect_nt_policy_hnd(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_hnd, NULL, NULL,\r\n\t\tPIDL_POLHND_USE);\r\n\r\n\toffset = dissect_ndr_cvstring(\r\n\t\ttvb, offset, pinfo, tree, di, drep,\r\n\t\tsizeof(uint16_t), hf_form_name, true, &name);\r\n\r\n\tcol_append_fstr(pinfo->cinfo, COL_INFO, \", %s\", name);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_form_level, &level);\r\n\r\n\t/* GetForm() stores the level in se_data */\r\n\tif(!pinfo->fd->visited){\r\n\t\t\tdcv->se_data = GUINT_TO_POINTER((int)level);\r\n\t}\r\n\r\n\tcol_append_fstr(pinfo->cinfo, COL_INFO, \", level %d\",\r\n\t\t\t\tlevel);\r\n\r\n\toffset = dissect_spoolss_buffer(tvb, offset, pinfo, tree, di, drep, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_offered, NULL);\r\n\r\n\treturn offset;\r\n}", ".poolssGetForm_r": "static int\r\nSpoolssGetForm_r(tvbuff_t *tvb, int offset, packet_info *pinfo,\r\n\t\t\t    proto_tree *tree, dcerpc_info *di, uint8_t *drep)\r\n{\r\n\tdcerpc_call_value *dcv = (dcerpc_call_value *)di->call_data;\r\n\tBUFFER buffer;\r\n\tuint32_t level = GPOINTER_TO_UINT(dcv->se_data);\r\n\tproto_item *hidden_item;\r\n\r\n\thidden_item = proto_tree_add_uint(\r\n\t\ttree, hf_form, tvb, offset, 0, 1);\r\n\tproto_item_set_hidden(hidden_item);\r\n\r\n\t/* Parse packet */\r\n\r\n\toffset = dissect_spoolss_buffer(\r\n\t\ttvb, offset, pinfo, tree, di, drep, &buffer);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_needed, NULL);\r\n\r\n\tcol_append_fstr(pinfo->cinfo, COL_INFO, \", level %d\", level);\r\n\r\n\tif (buffer.tvb) {\r\n\t\tint buffer_offset = 0;\r\n\r\n\t\tswitch(level) {\r\n\t\tcase 1: {\r\n\t\t\tint struct_start = buffer_offset;\r\n\r\n\t\t\t/*buffer_offset = */dissect_FORM_REL(\r\n\t\t\t\tbuffer.tvb, buffer_offset, pinfo, tree, di, drep,\r\n\t\t\t\tstruct_start);\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\tdefault:\r\n\t\t\tproto_tree_add_expert_format(buffer.tree, pinfo, &ei_form_level, buffer.tvb, buffer_offset, -1, \"Unknown form info level %d\", level);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\r\n\toffset = dissect_doserror(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_rc, NULL);\r\n\r\n\treturn offset;\r\n}", ".poolssEnumJobs_q": "static int\r\nSpoolssEnumJobs_q(tvbuff_t *tvb, int offset, packet_info *pinfo,\r\n\t\t\t     proto_tree *tree, dcerpc_info *di, uint8_t *drep)\r\n{\r\n\tdcerpc_call_value *dcv = (dcerpc_call_value *)di->call_data;\r\n\tuint32_t level;\r\n\r\n\t/* Parse packet */\r\n\r\n\toffset = dissect_nt_policy_hnd(\r\n\t\ttvb, offset, pinfo, tree, di, drep,\r\n\t\thf_hnd, NULL, NULL, PIDL_POLHND_USE);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_enumjobs_firstjob, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_enumjobs_numjobs, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_level, &level);\r\n\r\n\t/* EnumJobs() stores the level in se_data */\r\n\tif(!pinfo->fd->visited){\r\n\t\t\tdcv->se_data = GUINT_TO_POINTER((int)level);\r\n\t}\r\n\r\n\tcol_append_fstr(pinfo->cinfo, COL_INFO, \", level %d\", level);\r\n\r\n\toffset = dissect_spoolss_buffer(tvb, offset, pinfo, tree, di, drep, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_offered, NULL);\r\n\r\n\treturn offset;\r\n}", ".poolssEnumJobs_r": "static int\r\nSpoolssEnumJobs_r(tvbuff_t *tvb, int offset, packet_info *pinfo,\r\n\t\t\t     proto_tree *tree, dcerpc_info *di, uint8_t *drep)\r\n{\r\n\tdcerpc_call_value *dcv = (dcerpc_call_value *)di->call_data;\r\n\tint16_t level = GPOINTER_TO_UINT(dcv->se_data);\r\n\tBUFFER buffer;\r\n\tuint32_t num_jobs, i;\r\n\tint buffer_offset;\r\n\r\n\t/* Parse packet */\r\n\r\n\toffset = dissect_spoolss_buffer(\r\n\t\ttvb, offset, pinfo, tree, di, drep, &buffer);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_needed, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_enumjobs_numjobs,\r\n\t\t&num_jobs);\r\n\r\n\tbuffer_offset = 0;\r\n\r\n\tfor (i = 0; i < num_jobs; i++) {\r\n\t\tswitch(level) {\r\n\t\tcase 1:\r\n\t\t\tbuffer_offset = dissect_spoolss_JOB_INFO_1(\r\n\t\t\t\tbuffer.tvb, buffer_offset, pinfo,\r\n\t\t\t\tbuffer.tree, di, drep);\r\n\t\t\tbreak;\r\n\t\tcase 2:\r\n\t\t\tbuffer_offset = dissect_spoolss_JOB_INFO_2(\r\n\t\t\t\tbuffer.tvb, buffer_offset, pinfo,\r\n\t\t\t\tbuffer.tree, di, drep);\r\n\t\t\tbreak;\r\n\t\tdefault:\r\n\t\t\tproto_tree_add_expert_format( buffer.tree, pinfo, &ei_job_info_level, buffer.tvb, 0, -1, \"Unknown job info level %d\", level);\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t}\r\n\r\n\toffset = dissect_doserror(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_rc, NULL);\r\n\r\n\treturn offset;\r\n}", ".poolssGetJob_q": "static int\r\nSpoolssGetJob_q(tvbuff_t *tvb, int offset, packet_info *pinfo,\r\n\t\t\t   proto_tree *tree, dcerpc_info *di, uint8_t *drep)\r\n{\r\n\tdcerpc_call_value *dcv = (dcerpc_call_value *)di->call_data;\r\n\tuint32_t level, jobid;\r\n\r\n\t/* Parse packet */\r\n\r\n\toffset = dissect_nt_policy_hnd(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_hnd, NULL, NULL,\r\n\t\tPIDL_POLHND_USE);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_job_id, &jobid);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_level, &level);\r\n\r\n\t/* GetJob() stores the level in se_data */\r\n\tif(!pinfo->fd->visited){\r\n\t\t\tdcv->se_data = GUINT_TO_POINTER((int)level);\r\n\t}\r\n\r\n\tcol_append_fstr(pinfo->cinfo, COL_INFO, \", level %d, jobid %d\",\r\n\t\t\t\tlevel, jobid);\r\n\r\n\toffset = dissect_spoolss_buffer(tvb, offset, pinfo, tree, di, drep, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_offered, NULL);\r\n\r\n\treturn offset;\r\n}", ".poolssGetJob_r": "static int\r\nSpoolssGetJob_r(tvbuff_t *tvb, int offset, packet_info *pinfo,\r\n\t\t\tproto_tree *tree, dcerpc_info *di, uint8_t *drep)\r\n{\r\n\tdcerpc_call_value *dcv = (dcerpc_call_value *)di->call_data;\r\n\tint32_t level = GPOINTER_TO_UINT(dcv->se_data);\r\n\tBUFFER buffer;\r\n\r\n\t/* Parse packet */\r\n\r\n\toffset = dissect_spoolss_buffer(tvb, offset, pinfo, tree, di, drep,\r\n\t\t\t\t\t&buffer);\r\n\r\n\tif (buffer.tvb) {\r\n\t\tint buffer_offset = 0;\r\n\r\n\t\tswitch(level) {\r\n\t\tcase 1:\r\n\t\t\t/*buffer_offset = */dissect_spoolss_JOB_INFO_1(\r\n\t\t\t\tbuffer.tvb, buffer_offset, pinfo,\r\n\t\t\t\tbuffer.tree, di, drep);\r\n\t\t\tbreak;\r\n\t\tcase 2:\r\n\t\tdefault:\r\n\t\t\tproto_tree_add_expert_format( buffer.tree, pinfo, &ei_job_info_level, buffer.tvb, buffer_offset, -1, \"Unknown job info level %d\", level);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_needed, NULL);\r\n\r\n\toffset = dissect_doserror(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_rc, NULL);\r\n\r\n\treturn offset;\r\n}", ".poolssEnumPrinterDrivers_q": "static int\r\nSpoolssEnumPrinterDrivers_q(tvbuff_t *tvb, int offset,\r\n\t\t\t\t       packet_info *pinfo, proto_tree *tree,\r\n\t\t\t\t       dcerpc_info *di, uint8_t *drep)\r\n{\r\n\tdcerpc_call_value *dcv = (dcerpc_call_value *)di->call_data;\r\n\tuint32_t level;\r\n\r\n\t/* Parse packet */\r\n\r\n\toffset = dissect_ndr_str_pointer_item(\r\n\t\ttvb, offset, pinfo, tree, di, drep, NDR_POINTER_UNIQUE,\r\n\t\t\"Name\", hf_servername, 0);\r\n\r\n\toffset = dissect_ndr_str_pointer_item(\r\n\t\ttvb, offset, pinfo, tree, di, drep, NDR_POINTER_UNIQUE,\r\n\t\t\"Environment\", hf_environment, 0);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_level, &level);\r\n\r\n\t/* EnumPrinterDrivers() stores the level in se_data */\r\n\tif(!pinfo->fd->visited){\r\n\t\t\tdcv->se_data = GUINT_TO_POINTER((int)level);\r\n\t}\r\n\r\n\tcol_append_fstr(pinfo->cinfo, COL_INFO, \", level %d\", level);\r\n\r\n\toffset = dissect_spoolss_buffer(tvb, offset, pinfo, tree, di, drep, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_offered, NULL);\r\n\r\n\treturn offset;\r\n}", ".poolssEnumPrinterDrivers_r": "static int\r\nSpoolssEnumPrinterDrivers_r(tvbuff_t *tvb, int offset,\r\n\t\t\t\t       packet_info *pinfo, proto_tree *tree,\r\n\t\t\t\t       dcerpc_info *di, uint8_t *drep)\r\n{\r\n\tdcerpc_call_value *dcv = (dcerpc_call_value *)di->call_data;\r\n\tuint32_t level = GPOINTER_TO_UINT(dcv->se_data), num_drivers, i;\r\n\tint buffer_offset;\r\n\tBUFFER buffer;\r\n\r\n\t/* Parse packet */\r\n\r\n\toffset = dissect_spoolss_buffer(tvb, offset, pinfo, tree, di, drep,\r\n\t\t\t\t\t&buffer);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_needed, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_returned,\r\n\t\t&num_drivers);\r\n\r\n\tbuffer_offset = 0;\r\n\r\n\tfor (i = 0; i < num_drivers; i++) {\r\n\t\tswitch(level) {\r\n\t\tcase 1:\r\n\t\t\tbuffer_offset = dissect_DRIVER_INFO_1(\r\n\t\t\t\tbuffer.tvb, buffer_offset, pinfo,\r\n\t\t\t\tbuffer.tree, di, drep);\r\n\t\t\tbreak;\r\n\t\tcase 2:\r\n\t\t\tbuffer_offset = dissect_DRIVER_INFO_2(\r\n\t\t\t\tbuffer.tvb, buffer_offset, pinfo,\r\n\t\t\t\tbuffer.tree, di, drep);\r\n\t\t\tbreak;\r\n\t\tcase 3:\r\n\t\t\tbuffer_offset = dissect_DRIVER_INFO_3(\r\n\t\t\t\tbuffer.tvb, buffer_offset, pinfo,\r\n\t\t\t\tbuffer.tree, di, drep);\r\n\t\t\tbreak;\r\n\t\tcase 6:\r\n\t\t\tbuffer_offset = dissect_DRIVER_INFO_6(\r\n\t\t\t\tbuffer.tvb, buffer_offset, pinfo,\r\n\t\t\t\tbuffer.tree, di, drep);\r\n\t\t\tbreak;\r\n\t\tcase 8:\r\n\t\t\tbuffer_offset = dissect_DRIVER_INFO_8(\r\n\t\t\t\tbuffer.tvb, buffer_offset, pinfo,\r\n\t\t\t\tbuffer.tree, di, drep);\r\n\t\t\tbreak;\r\n\t\tcase 101:\r\n\t\t\t/*buffer_offset =*/ dissect_DRIVER_INFO_101(\r\n\t\t\t\tbuffer.tvb, buffer_offset, pinfo,\r\n\t\t\t\tbuffer.tree, di, drep);\r\n\t\t\t/*break;*/\r\n\t\t\tgoto done; /*Not entirely implemented*/\r\n\t\tdefault:\r\n\t\t\tproto_tree_add_expert_format( buffer.tree, pinfo, &ei_driver_info_level, buffer.tvb, buffer_offset, -1, \"Unknown driver info level %d\", level);\r\n\t\t\tgoto done;\r\n\t\t}\r\n\t}\r\n\r\ndone:\r\n\toffset = dissect_doserror(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_rc, NULL);\r\n\r\n\treturn offset;\r\n}", ".poolssGetPrinterDriver2_q": "static int\r\nSpoolssGetPrinterDriver2_q(tvbuff_t *tvb, int offset,\r\n\t\t\t\t      packet_info *pinfo, proto_tree *tree,\r\n\t\t\t\t      dcerpc_info *di, uint8_t *drep)\r\n{\r\n\tdcerpc_call_value *dcv = (dcerpc_call_value *)di->call_data;\r\n\te_ctx_hnd policy_hnd;\r\n\tchar *pol_name;\r\n\tuint32_t level;\r\n\r\n\t/* Parse packet */\r\n\r\n\toffset = dissect_nt_policy_hnd(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_hnd, &policy_hnd, NULL,\r\n\t\tPIDL_POLHND_USE);\r\n\r\n\tdcerpc_fetch_polhnd_data(&policy_hnd, &pol_name, NULL, NULL, NULL,\r\n\t\t\t     pinfo->num);\r\n\r\n\tcol_append_fstr(pinfo->cinfo, COL_INFO, \", %s\",\r\n\t\t\t\tpol_name);\r\n\r\n\toffset = dissect_ndr_str_pointer_item(\r\n\t\ttvb, offset, pinfo, tree, di, drep, NDR_POINTER_UNIQUE,\r\n\t\t\"Environment\", hf_environment, 0);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_level, &level);\r\n\r\n\t/* GetPrinterDriver2() stores the level in se_data */\r\n\tif(!pinfo->fd->visited){\r\n\t\t\tdcv->se_data = GUINT_TO_POINTER((int)level);\r\n\t}\r\n\r\n\tcol_append_fstr(pinfo->cinfo, COL_INFO, \", level %d\", level);\r\n\r\n\toffset = dissect_spoolss_buffer(tvb, offset, pinfo, tree, di, drep, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_offered, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, tree, di, drep,\r\n\t\t\t\t    hf_clientmajorversion, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, tree, di, drep,\r\n\t\t\t\t    hf_clientminorversion, NULL);\r\n\r\n\treturn offset;\r\n}", ".poolssGetPrinterDriver2_r": "static int\r\nSpoolssGetPrinterDriver2_r(tvbuff_t *tvb, int offset,\r\n\t\t\t\t      packet_info *pinfo, proto_tree *tree,\r\n\t\t\t\t      dcerpc_info *di, uint8_t *drep)\r\n{\r\n\tdcerpc_call_value *dcv = (dcerpc_call_value *)di->call_data;\r\n\tuint32_t level = GPOINTER_TO_UINT(dcv->se_data);\r\n\tBUFFER buffer;\r\n\r\n\t/* Parse packet */\r\n\r\n\toffset = dissect_spoolss_buffer(tvb, offset, pinfo, tree, di, drep,\r\n\t\t\t\t\t&buffer);\r\n\r\n\tif (buffer.tvb) {\r\n\t\tswitch(level) {\r\n\t\tcase 1:\r\n\t\t\tdissect_DRIVER_INFO_1(\r\n\t\t\t\tbuffer.tvb, 0, pinfo, buffer.tree, di, drep);\r\n\t\t\tbreak;\r\n\t\tcase 2:\r\n\t\t\tdissect_DRIVER_INFO_2(\r\n\t\t\t\tbuffer.tvb, 0, pinfo, buffer.tree, di, drep);\r\n\t\t\tbreak;\r\n\t\tcase 3:\r\n\t\t\tdissect_DRIVER_INFO_3(\r\n\t\t\t\tbuffer.tvb, 0, pinfo, buffer.tree, di, drep);\r\n\t\t\tbreak;\r\n\t\tcase 6:\r\n\t\t\tdissect_DRIVER_INFO_6(\r\n\t\t\t\tbuffer.tvb, 0, pinfo, buffer.tree, di, drep);\r\n\t\t\tbreak;\r\n\t\tcase 8:\r\n\t\t\tdissect_DRIVER_INFO_8(\r\n\t\t\t\tbuffer.tvb, 0, pinfo, buffer.tree, di, drep);\r\n\t\t\tbreak;\r\n\t\tcase 101:\r\n\t\t\tdissect_DRIVER_INFO_101(\r\n\t\t\t\tbuffer.tvb, 0, pinfo, buffer.tree, di, drep);\r\n\t\t\tbreak;\r\n\t\tdefault:\r\n\t\t\tproto_tree_add_expert_format( buffer.tree, pinfo, &ei_driver_info_level, buffer.tvb, 0, -1, \"Unknown driver info level %d\", level);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_needed, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, tree, di, drep,\r\n\t\t\t\t    hf_servermajorversion, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, tree, di, drep,\r\n\t\t\t\t    hf_serverminorversion, NULL);\r\n\r\n\toffset = dissect_doserror(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_rc, NULL);\r\n\r\n\treturn offset;\r\n}", ".poolssGetPrinterDriverDirectory_q": "static int\r\nSpoolssGetPrinterDriverDirectory_q(tvbuff_t *tvb, int offset,\r\n\t\t\t\t      packet_info *pinfo, proto_tree *tree,\r\n\t\t\t\t      dcerpc_info *di, uint8_t *drep)\r\n{\r\n\tuint32_t level;\r\n\r\n\t/* Parse packet */\r\n\r\n\toffset = dissect_ndr_str_pointer_item(\r\n\t\ttvb, offset, pinfo, tree, di, drep, NDR_POINTER_UNIQUE,\r\n\t\t\"Name\", hf_servername, 0);\r\n\r\n\toffset = dissect_ndr_str_pointer_item(\r\n\t\ttvb, offset, pinfo, tree, di, drep, NDR_POINTER_UNIQUE,\r\n\t\t\"Environment\", hf_environment, 0);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_level, &level);\r\n\r\n\toffset = dissect_spoolss_buffer(\r\n\t\ttvb, offset, pinfo, tree, di, drep, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_offered, NULL);\r\n\r\n\treturn offset;\r\n}", ".poolssGetPrinterDriverPackagePath_q": "static int\r\nSpoolssGetPrinterDriverPackagePath_q(tvbuff_t *tvb, int offset,\r\n\t\t\t\t     packet_info *pinfo, proto_tree *tree,\r\n\t\t\t\t     dcerpc_info *di, uint8_t *drep)\r\n{\r\n\t/* Parse packet */\r\n\r\n\toffset = dissect_ndr_str_pointer_item(\r\n\t\ttvb, offset, pinfo, tree, di, drep, NDR_POINTER_UNIQUE,\r\n\t\t\"Name\", hf_servername, 0);\r\n\r\n\toffset = dissect_ndr_str_pointer_item(\r\n\t\ttvb, offset, pinfo, tree, di, drep, NDR_POINTER_REF,\r\n\t\t\"Environment\", hf_environment, 0);\r\n\r\n\toffset = dissect_ndr_str_pointer_item(\r\n\t\ttvb, offset, pinfo, tree, di, drep, NDR_POINTER_UNIQUE,\r\n\t\t\"Language\", hf_language, 0);\r\n\r\n\toffset = dissect_ndr_str_pointer_item(\r\n\t\ttvb, offset, pinfo, tree, di, drep, NDR_POINTER_REF,\r\n\t\t\"PackageId\", hf_package_id, 0);\r\n\r\n\toffset = dissect_spoolss_buffer(\r\n\t\ttvb, offset, pinfo, tree, di, drep, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, tree, di, drep,\r\n\t\thf_driver_package_cab_size, NULL);\r\n\r\n\treturn offset;\r\n}", ".issect_spoolss_string_parm": "static int\r\ndissect_spoolss_string_parm(tvbuff_t *tvb, int offset, packet_info *pinfo,\r\n\t\t       proto_tree *tree, dcerpc_info *di, uint8_t *drep, const char *text)\r\n{\r\n\toffset = dissect_ndr_pointer(\r\n\t\ttvb, offset, pinfo, tree, di, drep,\r\n\t\tdissect_spoolss_string_parm_data, NDR_POINTER_UNIQUE,\r\n\t\ttext, -1);\r\n\r\n\treturn offset;\r\n}", ".poolssGetPrinterDriverDirectory_r": "static int\r\nSpoolssGetPrinterDriverDirectory_r(tvbuff_t *tvb, int offset,\r\n\t\t\t\t      packet_info *pinfo, proto_tree *tree,\r\n\t\t\t\t      dcerpc_info *di, uint8_t *drep)\r\n{\r\n\t/* Parse packet */\r\n\r\n\toffset = dissect_spoolss_string_parm(\r\n\t\ttvb, offset, pinfo, tree, di, drep, \"Directory\");\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_needed, NULL);\r\n\r\n\toffset = dissect_doserror(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_rc, NULL);\r\n\r\n\treturn offset;\r\n}", ".poolssGetPrinterDriverPackagePath_r": "static int\r\nSpoolssGetPrinterDriverPackagePath_r(tvbuff_t *tvb, int offset,\r\n\t\t\t\t     packet_info *pinfo, proto_tree *tree,\r\n\t\t\t\t     dcerpc_info *di, uint8_t *drep)\r\n{\r\n\t/* Parse packet */\r\n\r\n\toffset = dissect_spoolss_string_parm(\r\n\t\ttvb, offset, pinfo, tree, di, drep, \"DriverPackageCab\");\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_needed, NULL);\r\n\r\n\toffset = dissect_hresult(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_hresult, NULL);\r\n\r\n\treturn offset;\r\n}", ".issect_SYSTEM_TIME_ptr": "static int\r\ndissect_SYSTEM_TIME_ptr(tvbuff_t *tvb, int offset, packet_info *pinfo,\r\n\t\t\tproto_tree *tree, dcerpc_info *di, uint8_t *drep)\r\n{\r\n\tdcerpc_call_value *dcv = (dcerpc_call_value *)di->call_data;\r\n\tchar *str;\r\n\r\n\r\n\toffset =  dissect_SYSTEM_TIME(\r\n\t\ttvb, offset, pinfo, tree, di, drep, NULL, false, &str);\r\n\tdcv->private_data = wmem_strdup(wmem_file_scope(), str);\r\n\r\n\treturn offset;\r\n}", ".issect_PRINTER_INFO_0": "static int\r\ndissect_PRINTER_INFO_0(tvbuff_t *tvb, int offset,\r\n\t\t\t\t  packet_info *pinfo, proto_tree *tree,\r\n\t\t\t\t  dcerpc_info *di, uint8_t *drep)\r\n{\r\n\toffset = dissect_spoolss_relstr(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printername,\r\n\t\t0, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_servername,\r\n\t\t0, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printer_cjobs, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printer_total_jobs,\r\n\t\tNULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printer_total_bytes,\r\n\t\tNULL);\r\n\r\n\toffset = dissect_SYSTEM_TIME(\r\n\t\ttvb, offset, pinfo, tree, di, drep, \"Unknown time\", true, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printer_global_counter,\r\n\t\tNULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printer_total_pages,\r\n\t\tNULL);\r\n\r\n\toffset = dissect_ndr_uint16(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printer_major_version,\r\n\t\tNULL);\r\n\r\n\toffset = dissect_ndr_uint16(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printer_build_version,\r\n\t\tNULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printer_unk7, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printer_unk8, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printer_unk9, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printer_session_ctr,\r\n\t\tNULL);\r\n\r\n\toffset = dissect_ndr_uint32( tvb, offset, pinfo, tree, di, drep,\r\n\t\thf_printer_unk11, NULL);\r\n\r\n\toffset = dissect_ndr_uint32( tvb, offset, pinfo, tree, di, drep,\r\n\t\thf_printer_printer_errors, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printer_unk13, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printer_unk14, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printer_unk15, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printer_unk16, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printer_changeid, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printer_unk18, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printer_status, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printer_unk20, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printer_c_setprinter,\r\n\t\tNULL);\r\n\r\n\toffset = dissect_ndr_uint16(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printer_unk22, NULL);\r\n\r\n\toffset = dissect_ndr_uint16(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printer_unk23, NULL);\r\n\r\n\toffset = dissect_ndr_uint16(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printer_unk24, NULL);\r\n\r\n\toffset = dissect_ndr_uint16(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printer_unk25, NULL);\r\n\r\n\toffset = dissect_ndr_uint16(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printer_unk26, NULL);\r\n\r\n\toffset = dissect_ndr_uint16(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printer_unk27, NULL);\r\n\r\n\toffset = dissect_ndr_uint16(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printer_unk28, NULL);\r\n\r\n\toffset = dissect_ndr_uint16(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printer_unk29, NULL);\r\n\r\n\treturn offset;\r\n}", ".issect_spoolss_JOB_INFO_1": "static int\r\ndissect_spoolss_JOB_INFO_1(tvbuff_t *tvb, int offset, packet_info *pinfo,\r\n\t\t\t   proto_tree *tree, dcerpc_info *di, uint8_t *drep)\r\n{\r\n\tproto_item *item;\r\n\tproto_tree *subtree;\r\n\tint struct_start = offset;\r\n\tchar *document_name;\r\n\r\n\tsubtree = proto_tree_add_subtree(tree, tvb, offset, 0, ett_JOB_INFO_1, &item, \"Job info level 1\");\r\n\r\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, subtree, di, drep,\r\n\t\t\t\t    hf_job_id, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_printername,\r\n\t\tstruct_start, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_servername,\r\n\t\tstruct_start, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_username,\r\n\t\tstruct_start, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_documentname,\r\n\t\tstruct_start, &document_name);\r\n\r\n\tproto_item_append_text(item, \": %s\", document_name);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_datatype,\r\n\t\tstruct_start, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_textstatus,\r\n\t\tstruct_start, NULL);\r\n\r\n\toffset = dissect_job_status(tvb, offset, pinfo, subtree, di, drep);\r\n\r\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, subtree, di, drep,\r\n\t\t\t\t    hf_job_priority, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, subtree, di, drep,\r\n\t\t\t\t    hf_job_position, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, subtree, di, drep,\r\n\t\t\t\t    hf_job_totalpages, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, subtree, di, drep,\r\n\t\t\t\t    hf_job_pagesprinted, NULL);\r\n\r\n\toffset = dissect_SYSTEM_TIME(\r\n\t\ttvb, offset, pinfo, subtree, di, drep, \"Job Submission Time\",\r\n\t\ttrue, NULL);\r\n\r\n\tproto_item_set_len(item, offset - struct_start);\r\n\r\n\treturn offset;\r\n}", ".issect_spoolss_JOB_INFO_2": "static int\r\ndissect_spoolss_JOB_INFO_2(tvbuff_t *tvb, int offset, packet_info *pinfo,\r\n\t\t\t   proto_tree *tree, dcerpc_info *di, uint8_t *drep)\r\n{\r\n\tproto_item *item;\r\n\tproto_tree *subtree;\r\n\tint struct_start = offset;\r\n\tchar *document_name;\r\n\tuint32_t devmode_offset, secdesc_offset;\r\n\r\n\tsubtree = proto_tree_add_subtree(tree, tvb, offset, 0, ett_JOB_INFO_2, &item, \"Job info level 2\");\r\n\r\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, subtree, di, drep,\r\n\t\t\t\t    hf_job_id, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_printername,\r\n\t\tstruct_start, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_machinename,\r\n\t\tstruct_start, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_username,\r\n\t\tstruct_start, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_documentname,\r\n\t\tstruct_start, &document_name);\r\n\r\n\tproto_item_append_text(item, \": %s\", document_name);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_notifyname,\r\n\t\tstruct_start, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_datatype,\r\n\t\tstruct_start, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_printprocessor,\r\n\t\tstruct_start, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_parameters,\r\n\t\tstruct_start, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_drivername,\r\n\t\tstruct_start, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, NULL, di, drep, hf_offset,\r\n\t\t&devmode_offset);\r\n\r\n\tdissect_DEVMODE(\r\n\t\ttvb, devmode_offset - 4 + struct_start, pinfo, subtree, di, drep);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_textstatus,\r\n\t\tstruct_start, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, NULL, di, drep, hf_offset,\r\n\t\t&secdesc_offset);\r\n\r\n\tdissect_nt_sec_desc(\r\n\t\ttvb, secdesc_offset, pinfo, subtree, drep,\r\n\t\tfalse, -1,\r\n\t\t&spoolss_job_access_mask_info);\r\n\r\n\toffset = dissect_job_status(tvb, offset, pinfo, subtree, di, drep);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_job_priority, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_job_position, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, NULL, di, drep, hf_start_time, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, NULL, di, drep, hf_end_time, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_job_totalpages, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_job_size, NULL);\r\n\r\n\toffset = dissect_SYSTEM_TIME(\r\n\t\ttvb, offset, pinfo, subtree, di, drep, \"Job Submission Time\",\r\n\t\ttrue, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, NULL, di, drep, hf_elapsed_time, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_job_pagesprinted, NULL);\r\n\r\n\tproto_item_set_len(item, offset - struct_start);\r\n\r\n\treturn offset;\r\n}", ".issect_NOTIFY_INFO_DATA_job": "static int\r\ndissect_NOTIFY_INFO_DATA_job(tvbuff_t *tvb, int offset, packet_info *pinfo,\r\n\t\t\t     proto_tree *tree, proto_item *item, dcerpc_info *di, uint8_t *drep,\r\n\t\t\t     uint16_t field)\r\n{\r\n\tuint32_t value1;\r\n\tproto_item *hidden_item;\r\n\r\n\tswitch (field) {\r\n\r\n\t\t/* String notify data */\r\n\r\n\tcase JOB_NOTIFY_PRINTER_NAME:\r\n\tcase JOB_NOTIFY_MACHINE_NAME:\r\n\tcase JOB_NOTIFY_PORT_NAME:\r\n\tcase JOB_NOTIFY_USER_NAME:\r\n\tcase JOB_NOTIFY_NOTIFY_NAME:\r\n\tcase JOB_NOTIFY_DATATYPE:\r\n\tcase JOB_NOTIFY_PRINT_PROCESSOR:\r\n\tcase JOB_NOTIFY_PARAMETERS:\r\n\tcase JOB_NOTIFY_DRIVER_NAME:\r\n\tcase JOB_NOTIFY_STATUS_STRING:\r\n\tcase JOB_NOTIFY_DOCUMENT:\r\n\r\n\t\toffset = dissect_ndr_uint32(\r\n\t\t\ttvb, offset, pinfo, tree, di, drep,\r\n\t\t\thf_notify_info_data_bufsize, &value1);\r\n\r\n\t\toffset = dissect_ndr_pointer_cb(\r\n\t\t\ttvb, offset, pinfo, tree, di, drep,\r\n\t\t\tdissect_notify_info_data_buffer,\r\n\t\t\tNDR_POINTER_UNIQUE, \"String\",\r\n\t\t\thf_notify_info_data_buffer,\r\n\t\t\tcb_notify_str_postprocess,\r\n\t\t\tGINT_TO_POINTER(job_notify_hf_index(field)));\r\n\r\n\t\tbreak;\r\n\r\n\tcase JOB_NOTIFY_STATUS:\r\n\t\toffset = dissect_job_status(\r\n\t\t\ttvb, offset, pinfo, tree, di, drep);\r\n\r\n\t\toffset = dissect_ndr_uint32(\r\n\t\t\ttvb, offset, pinfo, NULL, di, drep,\r\n\t\t\thf_notify_info_data_value2, NULL);\r\n\r\n\t\tbreak;\r\n\r\n\tcase JOB_NOTIFY_SUBMITTED:\r\n\r\n\t\t/* SYSTEM_TIME */\r\n\r\n\t\toffset = dissect_ndr_uint32(\r\n\t\t\ttvb, offset, pinfo, tree, di, drep,\r\n\t\t\thf_notify_info_data_buffer_len, NULL);\r\n\r\n\t\toffset = dissect_ndr_pointer_cb(\r\n\t\t\ttvb, offset, pinfo, tree, di, drep,\r\n\t\t\tdissect_SYSTEM_TIME_ptr, NDR_POINTER_UNIQUE,\r\n\t\t\t\"Time submitted\", -1, notify_job_time_cb, NULL);\r\n\r\n\t\tbreak;\r\n\r\n\tcase JOB_NOTIFY_PRIORITY:\r\n\tcase JOB_NOTIFY_POSITION:\r\n\tcase JOB_NOTIFY_TOTAL_PAGES:\r\n\tcase JOB_NOTIFY_PAGES_PRINTED:\r\n\tcase JOB_NOTIFY_TOTAL_BYTES:\r\n\tcase JOB_NOTIFY_BYTES_PRINTED: {\r\n\t\tuint32_t value;\r\n\r\n\t\toffset = dissect_ndr_uint32(\r\n\t\t\ttvb, offset, pinfo, tree, di, drep,\r\n\t\t\thf_notify_info_data_value1, &value);\r\n\r\n\t\toffset = dissect_ndr_uint32(\r\n\t\t\ttvb, offset, pinfo, tree, di, drep,\r\n\t\t\thf_notify_info_data_value2, NULL);\r\n\r\n\t\tproto_item_append_text(item, \": %d\", value);\r\n\r\n\t\thidden_item = proto_tree_add_uint(\r\n\t\t\ttree, job_notify_hf_index(field), tvb,\r\n\t\t\toffset, 4, value);\r\n\t\tproto_item_set_hidden(hidden_item);\r\n\r\n\t\tbreak;\r\n\t}\r\n\r\n\t\t/* Unknown notify data */\r\n\r\n\tcase JOB_NOTIFY_DEVMODE:\r\n\r\n\t\toffset = dissect_ndr_uint32(\r\n\t\t\ttvb, offset, pinfo, tree, di, drep,\r\n\t\t\thf_notify_info_data_bufsize, &value1);\r\n\r\n\t\toffset = dissect_ndr_pointer(\r\n\t\t\ttvb, offset, pinfo, tree, di, drep,\r\n\t\t\tdissect_notify_info_data_buffer,\r\n\t\t\tNDR_POINTER_UNIQUE, \"Buffer\",\r\n\t\t\thf_notify_info_data_buffer);\r\n\r\n\t\tbreak;\r\n\r\n\tdefault:\r\n\t\toffset = dissect_ndr_uint32(\r\n\t\t\ttvb, offset, pinfo, tree, di, drep,\r\n\t\t\thf_notify_info_data_value1, NULL);\r\n\r\n\t\toffset = dissect_ndr_uint32(\r\n\t\t\ttvb, offset, pinfo, tree, di, drep,\r\n\t\t\thf_notify_info_data_value2, NULL);\r\n\t}\r\n\treturn offset;\r\n}", ".poolssGetPrinterData_r": "static int\r\nSpoolssGetPrinterData_r(tvbuff_t *tvb, int offset,\r\n\t\t\t\t   packet_info *pinfo, proto_tree *tree,\r\n\t\t\t\t   dcerpc_info *di, uint8_t *drep)\r\n{\r\n\tdcerpc_call_value *dcv = (dcerpc_call_value *)di->call_data;\r\n\tuint32_t type;\r\n\tproto_item *hidden_item;\r\n\tconst char *data;\r\n\r\n\thidden_item = proto_tree_add_uint(\r\n\t\ttree, hf_printerdata, tvb, offset, 0, 1);\r\n\tproto_item_set_hidden(hidden_item);\r\n\r\n\t/* Parse packet */\r\n\r\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, tree, di, drep,\r\n\t\t\t\t    hf_printerdata_type, &type);\r\n\r\n\tdata = (const char *)(dcv->se_data ? dcv->se_data : \"????\");\r\n\r\n\tcol_append_fstr(pinfo->cinfo, COL_INFO, \", %s\", data);\r\n\r\n\toffset = dissect_printerdata_data(\r\n\t\ttvb, offset, pinfo, tree, di, drep, type);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_needed, NULL);\r\n\r\n\toffset = dissect_doserror(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_rc, NULL);\r\n\r\n\treturn offset;\r\n}", ".poolssGetPrinterDataEx_r": "static int\r\nSpoolssGetPrinterDataEx_r(tvbuff_t *tvb, int offset,\r\n\t\t\t\t     packet_info *pinfo, proto_tree *tree,\r\n\t\t\t\t     dcerpc_info *di, uint8_t *drep)\r\n{\r\n\tdcerpc_call_value *dcv = (dcerpc_call_value *)di->call_data;\r\n\tuint32_t size, type;\r\n\tproto_item *hidden_item;\r\n\r\n\thidden_item = proto_tree_add_uint(\r\n\t\ttree, hf_printerdata, tvb, offset, 0, 1);\r\n\tproto_item_set_hidden(hidden_item);\r\n\r\n\t/* Parse packet */\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printerdata_type, &type);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_returned, &size);\r\n\r\n\tif (dcv->se_data) {\r\n\t\tcol_append_fstr(pinfo->cinfo, COL_INFO, \", %s\", (char *)dcv->se_data);\r\n\t}\r\n\r\n\tif (size)\r\n\t\tdissect_printerdata_data(tvb, offset, pinfo, tree, di, drep, type);\r\n\r\n\toffset += size;\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_needed, NULL);\r\n\r\n\toffset = dissect_doserror(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_rc, NULL);\r\n\r\n\treturn offset;\r\n}", ".poolssSetPrinterData_q": "static int\r\nSpoolssSetPrinterData_q(tvbuff_t *tvb, int offset,\r\n\t\t\t\t   packet_info *pinfo, proto_tree *tree,\r\n\t\t\t\t   dcerpc_info *di, uint8_t *drep)\r\n{\r\n\tdcerpc_call_value *dcv = (dcerpc_call_value *)di->call_data;\r\n\tchar *value_name;\r\n\tuint32_t type;\r\n\tproto_item *hidden_item;\r\n\r\n\thidden_item = proto_tree_add_uint(\r\n\t\ttree, hf_printerdata, tvb, offset, 0, 1);\r\n\tproto_item_set_hidden(hidden_item);\r\n\r\n\t/* Parse packet */\r\n\r\n\toffset = dissect_nt_policy_hnd(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_hnd, NULL, NULL,\r\n\t\tPIDL_POLHND_USE);\r\n\r\n\tvalue_name=NULL;\r\n\toffset = dissect_ndr_cvstring(\r\n\t\ttvb, offset, pinfo, tree, di, drep, sizeof(uint16_t),\r\n\t\thf_printerdata_value, true, &value_name);\r\n\r\n\t/* GetPrinterDataEx() stores the key/value in se_data */\r\n\tif(!pinfo->fd->visited){\r\n\t\tif(!dcv->se_data){\r\n\t\t\tdcv->se_data = wmem_strdup(wmem_file_scope(),\r\n\t\t\t\tvalue_name?value_name:\"\");\r\n\t\t}\r\n\t}\r\n\r\n\r\n\tif (dcv->se_data){\r\n\t\tcol_append_fstr(pinfo->cinfo, COL_INFO, \", %s\", (char *)dcv->se_data);\r\n\t}\r\n\r\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, tree, di, drep,\r\n\t\t\t\t    hf_printerdata_type, &type);\r\n\r\n\toffset = dissect_printerdata_data(\r\n\t\ttvb, offset, pinfo, tree, di, drep, type);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_offered, NULL);\r\n\r\n\treturn offset;\r\n}", ".poolssEnumPrinterData_r": "static int\r\nSpoolssEnumPrinterData_r(tvbuff_t *tvb, int offset,\r\n\t\t\t\t    packet_info *pinfo, proto_tree *tree,\r\n\t\t\t\t    dcerpc_info *di, uint8_t *drep)\r\n{\r\n\tuint32_t value_len, type;\r\n\tchar *value;\r\n\tproto_item *value_item;\r\n\tproto_tree *value_subtree;\r\n\tproto_item *hidden_item;\r\n\r\n\thidden_item = proto_tree_add_uint(\r\n\t\ttree, hf_printerdata, tvb, offset, 0, 1);\r\n\tproto_item_set_hidden(hidden_item);\r\n\r\n\t/* Parse packet */\r\n\r\n\tvalue_subtree = proto_tree_add_subtree(tree, tvb, offset, 0, ett_printerdata_value, &value_item, \"Value\");\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, value_subtree, di, drep,\r\n\t\thf_enumprinterdata_value_len, &value_len);\r\n\r\n\tif (value_len) {\r\n\t\tdissect_spoolss_uint16uni(\r\n\t\t\ttvb, offset, pinfo, value_subtree, drep, &value, hf_value_name);\r\n\r\n\t\toffset += value_len * 2;\r\n\r\n\t\tif (value && value[0])\r\n\t\t\tcol_append_fstr(pinfo->cinfo, COL_INFO, \", %s\", value);\r\n\r\n\t\tproto_item_append_text(value_item, \": %s\", value);\r\n\r\n\t\thidden_item = proto_tree_add_string(\r\n\t\t\ttree, hf_printerdata_value, tvb, offset, 0, value);\r\n\t\tproto_item_set_hidden(hidden_item);\r\n\t}\r\n\r\n\tproto_item_set_len(value_item, value_len * 2 + 4);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, value_subtree, di, drep,\r\n\t\thf_enumprinterdata_value_needed, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printerdata_type, &type);\r\n\r\n\toffset = dissect_printerdata_data(\r\n\t\ttvb, offset, pinfo, tree, di, drep, type);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, tree, di, drep,\r\n\t\thf_enumprinterdata_data_needed, NULL);\r\n\r\n\toffset = dissect_doserror(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_rc, NULL);\r\n\r\n\treturn offset;\r\n}", ".issect_DEVMODE": "static int\r\ndissect_DEVMODE(tvbuff_t *tvb, int offset, packet_info *pinfo,\r\n\t\t\t   proto_tree *tree, dcerpc_info *di, uint8_t *drep)\r\n{\r\n\tproto_item *item;\r\n\tproto_tree *subtree;\r\n\tuint16_t driver_extra;\r\n\tint16_t print_quality;\r\n\tuint32_t fields;\r\n\tint struct_start = offset;\r\n\r\n\tif (di->conformant_run)\r\n\t\treturn offset;\r\n\r\n\tsubtree = proto_tree_add_subtree(tree, tvb, offset, 0, ett_DEVMODE, &item, \"Devicemode\");\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_devmode_size,\r\n\t\tNULL);\r\n\r\n\t/* The device name is stored in a 32-wchar buffer */\r\n\r\n\tdissect_spoolss_uint16uni(tvb, offset, pinfo, subtree, drep, NULL, hf_devmode_devicename);\r\n\toffset += 64;\r\n\r\n\toffset = dissect_ndr_uint16(\r\n\t\ttvb, offset, pinfo, subtree, di, drep,\r\n\t\thf_devmode_spec_version, NULL);\r\n\r\n\toffset = dissect_ndr_uint16(\r\n\t\ttvb, offset, pinfo, subtree, di, drep,\r\n\t\thf_devmode_driver_version, NULL);\r\n\r\n\toffset = dissect_ndr_uint16(\r\n\t\ttvb, offset, pinfo, subtree, di, drep,\r\n\t\thf_devmode_size2, NULL);\r\n\r\n\toffset = dissect_ndr_uint16(\r\n\t\ttvb, offset, pinfo, subtree, di, drep,\r\n\t\thf_devmode_driver_extra_len, &driver_extra);\r\n\r\n\toffset = dissect_DEVMODE_fields(\r\n\t\ttvb, offset, pinfo, subtree, di, drep, &fields);\r\n\r\n\toffset = dissect_ndr_uint16(\r\n\t\ttvb, offset, pinfo, subtree, di, drep,\r\n\t\thf_devmode_orientation, NULL);\r\n\r\n\toffset = dissect_ndr_uint16(\r\n\t\ttvb, offset, pinfo, subtree, di, drep,\r\n\t\thf_devmode_paper_size, NULL);\r\n\r\n\toffset = dissect_ndr_uint16(\r\n\t\ttvb, offset, pinfo, subtree, di, drep,\r\n\t\thf_devmode_paper_length, NULL);\r\n\r\n\toffset = dissect_ndr_uint16(\r\n\t\ttvb, offset, pinfo, subtree, di, drep,\r\n\t\thf_devmode_paper_width, NULL);\r\n\r\n\toffset = dissect_ndr_uint16(\r\n\t\ttvb, offset, pinfo, subtree, di, drep,\r\n\t\thf_devmode_scale, NULL);\r\n\r\n\toffset = dissect_ndr_uint16(\r\n\t\ttvb, offset, pinfo, subtree, di, drep,\r\n\t\thf_devmode_copies, NULL);\r\n\r\n\toffset = dissect_ndr_uint16(\r\n\t\ttvb, offset, pinfo, subtree, di, drep,\r\n\t\thf_devmode_default_source, NULL);\r\n\r\n\toffset = dissect_ndr_uint16(\r\n\t\ttvb, offset, pinfo, NULL, di, drep,\r\n\t\thf_devmode_print_quality, &print_quality);\r\n\r\n\tif (print_quality < 0)\r\n\t\tproto_tree_add_item(\r\n\t\t\tsubtree, hf_devmode_print_quality, tvb,\r\n\t\t\toffset - 2, 2, DREP_ENC_INTEGER(drep));\r\n\telse\r\n\t\tproto_tree_add_uint_format_value(\r\n\t\t\tsubtree, hf_devmode_print_quality, tvb, offset - 4, 4,\r\n\t\t\tprint_quality, \"%d dpi\", print_quality);\r\n\r\n\toffset = dissect_ndr_uint16(\r\n\t\ttvb, offset, pinfo, subtree, di, drep,\r\n\t\thf_devmode_color, NULL);\r\n\r\n\toffset = dissect_ndr_uint16(\r\n\t\ttvb, offset, pinfo, subtree, di, drep,\r\n\t\thf_devmode_duplex, NULL);\r\n\r\n\toffset = dissect_ndr_uint16(\r\n\t\ttvb, offset, pinfo, subtree, di, drep,\r\n\t\thf_devmode_y_resolution, NULL);\r\n\r\n\toffset = dissect_ndr_uint16(\r\n\t\ttvb, offset, pinfo, subtree, di, drep,\r\n\t\thf_devmode_tt_option, NULL);\r\n\r\n\toffset = dissect_ndr_uint16(\r\n\t\ttvb, offset, pinfo, subtree, di, drep,\r\n\t\thf_devmode_collate, NULL);\r\n\r\n\tdissect_spoolss_uint16uni(tvb, offset, pinfo, subtree, drep, NULL, hf_devmode_form_name);\r\n\toffset += 64;\r\n\r\n\toffset = dissect_ndr_uint16(\r\n\t\ttvb, offset, pinfo, subtree, di, drep,\r\n\t\thf_devmode_log_pixels, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, subtree, di, drep,\r\n\t\thf_devmode_bits_per_pel, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, subtree, di, drep,\r\n\t\thf_devmode_pels_width, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, subtree, di, drep,\r\n\t\thf_devmode_pels_height, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, subtree, di, drep,\r\n\t\thf_devmode_display_flags, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, subtree, di, drep,\r\n\t\thf_devmode_display_freq, NULL);\r\n\r\n\t/* TODO: Some of the remaining fields are optional.  See\r\n\t   rpc_parse/parse_spoolss.c in the Samba source for details. */\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, subtree, di, drep,\r\n\t\thf_devmode_icm_method, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, subtree, di, drep,\r\n\t\thf_devmode_icm_intent, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, subtree, di, drep,\r\n\t\thf_devmode_media_type, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, subtree, di, drep,\r\n\t\thf_devmode_dither_type, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, subtree, di, drep,\r\n\t\thf_devmode_reserved1, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, subtree, di, drep,\r\n\t\thf_devmode_reserved2, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, subtree, di, drep,\r\n\t\thf_devmode_panning_width, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, subtree, di, drep,\r\n\t\thf_devmode_panning_height, NULL);\r\n\r\n\tif (driver_extra)\r\n\t\toffset = dissect_ndr_uint8s(\r\n\t\t\ttvb, offset, pinfo, subtree, di, drep,\r\n\t\t\thf_devmode_driver_extra, driver_extra, NULL);\r\n\r\n\tproto_item_set_len(item, offset - struct_start);\r\n\r\n\treturn offset;\r\n}", ".issect_spoolss_relstr": "static int\r\ndissect_spoolss_relstr(tvbuff_t *tvb, int offset, packet_info *pinfo,\r\n\t\t       proto_tree *tree, dcerpc_info *di, uint8_t *drep, int hf_index,\r\n\t\t       int struct_start, char **data)\r\n{\r\n\tproto_item *item;\r\n\tproto_tree *subtree;\r\n\tuint32_t relstr_offset, relstr_start, relstr_end;\r\n\tchar *text;\r\n\r\n\t/* Peek ahead to read the string.  We need this for the\r\n\t   proto_tree_add_string() call so filtering will work. */\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, NULL, di, drep, hf_offset, &relstr_offset);\r\n\r\n\trelstr_start = relstr_offset + struct_start;\r\n\r\n\tif (relstr_offset) {\r\n\t\trelstr_end = dissect_spoolss_uint16uni(\r\n\t\t\ttvb, relstr_start, pinfo, NULL, drep, &text, hf_relative_string);\r\n\t} else { \t\t\t/* relstr_offset == 0 is a NULL string */\r\n\t\ttext = wmem_strdup(pinfo->pool, \"\");\r\n\t\trelstr_end = relstr_start;\r\n\t}\r\n\r\n\t/* OK now add the proto item with the string value */\r\n\r\n\titem = proto_tree_add_string(tree, hf_index, tvb, relstr_start, relstr_end - relstr_start, text);\r\n\tsubtree = proto_item_add_subtree(item, ett_RELSTR);\r\n\r\n\tdissect_ndr_uint32(\r\n\t\ttvb, offset - 4, pinfo, subtree, di, drep, hf_offset, NULL);\r\n\r\n\tif (relstr_offset)\r\n\t\tdissect_spoolss_uint16uni(\r\n\t\t\ttvb, relstr_start, pinfo, subtree, drep, NULL, hf_relative_string);\r\n\r\n\tif (data)\r\n\t\t*data = text;\r\n\r\n\treturn offset;\r\n}", ".issect_spoolss_relstrarray": "static int\r\ndissect_spoolss_relstrarray(tvbuff_t *tvb, int offset, packet_info *pinfo,\r\n\t\t\t    proto_tree *tree, dcerpc_info *di, uint8_t *drep, int hf_index,\r\n\t\t\t    int struct_start, char **data)\r\n{\r\n\tproto_item *item;\r\n\tproto_tree *subtree;\r\n\tuint32_t relstr_offset, relstr_start/*, relstr_end, relstr_len*/;\r\n\tchar *text;\r\n\r\n\titem = proto_tree_add_string(tree, hf_index, tvb, offset, 4, \"\");\r\n\r\n\tsubtree = proto_item_add_subtree(item, ett_RELSTR_ARRAY);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_offset, &relstr_offset);\r\n\r\n\t/* A relative offset of zero is a NULL string */\r\n\r\n\trelstr_start = relstr_offset + struct_start;\r\n\r\n\tif (relstr_offset)\r\n\t\t/*relstr_end = */dissect_spoolss_uint16uni(\r\n\t\t\ttvb, relstr_start, pinfo, subtree, drep, &text, hf_relative_string);\r\n\telse {\r\n\t\ttext = wmem_strdup(pinfo->pool, \"NULL\");\r\n\t\t/*relstr_end = offset;*/\r\n\t}\r\n\r\n\t/*relstr_len = relstr_end - relstr_start;*/\r\n\r\n\tproto_item_append_text(item, \"%s\", text);\r\n\r\n\tif (data)\r\n\t\t*data = text;\r\n\r\n\treturn offset;\r\n}", ".issect_CORE_PRINTER_DRIVER": "static int\r\ndissect_CORE_PRINTER_DRIVER(tvbuff_t *tvb, int offset,\r\n\t\t\t\t packet_info *pinfo, proto_tree *tree,\r\n\t\t\t\t dcerpc_info *di, uint8_t *drep)\r\n{\r\n\tproto_tree *subtree;\r\n\r\n\tALIGN_TO_5_BYTES;\r\n\r\n\tsubtree = proto_tree_add_subtree(\r\n\t\ttree, tvb, offset, 0, ett_CORE_PRINTER_DRIVER, NULL, \"Core Printer Driver\");\r\n\r\n\toffset = dissect_ndr_uuid_t(tvb, offset, pinfo, subtree, di, drep,\r\n\t\thf_core_driver_guid, NULL);\r\n\r\n\toffset = dissect_ndr_nt_NTTIME(tvb, offset, pinfo, subtree, di, drep,\r\n\t\thf_driverdate);\r\n\r\n\toffset = dissect_ndr_uint64(tvb, offset, pinfo, subtree, di, drep,\r\n\t\thf_driver_version, NULL);\r\n\r\n\t/* The package id is stored in a 260-wchar buffer */\r\n\r\n\tdissect_spoolss_uint16uni(tvb, offset, pinfo, subtree, drep, NULL,\r\n\t\thf_package_id);\r\n\r\n\toffset += 520;\r\n\r\n\tif (di->call_data->flags & DCERPC_IS_NDR64) {\r\n\t\tALIGN_TO_5_BYTES;\r\n\t}\r\n\r\n\treturn offset;\r\n}", ".issect_spoolss_keybuffer": "static int\r\ndissect_spoolss_keybuffer(tvbuff_t *tvb, int offset, packet_info *pinfo,\r\n\t\t\t  proto_tree *tree, dcerpc_info *di, uint8_t *drep)\r\n{\r\n\tuint32_t size;\r\n\tint end_offset;\r\n\r\n\tif (di->conformant_run)\r\n\t\treturn offset;\r\n\r\n\t/* Dissect size and data */\r\n\r\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, tree, di, drep,\r\n\t\t\t\t    hf_keybuffer_size, &size);\r\n\r\n\tend_offset = offset + (size*2);\r\n\tif (end_offset < offset) {\r\n\t\t/*\r\n\t\t * Overflow - make the end offset one past the end of\r\n\t\t * the packet data, so we throw an exception (as the\r\n\t\t * size is almost certainly too big).\r\n\t\t */\r\n\t\tend_offset = tvb_reported_length_remaining(tvb, offset) + 1;\r\n\t}\r\n\r\n\twhile (offset > 0 && offset < end_offset) {\r\n\t\toffset = dissect_spoolss_uint16uni(\r\n\t\t\ttvb, offset, pinfo, tree, drep, NULL, hf_keybuffer);\r\n\t}\r\n\r\n\treturn offset;\r\n}", ".issect_spoolss_printer_enum_values": "static int\r\ndissect_spoolss_printer_enum_values(tvbuff_t *tvb, int offset,\r\n\t\t\t\t    packet_info *pinfo, proto_tree *tree,\r\n\t\t\t\t    dcerpc_info *di, uint8_t *drep)\r\n{\r\n\tuint32_t start_offset = offset;\r\n\tuint32_t name_offset, name_len, val_offset, val_len, val_type;\r\n\tchar *name;\r\n\tproto_item *item;\r\n\tproto_tree *subtree;\r\n\r\n\t/* Get offset of value name */\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, NULL, di, drep,\r\n\t\thf_enumprinterdataex_name_offset, &name_offset);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, NULL, di, drep,\r\n\t\thf_enumprinterdataex_name_len, &name_len);\r\n\r\n\tdissect_spoolss_uint16uni(\r\n\t\ttvb, start_offset + name_offset, pinfo, NULL, drep,\r\n\t\t&name, hf_enumprinterdataex_name);\r\n\r\n\tsubtree = proto_tree_add_subtree_format(tree, tvb, offset, 0, ett_printer_enumdataex_value, &item, \"Name: %s\", name);\r\n\r\n\tproto_tree_add_uint(subtree, hf_enumprinterdataex_name_offset, tvb, offset - 8, 4, name_offset);\r\n\r\n\tproto_tree_add_uint(subtree, hf_enumprinterdataex_name_len, tvb, offset - 4, 4, name_len);\r\n\r\n\tproto_tree_add_string( subtree, hf_enumprinterdataex_name, tvb, start_offset + name_offset, ((int)strlen(name) + 1) * 2, name);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_printerdata_type,\r\n\t\t&val_type);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, subtree, di, drep,\r\n\t\thf_enumprinterdataex_val_offset, &val_offset);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, subtree, di, drep,\r\n\t\thf_enumprinterdataex_val_len, &val_len);\r\n\r\n\tif (val_len == 0) {\r\n\t\tproto_tree_add_uint_format_value(subtree, hf_enumprinterdataex_value_null, tvb, start_offset + val_offset, 4, 0, \"(null)\");\r\n\t\treturn offset;\r\n\t}\r\n\r\n\tswitch(val_type) {\r\n\tcase DCERPC_REG_DWORD: {\r\n\t\tuint32_t value;\r\n\t\tuint16_t low, high;\r\n\t\tint offset2 = start_offset + val_offset;\r\n\r\n\t\t/* Needs to be broken into two 16-byte ints because it may\r\n\t\t   not be aligned. */\r\n\r\n\t\toffset2 = dissect_ndr_uint16(\r\n\t\t\ttvb, offset2, pinfo, subtree, di, drep,\r\n\t\t\thf_enumprinterdataex_val_dword_low, &low);\r\n\r\n\t\t/*offset2 = */dissect_ndr_uint16(\r\n\t\t\ttvb, offset2, pinfo, subtree, di, drep,\r\n\t\t\thf_enumprinterdataex_val_dword_high, &high);\r\n\r\n\t\tvalue = (high << 16) | low;\r\n\r\n\t\tproto_tree_add_uint(subtree, hf_enumprinterdataex_value_uint, tvb, start_offset + val_offset, 4, value);\r\n\r\n\t\tproto_item_append_text(item, \", Value: %d\", value);\r\n\r\n\t\tbreak;\r\n\t}\r\n\tcase DCERPC_REG_SZ: {\r\n\t\tchar *value;\r\n\r\n\t\tdissect_spoolss_uint16uni(\r\n\t\t\ttvb, start_offset + val_offset, pinfo, subtree, drep,\r\n\t\t\t&value, hf_value_string);\r\n\r\n\t\tproto_item_append_text(item, \", Value: %s\", value);\r\n\r\n\t\tbreak;\r\n\t}\r\n\tcase DCERPC_REG_BINARY:\r\n\r\n\t\t/* FIXME: nicer way to display this */\r\n\r\n\t\tproto_tree_add_bytes_format_value( subtree, hf_enumprinterdataex_value_binary, tvb, start_offset + val_offset, val_len, NULL, \"<binary data>\");\r\n\t\tbreak;\r\n\r\n\tcase DCERPC_REG_MULTI_SZ:\r\n\r\n\t\t/* FIXME: implement REG_MULTI_SZ support */\r\n\r\n\t\tproto_tree_add_bytes_format_value(subtree, hf_enumprinterdataex_value_multi_sz, tvb, start_offset + val_offset, val_len, NULL, \"<REG_MULTI_SZ not implemented>\");\r\n\t\tbreak;\r\n\r\n\tdefault:\r\n\t\tproto_tree_add_expert_format( subtree, pinfo, &ei_enumprinterdataex_value, tvb, start_offset + val_offset, val_len, \"%s: unknown type %d\", name, val_type);\r\n\t}\r\n\r\n\treturn offset;\r\n}", ".poolssGetCorePrinterDrivers_q": "static int\r\nSpoolssGetCorePrinterDrivers_q(tvbuff_t *tvb, int offset,\r\n\t\t\t       packet_info *pinfo, proto_tree *tree,\r\n\t\t\t       dcerpc_info *di, uint8_t *drep)\r\n{\r\n\t/* Parse packet */\r\n\r\n\toffset = dissect_ndr_str_pointer_item(\r\n\t\ttvb, offset, pinfo, tree, di, drep, NDR_POINTER_UNIQUE,\r\n\t\t\"Name\", hf_servername, 0);\r\n\r\n\toffset = dissect_ndr_str_pointer_item(\r\n\t\ttvb, offset, pinfo, tree, di, drep, NDR_POINTER_REF,\r\n\t\t\"Environment\", hf_environment, 0);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, tree, di, drep,\r\n\t\thf_offered, NULL);\r\n#if 1\r\n\toffset = dissect_spoolss_keybuffer(\r\n\t\ttvb, offset, pinfo, tree, di, drep);\r\n#else\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, tree, di, drep,\r\n\t\thf_core_driver_size, NULL);\r\n\r\n\toffset = dissect_spoolss_uint16uni(\r\n\t\ttvb, offset, pinfo, tree, drep,\r\n\t\tNULL, hf_core_printer_driver_ids);\r\n#endif\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, tree, di, drep,\r\n\t\thf_core_printer_driver_count, NULL);\r\n\r\n\treturn offset;\r\n}", ".issect_DEVMODE_CTR": "int\r\ndissect_DEVMODE_CTR(tvbuff_t *tvb, int offset, packet_info *pinfo,\r\n\t\t\t       proto_tree *tree, dcerpc_info *di, uint8_t *drep)\r\n{\r\n\tproto_tree *subtree;\r\n\tuint32_t size;\r\n\r\n\tsubtree = proto_tree_add_subtree(\r\n\t\ttree, tvb, offset, 0, ett_DEVMODE_CTR, NULL, \"Devicemode container\");\r\n\r\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, subtree, di, drep,\r\n\t\t\t\t    hf_devmodectr_size, &size);\r\n\r\n\toffset = dissect_ndr_pointer(\r\n\t\ttvb, offset, pinfo, subtree, di, drep,\r\n\t\tdissect_DEVMODE, NDR_POINTER_UNIQUE, \"Devicemode\", -1);\r\n\r\n\treturn offset;\r\n}", ".issect_PRINTER_INFO_2": "static int\r\ndissect_PRINTER_INFO_2(tvbuff_t *tvb, int offset,\r\n\t\t\t\t  packet_info *pinfo, proto_tree *tree,\r\n\t\t\t\t  dcerpc_info *di, uint8_t *drep)\r\n{\r\n\tuint32_t devmode_offset, secdesc_offset;\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_servername,\r\n\t\t0, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printername,\r\n\t\t0, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_sharename,\r\n\t\t0, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_portname,\r\n\t\t0, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_drivername,\r\n\t\t0, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printercomment,\r\n\t\t0, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printerlocation,\r\n\t\t0, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, NULL, di, drep, hf_offset,\r\n\t\t&devmode_offset);\r\n\r\n\tdissect_DEVMODE(tvb, devmode_offset - 4, pinfo, tree, di, drep);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_sepfile,\r\n\t\t0, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printprocessor,\r\n\t\t0, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_datatype,\r\n\t\t0, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_parameters,\r\n\t\t0, NULL);\r\n\r\n\t/*\r\n\t * XXX - what *is* the length of this security descriptor?\r\n\t * \"prs_PRINTER_INFO_2()\" is passed to \"defer_ptr()\", but\r\n\t * \"defer_ptr\" takes, as an argument, a function with a\r\n\t * different calling sequence from \"prs_PRINTER_INFO_2()\",\r\n\t * lacking the \"len\" argument, so that won't work.\r\n\t */\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, NULL, di, drep, hf_offset,\r\n\t\t&secdesc_offset);\r\n\r\n\tdissect_nt_sec_desc(\r\n\t\ttvb, secdesc_offset, pinfo, tree, drep,\r\n\t\tfalse, -1,\r\n\t\t&spoolss_printer_access_mask_info);\r\n\r\n\toffset = dissect_printer_attributes(tvb, offset, pinfo, tree, di, drep);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, NULL, di, drep, hf_printer_priority,\r\n\t\tNULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, NULL, di, drep,\r\n\t\thf_printer_default_priority, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, NULL, di, drep, hf_start_time, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, NULL, di, drep, hf_end_time, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, tree, di, drep,\r\n\t\thf_printer_status, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, NULL, di, drep, hf_printer_jobs,\r\n\t\tNULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, NULL, di, drep,\r\n\t\thf_printer_averageppm, NULL);\r\n\r\n\treturn offset;\r\n}", ".poolssOpenPrinterEx_q": "static int\r\nSpoolssOpenPrinterEx_q(tvbuff_t *tvb, int offset,\r\n\t\t\t\t  packet_info *pinfo, proto_tree *tree,\r\n\t\t\t\t  dcerpc_info *di, uint8_t *drep)\r\n{\r\n\tdcerpc_call_value *dcv = (dcerpc_call_value *)di->call_data;\r\n\tchar *name;\r\n\r\n\t/* Parse packet */\r\n\r\n\tdcv->private_data=NULL;\r\n\toffset = dissect_ndr_pointer_cb(\r\n\t\ttvb, offset, pinfo, tree, di, drep,\r\n\t\tdissect_ndr_wchar_cvstring, NDR_POINTER_UNIQUE,\r\n\t\t\"Printer name\", hf_printername, cb_wstr_postprocess,\r\n\t\tGINT_TO_POINTER(CB_STR_COL_INFO | CB_STR_SAVE | 1));\r\n\tname = (char *)dcv->private_data;\r\n\r\n\t/* OpenPrinterEx() stores the key/value in se_data */\r\n\tif(!pinfo->fd->visited){\r\n\t\tif(!dcv->se_data){\r\n\t\t\tdcv->se_data = wmem_strdup(wmem_file_scope(),\r\n\t\t\t\tname?name:\"\");\r\n\t\t}\r\n\t}\r\n\r\n\toffset = dissect_ndr_pointer(\r\n\t\ttvb, offset, pinfo, tree, di, drep,\r\n\t\tdissect_PRINTER_DATATYPE, NDR_POINTER_UNIQUE,\r\n\t\t\"Printer datatype\", -1);\r\n\r\n\toffset = dissect_DEVMODE_CTR(tvb, offset, pinfo, tree, di, drep);\r\n\r\n\tname=(char *)dcv->se_data;\r\n\tif (name) {\r\n\t\tif (name[0] == '\\\\' && name[1] == '\\\\')\r\n\t\t\tname += 2;\r\n\r\n\t\t/* Determine if we are opening a printer or a print server */\r\n\r\n\t\tif (strchr(name, '\\\\'))\r\n\t\t\toffset = dissect_nt_access_mask(\r\n\t\t\t\ttvb, offset, pinfo, tree, di, drep,\r\n\t\t\t\thf_access_required,\r\n\t\t\t\t&spoolss_printer_access_mask_info, NULL);\r\n\t\telse\r\n\t\t\toffset = dissect_nt_access_mask(\r\n\t\t\t\ttvb, offset, pinfo, tree, di, drep,\r\n\t\t\t\thf_access_required,\r\n\t\t\t\t&spoolss_printserver_access_mask_info, NULL);\r\n\t} else {\r\n\r\n\t\t/* We can't decide what type of object being opened */\r\n\r\n\t\toffset = dissect_nt_access_mask(\r\n\t\t\ttvb, offset, pinfo, tree, di, drep, hf_access_required,\r\n\t\t\tNULL, NULL);\r\n\t}\r\n\r\n\toffset = dissect_USER_LEVEL_CTR(tvb, offset, pinfo, tree, di, drep);\r\n\r\n\treturn offset;\r\n}", ".issect_SPOOL_PRINTER_INFO": "int\r\ndissect_SPOOL_PRINTER_INFO(tvbuff_t *tvb, int offset, packet_info *pinfo,\r\n\t\t\t   proto_tree *tree, dcerpc_info *di, uint8_t *drep)\r\n{\r\n\tproto_tree *subtree;\r\n\tuint32_t level;\r\n\tproto_tree *item;\r\n\r\n\tsubtree = proto_tree_add_subtree(\r\n\t\ttree, tvb, offset, 0, ett_SPOOL_PRINTER_INFO_LEVEL, &item, \"Spool printer info level\");\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_level, &level);\r\n\r\n\tswitch(level) {\r\n\tcase 3: {\r\n\t\tuint32_t devmode_ptr, secdesc_ptr;\r\n\r\n\t\t/* I can't seem to get this working with the correct\r\n\t\t   dissect_ndr_pointer() function so let's cheat and\r\n\t\t   dissect the pointers by hand. )-: */\r\n\r\n\t\toffset = dissect_ndr_uint32(\r\n\t\t\ttvb, offset, pinfo, subtree, di, drep,\r\n\t\t\thf_spool_printer_info_devmode_ptr,\r\n\t\t\t&devmode_ptr);\r\n\r\n\t\toffset = dissect_ndr_uint32(\r\n\t\t\ttvb, offset, pinfo, subtree, di, drep,\r\n\t\t\thf_spool_printer_info_secdesc_ptr,\r\n\t\t\t&secdesc_ptr);\r\n\r\n\t\tif (devmode_ptr)\r\n\t\t\toffset = dissect_DEVMODE_CTR(\r\n\t\t\t\ttvb, offset, pinfo, subtree, di, drep);\r\n\r\n\t\tif (secdesc_ptr)\r\n\t\t\toffset = dissect_SEC_DESC_BUF(\r\n\t\t\t\ttvb, offset, pinfo, subtree, di, drep);\r\n\r\n\tbreak;\r\n\t}\r\n\tcase 2:\r\n\tdefault:\r\n\t\texpert_add_info_format(pinfo, item, &ei_spool_printer_info_level, \"Unknown spool printer info level %d\", level);\r\n\t\tbreak;\r\n\t}\r\n\r\n\treturn offset;\r\n}", ".issect_PRINTER_INFO_1": "static int\r\ndissect_PRINTER_INFO_1(tvbuff_t *tvb, int offset,\r\n\t\t\t\t  packet_info *pinfo, proto_tree *tree,\r\n\t\t\t\t  dcerpc_info *di, uint8_t *drep)\r\n{\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, tree, di, drep,\r\n\t\thf_printer_flags, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printerdesc,\r\n\t\t0, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printername,\r\n\t\t0, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printercomment,\r\n\t\t0, NULL);\r\n\r\n\treturn offset;\r\n}", ".issect_PRINTER_INFO_5": "static int\r\ndissect_PRINTER_INFO_5(tvbuff_t *tvb, int offset,\r\n\t\t\t\t  packet_info *pinfo, proto_tree *tree,\r\n\t\t\t\t  dcerpc_info *di, uint8_t *drep)\r\n{\r\n\toffset = dissect_spoolss_relstr(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printername,\r\n\t\t0, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_portname,\r\n\t\t0, NULL);\r\n\r\n\toffset = dissect_printer_attributes(tvb, offset, pinfo, tree, di, drep);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, tree, di, drep,\r\n\t\thf_device_not_selected_timeout, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, tree, di, drep,\r\n\t\thf_transmission_retry_timeout, NULL);\r\n\r\n\treturn offset;\r\n}", ".issect_PRINTER_INFO_7": "static int\r\ndissect_PRINTER_INFO_7(tvbuff_t *tvb, int offset,\r\n\t\t\t\t  packet_info *pinfo, proto_tree *tree,\r\n\t\t\t\t  dcerpc_info *di, uint8_t *drep)\r\n{\r\n\toffset = dissect_spoolss_relstr(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printer_guid,\r\n\t\t0, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, tree, di, drep,\r\n\t\thf_printer_action, NULL);\r\n\r\n\treturn offset;\r\n}", ".issect_FORM_REL": "static int\r\ndissect_FORM_REL(tvbuff_t *tvb, int offset, packet_info *pinfo,\r\n\t\t\t    proto_tree *tree, dcerpc_info *di, uint8_t *drep, int struct_start)\r\n{\r\n\tproto_item *item;\r\n\tproto_tree *subtree;\r\n\tuint32_t flags;\r\n\tint item_start = offset;\r\n\tchar *name = NULL;\r\n\r\n\tsubtree = proto_tree_add_subtree(tree, tvb, offset, 0, ett_FORM_REL, &item, \"Form\");\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_form_flags, &flags);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_form_name,\r\n\t\tstruct_start, &name);\r\n\r\n\tif (name) {\r\n\t\tproto_item_append_text(item, \": %s\", name);\r\n\t}\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, subtree, di, drep,\r\n\t\thf_form_width, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, subtree, di, drep,\r\n\t\thf_form_height, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, subtree, di, drep,\r\n\t\thf_form_left_margin, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, subtree, di, drep,\r\n\t\thf_form_top_margin, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, subtree, di, drep,\r\n\t\thf_form_horiz_len, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, subtree, di, drep,\r\n\t\thf_form_vert_len, NULL);\r\n\r\n\tproto_item_set_len(item, offset - item_start);\r\n\r\n\treturn offset;\r\n}", ".issect_DRIVER_INFO_1": "static int\r\ndissect_DRIVER_INFO_1(tvbuff_t *tvb, int offset,\r\n\t\t\t\t packet_info *pinfo, proto_tree *tree,\r\n\t\t\t\t dcerpc_info *di, uint8_t *drep)\r\n{\r\n\tproto_tree *subtree;\r\n\tint struct_start = offset;\r\n\r\n\tsubtree = proto_tree_add_subtree(\r\n\t\ttree, tvb, offset, 0, ett_DRIVER_INFO_1, NULL, \"Driver info level 1\");\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_drivername,\r\n\t\tstruct_start, NULL);\r\n\r\n\treturn offset;\r\n}", ".issect_DRIVER_INFO_2": "static int\r\ndissect_DRIVER_INFO_2(tvbuff_t *tvb, int offset,\r\n\t packet_info *pinfo, proto_tree *tree,\r\n\t dcerpc_info *di, uint8_t *drep)\r\n{\r\n\tproto_tree *subtree;\r\n\tint struct_start = offset;\r\n\r\n\tsubtree = proto_tree_add_subtree(\r\n\t\t\ttree, tvb, offset, 0, ett_DRIVER_INFO_2, NULL, \"Driver info level 2\");\r\n\r\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, subtree, di, drep,\r\n\t\t\thf_driverinfo_cversion, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_drivername,\r\n\t\t\tstruct_start, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_environment,\r\n\t\t\tstruct_start, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_driverpath,\r\n\t\t\tstruct_start, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_datafile,\r\n\t\t\tstruct_start, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_configfile,\r\n\t\t\tstruct_start, NULL);\r\n\r\n\treturn offset;\r\n}", ".issect_DRIVER_INFO_3": "static int\r\ndissect_DRIVER_INFO_3(tvbuff_t *tvb, int offset,\r\n\t\t\t\t packet_info *pinfo, proto_tree *tree,\r\n\t\t\t\t dcerpc_info *di, uint8_t *drep)\r\n{\r\n\tproto_tree *subtree;\r\n\tint struct_start = offset;\r\n\r\n\tsubtree = proto_tree_add_subtree(\r\n\t\ttree, tvb, offset, 0, ett_DRIVER_INFO_3, NULL, \"Driver info level 3\");\r\n\r\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, subtree, di, drep,\r\n\t\t\t\t    hf_driverinfo_cversion, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_drivername,\r\n\t\tstruct_start, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_environment,\r\n\t\tstruct_start, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_driverpath,\r\n\t\tstruct_start, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_datafile,\r\n\t\tstruct_start, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_configfile,\r\n\t\tstruct_start, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_helpfile,\r\n\t\tstruct_start, NULL);\r\n\r\n\toffset = dissect_spoolss_relstrarray(\r\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_dependentfiles,\r\n\t\tstruct_start, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_monitorname,\r\n\t\tstruct_start, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_defaultdatatype,\r\n\t\tstruct_start, NULL);\r\n\r\n\treturn offset;\r\n}", ".issect_DRIVER_INFO_6": "static int\r\ndissect_DRIVER_INFO_6(tvbuff_t *tvb, int offset,\r\n\t\t\t\t packet_info *pinfo, proto_tree *tree,\r\n\t\t\t\t dcerpc_info *di, uint8_t *drep)\r\n{\r\n\tproto_tree *subtree;\r\n\tint struct_start = offset;\r\n\r\n\tsubtree = proto_tree_add_subtree(\r\n\t\t\ttree, tvb, offset, 0, ett_DRIVER_INFO_6, NULL, \"Driver info level 6\");\r\n\r\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, subtree, di, drep,\r\n\t\t\thf_driverinfo_cversion, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_drivername,\r\n\t\t\tstruct_start, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_environment,\r\n\t\t\tstruct_start, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_driverpath,\r\n\t\t\tstruct_start, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_datafile,\r\n\t\t\tstruct_start, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_configfile,\r\n\t\t\tstruct_start, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_helpfile,\r\n\t\t\tstruct_start, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_monitorname,\r\n\t\t\tstruct_start, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_defaultdatatype,\r\n\t\t\tstruct_start, NULL);\r\n\r\n\toffset = dissect_spoolss_relstrarray(\r\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_dependentfiles,\r\n\t\t\tstruct_start, NULL);\r\n\r\n\toffset = dissect_spoolss_relstrarray(\r\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_previousdrivernames,\r\n\t\t\tstruct_start, NULL);\r\n\r\n\toffset = dissect_ndr_nt_NTTIME (\r\n\t\t\ttvb, offset, pinfo, subtree, di, drep,hf_driverdate);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_padding,\r\n\t\t\tNULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_driver_version_low,\r\n\t\t\tNULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_driver_version_high,\r\n\t\t\tNULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_mfgname,\r\n\t\t\tstruct_start, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_oemurl,\r\n\t\t\tstruct_start, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_hardwareid,\r\n\t\t\tstruct_start, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_provider,\r\n\t\t\tstruct_start, NULL);\r\n\r\n\treturn offset;\r\n}", ".issect_DRIVER_INFO_8": "static int\r\ndissect_DRIVER_INFO_8(tvbuff_t *tvb, int offset,\r\n\t\t\t\t packet_info *pinfo, proto_tree *tree,\r\n\t\t\t\t dcerpc_info *di, uint8_t *drep)\r\n{\r\n\tproto_tree *subtree;\r\n\tint struct_start = offset;\r\n\r\n\tsubtree = proto_tree_add_subtree(\r\n\t\t\ttree, tvb, offset, 0, ett_DRIVER_INFO_8, NULL, \"Driver info level 8\");\r\n\r\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, subtree, di, drep,\r\n\t\t\thf_driverinfo_cversion, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_drivername,\r\n\t\t\tstruct_start, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_environment,\r\n\t\t\tstruct_start, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_driverpath,\r\n\t\t\tstruct_start, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_datafile,\r\n\t\t\tstruct_start, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_configfile,\r\n\t\t\tstruct_start, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_helpfile,\r\n\t\t\tstruct_start, NULL);\r\n\r\n\toffset = dissect_spoolss_relstrarray(\r\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_dependentfiles,\r\n\t\t\tstruct_start, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_monitorname,\r\n\t\t\tstruct_start, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_defaultdatatype,\r\n\t\t\tstruct_start, NULL);\r\n\r\n\toffset = dissect_spoolss_relstrarray(\r\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_previousdrivernames,\r\n\t\t\tstruct_start, NULL);\r\n\r\n\toffset = dissect_ndr_nt_NTTIME (\r\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_driverdate);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_padding,\r\n\t\t\tNULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_driver_version_low,\r\n\t\t\tNULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_driver_version_high,\r\n\t\t\tNULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_mfgname,\r\n\t\t\tstruct_start, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_oemurl,\r\n\t\t\tstruct_start, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_hardwareid,\r\n\t\t\tstruct_start, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_provider,\r\n\t\t\tstruct_start, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_printprocessor,\r\n\t\t\tstruct_start, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_vendor_setup,\r\n\t\t\tstruct_start, NULL);\r\n\r\n\toffset = dissect_spoolss_relstrarray(\r\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_color_profiles,\r\n\t\t\tstruct_start, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_inf_path,\r\n\t\t\tstruct_start, NULL);\r\n\r\n\toffset = dissect_printer_driver_attributes(\r\n\t\t\ttvb, offset, pinfo, subtree, di, drep);\r\n\r\n\toffset = dissect_spoolss_relstrarray(\r\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_core_driver_dependencies,\r\n\t\t\tstruct_start, NULL);\r\n\r\n\toffset = dissect_ndr_nt_NTTIME (\r\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_min_inbox_driverdate);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_min_inbox_driver_version_low,\r\n\t\t\tNULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_min_inbox_driver_version_high,\r\n\t\t\tNULL);\r\n\r\n\treturn offset;\r\n}", ".issect_DRIVER_INFO_101": "static int\r\ndissect_DRIVER_INFO_101(tvbuff_t *tvb, int offset,\r\n\t\t\t\t packet_info *pinfo, proto_tree *tree,\r\n\t\t\t\t dcerpc_info *di, uint8_t *drep)\r\n{\r\n\tproto_tree *subtree;\r\n\tint struct_start = offset;\r\n\r\n\tsubtree = proto_tree_add_subtree(\r\n\t\t\ttree, tvb, offset, 0, ett_DRIVER_INFO_101, NULL, \"Driver info level 101\");\r\n\r\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, subtree, di, drep,\r\n\t\t\thf_driverinfo_cversion, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_drivername,\r\n\t\t\tstruct_start, NULL);\r\n\r\n\toffset = dissect_spoolss_relstr(\r\n\t\t\ttvb, offset, pinfo, subtree, di, drep, hf_environment,\r\n\t\t\tstruct_start, NULL);\r\n\r\n\tproto_tree_add_expert(subtree, pinfo, &ei_unknown_data, tvb, offset, 0);\r\n\r\n\treturn offset;\r\n}", ".issect_NOTIFY_INFO_DATA_printer": "static int\r\ndissect_NOTIFY_INFO_DATA_printer(tvbuff_t *tvb, int offset, packet_info *pinfo,\r\n\t\t\t\t proto_tree *tree, proto_item *item,\r\n\t\t\t\t dcerpc_info *di, uint8_t *drep, uint16_t field)\r\n{\r\n\tuint32_t value1;\r\n\r\n\tswitch (field) {\r\n\r\n\t\t/* String notify data */\r\n\r\n\tcase PRINTER_NOTIFY_SERVER_NAME:\r\n\tcase PRINTER_NOTIFY_PRINTER_NAME:\r\n\tcase PRINTER_NOTIFY_SHARE_NAME:\r\n\tcase PRINTER_NOTIFY_DRIVER_NAME:\r\n\tcase PRINTER_NOTIFY_COMMENT:\r\n\tcase PRINTER_NOTIFY_LOCATION:\r\n\tcase PRINTER_NOTIFY_SEPFILE:\r\n\tcase PRINTER_NOTIFY_PRINT_PROCESSOR:\r\n\tcase PRINTER_NOTIFY_PARAMETERS:\r\n\tcase PRINTER_NOTIFY_DATATYPE:\r\n\tcase PRINTER_NOTIFY_PORT_NAME:\r\n\r\n\t\toffset = dissect_ndr_uint32(\r\n\t\t\ttvb, offset, pinfo, tree, di, drep,\r\n\t\t\thf_notify_info_data_bufsize, &value1);\r\n\r\n\t\toffset = dissect_ndr_pointer_cb(\r\n\t\t\ttvb, offset, pinfo, tree, di, drep,\r\n\t\t\tdissect_notify_info_data_buffer,\r\n\t\t\tNDR_POINTER_UNIQUE, \"String\",\r\n\t\t\thf_notify_info_data_buffer,\r\n\t\t\tcb_notify_str_postprocess,\r\n\t\t\tGINT_TO_POINTER(printer_notify_hf_index(field)));\r\n\r\n\t\tbreak;\r\n\r\n\tcase PRINTER_NOTIFY_ATTRIBUTES:\r\n\r\n\t\t/* Value 1 is the printer attributes */\r\n\r\n\t\toffset = dissect_printer_attributes(\r\n\t\t\ttvb, offset, pinfo, tree, di, drep);\r\n\r\n\t\toffset = dissect_ndr_uint32(\r\n\t\t\ttvb, offset, pinfo, NULL, di, drep,\r\n\t\t\thf_notify_info_data_value2, NULL);\r\n\r\n\t\tbreak;\r\n\r\n\tcase PRINTER_NOTIFY_STATUS: {\r\n\t\tuint32_t status;\r\n\r\n\t\t/* Value 1 is the printer status */\r\n\r\n \t\toffset = dissect_ndr_uint32(\r\n\t\t\ttvb, offset, pinfo, tree, di, drep,\r\n\t\t\thf_printer_status, &status);\r\n\r\n\t\toffset = dissect_ndr_uint32(\r\n\t\t\ttvb, offset, pinfo, NULL, di, drep,\r\n\t\t\thf_notify_info_data_value2, NULL);\r\n\r\n\t\tproto_item_append_text(\r\n\t\t\titem, \": %s\",\r\n\t\t\tval_to_str_ext_const(status, &printer_status_vals_ext, \"Unknown\"));\r\n\r\n\t\tbreak;\r\n\t}\r\n\r\n\t\t/* Unknown notify data */\r\n\r\n\tcase PRINTER_NOTIFY_SECURITY_DESCRIPTOR: /* Secdesc */\r\n\tcase PRINTER_NOTIFY_DEVMODE: /* Devicemode */\r\n\r\n\t\toffset = dissect_ndr_uint32(\r\n\t\t\ttvb, offset, pinfo, tree, di, drep,\r\n\t\t\thf_notify_info_data_bufsize, &value1);\r\n\r\n\t\toffset = dissect_ndr_pointer(\r\n\t\t\ttvb, offset, pinfo, tree, di, drep,\r\n\t\t\tdissect_notify_info_data_buffer,\r\n\t\t\tNDR_POINTER_UNIQUE, \"Buffer\",\r\n\t\t\thf_notify_info_data_buffer);\r\n\r\n\t\tbreak;\r\n\r\n\tdefault:\r\n\t\toffset = dissect_ndr_uint32(\r\n\t\t\ttvb, offset, pinfo, tree, di, drep,\r\n\t\t\thf_notify_info_data_value1, NULL);\r\n\r\n\t\toffset = dissect_ndr_uint32(\r\n\t\t\ttvb, offset, pinfo, tree, di, drep,\r\n\t\t\thf_notify_info_data_value2, NULL);\r\n\r\n\t\tbreak;\r\n\t}\r\n\treturn offset;\r\n}", ".issect_USER_LEVEL_CTR": "int\r\ndissect_USER_LEVEL_CTR(tvbuff_t *tvb, int offset,\r\n\t\t\t\t  packet_info *pinfo, proto_tree *tree,\r\n\t\t\t\t  dcerpc_info *di, uint8_t *drep)\r\n{\r\n\tproto_tree *subtree;\r\n\tproto_item *item;\r\n\tuint32_t level;\r\n\r\n\tif (di->conformant_run)\r\n\t\treturn offset;\r\n\r\n\tsubtree = proto_tree_add_subtree(\r\n\t\ttree, tvb, offset, 0, ett_USER_LEVEL_CTR, &item, \"User level container\");\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_level, &level);\r\n\r\n\tswitch(level) {\r\n\tcase 1:\r\n\t\toffset = dissect_ndr_pointer(\r\n\t\t\ttvb, offset, pinfo, subtree, di, drep,\r\n\t\t\tdissect_USER_LEVEL_1, NDR_POINTER_UNIQUE,\r\n\t\t\t\"User level 1\", -1);\r\n\t\tbreak;\r\n\tdefault:\r\n\t\texpert_add_info_format(pinfo, item, &ei_level, \"Info level %d not decoded\", level);\r\n\t\tbreak;\r\n\t}\r\n\r\n\treturn offset;\r\n}", ".issect_NOTIFY_OPTION_DATA": "static int\r\ndissect_NOTIFY_OPTION_DATA(tvbuff_t *tvb, int offset, packet_info *pinfo,\r\n\t\t\t   proto_tree *tree, dcerpc_info *di, uint8_t *drep)\r\n{\r\n\tdcerpc_call_value *dcv = (dcerpc_call_value *)di->call_data;\r\n\tuint32_t count, i;\r\n\tuint16_t type;\r\n\r\n\tif (di->conformant_run)\r\n\t\treturn offset;\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, tree, di, drep,\r\n\t\thf_notify_option_data_count, &count);\r\n\r\n\ttype = GPOINTER_TO_INT(dcv->private_data);\r\n\r\n\tfor (i = 0; i < count; i++)\r\n\t\toffset = dissect_notify_field(\r\n\t\t\ttvb, offset, pinfo, tree, di, drep, type, NULL);\r\n\r\n\treturn offset;\r\n}", ".issect_NOTIFY_INFO_DATA": "static int\r\ndissect_NOTIFY_INFO_DATA(tvbuff_t *tvb, int offset, packet_info *pinfo,\r\n\t\t\t proto_tree *tree, dcerpc_info *di, uint8_t *drep)\r\n{\r\n\tproto_item *item;\r\n\tproto_tree *subtree;\r\n\tuint32_t count;\r\n\tuint16_t type, field;\r\n\tconst char *field_string;\r\n\r\n\tsubtree = proto_tree_add_subtree(tree, tvb, offset, 0, ett_NOTIFY_INFO_DATA, &item, \"\");\r\n\r\n\toffset = dissect_ndr_uint16(\r\n\t\ttvb, offset, pinfo, subtree, di, drep,\r\n\t\thf_notify_info_data_type, &type);\r\n\r\n\toffset = dissect_notify_field(\r\n\t\ttvb, offset, pinfo, subtree, di, drep, type, &field);\r\n\r\n\tswitch(type) {\r\n\tcase PRINTER_NOTIFY_TYPE:\r\n\t\tfield_string = val_to_str_ext(pinfo->pool,\r\n\t\t\tfield, &printer_notify_option_data_vals_ext,\r\n\t\t\t\"Unknown (%d)\");\r\n\t\tbreak;\r\n\tcase JOB_NOTIFY_TYPE:\r\n\t\tfield_string = val_to_str_ext(pinfo->pool,\r\n\t\t\tfield, &job_notify_option_data_vals_ext,\r\n\t\t\t\"Unknown (%d)\");\r\n\t\tbreak;\r\n\tdefault:\r\n\t\tfield_string = \"Unknown field\";\r\n\t\tbreak;\r\n\t}\r\n\r\n\tproto_item_append_text(\r\n\t\titem, \"%s, %s\",\r\n\t\tval_to_str_wmem(pinfo->pool, type, printer_notify_types, \"Unknown (%d)\"),\r\n\t\tfield_string);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, subtree, di, drep,\r\n\t\thf_notify_info_data_count, &count);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, subtree, di, drep,\r\n\t\thf_notify_info_data_id, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, subtree, di, drep,\r\n\t\thf_notify_info_data_count, NULL);\r\n\r\n\t/* The value here depends on (type, field) */\r\n\r\n\tswitch (type) {\r\n\tcase PRINTER_NOTIFY_TYPE:\r\n\t\toffset = dissect_NOTIFY_INFO_DATA_printer(\r\n\t\t\ttvb, offset, pinfo, subtree, item, di, drep, field);\r\n\t\tbreak;\r\n\tcase JOB_NOTIFY_TYPE:\r\n\t\toffset = dissect_NOTIFY_INFO_DATA_job(\r\n\t\t\ttvb, offset, pinfo, subtree, item, di, drep, field);\r\n\t\tbreak;\r\n\tdefault:\r\n\t\texpert_add_info(pinfo, item, &ei_notify_info_data_type);\r\n\t\tbreak;\r\n\t}\r\n\r\n\treturn offset;\r\n}", ".issect_NOTIFY_OPTION": "static int\r\ndissect_NOTIFY_OPTION(tvbuff_t *tvb, int offset, packet_info *pinfo,\r\n\t\t      proto_tree *tree, dcerpc_info *di, uint8_t *drep)\r\n{\r\n\tdcerpc_call_value *dcv = (dcerpc_call_value *)di->call_data;\r\n\tproto_item *item;\r\n\tproto_tree *subtree;\r\n\tuint16_t type;\r\n\tuint32_t count;\r\n\r\n\tsubtree = proto_tree_add_subtree(tree, tvb, offset, 0, ett_NOTIFY_OPTION, &item, \"Notify Option\");\r\n\r\n\toffset = dissect_ndr_uint16(tvb, offset, pinfo, subtree, di, drep,\r\n\t\t\t\t    hf_notify_option_type, &type);\r\n\r\n\tproto_item_append_text(\r\n\t\titem, \": %s\", val_to_str_wmem(pinfo->pool, type, printer_notify_types,\r\n\t\t\t\t\t \"Unknown (%d)\"));\r\n\r\n\toffset = dissect_ndr_uint16(tvb, offset, pinfo, subtree, di, drep,\r\n\t\t\t\t    hf_notify_option_reserved1, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, subtree, di, drep,\r\n\t\t\t\t    hf_notify_option_reserved2, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, subtree, di, drep,\r\n\t\t\t\t    hf_notify_option_reserved3, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, subtree, di, drep,\r\n\t\t\t\t    hf_notify_option_count, &count);\r\n\r\n\tproto_item_append_text(\r\n\t\titem, \", %d %s\", count, notify_plural(count));\r\n\r\n\tdcv->private_data = GINT_TO_POINTER((int)type);\r\n\r\n\toffset = dissect_ndr_pointer(\r\n\t\ttvb, offset, pinfo, subtree, di, drep,\r\n\t\tdissect_NOTIFY_OPTION_DATA, NDR_POINTER_UNIQUE,\r\n\t\t\"Notify Option Data\", -1);\r\n\r\n\treturn offset;\r\n}", ".issect_NOTIFY_OPTIONS_ARRAY": "static int\r\ndissect_NOTIFY_OPTIONS_ARRAY(tvbuff_t *tvb, int offset,\r\n\t\t\t     packet_info *pinfo, proto_tree *tree,\r\n\t\t\t     dcerpc_info *di, uint8_t *drep)\r\n{\r\n\t/* Why is a check for di->conformant_run not required here? */\r\n\r\n\toffset = dissect_ndr_ucarray(\r\n\t\ttvb, offset, pinfo, tree, di, drep, dissect_NOTIFY_OPTION);\r\n\r\n\treturn offset;\r\n}", ".issect_NOTIFY_OPTIONS_ARRAY_CTR": "int\r\ndissect_NOTIFY_OPTIONS_ARRAY_CTR(tvbuff_t *tvb, int offset,\r\n\t\t\t\t packet_info *pinfo, proto_tree *tree,\r\n\t\t\t\t dcerpc_info *di, uint8_t *drep)\r\n{\r\n\tif (di->conformant_run)\r\n\t\treturn offset;\r\n\r\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, tree, di, drep,\r\n\t\t\t\t    hf_notify_options_version, NULL);\r\n\r\n\toffset = dissect_notify_options_flags(tvb, offset, pinfo, tree, di, drep);\r\n\r\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, tree, di, drep,\r\n\t\t\t\t    hf_notify_options_count, NULL);\r\n\r\n\toffset = dissect_ndr_pointer(\r\n\t\ttvb, offset, pinfo, tree, di, drep,\r\n\t\tdissect_NOTIFY_OPTIONS_ARRAY, NDR_POINTER_UNIQUE,\r\n\t\t\"Notify Options Array\", -1);\r\n\r\n\treturn offset;\r\n}", ".poolssRFFPCNEX_q": "static int\r\nSpoolssRFFPCNEX_q(tvbuff_t *tvb, int offset,\r\n\t\t\t     packet_info *pinfo, proto_tree *tree,\r\n\t\t\t     dcerpc_info *di, uint8_t *drep)\r\n{\r\n\tuint32_t flags;\r\n\tstatic int * const hf_flags[] = {\r\n\t\t&hf_rffpcnex_flags_timeout,\r\n\t\t&hf_rffpcnex_flags_delete_driver,\r\n\t\t&hf_rffpcnex_flags_set_driver,\r\n\t\t&hf_rffpcnex_flags_add_driver,\r\n\t\t&hf_rffpcnex_flags_delete_print_processor,\r\n\t\t&hf_rffpcnex_flags_add_print_processor,\r\n\t\t&hf_rffpcnex_flags_delete_port,\r\n\t\t&hf_rffpcnex_flags_configure_port,\r\n\t\t&hf_rffpcnex_flags_add_port,\r\n\t\t&hf_rffpcnex_flags_delete_form,\r\n\t\t&hf_rffpcnex_flags_set_form,\r\n\t\t&hf_rffpcnex_flags_add_form,\r\n\t\t&hf_rffpcnex_flags_write_job,\r\n\t\t&hf_rffpcnex_flags_delete_job,\r\n\t\t&hf_rffpcnex_flags_set_job,\r\n\t\t&hf_rffpcnex_flags_add_job,\r\n\t\t&hf_rffpcnex_flags_failed_printer_connection,\r\n\t\t&hf_rffpcnex_flags_delete_printer,\r\n\t\t&hf_rffpcnex_flags_set_printer,\r\n\t\t&hf_rffpcnex_flags_add_printer,\r\n\t\tNULL\r\n\t};\r\n\r\n\t/* Parse packet */\r\n\r\n\toffset = dissect_nt_policy_hnd(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_hnd, NULL, NULL,\r\n\t\tPIDL_POLHND_USE);\r\n\r\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, NULL, di, drep, -1, &flags);\r\n\r\n\tproto_tree_add_bitmask_value(tree, tvb, offset - 4, hf_rffpcnex_flags,\r\n\t\t\t\t\tett_rffpcnex_flags, hf_flags, flags);\r\n\r\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, tree, di, drep,\r\n\t\t\t\t    hf_rffpcnex_options, NULL);\r\n\r\n\toffset = dissect_ndr_str_pointer_item(\r\n\t\ttvb, offset, pinfo, tree, di, drep, NDR_POINTER_UNIQUE,\r\n\t\t\"Server\", hf_servername, 0);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printerlocal, NULL);\r\n\r\n\toffset = dissect_ndr_pointer(\r\n\t\ttvb, offset, pinfo, tree, di, drep,\r\n\t\tdissect_NOTIFY_OPTIONS_ARRAY_CTR, NDR_POINTER_UNIQUE,\r\n\t\t\"Notify Options Container\", -1);\r\n\r\n\treturn offset;\r\n}", ".poolssRFNPCNEX_q": "static int\r\nSpoolssRFNPCNEX_q(tvbuff_t *tvb, int offset, packet_info *pinfo,\r\n\t\t\t     proto_tree *tree, dcerpc_info *di, uint8_t *drep)\r\n{\r\n\tuint32_t changeid;\r\n\r\n\t/* Parse packet */\r\n\r\n\toffset = dissect_nt_policy_hnd(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_hnd, NULL, NULL,\r\n\t\tPIDL_POLHND_USE);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_rrpcn_changelow, &changeid);\r\n\r\n\tcol_append_fstr(\r\n\t\t\tpinfo->cinfo, COL_INFO, \", changeid %d\", changeid);\r\n\r\n\toffset = dissect_ndr_pointer(\r\n\t\ttvb, offset, pinfo, tree, di, drep,\r\n\t\tdissect_NOTIFY_OPTIONS_ARRAY_CTR, NDR_POINTER_UNIQUE,\r\n\t\t\"Notify Options Array Container\", -1);\r\n\r\n\treturn offset;\r\n}", ".poolssSetPrinter_q": "static int\r\nSpoolssSetPrinter_q(tvbuff_t *tvb, int offset, packet_info *pinfo,\r\n\t\t\t       proto_tree *tree, dcerpc_info *di, uint8_t *drep)\r\n{\r\n\tuint32_t level;\r\n\r\n\t/* Parse packet */\r\n\r\n\toffset = dissect_nt_policy_hnd(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_hnd, NULL, NULL,\r\n\t\tPIDL_POLHND_USE);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_level, &level);\r\n\r\n\tcol_append_fstr(pinfo->cinfo, COL_INFO, \", level %d\", level);\r\n\r\n\toffset = dissect_SPOOL_PRINTER_INFO(\r\n\t\ttvb, offset, pinfo, tree, di, drep);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, tree, di, drep,\r\n\t\thf_setprinter_cmd, NULL);\r\n\r\n\treturn offset;\r\n}", ".issect_FORM_CTR": "int\r\ndissect_FORM_CTR(tvbuff_t *tvb, int offset,\r\n\t\t\t    packet_info *pinfo, proto_tree *tree,\r\n\t\t\t    dcerpc_info *di, uint8_t *drep)\r\n{\r\n\tproto_tree *subtree;\r\n\tproto_item *item;\r\n\tuint32_t level;\r\n\r\n\tsubtree = proto_tree_add_subtree(tree, tvb, offset, 0, ett_FORM_CTR, &item, \"Form container\");\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_form_level, &level);\r\n\r\n\tswitch(level) {\r\n\tcase 1:\r\n\t\toffset = dissect_FORM_1(tvb, offset, pinfo, subtree, di, drep);\r\n\t\tbreak;\r\n\r\n\tdefault:\r\n\t\texpert_add_info_format(pinfo, item, &ei_form_level, \"Unknown form info level %d\", level);\r\n\t\tbreak;\r\n\t}\r\n\r\n\treturn offset;\r\n}", ".poolssAddForm_q": "static int\r\nSpoolssAddForm_q(tvbuff_t *tvb, int offset, packet_info *pinfo,\r\n\t\t\t    proto_tree *tree, dcerpc_info *di, uint8_t *drep)\r\n{\r\n\tdcerpc_call_value *dcv = (dcerpc_call_value *)di->call_data;\r\n\tuint32_t level;\r\n\tproto_item *hidden_item;\r\n\r\n\thidden_item = proto_tree_add_uint(\r\n\t\ttree, hf_form, tvb, offset, 0, 1);\r\n\tproto_item_set_hidden(hidden_item);\r\n\r\n\t/* Parse packet */\r\n\r\n\toffset = dissect_nt_policy_hnd(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_hnd, NULL, NULL,\r\n\t\tPIDL_POLHND_USE);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_form_level, &level);\r\n\r\n\tcol_append_fstr(pinfo->cinfo, COL_INFO, \", level %d\", level);\r\n\r\n\t/* AddForm() stores the level in se_data */\r\n\tif(!pinfo->fd->visited){\r\n\t\t\tdcv->se_data = GUINT_TO_POINTER((int)level);\r\n\t}\r\n\r\n\toffset = dissect_FORM_CTR(tvb, offset, pinfo, tree, di, drep);\r\n\r\n\treturn offset;\r\n}", ".poolssSetForm_q": "static int\r\nSpoolssSetForm_q(tvbuff_t *tvb, int offset, packet_info *pinfo,\r\n\t\t\t    proto_tree *tree, dcerpc_info *di, uint8_t *drep)\r\n{\r\n\tchar *name = NULL;\r\n\tuint32_t level;\r\n\tproto_item *hidden_item;\r\n\r\n\thidden_item = proto_tree_add_uint(\r\n\t\ttree, hf_form, tvb, offset, 0, 1);\r\n\tproto_item_set_hidden(hidden_item);\r\n\r\n\t/* Parse packet */\r\n\r\n\toffset = dissect_nt_policy_hnd(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_hnd, NULL, NULL,\r\n\t\tPIDL_POLHND_USE);\r\n\r\n\toffset = dissect_ndr_cvstring(\r\n\t\ttvb, offset, pinfo, tree, di, drep,\r\n\t\tsizeof(uint16_t), hf_form_name, true, &name);\r\n\r\n\tif (name)\r\n\t\tcol_append_fstr(pinfo->cinfo, COL_INFO, \", %s\", name);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_form_level, &level);\r\n\r\n\tcol_append_fstr(pinfo->cinfo, COL_INFO, \", level %d\", level);\r\n\r\n\toffset = dissect_FORM_CTR(tvb, offset, pinfo, tree, di, drep);\r\n\r\n\treturn offset;\r\n}", ".issect_spoolss_doc_info_data": "static int\r\ndissect_spoolss_doc_info_data(tvbuff_t *tvb, int offset, packet_info *pinfo,\r\n\t\t\t      proto_tree *tree, dcerpc_info *di, uint8_t *drep)\r\n{\r\n\tif (di->conformant_run)\r\n\t\treturn offset;\r\n\r\n\treturn dissect_spoolss_doc_info_1(tvb, offset, pinfo, tree, di, drep);\r\n}", ".issect_spoolss_doc_info": "static int\r\ndissect_spoolss_doc_info(tvbuff_t *tvb, int offset, packet_info *pinfo,\r\n\t\t\t proto_tree *tree, dcerpc_info *di, uint8_t *drep)\r\n{\r\n\tproto_tree *subtree;\r\n\tuint32_t level;\r\n\r\n\tsubtree = proto_tree_add_subtree(\r\n\t\ttree, tvb, offset, 0, ett_DOC_INFO, NULL, \"Document info\");\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_level, &level);\r\n\r\n\toffset = dissect_ndr_pointer(\r\n\t\ttvb, offset, pinfo, subtree, di, drep,\r\n\t\tdissect_spoolss_doc_info_data,\r\n\t\tNDR_POINTER_UNIQUE, \"Document info\", -1);\r\n\r\n\treturn offset;\r\n}", ".issect_spoolss_doc_info_ctr": "int\r\ndissect_spoolss_doc_info_ctr(tvbuff_t *tvb, int offset, packet_info *pinfo,\r\n\t\t\t     proto_tree *tree, dcerpc_info *di, uint8_t *drep)\r\n{\r\n\tproto_tree *subtree;\r\n\r\n\tsubtree = proto_tree_add_subtree(\r\n\t\ttree, tvb, offset, 0, ett_DOC_INFO_CTR, NULL, \"Document info container\");\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_level, NULL);\r\n\r\n\toffset = dissect_spoolss_doc_info(\r\n\t\ttvb, offset, pinfo, subtree, di, drep);\r\n\r\n\treturn offset;\r\n}", ".poolssStartDocPrinter_q": "static int\r\nSpoolssStartDocPrinter_q(tvbuff_t *tvb, int offset,\r\n\t\t\t\t    packet_info *pinfo, proto_tree *tree,\r\n\t\t\t\t    dcerpc_info *di, uint8_t *drep)\r\n{\r\n\te_ctx_hnd policy_hnd;\r\n\tchar *pol_name;\r\n\r\n\t/* Parse packet */\r\n\r\n\toffset = dissect_nt_policy_hnd(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_hnd, &policy_hnd, NULL,\r\n\t\tPIDL_POLHND_USE);\r\n\r\n\tdcerpc_fetch_polhnd_data(&policy_hnd, &pol_name, NULL, NULL, NULL,\r\n\t\t\t     pinfo->num);\r\n\r\n\tif (pol_name)\r\n\t\tcol_append_fstr(pinfo->cinfo, COL_INFO, \", %s\",\r\n\t\t\t\tpol_name);\r\n\r\n\toffset = dissect_spoolss_doc_info_ctr(tvb, offset, pinfo, tree, di, drep);\r\n\r\n\treturn offset;\r\n}", ".poolssGetCorePrinterDrivers_r": "static int\r\nSpoolssGetCorePrinterDrivers_r(tvbuff_t *tvb, int offset,\r\n\t\t\t       packet_info *pinfo, proto_tree *tree,\r\n\t\t\t       dcerpc_info *di, uint8_t *drep)\r\n{\r\n\tuint32_t num_drivers, i;\r\n\r\n\t/* Parse packet */\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, tree, di, drep,\r\n\t\thf_core_printer_driver_count,\r\n\t\t&num_drivers);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_core_printer_driver_ids,\r\n\t\tNULL);\r\n\r\n\tfor (i = 0; i < num_drivers; i++) {\r\n\t\toffset = dissect_CORE_PRINTER_DRIVER(\r\n\t\t\ttvb, offset, pinfo,\r\n\t\t\ttree, di, drep);\r\n\t}\r\n\r\n\toffset = dissect_hresult(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_hresult, NULL);\r\n\r\n\treturn offset;\r\n}", ".issect_NOTIFY_INFO": "int\r\ndissect_NOTIFY_INFO(tvbuff_t *tvb, int offset, packet_info *pinfo,\r\n\t\t    proto_tree *tree, dcerpc_info *di, uint8_t *drep)\r\n{\r\n\tuint32_t count;\r\n\r\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, tree, di, drep,\r\n\t\t\t\t    hf_notify_info_version, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, tree, di, drep,\r\n\t\t\t\t    hf_notify_info_flags, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, tree, di, drep,\r\n\t\t\t\t    hf_notify_info_count, &count);\r\n\r\n\tif (!di->conformant_run)\r\n\t\tcol_append_fstr(\r\n\t\t\tpinfo->cinfo, COL_INFO, \", %d %s\", count,\r\n\t\t\tnotify_plural(count));\r\n\r\n\toffset = dissect_ndr_ucarray(tvb, offset, pinfo, tree, di, drep,\r\n\t\t\t\t     dissect_NOTIFY_INFO_DATA);\r\n\r\n\treturn offset;\r\n}", ".poolssRFNPCNEX_r": "static int\r\nSpoolssRFNPCNEX_r(tvbuff_t *tvb, int offset, packet_info *pinfo,\r\n\t\t\t     proto_tree *tree, dcerpc_info *di, uint8_t *drep)\r\n{\r\n\t/* Parse packet */\r\n\r\n\toffset = dissect_ndr_pointer(\r\n\t\ttvb, offset, pinfo, tree, di, drep,\r\n\t\tdissect_NOTIFY_INFO, NDR_POINTER_UNIQUE,\r\n\t\t\"Notify Info\", -1);\r\n\r\n\toffset = dissect_doserror(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_rc, NULL);\r\n\r\n\treturn offset;\r\n}", ".poolssRRPCN_q": "static int\r\nSpoolssRRPCN_q(tvbuff_t *tvb, int offset, packet_info *pinfo,\r\n\t\t\t  proto_tree *tree, dcerpc_info *di, uint8_t *drep)\r\n{\r\n\tuint32_t changeid;\r\n\r\n\t/* Parse packet */\r\n\r\n\toffset = dissect_nt_policy_hnd(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_hnd, NULL, NULL,\r\n\t\tPIDL_POLHND_USE);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_rrpcn_changelow, &changeid);\r\n\r\n\tcol_append_fstr(\r\n\t\t\tpinfo->cinfo, COL_INFO, \", changeid %d\", changeid);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_rrpcn_changehigh, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_rrpcn_unk0, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_rrpcn_unk1, NULL);\r\n\r\n\toffset = dissect_ndr_pointer(\r\n\t\ttvb, offset, pinfo, tree, di, drep,\r\n\t\tdissect_NOTIFY_INFO, NDR_POINTER_UNIQUE,\r\n\t\t\"Notify Info\", -1);\r\n\r\n\t/* Notify info */\r\n\r\n\treturn offset;\r\n}", ".poolssEnumPrinterKey_r": "static int\r\nSpoolssEnumPrinterKey_r(tvbuff_t *tvb, int offset,\r\n\t\t\t\t   packet_info *pinfo, proto_tree *tree,\r\n\t\t\t\t   dcerpc_info *di, uint8_t *drep)\r\n{\r\n\t/* Parse packet */\r\n\r\n\toffset = dissect_spoolss_keybuffer(tvb, offset, pinfo, tree, di, drep);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_needed, NULL);\r\n\r\n\toffset = dissect_doserror(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_rc, NULL);\r\n\r\n\treturn offset;\r\n}", ".poolssEnumPrinterDataEx_r": "static int\r\nSpoolssEnumPrinterDataEx_r(tvbuff_t *tvb, int offset,\r\n\t\t\t\t   packet_info *pinfo, proto_tree *tree,\r\n\t\t\t\t   dcerpc_info *di, uint8_t *drep)\r\n{\r\n\tuint32_t size, num_values;\r\n\tproto_item *hidden_item;\r\n\r\n\thidden_item = proto_tree_add_uint(\r\n\t\ttree, hf_printerdata, tvb, offset, 0, 1);\r\n\tproto_item_set_hidden(hidden_item);\r\n\r\n\t/* Parse packet */\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, tree, di, drep,\r\n\t\thf_buffer_size, &size);\r\n\r\n\tdissect_ndr_uint32(\r\n\t\ttvb, offset + size + 4, pinfo, NULL, di, drep, hf_returned,\r\n\t\t&num_values);\r\n\r\n\tif (size) {\r\n\t\tproto_tree *subtree;\r\n\t\tint offset2 = offset;\r\n\t\tuint32_t i;\r\n\r\n\t\tsubtree = proto_tree_add_subtree(\r\n\t\t\ttree, tvb, offset, 0, ett_PRINTER_DATA_CTR, NULL, \"Printer data\");\r\n\r\n\t\tfor (i=0; i < num_values; i++)\r\n\t\t\toffset2 = dissect_spoolss_printer_enum_values(\r\n\t\t\t\ttvb, offset2, pinfo, subtree, di, drep);\r\n\t}\r\n\r\n\toffset += size;\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_needed, NULL);\r\n\r\n\toffset = dissect_ndr_uint32(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_returned, NULL);\r\n\r\n\toffset = dissect_doserror(\r\n\t\ttvb, offset, pinfo, tree, di, drep, hf_rc, NULL);\r\n\r\n\treturn offset;\r\n}"}, "function_name": "proto_reg_handoff_dcerpc_spoolss"}
{"function_id": null, "caller": {".udit_compare_uid": "static int audit_compare_uid(kuid_t uid,\r\n\t\t\t     struct audit_names *name,\r\n\t\t\t     struct audit_field *f,\r\n\t\t\t     struct audit_context *ctx)\r\n{\r\n\tstruct audit_names *n;\r\n\tint rc;\r\n\r\n\tif (name) {\r\n\t\trc = audit_uid_comparator(uid, f->op, name->uid);\r\n\t\tif (rc)\r\n\t\t\treturn rc;\r\n\t}\r\n\r\n\tif (ctx) {\r\n\t\tlist_for_each_entry(n, &ctx->names_list, list) {\r\n\t\t\trc = audit_uid_comparator(uid, f->op, n->uid);\r\n\t\t\tif (rc)\r\n\t\t\t\treturn rc;\r\n\t\t}\r\n\t}\r\n\treturn 0;\r\n}", ".udit_compare_gid": "static int audit_compare_gid(kgid_t gid,\r\n\t\t\t     struct audit_names *name,\r\n\t\t\t     struct audit_field *f,\r\n\t\t\t     struct audit_context *ctx)\r\n{\r\n\tstruct audit_names *n;\r\n\tint rc;\r\n\r\n\tif (name) {\r\n\t\trc = audit_gid_comparator(gid, f->op, name->gid);\r\n\t\tif (rc)\r\n\t\t\treturn rc;\r\n\t}\r\n\r\n\tif (ctx) {\r\n\t\tlist_for_each_entry(n, &ctx->names_list, list) {\r\n\t\t\trc = audit_gid_comparator(gid, f->op, n->gid);\r\n\t\t\tif (rc)\r\n\t\t\t\treturn rc;\r\n\t\t}\r\n\t}\r\n\treturn 0;\r\n}", ".atch_tree_refs": "static int match_tree_refs(struct audit_context *ctx, struct audit_tree *tree)\r\n{\r\n\tstruct audit_tree_refs *p;\r\n\tint n;\r\n\r\n\tif (!tree)\r\n\t\treturn 0;\r\n\t/* full ones */\r\n\tfor (p = ctx->first_trees; p != ctx->trees; p = p->next) {\r\n\t\tfor (n = 0; n < 31; n++)\r\n\t\t\tif (audit_tree_match(p->c[n], tree))\r\n\t\t\t\treturn 1;\r\n\t}\r\n\t/* partial */\r\n\tif (p) {\r\n\t\tfor (n = ctx->tree_count; n < 31; n++)\r\n\t\t\tif (audit_tree_match(p->c[n], tree))\r\n\t\t\t\treturn 1;\r\n\t}\r\n\treturn 0;\r\n}", ".udit_match_perm": "static int audit_match_perm(struct audit_context *ctx, int mask)\r\n{\r\n\tunsigned n;\r\n\r\n\tif (unlikely(!ctx))\r\n\t\treturn 0;\r\n\tn = ctx->major;\r\n\r\n\tswitch (audit_classify_syscall(ctx->arch, n)) {\r\n\tcase AUDITSC_NATIVE:\r\n\t\tif ((mask & AUDIT_PERM_WRITE) &&\r\n\t\t     audit_match_class(AUDIT_CLASS_WRITE, n))\r\n\t\t\treturn 1;\r\n\t\tif ((mask & AUDIT_PERM_READ) &&\r\n\t\t     audit_match_class(AUDIT_CLASS_READ, n))\r\n\t\t\treturn 1;\r\n\t\tif ((mask & AUDIT_PERM_ATTR) &&\r\n\t\t     audit_match_class(AUDIT_CLASS_CHATTR, n))\r\n\t\t\treturn 1;\r\n\t\treturn 0;\r\n\tcase AUDITSC_COMPAT: /* 32bit on biarch */\r\n\t\tif ((mask & AUDIT_PERM_WRITE) &&\r\n\t\t     audit_match_class(AUDIT_CLASS_WRITE_32, n))\r\n\t\t\treturn 1;\r\n\t\tif ((mask & AUDIT_PERM_READ) &&\r\n\t\t     audit_match_class(AUDIT_CLASS_READ_32, n))\r\n\t\t\treturn 1;\r\n\t\tif ((mask & AUDIT_PERM_ATTR) &&\r\n\t\t     audit_match_class(AUDIT_CLASS_CHATTR_32, n))\r\n\t\t\treturn 1;\r\n\t\treturn 0;\r\n\tcase AUDITSC_OPEN:\r\n\t\treturn mask & ACC_MODE(ctx->argv[1]);\r\n\tcase AUDITSC_OPENAT:\r\n\t\treturn mask & ACC_MODE(ctx->argv[2]);\r\n\tcase AUDITSC_SOCKETCALL:\r\n\t\treturn ((mask & AUDIT_PERM_WRITE) && ctx->argv[0] == SYS_BIND);\r\n\tcase AUDITSC_EXECVE:\r\n\t\treturn mask & AUDIT_PERM_EXEC;\r\n\tcase AUDITSC_OPENAT2:\r\n\t\treturn mask & ACC_MODE((u32)ctx->openat2.flags);\r\n\tdefault:\r\n\t\treturn 0;\r\n\t}\r\n}", ".udit_match_filetype": "static int audit_match_filetype(struct audit_context *ctx, int val)\r\n{\r\n\tstruct audit_names *n;\r\n\tumode_t mode = (umode_t)val;\r\n\r\n\tif (unlikely(!ctx))\r\n\t\treturn 0;\r\n\r\n\tlist_for_each_entry(n, &ctx->names_list, list) {\r\n\t\tif ((n->ino != AUDIT_INO_UNSET) &&\r\n\t\t    ((n->mode & S_IFMT) == mode))\r\n\t\t\treturn 1;\r\n\t}\r\n\r\n\treturn 0;\r\n}", ".udit_field_compare": "static int audit_field_compare(struct task_struct *tsk,\r\n\t\t\t       const struct cred *cred,\r\n\t\t\t       struct audit_field *f,\r\n\t\t\t       struct audit_context *ctx,\r\n\t\t\t       struct audit_names *name)\r\n{\r\n\tswitch (f->val) {\r\n\t/* process to file object comparisons */\r\n\tcase AUDIT_COMPARE_UID_TO_OBJ_UID:\r\n\t\treturn audit_compare_uid(cred->uid, name, f, ctx);\r\n\tcase AUDIT_COMPARE_GID_TO_OBJ_GID:\r\n\t\treturn audit_compare_gid(cred->gid, name, f, ctx);\r\n\tcase AUDIT_COMPARE_EUID_TO_OBJ_UID:\r\n\t\treturn audit_compare_uid(cred->euid, name, f, ctx);\r\n\tcase AUDIT_COMPARE_EGID_TO_OBJ_GID:\r\n\t\treturn audit_compare_gid(cred->egid, name, f, ctx);\r\n\tcase AUDIT_COMPARE_AUID_TO_OBJ_UID:\r\n\t\treturn audit_compare_uid(audit_get_loginuid(tsk), name, f, ctx);\r\n\tcase AUDIT_COMPARE_SUID_TO_OBJ_UID:\r\n\t\treturn audit_compare_uid(cred->suid, name, f, ctx);\r\n\tcase AUDIT_COMPARE_SGID_TO_OBJ_GID:\r\n\t\treturn audit_compare_gid(cred->sgid, name, f, ctx);\r\n\tcase AUDIT_COMPARE_FSUID_TO_OBJ_UID:\r\n\t\treturn audit_compare_uid(cred->fsuid, name, f, ctx);\r\n\tcase AUDIT_COMPARE_FSGID_TO_OBJ_GID:\r\n\t\treturn audit_compare_gid(cred->fsgid, name, f, ctx);\r\n\t/* uid comparisons */\r\n\tcase AUDIT_COMPARE_UID_TO_AUID:\r\n\t\treturn audit_uid_comparator(cred->uid, f->op,\r\n\t\t\t\t\t    audit_get_loginuid(tsk));\r\n\tcase AUDIT_COMPARE_UID_TO_EUID:\r\n\t\treturn audit_uid_comparator(cred->uid, f->op, cred->euid);\r\n\tcase AUDIT_COMPARE_UID_TO_SUID:\r\n\t\treturn audit_uid_comparator(cred->uid, f->op, cred->suid);\r\n\tcase AUDIT_COMPARE_UID_TO_FSUID:\r\n\t\treturn audit_uid_comparator(cred->uid, f->op, cred->fsuid);\r\n\t/* auid comparisons */\r\n\tcase AUDIT_COMPARE_AUID_TO_EUID:\r\n\t\treturn audit_uid_comparator(audit_get_loginuid(tsk), f->op,\r\n\t\t\t\t\t    cred->euid);\r\n\tcase AUDIT_COMPARE_AUID_TO_SUID:\r\n\t\treturn audit_uid_comparator(audit_get_loginuid(tsk), f->op,\r\n\t\t\t\t\t    cred->suid);\r\n\tcase AUDIT_COMPARE_AUID_TO_FSUID:\r\n\t\treturn audit_uid_comparator(audit_get_loginuid(tsk), f->op,\r\n\t\t\t\t\t    cred->fsuid);\r\n\t/* euid comparisons */\r\n\tcase AUDIT_COMPARE_EUID_TO_SUID:\r\n\t\treturn audit_uid_comparator(cred->euid, f->op, cred->suid);\r\n\tcase AUDIT_COMPARE_EUID_TO_FSUID:\r\n\t\treturn audit_uid_comparator(cred->euid, f->op, cred->fsuid);\r\n\t/* suid comparisons */\r\n\tcase AUDIT_COMPARE_SUID_TO_FSUID:\r\n\t\treturn audit_uid_comparator(cred->suid, f->op, cred->fsuid);\r\n\t/* gid comparisons */\r\n\tcase AUDIT_COMPARE_GID_TO_EGID:\r\n\t\treturn audit_gid_comparator(cred->gid, f->op, cred->egid);\r\n\tcase AUDIT_COMPARE_GID_TO_SGID:\r\n\t\treturn audit_gid_comparator(cred->gid, f->op, cred->sgid);\r\n\tcase AUDIT_COMPARE_GID_TO_FSGID:\r\n\t\treturn audit_gid_comparator(cred->gid, f->op, cred->fsgid);\r\n\t/* egid comparisons */\r\n\tcase AUDIT_COMPARE_EGID_TO_SGID:\r\n\t\treturn audit_gid_comparator(cred->egid, f->op, cred->sgid);\r\n\tcase AUDIT_COMPARE_EGID_TO_FSGID:\r\n\t\treturn audit_gid_comparator(cred->egid, f->op, cred->fsgid);\r\n\t/* sgid comparison */\r\n\tcase AUDIT_COMPARE_SGID_TO_FSGID:\r\n\t\treturn audit_gid_comparator(cred->sgid, f->op, cred->fsgid);\r\n\tdefault:\r\n\t\tWARN(1, \"Missing AUDIT_COMPARE define.  Report as a bug\\n\");\r\n\t\treturn 0;\r\n\t}\r\n\treturn 0;\r\n}", ".udit_filter_rules": "static int audit_filter_rules(struct task_struct *tsk,\r\n\t\t\t      struct audit_krule *rule,\r\n\t\t\t      struct audit_context *ctx,\r\n\t\t\t      struct audit_names *name,\r\n\t\t\t      enum audit_state *state,\r\n\t\t\t      bool task_creation)\r\n{\r\n\tconst struct cred *cred;\r\n\tint i, need_sid = 1;\r\n\tstruct lsm_prop prop = { };\r\n\tunsigned int sessionid;\r\n\r\n\tif (ctx && rule->prio <= ctx->prio)\r\n\t\treturn 0;\r\n\r\n\tcred = rcu_dereference_check(tsk->cred, tsk == current || task_creation);\r\n\r\n\tfor (i = 0; i < rule->field_count; i++) {\r\n\t\tstruct audit_field *f = &rule->fields[i];\r\n\t\tstruct audit_names *n;\r\n\t\tint result = 0;\r\n\t\tpid_t pid;\r\n\r\n\t\tswitch (f->type) {\r\n\t\tcase AUDIT_PID:\r\n\t\t\tpid = task_tgid_nr(tsk);\r\n\t\t\tresult = audit_comparator(pid, f->op, f->val);\r\n\t\t\tbreak;\r\n\t\tcase AUDIT_PPID:\r\n\t\t\tif (ctx) {\r\n\t\t\t\tif (!ctx->ppid)\r\n\t\t\t\t\tctx->ppid = task_ppid_nr(tsk);\r\n\t\t\t\tresult = audit_comparator(ctx->ppid, f->op, f->val);\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\tcase AUDIT_EXE:\r\n\t\t\tresult = audit_exe_compare(tsk, rule->exe);\r\n\t\t\tif (f->op == Audit_not_equal)\r\n\t\t\t\tresult = !result;\r\n\t\t\tbreak;\r\n\t\tcase AUDIT_UID:\r\n\t\t\tresult = audit_uid_comparator(cred->uid, f->op, f->uid);\r\n\t\t\tbreak;\r\n\t\tcase AUDIT_EUID:\r\n\t\t\tresult = audit_uid_comparator(cred->euid, f->op, f->uid);\r\n\t\t\tbreak;\r\n\t\tcase AUDIT_SUID:\r\n\t\t\tresult = audit_uid_comparator(cred->suid, f->op, f->uid);\r\n\t\t\tbreak;\r\n\t\tcase AUDIT_FSUID:\r\n\t\t\tresult = audit_uid_comparator(cred->fsuid, f->op, f->uid);\r\n\t\t\tbreak;\r\n\t\tcase AUDIT_GID:\r\n\t\t\tresult = audit_gid_comparator(cred->gid, f->op, f->gid);\r\n\t\t\tif (f->op == Audit_equal) {\r\n\t\t\t\tif (!result)\r\n\t\t\t\t\tresult = groups_search(cred->group_info, f->gid);\r\n\t\t\t} else if (f->op == Audit_not_equal) {\r\n\t\t\t\tif (result)\r\n\t\t\t\t\tresult = !groups_search(cred->group_info, f->gid);\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\tcase AUDIT_EGID:\r\n\t\t\tresult = audit_gid_comparator(cred->egid, f->op, f->gid);\r\n\t\t\tif (f->op == Audit_equal) {\r\n\t\t\t\tif (!result)\r\n\t\t\t\t\tresult = groups_search(cred->group_info, f->gid);\r\n\t\t\t} else if (f->op == Audit_not_equal) {\r\n\t\t\t\tif (result)\r\n\t\t\t\t\tresult = !groups_search(cred->group_info, f->gid);\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\tcase AUDIT_SGID:\r\n\t\t\tresult = audit_gid_comparator(cred->sgid, f->op, f->gid);\r\n\t\t\tbreak;\r\n\t\tcase AUDIT_FSGID:\r\n\t\t\tresult = audit_gid_comparator(cred->fsgid, f->op, f->gid);\r\n\t\t\tbreak;\r\n\t\tcase AUDIT_SESSIONID:\r\n\t\t\tsessionid = audit_get_sessionid(tsk);\r\n\t\t\tresult = audit_comparator(sessionid, f->op, f->val);\r\n\t\t\tbreak;\r\n\t\tcase AUDIT_PERS:\r\n\t\t\tresult = audit_comparator(tsk->personality, f->op, f->val);\r\n\t\t\tbreak;\r\n\t\tcase AUDIT_ARCH:\r\n\t\t\tif (ctx)\r\n\t\t\t\tresult = audit_comparator(ctx->arch, f->op, f->val);\r\n\t\t\tbreak;\r\n\r\n\t\tcase AUDIT_EXIT:\r\n\t\t\tif (ctx && ctx->return_valid != AUDITSC_INVALID)\r\n\t\t\t\tresult = audit_comparator(ctx->return_code, f->op, f->val);\r\n\t\t\tbreak;\r\n\t\tcase AUDIT_SUCCESS:\r\n\t\t\tif (ctx && ctx->return_valid != AUDITSC_INVALID) {\r\n\t\t\t\tif (f->val)\r\n\t\t\t\t\tresult = audit_comparator(ctx->return_valid, f->op, AUDITSC_SUCCESS);\r\n\t\t\t\telse\r\n\t\t\t\t\tresult = audit_comparator(ctx->return_valid, f->op, AUDITSC_FAILURE);\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\tcase AUDIT_DEVMAJOR:\r\n\t\t\tif (name) {\r\n\t\t\t\tif (audit_comparator(MAJOR(name->dev), f->op, f->val) ||\r\n\t\t\t\t    audit_comparator(MAJOR(name->rdev), f->op, f->val))\r\n\t\t\t\t\t++result;\r\n\t\t\t} else if (ctx) {\r\n\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\r\n\t\t\t\t\tif (audit_comparator(MAJOR(n->dev), f->op, f->val) ||\r\n\t\t\t\t\t    audit_comparator(MAJOR(n->rdev), f->op, f->val)) {\r\n\t\t\t\t\t\t++result;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\tcase AUDIT_DEVMINOR:\r\n\t\t\tif (name) {\r\n\t\t\t\tif (audit_comparator(MINOR(name->dev), f->op, f->val) ||\r\n\t\t\t\t    audit_comparator(MINOR(name->rdev), f->op, f->val))\r\n\t\t\t\t\t++result;\r\n\t\t\t} else if (ctx) {\r\n\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\r\n\t\t\t\t\tif (audit_comparator(MINOR(n->dev), f->op, f->val) ||\r\n\t\t\t\t\t    audit_comparator(MINOR(n->rdev), f->op, f->val)) {\r\n\t\t\t\t\t\t++result;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\tcase AUDIT_INODE:\r\n\t\t\tif (name)\r\n\t\t\t\tresult = audit_comparator(name->ino, f->op, f->val);\r\n\t\t\telse if (ctx) {\r\n\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\r\n\t\t\t\t\tif (audit_comparator(n->ino, f->op, f->val)) {\r\n\t\t\t\t\t\t++result;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\tcase AUDIT_OBJ_UID:\r\n\t\t\tif (name) {\r\n\t\t\t\tresult = audit_uid_comparator(name->uid, f->op, f->uid);\r\n\t\t\t} else if (ctx) {\r\n\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\r\n\t\t\t\t\tif (audit_uid_comparator(n->uid, f->op, f->uid)) {\r\n\t\t\t\t\t\t++result;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\tcase AUDIT_OBJ_GID:\r\n\t\t\tif (name) {\r\n\t\t\t\tresult = audit_gid_comparator(name->gid, f->op, f->gid);\r\n\t\t\t} else if (ctx) {\r\n\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\r\n\t\t\t\t\tif (audit_gid_comparator(n->gid, f->op, f->gid)) {\r\n\t\t\t\t\t\t++result;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\tcase AUDIT_WATCH:\r\n\t\t\tif (name) {\r\n\t\t\t\tresult = audit_watch_compare(rule->watch,\r\n\t\t\t\t\t\t\t     name->ino,\r\n\t\t\t\t\t\t\t     name->dev);\r\n\t\t\t\tif (f->op == Audit_not_equal)\r\n\t\t\t\t\tresult = !result;\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\tcase AUDIT_DIR:\r\n\t\t\tif (ctx) {\r\n\t\t\t\tresult = match_tree_refs(ctx, rule->tree);\r\n\t\t\t\tif (f->op == Audit_not_equal)\r\n\t\t\t\t\tresult = !result;\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\tcase AUDIT_LOGINUID:\r\n\t\t\tresult = audit_uid_comparator(audit_get_loginuid(tsk),\r\n\t\t\t\t\t\t      f->op, f->uid);\r\n\t\t\tbreak;\r\n\t\tcase AUDIT_LOGINUID_SET:\r\n\t\t\tresult = audit_comparator(audit_loginuid_set(tsk), f->op, f->val);\r\n\t\t\tbreak;\r\n\t\tcase AUDIT_SADDR_FAM:\r\n\t\t\tif (ctx && ctx->sockaddr)\r\n\t\t\t\tresult = audit_comparator(ctx->sockaddr->ss_family,\r\n\t\t\t\t\t\t\t  f->op, f->val);\r\n\t\t\tbreak;\r\n\t\tcase AUDIT_SUBJ_USER:\r\n\t\tcase AUDIT_SUBJ_ROLE:\r\n\t\tcase AUDIT_SUBJ_TYPE:\r\n\t\tcase AUDIT_SUBJ_SEN:\r\n\t\tcase AUDIT_SUBJ_CLR:\r\n\t\t\t/* NOTE: this may return negative values indicating\r\n\t\t\t   a temporary error.  We simply treat this as a\r\n\t\t\t   match for now to avoid losing information that\r\n\t\t\t   may be wanted.   An error message will also be\r\n\t\t\t   logged upon error */\r\n\t\t\tif (f->lsm_rule) {\r\n\t\t\t\tif (need_sid) {\r\n\t\t\t\t\t/* @tsk should always be equal to\r\n\t\t\t\t\t * @current with the exception of\r\n\t\t\t\t\t * fork()/copy_process() in which case\r\n\t\t\t\t\t * the new @tsk creds are still a dup\r\n\t\t\t\t\t * of @current's creds so we can still\r\n\t\t\t\t\t * use\r\n\t\t\t\t\t * security_current_getlsmprop_subj()\r\n\t\t\t\t\t * here even though it always refs\r\n\t\t\t\t\t * @current's creds\r\n\t\t\t\t\t */\r\n\t\t\t\t\tsecurity_current_getlsmprop_subj(&prop);\r\n\t\t\t\t\tneed_sid = 0;\r\n\t\t\t\t}\r\n\t\t\t\tresult = security_audit_rule_match(&prop,\r\n\t\t\t\t\t\t\t\t   f->type,\r\n\t\t\t\t\t\t\t\t   f->op,\r\n\t\t\t\t\t\t\t\t   f->lsm_rule);\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\tcase AUDIT_OBJ_USER:\r\n\t\tcase AUDIT_OBJ_ROLE:\r\n\t\tcase AUDIT_OBJ_TYPE:\r\n\t\tcase AUDIT_OBJ_LEV_LOW:\r\n\t\tcase AUDIT_OBJ_LEV_HIGH:\r\n\t\t\t/* The above note for AUDIT_SUBJ_USER...AUDIT_SUBJ_CLR\r\n\t\t\t   also applies here */\r\n\t\t\tif (f->lsm_rule) {\r\n\t\t\t\t/* Find files that match */\r\n\t\t\t\tif (name) {\r\n\t\t\t\t\tresult = security_audit_rule_match(\r\n\t\t\t\t\t\t\t\t&name->oprop,\r\n\t\t\t\t\t\t\t\tf->type,\r\n\t\t\t\t\t\t\t\tf->op,\r\n\t\t\t\t\t\t\t\tf->lsm_rule);\r\n\t\t\t\t} else if (ctx) {\r\n\t\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\r\n\t\t\t\t\t\tif (security_audit_rule_match(\r\n\t\t\t\t\t\t\t\t&n->oprop,\r\n\t\t\t\t\t\t\t\tf->type,\r\n\t\t\t\t\t\t\t\tf->op,\r\n\t\t\t\t\t\t\t\tf->lsm_rule)) {\r\n\t\t\t\t\t\t\t++result;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t/* Find ipc objects that match */\r\n\t\t\t\tif (!ctx || ctx->type != AUDIT_IPC)\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tif (security_audit_rule_match(&ctx->ipc.oprop,\r\n\t\t\t\t\t\t\t      f->type, f->op,\r\n\t\t\t\t\t\t\t      f->lsm_rule))\r\n\t\t\t\t\t++result;\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\tcase AUDIT_ARG0:\r\n\t\tcase AUDIT_ARG1:\r\n\t\tcase AUDIT_ARG2:\r\n\t\tcase AUDIT_ARG3:\r\n\t\t\tif (ctx)\r\n\t\t\t\tresult = audit_comparator(ctx->argv[f->type-AUDIT_ARG0], f->op, f->val);\r\n\t\t\tbreak;\r\n\t\tcase AUDIT_FILTERKEY:\r\n\t\t\t/* ignore this field for filtering */\r\n\t\t\tresult = 1;\r\n\t\t\tbreak;\r\n\t\tcase AUDIT_PERM:\r\n\t\t\tresult = audit_match_perm(ctx, f->val);\r\n\t\t\tif (f->op == Audit_not_equal)\r\n\t\t\t\tresult = !result;\r\n\t\t\tbreak;\r\n\t\tcase AUDIT_FILETYPE:\r\n\t\t\tresult = audit_match_filetype(ctx, f->val);\r\n\t\t\tif (f->op == Audit_not_equal)\r\n\t\t\t\tresult = !result;\r\n\t\t\tbreak;\r\n\t\tcase AUDIT_FIELD_COMPARE:\r\n\t\t\tresult = audit_field_compare(tsk, cred, f, ctx, name);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tif (!result)\r\n\t\t\treturn 0;\r\n\t}\r\n\r\n\tif (ctx) {\r\n\t\tif (rule->filterkey) {\r\n\t\t\tkfree(ctx->filterkey);\r\n\t\t\tctx->filterkey = kstrdup(rule->filterkey, GFP_ATOMIC);\r\n\t\t}\r\n\t\tctx->prio = rule->prio;\r\n\t}\r\n\tswitch (rule->action) {\r\n\tcase AUDIT_NEVER:\r\n\t\t*state = AUDIT_STATE_DISABLED;\r\n\t\tbreak;\r\n\tcase AUDIT_ALWAYS:\r\n\t\t*state = AUDIT_STATE_RECORD;\r\n\t\tbreak;\r\n\t}\r\n\treturn 1;\r\n}", ".udit_filter_inode_name": "static int audit_filter_inode_name(struct task_struct *tsk,\r\n\t\t\t\t   struct audit_names *n,\r\n\t\t\t\t   struct audit_context *ctx)\r\n{\r\n\tint h = audit_hash_ino((u32)n->ino);\r\n\tstruct list_head *list = &audit_inode_hash[h];\r\n\r\n\treturn __audit_filter_op(tsk, ctx, list, n, ctx->major);\r\n}", ".udit_free_names": "static inline void audit_free_names(struct audit_context *context)\r\n{\r\n\tstruct audit_names *n, *next;\r\n\r\n\tlist_for_each_entry_safe(n, next, &context->names_list, list) {\r\n\t\tlist_del(&n->list);\r\n\t\tif (n->name)\r\n\t\t\tputname(n->name);\r\n\t\tif (n->should_free)\r\n\t\t\tkfree(n);\r\n\t}\r\n\tcontext->name_count = 0;\r\n\tpath_put(&context->pwd);\r\n\tcontext->pwd.dentry = NULL;\r\n\tcontext->pwd.mnt = NULL;\r\n}", ".udit_free_aux": "static inline void audit_free_aux(struct audit_context *context)\r\n{\r\n\tstruct audit_aux_data *aux;\r\n\r\n\twhile ((aux = context->aux)) {\r\n\t\tcontext->aux = aux->next;\r\n\t\tkfree(aux);\r\n\t}\r\n\tcontext->aux = NULL;\r\n\twhile ((aux = context->aux_pids)) {\r\n\t\tcontext->aux_pids = aux->next;\r\n\t\tkfree(aux);\r\n\t}\r\n\tcontext->aux_pids = NULL;\r\n}", ".nroll_tree_refs": "static void unroll_tree_refs(struct audit_context *ctx,\r\n\t\t      struct audit_tree_refs *p, int count)\r\n{\r\n\tstruct audit_tree_refs *q;\r\n\tint n;\r\n\r\n\tif (!p) {\r\n\t\t/* we started with empty chain */\r\n\t\tp = ctx->first_trees;\r\n\t\tcount = 31;\r\n\t\t/* if the very first allocation has failed, nothing to do */\r\n\t\tif (!p)\r\n\t\t\treturn;\r\n\t}\r\n\tn = count;\r\n\tfor (q = p; q != ctx->trees; q = q->next, n = 31) {\r\n\t\twhile (n--) {\r\n\t\t\taudit_put_chunk(q->c[n]);\r\n\t\t\tq->c[n] = NULL;\r\n\t\t}\r\n\t}\r\n\twhile (n-- > ctx->tree_count) {\r\n\t\taudit_put_chunk(q->c[n]);\r\n\t\tq->c[n] = NULL;\r\n\t}\r\n\tctx->trees = p;\r\n\tctx->tree_count = count;\r\n}", ".udit_free_module": "static inline void audit_free_module(struct audit_context *context)\r\n{\r\n\tif (context->type == AUDIT_KERN_MODULE) {\r\n\t\tkfree(context->module.name);\r\n\t\tcontext->module.name = NULL;\r\n\t}\r\n}", ".udit_filter_task": "static enum audit_state audit_filter_task(struct task_struct *tsk, char **key)\r\n{\r\n\tstruct audit_entry *e;\r\n\tenum audit_state   state;\r\n\r\n\trcu_read_lock();\r\n\tlist_for_each_entry_rcu(e, &audit_filter_list[AUDIT_FILTER_TASK], list) {\r\n\t\tif (audit_filter_rules(tsk, &e->rule, NULL, NULL,\r\n\t\t\t\t       &state, true)) {\r\n\t\t\tif (state == AUDIT_STATE_RECORD)\r\n\t\t\t\t*key = kstrdup(e->rule.filterkey, GFP_ATOMIC);\r\n\t\t\trcu_read_unlock();\r\n\t\t\treturn state;\r\n\t\t}\r\n\t}\r\n\trcu_read_unlock();\r\n\treturn AUDIT_STATE_BUILD;\r\n}", ".udit_reset_context": "static void audit_reset_context(struct audit_context *ctx)\r\n{\r\n\tif (!ctx)\r\n\t\treturn;\r\n\r\n\t/* if ctx is non-null, reset the \"ctx->context\" regardless */\r\n\tctx->context = AUDIT_CTX_UNUSED;\r\n\tif (ctx->dummy)\r\n\t\treturn;\r\n\r\n\t/*\r\n\t * NOTE: It shouldn't matter in what order we release the fields, so\r\n\t *       release them in the order in which they appear in the struct;\r\n\t *       this gives us some hope of quickly making sure we are\r\n\t *       resetting the audit_context properly.\r\n\t *\r\n\t *       Other things worth mentioning:\r\n\t *       - we don't reset \"dummy\"\r\n\t *       - we don't reset \"state\", we do reset \"current_state\"\r\n\t *       - we preserve \"filterkey\" if \"state\" is AUDIT_STATE_RECORD\r\n\t *       - much of this is likely overkill, but play it safe for now\r\n\t *       - we really need to work on improving the audit_context struct\r\n\t */\r\n\r\n\tctx->current_state = ctx->state;\r\n\tctx->stamp.serial = 0;\r\n\tctx->stamp.ctime = (struct timespec64){ .tv_sec = 0, .tv_nsec = 0 };\r\n\tctx->major = 0;\r\n\tctx->uring_op = 0;\r\n\tmemset(ctx->argv, 0, sizeof(ctx->argv));\r\n\tctx->return_code = 0;\r\n\tctx->prio = (ctx->state == AUDIT_STATE_RECORD ? ~0ULL : 0);\r\n\tctx->return_valid = AUDITSC_INVALID;\r\n\taudit_free_names(ctx);\r\n\tif (ctx->state != AUDIT_STATE_RECORD) {\r\n\t\tkfree(ctx->filterkey);\r\n\t\tctx->filterkey = NULL;\r\n\t}\r\n\taudit_free_aux(ctx);\r\n\tkfree(ctx->sockaddr);\r\n\tctx->sockaddr = NULL;\r\n\tctx->sockaddr_len = 0;\r\n\tctx->ppid = 0;\r\n\tctx->uid = ctx->euid = ctx->suid = ctx->fsuid = KUIDT_INIT(0);\r\n\tctx->gid = ctx->egid = ctx->sgid = ctx->fsgid = KGIDT_INIT(0);\r\n\tctx->personality = 0;\r\n\tctx->arch = 0;\r\n\tctx->target_pid = 0;\r\n\tctx->target_auid = ctx->target_uid = KUIDT_INIT(0);\r\n\tctx->target_sessionid = 0;\r\n\tlsmprop_init(&ctx->target_ref);\r\n\tctx->target_comm[0] = '\\0';\r\n\tunroll_tree_refs(ctx, NULL, 0);\r\n\tWARN_ON(!list_empty(&ctx->killed_trees));\r\n\taudit_free_module(ctx);\r\n\tctx->fds[0] = -1;\r\n\tctx->type = 0; /* reset last for audit_free_*() */\r\n}", ".udit_proctitle_free": "static inline void audit_proctitle_free(struct audit_context *context)\r\n{\r\n\tkfree(context->proctitle.value);\r\n\tcontext->proctitle.value = NULL;\r\n\tcontext->proctitle.len = 0;\r\n}", ".ree_tree_refs": "static void free_tree_refs(struct audit_context *ctx)\r\n{\r\n\tstruct audit_tree_refs *p, *q;\r\n\r\n\tfor (p = ctx->first_trees; p; p = q) {\r\n\t\tq = p->next;\r\n\t\tkfree(p);\r\n\t}\r\n}", ".udit_log_cap": "static void audit_log_cap(struct audit_buffer *ab, char *prefix,\r\n\t\t\t  kernel_cap_t *cap)\r\n{\r\n\tif (cap_isclear(*cap)) {\r\n\t\taudit_log_format(ab, \" %s=0\", prefix);\r\n\t\treturn;\r\n\t}\r\n\taudit_log_format(ab, \" %s=%016llx\", prefix, cap->val);\r\n}", ".udit_log_execve_info": "static void audit_log_execve_info(struct audit_context *context,\r\n\t\t\t\t  struct audit_buffer **ab)\r\n{\r\n\tlong len_max;\r\n\tlong len_rem;\r\n\tlong len_full;\r\n\tlong len_buf;\r\n\tlong len_abuf = 0;\r\n\tlong len_tmp;\r\n\tbool require_data;\r\n\tbool encode;\r\n\tunsigned int iter;\r\n\tunsigned int arg;\r\n\tchar *buf_head;\r\n\tchar *buf;\r\n\tconst char __user *p = (const char __user *)current->mm->arg_start;\r\n\r\n\t/* NOTE: this buffer needs to be large enough to hold all the non-arg\r\n\t *       data we put in the audit record for this argument (see the\r\n\t *       code below) ... at this point in time 96 is plenty */\r\n\tchar abuf[96];\r\n\r\n\t/* NOTE: we set MAX_EXECVE_AUDIT_LEN to a rather arbitrary limit, the\r\n\t *       current value of 7500 is not as important as the fact that it\r\n\t *       is less than 8k, a setting of 7500 gives us plenty of wiggle\r\n\t *       room if we go over a little bit in the logging below */\r\n\tWARN_ON_ONCE(MAX_EXECVE_AUDIT_LEN > 7500);\r\n\tlen_max = MAX_EXECVE_AUDIT_LEN;\r\n\r\n\t/* scratch buffer to hold the userspace args */\r\n\tbuf_head = kmalloc(MAX_EXECVE_AUDIT_LEN + 1, GFP_KERNEL);\r\n\tif (!buf_head) {\r\n\t\taudit_panic(\"out of memory for argv string\");\r\n\t\treturn;\r\n\t}\r\n\tbuf = buf_head;\r\n\r\n\taudit_log_format(*ab, \"argc=%d\", context->execve.argc);\r\n\r\n\tlen_rem = len_max;\r\n\tlen_buf = 0;\r\n\tlen_full = 0;\r\n\trequire_data = true;\r\n\tencode = false;\r\n\titer = 0;\r\n\targ = 0;\r\n\tdo {\r\n\t\t/* NOTE: we don't ever want to trust this value for anything\r\n\t\t *       serious, but the audit record format insists we\r\n\t\t *       provide an argument length for really long arguments,\r\n\t\t *       e.g. > MAX_EXECVE_AUDIT_LEN, so we have no choice but\r\n\t\t *       to use strncpy_from_user() to obtain this value for\r\n\t\t *       recording in the log, although we don't use it\r\n\t\t *       anywhere here to avoid a double-fetch problem */\r\n\t\tif (len_full == 0)\r\n\t\t\tlen_full = strnlen_user(p, MAX_ARG_STRLEN) - 1;\r\n\r\n\t\t/* read more data from userspace */\r\n\t\tif (require_data) {\r\n\t\t\t/* can we make more room in the buffer? */\r\n\t\t\tif (buf != buf_head) {\r\n\t\t\t\tmemmove(buf_head, buf, len_buf);\r\n\t\t\t\tbuf = buf_head;\r\n\t\t\t}\r\n\r\n\t\t\t/* fetch as much as we can of the argument */\r\n\t\t\tlen_tmp = strncpy_from_user(&buf_head[len_buf], p,\r\n\t\t\t\t\t\t    len_max - len_buf);\r\n\t\t\tif (len_tmp == -EFAULT) {\r\n\t\t\t\t/* unable to copy from userspace */\r\n\t\t\t\tsend_sig(SIGKILL, current, 0);\r\n\t\t\t\tgoto out;\r\n\t\t\t} else if (len_tmp == (len_max - len_buf)) {\r\n\t\t\t\t/* buffer is not large enough */\r\n\t\t\t\trequire_data = true;\r\n\t\t\t\t/* NOTE: if we are going to span multiple\r\n\t\t\t\t *       buffers force the encoding so we stand\r\n\t\t\t\t *       a chance at a sane len_full value and\r\n\t\t\t\t *       consistent record encoding */\r\n\t\t\t\tencode = true;\r\n\t\t\t\tlen_full = len_full * 2;\r\n\t\t\t\tp += len_tmp;\r\n\t\t\t} else {\r\n\t\t\t\trequire_data = false;\r\n\t\t\t\tif (!encode)\r\n\t\t\t\t\tencode = audit_string_contains_control(\r\n\t\t\t\t\t\t\t\tbuf, len_tmp);\r\n\t\t\t\t/* try to use a trusted value for len_full */\r\n\t\t\t\tif (len_full < len_max)\r\n\t\t\t\t\tlen_full = (encode ?\r\n\t\t\t\t\t\t    len_tmp * 2 : len_tmp);\r\n\t\t\t\tp += len_tmp + 1;\r\n\t\t\t}\r\n\t\t\tlen_buf += len_tmp;\r\n\t\t\tbuf_head[len_buf] = '\\0';\r\n\r\n\t\t\t/* length of the buffer in the audit record? */\r\n\t\t\tlen_abuf = (encode ? len_buf * 2 : len_buf + 2);\r\n\t\t}\r\n\r\n\t\t/* write as much as we can to the audit log */\r\n\t\tif (len_buf >= 0) {\r\n\t\t\t/* NOTE: some magic numbers here - basically if we\r\n\t\t\t *       can't fit a reasonable amount of data into the\r\n\t\t\t *       existing audit buffer, flush it and start with\r\n\t\t\t *       a new buffer */\r\n\t\t\tif ((sizeof(abuf) + 8) > len_rem) {\r\n\t\t\t\tlen_rem = len_max;\r\n\t\t\t\taudit_log_end(*ab);\r\n\t\t\t\t*ab = audit_log_start(context,\r\n\t\t\t\t\t\t      GFP_KERNEL, AUDIT_EXECVE);\r\n\t\t\t\tif (!*ab)\r\n\t\t\t\t\tgoto out;\r\n\t\t\t}\r\n\r\n\t\t\t/* create the non-arg portion of the arg record */\r\n\t\t\tlen_tmp = 0;\r\n\t\t\tif (require_data || (iter > 0) ||\r\n\t\t\t    ((len_abuf + sizeof(abuf)) > len_rem)) {\r\n\t\t\t\tif (iter == 0) {\r\n\t\t\t\t\tlen_tmp += snprintf(&abuf[len_tmp],\r\n\t\t\t\t\t\t\tsizeof(abuf) - len_tmp,\r\n\t\t\t\t\t\t\t\" a%d_len=%lu\",\r\n\t\t\t\t\t\t\targ, len_full);\r\n\t\t\t\t}\r\n\t\t\t\tlen_tmp += snprintf(&abuf[len_tmp],\r\n\t\t\t\t\t\t    sizeof(abuf) - len_tmp,\r\n\t\t\t\t\t\t    \" a%d[%d]=\", arg, iter++);\r\n\t\t\t} else\r\n\t\t\t\tlen_tmp += snprintf(&abuf[len_tmp],\r\n\t\t\t\t\t\t    sizeof(abuf) - len_tmp,\r\n\t\t\t\t\t\t    \" a%d=\", arg);\r\n\t\t\tWARN_ON(len_tmp >= sizeof(abuf));\r\n\t\t\tabuf[sizeof(abuf) - 1] = '\\0';\r\n\r\n\t\t\t/* log the arg in the audit record */\r\n\t\t\taudit_log_format(*ab, \"%s\", abuf);\r\n\t\t\tlen_rem -= len_tmp;\r\n\t\t\tlen_tmp = len_buf;\r\n\t\t\tif (encode) {\r\n\t\t\t\tif (len_abuf > len_rem)\r\n\t\t\t\t\tlen_tmp = len_rem / 2; /* encoding */\r\n\t\t\t\taudit_log_n_hex(*ab, buf, len_tmp);\r\n\t\t\t\tlen_rem -= len_tmp * 2;\r\n\t\t\t\tlen_abuf -= len_tmp * 2;\r\n\t\t\t} else {\r\n\t\t\t\tif (len_abuf > len_rem)\r\n\t\t\t\t\tlen_tmp = len_rem - 2; /* quotes */\r\n\t\t\t\taudit_log_n_string(*ab, buf, len_tmp);\r\n\t\t\t\tlen_rem -= len_tmp + 2;\r\n\t\t\t\t/* don't subtract the \"2\" because we still need\r\n\t\t\t\t * to add quotes to the remaining string */\r\n\t\t\t\tlen_abuf -= len_tmp;\r\n\t\t\t}\r\n\t\t\tlen_buf -= len_tmp;\r\n\t\t\tbuf += len_tmp;\r\n\t\t}\r\n\r\n\t\t/* ready to move to the next argument? */\r\n\t\tif ((len_buf == 0) && !require_data) {\r\n\t\t\targ++;\r\n\t\t\titer = 0;\r\n\t\t\tlen_full = 0;\r\n\t\t\trequire_data = true;\r\n\t\t\tencode = false;\r\n\t\t}\r\n\t} while (arg < context->execve.argc);\r\n\r\n\t/* NOTE: the caller handles the final audit_log_end() call */\r\n\r\nout:\r\n\tkfree(buf_head);\r\n}", ".udit_log_time": "static void audit_log_time(struct audit_context *context, struct audit_buffer **ab)\r\n{\r\n\tconst struct audit_ntp_data *ntp = &context->time.ntp_data;\r\n\tconst struct timespec64 *tk = &context->time.tk_injoffset;\r\n\tstatic const char * const ntp_name[] = {\r\n\t\t\"offset\",\r\n\t\t\"freq\",\r\n\t\t\"status\",\r\n\t\t\"tai\",\r\n\t\t\"tick\",\r\n\t\t\"adjust\",\r\n\t};\r\n\tint type;\r\n\r\n\tif (context->type == AUDIT_TIME_ADJNTPVAL) {\r\n\t\tfor (type = 0; type < AUDIT_NTP_NVALS; type++) {\r\n\t\t\tif (ntp->vals[type].newval != ntp->vals[type].oldval) {\r\n\t\t\t\tif (!*ab) {\r\n\t\t\t\t\t*ab = audit_log_start(context,\r\n\t\t\t\t\t\t\tGFP_KERNEL,\r\n\t\t\t\t\t\t\tAUDIT_TIME_ADJNTPVAL);\r\n\t\t\t\t\tif (!*ab)\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\taudit_log_format(*ab, \"op=%s old=%lli new=%lli\",\r\n\t\t\t\t\t\t ntp_name[type],\r\n\t\t\t\t\t\t ntp->vals[type].oldval,\r\n\t\t\t\t\t\t ntp->vals[type].newval);\r\n\t\t\t\taudit_log_end(*ab);\r\n\t\t\t\t*ab = NULL;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tif (tk->tv_sec != 0 || tk->tv_nsec != 0) {\r\n\t\tif (!*ab) {\r\n\t\t\t*ab = audit_log_start(context, GFP_KERNEL,\r\n\t\t\t\t\t      AUDIT_TIME_INJOFFSET);\r\n\t\t\tif (!*ab)\r\n\t\t\t\treturn;\r\n\t\t}\r\n\t\taudit_log_format(*ab, \"sec=%lli nsec=%li\",\r\n\t\t\t\t (long long)tk->tv_sec, tk->tv_nsec);\r\n\t\taudit_log_end(*ab);\r\n\t\t*ab = NULL;\r\n\t}\r\n}", ".udit_log_fcaps": "static void audit_log_fcaps(struct audit_buffer *ab, struct audit_names *name)\r\n{\r\n\tif (name->fcap_ver == -1) {\r\n\t\taudit_log_format(ab, \" cap_fe=? cap_fver=? cap_fp=? cap_fi=?\");\r\n\t\treturn;\r\n\t}\r\n\taudit_log_cap(ab, \"cap_fp\", &name->fcap.permitted);\r\n\taudit_log_cap(ab, \"cap_fi\", &name->fcap.inheritable);\r\n\taudit_log_format(ab, \" cap_fe=%d cap_fver=%x cap_frootid=%d\",\r\n\t\t\t name->fcap.fE, name->fcap_ver,\r\n\t\t\t from_kuid(&init_user_ns, name->fcap.rootid));\r\n}", ".udit_proctitle_rtrim": "static inline int audit_proctitle_rtrim(char *proctitle, int len)\r\n{\r\n\tchar *end = proctitle + len - 1;\r\n\r\n\twhile (end > proctitle && !isprint(*end))\r\n\t\tend--;\r\n\r\n\t/* catch the case where proctitle is only 1 non-print character */\r\n\tlen = end - proctitle + 1;\r\n\tlen -= isprint(proctitle[len-1]) == 0;\r\n\treturn len;\r\n}", ".udit_log_uring": "static void audit_log_uring(struct audit_context *ctx)\r\n{\r\n\tstruct audit_buffer *ab;\r\n\tconst struct cred *cred;\r\n\r\n\tab = audit_log_start(ctx, GFP_ATOMIC, AUDIT_URINGOP);\r\n\tif (!ab)\r\n\t\treturn;\r\n\tcred = current_cred();\r\n\taudit_log_format(ab, \"uring_op=%d\", ctx->uring_op);\r\n\tif (ctx->return_valid != AUDITSC_INVALID)\r\n\t\taudit_log_format(ab, \" success=%s exit=%ld\",\r\n\t\t\t\t str_yes_no(ctx->return_valid ==\r\n\t\t\t\t\t    AUDITSC_SUCCESS),\r\n\t\t\t\t ctx->return_code);\r\n\taudit_log_format(ab,\r\n\t\t\t \" items=%d\"\r\n\t\t\t \" ppid=%d pid=%d uid=%u gid=%u euid=%u suid=%u\"\r\n\t\t\t \" fsuid=%u egid=%u sgid=%u fsgid=%u\",\r\n\t\t\t ctx->name_count,\r\n\t\t\t task_ppid_nr(current), task_tgid_nr(current),\r\n\t\t\t from_kuid(&init_user_ns, cred->uid),\r\n\t\t\t from_kgid(&init_user_ns, cred->gid),\r\n\t\t\t from_kuid(&init_user_ns, cred->euid),\r\n\t\t\t from_kuid(&init_user_ns, cred->suid),\r\n\t\t\t from_kuid(&init_user_ns, cred->fsuid),\r\n\t\t\t from_kgid(&init_user_ns, cred->egid),\r\n\t\t\t from_kgid(&init_user_ns, cred->sgid),\r\n\t\t\t from_kgid(&init_user_ns, cred->fsgid));\r\n\taudit_log_task_context(ab);\r\n\taudit_log_key(ab, ctx->filterkey);\r\n\taudit_log_end(ab);\r\n}", ".how_special": "static void show_special(struct audit_context *context, int *call_panic)\r\n{\r\n\tstruct audit_buffer *ab;\r\n\tint i;\r\n\r\n\tab = audit_log_start(context, GFP_KERNEL, context->type);\r\n\tif (!ab)\r\n\t\treturn;\r\n\r\n\tswitch (context->type) {\r\n\tcase AUDIT_SOCKETCALL: {\r\n\t\tint nargs = context->socketcall.nargs;\r\n\r\n\t\taudit_log_format(ab, \"nargs=%d\", nargs);\r\n\t\tfor (i = 0; i < nargs; i++)\r\n\t\t\taudit_log_format(ab, \" a%d=%lx\", i,\r\n\t\t\t\tcontext->socketcall.args[i]);\r\n\t\tbreak; }\r\n\tcase AUDIT_IPC:\r\n\t\taudit_log_format(ab, \"ouid=%u ogid=%u mode=%#ho\",\r\n\t\t\t\t from_kuid(&init_user_ns, context->ipc.uid),\r\n\t\t\t\t from_kgid(&init_user_ns, context->ipc.gid),\r\n\t\t\t\t context->ipc.mode);\r\n\t\tif (lsmprop_is_set(&context->ipc.oprop)) {\r\n\t\t\tstruct lsm_context lsmctx;\r\n\r\n\t\t\tif (security_lsmprop_to_secctx(&context->ipc.oprop,\r\n\t\t\t\t\t\t       &lsmctx,\r\n\t\t\t\t\t\t       LSM_ID_UNDEF) < 0) {\r\n\t\t\t\t*call_panic = 1;\r\n\t\t\t} else {\r\n\t\t\t\taudit_log_format(ab, \" obj=%s\", lsmctx.context);\r\n\t\t\t\tsecurity_release_secctx(&lsmctx);\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (context->ipc.has_perm) {\r\n\t\t\taudit_log_end(ab);\r\n\t\t\tab = audit_log_start(context, GFP_KERNEL,\r\n\t\t\t\t\t     AUDIT_IPC_SET_PERM);\r\n\t\t\tif (unlikely(!ab))\r\n\t\t\t\treturn;\r\n\t\t\taudit_log_format(ab,\r\n\t\t\t\t\"qbytes=%lx ouid=%u ogid=%u mode=%#ho\",\r\n\t\t\t\tcontext->ipc.qbytes,\r\n\t\t\t\tcontext->ipc.perm_uid,\r\n\t\t\t\tcontext->ipc.perm_gid,\r\n\t\t\t\tcontext->ipc.perm_mode);\r\n\t\t}\r\n\t\tbreak;\r\n\tcase AUDIT_MQ_OPEN:\r\n\t\taudit_log_format(ab,\r\n\t\t\t\"oflag=0x%x mode=%#ho mq_flags=0x%lx mq_maxmsg=%ld \"\r\n\t\t\t\"mq_msgsize=%ld mq_curmsgs=%ld\",\r\n\t\t\tcontext->mq_open.oflag, context->mq_open.mode,\r\n\t\t\tcontext->mq_open.attr.mq_flags,\r\n\t\t\tcontext->mq_open.attr.mq_maxmsg,\r\n\t\t\tcontext->mq_open.attr.mq_msgsize,\r\n\t\t\tcontext->mq_open.attr.mq_curmsgs);\r\n\t\tbreak;\r\n\tcase AUDIT_MQ_SENDRECV:\r\n\t\taudit_log_format(ab,\r\n\t\t\t\"mqdes=%d msg_len=%zd msg_prio=%u \"\r\n\t\t\t\"abs_timeout_sec=%lld abs_timeout_nsec=%ld\",\r\n\t\t\tcontext->mq_sendrecv.mqdes,\r\n\t\t\tcontext->mq_sendrecv.msg_len,\r\n\t\t\tcontext->mq_sendrecv.msg_prio,\r\n\t\t\t(long long) context->mq_sendrecv.abs_timeout.tv_sec,\r\n\t\t\tcontext->mq_sendrecv.abs_timeout.tv_nsec);\r\n\t\tbreak;\r\n\tcase AUDIT_MQ_NOTIFY:\r\n\t\taudit_log_format(ab, \"mqdes=%d sigev_signo=%d\",\r\n\t\t\t\tcontext->mq_notify.mqdes,\r\n\t\t\t\tcontext->mq_notify.sigev_signo);\r\n\t\tbreak;\r\n\tcase AUDIT_MQ_GETSETATTR: {\r\n\t\tstruct mq_attr *attr = &context->mq_getsetattr.mqstat;\r\n\r\n\t\taudit_log_format(ab,\r\n\t\t\t\"mqdes=%d mq_flags=0x%lx mq_maxmsg=%ld mq_msgsize=%ld \"\r\n\t\t\t\"mq_curmsgs=%ld \",\r\n\t\t\tcontext->mq_getsetattr.mqdes,\r\n\t\t\tattr->mq_flags, attr->mq_maxmsg,\r\n\t\t\tattr->mq_msgsize, attr->mq_curmsgs);\r\n\t\tbreak; }\r\n\tcase AUDIT_CAPSET:\r\n\t\taudit_log_format(ab, \"pid=%d\", context->capset.pid);\r\n\t\taudit_log_cap(ab, \"cap_pi\", &context->capset.cap.inheritable);\r\n\t\taudit_log_cap(ab, \"cap_pp\", &context->capset.cap.permitted);\r\n\t\taudit_log_cap(ab, \"cap_pe\", &context->capset.cap.effective);\r\n\t\taudit_log_cap(ab, \"cap_pa\", &context->capset.cap.ambient);\r\n\t\tbreak;\r\n\tcase AUDIT_MMAP:\r\n\t\taudit_log_format(ab, \"fd=%d flags=0x%x\", context->mmap.fd,\r\n\t\t\t\t context->mmap.flags);\r\n\t\tbreak;\r\n\tcase AUDIT_OPENAT2:\r\n\t\taudit_log_format(ab, \"oflag=0%llo mode=0%llo resolve=0x%llx\",\r\n\t\t\t\t context->openat2.flags,\r\n\t\t\t\t context->openat2.mode,\r\n\t\t\t\t context->openat2.resolve);\r\n\t\tbreak;\r\n\tcase AUDIT_EXECVE:\r\n\t\taudit_log_execve_info(context, &ab);\r\n\t\tbreak;\r\n\tcase AUDIT_KERN_MODULE:\r\n\t\taudit_log_format(ab, \"name=\");\r\n\t\tif (context->module.name) {\r\n\t\t\taudit_log_untrustedstring(ab, context->module.name);\r\n\t\t} else\r\n\t\t\taudit_log_format(ab, \"(null)\");\r\n\r\n\t\tbreak;\r\n\tcase AUDIT_TIME_ADJNTPVAL:\r\n\tcase AUDIT_TIME_INJOFFSET:\r\n\t\t/* this call deviates from the rest, eating the buffer */\r\n\t\taudit_log_time(context, &ab);\r\n\t\tbreak;\r\n\t}\r\n\taudit_log_end(ab);\r\n}", ".udit_log_pid_context": "static int audit_log_pid_context(struct audit_context *context, pid_t pid,\r\n\t\t\t\t kuid_t auid, kuid_t uid,\r\n\t\t\t\t unsigned int sessionid, struct lsm_prop *prop,\r\n\t\t\t\t char *comm)\r\n{\r\n\tstruct audit_buffer *ab;\r\n\tstruct lsm_context ctx;\r\n\tint rc = 0;\r\n\r\n\tab = audit_log_start(context, GFP_KERNEL, AUDIT_OBJ_PID);\r\n\tif (!ab)\r\n\t\treturn rc;\r\n\r\n\taudit_log_format(ab, \"opid=%d oauid=%d ouid=%d oses=%d\", pid,\r\n\t\t\t from_kuid(&init_user_ns, auid),\r\n\t\t\t from_kuid(&init_user_ns, uid), sessionid);\r\n\tif (lsmprop_is_set(prop)) {\r\n\t\tif (security_lsmprop_to_secctx(prop, &ctx, LSM_ID_UNDEF) < 0) {\r\n\t\t\taudit_log_format(ab, \" obj=(none)\");\r\n\t\t\trc = 1;\r\n\t\t} else {\r\n\t\t\taudit_log_format(ab, \" obj=%s\", ctx.context);\r\n\t\t\tsecurity_release_secctx(&ctx);\r\n\t\t}\r\n\t}\r\n\taudit_log_format(ab, \" ocomm=\");\r\n\taudit_log_untrustedstring(ab, comm);\r\n\taudit_log_end(ab);\r\n\r\n\treturn rc;\r\n}", ".udit_log_name": "static void audit_log_name(struct audit_context *context, struct audit_names *n,\r\n\t\t    const struct path *path, int record_num, int *call_panic)\r\n{\r\n\tstruct audit_buffer *ab;\r\n\r\n\tab = audit_log_start(context, GFP_KERNEL, AUDIT_PATH);\r\n\tif (!ab)\r\n\t\treturn;\r\n\r\n\taudit_log_format(ab, \"item=%d\", record_num);\r\n\r\n\tif (path)\r\n\t\taudit_log_d_path(ab, \" name=\", path);\r\n\telse if (n->name) {\r\n\t\tswitch (n->name_len) {\r\n\t\tcase AUDIT_NAME_FULL:\r\n\t\t\t/* log the full path */\r\n\t\t\taudit_log_format(ab, \" name=\");\r\n\t\t\taudit_log_untrustedstring(ab, n->name->name);\r\n\t\t\tbreak;\r\n\t\tcase 0:\r\n\t\t\t/* name was specified as a relative path and the\r\n\t\t\t * directory component is the cwd\r\n\t\t\t */\r\n\t\t\tif (context->pwd.dentry && context->pwd.mnt)\r\n\t\t\t\taudit_log_d_path(ab, \" name=\", &context->pwd);\r\n\t\t\telse\r\n\t\t\t\taudit_log_format(ab, \" name=(null)\");\r\n\t\t\tbreak;\r\n\t\tdefault:\r\n\t\t\t/* log the name's directory component */\r\n\t\t\taudit_log_format(ab, \" name=\");\r\n\t\t\taudit_log_n_untrustedstring(ab, n->name->name,\r\n\t\t\t\t\t\t    n->name_len);\r\n\t\t}\r\n\t} else\r\n\t\taudit_log_format(ab, \" name=(null)\");\r\n\r\n\tif (n->ino != AUDIT_INO_UNSET)\r\n\t\taudit_log_format(ab, \" inode=%lu dev=%02x:%02x mode=%#ho ouid=%u ogid=%u rdev=%02x:%02x\",\r\n\t\t\t\t n->ino,\r\n\t\t\t\t MAJOR(n->dev),\r\n\t\t\t\t MINOR(n->dev),\r\n\t\t\t\t n->mode,\r\n\t\t\t\t from_kuid(&init_user_ns, n->uid),\r\n\t\t\t\t from_kgid(&init_user_ns, n->gid),\r\n\t\t\t\t MAJOR(n->rdev),\r\n\t\t\t\t MINOR(n->rdev));\r\n\tif (lsmprop_is_set(&n->oprop)) {\r\n\t\tstruct lsm_context ctx;\r\n\r\n\t\tif (security_lsmprop_to_secctx(&n->oprop, &ctx,\r\n\t\t\t\t\t       LSM_ID_UNDEF) < 0) {\r\n\t\t\tif (call_panic)\r\n\t\t\t\t*call_panic = 2;\r\n\t\t} else {\r\n\t\t\taudit_log_format(ab, \" obj=%s\", ctx.context);\r\n\t\t\tsecurity_release_secctx(&ctx);\r\n\t\t}\r\n\t}\r\n\r\n\t/* log the audit_names record type */\r\n\tswitch (n->type) {\r\n\tcase AUDIT_TYPE_NORMAL:\r\n\t\taudit_log_format(ab, \" nametype=NORMAL\");\r\n\t\tbreak;\r\n\tcase AUDIT_TYPE_PARENT:\r\n\t\taudit_log_format(ab, \" nametype=PARENT\");\r\n\t\tbreak;\r\n\tcase AUDIT_TYPE_CHILD_DELETE:\r\n\t\taudit_log_format(ab, \" nametype=DELETE\");\r\n\t\tbreak;\r\n\tcase AUDIT_TYPE_CHILD_CREATE:\r\n\t\taudit_log_format(ab, \" nametype=CREATE\");\r\n\t\tbreak;\r\n\tdefault:\r\n\t\taudit_log_format(ab, \" nametype=UNKNOWN\");\r\n\t\tbreak;\r\n\t}\r\n\r\n\taudit_log_fcaps(ab, n);\r\n\taudit_log_end(ab);\r\n}", ".udit_log_proctitle": "static void audit_log_proctitle(void)\r\n{\r\n\tint res;\r\n\tchar *buf;\r\n\tchar *msg = \"(null)\";\r\n\tint len = strlen(msg);\r\n\tstruct audit_context *context = audit_context();\r\n\tstruct audit_buffer *ab;\r\n\r\n\tab = audit_log_start(context, GFP_KERNEL, AUDIT_PROCTITLE);\r\n\tif (!ab)\r\n\t\treturn;\t/* audit_panic or being filtered */\r\n\r\n\taudit_log_format(ab, \"proctitle=\");\r\n\r\n\t/* Not  cached */\r\n\tif (!context->proctitle.value) {\r\n\t\tbuf = kmalloc(MAX_PROCTITLE_AUDIT_LEN, GFP_KERNEL);\r\n\t\tif (!buf)\r\n\t\t\tgoto out;\r\n\t\t/* Historically called this from procfs naming */\r\n\t\tres = get_cmdline(current, buf, MAX_PROCTITLE_AUDIT_LEN);\r\n\t\tif (res == 0) {\r\n\t\t\tkfree(buf);\r\n\t\t\tgoto out;\r\n\t\t}\r\n\t\tres = audit_proctitle_rtrim(buf, res);\r\n\t\tif (res == 0) {\r\n\t\t\tkfree(buf);\r\n\t\t\tgoto out;\r\n\t\t}\r\n\t\tcontext->proctitle.value = buf;\r\n\t\tcontext->proctitle.len = res;\r\n\t}\r\n\tmsg = context->proctitle.value;\r\n\tlen = context->proctitle.len;\r\nout:\r\n\taudit_log_n_untrustedstring(ab, msg, len);\r\n\taudit_log_end(ab);\r\n}", ".ut_tree_ref": "static int put_tree_ref(struct audit_context *ctx, struct audit_chunk *chunk)\r\n{\r\n\tstruct audit_tree_refs *p = ctx->trees;\r\n\tint left = ctx->tree_count;\r\n\r\n\tif (likely(left)) {\r\n\t\tp->c[--left] = chunk;\r\n\t\tctx->tree_count = left;\r\n\t\treturn 1;\r\n\t}\r\n\tif (!p)\r\n\t\treturn 0;\r\n\tp = p->next;\r\n\tif (p) {\r\n\t\tp->c[30] = chunk;\r\n\t\tctx->trees = p;\r\n\t\tctx->tree_count = 30;\r\n\t\treturn 1;\r\n\t}\r\n\treturn 0;\r\n}", ".row_tree_refs": "static int grow_tree_refs(struct audit_context *ctx)\r\n{\r\n\tstruct audit_tree_refs *p = ctx->trees;\r\n\r\n\tctx->trees = kzalloc(sizeof(struct audit_tree_refs), GFP_KERNEL);\r\n\tif (!ctx->trees) {\r\n\t\tctx->trees = p;\r\n\t\treturn 0;\r\n\t}\r\n\tif (p)\r\n\t\tp->next = ctx->trees;\r\n\telse\r\n\t\tctx->first_trees = ctx->trees;\r\n\tctx->tree_count = 31;\r\n\treturn 1;\r\n}", ".udit_set_auditable": "static void audit_set_auditable(struct audit_context *ctx)\r\n{\r\n\tif (!ctx->prio) {\r\n\t\tctx->prio = 1;\r\n\t\tctx->current_state = AUDIT_STATE_RECORD;\r\n\t}\r\n}", ".udit_copy_fcaps": "static inline int audit_copy_fcaps(struct audit_names *name,\r\n\t\t\t\t   const struct dentry *dentry)\r\n{\r\n\tstruct cpu_vfs_cap_data caps;\r\n\tint rc;\r\n\r\n\tif (!dentry)\r\n\t\treturn 0;\r\n\r\n\trc = get_vfs_caps_from_disk(&nop_mnt_idmap, dentry, &caps);\r\n\tif (rc)\r\n\t\treturn rc;\r\n\r\n\tname->fcap.permitted = caps.permitted;\r\n\tname->fcap.inheritable = caps.inheritable;\r\n\tname->fcap.fE = !!(caps.magic_etc & VFS_CAP_FLAGS_EFFECTIVE);\r\n\tname->fcap.rootid = caps.rootid;\r\n\tname->fcap_ver = (caps.magic_etc & VFS_CAP_REVISION_MASK) >>\r\n\t\t\t\tVFS_CAP_REVISION_SHIFT;\r\n\r\n\treturn 0;\r\n}", ".udit_log_task": "static void audit_log_task(struct audit_buffer *ab)\r\n{\r\n\tkuid_t auid, uid;\r\n\tkgid_t gid;\r\n\tunsigned int sessionid;\r\n\tchar comm[sizeof(current->comm)];\r\n\r\n\tauid = audit_get_loginuid(current);\r\n\tsessionid = audit_get_sessionid(current);\r\n\tcurrent_uid_gid(&uid, &gid);\r\n\r\n\taudit_log_format(ab, \"auid=%u uid=%u gid=%u ses=%u\",\r\n\t\t\t from_kuid(&init_user_ns, auid),\r\n\t\t\t from_kuid(&init_user_ns, uid),\r\n\t\t\t from_kgid(&init_user_ns, gid),\r\n\t\t\t sessionid);\r\n\taudit_log_task_context(ab);\r\n\taudit_log_format(ab, \" pid=%d comm=\", task_tgid_nr(current));\r\n\taudit_log_untrustedstring(ab, get_task_comm(comm, current));\r\n\taudit_log_d_path_exe(ab, current->mm);\r\n}"}, "callee": {".udit_filter_rules": "static int audit_filter_rules(struct task_struct *tsk,\r\n\t\t\t      struct audit_krule *rule,\r\n\t\t\t      struct audit_context *ctx,\r\n\t\t\t      struct audit_names *name,\r\n\t\t\t      enum audit_state *state,\r\n\t\t\t      bool task_creation)\r\n{\r\n\tconst struct cred *cred;\r\n\tint i, need_sid = 1;\r\n\tstruct lsm_prop prop = { };\r\n\tunsigned int sessionid;\r\n\r\n\tif (ctx && rule->prio <= ctx->prio)\r\n\t\treturn 0;\r\n\r\n\tcred = rcu_dereference_check(tsk->cred, tsk == current || task_creation);\r\n\r\n\tfor (i = 0; i < rule->field_count; i++) {\r\n\t\tstruct audit_field *f = &rule->fields[i];\r\n\t\tstruct audit_names *n;\r\n\t\tint result = 0;\r\n\t\tpid_t pid;\r\n\r\n\t\tswitch (f->type) {\r\n\t\tcase AUDIT_PID:\r\n\t\t\tpid = task_tgid_nr(tsk);\r\n\t\t\tresult = audit_comparator(pid, f->op, f->val);\r\n\t\t\tbreak;\r\n\t\tcase AUDIT_PPID:\r\n\t\t\tif (ctx) {\r\n\t\t\t\tif (!ctx->ppid)\r\n\t\t\t\t\tctx->ppid = task_ppid_nr(tsk);\r\n\t\t\t\tresult = audit_comparator(ctx->ppid, f->op, f->val);\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\tcase AUDIT_EXE:\r\n\t\t\tresult = audit_exe_compare(tsk, rule->exe);\r\n\t\t\tif (f->op == Audit_not_equal)\r\n\t\t\t\tresult = !result;\r\n\t\t\tbreak;\r\n\t\tcase AUDIT_UID:\r\n\t\t\tresult = audit_uid_comparator(cred->uid, f->op, f->uid);\r\n\t\t\tbreak;\r\n\t\tcase AUDIT_EUID:\r\n\t\t\tresult = audit_uid_comparator(cred->euid, f->op, f->uid);\r\n\t\t\tbreak;\r\n\t\tcase AUDIT_SUID:\r\n\t\t\tresult = audit_uid_comparator(cred->suid, f->op, f->uid);\r\n\t\t\tbreak;\r\n\t\tcase AUDIT_FSUID:\r\n\t\t\tresult = audit_uid_comparator(cred->fsuid, f->op, f->uid);\r\n\t\t\tbreak;\r\n\t\tcase AUDIT_GID:\r\n\t\t\tresult = audit_gid_comparator(cred->gid, f->op, f->gid);\r\n\t\t\tif (f->op == Audit_equal) {\r\n\t\t\t\tif (!result)\r\n\t\t\t\t\tresult = groups_search(cred->group_info, f->gid);\r\n\t\t\t} else if (f->op == Audit_not_equal) {\r\n\t\t\t\tif (result)\r\n\t\t\t\t\tresult = !groups_search(cred->group_info, f->gid);\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\tcase AUDIT_EGID:\r\n\t\t\tresult = audit_gid_comparator(cred->egid, f->op, f->gid);\r\n\t\t\tif (f->op == Audit_equal) {\r\n\t\t\t\tif (!result)\r\n\t\t\t\t\tresult = groups_search(cred->group_info, f->gid);\r\n\t\t\t} else if (f->op == Audit_not_equal) {\r\n\t\t\t\tif (result)\r\n\t\t\t\t\tresult = !groups_search(cred->group_info, f->gid);\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\tcase AUDIT_SGID:\r\n\t\t\tresult = audit_gid_comparator(cred->sgid, f->op, f->gid);\r\n\t\t\tbreak;\r\n\t\tcase AUDIT_FSGID:\r\n\t\t\tresult = audit_gid_comparator(cred->fsgid, f->op, f->gid);\r\n\t\t\tbreak;\r\n\t\tcase AUDIT_SESSIONID:\r\n\t\t\tsessionid = audit_get_sessionid(tsk);\r\n\t\t\tresult = audit_comparator(sessionid, f->op, f->val);\r\n\t\t\tbreak;\r\n\t\tcase AUDIT_PERS:\r\n\t\t\tresult = audit_comparator(tsk->personality, f->op, f->val);\r\n\t\t\tbreak;\r\n\t\tcase AUDIT_ARCH:\r\n\t\t\tif (ctx)\r\n\t\t\t\tresult = audit_comparator(ctx->arch, f->op, f->val);\r\n\t\t\tbreak;\r\n\r\n\t\tcase AUDIT_EXIT:\r\n\t\t\tif (ctx && ctx->return_valid != AUDITSC_INVALID)\r\n\t\t\t\tresult = audit_comparator(ctx->return_code, f->op, f->val);\r\n\t\t\tbreak;\r\n\t\tcase AUDIT_SUCCESS:\r\n\t\t\tif (ctx && ctx->return_valid != AUDITSC_INVALID) {\r\n\t\t\t\tif (f->val)\r\n\t\t\t\t\tresult = audit_comparator(ctx->return_valid, f->op, AUDITSC_SUCCESS);\r\n\t\t\t\telse\r\n\t\t\t\t\tresult = audit_comparator(ctx->return_valid, f->op, AUDITSC_FAILURE);\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\tcase AUDIT_DEVMAJOR:\r\n\t\t\tif (name) {\r\n\t\t\t\tif (audit_comparator(MAJOR(name->dev), f->op, f->val) ||\r\n\t\t\t\t    audit_comparator(MAJOR(name->rdev), f->op, f->val))\r\n\t\t\t\t\t++result;\r\n\t\t\t} else if (ctx) {\r\n\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\r\n\t\t\t\t\tif (audit_comparator(MAJOR(n->dev), f->op, f->val) ||\r\n\t\t\t\t\t    audit_comparator(MAJOR(n->rdev), f->op, f->val)) {\r\n\t\t\t\t\t\t++result;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\tcase AUDIT_DEVMINOR:\r\n\t\t\tif (name) {\r\n\t\t\t\tif (audit_comparator(MINOR(name->dev), f->op, f->val) ||\r\n\t\t\t\t    audit_comparator(MINOR(name->rdev), f->op, f->val))\r\n\t\t\t\t\t++result;\r\n\t\t\t} else if (ctx) {\r\n\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\r\n\t\t\t\t\tif (audit_comparator(MINOR(n->dev), f->op, f->val) ||\r\n\t\t\t\t\t    audit_comparator(MINOR(n->rdev), f->op, f->val)) {\r\n\t\t\t\t\t\t++result;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\tcase AUDIT_INODE:\r\n\t\t\tif (name)\r\n\t\t\t\tresult = audit_comparator(name->ino, f->op, f->val);\r\n\t\t\telse if (ctx) {\r\n\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\r\n\t\t\t\t\tif (audit_comparator(n->ino, f->op, f->val)) {\r\n\t\t\t\t\t\t++result;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\tcase AUDIT_OBJ_UID:\r\n\t\t\tif (name) {\r\n\t\t\t\tresult = audit_uid_comparator(name->uid, f->op, f->uid);\r\n\t\t\t} else if (ctx) {\r\n\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\r\n\t\t\t\t\tif (audit_uid_comparator(n->uid, f->op, f->uid)) {\r\n\t\t\t\t\t\t++result;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\tcase AUDIT_OBJ_GID:\r\n\t\t\tif (name) {\r\n\t\t\t\tresult = audit_gid_comparator(name->gid, f->op, f->gid);\r\n\t\t\t} else if (ctx) {\r\n\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\r\n\t\t\t\t\tif (audit_gid_comparator(n->gid, f->op, f->gid)) {\r\n\t\t\t\t\t\t++result;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\tcase AUDIT_WATCH:\r\n\t\t\tif (name) {\r\n\t\t\t\tresult = audit_watch_compare(rule->watch,\r\n\t\t\t\t\t\t\t     name->ino,\r\n\t\t\t\t\t\t\t     name->dev);\r\n\t\t\t\tif (f->op == Audit_not_equal)\r\n\t\t\t\t\tresult = !result;\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\tcase AUDIT_DIR:\r\n\t\t\tif (ctx) {\r\n\t\t\t\tresult = match_tree_refs(ctx, rule->tree);\r\n\t\t\t\tif (f->op == Audit_not_equal)\r\n\t\t\t\t\tresult = !result;\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\tcase AUDIT_LOGINUID:\r\n\t\t\tresult = audit_uid_comparator(audit_get_loginuid(tsk),\r\n\t\t\t\t\t\t      f->op, f->uid);\r\n\t\t\tbreak;\r\n\t\tcase AUDIT_LOGINUID_SET:\r\n\t\t\tresult = audit_comparator(audit_loginuid_set(tsk), f->op, f->val);\r\n\t\t\tbreak;\r\n\t\tcase AUDIT_SADDR_FAM:\r\n\t\t\tif (ctx && ctx->sockaddr)\r\n\t\t\t\tresult = audit_comparator(ctx->sockaddr->ss_family,\r\n\t\t\t\t\t\t\t  f->op, f->val);\r\n\t\t\tbreak;\r\n\t\tcase AUDIT_SUBJ_USER:\r\n\t\tcase AUDIT_SUBJ_ROLE:\r\n\t\tcase AUDIT_SUBJ_TYPE:\r\n\t\tcase AUDIT_SUBJ_SEN:\r\n\t\tcase AUDIT_SUBJ_CLR:\r\n\t\t\t/* NOTE: this may return negative values indicating\r\n\t\t\t   a temporary error.  We simply treat this as a\r\n\t\t\t   match for now to avoid losing information that\r\n\t\t\t   may be wanted.   An error message will also be\r\n\t\t\t   logged upon error */\r\n\t\t\tif (f->lsm_rule) {\r\n\t\t\t\tif (need_sid) {\r\n\t\t\t\t\t/* @tsk should always be equal to\r\n\t\t\t\t\t * @current with the exception of\r\n\t\t\t\t\t * fork()/copy_process() in which case\r\n\t\t\t\t\t * the new @tsk creds are still a dup\r\n\t\t\t\t\t * of @current's creds so we can still\r\n\t\t\t\t\t * use\r\n\t\t\t\t\t * security_current_getlsmprop_subj()\r\n\t\t\t\t\t * here even though it always refs\r\n\t\t\t\t\t * @current's creds\r\n\t\t\t\t\t */\r\n\t\t\t\t\tsecurity_current_getlsmprop_subj(&prop);\r\n\t\t\t\t\tneed_sid = 0;\r\n\t\t\t\t}\r\n\t\t\t\tresult = security_audit_rule_match(&prop,\r\n\t\t\t\t\t\t\t\t   f->type,\r\n\t\t\t\t\t\t\t\t   f->op,\r\n\t\t\t\t\t\t\t\t   f->lsm_rule);\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\tcase AUDIT_OBJ_USER:\r\n\t\tcase AUDIT_OBJ_ROLE:\r\n\t\tcase AUDIT_OBJ_TYPE:\r\n\t\tcase AUDIT_OBJ_LEV_LOW:\r\n\t\tcase AUDIT_OBJ_LEV_HIGH:\r\n\t\t\t/* The above note for AUDIT_SUBJ_USER...AUDIT_SUBJ_CLR\r\n\t\t\t   also applies here */\r\n\t\t\tif (f->lsm_rule) {\r\n\t\t\t\t/* Find files that match */\r\n\t\t\t\tif (name) {\r\n\t\t\t\t\tresult = security_audit_rule_match(\r\n\t\t\t\t\t\t\t\t&name->oprop,\r\n\t\t\t\t\t\t\t\tf->type,\r\n\t\t\t\t\t\t\t\tf->op,\r\n\t\t\t\t\t\t\t\tf->lsm_rule);\r\n\t\t\t\t} else if (ctx) {\r\n\t\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\r\n\t\t\t\t\t\tif (security_audit_rule_match(\r\n\t\t\t\t\t\t\t\t&n->oprop,\r\n\t\t\t\t\t\t\t\tf->type,\r\n\t\t\t\t\t\t\t\tf->op,\r\n\t\t\t\t\t\t\t\tf->lsm_rule)) {\r\n\t\t\t\t\t\t\t++result;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t/* Find ipc objects that match */\r\n\t\t\t\tif (!ctx || ctx->type != AUDIT_IPC)\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tif (security_audit_rule_match(&ctx->ipc.oprop,\r\n\t\t\t\t\t\t\t      f->type, f->op,\r\n\t\t\t\t\t\t\t      f->lsm_rule))\r\n\t\t\t\t\t++result;\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\tcase AUDIT_ARG0:\r\n\t\tcase AUDIT_ARG1:\r\n\t\tcase AUDIT_ARG2:\r\n\t\tcase AUDIT_ARG3:\r\n\t\t\tif (ctx)\r\n\t\t\t\tresult = audit_comparator(ctx->argv[f->type-AUDIT_ARG0], f->op, f->val);\r\n\t\t\tbreak;\r\n\t\tcase AUDIT_FILTERKEY:\r\n\t\t\t/* ignore this field for filtering */\r\n\t\t\tresult = 1;\r\n\t\t\tbreak;\r\n\t\tcase AUDIT_PERM:\r\n\t\t\tresult = audit_match_perm(ctx, f->val);\r\n\t\t\tif (f->op == Audit_not_equal)\r\n\t\t\t\tresult = !result;\r\n\t\t\tbreak;\r\n\t\tcase AUDIT_FILETYPE:\r\n\t\t\tresult = audit_match_filetype(ctx, f->val);\r\n\t\t\tif (f->op == Audit_not_equal)\r\n\t\t\t\tresult = !result;\r\n\t\t\tbreak;\r\n\t\tcase AUDIT_FIELD_COMPARE:\r\n\t\t\tresult = audit_field_compare(tsk, cred, f, ctx, name);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tif (!result)\r\n\t\t\treturn 0;\r\n\t}\r\n\r\n\tif (ctx) {\r\n\t\tif (rule->filterkey) {\r\n\t\t\tkfree(ctx->filterkey);\r\n\t\t\tctx->filterkey = kstrdup(rule->filterkey, GFP_ATOMIC);\r\n\t\t}\r\n\t\tctx->prio = rule->prio;\r\n\t}\r\n\tswitch (rule->action) {\r\n\tcase AUDIT_NEVER:\r\n\t\t*state = AUDIT_STATE_DISABLED;\r\n\t\tbreak;\r\n\tcase AUDIT_ALWAYS:\r\n\t\t*state = AUDIT_STATE_RECORD;\r\n\t\tbreak;\r\n\t}\r\n\treturn 1;\r\n}", ".andle_one": "static inline void handle_one(const struct inode *inode)\r\n{\r\n\tstruct audit_context *context;\r\n\tstruct audit_tree_refs *p;\r\n\tstruct audit_chunk *chunk;\r\n\tint count;\r\n\r\n\tif (likely(!inode->i_fsnotify_marks))\r\n\t\treturn;\r\n\tcontext = audit_context();\r\n\tp = context->trees;\r\n\tcount = context->tree_count;\r\n\trcu_read_lock();\r\n\tchunk = audit_tree_lookup(inode);\r\n\trcu_read_unlock();\r\n\tif (!chunk)\r\n\t\treturn;\r\n\tif (likely(put_tree_ref(context, chunk)))\r\n\t\treturn;\r\n\tif (unlikely(!grow_tree_refs(context))) {\r\n\t\tpr_warn(\"out of memory, audit has lost a tree reference\\n\");\r\n\t\taudit_set_auditable(context);\r\n\t\taudit_put_chunk(chunk);\r\n\t\tunroll_tree_refs(context, p, count);\r\n\t\treturn;\r\n\t}\r\n\tput_tree_ref(context, chunk);\r\n}", ".andle_path": "static void handle_path(const struct dentry *dentry)\r\n{\r\n\tstruct audit_context *context;\r\n\tstruct audit_tree_refs *p;\r\n\tconst struct dentry *d, *parent;\r\n\tstruct audit_chunk *drop;\r\n\tunsigned long seq;\r\n\tint count;\r\n\r\n\tcontext = audit_context();\r\n\tp = context->trees;\r\n\tcount = context->tree_count;\r\nretry:\r\n\tdrop = NULL;\r\n\td = dentry;\r\n\trcu_read_lock();\r\n\tseq = read_seqbegin(&rename_lock);\r\n\tfor (;;) {\r\n\t\tstruct inode *inode = d_backing_inode(d);\r\n\r\n\t\tif (inode && unlikely(inode->i_fsnotify_marks)) {\r\n\t\t\tstruct audit_chunk *chunk;\r\n\r\n\t\t\tchunk = audit_tree_lookup(inode);\r\n\t\t\tif (chunk) {\r\n\t\t\t\tif (unlikely(!put_tree_ref(context, chunk))) {\r\n\t\t\t\t\tdrop = chunk;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tparent = d->d_parent;\r\n\t\tif (parent == d)\r\n\t\t\tbreak;\r\n\t\td = parent;\r\n\t}\r\n\tif (unlikely(read_seqretry(&rename_lock, seq) || drop)) {  /* in this order */\r\n\t\trcu_read_unlock();\r\n\t\tif (!drop) {\r\n\t\t\t/* just a race with rename */\r\n\t\t\tunroll_tree_refs(context, p, count);\r\n\t\t\tgoto retry;\r\n\t\t}\r\n\t\taudit_put_chunk(drop);\r\n\t\tif (grow_tree_refs(context)) {\r\n\t\t\t/* OK, got more space */\r\n\t\t\tunroll_tree_refs(context, p, count);\r\n\t\t\tgoto retry;\r\n\t\t}\r\n\t\t/* too bad */\r\n\t\tpr_warn(\"out of memory, audit has lost a tree reference\\n\");\r\n\t\tunroll_tree_refs(context, p, count);\r\n\t\taudit_set_auditable(context);\r\n\t\treturn;\r\n\t}\r\n\trcu_read_unlock();\r\n}", ".udit_reset_context": "static void audit_reset_context(struct audit_context *ctx)\r\n{\r\n\tif (!ctx)\r\n\t\treturn;\r\n\r\n\t/* if ctx is non-null, reset the \"ctx->context\" regardless */\r\n\tctx->context = AUDIT_CTX_UNUSED;\r\n\tif (ctx->dummy)\r\n\t\treturn;\r\n\r\n\t/*\r\n\t * NOTE: It shouldn't matter in what order we release the fields, so\r\n\t *       release them in the order in which they appear in the struct;\r\n\t *       this gives us some hope of quickly making sure we are\r\n\t *       resetting the audit_context properly.\r\n\t *\r\n\t *       Other things worth mentioning:\r\n\t *       - we don't reset \"dummy\"\r\n\t *       - we don't reset \"state\", we do reset \"current_state\"\r\n\t *       - we preserve \"filterkey\" if \"state\" is AUDIT_STATE_RECORD\r\n\t *       - much of this is likely overkill, but play it safe for now\r\n\t *       - we really need to work on improving the audit_context struct\r\n\t */\r\n\r\n\tctx->current_state = ctx->state;\r\n\tctx->stamp.serial = 0;\r\n\tctx->stamp.ctime = (struct timespec64){ .tv_sec = 0, .tv_nsec = 0 };\r\n\tctx->major = 0;\r\n\tctx->uring_op = 0;\r\n\tmemset(ctx->argv, 0, sizeof(ctx->argv));\r\n\tctx->return_code = 0;\r\n\tctx->prio = (ctx->state == AUDIT_STATE_RECORD ? ~0ULL : 0);\r\n\tctx->return_valid = AUDITSC_INVALID;\r\n\taudit_free_names(ctx);\r\n\tif (ctx->state != AUDIT_STATE_RECORD) {\r\n\t\tkfree(ctx->filterkey);\r\n\t\tctx->filterkey = NULL;\r\n\t}\r\n\taudit_free_aux(ctx);\r\n\tkfree(ctx->sockaddr);\r\n\tctx->sockaddr = NULL;\r\n\tctx->sockaddr_len = 0;\r\n\tctx->ppid = 0;\r\n\tctx->uid = ctx->euid = ctx->suid = ctx->fsuid = KUIDT_INIT(0);\r\n\tctx->gid = ctx->egid = ctx->sgid = ctx->fsgid = KGIDT_INIT(0);\r\n\tctx->personality = 0;\r\n\tctx->arch = 0;\r\n\tctx->target_pid = 0;\r\n\tctx->target_auid = ctx->target_uid = KUIDT_INIT(0);\r\n\tctx->target_sessionid = 0;\r\n\tlsmprop_init(&ctx->target_ref);\r\n\tctx->target_comm[0] = '\\0';\r\n\tunroll_tree_refs(ctx, NULL, 0);\r\n\tWARN_ON(!list_empty(&ctx->killed_trees));\r\n\taudit_free_module(ctx);\r\n\tctx->fds[0] = -1;\r\n\tctx->type = 0; /* reset last for audit_free_*() */\r\n}", ".udit_free_context": "static inline void audit_free_context(struct audit_context *context)\r\n{\r\n\t/* resetting is extra work, but it is likely just noise */\r\n\taudit_reset_context(context);\r\n\taudit_proctitle_free(context);\r\n\tfree_tree_refs(context);\r\n\tkfree(context->filterkey);\r\n\tkfree(context);\r\n}", ".udit_field_compare": "static int audit_field_compare(struct task_struct *tsk,\r\n\t\t\t       const struct cred *cred,\r\n\t\t\t       struct audit_field *f,\r\n\t\t\t       struct audit_context *ctx,\r\n\t\t\t       struct audit_names *name)\r\n{\r\n\tswitch (f->val) {\r\n\t/* process to file object comparisons */\r\n\tcase AUDIT_COMPARE_UID_TO_OBJ_UID:\r\n\t\treturn audit_compare_uid(cred->uid, name, f, ctx);\r\n\tcase AUDIT_COMPARE_GID_TO_OBJ_GID:\r\n\t\treturn audit_compare_gid(cred->gid, name, f, ctx);\r\n\tcase AUDIT_COMPARE_EUID_TO_OBJ_UID:\r\n\t\treturn audit_compare_uid(cred->euid, name, f, ctx);\r\n\tcase AUDIT_COMPARE_EGID_TO_OBJ_GID:\r\n\t\treturn audit_compare_gid(cred->egid, name, f, ctx);\r\n\tcase AUDIT_COMPARE_AUID_TO_OBJ_UID:\r\n\t\treturn audit_compare_uid(audit_get_loginuid(tsk), name, f, ctx);\r\n\tcase AUDIT_COMPARE_SUID_TO_OBJ_UID:\r\n\t\treturn audit_compare_uid(cred->suid, name, f, ctx);\r\n\tcase AUDIT_COMPARE_SGID_TO_OBJ_GID:\r\n\t\treturn audit_compare_gid(cred->sgid, name, f, ctx);\r\n\tcase AUDIT_COMPARE_FSUID_TO_OBJ_UID:\r\n\t\treturn audit_compare_uid(cred->fsuid, name, f, ctx);\r\n\tcase AUDIT_COMPARE_FSGID_TO_OBJ_GID:\r\n\t\treturn audit_compare_gid(cred->fsgid, name, f, ctx);\r\n\t/* uid comparisons */\r\n\tcase AUDIT_COMPARE_UID_TO_AUID:\r\n\t\treturn audit_uid_comparator(cred->uid, f->op,\r\n\t\t\t\t\t    audit_get_loginuid(tsk));\r\n\tcase AUDIT_COMPARE_UID_TO_EUID:\r\n\t\treturn audit_uid_comparator(cred->uid, f->op, cred->euid);\r\n\tcase AUDIT_COMPARE_UID_TO_SUID:\r\n\t\treturn audit_uid_comparator(cred->uid, f->op, cred->suid);\r\n\tcase AUDIT_COMPARE_UID_TO_FSUID:\r\n\t\treturn audit_uid_comparator(cred->uid, f->op, cred->fsuid);\r\n\t/* auid comparisons */\r\n\tcase AUDIT_COMPARE_AUID_TO_EUID:\r\n\t\treturn audit_uid_comparator(audit_get_loginuid(tsk), f->op,\r\n\t\t\t\t\t    cred->euid);\r\n\tcase AUDIT_COMPARE_AUID_TO_SUID:\r\n\t\treturn audit_uid_comparator(audit_get_loginuid(tsk), f->op,\r\n\t\t\t\t\t    cred->suid);\r\n\tcase AUDIT_COMPARE_AUID_TO_FSUID:\r\n\t\treturn audit_uid_comparator(audit_get_loginuid(tsk), f->op,\r\n\t\t\t\t\t    cred->fsuid);\r\n\t/* euid comparisons */\r\n\tcase AUDIT_COMPARE_EUID_TO_SUID:\r\n\t\treturn audit_uid_comparator(cred->euid, f->op, cred->suid);\r\n\tcase AUDIT_COMPARE_EUID_TO_FSUID:\r\n\t\treturn audit_uid_comparator(cred->euid, f->op, cred->fsuid);\r\n\t/* suid comparisons */\r\n\tcase AUDIT_COMPARE_SUID_TO_FSUID:\r\n\t\treturn audit_uid_comparator(cred->suid, f->op, cred->fsuid);\r\n\t/* gid comparisons */\r\n\tcase AUDIT_COMPARE_GID_TO_EGID:\r\n\t\treturn audit_gid_comparator(cred->gid, f->op, cred->egid);\r\n\tcase AUDIT_COMPARE_GID_TO_SGID:\r\n\t\treturn audit_gid_comparator(cred->gid, f->op, cred->sgid);\r\n\tcase AUDIT_COMPARE_GID_TO_FSGID:\r\n\t\treturn audit_gid_comparator(cred->gid, f->op, cred->fsgid);\r\n\t/* egid comparisons */\r\n\tcase AUDIT_COMPARE_EGID_TO_SGID:\r\n\t\treturn audit_gid_comparator(cred->egid, f->op, cred->sgid);\r\n\tcase AUDIT_COMPARE_EGID_TO_FSGID:\r\n\t\treturn audit_gid_comparator(cred->egid, f->op, cred->fsgid);\r\n\t/* sgid comparison */\r\n\tcase AUDIT_COMPARE_SGID_TO_FSGID:\r\n\t\treturn audit_gid_comparator(cred->sgid, f->op, cred->fsgid);\r\n\tdefault:\r\n\t\tWARN(1, \"Missing AUDIT_COMPARE define.  Report as a bug\\n\");\r\n\t\treturn 0;\r\n\t}\r\n\treturn 0;\r\n}", ".udit_filter_task": "static enum audit_state audit_filter_task(struct task_struct *tsk, char **key)\r\n{\r\n\tstruct audit_entry *e;\r\n\tenum audit_state   state;\r\n\r\n\trcu_read_lock();\r\n\tlist_for_each_entry_rcu(e, &audit_filter_list[AUDIT_FILTER_TASK], list) {\r\n\t\tif (audit_filter_rules(tsk, &e->rule, NULL, NULL,\r\n\t\t\t\t       &state, true)) {\r\n\t\t\tif (state == AUDIT_STATE_RECORD)\r\n\t\t\t\t*key = kstrdup(e->rule.filterkey, GFP_ATOMIC);\r\n\t\t\trcu_read_unlock();\r\n\t\t\treturn state;\r\n\t\t}\r\n\t}\r\n\trcu_read_unlock();\r\n\treturn AUDIT_STATE_BUILD;\r\n}", ".udit_alloc": "int audit_alloc(struct task_struct *tsk)\r\n{\r\n\tstruct audit_context *context;\r\n\tenum audit_state     state;\r\n\tchar *key = NULL;\r\n\r\n\tif (likely(!audit_ever_enabled))\r\n\t\treturn 0;\r\n\r\n\tstate = audit_filter_task(tsk, &key);\r\n\tif (state == AUDIT_STATE_DISABLED) {\r\n\t\tclear_task_syscall_work(tsk, SYSCALL_AUDIT);\r\n\t\treturn 0;\r\n\t}\r\n\r\n\tcontext = audit_alloc_context(state);\r\n\tif (!context) {\r\n\t\tkfree(key);\r\n\t\taudit_log_lost(\"out of memory in audit_alloc\");\r\n\t\treturn -ENOMEM;\r\n\t}\r\n\tcontext->filterkey = key;\r\n\r\n\taudit_set_context(tsk, context);\r\n\tset_task_syscall_work(tsk, SYSCALL_AUDIT);\r\n\treturn 0;\r\n}", ".udit_filter_inodes": "void audit_filter_inodes(struct task_struct *tsk, struct audit_context *ctx)\r\n{\r\n\tstruct audit_names *n;\r\n\r\n\tif (auditd_test_task(tsk))\r\n\t\treturn;\r\n\r\n\trcu_read_lock();\r\n\r\n\tlist_for_each_entry(n, &ctx->names_list, list) {\r\n\t\tif (audit_filter_inode_name(tsk, n, ctx))\r\n\t\t\tbreak;\r\n\t}\r\n\trcu_read_unlock();\r\n}", ".udit_log_exit": "static void audit_log_exit(void)\r\n{\r\n\tint i, call_panic = 0;\r\n\tstruct audit_context *context = audit_context();\r\n\tstruct audit_buffer *ab;\r\n\tstruct audit_aux_data *aux;\r\n\tstruct audit_names *n;\r\n\r\n\tcontext->personality = current->personality;\r\n\r\n\tswitch (context->context) {\r\n\tcase AUDIT_CTX_SYSCALL:\r\n\t\tab = audit_log_start(context, GFP_KERNEL, AUDIT_SYSCALL);\r\n\t\tif (!ab)\r\n\t\t\treturn;\r\n\t\taudit_log_format(ab, \"arch=%x syscall=%d\",\r\n\t\t\t\t context->arch, context->major);\r\n\t\tif (context->personality != PER_LINUX)\r\n\t\t\taudit_log_format(ab, \" per=%lx\", context->personality);\r\n\t\tif (context->return_valid != AUDITSC_INVALID)\r\n\t\t\taudit_log_format(ab, \" success=%s exit=%ld\",\r\n\t\t\t\t\t str_yes_no(context->return_valid ==\r\n\t\t\t\t\t\t    AUDITSC_SUCCESS),\r\n\t\t\t\t\t context->return_code);\r\n\t\taudit_log_format(ab,\r\n\t\t\t\t \" a0=%lx a1=%lx a2=%lx a3=%lx items=%d\",\r\n\t\t\t\t context->argv[0],\r\n\t\t\t\t context->argv[1],\r\n\t\t\t\t context->argv[2],\r\n\t\t\t\t context->argv[3],\r\n\t\t\t\t context->name_count);\r\n\t\taudit_log_task_info(ab);\r\n\t\taudit_log_key(ab, context->filterkey);\r\n\t\taudit_log_end(ab);\r\n\t\tbreak;\r\n\tcase AUDIT_CTX_URING:\r\n\t\taudit_log_uring(context);\r\n\t\tbreak;\r\n\tdefault:\r\n\t\tBUG();\r\n\t\tbreak;\r\n\t}\r\n\r\n\tfor (aux = context->aux; aux; aux = aux->next) {\r\n\r\n\t\tab = audit_log_start(context, GFP_KERNEL, aux->type);\r\n\t\tif (!ab)\r\n\t\t\tcontinue; /* audit_panic has been called */\r\n\r\n\t\tswitch (aux->type) {\r\n\r\n\t\tcase AUDIT_BPRM_FCAPS: {\r\n\t\t\tstruct audit_aux_data_bprm_fcaps *axs = (void *)aux;\r\n\r\n\t\t\taudit_log_format(ab, \"fver=%x\", axs->fcap_ver);\r\n\t\t\taudit_log_cap(ab, \"fp\", &axs->fcap.permitted);\r\n\t\t\taudit_log_cap(ab, \"fi\", &axs->fcap.inheritable);\r\n\t\t\taudit_log_format(ab, \" fe=%d\", axs->fcap.fE);\r\n\t\t\taudit_log_cap(ab, \"old_pp\", &axs->old_pcap.permitted);\r\n\t\t\taudit_log_cap(ab, \"old_pi\", &axs->old_pcap.inheritable);\r\n\t\t\taudit_log_cap(ab, \"old_pe\", &axs->old_pcap.effective);\r\n\t\t\taudit_log_cap(ab, \"old_pa\", &axs->old_pcap.ambient);\r\n\t\t\taudit_log_cap(ab, \"pp\", &axs->new_pcap.permitted);\r\n\t\t\taudit_log_cap(ab, \"pi\", &axs->new_pcap.inheritable);\r\n\t\t\taudit_log_cap(ab, \"pe\", &axs->new_pcap.effective);\r\n\t\t\taudit_log_cap(ab, \"pa\", &axs->new_pcap.ambient);\r\n\t\t\taudit_log_format(ab, \" frootid=%d\",\r\n\t\t\t\t\t from_kuid(&init_user_ns,\r\n\t\t\t\t\t\t   axs->fcap.rootid));\r\n\t\t\tbreak; }\r\n\r\n\t\t}\r\n\t\taudit_log_end(ab);\r\n\t}\r\n\r\n\tif (context->type)\r\n\t\tshow_special(context, &call_panic);\r\n\r\n\tif (context->fds[0] >= 0) {\r\n\t\tab = audit_log_start(context, GFP_KERNEL, AUDIT_FD_PAIR);\r\n\t\tif (ab) {\r\n\t\t\taudit_log_format(ab, \"fd0=%d fd1=%d\",\r\n\t\t\t\t\tcontext->fds[0], context->fds[1]);\r\n\t\t\taudit_log_end(ab);\r\n\t\t}\r\n\t}\r\n\r\n\tif (context->sockaddr_len) {\r\n\t\tab = audit_log_start(context, GFP_KERNEL, AUDIT_SOCKADDR);\r\n\t\tif (ab) {\r\n\t\t\taudit_log_format(ab, \"saddr=\");\r\n\t\t\taudit_log_n_hex(ab, (void *)context->sockaddr,\r\n\t\t\t\t\tcontext->sockaddr_len);\r\n\t\t\taudit_log_end(ab);\r\n\t\t}\r\n\t}\r\n\r\n\tfor (aux = context->aux_pids; aux; aux = aux->next) {\r\n\t\tstruct audit_aux_data_pids *axs = (void *)aux;\r\n\r\n\t\tfor (i = 0; i < axs->pid_count; i++)\r\n\t\t\tif (audit_log_pid_context(context, axs->target_pid[i],\r\n\t\t\t\t\t\t  axs->target_auid[i],\r\n\t\t\t\t\t\t  axs->target_uid[i],\r\n\t\t\t\t\t\t  axs->target_sessionid[i],\r\n\t\t\t\t\t\t  &axs->target_ref[i],\r\n\t\t\t\t\t\t  axs->target_comm[i]))\r\n\t\t\t\tcall_panic = 1;\r\n\t}\r\n\r\n\tif (context->target_pid &&\r\n\t    audit_log_pid_context(context, context->target_pid,\r\n\t\t\t\t  context->target_auid, context->target_uid,\r\n\t\t\t\t  context->target_sessionid,\r\n\t\t\t\t  &context->target_ref,\r\n\t\t\t\t  context->target_comm))\r\n\t\tcall_panic = 1;\r\n\r\n\tif (context->pwd.dentry && context->pwd.mnt) {\r\n\t\tab = audit_log_start(context, GFP_KERNEL, AUDIT_CWD);\r\n\t\tif (ab) {\r\n\t\t\taudit_log_d_path(ab, \"cwd=\", &context->pwd);\r\n\t\t\taudit_log_end(ab);\r\n\t\t}\r\n\t}\r\n\r\n\ti = 0;\r\n\tlist_for_each_entry(n, &context->names_list, list) {\r\n\t\tif (n->hidden)\r\n\t\t\tcontinue;\r\n\t\taudit_log_name(context, n, NULL, i++, &call_panic);\r\n\t}\r\n\r\n\tif (context->context == AUDIT_CTX_SYSCALL)\r\n\t\taudit_log_proctitle();\r\n\r\n\t/* Send end of event record to help user space know we are finished */\r\n\tab = audit_log_start(context, GFP_KERNEL, AUDIT_EOE);\r\n\tif (ab)\r\n\t\taudit_log_end(ab);\r\n\tif (call_panic)\r\n\t\taudit_panic(\"error in audit_log_exit()\");\r\n}", ".how_special": "static void show_special(struct audit_context *context, int *call_panic)\r\n{\r\n\tstruct audit_buffer *ab;\r\n\tint i;\r\n\r\n\tab = audit_log_start(context, GFP_KERNEL, context->type);\r\n\tif (!ab)\r\n\t\treturn;\r\n\r\n\tswitch (context->type) {\r\n\tcase AUDIT_SOCKETCALL: {\r\n\t\tint nargs = context->socketcall.nargs;\r\n\r\n\t\taudit_log_format(ab, \"nargs=%d\", nargs);\r\n\t\tfor (i = 0; i < nargs; i++)\r\n\t\t\taudit_log_format(ab, \" a%d=%lx\", i,\r\n\t\t\t\tcontext->socketcall.args[i]);\r\n\t\tbreak; }\r\n\tcase AUDIT_IPC:\r\n\t\taudit_log_format(ab, \"ouid=%u ogid=%u mode=%#ho\",\r\n\t\t\t\t from_kuid(&init_user_ns, context->ipc.uid),\r\n\t\t\t\t from_kgid(&init_user_ns, context->ipc.gid),\r\n\t\t\t\t context->ipc.mode);\r\n\t\tif (lsmprop_is_set(&context->ipc.oprop)) {\r\n\t\t\tstruct lsm_context lsmctx;\r\n\r\n\t\t\tif (security_lsmprop_to_secctx(&context->ipc.oprop,\r\n\t\t\t\t\t\t       &lsmctx,\r\n\t\t\t\t\t\t       LSM_ID_UNDEF) < 0) {\r\n\t\t\t\t*call_panic = 1;\r\n\t\t\t} else {\r\n\t\t\t\taudit_log_format(ab, \" obj=%s\", lsmctx.context);\r\n\t\t\t\tsecurity_release_secctx(&lsmctx);\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (context->ipc.has_perm) {\r\n\t\t\taudit_log_end(ab);\r\n\t\t\tab = audit_log_start(context, GFP_KERNEL,\r\n\t\t\t\t\t     AUDIT_IPC_SET_PERM);\r\n\t\t\tif (unlikely(!ab))\r\n\t\t\t\treturn;\r\n\t\t\taudit_log_format(ab,\r\n\t\t\t\t\"qbytes=%lx ouid=%u ogid=%u mode=%#ho\",\r\n\t\t\t\tcontext->ipc.qbytes,\r\n\t\t\t\tcontext->ipc.perm_uid,\r\n\t\t\t\tcontext->ipc.perm_gid,\r\n\t\t\t\tcontext->ipc.perm_mode);\r\n\t\t}\r\n\t\tbreak;\r\n\tcase AUDIT_MQ_OPEN:\r\n\t\taudit_log_format(ab,\r\n\t\t\t\"oflag=0x%x mode=%#ho mq_flags=0x%lx mq_maxmsg=%ld \"\r\n\t\t\t\"mq_msgsize=%ld mq_curmsgs=%ld\",\r\n\t\t\tcontext->mq_open.oflag, context->mq_open.mode,\r\n\t\t\tcontext->mq_open.attr.mq_flags,\r\n\t\t\tcontext->mq_open.attr.mq_maxmsg,\r\n\t\t\tcontext->mq_open.attr.mq_msgsize,\r\n\t\t\tcontext->mq_open.attr.mq_curmsgs);\r\n\t\tbreak;\r\n\tcase AUDIT_MQ_SENDRECV:\r\n\t\taudit_log_format(ab,\r\n\t\t\t\"mqdes=%d msg_len=%zd msg_prio=%u \"\r\n\t\t\t\"abs_timeout_sec=%lld abs_timeout_nsec=%ld\",\r\n\t\t\tcontext->mq_sendrecv.mqdes,\r\n\t\t\tcontext->mq_sendrecv.msg_len,\r\n\t\t\tcontext->mq_sendrecv.msg_prio,\r\n\t\t\t(long long) context->mq_sendrecv.abs_timeout.tv_sec,\r\n\t\t\tcontext->mq_sendrecv.abs_timeout.tv_nsec);\r\n\t\tbreak;\r\n\tcase AUDIT_MQ_NOTIFY:\r\n\t\taudit_log_format(ab, \"mqdes=%d sigev_signo=%d\",\r\n\t\t\t\tcontext->mq_notify.mqdes,\r\n\t\t\t\tcontext->mq_notify.sigev_signo);\r\n\t\tbreak;\r\n\tcase AUDIT_MQ_GETSETATTR: {\r\n\t\tstruct mq_attr *attr = &context->mq_getsetattr.mqstat;\r\n\r\n\t\taudit_log_format(ab,\r\n\t\t\t\"mqdes=%d mq_flags=0x%lx mq_maxmsg=%ld mq_msgsize=%ld \"\r\n\t\t\t\"mq_curmsgs=%ld \",\r\n\t\t\tcontext->mq_getsetattr.mqdes,\r\n\t\t\tattr->mq_flags, attr->mq_maxmsg,\r\n\t\t\tattr->mq_msgsize, attr->mq_curmsgs);\r\n\t\tbreak; }\r\n\tcase AUDIT_CAPSET:\r\n\t\taudit_log_format(ab, \"pid=%d\", context->capset.pid);\r\n\t\taudit_log_cap(ab, \"cap_pi\", &context->capset.cap.inheritable);\r\n\t\taudit_log_cap(ab, \"cap_pp\", &context->capset.cap.permitted);\r\n\t\taudit_log_cap(ab, \"cap_pe\", &context->capset.cap.effective);\r\n\t\taudit_log_cap(ab, \"cap_pa\", &context->capset.cap.ambient);\r\n\t\tbreak;\r\n\tcase AUDIT_MMAP:\r\n\t\taudit_log_format(ab, \"fd=%d flags=0x%x\", context->mmap.fd,\r\n\t\t\t\t context->mmap.flags);\r\n\t\tbreak;\r\n\tcase AUDIT_OPENAT2:\r\n\t\taudit_log_format(ab, \"oflag=0%llo mode=0%llo resolve=0x%llx\",\r\n\t\t\t\t context->openat2.flags,\r\n\t\t\t\t context->openat2.mode,\r\n\t\t\t\t context->openat2.resolve);\r\n\t\tbreak;\r\n\tcase AUDIT_EXECVE:\r\n\t\taudit_log_execve_info(context, &ab);\r\n\t\tbreak;\r\n\tcase AUDIT_KERN_MODULE:\r\n\t\taudit_log_format(ab, \"name=\");\r\n\t\tif (context->module.name) {\r\n\t\t\taudit_log_untrustedstring(ab, context->module.name);\r\n\t\t} else\r\n\t\t\taudit_log_format(ab, \"(null)\");\r\n\r\n\t\tbreak;\r\n\tcase AUDIT_TIME_ADJNTPVAL:\r\n\tcase AUDIT_TIME_INJOFFSET:\r\n\t\t/* this call deviates from the rest, eating the buffer */\r\n\t\taudit_log_time(context, &ab);\r\n\t\tbreak;\r\n\t}\r\n\taudit_log_end(ab);\r\n}", ".udit_log_fcaps": "static void audit_log_fcaps(struct audit_buffer *ab, struct audit_names *name)\r\n{\r\n\tif (name->fcap_ver == -1) {\r\n\t\taudit_log_format(ab, \" cap_fe=? cap_fver=? cap_fp=? cap_fi=?\");\r\n\t\treturn;\r\n\t}\r\n\taudit_log_cap(ab, \"cap_fp\", &name->fcap.permitted);\r\n\taudit_log_cap(ab, \"cap_fi\", &name->fcap.inheritable);\r\n\taudit_log_format(ab, \" cap_fe=%d cap_fver=%x cap_frootid=%d\",\r\n\t\t\t name->fcap.fE, name->fcap_ver,\r\n\t\t\t from_kuid(&init_user_ns, name->fcap.rootid));\r\n}", ".udit_log_name": "static void audit_log_name(struct audit_context *context, struct audit_names *n,\r\n\t\t    const struct path *path, int record_num, int *call_panic)\r\n{\r\n\tstruct audit_buffer *ab;\r\n\r\n\tab = audit_log_start(context, GFP_KERNEL, AUDIT_PATH);\r\n\tif (!ab)\r\n\t\treturn;\r\n\r\n\taudit_log_format(ab, \"item=%d\", record_num);\r\n\r\n\tif (path)\r\n\t\taudit_log_d_path(ab, \" name=\", path);\r\n\telse if (n->name) {\r\n\t\tswitch (n->name_len) {\r\n\t\tcase AUDIT_NAME_FULL:\r\n\t\t\t/* log the full path */\r\n\t\t\taudit_log_format(ab, \" name=\");\r\n\t\t\taudit_log_untrustedstring(ab, n->name->name);\r\n\t\t\tbreak;\r\n\t\tcase 0:\r\n\t\t\t/* name was specified as a relative path and the\r\n\t\t\t * directory component is the cwd\r\n\t\t\t */\r\n\t\t\tif (context->pwd.dentry && context->pwd.mnt)\r\n\t\t\t\taudit_log_d_path(ab, \" name=\", &context->pwd);\r\n\t\t\telse\r\n\t\t\t\taudit_log_format(ab, \" name=(null)\");\r\n\t\t\tbreak;\r\n\t\tdefault:\r\n\t\t\t/* log the name's directory component */\r\n\t\t\taudit_log_format(ab, \" name=\");\r\n\t\t\taudit_log_n_untrustedstring(ab, n->name->name,\r\n\t\t\t\t\t\t    n->name_len);\r\n\t\t}\r\n\t} else\r\n\t\taudit_log_format(ab, \" name=(null)\");\r\n\r\n\tif (n->ino != AUDIT_INO_UNSET)\r\n\t\taudit_log_format(ab, \" inode=%lu dev=%02x:%02x mode=%#ho ouid=%u ogid=%u rdev=%02x:%02x\",\r\n\t\t\t\t n->ino,\r\n\t\t\t\t MAJOR(n->dev),\r\n\t\t\t\t MINOR(n->dev),\r\n\t\t\t\t n->mode,\r\n\t\t\t\t from_kuid(&init_user_ns, n->uid),\r\n\t\t\t\t from_kgid(&init_user_ns, n->gid),\r\n\t\t\t\t MAJOR(n->rdev),\r\n\t\t\t\t MINOR(n->rdev));\r\n\tif (lsmprop_is_set(&n->oprop)) {\r\n\t\tstruct lsm_context ctx;\r\n\r\n\t\tif (security_lsmprop_to_secctx(&n->oprop, &ctx,\r\n\t\t\t\t\t       LSM_ID_UNDEF) < 0) {\r\n\t\t\tif (call_panic)\r\n\t\t\t\t*call_panic = 2;\r\n\t\t} else {\r\n\t\t\taudit_log_format(ab, \" obj=%s\", ctx.context);\r\n\t\t\tsecurity_release_secctx(&ctx);\r\n\t\t}\r\n\t}\r\n\r\n\t/* log the audit_names record type */\r\n\tswitch (n->type) {\r\n\tcase AUDIT_TYPE_NORMAL:\r\n\t\taudit_log_format(ab, \" nametype=NORMAL\");\r\n\t\tbreak;\r\n\tcase AUDIT_TYPE_PARENT:\r\n\t\taudit_log_format(ab, \" nametype=PARENT\");\r\n\t\tbreak;\r\n\tcase AUDIT_TYPE_CHILD_DELETE:\r\n\t\taudit_log_format(ab, \" nametype=DELETE\");\r\n\t\tbreak;\r\n\tcase AUDIT_TYPE_CHILD_CREATE:\r\n\t\taudit_log_format(ab, \" nametype=CREATE\");\r\n\t\tbreak;\r\n\tdefault:\r\n\t\taudit_log_format(ab, \" nametype=UNKNOWN\");\r\n\t\tbreak;\r\n\t}\r\n\r\n\taudit_log_fcaps(ab, n);\r\n\taudit_log_end(ab);\r\n}", ".udit_log_proctitle": "static void audit_log_proctitle(void)\r\n{\r\n\tint res;\r\n\tchar *buf;\r\n\tchar *msg = \"(null)\";\r\n\tint len = strlen(msg);\r\n\tstruct audit_context *context = audit_context();\r\n\tstruct audit_buffer *ab;\r\n\r\n\tab = audit_log_start(context, GFP_KERNEL, AUDIT_PROCTITLE);\r\n\tif (!ab)\r\n\t\treturn;\t/* audit_panic or being filtered */\r\n\r\n\taudit_log_format(ab, \"proctitle=\");\r\n\r\n\t/* Not  cached */\r\n\tif (!context->proctitle.value) {\r\n\t\tbuf = kmalloc(MAX_PROCTITLE_AUDIT_LEN, GFP_KERNEL);\r\n\t\tif (!buf)\r\n\t\t\tgoto out;\r\n\t\t/* Historically called this from procfs naming */\r\n\t\tres = get_cmdline(current, buf, MAX_PROCTITLE_AUDIT_LEN);\r\n\t\tif (res == 0) {\r\n\t\t\tkfree(buf);\r\n\t\t\tgoto out;\r\n\t\t}\r\n\t\tres = audit_proctitle_rtrim(buf, res);\r\n\t\tif (res == 0) {\r\n\t\t\tkfree(buf);\r\n\t\t\tgoto out;\r\n\t\t}\r\n\t\tcontext->proctitle.value = buf;\r\n\t\tcontext->proctitle.len = res;\r\n\t}\r\n\tmsg = context->proctitle.value;\r\n\tlen = context->proctitle.len;\r\nout:\r\n\taudit_log_n_untrustedstring(ab, msg, len);\r\n\taudit_log_end(ab);\r\n}", ".udit_copy_inode": "static void audit_copy_inode(struct audit_names *name,\r\n\t\t\t     const struct dentry *dentry,\r\n\t\t\t     struct inode *inode, unsigned int flags)\r\n{\r\n\tname->ino   = inode->i_ino;\r\n\tname->dev   = inode->i_sb->s_dev;\r\n\tname->mode  = inode->i_mode;\r\n\tname->uid   = inode->i_uid;\r\n\tname->gid   = inode->i_gid;\r\n\tname->rdev  = inode->i_rdev;\r\n\tsecurity_inode_getlsmprop(inode, &name->oprop);\r\n\tif (flags & AUDIT_INODE_NOEVAL) {\r\n\t\tname->fcap_ver = -1;\r\n\t\treturn;\r\n\t}\r\n\taudit_copy_fcaps(name, dentry);\r\n}", ".udit_core_dumps": "void audit_core_dumps(long signr)\r\n{\r\n\tstruct audit_buffer *ab;\r\n\r\n\tif (!audit_enabled)\r\n\t\treturn;\r\n\r\n\tif (signr == SIGQUIT)\t/* don't care for those */\r\n\t\treturn;\r\n\r\n\tab = audit_log_start(audit_context(), GFP_KERNEL, AUDIT_ANOM_ABEND);\r\n\tif (unlikely(!ab))\r\n\t\treturn;\r\n\taudit_log_task(ab);\r\n\taudit_log_format(ab, \" sig=%ld res=1\", signr);\r\n\taudit_log_end(ab);\r\n}", ".udit_seccomp": "void audit_seccomp(unsigned long syscall, long signr, int code)\r\n{\r\n\tstruct audit_buffer *ab;\r\n\r\n\tab = audit_log_start(audit_context(), GFP_KERNEL, AUDIT_SECCOMP);\r\n\tif (unlikely(!ab))\r\n\t\treturn;\r\n\taudit_log_task(ab);\r\n\taudit_log_format(ab, \" sig=%ld arch=%x syscall=%ld compat=%d ip=0x%lx code=0x%x\",\r\n\t\t\t signr, syscall_get_arch(current), syscall,\r\n\t\t\t in_compat_syscall(), KSTK_EIP(current), code);\r\n\taudit_log_end(ab);\r\n}"}, "function_name": "audit_seccomp_actions_logged"}
{"function_id": null, "caller": {".s_known_bootstrap_register": "static int\r\nis_known_bootstrap_register(uint64_t addr, u3v_conv_info_t * u3v_conv_info)\r\n{\r\n    const char* address_string = NULL;\r\n    uint32_t offset_address;\r\n    /* check if this is the access to one of the base address registers */\r\n    if ( addr < 0x10000 ) {\r\n        offset_address = (uint32_t)addr;\r\n        address_string = try_val_to_str(offset_address, bootstrap_register_names_abrm);\r\n    }\r\n    if ( u3v_conv_info->sbrm_addr != 0 &&  (addr >= u3v_conv_info->sbrm_addr)) {\r\n        offset_address = (uint32_t)( addr - u3v_conv_info->sbrm_addr);\r\n        address_string = try_val_to_str(offset_address, bootstrap_register_names_sbrm);\r\n    }\r\n    if ( u3v_conv_info->sirm_addr != 0 &&  (addr >= u3v_conv_info->sirm_addr)) {\r\n        offset_address = (uint32_t)( addr - u3v_conv_info->sirm_addr);\r\n        address_string = try_val_to_str(offset_address, bootstrap_register_names_sirm);\r\n    }\r\n    if ( u3v_conv_info->eirm_addr != 0 &&  (addr >= u3v_conv_info->eirm_addr)) {\r\n        offset_address = (uint32_t)( addr - u3v_conv_info->eirm_addr);\r\n        address_string = try_val_to_str(offset_address, bootstrap_register_names_eirm);\r\n    }\r\n    return address_string != NULL;\r\n}", ".issect_u3v_register": "static int\r\ndissect_u3v_register(uint64_t addr, proto_tree *branch, tvbuff_t *tvb, int offset, int length, u3v_conv_info_t *u3v_conv_info)\r\n{\r\n    bool isABRM = false, isSBRM = false, isSIRM = false, isEIRM = false;\r\n    /* check if this is the access to one of the base address registers */\r\n    if ( addr < 0x10000 ) {\r\n        isABRM = true;\r\n        switch (addr) {\r\n        case U3V_ABRM_GENCP_VERSION:\r\n            proto_tree_add_item(branch, hf_u3v_bootstrap_GenCP_Version, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\n            break;\r\n        case U3V_ABRM_MANUFACTURER_NAME:\r\n            if ( length <= 64 ) {\r\n                proto_tree_add_item(branch, hf_u3v_bootstrap_Manufacturer_Name, tvb, offset, length, ENC_ASCII);\r\n            }\r\n            break;\r\n        case U3V_ABRM_MODEL_NAME:\r\n            if ( length <= 64 ) {\r\n                proto_tree_add_item(branch, hf_u3v_bootstrap_Model_Name, tvb, offset, length, ENC_ASCII);\r\n            }\r\n            break;\r\n        case U3V_ABRM_FAMILY_NAME:\r\n            if ( length <= 64 ) {\r\n                proto_tree_add_item(branch, hf_u3v_bootstrap_Family_Name, tvb, offset, length, ENC_ASCII);\r\n            }\r\n            break;\r\n        case U3V_ABRM_DEVICE_VERSION:\r\n            if ( length <= 64 ) {\r\n                proto_tree_add_item(branch, hf_u3v_bootstrap_Device_Version, tvb, offset, length, ENC_ASCII);\r\n            }\r\n            break;\r\n        case U3V_ABRM_MANUFACTURER_INFO:\r\n            if ( length <= 64 ) {\r\n                proto_tree_add_item(branch, hf_u3v_bootstrap_Manufacturer_Info, tvb, offset, length, ENC_ASCII);\r\n            }\r\n            break;\r\n        case U3V_ABRM_SERIAL_NUMBER:\r\n            if ( length <= 64 ) {\r\n                proto_tree_add_item(branch, hf_u3v_bootstrap_Serial_Number, tvb, offset, length, ENC_ASCII);\r\n            }\r\n            break;\r\n        case U3V_ABRM_USER_DEFINED_NAME:\r\n            if ( length <= 64 ) {\r\n                proto_tree_add_item(branch, hf_u3v_bootstrap_User_Defined_Name, tvb, offset, length, ENC_ASCII);\r\n            }\r\n            break;\r\n        case U3V_ABRM_DEVICE_CAPABILITY:\r\n            proto_tree_add_item(branch, hf_u3v_bootstrap_Device_Capability, tvb, offset, 8, ENC_LITTLE_ENDIAN);\r\n            break;\r\n        case U3V_ABRM_MAXIMUM_DEVICE_RESPONSE_TIME:\r\n            proto_tree_add_item(branch, hf_u3v_bootstrap_Maximum_Device_Response_Time, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\n            break;\r\n        case U3V_ABRM_MANIFEST_TABLE_ADDRESS:\r\n            proto_tree_add_item(branch, hf_u3v_bootstrap_Manifest_Table_Address, tvb, offset, 8, ENC_LITTLE_ENDIAN);\r\n            break;\r\n        case U3V_ABRM_SBRM_ADDRESS:\r\n            proto_tree_add_item(branch, hf_u3v_bootstrap_SBRM_Address, tvb, offset, 8, ENC_LITTLE_ENDIAN);\r\n            break;\r\n        case U3V_ABRM_DEVICE_CONFIGURATION:\r\n            proto_tree_add_item(branch, hf_u3v_bootstrap_Device_Configuration, tvb, offset, 8, ENC_LITTLE_ENDIAN);\r\n            break;\r\n        case U3V_ABRM_HEARTBEAT_TIMEOUT:\r\n            proto_tree_add_item(branch, hf_u3v_bootstrap_Heartbeat_Timeout, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\n            break;\r\n        case U3V_ABRM_MESSAGE_CHANNEL_CHANNEL_ID:\r\n            proto_tree_add_item(branch, hf_u3v_bootstrap_Message_Channel_channel_id, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\n            break;\r\n        case U3V_ABRM_TIMESTAMP:\r\n            proto_tree_add_item(branch, hf_u3v_bootstrap_Timestamp, tvb, offset, 8, ENC_LITTLE_ENDIAN);\r\n            break;\r\n        case U3V_ABRM_TIMESTAMP_LATCH:\r\n            proto_tree_add_item(branch, hf_u3v_bootstrap_Timestamp_Latch, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\n            break;\r\n        case U3V_ABRM_TIMESTAMP_INCREMENT:\r\n            proto_tree_add_item(branch, hf_u3v_bootstrap_Timestamp_Increment, tvb, offset, 8, ENC_LITTLE_ENDIAN);\r\n            break;\r\n        case U3V_ABRM_ACCESS_PRIVILEGE:\r\n            proto_tree_add_item(branch, hf_u3v_bootstrap_Access_Privilege, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\n            break;\r\n        case U3V_ABRM_PROTOCOL_ENDIANNESS:\r\n            proto_tree_add_item(branch, hf_u3v_bootstrap_Protocol_Endianness, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\n            break;\r\n        case U3V_ABRM_IMPLEMENTATION_ENDIANNESS:\r\n            proto_tree_add_item(branch, hf_u3v_bootstrap_Implementation_Endianness, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\n            break;\r\n        default:\r\n            isABRM = false;\r\n            break;\r\n        }\r\n    }\r\n    if ( u3v_conv_info->sbrm_addr != 0 && (addr >= u3v_conv_info->sbrm_addr)) {\r\n        uint64_t map_offset = addr - u3v_conv_info->sbrm_addr;\r\n        isSBRM = true;\r\n        switch(map_offset) {\r\n        case U3V_SBRM_U3V_VERSION:\r\n            proto_tree_add_item(branch, hf_u3v_bootstrap_U3V_Version, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\n            break;\r\n        case U3V_SBRM_U3VCP_CAPABILITY_REGISTER:\r\n            proto_tree_add_item(branch, hf_u3v_bootstrap_U3VCP_Capability_Register, tvb, offset, 8, ENC_LITTLE_ENDIAN);\r\n            break;\r\n        case U3V_SBRM_U3VCP_CONFIGURATION_REGISTER:\r\n            proto_tree_add_item(branch, hf_u3v_bootstrap_U3VCP_Configuration_Register, tvb, offset, 8, ENC_LITTLE_ENDIAN);\r\n            break;\r\n        case U3V_SBRM_MAXIMUM_COMMAND_TRANSFER_LENGTH:\r\n            proto_tree_add_item(branch, hf_u3v_bootstrap_Maximum_Command_Transfer_Length, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\n            break;\r\n        case U3V_SBRM_MAXIMUM_ACKNOWLEDGE_TRANSFER_LENGTH:\r\n            proto_tree_add_item(branch, hf_u3v_bootstrap_Maximum_Acknowledge_Transfer_Length, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\n            break;\r\n        case U3V_SBRM_NUMBER_OF_STREAM_CHANNELS:\r\n            proto_tree_add_item(branch, hf_u3v_bootstrap_Number_of_Stream_Channels, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\n            break;\r\n        case U3V_SBRM_SIRM_ADDRESS:\r\n            proto_tree_add_item(branch, hf_u3v_bootstrap_SIRM_Address, tvb, offset, 8, ENC_LITTLE_ENDIAN);\r\n            break;\r\n        case U3V_SBRM_SIRM_LENGTH:\r\n            proto_tree_add_item(branch, hf_u3v_bootstrap_SIRM_Length, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\n            break;\r\n        case U3V_SBRM_EIRM_ADDRESS:\r\n            proto_tree_add_item(branch, hf_u3v_bootstrap_EIRM_Address, tvb, offset, 8, ENC_LITTLE_ENDIAN);\r\n            break;\r\n        case U3V_SBRM_EIRM_LENGTH:\r\n            proto_tree_add_item(branch, hf_u3v_bootstrap_EIRM_Length, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\n            break;\r\n        case U3V_SBRM_IIDC2_ADDRESS:\r\n            proto_tree_add_item(branch, hf_u3v_bootstrap_IIDC2_Address, tvb, offset, 8, ENC_LITTLE_ENDIAN);\r\n            break;\r\n        case U3V_SBRM_CURRENT_SPEED:\r\n            proto_tree_add_item(branch, hf_u3v_bootstrap_Current_Speed, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\n            break;\r\n        default:\r\n            isSBRM = false;\r\n            break;\r\n        }\r\n    }\r\n    if ( u3v_conv_info->sirm_addr != 0 && (addr >= u3v_conv_info->sirm_addr)) {\r\n        uint64_t map_offset = addr - u3v_conv_info->sirm_addr;\r\n        isSIRM = true;\r\n        switch(map_offset) {\r\n        case U3V_SIRM_SI_INFO:\r\n            proto_tree_add_item(branch, hf_u3v_bootstrap_SI_Info, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\n            break;\r\n        case U3V_SIRM_SI_CONTROL:\r\n            proto_tree_add_item(branch, hf_u3v_bootstrap_SI_Control, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\n            break;\r\n        case U3V_SIRM_SI_REQUIRED_PAYLOAD_SIZE:\r\n            proto_tree_add_item(branch, hf_u3v_bootstrap_SI_Required_Payload_Size, tvb, offset, 8, ENC_LITTLE_ENDIAN);\r\n            break;\r\n        case U3V_SIRM_SI_REQUIRED_LEADER_SIZE:\r\n            proto_tree_add_item(branch, hf_u3v_bootstrap_SI_Required_Leader_Size, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\n            break;\r\n        case U3V_SIRM_SI_REQUIRED_TRAILER_SIZE:\r\n            proto_tree_add_item(branch, hf_u3v_bootstrap_SI_Required_Trailer_Size, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\n            break;\r\n        case U3V_SIRM_SI_MAXIMUM_LEADER_SIZE:\r\n            proto_tree_add_item(branch, hf_u3v_bootstrap_SI_Maximum_Leader_Size, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\n            break;\r\n        case U3V_SIRM_SI_PAYLOAD_TRANSFER_SIZE:\r\n            proto_tree_add_item(branch, hf_u3v_bootstrap_SI_Payload_Transfer_Size, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\n            break;\r\n        case U3V_SIRM_SI_PAYLOAD_TRANSFER_COUNT:\r\n            proto_tree_add_item(branch, hf_u3v_bootstrap_SI_Payload_Transfer_Count, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\n            break;\r\n        case U3V_SIRM_SI_PAYLOAD_FINAL_TRANSFER1_SIZE:\r\n            proto_tree_add_item(branch, hf_u3v_bootstrap_SI_Payload_Final_Transfer1_Size, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\n            break;\r\n        case U3V_SIRM_SI_PAYLOAD_FINAL_TRANSFER2_SIZE:\r\n            proto_tree_add_item(branch, hf_u3v_bootstrap_SI_Payload_Final_Transfer2_Size, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\n            break;\r\n        case U3V_SIRM_SI_MAXIMUM_TRAILER_SIZE:\r\n            proto_tree_add_item(branch, hf_u3v_bootstrap_SI_Maximum_Trailer_Size, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\n            break;\r\n        default:\r\n            isSIRM = false;\r\n            break;\r\n        }\r\n    }\r\n    if ( u3v_conv_info->eirm_addr != 0 && (addr >= u3v_conv_info->eirm_addr)) {\r\n        uint64_t map_offset = addr -u3v_conv_info->eirm_addr;\r\n        isEIRM=true;\r\n        switch(map_offset) {\r\n        case U3V_EIRM_EI_CONTROL:\r\n            proto_tree_add_item(branch, hf_u3v_bootstrap_EI_Control, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\n            break;\r\n        case U3V_EIRM_MAXIMUM_EVENT_TRANSFER_LENGTH:\r\n            proto_tree_add_item(branch, hf_u3v_bootstrap_Maximum_Event_Transfer_Length, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\n            break;\r\n        case U3V_EIRM_EVENT_TEST_CONTROL:\r\n            proto_tree_add_item(branch, hf_u3v_bootstrap_Event_Test_Control, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\n            break;\r\n        default:\r\n            isEIRM = false;\r\n            break;\r\n        }\r\n    }\r\n    if(isABRM || isSBRM || isSIRM || isEIRM ) {\r\n        return 1;\r\n    }\r\n    return 0;\r\n}", ".issect_u3v_register_bases": "static void\r\ndissect_u3v_register_bases(uint64_t addr, tvbuff_t *tvb, int offset, u3v_conv_info_t * u3v_conv_info)\r\n{\r\n    if ( addr < 0x10000 ) {\r\n        switch (addr) {\r\n        case U3V_ABRM_SBRM_ADDRESS:\r\n            u3v_conv_info->sbrm_addr = tvb_get_letoh64(tvb, offset);\r\n            break;\r\n        case U3V_ABRM_MANIFEST_TABLE_ADDRESS:\r\n            u3v_conv_info->manifest_addr = tvb_get_letoh64(tvb, offset);\r\n            break;\r\n        }\r\n    }\r\n    if ( u3v_conv_info->sbrm_addr != 0 && (addr >= u3v_conv_info->sbrm_addr)) {\r\n        addr -= u3v_conv_info->sbrm_addr;\r\n        switch(addr) {\r\n        case U3V_SBRM_SIRM_ADDRESS:\r\n            u3v_conv_info->sirm_addr = tvb_get_letoh64(tvb, offset);\r\n            break;\r\n        case U3V_SBRM_EIRM_ADDRESS:\r\n            u3v_conv_info->eirm_addr = tvb_get_letoh64(tvb, offset);\r\n            break;\r\n        case U3V_SBRM_IIDC2_ADDRESS:\r\n            u3v_conv_info->iidc2_addr = tvb_get_letoh64(tvb, offset);\r\n            break;\r\n        }\r\n    }\r\n}", ".issect_u3v_read_mem_cmd": "static void\r\ndissect_u3v_read_mem_cmd(proto_tree *u3v_telegram_tree, tvbuff_t *tvb, packet_info *pinfo, int startoffset, int length, u3v_conv_info_t *u3v_conv_info, gencp_transaction_t * gencp_trans)\r\n{\r\n    uint64_t addr = 0;\r\n    const char* address_string = NULL;\r\n    bool is_custom_register = false;\r\n    uint16_t count = 0;\r\n    int offset = startoffset;\r\n    proto_item *item = NULL;\r\n\r\n    addr = tvb_get_letoh64(tvb, offset);\r\n    gencp_trans->address = addr;\r\n\r\n    address_string = get_register_name_from_address(addr, pinfo->pool, &is_custom_register, u3v_conv_info);\r\n    count = tvb_get_letohs(tvb, offset + 10);   /* Number of bytes to read from memory */\r\n\r\n    gencp_trans->count = count;\r\n    if ( 0xffffffff00000000 & addr ) {\r\n        col_append_fstr(pinfo->cinfo, COL_INFO, \" (0x%016\" PRIX64 \" (%d) bytes) %s\", addr, count, address_string);\r\n    } else {\r\n        col_append_fstr(pinfo->cinfo, COL_INFO, \" (0x%08X (%d) bytes)\", (uint32_t)addr, count);\r\n    }\r\n\r\n\r\n    item = proto_tree_add_item(u3v_telegram_tree, hf_u3v_scd_readmem_cmd, tvb, offset, length, ENC_NA);\r\n    u3v_telegram_tree = proto_item_add_subtree(item, ett_u3v_payload_cmd);\r\n\r\n    /* address */\r\n    if (is_known_bootstrap_register(addr, u3v_conv_info)) {\r\n        item = proto_tree_add_uint64(u3v_telegram_tree, hf_u3v_address, tvb, offset, 8, addr);\r\n        proto_item_append_text(item, \" %s\", address_string);\r\n    } else {\r\n        proto_tree_add_item(u3v_telegram_tree, hf_u3v_custom_memory_addr, tvb, offset, 8, ENC_LITTLE_ENDIAN);\r\n    }\r\n    offset += 8;\r\n\r\n    /* reserved field */\r\n    proto_tree_add_item(u3v_telegram_tree, hf_u3v_reserved, tvb, offset, 2, ENC_NA);\r\n    offset += 2;\r\n\r\n    /* count */\r\n    proto_tree_add_item(u3v_telegram_tree, hf_u3v_count, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\n}", ".issect_u3v_write_mem_cmd": "static void\r\ndissect_u3v_write_mem_cmd(proto_tree *u3v_telegram_tree, tvbuff_t *tvb, packet_info *pinfo, int startoffset, int length, u3v_conv_info_t *u3v_conv_info, gencp_transaction_t *gencp_trans)\r\n{\r\n    const char* address_string = NULL;\r\n    bool is_custom_register = false;\r\n    uint64_t addr = 0;\r\n    unsigned byte_count = 0;\r\n    proto_item *item = NULL;\r\n    unsigned offset = startoffset + 8;\r\n\r\n    addr = tvb_get_letoh64(tvb, startoffset);\r\n    byte_count = length - 8;\r\n    address_string = get_register_name_from_address(addr, pinfo->pool, &is_custom_register, u3v_conv_info);\r\n\r\n    gencp_trans->address = addr;\r\n    gencp_trans->count = byte_count;\r\n\r\n    /* fill in Info column in Wireshark GUI */\r\n    col_append_fstr(pinfo->cinfo, COL_INFO, \"%s: %d bytes\", address_string, byte_count);\r\n\r\n\r\n    /* Subtree initialization for Payload Data: WRITEMEM_CMD */\r\n    item = proto_tree_add_item(u3v_telegram_tree, hf_u3v_scd_writemem_cmd, tvb, startoffset, length, ENC_NA);\r\n    u3v_telegram_tree = proto_item_add_subtree(item, ett_u3v_payload_cmd);\r\n\r\n    if (is_known_bootstrap_register(addr, u3v_conv_info)) {\r\n        item = proto_tree_add_uint64(u3v_telegram_tree, hf_u3v_address, tvb, startoffset, 8, addr);\r\n        proto_item_append_text(item, \" %s\", address_string);\r\n        dissect_u3v_register(addr, u3v_telegram_tree, tvb, offset, byte_count, u3v_conv_info);\r\n    } else {\r\n        proto_tree_add_item(u3v_telegram_tree, hf_u3v_custom_memory_addr, tvb, startoffset, 8, ENC_LITTLE_ENDIAN);\r\n        proto_tree_add_item(u3v_telegram_tree, hf_u3v_custom_memory_data, tvb, startoffset + 8, byte_count, ENC_NA);\r\n    }\r\n\r\n}", ".issect_u3v_event_cmd": "static void\r\ndissect_u3v_event_cmd(proto_tree *u3v_telegram_tree, tvbuff_t *tvb, packet_info *pinfo, int startoffset, int length)\r\n{\r\n    int32_t eventid;\r\n    int offset = startoffset;\r\n    proto_item *item = NULL;\r\n\r\n    /* Get event ID */\r\n    eventid = tvb_get_letohs(tvb, offset + 2);\r\n\r\n    /* fill in Info column in Wireshark GUI */\r\n    col_append_fstr(pinfo->cinfo, COL_INFO, \"[ID: 0x%04X]\", eventid);\r\n\r\n\r\n    item = proto_tree_add_item(u3v_telegram_tree, hf_u3v_scd_event_cmd, tvb, offset, length, ENC_NA);\r\n    u3v_telegram_tree = proto_item_add_subtree(item, ett_u3v_payload_cmd);\r\n\r\n    offset += 2;\r\n\r\n    /* Use range to determine type of event */\r\n    if ((eventid >= 0x0000) && (eventid <= 0x8000)) {\r\n        /* Standard ID */\r\n        proto_tree_add_item(u3v_telegram_tree, hf_u3v_eventcmd_id, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\n    } else if ((eventid >= 0x8001) && (eventid <= 0x8FFF)) {\r\n        /* Error */\r\n        proto_tree_add_item(u3v_telegram_tree, hf_u3v_eventcmd_error_id, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\n    } else if ((eventid >= 0x9000) && (eventid <= 0xFFFF)) {\r\n        /* Device specific */\r\n        proto_tree_add_item(u3v_telegram_tree, hf_u3v_eventcmd_device_specific_id, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\n    }\r\n    offset += 2;\r\n\r\n    /* Timestamp (64 bit) associated with event */\r\n    proto_tree_add_item(u3v_telegram_tree, hf_u3v_eventcmd_timestamp, tvb, offset, 8, ENC_LITTLE_ENDIAN);\r\n    offset += 8;\r\n\r\n    /* Data */\r\n    if (length > offset ) {\r\n        proto_tree_add_item(u3v_telegram_tree, hf_u3v_eventcmd_data, tvb, offset, length - 12, ENC_NA);\r\n    }\r\n}", ".issect_u3v_read_mem_ack": "static void\r\ndissect_u3v_read_mem_ack(proto_tree *u3v_telegram_tree, tvbuff_t *tvb, packet_info *pinfo, int startoffset, int length, u3v_conv_info_t *u3v_conv_info, gencp_transaction_t * gencp_trans)\r\n{\r\n    uint64_t addr = 0;\r\n    const char *address_string = NULL;\r\n    bool is_custom_register = false;\r\n    bool have_address = (0 != gencp_trans->cmd_frame);\r\n    proto_item *item = NULL;\r\n    unsigned offset = startoffset;\r\n    unsigned byte_count = (length);\r\n\r\n    addr = gencp_trans->address;\r\n    dissect_u3v_register_bases(addr, tvb, startoffset, u3v_conv_info);\r\n    if (have_address) {\r\n        address_string = get_register_name_from_address(addr, pinfo->pool, &is_custom_register, u3v_conv_info);\r\n        /* Fill in Wireshark GUI Info column */\r\n        col_append_str(pinfo->cinfo, COL_INFO, address_string);\r\n    }\r\n\r\n\r\n    /* Subtree initialization for Payload Data: READMEM_ACK */\r\n    item = proto_tree_add_item(u3v_telegram_tree, hf_u3v_scd_ack_readmem_ack, tvb, startoffset, length, ENC_NA);\r\n    u3v_telegram_tree = proto_item_add_subtree(item, ett_u3v_payload_cmd);\r\n\r\n    /* Bootstrap register known address */\r\n    if (have_address) {\r\n        item = proto_tree_add_uint64(u3v_telegram_tree, hf_u3v_address, tvb, 0,0 , addr);\r\n        proto_item_set_generated(item);\r\n\r\n        if (is_known_bootstrap_register(addr, u3v_conv_info)) {\r\n            dissect_u3v_register(addr, u3v_telegram_tree, tvb, offset, byte_count, u3v_conv_info);\r\n        } else {\r\n            proto_tree_add_item(u3v_telegram_tree, hf_u3v_custom_memory_data, tvb, startoffset, length, ENC_NA);\r\n        }\r\n    }\r\n}", ".issect_u3v_write_mem_ack": "static void\r\ndissect_u3v_write_mem_ack(proto_tree *u3v_telegram_tree, tvbuff_t *tvb, packet_info *pinfo, int startoffset, int length, u3v_conv_info_t *u3v_conv_info , gencp_transaction_t * gencp_trans)\r\n{\r\n    uint64_t addr = 0;\r\n    int offset = startoffset;\r\n    const char *address_string = NULL;\r\n    bool is_custom_register = false;\r\n    bool have_address = (0 != gencp_trans->cmd_frame);\r\n    proto_item *item = NULL;\r\n\r\n    addr = gencp_trans->address;\r\n    if (have_address) {\r\n        address_string = get_register_name_from_address(addr, pinfo->pool, &is_custom_register, u3v_conv_info);\r\n\r\n        /* Fill in Wireshark GUI Info column */\r\n        col_append_str(pinfo->cinfo, COL_INFO, address_string);\r\n    }\r\n\r\n    item = proto_tree_add_item(u3v_telegram_tree, hf_u3v_scd_writemem_ack, tvb, startoffset, length, ENC_NA);\r\n    u3v_telegram_tree = proto_item_add_subtree(item, ett_u3v_payload_cmd);\r\n\r\n    if (have_address) {\r\n            item = proto_tree_add_uint64(u3v_telegram_tree, hf_u3v_address, tvb, 0,0 , addr);\r\n            proto_item_set_generated(item);\r\n        }\r\n    /* Number of bytes successfully written to the device register map */\r\n    if ( length == 4 ) {\r\n\r\n        /* reserved field */\r\n        proto_tree_add_item(u3v_telegram_tree, hf_u3v_reserved, tvb, offset, 2, ENC_NA);\r\n        offset += 2;\r\n\r\n        proto_tree_add_item(u3v_telegram_tree, hf_u3v_count, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\n    }\r\n}", ".issect_u3v_pending_ack": "static void\r\ndissect_u3v_pending_ack(proto_tree *u3v_telegram_tree, tvbuff_t *tvb, packet_info *pinfo _U_, int startoffset, int length, u3v_conv_info_t *u3v_conv_info _U_, gencp_transaction_t *gencp_trans _U_)\r\n{\r\n    proto_item *item = NULL;\r\n    unsigned offset = startoffset;\r\n\r\n    /* Fill in Wireshark GUI Info column */\r\n    col_append_fstr(pinfo->cinfo, COL_INFO, \" %d ms\", tvb_get_letohs(tvb, startoffset+2));\r\n\r\n    item = proto_tree_add_item(u3v_telegram_tree, hf_u3v_ccd_pending_ack, tvb, startoffset, length, ENC_NA);\r\n    u3v_telegram_tree = proto_item_add_subtree(item, ett_u3v_payload_cmd);\r\n\r\n    /* reserved field */\r\n    proto_tree_add_item(u3v_telegram_tree, hf_u3v_reserved, tvb, offset, 2, ENC_NA);\r\n    offset += 2;\r\n\r\n    proto_tree_add_item(u3v_telegram_tree, hf_u3v_time_to_completion, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\n}", ".issect_u3v_stream_leader": "static void\r\ndissect_u3v_stream_leader(proto_tree *u3v_telegram_tree, tvbuff_t *tvb, packet_info *pinfo, urb_info_t *urb _U_)\r\n{\r\n    uint32_t offset = 0;\r\n    uint32_t payload_type = 0;\r\n    uint64_t block_id = 0;\r\n    proto_item *item = NULL;\r\n\r\n    /* Subtree initialization for Stream Leader */\r\n    item = proto_tree_add_item(u3v_telegram_tree, hf_u3v_stream_leader, tvb, 0, -1, ENC_NA);\r\n    u3v_telegram_tree = proto_item_add_subtree(item, ett_u3v_stream_leader);\r\n\r\n    /* Add the prefix code: */\r\n    proto_tree_add_item(u3v_telegram_tree, hf_u3v_stream_prefix, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\n    offset += 4;\r\n\r\n    /* reserved field */\r\n    proto_tree_add_item(u3v_telegram_tree, hf_u3v_stream_reserved, tvb, offset, 2, ENC_NA);\r\n    offset += 2;\r\n\r\n    /* leader size */\r\n    proto_tree_add_item(u3v_telegram_tree, hf_u3v_stream_leader_size, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\n    offset += 2;\r\n\r\n    /* block id */\r\n    block_id = tvb_get_letoh64(tvb, offset);\r\n    proto_tree_add_item(u3v_telegram_tree, hf_u3v_stream_block_id, tvb, offset, 8, ENC_LITTLE_ENDIAN);\r\n    offset += 8;\r\n\r\n    /* reserved field */\r\n    proto_tree_add_item(u3v_telegram_tree, hf_u3v_stream_reserved, tvb, offset, 2, ENC_NA);\r\n    offset += 2;\r\n\r\n    /* payload type */\r\n    payload_type = tvb_get_letohs(tvb, offset);\r\n    proto_tree_add_item(u3v_telegram_tree, hf_u3v_stream_payload_type, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\n    offset += 2;\r\n\r\n    /* Add payload type to information string */\r\n    col_append_fstr(pinfo->cinfo, COL_INFO, \"Stream Leader  [ Block ID: %\" PRIu64 \" , Type %s]\",\r\n                    block_id,\r\n                    val_to_str_const(payload_type, payload_type_names, \"Unknown Payload Type\"));\r\n\r\n    if (payload_type == U3V_STREAM_PAYLOAD_IMAGE ||\r\n        payload_type == U3V_STREAM_PAYLOAD_IMAGE_EXT_CHUNK ||\r\n        payload_type == U3V_STREAM_PAYLOAD_CHUNK) {\r\n        /* timestamp */\r\n        proto_tree_add_item(u3v_telegram_tree, hf_u3v_stream_timestamp, tvb, offset, 8, ENC_LITTLE_ENDIAN);\r\n        offset += 8;\r\n    }\r\n\r\n    if (payload_type == U3V_STREAM_PAYLOAD_IMAGE ||\r\n        payload_type == U3V_STREAM_PAYLOAD_IMAGE_EXT_CHUNK ) {\r\n        /* pixel format */\r\n        proto_tree_add_item(u3v_telegram_tree, hf_u3v_stream_pixel_format, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\n        offset += 4;\r\n\r\n        /* size_x */\r\n        proto_tree_add_item(u3v_telegram_tree, hf_u3v_stream_size_x, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\n        offset += 4;\r\n\r\n        /* size_y */\r\n        proto_tree_add_item(u3v_telegram_tree, hf_u3v_stream_size_y, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\n        offset += 4;\r\n\r\n        /* offset_x */\r\n        proto_tree_add_item(u3v_telegram_tree, hf_u3v_stream_offset_x, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\n        offset += 4;\r\n\r\n        /* offset_x */\r\n        proto_tree_add_item(u3v_telegram_tree, hf_u3v_stream_offset_y, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\n        offset += 4;\r\n\r\n        /* padding_x */\r\n        proto_tree_add_item(u3v_telegram_tree, hf_u3v_stream_padding_x, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\n        /* offset += 2; */\r\n\r\n        /* reserved field */\r\n        proto_tree_add_item(u3v_telegram_tree, hf_u3v_stream_reserved, tvb, offset, 2, ENC_NA);\r\n        /* offset += 2; */\r\n    }\r\n}", ".issect_u3v_stream_trailer": "static void\r\ndissect_u3v_stream_trailer(proto_tree *u3v_telegram_tree, tvbuff_t *tvb, packet_info *pinfo, urb_info_t *urb _U_)\r\n{\r\n    int offset = 0;\r\n    uint64_t block_id;\r\n    proto_item *item = NULL;\r\n\r\n    /* Subtree initialization for Stream Trailer */\r\n    item = proto_tree_add_item(u3v_telegram_tree, hf_u3v_stream_trailer, tvb, 0, -1, ENC_NA);\r\n    u3v_telegram_tree = proto_item_add_subtree(item, ett_u3v_stream_trailer);\r\n\r\n    /* Add the prefix code: */\r\n    proto_tree_add_item(u3v_telegram_tree, hf_u3v_stream_prefix, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\n    offset += 4;\r\n\r\n    /* reserved field */\r\n    proto_tree_add_item(u3v_telegram_tree, hf_u3v_stream_reserved, tvb, offset, 2, ENC_NA);\r\n    offset += 2;\r\n\r\n    /* trailer size */\r\n    proto_tree_add_item(u3v_telegram_tree, hf_u3v_stream_trailer_size, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\n    offset += 2;\r\n\r\n    /* block id */\r\n    block_id = tvb_get_letoh64(tvb, offset);\r\n    proto_tree_add_item(u3v_telegram_tree, hf_u3v_stream_block_id, tvb, offset, 8, ENC_LITTLE_ENDIAN);\r\n    offset += 8;\r\n\r\n    /* status*/\r\n    proto_tree_add_item(u3v_telegram_tree, hf_u3v_stream_status, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\n    offset += 2;\r\n\r\n    /* reserved field */\r\n    proto_tree_add_item(u3v_telegram_tree, hf_u3v_stream_reserved, tvb, offset, 2, ENC_NA);\r\n    offset += 2;\r\n\r\n    /* block id */\r\n    proto_tree_add_item(u3v_telegram_tree, hf_u3v_stream_valid_payload_size, tvb, offset, 8, ENC_LITTLE_ENDIAN);\r\n    offset += 8;\r\n\r\n    /* Add payload type to information string */\r\n    col_append_fstr(pinfo->cinfo, COL_INFO, \"Stream Trailer [ Block ID: %\" PRIu64 \"]\", block_id);\r\n\r\n    if (tvb_captured_length_remaining(tvb,offset) >=4 ) {\r\n        /* size_y */\r\n        proto_tree_add_item(u3v_telegram_tree, hf_u3v_stream_size_y, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\n        offset += 4;\r\n    }\r\n\r\n    if (tvb_captured_length_remaining(tvb,offset) >=4 ) {\r\n        /* chunk layout id */\r\n        proto_tree_add_item(u3v_telegram_tree, hf_u3v_stream_chunk_layout_id, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\n        /* offset += 4; */\r\n    }\r\n}", ".issect_u3v_stream_payload": "static void\r\ndissect_u3v_stream_payload(proto_tree *u3v_telegram_tree, tvbuff_t *tvb, packet_info *pinfo, urb_info_t *urb _U_)\r\n{\r\n    proto_item *item = NULL;\r\n\r\n    /* Subtree initialization for Stream Payload */\r\n    item = proto_tree_add_item(u3v_telegram_tree, hf_u3v_stream_payload, tvb, 0, -1, ENC_NA);\r\n    u3v_telegram_tree = proto_item_add_subtree(item, ett_u3v_stream_payload);\r\n\r\n    /* Data */\r\n    proto_tree_add_item(u3v_telegram_tree, hf_u3v_stream_data, tvb, 0, -1, ENC_NA);\r\n\r\n    /* Add payload type to information string */\r\n    col_append_str(pinfo->cinfo, COL_INFO, \"Stream Payload\");\r\n}", ".issect_u3v": "static int\r\ndissect_u3v(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)\r\n{\r\n    int offset = 0;\r\n    proto_tree *u3v_tree = NULL, *ccd_tree_flag, *u3v_telegram_tree = NULL, *ccd_tree = NULL;\r\n    int data_length = 0;\r\n    int req_id = 0;\r\n    int command_id = -1;\r\n    int status = 0;\r\n    unsigned prefix = 0;\r\n    proto_item *ti = NULL;\r\n    proto_item *item = NULL;\r\n    const char *command_string;\r\n    urb_info_t *urb;\r\n    bool stream_detected = false;\r\n    bool control_detected = false;\r\n    u3v_conv_info_t *u3v_conv_info = NULL;\r\n    gencp_transaction_t *gencp_trans = NULL;\r\n\r\n    urb = (urb_info_t *)data;\r\n    if (!urb || !urb->conv) {\r\n        return 0;\r\n    }\r\n\r\n    /* decide if this packet belongs to U3V protocol */\r\n    u3v_conv_info = (u3v_conv_info_t *)urb->conv->class_data;\r\n\r\n    if (!u3v_conv_info) {\r\n        u3v_conv_info = wmem_new0(wmem_file_scope(), u3v_conv_info_t);\r\n        urb->conv->class_data = u3v_conv_info;\r\n        urb->conv->class_data_type = USB_CONV_U3V;\r\n    } else if (urb->conv->class_data_type != USB_CONV_U3V) {\r\n        /* Don't dissect if another USB type is in the conversation */\r\n        return 0;\r\n    }\r\n\r\n    prefix = tvb_get_letohl(tvb, 0);\r\n    if ((tvb_reported_length(tvb) >= 4) && ( ( U3V_CONTROL_PREFIX == prefix ) || ( U3V_EVENT_PREFIX == prefix ) ) ) {\r\n        control_detected = true;\r\n    }\r\n\r\n    if (((tvb_reported_length(tvb) >= 4) && (( U3V_STREAM_LEADER_PREFIX == prefix ) || ( U3V_STREAM_TRAILER_PREFIX == prefix )))\r\n         || (urb->endpoint == u3v_conv_info->ep_stream)) {\r\n        stream_detected = true;\r\n    }\r\n\r\n    /* initialize interface class/subclass in case no descriptors have been dissected yet */\r\n    if ( control_detected || stream_detected){\r\n        if (urb->conv->interfaceClass == IF_CLASS_UNKNOWN &&\r\n            urb->conv->interfaceSubclass == IF_SUBCLASS_UNKNOWN) {\r\n            urb->conv->interfaceClass = IF_CLASS_MISCELLANEOUS;\r\n            urb->conv->interfaceSubclass = IF_SUBCLASS_MISC_U3V;\r\n        }\r\n    }\r\n\r\n    if ( control_detected ) {\r\n        /* Set the protocol column */\r\n        col_set_str(pinfo->cinfo, COL_PROTOCOL, \"U3V\");\r\n\r\n        /* Clear out stuff in the info column */\r\n        col_clear(pinfo->cinfo, COL_INFO);\r\n\r\n        /* Adds \"USB3Vision\" heading to protocol tree */\r\n        /* We will add fields to this using the u3v_tree pointer */\r\n        ti = proto_tree_add_item(tree, proto_u3v, tvb, offset, -1, ENC_NA);\r\n        u3v_tree = proto_item_add_subtree(ti, ett_u3v);\r\n\r\n        prefix = tvb_get_letohl(tvb, offset);\r\n        command_id = tvb_get_letohs(tvb, offset+6);\r\n\r\n        /* decode CCD ( DCI/DCE command data layout) */\r\n        if ((prefix == U3V_CONTROL_PREFIX || prefix == U3V_EVENT_PREFIX) && ((command_id % 2) == 0)) {\r\n            command_string = val_to_str_wmem(pinfo->pool, command_id,command_names,\"Unknown Command (0x%x)\");\r\n            item = proto_tree_add_item(u3v_tree, hf_u3v_ccd_cmd, tvb, offset, 8, ENC_NA);\r\n            proto_item_append_text(item, \": %s\", command_string);\r\n            ccd_tree = proto_item_add_subtree(item, ett_u3v_cmd);\r\n\r\n            /* Add the prefix code: */\r\n            proto_tree_add_item(ccd_tree, hf_u3v_gencp_prefix, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\n            offset += 4;\r\n\r\n            /* Add the flags */\r\n            item = proto_tree_add_item(ccd_tree, hf_u3v_flag, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\n            ccd_tree_flag  = proto_item_add_subtree(item, ett_u3v_flags);\r\n            proto_tree_add_item(ccd_tree_flag, hf_u3v_acknowledge_required_flag, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\n\r\n            offset += 2;\r\n            col_append_fstr(pinfo->cinfo, COL_INFO, \"> %s \", command_string);\r\n        } else if (prefix == U3V_CONTROL_PREFIX && ((command_id % 2) == 1)) {\r\n            command_string = val_to_str_wmem(pinfo->pool, command_id,command_names,\"Unknown Acknowledge (0x%x)\");\r\n            item = proto_tree_add_item(u3v_tree, hf_u3v_ccd_ack, tvb, offset, 8, ENC_NA);\r\n            proto_item_append_text(item, \": %s\", command_string);\r\n            ccd_tree = proto_item_add_subtree(item, ett_u3v_ack);\r\n\r\n            /* Add the prefix code: */\r\n            proto_tree_add_item(ccd_tree, hf_u3v_gencp_prefix, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\n            offset += 4;\r\n\r\n            /* Add the status: */\r\n            proto_tree_add_item(ccd_tree, hf_u3v_status, tvb, offset, 2,ENC_LITTLE_ENDIAN);\r\n            status = tvb_get_letohs(tvb, offset);\r\n            offset += 2;\r\n            col_append_fstr(pinfo->cinfo, COL_INFO, \"< %s %s\",\r\n                    command_string,\r\n                    val_to_str_wmem(pinfo->pool, status, status_names_short, \"Unknown status (0x%04X)\"));\r\n        } else {\r\n            return 0;\r\n        }\r\n\r\n        /* Add the command id*/\r\n        proto_tree_add_item(ccd_tree, hf_u3v_command_id, tvb, offset, 2,ENC_LITTLE_ENDIAN);\r\n        offset += 2;\r\n\r\n        /* Parse the second part of both the command and the acknowledge header:\r\n        0          15 16         31\r\n        -------- -------- -------- --------\r\n        |     status      |   acknowledge   |\r\n        -------- -------- -------- --------\r\n        |     length      |      req_id     |\r\n        -------- -------- -------- --------\r\n\r\n        Add the data length\r\n        Number of valid data bytes in this message, not including this header. This\r\n        represents the number of bytes of payload appended after this header */\r\n\r\n        proto_tree_add_item(ccd_tree, hf_u3v_length, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\n        data_length = tvb_get_letohs(tvb, offset);\r\n        offset += 2;\r\n\r\n        /* Add the request ID */\r\n        proto_tree_add_item(ccd_tree, hf_u3v_request_id, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\n        req_id = tvb_get_letohs(tvb, offset);\r\n        offset += 2;\r\n\r\n        /* Add telegram subtree */\r\n        u3v_telegram_tree = proto_item_add_subtree(u3v_tree, ett_u3v);\r\n\r\n        if (!PINFO_FD_VISITED(pinfo)) {\r\n              if ((command_id % 2) == 0) {\r\n                    /* This is a command */\r\n                    gencp_trans = wmem_new0(wmem_file_scope(), gencp_transaction_t);\r\n                    gencp_trans->cmd_frame = pinfo->fd->num;\r\n                    gencp_trans->ack_frame = 0;\r\n                    gencp_trans->cmd_time = pinfo->abs_ts;\r\n                    /* add reference to current packet */\r\n                    p_add_proto_data(wmem_file_scope(), pinfo, proto_u3v, req_id, gencp_trans);\r\n                    /* add reference to current */\r\n                    u3v_conv_info->trans_info = gencp_trans;\r\n                } else {\r\n                    gencp_trans = u3v_conv_info->trans_info;\r\n                    if (gencp_trans) {\r\n                        gencp_trans->ack_frame = pinfo->fd->num;\r\n                        /* add reference to current packet */\r\n                        p_add_proto_data(wmem_file_scope(), pinfo, proto_u3v, req_id, gencp_trans);\r\n                    }\r\n                }\r\n         } else {\r\n            gencp_trans = (gencp_transaction_t*)p_get_proto_data(wmem_file_scope(),pinfo, proto_u3v, req_id);\r\n         }\r\n\r\n        if (!gencp_trans) {\r\n            /* create a \"fake\" gencp_trans structure */\r\n            gencp_trans = wmem_new0(pinfo->pool, gencp_transaction_t);\r\n            gencp_trans->cmd_frame = 0;\r\n            gencp_trans->ack_frame = 0;\r\n            gencp_trans->cmd_time = pinfo->abs_ts;\r\n        }\r\n\r\n        /* dissect depending on command? */\r\n        switch (command_id) {\r\n        case U3V_READMEM_CMD:\r\n            dissect_u3v_read_mem_cmd(u3v_telegram_tree, tvb, pinfo, offset, data_length,u3v_conv_info,gencp_trans);\r\n            break;\r\n        case U3V_WRITEMEM_CMD:\r\n            dissect_u3v_write_mem_cmd(u3v_telegram_tree, tvb, pinfo, offset, data_length,u3v_conv_info,gencp_trans);\r\n            break;\r\n        case U3V_EVENT_CMD:\r\n            dissect_u3v_event_cmd(u3v_telegram_tree, tvb, pinfo, offset, data_length);\r\n            break;\r\n        case U3V_READMEM_ACK:\r\n            if ( U3V_STATUS_GENCP_SUCCESS == status ) {\r\n                dissect_u3v_read_mem_ack(u3v_telegram_tree, tvb, pinfo, offset, data_length,u3v_conv_info,gencp_trans);\r\n            }\r\n            break;\r\n        case U3V_WRITEMEM_ACK:\r\n            dissect_u3v_write_mem_ack(u3v_telegram_tree, tvb, pinfo, offset, data_length, u3v_conv_info,gencp_trans);\r\n            break;\r\n        case U3V_PENDING_ACK:\r\n            dissect_u3v_pending_ack(u3v_telegram_tree, tvb, pinfo, offset, data_length, u3v_conv_info,gencp_trans);\r\n            break;\r\n        default:\r\n            proto_tree_add_item(u3v_telegram_tree, hf_u3v_payloaddata, tvb, offset, data_length, ENC_NA);\r\n            break;\r\n        }\r\n        return data_length + 12;\r\n    } else if ( stream_detected ) {\r\n        /* this is streaming data */\r\n\r\n        /* init this stream configuration */\r\n        u3v_conv_info = (u3v_conv_info_t *)urb->conv->class_data;\r\n        u3v_conv_info->ep_stream = urb->endpoint;\r\n\r\n        /* Set the protocol column */\r\n        col_set_str(pinfo->cinfo, COL_PROTOCOL, \"U3V\");\r\n\r\n        /* Clear out stuff in the info column */\r\n        col_clear(pinfo->cinfo, COL_INFO);\r\n\r\n        /* Adds \"USB3Vision\" heading to protocol tree */\r\n        /* We will add fields to this using the u3v_tree pointer */\r\n        ti = proto_tree_add_item(tree, proto_u3v, tvb, offset, -1, ENC_NA);\r\n        u3v_tree = proto_item_add_subtree(ti, ett_u3v);\r\n\r\n        if(tvb_captured_length(tvb) >=4) {\r\n            prefix = tvb_get_letohl(tvb, offset);\r\n            switch (prefix) {\r\n            case U3V_STREAM_LEADER_PREFIX:\r\n                dissect_u3v_stream_leader(u3v_tree, tvb, pinfo, urb);\r\n                break;\r\n            case U3V_STREAM_TRAILER_PREFIX:\r\n                dissect_u3v_stream_trailer(u3v_tree, tvb, pinfo, urb);\r\n                break;\r\n            default:\r\n                dissect_u3v_stream_payload(u3v_tree, tvb, pinfo, urb);\r\n                break;\r\n            }\r\n        }\r\n        return tvb_captured_length(tvb);\r\n    }\r\n    return 0;\r\n}", ".issect_u3v_heur": "static bool\r\ndissect_u3v_heur(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)\r\n{\r\n    uint32_t prefix;\r\n    urb_info_t *urb;\r\n\r\n    /* all control and meta data packets of U3V contain at least the prefix */\r\n    if (tvb_reported_length(tvb) < 4)\r\n        return false;\r\n    prefix = tvb_get_letohl(tvb, 0);\r\n\r\n    /* check if stream endpoint has been already set up for this conversation */\r\n    urb = (urb_info_t *)data;\r\n    if (!urb || !urb->conv)\r\n        return false;\r\n\r\n    /* either right prefix or the endpoint of the interface descriptor\r\n       set the correct class and subclass */\r\n    if ((U3V_STREAM_LEADER_PREFIX  == prefix) || (U3V_STREAM_TRAILER_PREFIX == prefix) ||\r\n        (U3V_CONTROL_PREFIX        == prefix) || (U3V_EVENT_PREFIX          == prefix) ||\r\n        ((urb->conv->interfaceClass == IF_CLASS_MISCELLANEOUS &&\r\n          urb->conv->interfaceSubclass == IF_SUBCLASS_MISC_U3V))) {\r\n        dissect_u3v(tvb, pinfo, tree, data);\r\n        return true;\r\n    }\r\n\r\n    return false;\r\n}", ".issect_u3v_descriptors": "static int\r\ndissect_u3v_descriptors(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, void *data _U_)\r\n{\r\n    uint8_t         type;\r\n    int             offset = 0;\r\n    proto_item *    ti;\r\n    proto_tree *    sub_tree;\r\n    uint32_t        version;\r\n\r\n\r\n    /* The descriptor must at least have a length and type field. */\r\n    if (tvb_reported_length(tvb) < 2) {\r\n        return 0;\r\n    }\r\n\r\n    /* skip len */\r\n    type = tvb_get_uint8(tvb, 1);\r\n\r\n    /* Check for U3V device info descriptor. */\r\n    if (type != DESCRIPTOR_TYPE_U3V_INTERFACE) {\r\n        return 0;\r\n    }\r\n\r\n    ti = proto_tree_add_item(tree, hf_u3v_device_info_descriptor, tvb, offset, -1, ENC_NA);\r\n    tree = proto_item_add_subtree(ti, ett_u3v_device_info_descriptor);\r\n\r\n    /* bLength */\r\n    proto_tree_add_item(tree, hf_u3v_device_info_descriptor_bLength, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\n    offset++;\r\n\r\n    /* bDescriptorType */\r\n    ti = proto_tree_add_item(tree, hf_u3v_device_info_descriptor_bDescriptorType, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\n    proto_item_append_text(ti, \" (U3V INTERFACE)\");\r\n    offset++;\r\n\r\n    /* bDescriptorSubtype */\r\n    proto_tree_add_item(tree, hf_u3v_device_info_descriptor_bDescriptorSubtype, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\n    offset++;\r\n\r\n    /* bGenCPVersion */\r\n    if (!tvb_bytes_exist(tvb, offset, 4)) {\r\n        /* Version not completely in buffer -> break dissection here. */\r\n        return offset;\r\n    }\r\n    version = tvb_get_letohl(tvb, offset);\r\n    ti = proto_tree_add_item(tree, hf_u3v_device_info_descriptor_bGenCPVersion, tvb, offset, 4, ENC_NA);\r\n    proto_item_append_text(ti, \": %u.%u\", version >> 16, version & 0xFFFF);\r\n    sub_tree = proto_item_add_subtree(ti, ett_u3v_device_info_descriptor_gencp_version);\r\n    proto_tree_add_item(sub_tree, hf_u3v_device_info_descriptor_bGenCPVersion_minor, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\n    proto_tree_add_item(sub_tree, hf_u3v_device_info_descriptor_bGenCPVersion_major, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\n    offset += 4;\r\n\r\n    /* bU3VVersion */\r\n    if (!tvb_bytes_exist(tvb, offset, 4)) {\r\n        /* Version not completely in buffer -> break dissection here. */\r\n        return offset;\r\n    }\r\n    version = tvb_get_letohl(tvb, offset);\r\n    ti = proto_tree_add_item(tree, hf_u3v_device_info_descriptor_bU3VVersion, tvb, offset, 4, ENC_NA);\r\n    proto_item_append_text(ti, \": %u.%u\", version >> 16, version & 0xFFFF);\r\n    sub_tree = proto_item_add_subtree(ti, ett_u3v_device_info_descriptor_u3v_version);\r\n    proto_tree_add_item(sub_tree, hf_u3v_device_info_descriptor_bU3VVersion_minor, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\n    proto_tree_add_item(sub_tree, hf_u3v_device_info_descriptor_bU3VVersion_major, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\n    offset += 4;\r\n\r\n    /* iDeviceGUID */\r\n    proto_tree_add_item(tree, hf_u3v_device_info_descriptor_iDeviceGUID, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\n    offset++;\r\n\r\n    /* iVendorName */\r\n    proto_tree_add_item(tree, hf_u3v_device_info_descriptor_iVendorName, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\n    offset++;\r\n\r\n    /* iModelName */\r\n    proto_tree_add_item(tree, hf_u3v_device_info_descriptor_iModelName, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\n    offset++;\r\n\r\n    /* iFamilyName */\r\n    proto_tree_add_item(tree, hf_u3v_device_info_descriptor_iFamilyName, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\n    offset++;\r\n\r\n    /* iDeviceVersion */\r\n    proto_tree_add_item(tree, hf_u3v_device_info_descriptor_iDeviceVersion, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\n    offset++;\r\n\r\n    /* iManufacturerInfo */\r\n    proto_tree_add_item(tree, hf_u3v_device_info_descriptor_iManufacturerInfo, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\n    offset++;\r\n\r\n    /* iSerialNumber */\r\n    proto_tree_add_item(tree, hf_u3v_device_info_descriptor_iSerialNumber, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\n    offset++;\r\n\r\n    /* iUserDefinedName */\r\n    proto_tree_add_item(tree, hf_u3v_device_info_descriptor_iUserDefinedName, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\n    offset++;\r\n\r\n    /* bmSpeedSupport */\r\n    proto_tree_add_bitmask(tree, tvb, offset, hf_u3v_device_info_descriptor_bmSpeedSupport,\r\n                           ett_u3v_device_info_descriptor_speed_support, speed_support_fields, ENC_LITTLE_ENDIAN);\r\n\r\n    offset++;\r\n\r\n    return offset;\r\n}"}, "callee": {".issect_u3v_read_mem_cmd": "static void\r\ndissect_u3v_read_mem_cmd(proto_tree *u3v_telegram_tree, tvbuff_t *tvb, packet_info *pinfo, int startoffset, int length, u3v_conv_info_t *u3v_conv_info, gencp_transaction_t * gencp_trans)\r\n{\r\n    uint64_t addr = 0;\r\n    const char* address_string = NULL;\r\n    bool is_custom_register = false;\r\n    uint16_t count = 0;\r\n    int offset = startoffset;\r\n    proto_item *item = NULL;\r\n\r\n    addr = tvb_get_letoh64(tvb, offset);\r\n    gencp_trans->address = addr;\r\n\r\n    address_string = get_register_name_from_address(addr, pinfo->pool, &is_custom_register, u3v_conv_info);\r\n    count = tvb_get_letohs(tvb, offset + 10);   /* Number of bytes to read from memory */\r\n\r\n    gencp_trans->count = count;\r\n    if ( 0xffffffff00000000 & addr ) {\r\n        col_append_fstr(pinfo->cinfo, COL_INFO, \" (0x%016\" PRIX64 \" (%d) bytes) %s\", addr, count, address_string);\r\n    } else {\r\n        col_append_fstr(pinfo->cinfo, COL_INFO, \" (0x%08X (%d) bytes)\", (uint32_t)addr, count);\r\n    }\r\n\r\n\r\n    item = proto_tree_add_item(u3v_telegram_tree, hf_u3v_scd_readmem_cmd, tvb, offset, length, ENC_NA);\r\n    u3v_telegram_tree = proto_item_add_subtree(item, ett_u3v_payload_cmd);\r\n\r\n    /* address */\r\n    if (is_known_bootstrap_register(addr, u3v_conv_info)) {\r\n        item = proto_tree_add_uint64(u3v_telegram_tree, hf_u3v_address, tvb, offset, 8, addr);\r\n        proto_item_append_text(item, \" %s\", address_string);\r\n    } else {\r\n        proto_tree_add_item(u3v_telegram_tree, hf_u3v_custom_memory_addr, tvb, offset, 8, ENC_LITTLE_ENDIAN);\r\n    }\r\n    offset += 8;\r\n\r\n    /* reserved field */\r\n    proto_tree_add_item(u3v_telegram_tree, hf_u3v_reserved, tvb, offset, 2, ENC_NA);\r\n    offset += 2;\r\n\r\n    /* count */\r\n    proto_tree_add_item(u3v_telegram_tree, hf_u3v_count, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\n}", ".issect_u3v_write_mem_cmd": "static void\r\ndissect_u3v_write_mem_cmd(proto_tree *u3v_telegram_tree, tvbuff_t *tvb, packet_info *pinfo, int startoffset, int length, u3v_conv_info_t *u3v_conv_info, gencp_transaction_t *gencp_trans)\r\n{\r\n    const char* address_string = NULL;\r\n    bool is_custom_register = false;\r\n    uint64_t addr = 0;\r\n    unsigned byte_count = 0;\r\n    proto_item *item = NULL;\r\n    unsigned offset = startoffset + 8;\r\n\r\n    addr = tvb_get_letoh64(tvb, startoffset);\r\n    byte_count = length - 8;\r\n    address_string = get_register_name_from_address(addr, pinfo->pool, &is_custom_register, u3v_conv_info);\r\n\r\n    gencp_trans->address = addr;\r\n    gencp_trans->count = byte_count;\r\n\r\n    /* fill in Info column in Wireshark GUI */\r\n    col_append_fstr(pinfo->cinfo, COL_INFO, \"%s: %d bytes\", address_string, byte_count);\r\n\r\n\r\n    /* Subtree initialization for Payload Data: WRITEMEM_CMD */\r\n    item = proto_tree_add_item(u3v_telegram_tree, hf_u3v_scd_writemem_cmd, tvb, startoffset, length, ENC_NA);\r\n    u3v_telegram_tree = proto_item_add_subtree(item, ett_u3v_payload_cmd);\r\n\r\n    if (is_known_bootstrap_register(addr, u3v_conv_info)) {\r\n        item = proto_tree_add_uint64(u3v_telegram_tree, hf_u3v_address, tvb, startoffset, 8, addr);\r\n        proto_item_append_text(item, \" %s\", address_string);\r\n        dissect_u3v_register(addr, u3v_telegram_tree, tvb, offset, byte_count, u3v_conv_info);\r\n    } else {\r\n        proto_tree_add_item(u3v_telegram_tree, hf_u3v_custom_memory_addr, tvb, startoffset, 8, ENC_LITTLE_ENDIAN);\r\n        proto_tree_add_item(u3v_telegram_tree, hf_u3v_custom_memory_data, tvb, startoffset + 8, byte_count, ENC_NA);\r\n    }\r\n\r\n}", ".issect_u3v_read_mem_ack": "static void\r\ndissect_u3v_read_mem_ack(proto_tree *u3v_telegram_tree, tvbuff_t *tvb, packet_info *pinfo, int startoffset, int length, u3v_conv_info_t *u3v_conv_info, gencp_transaction_t * gencp_trans)\r\n{\r\n    uint64_t addr = 0;\r\n    const char *address_string = NULL;\r\n    bool is_custom_register = false;\r\n    bool have_address = (0 != gencp_trans->cmd_frame);\r\n    proto_item *item = NULL;\r\n    unsigned offset = startoffset;\r\n    unsigned byte_count = (length);\r\n\r\n    addr = gencp_trans->address;\r\n    dissect_u3v_register_bases(addr, tvb, startoffset, u3v_conv_info);\r\n    if (have_address) {\r\n        address_string = get_register_name_from_address(addr, pinfo->pool, &is_custom_register, u3v_conv_info);\r\n        /* Fill in Wireshark GUI Info column */\r\n        col_append_str(pinfo->cinfo, COL_INFO, address_string);\r\n    }\r\n\r\n\r\n    /* Subtree initialization for Payload Data: READMEM_ACK */\r\n    item = proto_tree_add_item(u3v_telegram_tree, hf_u3v_scd_ack_readmem_ack, tvb, startoffset, length, ENC_NA);\r\n    u3v_telegram_tree = proto_item_add_subtree(item, ett_u3v_payload_cmd);\r\n\r\n    /* Bootstrap register known address */\r\n    if (have_address) {\r\n        item = proto_tree_add_uint64(u3v_telegram_tree, hf_u3v_address, tvb, 0,0 , addr);\r\n        proto_item_set_generated(item);\r\n\r\n        if (is_known_bootstrap_register(addr, u3v_conv_info)) {\r\n            dissect_u3v_register(addr, u3v_telegram_tree, tvb, offset, byte_count, u3v_conv_info);\r\n        } else {\r\n            proto_tree_add_item(u3v_telegram_tree, hf_u3v_custom_memory_data, tvb, startoffset, length, ENC_NA);\r\n        }\r\n    }\r\n}", ".issect_u3v": "static int\r\ndissect_u3v(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)\r\n{\r\n    int offset = 0;\r\n    proto_tree *u3v_tree = NULL, *ccd_tree_flag, *u3v_telegram_tree = NULL, *ccd_tree = NULL;\r\n    int data_length = 0;\r\n    int req_id = 0;\r\n    int command_id = -1;\r\n    int status = 0;\r\n    unsigned prefix = 0;\r\n    proto_item *ti = NULL;\r\n    proto_item *item = NULL;\r\n    const char *command_string;\r\n    urb_info_t *urb;\r\n    bool stream_detected = false;\r\n    bool control_detected = false;\r\n    u3v_conv_info_t *u3v_conv_info = NULL;\r\n    gencp_transaction_t *gencp_trans = NULL;\r\n\r\n    urb = (urb_info_t *)data;\r\n    if (!urb || !urb->conv) {\r\n        return 0;\r\n    }\r\n\r\n    /* decide if this packet belongs to U3V protocol */\r\n    u3v_conv_info = (u3v_conv_info_t *)urb->conv->class_data;\r\n\r\n    if (!u3v_conv_info) {\r\n        u3v_conv_info = wmem_new0(wmem_file_scope(), u3v_conv_info_t);\r\n        urb->conv->class_data = u3v_conv_info;\r\n        urb->conv->class_data_type = USB_CONV_U3V;\r\n    } else if (urb->conv->class_data_type != USB_CONV_U3V) {\r\n        /* Don't dissect if another USB type is in the conversation */\r\n        return 0;\r\n    }\r\n\r\n    prefix = tvb_get_letohl(tvb, 0);\r\n    if ((tvb_reported_length(tvb) >= 4) && ( ( U3V_CONTROL_PREFIX == prefix ) || ( U3V_EVENT_PREFIX == prefix ) ) ) {\r\n        control_detected = true;\r\n    }\r\n\r\n    if (((tvb_reported_length(tvb) >= 4) && (( U3V_STREAM_LEADER_PREFIX == prefix ) || ( U3V_STREAM_TRAILER_PREFIX == prefix )))\r\n         || (urb->endpoint == u3v_conv_info->ep_stream)) {\r\n        stream_detected = true;\r\n    }\r\n\r\n    /* initialize interface class/subclass in case no descriptors have been dissected yet */\r\n    if ( control_detected || stream_detected){\r\n        if (urb->conv->interfaceClass == IF_CLASS_UNKNOWN &&\r\n            urb->conv->interfaceSubclass == IF_SUBCLASS_UNKNOWN) {\r\n            urb->conv->interfaceClass = IF_CLASS_MISCELLANEOUS;\r\n            urb->conv->interfaceSubclass = IF_SUBCLASS_MISC_U3V;\r\n        }\r\n    }\r\n\r\n    if ( control_detected ) {\r\n        /* Set the protocol column */\r\n        col_set_str(pinfo->cinfo, COL_PROTOCOL, \"U3V\");\r\n\r\n        /* Clear out stuff in the info column */\r\n        col_clear(pinfo->cinfo, COL_INFO);\r\n\r\n        /* Adds \"USB3Vision\" heading to protocol tree */\r\n        /* We will add fields to this using the u3v_tree pointer */\r\n        ti = proto_tree_add_item(tree, proto_u3v, tvb, offset, -1, ENC_NA);\r\n        u3v_tree = proto_item_add_subtree(ti, ett_u3v);\r\n\r\n        prefix = tvb_get_letohl(tvb, offset);\r\n        command_id = tvb_get_letohs(tvb, offset+6);\r\n\r\n        /* decode CCD ( DCI/DCE command data layout) */\r\n        if ((prefix == U3V_CONTROL_PREFIX || prefix == U3V_EVENT_PREFIX) && ((command_id % 2) == 0)) {\r\n            command_string = val_to_str_wmem(pinfo->pool, command_id,command_names,\"Unknown Command (0x%x)\");\r\n            item = proto_tree_add_item(u3v_tree, hf_u3v_ccd_cmd, tvb, offset, 8, ENC_NA);\r\n            proto_item_append_text(item, \": %s\", command_string);\r\n            ccd_tree = proto_item_add_subtree(item, ett_u3v_cmd);\r\n\r\n            /* Add the prefix code: */\r\n            proto_tree_add_item(ccd_tree, hf_u3v_gencp_prefix, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\n            offset += 4;\r\n\r\n            /* Add the flags */\r\n            item = proto_tree_add_item(ccd_tree, hf_u3v_flag, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\n            ccd_tree_flag  = proto_item_add_subtree(item, ett_u3v_flags);\r\n            proto_tree_add_item(ccd_tree_flag, hf_u3v_acknowledge_required_flag, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\n\r\n            offset += 2;\r\n            col_append_fstr(pinfo->cinfo, COL_INFO, \"> %s \", command_string);\r\n        } else if (prefix == U3V_CONTROL_PREFIX && ((command_id % 2) == 1)) {\r\n            command_string = val_to_str_wmem(pinfo->pool, command_id,command_names,\"Unknown Acknowledge (0x%x)\");\r\n            item = proto_tree_add_item(u3v_tree, hf_u3v_ccd_ack, tvb, offset, 8, ENC_NA);\r\n            proto_item_append_text(item, \": %s\", command_string);\r\n            ccd_tree = proto_item_add_subtree(item, ett_u3v_ack);\r\n\r\n            /* Add the prefix code: */\r\n            proto_tree_add_item(ccd_tree, hf_u3v_gencp_prefix, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\n            offset += 4;\r\n\r\n            /* Add the status: */\r\n            proto_tree_add_item(ccd_tree, hf_u3v_status, tvb, offset, 2,ENC_LITTLE_ENDIAN);\r\n            status = tvb_get_letohs(tvb, offset);\r\n            offset += 2;\r\n            col_append_fstr(pinfo->cinfo, COL_INFO, \"< %s %s\",\r\n                    command_string,\r\n                    val_to_str_wmem(pinfo->pool, status, status_names_short, \"Unknown status (0x%04X)\"));\r\n        } else {\r\n            return 0;\r\n        }\r\n\r\n        /* Add the command id*/\r\n        proto_tree_add_item(ccd_tree, hf_u3v_command_id, tvb, offset, 2,ENC_LITTLE_ENDIAN);\r\n        offset += 2;\r\n\r\n        /* Parse the second part of both the command and the acknowledge header:\r\n        0          15 16         31\r\n        -------- -------- -------- --------\r\n        |     status      |   acknowledge   |\r\n        -------- -------- -------- --------\r\n        |     length      |      req_id     |\r\n        -------- -------- -------- --------\r\n\r\n        Add the data length\r\n        Number of valid data bytes in this message, not including this header. This\r\n        represents the number of bytes of payload appended after this header */\r\n\r\n        proto_tree_add_item(ccd_tree, hf_u3v_length, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\n        data_length = tvb_get_letohs(tvb, offset);\r\n        offset += 2;\r\n\r\n        /* Add the request ID */\r\n        proto_tree_add_item(ccd_tree, hf_u3v_request_id, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\n        req_id = tvb_get_letohs(tvb, offset);\r\n        offset += 2;\r\n\r\n        /* Add telegram subtree */\r\n        u3v_telegram_tree = proto_item_add_subtree(u3v_tree, ett_u3v);\r\n\r\n        if (!PINFO_FD_VISITED(pinfo)) {\r\n              if ((command_id % 2) == 0) {\r\n                    /* This is a command */\r\n                    gencp_trans = wmem_new0(wmem_file_scope(), gencp_transaction_t);\r\n                    gencp_trans->cmd_frame = pinfo->fd->num;\r\n                    gencp_trans->ack_frame = 0;\r\n                    gencp_trans->cmd_time = pinfo->abs_ts;\r\n                    /* add reference to current packet */\r\n                    p_add_proto_data(wmem_file_scope(), pinfo, proto_u3v, req_id, gencp_trans);\r\n                    /* add reference to current */\r\n                    u3v_conv_info->trans_info = gencp_trans;\r\n                } else {\r\n                    gencp_trans = u3v_conv_info->trans_info;\r\n                    if (gencp_trans) {\r\n                        gencp_trans->ack_frame = pinfo->fd->num;\r\n                        /* add reference to current packet */\r\n                        p_add_proto_data(wmem_file_scope(), pinfo, proto_u3v, req_id, gencp_trans);\r\n                    }\r\n                }\r\n         } else {\r\n            gencp_trans = (gencp_transaction_t*)p_get_proto_data(wmem_file_scope(),pinfo, proto_u3v, req_id);\r\n         }\r\n\r\n        if (!gencp_trans) {\r\n            /* create a \"fake\" gencp_trans structure */\r\n            gencp_trans = wmem_new0(pinfo->pool, gencp_transaction_t);\r\n            gencp_trans->cmd_frame = 0;\r\n            gencp_trans->ack_frame = 0;\r\n            gencp_trans->cmd_time = pinfo->abs_ts;\r\n        }\r\n\r\n        /* dissect depending on command? */\r\n        switch (command_id) {\r\n        case U3V_READMEM_CMD:\r\n            dissect_u3v_read_mem_cmd(u3v_telegram_tree, tvb, pinfo, offset, data_length,u3v_conv_info,gencp_trans);\r\n            break;\r\n        case U3V_WRITEMEM_CMD:\r\n            dissect_u3v_write_mem_cmd(u3v_telegram_tree, tvb, pinfo, offset, data_length,u3v_conv_info,gencp_trans);\r\n            break;\r\n        case U3V_EVENT_CMD:\r\n            dissect_u3v_event_cmd(u3v_telegram_tree, tvb, pinfo, offset, data_length);\r\n            break;\r\n        case U3V_READMEM_ACK:\r\n            if ( U3V_STATUS_GENCP_SUCCESS == status ) {\r\n                dissect_u3v_read_mem_ack(u3v_telegram_tree, tvb, pinfo, offset, data_length,u3v_conv_info,gencp_trans);\r\n            }\r\n            break;\r\n        case U3V_WRITEMEM_ACK:\r\n            dissect_u3v_write_mem_ack(u3v_telegram_tree, tvb, pinfo, offset, data_length, u3v_conv_info,gencp_trans);\r\n            break;\r\n        case U3V_PENDING_ACK:\r\n            dissect_u3v_pending_ack(u3v_telegram_tree, tvb, pinfo, offset, data_length, u3v_conv_info,gencp_trans);\r\n            break;\r\n        default:\r\n            proto_tree_add_item(u3v_telegram_tree, hf_u3v_payloaddata, tvb, offset, data_length, ENC_NA);\r\n            break;\r\n        }\r\n        return data_length + 12;\r\n    } else if ( stream_detected ) {\r\n        /* this is streaming data */\r\n\r\n        /* init this stream configuration */\r\n        u3v_conv_info = (u3v_conv_info_t *)urb->conv->class_data;\r\n        u3v_conv_info->ep_stream = urb->endpoint;\r\n\r\n        /* Set the protocol column */\r\n        col_set_str(pinfo->cinfo, COL_PROTOCOL, \"U3V\");\r\n\r\n        /* Clear out stuff in the info column */\r\n        col_clear(pinfo->cinfo, COL_INFO);\r\n\r\n        /* Adds \"USB3Vision\" heading to protocol tree */\r\n        /* We will add fields to this using the u3v_tree pointer */\r\n        ti = proto_tree_add_item(tree, proto_u3v, tvb, offset, -1, ENC_NA);\r\n        u3v_tree = proto_item_add_subtree(ti, ett_u3v);\r\n\r\n        if(tvb_captured_length(tvb) >=4) {\r\n            prefix = tvb_get_letohl(tvb, offset);\r\n            switch (prefix) {\r\n            case U3V_STREAM_LEADER_PREFIX:\r\n                dissect_u3v_stream_leader(u3v_tree, tvb, pinfo, urb);\r\n                break;\r\n            case U3V_STREAM_TRAILER_PREFIX:\r\n                dissect_u3v_stream_trailer(u3v_tree, tvb, pinfo, urb);\r\n                break;\r\n            default:\r\n                dissect_u3v_stream_payload(u3v_tree, tvb, pinfo, urb);\r\n                break;\r\n            }\r\n        }\r\n        return tvb_captured_length(tvb);\r\n    }\r\n    return 0;\r\n}", ".issect_u3v_heur": "static bool\r\ndissect_u3v_heur(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)\r\n{\r\n    uint32_t prefix;\r\n    urb_info_t *urb;\r\n\r\n    /* all control and meta data packets of U3V contain at least the prefix */\r\n    if (tvb_reported_length(tvb) < 4)\r\n        return false;\r\n    prefix = tvb_get_letohl(tvb, 0);\r\n\r\n    /* check if stream endpoint has been already set up for this conversation */\r\n    urb = (urb_info_t *)data;\r\n    if (!urb || !urb->conv)\r\n        return false;\r\n\r\n    /* either right prefix or the endpoint of the interface descriptor\r\n       set the correct class and subclass */\r\n    if ((U3V_STREAM_LEADER_PREFIX  == prefix) || (U3V_STREAM_TRAILER_PREFIX == prefix) ||\r\n        (U3V_CONTROL_PREFIX        == prefix) || (U3V_EVENT_PREFIX          == prefix) ||\r\n        ((urb->conv->interfaceClass == IF_CLASS_MISCELLANEOUS &&\r\n          urb->conv->interfaceSubclass == IF_SUBCLASS_MISC_U3V))) {\r\n        dissect_u3v(tvb, pinfo, tree, data);\r\n        return true;\r\n    }\r\n\r\n    return false;\r\n}", ".roto_register_u3v": "void\r\nproto_register_u3v(void)\r\n{\r\n    static int *ett[] = {\r\n        &ett_u3v,\r\n        &ett_u3v_cmd,\r\n        &ett_u3v_flags,\r\n        &ett_u3v_ack,\r\n        &ett_u3v_payload_cmd,\r\n        &ett_u3v_payload_ack,\r\n        &ett_u3v_payload_ack_subtree,\r\n        &ett_u3v_payload_cmd_subtree,\r\n        &ett_u3v_bootstrap_fields,\r\n        &ett_u3v_stream_leader,\r\n        &ett_u3v_stream_trailer,\r\n        &ett_u3v_stream_payload,\r\n        &ett_u3v_device_info_descriptor,\r\n        &ett_u3v_device_info_descriptor_speed_support,\r\n        &ett_u3v_device_info_descriptor_gencp_version,\r\n        &ett_u3v_device_info_descriptor_u3v_version,\r\n    };\r\n\r\n    proto_u3v = proto_register_protocol(\"USB 3 Vision\", \"U3V\", \"u3v\");\r\n    proto_register_field_array(proto_u3v, hf, array_length(hf));\r\n    proto_register_subtree_array(ett, array_length(ett));\r\n    u3v_handle = register_dissector(\"u3v\", dissect_u3v, proto_u3v);\r\n}", ".roto_reg_handoff_u3v": "void\r\nproto_reg_handoff_u3v(void)\r\n{\r\n    dissector_handle_t u3v_descr_handle = NULL;\r\n\r\n    dissector_add_uint(\"usb.bulk\", IF_CLASS_MISCELLANEOUS, u3v_handle);\r\n    heur_dissector_add(\"usb.bulk\", dissect_u3v_heur, \"USB3Vision Protocol\", \"u3v\", proto_u3v,HEURISTIC_ENABLE);\r\n    u3v_descr_handle = create_dissector_handle(dissect_u3v_descriptors, proto_u3v);\r\n    dissector_add_uint(\"usb.descriptor\", IF_CLASS_MISCELLANEOUS, u3v_descr_handle);\r\n}"}, "function_name": "proto_reg_handoff_u3v"}
{"function_id": null, "caller": {".ernelBessel_J1": "static double KernelBessel_J1(const double x)\r\n{\r\n\tdouble p, q;\r\n\r\n\tregister long i;\r\n\r\n\tstatic const double\r\n\tPone[] =\r\n\t{\r\n\t\t0.581199354001606143928050809e+21,\r\n\t\t-0.6672106568924916298020941484e+20,\r\n\t\t0.2316433580634002297931815435e+19,\r\n\t\t-0.3588817569910106050743641413e+17,\r\n\t\t0.2908795263834775409737601689e+15,\r\n\t\t-0.1322983480332126453125473247e+13,\r\n\t\t0.3413234182301700539091292655e+10,\r\n\t\t-0.4695753530642995859767162166e+7,\r\n\t\t0.270112271089232341485679099e+4\r\n\t},\r\n\tQone[] =\r\n\t{\r\n\t\t0.11623987080032122878585294e+22,\r\n\t\t0.1185770712190320999837113348e+20,\r\n\t\t0.6092061398917521746105196863e+17,\r\n\t\t0.2081661221307607351240184229e+15,\r\n\t\t0.5243710262167649715406728642e+12,\r\n\t\t0.1013863514358673989967045588e+10,\r\n\t\t0.1501793594998585505921097578e+7,\r\n\t\t0.1606931573481487801970916749e+4,\r\n\t\t0.1e+1\r\n\t};\r\n\r\n\tp = Pone[8];\r\n\tq = Qone[8];\r\n\tfor (i=7; i >= 0; i--)\r\n\t{\r\n\t\tp = p*x*x+Pone[i];\r\n\t\tq = q*x*x+Qone[i];\r\n\t}\r\n\treturn (double)(p/q);\r\n}", ".ernelBessel_P1": "static double KernelBessel_P1(const double x)\r\n{\r\n\tdouble p, q;\r\n\r\n\tregister long i;\r\n\r\n\tstatic const double\r\n\tPone[] =\r\n\t{\r\n\t\t0.352246649133679798341724373e+5,\r\n\t\t0.62758845247161281269005675e+5,\r\n\t\t0.313539631109159574238669888e+5,\r\n\t\t0.49854832060594338434500455e+4,\r\n\t\t0.2111529182853962382105718e+3,\r\n\t\t0.12571716929145341558495e+1\r\n\t},\r\n\tQone[] =\r\n\t{\r\n\t\t0.352246649133679798068390431e+5,\r\n\t\t0.626943469593560511888833731e+5,\r\n\t\t0.312404063819041039923015703e+5,\r\n\t\t0.4930396490181088979386097e+4,\r\n\t\t0.2030775189134759322293574e+3,\r\n\t\t0.1e+1\r\n\t};\r\n\r\n\tp = Pone[5];\r\n\tq = Qone[5];\r\n\tfor (i=4; i >= 0; i--)\r\n\t{\r\n\t\tp = p*(8.0/x)*(8.0/x)+Pone[i];\r\n\t\tq = q*(8.0/x)*(8.0/x)+Qone[i];\r\n\t}\r\n\treturn (double)(p/q);\r\n}", ".ernelBessel_Q1": "static double KernelBessel_Q1(const double x)\r\n{\r\n\tdouble p, q;\r\n\r\n\tregister long i;\r\n\r\n\tstatic const double\r\n\tPone[] =\r\n\t{\r\n\t\t0.3511751914303552822533318e+3,\r\n\t\t0.7210391804904475039280863e+3,\r\n\t\t0.4259873011654442389886993e+3,\r\n\t\t0.831898957673850827325226e+2,\r\n\t\t0.45681716295512267064405e+1,\r\n\t\t0.3532840052740123642735e-1\r\n\t},\r\n\tQone[] =\r\n\t{\r\n\t\t0.74917374171809127714519505e+4,\r\n\t\t0.154141773392650970499848051e+5,\r\n\t\t0.91522317015169922705904727e+4,\r\n\t\t0.18111867005523513506724158e+4,\r\n\t\t0.1038187585462133728776636e+3,\r\n\t\t0.1e+1\r\n\t};\r\n\r\n\tp = Pone[5];\r\n\tq = Qone[5];\r\n\tfor (i=4; i >= 0; i--)\r\n\t{\r\n\t\tp = p*(8.0/x)*(8.0/x)+Pone[i];\r\n\t\tq = q*(8.0/x)*(8.0/x)+Qone[i];\r\n\t}\r\n\treturn (double)(p/q);\r\n}", ".ernelBessel_Order1": "static double KernelBessel_Order1(double x)\r\n{\r\n\tdouble p, q;\r\n\r\n\tif (x == 0.0)\r\n\t\treturn (0.0f);\r\n\tp = x;\r\n\tif (x < 0.0)\r\n\t\tx=(-x);\r\n\tif (x < 8.0)\r\n\t\treturn (p*KernelBessel_J1(x));\r\n\tq = (double)sqrt(2.0f/(M_PI*x))*(double)(KernelBessel_P1(x)*(1.0f/sqrt(2.0f)*(sin(x)-cos(x)))-8.0f/x*KernelBessel_Q1(x)*\r\n\t\t(-1.0f/sqrt(2.0f)*(sin(x)+cos(x))));\r\n\tif (p < 0.0f)\r\n\t\tq = (-q);\r\n\treturn (q);\r\n}", ".etPixelOverflowTC": "static inline int getPixelOverflowTC(gdImagePtr im, const int x, const int y, const int bgColor)\r\n{\r\n\tif (gdImageBoundsSafe(im, x, y)) {\r\n\t\tconst int c = im->tpixels[y][x];\r\n\t\tif (c == im->transparent) {\r\n\t\t\treturn bgColor == -1 ? gdTrueColorAlpha(0, 0, 0, 127) : bgColor;\r\n\t\t}\r\n\t\treturn c;\r\n\t} else {\r\n\t\treturn bgColor;\r\n\t}\r\n}", ".etPixelOverflowPalette": "static inline int getPixelOverflowPalette(gdImagePtr im, const int x, const int y, const int bgColor)\r\n{\r\n\tif (gdImageBoundsSafe(im, x, y)) {\r\n\t\tconst int c = im->pixels[y][x];\r\n\t\tif (c == im->transparent) {\r\n\t\t\treturn bgColor == -1 ? gdTrueColorAlpha(0, 0, 0, 127) : bgColor;\r\n\t\t}\r\n\t\treturn colorIndex2RGBA(c);\r\n\t} else {\r\n\t\treturn bgColor;\r\n\t}\r\n}", ".etPixelInterpolateWeight": "static int getPixelInterpolateWeight(gdImagePtr im, const double x, const double y, const int bgColor)\r\n{\r\n\t/* Closest pixel <= (xf,yf) */\r\n\tint sx = (int)(x);\r\n\tint sy = (int)(y);\r\n\tconst double xf = x - (double)sx;\r\n\tconst double yf = y - (double)sy;\r\n\tconst double nxf = (double) 1.0 - xf;\r\n\tconst double nyf = (double) 1.0 - yf;\r\n\tconst double m1 = xf * yf;\r\n\tconst double m2 = nxf * yf;\r\n\tconst double m3 = xf * nyf;\r\n\tconst double m4 = nxf * nyf;\r\n\r\n\t/* get color values of neighbouring pixels */\r\n\tconst int c1 = im->trueColor == 1 ? getPixelOverflowTC(im, sx, sy, bgColor)         : getPixelOverflowPalette(im, sx, sy, bgColor);\r\n\tconst int c2 = im->trueColor == 1 ? getPixelOverflowTC(im, sx - 1, sy, bgColor)     : getPixelOverflowPalette(im, sx - 1, sy, bgColor);\r\n\tconst int c3 = im->trueColor == 1 ? getPixelOverflowTC(im, sx, sy - 1, bgColor)     : getPixelOverflowPalette(im, sx, sy - 1, bgColor);\r\n\tconst int c4 = im->trueColor == 1 ? getPixelOverflowTC(im, sx - 1, sy - 1, bgColor) : getPixelOverflowPalette(im, sx, sy - 1, bgColor);\r\n\tint r, g, b, a;\r\n\r\n\tif (x < 0) sx--;\r\n\tif (y < 0) sy--;\r\n\r\n\t/* component-wise summing-up of color values */\r\n\tif (im->trueColor) {\r\n\t\tr = (int)(m1*gdTrueColorGetRed(c1)   + m2*gdTrueColorGetRed(c2)   + m3*gdTrueColorGetRed(c3)   + m4*gdTrueColorGetRed(c4));\r\n\t\tg = (int)(m1*gdTrueColorGetGreen(c1) + m2*gdTrueColorGetGreen(c2) + m3*gdTrueColorGetGreen(c3) + m4*gdTrueColorGetGreen(c4));\r\n\t\tb = (int)(m1*gdTrueColorGetBlue(c1)  + m2*gdTrueColorGetBlue(c2)  + m3*gdTrueColorGetBlue(c3)  + m4*gdTrueColorGetBlue(c4));\r\n\t\ta = (int)(m1*gdTrueColorGetAlpha(c1) + m2*gdTrueColorGetAlpha(c2) + m3*gdTrueColorGetAlpha(c3) + m4*gdTrueColorGetAlpha(c4));\r\n\t} else {\r\n\t\tr = (int)(m1*im->red[(c1)]   + m2*im->red[(c2)]   + m3*im->red[(c3)]   + m4*im->red[(c4)]);\r\n\t\tg = (int)(m1*im->green[(c1)] + m2*im->green[(c2)] + m3*im->green[(c3)] + m4*im->green[(c4)]);\r\n\t\tb = (int)(m1*im->blue[(c1)]  + m2*im->blue[(c2)]  + m3*im->blue[(c3)]  + m4*im->blue[(c4)]);\r\n\t\ta = (int)(m1*im->alpha[(c1)] + m2*im->alpha[(c2)] + m3*im->alpha[(c3)] + m4*im->alpha[(c4)]);\r\n\t}\r\n\r\n\tr = CLAMP(r, 0, 255);\r\n\tg = CLAMP(g, 0, 255);\r\n\tb = CLAMP(b, 0, 255);\r\n\ta = CLAMP(a, 0, gdAlphaMax);\r\n\treturn gdTrueColorAlpha(r, g, b, a);\r\n}", ".dImageSetInterpolationMethod": "int gdImageSetInterpolationMethod(gdImagePtr im, gdInterpolationMethod id)\r\n{\r\n\tif (im == NULL || id < 0 || id > GD_METHOD_COUNT) {\r\n\t\treturn 0;\r\n\t}\r\n\r\n\tswitch (id) {\r\n\t\tcase GD_NEAREST_NEIGHBOUR:\r\n\t\tcase GD_WEIGHTED4:\r\n\t\t\tim->interpolation = NULL;\r\n\t\t\tbreak;\r\n\r\n\t\t/* generic versions*/\r\n\t\t/* GD_BILINEAR_FIXED and GD_BICUBIC_FIXED are kept for BC reasons */\r\n\t\tcase GD_BILINEAR_FIXED:\r\n\t\tcase GD_LINEAR:\r\n\t\t\tim->interpolation = filter_linear;\r\n\t\t\tbreak;\r\n\t\tcase GD_BELL:\r\n\t\t\tim->interpolation = filter_bell;\r\n\t\t\tbreak;\r\n\t\tcase GD_BESSEL:\r\n\t\t\tim->interpolation = filter_bessel;\r\n\t\t\tbreak;\r\n\t\tcase GD_BICUBIC_FIXED:\r\n\t\tcase GD_BICUBIC:\r\n\t\t\tim->interpolation = filter_bicubic;\r\n\t\t\tbreak;\r\n\t\tcase GD_BLACKMAN:\r\n\t\t\tim->interpolation = filter_blackman;\r\n\t\t\tbreak;\r\n\t\tcase GD_BOX:\r\n\t\t\tim->interpolation = filter_box;\r\n\t\t\tbreak;\r\n\t\tcase GD_BSPLINE:\r\n\t\t\tim->interpolation = filter_bspline;\r\n\t\t\tbreak;\r\n\t\tcase GD_CATMULLROM:\r\n\t\t\tim->interpolation = filter_catmullrom;\r\n\t\t\tbreak;\r\n\t\tcase GD_GAUSSIAN:\r\n\t\t\tim->interpolation = filter_gaussian;\r\n\t\t\tbreak;\r\n\t\tcase GD_GENERALIZED_CUBIC:\r\n\t\t\tim->interpolation = filter_generalized_cubic;\r\n\t\t\tbreak;\r\n\t\tcase GD_HERMITE:\r\n\t\t\tim->interpolation = filter_hermite;\r\n\t\t\tbreak;\r\n\t\tcase GD_HAMMING:\r\n\t\t\tim->interpolation = filter_hamming;\r\n\t\t\tbreak;\r\n\t\tcase GD_HANNING:\r\n\t\t\tim->interpolation = filter_hanning;\r\n\t\t\tbreak;\r\n\t\tcase GD_MITCHELL:\r\n\t\t\tim->interpolation = filter_mitchell;\r\n\t\t\tbreak;\r\n\t\tcase GD_POWER:\r\n\t\t\tim->interpolation = filter_power;\r\n\t\t\tbreak;\r\n\t\tcase GD_QUADRATIC:\r\n\t\t\tim->interpolation = filter_quadratic;\r\n\t\t\tbreak;\r\n\t\tcase GD_SINC:\r\n\t\t\tim->interpolation = filter_sinc;\r\n\t\t\tbreak;\r\n\t\tcase GD_TRIANGLE:\r\n\t\t\tim->interpolation = filter_triangle;\r\n\t\t\tbreak;\r\n\t\tcase GD_DEFAULT:\r\n\t\t\tid = GD_LINEAR;\r\n\t\t\tim->interpolation = filter_linear;\r\n\t\t\tbreak;\r\n\r\n\t\tdefault:\r\n\t\t\treturn 0;\r\n\t}\r\n\tim->interpolation_id = id;\r\n\treturn 1;\r\n}", ".dImageScaleBilinearTC": "static gdImagePtr gdImageScaleBilinearTC(gdImagePtr im, const unsigned int new_width, const unsigned int new_height)\r\n{\r\n\tlong dst_w = MAX(1, new_width);\r\n\tlong dst_h = MAX(1, new_height);\r\n\tfloat dx = (float)gdImageSX(im) / (float)dst_w;\r\n\tfloat dy = (float)gdImageSY(im) / (float)dst_h;\r\n\tgdFixed f_dx = gd_ftofx(dx);\r\n\tgdFixed f_dy = gd_ftofx(dy);\r\n\tgdFixed f_1 = gd_itofx(1);\r\n\r\n\tint dst_offset_h;\r\n\tint dst_offset_v = 0;\r\n\tlong i;\r\n\tgdImagePtr new_img;\r\n\r\n\tnew_img = gdImageCreateTrueColor(new_width, new_height);\r\n\tif (!new_img){\r\n\t\treturn NULL;\r\n\t}\r\n\r\n\tfor (i=0; i < dst_h; i++) {\r\n\t\tlong j;\r\n\t\tdst_offset_h = 0;\r\n\t\tfor (j=0; j < dst_w; j++) {\r\n\t\t\t/* Update bitmap */\r\n\t\t\tgdFixed f_i = gd_itofx(i);\r\n\t\t\tgdFixed f_j = gd_itofx(j);\r\n\t\t\tgdFixed f_a = gd_mulfx(f_i, f_dy);\r\n\t\t\tgdFixed f_b = gd_mulfx(f_j, f_dx);\r\n\t\t\tconst long m = gd_fxtoi(f_a);\r\n\t\t\tconst long n = gd_fxtoi(f_b);\r\n\t\t\tgdFixed f_f = f_a - gd_itofx(m);\r\n\t\t\tgdFixed f_g = f_b - gd_itofx(n);\r\n\r\n\t\t\tconst gdFixed f_w1 = gd_mulfx(f_1-f_f, f_1-f_g);\r\n\t\t\tconst gdFixed f_w2 = gd_mulfx(f_1-f_f, f_g);\r\n\t\t\tconst gdFixed f_w3 = gd_mulfx(f_f, f_1-f_g);\r\n\t\t\tconst gdFixed f_w4 = gd_mulfx(f_f, f_g);\r\n\t\t\tunsigned int pixel1;\r\n\t\t\tunsigned int pixel2;\r\n\t\t\tunsigned int pixel3;\r\n\t\t\tunsigned int pixel4;\r\n\t\t\tregister gdFixed f_r1, f_r2, f_r3, f_r4,\r\n\t\t\t\t\tf_g1, f_g2, f_g3, f_g4,\r\n\t\t\t\t\tf_b1, f_b2, f_b3, f_b4,\r\n\t\t\t\t\tf_a1, f_a2, f_a3, f_a4;\r\n\t\t\t/* 0 for bgColor; (n,m) is supposed to be valid anyway */\r\n\t\t\tpixel1 = getPixelOverflowTC(im, n, m, 0);\r\n\t\t\tpixel2 = getPixelOverflowTC(im, n + 1, m, pixel1);\r\n\t\t\tpixel3 = getPixelOverflowTC(im, n, m + 1, pixel1);\r\n\t\t\tpixel4 = getPixelOverflowTC(im, n + 1, m + 1, pixel1);\r\n\r\n\t\t\tf_r1 = gd_itofx(gdTrueColorGetRed(pixel1));\r\n\t\t\tf_r2 = gd_itofx(gdTrueColorGetRed(pixel2));\r\n\t\t\tf_r3 = gd_itofx(gdTrueColorGetRed(pixel3));\r\n\t\t\tf_r4 = gd_itofx(gdTrueColorGetRed(pixel4));\r\n\t\t\tf_g1 = gd_itofx(gdTrueColorGetGreen(pixel1));\r\n\t\t\tf_g2 = gd_itofx(gdTrueColorGetGreen(pixel2));\r\n\t\t\tf_g3 = gd_itofx(gdTrueColorGetGreen(pixel3));\r\n\t\t\tf_g4 = gd_itofx(gdTrueColorGetGreen(pixel4));\r\n\t\t\tf_b1 = gd_itofx(gdTrueColorGetBlue(pixel1));\r\n\t\t\tf_b2 = gd_itofx(gdTrueColorGetBlue(pixel2));\r\n\t\t\tf_b3 = gd_itofx(gdTrueColorGetBlue(pixel3));\r\n\t\t\tf_b4 = gd_itofx(gdTrueColorGetBlue(pixel4));\r\n\t\t\tf_a1 = gd_itofx(gdTrueColorGetAlpha(pixel1));\r\n\t\t\tf_a2 = gd_itofx(gdTrueColorGetAlpha(pixel2));\r\n\t\t\tf_a3 = gd_itofx(gdTrueColorGetAlpha(pixel3));\r\n\t\t\tf_a4 = gd_itofx(gdTrueColorGetAlpha(pixel4));\r\n\t\t\t{\r\n\t\t\t\tconst unsigned char red   = (unsigned char) gd_fxtoi(gd_mulfx(f_w1, f_r1) + gd_mulfx(f_w2, f_r2) + gd_mulfx(f_w3, f_r3) + gd_mulfx(f_w4, f_r4));\r\n\t\t\t\tconst unsigned char green = (unsigned char) gd_fxtoi(gd_mulfx(f_w1, f_g1) + gd_mulfx(f_w2, f_g2) + gd_mulfx(f_w3, f_g3) + gd_mulfx(f_w4, f_g4));\r\n\t\t\t\tconst unsigned char blue  = (unsigned char) gd_fxtoi(gd_mulfx(f_w1, f_b1) + gd_mulfx(f_w2, f_b2) + gd_mulfx(f_w3, f_b3) + gd_mulfx(f_w4, f_b4));\r\n\t\t\t\tconst unsigned char alpha = (unsigned char) gd_fxtoi(gd_mulfx(f_w1, f_a1) + gd_mulfx(f_w2, f_a2) + gd_mulfx(f_w3, f_a3) + gd_mulfx(f_w4, f_a4));\r\n\r\n\t\t\t\tnew_img->tpixels[dst_offset_v][dst_offset_h] = gdTrueColorAlpha(red, green, blue, alpha);\r\n\t\t\t}\r\n\r\n\t\t\tdst_offset_h++;\r\n\t\t}\r\n\r\n\t\tdst_offset_v++;\r\n\t}\r\n\treturn new_img;\r\n}", ".dImageScaleBilinearPalette": "static gdImagePtr gdImageScaleBilinearPalette(gdImagePtr im, const unsigned int new_width, const unsigned int new_height)\r\n{\r\n\tlong _width = MAX(1, new_width);\r\n\tlong _height = MAX(1, new_height);\r\n\tfloat dx = (float)gdImageSX(im) / (float)_width;\r\n\tfloat dy = (float)gdImageSY(im) / (float)_height;\r\n\tgdFixed f_dx = gd_ftofx(dx);\r\n\tgdFixed f_dy = gd_ftofx(dy);\r\n\tgdFixed f_1 = gd_itofx(1);\r\n\r\n\tint dst_offset_h;\r\n\tint dst_offset_v = 0;\r\n\tlong i;\r\n\tgdImagePtr new_img;\r\n\tconst int transparent = im->transparent;\r\n\r\n\tnew_img = gdImageCreateTrueColor(new_width, new_height);\r\n\tif (new_img == NULL) {\r\n\t\treturn NULL;\r\n\t}\r\n\r\n\tif (transparent < 0) {\r\n\t\t/* uninitialized */\r\n\t\tnew_img->transparent = -1;\r\n\t} else {\r\n\t\tnew_img->transparent = gdTrueColorAlpha(im->red[transparent], im->green[transparent], im->blue[transparent], im->alpha[transparent]);\r\n\t}\r\n\r\n\tfor (i=0; i < _height; i++) {\r\n\t\tlong j;\r\n\t\tconst gdFixed f_i = gd_itofx(i);\r\n\t\tconst gdFixed f_a = gd_mulfx(f_i, f_dy);\r\n\t\tregister long m = gd_fxtoi(f_a);\r\n\r\n\t\tdst_offset_h = 0;\r\n\r\n\t\tfor (j=0; j < _width; j++) {\r\n\t\t\t/* Update bitmap */\r\n\t\t\tgdFixed f_j = gd_itofx(j);\r\n\t\t\tgdFixed f_b = gd_mulfx(f_j, f_dx);\r\n\r\n\t\t\tconst long n = gd_fxtoi(f_b);\r\n\t\t\tgdFixed f_f = f_a - gd_itofx(m);\r\n\t\t\tgdFixed f_g = f_b - gd_itofx(n);\r\n\r\n\t\t\tconst gdFixed f_w1 = gd_mulfx(f_1-f_f, f_1-f_g);\r\n\t\t\tconst gdFixed f_w2 = gd_mulfx(f_1-f_f, f_g);\r\n\t\t\tconst gdFixed f_w3 = gd_mulfx(f_f, f_1-f_g);\r\n\t\t\tconst gdFixed f_w4 = gd_mulfx(f_f, f_g);\r\n\t\t\tunsigned int pixel1;\r\n\t\t\tunsigned int pixel2;\r\n\t\t\tunsigned int pixel3;\r\n\t\t\tunsigned int pixel4;\r\n\t\t\tregister gdFixed f_r1, f_r2, f_r3, f_r4,\r\n\t\t\t\t\tf_g1, f_g2, f_g3, f_g4,\r\n\t\t\t\t\tf_b1, f_b2, f_b3, f_b4,\r\n\t\t\t\t\tf_a1, f_a2, f_a3, f_a4;\r\n\r\n\t\t\t/* 0 for bgColor; (n,m) is supposed to be valid anyway */\r\n\t\t\tpixel1 = getPixelOverflowPalette(im, n, m, 0);\r\n\t\t\tpixel2 = getPixelOverflowPalette(im, n + 1, m, pixel1);\r\n\t\t\tpixel3 = getPixelOverflowPalette(im, n, m + 1, pixel1);\r\n\t\t\tpixel4 = getPixelOverflowPalette(im, n + 1, m + 1, pixel1);\r\n\r\n\t\t\tf_r1 = gd_itofx(gdTrueColorGetRed(pixel1));\r\n\t\t\tf_r2 = gd_itofx(gdTrueColorGetRed(pixel2));\r\n\t\t\tf_r3 = gd_itofx(gdTrueColorGetRed(pixel3));\r\n\t\t\tf_r4 = gd_itofx(gdTrueColorGetRed(pixel4));\r\n\t\t\tf_g1 = gd_itofx(gdTrueColorGetGreen(pixel1));\r\n\t\t\tf_g2 = gd_itofx(gdTrueColorGetGreen(pixel2));\r\n\t\t\tf_g3 = gd_itofx(gdTrueColorGetGreen(pixel3));\r\n\t\t\tf_g4 = gd_itofx(gdTrueColorGetGreen(pixel4));\r\n\t\t\tf_b1 = gd_itofx(gdTrueColorGetBlue(pixel1));\r\n\t\t\tf_b2 = gd_itofx(gdTrueColorGetBlue(pixel2));\r\n\t\t\tf_b3 = gd_itofx(gdTrueColorGetBlue(pixel3));\r\n\t\t\tf_b4 = gd_itofx(gdTrueColorGetBlue(pixel4));\r\n\t\t\tf_a1 = gd_itofx(gdTrueColorGetAlpha(pixel1));\r\n\t\t\tf_a2 = gd_itofx(gdTrueColorGetAlpha(pixel2));\r\n\t\t\tf_a3 = gd_itofx(gdTrueColorGetAlpha(pixel3));\r\n\t\t\tf_a4 = gd_itofx(gdTrueColorGetAlpha(pixel4));\r\n\r\n\t\t\t{\r\n\t\t\t\tconst unsigned char red = (unsigned char) gd_fxtoi(gd_mulfx(f_w1, f_r1) + gd_mulfx(f_w2, f_r2) + gd_mulfx(f_w3, f_r3) + gd_mulfx(f_w4, f_r4));\r\n\t\t\t\tconst unsigned char green = (unsigned char) gd_fxtoi(gd_mulfx(f_w1, f_g1) + gd_mulfx(f_w2, f_g2) + gd_mulfx(f_w3, f_g3) + gd_mulfx(f_w4, f_g4));\r\n\t\t\t\tconst unsigned char blue = (unsigned char) gd_fxtoi(gd_mulfx(f_w1, f_b1) + gd_mulfx(f_w2, f_b2) + gd_mulfx(f_w3, f_b3) + gd_mulfx(f_w4, f_b4));\r\n\t\t\t\tconst unsigned char alpha = (unsigned char) gd_fxtoi(gd_mulfx(f_w1, f_a1) + gd_mulfx(f_w2, f_a2) + gd_mulfx(f_w3, f_a3) + gd_mulfx(f_w4, f_a4));\r\n\r\n\t\t\t\tnew_img->tpixels[dst_offset_v][dst_offset_h] = gdTrueColorAlpha(red, green, blue, alpha);\r\n\t\t\t}\r\n\r\n\t\t\tdst_offset_h++;\r\n\t\t}\r\n\r\n\t\tdst_offset_v++;\r\n\t}\r\n\treturn new_img;\r\n}", ".dImageScaleNearestNeighbour": "static gdImagePtr\r\ngdImageScaleNearestNeighbour(gdImagePtr im, const unsigned int width, const unsigned int height)\r\n{\r\n\tconst unsigned long new_width = MAX(1, width);\r\n\tconst unsigned long new_height = MAX(1, height);\r\n\tconst float dx = (float)im->sx / (float)new_width;\r\n\tconst float dy = (float)im->sy / (float)new_height;\r\n\tconst gdFixed f_dx = gd_ftofx(dx);\r\n\tconst gdFixed f_dy = gd_ftofx(dy);\r\n\r\n\tgdImagePtr dst_img;\r\n\tunsigned long  dst_offset_x;\r\n\tunsigned long  dst_offset_y = 0;\r\n\tunsigned int i;\r\n\r\n\tdst_img = gdImageCreateTrueColor(new_width, new_height);\r\n\r\n\tif (dst_img == NULL) {\r\n\t\treturn NULL;\r\n\t}\r\n\r\n\tfor (i=0; i<new_height; i++) {\r\n\t\tunsigned int j;\r\n\t\tdst_offset_x = 0;\r\n\t\tif (im->trueColor) {\r\n\t\t\tfor (j=0; j<new_width; j++) {\r\n\t\t\t\tconst gdFixed f_i = gd_itofx(i);\r\n\t\t\t\tconst gdFixed f_j = gd_itofx(j);\r\n\t\t\t\tconst gdFixed f_a = gd_mulfx(f_i, f_dy);\r\n\t\t\t\tconst gdFixed f_b = gd_mulfx(f_j, f_dx);\r\n\t\t\t\tconst long m = gd_fxtoi(f_a);\r\n\t\t\t\tconst long n = gd_fxtoi(f_b);\r\n\r\n\t\t\t\tdst_img->tpixels[dst_offset_y][dst_offset_x++] = im->tpixels[m][n];\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tfor (j=0; j<new_width; j++) {\r\n\t\t\t\tconst gdFixed f_i = gd_itofx(i);\r\n\t\t\t\tconst gdFixed f_j = gd_itofx(j);\r\n\t\t\t\tconst gdFixed f_a = gd_mulfx(f_i, f_dy);\r\n\t\t\t\tconst gdFixed f_b = gd_mulfx(f_j, f_dx);\r\n\t\t\t\tconst long m = gd_fxtoi(f_a);\r\n\t\t\t\tconst long n = gd_fxtoi(f_b);\r\n\r\n\t\t\t\tdst_img->tpixels[dst_offset_y][dst_offset_x++] = colorIndex2RGBA(im->pixels[m][n]);\r\n\t\t\t}\r\n\t\t}\r\n\t\tdst_offset_y++;\r\n\t}\r\n\treturn dst_img;\r\n}", ".dImageScaleBilinear": "static gdImagePtr\r\ngdImageScaleBilinear(gdImagePtr im, const unsigned int new_width, const unsigned int new_height)\r\n{\r\n\tif (im->trueColor) {\r\n\t\treturn gdImageScaleBilinearTC(im, new_width, new_height);\r\n\t} else {\r\n\t\treturn gdImageScaleBilinearPalette(im, new_width, new_height);\r\n\t}\r\n}", ".dImageScaleBicubicFixed": "static gdImagePtr\r\ngdImageScaleBicubicFixed(gdImagePtr src, const unsigned int width, const unsigned int height)\r\n{\r\n\tconst long new_width = MAX(1, width);\r\n\tconst long new_height = MAX(1, height);\r\n\tconst int src_w = gdImageSX(src);\r\n\tconst int src_h = gdImageSY(src);\r\n\tconst gdFixed f_dx = gd_ftofx((float)src_w / (float)new_width);\r\n\tconst gdFixed f_dy = gd_ftofx((float)src_h / (float)new_height);\r\n\tconst gdFixed f_1 = gd_itofx(1);\r\n\tconst gdFixed f_2 = gd_itofx(2);\r\n\tconst gdFixed f_4 = gd_itofx(4);\r\n\tconst gdFixed f_6 = gd_itofx(6);\r\n\tconst gdFixed f_gamma = gd_ftofx(1.04f);\r\n\tgdImagePtr dst;\r\n\r\n\tunsigned int dst_offset_x;\r\n\tunsigned int dst_offset_y = 0;\r\n\tlong i;\r\n\r\n\t/* impact perf a bit, but not that much. Implementation for palette\r\n\t   images can be done at a later point.\r\n\t*/\r\n\tif (src->trueColor == 0) {\r\n\t\tgdImagePaletteToTrueColor(src);\r\n\t}\r\n\r\n\tdst = gdImageCreateTrueColor(new_width, new_height);\r\n\tif (!dst) {\r\n\t\treturn NULL;\r\n\t}\r\n\r\n\tdst->saveAlphaFlag = 1;\r\n\r\n\tfor (i=0; i < new_height; i++) {\r\n\t\tlong j;\r\n\t\tdst_offset_x = 0;\r\n\r\n\t\tfor (j=0; j < new_width; j++) {\r\n\t\t\tconst gdFixed f_a = gd_mulfx(gd_itofx(i), f_dy);\r\n\t\t\tconst gdFixed f_b = gd_mulfx(gd_itofx(j), f_dx);\r\n\t\t\tconst long m = gd_fxtoi(f_a);\r\n\t\t\tconst long n = gd_fxtoi(f_b);\r\n\t\t\tconst gdFixed f_f = f_a - gd_itofx(m);\r\n\t\t\tconst gdFixed f_g = f_b - gd_itofx(n);\r\n\t\t\tunsigned int src_offset_x[16], src_offset_y[16];\r\n\t\t\tlong k;\r\n\t\t\tregister gdFixed f_red = 0, f_green = 0, f_blue = 0, f_alpha = 0;\r\n\t\t\tunsigned char red, green, blue, alpha = 0;\r\n\t\t\tint *dst_row = dst->tpixels[dst_offset_y];\r\n\r\n\t\t\tif ((m < 1) || (n < 1)) {\r\n\t\t\t\tsrc_offset_x[0] = n;\r\n\t\t\t\tsrc_offset_y[0] = m;\r\n\t\t\t} else {\r\n\t\t\t\tsrc_offset_x[0] = n - 1;\r\n\t\t\t\tsrc_offset_y[0] = m;\r\n\t\t\t}\r\n\r\n\t\t\tsrc_offset_x[1] = n;\r\n\t\t\tsrc_offset_y[1] = m;\r\n\r\n\t\t\tif ((m < 1) || (n >= src_w - 1)) {\r\n\t\t\t\tsrc_offset_x[2] = n;\r\n\t\t\t\tsrc_offset_y[2] = m;\r\n\t\t\t} else {\r\n\t\t\t\tsrc_offset_x[2] = n + 1;\r\n\t\t\t\tsrc_offset_y[2] = m;\r\n\t\t\t}\r\n\r\n\t\t\tif ((m < 1) || (n >= src_w - 2)) {\r\n\t\t\t\tsrc_offset_x[3] = n;\r\n\t\t\t\tsrc_offset_y[3] = m;\r\n\t\t\t} else {\r\n\t\t\t\tsrc_offset_x[3] = n + 1 + 1;\r\n\t\t\t\tsrc_offset_y[3] = m;\r\n\t\t\t}\r\n\r\n\t\t\tif (n < 1) {\r\n\t\t\t\tsrc_offset_x[4] = n;\r\n\t\t\t\tsrc_offset_y[4] = m;\r\n\t\t\t} else {\r\n\t\t\t\tsrc_offset_x[4] = n - 1;\r\n\t\t\t\tsrc_offset_y[4] = m;\r\n\t\t\t}\r\n\r\n\t\t\tsrc_offset_x[5] = n;\r\n\t\t\tsrc_offset_y[5] = m;\r\n\t\t\tif (n >= src_w-1) {\r\n\t\t\t\tsrc_offset_x[6] = n;\r\n\t\t\t\tsrc_offset_y[6] = m;\r\n\t\t\t} else {\r\n\t\t\t\tsrc_offset_x[6] = n + 1;\r\n\t\t\t\tsrc_offset_y[6] = m;\r\n\t\t\t}\r\n\r\n\t\t\tif (n >= src_w - 2) {\r\n\t\t\t\tsrc_offset_x[7] = n;\r\n\t\t\t\tsrc_offset_y[7] = m;\r\n\t\t\t} else {\r\n\t\t\t\tsrc_offset_x[7] = n + 1 + 1;\r\n\t\t\t\tsrc_offset_y[7] = m;\r\n\t\t\t}\r\n\r\n\t\t\tif ((m >= src_h - 1) || (n < 1)) {\r\n\t\t\t\tsrc_offset_x[8] = n;\r\n\t\t\t\tsrc_offset_y[8] = m;\r\n\t\t\t} else {\r\n\t\t\t\tsrc_offset_x[8] = n - 1;\r\n\t\t\t\tsrc_offset_y[8] = m;\r\n\t\t\t}\r\n\r\n\t\t\tsrc_offset_x[9] = n;\r\n\t\t\tsrc_offset_y[9] = m;\r\n\r\n\t\t\tif ((m >= src_h-1) || (n >= src_w-1)) {\r\n\t\t\t\tsrc_offset_x[10] = n;\r\n\t\t\t\tsrc_offset_y[10] = m;\r\n\t\t\t} else {\r\n\t\t\t\tsrc_offset_x[10] = n + 1;\r\n\t\t\t\tsrc_offset_y[10] = m;\r\n\t\t\t}\r\n\r\n\t\t\tif ((m >= src_h - 1) || (n >= src_w - 2)) {\r\n\t\t\t\tsrc_offset_x[11] = n;\r\n\t\t\t\tsrc_offset_y[11] = m;\r\n\t\t\t} else {\r\n\t\t\t\tsrc_offset_x[11] = n + 1 + 1;\r\n\t\t\t\tsrc_offset_y[11] = m;\r\n\t\t\t}\r\n\r\n\t\t\tif ((m >= src_h - 2) || (n < 1)) {\r\n\t\t\t\tsrc_offset_x[12] = n;\r\n\t\t\t\tsrc_offset_y[12] = m;\r\n\t\t\t} else {\r\n\t\t\t\tsrc_offset_x[12] = n - 1;\r\n\t\t\t\tsrc_offset_y[12] = m;\r\n\t\t\t}\r\n\r\n\t\t\tsrc_offset_x[13] = n;\r\n\t\t\tsrc_offset_y[13] = m;\r\n\r\n\t\t\tif ((m >= src_h - 2) || (n >= src_w - 1)) {\r\n\t\t\t\tsrc_offset_x[14] = n;\r\n\t\t\t\tsrc_offset_y[14] = m;\r\n\t\t\t} else {\r\n\t\t\t\tsrc_offset_x[14] = n + 1;\r\n\t\t\t\tsrc_offset_y[14] = m;\r\n\t\t\t}\r\n\r\n\t\t\tif ((m >= src_h - 2) || (n >= src_w - 2)) {\r\n\t\t\t\tsrc_offset_x[15] = n;\r\n\t\t\t\tsrc_offset_y[15] = m;\r\n\t\t\t} else {\r\n\t\t\t\tsrc_offset_x[15] = n  + 1 + 1;\r\n\t\t\t\tsrc_offset_y[15] = m;\r\n\t\t\t}\r\n\r\n\t\t\tfor (k = -1; k < 3; k++) {\r\n\t\t\t\tconst gdFixed f = gd_itofx(k)-f_f;\r\n\t\t\t\tconst gdFixed f_fm1 = f - f_1;\r\n\t\t\t\tconst gdFixed f_fp1 = f + f_1;\r\n\t\t\t\tconst gdFixed f_fp2 = f + f_2;\r\n\t\t\t\tregister gdFixed f_a = 0, f_b = 0, f_d = 0, f_c = 0;\r\n\t\t\t\tregister gdFixed f_RY;\r\n\t\t\t\tint l;\r\n\r\n\t\t\t\tif (f_fp2 > 0) f_a = gd_mulfx(f_fp2, gd_mulfx(f_fp2,f_fp2));\r\n\t\t\t\tif (f_fp1 > 0) f_b = gd_mulfx(f_fp1, gd_mulfx(f_fp1,f_fp1));\r\n\t\t\t\tif (f > 0)     f_c = gd_mulfx(f, gd_mulfx(f,f));\r\n\t\t\t\tif (f_fm1 > 0) f_d = gd_mulfx(f_fm1, gd_mulfx(f_fm1,f_fm1));\r\n\r\n\t\t\t\tf_RY = gd_divfx((f_a - gd_mulfx(f_4,f_b) + gd_mulfx(f_6,f_c) - gd_mulfx(f_4,f_d)),f_6);\r\n\r\n\t\t\t\tfor (l = -1; l < 3; l++) {\r\n\t\t\t\t\tconst gdFixed f = gd_itofx(l) - f_g;\r\n\t\t\t\t\tconst gdFixed f_fm1 = f - f_1;\r\n\t\t\t\t\tconst gdFixed f_fp1 = f + f_1;\r\n\t\t\t\t\tconst gdFixed f_fp2 = f + f_2;\r\n\t\t\t\t\tregister gdFixed f_a = 0, f_b = 0, f_c = 0, f_d = 0;\r\n\t\t\t\t\tregister gdFixed f_RX, f_R, f_rs, f_gs, f_bs, f_ba;\r\n\t\t\t\t\tregister int c;\r\n\t\t\t\t\tconst int _k = ((k+1)*4) + (l+1);\r\n\r\n\t\t\t\t\tif (f_fp2 > 0) f_a = gd_mulfx(f_fp2,gd_mulfx(f_fp2,f_fp2));\r\n\r\n\t\t\t\t\tif (f_fp1 > 0) f_b = gd_mulfx(f_fp1,gd_mulfx(f_fp1,f_fp1));\r\n\r\n\t\t\t\t\tif (f > 0) f_c = gd_mulfx(f,gd_mulfx(f,f));\r\n\r\n\t\t\t\t\tif (f_fm1 > 0) f_d = gd_mulfx(f_fm1,gd_mulfx(f_fm1,f_fm1));\r\n\r\n\t\t\t\t\tf_RX = gd_divfx((f_a-gd_mulfx(f_4,f_b)+gd_mulfx(f_6,f_c)-gd_mulfx(f_4,f_d)),f_6);\r\n\t\t\t\t\tf_R = gd_mulfx(f_RY,f_RX);\r\n\r\n\t\t\t\t\tc = src->tpixels[*(src_offset_y + _k)][*(src_offset_x + _k)];\r\n\t\t\t\t\tf_rs = gd_itofx(gdTrueColorGetRed(c));\r\n\t\t\t\t\tf_gs = gd_itofx(gdTrueColorGetGreen(c));\r\n\t\t\t\t\tf_bs = gd_itofx(gdTrueColorGetBlue(c));\r\n\t\t\t\t\tf_ba = gd_itofx(gdTrueColorGetAlpha(c));\r\n\r\n\t\t\t\t\tf_red += gd_mulfx(f_rs,f_R);\r\n\t\t\t\t\tf_green += gd_mulfx(f_gs,f_R);\r\n\t\t\t\t\tf_blue += gd_mulfx(f_bs,f_R);\r\n\t\t\t\t\tf_alpha += gd_mulfx(f_ba,f_R);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tred    = (unsigned char) CLAMP(gd_fxtoi(gd_mulfx(f_red,   f_gamma)),  0, 255);\r\n\t\t\tgreen  = (unsigned char) CLAMP(gd_fxtoi(gd_mulfx(f_green, f_gamma)),  0, 255);\r\n\t\t\tblue   = (unsigned char) CLAMP(gd_fxtoi(gd_mulfx(f_blue,  f_gamma)),  0, 255);\r\n\t\t\talpha  = (unsigned char) CLAMP(gd_fxtoi(gd_mulfx(f_alpha,  f_gamma)), 0, 127);\r\n\r\n\t\t\t*(dst_row + dst_offset_x) = gdTrueColorAlpha(red, green, blue, alpha);\r\n\r\n\t\t\tdst_offset_x++;\r\n\t\t}\r\n\t\tdst_offset_y++;\r\n\t}\r\n\treturn dst;\r\n}", ".dImageScaleTwoPass": "static gdImagePtr\r\ngdImageScaleTwoPass(const gdImagePtr src, const unsigned int src_width, const unsigned int src_height, const unsigned int new_width, const unsigned int new_height)\r\n{\r\n\tgdImagePtr tmp_im;\r\n\tgdImagePtr dst;\r\n\tint scale_pass_res;\r\n\r\n\t/* Convert to truecolor if it isn't; this code requires it. */\r\n\tif (!src->trueColor) {\r\n\t\tgdImagePaletteToTrueColor(src);\r\n\t}\r\n\r\n\ttmp_im = gdImageCreateTrueColor(new_width, src_height);\r\n\tif (tmp_im == NULL) {\r\n\t\treturn NULL;\r\n\t}\r\n\tgdImageSetInterpolationMethod(tmp_im, src->interpolation_id);\r\n\tscale_pass_res = _gdScaleHoriz(src, src_width, src_height, tmp_im, new_width, src_height);\r\n\tif (scale_pass_res != 1) {\r\n\t\tgdImageDestroy(tmp_im);\r\n\t\treturn NULL;\r\n\t}\r\n\r\n\tdst = gdImageCreateTrueColor(new_width, new_height);\r\n\tif (dst == NULL) {\r\n\t\tgdImageDestroy(tmp_im);\r\n\t\treturn NULL;\r\n\t}\r\n\tgdImageSetInterpolationMethod(dst, src->interpolation_id);\r\n\tscale_pass_res = _gdScaleVert(tmp_im, new_width, src_height, dst, new_width, new_height);\r\n\tif (scale_pass_res != 1) {\r\n\t\tgdImageDestroy(dst);\r\n\t\tgdImageDestroy(tmp_im);\r\n\t\treturn NULL;\r\n\t}\r\n\tgdImageDestroy(tmp_im);\r\n\r\n\treturn dst;\r\n}", ".dTransformAffineBoundingBox": "int gdTransformAffineBoundingBox(gdRectPtr src, const double affine[6], gdRectPtr bbox)\r\n{\r\n\tgdPointF extent[4], min, max, point;\r\n\tint i;\r\n\r\n\textent[0].x=0.0;\r\n\textent[0].y=0.0;\r\n\textent[1].x=(double) src->width;\r\n\textent[1].y=0.0;\r\n\textent[2].x=(double) src->width;\r\n\textent[2].y=(double) src->height;\r\n\textent[3].x=0.0;\r\n\textent[3].y=(double) src->height;\r\n\r\n\tfor (i=0; i < 4; i++) {\r\n\t\tpoint=extent[i];\r\n\t\tif (gdAffineApplyToPointF(&extent[i], &point, affine) != GD_TRUE) {\r\n\t\t\treturn GD_FALSE;\r\n\t\t}\r\n\t}\r\n\tmin=extent[0];\r\n\tmax=extent[0];\r\n\r\n\tfor (i=1; i < 4; i++) {\r\n\t\tif (min.x > extent[i].x)\r\n\t\t\tmin.x=extent[i].x;\r\n\t\tif (min.y > extent[i].y)\r\n\t\t\tmin.y=extent[i].y;\r\n\t\tif (max.x < extent[i].x)\r\n\t\t\tmax.x=extent[i].x;\r\n\t\tif (max.y < extent[i].y)\r\n\t\t\tmax.y=extent[i].y;\r\n\t}\r\n\tbbox->x = (int) min.x;\r\n\tbbox->y = (int) min.y;\r\n\tbbox->width  = (int) floor(max.x - min.x) - 1;\r\n\tbbox->height = (int) floor(max.y - min.y);\r\n\treturn GD_TRUE;\r\n}", ".dRotatedImageSize": "static int gdRotatedImageSize(gdImagePtr src, const float angle, gdRectPtr bbox)\r\n{\r\n    gdRect src_area;\r\n    double m[6];\r\n\r\n    gdAffineRotate(m, angle);\r\n    src_area.x = 0;\r\n    src_area.y = 0;\r\n    src_area.width = gdImageSX(src);\r\n    src_area.height = gdImageSY(src);\r\n    if (gdTransformAffineBoundingBox(&src_area, m, bbox) != GD_TRUE) {\r\n        return GD_FALSE;\r\n    }\r\n\r\n    return GD_TRUE;\r\n}", ".etPixelInterpolated": "int getPixelInterpolated(gdImagePtr im, const double x, const double y, const int bgColor)\r\n{\r\n\tconst int xi=(int)(x);\r\n\tconst int yi=(int)(y);\r\n\tint yii;\r\n\tint i;\r\n\tdouble kernel, kernel_cache_y;\r\n\tdouble kernel_x[12], kernel_y[4];\r\n\tdouble new_r = 0.0f, new_g = 0.0f, new_b = 0.0f, new_a = 0.0f;\r\n\r\n\t/* These methods use special implementations */\r\n\tif (im->interpolation_id == GD_NEAREST_NEIGHBOUR) {\r\n\t\treturn -1;\r\n\t}\r\n\r\n\tif (im->interpolation_id == GD_WEIGHTED4) {\r\n\t\treturn getPixelInterpolateWeight(im, x, y, bgColor);\r\n\t}\r\n\r\n\tif (im->interpolation_id == GD_NEAREST_NEIGHBOUR) {\r\n\t\tif (im->trueColor == 1) {\r\n\t\t\treturn getPixelOverflowTC(im, xi, yi, bgColor);\r\n\t\t} else {\r\n\t\t\treturn getPixelOverflowPalette(im, xi, yi, bgColor);\r\n\t\t}\r\n\t}\r\n\tif (im->interpolation) {\r\n\t\tfor (i=0; i<4; i++) {\r\n\t\t\tkernel_x[i] = (double) im->interpolation((double)(xi+i-1-x));\r\n\t\t\tkernel_y[i] = (double) im->interpolation((double)(yi+i-1-y));\r\n\t\t}\r\n\t} else {\r\n\t\treturn -1;\r\n\t}\r\n\r\n\t/*\r\n\t * TODO: use the known fast rgba multiplication implementation once\r\n\t * the new formats are in place\r\n\t */\r\n\tfor (yii = yi-1; yii < yi+3; yii++) {\r\n\t\tint xii;\r\n\t\tkernel_cache_y = kernel_y[yii-(yi-1)];\r\n\t\tif (im->trueColor) {\r\n\t\t\tfor (xii=xi-1; xii<xi+3; xii++) {\r\n\t\t\t\tconst int rgbs = getPixelOverflowTC(im, xii, yii, bgColor);\r\n\r\n\t\t\t\tkernel = kernel_cache_y * kernel_x[xii-(xi-1)];\r\n\t\t\t\tnew_r += kernel * gdTrueColorGetRed(rgbs);\r\n\t\t\t\tnew_g += kernel * gdTrueColorGetGreen(rgbs);\r\n\t\t\t\tnew_b += kernel * gdTrueColorGetBlue(rgbs);\r\n\t\t\t\tnew_a += kernel * gdTrueColorGetAlpha(rgbs);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tfor (xii=xi-1; xii<xi+3; xii++) {\r\n\t\t\t\tconst int rgbs = getPixelOverflowPalette(im, xii, yii, bgColor);\r\n\r\n\t\t\t\tkernel = kernel_cache_y * kernel_x[xii-(xi-1)];\r\n\t\t\t\tnew_r += kernel * gdTrueColorGetRed(rgbs);\r\n\t\t\t\tnew_g += kernel * gdTrueColorGetGreen(rgbs);\r\n\t\t\t\tnew_b += kernel * gdTrueColorGetBlue(rgbs);\r\n\t\t\t\tnew_a += kernel * gdTrueColorGetAlpha(rgbs);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tnew_r = CLAMP(new_r, 0, 255);\r\n\tnew_g = CLAMP(new_g, 0, 255);\r\n\tnew_b = CLAMP(new_b, 0, 255);\r\n\tnew_a = CLAMP(new_a, 0, gdAlphaMax);\r\n\r\n\treturn gdTrueColorAlpha(((int)new_r), ((int)new_g), ((int)new_b), ((int)new_a));\r\n}", ".dImageRotateNearestNeighbour": "static gdImagePtr\r\ngdImageRotateNearestNeighbour(gdImagePtr src, const float degrees, const int bgColor)\r\n{\r\n\tfloat _angle = ((float) (-degrees / 180.0f) * (float)M_PI);\r\n\tconst int src_w  = gdImageSX(src);\r\n\tconst int src_h = gdImageSY(src);\r\n\tconst gdFixed f_0_5 = gd_ftofx(0.5f);\r\n\tconst gdFixed f_H = gd_itofx(src_h/2);\r\n\tconst gdFixed f_W = gd_itofx(src_w/2);\r\n\tconst gdFixed f_cos = gd_ftofx(cos(-_angle));\r\n\tconst gdFixed f_sin = gd_ftofx(sin(-_angle));\r\n\r\n\tunsigned int dst_offset_x;\r\n\tunsigned int dst_offset_y = 0;\r\n\tunsigned int i;\r\n\tgdImagePtr dst;\r\n\tgdRect bbox;\r\n\tint new_height, new_width;\r\n\r\n    gdRotatedImageSize(src, degrees, &bbox);\r\n    new_width = bbox.width;\r\n    new_height = bbox.height;\r\n\r\n\tdst = gdImageCreateTrueColor(new_width, new_height);\r\n\tif (!dst) {\r\n\t\treturn NULL;\r\n\t}\r\n\tdst->saveAlphaFlag = 1;\r\n\tfor (i = 0; i < new_height; i++) {\r\n\t\tunsigned int j;\r\n\t\tdst_offset_x = 0;\r\n\t\tfor (j = 0; j < new_width; j++) {\r\n\t\t\tgdFixed f_i = gd_itofx((int)i - (int)new_height/2);\r\n\t\t\tgdFixed f_j = gd_itofx((int)j - (int)new_width/2);\r\n\t\t\tgdFixed f_m = gd_mulfx(f_j,f_sin) + gd_mulfx(f_i,f_cos) + f_0_5 + f_H;\r\n\t\t\tgdFixed f_n = gd_mulfx(f_j,f_cos) - gd_mulfx(f_i,f_sin) + f_0_5 + f_W;\r\n\t\t\tlong m = gd_fxtoi(f_m);\r\n\t\t\tlong n = gd_fxtoi(f_n);\r\n\r\n\t\t\tif ((m > 0) && (m < src_h-1) && (n > 0) && (n < src_w-1)) {\r\n\t\t\t\tif (dst_offset_y < new_height) {\r\n\t\t\t\t\tdst->tpixels[dst_offset_y][dst_offset_x++] = src->tpixels[m][n];\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tif (dst_offset_y < new_height) {\r\n\t\t\t\t\tdst->tpixels[dst_offset_y][dst_offset_x++] = bgColor;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tdst_offset_y++;\r\n\t}\r\n\treturn dst;\r\n}", ".dImageRotateGeneric": "static gdImagePtr\r\ngdImageRotateGeneric(gdImagePtr src, const float degrees, const int bgColor)\r\n{\r\n\tfloat _angle = ((float) (-degrees / 180.0f) * (float)M_PI);\r\n\tconst int src_w  = gdImageSX(src);\r\n\tconst int src_h = gdImageSY(src);\r\n\tconst gdFixed f_0_5 = gd_ftofx(0.5f);\r\n\tconst gdFixed f_H = gd_itofx(src_h/2);\r\n\tconst gdFixed f_W = gd_itofx(src_w/2);\r\n\tconst gdFixed f_cos = gd_ftofx(cos(-_angle));\r\n\tconst gdFixed f_sin = gd_ftofx(sin(-_angle));\r\n\r\n\tunsigned int dst_offset_x;\r\n\tunsigned int dst_offset_y = 0;\r\n\tunsigned int i;\r\n\tgdImagePtr dst;\r\n\tint new_width, new_height;\r\n\tgdRect bbox;\r\n\r\n\tif (bgColor < 0) {\r\n\t\treturn NULL;\r\n\t}\r\n\r\n\tif (src->interpolation == NULL) {\r\n\t\tgdImageSetInterpolationMethod(src, GD_DEFAULT);\r\n\t}\r\n\r\n    gdRotatedImageSize(src, degrees, &bbox);\r\n    new_width = bbox.width;\r\n    new_height = bbox.height;\r\n\r\n\tdst = gdImageCreateTrueColor(new_width, new_height);\r\n\tif (!dst) {\r\n\t\treturn NULL;\r\n\t}\r\n\tdst->saveAlphaFlag = 1;\r\n\r\n\tfor (i = 0; i < new_height; i++) {\r\n\t\tunsigned int j;\r\n\t\tdst_offset_x = 0;\r\n\t\tfor (j = 0; j < new_width; j++) {\r\n\t\t\tgdFixed f_i = gd_itofx((int)i - (int)new_height/ 2);\r\n\t\t\tgdFixed f_j = gd_itofx((int)j - (int)new_width / 2);\r\n\t\t\tgdFixed f_m = gd_mulfx(f_j,f_sin) + gd_mulfx(f_i,f_cos) + f_0_5 + f_H;\r\n\t\t\tgdFixed f_n = gd_mulfx(f_j,f_cos) - gd_mulfx(f_i,f_sin) + f_0_5 + f_W;\r\n\t\t\tlong m = gd_fxtoi(f_m);\r\n\t\t\tlong n = gd_fxtoi(f_n);\r\n\r\n\t\t\tif (m < -1 || n < -1 || m >= src_h || n >= src_w ) {\r\n\t\t\t\tdst->tpixels[dst_offset_y][dst_offset_x++] = bgColor;\r\n\t\t\t} else {\r\n\t\t\t\tdst->tpixels[dst_offset_y][dst_offset_x++] = getPixelInterpolated(src, gd_fxtod(f_n), gd_fxtod(f_m), bgColor);\r\n\t\t\t}\r\n\t\t}\r\n\t\tdst_offset_y++;\r\n\t}\r\n\treturn dst;\r\n}", ".dTransformAffineCopy": "int gdTransformAffineCopy(gdImagePtr dst,\r\n\t\t  int dst_x, int dst_y,\r\n\t\t  const gdImagePtr src,\r\n\t\t  gdRectPtr src_region,\r\n\t\t  const double affine[6])\r\n{\r\n\tint c1x,c1y,c2x,c2y;\r\n\tint backclip = 0;\r\n\tint backup_clipx1, backup_clipy1, backup_clipx2, backup_clipy2;\r\n\tregister int x, y, src_offset_x, src_offset_y;\r\n\tdouble inv[6];\r\n\tgdPointF pt, src_pt;\r\n\tgdRect bbox;\r\n\tint end_x, end_y;\r\n\tgdInterpolationMethod interpolation_id_bak = src->interpolation_id;\r\n\r\n\t/* These methods use special implementations */\r\n\tif (src->interpolation_id == GD_BILINEAR_FIXED || src->interpolation_id == GD_BICUBIC_FIXED || src->interpolation_id == GD_NEAREST_NEIGHBOUR) {\r\n\t\tinterpolation_id_bak = src->interpolation_id;\r\n\r\n\t\tgdImageSetInterpolationMethod(src, GD_BICUBIC);\r\n\t}\r\n\r\n\r\n\tgdImageClipRectangle(src, src_region);\r\n\r\n\tif (src_region->x > 0 || src_region->y > 0\r\n\t\t|| src_region->width < gdImageSX(src)\r\n\t\t|| src_region->height < gdImageSY(src)) {\r\n\t\tbackclip = 1;\r\n\r\n\t\tgdImageGetClip(src, &backup_clipx1, &backup_clipy1,\r\n\t\t&backup_clipx2, &backup_clipy2);\r\n\r\n\t\tgdImageSetClip(src, src_region->x, src_region->y,\r\n\t\t\tsrc_region->x + src_region->width - 1,\r\n\t\t\tsrc_region->y + src_region->height - 1);\r\n\t}\r\n\r\n\tif (!gdTransformAffineBoundingBox(src_region, affine, &bbox)) {\r\n\t\tif (backclip) {\r\n\t\t\tgdImageSetClip(src, backup_clipx1, backup_clipy1,\r\n\t\t\t\t\tbackup_clipx2, backup_clipy2);\r\n\t\t}\r\n\t\tgdImageSetInterpolationMethod(src, interpolation_id_bak);\r\n\t\treturn GD_FALSE;\r\n\t}\r\n\r\n\tgdImageGetClip(dst, &c1x, &c1y, &c2x, &c2y);\r\n\r\n\tend_x = bbox.width  + abs(bbox.x);\r\n\tend_y = bbox.height + abs(bbox.y);\r\n\r\n\t/* Get inverse affine to let us work with destination -> source */\r\n\tif (gdAffineInvert(inv, affine) == GD_FALSE) {\r\n\t\tgdImageSetInterpolationMethod(src, interpolation_id_bak);\r\n\t\treturn GD_FALSE;\r\n\t}\r\n\r\n\tsrc_offset_x =  src_region->x;\r\n\tsrc_offset_y =  src_region->y;\r\n\r\n\tif (dst->alphaBlendingFlag) {\r\n\t\tfor (y = bbox.y; y <= end_y; y++) {\r\n\t\t\tpt.y = y + 0.5;\r\n\t\t\tfor (x = 0; x <= end_x; x++) {\r\n\t\t\t\tpt.x = x + 0.5;\r\n\t\t\t\tgdAffineApplyToPointF(&src_pt, &pt, inv);\r\n\t\t\t\tgdImageSetPixel(dst, dst_x + x, dst_y + y, getPixelInterpolated(src, src_offset_x + src_pt.x, src_offset_y + src_pt.y, 0));\r\n\t\t\t}\r\n\t\t}\r\n\t} else {\r\n\t\tfor (y = 0; y <= end_y; y++) {\r\n\t\t\tunsigned char *dst_p = NULL;\r\n\t\t\tint *tdst_p = NULL;\r\n\r\n\t\t\tpt.y = y + 0.5 + bbox.y;\r\n\t\t\tif ((dst_y + y) < 0 || ((dst_y + y) > gdImageSY(dst) -1)) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tif (dst->trueColor) {\r\n\t\t\t\ttdst_p = dst->tpixels[dst_y + y] + dst_x;\r\n\t\t\t} else {\r\n\t\t\t\tdst_p = dst->pixels[dst_y + y] + dst_x;\r\n\t\t\t}\r\n\r\n\t\t\tfor (x = 0; x <= end_x; x++) {\r\n\t\t\t\tpt.x = x + 0.5 + bbox.x;\r\n\t\t\t\tgdAffineApplyToPointF(&src_pt, &pt, inv);\r\n\r\n\t\t\t\tif ((dst_x + x) < 0 || (dst_x + x) > (gdImageSX(dst) - 1)) {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tif (dst->trueColor) {\r\n\t\t\t\t\t*(tdst_p++) = getPixelInterpolated(src, src_offset_x + src_pt.x, src_offset_y + src_pt.y, -1);\r\n\t\t\t\t} else {\r\n\t\t\t\t\t*(dst_p++) = getPixelInterpolated(src, src_offset_x + src_pt.x, src_offset_y + src_pt.y, -1);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/* Restore clip if required */\r\n\tif (backclip) {\r\n\t\tgdImageSetClip(src, backup_clipx1, backup_clipy1,\r\n\t\t\t\tbackup_clipx2, backup_clipy2);\r\n\t}\r\n\r\n\tgdImageSetInterpolationMethod(src, interpolation_id_bak);\r\n\treturn GD_TRUE;\r\n}", ".dImageClipRectangle": "static void gdImageClipRectangle(gdImagePtr im, gdRectPtr r)\r\n{\r\n\tint c1x, c1y, c2x, c2y;\r\n\tint x1,y1;\r\n\r\n\tgdImageGetClip(im, &c1x, &c1y, &c2x, &c2y);\r\n\tx1 = r->x + r->width - 1;\r\n\ty1 = r->y + r->height - 1;\r\n\tr->x = CLAMP(r->x, c1x, c2x);\r\n\tr->y = CLAMP(r->y, c1y, c2y);\r\n\tr->width = CLAMP(x1, c1x, c2x) - r->x + 1;\r\n\tr->height = CLAMP(y1, c1y, c2y) - r->y + 1;\r\n}", ".ilter_linear": "double filter_linear(const double x) {\r\n\tdouble ax = fabs(x);\r\n\tif (ax < 1.0f) {\r\n\t\treturn (1.0f - ax);\r\n\t}\r\n\treturn 0.0f;\r\n}", ".ilter_bell": "static double filter_bell(const double x1)\r\n{\r\n\tconst double x = x1 < 0.0 ? -x1 : x1;\r\n\r\n\tif (x < 0.5) return (0.75 - x*x);\r\n\tif (x < 1.5) return (0.5 * pow(x - 1.5, 2.0));\r\n\treturn 0.0;\r\n}", ".ilter_bessel": "static double filter_bessel(const double x)\r\n{\r\n\tif (x == 0.0f)\r\n\t\treturn (double)(M_PI/4.0f);\r\n\treturn (KernelBessel_Order1((double)M_PI*x)/(2.0f*x));\r\n}", ".ilter_bicubic": "static double filter_bicubic(const double t)\r\n{\r\n  const double abs_t = (double)fabs(t);\r\n  const double abs_t_sq = abs_t * abs_t;\r\n  if (abs_t<1) return 1-2*abs_t_sq+abs_t_sq*abs_t;\r\n  if (abs_t<2) return 4 - 8*abs_t +5*abs_t_sq - abs_t_sq*abs_t;\r\n  return 0;\r\n}", ".ilter_blackman": "static double filter_blackman(const double x)\r\n{\r\n\treturn (0.42f+0.5f*(double)cos(M_PI*x)+0.08f*(double)cos(2.0f*M_PI*x));\r\n}", ".ilter_box": "static double filter_box(double x) {\r\n\tif (x < - DEFAULT_FILTER_BOX)\r\n\t\treturn 0.0f;\r\n\tif (x < DEFAULT_FILTER_BOX)\r\n\t\treturn 1.0f;\r\n\treturn 0.0f;\r\n}", ".ilter_bspline": "static double filter_bspline(const double x)\r\n{\r\n\tif (x>2.0f) {\r\n\t\treturn 0.0f;\r\n\t} else {\r\n\t\tdouble a, b, c, d;\r\n\t\t/* Was calculated anyway cause the \"if((x-1.0f) < 0)\" */\r\n\t\tconst double xm1 = x - 1.0f;\r\n\t\tconst double xp1 = x + 1.0f;\r\n\t\tconst double xp2 = x + 2.0f;\r\n\r\n\t\tif ((xp2) <= 0.0f) a = 0.0f; else a = xp2*xp2*xp2;\r\n\t\tif ((xp1) <= 0.0f) b = 0.0f; else b = xp1*xp1*xp1;\r\n\t\tif (x <= 0) c = 0.0f; else c = x*x*x;\r\n\t\tif ((xm1) <= 0.0f) d = 0.0f; else d = xm1*xm1*xm1;\r\n\r\n\t\treturn (0.16666666666666666667f * (a - (4.0f * b) + (6.0f * c) - (4.0f * d)));\r\n\t}\r\n}", ".ilter_catmullrom": "static double filter_catmullrom(const double x)\r\n{\r\n\tif (x < -2.0)\r\n\t\treturn(0.0f);\r\n\tif (x < -1.0)\r\n\t\treturn(0.5f*(4.0f+x*(8.0f+x*(5.0f+x))));\r\n\tif (x < 0.0)\r\n\t\treturn(0.5f*(2.0f+x*x*(-5.0f-3.0f*x)));\r\n\tif (x < 1.0)\r\n\t\treturn(0.5f*(2.0f+x*x*(-5.0f+3.0f*x)));\r\n\tif (x < 2.0)\r\n\t\treturn(0.5f*(4.0f+x*(-8.0f+x*(5.0f-x))));\r\n\treturn(0.0f);\r\n}", ".ilter_gaussian": "static double filter_gaussian(const double x)\r\n{\r\n\t/* return(exp((double) (-2.0 * x * x)) * sqrt(2.0 / M_PI)); */\r\n\treturn (double)(exp(-2.0f * x * x) * 0.79788456080287f);\r\n}", ".ilter_generalized_cubic": "static double filter_generalized_cubic(const double t)\r\n{\r\n\tconst double a = -DEFAULT_FILTER_GENERALIZED_CUBIC;\r\n\tdouble abs_t = (double)fabs(t);\r\n\tdouble abs_t_sq = abs_t * abs_t;\r\n\tif (abs_t < 1) return (a + 2) * abs_t_sq * abs_t - (a + 3) * abs_t_sq + 1;\r\n\tif (abs_t < 2) return a * abs_t_sq * abs_t - 5 * a * abs_t_sq + 8 * a * abs_t - 4 * a;\r\n\treturn 0;\r\n}", ".ilter_hermite": "static double filter_hermite(const double x1)\r\n{\r\n\tconst double x = x1 < 0.0 ? -x1 : x1;\r\n\r\n\tif (x < 1.0) return ((2.0 * x - 3) * x * x + 1.0 );\r\n\r\n\treturn 0.0;\r\n}", ".ilter_hamming": "static double filter_hamming(const double x)\r\n{\r\n\t/* should be\r\n\t(0.54+0.46*cos(M_PI*(double) x));\r\n\tbut this approximation is sufficient */\r\n\tif (x < -1.0f)\r\n\t\treturn 0.0f;\r\n\tif (x < 0.0f)\r\n\t\treturn 0.92f*(-2.0f*x-3.0f)*x*x+1.0f;\r\n\tif (x < 1.0f)\r\n\t\treturn 0.92f*(2.0f*x-3.0f)*x*x+1.0f;\r\n\treturn 0.0f;\r\n}", ".ilter_hanning": "static double filter_hanning(const double x)\r\n{\r\n\t/* A Cosine windowing function */\r\n\treturn(0.5 + 0.5 * cos(M_PI * x));\r\n}", ".ilter_mitchell": "static double filter_mitchell(const double x)\r\n{\r\n#define KM_B (1.0f/3.0f)\r\n#define KM_C (1.0f/3.0f)\r\n#define KM_P0 ((  6.0f - 2.0f * KM_B ) / 6.0f)\r\n#define KM_P2 ((-18.0f + 12.0f * KM_B + 6.0f * KM_C) / 6.0f)\r\n#define KM_P3 (( 12.0f - 9.0f  * KM_B - 6.0f * KM_C) / 6.0f)\r\n#define KM_Q0 ((  8.0f * KM_B + 24.0f * KM_C) / 6.0f)\r\n#define KM_Q1 ((-12.0f * KM_B - 48.0f * KM_C) / 6.0f)\r\n#define KM_Q2 ((  6.0f * KM_B + 30.0f * KM_C) / 6.0f)\r\n#define KM_Q3 (( -1.0f * KM_B -  6.0f * KM_C) / 6.0f)\r\n\r\n\tif (x < -2.0)\r\n\t\treturn(0.0f);\r\n\tif (x < -1.0)\r\n\t\treturn(KM_Q0-x*(KM_Q1-x*(KM_Q2-x*KM_Q3)));\r\n\tif (x < 0.0f)\r\n\t\treturn(KM_P0+x*x*(KM_P2-x*KM_P3));\r\n\tif (x < 1.0f)\r\n\t\treturn(KM_P0+x*x*(KM_P2+x*KM_P3));\r\n\tif (x < 2.0f)\r\n\t\treturn(KM_Q0+x*(KM_Q1+x*(KM_Q2+x*KM_Q3)));\r\n\treturn(0.0f);\r\n}", ".ilter_power": "static double filter_power(const double x)\r\n{\r\n\tconst double a = 2.0f;\r\n\tif (fabs(x)>1) return 0.0f;\r\n\treturn (1.0f - (double)fabs(pow(x,a)));\r\n}", ".ilter_quadratic": "static double filter_quadratic(const double x1)\r\n{\r\n\tconst double x = x1 < 0.0 ? -x1 : x1;\r\n\r\n\tif (x <= 0.5) return (- 2.0 * x * x + 1);\r\n\tif (x <= 1.5) return (x * x - 2.5* x + 1.5);\r\n\treturn 0.0;\r\n}", ".ilter_sinc": "static double filter_sinc(const double x)\r\n{\r\n\t/* X-scaled Sinc(x) function. */\r\n\tif (x == 0.0) return(1.0);\r\n\treturn (sin(M_PI * (double) x) / (M_PI * (double) x));\r\n}", ".ilter_triangle": "static double filter_triangle(const double x1)\r\n{\r\n\tconst double x = x1 < 0.0 ? -x1 : x1;\r\n\tif (x < 1.0) return (1.0 - x);\r\n\treturn 0.0;\r\n}"}, "callee": {".ernelBessel_Order1": "static double KernelBessel_Order1(double x)\r\n{\r\n\tdouble p, q;\r\n\r\n\tif (x == 0.0)\r\n\t\treturn (0.0f);\r\n\tp = x;\r\n\tif (x < 0.0)\r\n\t\tx=(-x);\r\n\tif (x < 8.0)\r\n\t\treturn (p*KernelBessel_J1(x));\r\n\tq = (double)sqrt(2.0f/(M_PI*x))*(double)(KernelBessel_P1(x)*(1.0f/sqrt(2.0f)*(sin(x)-cos(x)))-8.0f/x*KernelBessel_Q1(x)*\r\n\t\t(-1.0f/sqrt(2.0f)*(sin(x)+cos(x))));\r\n\tif (p < 0.0f)\r\n\t\tq = (-q);\r\n\treturn (q);\r\n}", ".ilter_bessel": "static double filter_bessel(const double x)\r\n{\r\n\tif (x == 0.0f)\r\n\t\treturn (double)(M_PI/4.0f);\r\n\treturn (KernelBessel_Order1((double)M_PI*x)/(2.0f*x));\r\n}", ".dImageSetInterpolationMethod": "int gdImageSetInterpolationMethod(gdImagePtr im, gdInterpolationMethod id)\r\n{\r\n\tif (im == NULL || id < 0 || id > GD_METHOD_COUNT) {\r\n\t\treturn 0;\r\n\t}\r\n\r\n\tswitch (id) {\r\n\t\tcase GD_NEAREST_NEIGHBOUR:\r\n\t\tcase GD_WEIGHTED4:\r\n\t\t\tim->interpolation = NULL;\r\n\t\t\tbreak;\r\n\r\n\t\t/* generic versions*/\r\n\t\t/* GD_BILINEAR_FIXED and GD_BICUBIC_FIXED are kept for BC reasons */\r\n\t\tcase GD_BILINEAR_FIXED:\r\n\t\tcase GD_LINEAR:\r\n\t\t\tim->interpolation = filter_linear;\r\n\t\t\tbreak;\r\n\t\tcase GD_BELL:\r\n\t\t\tim->interpolation = filter_bell;\r\n\t\t\tbreak;\r\n\t\tcase GD_BESSEL:\r\n\t\t\tim->interpolation = filter_bessel;\r\n\t\t\tbreak;\r\n\t\tcase GD_BICUBIC_FIXED:\r\n\t\tcase GD_BICUBIC:\r\n\t\t\tim->interpolation = filter_bicubic;\r\n\t\t\tbreak;\r\n\t\tcase GD_BLACKMAN:\r\n\t\t\tim->interpolation = filter_blackman;\r\n\t\t\tbreak;\r\n\t\tcase GD_BOX:\r\n\t\t\tim->interpolation = filter_box;\r\n\t\t\tbreak;\r\n\t\tcase GD_BSPLINE:\r\n\t\t\tim->interpolation = filter_bspline;\r\n\t\t\tbreak;\r\n\t\tcase GD_CATMULLROM:\r\n\t\t\tim->interpolation = filter_catmullrom;\r\n\t\t\tbreak;\r\n\t\tcase GD_GAUSSIAN:\r\n\t\t\tim->interpolation = filter_gaussian;\r\n\t\t\tbreak;\r\n\t\tcase GD_GENERALIZED_CUBIC:\r\n\t\t\tim->interpolation = filter_generalized_cubic;\r\n\t\t\tbreak;\r\n\t\tcase GD_HERMITE:\r\n\t\t\tim->interpolation = filter_hermite;\r\n\t\t\tbreak;\r\n\t\tcase GD_HAMMING:\r\n\t\t\tim->interpolation = filter_hamming;\r\n\t\t\tbreak;\r\n\t\tcase GD_HANNING:\r\n\t\t\tim->interpolation = filter_hanning;\r\n\t\t\tbreak;\r\n\t\tcase GD_MITCHELL:\r\n\t\t\tim->interpolation = filter_mitchell;\r\n\t\t\tbreak;\r\n\t\tcase GD_POWER:\r\n\t\t\tim->interpolation = filter_power;\r\n\t\t\tbreak;\r\n\t\tcase GD_QUADRATIC:\r\n\t\t\tim->interpolation = filter_quadratic;\r\n\t\t\tbreak;\r\n\t\tcase GD_SINC:\r\n\t\t\tim->interpolation = filter_sinc;\r\n\t\t\tbreak;\r\n\t\tcase GD_TRIANGLE:\r\n\t\t\tim->interpolation = filter_triangle;\r\n\t\t\tbreak;\r\n\t\tcase GD_DEFAULT:\r\n\t\t\tid = GD_LINEAR;\r\n\t\t\tim->interpolation = filter_linear;\r\n\t\t\tbreak;\r\n\r\n\t\tdefault:\r\n\t\t\treturn 0;\r\n\t}\r\n\tim->interpolation_id = id;\r\n\treturn 1;\r\n}", ".etPixelInterpolateWeight": "static int getPixelInterpolateWeight(gdImagePtr im, const double x, const double y, const int bgColor)\r\n{\r\n\t/* Closest pixel <= (xf,yf) */\r\n\tint sx = (int)(x);\r\n\tint sy = (int)(y);\r\n\tconst double xf = x - (double)sx;\r\n\tconst double yf = y - (double)sy;\r\n\tconst double nxf = (double) 1.0 - xf;\r\n\tconst double nyf = (double) 1.0 - yf;\r\n\tconst double m1 = xf * yf;\r\n\tconst double m2 = nxf * yf;\r\n\tconst double m3 = xf * nyf;\r\n\tconst double m4 = nxf * nyf;\r\n\r\n\t/* get color values of neighbouring pixels */\r\n\tconst int c1 = im->trueColor == 1 ? getPixelOverflowTC(im, sx, sy, bgColor)         : getPixelOverflowPalette(im, sx, sy, bgColor);\r\n\tconst int c2 = im->trueColor == 1 ? getPixelOverflowTC(im, sx - 1, sy, bgColor)     : getPixelOverflowPalette(im, sx - 1, sy, bgColor);\r\n\tconst int c3 = im->trueColor == 1 ? getPixelOverflowTC(im, sx, sy - 1, bgColor)     : getPixelOverflowPalette(im, sx, sy - 1, bgColor);\r\n\tconst int c4 = im->trueColor == 1 ? getPixelOverflowTC(im, sx - 1, sy - 1, bgColor) : getPixelOverflowPalette(im, sx, sy - 1, bgColor);\r\n\tint r, g, b, a;\r\n\r\n\tif (x < 0) sx--;\r\n\tif (y < 0) sy--;\r\n\r\n\t/* component-wise summing-up of color values */\r\n\tif (im->trueColor) {\r\n\t\tr = (int)(m1*gdTrueColorGetRed(c1)   + m2*gdTrueColorGetRed(c2)   + m3*gdTrueColorGetRed(c3)   + m4*gdTrueColorGetRed(c4));\r\n\t\tg = (int)(m1*gdTrueColorGetGreen(c1) + m2*gdTrueColorGetGreen(c2) + m3*gdTrueColorGetGreen(c3) + m4*gdTrueColorGetGreen(c4));\r\n\t\tb = (int)(m1*gdTrueColorGetBlue(c1)  + m2*gdTrueColorGetBlue(c2)  + m3*gdTrueColorGetBlue(c3)  + m4*gdTrueColorGetBlue(c4));\r\n\t\ta = (int)(m1*gdTrueColorGetAlpha(c1) + m2*gdTrueColorGetAlpha(c2) + m3*gdTrueColorGetAlpha(c3) + m4*gdTrueColorGetAlpha(c4));\r\n\t} else {\r\n\t\tr = (int)(m1*im->red[(c1)]   + m2*im->red[(c2)]   + m3*im->red[(c3)]   + m4*im->red[(c4)]);\r\n\t\tg = (int)(m1*im->green[(c1)] + m2*im->green[(c2)] + m3*im->green[(c3)] + m4*im->green[(c4)]);\r\n\t\tb = (int)(m1*im->blue[(c1)]  + m2*im->blue[(c2)]  + m3*im->blue[(c3)]  + m4*im->blue[(c4)]);\r\n\t\ta = (int)(m1*im->alpha[(c1)] + m2*im->alpha[(c2)] + m3*im->alpha[(c3)] + m4*im->alpha[(c4)]);\r\n\t}\r\n\r\n\tr = CLAMP(r, 0, 255);\r\n\tg = CLAMP(g, 0, 255);\r\n\tb = CLAMP(b, 0, 255);\r\n\ta = CLAMP(a, 0, gdAlphaMax);\r\n\treturn gdTrueColorAlpha(r, g, b, a);\r\n}", ".etPixelInterpolated": "int getPixelInterpolated(gdImagePtr im, const double x, const double y, const int bgColor)\r\n{\r\n\tconst int xi=(int)(x);\r\n\tconst int yi=(int)(y);\r\n\tint yii;\r\n\tint i;\r\n\tdouble kernel, kernel_cache_y;\r\n\tdouble kernel_x[12], kernel_y[4];\r\n\tdouble new_r = 0.0f, new_g = 0.0f, new_b = 0.0f, new_a = 0.0f;\r\n\r\n\t/* These methods use special implementations */\r\n\tif (im->interpolation_id == GD_NEAREST_NEIGHBOUR) {\r\n\t\treturn -1;\r\n\t}\r\n\r\n\tif (im->interpolation_id == GD_WEIGHTED4) {\r\n\t\treturn getPixelInterpolateWeight(im, x, y, bgColor);\r\n\t}\r\n\r\n\tif (im->interpolation_id == GD_NEAREST_NEIGHBOUR) {\r\n\t\tif (im->trueColor == 1) {\r\n\t\t\treturn getPixelOverflowTC(im, xi, yi, bgColor);\r\n\t\t} else {\r\n\t\t\treturn getPixelOverflowPalette(im, xi, yi, bgColor);\r\n\t\t}\r\n\t}\r\n\tif (im->interpolation) {\r\n\t\tfor (i=0; i<4; i++) {\r\n\t\t\tkernel_x[i] = (double) im->interpolation((double)(xi+i-1-x));\r\n\t\t\tkernel_y[i] = (double) im->interpolation((double)(yi+i-1-y));\r\n\t\t}\r\n\t} else {\r\n\t\treturn -1;\r\n\t}\r\n\r\n\t/*\r\n\t * TODO: use the known fast rgba multiplication implementation once\r\n\t * the new formats are in place\r\n\t */\r\n\tfor (yii = yi-1; yii < yi+3; yii++) {\r\n\t\tint xii;\r\n\t\tkernel_cache_y = kernel_y[yii-(yi-1)];\r\n\t\tif (im->trueColor) {\r\n\t\t\tfor (xii=xi-1; xii<xi+3; xii++) {\r\n\t\t\t\tconst int rgbs = getPixelOverflowTC(im, xii, yii, bgColor);\r\n\r\n\t\t\t\tkernel = kernel_cache_y * kernel_x[xii-(xi-1)];\r\n\t\t\t\tnew_r += kernel * gdTrueColorGetRed(rgbs);\r\n\t\t\t\tnew_g += kernel * gdTrueColorGetGreen(rgbs);\r\n\t\t\t\tnew_b += kernel * gdTrueColorGetBlue(rgbs);\r\n\t\t\t\tnew_a += kernel * gdTrueColorGetAlpha(rgbs);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tfor (xii=xi-1; xii<xi+3; xii++) {\r\n\t\t\t\tconst int rgbs = getPixelOverflowPalette(im, xii, yii, bgColor);\r\n\r\n\t\t\t\tkernel = kernel_cache_y * kernel_x[xii-(xi-1)];\r\n\t\t\t\tnew_r += kernel * gdTrueColorGetRed(rgbs);\r\n\t\t\t\tnew_g += kernel * gdTrueColorGetGreen(rgbs);\r\n\t\t\t\tnew_b += kernel * gdTrueColorGetBlue(rgbs);\r\n\t\t\t\tnew_a += kernel * gdTrueColorGetAlpha(rgbs);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tnew_r = CLAMP(new_r, 0, 255);\r\n\tnew_g = CLAMP(new_g, 0, 255);\r\n\tnew_b = CLAMP(new_b, 0, 255);\r\n\tnew_a = CLAMP(new_a, 0, gdAlphaMax);\r\n\r\n\treturn gdTrueColorAlpha(((int)new_r), ((int)new_g), ((int)new_b), ((int)new_a));\r\n}", ".dImageScaleBilinearTC": "static gdImagePtr gdImageScaleBilinearTC(gdImagePtr im, const unsigned int new_width, const unsigned int new_height)\r\n{\r\n\tlong dst_w = MAX(1, new_width);\r\n\tlong dst_h = MAX(1, new_height);\r\n\tfloat dx = (float)gdImageSX(im) / (float)dst_w;\r\n\tfloat dy = (float)gdImageSY(im) / (float)dst_h;\r\n\tgdFixed f_dx = gd_ftofx(dx);\r\n\tgdFixed f_dy = gd_ftofx(dy);\r\n\tgdFixed f_1 = gd_itofx(1);\r\n\r\n\tint dst_offset_h;\r\n\tint dst_offset_v = 0;\r\n\tlong i;\r\n\tgdImagePtr new_img;\r\n\r\n\tnew_img = gdImageCreateTrueColor(new_width, new_height);\r\n\tif (!new_img){\r\n\t\treturn NULL;\r\n\t}\r\n\r\n\tfor (i=0; i < dst_h; i++) {\r\n\t\tlong j;\r\n\t\tdst_offset_h = 0;\r\n\t\tfor (j=0; j < dst_w; j++) {\r\n\t\t\t/* Update bitmap */\r\n\t\t\tgdFixed f_i = gd_itofx(i);\r\n\t\t\tgdFixed f_j = gd_itofx(j);\r\n\t\t\tgdFixed f_a = gd_mulfx(f_i, f_dy);\r\n\t\t\tgdFixed f_b = gd_mulfx(f_j, f_dx);\r\n\t\t\tconst long m = gd_fxtoi(f_a);\r\n\t\t\tconst long n = gd_fxtoi(f_b);\r\n\t\t\tgdFixed f_f = f_a - gd_itofx(m);\r\n\t\t\tgdFixed f_g = f_b - gd_itofx(n);\r\n\r\n\t\t\tconst gdFixed f_w1 = gd_mulfx(f_1-f_f, f_1-f_g);\r\n\t\t\tconst gdFixed f_w2 = gd_mulfx(f_1-f_f, f_g);\r\n\t\t\tconst gdFixed f_w3 = gd_mulfx(f_f, f_1-f_g);\r\n\t\t\tconst gdFixed f_w4 = gd_mulfx(f_f, f_g);\r\n\t\t\tunsigned int pixel1;\r\n\t\t\tunsigned int pixel2;\r\n\t\t\tunsigned int pixel3;\r\n\t\t\tunsigned int pixel4;\r\n\t\t\tregister gdFixed f_r1, f_r2, f_r3, f_r4,\r\n\t\t\t\t\tf_g1, f_g2, f_g3, f_g4,\r\n\t\t\t\t\tf_b1, f_b2, f_b3, f_b4,\r\n\t\t\t\t\tf_a1, f_a2, f_a3, f_a4;\r\n\t\t\t/* 0 for bgColor; (n,m) is supposed to be valid anyway */\r\n\t\t\tpixel1 = getPixelOverflowTC(im, n, m, 0);\r\n\t\t\tpixel2 = getPixelOverflowTC(im, n + 1, m, pixel1);\r\n\t\t\tpixel3 = getPixelOverflowTC(im, n, m + 1, pixel1);\r\n\t\t\tpixel4 = getPixelOverflowTC(im, n + 1, m + 1, pixel1);\r\n\r\n\t\t\tf_r1 = gd_itofx(gdTrueColorGetRed(pixel1));\r\n\t\t\tf_r2 = gd_itofx(gdTrueColorGetRed(pixel2));\r\n\t\t\tf_r3 = gd_itofx(gdTrueColorGetRed(pixel3));\r\n\t\t\tf_r4 = gd_itofx(gdTrueColorGetRed(pixel4));\r\n\t\t\tf_g1 = gd_itofx(gdTrueColorGetGreen(pixel1));\r\n\t\t\tf_g2 = gd_itofx(gdTrueColorGetGreen(pixel2));\r\n\t\t\tf_g3 = gd_itofx(gdTrueColorGetGreen(pixel3));\r\n\t\t\tf_g4 = gd_itofx(gdTrueColorGetGreen(pixel4));\r\n\t\t\tf_b1 = gd_itofx(gdTrueColorGetBlue(pixel1));\r\n\t\t\tf_b2 = gd_itofx(gdTrueColorGetBlue(pixel2));\r\n\t\t\tf_b3 = gd_itofx(gdTrueColorGetBlue(pixel3));\r\n\t\t\tf_b4 = gd_itofx(gdTrueColorGetBlue(pixel4));\r\n\t\t\tf_a1 = gd_itofx(gdTrueColorGetAlpha(pixel1));\r\n\t\t\tf_a2 = gd_itofx(gdTrueColorGetAlpha(pixel2));\r\n\t\t\tf_a3 = gd_itofx(gdTrueColorGetAlpha(pixel3));\r\n\t\t\tf_a4 = gd_itofx(gdTrueColorGetAlpha(pixel4));\r\n\t\t\t{\r\n\t\t\t\tconst unsigned char red   = (unsigned char) gd_fxtoi(gd_mulfx(f_w1, f_r1) + gd_mulfx(f_w2, f_r2) + gd_mulfx(f_w3, f_r3) + gd_mulfx(f_w4, f_r4));\r\n\t\t\t\tconst unsigned char green = (unsigned char) gd_fxtoi(gd_mulfx(f_w1, f_g1) + gd_mulfx(f_w2, f_g2) + gd_mulfx(f_w3, f_g3) + gd_mulfx(f_w4, f_g4));\r\n\t\t\t\tconst unsigned char blue  = (unsigned char) gd_fxtoi(gd_mulfx(f_w1, f_b1) + gd_mulfx(f_w2, f_b2) + gd_mulfx(f_w3, f_b3) + gd_mulfx(f_w4, f_b4));\r\n\t\t\t\tconst unsigned char alpha = (unsigned char) gd_fxtoi(gd_mulfx(f_w1, f_a1) + gd_mulfx(f_w2, f_a2) + gd_mulfx(f_w3, f_a3) + gd_mulfx(f_w4, f_a4));\r\n\r\n\t\t\t\tnew_img->tpixels[dst_offset_v][dst_offset_h] = gdTrueColorAlpha(red, green, blue, alpha);\r\n\t\t\t}\r\n\r\n\t\t\tdst_offset_h++;\r\n\t\t}\r\n\r\n\t\tdst_offset_v++;\r\n\t}\r\n\treturn new_img;\r\n}", ".dImageScaleBilinearPalette": "static gdImagePtr gdImageScaleBilinearPalette(gdImagePtr im, const unsigned int new_width, const unsigned int new_height)\r\n{\r\n\tlong _width = MAX(1, new_width);\r\n\tlong _height = MAX(1, new_height);\r\n\tfloat dx = (float)gdImageSX(im) / (float)_width;\r\n\tfloat dy = (float)gdImageSY(im) / (float)_height;\r\n\tgdFixed f_dx = gd_ftofx(dx);\r\n\tgdFixed f_dy = gd_ftofx(dy);\r\n\tgdFixed f_1 = gd_itofx(1);\r\n\r\n\tint dst_offset_h;\r\n\tint dst_offset_v = 0;\r\n\tlong i;\r\n\tgdImagePtr new_img;\r\n\tconst int transparent = im->transparent;\r\n\r\n\tnew_img = gdImageCreateTrueColor(new_width, new_height);\r\n\tif (new_img == NULL) {\r\n\t\treturn NULL;\r\n\t}\r\n\r\n\tif (transparent < 0) {\r\n\t\t/* uninitialized */\r\n\t\tnew_img->transparent = -1;\r\n\t} else {\r\n\t\tnew_img->transparent = gdTrueColorAlpha(im->red[transparent], im->green[transparent], im->blue[transparent], im->alpha[transparent]);\r\n\t}\r\n\r\n\tfor (i=0; i < _height; i++) {\r\n\t\tlong j;\r\n\t\tconst gdFixed f_i = gd_itofx(i);\r\n\t\tconst gdFixed f_a = gd_mulfx(f_i, f_dy);\r\n\t\tregister long m = gd_fxtoi(f_a);\r\n\r\n\t\tdst_offset_h = 0;\r\n\r\n\t\tfor (j=0; j < _width; j++) {\r\n\t\t\t/* Update bitmap */\r\n\t\t\tgdFixed f_j = gd_itofx(j);\r\n\t\t\tgdFixed f_b = gd_mulfx(f_j, f_dx);\r\n\r\n\t\t\tconst long n = gd_fxtoi(f_b);\r\n\t\t\tgdFixed f_f = f_a - gd_itofx(m);\r\n\t\t\tgdFixed f_g = f_b - gd_itofx(n);\r\n\r\n\t\t\tconst gdFixed f_w1 = gd_mulfx(f_1-f_f, f_1-f_g);\r\n\t\t\tconst gdFixed f_w2 = gd_mulfx(f_1-f_f, f_g);\r\n\t\t\tconst gdFixed f_w3 = gd_mulfx(f_f, f_1-f_g);\r\n\t\t\tconst gdFixed f_w4 = gd_mulfx(f_f, f_g);\r\n\t\t\tunsigned int pixel1;\r\n\t\t\tunsigned int pixel2;\r\n\t\t\tunsigned int pixel3;\r\n\t\t\tunsigned int pixel4;\r\n\t\t\tregister gdFixed f_r1, f_r2, f_r3, f_r4,\r\n\t\t\t\t\tf_g1, f_g2, f_g3, f_g4,\r\n\t\t\t\t\tf_b1, f_b2, f_b3, f_b4,\r\n\t\t\t\t\tf_a1, f_a2, f_a3, f_a4;\r\n\r\n\t\t\t/* 0 for bgColor; (n,m) is supposed to be valid anyway */\r\n\t\t\tpixel1 = getPixelOverflowPalette(im, n, m, 0);\r\n\t\t\tpixel2 = getPixelOverflowPalette(im, n + 1, m, pixel1);\r\n\t\t\tpixel3 = getPixelOverflowPalette(im, n, m + 1, pixel1);\r\n\t\t\tpixel4 = getPixelOverflowPalette(im, n + 1, m + 1, pixel1);\r\n\r\n\t\t\tf_r1 = gd_itofx(gdTrueColorGetRed(pixel1));\r\n\t\t\tf_r2 = gd_itofx(gdTrueColorGetRed(pixel2));\r\n\t\t\tf_r3 = gd_itofx(gdTrueColorGetRed(pixel3));\r\n\t\t\tf_r4 = gd_itofx(gdTrueColorGetRed(pixel4));\r\n\t\t\tf_g1 = gd_itofx(gdTrueColorGetGreen(pixel1));\r\n\t\t\tf_g2 = gd_itofx(gdTrueColorGetGreen(pixel2));\r\n\t\t\tf_g3 = gd_itofx(gdTrueColorGetGreen(pixel3));\r\n\t\t\tf_g4 = gd_itofx(gdTrueColorGetGreen(pixel4));\r\n\t\t\tf_b1 = gd_itofx(gdTrueColorGetBlue(pixel1));\r\n\t\t\tf_b2 = gd_itofx(gdTrueColorGetBlue(pixel2));\r\n\t\t\tf_b3 = gd_itofx(gdTrueColorGetBlue(pixel3));\r\n\t\t\tf_b4 = gd_itofx(gdTrueColorGetBlue(pixel4));\r\n\t\t\tf_a1 = gd_itofx(gdTrueColorGetAlpha(pixel1));\r\n\t\t\tf_a2 = gd_itofx(gdTrueColorGetAlpha(pixel2));\r\n\t\t\tf_a3 = gd_itofx(gdTrueColorGetAlpha(pixel3));\r\n\t\t\tf_a4 = gd_itofx(gdTrueColorGetAlpha(pixel4));\r\n\r\n\t\t\t{\r\n\t\t\t\tconst unsigned char red = (unsigned char) gd_fxtoi(gd_mulfx(f_w1, f_r1) + gd_mulfx(f_w2, f_r2) + gd_mulfx(f_w3, f_r3) + gd_mulfx(f_w4, f_r4));\r\n\t\t\t\tconst unsigned char green = (unsigned char) gd_fxtoi(gd_mulfx(f_w1, f_g1) + gd_mulfx(f_w2, f_g2) + gd_mulfx(f_w3, f_g3) + gd_mulfx(f_w4, f_g4));\r\n\t\t\t\tconst unsigned char blue = (unsigned char) gd_fxtoi(gd_mulfx(f_w1, f_b1) + gd_mulfx(f_w2, f_b2) + gd_mulfx(f_w3, f_b3) + gd_mulfx(f_w4, f_b4));\r\n\t\t\t\tconst unsigned char alpha = (unsigned char) gd_fxtoi(gd_mulfx(f_w1, f_a1) + gd_mulfx(f_w2, f_a2) + gd_mulfx(f_w3, f_a3) + gd_mulfx(f_w4, f_a4));\r\n\r\n\t\t\t\tnew_img->tpixels[dst_offset_v][dst_offset_h] = gdTrueColorAlpha(red, green, blue, alpha);\r\n\t\t\t}\r\n\r\n\t\t\tdst_offset_h++;\r\n\t\t}\r\n\r\n\t\tdst_offset_v++;\r\n\t}\r\n\treturn new_img;\r\n}", ".dImageRotateGeneric": "static gdImagePtr\r\ngdImageRotateGeneric(gdImagePtr src, const float degrees, const int bgColor)\r\n{\r\n\tfloat _angle = ((float) (-degrees / 180.0f) * (float)M_PI);\r\n\tconst int src_w  = gdImageSX(src);\r\n\tconst int src_h = gdImageSY(src);\r\n\tconst gdFixed f_0_5 = gd_ftofx(0.5f);\r\n\tconst gdFixed f_H = gd_itofx(src_h/2);\r\n\tconst gdFixed f_W = gd_itofx(src_w/2);\r\n\tconst gdFixed f_cos = gd_ftofx(cos(-_angle));\r\n\tconst gdFixed f_sin = gd_ftofx(sin(-_angle));\r\n\r\n\tunsigned int dst_offset_x;\r\n\tunsigned int dst_offset_y = 0;\r\n\tunsigned int i;\r\n\tgdImagePtr dst;\r\n\tint new_width, new_height;\r\n\tgdRect bbox;\r\n\r\n\tif (bgColor < 0) {\r\n\t\treturn NULL;\r\n\t}\r\n\r\n\tif (src->interpolation == NULL) {\r\n\t\tgdImageSetInterpolationMethod(src, GD_DEFAULT);\r\n\t}\r\n\r\n    gdRotatedImageSize(src, degrees, &bbox);\r\n    new_width = bbox.width;\r\n    new_height = bbox.height;\r\n\r\n\tdst = gdImageCreateTrueColor(new_width, new_height);\r\n\tif (!dst) {\r\n\t\treturn NULL;\r\n\t}\r\n\tdst->saveAlphaFlag = 1;\r\n\r\n\tfor (i = 0; i < new_height; i++) {\r\n\t\tunsigned int j;\r\n\t\tdst_offset_x = 0;\r\n\t\tfor (j = 0; j < new_width; j++) {\r\n\t\t\tgdFixed f_i = gd_itofx((int)i - (int)new_height/ 2);\r\n\t\t\tgdFixed f_j = gd_itofx((int)j - (int)new_width / 2);\r\n\t\t\tgdFixed f_m = gd_mulfx(f_j,f_sin) + gd_mulfx(f_i,f_cos) + f_0_5 + f_H;\r\n\t\t\tgdFixed f_n = gd_mulfx(f_j,f_cos) - gd_mulfx(f_i,f_sin) + f_0_5 + f_W;\r\n\t\t\tlong m = gd_fxtoi(f_m);\r\n\t\t\tlong n = gd_fxtoi(f_n);\r\n\r\n\t\t\tif (m < -1 || n < -1 || m >= src_h || n >= src_w ) {\r\n\t\t\t\tdst->tpixels[dst_offset_y][dst_offset_x++] = bgColor;\r\n\t\t\t} else {\r\n\t\t\t\tdst->tpixels[dst_offset_y][dst_offset_x++] = getPixelInterpolated(src, gd_fxtod(f_n), gd_fxtod(f_m), bgColor);\r\n\t\t\t}\r\n\t\t}\r\n\t\tdst_offset_y++;\r\n\t}\r\n\treturn dst;\r\n}", ".dTransformAffineCopy": "int gdTransformAffineCopy(gdImagePtr dst,\r\n\t\t  int dst_x, int dst_y,\r\n\t\t  const gdImagePtr src,\r\n\t\t  gdRectPtr src_region,\r\n\t\t  const double affine[6])\r\n{\r\n\tint c1x,c1y,c2x,c2y;\r\n\tint backclip = 0;\r\n\tint backup_clipx1, backup_clipy1, backup_clipx2, backup_clipy2;\r\n\tregister int x, y, src_offset_x, src_offset_y;\r\n\tdouble inv[6];\r\n\tgdPointF pt, src_pt;\r\n\tgdRect bbox;\r\n\tint end_x, end_y;\r\n\tgdInterpolationMethod interpolation_id_bak = src->interpolation_id;\r\n\r\n\t/* These methods use special implementations */\r\n\tif (src->interpolation_id == GD_BILINEAR_FIXED || src->interpolation_id == GD_BICUBIC_FIXED || src->interpolation_id == GD_NEAREST_NEIGHBOUR) {\r\n\t\tinterpolation_id_bak = src->interpolation_id;\r\n\r\n\t\tgdImageSetInterpolationMethod(src, GD_BICUBIC);\r\n\t}\r\n\r\n\r\n\tgdImageClipRectangle(src, src_region);\r\n\r\n\tif (src_region->x > 0 || src_region->y > 0\r\n\t\t|| src_region->width < gdImageSX(src)\r\n\t\t|| src_region->height < gdImageSY(src)) {\r\n\t\tbackclip = 1;\r\n\r\n\t\tgdImageGetClip(src, &backup_clipx1, &backup_clipy1,\r\n\t\t&backup_clipx2, &backup_clipy2);\r\n\r\n\t\tgdImageSetClip(src, src_region->x, src_region->y,\r\n\t\t\tsrc_region->x + src_region->width - 1,\r\n\t\t\tsrc_region->y + src_region->height - 1);\r\n\t}\r\n\r\n\tif (!gdTransformAffineBoundingBox(src_region, affine, &bbox)) {\r\n\t\tif (backclip) {\r\n\t\t\tgdImageSetClip(src, backup_clipx1, backup_clipy1,\r\n\t\t\t\t\tbackup_clipx2, backup_clipy2);\r\n\t\t}\r\n\t\tgdImageSetInterpolationMethod(src, interpolation_id_bak);\r\n\t\treturn GD_FALSE;\r\n\t}\r\n\r\n\tgdImageGetClip(dst, &c1x, &c1y, &c2x, &c2y);\r\n\r\n\tend_x = bbox.width  + abs(bbox.x);\r\n\tend_y = bbox.height + abs(bbox.y);\r\n\r\n\t/* Get inverse affine to let us work with destination -> source */\r\n\tif (gdAffineInvert(inv, affine) == GD_FALSE) {\r\n\t\tgdImageSetInterpolationMethod(src, interpolation_id_bak);\r\n\t\treturn GD_FALSE;\r\n\t}\r\n\r\n\tsrc_offset_x =  src_region->x;\r\n\tsrc_offset_y =  src_region->y;\r\n\r\n\tif (dst->alphaBlendingFlag) {\r\n\t\tfor (y = bbox.y; y <= end_y; y++) {\r\n\t\t\tpt.y = y + 0.5;\r\n\t\t\tfor (x = 0; x <= end_x; x++) {\r\n\t\t\t\tpt.x = x + 0.5;\r\n\t\t\t\tgdAffineApplyToPointF(&src_pt, &pt, inv);\r\n\t\t\t\tgdImageSetPixel(dst, dst_x + x, dst_y + y, getPixelInterpolated(src, src_offset_x + src_pt.x, src_offset_y + src_pt.y, 0));\r\n\t\t\t}\r\n\t\t}\r\n\t} else {\r\n\t\tfor (y = 0; y <= end_y; y++) {\r\n\t\t\tunsigned char *dst_p = NULL;\r\n\t\t\tint *tdst_p = NULL;\r\n\r\n\t\t\tpt.y = y + 0.5 + bbox.y;\r\n\t\t\tif ((dst_y + y) < 0 || ((dst_y + y) > gdImageSY(dst) -1)) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tif (dst->trueColor) {\r\n\t\t\t\ttdst_p = dst->tpixels[dst_y + y] + dst_x;\r\n\t\t\t} else {\r\n\t\t\t\tdst_p = dst->pixels[dst_y + y] + dst_x;\r\n\t\t\t}\r\n\r\n\t\t\tfor (x = 0; x <= end_x; x++) {\r\n\t\t\t\tpt.x = x + 0.5 + bbox.x;\r\n\t\t\t\tgdAffineApplyToPointF(&src_pt, &pt, inv);\r\n\r\n\t\t\t\tif ((dst_x + x) < 0 || (dst_x + x) > (gdImageSX(dst) - 1)) {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tif (dst->trueColor) {\r\n\t\t\t\t\t*(tdst_p++) = getPixelInterpolated(src, src_offset_x + src_pt.x, src_offset_y + src_pt.y, -1);\r\n\t\t\t\t} else {\r\n\t\t\t\t\t*(dst_p++) = getPixelInterpolated(src, src_offset_x + src_pt.x, src_offset_y + src_pt.y, -1);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/* Restore clip if required */\r\n\tif (backclip) {\r\n\t\tgdImageSetClip(src, backup_clipx1, backup_clipy1,\r\n\t\t\t\tbackup_clipx2, backup_clipy2);\r\n\t}\r\n\r\n\tgdImageSetInterpolationMethod(src, interpolation_id_bak);\r\n\treturn GD_TRUE;\r\n}", ".dImageScale": "gdImagePtr gdImageScale(const gdImagePtr src, const unsigned int new_width, const unsigned int new_height)\r\n{\r\n\tgdImagePtr im_scaled = NULL;\r\n\r\n\tif (src == NULL || src->interpolation_id < 0 || src->interpolation_id > GD_METHOD_COUNT) {\r\n\t\treturn NULL;\r\n\t}\r\n\r\n\tif (new_width == 0 || new_height == 0) {\r\n\t\treturn NULL;\r\n\t}\r\n\r\n\tif (new_width == gdImageSX(src) && new_height == gdImageSY(src)) {\r\n\t\treturn gdImageClone(src);\r\n\t}\r\n\tswitch (src->interpolation_id) {\r\n\t\t/*Special cases, optimized implementations */\r\n\t\tcase GD_NEAREST_NEIGHBOUR:\r\n\t\t\tim_scaled = gdImageScaleNearestNeighbour(src, new_width, new_height);\r\n\t\t\tbreak;\r\n\r\n\t\tcase GD_BILINEAR_FIXED:\r\n\t\tcase GD_LINEAR:\r\n\t\t\tim_scaled = gdImageScaleBilinear(src, new_width, new_height);\r\n\t\t\tbreak;\r\n\r\n\t\tcase GD_BICUBIC_FIXED:\r\n\t\tcase GD_BICUBIC:\r\n\t\t\tim_scaled = gdImageScaleBicubicFixed(src, new_width, new_height);\r\n\t\t\tbreak;\r\n\r\n\t\t/* generic */\r\n\t\tdefault:\r\n\t\t\tif (src->interpolation == NULL) {\r\n\t\t\t\treturn NULL;\r\n\t\t\t}\r\n\t\t\tim_scaled = gdImageScaleTwoPass(src, src->sx, src->sy, new_width, new_height);\r\n\t\t\tbreak;\r\n\t}\r\n\treturn im_scaled;\r\n}", ".dImageScaleBilinear": "static gdImagePtr\r\ngdImageScaleBilinear(gdImagePtr im, const unsigned int new_width, const unsigned int new_height)\r\n{\r\n\tif (im->trueColor) {\r\n\t\treturn gdImageScaleBilinearTC(im, new_width, new_height);\r\n\t} else {\r\n\t\treturn gdImageScaleBilinearPalette(im, new_width, new_height);\r\n\t}\r\n}", ".dImageRotateNearestNeighbour": "static gdImagePtr\r\ngdImageRotateNearestNeighbour(gdImagePtr src, const float degrees, const int bgColor)\r\n{\r\n\tfloat _angle = ((float) (-degrees / 180.0f) * (float)M_PI);\r\n\tconst int src_w  = gdImageSX(src);\r\n\tconst int src_h = gdImageSY(src);\r\n\tconst gdFixed f_0_5 = gd_ftofx(0.5f);\r\n\tconst gdFixed f_H = gd_itofx(src_h/2);\r\n\tconst gdFixed f_W = gd_itofx(src_w/2);\r\n\tconst gdFixed f_cos = gd_ftofx(cos(-_angle));\r\n\tconst gdFixed f_sin = gd_ftofx(sin(-_angle));\r\n\r\n\tunsigned int dst_offset_x;\r\n\tunsigned int dst_offset_y = 0;\r\n\tunsigned int i;\r\n\tgdImagePtr dst;\r\n\tgdRect bbox;\r\n\tint new_height, new_width;\r\n\r\n    gdRotatedImageSize(src, degrees, &bbox);\r\n    new_width = bbox.width;\r\n    new_height = bbox.height;\r\n\r\n\tdst = gdImageCreateTrueColor(new_width, new_height);\r\n\tif (!dst) {\r\n\t\treturn NULL;\r\n\t}\r\n\tdst->saveAlphaFlag = 1;\r\n\tfor (i = 0; i < new_height; i++) {\r\n\t\tunsigned int j;\r\n\t\tdst_offset_x = 0;\r\n\t\tfor (j = 0; j < new_width; j++) {\r\n\t\t\tgdFixed f_i = gd_itofx((int)i - (int)new_height/2);\r\n\t\t\tgdFixed f_j = gd_itofx((int)j - (int)new_width/2);\r\n\t\t\tgdFixed f_m = gd_mulfx(f_j,f_sin) + gd_mulfx(f_i,f_cos) + f_0_5 + f_H;\r\n\t\t\tgdFixed f_n = gd_mulfx(f_j,f_cos) - gd_mulfx(f_i,f_sin) + f_0_5 + f_W;\r\n\t\t\tlong m = gd_fxtoi(f_m);\r\n\t\t\tlong n = gd_fxtoi(f_n);\r\n\r\n\t\t\tif ((m > 0) && (m < src_h-1) && (n > 0) && (n < src_w-1)) {\r\n\t\t\t\tif (dst_offset_y < new_height) {\r\n\t\t\t\t\tdst->tpixels[dst_offset_y][dst_offset_x++] = src->tpixels[m][n];\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tif (dst_offset_y < new_height) {\r\n\t\t\t\t\tdst->tpixels[dst_offset_y][dst_offset_x++] = bgColor;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tdst_offset_y++;\r\n\t}\r\n\treturn dst;\r\n}", ".dImageRotateInterpolated": "gdImagePtr gdImageRotateInterpolated(const gdImagePtr src, const float angle, int bgcolor)\r\n{\r\n\t/* round to two decimals and keep the 100x multiplication to use it in the common square angles\r\n\t   case later. Keep the two decimal precisions so smaller rotation steps can be done, useful for\r\n\t   slow animations. */\r\n\tconst int angle_rounded = fmod((int) floorf(angle * 100), 360 * 100);\r\n\r\n\tif (bgcolor < 0) {\r\n\t\treturn NULL;\r\n\t}\r\n\r\n\t/* impact perf a bit, but not that much. Implementation for palette\r\n\t   images can be done at a later point.\r\n\t*/\r\n\tif (src->trueColor == 0) {\r\n\t\tif (bgcolor < gdMaxColors) {\r\n\t\t\tbgcolor =  gdTrueColorAlpha(src->red[bgcolor], src->green[bgcolor], src->blue[bgcolor], src->alpha[bgcolor]);\r\n\t\t}\r\n\t\tgdImagePaletteToTrueColor(src);\r\n\t}\r\n\r\n\t/* no interpolation needed here */\r\n\tswitch (angle_rounded) {\r\n\t\tcase    0: {\r\n\t\t\tgdImagePtr dst = gdImageCreateTrueColor(src->sx, src->sy);\r\n\t\t\tif (dst == NULL) {\r\n\t\t\t\treturn NULL;\r\n\t\t\t}\r\n\t\t\tdst->transparent = src->transparent;\r\n\t\t\tdst->saveAlphaFlag = 1;\r\n\t\t\tdst->alphaBlendingFlag = gdEffectReplace;\r\n\r\n\t\t\tgdImageCopy(dst, src, 0,0,0,0,src->sx,src->sy);\r\n\t\t\treturn dst;\r\n\t\t}\r\n\t\tcase -27000:\r\n\t\tcase   9000:\r\n\t\t\treturn gdImageRotate90(src, 0);\r\n\t\tcase -18000:\r\n\t\tcase  18000:\r\n\t\t\treturn gdImageRotate180(src, 0);\r\n\t\tcase -9000:\r\n\t\tcase 27000:\r\n\t\t\treturn gdImageRotate270(src, 0);\r\n\t}\r\n\r\n\tif (src == NULL || src->interpolation_id < 1 || src->interpolation_id > GD_METHOD_COUNT) {\r\n\t\treturn NULL;\r\n\t}\r\n\r\n\tswitch (src->interpolation_id) {\r\n\t\tcase GD_NEAREST_NEIGHBOUR:\r\n\t\t\treturn gdImageRotateNearestNeighbour(src, angle, bgcolor);\r\n\t\t\tbreak;\r\n\r\n\t\tcase GD_BILINEAR_FIXED:\r\n\t\tcase GD_BICUBIC_FIXED:\r\n\t\tdefault:\r\n\t\t\treturn gdImageRotateGeneric(src, angle, bgcolor);\r\n\t}\r\n\treturn NULL;\r\n}", ".dTransformAffineGetImage": "int gdTransformAffineGetImage(gdImagePtr *dst,\r\n\t\t  const gdImagePtr src,\r\n\t\t  gdRectPtr src_area,\r\n\t\t  const double affine[6])\r\n{\r\n\tint res;\r\n\tdouble m[6];\r\n\tgdRect bbox;\r\n\tgdRect area_full;\r\n\r\n\tif (src_area == NULL) {\r\n\t\tarea_full.x = 0;\r\n\t\tarea_full.y = 0;\r\n\t\tarea_full.width  = gdImageSX(src);\r\n\t\tarea_full.height = gdImageSY(src);\r\n\t\tsrc_area = &area_full;\r\n\t}\r\n\r\n\tgdTransformAffineBoundingBox(src_area, affine, &bbox);\r\n\r\n\t*dst = gdImageCreateTrueColor(bbox.width, bbox.height);\r\n\tif (*dst == NULL) {\r\n\t\treturn GD_FALSE;\r\n\t}\r\n\t(*dst)->saveAlphaFlag = 1;\r\n\r\n\tif (!src->trueColor) {\r\n\t\tgdImagePaletteToTrueColor(src);\r\n\t}\r\n\r\n\t/* Translate to dst origin (0,0) */\r\n\tgdAffineTranslate(m, -bbox.x, -bbox.y);\r\n\tgdAffineConcat(m, affine, m);\r\n\r\n\tgdImageAlphaBlending(*dst, 0);\r\n\r\n\tres = gdTransformAffineCopy(*dst,\r\n\t\t  0,0,\r\n\t\t  src,\r\n\t\t  src_area,\r\n\t\t  m);\r\n\r\n\tif (res != GD_TRUE) {\r\n\t\tgdImageDestroy(*dst);\r\n\t\tdst = NULL;\r\n\t\treturn GD_FALSE;\r\n\t} else {\r\n\t\treturn GD_TRUE;\r\n\t}\r\n}", ".dRotatedImageSize": "static int gdRotatedImageSize(gdImagePtr src, const float angle, gdRectPtr bbox)\r\n{\r\n    gdRect src_area;\r\n    double m[6];\r\n\r\n    gdAffineRotate(m, angle);\r\n    src_area.x = 0;\r\n    src_area.y = 0;\r\n    src_area.width = gdImageSX(src);\r\n    src_area.height = gdImageSY(src);\r\n    if (gdTransformAffineBoundingBox(&src_area, m, bbox) != GD_TRUE) {\r\n        return GD_FALSE;\r\n    }\r\n\r\n    return GD_TRUE;\r\n}", ".dImageScaleTwoPass": "static gdImagePtr\r\ngdImageScaleTwoPass(const gdImagePtr src, const unsigned int src_width, const unsigned int src_height, const unsigned int new_width, const unsigned int new_height)\r\n{\r\n\tgdImagePtr tmp_im;\r\n\tgdImagePtr dst;\r\n\tint scale_pass_res;\r\n\r\n\t/* Convert to truecolor if it isn't; this code requires it. */\r\n\tif (!src->trueColor) {\r\n\t\tgdImagePaletteToTrueColor(src);\r\n\t}\r\n\r\n\ttmp_im = gdImageCreateTrueColor(new_width, src_height);\r\n\tif (tmp_im == NULL) {\r\n\t\treturn NULL;\r\n\t}\r\n\tgdImageSetInterpolationMethod(tmp_im, src->interpolation_id);\r\n\tscale_pass_res = _gdScaleHoriz(src, src_width, src_height, tmp_im, new_width, src_height);\r\n\tif (scale_pass_res != 1) {\r\n\t\tgdImageDestroy(tmp_im);\r\n\t\treturn NULL;\r\n\t}\r\n\r\n\tdst = gdImageCreateTrueColor(new_width, new_height);\r\n\tif (dst == NULL) {\r\n\t\tgdImageDestroy(tmp_im);\r\n\t\treturn NULL;\r\n\t}\r\n\tgdImageSetInterpolationMethod(dst, src->interpolation_id);\r\n\tscale_pass_res = _gdScaleVert(tmp_im, new_width, src_height, dst, new_width, new_height);\r\n\tif (scale_pass_res != 1) {\r\n\t\tgdImageDestroy(dst);\r\n\t\tgdImageDestroy(tmp_im);\r\n\t\treturn NULL;\r\n\t}\r\n\tgdImageDestroy(tmp_im);\r\n\r\n\treturn dst;\r\n}"}, "function_name": "gdImageGetInterpolationMethod"}
{"function_id": null, "caller": {".irPDcapGetSa": "static INT\r\nAirPDcapGetSa(\r\n    PAIRPDCAP_CONTEXT ctx,\r\n    AIRPDCAP_SEC_ASSOCIATION_ID *id)\r\n{\r\n    INT sa_index;\r\n    if (ctx->sa_index!=-1) {\r\n        /* at least one association was stored                               */\r\n        /* search for the association from sa_index to 0 (most recent added) */\r\n        for (sa_index=ctx->sa_index; sa_index>=0; sa_index--) {\r\n            if (ctx->sa[sa_index].used) {\r\n                if (memcmp(id, &(ctx->sa[sa_index].saId), sizeof(AIRPDCAP_SEC_ASSOCIATION_ID))==0) {\r\n                    ctx->index=sa_index;\r\n                    return sa_index;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    return -1;\r\n}", ".irPDcapStoreSa": "static INT\r\nAirPDcapStoreSa(\r\n    PAIRPDCAP_CONTEXT ctx,\r\n    AIRPDCAP_SEC_ASSOCIATION_ID *id)\r\n{\r\n    INT last_free;\r\n    if (ctx->first_free_index>=AIRPDCAP_MAX_SEC_ASSOCIATIONS_NR) {\r\n        /* there is no empty space available. FAILURE */\r\n        return -1;\r\n    }\r\n    if (ctx->sa[ctx->first_free_index].used) {\r\n        /* last addition was in the middle of the array (and the first_free_index was just incremented by 1)   */\r\n        /* search for a free space from the first_free_index to AIRPDCAP_STA_INFOS_NR (to avoid free blocks in */\r\n        /*              the middle)                                                                            */\r\n        for (last_free=ctx->first_free_index; last_free<AIRPDCAP_MAX_SEC_ASSOCIATIONS_NR; last_free++)\r\n            if (!ctx->sa[last_free].used)\r\n                break;\r\n\r\n        if (last_free>=AIRPDCAP_MAX_SEC_ASSOCIATIONS_NR) {\r\n            /* there is no empty space available. FAILURE */\r\n            return -1;\r\n        }\r\n\r\n        /* store first free space index */\r\n        ctx->first_free_index=last_free;\r\n    }\r\n\r\n    /* use this info */\r\n    ctx->index=ctx->first_free_index;\r\n\r\n    /* reset the info structure */\r\n    memset(ctx->sa+ctx->index, 0, sizeof(AIRPDCAP_SEC_ASSOCIATION));\r\n\r\n    ctx->sa[ctx->index].used=1;\r\n\r\n    /* set the info structure */\r\n    memcpy(&(ctx->sa[ctx->index].saId), id, sizeof(AIRPDCAP_SEC_ASSOCIATION_ID));\r\n\r\n    /* increment by 1 the first_free_index (heuristic) */\r\n    ctx->first_free_index++;\r\n\r\n    /* set the sa_index if the added index is greater the the sa_index */\r\n    if (ctx->index > ctx->sa_index)\r\n        ctx->sa_index=ctx->index;\r\n\r\n    return ctx->index;\r\n}", ".irPDcapGetSaPtr": "static PAIRPDCAP_SEC_ASSOCIATION\r\nAirPDcapGetSaPtr(\r\n    PAIRPDCAP_CONTEXT ctx,\r\n    AIRPDCAP_SEC_ASSOCIATION_ID *id)\r\n{\r\n    int sa_index;\r\n\r\n    /* search for a cached Security Association for supplied BSSID and STA MAC  */\r\n    if ((sa_index=AirPDcapGetSa(ctx, id))==-1) {\r\n        /* create a new Security Association if it doesn't currently exist      */\r\n        if ((sa_index=AirPDcapStoreSa(ctx, id))==-1) {\r\n            return NULL;\r\n        }\r\n    }\r\n    /* get the Security Association structure   */\r\n    return &ctx->sa[sa_index];\r\n}", ".irPDcapRsna4WHandshake": "static INT\r\nAirPDcapRsna4WHandshake(\r\n    PAIRPDCAP_CONTEXT ctx,\r\n    const UCHAR *data,\r\n    AIRPDCAP_SEC_ASSOCIATION *sa,\r\n    INT offset,\r\n    const guint tot_len)\r\n{\r\n    AIRPDCAP_KEY_ITEM *tmp_key, *tmp_pkt_key, pkt_key;\r\n    AIRPDCAP_SEC_ASSOCIATION *tmp_sa;\r\n    INT key_index;\r\n    INT ret_value=1;\r\n    UCHAR useCache=FALSE;\r\n    UCHAR eapol[AIRPDCAP_EAPOL_MAX_LEN];\r\n    USHORT eapol_len;\r\n\r\n    if (sa->key!=NULL)\r\n        useCache=TRUE;\r\n\r\n    /* a 4-way handshake packet use a Pairwise key type (IEEE 802.11i-2004, pg. 79) */\r\n    if (AIRPDCAP_EAP_KEY(data[offset+1])!=1) {\r\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsna4WHandshake\", \"Group/STAKey message (not used)\", AIRPDCAP_DEBUG_LEVEL_5);\r\n        return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\r\n    }\r\n\r\n    /* TODO timeouts? */\r\n\r\n    /* TODO consider key-index */\r\n\r\n    /* TODO considera Deauthentications */\r\n\r\n    AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsna4WHandshake\", \"4-way handshake...\", AIRPDCAP_DEBUG_LEVEL_5);\r\n\r\n    /* manage 4-way handshake packets; this step completes the 802.1X authentication process (IEEE 802.11i-2004, pag. 85) */\r\n\r\n    /* message 1: Authenticator->Supplicant (Sec=0, Mic=0, Ack=1, Inst=0, Key=1(pairwise), KeyRSC=0, Nonce=ANonce, MIC=0) */\r\n    if (AIRPDCAP_EAP_INST(data[offset+1])==0 &&\r\n        AIRPDCAP_EAP_ACK(data[offset+1])==1 &&\r\n        AIRPDCAP_EAP_MIC(data[offset])==0)\r\n    {\r\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsna4WHandshake\", \"4-way handshake message 1\", AIRPDCAP_DEBUG_LEVEL_3);\r\n\r\n        /* On reception of Message 1, the Supplicant determines whether the Key Replay Counter field value has been        */\r\n        /* used before with the current PMKSA. If the Key Replay Counter field value is less than or equal to the current  */\r\n        /* local value, the Supplicant discards the message.                                                               */\r\n        /* -> not checked, the Authenticator will be send another Message 1 (hopefully!)                                   */\r\n\r\n        /* This saves the sa since we are reauthenticating which will overwrite our current sa GCS*/\r\n        if( sa->handshake >= 2) {\r\n            tmp_sa= g_new(AIRPDCAP_SEC_ASSOCIATION, 1);\r\n            memcpy(tmp_sa, sa, sizeof(AIRPDCAP_SEC_ASSOCIATION));\r\n            sa->validKey=FALSE;\r\n            sa->next=tmp_sa;\r\n        }\r\n\r\n        /* save ANonce (from authenticator) to derive the PTK with the SNonce (from the 2 message) */\r\n        memcpy(sa->wpa.nonce, data+offset+12, 32);\r\n\r\n        /* get the Key Descriptor Version (to select algorithm used in decryption -CCMP or TKIP-) */\r\n        sa->wpa.key_ver=AIRPDCAP_EAP_KEY_DESCR_VER(data[offset+1]);\r\n\r\n        sa->handshake=1;\r\n\r\n        return AIRPDCAP_RET_SUCCESS_HANDSHAKE;\r\n    }\r\n\r\n    /* message 2|4: Supplicant->Authenticator (Sec=0|1, Mic=1, Ack=0, Inst=0, Key=1(pairwise), KeyRSC=0, Nonce=SNonce|0, MIC=MIC(KCK,EAPOL)) */\r\n    if (AIRPDCAP_EAP_INST(data[offset+1])==0 &&\r\n        AIRPDCAP_EAP_ACK(data[offset+1])==0 &&\r\n        AIRPDCAP_EAP_MIC(data[offset])==1)\r\n    {\r\n        /* Check key data length to differentiate between message 2 or 4, same as in epan/dissectors/packet-ieee80211.c */\r\n        if (pntoh16(data+offset+92)) {\r\n            /* message 2 */\r\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsna4WHandshake\", \"4-way handshake message 2\", AIRPDCAP_DEBUG_LEVEL_3);\r\n\r\n            /* On reception of Message 2, the Authenticator checks that the key replay counter corresponds to the */\r\n            /* outstanding Message 1. If not, it silently discards the message.                                   */\r\n            /* If the calculated MIC does not match the MIC that the Supplicant included in the EAPOL-Key frame,  */\r\n            /* the Authenticator silently discards Message 2.                                                     */\r\n            /* -> not checked; the Supplicant will send another message 2 (hopefully!)                            */\r\n\r\n            /* now you can derive the PTK */\r\n            for (key_index=0; key_index<(INT)ctx->keys_nr || useCache; key_index++) {\r\n                /* use the cached one, or try all keys */\r\n                if (!useCache) {\r\n                    AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsna4WHandshake\", \"Try WPA key...\", AIRPDCAP_DEBUG_LEVEL_3);\r\n                    tmp_key=&ctx->keys[key_index];\r\n                } else {\r\n                    /* there is a cached key in the security association, if it's a WPA key try it... */\r\n                    if (sa->key!=NULL &&\r\n                        (sa->key->KeyType==AIRPDCAP_KEY_TYPE_WPA_PWD ||\r\n                         sa->key->KeyType==AIRPDCAP_KEY_TYPE_WPA_PSK ||\r\n                         sa->key->KeyType==AIRPDCAP_KEY_TYPE_WPA_PMK)) {\r\n                            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsna4WHandshake\", \"Try cached WPA key...\", AIRPDCAP_DEBUG_LEVEL_3);\r\n                            tmp_key=sa->key;\r\n                    } else {\r\n                        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsna4WHandshake\", \"Cached key is of a wrong type, try WPA key...\", AIRPDCAP_DEBUG_LEVEL_3);\r\n                        tmp_key=&ctx->keys[key_index];\r\n                    }\r\n                }\r\n\r\n                /* obviously, try only WPA keys... */\r\n                if (tmp_key->KeyType==AIRPDCAP_KEY_TYPE_WPA_PWD ||\r\n                    tmp_key->KeyType==AIRPDCAP_KEY_TYPE_WPA_PSK ||\r\n                    tmp_key->KeyType==AIRPDCAP_KEY_TYPE_WPA_PMK)\r\n                {\r\n                    if (tmp_key->KeyType == AIRPDCAP_KEY_TYPE_WPA_PWD && tmp_key->UserPwd.SsidLen == 0 && ctx->pkt_ssid_len > 0 && ctx->pkt_ssid_len <= AIRPDCAP_WPA_SSID_MAX_LEN) {\r\n                        /* We have a \"wildcard\" SSID.  Use the one from the packet. */\r\n                        memcpy(&pkt_key, tmp_key, sizeof(pkt_key));\r\n                        memcpy(&pkt_key.UserPwd.Ssid, ctx->pkt_ssid, ctx->pkt_ssid_len);\r\n                         pkt_key.UserPwd.SsidLen = ctx->pkt_ssid_len;\r\n                        AirPDcapRsnaPwd2Psk(pkt_key.UserPwd.Passphrase, pkt_key.UserPwd.Ssid,\r\n                            pkt_key.UserPwd.SsidLen, pkt_key.KeyData.Wpa.Psk);\r\n                        tmp_pkt_key = &pkt_key;\r\n                    } else {\r\n                        tmp_pkt_key = tmp_key;\r\n                    }\r\n\r\n                    /* derive the PTK from the BSSID, STA MAC, PMK, SNonce, ANonce */\r\n                    AirPDcapRsnaPrfX(sa,                            /* authenticator nonce, bssid, station mac */\r\n                                     tmp_pkt_key->KeyData.Wpa.Psk,      /* PSK == PMK */\r\n                                     data+offset+12,                /* supplicant nonce */\r\n                                     512,\r\n                                     sa->wpa.ptk);\r\n\r\n                    /* verify the MIC (compare the MIC in the packet included in this message with a MIC calculated with the PTK) */\r\n                    eapol_len=pntoh16(data+offset-3)+4;\r\n                    memcpy(eapol, &data[offset-5], (eapol_len<AIRPDCAP_EAPOL_MAX_LEN?eapol_len:AIRPDCAP_EAPOL_MAX_LEN));\r\n                    ret_value=AirPDcapRsnaMicCheck(eapol,           /*      eapol frame (header also) */\r\n                                                   eapol_len,       /*      eapol frame length        */\r\n                                                   sa->wpa.ptk,     /*      Key Confirmation Key      */\r\n                                                   AIRPDCAP_EAP_KEY_DESCR_VER(data[offset+1])); /*  EAPOL-Key description version */\r\n\r\n                    /* If the MIC is valid, the Authenticator checks that the RSN information element bit-wise matches       */\r\n                    /* that from the (Re)Association Request message.                                                        */\r\n                    /*              i) TODO If these are not exactly the same, the Authenticator uses MLME-DEAUTHENTICATE.request */\r\n                    /* primitive to terminate the association.                                                               */\r\n                    /*              ii) If they do match bit-wise, the Authenticator constructs Message 3.                   */\r\n                }\r\n\r\n                if (!ret_value &&\r\n                    (tmp_key->KeyType==AIRPDCAP_KEY_TYPE_WPA_PWD ||\r\n                    tmp_key->KeyType==AIRPDCAP_KEY_TYPE_WPA_PSK ||\r\n                    tmp_key->KeyType==AIRPDCAP_KEY_TYPE_WPA_PMK))\r\n                {\r\n                    /* the temporary key is the correct one, cached in the Security Association */\r\n\r\n                    sa->key=tmp_key;\r\n                    break;\r\n                } else {\r\n                    /* the cached key was not valid, try other keys */\r\n\r\n                    if (useCache==TRUE) {\r\n                        useCache=FALSE;\r\n                        key_index--;\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (ret_value) {\r\n                AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsna4WHandshake\", \"handshake step failed\", AIRPDCAP_DEBUG_LEVEL_3);\r\n                return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\r\n            }\r\n\r\n            sa->handshake=2;\r\n            sa->validKey=TRUE; /* we can use the key to decode, even if we have not captured the other eapol packets */\r\n\r\n            return AIRPDCAP_RET_SUCCESS_HANDSHAKE;\r\n        } else {\r\n        /* message 4 */\r\n\r\n            /* TODO \"Note that when the 4-Way Handshake is first used Message 4 is sent in the clear.\" */\r\n\r\n            /* TODO check MIC and Replay Counter                                                                     */\r\n            /* On reception of Message 4, the Authenticator verifies that the Key Replay Counter field value is one  */\r\n            /* that it used on this 4-Way Handshake; if it is not, it silently discards the message.                 */\r\n            /* If the calculated MIC does not match the MIC that the Supplicant included in the EAPOL-Key frame, the */\r\n            /* Authenticator silently discards Message 4.                                                            */\r\n\r\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsna4WHandshake\", \"4-way handshake message 4\", AIRPDCAP_DEBUG_LEVEL_3);\r\n\r\n            sa->handshake=4;\r\n\r\n            return AIRPDCAP_RET_SUCCESS_HANDSHAKE;\r\n        }\r\n    }\r\n\r\n    /* message 3: Authenticator->Supplicant (Sec=1, Mic=1, Ack=1, Inst=0/1, Key=1(pairwise), KeyRSC=???, Nonce=ANonce, MIC=1) */\r\n    if (AIRPDCAP_EAP_ACK(data[offset+1])==1 &&\r\n        AIRPDCAP_EAP_MIC(data[offset])==1)\r\n    {\r\n        const EAPOL_RSN_KEY *pEAPKey;\r\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsna4WHandshake\", \"4-way handshake message 3\", AIRPDCAP_DEBUG_LEVEL_3);\r\n\r\n        /* On reception of Message 3, the Supplicant silently discards the message if the Key Replay Counter field     */\r\n        /* value has already been used or if the ANonce value in Message 3 differs from the ANonce value in Message 1. */\r\n        /* -> not checked, the Authenticator will send another message 3 (hopefully!)                                  */\r\n\r\n        /* TODO check page 88 (RNS) */\r\n\r\n        /* If using WPA2 PSK, message 3 will contain an RSN for the group key (GTK KDE).\r\n           In order to properly support decrypting WPA2-PSK packets, we need to parse this to get the group key. */\r\n        pEAPKey = (const EAPOL_RSN_KEY *)(&(data[offset-1]));\r\n        if (pEAPKey->type == AIRPDCAP_RSN_WPA2_KEY_DESCRIPTOR){\r\n            PAIRPDCAP_SEC_ASSOCIATION broadcast_sa;\r\n            AIRPDCAP_SEC_ASSOCIATION_ID id;\r\n\r\n            /* Get broadcacst SA for the current BSSID */\r\n            memcpy(id.sta, broadcast_mac, AIRPDCAP_MAC_LEN);\r\n            memcpy(id.bssid, sa->saId.bssid, AIRPDCAP_MAC_LEN);\r\n            broadcast_sa = AirPDcapGetSaPtr(ctx, &id);\r\n\r\n            if (broadcast_sa == NULL){\r\n                return AIRPDCAP_RET_REQ_DATA;\r\n            }\r\n            return (AirPDcapDecryptWPABroadcastKey(pEAPKey, sa->wpa.ptk+16, broadcast_sa, tot_len-offset+1));\r\n        }\r\n    }\r\n\r\n    return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\r\n}", ".irPDcapDecryptWPABroadcastKey": "static INT\r\nAirPDcapDecryptWPABroadcastKey(const EAPOL_RSN_KEY *pEAPKey, guint8 *decryption_key, PAIRPDCAP_SEC_ASSOCIATION sa, guint eapol_len)\r\n{\r\n    guint8 key_version;\r\n    const guint8 *key_data;\r\n    guint8  *szEncryptedKey;\r\n    guint16 key_bytes_len = 0; /* Length of the total key data field */\r\n    guint16 key_len;           /* Actual group key length */\r\n    static AIRPDCAP_KEY_ITEM dummy_key; /* needed in case AirPDcapRsnaMng() wants the key structure */\r\n    AIRPDCAP_SEC_ASSOCIATION *tmp_sa;\r\n\r\n    /* We skip verifying the MIC of the key. If we were implementing a WPA supplicant we'd want to verify, but for a sniffer it's not needed. */\r\n\r\n    /* Preparation for decrypting the group key -  determine group key data length */\r\n    /* depending on whether the pairwise key is TKIP or AES encryption key */\r\n    key_version = AIRPDCAP_EAP_KEY_DESCR_VER(pEAPKey->key_information[1]);\r\n    if (key_version == AIRPDCAP_WPA_KEY_VER_NOT_CCMP){\r\n        /* TKIP */\r\n        key_bytes_len = pntoh16(pEAPKey->key_length);\r\n    }else if (key_version == AIRPDCAP_WPA_KEY_VER_AES_CCMP){\r\n        /* AES */\r\n        key_bytes_len = pntoh16(pEAPKey->key_data_len);\r\n\r\n        /* AES keys must be at least 128 bits = 16 bytes. */\r\n        if (key_bytes_len < 16) {\r\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\r\n        }\r\n    }\r\n\r\n    if ((key_bytes_len < GROUP_KEY_MIN_LEN) ||\r\n        (eapol_len < sizeof(EAPOL_RSN_KEY)) ||\r\n        (key_bytes_len > eapol_len - sizeof(EAPOL_RSN_KEY))) {\r\n        return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\r\n    }\r\n\r\n    /* Encrypted key is in the information element field of the EAPOL key packet */\r\n    key_data = (const guint8 *)pEAPKey + sizeof(EAPOL_RSN_KEY);\r\n    szEncryptedKey = (guint8 *)g_memdup(key_data, key_bytes_len);\r\n\r\n    DEBUG_DUMP(\"Encrypted Broadcast key:\", szEncryptedKey, key_bytes_len);\r\n    DEBUG_DUMP(\"KeyIV:\", pEAPKey->key_iv, 16);\r\n    DEBUG_DUMP(\"decryption_key:\", decryption_key, 16);\r\n\r\n    /* We are rekeying, save old sa */\r\n    tmp_sa=(AIRPDCAP_SEC_ASSOCIATION *)g_malloc(sizeof(AIRPDCAP_SEC_ASSOCIATION));\r\n    memcpy(tmp_sa, sa, sizeof(AIRPDCAP_SEC_ASSOCIATION));\r\n    sa->next=tmp_sa;\r\n\r\n    /* As we have no concept of the prior association request at this point, we need to deduce the     */\r\n    /* group key cipher from the length of the key bytes. In WPA this is straightforward as the        */\r\n    /* keybytes just contain the GTK, and the GTK is only in the group handshake, NOT the M3.          */\r\n    /* In WPA2 its a little more tricky as the M3 keybytes contain an RSN_IE, but the group handshake  */\r\n    /* does not. Also there are other (variable length) items in the keybytes which we need to account */\r\n    /* for to determine the true key length, and thus the group cipher.                                */\r\n\r\n    if (key_version == AIRPDCAP_WPA_KEY_VER_NOT_CCMP){\r\n        guint8 new_key[32];\r\n        guint8 dummy[256] = { 0 };\r\n        /* TKIP key */\r\n        /* Per 802.11i, Draft 3.0 spec, section 8.5.2, p. 97, line 4-8, */\r\n        /* group key is decrypted using RC4.  Concatenate the IV with the 16 byte EK (PTK+16) to get the decryption key */\r\n\r\n        gcry_cipher_hd_t  rc4_handle;\r\n\r\n        /* The WPA group key just contains the GTK bytes so deducing the type is straightforward   */\r\n        /* Note - WPA M3 doesn't contain a group key so we'll only be here for the group handshake */\r\n        sa->wpa.key_ver = (key_bytes_len >=TKIP_GROUP_KEY_LEN)?AIRPDCAP_WPA_KEY_VER_NOT_CCMP:AIRPDCAP_WPA_KEY_VER_AES_CCMP;\r\n\r\n        /* Build the full decryption key based on the IV and part of the pairwise key */\r\n        memcpy(new_key, pEAPKey->key_iv, 16);\r\n        memcpy(new_key+16, decryption_key, 16);\r\n        DEBUG_DUMP(\"FullDecrKey:\", new_key, 32);\r\n\r\n        if (gcry_cipher_open (&rc4_handle, GCRY_CIPHER_ARCFOUR, GCRY_CIPHER_MODE_STREAM, 0)) {\r\n          return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\r\n        }\r\n        if (gcry_cipher_setkey(rc4_handle, new_key, sizeof(new_key))) {\r\n          gcry_cipher_close(rc4_handle);\r\n          return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\r\n        }\r\n\r\n        /* Do dummy 256 iterations of the RC4 algorithm (per 802.11i, Draft 3.0, p. 97 line 6) */\r\n        gcry_cipher_decrypt(rc4_handle, dummy, 256, NULL, 0);\r\n        gcry_cipher_decrypt(rc4_handle, szEncryptedKey, key_bytes_len, NULL, 0);\r\n        gcry_cipher_close(rc4_handle);\r\n\r\n    } else if (key_version == AIRPDCAP_WPA_KEY_VER_AES_CCMP){\r\n        /* AES CCMP key */\r\n\r\n        guint8 key_found;\r\n        guint8 key_length;\r\n        guint16 key_index;\r\n        guint8 *decrypted_data;\r\n\r\n        /* Unwrap the key; the result is key_bytes_len in length */\r\n        decrypted_data = AES_unwrap(decryption_key, 16, szEncryptedKey,  key_bytes_len);\r\n\r\n        /* With WPA2 what we get after Broadcast Key decryption is an actual RSN structure.\r\n           The key itself is stored as a GTK KDE\r\n           WPA2 IE (1 byte) id = 0xdd, length (1 byte), GTK OUI (4 bytes), key index (1 byte) and 1 reserved byte. Thus we have to\r\n           pass pointer to the actual key with 8 bytes offset */\r\n\r\n        key_found = FALSE;\r\n        key_index = 0;\r\n\r\n        /* Parse Key data until we found GTK KDE */\r\n        /* GTK KDE = 00-0F-AC 01 */\r\n        while(key_index < (key_bytes_len - 6) && !key_found){\r\n            guint8 rsn_id;\r\n            guint32 type;\r\n\r\n            /* Get RSN ID */\r\n            rsn_id = decrypted_data[key_index];\r\n            type = ((decrypted_data[key_index + 2] << 24) +\r\n                    (decrypted_data[key_index + 3] << 16) +\r\n                    (decrypted_data[key_index + 4] << 8) +\r\n                     (decrypted_data[key_index + 5]));\r\n\r\n            if (rsn_id == 0xdd && type == 0x000fac01) {\r\n                key_found = TRUE;\r\n            } else {\r\n                key_index += decrypted_data[key_index+1]+2;\r\n            }\r\n        }\r\n\r\n        if (key_found){\r\n            if (decrypted_data[key_index+1] <= 6) {\r\n                g_free(decrypted_data);\r\n                g_free(szEncryptedKey);\r\n                return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\r\n            }\r\n            key_length = decrypted_data[key_index+1] - 6;\r\n\r\n            if (key_index+8 >= key_bytes_len ||\r\n                key_length > key_bytes_len - key_index - 8) {\r\n                g_free(decrypted_data);\r\n                g_free(szEncryptedKey);\r\n                return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\r\n            }\r\n\r\n            /* Skip over the GTK header info, and don't copy past the end of the encrypted data */\r\n            memcpy(szEncryptedKey, decrypted_data+key_index+8, key_length);\r\n        } else {\r\n            g_free(decrypted_data);\r\n            g_free(szEncryptedKey);\r\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\r\n        }\r\n\r\n        if (key_length == TKIP_GROUP_KEY_LEN)\r\n            sa->wpa.key_ver = AIRPDCAP_WPA_KEY_VER_NOT_CCMP;\r\n        else\r\n            sa->wpa.key_ver = AIRPDCAP_WPA_KEY_VER_AES_CCMP;\r\n\r\n        g_free(decrypted_data);\r\n    }\r\n\r\n    key_len = (sa->wpa.key_ver==AIRPDCAP_WPA_KEY_VER_NOT_CCMP)?TKIP_GROUP_KEY_LEN:CCMP_GROUP_KEY_LEN;\r\n    if (key_len > key_bytes_len) {\r\n        /* the key required for this protocol is longer than the key that we just calculated */\r\n        g_free(szEncryptedKey);\r\n        return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\r\n    }\r\n\r\n    /* Decrypted key is now in szEncryptedKey with len of key_len */\r\n    DEBUG_DUMP(\"Broadcast key:\", szEncryptedKey, key_len);\r\n\r\n    /* Load the proper key material info into the SA */\r\n    sa->key = &dummy_key;  /* we just need key to be not null because it is checked in AirPDcapRsnaMng().  The WPA key materials are actually in the .wpa structure */\r\n    sa->validKey = TRUE;\r\n\r\n    /* Since this is a GTK and its size is only 32 bytes (vs. the 64 byte size of a PTK), we fake it and put it in at a 32-byte offset so the  */\r\n    /* AirPDcapRsnaMng() function will extract the right piece of the GTK for decryption. (The first 16 bytes of the GTK are used for decryption.) */\r\n    memset(sa->wpa.ptk, 0, sizeof(sa->wpa.ptk));\r\n    memcpy(sa->wpa.ptk+32, szEncryptedKey, key_len);\r\n    g_free(szEncryptedKey);\r\n    return AIRPDCAP_RET_SUCCESS_HANDSHAKE;\r\n}", ".irPDcapTDLSDeriveKey": "static INT\r\nAirPDcapTDLSDeriveKey(\r\n    PAIRPDCAP_SEC_ASSOCIATION sa,\r\n    const guint8 *data,\r\n#if GCRYPT_VERSION_NUMBER >= 0x010600\r\n    guint offset_rsne,\r\n#else\r\n    guint offset_rsne _U_,\r\n#endif\r\n    guint offset_fte,\r\n#if GCRYPT_VERSION_NUMBER >= 0x010600\r\n    guint offset_timeout,\r\n#else\r\n    guint offset_timeout _U_,\r\n#endif\r\n    guint offset_link,\r\n#if GCRYPT_VERSION_NUMBER >= 0x010600\r\n    guint8 action)\r\n#else\r\n    guint8 action _U_)\r\n#endif\r\n{\r\n\r\n    gcry_md_hd_t sha256_handle;\r\n    gcry_md_hd_t hmac_handle;\r\n    const guint8 *snonce, *anonce, *initiator, *responder, *bssid;\r\n    guint8 key_input[32];\r\n#if GCRYPT_VERSION_NUMBER >= 0x010600\r\n    guint8 mic[16], seq_num = action + 1;\r\n    guint8 zeros[16] = { 0 };\r\n    gcry_mac_hd_t cmac_handle;\r\n    size_t cmac_len = 16;\r\n    size_t cmac_write_len;\r\n#endif\r\n\r\n    /* Get key input */\r\n    anonce = &data[offset_fte + 20];\r\n    snonce = &data[offset_fte + 52];\r\n\r\n    gcry_md_open (&sha256_handle, GCRY_MD_SHA256, 0);\r\n    if (memcmp(anonce, snonce, AIRPDCAP_WPA_NONCE_LEN) < 0) {\r\n        gcry_md_write(sha256_handle, anonce, AIRPDCAP_WPA_NONCE_LEN);\r\n        gcry_md_write(sha256_handle, snonce, AIRPDCAP_WPA_NONCE_LEN);\r\n    } else {\r\n        gcry_md_write(sha256_handle, snonce, AIRPDCAP_WPA_NONCE_LEN);\r\n        gcry_md_write(sha256_handle, anonce, AIRPDCAP_WPA_NONCE_LEN);\r\n    }\r\n    memcpy(key_input, gcry_md_read(sha256_handle, 0), 32);\r\n    gcry_md_close(sha256_handle);\r\n\r\n    /* Derive key */\r\n    bssid = &data[offset_link + 2];\r\n    initiator = &data[offset_link + 8];\r\n    responder = &data[offset_link + 14];\r\n    if (gcry_md_open(&hmac_handle, GCRY_MD_SHA256, GCRY_MD_FLAG_HMAC)) {\r\n        return AIRPDCAP_RET_UNSUCCESS;\r\n    }\r\n    if (gcry_md_setkey(hmac_handle, key_input, 32)) {\r\n        gcry_md_close(hmac_handle);\r\n        return AIRPDCAP_RET_UNSUCCESS;\r\n    }\r\n    gcry_md_putc(hmac_handle, 1);\r\n    gcry_md_putc(hmac_handle, 0);\r\n    gcry_md_write(hmac_handle, \"TDLS PMK\", 8);\r\n    if (memcmp(initiator, responder, AIRPDCAP_MAC_LEN) < 0) {\r\n          gcry_md_write(hmac_handle, initiator, AIRPDCAP_MAC_LEN);\r\n          gcry_md_write(hmac_handle, responder, AIRPDCAP_MAC_LEN);\r\n    } else {\r\n          gcry_md_write(hmac_handle, responder, AIRPDCAP_MAC_LEN);\r\n          gcry_md_write(hmac_handle, initiator, AIRPDCAP_MAC_LEN);\r\n    }\r\n    gcry_md_write(hmac_handle, bssid, AIRPDCAP_MAC_LEN);\r\n    gcry_md_putc(hmac_handle, 0);\r\n    gcry_md_putc(hmac_handle, 1);\r\n    memcpy(key_input, gcry_md_read(hmac_handle, 0), 32);\r\n    gcry_md_close(hmac_handle);\r\n\r\n    /* Check MIC */\r\n#if GCRYPT_VERSION_NUMBER >= 0x010600\r\n    if (gcry_mac_open(&cmac_handle, GCRY_MAC_CMAC_AES, 0, NULL)) {\r\n        return AIRPDCAP_RET_UNSUCCESS;\r\n    }\r\n    if (gcry_mac_setkey(cmac_handle, key_input, 16)) {\r\n        gcry_mac_close(cmac_handle);\r\n        return AIRPDCAP_RET_UNSUCCESS;\r\n    }\r\n    gcry_mac_write(cmac_handle, initiator, AIRPDCAP_MAC_LEN);\r\n    gcry_mac_write(cmac_handle, responder, AIRPDCAP_MAC_LEN);\r\n    gcry_mac_write(cmac_handle, &seq_num, 1);\r\n    gcry_mac_write(cmac_handle, &data[offset_link], data[offset_link + 1] + 2);\r\n    gcry_mac_write(cmac_handle, &data[offset_rsne], data[offset_rsne + 1] + 2);\r\n    gcry_mac_write(cmac_handle, &data[offset_timeout], data[offset_timeout + 1] + 2);\r\n    gcry_mac_write(cmac_handle, &data[offset_fte], 4);\r\n    gcry_mac_write(cmac_handle, zeros, 16);\r\n    cmac_write_len = data[offset_fte + 1] + 2;\r\n    if (cmac_write_len < 20) {\r\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapTDLSDeriveKey\", \"Bad MAC len\", AIRPDCAP_DEBUG_LEVEL_3);\r\n        gcry_mac_close(cmac_handle);\r\n        return AIRPDCAP_RET_UNSUCCESS;\r\n    }\r\n    gcry_mac_write(cmac_handle, &data[offset_fte + 20], cmac_write_len - 20);\r\n    if (gcry_mac_read(cmac_handle, mic, &cmac_len) != GPG_ERR_NO_ERROR) {\r\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapTDLSDeriveKey\", \"MAC read error\", AIRPDCAP_DEBUG_LEVEL_3);\r\n        gcry_mac_close(cmac_handle);\r\n        return AIRPDCAP_RET_UNSUCCESS;\r\n    }\r\n    if (memcmp(mic, &data[offset_fte + 4], 16)) {\r\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapTDLSDeriveKey\", \"MIC verification failed\", AIRPDCAP_DEBUG_LEVEL_3);\r\n        gcry_mac_close(cmac_handle);\r\n        return AIRPDCAP_RET_UNSUCCESS;\r\n    }\r\n    gcry_mac_close(cmac_handle);\r\n#else\r\n    AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapTDLSDeriveKey\", \"MIC verification failed, need libgcrypt >= 1.6\", AIRPDCAP_DEBUG_LEVEL_3);\r\n    return AIRPDCAP_RET_UNSUCCESS;\r\n#endif\r\n    memcpy(AIRPDCAP_GET_TK(sa->wpa.ptk), &key_input[16], 16);\r\n    memcpy(sa->wpa.nonce, snonce, AIRPDCAP_WPA_NONCE_LEN);\r\n    sa->validKey = TRUE;\r\n    sa->wpa.key_ver = AIRPDCAP_WPA_KEY_VER_AES_CCMP;\r\n    AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapTDLSDeriveKey\", \"MIC verified\", AIRPDCAP_DEBUG_LEVEL_3);\r\n    return  AIRPDCAP_RET_SUCCESS;\r\n}", ".irPDcapGetSaAddress": "static INT\r\nAirPDcapGetSaAddress(\r\n    const AIRPDCAP_MAC_FRAME_ADDR4 *frame,\r\n    AIRPDCAP_SEC_ASSOCIATION_ID *id)\r\n{\r\n#ifdef AIRPDCAP_DEBUG\r\n#define MSGBUF_LEN 255\r\n    CHAR msgbuf[MSGBUF_LEN];\r\n#endif\r\n\r\n    if ((AIRPDCAP_TYPE(frame->fc[0])==AIRPDCAP_TYPE_DATA) &&\r\n        (AIRPDCAP_DS_BITS(frame->fc[1]) == 0) &&\r\n        (memcmp(frame->addr2, frame->addr3, AIRPDCAP_MAC_LEN) != 0) &&\r\n        (memcmp(frame->addr1, frame->addr3, AIRPDCAP_MAC_LEN) != 0)) {\r\n        /* DATA frame with fromDS=0 ToDS=0 and neither RA or SA is BSSID\r\n           => TDLS traffic. Use highest MAC address for bssid */\r\n        if (memcmp(frame->addr1, frame->addr2, AIRPDCAP_MAC_LEN) < 0) {\r\n            memcpy(id->sta, frame->addr1, AIRPDCAP_MAC_LEN);\r\n            memcpy(id->bssid, frame->addr2, AIRPDCAP_MAC_LEN);\r\n        } else {\r\n            memcpy(id->sta, frame->addr2, AIRPDCAP_MAC_LEN);\r\n            memcpy(id->bssid, frame->addr1, AIRPDCAP_MAC_LEN);\r\n        }\r\n    } else {\r\n        const UCHAR *addr;\r\n\r\n        /* Normal Case: SA between STA and AP */\r\n        if ((addr = AirPDcapGetBssidAddress(frame)) != NULL) {\r\n            memcpy(id->bssid, addr, AIRPDCAP_MAC_LEN);\r\n        } else {\r\n            return AIRPDCAP_RET_UNSUCCESS;\r\n        }\r\n\r\n        if ((addr = AirPDcapGetStaAddress(frame)) != NULL) {\r\n            memcpy(id->sta, addr, AIRPDCAP_MAC_LEN);\r\n        } else {\r\n            return AIRPDCAP_RET_UNSUCCESS;\r\n        }\r\n    }\r\n\r\n#ifdef AIRPDCAP_DEBUG\r\n    g_snprintf(msgbuf, MSGBUF_LEN, \"BSSID_MAC: %02X.%02X.%02X.%02X.%02X.%02X\\t\",\r\n               id->bssid[0],id->bssid[1],id->bssid[2],id->bssid[3],id->bssid[4],id->bssid[5]);\r\n    AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapGetSaAddress\", msgbuf, AIRPDCAP_DEBUG_LEVEL_3);\r\n    g_snprintf(msgbuf, MSGBUF_LEN, \"STA_MAC: %02X.%02X.%02X.%02X.%02X.%02X\\t\",\r\n               id->sta[0],id->sta[1],id->sta[2],id->sta[3],id->sta[4],id->sta[5]);\r\n    AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapGetSaAddress\", msgbuf, AIRPDCAP_DEBUG_LEVEL_3);\r\n#endif\r\n\r\n    return AIRPDCAP_RET_SUCCESS;\r\n}", ".irPDcapScanForKeys": "static INT AirPDcapScanForKeys(\r\n    PAIRPDCAP_CONTEXT ctx,\r\n    const guint8 *data,\r\n    const guint mac_header_len,\r\n    const guint tot_len,\r\n    AIRPDCAP_SEC_ASSOCIATION_ID id\r\n)\r\n{\r\n    const UCHAR *addr;\r\n    guint bodyLength;\r\n    PAIRPDCAP_SEC_ASSOCIATION sta_sa;\r\n    PAIRPDCAP_SEC_ASSOCIATION sa;\r\n    guint offset = 0;\r\n    const guint8 dot1x_header[] = {\r\n        0xAA,             /* DSAP=SNAP */\r\n        0xAA,             /* SSAP=SNAP */\r\n        0x03,             /* Control field=Unnumbered frame */\r\n        0x00, 0x00, 0x00, /* Org. code=encaps. Ethernet */\r\n        0x88, 0x8E        /* Type: 802.1X authentication */\r\n    };\r\n    const guint8 bt_dot1x_header[] = {\r\n        0xAA,             /* DSAP=SNAP */\r\n        0xAA,             /* SSAP=SNAP */\r\n        0x03,             /* Control field=Unnumbered frame */\r\n        0x00, 0x19, 0x58, /* Org. code=Bluetooth SIG */\r\n        0x00, 0x03        /* Type: Bluetooth Security */\r\n    };\r\n    const guint8 tdls_header[] = {\r\n        0xAA,             /* DSAP=SNAP */\r\n        0xAA,             /* SSAP=SNAP */\r\n        0x03,             /* Control field=Unnumbered frame */\r\n        0x00, 0x00, 0x00, /* Org. code=encaps. Ethernet */\r\n        0x89, 0x0D,       /* Type: 802.11 - Fast Roaming Remote Request */\r\n        0x02,             /* Payload Type: TDLS */\r\n        0X0C              /* Action Category: TDLS */\r\n    };\r\n\r\n    const EAPOL_RSN_KEY *pEAPKey;\r\n#ifdef AIRPDCAP_DEBUG\r\n#define MSGBUF_LEN 255\r\n    CHAR msgbuf[MSGBUF_LEN];\r\n#endif\r\n    AIRPDCAP_DEBUG_TRACE_START(\"AirPDcapScanForKeys\");\r\n\r\n    /* cache offset in the packet data */\r\n    offset = mac_header_len;\r\n\r\n    /* check if the packet has an LLC header and the packet is 802.1X authentication (IEEE 802.1X-2004, pg. 24) */\r\n    if (memcmp(data+offset, dot1x_header, 8) == 0 || memcmp(data+offset, bt_dot1x_header, 8) == 0) {\r\n\r\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Authentication: EAPOL packet\", AIRPDCAP_DEBUG_LEVEL_3);\r\n\r\n        /* skip LLC header */\r\n        offset+=8;\r\n\r\n        /* check if the packet is a EAPOL-Key (0x03) (IEEE 802.1X-2004, pg. 25) */\r\n        if (data[offset+1]!=3) {\r\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Not EAPOL-Key\", AIRPDCAP_DEBUG_LEVEL_3);\r\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\r\n        }\r\n\r\n        /* get and check the body length (IEEE 802.1X-2004, pg. 25) */\r\n        bodyLength=pntoh16(data+offset+2);\r\n        if (((tot_len-offset-4) < bodyLength) || (bodyLength < sizeof(EAPOL_RSN_KEY))) { /* Only check if frame is long enough for eapol header, ignore tailing garbage, see bug 9065 */\r\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"EAPOL body too short\", AIRPDCAP_DEBUG_LEVEL_3);\r\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\r\n        }\r\n\r\n        /* skip EAPOL MPDU and go to the first byte of the body */\r\n        offset+=4;\r\n\r\n        pEAPKey = (const EAPOL_RSN_KEY *) (data+offset);\r\n\r\n        /* check if the key descriptor type is valid (IEEE 802.1X-2004, pg. 27) */\r\n        if (/*pEAPKey->type!=0x1 &&*/ /* RC4 Key Descriptor Type (deprecated) */\r\n            pEAPKey->type != AIRPDCAP_RSN_WPA2_KEY_DESCRIPTOR &&             /* IEEE 802.11 Key Descriptor Type  (WPA2) */\r\n            pEAPKey->type != AIRPDCAP_RSN_WPA_KEY_DESCRIPTOR)           /* 254 = RSN_KEY_DESCRIPTOR - WPA,              */\r\n        {\r\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Not valid key descriptor type\", AIRPDCAP_DEBUG_LEVEL_3);\r\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\r\n        }\r\n\r\n        /* start with descriptor body */\r\n        offset+=1;\r\n\r\n        /* search for a cached Security Association for current BSSID and AP */\r\n        sa = AirPDcapGetSaPtr(ctx, &id);\r\n        if (sa == NULL){\r\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"No SA for BSSID found\", AIRPDCAP_DEBUG_LEVEL_3);\r\n            return AIRPDCAP_RET_REQ_DATA;\r\n        }\r\n\r\n        /* It could be a Pairwise Key exchange, check */\r\n        if (AirPDcapRsna4WHandshake(ctx, data, sa, offset, tot_len) == AIRPDCAP_RET_SUCCESS_HANDSHAKE)\r\n            return AIRPDCAP_RET_SUCCESS_HANDSHAKE;\r\n\r\n        if (mac_header_len + GROUP_KEY_PAYLOAD_LEN_MIN > tot_len) {\r\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Message too short for Group Key\", AIRPDCAP_DEBUG_LEVEL_3);\r\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\r\n        }\r\n\r\n        /* Verify the bitfields: Key = 0(groupwise) Mic = 1 Ack = 1 Secure = 1 */\r\n        if (AIRPDCAP_EAP_KEY(data[offset+1])!=0 ||\r\n            AIRPDCAP_EAP_ACK(data[offset+1])!=1 ||\r\n            AIRPDCAP_EAP_MIC(data[offset]) != 1 ||\r\n            AIRPDCAP_EAP_SEC(data[offset]) != 1){\r\n\r\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Key bitfields not correct for Group Key\", AIRPDCAP_DEBUG_LEVEL_3);\r\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\r\n        }\r\n\r\n        /* force STA address to be the broadcast MAC so we create an SA for the groupkey */\r\n        memcpy(id.sta, broadcast_mac, AIRPDCAP_MAC_LEN);\r\n\r\n        /* get the Security Association structure for the broadcast MAC and AP */\r\n        sa = AirPDcapGetSaPtr(ctx, &id);\r\n        if (sa == NULL){\r\n            return AIRPDCAP_RET_REQ_DATA;\r\n        }\r\n\r\n        /* Get the SA for the STA, since we need its pairwise key to decrpyt the group key */\r\n\r\n        /* get STA address */\r\n        if ( (addr=AirPDcapGetStaAddress((const AIRPDCAP_MAC_FRAME_ADDR4 *)(data))) != NULL) {\r\n            memcpy(id.sta, addr, AIRPDCAP_MAC_LEN);\r\n#ifdef AIRPDCAP_DEBUG\r\n            g_snprintf(msgbuf, MSGBUF_LEN, \"ST_MAC: %2X.%2X.%2X.%2X.%2X.%2X\\t\", id.sta[0],id.sta[1],id.sta[2],id.sta[3],id.sta[4],id.sta[5]);\r\n#endif\r\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", msgbuf, AIRPDCAP_DEBUG_LEVEL_3);\r\n        } else {\r\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"SA not found\", AIRPDCAP_DEBUG_LEVEL_5);\r\n            return AIRPDCAP_RET_REQ_DATA;\r\n        }\r\n\r\n        sta_sa = AirPDcapGetSaPtr(ctx, &id);\r\n        if (sta_sa == NULL){\r\n            return AIRPDCAP_RET_REQ_DATA;\r\n        }\r\n\r\n        /* Try to extract the group key and install it in the SA */\r\n        return (AirPDcapDecryptWPABroadcastKey(pEAPKey, sta_sa->wpa.ptk+16, sa, tot_len-offset+1));\r\n\r\n    } else if (memcmp(data+offset, tdls_header, 10) == 0) {\r\n        const guint8 *initiator, *responder;\r\n        guint8 action;\r\n        guint status, offset_rsne = 0, offset_fte = 0, offset_link = 0, offset_timeout = 0;\r\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Authentication: TDLS Action Frame\", AIRPDCAP_DEBUG_LEVEL_3);\r\n\r\n        /* skip LLC header */\r\n        offset+=10;\r\n\r\n        /* check if the packet is a TDLS response or confirm */\r\n        action = data[offset];\r\n        if (action!=1 && action!=2) {\r\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Not Response nor confirm\", AIRPDCAP_DEBUG_LEVEL_3);\r\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\r\n        }\r\n\r\n        /* check status */\r\n        offset++;\r\n        status=pntoh16(data+offset);\r\n        if (status!=0) {\r\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"TDLS setup not successfull\", AIRPDCAP_DEBUG_LEVEL_3);\r\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\r\n        }\r\n\r\n        /* skip Token + capabilities */\r\n        offset+=5;\r\n\r\n        /* search for RSN, Fast BSS Transition, Link Identifier and Timeout Interval IEs */\r\n\r\n        while(offset < (tot_len - 2)) {\r\n            if (data[offset] == 48) {\r\n                offset_rsne = offset;\r\n            } else if (data[offset] == 55) {\r\n                offset_fte = offset;\r\n            } else if (data[offset] == 56) {\r\n                offset_timeout = offset;\r\n            } else if (data[offset] == 101) {\r\n                offset_link = offset;\r\n            }\r\n\r\n            if (tot_len < offset + data[offset + 1] + 2) {\r\n                return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\r\n            }\r\n            offset += data[offset + 1] + 2;\r\n        }\r\n\r\n        if (offset_rsne == 0 || offset_fte == 0 ||\r\n            offset_timeout == 0 || offset_link == 0)\r\n        {\r\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Cannot Find all necessary IEs\", AIRPDCAP_DEBUG_LEVEL_3);\r\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\r\n        }\r\n\r\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Found RSNE/Fast BSS/Timeout Interval/Link IEs\", AIRPDCAP_DEBUG_LEVEL_3);\r\n\r\n        /* Will create a Security Association between 2 STA. Need to get both MAC address */\r\n        initiator = &data[offset_link + 8];\r\n        responder = &data[offset_link + 14];\r\n\r\n        if (memcmp(initiator, responder, AIRPDCAP_MAC_LEN) < 0) {\r\n            memcpy(id.sta, initiator, AIRPDCAP_MAC_LEN);\r\n            memcpy(id.bssid, responder, AIRPDCAP_MAC_LEN);\r\n        } else {\r\n            memcpy(id.sta, responder, AIRPDCAP_MAC_LEN);\r\n            memcpy(id.bssid, initiator, AIRPDCAP_MAC_LEN);\r\n        }\r\n\r\n        sa = AirPDcapGetSaPtr(ctx, &id);\r\n        if (sa == NULL){\r\n            return AIRPDCAP_RET_REQ_DATA;\r\n        }\r\n\r\n        if (sa->validKey) {\r\n            if (memcmp(sa->wpa.nonce, data + offset_fte + 52, AIRPDCAP_WPA_NONCE_LEN) == 0) {\r\n                /* Already have valid key for this SA, no need to redo key derivation */\r\n                return AIRPDCAP_RET_SUCCESS_HANDSHAKE;\r\n            } else {\r\n                /* We are opening a new session with the same two STA, save previous sa  */\r\n                AIRPDCAP_SEC_ASSOCIATION *tmp_sa = g_new(AIRPDCAP_SEC_ASSOCIATION, 1);\r\n                memcpy(tmp_sa, sa, sizeof(AIRPDCAP_SEC_ASSOCIATION));\r\n                sa->next=tmp_sa;\r\n                sa->validKey = FALSE;\r\n            }\r\n        }\r\n\r\n        if (AirPDcapTDLSDeriveKey(sa, data, offset_rsne, offset_fte, offset_timeout, offset_link, action)\r\n            == AIRPDCAP_RET_SUCCESS) {\r\n            AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapScanForKeys\");\r\n            return AIRPDCAP_RET_SUCCESS_HANDSHAKE;\r\n        }\r\n    } else {\r\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Skipping: not an EAPOL packet\", AIRPDCAP_DEBUG_LEVEL_3);\r\n    }\r\n\r\n    AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapScanForKeys\");\r\n    return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\r\n}", ".irPDcapWepMng": "static INT\r\nAirPDcapWepMng(\r\n    PAIRPDCAP_CONTEXT ctx,\r\n    UCHAR *decrypt_data,\r\n    guint mac_header_len,\r\n    guint *decrypt_len,\r\n    PAIRPDCAP_KEY_ITEM key,\r\n    AIRPDCAP_SEC_ASSOCIATION *sa,\r\n    INT offset)\r\n{\r\n    UCHAR wep_key[AIRPDCAP_WEP_KEY_MAXLEN+AIRPDCAP_WEP_IVLEN];\r\n    size_t keylen;\r\n    INT ret_value=1;\r\n    INT key_index;\r\n    AIRPDCAP_KEY_ITEM *tmp_key;\r\n    UINT8 useCache=FALSE;\r\n    UCHAR *try_data;\r\n    guint try_data_len = *decrypt_len;\r\n\r\n    try_data = (UCHAR *)g_malloc(try_data_len);\r\n\r\n    if (sa->key!=NULL)\r\n        useCache=TRUE;\r\n\r\n    for (key_index=0; key_index<(INT)ctx->keys_nr; key_index++) {\r\n        /* use the cached one, or try all keys */\r\n        if (!useCache) {\r\n            tmp_key=&ctx->keys[key_index];\r\n        } else {\r\n            if (sa->key!=NULL && sa->key->KeyType==AIRPDCAP_KEY_TYPE_WEP) {\r\n                AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapWepMng\", \"Try cached WEP key...\", AIRPDCAP_DEBUG_LEVEL_3);\r\n                tmp_key=sa->key;\r\n            } else {\r\n                AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapWepMng\", \"Cached key is not valid, try another WEP key...\", AIRPDCAP_DEBUG_LEVEL_3);\r\n                tmp_key=&ctx->keys[key_index];\r\n            }\r\n        }\r\n\r\n        /* obviously, try only WEP keys... */\r\n        if (tmp_key->KeyType==AIRPDCAP_KEY_TYPE_WEP) {\r\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapWepMng\", \"Try WEP key...\", AIRPDCAP_DEBUG_LEVEL_3);\r\n\r\n            memset(wep_key, 0, sizeof(wep_key));\r\n            memcpy(try_data, decrypt_data, *decrypt_len);\r\n\r\n            /* Costruct the WEP seed: copy the IV in first 3 bytes and then the WEP key (refer to 802-11i-2004, 8.2.1.4.3, pag. 36) */\r\n            memcpy(wep_key, try_data+mac_header_len, AIRPDCAP_WEP_IVLEN);\r\n            keylen=tmp_key->KeyData.Wep.WepKeyLen;\r\n            memcpy(wep_key+AIRPDCAP_WEP_IVLEN, tmp_key->KeyData.Wep.WepKey, keylen);\r\n\r\n            ret_value=AirPDcapWepDecrypt(wep_key,\r\n                keylen+AIRPDCAP_WEP_IVLEN,\r\n                try_data + (mac_header_len+AIRPDCAP_WEP_IVLEN+AIRPDCAP_WEP_KIDLEN),\r\n                *decrypt_len-(mac_header_len+AIRPDCAP_WEP_IVLEN+AIRPDCAP_WEP_KIDLEN+AIRPDCAP_CRC_LEN));\r\n\r\n            if (ret_value == AIRPDCAP_RET_SUCCESS)\r\n                memcpy(decrypt_data, try_data, *decrypt_len);\r\n        }\r\n\r\n        if (!ret_value && tmp_key->KeyType==AIRPDCAP_KEY_TYPE_WEP) {\r\n            /* the tried key is the correct one, cached in the Security Association */\r\n\r\n            sa->key=tmp_key;\r\n\r\n            if (key!=NULL) {\r\n                memcpy(key, sa->key, sizeof(AIRPDCAP_KEY_ITEM));\r\n                key->KeyType=AIRPDCAP_KEY_TYPE_WEP;\r\n            }\r\n\r\n            break;\r\n        } else {\r\n            /* the cached key was not valid, try other keys */\r\n\r\n            if (useCache==TRUE) {\r\n                useCache=FALSE;\r\n                key_index--;\r\n            }\r\n        }\r\n    }\r\n\r\n    g_free(try_data);\r\n    if (ret_value)\r\n        return AIRPDCAP_RET_UNSUCCESS;\r\n\r\n    AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapWepMng\", \"WEP DECRYPTED!!!\", AIRPDCAP_DEBUG_LEVEL_3);\r\n\r\n    /* remove ICV (4bytes) from the end of packet */\r\n    *decrypt_len-=4;\r\n\r\n    if (*decrypt_len < 4) {\r\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapWepMng\", \"Decryption length too short\", AIRPDCAP_DEBUG_LEVEL_3);\r\n        return AIRPDCAP_RET_UNSUCCESS;\r\n    }\r\n\r\n    /* remove protection bit */\r\n    decrypt_data[1]&=0xBF;\r\n\r\n    /* remove IC header */\r\n    offset = mac_header_len;\r\n    *decrypt_len-=4;\r\n    memmove(decrypt_data+offset, decrypt_data+offset+AIRPDCAP_WEP_IVLEN+AIRPDCAP_WEP_KIDLEN, *decrypt_len-offset);\r\n\r\n    return AIRPDCAP_RET_SUCCESS;\r\n}", ".irPDcapRsnaMng": "static INT\r\nAirPDcapRsnaMng(\r\n    UCHAR *decrypt_data,\r\n    guint mac_header_len,\r\n    guint *decrypt_len,\r\n    PAIRPDCAP_KEY_ITEM key,\r\n    AIRPDCAP_SEC_ASSOCIATION *sa,\r\n    INT offset)\r\n{\r\n    INT ret_value=1;\r\n    UCHAR *try_data;\r\n    guint try_data_len = *decrypt_len;\r\n\r\n    if (*decrypt_len > try_data_len) {\r\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsnaMng\", \"Invalid decryption length\", AIRPDCAP_DEBUG_LEVEL_3);\r\n        return AIRPDCAP_RET_UNSUCCESS;\r\n    }\r\n\r\n    /* allocate a temp buffer for the decryption loop */\r\n    try_data=(UCHAR *)g_malloc(try_data_len);\r\n\r\n    /* start of loop added by GCS */\r\n    for(/* sa */; sa != NULL ;sa=sa->next) {\r\n\r\n       if (sa->validKey==FALSE) {\r\n           AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsnaMng\", \"Key not yet valid\", AIRPDCAP_DEBUG_LEVEL_3);\r\n           continue;\r\n       }\r\n\r\n       /* copy the encrypted data into a temp buffer */\r\n       memcpy(try_data, decrypt_data, *decrypt_len);\r\n\r\n       if (sa->wpa.key_ver==1) {\r\n           /* CCMP -> HMAC-MD5 is the EAPOL-Key MIC, RC4 is the EAPOL-Key encryption algorithm */\r\n           AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsnaMng\", \"TKIP\", AIRPDCAP_DEBUG_LEVEL_3);\r\n           DEBUG_DUMP(\"ptk\", sa->wpa.ptk, 64);\r\n           DEBUG_DUMP(\"ptk portion used\", AIRPDCAP_GET_TK(sa->wpa.ptk), 16);\r\n\r\n           ret_value=AirPDcapTkipDecrypt(try_data+offset, *decrypt_len-offset, try_data+AIRPDCAP_TA_OFFSET, AIRPDCAP_GET_TK(sa->wpa.ptk));\r\n           if (ret_value){\r\n               AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsnaMng\", \"TKIP failed!\", AIRPDCAP_DEBUG_LEVEL_3);\r\n               continue;\r\n           }\r\n\r\n           AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsnaMng\", \"TKIP DECRYPTED!!!\", AIRPDCAP_DEBUG_LEVEL_3);\r\n           /* remove MIC (8bytes) and ICV (4bytes) from the end of packet */\r\n           *decrypt_len-=12;\r\n           break;\r\n       } else {\r\n           /* AES-CCMP -> HMAC-SHA1-128 is the EAPOL-Key MIC, AES wep_key wrap is the EAPOL-Key encryption algorithm */\r\n           AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsnaMng\", \"CCMP\", AIRPDCAP_DEBUG_LEVEL_3);\r\n\r\n           ret_value=AirPDcapCcmpDecrypt(try_data, mac_header_len, (INT)*decrypt_len, AIRPDCAP_GET_TK(sa->wpa.ptk));\r\n           if (ret_value)\r\n              continue;\r\n\r\n           AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsnaMng\", \"CCMP DECRYPTED!!!\", AIRPDCAP_DEBUG_LEVEL_3);\r\n           /* remove MIC (8bytes) from the end of packet */\r\n           *decrypt_len-=8;\r\n           break;\r\n       }\r\n    }\r\n    /* end of loop */\r\n\r\n    /* none of the keys worked */\r\n    if(sa == NULL) {\r\n        g_free(try_data);\r\n        return ret_value;\r\n    }\r\n\r\n    if (*decrypt_len > try_data_len || *decrypt_len < 8) {\r\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsnaMng\", \"Invalid decryption length\", AIRPDCAP_DEBUG_LEVEL_3);\r\n        g_free(try_data);\r\n        return AIRPDCAP_RET_UNSUCCESS;\r\n    }\r\n\r\n    /* copy the decrypted data into the decrypt buffer GCS*/\r\n    memcpy(decrypt_data, try_data, *decrypt_len);\r\n    g_free(try_data);\r\n\r\n    /* remove protection bit */\r\n    decrypt_data[1]&=0xBF;\r\n\r\n    /* remove TKIP/CCMP header */\r\n    offset = mac_header_len;\r\n    *decrypt_len-=8;\r\n    memmove(decrypt_data+offset, decrypt_data+offset+8, *decrypt_len-offset);\r\n\r\n    if (key!=NULL) {\r\n        if (sa->key!=NULL)\r\n            memcpy(key, sa->key, sizeof(AIRPDCAP_KEY_ITEM));\r\n        else\r\n            memset(key, 0, sizeof(AIRPDCAP_KEY_ITEM));\r\n        memcpy(key->KeyData.Wpa.Ptk, sa->wpa.ptk, AIRPDCAP_WPA_PTK_LEN); /* copy the PTK to the key structure for future use by wireshark */\r\n        if (sa->wpa.key_ver==AIRPDCAP_WPA_KEY_VER_NOT_CCMP)\r\n            key->KeyType=AIRPDCAP_KEY_TYPE_TKIP;\r\n        else if (sa->wpa.key_ver==AIRPDCAP_WPA_KEY_VER_AES_CCMP)\r\n            key->KeyType=AIRPDCAP_KEY_TYPE_CCMP;\r\n    }\r\n\r\n    return AIRPDCAP_RET_SUCCESS;\r\n}", ".irPDcapInitContext": "INT AirPDcapInitContext(\r\n    PAIRPDCAP_CONTEXT ctx)\r\n{\r\n    AIRPDCAP_DEBUG_TRACE_START(\"AirPDcapInitContext\");\r\n\r\n    if (ctx==NULL) {\r\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapInitContext\", \"NULL context\", AIRPDCAP_DEBUG_LEVEL_5);\r\n        AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapInitContext\");\r\n        return AIRPDCAP_RET_UNSUCCESS;\r\n    }\r\n\r\n    AirPDcapCleanKeys(ctx);\r\n\r\n    ctx->first_free_index=0;\r\n    ctx->index=-1;\r\n    ctx->sa_index=-1;\r\n    ctx->pkt_ssid_len = 0;\r\n\r\n    memset(ctx->sa, 0, AIRPDCAP_MAX_SEC_ASSOCIATIONS_NR * sizeof(AIRPDCAP_SEC_ASSOCIATION));\r\n\r\n    AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapInitContext\", \"Context initialized!\", AIRPDCAP_DEBUG_LEVEL_5);\r\n    AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapInitContext\");\r\n    return AIRPDCAP_RET_SUCCESS;\r\n}", ".irPDcapValidateKey": "static INT\r\nAirPDcapValidateKey(\r\n    PAIRPDCAP_KEY_ITEM key)\r\n{\r\n    size_t len;\r\n    UCHAR ret=TRUE;\r\n    AIRPDCAP_DEBUG_TRACE_START(\"AirPDcapValidateKey\");\r\n\r\n    if (key==NULL) {\r\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapValidateKey\", \"NULL key\", AIRPDCAP_DEBUG_LEVEL_5);\r\n        AIRPDCAP_DEBUG_TRACE_START(\"AirPDcapValidateKey\");\r\n        return FALSE;\r\n    }\r\n\r\n    switch (key->KeyType) {\r\n        case AIRPDCAP_KEY_TYPE_WEP:\r\n            /* check key size limits */\r\n            len=key->KeyData.Wep.WepKeyLen;\r\n            if (len<AIRPDCAP_WEP_KEY_MINLEN || len>AIRPDCAP_WEP_KEY_MAXLEN) {\r\n                AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapValidateKey\", \"WEP key: key length not accepted\", AIRPDCAP_DEBUG_LEVEL_5);\r\n                ret=FALSE;\r\n            }\r\n            break;\r\n\r\n        case AIRPDCAP_KEY_TYPE_WEP_40:\r\n            /* set the standard length and use a generic WEP key type */\r\n            key->KeyData.Wep.WepKeyLen=AIRPDCAP_WEP_40_KEY_LEN;\r\n            key->KeyType=AIRPDCAP_KEY_TYPE_WEP;\r\n            break;\r\n\r\n        case AIRPDCAP_KEY_TYPE_WEP_104:\r\n            /* set the standard length and use a generic WEP key type */\r\n            key->KeyData.Wep.WepKeyLen=AIRPDCAP_WEP_104_KEY_LEN;\r\n            key->KeyType=AIRPDCAP_KEY_TYPE_WEP;\r\n            break;\r\n\r\n        case AIRPDCAP_KEY_TYPE_WPA_PWD:\r\n            /* check passphrase and SSID size limits */\r\n            len=strlen(key->UserPwd.Passphrase);\r\n            if (len<AIRPDCAP_WPA_PASSPHRASE_MIN_LEN || len>AIRPDCAP_WPA_PASSPHRASE_MAX_LEN) {\r\n                AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapValidateKey\", \"WPA-PWD key: passphrase length not accepted\", AIRPDCAP_DEBUG_LEVEL_5);\r\n                ret=FALSE;\r\n            }\r\n\r\n            len=key->UserPwd.SsidLen;\r\n            if (len>AIRPDCAP_WPA_SSID_MAX_LEN) {\r\n                AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapValidateKey\", \"WPA-PWD key: ssid length not accepted\", AIRPDCAP_DEBUG_LEVEL_5);\r\n                ret=FALSE;\r\n            }\r\n\r\n            break;\r\n\r\n        case AIRPDCAP_KEY_TYPE_WPA_PSK:\r\n            break;\r\n\r\n        case AIRPDCAP_KEY_TYPE_WPA_PMK:\r\n            break;\r\n\r\n        default:\r\n            ret=FALSE;\r\n    }\r\n\r\n    AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapValidateKey\");\r\n    return ret;\r\n}", ".irPDcapRsnaPwd2Psk": "static INT\r\nAirPDcapRsnaPwd2Psk(\r\n    const CHAR *passphrase,\r\n    const CHAR *ssid,\r\n    const size_t ssidLength,\r\n    UCHAR *output)\r\n{\r\n    UCHAR m_output[40] = { 0 };\r\n    GByteArray *pp_ba = g_byte_array_new();\r\n\r\n    if (!uri_str_to_bytes(passphrase, pp_ba)) {\r\n        g_byte_array_free(pp_ba, TRUE);\r\n        return 0;\r\n    }\r\n\r\n    AirPDcapRsnaPwd2PskStep(pp_ba->data, pp_ba->len, ssid, ssidLength, 4096, 1, m_output);\r\n    AirPDcapRsnaPwd2PskStep(pp_ba->data, pp_ba->len, ssid, ssidLength, 4096, 2, &m_output[20]);\r\n\r\n    memcpy(output, m_output, AIRPDCAP_WPA_PSK_LEN);\r\n    g_byte_array_free(pp_ba, TRUE);\r\n\r\n    return 0;\r\n}", ".irPDcapRecurseCleanSA": "static void\r\nAirPDcapRecurseCleanSA(\r\n    PAIRPDCAP_SEC_ASSOCIATION sa)\r\n{\r\n    if (sa->next != NULL) {\r\n        AirPDcapRecurseCleanSA(sa->next);\r\n        g_free(sa->next);\r\n        sa->next = NULL;\r\n    }\r\n}", ".irPDcapCleanKeys": "static void\r\nAirPDcapCleanKeys(\r\n    PAIRPDCAP_CONTEXT ctx)\r\n{\r\n    AIRPDCAP_DEBUG_TRACE_START(\"AirPDcapCleanKeys\");\r\n\r\n    if (ctx==NULL) {\r\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapCleanKeys\", \"NULL context\", AIRPDCAP_DEBUG_LEVEL_5);\r\n        AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapCleanKeys\");\r\n        return;\r\n    }\r\n\r\n    memset(ctx->keys, 0, sizeof(AIRPDCAP_KEY_ITEM) * AIRPDCAP_MAX_KEYS_NR);\r\n\r\n    ctx->keys_nr=0;\r\n\r\n    AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapCleanKeys\", \"Keys collection cleaned!\", AIRPDCAP_DEBUG_LEVEL_5);\r\n    AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapCleanKeys\");\r\n}", ".irPDcapCleanSecAssoc": "static void\r\nAirPDcapCleanSecAssoc(\r\n    PAIRPDCAP_CONTEXT ctx)\r\n{\r\n    PAIRPDCAP_SEC_ASSOCIATION psa;\r\n    int i;\r\n\r\n    for (psa = ctx->sa, i = 0; i < AIRPDCAP_MAX_SEC_ASSOCIATIONS_NR; i++, psa++) {\r\n        /* To iterate is human, to recurse, divine */\r\n        AirPDcapRecurseCleanSA(psa);\r\n    }\r\n}", ".irPDcapRsnaPrfX": "static void\r\nAirPDcapRsnaPrfX(\r\n    AIRPDCAP_SEC_ASSOCIATION *sa,\r\n    const UCHAR pmk[32],\r\n    const UCHAR snonce[32],\r\n    const INT x,        /*      for TKIP 512, for CCMP 384 */\r\n    UCHAR *ptk)\r\n{\r\n    UINT8 i;\r\n    UCHAR R[100];\r\n    INT offset=sizeof(\"Pairwise key expansion\");\r\n    UCHAR output[80]; /* allow for sha1 overflow. */\r\n\r\n    memset(R, 0, 100);\r\n\r\n    memcpy(R, \"Pairwise key expansion\", offset);\r\n\r\n    /* Min(AA, SPA) || Max(AA, SPA) */\r\n    if (memcmp(sa->saId.sta, sa->saId.bssid, AIRPDCAP_MAC_LEN) < 0)\r\n    {\r\n        memcpy(R + offset, sa->saId.sta, AIRPDCAP_MAC_LEN);\r\n        memcpy(R + offset+AIRPDCAP_MAC_LEN, sa->saId.bssid, AIRPDCAP_MAC_LEN);\r\n    }\r\n    else\r\n    {\r\n        memcpy(R + offset, sa->saId.bssid, AIRPDCAP_MAC_LEN);\r\n        memcpy(R + offset+AIRPDCAP_MAC_LEN, sa->saId.sta, AIRPDCAP_MAC_LEN);\r\n    }\r\n\r\n    offset+=AIRPDCAP_MAC_LEN*2;\r\n\r\n    /* Min(ANonce,SNonce) || Max(ANonce,SNonce) */\r\n    if( memcmp(snonce, sa->wpa.nonce, 32) < 0 )\r\n    {\r\n        memcpy(R + offset, snonce, 32);\r\n        memcpy(R + offset + 32, sa->wpa.nonce, 32);\r\n    }\r\n    else\r\n    {\r\n        memcpy(R + offset, sa->wpa.nonce, 32);\r\n        memcpy(R + offset + 32, snonce, 32);\r\n    }\r\n\r\n    offset+=32*2;\r\n\r\n    for(i = 0; i < (x+159)/160; i++)\r\n    {\r\n        R[offset] = i;\r\n        if (ws_hmac_buffer(GCRY_MD_SHA1, &output[HASH_SHA1_LENGTH * i], R, 100, pmk, 32)) {\r\n          return;\r\n        }\r\n    }\r\n    memcpy(ptk, output, x/8);\r\n}", ".irPDcapRsnaMicCheck": "static INT\r\nAirPDcapRsnaMicCheck(\r\n    UCHAR *eapol,\r\n    USHORT eapol_len,\r\n    UCHAR KCK[AIRPDCAP_WPA_KCK_LEN],\r\n    USHORT key_ver)\r\n{\r\n    UCHAR mic[AIRPDCAP_WPA_MICKEY_LEN];\r\n    UCHAR c_mic[HASH_SHA1_LENGTH] = { 0 };  /* MIC 16 byte, the HMAC-SHA1 use a buffer of 20 bytes */\r\n    int algo;\r\n\r\n    /* copy the MIC from the EAPOL packet */\r\n    memcpy(mic, eapol+AIRPDCAP_WPA_MICKEY_OFFSET+4, AIRPDCAP_WPA_MICKEY_LEN);\r\n\r\n    /* set to 0 the MIC in the EAPOL packet (to calculate the MIC) */\r\n    memset(eapol+AIRPDCAP_WPA_MICKEY_OFFSET+4, 0, AIRPDCAP_WPA_MICKEY_LEN);\r\n\r\n    if (key_ver==AIRPDCAP_WPA_KEY_VER_NOT_CCMP) {\r\n        /* use HMAC-MD5 for the EAPOL-Key MIC */\r\n        algo = GCRY_MD_MD5;\r\n    } else if (key_ver==AIRPDCAP_WPA_KEY_VER_AES_CCMP) {\r\n        /* use HMAC-SHA1-128 for the EAPOL-Key MIC */\r\n        algo = GCRY_MD_SHA1;\r\n    } else {\r\n        /* key descriptor version not recognized */\r\n        return AIRPDCAP_RET_UNSUCCESS;\r\n    }\r\n\r\n    if (ws_hmac_buffer(algo, c_mic, eapol, eapol_len, KCK, AIRPDCAP_WPA_KCK_LEN)) {\r\n        return AIRPDCAP_RET_UNSUCCESS;\r\n    }\r\n\r\n    /* compare calculated MIC with the Key MIC and return result (0 means success) */\r\n    return memcmp(mic, c_mic, AIRPDCAP_WPA_MICKEY_LEN);\r\n}", ".irPDcapRsnaPwd2PskStep": "static INT\r\nAirPDcapRsnaPwd2PskStep(\r\n    const guint8 *ppBytes,\r\n    const guint ppLength,\r\n    const CHAR *ssid,\r\n    const size_t ssidLength,\r\n    const INT iterations,\r\n    const INT count,\r\n    UCHAR *output)\r\n{\r\n    UCHAR digest[MAX_SSID_LENGTH+4] = { 0 };  /* SSID plus 4 bytes of count */\r\n    INT i, j;\r\n\r\n    if (ssidLength > MAX_SSID_LENGTH) {\r\n        /* This \"should not happen\" */\r\n        return AIRPDCAP_RET_UNSUCCESS;\r\n    }\r\n\r\n    /* U1 = PRF(P, S || INT(i)) */\r\n    memcpy(digest, ssid, ssidLength);\r\n    digest[ssidLength] = (UCHAR)((count>>24) & 0xff);\r\n    digest[ssidLength+1] = (UCHAR)((count>>16) & 0xff);\r\n    digest[ssidLength+2] = (UCHAR)((count>>8) & 0xff);\r\n    digest[ssidLength+3] = (UCHAR)(count & 0xff);\r\n    if (ws_hmac_buffer(GCRY_MD_SHA1, digest, digest, (guint32) ssidLength + 4, ppBytes, ppLength)) {\r\n      return AIRPDCAP_RET_UNSUCCESS;\r\n    }\r\n\r\n    /* output = U1 */\r\n    memcpy(output, digest, 20);\r\n    for (i = 1; i < iterations; i++) {\r\n        /* Un = PRF(P, Un-1) */\r\n        if (ws_hmac_buffer(GCRY_MD_SHA1, digest, digest, HASH_SHA1_LENGTH, ppBytes, ppLength)) {\r\n          return AIRPDCAP_RET_UNSUCCESS;\r\n        }\r\n\r\n        /* output = output xor Un */\r\n        for (j = 0; j < 20; j++) {\r\n            output[j] ^= digest[j];\r\n        }\r\n    }\r\n\r\n    return AIRPDCAP_RET_SUCCESS;\r\n}"}, "callee": {".irPDcapScanForKeys": "static INT AirPDcapScanForKeys(\r\n    PAIRPDCAP_CONTEXT ctx,\r\n    const guint8 *data,\r\n    const guint mac_header_len,\r\n    const guint tot_len,\r\n    AIRPDCAP_SEC_ASSOCIATION_ID id\r\n)\r\n{\r\n    const UCHAR *addr;\r\n    guint bodyLength;\r\n    PAIRPDCAP_SEC_ASSOCIATION sta_sa;\r\n    PAIRPDCAP_SEC_ASSOCIATION sa;\r\n    guint offset = 0;\r\n    const guint8 dot1x_header[] = {\r\n        0xAA,             /* DSAP=SNAP */\r\n        0xAA,             /* SSAP=SNAP */\r\n        0x03,             /* Control field=Unnumbered frame */\r\n        0x00, 0x00, 0x00, /* Org. code=encaps. Ethernet */\r\n        0x88, 0x8E        /* Type: 802.1X authentication */\r\n    };\r\n    const guint8 bt_dot1x_header[] = {\r\n        0xAA,             /* DSAP=SNAP */\r\n        0xAA,             /* SSAP=SNAP */\r\n        0x03,             /* Control field=Unnumbered frame */\r\n        0x00, 0x19, 0x58, /* Org. code=Bluetooth SIG */\r\n        0x00, 0x03        /* Type: Bluetooth Security */\r\n    };\r\n    const guint8 tdls_header[] = {\r\n        0xAA,             /* DSAP=SNAP */\r\n        0xAA,             /* SSAP=SNAP */\r\n        0x03,             /* Control field=Unnumbered frame */\r\n        0x00, 0x00, 0x00, /* Org. code=encaps. Ethernet */\r\n        0x89, 0x0D,       /* Type: 802.11 - Fast Roaming Remote Request */\r\n        0x02,             /* Payload Type: TDLS */\r\n        0X0C              /* Action Category: TDLS */\r\n    };\r\n\r\n    const EAPOL_RSN_KEY *pEAPKey;\r\n#ifdef AIRPDCAP_DEBUG\r\n#define MSGBUF_LEN 255\r\n    CHAR msgbuf[MSGBUF_LEN];\r\n#endif\r\n    AIRPDCAP_DEBUG_TRACE_START(\"AirPDcapScanForKeys\");\r\n\r\n    /* cache offset in the packet data */\r\n    offset = mac_header_len;\r\n\r\n    /* check if the packet has an LLC header and the packet is 802.1X authentication (IEEE 802.1X-2004, pg. 24) */\r\n    if (memcmp(data+offset, dot1x_header, 8) == 0 || memcmp(data+offset, bt_dot1x_header, 8) == 0) {\r\n\r\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Authentication: EAPOL packet\", AIRPDCAP_DEBUG_LEVEL_3);\r\n\r\n        /* skip LLC header */\r\n        offset+=8;\r\n\r\n        /* check if the packet is a EAPOL-Key (0x03) (IEEE 802.1X-2004, pg. 25) */\r\n        if (data[offset+1]!=3) {\r\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Not EAPOL-Key\", AIRPDCAP_DEBUG_LEVEL_3);\r\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\r\n        }\r\n\r\n        /* get and check the body length (IEEE 802.1X-2004, pg. 25) */\r\n        bodyLength=pntoh16(data+offset+2);\r\n        if (((tot_len-offset-4) < bodyLength) || (bodyLength < sizeof(EAPOL_RSN_KEY))) { /* Only check if frame is long enough for eapol header, ignore tailing garbage, see bug 9065 */\r\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"EAPOL body too short\", AIRPDCAP_DEBUG_LEVEL_3);\r\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\r\n        }\r\n\r\n        /* skip EAPOL MPDU and go to the first byte of the body */\r\n        offset+=4;\r\n\r\n        pEAPKey = (const EAPOL_RSN_KEY *) (data+offset);\r\n\r\n        /* check if the key descriptor type is valid (IEEE 802.1X-2004, pg. 27) */\r\n        if (/*pEAPKey->type!=0x1 &&*/ /* RC4 Key Descriptor Type (deprecated) */\r\n            pEAPKey->type != AIRPDCAP_RSN_WPA2_KEY_DESCRIPTOR &&             /* IEEE 802.11 Key Descriptor Type  (WPA2) */\r\n            pEAPKey->type != AIRPDCAP_RSN_WPA_KEY_DESCRIPTOR)           /* 254 = RSN_KEY_DESCRIPTOR - WPA,              */\r\n        {\r\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Not valid key descriptor type\", AIRPDCAP_DEBUG_LEVEL_3);\r\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\r\n        }\r\n\r\n        /* start with descriptor body */\r\n        offset+=1;\r\n\r\n        /* search for a cached Security Association for current BSSID and AP */\r\n        sa = AirPDcapGetSaPtr(ctx, &id);\r\n        if (sa == NULL){\r\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"No SA for BSSID found\", AIRPDCAP_DEBUG_LEVEL_3);\r\n            return AIRPDCAP_RET_REQ_DATA;\r\n        }\r\n\r\n        /* It could be a Pairwise Key exchange, check */\r\n        if (AirPDcapRsna4WHandshake(ctx, data, sa, offset, tot_len) == AIRPDCAP_RET_SUCCESS_HANDSHAKE)\r\n            return AIRPDCAP_RET_SUCCESS_HANDSHAKE;\r\n\r\n        if (mac_header_len + GROUP_KEY_PAYLOAD_LEN_MIN > tot_len) {\r\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Message too short for Group Key\", AIRPDCAP_DEBUG_LEVEL_3);\r\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\r\n        }\r\n\r\n        /* Verify the bitfields: Key = 0(groupwise) Mic = 1 Ack = 1 Secure = 1 */\r\n        if (AIRPDCAP_EAP_KEY(data[offset+1])!=0 ||\r\n            AIRPDCAP_EAP_ACK(data[offset+1])!=1 ||\r\n            AIRPDCAP_EAP_MIC(data[offset]) != 1 ||\r\n            AIRPDCAP_EAP_SEC(data[offset]) != 1){\r\n\r\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Key bitfields not correct for Group Key\", AIRPDCAP_DEBUG_LEVEL_3);\r\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\r\n        }\r\n\r\n        /* force STA address to be the broadcast MAC so we create an SA for the groupkey */\r\n        memcpy(id.sta, broadcast_mac, AIRPDCAP_MAC_LEN);\r\n\r\n        /* get the Security Association structure for the broadcast MAC and AP */\r\n        sa = AirPDcapGetSaPtr(ctx, &id);\r\n        if (sa == NULL){\r\n            return AIRPDCAP_RET_REQ_DATA;\r\n        }\r\n\r\n        /* Get the SA for the STA, since we need its pairwise key to decrpyt the group key */\r\n\r\n        /* get STA address */\r\n        if ( (addr=AirPDcapGetStaAddress((const AIRPDCAP_MAC_FRAME_ADDR4 *)(data))) != NULL) {\r\n            memcpy(id.sta, addr, AIRPDCAP_MAC_LEN);\r\n#ifdef AIRPDCAP_DEBUG\r\n            g_snprintf(msgbuf, MSGBUF_LEN, \"ST_MAC: %2X.%2X.%2X.%2X.%2X.%2X\\t\", id.sta[0],id.sta[1],id.sta[2],id.sta[3],id.sta[4],id.sta[5]);\r\n#endif\r\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", msgbuf, AIRPDCAP_DEBUG_LEVEL_3);\r\n        } else {\r\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"SA not found\", AIRPDCAP_DEBUG_LEVEL_5);\r\n            return AIRPDCAP_RET_REQ_DATA;\r\n        }\r\n\r\n        sta_sa = AirPDcapGetSaPtr(ctx, &id);\r\n        if (sta_sa == NULL){\r\n            return AIRPDCAP_RET_REQ_DATA;\r\n        }\r\n\r\n        /* Try to extract the group key and install it in the SA */\r\n        return (AirPDcapDecryptWPABroadcastKey(pEAPKey, sta_sa->wpa.ptk+16, sa, tot_len-offset+1));\r\n\r\n    } else if (memcmp(data+offset, tdls_header, 10) == 0) {\r\n        const guint8 *initiator, *responder;\r\n        guint8 action;\r\n        guint status, offset_rsne = 0, offset_fte = 0, offset_link = 0, offset_timeout = 0;\r\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Authentication: TDLS Action Frame\", AIRPDCAP_DEBUG_LEVEL_3);\r\n\r\n        /* skip LLC header */\r\n        offset+=10;\r\n\r\n        /* check if the packet is a TDLS response or confirm */\r\n        action = data[offset];\r\n        if (action!=1 && action!=2) {\r\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Not Response nor confirm\", AIRPDCAP_DEBUG_LEVEL_3);\r\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\r\n        }\r\n\r\n        /* check status */\r\n        offset++;\r\n        status=pntoh16(data+offset);\r\n        if (status!=0) {\r\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"TDLS setup not successfull\", AIRPDCAP_DEBUG_LEVEL_3);\r\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\r\n        }\r\n\r\n        /* skip Token + capabilities */\r\n        offset+=5;\r\n\r\n        /* search for RSN, Fast BSS Transition, Link Identifier and Timeout Interval IEs */\r\n\r\n        while(offset < (tot_len - 2)) {\r\n            if (data[offset] == 48) {\r\n                offset_rsne = offset;\r\n            } else if (data[offset] == 55) {\r\n                offset_fte = offset;\r\n            } else if (data[offset] == 56) {\r\n                offset_timeout = offset;\r\n            } else if (data[offset] == 101) {\r\n                offset_link = offset;\r\n            }\r\n\r\n            if (tot_len < offset + data[offset + 1] + 2) {\r\n                return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\r\n            }\r\n            offset += data[offset + 1] + 2;\r\n        }\r\n\r\n        if (offset_rsne == 0 || offset_fte == 0 ||\r\n            offset_timeout == 0 || offset_link == 0)\r\n        {\r\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Cannot Find all necessary IEs\", AIRPDCAP_DEBUG_LEVEL_3);\r\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\r\n        }\r\n\r\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Found RSNE/Fast BSS/Timeout Interval/Link IEs\", AIRPDCAP_DEBUG_LEVEL_3);\r\n\r\n        /* Will create a Security Association between 2 STA. Need to get both MAC address */\r\n        initiator = &data[offset_link + 8];\r\n        responder = &data[offset_link + 14];\r\n\r\n        if (memcmp(initiator, responder, AIRPDCAP_MAC_LEN) < 0) {\r\n            memcpy(id.sta, initiator, AIRPDCAP_MAC_LEN);\r\n            memcpy(id.bssid, responder, AIRPDCAP_MAC_LEN);\r\n        } else {\r\n            memcpy(id.sta, responder, AIRPDCAP_MAC_LEN);\r\n            memcpy(id.bssid, initiator, AIRPDCAP_MAC_LEN);\r\n        }\r\n\r\n        sa = AirPDcapGetSaPtr(ctx, &id);\r\n        if (sa == NULL){\r\n            return AIRPDCAP_RET_REQ_DATA;\r\n        }\r\n\r\n        if (sa->validKey) {\r\n            if (memcmp(sa->wpa.nonce, data + offset_fte + 52, AIRPDCAP_WPA_NONCE_LEN) == 0) {\r\n                /* Already have valid key for this SA, no need to redo key derivation */\r\n                return AIRPDCAP_RET_SUCCESS_HANDSHAKE;\r\n            } else {\r\n                /* We are opening a new session with the same two STA, save previous sa  */\r\n                AIRPDCAP_SEC_ASSOCIATION *tmp_sa = g_new(AIRPDCAP_SEC_ASSOCIATION, 1);\r\n                memcpy(tmp_sa, sa, sizeof(AIRPDCAP_SEC_ASSOCIATION));\r\n                sa->next=tmp_sa;\r\n                sa->validKey = FALSE;\r\n            }\r\n        }\r\n\r\n        if (AirPDcapTDLSDeriveKey(sa, data, offset_rsne, offset_fte, offset_timeout, offset_link, action)\r\n            == AIRPDCAP_RET_SUCCESS) {\r\n            AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapScanForKeys\");\r\n            return AIRPDCAP_RET_SUCCESS_HANDSHAKE;\r\n        }\r\n    } else {\r\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Skipping: not an EAPOL packet\", AIRPDCAP_DEBUG_LEVEL_3);\r\n    }\r\n\r\n    AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapScanForKeys\");\r\n    return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\r\n}", ".irPDcapRsna4WHandshake": "static INT\r\nAirPDcapRsna4WHandshake(\r\n    PAIRPDCAP_CONTEXT ctx,\r\n    const UCHAR *data,\r\n    AIRPDCAP_SEC_ASSOCIATION *sa,\r\n    INT offset,\r\n    const guint tot_len)\r\n{\r\n    AIRPDCAP_KEY_ITEM *tmp_key, *tmp_pkt_key, pkt_key;\r\n    AIRPDCAP_SEC_ASSOCIATION *tmp_sa;\r\n    INT key_index;\r\n    INT ret_value=1;\r\n    UCHAR useCache=FALSE;\r\n    UCHAR eapol[AIRPDCAP_EAPOL_MAX_LEN];\r\n    USHORT eapol_len;\r\n\r\n    if (sa->key!=NULL)\r\n        useCache=TRUE;\r\n\r\n    /* a 4-way handshake packet use a Pairwise key type (IEEE 802.11i-2004, pg. 79) */\r\n    if (AIRPDCAP_EAP_KEY(data[offset+1])!=1) {\r\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsna4WHandshake\", \"Group/STAKey message (not used)\", AIRPDCAP_DEBUG_LEVEL_5);\r\n        return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\r\n    }\r\n\r\n    /* TODO timeouts? */\r\n\r\n    /* TODO consider key-index */\r\n\r\n    /* TODO considera Deauthentications */\r\n\r\n    AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsna4WHandshake\", \"4-way handshake...\", AIRPDCAP_DEBUG_LEVEL_5);\r\n\r\n    /* manage 4-way handshake packets; this step completes the 802.1X authentication process (IEEE 802.11i-2004, pag. 85) */\r\n\r\n    /* message 1: Authenticator->Supplicant (Sec=0, Mic=0, Ack=1, Inst=0, Key=1(pairwise), KeyRSC=0, Nonce=ANonce, MIC=0) */\r\n    if (AIRPDCAP_EAP_INST(data[offset+1])==0 &&\r\n        AIRPDCAP_EAP_ACK(data[offset+1])==1 &&\r\n        AIRPDCAP_EAP_MIC(data[offset])==0)\r\n    {\r\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsna4WHandshake\", \"4-way handshake message 1\", AIRPDCAP_DEBUG_LEVEL_3);\r\n\r\n        /* On reception of Message 1, the Supplicant determines whether the Key Replay Counter field value has been        */\r\n        /* used before with the current PMKSA. If the Key Replay Counter field value is less than or equal to the current  */\r\n        /* local value, the Supplicant discards the message.                                                               */\r\n        /* -> not checked, the Authenticator will be send another Message 1 (hopefully!)                                   */\r\n\r\n        /* This saves the sa since we are reauthenticating which will overwrite our current sa GCS*/\r\n        if( sa->handshake >= 2) {\r\n            tmp_sa= g_new(AIRPDCAP_SEC_ASSOCIATION, 1);\r\n            memcpy(tmp_sa, sa, sizeof(AIRPDCAP_SEC_ASSOCIATION));\r\n            sa->validKey=FALSE;\r\n            sa->next=tmp_sa;\r\n        }\r\n\r\n        /* save ANonce (from authenticator) to derive the PTK with the SNonce (from the 2 message) */\r\n        memcpy(sa->wpa.nonce, data+offset+12, 32);\r\n\r\n        /* get the Key Descriptor Version (to select algorithm used in decryption -CCMP or TKIP-) */\r\n        sa->wpa.key_ver=AIRPDCAP_EAP_KEY_DESCR_VER(data[offset+1]);\r\n\r\n        sa->handshake=1;\r\n\r\n        return AIRPDCAP_RET_SUCCESS_HANDSHAKE;\r\n    }\r\n\r\n    /* message 2|4: Supplicant->Authenticator (Sec=0|1, Mic=1, Ack=0, Inst=0, Key=1(pairwise), KeyRSC=0, Nonce=SNonce|0, MIC=MIC(KCK,EAPOL)) */\r\n    if (AIRPDCAP_EAP_INST(data[offset+1])==0 &&\r\n        AIRPDCAP_EAP_ACK(data[offset+1])==0 &&\r\n        AIRPDCAP_EAP_MIC(data[offset])==1)\r\n    {\r\n        /* Check key data length to differentiate between message 2 or 4, same as in epan/dissectors/packet-ieee80211.c */\r\n        if (pntoh16(data+offset+92)) {\r\n            /* message 2 */\r\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsna4WHandshake\", \"4-way handshake message 2\", AIRPDCAP_DEBUG_LEVEL_3);\r\n\r\n            /* On reception of Message 2, the Authenticator checks that the key replay counter corresponds to the */\r\n            /* outstanding Message 1. If not, it silently discards the message.                                   */\r\n            /* If the calculated MIC does not match the MIC that the Supplicant included in the EAPOL-Key frame,  */\r\n            /* the Authenticator silently discards Message 2.                                                     */\r\n            /* -> not checked; the Supplicant will send another message 2 (hopefully!)                            */\r\n\r\n            /* now you can derive the PTK */\r\n            for (key_index=0; key_index<(INT)ctx->keys_nr || useCache; key_index++) {\r\n                /* use the cached one, or try all keys */\r\n                if (!useCache) {\r\n                    AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsna4WHandshake\", \"Try WPA key...\", AIRPDCAP_DEBUG_LEVEL_3);\r\n                    tmp_key=&ctx->keys[key_index];\r\n                } else {\r\n                    /* there is a cached key in the security association, if it's a WPA key try it... */\r\n                    if (sa->key!=NULL &&\r\n                        (sa->key->KeyType==AIRPDCAP_KEY_TYPE_WPA_PWD ||\r\n                         sa->key->KeyType==AIRPDCAP_KEY_TYPE_WPA_PSK ||\r\n                         sa->key->KeyType==AIRPDCAP_KEY_TYPE_WPA_PMK)) {\r\n                            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsna4WHandshake\", \"Try cached WPA key...\", AIRPDCAP_DEBUG_LEVEL_3);\r\n                            tmp_key=sa->key;\r\n                    } else {\r\n                        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsna4WHandshake\", \"Cached key is of a wrong type, try WPA key...\", AIRPDCAP_DEBUG_LEVEL_3);\r\n                        tmp_key=&ctx->keys[key_index];\r\n                    }\r\n                }\r\n\r\n                /* obviously, try only WPA keys... */\r\n                if (tmp_key->KeyType==AIRPDCAP_KEY_TYPE_WPA_PWD ||\r\n                    tmp_key->KeyType==AIRPDCAP_KEY_TYPE_WPA_PSK ||\r\n                    tmp_key->KeyType==AIRPDCAP_KEY_TYPE_WPA_PMK)\r\n                {\r\n                    if (tmp_key->KeyType == AIRPDCAP_KEY_TYPE_WPA_PWD && tmp_key->UserPwd.SsidLen == 0 && ctx->pkt_ssid_len > 0 && ctx->pkt_ssid_len <= AIRPDCAP_WPA_SSID_MAX_LEN) {\r\n                        /* We have a \"wildcard\" SSID.  Use the one from the packet. */\r\n                        memcpy(&pkt_key, tmp_key, sizeof(pkt_key));\r\n                        memcpy(&pkt_key.UserPwd.Ssid, ctx->pkt_ssid, ctx->pkt_ssid_len);\r\n                         pkt_key.UserPwd.SsidLen = ctx->pkt_ssid_len;\r\n                        AirPDcapRsnaPwd2Psk(pkt_key.UserPwd.Passphrase, pkt_key.UserPwd.Ssid,\r\n                            pkt_key.UserPwd.SsidLen, pkt_key.KeyData.Wpa.Psk);\r\n                        tmp_pkt_key = &pkt_key;\r\n                    } else {\r\n                        tmp_pkt_key = tmp_key;\r\n                    }\r\n\r\n                    /* derive the PTK from the BSSID, STA MAC, PMK, SNonce, ANonce */\r\n                    AirPDcapRsnaPrfX(sa,                            /* authenticator nonce, bssid, station mac */\r\n                                     tmp_pkt_key->KeyData.Wpa.Psk,      /* PSK == PMK */\r\n                                     data+offset+12,                /* supplicant nonce */\r\n                                     512,\r\n                                     sa->wpa.ptk);\r\n\r\n                    /* verify the MIC (compare the MIC in the packet included in this message with a MIC calculated with the PTK) */\r\n                    eapol_len=pntoh16(data+offset-3)+4;\r\n                    memcpy(eapol, &data[offset-5], (eapol_len<AIRPDCAP_EAPOL_MAX_LEN?eapol_len:AIRPDCAP_EAPOL_MAX_LEN));\r\n                    ret_value=AirPDcapRsnaMicCheck(eapol,           /*      eapol frame (header also) */\r\n                                                   eapol_len,       /*      eapol frame length        */\r\n                                                   sa->wpa.ptk,     /*      Key Confirmation Key      */\r\n                                                   AIRPDCAP_EAP_KEY_DESCR_VER(data[offset+1])); /*  EAPOL-Key description version */\r\n\r\n                    /* If the MIC is valid, the Authenticator checks that the RSN information element bit-wise matches       */\r\n                    /* that from the (Re)Association Request message.                                                        */\r\n                    /*              i) TODO If these are not exactly the same, the Authenticator uses MLME-DEAUTHENTICATE.request */\r\n                    /* primitive to terminate the association.                                                               */\r\n                    /*              ii) If they do match bit-wise, the Authenticator constructs Message 3.                   */\r\n                }\r\n\r\n                if (!ret_value &&\r\n                    (tmp_key->KeyType==AIRPDCAP_KEY_TYPE_WPA_PWD ||\r\n                    tmp_key->KeyType==AIRPDCAP_KEY_TYPE_WPA_PSK ||\r\n                    tmp_key->KeyType==AIRPDCAP_KEY_TYPE_WPA_PMK))\r\n                {\r\n                    /* the temporary key is the correct one, cached in the Security Association */\r\n\r\n                    sa->key=tmp_key;\r\n                    break;\r\n                } else {\r\n                    /* the cached key was not valid, try other keys */\r\n\r\n                    if (useCache==TRUE) {\r\n                        useCache=FALSE;\r\n                        key_index--;\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (ret_value) {\r\n                AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsna4WHandshake\", \"handshake step failed\", AIRPDCAP_DEBUG_LEVEL_3);\r\n                return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\r\n            }\r\n\r\n            sa->handshake=2;\r\n            sa->validKey=TRUE; /* we can use the key to decode, even if we have not captured the other eapol packets */\r\n\r\n            return AIRPDCAP_RET_SUCCESS_HANDSHAKE;\r\n        } else {\r\n        /* message 4 */\r\n\r\n            /* TODO \"Note that when the 4-Way Handshake is first used Message 4 is sent in the clear.\" */\r\n\r\n            /* TODO check MIC and Replay Counter                                                                     */\r\n            /* On reception of Message 4, the Authenticator verifies that the Key Replay Counter field value is one  */\r\n            /* that it used on this 4-Way Handshake; if it is not, it silently discards the message.                 */\r\n            /* If the calculated MIC does not match the MIC that the Supplicant included in the EAPOL-Key frame, the */\r\n            /* Authenticator silently discards Message 4.                                                            */\r\n\r\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsna4WHandshake\", \"4-way handshake message 4\", AIRPDCAP_DEBUG_LEVEL_3);\r\n\r\n            sa->handshake=4;\r\n\r\n            return AIRPDCAP_RET_SUCCESS_HANDSHAKE;\r\n        }\r\n    }\r\n\r\n    /* message 3: Authenticator->Supplicant (Sec=1, Mic=1, Ack=1, Inst=0/1, Key=1(pairwise), KeyRSC=???, Nonce=ANonce, MIC=1) */\r\n    if (AIRPDCAP_EAP_ACK(data[offset+1])==1 &&\r\n        AIRPDCAP_EAP_MIC(data[offset])==1)\r\n    {\r\n        const EAPOL_RSN_KEY *pEAPKey;\r\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsna4WHandshake\", \"4-way handshake message 3\", AIRPDCAP_DEBUG_LEVEL_3);\r\n\r\n        /* On reception of Message 3, the Supplicant silently discards the message if the Key Replay Counter field     */\r\n        /* value has already been used or if the ANonce value in Message 3 differs from the ANonce value in Message 1. */\r\n        /* -> not checked, the Authenticator will send another message 3 (hopefully!)                                  */\r\n\r\n        /* TODO check page 88 (RNS) */\r\n\r\n        /* If using WPA2 PSK, message 3 will contain an RSN for the group key (GTK KDE).\r\n           In order to properly support decrypting WPA2-PSK packets, we need to parse this to get the group key. */\r\n        pEAPKey = (const EAPOL_RSN_KEY *)(&(data[offset-1]));\r\n        if (pEAPKey->type == AIRPDCAP_RSN_WPA2_KEY_DESCRIPTOR){\r\n            PAIRPDCAP_SEC_ASSOCIATION broadcast_sa;\r\n            AIRPDCAP_SEC_ASSOCIATION_ID id;\r\n\r\n            /* Get broadcacst SA for the current BSSID */\r\n            memcpy(id.sta, broadcast_mac, AIRPDCAP_MAC_LEN);\r\n            memcpy(id.bssid, sa->saId.bssid, AIRPDCAP_MAC_LEN);\r\n            broadcast_sa = AirPDcapGetSaPtr(ctx, &id);\r\n\r\n            if (broadcast_sa == NULL){\r\n                return AIRPDCAP_RET_REQ_DATA;\r\n            }\r\n            return (AirPDcapDecryptWPABroadcastKey(pEAPKey, sa->wpa.ptk+16, broadcast_sa, tot_len-offset+1));\r\n        }\r\n    }\r\n\r\n    return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\r\n}", ".irPDcapPacketProcess": "INT AirPDcapPacketProcess(\r\n    PAIRPDCAP_CONTEXT ctx,\r\n    const guint8 *data,\r\n    const guint mac_header_len,\r\n    const guint tot_len,\r\n    UCHAR *decrypt_data,\r\n    guint *decrypt_len,\r\n    PAIRPDCAP_KEY_ITEM key,\r\n    gboolean scanHandshake)\r\n{\r\n    AIRPDCAP_SEC_ASSOCIATION_ID id;\r\n    UCHAR tmp_data[AIRPDCAP_MAX_CAPLEN];\r\n    guint tmp_len;\r\n\r\n#ifdef AIRPDCAP_DEBUG\r\n#define MSGBUF_LEN 255\r\n    CHAR msgbuf[MSGBUF_LEN];\r\n#endif\r\n\r\n    AIRPDCAP_DEBUG_TRACE_START(\"AirPDcapPacketProcess\");\r\n\r\n    if (ctx==NULL) {\r\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapPacketProcess\", \"NULL context\", AIRPDCAP_DEBUG_LEVEL_5);\r\n        AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapPacketProcess\");\r\n        return AIRPDCAP_RET_REQ_DATA;\r\n    }\r\n    if (data==NULL || tot_len==0) {\r\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapPacketProcess\", \"NULL data or length=0\", AIRPDCAP_DEBUG_LEVEL_5);\r\n        AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapPacketProcess\");\r\n        return AIRPDCAP_RET_REQ_DATA;\r\n    }\r\n\r\n    /* check if the packet is of data or robust managment type */\r\n    if (!((AIRPDCAP_TYPE(data[0])==AIRPDCAP_TYPE_DATA) ||\r\n          (AIRPDCAP_TYPE(data[0])==AIRPDCAP_TYPE_MANAGEMENT &&\r\n           (AIRPDCAP_SUBTYPE(data[0])==AIRPDCAP_SUBTYPE_DISASS ||\r\n            AIRPDCAP_SUBTYPE(data[0])==AIRPDCAP_SUBTYPE_DEAUTHENTICATION ||\r\n            AIRPDCAP_SUBTYPE(data[0])==AIRPDCAP_SUBTYPE_ACTION)))) {\r\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapPacketProcess\", \"not data nor robust mgmt packet\", AIRPDCAP_DEBUG_LEVEL_5);\r\n        return AIRPDCAP_RET_NO_DATA;\r\n    }\r\n\r\n    /* check correct packet size, to avoid wrong elaboration of encryption algorithms */\r\n    if (tot_len < (UINT)(mac_header_len+AIRPDCAP_CRYPTED_DATA_MINLEN)) {\r\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapPacketProcess\", \"minimum length violated\", AIRPDCAP_DEBUG_LEVEL_5);\r\n        return AIRPDCAP_RET_WRONG_DATA_SIZE;\r\n    }\r\n\r\n    /* Assume that the decrypt_data field is at least this size. */\r\n    if (tot_len > AIRPDCAP_MAX_CAPLEN) {\r\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapPacketProcess\", \"length too large\", AIRPDCAP_DEBUG_LEVEL_3);\r\n        return AIRPDCAP_RET_UNSUCCESS;\r\n    }\r\n\r\n    /* get STA/BSSID address */\r\n    if (AirPDcapGetSaAddress((const AIRPDCAP_MAC_FRAME_ADDR4 *)(data), &id) != AIRPDCAP_RET_SUCCESS) {\r\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapPacketProcess\", \"STA/BSSID not found\", AIRPDCAP_DEBUG_LEVEL_5);\r\n        return AIRPDCAP_RET_REQ_DATA;\r\n    }\r\n\r\n    /* check if data is encrypted (use the WEP bit in the Frame Control field) */\r\n    if (AIRPDCAP_WEP(data[1])==0) {\r\n        if (scanHandshake) {\r\n            /* data is sent in cleartext, check if is an authentication message or end the process */\r\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapPacketProcess\", \"Unencrypted data\", AIRPDCAP_DEBUG_LEVEL_3);\r\n            return (AirPDcapScanForKeys(ctx, data, mac_header_len, tot_len, id));\r\n        }\r\n        return AIRPDCAP_RET_NO_DATA_ENCRYPTED;\r\n    } else {\r\n        PAIRPDCAP_SEC_ASSOCIATION sa;\r\n        int offset = 0;\r\n\r\n        /* get the Security Association structure for the STA and AP */\r\n        sa = AirPDcapGetSaPtr(ctx, &id);\r\n        if (sa == NULL){\r\n            return AIRPDCAP_RET_REQ_DATA;\r\n        }\r\n\r\n        /* cache offset in the packet data (to scan encryption data) */\r\n        offset = mac_header_len;\r\n\r\n        if (decrypt_data==NULL) {\r\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapPacketProcess\", \"no decrypt buffer, use local\", AIRPDCAP_DEBUG_LEVEL_3);\r\n            decrypt_data=tmp_data;\r\n            decrypt_len=&tmp_len;\r\n        }\r\n\r\n        /* create new header and data to modify */\r\n        *decrypt_len = tot_len;\r\n        memcpy(decrypt_data, data, *decrypt_len);\r\n\r\n        /* encrypted data */\r\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapPacketProcess\", \"Encrypted data\", AIRPDCAP_DEBUG_LEVEL_3);\r\n\r\n        /* check the Extension IV to distinguish between WEP encryption and WPA encryption */\r\n        /* refer to IEEE 802.11i-2004, 8.2.1.2, pag.35 for WEP,    */\r\n        /*          IEEE 802.11i-2004, 8.3.2.2, pag. 45 for TKIP,  */\r\n        /*          IEEE 802.11i-2004, 8.3.3.2, pag. 57 for CCMP   */\r\n        if (AIRPDCAP_EXTIV(data[offset+3])==0) {\r\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapPacketProcess\", \"WEP encryption\", AIRPDCAP_DEBUG_LEVEL_3);\r\n            return AirPDcapWepMng(ctx, decrypt_data, mac_header_len, decrypt_len, key, sa, offset);\r\n        } else {\r\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapPacketProcess\", \"TKIP or CCMP encryption\", AIRPDCAP_DEBUG_LEVEL_3);\r\n\r\n            /* If index >= 1, then use the group key.  This will not work if the AP is using\r\n               more than one group key simultaneously.  I've not seen this in practice, however.\r\n               Usually an AP will rotate between the two key index values of 1 and 2 whenever\r\n               it needs to change the group key to be used. */\r\n            if (AIRPDCAP_KEY_INDEX(data[offset+3])>=1){\r\n\r\n                AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapPacketProcess\", \"The key index >= 1. This is encrypted with a group key.\", AIRPDCAP_DEBUG_LEVEL_3);\r\n\r\n                /* force STA address to broadcast MAC so we load the SA for the groupkey */\r\n                memcpy(id.sta, broadcast_mac, AIRPDCAP_MAC_LEN);\r\n\r\n#ifdef AIRPDCAP_DEBUG\r\n                g_snprintf(msgbuf, MSGBUF_LEN, \"ST_MAC: %2X.%2X.%2X.%2X.%2X.%2X\\t\", id.sta[0],id.sta[1],id.sta[2],id.sta[3],id.sta[4],id.sta[5]);\r\n                AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapPacketProcess\", msgbuf, AIRPDCAP_DEBUG_LEVEL_3);\r\n#endif\r\n\r\n                /* search for a cached Security Association for current BSSID and broadcast MAC */\r\n                sa = AirPDcapGetSaPtr(ctx, &id);\r\n                if (sa == NULL)\r\n                    return AIRPDCAP_RET_REQ_DATA;\r\n            }\r\n\r\n            /* Decrypt the packet using the appropriate SA */\r\n            if (AirPDcapRsnaMng(decrypt_data, mac_header_len, decrypt_len, key, sa, offset) == AIRPDCAP_RET_SUCCESS) {\r\n                /* If we successfully decrypted a packet, scan it to see if it contains a key handshake.\r\n                   The group key handshake could be sent at any time the AP wants to change the key (such as when\r\n                   it is using key rotation) and it also could be a rekey for the Pairwise key. So we must scan every packet. */\r\n                if (scanHandshake) {\r\n                    return (AirPDcapScanForKeys(ctx, decrypt_data, mac_header_len, *decrypt_len, id));\r\n                } else {\r\n                    return AIRPDCAP_RET_SUCCESS;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return AIRPDCAP_RET_UNSUCCESS;\r\n}", ".irPDcapInitContext": "INT AirPDcapInitContext(\r\n    PAIRPDCAP_CONTEXT ctx)\r\n{\r\n    AIRPDCAP_DEBUG_TRACE_START(\"AirPDcapInitContext\");\r\n\r\n    if (ctx==NULL) {\r\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapInitContext\", \"NULL context\", AIRPDCAP_DEBUG_LEVEL_5);\r\n        AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapInitContext\");\r\n        return AIRPDCAP_RET_UNSUCCESS;\r\n    }\r\n\r\n    AirPDcapCleanKeys(ctx);\r\n\r\n    ctx->first_free_index=0;\r\n    ctx->index=-1;\r\n    ctx->sa_index=-1;\r\n    ctx->pkt_ssid_len = 0;\r\n\r\n    memset(ctx->sa, 0, AIRPDCAP_MAX_SEC_ASSOCIATIONS_NR * sizeof(AIRPDCAP_SEC_ASSOCIATION));\r\n\r\n    AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapInitContext\", \"Context initialized!\", AIRPDCAP_DEBUG_LEVEL_5);\r\n    AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapInitContext\");\r\n    return AIRPDCAP_RET_SUCCESS;\r\n}", ".irPDcapDestroyContext": "INT AirPDcapDestroyContext(\r\n    PAIRPDCAP_CONTEXT ctx)\r\n{\r\n    AIRPDCAP_DEBUG_TRACE_START(\"AirPDcapDestroyContext\");\r\n\r\n    if (ctx==NULL) {\r\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapDestroyContext\", \"NULL context\", AIRPDCAP_DEBUG_LEVEL_5);\r\n        AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapDestroyContext\");\r\n        return AIRPDCAP_RET_UNSUCCESS;\r\n    }\r\n\r\n    AirPDcapCleanKeys(ctx);\r\n    AirPDcapCleanSecAssoc(ctx);\r\n\r\n    ctx->first_free_index=0;\r\n    ctx->index=-1;\r\n    ctx->sa_index=-1;\r\n\r\n    AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapDestroyContext\", \"Context destroyed!\", AIRPDCAP_DEBUG_LEVEL_5);\r\n    AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapDestroyContext\");\r\n    return AIRPDCAP_RET_SUCCESS;\r\n}", ".irPDcapCleanSecAssoc": "static void\r\nAirPDcapCleanSecAssoc(\r\n    PAIRPDCAP_CONTEXT ctx)\r\n{\r\n    PAIRPDCAP_SEC_ASSOCIATION psa;\r\n    int i;\r\n\r\n    for (psa = ctx->sa, i = 0; i < AIRPDCAP_MAX_SEC_ASSOCIATIONS_NR; i++, psa++) {\r\n        /* To iterate is human, to recurse, divine */\r\n        AirPDcapRecurseCleanSA(psa);\r\n    }\r\n}", ".irPDcapSetKeys": "INT AirPDcapSetKeys(\r\n    PAIRPDCAP_CONTEXT ctx,\r\n    AIRPDCAP_KEY_ITEM keys[],\r\n    const size_t keys_nr)\r\n{\r\n    INT i;\r\n    INT success;\r\n    AIRPDCAP_DEBUG_TRACE_START(\"AirPDcapSetKeys\");\r\n\r\n    if (ctx==NULL || keys==NULL) {\r\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapSetKeys\", \"NULL context or NULL keys array\", AIRPDCAP_DEBUG_LEVEL_3);\r\n        AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapSetKeys\");\r\n        return 0;\r\n    }\r\n\r\n    if (keys_nr>AIRPDCAP_MAX_KEYS_NR) {\r\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapSetKeys\", \"Keys number greater than maximum\", AIRPDCAP_DEBUG_LEVEL_3);\r\n        AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapSetKeys\");\r\n        return 0;\r\n    }\r\n\r\n    /* clean key and SA collections before setting new ones */\r\n    AirPDcapInitContext(ctx);\r\n\r\n    /* check and insert keys */\r\n    for (i=0, success=0; i<(INT)keys_nr; i++) {\r\n        if (AirPDcapValidateKey(keys+i)==TRUE) {\r\n            if (keys[i].KeyType==AIRPDCAP_KEY_TYPE_WPA_PWD) {\r\n                AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapSetKeys\", \"Set a WPA-PWD key\", AIRPDCAP_DEBUG_LEVEL_4);\r\n                AirPDcapRsnaPwd2Psk(keys[i].UserPwd.Passphrase, keys[i].UserPwd.Ssid, keys[i].UserPwd.SsidLen, keys[i].KeyData.Wpa.Psk);\r\n            }\r\n#ifdef AIRPDCAP_DEBUG\r\n            else if (keys[i].KeyType==AIRPDCAP_KEY_TYPE_WPA_PMK) {\r\n                AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapSetKeys\", \"Set a WPA-PMK key\", AIRPDCAP_DEBUG_LEVEL_4);\r\n            } else if (keys[i].KeyType==AIRPDCAP_KEY_TYPE_WEP) {\r\n                AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapSetKeys\", \"Set a WEP key\", AIRPDCAP_DEBUG_LEVEL_4);\r\n            } else {\r\n                AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapSetKeys\", \"Set a key\", AIRPDCAP_DEBUG_LEVEL_4);\r\n            }\r\n#endif\r\n            memcpy(&ctx->keys[success], &keys[i], sizeof(keys[i]));\r\n            success++;\r\n        }\r\n    }\r\n\r\n    ctx->keys_nr=success;\r\n\r\n    AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapSetKeys\");\r\n    return success;\r\n}", ".irPDcapGetSaPtr": "static PAIRPDCAP_SEC_ASSOCIATION\r\nAirPDcapGetSaPtr(\r\n    PAIRPDCAP_CONTEXT ctx,\r\n    AIRPDCAP_SEC_ASSOCIATION_ID *id)\r\n{\r\n    int sa_index;\r\n\r\n    /* search for a cached Security Association for supplied BSSID and STA MAC  */\r\n    if ((sa_index=AirPDcapGetSa(ctx, id))==-1) {\r\n        /* create a new Security Association if it doesn't currently exist      */\r\n        if ((sa_index=AirPDcapStoreSa(ctx, id))==-1) {\r\n            return NULL;\r\n        }\r\n    }\r\n    /* get the Security Association structure   */\r\n    return &ctx->sa[sa_index];\r\n}", ".irPDcapRsnaPwd2Psk": "static INT\r\nAirPDcapRsnaPwd2Psk(\r\n    const CHAR *passphrase,\r\n    const CHAR *ssid,\r\n    const size_t ssidLength,\r\n    UCHAR *output)\r\n{\r\n    UCHAR m_output[40] = { 0 };\r\n    GByteArray *pp_ba = g_byte_array_new();\r\n\r\n    if (!uri_str_to_bytes(passphrase, pp_ba)) {\r\n        g_byte_array_free(pp_ba, TRUE);\r\n        return 0;\r\n    }\r\n\r\n    AirPDcapRsnaPwd2PskStep(pp_ba->data, pp_ba->len, ssid, ssidLength, 4096, 1, m_output);\r\n    AirPDcapRsnaPwd2PskStep(pp_ba->data, pp_ba->len, ssid, ssidLength, 4096, 2, &m_output[20]);\r\n\r\n    memcpy(output, m_output, AIRPDCAP_WPA_PSK_LEN);\r\n    g_byte_array_free(pp_ba, TRUE);\r\n\r\n    return 0;\r\n}"}, "function_name": "AirPDcapTDLSDeriveKey"}
{"function_id": null, "caller": {".utback_movable_ops_page": "static void putback_movable_ops_page(struct page *page)\r\n{\r\n\t/*\r\n\t * TODO: these pages will not be folios in the future. All\r\n\t * folio dependencies will have to be removed.\r\n\t */\r\n\tstruct folio *folio = page_folio(page);\r\n\r\n\tVM_WARN_ON_ONCE_PAGE(!page_has_movable_ops(page), page);\r\n\tVM_WARN_ON_ONCE_PAGE(!PageMovableOpsIsolated(page), page);\r\n\tfolio_lock(folio);\r\n\tpage_movable_ops(page)->putback_page(page);\r\n\tClearPageMovableOpsIsolated(page);\r\n\tfolio_unlock(folio);\r\n\tfolio_put(folio);\r\n}", ".solate_movable_ops_page": "bool isolate_movable_ops_page(struct page *page, isolate_mode_t mode)\r\n{\r\n\t/*\r\n\t * TODO: these pages will not be folios in the future. All\r\n\t * folio dependencies will have to be removed.\r\n\t */\r\n\tstruct folio *folio = folio_get_nontail_page(page);\r\n\tconst struct movable_operations *mops;\r\n\r\n\t/*\r\n\t * Avoid burning cycles with pages that are yet under __free_pages(),\r\n\t * or just got freed under us.\r\n\t *\r\n\t * In case we 'win' a race for a movable page being freed under us and\r\n\t * raise its refcount preventing __free_pages() from doing its job\r\n\t * the put_page() at the end of this block will take care of\r\n\t * release this page, thus avoiding a nasty leakage.\r\n\t */\r\n\tif (!folio)\r\n\t\tgoto out;\r\n\r\n\t/*\r\n\t * Check for movable_ops pages before taking the page lock because\r\n\t * we use non-atomic bitops on newly allocated page flags so\r\n\t * unconditionally grabbing the lock ruins page's owner side.\r\n\t *\r\n\t * Note that once a page has movable_ops, it will stay that way\r\n\t * until the page was freed.\r\n\t */\r\n\tif (unlikely(!page_has_movable_ops(page)))\r\n\t\tgoto out_putfolio;\r\n\r\n\t/*\r\n\t * As movable pages are not isolated from LRU lists, concurrent\r\n\t * compaction threads can race against page migration functions\r\n\t * as well as race against the releasing a page.\r\n\t *\r\n\t * In order to avoid having an already isolated movable page\r\n\t * being (wrongly) re-isolated while it is under migration,\r\n\t * or to avoid attempting to isolate pages being released,\r\n\t * lets be sure we have the page lock\r\n\t * before proceeding with the movable page isolation steps.\r\n\t */\r\n\tif (unlikely(!folio_trylock(folio)))\r\n\t\tgoto out_putfolio;\r\n\r\n\tVM_WARN_ON_ONCE_PAGE(!page_has_movable_ops(page), page);\r\n\tif (PageMovableOpsIsolated(page))\r\n\t\tgoto out_no_isolated;\r\n\r\n\tmops = page_movable_ops(page);\r\n\tif (WARN_ON_ONCE(!mops))\r\n\t\tgoto out_no_isolated;\r\n\r\n\tif (!mops->isolate_page(page, mode))\r\n\t\tgoto out_no_isolated;\r\n\r\n\t/* Driver shouldn't use the isolated flag */\r\n\tVM_WARN_ON_ONCE_PAGE(PageMovableOpsIsolated(page), page);\r\n\tSetPageMovableOpsIsolated(page);\r\n\tfolio_unlock(folio);\r\n\r\n\treturn true;\r\n\r\nout_no_isolated:\r\n\tfolio_unlock(folio);\r\nout_putfolio:\r\n\tfolio_put(folio);\r\nout:\r\n\treturn false;\r\n}", ".ry_to_map_unused_to_zeropage": "static bool try_to_map_unused_to_zeropage(struct page_vma_mapped_walk *pvmw,\r\n\t\t\t\t\t  struct folio *folio,\r\n\t\t\t\t\t  unsigned long idx)\r\n{\r\n\tstruct page *page = folio_page(folio, idx);\r\n\tpte_t newpte;\r\n\r\n\tif (PageCompound(page))\r\n\t\treturn false;\r\n\tVM_BUG_ON_PAGE(!PageAnon(page), page);\r\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\r\n\tVM_BUG_ON_PAGE(pte_present(ptep_get(pvmw->pte)), page);\r\n\r\n\tif (folio_test_mlocked(folio) || (pvmw->vma->vm_flags & VM_LOCKED) ||\r\n\t    mm_forbids_zeropage(pvmw->vma->vm_mm))\r\n\t\treturn false;\r\n\r\n\t/*\r\n\t * The pmd entry mapping the old thp was flushed and the pte mapping\r\n\t * this subpage has been non present. If the subpage is only zero-filled\r\n\t * then map it to the shared zeropage.\r\n\t */\r\n\tif (!pages_identical(page, ZERO_PAGE(0)))\r\n\t\treturn false;\r\n\r\n\tnewpte = pte_mkspecial(pfn_pte(my_zero_pfn(pvmw->address),\r\n\t\t\t\t\tpvmw->vma->vm_page_prot));\r\n\tset_pte_at(pvmw->vma->vm_mm, pvmw->address, pvmw->pte, newpte);\r\n\r\n\tdec_mm_counter(pvmw->vma->vm_mm, mm_counter(folio));\r\n\treturn true;\r\n}", ".emove_migration_pte": "static bool remove_migration_pte(struct folio *folio,\r\n\t\tstruct vm_area_struct *vma, unsigned long addr, void *arg)\r\n{\r\n\tstruct rmap_walk_arg *rmap_walk_arg = arg;\r\n\tDEFINE_FOLIO_VMA_WALK(pvmw, rmap_walk_arg->folio, vma, addr, PVMW_SYNC | PVMW_MIGRATION);\r\n\r\n\twhile (page_vma_mapped_walk(&pvmw)) {\r\n\t\trmap_t rmap_flags = RMAP_NONE;\r\n\t\tpte_t old_pte;\r\n\t\tpte_t pte;\r\n\t\tswp_entry_t entry;\r\n\t\tstruct page *new;\r\n\t\tunsigned long idx = 0;\r\n\r\n\t\t/* pgoff is invalid for ksm pages, but they are never large */\r\n\t\tif (folio_test_large(folio) && !folio_test_hugetlb(folio))\r\n\t\t\tidx = linear_page_index(vma, pvmw.address) - pvmw.pgoff;\r\n\t\tnew = folio_page(folio, idx);\r\n\r\n#ifdef CONFIG_ARCH_ENABLE_THP_MIGRATION\r\n\t\t/* PMD-mapped THP migration entry */\r\n\t\tif (!pvmw.pte) {\r\n\t\t\tVM_BUG_ON_FOLIO(folio_test_hugetlb(folio) ||\r\n\t\t\t\t\t!folio_test_pmd_mappable(folio), folio);\r\n\t\t\tremove_migration_pmd(&pvmw, new);\r\n\t\t\tcontinue;\r\n\t\t}\r\n#endif\r\n\t\tif (rmap_walk_arg->map_unused_to_zeropage &&\r\n\t\t    try_to_map_unused_to_zeropage(&pvmw, folio, idx))\r\n\t\t\tcontinue;\r\n\r\n\t\tfolio_get(folio);\r\n\t\tpte = mk_pte(new, READ_ONCE(vma->vm_page_prot));\r\n\t\told_pte = ptep_get(pvmw.pte);\r\n\r\n\t\tentry = pte_to_swp_entry(old_pte);\r\n\t\tif (!is_migration_entry_young(entry))\r\n\t\t\tpte = pte_mkold(pte);\r\n\t\tif (folio_test_dirty(folio) && is_migration_entry_dirty(entry))\r\n\t\t\tpte = pte_mkdirty(pte);\r\n\t\tif (pte_swp_soft_dirty(old_pte))\r\n\t\t\tpte = pte_mksoft_dirty(pte);\r\n\t\telse\r\n\t\t\tpte = pte_clear_soft_dirty(pte);\r\n\r\n\t\tif (is_writable_migration_entry(entry))\r\n\t\t\tpte = pte_mkwrite(pte, vma);\r\n\t\telse if (pte_swp_uffd_wp(old_pte))\r\n\t\t\tpte = pte_mkuffd_wp(pte);\r\n\r\n\t\tif (folio_test_anon(folio) && !is_readable_migration_entry(entry))\r\n\t\t\trmap_flags |= RMAP_EXCLUSIVE;\r\n\r\n\t\tif (unlikely(is_device_private_page(new))) {\r\n\t\t\tif (pte_write(pte))\r\n\t\t\t\tentry = make_writable_device_private_entry(\r\n\t\t\t\t\t\t\tpage_to_pfn(new));\r\n\t\t\telse\r\n\t\t\t\tentry = make_readable_device_private_entry(\r\n\t\t\t\t\t\t\tpage_to_pfn(new));\r\n\t\t\tpte = swp_entry_to_pte(entry);\r\n\t\t\tif (pte_swp_soft_dirty(old_pte))\r\n\t\t\t\tpte = pte_swp_mksoft_dirty(pte);\r\n\t\t\tif (pte_swp_uffd_wp(old_pte))\r\n\t\t\t\tpte = pte_swp_mkuffd_wp(pte);\r\n\t\t}\r\n\r\n#ifdef CONFIG_HUGETLB_PAGE\r\n\t\tif (folio_test_hugetlb(folio)) {\r\n\t\t\tstruct hstate *h = hstate_vma(vma);\r\n\t\t\tunsigned int shift = huge_page_shift(h);\r\n\t\t\tunsigned long psize = huge_page_size(h);\r\n\r\n\t\t\tpte = arch_make_huge_pte(pte, shift, vma->vm_flags);\r\n\t\t\tif (folio_test_anon(folio))\r\n\t\t\t\thugetlb_add_anon_rmap(folio, vma, pvmw.address,\r\n\t\t\t\t\t\t      rmap_flags);\r\n\t\t\telse\r\n\t\t\t\thugetlb_add_file_rmap(folio);\r\n\t\t\tset_huge_pte_at(vma->vm_mm, pvmw.address, pvmw.pte, pte,\r\n\t\t\t\t\tpsize);\r\n\t\t} else\r\n#endif\r\n\t\t{\r\n\t\t\tif (folio_test_anon(folio))\r\n\t\t\t\tfolio_add_anon_rmap_pte(folio, new, vma,\r\n\t\t\t\t\t\t\tpvmw.address, rmap_flags);\r\n\t\t\telse\r\n\t\t\t\tfolio_add_file_rmap_pte(folio, new, vma);\r\n\t\t\tset_pte_at(vma->vm_mm, pvmw.address, pvmw.pte, pte);\r\n\t\t}\r\n\t\tif (READ_ONCE(vma->vm_flags) & VM_LOCKED)\r\n\t\t\tmlock_drain_local();\r\n\r\n\t\ttrace_remove_migration_pte(pvmw.address, pte_val(pte),\r\n\t\t\t\t\t   compound_order(new));\r\n\r\n\t\t/* No need to invalidate - it was non-present before */\r\n\t\tupdate_mmu_cache(vma, pvmw.address, pvmw.pte);\r\n\t}\r\n\r\n\treturn true;\r\n}", ".igrate_folio": "int migrate_folio(struct address_space *mapping, struct folio *dst,\r\n\t\t  struct folio *src, enum migrate_mode mode)\r\n{\r\n\tBUG_ON(folio_test_writeback(src));\t/* Writeback must be complete */\r\n\treturn __migrate_folio(mapping, dst, src, NULL, mode);\r\n}", ".allback_migrate_folio": "static int fallback_migrate_folio(struct address_space *mapping,\r\n\t\tstruct folio *dst, struct folio *src, enum migrate_mode mode)\r\n{\r\n\tWARN_ONCE(mapping->a_ops->writepages,\r\n\t\t\t\"%ps does not implement migrate_folio\\n\",\r\n\t\t\tmapping->a_ops);\r\n\tif (folio_test_dirty(src))\r\n\t\treturn -EBUSY;\r\n\r\n\t/*\r\n\t * Filesystem may have private data at folio->private that we\r\n\t * can't migrate automatically.\r\n\t */\r\n\tif (!filemap_release_folio(src, GFP_KERNEL))\r\n\t\treturn mode == MIGRATE_SYNC ? -EAGAIN : -EBUSY;\r\n\r\n\treturn migrate_folio(mapping, dst, src, mode);\r\n}", ".emove_migration_ptes": "void remove_migration_ptes(struct folio *src, struct folio *dst, int flags)\r\n{\r\n\tstruct rmap_walk_arg rmap_walk_arg = {\r\n\t\t.folio = src,\r\n\t\t.map_unused_to_zeropage = flags & RMP_USE_SHARED_ZEROPAGE,\r\n\t};\r\n\r\n\tstruct rmap_walk_control rwc = {\r\n\t\t.rmap_one = remove_migration_pte,\r\n\t\t.arg = &rmap_walk_arg,\r\n\t};\r\n\r\n\tVM_BUG_ON_FOLIO((flags & RMP_USE_SHARED_ZEROPAGE) && (src != dst), src);\r\n\r\n\tif (flags & RMP_LOCKED)\r\n\t\trmap_walk_locked(dst, &rwc);\r\n\telse\r\n\t\trmap_walk(dst, &rwc);\r\n}", ".igrate_folio_undo_src": "static void migrate_folio_undo_src(struct folio *src,\r\n\t\t\t\t   int page_was_mapped,\r\n\t\t\t\t   struct anon_vma *anon_vma,\r\n\t\t\t\t   bool locked,\r\n\t\t\t\t   struct list_head *ret)\r\n{\r\n\tif (page_was_mapped)\r\n\t\tremove_migration_ptes(src, src, 0);\r\n\t/* Drop an anon_vma reference if we took one */\r\n\tif (anon_vma)\r\n\t\tput_anon_vma(anon_vma);\r\n\tif (locked)\r\n\t\tfolio_unlock(src);\r\n\tif (ret)\r\n\t\tlist_move_tail(&src->lru, ret);\r\n}", ".igrate_folio_undo_dst": "static void migrate_folio_undo_dst(struct folio *dst, bool locked,\r\n\t\tfree_folio_t put_new_folio, unsigned long private)\r\n{\r\n\tif (locked)\r\n\t\tfolio_unlock(dst);\r\n\tif (put_new_folio)\r\n\t\tput_new_folio(dst, private);\r\n\telse\r\n\t\tfolio_put(dst);\r\n}", ".igrate_movable_ops_page": "static int migrate_movable_ops_page(struct page *dst, struct page *src,\r\n\t\tenum migrate_mode mode)\r\n{\r\n\tint rc;\r\n\r\n\tVM_WARN_ON_ONCE_PAGE(!page_has_movable_ops(src), src);\r\n\tVM_WARN_ON_ONCE_PAGE(!PageMovableOpsIsolated(src), src);\r\n\trc = page_movable_ops(src)->migrate_page(dst, src, mode);\r\n\tif (!rc)\r\n\t\tClearPageMovableOpsIsolated(src);\r\n\treturn rc;\r\n}", ".ove_to_new_folio": "static int move_to_new_folio(struct folio *dst, struct folio *src,\r\n\t\t\t\tenum migrate_mode mode)\r\n{\r\n\tstruct address_space *mapping = folio_mapping(src);\r\n\tint rc = -EAGAIN;\r\n\r\n\tVM_BUG_ON_FOLIO(!folio_test_locked(src), src);\r\n\tVM_BUG_ON_FOLIO(!folio_test_locked(dst), dst);\r\n\r\n\tif (!mapping)\r\n\t\trc = migrate_folio(mapping, dst, src, mode);\r\n\telse if (mapping_inaccessible(mapping))\r\n\t\trc = -EOPNOTSUPP;\r\n\telse if (mapping->a_ops->migrate_folio)\r\n\t\t/*\r\n\t\t * Most folios have a mapping and most filesystems\r\n\t\t * provide a migrate_folio callback. Anonymous folios\r\n\t\t * are part of swap space which also has its own\r\n\t\t * migrate_folio callback. This is the most common path\r\n\t\t * for page migration.\r\n\t\t */\r\n\t\trc = mapping->a_ops->migrate_folio(mapping, dst, src,\r\n\t\t\t\t\t\t\tmode);\r\n\telse\r\n\t\trc = fallback_migrate_folio(mapping, dst, src, mode);\r\n\r\n\tif (!rc) {\r\n\t\t/*\r\n\t\t * For pagecache folios, src->mapping must be cleared before src\r\n\t\t * is freed. Anonymous folios must stay anonymous until freed.\r\n\t\t */\r\n\t\tif (!folio_test_anon(src))\r\n\t\t\tsrc->mapping = NULL;\r\n\r\n\t\tif (likely(!folio_is_zone_device(dst)))\r\n\t\t\tflush_dcache_folio(dst);\r\n\t}\r\n\treturn rc;\r\n}", ".igrate_folio_done": "static void migrate_folio_done(struct folio *src,\r\n\t\t\t       enum migrate_reason reason)\r\n{\r\n\tif (likely(!page_has_movable_ops(&src->page)) && reason != MR_DEMOTION)\r\n\t\tmod_node_page_state(folio_pgdat(src), NR_ISOLATED_ANON +\r\n\t\t\t\t    folio_is_file_lru(src), -folio_nr_pages(src));\r\n\r\n\tif (reason != MR_MEMORY_FAILURE)\r\n\t\t/* We release the page in page_handle_poison. */\r\n\t\tfolio_put(src);\r\n}", ".nmap_and_move_huge_page": "static int unmap_and_move_huge_page(new_folio_t get_new_folio,\r\n\t\tfree_folio_t put_new_folio, unsigned long private,\r\n\t\tstruct folio *src, int force, enum migrate_mode mode,\r\n\t\tint reason, struct list_head *ret)\r\n{\r\n\tstruct folio *dst;\r\n\tint rc = -EAGAIN;\r\n\tint page_was_mapped = 0;\r\n\tstruct anon_vma *anon_vma = NULL;\r\n\tstruct address_space *mapping = NULL;\r\n\r\n\tif (folio_ref_count(src) == 1) {\r\n\t\t/* page was freed from under us. So we are done. */\r\n\t\tfolio_putback_hugetlb(src);\r\n\t\treturn 0;\r\n\t}\r\n\r\n\tdst = get_new_folio(src, private);\r\n\tif (!dst)\r\n\t\treturn -ENOMEM;\r\n\r\n\tif (!folio_trylock(src)) {\r\n\t\tif (!force)\r\n\t\t\tgoto out;\r\n\t\tswitch (mode) {\r\n\t\tcase MIGRATE_SYNC:\r\n\t\t\tbreak;\r\n\t\tdefault:\r\n\t\t\tgoto out;\r\n\t\t}\r\n\t\tfolio_lock(src);\r\n\t}\r\n\r\n\t/*\r\n\t * Check for pages which are in the process of being freed.  Without\r\n\t * folio_mapping() set, hugetlbfs specific move page routine will not\r\n\t * be called and we could leak usage counts for subpools.\r\n\t */\r\n\tif (hugetlb_folio_subpool(src) && !folio_mapping(src)) {\r\n\t\trc = -EBUSY;\r\n\t\tgoto out_unlock;\r\n\t}\r\n\r\n\tif (folio_test_anon(src))\r\n\t\tanon_vma = folio_get_anon_vma(src);\r\n\r\n\tif (unlikely(!folio_trylock(dst)))\r\n\t\tgoto put_anon;\r\n\r\n\tif (folio_mapped(src)) {\r\n\t\tenum ttu_flags ttu = 0;\r\n\r\n\t\tif (!folio_test_anon(src)) {\r\n\t\t\t/*\r\n\t\t\t * In shared mappings, try_to_unmap could potentially\r\n\t\t\t * call huge_pmd_unshare.  Because of this, take\r\n\t\t\t * semaphore in write mode here and set TTU_RMAP_LOCKED\r\n\t\t\t * to let lower levels know we have taken the lock.\r\n\t\t\t */\r\n\t\t\tmapping = hugetlb_folio_mapping_lock_write(src);\r\n\t\t\tif (unlikely(!mapping))\r\n\t\t\t\tgoto unlock_put_anon;\r\n\r\n\t\t\tttu = TTU_RMAP_LOCKED;\r\n\t\t}\r\n\r\n\t\ttry_to_migrate(src, ttu);\r\n\t\tpage_was_mapped = 1;\r\n\r\n\t\tif (ttu & TTU_RMAP_LOCKED)\r\n\t\t\ti_mmap_unlock_write(mapping);\r\n\t}\r\n\r\n\tif (!folio_mapped(src))\r\n\t\trc = move_to_new_folio(dst, src, mode);\r\n\r\n\tif (page_was_mapped)\r\n\t\tremove_migration_ptes(src, !rc ? dst : src, 0);\r\n\r\nunlock_put_anon:\r\n\tfolio_unlock(dst);\r\n\r\nput_anon:\r\n\tif (anon_vma)\r\n\t\tput_anon_vma(anon_vma);\r\n\r\n\tif (!rc) {\r\n\t\tmove_hugetlb_state(src, dst, reason);\r\n\t\tput_new_folio = NULL;\r\n\t}\r\n\r\nout_unlock:\r\n\tfolio_unlock(src);\r\nout:\r\n\tif (!rc)\r\n\t\tfolio_putback_hugetlb(src);\r\n\telse if (rc != -EAGAIN)\r\n\t\tlist_move_tail(&src->lru, ret);\r\n\r\n\t/*\r\n\t * If migration was not successful and there's a freeing callback,\r\n\t * return the folio to that special allocator. Otherwise, simply drop\r\n\t * our additional reference.\r\n\t */\r\n\tif (put_new_folio)\r\n\t\tput_new_folio(dst, private);\r\n\telse\r\n\t\tfolio_put(dst);\r\n\r\n\treturn rc;\r\n}", ".igrate_folio_move": "static int migrate_folio_move(free_folio_t put_new_folio, unsigned long private,\r\n\t\t\t      struct folio *src, struct folio *dst,\r\n\t\t\t      enum migrate_mode mode, enum migrate_reason reason,\r\n\t\t\t      struct list_head *ret)\r\n{\r\n\tint rc;\r\n\tint old_page_state = 0;\r\n\tstruct anon_vma *anon_vma = NULL;\r\n\tstruct list_head *prev;\r\n\r\n\t__migrate_folio_extract(dst, &old_page_state, &anon_vma);\r\n\tprev = dst->lru.prev;\r\n\tlist_del(&dst->lru);\r\n\r\n\tif (unlikely(page_has_movable_ops(&src->page))) {\r\n\t\trc = migrate_movable_ops_page(&dst->page, &src->page, mode);\r\n\t\tif (rc)\r\n\t\t\tgoto out;\r\n\t\tgoto out_unlock_both;\r\n\t}\r\n\r\n\trc = move_to_new_folio(dst, src, mode);\r\n\tif (rc)\r\n\t\tgoto out;\r\n\r\n\t/*\r\n\t * When successful, push dst to LRU immediately: so that if it\r\n\t * turns out to be an mlocked page, remove_migration_ptes() will\r\n\t * automatically build up the correct dst->mlock_count for it.\r\n\t *\r\n\t * We would like to do something similar for the old page, when\r\n\t * unsuccessful, and other cases when a page has been temporarily\r\n\t * isolated from the unevictable LRU: but this case is the easiest.\r\n\t */\r\n\tfolio_add_lru(dst);\r\n\tif (old_page_state & PAGE_WAS_MLOCKED)\r\n\t\tlru_add_drain();\r\n\r\n\tif (old_page_state & PAGE_WAS_MAPPED)\r\n\t\tremove_migration_ptes(src, dst, 0);\r\n\r\nout_unlock_both:\r\n\tfolio_unlock(dst);\r\n\tfolio_set_owner_migrate_reason(dst, reason);\r\n\t/*\r\n\t * If migration is successful, decrease refcount of dst,\r\n\t * which will not free the page because new page owner increased\r\n\t * refcounter.\r\n\t */\r\n\tfolio_put(dst);\r\n\r\n\t/*\r\n\t * A folio that has been migrated has all references removed\r\n\t * and will be freed.\r\n\t */\r\n\tlist_del(&src->lru);\r\n\t/* Drop an anon_vma reference if we took one */\r\n\tif (anon_vma)\r\n\t\tput_anon_vma(anon_vma);\r\n\tfolio_unlock(src);\r\n\tmigrate_folio_done(src, reason);\r\n\r\n\treturn rc;\r\nout:\r\n\t/*\r\n\t * A folio that has not been migrated will be restored to\r\n\t * right list unless we want to retry.\r\n\t */\r\n\tif (rc == -EAGAIN) {\r\n\t\tlist_add(&dst->lru, prev);\r\n\t\t__migrate_folio_record(dst, old_page_state, anon_vma);\r\n\t\treturn rc;\r\n\t}\r\n\r\n\tmigrate_folio_undo_src(src, old_page_state & PAGE_WAS_MAPPED,\r\n\t\t\t       anon_vma, true, ret);\r\n\tmigrate_folio_undo_dst(dst, true, put_new_folio, private);\r\n\r\n\treturn rc;\r\n}", ".ry_split_folio": "static inline int try_split_folio(struct folio *folio, struct list_head *split_folios,\r\n\t\t\t\t  enum migrate_mode mode)\r\n{\r\n\tint rc;\r\n\r\n\tif (mode == MIGRATE_ASYNC) {\r\n\t\tif (!folio_trylock(folio))\r\n\t\t\treturn -EAGAIN;\r\n\t} else {\r\n\t\tfolio_lock(folio);\r\n\t}\r\n\trc = split_folio_to_list(folio, split_folios);\r\n\tfolio_unlock(folio);\r\n\tif (!rc)\r\n\t\tlist_move_tail(&folio->lru, split_folios);\r\n\r\n\treturn rc;\r\n}", ".igrate_folio_unmap": "static int migrate_folio_unmap(new_folio_t get_new_folio,\r\n\t\tfree_folio_t put_new_folio, unsigned long private,\r\n\t\tstruct folio *src, struct folio **dstp, enum migrate_mode mode,\r\n\t\tstruct list_head *ret)\r\n{\r\n\tstruct folio *dst;\r\n\tint rc = -EAGAIN;\r\n\tint old_page_state = 0;\r\n\tstruct anon_vma *anon_vma = NULL;\r\n\tbool locked = false;\r\n\tbool dst_locked = false;\r\n\r\n\tdst = get_new_folio(src, private);\r\n\tif (!dst)\r\n\t\treturn -ENOMEM;\r\n\t*dstp = dst;\r\n\r\n\tdst->private = NULL;\r\n\r\n\tif (!folio_trylock(src)) {\r\n\t\tif (mode == MIGRATE_ASYNC)\r\n\t\t\tgoto out;\r\n\r\n\t\t/*\r\n\t\t * It's not safe for direct compaction to call lock_page.\r\n\t\t * For example, during page readahead pages are added locked\r\n\t\t * to the LRU. Later, when the IO completes the pages are\r\n\t\t * marked uptodate and unlocked. However, the queueing\r\n\t\t * could be merging multiple pages for one bio (e.g.\r\n\t\t * mpage_readahead). If an allocation happens for the\r\n\t\t * second or third page, the process can end up locking\r\n\t\t * the same page twice and deadlocking. Rather than\r\n\t\t * trying to be clever about what pages can be locked,\r\n\t\t * avoid the use of lock_page for direct compaction\r\n\t\t * altogether.\r\n\t\t */\r\n\t\tif (current->flags & PF_MEMALLOC)\r\n\t\t\tgoto out;\r\n\r\n\t\t/*\r\n\t\t * In \"light\" mode, we can wait for transient locks (eg\r\n\t\t * inserting a page into the page table), but it's not\r\n\t\t * worth waiting for I/O.\r\n\t\t */\r\n\t\tif (mode == MIGRATE_SYNC_LIGHT && !folio_test_uptodate(src))\r\n\t\t\tgoto out;\r\n\r\n\t\tfolio_lock(src);\r\n\t}\r\n\tlocked = true;\r\n\tif (folio_test_mlocked(src))\r\n\t\told_page_state |= PAGE_WAS_MLOCKED;\r\n\r\n\tif (folio_test_writeback(src)) {\r\n\t\t/*\r\n\t\t * Only in the case of a full synchronous migration is it\r\n\t\t * necessary to wait for PageWriteback. In the async case,\r\n\t\t * the retry loop is too short and in the sync-light case,\r\n\t\t * the overhead of stalling is too much\r\n\t\t */\r\n\t\tswitch (mode) {\r\n\t\tcase MIGRATE_SYNC:\r\n\t\t\tbreak;\r\n\t\tdefault:\r\n\t\t\trc = -EBUSY;\r\n\t\t\tgoto out;\r\n\t\t}\r\n\t\tfolio_wait_writeback(src);\r\n\t}\r\n\r\n\t/*\r\n\t * By try_to_migrate(), src->mapcount goes down to 0 here. In this case,\r\n\t * we cannot notice that anon_vma is freed while we migrate a page.\r\n\t * This get_anon_vma() delays freeing anon_vma pointer until the end\r\n\t * of migration. File cache pages are no problem because of page_lock()\r\n\t * File Caches may use write_page() or lock_page() in migration, then,\r\n\t * just care Anon page here.\r\n\t *\r\n\t * Only folio_get_anon_vma() understands the subtleties of\r\n\t * getting a hold on an anon_vma from outside one of its mms.\r\n\t * But if we cannot get anon_vma, then we won't need it anyway,\r\n\t * because that implies that the anon page is no longer mapped\r\n\t * (and cannot be remapped so long as we hold the page lock).\r\n\t */\r\n\tif (folio_test_anon(src) && !folio_test_ksm(src))\r\n\t\tanon_vma = folio_get_anon_vma(src);\r\n\r\n\t/*\r\n\t * Block others from accessing the new page when we get around to\r\n\t * establishing additional references. We are usually the only one\r\n\t * holding a reference to dst at this point. We used to have a BUG\r\n\t * here if folio_trylock(dst) fails, but would like to allow for\r\n\t * cases where there might be a race with the previous use of dst.\r\n\t * This is much like races on refcount of oldpage: just don't BUG().\r\n\t */\r\n\tif (unlikely(!folio_trylock(dst)))\r\n\t\tgoto out;\r\n\tdst_locked = true;\r\n\r\n\tif (unlikely(page_has_movable_ops(&src->page))) {\r\n\t\t__migrate_folio_record(dst, old_page_state, anon_vma);\r\n\t\treturn 0;\r\n\t}\r\n\r\n\t/*\r\n\t * Corner case handling:\r\n\t * 1. When a new swap-cache page is read into, it is added to the LRU\r\n\t * and treated as swapcache but it has no rmap yet.\r\n\t * Calling try_to_unmap() against a src->mapping==NULL page will\r\n\t * trigger a BUG.  So handle it here.\r\n\t * 2. An orphaned page (see truncate_cleanup_page) might have\r\n\t * fs-private metadata. The page can be picked up due to memory\r\n\t * offlining.  Everywhere else except page reclaim, the page is\r\n\t * invisible to the vm, so the page can not be migrated.  So try to\r\n\t * free the metadata, so the page can be freed.\r\n\t */\r\n\tif (!src->mapping) {\r\n\t\tif (folio_test_private(src)) {\r\n\t\t\ttry_to_free_buffers(src);\r\n\t\t\tgoto out;\r\n\t\t}\r\n\t} else if (folio_mapped(src)) {\r\n\t\t/* Establish migration ptes */\r\n\t\tVM_BUG_ON_FOLIO(folio_test_anon(src) &&\r\n\t\t\t       !folio_test_ksm(src) && !anon_vma, src);\r\n\t\ttry_to_migrate(src, mode == MIGRATE_ASYNC ? TTU_BATCH_FLUSH : 0);\r\n\t\told_page_state |= PAGE_WAS_MAPPED;\r\n\t}\r\n\r\n\tif (!folio_mapped(src)) {\r\n\t\t__migrate_folio_record(dst, old_page_state, anon_vma);\r\n\t\treturn 0;\r\n\t}\r\n\r\nout:\r\n\t/*\r\n\t * A folio that has not been unmapped will be restored to\r\n\t * right list unless we want to retry.\r\n\t */\r\n\tif (rc == -EAGAIN)\r\n\t\tret = NULL;\r\n\r\n\tmigrate_folio_undo_src(src, old_page_state & PAGE_WAS_MAPPED,\r\n\t\t\t       anon_vma, locked, ret);\r\n\tmigrate_folio_undo_dst(dst, dst_locked, put_new_folio, private);\r\n\r\n\treturn rc;\r\n}", ".igrate_folios_move": "static void migrate_folios_move(struct list_head *src_folios,\r\n\t\tstruct list_head *dst_folios,\r\n\t\tfree_folio_t put_new_folio, unsigned long private,\r\n\t\tenum migrate_mode mode, int reason,\r\n\t\tstruct list_head *ret_folios,\r\n\t\tstruct migrate_pages_stats *stats,\r\n\t\tint *retry, int *thp_retry, int *nr_failed,\r\n\t\tint *nr_retry_pages)\r\n{\r\n\tstruct folio *folio, *folio2, *dst, *dst2;\r\n\tbool is_thp;\r\n\tint nr_pages;\r\n\tint rc;\r\n\r\n\tdst = list_first_entry(dst_folios, struct folio, lru);\r\n\tdst2 = list_next_entry(dst, lru);\r\n\tlist_for_each_entry_safe(folio, folio2, src_folios, lru) {\r\n\t\tis_thp = folio_test_large(folio) && folio_test_pmd_mappable(folio);\r\n\t\tnr_pages = folio_nr_pages(folio);\r\n\r\n\t\tcond_resched();\r\n\r\n\t\trc = migrate_folio_move(put_new_folio, private,\r\n\t\t\t\tfolio, dst, mode,\r\n\t\t\t\treason, ret_folios);\r\n\t\t/*\r\n\t\t * The rules are:\r\n\t\t *\t0: folio will be freed\r\n\t\t *\t-EAGAIN: stay on the unmap_folios list\r\n\t\t *\tOther errno: put on ret_folios list\r\n\t\t */\r\n\t\tswitch (rc) {\r\n\t\tcase -EAGAIN:\r\n\t\t\t*retry += 1;\r\n\t\t\t*thp_retry += is_thp;\r\n\t\t\t*nr_retry_pages += nr_pages;\r\n\t\t\tbreak;\r\n\t\tcase 0:\r\n\t\t\tstats->nr_succeeded += nr_pages;\r\n\t\t\tstats->nr_thp_succeeded += is_thp;\r\n\t\t\tbreak;\r\n\t\tdefault:\r\n\t\t\t*nr_failed += 1;\r\n\t\t\tstats->nr_thp_failed += is_thp;\r\n\t\t\tstats->nr_failed_pages += nr_pages;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tdst = dst2;\r\n\t\tdst2 = list_next_entry(dst, lru);\r\n\t}\r\n}", ".igrate_folios_undo": "static void migrate_folios_undo(struct list_head *src_folios,\r\n\t\tstruct list_head *dst_folios,\r\n\t\tfree_folio_t put_new_folio, unsigned long private,\r\n\t\tstruct list_head *ret_folios)\r\n{\r\n\tstruct folio *folio, *folio2, *dst, *dst2;\r\n\r\n\tdst = list_first_entry(dst_folios, struct folio, lru);\r\n\tdst2 = list_next_entry(dst, lru);\r\n\tlist_for_each_entry_safe(folio, folio2, src_folios, lru) {\r\n\t\tint old_page_state = 0;\r\n\t\tstruct anon_vma *anon_vma = NULL;\r\n\r\n\t\t__migrate_folio_extract(dst, &old_page_state, &anon_vma);\r\n\t\tmigrate_folio_undo_src(folio, old_page_state & PAGE_WAS_MAPPED,\r\n\t\t\t\tanon_vma, true, ret_folios);\r\n\t\tlist_del(&dst->lru);\r\n\t\tmigrate_folio_undo_dst(dst, true, put_new_folio, private);\r\n\t\tdst = dst2;\r\n\t\tdst2 = list_next_entry(dst, lru);\r\n\t}\r\n}", ".igrate_pages_batch": "static int migrate_pages_batch(struct list_head *from,\r\n\t\tnew_folio_t get_new_folio, free_folio_t put_new_folio,\r\n\t\tunsigned long private, enum migrate_mode mode, int reason,\r\n\t\tstruct list_head *ret_folios, struct list_head *split_folios,\r\n\t\tstruct migrate_pages_stats *stats, int nr_pass)\r\n{\r\n\tint retry = 1;\r\n\tint thp_retry = 1;\r\n\tint nr_failed = 0;\r\n\tint nr_retry_pages = 0;\r\n\tint pass = 0;\r\n\tbool is_thp = false;\r\n\tbool is_large = false;\r\n\tstruct folio *folio, *folio2, *dst = NULL;\r\n\tint rc, rc_saved = 0, nr_pages;\r\n\tLIST_HEAD(unmap_folios);\r\n\tLIST_HEAD(dst_folios);\r\n\tbool nosplit = (reason == MR_NUMA_MISPLACED);\r\n\r\n\tVM_WARN_ON_ONCE(mode != MIGRATE_ASYNC &&\r\n\t\t\t!list_empty(from) && !list_is_singular(from));\r\n\r\n\tfor (pass = 0; pass < nr_pass && retry; pass++) {\r\n\t\tretry = 0;\r\n\t\tthp_retry = 0;\r\n\t\tnr_retry_pages = 0;\r\n\r\n\t\tlist_for_each_entry_safe(folio, folio2, from, lru) {\r\n\t\t\tis_large = folio_test_large(folio);\r\n\t\t\tis_thp = folio_test_pmd_mappable(folio);\r\n\t\t\tnr_pages = folio_nr_pages(folio);\r\n\r\n\t\t\tcond_resched();\r\n\r\n\t\t\t/*\r\n\t\t\t * The rare folio on the deferred split list should\r\n\t\t\t * be split now. It should not count as a failure:\r\n\t\t\t * but increment nr_failed because, without doing so,\r\n\t\t\t * migrate_pages() may report success with (split but\r\n\t\t\t * unmigrated) pages still on its fromlist; whereas it\r\n\t\t\t * always reports success when its fromlist is empty.\r\n\t\t\t * stats->nr_thp_failed should be increased too,\r\n\t\t\t * otherwise stats inconsistency will happen when\r\n\t\t\t * migrate_pages_batch is called via migrate_pages()\r\n\t\t\t * with MIGRATE_SYNC and MIGRATE_ASYNC.\r\n\t\t\t *\r\n\t\t\t * Only check it without removing it from the list.\r\n\t\t\t * Since the folio can be on deferred_split_scan()\r\n\t\t\t * local list and removing it can cause the local list\r\n\t\t\t * corruption. Folio split process below can handle it\r\n\t\t\t * with the help of folio_ref_freeze().\r\n\t\t\t *\r\n\t\t\t * nr_pages > 2 is needed to avoid checking order-1\r\n\t\t\t * page cache folios. They exist, in contrast to\r\n\t\t\t * non-existent order-1 anonymous folios, and do not\r\n\t\t\t * use _deferred_list.\r\n\t\t\t */\r\n\t\t\tif (nr_pages > 2 &&\r\n\t\t\t   !list_empty(&folio->_deferred_list) &&\r\n\t\t\t   folio_test_partially_mapped(folio)) {\r\n\t\t\t\tif (!try_split_folio(folio, split_folios, mode)) {\r\n\t\t\t\t\tnr_failed++;\r\n\t\t\t\t\tstats->nr_thp_failed += is_thp;\r\n\t\t\t\t\tstats->nr_thp_split += is_thp;\r\n\t\t\t\t\tstats->nr_split++;\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t/*\r\n\t\t\t * Large folio migration might be unsupported or\r\n\t\t\t * the allocation might be failed so we should retry\r\n\t\t\t * on the same folio with the large folio split\r\n\t\t\t * to normal folios.\r\n\t\t\t *\r\n\t\t\t * Split folios are put in split_folios, and\r\n\t\t\t * we will migrate them after the rest of the\r\n\t\t\t * list is processed.\r\n\t\t\t */\r\n\t\t\tif (!thp_migration_supported() && is_thp) {\r\n\t\t\t\tnr_failed++;\r\n\t\t\t\tstats->nr_thp_failed++;\r\n\t\t\t\tif (!try_split_folio(folio, split_folios, mode)) {\r\n\t\t\t\t\tstats->nr_thp_split++;\r\n\t\t\t\t\tstats->nr_split++;\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tstats->nr_failed_pages += nr_pages;\r\n\t\t\t\tlist_move_tail(&folio->lru, ret_folios);\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\t/*\r\n\t\t\t * If we are holding the last folio reference, the folio\r\n\t\t\t * was freed from under us, so just drop our reference.\r\n\t\t\t */\r\n\t\t\tif (likely(!page_has_movable_ops(&folio->page)) &&\r\n\t\t\t    folio_ref_count(folio) == 1) {\r\n\t\t\t\tfolio_clear_active(folio);\r\n\t\t\t\tfolio_clear_unevictable(folio);\r\n\t\t\t\tlist_del(&folio->lru);\r\n\t\t\t\tmigrate_folio_done(folio, reason);\r\n\t\t\t\tstats->nr_succeeded += nr_pages;\r\n\t\t\t\tstats->nr_thp_succeeded += is_thp;\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\trc = migrate_folio_unmap(get_new_folio, put_new_folio,\r\n\t\t\t\t\tprivate, folio, &dst, mode, ret_folios);\r\n\t\t\t/*\r\n\t\t\t * The rules are:\r\n\t\t\t *\t0: folio will be put on unmap_folios list,\r\n\t\t\t *\t   dst folio put on dst_folios list\r\n\t\t\t *\t-EAGAIN: stay on the from list\r\n\t\t\t *\t-ENOMEM: stay on the from list\r\n\t\t\t *\tOther errno: put on ret_folios list\r\n\t\t\t */\r\n\t\t\tswitch(rc) {\r\n\t\t\tcase -ENOMEM:\r\n\t\t\t\t/*\r\n\t\t\t\t * When memory is low, don't bother to try to migrate\r\n\t\t\t\t * other folios, move unmapped folios, then exit.\r\n\t\t\t\t */\r\n\t\t\t\tnr_failed++;\r\n\t\t\t\tstats->nr_thp_failed += is_thp;\r\n\t\t\t\t/* Large folio NUMA faulting doesn't split to retry. */\r\n\t\t\t\tif (is_large && !nosplit) {\r\n\t\t\t\t\tint ret = try_split_folio(folio, split_folios, mode);\r\n\r\n\t\t\t\t\tif (!ret) {\r\n\t\t\t\t\t\tstats->nr_thp_split += is_thp;\r\n\t\t\t\t\t\tstats->nr_split++;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t} else if (reason == MR_LONGTERM_PIN &&\r\n\t\t\t\t\t\t   ret == -EAGAIN) {\r\n\t\t\t\t\t\t/*\r\n\t\t\t\t\t\t * Try again to split large folio to\r\n\t\t\t\t\t\t * mitigate the failure of longterm pinning.\r\n\t\t\t\t\t\t */\r\n\t\t\t\t\t\tretry++;\r\n\t\t\t\t\t\tthp_retry += is_thp;\r\n\t\t\t\t\t\tnr_retry_pages += nr_pages;\r\n\t\t\t\t\t\t/* Undo duplicated failure counting. */\r\n\t\t\t\t\t\tnr_failed--;\r\n\t\t\t\t\t\tstats->nr_thp_failed -= is_thp;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tstats->nr_failed_pages += nr_pages + nr_retry_pages;\r\n\t\t\t\t/* nr_failed isn't updated for not used */\r\n\t\t\t\tstats->nr_thp_failed += thp_retry;\r\n\t\t\t\trc_saved = rc;\r\n\t\t\t\tif (list_empty(&unmap_folios))\r\n\t\t\t\t\tgoto out;\r\n\t\t\t\telse\r\n\t\t\t\t\tgoto move;\r\n\t\t\tcase -EAGAIN:\r\n\t\t\t\tretry++;\r\n\t\t\t\tthp_retry += is_thp;\r\n\t\t\t\tnr_retry_pages += nr_pages;\r\n\t\t\t\tbreak;\r\n\t\t\tcase 0:\r\n\t\t\t\tlist_move_tail(&folio->lru, &unmap_folios);\r\n\t\t\t\tlist_add_tail(&dst->lru, &dst_folios);\r\n\t\t\t\tbreak;\r\n\t\t\tdefault:\r\n\t\t\t\t/*\r\n\t\t\t\t * Permanent failure (-EBUSY, etc.):\r\n\t\t\t\t * unlike -EAGAIN case, the failed folio is\r\n\t\t\t\t * removed from migration folio list and not\r\n\t\t\t\t * retried in the next outer loop.\r\n\t\t\t\t */\r\n\t\t\t\tnr_failed++;\r\n\t\t\t\tstats->nr_thp_failed += is_thp;\r\n\t\t\t\tstats->nr_failed_pages += nr_pages;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tnr_failed += retry;\r\n\tstats->nr_thp_failed += thp_retry;\r\n\tstats->nr_failed_pages += nr_retry_pages;\r\nmove:\r\n\t/* Flush TLBs for all unmapped folios */\r\n\ttry_to_unmap_flush();\r\n\r\n\tretry = 1;\r\n\tfor (pass = 0; pass < nr_pass && retry; pass++) {\r\n\t\tretry = 0;\r\n\t\tthp_retry = 0;\r\n\t\tnr_retry_pages = 0;\r\n\r\n\t\t/* Move the unmapped folios */\r\n\t\tmigrate_folios_move(&unmap_folios, &dst_folios,\r\n\t\t\t\tput_new_folio, private, mode, reason,\r\n\t\t\t\tret_folios, stats, &retry, &thp_retry,\r\n\t\t\t\t&nr_failed, &nr_retry_pages);\r\n\t}\r\n\tnr_failed += retry;\r\n\tstats->nr_thp_failed += thp_retry;\r\n\tstats->nr_failed_pages += nr_retry_pages;\r\n\r\n\trc = rc_saved ? : nr_failed;\r\nout:\r\n\t/* Cleanup remaining folios */\r\n\tmigrate_folios_undo(&unmap_folios, &dst_folios,\r\n\t\t\tput_new_folio, private, ret_folios);\r\n\r\n\treturn rc;\r\n}", ".igrate_hugetlbs": "static int migrate_hugetlbs(struct list_head *from, new_folio_t get_new_folio,\r\n\t\t\t    free_folio_t put_new_folio, unsigned long private,\r\n\t\t\t    enum migrate_mode mode, int reason,\r\n\t\t\t    struct migrate_pages_stats *stats,\r\n\t\t\t    struct list_head *ret_folios)\r\n{\r\n\tint retry = 1;\r\n\tint nr_failed = 0;\r\n\tint nr_retry_pages = 0;\r\n\tint pass = 0;\r\n\tstruct folio *folio, *folio2;\r\n\tint rc, nr_pages;\r\n\r\n\tfor (pass = 0; pass < NR_MAX_MIGRATE_PAGES_RETRY && retry; pass++) {\r\n\t\tretry = 0;\r\n\t\tnr_retry_pages = 0;\r\n\r\n\t\tlist_for_each_entry_safe(folio, folio2, from, lru) {\r\n\t\t\tif (!folio_test_hugetlb(folio))\r\n\t\t\t\tcontinue;\r\n\r\n\t\t\tnr_pages = folio_nr_pages(folio);\r\n\r\n\t\t\tcond_resched();\r\n\r\n\t\t\t/*\r\n\t\t\t * Migratability of hugepages depends on architectures and\r\n\t\t\t * their size.  This check is necessary because some callers\r\n\t\t\t * of hugepage migration like soft offline and memory\r\n\t\t\t * hotremove don't walk through page tables or check whether\r\n\t\t\t * the hugepage is pmd-based or not before kicking migration.\r\n\t\t\t */\r\n\t\t\tif (!hugepage_migration_supported(folio_hstate(folio))) {\r\n\t\t\t\tnr_failed++;\r\n\t\t\t\tstats->nr_failed_pages += nr_pages;\r\n\t\t\t\tlist_move_tail(&folio->lru, ret_folios);\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\trc = unmap_and_move_huge_page(get_new_folio,\r\n\t\t\t\t\t\t      put_new_folio, private,\r\n\t\t\t\t\t\t      folio, pass > 2, mode,\r\n\t\t\t\t\t\t      reason, ret_folios);\r\n\t\t\t/*\r\n\t\t\t * The rules are:\r\n\t\t\t *\t0: hugetlb folio will be put back\r\n\t\t\t *\t-EAGAIN: stay on the from list\r\n\t\t\t *\t-ENOMEM: stay on the from list\r\n\t\t\t *\tOther errno: put on ret_folios list\r\n\t\t\t */\r\n\t\t\tswitch(rc) {\r\n\t\t\tcase -ENOMEM:\r\n\t\t\t\t/*\r\n\t\t\t\t * When memory is low, don't bother to try to migrate\r\n\t\t\t\t * other folios, just exit.\r\n\t\t\t\t */\r\n\t\t\t\tstats->nr_failed_pages += nr_pages + nr_retry_pages;\r\n\t\t\t\treturn -ENOMEM;\r\n\t\t\tcase -EAGAIN:\r\n\t\t\t\tretry++;\r\n\t\t\t\tnr_retry_pages += nr_pages;\r\n\t\t\t\tbreak;\r\n\t\t\tcase 0:\r\n\t\t\t\tstats->nr_succeeded += nr_pages;\r\n\t\t\t\tbreak;\r\n\t\t\tdefault:\r\n\t\t\t\t/*\r\n\t\t\t\t * Permanent failure (-EBUSY, etc.):\r\n\t\t\t\t * unlike -EAGAIN case, the failed folio is\r\n\t\t\t\t * removed from migration folio list and not\r\n\t\t\t\t * retried in the next outer loop.\r\n\t\t\t\t */\r\n\t\t\t\tnr_failed++;\r\n\t\t\t\tstats->nr_failed_pages += nr_pages;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t/*\r\n\t * nr_failed is number of hugetlb folios failed to be migrated.  After\r\n\t * NR_MAX_MIGRATE_PAGES_RETRY attempts, give up and count retried hugetlb\r\n\t * folios as failed.\r\n\t */\r\n\tnr_failed += retry;\r\n\tstats->nr_failed_pages += nr_retry_pages;\r\n\r\n\treturn nr_failed;\r\n}", ".igrate_pages_sync": "static int migrate_pages_sync(struct list_head *from, new_folio_t get_new_folio,\r\n\t\tfree_folio_t put_new_folio, unsigned long private,\r\n\t\tenum migrate_mode mode, int reason,\r\n\t\tstruct list_head *ret_folios, struct list_head *split_folios,\r\n\t\tstruct migrate_pages_stats *stats)\r\n{\r\n\tint rc, nr_failed = 0;\r\n\tLIST_HEAD(folios);\r\n\tstruct migrate_pages_stats astats;\r\n\r\n\tmemset(&astats, 0, sizeof(astats));\r\n\t/* Try to migrate in batch with MIGRATE_ASYNC mode firstly */\r\n\trc = migrate_pages_batch(from, get_new_folio, put_new_folio, private, MIGRATE_ASYNC,\r\n\t\t\t\t reason, &folios, split_folios, &astats,\r\n\t\t\t\t NR_MAX_MIGRATE_ASYNC_RETRY);\r\n\tstats->nr_succeeded += astats.nr_succeeded;\r\n\tstats->nr_thp_succeeded += astats.nr_thp_succeeded;\r\n\tstats->nr_thp_split += astats.nr_thp_split;\r\n\tstats->nr_split += astats.nr_split;\r\n\tif (rc < 0) {\r\n\t\tstats->nr_failed_pages += astats.nr_failed_pages;\r\n\t\tstats->nr_thp_failed += astats.nr_thp_failed;\r\n\t\tlist_splice_tail(&folios, ret_folios);\r\n\t\treturn rc;\r\n\t}\r\n\tstats->nr_thp_failed += astats.nr_thp_split;\r\n\t/*\r\n\t * Do not count rc, as pages will be retried below.\r\n\t * Count nr_split only, since it includes nr_thp_split.\r\n\t */\r\n\tnr_failed += astats.nr_split;\r\n\t/*\r\n\t * Fall back to migrate all failed folios one by one synchronously. All\r\n\t * failed folios except split THPs will be retried, so their failure\r\n\t * isn't counted\r\n\t */\r\n\tlist_splice_tail_init(&folios, from);\r\n\twhile (!list_empty(from)) {\r\n\t\tlist_move(from->next, &folios);\r\n\t\trc = migrate_pages_batch(&folios, get_new_folio, put_new_folio,\r\n\t\t\t\t\t private, mode, reason, ret_folios,\r\n\t\t\t\t\t split_folios, stats, NR_MAX_MIGRATE_SYNC_RETRY);\r\n\t\tlist_splice_tail_init(&folios, ret_folios);\r\n\t\tif (rc < 0)\r\n\t\t\treturn rc;\r\n\t\tnr_failed += rc;\r\n\t}\r\n\r\n\treturn nr_failed;\r\n}", ".igrate_pages": "int migrate_pages(struct list_head *from, new_folio_t get_new_folio,\r\n\t\tfree_folio_t put_new_folio, unsigned long private,\r\n\t\tenum migrate_mode mode, int reason, unsigned int *ret_succeeded)\r\n{\r\n\tint rc, rc_gather;\r\n\tint nr_pages;\r\n\tstruct folio *folio, *folio2;\r\n\tLIST_HEAD(folios);\r\n\tLIST_HEAD(ret_folios);\r\n\tLIST_HEAD(split_folios);\r\n\tstruct migrate_pages_stats stats;\r\n\r\n\ttrace_mm_migrate_pages_start(mode, reason);\r\n\r\n\tmemset(&stats, 0, sizeof(stats));\r\n\r\n\trc_gather = migrate_hugetlbs(from, get_new_folio, put_new_folio, private,\r\n\t\t\t\t     mode, reason, &stats, &ret_folios);\r\n\tif (rc_gather < 0)\r\n\t\tgoto out;\r\n\r\nagain:\r\n\tnr_pages = 0;\r\n\tlist_for_each_entry_safe(folio, folio2, from, lru) {\r\n\t\t/* Retried hugetlb folios will be kept in list  */\r\n\t\tif (folio_test_hugetlb(folio)) {\r\n\t\t\tlist_move_tail(&folio->lru, &ret_folios);\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\tnr_pages += folio_nr_pages(folio);\r\n\t\tif (nr_pages >= NR_MAX_BATCHED_MIGRATION)\r\n\t\t\tbreak;\r\n\t}\r\n\tif (nr_pages >= NR_MAX_BATCHED_MIGRATION)\r\n\t\tlist_cut_before(&folios, from, &folio2->lru);\r\n\telse\r\n\t\tlist_splice_init(from, &folios);\r\n\tif (mode == MIGRATE_ASYNC)\r\n\t\trc = migrate_pages_batch(&folios, get_new_folio, put_new_folio,\r\n\t\t\t\tprivate, mode, reason, &ret_folios,\r\n\t\t\t\t&split_folios, &stats,\r\n\t\t\t\tNR_MAX_MIGRATE_PAGES_RETRY);\r\n\telse\r\n\t\trc = migrate_pages_sync(&folios, get_new_folio, put_new_folio,\r\n\t\t\t\tprivate, mode, reason, &ret_folios,\r\n\t\t\t\t&split_folios, &stats);\r\n\tlist_splice_tail_init(&folios, &ret_folios);\r\n\tif (rc < 0) {\r\n\t\trc_gather = rc;\r\n\t\tlist_splice_tail(&split_folios, &ret_folios);\r\n\t\tgoto out;\r\n\t}\r\n\tif (!list_empty(&split_folios)) {\r\n\t\t/*\r\n\t\t * Failure isn't counted since all split folios of a large folio\r\n\t\t * is counted as 1 failure already.  And, we only try to migrate\r\n\t\t * with minimal effort, force MIGRATE_ASYNC mode and retry once.\r\n\t\t */\r\n\t\tmigrate_pages_batch(&split_folios, get_new_folio,\r\n\t\t\t\tput_new_folio, private, MIGRATE_ASYNC, reason,\r\n\t\t\t\t&ret_folios, NULL, &stats, 1);\r\n\t\tlist_splice_tail_init(&split_folios, &ret_folios);\r\n\t}\r\n\trc_gather += rc;\r\n\tif (!list_empty(from))\r\n\t\tgoto again;\r\nout:\r\n\t/*\r\n\t * Put the permanent failure folio back to migration list, they\r\n\t * will be put back to the right list by the caller.\r\n\t */\r\n\tlist_splice(&ret_folios, from);\r\n\r\n\t/*\r\n\t * Return 0 in case all split folios of fail-to-migrate large folios\r\n\t * are migrated successfully.\r\n\t */\r\n\tif (list_empty(from))\r\n\t\trc_gather = 0;\r\n\r\n\tcount_vm_events(PGMIGRATE_SUCCESS, stats.nr_succeeded);\r\n\tcount_vm_events(PGMIGRATE_FAIL, stats.nr_failed_pages);\r\n\tcount_vm_events(THP_MIGRATION_SUCCESS, stats.nr_thp_succeeded);\r\n\tcount_vm_events(THP_MIGRATION_FAIL, stats.nr_thp_failed);\r\n\tcount_vm_events(THP_MIGRATION_SPLIT, stats.nr_thp_split);\r\n\ttrace_mm_migrate_pages(stats.nr_succeeded, stats.nr_failed_pages,\r\n\t\t\t       stats.nr_thp_succeeded, stats.nr_thp_failed,\r\n\t\t\t       stats.nr_thp_split, stats.nr_split, mode,\r\n\t\t\t       reason);\r\n\r\n\tif (ret_succeeded)\r\n\t\t*ret_succeeded = stats.nr_succeeded;\r\n\r\n\treturn rc_gather;\r\n}", ".utback_movable_pages": "void putback_movable_pages(struct list_head *l)\r\n{\r\n\tstruct folio *folio;\r\n\tstruct folio *folio2;\r\n\r\n\tlist_for_each_entry_safe(folio, folio2, l, lru) {\r\n\t\tif (unlikely(folio_test_hugetlb(folio))) {\r\n\t\t\tfolio_putback_hugetlb(folio);\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tlist_del(&folio->lru);\r\n\t\tif (unlikely(page_has_movable_ops(&folio->page))) {\r\n\t\t\tputback_movable_ops_page(&folio->page);\r\n\t\t} else {\r\n\t\t\tnode_stat_mod_folio(folio, NR_ISOLATED_ANON +\r\n\t\t\t\t\tfolio_is_file_lru(folio), -folio_nr_pages(folio));\r\n\t\t\tfolio_putback_lru(folio);\r\n\t\t}\r\n\t}\r\n}", ".o_move_pages_to_node": "static int do_move_pages_to_node(struct list_head *pagelist, int node)\r\n{\r\n\tint err;\r\n\tstruct migration_target_control mtc = {\r\n\t\t.nid = node,\r\n\t\t.gfp_mask = GFP_HIGHUSER_MOVABLE | __GFP_THISNODE,\r\n\t\t.reason = MR_SYSCALL,\r\n\t};\r\n\r\n\terr = migrate_pages(pagelist, alloc_migration_target, NULL,\r\n\t\t(unsigned long)&mtc, MIGRATE_SYNC, MR_SYSCALL, NULL);\r\n\tif (err)\r\n\t\tputback_movable_pages(pagelist);\r\n\treturn err;\r\n}", ".tore_status": "static int store_status(int __user *status, int start, int value, int nr)\r\n{\r\n\twhile (nr-- > 0) {\r\n\t\tif (put_user(value, status + start))\r\n\t\t\treturn -EFAULT;\r\n\t\tstart++;\r\n\t}\r\n\r\n\treturn 0;\r\n}", ".ove_pages_and_store_status": "static int move_pages_and_store_status(int node,\r\n\t\tstruct list_head *pagelist, int __user *status,\r\n\t\tint start, int i, unsigned long nr_pages)\r\n{\r\n\tint err;\r\n\r\n\tif (list_empty(pagelist))\r\n\t\treturn 0;\r\n\r\n\terr = do_move_pages_to_node(pagelist, node);\r\n\tif (err) {\r\n\t\t/*\r\n\t\t * Positive err means the number of failed\r\n\t\t * pages to migrate.  Since we are going to\r\n\t\t * abort and return the number of non-migrated\r\n\t\t * pages, so need to include the rest of the\r\n\t\t * nr_pages that have not been attempted as\r\n\t\t * well.\r\n\t\t */\r\n\t\tif (err > 0)\r\n\t\t\terr += nr_pages - i;\r\n\t\treturn err;\r\n\t}\r\n\treturn store_status(status, start, node, i - start);\r\n}", ".dd_folio_for_migration": "static int add_folio_for_migration(struct mm_struct *mm, const void __user *p,\r\n\t\tint node, struct list_head *pagelist, bool migrate_all)\r\n{\r\n\tstruct vm_area_struct *vma;\r\n\tstruct folio_walk fw;\r\n\tstruct folio *folio;\r\n\tunsigned long addr;\r\n\tint err = -EFAULT;\r\n\r\n\tmmap_read_lock(mm);\r\n\taddr = (unsigned long)untagged_addr_remote(mm, p);\r\n\r\n\tvma = vma_lookup(mm, addr);\r\n\tif (vma && vma_migratable(vma)) {\r\n\t\tfolio = folio_walk_start(&fw, vma, addr, FW_ZEROPAGE);\r\n\t\tif (folio) {\r\n\t\t\terr = __add_folio_for_migration(folio, node, pagelist,\r\n\t\t\t\t\t\t\tmigrate_all);\r\n\t\t\tfolio_walk_end(&fw, vma);\r\n\t\t} else {\r\n\t\t\terr = -ENOENT;\r\n\t\t}\r\n\t}\r\n\tmmap_read_unlock(mm);\r\n\treturn err;\r\n}", ".et_compat_pages_array": "static int get_compat_pages_array(const void __user *chunk_pages[],\r\n\t\t\t\t  const void __user * __user *pages,\r\n\t\t\t\t  unsigned long chunk_offset,\r\n\t\t\t\t  unsigned long chunk_nr)\r\n{\r\n\tcompat_uptr_t __user *pages32 = (compat_uptr_t __user *)pages;\r\n\tcompat_uptr_t p;\r\n\tint i;\r\n\r\n\tfor (i = 0; i < chunk_nr; i++) {\r\n\t\tif (get_user(p, pages32 + chunk_offset + i))\r\n\t\t\treturn -EFAULT;\r\n\t\tchunk_pages[i] = compat_ptr(p);\r\n\t}\r\n\r\n\treturn 0;\r\n}", ".o_pages_stat_array": "static void do_pages_stat_array(struct mm_struct *mm, unsigned long nr_pages,\r\n\t\t\t\tconst void __user **pages, int *status)\r\n{\r\n\tunsigned long i;\r\n\r\n\tmmap_read_lock(mm);\r\n\r\n\tfor (i = 0; i < nr_pages; i++) {\r\n\t\tunsigned long addr = (unsigned long)(*pages);\r\n\t\tstruct vm_area_struct *vma;\r\n\t\tstruct folio_walk fw;\r\n\t\tstruct folio *folio;\r\n\t\tint err = -EFAULT;\r\n\r\n\t\tvma = vma_lookup(mm, addr);\r\n\t\tif (!vma)\r\n\t\t\tgoto set_status;\r\n\r\n\t\tfolio = folio_walk_start(&fw, vma, addr, FW_ZEROPAGE);\r\n\t\tif (folio) {\r\n\t\t\tif (is_zero_folio(folio) || is_huge_zero_folio(folio))\r\n\t\t\t\terr = -EFAULT;\r\n\t\t\telse if (folio_is_zone_device(folio))\r\n\t\t\t\terr = -ENOENT;\r\n\t\t\telse\r\n\t\t\t\terr = folio_nid(folio);\r\n\t\t\tfolio_walk_end(&fw, vma);\r\n\t\t} else {\r\n\t\t\terr = -ENOENT;\r\n\t\t}\r\nset_status:\r\n\t\t*status = err;\r\n\r\n\t\tpages++;\r\n\t\tstatus++;\r\n\t}\r\n\r\n\tmmap_read_unlock(mm);\r\n}", ".o_pages_move": "static int do_pages_move(struct mm_struct *mm, nodemask_t task_nodes,\r\n\t\t\t unsigned long nr_pages,\r\n\t\t\t const void __user * __user *pages,\r\n\t\t\t const int __user *nodes,\r\n\t\t\t int __user *status, int flags)\r\n{\r\n\tcompat_uptr_t __user *compat_pages = (void __user *)pages;\r\n\tint current_node = NUMA_NO_NODE;\r\n\tLIST_HEAD(pagelist);\r\n\tint start, i;\r\n\tint err = 0, err1;\r\n\r\n\tlru_cache_disable();\r\n\r\n\tfor (i = start = 0; i < nr_pages; i++) {\r\n\t\tconst void __user *p;\r\n\t\tint node;\r\n\r\n\t\terr = -EFAULT;\r\n\t\tif (in_compat_syscall()) {\r\n\t\t\tcompat_uptr_t cp;\r\n\r\n\t\t\tif (get_user(cp, compat_pages + i))\r\n\t\t\t\tgoto out_flush;\r\n\r\n\t\t\tp = compat_ptr(cp);\r\n\t\t} else {\r\n\t\t\tif (get_user(p, pages + i))\r\n\t\t\t\tgoto out_flush;\r\n\t\t}\r\n\t\tif (get_user(node, nodes + i))\r\n\t\t\tgoto out_flush;\r\n\r\n\t\terr = -ENODEV;\r\n\t\tif (node < 0 || node >= MAX_NUMNODES)\r\n\t\t\tgoto out_flush;\r\n\t\tif (!node_state(node, N_MEMORY))\r\n\t\t\tgoto out_flush;\r\n\r\n\t\terr = -EACCES;\r\n\t\tif (!node_isset(node, task_nodes))\r\n\t\t\tgoto out_flush;\r\n\r\n\t\tif (current_node == NUMA_NO_NODE) {\r\n\t\t\tcurrent_node = node;\r\n\t\t\tstart = i;\r\n\t\t} else if (node != current_node) {\r\n\t\t\terr = move_pages_and_store_status(current_node,\r\n\t\t\t\t\t&pagelist, status, start, i, nr_pages);\r\n\t\t\tif (err)\r\n\t\t\t\tgoto out;\r\n\t\t\tstart = i;\r\n\t\t\tcurrent_node = node;\r\n\t\t}\r\n\r\n\t\t/*\r\n\t\t * Errors in the page lookup or isolation are not fatal and we simply\r\n\t\t * report them via status\r\n\t\t */\r\n\t\terr = add_folio_for_migration(mm, p, current_node, &pagelist,\r\n\t\t\t\t\t      flags & MPOL_MF_MOVE_ALL);\r\n\r\n\t\tif (err > 0) {\r\n\t\t\t/* The page is successfully queued for migration */\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\t/*\r\n\t\t * If the page is already on the target node (!err), store the\r\n\t\t * node, otherwise, store the err.\r\n\t\t */\r\n\t\terr = store_status(status, i, err ? : current_node, 1);\r\n\t\tif (err)\r\n\t\t\tgoto out_flush;\r\n\r\n\t\terr = move_pages_and_store_status(current_node, &pagelist,\r\n\t\t\t\tstatus, start, i, nr_pages);\r\n\t\tif (err) {\r\n\t\t\t/* We have accounted for page i */\r\n\t\t\tif (err > 0)\r\n\t\t\t\terr--;\r\n\t\t\tgoto out;\r\n\t\t}\r\n\t\tcurrent_node = NUMA_NO_NODE;\r\n\t}\r\nout_flush:\r\n\t/* Make sure we do not overwrite the existing error */\r\n\terr1 = move_pages_and_store_status(current_node, &pagelist,\r\n\t\t\t\tstatus, start, i, nr_pages);\r\n\tif (err >= 0)\r\n\t\terr = err1;\r\nout:\r\n\tlru_cache_enable();\r\n\treturn err;\r\n}", ".o_pages_stat": "static int do_pages_stat(struct mm_struct *mm, unsigned long nr_pages,\r\n\t\t\t const void __user * __user *pages,\r\n\t\t\t int __user *status)\r\n{\r\n#define DO_PAGES_STAT_CHUNK_NR 16UL\r\n\tconst void __user *chunk_pages[DO_PAGES_STAT_CHUNK_NR];\r\n\tint chunk_status[DO_PAGES_STAT_CHUNK_NR];\r\n\tunsigned long chunk_offset = 0;\r\n\r\n\twhile (nr_pages) {\r\n\t\tunsigned long chunk_nr = min(nr_pages, DO_PAGES_STAT_CHUNK_NR);\r\n\r\n\t\tif (in_compat_syscall()) {\r\n\t\t\tif (get_compat_pages_array(chunk_pages, pages,\r\n\t\t\t\t\t\t   chunk_offset, chunk_nr))\r\n\t\t\t\tbreak;\r\n\t\t} else {\r\n\t\t\tif (copy_from_user(chunk_pages, pages + chunk_offset,\r\n\t\t\t\t      chunk_nr * sizeof(*chunk_pages)))\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\tdo_pages_stat_array(mm, chunk_nr, chunk_pages, chunk_status);\r\n\r\n\t\tif (copy_to_user(status + chunk_offset, chunk_status,\r\n\t\t\t\t chunk_nr * sizeof(*status)))\r\n\t\t\tbreak;\r\n\r\n\t\tchunk_offset += chunk_nr;\r\n\t\tnr_pages -= chunk_nr;\r\n\t}\r\n\treturn nr_pages ? -EFAULT : 0;\r\n}", ".igrate_balanced_pgdat": "static bool migrate_balanced_pgdat(struct pglist_data *pgdat,\r\n\t\t\t\t   unsigned long nr_migrate_pages)\r\n{\r\n\tint z;\r\n\r\n\tfor (z = pgdat->nr_zones - 1; z >= 0; z--) {\r\n\t\tstruct zone *zone = pgdat->node_zones + z;\r\n\r\n\t\tif (!managed_zone(zone))\r\n\t\t\tcontinue;\r\n\r\n\t\t/* Avoid waking kswapd by allocating pages_to_migrate pages. */\r\n\t\tif (!zone_watermark_ok(zone, 0,\r\n\t\t\t\t       high_wmark_pages(zone) +\r\n\t\t\t\t       nr_migrate_pages,\r\n\t\t\t\t       ZONE_MOVABLE, ALLOC_CMA))\r\n\t\t\tcontinue;\r\n\t\treturn true;\r\n\t}\r\n\treturn false;\r\n}"}, "callee": {".solate_folio_to_list": "bool isolate_folio_to_list(struct folio *folio, struct list_head *list)\r\n{\r\n\tif (folio_test_hugetlb(folio))\r\n\t\treturn folio_isolate_hugetlb(folio, list);\r\n\r\n\tif (page_has_movable_ops(&folio->page)) {\r\n\t\tif (!isolate_movable_ops_page(&folio->page,\r\n\t\t\t\t\t      ISOLATE_UNEVICTABLE))\r\n\t\t\treturn false;\r\n\t} else {\r\n\t\tif (!folio_isolate_lru(folio))\r\n\t\t\treturn false;\r\n\t\tnode_stat_add_folio(folio, NR_ISOLATED_ANON +\r\n\t\t\t\t    folio_is_file_lru(folio));\r\n\t}\r\n\tlist_add(&folio->lru, list);\r\n\treturn true;\r\n}", ".utback_movable_pages": "void putback_movable_pages(struct list_head *l)\r\n{\r\n\tstruct folio *folio;\r\n\tstruct folio *folio2;\r\n\r\n\tlist_for_each_entry_safe(folio, folio2, l, lru) {\r\n\t\tif (unlikely(folio_test_hugetlb(folio))) {\r\n\t\t\tfolio_putback_hugetlb(folio);\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tlist_del(&folio->lru);\r\n\t\tif (unlikely(page_has_movable_ops(&folio->page))) {\r\n\t\t\tputback_movable_ops_page(&folio->page);\r\n\t\t} else {\r\n\t\t\tnode_stat_mod_folio(folio, NR_ISOLATED_ANON +\r\n\t\t\t\t\tfolio_is_file_lru(folio), -folio_nr_pages(folio));\r\n\t\t\tfolio_putback_lru(folio);\r\n\t\t}\r\n\t}\r\n}", ".igrate_folio_move": "static int migrate_folio_move(free_folio_t put_new_folio, unsigned long private,\r\n\t\t\t      struct folio *src, struct folio *dst,\r\n\t\t\t      enum migrate_mode mode, enum migrate_reason reason,\r\n\t\t\t      struct list_head *ret)\r\n{\r\n\tint rc;\r\n\tint old_page_state = 0;\r\n\tstruct anon_vma *anon_vma = NULL;\r\n\tstruct list_head *prev;\r\n\r\n\t__migrate_folio_extract(dst, &old_page_state, &anon_vma);\r\n\tprev = dst->lru.prev;\r\n\tlist_del(&dst->lru);\r\n\r\n\tif (unlikely(page_has_movable_ops(&src->page))) {\r\n\t\trc = migrate_movable_ops_page(&dst->page, &src->page, mode);\r\n\t\tif (rc)\r\n\t\t\tgoto out;\r\n\t\tgoto out_unlock_both;\r\n\t}\r\n\r\n\trc = move_to_new_folio(dst, src, mode);\r\n\tif (rc)\r\n\t\tgoto out;\r\n\r\n\t/*\r\n\t * When successful, push dst to LRU immediately: so that if it\r\n\t * turns out to be an mlocked page, remove_migration_ptes() will\r\n\t * automatically build up the correct dst->mlock_count for it.\r\n\t *\r\n\t * We would like to do something similar for the old page, when\r\n\t * unsuccessful, and other cases when a page has been temporarily\r\n\t * isolated from the unevictable LRU: but this case is the easiest.\r\n\t */\r\n\tfolio_add_lru(dst);\r\n\tif (old_page_state & PAGE_WAS_MLOCKED)\r\n\t\tlru_add_drain();\r\n\r\n\tif (old_page_state & PAGE_WAS_MAPPED)\r\n\t\tremove_migration_ptes(src, dst, 0);\r\n\r\nout_unlock_both:\r\n\tfolio_unlock(dst);\r\n\tfolio_set_owner_migrate_reason(dst, reason);\r\n\t/*\r\n\t * If migration is successful, decrease refcount of dst,\r\n\t * which will not free the page because new page owner increased\r\n\t * refcounter.\r\n\t */\r\n\tfolio_put(dst);\r\n\r\n\t/*\r\n\t * A folio that has been migrated has all references removed\r\n\t * and will be freed.\r\n\t */\r\n\tlist_del(&src->lru);\r\n\t/* Drop an anon_vma reference if we took one */\r\n\tif (anon_vma)\r\n\t\tput_anon_vma(anon_vma);\r\n\tfolio_unlock(src);\r\n\tmigrate_folio_done(src, reason);\r\n\r\n\treturn rc;\r\nout:\r\n\t/*\r\n\t * A folio that has not been migrated will be restored to\r\n\t * right list unless we want to retry.\r\n\t */\r\n\tif (rc == -EAGAIN) {\r\n\t\tlist_add(&dst->lru, prev);\r\n\t\t__migrate_folio_record(dst, old_page_state, anon_vma);\r\n\t\treturn rc;\r\n\t}\r\n\r\n\tmigrate_folio_undo_src(src, old_page_state & PAGE_WAS_MAPPED,\r\n\t\t\t       anon_vma, true, ret);\r\n\tmigrate_folio_undo_dst(dst, true, put_new_folio, private);\r\n\r\n\treturn rc;\r\n}", ".o_move_pages_to_node": "static int do_move_pages_to_node(struct list_head *pagelist, int node)\r\n{\r\n\tint err;\r\n\tstruct migration_target_control mtc = {\r\n\t\t.nid = node,\r\n\t\t.gfp_mask = GFP_HIGHUSER_MOVABLE | __GFP_THISNODE,\r\n\t\t.reason = MR_SYSCALL,\r\n\t};\r\n\r\n\terr = migrate_pages(pagelist, alloc_migration_target, NULL,\r\n\t\t(unsigned long)&mtc, MIGRATE_SYNC, MR_SYSCALL, NULL);\r\n\tif (err)\r\n\t\tputback_movable_pages(pagelist);\r\n\treturn err;\r\n}", ".igrate_misplaced_folio": "int migrate_misplaced_folio(struct folio *folio, int node)\r\n{\r\n\tpg_data_t *pgdat = NODE_DATA(node);\r\n\tint nr_remaining;\r\n\tunsigned int nr_succeeded;\r\n\tLIST_HEAD(migratepages);\r\n\tstruct mem_cgroup *memcg = get_mem_cgroup_from_folio(folio);\r\n\tstruct lruvec *lruvec = mem_cgroup_lruvec(memcg, pgdat);\r\n\r\n\tlist_add(&folio->lru, &migratepages);\r\n\tnr_remaining = migrate_pages(&migratepages, alloc_misplaced_dst_folio,\r\n\t\t\t\t     NULL, node, MIGRATE_ASYNC,\r\n\t\t\t\t     MR_NUMA_MISPLACED, &nr_succeeded);\r\n\tif (nr_remaining && !list_empty(&migratepages))\r\n\t\tputback_movable_pages(&migratepages);\r\n\tif (nr_succeeded) {\r\n\t\tcount_vm_numa_events(NUMA_PAGE_MIGRATE, nr_succeeded);\r\n\t\tcount_memcg_events(memcg, NUMA_PAGE_MIGRATE, nr_succeeded);\r\n\t\tif ((sysctl_numa_balancing_mode & NUMA_BALANCING_MEMORY_TIERING)\r\n\t\t    && !node_is_toptier(folio_nid(folio))\r\n\t\t    && node_is_toptier(node))\r\n\t\t\tmod_lruvec_state(lruvec, PGPROMOTE_SUCCESS, nr_succeeded);\r\n\t}\r\n\tmem_cgroup_put(memcg);\r\n\tBUG_ON(!list_empty(&migratepages));\r\n\treturn nr_remaining ? -EAGAIN : 0;\r\n}", ".emove_migration_pte": "static bool remove_migration_pte(struct folio *folio,\r\n\t\tstruct vm_area_struct *vma, unsigned long addr, void *arg)\r\n{\r\n\tstruct rmap_walk_arg *rmap_walk_arg = arg;\r\n\tDEFINE_FOLIO_VMA_WALK(pvmw, rmap_walk_arg->folio, vma, addr, PVMW_SYNC | PVMW_MIGRATION);\r\n\r\n\twhile (page_vma_mapped_walk(&pvmw)) {\r\n\t\trmap_t rmap_flags = RMAP_NONE;\r\n\t\tpte_t old_pte;\r\n\t\tpte_t pte;\r\n\t\tswp_entry_t entry;\r\n\t\tstruct page *new;\r\n\t\tunsigned long idx = 0;\r\n\r\n\t\t/* pgoff is invalid for ksm pages, but they are never large */\r\n\t\tif (folio_test_large(folio) && !folio_test_hugetlb(folio))\r\n\t\t\tidx = linear_page_index(vma, pvmw.address) - pvmw.pgoff;\r\n\t\tnew = folio_page(folio, idx);\r\n\r\n#ifdef CONFIG_ARCH_ENABLE_THP_MIGRATION\r\n\t\t/* PMD-mapped THP migration entry */\r\n\t\tif (!pvmw.pte) {\r\n\t\t\tVM_BUG_ON_FOLIO(folio_test_hugetlb(folio) ||\r\n\t\t\t\t\t!folio_test_pmd_mappable(folio), folio);\r\n\t\t\tremove_migration_pmd(&pvmw, new);\r\n\t\t\tcontinue;\r\n\t\t}\r\n#endif\r\n\t\tif (rmap_walk_arg->map_unused_to_zeropage &&\r\n\t\t    try_to_map_unused_to_zeropage(&pvmw, folio, idx))\r\n\t\t\tcontinue;\r\n\r\n\t\tfolio_get(folio);\r\n\t\tpte = mk_pte(new, READ_ONCE(vma->vm_page_prot));\r\n\t\told_pte = ptep_get(pvmw.pte);\r\n\r\n\t\tentry = pte_to_swp_entry(old_pte);\r\n\t\tif (!is_migration_entry_young(entry))\r\n\t\t\tpte = pte_mkold(pte);\r\n\t\tif (folio_test_dirty(folio) && is_migration_entry_dirty(entry))\r\n\t\t\tpte = pte_mkdirty(pte);\r\n\t\tif (pte_swp_soft_dirty(old_pte))\r\n\t\t\tpte = pte_mksoft_dirty(pte);\r\n\t\telse\r\n\t\t\tpte = pte_clear_soft_dirty(pte);\r\n\r\n\t\tif (is_writable_migration_entry(entry))\r\n\t\t\tpte = pte_mkwrite(pte, vma);\r\n\t\telse if (pte_swp_uffd_wp(old_pte))\r\n\t\t\tpte = pte_mkuffd_wp(pte);\r\n\r\n\t\tif (folio_test_anon(folio) && !is_readable_migration_entry(entry))\r\n\t\t\trmap_flags |= RMAP_EXCLUSIVE;\r\n\r\n\t\tif (unlikely(is_device_private_page(new))) {\r\n\t\t\tif (pte_write(pte))\r\n\t\t\t\tentry = make_writable_device_private_entry(\r\n\t\t\t\t\t\t\tpage_to_pfn(new));\r\n\t\t\telse\r\n\t\t\t\tentry = make_readable_device_private_entry(\r\n\t\t\t\t\t\t\tpage_to_pfn(new));\r\n\t\t\tpte = swp_entry_to_pte(entry);\r\n\t\t\tif (pte_swp_soft_dirty(old_pte))\r\n\t\t\t\tpte = pte_swp_mksoft_dirty(pte);\r\n\t\t\tif (pte_swp_uffd_wp(old_pte))\r\n\t\t\t\tpte = pte_swp_mkuffd_wp(pte);\r\n\t\t}\r\n\r\n#ifdef CONFIG_HUGETLB_PAGE\r\n\t\tif (folio_test_hugetlb(folio)) {\r\n\t\t\tstruct hstate *h = hstate_vma(vma);\r\n\t\t\tunsigned int shift = huge_page_shift(h);\r\n\t\t\tunsigned long psize = huge_page_size(h);\r\n\r\n\t\t\tpte = arch_make_huge_pte(pte, shift, vma->vm_flags);\r\n\t\t\tif (folio_test_anon(folio))\r\n\t\t\t\thugetlb_add_anon_rmap(folio, vma, pvmw.address,\r\n\t\t\t\t\t\t      rmap_flags);\r\n\t\t\telse\r\n\t\t\t\thugetlb_add_file_rmap(folio);\r\n\t\t\tset_huge_pte_at(vma->vm_mm, pvmw.address, pvmw.pte, pte,\r\n\t\t\t\t\tpsize);\r\n\t\t} else\r\n#endif\r\n\t\t{\r\n\t\t\tif (folio_test_anon(folio))\r\n\t\t\t\tfolio_add_anon_rmap_pte(folio, new, vma,\r\n\t\t\t\t\t\t\tpvmw.address, rmap_flags);\r\n\t\t\telse\r\n\t\t\t\tfolio_add_file_rmap_pte(folio, new, vma);\r\n\t\t\tset_pte_at(vma->vm_mm, pvmw.address, pvmw.pte, pte);\r\n\t\t}\r\n\t\tif (READ_ONCE(vma->vm_flags) & VM_LOCKED)\r\n\t\t\tmlock_drain_local();\r\n\r\n\t\ttrace_remove_migration_pte(pvmw.address, pte_val(pte),\r\n\t\t\t\t\t   compound_order(new));\r\n\r\n\t\t/* No need to invalidate - it was non-present before */\r\n\t\tupdate_mmu_cache(vma, pvmw.address, pvmw.pte);\r\n\t}\r\n\r\n\treturn true;\r\n}", ".emove_migration_ptes": "void remove_migration_ptes(struct folio *src, struct folio *dst, int flags)\r\n{\r\n\tstruct rmap_walk_arg rmap_walk_arg = {\r\n\t\t.folio = src,\r\n\t\t.map_unused_to_zeropage = flags & RMP_USE_SHARED_ZEROPAGE,\r\n\t};\r\n\r\n\tstruct rmap_walk_control rwc = {\r\n\t\t.rmap_one = remove_migration_pte,\r\n\t\t.arg = &rmap_walk_arg,\r\n\t};\r\n\r\n\tVM_BUG_ON_FOLIO((flags & RMP_USE_SHARED_ZEROPAGE) && (src != dst), src);\r\n\r\n\tif (flags & RMP_LOCKED)\r\n\t\trmap_walk_locked(dst, &rwc);\r\n\telse\r\n\t\trmap_walk(dst, &rwc);\r\n}", ".igrate_folio_undo_src": "static void migrate_folio_undo_src(struct folio *src,\r\n\t\t\t\t   int page_was_mapped,\r\n\t\t\t\t   struct anon_vma *anon_vma,\r\n\t\t\t\t   bool locked,\r\n\t\t\t\t   struct list_head *ret)\r\n{\r\n\tif (page_was_mapped)\r\n\t\tremove_migration_ptes(src, src, 0);\r\n\t/* Drop an anon_vma reference if we took one */\r\n\tif (anon_vma)\r\n\t\tput_anon_vma(anon_vma);\r\n\tif (locked)\r\n\t\tfolio_unlock(src);\r\n\tif (ret)\r\n\t\tlist_move_tail(&src->lru, ret);\r\n}", ".nmap_and_move_huge_page": "static int unmap_and_move_huge_page(new_folio_t get_new_folio,\r\n\t\tfree_folio_t put_new_folio, unsigned long private,\r\n\t\tstruct folio *src, int force, enum migrate_mode mode,\r\n\t\tint reason, struct list_head *ret)\r\n{\r\n\tstruct folio *dst;\r\n\tint rc = -EAGAIN;\r\n\tint page_was_mapped = 0;\r\n\tstruct anon_vma *anon_vma = NULL;\r\n\tstruct address_space *mapping = NULL;\r\n\r\n\tif (folio_ref_count(src) == 1) {\r\n\t\t/* page was freed from under us. So we are done. */\r\n\t\tfolio_putback_hugetlb(src);\r\n\t\treturn 0;\r\n\t}\r\n\r\n\tdst = get_new_folio(src, private);\r\n\tif (!dst)\r\n\t\treturn -ENOMEM;\r\n\r\n\tif (!folio_trylock(src)) {\r\n\t\tif (!force)\r\n\t\t\tgoto out;\r\n\t\tswitch (mode) {\r\n\t\tcase MIGRATE_SYNC:\r\n\t\t\tbreak;\r\n\t\tdefault:\r\n\t\t\tgoto out;\r\n\t\t}\r\n\t\tfolio_lock(src);\r\n\t}\r\n\r\n\t/*\r\n\t * Check for pages which are in the process of being freed.  Without\r\n\t * folio_mapping() set, hugetlbfs specific move page routine will not\r\n\t * be called and we could leak usage counts for subpools.\r\n\t */\r\n\tif (hugetlb_folio_subpool(src) && !folio_mapping(src)) {\r\n\t\trc = -EBUSY;\r\n\t\tgoto out_unlock;\r\n\t}\r\n\r\n\tif (folio_test_anon(src))\r\n\t\tanon_vma = folio_get_anon_vma(src);\r\n\r\n\tif (unlikely(!folio_trylock(dst)))\r\n\t\tgoto put_anon;\r\n\r\n\tif (folio_mapped(src)) {\r\n\t\tenum ttu_flags ttu = 0;\r\n\r\n\t\tif (!folio_test_anon(src)) {\r\n\t\t\t/*\r\n\t\t\t * In shared mappings, try_to_unmap could potentially\r\n\t\t\t * call huge_pmd_unshare.  Because of this, take\r\n\t\t\t * semaphore in write mode here and set TTU_RMAP_LOCKED\r\n\t\t\t * to let lower levels know we have taken the lock.\r\n\t\t\t */\r\n\t\t\tmapping = hugetlb_folio_mapping_lock_write(src);\r\n\t\t\tif (unlikely(!mapping))\r\n\t\t\t\tgoto unlock_put_anon;\r\n\r\n\t\t\tttu = TTU_RMAP_LOCKED;\r\n\t\t}\r\n\r\n\t\ttry_to_migrate(src, ttu);\r\n\t\tpage_was_mapped = 1;\r\n\r\n\t\tif (ttu & TTU_RMAP_LOCKED)\r\n\t\t\ti_mmap_unlock_write(mapping);\r\n\t}\r\n\r\n\tif (!folio_mapped(src))\r\n\t\trc = move_to_new_folio(dst, src, mode);\r\n\r\n\tif (page_was_mapped)\r\n\t\tremove_migration_ptes(src, !rc ? dst : src, 0);\r\n\r\nunlock_put_anon:\r\n\tfolio_unlock(dst);\r\n\r\nput_anon:\r\n\tif (anon_vma)\r\n\t\tput_anon_vma(anon_vma);\r\n\r\n\tif (!rc) {\r\n\t\tmove_hugetlb_state(src, dst, reason);\r\n\t\tput_new_folio = NULL;\r\n\t}\r\n\r\nout_unlock:\r\n\tfolio_unlock(src);\r\nout:\r\n\tif (!rc)\r\n\t\tfolio_putback_hugetlb(src);\r\n\telse if (rc != -EAGAIN)\r\n\t\tlist_move_tail(&src->lru, ret);\r\n\r\n\t/*\r\n\t * If migration was not successful and there's a freeing callback,\r\n\t * return the folio to that special allocator. Otherwise, simply drop\r\n\t * our additional reference.\r\n\t */\r\n\tif (put_new_folio)\r\n\t\tput_new_folio(dst, private);\r\n\telse\r\n\t\tfolio_put(dst);\r\n\r\n\treturn rc;\r\n}", ".allback_migrate_folio": "static int fallback_migrate_folio(struct address_space *mapping,\r\n\t\tstruct folio *dst, struct folio *src, enum migrate_mode mode)\r\n{\r\n\tWARN_ONCE(mapping->a_ops->writepages,\r\n\t\t\t\"%ps does not implement migrate_folio\\n\",\r\n\t\t\tmapping->a_ops);\r\n\tif (folio_test_dirty(src))\r\n\t\treturn -EBUSY;\r\n\r\n\t/*\r\n\t * Filesystem may have private data at folio->private that we\r\n\t * can't migrate automatically.\r\n\t */\r\n\tif (!filemap_release_folio(src, GFP_KERNEL))\r\n\t\treturn mode == MIGRATE_SYNC ? -EAGAIN : -EBUSY;\r\n\r\n\treturn migrate_folio(mapping, dst, src, mode);\r\n}", ".ove_to_new_folio": "static int move_to_new_folio(struct folio *dst, struct folio *src,\r\n\t\t\t\tenum migrate_mode mode)\r\n{\r\n\tstruct address_space *mapping = folio_mapping(src);\r\n\tint rc = -EAGAIN;\r\n\r\n\tVM_BUG_ON_FOLIO(!folio_test_locked(src), src);\r\n\tVM_BUG_ON_FOLIO(!folio_test_locked(dst), dst);\r\n\r\n\tif (!mapping)\r\n\t\trc = migrate_folio(mapping, dst, src, mode);\r\n\telse if (mapping_inaccessible(mapping))\r\n\t\trc = -EOPNOTSUPP;\r\n\telse if (mapping->a_ops->migrate_folio)\r\n\t\t/*\r\n\t\t * Most folios have a mapping and most filesystems\r\n\t\t * provide a migrate_folio callback. Anonymous folios\r\n\t\t * are part of swap space which also has its own\r\n\t\t * migrate_folio callback. This is the most common path\r\n\t\t * for page migration.\r\n\t\t */\r\n\t\trc = mapping->a_ops->migrate_folio(mapping, dst, src,\r\n\t\t\t\t\t\t\tmode);\r\n\telse\r\n\t\trc = fallback_migrate_folio(mapping, dst, src, mode);\r\n\r\n\tif (!rc) {\r\n\t\t/*\r\n\t\t * For pagecache folios, src->mapping must be cleared before src\r\n\t\t * is freed. Anonymous folios must stay anonymous until freed.\r\n\t\t */\r\n\t\tif (!folio_test_anon(src))\r\n\t\t\tsrc->mapping = NULL;\r\n\r\n\t\tif (likely(!folio_is_zone_device(dst)))\r\n\t\t\tflush_dcache_folio(dst);\r\n\t}\r\n\treturn rc;\r\n}", ".igrate_pages_batch": "static int migrate_pages_batch(struct list_head *from,\r\n\t\tnew_folio_t get_new_folio, free_folio_t put_new_folio,\r\n\t\tunsigned long private, enum migrate_mode mode, int reason,\r\n\t\tstruct list_head *ret_folios, struct list_head *split_folios,\r\n\t\tstruct migrate_pages_stats *stats, int nr_pass)\r\n{\r\n\tint retry = 1;\r\n\tint thp_retry = 1;\r\n\tint nr_failed = 0;\r\n\tint nr_retry_pages = 0;\r\n\tint pass = 0;\r\n\tbool is_thp = false;\r\n\tbool is_large = false;\r\n\tstruct folio *folio, *folio2, *dst = NULL;\r\n\tint rc, rc_saved = 0, nr_pages;\r\n\tLIST_HEAD(unmap_folios);\r\n\tLIST_HEAD(dst_folios);\r\n\tbool nosplit = (reason == MR_NUMA_MISPLACED);\r\n\r\n\tVM_WARN_ON_ONCE(mode != MIGRATE_ASYNC &&\r\n\t\t\t!list_empty(from) && !list_is_singular(from));\r\n\r\n\tfor (pass = 0; pass < nr_pass && retry; pass++) {\r\n\t\tretry = 0;\r\n\t\tthp_retry = 0;\r\n\t\tnr_retry_pages = 0;\r\n\r\n\t\tlist_for_each_entry_safe(folio, folio2, from, lru) {\r\n\t\t\tis_large = folio_test_large(folio);\r\n\t\t\tis_thp = folio_test_pmd_mappable(folio);\r\n\t\t\tnr_pages = folio_nr_pages(folio);\r\n\r\n\t\t\tcond_resched();\r\n\r\n\t\t\t/*\r\n\t\t\t * The rare folio on the deferred split list should\r\n\t\t\t * be split now. It should not count as a failure:\r\n\t\t\t * but increment nr_failed because, without doing so,\r\n\t\t\t * migrate_pages() may report success with (split but\r\n\t\t\t * unmigrated) pages still on its fromlist; whereas it\r\n\t\t\t * always reports success when its fromlist is empty.\r\n\t\t\t * stats->nr_thp_failed should be increased too,\r\n\t\t\t * otherwise stats inconsistency will happen when\r\n\t\t\t * migrate_pages_batch is called via migrate_pages()\r\n\t\t\t * with MIGRATE_SYNC and MIGRATE_ASYNC.\r\n\t\t\t *\r\n\t\t\t * Only check it without removing it from the list.\r\n\t\t\t * Since the folio can be on deferred_split_scan()\r\n\t\t\t * local list and removing it can cause the local list\r\n\t\t\t * corruption. Folio split process below can handle it\r\n\t\t\t * with the help of folio_ref_freeze().\r\n\t\t\t *\r\n\t\t\t * nr_pages > 2 is needed to avoid checking order-1\r\n\t\t\t * page cache folios. They exist, in contrast to\r\n\t\t\t * non-existent order-1 anonymous folios, and do not\r\n\t\t\t * use _deferred_list.\r\n\t\t\t */\r\n\t\t\tif (nr_pages > 2 &&\r\n\t\t\t   !list_empty(&folio->_deferred_list) &&\r\n\t\t\t   folio_test_partially_mapped(folio)) {\r\n\t\t\t\tif (!try_split_folio(folio, split_folios, mode)) {\r\n\t\t\t\t\tnr_failed++;\r\n\t\t\t\t\tstats->nr_thp_failed += is_thp;\r\n\t\t\t\t\tstats->nr_thp_split += is_thp;\r\n\t\t\t\t\tstats->nr_split++;\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t/*\r\n\t\t\t * Large folio migration might be unsupported or\r\n\t\t\t * the allocation might be failed so we should retry\r\n\t\t\t * on the same folio with the large folio split\r\n\t\t\t * to normal folios.\r\n\t\t\t *\r\n\t\t\t * Split folios are put in split_folios, and\r\n\t\t\t * we will migrate them after the rest of the\r\n\t\t\t * list is processed.\r\n\t\t\t */\r\n\t\t\tif (!thp_migration_supported() && is_thp) {\r\n\t\t\t\tnr_failed++;\r\n\t\t\t\tstats->nr_thp_failed++;\r\n\t\t\t\tif (!try_split_folio(folio, split_folios, mode)) {\r\n\t\t\t\t\tstats->nr_thp_split++;\r\n\t\t\t\t\tstats->nr_split++;\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tstats->nr_failed_pages += nr_pages;\r\n\t\t\t\tlist_move_tail(&folio->lru, ret_folios);\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\t/*\r\n\t\t\t * If we are holding the last folio reference, the folio\r\n\t\t\t * was freed from under us, so just drop our reference.\r\n\t\t\t */\r\n\t\t\tif (likely(!page_has_movable_ops(&folio->page)) &&\r\n\t\t\t    folio_ref_count(folio) == 1) {\r\n\t\t\t\tfolio_clear_active(folio);\r\n\t\t\t\tfolio_clear_unevictable(folio);\r\n\t\t\t\tlist_del(&folio->lru);\r\n\t\t\t\tmigrate_folio_done(folio, reason);\r\n\t\t\t\tstats->nr_succeeded += nr_pages;\r\n\t\t\t\tstats->nr_thp_succeeded += is_thp;\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\trc = migrate_folio_unmap(get_new_folio, put_new_folio,\r\n\t\t\t\t\tprivate, folio, &dst, mode, ret_folios);\r\n\t\t\t/*\r\n\t\t\t * The rules are:\r\n\t\t\t *\t0: folio will be put on unmap_folios list,\r\n\t\t\t *\t   dst folio put on dst_folios list\r\n\t\t\t *\t-EAGAIN: stay on the from list\r\n\t\t\t *\t-ENOMEM: stay on the from list\r\n\t\t\t *\tOther errno: put on ret_folios list\r\n\t\t\t */\r\n\t\t\tswitch(rc) {\r\n\t\t\tcase -ENOMEM:\r\n\t\t\t\t/*\r\n\t\t\t\t * When memory is low, don't bother to try to migrate\r\n\t\t\t\t * other folios, move unmapped folios, then exit.\r\n\t\t\t\t */\r\n\t\t\t\tnr_failed++;\r\n\t\t\t\tstats->nr_thp_failed += is_thp;\r\n\t\t\t\t/* Large folio NUMA faulting doesn't split to retry. */\r\n\t\t\t\tif (is_large && !nosplit) {\r\n\t\t\t\t\tint ret = try_split_folio(folio, split_folios, mode);\r\n\r\n\t\t\t\t\tif (!ret) {\r\n\t\t\t\t\t\tstats->nr_thp_split += is_thp;\r\n\t\t\t\t\t\tstats->nr_split++;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t} else if (reason == MR_LONGTERM_PIN &&\r\n\t\t\t\t\t\t   ret == -EAGAIN) {\r\n\t\t\t\t\t\t/*\r\n\t\t\t\t\t\t * Try again to split large folio to\r\n\t\t\t\t\t\t * mitigate the failure of longterm pinning.\r\n\t\t\t\t\t\t */\r\n\t\t\t\t\t\tretry++;\r\n\t\t\t\t\t\tthp_retry += is_thp;\r\n\t\t\t\t\t\tnr_retry_pages += nr_pages;\r\n\t\t\t\t\t\t/* Undo duplicated failure counting. */\r\n\t\t\t\t\t\tnr_failed--;\r\n\t\t\t\t\t\tstats->nr_thp_failed -= is_thp;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tstats->nr_failed_pages += nr_pages + nr_retry_pages;\r\n\t\t\t\t/* nr_failed isn't updated for not used */\r\n\t\t\t\tstats->nr_thp_failed += thp_retry;\r\n\t\t\t\trc_saved = rc;\r\n\t\t\t\tif (list_empty(&unmap_folios))\r\n\t\t\t\t\tgoto out;\r\n\t\t\t\telse\r\n\t\t\t\t\tgoto move;\r\n\t\t\tcase -EAGAIN:\r\n\t\t\t\tretry++;\r\n\t\t\t\tthp_retry += is_thp;\r\n\t\t\t\tnr_retry_pages += nr_pages;\r\n\t\t\t\tbreak;\r\n\t\t\tcase 0:\r\n\t\t\t\tlist_move_tail(&folio->lru, &unmap_folios);\r\n\t\t\t\tlist_add_tail(&dst->lru, &dst_folios);\r\n\t\t\t\tbreak;\r\n\t\t\tdefault:\r\n\t\t\t\t/*\r\n\t\t\t\t * Permanent failure (-EBUSY, etc.):\r\n\t\t\t\t * unlike -EAGAIN case, the failed folio is\r\n\t\t\t\t * removed from migration folio list and not\r\n\t\t\t\t * retried in the next outer loop.\r\n\t\t\t\t */\r\n\t\t\t\tnr_failed++;\r\n\t\t\t\tstats->nr_thp_failed += is_thp;\r\n\t\t\t\tstats->nr_failed_pages += nr_pages;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tnr_failed += retry;\r\n\tstats->nr_thp_failed += thp_retry;\r\n\tstats->nr_failed_pages += nr_retry_pages;\r\nmove:\r\n\t/* Flush TLBs for all unmapped folios */\r\n\ttry_to_unmap_flush();\r\n\r\n\tretry = 1;\r\n\tfor (pass = 0; pass < nr_pass && retry; pass++) {\r\n\t\tretry = 0;\r\n\t\tthp_retry = 0;\r\n\t\tnr_retry_pages = 0;\r\n\r\n\t\t/* Move the unmapped folios */\r\n\t\tmigrate_folios_move(&unmap_folios, &dst_folios,\r\n\t\t\t\tput_new_folio, private, mode, reason,\r\n\t\t\t\tret_folios, stats, &retry, &thp_retry,\r\n\t\t\t\t&nr_failed, &nr_retry_pages);\r\n\t}\r\n\tnr_failed += retry;\r\n\tstats->nr_thp_failed += thp_retry;\r\n\tstats->nr_failed_pages += nr_retry_pages;\r\n\r\n\trc = rc_saved ? : nr_failed;\r\nout:\r\n\t/* Cleanup remaining folios */\r\n\tmigrate_folios_undo(&unmap_folios, &dst_folios,\r\n\t\t\tput_new_folio, private, ret_folios);\r\n\r\n\treturn rc;\r\n}", ".igrate_folios_move": "static void migrate_folios_move(struct list_head *src_folios,\r\n\t\tstruct list_head *dst_folios,\r\n\t\tfree_folio_t put_new_folio, unsigned long private,\r\n\t\tenum migrate_mode mode, int reason,\r\n\t\tstruct list_head *ret_folios,\r\n\t\tstruct migrate_pages_stats *stats,\r\n\t\tint *retry, int *thp_retry, int *nr_failed,\r\n\t\tint *nr_retry_pages)\r\n{\r\n\tstruct folio *folio, *folio2, *dst, *dst2;\r\n\tbool is_thp;\r\n\tint nr_pages;\r\n\tint rc;\r\n\r\n\tdst = list_first_entry(dst_folios, struct folio, lru);\r\n\tdst2 = list_next_entry(dst, lru);\r\n\tlist_for_each_entry_safe(folio, folio2, src_folios, lru) {\r\n\t\tis_thp = folio_test_large(folio) && folio_test_pmd_mappable(folio);\r\n\t\tnr_pages = folio_nr_pages(folio);\r\n\r\n\t\tcond_resched();\r\n\r\n\t\trc = migrate_folio_move(put_new_folio, private,\r\n\t\t\t\tfolio, dst, mode,\r\n\t\t\t\treason, ret_folios);\r\n\t\t/*\r\n\t\t * The rules are:\r\n\t\t *\t0: folio will be freed\r\n\t\t *\t-EAGAIN: stay on the unmap_folios list\r\n\t\t *\tOther errno: put on ret_folios list\r\n\t\t */\r\n\t\tswitch (rc) {\r\n\t\tcase -EAGAIN:\r\n\t\t\t*retry += 1;\r\n\t\t\t*thp_retry += is_thp;\r\n\t\t\t*nr_retry_pages += nr_pages;\r\n\t\t\tbreak;\r\n\t\tcase 0:\r\n\t\t\tstats->nr_succeeded += nr_pages;\r\n\t\t\tstats->nr_thp_succeeded += is_thp;\r\n\t\t\tbreak;\r\n\t\tdefault:\r\n\t\t\t*nr_failed += 1;\r\n\t\t\tstats->nr_thp_failed += is_thp;\r\n\t\t\tstats->nr_failed_pages += nr_pages;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tdst = dst2;\r\n\t\tdst2 = list_next_entry(dst, lru);\r\n\t}\r\n}", ".igrate_folio_unmap": "static int migrate_folio_unmap(new_folio_t get_new_folio,\r\n\t\tfree_folio_t put_new_folio, unsigned long private,\r\n\t\tstruct folio *src, struct folio **dstp, enum migrate_mode mode,\r\n\t\tstruct list_head *ret)\r\n{\r\n\tstruct folio *dst;\r\n\tint rc = -EAGAIN;\r\n\tint old_page_state = 0;\r\n\tstruct anon_vma *anon_vma = NULL;\r\n\tbool locked = false;\r\n\tbool dst_locked = false;\r\n\r\n\tdst = get_new_folio(src, private);\r\n\tif (!dst)\r\n\t\treturn -ENOMEM;\r\n\t*dstp = dst;\r\n\r\n\tdst->private = NULL;\r\n\r\n\tif (!folio_trylock(src)) {\r\n\t\tif (mode == MIGRATE_ASYNC)\r\n\t\t\tgoto out;\r\n\r\n\t\t/*\r\n\t\t * It's not safe for direct compaction to call lock_page.\r\n\t\t * For example, during page readahead pages are added locked\r\n\t\t * to the LRU. Later, when the IO completes the pages are\r\n\t\t * marked uptodate and unlocked. However, the queueing\r\n\t\t * could be merging multiple pages for one bio (e.g.\r\n\t\t * mpage_readahead). If an allocation happens for the\r\n\t\t * second or third page, the process can end up locking\r\n\t\t * the same page twice and deadlocking. Rather than\r\n\t\t * trying to be clever about what pages can be locked,\r\n\t\t * avoid the use of lock_page for direct compaction\r\n\t\t * altogether.\r\n\t\t */\r\n\t\tif (current->flags & PF_MEMALLOC)\r\n\t\t\tgoto out;\r\n\r\n\t\t/*\r\n\t\t * In \"light\" mode, we can wait for transient locks (eg\r\n\t\t * inserting a page into the page table), but it's not\r\n\t\t * worth waiting for I/O.\r\n\t\t */\r\n\t\tif (mode == MIGRATE_SYNC_LIGHT && !folio_test_uptodate(src))\r\n\t\t\tgoto out;\r\n\r\n\t\tfolio_lock(src);\r\n\t}\r\n\tlocked = true;\r\n\tif (folio_test_mlocked(src))\r\n\t\told_page_state |= PAGE_WAS_MLOCKED;\r\n\r\n\tif (folio_test_writeback(src)) {\r\n\t\t/*\r\n\t\t * Only in the case of a full synchronous migration is it\r\n\t\t * necessary to wait for PageWriteback. In the async case,\r\n\t\t * the retry loop is too short and in the sync-light case,\r\n\t\t * the overhead of stalling is too much\r\n\t\t */\r\n\t\tswitch (mode) {\r\n\t\tcase MIGRATE_SYNC:\r\n\t\t\tbreak;\r\n\t\tdefault:\r\n\t\t\trc = -EBUSY;\r\n\t\t\tgoto out;\r\n\t\t}\r\n\t\tfolio_wait_writeback(src);\r\n\t}\r\n\r\n\t/*\r\n\t * By try_to_migrate(), src->mapcount goes down to 0 here. In this case,\r\n\t * we cannot notice that anon_vma is freed while we migrate a page.\r\n\t * This get_anon_vma() delays freeing anon_vma pointer until the end\r\n\t * of migration. File cache pages are no problem because of page_lock()\r\n\t * File Caches may use write_page() or lock_page() in migration, then,\r\n\t * just care Anon page here.\r\n\t *\r\n\t * Only folio_get_anon_vma() understands the subtleties of\r\n\t * getting a hold on an anon_vma from outside one of its mms.\r\n\t * But if we cannot get anon_vma, then we won't need it anyway,\r\n\t * because that implies that the anon page is no longer mapped\r\n\t * (and cannot be remapped so long as we hold the page lock).\r\n\t */\r\n\tif (folio_test_anon(src) && !folio_test_ksm(src))\r\n\t\tanon_vma = folio_get_anon_vma(src);\r\n\r\n\t/*\r\n\t * Block others from accessing the new page when we get around to\r\n\t * establishing additional references. We are usually the only one\r\n\t * holding a reference to dst at this point. We used to have a BUG\r\n\t * here if folio_trylock(dst) fails, but would like to allow for\r\n\t * cases where there might be a race with the previous use of dst.\r\n\t * This is much like races on refcount of oldpage: just don't BUG().\r\n\t */\r\n\tif (unlikely(!folio_trylock(dst)))\r\n\t\tgoto out;\r\n\tdst_locked = true;\r\n\r\n\tif (unlikely(page_has_movable_ops(&src->page))) {\r\n\t\t__migrate_folio_record(dst, old_page_state, anon_vma);\r\n\t\treturn 0;\r\n\t}\r\n\r\n\t/*\r\n\t * Corner case handling:\r\n\t * 1. When a new swap-cache page is read into, it is added to the LRU\r\n\t * and treated as swapcache but it has no rmap yet.\r\n\t * Calling try_to_unmap() against a src->mapping==NULL page will\r\n\t * trigger a BUG.  So handle it here.\r\n\t * 2. An orphaned page (see truncate_cleanup_page) might have\r\n\t * fs-private metadata. The page can be picked up due to memory\r\n\t * offlining.  Everywhere else except page reclaim, the page is\r\n\t * invisible to the vm, so the page can not be migrated.  So try to\r\n\t * free the metadata, so the page can be freed.\r\n\t */\r\n\tif (!src->mapping) {\r\n\t\tif (folio_test_private(src)) {\r\n\t\t\ttry_to_free_buffers(src);\r\n\t\t\tgoto out;\r\n\t\t}\r\n\t} else if (folio_mapped(src)) {\r\n\t\t/* Establish migration ptes */\r\n\t\tVM_BUG_ON_FOLIO(folio_test_anon(src) &&\r\n\t\t\t       !folio_test_ksm(src) && !anon_vma, src);\r\n\t\ttry_to_migrate(src, mode == MIGRATE_ASYNC ? TTU_BATCH_FLUSH : 0);\r\n\t\told_page_state |= PAGE_WAS_MAPPED;\r\n\t}\r\n\r\n\tif (!folio_mapped(src)) {\r\n\t\t__migrate_folio_record(dst, old_page_state, anon_vma);\r\n\t\treturn 0;\r\n\t}\r\n\r\nout:\r\n\t/*\r\n\t * A folio that has not been unmapped will be restored to\r\n\t * right list unless we want to retry.\r\n\t */\r\n\tif (rc == -EAGAIN)\r\n\t\tret = NULL;\r\n\r\n\tmigrate_folio_undo_src(src, old_page_state & PAGE_WAS_MAPPED,\r\n\t\t\t       anon_vma, locked, ret);\r\n\tmigrate_folio_undo_dst(dst, dst_locked, put_new_folio, private);\r\n\r\n\treturn rc;\r\n}", ".igrate_folios_undo": "static void migrate_folios_undo(struct list_head *src_folios,\r\n\t\tstruct list_head *dst_folios,\r\n\t\tfree_folio_t put_new_folio, unsigned long private,\r\n\t\tstruct list_head *ret_folios)\r\n{\r\n\tstruct folio *folio, *folio2, *dst, *dst2;\r\n\r\n\tdst = list_first_entry(dst_folios, struct folio, lru);\r\n\tdst2 = list_next_entry(dst, lru);\r\n\tlist_for_each_entry_safe(folio, folio2, src_folios, lru) {\r\n\t\tint old_page_state = 0;\r\n\t\tstruct anon_vma *anon_vma = NULL;\r\n\r\n\t\t__migrate_folio_extract(dst, &old_page_state, &anon_vma);\r\n\t\tmigrate_folio_undo_src(folio, old_page_state & PAGE_WAS_MAPPED,\r\n\t\t\t\tanon_vma, true, ret_folios);\r\n\t\tlist_del(&dst->lru);\r\n\t\tmigrate_folio_undo_dst(dst, true, put_new_folio, private);\r\n\t\tdst = dst2;\r\n\t\tdst2 = list_next_entry(dst, lru);\r\n\t}\r\n}", ".igrate_hugetlbs": "static int migrate_hugetlbs(struct list_head *from, new_folio_t get_new_folio,\r\n\t\t\t    free_folio_t put_new_folio, unsigned long private,\r\n\t\t\t    enum migrate_mode mode, int reason,\r\n\t\t\t    struct migrate_pages_stats *stats,\r\n\t\t\t    struct list_head *ret_folios)\r\n{\r\n\tint retry = 1;\r\n\tint nr_failed = 0;\r\n\tint nr_retry_pages = 0;\r\n\tint pass = 0;\r\n\tstruct folio *folio, *folio2;\r\n\tint rc, nr_pages;\r\n\r\n\tfor (pass = 0; pass < NR_MAX_MIGRATE_PAGES_RETRY && retry; pass++) {\r\n\t\tretry = 0;\r\n\t\tnr_retry_pages = 0;\r\n\r\n\t\tlist_for_each_entry_safe(folio, folio2, from, lru) {\r\n\t\t\tif (!folio_test_hugetlb(folio))\r\n\t\t\t\tcontinue;\r\n\r\n\t\t\tnr_pages = folio_nr_pages(folio);\r\n\r\n\t\t\tcond_resched();\r\n\r\n\t\t\t/*\r\n\t\t\t * Migratability of hugepages depends on architectures and\r\n\t\t\t * their size.  This check is necessary because some callers\r\n\t\t\t * of hugepage migration like soft offline and memory\r\n\t\t\t * hotremove don't walk through page tables or check whether\r\n\t\t\t * the hugepage is pmd-based or not before kicking migration.\r\n\t\t\t */\r\n\t\t\tif (!hugepage_migration_supported(folio_hstate(folio))) {\r\n\t\t\t\tnr_failed++;\r\n\t\t\t\tstats->nr_failed_pages += nr_pages;\r\n\t\t\t\tlist_move_tail(&folio->lru, ret_folios);\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\trc = unmap_and_move_huge_page(get_new_folio,\r\n\t\t\t\t\t\t      put_new_folio, private,\r\n\t\t\t\t\t\t      folio, pass > 2, mode,\r\n\t\t\t\t\t\t      reason, ret_folios);\r\n\t\t\t/*\r\n\t\t\t * The rules are:\r\n\t\t\t *\t0: hugetlb folio will be put back\r\n\t\t\t *\t-EAGAIN: stay on the from list\r\n\t\t\t *\t-ENOMEM: stay on the from list\r\n\t\t\t *\tOther errno: put on ret_folios list\r\n\t\t\t */\r\n\t\t\tswitch(rc) {\r\n\t\t\tcase -ENOMEM:\r\n\t\t\t\t/*\r\n\t\t\t\t * When memory is low, don't bother to try to migrate\r\n\t\t\t\t * other folios, just exit.\r\n\t\t\t\t */\r\n\t\t\t\tstats->nr_failed_pages += nr_pages + nr_retry_pages;\r\n\t\t\t\treturn -ENOMEM;\r\n\t\t\tcase -EAGAIN:\r\n\t\t\t\tretry++;\r\n\t\t\t\tnr_retry_pages += nr_pages;\r\n\t\t\t\tbreak;\r\n\t\t\tcase 0:\r\n\t\t\t\tstats->nr_succeeded += nr_pages;\r\n\t\t\t\tbreak;\r\n\t\t\tdefault:\r\n\t\t\t\t/*\r\n\t\t\t\t * Permanent failure (-EBUSY, etc.):\r\n\t\t\t\t * unlike -EAGAIN case, the failed folio is\r\n\t\t\t\t * removed from migration folio list and not\r\n\t\t\t\t * retried in the next outer loop.\r\n\t\t\t\t */\r\n\t\t\t\tnr_failed++;\r\n\t\t\t\tstats->nr_failed_pages += nr_pages;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t/*\r\n\t * nr_failed is number of hugetlb folios failed to be migrated.  After\r\n\t * NR_MAX_MIGRATE_PAGES_RETRY attempts, give up and count retried hugetlb\r\n\t * folios as failed.\r\n\t */\r\n\tnr_failed += retry;\r\n\tstats->nr_failed_pages += nr_retry_pages;\r\n\r\n\treturn nr_failed;\r\n}", ".igrate_pages": "int migrate_pages(struct list_head *from, new_folio_t get_new_folio,\r\n\t\tfree_folio_t put_new_folio, unsigned long private,\r\n\t\tenum migrate_mode mode, int reason, unsigned int *ret_succeeded)\r\n{\r\n\tint rc, rc_gather;\r\n\tint nr_pages;\r\n\tstruct folio *folio, *folio2;\r\n\tLIST_HEAD(folios);\r\n\tLIST_HEAD(ret_folios);\r\n\tLIST_HEAD(split_folios);\r\n\tstruct migrate_pages_stats stats;\r\n\r\n\ttrace_mm_migrate_pages_start(mode, reason);\r\n\r\n\tmemset(&stats, 0, sizeof(stats));\r\n\r\n\trc_gather = migrate_hugetlbs(from, get_new_folio, put_new_folio, private,\r\n\t\t\t\t     mode, reason, &stats, &ret_folios);\r\n\tif (rc_gather < 0)\r\n\t\tgoto out;\r\n\r\nagain:\r\n\tnr_pages = 0;\r\n\tlist_for_each_entry_safe(folio, folio2, from, lru) {\r\n\t\t/* Retried hugetlb folios will be kept in list  */\r\n\t\tif (folio_test_hugetlb(folio)) {\r\n\t\t\tlist_move_tail(&folio->lru, &ret_folios);\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\tnr_pages += folio_nr_pages(folio);\r\n\t\tif (nr_pages >= NR_MAX_BATCHED_MIGRATION)\r\n\t\t\tbreak;\r\n\t}\r\n\tif (nr_pages >= NR_MAX_BATCHED_MIGRATION)\r\n\t\tlist_cut_before(&folios, from, &folio2->lru);\r\n\telse\r\n\t\tlist_splice_init(from, &folios);\r\n\tif (mode == MIGRATE_ASYNC)\r\n\t\trc = migrate_pages_batch(&folios, get_new_folio, put_new_folio,\r\n\t\t\t\tprivate, mode, reason, &ret_folios,\r\n\t\t\t\t&split_folios, &stats,\r\n\t\t\t\tNR_MAX_MIGRATE_PAGES_RETRY);\r\n\telse\r\n\t\trc = migrate_pages_sync(&folios, get_new_folio, put_new_folio,\r\n\t\t\t\tprivate, mode, reason, &ret_folios,\r\n\t\t\t\t&split_folios, &stats);\r\n\tlist_splice_tail_init(&folios, &ret_folios);\r\n\tif (rc < 0) {\r\n\t\trc_gather = rc;\r\n\t\tlist_splice_tail(&split_folios, &ret_folios);\r\n\t\tgoto out;\r\n\t}\r\n\tif (!list_empty(&split_folios)) {\r\n\t\t/*\r\n\t\t * Failure isn't counted since all split folios of a large folio\r\n\t\t * is counted as 1 failure already.  And, we only try to migrate\r\n\t\t * with minimal effort, force MIGRATE_ASYNC mode and retry once.\r\n\t\t */\r\n\t\tmigrate_pages_batch(&split_folios, get_new_folio,\r\n\t\t\t\tput_new_folio, private, MIGRATE_ASYNC, reason,\r\n\t\t\t\t&ret_folios, NULL, &stats, 1);\r\n\t\tlist_splice_tail_init(&split_folios, &ret_folios);\r\n\t}\r\n\trc_gather += rc;\r\n\tif (!list_empty(from))\r\n\t\tgoto again;\r\nout:\r\n\t/*\r\n\t * Put the permanent failure folio back to migration list, they\r\n\t * will be put back to the right list by the caller.\r\n\t */\r\n\tlist_splice(&ret_folios, from);\r\n\r\n\t/*\r\n\t * Return 0 in case all split folios of fail-to-migrate large folios\r\n\t * are migrated successfully.\r\n\t */\r\n\tif (list_empty(from))\r\n\t\trc_gather = 0;\r\n\r\n\tcount_vm_events(PGMIGRATE_SUCCESS, stats.nr_succeeded);\r\n\tcount_vm_events(PGMIGRATE_FAIL, stats.nr_failed_pages);\r\n\tcount_vm_events(THP_MIGRATION_SUCCESS, stats.nr_thp_succeeded);\r\n\tcount_vm_events(THP_MIGRATION_FAIL, stats.nr_thp_failed);\r\n\tcount_vm_events(THP_MIGRATION_SPLIT, stats.nr_thp_split);\r\n\ttrace_mm_migrate_pages(stats.nr_succeeded, stats.nr_failed_pages,\r\n\t\t\t       stats.nr_thp_succeeded, stats.nr_thp_failed,\r\n\t\t\t       stats.nr_thp_split, stats.nr_split, mode,\r\n\t\t\t       reason);\r\n\r\n\tif (ret_succeeded)\r\n\t\t*ret_succeeded = stats.nr_succeeded;\r\n\r\n\treturn rc_gather;\r\n}", ".igrate_pages_sync": "static int migrate_pages_sync(struct list_head *from, new_folio_t get_new_folio,\r\n\t\tfree_folio_t put_new_folio, unsigned long private,\r\n\t\tenum migrate_mode mode, int reason,\r\n\t\tstruct list_head *ret_folios, struct list_head *split_folios,\r\n\t\tstruct migrate_pages_stats *stats)\r\n{\r\n\tint rc, nr_failed = 0;\r\n\tLIST_HEAD(folios);\r\n\tstruct migrate_pages_stats astats;\r\n\r\n\tmemset(&astats, 0, sizeof(astats));\r\n\t/* Try to migrate in batch with MIGRATE_ASYNC mode firstly */\r\n\trc = migrate_pages_batch(from, get_new_folio, put_new_folio, private, MIGRATE_ASYNC,\r\n\t\t\t\t reason, &folios, split_folios, &astats,\r\n\t\t\t\t NR_MAX_MIGRATE_ASYNC_RETRY);\r\n\tstats->nr_succeeded += astats.nr_succeeded;\r\n\tstats->nr_thp_succeeded += astats.nr_thp_succeeded;\r\n\tstats->nr_thp_split += astats.nr_thp_split;\r\n\tstats->nr_split += astats.nr_split;\r\n\tif (rc < 0) {\r\n\t\tstats->nr_failed_pages += astats.nr_failed_pages;\r\n\t\tstats->nr_thp_failed += astats.nr_thp_failed;\r\n\t\tlist_splice_tail(&folios, ret_folios);\r\n\t\treturn rc;\r\n\t}\r\n\tstats->nr_thp_failed += astats.nr_thp_split;\r\n\t/*\r\n\t * Do not count rc, as pages will be retried below.\r\n\t * Count nr_split only, since it includes nr_thp_split.\r\n\t */\r\n\tnr_failed += astats.nr_split;\r\n\t/*\r\n\t * Fall back to migrate all failed folios one by one synchronously. All\r\n\t * failed folios except split THPs will be retried, so their failure\r\n\t * isn't counted\r\n\t */\r\n\tlist_splice_tail_init(&folios, from);\r\n\twhile (!list_empty(from)) {\r\n\t\tlist_move(from->next, &folios);\r\n\t\trc = migrate_pages_batch(&folios, get_new_folio, put_new_folio,\r\n\t\t\t\t\t private, mode, reason, ret_folios,\r\n\t\t\t\t\t split_folios, stats, NR_MAX_MIGRATE_SYNC_RETRY);\r\n\t\tlist_splice_tail_init(&folios, ret_folios);\r\n\t\tif (rc < 0)\r\n\t\t\treturn rc;\r\n\t\tnr_failed += rc;\r\n\t}\r\n\r\n\treturn nr_failed;\r\n}", ".ove_pages_and_store_status": "static int move_pages_and_store_status(int node,\r\n\t\tstruct list_head *pagelist, int __user *status,\r\n\t\tint start, int i, unsigned long nr_pages)\r\n{\r\n\tint err;\r\n\r\n\tif (list_empty(pagelist))\r\n\t\treturn 0;\r\n\r\n\terr = do_move_pages_to_node(pagelist, node);\r\n\tif (err) {\r\n\t\t/*\r\n\t\t * Positive err means the number of failed\r\n\t\t * pages to migrate.  Since we are going to\r\n\t\t * abort and return the number of non-migrated\r\n\t\t * pages, so need to include the rest of the\r\n\t\t * nr_pages that have not been attempted as\r\n\t\t * well.\r\n\t\t */\r\n\t\tif (err > 0)\r\n\t\t\terr += nr_pages - i;\r\n\t\treturn err;\r\n\t}\r\n\treturn store_status(status, start, node, i - start);\r\n}", ".o_pages_move": "static int do_pages_move(struct mm_struct *mm, nodemask_t task_nodes,\r\n\t\t\t unsigned long nr_pages,\r\n\t\t\t const void __user * __user *pages,\r\n\t\t\t const int __user *nodes,\r\n\t\t\t int __user *status, int flags)\r\n{\r\n\tcompat_uptr_t __user *compat_pages = (void __user *)pages;\r\n\tint current_node = NUMA_NO_NODE;\r\n\tLIST_HEAD(pagelist);\r\n\tint start, i;\r\n\tint err = 0, err1;\r\n\r\n\tlru_cache_disable();\r\n\r\n\tfor (i = start = 0; i < nr_pages; i++) {\r\n\t\tconst void __user *p;\r\n\t\tint node;\r\n\r\n\t\terr = -EFAULT;\r\n\t\tif (in_compat_syscall()) {\r\n\t\t\tcompat_uptr_t cp;\r\n\r\n\t\t\tif (get_user(cp, compat_pages + i))\r\n\t\t\t\tgoto out_flush;\r\n\r\n\t\t\tp = compat_ptr(cp);\r\n\t\t} else {\r\n\t\t\tif (get_user(p, pages + i))\r\n\t\t\t\tgoto out_flush;\r\n\t\t}\r\n\t\tif (get_user(node, nodes + i))\r\n\t\t\tgoto out_flush;\r\n\r\n\t\terr = -ENODEV;\r\n\t\tif (node < 0 || node >= MAX_NUMNODES)\r\n\t\t\tgoto out_flush;\r\n\t\tif (!node_state(node, N_MEMORY))\r\n\t\t\tgoto out_flush;\r\n\r\n\t\terr = -EACCES;\r\n\t\tif (!node_isset(node, task_nodes))\r\n\t\t\tgoto out_flush;\r\n\r\n\t\tif (current_node == NUMA_NO_NODE) {\r\n\t\t\tcurrent_node = node;\r\n\t\t\tstart = i;\r\n\t\t} else if (node != current_node) {\r\n\t\t\terr = move_pages_and_store_status(current_node,\r\n\t\t\t\t\t&pagelist, status, start, i, nr_pages);\r\n\t\t\tif (err)\r\n\t\t\t\tgoto out;\r\n\t\t\tstart = i;\r\n\t\t\tcurrent_node = node;\r\n\t\t}\r\n\r\n\t\t/*\r\n\t\t * Errors in the page lookup or isolation are not fatal and we simply\r\n\t\t * report them via status\r\n\t\t */\r\n\t\terr = add_folio_for_migration(mm, p, current_node, &pagelist,\r\n\t\t\t\t\t      flags & MPOL_MF_MOVE_ALL);\r\n\r\n\t\tif (err > 0) {\r\n\t\t\t/* The page is successfully queued for migration */\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\t/*\r\n\t\t * If the page is already on the target node (!err), store the\r\n\t\t * node, otherwise, store the err.\r\n\t\t */\r\n\t\terr = store_status(status, i, err ? : current_node, 1);\r\n\t\tif (err)\r\n\t\t\tgoto out_flush;\r\n\r\n\t\terr = move_pages_and_store_status(current_node, &pagelist,\r\n\t\t\t\tstatus, start, i, nr_pages);\r\n\t\tif (err) {\r\n\t\t\t/* We have accounted for page i */\r\n\t\t\tif (err > 0)\r\n\t\t\t\terr--;\r\n\t\t\tgoto out;\r\n\t\t}\r\n\t\tcurrent_node = NUMA_NO_NODE;\r\n\t}\r\nout_flush:\r\n\t/* Make sure we do not overwrite the existing error */\r\n\terr1 = move_pages_and_store_status(current_node, &pagelist,\r\n\t\t\t\tstatus, start, i, nr_pages);\r\n\tif (err >= 0)\r\n\t\terr = err1;\r\nout:\r\n\tlru_cache_enable();\r\n\treturn err;\r\n}", ".ernel_move_pages": "static int kernel_move_pages(pid_t pid, unsigned long nr_pages,\r\n\t\t\t     const void __user * __user *pages,\r\n\t\t\t     const int __user *nodes,\r\n\t\t\t     int __user *status, int flags)\r\n{\r\n\tstruct mm_struct *mm;\r\n\tint err;\r\n\tnodemask_t task_nodes;\r\n\r\n\t/* Check flags */\r\n\tif (flags & ~(MPOL_MF_MOVE|MPOL_MF_MOVE_ALL))\r\n\t\treturn -EINVAL;\r\n\r\n\tif ((flags & MPOL_MF_MOVE_ALL) && !capable(CAP_SYS_NICE))\r\n\t\treturn -EPERM;\r\n\r\n\tmm = find_mm_struct(pid, &task_nodes);\r\n\tif (IS_ERR(mm))\r\n\t\treturn PTR_ERR(mm);\r\n\r\n\tif (nodes)\r\n\t\terr = do_pages_move(mm, task_nodes, nr_pages, pages,\r\n\t\t\t\t    nodes, status, flags);\r\n\telse\r\n\t\terr = do_pages_stat(mm, nr_pages, pages, status);\r\n\r\n\tmmput(mm);\r\n\treturn err;\r\n}", ".o_pages_stat": "static int do_pages_stat(struct mm_struct *mm, unsigned long nr_pages,\r\n\t\t\t const void __user * __user *pages,\r\n\t\t\t int __user *status)\r\n{\r\n#define DO_PAGES_STAT_CHUNK_NR 16UL\r\n\tconst void __user *chunk_pages[DO_PAGES_STAT_CHUNK_NR];\r\n\tint chunk_status[DO_PAGES_STAT_CHUNK_NR];\r\n\tunsigned long chunk_offset = 0;\r\n\r\n\twhile (nr_pages) {\r\n\t\tunsigned long chunk_nr = min(nr_pages, DO_PAGES_STAT_CHUNK_NR);\r\n\r\n\t\tif (in_compat_syscall()) {\r\n\t\t\tif (get_compat_pages_array(chunk_pages, pages,\r\n\t\t\t\t\t\t   chunk_offset, chunk_nr))\r\n\t\t\t\tbreak;\r\n\t\t} else {\r\n\t\t\tif (copy_from_user(chunk_pages, pages + chunk_offset,\r\n\t\t\t\t      chunk_nr * sizeof(*chunk_pages)))\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\tdo_pages_stat_array(mm, chunk_nr, chunk_pages, chunk_status);\r\n\r\n\t\tif (copy_to_user(status + chunk_offset, chunk_status,\r\n\t\t\t\t chunk_nr * sizeof(*status)))\r\n\t\t\tbreak;\r\n\r\n\t\tchunk_offset += chunk_nr;\r\n\t\tnr_pages -= chunk_nr;\r\n\t}\r\n\treturn nr_pages ? -EFAULT : 0;\r\n}", ".igrate_misplaced_folio_prepare": "int migrate_misplaced_folio_prepare(struct folio *folio,\r\n\t\tstruct vm_area_struct *vma, int node)\r\n{\r\n\tint nr_pages = folio_nr_pages(folio);\r\n\tpg_data_t *pgdat = NODE_DATA(node);\r\n\r\n\tif (folio_is_file_lru(folio)) {\r\n\t\t/*\r\n\t\t * Do not migrate file folios that are mapped in multiple\r\n\t\t * processes with execute permissions as they are probably\r\n\t\t * shared libraries.\r\n\t\t *\r\n\t\t * See folio_maybe_mapped_shared() on possible imprecision\r\n\t\t * when we cannot easily detect if a folio is shared.\r\n\t\t */\r\n\t\tif ((vma->vm_flags & VM_EXEC) && folio_maybe_mapped_shared(folio))\r\n\t\t\treturn -EACCES;\r\n\r\n\t\t/*\r\n\t\t * Do not migrate dirty folios as not all filesystems can move\r\n\t\t * dirty folios in MIGRATE_ASYNC mode which is a waste of\r\n\t\t * cycles.\r\n\t\t */\r\n\t\tif (folio_test_dirty(folio))\r\n\t\t\treturn -EAGAIN;\r\n\t}\r\n\r\n\t/* Avoid migrating to a node that is nearly full */\r\n\tif (!migrate_balanced_pgdat(pgdat, nr_pages)) {\r\n\t\tint z;\r\n\r\n\t\tif (!(sysctl_numa_balancing_mode & NUMA_BALANCING_MEMORY_TIERING))\r\n\t\t\treturn -EAGAIN;\r\n\t\tfor (z = pgdat->nr_zones - 1; z >= 0; z--) {\r\n\t\t\tif (managed_zone(pgdat->node_zones + z))\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\t/*\r\n\t\t * If there are no managed zones, it should not proceed\r\n\t\t * further.\r\n\t\t */\r\n\t\tif (z < 0)\r\n\t\t\treturn -EAGAIN;\r\n\r\n\t\twakeup_kswapd(pgdat->node_zones + z, 0,\r\n\t\t\t      folio_order(folio), ZONE_MOVABLE);\r\n\t\treturn -EAGAIN;\r\n\t}\r\n\r\n\tif (!folio_isolate_lru(folio))\r\n\t\treturn -EAGAIN;\r\n\r\n\tnode_stat_mod_folio(folio, NR_ISOLATED_ANON + folio_is_file_lru(folio),\r\n\t\t\t    nr_pages);\r\n\treturn 0;\r\n}"}, "function_name": "migrate_misplaced_folio"}
{"function_id": null, "caller": {".irPDcapGetSa": "static INT\r\nAirPDcapGetSa(\r\n    PAIRPDCAP_CONTEXT ctx,\r\n    AIRPDCAP_SEC_ASSOCIATION_ID *id)\r\n{\r\n    INT sa_index;\r\n    if (ctx->sa_index!=-1) {\r\n        /* at least one association was stored                               */\r\n        /* search for the association from sa_index to 0 (most recent added) */\r\n        for (sa_index=ctx->sa_index; sa_index>=0; sa_index--) {\r\n            if (ctx->sa[sa_index].used) {\r\n                if (memcmp(id, &(ctx->sa[sa_index].saId), sizeof(AIRPDCAP_SEC_ASSOCIATION_ID))==0) {\r\n                    ctx->index=sa_index;\r\n                    return sa_index;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    return -1;\r\n}", ".irPDcapStoreSa": "static INT\r\nAirPDcapStoreSa(\r\n    PAIRPDCAP_CONTEXT ctx,\r\n    AIRPDCAP_SEC_ASSOCIATION_ID *id)\r\n{\r\n    INT last_free;\r\n    if (ctx->first_free_index>=AIRPDCAP_MAX_SEC_ASSOCIATIONS_NR) {\r\n        /* there is no empty space available. FAILURE */\r\n        return -1;\r\n    }\r\n    if (ctx->sa[ctx->first_free_index].used) {\r\n        /* last addition was in the middle of the array (and the first_free_index was just incremented by 1)   */\r\n        /* search for a free space from the first_free_index to AIRPDCAP_STA_INFOS_NR (to avoid free blocks in */\r\n        /*              the middle)                                                                            */\r\n        for (last_free=ctx->first_free_index; last_free<AIRPDCAP_MAX_SEC_ASSOCIATIONS_NR; last_free++)\r\n            if (!ctx->sa[last_free].used)\r\n                break;\r\n\r\n        if (last_free>=AIRPDCAP_MAX_SEC_ASSOCIATIONS_NR) {\r\n            /* there is no empty space available. FAILURE */\r\n            return -1;\r\n        }\r\n\r\n        /* store first free space index */\r\n        ctx->first_free_index=last_free;\r\n    }\r\n\r\n    /* use this info */\r\n    ctx->index=ctx->first_free_index;\r\n\r\n    /* reset the info structure */\r\n    memset(ctx->sa+ctx->index, 0, sizeof(AIRPDCAP_SEC_ASSOCIATION));\r\n\r\n    ctx->sa[ctx->index].used=1;\r\n\r\n    /* set the info structure */\r\n    memcpy(&(ctx->sa[ctx->index].saId), id, sizeof(AIRPDCAP_SEC_ASSOCIATION_ID));\r\n\r\n    /* increment by 1 the first_free_index (heuristic) */\r\n    ctx->first_free_index++;\r\n\r\n    /* set the sa_index if the added index is greater the the sa_index */\r\n    if (ctx->index > ctx->sa_index)\r\n        ctx->sa_index=ctx->index;\r\n\r\n    return ctx->index;\r\n}", ".irPDcapGetSaPtr": "static PAIRPDCAP_SEC_ASSOCIATION\r\nAirPDcapGetSaPtr(\r\n    PAIRPDCAP_CONTEXT ctx,\r\n    AIRPDCAP_SEC_ASSOCIATION_ID *id)\r\n{\r\n    int sa_index;\r\n\r\n    /* search for a cached Security Association for supplied BSSID and STA MAC  */\r\n    if ((sa_index=AirPDcapGetSa(ctx, id))==-1) {\r\n        /* create a new Security Association if it doesn't currently exist      */\r\n        if ((sa_index=AirPDcapStoreSa(ctx, id))==-1) {\r\n            return NULL;\r\n        }\r\n    }\r\n    /* get the Security Association structure   */\r\n    return &ctx->sa[sa_index];\r\n}", ".irPDcapRsna4WHandshake": "static INT\r\nAirPDcapRsna4WHandshake(\r\n    PAIRPDCAP_CONTEXT ctx,\r\n    const UCHAR *data,\r\n    AIRPDCAP_SEC_ASSOCIATION *sa,\r\n    INT offset,\r\n    const guint tot_len)\r\n{\r\n    AIRPDCAP_KEY_ITEM *tmp_key, *tmp_pkt_key, pkt_key;\r\n    AIRPDCAP_SEC_ASSOCIATION *tmp_sa;\r\n    INT key_index;\r\n    INT ret_value=1;\r\n    UCHAR useCache=FALSE;\r\n    UCHAR eapol[AIRPDCAP_EAPOL_MAX_LEN];\r\n    USHORT eapol_len;\r\n\r\n    if (sa->key!=NULL)\r\n        useCache=TRUE;\r\n\r\n    /* a 4-way handshake packet use a Pairwise key type (IEEE 802.11i-2004, pg. 79) */\r\n    if (AIRPDCAP_EAP_KEY(data[offset+1])!=1) {\r\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsna4WHandshake\", \"Group/STAKey message (not used)\", AIRPDCAP_DEBUG_LEVEL_5);\r\n        return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\r\n    }\r\n\r\n    /* TODO timeouts? */\r\n\r\n    /* TODO consider key-index */\r\n\r\n    /* TODO considera Deauthentications */\r\n\r\n    AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsna4WHandshake\", \"4-way handshake...\", AIRPDCAP_DEBUG_LEVEL_5);\r\n\r\n    /* manage 4-way handshake packets; this step completes the 802.1X authentication process (IEEE 802.11i-2004, pag. 85) */\r\n\r\n    /* message 1: Authenticator->Supplicant (Sec=0, Mic=0, Ack=1, Inst=0, Key=1(pairwise), KeyRSC=0, Nonce=ANonce, MIC=0) */\r\n    if (AIRPDCAP_EAP_INST(data[offset+1])==0 &&\r\n        AIRPDCAP_EAP_ACK(data[offset+1])==1 &&\r\n        AIRPDCAP_EAP_MIC(data[offset])==0)\r\n    {\r\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsna4WHandshake\", \"4-way handshake message 1\", AIRPDCAP_DEBUG_LEVEL_3);\r\n\r\n        /* On reception of Message 1, the Supplicant determines whether the Key Replay Counter field value has been        */\r\n        /* used before with the current PMKSA. If the Key Replay Counter field value is less than or equal to the current  */\r\n        /* local value, the Supplicant discards the message.                                                               */\r\n        /* -> not checked, the Authenticator will be send another Message 1 (hopefully!)                                   */\r\n\r\n        /* This saves the sa since we are reauthenticating which will overwrite our current sa GCS*/\r\n        if( sa->handshake >= 2) {\r\n            tmp_sa= g_new(AIRPDCAP_SEC_ASSOCIATION, 1);\r\n            memcpy(tmp_sa, sa, sizeof(AIRPDCAP_SEC_ASSOCIATION));\r\n            sa->validKey=FALSE;\r\n            sa->next=tmp_sa;\r\n        }\r\n\r\n        /* save ANonce (from authenticator) to derive the PTK with the SNonce (from the 2 message) */\r\n        memcpy(sa->wpa.nonce, data+offset+12, 32);\r\n\r\n        /* get the Key Descriptor Version (to select algorithm used in decryption -CCMP or TKIP-) */\r\n        sa->wpa.key_ver=AIRPDCAP_EAP_KEY_DESCR_VER(data[offset+1]);\r\n\r\n        sa->handshake=1;\r\n\r\n        return AIRPDCAP_RET_SUCCESS_HANDSHAKE;\r\n    }\r\n\r\n    /* message 2|4: Supplicant->Authenticator (Sec=0|1, Mic=1, Ack=0, Inst=0, Key=1(pairwise), KeyRSC=0, Nonce=SNonce|0, MIC=MIC(KCK,EAPOL)) */\r\n    if (AIRPDCAP_EAP_INST(data[offset+1])==0 &&\r\n        AIRPDCAP_EAP_ACK(data[offset+1])==0 &&\r\n        AIRPDCAP_EAP_MIC(data[offset])==1)\r\n    {\r\n        /* Check key data length to differentiate between message 2 or 4, same as in epan/dissectors/packet-ieee80211.c */\r\n        if (pntoh16(data+offset+92)) {\r\n            /* message 2 */\r\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsna4WHandshake\", \"4-way handshake message 2\", AIRPDCAP_DEBUG_LEVEL_3);\r\n\r\n            /* On reception of Message 2, the Authenticator checks that the key replay counter corresponds to the */\r\n            /* outstanding Message 1. If not, it silently discards the message.                                   */\r\n            /* If the calculated MIC does not match the MIC that the Supplicant included in the EAPOL-Key frame,  */\r\n            /* the Authenticator silently discards Message 2.                                                     */\r\n            /* -> not checked; the Supplicant will send another message 2 (hopefully!)                            */\r\n\r\n            /* now you can derive the PTK */\r\n            for (key_index=0; key_index<(INT)ctx->keys_nr || useCache; key_index++) {\r\n                /* use the cached one, or try all keys */\r\n                if (!useCache) {\r\n                    AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsna4WHandshake\", \"Try WPA key...\", AIRPDCAP_DEBUG_LEVEL_3);\r\n                    tmp_key=&ctx->keys[key_index];\r\n                } else {\r\n                    /* there is a cached key in the security association, if it's a WPA key try it... */\r\n                    if (sa->key!=NULL &&\r\n                        (sa->key->KeyType==AIRPDCAP_KEY_TYPE_WPA_PWD ||\r\n                         sa->key->KeyType==AIRPDCAP_KEY_TYPE_WPA_PSK ||\r\n                         sa->key->KeyType==AIRPDCAP_KEY_TYPE_WPA_PMK)) {\r\n                            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsna4WHandshake\", \"Try cached WPA key...\", AIRPDCAP_DEBUG_LEVEL_3);\r\n                            tmp_key=sa->key;\r\n                    } else {\r\n                        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsna4WHandshake\", \"Cached key is of a wrong type, try WPA key...\", AIRPDCAP_DEBUG_LEVEL_3);\r\n                        tmp_key=&ctx->keys[key_index];\r\n                    }\r\n                }\r\n\r\n                /* obviously, try only WPA keys... */\r\n                if (tmp_key->KeyType==AIRPDCAP_KEY_TYPE_WPA_PWD ||\r\n                    tmp_key->KeyType==AIRPDCAP_KEY_TYPE_WPA_PSK ||\r\n                    tmp_key->KeyType==AIRPDCAP_KEY_TYPE_WPA_PMK)\r\n                {\r\n                    if (tmp_key->KeyType == AIRPDCAP_KEY_TYPE_WPA_PWD && tmp_key->UserPwd.SsidLen == 0 && ctx->pkt_ssid_len > 0 && ctx->pkt_ssid_len <= AIRPDCAP_WPA_SSID_MAX_LEN) {\r\n                        /* We have a \"wildcard\" SSID.  Use the one from the packet. */\r\n                        memcpy(&pkt_key, tmp_key, sizeof(pkt_key));\r\n                        memcpy(&pkt_key.UserPwd.Ssid, ctx->pkt_ssid, ctx->pkt_ssid_len);\r\n                         pkt_key.UserPwd.SsidLen = ctx->pkt_ssid_len;\r\n                        AirPDcapRsnaPwd2Psk(pkt_key.UserPwd.Passphrase, pkt_key.UserPwd.Ssid,\r\n                            pkt_key.UserPwd.SsidLen, pkt_key.KeyData.Wpa.Psk);\r\n                        tmp_pkt_key = &pkt_key;\r\n                    } else {\r\n                        tmp_pkt_key = tmp_key;\r\n                    }\r\n\r\n                    /* derive the PTK from the BSSID, STA MAC, PMK, SNonce, ANonce */\r\n                    AirPDcapRsnaPrfX(sa,                            /* authenticator nonce, bssid, station mac */\r\n                                     tmp_pkt_key->KeyData.Wpa.Psk,      /* PSK == PMK */\r\n                                     data+offset+12,                /* supplicant nonce */\r\n                                     512,\r\n                                     sa->wpa.ptk);\r\n\r\n                    /* verify the MIC (compare the MIC in the packet included in this message with a MIC calculated with the PTK) */\r\n                    eapol_len=pntoh16(data+offset-3)+4;\r\n                    memcpy(eapol, &data[offset-5], (eapol_len<AIRPDCAP_EAPOL_MAX_LEN?eapol_len:AIRPDCAP_EAPOL_MAX_LEN));\r\n                    ret_value=AirPDcapRsnaMicCheck(eapol,           /*      eapol frame (header also) */\r\n                                                   eapol_len,       /*      eapol frame length        */\r\n                                                   sa->wpa.ptk,     /*      Key Confirmation Key      */\r\n                                                   AIRPDCAP_EAP_KEY_DESCR_VER(data[offset+1])); /*  EAPOL-Key description version */\r\n\r\n                    /* If the MIC is valid, the Authenticator checks that the RSN information element bit-wise matches       */\r\n                    /* that from the (Re)Association Request message.                                                        */\r\n                    /*              i) TODO If these are not exactly the same, the Authenticator uses MLME-DEAUTHENTICATE.request */\r\n                    /* primitive to terminate the association.                                                               */\r\n                    /*              ii) If they do match bit-wise, the Authenticator constructs Message 3.                   */\r\n                }\r\n\r\n                if (!ret_value &&\r\n                    (tmp_key->KeyType==AIRPDCAP_KEY_TYPE_WPA_PWD ||\r\n                    tmp_key->KeyType==AIRPDCAP_KEY_TYPE_WPA_PSK ||\r\n                    tmp_key->KeyType==AIRPDCAP_KEY_TYPE_WPA_PMK))\r\n                {\r\n                    /* the temporary key is the correct one, cached in the Security Association */\r\n\r\n                    sa->key=tmp_key;\r\n                    break;\r\n                } else {\r\n                    /* the cached key was not valid, try other keys */\r\n\r\n                    if (useCache==TRUE) {\r\n                        useCache=FALSE;\r\n                        key_index--;\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (ret_value) {\r\n                AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsna4WHandshake\", \"handshake step failed\", AIRPDCAP_DEBUG_LEVEL_3);\r\n                return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\r\n            }\r\n\r\n            sa->handshake=2;\r\n            sa->validKey=TRUE; /* we can use the key to decode, even if we have not captured the other eapol packets */\r\n\r\n            return AIRPDCAP_RET_SUCCESS_HANDSHAKE;\r\n        } else {\r\n        /* message 4 */\r\n\r\n            /* TODO \"Note that when the 4-Way Handshake is first used Message 4 is sent in the clear.\" */\r\n\r\n            /* TODO check MIC and Replay Counter                                                                     */\r\n            /* On reception of Message 4, the Authenticator verifies that the Key Replay Counter field value is one  */\r\n            /* that it used on this 4-Way Handshake; if it is not, it silently discards the message.                 */\r\n            /* If the calculated MIC does not match the MIC that the Supplicant included in the EAPOL-Key frame, the */\r\n            /* Authenticator silently discards Message 4.                                                            */\r\n\r\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsna4WHandshake\", \"4-way handshake message 4\", AIRPDCAP_DEBUG_LEVEL_3);\r\n\r\n            sa->handshake=4;\r\n\r\n            return AIRPDCAP_RET_SUCCESS_HANDSHAKE;\r\n        }\r\n    }\r\n\r\n    /* message 3: Authenticator->Supplicant (Sec=1, Mic=1, Ack=1, Inst=0/1, Key=1(pairwise), KeyRSC=???, Nonce=ANonce, MIC=1) */\r\n    if (AIRPDCAP_EAP_ACK(data[offset+1])==1 &&\r\n        AIRPDCAP_EAP_MIC(data[offset])==1)\r\n    {\r\n        const EAPOL_RSN_KEY *pEAPKey;\r\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsna4WHandshake\", \"4-way handshake message 3\", AIRPDCAP_DEBUG_LEVEL_3);\r\n\r\n        /* On reception of Message 3, the Supplicant silently discards the message if the Key Replay Counter field     */\r\n        /* value has already been used or if the ANonce value in Message 3 differs from the ANonce value in Message 1. */\r\n        /* -> not checked, the Authenticator will send another message 3 (hopefully!)                                  */\r\n\r\n        /* TODO check page 88 (RNS) */\r\n\r\n        /* If using WPA2 PSK, message 3 will contain an RSN for the group key (GTK KDE).\r\n           In order to properly support decrypting WPA2-PSK packets, we need to parse this to get the group key. */\r\n        pEAPKey = (const EAPOL_RSN_KEY *)(&(data[offset-1]));\r\n        if (pEAPKey->type == AIRPDCAP_RSN_WPA2_KEY_DESCRIPTOR){\r\n            PAIRPDCAP_SEC_ASSOCIATION broadcast_sa;\r\n            AIRPDCAP_SEC_ASSOCIATION_ID id;\r\n\r\n            /* Get broadcacst SA for the current BSSID */\r\n            memcpy(id.sta, broadcast_mac, AIRPDCAP_MAC_LEN);\r\n            memcpy(id.bssid, sa->saId.bssid, AIRPDCAP_MAC_LEN);\r\n            broadcast_sa = AirPDcapGetSaPtr(ctx, &id);\r\n\r\n            if (broadcast_sa == NULL){\r\n                return AIRPDCAP_RET_REQ_DATA;\r\n            }\r\n            return (AirPDcapDecryptWPABroadcastKey(pEAPKey, sa->wpa.ptk+16, broadcast_sa, tot_len-offset+1));\r\n        }\r\n    }\r\n\r\n    return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\r\n}", ".irPDcapDecryptWPABroadcastKey": "static INT\r\nAirPDcapDecryptWPABroadcastKey(const EAPOL_RSN_KEY *pEAPKey, guint8 *decryption_key, PAIRPDCAP_SEC_ASSOCIATION sa, guint eapol_len)\r\n{\r\n    guint8 key_version;\r\n    const guint8 *key_data;\r\n    guint8  *szEncryptedKey;\r\n    guint16 key_bytes_len = 0; /* Length of the total key data field */\r\n    guint16 key_len;           /* Actual group key length */\r\n    static AIRPDCAP_KEY_ITEM dummy_key; /* needed in case AirPDcapRsnaMng() wants the key structure */\r\n    AIRPDCAP_SEC_ASSOCIATION *tmp_sa;\r\n\r\n    /* We skip verifying the MIC of the key. If we were implementing a WPA supplicant we'd want to verify, but for a sniffer it's not needed. */\r\n\r\n    /* Preparation for decrypting the group key -  determine group key data length */\r\n    /* depending on whether the pairwise key is TKIP or AES encryption key */\r\n    key_version = AIRPDCAP_EAP_KEY_DESCR_VER(pEAPKey->key_information[1]);\r\n    if (key_version == AIRPDCAP_WPA_KEY_VER_NOT_CCMP){\r\n        /* TKIP */\r\n        key_bytes_len = pntoh16(pEAPKey->key_length);\r\n    }else if (key_version == AIRPDCAP_WPA_KEY_VER_AES_CCMP){\r\n        /* AES */\r\n        key_bytes_len = pntoh16(pEAPKey->key_data_len);\r\n\r\n        /* AES keys must be at least 128 bits = 16 bytes. */\r\n        if (key_bytes_len < 16) {\r\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\r\n        }\r\n    }\r\n\r\n    if ((key_bytes_len < GROUP_KEY_MIN_LEN) ||\r\n        (eapol_len < sizeof(EAPOL_RSN_KEY)) ||\r\n        (key_bytes_len > eapol_len - sizeof(EAPOL_RSN_KEY))) {\r\n        return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\r\n    }\r\n\r\n    /* Encrypted key is in the information element field of the EAPOL key packet */\r\n    key_data = (const guint8 *)pEAPKey + sizeof(EAPOL_RSN_KEY);\r\n    szEncryptedKey = (guint8 *)g_memdup(key_data, key_bytes_len);\r\n\r\n    DEBUG_DUMP(\"Encrypted Broadcast key:\", szEncryptedKey, key_bytes_len);\r\n    DEBUG_DUMP(\"KeyIV:\", pEAPKey->key_iv, 16);\r\n    DEBUG_DUMP(\"decryption_key:\", decryption_key, 16);\r\n\r\n    /* We are rekeying, save old sa */\r\n    tmp_sa=(AIRPDCAP_SEC_ASSOCIATION *)g_malloc(sizeof(AIRPDCAP_SEC_ASSOCIATION));\r\n    memcpy(tmp_sa, sa, sizeof(AIRPDCAP_SEC_ASSOCIATION));\r\n    sa->next=tmp_sa;\r\n\r\n    /* As we have no concept of the prior association request at this point, we need to deduce the     */\r\n    /* group key cipher from the length of the key bytes. In WPA this is straightforward as the        */\r\n    /* keybytes just contain the GTK, and the GTK is only in the group handshake, NOT the M3.          */\r\n    /* In WPA2 its a little more tricky as the M3 keybytes contain an RSN_IE, but the group handshake  */\r\n    /* does not. Also there are other (variable length) items in the keybytes which we need to account */\r\n    /* for to determine the true key length, and thus the group cipher.                                */\r\n\r\n    if (key_version == AIRPDCAP_WPA_KEY_VER_NOT_CCMP){\r\n        guint8 new_key[32];\r\n        guint8 dummy[256] = { 0 };\r\n        /* TKIP key */\r\n        /* Per 802.11i, Draft 3.0 spec, section 8.5.2, p. 97, line 4-8, */\r\n        /* group key is decrypted using RC4.  Concatenate the IV with the 16 byte EK (PTK+16) to get the decryption key */\r\n\r\n        gcry_cipher_hd_t  rc4_handle;\r\n\r\n        /* The WPA group key just contains the GTK bytes so deducing the type is straightforward   */\r\n        /* Note - WPA M3 doesn't contain a group key so we'll only be here for the group handshake */\r\n        sa->wpa.key_ver = (key_bytes_len >=TKIP_GROUP_KEY_LEN)?AIRPDCAP_WPA_KEY_VER_NOT_CCMP:AIRPDCAP_WPA_KEY_VER_AES_CCMP;\r\n\r\n        /* Build the full decryption key based on the IV and part of the pairwise key */\r\n        memcpy(new_key, pEAPKey->key_iv, 16);\r\n        memcpy(new_key+16, decryption_key, 16);\r\n        DEBUG_DUMP(\"FullDecrKey:\", new_key, 32);\r\n\r\n        if (gcry_cipher_open (&rc4_handle, GCRY_CIPHER_ARCFOUR, GCRY_CIPHER_MODE_STREAM, 0)) {\r\n          return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\r\n        }\r\n        if (gcry_cipher_setkey(rc4_handle, new_key, sizeof(new_key))) {\r\n          gcry_cipher_close(rc4_handle);\r\n          return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\r\n        }\r\n\r\n        /* Do dummy 256 iterations of the RC4 algorithm (per 802.11i, Draft 3.0, p. 97 line 6) */\r\n        gcry_cipher_decrypt(rc4_handle, dummy, 256, NULL, 0);\r\n        gcry_cipher_decrypt(rc4_handle, szEncryptedKey, key_bytes_len, NULL, 0);\r\n        gcry_cipher_close(rc4_handle);\r\n\r\n    } else if (key_version == AIRPDCAP_WPA_KEY_VER_AES_CCMP){\r\n        /* AES CCMP key */\r\n\r\n        guint8 key_found;\r\n        guint8 key_length;\r\n        guint16 key_index;\r\n        guint8 *decrypted_data;\r\n\r\n        /* Unwrap the key; the result is key_bytes_len in length */\r\n        decrypted_data = AES_unwrap(decryption_key, 16, szEncryptedKey,  key_bytes_len);\r\n\r\n        /* With WPA2 what we get after Broadcast Key decryption is an actual RSN structure.\r\n           The key itself is stored as a GTK KDE\r\n           WPA2 IE (1 byte) id = 0xdd, length (1 byte), GTK OUI (4 bytes), key index (1 byte) and 1 reserved byte. Thus we have to\r\n           pass pointer to the actual key with 8 bytes offset */\r\n\r\n        key_found = FALSE;\r\n        key_index = 0;\r\n\r\n        /* Parse Key data until we found GTK KDE */\r\n        /* GTK KDE = 00-0F-AC 01 */\r\n        while(key_index < (key_bytes_len - 6) && !key_found){\r\n            guint8 rsn_id;\r\n            guint32 type;\r\n\r\n            /* Get RSN ID */\r\n            rsn_id = decrypted_data[key_index];\r\n            type = ((decrypted_data[key_index + 2] << 24) +\r\n                    (decrypted_data[key_index + 3] << 16) +\r\n                    (decrypted_data[key_index + 4] << 8) +\r\n                     (decrypted_data[key_index + 5]));\r\n\r\n            if (rsn_id == 0xdd && type == 0x000fac01) {\r\n                key_found = TRUE;\r\n            } else {\r\n                key_index += decrypted_data[key_index+1]+2;\r\n            }\r\n        }\r\n\r\n        if (key_found){\r\n            if (decrypted_data[key_index+1] <= 6) {\r\n                g_free(decrypted_data);\r\n                g_free(szEncryptedKey);\r\n                return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\r\n            }\r\n            key_length = decrypted_data[key_index+1] - 6;\r\n\r\n            if (key_index+8 >= key_bytes_len ||\r\n                key_length > key_bytes_len - key_index - 8) {\r\n                g_free(decrypted_data);\r\n                g_free(szEncryptedKey);\r\n                return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\r\n            }\r\n\r\n            /* Skip over the GTK header info, and don't copy past the end of the encrypted data */\r\n            memcpy(szEncryptedKey, decrypted_data+key_index+8, key_length);\r\n        } else {\r\n            g_free(decrypted_data);\r\n            g_free(szEncryptedKey);\r\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\r\n        }\r\n\r\n        if (key_length == TKIP_GROUP_KEY_LEN)\r\n            sa->wpa.key_ver = AIRPDCAP_WPA_KEY_VER_NOT_CCMP;\r\n        else\r\n            sa->wpa.key_ver = AIRPDCAP_WPA_KEY_VER_AES_CCMP;\r\n\r\n        g_free(decrypted_data);\r\n    }\r\n\r\n    key_len = (sa->wpa.key_ver==AIRPDCAP_WPA_KEY_VER_NOT_CCMP)?TKIP_GROUP_KEY_LEN:CCMP_GROUP_KEY_LEN;\r\n    if (key_len > key_bytes_len) {\r\n        /* the key required for this protocol is longer than the key that we just calculated */\r\n        g_free(szEncryptedKey);\r\n        return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\r\n    }\r\n\r\n    /* Decrypted key is now in szEncryptedKey with len of key_len */\r\n    DEBUG_DUMP(\"Broadcast key:\", szEncryptedKey, key_len);\r\n\r\n    /* Load the proper key material info into the SA */\r\n    sa->key = &dummy_key;  /* we just need key to be not null because it is checked in AirPDcapRsnaMng().  The WPA key materials are actually in the .wpa structure */\r\n    sa->validKey = TRUE;\r\n\r\n    /* Since this is a GTK and its size is only 32 bytes (vs. the 64 byte size of a PTK), we fake it and put it in at a 32-byte offset so the  */\r\n    /* AirPDcapRsnaMng() function will extract the right piece of the GTK for decryption. (The first 16 bytes of the GTK are used for decryption.) */\r\n    memset(sa->wpa.ptk, 0, sizeof(sa->wpa.ptk));\r\n    memcpy(sa->wpa.ptk+32, szEncryptedKey, key_len);\r\n    g_free(szEncryptedKey);\r\n    return AIRPDCAP_RET_SUCCESS_HANDSHAKE;\r\n}", ".irPDcapTDLSDeriveKey": "static INT\r\nAirPDcapTDLSDeriveKey(\r\n    PAIRPDCAP_SEC_ASSOCIATION sa,\r\n    const guint8 *data,\r\n#if GCRYPT_VERSION_NUMBER >= 0x010600\r\n    guint offset_rsne,\r\n#else\r\n    guint offset_rsne _U_,\r\n#endif\r\n    guint offset_fte,\r\n#if GCRYPT_VERSION_NUMBER >= 0x010600\r\n    guint offset_timeout,\r\n#else\r\n    guint offset_timeout _U_,\r\n#endif\r\n    guint offset_link,\r\n#if GCRYPT_VERSION_NUMBER >= 0x010600\r\n    guint8 action)\r\n#else\r\n    guint8 action _U_)\r\n#endif\r\n{\r\n\r\n    gcry_md_hd_t sha256_handle;\r\n    gcry_md_hd_t hmac_handle;\r\n    const guint8 *snonce, *anonce, *initiator, *responder, *bssid;\r\n    guint8 key_input[32];\r\n#if GCRYPT_VERSION_NUMBER >= 0x010600\r\n    guint8 mic[16], seq_num = action + 1;\r\n    guint8 zeros[16] = { 0 };\r\n    gcry_mac_hd_t cmac_handle;\r\n    size_t cmac_len = 16;\r\n    size_t cmac_write_len;\r\n#endif\r\n\r\n    /* Get key input */\r\n    anonce = &data[offset_fte + 20];\r\n    snonce = &data[offset_fte + 52];\r\n\r\n    gcry_md_open (&sha256_handle, GCRY_MD_SHA256, 0);\r\n    if (memcmp(anonce, snonce, AIRPDCAP_WPA_NONCE_LEN) < 0) {\r\n        gcry_md_write(sha256_handle, anonce, AIRPDCAP_WPA_NONCE_LEN);\r\n        gcry_md_write(sha256_handle, snonce, AIRPDCAP_WPA_NONCE_LEN);\r\n    } else {\r\n        gcry_md_write(sha256_handle, snonce, AIRPDCAP_WPA_NONCE_LEN);\r\n        gcry_md_write(sha256_handle, anonce, AIRPDCAP_WPA_NONCE_LEN);\r\n    }\r\n    memcpy(key_input, gcry_md_read(sha256_handle, 0), 32);\r\n    gcry_md_close(sha256_handle);\r\n\r\n    /* Derive key */\r\n    bssid = &data[offset_link + 2];\r\n    initiator = &data[offset_link + 8];\r\n    responder = &data[offset_link + 14];\r\n    if (gcry_md_open(&hmac_handle, GCRY_MD_SHA256, GCRY_MD_FLAG_HMAC)) {\r\n        return AIRPDCAP_RET_UNSUCCESS;\r\n    }\r\n    if (gcry_md_setkey(hmac_handle, key_input, 32)) {\r\n        gcry_md_close(hmac_handle);\r\n        return AIRPDCAP_RET_UNSUCCESS;\r\n    }\r\n    gcry_md_putc(hmac_handle, 1);\r\n    gcry_md_putc(hmac_handle, 0);\r\n    gcry_md_write(hmac_handle, \"TDLS PMK\", 8);\r\n    if (memcmp(initiator, responder, AIRPDCAP_MAC_LEN) < 0) {\r\n          gcry_md_write(hmac_handle, initiator, AIRPDCAP_MAC_LEN);\r\n          gcry_md_write(hmac_handle, responder, AIRPDCAP_MAC_LEN);\r\n    } else {\r\n          gcry_md_write(hmac_handle, responder, AIRPDCAP_MAC_LEN);\r\n          gcry_md_write(hmac_handle, initiator, AIRPDCAP_MAC_LEN);\r\n    }\r\n    gcry_md_write(hmac_handle, bssid, AIRPDCAP_MAC_LEN);\r\n    gcry_md_putc(hmac_handle, 0);\r\n    gcry_md_putc(hmac_handle, 1);\r\n    memcpy(key_input, gcry_md_read(hmac_handle, 0), 32);\r\n    gcry_md_close(hmac_handle);\r\n\r\n    /* Check MIC */\r\n#if GCRYPT_VERSION_NUMBER >= 0x010600\r\n    if (gcry_mac_open(&cmac_handle, GCRY_MAC_CMAC_AES, 0, NULL)) {\r\n        return AIRPDCAP_RET_UNSUCCESS;\r\n    }\r\n    if (gcry_mac_setkey(cmac_handle, key_input, 16)) {\r\n        gcry_mac_close(cmac_handle);\r\n        return AIRPDCAP_RET_UNSUCCESS;\r\n    }\r\n    gcry_mac_write(cmac_handle, initiator, AIRPDCAP_MAC_LEN);\r\n    gcry_mac_write(cmac_handle, responder, AIRPDCAP_MAC_LEN);\r\n    gcry_mac_write(cmac_handle, &seq_num, 1);\r\n    gcry_mac_write(cmac_handle, &data[offset_link], data[offset_link + 1] + 2);\r\n    gcry_mac_write(cmac_handle, &data[offset_rsne], data[offset_rsne + 1] + 2);\r\n    gcry_mac_write(cmac_handle, &data[offset_timeout], data[offset_timeout + 1] + 2);\r\n    gcry_mac_write(cmac_handle, &data[offset_fte], 4);\r\n    gcry_mac_write(cmac_handle, zeros, 16);\r\n    cmac_write_len = data[offset_fte + 1] + 2;\r\n    if (cmac_write_len < 20) {\r\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapTDLSDeriveKey\", \"Bad MAC len\", AIRPDCAP_DEBUG_LEVEL_3);\r\n        gcry_mac_close(cmac_handle);\r\n        return AIRPDCAP_RET_UNSUCCESS;\r\n    }\r\n    gcry_mac_write(cmac_handle, &data[offset_fte + 20], cmac_write_len - 20);\r\n    if (gcry_mac_read(cmac_handle, mic, &cmac_len) != GPG_ERR_NO_ERROR) {\r\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapTDLSDeriveKey\", \"MAC read error\", AIRPDCAP_DEBUG_LEVEL_3);\r\n        gcry_mac_close(cmac_handle);\r\n        return AIRPDCAP_RET_UNSUCCESS;\r\n    }\r\n    if (memcmp(mic, &data[offset_fte + 4], 16)) {\r\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapTDLSDeriveKey\", \"MIC verification failed\", AIRPDCAP_DEBUG_LEVEL_3);\r\n        gcry_mac_close(cmac_handle);\r\n        return AIRPDCAP_RET_UNSUCCESS;\r\n    }\r\n    gcry_mac_close(cmac_handle);\r\n#else\r\n    AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapTDLSDeriveKey\", \"MIC verification failed, need libgcrypt >= 1.6\", AIRPDCAP_DEBUG_LEVEL_3);\r\n    return AIRPDCAP_RET_UNSUCCESS;\r\n#endif\r\n    memcpy(AIRPDCAP_GET_TK(sa->wpa.ptk), &key_input[16], 16);\r\n    memcpy(sa->wpa.nonce, snonce, AIRPDCAP_WPA_NONCE_LEN);\r\n    sa->validKey = TRUE;\r\n    sa->wpa.key_ver = AIRPDCAP_WPA_KEY_VER_AES_CCMP;\r\n    AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapTDLSDeriveKey\", \"MIC verified\", AIRPDCAP_DEBUG_LEVEL_3);\r\n    return  AIRPDCAP_RET_SUCCESS;\r\n}", ".irPDcapGetSaAddress": "static INT\r\nAirPDcapGetSaAddress(\r\n    const AIRPDCAP_MAC_FRAME_ADDR4 *frame,\r\n    AIRPDCAP_SEC_ASSOCIATION_ID *id)\r\n{\r\n#ifdef AIRPDCAP_DEBUG\r\n#define MSGBUF_LEN 255\r\n    CHAR msgbuf[MSGBUF_LEN];\r\n#endif\r\n\r\n    if ((AIRPDCAP_TYPE(frame->fc[0])==AIRPDCAP_TYPE_DATA) &&\r\n        (AIRPDCAP_DS_BITS(frame->fc[1]) == 0) &&\r\n        (memcmp(frame->addr2, frame->addr3, AIRPDCAP_MAC_LEN) != 0) &&\r\n        (memcmp(frame->addr1, frame->addr3, AIRPDCAP_MAC_LEN) != 0)) {\r\n        /* DATA frame with fromDS=0 ToDS=0 and neither RA or SA is BSSID\r\n           => TDLS traffic. Use highest MAC address for bssid */\r\n        if (memcmp(frame->addr1, frame->addr2, AIRPDCAP_MAC_LEN) < 0) {\r\n            memcpy(id->sta, frame->addr1, AIRPDCAP_MAC_LEN);\r\n            memcpy(id->bssid, frame->addr2, AIRPDCAP_MAC_LEN);\r\n        } else {\r\n            memcpy(id->sta, frame->addr2, AIRPDCAP_MAC_LEN);\r\n            memcpy(id->bssid, frame->addr1, AIRPDCAP_MAC_LEN);\r\n        }\r\n    } else {\r\n        const UCHAR *addr;\r\n\r\n        /* Normal Case: SA between STA and AP */\r\n        if ((addr = AirPDcapGetBssidAddress(frame)) != NULL) {\r\n            memcpy(id->bssid, addr, AIRPDCAP_MAC_LEN);\r\n        } else {\r\n            return AIRPDCAP_RET_UNSUCCESS;\r\n        }\r\n\r\n        if ((addr = AirPDcapGetStaAddress(frame)) != NULL) {\r\n            memcpy(id->sta, addr, AIRPDCAP_MAC_LEN);\r\n        } else {\r\n            return AIRPDCAP_RET_UNSUCCESS;\r\n        }\r\n    }\r\n\r\n#ifdef AIRPDCAP_DEBUG\r\n    g_snprintf(msgbuf, MSGBUF_LEN, \"BSSID_MAC: %02X.%02X.%02X.%02X.%02X.%02X\\t\",\r\n               id->bssid[0],id->bssid[1],id->bssid[2],id->bssid[3],id->bssid[4],id->bssid[5]);\r\n    AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapGetSaAddress\", msgbuf, AIRPDCAP_DEBUG_LEVEL_3);\r\n    g_snprintf(msgbuf, MSGBUF_LEN, \"STA_MAC: %02X.%02X.%02X.%02X.%02X.%02X\\t\",\r\n               id->sta[0],id->sta[1],id->sta[2],id->sta[3],id->sta[4],id->sta[5]);\r\n    AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapGetSaAddress\", msgbuf, AIRPDCAP_DEBUG_LEVEL_3);\r\n#endif\r\n\r\n    return AIRPDCAP_RET_SUCCESS;\r\n}", ".irPDcapScanForKeys": "static INT AirPDcapScanForKeys(\r\n    PAIRPDCAP_CONTEXT ctx,\r\n    const guint8 *data,\r\n    const guint mac_header_len,\r\n    const guint tot_len,\r\n    AIRPDCAP_SEC_ASSOCIATION_ID id\r\n)\r\n{\r\n    const UCHAR *addr;\r\n    guint bodyLength;\r\n    PAIRPDCAP_SEC_ASSOCIATION sta_sa;\r\n    PAIRPDCAP_SEC_ASSOCIATION sa;\r\n    guint offset = 0;\r\n    const guint8 dot1x_header[] = {\r\n        0xAA,             /* DSAP=SNAP */\r\n        0xAA,             /* SSAP=SNAP */\r\n        0x03,             /* Control field=Unnumbered frame */\r\n        0x00, 0x00, 0x00, /* Org. code=encaps. Ethernet */\r\n        0x88, 0x8E        /* Type: 802.1X authentication */\r\n    };\r\n    const guint8 bt_dot1x_header[] = {\r\n        0xAA,             /* DSAP=SNAP */\r\n        0xAA,             /* SSAP=SNAP */\r\n        0x03,             /* Control field=Unnumbered frame */\r\n        0x00, 0x19, 0x58, /* Org. code=Bluetooth SIG */\r\n        0x00, 0x03        /* Type: Bluetooth Security */\r\n    };\r\n    const guint8 tdls_header[] = {\r\n        0xAA,             /* DSAP=SNAP */\r\n        0xAA,             /* SSAP=SNAP */\r\n        0x03,             /* Control field=Unnumbered frame */\r\n        0x00, 0x00, 0x00, /* Org. code=encaps. Ethernet */\r\n        0x89, 0x0D,       /* Type: 802.11 - Fast Roaming Remote Request */\r\n        0x02,             /* Payload Type: TDLS */\r\n        0X0C              /* Action Category: TDLS */\r\n    };\r\n\r\n    const EAPOL_RSN_KEY *pEAPKey;\r\n#ifdef AIRPDCAP_DEBUG\r\n#define MSGBUF_LEN 255\r\n    CHAR msgbuf[MSGBUF_LEN];\r\n#endif\r\n    AIRPDCAP_DEBUG_TRACE_START(\"AirPDcapScanForKeys\");\r\n\r\n    /* cache offset in the packet data */\r\n    offset = mac_header_len;\r\n\r\n    /* check if the packet has an LLC header and the packet is 802.1X authentication (IEEE 802.1X-2004, pg. 24) */\r\n    if (memcmp(data+offset, dot1x_header, 8) == 0 || memcmp(data+offset, bt_dot1x_header, 8) == 0) {\r\n\r\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Authentication: EAPOL packet\", AIRPDCAP_DEBUG_LEVEL_3);\r\n\r\n        /* skip LLC header */\r\n        offset+=8;\r\n\r\n        /* check if the packet is a EAPOL-Key (0x03) (IEEE 802.1X-2004, pg. 25) */\r\n        if (data[offset+1]!=3) {\r\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Not EAPOL-Key\", AIRPDCAP_DEBUG_LEVEL_3);\r\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\r\n        }\r\n\r\n        /* get and check the body length (IEEE 802.1X-2004, pg. 25) */\r\n        bodyLength=pntoh16(data+offset+2);\r\n        if (((tot_len-offset-4) < bodyLength) || (bodyLength < sizeof(EAPOL_RSN_KEY))) { /* Only check if frame is long enough for eapol header, ignore tailing garbage, see bug 9065 */\r\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"EAPOL body too short\", AIRPDCAP_DEBUG_LEVEL_3);\r\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\r\n        }\r\n\r\n        /* skip EAPOL MPDU and go to the first byte of the body */\r\n        offset+=4;\r\n\r\n        pEAPKey = (const EAPOL_RSN_KEY *) (data+offset);\r\n\r\n        /* check if the key descriptor type is valid (IEEE 802.1X-2004, pg. 27) */\r\n        if (/*pEAPKey->type!=0x1 &&*/ /* RC4 Key Descriptor Type (deprecated) */\r\n            pEAPKey->type != AIRPDCAP_RSN_WPA2_KEY_DESCRIPTOR &&             /* IEEE 802.11 Key Descriptor Type  (WPA2) */\r\n            pEAPKey->type != AIRPDCAP_RSN_WPA_KEY_DESCRIPTOR)           /* 254 = RSN_KEY_DESCRIPTOR - WPA,              */\r\n        {\r\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Not valid key descriptor type\", AIRPDCAP_DEBUG_LEVEL_3);\r\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\r\n        }\r\n\r\n        /* start with descriptor body */\r\n        offset+=1;\r\n\r\n        /* search for a cached Security Association for current BSSID and AP */\r\n        sa = AirPDcapGetSaPtr(ctx, &id);\r\n        if (sa == NULL){\r\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"No SA for BSSID found\", AIRPDCAP_DEBUG_LEVEL_3);\r\n            return AIRPDCAP_RET_REQ_DATA;\r\n        }\r\n\r\n        /* It could be a Pairwise Key exchange, check */\r\n        if (AirPDcapRsna4WHandshake(ctx, data, sa, offset, tot_len) == AIRPDCAP_RET_SUCCESS_HANDSHAKE)\r\n            return AIRPDCAP_RET_SUCCESS_HANDSHAKE;\r\n\r\n        if (mac_header_len + GROUP_KEY_PAYLOAD_LEN_MIN > tot_len) {\r\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Message too short for Group Key\", AIRPDCAP_DEBUG_LEVEL_3);\r\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\r\n        }\r\n\r\n        /* Verify the bitfields: Key = 0(groupwise) Mic = 1 Ack = 1 Secure = 1 */\r\n        if (AIRPDCAP_EAP_KEY(data[offset+1])!=0 ||\r\n            AIRPDCAP_EAP_ACK(data[offset+1])!=1 ||\r\n            AIRPDCAP_EAP_MIC(data[offset]) != 1 ||\r\n            AIRPDCAP_EAP_SEC(data[offset]) != 1){\r\n\r\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Key bitfields not correct for Group Key\", AIRPDCAP_DEBUG_LEVEL_3);\r\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\r\n        }\r\n\r\n        /* force STA address to be the broadcast MAC so we create an SA for the groupkey */\r\n        memcpy(id.sta, broadcast_mac, AIRPDCAP_MAC_LEN);\r\n\r\n        /* get the Security Association structure for the broadcast MAC and AP */\r\n        sa = AirPDcapGetSaPtr(ctx, &id);\r\n        if (sa == NULL){\r\n            return AIRPDCAP_RET_REQ_DATA;\r\n        }\r\n\r\n        /* Get the SA for the STA, since we need its pairwise key to decrpyt the group key */\r\n\r\n        /* get STA address */\r\n        if ( (addr=AirPDcapGetStaAddress((const AIRPDCAP_MAC_FRAME_ADDR4 *)(data))) != NULL) {\r\n            memcpy(id.sta, addr, AIRPDCAP_MAC_LEN);\r\n#ifdef AIRPDCAP_DEBUG\r\n            g_snprintf(msgbuf, MSGBUF_LEN, \"ST_MAC: %2X.%2X.%2X.%2X.%2X.%2X\\t\", id.sta[0],id.sta[1],id.sta[2],id.sta[3],id.sta[4],id.sta[5]);\r\n#endif\r\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", msgbuf, AIRPDCAP_DEBUG_LEVEL_3);\r\n        } else {\r\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"SA not found\", AIRPDCAP_DEBUG_LEVEL_5);\r\n            return AIRPDCAP_RET_REQ_DATA;\r\n        }\r\n\r\n        sta_sa = AirPDcapGetSaPtr(ctx, &id);\r\n        if (sta_sa == NULL){\r\n            return AIRPDCAP_RET_REQ_DATA;\r\n        }\r\n\r\n        /* Try to extract the group key and install it in the SA */\r\n        return (AirPDcapDecryptWPABroadcastKey(pEAPKey, sta_sa->wpa.ptk+16, sa, tot_len-offset+1));\r\n\r\n    } else if (memcmp(data+offset, tdls_header, 10) == 0) {\r\n        const guint8 *initiator, *responder;\r\n        guint8 action;\r\n        guint status, offset_rsne = 0, offset_fte = 0, offset_link = 0, offset_timeout = 0;\r\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Authentication: TDLS Action Frame\", AIRPDCAP_DEBUG_LEVEL_3);\r\n\r\n        /* skip LLC header */\r\n        offset+=10;\r\n\r\n        /* check if the packet is a TDLS response or confirm */\r\n        action = data[offset];\r\n        if (action!=1 && action!=2) {\r\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Not Response nor confirm\", AIRPDCAP_DEBUG_LEVEL_3);\r\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\r\n        }\r\n\r\n        /* check status */\r\n        offset++;\r\n        status=pntoh16(data+offset);\r\n        if (status!=0) {\r\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"TDLS setup not successfull\", AIRPDCAP_DEBUG_LEVEL_3);\r\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\r\n        }\r\n\r\n        /* skip Token + capabilities */\r\n        offset+=5;\r\n\r\n        /* search for RSN, Fast BSS Transition, Link Identifier and Timeout Interval IEs */\r\n\r\n        while(offset < (tot_len - 2)) {\r\n            if (data[offset] == 48) {\r\n                offset_rsne = offset;\r\n            } else if (data[offset] == 55) {\r\n                offset_fte = offset;\r\n            } else if (data[offset] == 56) {\r\n                offset_timeout = offset;\r\n            } else if (data[offset] == 101) {\r\n                offset_link = offset;\r\n            }\r\n\r\n            if (tot_len < offset + data[offset + 1] + 2) {\r\n                return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\r\n            }\r\n            offset += data[offset + 1] + 2;\r\n        }\r\n\r\n        if (offset_rsne == 0 || offset_fte == 0 ||\r\n            offset_timeout == 0 || offset_link == 0)\r\n        {\r\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Cannot Find all necessary IEs\", AIRPDCAP_DEBUG_LEVEL_3);\r\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\r\n        }\r\n\r\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Found RSNE/Fast BSS/Timeout Interval/Link IEs\", AIRPDCAP_DEBUG_LEVEL_3);\r\n\r\n        /* Will create a Security Association between 2 STA. Need to get both MAC address */\r\n        initiator = &data[offset_link + 8];\r\n        responder = &data[offset_link + 14];\r\n\r\n        if (memcmp(initiator, responder, AIRPDCAP_MAC_LEN) < 0) {\r\n            memcpy(id.sta, initiator, AIRPDCAP_MAC_LEN);\r\n            memcpy(id.bssid, responder, AIRPDCAP_MAC_LEN);\r\n        } else {\r\n            memcpy(id.sta, responder, AIRPDCAP_MAC_LEN);\r\n            memcpy(id.bssid, initiator, AIRPDCAP_MAC_LEN);\r\n        }\r\n\r\n        sa = AirPDcapGetSaPtr(ctx, &id);\r\n        if (sa == NULL){\r\n            return AIRPDCAP_RET_REQ_DATA;\r\n        }\r\n\r\n        if (sa->validKey) {\r\n            if (memcmp(sa->wpa.nonce, data + offset_fte + 52, AIRPDCAP_WPA_NONCE_LEN) == 0) {\r\n                /* Already have valid key for this SA, no need to redo key derivation */\r\n                return AIRPDCAP_RET_SUCCESS_HANDSHAKE;\r\n            } else {\r\n                /* We are opening a new session with the same two STA, save previous sa  */\r\n                AIRPDCAP_SEC_ASSOCIATION *tmp_sa = g_new(AIRPDCAP_SEC_ASSOCIATION, 1);\r\n                memcpy(tmp_sa, sa, sizeof(AIRPDCAP_SEC_ASSOCIATION));\r\n                sa->next=tmp_sa;\r\n                sa->validKey = FALSE;\r\n            }\r\n        }\r\n\r\n        if (AirPDcapTDLSDeriveKey(sa, data, offset_rsne, offset_fte, offset_timeout, offset_link, action)\r\n            == AIRPDCAP_RET_SUCCESS) {\r\n            AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapScanForKeys\");\r\n            return AIRPDCAP_RET_SUCCESS_HANDSHAKE;\r\n        }\r\n    } else {\r\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Skipping: not an EAPOL packet\", AIRPDCAP_DEBUG_LEVEL_3);\r\n    }\r\n\r\n    AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapScanForKeys\");\r\n    return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\r\n}", ".irPDcapWepMng": "static INT\r\nAirPDcapWepMng(\r\n    PAIRPDCAP_CONTEXT ctx,\r\n    UCHAR *decrypt_data,\r\n    guint mac_header_len,\r\n    guint *decrypt_len,\r\n    PAIRPDCAP_KEY_ITEM key,\r\n    AIRPDCAP_SEC_ASSOCIATION *sa,\r\n    INT offset)\r\n{\r\n    UCHAR wep_key[AIRPDCAP_WEP_KEY_MAXLEN+AIRPDCAP_WEP_IVLEN];\r\n    size_t keylen;\r\n    INT ret_value=1;\r\n    INT key_index;\r\n    AIRPDCAP_KEY_ITEM *tmp_key;\r\n    UINT8 useCache=FALSE;\r\n    UCHAR *try_data;\r\n    guint try_data_len = *decrypt_len;\r\n\r\n    try_data = (UCHAR *)g_malloc(try_data_len);\r\n\r\n    if (sa->key!=NULL)\r\n        useCache=TRUE;\r\n\r\n    for (key_index=0; key_index<(INT)ctx->keys_nr; key_index++) {\r\n        /* use the cached one, or try all keys */\r\n        if (!useCache) {\r\n            tmp_key=&ctx->keys[key_index];\r\n        } else {\r\n            if (sa->key!=NULL && sa->key->KeyType==AIRPDCAP_KEY_TYPE_WEP) {\r\n                AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapWepMng\", \"Try cached WEP key...\", AIRPDCAP_DEBUG_LEVEL_3);\r\n                tmp_key=sa->key;\r\n            } else {\r\n                AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapWepMng\", \"Cached key is not valid, try another WEP key...\", AIRPDCAP_DEBUG_LEVEL_3);\r\n                tmp_key=&ctx->keys[key_index];\r\n            }\r\n        }\r\n\r\n        /* obviously, try only WEP keys... */\r\n        if (tmp_key->KeyType==AIRPDCAP_KEY_TYPE_WEP) {\r\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapWepMng\", \"Try WEP key...\", AIRPDCAP_DEBUG_LEVEL_3);\r\n\r\n            memset(wep_key, 0, sizeof(wep_key));\r\n            memcpy(try_data, decrypt_data, *decrypt_len);\r\n\r\n            /* Costruct the WEP seed: copy the IV in first 3 bytes and then the WEP key (refer to 802-11i-2004, 8.2.1.4.3, pag. 36) */\r\n            memcpy(wep_key, try_data+mac_header_len, AIRPDCAP_WEP_IVLEN);\r\n            keylen=tmp_key->KeyData.Wep.WepKeyLen;\r\n            memcpy(wep_key+AIRPDCAP_WEP_IVLEN, tmp_key->KeyData.Wep.WepKey, keylen);\r\n\r\n            ret_value=AirPDcapWepDecrypt(wep_key,\r\n                keylen+AIRPDCAP_WEP_IVLEN,\r\n                try_data + (mac_header_len+AIRPDCAP_WEP_IVLEN+AIRPDCAP_WEP_KIDLEN),\r\n                *decrypt_len-(mac_header_len+AIRPDCAP_WEP_IVLEN+AIRPDCAP_WEP_KIDLEN+AIRPDCAP_CRC_LEN));\r\n\r\n            if (ret_value == AIRPDCAP_RET_SUCCESS)\r\n                memcpy(decrypt_data, try_data, *decrypt_len);\r\n        }\r\n\r\n        if (!ret_value && tmp_key->KeyType==AIRPDCAP_KEY_TYPE_WEP) {\r\n            /* the tried key is the correct one, cached in the Security Association */\r\n\r\n            sa->key=tmp_key;\r\n\r\n            if (key!=NULL) {\r\n                memcpy(key, sa->key, sizeof(AIRPDCAP_KEY_ITEM));\r\n                key->KeyType=AIRPDCAP_KEY_TYPE_WEP;\r\n            }\r\n\r\n            break;\r\n        } else {\r\n            /* the cached key was not valid, try other keys */\r\n\r\n            if (useCache==TRUE) {\r\n                useCache=FALSE;\r\n                key_index--;\r\n            }\r\n        }\r\n    }\r\n\r\n    g_free(try_data);\r\n    if (ret_value)\r\n        return AIRPDCAP_RET_UNSUCCESS;\r\n\r\n    AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapWepMng\", \"WEP DECRYPTED!!!\", AIRPDCAP_DEBUG_LEVEL_3);\r\n\r\n    /* remove ICV (4bytes) from the end of packet */\r\n    *decrypt_len-=4;\r\n\r\n    if (*decrypt_len < 4) {\r\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapWepMng\", \"Decryption length too short\", AIRPDCAP_DEBUG_LEVEL_3);\r\n        return AIRPDCAP_RET_UNSUCCESS;\r\n    }\r\n\r\n    /* remove protection bit */\r\n    decrypt_data[1]&=0xBF;\r\n\r\n    /* remove IC header */\r\n    offset = mac_header_len;\r\n    *decrypt_len-=4;\r\n    memmove(decrypt_data+offset, decrypt_data+offset+AIRPDCAP_WEP_IVLEN+AIRPDCAP_WEP_KIDLEN, *decrypt_len-offset);\r\n\r\n    return AIRPDCAP_RET_SUCCESS;\r\n}", ".irPDcapRsnaMng": "static INT\r\nAirPDcapRsnaMng(\r\n    UCHAR *decrypt_data,\r\n    guint mac_header_len,\r\n    guint *decrypt_len,\r\n    PAIRPDCAP_KEY_ITEM key,\r\n    AIRPDCAP_SEC_ASSOCIATION *sa,\r\n    INT offset)\r\n{\r\n    INT ret_value=1;\r\n    UCHAR *try_data;\r\n    guint try_data_len = *decrypt_len;\r\n\r\n    if (*decrypt_len > try_data_len) {\r\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsnaMng\", \"Invalid decryption length\", AIRPDCAP_DEBUG_LEVEL_3);\r\n        return AIRPDCAP_RET_UNSUCCESS;\r\n    }\r\n\r\n    /* allocate a temp buffer for the decryption loop */\r\n    try_data=(UCHAR *)g_malloc(try_data_len);\r\n\r\n    /* start of loop added by GCS */\r\n    for(/* sa */; sa != NULL ;sa=sa->next) {\r\n\r\n       if (sa->validKey==FALSE) {\r\n           AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsnaMng\", \"Key not yet valid\", AIRPDCAP_DEBUG_LEVEL_3);\r\n           continue;\r\n       }\r\n\r\n       /* copy the encrypted data into a temp buffer */\r\n       memcpy(try_data, decrypt_data, *decrypt_len);\r\n\r\n       if (sa->wpa.key_ver==1) {\r\n           /* CCMP -> HMAC-MD5 is the EAPOL-Key MIC, RC4 is the EAPOL-Key encryption algorithm */\r\n           AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsnaMng\", \"TKIP\", AIRPDCAP_DEBUG_LEVEL_3);\r\n           DEBUG_DUMP(\"ptk\", sa->wpa.ptk, 64);\r\n           DEBUG_DUMP(\"ptk portion used\", AIRPDCAP_GET_TK(sa->wpa.ptk), 16);\r\n\r\n           ret_value=AirPDcapTkipDecrypt(try_data+offset, *decrypt_len-offset, try_data+AIRPDCAP_TA_OFFSET, AIRPDCAP_GET_TK(sa->wpa.ptk));\r\n           if (ret_value){\r\n               AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsnaMng\", \"TKIP failed!\", AIRPDCAP_DEBUG_LEVEL_3);\r\n               continue;\r\n           }\r\n\r\n           AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsnaMng\", \"TKIP DECRYPTED!!!\", AIRPDCAP_DEBUG_LEVEL_3);\r\n           /* remove MIC (8bytes) and ICV (4bytes) from the end of packet */\r\n           *decrypt_len-=12;\r\n           break;\r\n       } else {\r\n           /* AES-CCMP -> HMAC-SHA1-128 is the EAPOL-Key MIC, AES wep_key wrap is the EAPOL-Key encryption algorithm */\r\n           AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsnaMng\", \"CCMP\", AIRPDCAP_DEBUG_LEVEL_3);\r\n\r\n           ret_value=AirPDcapCcmpDecrypt(try_data, mac_header_len, (INT)*decrypt_len, AIRPDCAP_GET_TK(sa->wpa.ptk));\r\n           if (ret_value)\r\n              continue;\r\n\r\n           AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsnaMng\", \"CCMP DECRYPTED!!!\", AIRPDCAP_DEBUG_LEVEL_3);\r\n           /* remove MIC (8bytes) from the end of packet */\r\n           *decrypt_len-=8;\r\n           break;\r\n       }\r\n    }\r\n    /* end of loop */\r\n\r\n    /* none of the keys worked */\r\n    if(sa == NULL) {\r\n        g_free(try_data);\r\n        return ret_value;\r\n    }\r\n\r\n    if (*decrypt_len > try_data_len || *decrypt_len < 8) {\r\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsnaMng\", \"Invalid decryption length\", AIRPDCAP_DEBUG_LEVEL_3);\r\n        g_free(try_data);\r\n        return AIRPDCAP_RET_UNSUCCESS;\r\n    }\r\n\r\n    /* copy the decrypted data into the decrypt buffer GCS*/\r\n    memcpy(decrypt_data, try_data, *decrypt_len);\r\n    g_free(try_data);\r\n\r\n    /* remove protection bit */\r\n    decrypt_data[1]&=0xBF;\r\n\r\n    /* remove TKIP/CCMP header */\r\n    offset = mac_header_len;\r\n    *decrypt_len-=8;\r\n    memmove(decrypt_data+offset, decrypt_data+offset+8, *decrypt_len-offset);\r\n\r\n    if (key!=NULL) {\r\n        if (sa->key!=NULL)\r\n            memcpy(key, sa->key, sizeof(AIRPDCAP_KEY_ITEM));\r\n        else\r\n            memset(key, 0, sizeof(AIRPDCAP_KEY_ITEM));\r\n        memcpy(key->KeyData.Wpa.Ptk, sa->wpa.ptk, AIRPDCAP_WPA_PTK_LEN); /* copy the PTK to the key structure for future use by wireshark */\r\n        if (sa->wpa.key_ver==AIRPDCAP_WPA_KEY_VER_NOT_CCMP)\r\n            key->KeyType=AIRPDCAP_KEY_TYPE_TKIP;\r\n        else if (sa->wpa.key_ver==AIRPDCAP_WPA_KEY_VER_AES_CCMP)\r\n            key->KeyType=AIRPDCAP_KEY_TYPE_CCMP;\r\n    }\r\n\r\n    return AIRPDCAP_RET_SUCCESS;\r\n}", ".irPDcapInitContext": "INT AirPDcapInitContext(\r\n    PAIRPDCAP_CONTEXT ctx)\r\n{\r\n    AIRPDCAP_DEBUG_TRACE_START(\"AirPDcapInitContext\");\r\n\r\n    if (ctx==NULL) {\r\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapInitContext\", \"NULL context\", AIRPDCAP_DEBUG_LEVEL_5);\r\n        AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapInitContext\");\r\n        return AIRPDCAP_RET_UNSUCCESS;\r\n    }\r\n\r\n    AirPDcapCleanKeys(ctx);\r\n\r\n    ctx->first_free_index=0;\r\n    ctx->index=-1;\r\n    ctx->sa_index=-1;\r\n    ctx->pkt_ssid_len = 0;\r\n\r\n    memset(ctx->sa, 0, AIRPDCAP_MAX_SEC_ASSOCIATIONS_NR * sizeof(AIRPDCAP_SEC_ASSOCIATION));\r\n\r\n    AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapInitContext\", \"Context initialized!\", AIRPDCAP_DEBUG_LEVEL_5);\r\n    AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapInitContext\");\r\n    return AIRPDCAP_RET_SUCCESS;\r\n}", ".irPDcapValidateKey": "static INT\r\nAirPDcapValidateKey(\r\n    PAIRPDCAP_KEY_ITEM key)\r\n{\r\n    size_t len;\r\n    UCHAR ret=TRUE;\r\n    AIRPDCAP_DEBUG_TRACE_START(\"AirPDcapValidateKey\");\r\n\r\n    if (key==NULL) {\r\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapValidateKey\", \"NULL key\", AIRPDCAP_DEBUG_LEVEL_5);\r\n        AIRPDCAP_DEBUG_TRACE_START(\"AirPDcapValidateKey\");\r\n        return FALSE;\r\n    }\r\n\r\n    switch (key->KeyType) {\r\n        case AIRPDCAP_KEY_TYPE_WEP:\r\n            /* check key size limits */\r\n            len=key->KeyData.Wep.WepKeyLen;\r\n            if (len<AIRPDCAP_WEP_KEY_MINLEN || len>AIRPDCAP_WEP_KEY_MAXLEN) {\r\n                AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapValidateKey\", \"WEP key: key length not accepted\", AIRPDCAP_DEBUG_LEVEL_5);\r\n                ret=FALSE;\r\n            }\r\n            break;\r\n\r\n        case AIRPDCAP_KEY_TYPE_WEP_40:\r\n            /* set the standard length and use a generic WEP key type */\r\n            key->KeyData.Wep.WepKeyLen=AIRPDCAP_WEP_40_KEY_LEN;\r\n            key->KeyType=AIRPDCAP_KEY_TYPE_WEP;\r\n            break;\r\n\r\n        case AIRPDCAP_KEY_TYPE_WEP_104:\r\n            /* set the standard length and use a generic WEP key type */\r\n            key->KeyData.Wep.WepKeyLen=AIRPDCAP_WEP_104_KEY_LEN;\r\n            key->KeyType=AIRPDCAP_KEY_TYPE_WEP;\r\n            break;\r\n\r\n        case AIRPDCAP_KEY_TYPE_WPA_PWD:\r\n            /* check passphrase and SSID size limits */\r\n            len=strlen(key->UserPwd.Passphrase);\r\n            if (len<AIRPDCAP_WPA_PASSPHRASE_MIN_LEN || len>AIRPDCAP_WPA_PASSPHRASE_MAX_LEN) {\r\n                AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapValidateKey\", \"WPA-PWD key: passphrase length not accepted\", AIRPDCAP_DEBUG_LEVEL_5);\r\n                ret=FALSE;\r\n            }\r\n\r\n            len=key->UserPwd.SsidLen;\r\n            if (len>AIRPDCAP_WPA_SSID_MAX_LEN) {\r\n                AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapValidateKey\", \"WPA-PWD key: ssid length not accepted\", AIRPDCAP_DEBUG_LEVEL_5);\r\n                ret=FALSE;\r\n            }\r\n\r\n            break;\r\n\r\n        case AIRPDCAP_KEY_TYPE_WPA_PSK:\r\n            break;\r\n\r\n        case AIRPDCAP_KEY_TYPE_WPA_PMK:\r\n            break;\r\n\r\n        default:\r\n            ret=FALSE;\r\n    }\r\n\r\n    AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapValidateKey\");\r\n    return ret;\r\n}", ".irPDcapRsnaPwd2Psk": "static INT\r\nAirPDcapRsnaPwd2Psk(\r\n    const CHAR *passphrase,\r\n    const CHAR *ssid,\r\n    const size_t ssidLength,\r\n    UCHAR *output)\r\n{\r\n    UCHAR m_output[40] = { 0 };\r\n    GByteArray *pp_ba = g_byte_array_new();\r\n\r\n    if (!uri_str_to_bytes(passphrase, pp_ba)) {\r\n        g_byte_array_free(pp_ba, TRUE);\r\n        return 0;\r\n    }\r\n\r\n    AirPDcapRsnaPwd2PskStep(pp_ba->data, pp_ba->len, ssid, ssidLength, 4096, 1, m_output);\r\n    AirPDcapRsnaPwd2PskStep(pp_ba->data, pp_ba->len, ssid, ssidLength, 4096, 2, &m_output[20]);\r\n\r\n    memcpy(output, m_output, AIRPDCAP_WPA_PSK_LEN);\r\n    g_byte_array_free(pp_ba, TRUE);\r\n\r\n    return 0;\r\n}", ".irPDcapRecurseCleanSA": "static void\r\nAirPDcapRecurseCleanSA(\r\n    PAIRPDCAP_SEC_ASSOCIATION sa)\r\n{\r\n    if (sa->next != NULL) {\r\n        AirPDcapRecurseCleanSA(sa->next);\r\n        g_free(sa->next);\r\n        sa->next = NULL;\r\n    }\r\n}", ".irPDcapCleanKeys": "static void\r\nAirPDcapCleanKeys(\r\n    PAIRPDCAP_CONTEXT ctx)\r\n{\r\n    AIRPDCAP_DEBUG_TRACE_START(\"AirPDcapCleanKeys\");\r\n\r\n    if (ctx==NULL) {\r\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapCleanKeys\", \"NULL context\", AIRPDCAP_DEBUG_LEVEL_5);\r\n        AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapCleanKeys\");\r\n        return;\r\n    }\r\n\r\n    memset(ctx->keys, 0, sizeof(AIRPDCAP_KEY_ITEM) * AIRPDCAP_MAX_KEYS_NR);\r\n\r\n    ctx->keys_nr=0;\r\n\r\n    AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapCleanKeys\", \"Keys collection cleaned!\", AIRPDCAP_DEBUG_LEVEL_5);\r\n    AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapCleanKeys\");\r\n}", ".irPDcapCleanSecAssoc": "static void\r\nAirPDcapCleanSecAssoc(\r\n    PAIRPDCAP_CONTEXT ctx)\r\n{\r\n    PAIRPDCAP_SEC_ASSOCIATION psa;\r\n    int i;\r\n\r\n    for (psa = ctx->sa, i = 0; i < AIRPDCAP_MAX_SEC_ASSOCIATIONS_NR; i++, psa++) {\r\n        /* To iterate is human, to recurse, divine */\r\n        AirPDcapRecurseCleanSA(psa);\r\n    }\r\n}", ".irPDcapRsnaPrfX": "static void\r\nAirPDcapRsnaPrfX(\r\n    AIRPDCAP_SEC_ASSOCIATION *sa,\r\n    const UCHAR pmk[32],\r\n    const UCHAR snonce[32],\r\n    const INT x,        /*      for TKIP 512, for CCMP 384 */\r\n    UCHAR *ptk)\r\n{\r\n    UINT8 i;\r\n    UCHAR R[100];\r\n    INT offset=sizeof(\"Pairwise key expansion\");\r\n    UCHAR output[80]; /* allow for sha1 overflow. */\r\n\r\n    memset(R, 0, 100);\r\n\r\n    memcpy(R, \"Pairwise key expansion\", offset);\r\n\r\n    /* Min(AA, SPA) || Max(AA, SPA) */\r\n    if (memcmp(sa->saId.sta, sa->saId.bssid, AIRPDCAP_MAC_LEN) < 0)\r\n    {\r\n        memcpy(R + offset, sa->saId.sta, AIRPDCAP_MAC_LEN);\r\n        memcpy(R + offset+AIRPDCAP_MAC_LEN, sa->saId.bssid, AIRPDCAP_MAC_LEN);\r\n    }\r\n    else\r\n    {\r\n        memcpy(R + offset, sa->saId.bssid, AIRPDCAP_MAC_LEN);\r\n        memcpy(R + offset+AIRPDCAP_MAC_LEN, sa->saId.sta, AIRPDCAP_MAC_LEN);\r\n    }\r\n\r\n    offset+=AIRPDCAP_MAC_LEN*2;\r\n\r\n    /* Min(ANonce,SNonce) || Max(ANonce,SNonce) */\r\n    if( memcmp(snonce, sa->wpa.nonce, 32) < 0 )\r\n    {\r\n        memcpy(R + offset, snonce, 32);\r\n        memcpy(R + offset + 32, sa->wpa.nonce, 32);\r\n    }\r\n    else\r\n    {\r\n        memcpy(R + offset, sa->wpa.nonce, 32);\r\n        memcpy(R + offset + 32, snonce, 32);\r\n    }\r\n\r\n    offset+=32*2;\r\n\r\n    for(i = 0; i < (x+159)/160; i++)\r\n    {\r\n        R[offset] = i;\r\n        if (ws_hmac_buffer(GCRY_MD_SHA1, &output[HASH_SHA1_LENGTH * i], R, 100, pmk, 32)) {\r\n          return;\r\n        }\r\n    }\r\n    memcpy(ptk, output, x/8);\r\n}", ".irPDcapRsnaMicCheck": "static INT\r\nAirPDcapRsnaMicCheck(\r\n    UCHAR *eapol,\r\n    USHORT eapol_len,\r\n    UCHAR KCK[AIRPDCAP_WPA_KCK_LEN],\r\n    USHORT key_ver)\r\n{\r\n    UCHAR mic[AIRPDCAP_WPA_MICKEY_LEN];\r\n    UCHAR c_mic[HASH_SHA1_LENGTH] = { 0 };  /* MIC 16 byte, the HMAC-SHA1 use a buffer of 20 bytes */\r\n    int algo;\r\n\r\n    /* copy the MIC from the EAPOL packet */\r\n    memcpy(mic, eapol+AIRPDCAP_WPA_MICKEY_OFFSET+4, AIRPDCAP_WPA_MICKEY_LEN);\r\n\r\n    /* set to 0 the MIC in the EAPOL packet (to calculate the MIC) */\r\n    memset(eapol+AIRPDCAP_WPA_MICKEY_OFFSET+4, 0, AIRPDCAP_WPA_MICKEY_LEN);\r\n\r\n    if (key_ver==AIRPDCAP_WPA_KEY_VER_NOT_CCMP) {\r\n        /* use HMAC-MD5 for the EAPOL-Key MIC */\r\n        algo = GCRY_MD_MD5;\r\n    } else if (key_ver==AIRPDCAP_WPA_KEY_VER_AES_CCMP) {\r\n        /* use HMAC-SHA1-128 for the EAPOL-Key MIC */\r\n        algo = GCRY_MD_SHA1;\r\n    } else {\r\n        /* key descriptor version not recognized */\r\n        return AIRPDCAP_RET_UNSUCCESS;\r\n    }\r\n\r\n    if (ws_hmac_buffer(algo, c_mic, eapol, eapol_len, KCK, AIRPDCAP_WPA_KCK_LEN)) {\r\n        return AIRPDCAP_RET_UNSUCCESS;\r\n    }\r\n\r\n    /* compare calculated MIC with the Key MIC and return result (0 means success) */\r\n    return memcmp(mic, c_mic, AIRPDCAP_WPA_MICKEY_LEN);\r\n}", ".irPDcapRsnaPwd2PskStep": "static INT\r\nAirPDcapRsnaPwd2PskStep(\r\n    const guint8 *ppBytes,\r\n    const guint ppLength,\r\n    const CHAR *ssid,\r\n    const size_t ssidLength,\r\n    const INT iterations,\r\n    const INT count,\r\n    UCHAR *output)\r\n{\r\n    UCHAR digest[MAX_SSID_LENGTH+4] = { 0 };  /* SSID plus 4 bytes of count */\r\n    INT i, j;\r\n\r\n    if (ssidLength > MAX_SSID_LENGTH) {\r\n        /* This \"should not happen\" */\r\n        return AIRPDCAP_RET_UNSUCCESS;\r\n    }\r\n\r\n    /* U1 = PRF(P, S || INT(i)) */\r\n    memcpy(digest, ssid, ssidLength);\r\n    digest[ssidLength] = (UCHAR)((count>>24) & 0xff);\r\n    digest[ssidLength+1] = (UCHAR)((count>>16) & 0xff);\r\n    digest[ssidLength+2] = (UCHAR)((count>>8) & 0xff);\r\n    digest[ssidLength+3] = (UCHAR)(count & 0xff);\r\n    if (ws_hmac_buffer(GCRY_MD_SHA1, digest, digest, (guint32) ssidLength + 4, ppBytes, ppLength)) {\r\n      return AIRPDCAP_RET_UNSUCCESS;\r\n    }\r\n\r\n    /* output = U1 */\r\n    memcpy(output, digest, 20);\r\n    for (i = 1; i < iterations; i++) {\r\n        /* Un = PRF(P, Un-1) */\r\n        if (ws_hmac_buffer(GCRY_MD_SHA1, digest, digest, HASH_SHA1_LENGTH, ppBytes, ppLength)) {\r\n          return AIRPDCAP_RET_UNSUCCESS;\r\n        }\r\n\r\n        /* output = output xor Un */\r\n        for (j = 0; j < 20; j++) {\r\n            output[j] ^= digest[j];\r\n        }\r\n    }\r\n\r\n    return AIRPDCAP_RET_SUCCESS;\r\n}"}, "callee": {".irPDcapScanForKeys": "static INT AirPDcapScanForKeys(\r\n    PAIRPDCAP_CONTEXT ctx,\r\n    const guint8 *data,\r\n    const guint mac_header_len,\r\n    const guint tot_len,\r\n    AIRPDCAP_SEC_ASSOCIATION_ID id\r\n)\r\n{\r\n    const UCHAR *addr;\r\n    guint bodyLength;\r\n    PAIRPDCAP_SEC_ASSOCIATION sta_sa;\r\n    PAIRPDCAP_SEC_ASSOCIATION sa;\r\n    guint offset = 0;\r\n    const guint8 dot1x_header[] = {\r\n        0xAA,             /* DSAP=SNAP */\r\n        0xAA,             /* SSAP=SNAP */\r\n        0x03,             /* Control field=Unnumbered frame */\r\n        0x00, 0x00, 0x00, /* Org. code=encaps. Ethernet */\r\n        0x88, 0x8E        /* Type: 802.1X authentication */\r\n    };\r\n    const guint8 bt_dot1x_header[] = {\r\n        0xAA,             /* DSAP=SNAP */\r\n        0xAA,             /* SSAP=SNAP */\r\n        0x03,             /* Control field=Unnumbered frame */\r\n        0x00, 0x19, 0x58, /* Org. code=Bluetooth SIG */\r\n        0x00, 0x03        /* Type: Bluetooth Security */\r\n    };\r\n    const guint8 tdls_header[] = {\r\n        0xAA,             /* DSAP=SNAP */\r\n        0xAA,             /* SSAP=SNAP */\r\n        0x03,             /* Control field=Unnumbered frame */\r\n        0x00, 0x00, 0x00, /* Org. code=encaps. Ethernet */\r\n        0x89, 0x0D,       /* Type: 802.11 - Fast Roaming Remote Request */\r\n        0x02,             /* Payload Type: TDLS */\r\n        0X0C              /* Action Category: TDLS */\r\n    };\r\n\r\n    const EAPOL_RSN_KEY *pEAPKey;\r\n#ifdef AIRPDCAP_DEBUG\r\n#define MSGBUF_LEN 255\r\n    CHAR msgbuf[MSGBUF_LEN];\r\n#endif\r\n    AIRPDCAP_DEBUG_TRACE_START(\"AirPDcapScanForKeys\");\r\n\r\n    /* cache offset in the packet data */\r\n    offset = mac_header_len;\r\n\r\n    /* check if the packet has an LLC header and the packet is 802.1X authentication (IEEE 802.1X-2004, pg. 24) */\r\n    if (memcmp(data+offset, dot1x_header, 8) == 0 || memcmp(data+offset, bt_dot1x_header, 8) == 0) {\r\n\r\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Authentication: EAPOL packet\", AIRPDCAP_DEBUG_LEVEL_3);\r\n\r\n        /* skip LLC header */\r\n        offset+=8;\r\n\r\n        /* check if the packet is a EAPOL-Key (0x03) (IEEE 802.1X-2004, pg. 25) */\r\n        if (data[offset+1]!=3) {\r\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Not EAPOL-Key\", AIRPDCAP_DEBUG_LEVEL_3);\r\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\r\n        }\r\n\r\n        /* get and check the body length (IEEE 802.1X-2004, pg. 25) */\r\n        bodyLength=pntoh16(data+offset+2);\r\n        if (((tot_len-offset-4) < bodyLength) || (bodyLength < sizeof(EAPOL_RSN_KEY))) { /* Only check if frame is long enough for eapol header, ignore tailing garbage, see bug 9065 */\r\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"EAPOL body too short\", AIRPDCAP_DEBUG_LEVEL_3);\r\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\r\n        }\r\n\r\n        /* skip EAPOL MPDU and go to the first byte of the body */\r\n        offset+=4;\r\n\r\n        pEAPKey = (const EAPOL_RSN_KEY *) (data+offset);\r\n\r\n        /* check if the key descriptor type is valid (IEEE 802.1X-2004, pg. 27) */\r\n        if (/*pEAPKey->type!=0x1 &&*/ /* RC4 Key Descriptor Type (deprecated) */\r\n            pEAPKey->type != AIRPDCAP_RSN_WPA2_KEY_DESCRIPTOR &&             /* IEEE 802.11 Key Descriptor Type  (WPA2) */\r\n            pEAPKey->type != AIRPDCAP_RSN_WPA_KEY_DESCRIPTOR)           /* 254 = RSN_KEY_DESCRIPTOR - WPA,              */\r\n        {\r\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Not valid key descriptor type\", AIRPDCAP_DEBUG_LEVEL_3);\r\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\r\n        }\r\n\r\n        /* start with descriptor body */\r\n        offset+=1;\r\n\r\n        /* search for a cached Security Association for current BSSID and AP */\r\n        sa = AirPDcapGetSaPtr(ctx, &id);\r\n        if (sa == NULL){\r\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"No SA for BSSID found\", AIRPDCAP_DEBUG_LEVEL_3);\r\n            return AIRPDCAP_RET_REQ_DATA;\r\n        }\r\n\r\n        /* It could be a Pairwise Key exchange, check */\r\n        if (AirPDcapRsna4WHandshake(ctx, data, sa, offset, tot_len) == AIRPDCAP_RET_SUCCESS_HANDSHAKE)\r\n            return AIRPDCAP_RET_SUCCESS_HANDSHAKE;\r\n\r\n        if (mac_header_len + GROUP_KEY_PAYLOAD_LEN_MIN > tot_len) {\r\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Message too short for Group Key\", AIRPDCAP_DEBUG_LEVEL_3);\r\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\r\n        }\r\n\r\n        /* Verify the bitfields: Key = 0(groupwise) Mic = 1 Ack = 1 Secure = 1 */\r\n        if (AIRPDCAP_EAP_KEY(data[offset+1])!=0 ||\r\n            AIRPDCAP_EAP_ACK(data[offset+1])!=1 ||\r\n            AIRPDCAP_EAP_MIC(data[offset]) != 1 ||\r\n            AIRPDCAP_EAP_SEC(data[offset]) != 1){\r\n\r\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Key bitfields not correct for Group Key\", AIRPDCAP_DEBUG_LEVEL_3);\r\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\r\n        }\r\n\r\n        /* force STA address to be the broadcast MAC so we create an SA for the groupkey */\r\n        memcpy(id.sta, broadcast_mac, AIRPDCAP_MAC_LEN);\r\n\r\n        /* get the Security Association structure for the broadcast MAC and AP */\r\n        sa = AirPDcapGetSaPtr(ctx, &id);\r\n        if (sa == NULL){\r\n            return AIRPDCAP_RET_REQ_DATA;\r\n        }\r\n\r\n        /* Get the SA for the STA, since we need its pairwise key to decrpyt the group key */\r\n\r\n        /* get STA address */\r\n        if ( (addr=AirPDcapGetStaAddress((const AIRPDCAP_MAC_FRAME_ADDR4 *)(data))) != NULL) {\r\n            memcpy(id.sta, addr, AIRPDCAP_MAC_LEN);\r\n#ifdef AIRPDCAP_DEBUG\r\n            g_snprintf(msgbuf, MSGBUF_LEN, \"ST_MAC: %2X.%2X.%2X.%2X.%2X.%2X\\t\", id.sta[0],id.sta[1],id.sta[2],id.sta[3],id.sta[4],id.sta[5]);\r\n#endif\r\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", msgbuf, AIRPDCAP_DEBUG_LEVEL_3);\r\n        } else {\r\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"SA not found\", AIRPDCAP_DEBUG_LEVEL_5);\r\n            return AIRPDCAP_RET_REQ_DATA;\r\n        }\r\n\r\n        sta_sa = AirPDcapGetSaPtr(ctx, &id);\r\n        if (sta_sa == NULL){\r\n            return AIRPDCAP_RET_REQ_DATA;\r\n        }\r\n\r\n        /* Try to extract the group key and install it in the SA */\r\n        return (AirPDcapDecryptWPABroadcastKey(pEAPKey, sta_sa->wpa.ptk+16, sa, tot_len-offset+1));\r\n\r\n    } else if (memcmp(data+offset, tdls_header, 10) == 0) {\r\n        const guint8 *initiator, *responder;\r\n        guint8 action;\r\n        guint status, offset_rsne = 0, offset_fte = 0, offset_link = 0, offset_timeout = 0;\r\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Authentication: TDLS Action Frame\", AIRPDCAP_DEBUG_LEVEL_3);\r\n\r\n        /* skip LLC header */\r\n        offset+=10;\r\n\r\n        /* check if the packet is a TDLS response or confirm */\r\n        action = data[offset];\r\n        if (action!=1 && action!=2) {\r\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Not Response nor confirm\", AIRPDCAP_DEBUG_LEVEL_3);\r\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\r\n        }\r\n\r\n        /* check status */\r\n        offset++;\r\n        status=pntoh16(data+offset);\r\n        if (status!=0) {\r\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"TDLS setup not successfull\", AIRPDCAP_DEBUG_LEVEL_3);\r\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\r\n        }\r\n\r\n        /* skip Token + capabilities */\r\n        offset+=5;\r\n\r\n        /* search for RSN, Fast BSS Transition, Link Identifier and Timeout Interval IEs */\r\n\r\n        while(offset < (tot_len - 2)) {\r\n            if (data[offset] == 48) {\r\n                offset_rsne = offset;\r\n            } else if (data[offset] == 55) {\r\n                offset_fte = offset;\r\n            } else if (data[offset] == 56) {\r\n                offset_timeout = offset;\r\n            } else if (data[offset] == 101) {\r\n                offset_link = offset;\r\n            }\r\n\r\n            if (tot_len < offset + data[offset + 1] + 2) {\r\n                return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\r\n            }\r\n            offset += data[offset + 1] + 2;\r\n        }\r\n\r\n        if (offset_rsne == 0 || offset_fte == 0 ||\r\n            offset_timeout == 0 || offset_link == 0)\r\n        {\r\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Cannot Find all necessary IEs\", AIRPDCAP_DEBUG_LEVEL_3);\r\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\r\n        }\r\n\r\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Found RSNE/Fast BSS/Timeout Interval/Link IEs\", AIRPDCAP_DEBUG_LEVEL_3);\r\n\r\n        /* Will create a Security Association between 2 STA. Need to get both MAC address */\r\n        initiator = &data[offset_link + 8];\r\n        responder = &data[offset_link + 14];\r\n\r\n        if (memcmp(initiator, responder, AIRPDCAP_MAC_LEN) < 0) {\r\n            memcpy(id.sta, initiator, AIRPDCAP_MAC_LEN);\r\n            memcpy(id.bssid, responder, AIRPDCAP_MAC_LEN);\r\n        } else {\r\n            memcpy(id.sta, responder, AIRPDCAP_MAC_LEN);\r\n            memcpy(id.bssid, initiator, AIRPDCAP_MAC_LEN);\r\n        }\r\n\r\n        sa = AirPDcapGetSaPtr(ctx, &id);\r\n        if (sa == NULL){\r\n            return AIRPDCAP_RET_REQ_DATA;\r\n        }\r\n\r\n        if (sa->validKey) {\r\n            if (memcmp(sa->wpa.nonce, data + offset_fte + 52, AIRPDCAP_WPA_NONCE_LEN) == 0) {\r\n                /* Already have valid key for this SA, no need to redo key derivation */\r\n                return AIRPDCAP_RET_SUCCESS_HANDSHAKE;\r\n            } else {\r\n                /* We are opening a new session with the same two STA, save previous sa  */\r\n                AIRPDCAP_SEC_ASSOCIATION *tmp_sa = g_new(AIRPDCAP_SEC_ASSOCIATION, 1);\r\n                memcpy(tmp_sa, sa, sizeof(AIRPDCAP_SEC_ASSOCIATION));\r\n                sa->next=tmp_sa;\r\n                sa->validKey = FALSE;\r\n            }\r\n        }\r\n\r\n        if (AirPDcapTDLSDeriveKey(sa, data, offset_rsne, offset_fte, offset_timeout, offset_link, action)\r\n            == AIRPDCAP_RET_SUCCESS) {\r\n            AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapScanForKeys\");\r\n            return AIRPDCAP_RET_SUCCESS_HANDSHAKE;\r\n        }\r\n    } else {\r\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Skipping: not an EAPOL packet\", AIRPDCAP_DEBUG_LEVEL_3);\r\n    }\r\n\r\n    AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapScanForKeys\");\r\n    return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\r\n}", ".irPDcapRsna4WHandshake": "static INT\r\nAirPDcapRsna4WHandshake(\r\n    PAIRPDCAP_CONTEXT ctx,\r\n    const UCHAR *data,\r\n    AIRPDCAP_SEC_ASSOCIATION *sa,\r\n    INT offset,\r\n    const guint tot_len)\r\n{\r\n    AIRPDCAP_KEY_ITEM *tmp_key, *tmp_pkt_key, pkt_key;\r\n    AIRPDCAP_SEC_ASSOCIATION *tmp_sa;\r\n    INT key_index;\r\n    INT ret_value=1;\r\n    UCHAR useCache=FALSE;\r\n    UCHAR eapol[AIRPDCAP_EAPOL_MAX_LEN];\r\n    USHORT eapol_len;\r\n\r\n    if (sa->key!=NULL)\r\n        useCache=TRUE;\r\n\r\n    /* a 4-way handshake packet use a Pairwise key type (IEEE 802.11i-2004, pg. 79) */\r\n    if (AIRPDCAP_EAP_KEY(data[offset+1])!=1) {\r\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsna4WHandshake\", \"Group/STAKey message (not used)\", AIRPDCAP_DEBUG_LEVEL_5);\r\n        return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\r\n    }\r\n\r\n    /* TODO timeouts? */\r\n\r\n    /* TODO consider key-index */\r\n\r\n    /* TODO considera Deauthentications */\r\n\r\n    AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsna4WHandshake\", \"4-way handshake...\", AIRPDCAP_DEBUG_LEVEL_5);\r\n\r\n    /* manage 4-way handshake packets; this step completes the 802.1X authentication process (IEEE 802.11i-2004, pag. 85) */\r\n\r\n    /* message 1: Authenticator->Supplicant (Sec=0, Mic=0, Ack=1, Inst=0, Key=1(pairwise), KeyRSC=0, Nonce=ANonce, MIC=0) */\r\n    if (AIRPDCAP_EAP_INST(data[offset+1])==0 &&\r\n        AIRPDCAP_EAP_ACK(data[offset+1])==1 &&\r\n        AIRPDCAP_EAP_MIC(data[offset])==0)\r\n    {\r\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsna4WHandshake\", \"4-way handshake message 1\", AIRPDCAP_DEBUG_LEVEL_3);\r\n\r\n        /* On reception of Message 1, the Supplicant determines whether the Key Replay Counter field value has been        */\r\n        /* used before with the current PMKSA. If the Key Replay Counter field value is less than or equal to the current  */\r\n        /* local value, the Supplicant discards the message.                                                               */\r\n        /* -> not checked, the Authenticator will be send another Message 1 (hopefully!)                                   */\r\n\r\n        /* This saves the sa since we are reauthenticating which will overwrite our current sa GCS*/\r\n        if( sa->handshake >= 2) {\r\n            tmp_sa= g_new(AIRPDCAP_SEC_ASSOCIATION, 1);\r\n            memcpy(tmp_sa, sa, sizeof(AIRPDCAP_SEC_ASSOCIATION));\r\n            sa->validKey=FALSE;\r\n            sa->next=tmp_sa;\r\n        }\r\n\r\n        /* save ANonce (from authenticator) to derive the PTK with the SNonce (from the 2 message) */\r\n        memcpy(sa->wpa.nonce, data+offset+12, 32);\r\n\r\n        /* get the Key Descriptor Version (to select algorithm used in decryption -CCMP or TKIP-) */\r\n        sa->wpa.key_ver=AIRPDCAP_EAP_KEY_DESCR_VER(data[offset+1]);\r\n\r\n        sa->handshake=1;\r\n\r\n        return AIRPDCAP_RET_SUCCESS_HANDSHAKE;\r\n    }\r\n\r\n    /* message 2|4: Supplicant->Authenticator (Sec=0|1, Mic=1, Ack=0, Inst=0, Key=1(pairwise), KeyRSC=0, Nonce=SNonce|0, MIC=MIC(KCK,EAPOL)) */\r\n    if (AIRPDCAP_EAP_INST(data[offset+1])==0 &&\r\n        AIRPDCAP_EAP_ACK(data[offset+1])==0 &&\r\n        AIRPDCAP_EAP_MIC(data[offset])==1)\r\n    {\r\n        /* Check key data length to differentiate between message 2 or 4, same as in epan/dissectors/packet-ieee80211.c */\r\n        if (pntoh16(data+offset+92)) {\r\n            /* message 2 */\r\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsna4WHandshake\", \"4-way handshake message 2\", AIRPDCAP_DEBUG_LEVEL_3);\r\n\r\n            /* On reception of Message 2, the Authenticator checks that the key replay counter corresponds to the */\r\n            /* outstanding Message 1. If not, it silently discards the message.                                   */\r\n            /* If the calculated MIC does not match the MIC that the Supplicant included in the EAPOL-Key frame,  */\r\n            /* the Authenticator silently discards Message 2.                                                     */\r\n            /* -> not checked; the Supplicant will send another message 2 (hopefully!)                            */\r\n\r\n            /* now you can derive the PTK */\r\n            for (key_index=0; key_index<(INT)ctx->keys_nr || useCache; key_index++) {\r\n                /* use the cached one, or try all keys */\r\n                if (!useCache) {\r\n                    AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsna4WHandshake\", \"Try WPA key...\", AIRPDCAP_DEBUG_LEVEL_3);\r\n                    tmp_key=&ctx->keys[key_index];\r\n                } else {\r\n                    /* there is a cached key in the security association, if it's a WPA key try it... */\r\n                    if (sa->key!=NULL &&\r\n                        (sa->key->KeyType==AIRPDCAP_KEY_TYPE_WPA_PWD ||\r\n                         sa->key->KeyType==AIRPDCAP_KEY_TYPE_WPA_PSK ||\r\n                         sa->key->KeyType==AIRPDCAP_KEY_TYPE_WPA_PMK)) {\r\n                            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsna4WHandshake\", \"Try cached WPA key...\", AIRPDCAP_DEBUG_LEVEL_3);\r\n                            tmp_key=sa->key;\r\n                    } else {\r\n                        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsna4WHandshake\", \"Cached key is of a wrong type, try WPA key...\", AIRPDCAP_DEBUG_LEVEL_3);\r\n                        tmp_key=&ctx->keys[key_index];\r\n                    }\r\n                }\r\n\r\n                /* obviously, try only WPA keys... */\r\n                if (tmp_key->KeyType==AIRPDCAP_KEY_TYPE_WPA_PWD ||\r\n                    tmp_key->KeyType==AIRPDCAP_KEY_TYPE_WPA_PSK ||\r\n                    tmp_key->KeyType==AIRPDCAP_KEY_TYPE_WPA_PMK)\r\n                {\r\n                    if (tmp_key->KeyType == AIRPDCAP_KEY_TYPE_WPA_PWD && tmp_key->UserPwd.SsidLen == 0 && ctx->pkt_ssid_len > 0 && ctx->pkt_ssid_len <= AIRPDCAP_WPA_SSID_MAX_LEN) {\r\n                        /* We have a \"wildcard\" SSID.  Use the one from the packet. */\r\n                        memcpy(&pkt_key, tmp_key, sizeof(pkt_key));\r\n                        memcpy(&pkt_key.UserPwd.Ssid, ctx->pkt_ssid, ctx->pkt_ssid_len);\r\n                         pkt_key.UserPwd.SsidLen = ctx->pkt_ssid_len;\r\n                        AirPDcapRsnaPwd2Psk(pkt_key.UserPwd.Passphrase, pkt_key.UserPwd.Ssid,\r\n                            pkt_key.UserPwd.SsidLen, pkt_key.KeyData.Wpa.Psk);\r\n                        tmp_pkt_key = &pkt_key;\r\n                    } else {\r\n                        tmp_pkt_key = tmp_key;\r\n                    }\r\n\r\n                    /* derive the PTK from the BSSID, STA MAC, PMK, SNonce, ANonce */\r\n                    AirPDcapRsnaPrfX(sa,                            /* authenticator nonce, bssid, station mac */\r\n                                     tmp_pkt_key->KeyData.Wpa.Psk,      /* PSK == PMK */\r\n                                     data+offset+12,                /* supplicant nonce */\r\n                                     512,\r\n                                     sa->wpa.ptk);\r\n\r\n                    /* verify the MIC (compare the MIC in the packet included in this message with a MIC calculated with the PTK) */\r\n                    eapol_len=pntoh16(data+offset-3)+4;\r\n                    memcpy(eapol, &data[offset-5], (eapol_len<AIRPDCAP_EAPOL_MAX_LEN?eapol_len:AIRPDCAP_EAPOL_MAX_LEN));\r\n                    ret_value=AirPDcapRsnaMicCheck(eapol,           /*      eapol frame (header also) */\r\n                                                   eapol_len,       /*      eapol frame length        */\r\n                                                   sa->wpa.ptk,     /*      Key Confirmation Key      */\r\n                                                   AIRPDCAP_EAP_KEY_DESCR_VER(data[offset+1])); /*  EAPOL-Key description version */\r\n\r\n                    /* If the MIC is valid, the Authenticator checks that the RSN information element bit-wise matches       */\r\n                    /* that from the (Re)Association Request message.                                                        */\r\n                    /*              i) TODO If these are not exactly the same, the Authenticator uses MLME-DEAUTHENTICATE.request */\r\n                    /* primitive to terminate the association.                                                               */\r\n                    /*              ii) If they do match bit-wise, the Authenticator constructs Message 3.                   */\r\n                }\r\n\r\n                if (!ret_value &&\r\n                    (tmp_key->KeyType==AIRPDCAP_KEY_TYPE_WPA_PWD ||\r\n                    tmp_key->KeyType==AIRPDCAP_KEY_TYPE_WPA_PSK ||\r\n                    tmp_key->KeyType==AIRPDCAP_KEY_TYPE_WPA_PMK))\r\n                {\r\n                    /* the temporary key is the correct one, cached in the Security Association */\r\n\r\n                    sa->key=tmp_key;\r\n                    break;\r\n                } else {\r\n                    /* the cached key was not valid, try other keys */\r\n\r\n                    if (useCache==TRUE) {\r\n                        useCache=FALSE;\r\n                        key_index--;\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (ret_value) {\r\n                AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsna4WHandshake\", \"handshake step failed\", AIRPDCAP_DEBUG_LEVEL_3);\r\n                return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\r\n            }\r\n\r\n            sa->handshake=2;\r\n            sa->validKey=TRUE; /* we can use the key to decode, even if we have not captured the other eapol packets */\r\n\r\n            return AIRPDCAP_RET_SUCCESS_HANDSHAKE;\r\n        } else {\r\n        /* message 4 */\r\n\r\n            /* TODO \"Note that when the 4-Way Handshake is first used Message 4 is sent in the clear.\" */\r\n\r\n            /* TODO check MIC and Replay Counter                                                                     */\r\n            /* On reception of Message 4, the Authenticator verifies that the Key Replay Counter field value is one  */\r\n            /* that it used on this 4-Way Handshake; if it is not, it silently discards the message.                 */\r\n            /* If the calculated MIC does not match the MIC that the Supplicant included in the EAPOL-Key frame, the */\r\n            /* Authenticator silently discards Message 4.                                                            */\r\n\r\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsna4WHandshake\", \"4-way handshake message 4\", AIRPDCAP_DEBUG_LEVEL_3);\r\n\r\n            sa->handshake=4;\r\n\r\n            return AIRPDCAP_RET_SUCCESS_HANDSHAKE;\r\n        }\r\n    }\r\n\r\n    /* message 3: Authenticator->Supplicant (Sec=1, Mic=1, Ack=1, Inst=0/1, Key=1(pairwise), KeyRSC=???, Nonce=ANonce, MIC=1) */\r\n    if (AIRPDCAP_EAP_ACK(data[offset+1])==1 &&\r\n        AIRPDCAP_EAP_MIC(data[offset])==1)\r\n    {\r\n        const EAPOL_RSN_KEY *pEAPKey;\r\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsna4WHandshake\", \"4-way handshake message 3\", AIRPDCAP_DEBUG_LEVEL_3);\r\n\r\n        /* On reception of Message 3, the Supplicant silently discards the message if the Key Replay Counter field     */\r\n        /* value has already been used or if the ANonce value in Message 3 differs from the ANonce value in Message 1. */\r\n        /* -> not checked, the Authenticator will send another message 3 (hopefully!)                                  */\r\n\r\n        /* TODO check page 88 (RNS) */\r\n\r\n        /* If using WPA2 PSK, message 3 will contain an RSN for the group key (GTK KDE).\r\n           In order to properly support decrypting WPA2-PSK packets, we need to parse this to get the group key. */\r\n        pEAPKey = (const EAPOL_RSN_KEY *)(&(data[offset-1]));\r\n        if (pEAPKey->type == AIRPDCAP_RSN_WPA2_KEY_DESCRIPTOR){\r\n            PAIRPDCAP_SEC_ASSOCIATION broadcast_sa;\r\n            AIRPDCAP_SEC_ASSOCIATION_ID id;\r\n\r\n            /* Get broadcacst SA for the current BSSID */\r\n            memcpy(id.sta, broadcast_mac, AIRPDCAP_MAC_LEN);\r\n            memcpy(id.bssid, sa->saId.bssid, AIRPDCAP_MAC_LEN);\r\n            broadcast_sa = AirPDcapGetSaPtr(ctx, &id);\r\n\r\n            if (broadcast_sa == NULL){\r\n                return AIRPDCAP_RET_REQ_DATA;\r\n            }\r\n            return (AirPDcapDecryptWPABroadcastKey(pEAPKey, sa->wpa.ptk+16, broadcast_sa, tot_len-offset+1));\r\n        }\r\n    }\r\n\r\n    return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\r\n}", ".irPDcapPacketProcess": "INT AirPDcapPacketProcess(\r\n    PAIRPDCAP_CONTEXT ctx,\r\n    const guint8 *data,\r\n    const guint mac_header_len,\r\n    const guint tot_len,\r\n    UCHAR *decrypt_data,\r\n    guint *decrypt_len,\r\n    PAIRPDCAP_KEY_ITEM key,\r\n    gboolean scanHandshake)\r\n{\r\n    AIRPDCAP_SEC_ASSOCIATION_ID id;\r\n    UCHAR tmp_data[AIRPDCAP_MAX_CAPLEN];\r\n    guint tmp_len;\r\n\r\n#ifdef AIRPDCAP_DEBUG\r\n#define MSGBUF_LEN 255\r\n    CHAR msgbuf[MSGBUF_LEN];\r\n#endif\r\n\r\n    AIRPDCAP_DEBUG_TRACE_START(\"AirPDcapPacketProcess\");\r\n\r\n    if (ctx==NULL) {\r\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapPacketProcess\", \"NULL context\", AIRPDCAP_DEBUG_LEVEL_5);\r\n        AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapPacketProcess\");\r\n        return AIRPDCAP_RET_REQ_DATA;\r\n    }\r\n    if (data==NULL || tot_len==0) {\r\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapPacketProcess\", \"NULL data or length=0\", AIRPDCAP_DEBUG_LEVEL_5);\r\n        AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapPacketProcess\");\r\n        return AIRPDCAP_RET_REQ_DATA;\r\n    }\r\n\r\n    /* check if the packet is of data or robust managment type */\r\n    if (!((AIRPDCAP_TYPE(data[0])==AIRPDCAP_TYPE_DATA) ||\r\n          (AIRPDCAP_TYPE(data[0])==AIRPDCAP_TYPE_MANAGEMENT &&\r\n           (AIRPDCAP_SUBTYPE(data[0])==AIRPDCAP_SUBTYPE_DISASS ||\r\n            AIRPDCAP_SUBTYPE(data[0])==AIRPDCAP_SUBTYPE_DEAUTHENTICATION ||\r\n            AIRPDCAP_SUBTYPE(data[0])==AIRPDCAP_SUBTYPE_ACTION)))) {\r\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapPacketProcess\", \"not data nor robust mgmt packet\", AIRPDCAP_DEBUG_LEVEL_5);\r\n        return AIRPDCAP_RET_NO_DATA;\r\n    }\r\n\r\n    /* check correct packet size, to avoid wrong elaboration of encryption algorithms */\r\n    if (tot_len < (UINT)(mac_header_len+AIRPDCAP_CRYPTED_DATA_MINLEN)) {\r\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapPacketProcess\", \"minimum length violated\", AIRPDCAP_DEBUG_LEVEL_5);\r\n        return AIRPDCAP_RET_WRONG_DATA_SIZE;\r\n    }\r\n\r\n    /* Assume that the decrypt_data field is at least this size. */\r\n    if (tot_len > AIRPDCAP_MAX_CAPLEN) {\r\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapPacketProcess\", \"length too large\", AIRPDCAP_DEBUG_LEVEL_3);\r\n        return AIRPDCAP_RET_UNSUCCESS;\r\n    }\r\n\r\n    /* get STA/BSSID address */\r\n    if (AirPDcapGetSaAddress((const AIRPDCAP_MAC_FRAME_ADDR4 *)(data), &id) != AIRPDCAP_RET_SUCCESS) {\r\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapPacketProcess\", \"STA/BSSID not found\", AIRPDCAP_DEBUG_LEVEL_5);\r\n        return AIRPDCAP_RET_REQ_DATA;\r\n    }\r\n\r\n    /* check if data is encrypted (use the WEP bit in the Frame Control field) */\r\n    if (AIRPDCAP_WEP(data[1])==0) {\r\n        if (scanHandshake) {\r\n            /* data is sent in cleartext, check if is an authentication message or end the process */\r\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapPacketProcess\", \"Unencrypted data\", AIRPDCAP_DEBUG_LEVEL_3);\r\n            return (AirPDcapScanForKeys(ctx, data, mac_header_len, tot_len, id));\r\n        }\r\n        return AIRPDCAP_RET_NO_DATA_ENCRYPTED;\r\n    } else {\r\n        PAIRPDCAP_SEC_ASSOCIATION sa;\r\n        int offset = 0;\r\n\r\n        /* get the Security Association structure for the STA and AP */\r\n        sa = AirPDcapGetSaPtr(ctx, &id);\r\n        if (sa == NULL){\r\n            return AIRPDCAP_RET_REQ_DATA;\r\n        }\r\n\r\n        /* cache offset in the packet data (to scan encryption data) */\r\n        offset = mac_header_len;\r\n\r\n        if (decrypt_data==NULL) {\r\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapPacketProcess\", \"no decrypt buffer, use local\", AIRPDCAP_DEBUG_LEVEL_3);\r\n            decrypt_data=tmp_data;\r\n            decrypt_len=&tmp_len;\r\n        }\r\n\r\n        /* create new header and data to modify */\r\n        *decrypt_len = tot_len;\r\n        memcpy(decrypt_data, data, *decrypt_len);\r\n\r\n        /* encrypted data */\r\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapPacketProcess\", \"Encrypted data\", AIRPDCAP_DEBUG_LEVEL_3);\r\n\r\n        /* check the Extension IV to distinguish between WEP encryption and WPA encryption */\r\n        /* refer to IEEE 802.11i-2004, 8.2.1.2, pag.35 for WEP,    */\r\n        /*          IEEE 802.11i-2004, 8.3.2.2, pag. 45 for TKIP,  */\r\n        /*          IEEE 802.11i-2004, 8.3.3.2, pag. 57 for CCMP   */\r\n        if (AIRPDCAP_EXTIV(data[offset+3])==0) {\r\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapPacketProcess\", \"WEP encryption\", AIRPDCAP_DEBUG_LEVEL_3);\r\n            return AirPDcapWepMng(ctx, decrypt_data, mac_header_len, decrypt_len, key, sa, offset);\r\n        } else {\r\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapPacketProcess\", \"TKIP or CCMP encryption\", AIRPDCAP_DEBUG_LEVEL_3);\r\n\r\n            /* If index >= 1, then use the group key.  This will not work if the AP is using\r\n               more than one group key simultaneously.  I've not seen this in practice, however.\r\n               Usually an AP will rotate between the two key index values of 1 and 2 whenever\r\n               it needs to change the group key to be used. */\r\n            if (AIRPDCAP_KEY_INDEX(data[offset+3])>=1){\r\n\r\n                AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapPacketProcess\", \"The key index >= 1. This is encrypted with a group key.\", AIRPDCAP_DEBUG_LEVEL_3);\r\n\r\n                /* force STA address to broadcast MAC so we load the SA for the groupkey */\r\n                memcpy(id.sta, broadcast_mac, AIRPDCAP_MAC_LEN);\r\n\r\n#ifdef AIRPDCAP_DEBUG\r\n                g_snprintf(msgbuf, MSGBUF_LEN, \"ST_MAC: %2X.%2X.%2X.%2X.%2X.%2X\\t\", id.sta[0],id.sta[1],id.sta[2],id.sta[3],id.sta[4],id.sta[5]);\r\n                AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapPacketProcess\", msgbuf, AIRPDCAP_DEBUG_LEVEL_3);\r\n#endif\r\n\r\n                /* search for a cached Security Association for current BSSID and broadcast MAC */\r\n                sa = AirPDcapGetSaPtr(ctx, &id);\r\n                if (sa == NULL)\r\n                    return AIRPDCAP_RET_REQ_DATA;\r\n            }\r\n\r\n            /* Decrypt the packet using the appropriate SA */\r\n            if (AirPDcapRsnaMng(decrypt_data, mac_header_len, decrypt_len, key, sa, offset) == AIRPDCAP_RET_SUCCESS) {\r\n                /* If we successfully decrypted a packet, scan it to see if it contains a key handshake.\r\n                   The group key handshake could be sent at any time the AP wants to change the key (such as when\r\n                   it is using key rotation) and it also could be a rekey for the Pairwise key. So we must scan every packet. */\r\n                if (scanHandshake) {\r\n                    return (AirPDcapScanForKeys(ctx, decrypt_data, mac_header_len, *decrypt_len, id));\r\n                } else {\r\n                    return AIRPDCAP_RET_SUCCESS;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return AIRPDCAP_RET_UNSUCCESS;\r\n}", ".irPDcapInitContext": "INT AirPDcapInitContext(\r\n    PAIRPDCAP_CONTEXT ctx)\r\n{\r\n    AIRPDCAP_DEBUG_TRACE_START(\"AirPDcapInitContext\");\r\n\r\n    if (ctx==NULL) {\r\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapInitContext\", \"NULL context\", AIRPDCAP_DEBUG_LEVEL_5);\r\n        AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapInitContext\");\r\n        return AIRPDCAP_RET_UNSUCCESS;\r\n    }\r\n\r\n    AirPDcapCleanKeys(ctx);\r\n\r\n    ctx->first_free_index=0;\r\n    ctx->index=-1;\r\n    ctx->sa_index=-1;\r\n    ctx->pkt_ssid_len = 0;\r\n\r\n    memset(ctx->sa, 0, AIRPDCAP_MAX_SEC_ASSOCIATIONS_NR * sizeof(AIRPDCAP_SEC_ASSOCIATION));\r\n\r\n    AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapInitContext\", \"Context initialized!\", AIRPDCAP_DEBUG_LEVEL_5);\r\n    AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapInitContext\");\r\n    return AIRPDCAP_RET_SUCCESS;\r\n}", ".irPDcapDestroyContext": "INT AirPDcapDestroyContext(\r\n    PAIRPDCAP_CONTEXT ctx)\r\n{\r\n    AIRPDCAP_DEBUG_TRACE_START(\"AirPDcapDestroyContext\");\r\n\r\n    if (ctx==NULL) {\r\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapDestroyContext\", \"NULL context\", AIRPDCAP_DEBUG_LEVEL_5);\r\n        AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapDestroyContext\");\r\n        return AIRPDCAP_RET_UNSUCCESS;\r\n    }\r\n\r\n    AirPDcapCleanKeys(ctx);\r\n    AirPDcapCleanSecAssoc(ctx);\r\n\r\n    ctx->first_free_index=0;\r\n    ctx->index=-1;\r\n    ctx->sa_index=-1;\r\n\r\n    AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapDestroyContext\", \"Context destroyed!\", AIRPDCAP_DEBUG_LEVEL_5);\r\n    AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapDestroyContext\");\r\n    return AIRPDCAP_RET_SUCCESS;\r\n}", ".irPDcapCleanSecAssoc": "static void\r\nAirPDcapCleanSecAssoc(\r\n    PAIRPDCAP_CONTEXT ctx)\r\n{\r\n    PAIRPDCAP_SEC_ASSOCIATION psa;\r\n    int i;\r\n\r\n    for (psa = ctx->sa, i = 0; i < AIRPDCAP_MAX_SEC_ASSOCIATIONS_NR; i++, psa++) {\r\n        /* To iterate is human, to recurse, divine */\r\n        AirPDcapRecurseCleanSA(psa);\r\n    }\r\n}", ".irPDcapSetKeys": "INT AirPDcapSetKeys(\r\n    PAIRPDCAP_CONTEXT ctx,\r\n    AIRPDCAP_KEY_ITEM keys[],\r\n    const size_t keys_nr)\r\n{\r\n    INT i;\r\n    INT success;\r\n    AIRPDCAP_DEBUG_TRACE_START(\"AirPDcapSetKeys\");\r\n\r\n    if (ctx==NULL || keys==NULL) {\r\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapSetKeys\", \"NULL context or NULL keys array\", AIRPDCAP_DEBUG_LEVEL_3);\r\n        AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapSetKeys\");\r\n        return 0;\r\n    }\r\n\r\n    if (keys_nr>AIRPDCAP_MAX_KEYS_NR) {\r\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapSetKeys\", \"Keys number greater than maximum\", AIRPDCAP_DEBUG_LEVEL_3);\r\n        AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapSetKeys\");\r\n        return 0;\r\n    }\r\n\r\n    /* clean key and SA collections before setting new ones */\r\n    AirPDcapInitContext(ctx);\r\n\r\n    /* check and insert keys */\r\n    for (i=0, success=0; i<(INT)keys_nr; i++) {\r\n        if (AirPDcapValidateKey(keys+i)==TRUE) {\r\n            if (keys[i].KeyType==AIRPDCAP_KEY_TYPE_WPA_PWD) {\r\n                AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapSetKeys\", \"Set a WPA-PWD key\", AIRPDCAP_DEBUG_LEVEL_4);\r\n                AirPDcapRsnaPwd2Psk(keys[i].UserPwd.Passphrase, keys[i].UserPwd.Ssid, keys[i].UserPwd.SsidLen, keys[i].KeyData.Wpa.Psk);\r\n            }\r\n#ifdef AIRPDCAP_DEBUG\r\n            else if (keys[i].KeyType==AIRPDCAP_KEY_TYPE_WPA_PMK) {\r\n                AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapSetKeys\", \"Set a WPA-PMK key\", AIRPDCAP_DEBUG_LEVEL_4);\r\n            } else if (keys[i].KeyType==AIRPDCAP_KEY_TYPE_WEP) {\r\n                AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapSetKeys\", \"Set a WEP key\", AIRPDCAP_DEBUG_LEVEL_4);\r\n            } else {\r\n                AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapSetKeys\", \"Set a key\", AIRPDCAP_DEBUG_LEVEL_4);\r\n            }\r\n#endif\r\n            memcpy(&ctx->keys[success], &keys[i], sizeof(keys[i]));\r\n            success++;\r\n        }\r\n    }\r\n\r\n    ctx->keys_nr=success;\r\n\r\n    AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapSetKeys\");\r\n    return success;\r\n}", ".irPDcapGetSaPtr": "static PAIRPDCAP_SEC_ASSOCIATION\r\nAirPDcapGetSaPtr(\r\n    PAIRPDCAP_CONTEXT ctx,\r\n    AIRPDCAP_SEC_ASSOCIATION_ID *id)\r\n{\r\n    int sa_index;\r\n\r\n    /* search for a cached Security Association for supplied BSSID and STA MAC  */\r\n    if ((sa_index=AirPDcapGetSa(ctx, id))==-1) {\r\n        /* create a new Security Association if it doesn't currently exist      */\r\n        if ((sa_index=AirPDcapStoreSa(ctx, id))==-1) {\r\n            return NULL;\r\n        }\r\n    }\r\n    /* get the Security Association structure   */\r\n    return &ctx->sa[sa_index];\r\n}", ".irPDcapRsnaPwd2Psk": "static INT\r\nAirPDcapRsnaPwd2Psk(\r\n    const CHAR *passphrase,\r\n    const CHAR *ssid,\r\n    const size_t ssidLength,\r\n    UCHAR *output)\r\n{\r\n    UCHAR m_output[40] = { 0 };\r\n    GByteArray *pp_ba = g_byte_array_new();\r\n\r\n    if (!uri_str_to_bytes(passphrase, pp_ba)) {\r\n        g_byte_array_free(pp_ba, TRUE);\r\n        return 0;\r\n    }\r\n\r\n    AirPDcapRsnaPwd2PskStep(pp_ba->data, pp_ba->len, ssid, ssidLength, 4096, 1, m_output);\r\n    AirPDcapRsnaPwd2PskStep(pp_ba->data, pp_ba->len, ssid, ssidLength, 4096, 2, &m_output[20]);\r\n\r\n    memcpy(output, m_output, AIRPDCAP_WPA_PSK_LEN);\r\n    g_byte_array_free(pp_ba, TRUE);\r\n\r\n    return 0;\r\n}"}, "function_name": "AirPDcapTDLSDeriveKey"}
{"function_id": null, "caller": {".pv6_l3mdev_skb": "static inline bool ipv6_l3mdev_skb(__u16 flags)\r\n{\r\n\treturn flags & IP6SKB_L3SLAVE;\r\n}"}, "callee": {".net6_iif": "static inline int inet6_iif(const struct sk_buff *skb)\r\n{\r\n\tbool l3_slave = ipv6_l3mdev_skb(IP6CB(skb)->flags);\r\n\r\n\treturn l3_slave ? skb->skb_iif : IP6CB(skb)->iif;\r\n}", ".net6_sdif": "static inline int inet6_sdif(const struct sk_buff *skb)\r\n{\r\n#if IS_ENABLED(CONFIG_NET_L3_MASTER_DEV)\r\n\tif (skb && ipv6_l3mdev_skb(IP6CB(skb)->flags))\r\n\t\treturn IP6CB(skb)->iif;\r\n#endif\r\n\treturn 0;\r\n}"}, "function_name": "ipv6_mod_enabled"}
{"function_id": null, "caller": {".andle_packet": "static int handle_packet(unsigned char *data, int data_len) {\r\n\tstruct mt_mactelnet_hdr pkthdr;\r\n\r\n\t/* Minimal size checks (pings are not supported here) */\r\n\tif (data_len < MT_HEADER_LEN){\r\n\t\treturn -1;\r\n\t}\r\n\tparse_packet(data, &pkthdr);\r\n\r\n\t/* We only care about packets with correct sessionkey */\r\n\tif (pkthdr.seskey != sessionkey) {\r\n\t\treturn -1;\r\n\t}\r\n\r\n\t/* Handle data packets */\r\n\tif (pkthdr.ptype == MT_PTYPE_DATA) {\r\n\t\tstruct mt_packet odata;\r\n\t\tstruct mt_mactelnet_control_hdr cpkt;\r\n\t\tint success = 0;\r\n\r\n\t\t/* Always transmit ACKNOWLEDGE packets in response to DATA packets */\r\n\t\tinit_packet(&odata, MT_PTYPE_ACK, srcmac, dstmac, sessionkey, pkthdr.counter + (data_len - MT_HEADER_LEN));\r\n\t\tsend_udp(&odata, 0);\r\n\r\n\t\t/* Accept first packet, and all packets greater than incounter, and if counter has\r\n\t\twrapped around. */\r\n\t\tif (pkthdr.counter > incounter || (incounter - pkthdr.counter) > 65535) {\r\n\t\t\tincounter = pkthdr.counter;\r\n\t\t} else {\r\n\t\t\t/* Ignore double or old packets */\r\n\t\t\treturn -1;\r\n\t\t}\r\n\r\n\t\t/* Parse controlpacket data */\r\n\t\tsuccess = parse_control_packet(data + MT_HEADER_LEN, data_len - MT_HEADER_LEN, &cpkt);\r\n\r\n\t\twhile (success) {\r\n\r\n\t\t\t/* If we receive pass_salt, transmit auth data back */\r\n\t\t\tif (cpkt.cptype == MT_CPTYPE_PASSSALT) {\r\n\t\t\t\t/* check validity, server sends exactly 16 bytes */\r\n\t\t\t\tif (cpkt.length != 16) {\r\n\t\t\t\t\tfprintf(stderr, _(\"Invalid salt length: %d (instead of 16) received from server %s\\n\"), cpkt.length, ether_ntoa((struct ether_addr *)dstmac));\r\n\t\t\t\t}\r\n\t\t\t\tmemcpy(pass_salt, cpkt.data, 16);\r\n\t\t\t\tsend_auth(username, password);\r\n\t\t\t}\r\n\r\n\t\t\t/* If the (remaining) data did not have a control-packet magic byte sequence,\r\n\t\t\t   the data is raw terminal data to be outputted to the terminal. */\r\n\t\t\telse if (cpkt.cptype == MT_CPTYPE_PLAINDATA) {\r\n\t\t\t\tfwrite((const void *)cpkt.data, 1, cpkt.length, stdout);\r\n\t\t\t}\r\n\r\n\t\t\t/* END_AUTH means that the user/password negotiation is done, and after this point\r\n\t\t\t   terminal data may arrive, so we set up the terminal to raw mode. */\r\n\t\t\telse if (cpkt.cptype == MT_CPTYPE_END_AUTH) {\r\n\r\n\t\t\t\t/* we have entered \"terminal mode\" */\r\n\t\t\t\tterminal_mode = 1;\r\n\r\n\t\t\t\tif (is_a_tty) {\r\n\t\t\t\t\t/* stop input buffering at all levels. Give full control of terminal to RouterOS */\r\n\t\t\t\t\traw_term();\r\n\r\n\t\t\t\t\tsetvbuf(stdin,  (char*)NULL, _IONBF, 0);\r\n\r\n\t\t\t\t\t/* Add resize signal handler */\r\n\t\t\t\t\tsignal(SIGWINCH, sig_winch);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t/* Parse next controlpacket */\r\n\t\t\tsuccess = parse_control_packet(NULL, 0, &cpkt);\r\n\t\t}\r\n\t}\r\n\telse if (pkthdr.ptype == MT_PTYPE_ACK) {\r\n\t\t/* Handled elsewhere */\r\n\t}\r\n\r\n\t/* The server wants to terminate the connection, we have to oblige */\r\n\telse if (pkthdr.ptype == MT_PTYPE_END) {\r\n\t\tstruct mt_packet odata;\r\n\r\n\t\t/* Acknowledge the disconnection by sending a END packet in return */\r\n\t\tinit_packet(&odata, MT_PTYPE_END, srcmac, dstmac, pkthdr.seskey, 0);\r\n\t\tsend_udp(&odata, 0);\r\n\r\n\t\tif (!quiet_mode) {\r\n\t\t\tfprintf(stderr, _(\"Connection closed.\\n\"));\r\n\t\t}\r\n\r\n\t\t/* exit */\r\n\t\trunning = 0;\r\n\t} else {\r\n\t\tfprintf(stderr, _(\"Unhandeled packet type: %d received from server %s\\n\"), pkthdr.ptype, ether_ntoa((struct ether_addr *)dstmac));\r\n\t\treturn -1;\r\n\t}\r\n\r\n\treturn pkthdr.ptype;\r\n}", ".nit_packet": "int init_packet(struct mt_packet *packet, enum mt_ptype ptype, unsigned char *srcmac, unsigned char *dstmac, unsigned short sessionkey, unsigned int counter) {\r\n\tunsigned char *data = packet->data;\r\n\r\n\t/* Packet version */\r\n\tdata[0] = 1;\r\n\r\n\t/* Packet type */\r\n\tdata[1] = ptype;\r\n\r\n\t/* src ethernet address */\r\n\tmemcpy(data + 2, srcmac, ETH_ALEN);\r\n\r\n\t/* dst ethernet address */\r\n\tmemcpy(data + 8, dstmac, ETH_ALEN);\r\n\r\n\t/* Session key */\r\n\tsessionkey = htons(sessionkey);\r\n\tmemcpy(data + (mt_direction_fromserver ? 16 : 14), &sessionkey, sizeof(sessionkey));\r\n\r\n\t/* Client type: Mac Telnet */\r\n\tmemcpy(data + (mt_direction_fromserver ? 14 : 16), &mt_mactelnet_clienttype, sizeof(mt_mactelnet_clienttype));\r\n\r\n\t/* Received/sent data counter */\r\n\tcounter = htonl(counter);\r\n\tmemcpy(data + 18, &counter, sizeof(counter));\r\n\r\n\t/* 22 bytes header */\r\n\tpacket->size = 22;\r\n\treturn 22;\r\n}", ".dd_control_packet": "int add_control_packet(struct mt_packet *packet, enum mt_cptype cptype, void *cpdata, unsigned short data_len) {\r\n\tunsigned char *data = packet->data + packet->size;\r\n\tunsigned int act_size = data_len + (cptype == MT_CPTYPE_PLAINDATA ? 0 : MT_CPHEADER_LEN);\r\n\r\n\t/* Something is really wrong. Packets should never become over 1500 bytes,\r\n       perform an Integer-Overflow safe check */\r\n\tif (act_size > MT_PACKET_LEN - packet->size) {\r\n\t\tfprintf(stderr, _(\"add_control_packet: ERROR, too large packet. Exceeds %d bytes\\n\"), MT_PACKET_LEN);\r\n\t\treturn -1;\r\n\t\t//exit(1);\r\n\t}\r\n\r\n\t/* PLAINDATA isn't really a controlpacket, but we handle it here, since\r\n\t   parseControlPacket also parses raw data as PLAINDATA */\r\n\tif (cptype == MT_CPTYPE_PLAINDATA) {\r\n\t\tmemcpy(data, cpdata, data_len);\r\n\t\tpacket->size += data_len;\r\n\t\treturn data_len;\r\n\t}\r\n\r\n\t/* Control Packet Magic id */\r\n\tmemcpy(data, mt_mactelnet_cpmagic, sizeof(mt_mactelnet_cpmagic));\r\n\r\n\t/* Control packet type */\r\n\tdata[4] = cptype;\r\n\r\n\t/* Data length */\r\n#if BYTE_ORDER == LITTLE_ENDIAN\r\n\t{\r\n\t\tunsigned int templen;\r\n\t\ttemplen = htonl(data_len);\r\n\t\tmemcpy(data + 5, &templen, sizeof(templen));\r\n\t}\r\n#else\r\n\tmemcpy(data + 5, &data_len, sizeof(data_len));\r\n#endif\r\n\r\n\t/* Insert data */\r\n\tif (data_len > 0) {\r\n\t\tmemcpy(data + MT_CPHEADER_LEN, cpdata, data_len);\r\n\t}\r\n\r\n\tpacket->size += act_size;\r\n\t/* Control packet header length + data length */\r\n\treturn act_size;\r\n}", ".end_udp": "static int send_udp(struct mt_packet *packet, int retransmit) {\r\n\tint sent_bytes;\r\n\r\n\t/* Clear keepalive counter */\r\n\tkeepalive_counter = 0;\r\n\r\n\tif (!use_raw_socket) {\r\n\t\t/* Init SendTo struct */\r\n\t\tstruct sockaddr_in socket_address;\r\n\t\tsocket_address.sin_family = AF_INET;\r\n\t\tsocket_address.sin_port = htons(MT_MACTELNET_PORT);\r\n\t\tsocket_address.sin_addr.s_addr = htonl(INADDR_BROADCAST);\r\n\r\n\t\tsent_bytes = sendto(send_socket, packet->data, packet->size, 0, (struct sockaddr*)&socket_address, sizeof(socket_address));\r\n\t} else {\r\n\t\tsent_bytes = net_send_udp(sockfd, active_interface, srcmac, dstmac, &sourceip,  sourceport, &destip, MT_MACTELNET_PORT, packet->data, packet->size);\r\n\t}\r\n\r\n\t/* \r\n\t * Retransmit packet if no data is received within\r\n\t * retransmit_intervals milliseconds.\r\n\t */\r\n\tif (retransmit) {\r\n\t\tint i;\r\n\r\n\t\tfor (i = 0; i < MAX_RETRANSMIT_INTERVALS; ++i) {\r\n\t\t\tfd_set read_fds;\r\n\t\t\tint reads;\r\n\t\t\tstruct timeval timeout;\r\n\t\t\tint interval = retransmit_intervals[i] * 1000;\r\n\r\n\t\t\t/* Init select */\r\n\t\t\tFD_ZERO(&read_fds);\r\n\t\t\tFD_SET(insockfd, &read_fds);\r\n\t\t\ttimeout.tv_sec = 0;\r\n\t\t\ttimeout.tv_usec = interval;\r\n\r\n\t\t\t/* Wait for data or timeout */\r\n\t\t\treads = select(insockfd + 1, &read_fds, NULL, NULL, &timeout);\r\n\t\t\tif (reads && FD_ISSET(insockfd, &read_fds)) {\r\n\t\t\t\tunsigned char buff[MT_PACKET_LEN];\r\n\t\t\t\tint result;\r\n\r\n\t\t\t\tbzero(buff, sizeof(buff));\r\n\t\t\t\tresult = recvfrom(insockfd, buff, sizeof(buff), 0, 0, 0);\r\n\r\n\t\t\t\t/* Handle incoming packets, waiting for an ack */\r\n\t\t\t\tif (result > 0 && handle_packet(buff, result) == MT_PTYPE_ACK) {\r\n\t\t\t\t\treturn sent_bytes;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t/* Retransmit */\r\n\t\t\tsend_udp(packet, 0);\r\n\t\t}\r\n\r\n\t\tif (is_a_tty && terminal_mode) {\r\n\t\t\treset_term();\r\n\t\t}\r\n\r\n\t\tfprintf(stderr, _(\"\\nConnection timed out\\n\"));\r\n\t\texit(1);\r\n\t}\r\n\treturn sent_bytes;\r\n}", ".arse_packet": "void parse_packet(unsigned char *data, struct mt_mactelnet_hdr *pkthdr) {\r\n\t/* Packet version */\r\n\tpkthdr->ver = data[0];\r\n\r\n\t/* Packet type */\r\n\tpkthdr->ptype = data[1];\r\n\r\n\t/* src ethernet addr */\r\n\tmemcpy(pkthdr->srcaddr, data + 2, ETH_ALEN);\r\n\r\n\t/* dst ethernet addr */\r\n\tmemcpy(pkthdr->dstaddr, data + 8, ETH_ALEN);\r\n\r\n\t/* Session key */\r\n\tmemcpy(&(pkthdr->seskey), data + (mt_direction_fromserver ? 14 : 16), sizeof(pkthdr->seskey));\r\n\tpkthdr->seskey = ntohs(pkthdr->seskey);\r\n\r\n\t/* server type */\r\n\tmemcpy(&(pkthdr->clienttype), data + (mt_direction_fromserver ? 16 : 14), 2);\r\n\r\n\t/* Received/sent data counter */\r\n\tmemcpy(&(pkthdr->counter), data + 18, sizeof(pkthdr->counter));\r\n\tpkthdr->counter = ntohl(pkthdr->counter);\r\n\r\n\t/* Set pointer to actual data */\r\n\tpkthdr->data = data + 22;\r\n}", ".arse_control_packet": "int parse_control_packet(unsigned char *packetdata, unsigned short data_len, struct mt_mactelnet_control_hdr *cpkthdr) {\r\n\tstatic unsigned char *int_data;\r\n\tstatic unsigned int int_data_len;\r\n\tstatic unsigned int int_pos;\r\n\tunsigned char *data;\r\n\r\n\t/* Store info so we can call this function once with data,\r\n\t   and then several times for each control packets. Letting this function\r\n\t   control the data position. */\r\n\tif (packetdata != NULL) {\r\n\t\tif (data_len == 0) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\r\n\t\tint_data = packetdata;\r\n\t\tint_data_len = data_len;\r\n\t\tint_pos = 0;\r\n\t}\r\n\r\n\t/* No more data to parse? */\r\n\tif (int_pos >= int_data_len) {\r\n\t\treturn 0;\r\n\t}\r\n\r\n\t/* Set current position in data buffer */\r\n\tdata = int_data + int_pos;\r\n\r\n\t/* Check for valid minimum packet length & magic header */\r\n\tif ((int_data_len - int_pos) >= MT_CPHEADER_LEN && memcmp(data, &mt_mactelnet_cpmagic, 4) == 0) {\r\n\r\n\t\t/* Control packet type */\r\n\t\tcpkthdr->cptype = data[4];\r\n\r\n\t\t/* Control packet data length */\r\n\t\tmemcpy(&(cpkthdr->length), data + 5, sizeof(cpkthdr->length));\r\n\t\tcpkthdr->length = ntohl(cpkthdr->length);\r\n\r\n\t\t/* We want no buffer overflows */\r\n\t\tif (cpkthdr->length > int_data_len - MT_CPHEADER_LEN - int_pos) {\r\n\t\t\tcpkthdr->length = int_data_len - MT_CPHEADER_LEN - int_pos;\r\n\t\t}\r\n\r\n\t\t/* Set pointer to actual data */\r\n\t\tcpkthdr->data = data + MT_CPHEADER_LEN;\r\n\r\n\t\t/* Remember old position, for next call */\r\n\t\tint_pos += cpkthdr->length + MT_CPHEADER_LEN;\r\n\r\n\t\t/* Read data successfully */\r\n\t\treturn 1;\r\n\r\n\t} else {\r\n\t\t/* Mark data as raw terminal data */\r\n\t\tcpkthdr->cptype = MT_CPTYPE_PLAINDATA;\r\n\t\tcpkthdr->length = int_data_len - int_pos;\r\n\t\tcpkthdr->data = data;\r\n\r\n\t\t/* Consume the whole rest of the packet */\r\n\t\tint_pos = int_data_len;\r\n\r\n\t\t/* Read data successfully */\r\n\t\treturn 1;\r\n\t}\r\n}", ".end_auth": "static void send_auth(char *username, char *password) {\r\n\tstruct mt_packet data;\r\n\tunsigned short width = 0;\r\n\tunsigned short height = 0;\r\n\tchar *terminal = getenv(\"TERM\");\r\n\tchar md5data[100];\r\n\tunsigned char md5sum[17];\r\n\tint plen, act_pass_len;\r\n\tmd5_state_t state;\r\n\r\n#if defined(__linux__) && defined(_POSIX_MEMLOCK_RANGE)\r\n\tmlock(md5data, sizeof(md5data));\r\n\tmlock(md5sum, sizeof(md5data));\r\n#endif\r\n\r\n\t/* calculate the actual password's length */\r\n\tact_pass_len = strnlen(password, 82);\r\n\r\n\t/* Concat string of 0 + password + pass_salt */\r\n\tmd5data[0] = 0;\r\n\tmemcpy(md5data + 1, password, act_pass_len);\r\n\t/* in case that password is long, calculate only using the used-up parts */\r\n\tmemcpy(md5data + 1 + act_pass_len, pass_salt, 16);\r\n\r\n\t/* Generate md5 sum of md5data with a leading 0 */\r\n\tmd5_init(&state);\r\n\tmd5_append(&state, (const md5_byte_t *)md5data, 1 + act_pass_len + 16);\r\n\tmd5_finish(&state, (md5_byte_t *)md5sum + 1);\r\n\tmd5sum[0] = 0;\r\n\r\n\t/* Send combined packet to server */\r\n\tinit_packet(&data, MT_PTYPE_DATA, srcmac, dstmac, sessionkey, outcounter);\r\n\tplen = add_control_packet(&data, MT_CPTYPE_PASSWORD, md5sum, 17);\r\n\tplen += add_control_packet(&data, MT_CPTYPE_USERNAME, username, strlen(username));\r\n\tplen += add_control_packet(&data, MT_CPTYPE_TERM_TYPE, terminal, strlen(terminal));\r\n\t\r\n\tif (is_a_tty && get_terminal_size(&width, &height) != -1) {\r\n\t\twidth = htole16(width);\r\n\t\theight = htole16(height);\r\n\t\tplen += add_control_packet(&data, MT_CPTYPE_TERM_WIDTH, &width, 2);\r\n\t\tplen += add_control_packet(&data, MT_CPTYPE_TERM_HEIGHT, &height, 2);\r\n\t}\r\n\r\n\toutcounter += plen;\r\n\r\n\t/* TODO: handle result */\r\n\tsend_udp(&data, 1);\r\n}", ".ig_winch": "static void sig_winch(int sig) {\r\n\tunsigned short width,height;\r\n\tstruct mt_packet data;\r\n\tint plen;\r\n\r\n\t/* terminal height/width has changed, inform server */\r\n\tif (get_terminal_size(&width, &height) != -1) {\r\n\t\tinit_packet(&data, MT_PTYPE_DATA, srcmac, dstmac, sessionkey, outcounter);\r\n\t\twidth = htole16(width);\r\n\t\theight = htole16(height);\r\n\t\tplen = add_control_packet(&data, MT_CPTYPE_TERM_WIDTH, &width, 2);\r\n\t\tplen += add_control_packet(&data, MT_CPTYPE_TERM_HEIGHT, &height, 2);\r\n\t\toutcounter += plen;\r\n\r\n\t\tsend_udp(&data, 1);\r\n\t}\r\n\r\n\t/* reinstate signal handler */\r\n\tsignal(SIGWINCH, sig_winch);\r\n}", ".rint_version": "static void print_version() {\r\n\tfprintf(stderr, PROGRAM_NAME \" \" PROGRAM_VERSION \"\\n\");\r\n}", ".rop_privileges": "void drop_privileges(char *username) {\r\n\tstruct passwd *user = (struct passwd *) getpwnam(username);\r\n\tif (user == NULL) {\r\n\t\tfprintf(stderr, _(\"Failed dropping privileges. The user %s is not a valid username on local system.\\n\"), username);\r\n\t\texit(1);\r\n\t}\r\n\tif (getuid() == 0) {\r\n\t\t/* process is running as root, drop privileges */\r\n\t\tif (setgid(user->pw_gid) != 0) {\r\n\t\t\tfprintf(stderr, _(\"setgid: Error dropping group privileges\\n\"));\r\n\t\t\texit(1);\r\n\t\t}\r\n\t\tif (setuid(user->pw_uid) != 0) {\r\n\t\t\tfprintf(stderr, _(\"setuid: Error dropping user privileges\\n\"));\r\n\t\t\texit(1);\r\n\t\t}\r\n\t\t/* Verify if the privileges were developed. */\r\n\t\tif (setuid(0) != -1) {\r\n\t\t\tfprintf(stderr, _(\"Failed to drop privileges\\n\"));\r\n\t\t\texit(1);\r\n\t\t}\r\n\t}\r\n}", ".uery_mndp_or_mac": "int query_mndp_or_mac(char *address, unsigned char *dstmac, int verbose) {\r\n\tchar *p = address;\r\n\tint colons = 0;\r\n\tint dashs = 0;\r\n\r\n\twhile (*p++) {\r\n\t\tif (*p == ':') {\r\n\t\t\tcolons++;\r\n\t\t}\r\n\t\telse if (*p == '-') {\r\n\t\t\tdashs++;\r\n\t\t}\r\n\t}\r\n\r\n\t/* \r\n\t* Windows users often enter macs with dash instead\r\n\t* of colon.\r\n\t*/\r\n\tif (colons == 0 && dashs == 5) {\r\n\t\tp = address;\r\n\t\twhile (*p++) {\r\n\t\t\tif (*p == '-') {\r\n\t\t\t\t*p = ':';\r\n\t\t\t}\r\n\t\t}\r\n\t\tcolons = dashs;\r\n\t}\r\n\r\n\tif (colons != 5) {\r\n\t\t/* \r\n\t\t * Not a valid mac-address.\r\n\t\t * Search for Router by identity name, using MNDP\r\n\t\t */\r\n\t\tif (verbose) {\r\n\t\t\tfprintf(stderr, _(\"Searching for '%s'...\"), address);\r\n\t\t}\r\n\t\tif (!query_mndp(address, dstmac)) {\r\n\t\t\tif (verbose) {\r\n\t\t\t\tfprintf(stderr, _(\"not found\\n\"));\r\n\t\t\t}\r\n\t\t\treturn 0;\r\n\t\t}\r\n\r\n\t\t/* Router found, display mac and continue */\r\n\t\tif (verbose) {\r\n\t\t\tfprintf(stderr, _(\"found\\n\"));\r\n\t\t}\r\n\t} else {\r\n\t\t/* Convert mac address string to ether_addr struct */\r\n#if defined(__APPLE__)\r\n\t\tstruct ether_addr* dstmac_buf = ether_aton(address);\r\n\t\tmemcpy(dstmac, dstmac_buf, sizeof(struct ether_addr));\r\n#else\r\n\t\tether_aton_r(address, (struct ether_addr *)dstmac);\r\n#endif\r\n\t}\r\n\r\n\treturn 1;\r\n}", ".ind_interface": "static int find_interface() {\r\n\tfd_set read_fds;\r\n\tstruct mt_packet data;\r\n\tstruct sockaddr_in myip;\r\n\tunsigned char emptymac[ETH_ALEN];\r\n\tint testsocket;\r\n\tstruct timeval timeout;\r\n\tint optval = 1;\r\n\tstruct net_interface *interface;\r\n\r\n\t/* TODO: reread interfaces on HUP */\r\n\t//bzero(&interfaces, sizeof(struct net_interface) * MAX_INTERFACES);\r\n\r\n\tbzero(emptymac, ETH_ALEN);\r\n\r\n\tif (net_get_interfaces(&interfaces) <= 0) {\r\n\t\tfprintf(stderr, _(\"Error: No suitable devices found\\n\"));\r\n\t\texit(1);\r\n\t}\r\n\r\n\tDL_FOREACH(interfaces, interface) {\r\n\t\t/* Skip loopback interfaces */\r\n\t\tif (memcmp(\"lo\", interface->name, 2) == 0) {\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\t/* Initialize receiving socket on the device chosen */\r\n\t\tmyip.sin_family = AF_INET;\r\n\t\tmemcpy((void *)&myip.sin_addr, interface->ipv4_addr, IPV4_ALEN);\r\n\t\tmyip.sin_port = htons(sourceport);\r\n\r\n\t\t/* Initialize socket and bind to udp port */\r\n\t\tif ((testsocket = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)) < 0) {\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\tsetsockopt(testsocket, SOL_SOCKET, SO_BROADCAST, &optval, sizeof(optval));\r\n\t\tsetsockopt(testsocket, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval));\r\n\r\n\t\tif (bind(testsocket, (struct sockaddr *)&myip, sizeof(struct sockaddr_in)) == -1) {\r\n\t\t\tclose(testsocket);\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\t/* Ensure that we have mac-address for this interface  */\r\n\t\tif (!interface->has_mac) {\r\n\t\t\tclose(testsocket);\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\t/* Set the global socket handle and source mac address for send_udp() */\r\n\t\tsend_socket = testsocket;\r\n\t\tmemcpy(srcmac, interface->mac_addr, ETH_ALEN);\r\n\t\tactive_interface = interface;\r\n\r\n\t\t/* Send a SESSIONSTART message with the current device */\r\n\t\tinit_packet(&data, MT_PTYPE_SESSIONSTART, srcmac, dstmac, sessionkey, 0);\r\n\t\tsend_udp(&data, 0);\r\n\r\n\t\ttimeout.tv_sec = connect_timeout;\r\n\t\ttimeout.tv_usec = 0;\r\n\r\n\t\tFD_ZERO(&read_fds);\r\n\t\tFD_SET(insockfd, &read_fds);\r\n\t\tselect(insockfd + 1, &read_fds, NULL, NULL, &timeout);\r\n\t\tif (FD_ISSET(insockfd, &read_fds)) {\r\n\t\t\t/* We got a response, this is the correct device to use */\r\n\t\t\treturn 1;\r\n\t\t}\r\n\r\n\t\tclose(testsocket);\r\n\t}\r\n\treturn 0;\r\n}"}, "callee": {".ain": "int main (int argc, char **argv) {\r\n\tint result;\r\n\tstruct mt_packet data;\r\n\tstruct sockaddr_in si_me;\r\n\tstruct autologin_profile *login_profile;\r\n\tstruct net_interface *interface, *tmp;\r\n\tunsigned char buff[MT_PACKET_LEN];\r\n\tunsigned char print_help = 0, have_username = 0, have_password = 0;\r\n\tunsigned char drop_priv = 0;\r\n\tint c;\r\n\tint optval = 1;\r\n\r\n\tstrncpy(autologin_path, AUTOLOGIN_PATH, sizeof(autologin_path));\r\n\r\n\tsetlocale(LC_ALL, \"\");\r\n\tbindtextdomain(\"mactelnet\",\"/usr/share/locale\");\r\n\ttextdomain(\"mactelnet\");\r\n\r\n\twhile (1) {\r\n\t\tc = getopt(argc, argv, \"lnqt:u:p:U:vh?BAa:\");\r\n\r\n\t\tif (c == -1) {\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\tswitch (c) {\r\n\r\n\t\t\tcase 'n':\r\n\t\t\t\tuse_raw_socket = 1;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 'u':\r\n\t\t\t\t/* Save username */\r\n\t\t\t\tstrncpy(username, optarg, sizeof(username) - 1);\r\n\t\t\t\tusername[sizeof(username) - 1] = '\\0';\r\n\t\t\t\thave_username = 1;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 'p':\r\n\t\t\t\t/* Save password */\r\n#if defined(__linux__) && defined(_POSIX_MEMLOCK_RANGE)\r\n\t\t\t\tmlock(password, sizeof(password));\r\n#endif\r\n\t\t\t\tstrncpy(password, optarg, sizeof(password) - 1);\r\n\t\t\t\tpassword[sizeof(password) - 1] = '\\0';\r\n\t\t\t\thave_password = 1;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 'U':\r\n\t\t\t\t/* Save nonpriv_username */\r\n\t\t\t\tstrncpy(nonpriv_username, optarg, sizeof(nonpriv_username) - 1);\r\n\t\t\t\tnonpriv_username[sizeof(nonpriv_username) - 1] = '\\0';\r\n\t\t\t\tdrop_priv = 1;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 't':\r\n\t\t\t\tconnect_timeout = atoi(optarg);\r\n\t\t\t\tmndp_timeout = connect_timeout;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 'v':\r\n\t\t\t\tprint_version();\r\n\t\t\t\texit(0);\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 'q':\r\n\t\t\t\tquiet_mode = 1;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 'l':\r\n\t\t\t\trun_mndp = 1;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 'B':\r\n\t\t\t\tbatch_mode = 1;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 'A':\r\n\t\t\t\tno_autologin = 1;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 'a':\r\n\t\t\t\tstrncpy(autologin_path, optarg, sizeof(autologin_path) - 1);\r\n\t\t\t\tautologin_path[sizeof(autologin_path) - 1] = '\\0';\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 'h':\r\n\t\t\tcase '?':\r\n\t\t\t\tprint_help = 1;\r\n\t\t\t\tbreak;\r\n\r\n\t\t}\r\n\t}\r\n\tif (run_mndp) {\r\n\t\treturn mndp(mndp_timeout, batch_mode);\r\n\t}\r\n\tif (argc - optind < 1 || print_help) {\r\n\t\tprint_version();\r\n\t\tfprintf(stderr, _(\"Usage: %s <MAC|identity> [-h] [-n] [-a <path>] [-A] [-t <timeout>] [-u <user>] [-p <password>] [-U <user>] | -l [-B] [-t <timeout>]\\n\"), argv[0]);\r\n\r\n\t\tif (print_help) {\r\n\t\t\tfprintf(stderr, _(\"\\nParameters:\\n\"\r\n\t\t\t\"  MAC            MAC-Address of the RouterOS/mactelnetd device. Use mndp to\\n\"\r\n\t\t\t\"                 discover it.\\n\"\r\n\t\t\t\"  identity       The identity/name of your destination device. Uses\\n\"\r\n\t\t\t\"                 MNDP protocol to find it.\\n\"\r\n\t\t\t\"  -l             List/Search for routers nearby (MNDP). You may use -t to set timeout.\\n\"\r\n\t\t\t\"  -B             Batch mode. Use computer readable output (CSV), for use with -l.\\n\"\r\n\t\t\t\"  -n             Do not use broadcast packets. Less insecure but requires\\n\"\r\n\t\t\t\"                 root privileges.\\n\"\r\n\t\t\t\"  -a <path>      Use specified path instead of the default: \" AUTOLOGIN_PATH \" for autologin config file.\\n\"\r\n\t\t\t\"  -A             Disable autologin feature.\\n\"\r\n\t\t\t\"  -t <timeout>   Amount of seconds to wait for a response on each interface.\\n\"\r\n\t\t\t\"  -u <user>      Specify username on command line.\\n\"\r\n\t\t\t\"  -p <password>  Specify password on command line.\\n\"\r\n\t\t\t\"  -U <user>      Drop privileges to this user. Used in conjunction with -n\\n\"\r\n\t\t\t\"                 for security.\\n\"\r\n\t\t\t\"  -q             Quiet mode.\\n\"\r\n\t\t\t\"  -h             This help.\\n\"\r\n\t\t\t\"\\n\"));\r\n\t\t}\r\n\t\treturn 1;\r\n\t}\r\n\r\n\tis_a_tty = isatty(fileno(stdout)) && isatty(fileno(stdin));\r\n\tif (!is_a_tty) {\r\n\t\tquiet_mode = 1;\r\n\t}\r\n\r\n\tif (!no_autologin) {\r\n\t\tautologin_readfile(autologin_path);\r\n\t\tlogin_profile = autologin_find_profile(argv[optind]);\r\n\r\n\t\tif (!quiet_mode && login_profile != NULL && (login_profile->hasUsername || login_profile->hasPassword)) {\r\n\t\t\tfprintf(stderr, _(\"Using autologin credentials from %s\\n\"), autologin_path);\r\n\t\t}\r\n\t\tif (!have_username) {\r\n\t\t\tif (login_profile != NULL && login_profile->hasUsername) {\r\n\t\t\t\thave_username = 1;\r\n\t\t\t\tstrncpy(username, login_profile->username, sizeof(username) - 1);\r\n\t\t\t\tusername[sizeof(username) - 1] = '\\0';\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (!have_password) {\r\n\t\t\tif (login_profile != NULL && login_profile->hasPassword) {\r\n\t\t\t\thave_password = 1;\r\n\t\t\t\tstrncpy(password, login_profile->password, sizeof(password) - 1);\r\n\t\t\t\tpassword[sizeof(password) - 1] = '\\0';\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/* Seed randomizer */\r\n\tsrand(time(NULL));\r\n\r\n\tif (use_raw_socket) {\r\n\t\tif (geteuid() != 0) {\r\n\t\t\tfprintf(stderr, _(\"You need to have root privileges to use the -n parameter.\\n\"));\r\n\t\t\treturn 1;\r\n\t\t}\r\n\r\n\t\tsockfd = net_init_raw_socket();\r\n\r\n\t\tif (drop_priv) {\r\n\t\t\tdrop_privileges(nonpriv_username);\r\n\t\t}\r\n\t} else if (drop_priv) {\r\n\t\tfprintf(stderr, _(\"The -U option must be used in conjunction with the -n parameter.\\n\"));\r\n\t\treturn 1;\r\n\t}\r\n\r\n\t/* Receive regular udp packets with this socket */\r\n\tinsockfd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);\r\n\tif (insockfd < 0) {\r\n\t\tperror(\"insockfd\");\r\n\t\treturn 1;\r\n\t}\r\n\r\n\tif (!use_raw_socket) {\r\n\t\tif (setsockopt(insockfd, SOL_SOCKET, SO_BROADCAST, &optval, sizeof (optval))==-1) {\r\n\t\t\tperror(\"SO_BROADCAST\");\r\n\t\t\treturn 1;\r\n\t\t}\r\n\t}\r\n\r\n\t/* Need to use, to be able to autodetect which interface to use */\r\n\tsetsockopt(insockfd, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof (optval));\r\n\r\n\t/* Get mac-address from string, or check for hostname via mndp */\r\n\tif (!query_mndp_or_mac(argv[optind], dstmac, !quiet_mode)) {\r\n\t\t/* No valid mac address found, abort */\r\n\t\treturn 1;\r\n\t}\r\n\r\n\tif (!have_username) {\r\n\t\tif (!quiet_mode) {\r\n\t\t\tprintf(_(\"Login: \"));\r\n\t\t\tfflush(stdout);\r\n\t\t}\r\n\t\tscanf(\"%127s\", username);\r\n\t}\r\n\r\n\tif (!have_password) {\r\n\t\tchar *tmp;\r\n\t\ttmp = getpass(quiet_mode ? \"\" : _(\"Password: \"));\r\n#if defined(__linux__) && defined(_POSIX_MEMLOCK_RANGE)\r\n\t\tmlock(password, sizeof(password));\r\n#endif\r\n\t\tstrncpy(password, tmp, sizeof(password) - 1);\r\n\t\tpassword[sizeof(password) - 1] = '\\0';\r\n\t\t/* security */\r\n\t\tmemset(tmp, 0, strlen(tmp));\r\n#ifdef __linux__\r\n\t\tfree(tmp);\r\n#endif\r\n\t}\r\n\r\n\r\n\t/* Set random source port */\r\n\tsourceport = 1024 + (rand() % 1024);\r\n\r\n\t/* Set up global info about the connection */\r\n\tinet_pton(AF_INET, (char *)\"255.255.255.255\", &destip);\r\n\tmemcpy(&sourceip, &(si_me.sin_addr), IPV4_ALEN);\r\n\r\n\t/* Session key */\r\n\tsessionkey = rand() % 65535;\r\n\r\n\t/* stop output buffering */\r\n\tsetvbuf(stdout, (char*)NULL, _IONBF, 0);\r\n\r\n\tif (!quiet_mode) {\r\n\t\tprintf(_(\"Connecting to %s...\"), ether_ntoa((struct ether_addr *)dstmac));\r\n\t}\r\n\r\n\t/* Initialize receiving socket on the device chosen */\r\n\tmemset((char *) &si_me, 0, sizeof(si_me));\r\n\tsi_me.sin_family = AF_INET;\r\n\tsi_me.sin_port = htons(sourceport);\r\n\r\n\t/* Bind to udp port */\r\n\tif (bind(insockfd, (struct sockaddr *)&si_me, sizeof(si_me)) == -1) {\r\n\t\tfprintf(stderr, _(\"Error binding to %s:%d, %s\\n\"), inet_ntoa(si_me.sin_addr), sourceport, strerror(errno));\r\n\t\treturn 1;\r\n\t}\r\n\r\n\tif (!find_interface() || (result = recvfrom(insockfd, buff, sizeof(buff), 0, 0, 0)) < 1) {\r\n\t\tfprintf(stderr, _(\"Connection failed.\\n\"));\r\n\t\treturn 1;\r\n\t}\r\n\tif (!quiet_mode) {\r\n\t\tprintf(_(\"done\\n\"));\r\n\t}\r\n\r\n\t/* Handle first received packet */\r\n\thandle_packet(buff, result);\r\n\r\n\tinit_packet(&data, MT_PTYPE_DATA, srcmac, dstmac, sessionkey, 0);\r\n\toutcounter += add_control_packet(&data, MT_CPTYPE_BEGINAUTH, NULL, 0);\r\n\r\n\t/* TODO: handle result of send_udp */\r\n\tresult = send_udp(&data, 1);\r\n\r\n\twhile (running) {\r\n\t\tfd_set read_fds;\r\n\t\tint reads;\r\n\t\tstatic int terminal_gone = 0;\r\n\t\tstruct timeval timeout;\r\n\r\n\t\t/* Init select */\r\n\t\tFD_ZERO(&read_fds);\r\n\t\tif (!terminal_gone) {\r\n\t\t\tFD_SET(0, &read_fds);\r\n\t\t}\r\n\t\tFD_SET(insockfd, &read_fds);\r\n\r\n\t\ttimeout.tv_sec = 1;\r\n\t\ttimeout.tv_usec = 0;\r\n\r\n\t\t/* Wait for data or timeout */\r\n\t\treads = select(insockfd+1, &read_fds, NULL, NULL, &timeout);\r\n\t\tif (reads > 0) {\r\n\t\t\t/* Handle data from server */\r\n\t\t\tif (FD_ISSET(insockfd, &read_fds)) {\r\n\t\t\t\tbzero(buff, sizeof(buff));\r\n\t\t\t\tresult = recvfrom(insockfd, buff, sizeof(buff), 0, 0, 0);\r\n\t\t\t\thandle_packet(buff, result);\r\n\t\t\t}\r\n\t\t\t/* Handle data from keyboard/local terminal */\r\n\t\t\tif (FD_ISSET(0, &read_fds) && terminal_mode) {\r\n\t\t\t\tunsigned char keydata[512];\r\n\t\t\t\tint datalen;\r\n\r\n\t\t\t\tdatalen = read(STDIN_FILENO, &keydata, sizeof(keydata));\r\n\r\n\t\t\t\tif (datalen > 0) {\r\n\t\t\t\t\t/* Data received, transmit to server */\r\n\t\t\t\t\tinit_packet(&data, MT_PTYPE_DATA, srcmac, dstmac, sessionkey, outcounter);\r\n\t\t\t\t\tadd_control_packet(&data, MT_CPTYPE_PLAINDATA, &keydata, datalen);\r\n\t\t\t\t\toutcounter += datalen;\r\n\t\t\t\t\tsend_udp(&data, 1);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tterminal_gone = 1;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t/* Handle select() timeout */\r\n\t\t} else {\r\n\t\t\t/* handle keepalive counter, transmit keepalive packet every 10 seconds\r\n\t\t\t   of inactivity  */\r\n\t\t\tif (keepalive_counter++ == 10) {\r\n\t\t\t\tstruct mt_packet odata;\r\n\t\t\t\tinit_packet(&odata, MT_PTYPE_ACK, srcmac, dstmac, sessionkey, outcounter);\r\n\t\t\t\tsend_udp(&odata, 0);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tif (is_a_tty && terminal_mode) {\r\n\t\t/* Reset terminal back to old settings */\r\n\t\treset_term();\r\n\t}\r\n\r\n\tclose(sockfd);\r\n\tclose(insockfd);\r\n\r\n\tDL_FOREACH_SAFE(interfaces, interface, tmp) {\r\n\t\tDL_DELETE(interfaces, interface);\r\n\t\tfree(interface);\r\n\t}\r\n\r\n\treturn 0;\r\n}", ".end_auth": "static void send_auth(char *username, char *password) {\r\n\tstruct mt_packet data;\r\n\tunsigned short width = 0;\r\n\tunsigned short height = 0;\r\n\tchar *terminal = getenv(\"TERM\");\r\n\tchar md5data[100];\r\n\tunsigned char md5sum[17];\r\n\tint plen, act_pass_len;\r\n\tmd5_state_t state;\r\n\r\n#if defined(__linux__) && defined(_POSIX_MEMLOCK_RANGE)\r\n\tmlock(md5data, sizeof(md5data));\r\n\tmlock(md5sum, sizeof(md5data));\r\n#endif\r\n\r\n\t/* calculate the actual password's length */\r\n\tact_pass_len = strnlen(password, 82);\r\n\r\n\t/* Concat string of 0 + password + pass_salt */\r\n\tmd5data[0] = 0;\r\n\tmemcpy(md5data + 1, password, act_pass_len);\r\n\t/* in case that password is long, calculate only using the used-up parts */\r\n\tmemcpy(md5data + 1 + act_pass_len, pass_salt, 16);\r\n\r\n\t/* Generate md5 sum of md5data with a leading 0 */\r\n\tmd5_init(&state);\r\n\tmd5_append(&state, (const md5_byte_t *)md5data, 1 + act_pass_len + 16);\r\n\tmd5_finish(&state, (md5_byte_t *)md5sum + 1);\r\n\tmd5sum[0] = 0;\r\n\r\n\t/* Send combined packet to server */\r\n\tinit_packet(&data, MT_PTYPE_DATA, srcmac, dstmac, sessionkey, outcounter);\r\n\tplen = add_control_packet(&data, MT_CPTYPE_PASSWORD, md5sum, 17);\r\n\tplen += add_control_packet(&data, MT_CPTYPE_USERNAME, username, strlen(username));\r\n\tplen += add_control_packet(&data, MT_CPTYPE_TERM_TYPE, terminal, strlen(terminal));\r\n\t\r\n\tif (is_a_tty && get_terminal_size(&width, &height) != -1) {\r\n\t\twidth = htole16(width);\r\n\t\theight = htole16(height);\r\n\t\tplen += add_control_packet(&data, MT_CPTYPE_TERM_WIDTH, &width, 2);\r\n\t\tplen += add_control_packet(&data, MT_CPTYPE_TERM_HEIGHT, &height, 2);\r\n\t}\r\n\r\n\toutcounter += plen;\r\n\r\n\t/* TODO: handle result */\r\n\tsend_udp(&data, 1);\r\n}", ".ig_winch": "static void sig_winch(int sig) {\r\n\tunsigned short width,height;\r\n\tstruct mt_packet data;\r\n\tint plen;\r\n\r\n\t/* terminal height/width has changed, inform server */\r\n\tif (get_terminal_size(&width, &height) != -1) {\r\n\t\tinit_packet(&data, MT_PTYPE_DATA, srcmac, dstmac, sessionkey, outcounter);\r\n\t\twidth = htole16(width);\r\n\t\theight = htole16(height);\r\n\t\tplen = add_control_packet(&data, MT_CPTYPE_TERM_WIDTH, &width, 2);\r\n\t\tplen += add_control_packet(&data, MT_CPTYPE_TERM_HEIGHT, &height, 2);\r\n\t\toutcounter += plen;\r\n\r\n\t\tsend_udp(&data, 1);\r\n\t}\r\n\r\n\t/* reinstate signal handler */\r\n\tsignal(SIGWINCH, sig_winch);\r\n}", ".andle_packet": "static int handle_packet(unsigned char *data, int data_len) {\r\n\tstruct mt_mactelnet_hdr pkthdr;\r\n\r\n\t/* Minimal size checks (pings are not supported here) */\r\n\tif (data_len < MT_HEADER_LEN){\r\n\t\treturn -1;\r\n\t}\r\n\tparse_packet(data, &pkthdr);\r\n\r\n\t/* We only care about packets with correct sessionkey */\r\n\tif (pkthdr.seskey != sessionkey) {\r\n\t\treturn -1;\r\n\t}\r\n\r\n\t/* Handle data packets */\r\n\tif (pkthdr.ptype == MT_PTYPE_DATA) {\r\n\t\tstruct mt_packet odata;\r\n\t\tstruct mt_mactelnet_control_hdr cpkt;\r\n\t\tint success = 0;\r\n\r\n\t\t/* Always transmit ACKNOWLEDGE packets in response to DATA packets */\r\n\t\tinit_packet(&odata, MT_PTYPE_ACK, srcmac, dstmac, sessionkey, pkthdr.counter + (data_len - MT_HEADER_LEN));\r\n\t\tsend_udp(&odata, 0);\r\n\r\n\t\t/* Accept first packet, and all packets greater than incounter, and if counter has\r\n\t\twrapped around. */\r\n\t\tif (pkthdr.counter > incounter || (incounter - pkthdr.counter) > 65535) {\r\n\t\t\tincounter = pkthdr.counter;\r\n\t\t} else {\r\n\t\t\t/* Ignore double or old packets */\r\n\t\t\treturn -1;\r\n\t\t}\r\n\r\n\t\t/* Parse controlpacket data */\r\n\t\tsuccess = parse_control_packet(data + MT_HEADER_LEN, data_len - MT_HEADER_LEN, &cpkt);\r\n\r\n\t\twhile (success) {\r\n\r\n\t\t\t/* If we receive pass_salt, transmit auth data back */\r\n\t\t\tif (cpkt.cptype == MT_CPTYPE_PASSSALT) {\r\n\t\t\t\t/* check validity, server sends exactly 16 bytes */\r\n\t\t\t\tif (cpkt.length != 16) {\r\n\t\t\t\t\tfprintf(stderr, _(\"Invalid salt length: %d (instead of 16) received from server %s\\n\"), cpkt.length, ether_ntoa((struct ether_addr *)dstmac));\r\n\t\t\t\t}\r\n\t\t\t\tmemcpy(pass_salt, cpkt.data, 16);\r\n\t\t\t\tsend_auth(username, password);\r\n\t\t\t}\r\n\r\n\t\t\t/* If the (remaining) data did not have a control-packet magic byte sequence,\r\n\t\t\t   the data is raw terminal data to be outputted to the terminal. */\r\n\t\t\telse if (cpkt.cptype == MT_CPTYPE_PLAINDATA) {\r\n\t\t\t\tfwrite((const void *)cpkt.data, 1, cpkt.length, stdout);\r\n\t\t\t}\r\n\r\n\t\t\t/* END_AUTH means that the user/password negotiation is done, and after this point\r\n\t\t\t   terminal data may arrive, so we set up the terminal to raw mode. */\r\n\t\t\telse if (cpkt.cptype == MT_CPTYPE_END_AUTH) {\r\n\r\n\t\t\t\t/* we have entered \"terminal mode\" */\r\n\t\t\t\tterminal_mode = 1;\r\n\r\n\t\t\t\tif (is_a_tty) {\r\n\t\t\t\t\t/* stop input buffering at all levels. Give full control of terminal to RouterOS */\r\n\t\t\t\t\traw_term();\r\n\r\n\t\t\t\t\tsetvbuf(stdin,  (char*)NULL, _IONBF, 0);\r\n\r\n\t\t\t\t\t/* Add resize signal handler */\r\n\t\t\t\t\tsignal(SIGWINCH, sig_winch);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t/* Parse next controlpacket */\r\n\t\t\tsuccess = parse_control_packet(NULL, 0, &cpkt);\r\n\t\t}\r\n\t}\r\n\telse if (pkthdr.ptype == MT_PTYPE_ACK) {\r\n\t\t/* Handled elsewhere */\r\n\t}\r\n\r\n\t/* The server wants to terminate the connection, we have to oblige */\r\n\telse if (pkthdr.ptype == MT_PTYPE_END) {\r\n\t\tstruct mt_packet odata;\r\n\r\n\t\t/* Acknowledge the disconnection by sending a END packet in return */\r\n\t\tinit_packet(&odata, MT_PTYPE_END, srcmac, dstmac, pkthdr.seskey, 0);\r\n\t\tsend_udp(&odata, 0);\r\n\r\n\t\tif (!quiet_mode) {\r\n\t\t\tfprintf(stderr, _(\"Connection closed.\\n\"));\r\n\t\t}\r\n\r\n\t\t/* exit */\r\n\t\trunning = 0;\r\n\t} else {\r\n\t\tfprintf(stderr, _(\"Unhandeled packet type: %d received from server %s\\n\"), pkthdr.ptype, ether_ntoa((struct ether_addr *)dstmac));\r\n\t\treturn -1;\r\n\t}\r\n\r\n\treturn pkthdr.ptype;\r\n}", ".ind_interface": "static int find_interface() {\r\n\tfd_set read_fds;\r\n\tstruct mt_packet data;\r\n\tstruct sockaddr_in myip;\r\n\tunsigned char emptymac[ETH_ALEN];\r\n\tint testsocket;\r\n\tstruct timeval timeout;\r\n\tint optval = 1;\r\n\tstruct net_interface *interface;\r\n\r\n\t/* TODO: reread interfaces on HUP */\r\n\t//bzero(&interfaces, sizeof(struct net_interface) * MAX_INTERFACES);\r\n\r\n\tbzero(emptymac, ETH_ALEN);\r\n\r\n\tif (net_get_interfaces(&interfaces) <= 0) {\r\n\t\tfprintf(stderr, _(\"Error: No suitable devices found\\n\"));\r\n\t\texit(1);\r\n\t}\r\n\r\n\tDL_FOREACH(interfaces, interface) {\r\n\t\t/* Skip loopback interfaces */\r\n\t\tif (memcmp(\"lo\", interface->name, 2) == 0) {\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\t/* Initialize receiving socket on the device chosen */\r\n\t\tmyip.sin_family = AF_INET;\r\n\t\tmemcpy((void *)&myip.sin_addr, interface->ipv4_addr, IPV4_ALEN);\r\n\t\tmyip.sin_port = htons(sourceport);\r\n\r\n\t\t/* Initialize socket and bind to udp port */\r\n\t\tif ((testsocket = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)) < 0) {\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\tsetsockopt(testsocket, SOL_SOCKET, SO_BROADCAST, &optval, sizeof(optval));\r\n\t\tsetsockopt(testsocket, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval));\r\n\r\n\t\tif (bind(testsocket, (struct sockaddr *)&myip, sizeof(struct sockaddr_in)) == -1) {\r\n\t\t\tclose(testsocket);\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\t/* Ensure that we have mac-address for this interface  */\r\n\t\tif (!interface->has_mac) {\r\n\t\t\tclose(testsocket);\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\t/* Set the global socket handle and source mac address for send_udp() */\r\n\t\tsend_socket = testsocket;\r\n\t\tmemcpy(srcmac, interface->mac_addr, ETH_ALEN);\r\n\t\tactive_interface = interface;\r\n\r\n\t\t/* Send a SESSIONSTART message with the current device */\r\n\t\tinit_packet(&data, MT_PTYPE_SESSIONSTART, srcmac, dstmac, sessionkey, 0);\r\n\t\tsend_udp(&data, 0);\r\n\r\n\t\ttimeout.tv_sec = connect_timeout;\r\n\t\ttimeout.tv_usec = 0;\r\n\r\n\t\tFD_ZERO(&read_fds);\r\n\t\tFD_SET(insockfd, &read_fds);\r\n\t\tselect(insockfd + 1, &read_fds, NULL, NULL, &timeout);\r\n\t\tif (FD_ISSET(insockfd, &read_fds)) {\r\n\t\t\t/* We got a response, this is the correct device to use */\r\n\t\t\treturn 1;\r\n\t\t}\r\n\r\n\t\tclose(testsocket);\r\n\t}\r\n\treturn 0;\r\n}", ".end_udp": "static int send_udp(struct mt_packet *packet, int retransmit) {\r\n\tint sent_bytes;\r\n\r\n\t/* Clear keepalive counter */\r\n\tkeepalive_counter = 0;\r\n\r\n\tif (!use_raw_socket) {\r\n\t\t/* Init SendTo struct */\r\n\t\tstruct sockaddr_in socket_address;\r\n\t\tsocket_address.sin_family = AF_INET;\r\n\t\tsocket_address.sin_port = htons(MT_MACTELNET_PORT);\r\n\t\tsocket_address.sin_addr.s_addr = htonl(INADDR_BROADCAST);\r\n\r\n\t\tsent_bytes = sendto(send_socket, packet->data, packet->size, 0, (struct sockaddr*)&socket_address, sizeof(socket_address));\r\n\t} else {\r\n\t\tsent_bytes = net_send_udp(sockfd, active_interface, srcmac, dstmac, &sourceip,  sourceport, &destip, MT_MACTELNET_PORT, packet->data, packet->size);\r\n\t}\r\n\r\n\t/* \r\n\t * Retransmit packet if no data is received within\r\n\t * retransmit_intervals milliseconds.\r\n\t */\r\n\tif (retransmit) {\r\n\t\tint i;\r\n\r\n\t\tfor (i = 0; i < MAX_RETRANSMIT_INTERVALS; ++i) {\r\n\t\t\tfd_set read_fds;\r\n\t\t\tint reads;\r\n\t\t\tstruct timeval timeout;\r\n\t\t\tint interval = retransmit_intervals[i] * 1000;\r\n\r\n\t\t\t/* Init select */\r\n\t\t\tFD_ZERO(&read_fds);\r\n\t\t\tFD_SET(insockfd, &read_fds);\r\n\t\t\ttimeout.tv_sec = 0;\r\n\t\t\ttimeout.tv_usec = interval;\r\n\r\n\t\t\t/* Wait for data or timeout */\r\n\t\t\treads = select(insockfd + 1, &read_fds, NULL, NULL, &timeout);\r\n\t\t\tif (reads && FD_ISSET(insockfd, &read_fds)) {\r\n\t\t\t\tunsigned char buff[MT_PACKET_LEN];\r\n\t\t\t\tint result;\r\n\r\n\t\t\t\tbzero(buff, sizeof(buff));\r\n\t\t\t\tresult = recvfrom(insockfd, buff, sizeof(buff), 0, 0, 0);\r\n\r\n\t\t\t\t/* Handle incoming packets, waiting for an ack */\r\n\t\t\t\tif (result > 0 && handle_packet(buff, result) == MT_PTYPE_ACK) {\r\n\t\t\t\t\treturn sent_bytes;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t/* Retransmit */\r\n\t\t\tsend_udp(packet, 0);\r\n\t\t}\r\n\r\n\t\tif (is_a_tty && terminal_mode) {\r\n\t\t\treset_term();\r\n\t\t}\r\n\r\n\t\tfprintf(stderr, _(\"\\nConnection timed out\\n\"));\r\n\t\texit(1);\r\n\t}\r\n\treturn sent_bytes;\r\n}"}, "function_name": "main"}
{"function_id": null, "caller": {".et_tb_count": "static int\r\nget_tb_count(struct fp_info *p_fp_info)\r\n{\r\n    int chan, tb_count = 0;\r\n    for (chan = 0; chan < p_fp_info->num_chans; chan++) {\r\n        tb_count += p_fp_info->chan_num_tbs[chan];\r\n    }\r\n    return tb_count;\r\n}", ".issect_dch_outer_loop_power_control": "static int\r\ndissect_dch_outer_loop_power_control(proto_tree *tree, packet_info *pinfo, tvbuff_t *tvb, int offset)\r\n{\r\n    /* UL SIR target */\r\n    uint8_t encoded = tvb_get_uint8(tvb, offset);\r\n    float target = (float)-8.2 + ((float)0.1 * (float)(int)(encoded));\r\n    proto_tree_add_float_format_value(tree, hf_fp_ul_sir_target, tvb, offset, 1, target, \"%.1f dB (%u)\", target, encoded);\r\n    offset++;\r\n\r\n    col_append_fstr(pinfo->cinfo, COL_INFO, \" UL SIR Target = %.1f\", target);\r\n\r\n    return offset;\r\n}", ".issect_common_timing_adjustment": "static int\r\ndissect_common_timing_adjustment(packet_info *pinfo, proto_tree *tree, tvbuff_t *tvb,\r\n                                 int offset, struct fp_info *p_fp_info)\r\n{\r\n    int32_t toa;\r\n    proto_item *toa_ti;\r\n\r\n    if (p_fp_info->channel != CHANNEL_PCH) {\r\n        uint32_t cfn;\r\n\r\n        /* CFN control */\r\n        proto_tree_add_item_ret_uint(tree, hf_fp_cfn_control, tvb, offset, 1, ENC_BIG_ENDIAN, &cfn);\r\n        offset++;\r\n\r\n        /* ToA */\r\n        toa = tvb_get_ntohis(tvb, offset);\r\n        toa_ti = proto_tree_add_item(tree, hf_fp_toa, tvb, offset, 2, ENC_BIG_ENDIAN);\r\n        offset += 2;\r\n\r\n        col_append_fstr(pinfo->cinfo, COL_INFO, \"   CFN=%u, ToA=%d\", cfn, toa);\r\n    }\r\n    else {\r\n        uint32_t cfn;\r\n\r\n        /* PCH CFN is 12 bits */\r\n        proto_tree_add_item_ret_uint(tree, hf_fp_pch_cfn, tvb, offset, 2, ENC_BIG_ENDIAN, &cfn);\r\n        offset += 2;\r\n\r\n        /* 4 bits of padding follow... */\r\n\r\n        /* 20 bits of ToA (followed by 4 padding bits) */\r\n        toa = ((int)(tvb_get_ntoh24(tvb, offset) << 8)) / 4096;\r\n        toa_ti = proto_tree_add_int(tree, hf_fp_pch_toa, tvb, offset, 3, toa);\r\n        offset += 3;\r\n\r\n        col_append_fstr(pinfo->cinfo, COL_INFO, \"   CFN=%u, ToA=%d\", cfn, toa);\r\n    }\r\n\r\n    expert_add_info_format(pinfo, toa_ti, &ei_fp_timing_adjustment_reported, \"Timing adjustment reported (%.3f ms)\", ((float)(toa) / 8));\r\n\r\n    return offset;\r\n}", ".issect_common_outer_loop_power_control": "static int\r\ndissect_common_outer_loop_power_control(packet_info *pinfo, proto_tree *tree, tvbuff_t *tvb,\r\n                                        int offset, struct fp_info *p_fp_info _U_)\r\n{\r\n    return dissect_dch_outer_loop_power_control(tree, pinfo, tvb, offset);\r\n}", ".issect_common_dl_synchronisation": "static int\r\ndissect_common_dl_synchronisation(packet_info *pinfo, proto_tree *tree,\r\n                                  tvbuff_t *tvb, int offset, struct fp_info *p_fp_info)\r\n{\r\n    uint32_t cfn;\r\n\r\n    if (p_fp_info->channel != CHANNEL_PCH) {\r\n        /* CFN control */\r\n        proto_tree_add_item_ret_uint(tree, hf_fp_cfn_control, tvb, offset, 1, ENC_BIG_ENDIAN, &cfn);\r\n        offset++;\r\n    }\r\n    else {\r\n        /* PCH CFN is 12 bits */\r\n        proto_tree_add_item_ret_uint(tree, hf_fp_pch_cfn, tvb, offset, 2, ENC_BIG_ENDIAN, &cfn);\r\n\r\n        /* 4 bits of padding follow... */\r\n        offset += 2;\r\n    }\r\n\r\n    col_append_fstr(pinfo->cinfo, COL_INFO, \"   CFN=%u\", cfn);\r\n\r\n    return offset;\r\n}", ".issect_common_ul_synchronisation": "static int\r\ndissect_common_ul_synchronisation(packet_info *pinfo, proto_tree *tree,\r\n                                  tvbuff_t *tvb, int offset, struct fp_info *p_fp_info)\r\n{\r\n    return dissect_common_timing_adjustment(pinfo, tree, tvb, offset, p_fp_info);\r\n}", ".issect_common_dl_node_synchronisation": "static int\r\ndissect_common_dl_node_synchronisation(packet_info *pinfo, proto_tree *tree,\r\n                                       tvbuff_t *tvb, int offset)\r\n{\r\n    /* T1 (3 bytes) */\r\n    uint32_t encoded = tvb_get_ntoh24(tvb, offset);\r\n    float t1 = encoded * (float)0.125;\r\n    proto_tree_add_float_format_value(tree, hf_fp_t1, tvb, offset, 3, t1, \"%.3f ms (%u)\", t1, encoded);\r\n    offset += 3;\r\n\r\n    col_append_fstr(pinfo->cinfo, COL_INFO, \"   T1=%.3f\", t1);\r\n\r\n    return offset;\r\n}", ".issect_common_ul_node_synchronisation": "static int\r\ndissect_common_ul_node_synchronisation(packet_info *pinfo, proto_tree *tree,\r\n                                       tvbuff_t *tvb, int offset)\r\n{\r\n    uint32_t encoded;\r\n    float t1, t2, t3;\r\n\r\n    /* T1 (3 bytes) */\r\n    encoded = tvb_get_ntoh24(tvb, offset);\r\n    t1 = encoded * (float)0.125;\r\n    proto_tree_add_float_format_value(tree, hf_fp_t1, tvb, offset, 3, t1, \"%.3f ms (%u)\", t1, encoded);\r\n    offset += 3;\r\n\r\n    /* T2 (3 bytes) */\r\n    encoded = tvb_get_ntoh24(tvb, offset);\r\n    t2 = encoded * (float)0.125;\r\n    proto_tree_add_float_format_value(tree, hf_fp_t2, tvb, offset, 3, t2, \"%.3f ms (%u)\", t2, encoded);\r\n    offset += 3;\r\n\r\n    /* T3 (3 bytes) */\r\n    encoded = tvb_get_ntoh24(tvb, offset);\r\n    t3 = encoded * (float)0.125;\r\n    proto_tree_add_float_format_value(tree, hf_fp_t3, tvb, offset, 3, t3, \"%.3f ms (%u)\", t3, encoded);\r\n    offset += 3;\r\n\r\n    col_append_fstr(pinfo->cinfo, COL_INFO, \"   T1=%.3f T2=%.3f, T3=%.3f\",\r\n                    t1, t2, t3);\r\n\r\n    return offset;\r\n}", ".issect_common_dynamic_pusch_assignment": "static int\r\ndissect_common_dynamic_pusch_assignment(packet_info *pinfo, proto_tree *tree,\r\n                                        tvbuff_t *tvb, int offset)\r\n{\r\n    uint8_t pusch_set_id;\r\n    uint8_t activation_cfn;\r\n    uint8_t duration;\r\n\r\n    /* PUSCH Set Id */\r\n    pusch_set_id = tvb_get_uint8(tvb, offset);\r\n    proto_tree_add_item(tree, hf_fp_pusch_set_id, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n    offset++;\r\n\r\n    /* Activation CFN */\r\n    activation_cfn = tvb_get_uint8(tvb, offset);\r\n    proto_tree_add_item(tree, hf_fp_activation_cfn, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n    offset++;\r\n\r\n    /* Duration */\r\n    duration = tvb_get_uint8(tvb, offset) * 10;\r\n    proto_tree_add_uint(tree, hf_fp_duration, tvb, offset, 1, duration);\r\n    offset++;\r\n\r\n    col_append_fstr(pinfo->cinfo, COL_INFO,\r\n                    \"   PUSCH Set Id=%u  Activation CFN=%u  Duration=%u\",\r\n                    pusch_set_id, activation_cfn, duration);\r\n\r\n    return offset;\r\n}", ".issect_common_timing_advance": "static int\r\ndissect_common_timing_advance(packet_info *pinfo, proto_tree *tree, tvbuff_t *tvb, int offset)\r\n{\r\n    uint32_t cfn;\r\n    uint16_t timing_advance;\r\n\r\n    /* CFN control */\r\n    proto_tree_add_item_ret_uint(tree, hf_fp_cfn_control, tvb, offset, 1, ENC_BIG_ENDIAN, &cfn);\r\n    offset++;\r\n\r\n    /* Timing Advance */\r\n    timing_advance = (tvb_get_uint8(tvb, offset) & 0x3f) * 4;\r\n    proto_tree_add_uint(tree, hf_fp_timing_advance, tvb, offset, 1, timing_advance);\r\n    offset++;\r\n\r\n    col_append_fstr(pinfo->cinfo, COL_INFO, \" CFN = %u, TA = %u\",\r\n                    cfn, timing_advance);\r\n\r\n    return offset;\r\n}", ".issect_hsdpa_capacity_request": "static int\r\ndissect_hsdpa_capacity_request(packet_info *pinfo, proto_tree *tree,\r\n                               tvbuff_t *tvb, int offset)\r\n{\r\n    uint8_t priority;\r\n    uint16_t user_buffer_size;\r\n\r\n    /* CmCH-PI */\r\n    priority = (tvb_get_uint8(tvb, offset) & 0x0f);\r\n    proto_tree_add_item(tree, hf_fp_cmch_pi, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n    offset++;\r\n\r\n    /* User buffer size */\r\n    user_buffer_size = tvb_get_ntohs(tvb, offset);\r\n    proto_tree_add_item(tree, hf_fp_user_buffer_size, tvb, offset, 2, ENC_BIG_ENDIAN);\r\n    offset += 2;\r\n\r\n    col_append_fstr(pinfo->cinfo, COL_INFO, \"      CmCH-PI=%u  User-Buffer-Size=%u\",\r\n                    priority, user_buffer_size);\r\n\r\n    return offset;\r\n}", ".issect_hsdpa_capacity_allocation": "static int\r\ndissect_hsdpa_capacity_allocation(packet_info *pinfo, proto_tree *tree,\r\n                                  tvbuff_t *tvb, int offset,\r\n                                  struct fp_info *p_fp_info)\r\n{\r\n    proto_item *ti;\r\n    proto_item *rate_ti;\r\n    uint16_t    max_pdu_length;\r\n    uint8_t     repetition_period;\r\n    uint8_t     interval;\r\n    uint64_t    credits;\r\n\r\n    /* Congestion status (introduced sometime during R6...) */\r\n    if ((p_fp_info->release == 6) || (p_fp_info->release == 7)) {\r\n        proto_tree_add_bits_item(tree, hf_fp_congestion_status, tvb,\r\n                                 offset*8 + 2, 2, ENC_BIG_ENDIAN);\r\n    }\r\n\r\n    /* CmCH-PI */\r\n    proto_tree_add_item(tree, hf_fp_cmch_pi, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n    offset++;\r\n\r\n    /* Max MAC-d PDU length (13 bits) */\r\n    max_pdu_length = tvb_get_ntohs(tvb, offset) >> 3;\r\n    proto_tree_add_item(tree, hf_fp_hsdsch_max_macd_pdu_len, tvb, offset, 2, ENC_BIG_ENDIAN);\r\n    offset++;\r\n\r\n    /* HS-DSCH credits (11 bits) */\r\n    ti = proto_tree_add_bits_ret_val(tree, hf_fp_hsdsch_credits, tvb,\r\n                                     offset*8 + 5, 11, &credits, ENC_BIG_ENDIAN);\r\n    offset += 2;\r\n\r\n    /* Interesting values */\r\n    if (credits == 0) {\r\n        proto_item_append_text(ti, \" (stop transmission)\");\r\n        expert_add_info(pinfo, ti, &ei_fp_stop_hsdpa_transmission);\r\n    }\r\n    if (credits == 2047) {\r\n        proto_item_append_text(ti, \" (unlimited)\");\r\n    }\r\n\r\n    /* HS-DSCH Interval */\r\n    interval = tvb_get_uint8(tvb, offset);\r\n    ti = proto_tree_add_uint(tree, hf_fp_hsdsch_interval, tvb, offset, 1, interval*10);\r\n    offset++;\r\n    if (interval == 0) {\r\n        proto_item_append_text(ti, \" (none of the credits shall be used)\");\r\n    }\r\n\r\n    /* HS-DSCH Repetition period */\r\n    repetition_period = tvb_get_uint8(tvb, offset);\r\n    ti = proto_tree_add_item(tree, hf_fp_hsdsch_repetition_period, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n    offset++;\r\n    if (repetition_period == 0) {\r\n        proto_item_append_text(ti, \" (unlimited repetition period)\");\r\n    }\r\n\r\n    /* Calculated and show effective rate enabled */\r\n    if (credits == 2047) {\r\n        rate_ti = proto_tree_add_item(tree, hf_fp_hsdsch_unlimited_rate, tvb, 0, 0, ENC_NA);\r\n        proto_item_set_generated(rate_ti);\r\n    }\r\n    else {\r\n        if (interval != 0) {\r\n            /* Cast on credits is safe, since we know it won't exceed 10^11 */\r\n            rate_ti = proto_tree_add_uint(tree, hf_fp_hsdsch_calculated_rate, tvb, 0, 0,\r\n                                          (uint16_t)credits * max_pdu_length * (1000 / (interval*10)));\r\n            proto_item_set_generated(rate_ti);\r\n        }\r\n    }\r\n\r\n    col_append_fstr(pinfo->cinfo, COL_INFO,\r\n                    \"   Max-PDU-len=%u  Credits=%u  Interval=%u  Rep-Period=%u\",\r\n                    max_pdu_length, (uint16_t)credits, interval, repetition_period);\r\n\r\n    return offset;\r\n}", ".issect_hsdpa_capacity_allocation_type_2": "static int\r\ndissect_hsdpa_capacity_allocation_type_2(packet_info *pinfo, proto_tree *tree,\r\n                                         tvbuff_t *tvb, int offset)\r\n{\r\n    proto_item *ti;\r\n    proto_item *rate_ti;\r\n    uint16_t    max_pdu_length;\r\n    uint8_t     repetition_period;\r\n    uint8_t     interval;\r\n    uint16_t    credits;\r\n\r\n    /* Congestion status */\r\n    proto_tree_add_bits_item(tree, hf_fp_congestion_status, tvb,\r\n                            offset*8 + 2, 2, ENC_BIG_ENDIAN);\r\n\r\n    /* CmCH-PI */\r\n    proto_tree_add_item(tree, hf_fp_cmch_pi, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n    offset++;\r\n\r\n    /* 5 spare bits follow here */\r\n\r\n    /* Max MAC-d/c PDU length (11 bits) */\r\n    max_pdu_length = tvb_get_ntohs(tvb, offset) & 0x7ff;\r\n    proto_tree_add_item(tree, hf_fp_hsdsch_max_macdc_pdu_len, tvb, offset, 2, ENC_BIG_ENDIAN);\r\n    offset += 2;\r\n\r\n    /* HS-DSCH credits (16 bits) */\r\n    credits = (tvb_get_ntohs(tvb, offset));\r\n    ti = proto_tree_add_uint(tree, hf_fp_hsdsch_credits, tvb,\r\n                             offset, 2, credits);\r\n    offset += 2;\r\n\r\n    /* Interesting values */\r\n    if (credits == 0) {\r\n        proto_item_append_text(ti, \" (stop transmission)\");\r\n        expert_add_info(pinfo, ti, &ei_fp_stop_hsdpa_transmission);\r\n    }\r\n    if (credits == 65535) {\r\n        proto_item_append_text(ti, \" (unlimited)\");\r\n    }\r\n\r\n    /* HS-DSCH Interval */\r\n    interval = tvb_get_uint8(tvb, offset);\r\n    ti = proto_tree_add_uint(tree, hf_fp_hsdsch_interval, tvb, offset, 1, interval*10);\r\n    offset++;\r\n    if (interval == 0) {\r\n        proto_item_append_text(ti, \" (none of the credits shall be used)\");\r\n    }\r\n\r\n    /* HS-DSCH Repetition period */\r\n    repetition_period = tvb_get_uint8(tvb, offset);\r\n    ti = proto_tree_add_item(tree, hf_fp_hsdsch_repetition_period, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n    offset++;\r\n    if (repetition_period == 0) {\r\n        proto_item_append_text(ti, \" (unlimited repetition period)\");\r\n    }\r\n\r\n    /* Calculated and show effective rate enabled */\r\n    if (credits == 65535) {\r\n        rate_ti = proto_tree_add_item(tree, hf_fp_hsdsch_unlimited_rate, tvb, 0, 0, ENC_NA);\r\n        proto_item_set_generated(rate_ti);\r\n    }\r\n    else {\r\n        if (interval != 0) {\r\n            rate_ti = proto_tree_add_uint(tree, hf_fp_hsdsch_calculated_rate, tvb, 0, 0,\r\n                                          credits * max_pdu_length * (1000 / (interval*10)));\r\n            proto_item_set_generated(rate_ti);\r\n        }\r\n    }\r\n\r\n    col_append_fstr(pinfo->cinfo, COL_INFO,\r\n                    \"   Max-PDU-len=%u  Credits=%u  Interval=%u  Rep-Period=%u\",\r\n                    max_pdu_length, credits, interval, repetition_period);\r\n\r\n    return offset;\r\n}", ".issect_common_control": "static void\r\ndissect_common_control(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\r\n                       int offset, struct fp_info *p_fp_info)\r\n{\r\n    /* Common control frame type */\r\n    uint8_t control_frame_type = tvb_get_uint8(tvb, offset);\r\n    proto_tree_add_item(tree, hf_fp_common_control_frame_type, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n    offset++;\r\n\r\n    col_append_str(pinfo->cinfo, COL_INFO,\r\n                   val_to_str_const(control_frame_type, common_control_frame_type_vals, \"Unknown\"));\r\n\r\n    /* Frame-type specific dissection */\r\n    switch (control_frame_type) {\r\n        case COMMON_OUTER_LOOP_POWER_CONTROL:\r\n            /*offset =*/ dissect_common_outer_loop_power_control(pinfo, tree, tvb, offset, p_fp_info);\r\n            break;\r\n        case COMMON_TIMING_ADJUSTMENT:\r\n            /*offset =*/ dissect_common_timing_adjustment(pinfo, tree, tvb, offset, p_fp_info);\r\n            break;\r\n        case COMMON_DL_SYNCHRONISATION:\r\n            /*offset =*/ dissect_common_dl_synchronisation(pinfo, tree, tvb, offset, p_fp_info);\r\n            break;\r\n        case COMMON_UL_SYNCHRONISATION:\r\n            /*offset =*/ dissect_common_ul_synchronisation(pinfo, tree, tvb, offset, p_fp_info);\r\n            break;\r\n        case COMMON_DL_NODE_SYNCHRONISATION:\r\n            /*offset =*/ dissect_common_dl_node_synchronisation(pinfo, tree, tvb, offset);\r\n            break;\r\n        case COMMON_UL_NODE_SYNCHRONISATION:\r\n            /*offset =*/ dissect_common_ul_node_synchronisation(pinfo, tree, tvb, offset);\r\n            break;\r\n        case COMMON_DYNAMIC_PUSCH_ASSIGNMENT:\r\n            /*offset =*/ dissect_common_dynamic_pusch_assignment(pinfo, tree, tvb, offset);\r\n            break;\r\n        case COMMON_TIMING_ADVANCE:\r\n            /*offset =*/ dissect_common_timing_advance(pinfo, tree, tvb, offset);\r\n            break;\r\n        case COMMON_HS_DSCH_Capacity_Request:\r\n            /*offset =*/ dissect_hsdpa_capacity_request(pinfo, tree, tvb, offset);\r\n            break;\r\n        case COMMON_HS_DSCH_Capacity_Allocation:\r\n            /*offset =*/ dissect_hsdpa_capacity_allocation(pinfo, tree, tvb, offset, p_fp_info);\r\n            break;\r\n        case COMMON_HS_DSCH_Capacity_Allocation_Type_2:\r\n            /*offset =*/ dissect_hsdpa_capacity_allocation_type_2(pinfo, tree, tvb, offset);\r\n            break;\r\n\r\n        default:\r\n            break;\r\n    }\r\n\r\n     /* There is no Spare Extension nor payload crc in common control!? */\r\n   /* dissect_spare_extension_and_crc(tvb, pinfo, tree, 0, offset);\r\n    */\r\n}", ".erify_control_frame_crc": "static bool verify_control_frame_crc(tvbuff_t * tvb, packet_info * pinfo, proto_item * pi, uint16_t frame_crc)\r\n{\r\n    uint8_t crc = 0;\r\n    uint8_t * data = NULL;\r\n    /* Get data. */\r\n    data = (uint8_t *)tvb_memdup(pinfo->pool, tvb, 0, tvb_reported_length(tvb));\r\n    /* Include only FT flag bit in CRC calculation. */\r\n    data[0] = data[0] & 1;\r\n    /* Calculate crc7 sum. */\r\n    crc = crc7update(0, data, tvb_reported_length(tvb));\r\n    crc = crc7finalize(crc); /* finalize crc */\r\n    if (frame_crc == crc) {\r\n        proto_item_append_text(pi, \" [correct]\");\r\n        return true;\r\n    } else {\r\n        proto_item_append_text(pi, \" [incorrect, should be 0x%x]\", crc);\r\n        expert_add_info(pinfo, pi, &ei_fp_bad_header_checksum);\r\n        return false;\r\n    }\r\n}", ".issect_tb_data": "static int\r\ndissect_tb_data(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\r\n                int offset, struct fp_info *p_fp_info,\r\n                dissector_handle_t *data_handle, void *data)\r\n{\r\n    int         chan, num_tbs   = 0;\r\n    int         bit_offset      = 0;\r\n    int         crci_bit_offset = (offset+1)<<3; /* Current offset + Quality estimate of 1 byte at the end*/\r\n    unsigned    data_bits       = 0;\r\n    uint8_t     crci_bit        = 0;\r\n    proto_item *tree_ti         = NULL;\r\n    proto_tree *data_tree       = NULL;\r\n    bool        dissected       = false;\r\n\r\n    /* Add data subtree */\r\n    tree_ti =  proto_tree_add_item(tree, hf_fp_data, tvb, offset, -1, ENC_NA);\r\n    proto_item_set_text(tree_ti, \"TB data for %u chans\", p_fp_info->num_chans);\r\n    data_tree = proto_item_add_subtree(tree_ti, ett_fp_data);\r\n\r\n    if (p_fp_info->num_chans >= MAX_MAC_FRAMES) {\r\n        expert_add_info_format(pinfo, data_tree, &ei_fp_invalid_frame_count, \"Invalid Number of channels (max is %u)\", MAX_MAC_FRAMES);\r\n        return offset;\r\n    }\r\n\r\n    /* Calculate offset to CRCI bits */\r\n\r\n    if (p_fp_info->is_uplink) {\r\n        for (chan=0; chan < p_fp_info->num_chans; chan++) {\r\n            int n;\r\n            for (n=0; n < p_fp_info->chan_num_tbs[chan]; n++) {\r\n                /* Advance bit offset */\r\n                crci_bit_offset += p_fp_info->chan_tf_size[chan];\r\n                /* Pad out to next byte */\r\n                crci_bit_offset = WS_ROUNDUP_8(crci_bit_offset);\r\n            }\r\n        }\r\n    }\r\n    /* Now for the TB data */\r\n    for (chan=0; chan < p_fp_info->num_chans; chan++) {\r\n        int n;\r\n        p_fp_info->cur_chan = chan;    /*Set current channel?*/\r\n        /* Clearly show channels with no TBs */\r\n        if (p_fp_info->chan_num_tbs[chan] == 0) {\r\n            proto_item *no_tb_ti = proto_tree_add_uint(data_tree, hf_fp_chan_zero_tbs, tvb,\r\n                                                       offset+(bit_offset/8),\r\n                                                       0, chan+1);\r\n            proto_item_append_text(no_tb_ti, \" (of size %d)\",\r\n                                   p_fp_info->chan_tf_size[chan]);\r\n            proto_item_set_generated(no_tb_ti);\r\n        }\r\n\r\n        /* Show TBs from non-empty channels */\r\n        for (n=0; n < p_fp_info->chan_num_tbs[chan]; n++) {\r\n\r\n            proto_item *ti;\r\n            p_fp_info->cur_tb = chan;    /*Set current transport block?*/\r\n            if (data_tree) {\r\n                ti = proto_tree_add_item(data_tree, hf_fp_tb, tvb,\r\n                                         offset + (bit_offset/8),\r\n                                         ((bit_offset % 8) + p_fp_info->chan_tf_size[chan] + 7) / 8,\r\n                                         ENC_NA);\r\n                proto_item_set_text(ti, \"TB (chan %u, tb %u, %u bits)\",\r\n                                    chan+1, n+1, p_fp_info->chan_tf_size[chan]);\r\n            }\r\n\r\n            if (preferences_call_mac_dissectors && data_handle &&\r\n                (p_fp_info->chan_tf_size[chan] > 0)) {\r\n                tvbuff_t *next_tvb;\r\n                proto_item *item;\r\n                /* If this is DL we should not care about crci bits (since they don't exists)*/\r\n                if (p_fp_info->is_uplink) {\r\n\r\n\r\n                    if ( p_fp_info->channel == CHANNEL_RACH_FDD) {    /*In RACH we don't have any QE field, hence go back 8 bits.*/\r\n                        crci_bit = tvb_get_bits8(tvb, crci_bit_offset+n-8, 1);\r\n                        item = proto_tree_add_item(data_tree, hf_fp_crci[n%8], tvb, (crci_bit_offset+n-8)/8, 1, ENC_BIG_ENDIAN);\r\n                        proto_item_set_generated(item);\r\n                    } else {\r\n                        crci_bit = tvb_get_bits8(tvb, crci_bit_offset+n, 1);\r\n                        item = proto_tree_add_item(data_tree, hf_fp_crci[n%8], tvb, (crci_bit_offset+n)/8, 1, ENC_BIG_ENDIAN);\r\n                        proto_item_set_generated(item);\r\n                    }\r\n                }\r\n\r\n                if (crci_bit == 0 || !p_fp_info->is_uplink) {\r\n                    next_tvb = tvb_new_subset_length(tvb, offset + bit_offset/8,\r\n                                              ((bit_offset % 8) + p_fp_info->chan_tf_size[chan] + 7) / 8);\r\n\r\n\r\n                    /****************/\r\n                    /* TODO: maybe this decision can be based only on info available in fp_info */\r\n                    call_dissector_with_data(*data_handle, next_tvb, pinfo, top_level_tree, data);\r\n                    dissected = true;\r\n                } else {\r\n                    proto_tree_add_expert(tree, pinfo, &ei_fp_crci_no_subdissector, tvb, offset + bit_offset/8,\r\n                                               ((bit_offset % 8) + p_fp_info->chan_tf_size[chan] + 7) / 8);\r\n                }\r\n\r\n            }\r\n            num_tbs++;\r\n\r\n            /* Advance bit offset */\r\n            bit_offset += p_fp_info->chan_tf_size[chan];\r\n            data_bits  += p_fp_info->chan_tf_size[chan];\r\n\r\n            /* Pad out to next byte */\r\n            bit_offset = WS_ROUNDUP_8(bit_offset);\r\n        }\r\n    }\r\n\r\n    if (dissected == false) {\r\n        col_append_fstr(pinfo->cinfo, COL_INFO, \"(%u bits in %u tbs)\",\r\n                        data_bits, num_tbs);\r\n    }\r\n\r\n    /* Data tree should cover entire length */\r\n    if (data_tree) {\r\n        proto_item_set_len(tree_ti, bit_offset/8);\r\n        proto_item_append_text(tree_ti, \" (%u bits in %u tbs)\", data_bits, num_tbs);\r\n    }\r\n\r\n    /* Move offset past TBs (we know it's already padded out to next byte) */\r\n    offset += (bit_offset / 8);\r\n\r\n    return offset;\r\n}", ".issect_crci_bits": "static int\r\ndissect_crci_bits(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\r\n                  fp_info *p_fp_info, int offset)\r\n{\r\n    int         n, num_tbs;\r\n    proto_item *ti         = NULL;\r\n    proto_tree *crcis_tree = NULL;\r\n    unsigned    errors     = 0;\r\n\r\n    num_tbs = get_tb_count(p_fp_info);\r\n\r\n\r\n    /* Add CRCIs subtree */\r\n    if (tree) {\r\n        ti =  proto_tree_add_item(tree, hf_fp_crcis, tvb, offset, (num_tbs+7)/8, ENC_NA);\r\n        proto_item_set_text(ti, \"CRCI bits for %u tbs\", num_tbs);\r\n        crcis_tree = proto_item_add_subtree(ti, ett_fp_crcis);\r\n    }\r\n\r\n    /* CRCIs */\r\n    for (n=0; n < num_tbs; n++) {\r\n        int bit = (tvb_get_uint8(tvb, offset+(n/8)) >> (7-(n%8))) & 0x01;\r\n        proto_tree_add_item(crcis_tree, hf_fp_crci[n%8], tvb, offset+(n/8),\r\n                            1, ENC_BIG_ENDIAN);\r\n\r\n        if (bit == 1) {\r\n            errors++;\r\n            expert_add_info(pinfo, ti, &ei_fp_crci_error_bit_set_for_tb);\r\n        }\r\n    }\r\n\r\n    if (tree) {\r\n        /* Highlight range of bytes covered by indicator bits */\r\n        proto_item_set_len(ti, (num_tbs+7) / 8);\r\n\r\n        /* Show error count in root text */\r\n        proto_item_append_text(ti, \" (%u errors)\", errors);\r\n    }\r\n\r\n    offset += ((num_tbs+7) / 8);\r\n    return offset;\r\n}", ".erify_header_crc": "static bool verify_header_crc(tvbuff_t * tvb, packet_info * pinfo, proto_item * pi, uint16_t header_crc, unsigned header_length)\r\n{\r\n    uint8_t crc = 0;\r\n    uint8_t * data = NULL;\r\n    /* Get data of header with first byte removed. */\r\n    data = (uint8_t *)tvb_memdup(pinfo->pool, tvb, 1, header_length-1);\r\n    /* Calculate crc7 sum. */\r\n    crc = crc7update(0, data, header_length-1);\r\n    crc = crc7finalize(crc); /* finalize crc */\r\n    if (header_crc == crc) {\r\n        proto_item_append_text(pi, \" [correct]\");\r\n        return true;\r\n    } else {\r\n        proto_item_append_text(pi, \" [incorrect, should be 0x%x]\", crc);\r\n        expert_add_info(pinfo, pi, &ei_fp_bad_header_checksum);\r\n        return false;\r\n    }\r\n}", ".issect_spare_extension_and_crc": "static void\r\ndissect_spare_extension_and_crc(tvbuff_t *tvb, packet_info *pinfo,\r\n                                proto_tree *tree, uint8_t dch_crc_present,\r\n                                int offset, unsigned header_length)\r\n{\r\n    int         crc_size = 0;\r\n    int         remain   = tvb_reported_length_remaining(tvb, offset);\r\n\r\n    /* Payload CRC (optional) */\r\n    if ((dch_crc_present == 1) || ((dch_crc_present == 2) && (remain >= 2))) {\r\n        crc_size = 2;\r\n    }\r\n\r\n    if (remain > crc_size) {\r\n        proto_item *ti;\r\n        ti = proto_tree_add_item(tree, hf_fp_spare_extension, tvb,\r\n                                 offset, remain-crc_size, ENC_NA);\r\n        proto_item_append_text(ti, \" (%u octets)\", remain-crc_size);\r\n        expert_add_info_format(pinfo, ti, &ei_fp_spare_extension, \"Spare Extension present (%u bytes)\", remain-crc_size);\r\n        offset += remain-crc_size;\r\n    }\r\n\r\n    if (crc_size) {\r\n        unsigned flags = PROTO_CHECKSUM_NO_FLAGS;\r\n        uint16_t calc_crc = 0;\r\n        if (preferences_payload_checksum) {\r\n            flags = PROTO_CHECKSUM_VERIFY;\r\n            if ((unsigned)offset > header_length) {\r\n                uint8_t * data = (uint8_t *)tvb_memdup(pinfo->pool, tvb, header_length, offset-header_length);\r\n                calc_crc = crc16_8005_noreflect_noxor(data, offset-header_length);\r\n            }\r\n        }\r\n        if ((unsigned)offset == header_length && remain == 0) {\r\n            /* 3GPP TS 25.427 and TS 25.435: \"The Payload CRC IE may\r\n             * only be present if the frame contains payload\" (even\r\n             * if defined as present at the setup of the transport bearer.)\r\n             * If there's room for the CRC and no payload, assume zero,\r\n             * otherwise, assume it's absent.\r\n             */\r\n            flags = PROTO_CHECKSUM_NOT_PRESENT;\r\n        }\r\n        proto_tree_add_checksum(tree, tvb, offset,\r\n                hf_fp_payload_crc, hf_fp_payload_crc_status,\r\n                &ei_fp_bad_payload_checksum, pinfo, calc_crc,\r\n                ENC_BIG_ENDIAN, flags);\r\n    }\r\n}", ".issect_dch_timing_adjustment": "static int\r\ndissect_dch_timing_adjustment(proto_tree *tree, packet_info *pinfo, tvbuff_t *tvb, int offset)\r\n{\r\n    uint32_t    cfn;\r\n    int16_t     toa;\r\n    proto_item *toa_ti;\r\n\r\n    /* CFN control */\r\n    proto_tree_add_item_ret_uint(tree, hf_fp_cfn_control, tvb, offset, 1, ENC_BIG_ENDIAN, &cfn);\r\n    offset++;\r\n\r\n    /* ToA */\r\n    toa = tvb_get_ntohs(tvb, offset);\r\n    toa_ti = proto_tree_add_item(tree, hf_fp_toa, tvb, offset, 2, ENC_BIG_ENDIAN);\r\n    offset += 2;\r\n\r\n    expert_add_info_format(pinfo, toa_ti, &ei_fp_timing_adjustment_reported, \"Timing adjustment reported (%.3f ms)\", ((float)(toa) / 8));\r\n\r\n    col_append_fstr(pinfo->cinfo, COL_INFO,\r\n                    \" CFN = %u, ToA = %d\", cfn, toa);\r\n\r\n    return offset;\r\n}", ".issect_dch_rx_timing_deviation": "static int\r\ndissect_dch_rx_timing_deviation(packet_info *pinfo, proto_tree *tree,\r\n                                tvbuff_t *tvb, int offset,\r\n                                struct fp_info *p_fp_info)\r\n{\r\n    uint16_t    timing_deviation;\r\n    int         timing_deviation_chips;\r\n    proto_item *timing_deviation_ti;\r\n\r\n    /* CFN control */\r\n    proto_tree_add_item(tree, hf_fp_cfn_control, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n    offset++;\r\n\r\n    /* Rx Timing Deviation */\r\n    timing_deviation = tvb_get_uint8(tvb, offset);\r\n    timing_deviation_ti = proto_tree_add_item(tree, hf_fp_dch_rx_timing_deviation, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n    offset++;\r\n\r\n    /* May be extended in R7, but in this case there are at least 2 bytes remaining */\r\n    if ((p_fp_info->release == 7) &&\r\n        (tvb_reported_length_remaining(tvb, offset) >= 2)) {\r\n\r\n        /* New IE flags */\r\n        uint64_t extended_bits_present;\r\n        uint64_t e_rucch_present;\r\n\r\n        /* Read flags */\r\n        proto_tree_add_bits_ret_val(tree, hf_fp_e_rucch_present, tvb,\r\n                                    offset*8 + 6, 1, &e_rucch_present, ENC_BIG_ENDIAN);\r\n        proto_tree_add_bits_ret_val(tree, hf_fp_extended_bits_present, tvb,\r\n                                    offset*8 + 7, 1, &extended_bits_present, ENC_BIG_ENDIAN);\r\n        offset++;\r\n\r\n        /* Optional E-RUCCH */\r\n        if (e_rucch_present) {\r\n\r\n            /* Value of bit_offset depends upon division type */\r\n            int bit_offset;\r\n\r\n            switch (p_fp_info->division) {\r\n                case Division_TDD_384:\r\n                    bit_offset = 6;\r\n                    break;\r\n                case Division_TDD_768:\r\n                    bit_offset = 5;\r\n                    break;\r\n                default:\r\n                    {\r\n                        proto_tree_add_expert(tree, pinfo, &ei_fp_expecting_tdd, tvb, 0, 0);\r\n                        bit_offset = 6;\r\n                    }\r\n            }\r\n\r\n            proto_tree_add_item(tree, hf_fp_dch_e_rucch_flag, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n            proto_tree_add_bits_item(tree, hf_fp_dch_e_rucch_flag, tvb,\r\n                                     offset*8 + bit_offset, 1, ENC_BIG_ENDIAN);\r\n        }\r\n\r\n        /* Timing deviation may be extended by another:\r\n           - 1 bits (3.84 TDD)    OR\r\n           - 2 bits (7.68 TDD)\r\n        */\r\n        if (extended_bits_present) {\r\n            uint8_t extra_bits;\r\n            unsigned bits_to_extend;\r\n            switch (p_fp_info->division) {\r\n                case Division_TDD_384:\r\n                    bits_to_extend = 1;\r\n                    break;\r\n                case Division_TDD_768:\r\n                    bits_to_extend = 2;\r\n                    break;\r\n\r\n                default:\r\n                    /* TODO: report unexpected division type */\r\n                    bits_to_extend = 1;\r\n                    break;\r\n            }\r\n            extra_bits = tvb_get_uint8(tvb, offset) &\r\n                             ((bits_to_extend == 1) ? 0x01 : 0x03);\r\n            timing_deviation = (extra_bits << 8) | (timing_deviation);\r\n            proto_item_append_text(timing_deviation_ti,\r\n                                   \" (extended to 0x%x)\",\r\n                                   timing_deviation);\r\n            proto_tree_add_bits_item(tree, hf_fp_extended_bits, tvb,\r\n                                     offset*8 + (8-bits_to_extend), bits_to_extend, ENC_BIG_ENDIAN);\r\n            offset++;\r\n        }\r\n    }\r\n\r\n    timing_deviation_chips = (timing_deviation*4) - 1024;\r\n    proto_item_append_text(timing_deviation_ti, \" (%d chips)\",\r\n                           timing_deviation_chips);\r\n\r\n    col_append_fstr(pinfo->cinfo, COL_INFO, \" deviation = %u (%d chips)\",\r\n                    timing_deviation, timing_deviation_chips);\r\n\r\n    return offset;\r\n}", ".issect_dch_dl_synchronisation": "static int\r\ndissect_dch_dl_synchronisation(proto_tree *tree, packet_info *pinfo, tvbuff_t *tvb, int offset)\r\n{\r\n    uint32_t cfn;\r\n\r\n    /* CFN control */\r\n    proto_tree_add_item_ret_uint(tree, hf_fp_cfn_control, tvb, offset, 1, ENC_BIG_ENDIAN, &cfn);\r\n    offset++;\r\n\r\n    col_append_fstr(pinfo->cinfo, COL_INFO, \" CFN = %u\", cfn);\r\n\r\n    return offset;\r\n}", ".issect_dch_ul_synchronisation": "static int\r\ndissect_dch_ul_synchronisation(proto_tree *tree, packet_info *pinfo, tvbuff_t *tvb, int offset)\r\n{\r\n    uint32_t cfn;\r\n    int16_t toa;\r\n\r\n    /* CFN control */\r\n    proto_tree_add_item_ret_uint(tree, hf_fp_cfn_control, tvb, offset, 1, ENC_BIG_ENDIAN, &cfn);\r\n    offset++;\r\n\r\n    /* ToA */\r\n    toa = tvb_get_ntohs(tvb, offset);\r\n    proto_tree_add_item(tree, hf_fp_toa, tvb, offset, 2, ENC_BIG_ENDIAN);\r\n    offset += 2;\r\n\r\n    col_append_fstr(pinfo->cinfo, COL_INFO, \" CFN = %u, ToA = %d\",\r\n                    cfn, toa);\r\n\r\n    return offset;\r\n}", ".issect_dch_dl_node_synchronisation": "static int\r\ndissect_dch_dl_node_synchronisation(proto_tree *tree, packet_info *pinfo, tvbuff_t *tvb, int offset)\r\n{\r\n    return dissect_common_dl_node_synchronisation(pinfo, tree, tvb, offset);\r\n}", ".issect_dch_ul_node_synchronisation": "static int\r\ndissect_dch_ul_node_synchronisation(proto_tree *tree, packet_info *pinfo, tvbuff_t *tvb, int offset)\r\n{\r\n    return dissect_common_ul_node_synchronisation(pinfo, tree, tvb, offset);\r\n}", ".issect_dch_radio_interface_parameter_update": "static int\r\ndissect_dch_radio_interface_parameter_update(proto_tree *tree, packet_info *pinfo _U_, tvbuff_t *tvb, int offset)\r\n{\r\n    float tpc_po;\r\n    int8_t max_tx_pwr;\r\n    int    n;\r\n    uint8_t encoded;\r\n\r\n    /* Show defined flags in these 2 bytes */\r\n    for (n=4; n >= 0; n--) {\r\n        proto_tree_add_item(tree, hf_fp_radio_interface_parameter_update_flag[n], tvb, offset, 2, ENC_BIG_ENDIAN);\r\n    }\r\n    offset += 2;\r\n\r\n    /* CFN  */\r\n    proto_tree_add_item(tree, hf_fp_cfn, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n    offset++;\r\n\r\n    /* DPC mode */\r\n    proto_tree_add_item(tree, hf_fp_dpc_mode, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n\r\n    /* TPC PO */\r\n    encoded = tvb_get_uint8(tvb, offset) & 0x1f;\r\n    tpc_po = (float)encoded * 0.25f;\r\n    proto_tree_add_float_format_value(tree, hf_fp_tpc_po, tvb, offset, 1, tpc_po,\r\n                                      \"%.2f dB (%u)\", tpc_po, encoded);\r\n    offset++;\r\n\r\n    /* Multiple RL sets indicator */\r\n    proto_tree_add_item(tree, hf_fp_multiple_rl_set_indicator, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n    offset += 2;\r\n\r\n    /* Maximum UE TX Power */\r\n    encoded = tvb_get_uint8(tvb, offset) & 0x7f;\r\n    max_tx_pwr = -55 + encoded;\r\n    proto_tree_add_int_format(tree, hf_fp_max_ue_tx_pow, tvb, offset, 1, max_tx_pwr,\r\n                              \"%d dBm (%u)\", max_tx_pwr, encoded);\r\n    offset++;\r\n\r\n    return offset;\r\n}", ".issect_dch_timing_advance": "static int\r\ndissect_dch_timing_advance(proto_tree *tree, packet_info *pinfo,\r\n                           tvbuff_t *tvb, int offset, struct fp_info *p_fp_info)\r\n{\r\n    uint32_t    cfn;\r\n    uint16_t    timing_advance;\r\n    proto_item *timing_advance_ti;\r\n\r\n    /* CFN control */\r\n    proto_tree_add_item_ret_uint(tree, hf_fp_cfn_control, tvb, offset, 1, ENC_BIG_ENDIAN, &cfn);\r\n    offset++;\r\n\r\n    /* Timing Advance */\r\n    timing_advance = (tvb_get_uint8(tvb, offset) & 0x3f) * 4;\r\n    timing_advance_ti = proto_tree_add_uint(tree, hf_fp_timing_advance, tvb, offset, 1, timing_advance);\r\n    offset++;\r\n\r\n    if ((p_fp_info->release == 7) &&\r\n        (tvb_reported_length_remaining(tvb, offset) > 0)) {\r\n\r\n        /* New IE flags */\r\n        uint8_t flags = tvb_get_uint8(tvb, offset);\r\n        uint8_t extended_bits = flags & 0x01;\r\n        offset++;\r\n\r\n        if (extended_bits) {\r\n            uint8_t extra_bit = tvb_get_uint8(tvb, offset) & 0x01;\r\n            proto_item_append_text(timing_advance_ti, \" (extended to %u)\",\r\n                                   (timing_advance << 1) | extra_bit);\r\n        }\r\n        offset++;\r\n    }\r\n\r\n    col_append_fstr(pinfo->cinfo, COL_INFO, \" CFN = %u, TA = %u\",\r\n                    cfn, timing_advance);\r\n\r\n    return offset;\r\n}", ".issect_dch_tnl_congestion_indication": "static int\r\ndissect_dch_tnl_congestion_indication(proto_tree *tree, packet_info *pinfo, tvbuff_t *tvb, int offset)\r\n{\r\n    uint64_t status;\r\n\r\n    /* Congestion status */\r\n    proto_tree_add_bits_ret_val(tree, hf_fp_congestion_status, tvb,\r\n                                offset*8 + 6, 2, &status, ENC_BIG_ENDIAN);\r\n    offset++;\r\n\r\n    col_append_fstr(pinfo->cinfo, COL_INFO, \" status = %s\",\r\n                    val_to_str_const((uint16_t)status, congestion_status_vals, \"unknown\"));\r\n\r\n    return offset;\r\n}", ".issect_dch_control_frame": "static void\r\ndissect_dch_control_frame(proto_tree *tree, packet_info *pinfo, tvbuff_t *tvb,\r\n                          int offset, struct fp_info *p_fp_info)\r\n{\r\n    /* Control frame type */\r\n    uint8_t control_frame_type = tvb_get_uint8(tvb, offset);\r\n    proto_tree_add_item(tree, hf_fp_dch_control_frame_type, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n    offset++;\r\n\r\n    col_append_str(pinfo->cinfo, COL_INFO,\r\n                   val_to_str_const(control_frame_type,\r\n                                    dch_control_frame_type_vals, \"Unknown\"));\r\n\r\n    switch (control_frame_type) {\r\n        case DCH_TIMING_ADJUSTMENT:\r\n            /*offset =*/ dissect_dch_timing_adjustment(tree, pinfo, tvb, offset);\r\n            break;\r\n        case DCH_RX_TIMING_DEVIATION:\r\n            /*offset =*/ dissect_dch_rx_timing_deviation(pinfo, tree, tvb, offset, p_fp_info);\r\n            break;\r\n        case DCH_DL_SYNCHRONISATION:\r\n            /*offset =*/ dissect_dch_dl_synchronisation(tree, pinfo, tvb, offset);\r\n            break;\r\n        case DCH_UL_SYNCHRONISATION:\r\n            /*offset =*/ dissect_dch_ul_synchronisation(tree, pinfo, tvb, offset);\r\n            break;\r\n        case DCH_OUTER_LOOP_POWER_CONTROL:\r\n            /*offset =*/ dissect_dch_outer_loop_power_control(tree, pinfo, tvb, offset);\r\n            break;\r\n        case DCH_DL_NODE_SYNCHRONISATION:\r\n            /*offset =*/ dissect_dch_dl_node_synchronisation(tree, pinfo, tvb, offset);\r\n            break;\r\n        case DCH_UL_NODE_SYNCHRONISATION:\r\n            /*offset =*/ dissect_dch_ul_node_synchronisation(tree, pinfo, tvb, offset);\r\n            break;\r\n        case DCH_RADIO_INTERFACE_PARAMETER_UPDATE:\r\n            /*offset =*/ dissect_dch_radio_interface_parameter_update(tree, pinfo, tvb, offset);\r\n            break;\r\n        case DCH_TIMING_ADVANCE:\r\n            /*offset =*/ dissect_dch_timing_advance(tree, pinfo, tvb, offset, p_fp_info);\r\n            break;\r\n        case DCH_TNL_CONGESTION_INDICATION:\r\n            /*offset =*/ dissect_dch_tnl_congestion_indication(tree, pinfo, tvb, offset);\r\n            break;\r\n    }\r\n\r\n    /* Spare Extension */\r\n   /* dissect_spare_extension_and_crc(tvb, pinfo, tree, 0, offset);\r\n    */\r\n}", ".issect_e_dch_t2_or_common_channel_info": "static void\r\ndissect_e_dch_t2_or_common_channel_info(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\r\n                                        int offset, struct fp_info *p_fp_info,\r\n                                        int number_of_subframes,\r\n                                        bool is_common,\r\n                                        uint16_t header_crc,\r\n                                        proto_item * header_crc_pi,\r\n                                        void *data)\r\n{\r\n    int      n;\r\n    int      pdu_no;\r\n    uint64_t total_macis_sdus;\r\n    uint16_t macis_sdus_found = 0;\r\n    /* uint16_t macis_pdus       = 0; */\r\n    bool F                = true; /* We want to continue loop if get E-RNTI indication... */\r\n    int      bit_offset;\r\n    proto_item *subframe_macis_descriptors_ti = NULL;\r\n    static struct edch_t2_subframe_info subframes[16];\r\n    unsigned header_length = 0;\r\n    /* User Buffer size */\r\n    proto_tree_add_bits_item(tree, hf_fp_edch_user_buffer_size, tvb, offset*8,\r\n                             18, ENC_BIG_ENDIAN);\r\n    offset += 2;\r\n\r\n    /* Spare is in-between... */\r\n\r\n    /* Total number of MAC-is SDUs */\r\n    proto_tree_add_bits_ret_val(tree, hf_fp_edch_no_macid_sdus, tvb, offset*8+4,\r\n                                12, &total_macis_sdus, ENC_BIG_ENDIAN);\r\n    offset += 2;\r\n\r\n    if (is_common) {\r\n        /* E-RNTI */\r\n        proto_tree_add_item(tree, hf_fp_edch_e_rnti, tvb, offset, 2, ENC_BIG_ENDIAN);\r\n        offset += 2;\r\n    }\r\n\r\n    bit_offset = offset*8;\r\n    /* EDCH subframe header list */\r\n    for (n=0; n < number_of_subframes; n++) {\r\n        uint64_t   subframe_number;\r\n        uint64_t   no_of_macis_pdus;\r\n        proto_item *subframe_header_ti;\r\n        proto_tree *subframe_header_tree;\r\n\r\n        /* Add subframe header subtree */\r\n        subframe_header_ti = proto_tree_add_string_format(tree, hf_fp_edch_subframe_header, tvb, offset, 0,\r\n                                                          \"\", \"Subframe\");\r\n        subframe_header_tree = proto_item_add_subtree(subframe_header_ti, ett_fp_edch_subframe_header);\r\n\r\n        /* Spare bit */\r\n        bit_offset++;\r\n\r\n        if (!is_common) {\r\n            /* Number of HARQ Retransmissions */\r\n            proto_tree_add_item(subframe_header_tree, hf_fp_edch_harq_retransmissions, tvb,\r\n                                bit_offset/8, 1, ENC_BIG_ENDIAN);\r\n            bit_offset += 4;\r\n        }\r\n\r\n        /* Subframe number */\r\n        proto_tree_add_bits_ret_val(subframe_header_tree, hf_fp_edch_subframe_number, tvb,\r\n                                    bit_offset, 3, &subframe_number, ENC_BIG_ENDIAN);\r\n        subframes[n].subframe_number = (uint8_t)subframe_number;\r\n        bit_offset += 3;\r\n\r\n        /* Number of MAC-is PDUs */\r\n        proto_tree_add_bits_ret_val(subframe_header_tree, hf_fp_edch_number_of_mac_is_pdus, tvb,\r\n                                    bit_offset, 4, &no_of_macis_pdus, ENC_BIG_ENDIAN);\r\n        bit_offset += 4;\r\n        subframes[n].number_of_mac_is_pdus = (uint8_t)no_of_macis_pdus;\r\n        /* macis_pdus += subframes[n].number_of_mac_is_pdus; */\r\n\r\n        /* Next 4 bits are spare for T2*/\r\n        if (!is_common) {\r\n            bit_offset += 4;\r\n        }\r\n\r\n        /* Show summary in root */\r\n        proto_item_append_text(subframe_header_ti, \" (SFN %u, %u MAC-is PDUs)\",\r\n                               subframes[n].subframe_number, subframes[n].number_of_mac_is_pdus);\r\n        proto_item_set_len(subframe_header_ti, is_common ? 1 : 2);\r\n    }\r\n    offset = bit_offset / 8;\r\n\r\n\r\n    /* MAC-is PDU descriptors for each subframe follow */\r\n    for (n=0; n < number_of_subframes; n++) {\r\n        proto_tree *subframe_macis_descriptors_tree;\r\n\r\n        /* Add subframe header subtree */\r\n        subframe_macis_descriptors_ti = proto_tree_add_string_format(tree, hf_fp_edch_macis_descriptors, tvb, offset, 0,\r\n                                                                     \"\", \"MAC-is descriptors (SFN %u)\", subframes[n].subframe_number);\r\n        proto_item_set_len(subframe_macis_descriptors_ti, subframes[n].number_of_mac_is_pdus*2);\r\n        subframe_macis_descriptors_tree = proto_item_add_subtree(subframe_macis_descriptors_ti,\r\n                                                                 ett_fp_edch_macis_descriptors);\r\n\r\n        /* Find a sequence of descriptors for each MAC-is PDU in this subframe */\r\n        for (pdu_no=0; pdu_no < subframes[n].number_of_mac_is_pdus; pdu_no++) {\r\n            proto_item *f_ti = NULL;\r\n\r\n            subframes[n].number_of_mac_is_sdus[pdu_no] = 0;\r\n\r\n            do {\r\n                /* Check we haven't gone past the limit */\r\n                if (macis_sdus_found++ > total_macis_sdus) {\r\n                    expert_add_info_format(pinfo, f_ti, &ei_fp_mac_is_sdus_miscount, \"Found too many (%u) MAC-is SDUs - header said there were %u\", macis_sdus_found, (uint16_t)total_macis_sdus);\r\n                }\r\n\r\n                /* LCH-ID */\r\n                subframes[n].mac_is_lchid[pdu_no][subframes[n].number_of_mac_is_sdus[pdu_no]] = (tvb_get_uint8(tvb, offset) & 0xf0) >> 4;\r\n                proto_tree_add_item(subframe_macis_descriptors_tree, hf_fp_edch_macis_lchid, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n                if (subframes[n].mac_is_lchid[pdu_no][subframes[n].number_of_mac_is_sdus[pdu_no]] == 15) {\r\n                    proto_item *ti;\r\n\r\n                    /* 4 bits of spare */\r\n                    offset++;\r\n\r\n                    /* E-RNTI */\r\n                    ti = proto_tree_add_item(tree, hf_fp_edch_e_rnti, tvb, offset, 2, ENC_BIG_ENDIAN);\r\n                    offset += 2;\r\n\r\n                    /* This is only allowed if:\r\n                       - it's the common case AND\r\n                       - it's the first descriptor */\r\n                    if (!is_common) {\r\n                        expert_add_info(pinfo, ti, &ei_fp_e_rnti_t2_edch_frames);\r\n                    }\r\n                    if (subframes[n].number_of_mac_is_sdus[pdu_no] > 0) {\r\n                        expert_add_info(pinfo, ti, &ei_fp_e_rnti_first_entry);\r\n                    }\r\n                    continue;\r\n                }\r\n\r\n                /* Length */\r\n                subframes[n].mac_is_length[pdu_no][subframes[n].number_of_mac_is_sdus[pdu_no]] = (tvb_get_ntohs(tvb, offset) & 0x0ffe) >> 1;\r\n                proto_tree_add_item(subframe_macis_descriptors_tree, hf_fp_edch_macis_length, tvb, offset, 2, ENC_BIG_ENDIAN);\r\n                offset++;\r\n\r\n                /* Flag */\r\n                F = tvb_get_uint8(tvb, offset) & 0x01;\r\n                f_ti = proto_tree_add_item(subframe_macis_descriptors_tree, hf_fp_edch_macis_flag, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n\r\n                subframes[n].number_of_mac_is_sdus[pdu_no]++;\r\n\r\n                offset++;\r\n            } while (F == 0);\r\n        }\r\n    }\r\n\r\n    /* Check overall count of MAC-is SDUs */\r\n    if (macis_sdus_found != total_macis_sdus) {\r\n        expert_add_info_format(pinfo, subframe_macis_descriptors_ti, &ei_fp_mac_is_sdus_miscount, \"Frame contains %u MAC-is SDUs - header said there would be %u!\", macis_sdus_found, (uint16_t)total_macis_sdus);\r\n    }\r\n    header_length = offset;\r\n    /* Now PDUs */\r\n    for (n=0; n < number_of_subframes; n++) {\r\n\r\n        /* MAC-is PDU */\r\n        for (pdu_no=0; pdu_no < subframes[n].number_of_mac_is_pdus; pdu_no++) {\r\n            int i;\r\n            unsigned length = 0;\r\n            umts_mac_is_info * mac_is_info = wmem_new(wmem_file_scope(), umts_mac_is_info);\r\n\r\n            mac_is_info->number_of_mac_is_sdus = subframes[n].number_of_mac_is_sdus[pdu_no];\r\n            DISSECTOR_ASSERT(subframes[n].number_of_mac_is_sdus[pdu_no] <= MAX_MAC_FRAMES);\r\n            for (i = 0; i < subframes[n].number_of_mac_is_sdus[pdu_no]; i++) {\r\n                mac_is_info->sdulength[i] = subframes[n].mac_is_length[pdu_no][i];\r\n                mac_is_info->lchid[i] = subframes[n].mac_is_lchid[pdu_no][i];\r\n                length += subframes[n].mac_is_length[pdu_no][i];\r\n            }\r\n\r\n            /* Call MAC for this PDU if configured to */\r\n            if (preferences_call_mac_dissectors) {\r\n                p_add_proto_data(wmem_file_scope(), pinfo, proto_umts_mac, 0, mac_is_info);\r\n                call_dissector_with_data(mac_fdd_edch_type2_handle, tvb_new_subset_remaining(tvb, offset), pinfo, top_level_tree, data);\r\n            }\r\n            else {\r\n                /* Still show data if not decoding as MAC PDU */\r\n                proto_tree_add_item(tree, hf_fp_edch_mac_is_pdu, tvb, offset, length, ENC_NA);\r\n            }\r\n\r\n            /* get_mac_tsn_size in packet-umts_mac.h, gets the global_mac_tsn_size preference in umts_mac.c */\r\n            if (get_mac_tsn_size() == MAC_TSN_14BITS) {\r\n                offset += length + 2; /* Plus 2 bytes for TSN 14 bits and SS 2 bit. */\r\n            } else {\r\n                offset += length + 1; /* Plus 1 byte for TSN 6 bits and SS 2 bit. */\r\n            }\r\n        }\r\n    }\r\n    if (preferences_header_checksum) {\r\n        verify_header_crc_edch(tvb, pinfo, header_crc_pi, header_crc, header_length);\r\n    }\r\n    /* Spare extension and payload CRC (optional) */\r\n    dissect_spare_extension_and_crc(tvb, pinfo, tree,\r\n                                    p_fp_info->dch_crc_present, offset, header_length);\r\n}", ".erify_header_crc_edch": "static bool verify_header_crc_edch(tvbuff_t * tvb, packet_info * pinfo, proto_item * pi, uint16_t header_crc, unsigned header_length)\r\n{\r\n    uint16_t crc = 0;\r\n    uint8_t * data = NULL;\r\n    /* First create new subset of header with first byte removed. */\r\n    tvbuff_t * headtvb = tvb_new_subset_length(tvb, 1, header_length-1);\r\n    /* Get data of header with first byte removed. */\r\n    data = (uint8_t *)tvb_memdup(pinfo->pool, headtvb, 0, header_length-1);\r\n    /* Remove first 4 bits of the remaining data which are Header CRC cont. */\r\n    data[0] = data[0] & 0x0f;\r\n    crc = crc11_307_noreflect_noxor(data, header_length-1);\r\n    if (header_crc == crc) {\r\n        proto_item_append_text(pi, \" [correct]\");\r\n        return true;\r\n    } else {\r\n        proto_item_append_text(pi, \" [incorrect, should be 0x%x]\", crc);\r\n        expert_add_info(pinfo, pi, &ei_fp_bad_header_checksum);\r\n        return false;\r\n    }\r\n}", ".issect_macd_pdu_data": "static int\r\ndissect_macd_pdu_data(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\r\n                      int offset, uint16_t length, uint16_t number_of_pdus,\r\n                      struct fp_info *p_fp_info, void *data)\r\n{\r\n    int         pdu;\r\n    int         bit_offset = 0;\r\n    proto_item *pdus_ti    = NULL;\r\n    proto_tree *data_tree  = NULL;\r\n    bool        dissected  = false;\r\n\r\n    /* Add data subtree */\r\n    pdus_ti =  proto_tree_add_item(tree, hf_fp_data, tvb, offset, -1, ENC_NA);\r\n    proto_item_set_text(pdus_ti, \"%u MAC-d PDUs of %u bits\", number_of_pdus, length);\r\n    data_tree = proto_item_add_subtree(pdus_ti, ett_fp_data);\r\n    if (number_of_pdus >= MAX_MAC_FRAMES) {\r\n        expert_add_info_format(pinfo, data_tree, &ei_fp_invalid_frame_count, \"Invalid number_of_pdus (max is %u)\", MAX_MAC_FRAMES);\r\n        return offset;\r\n    }\r\n\r\n    /* Now for the PDUs */\r\n    for (pdu=0; pdu < number_of_pdus; pdu++) {\r\n        proto_item *pdu_ti;\r\n\r\n        if (data_tree) {\r\n            /* Show 4 bits padding at start of PDU */\r\n            proto_tree_add_item(data_tree, hf_fp_hsdsch_data_padding, tvb, offset+(bit_offset/8), 1, ENC_BIG_ENDIAN);\r\n\r\n        }\r\n        bit_offset += 4;\r\n\r\n        /* Data bytes! */\r\n        if (data_tree) {\r\n            pdu_ti = proto_tree_add_item(data_tree, hf_fp_mac_d_pdu, tvb,\r\n                                         offset + (bit_offset/8),\r\n                                         ((bit_offset % 8) + length + 7) / 8,\r\n                                         ENC_NA);\r\n            proto_item_set_text(pdu_ti, \"MAC-d PDU (PDU %u)\", pdu+1);\r\n        }\r\n\r\n        p_fp_info->cur_tb = pdu;    /*Set TB (PDU) index correctly*/\r\n        if (preferences_call_mac_dissectors) {\r\n            tvbuff_t *next_tvb;\r\n            next_tvb = tvb_new_subset_length_caplen(tvb, offset + bit_offset/8,\r\n                                      ((bit_offset % 8) + length + 7)/8, -1);\r\n            call_dissector_with_data(mac_fdd_hsdsch_handle, next_tvb, pinfo, top_level_tree, data);\r\n            dissected = true;\r\n        }\r\n\r\n        /* Advance bit offset */\r\n        bit_offset += length;\r\n\r\n        /* Pad out to next byte */\r\n        bit_offset = WS_ROUNDUP_8(bit_offset);\r\n    }\r\n\r\n    /* Data tree should cover entire length */\r\n    proto_item_set_len(pdus_ti, bit_offset/8);\r\n\r\n    /* Move offset past PDUs (we know it's already padded out to next byte) */\r\n    offset += (bit_offset / 8);\r\n\r\n    /* Show summary in info column */\r\n    if (dissected == false) {\r\n        col_append_fstr(pinfo->cinfo, COL_INFO, \"   %u PDUs of %u bits\",\r\n                        number_of_pdus, length);\r\n    }\r\n\r\n    return offset;\r\n}", ".issect_macd_pdu_data_type_2": "static int\r\ndissect_macd_pdu_data_type_2(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\r\n                             int offset, uint16_t length, uint16_t number_of_pdus,\r\n                             struct fp_info *fpi, void *data)\r\n{\r\n    int         pdu;\r\n    proto_item *pdus_ti      = NULL;\r\n    proto_tree *data_tree    = NULL;\r\n    int         first_offset = offset;\r\n    bool        dissected    = false;\r\n\r\n    /* Add data subtree */\r\n    pdus_ti =  proto_tree_add_item(tree, hf_fp_data, tvb, offset, -1, ENC_NA);\r\n    proto_item_set_text(pdus_ti, \"%u MAC-d PDUs of %u bytes\", number_of_pdus, length);\r\n    data_tree = proto_item_add_subtree(pdus_ti, ett_fp_data);\r\n\r\n    if (number_of_pdus >= MAX_MAC_FRAMES) {\r\n        expert_add_info_format(pinfo, data_tree, &ei_fp_invalid_frame_count, \"Invalid number_of_pdus (max is %u)\", MAX_MAC_FRAMES);\r\n        return offset;\r\n    }\r\n\r\n    /* Now for the PDUs */\r\n    for (pdu=0; pdu < number_of_pdus; pdu++) {\r\n        proto_item *pdu_ti;\r\n\r\n        /* Data bytes! */\r\n        if (data_tree) {\r\n            pdu_ti = proto_tree_add_item(data_tree, hf_fp_mac_d_pdu, tvb,\r\n                                         offset, length, ENC_NA);\r\n            proto_item_set_text(pdu_ti, \"MAC-d PDU (PDU %u)\", pdu+1);\r\n\r\n        }\r\n\r\n        if (preferences_call_mac_dissectors) {\r\n\r\n            tvbuff_t *next_tvb = tvb_new_subset_length(tvb, offset, length);\r\n\r\n            fpi->cur_tb = pdu;    /*Set proper pdu index for MAC and higher layers*/\r\n            call_dissector_with_data(mac_fdd_hsdsch_handle, next_tvb, pinfo, top_level_tree, data);\r\n            dissected = true;\r\n        }\r\n\r\n        /* Advance offset */\r\n        offset += length;\r\n    }\r\n\r\n    /* Data tree should cover entire length */\r\n    proto_item_set_len(pdus_ti, offset-first_offset);\r\n\r\n    /* Show summary in info column */\r\n    if (!dissected) {\r\n        col_append_fstr(pinfo->cinfo, COL_INFO, \"   %u PDUs of %u bits\",\r\n                        number_of_pdus, length*8);\r\n    }\r\n\r\n    return offset;\r\n}", ".enerate_ue_id_for_heur": "static uint32_t\r\ngenerate_ue_id_for_heur(packet_info *pinfo)\r\n{\r\n    if (pinfo->ptype == PT_UDP &&  pinfo->src.type == AT_IPv4 &&  pinfo->dst.type == AT_IPv4) {\r\n        /* This logic assumes FP is delivered over IP/UDP*/\r\n        /* Will return the same ID even if the address and ports are reversed */\r\n\r\n        /* srcXor: [ ------- Source Address ------- ] (4 bytes)*/\r\n        /*                         XOR                         */\r\n        /*         [  Source Port  ][  Source Port  ] (4 bytes)*/\r\n        int srcXor = pntohu32(pinfo->src.data) ^ ((pinfo->srcport << 16) | (pinfo->srcport));\r\n\r\n        /* dstXor: [ ---- Destination  Address ---- ] (4 bytes)*/\r\n        /*                         XOR                         */\r\n        /*         [ - Dest Port - ][ - Dest Port - ] (4 bytes)*/\r\n        int dstXor = pntohu32(pinfo->dst.data) ^ ((pinfo->destport << 16) | (pinfo->destport));\r\n        return srcXor ^ dstXor;\r\n    }\r\n    else {\r\n        /* Fallback - When IP and/or UDP are missing for whatever reason */\r\n        /* Using the frame number of the first heuristicly dissected frame as the UE ID should be unique enough */\r\n        /* The bitwise NOT operator is used to prevent low UE ID values which are likely to collide */\r\n        /* with legitimate UE IDs derived from C-RNTIs in FACH/RACH */\r\n        return ~(pinfo->num);\r\n    }\r\n}", ".issect_fp": "static int\r\ndissect_fp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)\r\n{\r\n    return dissect_fp_common(tvb, pinfo, tree, NULL);\r\n}", ".heck_header_crc_for_heur": "static bool\r\ncheck_header_crc_for_heur(tvbuff_t *tvb, uint16_t header_length)\r\n{\r\n    uint8_t crc = 0;\r\n    uint8_t calc_crc = 0;\r\n    const uint8_t * data = NULL;\r\n\r\n    if (header_length > tvb_captured_length(tvb))\r\n        return false;\r\n\r\n    crc = tvb_get_uint8(tvb, 0) >> 1;\r\n    /* Get data of header excluding the first byte */\r\n    data = tvb_get_ptr(tvb, 1, header_length - 1);\r\n\r\n    calc_crc = crc7update(0, data, header_length - 1);\r\n    calc_crc = crc7finalize(calc_crc);\r\n\r\n    return calc_crc == crc;\r\n}", ".heck_payload_crc_for_heur": "static bool\r\ncheck_payload_crc_for_heur(tvbuff_t *tvb, uint16_t header_length)\r\n{\r\n    uint16_t reported_length;\r\n    uint16_t crc_index;\r\n    uint16_t crc = 0;\r\n    uint16_t calc_crc = 0;\r\n    uint16_t payload_index;\r\n    uint16_t payload_length;\r\n    const uint8_t *data = NULL;\r\n\r\n    reported_length = tvb_reported_length(tvb);\r\n    if (reported_length < 2 || reported_length > tvb_captured_length(tvb)) {\r\n        return false;\r\n    }\r\n    /* Payload CRC is in the last 2 bytes of the packet */\r\n    crc_index = reported_length - 2;\r\n    crc = tvb_get_bits16(tvb, crc_index * 8, 16, ENC_BIG_ENDIAN);\r\n\r\n    payload_index = header_length; /* payload first index is the same as the header length */\r\n    payload_length = (reported_length - payload_index) - 2;\r\n    data = tvb_get_ptr(tvb, payload_index, payload_length);\r\n    calc_crc = crc16_8005_noreflect_noxor(data, payload_length);\r\n\r\n    return calc_crc == crc;\r\n}", ".et_both_sides_umts_fp_conv_data": "static void\r\nset_both_sides_umts_fp_conv_data(packet_info *pinfo, umts_fp_conversation_info_t *umts_fp_conversation_info)\r\n{\r\n    conversation_t   *packet_direction_conv;\r\n    conversation_t   *other_direction_conv;\r\n\r\n    if (pinfo == NULL) {\r\n        return;\r\n    }\r\n\r\n    /* Finding or creating conversation for the way the packet is heading */\r\n    packet_direction_conv = (conversation_t *)find_conversation(pinfo->num, &pinfo->net_dst, &pinfo->net_src,\r\n        conversation_pt_to_conversation_type(pinfo->ptype),\r\n        pinfo->destport, pinfo->srcport, NO_ADDR_B);\r\n\r\n    if (packet_direction_conv == NULL) {\r\n        /* Conversation does not exist yet, creating one now. */\r\n        packet_direction_conv = conversation_new(pinfo->num, &pinfo->net_dst, &pinfo->net_src,\r\n            conversation_pt_to_conversation_type(pinfo->ptype),\r\n            pinfo->destport, pinfo->srcport, NO_ADDR2);\r\n    }\r\n    conversation_add_proto_data(packet_direction_conv, proto_fp, umts_fp_conversation_info);\r\n\r\n    /* Finding or creating conversation for the other side */\r\n    other_direction_conv = (conversation_t *)find_conversation(pinfo->num, &pinfo->net_src, &pinfo->net_dst,\r\n        conversation_pt_to_conversation_type(pinfo->ptype),\r\n        pinfo->srcport, pinfo->destport, NO_ADDR_B);\r\n\r\n    if (other_direction_conv == NULL) {\r\n        /* Conversation does not exist yet, creating one now. */\r\n        other_direction_conv = conversation_new(pinfo->num, &pinfo->net_src, &pinfo->net_dst,\r\n            conversation_pt_to_conversation_type(pinfo->ptype),\r\n            pinfo->srcport, pinfo->destport, NO_ADDR2);\r\n    }\r\n    conversation_add_proto_data(other_direction_conv, proto_fp, umts_fp_conversation_info);\r\n\r\n}", ".ill_pch_conversation_info_for_heur": "static void\r\nfill_pch_conversation_info_for_heur(umts_fp_conversation_info_t* umts_fp_conversation_info ,packet_info *pinfo)\r\n{\r\n    umts_fp_conversation_info->iface_type = IuB_Interface;\r\n    umts_fp_conversation_info->division = Division_FDD;\r\n    umts_fp_conversation_info->dl_frame_number = pinfo->num;\r\n    umts_fp_conversation_info->ul_frame_number = pinfo->num;\r\n    umts_fp_conversation_info->dch_crc_present = 1;\r\n    umts_fp_conversation_info->com_context_id = generate_ue_id_for_heur(pinfo);\r\n    umts_fp_conversation_info->rlc_mode = FP_RLC_AM;\r\n    copy_address_wmem(wmem_file_scope(), &(umts_fp_conversation_info->crnc_address), &pinfo->src);\r\n    umts_fp_conversation_info->crnc_port = pinfo->srcport;\r\n    umts_fp_conversation_info->channel = CHANNEL_PCH;\r\n    umts_fp_conversation_info->num_dch_in_flow = 1;\r\n    umts_fp_conversation_info->fp_dch_channel_info[0].num_dl_chans = 1;\r\n    umts_fp_conversation_info->fp_dch_channel_info[0].dl_chan_num_tbs[1] = 1;\r\n    umts_fp_conversation_info->channel_specific_info = (void*)wmem_new0(wmem_file_scope(), fp_pch_channel_info_t);\r\n}", ".heck_edch_header_crc_for_heur": "static bool\r\ncheck_edch_header_crc_for_heur(wmem_allocator_t* allocator, tvbuff_t *tvb, uint16_t header_length)\r\n{\r\n    uint16_t crc = 0;\r\n    uint16_t calc_crc = 0;\r\n    uint8_t * data = NULL;\r\n\r\n    if (header_length > tvb_captured_length(tvb))\r\n        return false;\r\n\r\n    crc = (tvb_get_bits8(tvb, 0, 7) << 4) + tvb_get_bits8(tvb, 8, 4);\r\n    /* Get data of header excluding the first byte */\r\n    data = (uint8_t *)tvb_memdup(allocator, tvb, 1, header_length-1);\r\n    /*Zero the part in the second byte which contains part of the CRC*/\r\n    data[0] = data[0] & 0x0f;\r\n\r\n    calc_crc = crc11_307_noreflect_noxor(data, header_length-1);\r\n\r\n    return calc_crc == crc;\r\n}", ".heck_control_frame_crc_for_heur": "static bool\r\ncheck_control_frame_crc_for_heur(wmem_allocator_t* allocator, tvbuff_t * tvb)\r\n{\r\n    uint8_t crc = 0;\r\n    uint8_t calc_crc = 0;\r\n    uint8_t * data = NULL;\r\n    unsigned  reported_length = tvb_reported_length(tvb);\r\n\r\n    if (reported_length == 0 || reported_length > tvb_captured_length(tvb))\r\n        return false;\r\n\r\n    crc = tvb_get_uint8(tvb, 0) >> 1;\r\n    /* Get data. */\r\n    data = (uint8_t *)tvb_memdup(allocator, tvb, 0, tvb_reported_length(tvb));\r\n    /* Include only FT flag bit in CRC calculation. */\r\n    data[0] = data[0] & 1;\r\n    calc_crc = crc7update(0, data, tvb_reported_length(tvb));\r\n    calc_crc = crc7finalize(calc_crc);\r\n\r\n    return calc_crc == crc;\r\n}", ".eur_dissect_fp_dcch_over_dch": "static bool\r\nheur_dissect_fp_dcch_over_dch(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)\r\n{\r\n    conversation_t   *p_conv;\r\n    umts_fp_conversation_info_t* umts_fp_conversation_info = NULL;\r\n    struct fp_info *p_fp_info;\r\n    uint32_t captured_length;\r\n    uint32_t reported_length;\r\n    uint8_t frame_type;\r\n    uint8_t tfi;\r\n    uint8_t pch_collisions_byte;\r\n\r\n    /* Trying to find existing conversation */\r\n    p_conv = (conversation_t *)find_conversation(pinfo->num, &pinfo->net_dst, &pinfo->net_src,\r\n        conversation_pt_to_conversation_type(pinfo->ptype),\r\n        pinfo->destport, pinfo->srcport, NO_ADDR_B);\r\n\r\n    if (p_conv != NULL) {\r\n        /* Checking if the conversation was already framed */\r\n        umts_fp_conversation_info = (umts_fp_conversation_info_t *)conversation_get_proto_data(p_conv, proto_fp);\r\n        if (umts_fp_conversation_info) {\r\n            if (umts_fp_conversation_info->channel == CHANNEL_DCH) {\r\n                conversation_set_dissector(p_conv, fp_handle);\r\n                dissect_fp(tvb, pinfo, tree, data);\r\n                return true;\r\n            }\r\n            else if (umts_fp_conversation_info->channel != CHANNEL_UNKNOWN){\r\n                /* This conversation was successfully framed as ANOTHER type */\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /* Making sure FP info isn't already attached */\r\n    p_fp_info = (fp_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_fp, 0);\r\n    if (p_fp_info) {\r\n        return false;\r\n    }\r\n\r\n    frame_type = tvb_get_uint8(tvb, 0) & 0x01;\r\n    if (frame_type == 1) { /* is 'control' frame type*/\r\n        return false;\r\n    }\r\n\r\n    /* Making sure we have at least enough bytes for header (3) + footer (2) */\r\n    captured_length = tvb_captured_length(tvb);\r\n    if (captured_length < 5) {\r\n        return false;\r\n    }\r\n    reported_length = tvb_reported_length(tvb);\r\n\r\n    tfi = tvb_get_uint8(tvb, 2) & 0x1f;\r\n\r\n    /* Checking if this is a DCH frame with 0 TBs*/\r\n    if (tfi == 0x00)\r\n    {\r\n        if (reported_length != 5 /* DL */ && reported_length != 7 /* UL */) {\r\n            return false;\r\n        }\r\n        if (!check_header_crc_for_heur(tvb, 3)) {\r\n            return false;\r\n        }\r\n        if (!check_payload_crc_for_heur(tvb, 3)) {\r\n            return false;\r\n        }\r\n        /* All checks passed - This is an unknown DCH FP frame. */\r\n        /* To allow dissection of this frame after umts_fp_conversation_info will be added in a later frame */\r\n        /* the conversation must be created here if it doesn't exist yet*/\r\n        if (p_conv == NULL) {\r\n            conversation_new(pinfo->num, &pinfo->net_dst, &pinfo->net_src,\r\n                conversation_pt_to_conversation_type(pinfo->ptype),\r\n                pinfo->destport, pinfo->srcport, NO_ADDR2);\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /* Checking this is a DCH frame with 1 TB */\r\n    if (tfi != 0x01) {\r\n        return false;\r\n    }\r\n\r\n    /* Expecting specific lengths: 24 for downlink frames, 26 for uplink frames */\r\n    /* This is the common Transport Format of DCCH over DCH ( See 3GPP TR 25.944 / 4.1.1.3.1.1 ) */\r\n    if (reported_length != 24 /* DL */ && reported_length != 26 /* UL */) {\r\n        return false;\r\n    }\r\n\r\n    if (!check_header_crc_for_heur(tvb, 3)) {\r\n        return false;\r\n    }\r\n    if (!check_payload_crc_for_heur(tvb, 3)) {\r\n        return false;\r\n    }\r\n\r\n    /* Checking if the 4th byte in the frame is zeroed. In this case the CRC checks aren't */\r\n    /* deterministic enough to guarantee this is a DCH since this packet could also be a PCH frame */\r\n    /* with PI Bitmap of 18 bytes + 0 TBs (Both CRCs will match for both formats) */\r\n    pch_collisions_byte = tvb_get_uint8(tvb, 3);\r\n    if (pch_collisions_byte == 0) {\r\n        return false;\r\n    }\r\n\r\n    if(!umts_fp_conversation_info) {\r\n        umts_fp_conversation_info = wmem_new0(wmem_file_scope(), umts_fp_conversation_info_t);\r\n        set_both_sides_umts_fp_conv_data(pinfo, umts_fp_conversation_info);\r\n    }\r\n    umts_fp_conversation_info->iface_type = IuB_Interface;\r\n    umts_fp_conversation_info->division = Division_FDD;\r\n    umts_fp_conversation_info->dl_frame_number = pinfo->num;\r\n    umts_fp_conversation_info->ul_frame_number = pinfo->num;\r\n    umts_fp_conversation_info->dch_crc_present = 1;\r\n    umts_fp_conversation_info->com_context_id = generate_ue_id_for_heur(pinfo);\r\n    umts_fp_conversation_info->rlc_mode = FP_RLC_AM;\r\n    if (reported_length == 24) { /* Downlink */\r\n        copy_address_wmem(wmem_file_scope(), &(umts_fp_conversation_info->crnc_address), &pinfo->src);\r\n        umts_fp_conversation_info->crnc_port = pinfo->srcport;\r\n    }\r\n    else { /* Uplink*/\r\n        copy_address_wmem(wmem_file_scope(), &(umts_fp_conversation_info->crnc_address), &pinfo->dst);\r\n        umts_fp_conversation_info->crnc_port = pinfo->destport;\r\n    }\r\n    umts_fp_conversation_info->channel = CHANNEL_DCH;\r\n    umts_fp_conversation_info->num_dch_in_flow = 1;\r\n    umts_fp_conversation_info->dch_ids_in_flow_list[0] = 31;\r\n    umts_fp_conversation_info->fp_dch_channel_info[0].num_dl_chans = 1;\r\n    umts_fp_conversation_info->fp_dch_channel_info[0].dl_chan_num_tbs[1] = 1;\r\n    umts_fp_conversation_info->fp_dch_channel_info[0].dl_chan_tf_size[1] = 148;\r\n    umts_fp_conversation_info->fp_dch_channel_info[0].num_ul_chans = 1;\r\n    umts_fp_conversation_info->fp_dch_channel_info[0].ul_chan_num_tbs[1] = 1;\r\n    umts_fp_conversation_info->fp_dch_channel_info[0].ul_chan_tf_size[1] = 148;\r\n    conversation_set_dissector(find_or_create_conversation(pinfo), fp_handle);\r\n    dissect_fp(tvb, pinfo, tree, data);\r\n    return true;\r\n}", ".eur_dissect_fp_fach1": "static bool\r\nheur_dissect_fp_fach1(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)\r\n{\r\n    conversation_t   *p_conv;\r\n    fp_fach_channel_info_t* fp_fach_channel_info;\r\n    umts_fp_conversation_info_t* umts_fp_conversation_info = NULL;\r\n    struct fp_info *p_fp_info;\r\n    uint32_t captured_length;\r\n    uint32_t reported_length;\r\n    uint8_t frame_type;\r\n    uint8_t tfi;\r\n    uint8_t tctf;\r\n\r\n    /* Finding or creating conversation */\r\n    p_conv = (conversation_t *)find_conversation(pinfo->num, &pinfo->net_dst, &pinfo->net_src,\r\n        conversation_pt_to_conversation_type(pinfo->ptype),\r\n        pinfo->destport, pinfo->srcport, NO_ADDR_B);\r\n\r\n    if (p_conv != NULL) {\r\n        /* Checking if the conversation was already framed */\r\n        umts_fp_conversation_info = (umts_fp_conversation_info_t *)conversation_get_proto_data(p_conv, proto_fp);\r\n        if (umts_fp_conversation_info) {\r\n            if (umts_fp_conversation_info->channel == CHANNEL_FACH_FDD) {\r\n                conversation_set_dissector(p_conv, fp_handle);\r\n                dissect_fp(tvb, pinfo, tree, data);\r\n                return true;\r\n            }\r\n            else if (umts_fp_conversation_info->channel != CHANNEL_UNKNOWN){\r\n                /* This conversation was successfully framed as ANOTHER type */\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    /* Making sure we have at least enough bytes for header (4) + footer (2) */\r\n    captured_length = tvb_captured_length(tvb);\r\n    if(captured_length < 6) {\r\n        return false;\r\n    }\r\n\r\n    /* Expecting specific lengths: 51 for frames with 1 TB */\r\n    /* This is a common Transport Format of FACH ( See 3GPP TR 25.944 / 4.1.1.2 'FACH1' ) */\r\n    reported_length = tvb_reported_length(tvb);\r\n    if (reported_length != 51) {\r\n        return false;\r\n    }\r\n\r\n    p_fp_info = (fp_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_fp, 0);\r\n\r\n    /* Making sure FP info isn't already attached */\r\n    if (p_fp_info) {\r\n        return false;\r\n    }\r\n\r\n    frame_type = tvb_get_uint8(tvb, 0) & 0x01;\r\n    if (frame_type == 1) { /* is 'control' frame type*/\r\n                           /* We can't tell the FP type and content of control frames */\r\n        return false;\r\n    }\r\n\r\n    tfi = tvb_get_uint8(tvb, 2) & 0x1f;\r\n    if (tfi != 0x01) {\r\n        return false;\r\n    }\r\n\r\n    tctf = tvb_get_uint8(tvb, 4);\r\n    /* Asserting the TCTF field contains a valid (non reserved) value according to TS 25.321 Table 9.2.1-2 */\r\n    if (tctf != 0x40 && /* CCCH */\r\n        tctf != 0x50 && /* MCCH */\r\n        tctf != 0x5F && /* MSCH */\r\n        tctf != 0x80 && /* CTCH */\r\n        (tctf >> 4) != 0x06 && /* MTCH */\r\n        (tctf >> 6) != 0x00 && /* BCCH */\r\n        (tctf >> 6) != 0x03) { /* DCCH or DTCH over FACH */\r\n        return false;\r\n    }\r\n\r\n    if (!check_header_crc_for_heur(tvb, 4)) {\r\n        return false;\r\n    }\r\n    if (!check_payload_crc_for_heur(tvb, 4)) {\r\n        return false;\r\n    }\r\n\r\n    if(!umts_fp_conversation_info) {\r\n        umts_fp_conversation_info = wmem_new0(wmem_file_scope(), umts_fp_conversation_info_t);\r\n        set_both_sides_umts_fp_conv_data(pinfo, umts_fp_conversation_info);\r\n    }\r\n    umts_fp_conversation_info->iface_type = IuB_Interface;\r\n    umts_fp_conversation_info->division = Division_FDD;\r\n    umts_fp_conversation_info->dl_frame_number = pinfo->num;\r\n    umts_fp_conversation_info->ul_frame_number = pinfo->num;\r\n    umts_fp_conversation_info->dch_crc_present = 1;\r\n    umts_fp_conversation_info->com_context_id = generate_ue_id_for_heur(pinfo);\r\n    umts_fp_conversation_info->rlc_mode = FP_RLC_AM;\r\n    copy_address_wmem(wmem_file_scope(), &(umts_fp_conversation_info->crnc_address), &pinfo->src);\r\n    umts_fp_conversation_info->crnc_port = pinfo->srcport;\r\n    umts_fp_conversation_info->channel = CHANNEL_FACH_FDD;\r\n    umts_fp_conversation_info->num_dch_in_flow = 1;\r\n    umts_fp_conversation_info->fp_dch_channel_info[0].num_dl_chans = 1;\r\n    umts_fp_conversation_info->fp_dch_channel_info[0].dl_chan_num_tbs[1] = 1;\r\n    umts_fp_conversation_info->fp_dch_channel_info[0].dl_chan_tf_size[1] = 360;\r\n    /* Adding the 'channel specific info' for FACH */\r\n    fp_fach_channel_info = wmem_new0(wmem_file_scope(), fp_fach_channel_info_t);\r\n    fp_fach_channel_info->crnti_to_urnti_map = wmem_tree_new_autoreset(wmem_epan_scope(), wmem_file_scope());\r\n    umts_fp_conversation_info->channel_specific_info = (void*)fp_fach_channel_info;\r\n\r\n    conversation_set_dissector(find_or_create_conversation(pinfo), fp_handle);\r\n    dissect_fp(tvb, pinfo, tree, data);\r\n    return true;\r\n}", ".eur_dissect_fp_fach2": "static bool\r\nheur_dissect_fp_fach2(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)\r\n{\r\n    conversation_t   *p_conv;\r\n    fp_fach_channel_info_t* fp_fach_channel_info;\r\n    umts_fp_conversation_info_t* umts_fp_conversation_info = NULL;\r\n    struct fp_info *p_fp_info;\r\n    uint32_t captured_length;\r\n    uint32_t reported_length;\r\n    uint8_t frame_type;\r\n    uint8_t tfi;\r\n    uint8_t tctf;\r\n\r\n    /* Finding or creating conversation */\r\n    p_conv = (conversation_t *)find_conversation(pinfo->num, &pinfo->net_dst, &pinfo->net_src,\r\n        conversation_pt_to_conversation_type(pinfo->ptype),\r\n        pinfo->destport, pinfo->srcport, NO_ADDR_B);\r\n\r\n    if (p_conv != NULL) {\r\n        /* Checking if the conversation was already framed */\r\n        umts_fp_conversation_info = (umts_fp_conversation_info_t *)conversation_get_proto_data(p_conv, proto_fp);\r\n        if (umts_fp_conversation_info) {\r\n            if (umts_fp_conversation_info->channel == CHANNEL_FACH_FDD) {\r\n                conversation_set_dissector(p_conv, fp_handle);\r\n                dissect_fp(tvb, pinfo, tree, data);\r\n                return true;\r\n            }\r\n            else if (umts_fp_conversation_info->channel != CHANNEL_UNKNOWN){\r\n                /* This conversation was successfully framed as ANOTHER type */\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    /* Making sure we have at least enough bytes for header (4) + footer (2) */\r\n    captured_length = tvb_captured_length(tvb);\r\n    if(captured_length < 6) {\r\n        return false;\r\n    }\r\n\r\n    /* Expecting specific lengths: 27 for frames with 1 TB, 48 for frames with 2 TBs */\r\n    /* This is a common Transport Format of FACH ( See 3GPP TR 25.944 / 4.1.1.2 'FACH2' ) */\r\n    reported_length = tvb_reported_length(tvb);\r\n    if (reported_length != 27 && reported_length != 48) {\r\n        return false;\r\n    }\r\n\r\n    p_fp_info = (fp_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_fp, 0);\r\n\r\n    /* Making sure FP info isn't already attached */\r\n    if (p_fp_info) {\r\n        return false;\r\n    }\r\n\r\n    frame_type = tvb_get_uint8(tvb, 0) & 0x01;\r\n    if (frame_type == 1) { /* is 'control' frame type*/\r\n                           /* We can't tell the FP type and content of control frames */\r\n        return false;\r\n    }\r\n\r\n    tfi = tvb_get_uint8(tvb, 2) & 0x1f;\r\n    if (reported_length == 27 && tfi != 0x01) {\r\n        return false;\r\n    }\r\n    if (reported_length == 48 && tfi != 0x02) {\r\n        return false;\r\n    }\r\n\r\n    tctf = tvb_get_uint8(tvb, 4);\r\n    /* Asserting the TCTF field contains a valid (non reserved) value according to TS 25.321 Table 9.2.1-2 */\r\n    if (tctf != 0x40 && /* CCCH */\r\n        tctf != 0x50 && /* MCCH */\r\n        tctf != 0x5F && /* MSCH */\r\n        tctf != 0x80 && /* CTCH */\r\n        (tctf >> 4) != 0x06 && /* MTCH */\r\n        (tctf >> 6) != 0x00 && /* BCCH */\r\n        (tctf >> 6) != 0x03) { /* DCCH or DTCH over FACH */\r\n        return false;\r\n    }\r\n\r\n    if (!check_header_crc_for_heur(tvb, 4)) {\r\n        return false;\r\n    }\r\n    if (!check_payload_crc_for_heur(tvb, 4)) {\r\n        return false;\r\n    }\r\n\r\n    if(!umts_fp_conversation_info) {\r\n        umts_fp_conversation_info = wmem_new0(wmem_file_scope(), umts_fp_conversation_info_t);\r\n        set_both_sides_umts_fp_conv_data(pinfo, umts_fp_conversation_info);\r\n    }\r\n    umts_fp_conversation_info->iface_type = IuB_Interface;\r\n    umts_fp_conversation_info->division = Division_FDD;\r\n    umts_fp_conversation_info->dl_frame_number = pinfo->num;\r\n    umts_fp_conversation_info->ul_frame_number = pinfo->num;\r\n    umts_fp_conversation_info->dch_crc_present = 1;\r\n    umts_fp_conversation_info->com_context_id = generate_ue_id_for_heur(pinfo);\r\n    umts_fp_conversation_info->rlc_mode = FP_RLC_AM;\r\n    copy_address_wmem(wmem_file_scope(), &(umts_fp_conversation_info->crnc_address), &pinfo->src);\r\n    umts_fp_conversation_info->crnc_port = pinfo->srcport;\r\n    umts_fp_conversation_info->channel = CHANNEL_FACH_FDD;\r\n    umts_fp_conversation_info->num_dch_in_flow = 1;\r\n    umts_fp_conversation_info->fp_dch_channel_info[0].num_dl_chans = 1;\r\n    umts_fp_conversation_info->fp_dch_channel_info[0].dl_chan_num_tbs[1] = 1;\r\n    umts_fp_conversation_info->fp_dch_channel_info[0].dl_chan_tf_size[1] = 168;\r\n    umts_fp_conversation_info->fp_dch_channel_info[0].dl_chan_num_tbs[2] = 2;\r\n    umts_fp_conversation_info->fp_dch_channel_info[0].dl_chan_tf_size[2] = 168;\r\n    /* Adding the 'channel specific info' for FACH */\r\n    fp_fach_channel_info = wmem_new0(wmem_file_scope(), fp_fach_channel_info_t);\r\n    fp_fach_channel_info->crnti_to_urnti_map = wmem_tree_new_autoreset(wmem_epan_scope(), wmem_file_scope());\r\n    umts_fp_conversation_info->channel_specific_info = (void*)fp_fach_channel_info;\r\n\r\n    conversation_set_dissector(find_or_create_conversation(pinfo), fp_handle);\r\n    dissect_fp(tvb, pinfo, tree, data);\r\n    return true;\r\n}", ".eur_dissect_fp_rach": "static bool\r\nheur_dissect_fp_rach(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)\r\n{\r\n    conversation_t   *p_conv;\r\n    fp_rach_channel_info_t* fp_rach_channel_info;\r\n    umts_fp_conversation_info_t* umts_fp_conversation_info = NULL;\r\n    struct fp_info *p_fp_info;\r\n    uint32_t captured_length;\r\n    uint32_t reported_length;\r\n    uint8_t frame_type;\r\n    uint8_t tfi;\r\n    uint8_t tctf;\r\n\r\n    /* Finding or creating conversation */\r\n    p_conv = (conversation_t *)find_conversation(pinfo->num, &pinfo->net_dst, &pinfo->net_src,\r\n        conversation_pt_to_conversation_type(pinfo->ptype),\r\n        pinfo->destport, pinfo->srcport, NO_ADDR_B);\r\n\r\n    if (p_conv != NULL) {\r\n        /* Checking if the conversation was already framed */\r\n        umts_fp_conversation_info = (umts_fp_conversation_info_t *)conversation_get_proto_data(p_conv, proto_fp);\r\n        if (umts_fp_conversation_info) {\r\n            if (umts_fp_conversation_info->channel == CHANNEL_RACH_FDD) {\r\n                conversation_set_dissector(p_conv, fp_handle);\r\n                dissect_fp(tvb, pinfo, tree, data);\r\n                return true;\r\n            }\r\n            else if (umts_fp_conversation_info->channel != CHANNEL_UNKNOWN){\r\n                /* This conversation was successfully framed as ANOTHER type */\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /* Making sure we have at least enough bytes for header (4) + footer (2) */\r\n    captured_length = tvb_captured_length(tvb);\r\n    if(captured_length < 6) {\r\n        return false;\r\n    }\r\n\r\n    /* Expecting specific lengths: rach frames are either 28 or 52 bytes long */\r\n    /* This is the common Transport Formats of RACH ( See 3GPP TR 25.944 / 4.1.2.1 ) */\r\n    reported_length = tvb_reported_length(tvb);\r\n    if (reported_length != 28 && reported_length != 52) {\r\n        return false;\r\n    }\r\n\r\n    p_fp_info = (fp_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_fp, 0);\r\n\r\n    /* Making sure FP info isn't already attached */\r\n    if (p_fp_info) {\r\n        return false;\r\n    }\r\n\r\n    frame_type = tvb_get_uint8(tvb, 0) & 0x01;\r\n    if (frame_type == 1) { /* is 'control' frame type*/\r\n                           /* We can't tell the FP type and content of control frames */\r\n        return false;\r\n    }\r\n\r\n    tfi = tvb_get_uint8(tvb, 2) & 0x1f;\r\n    if (reported_length == 28 && tfi != 0x00) {\r\n        return false;\r\n    }\r\n    if (reported_length == 52 && tfi != 0x01) {\r\n        return false;\r\n    }\r\n\r\n    tctf = tvb_get_uint8(tvb, 4) >> 6;\r\n    /* Asserting the TCTF field contains a valid (non reserved) value according to TS 25.321 Table 9.2.1-4 */\r\n    if (tctf != 0x00 && /* CCCH */\r\n        tctf != 0x01)  /* DCCH over RACH */\r\n    {\r\n        return false;\r\n    }\r\n\r\n    if (!check_header_crc_for_heur(tvb, 4)) {\r\n        return false;\r\n    }\r\n    if (!check_payload_crc_for_heur(tvb, 4)) {\r\n        return false;\r\n    }\r\n\r\n    if(!umts_fp_conversation_info) {\r\n        umts_fp_conversation_info = wmem_new0(wmem_file_scope(), umts_fp_conversation_info_t);\r\n        set_both_sides_umts_fp_conv_data(pinfo, umts_fp_conversation_info);\r\n    }\r\n    umts_fp_conversation_info->iface_type = IuB_Interface;\r\n    umts_fp_conversation_info->division = Division_FDD;\r\n    umts_fp_conversation_info->dl_frame_number = pinfo->num;\r\n    umts_fp_conversation_info->ul_frame_number = pinfo->num;\r\n    umts_fp_conversation_info->dch_crc_present = 1;\r\n    umts_fp_conversation_info->com_context_id = generate_ue_id_for_heur(pinfo);\r\n    umts_fp_conversation_info->rlc_mode = FP_RLC_AM;\r\n    copy_address_wmem(wmem_file_scope(), &(umts_fp_conversation_info->crnc_address), &pinfo->dst);\r\n    umts_fp_conversation_info->crnc_port = pinfo->destport;\r\n    umts_fp_conversation_info->channel = CHANNEL_RACH_FDD;\r\n    umts_fp_conversation_info->num_dch_in_flow = 1;\r\n    umts_fp_conversation_info->fp_dch_channel_info[0].num_ul_chans = 0;\r\n    umts_fp_conversation_info->fp_dch_channel_info[0].ul_chan_num_tbs[0] = 1;\r\n    umts_fp_conversation_info->fp_dch_channel_info[0].ul_chan_num_tbs[1] = 1;\r\n    umts_fp_conversation_info->fp_dch_channel_info[0].ul_chan_tf_size[0] = 168;\r\n    umts_fp_conversation_info->fp_dch_channel_info[0].ul_chan_tf_size[1] = 360;\r\n\r\n    /* Adding the 'channel specific info' for RACH */\r\n    fp_rach_channel_info = wmem_new0(wmem_file_scope(), fp_rach_channel_info_t);\r\n    fp_rach_channel_info->crnti_to_urnti_map = wmem_tree_new_autoreset(wmem_epan_scope(), wmem_file_scope());\r\n    umts_fp_conversation_info->channel_specific_info = (void*)fp_rach_channel_info;\r\n\r\n    conversation_set_dissector(find_or_create_conversation(pinfo), fp_handle);\r\n    dissect_fp(tvb, pinfo, tree, data);\r\n    return true;\r\n}", ".eur_dissect_fp_pch": "static bool\r\nheur_dissect_fp_pch(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)\r\n{\r\n    conversation_t   *p_conv;\r\n    umts_fp_conversation_info_t* umts_fp_conversation_info = NULL;\r\n    fp_pch_channel_info_t* fp_pch_channel_info = NULL;\r\n    struct fp_info *p_fp_info;\r\n    bool conversation_initialized = false;\r\n    uint32_t captured_length;\r\n    uint32_t reported_length;\r\n    uint8_t frame_type;\r\n    uint8_t reserved_bits;\r\n    uint8_t tfi;\r\n    uint8_t pi_byte_length;\r\n    uint16_t tb_byte_length;\r\n    bool pi_present;\r\n    bool tb_size_found;\r\n    bool pi_length_found;\r\n    uint8_t cfn_lowest_bits;\r\n    uint8_t dch_collisions_byte;\r\n\r\n    /* To correctly dissect a PCH stream 2 parameters are required: PI Bitmap length & TB length */\r\n    /* Both are optional in each packet and having them both in a packet without knowing any of them */\r\n    /* is not helpful.*/\r\n    /* Hence gathering the info from 2 different frames is required. */\r\n\r\n    /* Finding or creating conversation */\r\n    p_conv = (conversation_t *)find_conversation(pinfo->num, &pinfo->net_dst, &pinfo->net_src,\r\n        conversation_pt_to_conversation_type(pinfo->ptype),\r\n        pinfo->destport, pinfo->srcport, NO_ADDR_B);\r\n\r\n    if (p_conv != NULL) {\r\n        /* Checking if the conversation was already framed */\r\n        umts_fp_conversation_info = (umts_fp_conversation_info_t *)conversation_get_proto_data(p_conv, proto_fp);\r\n        if (umts_fp_conversation_info) {\r\n            fp_pch_channel_info = (fp_pch_channel_info_t*)umts_fp_conversation_info->channel_specific_info;\r\n            /* Making sure this conversation type is \"PCH\" and the PCH channel info is present */\r\n            if (umts_fp_conversation_info->channel == CHANNEL_PCH && fp_pch_channel_info != NULL) {\r\n                conversation_initialized = true;\r\n                pi_length_found = fp_pch_channel_info->paging_indications != 0;\r\n                tb_size_found = umts_fp_conversation_info->fp_dch_channel_info[0].dl_chan_tf_size[1] != 0;\r\n                if (pi_length_found && tb_size_found) {\r\n                    /* Stream already framed - contains both PI length and TB size */\r\n                    dissect_fp(tvb, pinfo, tree, data);\r\n                    return true;\r\n                }\r\n            }\r\n            else if (umts_fp_conversation_info->channel != CHANNEL_UNKNOWN){\r\n                /* This conversation was successfully framed as ANOTHER type */\r\n                return false;\r\n            }\r\n            else {\r\n                /* FP conversation info attached and the channel type is UNKNOWN - might be PCH */\r\n                tb_size_found = false;\r\n                pi_length_found = false;\r\n            }\r\n        }\r\n        else {\r\n            /* FP conversation info not attached - no PCH info is known */\r\n            tb_size_found = false;\r\n            pi_length_found = false;\r\n        }\r\n    }\r\n    else {\r\n        /* A conversation does not exist yet - no PCH info is known */\r\n        tb_size_found = false;\r\n        pi_length_found = false;\r\n    }\r\n\r\n    /* Making sure we have at least enough bytes for header (4) + footer (2) */\r\n    captured_length = tvb_captured_length(tvb);\r\n    if(captured_length < 6) {\r\n        return false;\r\n    }\r\n\r\n    p_fp_info = (fp_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_fp, 0);\r\n    /* Making sure FP info isn't already attached */\r\n    if (p_fp_info) {\r\n        return false;\r\n    }\r\n\r\n    frame_type = tvb_get_uint8(tvb, 0) & 0x01;\r\n    if (frame_type == 1) { /* is 'control' frame type*/\r\n                           /* We can't tell the FP type and content of control frames */\r\n        return false;\r\n    }\r\n\r\n    /* Checking bits after CFN and before PI indicator are zeroed */\r\n    reserved_bits = tvb_get_uint8(tvb, 2) & 0x0E;\r\n    if (reserved_bits != 0x00) {\r\n        return false;\r\n    }\r\n\r\n    tfi = tvb_get_uint8(tvb, 3) & 0x1f;\r\n    if (tfi != 0x00 && tfi != 0x01) {\r\n        return false;\r\n    }\r\n\r\n    if (!check_header_crc_for_heur(tvb, 4)) {\r\n        return false;\r\n    }\r\n    if (!check_payload_crc_for_heur(tvb, 4)) {\r\n        return false;\r\n    }\r\n\r\n    reported_length = tvb_reported_length(tvb);\r\n    pi_present = tvb_get_uint8(tvb, 2) & 0x01; /* Rightmost bit in the 3rd byte */\r\n    if (pi_present) {\r\n        if (tfi == 0x00 && !pi_length_found) {\r\n            /* PI Bitmap present and No TB. Can calculate PI bitmap length */\r\n            uint8_t pi_bit_length;\r\n            pi_byte_length = reported_length - 6; /* Removing header length (4) and footer length (2)*/\r\n            switch (pi_byte_length)\r\n            {\r\n            case 3: /* 18 bits bitmap + padding */\r\n                pi_bit_length = 18;\r\n                break;\r\n            case 5: /* 36 bits bitmap + padding */\r\n                pi_bit_length = 36;\r\n                break;\r\n            case 9: /* 72 bits bitmap */\r\n                pi_bit_length = 72;\r\n                break;\r\n            case 18: /* 144 bits bitmap */\r\n                pi_bit_length = 144;\r\n                break;\r\n            default:\r\n                return false;\r\n            }\r\n\r\n            if (pi_bit_length == 144 && !tb_size_found) {\r\n                /* Nothing has confirmed yet that this channel is a PCH since */\r\n                /* both 'tb_size_found' and 'pi_length_found' are false. */\r\n                /* Checking if the 4 LSB bits of the CFN (the 4 leftmost bits in the 3rd byte) aren't zeroed. */\r\n                /* if they aren't this is probably PCH because those are reserved in DCH */\r\n                cfn_lowest_bits = tvb_get_uint8(tvb, 2) & 0xF0;\r\n                if(cfn_lowest_bits == 0) {\r\n                    /* Checking if the 4th byte in the frame is zeroed. In this case the CRC checks aren't */\r\n                    /* deterministic enough to guarantee this is a PCH since this packet could also be a DCH frame */\r\n                    /* with MAC's C/T is 0 and 4 leftmost bits of RLC are 0 */\r\n                    dch_collisions_byte = tvb_get_uint8(tvb, 3);\r\n                    if (dch_collisions_byte == 0) {\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (!umts_fp_conversation_info) {\r\n                umts_fp_conversation_info = wmem_new0(wmem_file_scope(), umts_fp_conversation_info_t);\r\n                set_both_sides_umts_fp_conv_data(pinfo, umts_fp_conversation_info);\r\n            }\r\n            if(!conversation_initialized) {\r\n                fill_pch_conversation_info_for_heur(umts_fp_conversation_info, pinfo);\r\n                fp_pch_channel_info = (fp_pch_channel_info_t*)umts_fp_conversation_info->channel_specific_info;\r\n            }\r\n            fp_pch_channel_info->paging_indications = pi_bit_length;\r\n            pi_length_found = true;\r\n        }\r\n        else if (tfi == 0x01 && !tb_size_found && pi_length_found) {\r\n            /* TB present and PI bitmap length is known. Can calculate TB length.*/\r\n            pi_byte_length = (fp_pch_channel_info->paging_indications + 7) / 8;\r\n            if (!umts_fp_conversation_info) {\r\n                umts_fp_conversation_info = wmem_new0(wmem_file_scope(), umts_fp_conversation_info_t);\r\n                set_both_sides_umts_fp_conv_data(pinfo, umts_fp_conversation_info);\r\n            }\r\n            if(!conversation_initialized) {\r\n                fill_pch_conversation_info_for_heur(umts_fp_conversation_info, pinfo);\r\n            }\r\n            tb_byte_length = (reported_length - (pi_byte_length + 6)); /* Removing header length (4), footer length (2) and PI bitmap length*/\r\n            /* Possible TB lengths for PCH is 10 or 30 bytes ( See 3GPP TR 25.944 / 4.1.1.2 ) */\r\n            if (tb_byte_length == 10 || tb_byte_length == 30) {\r\n                umts_fp_conversation_info->fp_dch_channel_info[0].dl_chan_tf_size[1] = tb_byte_length * 8;\r\n                tb_size_found = true;\r\n            }\r\n        }\r\n        /* TODO: It should be possible to figure both PI & TB sizes if both are present in a frame and neither is known */\r\n        /* Since the total size of the frame should be unique */\r\n        /* e.g. 19 bytes = header (4) + PI 18bits (3) + TB (10) + footer (2)*/\r\n        /*      21 bytes = header (4) + PI 36bits (5) + TB (10) + footer (2)*/\r\n        /*      etc... */\r\n        /* This could mostly help dissect 'busy' PCHs where most of the frames have both PI & TB*/\r\n    }\r\n    else {\r\n        if (tfi == 0x01 && !tb_size_found) {\r\n            /* TB present and PI bitmap is missing. Can calculate TB length.*/\r\n            if (!umts_fp_conversation_info) {\r\n                umts_fp_conversation_info = wmem_new0(wmem_file_scope(), umts_fp_conversation_info_t);\r\n                set_both_sides_umts_fp_conv_data(pinfo, umts_fp_conversation_info);\r\n            }\r\n            if(!conversation_initialized) {\r\n                fill_pch_conversation_info_for_heur(umts_fp_conversation_info, pinfo);\r\n            }\r\n            tb_byte_length = (reported_length - 6); /* Removing header length (4), footer length (2) */\r\n            /* Possible TB lengths for PCH is 10 or 30 bytes ( See 3GPP TR 25.944 / 4.1.1.2 ) */\r\n            if (tb_byte_length == 10 || tb_byte_length == 30) {\r\n                umts_fp_conversation_info->fp_dch_channel_info[0].dl_chan_tf_size[1] = tb_byte_length * 8;\r\n                set_both_sides_umts_fp_conv_data(pinfo, umts_fp_conversation_info);\r\n                tb_size_found = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    if (pi_length_found && tb_size_found) {\r\n        /* Stream completely framed! */\r\n        conversation_set_dissector(find_or_create_conversation(pinfo), fp_handle);\r\n        dissect_fp(tvb, pinfo, tree, data);\r\n        return true;\r\n    }\r\n    else {\r\n        /* Some data still missing */\r\n        return false;\r\n    }\r\n}", ".eur_dissect_fp_hsdsch_type_1": "static bool\r\nheur_dissect_fp_hsdsch_type_1(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)\r\n{\r\n    conversation_t   *p_conv;\r\n    umts_fp_conversation_info_t* umts_fp_conversation_info = NULL;\r\n    fp_hsdsch_channel_info_t* fp_hsdsch_channel_info;\r\n    struct fp_info *p_fp_info;\r\n    uint32_t captured_length;\r\n    uint32_t reported_length;\r\n    uint8_t frame_type;\r\n    uint16_t mac_d_pdu_length;\r\n    uint16_t num_of_pdus;\r\n    uint32_t expected_total_size;\r\n    uint32_t next_pdu_index;\r\n    uint16_t index_step;\r\n    uint8_t pre_pdu_padding;\r\n\r\n    /* Trying to find existing conversation */\r\n    p_conv = (conversation_t *)find_conversation(pinfo->num, &pinfo->net_dst, &pinfo->net_src,\r\n        conversation_pt_to_conversation_type(pinfo->ptype),\r\n        pinfo->destport, pinfo->srcport, NO_ADDR_B);\r\n\r\n    if (p_conv != NULL) {\r\n        /* Checking if the conversation was already framed */\r\n        umts_fp_conversation_info = (umts_fp_conversation_info_t *)conversation_get_proto_data(p_conv, proto_fp);\r\n        if (umts_fp_conversation_info) {\r\n            fp_hsdsch_channel_info = (fp_hsdsch_channel_info_t*)umts_fp_conversation_info->channel_specific_info;\r\n            if (umts_fp_conversation_info->channel == CHANNEL_HSDSCH && fp_hsdsch_channel_info->hsdsch_entity == hs) {\r\n                conversation_set_dissector(p_conv, fp_handle);\r\n                dissect_fp(tvb, pinfo, tree, data);\r\n                return true;\r\n            }\r\n            else if (umts_fp_conversation_info->channel != CHANNEL_UNKNOWN){\r\n                /* This conversation was successfully framed as ANOTHER type */\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /* Making sure FP info isn't already attached */\r\n    p_fp_info = (fp_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_fp, 0);\r\n    if (p_fp_info) {\r\n        return false;\r\n    }\r\n\r\n    captured_length = tvb_reported_length(tvb);\r\n    /* Lengths limit: header size (7) + at least 1 PDU Block (2) + CRC Payload size (2)*/\r\n    if (captured_length < 11) {\r\n        return false;\r\n    }\r\n\r\n    frame_type = tvb_get_uint8(tvb, 0) & 0x01;\r\n    if (frame_type == 1) { /* is 'control' frame type*/\r\n        return false;\r\n    }\r\n\r\n    /* Lengths limit: Smallest HS-DSCH type 1 data frame is 55 bytes (1 PDU of 336 bits) */\r\n    reported_length = tvb_reported_length(tvb);\r\n    if (reported_length < 55) {\r\n        return false;\r\n    }\r\n\r\n    mac_d_pdu_length = tvb_get_uint16(tvb, 2, ENC_NA) >> 3;\r\n    /* Only valid PDU lengths are 336 or 656 */\r\n    if (mac_d_pdu_length != 336 && mac_d_pdu_length != 656) {\r\n        return false;\r\n    }\r\n\r\n    num_of_pdus = tvb_get_uint8(tvb, 4);\r\n    /* PDUs count shouldn't be 0*/\r\n    if (num_of_pdus == 0) {\r\n        return false;\r\n    }\r\n    /* Maximum PDUs count constraint: 32 PDUs * 336 bits or 17 PDUs * 656 bits */\r\n    if ((mac_d_pdu_length == 336 && num_of_pdus > 32) || (mac_d_pdu_length == 656 && num_of_pdus > 17)) {\r\n        return false;\r\n    }\r\n\r\n    /* Making sure the expected packet size is smaller/equals to the entire packet's size */\r\n    expected_total_size = (num_of_pdus * mac_d_pdu_length / 8) + 7 /*Header length*/ + 2 /*Footer length*/;\r\n    if (expected_total_size > captured_length || expected_total_size > reported_length) {\r\n        return false;\r\n    }\r\n\r\n    /* Iterating through the PDUs making sure the padding nibble is present in all of them */\r\n    next_pdu_index = 7;\r\n    index_step = mac_d_pdu_length / 8;\r\n    for (int i = 0; i < num_of_pdus; i++)\r\n    {\r\n        pre_pdu_padding = tvb_get_uint8(tvb, next_pdu_index) >> 4;\r\n        if (pre_pdu_padding != 0x00)\r\n        {\r\n            /* One of the padding nibbles is not zeroed */\r\n            return false;\r\n        }\r\n        next_pdu_index += index_step;\r\n    }\r\n\r\n    if (!check_header_crc_for_heur(tvb, 7)) {\r\n        return false;\r\n    }\r\n    if (!check_payload_crc_for_heur(tvb, 7)) {\r\n        return false;\r\n    }\r\n\r\n    if(!umts_fp_conversation_info) {\r\n        umts_fp_conversation_info = wmem_new0(wmem_file_scope(), umts_fp_conversation_info_t);\r\n        set_both_sides_umts_fp_conv_data(pinfo, umts_fp_conversation_info);\r\n    }\r\n    umts_fp_conversation_info->iface_type = IuB_Interface;\r\n    umts_fp_conversation_info->division = Division_FDD;\r\n    umts_fp_conversation_info->dl_frame_number = pinfo->num;\r\n    umts_fp_conversation_info->ul_frame_number = pinfo->num;\r\n    umts_fp_conversation_info->dch_crc_present = 1;\r\n    umts_fp_conversation_info->com_context_id = generate_ue_id_for_heur(pinfo);\r\n    umts_fp_conversation_info->rlc_mode = FP_RLC_AM;\r\n    copy_address_wmem(wmem_file_scope(), &(umts_fp_conversation_info->crnc_address), &pinfo->src);\r\n    umts_fp_conversation_info->crnc_port = pinfo->srcport;\r\n    umts_fp_conversation_info->channel = CHANNEL_HSDSCH;\r\n    fp_hsdsch_channel_info = wmem_new0(wmem_file_scope(), fp_hsdsch_channel_info_t);\r\n    fp_hsdsch_channel_info->hsdsch_entity = hs;\r\n    fp_hsdsch_channel_info->hsdsch_macdflow_id = 0;\r\n    umts_fp_conversation_info->channel_specific_info = (void*)fp_hsdsch_channel_info;\r\n\r\n    conversation_set_dissector(find_or_create_conversation(pinfo), fp_handle);\r\n    dissect_fp(tvb, pinfo, tree, data);\r\n    return true;\r\n}", ".eur_dissect_fp_hsdsch_type_2": "static bool\r\nheur_dissect_fp_hsdsch_type_2(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)\r\n{\r\n    conversation_t   *p_conv;\r\n    umts_fp_conversation_info_t* umts_fp_conversation_info = NULL;\r\n    fp_hsdsch_channel_info_t* fp_hsdsch_channel_info;\r\n    struct fp_info *p_fp_info;\r\n    uint32_t captured_length;\r\n    uint32_t reported_length;\r\n    uint8_t frame_type;\r\n    uint8_t reserved_fach_ind_bits;\r\n    uint8_t pdu_block_header_reserved_bit;\r\n    uint8_t pdu_block_headers_count;\r\n    uint16_t next_pdu_block_header_index;\r\n    uint16_t pdu_block_header_pdu_length;\r\n    uint8_t pdu_block_header_pdus_count;\r\n    uint8_t pdu_block_header_lchid;\r\n    uint32_t total_header_length;\r\n    uint32_t expected_payload_length;\r\n\r\n    /* Trying to find existing conversation */\r\n    p_conv = (conversation_t *)find_conversation(pinfo->num, &pinfo->net_dst, &pinfo->net_src,\r\n        conversation_pt_to_conversation_type(pinfo->ptype),\r\n        pinfo->destport, pinfo->srcport, NO_ADDR_B);\r\n\r\n    if (p_conv != NULL) {\r\n        /* Checking if the conversation was already framed */\r\n        umts_fp_conversation_info = (umts_fp_conversation_info_t *)conversation_get_proto_data(p_conv, proto_fp);\r\n        if (umts_fp_conversation_info) {\r\n            fp_hsdsch_channel_info = (fp_hsdsch_channel_info_t*)umts_fp_conversation_info->channel_specific_info;\r\n            if (umts_fp_conversation_info->channel == CHANNEL_HSDSCH && fp_hsdsch_channel_info->hsdsch_entity == ehs) {\r\n                conversation_set_dissector(p_conv, fp_handle);\r\n                dissect_fp(tvb, pinfo, tree, data);\r\n                return true;\r\n            }\r\n            else if (umts_fp_conversation_info->channel != CHANNEL_UNKNOWN){\r\n                /* This conversation was successfully framed as ANOTHER type */\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /* Making sure FP info isn't already attached */\r\n    p_fp_info = (fp_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_fp, 0);\r\n    if (p_fp_info) {\r\n        return false;\r\n    }\r\n\r\n    captured_length = tvb_captured_length(tvb);\r\n    reported_length = tvb_reported_length(tvb);\r\n    /* Lengths limit: header size + at least 1 PDU Block Header + CRC Payload size */\r\n    if (captured_length < 11) {\r\n        return false;\r\n    }\r\n\r\n    frame_type = tvb_get_uint8(tvb, 0) & 0x01;\r\n    if (frame_type == 1) { /* is 'control' frame type*/\r\n        return false;\r\n    }\r\n\r\n    pdu_block_header_reserved_bit = (tvb_get_uint8(tvb, 7) & 0x10) >> 4;\r\n    if (pdu_block_header_reserved_bit == 0x1) {\r\n        return false;\r\n    }\r\n\r\n    /* Expecting at least 1 PDU Block Header */\r\n    pdu_block_headers_count = tvb_get_uint8(tvb, 2) >> 3;\r\n    if (pdu_block_headers_count == 0) {\r\n        return false;\r\n    }\r\n\r\n    /* Getting 3 rightmost bits in the FACH Indicator's byte, which are reserved and should be 0 */\r\n    reserved_fach_ind_bits = tvb_get_uint8(tvb, 3) & 0x03;\r\n    if (reserved_fach_ind_bits != 0x00) {\r\n        return false;\r\n    }\r\n\r\n    /* Iterating through the block headers looking for invalid fields and */\r\n    /* calculating the expected total packet length */\r\n    total_header_length = 6;\r\n    expected_payload_length = 0;\r\n    for (int i = 0; i < pdu_block_headers_count; i++)\r\n    {\r\n        /* Making sure the next index is not out of range */\r\n        if (((uint32_t)(8 + (i * 3))) >= captured_length) {\r\n            return false;\r\n        }\r\n\r\n        /* Getting blocks length and count from the i-th header */\r\n        if (i % 2 == 0) {\r\n            next_pdu_block_header_index = (i * 25) / 10;\r\n        }\r\n        else {\r\n            next_pdu_block_header_index = (((i-1) * 25) / 10) + 2;\r\n        }\r\n        pdu_block_header_pdu_length = tvb_get_uint16(tvb, 6 + next_pdu_block_header_index, ENC_NA) >> 5;\r\n        pdu_block_header_pdus_count = tvb_get_uint8(tvb, 7 + next_pdu_block_header_index) & 0x0F;\r\n        pdu_block_header_lchid = tvb_get_uint8(tvb, 8 + next_pdu_block_header_index) >> 4;\r\n\r\n\r\n        /* Making sure PDUs' Length isn't zeroed*/\r\n        if (pdu_block_header_pdu_length == 0) {\r\n            return false;\r\n        }\r\n        /* Making sure PDUs Count isn't zeroed */\r\n        if (pdu_block_header_pdus_count == 0) {\r\n            return false;\r\n        }\r\n\r\n        /* Adding this header's length to expected length*/\r\n        if (i % 2 == 0) {\r\n            total_header_length += 3;\r\n        }\r\n        else {\r\n            total_header_length += 2;\r\n        }\r\n        /* Adding this header's payload's size to expected length*/\r\n        expected_payload_length += (pdu_block_header_pdu_length * pdu_block_header_pdus_count);\r\n\r\n        /* Checking padding after lchid */\r\n        if ((tvb_get_uint8(tvb, 8 + (i * 3)) & 0x0F) != 0x00) {\r\n            return false;\r\n        }\r\n        /* Checking lchid for reserved value 0x0F*/\r\n\r\n        if (pdu_block_header_lchid == 0x0F) {\r\n            return false;\r\n        }\r\n    }\r\n    /* Adding Payload CRC'slength to payload length*/\r\n    expected_payload_length += 2;\r\n    /* Calculated expected packet size must not exceed captured length or reported length*/\r\n    if ((total_header_length + expected_payload_length) > captured_length || (total_header_length + expected_payload_length) > reported_length) {\r\n        return false;\r\n    }\r\n\r\n    if (!check_header_crc_for_heur(tvb, total_header_length)) {\r\n        return false;\r\n    }\r\n    if (!check_payload_crc_for_heur(tvb, total_header_length)) {\r\n        return false;\r\n    }\r\n\r\n    if(!umts_fp_conversation_info) {\r\n        umts_fp_conversation_info = wmem_new0(wmem_file_scope(), umts_fp_conversation_info_t);\r\n        set_both_sides_umts_fp_conv_data(pinfo, umts_fp_conversation_info);\r\n    }\r\n    umts_fp_conversation_info->iface_type = IuB_Interface;\r\n    umts_fp_conversation_info->division = Division_FDD;\r\n    umts_fp_conversation_info->dl_frame_number = pinfo->num;\r\n    umts_fp_conversation_info->ul_frame_number = pinfo->num;\r\n    umts_fp_conversation_info->dch_crc_present = 1;\r\n    umts_fp_conversation_info->com_context_id = generate_ue_id_for_heur(pinfo);\r\n    umts_fp_conversation_info->rlc_mode = FP_RLC_AM;\r\n    copy_address_wmem(wmem_file_scope(), &(umts_fp_conversation_info->crnc_address), &pinfo->src);\r\n    umts_fp_conversation_info->crnc_port = pinfo->srcport;\r\n    umts_fp_conversation_info->channel = CHANNEL_HSDSCH;\r\n    fp_hsdsch_channel_info = wmem_new0(wmem_file_scope(), fp_hsdsch_channel_info_t);\r\n    fp_hsdsch_channel_info->hsdsch_entity = ehs;\r\n    fp_hsdsch_channel_info->hsdsch_macdflow_id = 1;\r\n    umts_fp_conversation_info->channel_specific_info = (void*)fp_hsdsch_channel_info;\r\n\r\n    conversation_set_dissector(find_or_create_conversation(pinfo), fp_handle);\r\n    dissect_fp(tvb, pinfo, tree, data);\r\n    return true;\r\n}", ".eur_dissect_fp_edch_type_1": "static bool\r\nheur_dissect_fp_edch_type_1(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)\r\n{\r\n    conversation_t   *p_conv;\r\n    umts_fp_conversation_info_t* umts_fp_conversation_info = NULL;\r\n    fp_edch_channel_info_t* fp_edch_channel_info;\r\n    struct fp_info *p_fp_info;\r\n    uint32_t captured_length;\r\n    uint8_t frame_type;\r\n    uint8_t num_sub_frames_byte;\r\n    uint8_t number_of_subframes;\r\n    uint8_t number_of_mac_es_pdus;\r\n    uint32_t subframe_number;\r\n    uint32_t total_sub_headers_len;\r\n    uint32_t total_header_length;\r\n    uint32_t payload_length;\r\n    uint32_t total_mac_pdus_count;\r\n    uint32_t macd_pdu_bit_size;\r\n    uint32_t bit_offset;\r\n    uint32_t offset;\r\n    uint32_t i = 0;\r\n    uint32_t n = 0;\r\n\r\n    /* Trying to find existing conversation */\r\n    p_conv = (conversation_t *)find_conversation(pinfo->num, &pinfo->net_dst, &pinfo->net_src,\r\n        conversation_pt_to_conversation_type(pinfo->ptype),\r\n        pinfo->destport, pinfo->srcport, NO_ADDR_B);\r\n\r\n    if (p_conv != NULL) {\r\n        /* Checking if the conversation was already framed */\r\n        umts_fp_conversation_info = (umts_fp_conversation_info_t *)conversation_get_proto_data(p_conv, proto_fp);\r\n        if (umts_fp_conversation_info) {\r\n            fp_edch_channel_info = (fp_edch_channel_info_t*)umts_fp_conversation_info->channel_specific_info;\r\n            if (umts_fp_conversation_info->channel == CHANNEL_EDCH && fp_edch_channel_info->edch_type == 0) {\r\n                conversation_set_dissector(p_conv, fp_handle);\r\n                dissect_fp(tvb, pinfo, tree, data);\r\n                return true;\r\n            }\r\n            else if (umts_fp_conversation_info->channel != CHANNEL_UNKNOWN){\r\n                /* This conversation was successfully framed as ANOTHER type */\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /* Making sure FP info isn't already attached */\r\n    p_fp_info = (fp_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_fp, 0);\r\n    if (p_fp_info) {\r\n        return false;\r\n    }\r\n\r\n    captured_length = tvb_reported_length(tvb);\r\n    /* Lengths limit: header size + at least 1 Subframe Header + CRC Payload size */\r\n    if (captured_length < 9) {\r\n        return false;\r\n    }\r\n\r\n    frame_type = tvb_get_uint8(tvb, 0) & 0x01;\r\n    if (frame_type == 1) { /* is 'control' frame type*/\r\n        return false;\r\n    }\r\n\r\n    num_sub_frames_byte = tvb_get_uint8(tvb, 2);\r\n    /* Checking 4 leftmost bits in the 'Number of Subframes' byte, which are reserved and should be 0 */\r\n    if (num_sub_frames_byte & 0xf0) {\r\n        return false;\r\n    }\r\n\r\n    /* Values {11-16} are reserved */\r\n    number_of_subframes = (num_sub_frames_byte & 0x0f) + 1;\r\n    if (number_of_subframes >= 11) {\r\n        return false;\r\n    }\r\n\r\n    /* Iterating through the block headers looking for invalid fields */\r\n    total_header_length = 4;\r\n    offset = 4;\r\n    total_mac_pdus_count = 0;\r\n    /* EDCH subframe header list */\r\n    for (n=0; n < number_of_subframes; n++) {\r\n\r\n        /* Making sure the next index is not out of range */\r\n        if (((uint32_t)(offset + 3)) >= captured_length) {\r\n            return false;\r\n        }\r\n\r\n        /* Subframe number */\r\n        subframe_number = (tvb_get_uint8(tvb, offset) & 0x07);\r\n        if (subframe_number > 4) {\r\n            return false;\r\n        }\r\n        offset++;\r\n\r\n        /* Number of MAC-es PDUs */\r\n        number_of_mac_es_pdus = (tvb_get_uint8(tvb, offset) & 0xf0) >> 4;\r\n        if (number_of_mac_es_pdus == 0) {\r\n            return false;\r\n        }\r\n        bit_offset = 4;\r\n\r\n        /* Making sure enough bytes are present for all sub-header */\r\n        total_sub_headers_len = ((int)((((1.5 + (number_of_mac_es_pdus * 1.5))*8+7)/8)));\r\n        if ((offset + total_sub_headers_len) >= captured_length) {\r\n            return false;\r\n        }\r\n        /* Details of each MAC-es PDU */\r\n        for (i=0; i < number_of_mac_es_pdus; i++) {\r\n            uint32_t n_pdus;    /*Size of the PDU*/\r\n\r\n            /* DDI (6 bits) */\r\n            bit_offset += 6;\r\n\r\n            /* Number of MAC-d PDUs (6 bits) */\r\n            n_pdus = tvb_get_bits8( tvb, offset*8 + bit_offset, 6);\r\n            total_mac_pdus_count += n_pdus;\r\n            bit_offset += 6;\r\n        }\r\n\r\n        total_header_length += total_sub_headers_len;\r\n        offset += ((bit_offset+7)/8);\r\n    }\r\n\r\n    /* Figure MAC bit size */\r\n    payload_length = captured_length - total_header_length - 3; /* Removing 3 bytes for Payload CRC and TSN */\r\n    if (payload_length == (total_mac_pdus_count * 42)) {\r\n        macd_pdu_bit_size = 336;\r\n    }\r\n    else if (payload_length == (total_mac_pdus_count * 18)) {\r\n        macd_pdu_bit_size = 144;\r\n    }\r\n    else {\r\n        /* Unexpected payload length or DDIs combination */\r\n        return false;\r\n    }\r\n\r\n    if (!check_edch_header_crc_for_heur(pinfo->pool, tvb, total_header_length)) {\r\n        return false;\r\n    }\r\n    if (!check_payload_crc_for_heur(tvb, total_header_length)) {\r\n        return false;\r\n    }\r\n\r\n    if(!umts_fp_conversation_info) {\r\n        umts_fp_conversation_info = wmem_new0(wmem_file_scope(), umts_fp_conversation_info_t);\r\n        set_both_sides_umts_fp_conv_data(pinfo, umts_fp_conversation_info);\r\n    }\r\n    umts_fp_conversation_info->iface_type = IuB_Interface;\r\n    umts_fp_conversation_info->division = Division_FDD;\r\n    umts_fp_conversation_info->dl_frame_number = pinfo->num;\r\n    umts_fp_conversation_info->ul_frame_number = pinfo->num;\r\n    umts_fp_conversation_info->dch_crc_present = 1;\r\n    umts_fp_conversation_info->com_context_id = generate_ue_id_for_heur(pinfo);\r\n    umts_fp_conversation_info->rlc_mode = FP_RLC_AM;\r\n    copy_address_wmem(wmem_file_scope(), &(umts_fp_conversation_info->crnc_address), &pinfo->src);\r\n    umts_fp_conversation_info->crnc_port = pinfo->srcport;\r\n    umts_fp_conversation_info->channel = CHANNEL_EDCH;\r\n    fp_edch_channel_info = wmem_new0(wmem_file_scope(), fp_edch_channel_info_t);\r\n    fp_edch_channel_info->no_ddi_entries = 0x0f;\r\n    for(i = 0;i<0x0f;i++) {\r\n        fp_edch_channel_info->edch_ddi[i] = i;\r\n        fp_edch_channel_info->edch_macd_pdu_size[i] = macd_pdu_bit_size;\r\n        fp_edch_channel_info->edch_lchId[i] = 9;\r\n    }\r\n    fp_edch_channel_info->edch_type = 0; /* Type 1 */\r\n    umts_fp_conversation_info->channel_specific_info = (void*)fp_edch_channel_info;\r\n\r\n    conversation_set_dissector(find_or_create_conversation(pinfo), fp_handle);\r\n    dissect_fp(tvb, pinfo, tree, data);\r\n    return true;\r\n}", ".eur_dissect_fp_unknown_format": "static bool\r\nheur_dissect_fp_unknown_format(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)\r\n{\r\n    conversation_t   *p_conv;\r\n    umts_fp_conversation_info_t* umts_fp_conversation_info = NULL;\r\n    struct fp_info *p_fp_info;\r\n    uint32_t length;\r\n    uint8_t frame_type;\r\n    uint32_t ft;\r\n\r\n    /* Trying to find existing conversation */\r\n    p_conv = (conversation_t *)find_conversation(pinfo->num, &pinfo->net_dst, &pinfo->net_src,\r\n        conversation_pt_to_conversation_type(pinfo->ptype),\r\n        pinfo->destport, pinfo->srcport, NO_ADDR_B);\r\n\r\n    /* Check if FP Conversation Info is attached */\r\n    if (p_conv != NULL) {\r\n        umts_fp_conversation_info = (umts_fp_conversation_info_t *)conversation_get_proto_data(p_conv, proto_fp);\r\n        if (umts_fp_conversation_info) {\r\n            if (umts_fp_conversation_info->channel == CHANNEL_UNKNOWN) {\r\n                /* This stream was framed using a previous control frame, we can call FP dissector without further tests*/\r\n                dissect_fp(tvb, pinfo, tree, data);\r\n                return true;\r\n            }\r\n            else {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    p_fp_info = (fp_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_fp, 0);\r\n\r\n    /* Check if per-frame FP Info is attached*/\r\n    if(p_fp_info) {\r\n        /* if FP info is present, check that it really is an ethernet link */\r\n        if (p_fp_info->link_type != FP_Link_Ethernet) {\r\n            return false;\r\n        }\r\n\r\n        /* discriminate 'lower' UDP layer from 'user data' UDP layer\r\n         * (i.e. if an FP over UDP packet contains a user UDP packet */\r\n        if (p_fp_info->srcport != pinfo->srcport ||\r\n            p_fp_info->destport != pinfo->destport)\r\n            return false;\r\n\r\n        /* assume this is FP */\r\n        dissect_fp(tvb, pinfo, tree, data);\r\n        return true;\r\n    }\r\n\r\n    /* Both per-frame FP info and conversation FP info are missing */\r\n    /* Try to frame control frames using header CRC */\r\n    ft = (tvb_get_uint8(tvb, 0) & 0x01);\r\n    if(ft != FT_CONTROL) {\r\n        /* This is a Data frame, can't tell if it's FP. */\r\n        return false;\r\n    }\r\n\r\n    length = tvb_captured_length(tvb);\r\n    /* Length limit: control frames header is 2 bytes */\r\n    if (length < 2) {\r\n        return false;\r\n    }\r\n\r\n    /* Check 'Frame Type' */\r\n    frame_type = tvb_get_uint8(tvb, 1);\r\n    /* 0x00 is unused for both dedicated & common FP */\r\n    if( frame_type == 0x00 ) {\r\n        return false;\r\n    }\r\n    /* Max frame types are: */\r\n    /* For common channels: 0x0E */\r\n    /* For dedicated channels: 0x0B */\r\n    /* The left nibble is zeroed in both cases */\r\n    if( (frame_type & 0xF0) != 0x00) {\r\n        return false;\r\n    }\r\n\r\n    /* Checking Header CRC*/\r\n    if (!check_control_frame_crc_for_heur(pinfo->pool, tvb)) {\r\n        /* The CRC is incorrect */\r\n        return false;\r\n    }\r\n\r\n    /* The CRC is correct! */\r\n    /* Attaching 'FP Conversation Info' to the UDP conversation so other */\r\n    /* packets (both Control AND Data) will be marked as FP */\r\n    umts_fp_conversation_info = wmem_new0(wmem_file_scope(), umts_fp_conversation_info_t);\r\n    umts_fp_conversation_info->channel = CHANNEL_UNKNOWN;\r\n    set_both_sides_umts_fp_conv_data(pinfo, umts_fp_conversation_info);\r\n    /* Call FP Dissector for the current frame */\r\n    dissect_fp(tvb, pinfo, tree, data);\r\n    return true;\r\n}", ".issect_rach_channel_info": "static void\r\ndissect_rach_channel_info(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\r\n                          int offset, struct fp_info *p_fp_info, void *data)\r\n{\r\n    uint32_t ft;\r\n    uint32_t header_crc = 0;\r\n    proto_item * header_crc_pi = NULL;\r\n    unsigned header_length;\r\n\r\n    /* Header CRC */\r\n    header_crc_pi = proto_tree_add_item_ret_uint(tree, hf_fp_header_crc, tvb, offset, 1, ENC_BIG_ENDIAN, &header_crc);\r\n\r\n    /* Frame Type */\r\n    proto_tree_add_item_ret_uint(tree, hf_fp_ft, tvb, offset, 1, ENC_BIG_ENDIAN, &ft);\r\n    offset++;\r\n\r\n    col_append_fstr(pinfo->cinfo, COL_INFO, \" [%s] \", val_to_str_const(ft, frame_type_vals, \"Unknown\"));\r\n\r\n    if (ft == FT_CONTROL) {\r\n        dissect_common_control(tvb, pinfo, tree, offset, p_fp_info);\r\n        /* For control frame the header CRC is actually frame CRC covering all\r\n         * bytes except the first */\r\n        if (preferences_header_checksum) {\r\n            verify_control_frame_crc(tvb, pinfo, header_crc_pi, (uint16_t)header_crc);\r\n        }\r\n    }\r\n    else {\r\n        uint8_t     cfn;\r\n        uint32_t    encoded;\r\n        uint32_t    propagation_delay                    = 0;\r\n        proto_item *propagation_delay_ti                 = NULL;\r\n        uint32_t    received_sync_ul_timing_deviation    = 0;\r\n        proto_item *received_sync_ul_timing_deviation_ti = NULL;\r\n        proto_item *rx_timing_deviation_ti               = NULL;\r\n        uint16_t    rx_timing_deviation                  = 0;\r\n\r\n        /* DATA */\r\n\r\n        /* CFN */\r\n        cfn = tvb_get_uint8(tvb, offset);\r\n        proto_tree_add_item(tree, hf_fp_cfn, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n        offset++;\r\n\r\n        col_append_fstr(pinfo->cinfo, COL_INFO, \"CFN=%03u \", cfn);\r\n\r\n        /* TFI */\r\n        proto_tree_add_item(tree, hf_fp_tfi, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n        offset++;\r\n\r\n        if (p_fp_info->channel == CHANNEL_RACH_FDD) {\r\n            /* Propagation delay */\r\n            encoded = tvb_get_uint8(tvb, offset);\r\n            propagation_delay = encoded * 3;\r\n            propagation_delay_ti = proto_tree_add_uint_format(tree, hf_fp_propagation_delay, tvb, offset, 1,\r\n                                               propagation_delay, \"Propagation Delay: %u chips (%u)\",\r\n                                               propagation_delay, encoded);\r\n            offset++;\r\n        }\r\n\r\n        /* Should be TDD 3.84 or 7.68 */\r\n        if (p_fp_info->channel == CHANNEL_RACH_TDD) {\r\n            /* Rx Timing Deviation */\r\n            rx_timing_deviation = tvb_get_uint8(tvb, offset);\r\n            rx_timing_deviation_ti = proto_tree_add_item(tree, hf_fp_rx_timing_deviation, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n            offset++;\r\n        }\r\n\r\n        if (p_fp_info->channel == CHANNEL_RACH_TDD_128) {\r\n            /* Received SYNC UL Timing Deviation */\r\n            received_sync_ul_timing_deviation = tvb_get_uint8(tvb, offset);\r\n            received_sync_ul_timing_deviation_ti =\r\n                 proto_tree_add_item(tree, hf_fp_received_sync_ul_timing_deviation, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n            offset++;\r\n        }\r\n\r\n        header_length = offset;\r\n\r\n        /* TB data */\r\n        offset = dissect_tb_data(tvb, pinfo, tree, offset, p_fp_info, &mac_fdd_rach_handle, data);\r\n\r\n        /* CRCIs */\r\n        offset = dissect_crci_bits(tvb, pinfo, tree, p_fp_info, offset);\r\n\r\n        /* Info introduced in R6 */\r\n        /* only check if it looks as if they are present */\r\n        if (((p_fp_info->release == 6) || (p_fp_info->release == 7)) &&\r\n            (tvb_reported_length_remaining(tvb, offset) > 2))\r\n        {\r\n            int n;\r\n            uint8_t flags;\r\n            /* uint8_t flag_bytes = 0; */\r\n\r\n            bool cell_portion_id_present                 = false;\r\n            bool ext_propagation_delay_present           = false;\r\n            bool angle_of_arrival_present                = false;\r\n            bool ext_rx_sync_ul_timing_deviation_present = false;\r\n            bool ext_rx_timing_deviation_present         = false;\r\n\r\n            /* New IE flags (assume mandatory for now) */\r\n            do {\r\n                proto_item *new_ie_flags_ti;\r\n                proto_tree *new_ie_flags_tree;\r\n                unsigned ies_found = 0;\r\n\r\n                /* Add new IE flags subtree */\r\n                new_ie_flags_ti = proto_tree_add_string_format(tree, hf_fp_rach_new_ie_flags, tvb, offset, 1,\r\n                                                              \"\", \"New IE flags\");\r\n                new_ie_flags_tree = proto_item_add_subtree(new_ie_flags_ti, ett_fp_rach_new_ie_flags);\r\n\r\n                /* Read next byte */\r\n                flags = tvb_get_uint8(tvb, offset);\r\n                /* flag_bytes++ */\r\n\r\n                /* Dissect individual bits */\r\n                for (n=0; n < 8; n++) {\r\n                    switch (n) {\r\n                        case 6:\r\n                            switch (p_fp_info->division) {\r\n                                case Division_FDD:\r\n                                    /* Ext propagation delay */\r\n                                    ext_propagation_delay_present = true;\r\n                                    proto_tree_add_item(new_ie_flags_tree, hf_fp_rach_ext_propagation_delay_present,\r\n                                                        tvb, offset, 1, ENC_BIG_ENDIAN);\r\n                                    break;\r\n                                case Division_TDD_128:\r\n                                    /* Ext Rx Sync UL Timing */\r\n                                    ext_rx_sync_ul_timing_deviation_present = true;\r\n                                    proto_tree_add_item(new_ie_flags_tree, hf_fp_rach_ext_rx_sync_ul_timing_deviation_present,\r\n                                                        tvb, offset, 1, ENC_BIG_ENDIAN);\r\n\r\n                                    break;\r\n                                default:\r\n                                    /* Not defined */\r\n                                    proto_tree_add_item(new_ie_flags_tree, hf_fp_rach_new_ie_flag_unused[6],\r\n                                                        tvb, offset, 1, ENC_BIG_ENDIAN);\r\n                                    break;\r\n                            }\r\n                            break;\r\n                        case 7:\r\n                            switch (p_fp_info->division) {\r\n                                case Division_FDD:\r\n                                    /* Cell Portion ID */\r\n                                    cell_portion_id_present = true;\r\n                                    proto_tree_add_item(new_ie_flags_tree, hf_fp_rach_cell_portion_id_present,\r\n                                                        tvb, offset, 1, ENC_BIG_ENDIAN);\r\n                                    break;\r\n                                case Division_TDD_128:\r\n                                    /* AOA */\r\n                                    angle_of_arrival_present = true;\r\n                                    proto_tree_add_item(new_ie_flags_tree, hf_fp_rach_angle_of_arrival_present,\r\n                                                        tvb, offset, 1, ENC_BIG_ENDIAN);\r\n                                    break;\r\n                                case Division_TDD_384:\r\n                                case Division_TDD_768:\r\n                                    /* Extended Rx Timing Deviation */\r\n                                    ext_rx_timing_deviation_present = true;\r\n                                    proto_tree_add_item(new_ie_flags_tree, hf_fp_rach_ext_rx_timing_deviation_present,\r\n                                                        tvb, offset, 1, ENC_BIG_ENDIAN);\r\n                                    break;\r\n                            }\r\n                            break;\r\n\r\n                        default:\r\n                            /* No defined meanings */\r\n                            /* Visual Studio Code Analyzer wrongly thinks n can be 7 here. It can't */\r\n                            proto_tree_add_item(new_ie_flags_tree, hf_fp_rach_new_ie_flag_unused[n],\r\n                                                tvb, offset, 1, ENC_BIG_ENDIAN);\r\n                            break;\r\n                    }\r\n                    if ((flags >> (7-n)) & 0x01) {\r\n                        ies_found++;\r\n                    }\r\n                }\r\n                offset++;\r\n\r\n                proto_item_append_text(new_ie_flags_ti, \" (%u IEs found)\", ies_found);\r\n\r\n                /* Last bit set will indicate another flags byte follows... */\r\n            } while (0); /*((flags & 0x01) && (flag_bytes < 31));*/\r\n\r\n            /* Cell Portion ID */\r\n            if (cell_portion_id_present) {\r\n                    proto_tree_add_item(tree, hf_fp_cell_portion_id, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n                    offset++;\r\n            }\r\n\r\n            /* Ext Rx Timing Deviation */\r\n            if (ext_rx_timing_deviation_present) {\r\n                uint8_t extra_bits;\r\n                unsigned bits_to_extend;\r\n                switch (p_fp_info->division) {\r\n                    case Division_TDD_384:\r\n                        bits_to_extend = 1;\r\n                        break;\r\n                    case Division_TDD_768:\r\n                        bits_to_extend = 2;\r\n                        break;\r\n\r\n                    default:\r\n                        /* TODO: report unexpected division type */\r\n                        bits_to_extend = 1;\r\n                        break;\r\n                }\r\n                extra_bits = tvb_get_uint8(tvb, offset) &\r\n                                 ((bits_to_extend == 1) ? 0x01 : 0x03);\r\n                rx_timing_deviation = (extra_bits << 8) | (rx_timing_deviation);\r\n                proto_item_append_text(rx_timing_deviation_ti,\r\n                                       \" (extended to 0x%x)\",\r\n                                       rx_timing_deviation);\r\n                proto_tree_add_bits_item(tree, hf_fp_extended_bits, tvb,\r\n                                         offset*8 + (8-bits_to_extend), bits_to_extend, ENC_BIG_ENDIAN);\r\n                offset++;\r\n            }\r\n\r\n            /* Ext propagation delay. */\r\n            if (ext_propagation_delay_present) {\r\n                uint16_t extra_bits = tvb_get_ntohs(tvb, offset) & 0x03ff;\r\n                proto_tree_add_item(tree, hf_fp_ext_propagation_delay, tvb, offset, 2, ENC_BIG_ENDIAN);\r\n\r\n                /* Adding 10 bits to original 8 */\r\n                proto_item_append_text(propagation_delay_ti, \" (extended to %u)\",\r\n                                       ((extra_bits << 8) | propagation_delay) * 3);\r\n                offset += 2;\r\n            }\r\n\r\n            /* Angle of Arrival (AOA) */\r\n            if (angle_of_arrival_present) {\r\n                proto_tree_add_item(tree, hf_fp_angle_of_arrival, tvb, offset, 2, ENC_BIG_ENDIAN);\r\n                offset += 2;\r\n            }\r\n\r\n            /* Ext. Rx Sync UL Timing Deviation */\r\n            if (ext_rx_sync_ul_timing_deviation_present) {\r\n                uint16_t extra_bits;\r\n\r\n                /* Ext received Sync UL Timing Deviation */\r\n                extra_bits = tvb_get_ntohs(tvb, offset) & 0x1fff;\r\n                proto_tree_add_item(tree, hf_fp_ext_received_sync_ul_timing_deviation, tvb, offset, 2, ENC_BIG_ENDIAN);\r\n\r\n                /* Adding 13 bits to original 8 */\r\n                proto_item_append_text(received_sync_ul_timing_deviation_ti, \" (extended to %u)\",\r\n                                       (extra_bits << 8) | received_sync_ul_timing_deviation);\r\n                offset += 2;\r\n            }\r\n        }\r\n        if (preferences_header_checksum) {\r\n            verify_header_crc(tvb, pinfo, header_crc_pi, header_crc, header_length);\r\n        }\r\n        /* Spare Extension and Payload CRC */\r\n        dissect_spare_extension_and_crc(tvb, pinfo, tree, 1, offset, header_length);\r\n    }\r\n}", ".issect_dch_channel_info": "static void\r\ndissect_dch_channel_info(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\r\n                         int offset, struct fp_info *p_fp_info, void *data)\r\n{\r\n    uint32_t ft;\r\n    uint32_t  cfn;\r\n    unsigned header_length;\r\n    uint32_t header_crc = 0;\r\n    proto_item * header_crc_pi = NULL;\r\n\r\n    /* Header CRC */\r\n    header_crc_pi = proto_tree_add_item_ret_uint(tree, hf_fp_header_crc, tvb, offset, 1, ENC_BIG_ENDIAN, &header_crc);\r\n\r\n    /* Frame Type */\r\n    proto_tree_add_item_ret_uint(tree, hf_fp_ft, tvb, offset, 1, ENC_BIG_ENDIAN, &ft);\r\n    offset++;\r\n\r\n    col_append_str(pinfo->cinfo, COL_INFO,\r\n                   (ft == FT_CONTROL )? \" [Control] \" :\r\n                                       ((p_fp_info->is_uplink) ? \" [ULData] \" :\r\n                                                                 \" [DLData] \" ));\r\n\r\n    if (ft == FT_CONTROL) {\r\n        /* DCH control frame */\r\n        dissect_dch_control_frame(tree, pinfo, tvb, offset, p_fp_info);\r\n        /* For control frame the header CRC is actually frame CRC covering all\r\n         * bytes except the first */\r\n        if (preferences_header_checksum) {\r\n            verify_control_frame_crc(tvb, pinfo, header_crc_pi, (uint16_t)header_crc);\r\n        }\r\n    } else {\r\n        /************************/\r\n        /* DCH data here        */\r\n        int chan;\r\n        /* CFN */\r\n        proto_tree_add_item_ret_uint(tree, hf_fp_cfn, tvb, offset, 1, ENC_BIG_ENDIAN, &cfn);\r\n        offset++;\r\n\r\n        col_append_fstr(pinfo->cinfo, COL_INFO, \"CFN=%03u \", cfn);\r\n\r\n        /* One TFI for each channel */\r\n        for (chan=0; chan < p_fp_info->num_chans; chan++) {\r\n            proto_tree_add_item(tree, hf_fp_tfi, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n            offset++;\r\n        }\r\n        header_length = offset;\r\n        /* Dissect TB data */\r\n        offset = dissect_tb_data(tvb, pinfo, tree, offset, p_fp_info, &mac_fdd_dch_handle, data);\r\n\r\n        /* QE and CRCI bits (uplink only) */\r\n        if (p_fp_info->is_uplink) {\r\n            proto_tree_add_item(tree, hf_fp_quality_estimate, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n            offset++;\r\n            offset = dissect_crci_bits(tvb, pinfo, tree, p_fp_info, offset);\r\n        }\r\n\r\n        if (preferences_header_checksum) {\r\n            verify_header_crc(tvb, pinfo, header_crc_pi, header_crc, header_length);\r\n        }\r\n        /* Spare extension and payload CRC (optional) */\r\n        dissect_spare_extension_and_crc(tvb, pinfo, tree,\r\n                                        p_fp_info->dch_crc_present, offset, header_length);\r\n    }\r\n}", ".issect_fach_channel_info": "static void\r\ndissect_fach_channel_info(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\r\n                          int offset, struct fp_info *p_fp_info, void *data)\r\n{\r\n    uint32_t ft;\r\n    uint32_t header_crc = 0;\r\n    proto_item * header_crc_pi = NULL;\r\n    unsigned header_length;\r\n\r\n    /* Header CRC */\r\n    header_crc_pi = proto_tree_add_item_ret_uint(tree, hf_fp_header_crc, tvb, offset, 1, ENC_BIG_ENDIAN, &header_crc);\r\n\r\n    /* Frame Type */\r\n    proto_tree_add_item_ret_uint(tree, hf_fp_ft, tvb, offset, 1, ENC_BIG_ENDIAN, &ft);\r\n    offset++;\r\n\r\n    col_append_fstr(pinfo->cinfo, COL_INFO, \" [%s] \", val_to_str_const(ft, frame_type_vals, \"Unknown\"));\r\n\r\n    if (ft == FT_CONTROL) {\r\n        dissect_common_control(tvb, pinfo, tree, offset, p_fp_info);\r\n        /* For control frame the header CRC is actually frame CRC covering all\r\n         * bytes except the first */\r\n        if (preferences_header_checksum) {\r\n            verify_control_frame_crc(tvb, pinfo, header_crc_pi, (uint16_t)header_crc);\r\n        }\r\n    }\r\n    else {\r\n        uint8_t cfn;\r\n        /* DATA */\r\n\r\n        /* CFN */\r\n        cfn = tvb_get_uint8(tvb, offset);\r\n        proto_tree_add_item(tree, hf_fp_cfn, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n        offset++;\r\n\r\n        col_append_fstr(pinfo->cinfo, COL_INFO, \"CFN=%03u \", cfn);\r\n\r\n        /* TFI */\r\n        proto_tree_add_item(tree, hf_fp_fach_tfi, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n        offset++;\r\n\r\n        /* Transmit power level */\r\n        proto_tree_add_float(tree, hf_fp_transmit_power_level, tvb, offset, 1,\r\n                             (float)(int)(tvb_get_uint8(tvb, offset)) / 10);\r\n        offset++;\r\n        header_length = offset;\r\n\r\n        /* TB data */\r\n        offset = dissect_tb_data(tvb, pinfo, tree, offset, p_fp_info, &mac_fdd_fach_handle, data);\r\n\r\n        /* New IE flags (if it looks as though they are present) */\r\n        if ((p_fp_info->release == 7) &&\r\n            (tvb_reported_length_remaining(tvb, offset) > 2)) {\r\n\r\n            uint8_t flags = tvb_get_uint8(tvb, offset);\r\n            uint8_t aoa_present = flags & 0x01;\r\n            offset++;\r\n\r\n            if (aoa_present) {\r\n                proto_tree_add_item(tree, hf_fp_angle_of_arrival, tvb, offset, 2, ENC_BIG_ENDIAN);\r\n                offset += 2;\r\n            }\r\n        }\r\n        if (preferences_header_checksum) {\r\n            verify_header_crc(tvb, pinfo, header_crc_pi, header_crc, header_length);\r\n        }\r\n        /* Spare Extension and Payload CRC */\r\n        dissect_spare_extension_and_crc(tvb, pinfo, tree, 1, offset, header_length);\r\n    }\r\n}", ".issect_dsch_channel_info": "static void\r\ndissect_dsch_channel_info(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\r\n                          int offset, struct fp_info *p_fp_info)\r\n{\r\n    uint32_t ft;\r\n\r\n    /* Header CRC */\r\n    proto_tree_add_item(tree, hf_fp_header_crc, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n\r\n    /* Frame Type */\r\n    proto_tree_add_item_ret_uint(tree, hf_fp_ft, tvb, offset, 1, ENC_BIG_ENDIAN, &ft);\r\n    offset++;\r\n\r\n    col_append_fstr(pinfo->cinfo, COL_INFO, \" [%s] \", val_to_str_const(ft, frame_type_vals, \"Unknown\"));\r\n\r\n    if (ft == FT_CONTROL) {\r\n        dissect_common_control(tvb, pinfo, tree, offset, p_fp_info);\r\n    }\r\n    else {\r\n        uint32_t cfn;\r\n        unsigned header_length = 0;\r\n\r\n        /* DATA */\r\n\r\n        /* CFN */\r\n        proto_tree_add_item_ret_uint(tree, hf_fp_cfn, tvb, offset, 1, ENC_BIG_ENDIAN, &cfn);\r\n        offset++;\r\n\r\n        col_append_fstr(pinfo->cinfo, COL_INFO, \"CFN=%03u \", cfn);\r\n\r\n        /* TFI */\r\n        proto_tree_add_item(tree, hf_fp_tfi, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n        offset++;\r\n\r\n\r\n        /* Other fields depend upon release & FDD/TDD settings */\r\n        if (((p_fp_info->release == 99) || (p_fp_info->release == 4)) &&\r\n             (p_fp_info->channel == CHANNEL_DSCH_FDD)) {\r\n\r\n            /* Power offset */\r\n            proto_tree_add_float(tree, hf_fp_power_offset, tvb, offset, 1,\r\n                                 (float)(-32.0) +\r\n                                  ((float)(int)(tvb_get_uint8(tvb, offset)) * (float)(0.25)));\r\n            offset++;\r\n\r\n            /* Code number */\r\n            proto_tree_add_item(tree, hf_fp_code_number, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n            offset++;\r\n\r\n            /* Spreading Factor (3 bits) */\r\n            proto_tree_add_item(tree, hf_fp_spreading_factor, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n\r\n            /* MC info (4 bits)*/\r\n            proto_tree_add_item(tree, hf_fp_mc_info, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n\r\n            /* Last bit of this byte is spare */\r\n            offset++;\r\n        }\r\n        else {\r\n            /* Normal case */\r\n\r\n            /* PDSCH Set Id */\r\n            proto_tree_add_item(tree, hf_fp_pdsch_set_id, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n            offset++;\r\n\r\n            /* Transmit power level */\r\n            proto_tree_add_float(tree, hf_fp_transmit_power_level, tvb, offset, 1,\r\n                                 (float)(int)(tvb_get_uint8(tvb, offset)) / 10);\r\n            offset++;\r\n        }\r\n        header_length = offset;\r\n        /* TB data */\r\n        offset = dissect_tb_data(tvb, pinfo, tree, offset, p_fp_info, NULL, NULL);\r\n\r\n        /* Spare Extension and Payload CRC */\r\n        dissect_spare_extension_and_crc(tvb, pinfo, tree, 1, offset, header_length);\r\n    }\r\n}", ".issect_usch_channel_info": "static void\r\ndissect_usch_channel_info(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\r\n                          int offset, struct fp_info *p_fp_info)\r\n{\r\n    uint32_t ft;\r\n\r\n    /* Header CRC */\r\n    proto_tree_add_item(tree, hf_fp_header_crc, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n\r\n    /* Frame Type */\r\n    proto_tree_add_item_ret_uint(tree, hf_fp_ft, tvb, offset, 1, ENC_BIG_ENDIAN, &ft);\r\n    offset++;\r\n\r\n    col_append_fstr(pinfo->cinfo, COL_INFO, \" [%s] \", val_to_str_const(ft, frame_type_vals, \"Unknown\"));\r\n\r\n    if (ft == FT_CONTROL) {\r\n        dissect_common_control(tvb, pinfo, tree, offset, p_fp_info);\r\n    }\r\n    else {\r\n        unsigned cfn;\r\n        uint16_t rx_timing_deviation;\r\n        proto_item *rx_timing_deviation_ti;\r\n        unsigned header_length = 0;\r\n\r\n        /* DATA */\r\n\r\n        /* CFN */\r\n        proto_tree_add_item_ret_uint(tree, hf_fp_cfn, tvb, offset, 1, ENC_BIG_ENDIAN, &cfn);\r\n        offset++;\r\n\r\n        col_append_fstr(pinfo->cinfo, COL_INFO, \"CFN=%03u \", cfn);\r\n\r\n        /* TFI */\r\n        proto_tree_add_item(tree, hf_fp_usch_tfi, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n        offset++;\r\n\r\n        /* Rx Timing Deviation */\r\n        rx_timing_deviation = tvb_get_uint8(tvb, offset);\r\n        rx_timing_deviation_ti = proto_tree_add_item(tree, hf_fp_rx_timing_deviation,\r\n                                                     tvb, offset, 1, ENC_BIG_ENDIAN);\r\n        offset++;\r\n        header_length = offset;\r\n        /* TB data */\r\n        offset = dissect_tb_data(tvb, pinfo, tree, offset, p_fp_info, NULL, NULL);\r\n\r\n        /* QE */\r\n        proto_tree_add_item(tree, hf_fp_quality_estimate, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n        offset++;\r\n\r\n        /* CRCIs */\r\n        offset = dissect_crci_bits(tvb, pinfo, tree, p_fp_info, offset);\r\n\r\n        /* New IEs */\r\n        if ((p_fp_info->release == 7) &&\r\n            (tvb_reported_length_remaining(tvb, offset) > 2)) {\r\n\r\n            uint8_t flags = tvb_get_uint8(tvb, offset);\r\n            uint8_t bits_extended = flags & 0x01;\r\n            offset++;\r\n\r\n            if (bits_extended) {\r\n                uint8_t extra_bits = tvb_get_uint8(tvb, offset) & 0x03;\r\n                proto_item_append_text(rx_timing_deviation_ti,\r\n                                       \" (extended to %u)\",\r\n                                       (rx_timing_deviation << 2) | extra_bits);\r\n            }\r\n            offset++;\r\n        }\r\n\r\n        /* Spare Extension and Payload CRC */\r\n        dissect_spare_extension_and_crc(tvb, pinfo, tree, 1, offset, header_length);\r\n    }\r\n}", ".issect_pch_channel_info": "static void\r\ndissect_pch_channel_info(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\r\n                         int offset, struct fp_info *p_fp_info, void *data)\r\n{\r\n    uint32_t ft;\r\n    uint16_t pch_cfn;\r\n    uint32_t tfi;\r\n    bool paging_indication;\r\n    uint32_t header_crc = 0;\r\n    proto_item * header_crc_pi = NULL;\r\n\r\n    /* Header CRC */\r\n    header_crc_pi = proto_tree_add_item_ret_uint(tree, hf_fp_header_crc, tvb, offset, 1, ENC_BIG_ENDIAN, &header_crc);\r\n\r\n    /* Frame Type */\r\n    proto_tree_add_item_ret_uint(tree, hf_fp_ft, tvb, offset, 1, ENC_BIG_ENDIAN, &ft);\r\n    offset++;\r\n\r\n    col_append_fstr(pinfo->cinfo, COL_INFO, \" [%s] \", val_to_str_const(ft, frame_type_vals, \"Unknown\"));\r\n\r\n    if (ft == FT_CONTROL) {\r\n        dissect_common_control(tvb, pinfo, tree, offset, p_fp_info);\r\n        /* For control frame the header CRC is actually frame CRC covering all\r\n         * bytes except the first */\r\n        if (preferences_header_checksum) {\r\n            verify_control_frame_crc(tvb, pinfo, header_crc_pi, (uint16_t)header_crc);\r\n        }\r\n    }\r\n    else {\r\n        unsigned header_length = 0;\r\n        /* DATA */\r\n\r\n        /* 12-bit CFN value */\r\n        proto_tree_add_item(tree, hf_fp_pch_cfn, tvb, offset, 2, ENC_BIG_ENDIAN);\r\n        pch_cfn = (tvb_get_ntohs(tvb, offset) & 0xfff0) >> 4;\r\n        offset++;\r\n\r\n        col_append_fstr(pinfo->cinfo, COL_INFO, \"CFN=%04u \", pch_cfn);\r\n\r\n        /* Paging indication */\r\n        proto_tree_add_item(tree, hf_fp_pch_pi, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n        paging_indication = tvb_get_uint8(tvb, offset) & 0x01;\r\n        offset++;\r\n\r\n        /* 5-bit TFI */\r\n        proto_tree_add_item_ret_uint(tree, hf_fp_pch_tfi, tvb, offset, 1, ENC_BIG_ENDIAN, &tfi);\r\n        offset++;\r\n        header_length = offset;\r\n        /* Optional paging indications */\r\n        if (paging_indication) {\r\n            proto_item *ti;\r\n            ti = proto_tree_add_item(tree, hf_fp_paging_indication_bitmap, tvb,\r\n                                     offset,\r\n                                     (p_fp_info->paging_indications+7) / 8,\r\n                                     ENC_NA);\r\n            proto_item_append_text(ti, \" (%u bits)\", p_fp_info->paging_indications);\r\n\r\n            if(preferences_track_paging_indications && !PINFO_FD_VISITED(pinfo)){\r\n                paging_indications_info_t* current_pi_info;\r\n                current_pi_info = wmem_new0(wmem_file_scope(), paging_indications_info_t);\r\n                current_pi_info->frame_number = pinfo->num;\r\n                current_pi_info->paging_indications_bitmap = (uint8_t*)tvb_memdup(wmem_file_scope(), tvb, offset, (p_fp_info->paging_indications+7) / 8);\r\n                p_fp_info->current_paging_indications = current_pi_info;\r\n            }\r\n\r\n            offset += ((p_fp_info->paging_indications+7) / 8);\r\n        }\r\n        if(preferences_track_paging_indications) {\r\n            if(p_fp_info->relevant_paging_indications) {\r\n                /*If tracking PI is enabled and PI info (from the last packet) is attached, show on tree*/\r\n                proto_item *ti;\r\n                proto_tree *relevant_pi_tree;\r\n\r\n                tvbuff_t *pi_tvb;\r\n                pi_tvb = tvb_new_child_real_data(tvb,\r\n                                                 p_fp_info->relevant_paging_indications->paging_indications_bitmap,\r\n                                                 (p_fp_info->paging_indications+7) / 8,\r\n                                                 (p_fp_info->paging_indications+7) / 8);\r\n                add_new_data_source(pinfo, pi_tvb, \"Relevant Paging Indication\");\r\n                ti = proto_tree_add_item(tree, hf_fp_relevant_paging_indication_bitmap, pi_tvb,\r\n                                         0,\r\n                                         (p_fp_info->paging_indications+7) / 8,\r\n                                         ENC_NA);\r\n                proto_item_append_text(ti, \" (%u bits)\", p_fp_info->paging_indications);\r\n                proto_item_set_generated(ti);\r\n                relevant_pi_tree = proto_item_add_subtree(ti, ett_fp_pch_relevant_pi);\r\n                ti = proto_tree_add_uint(relevant_pi_tree, hf_fp_relevant_pi_frame,\r\n                                                           tvb, 0, 0, p_fp_info->relevant_paging_indications->frame_number);\r\n                proto_item_set_generated(ti);\r\n            }\r\n            else {\r\n                /* PI info not attached. Check if this frame has any Transport Blocks (i.e. RRC payloads) */\r\n                if(tfi > 0)\r\n                {\r\n                    /* This frame has RRC payload(s) but the PI info is missing, report to the user*/\r\n                    proto_tree_add_expert(tree, pinfo, &ei_fp_pch_lost_relevant_pi_frame, tvb, offset, -1);\r\n                }\r\n            }\r\n        }\r\n\r\n        /* TB data */\r\n        offset = dissect_tb_data(tvb, pinfo, tree, offset, p_fp_info, &mac_fdd_pch_handle, data);\r\n\r\n        if (preferences_header_checksum) {\r\n            verify_header_crc(tvb, pinfo, header_crc_pi, header_crc, header_length);\r\n        }\r\n        /* Spare Extension and Payload CRC */\r\n        dissect_spare_extension_and_crc(tvb, pinfo, tree, 1, offset, header_length);\r\n    }\r\n}", ".pdate_pch_coversation_info": "static void\r\nupdate_pch_coversation_info(umts_fp_conversation_info_t *p_conv_data, packet_info *pinfo, struct fp_info *p_fp_info)\r\n{\r\n    fp_pch_channel_info_t* fp_pch_channel_info;\r\n    /* The channel type MUST be set to PCH */\r\n    DISSECTOR_ASSERT(p_conv_data);\r\n    DISSECTOR_ASSERT(p_conv_data->channel == CHANNEL_PCH);\r\n\r\n    fp_pch_channel_info = (fp_pch_channel_info_t*)p_conv_data->channel_specific_info;\r\n    if(p_fp_info->current_paging_indications && !PINFO_FD_VISITED(pinfo))\r\n    {\r\n        /* Saving the PI info for the next packet to find */\r\n        fp_pch_channel_info->last_paging_indication_info = p_fp_info->current_paging_indications;\r\n        /* Resetting this field so we don't add it again to the conversation next time the packet is parsed */\r\n        p_fp_info->current_paging_indications = NULL;\r\n    }\r\n}", ".issect_cpch_channel_info": "static void\r\ndissect_cpch_channel_info(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\r\n                          int offset, struct fp_info *p_fp_info)\r\n{\r\n    uint32_t ft;\r\n\r\n    /* Header CRC */\r\n    proto_tree_add_item(tree, hf_fp_header_crc, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n\r\n    /* Frame Type */\r\n    proto_tree_add_item_ret_uint(tree, hf_fp_ft, tvb, offset, 1, ENC_BIG_ENDIAN, &ft);\r\n    offset++;\r\n\r\n    col_append_fstr(pinfo->cinfo, COL_INFO, \" [%s] \", val_to_str_const(ft, frame_type_vals, \"Unknown\"));\r\n\r\n    if (ft == FT_CONTROL) {\r\n        dissect_common_control(tvb, pinfo, tree, offset, p_fp_info);\r\n    }\r\n    else {\r\n        unsigned cfn;\r\n        uint32_t encoded;\r\n        unsigned header_length = 0;\r\n        uint32_t propagation_delay = 0;\r\n\r\n        /* DATA */\r\n\r\n        /* CFN */\r\n        proto_tree_add_item_ret_uint(tree, hf_fp_cfn, tvb, offset, 1, ENC_BIG_ENDIAN, &cfn);\r\n        offset++;\r\n\r\n        col_append_fstr(pinfo->cinfo, COL_INFO, \"CFN=%03u \", cfn);\r\n\r\n        /* TFI */\r\n        proto_tree_add_item(tree, hf_fp_cpch_tfi, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n        offset++;\r\n\r\n        /* Propagation delay */\r\n        encoded = tvb_get_uint8(tvb, offset);\r\n        propagation_delay = encoded * 3;\r\n        proto_tree_add_uint_format_value(tree, hf_fp_propagation_delay, tvb, offset, 1,\r\n                                               propagation_delay, \"Propagation Delay: %u chips (%u)\",\r\n                                               propagation_delay, encoded);\r\n        offset++;\r\n        header_length = offset; /* XXX this might be wrong */\r\n        /* TB data */\r\n        offset = dissect_tb_data(tvb, pinfo, tree, offset, p_fp_info, NULL, NULL);\r\n\r\n        /* CRCIs */\r\n        offset = dissect_crci_bits(tvb, pinfo, tree, p_fp_info, offset);\r\n\r\n        /* Spare Extension and Payload CRC */\r\n        dissect_spare_extension_and_crc(tvb, pinfo, tree, 1, offset, header_length);\r\n    }\r\n}", ".issect_bch_channel_info": "static void\r\ndissect_bch_channel_info(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\r\n                         int offset, struct fp_info *p_fp_info)\r\n{\r\n    uint32_t ft;\r\n\r\n    /* Header CRC */\r\n    proto_tree_add_item(tree, hf_fp_header_crc, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n\r\n    /* Frame Type */\r\n    proto_tree_add_item_ret_uint(tree, hf_fp_ft, tvb, offset, 1, ENC_BIG_ENDIAN, &ft);\r\n    offset++;\r\n\r\n    col_append_fstr(pinfo->cinfo, COL_INFO, \" [%s] \", val_to_str_const(ft, frame_type_vals, \"Unknown\"));\r\n\r\n    if (ft == FT_CONTROL) {\r\n        dissect_common_control(tvb, pinfo, tree, offset, p_fp_info);\r\n    }\r\n}", ".issect_hsdsch_channel_info": "static void\r\ndissect_hsdsch_channel_info(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\r\n                            int offset, struct fp_info *p_fp_info, void *data)\r\n{\r\n    uint32_t ft;\r\n    unsigned header_length;\r\n    uint32_t header_crc = 0;\r\n    proto_item * header_crc_pi = NULL;\r\n\r\n    /* Header CRC */\r\n    header_crc_pi = proto_tree_add_item_ret_uint(tree, hf_fp_header_crc, tvb, offset, 1, ENC_BIG_ENDIAN, &header_crc);\r\n\r\n    /* Frame Type */\r\n    proto_tree_add_item_ret_uint(tree, hf_fp_ft, tvb, offset, 1, ENC_BIG_ENDIAN, &ft);\r\n    offset++;\r\n\r\n    col_append_fstr(pinfo->cinfo, COL_INFO, \" [%s] \", val_to_str_const(ft, frame_type_vals, \"Unknown\"));\r\n\r\n    if (ft == FT_CONTROL) {\r\n        dissect_common_control(tvb, pinfo, tree, offset, p_fp_info);\r\n        /* For control frame the header CRC is actually frame CRC covering all\r\n         * bytes except the first */\r\n        if (preferences_header_checksum) {\r\n            verify_control_frame_crc(tvb, pinfo, header_crc_pi, (uint16_t)header_crc);\r\n        }\r\n    }\r\n    else {\r\n        uint8_t number_of_pdus;\r\n        uint16_t pdu_length;\r\n        uint16_t user_buffer_size;\r\n        int i;\r\n        umts_mac_info *macinf;\r\n        rlc_info *rlcinf;\r\n        uint32_t user_identity;\r\n        proto_item *item;\r\n\r\n        rlcinf = (rlc_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_umts_rlc, 0);\r\n        if (!rlcinf) {\r\n            rlcinf = wmem_new0(pinfo->pool, rlc_info);\r\n        }\r\n        macinf = (umts_mac_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_umts_mac, 0);\r\n        if (!macinf) {\r\n            macinf = wmem_new0(pinfo->pool, umts_mac_info);\r\n        }\r\n\r\n        /**************************************/\r\n        /* HS-DCH data here (type 1 in R7)    */\r\n\r\n        /* Frame Seq Nr */\r\n        if ((p_fp_info->release == 6) ||\r\n            (p_fp_info->release == 7)) {\r\n\r\n            uint8_t frame_seq_no = (tvb_get_uint8(tvb, offset) & 0xf0) >> 4;\r\n            proto_tree_add_item(tree, hf_fp_frame_seq_nr, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n\r\n            col_append_fstr(pinfo->cinfo, COL_INFO, \"  seqno=%u\", frame_seq_no);\r\n        }\r\n\r\n        /* CmCH-PI */\r\n        proto_tree_add_item(tree, hf_fp_cmch_pi, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n        offset++;\r\n\r\n        /* MAC-d PDU Length (13 bits) */\r\n        pdu_length = (tvb_get_ntohs(tvb, offset) >> 3);\r\n        proto_tree_add_item(tree, hf_fp_mac_d_pdu_len, tvb, offset, 2, ENC_BIG_ENDIAN);\r\n        offset += 2;\r\n        macinf->pdu_len = pdu_length;\r\n\r\n        if ((p_fp_info->release == 6) ||\r\n            (p_fp_info->release == 7)) {\r\n\r\n            /* Flush bit */\r\n            proto_tree_add_item(tree, hf_fp_flush, tvb, offset-1, 1, ENC_BIG_ENDIAN);\r\n\r\n            /* FSN/DRT reset bit */\r\n            proto_tree_add_item(tree, hf_fp_fsn_drt_reset, tvb, offset-1, 1, ENC_BIG_ENDIAN);\r\n        }\r\n\r\n        /* Num of PDUs */\r\n        number_of_pdus = tvb_get_uint8(tvb, offset);\r\n        item = proto_tree_add_item(tree, hf_fp_num_of_pdu, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n        offset++;\r\n        if (number_of_pdus > MAX_MAC_FRAMES) {\r\n            expert_add_info_format(pinfo, item, &ei_fp_invalid_frame_count, \"Invalid number of PDUs (max is %u)\", MAX_MAC_FRAMES);\r\n            return;\r\n        }\r\n\r\n        /* User buffer size */\r\n        user_buffer_size = tvb_get_ntohs(tvb, offset);\r\n        proto_tree_add_item(tree, hf_fp_user_buffer_size, tvb, offset, 2, ENC_BIG_ENDIAN);\r\n        offset += 2;\r\n\r\n        header_length = offset;\r\n\r\n\r\n        /* Determine the UE ID to use in RLC */\r\n        user_identity = p_fp_info->com_context_id;\r\n        if(p_fp_info->urnti) {\r\n            user_identity = p_fp_info->urnti;\r\n        }\r\n        /************************/\r\n        /*Configure the pdus*/\r\n        for (i=0;i<number_of_pdus && i<MIN(MAX_MAC_FRAMES, MAX_RLC_CHANS); i++) {\r\n            macinf->content[i] = hsdsch_macdflow_id_mac_content_map[p_fp_info->hsdsch_macflowd_id]; /*MAC_CONTENT_PS_DTCH;*/\r\n            macinf->lchid[i] = fake_lchid_macd_flow[p_fp_info->hsdsch_macflowd_id];/*Faked logical channel id 255 used as a mark if it doesn't exist...*/\r\n            macinf->fake_chid[i] = true;    /**/\r\n            macinf->macdflow_id[i] = p_fp_info->hsdsch_macflowd_id;    /*Save the flow ID (+1 to make it human readable (it's zero indexed!))*/\r\n\r\n            /*Check if this is multiplexed (signaled by RRC)*/\r\n            if (p_fp_info->hsdhsch_macfdlow_is_mux[p_fp_info->hsdsch_macflowd_id] ) {\r\n                macinf->ctmux[i] = true;\r\n            } else if (p_fp_info->hsdsch_macflowd_id == 0) {              /*MACd-flow = 0 is often SRB */\r\n                expert_add_info(pinfo, NULL, &ei_fp_maybe_srb);\r\n            } else {\r\n                    macinf->ctmux[i] = false;    /*Either it's multiplexed and not signalled or it's not MUX*/\r\n            }\r\n\r\n            /* Figure out RLC mode */\r\n            if(p_fp_info->hsdsch_rlc_mode != FP_RLC_MODE_UNKNOWN) {\r\n                /* We know the RLC mode, possibly reported from NBAP */\r\n                rlcinf->mode[i] = (enum rlc_mode)(p_fp_info->hsdsch_rlc_mode - 1);\r\n            }\r\n            else {\r\n                /* Guess the mode by the MACd-flow-ID, basically MACd-flow-ID = 0 then it's SRB0 == UM else AM */\r\n                /* This logic might be incorrect sometimes */\r\n                rlcinf->mode[i] = hsdsch_macdflow_id_rlc_map[p_fp_info->hsdsch_macflowd_id];\r\n            }\r\n\r\n            rlcinf->ueid[i] = user_identity;\r\n            rlcinf->li_size[i] = RLC_LI_7BITS;\r\n            rlcinf->deciphered[i] = false;\r\n            rlcinf->ciphered[i] = false;\r\n            rlcinf->rbid[i] = macinf->lchid[i];\r\n\r\n#if 0\r\n            /*When a flow has been reconfigured rlc needs to be reset.\r\n             * This needs more work though since we must figure out when the re-configuration becomes\r\n             * active based on the CFN value\r\n             * */\r\n            /*Indicate we need to reset stream*/\r\n            if (p_fp_info->reset_frag) {\r\n                rlc_reset_channel(rlcinf->mode[i], macinf->lchid[i], p_fp_info->is_uplink,  rlcinf->ueid[i] );\r\n                p_fp_info->reset_frag = false;\r\n\r\n            }\r\n#endif\r\n        }\r\n\r\n        col_append_fstr(pinfo->cinfo, COL_INFO, \"  %ux%u-bit PDUs  User-Buffer-Size=%u\",\r\n                        number_of_pdus, pdu_length, user_buffer_size);\r\n\r\n        /* MAC-d PDUs */\r\n        offset = dissect_macd_pdu_data(tvb, pinfo, tree, offset, pdu_length,\r\n                                       number_of_pdus, p_fp_info, data);\r\n\r\n        /* Extra IEs (if there is room for them) */\r\n        if (((p_fp_info->release == 6) ||\r\n             (p_fp_info->release == 7)) &&\r\n            (tvb_reported_length_remaining(tvb, offset) > 2)) {\r\n\r\n            int n;\r\n            uint8_t flags;\r\n            /* uint8_t flag_bytes = 0; */\r\n\r\n            /* New IE flags */\r\n            do {\r\n                proto_item *new_ie_flags_ti;\r\n                proto_tree *new_ie_flags_tree;\r\n                unsigned ies_found = 0;\r\n\r\n                /* Add new IE flags subtree */\r\n                new_ie_flags_ti = proto_tree_add_string_format(tree, hf_fp_hsdsch_new_ie_flags, tvb, offset, 1,\r\n                                                              \"\", \"New IE flags\");\r\n                new_ie_flags_tree = proto_item_add_subtree(new_ie_flags_ti, ett_fp_hsdsch_new_ie_flags);\r\n\r\n                /* Read next byte */\r\n                flags = tvb_get_uint8(tvb, offset);\r\n                /* flag_bytes++; */\r\n\r\n                /* Dissect individual bits */\r\n                for (n=0; n < 8; n++) {\r\n                    proto_tree_add_item(new_ie_flags_tree, hf_fp_hsdsch_new_ie_flag[n], tvb, offset, 1, ENC_BIG_ENDIAN);\r\n                    if ((flags >> (7-n)) & 0x01) {\r\n                        ies_found++;\r\n                    }\r\n                }\r\n                offset++;\r\n\r\n                proto_item_append_text(new_ie_flags_ti, \" (%u IEs found)\", ies_found);\r\n\r\n                /* Last bit set will indicate another flags byte follows... */\r\n            } while (0); /*((flags & 0x01) && (flag_bytes < 31));*/\r\n\r\n            if (1) /*(flags & 0x8) */ {\r\n                /* DRT is shown as mandatory in the diagram (3GPP TS 25.435 V6.3.0),\r\n                   but the description below it states that\r\n                   it should depend upon the first bit.  The detailed description of\r\n                   New IE flags doesn't agree, so treat as mandatory for now... */\r\n                proto_tree_add_item(tree, hf_fp_hsdsch_drt, tvb, offset, 2, ENC_BIG_ENDIAN);\r\n                offset += 2;\r\n            }\r\n        }\r\n        if (preferences_header_checksum) {\r\n            verify_header_crc(tvb, pinfo, header_crc_pi, header_crc, header_length);\r\n        }\r\n        /* Spare Extension and Payload CRC */\r\n        dissect_spare_extension_and_crc(tvb, pinfo, tree, 1, offset, header_length);\r\n    }\r\n}", ".issect_hsdsch_type_2_channel_info": "static void\r\ndissect_hsdsch_type_2_channel_info(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\r\n                                   int offset, struct fp_info *p_fp_info,\r\n                                   void *data)\r\n{\r\n    uint32_t ft;\r\n    uint32_t header_crc = 0;\r\n    proto_item * header_crc_pi = NULL;\r\n    uint16_t header_length;\r\n\r\n    /* Header CRC */\r\n    header_crc_pi = proto_tree_add_item_ret_uint(tree, hf_fp_header_crc, tvb, offset, 1, ENC_BIG_ENDIAN, &header_crc);\r\n\r\n    /* Frame Type */\r\n    proto_tree_add_item_ret_uint(tree, hf_fp_ft, tvb, offset, 1, ENC_BIG_ENDIAN, &ft);\r\n    offset++;\r\n\r\n    col_append_fstr(pinfo->cinfo, COL_INFO, \" [%s] \", val_to_str_const(ft, frame_type_vals, \"Unknown\"));\r\n\r\n    if (ft == FT_CONTROL) {\r\n        dissect_common_control(tvb, pinfo, tree, offset, p_fp_info);\r\n        /* For control frame the header CRC is actually frame CRC covering all\r\n         * bytes except the first */\r\n        if (preferences_header_checksum) {\r\n            verify_control_frame_crc(tvb, pinfo, header_crc_pi, (uint16_t)header_crc);\r\n        }\r\n    }\r\n    else {\r\n        uint8_t number_of_pdu_blocks;\r\n        bool drt_present = false;\r\n        bool fach_present = false;\r\n        uint16_t user_buffer_size;\r\n        int n;\r\n        unsigned j;\r\n        uint64_t lchid_val;\r\n\r\n        #define MAX_PDU_BLOCKS 31\r\n        uint64_t lchid_field[MAX_PDU_BLOCKS];\r\n        uint64_t pdu_length[MAX_PDU_BLOCKS];\r\n        uint64_t no_of_pdus[MAX_PDU_BLOCKS];\r\n\r\n        umts_mac_info *macinf;\r\n        rlc_info *rlcinf;\r\n        uint32_t user_identity;\r\n\r\n        rlcinf = (rlc_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_umts_rlc, 0);\r\n        if (!rlcinf) {\r\n            rlcinf = wmem_new0(pinfo->pool, rlc_info);\r\n        }\r\n        macinf = (umts_mac_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_umts_mac, 0);\r\n        if (!macinf) {\r\n            macinf = wmem_new0(pinfo->pool, umts_mac_info);\r\n        }\r\n\r\n        /********************************/\r\n        /* HS-DCH type 2 data here      */\r\n\r\n        col_append_str(pinfo->cinfo, COL_INFO, \"(ehs)\");\r\n\r\n        /* Frame Seq Nr (4 bits) */\r\n        if ((p_fp_info->release == 6) ||\r\n            (p_fp_info->release == 7)) {\r\n\r\n            uint8_t frame_seq_no = (tvb_get_uint8(tvb, offset) & 0xf0) >> 4;\r\n            proto_tree_add_item(tree, hf_fp_frame_seq_nr, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n\r\n            col_append_fstr(pinfo->cinfo, COL_INFO, \"  seqno=%u\", frame_seq_no);\r\n        }\r\n\r\n        /* CmCH-PI (4 bits) */\r\n        proto_tree_add_item(tree, hf_fp_cmch_pi, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n        offset++;\r\n\r\n        /* Total number of PDU blocks (5 bits) */\r\n        number_of_pdu_blocks = (tvb_get_uint8(tvb, offset) >> 3);\r\n        proto_tree_add_item(tree, hf_fp_total_pdu_blocks, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n\r\n        if (p_fp_info->release == 7) {\r\n            /* Flush bit */\r\n            proto_tree_add_item(tree, hf_fp_flush, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n\r\n            /* FSN/DRT reset bit */\r\n            proto_tree_add_item(tree, hf_fp_fsn_drt_reset, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n\r\n            /* DRT Indicator */\r\n            drt_present = tvb_get_uint8(tvb, offset) & 0x01;\r\n            proto_tree_add_item(tree, hf_fp_drt_indicator, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n        }\r\n        offset++;\r\n\r\n        /* FACH Indicator flag */\r\n        fach_present = (tvb_get_uint8(tvb, offset) & 0x80) >> 7;\r\n        proto_tree_add_item(tree, hf_fp_fach_indicator, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n        offset++;\r\n\r\n        /* User buffer size */\r\n        user_buffer_size = tvb_get_ntohs(tvb, offset);\r\n        proto_tree_add_item(tree, hf_fp_user_buffer_size, tvb, offset, 2, ENC_BIG_ENDIAN);\r\n        offset += 2;\r\n\r\n        col_append_fstr(pinfo->cinfo, COL_INFO, \"  User-Buffer-Size=%u\", user_buffer_size);\r\n\r\n\r\n\r\n        /********************************************************************/\r\n        /* Now read number_of_pdu_blocks header entries                     */\r\n        for (n=0; n < number_of_pdu_blocks; n++) {\r\n            proto_item *pdu_block_header_ti;\r\n            proto_tree *pdu_block_header_tree;\r\n            int        block_header_start_offset = offset;\r\n\r\n            /* Add PDU block header subtree */\r\n            pdu_block_header_ti = proto_tree_add_string_format(tree, hf_fp_hsdsch_pdu_block_header,\r\n                                                               tvb, offset, 0,\r\n                                                               \"\",\r\n                                                               \"PDU Block Header\");\r\n            pdu_block_header_tree = proto_item_add_subtree(pdu_block_header_ti,\r\n                                                           ett_fp_hsdsch_pdu_block_header);\r\n\r\n            /* MAC-d/c PDU length in this block (11 bits) */\r\n            proto_tree_add_bits_ret_val(pdu_block_header_tree, hf_fp_pdu_length_in_block, tvb,\r\n                                        (offset*8) + ((n % 2) ? 4 : 0), 11,\r\n                                        &pdu_length[n], ENC_BIG_ENDIAN);\r\n            if ((n % 2) == 0)\r\n                offset++;\r\n            else\r\n                offset += 2;\r\n\r\n\r\n            /* # PDUs in this block (4 bits) */\r\n            proto_tree_add_bits_ret_val(pdu_block_header_tree, hf_fp_pdus_in_block, tvb,\r\n                                        (offset*8) + ((n % 2) ? 0 : 4), 4,\r\n                                        &no_of_pdus[n], ENC_BIG_ENDIAN);\r\n            if ((n % 2) == 0) {\r\n                offset++;\r\n            }\r\n\r\n            /* Logical channel ID in block (4 bits) */\r\n            proto_tree_add_bits_ret_val(pdu_block_header_tree, hf_fp_lchid, tvb,\r\n                                        (offset*8) + ((n % 2) ? 4 : 0), 4,\r\n                                        &lchid_field[n], ENC_BIG_ENDIAN);\r\n            if ((n % 2) == 1) {\r\n                offset++;\r\n            }\r\n            else {\r\n                if (n == (number_of_pdu_blocks-1)) {\r\n                    /* Byte is padded out for last block */\r\n                    offset++;\r\n                }\r\n            }\r\n\r\n            /* Append summary to header tree root */\r\n            proto_item_append_text(pdu_block_header_ti,\r\n                                   \" (lch:%u, %u pdus of %u bytes)\",\r\n                                   (uint16_t)lchid_field[n],\r\n                                   (uint16_t)no_of_pdus[n],\r\n                                   (uint16_t)pdu_length[n]);\r\n\r\n            /* Set length of header tree item */\r\n            if (((n % 2) == 0) && (n < (number_of_pdu_blocks-1))) {\r\n                proto_item_set_len(pdu_block_header_ti,\r\n                                   offset - block_header_start_offset+1);\r\n            }\r\n            else {\r\n                proto_item_set_len(pdu_block_header_ti,\r\n                                   offset - block_header_start_offset);\r\n            }\r\n        }\r\n\r\n        header_length = offset;\r\n\r\n        /**********************************************/\r\n        /* Optional fields indicated by earlier flags */\r\n        if (drt_present) {\r\n            /* DRT */\r\n            proto_tree_add_item(tree, hf_fp_drt, tvb, offset, 2, ENC_BIG_ENDIAN);\r\n            offset += 2;\r\n        }\r\n\r\n        if (fach_present) {\r\n            /* H-RNTI: */\r\n            proto_tree_add_item(tree, hf_fp_hrnti, tvb, offset, 2, ENC_BIG_ENDIAN);\r\n            offset += 2;\r\n\r\n            /* RACH Measurement Result */\r\n            proto_tree_add_item(tree, hf_fp_rach_measurement_result, tvb, offset, 2, ENC_BIG_ENDIAN);\r\n            offset++;\r\n        }\r\n\r\n\r\n        /* Determine the UE ID to use in RLC */\r\n        user_identity = p_fp_info->com_context_id;\r\n        if(p_fp_info->urnti) {\r\n            user_identity = p_fp_info->urnti;\r\n        }\r\n        /********************************************************************/\r\n        /* Now read the MAC-d/c PDUs for each block using info from headers */\r\n        for (n=0; n < number_of_pdu_blocks; n++) {\r\n            for (j=0;j<no_of_pdus[n];j++) {\r\n\r\n                /*Configure (signal to lower layers) the PDU!*/\r\n                if (lchid_field[n] != 0x0f) {\r\n                    lchid_val = lchid_field[n] + 1; /* Add 1 since 'LCHID' field is zero indexed. ie field value = 0 => Actual L-CHID = 1*/\r\n                    macinf->content[j] = lchId_type_table[lchid_val];\r\n                    macinf->lchid[j] = (uint8_t)lchid_val;\r\n                    macinf->macdflow_id[j] = p_fp_info->hsdsch_macflowd_id;\r\n                    /*Figure out RLC_MODE based on MACd-flow-ID, basically MACd-flow-ID = 0 then it's SRB0 == UM else AM*/\r\n                    rlcinf->mode[j] = lchId_rlc_map[lchid_val];\r\n\r\n                    macinf->ctmux[n] = false;\r\n\r\n                    rlcinf->li_size[j] = RLC_LI_7BITS;\r\n                    rlcinf->ciphered[j] = false;\r\n                    rlcinf->deciphered[j] = false;\r\n                    rlcinf->rbid[j] = (uint8_t)lchid_val;\r\n\r\n                    rlcinf->ueid[j] = user_identity;\r\n                }\r\n                else {\r\n                    /* LCHID field is 15. This value indicates BCCH or PCCH mapped on HS-DSCH*/\r\n                    /* The dissector does not handle this case yet, so we are filling zeroes and default values below*/\r\n                    macinf->content[j] = MAC_CONTENT_UNKNOWN;\r\n                    macinf->lchid[j] = 0; /* LCHID field doesn't reflect a real ID in this case*/\r\n                    macinf->macdflow_id[j] = 0;\r\n                    macinf->ctmux[j] = false;\r\n\r\n                    rlcinf->mode[j] = RLC_TM; /* PCCH and BCCH should be using RLC TM? */\r\n                    rlcinf->li_size[j] = RLC_LI_7BITS;\r\n                    rlcinf->ciphered[j] = false;\r\n                    rlcinf->deciphered[j] = false;\r\n                    rlcinf->rbid[j] = 0;\r\n                    rlcinf->ueid[j] = 0;\r\n                }\r\n            }\r\n\r\n            /* Add PDU block header subtree */\r\n            offset = dissect_macd_pdu_data_type_2(tvb, pinfo, tree, offset,\r\n                                                  (uint16_t)pdu_length[n],\r\n                                                  (uint16_t)no_of_pdus[n],\r\n                                                  p_fp_info, data);\r\n        }\r\n        if (preferences_header_checksum) {\r\n            verify_header_crc(tvb, pinfo, header_crc_pi, header_crc, header_length);\r\n        }\r\n        /* Spare Extension and Payload CRC */\r\n        dissect_spare_extension_and_crc(tvb, pinfo, tree, 1, offset, header_length);\r\n    }\r\n}", ".issect_hsdsch_common_channel_info": "static\r\nvoid dissect_hsdsch_common_channel_info(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\r\n                                        int offset, struct fp_info *p_fp_info,\r\n                                        void *data)\r\n{\r\n    uint32_t ft;\r\n    uint32_t header_crc = 0;\r\n    proto_item * header_crc_pi = NULL;\r\n    unsigned header_length;\r\n\r\n    /* Header CRC */\r\n    header_crc_pi = proto_tree_add_item_ret_uint(tree, hf_fp_header_crc, tvb, offset, 1, ENC_BIG_ENDIAN, &header_crc);\r\n\r\n    /* Frame Type */\r\n    proto_tree_add_item_ret_uint(tree, hf_fp_ft, tvb, offset, 1, ENC_BIG_ENDIAN, &ft);\r\n    offset++;\r\n\r\n    col_append_fstr(pinfo->cinfo, COL_INFO, \" [%s] \", val_to_str_const(ft, frame_type_vals, \"Unknown\"));\r\n\r\n    if (ft == FT_CONTROL) {\r\n        dissect_common_control(tvb, pinfo, tree, offset, p_fp_info);\r\n        /* For control frame the header CRC is actually frame CRC covering all\r\n         * bytes except the first */\r\n        if (preferences_header_checksum) {\r\n            verify_control_frame_crc(tvb, pinfo, header_crc_pi, (uint16_t)header_crc);\r\n        }\r\n    }\r\n    else {\r\n        uint8_t number_of_pdu_blocks;\r\n        bool drt_present = false;\r\n        bool fach_present = false;\r\n        uint16_t user_buffer_size;\r\n        int n;\r\n        unsigned j;\r\n\r\n        #define MAX_PDU_BLOCKS 31\r\n        uint64_t lchid[MAX_PDU_BLOCKS];\r\n        uint64_t pdu_length[MAX_PDU_BLOCKS];\r\n        uint64_t no_of_pdus[MAX_PDU_BLOCKS];\r\n        uint8_t newieflags = 0;\r\n\r\n        umts_mac_info *macinf;\r\n        rlc_info *rlcinf;\r\n\r\n        rlcinf = (rlc_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_umts_rlc, 0);\r\n        if (!rlcinf) {\r\n            rlcinf = wmem_new0(pinfo->pool, rlc_info);\r\n        }\r\n        macinf = (umts_mac_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_umts_mac, 0);\r\n        if (!macinf) {\r\n            macinf = wmem_new0(pinfo->pool, umts_mac_info);\r\n        }\r\n        /********************************/\r\n        /* HS-DCH type 2 data here      */\r\n\r\n        col_append_str(pinfo->cinfo, COL_INFO, \"(ehs)\");\r\n\r\n        /* Frame Seq Nr (4 bits) */\r\n        if ((p_fp_info->release == 6) ||\r\n            (p_fp_info->release == 7)) {\r\n\r\n            uint8_t frame_seq_no = (tvb_get_uint8(tvb, offset) & 0xf0) >> 4;\r\n            proto_tree_add_item(tree, hf_fp_frame_seq_nr, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n\r\n            col_append_fstr(pinfo->cinfo, COL_INFO, \"  seqno=%u\", frame_seq_no);\r\n        }\r\n\r\n        /* CmCH-PI (4 bits) */\r\n        proto_tree_add_item(tree, hf_fp_cmch_pi, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n        offset++;\r\n\r\n        /* Total number of PDU blocks (5 bits) */\r\n        number_of_pdu_blocks = (tvb_get_uint8(tvb, offset) >> 3);\r\n        proto_tree_add_item(tree, hf_fp_total_pdu_blocks, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n\r\n        if (p_fp_info->release == 7) {\r\n            /* Flush bit */\r\n            proto_tree_add_item(tree, hf_fp_flush, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n\r\n            /* FSN/DRT reset bit */\r\n            proto_tree_add_item(tree, hf_fp_fsn_drt_reset, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n\r\n            /* DRT Indicator */\r\n            drt_present = tvb_get_uint8(tvb, offset) & 0x01;\r\n            proto_tree_add_item(tree, hf_fp_drt_indicator, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n        }\r\n        offset++;\r\n\r\n        /* FACH Indicator flag */\r\n        fach_present = (tvb_get_uint8(tvb, offset) & 0x80) >> 7;\r\n        proto_tree_add_item(tree, hf_fp_fach_indicator, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n        offset++;\r\n\r\n        /* User buffer size */\r\n        user_buffer_size = tvb_get_ntohs(tvb, offset);\r\n        proto_tree_add_item(tree, hf_fp_user_buffer_size, tvb, offset, 2, ENC_BIG_ENDIAN);\r\n        offset += 2;\r\n\r\n        col_append_fstr(pinfo->cinfo, COL_INFO, \"  User-Buffer-Size=%u\", user_buffer_size);\r\n\r\n\r\n        /********************************************************************/\r\n        /* Now read number_of_pdu_blocks header entries                     */\r\n        for (n=0; n < number_of_pdu_blocks; n++) {\r\n            proto_item *pdu_block_header_ti;\r\n            proto_item *item;\r\n            proto_tree *pdu_block_header_tree;\r\n            int        block_header_start_offset = offset;\r\n\r\n            /* Add PDU block header subtree */\r\n            pdu_block_header_ti = proto_tree_add_string_format(tree, hf_fp_hsdsch_pdu_block_header,\r\n                                                               tvb, offset, 0,\r\n                                                               \"\",\r\n                                                               \"PDU Block Header\");\r\n            pdu_block_header_tree = proto_item_add_subtree(pdu_block_header_ti,\r\n                                                           ett_fp_hsdsch_pdu_block_header);\r\n\r\n            /* MAC-d/c PDU length in this block (11 bits) */\r\n            proto_tree_add_bits_ret_val(pdu_block_header_tree, hf_fp_pdu_length_in_block, tvb,\r\n                                        (offset*8) + ((n % 2) ? 4 : 0), 11,\r\n                                        &pdu_length[n], ENC_BIG_ENDIAN);\r\n            if ((n % 2) == 0)\r\n                offset++;\r\n            else\r\n                offset += 2;\r\n\r\n\r\n            /* # PDUs in this block (4 bits) */\r\n            item = proto_tree_add_bits_ret_val(pdu_block_header_tree, hf_fp_pdus_in_block, tvb,\r\n                                        (offset*8) + ((n % 2) ? 0 : 4), 4,\r\n                                        &no_of_pdus[n], ENC_BIG_ENDIAN);\r\n            if ((n % 2) == 0) {\r\n                offset++;\r\n            }\r\n            if (no_of_pdus[n] > MAX_MAC_FRAMES) {\r\n                expert_add_info_format(pinfo, item, &ei_fp_invalid_frame_count, \"Invalid number of PDUs (max is %u)\", MAX_MAC_FRAMES);\r\n                return;\r\n            }\r\n\r\n            /* Logical channel ID in block (4 bits) */\r\n            proto_tree_add_bits_ret_val(pdu_block_header_tree, hf_fp_lchid, tvb,\r\n                                        (offset*8) + ((n % 2) ? 4 : 0), 4,\r\n                                        &lchid[n], ENC_BIG_ENDIAN);\r\n            if ((n % 2) == 1) {\r\n                offset++;\r\n            }\r\n            else {\r\n                if (n == (number_of_pdu_blocks-1)) {\r\n                    /* Byte is padded out for last block */\r\n                    offset++;\r\n                }\r\n            }\r\n\r\n            /* Append summary to header tree root */\r\n            proto_item_append_text(pdu_block_header_ti,\r\n                                   \" (lch:%u, %u pdus of %u bytes)\",\r\n                                   (uint16_t)lchid[n],\r\n                                   (uint16_t)no_of_pdus[n],\r\n                                   (uint16_t)pdu_length[n]);\r\n\r\n            /* Set length of header tree item */\r\n            if (((n % 2) == 0) && (n < (number_of_pdu_blocks-1))) {\r\n                proto_item_set_len(pdu_block_header_ti,\r\n                                   offset - block_header_start_offset+1);\r\n            }\r\n            else {\r\n                proto_item_set_len(pdu_block_header_ti,\r\n                                   offset - block_header_start_offset);\r\n            }\r\n        }\r\n\r\n        header_length = offset;\r\n\r\n        /**********************************************/\r\n        /* Optional fields indicated by earlier flags */\r\n        if (drt_present) {\r\n            /* DRT */\r\n            proto_tree_add_item(tree, hf_fp_drt, tvb, offset, 2, ENC_BIG_ENDIAN);\r\n            offset += 2;\r\n        }\r\n\r\n        if (fach_present) {\r\n            /* H-RNTI: */\r\n            proto_tree_add_item(tree, hf_fp_hrnti, tvb, offset, 2, ENC_BIG_ENDIAN);\r\n            offset += 2;\r\n\r\n            /* RACH Measurement Result */\r\n            proto_tree_add_item(tree, hf_fp_rach_measurement_result, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n            offset++;\r\n        }\r\n\r\n        /********************************************************************/\r\n        /* Now read the MAC-d/c PDUs for each block using info from headers */\r\n        for (n=0; n < number_of_pdu_blocks; n++) {\r\n            tvbuff_t *next_tvb;\r\n            for (j=0; j<no_of_pdus[n]; j++) {\r\n                /* If all bits are set, then this is BCCH or PCCH according to: 25.435 paragraph: 6.2.7.31 */\r\n                if (lchid[n] == 0xF) {\r\n                    /* In the very few test cases I've seen, this seems to be\r\n                     * BCCH with transparent MAC layer. Therefore skip right to\r\n                     * rlc_bcch and hope for the best. */\r\n                    next_tvb = tvb_new_subset_length(tvb, offset, (int)pdu_length[n]);\r\n                    call_dissector_with_data(rlc_bcch_handle, next_tvb, pinfo, top_level_tree, data);\r\n                    offset += (int)pdu_length[n];\r\n                } else { /* Else go for CCCH UM, this seems to work. */\r\n                    p_fp_info->hsdsch_entity = ehs; /* HSDSCH type 2 */\r\n                    if (j >= MAX_MAC_FRAMES) {\r\n                        /* Should not happen as we check no_of_pdus[n]*/\r\n                        expert_add_info_format(pinfo, tree, &ei_fp_invalid_frame_count, \"Invalid frame count (max is %u)\", MAX_MAC_FRAMES);\r\n                        return;\r\n                    }\r\n                    p_fp_info->cur_tb = j; /* set cur_tb for MAC and RRC */\r\n                    macinf->content[j] = MAC_CONTENT_CCCH;\r\n                    macinf->lchid[j] = (uint8_t)lchid[n]+1; /*Add 1 since it is zero indexed? */\r\n                    macinf->macdflow_id[j] = p_fp_info->hsdsch_macflowd_id;\r\n                    macinf->ctmux[j] = false;\r\n\r\n                    rlcinf->li_size[j] = RLC_LI_7BITS;\r\n                    rlcinf->ciphered[j] = false;\r\n                    rlcinf->deciphered[j] = false;\r\n                    rlcinf->rbid[j] = (uint8_t)lchid[n]+1;\r\n                    rlcinf->ueid[j] = p_fp_info->channel; /*We need to fake \"UE ID\"*/\r\n\r\n                    next_tvb = tvb_new_subset_length(tvb, offset, (int)pdu_length[n]);\r\n                    call_dissector_with_data(mac_fdd_hsdsch_handle, next_tvb, pinfo, top_level_tree, data);\r\n\r\n                    offset += (int)pdu_length[n];\r\n                }\r\n            }\r\n        }\r\n\r\n        /* New IE Flags */\r\n        newieflags = tvb_get_uint8(tvb, offset);\r\n        /* If newieflags == 0000 0010 then this indicates that there is a\r\n         * HS-DSCH physical layer category and no other New IE flags. */\r\n        if (newieflags == 2) {\r\n            /* HS-DSCH physical layer category presence bit. */\r\n            proto_tree_add_uint(tree, hf_fp_hsdsch_new_ie_flag[6], tvb, offset, 1, newieflags);\r\n            offset++;\r\n            /* HS-DSCH physical layer category. */\r\n            proto_tree_add_bits_item(tree, hf_fp_hsdsch_physical_layer_category, tvb, offset*8, 6, ENC_BIG_ENDIAN);\r\n            offset++;\r\n        }\r\n        if (preferences_header_checksum) {\r\n            verify_header_crc(tvb, pinfo, header_crc_pi, header_crc, header_length);\r\n        }\r\n        /* Spare Extension and Payload CRC */\r\n        dissect_spare_extension_and_crc(tvb, pinfo, tree, 1, offset, header_length);\r\n    }\r\n}", ".issect_iur_dsch_channel_info": "static void\r\ndissect_iur_dsch_channel_info(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\r\n                              int offset, struct fp_info *p_fp_info)\r\n{\r\n    uint32_t ft;\r\n\r\n    /* Header CRC */\r\n    proto_tree_add_item(tree, hf_fp_header_crc, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n\r\n    /* Frame Type */\r\n    proto_tree_add_item_ret_uint(tree, hf_fp_ft, tvb, offset, 1, ENC_BIG_ENDIAN, &ft);\r\n    offset++;\r\n\r\n    col_append_fstr(pinfo->cinfo, COL_INFO, \" [%s] \", val_to_str_const(ft, frame_type_vals, \"Unknown\"));\r\n\r\n    if (ft == FT_CONTROL) {\r\n        dissect_common_control(tvb, pinfo, tree, offset, p_fp_info);\r\n    }\r\n    else {\r\n        /* TODO: DATA */\r\n    }\r\n}", ".issect_e_dch_channel_info": "static void\r\ndissect_e_dch_channel_info(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\r\n                           int offset, struct fp_info *p_fp_info,\r\n                           bool is_common,\r\n                           void *data)\r\n{\r\n    uint32_t ft;\r\n    uint8_t  number_of_subframes;\r\n    uint32_t cfn;\r\n    int      n;\r\n    struct   edch_t1_subframe_info subframes[16];\r\n    uint32_t header_crc = 0;\r\n    proto_item * header_crc_pi = NULL;\r\n    proto_item * item;\r\n    unsigned header_length;\r\n    rlc_info * rlcinf;\r\n\r\n    if (p_fp_info->edch_type == 1) {\r\n        col_append_str(pinfo->cinfo, COL_INFO, \" (T2)\");\r\n    }\r\n\r\n    /* Header CRC */\r\n     /* the bitmask doesn't properly handle this delicate case, do manually */\r\n    header_crc = (tvb_get_bits8(tvb, offset*8, 7) << 4) + tvb_get_bits8(tvb, offset*8+8, 4);\r\n\r\n    /* Frame Type */\r\n    ft = tvb_get_uint8(tvb, offset) & 0x01;\r\n\r\n    col_append_fstr(pinfo->cinfo, COL_INFO, \" [%s] \", val_to_str_const(ft, frame_type_vals, \"Unknown\"));\r\n\r\n    if (ft == FT_CONTROL) {\r\n        /* DCH control frame */\r\n\r\n        /* For control frame the header CRC is actually frame CRC covering all\r\n         * bytes except the first */\r\n        header_crc_pi = proto_tree_add_item_ret_uint(tree, hf_fp_header_crc, tvb, offset, 1, ENC_BIG_ENDIAN, &header_crc);\r\n        proto_tree_add_item(tree, hf_fp_ft, tvb, 0, 1, ENC_BIG_ENDIAN);\r\n        offset++;\r\n        if (preferences_header_checksum) {\r\n            verify_control_frame_crc(tvb, pinfo, header_crc_pi, (uint16_t)header_crc);\r\n        }\r\n        dissect_dch_control_frame(tree, pinfo, tvb, offset, p_fp_info);\r\n    }\r\n    else {\r\n        /********************************/\r\n        /* E-DCH data here              */\r\n        unsigned  bit_offset;\r\n        unsigned  total_pdus = 0;\r\n        unsigned  total_bits = 0;\r\n        bool dissected = false;\r\n\r\n        rlcinf = (rlc_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_umts_rlc, 0);\r\n        if (!rlcinf) {\r\n            rlcinf = wmem_new0(pinfo->pool, rlc_info);\r\n        }\r\n\r\n        header_crc_pi = proto_tree_add_uint_format(tree, hf_fp_edch_header_crc, tvb,\r\n                offset, 2, header_crc,\r\n                \"%u%u%u%u %u%u%u. %u%u%u%u .... = E-DCH Header CRC: 0x%x\",\r\n                (header_crc >> 10) & 1,\r\n                (header_crc >> 9) & 1,\r\n                (header_crc >> 8) & 1,\r\n                (header_crc >> 7) & 1,\r\n                (header_crc >> 6) & 1,\r\n                (header_crc >> 5) & 1,\r\n                (header_crc >> 4) & 1,\r\n                (header_crc >> 3) & 1,\r\n                (header_crc >> 2) & 1,\r\n                (header_crc >> 1) & 1,\r\n                (header_crc >> 0) & 1, header_crc);\r\n        proto_tree_add_item(tree, hf_fp_ft, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n        offset++;\r\n        /* FSN */\r\n        proto_tree_add_item(tree, hf_fp_edch_fsn, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n        offset++;\r\n\r\n        /* Number of subframes.\r\n           This was 3 bits in early releases, is 4 bits offset by 1 in later releases  */\r\n        if ((p_fp_info->release >= 6) &&\r\n            ((p_fp_info->release_year > 2005) ||\r\n             ((p_fp_info->release_year == 2005) && (p_fp_info->release_month >= 9)))) {\r\n\r\n            /* Use 4 bits plus offset of 1 */\r\n            number_of_subframes = (tvb_get_uint8(tvb, offset) & 0x0f) + 1;\r\n        }\r\n        else {\r\n            /* Use 3 bits only */\r\n            number_of_subframes = (tvb_get_uint8(tvb, offset) & 0x07);\r\n        }\r\n        proto_tree_add_uint(tree, hf_fp_edch_number_of_subframes, tvb, offset, 1,\r\n                            number_of_subframes);\r\n\r\n        offset++;\r\n\r\n        /* CFN */\r\n        proto_tree_add_item_ret_uint(tree, hf_fp_cfn, tvb, offset, 1, ENC_BIG_ENDIAN, &cfn);\r\n        offset++;\r\n\r\n        /* Remainder of T2 or common data frames differ here... */\r\n        if (p_fp_info->edch_type == 1) {\r\n            dissect_e_dch_t2_or_common_channel_info(tvb, pinfo, tree, offset, p_fp_info,\r\n                                                    number_of_subframes,\r\n                                                    is_common, header_crc,\r\n                                                    header_crc_pi, data);\r\n            return;\r\n        }\r\n\r\n        /* EDCH subframe header list */\r\n        for (n=0; n < number_of_subframes; n++) {\r\n            int i;\r\n            int start_offset = offset;\r\n            proto_item *subframe_header_ti;\r\n            proto_tree *subframe_header_tree;\r\n\r\n            /* Add subframe header subtree */\r\n            subframe_header_ti = proto_tree_add_string_format(tree, hf_fp_edch_subframe_header, tvb, offset, 0,\r\n                                                              \"\", \"Subframe\");\r\n            subframe_header_tree = proto_item_add_subtree(subframe_header_ti, ett_fp_edch_subframe_header);\r\n\r\n            /* Number of HARQ Retransmissions */\r\n            proto_tree_add_item(subframe_header_tree, hf_fp_edch_harq_retransmissions, tvb,\r\n                                offset, 1, ENC_BIG_ENDIAN);\r\n\r\n            /* Subframe number */\r\n            subframes[n].subframe_number = (tvb_get_uint8(tvb, offset) & 0x07);\r\n            proto_tree_add_bits_item(subframe_header_tree, hf_fp_edch_subframe_number, tvb,\r\n                                     offset*8+5, 3, ENC_BIG_ENDIAN);\r\n            offset++;\r\n\r\n            /* Number of MAC-es PDUs */\r\n            subframes[n].number_of_mac_es_pdus = (tvb_get_uint8(tvb, offset) & 0xf0) >> 4;\r\n            proto_tree_add_item(subframe_header_tree, hf_fp_edch_number_of_mac_es_pdus,\r\n                                tvb, offset, 1, ENC_BIG_ENDIAN);\r\n            bit_offset = 4;\r\n\r\n            proto_item_append_text(subframe_header_ti, \" %u header (%u MAC-es PDUs)\",\r\n                                   subframes[n].subframe_number,\r\n                                   subframes[n].number_of_mac_es_pdus);\r\n\r\n            /* Details of each MAC-es PDU */\r\n            for (i=0; i < subframes[n].number_of_mac_es_pdus; i++) {\r\n                uint64_t ddi;\r\n                uint64_t n_pdus;    /*Size of the PDU*/\r\n\r\n                proto_item *ddi_ti;\r\n                int ddi_size = -1;\r\n                int     p;\r\n\r\n                /* DDI (6 bits) */\r\n                ddi_ti = proto_tree_add_bits_ret_val(subframe_header_tree, hf_fp_edch_ddi, tvb,\r\n                                                     offset*8 + bit_offset, 6, &ddi, ENC_BIG_ENDIAN);\r\n\r\n                rlcinf->rbid[i] = (uint8_t)ddi;\r\n                /********************************/\r\n                /* Look up data in higher layers*/\r\n                /* Look up the size from this DDI value */\r\n                for (p=0; p < p_fp_info->no_ddi_entries; p++) {\r\n                    if (ddi == p_fp_info->edch_ddi[p]) {\r\n                        ddi_size = p_fp_info->edch_macd_pdu_size[p];\r\n\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                if (ddi_size == -1) {\r\n                    expert_add_info_format(pinfo, ddi_ti, &ei_fp_ddi_not_defined, \"DDI %u not defined for this UE!\", (unsigned)ddi);\r\n                    return;\r\n                }\r\n                else {\r\n                    proto_item_append_text(ddi_ti, \" (%d bits)\", ddi_size);\r\n                }\r\n\r\n                subframes[n].ddi[i] = (uint8_t)ddi;\r\n                bit_offset += 6;\r\n\r\n                /* Number of MAC-d PDUs (6 bits) */\r\n                item = proto_tree_add_bits_ret_val(subframe_header_tree, hf_fp_edch_number_of_mac_d_pdus, tvb,\r\n                                            offset*8 + bit_offset, 6, &n_pdus, ENC_BIG_ENDIAN);\r\n                if (n_pdus > MAX_MAC_FRAMES) {\r\n                    expert_add_info_format(pinfo, item, &ei_fp_invalid_frame_count, \"Invalid number of PDUs (max is %u)\", MAX_MAC_FRAMES);\r\n                    return;\r\n                }\r\n\r\n                subframes[n].number_of_mac_d_pdus[i] = (uint8_t)n_pdus;\r\n                bit_offset += 6;\r\n            }\r\n\r\n            offset += ((bit_offset+7)/8);\r\n\r\n            /* Tree should cover entire subframe header */\r\n            proto_item_set_len(subframe_header_ti, offset - start_offset);\r\n        }\r\n        header_length = offset;\r\n        /* EDCH subframes */\r\n        for (n=0; n < number_of_subframes; n++) {\r\n            int i;\r\n            proto_item *subframe_ti;\r\n            proto_tree *subframe_tree;\r\n            unsigned bits_in_subframe = 0;\r\n            unsigned mac_d_pdus_in_subframe = 0;\r\n            unsigned lchid=0;    /*Logical channel id*/\r\n            uint32_t user_identity;\r\n            umts_mac_info *macinf;\r\n            bit_offset = 0;\r\n\r\n            macinf = (umts_mac_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_umts_mac, 0);\r\n            if (!macinf) {\r\n                macinf = wmem_new0(pinfo->pool, umts_mac_info);\r\n            }\r\n            /* Add subframe subtree */\r\n            subframe_ti = proto_tree_add_string_format(tree, hf_fp_edch_subframe, tvb, offset, 0,\r\n                                                       \"\", \"Subframe %u data\", subframes[n].subframe_number);\r\n            subframe_tree = proto_item_add_subtree(subframe_ti, ett_fp_edch_subframe);\r\n\r\n            for (i=0; i < subframes[n].number_of_mac_es_pdus; i++) {\r\n                int         m;\r\n                uint16_t    size = 0;\r\n                /* uint8_t     tsn; */\r\n                unsigned    send_size;\r\n                proto_item  *ti;\r\n                int         macd_idx;\r\n                proto_tree  *maces_tree = NULL;\r\n\r\n                /** TODO: Merge these two loops? **/\r\n                /* Look up mac-d pdu size for this ddi */\r\n                for (m=0; m < p_fp_info->no_ddi_entries; m++) {\r\n                    if (subframes[n].ddi[i] == p_fp_info->edch_ddi[m]) {\r\n                        size = p_fp_info->edch_macd_pdu_size[m];\r\n                        break;\r\n                    }\r\n                }\r\n                /* Look up logicalchannel id for this DDI value */\r\n                for (m=0; m < p_fp_info->no_ddi_entries; m++) {\r\n                    if (subframes[n].ddi[i] == p_fp_info->edch_ddi[m]) {\r\n                        lchid = p_fp_info->edch_lchId[m];\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                if (m == p_fp_info->no_ddi_entries) {\r\n                    /* Not found.  Oops */\r\n                    expert_add_info(pinfo, NULL, &ei_fp_unable_to_locate_ddi_entry);\r\n                    return;\r\n                }\r\n\r\n                /* Send MAC-dd PDUs together as one MAC-es PDU */\r\n                send_size = size * subframes[n].number_of_mac_d_pdus[i];\r\n\r\n                /* 2 bits spare */\r\n                proto_tree_add_item(subframe_tree, hf_fp_edch_pdu_padding, tvb,\r\n                                    offset + (bit_offset/8),\r\n                                    1, ENC_BIG_ENDIAN);\r\n                bit_offset += 2;\r\n\r\n                /* TSN */\r\n                /* tsn = (tvb_get_uint8(tvb, offset + (bit_offset/8)) & 0x3f); */\r\n                proto_tree_add_item(subframe_tree, hf_fp_edch_tsn, tvb,\r\n                                    offset + (bit_offset/8),\r\n                                    1, ENC_BIG_ENDIAN);\r\n                bit_offset += 6;\r\n\r\n                /* PDU */\r\n                if (subframe_tree) {\r\n                    ti = proto_tree_add_item(subframe_tree, hf_fp_edch_mac_es_pdu, tvb,\r\n                                             offset + (bit_offset/8),\r\n                                             ((bit_offset % 8) + send_size + 7) / 8,\r\n                                             ENC_NA);\r\n                    proto_item_append_text(ti, \" (%u * %u = %u bits, PDU %d)\",\r\n                                           size, subframes[n].number_of_mac_d_pdus[i],\r\n                                           send_size, n);\r\n                    maces_tree = proto_item_add_subtree(ti, ett_fp_edch_maces);\r\n                }\r\n                /* Determine the UE ID to use in RLC */\r\n                user_identity = p_fp_info->com_context_id;\r\n                if(p_fp_info->urnti) {\r\n                    user_identity = p_fp_info->urnti;\r\n                }\r\n                for (macd_idx = 0; macd_idx < subframes[n].number_of_mac_d_pdus[i]; macd_idx++) {\r\n\r\n                    if (preferences_call_mac_dissectors) {\r\n                        /* Should no longer happen ??*/\r\n                        if (macd_idx >= MAX_MAC_FRAMES) {\r\n                            expert_add_info_format(pinfo, subframe_tree, &ei_fp_invalid_frame_count, \"Invalid frame count (max is %u)\", MAX_MAC_FRAMES);\r\n                            return;\r\n                        }\r\n\r\n                        tvbuff_t *next_tvb;\r\n                        /* create new TVB and pass further on */\r\n                        next_tvb = tvb_new_subset_length(tvb, offset + bit_offset/8,\r\n                                ((bit_offset % 8) + size + 7) / 8);\r\n\r\n                        /*Set up information needed for MAC and lower layers*/\r\n                        macinf->content[macd_idx] = lchId_type_table[lchid];     /*Set the proper Content type for the mac layer.*/\r\n                        macinf->lchid[macd_idx] = lchid;\r\n                        rlcinf->mode[macd_idx] = lchId_rlc_map[lchid]; /* Set RLC mode by lchid to RLC_MODE map in nbap.h */\r\n\r\n                        /* Set UE ID to U-RNTI or NBAP Communication Context*/\r\n                        rlcinf->ueid[macd_idx] = user_identity;\r\n                        rlcinf->rbid[macd_idx] = lchid;\r\n                        rlcinf->li_size[macd_idx] = RLC_LI_7BITS;\r\n\r\n                        rlcinf->ciphered[macd_idx] = false;\r\n                        rlcinf->deciphered[macd_idx] = false;\r\n                        p_fp_info->cur_tb = macd_idx;    /*Set the transport block index */\r\n\r\n                        call_dissector_with_data(mac_fdd_edch_handle, next_tvb, pinfo, top_level_tree, data);\r\n                        dissected = true;\r\n                    }\r\n                    else {\r\n                        /* Just add as a MAC-d PDU */\r\n                        proto_tree_add_item(maces_tree, hf_fp_mac_d_pdu, tvb,\r\n                                            offset + (bit_offset/8),\r\n                                            ((bit_offset % 8) + size + 7) / 8,\r\n                                            ENC_NA);\r\n                    }\r\n                    bit_offset += size;\r\n                }\r\n\r\n                bits_in_subframe += send_size;\r\n                mac_d_pdus_in_subframe += subframes[n].number_of_mac_d_pdus[i];\r\n\r\n                /* Pad out to next byte */\r\n                bit_offset = WS_ROUNDUP_8(bit_offset);\r\n            }\r\n\r\n            if (tree) {\r\n                /* Tree should cover entire subframe */\r\n                proto_item_set_len(subframe_ti, bit_offset/8);\r\n                /* Append summary info to subframe label */\r\n                proto_item_append_text(subframe_ti, \" (%u bits in %u MAC-d PDUs)\",\r\n                                       bits_in_subframe, mac_d_pdus_in_subframe);\r\n            }\r\n            total_pdus += mac_d_pdus_in_subframe;\r\n            total_bits += bits_in_subframe;\r\n\r\n            offset += (bit_offset/8);\r\n        }\r\n\r\n        /* Report number of subframes in info column\r\n         * do this only if no other dissector was called */\r\n        if (dissected == false) {\r\n            col_append_fstr(pinfo->cinfo, COL_INFO,\r\n                            \" CFN = %03u   (%u bits in %u pdus in %u subframes)\",\r\n                            cfn, total_bits, total_pdus, number_of_subframes);\r\n        }\r\n        /* Add data summary to info column */\r\n        /*col_append_fstr(pinfo->cinfo, COL_INFO, \" (%u bytes in %u SDUs in %u MAC-is PDUs in %u subframes)\",\r\n                        total_bytes, macis_sdus_found, macis_pdus, number_of_subframes);*/\r\n        if (preferences_header_checksum) {\r\n            verify_header_crc_edch(tvb, pinfo, header_crc_pi, header_crc, header_length);\r\n        }\r\n        /* Spare extension and payload CRC (optional) */\r\n        dissect_spare_extension_and_crc(tvb, pinfo, tree,\r\n                                        p_fp_info->dch_crc_present, offset, header_length);\r\n    }\r\n}", ".issect_fp_common": "static int\r\ndissect_fp_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)\r\n{\r\n    proto_tree       *fp_tree;\r\n    proto_item       *ti;\r\n    int               offset = 0;\r\n    struct fp_info   *p_fp_info;\r\n    conversation_t   *p_conv = NULL;\r\n    umts_fp_conversation_info_t *p_conv_data = NULL;\r\n\r\n    /* Append this protocol name rather than replace. */\r\n    col_set_str(pinfo->cinfo, COL_PROTOCOL, \"FP\");\r\n\r\n    /* Create fp tree. */\r\n    ti = proto_tree_add_item(tree, proto_fp, tvb, offset, -1, ENC_NA);\r\n    fp_tree = proto_item_add_subtree(ti, ett_fp);\r\n\r\n    top_level_tree = tree;\r\n\r\n    /* Look for packet info! */\r\n    p_fp_info = (struct fp_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_fp, 0);\r\n\r\n    /* Check if we have conversation info */\r\n    /* Trying to find exact match - with both RNC's address & port and Node B's address & port */\r\n    p_conv = (conversation_t *)find_conversation(pinfo->num, &pinfo->net_dst, &pinfo->net_src,\r\n                               conversation_pt_to_conversation_type(pinfo->ptype),\r\n                               pinfo->destport, pinfo->srcport, 0);\r\n    if (p_conv) {\r\n        p_conv_data = (umts_fp_conversation_info_t *)conversation_get_proto_data(p_conv, proto_fp);\r\n    }\r\n    if (!p_conv || !p_conv_data) {\r\n        /* Didn't find exact conversation match */\r\n        /* Try to find a partial match with just the source/destination included */\r\n        p_conv = (conversation_t *)find_conversation(pinfo->num, &pinfo->net_dst, &pinfo->net_src,\r\n                                   conversation_pt_to_conversation_type(pinfo->ptype),\r\n                                   pinfo->destport, pinfo->srcport, NO_ADDR_B);\r\n        if (p_conv) {\r\n            p_conv_data = (umts_fp_conversation_info_t *)conversation_get_proto_data(p_conv, proto_fp);\r\n        }\r\n    }\r\n\r\n    if (p_conv_data) {\r\n        /*Figure out the direction of the link*/\r\n        if (addresses_equal(&(pinfo->net_dst), (&p_conv_data->crnc_address))) {\r\n            /* Node B -> CRNC*/\r\n            pinfo->link_dir=P2P_DIR_UL;\r\n\r\n            proto_item *item= proto_tree_add_uint(fp_tree, hf_fp_ul_setup_frame,\r\n                                                  tvb, 0, 0, p_conv_data->ul_frame_number);\r\n            proto_item_set_generated(item);\r\n        }\r\n        else {\r\n            /* CRNC -> Node B */\r\n            pinfo->link_dir=P2P_DIR_DL;\r\n\r\n            /* Maybe the frame number should be stored in the proper location already in nbap?, in ul_frame_number*/\r\n            proto_item *item= proto_tree_add_uint(fp_tree, hf_fp_dl_setup_frame,\r\n                                                   tvb, 0, 0, p_conv_data->ul_frame_number);\r\n            proto_item_set_generated(item);\r\n        }\r\n        if (p_fp_info == NULL) {\r\n            p_fp_info = fp_set_per_packet_inf_from_conv(p_conv, p_conv_data, tvb, pinfo, fp_tree);\r\n        }\r\n    }\r\n\r\n    if (pinfo->p2p_dir == P2P_DIR_UNKNOWN) {\r\n        if (pinfo->link_dir == P2P_DIR_UL) {\r\n            pinfo->p2p_dir = P2P_DIR_RECV;\r\n        } else {\r\n            pinfo->p2p_dir = P2P_DIR_SENT;\r\n        }\r\n    }\r\n\r\n    /* Can't dissect anything without it... */\r\n    if (p_fp_info == NULL) {\r\n        proto_tree_add_expert(fp_tree, pinfo, &ei_fp_no_per_frame_info, tvb, offset, -1);\r\n        return 1;\r\n    }\r\n\r\n    /* Show release information */\r\n    if (preferences_show_release_info) {\r\n        proto_item *release_ti;\r\n        proto_tree *release_tree;\r\n        proto_item *temp_ti;\r\n\r\n        release_ti = proto_tree_add_item(fp_tree, hf_fp_release, tvb, 0, 0, ENC_NA);\r\n        proto_item_set_generated(release_ti);\r\n        proto_item_append_text(release_ti, \" R%u (%d/%d)\",\r\n                               p_fp_info->release, p_fp_info->release_year, p_fp_info->release_month);\r\n        release_tree = proto_item_add_subtree(release_ti, ett_fp_release);\r\n\r\n        temp_ti = proto_tree_add_uint(release_tree, hf_fp_release_version, tvb, 0, 0, p_fp_info->release);\r\n        proto_item_set_generated(temp_ti);\r\n\r\n        temp_ti = proto_tree_add_uint(release_tree, hf_fp_release_year, tvb, 0, 0, p_fp_info->release_year);\r\n        proto_item_set_generated(temp_ti);\r\n\r\n        temp_ti = proto_tree_add_uint(release_tree, hf_fp_release_month, tvb, 0, 0, p_fp_info->release_month);\r\n        proto_item_set_generated(temp_ti);\r\n    }\r\n\r\n    /* Show channel type in info column, tree */\r\n    col_set_str(pinfo->cinfo, COL_INFO,\r\n                val_to_str_const(p_fp_info->channel,\r\n                                 channel_type_vals,\r\n                                 \"Unknown channel type\"));\r\n    if (p_conv_data) {\r\n        int i;\r\n        col_append_fstr(pinfo->cinfo, COL_INFO, \"(%u\", p_conv_data->dch_ids_in_flow_list[0]);\r\n        for (i=1; i < p_conv_data->num_dch_in_flow; i++) {\r\n            col_append_fstr(pinfo->cinfo, COL_INFO, \",%u\", p_conv_data->dch_ids_in_flow_list[i]);\r\n        }\r\n        col_append_str(pinfo->cinfo, COL_INFO, \") \");\r\n    }\r\n    proto_item_append_text(ti, \" (%s)\",\r\n                           val_to_str_const(p_fp_info->channel,\r\n                                            channel_type_vals,\r\n                                            \"Unknown channel type\"));\r\n\r\n    /* Add channel type as a generated field */\r\n    ti = proto_tree_add_uint(fp_tree, hf_fp_channel_type, tvb, 0, 0, p_fp_info->channel);\r\n    proto_item_set_generated(ti);\r\n\r\n    /* Add division type as a generated field */\r\n    if (p_fp_info->release == 7) {\r\n        ti = proto_tree_add_uint(fp_tree, hf_fp_division, tvb, 0, 0, p_fp_info->division);\r\n        proto_item_set_generated(ti);\r\n    }\r\n\r\n    /* Add link direction as a generated field */\r\n    ti = proto_tree_add_boolean(fp_tree, hf_fp_direction, tvb, 0, 0, p_fp_info->is_uplink);\r\n    proto_item_set_generated(ti);\r\n\r\n    /* Don't currently handle IuR-specific formats, but it's useful to even see\r\n       the channel type and direction */\r\n    if (p_fp_info->iface_type == IuR_Interface) {\r\n        return 1;\r\n    }\r\n\r\n    /* Show DDI config info */\r\n    if (p_fp_info->no_ddi_entries > 0) {\r\n        int n;\r\n        proto_item *ddi_config_ti;\r\n        proto_tree *ddi_config_tree;\r\n\r\n        ddi_config_ti = proto_tree_add_string_format(fp_tree, hf_fp_ddi_config, tvb, offset, 0,\r\n                                                     \"\", \"DDI Config (\");\r\n        proto_item_set_generated(ddi_config_ti);\r\n        ddi_config_tree = proto_item_add_subtree(ddi_config_ti, ett_fp_ddi_config);\r\n\r\n        /* Add each entry */\r\n        for (n=0; n < p_fp_info->no_ddi_entries; n++) {\r\n            proto_item_append_text(ddi_config_ti, \"%s%u->%ubits\",\r\n                                   (n == 0) ? \"\" : \"  \",\r\n                                   p_fp_info->edch_ddi[n], p_fp_info->edch_macd_pdu_size[n]);\r\n            ti = proto_tree_add_uint(ddi_config_tree, hf_fp_ddi_config_ddi, tvb, 0, 0,\r\n                                p_fp_info->edch_ddi[n]);\r\n            proto_item_set_generated(ti);\r\n            ti = proto_tree_add_uint(ddi_config_tree, hf_fp_ddi_config_macd_pdu_size, tvb, 0, 0,\r\n                                p_fp_info->edch_macd_pdu_size[n]);\r\n            proto_item_set_generated(ti);\r\n\r\n        }\r\n        proto_item_append_text(ddi_config_ti, \")\");\r\n    }\r\n\r\n    /*************************************/\r\n    /* Dissect according to channel type */\r\n    switch (p_fp_info->channel) {\r\n        case CHANNEL_RACH_TDD:\r\n        case CHANNEL_RACH_TDD_128:\r\n        case CHANNEL_RACH_FDD:\r\n            dissect_rach_channel_info(tvb, pinfo, fp_tree, offset, p_fp_info,\r\n                                      data);\r\n            break;\r\n        case CHANNEL_DCH:\r\n            dissect_dch_channel_info(tvb, pinfo, fp_tree, offset, p_fp_info,\r\n                                     data);\r\n            break;\r\n        case CHANNEL_FACH_FDD:\r\n        case CHANNEL_FACH_TDD:\r\n            dissect_fach_channel_info(tvb, pinfo, fp_tree, offset, p_fp_info,\r\n                                      data);\r\n            break;\r\n        case CHANNEL_DSCH_FDD:\r\n        case CHANNEL_DSCH_TDD:\r\n            dissect_dsch_channel_info(tvb, pinfo, fp_tree, offset, p_fp_info);\r\n            break;\r\n        case CHANNEL_USCH_TDD_128:\r\n        case CHANNEL_USCH_TDD_384:\r\n            dissect_usch_channel_info(tvb, pinfo, fp_tree, offset, p_fp_info);\r\n            break;\r\n        case CHANNEL_PCH:\r\n            dissect_pch_channel_info(tvb, pinfo, fp_tree, offset, p_fp_info,\r\n                                     data);\r\n            update_pch_coversation_info(p_conv_data, pinfo, p_fp_info);\r\n            break;\r\n        case CHANNEL_CPCH:\r\n            dissect_cpch_channel_info(tvb, pinfo, fp_tree, offset, p_fp_info);\r\n            break;\r\n        case CHANNEL_BCH:\r\n            dissect_bch_channel_info(tvb, pinfo, fp_tree, offset, p_fp_info);\r\n            break;\r\n        case CHANNEL_HSDSCH:\r\n            /* Show configured MAC HS-DSCH entity in use */\r\n            if (fp_tree)\r\n            {\r\n                proto_item *entity_ti;\r\n                entity_ti = proto_tree_add_uint(fp_tree, hf_fp_hsdsch_entity,\r\n                                                tvb, 0, 0,\r\n                                                p_fp_info->hsdsch_entity);\r\n                proto_item_set_generated(entity_ti);\r\n            }\r\n            switch (p_fp_info->hsdsch_entity) {\r\n                case entity_not_specified:\r\n                case hs:\r\n                    /* This is the pre-R7 default */\r\n                    dissect_hsdsch_channel_info(tvb, pinfo, fp_tree, offset, p_fp_info, data);\r\n                    break;\r\n                case ehs:\r\n                    dissect_hsdsch_type_2_channel_info(tvb, pinfo, fp_tree, offset, p_fp_info, data);\r\n                    break;\r\n                default:\r\n                    /* Report Error */\r\n                    expert_add_info(pinfo, NULL, &ei_fp_hsdsch_entity_not_specified);\r\n                    break;\r\n            }\r\n            break;\r\n        case CHANNEL_HSDSCH_COMMON:\r\n            expert_add_info(pinfo, NULL, &ei_fp_hsdsch_common_experimental_support);\r\n            /*if (false)*/\r\n            dissect_hsdsch_common_channel_info(tvb, pinfo, fp_tree, offset, p_fp_info, data);\r\n\r\n            break;\r\n        case CHANNEL_HSDSCH_COMMON_T3:\r\n            expert_add_info(pinfo, NULL, &ei_fp_hsdsch_common_t3_not_implemented);\r\n\r\n            /* TODO: */\r\n            break;\r\n        case CHANNEL_IUR_CPCHF:\r\n            /* TODO: */\r\n            break;\r\n        case CHANNEL_IUR_FACH:\r\n            /* TODO: */\r\n            break;\r\n        case CHANNEL_IUR_DSCH:\r\n            dissect_iur_dsch_channel_info(tvb, pinfo, fp_tree, offset, p_fp_info);\r\n            break;\r\n        case CHANNEL_EDCH:\r\n        case CHANNEL_EDCH_COMMON:\r\n            /* Show configured MAC E-DCH entity in use */\r\n            if (fp_tree)\r\n            {\r\n                proto_item *entity_ti;\r\n                entity_ti = proto_tree_add_uint(fp_tree, hf_fp_edch_entity,\r\n                                                tvb, 0, 0,\r\n                                                p_fp_info->edch_type);\r\n                proto_item_set_generated(entity_ti);\r\n            }\r\n            dissect_e_dch_channel_info(tvb, pinfo, fp_tree, offset, p_fp_info,\r\n                                       p_fp_info->channel == CHANNEL_EDCH_COMMON,\r\n                                       data);\r\n            break;\r\n\r\n        default:\r\n            expert_add_info(pinfo, NULL, &ei_fp_channel_type_unknown);\r\n            break;\r\n    }\r\n    return tvb_captured_length(tvb);\r\n}", ".issect_fp_aal2": "static int\r\ndissect_fp_aal2(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)\r\n{\r\n    return dissect_fp_common(tvb, pinfo, tree, data);\r\n}", ".eur_dissect_fp": "static bool\r\nheur_dissect_fp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)\r\n{\r\n    bool match;\r\n\r\n    match = heur_dissect_fp_dcch_over_dch(tvb, pinfo, tree, data);\r\n    if(match)\r\n        return true;\r\n    match = heur_dissect_fp_fach1(tvb, pinfo, tree, data);\r\n    if(match)\r\n        return true;\r\n    match = heur_dissect_fp_fach2(tvb, pinfo, tree, data);\r\n    if(match)\r\n        return true;\r\n    match = heur_dissect_fp_rach(tvb, pinfo, tree, data);\r\n    if(match)\r\n        return true;\r\n    match = heur_dissect_fp_pch(tvb, pinfo, tree, data);\r\n    if(match)\r\n        return true;\r\n    match = heur_dissect_fp_hsdsch_type_1(tvb, pinfo, tree, data);\r\n    if(match)\r\n        return true;\r\n    match = heur_dissect_fp_hsdsch_type_2(tvb, pinfo, tree, data);\r\n    if(match)\r\n        return true;\r\n    match = heur_dissect_fp_edch_type_1(tvb, pinfo, tree, data);\r\n    if(match)\r\n        return true;\r\n    /* NOTE: Add new heuristic dissectors BEFORE the 'unknown format' dissector */\r\n    /* since it might 'swallow' packets if the UDP stream is framed as 'CHANNEL_UNKNOWN' */\r\n    match = heur_dissect_fp_unknown_format(tvb, pinfo, tree, data);\r\n    if(match)\r\n        return true;\r\n\r\n    return false;\r\n}"}, "callee": {".issect_crci_bits": "static int\r\ndissect_crci_bits(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\r\n                  fp_info *p_fp_info, int offset)\r\n{\r\n    int         n, num_tbs;\r\n    proto_item *ti         = NULL;\r\n    proto_tree *crcis_tree = NULL;\r\n    unsigned    errors     = 0;\r\n\r\n    num_tbs = get_tb_count(p_fp_info);\r\n\r\n\r\n    /* Add CRCIs subtree */\r\n    if (tree) {\r\n        ti =  proto_tree_add_item(tree, hf_fp_crcis, tvb, offset, (num_tbs+7)/8, ENC_NA);\r\n        proto_item_set_text(ti, \"CRCI bits for %u tbs\", num_tbs);\r\n        crcis_tree = proto_item_add_subtree(ti, ett_fp_crcis);\r\n    }\r\n\r\n    /* CRCIs */\r\n    for (n=0; n < num_tbs; n++) {\r\n        int bit = (tvb_get_uint8(tvb, offset+(n/8)) >> (7-(n%8))) & 0x01;\r\n        proto_tree_add_item(crcis_tree, hf_fp_crci[n%8], tvb, offset+(n/8),\r\n                            1, ENC_BIG_ENDIAN);\r\n\r\n        if (bit == 1) {\r\n            errors++;\r\n            expert_add_info(pinfo, ti, &ei_fp_crci_error_bit_set_for_tb);\r\n        }\r\n    }\r\n\r\n    if (tree) {\r\n        /* Highlight range of bytes covered by indicator bits */\r\n        proto_item_set_len(ti, (num_tbs+7) / 8);\r\n\r\n        /* Show error count in root text */\r\n        proto_item_append_text(ti, \" (%u errors)\", errors);\r\n    }\r\n\r\n    offset += ((num_tbs+7) / 8);\r\n    return offset;\r\n}", ".issect_rach_channel_info": "static void\r\ndissect_rach_channel_info(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\r\n                          int offset, struct fp_info *p_fp_info, void *data)\r\n{\r\n    uint32_t ft;\r\n    uint32_t header_crc = 0;\r\n    proto_item * header_crc_pi = NULL;\r\n    unsigned header_length;\r\n\r\n    /* Header CRC */\r\n    header_crc_pi = proto_tree_add_item_ret_uint(tree, hf_fp_header_crc, tvb, offset, 1, ENC_BIG_ENDIAN, &header_crc);\r\n\r\n    /* Frame Type */\r\n    proto_tree_add_item_ret_uint(tree, hf_fp_ft, tvb, offset, 1, ENC_BIG_ENDIAN, &ft);\r\n    offset++;\r\n\r\n    col_append_fstr(pinfo->cinfo, COL_INFO, \" [%s] \", val_to_str_const(ft, frame_type_vals, \"Unknown\"));\r\n\r\n    if (ft == FT_CONTROL) {\r\n        dissect_common_control(tvb, pinfo, tree, offset, p_fp_info);\r\n        /* For control frame the header CRC is actually frame CRC covering all\r\n         * bytes except the first */\r\n        if (preferences_header_checksum) {\r\n            verify_control_frame_crc(tvb, pinfo, header_crc_pi, (uint16_t)header_crc);\r\n        }\r\n    }\r\n    else {\r\n        uint8_t     cfn;\r\n        uint32_t    encoded;\r\n        uint32_t    propagation_delay                    = 0;\r\n        proto_item *propagation_delay_ti                 = NULL;\r\n        uint32_t    received_sync_ul_timing_deviation    = 0;\r\n        proto_item *received_sync_ul_timing_deviation_ti = NULL;\r\n        proto_item *rx_timing_deviation_ti               = NULL;\r\n        uint16_t    rx_timing_deviation                  = 0;\r\n\r\n        /* DATA */\r\n\r\n        /* CFN */\r\n        cfn = tvb_get_uint8(tvb, offset);\r\n        proto_tree_add_item(tree, hf_fp_cfn, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n        offset++;\r\n\r\n        col_append_fstr(pinfo->cinfo, COL_INFO, \"CFN=%03u \", cfn);\r\n\r\n        /* TFI */\r\n        proto_tree_add_item(tree, hf_fp_tfi, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n        offset++;\r\n\r\n        if (p_fp_info->channel == CHANNEL_RACH_FDD) {\r\n            /* Propagation delay */\r\n            encoded = tvb_get_uint8(tvb, offset);\r\n            propagation_delay = encoded * 3;\r\n            propagation_delay_ti = proto_tree_add_uint_format(tree, hf_fp_propagation_delay, tvb, offset, 1,\r\n                                               propagation_delay, \"Propagation Delay: %u chips (%u)\",\r\n                                               propagation_delay, encoded);\r\n            offset++;\r\n        }\r\n\r\n        /* Should be TDD 3.84 or 7.68 */\r\n        if (p_fp_info->channel == CHANNEL_RACH_TDD) {\r\n            /* Rx Timing Deviation */\r\n            rx_timing_deviation = tvb_get_uint8(tvb, offset);\r\n            rx_timing_deviation_ti = proto_tree_add_item(tree, hf_fp_rx_timing_deviation, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n            offset++;\r\n        }\r\n\r\n        if (p_fp_info->channel == CHANNEL_RACH_TDD_128) {\r\n            /* Received SYNC UL Timing Deviation */\r\n            received_sync_ul_timing_deviation = tvb_get_uint8(tvb, offset);\r\n            received_sync_ul_timing_deviation_ti =\r\n                 proto_tree_add_item(tree, hf_fp_received_sync_ul_timing_deviation, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n            offset++;\r\n        }\r\n\r\n        header_length = offset;\r\n\r\n        /* TB data */\r\n        offset = dissect_tb_data(tvb, pinfo, tree, offset, p_fp_info, &mac_fdd_rach_handle, data);\r\n\r\n        /* CRCIs */\r\n        offset = dissect_crci_bits(tvb, pinfo, tree, p_fp_info, offset);\r\n\r\n        /* Info introduced in R6 */\r\n        /* only check if it looks as if they are present */\r\n        if (((p_fp_info->release == 6) || (p_fp_info->release == 7)) &&\r\n            (tvb_reported_length_remaining(tvb, offset) > 2))\r\n        {\r\n            int n;\r\n            uint8_t flags;\r\n            /* uint8_t flag_bytes = 0; */\r\n\r\n            bool cell_portion_id_present                 = false;\r\n            bool ext_propagation_delay_present           = false;\r\n            bool angle_of_arrival_present                = false;\r\n            bool ext_rx_sync_ul_timing_deviation_present = false;\r\n            bool ext_rx_timing_deviation_present         = false;\r\n\r\n            /* New IE flags (assume mandatory for now) */\r\n            do {\r\n                proto_item *new_ie_flags_ti;\r\n                proto_tree *new_ie_flags_tree;\r\n                unsigned ies_found = 0;\r\n\r\n                /* Add new IE flags subtree */\r\n                new_ie_flags_ti = proto_tree_add_string_format(tree, hf_fp_rach_new_ie_flags, tvb, offset, 1,\r\n                                                              \"\", \"New IE flags\");\r\n                new_ie_flags_tree = proto_item_add_subtree(new_ie_flags_ti, ett_fp_rach_new_ie_flags);\r\n\r\n                /* Read next byte */\r\n                flags = tvb_get_uint8(tvb, offset);\r\n                /* flag_bytes++ */\r\n\r\n                /* Dissect individual bits */\r\n                for (n=0; n < 8; n++) {\r\n                    switch (n) {\r\n                        case 6:\r\n                            switch (p_fp_info->division) {\r\n                                case Division_FDD:\r\n                                    /* Ext propagation delay */\r\n                                    ext_propagation_delay_present = true;\r\n                                    proto_tree_add_item(new_ie_flags_tree, hf_fp_rach_ext_propagation_delay_present,\r\n                                                        tvb, offset, 1, ENC_BIG_ENDIAN);\r\n                                    break;\r\n                                case Division_TDD_128:\r\n                                    /* Ext Rx Sync UL Timing */\r\n                                    ext_rx_sync_ul_timing_deviation_present = true;\r\n                                    proto_tree_add_item(new_ie_flags_tree, hf_fp_rach_ext_rx_sync_ul_timing_deviation_present,\r\n                                                        tvb, offset, 1, ENC_BIG_ENDIAN);\r\n\r\n                                    break;\r\n                                default:\r\n                                    /* Not defined */\r\n                                    proto_tree_add_item(new_ie_flags_tree, hf_fp_rach_new_ie_flag_unused[6],\r\n                                                        tvb, offset, 1, ENC_BIG_ENDIAN);\r\n                                    break;\r\n                            }\r\n                            break;\r\n                        case 7:\r\n                            switch (p_fp_info->division) {\r\n                                case Division_FDD:\r\n                                    /* Cell Portion ID */\r\n                                    cell_portion_id_present = true;\r\n                                    proto_tree_add_item(new_ie_flags_tree, hf_fp_rach_cell_portion_id_present,\r\n                                                        tvb, offset, 1, ENC_BIG_ENDIAN);\r\n                                    break;\r\n                                case Division_TDD_128:\r\n                                    /* AOA */\r\n                                    angle_of_arrival_present = true;\r\n                                    proto_tree_add_item(new_ie_flags_tree, hf_fp_rach_angle_of_arrival_present,\r\n                                                        tvb, offset, 1, ENC_BIG_ENDIAN);\r\n                                    break;\r\n                                case Division_TDD_384:\r\n                                case Division_TDD_768:\r\n                                    /* Extended Rx Timing Deviation */\r\n                                    ext_rx_timing_deviation_present = true;\r\n                                    proto_tree_add_item(new_ie_flags_tree, hf_fp_rach_ext_rx_timing_deviation_present,\r\n                                                        tvb, offset, 1, ENC_BIG_ENDIAN);\r\n                                    break;\r\n                            }\r\n                            break;\r\n\r\n                        default:\r\n                            /* No defined meanings */\r\n                            /* Visual Studio Code Analyzer wrongly thinks n can be 7 here. It can't */\r\n                            proto_tree_add_item(new_ie_flags_tree, hf_fp_rach_new_ie_flag_unused[n],\r\n                                                tvb, offset, 1, ENC_BIG_ENDIAN);\r\n                            break;\r\n                    }\r\n                    if ((flags >> (7-n)) & 0x01) {\r\n                        ies_found++;\r\n                    }\r\n                }\r\n                offset++;\r\n\r\n                proto_item_append_text(new_ie_flags_ti, \" (%u IEs found)\", ies_found);\r\n\r\n                /* Last bit set will indicate another flags byte follows... */\r\n            } while (0); /*((flags & 0x01) && (flag_bytes < 31));*/\r\n\r\n            /* Cell Portion ID */\r\n            if (cell_portion_id_present) {\r\n                    proto_tree_add_item(tree, hf_fp_cell_portion_id, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n                    offset++;\r\n            }\r\n\r\n            /* Ext Rx Timing Deviation */\r\n            if (ext_rx_timing_deviation_present) {\r\n                uint8_t extra_bits;\r\n                unsigned bits_to_extend;\r\n                switch (p_fp_info->division) {\r\n                    case Division_TDD_384:\r\n                        bits_to_extend = 1;\r\n                        break;\r\n                    case Division_TDD_768:\r\n                        bits_to_extend = 2;\r\n                        break;\r\n\r\n                    default:\r\n                        /* TODO: report unexpected division type */\r\n                        bits_to_extend = 1;\r\n                        break;\r\n                }\r\n                extra_bits = tvb_get_uint8(tvb, offset) &\r\n                                 ((bits_to_extend == 1) ? 0x01 : 0x03);\r\n                rx_timing_deviation = (extra_bits << 8) | (rx_timing_deviation);\r\n                proto_item_append_text(rx_timing_deviation_ti,\r\n                                       \" (extended to 0x%x)\",\r\n                                       rx_timing_deviation);\r\n                proto_tree_add_bits_item(tree, hf_fp_extended_bits, tvb,\r\n                                         offset*8 + (8-bits_to_extend), bits_to_extend, ENC_BIG_ENDIAN);\r\n                offset++;\r\n            }\r\n\r\n            /* Ext propagation delay. */\r\n            if (ext_propagation_delay_present) {\r\n                uint16_t extra_bits = tvb_get_ntohs(tvb, offset) & 0x03ff;\r\n                proto_tree_add_item(tree, hf_fp_ext_propagation_delay, tvb, offset, 2, ENC_BIG_ENDIAN);\r\n\r\n                /* Adding 10 bits to original 8 */\r\n                proto_item_append_text(propagation_delay_ti, \" (extended to %u)\",\r\n                                       ((extra_bits << 8) | propagation_delay) * 3);\r\n                offset += 2;\r\n            }\r\n\r\n            /* Angle of Arrival (AOA) */\r\n            if (angle_of_arrival_present) {\r\n                proto_tree_add_item(tree, hf_fp_angle_of_arrival, tvb, offset, 2, ENC_BIG_ENDIAN);\r\n                offset += 2;\r\n            }\r\n\r\n            /* Ext. Rx Sync UL Timing Deviation */\r\n            if (ext_rx_sync_ul_timing_deviation_present) {\r\n                uint16_t extra_bits;\r\n\r\n                /* Ext received Sync UL Timing Deviation */\r\n                extra_bits = tvb_get_ntohs(tvb, offset) & 0x1fff;\r\n                proto_tree_add_item(tree, hf_fp_ext_received_sync_ul_timing_deviation, tvb, offset, 2, ENC_BIG_ENDIAN);\r\n\r\n                /* Adding 13 bits to original 8 */\r\n                proto_item_append_text(received_sync_ul_timing_deviation_ti, \" (extended to %u)\",\r\n                                       (extra_bits << 8) | received_sync_ul_timing_deviation);\r\n                offset += 2;\r\n            }\r\n        }\r\n        if (preferences_header_checksum) {\r\n            verify_header_crc(tvb, pinfo, header_crc_pi, header_crc, header_length);\r\n        }\r\n        /* Spare Extension and Payload CRC */\r\n        dissect_spare_extension_and_crc(tvb, pinfo, tree, 1, offset, header_length);\r\n    }\r\n}", ".issect_fach_channel_info": "static void\r\ndissect_fach_channel_info(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\r\n                          int offset, struct fp_info *p_fp_info, void *data)\r\n{\r\n    uint32_t ft;\r\n    uint32_t header_crc = 0;\r\n    proto_item * header_crc_pi = NULL;\r\n    unsigned header_length;\r\n\r\n    /* Header CRC */\r\n    header_crc_pi = proto_tree_add_item_ret_uint(tree, hf_fp_header_crc, tvb, offset, 1, ENC_BIG_ENDIAN, &header_crc);\r\n\r\n    /* Frame Type */\r\n    proto_tree_add_item_ret_uint(tree, hf_fp_ft, tvb, offset, 1, ENC_BIG_ENDIAN, &ft);\r\n    offset++;\r\n\r\n    col_append_fstr(pinfo->cinfo, COL_INFO, \" [%s] \", val_to_str_const(ft, frame_type_vals, \"Unknown\"));\r\n\r\n    if (ft == FT_CONTROL) {\r\n        dissect_common_control(tvb, pinfo, tree, offset, p_fp_info);\r\n        /* For control frame the header CRC is actually frame CRC covering all\r\n         * bytes except the first */\r\n        if (preferences_header_checksum) {\r\n            verify_control_frame_crc(tvb, pinfo, header_crc_pi, (uint16_t)header_crc);\r\n        }\r\n    }\r\n    else {\r\n        uint8_t cfn;\r\n        /* DATA */\r\n\r\n        /* CFN */\r\n        cfn = tvb_get_uint8(tvb, offset);\r\n        proto_tree_add_item(tree, hf_fp_cfn, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n        offset++;\r\n\r\n        col_append_fstr(pinfo->cinfo, COL_INFO, \"CFN=%03u \", cfn);\r\n\r\n        /* TFI */\r\n        proto_tree_add_item(tree, hf_fp_fach_tfi, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n        offset++;\r\n\r\n        /* Transmit power level */\r\n        proto_tree_add_float(tree, hf_fp_transmit_power_level, tvb, offset, 1,\r\n                             (float)(int)(tvb_get_uint8(tvb, offset)) / 10);\r\n        offset++;\r\n        header_length = offset;\r\n\r\n        /* TB data */\r\n        offset = dissect_tb_data(tvb, pinfo, tree, offset, p_fp_info, &mac_fdd_fach_handle, data);\r\n\r\n        /* New IE flags (if it looks as though they are present) */\r\n        if ((p_fp_info->release == 7) &&\r\n            (tvb_reported_length_remaining(tvb, offset) > 2)) {\r\n\r\n            uint8_t flags = tvb_get_uint8(tvb, offset);\r\n            uint8_t aoa_present = flags & 0x01;\r\n            offset++;\r\n\r\n            if (aoa_present) {\r\n                proto_tree_add_item(tree, hf_fp_angle_of_arrival, tvb, offset, 2, ENC_BIG_ENDIAN);\r\n                offset += 2;\r\n            }\r\n        }\r\n        if (preferences_header_checksum) {\r\n            verify_header_crc(tvb, pinfo, header_crc_pi, header_crc, header_length);\r\n        }\r\n        /* Spare Extension and Payload CRC */\r\n        dissect_spare_extension_and_crc(tvb, pinfo, tree, 1, offset, header_length);\r\n    }\r\n}", ".issect_pch_channel_info": "static void\r\ndissect_pch_channel_info(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\r\n                         int offset, struct fp_info *p_fp_info, void *data)\r\n{\r\n    uint32_t ft;\r\n    uint16_t pch_cfn;\r\n    uint32_t tfi;\r\n    bool paging_indication;\r\n    uint32_t header_crc = 0;\r\n    proto_item * header_crc_pi = NULL;\r\n\r\n    /* Header CRC */\r\n    header_crc_pi = proto_tree_add_item_ret_uint(tree, hf_fp_header_crc, tvb, offset, 1, ENC_BIG_ENDIAN, &header_crc);\r\n\r\n    /* Frame Type */\r\n    proto_tree_add_item_ret_uint(tree, hf_fp_ft, tvb, offset, 1, ENC_BIG_ENDIAN, &ft);\r\n    offset++;\r\n\r\n    col_append_fstr(pinfo->cinfo, COL_INFO, \" [%s] \", val_to_str_const(ft, frame_type_vals, \"Unknown\"));\r\n\r\n    if (ft == FT_CONTROL) {\r\n        dissect_common_control(tvb, pinfo, tree, offset, p_fp_info);\r\n        /* For control frame the header CRC is actually frame CRC covering all\r\n         * bytes except the first */\r\n        if (preferences_header_checksum) {\r\n            verify_control_frame_crc(tvb, pinfo, header_crc_pi, (uint16_t)header_crc);\r\n        }\r\n    }\r\n    else {\r\n        unsigned header_length = 0;\r\n        /* DATA */\r\n\r\n        /* 12-bit CFN value */\r\n        proto_tree_add_item(tree, hf_fp_pch_cfn, tvb, offset, 2, ENC_BIG_ENDIAN);\r\n        pch_cfn = (tvb_get_ntohs(tvb, offset) & 0xfff0) >> 4;\r\n        offset++;\r\n\r\n        col_append_fstr(pinfo->cinfo, COL_INFO, \"CFN=%04u \", pch_cfn);\r\n\r\n        /* Paging indication */\r\n        proto_tree_add_item(tree, hf_fp_pch_pi, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n        paging_indication = tvb_get_uint8(tvb, offset) & 0x01;\r\n        offset++;\r\n\r\n        /* 5-bit TFI */\r\n        proto_tree_add_item_ret_uint(tree, hf_fp_pch_tfi, tvb, offset, 1, ENC_BIG_ENDIAN, &tfi);\r\n        offset++;\r\n        header_length = offset;\r\n        /* Optional paging indications */\r\n        if (paging_indication) {\r\n            proto_item *ti;\r\n            ti = proto_tree_add_item(tree, hf_fp_paging_indication_bitmap, tvb,\r\n                                     offset,\r\n                                     (p_fp_info->paging_indications+7) / 8,\r\n                                     ENC_NA);\r\n            proto_item_append_text(ti, \" (%u bits)\", p_fp_info->paging_indications);\r\n\r\n            if(preferences_track_paging_indications && !PINFO_FD_VISITED(pinfo)){\r\n                paging_indications_info_t* current_pi_info;\r\n                current_pi_info = wmem_new0(wmem_file_scope(), paging_indications_info_t);\r\n                current_pi_info->frame_number = pinfo->num;\r\n                current_pi_info->paging_indications_bitmap = (uint8_t*)tvb_memdup(wmem_file_scope(), tvb, offset, (p_fp_info->paging_indications+7) / 8);\r\n                p_fp_info->current_paging_indications = current_pi_info;\r\n            }\r\n\r\n            offset += ((p_fp_info->paging_indications+7) / 8);\r\n        }\r\n        if(preferences_track_paging_indications) {\r\n            if(p_fp_info->relevant_paging_indications) {\r\n                /*If tracking PI is enabled and PI info (from the last packet) is attached, show on tree*/\r\n                proto_item *ti;\r\n                proto_tree *relevant_pi_tree;\r\n\r\n                tvbuff_t *pi_tvb;\r\n                pi_tvb = tvb_new_child_real_data(tvb,\r\n                                                 p_fp_info->relevant_paging_indications->paging_indications_bitmap,\r\n                                                 (p_fp_info->paging_indications+7) / 8,\r\n                                                 (p_fp_info->paging_indications+7) / 8);\r\n                add_new_data_source(pinfo, pi_tvb, \"Relevant Paging Indication\");\r\n                ti = proto_tree_add_item(tree, hf_fp_relevant_paging_indication_bitmap, pi_tvb,\r\n                                         0,\r\n                                         (p_fp_info->paging_indications+7) / 8,\r\n                                         ENC_NA);\r\n                proto_item_append_text(ti, \" (%u bits)\", p_fp_info->paging_indications);\r\n                proto_item_set_generated(ti);\r\n                relevant_pi_tree = proto_item_add_subtree(ti, ett_fp_pch_relevant_pi);\r\n                ti = proto_tree_add_uint(relevant_pi_tree, hf_fp_relevant_pi_frame,\r\n                                                           tvb, 0, 0, p_fp_info->relevant_paging_indications->frame_number);\r\n                proto_item_set_generated(ti);\r\n            }\r\n            else {\r\n                /* PI info not attached. Check if this frame has any Transport Blocks (i.e. RRC payloads) */\r\n                if(tfi > 0)\r\n                {\r\n                    /* This frame has RRC payload(s) but the PI info is missing, report to the user*/\r\n                    proto_tree_add_expert(tree, pinfo, &ei_fp_pch_lost_relevant_pi_frame, tvb, offset, -1);\r\n                }\r\n            }\r\n        }\r\n\r\n        /* TB data */\r\n        offset = dissect_tb_data(tvb, pinfo, tree, offset, p_fp_info, &mac_fdd_pch_handle, data);\r\n\r\n        if (preferences_header_checksum) {\r\n            verify_header_crc(tvb, pinfo, header_crc_pi, header_crc, header_length);\r\n        }\r\n        /* Spare Extension and Payload CRC */\r\n        dissect_spare_extension_and_crc(tvb, pinfo, tree, 1, offset, header_length);\r\n    }\r\n}", ".issect_dch_channel_info": "static void\r\ndissect_dch_channel_info(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\r\n                         int offset, struct fp_info *p_fp_info, void *data)\r\n{\r\n    uint32_t ft;\r\n    uint32_t  cfn;\r\n    unsigned header_length;\r\n    uint32_t header_crc = 0;\r\n    proto_item * header_crc_pi = NULL;\r\n\r\n    /* Header CRC */\r\n    header_crc_pi = proto_tree_add_item_ret_uint(tree, hf_fp_header_crc, tvb, offset, 1, ENC_BIG_ENDIAN, &header_crc);\r\n\r\n    /* Frame Type */\r\n    proto_tree_add_item_ret_uint(tree, hf_fp_ft, tvb, offset, 1, ENC_BIG_ENDIAN, &ft);\r\n    offset++;\r\n\r\n    col_append_str(pinfo->cinfo, COL_INFO,\r\n                   (ft == FT_CONTROL )? \" [Control] \" :\r\n                                       ((p_fp_info->is_uplink) ? \" [ULData] \" :\r\n                                                                 \" [DLData] \" ));\r\n\r\n    if (ft == FT_CONTROL) {\r\n        /* DCH control frame */\r\n        dissect_dch_control_frame(tree, pinfo, tvb, offset, p_fp_info);\r\n        /* For control frame the header CRC is actually frame CRC covering all\r\n         * bytes except the first */\r\n        if (preferences_header_checksum) {\r\n            verify_control_frame_crc(tvb, pinfo, header_crc_pi, (uint16_t)header_crc);\r\n        }\r\n    } else {\r\n        /************************/\r\n        /* DCH data here        */\r\n        int chan;\r\n        /* CFN */\r\n        proto_tree_add_item_ret_uint(tree, hf_fp_cfn, tvb, offset, 1, ENC_BIG_ENDIAN, &cfn);\r\n        offset++;\r\n\r\n        col_append_fstr(pinfo->cinfo, COL_INFO, \"CFN=%03u \", cfn);\r\n\r\n        /* One TFI for each channel */\r\n        for (chan=0; chan < p_fp_info->num_chans; chan++) {\r\n            proto_tree_add_item(tree, hf_fp_tfi, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n            offset++;\r\n        }\r\n        header_length = offset;\r\n        /* Dissect TB data */\r\n        offset = dissect_tb_data(tvb, pinfo, tree, offset, p_fp_info, &mac_fdd_dch_handle, data);\r\n\r\n        /* QE and CRCI bits (uplink only) */\r\n        if (p_fp_info->is_uplink) {\r\n            proto_tree_add_item(tree, hf_fp_quality_estimate, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n            offset++;\r\n            offset = dissect_crci_bits(tvb, pinfo, tree, p_fp_info, offset);\r\n        }\r\n\r\n        if (preferences_header_checksum) {\r\n            verify_header_crc(tvb, pinfo, header_crc_pi, header_crc, header_length);\r\n        }\r\n        /* Spare extension and payload CRC (optional) */\r\n        dissect_spare_extension_and_crc(tvb, pinfo, tree,\r\n                                        p_fp_info->dch_crc_present, offset, header_length);\r\n    }\r\n}", ".issect_e_dch_channel_info": "static void\r\ndissect_e_dch_channel_info(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\r\n                           int offset, struct fp_info *p_fp_info,\r\n                           bool is_common,\r\n                           void *data)\r\n{\r\n    uint32_t ft;\r\n    uint8_t  number_of_subframes;\r\n    uint32_t cfn;\r\n    int      n;\r\n    struct   edch_t1_subframe_info subframes[16];\r\n    uint32_t header_crc = 0;\r\n    proto_item * header_crc_pi = NULL;\r\n    proto_item * item;\r\n    unsigned header_length;\r\n    rlc_info * rlcinf;\r\n\r\n    if (p_fp_info->edch_type == 1) {\r\n        col_append_str(pinfo->cinfo, COL_INFO, \" (T2)\");\r\n    }\r\n\r\n    /* Header CRC */\r\n     /* the bitmask doesn't properly handle this delicate case, do manually */\r\n    header_crc = (tvb_get_bits8(tvb, offset*8, 7) << 4) + tvb_get_bits8(tvb, offset*8+8, 4);\r\n\r\n    /* Frame Type */\r\n    ft = tvb_get_uint8(tvb, offset) & 0x01;\r\n\r\n    col_append_fstr(pinfo->cinfo, COL_INFO, \" [%s] \", val_to_str_const(ft, frame_type_vals, \"Unknown\"));\r\n\r\n    if (ft == FT_CONTROL) {\r\n        /* DCH control frame */\r\n\r\n        /* For control frame the header CRC is actually frame CRC covering all\r\n         * bytes except the first */\r\n        header_crc_pi = proto_tree_add_item_ret_uint(tree, hf_fp_header_crc, tvb, offset, 1, ENC_BIG_ENDIAN, &header_crc);\r\n        proto_tree_add_item(tree, hf_fp_ft, tvb, 0, 1, ENC_BIG_ENDIAN);\r\n        offset++;\r\n        if (preferences_header_checksum) {\r\n            verify_control_frame_crc(tvb, pinfo, header_crc_pi, (uint16_t)header_crc);\r\n        }\r\n        dissect_dch_control_frame(tree, pinfo, tvb, offset, p_fp_info);\r\n    }\r\n    else {\r\n        /********************************/\r\n        /* E-DCH data here              */\r\n        unsigned  bit_offset;\r\n        unsigned  total_pdus = 0;\r\n        unsigned  total_bits = 0;\r\n        bool dissected = false;\r\n\r\n        rlcinf = (rlc_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_umts_rlc, 0);\r\n        if (!rlcinf) {\r\n            rlcinf = wmem_new0(pinfo->pool, rlc_info);\r\n        }\r\n\r\n        header_crc_pi = proto_tree_add_uint_format(tree, hf_fp_edch_header_crc, tvb,\r\n                offset, 2, header_crc,\r\n                \"%u%u%u%u %u%u%u. %u%u%u%u .... = E-DCH Header CRC: 0x%x\",\r\n                (header_crc >> 10) & 1,\r\n                (header_crc >> 9) & 1,\r\n                (header_crc >> 8) & 1,\r\n                (header_crc >> 7) & 1,\r\n                (header_crc >> 6) & 1,\r\n                (header_crc >> 5) & 1,\r\n                (header_crc >> 4) & 1,\r\n                (header_crc >> 3) & 1,\r\n                (header_crc >> 2) & 1,\r\n                (header_crc >> 1) & 1,\r\n                (header_crc >> 0) & 1, header_crc);\r\n        proto_tree_add_item(tree, hf_fp_ft, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n        offset++;\r\n        /* FSN */\r\n        proto_tree_add_item(tree, hf_fp_edch_fsn, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n        offset++;\r\n\r\n        /* Number of subframes.\r\n           This was 3 bits in early releases, is 4 bits offset by 1 in later releases  */\r\n        if ((p_fp_info->release >= 6) &&\r\n            ((p_fp_info->release_year > 2005) ||\r\n             ((p_fp_info->release_year == 2005) && (p_fp_info->release_month >= 9)))) {\r\n\r\n            /* Use 4 bits plus offset of 1 */\r\n            number_of_subframes = (tvb_get_uint8(tvb, offset) & 0x0f) + 1;\r\n        }\r\n        else {\r\n            /* Use 3 bits only */\r\n            number_of_subframes = (tvb_get_uint8(tvb, offset) & 0x07);\r\n        }\r\n        proto_tree_add_uint(tree, hf_fp_edch_number_of_subframes, tvb, offset, 1,\r\n                            number_of_subframes);\r\n\r\n        offset++;\r\n\r\n        /* CFN */\r\n        proto_tree_add_item_ret_uint(tree, hf_fp_cfn, tvb, offset, 1, ENC_BIG_ENDIAN, &cfn);\r\n        offset++;\r\n\r\n        /* Remainder of T2 or common data frames differ here... */\r\n        if (p_fp_info->edch_type == 1) {\r\n            dissect_e_dch_t2_or_common_channel_info(tvb, pinfo, tree, offset, p_fp_info,\r\n                                                    number_of_subframes,\r\n                                                    is_common, header_crc,\r\n                                                    header_crc_pi, data);\r\n            return;\r\n        }\r\n\r\n        /* EDCH subframe header list */\r\n        for (n=0; n < number_of_subframes; n++) {\r\n            int i;\r\n            int start_offset = offset;\r\n            proto_item *subframe_header_ti;\r\n            proto_tree *subframe_header_tree;\r\n\r\n            /* Add subframe header subtree */\r\n            subframe_header_ti = proto_tree_add_string_format(tree, hf_fp_edch_subframe_header, tvb, offset, 0,\r\n                                                              \"\", \"Subframe\");\r\n            subframe_header_tree = proto_item_add_subtree(subframe_header_ti, ett_fp_edch_subframe_header);\r\n\r\n            /* Number of HARQ Retransmissions */\r\n            proto_tree_add_item(subframe_header_tree, hf_fp_edch_harq_retransmissions, tvb,\r\n                                offset, 1, ENC_BIG_ENDIAN);\r\n\r\n            /* Subframe number */\r\n            subframes[n].subframe_number = (tvb_get_uint8(tvb, offset) & 0x07);\r\n            proto_tree_add_bits_item(subframe_header_tree, hf_fp_edch_subframe_number, tvb,\r\n                                     offset*8+5, 3, ENC_BIG_ENDIAN);\r\n            offset++;\r\n\r\n            /* Number of MAC-es PDUs */\r\n            subframes[n].number_of_mac_es_pdus = (tvb_get_uint8(tvb, offset) & 0xf0) >> 4;\r\n            proto_tree_add_item(subframe_header_tree, hf_fp_edch_number_of_mac_es_pdus,\r\n                                tvb, offset, 1, ENC_BIG_ENDIAN);\r\n            bit_offset = 4;\r\n\r\n            proto_item_append_text(subframe_header_ti, \" %u header (%u MAC-es PDUs)\",\r\n                                   subframes[n].subframe_number,\r\n                                   subframes[n].number_of_mac_es_pdus);\r\n\r\n            /* Details of each MAC-es PDU */\r\n            for (i=0; i < subframes[n].number_of_mac_es_pdus; i++) {\r\n                uint64_t ddi;\r\n                uint64_t n_pdus;    /*Size of the PDU*/\r\n\r\n                proto_item *ddi_ti;\r\n                int ddi_size = -1;\r\n                int     p;\r\n\r\n                /* DDI (6 bits) */\r\n                ddi_ti = proto_tree_add_bits_ret_val(subframe_header_tree, hf_fp_edch_ddi, tvb,\r\n                                                     offset*8 + bit_offset, 6, &ddi, ENC_BIG_ENDIAN);\r\n\r\n                rlcinf->rbid[i] = (uint8_t)ddi;\r\n                /********************************/\r\n                /* Look up data in higher layers*/\r\n                /* Look up the size from this DDI value */\r\n                for (p=0; p < p_fp_info->no_ddi_entries; p++) {\r\n                    if (ddi == p_fp_info->edch_ddi[p]) {\r\n                        ddi_size = p_fp_info->edch_macd_pdu_size[p];\r\n\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                if (ddi_size == -1) {\r\n                    expert_add_info_format(pinfo, ddi_ti, &ei_fp_ddi_not_defined, \"DDI %u not defined for this UE!\", (unsigned)ddi);\r\n                    return;\r\n                }\r\n                else {\r\n                    proto_item_append_text(ddi_ti, \" (%d bits)\", ddi_size);\r\n                }\r\n\r\n                subframes[n].ddi[i] = (uint8_t)ddi;\r\n                bit_offset += 6;\r\n\r\n                /* Number of MAC-d PDUs (6 bits) */\r\n                item = proto_tree_add_bits_ret_val(subframe_header_tree, hf_fp_edch_number_of_mac_d_pdus, tvb,\r\n                                            offset*8 + bit_offset, 6, &n_pdus, ENC_BIG_ENDIAN);\r\n                if (n_pdus > MAX_MAC_FRAMES) {\r\n                    expert_add_info_format(pinfo, item, &ei_fp_invalid_frame_count, \"Invalid number of PDUs (max is %u)\", MAX_MAC_FRAMES);\r\n                    return;\r\n                }\r\n\r\n                subframes[n].number_of_mac_d_pdus[i] = (uint8_t)n_pdus;\r\n                bit_offset += 6;\r\n            }\r\n\r\n            offset += ((bit_offset+7)/8);\r\n\r\n            /* Tree should cover entire subframe header */\r\n            proto_item_set_len(subframe_header_ti, offset - start_offset);\r\n        }\r\n        header_length = offset;\r\n        /* EDCH subframes */\r\n        for (n=0; n < number_of_subframes; n++) {\r\n            int i;\r\n            proto_item *subframe_ti;\r\n            proto_tree *subframe_tree;\r\n            unsigned bits_in_subframe = 0;\r\n            unsigned mac_d_pdus_in_subframe = 0;\r\n            unsigned lchid=0;    /*Logical channel id*/\r\n            uint32_t user_identity;\r\n            umts_mac_info *macinf;\r\n            bit_offset = 0;\r\n\r\n            macinf = (umts_mac_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_umts_mac, 0);\r\n            if (!macinf) {\r\n                macinf = wmem_new0(pinfo->pool, umts_mac_info);\r\n            }\r\n            /* Add subframe subtree */\r\n            subframe_ti = proto_tree_add_string_format(tree, hf_fp_edch_subframe, tvb, offset, 0,\r\n                                                       \"\", \"Subframe %u data\", subframes[n].subframe_number);\r\n            subframe_tree = proto_item_add_subtree(subframe_ti, ett_fp_edch_subframe);\r\n\r\n            for (i=0; i < subframes[n].number_of_mac_es_pdus; i++) {\r\n                int         m;\r\n                uint16_t    size = 0;\r\n                /* uint8_t     tsn; */\r\n                unsigned    send_size;\r\n                proto_item  *ti;\r\n                int         macd_idx;\r\n                proto_tree  *maces_tree = NULL;\r\n\r\n                /** TODO: Merge these two loops? **/\r\n                /* Look up mac-d pdu size for this ddi */\r\n                for (m=0; m < p_fp_info->no_ddi_entries; m++) {\r\n                    if (subframes[n].ddi[i] == p_fp_info->edch_ddi[m]) {\r\n                        size = p_fp_info->edch_macd_pdu_size[m];\r\n                        break;\r\n                    }\r\n                }\r\n                /* Look up logicalchannel id for this DDI value */\r\n                for (m=0; m < p_fp_info->no_ddi_entries; m++) {\r\n                    if (subframes[n].ddi[i] == p_fp_info->edch_ddi[m]) {\r\n                        lchid = p_fp_info->edch_lchId[m];\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                if (m == p_fp_info->no_ddi_entries) {\r\n                    /* Not found.  Oops */\r\n                    expert_add_info(pinfo, NULL, &ei_fp_unable_to_locate_ddi_entry);\r\n                    return;\r\n                }\r\n\r\n                /* Send MAC-dd PDUs together as one MAC-es PDU */\r\n                send_size = size * subframes[n].number_of_mac_d_pdus[i];\r\n\r\n                /* 2 bits spare */\r\n                proto_tree_add_item(subframe_tree, hf_fp_edch_pdu_padding, tvb,\r\n                                    offset + (bit_offset/8),\r\n                                    1, ENC_BIG_ENDIAN);\r\n                bit_offset += 2;\r\n\r\n                /* TSN */\r\n                /* tsn = (tvb_get_uint8(tvb, offset + (bit_offset/8)) & 0x3f); */\r\n                proto_tree_add_item(subframe_tree, hf_fp_edch_tsn, tvb,\r\n                                    offset + (bit_offset/8),\r\n                                    1, ENC_BIG_ENDIAN);\r\n                bit_offset += 6;\r\n\r\n                /* PDU */\r\n                if (subframe_tree) {\r\n                    ti = proto_tree_add_item(subframe_tree, hf_fp_edch_mac_es_pdu, tvb,\r\n                                             offset + (bit_offset/8),\r\n                                             ((bit_offset % 8) + send_size + 7) / 8,\r\n                                             ENC_NA);\r\n                    proto_item_append_text(ti, \" (%u * %u = %u bits, PDU %d)\",\r\n                                           size, subframes[n].number_of_mac_d_pdus[i],\r\n                                           send_size, n);\r\n                    maces_tree = proto_item_add_subtree(ti, ett_fp_edch_maces);\r\n                }\r\n                /* Determine the UE ID to use in RLC */\r\n                user_identity = p_fp_info->com_context_id;\r\n                if(p_fp_info->urnti) {\r\n                    user_identity = p_fp_info->urnti;\r\n                }\r\n                for (macd_idx = 0; macd_idx < subframes[n].number_of_mac_d_pdus[i]; macd_idx++) {\r\n\r\n                    if (preferences_call_mac_dissectors) {\r\n                        /* Should no longer happen ??*/\r\n                        if (macd_idx >= MAX_MAC_FRAMES) {\r\n                            expert_add_info_format(pinfo, subframe_tree, &ei_fp_invalid_frame_count, \"Invalid frame count (max is %u)\", MAX_MAC_FRAMES);\r\n                            return;\r\n                        }\r\n\r\n                        tvbuff_t *next_tvb;\r\n                        /* create new TVB and pass further on */\r\n                        next_tvb = tvb_new_subset_length(tvb, offset + bit_offset/8,\r\n                                ((bit_offset % 8) + size + 7) / 8);\r\n\r\n                        /*Set up information needed for MAC and lower layers*/\r\n                        macinf->content[macd_idx] = lchId_type_table[lchid];     /*Set the proper Content type for the mac layer.*/\r\n                        macinf->lchid[macd_idx] = lchid;\r\n                        rlcinf->mode[macd_idx] = lchId_rlc_map[lchid]; /* Set RLC mode by lchid to RLC_MODE map in nbap.h */\r\n\r\n                        /* Set UE ID to U-RNTI or NBAP Communication Context*/\r\n                        rlcinf->ueid[macd_idx] = user_identity;\r\n                        rlcinf->rbid[macd_idx] = lchid;\r\n                        rlcinf->li_size[macd_idx] = RLC_LI_7BITS;\r\n\r\n                        rlcinf->ciphered[macd_idx] = false;\r\n                        rlcinf->deciphered[macd_idx] = false;\r\n                        p_fp_info->cur_tb = macd_idx;    /*Set the transport block index */\r\n\r\n                        call_dissector_with_data(mac_fdd_edch_handle, next_tvb, pinfo, top_level_tree, data);\r\n                        dissected = true;\r\n                    }\r\n                    else {\r\n                        /* Just add as a MAC-d PDU */\r\n                        proto_tree_add_item(maces_tree, hf_fp_mac_d_pdu, tvb,\r\n                                            offset + (bit_offset/8),\r\n                                            ((bit_offset % 8) + size + 7) / 8,\r\n                                            ENC_NA);\r\n                    }\r\n                    bit_offset += size;\r\n                }\r\n\r\n                bits_in_subframe += send_size;\r\n                mac_d_pdus_in_subframe += subframes[n].number_of_mac_d_pdus[i];\r\n\r\n                /* Pad out to next byte */\r\n                bit_offset = WS_ROUNDUP_8(bit_offset);\r\n            }\r\n\r\n            if (tree) {\r\n                /* Tree should cover entire subframe */\r\n                proto_item_set_len(subframe_ti, bit_offset/8);\r\n                /* Append summary info to subframe label */\r\n                proto_item_append_text(subframe_ti, \" (%u bits in %u MAC-d PDUs)\",\r\n                                       bits_in_subframe, mac_d_pdus_in_subframe);\r\n            }\r\n            total_pdus += mac_d_pdus_in_subframe;\r\n            total_bits += bits_in_subframe;\r\n\r\n            offset += (bit_offset/8);\r\n        }\r\n\r\n        /* Report number of subframes in info column\r\n         * do this only if no other dissector was called */\r\n        if (dissected == false) {\r\n            col_append_fstr(pinfo->cinfo, COL_INFO,\r\n                            \" CFN = %03u   (%u bits in %u pdus in %u subframes)\",\r\n                            cfn, total_bits, total_pdus, number_of_subframes);\r\n        }\r\n        /* Add data summary to info column */\r\n        /*col_append_fstr(pinfo->cinfo, COL_INFO, \" (%u bytes in %u SDUs in %u MAC-is PDUs in %u subframes)\",\r\n                        total_bytes, macis_sdus_found, macis_pdus, number_of_subframes);*/\r\n        if (preferences_header_checksum) {\r\n            verify_header_crc_edch(tvb, pinfo, header_crc_pi, header_crc, header_length);\r\n        }\r\n        /* Spare extension and payload CRC (optional) */\r\n        dissect_spare_extension_and_crc(tvb, pinfo, tree,\r\n                                        p_fp_info->dch_crc_present, offset, header_length);\r\n    }\r\n}", ".issect_hsdsch_channel_info": "static void\r\ndissect_hsdsch_channel_info(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\r\n                            int offset, struct fp_info *p_fp_info, void *data)\r\n{\r\n    uint32_t ft;\r\n    unsigned header_length;\r\n    uint32_t header_crc = 0;\r\n    proto_item * header_crc_pi = NULL;\r\n\r\n    /* Header CRC */\r\n    header_crc_pi = proto_tree_add_item_ret_uint(tree, hf_fp_header_crc, tvb, offset, 1, ENC_BIG_ENDIAN, &header_crc);\r\n\r\n    /* Frame Type */\r\n    proto_tree_add_item_ret_uint(tree, hf_fp_ft, tvb, offset, 1, ENC_BIG_ENDIAN, &ft);\r\n    offset++;\r\n\r\n    col_append_fstr(pinfo->cinfo, COL_INFO, \" [%s] \", val_to_str_const(ft, frame_type_vals, \"Unknown\"));\r\n\r\n    if (ft == FT_CONTROL) {\r\n        dissect_common_control(tvb, pinfo, tree, offset, p_fp_info);\r\n        /* For control frame the header CRC is actually frame CRC covering all\r\n         * bytes except the first */\r\n        if (preferences_header_checksum) {\r\n            verify_control_frame_crc(tvb, pinfo, header_crc_pi, (uint16_t)header_crc);\r\n        }\r\n    }\r\n    else {\r\n        uint8_t number_of_pdus;\r\n        uint16_t pdu_length;\r\n        uint16_t user_buffer_size;\r\n        int i;\r\n        umts_mac_info *macinf;\r\n        rlc_info *rlcinf;\r\n        uint32_t user_identity;\r\n        proto_item *item;\r\n\r\n        rlcinf = (rlc_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_umts_rlc, 0);\r\n        if (!rlcinf) {\r\n            rlcinf = wmem_new0(pinfo->pool, rlc_info);\r\n        }\r\n        macinf = (umts_mac_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_umts_mac, 0);\r\n        if (!macinf) {\r\n            macinf = wmem_new0(pinfo->pool, umts_mac_info);\r\n        }\r\n\r\n        /**************************************/\r\n        /* HS-DCH data here (type 1 in R7)    */\r\n\r\n        /* Frame Seq Nr */\r\n        if ((p_fp_info->release == 6) ||\r\n            (p_fp_info->release == 7)) {\r\n\r\n            uint8_t frame_seq_no = (tvb_get_uint8(tvb, offset) & 0xf0) >> 4;\r\n            proto_tree_add_item(tree, hf_fp_frame_seq_nr, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n\r\n            col_append_fstr(pinfo->cinfo, COL_INFO, \"  seqno=%u\", frame_seq_no);\r\n        }\r\n\r\n        /* CmCH-PI */\r\n        proto_tree_add_item(tree, hf_fp_cmch_pi, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n        offset++;\r\n\r\n        /* MAC-d PDU Length (13 bits) */\r\n        pdu_length = (tvb_get_ntohs(tvb, offset) >> 3);\r\n        proto_tree_add_item(tree, hf_fp_mac_d_pdu_len, tvb, offset, 2, ENC_BIG_ENDIAN);\r\n        offset += 2;\r\n        macinf->pdu_len = pdu_length;\r\n\r\n        if ((p_fp_info->release == 6) ||\r\n            (p_fp_info->release == 7)) {\r\n\r\n            /* Flush bit */\r\n            proto_tree_add_item(tree, hf_fp_flush, tvb, offset-1, 1, ENC_BIG_ENDIAN);\r\n\r\n            /* FSN/DRT reset bit */\r\n            proto_tree_add_item(tree, hf_fp_fsn_drt_reset, tvb, offset-1, 1, ENC_BIG_ENDIAN);\r\n        }\r\n\r\n        /* Num of PDUs */\r\n        number_of_pdus = tvb_get_uint8(tvb, offset);\r\n        item = proto_tree_add_item(tree, hf_fp_num_of_pdu, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n        offset++;\r\n        if (number_of_pdus > MAX_MAC_FRAMES) {\r\n            expert_add_info_format(pinfo, item, &ei_fp_invalid_frame_count, \"Invalid number of PDUs (max is %u)\", MAX_MAC_FRAMES);\r\n            return;\r\n        }\r\n\r\n        /* User buffer size */\r\n        user_buffer_size = tvb_get_ntohs(tvb, offset);\r\n        proto_tree_add_item(tree, hf_fp_user_buffer_size, tvb, offset, 2, ENC_BIG_ENDIAN);\r\n        offset += 2;\r\n\r\n        header_length = offset;\r\n\r\n\r\n        /* Determine the UE ID to use in RLC */\r\n        user_identity = p_fp_info->com_context_id;\r\n        if(p_fp_info->urnti) {\r\n            user_identity = p_fp_info->urnti;\r\n        }\r\n        /************************/\r\n        /*Configure the pdus*/\r\n        for (i=0;i<number_of_pdus && i<MIN(MAX_MAC_FRAMES, MAX_RLC_CHANS); i++) {\r\n            macinf->content[i] = hsdsch_macdflow_id_mac_content_map[p_fp_info->hsdsch_macflowd_id]; /*MAC_CONTENT_PS_DTCH;*/\r\n            macinf->lchid[i] = fake_lchid_macd_flow[p_fp_info->hsdsch_macflowd_id];/*Faked logical channel id 255 used as a mark if it doesn't exist...*/\r\n            macinf->fake_chid[i] = true;    /**/\r\n            macinf->macdflow_id[i] = p_fp_info->hsdsch_macflowd_id;    /*Save the flow ID (+1 to make it human readable (it's zero indexed!))*/\r\n\r\n            /*Check if this is multiplexed (signaled by RRC)*/\r\n            if (p_fp_info->hsdhsch_macfdlow_is_mux[p_fp_info->hsdsch_macflowd_id] ) {\r\n                macinf->ctmux[i] = true;\r\n            } else if (p_fp_info->hsdsch_macflowd_id == 0) {              /*MACd-flow = 0 is often SRB */\r\n                expert_add_info(pinfo, NULL, &ei_fp_maybe_srb);\r\n            } else {\r\n                    macinf->ctmux[i] = false;    /*Either it's multiplexed and not signalled or it's not MUX*/\r\n            }\r\n\r\n            /* Figure out RLC mode */\r\n            if(p_fp_info->hsdsch_rlc_mode != FP_RLC_MODE_UNKNOWN) {\r\n                /* We know the RLC mode, possibly reported from NBAP */\r\n                rlcinf->mode[i] = (enum rlc_mode)(p_fp_info->hsdsch_rlc_mode - 1);\r\n            }\r\n            else {\r\n                /* Guess the mode by the MACd-flow-ID, basically MACd-flow-ID = 0 then it's SRB0 == UM else AM */\r\n                /* This logic might be incorrect sometimes */\r\n                rlcinf->mode[i] = hsdsch_macdflow_id_rlc_map[p_fp_info->hsdsch_macflowd_id];\r\n            }\r\n\r\n            rlcinf->ueid[i] = user_identity;\r\n            rlcinf->li_size[i] = RLC_LI_7BITS;\r\n            rlcinf->deciphered[i] = false;\r\n            rlcinf->ciphered[i] = false;\r\n            rlcinf->rbid[i] = macinf->lchid[i];\r\n\r\n#if 0\r\n            /*When a flow has been reconfigured rlc needs to be reset.\r\n             * This needs more work though since we must figure out when the re-configuration becomes\r\n             * active based on the CFN value\r\n             * */\r\n            /*Indicate we need to reset stream*/\r\n            if (p_fp_info->reset_frag) {\r\n                rlc_reset_channel(rlcinf->mode[i], macinf->lchid[i], p_fp_info->is_uplink,  rlcinf->ueid[i] );\r\n                p_fp_info->reset_frag = false;\r\n\r\n            }\r\n#endif\r\n        }\r\n\r\n        col_append_fstr(pinfo->cinfo, COL_INFO, \"  %ux%u-bit PDUs  User-Buffer-Size=%u\",\r\n                        number_of_pdus, pdu_length, user_buffer_size);\r\n\r\n        /* MAC-d PDUs */\r\n        offset = dissect_macd_pdu_data(tvb, pinfo, tree, offset, pdu_length,\r\n                                       number_of_pdus, p_fp_info, data);\r\n\r\n        /* Extra IEs (if there is room for them) */\r\n        if (((p_fp_info->release == 6) ||\r\n             (p_fp_info->release == 7)) &&\r\n            (tvb_reported_length_remaining(tvb, offset) > 2)) {\r\n\r\n            int n;\r\n            uint8_t flags;\r\n            /* uint8_t flag_bytes = 0; */\r\n\r\n            /* New IE flags */\r\n            do {\r\n                proto_item *new_ie_flags_ti;\r\n                proto_tree *new_ie_flags_tree;\r\n                unsigned ies_found = 0;\r\n\r\n                /* Add new IE flags subtree */\r\n                new_ie_flags_ti = proto_tree_add_string_format(tree, hf_fp_hsdsch_new_ie_flags, tvb, offset, 1,\r\n                                                              \"\", \"New IE flags\");\r\n                new_ie_flags_tree = proto_item_add_subtree(new_ie_flags_ti, ett_fp_hsdsch_new_ie_flags);\r\n\r\n                /* Read next byte */\r\n                flags = tvb_get_uint8(tvb, offset);\r\n                /* flag_bytes++; */\r\n\r\n                /* Dissect individual bits */\r\n                for (n=0; n < 8; n++) {\r\n                    proto_tree_add_item(new_ie_flags_tree, hf_fp_hsdsch_new_ie_flag[n], tvb, offset, 1, ENC_BIG_ENDIAN);\r\n                    if ((flags >> (7-n)) & 0x01) {\r\n                        ies_found++;\r\n                    }\r\n                }\r\n                offset++;\r\n\r\n                proto_item_append_text(new_ie_flags_ti, \" (%u IEs found)\", ies_found);\r\n\r\n                /* Last bit set will indicate another flags byte follows... */\r\n            } while (0); /*((flags & 0x01) && (flag_bytes < 31));*/\r\n\r\n            if (1) /*(flags & 0x8) */ {\r\n                /* DRT is shown as mandatory in the diagram (3GPP TS 25.435 V6.3.0),\r\n                   but the description below it states that\r\n                   it should depend upon the first bit.  The detailed description of\r\n                   New IE flags doesn't agree, so treat as mandatory for now... */\r\n                proto_tree_add_item(tree, hf_fp_hsdsch_drt, tvb, offset, 2, ENC_BIG_ENDIAN);\r\n                offset += 2;\r\n            }\r\n        }\r\n        if (preferences_header_checksum) {\r\n            verify_header_crc(tvb, pinfo, header_crc_pi, header_crc, header_length);\r\n        }\r\n        /* Spare Extension and Payload CRC */\r\n        dissect_spare_extension_and_crc(tvb, pinfo, tree, 1, offset, header_length);\r\n    }\r\n}", ".issect_hsdsch_type_2_channel_info": "static void\r\ndissect_hsdsch_type_2_channel_info(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\r\n                                   int offset, struct fp_info *p_fp_info,\r\n                                   void *data)\r\n{\r\n    uint32_t ft;\r\n    uint32_t header_crc = 0;\r\n    proto_item * header_crc_pi = NULL;\r\n    uint16_t header_length;\r\n\r\n    /* Header CRC */\r\n    header_crc_pi = proto_tree_add_item_ret_uint(tree, hf_fp_header_crc, tvb, offset, 1, ENC_BIG_ENDIAN, &header_crc);\r\n\r\n    /* Frame Type */\r\n    proto_tree_add_item_ret_uint(tree, hf_fp_ft, tvb, offset, 1, ENC_BIG_ENDIAN, &ft);\r\n    offset++;\r\n\r\n    col_append_fstr(pinfo->cinfo, COL_INFO, \" [%s] \", val_to_str_const(ft, frame_type_vals, \"Unknown\"));\r\n\r\n    if (ft == FT_CONTROL) {\r\n        dissect_common_control(tvb, pinfo, tree, offset, p_fp_info);\r\n        /* For control frame the header CRC is actually frame CRC covering all\r\n         * bytes except the first */\r\n        if (preferences_header_checksum) {\r\n            verify_control_frame_crc(tvb, pinfo, header_crc_pi, (uint16_t)header_crc);\r\n        }\r\n    }\r\n    else {\r\n        uint8_t number_of_pdu_blocks;\r\n        bool drt_present = false;\r\n        bool fach_present = false;\r\n        uint16_t user_buffer_size;\r\n        int n;\r\n        unsigned j;\r\n        uint64_t lchid_val;\r\n\r\n        #define MAX_PDU_BLOCKS 31\r\n        uint64_t lchid_field[MAX_PDU_BLOCKS];\r\n        uint64_t pdu_length[MAX_PDU_BLOCKS];\r\n        uint64_t no_of_pdus[MAX_PDU_BLOCKS];\r\n\r\n        umts_mac_info *macinf;\r\n        rlc_info *rlcinf;\r\n        uint32_t user_identity;\r\n\r\n        rlcinf = (rlc_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_umts_rlc, 0);\r\n        if (!rlcinf) {\r\n            rlcinf = wmem_new0(pinfo->pool, rlc_info);\r\n        }\r\n        macinf = (umts_mac_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_umts_mac, 0);\r\n        if (!macinf) {\r\n            macinf = wmem_new0(pinfo->pool, umts_mac_info);\r\n        }\r\n\r\n        /********************************/\r\n        /* HS-DCH type 2 data here      */\r\n\r\n        col_append_str(pinfo->cinfo, COL_INFO, \"(ehs)\");\r\n\r\n        /* Frame Seq Nr (4 bits) */\r\n        if ((p_fp_info->release == 6) ||\r\n            (p_fp_info->release == 7)) {\r\n\r\n            uint8_t frame_seq_no = (tvb_get_uint8(tvb, offset) & 0xf0) >> 4;\r\n            proto_tree_add_item(tree, hf_fp_frame_seq_nr, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n\r\n            col_append_fstr(pinfo->cinfo, COL_INFO, \"  seqno=%u\", frame_seq_no);\r\n        }\r\n\r\n        /* CmCH-PI (4 bits) */\r\n        proto_tree_add_item(tree, hf_fp_cmch_pi, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n        offset++;\r\n\r\n        /* Total number of PDU blocks (5 bits) */\r\n        number_of_pdu_blocks = (tvb_get_uint8(tvb, offset) >> 3);\r\n        proto_tree_add_item(tree, hf_fp_total_pdu_blocks, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n\r\n        if (p_fp_info->release == 7) {\r\n            /* Flush bit */\r\n            proto_tree_add_item(tree, hf_fp_flush, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n\r\n            /* FSN/DRT reset bit */\r\n            proto_tree_add_item(tree, hf_fp_fsn_drt_reset, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n\r\n            /* DRT Indicator */\r\n            drt_present = tvb_get_uint8(tvb, offset) & 0x01;\r\n            proto_tree_add_item(tree, hf_fp_drt_indicator, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n        }\r\n        offset++;\r\n\r\n        /* FACH Indicator flag */\r\n        fach_present = (tvb_get_uint8(tvb, offset) & 0x80) >> 7;\r\n        proto_tree_add_item(tree, hf_fp_fach_indicator, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n        offset++;\r\n\r\n        /* User buffer size */\r\n        user_buffer_size = tvb_get_ntohs(tvb, offset);\r\n        proto_tree_add_item(tree, hf_fp_user_buffer_size, tvb, offset, 2, ENC_BIG_ENDIAN);\r\n        offset += 2;\r\n\r\n        col_append_fstr(pinfo->cinfo, COL_INFO, \"  User-Buffer-Size=%u\", user_buffer_size);\r\n\r\n\r\n\r\n        /********************************************************************/\r\n        /* Now read number_of_pdu_blocks header entries                     */\r\n        for (n=0; n < number_of_pdu_blocks; n++) {\r\n            proto_item *pdu_block_header_ti;\r\n            proto_tree *pdu_block_header_tree;\r\n            int        block_header_start_offset = offset;\r\n\r\n            /* Add PDU block header subtree */\r\n            pdu_block_header_ti = proto_tree_add_string_format(tree, hf_fp_hsdsch_pdu_block_header,\r\n                                                               tvb, offset, 0,\r\n                                                               \"\",\r\n                                                               \"PDU Block Header\");\r\n            pdu_block_header_tree = proto_item_add_subtree(pdu_block_header_ti,\r\n                                                           ett_fp_hsdsch_pdu_block_header);\r\n\r\n            /* MAC-d/c PDU length in this block (11 bits) */\r\n            proto_tree_add_bits_ret_val(pdu_block_header_tree, hf_fp_pdu_length_in_block, tvb,\r\n                                        (offset*8) + ((n % 2) ? 4 : 0), 11,\r\n                                        &pdu_length[n], ENC_BIG_ENDIAN);\r\n            if ((n % 2) == 0)\r\n                offset++;\r\n            else\r\n                offset += 2;\r\n\r\n\r\n            /* # PDUs in this block (4 bits) */\r\n            proto_tree_add_bits_ret_val(pdu_block_header_tree, hf_fp_pdus_in_block, tvb,\r\n                                        (offset*8) + ((n % 2) ? 0 : 4), 4,\r\n                                        &no_of_pdus[n], ENC_BIG_ENDIAN);\r\n            if ((n % 2) == 0) {\r\n                offset++;\r\n            }\r\n\r\n            /* Logical channel ID in block (4 bits) */\r\n            proto_tree_add_bits_ret_val(pdu_block_header_tree, hf_fp_lchid, tvb,\r\n                                        (offset*8) + ((n % 2) ? 4 : 0), 4,\r\n                                        &lchid_field[n], ENC_BIG_ENDIAN);\r\n            if ((n % 2) == 1) {\r\n                offset++;\r\n            }\r\n            else {\r\n                if (n == (number_of_pdu_blocks-1)) {\r\n                    /* Byte is padded out for last block */\r\n                    offset++;\r\n                }\r\n            }\r\n\r\n            /* Append summary to header tree root */\r\n            proto_item_append_text(pdu_block_header_ti,\r\n                                   \" (lch:%u, %u pdus of %u bytes)\",\r\n                                   (uint16_t)lchid_field[n],\r\n                                   (uint16_t)no_of_pdus[n],\r\n                                   (uint16_t)pdu_length[n]);\r\n\r\n            /* Set length of header tree item */\r\n            if (((n % 2) == 0) && (n < (number_of_pdu_blocks-1))) {\r\n                proto_item_set_len(pdu_block_header_ti,\r\n                                   offset - block_header_start_offset+1);\r\n            }\r\n            else {\r\n                proto_item_set_len(pdu_block_header_ti,\r\n                                   offset - block_header_start_offset);\r\n            }\r\n        }\r\n\r\n        header_length = offset;\r\n\r\n        /**********************************************/\r\n        /* Optional fields indicated by earlier flags */\r\n        if (drt_present) {\r\n            /* DRT */\r\n            proto_tree_add_item(tree, hf_fp_drt, tvb, offset, 2, ENC_BIG_ENDIAN);\r\n            offset += 2;\r\n        }\r\n\r\n        if (fach_present) {\r\n            /* H-RNTI: */\r\n            proto_tree_add_item(tree, hf_fp_hrnti, tvb, offset, 2, ENC_BIG_ENDIAN);\r\n            offset += 2;\r\n\r\n            /* RACH Measurement Result */\r\n            proto_tree_add_item(tree, hf_fp_rach_measurement_result, tvb, offset, 2, ENC_BIG_ENDIAN);\r\n            offset++;\r\n        }\r\n\r\n\r\n        /* Determine the UE ID to use in RLC */\r\n        user_identity = p_fp_info->com_context_id;\r\n        if(p_fp_info->urnti) {\r\n            user_identity = p_fp_info->urnti;\r\n        }\r\n        /********************************************************************/\r\n        /* Now read the MAC-d/c PDUs for each block using info from headers */\r\n        for (n=0; n < number_of_pdu_blocks; n++) {\r\n            for (j=0;j<no_of_pdus[n];j++) {\r\n\r\n                /*Configure (signal to lower layers) the PDU!*/\r\n                if (lchid_field[n] != 0x0f) {\r\n                    lchid_val = lchid_field[n] + 1; /* Add 1 since 'LCHID' field is zero indexed. ie field value = 0 => Actual L-CHID = 1*/\r\n                    macinf->content[j] = lchId_type_table[lchid_val];\r\n                    macinf->lchid[j] = (uint8_t)lchid_val;\r\n                    macinf->macdflow_id[j] = p_fp_info->hsdsch_macflowd_id;\r\n                    /*Figure out RLC_MODE based on MACd-flow-ID, basically MACd-flow-ID = 0 then it's SRB0 == UM else AM*/\r\n                    rlcinf->mode[j] = lchId_rlc_map[lchid_val];\r\n\r\n                    macinf->ctmux[n] = false;\r\n\r\n                    rlcinf->li_size[j] = RLC_LI_7BITS;\r\n                    rlcinf->ciphered[j] = false;\r\n                    rlcinf->deciphered[j] = false;\r\n                    rlcinf->rbid[j] = (uint8_t)lchid_val;\r\n\r\n                    rlcinf->ueid[j] = user_identity;\r\n                }\r\n                else {\r\n                    /* LCHID field is 15. This value indicates BCCH or PCCH mapped on HS-DSCH*/\r\n                    /* The dissector does not handle this case yet, so we are filling zeroes and default values below*/\r\n                    macinf->content[j] = MAC_CONTENT_UNKNOWN;\r\n                    macinf->lchid[j] = 0; /* LCHID field doesn't reflect a real ID in this case*/\r\n                    macinf->macdflow_id[j] = 0;\r\n                    macinf->ctmux[j] = false;\r\n\r\n                    rlcinf->mode[j] = RLC_TM; /* PCCH and BCCH should be using RLC TM? */\r\n                    rlcinf->li_size[j] = RLC_LI_7BITS;\r\n                    rlcinf->ciphered[j] = false;\r\n                    rlcinf->deciphered[j] = false;\r\n                    rlcinf->rbid[j] = 0;\r\n                    rlcinf->ueid[j] = 0;\r\n                }\r\n            }\r\n\r\n            /* Add PDU block header subtree */\r\n            offset = dissect_macd_pdu_data_type_2(tvb, pinfo, tree, offset,\r\n                                                  (uint16_t)pdu_length[n],\r\n                                                  (uint16_t)no_of_pdus[n],\r\n                                                  p_fp_info, data);\r\n        }\r\n        if (preferences_header_checksum) {\r\n            verify_header_crc(tvb, pinfo, header_crc_pi, header_crc, header_length);\r\n        }\r\n        /* Spare Extension and Payload CRC */\r\n        dissect_spare_extension_and_crc(tvb, pinfo, tree, 1, offset, header_length);\r\n    }\r\n}", ".issect_hsdsch_common_channel_info": "static\r\nvoid dissect_hsdsch_common_channel_info(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\r\n                                        int offset, struct fp_info *p_fp_info,\r\n                                        void *data)\r\n{\r\n    uint32_t ft;\r\n    uint32_t header_crc = 0;\r\n    proto_item * header_crc_pi = NULL;\r\n    unsigned header_length;\r\n\r\n    /* Header CRC */\r\n    header_crc_pi = proto_tree_add_item_ret_uint(tree, hf_fp_header_crc, tvb, offset, 1, ENC_BIG_ENDIAN, &header_crc);\r\n\r\n    /* Frame Type */\r\n    proto_tree_add_item_ret_uint(tree, hf_fp_ft, tvb, offset, 1, ENC_BIG_ENDIAN, &ft);\r\n    offset++;\r\n\r\n    col_append_fstr(pinfo->cinfo, COL_INFO, \" [%s] \", val_to_str_const(ft, frame_type_vals, \"Unknown\"));\r\n\r\n    if (ft == FT_CONTROL) {\r\n        dissect_common_control(tvb, pinfo, tree, offset, p_fp_info);\r\n        /* For control frame the header CRC is actually frame CRC covering all\r\n         * bytes except the first */\r\n        if (preferences_header_checksum) {\r\n            verify_control_frame_crc(tvb, pinfo, header_crc_pi, (uint16_t)header_crc);\r\n        }\r\n    }\r\n    else {\r\n        uint8_t number_of_pdu_blocks;\r\n        bool drt_present = false;\r\n        bool fach_present = false;\r\n        uint16_t user_buffer_size;\r\n        int n;\r\n        unsigned j;\r\n\r\n        #define MAX_PDU_BLOCKS 31\r\n        uint64_t lchid[MAX_PDU_BLOCKS];\r\n        uint64_t pdu_length[MAX_PDU_BLOCKS];\r\n        uint64_t no_of_pdus[MAX_PDU_BLOCKS];\r\n        uint8_t newieflags = 0;\r\n\r\n        umts_mac_info *macinf;\r\n        rlc_info *rlcinf;\r\n\r\n        rlcinf = (rlc_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_umts_rlc, 0);\r\n        if (!rlcinf) {\r\n            rlcinf = wmem_new0(pinfo->pool, rlc_info);\r\n        }\r\n        macinf = (umts_mac_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_umts_mac, 0);\r\n        if (!macinf) {\r\n            macinf = wmem_new0(pinfo->pool, umts_mac_info);\r\n        }\r\n        /********************************/\r\n        /* HS-DCH type 2 data here      */\r\n\r\n        col_append_str(pinfo->cinfo, COL_INFO, \"(ehs)\");\r\n\r\n        /* Frame Seq Nr (4 bits) */\r\n        if ((p_fp_info->release == 6) ||\r\n            (p_fp_info->release == 7)) {\r\n\r\n            uint8_t frame_seq_no = (tvb_get_uint8(tvb, offset) & 0xf0) >> 4;\r\n            proto_tree_add_item(tree, hf_fp_frame_seq_nr, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n\r\n            col_append_fstr(pinfo->cinfo, COL_INFO, \"  seqno=%u\", frame_seq_no);\r\n        }\r\n\r\n        /* CmCH-PI (4 bits) */\r\n        proto_tree_add_item(tree, hf_fp_cmch_pi, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n        offset++;\r\n\r\n        /* Total number of PDU blocks (5 bits) */\r\n        number_of_pdu_blocks = (tvb_get_uint8(tvb, offset) >> 3);\r\n        proto_tree_add_item(tree, hf_fp_total_pdu_blocks, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n\r\n        if (p_fp_info->release == 7) {\r\n            /* Flush bit */\r\n            proto_tree_add_item(tree, hf_fp_flush, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n\r\n            /* FSN/DRT reset bit */\r\n            proto_tree_add_item(tree, hf_fp_fsn_drt_reset, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n\r\n            /* DRT Indicator */\r\n            drt_present = tvb_get_uint8(tvb, offset) & 0x01;\r\n            proto_tree_add_item(tree, hf_fp_drt_indicator, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n        }\r\n        offset++;\r\n\r\n        /* FACH Indicator flag */\r\n        fach_present = (tvb_get_uint8(tvb, offset) & 0x80) >> 7;\r\n        proto_tree_add_item(tree, hf_fp_fach_indicator, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n        offset++;\r\n\r\n        /* User buffer size */\r\n        user_buffer_size = tvb_get_ntohs(tvb, offset);\r\n        proto_tree_add_item(tree, hf_fp_user_buffer_size, tvb, offset, 2, ENC_BIG_ENDIAN);\r\n        offset += 2;\r\n\r\n        col_append_fstr(pinfo->cinfo, COL_INFO, \"  User-Buffer-Size=%u\", user_buffer_size);\r\n\r\n\r\n        /********************************************************************/\r\n        /* Now read number_of_pdu_blocks header entries                     */\r\n        for (n=0; n < number_of_pdu_blocks; n++) {\r\n            proto_item *pdu_block_header_ti;\r\n            proto_item *item;\r\n            proto_tree *pdu_block_header_tree;\r\n            int        block_header_start_offset = offset;\r\n\r\n            /* Add PDU block header subtree */\r\n            pdu_block_header_ti = proto_tree_add_string_format(tree, hf_fp_hsdsch_pdu_block_header,\r\n                                                               tvb, offset, 0,\r\n                                                               \"\",\r\n                                                               \"PDU Block Header\");\r\n            pdu_block_header_tree = proto_item_add_subtree(pdu_block_header_ti,\r\n                                                           ett_fp_hsdsch_pdu_block_header);\r\n\r\n            /* MAC-d/c PDU length in this block (11 bits) */\r\n            proto_tree_add_bits_ret_val(pdu_block_header_tree, hf_fp_pdu_length_in_block, tvb,\r\n                                        (offset*8) + ((n % 2) ? 4 : 0), 11,\r\n                                        &pdu_length[n], ENC_BIG_ENDIAN);\r\n            if ((n % 2) == 0)\r\n                offset++;\r\n            else\r\n                offset += 2;\r\n\r\n\r\n            /* # PDUs in this block (4 bits) */\r\n            item = proto_tree_add_bits_ret_val(pdu_block_header_tree, hf_fp_pdus_in_block, tvb,\r\n                                        (offset*8) + ((n % 2) ? 0 : 4), 4,\r\n                                        &no_of_pdus[n], ENC_BIG_ENDIAN);\r\n            if ((n % 2) == 0) {\r\n                offset++;\r\n            }\r\n            if (no_of_pdus[n] > MAX_MAC_FRAMES) {\r\n                expert_add_info_format(pinfo, item, &ei_fp_invalid_frame_count, \"Invalid number of PDUs (max is %u)\", MAX_MAC_FRAMES);\r\n                return;\r\n            }\r\n\r\n            /* Logical channel ID in block (4 bits) */\r\n            proto_tree_add_bits_ret_val(pdu_block_header_tree, hf_fp_lchid, tvb,\r\n                                        (offset*8) + ((n % 2) ? 4 : 0), 4,\r\n                                        &lchid[n], ENC_BIG_ENDIAN);\r\n            if ((n % 2) == 1) {\r\n                offset++;\r\n            }\r\n            else {\r\n                if (n == (number_of_pdu_blocks-1)) {\r\n                    /* Byte is padded out for last block */\r\n                    offset++;\r\n                }\r\n            }\r\n\r\n            /* Append summary to header tree root */\r\n            proto_item_append_text(pdu_block_header_ti,\r\n                                   \" (lch:%u, %u pdus of %u bytes)\",\r\n                                   (uint16_t)lchid[n],\r\n                                   (uint16_t)no_of_pdus[n],\r\n                                   (uint16_t)pdu_length[n]);\r\n\r\n            /* Set length of header tree item */\r\n            if (((n % 2) == 0) && (n < (number_of_pdu_blocks-1))) {\r\n                proto_item_set_len(pdu_block_header_ti,\r\n                                   offset - block_header_start_offset+1);\r\n            }\r\n            else {\r\n                proto_item_set_len(pdu_block_header_ti,\r\n                                   offset - block_header_start_offset);\r\n            }\r\n        }\r\n\r\n        header_length = offset;\r\n\r\n        /**********************************************/\r\n        /* Optional fields indicated by earlier flags */\r\n        if (drt_present) {\r\n            /* DRT */\r\n            proto_tree_add_item(tree, hf_fp_drt, tvb, offset, 2, ENC_BIG_ENDIAN);\r\n            offset += 2;\r\n        }\r\n\r\n        if (fach_present) {\r\n            /* H-RNTI: */\r\n            proto_tree_add_item(tree, hf_fp_hrnti, tvb, offset, 2, ENC_BIG_ENDIAN);\r\n            offset += 2;\r\n\r\n            /* RACH Measurement Result */\r\n            proto_tree_add_item(tree, hf_fp_rach_measurement_result, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n            offset++;\r\n        }\r\n\r\n        /********************************************************************/\r\n        /* Now read the MAC-d/c PDUs for each block using info from headers */\r\n        for (n=0; n < number_of_pdu_blocks; n++) {\r\n            tvbuff_t *next_tvb;\r\n            for (j=0; j<no_of_pdus[n]; j++) {\r\n                /* If all bits are set, then this is BCCH or PCCH according to: 25.435 paragraph: 6.2.7.31 */\r\n                if (lchid[n] == 0xF) {\r\n                    /* In the very few test cases I've seen, this seems to be\r\n                     * BCCH with transparent MAC layer. Therefore skip right to\r\n                     * rlc_bcch and hope for the best. */\r\n                    next_tvb = tvb_new_subset_length(tvb, offset, (int)pdu_length[n]);\r\n                    call_dissector_with_data(rlc_bcch_handle, next_tvb, pinfo, top_level_tree, data);\r\n                    offset += (int)pdu_length[n];\r\n                } else { /* Else go for CCCH UM, this seems to work. */\r\n                    p_fp_info->hsdsch_entity = ehs; /* HSDSCH type 2 */\r\n                    if (j >= MAX_MAC_FRAMES) {\r\n                        /* Should not happen as we check no_of_pdus[n]*/\r\n                        expert_add_info_format(pinfo, tree, &ei_fp_invalid_frame_count, \"Invalid frame count (max is %u)\", MAX_MAC_FRAMES);\r\n                        return;\r\n                    }\r\n                    p_fp_info->cur_tb = j; /* set cur_tb for MAC and RRC */\r\n                    macinf->content[j] = MAC_CONTENT_CCCH;\r\n                    macinf->lchid[j] = (uint8_t)lchid[n]+1; /*Add 1 since it is zero indexed? */\r\n                    macinf->macdflow_id[j] = p_fp_info->hsdsch_macflowd_id;\r\n                    macinf->ctmux[j] = false;\r\n\r\n                    rlcinf->li_size[j] = RLC_LI_7BITS;\r\n                    rlcinf->ciphered[j] = false;\r\n                    rlcinf->deciphered[j] = false;\r\n                    rlcinf->rbid[j] = (uint8_t)lchid[n]+1;\r\n                    rlcinf->ueid[j] = p_fp_info->channel; /*We need to fake \"UE ID\"*/\r\n\r\n                    next_tvb = tvb_new_subset_length(tvb, offset, (int)pdu_length[n]);\r\n                    call_dissector_with_data(mac_fdd_hsdsch_handle, next_tvb, pinfo, top_level_tree, data);\r\n\r\n                    offset += (int)pdu_length[n];\r\n                }\r\n            }\r\n        }\r\n\r\n        /* New IE Flags */\r\n        newieflags = tvb_get_uint8(tvb, offset);\r\n        /* If newieflags == 0000 0010 then this indicates that there is a\r\n         * HS-DSCH physical layer category and no other New IE flags. */\r\n        if (newieflags == 2) {\r\n            /* HS-DSCH physical layer category presence bit. */\r\n            proto_tree_add_uint(tree, hf_fp_hsdsch_new_ie_flag[6], tvb, offset, 1, newieflags);\r\n            offset++;\r\n            /* HS-DSCH physical layer category. */\r\n            proto_tree_add_bits_item(tree, hf_fp_hsdsch_physical_layer_category, tvb, offset*8, 6, ENC_BIG_ENDIAN);\r\n            offset++;\r\n        }\r\n        if (preferences_header_checksum) {\r\n            verify_header_crc(tvb, pinfo, header_crc_pi, header_crc, header_length);\r\n        }\r\n        /* Spare Extension and Payload CRC */\r\n        dissect_spare_extension_and_crc(tvb, pinfo, tree, 1, offset, header_length);\r\n    }\r\n}", ".issect_e_dch_t2_or_common_channel_info": "static void\r\ndissect_e_dch_t2_or_common_channel_info(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\r\n                                        int offset, struct fp_info *p_fp_info,\r\n                                        int number_of_subframes,\r\n                                        bool is_common,\r\n                                        uint16_t header_crc,\r\n                                        proto_item * header_crc_pi,\r\n                                        void *data)\r\n{\r\n    int      n;\r\n    int      pdu_no;\r\n    uint64_t total_macis_sdus;\r\n    uint16_t macis_sdus_found = 0;\r\n    /* uint16_t macis_pdus       = 0; */\r\n    bool F                = true; /* We want to continue loop if get E-RNTI indication... */\r\n    int      bit_offset;\r\n    proto_item *subframe_macis_descriptors_ti = NULL;\r\n    static struct edch_t2_subframe_info subframes[16];\r\n    unsigned header_length = 0;\r\n    /* User Buffer size */\r\n    proto_tree_add_bits_item(tree, hf_fp_edch_user_buffer_size, tvb, offset*8,\r\n                             18, ENC_BIG_ENDIAN);\r\n    offset += 2;\r\n\r\n    /* Spare is in-between... */\r\n\r\n    /* Total number of MAC-is SDUs */\r\n    proto_tree_add_bits_ret_val(tree, hf_fp_edch_no_macid_sdus, tvb, offset*8+4,\r\n                                12, &total_macis_sdus, ENC_BIG_ENDIAN);\r\n    offset += 2;\r\n\r\n    if (is_common) {\r\n        /* E-RNTI */\r\n        proto_tree_add_item(tree, hf_fp_edch_e_rnti, tvb, offset, 2, ENC_BIG_ENDIAN);\r\n        offset += 2;\r\n    }\r\n\r\n    bit_offset = offset*8;\r\n    /* EDCH subframe header list */\r\n    for (n=0; n < number_of_subframes; n++) {\r\n        uint64_t   subframe_number;\r\n        uint64_t   no_of_macis_pdus;\r\n        proto_item *subframe_header_ti;\r\n        proto_tree *subframe_header_tree;\r\n\r\n        /* Add subframe header subtree */\r\n        subframe_header_ti = proto_tree_add_string_format(tree, hf_fp_edch_subframe_header, tvb, offset, 0,\r\n                                                          \"\", \"Subframe\");\r\n        subframe_header_tree = proto_item_add_subtree(subframe_header_ti, ett_fp_edch_subframe_header);\r\n\r\n        /* Spare bit */\r\n        bit_offset++;\r\n\r\n        if (!is_common) {\r\n            /* Number of HARQ Retransmissions */\r\n            proto_tree_add_item(subframe_header_tree, hf_fp_edch_harq_retransmissions, tvb,\r\n                                bit_offset/8, 1, ENC_BIG_ENDIAN);\r\n            bit_offset += 4;\r\n        }\r\n\r\n        /* Subframe number */\r\n        proto_tree_add_bits_ret_val(subframe_header_tree, hf_fp_edch_subframe_number, tvb,\r\n                                    bit_offset, 3, &subframe_number, ENC_BIG_ENDIAN);\r\n        subframes[n].subframe_number = (uint8_t)subframe_number;\r\n        bit_offset += 3;\r\n\r\n        /* Number of MAC-is PDUs */\r\n        proto_tree_add_bits_ret_val(subframe_header_tree, hf_fp_edch_number_of_mac_is_pdus, tvb,\r\n                                    bit_offset, 4, &no_of_macis_pdus, ENC_BIG_ENDIAN);\r\n        bit_offset += 4;\r\n        subframes[n].number_of_mac_is_pdus = (uint8_t)no_of_macis_pdus;\r\n        /* macis_pdus += subframes[n].number_of_mac_is_pdus; */\r\n\r\n        /* Next 4 bits are spare for T2*/\r\n        if (!is_common) {\r\n            bit_offset += 4;\r\n        }\r\n\r\n        /* Show summary in root */\r\n        proto_item_append_text(subframe_header_ti, \" (SFN %u, %u MAC-is PDUs)\",\r\n                               subframes[n].subframe_number, subframes[n].number_of_mac_is_pdus);\r\n        proto_item_set_len(subframe_header_ti, is_common ? 1 : 2);\r\n    }\r\n    offset = bit_offset / 8;\r\n\r\n\r\n    /* MAC-is PDU descriptors for each subframe follow */\r\n    for (n=0; n < number_of_subframes; n++) {\r\n        proto_tree *subframe_macis_descriptors_tree;\r\n\r\n        /* Add subframe header subtree */\r\n        subframe_macis_descriptors_ti = proto_tree_add_string_format(tree, hf_fp_edch_macis_descriptors, tvb, offset, 0,\r\n                                                                     \"\", \"MAC-is descriptors (SFN %u)\", subframes[n].subframe_number);\r\n        proto_item_set_len(subframe_macis_descriptors_ti, subframes[n].number_of_mac_is_pdus*2);\r\n        subframe_macis_descriptors_tree = proto_item_add_subtree(subframe_macis_descriptors_ti,\r\n                                                                 ett_fp_edch_macis_descriptors);\r\n\r\n        /* Find a sequence of descriptors for each MAC-is PDU in this subframe */\r\n        for (pdu_no=0; pdu_no < subframes[n].number_of_mac_is_pdus; pdu_no++) {\r\n            proto_item *f_ti = NULL;\r\n\r\n            subframes[n].number_of_mac_is_sdus[pdu_no] = 0;\r\n\r\n            do {\r\n                /* Check we haven't gone past the limit */\r\n                if (macis_sdus_found++ > total_macis_sdus) {\r\n                    expert_add_info_format(pinfo, f_ti, &ei_fp_mac_is_sdus_miscount, \"Found too many (%u) MAC-is SDUs - header said there were %u\", macis_sdus_found, (uint16_t)total_macis_sdus);\r\n                }\r\n\r\n                /* LCH-ID */\r\n                subframes[n].mac_is_lchid[pdu_no][subframes[n].number_of_mac_is_sdus[pdu_no]] = (tvb_get_uint8(tvb, offset) & 0xf0) >> 4;\r\n                proto_tree_add_item(subframe_macis_descriptors_tree, hf_fp_edch_macis_lchid, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n                if (subframes[n].mac_is_lchid[pdu_no][subframes[n].number_of_mac_is_sdus[pdu_no]] == 15) {\r\n                    proto_item *ti;\r\n\r\n                    /* 4 bits of spare */\r\n                    offset++;\r\n\r\n                    /* E-RNTI */\r\n                    ti = proto_tree_add_item(tree, hf_fp_edch_e_rnti, tvb, offset, 2, ENC_BIG_ENDIAN);\r\n                    offset += 2;\r\n\r\n                    /* This is only allowed if:\r\n                       - it's the common case AND\r\n                       - it's the first descriptor */\r\n                    if (!is_common) {\r\n                        expert_add_info(pinfo, ti, &ei_fp_e_rnti_t2_edch_frames);\r\n                    }\r\n                    if (subframes[n].number_of_mac_is_sdus[pdu_no] > 0) {\r\n                        expert_add_info(pinfo, ti, &ei_fp_e_rnti_first_entry);\r\n                    }\r\n                    continue;\r\n                }\r\n\r\n                /* Length */\r\n                subframes[n].mac_is_length[pdu_no][subframes[n].number_of_mac_is_sdus[pdu_no]] = (tvb_get_ntohs(tvb, offset) & 0x0ffe) >> 1;\r\n                proto_tree_add_item(subframe_macis_descriptors_tree, hf_fp_edch_macis_length, tvb, offset, 2, ENC_BIG_ENDIAN);\r\n                offset++;\r\n\r\n                /* Flag */\r\n                F = tvb_get_uint8(tvb, offset) & 0x01;\r\n                f_ti = proto_tree_add_item(subframe_macis_descriptors_tree, hf_fp_edch_macis_flag, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n\r\n                subframes[n].number_of_mac_is_sdus[pdu_no]++;\r\n\r\n                offset++;\r\n            } while (F == 0);\r\n        }\r\n    }\r\n\r\n    /* Check overall count of MAC-is SDUs */\r\n    if (macis_sdus_found != total_macis_sdus) {\r\n        expert_add_info_format(pinfo, subframe_macis_descriptors_ti, &ei_fp_mac_is_sdus_miscount, \"Frame contains %u MAC-is SDUs - header said there would be %u!\", macis_sdus_found, (uint16_t)total_macis_sdus);\r\n    }\r\n    header_length = offset;\r\n    /* Now PDUs */\r\n    for (n=0; n < number_of_subframes; n++) {\r\n\r\n        /* MAC-is PDU */\r\n        for (pdu_no=0; pdu_no < subframes[n].number_of_mac_is_pdus; pdu_no++) {\r\n            int i;\r\n            unsigned length = 0;\r\n            umts_mac_is_info * mac_is_info = wmem_new(wmem_file_scope(), umts_mac_is_info);\r\n\r\n            mac_is_info->number_of_mac_is_sdus = subframes[n].number_of_mac_is_sdus[pdu_no];\r\n            DISSECTOR_ASSERT(subframes[n].number_of_mac_is_sdus[pdu_no] <= MAX_MAC_FRAMES);\r\n            for (i = 0; i < subframes[n].number_of_mac_is_sdus[pdu_no]; i++) {\r\n                mac_is_info->sdulength[i] = subframes[n].mac_is_length[pdu_no][i];\r\n                mac_is_info->lchid[i] = subframes[n].mac_is_lchid[pdu_no][i];\r\n                length += subframes[n].mac_is_length[pdu_no][i];\r\n            }\r\n\r\n            /* Call MAC for this PDU if configured to */\r\n            if (preferences_call_mac_dissectors) {\r\n                p_add_proto_data(wmem_file_scope(), pinfo, proto_umts_mac, 0, mac_is_info);\r\n                call_dissector_with_data(mac_fdd_edch_type2_handle, tvb_new_subset_remaining(tvb, offset), pinfo, top_level_tree, data);\r\n            }\r\n            else {\r\n                /* Still show data if not decoding as MAC PDU */\r\n                proto_tree_add_item(tree, hf_fp_edch_mac_is_pdu, tvb, offset, length, ENC_NA);\r\n            }\r\n\r\n            /* get_mac_tsn_size in packet-umts_mac.h, gets the global_mac_tsn_size preference in umts_mac.c */\r\n            if (get_mac_tsn_size() == MAC_TSN_14BITS) {\r\n                offset += length + 2; /* Plus 2 bytes for TSN 14 bits and SS 2 bit. */\r\n            } else {\r\n                offset += length + 1; /* Plus 1 byte for TSN 6 bits and SS 2 bit. */\r\n            }\r\n        }\r\n    }\r\n    if (preferences_header_checksum) {\r\n        verify_header_crc_edch(tvb, pinfo, header_crc_pi, header_crc, header_length);\r\n    }\r\n    /* Spare extension and payload CRC (optional) */\r\n    dissect_spare_extension_and_crc(tvb, pinfo, tree,\r\n                                    p_fp_info->dch_crc_present, offset, header_length);\r\n}", ".issect_dsch_channel_info": "static void\r\ndissect_dsch_channel_info(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\r\n                          int offset, struct fp_info *p_fp_info)\r\n{\r\n    uint32_t ft;\r\n\r\n    /* Header CRC */\r\n    proto_tree_add_item(tree, hf_fp_header_crc, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n\r\n    /* Frame Type */\r\n    proto_tree_add_item_ret_uint(tree, hf_fp_ft, tvb, offset, 1, ENC_BIG_ENDIAN, &ft);\r\n    offset++;\r\n\r\n    col_append_fstr(pinfo->cinfo, COL_INFO, \" [%s] \", val_to_str_const(ft, frame_type_vals, \"Unknown\"));\r\n\r\n    if (ft == FT_CONTROL) {\r\n        dissect_common_control(tvb, pinfo, tree, offset, p_fp_info);\r\n    }\r\n    else {\r\n        uint32_t cfn;\r\n        unsigned header_length = 0;\r\n\r\n        /* DATA */\r\n\r\n        /* CFN */\r\n        proto_tree_add_item_ret_uint(tree, hf_fp_cfn, tvb, offset, 1, ENC_BIG_ENDIAN, &cfn);\r\n        offset++;\r\n\r\n        col_append_fstr(pinfo->cinfo, COL_INFO, \"CFN=%03u \", cfn);\r\n\r\n        /* TFI */\r\n        proto_tree_add_item(tree, hf_fp_tfi, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n        offset++;\r\n\r\n\r\n        /* Other fields depend upon release & FDD/TDD settings */\r\n        if (((p_fp_info->release == 99) || (p_fp_info->release == 4)) &&\r\n             (p_fp_info->channel == CHANNEL_DSCH_FDD)) {\r\n\r\n            /* Power offset */\r\n            proto_tree_add_float(tree, hf_fp_power_offset, tvb, offset, 1,\r\n                                 (float)(-32.0) +\r\n                                  ((float)(int)(tvb_get_uint8(tvb, offset)) * (float)(0.25)));\r\n            offset++;\r\n\r\n            /* Code number */\r\n            proto_tree_add_item(tree, hf_fp_code_number, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n            offset++;\r\n\r\n            /* Spreading Factor (3 bits) */\r\n            proto_tree_add_item(tree, hf_fp_spreading_factor, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n\r\n            /* MC info (4 bits)*/\r\n            proto_tree_add_item(tree, hf_fp_mc_info, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n\r\n            /* Last bit of this byte is spare */\r\n            offset++;\r\n        }\r\n        else {\r\n            /* Normal case */\r\n\r\n            /* PDSCH Set Id */\r\n            proto_tree_add_item(tree, hf_fp_pdsch_set_id, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n            offset++;\r\n\r\n            /* Transmit power level */\r\n            proto_tree_add_float(tree, hf_fp_transmit_power_level, tvb, offset, 1,\r\n                                 (float)(int)(tvb_get_uint8(tvb, offset)) / 10);\r\n            offset++;\r\n        }\r\n        header_length = offset;\r\n        /* TB data */\r\n        offset = dissect_tb_data(tvb, pinfo, tree, offset, p_fp_info, NULL, NULL);\r\n\r\n        /* Spare Extension and Payload CRC */\r\n        dissect_spare_extension_and_crc(tvb, pinfo, tree, 1, offset, header_length);\r\n    }\r\n}", ".issect_usch_channel_info": "static void\r\ndissect_usch_channel_info(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\r\n                          int offset, struct fp_info *p_fp_info)\r\n{\r\n    uint32_t ft;\r\n\r\n    /* Header CRC */\r\n    proto_tree_add_item(tree, hf_fp_header_crc, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n\r\n    /* Frame Type */\r\n    proto_tree_add_item_ret_uint(tree, hf_fp_ft, tvb, offset, 1, ENC_BIG_ENDIAN, &ft);\r\n    offset++;\r\n\r\n    col_append_fstr(pinfo->cinfo, COL_INFO, \" [%s] \", val_to_str_const(ft, frame_type_vals, \"Unknown\"));\r\n\r\n    if (ft == FT_CONTROL) {\r\n        dissect_common_control(tvb, pinfo, tree, offset, p_fp_info);\r\n    }\r\n    else {\r\n        unsigned cfn;\r\n        uint16_t rx_timing_deviation;\r\n        proto_item *rx_timing_deviation_ti;\r\n        unsigned header_length = 0;\r\n\r\n        /* DATA */\r\n\r\n        /* CFN */\r\n        proto_tree_add_item_ret_uint(tree, hf_fp_cfn, tvb, offset, 1, ENC_BIG_ENDIAN, &cfn);\r\n        offset++;\r\n\r\n        col_append_fstr(pinfo->cinfo, COL_INFO, \"CFN=%03u \", cfn);\r\n\r\n        /* TFI */\r\n        proto_tree_add_item(tree, hf_fp_usch_tfi, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n        offset++;\r\n\r\n        /* Rx Timing Deviation */\r\n        rx_timing_deviation = tvb_get_uint8(tvb, offset);\r\n        rx_timing_deviation_ti = proto_tree_add_item(tree, hf_fp_rx_timing_deviation,\r\n                                                     tvb, offset, 1, ENC_BIG_ENDIAN);\r\n        offset++;\r\n        header_length = offset;\r\n        /* TB data */\r\n        offset = dissect_tb_data(tvb, pinfo, tree, offset, p_fp_info, NULL, NULL);\r\n\r\n        /* QE */\r\n        proto_tree_add_item(tree, hf_fp_quality_estimate, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n        offset++;\r\n\r\n        /* CRCIs */\r\n        offset = dissect_crci_bits(tvb, pinfo, tree, p_fp_info, offset);\r\n\r\n        /* New IEs */\r\n        if ((p_fp_info->release == 7) &&\r\n            (tvb_reported_length_remaining(tvb, offset) > 2)) {\r\n\r\n            uint8_t flags = tvb_get_uint8(tvb, offset);\r\n            uint8_t bits_extended = flags & 0x01;\r\n            offset++;\r\n\r\n            if (bits_extended) {\r\n                uint8_t extra_bits = tvb_get_uint8(tvb, offset) & 0x03;\r\n                proto_item_append_text(rx_timing_deviation_ti,\r\n                                       \" (extended to %u)\",\r\n                                       (rx_timing_deviation << 2) | extra_bits);\r\n            }\r\n            offset++;\r\n        }\r\n\r\n        /* Spare Extension and Payload CRC */\r\n        dissect_spare_extension_and_crc(tvb, pinfo, tree, 1, offset, header_length);\r\n    }\r\n}", ".issect_cpch_channel_info": "static void\r\ndissect_cpch_channel_info(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\r\n                          int offset, struct fp_info *p_fp_info)\r\n{\r\n    uint32_t ft;\r\n\r\n    /* Header CRC */\r\n    proto_tree_add_item(tree, hf_fp_header_crc, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n\r\n    /* Frame Type */\r\n    proto_tree_add_item_ret_uint(tree, hf_fp_ft, tvb, offset, 1, ENC_BIG_ENDIAN, &ft);\r\n    offset++;\r\n\r\n    col_append_fstr(pinfo->cinfo, COL_INFO, \" [%s] \", val_to_str_const(ft, frame_type_vals, \"Unknown\"));\r\n\r\n    if (ft == FT_CONTROL) {\r\n        dissect_common_control(tvb, pinfo, tree, offset, p_fp_info);\r\n    }\r\n    else {\r\n        unsigned cfn;\r\n        uint32_t encoded;\r\n        unsigned header_length = 0;\r\n        uint32_t propagation_delay = 0;\r\n\r\n        /* DATA */\r\n\r\n        /* CFN */\r\n        proto_tree_add_item_ret_uint(tree, hf_fp_cfn, tvb, offset, 1, ENC_BIG_ENDIAN, &cfn);\r\n        offset++;\r\n\r\n        col_append_fstr(pinfo->cinfo, COL_INFO, \"CFN=%03u \", cfn);\r\n\r\n        /* TFI */\r\n        proto_tree_add_item(tree, hf_fp_cpch_tfi, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n        offset++;\r\n\r\n        /* Propagation delay */\r\n        encoded = tvb_get_uint8(tvb, offset);\r\n        propagation_delay = encoded * 3;\r\n        proto_tree_add_uint_format_value(tree, hf_fp_propagation_delay, tvb, offset, 1,\r\n                                               propagation_delay, \"Propagation Delay: %u chips (%u)\",\r\n                                               propagation_delay, encoded);\r\n        offset++;\r\n        header_length = offset; /* XXX this might be wrong */\r\n        /* TB data */\r\n        offset = dissect_tb_data(tvb, pinfo, tree, offset, p_fp_info, NULL, NULL);\r\n\r\n        /* CRCIs */\r\n        offset = dissect_crci_bits(tvb, pinfo, tree, p_fp_info, offset);\r\n\r\n        /* Spare Extension and Payload CRC */\r\n        dissect_spare_extension_and_crc(tvb, pinfo, tree, 1, offset, header_length);\r\n    }\r\n}", ".issect_common_control": "static void\r\ndissect_common_control(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\r\n                       int offset, struct fp_info *p_fp_info)\r\n{\r\n    /* Common control frame type */\r\n    uint8_t control_frame_type = tvb_get_uint8(tvb, offset);\r\n    proto_tree_add_item(tree, hf_fp_common_control_frame_type, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n    offset++;\r\n\r\n    col_append_str(pinfo->cinfo, COL_INFO,\r\n                   val_to_str_const(control_frame_type, common_control_frame_type_vals, \"Unknown\"));\r\n\r\n    /* Frame-type specific dissection */\r\n    switch (control_frame_type) {\r\n        case COMMON_OUTER_LOOP_POWER_CONTROL:\r\n            /*offset =*/ dissect_common_outer_loop_power_control(pinfo, tree, tvb, offset, p_fp_info);\r\n            break;\r\n        case COMMON_TIMING_ADJUSTMENT:\r\n            /*offset =*/ dissect_common_timing_adjustment(pinfo, tree, tvb, offset, p_fp_info);\r\n            break;\r\n        case COMMON_DL_SYNCHRONISATION:\r\n            /*offset =*/ dissect_common_dl_synchronisation(pinfo, tree, tvb, offset, p_fp_info);\r\n            break;\r\n        case COMMON_UL_SYNCHRONISATION:\r\n            /*offset =*/ dissect_common_ul_synchronisation(pinfo, tree, tvb, offset, p_fp_info);\r\n            break;\r\n        case COMMON_DL_NODE_SYNCHRONISATION:\r\n            /*offset =*/ dissect_common_dl_node_synchronisation(pinfo, tree, tvb, offset);\r\n            break;\r\n        case COMMON_UL_NODE_SYNCHRONISATION:\r\n            /*offset =*/ dissect_common_ul_node_synchronisation(pinfo, tree, tvb, offset);\r\n            break;\r\n        case COMMON_DYNAMIC_PUSCH_ASSIGNMENT:\r\n            /*offset =*/ dissect_common_dynamic_pusch_assignment(pinfo, tree, tvb, offset);\r\n            break;\r\n        case COMMON_TIMING_ADVANCE:\r\n            /*offset =*/ dissect_common_timing_advance(pinfo, tree, tvb, offset);\r\n            break;\r\n        case COMMON_HS_DSCH_Capacity_Request:\r\n            /*offset =*/ dissect_hsdpa_capacity_request(pinfo, tree, tvb, offset);\r\n            break;\r\n        case COMMON_HS_DSCH_Capacity_Allocation:\r\n            /*offset =*/ dissect_hsdpa_capacity_allocation(pinfo, tree, tvb, offset, p_fp_info);\r\n            break;\r\n        case COMMON_HS_DSCH_Capacity_Allocation_Type_2:\r\n            /*offset =*/ dissect_hsdpa_capacity_allocation_type_2(pinfo, tree, tvb, offset);\r\n            break;\r\n\r\n        default:\r\n            break;\r\n    }\r\n\r\n     /* There is no Spare Extension nor payload crc in common control!? */\r\n   /* dissect_spare_extension_and_crc(tvb, pinfo, tree, 0, offset);\r\n    */\r\n}", ".issect_common_ul_synchronisation": "static int\r\ndissect_common_ul_synchronisation(packet_info *pinfo, proto_tree *tree,\r\n                                  tvbuff_t *tvb, int offset, struct fp_info *p_fp_info)\r\n{\r\n    return dissect_common_timing_adjustment(pinfo, tree, tvb, offset, p_fp_info);\r\n}", ".issect_dch_dl_node_synchronisation": "static int\r\ndissect_dch_dl_node_synchronisation(proto_tree *tree, packet_info *pinfo, tvbuff_t *tvb, int offset)\r\n{\r\n    return dissect_common_dl_node_synchronisation(pinfo, tree, tvb, offset);\r\n}", ".issect_dch_ul_node_synchronisation": "static int\r\ndissect_dch_ul_node_synchronisation(proto_tree *tree, packet_info *pinfo, tvbuff_t *tvb, int offset)\r\n{\r\n    return dissect_common_ul_node_synchronisation(pinfo, tree, tvb, offset);\r\n}", ".issect_bch_channel_info": "static void\r\ndissect_bch_channel_info(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\r\n                         int offset, struct fp_info *p_fp_info)\r\n{\r\n    uint32_t ft;\r\n\r\n    /* Header CRC */\r\n    proto_tree_add_item(tree, hf_fp_header_crc, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n\r\n    /* Frame Type */\r\n    proto_tree_add_item_ret_uint(tree, hf_fp_ft, tvb, offset, 1, ENC_BIG_ENDIAN, &ft);\r\n    offset++;\r\n\r\n    col_append_fstr(pinfo->cinfo, COL_INFO, \" [%s] \", val_to_str_const(ft, frame_type_vals, \"Unknown\"));\r\n\r\n    if (ft == FT_CONTROL) {\r\n        dissect_common_control(tvb, pinfo, tree, offset, p_fp_info);\r\n    }\r\n}", ".issect_iur_dsch_channel_info": "static void\r\ndissect_iur_dsch_channel_info(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\r\n                              int offset, struct fp_info *p_fp_info)\r\n{\r\n    uint32_t ft;\r\n\r\n    /* Header CRC */\r\n    proto_tree_add_item(tree, hf_fp_header_crc, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n\r\n    /* Frame Type */\r\n    proto_tree_add_item_ret_uint(tree, hf_fp_ft, tvb, offset, 1, ENC_BIG_ENDIAN, &ft);\r\n    offset++;\r\n\r\n    col_append_fstr(pinfo->cinfo, COL_INFO, \" [%s] \", val_to_str_const(ft, frame_type_vals, \"Unknown\"));\r\n\r\n    if (ft == FT_CONTROL) {\r\n        dissect_common_control(tvb, pinfo, tree, offset, p_fp_info);\r\n    }\r\n    else {\r\n        /* TODO: DATA */\r\n    }\r\n}", ".issect_fp_common": "static int\r\ndissect_fp_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)\r\n{\r\n    proto_tree       *fp_tree;\r\n    proto_item       *ti;\r\n    int               offset = 0;\r\n    struct fp_info   *p_fp_info;\r\n    conversation_t   *p_conv = NULL;\r\n    umts_fp_conversation_info_t *p_conv_data = NULL;\r\n\r\n    /* Append this protocol name rather than replace. */\r\n    col_set_str(pinfo->cinfo, COL_PROTOCOL, \"FP\");\r\n\r\n    /* Create fp tree. */\r\n    ti = proto_tree_add_item(tree, proto_fp, tvb, offset, -1, ENC_NA);\r\n    fp_tree = proto_item_add_subtree(ti, ett_fp);\r\n\r\n    top_level_tree = tree;\r\n\r\n    /* Look for packet info! */\r\n    p_fp_info = (struct fp_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_fp, 0);\r\n\r\n    /* Check if we have conversation info */\r\n    /* Trying to find exact match - with both RNC's address & port and Node B's address & port */\r\n    p_conv = (conversation_t *)find_conversation(pinfo->num, &pinfo->net_dst, &pinfo->net_src,\r\n                               conversation_pt_to_conversation_type(pinfo->ptype),\r\n                               pinfo->destport, pinfo->srcport, 0);\r\n    if (p_conv) {\r\n        p_conv_data = (umts_fp_conversation_info_t *)conversation_get_proto_data(p_conv, proto_fp);\r\n    }\r\n    if (!p_conv || !p_conv_data) {\r\n        /* Didn't find exact conversation match */\r\n        /* Try to find a partial match with just the source/destination included */\r\n        p_conv = (conversation_t *)find_conversation(pinfo->num, &pinfo->net_dst, &pinfo->net_src,\r\n                                   conversation_pt_to_conversation_type(pinfo->ptype),\r\n                                   pinfo->destport, pinfo->srcport, NO_ADDR_B);\r\n        if (p_conv) {\r\n            p_conv_data = (umts_fp_conversation_info_t *)conversation_get_proto_data(p_conv, proto_fp);\r\n        }\r\n    }\r\n\r\n    if (p_conv_data) {\r\n        /*Figure out the direction of the link*/\r\n        if (addresses_equal(&(pinfo->net_dst), (&p_conv_data->crnc_address))) {\r\n            /* Node B -> CRNC*/\r\n            pinfo->link_dir=P2P_DIR_UL;\r\n\r\n            proto_item *item= proto_tree_add_uint(fp_tree, hf_fp_ul_setup_frame,\r\n                                                  tvb, 0, 0, p_conv_data->ul_frame_number);\r\n            proto_item_set_generated(item);\r\n        }\r\n        else {\r\n            /* CRNC -> Node B */\r\n            pinfo->link_dir=P2P_DIR_DL;\r\n\r\n            /* Maybe the frame number should be stored in the proper location already in nbap?, in ul_frame_number*/\r\n            proto_item *item= proto_tree_add_uint(fp_tree, hf_fp_dl_setup_frame,\r\n                                                   tvb, 0, 0, p_conv_data->ul_frame_number);\r\n            proto_item_set_generated(item);\r\n        }\r\n        if (p_fp_info == NULL) {\r\n            p_fp_info = fp_set_per_packet_inf_from_conv(p_conv, p_conv_data, tvb, pinfo, fp_tree);\r\n        }\r\n    }\r\n\r\n    if (pinfo->p2p_dir == P2P_DIR_UNKNOWN) {\r\n        if (pinfo->link_dir == P2P_DIR_UL) {\r\n            pinfo->p2p_dir = P2P_DIR_RECV;\r\n        } else {\r\n            pinfo->p2p_dir = P2P_DIR_SENT;\r\n        }\r\n    }\r\n\r\n    /* Can't dissect anything without it... */\r\n    if (p_fp_info == NULL) {\r\n        proto_tree_add_expert(fp_tree, pinfo, &ei_fp_no_per_frame_info, tvb, offset, -1);\r\n        return 1;\r\n    }\r\n\r\n    /* Show release information */\r\n    if (preferences_show_release_info) {\r\n        proto_item *release_ti;\r\n        proto_tree *release_tree;\r\n        proto_item *temp_ti;\r\n\r\n        release_ti = proto_tree_add_item(fp_tree, hf_fp_release, tvb, 0, 0, ENC_NA);\r\n        proto_item_set_generated(release_ti);\r\n        proto_item_append_text(release_ti, \" R%u (%d/%d)\",\r\n                               p_fp_info->release, p_fp_info->release_year, p_fp_info->release_month);\r\n        release_tree = proto_item_add_subtree(release_ti, ett_fp_release);\r\n\r\n        temp_ti = proto_tree_add_uint(release_tree, hf_fp_release_version, tvb, 0, 0, p_fp_info->release);\r\n        proto_item_set_generated(temp_ti);\r\n\r\n        temp_ti = proto_tree_add_uint(release_tree, hf_fp_release_year, tvb, 0, 0, p_fp_info->release_year);\r\n        proto_item_set_generated(temp_ti);\r\n\r\n        temp_ti = proto_tree_add_uint(release_tree, hf_fp_release_month, tvb, 0, 0, p_fp_info->release_month);\r\n        proto_item_set_generated(temp_ti);\r\n    }\r\n\r\n    /* Show channel type in info column, tree */\r\n    col_set_str(pinfo->cinfo, COL_INFO,\r\n                val_to_str_const(p_fp_info->channel,\r\n                                 channel_type_vals,\r\n                                 \"Unknown channel type\"));\r\n    if (p_conv_data) {\r\n        int i;\r\n        col_append_fstr(pinfo->cinfo, COL_INFO, \"(%u\", p_conv_data->dch_ids_in_flow_list[0]);\r\n        for (i=1; i < p_conv_data->num_dch_in_flow; i++) {\r\n            col_append_fstr(pinfo->cinfo, COL_INFO, \",%u\", p_conv_data->dch_ids_in_flow_list[i]);\r\n        }\r\n        col_append_str(pinfo->cinfo, COL_INFO, \") \");\r\n    }\r\n    proto_item_append_text(ti, \" (%s)\",\r\n                           val_to_str_const(p_fp_info->channel,\r\n                                            channel_type_vals,\r\n                                            \"Unknown channel type\"));\r\n\r\n    /* Add channel type as a generated field */\r\n    ti = proto_tree_add_uint(fp_tree, hf_fp_channel_type, tvb, 0, 0, p_fp_info->channel);\r\n    proto_item_set_generated(ti);\r\n\r\n    /* Add division type as a generated field */\r\n    if (p_fp_info->release == 7) {\r\n        ti = proto_tree_add_uint(fp_tree, hf_fp_division, tvb, 0, 0, p_fp_info->division);\r\n        proto_item_set_generated(ti);\r\n    }\r\n\r\n    /* Add link direction as a generated field */\r\n    ti = proto_tree_add_boolean(fp_tree, hf_fp_direction, tvb, 0, 0, p_fp_info->is_uplink);\r\n    proto_item_set_generated(ti);\r\n\r\n    /* Don't currently handle IuR-specific formats, but it's useful to even see\r\n       the channel type and direction */\r\n    if (p_fp_info->iface_type == IuR_Interface) {\r\n        return 1;\r\n    }\r\n\r\n    /* Show DDI config info */\r\n    if (p_fp_info->no_ddi_entries > 0) {\r\n        int n;\r\n        proto_item *ddi_config_ti;\r\n        proto_tree *ddi_config_tree;\r\n\r\n        ddi_config_ti = proto_tree_add_string_format(fp_tree, hf_fp_ddi_config, tvb, offset, 0,\r\n                                                     \"\", \"DDI Config (\");\r\n        proto_item_set_generated(ddi_config_ti);\r\n        ddi_config_tree = proto_item_add_subtree(ddi_config_ti, ett_fp_ddi_config);\r\n\r\n        /* Add each entry */\r\n        for (n=0; n < p_fp_info->no_ddi_entries; n++) {\r\n            proto_item_append_text(ddi_config_ti, \"%s%u->%ubits\",\r\n                                   (n == 0) ? \"\" : \"  \",\r\n                                   p_fp_info->edch_ddi[n], p_fp_info->edch_macd_pdu_size[n]);\r\n            ti = proto_tree_add_uint(ddi_config_tree, hf_fp_ddi_config_ddi, tvb, 0, 0,\r\n                                p_fp_info->edch_ddi[n]);\r\n            proto_item_set_generated(ti);\r\n            ti = proto_tree_add_uint(ddi_config_tree, hf_fp_ddi_config_macd_pdu_size, tvb, 0, 0,\r\n                                p_fp_info->edch_macd_pdu_size[n]);\r\n            proto_item_set_generated(ti);\r\n\r\n        }\r\n        proto_item_append_text(ddi_config_ti, \")\");\r\n    }\r\n\r\n    /*************************************/\r\n    /* Dissect according to channel type */\r\n    switch (p_fp_info->channel) {\r\n        case CHANNEL_RACH_TDD:\r\n        case CHANNEL_RACH_TDD_128:\r\n        case CHANNEL_RACH_FDD:\r\n            dissect_rach_channel_info(tvb, pinfo, fp_tree, offset, p_fp_info,\r\n                                      data);\r\n            break;\r\n        case CHANNEL_DCH:\r\n            dissect_dch_channel_info(tvb, pinfo, fp_tree, offset, p_fp_info,\r\n                                     data);\r\n            break;\r\n        case CHANNEL_FACH_FDD:\r\n        case CHANNEL_FACH_TDD:\r\n            dissect_fach_channel_info(tvb, pinfo, fp_tree, offset, p_fp_info,\r\n                                      data);\r\n            break;\r\n        case CHANNEL_DSCH_FDD:\r\n        case CHANNEL_DSCH_TDD:\r\n            dissect_dsch_channel_info(tvb, pinfo, fp_tree, offset, p_fp_info);\r\n            break;\r\n        case CHANNEL_USCH_TDD_128:\r\n        case CHANNEL_USCH_TDD_384:\r\n            dissect_usch_channel_info(tvb, pinfo, fp_tree, offset, p_fp_info);\r\n            break;\r\n        case CHANNEL_PCH:\r\n            dissect_pch_channel_info(tvb, pinfo, fp_tree, offset, p_fp_info,\r\n                                     data);\r\n            update_pch_coversation_info(p_conv_data, pinfo, p_fp_info);\r\n            break;\r\n        case CHANNEL_CPCH:\r\n            dissect_cpch_channel_info(tvb, pinfo, fp_tree, offset, p_fp_info);\r\n            break;\r\n        case CHANNEL_BCH:\r\n            dissect_bch_channel_info(tvb, pinfo, fp_tree, offset, p_fp_info);\r\n            break;\r\n        case CHANNEL_HSDSCH:\r\n            /* Show configured MAC HS-DSCH entity in use */\r\n            if (fp_tree)\r\n            {\r\n                proto_item *entity_ti;\r\n                entity_ti = proto_tree_add_uint(fp_tree, hf_fp_hsdsch_entity,\r\n                                                tvb, 0, 0,\r\n                                                p_fp_info->hsdsch_entity);\r\n                proto_item_set_generated(entity_ti);\r\n            }\r\n            switch (p_fp_info->hsdsch_entity) {\r\n                case entity_not_specified:\r\n                case hs:\r\n                    /* This is the pre-R7 default */\r\n                    dissect_hsdsch_channel_info(tvb, pinfo, fp_tree, offset, p_fp_info, data);\r\n                    break;\r\n                case ehs:\r\n                    dissect_hsdsch_type_2_channel_info(tvb, pinfo, fp_tree, offset, p_fp_info, data);\r\n                    break;\r\n                default:\r\n                    /* Report Error */\r\n                    expert_add_info(pinfo, NULL, &ei_fp_hsdsch_entity_not_specified);\r\n                    break;\r\n            }\r\n            break;\r\n        case CHANNEL_HSDSCH_COMMON:\r\n            expert_add_info(pinfo, NULL, &ei_fp_hsdsch_common_experimental_support);\r\n            /*if (false)*/\r\n            dissect_hsdsch_common_channel_info(tvb, pinfo, fp_tree, offset, p_fp_info, data);\r\n\r\n            break;\r\n        case CHANNEL_HSDSCH_COMMON_T3:\r\n            expert_add_info(pinfo, NULL, &ei_fp_hsdsch_common_t3_not_implemented);\r\n\r\n            /* TODO: */\r\n            break;\r\n        case CHANNEL_IUR_CPCHF:\r\n            /* TODO: */\r\n            break;\r\n        case CHANNEL_IUR_FACH:\r\n            /* TODO: */\r\n            break;\r\n        case CHANNEL_IUR_DSCH:\r\n            dissect_iur_dsch_channel_info(tvb, pinfo, fp_tree, offset, p_fp_info);\r\n            break;\r\n        case CHANNEL_EDCH:\r\n        case CHANNEL_EDCH_COMMON:\r\n            /* Show configured MAC E-DCH entity in use */\r\n            if (fp_tree)\r\n            {\r\n                proto_item *entity_ti;\r\n                entity_ti = proto_tree_add_uint(fp_tree, hf_fp_edch_entity,\r\n                                                tvb, 0, 0,\r\n                                                p_fp_info->edch_type);\r\n                proto_item_set_generated(entity_ti);\r\n            }\r\n            dissect_e_dch_channel_info(tvb, pinfo, fp_tree, offset, p_fp_info,\r\n                                       p_fp_info->channel == CHANNEL_EDCH_COMMON,\r\n                                       data);\r\n            break;\r\n\r\n        default:\r\n            expert_add_info(pinfo, NULL, &ei_fp_channel_type_unknown);\r\n            break;\r\n    }\r\n    return tvb_captured_length(tvb);\r\n}", ".issect_dch_control_frame": "static void\r\ndissect_dch_control_frame(proto_tree *tree, packet_info *pinfo, tvbuff_t *tvb,\r\n                          int offset, struct fp_info *p_fp_info)\r\n{\r\n    /* Control frame type */\r\n    uint8_t control_frame_type = tvb_get_uint8(tvb, offset);\r\n    proto_tree_add_item(tree, hf_fp_dch_control_frame_type, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n    offset++;\r\n\r\n    col_append_str(pinfo->cinfo, COL_INFO,\r\n                   val_to_str_const(control_frame_type,\r\n                                    dch_control_frame_type_vals, \"Unknown\"));\r\n\r\n    switch (control_frame_type) {\r\n        case DCH_TIMING_ADJUSTMENT:\r\n            /*offset =*/ dissect_dch_timing_adjustment(tree, pinfo, tvb, offset);\r\n            break;\r\n        case DCH_RX_TIMING_DEVIATION:\r\n            /*offset =*/ dissect_dch_rx_timing_deviation(pinfo, tree, tvb, offset, p_fp_info);\r\n            break;\r\n        case DCH_DL_SYNCHRONISATION:\r\n            /*offset =*/ dissect_dch_dl_synchronisation(tree, pinfo, tvb, offset);\r\n            break;\r\n        case DCH_UL_SYNCHRONISATION:\r\n            /*offset =*/ dissect_dch_ul_synchronisation(tree, pinfo, tvb, offset);\r\n            break;\r\n        case DCH_OUTER_LOOP_POWER_CONTROL:\r\n            /*offset =*/ dissect_dch_outer_loop_power_control(tree, pinfo, tvb, offset);\r\n            break;\r\n        case DCH_DL_NODE_SYNCHRONISATION:\r\n            /*offset =*/ dissect_dch_dl_node_synchronisation(tree, pinfo, tvb, offset);\r\n            break;\r\n        case DCH_UL_NODE_SYNCHRONISATION:\r\n            /*offset =*/ dissect_dch_ul_node_synchronisation(tree, pinfo, tvb, offset);\r\n            break;\r\n        case DCH_RADIO_INTERFACE_PARAMETER_UPDATE:\r\n            /*offset =*/ dissect_dch_radio_interface_parameter_update(tree, pinfo, tvb, offset);\r\n            break;\r\n        case DCH_TIMING_ADVANCE:\r\n            /*offset =*/ dissect_dch_timing_advance(tree, pinfo, tvb, offset, p_fp_info);\r\n            break;\r\n        case DCH_TNL_CONGESTION_INDICATION:\r\n            /*offset =*/ dissect_dch_tnl_congestion_indication(tree, pinfo, tvb, offset);\r\n            break;\r\n    }\r\n\r\n    /* Spare Extension */\r\n   /* dissect_spare_extension_and_crc(tvb, pinfo, tree, 0, offset);\r\n    */\r\n}", ".issect_common_outer_loop_power_control": "static int\r\ndissect_common_outer_loop_power_control(packet_info *pinfo, proto_tree *tree, tvbuff_t *tvb,\r\n                                        int offset, struct fp_info *p_fp_info _U_)\r\n{\r\n    return dissect_dch_outer_loop_power_control(tree, pinfo, tvb, offset);\r\n}", ".eur_dissect_fp_unknown_format": "static bool\r\nheur_dissect_fp_unknown_format(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)\r\n{\r\n    conversation_t   *p_conv;\r\n    umts_fp_conversation_info_t* umts_fp_conversation_info = NULL;\r\n    struct fp_info *p_fp_info;\r\n    uint32_t length;\r\n    uint8_t frame_type;\r\n    uint32_t ft;\r\n\r\n    /* Trying to find existing conversation */\r\n    p_conv = (conversation_t *)find_conversation(pinfo->num, &pinfo->net_dst, &pinfo->net_src,\r\n        conversation_pt_to_conversation_type(pinfo->ptype),\r\n        pinfo->destport, pinfo->srcport, NO_ADDR_B);\r\n\r\n    /* Check if FP Conversation Info is attached */\r\n    if (p_conv != NULL) {\r\n        umts_fp_conversation_info = (umts_fp_conversation_info_t *)conversation_get_proto_data(p_conv, proto_fp);\r\n        if (umts_fp_conversation_info) {\r\n            if (umts_fp_conversation_info->channel == CHANNEL_UNKNOWN) {\r\n                /* This stream was framed using a previous control frame, we can call FP dissector without further tests*/\r\n                dissect_fp(tvb, pinfo, tree, data);\r\n                return true;\r\n            }\r\n            else {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    p_fp_info = (fp_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_fp, 0);\r\n\r\n    /* Check if per-frame FP Info is attached*/\r\n    if(p_fp_info) {\r\n        /* if FP info is present, check that it really is an ethernet link */\r\n        if (p_fp_info->link_type != FP_Link_Ethernet) {\r\n            return false;\r\n        }\r\n\r\n        /* discriminate 'lower' UDP layer from 'user data' UDP layer\r\n         * (i.e. if an FP over UDP packet contains a user UDP packet */\r\n        if (p_fp_info->srcport != pinfo->srcport ||\r\n            p_fp_info->destport != pinfo->destport)\r\n            return false;\r\n\r\n        /* assume this is FP */\r\n        dissect_fp(tvb, pinfo, tree, data);\r\n        return true;\r\n    }\r\n\r\n    /* Both per-frame FP info and conversation FP info are missing */\r\n    /* Try to frame control frames using header CRC */\r\n    ft = (tvb_get_uint8(tvb, 0) & 0x01);\r\n    if(ft != FT_CONTROL) {\r\n        /* This is a Data frame, can't tell if it's FP. */\r\n        return false;\r\n    }\r\n\r\n    length = tvb_captured_length(tvb);\r\n    /* Length limit: control frames header is 2 bytes */\r\n    if (length < 2) {\r\n        return false;\r\n    }\r\n\r\n    /* Check 'Frame Type' */\r\n    frame_type = tvb_get_uint8(tvb, 1);\r\n    /* 0x00 is unused for both dedicated & common FP */\r\n    if( frame_type == 0x00 ) {\r\n        return false;\r\n    }\r\n    /* Max frame types are: */\r\n    /* For common channels: 0x0E */\r\n    /* For dedicated channels: 0x0B */\r\n    /* The left nibble is zeroed in both cases */\r\n    if( (frame_type & 0xF0) != 0x00) {\r\n        return false;\r\n    }\r\n\r\n    /* Checking Header CRC*/\r\n    if (!check_control_frame_crc_for_heur(pinfo->pool, tvb)) {\r\n        /* The CRC is incorrect */\r\n        return false;\r\n    }\r\n\r\n    /* The CRC is correct! */\r\n    /* Attaching 'FP Conversation Info' to the UDP conversation so other */\r\n    /* packets (both Control AND Data) will be marked as FP */\r\n    umts_fp_conversation_info = wmem_new0(wmem_file_scope(), umts_fp_conversation_info_t);\r\n    umts_fp_conversation_info->channel = CHANNEL_UNKNOWN;\r\n    set_both_sides_umts_fp_conv_data(pinfo, umts_fp_conversation_info);\r\n    /* Call FP Dissector for the current frame */\r\n    dissect_fp(tvb, pinfo, tree, data);\r\n    return true;\r\n}", ".eur_dissect_fp_dcch_over_dch": "static bool\r\nheur_dissect_fp_dcch_over_dch(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)\r\n{\r\n    conversation_t   *p_conv;\r\n    umts_fp_conversation_info_t* umts_fp_conversation_info = NULL;\r\n    struct fp_info *p_fp_info;\r\n    uint32_t captured_length;\r\n    uint32_t reported_length;\r\n    uint8_t frame_type;\r\n    uint8_t tfi;\r\n    uint8_t pch_collisions_byte;\r\n\r\n    /* Trying to find existing conversation */\r\n    p_conv = (conversation_t *)find_conversation(pinfo->num, &pinfo->net_dst, &pinfo->net_src,\r\n        conversation_pt_to_conversation_type(pinfo->ptype),\r\n        pinfo->destport, pinfo->srcport, NO_ADDR_B);\r\n\r\n    if (p_conv != NULL) {\r\n        /* Checking if the conversation was already framed */\r\n        umts_fp_conversation_info = (umts_fp_conversation_info_t *)conversation_get_proto_data(p_conv, proto_fp);\r\n        if (umts_fp_conversation_info) {\r\n            if (umts_fp_conversation_info->channel == CHANNEL_DCH) {\r\n                conversation_set_dissector(p_conv, fp_handle);\r\n                dissect_fp(tvb, pinfo, tree, data);\r\n                return true;\r\n            }\r\n            else if (umts_fp_conversation_info->channel != CHANNEL_UNKNOWN){\r\n                /* This conversation was successfully framed as ANOTHER type */\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /* Making sure FP info isn't already attached */\r\n    p_fp_info = (fp_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_fp, 0);\r\n    if (p_fp_info) {\r\n        return false;\r\n    }\r\n\r\n    frame_type = tvb_get_uint8(tvb, 0) & 0x01;\r\n    if (frame_type == 1) { /* is 'control' frame type*/\r\n        return false;\r\n    }\r\n\r\n    /* Making sure we have at least enough bytes for header (3) + footer (2) */\r\n    captured_length = tvb_captured_length(tvb);\r\n    if (captured_length < 5) {\r\n        return false;\r\n    }\r\n    reported_length = tvb_reported_length(tvb);\r\n\r\n    tfi = tvb_get_uint8(tvb, 2) & 0x1f;\r\n\r\n    /* Checking if this is a DCH frame with 0 TBs*/\r\n    if (tfi == 0x00)\r\n    {\r\n        if (reported_length != 5 /* DL */ && reported_length != 7 /* UL */) {\r\n            return false;\r\n        }\r\n        if (!check_header_crc_for_heur(tvb, 3)) {\r\n            return false;\r\n        }\r\n        if (!check_payload_crc_for_heur(tvb, 3)) {\r\n            return false;\r\n        }\r\n        /* All checks passed - This is an unknown DCH FP frame. */\r\n        /* To allow dissection of this frame after umts_fp_conversation_info will be added in a later frame */\r\n        /* the conversation must be created here if it doesn't exist yet*/\r\n        if (p_conv == NULL) {\r\n            conversation_new(pinfo->num, &pinfo->net_dst, &pinfo->net_src,\r\n                conversation_pt_to_conversation_type(pinfo->ptype),\r\n                pinfo->destport, pinfo->srcport, NO_ADDR2);\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /* Checking this is a DCH frame with 1 TB */\r\n    if (tfi != 0x01) {\r\n        return false;\r\n    }\r\n\r\n    /* Expecting specific lengths: 24 for downlink frames, 26 for uplink frames */\r\n    /* This is the common Transport Format of DCCH over DCH ( See 3GPP TR 25.944 / 4.1.1.3.1.1 ) */\r\n    if (reported_length != 24 /* DL */ && reported_length != 26 /* UL */) {\r\n        return false;\r\n    }\r\n\r\n    if (!check_header_crc_for_heur(tvb, 3)) {\r\n        return false;\r\n    }\r\n    if (!check_payload_crc_for_heur(tvb, 3)) {\r\n        return false;\r\n    }\r\n\r\n    /* Checking if the 4th byte in the frame is zeroed. In this case the CRC checks aren't */\r\n    /* deterministic enough to guarantee this is a DCH since this packet could also be a PCH frame */\r\n    /* with PI Bitmap of 18 bytes + 0 TBs (Both CRCs will match for both formats) */\r\n    pch_collisions_byte = tvb_get_uint8(tvb, 3);\r\n    if (pch_collisions_byte == 0) {\r\n        return false;\r\n    }\r\n\r\n    if(!umts_fp_conversation_info) {\r\n        umts_fp_conversation_info = wmem_new0(wmem_file_scope(), umts_fp_conversation_info_t);\r\n        set_both_sides_umts_fp_conv_data(pinfo, umts_fp_conversation_info);\r\n    }\r\n    umts_fp_conversation_info->iface_type = IuB_Interface;\r\n    umts_fp_conversation_info->division = Division_FDD;\r\n    umts_fp_conversation_info->dl_frame_number = pinfo->num;\r\n    umts_fp_conversation_info->ul_frame_number = pinfo->num;\r\n    umts_fp_conversation_info->dch_crc_present = 1;\r\n    umts_fp_conversation_info->com_context_id = generate_ue_id_for_heur(pinfo);\r\n    umts_fp_conversation_info->rlc_mode = FP_RLC_AM;\r\n    if (reported_length == 24) { /* Downlink */\r\n        copy_address_wmem(wmem_file_scope(), &(umts_fp_conversation_info->crnc_address), &pinfo->src);\r\n        umts_fp_conversation_info->crnc_port = pinfo->srcport;\r\n    }\r\n    else { /* Uplink*/\r\n        copy_address_wmem(wmem_file_scope(), &(umts_fp_conversation_info->crnc_address), &pinfo->dst);\r\n        umts_fp_conversation_info->crnc_port = pinfo->destport;\r\n    }\r\n    umts_fp_conversation_info->channel = CHANNEL_DCH;\r\n    umts_fp_conversation_info->num_dch_in_flow = 1;\r\n    umts_fp_conversation_info->dch_ids_in_flow_list[0] = 31;\r\n    umts_fp_conversation_info->fp_dch_channel_info[0].num_dl_chans = 1;\r\n    umts_fp_conversation_info->fp_dch_channel_info[0].dl_chan_num_tbs[1] = 1;\r\n    umts_fp_conversation_info->fp_dch_channel_info[0].dl_chan_tf_size[1] = 148;\r\n    umts_fp_conversation_info->fp_dch_channel_info[0].num_ul_chans = 1;\r\n    umts_fp_conversation_info->fp_dch_channel_info[0].ul_chan_num_tbs[1] = 1;\r\n    umts_fp_conversation_info->fp_dch_channel_info[0].ul_chan_tf_size[1] = 148;\r\n    conversation_set_dissector(find_or_create_conversation(pinfo), fp_handle);\r\n    dissect_fp(tvb, pinfo, tree, data);\r\n    return true;\r\n}", ".eur_dissect_fp_fach1": "static bool\r\nheur_dissect_fp_fach1(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)\r\n{\r\n    conversation_t   *p_conv;\r\n    fp_fach_channel_info_t* fp_fach_channel_info;\r\n    umts_fp_conversation_info_t* umts_fp_conversation_info = NULL;\r\n    struct fp_info *p_fp_info;\r\n    uint32_t captured_length;\r\n    uint32_t reported_length;\r\n    uint8_t frame_type;\r\n    uint8_t tfi;\r\n    uint8_t tctf;\r\n\r\n    /* Finding or creating conversation */\r\n    p_conv = (conversation_t *)find_conversation(pinfo->num, &pinfo->net_dst, &pinfo->net_src,\r\n        conversation_pt_to_conversation_type(pinfo->ptype),\r\n        pinfo->destport, pinfo->srcport, NO_ADDR_B);\r\n\r\n    if (p_conv != NULL) {\r\n        /* Checking if the conversation was already framed */\r\n        umts_fp_conversation_info = (umts_fp_conversation_info_t *)conversation_get_proto_data(p_conv, proto_fp);\r\n        if (umts_fp_conversation_info) {\r\n            if (umts_fp_conversation_info->channel == CHANNEL_FACH_FDD) {\r\n                conversation_set_dissector(p_conv, fp_handle);\r\n                dissect_fp(tvb, pinfo, tree, data);\r\n                return true;\r\n            }\r\n            else if (umts_fp_conversation_info->channel != CHANNEL_UNKNOWN){\r\n                /* This conversation was successfully framed as ANOTHER type */\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    /* Making sure we have at least enough bytes for header (4) + footer (2) */\r\n    captured_length = tvb_captured_length(tvb);\r\n    if(captured_length < 6) {\r\n        return false;\r\n    }\r\n\r\n    /* Expecting specific lengths: 51 for frames with 1 TB */\r\n    /* This is a common Transport Format of FACH ( See 3GPP TR 25.944 / 4.1.1.2 'FACH1' ) */\r\n    reported_length = tvb_reported_length(tvb);\r\n    if (reported_length != 51) {\r\n        return false;\r\n    }\r\n\r\n    p_fp_info = (fp_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_fp, 0);\r\n\r\n    /* Making sure FP info isn't already attached */\r\n    if (p_fp_info) {\r\n        return false;\r\n    }\r\n\r\n    frame_type = tvb_get_uint8(tvb, 0) & 0x01;\r\n    if (frame_type == 1) { /* is 'control' frame type*/\r\n                           /* We can't tell the FP type and content of control frames */\r\n        return false;\r\n    }\r\n\r\n    tfi = tvb_get_uint8(tvb, 2) & 0x1f;\r\n    if (tfi != 0x01) {\r\n        return false;\r\n    }\r\n\r\n    tctf = tvb_get_uint8(tvb, 4);\r\n    /* Asserting the TCTF field contains a valid (non reserved) value according to TS 25.321 Table 9.2.1-2 */\r\n    if (tctf != 0x40 && /* CCCH */\r\n        tctf != 0x50 && /* MCCH */\r\n        tctf != 0x5F && /* MSCH */\r\n        tctf != 0x80 && /* CTCH */\r\n        (tctf >> 4) != 0x06 && /* MTCH */\r\n        (tctf >> 6) != 0x00 && /* BCCH */\r\n        (tctf >> 6) != 0x03) { /* DCCH or DTCH over FACH */\r\n        return false;\r\n    }\r\n\r\n    if (!check_header_crc_for_heur(tvb, 4)) {\r\n        return false;\r\n    }\r\n    if (!check_payload_crc_for_heur(tvb, 4)) {\r\n        return false;\r\n    }\r\n\r\n    if(!umts_fp_conversation_info) {\r\n        umts_fp_conversation_info = wmem_new0(wmem_file_scope(), umts_fp_conversation_info_t);\r\n        set_both_sides_umts_fp_conv_data(pinfo, umts_fp_conversation_info);\r\n    }\r\n    umts_fp_conversation_info->iface_type = IuB_Interface;\r\n    umts_fp_conversation_info->division = Division_FDD;\r\n    umts_fp_conversation_info->dl_frame_number = pinfo->num;\r\n    umts_fp_conversation_info->ul_frame_number = pinfo->num;\r\n    umts_fp_conversation_info->dch_crc_present = 1;\r\n    umts_fp_conversation_info->com_context_id = generate_ue_id_for_heur(pinfo);\r\n    umts_fp_conversation_info->rlc_mode = FP_RLC_AM;\r\n    copy_address_wmem(wmem_file_scope(), &(umts_fp_conversation_info->crnc_address), &pinfo->src);\r\n    umts_fp_conversation_info->crnc_port = pinfo->srcport;\r\n    umts_fp_conversation_info->channel = CHANNEL_FACH_FDD;\r\n    umts_fp_conversation_info->num_dch_in_flow = 1;\r\n    umts_fp_conversation_info->fp_dch_channel_info[0].num_dl_chans = 1;\r\n    umts_fp_conversation_info->fp_dch_channel_info[0].dl_chan_num_tbs[1] = 1;\r\n    umts_fp_conversation_info->fp_dch_channel_info[0].dl_chan_tf_size[1] = 360;\r\n    /* Adding the 'channel specific info' for FACH */\r\n    fp_fach_channel_info = wmem_new0(wmem_file_scope(), fp_fach_channel_info_t);\r\n    fp_fach_channel_info->crnti_to_urnti_map = wmem_tree_new_autoreset(wmem_epan_scope(), wmem_file_scope());\r\n    umts_fp_conversation_info->channel_specific_info = (void*)fp_fach_channel_info;\r\n\r\n    conversation_set_dissector(find_or_create_conversation(pinfo), fp_handle);\r\n    dissect_fp(tvb, pinfo, tree, data);\r\n    return true;\r\n}", ".eur_dissect_fp_fach2": "static bool\r\nheur_dissect_fp_fach2(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)\r\n{\r\n    conversation_t   *p_conv;\r\n    fp_fach_channel_info_t* fp_fach_channel_info;\r\n    umts_fp_conversation_info_t* umts_fp_conversation_info = NULL;\r\n    struct fp_info *p_fp_info;\r\n    uint32_t captured_length;\r\n    uint32_t reported_length;\r\n    uint8_t frame_type;\r\n    uint8_t tfi;\r\n    uint8_t tctf;\r\n\r\n    /* Finding or creating conversation */\r\n    p_conv = (conversation_t *)find_conversation(pinfo->num, &pinfo->net_dst, &pinfo->net_src,\r\n        conversation_pt_to_conversation_type(pinfo->ptype),\r\n        pinfo->destport, pinfo->srcport, NO_ADDR_B);\r\n\r\n    if (p_conv != NULL) {\r\n        /* Checking if the conversation was already framed */\r\n        umts_fp_conversation_info = (umts_fp_conversation_info_t *)conversation_get_proto_data(p_conv, proto_fp);\r\n        if (umts_fp_conversation_info) {\r\n            if (umts_fp_conversation_info->channel == CHANNEL_FACH_FDD) {\r\n                conversation_set_dissector(p_conv, fp_handle);\r\n                dissect_fp(tvb, pinfo, tree, data);\r\n                return true;\r\n            }\r\n            else if (umts_fp_conversation_info->channel != CHANNEL_UNKNOWN){\r\n                /* This conversation was successfully framed as ANOTHER type */\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    /* Making sure we have at least enough bytes for header (4) + footer (2) */\r\n    captured_length = tvb_captured_length(tvb);\r\n    if(captured_length < 6) {\r\n        return false;\r\n    }\r\n\r\n    /* Expecting specific lengths: 27 for frames with 1 TB, 48 for frames with 2 TBs */\r\n    /* This is a common Transport Format of FACH ( See 3GPP TR 25.944 / 4.1.1.2 'FACH2' ) */\r\n    reported_length = tvb_reported_length(tvb);\r\n    if (reported_length != 27 && reported_length != 48) {\r\n        return false;\r\n    }\r\n\r\n    p_fp_info = (fp_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_fp, 0);\r\n\r\n    /* Making sure FP info isn't already attached */\r\n    if (p_fp_info) {\r\n        return false;\r\n    }\r\n\r\n    frame_type = tvb_get_uint8(tvb, 0) & 0x01;\r\n    if (frame_type == 1) { /* is 'control' frame type*/\r\n                           /* We can't tell the FP type and content of control frames */\r\n        return false;\r\n    }\r\n\r\n    tfi = tvb_get_uint8(tvb, 2) & 0x1f;\r\n    if (reported_length == 27 && tfi != 0x01) {\r\n        return false;\r\n    }\r\n    if (reported_length == 48 && tfi != 0x02) {\r\n        return false;\r\n    }\r\n\r\n    tctf = tvb_get_uint8(tvb, 4);\r\n    /* Asserting the TCTF field contains a valid (non reserved) value according to TS 25.321 Table 9.2.1-2 */\r\n    if (tctf != 0x40 && /* CCCH */\r\n        tctf != 0x50 && /* MCCH */\r\n        tctf != 0x5F && /* MSCH */\r\n        tctf != 0x80 && /* CTCH */\r\n        (tctf >> 4) != 0x06 && /* MTCH */\r\n        (tctf >> 6) != 0x00 && /* BCCH */\r\n        (tctf >> 6) != 0x03) { /* DCCH or DTCH over FACH */\r\n        return false;\r\n    }\r\n\r\n    if (!check_header_crc_for_heur(tvb, 4)) {\r\n        return false;\r\n    }\r\n    if (!check_payload_crc_for_heur(tvb, 4)) {\r\n        return false;\r\n    }\r\n\r\n    if(!umts_fp_conversation_info) {\r\n        umts_fp_conversation_info = wmem_new0(wmem_file_scope(), umts_fp_conversation_info_t);\r\n        set_both_sides_umts_fp_conv_data(pinfo, umts_fp_conversation_info);\r\n    }\r\n    umts_fp_conversation_info->iface_type = IuB_Interface;\r\n    umts_fp_conversation_info->division = Division_FDD;\r\n    umts_fp_conversation_info->dl_frame_number = pinfo->num;\r\n    umts_fp_conversation_info->ul_frame_number = pinfo->num;\r\n    umts_fp_conversation_info->dch_crc_present = 1;\r\n    umts_fp_conversation_info->com_context_id = generate_ue_id_for_heur(pinfo);\r\n    umts_fp_conversation_info->rlc_mode = FP_RLC_AM;\r\n    copy_address_wmem(wmem_file_scope(), &(umts_fp_conversation_info->crnc_address), &pinfo->src);\r\n    umts_fp_conversation_info->crnc_port = pinfo->srcport;\r\n    umts_fp_conversation_info->channel = CHANNEL_FACH_FDD;\r\n    umts_fp_conversation_info->num_dch_in_flow = 1;\r\n    umts_fp_conversation_info->fp_dch_channel_info[0].num_dl_chans = 1;\r\n    umts_fp_conversation_info->fp_dch_channel_info[0].dl_chan_num_tbs[1] = 1;\r\n    umts_fp_conversation_info->fp_dch_channel_info[0].dl_chan_tf_size[1] = 168;\r\n    umts_fp_conversation_info->fp_dch_channel_info[0].dl_chan_num_tbs[2] = 2;\r\n    umts_fp_conversation_info->fp_dch_channel_info[0].dl_chan_tf_size[2] = 168;\r\n    /* Adding the 'channel specific info' for FACH */\r\n    fp_fach_channel_info = wmem_new0(wmem_file_scope(), fp_fach_channel_info_t);\r\n    fp_fach_channel_info->crnti_to_urnti_map = wmem_tree_new_autoreset(wmem_epan_scope(), wmem_file_scope());\r\n    umts_fp_conversation_info->channel_specific_info = (void*)fp_fach_channel_info;\r\n\r\n    conversation_set_dissector(find_or_create_conversation(pinfo), fp_handle);\r\n    dissect_fp(tvb, pinfo, tree, data);\r\n    return true;\r\n}", ".eur_dissect_fp_rach": "static bool\r\nheur_dissect_fp_rach(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)\r\n{\r\n    conversation_t   *p_conv;\r\n    fp_rach_channel_info_t* fp_rach_channel_info;\r\n    umts_fp_conversation_info_t* umts_fp_conversation_info = NULL;\r\n    struct fp_info *p_fp_info;\r\n    uint32_t captured_length;\r\n    uint32_t reported_length;\r\n    uint8_t frame_type;\r\n    uint8_t tfi;\r\n    uint8_t tctf;\r\n\r\n    /* Finding or creating conversation */\r\n    p_conv = (conversation_t *)find_conversation(pinfo->num, &pinfo->net_dst, &pinfo->net_src,\r\n        conversation_pt_to_conversation_type(pinfo->ptype),\r\n        pinfo->destport, pinfo->srcport, NO_ADDR_B);\r\n\r\n    if (p_conv != NULL) {\r\n        /* Checking if the conversation was already framed */\r\n        umts_fp_conversation_info = (umts_fp_conversation_info_t *)conversation_get_proto_data(p_conv, proto_fp);\r\n        if (umts_fp_conversation_info) {\r\n            if (umts_fp_conversation_info->channel == CHANNEL_RACH_FDD) {\r\n                conversation_set_dissector(p_conv, fp_handle);\r\n                dissect_fp(tvb, pinfo, tree, data);\r\n                return true;\r\n            }\r\n            else if (umts_fp_conversation_info->channel != CHANNEL_UNKNOWN){\r\n                /* This conversation was successfully framed as ANOTHER type */\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /* Making sure we have at least enough bytes for header (4) + footer (2) */\r\n    captured_length = tvb_captured_length(tvb);\r\n    if(captured_length < 6) {\r\n        return false;\r\n    }\r\n\r\n    /* Expecting specific lengths: rach frames are either 28 or 52 bytes long */\r\n    /* This is the common Transport Formats of RACH ( See 3GPP TR 25.944 / 4.1.2.1 ) */\r\n    reported_length = tvb_reported_length(tvb);\r\n    if (reported_length != 28 && reported_length != 52) {\r\n        return false;\r\n    }\r\n\r\n    p_fp_info = (fp_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_fp, 0);\r\n\r\n    /* Making sure FP info isn't already attached */\r\n    if (p_fp_info) {\r\n        return false;\r\n    }\r\n\r\n    frame_type = tvb_get_uint8(tvb, 0) & 0x01;\r\n    if (frame_type == 1) { /* is 'control' frame type*/\r\n                           /* We can't tell the FP type and content of control frames */\r\n        return false;\r\n    }\r\n\r\n    tfi = tvb_get_uint8(tvb, 2) & 0x1f;\r\n    if (reported_length == 28 && tfi != 0x00) {\r\n        return false;\r\n    }\r\n    if (reported_length == 52 && tfi != 0x01) {\r\n        return false;\r\n    }\r\n\r\n    tctf = tvb_get_uint8(tvb, 4) >> 6;\r\n    /* Asserting the TCTF field contains a valid (non reserved) value according to TS 25.321 Table 9.2.1-4 */\r\n    if (tctf != 0x00 && /* CCCH */\r\n        tctf != 0x01)  /* DCCH over RACH */\r\n    {\r\n        return false;\r\n    }\r\n\r\n    if (!check_header_crc_for_heur(tvb, 4)) {\r\n        return false;\r\n    }\r\n    if (!check_payload_crc_for_heur(tvb, 4)) {\r\n        return false;\r\n    }\r\n\r\n    if(!umts_fp_conversation_info) {\r\n        umts_fp_conversation_info = wmem_new0(wmem_file_scope(), umts_fp_conversation_info_t);\r\n        set_both_sides_umts_fp_conv_data(pinfo, umts_fp_conversation_info);\r\n    }\r\n    umts_fp_conversation_info->iface_type = IuB_Interface;\r\n    umts_fp_conversation_info->division = Division_FDD;\r\n    umts_fp_conversation_info->dl_frame_number = pinfo->num;\r\n    umts_fp_conversation_info->ul_frame_number = pinfo->num;\r\n    umts_fp_conversation_info->dch_crc_present = 1;\r\n    umts_fp_conversation_info->com_context_id = generate_ue_id_for_heur(pinfo);\r\n    umts_fp_conversation_info->rlc_mode = FP_RLC_AM;\r\n    copy_address_wmem(wmem_file_scope(), &(umts_fp_conversation_info->crnc_address), &pinfo->dst);\r\n    umts_fp_conversation_info->crnc_port = pinfo->destport;\r\n    umts_fp_conversation_info->channel = CHANNEL_RACH_FDD;\r\n    umts_fp_conversation_info->num_dch_in_flow = 1;\r\n    umts_fp_conversation_info->fp_dch_channel_info[0].num_ul_chans = 0;\r\n    umts_fp_conversation_info->fp_dch_channel_info[0].ul_chan_num_tbs[0] = 1;\r\n    umts_fp_conversation_info->fp_dch_channel_info[0].ul_chan_num_tbs[1] = 1;\r\n    umts_fp_conversation_info->fp_dch_channel_info[0].ul_chan_tf_size[0] = 168;\r\n    umts_fp_conversation_info->fp_dch_channel_info[0].ul_chan_tf_size[1] = 360;\r\n\r\n    /* Adding the 'channel specific info' for RACH */\r\n    fp_rach_channel_info = wmem_new0(wmem_file_scope(), fp_rach_channel_info_t);\r\n    fp_rach_channel_info->crnti_to_urnti_map = wmem_tree_new_autoreset(wmem_epan_scope(), wmem_file_scope());\r\n    umts_fp_conversation_info->channel_specific_info = (void*)fp_rach_channel_info;\r\n\r\n    conversation_set_dissector(find_or_create_conversation(pinfo), fp_handle);\r\n    dissect_fp(tvb, pinfo, tree, data);\r\n    return true;\r\n}", ".eur_dissect_fp_pch": "static bool\r\nheur_dissect_fp_pch(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)\r\n{\r\n    conversation_t   *p_conv;\r\n    umts_fp_conversation_info_t* umts_fp_conversation_info = NULL;\r\n    fp_pch_channel_info_t* fp_pch_channel_info = NULL;\r\n    struct fp_info *p_fp_info;\r\n    bool conversation_initialized = false;\r\n    uint32_t captured_length;\r\n    uint32_t reported_length;\r\n    uint8_t frame_type;\r\n    uint8_t reserved_bits;\r\n    uint8_t tfi;\r\n    uint8_t pi_byte_length;\r\n    uint16_t tb_byte_length;\r\n    bool pi_present;\r\n    bool tb_size_found;\r\n    bool pi_length_found;\r\n    uint8_t cfn_lowest_bits;\r\n    uint8_t dch_collisions_byte;\r\n\r\n    /* To correctly dissect a PCH stream 2 parameters are required: PI Bitmap length & TB length */\r\n    /* Both are optional in each packet and having them both in a packet without knowing any of them */\r\n    /* is not helpful.*/\r\n    /* Hence gathering the info from 2 different frames is required. */\r\n\r\n    /* Finding or creating conversation */\r\n    p_conv = (conversation_t *)find_conversation(pinfo->num, &pinfo->net_dst, &pinfo->net_src,\r\n        conversation_pt_to_conversation_type(pinfo->ptype),\r\n        pinfo->destport, pinfo->srcport, NO_ADDR_B);\r\n\r\n    if (p_conv != NULL) {\r\n        /* Checking if the conversation was already framed */\r\n        umts_fp_conversation_info = (umts_fp_conversation_info_t *)conversation_get_proto_data(p_conv, proto_fp);\r\n        if (umts_fp_conversation_info) {\r\n            fp_pch_channel_info = (fp_pch_channel_info_t*)umts_fp_conversation_info->channel_specific_info;\r\n            /* Making sure this conversation type is \"PCH\" and the PCH channel info is present */\r\n            if (umts_fp_conversation_info->channel == CHANNEL_PCH && fp_pch_channel_info != NULL) {\r\n                conversation_initialized = true;\r\n                pi_length_found = fp_pch_channel_info->paging_indications != 0;\r\n                tb_size_found = umts_fp_conversation_info->fp_dch_channel_info[0].dl_chan_tf_size[1] != 0;\r\n                if (pi_length_found && tb_size_found) {\r\n                    /* Stream already framed - contains both PI length and TB size */\r\n                    dissect_fp(tvb, pinfo, tree, data);\r\n                    return true;\r\n                }\r\n            }\r\n            else if (umts_fp_conversation_info->channel != CHANNEL_UNKNOWN){\r\n                /* This conversation was successfully framed as ANOTHER type */\r\n                return false;\r\n            }\r\n            else {\r\n                /* FP conversation info attached and the channel type is UNKNOWN - might be PCH */\r\n                tb_size_found = false;\r\n                pi_length_found = false;\r\n            }\r\n        }\r\n        else {\r\n            /* FP conversation info not attached - no PCH info is known */\r\n            tb_size_found = false;\r\n            pi_length_found = false;\r\n        }\r\n    }\r\n    else {\r\n        /* A conversation does not exist yet - no PCH info is known */\r\n        tb_size_found = false;\r\n        pi_length_found = false;\r\n    }\r\n\r\n    /* Making sure we have at least enough bytes for header (4) + footer (2) */\r\n    captured_length = tvb_captured_length(tvb);\r\n    if(captured_length < 6) {\r\n        return false;\r\n    }\r\n\r\n    p_fp_info = (fp_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_fp, 0);\r\n    /* Making sure FP info isn't already attached */\r\n    if (p_fp_info) {\r\n        return false;\r\n    }\r\n\r\n    frame_type = tvb_get_uint8(tvb, 0) & 0x01;\r\n    if (frame_type == 1) { /* is 'control' frame type*/\r\n                           /* We can't tell the FP type and content of control frames */\r\n        return false;\r\n    }\r\n\r\n    /* Checking bits after CFN and before PI indicator are zeroed */\r\n    reserved_bits = tvb_get_uint8(tvb, 2) & 0x0E;\r\n    if (reserved_bits != 0x00) {\r\n        return false;\r\n    }\r\n\r\n    tfi = tvb_get_uint8(tvb, 3) & 0x1f;\r\n    if (tfi != 0x00 && tfi != 0x01) {\r\n        return false;\r\n    }\r\n\r\n    if (!check_header_crc_for_heur(tvb, 4)) {\r\n        return false;\r\n    }\r\n    if (!check_payload_crc_for_heur(tvb, 4)) {\r\n        return false;\r\n    }\r\n\r\n    reported_length = tvb_reported_length(tvb);\r\n    pi_present = tvb_get_uint8(tvb, 2) & 0x01; /* Rightmost bit in the 3rd byte */\r\n    if (pi_present) {\r\n        if (tfi == 0x00 && !pi_length_found) {\r\n            /* PI Bitmap present and No TB. Can calculate PI bitmap length */\r\n            uint8_t pi_bit_length;\r\n            pi_byte_length = reported_length - 6; /* Removing header length (4) and footer length (2)*/\r\n            switch (pi_byte_length)\r\n            {\r\n            case 3: /* 18 bits bitmap + padding */\r\n                pi_bit_length = 18;\r\n                break;\r\n            case 5: /* 36 bits bitmap + padding */\r\n                pi_bit_length = 36;\r\n                break;\r\n            case 9: /* 72 bits bitmap */\r\n                pi_bit_length = 72;\r\n                break;\r\n            case 18: /* 144 bits bitmap */\r\n                pi_bit_length = 144;\r\n                break;\r\n            default:\r\n                return false;\r\n            }\r\n\r\n            if (pi_bit_length == 144 && !tb_size_found) {\r\n                /* Nothing has confirmed yet that this channel is a PCH since */\r\n                /* both 'tb_size_found' and 'pi_length_found' are false. */\r\n                /* Checking if the 4 LSB bits of the CFN (the 4 leftmost bits in the 3rd byte) aren't zeroed. */\r\n                /* if they aren't this is probably PCH because those are reserved in DCH */\r\n                cfn_lowest_bits = tvb_get_uint8(tvb, 2) & 0xF0;\r\n                if(cfn_lowest_bits == 0) {\r\n                    /* Checking if the 4th byte in the frame is zeroed. In this case the CRC checks aren't */\r\n                    /* deterministic enough to guarantee this is a PCH since this packet could also be a DCH frame */\r\n                    /* with MAC's C/T is 0 and 4 leftmost bits of RLC are 0 */\r\n                    dch_collisions_byte = tvb_get_uint8(tvb, 3);\r\n                    if (dch_collisions_byte == 0) {\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (!umts_fp_conversation_info) {\r\n                umts_fp_conversation_info = wmem_new0(wmem_file_scope(), umts_fp_conversation_info_t);\r\n                set_both_sides_umts_fp_conv_data(pinfo, umts_fp_conversation_info);\r\n            }\r\n            if(!conversation_initialized) {\r\n                fill_pch_conversation_info_for_heur(umts_fp_conversation_info, pinfo);\r\n                fp_pch_channel_info = (fp_pch_channel_info_t*)umts_fp_conversation_info->channel_specific_info;\r\n            }\r\n            fp_pch_channel_info->paging_indications = pi_bit_length;\r\n            pi_length_found = true;\r\n        }\r\n        else if (tfi == 0x01 && !tb_size_found && pi_length_found) {\r\n            /* TB present and PI bitmap length is known. Can calculate TB length.*/\r\n            pi_byte_length = (fp_pch_channel_info->paging_indications + 7) / 8;\r\n            if (!umts_fp_conversation_info) {\r\n                umts_fp_conversation_info = wmem_new0(wmem_file_scope(), umts_fp_conversation_info_t);\r\n                set_both_sides_umts_fp_conv_data(pinfo, umts_fp_conversation_info);\r\n            }\r\n            if(!conversation_initialized) {\r\n                fill_pch_conversation_info_for_heur(umts_fp_conversation_info, pinfo);\r\n            }\r\n            tb_byte_length = (reported_length - (pi_byte_length + 6)); /* Removing header length (4), footer length (2) and PI bitmap length*/\r\n            /* Possible TB lengths for PCH is 10 or 30 bytes ( See 3GPP TR 25.944 / 4.1.1.2 ) */\r\n            if (tb_byte_length == 10 || tb_byte_length == 30) {\r\n                umts_fp_conversation_info->fp_dch_channel_info[0].dl_chan_tf_size[1] = tb_byte_length * 8;\r\n                tb_size_found = true;\r\n            }\r\n        }\r\n        /* TODO: It should be possible to figure both PI & TB sizes if both are present in a frame and neither is known */\r\n        /* Since the total size of the frame should be unique */\r\n        /* e.g. 19 bytes = header (4) + PI 18bits (3) + TB (10) + footer (2)*/\r\n        /*      21 bytes = header (4) + PI 36bits (5) + TB (10) + footer (2)*/\r\n        /*      etc... */\r\n        /* This could mostly help dissect 'busy' PCHs where most of the frames have both PI & TB*/\r\n    }\r\n    else {\r\n        if (tfi == 0x01 && !tb_size_found) {\r\n            /* TB present and PI bitmap is missing. Can calculate TB length.*/\r\n            if (!umts_fp_conversation_info) {\r\n                umts_fp_conversation_info = wmem_new0(wmem_file_scope(), umts_fp_conversation_info_t);\r\n                set_both_sides_umts_fp_conv_data(pinfo, umts_fp_conversation_info);\r\n            }\r\n            if(!conversation_initialized) {\r\n                fill_pch_conversation_info_for_heur(umts_fp_conversation_info, pinfo);\r\n            }\r\n            tb_byte_length = (reported_length - 6); /* Removing header length (4), footer length (2) */\r\n            /* Possible TB lengths for PCH is 10 or 30 bytes ( See 3GPP TR 25.944 / 4.1.1.2 ) */\r\n            if (tb_byte_length == 10 || tb_byte_length == 30) {\r\n                umts_fp_conversation_info->fp_dch_channel_info[0].dl_chan_tf_size[1] = tb_byte_length * 8;\r\n                set_both_sides_umts_fp_conv_data(pinfo, umts_fp_conversation_info);\r\n                tb_size_found = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    if (pi_length_found && tb_size_found) {\r\n        /* Stream completely framed! */\r\n        conversation_set_dissector(find_or_create_conversation(pinfo), fp_handle);\r\n        dissect_fp(tvb, pinfo, tree, data);\r\n        return true;\r\n    }\r\n    else {\r\n        /* Some data still missing */\r\n        return false;\r\n    }\r\n}", ".eur_dissect_fp_hsdsch_type_1": "static bool\r\nheur_dissect_fp_hsdsch_type_1(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)\r\n{\r\n    conversation_t   *p_conv;\r\n    umts_fp_conversation_info_t* umts_fp_conversation_info = NULL;\r\n    fp_hsdsch_channel_info_t* fp_hsdsch_channel_info;\r\n    struct fp_info *p_fp_info;\r\n    uint32_t captured_length;\r\n    uint32_t reported_length;\r\n    uint8_t frame_type;\r\n    uint16_t mac_d_pdu_length;\r\n    uint16_t num_of_pdus;\r\n    uint32_t expected_total_size;\r\n    uint32_t next_pdu_index;\r\n    uint16_t index_step;\r\n    uint8_t pre_pdu_padding;\r\n\r\n    /* Trying to find existing conversation */\r\n    p_conv = (conversation_t *)find_conversation(pinfo->num, &pinfo->net_dst, &pinfo->net_src,\r\n        conversation_pt_to_conversation_type(pinfo->ptype),\r\n        pinfo->destport, pinfo->srcport, NO_ADDR_B);\r\n\r\n    if (p_conv != NULL) {\r\n        /* Checking if the conversation was already framed */\r\n        umts_fp_conversation_info = (umts_fp_conversation_info_t *)conversation_get_proto_data(p_conv, proto_fp);\r\n        if (umts_fp_conversation_info) {\r\n            fp_hsdsch_channel_info = (fp_hsdsch_channel_info_t*)umts_fp_conversation_info->channel_specific_info;\r\n            if (umts_fp_conversation_info->channel == CHANNEL_HSDSCH && fp_hsdsch_channel_info->hsdsch_entity == hs) {\r\n                conversation_set_dissector(p_conv, fp_handle);\r\n                dissect_fp(tvb, pinfo, tree, data);\r\n                return true;\r\n            }\r\n            else if (umts_fp_conversation_info->channel != CHANNEL_UNKNOWN){\r\n                /* This conversation was successfully framed as ANOTHER type */\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /* Making sure FP info isn't already attached */\r\n    p_fp_info = (fp_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_fp, 0);\r\n    if (p_fp_info) {\r\n        return false;\r\n    }\r\n\r\n    captured_length = tvb_reported_length(tvb);\r\n    /* Lengths limit: header size (7) + at least 1 PDU Block (2) + CRC Payload size (2)*/\r\n    if (captured_length < 11) {\r\n        return false;\r\n    }\r\n\r\n    frame_type = tvb_get_uint8(tvb, 0) & 0x01;\r\n    if (frame_type == 1) { /* is 'control' frame type*/\r\n        return false;\r\n    }\r\n\r\n    /* Lengths limit: Smallest HS-DSCH type 1 data frame is 55 bytes (1 PDU of 336 bits) */\r\n    reported_length = tvb_reported_length(tvb);\r\n    if (reported_length < 55) {\r\n        return false;\r\n    }\r\n\r\n    mac_d_pdu_length = tvb_get_uint16(tvb, 2, ENC_NA) >> 3;\r\n    /* Only valid PDU lengths are 336 or 656 */\r\n    if (mac_d_pdu_length != 336 && mac_d_pdu_length != 656) {\r\n        return false;\r\n    }\r\n\r\n    num_of_pdus = tvb_get_uint8(tvb, 4);\r\n    /* PDUs count shouldn't be 0*/\r\n    if (num_of_pdus == 0) {\r\n        return false;\r\n    }\r\n    /* Maximum PDUs count constraint: 32 PDUs * 336 bits or 17 PDUs * 656 bits */\r\n    if ((mac_d_pdu_length == 336 && num_of_pdus > 32) || (mac_d_pdu_length == 656 && num_of_pdus > 17)) {\r\n        return false;\r\n    }\r\n\r\n    /* Making sure the expected packet size is smaller/equals to the entire packet's size */\r\n    expected_total_size = (num_of_pdus * mac_d_pdu_length / 8) + 7 /*Header length*/ + 2 /*Footer length*/;\r\n    if (expected_total_size > captured_length || expected_total_size > reported_length) {\r\n        return false;\r\n    }\r\n\r\n    /* Iterating through the PDUs making sure the padding nibble is present in all of them */\r\n    next_pdu_index = 7;\r\n    index_step = mac_d_pdu_length / 8;\r\n    for (int i = 0; i < num_of_pdus; i++)\r\n    {\r\n        pre_pdu_padding = tvb_get_uint8(tvb, next_pdu_index) >> 4;\r\n        if (pre_pdu_padding != 0x00)\r\n        {\r\n            /* One of the padding nibbles is not zeroed */\r\n            return false;\r\n        }\r\n        next_pdu_index += index_step;\r\n    }\r\n\r\n    if (!check_header_crc_for_heur(tvb, 7)) {\r\n        return false;\r\n    }\r\n    if (!check_payload_crc_for_heur(tvb, 7)) {\r\n        return false;\r\n    }\r\n\r\n    if(!umts_fp_conversation_info) {\r\n        umts_fp_conversation_info = wmem_new0(wmem_file_scope(), umts_fp_conversation_info_t);\r\n        set_both_sides_umts_fp_conv_data(pinfo, umts_fp_conversation_info);\r\n    }\r\n    umts_fp_conversation_info->iface_type = IuB_Interface;\r\n    umts_fp_conversation_info->division = Division_FDD;\r\n    umts_fp_conversation_info->dl_frame_number = pinfo->num;\r\n    umts_fp_conversation_info->ul_frame_number = pinfo->num;\r\n    umts_fp_conversation_info->dch_crc_present = 1;\r\n    umts_fp_conversation_info->com_context_id = generate_ue_id_for_heur(pinfo);\r\n    umts_fp_conversation_info->rlc_mode = FP_RLC_AM;\r\n    copy_address_wmem(wmem_file_scope(), &(umts_fp_conversation_info->crnc_address), &pinfo->src);\r\n    umts_fp_conversation_info->crnc_port = pinfo->srcport;\r\n    umts_fp_conversation_info->channel = CHANNEL_HSDSCH;\r\n    fp_hsdsch_channel_info = wmem_new0(wmem_file_scope(), fp_hsdsch_channel_info_t);\r\n    fp_hsdsch_channel_info->hsdsch_entity = hs;\r\n    fp_hsdsch_channel_info->hsdsch_macdflow_id = 0;\r\n    umts_fp_conversation_info->channel_specific_info = (void*)fp_hsdsch_channel_info;\r\n\r\n    conversation_set_dissector(find_or_create_conversation(pinfo), fp_handle);\r\n    dissect_fp(tvb, pinfo, tree, data);\r\n    return true;\r\n}", ".eur_dissect_fp_hsdsch_type_2": "static bool\r\nheur_dissect_fp_hsdsch_type_2(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)\r\n{\r\n    conversation_t   *p_conv;\r\n    umts_fp_conversation_info_t* umts_fp_conversation_info = NULL;\r\n    fp_hsdsch_channel_info_t* fp_hsdsch_channel_info;\r\n    struct fp_info *p_fp_info;\r\n    uint32_t captured_length;\r\n    uint32_t reported_length;\r\n    uint8_t frame_type;\r\n    uint8_t reserved_fach_ind_bits;\r\n    uint8_t pdu_block_header_reserved_bit;\r\n    uint8_t pdu_block_headers_count;\r\n    uint16_t next_pdu_block_header_index;\r\n    uint16_t pdu_block_header_pdu_length;\r\n    uint8_t pdu_block_header_pdus_count;\r\n    uint8_t pdu_block_header_lchid;\r\n    uint32_t total_header_length;\r\n    uint32_t expected_payload_length;\r\n\r\n    /* Trying to find existing conversation */\r\n    p_conv = (conversation_t *)find_conversation(pinfo->num, &pinfo->net_dst, &pinfo->net_src,\r\n        conversation_pt_to_conversation_type(pinfo->ptype),\r\n        pinfo->destport, pinfo->srcport, NO_ADDR_B);\r\n\r\n    if (p_conv != NULL) {\r\n        /* Checking if the conversation was already framed */\r\n        umts_fp_conversation_info = (umts_fp_conversation_info_t *)conversation_get_proto_data(p_conv, proto_fp);\r\n        if (umts_fp_conversation_info) {\r\n            fp_hsdsch_channel_info = (fp_hsdsch_channel_info_t*)umts_fp_conversation_info->channel_specific_info;\r\n            if (umts_fp_conversation_info->channel == CHANNEL_HSDSCH && fp_hsdsch_channel_info->hsdsch_entity == ehs) {\r\n                conversation_set_dissector(p_conv, fp_handle);\r\n                dissect_fp(tvb, pinfo, tree, data);\r\n                return true;\r\n            }\r\n            else if (umts_fp_conversation_info->channel != CHANNEL_UNKNOWN){\r\n                /* This conversation was successfully framed as ANOTHER type */\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /* Making sure FP info isn't already attached */\r\n    p_fp_info = (fp_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_fp, 0);\r\n    if (p_fp_info) {\r\n        return false;\r\n    }\r\n\r\n    captured_length = tvb_captured_length(tvb);\r\n    reported_length = tvb_reported_length(tvb);\r\n    /* Lengths limit: header size + at least 1 PDU Block Header + CRC Payload size */\r\n    if (captured_length < 11) {\r\n        return false;\r\n    }\r\n\r\n    frame_type = tvb_get_uint8(tvb, 0) & 0x01;\r\n    if (frame_type == 1) { /* is 'control' frame type*/\r\n        return false;\r\n    }\r\n\r\n    pdu_block_header_reserved_bit = (tvb_get_uint8(tvb, 7) & 0x10) >> 4;\r\n    if (pdu_block_header_reserved_bit == 0x1) {\r\n        return false;\r\n    }\r\n\r\n    /* Expecting at least 1 PDU Block Header */\r\n    pdu_block_headers_count = tvb_get_uint8(tvb, 2) >> 3;\r\n    if (pdu_block_headers_count == 0) {\r\n        return false;\r\n    }\r\n\r\n    /* Getting 3 rightmost bits in the FACH Indicator's byte, which are reserved and should be 0 */\r\n    reserved_fach_ind_bits = tvb_get_uint8(tvb, 3) & 0x03;\r\n    if (reserved_fach_ind_bits != 0x00) {\r\n        return false;\r\n    }\r\n\r\n    /* Iterating through the block headers looking for invalid fields and */\r\n    /* calculating the expected total packet length */\r\n    total_header_length = 6;\r\n    expected_payload_length = 0;\r\n    for (int i = 0; i < pdu_block_headers_count; i++)\r\n    {\r\n        /* Making sure the next index is not out of range */\r\n        if (((uint32_t)(8 + (i * 3))) >= captured_length) {\r\n            return false;\r\n        }\r\n\r\n        /* Getting blocks length and count from the i-th header */\r\n        if (i % 2 == 0) {\r\n            next_pdu_block_header_index = (i * 25) / 10;\r\n        }\r\n        else {\r\n            next_pdu_block_header_index = (((i-1) * 25) / 10) + 2;\r\n        }\r\n        pdu_block_header_pdu_length = tvb_get_uint16(tvb, 6 + next_pdu_block_header_index, ENC_NA) >> 5;\r\n        pdu_block_header_pdus_count = tvb_get_uint8(tvb, 7 + next_pdu_block_header_index) & 0x0F;\r\n        pdu_block_header_lchid = tvb_get_uint8(tvb, 8 + next_pdu_block_header_index) >> 4;\r\n\r\n\r\n        /* Making sure PDUs' Length isn't zeroed*/\r\n        if (pdu_block_header_pdu_length == 0) {\r\n            return false;\r\n        }\r\n        /* Making sure PDUs Count isn't zeroed */\r\n        if (pdu_block_header_pdus_count == 0) {\r\n            return false;\r\n        }\r\n\r\n        /* Adding this header's length to expected length*/\r\n        if (i % 2 == 0) {\r\n            total_header_length += 3;\r\n        }\r\n        else {\r\n            total_header_length += 2;\r\n        }\r\n        /* Adding this header's payload's size to expected length*/\r\n        expected_payload_length += (pdu_block_header_pdu_length * pdu_block_header_pdus_count);\r\n\r\n        /* Checking padding after lchid */\r\n        if ((tvb_get_uint8(tvb, 8 + (i * 3)) & 0x0F) != 0x00) {\r\n            return false;\r\n        }\r\n        /* Checking lchid for reserved value 0x0F*/\r\n\r\n        if (pdu_block_header_lchid == 0x0F) {\r\n            return false;\r\n        }\r\n    }\r\n    /* Adding Payload CRC'slength to payload length*/\r\n    expected_payload_length += 2;\r\n    /* Calculated expected packet size must not exceed captured length or reported length*/\r\n    if ((total_header_length + expected_payload_length) > captured_length || (total_header_length + expected_payload_length) > reported_length) {\r\n        return false;\r\n    }\r\n\r\n    if (!check_header_crc_for_heur(tvb, total_header_length)) {\r\n        return false;\r\n    }\r\n    if (!check_payload_crc_for_heur(tvb, total_header_length)) {\r\n        return false;\r\n    }\r\n\r\n    if(!umts_fp_conversation_info) {\r\n        umts_fp_conversation_info = wmem_new0(wmem_file_scope(), umts_fp_conversation_info_t);\r\n        set_both_sides_umts_fp_conv_data(pinfo, umts_fp_conversation_info);\r\n    }\r\n    umts_fp_conversation_info->iface_type = IuB_Interface;\r\n    umts_fp_conversation_info->division = Division_FDD;\r\n    umts_fp_conversation_info->dl_frame_number = pinfo->num;\r\n    umts_fp_conversation_info->ul_frame_number = pinfo->num;\r\n    umts_fp_conversation_info->dch_crc_present = 1;\r\n    umts_fp_conversation_info->com_context_id = generate_ue_id_for_heur(pinfo);\r\n    umts_fp_conversation_info->rlc_mode = FP_RLC_AM;\r\n    copy_address_wmem(wmem_file_scope(), &(umts_fp_conversation_info->crnc_address), &pinfo->src);\r\n    umts_fp_conversation_info->crnc_port = pinfo->srcport;\r\n    umts_fp_conversation_info->channel = CHANNEL_HSDSCH;\r\n    fp_hsdsch_channel_info = wmem_new0(wmem_file_scope(), fp_hsdsch_channel_info_t);\r\n    fp_hsdsch_channel_info->hsdsch_entity = ehs;\r\n    fp_hsdsch_channel_info->hsdsch_macdflow_id = 1;\r\n    umts_fp_conversation_info->channel_specific_info = (void*)fp_hsdsch_channel_info;\r\n\r\n    conversation_set_dissector(find_or_create_conversation(pinfo), fp_handle);\r\n    dissect_fp(tvb, pinfo, tree, data);\r\n    return true;\r\n}", ".eur_dissect_fp_edch_type_1": "static bool\r\nheur_dissect_fp_edch_type_1(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)\r\n{\r\n    conversation_t   *p_conv;\r\n    umts_fp_conversation_info_t* umts_fp_conversation_info = NULL;\r\n    fp_edch_channel_info_t* fp_edch_channel_info;\r\n    struct fp_info *p_fp_info;\r\n    uint32_t captured_length;\r\n    uint8_t frame_type;\r\n    uint8_t num_sub_frames_byte;\r\n    uint8_t number_of_subframes;\r\n    uint8_t number_of_mac_es_pdus;\r\n    uint32_t subframe_number;\r\n    uint32_t total_sub_headers_len;\r\n    uint32_t total_header_length;\r\n    uint32_t payload_length;\r\n    uint32_t total_mac_pdus_count;\r\n    uint32_t macd_pdu_bit_size;\r\n    uint32_t bit_offset;\r\n    uint32_t offset;\r\n    uint32_t i = 0;\r\n    uint32_t n = 0;\r\n\r\n    /* Trying to find existing conversation */\r\n    p_conv = (conversation_t *)find_conversation(pinfo->num, &pinfo->net_dst, &pinfo->net_src,\r\n        conversation_pt_to_conversation_type(pinfo->ptype),\r\n        pinfo->destport, pinfo->srcport, NO_ADDR_B);\r\n\r\n    if (p_conv != NULL) {\r\n        /* Checking if the conversation was already framed */\r\n        umts_fp_conversation_info = (umts_fp_conversation_info_t *)conversation_get_proto_data(p_conv, proto_fp);\r\n        if (umts_fp_conversation_info) {\r\n            fp_edch_channel_info = (fp_edch_channel_info_t*)umts_fp_conversation_info->channel_specific_info;\r\n            if (umts_fp_conversation_info->channel == CHANNEL_EDCH && fp_edch_channel_info->edch_type == 0) {\r\n                conversation_set_dissector(p_conv, fp_handle);\r\n                dissect_fp(tvb, pinfo, tree, data);\r\n                return true;\r\n            }\r\n            else if (umts_fp_conversation_info->channel != CHANNEL_UNKNOWN){\r\n                /* This conversation was successfully framed as ANOTHER type */\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /* Making sure FP info isn't already attached */\r\n    p_fp_info = (fp_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_fp, 0);\r\n    if (p_fp_info) {\r\n        return false;\r\n    }\r\n\r\n    captured_length = tvb_reported_length(tvb);\r\n    /* Lengths limit: header size + at least 1 Subframe Header + CRC Payload size */\r\n    if (captured_length < 9) {\r\n        return false;\r\n    }\r\n\r\n    frame_type = tvb_get_uint8(tvb, 0) & 0x01;\r\n    if (frame_type == 1) { /* is 'control' frame type*/\r\n        return false;\r\n    }\r\n\r\n    num_sub_frames_byte = tvb_get_uint8(tvb, 2);\r\n    /* Checking 4 leftmost bits in the 'Number of Subframes' byte, which are reserved and should be 0 */\r\n    if (num_sub_frames_byte & 0xf0) {\r\n        return false;\r\n    }\r\n\r\n    /* Values {11-16} are reserved */\r\n    number_of_subframes = (num_sub_frames_byte & 0x0f) + 1;\r\n    if (number_of_subframes >= 11) {\r\n        return false;\r\n    }\r\n\r\n    /* Iterating through the block headers looking for invalid fields */\r\n    total_header_length = 4;\r\n    offset = 4;\r\n    total_mac_pdus_count = 0;\r\n    /* EDCH subframe header list */\r\n    for (n=0; n < number_of_subframes; n++) {\r\n\r\n        /* Making sure the next index is not out of range */\r\n        if (((uint32_t)(offset + 3)) >= captured_length) {\r\n            return false;\r\n        }\r\n\r\n        /* Subframe number */\r\n        subframe_number = (tvb_get_uint8(tvb, offset) & 0x07);\r\n        if (subframe_number > 4) {\r\n            return false;\r\n        }\r\n        offset++;\r\n\r\n        /* Number of MAC-es PDUs */\r\n        number_of_mac_es_pdus = (tvb_get_uint8(tvb, offset) & 0xf0) >> 4;\r\n        if (number_of_mac_es_pdus == 0) {\r\n            return false;\r\n        }\r\n        bit_offset = 4;\r\n\r\n        /* Making sure enough bytes are present for all sub-header */\r\n        total_sub_headers_len = ((int)((((1.5 + (number_of_mac_es_pdus * 1.5))*8+7)/8)));\r\n        if ((offset + total_sub_headers_len) >= captured_length) {\r\n            return false;\r\n        }\r\n        /* Details of each MAC-es PDU */\r\n        for (i=0; i < number_of_mac_es_pdus; i++) {\r\n            uint32_t n_pdus;    /*Size of the PDU*/\r\n\r\n            /* DDI (6 bits) */\r\n            bit_offset += 6;\r\n\r\n            /* Number of MAC-d PDUs (6 bits) */\r\n            n_pdus = tvb_get_bits8( tvb, offset*8 + bit_offset, 6);\r\n            total_mac_pdus_count += n_pdus;\r\n            bit_offset += 6;\r\n        }\r\n\r\n        total_header_length += total_sub_headers_len;\r\n        offset += ((bit_offset+7)/8);\r\n    }\r\n\r\n    /* Figure MAC bit size */\r\n    payload_length = captured_length - total_header_length - 3; /* Removing 3 bytes for Payload CRC and TSN */\r\n    if (payload_length == (total_mac_pdus_count * 42)) {\r\n        macd_pdu_bit_size = 336;\r\n    }\r\n    else if (payload_length == (total_mac_pdus_count * 18)) {\r\n        macd_pdu_bit_size = 144;\r\n    }\r\n    else {\r\n        /* Unexpected payload length or DDIs combination */\r\n        return false;\r\n    }\r\n\r\n    if (!check_edch_header_crc_for_heur(pinfo->pool, tvb, total_header_length)) {\r\n        return false;\r\n    }\r\n    if (!check_payload_crc_for_heur(tvb, total_header_length)) {\r\n        return false;\r\n    }\r\n\r\n    if(!umts_fp_conversation_info) {\r\n        umts_fp_conversation_info = wmem_new0(wmem_file_scope(), umts_fp_conversation_info_t);\r\n        set_both_sides_umts_fp_conv_data(pinfo, umts_fp_conversation_info);\r\n    }\r\n    umts_fp_conversation_info->iface_type = IuB_Interface;\r\n    umts_fp_conversation_info->division = Division_FDD;\r\n    umts_fp_conversation_info->dl_frame_number = pinfo->num;\r\n    umts_fp_conversation_info->ul_frame_number = pinfo->num;\r\n    umts_fp_conversation_info->dch_crc_present = 1;\r\n    umts_fp_conversation_info->com_context_id = generate_ue_id_for_heur(pinfo);\r\n    umts_fp_conversation_info->rlc_mode = FP_RLC_AM;\r\n    copy_address_wmem(wmem_file_scope(), &(umts_fp_conversation_info->crnc_address), &pinfo->src);\r\n    umts_fp_conversation_info->crnc_port = pinfo->srcport;\r\n    umts_fp_conversation_info->channel = CHANNEL_EDCH;\r\n    fp_edch_channel_info = wmem_new0(wmem_file_scope(), fp_edch_channel_info_t);\r\n    fp_edch_channel_info->no_ddi_entries = 0x0f;\r\n    for(i = 0;i<0x0f;i++) {\r\n        fp_edch_channel_info->edch_ddi[i] = i;\r\n        fp_edch_channel_info->edch_macd_pdu_size[i] = macd_pdu_bit_size;\r\n        fp_edch_channel_info->edch_lchId[i] = 9;\r\n    }\r\n    fp_edch_channel_info->edch_type = 0; /* Type 1 */\r\n    umts_fp_conversation_info->channel_specific_info = (void*)fp_edch_channel_info;\r\n\r\n    conversation_set_dissector(find_or_create_conversation(pinfo), fp_handle);\r\n    dissect_fp(tvb, pinfo, tree, data);\r\n    return true;\r\n}", ".ill_pch_conversation_info_for_heur": "static void\r\nfill_pch_conversation_info_for_heur(umts_fp_conversation_info_t* umts_fp_conversation_info ,packet_info *pinfo)\r\n{\r\n    umts_fp_conversation_info->iface_type = IuB_Interface;\r\n    umts_fp_conversation_info->division = Division_FDD;\r\n    umts_fp_conversation_info->dl_frame_number = pinfo->num;\r\n    umts_fp_conversation_info->ul_frame_number = pinfo->num;\r\n    umts_fp_conversation_info->dch_crc_present = 1;\r\n    umts_fp_conversation_info->com_context_id = generate_ue_id_for_heur(pinfo);\r\n    umts_fp_conversation_info->rlc_mode = FP_RLC_AM;\r\n    copy_address_wmem(wmem_file_scope(), &(umts_fp_conversation_info->crnc_address), &pinfo->src);\r\n    umts_fp_conversation_info->crnc_port = pinfo->srcport;\r\n    umts_fp_conversation_info->channel = CHANNEL_PCH;\r\n    umts_fp_conversation_info->num_dch_in_flow = 1;\r\n    umts_fp_conversation_info->fp_dch_channel_info[0].num_dl_chans = 1;\r\n    umts_fp_conversation_info->fp_dch_channel_info[0].dl_chan_num_tbs[1] = 1;\r\n    umts_fp_conversation_info->channel_specific_info = (void*)wmem_new0(wmem_file_scope(), fp_pch_channel_info_t);\r\n}", ".eur_dissect_fp": "static bool\r\nheur_dissect_fp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)\r\n{\r\n    bool match;\r\n\r\n    match = heur_dissect_fp_dcch_over_dch(tvb, pinfo, tree, data);\r\n    if(match)\r\n        return true;\r\n    match = heur_dissect_fp_fach1(tvb, pinfo, tree, data);\r\n    if(match)\r\n        return true;\r\n    match = heur_dissect_fp_fach2(tvb, pinfo, tree, data);\r\n    if(match)\r\n        return true;\r\n    match = heur_dissect_fp_rach(tvb, pinfo, tree, data);\r\n    if(match)\r\n        return true;\r\n    match = heur_dissect_fp_pch(tvb, pinfo, tree, data);\r\n    if(match)\r\n        return true;\r\n    match = heur_dissect_fp_hsdsch_type_1(tvb, pinfo, tree, data);\r\n    if(match)\r\n        return true;\r\n    match = heur_dissect_fp_hsdsch_type_2(tvb, pinfo, tree, data);\r\n    if(match)\r\n        return true;\r\n    match = heur_dissect_fp_edch_type_1(tvb, pinfo, tree, data);\r\n    if(match)\r\n        return true;\r\n    /* NOTE: Add new heuristic dissectors BEFORE the 'unknown format' dissector */\r\n    /* since it might 'swallow' packets if the UDP stream is framed as 'CHANNEL_UNKNOWN' */\r\n    match = heur_dissect_fp_unknown_format(tvb, pinfo, tree, data);\r\n    if(match)\r\n        return true;\r\n\r\n    return false;\r\n}", ".roto_reg_handoff_fp": "void proto_reg_handoff_fp(void)\r\n{\r\n    rlc_bcch_handle           = find_dissector_add_dependency(\"rlc.bcch\", proto_fp);\r\n    mac_fdd_rach_handle       = find_dissector_add_dependency(\"mac.fdd.rach\", proto_fp);\r\n    mac_fdd_fach_handle       = find_dissector_add_dependency(\"mac.fdd.fach\", proto_fp);\r\n    mac_fdd_pch_handle        = find_dissector_add_dependency(\"mac.fdd.pch\", proto_fp);\r\n    mac_fdd_dch_handle        = find_dissector_add_dependency(\"mac.fdd.dch\", proto_fp);\r\n    mac_fdd_edch_handle       = find_dissector_add_dependency(\"mac.fdd.edch\", proto_fp);\r\n    mac_fdd_edch_type2_handle = find_dissector_add_dependency(\"mac.fdd.edch.type2\", proto_fp);\r\n    mac_fdd_hsdsch_handle     = find_dissector_add_dependency(\"mac.fdd.hsdsch\", proto_fp);\r\n\r\n    heur_dissector_add(\"udp\", heur_dissect_fp, \"FP over UDP\", \"fp_udp\", proto_fp, HEURISTIC_DISABLE);\r\n    heur_dissector_add(\"fp_mux\", heur_dissect_fp, \"FP over FP Mux\", \"fp_fp_mux\", proto_fp, HEURISTIC_ENABLE);\r\n\r\n    dissector_add_uint(\"atm.aal2.type\", TRAF_UMTS_FP, fp_aal2_handle);\r\n}", ".issect_fp": "static int\r\ndissect_fp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)\r\n{\r\n    return dissect_fp_common(tvb, pinfo, tree, NULL);\r\n}", ".issect_fp_aal2": "static int\r\ndissect_fp_aal2(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)\r\n{\r\n    return dissect_fp_common(tvb, pinfo, tree, data);\r\n}", ".roto_register_fp": "void proto_register_fp(void)\r\n{\r\n    static hf_register_info hf[] =\r\n        {\r\n            { &hf_fp_release,\r\n              { \"Release\",\r\n                \"fp.release\", FT_NONE, BASE_NONE, NULL, 0x0,\r\n                \"Release information\", HFILL\r\n              }\r\n            },\r\n            { &hf_fp_release_version,\r\n              { \"Release Version\",\r\n                \"fp.release.version\", FT_UINT8, BASE_DEC, NULL, 0x0,\r\n                \"3GPP Release number\", HFILL\r\n              }\r\n            },\r\n            { &hf_fp_release_year,\r\n              { \"Release year\",\r\n                \"fp.release.year\", FT_UINT16, BASE_DEC, NULL, 0x0,\r\n                NULL, HFILL\r\n              }\r\n            },\r\n            { &hf_fp_release_month,\r\n              { \"Release month\",\r\n                \"fp.release.month\", FT_UINT8, BASE_DEC, NULL, 0x0,\r\n                NULL, HFILL\r\n              }\r\n            },\r\n            { &hf_fp_channel_type,\r\n              { \"Channel Type\",\r\n                \"fp.channel-type\", FT_UINT8, BASE_HEX, VALS(channel_type_vals), 0x0,\r\n                NULL, HFILL\r\n              }\r\n            },\r\n            { &hf_fp_division,\r\n              { \"Division\",\r\n                \"fp.division\", FT_UINT8, BASE_HEX, VALS(division_vals), 0x0,\r\n                \"Radio division type\", HFILL\r\n              }\r\n            },\r\n            { &hf_fp_direction,\r\n              { \"Direction\",\r\n                \"fp.direction\", FT_BOOLEAN, BASE_NONE, TFS(&tfs_uplink_downlink), 0x0,\r\n                \"Link direction\", HFILL\r\n              }\r\n            },\r\n            { &hf_fp_ddi_config,\r\n              { \"DDI Config\",\r\n                \"fp.ddi-config\", FT_STRING, BASE_NONE, NULL, 0x0,\r\n                \"DDI Config (for E-DCH)\", HFILL\r\n              }\r\n            },\r\n            { &hf_fp_ddi_config_ddi,\r\n              { \"DDI\",\r\n                \"fp.ddi-config.ddi\", FT_UINT8, BASE_DEC, NULL, 0x0,\r\n                NULL, HFILL\r\n              }\r\n            },\r\n            { &hf_fp_ddi_config_macd_pdu_size,\r\n              { \"MACd PDU Size\",\r\n                \"fp.ddi-config.macd-pdu-size\", FT_UINT16, BASE_DEC, NULL, 0x0,\r\n                NULL, HFILL\r\n              }\r\n            },\r\n\r\n\r\n            { &hf_fp_header_crc,\r\n              { \"Header CRC\",\r\n                \"fp.header-crc\", FT_UINT8, BASE_HEX, NULL, 0xfe,\r\n                NULL, HFILL\r\n              }\r\n            },\r\n            { &hf_fp_ft,\r\n              { \"Frame Type\",\r\n                \"fp.ft\", FT_UINT8, BASE_HEX, VALS(frame_type_vals), 0x01,\r\n                NULL, HFILL\r\n              }\r\n            },\r\n            { &hf_fp_cfn,\r\n              { \"CFN\",\r\n                \"fp.cfn\", FT_UINT8, BASE_DEC, NULL, 0x0,\r\n                \"Connection Frame Number\", HFILL\r\n              }\r\n            },\r\n            { &hf_fp_pch_cfn,\r\n              { \"CFN (PCH)\",\r\n                \"fp.pch.cfn\", FT_UINT16, BASE_DEC, NULL, 0xfff0,\r\n                \"PCH Connection Frame Number\", HFILL\r\n              }\r\n            },\r\n            { &hf_fp_pch_toa,\r\n              { \"ToA (PCH)\",\r\n                \"fp.pch.toa\", FT_INT24, BASE_DEC, NULL, 0x0,\r\n                \"PCH Time of Arrival\", HFILL\r\n              }\r\n            },\r\n            { &hf_fp_cfn_control,\r\n              { \"CFN control\",\r\n                \"fp.cfn-control\", FT_UINT8, BASE_DEC, NULL, 0x0,\r\n                \"Connection Frame Number Control\", HFILL\r\n              }\r\n            },\r\n            { &hf_fp_toa,\r\n              { \"ToA\",\r\n                \"fp.toa\", FT_INT16, BASE_DEC, NULL, 0x0,\r\n                \"Time of arrival (units are 125 microseconds)\", HFILL\r\n              }\r\n            },\r\n            { &hf_fp_tb,\r\n              { \"TB\",\r\n                \"fp.tb\", FT_BYTES, BASE_NONE, NULL, 0x0,\r\n                \"Transport Block\", HFILL\r\n              }\r\n            },\r\n            { &hf_fp_chan_zero_tbs,\r\n              { \"No TBs for channel\",\r\n                \"fp.channel-with-zero-tbs\", FT_UINT32, BASE_DEC, NULL, 0x0,\r\n                \"Channel with 0 TBs\", HFILL\r\n              }\r\n            },\r\n            { &hf_fp_tfi,\r\n              { \"TFI\",\r\n                \"fp.tfi\", FT_UINT8, BASE_DEC, NULL, 0x0,\r\n                \"Transport Format Indicator\", HFILL\r\n              }\r\n            },\r\n            { &hf_fp_usch_tfi,\r\n              { \"TFI\",\r\n                \"fp.usch.tfi\", FT_UINT8, BASE_DEC, NULL, 0x1f,\r\n                \"USCH Transport Format Indicator\", HFILL\r\n              }\r\n            },\r\n            { &hf_fp_cpch_tfi,\r\n              { \"TFI\",\r\n                \"fp.cpch.tfi\", FT_UINT8, BASE_DEC, NULL, 0x1f,\r\n                \"CPCH Transport Format Indicator\", HFILL\r\n              }\r\n            },\r\n            { &hf_fp_propagation_delay,\r\n              { \"Propagation Delay\",\r\n                \"fp.propagation-delay\", FT_UINT8, BASE_DEC, NULL, 0x0,\r\n                NULL, HFILL\r\n              }\r\n            },\r\n            { &hf_fp_dch_control_frame_type,\r\n              { \"Control Frame Type\",\r\n                \"fp.dch.control.frame-type\", FT_UINT8, BASE_HEX, VALS(dch_control_frame_type_vals), 0x0,\r\n                \"DCH Control Frame Type\", HFILL\r\n              }\r\n            },\r\n            { &hf_fp_dch_rx_timing_deviation,\r\n              { \"Rx Timing Deviation\",\r\n                \"fp.dch.control.rx-timing-deviation\", FT_UINT8, BASE_DEC, 0, 0x0,\r\n                \"DCH Rx Timing Deviation\", HFILL\r\n              }\r\n            },\r\n            { &hf_fp_quality_estimate,\r\n              { \"Quality Estimate\",\r\n                \"fp.dch.quality-estimate\", FT_UINT8, BASE_DEC, 0, 0x0,\r\n                NULL, HFILL\r\n              }\r\n            },\r\n            { &hf_fp_payload_crc,\r\n              { \"Payload CRC\",\r\n                \"fp.payload-crc\", FT_UINT16, BASE_HEX, 0, 0x0,\r\n                NULL, HFILL\r\n              }\r\n            },\r\n            { &hf_fp_payload_crc_status,\r\n              { \"Payload CRC Status\",\r\n                \"fp.payload-crc.status\", FT_UINT8, BASE_NONE, VALS(proto_checksum_vals), 0x0,\r\n                NULL, HFILL\r\n              }\r\n            },\r\n            { &hf_fp_common_control_frame_type,\r\n              { \"Control Frame Type\",\r\n                \"fp.common.control.frame-type\", FT_UINT8, BASE_HEX, VALS(common_control_frame_type_vals), 0x0,\r\n                \"Common Control Frame Type\", HFILL\r\n              }\r\n            },\r\n            { &hf_fp_crci[0],\r\n              { \"CRCI\",\r\n                \"fp.crci\", FT_UINT8, BASE_HEX, VALS(crci_vals), 0x80,\r\n                \"CRC correctness indicator\", HFILL\r\n              }\r\n            },\r\n            { &hf_fp_crci[1],\r\n              { \"CRCI\",\r\n                \"fp.crci\", FT_UINT8, BASE_HEX, VALS(crci_vals), 0x40,\r\n                \"CRC correctness indicator\", HFILL\r\n              }\r\n            },\r\n            { &hf_fp_crci[2],\r\n              { \"CRCI\",\r\n                \"fp.crci\", FT_UINT8, BASE_HEX, VALS(crci_vals), 0x20,\r\n                \"CRC correctness indicator\", HFILL\r\n              }\r\n            },\r\n            { &hf_fp_crci[3],\r\n              { \"CRCI\",\r\n                \"fp.crci\", FT_UINT8, BASE_HEX, VALS(crci_vals), 0x10,\r\n                \"CRC correctness indicator\", HFILL\r\n              }\r\n            },\r\n            { &hf_fp_crci[4],\r\n              { \"CRCI\",\r\n                \"fp.crci\", FT_UINT8, BASE_HEX, VALS(crci_vals), 0x08,\r\n                \"CRC correctness indicator\", HFILL\r\n              }\r\n            },\r\n            { &hf_fp_crci[5],\r\n              { \"CRCI\",\r\n                \"fp.crci\", FT_UINT8, BASE_HEX, VALS(crci_vals), 0x04,\r\n                \"CRC correctness indicator\", HFILL\r\n              }\r\n            },\r\n            { &hf_fp_crci[6],\r\n              { \"CRCI\",\r\n                \"fp.crci\", FT_UINT8, BASE_HEX, VALS(crci_vals), 0x02,\r\n                \"CRC correctness indicator\", HFILL\r\n              }\r\n            },\r\n            { &hf_fp_crci[7],\r\n              { \"CRCI\",\r\n                \"fp.crci\", FT_UINT8, BASE_HEX, VALS(crci_vals), 0x01,\r\n                \"CRC correctness indicator\", HFILL\r\n              }\r\n            },\r\n            { &hf_fp_received_sync_ul_timing_deviation,\r\n              { \"Received SYNC UL Timing Deviation\",\r\n                \"fp.rx-sync-ul-timing-deviation\", FT_UINT8, BASE_DEC, 0, 0x0,\r\n                NULL, HFILL\r\n              }\r\n            },\r\n            { &hf_fp_pch_pi,\r\n              { \"Paging Indication\",\r\n                \"fp.pch.pi\", FT_UINT8, BASE_DEC, VALS(paging_indication_vals), 0x01,\r\n                \"Indicates if the PI Bitmap is present\", HFILL\r\n              }\r\n            },\r\n            { &hf_fp_pch_tfi,\r\n              { \"TFI\",\r\n                \"fp.pch.tfi\", FT_UINT8, BASE_DEC, 0, 0x1f,\r\n                \"PCH Transport Format Indicator\", HFILL\r\n              }\r\n            },\r\n            { &hf_fp_fach_tfi,\r\n              { \"TFI\",\r\n                \"fp.fach.tfi\", FT_UINT8, BASE_DEC, 0, 0x1f,\r\n                \"FACH Transport Format Indicator\", HFILL\r\n              }\r\n            },\r\n            { &hf_fp_transmit_power_level,\r\n              { \"Transmit Power Level\",\r\n                \"fp.transmit-power-level\", FT_FLOAT, BASE_NONE, 0, 0x0,\r\n                \"Transmit Power Level (dB)\", HFILL\r\n              }\r\n            },\r\n            { &hf_fp_pdsch_set_id,\r\n              { \"PDSCH Set Id\",\r\n                \"fp.pdsch-set-id\", FT_UINT8, BASE_DEC, 0, 0x0,\r\n                \"A pointer to the PDSCH Set which shall be used to transmit\", HFILL\r\n              }\r\n            },\r\n            { &hf_fp_paging_indication_bitmap,\r\n              { \"Paging Indications bitmap\",\r\n                \"fp.pch.pi-bitmap\", FT_BYTES , BASE_NONE, NULL, 0x0,\r\n                \"Paging Indication bitmap\", HFILL\r\n              }\r\n            },\r\n            { &hf_fp_relevant_paging_indication_bitmap,\r\n              { \"Relevant Paging Indications bitmap\",\r\n                \"fp.pch.relevant-pi-bitmap\", FT_BYTES , BASE_NONE, NULL, 0x0,\r\n                \"The Paging Indication bitmap used to inform users about the current frame\", HFILL\r\n              }\r\n            },\r\n            { &hf_fp_rx_timing_deviation,\r\n              { \"Rx Timing Deviation\",\r\n                \"fp.common.control.rx-timing-deviation\", FT_UINT8, BASE_DEC, 0, 0x0,\r\n                \"Common Rx Timing Deviation\", HFILL\r\n              }\r\n            },\r\n            { &hf_fp_dch_e_rucch_flag,\r\n              { \"E-RUCCH Flag\",\r\n                \"fp.common.control.e-rucch-flag\", FT_UINT8, BASE_DEC, VALS(e_rucch_flag_vals), 0x0,\r\n                NULL, HFILL\r\n              }\r\n            },\r\n            { &hf_fp_edch_header_crc,\r\n              { \"E-DCH Header CRC\",\r\n                \"fp.edch.header-crc\", FT_UINT16, BASE_HEX, 0, 0,\r\n                NULL, HFILL\r\n              }\r\n            },\r\n            { &hf_fp_edch_fsn,\r\n              { \"FSN\",\r\n                \"fp.edch.fsn\", FT_UINT8, BASE_DEC, 0, 0x0f,\r\n                \"E-DCH Frame Sequence Number\", HFILL\r\n              }\r\n            },\r\n            { &hf_fp_edch_number_of_subframes,\r\n              { \"No of subframes\",\r\n                \"fp.edch.no-of-subframes\", FT_UINT8, BASE_DEC, 0, 0x0f,\r\n                \"E-DCH Number of subframes\", HFILL\r\n              }\r\n            },\r\n            { &hf_fp_edch_harq_retransmissions,\r\n              { \"No of HARQ Retransmissions\",\r\n                \"fp.edch.no-of-harq-retransmissions\", FT_UINT8, BASE_DEC, 0, 0x78,\r\n                \"E-DCH Number of HARQ retransmissions\", HFILL\r\n              }\r\n            },\r\n            { &hf_fp_edch_subframe_number,\r\n              { \"Subframe number\",\r\n                \"fp.edch.subframe-number\", FT_UINT8, BASE_DEC, 0, 0x0,\r\n                \"E-DCH Subframe number\", HFILL\r\n              }\r\n            },\r\n            { &hf_fp_edch_number_of_mac_es_pdus,\r\n              { \"Number of Mac-es PDUs\",\r\n                \"fp.edch.number-of-mac-es-pdus\", FT_UINT8, BASE_DEC, 0, 0xf0,\r\n                NULL, HFILL\r\n              }\r\n            },\r\n            { &hf_fp_edch_ddi,\r\n              { \"DDI\",\r\n                \"fp.edch.ddi\", FT_UINT8, BASE_DEC, 0, 0x0,\r\n                \"E-DCH Data Description Indicator\", HFILL\r\n              }\r\n            },\r\n            { &hf_fp_edch_subframe,\r\n              { \"Subframe\",\r\n                \"fp.edch.subframe\", FT_STRING, BASE_NONE, NULL, 0x0,\r\n                \"EDCH Subframe\", HFILL\r\n              }\r\n            },\r\n            { &hf_fp_edch_subframe_header,\r\n              { \"Subframe header\",\r\n                \"fp.edch.subframe-header\", FT_STRING, BASE_NONE, NULL, 0x0,\r\n                \"EDCH Subframe header\", HFILL\r\n              }\r\n            },\r\n            { &hf_fp_edch_number_of_mac_d_pdus,\r\n              { \"Number of Mac-d PDUs\",\r\n                \"fp.edch.number-of-mac-d-pdus\", FT_UINT8, BASE_DEC, 0, 0x0,\r\n                NULL, HFILL\r\n              }\r\n            },\r\n            { &hf_fp_edch_pdu_padding,\r\n              { \"Padding\",\r\n                \"fp.edch-data-padding\", FT_UINT8, BASE_DEC, 0, 0xc0,\r\n                \"E-DCH padding before PDU\", HFILL\r\n              }\r\n            },\r\n            { &hf_fp_edch_tsn,\r\n              { \"TSN\",\r\n                \"fp.edch-tsn\", FT_UINT8, BASE_DEC, 0, 0x3f,\r\n                \"E-DCH Transmission Sequence Number\", HFILL\r\n              }\r\n            },\r\n            { &hf_fp_edch_mac_es_pdu,\r\n              { \"MAC-es PDU\",\r\n                \"fp.edch.mac-es-pdu\", FT_NONE, BASE_NONE, NULL, 0x0,\r\n                NULL, HFILL\r\n              }\r\n            },\r\n\r\n            { &hf_fp_edch_user_buffer_size,\r\n              { \"User Buffer Size\",\r\n                \"fp.edch.user-buffer-size\", FT_UINT24, BASE_DEC, NULL, 0x0,\r\n                NULL, HFILL\r\n              }\r\n            },\r\n            { &hf_fp_edch_no_macid_sdus,\r\n              { \"No of MAC-is SDUs\",\r\n                \"fp.edch.no-macis-sdus\", FT_UINT16, BASE_DEC, NULL, 0x0,\r\n                NULL, HFILL\r\n              }\r\n            },\r\n            { &hf_fp_edch_number_of_mac_is_pdus,\r\n              { \"Number of Mac-is PDUs\",\r\n                \"fp.edch.number-of-mac-is-pdus\", FT_UINT8, BASE_DEC, 0, 0x0,\r\n                NULL, HFILL\r\n              }\r\n            },\r\n            { &hf_fp_edch_mac_is_pdu,\r\n              { \"Mac-is PDU\",\r\n                \"fp.edch.mac-is-pdu\", FT_BYTES, BASE_NONE, 0, 0x0,\r\n                NULL, HFILL\r\n              }\r\n            },\r\n            { &hf_fp_edch_e_rnti,\r\n              { \"E-RNTI\",\r\n                \"fp.edch.e-rnti\", FT_UINT16, BASE_DEC, 0, 0x0,\r\n                NULL, HFILL\r\n              }\r\n            },\r\n\r\n            { &hf_fp_edch_macis_descriptors,\r\n              { \"MAC-is Descriptors\",\r\n                \"fp.edch.mac-is.descriptors\", FT_STRING, BASE_NONE, NULL, 0x0,\r\n                NULL, HFILL\r\n              }\r\n            },\r\n            { &hf_fp_edch_macis_lchid,\r\n              { \"LCH-ID\",\r\n                \"fp.edch.mac-is.lchid\", FT_UINT8, BASE_HEX, VALS(lchid_vals), 0xf0,\r\n                NULL, HFILL\r\n              }\r\n            },\r\n            { &hf_fp_edch_macis_length,\r\n              { \"Length\",\r\n                \"fp.edch.mac-is.length\", FT_UINT16, BASE_DEC, 0, 0x0ffe,\r\n                NULL, HFILL\r\n              }\r\n            },\r\n            { &hf_fp_edch_macis_flag,\r\n              { \"Flag\",\r\n                \"fp.edch.mac-is.flag\", FT_UINT8, BASE_HEX, 0, 0x01,\r\n                \"Indicates if another entry follows\", HFILL\r\n              }\r\n            },\r\n            { &hf_fp_edch_entity,\r\n              { \"E-DCH Entity\",\r\n                \"fp.edch.entity\", FT_UINT8, BASE_DEC, VALS(edch_mac_entity_vals), 0x0,\r\n                \"Type of MAC entity for this E-DCH channel\", HFILL\r\n              }\r\n            },\r\n            { &hf_fp_frame_seq_nr,\r\n              { \"Frame Seq Nr\",\r\n                \"fp.frame-seq-nr\", FT_UINT8, BASE_DEC, 0, 0xf0,\r\n                \"Frame Sequence Number\", HFILL\r\n              }\r\n            },\r\n            { &hf_fp_hsdsch_pdu_block_header,\r\n              { \"PDU block header\",\r\n                \"fp.hsdsch.pdu-block-header\", FT_STRING, BASE_NONE, NULL, 0x0,\r\n                \"HS-DSCH type 2 PDU block header\", HFILL\r\n              }\r\n            },\r\n#if 0\r\n            { &hf_fp_hsdsch_pdu_block,\r\n              { \"PDU block\",\r\n                \"fp.hsdsch.pdu-block\", FT_STRING, BASE_NONE, NULL, 0x0,\r\n                \"HS-DSCH type 2 PDU block data\", HFILL\r\n              }\r\n            },\r\n#endif\r\n            { &hf_fp_flush,\r\n              { \"Flush\",\r\n                \"fp.flush\", FT_UINT8, BASE_DEC, 0, 0x04,\r\n                \"Whether all PDUs for this priority queue should be removed\", HFILL\r\n              }\r\n            },\r\n            { &hf_fp_fsn_drt_reset,\r\n              { \"FSN-DRT reset\",\r\n                \"fp.fsn-drt-reset\", FT_UINT8, BASE_DEC, 0, 0x02,\r\n                \"FSN/DRT Reset Flag\", HFILL\r\n              }\r\n            },\r\n            { &hf_fp_drt_indicator,\r\n              { \"DRT Indicator\",\r\n                \"fp.drt-indicator\", FT_UINT8, BASE_DEC, 0, 0x01,\r\n                NULL, HFILL\r\n              }\r\n            },\r\n            { &hf_fp_fach_indicator,\r\n              { \"FACH Indicator\",\r\n                \"fp.fach-indicator\", FT_UINT8, BASE_DEC, 0, 0x80,\r\n                NULL, HFILL\r\n              }\r\n            },\r\n            { &hf_fp_total_pdu_blocks,\r\n              { \"PDU Blocks\",\r\n                \"fp.pdu_blocks\", FT_UINT8, BASE_DEC, 0, 0xf8,\r\n                \"Total number of PDU blocks\", HFILL\r\n              }\r\n            },\r\n            { &hf_fp_drt,\r\n              { \"DelayRefTime\",\r\n                \"fp.drt\", FT_UINT16, BASE_DEC, 0, 0x0,\r\n                NULL, HFILL\r\n              }\r\n            },\r\n            { &hf_fp_hrnti,\r\n              { \"HRNTI\",\r\n                \"fp.hrnti\", FT_UINT16, BASE_DEC, 0, 0x0,\r\n                NULL, HFILL\r\n              }\r\n            },\r\n            { &hf_fp_rach_measurement_result,\r\n              { \"RACH Measurement Result\",\r\n                \"fp.rach-measurement-result\", FT_UINT16, BASE_DEC, 0, 0x0,\r\n                NULL, HFILL\r\n              }\r\n            },\r\n            { &hf_fp_lchid,\r\n              { \"Logical Channel ID\",\r\n                \"fp.lchid\", FT_UINT8, BASE_DEC, NULL, 0x0,\r\n                NULL, HFILL\r\n              }\r\n            },\r\n            { &hf_fp_pdu_length_in_block,\r\n              { \"PDU length in block\",\r\n                \"fp.pdu-length-in-block\", FT_UINT8, BASE_DEC, 0, 0x0,\r\n                \"Length of each PDU in this block in bytes\", HFILL\r\n              }\r\n            },\r\n            { &hf_fp_pdus_in_block,\r\n              { \"PDUs in block\",\r\n                \"fp.no-pdus-in-block\", FT_UINT8, BASE_DEC, 0, 0x0,\r\n                \"Number of PDUs in block\", HFILL\r\n              }\r\n            },\r\n            { &hf_fp_cmch_pi,\r\n              { \"CmCH-PI\",\r\n                \"fp.cmch-pi\", FT_UINT8, BASE_DEC, 0, 0x0f,\r\n                \"Common Transport Channel Priority Indicator\", HFILL\r\n              }\r\n            },\r\n            { &hf_fp_user_buffer_size,\r\n              { \"User buffer size\",\r\n                \"fp.user-buffer-size\", FT_UINT16, BASE_DEC, 0, 0x0,\r\n                \"User buffer size in octets\", HFILL\r\n              }\r\n            },\r\n            { &hf_fp_hsdsch_credits,\r\n              { \"HS-DSCH Credits\",\r\n                \"fp.hsdsch-credits\", FT_UINT16, BASE_DEC, 0, 0x0,\r\n                NULL, HFILL\r\n              }\r\n            },\r\n            { &hf_fp_hsdsch_max_macd_pdu_len,\r\n              { \"Max MAC-d PDU Length\",\r\n                \"fp.hsdsch.max-macd-pdu-len\", FT_UINT16, BASE_DEC, 0, 0xfff8,\r\n                \"Maximum MAC-d PDU Length in bits\", HFILL\r\n              }\r\n            },\r\n            { &hf_fp_hsdsch_max_macdc_pdu_len,\r\n              { \"Max MAC-d/c PDU Length\",\r\n                \"fp.hsdsch.max-macdc-pdu-len\", FT_UINT16, BASE_DEC, 0, 0x07ff,\r\n                \"Maximum MAC-d/c PDU Length in bits\", HFILL\r\n              }\r\n            },\r\n            { &hf_fp_hsdsch_interval,\r\n              { \"HS-DSCH Interval in milliseconds\",\r\n                \"fp.hsdsch-interval\", FT_UINT8, BASE_DEC, 0, 0x0,\r\n                NULL, HFILL\r\n              }\r\n            },\r\n            { &hf_fp_hsdsch_calculated_rate,\r\n              { \"Calculated rate allocation (bps)\",\r\n                \"fp.hsdsch-calculated-rate\", FT_UINT32, BASE_DEC, 0, 0x0,\r\n                \"Calculated rate RNC is allowed to send in bps\", HFILL\r\n              }\r\n            },\r\n            { &hf_fp_hsdsch_unlimited_rate,\r\n              { \"Unlimited rate\",\r\n                \"fp.hsdsch-unlimited-rate\", FT_NONE, BASE_NONE, 0, 0x0,\r\n                \"No restriction on rate at which date may be sent\", HFILL\r\n              }\r\n            },\r\n            { &hf_fp_hsdsch_repetition_period,\r\n              { \"HS-DSCH Repetition Period\",\r\n                \"fp.hsdsch-repetition-period\", FT_UINT8, BASE_DEC, 0, 0x0,\r\n                \"HS-DSCH Repetition Period in milliseconds\", HFILL\r\n              }\r\n            },\r\n            { &hf_fp_hsdsch_data_padding,\r\n              { \"Padding\",\r\n                \"fp.hsdsch-data-padding\", FT_UINT8, BASE_DEC, 0, 0xf0,\r\n                \"HS-DSCH Repetition Period in milliseconds\", HFILL\r\n              }\r\n            },\r\n            { &hf_fp_hsdsch_new_ie_flags,\r\n              { \"New IEs flags\",\r\n                \"fp.hsdsch.new-ie-flags\", FT_STRING, BASE_NONE, 0, 0x0,\r\n                NULL, HFILL\r\n              }\r\n            },\r\n            { &hf_fp_hsdsch_new_ie_flag[0],\r\n              { \"DRT IE present\",\r\n                \"fp.hsdsch.new-ie-flag\", FT_UINT8, BASE_DEC, 0, 0x80,\r\n                NULL, HFILL\r\n              }\r\n            },\r\n            { &hf_fp_hsdsch_new_ie_flag[1],\r\n              { \"New IE present\",\r\n                \"fp.hsdsch.new-ie-flag\", FT_UINT8, BASE_DEC, 0, 0x40,\r\n                NULL, HFILL\r\n              }\r\n            },\r\n            { &hf_fp_hsdsch_new_ie_flag[2],\r\n              { \"New IE present\",\r\n                \"fp.hsdsch.new-ie-flag\", FT_UINT8, BASE_DEC, 0, 0x20,\r\n                NULL, HFILL\r\n              }\r\n            },\r\n            { &hf_fp_hsdsch_new_ie_flag[3],\r\n              { \"New IE present\",\r\n                \"fp.hsdsch.new-ie-flag\", FT_UINT8, BASE_DEC, 0, 0x10,\r\n                NULL, HFILL\r\n              }\r\n            },\r\n            { &hf_fp_hsdsch_new_ie_flag[4],\r\n              { \"New IE present\",\r\n                \"fp.hsdsch.new-ie-flag\", FT_UINT8, BASE_DEC, 0, 0x08,\r\n                NULL, HFILL\r\n              }\r\n            },\r\n            { &hf_fp_hsdsch_new_ie_flag[5],\r\n              { \"New IE present\",\r\n                \"fp.hsdsch.new-ie-flag\", FT_UINT8, BASE_DEC, 0, 0x04,\r\n                NULL, HFILL\r\n              }\r\n            },\r\n            { &hf_fp_hsdsch_new_ie_flag[6],\r\n              { \"HS-DSCH physical layer category present\",\r\n                \"fp.hsdsch.new-ie-flag\", FT_UINT8, BASE_DEC, 0, 0x02,\r\n                NULL, HFILL\r\n              }\r\n            },\r\n            { &hf_fp_hsdsch_new_ie_flag[7],\r\n              { \"Another new IE flags byte\",\r\n                \"fp.hsdsch.new-ie-flags-byte\", FT_UINT8, BASE_DEC, 0, 0x01,\r\n                \"Another new IE flagsbyte\", HFILL\r\n              }\r\n            },\r\n            { &hf_fp_hsdsch_drt,\r\n              { \"DRT\",\r\n                \"fp.hsdsch.drt\", FT_UINT16, BASE_DEC, 0, 0x0,\r\n                \"Delay Reference Time\", HFILL\r\n              }\r\n            },\r\n            { &hf_fp_hsdsch_entity,\r\n              { \"HS-DSCH Entity\",\r\n                \"fp.hsdsch.entity\", FT_UINT8, BASE_DEC, VALS(hsdshc_mac_entity_vals), 0x0,\r\n                \"Type of MAC entity for this HS-DSCH channel\", HFILL\r\n              }\r\n            },\r\n            { &hf_fp_timing_advance,\r\n              { \"Timing advance\",\r\n                \"fp.timing-advance\", FT_UINT8, BASE_DEC, 0, 0x3f,\r\n                \"Timing advance in chips\", HFILL\r\n              }\r\n            },\r\n            { &hf_fp_num_of_pdu,\r\n              { \"Number of PDUs\",\r\n                \"fp.hsdsch.num-of-pdu\", FT_UINT8, BASE_DEC, 0, 0x0,\r\n                \"Number of PDUs in the payload\", HFILL\r\n              }\r\n            },\r\n            { &hf_fp_mac_d_pdu_len,\r\n              { \"MAC-d PDU Length\",\r\n                \"fp.hsdsch.mac-d-pdu-len\", FT_UINT16, BASE_DEC, 0, 0xfff8,\r\n                \"MAC-d PDU Length in bits\", HFILL\r\n              }\r\n            },\r\n            { &hf_fp_mac_d_pdu,\r\n              { \"MAC-d PDU\",\r\n                \"fp.mac-d-pdu\", FT_BYTES, BASE_NONE, NULL, 0x0,\r\n                NULL, HFILL\r\n              }\r\n            },\r\n            { &hf_fp_data,\r\n              { \"Data\",\r\n                \"fp.data\", FT_BYTES, BASE_NONE, NULL, 0x0,\r\n                NULL, HFILL\r\n              }\r\n            },\r\n            { &hf_fp_crcis,\r\n              { \"CRCIs\",\r\n                \"fp.crcis\", FT_BYTES, BASE_NONE, NULL, 0x0,\r\n                \"CRC Indicators for uplink TBs\", HFILL\r\n              }\r\n            },\r\n            { &hf_fp_t1,\r\n              { \"T1\",\r\n                \"fp.t1\", FT_FLOAT, BASE_NONE, NULL, 0x0,\r\n                \"RNC frame number indicating time it sends frame\", HFILL\r\n              }\r\n            },\r\n            { &hf_fp_t2,\r\n              { \"T2\",\r\n                \"fp.t2\", FT_FLOAT, BASE_NONE, NULL, 0x0,\r\n                \"NodeB frame number indicating time it received DL Sync\", HFILL\r\n              }\r\n            },\r\n            { &hf_fp_t3,\r\n              { \"T3\",\r\n                \"fp.t3\", FT_FLOAT, BASE_NONE, NULL, 0x0,\r\n                \"NodeB frame number indicating time it sends frame\", HFILL\r\n              }\r\n            },\r\n            { &hf_fp_ul_sir_target,\r\n              { \"UL_SIR_TARGET\",\r\n                \"fp.ul-sir-target\", FT_FLOAT, BASE_NONE, 0, 0x0,\r\n                \"Value (in dB) of the SIR target to be used by the UL inner loop power control\", HFILL\r\n              }\r\n            },\r\n            { &hf_fp_pusch_set_id,\r\n              { \"PUSCH Set Id\",\r\n                \"fp.pusch-set-id\", FT_UINT8, BASE_DEC, NULL, 0x0,\r\n                \"Identifies PUSCH Set from those configured in NodeB\", HFILL\r\n              }\r\n            },\r\n            { &hf_fp_activation_cfn,\r\n              { \"Activation CFN\",\r\n                \"fp.activation-cfn\", FT_UINT8, BASE_DEC, NULL, 0x0,\r\n                \"Activation Connection Frame Number\", HFILL\r\n              }\r\n            },\r\n            { &hf_fp_duration,\r\n              { \"Duration (ms)\",\r\n                \"fp.pusch-duration\", FT_UINT8, BASE_DEC, NULL, 0x0,\r\n                \"Duration of the activation period of the PUSCH Set\", HFILL\r\n              }\r\n            },\r\n            { &hf_fp_power_offset,\r\n              { \"Power offset\",\r\n                \"fp.power-offset\", FT_FLOAT, BASE_NONE, NULL, 0x0,\r\n                \"Power offset (in dB)\", HFILL\r\n              }\r\n            },\r\n            { &hf_fp_code_number,\r\n              { \"Code number\",\r\n                \"fp.code-number\", FT_UINT8, BASE_DEC, NULL, 0x0,\r\n                NULL, HFILL\r\n              }\r\n            },\r\n            { &hf_fp_spreading_factor,\r\n              { \"Spreading factor\",\r\n                \"fp.spreading-factor\", FT_UINT8, BASE_DEC, VALS(spreading_factor_vals), 0xf0,\r\n                NULL, HFILL\r\n              }\r\n            },\r\n            { &hf_fp_mc_info,\r\n              { \"MC info\",\r\n                \"fp.mc-info\", FT_UINT8, BASE_DEC, NULL, 0x0e,\r\n                NULL, HFILL\r\n              }\r\n            },\r\n            { &hf_fp_rach_new_ie_flags,\r\n              { \"New IEs flags\",\r\n                \"fp.rach.new-ie-flags\", FT_STRING, BASE_NONE, 0, 0x0,\r\n                NULL, HFILL\r\n              }\r\n            },\r\n            { &hf_fp_rach_new_ie_flag_unused[0],\r\n              { \"New IE present\",\r\n                \"fp.rach.new-ie-flag\", FT_UINT8, BASE_DEC, 0, 0x80,\r\n                NULL, HFILL\r\n              }\r\n            },\r\n            { &hf_fp_rach_new_ie_flag_unused[1],\r\n              { \"New IE present\",\r\n                \"fp.rach.new-ie-flag\", FT_UINT8, BASE_DEC, 0, 0x40,\r\n                NULL, HFILL\r\n              }\r\n            },\r\n            { &hf_fp_rach_new_ie_flag_unused[2],\r\n              { \"New IE present\",\r\n                \"fp.rach.new-ie-flag\", FT_UINT8, BASE_DEC, 0, 0x20,\r\n                \"New IE present (unused)\", HFILL\r\n              }\r\n            },\r\n            { &hf_fp_rach_new_ie_flag_unused[3],\r\n              { \"New IE present\",\r\n                \"fp.rach.new-ie-flag\", FT_UINT8, BASE_DEC, 0, 0x10,\r\n                \"New IE present (unused)\", HFILL\r\n              }\r\n            },\r\n            { &hf_fp_rach_new_ie_flag_unused[4],\r\n              { \"New IE present\",\r\n                \"fp.rach.new-ie-flag\", FT_UINT8, BASE_DEC, 0, 0x08,\r\n                \"New IE present (unused)\", HFILL\r\n              }\r\n            },\r\n            { &hf_fp_rach_new_ie_flag_unused[5],\r\n              { \"New IE present\",\r\n                \"fp.rach.new-ie-flag\", FT_UINT8, BASE_DEC, 0, 0x04,\r\n                \"New IE present (unused)\", HFILL\r\n              }\r\n            },\r\n            { &hf_fp_rach_new_ie_flag_unused[6],\r\n              { \"New IE present\",\r\n                \"fp.rach.new-ie-flag\", FT_UINT8, BASE_DEC, 0, 0x02,\r\n                \"New IE present (unused)\", HFILL\r\n              }\r\n            },\r\n            { &hf_fp_rach_cell_portion_id_present,\r\n              { \"Cell portion ID present\",\r\n                \"fp.rach.cell-portion-id-present\", FT_UINT8, BASE_DEC, 0, 0x01,\r\n                NULL, HFILL\r\n              }\r\n            },\r\n            { &hf_fp_rach_angle_of_arrival_present,\r\n              { \"Angle of arrival present\",\r\n                \"fp.rach.angle-of-arrival-present\", FT_UINT8, BASE_DEC, 0, 0x01,\r\n                NULL, HFILL\r\n              }\r\n            },\r\n            { &hf_fp_rach_ext_propagation_delay_present,\r\n              { \"Ext Propagation Delay Present\",\r\n                \"fp.rach.ext-propagation-delay-present\", FT_UINT8, BASE_DEC, 0, 0x02,\r\n                NULL, HFILL\r\n              }\r\n            },\r\n            { &hf_fp_rach_ext_rx_sync_ul_timing_deviation_present,\r\n              { \"Ext Received Sync UL Timing Deviation present\",\r\n                \"fp.rach.ext-rx-sync-ul-timing-deviation-present\", FT_UINT8, BASE_DEC, 0, 0x02,\r\n                NULL, HFILL\r\n              }\r\n            },\r\n            { &hf_fp_rach_ext_rx_timing_deviation_present,\r\n              { \"Ext Rx Timing Deviation present\",\r\n                \"fp.rach.ext-rx-timing-deviation-present\", FT_UINT8, BASE_DEC, 0, 0x01,\r\n                NULL, HFILL\r\n              }\r\n            },\r\n            { &hf_fp_cell_portion_id,\r\n              { \"Cell Portion ID\",\r\n                \"fp.cell-portion-id\", FT_UINT8, BASE_DEC, NULL, 0x3f,\r\n                NULL, HFILL\r\n              }\r\n            },\r\n            { &hf_fp_ext_propagation_delay,\r\n              { \"Ext Propagation Delay\",\r\n                \"fp.ext-propagation-delay\", FT_UINT16, BASE_DEC, NULL, 0x03ff,\r\n                NULL, HFILL\r\n              }\r\n            },\r\n            { &hf_fp_angle_of_arrival,\r\n              { \"Angle of Arrival\",\r\n                \"fp.angle-of-arrival\", FT_UINT16, BASE_DEC, NULL, 0x03ff,\r\n                NULL, HFILL\r\n              }\r\n            },\r\n            { &hf_fp_ext_received_sync_ul_timing_deviation,\r\n              { \"Ext Received SYNC UL Timing Deviation\",\r\n                \"fp.ext-received-sync-ul-timing-deviation\", FT_UINT16, BASE_DEC, NULL, 0x1fff,\r\n                NULL, HFILL\r\n              }\r\n            },\r\n\r\n\r\n            { &hf_fp_radio_interface_parameter_update_flag[0],\r\n              { \"CFN valid\",\r\n                \"fp.radio-interface-param.cfn-valid\", FT_UINT16, BASE_DEC, 0, 0x0001,\r\n                NULL, HFILL\r\n              }\r\n            },\r\n            { &hf_fp_radio_interface_parameter_update_flag[1],\r\n              { \"TPC PO valid\",\r\n                \"fp.radio-interface-param.tpc-po-valid\", FT_UINT16, BASE_DEC, 0, 0x0002,\r\n                NULL, HFILL\r\n              }\r\n            },\r\n            { &hf_fp_radio_interface_parameter_update_flag[2],\r\n              { \"DPC mode valid\",\r\n                \"fp.radio-interface-param.dpc-mode-valid\", FT_UINT16, BASE_DEC, 0, 0x0004,\r\n                NULL, HFILL\r\n              }\r\n            },\r\n            { &hf_fp_radio_interface_parameter_update_flag[3],\r\n              { \"RL sets indicator valid\",\r\n                \"fp.radio-interface_param.rl-sets-indicator-valid\", FT_UINT16, BASE_DEC, 0, 0x0020,\r\n                NULL, HFILL\r\n              }\r\n            },\r\n            { &hf_fp_radio_interface_parameter_update_flag[4],\r\n              { \"Maximum UE TX Power valid\",\r\n                \"fp.radio-interface-param.max-ue-tx-pow-valid\", FT_UINT16, BASE_DEC, 0, 0x0040,\r\n                \"MAX UE TX POW valid\", HFILL\r\n              }\r\n            },\r\n            { &hf_fp_dpc_mode,\r\n              { \"DPC Mode\",\r\n                \"fp.dpc-mode\", FT_UINT8, BASE_DEC, NULL, 0x20,\r\n                \"DPC Mode to be applied in the uplink\", HFILL\r\n              }\r\n            },\r\n            { &hf_fp_tpc_po,\r\n              { \"TPC Power Offset\",\r\n                \"fp.tpc-po\", FT_FLOAT, BASE_NONE, NULL, 0x0,\r\n                NULL, HFILL\r\n              }\r\n            },\r\n            { &hf_fp_multiple_rl_set_indicator,\r\n              { \"Multiple RL sets indicator\",\r\n                \"fp.multiple-rl-sets-indicator\", FT_UINT8, BASE_DEC, NULL, 0x80,\r\n                NULL, HFILL\r\n              }\r\n            },\r\n            { &hf_fp_max_ue_tx_pow,\r\n              { \"Maximum UE TX Power\",\r\n                \"fp.max-ue-tx-pow\", FT_INT8, BASE_DEC, NULL, 0x0,\r\n                \"Max UE TX POW (dBm)\", HFILL\r\n              }\r\n            },\r\n            { &hf_fp_congestion_status,\r\n              { \"Congestion Status\",\r\n                \"fp.congestion-status\", FT_UINT8, BASE_DEC, VALS(congestion_status_vals), 0x0,\r\n                NULL, HFILL\r\n              }\r\n            },\r\n            { &hf_fp_e_rucch_present,\r\n              { \"E-RUCCH Present\",\r\n                \"fp.erucch-present\", FT_UINT8, BASE_DEC, NULL, 0x0,\r\n                NULL, HFILL\r\n              }\r\n            },\r\n            { &hf_fp_extended_bits_present,\r\n              { \"Extended Bits Present\",\r\n                \"fp.extended-bits-present\", FT_UINT8, BASE_DEC, NULL, 0x0,\r\n                NULL, HFILL\r\n              }\r\n            },\r\n            { &hf_fp_extended_bits,\r\n              { \"Extended Bits\",\r\n                \"fp.extended-bits\", FT_UINT8, BASE_HEX, NULL, 0x0,\r\n                NULL, HFILL\r\n              }\r\n            },\r\n            { &hf_fp_spare_extension,\r\n              { \"Spare Extension\",\r\n                \"fp.spare-extension\", FT_NONE, BASE_NONE, NULL, 0x0,\r\n                NULL, HFILL\r\n              }\r\n            },\r\n            { &hf_fp_ul_setup_frame,\r\n              { \"UL setup frame\",\r\n                \"fp.ul.setup_frame\", FT_FRAMENUM, BASE_NONE, NULL, 0x0,\r\n                NULL, HFILL\r\n              }\r\n            },\r\n            { &hf_fp_dl_setup_frame,\r\n              { \"DL setup frame\",\r\n                \"fp.dl.setup_frame\", FT_FRAMENUM, BASE_NONE, NULL, 0x0,\r\n                NULL, HFILL\r\n              }\r\n            },\r\n            { &hf_fp_relevant_pi_frame,\r\n              { \"Paging Indications frame number\",\r\n                \"fp.pch.relevant-pi-frame\", FT_FRAMENUM, BASE_NONE, NULL, 0x0,\r\n                \"The frame where this Paging Indication bitmap was found\",\r\n                HFILL\r\n              }\r\n            },\r\n            { &hf_fp_hsdsch_physical_layer_category,\r\n              { \"HS-DSCH physical layer category\",\r\n                \"fp.hsdsch.physical_layer_category\", FT_UINT8, BASE_DEC, NULL, 0x0,\r\n                NULL, HFILL\r\n              }\r\n            }\r\n        };\r\n\r\n\r\n    static int *ett[] =\r\n    {\r\n        &ett_fp,\r\n        &ett_fp_data,\r\n        &ett_fp_crcis,\r\n        &ett_fp_ddi_config,\r\n        &ett_fp_edch_subframe_header,\r\n        &ett_fp_edch_subframe,\r\n        &ett_fp_edch_maces,\r\n        &ett_fp_edch_macis_descriptors,\r\n        &ett_fp_hsdsch_new_ie_flags,\r\n        &ett_fp_rach_new_ie_flags,\r\n        &ett_fp_hsdsch_pdu_block_header,\r\n        &ett_fp_pch_relevant_pi,\r\n        &ett_fp_release\r\n    };\r\n\r\n    static ei_register_info ei[] = {\r\n        { &ei_fp_bad_header_checksum, { \"fp.header.bad_checksum\", PI_CHECKSUM, PI_WARN, \"Bad header checksum\", EXPFILL }},\r\n        { &ei_fp_crci_no_subdissector, { \"fp.crci.no_subdissector\", PI_UNDECODED, PI_NOTE, \"Not sent to subdissectors as CRCI is set\", EXPFILL }},\r\n        { &ei_fp_crci_error_bit_set_for_tb, { \"fp.crci.error_bit_set_for_tb\", PI_CHECKSUM, PI_WARN, \"CRCI error bit set for TB\", EXPFILL }},\r\n        { &ei_fp_spare_extension, { \"fp.spare-extension.expert\", PI_UNDECODED, PI_WARN, \"Spare Extension present\", EXPFILL }},\r\n        { &ei_fp_bad_payload_checksum, { \"fp.payload-crc.bad\", PI_CHECKSUM, PI_WARN, \"Bad payload checksum\", EXPFILL }},\r\n        { &ei_fp_stop_hsdpa_transmission, { \"fp.stop_hsdpa_transmission\", PI_RESPONSE_CODE, PI_NOTE, \"Stop HSDPA transmission\", EXPFILL }},\r\n        { &ei_fp_timing_adjustment_reported, { \"fp.timing_adjustment_reported\", PI_SEQUENCE, PI_WARN, \"Timing adjustment reported\", EXPFILL }},\r\n        { &ei_fp_expecting_tdd, { \"fp.expecting_tdd\", PI_MALFORMED, PI_NOTE, \"Error: expecting TDD-384 or TDD-768\", EXPFILL }},\r\n        { &ei_fp_ddi_not_defined, { \"fp.ddi_not_defined\", PI_MALFORMED, PI_ERROR, \"DDI not defined for this UE!\", EXPFILL }},\r\n        { &ei_fp_unable_to_locate_ddi_entry, { \"fp.unable_to_locate_ddi_entry\", PI_UNDECODED, PI_ERROR, \"Unable to locate DDI entry.\", EXPFILL }},\r\n        { &ei_fp_mac_is_sdus_miscount, { \"fp.mac_is_sdus.miscount\", PI_MALFORMED, PI_ERROR, \"Found too many MAC-is SDUs\", EXPFILL }},\r\n        { &ei_fp_e_rnti_t2_edch_frames, { \"fp.e_rnti.t2_edch_frames\", PI_MALFORMED, PI_ERROR, \"E-RNTI not supposed to appear for T2 EDCH frames\", EXPFILL }},\r\n        { &ei_fp_e_rnti_first_entry, { \"fp.e_rnti.first_entry\", PI_MALFORMED, PI_ERROR, \"E-RNTI must be first entry among descriptors\", EXPFILL }},\r\n        { &ei_fp_maybe_srb, { \"fp.maybe_srb\", PI_PROTOCOL, PI_NOTE, \"Found MACd-Flow = 0 and not MUX detected. (This might be SRB)\", EXPFILL }},\r\n        { &ei_fp_transport_channel_type_unknown, { \"fp.transport_channel_type.unknown\", PI_UNDECODED, PI_WARN, \"Unknown transport channel type\", EXPFILL }},\r\n        { &ei_fp_pch_lost_relevant_pi_frame, { \"fp.pch_lost_relevant_pi_frame\", PI_SEQUENCE, PI_WARN, \"Previous PCH frame containing PI bitmap not captured (common at capture start)\", EXPFILL }},\r\n        { &ei_fp_hsdsch_entity_not_specified, { \"fp.hsdsch_entity_not_specified\", PI_MALFORMED, PI_ERROR, \"HSDSCH Entity not specified\", EXPFILL }},\r\n        { &ei_fp_hsdsch_common_experimental_support, { \"fp.hsdsch_common.experimental_support\", PI_DEBUG, PI_WARN, \"HSDSCH COMMON - Experimental support!\", EXPFILL }},\r\n        { &ei_fp_hsdsch_common_t3_not_implemented, { \"fp.hsdsch_common_t3.not_implemented\", PI_DEBUG, PI_ERROR, \"HSDSCH COMMON T3 - Not implemented!\", EXPFILL }},\r\n        { &ei_fp_channel_type_unknown, { \"fp.channel_type.unknown\", PI_MALFORMED, PI_ERROR, \"Unknown channel type\", EXPFILL }},\r\n        { &ei_fp_no_per_frame_info, { \"fp.no_per_frame_info\", PI_UNDECODED, PI_ERROR, \"Can't dissect FP frame because no per-frame info was attached!\", EXPFILL }},\r\n        { &ei_fp_no_per_conv_channel_info, { \"fp.no_per_conv_channel_info\", PI_UNDECODED, PI_ERROR, \"Can't dissect this FP stream because no per-conversation channel info was attached!\", EXPFILL }},\r\n        { &ei_fp_invalid_frame_count, { \"fp.invalid_frame_count\", PI_MALFORMED, PI_ERROR, \"Invalid frame count\", EXPFILL }},\r\n    };\r\n\r\n    module_t *fp_module;\r\n    expert_module_t *expert_fp;\r\n\r\n    /* Register protocol. */\r\n    proto_fp = proto_register_protocol(\"FP\", \"FP\", \"fp\");\r\n    proto_register_field_array(proto_fp, hf, array_length(hf));\r\n    proto_register_subtree_array(ett, array_length(ett));\r\n    expert_fp = expert_register_protocol(proto_fp);\r\n    expert_register_field_array(expert_fp, ei, array_length(ei));\r\n\r\n    /* Allow other dissectors to find this one by name. */\r\n    fp_handle = register_dissector(\"fp\", dissect_fp, proto_fp);\r\n    fp_aal2_handle = register_dissector(\"fp.aal2\", dissect_fp_aal2, proto_fp);\r\n\r\n    /* Preferences */\r\n    fp_module = prefs_register_protocol(proto_fp, NULL);\r\n\r\n    /* Determines whether release information should be displayed */\r\n    prefs_register_bool_preference(fp_module, \"show_release_info\",\r\n                                   \"Show reported release info\",\r\n                                   \"Show reported release info\",\r\n                                   &preferences_show_release_info);\r\n\r\n    /* Determines whether MAC dissector should be called for payloads */\r\n    prefs_register_bool_preference(fp_module, \"call_mac\",\r\n                                   \"Call MAC dissector for payloads\",\r\n                                   \"Call MAC dissector for payloads\",\r\n                                   &preferences_call_mac_dissectors);\r\n     /* Determines whether or not to validate FP payload checksums */\r\n    prefs_register_bool_preference(fp_module, \"payload_checksum\",\r\n                                    \"Validate FP payload checksums\",\r\n                                    \"Validate FP payload checksums\",\r\n                                    &preferences_payload_checksum);\r\n     /* Determines whether or not to validate FP header checksums */\r\n    prefs_register_bool_preference(fp_module, \"header_checksum\",\r\n                                    \"Validate FP header checksums\",\r\n                                    \"Validate FP header checksums\",\r\n                                    &preferences_header_checksum);\r\n     /* Determines whether or not to track Paging Indications between PCH frames*/\r\n     prefs_register_bool_preference(fp_module, \"track_paging_indications\",\r\n                                    \"Track Paging Indications in PCH channels\",\r\n                                    \"For each PCH data frame, Try to show the paging indications bitmap found in the previous frame\",\r\n                                    &preferences_track_paging_indications);\r\n    prefs_register_obsolete_preference(fp_module, \"udp_heur\");\r\n    prefs_register_obsolete_preference(fp_module, \"epandchannelconfigurationtable\");\r\n\r\n}"}, "function_name": "proto_reg_handoff_fp"}
{"function_id": null, "caller": {".y_login": "static int my_login(pTHX_ SV* dbh, imp_dbh_t *imp_dbh)\r\n{\r\n  SV* sv;\r\n  HV* hv;\r\n  char* dbname;\r\n  char* host;\r\n  char* port;\r\n  char* user;\r\n  char* password;\r\n  char* mysql_socket;\r\n  int   result;\r\n  D_imp_xxh(dbh);\r\n\r\n  /* TODO- resolve this so that it is set only if DBI is 1.607 */\r\n#define TAKE_IMP_DATA_VERSION 1\r\n#if TAKE_IMP_DATA_VERSION\r\n  if (DBIc_has(imp_dbh, DBIcf_IMPSET))\r\n  { /* eg from take_imp_data() */\r\n    if (DBIc_has(imp_dbh, DBIcf_ACTIVE))\r\n    {\r\n      if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n        PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"my_login skip connect\\n\");\r\n      /* tell our parent we've adopted an active child */\r\n      ++DBIc_ACTIVE_KIDS(DBIc_PARENT_COM(imp_dbh));\r\n      return TRUE;\r\n    }\r\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                    \"my_login IMPSET but not ACTIVE so connect not skipped\\n\");\r\n  }\r\n#endif\r\n\r\n  sv = DBIc_IMP_DATA(imp_dbh);\r\n\r\n  if (!sv  ||  !SvROK(sv))\r\n    return FALSE;\r\n\r\n  hv = (HV*) SvRV(sv);\r\n  if (SvTYPE(hv) != SVt_PVHV)\r\n    return FALSE;\r\n\r\n  host=\t\tsafe_hv_fetch(aTHX_ hv, \"host\", 4);\r\n  port=\t\tsafe_hv_fetch(aTHX_ hv, \"port\", 4);\r\n  user=\t\tsafe_hv_fetch(aTHX_ hv, \"user\", 4);\r\n  password=\tsafe_hv_fetch(aTHX_ hv, \"password\", 8);\r\n  dbname=\tsafe_hv_fetch(aTHX_ hv, \"database\", 8);\r\n  mysql_socket=\tsafe_hv_fetch(aTHX_ hv, \"mysql_socket\", 12);\r\n\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n\t\t  \"imp_dbh->my_login : dbname = %s, uid = %s, pwd = %s,\" \\\r\n\t\t  \"host = %s, port = %s\\n\",\r\n\t\t  dbname ? dbname : \"NULL\",\r\n\t\t  user ? user : \"NULL\",\r\n\t\t  password ? password : \"NULL\",\r\n\t\t  host ? host : \"NULL\",\r\n\t\t  port ? port : \"NULL\");\r\n\r\n  if (!imp_dbh->pmysql) {\r\n     Newz(908, imp_dbh->pmysql, 1, MYSQL);\r\n     imp_dbh->pmysql->net.fd = -1;\r\n  }\r\n  result = mysql_dr_connect(dbh, imp_dbh->pmysql, mysql_socket, host, port, user,\r\n\t\t\t  password, dbname, imp_dbh) ? TRUE : FALSE;\r\n  return result;\r\n}", ".o_error": "void do_error(SV* h, int rc, const char* what, const char* sqlstate)\r\n{\r\n  dTHX;\r\n  D_imp_xxh(h);\r\n  SV *errstr;\r\n  SV *errstate;\r\n\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\t--> do_error\\n\");\r\n  errstr= DBIc_ERRSTR(imp_xxh);\r\n  sv_setiv(DBIc_ERR(imp_xxh), (IV)rc);\t/* set err early\t*/\r\n  sv_setpv(errstr, what);\r\n\r\n  if (sqlstate)\r\n  {\r\n    errstate= DBIc_STATE(imp_xxh);\r\n    sv_setpvn(errstate, sqlstate, 5);\r\n  }\r\n\r\n  /* NO EFFECT DBIh_EVENT2(h, ERROR_event, DBIc_ERR(imp_xxh), errstr); */\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"%s error %d recorded: %s\\n\",\r\n    what, rc, SvPV_nolen(errstr));\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\t<-- do_error\\n\");\r\n}", ".o_warn": "void do_warn(SV* h, int rc, char* what)\r\n{\r\n  dTHX;\r\n  D_imp_xxh(h);\r\n\r\n  SV *errstr = DBIc_ERRSTR(imp_xxh);\r\n  sv_setiv(DBIc_ERR(imp_xxh), (IV)rc);\t/* set err early\t*/\r\n  sv_setpv(errstr, what);\r\n  /* NO EFFECT DBIh_EVENT2(h, WARN_event, DBIc_ERR(imp_xxh), errstr);*/\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"%s warning %d recorded: %s\\n\",\r\n    what, rc, SvPV_nolen(errstr));\r\n  warn(\"%s\", what);\r\n}", ".bd_db_disconnect": "int dbd_db_disconnect(SV* dbh, imp_dbh_t* imp_dbh)\r\n{\r\n#ifdef dTHR\r\n  dTHR;\r\n#endif\r\n  dTHX;\r\n  D_imp_xxh(dbh);\r\n\r\n  /* We assume that disconnect will always work       */\r\n  /* since most errors imply already disconnected.    */\r\n  DBIc_ACTIVE_off(imp_dbh);\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"imp_dbh->pmysql: %p\\n\",\r\n\t\t              imp_dbh->pmysql);\r\n  mysql_close(imp_dbh->pmysql );\r\n  imp_dbh->pmysql->net.fd = -1;\r\n\r\n  /* We don't free imp_dbh since a reference still exists    */\r\n  /* The DESTROY method is the only one to 'free' memory.    */\r\n  return TRUE;\r\n}", ".ysql_st_free_result_sets": "int mysql_st_free_result_sets (SV * sth, imp_sth_t * imp_sth)\r\n{\r\n  dTHX;\r\n  D_imp_dbh_from_sth;\r\n  D_imp_xxh(sth);\r\n  int next_result_rc= -1;\r\n\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t>- dbd_st_free_result_sets\\n\");\r\n\r\n  do\r\n  {\r\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t<- dbd_st_free_result_sets RC %d\\n\", next_result_rc);\r\n\r\n    if (next_result_rc == 0)\r\n    {\r\n      if (!(imp_sth->result = mysql_use_result(imp_dbh->pmysql)))\r\n      {\r\n        /* Check for possible error */\r\n        if (mysql_field_count(imp_dbh->pmysql))\r\n        {\r\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n          PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t<- dbd_st_free_result_sets ERROR: %s\\n\",\r\n                                  mysql_error(imp_dbh->pmysql));\r\n\r\n          do_error(sth, mysql_errno(imp_dbh->pmysql), mysql_error(imp_dbh->pmysql),\r\n                   mysql_sqlstate(imp_dbh->pmysql));\r\n          return 0;\r\n        }\r\n      }\r\n    }\r\n    if (imp_sth->result)\r\n    {\r\n      mysql_free_result(imp_sth->result);\r\n      imp_sth->result=NULL;\r\n    }\r\n  } while ((next_result_rc=mysql_next_result(imp_dbh->pmysql))==0);\r\n\r\n  if (next_result_rc > 0)\r\n  {\r\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t<- dbd_st_free_result_sets: Error while processing multi-result set: %s\\n\",\r\n                    mysql_error(imp_dbh->pmysql));\r\n\r\n    do_error(sth, mysql_errno(imp_dbh->pmysql), mysql_error(imp_dbh->pmysql),\r\n             mysql_sqlstate(imp_dbh->pmysql));\r\n  }\r\n\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t<- dbd_st_free_result_sets\\n\");\r\n\r\n  return 1;\r\n}", ".ount_params": "static int\r\ncount_params(imp_xxh_t *imp_xxh, pTHX_ char *statement, bool bind_comment_placeholders)\r\n{\r\n  bool comment_end= false;\r\n  char* ptr= statement;\r\n  int num_params= 0;\r\n  int comment_length= 0;\r\n  char c;\r\n\r\n  if (DBIc_DBISTATE(imp_xxh)->debug >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \">count_params statement %s\\n\", statement);\r\n\r\n  while ( (c = *ptr++) )\r\n  {\r\n    switch (c) {\r\n      /* so, this is a -- comment, so let's burn up characters */\r\n    case '-':\r\n      {\r\n          if (bind_comment_placeholders)\r\n          {\r\n              c = *ptr++;\r\n              break;\r\n          }\r\n          else\r\n          {\r\n              comment_length= 1;\r\n              /* let's see if the next one is a dash */\r\n              c = *ptr++;\r\n\r\n              if  (c == '-') {\r\n                  /* if two dashes, ignore everything until newline */\r\n                  while ((c = *ptr))\r\n                  {\r\n                      if (DBIc_DBISTATE(imp_xxh)->debug >= 2)\r\n                          PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"%c\\n\", c);\r\n                      ptr++;\r\n                      comment_length++;\r\n                      if (c == '\\n')\r\n                      {\r\n                          comment_end= true;\r\n                          break;\r\n                      }\r\n                  }\r\n                  /*\r\n                    if not comment_end, the comment never ended and we need to iterate\r\n                    back to the beginning of where we started and let the database \r\n                    handle whatever is in the statement\r\n                */\r\n                  if (! comment_end)\r\n                      ptr-= comment_length;\r\n              }\r\n              /* otherwise, only one dash/hyphen, backtrack by one */\r\n              else\r\n                  ptr--;\r\n              break;\r\n          }\r\n      }\r\n    /* c-type comments */\r\n    case '/':\r\n      {\r\n          if (bind_comment_placeholders)\r\n          {\r\n              c = *ptr++;\r\n              break;\r\n          }\r\n          else\r\n          {\r\n              c = *ptr++;\r\n              /* let's check if the next one is an asterisk */\r\n              if  (c == '*')\r\n              {\r\n                  comment_length= 0;\r\n                  comment_end= false;\r\n                  /* ignore everything until closing comment */\r\n                  while ((c= *ptr))\r\n                  {\r\n                      ptr++;\r\n                      comment_length++;\r\n\r\n                      if (c == '*')\r\n                      {\r\n                          c = *ptr++;\r\n                          /* alas, end of comment */\r\n                          if (c == '/')\r\n                          {\r\n                              comment_end= true;\r\n                              break;\r\n                          }\r\n                          /*\r\n                            nope, just an asterisk, not so fast, not\r\n                            end of comment, go back one\r\n                        */\r\n                          else\r\n                              ptr--;\r\n                      }\r\n                  }\r\n                  /*\r\n                    if the end of the comment was never found, we have\r\n                    to backtrack to wherever we first started skipping\r\n                    over the possible comment.\r\n                    This means we will pass the statement to the database\r\n                    to see its own fate and issue the error\r\n                */\r\n                  if (!comment_end)\r\n                      ptr -= comment_length;\r\n              }\r\n              else\r\n                  ptr--;\r\n              break;\r\n          }\r\n      }\r\n    case '`':\r\n    case '\"':\r\n    case '\\'':\r\n      /* Skip string */\r\n      {\r\n        char end_token = c;\r\n        while ((c = *ptr)  &&  c != end_token)\r\n        {\r\n          if (c == '\\\\')\r\n            if (! *(++ptr))\r\n              continue;\r\n\r\n          ++ptr;\r\n        }\r\n        if (c)\r\n          ++ptr;\r\n        break;\r\n      }\r\n\r\n    case '?':\r\n      ++num_params;\r\n      break;\r\n\r\n    default:\r\n      break;\r\n    }\r\n  }\r\n  return num_params;\r\n}", ".ysql_db_reconnect": "int mysql_db_reconnect(SV* h)\r\n{\r\n  dTHX;\r\n  D_imp_xxh(h);\r\n  imp_dbh_t* imp_dbh;\r\n  MYSQL save_socket;\r\n\r\n  if (DBIc_DBISTATE(imp_xxh)->debug >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"reconnecting\\n\");\r\n\r\n  if (DBIc_TYPE(imp_xxh) == DBIt_ST)\r\n  {\r\n    imp_dbh = (imp_dbh_t*) DBIc_PARENT_COM(imp_xxh);\r\n    h = DBIc_PARENT_H(imp_xxh);\r\n  }\r\n  else\r\n    imp_dbh= (imp_dbh_t*) imp_xxh;\r\n\r\n  /* reconnect a closed connection, used in do() for implicit reconnect */\r\n  if (!DBIc_has(imp_dbh, DBIcf_ACTIVE) && DBIc_has(imp_dbh, DBIcf_AutoCommit)) {\r\n    if (my_login(aTHX_ h, imp_dbh)) {\r\n      DBIc_ACTIVE_on(imp_dbh);\r\n      DBIc_set(imp_dbh, DBIcf_AutoCommit, TRUE);\r\n      return TRUE;\r\n    }\r\n    return FALSE;\r\n  }\r\n\r\n  if (mysql_errno(imp_dbh->pmysql) != CR_SERVER_GONE_ERROR &&\r\n#ifdef ER_CLIENT_INTERACTION_TIMEOUT /* Added in 8.0.24 */\r\n          mysql_errno(imp_dbh->pmysql) != ER_CLIENT_INTERACTION_TIMEOUT &&\r\n#endif\r\n          mysql_errno(imp_dbh->pmysql) != CR_SERVER_LOST) {\r\n    /* Other error */\r\n    if (DBIc_DBISTATE(imp_xxh)->debug >= 2)\r\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"Can't reconnect on unexpected error %d\\n\",\r\n          mysql_errno(imp_dbh->pmysql));\r\n    return FALSE;\r\n  }\r\n\r\n  if (!DBIc_has(imp_dbh, DBIcf_AutoCommit) || !imp_dbh->auto_reconnect)\r\n  {\r\n    /* We never reconnect if AutoCommit is turned off.\r\n     * Otherwise we might get an inconsistent transaction\r\n     * state.\r\n     */\r\n    if (DBIc_DBISTATE(imp_xxh)->debug >= 2)\r\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"Can't reconnect as AutoCommit is turned off\\n\");\r\n    return FALSE;\r\n  }\r\n\r\n  /* my_login will blow away imp_dbh->mysql so we save a copy of\r\n   * imp_dbh->mysql and put it back where it belongs if the reconnect\r\n   * fail.  Think server is down & reconnect fails but the application eval{}s\r\n   * the execute, so next time $dbh->quote() gets called, instant SIGSEGV!\r\n   */\r\n  save_socket= *(imp_dbh->pmysql);\r\n  memcpy (&save_socket, imp_dbh->pmysql,sizeof(save_socket));\r\n  memset (imp_dbh->pmysql,0,sizeof(*(imp_dbh->pmysql)));\r\n\r\n  /* we should disconnect the db handle before reconnecting, this will\r\n   * prevent my_login from thinking it's adopting an active child which\r\n   * would prevent the handle from actually reconnecting\r\n   */\r\n  if (!dbd_db_disconnect(h, imp_dbh) || !my_login(aTHX_ h, imp_dbh))\r\n  {\r\n    do_error(h, mysql_errno(imp_dbh->pmysql), mysql_error(imp_dbh->pmysql),\r\n             mysql_sqlstate(imp_dbh->pmysql));\r\n    memcpy (imp_dbh->pmysql, &save_socket, sizeof(save_socket));\r\n    ++imp_dbh->stats.auto_reconnects_failed;\r\n    return FALSE;\r\n  }\r\n\r\n  /*\r\n   *  Tell DBI, that dbh->disconnect should be called for this handle\r\n   */\r\n  DBIc_ACTIVE_on(imp_dbh);\r\n\r\n  ++imp_dbh->stats.auto_reconnects_ok;\r\n  return TRUE;\r\n}", ".ysql_to_perl_type": "static enum enum_field_types mysql_to_perl_type(enum enum_field_types type)\r\n{\r\n  enum enum_field_types enum_type;\r\n\r\n  switch (type) {\r\n  case MYSQL_TYPE_DOUBLE:\r\n  case MYSQL_TYPE_FLOAT:\r\n    enum_type= MYSQL_TYPE_DOUBLE;\r\n    break;\r\n\r\n  case MYSQL_TYPE_SHORT:\r\n  case MYSQL_TYPE_TINY:\r\n  case MYSQL_TYPE_LONG:\r\n  case MYSQL_TYPE_INT24:\r\n  case MYSQL_TYPE_YEAR:\r\n#if IVSIZE >= 8\r\n  case MYSQL_TYPE_LONGLONG:\r\n    enum_type= MYSQL_TYPE_LONGLONG;\r\n#else\r\n    enum_type= MYSQL_TYPE_LONG;\r\n#endif\r\n    break;\r\n\r\n  case MYSQL_TYPE_BIT:\r\n    enum_type= MYSQL_TYPE_BIT;\r\n    break;\r\n\r\n  case MYSQL_TYPE_NEWDECIMAL:\r\n  case MYSQL_TYPE_DECIMAL:\r\n    enum_type= MYSQL_TYPE_DECIMAL;\r\n    break;\r\n\r\n#if IVSIZE < 8\r\n  case MYSQL_TYPE_LONGLONG:\r\n#endif\r\n  case MYSQL_TYPE_DATE:\r\n  case MYSQL_TYPE_TIME:\r\n  case MYSQL_TYPE_DATETIME:\r\n  case MYSQL_TYPE_NEWDATE:\r\n  case MYSQL_TYPE_TIMESTAMP:\r\n  case MYSQL_TYPE_VAR_STRING:\r\n  case MYSQL_TYPE_VARCHAR:\r\n  case MYSQL_TYPE_STRING:\r\n    enum_type= MYSQL_TYPE_STRING;\r\n    break;\r\n\r\n  case MYSQL_TYPE_GEOMETRY:\r\n  case MYSQL_TYPE_BLOB:\r\n  case MYSQL_TYPE_TINY_BLOB:\r\n    enum_type= MYSQL_TYPE_BLOB;\r\n    break;\r\n\r\n  default:\r\n    enum_type= MYSQL_TYPE_STRING;    /* MySQL can handle all types as strings */\r\n  }\r\n  return(enum_type);\r\n}", ".ysql_st_internal_execute41": "my_ulonglong mysql_st_internal_execute41(\r\n                                         SV *sth,\r\n                                         int num_params,\r\n                                         MYSQL_RES **result,\r\n                                         MYSQL_STMT *stmt,\r\n                                         MYSQL_BIND *bind,\r\n                                         int *has_been_bound\r\n                                        )\r\n{\r\n  int i;\r\n  enum enum_field_types enum_type;\r\n  dTHX;\r\n  int execute_retval;\r\n  my_ulonglong rows=0;\r\n  D_imp_xxh(sth);\r\n\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                  \"\\t-> mysql_st_internal_execute41\\n\");\r\n\r\n  /* free result if exists */\r\n  if (*result)\r\n  {\r\n    mysql_free_result(*result);\r\n    *result= 0;\r\n  }\r\n\r\n  /*\r\n    If were performed any changes with ph variables\r\n    we have to rebind them\r\n  */\r\n\r\n  if (num_params > 0 && !(*has_been_bound))\r\n  {\r\n#if MYSQL_VERSION_ID >= 80300\r\n    if (mysql_stmt_bind_named_param(stmt,bind,num_params, NULL))\r\n#else\r\n    if (mysql_stmt_bind_param(stmt,bind))\r\n#endif\r\n      goto error;\r\n\r\n    *has_been_bound= 1;\r\n  }\r\n\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                  \"\\t\\tmysql_st_internal_execute41 calling mysql_execute with %d num_params\\n\",\r\n                  num_params);\r\n\r\n  execute_retval= mysql_stmt_execute(stmt);\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                  \"\\t\\tmysql_stmt_execute returned %d\\n\",\r\n                  execute_retval);\r\n  if (execute_retval)\r\n    goto error;\r\n\r\n  /*\r\n   This statement does not return a result set (INSERT, UPDATE...)\r\n  */\r\n  if (!(*result= mysql_stmt_result_metadata(stmt)))\r\n  {\r\n    if (mysql_stmt_errno(stmt))\r\n      goto error;\r\n\r\n    rows= mysql_stmt_affected_rows(stmt);\r\n\r\n    /* mysql_stmt_affected_rows(): -1 indicates that the query returned an error */\r\n    if (rows == (my_ulonglong)-1)\r\n      goto error;\r\n  }\r\n  /*\r\n    This statement returns a result set (SELECT...)\r\n  */\r\n  else\r\n  {\r\n    for (i = mysql_stmt_field_count(stmt) - 1; i >=0; --i) {\r\n        enum_type = mysql_to_perl_type(stmt->fields[i].type);\r\n        if (enum_type != MYSQL_TYPE_DOUBLE && enum_type != MYSQL_TYPE_LONG && enum_type != MYSQL_TYPE_LONGLONG && enum_type != MYSQL_TYPE_BIT)\r\n        {\r\n            /* mysql_stmt_store_result to update MYSQL_FIELD->max_length */\r\n            bool on = 1;\r\n            mysql_stmt_attr_set(stmt, STMT_ATTR_UPDATE_MAX_LENGTH, &on);\r\n            break;\r\n        }\r\n    }\r\n    /* Get the total rows affected and return */\r\n    if (mysql_stmt_store_result(stmt))\r\n      goto error;\r\n    else\r\n      rows= mysql_stmt_num_rows(stmt);\r\n  }\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                  \"\\t<- mysql_internal_execute_41 returning %lu rows\\n\",\r\n                  rows);\r\n  return(rows);\r\n\r\nerror:\r\n  if (*result)\r\n  {\r\n    mysql_free_result(*result);\r\n    *result= 0;\r\n  }\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                  \"     errno %d err message %s\\n\",\r\n                  mysql_stmt_errno(stmt),\r\n                  mysql_stmt_error(stmt));\r\n  do_error(sth, mysql_stmt_errno(stmt), mysql_stmt_error(stmt),\r\n           mysql_stmt_sqlstate(stmt));\r\n  mysql_stmt_reset(stmt);\r\n\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                  \"\\t<- mysql_st_internal_execute41\\n\");\r\n  return -2;\r\n\r\n}", ".ysql_st_internal_execute": "my_ulonglong mysql_st_internal_execute(\r\n                                       SV *h, /* could be sth or dbh */\r\n                                       SV *statement,\r\n                                       SV *attribs,\r\n                                       int num_params,\r\n                                       imp_sth_ph_t *params,\r\n                                       MYSQL_RES **result,\r\n                                       MYSQL *svsock,\r\n                                       int use_mysql_use_result\r\n                                      )\r\n{\r\n  dTHX;\r\n  bool bind_type_guessing= FALSE;\r\n  bool bind_comment_placeholders= TRUE;\r\n  STRLEN slen;\r\n  char *sbuf = SvPV(statement, slen);\r\n  char *salloc;\r\n  int htype;\r\n  bool async = FALSE;\r\n  my_ulonglong rows= 0;\r\n  /* thank you DBI.c for this info! */\r\n  D_imp_xxh(h);\r\n  attribs= attribs;\r\n\r\n  htype= DBIc_TYPE(imp_xxh);\r\n  /*\r\n    It is important to import imp_dbh properly according to the htype\r\n    that it is! Also, one might ask why bind_type_guessing is assigned\r\n    in each block. Well, it's because D_imp_ macros called in these\r\n    blocks make it so imp_dbh is not \"visible\" or defined outside of the\r\n    if/else (when compiled, it fails for imp_dbh not being defined).\r\n  */\r\n  /* h is a dbh */\r\n  if (htype == DBIt_DB)\r\n  {\r\n    D_imp_dbh(h);\r\n    /* if imp_dbh is not available, it causes segfault (proper) on OpenBSD */\r\n    if (imp_dbh)\r\n    {\r\n      bind_type_guessing= imp_dbh->bind_type_guessing;\r\n      bind_comment_placeholders= imp_dbh->bind_comment_placeholders;\r\n    }\r\n    async = (bool) (imp_dbh->async_query_in_flight != NULL);\r\n  }\r\n  /* h is a sth */\r\n  else\r\n  {\r\n    D_imp_sth(h);\r\n    D_imp_dbh_from_sth;\r\n    /* if imp_dbh is not available, it causes segfault (proper) on OpenBSD */\r\n    if (imp_dbh)\r\n    {\r\n      bind_type_guessing= imp_dbh->bind_type_guessing;\r\n      bind_comment_placeholders= imp_dbh->bind_comment_placeholders;\r\n    }\r\n    async = imp_sth->is_async;\r\n    if(async) {\r\n        imp_dbh->async_query_in_flight = imp_sth;\r\n    } else {\r\n        imp_dbh->async_query_in_flight = NULL;\r\n    }\r\n  }\r\n\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"mysql_st_internal_execute MYSQL_VERSION_ID %d\\n\",\r\n                  MYSQL_VERSION_ID );\r\n\r\n  salloc= parse_params(imp_xxh,\r\n                              aTHX_ svsock,\r\n                              sbuf,\r\n                              &slen,\r\n                              params,\r\n                              num_params,\r\n                              bind_type_guessing,\r\n                              bind_comment_placeholders);\r\n\r\n  if (salloc)\r\n  {\r\n    sbuf= salloc;\r\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"Binding parameters: %s\\n\", sbuf);\r\n  }\r\n\r\n  if(async) {\r\n    if((mysql_send_query(svsock, sbuf, slen)) &&\r\n       (!mysql_db_reconnect(h) ||\r\n        (mysql_send_query(svsock, sbuf, slen))))\r\n    {\r\n        rows = -2;\r\n    } else {\r\n        rows = 0;\r\n    }\r\n  } else {\r\n      if ((mysql_real_query(svsock, sbuf, slen))  &&\r\n          (!mysql_db_reconnect(h)  ||\r\n           (mysql_real_query(svsock, sbuf, slen))))\r\n      {\r\n        rows = -2;\r\n      } else {\r\n          /** Store the result from the Query */\r\n          *result= use_mysql_use_result ?\r\n            mysql_use_result(svsock) : mysql_store_result(svsock);\r\n\r\n          if (mysql_errno(svsock))\r\n            rows = -2;\r\n          else if (*result)\r\n            rows = mysql_num_rows(*result);\r\n          else {\r\n            rows = mysql_affected_rows(svsock);\r\n            /* mysql_affected_rows(): -1 indicates that the query returned an error */\r\n            if (rows == (my_ulonglong)-1)\r\n              rows = -2;\r\n          }\r\n      }\r\n  }\r\n\r\n  if (salloc)\r\n    Safefree(salloc);\r\n\r\n  if(rows == (my_ulonglong)-2) {\r\n    do_error(h, mysql_errno(svsock), mysql_error(svsock), \r\n             mysql_sqlstate(svsock));\r\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"IGNORING ERROR errno %d\\n\", mysql_errno(svsock));\r\n  }\r\n  return(rows);\r\n}", ".bd_describe": "int dbd_describe(SV* sth, imp_sth_t* imp_sth)\r\n{\r\n  dTHX;\r\n  D_imp_xxh(sth);\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t--> dbd_describe\\n\");\r\n\r\n\r\n  if (imp_sth->use_server_side_prepare)\r\n  {\r\n    int i;\r\n    int col_type;\r\n    int num_fields= DBIc_NUM_FIELDS(imp_sth);\r\n    imp_sth_fbh_t *fbh;\r\n    MYSQL_BIND *buffer;\r\n    MYSQL_FIELD *fields;\r\n\r\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tdbd_describe() num_fields %d\\n\",\r\n                    num_fields);\r\n\r\n    if (imp_sth->done_desc)\r\n      return TRUE;\r\n\r\n    if (!num_fields || !imp_sth->result)\r\n    {\r\n      /* no metadata */\r\n      do_error(sth, JW_ERR_SEQUENCE,\r\n               \"no metadata information while trying describe result set\",\r\n               NULL);\r\n      return 0;\r\n    }\r\n\r\n    /* allocate fields buffers  */\r\n    if (  !(imp_sth->fbh= alloc_fbuffer(num_fields))\r\n          || !(imp_sth->buffer= alloc_bind(num_fields)) )\r\n    {\r\n      /* Out of memory */\r\n      do_error(sth, JW_ERR_SEQUENCE,\r\n               \"Out of memory in dbd_sescribe()\",NULL);\r\n      return 0;\r\n    }\r\n\r\n    fields= mysql_fetch_fields(imp_sth->result);\r\n\r\n    for (\r\n         fbh= imp_sth->fbh, buffer= (MYSQL_BIND*)imp_sth->buffer, i= 0;\r\n         i < num_fields;\r\n         i++, fbh++, buffer++\r\n        )\r\n    {\r\n      /* get the column type */\r\n      col_type = fields ? fields[i].type : MYSQL_TYPE_STRING;\r\n\r\n      if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n      {\r\n        PerlIO_printf(DBIc_LOGPIO(imp_xxh),\"\\t\\ti %d col_type %d fbh->length %lu\\n\",\r\n                      i, col_type, fbh->length);\r\n        PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                      \"\\t\\tfields[i].length %lu fields[i].max_length %lu fields[i].type %d fields[i].charsetnr %d\\n\",\r\n                      fields[i].length, fields[i].max_length, fields[i].type,\r\n                      fields[i].charsetnr);\r\n      }\r\n      fbh->charsetnr = fields[i].charsetnr;\r\n\r\n      buffer->buffer_type= mysql_to_perl_type(col_type);\r\n      if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n        PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tmysql_to_perl_type returned %d\\n\",\r\n                      col_type);\r\n      buffer->length= &(fbh->length);\r\n      buffer->is_null= &(fbh->is_null);\r\n      buffer->error= (bool*) &(fbh->error);\r\n\r\n      if (fields[i].flags & ZEROFILL_FLAG)\r\n        buffer->buffer_type = MYSQL_TYPE_STRING;\r\n\r\n      switch (buffer->buffer_type) {\r\n      case MYSQL_TYPE_DOUBLE:\r\n        buffer->buffer_length= sizeof(fbh->ddata);\r\n        buffer->buffer= (char*) &fbh->ddata;\r\n        break;\r\n\r\n      case MYSQL_TYPE_LONG:\r\n      case MYSQL_TYPE_LONGLONG:\r\n        buffer->buffer_length= sizeof(fbh->ldata);\r\n        buffer->buffer= (char*) &fbh->ldata;\r\n        buffer->is_unsigned= (fields[i].flags & UNSIGNED_FLAG) ? 1 : 0;\r\n        break;\r\n\r\n      case MYSQL_TYPE_BIT:\r\n        buffer->buffer_length= 8;\r\n        Newz(908, fbh->data, buffer->buffer_length, char);\r\n        buffer->buffer= (char *) fbh->data;\r\n        break;\r\n\r\n      default:\r\n        buffer->buffer_length= fields[i].max_length ? fields[i].max_length : 1;\r\n        Newz(908, fbh->data, buffer->buffer_length, char);\r\n        buffer->buffer= (char *) fbh->data;\r\n      }\r\n    }\r\n\r\n    if (mysql_stmt_bind_result(imp_sth->stmt, imp_sth->buffer))\r\n    {\r\n      do_error(sth, mysql_stmt_errno(imp_sth->stmt),\r\n               mysql_stmt_error(imp_sth->stmt),\r\n               mysql_stmt_sqlstate(imp_sth->stmt));\r\n      return 0;\r\n    }\r\n  }\r\n\r\n  imp_sth->done_desc= 1;\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t<- dbd_describe\\n\");\r\n  return TRUE;\r\n}", ".ysql_db_async_result": "int mysql_db_async_result(SV* h, MYSQL_RES** resp)\r\n{\r\n  dTHX;\r\n  D_imp_xxh(h);\r\n  imp_dbh_t* dbh;\r\n  MYSQL* svsock = NULL;\r\n  MYSQL_RES* _res;\r\n  int retval = 0;\r\n  int htype;\r\n  bool async_sth = FALSE;\r\n\r\n  if(! resp) {\r\n      resp = &_res;\r\n  }\r\n  htype = DBIc_TYPE(imp_xxh);\r\n\r\n\r\n  if(htype == DBIt_DB) {\r\n      D_imp_dbh(h);\r\n      dbh = imp_dbh;\r\n  } else {\r\n      D_imp_sth(h);\r\n      D_imp_dbh_from_sth;\r\n      dbh = imp_dbh;\r\n      async_sth = imp_sth->is_async;\r\n      retval = imp_sth->row_num;\r\n  }\r\n\r\n  if(! dbh->async_query_in_flight) {\r\n      if (async_sth)\r\n          return retval;\r\n      do_error(h, 2000, \"Gathering asynchronous results for a synchronous handle\", \"HY000\");\r\n      return -1;\r\n  }\r\n  if(dbh->async_query_in_flight != imp_xxh) {\r\n      do_error(h, 2000, \"Gathering async_query_in_flight results for the wrong handle\", \"HY000\");\r\n      return -1;\r\n  }\r\n  dbh->async_query_in_flight = NULL;\r\n\r\n  svsock= dbh->pmysql;\r\n  retval= mysql_read_query_result(svsock);\r\n  if(! retval) {\r\n    *resp= mysql_store_result(svsock);\r\n\r\n    if (mysql_errno(svsock))\r\n      do_error(h, mysql_errno(svsock), mysql_error(svsock), mysql_sqlstate(svsock));\r\n    if (!*resp)\r\n      retval= mysql_affected_rows(svsock);\r\n    else {\r\n      retval= mysql_num_rows(*resp);\r\n      if(resp == &_res) {\r\n        mysql_free_result(*resp);\r\n        *resp= NULL;\r\n      }\r\n    }\r\n    if(htype == DBIt_ST) {\r\n      D_imp_sth(h);\r\n      D_imp_dbh_from_sth;\r\n\r\n      if((my_ulonglong)retval+1 != (my_ulonglong)-1) {\r\n        if(! *resp) {\r\n          imp_sth->insertid= mysql_insert_id(svsock);\r\n          if(! mysql_more_results(svsock))\r\n            DBIc_ACTIVE_off(imp_sth);\r\n        } else {\r\n          DBIc_NUM_FIELDS(imp_sth)= mysql_num_fields(imp_sth->result);\r\n          imp_sth->done_desc= 0;\r\n          imp_sth->fetch_done= 0;\r\n        }\r\n      }\r\n      imp_sth->warning_count = mysql_warning_count(imp_dbh->pmysql);\r\n    }\r\n  } else {\r\n     do_error(h, mysql_errno(svsock), mysql_error(svsock),\r\n              mysql_sqlstate(svsock));\r\n     return -1;\r\n  }\r\n return retval;\r\n}", ".ysql_st_clean_cursor": "int mysql_st_clean_cursor(SV* sth, imp_sth_t* imp_sth) {\r\n\r\n  if (DBIc_ACTIVE(imp_sth) && dbd_describe(sth, imp_sth) &&\r\n      !imp_sth->fetch_done)\r\n    mysql_stmt_free_result(imp_sth->stmt);\r\n  return 1;\r\n}", ".ree_bind": "static void free_bind(MYSQL_BIND *bind)\r\n{\r\n  if (bind)\r\n    Safefree(bind);\r\n}", ".ree_fbind": "static void free_fbind(imp_sth_phb_t *fbind)\r\n{\r\n  if (fbind)\r\n    Safefree(fbind);\r\n}", ".ree_fbuffer": "static void free_fbuffer(imp_sth_fbh_t *fbh)\r\n{\r\n  if (fbh)\r\n    Safefree(fbh);\r\n}", ".ree_param": "static void\r\nfree_param(pTHX_ imp_sth_ph_t *params, int num_params)\r\n{\r\n  if (params)\r\n  {\r\n    int i;\r\n    for (i= 0;  i < num_params;  i++)\r\n    {\r\n      imp_sth_ph_t *ph= params+i;\r\n      if (ph->value)\r\n      {\r\n        (void) SvREFCNT_dec(ph->value);\r\n        ph->value= NULL;\r\n      }\r\n    }\r\n    Safefree(params);\r\n  }\r\n}", ".ind_param": "int bind_param(imp_sth_ph_t *ph, SV *value, IV sql_type)\r\n{\r\n  dTHX;\r\n  if (ph->value)\r\n  {\r\n    if (SvMAGICAL(ph->value))\r\n      mg_get(ph->value);\r\n    (void) SvREFCNT_dec(ph->value);\r\n  }\r\n\r\n  ph->value= newSVsv(value);\r\n\r\n  if (sql_type)\r\n    ph->type = sql_type;\r\n\r\n  return TRUE;\r\n}"}, "callee": {".bd_st_prepare": "int\r\ndbd_st_prepare(\r\n  SV *sth,\r\n  imp_sth_t *imp_sth,\r\n  char *statement,\r\n  SV *attribs)\r\n{\r\n  int i;\r\n  SV **svp;\r\n  dTHX;\r\n  int prepare_retval;\r\n  MYSQL_BIND *bind, *bind_end;\r\n  imp_sth_phb_t *fbind;\r\n  D_imp_xxh(sth);\r\n  D_imp_dbh_from_sth;\r\n\r\n  if (!DBIc_ACTIVE(imp_dbh)) {\r\n    do_error(sth, JW_ERR_NOT_ACTIVE, \"Statement not active\" ,NULL);\r\n    return FALSE;\r\n  }\r\n\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                 \"\\t-> dbd_st_prepare MYSQL_VERSION_ID %d, SQL statement: %s\\n\",\r\n                  MYSQL_VERSION_ID, statement);\r\n\r\n /* Set default value of 'mysql_server_prepare' attribute for sth from dbh */\r\n  imp_sth->use_server_side_prepare= imp_dbh->use_server_side_prepare;\r\n  imp_sth->disable_fallback_for_server_prepare= imp_dbh->disable_fallback_for_server_prepare;\r\n  if (attribs)\r\n  {\r\n    svp= DBD_ATTRIB_GET_SVP(attribs, \"mysql_server_prepare\", 20);\r\n    imp_sth->use_server_side_prepare = (svp) ?\r\n      SvTRUE(*svp) : imp_dbh->use_server_side_prepare;\r\n\r\n    svp= DBD_ATTRIB_GET_SVP(attribs, \"mysql_server_prepare_disable_fallback\", 37);\r\n    imp_sth->disable_fallback_for_server_prepare = (svp) ?\r\n      SvTRUE(*svp) : imp_dbh->disable_fallback_for_server_prepare;\r\n\r\n    svp = DBD_ATTRIB_GET_SVP(attribs, \"async\", 5);\r\n\r\n    if(svp && SvTRUE(*svp)) {\r\n        imp_sth->is_async = TRUE;\r\n        if (imp_sth->disable_fallback_for_server_prepare)\r\n        {\r\n          do_error(sth, ER_UNSUPPORTED_PS,\r\n                   \"Async option not supported with server side prepare\", \"HY000\");\r\n          return 0;\r\n        }\r\n        imp_sth->use_server_side_prepare = FALSE;\r\n    }\r\n  }\r\n\r\n  imp_sth->fetch_done= 0;\r\n  imp_sth->done_desc= 0;\r\n  imp_sth->result= NULL;\r\n  imp_sth->currow= 0;\r\n\r\n  /* Set default value of 'mysql_use_result' attribute for sth from dbh */\r\n  svp= DBD_ATTRIB_GET_SVP(attribs, \"mysql_use_result\", 16);\r\n  imp_sth->use_mysql_use_result= svp ?\r\n    SvTRUE(*svp) : imp_dbh->use_mysql_use_result;\r\n\r\n  for (i= 0; i < AV_ATTRIB_LAST; i++)\r\n    imp_sth->av_attr[i]= Nullav;\r\n\r\n  /*\r\n     Clean-up previous result set(s) for sth to prevent\r\n     'Commands out of sync' error \r\n  */\r\n  mysql_st_free_result_sets(sth, imp_sth);\r\n\r\n\r\n  if (imp_sth->use_server_side_prepare)\r\n  {\r\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                    \"\\t\\tuse_server_side_prepare set\\n\");\r\n    /* do we really need this? If we do, we should return, not just continue */\r\n    if (imp_sth->stmt)\r\n      fprintf(stderr,\r\n              \"ERROR: Trying to prepare new stmt while we have \\\r\n              already not closed one \\n\");\r\n\r\n    imp_sth->stmt= mysql_stmt_init(imp_dbh->pmysql);\r\n\r\n    if (! imp_sth->stmt)\r\n    {\r\n      if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n        PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                      \"\\t\\tERROR: Unable to return MYSQL_STMT structure \\\r\n                      from mysql_stmt_init(): ERROR NO: %d ERROR MSG:%s\\n\",\r\n                      mysql_errno(imp_dbh->pmysql),\r\n                      mysql_error(imp_dbh->pmysql));\r\n    }\r\n\r\n    prepare_retval= mysql_stmt_prepare(imp_sth->stmt,\r\n                                       statement,\r\n                                       strlen(statement));\r\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n        PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                      \"\\t\\tmysql_stmt_prepare returned %d\\n\",\r\n                      prepare_retval);\r\n\r\n    if (prepare_retval)\r\n    {\r\n      if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n        PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                      \"\\t\\tmysql_stmt_prepare %d %s\\n\",\r\n                      mysql_stmt_errno(imp_sth->stmt),\r\n                      mysql_stmt_error(imp_sth->stmt));\r\n\r\n      /* For commands that are not supported by server side prepared statement\r\n         mechanism lets try to pass them through regular API */\r\n      if (!imp_sth->disable_fallback_for_server_prepare && mysql_stmt_errno(imp_sth->stmt) == ER_UNSUPPORTED_PS)\r\n      {\r\n        if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n          PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                    \"\\t\\tSETTING imp_sth->use_server_side_prepare to 0\\n\");\r\n        imp_sth->use_server_side_prepare= 0;\r\n      }\r\n      else\r\n      {\r\n        do_error(sth, mysql_stmt_errno(imp_sth->stmt),\r\n                 mysql_stmt_error(imp_sth->stmt),\r\n                mysql_sqlstate(imp_dbh->pmysql));\r\n        mysql_stmt_close(imp_sth->stmt);\r\n        imp_sth->stmt= NULL;\r\n        return FALSE;\r\n      }\r\n    }\r\n    else\r\n    {\r\n      DBIc_NUM_PARAMS(imp_sth)= mysql_stmt_param_count(imp_sth->stmt);\r\n      /* mysql_stmt_param_count */\r\n\r\n      if (DBIc_NUM_PARAMS(imp_sth) > 0)\r\n      {\r\n        /* Allocate memory for bind variables */\r\n        imp_sth->bind=            alloc_bind(DBIc_NUM_PARAMS(imp_sth));\r\n        imp_sth->fbind=           alloc_fbind(DBIc_NUM_PARAMS(imp_sth));\r\n        imp_sth->has_been_bound=  0;\r\n\r\n        /* Initialize ph variables with  NULL values */\r\n        for (i= 0,\r\n             bind=      imp_sth->bind,\r\n             fbind=     imp_sth->fbind,\r\n             bind_end=  bind+DBIc_NUM_PARAMS(imp_sth);\r\n             bind < bind_end ;\r\n             bind++, fbind++, i++ )\r\n        {\r\n          bind->buffer_type=  MYSQL_TYPE_STRING;\r\n          bind->buffer=       NULL;\r\n          bind->length=       &(fbind->length);\r\n          bind->is_null=      &(fbind->is_null);\r\n          fbind->is_null=     1;\r\n          fbind->length=      0;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /* Count the number of parameters (driver, vs server-side) */\r\n  if (imp_sth->use_server_side_prepare == 0)\r\n    DBIc_NUM_PARAMS(imp_sth) = count_params((imp_xxh_t *)imp_dbh, aTHX_ statement,\r\n                                            imp_dbh->bind_comment_placeholders);\r\n\r\n  /* Allocate memory for parameters */\r\n  imp_sth->params= alloc_param(DBIc_NUM_PARAMS(imp_sth));\r\n  DBIc_IMPSET_on(imp_sth);\r\n\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t<- dbd_st_prepare\\n\");\r\n  return 1;\r\n}", ".bd_st_destroy": "void dbd_st_destroy(SV *sth, imp_sth_t *imp_sth) {\r\n  dTHX;\r\n  D_imp_xxh(sth);\r\n\r\n#if defined (dTHR)\r\n  dTHR;\r\n#endif\r\n\r\n  int i;\r\n\r\n  imp_sth_fbh_t *fbh;\r\n  int n;\r\n\r\n  n= DBIc_NUM_PARAMS(imp_sth);\r\n  if (n)\r\n  {\r\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\tFreeing %d parameters, bind %p fbind %p\\n\",\r\n          n, imp_sth->bind, imp_sth->fbind);\r\n\r\n    free_bind(imp_sth->bind);\r\n    free_fbind(imp_sth->fbind);\r\n  }\r\n\r\n  fbh= imp_sth->fbh;\r\n  if (fbh)\r\n  {\r\n    n = DBIc_NUM_FIELDS(imp_sth);\r\n    i = 0;\r\n    while (i < n)\r\n    {\r\n      if (fbh[i].data) Safefree(fbh[i].data);\r\n      ++i;\r\n    }\r\n\r\n    free_fbuffer(fbh);\r\n    if (imp_sth->buffer)\r\n      free_bind(imp_sth->buffer);\r\n  }\r\n\r\n  if (imp_sth->stmt)\r\n  {\r\n    mysql_stmt_close(imp_sth->stmt);\r\n    imp_sth->stmt= NULL;\r\n  }\r\n\r\n  /* dbd_st_finish has already been called by .xs code if needed.\t*/\r\n\r\n  /* Free values allocated by dbd_bind_ph */\r\n  if (imp_sth->params)\r\n  {\r\n    free_param(aTHX_ imp_sth->params, DBIc_NUM_PARAMS(imp_sth));\r\n    imp_sth->params= NULL;\r\n  }\r\n\r\n  /* Free cached array attributes */\r\n  for (i= 0; i < AV_ATTRIB_LAST; i++)\r\n  {\r\n    if (imp_sth->av_attr[i])\r\n      SvREFCNT_dec(imp_sth->av_attr[i]);\r\n    imp_sth->av_attr[i]= Nullav;\r\n  }\r\n  /* let DBI know we've done it   */\r\n  DBIc_IMPSET_off(imp_sth);\r\n}", ".ysql_st_internal_execute41": "my_ulonglong mysql_st_internal_execute41(\r\n                                         SV *sth,\r\n                                         int num_params,\r\n                                         MYSQL_RES **result,\r\n                                         MYSQL_STMT *stmt,\r\n                                         MYSQL_BIND *bind,\r\n                                         int *has_been_bound\r\n                                        )\r\n{\r\n  int i;\r\n  enum enum_field_types enum_type;\r\n  dTHX;\r\n  int execute_retval;\r\n  my_ulonglong rows=0;\r\n  D_imp_xxh(sth);\r\n\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                  \"\\t-> mysql_st_internal_execute41\\n\");\r\n\r\n  /* free result if exists */\r\n  if (*result)\r\n  {\r\n    mysql_free_result(*result);\r\n    *result= 0;\r\n  }\r\n\r\n  /*\r\n    If were performed any changes with ph variables\r\n    we have to rebind them\r\n  */\r\n\r\n  if (num_params > 0 && !(*has_been_bound))\r\n  {\r\n#if MYSQL_VERSION_ID >= 80300\r\n    if (mysql_stmt_bind_named_param(stmt,bind,num_params, NULL))\r\n#else\r\n    if (mysql_stmt_bind_param(stmt,bind))\r\n#endif\r\n      goto error;\r\n\r\n    *has_been_bound= 1;\r\n  }\r\n\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                  \"\\t\\tmysql_st_internal_execute41 calling mysql_execute with %d num_params\\n\",\r\n                  num_params);\r\n\r\n  execute_retval= mysql_stmt_execute(stmt);\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                  \"\\t\\tmysql_stmt_execute returned %d\\n\",\r\n                  execute_retval);\r\n  if (execute_retval)\r\n    goto error;\r\n\r\n  /*\r\n   This statement does not return a result set (INSERT, UPDATE...)\r\n  */\r\n  if (!(*result= mysql_stmt_result_metadata(stmt)))\r\n  {\r\n    if (mysql_stmt_errno(stmt))\r\n      goto error;\r\n\r\n    rows= mysql_stmt_affected_rows(stmt);\r\n\r\n    /* mysql_stmt_affected_rows(): -1 indicates that the query returned an error */\r\n    if (rows == (my_ulonglong)-1)\r\n      goto error;\r\n  }\r\n  /*\r\n    This statement returns a result set (SELECT...)\r\n  */\r\n  else\r\n  {\r\n    for (i = mysql_stmt_field_count(stmt) - 1; i >=0; --i) {\r\n        enum_type = mysql_to_perl_type(stmt->fields[i].type);\r\n        if (enum_type != MYSQL_TYPE_DOUBLE && enum_type != MYSQL_TYPE_LONG && enum_type != MYSQL_TYPE_LONGLONG && enum_type != MYSQL_TYPE_BIT)\r\n        {\r\n            /* mysql_stmt_store_result to update MYSQL_FIELD->max_length */\r\n            bool on = 1;\r\n            mysql_stmt_attr_set(stmt, STMT_ATTR_UPDATE_MAX_LENGTH, &on);\r\n            break;\r\n        }\r\n    }\r\n    /* Get the total rows affected and return */\r\n    if (mysql_stmt_store_result(stmt))\r\n      goto error;\r\n    else\r\n      rows= mysql_stmt_num_rows(stmt);\r\n  }\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                  \"\\t<- mysql_internal_execute_41 returning %lu rows\\n\",\r\n                  rows);\r\n  return(rows);\r\n\r\nerror:\r\n  if (*result)\r\n  {\r\n    mysql_free_result(*result);\r\n    *result= 0;\r\n  }\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                  \"     errno %d err message %s\\n\",\r\n                  mysql_stmt_errno(stmt),\r\n                  mysql_stmt_error(stmt));\r\n  do_error(sth, mysql_stmt_errno(stmt), mysql_stmt_error(stmt),\r\n           mysql_stmt_sqlstate(stmt));\r\n  mysql_stmt_reset(stmt);\r\n\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                  \"\\t<- mysql_st_internal_execute41\\n\");\r\n  return -2;\r\n\r\n}", ".bd_describe": "int dbd_describe(SV* sth, imp_sth_t* imp_sth)\r\n{\r\n  dTHX;\r\n  D_imp_xxh(sth);\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t--> dbd_describe\\n\");\r\n\r\n\r\n  if (imp_sth->use_server_side_prepare)\r\n  {\r\n    int i;\r\n    int col_type;\r\n    int num_fields= DBIc_NUM_FIELDS(imp_sth);\r\n    imp_sth_fbh_t *fbh;\r\n    MYSQL_BIND *buffer;\r\n    MYSQL_FIELD *fields;\r\n\r\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tdbd_describe() num_fields %d\\n\",\r\n                    num_fields);\r\n\r\n    if (imp_sth->done_desc)\r\n      return TRUE;\r\n\r\n    if (!num_fields || !imp_sth->result)\r\n    {\r\n      /* no metadata */\r\n      do_error(sth, JW_ERR_SEQUENCE,\r\n               \"no metadata information while trying describe result set\",\r\n               NULL);\r\n      return 0;\r\n    }\r\n\r\n    /* allocate fields buffers  */\r\n    if (  !(imp_sth->fbh= alloc_fbuffer(num_fields))\r\n          || !(imp_sth->buffer= alloc_bind(num_fields)) )\r\n    {\r\n      /* Out of memory */\r\n      do_error(sth, JW_ERR_SEQUENCE,\r\n               \"Out of memory in dbd_sescribe()\",NULL);\r\n      return 0;\r\n    }\r\n\r\n    fields= mysql_fetch_fields(imp_sth->result);\r\n\r\n    for (\r\n         fbh= imp_sth->fbh, buffer= (MYSQL_BIND*)imp_sth->buffer, i= 0;\r\n         i < num_fields;\r\n         i++, fbh++, buffer++\r\n        )\r\n    {\r\n      /* get the column type */\r\n      col_type = fields ? fields[i].type : MYSQL_TYPE_STRING;\r\n\r\n      if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n      {\r\n        PerlIO_printf(DBIc_LOGPIO(imp_xxh),\"\\t\\ti %d col_type %d fbh->length %lu\\n\",\r\n                      i, col_type, fbh->length);\r\n        PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                      \"\\t\\tfields[i].length %lu fields[i].max_length %lu fields[i].type %d fields[i].charsetnr %d\\n\",\r\n                      fields[i].length, fields[i].max_length, fields[i].type,\r\n                      fields[i].charsetnr);\r\n      }\r\n      fbh->charsetnr = fields[i].charsetnr;\r\n\r\n      buffer->buffer_type= mysql_to_perl_type(col_type);\r\n      if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n        PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tmysql_to_perl_type returned %d\\n\",\r\n                      col_type);\r\n      buffer->length= &(fbh->length);\r\n      buffer->is_null= &(fbh->is_null);\r\n      buffer->error= (bool*) &(fbh->error);\r\n\r\n      if (fields[i].flags & ZEROFILL_FLAG)\r\n        buffer->buffer_type = MYSQL_TYPE_STRING;\r\n\r\n      switch (buffer->buffer_type) {\r\n      case MYSQL_TYPE_DOUBLE:\r\n        buffer->buffer_length= sizeof(fbh->ddata);\r\n        buffer->buffer= (char*) &fbh->ddata;\r\n        break;\r\n\r\n      case MYSQL_TYPE_LONG:\r\n      case MYSQL_TYPE_LONGLONG:\r\n        buffer->buffer_length= sizeof(fbh->ldata);\r\n        buffer->buffer= (char*) &fbh->ldata;\r\n        buffer->is_unsigned= (fields[i].flags & UNSIGNED_FLAG) ? 1 : 0;\r\n        break;\r\n\r\n      case MYSQL_TYPE_BIT:\r\n        buffer->buffer_length= 8;\r\n        Newz(908, fbh->data, buffer->buffer_length, char);\r\n        buffer->buffer= (char *) fbh->data;\r\n        break;\r\n\r\n      default:\r\n        buffer->buffer_length= fields[i].max_length ? fields[i].max_length : 1;\r\n        Newz(908, fbh->data, buffer->buffer_length, char);\r\n        buffer->buffer= (char *) fbh->data;\r\n      }\r\n    }\r\n\r\n    if (mysql_stmt_bind_result(imp_sth->stmt, imp_sth->buffer))\r\n    {\r\n      do_error(sth, mysql_stmt_errno(imp_sth->stmt),\r\n               mysql_stmt_error(imp_sth->stmt),\r\n               mysql_stmt_sqlstate(imp_sth->stmt));\r\n      return 0;\r\n    }\r\n  }\r\n\r\n  imp_sth->done_desc= 1;\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t<- dbd_describe\\n\");\r\n  return TRUE;\r\n}", ".bd_bind_ph": "int dbd_bind_ph(SV *sth, imp_sth_t *imp_sth, SV *param, SV *value,\r\n\t\t IV sql_type, SV *attribs, int is_inout, IV maxlen) {\r\n  dTHX;\r\n  int rc;\r\n  int param_num= SvIV(param);\r\n  int idx= param_num - 1;\r\n  char *err_msg;\r\n  D_imp_xxh(sth);\r\n\r\n  STRLEN slen;\r\n  char *buffer= NULL;\r\n  int buffer_is_null= 0;\r\n  int buffer_is_unsigned= 0;\r\n  int buffer_length= 0;\r\n  unsigned int buffer_type= 0;\r\n\r\n  D_imp_dbh_from_sth;\r\n  ASYNC_CHECK_RETURN(sth, FALSE);\r\n\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                  \"   Called: dbd_bind_ph\\n\");\r\n\r\n  attribs= attribs;\r\n  maxlen= maxlen;\r\n\r\n  if (param_num <= 0  ||  param_num > DBIc_NUM_PARAMS(imp_sth))\r\n  {\r\n    do_error(sth, JW_ERR_ILLEGAL_PARAM_NUM, \"Illegal parameter number\", NULL);\r\n    return FALSE;\r\n  }\r\n\r\n  /*\r\n     This fixes the bug whereby no warning was issued upon binding a\r\n     defined non-numeric as numeric\r\n   */\r\n  if (SvOK(value) &&\r\n      (sql_type == SQL_NUMERIC  ||\r\n       sql_type == SQL_DECIMAL  ||\r\n       sql_type == SQL_INTEGER  ||\r\n       sql_type == SQL_SMALLINT ||\r\n       sql_type == SQL_FLOAT    ||\r\n       sql_type == SQL_REAL     ||\r\n       sql_type == SQL_DOUBLE) )\r\n  {\r\n    if (! looks_like_number(value))\r\n    {\r\n      err_msg = SvPVX(sv_2mortal(newSVpvf(\r\n              \"Binding non-numeric field %d, value %s as a numeric!\",\r\n              param_num, neatsvpv(value,0))));\r\n      do_error(sth, JW_ERR_ILLEGAL_PARAM_NUM, err_msg, NULL);\r\n    }\r\n  }\r\n\r\n  if (is_inout)\r\n  {\r\n    do_error(sth, JW_ERR_NOT_IMPLEMENTED, \"Output parameters not implemented\", NULL);\r\n    return FALSE;\r\n  }\r\n\r\n  rc = bind_param(&imp_sth->params[idx], value, sql_type);\r\n\r\n  if (imp_sth->use_server_side_prepare)\r\n  {\r\n      switch(sql_type) {\r\n      case SQL_NUMERIC:\r\n      case SQL_INTEGER:\r\n      case SQL_SMALLINT:\r\n      case SQL_TINYINT:\r\n#if IVSIZE >= 8\r\n      case SQL_BIGINT:\r\n          buffer_type= MYSQL_TYPE_LONGLONG;\r\n#else\r\n          buffer_type= MYSQL_TYPE_LONG;\r\n#endif\r\n          break;\r\n      case SQL_DOUBLE:\r\n      case SQL_DECIMAL: \r\n      case SQL_FLOAT: \r\n      case SQL_REAL:\r\n          buffer_type= MYSQL_TYPE_DOUBLE;\r\n          break;\r\n      case SQL_CHAR: \r\n      case SQL_VARCHAR: \r\n      case SQL_DATE: \r\n      case SQL_TIME: \r\n      case SQL_TIMESTAMP: \r\n      case SQL_LONGVARCHAR: \r\n      case SQL_BINARY: \r\n      case SQL_VARBINARY: \r\n      case SQL_LONGVARBINARY:\r\n          buffer_type= MYSQL_TYPE_BLOB;\r\n          break;\r\n      default:\r\n          buffer_type= MYSQL_TYPE_STRING;\r\n    }\r\n    buffer_is_null = !(SvOK(imp_sth->params[idx].value) && imp_sth->params[idx].value);\r\n    if (! buffer_is_null) {\r\n      switch(buffer_type) {\r\n        case MYSQL_TYPE_LONG:\r\n        case MYSQL_TYPE_LONGLONG:\r\n          /* INT */\r\n          if (!SvIOK(imp_sth->params[idx].value) && DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tTRY TO BIND AN INT NUMBER\\n\");\r\n          buffer_length = sizeof imp_sth->fbind[idx].numeric_val.lval;\r\n          imp_sth->fbind[idx].numeric_val.lval= SvIV(imp_sth->params[idx].value);\r\n          buffer=(void*)&(imp_sth->fbind[idx].numeric_val.lval);\r\n          if (!SvIOK(imp_sth->params[idx].value))\r\n          {\r\n            if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n              PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                            \"   Conversion to INT NUMBER was not successful -> '%s' --> (unsigned) '%\"UVuf\"' / (signed) '%\"IVdf\"' <- fallback to STRING\\n\",\r\n                            SvPV_nolen(imp_sth->params[idx].value), imp_sth->fbind[idx].numeric_val.lval, imp_sth->fbind[idx].numeric_val.lval);\r\n            buffer_type = MYSQL_TYPE_STRING;\r\n            break;\r\n          }\r\n          if (SvIsUV(imp_sth->params[idx].value))\r\n            buffer_is_unsigned= 1;\r\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                          \"   SCALAR type %\"IVdf\" ->%\"IVdf\"<- IS AN INT NUMBER\\n\",\r\n                          sql_type, *(IV *)buffer);\r\n          break;\r\n\r\n        case MYSQL_TYPE_DOUBLE:\r\n          if (!SvNOK(imp_sth->params[idx].value) && DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tTRY TO BIND A FLOAT NUMBER\\n\");\r\n          buffer_length = sizeof imp_sth->fbind[idx].numeric_val.dval;\r\n          imp_sth->fbind[idx].numeric_val.dval= SvNV(imp_sth->params[idx].value);\r\n          buffer=(char*)&(imp_sth->fbind[idx].numeric_val.dval);\r\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                          \"   SCALAR type %\"IVdf\" ->%f<- IS A FLOAT NUMBER\\n\",\r\n                          sql_type, (double)(*buffer));\r\n          break;\r\n\r\n        case MYSQL_TYPE_BLOB:\r\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                          \"   SCALAR type BLOB\\n\");\r\n          break;\r\n\r\n        case MYSQL_TYPE_STRING:\r\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                          \"   SCALAR type STRING %\"IVdf\", buffertype=%d\\n\", sql_type, buffer_type);\r\n          break;\r\n\r\n        default:\r\n          croak(\"Bug in DBD::Mysql file dbdimp.c#dbd_bind_ph: do not know how to handle unknown buffer type.\");\r\n      }\r\n\r\n      if (buffer_type == MYSQL_TYPE_STRING || buffer_type == MYSQL_TYPE_BLOB)\r\n      {\r\n        buffer= SvPV(imp_sth->params[idx].value, slen);\r\n        buffer_length= slen;\r\n        if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n          PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                        \" SCALAR type %\"IVdf\" ->length %d<- IS A STRING or BLOB\\n\",\r\n                        sql_type, buffer_length);\r\n      }\r\n    }\r\n    else\r\n    {\r\n      /*case: buffer_is_null != 0*/\r\n      buffer= NULL;\r\n      if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n        PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                      \"   SCALAR NULL VALUE: buffer type is: %d\\n\", buffer_type);\r\n    }\r\n\r\n    /* Type of column was changed. Force to rebind */\r\n    if (imp_sth->bind[idx].buffer_type != buffer_type || imp_sth->bind[idx].is_unsigned != buffer_is_unsigned) {\r\n      if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n          PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                        \"   FORCE REBIND: buffer type changed from %d to %d, sql-type=%\"IVdf\"\\n\",\r\n                        (int) imp_sth->bind[idx].buffer_type, buffer_type, sql_type);\r\n      imp_sth->has_been_bound = 0;\r\n    }\r\n\r\n    /* prepare has been called */\r\n    if (imp_sth->has_been_bound)\r\n    {\r\n      imp_sth->stmt->params[idx].buffer= buffer;\r\n      imp_sth->stmt->params[idx].buffer_length= buffer_length;\r\n    }\r\n\r\n    imp_sth->bind[idx].buffer_type= buffer_type;\r\n    imp_sth->bind[idx].buffer= buffer;\r\n    imp_sth->bind[idx].buffer_length= buffer_length;\r\n    imp_sth->bind[idx].is_unsigned= buffer_is_unsigned;\r\n\r\n    imp_sth->fbind[idx].length= buffer_length;\r\n    imp_sth->fbind[idx].is_null= buffer_is_null;\r\n  }\r\n  return rc;\r\n}", ".bd_db_login": "int dbd_db_login(SV* dbh, imp_dbh_t* imp_dbh, char* dbname, char* user,\r\n\t\t char* password) {\r\n#ifdef dTHR\r\n  dTHR;\r\n#endif\r\n  dTHX; \r\n  D_imp_xxh(dbh);\r\n\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n\t\t  \"imp_dbh->connect: dsn = %s, uid = %s, pwd = %s\\n\",\r\n\t\t  dbname ? dbname : \"NULL\",\r\n\t\t  user ? user : \"NULL\",\r\n\t\t  password ? password : \"NULL\");\r\n\r\n  imp_dbh->stats.auto_reconnects_ok= 0;\r\n  imp_dbh->stats.auto_reconnects_failed= 0;\r\n  imp_dbh->bind_type_guessing= FALSE;\r\n  imp_dbh->bind_comment_placeholders= FALSE;\r\n  imp_dbh->has_transactions= TRUE;\r\n /* Safer we flip this to TRUE perl side if we detect a mod_perl env. */\r\n  imp_dbh->auto_reconnect = FALSE;\r\n\r\n  imp_dbh->enable_utf8 = FALSE;     /* initialize mysql_enable_utf8 */\r\n  imp_dbh->enable_utf8mb4 = FALSE;  /* initialize mysql_enable_utf8mb4 */\r\n\r\n  if (!my_login(aTHX_ dbh, imp_dbh))\r\n  {\r\n    if(imp_dbh->pmysql) {\r\n        do_error(dbh, mysql_errno(imp_dbh->pmysql),\r\n                mysql_error(imp_dbh->pmysql) ,mysql_sqlstate(imp_dbh->pmysql));\r\n        Safefree(imp_dbh->pmysql);\r\n\r\n    }\r\n    return FALSE;\r\n  }\r\n\r\n    /*\r\n     *  Tell DBI, that dbh->disconnect should be called for this handle\r\n     */\r\n    DBIc_ACTIVE_on(imp_dbh);\r\n\r\n    /* Tell DBI, that dbh->destroy should be called for this handle */\r\n    DBIc_on(imp_dbh, DBIcf_IMPSET);\r\n\r\n    return TRUE;\r\n}", ".bd_db_commit": "int\r\ndbd_db_commit(SV* dbh, imp_dbh_t* imp_dbh)\r\n{\r\n  if (DBIc_has(imp_dbh, DBIcf_AutoCommit))\r\n    return FALSE;\r\n\r\n  ASYNC_CHECK_RETURN(dbh, FALSE);\r\n\r\n  if (imp_dbh->has_transactions)\r\n  {\r\n    if (mysql_commit(imp_dbh->pmysql))\r\n    {\r\n      do_error(dbh, mysql_errno(imp_dbh->pmysql), mysql_error(imp_dbh->pmysql)\r\n               ,mysql_sqlstate(imp_dbh->pmysql));\r\n      return FALSE;\r\n    }\r\n  }\r\n  else\r\n    do_warn(dbh, JW_ERR_NOT_IMPLEMENTED,\r\n            \"Commit ineffective because transactions are not available\");\r\n  return TRUE;\r\n}", ".bd_db_rollback": "int\r\ndbd_db_rollback(SV* dbh, imp_dbh_t* imp_dbh) {\r\n  /* croak, if not in AutoCommit mode */\r\n  if (DBIc_has(imp_dbh, DBIcf_AutoCommit))\r\n    return FALSE;\r\n\r\n  ASYNC_CHECK_RETURN(dbh, FALSE);\r\n\r\n  if (imp_dbh->has_transactions)\r\n  {\r\n      if (mysql_rollback(imp_dbh->pmysql))\r\n      {\r\n        do_error(dbh, mysql_errno(imp_dbh->pmysql),\r\n                 mysql_error(imp_dbh->pmysql) ,mysql_sqlstate(imp_dbh->pmysql));\r\n        return FALSE;\r\n      }\r\n  }\r\n  else\r\n    do_error(dbh, JW_ERR_NOT_IMPLEMENTED,\r\n             \"Rollback ineffective because transactions are not available\" ,NULL);\r\n  return TRUE;\r\n}", ".bd_db_destroy": "void dbd_db_destroy(SV* dbh, imp_dbh_t* imp_dbh) {\r\n\r\n    /*\r\n     *  Being on the safe side never hurts ...\r\n     */\r\n  if (DBIc_ACTIVE(imp_dbh))\r\n  {\r\n    if (imp_dbh->has_transactions)\r\n    {\r\n      if (!DBIc_has(imp_dbh, DBIcf_AutoCommit))\r\n        if (mysql_rollback(imp_dbh->pmysql))\r\n            do_error(dbh, TX_ERR_ROLLBACK,\"ROLLBACK failed\" ,NULL);\r\n    }\r\n    dbd_db_disconnect(dbh, imp_dbh);\r\n  }\r\n  Safefree(imp_dbh->pmysql);\r\n\r\n  /* Tell DBI, that dbh->destroy must no longer be called */\r\n  DBIc_off(imp_dbh, DBIcf_IMPSET);\r\n}", ".bd_db_STORE_attrib": "int\r\ndbd_db_STORE_attrib(\r\n                    SV* dbh,\r\n                    imp_dbh_t* imp_dbh,\r\n                    SV* keysv,\r\n                    SV* valuesv\r\n                   )\r\n{\r\n  dTHX;\r\n  STRLEN kl;\r\n  char *key = SvPV(keysv, kl);\r\n  SV *cachesv = Nullsv;\r\n  int cacheit = FALSE;\r\n  const bool bool_value = SvTRUE(valuesv);\r\n\r\n  if (kl==10 && strEQ(key, \"AutoCommit\"))\r\n  {\r\n    if (imp_dbh->has_transactions)\r\n    {\r\n      bool oldval = DBIc_has(imp_dbh,DBIcf_AutoCommit) ? 1 : 0;\r\n\r\n      if (bool_value == oldval)\r\n        return TRUE;\r\n\r\n      /* if setting AutoCommit on ... */\r\n      if (!imp_dbh->no_autocommit_cmd)\r\n      {\r\n        if (\r\n            mysql_autocommit(imp_dbh->pmysql, bool_value)\r\n           )\r\n        {\r\n          do_error(dbh, TX_ERR_AUTOCOMMIT,\r\n                   bool_value ?\r\n                   \"Turning on AutoCommit failed\" :\r\n                   \"Turning off AutoCommit failed\"\r\n                   ,NULL);\r\n          return TRUE;  /* TRUE means we handled it - important to avoid spurious errors */\r\n        }\r\n      }\r\n      DBIc_set(imp_dbh, DBIcf_AutoCommit, bool_value);\r\n    }\r\n    else\r\n    {\r\n      /*\r\n       *  We do support neither transactions nor \"AutoCommit\".\r\n       *  But we stub it. :-)\r\n      */\r\n      if (!bool_value)\r\n      {\r\n        do_error(dbh, JW_ERR_NOT_IMPLEMENTED,\r\n                 \"Transactions not supported by database\" ,NULL);\r\n        croak(\"Transactions not supported by database\");\r\n      }\r\n    }\r\n  }\r\n  else if (kl == 16 && strEQ(key,\"mysql_use_result\"))\r\n    imp_dbh->use_mysql_use_result = bool_value;\r\n  else if (kl == 20 && strEQ(key,\"mysql_auto_reconnect\"))\r\n    imp_dbh->auto_reconnect = bool_value;\r\n  else if (kl == 20 && strEQ(key, \"mysql_server_prepare\"))\r\n    imp_dbh->use_server_side_prepare = bool_value;\r\n  else if (kl == 37 && strEQ(key, \"mysql_server_prepare_disable_fallback\"))\r\n    imp_dbh->disable_fallback_for_server_prepare = bool_value;\r\n  else if (kl == 23 && strEQ(key,\"mysql_no_autocommit_cmd\"))\r\n    imp_dbh->no_autocommit_cmd = bool_value;\r\n  else if (kl == 24 && strEQ(key,\"mysql_bind_type_guessing\"))\r\n    imp_dbh->bind_type_guessing = bool_value;\r\n  else if (kl == 31 && strEQ(key,\"mysql_bind_comment_placeholders\"))\r\n    imp_dbh->bind_type_guessing = bool_value;\r\n  else if (kl == 17 && strEQ(key, \"mysql_enable_utf8\"))\r\n    imp_dbh->enable_utf8 = bool_value;\r\n  else if (kl == 20 && strEQ(key, \"mysql_enable_utf8mb4\"))\r\n    imp_dbh->enable_utf8mb4 = bool_value;\r\n  else\r\n    return FALSE;\t\t\t\t/* Unknown key */\r\n\r\n  if (cacheit) /* cache value for later DBI 'quick' fetch? */\r\n    (void)hv_store((HV*)SvRV(dbh), key, kl, cachesv, 0);\r\n  return TRUE;\r\n}", ".ysql_st_free_result_sets": "int mysql_st_free_result_sets (SV * sth, imp_sth_t * imp_sth)\r\n{\r\n  dTHX;\r\n  D_imp_dbh_from_sth;\r\n  D_imp_xxh(sth);\r\n  int next_result_rc= -1;\r\n\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t>- dbd_st_free_result_sets\\n\");\r\n\r\n  do\r\n  {\r\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t<- dbd_st_free_result_sets RC %d\\n\", next_result_rc);\r\n\r\n    if (next_result_rc == 0)\r\n    {\r\n      if (!(imp_sth->result = mysql_use_result(imp_dbh->pmysql)))\r\n      {\r\n        /* Check for possible error */\r\n        if (mysql_field_count(imp_dbh->pmysql))\r\n        {\r\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n          PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t<- dbd_st_free_result_sets ERROR: %s\\n\",\r\n                                  mysql_error(imp_dbh->pmysql));\r\n\r\n          do_error(sth, mysql_errno(imp_dbh->pmysql), mysql_error(imp_dbh->pmysql),\r\n                   mysql_sqlstate(imp_dbh->pmysql));\r\n          return 0;\r\n        }\r\n      }\r\n    }\r\n    if (imp_sth->result)\r\n    {\r\n      mysql_free_result(imp_sth->result);\r\n      imp_sth->result=NULL;\r\n    }\r\n  } while ((next_result_rc=mysql_next_result(imp_dbh->pmysql))==0);\r\n\r\n  if (next_result_rc > 0)\r\n  {\r\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t<- dbd_st_free_result_sets: Error while processing multi-result set: %s\\n\",\r\n                    mysql_error(imp_dbh->pmysql));\r\n\r\n    do_error(sth, mysql_errno(imp_dbh->pmysql), mysql_error(imp_dbh->pmysql),\r\n             mysql_sqlstate(imp_dbh->pmysql));\r\n  }\r\n\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t<- dbd_st_free_result_sets\\n\");\r\n\r\n  return 1;\r\n}", ".bd_st_more_results": "int dbd_st_more_results(SV* sth, imp_sth_t* imp_sth)\r\n{\r\n  dTHX;\r\n  D_imp_dbh_from_sth;\r\n  D_imp_xxh(sth);\r\n\r\n  int use_mysql_use_result=imp_sth->use_mysql_use_result;\r\n  int next_result_return_code, i;\r\n  MYSQL* svsock= imp_dbh->pmysql;\r\n\r\n  if (!SvROK(sth) || SvTYPE(SvRV(sth)) != SVt_PVHV)\r\n    croak(\"Expected hash array\");\r\n\r\n  if (!mysql_more_results(svsock))\r\n  {\r\n    /* No more pending result set(s)*/\r\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n\t\t    \"\\n      <- dbs_st_more_results no more results\\n\");\r\n    return 0;\r\n  }\r\n\r\n  if (imp_sth->use_server_side_prepare)\r\n  {\r\n    do_warn(sth, JW_ERR_NOT_IMPLEMENTED,\r\n            \"Processing of multiple result set is not possible with server side prepare\");\r\n    return 0;\r\n  }\r\n\r\n  /*\r\n   *  Free cached array attributes\r\n   */\r\n  for (i= 0; i < AV_ATTRIB_LAST;  i++)\r\n  {\r\n    if (imp_sth->av_attr[i])\r\n      SvREFCNT_dec(imp_sth->av_attr[i]);\r\n\r\n    imp_sth->av_attr[i]= Nullav;\r\n  }\r\n\r\n  /* Release previous MySQL result*/\r\n  if (imp_sth->result)\r\n  {\r\n    mysql_free_result(imp_sth->result);\r\n    imp_sth->result= NULL;\r\n  }\r\n\r\n  if (DBIc_ACTIVE(imp_sth))\r\n    DBIc_ACTIVE_off(imp_sth);\r\n\r\n  next_result_return_code= mysql_next_result(svsock);\r\n\r\n  imp_sth->warning_count = mysql_warning_count(imp_dbh->pmysql);\r\n\r\n  /*\r\n    mysql_next_result returns\r\n      0 if there are more results\r\n     -1 if there are no more results\r\n     >0 if there was an error\r\n   */\r\n  if (next_result_return_code > 0)\r\n  {\r\n    do_error(sth, mysql_errno(svsock), mysql_error(svsock),\r\n             mysql_sqlstate(svsock));\r\n\r\n    return 0;\r\n  }\r\n  else if(next_result_return_code == -1)                                                                                                                  \r\n  {                                                                                                                                                       \r\n    return 0;                                                                                                                                             \r\n  }  \r\n  else\r\n  {\r\n    /* Store the result from the Query */\r\n    imp_sth->result = use_mysql_use_result ?\r\n     mysql_use_result(svsock) : mysql_store_result(svsock);\r\n\r\n    if (mysql_errno(svsock))\r\n    {\r\n      do_error(sth, mysql_errno(svsock), mysql_error(svsock), \r\n               mysql_sqlstate(svsock));\r\n      return 0;\r\n    }\r\n\r\n    imp_sth->row_num= mysql_affected_rows(imp_dbh->pmysql);\r\n\r\n    if (imp_sth->result == NULL)\r\n    {\r\n      /* No \"real\" rowset*/\r\n      DBIc_NUM_FIELDS(imp_sth)= 0; /* for DBI <= 1.53 */\r\n      DBIS->set_attr_k(sth, sv_2mortal(newSVpvn(\"NUM_OF_FIELDS\",13)), 0,\r\n\t\t\t               sv_2mortal(newSViv(0)));\r\n      return 1;\r\n    }\r\n    else\r\n    {\r\n      /* We have a new rowset */\r\n      imp_sth->currow=0;\r\n\r\n\r\n      /* delete cached handle attributes */\r\n      /* XXX should be driven by a list to ease maintenance */\r\n      (void)hv_delete((HV*)SvRV(sth), \"NAME\", 4, G_DISCARD);\r\n      (void)hv_delete((HV*)SvRV(sth), \"NULLABLE\", 8, G_DISCARD);\r\n      (void)hv_delete((HV*)SvRV(sth), \"NUM_OF_FIELDS\", 13, G_DISCARD);\r\n      (void)hv_delete((HV*)SvRV(sth), \"PRECISION\", 9, G_DISCARD);\r\n      (void)hv_delete((HV*)SvRV(sth), \"SCALE\", 5, G_DISCARD);\r\n      (void)hv_delete((HV*)SvRV(sth), \"TYPE\", 4, G_DISCARD);\r\n      (void)hv_delete((HV*)SvRV(sth), \"mysql_insertid\", 14, G_DISCARD);\r\n      (void)hv_delete((HV*)SvRV(sth), \"mysql_is_auto_increment\", 23, G_DISCARD);\r\n      (void)hv_delete((HV*)SvRV(sth), \"mysql_is_blob\", 13, G_DISCARD);\r\n      (void)hv_delete((HV*)SvRV(sth), \"mysql_is_key\", 12, G_DISCARD);\r\n      (void)hv_delete((HV*)SvRV(sth), \"mysql_is_num\", 12, G_DISCARD);\r\n      (void)hv_delete((HV*)SvRV(sth), \"mysql_is_pri_key\", 16, G_DISCARD);\r\n      (void)hv_delete((HV*)SvRV(sth), \"mysql_length\", 12, G_DISCARD);\r\n      (void)hv_delete((HV*)SvRV(sth), \"mysql_max_length\", 16, G_DISCARD);\r\n      (void)hv_delete((HV*)SvRV(sth), \"mysql_table\", 11, G_DISCARD);\r\n      (void)hv_delete((HV*)SvRV(sth), \"mysql_type\", 10, G_DISCARD);\r\n      (void)hv_delete((HV*)SvRV(sth), \"mysql_type_name\", 15, G_DISCARD);\r\n      (void)hv_delete((HV*)SvRV(sth), \"mysql_warning_count\", 20, G_DISCARD);\r\n\r\n      /* Adjust NUM_OF_FIELDS - which also adjusts the row buffer size */\r\n      DBIc_NUM_FIELDS(imp_sth)= 0; /* for DBI <= 1.53 */\r\n      DBIc_DBISTATE(imp_sth)->set_attr_k(sth, sv_2mortal(newSVpvn(\"NUM_OF_FIELDS\",13)), 0,\r\n          sv_2mortal(newSViv(mysql_num_fields(imp_sth->result)))\r\n      );\r\n\r\n      DBIc_ACTIVE_on(imp_sth);\r\n\r\n      imp_sth->done_desc = 0;\r\n    }\r\n    imp_dbh->pmysql->net.last_errno= 0;\r\n    return 1;\r\n  }\r\n}", ".ysql_st_internal_execute": "my_ulonglong mysql_st_internal_execute(\r\n                                       SV *h, /* could be sth or dbh */\r\n                                       SV *statement,\r\n                                       SV *attribs,\r\n                                       int num_params,\r\n                                       imp_sth_ph_t *params,\r\n                                       MYSQL_RES **result,\r\n                                       MYSQL *svsock,\r\n                                       int use_mysql_use_result\r\n                                      )\r\n{\r\n  dTHX;\r\n  bool bind_type_guessing= FALSE;\r\n  bool bind_comment_placeholders= TRUE;\r\n  STRLEN slen;\r\n  char *sbuf = SvPV(statement, slen);\r\n  char *salloc;\r\n  int htype;\r\n  bool async = FALSE;\r\n  my_ulonglong rows= 0;\r\n  /* thank you DBI.c for this info! */\r\n  D_imp_xxh(h);\r\n  attribs= attribs;\r\n\r\n  htype= DBIc_TYPE(imp_xxh);\r\n  /*\r\n    It is important to import imp_dbh properly according to the htype\r\n    that it is! Also, one might ask why bind_type_guessing is assigned\r\n    in each block. Well, it's because D_imp_ macros called in these\r\n    blocks make it so imp_dbh is not \"visible\" or defined outside of the\r\n    if/else (when compiled, it fails for imp_dbh not being defined).\r\n  */\r\n  /* h is a dbh */\r\n  if (htype == DBIt_DB)\r\n  {\r\n    D_imp_dbh(h);\r\n    /* if imp_dbh is not available, it causes segfault (proper) on OpenBSD */\r\n    if (imp_dbh)\r\n    {\r\n      bind_type_guessing= imp_dbh->bind_type_guessing;\r\n      bind_comment_placeholders= imp_dbh->bind_comment_placeholders;\r\n    }\r\n    async = (bool) (imp_dbh->async_query_in_flight != NULL);\r\n  }\r\n  /* h is a sth */\r\n  else\r\n  {\r\n    D_imp_sth(h);\r\n    D_imp_dbh_from_sth;\r\n    /* if imp_dbh is not available, it causes segfault (proper) on OpenBSD */\r\n    if (imp_dbh)\r\n    {\r\n      bind_type_guessing= imp_dbh->bind_type_guessing;\r\n      bind_comment_placeholders= imp_dbh->bind_comment_placeholders;\r\n    }\r\n    async = imp_sth->is_async;\r\n    if(async) {\r\n        imp_dbh->async_query_in_flight = imp_sth;\r\n    } else {\r\n        imp_dbh->async_query_in_flight = NULL;\r\n    }\r\n  }\r\n\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"mysql_st_internal_execute MYSQL_VERSION_ID %d\\n\",\r\n                  MYSQL_VERSION_ID );\r\n\r\n  salloc= parse_params(imp_xxh,\r\n                              aTHX_ svsock,\r\n                              sbuf,\r\n                              &slen,\r\n                              params,\r\n                              num_params,\r\n                              bind_type_guessing,\r\n                              bind_comment_placeholders);\r\n\r\n  if (salloc)\r\n  {\r\n    sbuf= salloc;\r\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"Binding parameters: %s\\n\", sbuf);\r\n  }\r\n\r\n  if(async) {\r\n    if((mysql_send_query(svsock, sbuf, slen)) &&\r\n       (!mysql_db_reconnect(h) ||\r\n        (mysql_send_query(svsock, sbuf, slen))))\r\n    {\r\n        rows = -2;\r\n    } else {\r\n        rows = 0;\r\n    }\r\n  } else {\r\n      if ((mysql_real_query(svsock, sbuf, slen))  &&\r\n          (!mysql_db_reconnect(h)  ||\r\n           (mysql_real_query(svsock, sbuf, slen))))\r\n      {\r\n        rows = -2;\r\n      } else {\r\n          /** Store the result from the Query */\r\n          *result= use_mysql_use_result ?\r\n            mysql_use_result(svsock) : mysql_store_result(svsock);\r\n\r\n          if (mysql_errno(svsock))\r\n            rows = -2;\r\n          else if (*result)\r\n            rows = mysql_num_rows(*result);\r\n          else {\r\n            rows = mysql_affected_rows(svsock);\r\n            /* mysql_affected_rows(): -1 indicates that the query returned an error */\r\n            if (rows == (my_ulonglong)-1)\r\n              rows = -2;\r\n          }\r\n      }\r\n  }\r\n\r\n  if (salloc)\r\n    Safefree(salloc);\r\n\r\n  if(rows == (my_ulonglong)-2) {\r\n    do_error(h, mysql_errno(svsock), mysql_error(svsock), \r\n             mysql_sqlstate(svsock));\r\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"IGNORING ERROR errno %d\\n\", mysql_errno(svsock));\r\n  }\r\n  return(rows);\r\n}", ".bd_st_execute": "int dbd_st_execute(SV* sth, imp_sth_t* imp_sth)\r\n{\r\n  dTHX;\r\n  char actual_row_num[64];\r\n  int i;\r\n  SV **statement;\r\n  D_imp_dbh_from_sth;\r\n  D_imp_xxh(sth);\r\n#if defined (dTHR)\r\n  dTHR;\r\n#endif\r\n  int use_server_side_prepare = imp_sth->use_server_side_prepare;\r\n  int disable_fallback_for_server_prepare = imp_sth->disable_fallback_for_server_prepare;\r\n\r\n  ASYNC_CHECK_RETURN(sth, -2);\r\n\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n      \" -> dbd_st_execute for %p\\n\", sth);\r\n\r\n  if (!SvROK(sth)  ||  SvTYPE(SvRV(sth)) != SVt_PVHV)\r\n    croak(\"Expected hash array\");\r\n\r\n  /* Free cached array attributes */\r\n  for (i= 0;  i < AV_ATTRIB_LAST;  i++)\r\n  {\r\n    if (imp_sth->av_attr[i])\r\n      SvREFCNT_dec(imp_sth->av_attr[i]);\r\n\r\n    imp_sth->av_attr[i]= Nullav;\r\n  }\r\n\r\n  statement= hv_fetch((HV*) SvRV(sth), \"Statement\", 9, FALSE);\r\n\r\n  /* \r\n     Clean-up previous result set(s) for sth to prevent\r\n     'Commands out of sync' error \r\n  */\r\n  mysql_st_free_result_sets (sth, imp_sth);\r\n\r\n  if (use_server_side_prepare)\r\n  {\r\n    if (imp_sth->use_mysql_use_result)\r\n    {\r\n      if (disable_fallback_for_server_prepare)\r\n      {\r\n        do_error(sth, ER_UNSUPPORTED_PS,\r\n                 \"\\\"mysql_use_result\\\" not supported with server side prepare\",\r\n                 \"HY000\");\r\n        return 0;\r\n      }\r\n      use_server_side_prepare = 0;\r\n    }\r\n\r\n    if (use_server_side_prepare)\r\n    {\r\n      imp_sth->row_num= mysql_st_internal_execute41(\r\n                                                    sth,\r\n                                                    DBIc_NUM_PARAMS(imp_sth),\r\n                                                    &imp_sth->result,\r\n                                                    imp_sth->stmt,\r\n                                                    imp_sth->bind,\r\n                                                    &imp_sth->has_been_bound\r\n                                                   );\r\n      if (imp_sth->row_num == (my_ulonglong)-2) /* -2 means error */\r\n      {\r\n        SV *err = DBIc_ERR(imp_xxh);\r\n        if (!disable_fallback_for_server_prepare && SvIV(err) == ER_UNSUPPORTED_PS)\r\n        {\r\n          use_server_side_prepare = 0;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  if (!use_server_side_prepare)\r\n  {\r\n    imp_sth->row_num= mysql_st_internal_execute(\r\n                                                sth,\r\n                                                *statement,\r\n                                                NULL,\r\n                                                DBIc_NUM_PARAMS(imp_sth),\r\n                                                imp_sth->params,\r\n                                                &imp_sth->result,\r\n                                                imp_dbh->pmysql,\r\n                                                imp_sth->use_mysql_use_result\r\n                                               );\r\n    if(imp_dbh->async_query_in_flight) {\r\n        DBIc_ACTIVE_on(imp_sth);\r\n        return 0;\r\n    }\r\n  }\r\n\r\n  if (imp_sth->row_num+1 != (my_ulonglong)-1)\r\n  {\r\n    if (!imp_sth->result)\r\n    {\r\n      imp_sth->insertid= mysql_insert_id(imp_dbh->pmysql);\r\n      if (mysql_more_results(imp_dbh->pmysql))\r\n        DBIc_ACTIVE_on(imp_sth);\r\n    }\r\n    else\r\n    {\r\n      /** Store the result in the current statement handle */\r\n      DBIc_NUM_FIELDS(imp_sth)= mysql_num_fields(imp_sth->result);\r\n      DBIc_ACTIVE_on(imp_sth);\r\n      if (!use_server_side_prepare)\r\n        imp_sth->done_desc= 0;\r\n      imp_sth->fetch_done= 0;\r\n    }\r\n  }\r\n\r\n  imp_sth->warning_count = mysql_warning_count(imp_dbh->pmysql);\r\n\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n  {\r\n    /* \r\n      PerlIO_printf doesn't always handle imp_sth->row_num %llu \r\n      consistently!!\r\n    */\r\n    sprintf(actual_row_num, \"%lu\", imp_sth->row_num);\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                  \" <- dbd_st_execute returning imp_sth->row_num %s\\n\",\r\n                  actual_row_num);\r\n  }\r\n\r\n  return (int)imp_sth->row_num;\r\n}", ".bd_st_finish": "int dbd_st_finish(SV* sth, imp_sth_t* imp_sth) {\r\n  dTHX;\r\n  D_imp_xxh(sth);\r\n\r\n#if defined (dTHR)\r\n  dTHR;\r\n#endif\r\n\r\n  D_imp_dbh_from_sth;\r\n  if(imp_dbh->async_query_in_flight) {\r\n    mysql_db_async_result(sth, &imp_sth->result);\r\n  }\r\n\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n  {\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\n--> dbd_st_finish\\n\");\r\n  }\r\n\r\n  if (imp_sth->use_server_side_prepare)\r\n  {\r\n    if (imp_sth && imp_sth->stmt)\r\n    {\r\n      if (!mysql_st_clean_cursor(sth, imp_sth))\r\n      {\r\n        do_error(sth, JW_ERR_SEQUENCE,\r\n                 \"Error happened while tried to clean up stmt\",NULL);\r\n        return 0;\r\n      }\r\n    }\r\n  }\r\n\r\n  /*\r\n    Cancel further fetches from this cursor.\r\n    We don't close the cursor till DESTROY.\r\n    The application may re execute it.\r\n  */\r\n  if (imp_sth && DBIc_ACTIVE(imp_sth))\r\n  {\r\n    /*\r\n      Clean-up previous result set(s) for sth to prevent\r\n      'Commands out of sync' error\r\n    */\r\n    mysql_st_free_result_sets(sth, imp_sth);\r\n  }\r\n  DBIc_ACTIVE_off(imp_sth);\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n  {\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\n<-- dbd_st_finish\\n\");\r\n  }\r\n  return 1;\r\n}", ".ysql_db_reconnect": "int mysql_db_reconnect(SV* h)\r\n{\r\n  dTHX;\r\n  D_imp_xxh(h);\r\n  imp_dbh_t* imp_dbh;\r\n  MYSQL save_socket;\r\n\r\n  if (DBIc_DBISTATE(imp_xxh)->debug >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"reconnecting\\n\");\r\n\r\n  if (DBIc_TYPE(imp_xxh) == DBIt_ST)\r\n  {\r\n    imp_dbh = (imp_dbh_t*) DBIc_PARENT_COM(imp_xxh);\r\n    h = DBIc_PARENT_H(imp_xxh);\r\n  }\r\n  else\r\n    imp_dbh= (imp_dbh_t*) imp_xxh;\r\n\r\n  /* reconnect a closed connection, used in do() for implicit reconnect */\r\n  if (!DBIc_has(imp_dbh, DBIcf_ACTIVE) && DBIc_has(imp_dbh, DBIcf_AutoCommit)) {\r\n    if (my_login(aTHX_ h, imp_dbh)) {\r\n      DBIc_ACTIVE_on(imp_dbh);\r\n      DBIc_set(imp_dbh, DBIcf_AutoCommit, TRUE);\r\n      return TRUE;\r\n    }\r\n    return FALSE;\r\n  }\r\n\r\n  if (mysql_errno(imp_dbh->pmysql) != CR_SERVER_GONE_ERROR &&\r\n#ifdef ER_CLIENT_INTERACTION_TIMEOUT /* Added in 8.0.24 */\r\n          mysql_errno(imp_dbh->pmysql) != ER_CLIENT_INTERACTION_TIMEOUT &&\r\n#endif\r\n          mysql_errno(imp_dbh->pmysql) != CR_SERVER_LOST) {\r\n    /* Other error */\r\n    if (DBIc_DBISTATE(imp_xxh)->debug >= 2)\r\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"Can't reconnect on unexpected error %d\\n\",\r\n          mysql_errno(imp_dbh->pmysql));\r\n    return FALSE;\r\n  }\r\n\r\n  if (!DBIc_has(imp_dbh, DBIcf_AutoCommit) || !imp_dbh->auto_reconnect)\r\n  {\r\n    /* We never reconnect if AutoCommit is turned off.\r\n     * Otherwise we might get an inconsistent transaction\r\n     * state.\r\n     */\r\n    if (DBIc_DBISTATE(imp_xxh)->debug >= 2)\r\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"Can't reconnect as AutoCommit is turned off\\n\");\r\n    return FALSE;\r\n  }\r\n\r\n  /* my_login will blow away imp_dbh->mysql so we save a copy of\r\n   * imp_dbh->mysql and put it back where it belongs if the reconnect\r\n   * fail.  Think server is down & reconnect fails but the application eval{}s\r\n   * the execute, so next time $dbh->quote() gets called, instant SIGSEGV!\r\n   */\r\n  save_socket= *(imp_dbh->pmysql);\r\n  memcpy (&save_socket, imp_dbh->pmysql,sizeof(save_socket));\r\n  memset (imp_dbh->pmysql,0,sizeof(*(imp_dbh->pmysql)));\r\n\r\n  /* we should disconnect the db handle before reconnecting, this will\r\n   * prevent my_login from thinking it's adopting an active child which\r\n   * would prevent the handle from actually reconnecting\r\n   */\r\n  if (!dbd_db_disconnect(h, imp_dbh) || !my_login(aTHX_ h, imp_dbh))\r\n  {\r\n    do_error(h, mysql_errno(imp_dbh->pmysql), mysql_error(imp_dbh->pmysql),\r\n             mysql_sqlstate(imp_dbh->pmysql));\r\n    memcpy (imp_dbh->pmysql, &save_socket, sizeof(save_socket));\r\n    ++imp_dbh->stats.auto_reconnects_failed;\r\n    return FALSE;\r\n  }\r\n\r\n  /*\r\n   *  Tell DBI, that dbh->disconnect should be called for this handle\r\n   */\r\n  DBIc_ACTIVE_on(imp_dbh);\r\n\r\n  ++imp_dbh->stats.auto_reconnects_ok;\r\n  return TRUE;\r\n}", ".ysql_db_async_result": "int mysql_db_async_result(SV* h, MYSQL_RES** resp)\r\n{\r\n  dTHX;\r\n  D_imp_xxh(h);\r\n  imp_dbh_t* dbh;\r\n  MYSQL* svsock = NULL;\r\n  MYSQL_RES* _res;\r\n  int retval = 0;\r\n  int htype;\r\n  bool async_sth = FALSE;\r\n\r\n  if(! resp) {\r\n      resp = &_res;\r\n  }\r\n  htype = DBIc_TYPE(imp_xxh);\r\n\r\n\r\n  if(htype == DBIt_DB) {\r\n      D_imp_dbh(h);\r\n      dbh = imp_dbh;\r\n  } else {\r\n      D_imp_sth(h);\r\n      D_imp_dbh_from_sth;\r\n      dbh = imp_dbh;\r\n      async_sth = imp_sth->is_async;\r\n      retval = imp_sth->row_num;\r\n  }\r\n\r\n  if(! dbh->async_query_in_flight) {\r\n      if (async_sth)\r\n          return retval;\r\n      do_error(h, 2000, \"Gathering asynchronous results for a synchronous handle\", \"HY000\");\r\n      return -1;\r\n  }\r\n  if(dbh->async_query_in_flight != imp_xxh) {\r\n      do_error(h, 2000, \"Gathering async_query_in_flight results for the wrong handle\", \"HY000\");\r\n      return -1;\r\n  }\r\n  dbh->async_query_in_flight = NULL;\r\n\r\n  svsock= dbh->pmysql;\r\n  retval= mysql_read_query_result(svsock);\r\n  if(! retval) {\r\n    *resp= mysql_store_result(svsock);\r\n\r\n    if (mysql_errno(svsock))\r\n      do_error(h, mysql_errno(svsock), mysql_error(svsock), mysql_sqlstate(svsock));\r\n    if (!*resp)\r\n      retval= mysql_affected_rows(svsock);\r\n    else {\r\n      retval= mysql_num_rows(*resp);\r\n      if(resp == &_res) {\r\n        mysql_free_result(*resp);\r\n        *resp= NULL;\r\n      }\r\n    }\r\n    if(htype == DBIt_ST) {\r\n      D_imp_sth(h);\r\n      D_imp_dbh_from_sth;\r\n\r\n      if((my_ulonglong)retval+1 != (my_ulonglong)-1) {\r\n        if(! *resp) {\r\n          imp_sth->insertid= mysql_insert_id(svsock);\r\n          if(! mysql_more_results(svsock))\r\n            DBIc_ACTIVE_off(imp_sth);\r\n        } else {\r\n          DBIc_NUM_FIELDS(imp_sth)= mysql_num_fields(imp_sth->result);\r\n          imp_sth->done_desc= 0;\r\n          imp_sth->fetch_done= 0;\r\n        }\r\n      }\r\n      imp_sth->warning_count = mysql_warning_count(imp_dbh->pmysql);\r\n    }\r\n  } else {\r\n     do_error(h, mysql_errno(svsock), mysql_error(svsock),\r\n              mysql_sqlstate(svsock));\r\n     return -1;\r\n  }\r\n return retval;\r\n}", ".ysql_db_async_ready": "int mysql_db_async_ready(SV* h)\r\n{\r\n  dTHX;\r\n  D_imp_xxh(h);\r\n  imp_dbh_t* dbh;\r\n  int htype;\r\n  bool async_sth = FALSE;\r\n  bool async_active = FALSE;\r\n\r\n  htype = DBIc_TYPE(imp_xxh);\r\n  \r\n  if(htype == DBIt_DB) {\r\n      D_imp_dbh(h);\r\n      dbh = imp_dbh;\r\n  } else {\r\n      D_imp_sth(h);\r\n      D_imp_dbh_from_sth;\r\n      dbh = imp_dbh;\r\n      async_sth = imp_sth->is_async;\r\n      async_active = !!DBIc_ACTIVE(imp_sth);\r\n  }\r\n\r\n  if(dbh->async_query_in_flight) {\r\n      if(dbh->async_query_in_flight == imp_xxh && dbh->pmysql->net.fd != -1) {\r\n          int retval = mysql_socket_ready(dbh->pmysql->net.fd);\r\n          if(retval < 0) {\r\n              do_error(h, -retval, strerror(-retval), \"HY000\");\r\n          }\r\n          return retval;\r\n      } else {\r\n          do_error(h, 2000, \"Calling mysql_async_ready on the wrong handle\", \"HY000\");\r\n          return -1;\r\n      }\r\n  } else {\r\n      if (async_sth) {\r\n          if (async_active)\r\n              return 1;\r\n          do_error(h, 2000, \"Asynchronous handle was not executed yet\", \"HY000\");\r\n          return -1;\r\n      }\r\n      do_error(h, 2000, \"Handle is not in asynchronous mode\", \"HY000\");\r\n      return -1;\r\n  }\r\n}", ".ysql_st_clean_cursor": "int mysql_st_clean_cursor(SV* sth, imp_sth_t* imp_sth) {\r\n\r\n  if (DBIc_ACTIVE(imp_sth) && dbd_describe(sth, imp_sth) &&\r\n      !imp_sth->fetch_done)\r\n    mysql_stmt_free_result(imp_sth->stmt);\r\n  return 1;\r\n}"}, "function_name": "parse_number"}
{"function_id": null, "caller": {".cp_gro_dev_warn": "static __cold void tcp_gro_dev_warn(const struct sock *sk, const struct sk_buff *skb,\r\n\t\t\t\t    unsigned int len)\r\n{\r\n\tstruct net_device *dev;\r\n\r\n\trcu_read_lock();\r\n\tdev = dev_get_by_index_rcu(sock_net(sk), skb->skb_iif);\r\n\tif (!dev || len >= READ_ONCE(dev->mtu))\r\n\t\tpr_warn(\"%s: Driver has suspect GRO implementation, TCP performance may be compromised.\\n\",\r\n\t\t\tdev ? dev->name : \"Unknown driver\");\r\n\trcu_read_unlock();\r\n}", ".cp_incr_quickack": "static void tcp_incr_quickack(struct sock *sk, unsigned int max_quickacks)\r\n{\r\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\r\n\tunsigned int quickacks = tcp_sk(sk)->rcv_wnd / (2 * icsk->icsk_ack.rcv_mss);\r\n\r\n\tif (quickacks == 0)\r\n\t\tquickacks = 2;\r\n\tquickacks = min(quickacks, max_quickacks);\r\n\tif (quickacks > icsk->icsk_ack.quick)\r\n\t\ticsk->icsk_ack.quick = quickacks;\r\n}", ".cp_enter_quickack_mode": "static void tcp_enter_quickack_mode(struct sock *sk, unsigned int max_quickacks)\r\n{\r\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\r\n\r\n\ttcp_incr_quickack(sk, max_quickacks);\r\n\tinet_csk_exit_pingpong_mode(sk);\r\n\ticsk->icsk_ack.ato = TCP_ATO_MIN;\r\n}", ".cp_count_delivered_ce": "static void tcp_count_delivered_ce(struct tcp_sock *tp, u32 ecn_count)\r\n{\r\n\ttp->delivered_ce += ecn_count;\r\n}", ".ruesize_adjust": "static u32 truesize_adjust(bool adjust, const struct sk_buff *skb)\r\n{\r\n\tu32 truesize = skb->truesize;\r\n\r\n\tif (adjust && !skb_headlen(skb)) {\r\n\t\ttruesize -= SKB_TRUESIZE(skb_end_offset(skb));\r\n\t\t/* paranoid check, some drivers might be buggy */\r\n\t\tif (unlikely((int)truesize < (int)skb->len))\r\n\t\t\ttruesize = skb->truesize;\r\n\t}\r\n\treturn truesize;\r\n}", ".cp_sndbuf_expand": "static void tcp_sndbuf_expand(struct sock *sk)\r\n{\r\n\tconst struct tcp_sock *tp = tcp_sk(sk);\r\n\tconst struct tcp_congestion_ops *ca_ops = inet_csk(sk)->icsk_ca_ops;\r\n\tint sndmem, per_mss;\r\n\tu32 nr_segs;\r\n\r\n\t/* Worst case is non GSO/TSO : each frame consumes one skb\r\n\t * and skb->head is kmalloced using power of two area of memory\r\n\t */\r\n\tper_mss = max_t(u32, tp->rx_opt.mss_clamp, tp->mss_cache) +\r\n\t\t  MAX_TCP_HEADER +\r\n\t\t  SKB_DATA_ALIGN(sizeof(struct skb_shared_info));\r\n\r\n\tper_mss = roundup_pow_of_two(per_mss) +\r\n\t\t  SKB_DATA_ALIGN(sizeof(struct sk_buff));\r\n\r\n\tnr_segs = max_t(u32, TCP_INIT_CWND, tcp_snd_cwnd(tp));\r\n\tnr_segs = max_t(u32, nr_segs, tp->reordering + 1);\r\n\r\n\t/* Fast Recovery (RFC 5681 3.2) :\r\n\t * Cubic needs 1.7 factor, rounded to 2 to include\r\n\t * extra cushion (application might react slowly to EPOLLOUT)\r\n\t */\r\n\tsndmem = ca_ops->sndbuf_expand ? ca_ops->sndbuf_expand(sk) : 2;\r\n\tsndmem *= nr_segs * per_mss;\r\n\r\n\tif (sk->sk_sndbuf < sndmem)\r\n\t\tWRITE_ONCE(sk->sk_sndbuf,\r\n\t\t\t   min(sndmem, READ_ONCE(sock_net(sk)->ipv4.sysctl_tcp_wmem[2])));\r\n}", ".cp_rcv_rtt_update": "static void tcp_rcv_rtt_update(struct tcp_sock *tp, u32 sample, int win_dep)\r\n{\r\n\tu32 new_sample, old_sample = tp->rcv_rtt_est.rtt_us;\r\n\tlong m = sample << 3;\r\n\r\n\tif (old_sample == 0 || m < old_sample) {\r\n\t\tnew_sample = m;\r\n\t} else {\r\n\t\t/* If we sample in larger samples in the non-timestamp\r\n\t\t * case, we could grossly overestimate the RTT especially\r\n\t\t * with chatty applications or bulk transfer apps which\r\n\t\t * are stalled on filesystem I/O.\r\n\t\t *\r\n\t\t * Also, since we are only going for a minimum in the\r\n\t\t * non-timestamp case, we do not smooth things out\r\n\t\t * else with timestamps disabled convergence takes too\r\n\t\t * long.\r\n\t\t */\r\n\t\tif (win_dep)\r\n\t\t\treturn;\r\n\t\t/* Do not use this sample if receive queue is not empty. */\r\n\t\tif (tp->rcv_nxt != tp->copied_seq)\r\n\t\t\treturn;\r\n\t\tnew_sample = old_sample - (old_sample >> 3) + sample;\r\n\t}\r\n\r\n\ttp->rcv_rtt_est.rtt_us = new_sample;\r\n}", ".cp_rtt_tsopt_us": "static s32 tcp_rtt_tsopt_us(const struct tcp_sock *tp, u32 min_delta)\r\n{\r\n\tu32 delta, delta_us;\r\n\r\n\tdelta = tcp_time_stamp_ts(tp) - tp->rx_opt.rcv_tsecr;\r\n\tif (tp->tcp_usec_ts)\r\n\t\treturn delta;\r\n\r\n\tif (likely(delta < INT_MAX / (USEC_PER_SEC / TCP_TS_HZ))) {\r\n\t\tif (!delta)\r\n\t\t\tdelta = min_delta;\r\n\t\tdelta_us = delta * (USEC_PER_SEC / TCP_TS_HZ);\r\n\t\treturn delta_us;\r\n\t}\r\n\treturn -1;\r\n}", ".cp_rcvbuf_grow": "void tcp_rcvbuf_grow(struct sock *sk)\r\n{\r\n\tconst struct net *net = sock_net(sk);\r\n\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\tint rcvwin, rcvbuf, cap;\r\n\r\n\tif (!READ_ONCE(net->ipv4.sysctl_tcp_moderate_rcvbuf) ||\r\n\t    (sk->sk_userlocks & SOCK_RCVBUF_LOCK))\r\n\t\treturn;\r\n\r\n\t/* slow start: allow the sender to double its rate. */\r\n\trcvwin = tp->rcvq_space.space << 1;\r\n\r\n\tif (!RB_EMPTY_ROOT(&tp->out_of_order_queue))\r\n\t\trcvwin += TCP_SKB_CB(tp->ooo_last_skb)->end_seq - tp->rcv_nxt;\r\n\r\n\tcap = READ_ONCE(net->ipv4.sysctl_tcp_rmem[2]);\r\n\r\n\trcvbuf = min_t(u32, tcp_space_from_win(sk, rcvwin), cap);\r\n\tif (rcvbuf > sk->sk_rcvbuf) {\r\n\t\tWRITE_ONCE(sk->sk_rcvbuf, rcvbuf);\r\n\t\t/* Make the window clamp follow along.  */\r\n\t\tWRITE_ONCE(tp->window_clamp,\r\n\t\t\t   tcp_win_from_space(sk, rcvbuf));\r\n\t}\r\n}", ".cp_measure_rcv_mss": "static void tcp_measure_rcv_mss(struct sock *sk, const struct sk_buff *skb)\r\n{\r\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\r\n\tconst unsigned int lss = icsk->icsk_ack.last_seg_size;\r\n\tunsigned int len;\r\n\r\n\ticsk->icsk_ack.last_seg_size = 0;\r\n\r\n\t/* skb->len may jitter because of SACKs, even if peer\r\n\t * sends good full-sized frames.\r\n\t */\r\n\tlen = skb_shinfo(skb)->gso_size ? : skb->len;\r\n\tif (len >= icsk->icsk_ack.rcv_mss) {\r\n\t\t/* Note: divides are still a bit expensive.\r\n\t\t * For the moment, only adjust scaling_ratio\r\n\t\t * when we update icsk_ack.rcv_mss.\r\n\t\t */\r\n\t\tif (unlikely(len != icsk->icsk_ack.rcv_mss)) {\r\n\t\t\tu64 val = (u64)skb->len << TCP_RMEM_TO_WIN_SCALE;\r\n\t\t\tu8 old_ratio = tcp_sk(sk)->scaling_ratio;\r\n\r\n\t\t\tdo_div(val, skb->truesize);\r\n\t\t\ttcp_sk(sk)->scaling_ratio = val ? val : 1;\r\n\r\n\t\t\tif (old_ratio != tcp_sk(sk)->scaling_ratio) {\r\n\t\t\t\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\r\n\t\t\t\tval = tcp_win_from_space(sk, sk->sk_rcvbuf);\r\n\t\t\t\ttcp_set_window_clamp(sk, val);\r\n\r\n\t\t\t\tif (tp->window_clamp < tp->rcvq_space.space)\r\n\t\t\t\t\ttp->rcvq_space.space = tp->window_clamp;\r\n\t\t\t}\r\n\t\t}\r\n\t\ticsk->icsk_ack.rcv_mss = min_t(unsigned int, len,\r\n\t\t\t\t\t       tcp_sk(sk)->advmss);\r\n\t\t/* Account for possibly-removed options */\r\n\t\tDO_ONCE_LITE_IF(len > icsk->icsk_ack.rcv_mss + MAX_TCP_OPTION_SPACE,\r\n\t\t\t\ttcp_gro_dev_warn, sk, skb, len);\r\n\t\t/* If the skb has a len of exactly 1*MSS and has the PSH bit\r\n\t\t * set then it is likely the end of an application write. So\r\n\t\t * more data may not be arriving soon, and yet the data sender\r\n\t\t * may be waiting for an ACK if cwnd-bound or using TX zero\r\n\t\t * copy. So we set ICSK_ACK_PUSHED here so that\r\n\t\t * tcp_cleanup_rbuf() will send an ACK immediately if the app\r\n\t\t * reads all of the data and is not ping-pong. If len > MSS\r\n\t\t * then this logic does not matter (and does not hurt) because\r\n\t\t * tcp_cleanup_rbuf() will always ACK immediately if the app\r\n\t\t * reads data and there is more than an MSS of unACKed data.\r\n\t\t */\r\n\t\tif (TCP_SKB_CB(skb)->tcp_flags & TCPHDR_PSH)\r\n\t\t\ticsk->icsk_ack.pending |= ICSK_ACK_PUSHED;\r\n\t} else {\r\n\t\t/* Otherwise, we make more careful check taking into account,\r\n\t\t * that SACKs block is variable.\r\n\t\t *\r\n\t\t * \"len\" is invariant segment length, including TCP header.\r\n\t\t */\r\n\t\tlen += skb->data - skb_transport_header(skb);\r\n\t\tif (len >= TCP_MSS_DEFAULT + sizeof(struct tcphdr) ||\r\n\t\t    /* If PSH is not set, packet should be\r\n\t\t     * full sized, provided peer TCP is not badly broken.\r\n\t\t     * This observation (if it is correct 8)) allows\r\n\t\t     * to handle super-low mtu links fairly.\r\n\t\t     */\r\n\t\t    (len >= TCP_MIN_MSS + sizeof(struct tcphdr) &&\r\n\t\t     !(tcp_flag_word(tcp_hdr(skb)) & TCP_REMNANT))) {\r\n\t\t\t/* Subtract also invariant (if peer is RFC compliant),\r\n\t\t\t * tcp header plus fixed timestamp option length.\r\n\t\t\t * Resulting \"len\" is MSS free of SACK jitter.\r\n\t\t\t */\r\n\t\t\tlen -= tcp_sk(sk)->tcp_header_len;\r\n\t\t\ticsk->icsk_ack.last_seg_size = len;\r\n\t\t\tif (len == lss) {\r\n\t\t\t\ticsk->icsk_ack.rcv_mss = len;\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (icsk->icsk_ack.pending & ICSK_ACK_PUSHED)\r\n\t\t\ticsk->icsk_ack.pending |= ICSK_ACK_PUSHED2;\r\n\t\ticsk->icsk_ack.pending |= ICSK_ACK_PUSHED;\r\n\t}\r\n}", ".cp_rcv_rtt_measure": "static inline void tcp_rcv_rtt_measure(struct tcp_sock *tp)\r\n{\r\n\tu32 delta_us;\r\n\r\n\tif (tp->rcv_rtt_est.time == 0)\r\n\t\tgoto new_measure;\r\n\tif (before(tp->rcv_nxt, tp->rcv_rtt_est.seq))\r\n\t\treturn;\r\n\tdelta_us = tcp_stamp_us_delta(tp->tcp_mstamp, tp->rcv_rtt_est.time);\r\n\tif (!delta_us)\r\n\t\tdelta_us = 1;\r\n\ttcp_rcv_rtt_update(tp, delta_us, 1);\r\n\r\nnew_measure:\r\n\ttp->rcv_rtt_est.seq = tp->rcv_nxt + tp->rcv_wnd;\r\n\ttp->rcv_rtt_est.time = tp->tcp_mstamp;\r\n}", ".cp_save_lrcv_flowlabel": "static void tcp_save_lrcv_flowlabel(struct sock *sk, const struct sk_buff *skb)\r\n{\r\n#if IS_ENABLED(CONFIG_IPV6)\r\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\r\n\r\n\tif (skb->protocol == htons(ETH_P_IPV6))\r\n\t\ticsk->icsk_ack.lrcv_flowlabel = ntohl(ip6_flowlabel(ipv6_hdr(skb)));\r\n#endif\r\n}", ".cp_data_ecn_check": "static void tcp_data_ecn_check(struct sock *sk, const struct sk_buff *skb)\r\n{\r\n\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\r\n\tif (tcp_ecn_disabled(tp))\r\n\t\treturn;\r\n\r\n\tswitch (TCP_SKB_CB(skb)->ip_dsfield & INET_ECN_MASK) {\r\n\tcase INET_ECN_NOT_ECT:\r\n\t\t/* Funny extension: if ECT is not set on a segment,\r\n\t\t * and we already seen ECT on a previous segment,\r\n\t\t * it is probably a retransmit.\r\n\t\t */\r\n\t\tif (tp->ecn_flags & TCP_ECN_SEEN)\r\n\t\t\ttcp_enter_quickack_mode(sk, 2);\r\n\t\tbreak;\r\n\tcase INET_ECN_CE:\r\n\t\tif (tcp_ca_needs_ecn(sk))\r\n\t\t\ttcp_ca_event(sk, CA_EVENT_ECN_IS_CE);\r\n\r\n\t\tif (!(tp->ecn_flags & TCP_ECN_DEMAND_CWR) &&\r\n\t\t    tcp_ecn_mode_rfc3168(tp)) {\r\n\t\t\t/* Better not delay acks, sender can have a very low cwnd */\r\n\t\t\ttcp_enter_quickack_mode(sk, 2);\r\n\t\t\ttp->ecn_flags |= TCP_ECN_DEMAND_CWR;\r\n\t\t}\r\n\t\t/* As for RFC3168 ECN, the TCP_ECN_SEEN flag is set by\r\n\t\t * tcp_data_ecn_check() when the ECN codepoint of\r\n\t\t * received TCP data contains ECT(0), ECT(1), or CE.\r\n\t\t */\r\n\t\tif (!tcp_ecn_mode_rfc3168(tp))\r\n\t\t\tbreak;\r\n\t\ttp->ecn_flags |= TCP_ECN_SEEN;\r\n\t\tbreak;\r\n\tdefault:\r\n\t\tif (tcp_ca_needs_ecn(sk))\r\n\t\t\ttcp_ca_event(sk, CA_EVENT_ECN_NO_CE);\r\n\t\tif (!tcp_ecn_mode_rfc3168(tp))\r\n\t\t\tbreak;\r\n\t\ttp->ecn_flags |= TCP_ECN_SEEN;\r\n\t\tbreak;\r\n\t}\r\n}", ".cp_grow_window": "static void tcp_grow_window(struct sock *sk, const struct sk_buff *skb,\r\n\t\t\t    bool adjust)\r\n{\r\n\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\tint room;\r\n\r\n\troom = min_t(int, tp->window_clamp, tcp_space(sk)) - tp->rcv_ssthresh;\r\n\r\n\tif (room <= 0)\r\n\t\treturn;\r\n\r\n\t/* Check #1 */\r\n\tif (!tcp_under_memory_pressure(sk)) {\r\n\t\tunsigned int truesize = truesize_adjust(adjust, skb);\r\n\t\tint incr;\r\n\r\n\t\t/* Check #2. Increase window, if skb with such overhead\r\n\t\t * will fit to rcvbuf in future.\r\n\t\t */\r\n\t\tif (tcp_win_from_space(sk, truesize) <= skb->len)\r\n\t\t\tincr = 2 * tp->advmss;\r\n\t\telse\r\n\t\t\tincr = __tcp_grow_window(sk, skb, truesize);\r\n\r\n\t\tif (incr) {\r\n\t\t\tincr = max_t(int, incr, 2 * skb->len);\r\n\t\t\ttp->rcv_ssthresh += min(room, incr);\r\n\t\t\tinet_csk(sk)->icsk_ack.quick |= 1;\r\n\t\t}\r\n\t} else {\r\n\t\t/* Under pressure:\r\n\t\t * Adjust rcv_ssthresh according to reserved mem\r\n\t\t */\r\n\t\ttcp_adjust_rcv_ssthresh(sk);\r\n\t}\r\n}", ".cp_verify_retransmit_hint": "static void tcp_verify_retransmit_hint(struct tcp_sock *tp, struct sk_buff *skb)\r\n{\r\n\tif ((!tp->retransmit_skb_hint && tp->retrans_out >= tp->lost_out) ||\r\n\t    (tp->retransmit_skb_hint &&\r\n\t     before(TCP_SKB_CB(skb)->seq,\r\n\t\t    TCP_SKB_CB(tp->retransmit_skb_hint)->seq)))\r\n\t\ttp->retransmit_skb_hint = skb;\r\n}", ".cp_notify_skb_loss_event": "static void tcp_notify_skb_loss_event(struct tcp_sock *tp, const struct sk_buff *skb)\r\n{\r\n\ttp->lost += tcp_skb_pcount(skb);\r\n}", ".cp_dsack_seen": "static u32 tcp_dsack_seen(struct tcp_sock *tp, u32 start_seq,\r\n\t\t\t  u32 end_seq, struct tcp_sacktag_state *state)\r\n{\r\n\tu32 seq_len, dup_segs = 1;\r\n\r\n\tif (!before(start_seq, end_seq))\r\n\t\treturn 0;\r\n\r\n\tseq_len = end_seq - start_seq;\r\n\t/* Dubious DSACK: DSACKed range greater than maximum advertised rwnd */\r\n\tif (seq_len > tp->max_window)\r\n\t\treturn 0;\r\n\tif (seq_len > tp->mss_cache)\r\n\t\tdup_segs = DIV_ROUND_UP(seq_len, tp->mss_cache);\r\n\telse if (tp->tlp_high_seq && tp->tlp_high_seq == end_seq)\r\n\t\tstate->flag |= FLAG_DSACK_TLP;\r\n\r\n\ttp->dsack_dups += dup_segs;\r\n\t/* Skip the DSACK if dup segs weren't retransmitted by sender */\r\n\tif (tp->dsack_dups > tp->total_retrans)\r\n\t\treturn 0;\r\n\r\n\ttp->rx_opt.sack_ok |= TCP_DSACK_SEEN;\r\n\t/* We increase the RACK ordering window in rounds where we receive\r\n\t * DSACKs that may have been due to reordering causing RACK to trigger\r\n\t * a spurious fast recovery. Thus RACK ignores DSACKs that happen\r\n\t * without having seen reordering, or that match TLP probes (TLP\r\n\t * is timer-driven, not triggered by RACK).\r\n\t */\r\n\tif (tp->reord_seen && !(state->flag & FLAG_DSACK_TLP))\r\n\t\ttp->rack.dsack_seen = 1;\r\n\r\n\tstate->flag |= FLAG_DSACKING_ACK;\r\n\t/* A spurious retransmission is delivered */\r\n\tstate->sack_delivered += dup_segs;\r\n\r\n\treturn dup_segs;\r\n}", ".cp_sacktag_one": "static u8 tcp_sacktag_one(struct sock *sk,\r\n\t\t\t  struct tcp_sacktag_state *state, u8 sacked,\r\n\t\t\t  u32 start_seq, u32 end_seq,\r\n\t\t\t  int dup_sack, int pcount, u32 plen,\r\n\t\t\t  u64 xmit_time)\r\n{\r\n\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\r\n\t/* Account D-SACK for retransmitted packet. */\r\n\tif (dup_sack && (sacked & TCPCB_RETRANS)) {\r\n\t\tif (tp->undo_marker && tp->undo_retrans > 0 &&\r\n\t\t    after(end_seq, tp->undo_marker))\r\n\t\t\ttp->undo_retrans = max_t(int, 0, tp->undo_retrans - pcount);\r\n\t\tif ((sacked & TCPCB_SACKED_ACKED) &&\r\n\t\t    before(start_seq, state->reord))\r\n\t\t\t\tstate->reord = start_seq;\r\n\t}\r\n\r\n\t/* Nothing to do; acked frame is about to be dropped (was ACKed). */\r\n\tif (!after(end_seq, tp->snd_una))\r\n\t\treturn sacked;\r\n\r\n\tif (!(sacked & TCPCB_SACKED_ACKED)) {\r\n\t\ttcp_rack_advance(tp, sacked, end_seq, xmit_time);\r\n\r\n\t\tif (sacked & TCPCB_SACKED_RETRANS) {\r\n\t\t\t/* If the segment is not tagged as lost,\r\n\t\t\t * we do not clear RETRANS, believing\r\n\t\t\t * that retransmission is still in flight.\r\n\t\t\t */\r\n\t\t\tif (sacked & TCPCB_LOST) {\r\n\t\t\t\tsacked &= ~(TCPCB_LOST|TCPCB_SACKED_RETRANS);\r\n\t\t\t\ttp->lost_out -= pcount;\r\n\t\t\t\ttp->retrans_out -= pcount;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tif (!(sacked & TCPCB_RETRANS)) {\r\n\t\t\t\t/* New sack for not retransmitted frame,\r\n\t\t\t\t * which was in hole. It is reordering.\r\n\t\t\t\t */\r\n\t\t\t\tif (before(start_seq,\r\n\t\t\t\t\t   tcp_highest_sack_seq(tp)) &&\r\n\t\t\t\t    before(start_seq, state->reord))\r\n\t\t\t\t\tstate->reord = start_seq;\r\n\r\n\t\t\t\tif (!after(end_seq, tp->high_seq))\r\n\t\t\t\t\tstate->flag |= FLAG_ORIG_SACK_ACKED;\r\n\t\t\t\tif (state->first_sackt == 0)\r\n\t\t\t\t\tstate->first_sackt = xmit_time;\r\n\t\t\t\tstate->last_sackt = xmit_time;\r\n\t\t\t}\r\n\r\n\t\t\tif (sacked & TCPCB_LOST) {\r\n\t\t\t\tsacked &= ~TCPCB_LOST;\r\n\t\t\t\ttp->lost_out -= pcount;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tsacked |= TCPCB_SACKED_ACKED;\r\n\t\tstate->flag |= FLAG_DATA_SACKED;\r\n\t\ttp->sacked_out += pcount;\r\n\t\t/* Out-of-order packets delivered */\r\n\t\tstate->sack_delivered += pcount;\r\n\t\tstate->delivered_bytes += plen;\r\n\t}\r\n\r\n\t/* D-SACK. We can detect redundant retransmission in S|R and plain R\r\n\t * frames and clear it. undo_retrans is decreased above, L|R frames\r\n\t * are accounted above as well.\r\n\t */\r\n\tif (dup_sack && (sacked & TCPCB_SACKED_RETRANS)) {\r\n\t\tsacked &= ~TCPCB_SACKED_RETRANS;\r\n\t\ttp->retrans_out -= pcount;\r\n\t}\r\n\r\n\treturn sacked;\r\n}", ".cp_check_dsack": "static bool tcp_check_dsack(struct sock *sk, const struct sk_buff *ack_skb,\r\n\t\t\t    struct tcp_sack_block_wire *sp, int num_sacks,\r\n\t\t\t    u32 prior_snd_una, struct tcp_sacktag_state *state)\r\n{\r\n\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\tu32 start_seq_0 = get_unaligned_be32(&sp[0].start_seq);\r\n\tu32 end_seq_0 = get_unaligned_be32(&sp[0].end_seq);\r\n\tu32 dup_segs;\r\n\r\n\tif (before(start_seq_0, TCP_SKB_CB(ack_skb)->ack_seq)) {\r\n\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPDSACKRECV);\r\n\t} else if (num_sacks > 1) {\r\n\t\tu32 end_seq_1 = get_unaligned_be32(&sp[1].end_seq);\r\n\t\tu32 start_seq_1 = get_unaligned_be32(&sp[1].start_seq);\r\n\r\n\t\tif (after(end_seq_0, end_seq_1) || before(start_seq_0, start_seq_1))\r\n\t\t\treturn false;\r\n\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPDSACKOFORECV);\r\n\t} else {\r\n\t\treturn false;\r\n\t}\r\n\r\n\tdup_segs = tcp_dsack_seen(tp, start_seq_0, end_seq_0, state);\r\n\tif (!dup_segs) {\t/* Skip dubious DSACK */\r\n\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPDSACKIGNOREDDUBIOUS);\r\n\t\treturn false;\r\n\t}\r\n\r\n\tNET_ADD_STATS(sock_net(sk), LINUX_MIB_TCPDSACKRECVSEGS, dup_segs);\r\n\r\n\t/* D-SACK for already forgotten data... Do dumb counting. */\r\n\tif (tp->undo_marker && tp->undo_retrans > 0 &&\r\n\t    !after(end_seq_0, prior_snd_una) &&\r\n\t    after(end_seq_0, tp->undo_marker))\r\n\t\ttp->undo_retrans = max_t(int, 0, tp->undo_retrans - dup_segs);\r\n\r\n\treturn true;\r\n}", ".cp_is_sackblock_valid": "static bool tcp_is_sackblock_valid(struct tcp_sock *tp, bool is_dsack,\r\n\t\t\t\t   u32 start_seq, u32 end_seq)\r\n{\r\n\t/* Too far in future, or reversed (interpretation is ambiguous) */\r\n\tif (after(end_seq, tp->snd_nxt) || !before(start_seq, end_seq))\r\n\t\treturn false;\r\n\r\n\t/* Nasty start_seq wrap-around check (see comments above) */\r\n\tif (!before(start_seq, tp->snd_nxt))\r\n\t\treturn false;\r\n\r\n\t/* In outstanding window? ...This is valid exit for D-SACKs too.\r\n\t * start_seq == snd_una is non-sensical (see comments above)\r\n\t */\r\n\tif (after(start_seq, tp->snd_una))\r\n\t\treturn true;\r\n\r\n\tif (!is_dsack || !tp->undo_marker)\r\n\t\treturn false;\r\n\r\n\t/* ...Then it's D-SACK, and must reside below snd_una completely */\r\n\tif (after(end_seq, tp->snd_una))\r\n\t\treturn false;\r\n\r\n\tif (!before(start_seq, tp->undo_marker))\r\n\t\treturn true;\r\n\r\n\t/* Too old */\r\n\tif (!after(end_seq, tp->undo_marker))\r\n\t\treturn false;\r\n\r\n\t/* Undo_marker boundary crossing (overestimates a lot). Known already:\r\n\t *   start_seq < undo_marker and end_seq >= undo_marker.\r\n\t */\r\n\treturn !before(start_seq, end_seq - tp->max_window);\r\n}", ".cp_sack_cache_ok": "static int tcp_sack_cache_ok(const struct tcp_sock *tp, const struct tcp_sack_block *cache)\r\n{\r\n\treturn cache < tp->recv_sack_cache + ARRAY_SIZE(tp->recv_sack_cache);\r\n}", ".cp_check_sack_reordering": "static void tcp_check_sack_reordering(struct sock *sk, const u32 low_seq,\r\n\t\t\t\t      const int ts)\r\n{\r\n\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\tconst u32 mss = tp->mss_cache;\r\n\tu32 fack, metric;\r\n\r\n\tfack = tcp_highest_sack_seq(tp);\r\n\tif (!before(low_seq, fack))\r\n\t\treturn;\r\n\r\n\tmetric = fack - low_seq;\r\n\tif ((metric > tp->reordering * mss) && mss) {\r\n#if FASTRETRANS_DEBUG > 1\r\n\t\tpr_debug(\"Disorder%d %d %u f%u s%u rr%d\\n\",\r\n\t\t\t tp->rx_opt.sack_ok, inet_csk(sk)->icsk_ca_state,\r\n\t\t\t tp->reordering,\r\n\t\t\t 0,\r\n\t\t\t tp->sacked_out,\r\n\t\t\t tp->undo_marker ? tp->undo_retrans : 0);\r\n#endif\r\n\t\ttp->reordering = min_t(u32, (metric + mss - 1) / mss,\r\n\t\t\t\t       READ_ONCE(sock_net(sk)->ipv4.sysctl_tcp_max_reordering));\r\n\t}\r\n\r\n\t/* This exciting event is worth to be remembered. 8) */\r\n\ttp->reord_seen++;\r\n\tNET_INC_STATS(sock_net(sk),\r\n\t\t      ts ? LINUX_MIB_TCPTSREORDER : LINUX_MIB_TCPSACKREORDER);\r\n}", ".cp_limit_reno_sacked": "static bool tcp_limit_reno_sacked(struct tcp_sock *tp)\r\n{\r\n\tu32 holes;\r\n\r\n\tholes = max(tp->lost_out, 1U);\r\n\tholes = min(holes, tp->packets_out);\r\n\r\n\tif ((tp->sacked_out + holes) > tp->packets_out) {\r\n\t\ttp->sacked_out = tp->packets_out - holes;\r\n\t\treturn true;\r\n\t}\r\n\treturn false;\r\n}", ".cp_check_reno_reordering": "static void tcp_check_reno_reordering(struct sock *sk, const int addend)\r\n{\r\n\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\r\n\tif (!tcp_limit_reno_sacked(tp))\r\n\t\treturn;\r\n\r\n\ttp->reordering = min_t(u32, tp->packets_out + addend,\r\n\t\t\t       READ_ONCE(sock_net(sk)->ipv4.sysctl_tcp_max_reordering));\r\n\ttp->reord_seen++;\r\n\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPRENOREORDER);\r\n}", ".cp_count_delivered": "static void tcp_count_delivered(struct tcp_sock *tp, u32 delivered,\r\n\t\t\t\tbool ece_ack)\r\n{\r\n\ttp->delivered += delivered;\r\n\tif (tcp_ecn_mode_rfc3168(tp) && ece_ack)\r\n\t\ttcp_count_delivered_ce(tp, delivered);\r\n}", ".cp_reset_reno_sack": "static inline void tcp_reset_reno_sack(struct tcp_sock *tp)\r\n{\r\n\ttp->sacked_out = 0;\r\n}", ".cp_mark_skb_lost": "void tcp_mark_skb_lost(struct sock *sk, struct sk_buff *skb)\r\n{\r\n\t__u8 sacked = TCP_SKB_CB(skb)->sacked;\r\n\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\r\n\tif (sacked & TCPCB_SACKED_ACKED)\r\n\t\treturn;\r\n\r\n\ttcp_verify_retransmit_hint(tp, skb);\r\n\tif (sacked & TCPCB_LOST) {\r\n\t\tif (sacked & TCPCB_SACKED_RETRANS) {\r\n\t\t\t/* Account for retransmits that are lost again */\r\n\t\t\tTCP_SKB_CB(skb)->sacked &= ~TCPCB_SACKED_RETRANS;\r\n\t\t\ttp->retrans_out -= tcp_skb_pcount(skb);\r\n\t\t\tNET_ADD_STATS(sock_net(sk), LINUX_MIB_TCPLOSTRETRANSMIT,\r\n\t\t\t\t      tcp_skb_pcount(skb));\r\n\t\t\ttcp_notify_skb_loss_event(tp, skb);\r\n\t\t}\r\n\t} else {\r\n\t\ttp->lost_out += tcp_skb_pcount(skb);\r\n\t\tTCP_SKB_CB(skb)->sacked |= TCPCB_LOST;\r\n\t\ttcp_notify_skb_loss_event(tp, skb);\r\n\t}\r\n}", ".cp_timeout_mark_lost": "static void tcp_timeout_mark_lost(struct sock *sk)\r\n{\r\n\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\tstruct sk_buff *skb, *head;\r\n\tbool is_reneg;\t\t\t/* is receiver reneging on SACKs? */\r\n\r\n\thead = tcp_rtx_queue_head(sk);\r\n\tis_reneg = head && (TCP_SKB_CB(head)->sacked & TCPCB_SACKED_ACKED);\r\n\tif (is_reneg) {\r\n\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPSACKRENEGING);\r\n\t\ttp->sacked_out = 0;\r\n\t\t/* Mark SACK reneging until we recover from this loss event. */\r\n\t\ttp->is_sack_reneg = 1;\r\n\t} else if (tcp_is_reno(tp)) {\r\n\t\ttcp_reset_reno_sack(tp);\r\n\t}\r\n\r\n\tskb = head;\r\n\tskb_rbtree_walk_from(skb) {\r\n\t\tif (is_reneg)\r\n\t\t\tTCP_SKB_CB(skb)->sacked &= ~TCPCB_SACKED_ACKED;\r\n\t\telse if (skb != head && tcp_rack_skb_timeout(tp, skb, 0) > 0)\r\n\t\t\tcontinue; /* Don't mark recently sent ones lost yet */\r\n\t\ttcp_mark_skb_lost(sk, skb);\r\n\t}\r\n\ttcp_verify_left_out(tp);\r\n\ttcp_clear_all_retrans_hints(tp);\r\n}", ".cp_init_undo": "static inline void tcp_init_undo(struct tcp_sock *tp)\r\n{\r\n\ttp->undo_marker = tp->snd_una;\r\n\r\n\t/* Retransmission still in flight may cause DSACKs later. */\r\n\t/* First, account for regular retransmits in flight: */\r\n\ttp->undo_retrans = tp->retrans_out;\r\n\t/* Next, account for TLP retransmits in flight: */\r\n\tif (tp->tlp_high_seq && tp->tlp_retrans)\r\n\t\ttp->undo_retrans++;\r\n\t/* Finally, avoid 0, because undo_retrans==0 means \"can undo now\": */\r\n\tif (!tp->undo_retrans)\r\n\t\ttp->undo_retrans = -1;\r\n}", ".cp_tsopt_ecr_before": "static bool tcp_tsopt_ecr_before(const struct tcp_sock *tp, u32 when)\r\n{\r\n\treturn tp->rx_opt.saw_tstamp && tp->rx_opt.rcv_tsecr &&\r\n\t       before(tp->rx_opt.rcv_tsecr, when);\r\n}", ".cp_any_retrans_done": "static bool tcp_any_retrans_done(const struct sock *sk)\r\n{\r\n\tconst struct tcp_sock *tp = tcp_sk(sk);\r\n\tstruct sk_buff *skb;\r\n\r\n\tif (tp->retrans_out)\r\n\t\treturn true;\r\n\r\n\tskb = tcp_rtx_queue_head(sk);\r\n\tif (unlikely(skb && TCP_SKB_CB(skb)->sacked & TCPCB_EVER_RETRANS))\r\n\t\treturn true;\r\n\r\n\treturn false;\r\n}", ".cp_packet_delayed": "static inline bool tcp_packet_delayed(const struct tcp_sock *tp)\r\n{\r\n\tconst struct sock *sk = (const struct sock *)tp;\r\n\r\n\t/* Received an echoed timestamp before the first retransmission? */\r\n\tif (tp->retrans_stamp)\r\n\t\treturn tcp_tsopt_ecr_before(tp, tp->retrans_stamp);\r\n\r\n\t/* We set tp->retrans_stamp upon the first retransmission of a loss\r\n\t * recovery episode, so normally if tp->retrans_stamp is 0 then no\r\n\t * retransmission has happened yet (likely due to TSQ, which can cause\r\n\t * fast retransmits to be delayed). So if snd_una advanced while\r\n\t * (tp->retrans_stamp is 0 then apparently a packet was merely delayed,\r\n\t * not lost. But there are exceptions where we retransmit but then\r\n\t * clear tp->retrans_stamp, so we check for those exceptions.\r\n\t */\r\n\r\n\t/* (1) For non-SACK connections, tcp_is_non_sack_preventing_reopen()\r\n\t * clears tp->retrans_stamp when snd_una == high_seq.\r\n\t */\r\n\tif (!tcp_is_sack(tp) && !before(tp->snd_una, tp->high_seq))\r\n\t\treturn false;\r\n\r\n\t/* (2) In TCP_SYN_SENT tcp_clean_rtx_queue() clears tp->retrans_stamp\r\n\t * when setting FLAG_SYN_ACKED is set, even if the SYN was\r\n\t * retransmitted.\r\n\t */\r\n\tif (sk->sk_state == TCP_SYN_SENT)\r\n\t\treturn false;\r\n\r\n\treturn true;\t/* tp->retrans_stamp is zero; no retransmit yet */\r\n}", ".cp_may_undo": "static inline bool tcp_may_undo(const struct tcp_sock *tp)\r\n{\r\n\treturn tp->undo_marker && (!tp->undo_retrans || tcp_packet_delayed(tp));\r\n}", ".BGUNDO": "static void DBGUNDO(struct sock *sk, const char *msg)\r\n{\r\n#if FASTRETRANS_DEBUG > 1\r\n\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\tstruct inet_sock *inet = inet_sk(sk);\r\n\r\n\tif (sk->sk_family == AF_INET) {\r\n\t\tpr_debug(\"Undo %s %pI4/%u c%u l%u ss%u/%u p%u\\n\",\r\n\t\t\t msg,\r\n\t\t\t &inet->inet_daddr, ntohs(inet->inet_dport),\r\n\t\t\t tcp_snd_cwnd(tp), tcp_left_out(tp),\r\n\t\t\t tp->snd_ssthresh, tp->prior_ssthresh,\r\n\t\t\t tp->packets_out);\r\n\t}\r\n#if IS_ENABLED(CONFIG_IPV6)\r\n\telse if (sk->sk_family == AF_INET6) {\r\n\t\tpr_debug(\"Undo %s %pI6/%u c%u l%u ss%u/%u p%u\\n\",\r\n\t\t\t msg,\r\n\t\t\t &sk->sk_v6_daddr, ntohs(inet->inet_dport),\r\n\t\t\t tcp_snd_cwnd(tp), tcp_left_out(tp),\r\n\t\t\t tp->snd_ssthresh, tp->prior_ssthresh,\r\n\t\t\t tp->packets_out);\r\n\t}\r\n#endif\r\n#endif\r\n}", ".cp_undo_cwnd_reduction": "static void tcp_undo_cwnd_reduction(struct sock *sk, bool unmark_loss)\r\n{\r\n\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\r\n\tif (unmark_loss) {\r\n\t\tstruct sk_buff *skb;\r\n\r\n\t\tskb_rbtree_walk(skb, &sk->tcp_rtx_queue) {\r\n\t\t\tTCP_SKB_CB(skb)->sacked &= ~TCPCB_LOST;\r\n\t\t}\r\n\t\ttp->lost_out = 0;\r\n\t\ttcp_clear_all_retrans_hints(tp);\r\n\t}\r\n\r\n\tif (tp->prior_ssthresh) {\r\n\t\tconst struct inet_connection_sock *icsk = inet_csk(sk);\r\n\r\n\t\ttcp_snd_cwnd_set(tp, icsk->icsk_ca_ops->undo_cwnd(sk));\r\n\r\n\t\tif (tp->prior_ssthresh > tp->snd_ssthresh) {\r\n\t\t\ttp->snd_ssthresh = tp->prior_ssthresh;\r\n\t\t\ttcp_ecn_withdraw_cwr(tp);\r\n\t\t}\r\n\t}\r\n\ttp->snd_cwnd_stamp = tcp_jiffies32;\r\n\ttp->undo_marker = 0;\r\n\ttp->rack.advanced = 1; /* Force RACK to re-exam losses */\r\n}", ".cp_is_non_sack_preventing_reopen": "static bool tcp_is_non_sack_preventing_reopen(struct sock *sk)\r\n{\r\n\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\r\n\tif (tp->snd_una == tp->high_seq && tcp_is_reno(tp)) {\r\n\t\t/* Hold old state until something *above* high_seq\r\n\t\t * is ACKed. For Reno it is MUST to prevent false\r\n\t\t * fast retransmits (RFC2582). SACK TCP is safe. */\r\n\t\tif (!tcp_any_retrans_done(sk))\r\n\t\t\ttp->retrans_stamp = 0;\r\n\t\treturn true;\r\n\t}\r\n\treturn false;\r\n}", ".cp_init_cwnd_reduction": "static void tcp_init_cwnd_reduction(struct sock *sk)\r\n{\r\n\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\r\n\ttp->high_seq = tp->snd_nxt;\r\n\ttp->tlp_high_seq = 0;\r\n\ttp->snd_cwnd_cnt = 0;\r\n\ttp->prior_cwnd = tcp_snd_cwnd(tp);\r\n\ttp->prr_delivered = 0;\r\n\ttp->prr_out = 0;\r\n\ttp->snd_ssthresh = inet_csk(sk)->icsk_ca_ops->ssthresh(sk);\r\n\ttcp_ecn_queue_cwr(tp);\r\n}", ".cp_enter_cwr": "void tcp_enter_cwr(struct sock *sk)\r\n{\r\n\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\r\n\ttp->prior_ssthresh = 0;\r\n\tif (inet_csk(sk)->icsk_ca_state < TCP_CA_CWR) {\r\n\t\ttp->undo_marker = 0;\r\n\t\ttcp_init_cwnd_reduction(sk);\r\n\t\ttcp_set_ca_state(sk, TCP_CA_CWR);\r\n\t}\r\n}", ".cp_try_keep_open": "static void tcp_try_keep_open(struct sock *sk)\r\n{\r\n\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\tint state = TCP_CA_Open;\r\n\r\n\tif (tcp_left_out(tp) || tcp_any_retrans_done(sk))\r\n\t\tstate = TCP_CA_Disorder;\r\n\r\n\tif (inet_csk(sk)->icsk_ca_state != state) {\r\n\t\ttcp_set_ca_state(sk, state);\r\n\t\ttp->high_seq = tp->snd_nxt;\r\n\t}\r\n}", ".cp_skb_seglen": "static int tcp_skb_seglen(const struct sk_buff *skb)\r\n{\r\n\treturn tcp_skb_pcount(skb) == 1 ? skb->len : tcp_skb_mss(skb);\r\n}", ".cp_non_congestion_loss_retransmit": "static void tcp_non_congestion_loss_retransmit(struct sock *sk)\r\n{\r\n\tconst struct inet_connection_sock *icsk = inet_csk(sk);\r\n\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\r\n\tif (icsk->icsk_ca_state != TCP_CA_Loss) {\r\n\t\ttp->high_seq = tp->snd_nxt;\r\n\t\ttp->snd_ssthresh = tcp_current_ssthresh(sk);\r\n\t\ttp->prior_ssthresh = 0;\r\n\t\ttp->undo_marker = 0;\r\n\t\ttcp_set_ca_state(sk, TCP_CA_Loss);\r\n\t}\r\n\ttcp_xmit_retransmit_queue(sk);\r\n}", ".cp_retrans_stamp_cleanup": "static void tcp_retrans_stamp_cleanup(struct sock *sk)\r\n{\r\n\tif (!tcp_any_retrans_done(sk))\r\n\t\ttcp_sk(sk)->retrans_stamp = 0;\r\n}", ".cp_try_undo_loss": "static bool tcp_try_undo_loss(struct sock *sk, bool frto_undo)\r\n{\r\n\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\r\n\tif (frto_undo || tcp_may_undo(tp)) {\r\n\t\ttcp_undo_cwnd_reduction(sk, true);\r\n\r\n\t\tDBGUNDO(sk, \"partial loss\");\r\n\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPLOSSUNDO);\r\n\t\tif (frto_undo)\r\n\t\t\tNET_INC_STATS(sock_net(sk),\r\n\t\t\t\t\tLINUX_MIB_TCPSPURIOUSRTOS);\r\n\t\tWRITE_ONCE(inet_csk(sk)->icsk_retransmits, 0);\r\n\t\tif (tcp_is_non_sack_preventing_reopen(sk))\r\n\t\t\treturn true;\r\n\t\tif (frto_undo || tcp_is_sack(tp)) {\r\n\t\t\ttcp_set_ca_state(sk, TCP_CA_Open);\r\n\t\t\ttp->is_sack_reneg = 0;\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\treturn false;\r\n}", ".cp_try_undo_recovery": "static bool tcp_try_undo_recovery(struct sock *sk)\r\n{\r\n\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\r\n\tif (tcp_may_undo(tp)) {\r\n\t\tint mib_idx;\r\n\r\n\t\t/* Happy end! We did not retransmit anything\r\n\t\t * or our original transmission succeeded.\r\n\t\t */\r\n\t\tDBGUNDO(sk, inet_csk(sk)->icsk_ca_state == TCP_CA_Loss ? \"loss\" : \"retrans\");\r\n\t\ttcp_undo_cwnd_reduction(sk, false);\r\n\t\tif (inet_csk(sk)->icsk_ca_state == TCP_CA_Loss)\r\n\t\t\tmib_idx = LINUX_MIB_TCPLOSSUNDO;\r\n\t\telse\r\n\t\t\tmib_idx = LINUX_MIB_TCPFULLUNDO;\r\n\r\n\t\tNET_INC_STATS(sock_net(sk), mib_idx);\r\n\t} else if (tp->rack.reo_wnd_persist) {\r\n\t\ttp->rack.reo_wnd_persist--;\r\n\t}\r\n\tif (tcp_is_non_sack_preventing_reopen(sk))\r\n\t\treturn true;\r\n\ttcp_set_ca_state(sk, TCP_CA_Open);\r\n\ttp->is_sack_reneg = 0;\r\n\treturn false;\r\n}", ".cp_add_reno_sack": "static void tcp_add_reno_sack(struct sock *sk, int num_dupack, bool ece_ack)\r\n{\r\n\tif (num_dupack) {\r\n\t\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\t\tu32 prior_sacked = tp->sacked_out;\r\n\t\ts32 delivered;\r\n\r\n\t\ttp->sacked_out += num_dupack;\r\n\t\ttcp_check_reno_reordering(sk, 0);\r\n\t\tdelivered = tp->sacked_out - prior_sacked;\r\n\t\tif (delivered > 0)\r\n\t\t\ttcp_count_delivered(tp, delivered, ece_ack);\r\n\t\ttcp_verify_left_out(tp);\r\n\t}\r\n}", ".cp_check_sack_reneging": "static bool tcp_check_sack_reneging(struct sock *sk, int *ack_flag)\r\n{\r\n\tif (*ack_flag & FLAG_SACK_RENEGING &&\r\n\t    *ack_flag & FLAG_SND_UNA_ADVANCED) {\r\n\t\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\t\tunsigned long delay = max(usecs_to_jiffies(tp->srtt_us >> 4),\r\n\t\t\t\t\t  msecs_to_jiffies(10));\r\n\r\n\t\ttcp_reset_xmit_timer(sk, ICSK_TIME_RETRANS, delay, false);\r\n\t\t*ack_flag &= ~FLAG_SET_XMIT_TIMER;\r\n\t\treturn true;\r\n\t}\r\n\treturn false;\r\n}", ".cp_end_cwnd_reduction": "static inline void tcp_end_cwnd_reduction(struct sock *sk)\r\n{\r\n\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\r\n\tif (inet_csk(sk)->icsk_ca_ops->cong_control)\r\n\t\treturn;\r\n\r\n\t/* Reset cwnd to ssthresh in CWR or Recovery (unless it's undone) */\r\n\tif (tp->snd_ssthresh < TCP_INFINITE_SSTHRESH &&\r\n\t    (inet_csk(sk)->icsk_ca_state == TCP_CA_CWR || tp->undo_marker)) {\r\n\t\ttcp_snd_cwnd_set(tp, tp->snd_ssthresh);\r\n\t\ttp->snd_cwnd_stamp = tcp_jiffies32;\r\n\t}\r\n\ttcp_ca_event(sk, CA_EVENT_COMPLETE_CWR);\r\n}", ".cp_try_undo_partial": "static bool tcp_try_undo_partial(struct sock *sk, u32 prior_snd_una)\r\n{\r\n\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\r\n\tif (tp->undo_marker && tcp_packet_delayed(tp)) {\r\n\t\t/* Plain luck! Hole if filled with delayed\r\n\t\t * packet, rather than with a retransmit. Check reordering.\r\n\t\t */\r\n\t\ttcp_check_sack_reordering(sk, prior_snd_una, 1);\r\n\r\n\t\t/* We are getting evidence that the reordering degree is higher\r\n\t\t * than we realized. If there are no retransmits out then we\r\n\t\t * can undo. Otherwise we clock out new packets but do not\r\n\t\t * mark more packets lost or retransmit more.\r\n\t\t */\r\n\t\tif (tp->retrans_out)\r\n\t\t\treturn true;\r\n\r\n\t\tif (!tcp_any_retrans_done(sk))\r\n\t\t\ttp->retrans_stamp = 0;\r\n\r\n\t\tDBGUNDO(sk, \"partial recovery\");\r\n\t\ttcp_undo_cwnd_reduction(sk, true);\r\n\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPPARTIALUNDO);\r\n\t\ttcp_try_keep_open(sk);\r\n\t}\r\n\treturn false;\r\n}", ".cp_try_undo_dsack": "static bool tcp_try_undo_dsack(struct sock *sk)\r\n{\r\n\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\r\n\tif (tp->undo_marker && !tp->undo_retrans) {\r\n\t\ttp->rack.reo_wnd_persist = min(TCP_RACK_RECOVERY_THRESH,\r\n\t\t\t\t\t       tp->rack.reo_wnd_persist + 1);\r\n\t\tDBGUNDO(sk, \"D-SACK\");\r\n\t\ttcp_undo_cwnd_reduction(sk, false);\r\n\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPDSACKUNDO);\r\n\t\treturn true;\r\n\t}\r\n\treturn false;\r\n}", ".cp_try_to_open": "static void tcp_try_to_open(struct sock *sk, int flag)\r\n{\r\n\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\r\n\ttcp_verify_left_out(tp);\r\n\r\n\tif (!tcp_any_retrans_done(sk))\r\n\t\ttp->retrans_stamp = 0;\r\n\r\n\tif (flag & FLAG_ECE)\r\n\t\ttcp_enter_cwr(sk);\r\n\r\n\tif (inet_csk(sk)->icsk_ca_state != TCP_CA_CWR) {\r\n\t\ttcp_try_keep_open(sk);\r\n\t}\r\n}", ".cp_identify_packet_loss": "static void tcp_identify_packet_loss(struct sock *sk, int *ack_flag)\r\n{\r\n\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\r\n\tif (tcp_rtx_queue_empty(sk))\r\n\t\treturn;\r\n\r\n\tif (unlikely(tcp_is_reno(tp))) {\r\n\t\ttcp_newreno_mark_lost(sk, *ack_flag & FLAG_SND_UNA_ADVANCED);\r\n\t} else {\r\n\t\tu32 prior_retrans = tp->retrans_out;\r\n\r\n\t\tif (tcp_rack_mark_lost(sk))\r\n\t\t\t*ack_flag &= ~FLAG_SET_XMIT_TIMER;\r\n\t\tif (prior_retrans > tp->retrans_out)\r\n\t\t\t*ack_flag |= FLAG_LOST_RETRANS;\r\n\t}\r\n}", ".cp_time_to_recover": "static bool tcp_time_to_recover(const struct tcp_sock *tp)\r\n{\r\n\t/* Has loss detection marked at least one packet lost? */\r\n\treturn tp->lost_out != 0;\r\n}", ".cp_enter_recovery": "void tcp_enter_recovery(struct sock *sk, bool ece_ack)\r\n{\r\n\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\tint mib_idx;\r\n\r\n\t/* Start the clock with our fast retransmit, for undo and ETIMEDOUT. */\r\n\ttcp_retrans_stamp_cleanup(sk);\r\n\r\n\tif (tcp_is_reno(tp))\r\n\t\tmib_idx = LINUX_MIB_TCPRENORECOVERY;\r\n\telse\r\n\t\tmib_idx = LINUX_MIB_TCPSACKRECOVERY;\r\n\r\n\tNET_INC_STATS(sock_net(sk), mib_idx);\r\n\r\n\ttp->prior_ssthresh = 0;\r\n\ttcp_init_undo(tp);\r\n\r\n\tif (!tcp_in_cwnd_reduction(sk)) {\r\n\t\tif (!ece_ack)\r\n\t\t\ttp->prior_ssthresh = tcp_current_ssthresh(sk);\r\n\t\ttcp_init_cwnd_reduction(sk);\r\n\t}\r\n\ttcp_set_ca_state(sk, TCP_CA_Recovery);\r\n}", ".cp_process_loss": "static void tcp_process_loss(struct sock *sk, int flag, int num_dupack,\r\n\t\t\t     int *rexmit)\r\n{\r\n\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\tbool recovered = !before(tp->snd_una, tp->high_seq);\r\n\r\n\tif ((flag & FLAG_SND_UNA_ADVANCED || rcu_access_pointer(tp->fastopen_rsk)) &&\r\n\t    tcp_try_undo_loss(sk, false))\r\n\t\treturn;\r\n\r\n\tif (tp->frto) { /* F-RTO RFC5682 sec 3.1 (sack enhanced version). */\r\n\t\t/* Step 3.b. A timeout is spurious if not all data are\r\n\t\t * lost, i.e., never-retransmitted data are (s)acked.\r\n\t\t */\r\n\t\tif ((flag & FLAG_ORIG_SACK_ACKED) &&\r\n\t\t    tcp_try_undo_loss(sk, true))\r\n\t\t\treturn;\r\n\r\n\t\tif (after(tp->snd_nxt, tp->high_seq)) {\r\n\t\t\tif (flag & FLAG_DATA_SACKED || num_dupack)\r\n\t\t\t\ttp->frto = 0; /* Step 3.a. loss was real */\r\n\t\t} else if (flag & FLAG_SND_UNA_ADVANCED && !recovered) {\r\n\t\t\ttp->high_seq = tp->snd_nxt;\r\n\t\t\t/* Step 2.b. Try send new data (but deferred until cwnd\r\n\t\t\t * is updated in tcp_ack()). Otherwise fall back to\r\n\t\t\t * the conventional recovery.\r\n\t\t\t */\r\n\t\t\tif (!tcp_write_queue_empty(sk) &&\r\n\t\t\t    after(tcp_wnd_end(tp), tp->snd_nxt)) {\r\n\t\t\t\t*rexmit = REXMIT_NEW;\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\ttp->frto = 0;\r\n\t\t}\r\n\t}\r\n\r\n\tif (recovered) {\r\n\t\t/* F-RTO RFC5682 sec 3.1 step 2.a and 1st part of step 3.a */\r\n\t\ttcp_try_undo_recovery(sk);\r\n\t\treturn;\r\n\t}\r\n\tif (tcp_is_reno(tp)) {\r\n\t\t/* A Reno DUPACK means new data in F-RTO step 2.b above are\r\n\t\t * delivered. Lower inflight to clock out (re)transmissions.\r\n\t\t */\r\n\t\tif (after(tp->snd_nxt, tp->high_seq) && num_dupack)\r\n\t\t\ttcp_add_reno_sack(sk, num_dupack, flag & FLAG_ECE);\r\n\t\telse if (flag & FLAG_SND_UNA_ADVANCED)\r\n\t\t\ttcp_reset_reno_sack(tp);\r\n\t}\r\n\t*rexmit = REXMIT_LOST;\r\n}", ".cp_update_rto_time": "static void tcp_update_rto_time(struct tcp_sock *tp)\r\n{\r\n\tif (tp->rto_stamp) {\r\n\t\ttp->total_rto_time += tcp_time_stamp_ms(tp) - tp->rto_stamp;\r\n\t\ttp->rto_stamp = 0;\r\n\t}\r\n}", ".cp_mtup_probe_failed": "static void tcp_mtup_probe_failed(struct sock *sk)\r\n{\r\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\r\n\r\n\ticsk->icsk_mtup.search_high = icsk->icsk_mtup.probe_size - 1;\r\n\ticsk->icsk_mtup.probe_size = 0;\r\n\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPMTUPFAIL);\r\n}", ".cp_simple_retransmit": "void tcp_simple_retransmit(struct sock *sk)\r\n{\r\n\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\tstruct sk_buff *skb;\r\n\tint mss;\r\n\r\n\t/* A fastopen SYN request is stored as two separate packets within\r\n\t * the retransmit queue, this is done by tcp_send_syn_data().\r\n\t * As a result simply checking the MSS of the frames in the queue\r\n\t * will not work for the SYN packet.\r\n\t *\r\n\t * Us being here is an indication of a path MTU issue so we can\r\n\t * assume that the fastopen SYN was lost and just mark all the\r\n\t * frames in the retransmit queue as lost. We will use an MSS of\r\n\t * -1 to mark all frames as lost, otherwise compute the current MSS.\r\n\t */\r\n\tif (tp->syn_data && sk->sk_state == TCP_SYN_SENT)\r\n\t\tmss = -1;\r\n\telse\r\n\t\tmss = tcp_current_mss(sk);\r\n\r\n\tskb_rbtree_walk(skb, &sk->tcp_rtx_queue) {\r\n\t\tif (tcp_skb_seglen(skb) > mss)\r\n\t\t\ttcp_mark_skb_lost(sk, skb);\r\n\t}\r\n\r\n\tif (!tp->lost_out)\r\n\t\treturn;\r\n\r\n\tif (tcp_is_reno(tp))\r\n\t\ttcp_limit_reno_sacked(tp);\r\n\r\n\ttcp_verify_left_out(tp);\r\n\r\n\t/* Don't muck with the congestion window here.\r\n\t * Reason is that we do not increase amount of _data_\r\n\t * in network, but units changed and effective\r\n\t * cwnd/ssthresh really reduced now.\r\n\t */\r\n\ttcp_non_congestion_loss_retransmit(sk);\r\n}", ".cp_update_rtt_min": "static void tcp_update_rtt_min(struct sock *sk, u32 rtt_us, const int flag)\r\n{\r\n\tu32 wlen = READ_ONCE(sock_net(sk)->ipv4.sysctl_tcp_min_rtt_wlen) * HZ;\r\n\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\r\n\tif ((flag & FLAG_ACK_MAYBE_DELAYED) && rtt_us > tcp_min_rtt(tp)) {\r\n\t\t/* If the remote keeps returning delayed ACKs, eventually\r\n\t\t * the min filter would pick it up and overestimate the\r\n\t\t * prop. delay when it expires. Skip suspected delayed ACKs.\r\n\t\t */\r\n\t\treturn;\r\n\t}\r\n\tminmax_running_min(&tp->rtt_min, wlen, tcp_jiffies32,\r\n\t\t\t   rtt_us ? : jiffies_to_usecs(1));\r\n}", ".cp_rtt_estimator": "static void tcp_rtt_estimator(struct sock *sk, long mrtt_us)\r\n{\r\n\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\tlong m = mrtt_us; /* RTT */\r\n\tu32 srtt = tp->srtt_us;\r\n\r\n\t/*\tThe following amusing code comes from Jacobson's\r\n\t *\tarticle in SIGCOMM '88.  Note that rtt and mdev\r\n\t *\tare scaled versions of rtt and mean deviation.\r\n\t *\tThis is designed to be as fast as possible\r\n\t *\tm stands for \"measurement\".\r\n\t *\r\n\t *\tOn a 1990 paper the rto value is changed to:\r\n\t *\tRTO = rtt + 4 * mdev\r\n\t *\r\n\t * Funny. This algorithm seems to be very broken.\r\n\t * These formulae increase RTO, when it should be decreased, increase\r\n\t * too slowly, when it should be increased quickly, decrease too quickly\r\n\t * etc. I guess in BSD RTO takes ONE value, so that it is absolutely\r\n\t * does not matter how to _calculate_ it. Seems, it was trap\r\n\t * that VJ failed to avoid. 8)\r\n\t */\r\n\tif (srtt != 0) {\r\n\t\tm -= (srtt >> 3);\t/* m is now error in rtt est */\r\n\t\tsrtt += m;\t\t/* rtt = 7/8 rtt + 1/8 new */\r\n\t\tif (m < 0) {\r\n\t\t\tm = -m;\t\t/* m is now abs(error) */\r\n\t\t\tm -= (tp->mdev_us >> 2);   /* similar update on mdev */\r\n\t\t\t/* This is similar to one of Eifel findings.\r\n\t\t\t * Eifel blocks mdev updates when rtt decreases.\r\n\t\t\t * This solution is a bit different: we use finer gain\r\n\t\t\t * for mdev in this case (alpha*beta).\r\n\t\t\t * Like Eifel it also prevents growth of rto,\r\n\t\t\t * but also it limits too fast rto decreases,\r\n\t\t\t * happening in pure Eifel.\r\n\t\t\t */\r\n\t\t\tif (m > 0)\r\n\t\t\t\tm >>= 3;\r\n\t\t} else {\r\n\t\t\tm -= (tp->mdev_us >> 2);   /* similar update on mdev */\r\n\t\t}\r\n\t\ttp->mdev_us += m;\t\t/* mdev = 3/4 mdev + 1/4 new */\r\n\t\tif (tp->mdev_us > tp->mdev_max_us) {\r\n\t\t\ttp->mdev_max_us = tp->mdev_us;\r\n\t\t\tif (tp->mdev_max_us > tp->rttvar_us)\r\n\t\t\t\ttp->rttvar_us = tp->mdev_max_us;\r\n\t\t}\r\n\t\tif (after(tp->snd_una, tp->rtt_seq)) {\r\n\t\t\tif (tp->mdev_max_us < tp->rttvar_us)\r\n\t\t\t\ttp->rttvar_us -= (tp->rttvar_us - tp->mdev_max_us) >> 2;\r\n\t\t\ttp->rtt_seq = tp->snd_nxt;\r\n\t\t\ttp->mdev_max_us = tcp_rto_min_us(sk);\r\n\r\n\t\t\ttcp_bpf_rtt(sk, mrtt_us, srtt);\r\n\t\t}\r\n\t} else {\r\n\t\t/* no previous measure. */\r\n\t\tsrtt = m << 3;\t\t/* take the measured time to be rtt */\r\n\t\ttp->mdev_us = m << 1;\t/* make sure rto = 3*rtt */\r\n\t\ttp->rttvar_us = max(tp->mdev_us, tcp_rto_min_us(sk));\r\n\t\ttp->mdev_max_us = tp->rttvar_us;\r\n\t\ttp->rtt_seq = tp->snd_nxt;\r\n\r\n\t\ttcp_bpf_rtt(sk, mrtt_us, srtt);\r\n\t}\r\n\ttp->srtt_us = max(1U, srtt);\r\n}", ".cp_set_rto": "static void tcp_set_rto(struct sock *sk)\r\n{\r\n\tconst struct tcp_sock *tp = tcp_sk(sk);\r\n\t/* Old crap is replaced with new one. 8)\r\n\t *\r\n\t * More seriously:\r\n\t * 1. If rtt variance happened to be less 50msec, it is hallucination.\r\n\t *    It cannot be less due to utterly erratic ACK generation made\r\n\t *    at least by solaris and freebsd. \"Erratic ACKs\" has _nothing_\r\n\t *    to do with delayed acks, because at cwnd>2 true delack timeout\r\n\t *    is invisible. Actually, Linux-2.4 also generates erratic\r\n\t *    ACKs in some circumstances.\r\n\t */\r\n\tinet_csk(sk)->icsk_rto = __tcp_set_rto(tp);\r\n\r\n\t/* 2. Fixups made earlier cannot be right.\r\n\t *    If we do not estimate RTO correctly without them,\r\n\t *    all the algo is pure shit and should be replaced\r\n\t *    with correct one. It is exactly, which we pretend to do.\r\n\t */\r\n\r\n\t/* NOTE: clamping at TCP_RTO_MIN is not required, current algo\r\n\t * guarantees that rto is higher.\r\n\t */\r\n\ttcp_bound_rto(sk);\r\n}", ".cp_ack_update_rtt": "static bool tcp_ack_update_rtt(struct sock *sk, const int flag,\r\n\t\t\t       long seq_rtt_us, long sack_rtt_us,\r\n\t\t\t       long ca_rtt_us, struct rate_sample *rs)\r\n{\r\n\tconst struct tcp_sock *tp = tcp_sk(sk);\r\n\r\n\t/* Prefer RTT measured from ACK's timing to TS-ECR. This is because\r\n\t * broken middle-boxes or peers may corrupt TS-ECR fields. But\r\n\t * Karn's algorithm forbids taking RTT if some retransmitted data\r\n\t * is acked (RFC6298).\r\n\t */\r\n\tif (seq_rtt_us < 0)\r\n\t\tseq_rtt_us = sack_rtt_us;\r\n\r\n\t/* RTTM Rule: A TSecr value received in a segment is used to\r\n\t * update the averaged RTT measurement only if the segment\r\n\t * acknowledges some new data, i.e., only if it advances the\r\n\t * left edge of the send window.\r\n\t * See draft-ietf-tcplw-high-performance-00, section 3.3.\r\n\t */\r\n\tif (seq_rtt_us < 0 && tp->rx_opt.saw_tstamp &&\r\n\t    tp->rx_opt.rcv_tsecr && flag & FLAG_ACKED)\r\n\t\tseq_rtt_us = ca_rtt_us = tcp_rtt_tsopt_us(tp, 1);\r\n\r\n\trs->rtt_us = ca_rtt_us; /* RTT of last (S)ACKed packet (or -1) */\r\n\tif (seq_rtt_us < 0)\r\n\t\treturn false;\r\n\r\n\t/* ca_rtt_us >= 0 is counting on the invariant that ca_rtt_us is\r\n\t * always taken together with ACK, SACK, or TS-opts. Any negative\r\n\t * values will be skipped with the seq_rtt_us < 0 check above.\r\n\t */\r\n\ttcp_update_rtt_min(sk, ca_rtt_us, flag);\r\n\ttcp_rtt_estimator(sk, seq_rtt_us);\r\n\ttcp_set_rto(sk);\r\n\r\n\t/* RFC6298: only reset backoff on valid RTT measurement. */\r\n\tinet_csk(sk)->icsk_backoff = 0;\r\n\treturn true;\r\n}", ".cp_rearm_rto": "void tcp_rearm_rto(struct sock *sk)\r\n{\r\n\tconst struct inet_connection_sock *icsk = inet_csk(sk);\r\n\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\r\n\t/* If the retrans timer is currently being used by Fast Open\r\n\t * for SYN-ACK retrans purpose, stay put.\r\n\t */\r\n\tif (rcu_access_pointer(tp->fastopen_rsk))\r\n\t\treturn;\r\n\r\n\tif (!tp->packets_out) {\r\n\t\tinet_csk_clear_xmit_timer(sk, ICSK_TIME_RETRANS);\r\n\t} else {\r\n\t\tu32 rto = inet_csk(sk)->icsk_rto;\r\n\t\t/* Offset the time elapsed after installing regular RTO */\r\n\t\tif (icsk->icsk_pending == ICSK_TIME_REO_TIMEOUT ||\r\n\t\t    icsk->icsk_pending == ICSK_TIME_LOSS_PROBE) {\r\n\t\t\ts64 delta_us = tcp_rto_delta_us(sk);\r\n\t\t\t/* delta_us may not be positive if the socket is locked\r\n\t\t\t * when the retrans timer fires and is rescheduled.\r\n\t\t\t */\r\n\t\t\trto = usecs_to_jiffies(max_t(int, delta_us, 1));\r\n\t\t}\r\n\t\ttcp_reset_xmit_timer(sk, ICSK_TIME_RETRANS, rto, true);\r\n\t}\r\n}", ".cp_tso_acked": "static u32 tcp_tso_acked(struct sock *sk, struct sk_buff *skb)\r\n{\r\n\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\tu32 packets_acked;\r\n\r\n\tBUG_ON(!after(TCP_SKB_CB(skb)->end_seq, tp->snd_una));\r\n\r\n\tpackets_acked = tcp_skb_pcount(skb);\r\n\tif (tcp_trim_head(sk, skb, tp->snd_una - TCP_SKB_CB(skb)->seq))\r\n\t\treturn 0;\r\n\tpackets_acked -= tcp_skb_pcount(skb);\r\n\r\n\tif (packets_acked) {\r\n\t\tBUG_ON(tcp_skb_pcount(skb) == 0);\r\n\t\tBUG_ON(!before(TCP_SKB_CB(skb)->seq, TCP_SKB_CB(skb)->end_seq));\r\n\t}\r\n\r\n\treturn packets_acked;\r\n}", ".cp_skb_spurious_retrans": "static bool tcp_skb_spurious_retrans(const struct tcp_sock *tp,\r\n\t\t\t\t     const struct sk_buff *skb)\r\n{\r\n\treturn (TCP_SKB_CB(skb)->sacked & TCPCB_RETRANS) &&\r\n\t       tcp_tsopt_ecr_before(tp, tcp_skb_timestamp_ts(tp->tcp_usec_ts, skb));\r\n}", ".cp_ack_tstamp": "static void tcp_ack_tstamp(struct sock *sk, struct sk_buff *skb,\r\n\t\t\t   const struct sk_buff *ack_skb, u32 prior_snd_una)\r\n{\r\n\tconst struct skb_shared_info *shinfo;\r\n\r\n\t/* Avoid cache line misses to get skb_shinfo() and shinfo->tx_flags */\r\n\tif (likely(!TCP_SKB_CB(skb)->txstamp_ack))\r\n\t\treturn;\r\n\r\n\tshinfo = skb_shinfo(skb);\r\n\tif (!before(shinfo->tskey, prior_snd_una) &&\r\n\t    before(shinfo->tskey, tcp_sk(sk)->snd_una)) {\r\n\t\ttcp_skb_tsorted_save(skb) {\r\n\t\t\t__skb_tstamp_tx(skb, ack_skb, NULL, sk, SCM_TSTAMP_ACK);\r\n\t\t} tcp_skb_tsorted_restore(skb);\r\n\t}\r\n}", ".cp_mtup_probe_success": "static void tcp_mtup_probe_success(struct sock *sk)\r\n{\r\n\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\r\n\tu64 val;\r\n\r\n\ttp->prior_ssthresh = tcp_current_ssthresh(sk);\r\n\r\n\tval = (u64)tcp_snd_cwnd(tp) * tcp_mss_to_mtu(sk, tp->mss_cache);\r\n\tdo_div(val, icsk->icsk_mtup.probe_size);\r\n\tDEBUG_NET_WARN_ON_ONCE((u32)val != val);\r\n\ttcp_snd_cwnd_set(tp, max_t(u32, 1U, val));\r\n\r\n\ttp->snd_cwnd_cnt = 0;\r\n\ttp->snd_cwnd_stamp = tcp_jiffies32;\r\n\ttp->snd_ssthresh = tcp_current_ssthresh(sk);\r\n\r\n\ticsk->icsk_mtup.search_low = icsk->icsk_mtup.probe_size;\r\n\ticsk->icsk_mtup.probe_size = 0;\r\n\ttcp_sync_mss(sk, icsk->icsk_pmtu_cookie);\r\n\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPMTUPSUCCESS);\r\n}", ".cp_remove_reno_sacks": "static void tcp_remove_reno_sacks(struct sock *sk, int acked, bool ece_ack)\r\n{\r\n\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\r\n\tif (acked > 0) {\r\n\t\t/* One ACK acked hole. The rest eat duplicate ACKs. */\r\n\t\ttcp_count_delivered(tp, max_t(int, acked - tp->sacked_out, 1),\r\n\t\t\t\t    ece_ack);\r\n\t\tif (acked - 1 >= tp->sacked_out)\r\n\t\t\ttp->sacked_out = 0;\r\n\t\telse\r\n\t\t\ttp->sacked_out -= acked - 1;\r\n\t}\r\n\ttcp_check_reno_reordering(sk, acked);\r\n\ttcp_verify_left_out(tp);\r\n}", ".cp_cwnd_reduction": "void tcp_cwnd_reduction(struct sock *sk, int newly_acked_sacked, int newly_lost, int flag)\r\n{\r\n\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\tint sndcnt = 0;\r\n\tint delta = tp->snd_ssthresh - tcp_packets_in_flight(tp);\r\n\r\n\tif (newly_acked_sacked <= 0 || WARN_ON_ONCE(!tp->prior_cwnd))\r\n\t\treturn;\r\n\r\n\ttrace_tcp_cwnd_reduction_tp(sk, newly_acked_sacked, newly_lost, flag);\r\n\r\n\ttp->prr_delivered += newly_acked_sacked;\r\n\tif (delta < 0) {\r\n\t\tu64 dividend = (u64)tp->snd_ssthresh * tp->prr_delivered +\r\n\t\t\t       tp->prior_cwnd - 1;\r\n\t\tsndcnt = div_u64(dividend, tp->prior_cwnd) - tp->prr_out;\r\n\t} else {\r\n\t\tsndcnt = max_t(int, tp->prr_delivered - tp->prr_out,\r\n\t\t\t       newly_acked_sacked);\r\n\t\tif (flag & FLAG_SND_UNA_ADVANCED && !newly_lost)\r\n\t\t\tsndcnt++;\r\n\t\tsndcnt = min(delta, sndcnt);\r\n\t}\r\n\t/* Force a fast retransmit upon entering fast recovery */\r\n\tsndcnt = max(sndcnt, (tp->prr_out ? 0 : 1));\r\n\ttcp_snd_cwnd_set(tp, tcp_packets_in_flight(tp) + sndcnt);\r\n}", ".cp_may_raise_cwnd": "static inline bool tcp_may_raise_cwnd(const struct sock *sk, const int flag)\r\n{\r\n\t/* If reordering is high then always grow cwnd whenever data is\r\n\t * delivered regardless of its ordering. Otherwise stay conservative\r\n\t * and only grow cwnd on in-order delivery (RFC5681). A stretched ACK w/\r\n\t * new SACK or ECE mark may first advance cwnd here and later reduce\r\n\t * cwnd in tcp_fastretrans_alert() based on more states.\r\n\t */\r\n\tif (tcp_sk(sk)->reordering >\r\n\t    READ_ONCE(sock_net(sk)->ipv4.sysctl_tcp_reordering))\r\n\t\treturn flag & FLAG_FORWARD_PROGRESS;\r\n\r\n\treturn flag & FLAG_DATA_ACKED;\r\n}", ".cp_cong_avoid": "static void tcp_cong_avoid(struct sock *sk, u32 ack, u32 acked)\r\n{\r\n\tconst struct inet_connection_sock *icsk = inet_csk(sk);\r\n\r\n\ticsk->icsk_ca_ops->cong_avoid(sk, ack, acked);\r\n\ttcp_sk(sk)->snd_cwnd_stamp = tcp_jiffies32;\r\n}", ".cp_update_pacing_rate": "static void tcp_update_pacing_rate(struct sock *sk)\r\n{\r\n\tconst struct tcp_sock *tp = tcp_sk(sk);\r\n\tu64 rate;\r\n\r\n\t/* set sk_pacing_rate to 200 % of current rate (mss * cwnd / srtt) */\r\n\trate = (u64)tp->mss_cache * ((USEC_PER_SEC / 100) << 3);\r\n\r\n\t/* current rate is (cwnd * mss) / srtt\r\n\t * In Slow Start [1], set sk_pacing_rate to 200 % the current rate.\r\n\t * In Congestion Avoidance phase, set it to 120 % the current rate.\r\n\t *\r\n\t * [1] : Normal Slow Start condition is (tp->snd_cwnd < tp->snd_ssthresh)\r\n\t *\t If snd_cwnd >= (tp->snd_ssthresh / 2), we are approaching\r\n\t *\t end of slow start and should slow down.\r\n\t */\r\n\tif (tcp_snd_cwnd(tp) < tp->snd_ssthresh / 2)\r\n\t\trate *= READ_ONCE(sock_net(sk)->ipv4.sysctl_tcp_pacing_ss_ratio);\r\n\telse\r\n\t\trate *= READ_ONCE(sock_net(sk)->ipv4.sysctl_tcp_pacing_ca_ratio);\r\n\r\n\trate *= max(tcp_snd_cwnd(tp), tp->packets_out);\r\n\r\n\tif (likely(tp->srtt_us))\r\n\t\tdo_div(rate, tp->srtt_us);\r\n\r\n\t/* WRITE_ONCE() is needed because sch_fq fetches sk_pacing_rate\r\n\t * without any lock. We want to make sure compiler wont store\r\n\t * intermediate values in this location.\r\n\t */\r\n\tWRITE_ONCE(sk->sk_pacing_rate,\r\n\t\t   min_t(u64, rate, READ_ONCE(sk->sk_max_pacing_rate)));\r\n}", ".cp_snd_sne_update": "static void tcp_snd_sne_update(struct tcp_sock *tp, u32 ack)\r\n{\r\n#ifdef CONFIG_TCP_AO\r\n\tstruct tcp_ao_info *ao;\r\n\r\n\tif (!static_branch_unlikely(&tcp_ao_needed.key))\r\n\t\treturn;\r\n\r\n\tao = rcu_dereference_protected(tp->ao_info,\r\n\t\t\t\t       lockdep_sock_is_held((struct sock *)tp));\r\n\tif (ao && ack < tp->snd_una) {\r\n\t\tao->snd_sne++;\r\n\t\ttrace_tcp_ao_snd_sne_update((struct sock *)tp, ao->snd_sne);\r\n\t}\r\n#endif\r\n}", ".cp_rcv_sne_update": "static void tcp_rcv_sne_update(struct tcp_sock *tp, u32 seq)\r\n{\r\n#ifdef CONFIG_TCP_AO\r\n\tstruct tcp_ao_info *ao;\r\n\r\n\tif (!static_branch_unlikely(&tcp_ao_needed.key))\r\n\t\treturn;\r\n\r\n\tao = rcu_dereference_protected(tp->ao_info,\r\n\t\t\t\t       lockdep_sock_is_held((struct sock *)tp));\r\n\tif (ao && seq < tp->rcv_nxt) {\r\n\t\tao->rcv_sne++;\r\n\t\ttrace_tcp_ao_rcv_sne_update((struct sock *)tp, ao->rcv_sne);\r\n\t}\r\n#endif\r\n}", ".cp_may_update_window": "static inline bool tcp_may_update_window(const struct tcp_sock *tp,\r\n\t\t\t\t\tconst u32 ack, const u32 ack_seq,\r\n\t\t\t\t\tconst u32 nwin)\r\n{\r\n\treturn\tafter(ack, tp->snd_una) ||\r\n\t\tafter(ack_seq, tp->snd_wl1) ||\r\n\t\t(ack_seq == tp->snd_wl1 && (nwin > tp->snd_wnd || !nwin));\r\n}", ".cp_snd_una_update": "static void tcp_snd_una_update(struct tcp_sock *tp, u32 ack)\r\n{\r\n\tu32 delta = ack - tp->snd_una;\r\n\r\n\tsock_owned_by_me((struct sock *)tp);\r\n\ttp->bytes_acked += delta;\r\n\ttcp_snd_sne_update(tp, ack);\r\n\ttp->snd_una = ack;\r\n}", ".cp_send_ack_reflect_ect": "static void tcp_send_ack_reflect_ect(struct sock *sk, bool accecn_reflector)\r\n{\r\n\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\tu16 flags = 0;\r\n\r\n\tif (accecn_reflector)\r\n\t\tflags = tcp_accecn_reflector_flags(tp->syn_ect_rcv);\r\n\t__tcp_send_ack(sk, tp->rcv_nxt, flags);\r\n}", ".cp_send_challenge_ack": "static void tcp_send_challenge_ack(struct sock *sk, bool accecn_reflector)\r\n{\r\n\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\tstruct net *net = sock_net(sk);\r\n\tu32 count, now, ack_limit;\r\n\r\n\t/* First check our per-socket dupack rate limit. */\r\n\tif (__tcp_oow_rate_limited(net,\r\n\t\t\t\t   LINUX_MIB_TCPACKSKIPPEDCHALLENGE,\r\n\t\t\t\t   &tp->last_oow_ack_time))\r\n\t\treturn;\r\n\r\n\tack_limit = READ_ONCE(net->ipv4.sysctl_tcp_challenge_ack_limit);\r\n\tif (ack_limit == INT_MAX)\r\n\t\tgoto send_ack;\r\n\r\n\t/* Then check host-wide RFC 5961 rate limit. */\r\n\tnow = jiffies / HZ;\r\n\tif (now != READ_ONCE(net->ipv4.tcp_challenge_timestamp)) {\r\n\t\tu32 half = (ack_limit + 1) >> 1;\r\n\r\n\t\tWRITE_ONCE(net->ipv4.tcp_challenge_timestamp, now);\r\n\t\tWRITE_ONCE(net->ipv4.tcp_challenge_count,\r\n\t\t\t   get_random_u32_inclusive(half, ack_limit + half - 1));\r\n\t}\r\n\tcount = READ_ONCE(net->ipv4.tcp_challenge_count);\r\n\tif (count > 0) {\r\n\t\tWRITE_ONCE(net->ipv4.tcp_challenge_count, count - 1);\r\nsend_ack:\r\n\t\tNET_INC_STATS(net, LINUX_MIB_TCPCHALLENGEACK);\r\n\t\ttcp_send_ack_reflect_ect(sk, accecn_reflector);\r\n\t}\r\n}", ".cp_replace_ts_recent": "static int tcp_replace_ts_recent(struct tcp_sock *tp, u32 seq)\r\n{\r\n\ts32 delta;\r\n\r\n\tif (tp->rx_opt.saw_tstamp && !after(seq, tp->rcv_wup)) {\r\n\t\t/* PAWS bug workaround wrt. ACK frames, the PAWS discard\r\n\t\t * extra check below makes sure this can only happen\r\n\t\t * for pure ACK frames.  -DaveM\r\n\t\t *\r\n\t\t * Not only, also it occurs for expired timestamps.\r\n\t\t */\r\n\r\n\t\tif (tcp_paws_check(&tp->rx_opt, 0)) {\r\n\t\t\tdelta = tp->rx_opt.rcv_tsval - tp->rx_opt.ts_recent;\r\n\t\t\treturn __tcp_replace_ts_recent(tp, delta);\r\n\t\t}\r\n\t}\r\n\r\n\treturn 0;\r\n}", ".cp_ack_update_window": "static int tcp_ack_update_window(struct sock *sk, const struct sk_buff *skb, u32 ack,\r\n\t\t\t\t u32 ack_seq)\r\n{\r\n\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\tint flag = 0;\r\n\tu32 nwin = ntohs(tcp_hdr(skb)->window);\r\n\r\n\tif (likely(!tcp_hdr(skb)->syn))\r\n\t\tnwin <<= tp->rx_opt.snd_wscale;\r\n\r\n\tif (tcp_may_update_window(tp, ack, ack_seq, nwin)) {\r\n\t\tflag |= FLAG_WIN_UPDATE;\r\n\t\ttcp_update_wl(tp, ack_seq);\r\n\r\n\t\tif (tp->snd_wnd != nwin) {\r\n\t\t\ttp->snd_wnd = nwin;\r\n\r\n\t\t\t/* Note, it is the only place, where\r\n\t\t\t * fast path is recovered for sending TCP.\r\n\t\t\t */\r\n\t\t\ttp->pred_flags = 0;\r\n\t\t\ttcp_fast_path_check(sk);\r\n\r\n\t\t\tif (!tcp_write_queue_empty(sk))\r\n\t\t\t\ttcp_slow_start_after_idle_check(sk);\r\n\r\n\t\t\tif (nwin > tp->max_window) {\r\n\t\t\t\ttp->max_window = nwin;\r\n\t\t\t\ttcp_sync_mss(sk, inet_csk(sk)->icsk_pmtu_cookie);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\ttcp_snd_una_update(tp, ack);\r\n\r\n\treturn flag;\r\n}", ".cp_sacktag_write_queue": "static int\r\ntcp_sacktag_write_queue(struct sock *sk, const struct sk_buff *ack_skb,\r\n\t\t\tu32 prior_snd_una, struct tcp_sacktag_state *state)\r\n{\r\n\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\tconst unsigned char *ptr = (skb_transport_header(ack_skb) +\r\n\t\t\t\t    TCP_SKB_CB(ack_skb)->sacked);\r\n\tstruct tcp_sack_block_wire *sp_wire = (struct tcp_sack_block_wire *)(ptr+2);\r\n\tstruct tcp_sack_block sp[TCP_NUM_SACKS];\r\n\tstruct tcp_sack_block *cache;\r\n\tstruct sk_buff *skb;\r\n\tint num_sacks = min(TCP_NUM_SACKS, (ptr[1] - TCPOLEN_SACK_BASE) >> 3);\r\n\tint used_sacks;\r\n\tbool found_dup_sack = false;\r\n\tint i, j;\r\n\tint first_sack_index;\r\n\r\n\tstate->flag = 0;\r\n\tstate->reord = tp->snd_nxt;\r\n\r\n\tif (!tp->sacked_out)\r\n\t\ttcp_highest_sack_reset(sk);\r\n\r\n\tfound_dup_sack = tcp_check_dsack(sk, ack_skb, sp_wire,\r\n\t\t\t\t\t num_sacks, prior_snd_una, state);\r\n\r\n\t/* Eliminate too old ACKs, but take into\r\n\t * account more or less fresh ones, they can\r\n\t * contain valid SACK info.\r\n\t */\r\n\tif (before(TCP_SKB_CB(ack_skb)->ack_seq, prior_snd_una - tp->max_window))\r\n\t\treturn 0;\r\n\r\n\tif (!tp->packets_out)\r\n\t\tgoto out;\r\n\r\n\tused_sacks = 0;\r\n\tfirst_sack_index = 0;\r\n\tfor (i = 0; i < num_sacks; i++) {\r\n\t\tbool dup_sack = !i && found_dup_sack;\r\n\r\n\t\tsp[used_sacks].start_seq = get_unaligned_be32(&sp_wire[i].start_seq);\r\n\t\tsp[used_sacks].end_seq = get_unaligned_be32(&sp_wire[i].end_seq);\r\n\r\n\t\tif (!tcp_is_sackblock_valid(tp, dup_sack,\r\n\t\t\t\t\t    sp[used_sacks].start_seq,\r\n\t\t\t\t\t    sp[used_sacks].end_seq)) {\r\n\t\t\tint mib_idx;\r\n\r\n\t\t\tif (dup_sack) {\r\n\t\t\t\tif (!tp->undo_marker)\r\n\t\t\t\t\tmib_idx = LINUX_MIB_TCPDSACKIGNOREDNOUNDO;\r\n\t\t\t\telse\r\n\t\t\t\t\tmib_idx = LINUX_MIB_TCPDSACKIGNOREDOLD;\r\n\t\t\t} else {\r\n\t\t\t\t/* Don't count olds caused by ACK reordering */\r\n\t\t\t\tif ((TCP_SKB_CB(ack_skb)->ack_seq != tp->snd_una) &&\r\n\t\t\t\t    !after(sp[used_sacks].end_seq, tp->snd_una))\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\tmib_idx = LINUX_MIB_TCPSACKDISCARD;\r\n\t\t\t}\r\n\r\n\t\t\tNET_INC_STATS(sock_net(sk), mib_idx);\r\n\t\t\tif (i == 0)\r\n\t\t\t\tfirst_sack_index = -1;\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\t/* Ignore very old stuff early */\r\n\t\tif (!after(sp[used_sacks].end_seq, prior_snd_una)) {\r\n\t\t\tif (i == 0)\r\n\t\t\t\tfirst_sack_index = -1;\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\tused_sacks++;\r\n\t}\r\n\r\n\t/* order SACK blocks to allow in order walk of the retrans queue */\r\n\tfor (i = used_sacks - 1; i > 0; i--) {\r\n\t\tfor (j = 0; j < i; j++) {\r\n\t\t\tif (after(sp[j].start_seq, sp[j + 1].start_seq)) {\r\n\t\t\t\tswap(sp[j], sp[j + 1]);\r\n\r\n\t\t\t\t/* Track where the first SACK block goes to */\r\n\t\t\t\tif (j == first_sack_index)\r\n\t\t\t\t\tfirst_sack_index = j + 1;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tstate->mss_now = tcp_current_mss(sk);\r\n\tskb = NULL;\r\n\ti = 0;\r\n\r\n\tif (!tp->sacked_out) {\r\n\t\t/* It's already past, so skip checking against it */\r\n\t\tcache = tp->recv_sack_cache + ARRAY_SIZE(tp->recv_sack_cache);\r\n\t} else {\r\n\t\tcache = tp->recv_sack_cache;\r\n\t\t/* Skip empty blocks in at head of the cache */\r\n\t\twhile (tcp_sack_cache_ok(tp, cache) && !cache->start_seq &&\r\n\t\t       !cache->end_seq)\r\n\t\t\tcache++;\r\n\t}\r\n\r\n\twhile (i < used_sacks) {\r\n\t\tu32 start_seq = sp[i].start_seq;\r\n\t\tu32 end_seq = sp[i].end_seq;\r\n\t\tbool dup_sack = (found_dup_sack && (i == first_sack_index));\r\n\t\tstruct tcp_sack_block *next_dup = NULL;\r\n\r\n\t\tif (found_dup_sack && ((i + 1) == first_sack_index))\r\n\t\t\tnext_dup = &sp[i + 1];\r\n\r\n\t\t/* Skip too early cached blocks */\r\n\t\twhile (tcp_sack_cache_ok(tp, cache) &&\r\n\t\t       !before(start_seq, cache->end_seq))\r\n\t\t\tcache++;\r\n\r\n\t\t/* Can skip some work by looking recv_sack_cache? */\r\n\t\tif (tcp_sack_cache_ok(tp, cache) && !dup_sack &&\r\n\t\t    after(end_seq, cache->start_seq)) {\r\n\r\n\t\t\t/* Head todo? */\r\n\t\t\tif (before(start_seq, cache->start_seq)) {\r\n\t\t\t\tskb = tcp_sacktag_skip(skb, sk, start_seq);\r\n\t\t\t\tskb = tcp_sacktag_walk(skb, sk, next_dup,\r\n\t\t\t\t\t\t       state,\r\n\t\t\t\t\t\t       start_seq,\r\n\t\t\t\t\t\t       cache->start_seq,\r\n\t\t\t\t\t\t       dup_sack);\r\n\t\t\t}\r\n\r\n\t\t\t/* Rest of the block already fully processed? */\r\n\t\t\tif (!after(end_seq, cache->end_seq))\r\n\t\t\t\tgoto advance_sp;\r\n\r\n\t\t\tskb = tcp_maybe_skipping_dsack(skb, sk, next_dup,\r\n\t\t\t\t\t\t       state,\r\n\t\t\t\t\t\t       cache->end_seq);\r\n\r\n\t\t\t/* ...tail remains todo... */\r\n\t\t\tif (tcp_highest_sack_seq(tp) == cache->end_seq) {\r\n\t\t\t\t/* ...but better entrypoint exists! */\r\n\t\t\t\tskb = tcp_highest_sack(sk);\r\n\t\t\t\tif (!skb)\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcache++;\r\n\t\t\t\tgoto walk;\r\n\t\t\t}\r\n\r\n\t\t\tskb = tcp_sacktag_skip(skb, sk, cache->end_seq);\r\n\t\t\t/* Check overlap against next cached too (past this one already) */\r\n\t\t\tcache++;\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\tif (!before(start_seq, tcp_highest_sack_seq(tp))) {\r\n\t\t\tskb = tcp_highest_sack(sk);\r\n\t\t\tif (!skb)\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\t\tskb = tcp_sacktag_skip(skb, sk, start_seq);\r\n\r\nwalk:\r\n\t\tskb = tcp_sacktag_walk(skb, sk, next_dup, state,\r\n\t\t\t\t       start_seq, end_seq, dup_sack);\r\n\r\nadvance_sp:\r\n\t\ti++;\r\n\t}\r\n\r\n\t/* Clear the head of the cache sack blocks so we can skip it next time */\r\n\tfor (i = 0; i < ARRAY_SIZE(tp->recv_sack_cache) - used_sacks; i++) {\r\n\t\ttp->recv_sack_cache[i].start_seq = 0;\r\n\t\ttp->recv_sack_cache[i].end_seq = 0;\r\n\t}\r\n\tfor (j = 0; j < used_sacks; j++)\r\n\t\ttp->recv_sack_cache[i++] = sp[j];\r\n\r\n\tif (inet_csk(sk)->icsk_ca_state != TCP_CA_Loss || tp->undo_marker)\r\n\t\ttcp_check_sack_reordering(sk, state->reord, 0);\r\n\r\n\ttcp_verify_left_out(tp);\r\nout:\r\n\r\n#if FASTRETRANS_DEBUG > 0\r\n\tWARN_ON((int)tp->sacked_out < 0);\r\n\tWARN_ON((int)tp->lost_out < 0);\r\n\tWARN_ON((int)tp->retrans_out < 0);\r\n\tWARN_ON((int)tcp_packets_in_flight(tp) < 0);\r\n#endif\r\n\treturn state->flag;\r\n}", ".cp_clean_rtx_queue": "static int tcp_clean_rtx_queue(struct sock *sk, const struct sk_buff *ack_skb,\r\n\t\t\t       u32 prior_fack, u32 prior_snd_una,\r\n\t\t\t       struct tcp_sacktag_state *sack, bool ece_ack)\r\n{\r\n\tconst struct inet_connection_sock *icsk = inet_csk(sk);\r\n\tu64 first_ackt, last_ackt;\r\n\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\tu32 prior_sacked = tp->sacked_out;\r\n\tu32 reord = tp->snd_nxt; /* lowest acked un-retx un-sacked seq */\r\n\tstruct sk_buff *skb, *next;\r\n\tbool fully_acked = true;\r\n\tlong sack_rtt_us = -1L;\r\n\tlong seq_rtt_us = -1L;\r\n\tlong ca_rtt_us = -1L;\r\n\tu32 pkts_acked = 0;\r\n\tbool rtt_update;\r\n\tint flag = 0;\r\n\r\n\tfirst_ackt = 0;\r\n\r\n\tfor (skb = skb_rb_first(&sk->tcp_rtx_queue); skb; skb = next) {\r\n\t\tstruct tcp_skb_cb *scb = TCP_SKB_CB(skb);\r\n\t\tconst u32 start_seq = scb->seq;\r\n\t\tu8 sacked = scb->sacked;\r\n\t\tu32 acked_pcount;\r\n\r\n\t\t/* Determine how many packets and what bytes were acked, tso and else */\r\n\t\tif (after(scb->end_seq, tp->snd_una)) {\r\n\t\t\tif (tcp_skb_pcount(skb) == 1 ||\r\n\t\t\t    !after(tp->snd_una, scb->seq))\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tacked_pcount = tcp_tso_acked(sk, skb);\r\n\t\t\tif (!acked_pcount)\r\n\t\t\t\tbreak;\r\n\t\t\tfully_acked = false;\r\n\t\t} else {\r\n\t\t\tacked_pcount = tcp_skb_pcount(skb);\r\n\t\t}\r\n\r\n\t\tif (unlikely(sacked & TCPCB_RETRANS)) {\r\n\t\t\tif (sacked & TCPCB_SACKED_RETRANS)\r\n\t\t\t\ttp->retrans_out -= acked_pcount;\r\n\t\t\tflag |= FLAG_RETRANS_DATA_ACKED;\r\n\t\t} else if (!(sacked & TCPCB_SACKED_ACKED)) {\r\n\t\t\tlast_ackt = tcp_skb_timestamp_us(skb);\r\n\t\t\tWARN_ON_ONCE(last_ackt == 0);\r\n\t\t\tif (!first_ackt)\r\n\t\t\t\tfirst_ackt = last_ackt;\r\n\r\n\t\t\tif (before(start_seq, reord))\r\n\t\t\t\treord = start_seq;\r\n\t\t\tif (!after(scb->end_seq, tp->high_seq))\r\n\t\t\t\tflag |= FLAG_ORIG_SACK_ACKED;\r\n\t\t}\r\n\r\n\t\tif (sacked & TCPCB_SACKED_ACKED) {\r\n\t\t\ttp->sacked_out -= acked_pcount;\r\n\t\t\t/* snd_una delta covers these skbs */\r\n\t\t\tsack->delivered_bytes -= skb->len;\r\n\t\t} else if (tcp_is_sack(tp)) {\r\n\t\t\ttcp_count_delivered(tp, acked_pcount, ece_ack);\r\n\t\t\tif (!tcp_skb_spurious_retrans(tp, skb))\r\n\t\t\t\ttcp_rack_advance(tp, sacked, scb->end_seq,\r\n\t\t\t\t\t\t tcp_skb_timestamp_us(skb));\r\n\t\t}\r\n\t\tif (sacked & TCPCB_LOST)\r\n\t\t\ttp->lost_out -= acked_pcount;\r\n\r\n\t\ttp->packets_out -= acked_pcount;\r\n\t\tpkts_acked += acked_pcount;\r\n\t\ttcp_rate_skb_delivered(sk, skb, sack->rate);\r\n\r\n\t\t/* Initial outgoing SYN's get put onto the write_queue\r\n\t\t * just like anything else we transmit.  It is not\r\n\t\t * true data, and if we misinform our callers that\r\n\t\t * this ACK acks real data, we will erroneously exit\r\n\t\t * connection startup slow start one packet too\r\n\t\t * quickly.  This is severely frowned upon behavior.\r\n\t\t */\r\n\t\tif (likely(!(scb->tcp_flags & TCPHDR_SYN))) {\r\n\t\t\tflag |= FLAG_DATA_ACKED;\r\n\t\t} else {\r\n\t\t\tflag |= FLAG_SYN_ACKED;\r\n\t\t\ttp->retrans_stamp = 0;\r\n\t\t}\r\n\r\n\t\tif (!fully_acked)\r\n\t\t\tbreak;\r\n\r\n\t\ttcp_ack_tstamp(sk, skb, ack_skb, prior_snd_una);\r\n\r\n\t\tnext = skb_rb_next(skb);\r\n\t\tif (unlikely(skb == tp->retransmit_skb_hint))\r\n\t\t\ttp->retransmit_skb_hint = NULL;\r\n\t\ttcp_highest_sack_replace(sk, skb, next);\r\n\t\ttcp_rtx_queue_unlink_and_free(skb, sk);\r\n\t}\r\n\r\n\tif (!skb)\r\n\t\ttcp_chrono_stop(sk, TCP_CHRONO_BUSY);\r\n\r\n\tif (likely(between(tp->snd_up, prior_snd_una, tp->snd_una)))\r\n\t\ttp->snd_up = tp->snd_una;\r\n\r\n\tif (skb) {\r\n\t\ttcp_ack_tstamp(sk, skb, ack_skb, prior_snd_una);\r\n\t\tif (TCP_SKB_CB(skb)->sacked & TCPCB_SACKED_ACKED)\r\n\t\t\tflag |= FLAG_SACK_RENEGING;\r\n\t}\r\n\r\n\tif (likely(first_ackt) && !(flag & FLAG_RETRANS_DATA_ACKED)) {\r\n\t\tseq_rtt_us = tcp_stamp_us_delta(tp->tcp_mstamp, first_ackt);\r\n\t\tca_rtt_us = tcp_stamp_us_delta(tp->tcp_mstamp, last_ackt);\r\n\r\n\t\tif (pkts_acked == 1 && fully_acked && !prior_sacked &&\r\n\t\t    (tp->snd_una - prior_snd_una) < tp->mss_cache &&\r\n\t\t    sack->rate->prior_delivered + 1 == tp->delivered &&\r\n\t\t    !(flag & (FLAG_CA_ALERT | FLAG_SYN_ACKED))) {\r\n\t\t\t/* Conservatively mark a delayed ACK. It's typically\r\n\t\t\t * from a lone runt packet over the round trip to\r\n\t\t\t * a receiver w/o out-of-order or CE events.\r\n\t\t\t */\r\n\t\t\tflag |= FLAG_ACK_MAYBE_DELAYED;\r\n\t\t}\r\n\t}\r\n\tif (sack->first_sackt) {\r\n\t\tsack_rtt_us = tcp_stamp_us_delta(tp->tcp_mstamp, sack->first_sackt);\r\n\t\tca_rtt_us = tcp_stamp_us_delta(tp->tcp_mstamp, sack->last_sackt);\r\n\t}\r\n\trtt_update = tcp_ack_update_rtt(sk, flag, seq_rtt_us, sack_rtt_us,\r\n\t\t\t\t\tca_rtt_us, sack->rate);\r\n\r\n\tif (flag & FLAG_ACKED) {\r\n\t\tflag |= FLAG_SET_XMIT_TIMER;  /* set TLP or RTO timer */\r\n\t\tif (unlikely(icsk->icsk_mtup.probe_size &&\r\n\t\t\t     !after(tp->mtu_probe.probe_seq_end, tp->snd_una))) {\r\n\t\t\ttcp_mtup_probe_success(sk);\r\n\t\t}\r\n\r\n\t\tif (tcp_is_reno(tp)) {\r\n\t\t\ttcp_remove_reno_sacks(sk, pkts_acked, ece_ack);\r\n\r\n\t\t\t/* If any of the cumulatively ACKed segments was\r\n\t\t\t * retransmitted, non-SACK case cannot confirm that\r\n\t\t\t * progress was due to original transmission due to\r\n\t\t\t * lack of TCPCB_SACKED_ACKED bits even if some of\r\n\t\t\t * the packets may have been never retransmitted.\r\n\t\t\t */\r\n\t\t\tif (flag & FLAG_RETRANS_DATA_ACKED)\r\n\t\t\t\tflag &= ~FLAG_ORIG_SACK_ACKED;\r\n\t\t} else {\r\n\t\t\t/* Non-retransmitted hole got filled? That's reordering */\r\n\t\t\tif (before(reord, prior_fack))\r\n\t\t\t\ttcp_check_sack_reordering(sk, reord, 0);\r\n\t\t}\r\n\r\n\t\tsack->delivered_bytes = (skb ?\r\n\t\t\t\t\t TCP_SKB_CB(skb)->seq : tp->snd_una) -\r\n\t\t\t\t\t prior_snd_una;\r\n\t} else if (skb && rtt_update && sack_rtt_us >= 0 &&\r\n\t\t   sack_rtt_us > tcp_stamp_us_delta(tp->tcp_mstamp,\r\n\t\t\t\t\t\t    tcp_skb_timestamp_us(skb))) {\r\n\t\t/* Do not re-arm RTO if the sack RTT is measured from data sent\r\n\t\t * after when the head was last (re)transmitted. Otherwise the\r\n\t\t * timeout may continue to extend in loss recovery.\r\n\t\t */\r\n\t\tflag |= FLAG_SET_XMIT_TIMER;  /* set TLP or RTO timer */\r\n\t}\r\n\r\n\tif (icsk->icsk_ca_ops->pkts_acked) {\r\n\t\tstruct ack_sample sample = { .pkts_acked = pkts_acked,\r\n\t\t\t\t\t     .rtt_us = sack->rate->rtt_us };\r\n\r\n\t\tsample.in_flight = tp->mss_cache *\r\n\t\t\t(tp->delivered - sack->rate->prior_delivered);\r\n\t\ticsk->icsk_ca_ops->pkts_acked(sk, &sample);\r\n\t}\r\n\r\n#if FASTRETRANS_DEBUG > 0\r\n\tWARN_ON((int)tp->sacked_out < 0);\r\n\tWARN_ON((int)tp->lost_out < 0);\r\n\tWARN_ON((int)tp->retrans_out < 0);\r\n\tif (!tp->packets_out && tcp_is_sack(tp)) {\r\n\t\ticsk = inet_csk(sk);\r\n\t\tif (tp->lost_out) {\r\n\t\t\tpr_debug(\"Leak l=%u %d\\n\",\r\n\t\t\t\t tp->lost_out, icsk->icsk_ca_state);\r\n\t\t\ttp->lost_out = 0;\r\n\t\t}\r\n\t\tif (tp->sacked_out) {\r\n\t\t\tpr_debug(\"Leak s=%u %d\\n\",\r\n\t\t\t\t tp->sacked_out, icsk->icsk_ca_state);\r\n\t\t\ttp->sacked_out = 0;\r\n\t\t}\r\n\t\tif (tp->retrans_out) {\r\n\t\t\tpr_debug(\"Leak r=%u %d\\n\",\r\n\t\t\t\t tp->retrans_out, icsk->icsk_ca_state);\r\n\t\t\ttp->retrans_out = 0;\r\n\t\t}\r\n\t}\r\n#endif\r\n\treturn flag;\r\n}", ".cp_accecn_process": "static u32 tcp_accecn_process(struct sock *sk, const struct sk_buff *skb,\r\n\t\t\t      u32 delivered_pkts, u32 delivered_bytes,\r\n\t\t\t      int *flag)\r\n{\r\n\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\tu32 delta;\r\n\r\n\tdelta = __tcp_accecn_process(sk, skb, delivered_pkts,\r\n\t\t\t\t     delivered_bytes, *flag);\r\n\tif (delta > 0) {\r\n\t\ttcp_count_delivered_ce(tp, delta);\r\n\t\t*flag |= FLAG_ECE;\r\n\t\t/* Recalculate header predictor */\r\n\t\tif (tp->pred_flags)\r\n\t\t\ttcp_fast_path_on(tp);\r\n\t}\r\n\treturn delta;\r\n}", ".cp_in_ack_event": "static void tcp_in_ack_event(struct sock *sk, int flag)\r\n{\r\n\tconst struct inet_connection_sock *icsk = inet_csk(sk);\r\n\r\n\tif (icsk->icsk_ca_ops->in_ack_event) {\r\n\t\tu32 ack_ev_flags = 0;\r\n\r\n\t\tif (flag & FLAG_WIN_UPDATE)\r\n\t\t\tack_ev_flags |= CA_ACK_WIN_UPDATE;\r\n\t\tif (flag & FLAG_SLOWPATH) {\r\n\t\t\tack_ev_flags |= CA_ACK_SLOWPATH;\r\n\t\t\tif (flag & FLAG_ECE)\r\n\t\t\t\tack_ev_flags |= CA_ACK_ECE;\r\n\t\t}\r\n\r\n\t\ticsk->icsk_ca_ops->in_ack_event(sk, ack_ev_flags);\r\n\t}\r\n}", ".cp_process_tlp_ack": "static void tcp_process_tlp_ack(struct sock *sk, u32 ack, int flag)\r\n{\r\n\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\r\n\tif (before(ack, tp->tlp_high_seq))\r\n\t\treturn;\r\n\r\n\tif (!tp->tlp_retrans) {\r\n\t\t/* TLP of new data has been acknowledged */\r\n\t\ttp->tlp_high_seq = 0;\r\n\t} else if (flag & FLAG_DSACK_TLP) {\r\n\t\t/* This DSACK means original and TLP probe arrived; no loss */\r\n\t\ttp->tlp_high_seq = 0;\r\n\t} else if (after(ack, tp->tlp_high_seq)) {\r\n\t\t/* ACK advances: there was a loss, so reduce cwnd. Reset\r\n\t\t * tlp_high_seq in tcp_init_cwnd_reduction()\r\n\t\t */\r\n\t\ttcp_init_cwnd_reduction(sk);\r\n\t\ttcp_set_ca_state(sk, TCP_CA_CWR);\r\n\t\ttcp_end_cwnd_reduction(sk);\r\n\t\ttcp_try_keep_open(sk);\r\n\t\tNET_INC_STATS(sock_net(sk),\r\n\t\t\t\tLINUX_MIB_TCPLOSSPROBERECOVERY);\r\n\t} else if (!(flag & (FLAG_SND_UNA_ADVANCED |\r\n\t\t\t     FLAG_NOT_DUP | FLAG_DATA_SACKED))) {\r\n\t\t/* Pure dupack: original and TLP probe arrived; no loss */\r\n\t\ttp->tlp_high_seq = 0;\r\n\t}\r\n}", ".cp_ack_is_dubious": "static inline bool tcp_ack_is_dubious(const struct sock *sk, const int flag)\r\n{\r\n\treturn !(flag & FLAG_NOT_DUP) || (flag & FLAG_CA_ALERT) ||\r\n\t\tinet_csk(sk)->icsk_ca_state != TCP_CA_Open;\r\n}", ".cp_fastretrans_alert": "static void tcp_fastretrans_alert(struct sock *sk, const u32 prior_snd_una,\r\n\t\t\t\t  int num_dupack, int *ack_flag, int *rexmit)\r\n{\r\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\r\n\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\tint flag = *ack_flag;\r\n\tbool ece_ack = flag & FLAG_ECE;\r\n\r\n\tif (!tp->packets_out && tp->sacked_out)\r\n\t\ttp->sacked_out = 0;\r\n\r\n\t/* Now state machine starts.\r\n\t * A. ECE, hence prohibit cwnd undoing, the reduction is required. */\r\n\tif (ece_ack)\r\n\t\ttp->prior_ssthresh = 0;\r\n\r\n\t/* B. In all the states check for reneging SACKs. */\r\n\tif (tcp_check_sack_reneging(sk, ack_flag))\r\n\t\treturn;\r\n\r\n\t/* C. Check consistency of the current state. */\r\n\ttcp_verify_left_out(tp);\r\n\r\n\t/* D. Check state exit conditions. State can be terminated\r\n\t *    when high_seq is ACKed. */\r\n\tif (icsk->icsk_ca_state == TCP_CA_Open) {\r\n\t\tWARN_ON(tp->retrans_out != 0 && !tp->syn_data);\r\n\t\ttp->retrans_stamp = 0;\r\n\t} else if (!before(tp->snd_una, tp->high_seq)) {\r\n\t\tswitch (icsk->icsk_ca_state) {\r\n\t\tcase TCP_CA_CWR:\r\n\t\t\t/* CWR is to be held something *above* high_seq\r\n\t\t\t * is ACKed for CWR bit to reach receiver. */\r\n\t\t\tif (tp->snd_una != tp->high_seq) {\r\n\t\t\t\ttcp_end_cwnd_reduction(sk);\r\n\t\t\t\ttcp_set_ca_state(sk, TCP_CA_Open);\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\r\n\t\tcase TCP_CA_Recovery:\r\n\t\t\tif (tcp_is_reno(tp))\r\n\t\t\t\ttcp_reset_reno_sack(tp);\r\n\t\t\tif (tcp_try_undo_recovery(sk))\r\n\t\t\t\treturn;\r\n\t\t\ttcp_end_cwnd_reduction(sk);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\r\n\t/* E. Process state. */\r\n\tswitch (icsk->icsk_ca_state) {\r\n\tcase TCP_CA_Recovery:\r\n\t\tif (!(flag & FLAG_SND_UNA_ADVANCED)) {\r\n\t\t\tif (tcp_is_reno(tp))\r\n\t\t\t\ttcp_add_reno_sack(sk, num_dupack, ece_ack);\r\n\t\t} else if (tcp_try_undo_partial(sk, prior_snd_una))\r\n\t\t\treturn;\r\n\r\n\t\tif (tcp_try_undo_dsack(sk))\r\n\t\t\ttcp_try_to_open(sk, flag);\r\n\r\n\t\ttcp_identify_packet_loss(sk, ack_flag);\r\n\t\tif (icsk->icsk_ca_state != TCP_CA_Recovery) {\r\n\t\t\tif (!tcp_time_to_recover(tp))\r\n\t\t\t\treturn;\r\n\t\t\t/* Undo reverts the recovery state. If loss is evident,\r\n\t\t\t * starts a new recovery (e.g. reordering then loss);\r\n\t\t\t */\r\n\t\t\ttcp_enter_recovery(sk, ece_ack);\r\n\t\t}\r\n\t\tbreak;\r\n\tcase TCP_CA_Loss:\r\n\t\ttcp_process_loss(sk, flag, num_dupack, rexmit);\r\n\t\tif (icsk->icsk_ca_state != TCP_CA_Loss)\r\n\t\t\ttcp_update_rto_time(tp);\r\n\t\ttcp_identify_packet_loss(sk, ack_flag);\r\n\t\tif (!(icsk->icsk_ca_state == TCP_CA_Open ||\r\n\t\t      (*ack_flag & FLAG_LOST_RETRANS)))\r\n\t\t\treturn;\r\n\t\t/* Change state if cwnd is undone or retransmits are lost */\r\n\t\tfallthrough;\r\n\tdefault:\r\n\t\tif (tcp_is_reno(tp)) {\r\n\t\t\tif (flag & FLAG_SND_UNA_ADVANCED)\r\n\t\t\t\ttcp_reset_reno_sack(tp);\r\n\t\t\ttcp_add_reno_sack(sk, num_dupack, ece_ack);\r\n\t\t}\r\n\r\n\t\tif (icsk->icsk_ca_state <= TCP_CA_Disorder)\r\n\t\t\ttcp_try_undo_dsack(sk);\r\n\r\n\t\ttcp_identify_packet_loss(sk, ack_flag);\r\n\t\tif (!tcp_time_to_recover(tp)) {\r\n\t\t\ttcp_try_to_open(sk, flag);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t/* MTU probe failure: don't reduce cwnd */\r\n\t\tif (icsk->icsk_ca_state < TCP_CA_CWR &&\r\n\t\t    icsk->icsk_mtup.probe_size &&\r\n\t\t    tp->snd_una == tp->mtu_probe.probe_seq_start) {\r\n\t\t\ttcp_mtup_probe_failed(sk);\r\n\t\t\t/* Restores the reduction we did in tcp_mtup_probe() */\r\n\t\t\ttcp_snd_cwnd_set(tp, tcp_snd_cwnd(tp) + 1);\r\n\t\t\ttcp_simple_retransmit(sk);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t/* Otherwise enter Recovery state */\r\n\t\ttcp_enter_recovery(sk, ece_ack);\r\n\t}\r\n\r\n\t*rexmit = REXMIT_LOST;\r\n}", ".cp_set_xmit_timer": "static void tcp_set_xmit_timer(struct sock *sk)\r\n{\r\n\tif (!tcp_schedule_loss_probe(sk, true))\r\n\t\ttcp_rearm_rto(sk);\r\n}", ".cp_newly_delivered": "static u32 tcp_newly_delivered(struct sock *sk, u32 prior_delivered,\r\n\t\t\t       u32 ecn_count, int flag)\r\n{\r\n\tconst struct net *net = sock_net(sk);\r\n\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\tu32 delivered;\r\n\r\n\tdelivered = tp->delivered - prior_delivered;\r\n\tNET_ADD_STATS(net, LINUX_MIB_TCPDELIVERED, delivered);\r\n\r\n\tif (flag & FLAG_ECE) {\r\n\t\tif (tcp_ecn_mode_rfc3168(tp))\r\n\t\t\tecn_count = delivered;\r\n\t\tNET_ADD_STATS(net, LINUX_MIB_TCPDELIVEREDCE, ecn_count);\r\n\t}\r\n\r\n\treturn delivered;\r\n}", ".cp_cong_control": "static void tcp_cong_control(struct sock *sk, u32 ack, u32 acked_sacked,\r\n\t\t\t     int flag, const struct rate_sample *rs)\r\n{\r\n\tconst struct inet_connection_sock *icsk = inet_csk(sk);\r\n\r\n\tif (icsk->icsk_ca_ops->cong_control) {\r\n\t\ticsk->icsk_ca_ops->cong_control(sk, ack, flag, rs);\r\n\t\treturn;\r\n\t}\r\n\r\n\tif (tcp_in_cwnd_reduction(sk)) {\r\n\t\t/* Reduce cwnd if state mandates */\r\n\t\ttcp_cwnd_reduction(sk, acked_sacked, rs->losses, flag);\r\n\t} else if (tcp_may_raise_cwnd(sk, flag)) {\r\n\t\t/* Advance cwnd if state allows */\r\n\t\ttcp_cong_avoid(sk, ack, acked_sacked);\r\n\t}\r\n\ttcp_update_pacing_rate(sk);\r\n}", ".cp_xmit_recovery": "static void tcp_xmit_recovery(struct sock *sk, int rexmit)\r\n{\r\n\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\r\n\tif (rexmit == REXMIT_NONE || sk->sk_state == TCP_SYN_SENT)\r\n\t\treturn;\r\n\r\n\tif (unlikely(rexmit == REXMIT_NEW)) {\r\n\t\t__tcp_push_pending_frames(sk, tcp_current_mss(sk),\r\n\t\t\t\t\t  TCP_NAGLE_OFF);\r\n\t\tif (after(tp->snd_nxt, tp->high_seq))\r\n\t\t\treturn;\r\n\t\ttp->frto = 0;\r\n\t}\r\n\ttcp_xmit_retransmit_queue(sk);\r\n}", ".cp_ack_probe": "static void tcp_ack_probe(struct sock *sk)\r\n{\r\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\r\n\tstruct sk_buff *head = tcp_send_head(sk);\r\n\tconst struct tcp_sock *tp = tcp_sk(sk);\r\n\r\n\t/* Was it a usable window open? */\r\n\tif (!head)\r\n\t\treturn;\r\n\tif (!after(TCP_SKB_CB(head)->end_seq, tcp_wnd_end(tp))) {\r\n\t\ticsk->icsk_backoff = 0;\r\n\t\ticsk->icsk_probes_tstamp = 0;\r\n\t\tinet_csk_clear_xmit_timer(sk, ICSK_TIME_PROBE0);\r\n\t\t/* Socket must be waked up by subsequent tcp_data_snd_check().\r\n\t\t * This function is not for random using!\r\n\t\t */\r\n\t} else {\r\n\t\tunsigned long when = tcp_probe0_when(sk, tcp_rto_max(sk));\r\n\r\n\t\twhen = tcp_clamp_probe0_to_user_timeout(sk, when);\r\n\t\ttcp_reset_xmit_timer(sk, ICSK_TIME_PROBE0, when, true);\r\n\t}\r\n}", ".cp_parse_fastopen_option": "static void tcp_parse_fastopen_option(int len, const unsigned char *cookie,\r\n\t\t\t\t      bool syn, struct tcp_fastopen_cookie *foc,\r\n\t\t\t\t      bool exp_opt)\r\n{\r\n\t/* Valid only in SYN or SYN-ACK with an even length.  */\r\n\tif (!foc || !syn || len < 0 || (len & 1))\r\n\t\treturn;\r\n\r\n\tif (len >= TCP_FASTOPEN_COOKIE_MIN &&\r\n\t    len <= TCP_FASTOPEN_COOKIE_MAX)\r\n\t\tmemcpy(foc->val, cookie, len);\r\n\telse if (len != 0)\r\n\t\tlen = -1;\r\n\tfoc->len = len;\r\n\tfoc->exp = exp_opt;\r\n}", ".mc_parse_options": "static bool smc_parse_options(const struct tcphdr *th,\r\n\t\t\t      struct tcp_options_received *opt_rx,\r\n\t\t\t      const unsigned char *ptr,\r\n\t\t\t      int opsize)\r\n{\r\n#if IS_ENABLED(CONFIG_SMC)\r\n\tif (static_branch_unlikely(&tcp_have_smc)) {\r\n\t\tif (th->syn && !(opsize & 1) &&\r\n\t\t    opsize >= TCPOLEN_EXP_SMC_BASE &&\r\n\t\t    get_unaligned_be32(ptr) == TCPOPT_SMC_MAGIC) {\r\n\t\t\topt_rx->smc_ok = 1;\r\n\t\t\treturn true;\r\n\t\t}\r\n\t}\r\n#endif\r\n\treturn false;\r\n}", ".cp_parse_aligned_timestamp": "static bool tcp_parse_aligned_timestamp(struct tcp_sock *tp, const struct tcphdr *th)\r\n{\r\n\tconst __be32 *ptr = (const __be32 *)(th + 1);\r\n\r\n\tif (*ptr == htonl((TCPOPT_NOP << 24) | (TCPOPT_NOP << 16)\r\n\t\t\t  | (TCPOPT_TIMESTAMP << 8) | TCPOLEN_TIMESTAMP)) {\r\n\t\ttp->rx_opt.saw_tstamp = 1;\r\n\t\t++ptr;\r\n\t\ttp->rx_opt.rcv_tsval = ntohl(*ptr);\r\n\t\t++ptr;\r\n\t\tif (*ptr)\r\n\t\t\ttp->rx_opt.rcv_tsecr = ntohl(*ptr) - tp->tsoffset;\r\n\t\telse\r\n\t\t\ttp->rx_opt.rcv_tsecr = 0;\r\n\t\treturn true;\r\n\t}\r\n\treturn false;\r\n}", ".cp_parse_options": "void tcp_parse_options(const struct net *net,\r\n\t\t       const struct sk_buff *skb,\r\n\t\t       struct tcp_options_received *opt_rx, int estab,\r\n\t\t       struct tcp_fastopen_cookie *foc)\r\n{\r\n\tconst unsigned char *ptr;\r\n\tconst struct tcphdr *th = tcp_hdr(skb);\r\n\tint length = (th->doff * 4) - sizeof(struct tcphdr);\r\n\r\n\tptr = (const unsigned char *)(th + 1);\r\n\topt_rx->saw_tstamp = 0;\r\n\topt_rx->accecn = 0;\r\n\topt_rx->saw_unknown = 0;\r\n\r\n\twhile (length > 0) {\r\n\t\tint opcode = *ptr++;\r\n\t\tint opsize;\r\n\r\n\t\tswitch (opcode) {\r\n\t\tcase TCPOPT_EOL:\r\n\t\t\treturn;\r\n\t\tcase TCPOPT_NOP:\t/* Ref: RFC 793 section 3.1 */\r\n\t\t\tlength--;\r\n\t\t\tcontinue;\r\n\t\tdefault:\r\n\t\t\tif (length < 2)\r\n\t\t\t\treturn;\r\n\t\t\topsize = *ptr++;\r\n\t\t\tif (opsize < 2) /* \"silly options\" */\r\n\t\t\t\treturn;\r\n\t\t\tif (opsize > length)\r\n\t\t\t\treturn;\t/* don't parse partial options */\r\n\t\t\tswitch (opcode) {\r\n\t\t\tcase TCPOPT_MSS:\r\n\t\t\t\tif (opsize == TCPOLEN_MSS && th->syn && !estab) {\r\n\t\t\t\t\tu16 in_mss = get_unaligned_be16(ptr);\r\n\t\t\t\t\tif (in_mss) {\r\n\t\t\t\t\t\tif (opt_rx->user_mss &&\r\n\t\t\t\t\t\t    opt_rx->user_mss < in_mss)\r\n\t\t\t\t\t\t\tin_mss = opt_rx->user_mss;\r\n\t\t\t\t\t\topt_rx->mss_clamp = in_mss;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase TCPOPT_WINDOW:\r\n\t\t\t\tif (opsize == TCPOLEN_WINDOW && th->syn &&\r\n\t\t\t\t    !estab && READ_ONCE(net->ipv4.sysctl_tcp_window_scaling)) {\r\n\t\t\t\t\t__u8 snd_wscale = *(__u8 *)ptr;\r\n\t\t\t\t\topt_rx->wscale_ok = 1;\r\n\t\t\t\t\tif (snd_wscale > TCP_MAX_WSCALE) {\r\n\t\t\t\t\t\tnet_info_ratelimited(\"%s: Illegal window scaling value %d > %u received\\n\",\r\n\t\t\t\t\t\t\t\t     __func__,\r\n\t\t\t\t\t\t\t\t     snd_wscale,\r\n\t\t\t\t\t\t\t\t     TCP_MAX_WSCALE);\r\n\t\t\t\t\t\tsnd_wscale = TCP_MAX_WSCALE;\r\n\t\t\t\t\t}\r\n\t\t\t\t\topt_rx->snd_wscale = snd_wscale;\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase TCPOPT_TIMESTAMP:\r\n\t\t\t\tif ((opsize == TCPOLEN_TIMESTAMP) &&\r\n\t\t\t\t    ((estab && opt_rx->tstamp_ok) ||\r\n\t\t\t\t     (!estab && READ_ONCE(net->ipv4.sysctl_tcp_timestamps)))) {\r\n\t\t\t\t\topt_rx->saw_tstamp = 1;\r\n\t\t\t\t\topt_rx->rcv_tsval = get_unaligned_be32(ptr);\r\n\t\t\t\t\topt_rx->rcv_tsecr = get_unaligned_be32(ptr + 4);\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase TCPOPT_SACK_PERM:\r\n\t\t\t\tif (opsize == TCPOLEN_SACK_PERM && th->syn &&\r\n\t\t\t\t    !estab && READ_ONCE(net->ipv4.sysctl_tcp_sack)) {\r\n\t\t\t\t\topt_rx->sack_ok = TCP_SACK_SEEN;\r\n\t\t\t\t\ttcp_sack_reset(opt_rx);\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase TCPOPT_SACK:\r\n\t\t\t\tif ((opsize >= (TCPOLEN_SACK_BASE + TCPOLEN_SACK_PERBLOCK)) &&\r\n\t\t\t\t   !((opsize - TCPOLEN_SACK_BASE) % TCPOLEN_SACK_PERBLOCK) &&\r\n\t\t\t\t   opt_rx->sack_ok) {\r\n\t\t\t\t\tTCP_SKB_CB(skb)->sacked = (ptr - 2) - (unsigned char *)th;\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n#ifdef CONFIG_TCP_MD5SIG\r\n\t\t\tcase TCPOPT_MD5SIG:\r\n\t\t\t\t/* The MD5 Hash has already been\r\n\t\t\t\t * checked (see tcp_v{4,6}_rcv()).\r\n\t\t\t\t */\r\n\t\t\t\tbreak;\r\n#endif\r\n#ifdef CONFIG_TCP_AO\r\n\t\t\tcase TCPOPT_AO:\r\n\t\t\t\t/* TCP AO has already been checked\r\n\t\t\t\t * (see tcp_inbound_ao_hash()).\r\n\t\t\t\t */\r\n\t\t\t\tbreak;\r\n#endif\r\n\t\t\tcase TCPOPT_FASTOPEN:\r\n\t\t\t\ttcp_parse_fastopen_option(\r\n\t\t\t\t\topsize - TCPOLEN_FASTOPEN_BASE,\r\n\t\t\t\t\tptr, th->syn, foc, false);\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase TCPOPT_ACCECN0:\r\n\t\t\tcase TCPOPT_ACCECN1:\r\n\t\t\t\t/* Save offset of AccECN option in TCP header */\r\n\t\t\t\topt_rx->accecn = (ptr - 2) - (__u8 *)th;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase TCPOPT_EXP:\r\n\t\t\t\t/* Fast Open option shares code 254 using a\r\n\t\t\t\t * 16 bits magic number.\r\n\t\t\t\t */\r\n\t\t\t\tif (opsize >= TCPOLEN_EXP_FASTOPEN_BASE &&\r\n\t\t\t\t    get_unaligned_be16(ptr) ==\r\n\t\t\t\t    TCPOPT_FASTOPEN_MAGIC) {\r\n\t\t\t\t\ttcp_parse_fastopen_option(opsize -\r\n\t\t\t\t\t\tTCPOLEN_EXP_FASTOPEN_BASE,\r\n\t\t\t\t\t\tptr + 2, th->syn, foc, true);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (smc_parse_options(th, opt_rx, ptr, opsize))\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\topt_rx->saw_unknown = 1;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tdefault:\r\n\t\t\t\topt_rx->saw_unknown = 1;\r\n\t\t\t}\r\n\t\t\tptr += opsize-2;\r\n\t\t\tlength -= opsize;\r\n\t\t}\r\n\t}\r\n}", ".cp_tsval_replay": "static u32 tcp_tsval_replay(const struct sock *sk)\r\n{\r\n\t/* If we use usec TS resolution,\r\n\t * then expect the remote peer to use the same resolution.\r\n\t */\r\n\tif (tcp_sk(sk)->tcp_usec_ts)\r\n\t\treturn inet_csk(sk)->icsk_rto * (USEC_PER_SEC / HZ);\r\n\r\n\t/* RFC 7323 recommends a TSval clock between 1ms and 1sec.\r\n\t * We know that some OS (including old linux) can use 1200 Hz.\r\n\t */\r\n\treturn inet_csk(sk)->icsk_rto * 1200 / HZ;\r\n}", ".cp_done_with_error": "void tcp_done_with_error(struct sock *sk, int err)\r\n{\r\n\t/* This barrier is coupled with smp_rmb() in tcp_poll() */\r\n\tWRITE_ONCE(sk->sk_err, err);\r\n\tsmp_wmb();\r\n\r\n\ttcp_write_queue_purge(sk);\r\n\ttcp_done(sk);\r\n\r\n\tif (!sock_flag(sk, SOCK_DEAD))\r\n\t\tsk_error_report(sk);\r\n}", ".cp_dsack_set": "static void tcp_dsack_set(struct sock *sk, u32 seq, u32 end_seq)\r\n{\r\n\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\r\n\tif (tcp_is_sack(tp) && READ_ONCE(sock_net(sk)->ipv4.sysctl_tcp_dsack)) {\r\n\t\tint mib_idx;\r\n\r\n\t\tif (before(seq, tp->rcv_nxt))\r\n\t\t\tmib_idx = LINUX_MIB_TCPDSACKOLDSENT;\r\n\t\telse\r\n\t\t\tmib_idx = LINUX_MIB_TCPDSACKOFOSENT;\r\n\r\n\t\tNET_INC_STATS(sock_net(sk), mib_idx);\r\n\r\n\t\ttp->rx_opt.dsack = 1;\r\n\t\ttp->duplicate_sack[0].start_seq = seq;\r\n\t\ttp->duplicate_sack[0].end_seq = end_seq;\r\n\t}\r\n}", ".cp_sack_extend": "static inline bool tcp_sack_extend(struct tcp_sack_block *sp, u32 seq,\r\n\t\t\t\t  u32 end_seq)\r\n{\r\n\tif (!after(seq, sp->end_seq) && !after(sp->start_seq, end_seq)) {\r\n\t\tif (before(seq, sp->start_seq))\r\n\t\t\tsp->start_seq = seq;\r\n\t\tif (after(end_seq, sp->end_seq))\r\n\t\t\tsp->end_seq = end_seq;\r\n\t\treturn true;\r\n\t}\r\n\treturn false;\r\n}", ".cp_rcv_spurious_retrans": "static void tcp_rcv_spurious_retrans(struct sock *sk, const struct sk_buff *skb)\r\n{\r\n\t/* When the ACK path fails or drops most ACKs, the sender would\r\n\t * timeout and spuriously retransmit the same segment repeatedly.\r\n\t * If it seems our ACKs are not reaching the other side,\r\n\t * based on receiving a duplicate data segment with new flowlabel\r\n\t * (suggesting the sender suffered an RTO), and we are not already\r\n\t * repathing due to our own RTO, then rehash the socket to repath our\r\n\t * packets.\r\n\t */\r\n#if IS_ENABLED(CONFIG_IPV6)\r\n\tif (inet_csk(sk)->icsk_ca_state != TCP_CA_Loss &&\r\n\t    skb->protocol == htons(ETH_P_IPV6) &&\r\n\t    (tcp_sk(sk)->inet_conn.icsk_ack.lrcv_flowlabel !=\r\n\t     ntohl(ip6_flowlabel(ipv6_hdr(skb)))) &&\r\n\t    sk_rethink_txhash(sk))\r\n\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPDUPLICATEDATAREHASH);\r\n\r\n\t/* Save last flowlabel after a spurious retrans. */\r\n\ttcp_save_lrcv_flowlabel(sk, skb);\r\n#endif\r\n}", ".cp_sack_compress_send_ack": "void tcp_sack_compress_send_ack(struct sock *sk)\r\n{\r\n\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\r\n\tif (!tp->compressed_ack)\r\n\t\treturn;\r\n\r\n\tif (hrtimer_try_to_cancel(&tp->compressed_ack_timer) == 1)\r\n\t\t__sock_put(sk);\r\n\r\n\t/* Since we have to send one ack finally,\r\n\t * substract one from tp->compressed_ack to keep\r\n\t * LINUX_MIB_TCPACKCOMPRESSED accurate.\r\n\t */\r\n\tNET_ADD_STATS(sock_net(sk), LINUX_MIB_TCPACKCOMPRESSED,\r\n\t\t      tp->compressed_ack - 1);\r\n\r\n\ttp->compressed_ack = 0;\r\n\ttcp_send_ack(sk);\r\n}", ".cp_sack_maybe_coalesce": "static void tcp_sack_maybe_coalesce(struct tcp_sock *tp)\r\n{\r\n\tint this_sack;\r\n\tstruct tcp_sack_block *sp = &tp->selective_acks[0];\r\n\tstruct tcp_sack_block *swalk = sp + 1;\r\n\r\n\t/* See if the recent change to the first SACK eats into\r\n\t * or hits the sequence space of other SACK blocks, if so coalesce.\r\n\t */\r\n\tfor (this_sack = 1; this_sack < tp->rx_opt.num_sacks;) {\r\n\t\tif (tcp_sack_extend(sp, swalk->start_seq, swalk->end_seq)) {\r\n\t\t\tint i;\r\n\r\n\t\t\t/* Zap SWALK, by moving every further SACK up by one slot.\r\n\t\t\t * Decrease num_sacks.\r\n\t\t\t */\r\n\t\t\ttp->rx_opt.num_sacks--;\r\n\t\t\tfor (i = this_sack; i < tp->rx_opt.num_sacks; i++)\r\n\t\t\t\tsp[i] = sp[i + 1];\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tthis_sack++;\r\n\t\tswalk++;\r\n\t}\r\n}", ".cp_try_coalesce": "static bool tcp_try_coalesce(struct sock *sk,\r\n\t\t\t     struct sk_buff *to,\r\n\t\t\t     struct sk_buff *from,\r\n\t\t\t     bool *fragstolen)\r\n{\r\n\tint delta;\r\n\r\n\t*fragstolen = false;\r\n\r\n\t/* Its possible this segment overlaps with prior segment in queue */\r\n\tif (TCP_SKB_CB(from)->seq != TCP_SKB_CB(to)->end_seq)\r\n\t\treturn false;\r\n\r\n\tif (!tcp_skb_can_collapse_rx(to, from))\r\n\t\treturn false;\r\n\r\n\tif (!skb_try_coalesce(to, from, fragstolen, &delta))\r\n\t\treturn false;\r\n\r\n\tatomic_add(delta, &sk->sk_rmem_alloc);\r\n\tsk_mem_charge(sk, delta);\r\n\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPRCVCOALESCE);\r\n\tTCP_SKB_CB(to)->end_seq = TCP_SKB_CB(from)->end_seq;\r\n\tTCP_SKB_CB(to)->ack_seq = TCP_SKB_CB(from)->ack_seq;\r\n\tTCP_SKB_CB(to)->tcp_flags |= TCP_SKB_CB(from)->tcp_flags;\r\n\r\n\tif (TCP_SKB_CB(from)->has_rxtstamp) {\r\n\t\tTCP_SKB_CB(to)->has_rxtstamp = true;\r\n\t\tto->tstamp = from->tstamp;\r\n\t\tskb_hwtstamps(to)->hwtstamp = skb_hwtstamps(from)->hwtstamp;\r\n\t}\r\n\r\n\treturn true;\r\n}", ".cp_can_ingest": "static bool tcp_can_ingest(const struct sock *sk, const struct sk_buff *skb)\r\n{\r\n\tunsigned int rmem = atomic_read(&sk->sk_rmem_alloc);\r\n\r\n\treturn rmem + skb->len <= sk->sk_rcvbuf;\r\n}", ".cp_prune_queue": "static int tcp_prune_queue(struct sock *sk, const struct sk_buff *in_skb)\r\n{\r\n\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\r\n\t/* Do nothing if our queues are empty. */\r\n\tif (!atomic_read(&sk->sk_rmem_alloc))\r\n\t\treturn -1;\r\n\r\n\tNET_INC_STATS(sock_net(sk), LINUX_MIB_PRUNECALLED);\r\n\r\n\tif (!tcp_can_ingest(sk, in_skb))\r\n\t\ttcp_clamp_window(sk);\r\n\telse if (tcp_under_memory_pressure(sk))\r\n\t\ttcp_adjust_rcv_ssthresh(sk);\r\n\r\n\tif (tcp_can_ingest(sk, in_skb))\r\n\t\treturn 0;\r\n\r\n\ttcp_collapse_ofo_queue(sk);\r\n\tif (!skb_queue_empty(&sk->sk_receive_queue))\r\n\t\ttcp_collapse(sk, &sk->sk_receive_queue, NULL,\r\n\t\t\t     skb_peek(&sk->sk_receive_queue),\r\n\t\t\t     NULL,\r\n\t\t\t     tp->copied_seq, tp->rcv_nxt);\r\n\r\n\tif (tcp_can_ingest(sk, in_skb))\r\n\t\treturn 0;\r\n\r\n\t/* Collapsing did not help, destructive actions follow.\r\n\t * This must not ever occur. */\r\n\r\n\ttcp_prune_ofo_queue(sk, in_skb);\r\n\r\n\tif (tcp_can_ingest(sk, in_skb))\r\n\t\treturn 0;\r\n\r\n\t/* If we are really being abused, tell the caller to silently\r\n\t * drop receive data on the floor.  It will get retransmitted\r\n\t * and hopefully then we'll have sufficient space.\r\n\t */\r\n\tNET_INC_STATS(sock_net(sk), LINUX_MIB_RCVPRUNED);\r\n\r\n\t/* Massive buffer overcommit. */\r\n\ttp->pred_flags = 0;\r\n\treturn -1;\r\n}", ".cp_prune_ofo_queue": "static bool tcp_prune_ofo_queue(struct sock *sk, const struct sk_buff *in_skb)\r\n{\r\n\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\tstruct rb_node *node, *prev;\r\n\tbool pruned = false;\r\n\tint goal;\r\n\r\n\tif (RB_EMPTY_ROOT(&tp->out_of_order_queue))\r\n\t\treturn false;\r\n\r\n\tgoal = sk->sk_rcvbuf >> 3;\r\n\tnode = &tp->ooo_last_skb->rbnode;\r\n\r\n\tdo {\r\n\t\tstruct sk_buff *skb = rb_to_skb(node);\r\n\r\n\t\t/* If incoming skb would land last in ofo queue, stop pruning. */\r\n\t\tif (after(TCP_SKB_CB(in_skb)->seq, TCP_SKB_CB(skb)->seq))\r\n\t\t\tbreak;\r\n\t\tpruned = true;\r\n\t\tprev = rb_prev(node);\r\n\t\trb_erase(node, &tp->out_of_order_queue);\r\n\t\tgoal -= skb->truesize;\r\n\t\ttcp_drop_reason(sk, skb, SKB_DROP_REASON_TCP_OFO_QUEUE_PRUNE);\r\n\t\ttp->ooo_last_skb = rb_to_skb(prev);\r\n\t\tif (!prev || goal <= 0) {\r\n\t\t\tif (tcp_can_ingest(sk, in_skb) &&\r\n\t\t\t    !tcp_under_memory_pressure(sk))\r\n\t\t\t\tbreak;\r\n\t\t\tgoal = sk->sk_rcvbuf >> 3;\r\n\t\t}\r\n\t\tnode = prev;\r\n\t} while (node);\r\n\r\n\tif (pruned) {\r\n\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_OFOPRUNED);\r\n\t\t/* Reset SACK state.  A conforming SACK implementation will\r\n\t\t * do the same at a timeout based retransmit.  When a connection\r\n\t\t * is in a sad state like this, we care only about integrity\r\n\t\t * of the connection not performance.\r\n\t\t */\r\n\t\tif (tp->rx_opt.sack_ok)\r\n\t\t\ttcp_sack_reset(&tp->rx_opt);\r\n\t}\r\n\treturn pruned;\r\n}", ".cp_try_rmem_schedule": "static int tcp_try_rmem_schedule(struct sock *sk, const struct sk_buff *skb,\r\n\t\t\t\t unsigned int size)\r\n{\r\n\tif (!tcp_can_ingest(sk, skb) ||\r\n\t    !sk_rmem_schedule(sk, skb, size)) {\r\n\r\n\t\tif (tcp_prune_queue(sk, skb) < 0)\r\n\t\t\treturn -1;\r\n\r\n\t\twhile (!sk_rmem_schedule(sk, skb, size)) {\r\n\t\t\tif (!tcp_prune_ofo_queue(sk, skb))\r\n\t\t\t\treturn -1;\r\n\t\t}\r\n\t}\r\n\treturn 0;\r\n}", ".cp_ooo_try_coalesce": "static bool tcp_ooo_try_coalesce(struct sock *sk,\r\n\t\t\t     struct sk_buff *to,\r\n\t\t\t     struct sk_buff *from,\r\n\t\t\t     bool *fragstolen)\r\n{\r\n\tbool res = tcp_try_coalesce(sk, to, from, fragstolen);\r\n\r\n\t/* In case tcp_drop_reason() is called later, update to->gso_segs */\r\n\tif (res) {\r\n\t\tu32 gso_segs = max_t(u16, 1, skb_shinfo(to)->gso_segs) +\r\n\t\t\t       max_t(u16, 1, skb_shinfo(from)->gso_segs);\r\n\r\n\t\tskb_shinfo(to)->gso_segs = min_t(u32, gso_segs, 0xFFFF);\r\n\t}\r\n\treturn res;\r\n}", ".cp_dsack_extend": "static void tcp_dsack_extend(struct sock *sk, u32 seq, u32 end_seq)\r\n{\r\n\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\r\n\tif (!tp->rx_opt.dsack)\r\n\t\ttcp_dsack_set(sk, seq, end_seq);\r\n\telse\r\n\t\ttcp_sack_extend(tp->duplicate_sack, seq, end_seq);\r\n}", ".cp_sack_new_ofo_skb": "static void tcp_sack_new_ofo_skb(struct sock *sk, u32 seq, u32 end_seq)\r\n{\r\n\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\tstruct tcp_sack_block *sp = &tp->selective_acks[0];\r\n\tint cur_sacks = tp->rx_opt.num_sacks;\r\n\tint this_sack;\r\n\r\n\tif (!cur_sacks)\r\n\t\tgoto new_sack;\r\n\r\n\tfor (this_sack = 0; this_sack < cur_sacks; this_sack++, sp++) {\r\n\t\tif (tcp_sack_extend(sp, seq, end_seq)) {\r\n\t\t\tif (this_sack >= TCP_SACK_BLOCKS_EXPECTED)\r\n\t\t\t\ttcp_sack_compress_send_ack(sk);\r\n\t\t\t/* Rotate this_sack to the first one. */\r\n\t\t\tfor (; this_sack > 0; this_sack--, sp--)\r\n\t\t\t\tswap(*sp, *(sp - 1));\r\n\t\t\tif (cur_sacks > 1)\r\n\t\t\t\ttcp_sack_maybe_coalesce(tp);\r\n\t\t\treturn;\r\n\t\t}\r\n\t}\r\n\r\n\tif (this_sack >= TCP_SACK_BLOCKS_EXPECTED)\r\n\t\ttcp_sack_compress_send_ack(sk);\r\n\r\n\t/* Could not find an adjacent existing SACK, build a new one,\r\n\t * put it at the front, and shift everyone else down.  We\r\n\t * always know there is at least one SACK present already here.\r\n\t *\r\n\t * If the sack array is full, forget about the last one.\r\n\t */\r\n\tif (this_sack >= TCP_NUM_SACKS) {\r\n\t\tthis_sack--;\r\n\t\ttp->rx_opt.num_sacks--;\r\n\t\tsp--;\r\n\t}\r\n\tfor (; this_sack > 0; this_sack--, sp--)\r\n\t\t*sp = *(sp - 1);\r\n\r\nnew_sack:\r\n\t/* Build the new head SACK, and we're done. */\r\n\tsp->start_seq = seq;\r\n\tsp->end_seq = end_seq;\r\n\ttp->rx_opt.num_sacks++;\r\n}", ".cp_rcv_nxt_update": "static void tcp_rcv_nxt_update(struct tcp_sock *tp, u32 seq)\r\n{\r\n\tu32 delta = seq - tp->rcv_nxt;\r\n\r\n\tsock_owned_by_me((struct sock *)tp);\r\n\ttp->bytes_received += delta;\r\n\ttcp_rcv_sne_update(tp, seq);\r\n\tWRITE_ONCE(tp->rcv_nxt, seq);\r\n}", ".cp_queue_rcv": "static int __must_check tcp_queue_rcv(struct sock *sk, struct sk_buff *skb,\r\n\t\t\t\t      bool *fragstolen)\r\n{\r\n\tint eaten;\r\n\tstruct sk_buff *tail = skb_peek_tail(&sk->sk_receive_queue);\r\n\r\n\teaten = (tail &&\r\n\t\t tcp_try_coalesce(sk, tail,\r\n\t\t\t\t  skb, fragstolen)) ? 1 : 0;\r\n\ttcp_rcv_nxt_update(tcp_sk(sk), TCP_SKB_CB(skb)->end_seq);\r\n\tif (!eaten) {\r\n\t\ttcp_add_receive_queue(sk, skb);\r\n\t\tskb_set_owner_r(skb, sk);\r\n\t}\r\n\treturn eaten;\r\n}", ".cp_event_data_recv": "static void tcp_event_data_recv(struct sock *sk, struct sk_buff *skb)\r\n{\r\n\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\r\n\tu32 now;\r\n\r\n\tinet_csk_schedule_ack(sk);\r\n\r\n\ttcp_measure_rcv_mss(sk, skb);\r\n\r\n\ttcp_rcv_rtt_measure(tp);\r\n\r\n\tnow = tcp_jiffies32;\r\n\r\n\tif (!icsk->icsk_ack.ato) {\r\n\t\t/* The _first_ data packet received, initialize\r\n\t\t * delayed ACK engine.\r\n\t\t */\r\n\t\ttcp_incr_quickack(sk, TCP_MAX_QUICKACKS);\r\n\t\ticsk->icsk_ack.ato = TCP_ATO_MIN;\r\n\t} else {\r\n\t\tint m = now - icsk->icsk_ack.lrcvtime;\r\n\r\n\t\tif (m <= TCP_ATO_MIN / 2) {\r\n\t\t\t/* The fastest case is the first. */\r\n\t\t\ticsk->icsk_ack.ato = (icsk->icsk_ack.ato >> 1) + TCP_ATO_MIN / 2;\r\n\t\t} else if (m < icsk->icsk_ack.ato) {\r\n\t\t\ticsk->icsk_ack.ato = (icsk->icsk_ack.ato >> 1) + m;\r\n\t\t\tif (icsk->icsk_ack.ato > icsk->icsk_rto)\r\n\t\t\t\ticsk->icsk_ack.ato = icsk->icsk_rto;\r\n\t\t} else if (m > icsk->icsk_rto) {\r\n\t\t\t/* Too long gap. Apparently sender failed to\r\n\t\t\t * restart window, so that we send ACKs quickly.\r\n\t\t\t */\r\n\t\t\ttcp_incr_quickack(sk, TCP_MAX_QUICKACKS);\r\n\t\t}\r\n\t}\r\n\ticsk->icsk_ack.lrcvtime = now;\r\n\ttcp_save_lrcv_flowlabel(sk, skb);\r\n\r\n\ttcp_data_ecn_check(sk, skb);\r\n\r\n\tif (skb->len >= 128)\r\n\t\ttcp_grow_window(sk, skb, true);\r\n}", ".cp_fin": "void tcp_fin(struct sock *sk)\r\n{\r\n\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\r\n\tinet_csk_schedule_ack(sk);\r\n\r\n\tWRITE_ONCE(sk->sk_shutdown, sk->sk_shutdown | RCV_SHUTDOWN);\r\n\tsock_set_flag(sk, SOCK_DONE);\r\n\r\n\tswitch (sk->sk_state) {\r\n\tcase TCP_SYN_RECV:\r\n\tcase TCP_ESTABLISHED:\r\n\t\t/* Move to CLOSE_WAIT */\r\n\t\ttcp_set_state(sk, TCP_CLOSE_WAIT);\r\n\t\tinet_csk_enter_pingpong_mode(sk);\r\n\t\tbreak;\r\n\r\n\tcase TCP_CLOSE_WAIT:\r\n\tcase TCP_CLOSING:\r\n\t\t/* Received a retransmission of the FIN, do\r\n\t\t * nothing.\r\n\t\t */\r\n\t\tbreak;\r\n\tcase TCP_LAST_ACK:\r\n\t\t/* RFC793: Remain in the LAST-ACK state. */\r\n\t\tbreak;\r\n\r\n\tcase TCP_FIN_WAIT1:\r\n\t\t/* This case occurs when a simultaneous close\r\n\t\t * happens, we must ack the received FIN and\r\n\t\t * enter the CLOSING state.\r\n\t\t */\r\n\t\ttcp_send_ack(sk);\r\n\t\ttcp_set_state(sk, TCP_CLOSING);\r\n\t\tbreak;\r\n\tcase TCP_FIN_WAIT2:\r\n\t\t/* Received a FIN -- send ACK and enter TIME_WAIT. */\r\n\t\ttcp_send_ack(sk);\r\n\t\ttcp_time_wait(sk, TCP_TIME_WAIT, 0);\r\n\t\tbreak;\r\n\tdefault:\r\n\t\t/* Only TCP_LISTEN and TCP_CLOSE are left, in these\r\n\t\t * cases we should never reach this piece of code.\r\n\t\t */\r\n\t\tpr_err(\"%s: Impossible, sk->sk_state=%d\\n\",\r\n\t\t       __func__, sk->sk_state);\r\n\t\tbreak;\r\n\t}\r\n\r\n\t/* It _is_ possible, that we have something out-of-order _after_ FIN.\r\n\t * Probably, we should reset in this case. For now drop them.\r\n\t */\r\n\tskb_rbtree_purge(&tp->out_of_order_queue);\r\n\tif (tcp_is_sack(tp))\r\n\t\ttcp_sack_reset(&tp->rx_opt);\r\n\r\n\tif (!sock_flag(sk, SOCK_DEAD)) {\r\n\t\tsk->sk_state_change(sk);\r\n\r\n\t\t/* Do not send POLL_HUP for half duplex close. */\r\n\t\tif (sk->sk_shutdown == SHUTDOWN_MASK ||\r\n\t\t    sk->sk_state == TCP_CLOSE)\r\n\t\t\tsk_wake_async(sk, SOCK_WAKE_WAITD, POLL_HUP);\r\n\t\telse\r\n\t\t\tsk_wake_async(sk, SOCK_WAKE_WAITD, POLL_IN);\r\n\t}\r\n}", ".cp_ofo_queue": "static void tcp_ofo_queue(struct sock *sk)\r\n{\r\n\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\t__u32 dsack_high = tp->rcv_nxt;\r\n\tbool fin, fragstolen, eaten;\r\n\tstruct sk_buff *skb, *tail;\r\n\tstruct rb_node *p;\r\n\r\n\tp = rb_first(&tp->out_of_order_queue);\r\n\twhile (p) {\r\n\t\tskb = rb_to_skb(p);\r\n\t\tif (after(TCP_SKB_CB(skb)->seq, tp->rcv_nxt))\r\n\t\t\tbreak;\r\n\r\n\t\tif (before(TCP_SKB_CB(skb)->seq, dsack_high)) {\r\n\t\t\t__u32 dsack = dsack_high;\r\n\r\n\t\t\tif (before(TCP_SKB_CB(skb)->end_seq, dsack_high))\r\n\t\t\t\tdsack = TCP_SKB_CB(skb)->end_seq;\r\n\t\t\ttcp_dsack_extend(sk, TCP_SKB_CB(skb)->seq, dsack);\r\n\t\t}\r\n\t\tp = rb_next(p);\r\n\t\trb_erase(&skb->rbnode, &tp->out_of_order_queue);\r\n\r\n\t\tif (unlikely(!after(TCP_SKB_CB(skb)->end_seq, tp->rcv_nxt))) {\r\n\t\t\ttcp_drop_reason(sk, skb, SKB_DROP_REASON_TCP_OFO_DROP);\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\ttail = skb_peek_tail(&sk->sk_receive_queue);\r\n\t\teaten = tail && tcp_try_coalesce(sk, tail, skb, &fragstolen);\r\n\t\ttcp_rcv_nxt_update(tp, TCP_SKB_CB(skb)->end_seq);\r\n\t\tfin = TCP_SKB_CB(skb)->tcp_flags & TCPHDR_FIN;\r\n\t\tif (!eaten)\r\n\t\t\ttcp_add_receive_queue(sk, skb);\r\n\t\telse\r\n\t\t\tkfree_skb_partial(skb, fragstolen);\r\n\r\n\t\tif (unlikely(fin)) {\r\n\t\t\ttcp_fin(sk);\r\n\t\t\t/* tcp_fin() purges tp->out_of_order_queue,\r\n\t\t\t * so we must end this loop right now.\r\n\t\t\t */\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n}", ".cp_sack_remove": "static void tcp_sack_remove(struct tcp_sock *tp)\r\n{\r\n\tstruct tcp_sack_block *sp = &tp->selective_acks[0];\r\n\tint num_sacks = tp->rx_opt.num_sacks;\r\n\tint this_sack;\r\n\r\n\t/* Empty ofo queue, hence, all the SACKs are eaten. Clear. */\r\n\tif (RB_EMPTY_ROOT(&tp->out_of_order_queue)) {\r\n\t\ttp->rx_opt.num_sacks = 0;\r\n\t\treturn;\r\n\t}\r\n\r\n\tfor (this_sack = 0; this_sack < num_sacks;) {\r\n\t\t/* Check if the start of the sack is covered by RCV.NXT. */\r\n\t\tif (!before(tp->rcv_nxt, sp->start_seq)) {\r\n\t\t\tint i;\r\n\r\n\t\t\t/* RCV.NXT must cover all the block! */\r\n\t\t\tWARN_ON(before(tp->rcv_nxt, sp->end_seq));\r\n\r\n\t\t\t/* Zap this SACK, by moving forward any other SACKS. */\r\n\t\t\tfor (i = this_sack+1; i < num_sacks; i++)\r\n\t\t\t\ttp->selective_acks[i-1] = tp->selective_acks[i];\r\n\t\t\tnum_sacks--;\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tthis_sack++;\r\n\t\tsp++;\r\n\t}\r\n\ttp->rx_opt.num_sacks = num_sacks;\r\n}", ".cp_data_ready": "void tcp_data_ready(struct sock *sk)\r\n{\r\n\tif (tcp_epollin_ready(sk, sk->sk_rcvlowat) || sock_flag(sk, SOCK_DONE))\r\n\t\tsk->sk_data_ready(sk);\r\n}", ".cp_data_queue_ofo": "static void tcp_data_queue_ofo(struct sock *sk, struct sk_buff *skb)\r\n{\r\n\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\tstruct rb_node **p, *parent;\r\n\tstruct sk_buff *skb1;\r\n\tu32 seq, end_seq;\r\n\tbool fragstolen;\r\n\r\n\ttcp_save_lrcv_flowlabel(sk, skb);\r\n\ttcp_data_ecn_check(sk, skb);\r\n\r\n\tif (unlikely(tcp_try_rmem_schedule(sk, skb, skb->truesize))) {\r\n\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPOFODROP);\r\n\t\tsk->sk_data_ready(sk);\r\n\t\ttcp_drop_reason(sk, skb, SKB_DROP_REASON_PROTO_MEM);\r\n\t\treturn;\r\n\t}\r\n\r\n\ttcp_measure_rcv_mss(sk, skb);\r\n\t/* Disable header prediction. */\r\n\ttp->pred_flags = 0;\r\n\tinet_csk_schedule_ack(sk);\r\n\r\n\ttp->rcv_ooopack += max_t(u16, 1, skb_shinfo(skb)->gso_segs);\r\n\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPOFOQUEUE);\r\n\tseq = TCP_SKB_CB(skb)->seq;\r\n\tend_seq = TCP_SKB_CB(skb)->end_seq;\r\n\r\n\tp = &tp->out_of_order_queue.rb_node;\r\n\tif (RB_EMPTY_ROOT(&tp->out_of_order_queue)) {\r\n\t\t/* Initial out of order segment, build 1 SACK. */\r\n\t\tif (tcp_is_sack(tp)) {\r\n\t\t\ttp->rx_opt.num_sacks = 1;\r\n\t\t\ttp->selective_acks[0].start_seq = seq;\r\n\t\t\ttp->selective_acks[0].end_seq = end_seq;\r\n\t\t}\r\n\t\trb_link_node(&skb->rbnode, NULL, p);\r\n\t\trb_insert_color(&skb->rbnode, &tp->out_of_order_queue);\r\n\t\ttp->ooo_last_skb = skb;\r\n\t\tgoto end;\r\n\t}\r\n\r\n\t/* In the typical case, we are adding an skb to the end of the list.\r\n\t * Use of ooo_last_skb avoids the O(Log(N)) rbtree lookup.\r\n\t */\r\n\tif (tcp_ooo_try_coalesce(sk, tp->ooo_last_skb,\r\n\t\t\t\t skb, &fragstolen)) {\r\ncoalesce_done:\r\n\t\t/* For non sack flows, do not grow window to force DUPACK\r\n\t\t * and trigger fast retransmit.\r\n\t\t */\r\n\t\tif (tcp_is_sack(tp))\r\n\t\t\ttcp_grow_window(sk, skb, true);\r\n\t\tkfree_skb_partial(skb, fragstolen);\r\n\t\tskb = NULL;\r\n\t\tgoto add_sack;\r\n\t}\r\n\t/* Can avoid an rbtree lookup if we are adding skb after ooo_last_skb */\r\n\tif (!before(seq, TCP_SKB_CB(tp->ooo_last_skb)->end_seq)) {\r\n\t\tparent = &tp->ooo_last_skb->rbnode;\r\n\t\tp = &parent->rb_right;\r\n\t\tgoto insert;\r\n\t}\r\n\r\n\t/* Find place to insert this segment. Handle overlaps on the way. */\r\n\tparent = NULL;\r\n\twhile (*p) {\r\n\t\tparent = *p;\r\n\t\tskb1 = rb_to_skb(parent);\r\n\t\tif (before(seq, TCP_SKB_CB(skb1)->seq)) {\r\n\t\t\tp = &parent->rb_left;\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tif (before(seq, TCP_SKB_CB(skb1)->end_seq)) {\r\n\t\t\tif (!after(end_seq, TCP_SKB_CB(skb1)->end_seq)) {\r\n\t\t\t\t/* All the bits are present. Drop. */\r\n\t\t\t\tNET_INC_STATS(sock_net(sk),\r\n\t\t\t\t\t      LINUX_MIB_TCPOFOMERGE);\r\n\t\t\t\ttcp_drop_reason(sk, skb,\r\n\t\t\t\t\t\tSKB_DROP_REASON_TCP_OFOMERGE);\r\n\t\t\t\tskb = NULL;\r\n\t\t\t\ttcp_dsack_set(sk, seq, end_seq);\r\n\t\t\t\tgoto add_sack;\r\n\t\t\t}\r\n\t\t\tif (after(seq, TCP_SKB_CB(skb1)->seq)) {\r\n\t\t\t\t/* Partial overlap. */\r\n\t\t\t\ttcp_dsack_set(sk, seq, TCP_SKB_CB(skb1)->end_seq);\r\n\t\t\t} else {\r\n\t\t\t\t/* skb's seq == skb1's seq and skb covers skb1.\r\n\t\t\t\t * Replace skb1 with skb.\r\n\t\t\t\t */\r\n\t\t\t\trb_replace_node(&skb1->rbnode, &skb->rbnode,\r\n\t\t\t\t\t\t&tp->out_of_order_queue);\r\n\t\t\t\ttcp_dsack_extend(sk,\r\n\t\t\t\t\t\t TCP_SKB_CB(skb1)->seq,\r\n\t\t\t\t\t\t TCP_SKB_CB(skb1)->end_seq);\r\n\t\t\t\tNET_INC_STATS(sock_net(sk),\r\n\t\t\t\t\t      LINUX_MIB_TCPOFOMERGE);\r\n\t\t\t\ttcp_drop_reason(sk, skb1,\r\n\t\t\t\t\t\tSKB_DROP_REASON_TCP_OFOMERGE);\r\n\t\t\t\tgoto merge_right;\r\n\t\t\t}\r\n\t\t} else if (tcp_ooo_try_coalesce(sk, skb1,\r\n\t\t\t\t\t\tskb, &fragstolen)) {\r\n\t\t\tgoto coalesce_done;\r\n\t\t}\r\n\t\tp = &parent->rb_right;\r\n\t}\r\ninsert:\r\n\t/* Insert segment into RB tree. */\r\n\trb_link_node(&skb->rbnode, parent, p);\r\n\trb_insert_color(&skb->rbnode, &tp->out_of_order_queue);\r\n\r\nmerge_right:\r\n\t/* Remove other segments covered by skb. */\r\n\twhile ((skb1 = skb_rb_next(skb)) != NULL) {\r\n\t\tif (!after(end_seq, TCP_SKB_CB(skb1)->seq))\r\n\t\t\tbreak;\r\n\t\tif (before(end_seq, TCP_SKB_CB(skb1)->end_seq)) {\r\n\t\t\ttcp_dsack_extend(sk, TCP_SKB_CB(skb1)->seq,\r\n\t\t\t\t\t end_seq);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\trb_erase(&skb1->rbnode, &tp->out_of_order_queue);\r\n\t\ttcp_dsack_extend(sk, TCP_SKB_CB(skb1)->seq,\r\n\t\t\t\t TCP_SKB_CB(skb1)->end_seq);\r\n\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPOFOMERGE);\r\n\t\ttcp_drop_reason(sk, skb1, SKB_DROP_REASON_TCP_OFOMERGE);\r\n\t}\r\n\t/* If there is no skb after us, we are the last_skb ! */\r\n\tif (!skb1)\r\n\t\ttp->ooo_last_skb = skb;\r\n\r\nadd_sack:\r\n\tif (tcp_is_sack(tp))\r\n\t\ttcp_sack_new_ofo_skb(sk, seq, end_seq);\r\nend:\r\n\tif (skb) {\r\n\t\t/* For non sack flows, do not grow window to force DUPACK\r\n\t\t * and trigger fast retransmit.\r\n\t\t */\r\n\t\tif (tcp_is_sack(tp))\r\n\t\t\ttcp_grow_window(sk, skb, false);\r\n\t\tskb_condense(skb);\r\n\t\tskb_set_owner_r(skb, sk);\r\n\t}\r\n\t/* do not grow rcvbuf for not-yet-accepted or orphaned sockets. */\r\n\tif (sk->sk_socket)\r\n\t\ttcp_rcvbuf_grow(sk);\r\n}", ".cp_rbtree_insert": "void tcp_rbtree_insert(struct rb_root *root, struct sk_buff *skb)\r\n{\r\n\tstruct rb_node **p = &root->rb_node;\r\n\tstruct rb_node *parent = NULL;\r\n\tstruct sk_buff *skb1;\r\n\r\n\twhile (*p) {\r\n\t\tparent = *p;\r\n\t\tskb1 = rb_to_skb(parent);\r\n\t\tif (before(TCP_SKB_CB(skb)->seq, TCP_SKB_CB(skb1)->seq))\r\n\t\t\tp = &parent->rb_left;\r\n\t\telse\r\n\t\t\tp = &parent->rb_right;\r\n\t}\r\n\trb_link_node(&skb->rbnode, parent, p);\r\n\trb_insert_color(&skb->rbnode, root);\r\n}", ".cp_collapse": "static void\r\ntcp_collapse(struct sock *sk, struct sk_buff_head *list, struct rb_root *root,\r\n\t     struct sk_buff *head, struct sk_buff *tail, u32 start, u32 end)\r\n{\r\n\tstruct sk_buff *skb = head, *n;\r\n\tstruct sk_buff_head tmp;\r\n\tbool end_of_skbs;\r\n\r\n\t/* First, check that queue is collapsible and find\r\n\t * the point where collapsing can be useful.\r\n\t */\r\nrestart:\r\n\tfor (end_of_skbs = true; skb != NULL && skb != tail; skb = n) {\r\n\t\tn = tcp_skb_next(skb, list);\r\n\r\n\t\tif (!skb_frags_readable(skb))\r\n\t\t\tgoto skip_this;\r\n\r\n\t\t/* No new bits? It is possible on ofo queue. */\r\n\t\tif (!before(start, TCP_SKB_CB(skb)->end_seq)) {\r\n\t\t\tskb = tcp_collapse_one(sk, skb, list, root);\r\n\t\t\tif (!skb)\r\n\t\t\t\tbreak;\r\n\t\t\tgoto restart;\r\n\t\t}\r\n\r\n\t\t/* The first skb to collapse is:\r\n\t\t * - not SYN/FIN and\r\n\t\t * - bloated or contains data before \"start\" or\r\n\t\t *   overlaps to the next one and mptcp allow collapsing.\r\n\t\t */\r\n\t\tif (!(TCP_SKB_CB(skb)->tcp_flags & (TCPHDR_SYN | TCPHDR_FIN)) &&\r\n\t\t    (tcp_win_from_space(sk, skb->truesize) > skb->len ||\r\n\t\t     before(TCP_SKB_CB(skb)->seq, start))) {\r\n\t\t\tend_of_skbs = false;\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\tif (n && n != tail && skb_frags_readable(n) &&\r\n\t\t    tcp_skb_can_collapse_rx(skb, n) &&\r\n\t\t    TCP_SKB_CB(skb)->end_seq != TCP_SKB_CB(n)->seq) {\r\n\t\t\tend_of_skbs = false;\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\nskip_this:\r\n\t\t/* Decided to skip this, advance start seq. */\r\n\t\tstart = TCP_SKB_CB(skb)->end_seq;\r\n\t}\r\n\tif (end_of_skbs ||\r\n\t    (TCP_SKB_CB(skb)->tcp_flags & (TCPHDR_SYN | TCPHDR_FIN)) ||\r\n\t    !skb_frags_readable(skb))\r\n\t\treturn;\r\n\r\n\t__skb_queue_head_init(&tmp);\r\n\r\n\twhile (before(start, end)) {\r\n\t\tint copy = min_t(int, SKB_MAX_ORDER(0, 0), end - start);\r\n\t\tstruct sk_buff *nskb;\r\n\r\n\t\tnskb = alloc_skb(copy, GFP_ATOMIC);\r\n\t\tif (!nskb)\r\n\t\t\tbreak;\r\n\r\n\t\tmemcpy(nskb->cb, skb->cb, sizeof(skb->cb));\r\n\t\tskb_copy_decrypted(nskb, skb);\r\n\t\tTCP_SKB_CB(nskb)->seq = TCP_SKB_CB(nskb)->end_seq = start;\r\n\t\tif (list)\r\n\t\t\t__skb_queue_before(list, skb, nskb);\r\n\t\telse\r\n\t\t\t__skb_queue_tail(&tmp, nskb); /* defer rbtree insertion */\r\n\t\tskb_set_owner_r(nskb, sk);\r\n\t\tmptcp_skb_ext_move(nskb, skb);\r\n\r\n\t\t/* Copy data, releasing collapsed skbs. */\r\n\t\twhile (copy > 0) {\r\n\t\t\tint offset = start - TCP_SKB_CB(skb)->seq;\r\n\t\t\tint size = TCP_SKB_CB(skb)->end_seq - start;\r\n\r\n\t\t\tBUG_ON(offset < 0);\r\n\t\t\tif (size > 0) {\r\n\t\t\t\tsize = min(copy, size);\r\n\t\t\t\tif (skb_copy_bits(skb, offset, skb_put(nskb, size), size))\r\n\t\t\t\t\tBUG();\r\n\t\t\t\tTCP_SKB_CB(nskb)->end_seq += size;\r\n\t\t\t\tcopy -= size;\r\n\t\t\t\tstart += size;\r\n\t\t\t}\r\n\t\t\tif (!before(start, TCP_SKB_CB(skb)->end_seq)) {\r\n\t\t\t\tskb = tcp_collapse_one(sk, skb, list, root);\r\n\t\t\t\tif (!skb ||\r\n\t\t\t\t    skb == tail ||\r\n\t\t\t\t    !tcp_skb_can_collapse_rx(nskb, skb) ||\r\n\t\t\t\t    (TCP_SKB_CB(skb)->tcp_flags & (TCPHDR_SYN | TCPHDR_FIN)) ||\r\n\t\t\t\t    !skb_frags_readable(skb))\r\n\t\t\t\t\tgoto end;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\nend:\r\n\tskb_queue_walk_safe(&tmp, skb, n)\r\n\t\ttcp_rbtree_insert(root, skb);\r\n}", ".cp_clamp_window": "static void tcp_clamp_window(struct sock *sk)\r\n{\r\n\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\r\n\tstruct net *net = sock_net(sk);\r\n\tint rmem2;\r\n\r\n\ticsk->icsk_ack.quick = 0;\r\n\trmem2 = READ_ONCE(net->ipv4.sysctl_tcp_rmem[2]);\r\n\r\n\tif (sk->sk_rcvbuf < rmem2 &&\r\n\t    !(sk->sk_userlocks & SOCK_RCVBUF_LOCK) &&\r\n\t    !tcp_under_memory_pressure(sk) &&\r\n\t    sk_memory_allocated(sk) < sk_prot_mem_limits(sk, 0)) {\r\n\t\tWRITE_ONCE(sk->sk_rcvbuf,\r\n\t\t\t   min(atomic_read(&sk->sk_rmem_alloc), rmem2));\r\n\t}\r\n\tif (atomic_read(&sk->sk_rmem_alloc) > sk->sk_rcvbuf)\r\n\t\ttp->rcv_ssthresh = min(tp->window_clamp, 2U * tp->advmss);\r\n}", ".cp_collapse_ofo_queue": "static void tcp_collapse_ofo_queue(struct sock *sk)\r\n{\r\n\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\tu32 range_truesize, sum_tiny = 0;\r\n\tstruct sk_buff *skb, *head;\r\n\tu32 start, end;\r\n\r\n\tskb = skb_rb_first(&tp->out_of_order_queue);\r\nnew_range:\r\n\tif (!skb) {\r\n\t\ttp->ooo_last_skb = skb_rb_last(&tp->out_of_order_queue);\r\n\t\treturn;\r\n\t}\r\n\tstart = TCP_SKB_CB(skb)->seq;\r\n\tend = TCP_SKB_CB(skb)->end_seq;\r\n\trange_truesize = skb->truesize;\r\n\r\n\tfor (head = skb;;) {\r\n\t\tskb = skb_rb_next(skb);\r\n\r\n\t\t/* Range is terminated when we see a gap or when\r\n\t\t * we are at the queue end.\r\n\t\t */\r\n\t\tif (!skb ||\r\n\t\t    after(TCP_SKB_CB(skb)->seq, end) ||\r\n\t\t    before(TCP_SKB_CB(skb)->end_seq, start)) {\r\n\t\t\t/* Do not attempt collapsing tiny skbs */\r\n\t\t\tif (range_truesize != head->truesize ||\r\n\t\t\t    end - start >= SKB_WITH_OVERHEAD(PAGE_SIZE)) {\r\n\t\t\t\ttcp_collapse(sk, NULL, &tp->out_of_order_queue,\r\n\t\t\t\t\t     head, skb, start, end);\r\n\t\t\t} else {\r\n\t\t\t\tsum_tiny += range_truesize;\r\n\t\t\t\tif (sum_tiny > sk->sk_rcvbuf >> 3)\r\n\t\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tgoto new_range;\r\n\t\t}\r\n\r\n\t\trange_truesize += skb->truesize;\r\n\t\tif (unlikely(before(TCP_SKB_CB(skb)->seq, start)))\r\n\t\t\tstart = TCP_SKB_CB(skb)->seq;\r\n\t\tif (after(TCP_SKB_CB(skb)->end_seq, end))\r\n\t\t\tend = TCP_SKB_CB(skb)->end_seq;\r\n\t}\r\n}", ".cp_should_expand_sndbuf": "static bool tcp_should_expand_sndbuf(struct sock *sk)\r\n{\r\n\tconst struct tcp_sock *tp = tcp_sk(sk);\r\n\r\n\t/* If the user specified a specific send buffer setting, do\r\n\t * not modify it.\r\n\t */\r\n\tif (sk->sk_userlocks & SOCK_SNDBUF_LOCK)\r\n\t\treturn false;\r\n\r\n\t/* If we are under global TCP memory pressure, do not expand.  */\r\n\tif (tcp_under_memory_pressure(sk)) {\r\n\t\tint unused_mem = sk_unused_reserved_mem(sk);\r\n\r\n\t\t/* Adjust sndbuf according to reserved mem. But make sure\r\n\t\t * it never goes below SOCK_MIN_SNDBUF.\r\n\t\t * See sk_stream_moderate_sndbuf() for more details.\r\n\t\t */\r\n\t\tif (unused_mem > SOCK_MIN_SNDBUF)\r\n\t\t\tWRITE_ONCE(sk->sk_sndbuf, unused_mem);\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\t/* If we are under soft global TCP memory pressure, do not expand.  */\r\n\tif (sk_memory_allocated(sk) >= sk_prot_mem_limits(sk, 0))\r\n\t\treturn false;\r\n\r\n\t/* If we filled the congestion window, do not expand.  */\r\n\tif (tcp_packets_in_flight(tp) >= tcp_snd_cwnd(tp))\r\n\t\treturn false;\r\n\r\n\treturn true;\r\n}", ".cp_new_space": "static void tcp_new_space(struct sock *sk)\r\n{\r\n\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\r\n\tif (tcp_should_expand_sndbuf(sk)) {\r\n\t\ttcp_sndbuf_expand(sk);\r\n\t\ttp->snd_cwnd_stamp = tcp_jiffies32;\r\n\t}\r\n\r\n\tINDIRECT_CALL_1(sk->sk_write_space, sk_stream_write_space, sk);\r\n}", ".cp_check_space": "void tcp_check_space(struct sock *sk)\r\n{\r\n\t/* pairs with tcp_poll() */\r\n\tsmp_mb();\r\n\tif (sk->sk_socket &&\r\n\t    test_bit(SOCK_NOSPACE, &sk->sk_socket->flags)) {\r\n\t\ttcp_new_space(sk);\r\n\t\tif (!test_bit(SOCK_NOSPACE, &sk->sk_socket->flags))\r\n\t\t\ttcp_chrono_stop(sk, TCP_CHRONO_SNDBUF_LIMITED);\r\n\t}\r\n}", ".cp_check_urg": "static void tcp_check_urg(struct sock *sk, const struct tcphdr *th)\r\n{\r\n\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\tu32 ptr = ntohs(th->urg_ptr);\r\n\r\n\tif (ptr && !READ_ONCE(sock_net(sk)->ipv4.sysctl_tcp_stdurg))\r\n\t\tptr--;\r\n\tptr += ntohl(th->seq);\r\n\r\n\t/* Ignore urgent data that we've already seen and read. */\r\n\tif (after(tp->copied_seq, ptr))\r\n\t\treturn;\r\n\r\n\t/* Do not replay urg ptr.\r\n\t *\r\n\t * NOTE: interesting situation not covered by specs.\r\n\t * Misbehaving sender may send urg ptr, pointing to segment,\r\n\t * which we already have in ofo queue. We are not able to fetch\r\n\t * such data and will stay in TCP_URG_NOTYET until will be eaten\r\n\t * by recvmsg(). Seems, we are not obliged to handle such wicked\r\n\t * situations. But it is worth to think about possibility of some\r\n\t * DoSes using some hypothetical application level deadlock.\r\n\t */\r\n\tif (before(ptr, tp->rcv_nxt))\r\n\t\treturn;\r\n\r\n\t/* Do we already have a newer (or duplicate) urgent pointer? */\r\n\tif (tp->urg_data && !after(ptr, tp->urg_seq))\r\n\t\treturn;\r\n\r\n\t/* Tell the world about our new urgent pointer. */\r\n\tsk_send_sigurg(sk);\r\n\r\n\t/* We may be adding urgent data when the last byte read was\r\n\t * urgent. To do this requires some care. We cannot just ignore\r\n\t * tp->copied_seq since we would read the last urgent byte again\r\n\t * as data, nor can we alter copied_seq until this data arrives\r\n\t * or we break the semantics of SIOCATMARK (and thus sockatmark())\r\n\t *\r\n\t * NOTE. Double Dutch. Rendering to plain English: author of comment\r\n\t * above did something sort of \tsend(\"A\", MSG_OOB); send(\"B\", MSG_OOB);\r\n\t * and expect that both A and B disappear from stream. This is _wrong_.\r\n\t * Though this happens in BSD with high probability, this is occasional.\r\n\t * Any application relying on this is buggy. Note also, that fix \"works\"\r\n\t * only in this artificial test. Insert some normal data between A and B and we will\r\n\t * decline of BSD again. Verdict: it is better to remove to trap\r\n\t * buggy users.\r\n\t */\r\n\tif (tp->urg_seq == tp->copied_seq && tp->urg_data &&\r\n\t    !sock_flag(sk, SOCK_URGINLINE) && tp->copied_seq != tp->rcv_nxt) {\r\n\t\tstruct sk_buff *skb = skb_peek(&sk->sk_receive_queue);\r\n\t\ttp->copied_seq++;\r\n\t\tif (skb && !before(tp->copied_seq, TCP_SKB_CB(skb)->end_seq)) {\r\n\t\t\t__skb_unlink(skb, &sk->sk_receive_queue);\r\n\t\t\t__kfree_skb(skb);\r\n\t\t}\r\n\t}\r\n\r\n\tWRITE_ONCE(tp->urg_data, TCP_URG_NOTYET);\r\n\tWRITE_ONCE(tp->urg_seq, ptr);\r\n\r\n\t/* Disable header prediction. */\r\n\ttp->pred_flags = 0;\r\n}", ".cp_fast_parse_options": "static bool tcp_fast_parse_options(const struct net *net,\r\n\t\t\t\t   const struct sk_buff *skb,\r\n\t\t\t\t   const struct tcphdr *th, struct tcp_sock *tp)\r\n{\r\n\t/* In the spirit of fast parsing, compare doff directly to constant\r\n\t * values.  Because equality is used, short doff can be ignored here.\r\n\t */\r\n\tif (th->doff == (sizeof(*th) / 4)) {\r\n\t\ttp->rx_opt.saw_tstamp = 0;\r\n\t\ttp->rx_opt.accecn = 0;\r\n\t\treturn false;\r\n\t} else if (tp->rx_opt.tstamp_ok &&\r\n\t\t   th->doff == ((sizeof(*th) + TCPOLEN_TSTAMP_ALIGNED) / 4)) {\r\n\t\tif (tcp_parse_aligned_timestamp(tp, th)) {\r\n\t\t\ttp->rx_opt.accecn = 0;\r\n\t\t\treturn true;\r\n\t\t}\r\n\t}\r\n\r\n\ttcp_parse_options(net, skb, &tp->rx_opt, 1, NULL);\r\n\tif (tp->rx_opt.saw_tstamp && tp->rx_opt.rcv_tsecr)\r\n\t\ttp->rx_opt.rcv_tsecr -= tp->tsoffset;\r\n\r\n\treturn true;\r\n}", ".cp_disordered_ack_check": "static enum skb_drop_reason tcp_disordered_ack_check(const struct sock *sk,\r\n\t\t\t\t\t\t     const struct sk_buff *skb)\r\n{\r\n\tconst struct tcp_sock *tp = tcp_sk(sk);\r\n\tconst struct tcphdr *th = tcp_hdr(skb);\r\n\tSKB_DR_INIT(reason, TCP_RFC7323_PAWS);\r\n\tu32 ack = TCP_SKB_CB(skb)->ack_seq;\r\n\tu32 seq = TCP_SKB_CB(skb)->seq;\r\n\r\n\t/* 1. Is this not a pure ACK ? */\r\n\tif (!th->ack || seq != TCP_SKB_CB(skb)->end_seq)\r\n\t\treturn reason;\r\n\r\n\t/* 2. Is its sequence not the expected one ? */\r\n\tif (seq != tp->rcv_nxt)\r\n\t\treturn before(seq, tp->rcv_nxt) ?\r\n\t\t\tSKB_DROP_REASON_TCP_RFC7323_PAWS_ACK :\r\n\t\t\treason;\r\n\r\n\t/* 3. Is this not a duplicate ACK ? */\r\n\tif (ack != tp->snd_una)\r\n\t\treturn reason;\r\n\r\n\t/* 4. Is this updating the window ? */\r\n\tif (tcp_may_update_window(tp, ack, seq, ntohs(th->window) <<\r\n\t\t\t\t\t\ttp->rx_opt.snd_wscale))\r\n\t\treturn reason;\r\n\r\n\t/* 5. Is this not in the replay window ? */\r\n\tif ((s32)(tp->rx_opt.ts_recent - tp->rx_opt.rcv_tsval) >\r\n\t    tcp_tsval_replay(sk))\r\n\t\treturn reason;\r\n\r\n\treturn 0;\r\n}", ".cp_oow_rate_limited": "bool tcp_oow_rate_limited(struct net *net, const struct sk_buff *skb,\r\n\t\t\t  int mib_idx, u32 *last_oow_ack_time)\r\n{\r\n\t/* Data packets without SYNs are not likely part of an ACK loop. */\r\n\tif ((TCP_SKB_CB(skb)->seq != TCP_SKB_CB(skb)->end_seq) &&\r\n\t    !tcp_hdr(skb)->syn)\r\n\t\treturn false;\r\n\r\n\treturn __tcp_oow_rate_limited(net, mib_idx, last_oow_ack_time);\r\n}", ".cp_send_dupack": "static void tcp_send_dupack(struct sock *sk, const struct sk_buff *skb)\r\n{\r\n\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\r\n\tif (TCP_SKB_CB(skb)->end_seq != TCP_SKB_CB(skb)->seq &&\r\n\t    before(TCP_SKB_CB(skb)->seq, tp->rcv_nxt)) {\r\n\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_DELAYEDACKLOST);\r\n\t\ttcp_enter_quickack_mode(sk, TCP_MAX_QUICKACKS);\r\n\r\n\t\tif (tcp_is_sack(tp) && READ_ONCE(sock_net(sk)->ipv4.sysctl_tcp_dsack)) {\r\n\t\t\tu32 end_seq = TCP_SKB_CB(skb)->end_seq;\r\n\r\n\t\t\ttcp_rcv_spurious_retrans(sk, skb);\r\n\t\t\tif (after(TCP_SKB_CB(skb)->end_seq, tp->rcv_nxt))\r\n\t\t\t\tend_seq = tp->rcv_nxt;\r\n\t\t\ttcp_dsack_set(sk, TCP_SKB_CB(skb)->seq, end_seq);\r\n\t\t}\r\n\t}\r\n\r\n\ttcp_send_ack(sk);\r\n}", ".cp_sequence": "static enum skb_drop_reason tcp_sequence(const struct sock *sk,\r\n\t\t\t\t\t u32 seq, u32 end_seq)\r\n{\r\n\tconst struct tcp_sock *tp = tcp_sk(sk);\r\n\r\n\tif (before(end_seq, tp->rcv_wup))\r\n\t\treturn SKB_DROP_REASON_TCP_OLD_SEQUENCE;\r\n\r\n\tif (after(end_seq, tp->rcv_nxt + tcp_receive_window(tp))) {\r\n\t\tif (after(seq, tp->rcv_nxt + tcp_receive_window(tp)))\r\n\t\t\treturn SKB_DROP_REASON_TCP_INVALID_SEQUENCE;\r\n\r\n\t\t/* Only accept this packet if receive queue is empty. */\r\n\t\tif (skb_queue_len(&sk->sk_receive_queue))\r\n\t\t\treturn SKB_DROP_REASON_TCP_INVALID_END_SEQUENCE;\r\n\t}\r\n\r\n\treturn SKB_NOT_DROPPED_YET;\r\n}", ".cp_reset_check": "static bool tcp_reset_check(const struct sock *sk, const struct sk_buff *skb)\r\n{\r\n\tconst struct tcp_sock *tp = tcp_sk(sk);\r\n\r\n\treturn unlikely(TCP_SKB_CB(skb)->seq == (tp->rcv_nxt - 1) &&\r\n\t\t\t(1 << sk->sk_state) & (TCPF_CLOSE_WAIT | TCPF_LAST_ACK |\r\n\t\t\t\t\t       TCPF_CLOSING));\r\n}", ".pf_skops_parse_hdr": "static void bpf_skops_parse_hdr(struct sock *sk, struct sk_buff *skb)\r\n{\r\n\tbool unknown_opt = tcp_sk(sk)->rx_opt.saw_unknown &&\r\n\t\tBPF_SOCK_OPS_TEST_FLAG(tcp_sk(sk),\r\n\t\t\t\t       BPF_SOCK_OPS_PARSE_UNKNOWN_HDR_OPT_CB_FLAG);\r\n\tbool parse_all_opt = BPF_SOCK_OPS_TEST_FLAG(tcp_sk(sk),\r\n\t\t\t\t\t\t    BPF_SOCK_OPS_PARSE_ALL_HDR_OPT_CB_FLAG);\r\n\tstruct bpf_sock_ops_kern sock_ops;\r\n\r\n\tif (likely(!unknown_opt && !parse_all_opt))\r\n\t\treturn;\r\n\r\n\t/* The skb will be handled in the\r\n\t * bpf_skops_established() or\r\n\t * bpf_skops_write_hdr_opt().\r\n\t */\r\n\tswitch (sk->sk_state) {\r\n\tcase TCP_SYN_RECV:\r\n\tcase TCP_SYN_SENT:\r\n\tcase TCP_LISTEN:\r\n\t\treturn;\r\n\t}\r\n\r\n\tsock_owned_by_me(sk);\r\n\r\n\tmemset(&sock_ops, 0, offsetof(struct bpf_sock_ops_kern, temp));\r\n\tsock_ops.op = BPF_SOCK_OPS_PARSE_HDR_OPT_CB;\r\n\tsock_ops.is_fullsock = 1;\r\n\tsock_ops.is_locked_tcp_sock = 1;\r\n\tsock_ops.sk = sk;\r\n\tbpf_skops_init_skb(&sock_ops, skb, tcp_hdrlen(skb));\r\n\r\n\tBPF_CGROUP_RUN_PROG_SOCK_OPS(&sock_ops);\r\n}", ".cp_reset": "void tcp_reset(struct sock *sk, struct sk_buff *skb)\r\n{\r\n\tint err;\r\n\r\n\ttrace_tcp_receive_reset(sk);\r\n\r\n\t/* mptcp can't tell us to ignore reset pkts,\r\n\t * so just ignore the return value of mptcp_incoming_options().\r\n\t */\r\n\tif (sk_is_mptcp(sk))\r\n\t\tmptcp_incoming_options(sk, skb);\r\n\r\n\t/* We want the right error as BSD sees it (and indeed as we do). */\r\n\tswitch (sk->sk_state) {\r\n\tcase TCP_SYN_SENT:\r\n\t\terr = ECONNREFUSED;\r\n\t\tbreak;\r\n\tcase TCP_CLOSE_WAIT:\r\n\t\terr = EPIPE;\r\n\t\tbreak;\r\n\tcase TCP_CLOSE:\r\n\t\treturn;\r\n\tdefault:\r\n\t\terr = ECONNRESET;\r\n\t}\r\n\ttcp_done_with_error(sk, err);\r\n}", ".cp_ack": "static int tcp_ack(struct sock *sk, const struct sk_buff *skb, int flag)\r\n{\r\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\r\n\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\tstruct tcp_sacktag_state sack_state;\r\n\tstruct rate_sample rs = { .prior_delivered = 0 };\r\n\tu32 prior_snd_una = tp->snd_una;\r\n\tbool is_sack_reneg = tp->is_sack_reneg;\r\n\tu32 ack_seq = TCP_SKB_CB(skb)->seq;\r\n\tu32 ack = TCP_SKB_CB(skb)->ack_seq;\r\n\tint num_dupack = 0;\r\n\tint prior_packets = tp->packets_out;\r\n\tu32 delivered = tp->delivered;\r\n\tu32 lost = tp->lost;\r\n\tint rexmit = REXMIT_NONE; /* Flag to (re)transmit to recover losses */\r\n\tu32 ecn_count = 0;\t  /* Did we receive ECE/an AccECN ACE update? */\r\n\tu32 prior_fack;\r\n\r\n\tsack_state.first_sackt = 0;\r\n\tsack_state.rate = &rs;\r\n\tsack_state.sack_delivered = 0;\r\n\tsack_state.delivered_bytes = 0;\r\n\r\n\t/* We very likely will need to access rtx queue. */\r\n\tprefetch(sk->tcp_rtx_queue.rb_node);\r\n\r\n\t/* If the ack is older than previous acks\r\n\t * then we can probably ignore it.\r\n\t */\r\n\tif (before(ack, prior_snd_una)) {\r\n\t\tu32 max_window;\r\n\r\n\t\t/* do not accept ACK for bytes we never sent. */\r\n\t\tmax_window = min_t(u64, tp->max_window, tp->bytes_acked);\r\n\t\t/* RFC 5961 5.2 [Blind Data Injection Attack].[Mitigation] */\r\n\t\tif (before(ack, prior_snd_una - max_window)) {\r\n\t\t\tif (!(flag & FLAG_NO_CHALLENGE_ACK))\r\n\t\t\t\ttcp_send_challenge_ack(sk, false);\r\n\t\t\treturn -SKB_DROP_REASON_TCP_TOO_OLD_ACK;\r\n\t\t}\r\n\t\tgoto old_ack;\r\n\t}\r\n\r\n\t/* If the ack includes data we haven't sent yet, discard\r\n\t * this segment (RFC793 Section 3.9).\r\n\t */\r\n\tif (after(ack, tp->snd_nxt))\r\n\t\treturn -SKB_DROP_REASON_TCP_ACK_UNSENT_DATA;\r\n\r\n\tif (after(ack, prior_snd_una)) {\r\n\t\tflag |= FLAG_SND_UNA_ADVANCED;\r\n\t\tWRITE_ONCE(icsk->icsk_retransmits, 0);\r\n\r\n#if IS_ENABLED(CONFIG_TLS_DEVICE)\r\n\t\tif (static_branch_unlikely(&clean_acked_data_enabled.key))\r\n\t\t\tif (tp->tcp_clean_acked)\r\n\t\t\t\ttp->tcp_clean_acked(sk, ack);\r\n#endif\r\n\t}\r\n\r\n\tprior_fack = tcp_is_sack(tp) ? tcp_highest_sack_seq(tp) : tp->snd_una;\r\n\trs.prior_in_flight = tcp_packets_in_flight(tp);\r\n\r\n\t/* ts_recent update must be made after we are sure that the packet\r\n\t * is in window.\r\n\t */\r\n\tif (flag & FLAG_UPDATE_TS_RECENT)\r\n\t\tflag |= tcp_replace_ts_recent(tp, TCP_SKB_CB(skb)->seq);\r\n\r\n\tif ((flag & (FLAG_SLOWPATH | FLAG_SND_UNA_ADVANCED)) ==\r\n\t    FLAG_SND_UNA_ADVANCED) {\r\n\t\t/* Window is constant, pure forward advance.\r\n\t\t * No more checks are required.\r\n\t\t * Note, we use the fact that SND.UNA>=SND.WL2.\r\n\t\t */\r\n\t\ttcp_update_wl(tp, ack_seq);\r\n\t\ttcp_snd_una_update(tp, ack);\r\n\t\tflag |= FLAG_WIN_UPDATE;\r\n\r\n\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPHPACKS);\r\n\t} else {\r\n\t\tif (ack_seq != TCP_SKB_CB(skb)->end_seq)\r\n\t\t\tflag |= FLAG_DATA;\r\n\t\telse\r\n\t\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPPUREACKS);\r\n\r\n\t\tflag |= tcp_ack_update_window(sk, skb, ack, ack_seq);\r\n\r\n\t\tif (TCP_SKB_CB(skb)->sacked)\r\n\t\t\tflag |= tcp_sacktag_write_queue(sk, skb, prior_snd_una,\r\n\t\t\t\t\t\t\t&sack_state);\r\n\r\n\t\tif (tcp_ecn_rcv_ecn_echo(tp, tcp_hdr(skb)))\r\n\t\t\tflag |= FLAG_ECE;\r\n\r\n\t\tif (sack_state.sack_delivered)\r\n\t\t\ttcp_count_delivered(tp, sack_state.sack_delivered,\r\n\t\t\t\t\t    flag & FLAG_ECE);\r\n\t}\r\n\r\n\t/* This is a deviation from RFC3168 since it states that:\r\n\t * \"When the TCP data sender is ready to set the CWR bit after reducing\r\n\t * the congestion window, it SHOULD set the CWR bit only on the first\r\n\t * new data packet that it transmits.\"\r\n\t * We accept CWR on pure ACKs to be more robust\r\n\t * with widely-deployed TCP implementations that do this.\r\n\t */\r\n\ttcp_ecn_accept_cwr(sk, skb);\r\n\r\n\t/* We passed data and got it acked, remove any soft error\r\n\t * log. Something worked...\r\n\t */\r\n\tif (READ_ONCE(sk->sk_err_soft))\r\n\t\tWRITE_ONCE(sk->sk_err_soft, 0);\r\n\tWRITE_ONCE(icsk->icsk_probes_out, 0);\r\n\ttp->rcv_tstamp = tcp_jiffies32;\r\n\tif (!prior_packets)\r\n\t\tgoto no_queue;\r\n\r\n\t/* See if we can take anything off of the retransmit queue. */\r\n\tflag |= tcp_clean_rtx_queue(sk, skb, prior_fack, prior_snd_una,\r\n\t\t\t\t    &sack_state, flag & FLAG_ECE);\r\n\r\n\ttcp_rack_update_reo_wnd(sk, &rs);\r\n\r\n\tif (tcp_ecn_mode_accecn(tp))\r\n\t\tecn_count = tcp_accecn_process(sk, skb,\r\n\t\t\t\t\t       tp->delivered - delivered,\r\n\t\t\t\t\t       sack_state.delivered_bytes,\r\n\t\t\t\t\t       &flag);\r\n\r\n\ttcp_in_ack_event(sk, flag);\r\n\r\n\tif (tp->tlp_high_seq)\r\n\t\ttcp_process_tlp_ack(sk, ack, flag);\r\n\r\n\tif (tcp_ack_is_dubious(sk, flag)) {\r\n\t\tif (!(flag & (FLAG_SND_UNA_ADVANCED |\r\n\t\t\t      FLAG_NOT_DUP | FLAG_DSACKING_ACK))) {\r\n\t\t\tnum_dupack = 1;\r\n\t\t\t/* Consider if pure acks were aggregated in tcp_add_backlog() */\r\n\t\t\tif (!(flag & FLAG_DATA))\r\n\t\t\t\tnum_dupack = max_t(u16, 1, skb_shinfo(skb)->gso_segs);\r\n\t\t}\r\n\t\ttcp_fastretrans_alert(sk, prior_snd_una, num_dupack, &flag,\r\n\t\t\t\t      &rexmit);\r\n\t}\r\n\r\n\t/* If needed, reset TLP/RTO timer when RACK doesn't set. */\r\n\tif (flag & FLAG_SET_XMIT_TIMER)\r\n\t\ttcp_set_xmit_timer(sk);\r\n\r\n\tif ((flag & FLAG_FORWARD_PROGRESS) || !(flag & FLAG_NOT_DUP))\r\n\t\tsk_dst_confirm(sk);\r\n\r\n\tdelivered = tcp_newly_delivered(sk, delivered, ecn_count, flag);\r\n\r\n\tlost = tp->lost - lost;\t\t\t/* freshly marked lost */\r\n\trs.is_ack_delayed = !!(flag & FLAG_ACK_MAYBE_DELAYED);\r\n\ttcp_rate_gen(sk, delivered, lost, is_sack_reneg, sack_state.rate);\r\n\ttcp_cong_control(sk, ack, delivered, flag, sack_state.rate);\r\n\ttcp_xmit_recovery(sk, rexmit);\r\n\treturn 1;\r\n\r\nno_queue:\r\n\tif (tcp_ecn_mode_accecn(tp))\r\n\t\tecn_count = tcp_accecn_process(sk, skb,\r\n\t\t\t\t\t       tp->delivered - delivered,\r\n\t\t\t\t\t       sack_state.delivered_bytes,\r\n\t\t\t\t\t       &flag);\r\n\ttcp_in_ack_event(sk, flag);\r\n\t/* If data was DSACKed, see if we can undo a cwnd reduction. */\r\n\tif (flag & FLAG_DSACKING_ACK) {\r\n\t\ttcp_fastretrans_alert(sk, prior_snd_una, num_dupack, &flag,\r\n\t\t\t\t      &rexmit);\r\n\t\ttcp_newly_delivered(sk, delivered, ecn_count, flag);\r\n\t}\r\n\t/* If this ack opens up a zero window, clear backoff.  It was\r\n\t * being used to time the probes, and is probably far higher than\r\n\t * it needs to be for normal retransmission.\r\n\t */\r\n\ttcp_ack_probe(sk);\r\n\r\n\tif (tp->tlp_high_seq)\r\n\t\ttcp_process_tlp_ack(sk, ack, flag);\r\n\treturn 1;\r\n\r\nold_ack:\r\n\t/* If data was SACKed, tag it and see if we should send more data.\r\n\t * If data was DSACKed, see if we can undo a cwnd reduction.\r\n\t */\r\n\tif (TCP_SKB_CB(skb)->sacked) {\r\n\t\tflag |= tcp_sacktag_write_queue(sk, skb, prior_snd_una,\r\n\t\t\t\t\t\t&sack_state);\r\n\t\ttcp_fastretrans_alert(sk, prior_snd_una, num_dupack, &flag,\r\n\t\t\t\t      &rexmit);\r\n\t\ttcp_newly_delivered(sk, delivered, ecn_count, flag);\r\n\t\ttcp_xmit_recovery(sk, rexmit);\r\n\t}\r\n\r\n\treturn 0;\r\n}", ".cp_data_snd_check": "static inline void tcp_data_snd_check(struct sock *sk)\r\n{\r\n\ttcp_push_pending_frames(sk);\r\n\ttcp_check_space(sk);\r\n}", ".cp_rcv_rtt_measure_ts": "static inline void tcp_rcv_rtt_measure_ts(struct sock *sk,\r\n\t\t\t\t\t  const struct sk_buff *skb)\r\n{\r\n\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\r\n\tif (tp->rx_opt.rcv_tsecr == tp->rcv_rtt_last_tsecr)\r\n\t\treturn;\r\n\ttp->rcv_rtt_last_tsecr = tp->rx_opt.rcv_tsecr;\r\n\r\n\tif (TCP_SKB_CB(skb)->end_seq -\r\n\t    TCP_SKB_CB(skb)->seq >= inet_csk(sk)->icsk_ack.rcv_mss) {\r\n\t\ts32 delta = tcp_rtt_tsopt_us(tp, 0);\r\n\r\n\t\tif (delta > 0)\r\n\t\t\ttcp_rcv_rtt_update(tp, delta, 0);\r\n\t}\r\n}", ".cp_validate_incoming": "static bool tcp_validate_incoming(struct sock *sk, struct sk_buff *skb,\r\n\t\t\t\t  const struct tcphdr *th, int syn_inerr)\r\n{\r\n\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\tbool accecn_reflector = false;\r\n\tSKB_DR(reason);\r\n\r\n\t/* RFC1323: H1. Apply PAWS check first. */\r\n\tif (!tcp_fast_parse_options(sock_net(sk), skb, th, tp) ||\r\n\t    !tp->rx_opt.saw_tstamp ||\r\n\t    tcp_paws_check(&tp->rx_opt, TCP_PAWS_WINDOW))\r\n\t\tgoto step1;\r\n\r\n\treason = tcp_disordered_ack_check(sk, skb);\r\n\tif (!reason)\r\n\t\tgoto step1;\r\n\t/* Reset is accepted even if it did not pass PAWS. */\r\n\tif (th->rst)\r\n\t\tgoto step1;\r\n\tif (unlikely(th->syn))\r\n\t\tgoto syn_challenge;\r\n\r\n\t/* Old ACK are common, increment PAWS_OLD_ACK\r\n\t * and do not send a dupack.\r\n\t */\r\n\tif (reason == SKB_DROP_REASON_TCP_RFC7323_PAWS_ACK) {\r\n\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_PAWS_OLD_ACK);\r\n\t\tgoto discard;\r\n\t}\r\n\tNET_INC_STATS(sock_net(sk), LINUX_MIB_PAWSESTABREJECTED);\r\n\tif (!tcp_oow_rate_limited(sock_net(sk), skb,\r\n\t\t\t\t  LINUX_MIB_TCPACKSKIPPEDPAWS,\r\n\t\t\t\t  &tp->last_oow_ack_time))\r\n\t\ttcp_send_dupack(sk, skb);\r\n\tgoto discard;\r\n\r\nstep1:\r\n\t/* Step 1: check sequence number */\r\n\treason = tcp_sequence(sk, TCP_SKB_CB(skb)->seq, TCP_SKB_CB(skb)->end_seq);\r\n\tif (reason) {\r\n\t\t/* RFC793, page 37: \"In all states except SYN-SENT, all reset\r\n\t\t * (RST) segments are validated by checking their SEQ-fields.\"\r\n\t\t * And page 69: \"If an incoming segment is not acceptable,\r\n\t\t * an acknowledgment should be sent in reply (unless the RST\r\n\t\t * bit is set, if so drop the segment and return)\".\r\n\t\t */\r\n\t\tif (!th->rst) {\r\n\t\t\tif (th->syn)\r\n\t\t\t\tgoto syn_challenge;\r\n\r\n\t\t\tif (reason == SKB_DROP_REASON_TCP_INVALID_SEQUENCE ||\r\n\t\t\t    reason == SKB_DROP_REASON_TCP_INVALID_END_SEQUENCE)\r\n\t\t\t\tNET_INC_STATS(sock_net(sk),\r\n\t\t\t\t\t      LINUX_MIB_BEYOND_WINDOW);\r\n\t\t\tif (!tcp_oow_rate_limited(sock_net(sk), skb,\r\n\t\t\t\t\t\t  LINUX_MIB_TCPACKSKIPPEDSEQ,\r\n\t\t\t\t\t\t  &tp->last_oow_ack_time))\r\n\t\t\t\ttcp_send_dupack(sk, skb);\r\n\t\t} else if (tcp_reset_check(sk, skb)) {\r\n\t\t\tgoto reset;\r\n\t\t}\r\n\t\tgoto discard;\r\n\t}\r\n\r\n\t/* Step 2: check RST bit */\r\n\tif (th->rst) {\r\n\t\t/* RFC 5961 3.2 (extend to match against (RCV.NXT - 1) after a\r\n\t\t * FIN and SACK too if available):\r\n\t\t * If seq num matches RCV.NXT or (RCV.NXT - 1) after a FIN, or\r\n\t\t * the right-most SACK block,\r\n\t\t * then\r\n\t\t *     RESET the connection\r\n\t\t * else\r\n\t\t *     Send a challenge ACK\r\n\t\t */\r\n\t\tif (TCP_SKB_CB(skb)->seq == tp->rcv_nxt ||\r\n\t\t    tcp_reset_check(sk, skb))\r\n\t\t\tgoto reset;\r\n\r\n\t\tif (tcp_is_sack(tp) && tp->rx_opt.num_sacks > 0) {\r\n\t\t\tstruct tcp_sack_block *sp = &tp->selective_acks[0];\r\n\t\t\tint max_sack = sp[0].end_seq;\r\n\t\t\tint this_sack;\r\n\r\n\t\t\tfor (this_sack = 1; this_sack < tp->rx_opt.num_sacks;\r\n\t\t\t     ++this_sack) {\r\n\t\t\t\tmax_sack = after(sp[this_sack].end_seq,\r\n\t\t\t\t\t\t max_sack) ?\r\n\t\t\t\t\tsp[this_sack].end_seq : max_sack;\r\n\t\t\t}\r\n\r\n\t\t\tif (TCP_SKB_CB(skb)->seq == max_sack)\r\n\t\t\t\tgoto reset;\r\n\t\t}\r\n\r\n\t\t/* Disable TFO if RST is out-of-order\r\n\t\t * and no data has been received\r\n\t\t * for current active TFO socket\r\n\t\t */\r\n\t\tif (tp->syn_fastopen && !tp->data_segs_in &&\r\n\t\t    sk->sk_state == TCP_ESTABLISHED)\r\n\t\t\ttcp_fastopen_active_disable(sk);\r\n\t\ttcp_send_challenge_ack(sk, false);\r\n\t\tSKB_DR_SET(reason, TCP_RESET);\r\n\t\tgoto discard;\r\n\t}\r\n\r\n\t/* step 3: check security and precedence [ignored] */\r\n\r\n\t/* step 4: Check for a SYN\r\n\t * RFC 5961 4.2 : Send a challenge ack\r\n\t */\r\n\tif (th->syn) {\r\n\t\tif (tcp_ecn_mode_accecn(tp)) {\r\n\t\t\taccecn_reflector = true;\r\n\t\t\tif (tp->rx_opt.accecn &&\r\n\t\t\t    tp->saw_accecn_opt < TCP_ACCECN_OPT_COUNTER_SEEN) {\r\n\t\t\t\tu8 saw_opt = tcp_accecn_option_init(skb, tp->rx_opt.accecn);\r\n\r\n\t\t\t\ttcp_accecn_saw_opt_fail_recv(tp, saw_opt);\r\n\t\t\t\ttcp_accecn_opt_demand_min(sk, 1);\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (sk->sk_state == TCP_SYN_RECV && sk->sk_socket && th->ack &&\r\n\t\t    TCP_SKB_CB(skb)->seq + 1 == TCP_SKB_CB(skb)->end_seq &&\r\n\t\t    TCP_SKB_CB(skb)->seq + 1 == tp->rcv_nxt &&\r\n\t\t    TCP_SKB_CB(skb)->ack_seq == tp->snd_nxt)\r\n\t\t\tgoto pass;\r\nsyn_challenge:\r\n\t\tif (syn_inerr)\r\n\t\t\tTCP_INC_STATS(sock_net(sk), TCP_MIB_INERRS);\r\n\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPSYNCHALLENGE);\r\n\t\ttcp_send_challenge_ack(sk, accecn_reflector);\r\n\t\tSKB_DR_SET(reason, TCP_INVALID_SYN);\r\n\t\tgoto discard;\r\n\t}\r\n\r\npass:\r\n\tbpf_skops_parse_hdr(sk, skb);\r\n\r\n\treturn true;\r\n\r\ndiscard:\r\n\ttcp_drop_reason(sk, skb, reason);\r\n\treturn false;\r\n\r\nreset:\r\n\ttcp_reset(sk, skb);\r\n\t__kfree_skb(skb);\r\n\treturn false;\r\n}", ".cp_urg": "static void tcp_urg(struct sock *sk, struct sk_buff *skb, const struct tcphdr *th)\r\n{\r\n\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\r\n\t/* Check if we get a new urgent pointer - normally not. */\r\n\tif (unlikely(th->urg))\r\n\t\ttcp_check_urg(sk, th);\r\n\r\n\t/* Do we wait for any urgent data? - normally not... */\r\n\tif (unlikely(tp->urg_data == TCP_URG_NOTYET)) {\r\n\t\tu32 ptr = tp->urg_seq - ntohl(th->seq) + (th->doff * 4) -\r\n\t\t\t  th->syn;\r\n\r\n\t\t/* Is the urgent pointer pointing into this packet? */\r\n\t\tif (ptr < skb->len) {\r\n\t\t\tu8 tmp;\r\n\t\t\tif (skb_copy_bits(skb, ptr, &tmp, 1))\r\n\t\t\t\tBUG();\r\n\t\t\tWRITE_ONCE(tp->urg_data, TCP_URG_VALID | tmp);\r\n\t\t\tif (!sock_flag(sk, SOCK_DEAD))\r\n\t\t\t\tsk->sk_data_ready(sk);\r\n\t\t}\r\n\t}\r\n}", ".cp_data_queue": "static void tcp_data_queue(struct sock *sk, struct sk_buff *skb)\r\n{\r\n\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\tenum skb_drop_reason reason;\r\n\tbool fragstolen;\r\n\tint eaten;\r\n\r\n\t/* If a subflow has been reset, the packet should not continue\r\n\t * to be processed, drop the packet.\r\n\t */\r\n\tif (sk_is_mptcp(sk) && !mptcp_incoming_options(sk, skb)) {\r\n\t\t__kfree_skb(skb);\r\n\t\treturn;\r\n\t}\r\n\r\n\tif (TCP_SKB_CB(skb)->seq == TCP_SKB_CB(skb)->end_seq) {\r\n\t\t__kfree_skb(skb);\r\n\t\treturn;\r\n\t}\r\n\ttcp_cleanup_skb(skb);\r\n\t__skb_pull(skb, tcp_hdr(skb)->doff * 4);\r\n\r\n\treason = SKB_DROP_REASON_NOT_SPECIFIED;\r\n\ttp->rx_opt.dsack = 0;\r\n\r\n\t/*  Queue data for delivery to the user.\r\n\t *  Packets in sequence go to the receive queue.\r\n\t *  Out of sequence packets to the out_of_order_queue.\r\n\t */\r\n\tif (TCP_SKB_CB(skb)->seq == tp->rcv_nxt) {\r\n\t\tif (tcp_receive_window(tp) == 0) {\r\n\t\t\t/* Some stacks are known to send bare FIN packets\r\n\t\t\t * in a loop even if we send RWIN 0 in our ACK.\r\n\t\t\t * Accepting this FIN does not hurt memory pressure\r\n\t\t\t * because the FIN flag will simply be merged to the\r\n\t\t\t * receive queue tail skb in most cases.\r\n\t\t\t */\r\n\t\t\tif (!skb->len &&\r\n\t\t\t    (TCP_SKB_CB(skb)->tcp_flags & TCPHDR_FIN))\r\n\t\t\t\tgoto queue_and_out;\r\n\r\n\t\t\treason = SKB_DROP_REASON_TCP_ZEROWINDOW;\r\n\t\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPZEROWINDOWDROP);\r\n\t\t\tgoto out_of_window;\r\n\t\t}\r\n\r\n\t\t/* Ok. In sequence. In window. */\r\nqueue_and_out:\r\n\t\tif (tcp_try_rmem_schedule(sk, skb, skb->truesize)) {\r\n\t\t\t/* TODO: maybe ratelimit these WIN 0 ACK ? */\r\n\t\t\tinet_csk(sk)->icsk_ack.pending |=\r\n\t\t\t\t\t(ICSK_ACK_NOMEM | ICSK_ACK_NOW);\r\n\t\t\tinet_csk_schedule_ack(sk);\r\n\t\t\tsk->sk_data_ready(sk);\r\n\r\n\t\t\tif (skb_queue_len(&sk->sk_receive_queue) && skb->len) {\r\n\t\t\t\treason = SKB_DROP_REASON_PROTO_MEM;\r\n\t\t\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPRCVQDROP);\r\n\t\t\t\tgoto drop;\r\n\t\t\t}\r\n\t\t\tsk_forced_mem_schedule(sk, skb->truesize);\r\n\t\t}\r\n\r\n\t\teaten = tcp_queue_rcv(sk, skb, &fragstolen);\r\n\t\tif (skb->len)\r\n\t\t\ttcp_event_data_recv(sk, skb);\r\n\t\tif (TCP_SKB_CB(skb)->tcp_flags & TCPHDR_FIN)\r\n\t\t\ttcp_fin(sk);\r\n\r\n\t\tif (!RB_EMPTY_ROOT(&tp->out_of_order_queue)) {\r\n\t\t\ttcp_ofo_queue(sk);\r\n\r\n\t\t\t/* RFC5681. 4.2. SHOULD send immediate ACK, when\r\n\t\t\t * gap in queue is filled.\r\n\t\t\t */\r\n\t\t\tif (RB_EMPTY_ROOT(&tp->out_of_order_queue))\r\n\t\t\t\tinet_csk(sk)->icsk_ack.pending |= ICSK_ACK_NOW;\r\n\t\t}\r\n\r\n\t\tif (tp->rx_opt.num_sacks)\r\n\t\t\ttcp_sack_remove(tp);\r\n\r\n\t\ttcp_fast_path_check(sk);\r\n\r\n\t\tif (eaten > 0)\r\n\t\t\tkfree_skb_partial(skb, fragstolen);\r\n\t\tif (!sock_flag(sk, SOCK_DEAD))\r\n\t\t\ttcp_data_ready(sk);\r\n\t\treturn;\r\n\t}\r\n\r\n\tif (!after(TCP_SKB_CB(skb)->end_seq, tp->rcv_nxt)) {\r\n\t\ttcp_rcv_spurious_retrans(sk, skb);\r\n\t\t/* A retransmit, 2nd most common case.  Force an immediate ack. */\r\n\t\treason = SKB_DROP_REASON_TCP_OLD_DATA;\r\n\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_DELAYEDACKLOST);\r\n\t\ttcp_dsack_set(sk, TCP_SKB_CB(skb)->seq, TCP_SKB_CB(skb)->end_seq);\r\n\r\nout_of_window:\r\n\t\ttcp_enter_quickack_mode(sk, TCP_MAX_QUICKACKS);\r\n\t\tinet_csk_schedule_ack(sk);\r\ndrop:\r\n\t\ttcp_drop_reason(sk, skb, reason);\r\n\t\treturn;\r\n\t}\r\n\r\n\t/* Out of window. F.e. zero window probe. */\r\n\tif (!before(TCP_SKB_CB(skb)->seq,\r\n\t\t    tp->rcv_nxt + tcp_receive_window(tp))) {\r\n\t\treason = SKB_DROP_REASON_TCP_OVERWINDOW;\r\n\t\tgoto out_of_window;\r\n\t}\r\n\r\n\tif (before(TCP_SKB_CB(skb)->seq, tp->rcv_nxt)) {\r\n\t\t/* Partial packet, seq < rcv_next < end_seq */\r\n\t\ttcp_dsack_set(sk, TCP_SKB_CB(skb)->seq, tp->rcv_nxt);\r\n\r\n\t\t/* If window is closed, drop tail of packet. But after\r\n\t\t * remembering D-SACK for its head made in previous line.\r\n\t\t */\r\n\t\tif (!tcp_receive_window(tp)) {\r\n\t\t\treason = SKB_DROP_REASON_TCP_ZEROWINDOW;\r\n\t\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPZEROWINDOWDROP);\r\n\t\t\tgoto out_of_window;\r\n\t\t}\r\n\t\tgoto queue_and_out;\r\n\t}\r\n\r\n\ttcp_data_queue_ofo(sk, skb);\r\n}", ".cp_ack_snd_check": "static inline void tcp_ack_snd_check(struct sock *sk)\r\n{\r\n\tif (!inet_csk_ack_scheduled(sk)) {\r\n\t\t/* We sent a data segment already. */\r\n\t\treturn;\r\n\t}\r\n\t__tcp_ack_snd_check(sk, 1);\r\n}", ".cp_init_cwnd": "__u32 tcp_init_cwnd(const struct tcp_sock *tp, const struct dst_entry *dst)\r\n{\r\n\t__u32 cwnd = (dst ? dst_metric(dst, RTAX_INITCWND) : 0);\r\n\r\n\tif (!cwnd)\r\n\t\tcwnd = TCP_INIT_CWND;\r\n\treturn min_t(__u32, cwnd, tp->snd_cwnd_clamp);\r\n}", ".pf_skops_established": "static void bpf_skops_established(struct sock *sk, int bpf_op,\r\n\t\t\t\t  struct sk_buff *skb)\r\n{\r\n\tstruct bpf_sock_ops_kern sock_ops;\r\n\r\n\tsock_owned_by_me(sk);\r\n\r\n\tmemset(&sock_ops, 0, offsetof(struct bpf_sock_ops_kern, temp));\r\n\tsock_ops.op = bpf_op;\r\n\tsock_ops.is_fullsock = 1;\r\n\tsock_ops.is_locked_tcp_sock = 1;\r\n\tsock_ops.sk = sk;\r\n\t/* sk with TCP_REPAIR_ON does not have skb in tcp_finish_connect */\r\n\tif (skb)\r\n\t\tbpf_skops_init_skb(&sock_ops, skb, tcp_hdrlen(skb));\r\n\r\n\tBPF_CGROUP_RUN_PROG_SOCK_OPS(&sock_ops);\r\n}", ".cp_init_buffer_space": "static void tcp_init_buffer_space(struct sock *sk)\r\n{\r\n\tint tcp_app_win = READ_ONCE(sock_net(sk)->ipv4.sysctl_tcp_app_win);\r\n\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\tint maxwin;\r\n\r\n\tif (!(sk->sk_userlocks & SOCK_SNDBUF_LOCK))\r\n\t\ttcp_sndbuf_expand(sk);\r\n\r\n\ttcp_mstamp_refresh(tp);\r\n\ttp->rcvq_space.time = tp->tcp_mstamp;\r\n\ttp->rcvq_space.seq = tp->copied_seq;\r\n\r\n\tmaxwin = tcp_full_space(sk);\r\n\r\n\tif (tp->window_clamp >= maxwin) {\r\n\t\tWRITE_ONCE(tp->window_clamp, maxwin);\r\n\r\n\t\tif (tcp_app_win && maxwin > 4 * tp->advmss)\r\n\t\t\tWRITE_ONCE(tp->window_clamp,\r\n\t\t\t\t   max(maxwin - (maxwin >> tcp_app_win),\r\n\t\t\t\t       4 * tp->advmss));\r\n\t}\r\n\r\n\t/* Force reservation of one segment. */\r\n\tif (tcp_app_win &&\r\n\t    tp->window_clamp > 2 * tp->advmss &&\r\n\t    tp->window_clamp + tp->advmss > maxwin)\r\n\t\tWRITE_ONCE(tp->window_clamp,\r\n\t\t\t   max(2 * tp->advmss, maxwin - tp->advmss));\r\n\r\n\ttp->rcv_ssthresh = min(tp->rcv_ssthresh, tp->window_clamp);\r\n\ttp->snd_cwnd_stamp = tcp_jiffies32;\r\n\ttp->rcvq_space.space = min3(tp->rcv_ssthresh, tp->rcv_wnd,\r\n\t\t\t\t    (u32)TCP_INIT_CWND * tp->advmss);\r\n}", ".cp_init_transfer": "void tcp_init_transfer(struct sock *sk, int bpf_op, struct sk_buff *skb)\r\n{\r\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\r\n\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\r\n\ttcp_mtup_init(sk);\r\n\ticsk->icsk_af_ops->rebuild_header(sk);\r\n\ttcp_init_metrics(sk);\r\n\r\n\t/* Initialize the congestion window to start the transfer.\r\n\t * Cut cwnd down to 1 per RFC5681 if SYN or SYN-ACK has been\r\n\t * retransmitted. In light of RFC6298 more aggressive 1sec\r\n\t * initRTO, we only reset cwnd when more than 1 SYN/SYN-ACK\r\n\t * retransmission has occurred.\r\n\t */\r\n\tif (tp->total_retrans > 1 && tp->undo_marker)\r\n\t\ttcp_snd_cwnd_set(tp, 1);\r\n\telse\r\n\t\ttcp_snd_cwnd_set(tp, tcp_init_cwnd(tp, __sk_dst_get(sk)));\r\n\ttp->snd_cwnd_stamp = tcp_jiffies32;\r\n\r\n\tbpf_skops_established(sk, bpf_op, skb);\r\n\t/* Initialize congestion control unless BPF initialized it already: */\r\n\tif (!icsk->icsk_ca_initialized)\r\n\t\ttcp_init_congestion_control(sk);\r\n\ttcp_init_buffer_space(sk);\r\n}", ".cp_try_undo_spurious_syn": "static void tcp_try_undo_spurious_syn(struct sock *sk)\r\n{\r\n\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\tu32 syn_stamp;\r\n\r\n\t/* undo_marker is set when SYN or SYNACK times out. The timeout is\r\n\t * spurious if the ACK's timestamp option echo value matches the\r\n\t * original SYN timestamp.\r\n\t */\r\n\tsyn_stamp = tp->retrans_stamp;\r\n\tif (tp->undo_marker && syn_stamp && tp->rx_opt.saw_tstamp &&\r\n\t    syn_stamp == tp->rx_opt.rcv_tsecr)\r\n\t\ttp->undo_marker = 0;\r\n}", ".cp_store_ts_recent": "static void tcp_store_ts_recent(struct tcp_sock *tp)\r\n{\r\n\ttp->rx_opt.ts_recent = tp->rx_opt.rcv_tsval;\r\n\ttp->rx_opt.ts_recent_stamp = ktime_get_seconds();\r\n}", ".cp_initialize_rcv_mss": "void tcp_initialize_rcv_mss(struct sock *sk)\r\n{\r\n\tconst struct tcp_sock *tp = tcp_sk(sk);\r\n\tunsigned int hint = min_t(unsigned int, tp->advmss, tp->mss_cache);\r\n\r\n\thint = min(hint, tp->rcv_wnd / 2);\r\n\thint = min(hint, TCP_MSS_DEFAULT);\r\n\thint = max(hint, TCP_MIN_MSS);\r\n\r\n\tinet_csk(sk)->icsk_ack.rcv_mss = hint;\r\n}", ".mc_check_reset_syn": "static void smc_check_reset_syn(struct tcp_sock *tp)\r\n{\r\n#if IS_ENABLED(CONFIG_SMC)\r\n\tif (static_branch_unlikely(&tcp_have_smc)) {\r\n\t\tif (tp->syn_smc && !tp->rx_opt.smc_ok)\r\n\t\t\ttp->syn_smc = 0;\r\n\t}\r\n#endif\r\n}", ".cp_finish_connect": "void tcp_finish_connect(struct sock *sk, struct sk_buff *skb)\r\n{\r\n\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\r\n\r\n\ttcp_ao_finish_connect(sk, skb);\r\n\ttcp_set_state(sk, TCP_ESTABLISHED);\r\n\ticsk->icsk_ack.lrcvtime = tcp_jiffies32;\r\n\r\n\tif (skb) {\r\n\t\ticsk->icsk_af_ops->sk_rx_dst_set(sk, skb);\r\n\t\tsecurity_inet_conn_established(sk, skb);\r\n\t\tsk_mark_napi_id(sk, skb);\r\n\t}\r\n\r\n\ttcp_init_transfer(sk, BPF_SOCK_OPS_ACTIVE_ESTABLISHED_CB, skb);\r\n\r\n\t/* Prevent spurious tcp_cwnd_restart() on first data\r\n\t * packet.\r\n\t */\r\n\ttp->lsndtime = tcp_jiffies32;\r\n\r\n\tif (sock_flag(sk, SOCK_KEEPOPEN))\r\n\t\ttcp_reset_keepalive_timer(sk, keepalive_time_when(tp));\r\n\r\n\tif (!tp->rx_opt.snd_wscale)\r\n\t\t__tcp_fast_path_on(tp, tp->snd_wnd);\r\n\telse\r\n\t\ttp->pred_flags = 0;\r\n}", ".cp_rcv_fastopen_synack": "static bool tcp_rcv_fastopen_synack(struct sock *sk, struct sk_buff *synack,\r\n\t\t\t\t    struct tcp_fastopen_cookie *cookie)\r\n{\r\n\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\tstruct sk_buff *data = tp->syn_data ? tcp_rtx_queue_head(sk) : NULL;\r\n\tu16 mss = tp->rx_opt.mss_clamp, try_exp = 0;\r\n\tbool syn_drop = false;\r\n\r\n\tif (mss == READ_ONCE(tp->rx_opt.user_mss)) {\r\n\t\tstruct tcp_options_received opt;\r\n\r\n\t\t/* Get original SYNACK MSS value if user MSS sets mss_clamp */\r\n\t\ttcp_clear_options(&opt);\r\n\t\topt.user_mss = opt.mss_clamp = 0;\r\n\t\ttcp_parse_options(sock_net(sk), synack, &opt, 0, NULL);\r\n\t\tmss = opt.mss_clamp;\r\n\t}\r\n\r\n\tif (!tp->syn_fastopen) {\r\n\t\t/* Ignore an unsolicited cookie */\r\n\t\tcookie->len = -1;\r\n\t} else if (tp->total_retrans) {\r\n\t\t/* SYN timed out and the SYN-ACK neither has a cookie nor\r\n\t\t * acknowledges data. Presumably the remote received only\r\n\t\t * the retransmitted (regular) SYNs: either the original\r\n\t\t * SYN-data or the corresponding SYN-ACK was dropped.\r\n\t\t */\r\n\t\tsyn_drop = (cookie->len < 0 && data);\r\n\t} else if (cookie->len < 0 && !tp->syn_data) {\r\n\t\t/* We requested a cookie but didn't get it. If we did not use\r\n\t\t * the (old) exp opt format then try so next time (try_exp=1).\r\n\t\t * Otherwise we go back to use the RFC7413 opt (try_exp=2).\r\n\t\t */\r\n\t\ttry_exp = tp->syn_fastopen_exp ? 2 : 1;\r\n\t}\r\n\r\n\ttcp_fastopen_cache_set(sk, mss, cookie, syn_drop, try_exp);\r\n\r\n\tif (data) { /* Retransmit unacked data in SYN */\r\n\t\tif (tp->total_retrans)\r\n\t\t\ttp->fastopen_client_fail = TFO_SYN_RETRANSMITTED;\r\n\t\telse\r\n\t\t\ttp->fastopen_client_fail = TFO_DATA_NOT_ACKED;\r\n\t\tskb_rbtree_walk_from(data)\r\n\t\t\t tcp_mark_skb_lost(sk, data);\r\n\t\ttcp_non_congestion_loss_retransmit(sk);\r\n\t\tNET_INC_STATS(sock_net(sk),\r\n\t\t\t\tLINUX_MIB_TCPFASTOPENACTIVEFAIL);\r\n\t\treturn true;\r\n\t}\r\n\ttp->syn_data_acked = tp->syn_data;\r\n\tif (tp->syn_data_acked) {\r\n\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPFASTOPENACTIVE);\r\n\t\t/* SYN-data is counted as two separate packets in tcp_ack() */\r\n\t\tif (tp->delivered > 1)\r\n\t\t\t--tp->delivered;\r\n\t}\r\n\r\n\ttcp_fastopen_add_skb(sk, synack);\r\n\r\n\treturn false;\r\n}", ".cp_rcv_synsent_state_process": "static int tcp_rcv_synsent_state_process(struct sock *sk, struct sk_buff *skb,\r\n\t\t\t\t\t const struct tcphdr *th)\r\n{\r\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\r\n\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\tstruct tcp_fastopen_cookie foc = { .len = -1 };\r\n\tint saved_clamp = tp->rx_opt.mss_clamp;\r\n\tbool fastopen_fail;\r\n\tSKB_DR(reason);\r\n\r\n\ttcp_parse_options(sock_net(sk), skb, &tp->rx_opt, 0, &foc);\r\n\tif (tp->rx_opt.saw_tstamp && tp->rx_opt.rcv_tsecr)\r\n\t\ttp->rx_opt.rcv_tsecr -= tp->tsoffset;\r\n\r\n\tif (th->ack) {\r\n\t\t/* rfc793:\r\n\t\t * \"If the state is SYN-SENT then\r\n\t\t *    first check the ACK bit\r\n\t\t *      If the ACK bit is set\r\n\t\t *\t  If SEG.ACK =< ISS, or SEG.ACK > SND.NXT, send\r\n\t\t *        a reset (unless the RST bit is set, if so drop\r\n\t\t *        the segment and return)\"\r\n\t\t */\r\n\t\tif (!after(TCP_SKB_CB(skb)->ack_seq, tp->snd_una) ||\r\n\t\t    after(TCP_SKB_CB(skb)->ack_seq, tp->snd_nxt)) {\r\n\t\t\t/* Previous FIN/ACK or RST/ACK might be ignored. */\r\n\t\t\tif (icsk->icsk_retransmits == 0)\r\n\t\t\t\ttcp_reset_xmit_timer(sk, ICSK_TIME_RETRANS,\r\n\t\t\t\t\t\t     TCP_TIMEOUT_MIN, false);\r\n\t\t\tSKB_DR_SET(reason, TCP_INVALID_ACK_SEQUENCE);\r\n\t\t\tgoto reset_and_undo;\r\n\t\t}\r\n\r\n\t\tif (tp->rx_opt.saw_tstamp && tp->rx_opt.rcv_tsecr &&\r\n\t\t    !between(tp->rx_opt.rcv_tsecr, tp->retrans_stamp,\r\n\t\t\t     tcp_time_stamp_ts(tp))) {\r\n\t\t\tNET_INC_STATS(sock_net(sk),\r\n\t\t\t\t\tLINUX_MIB_PAWSACTIVEREJECTED);\r\n\t\t\tSKB_DR_SET(reason, TCP_RFC7323_PAWS);\r\n\t\t\tgoto reset_and_undo;\r\n\t\t}\r\n\r\n\t\t/* Now ACK is acceptable.\r\n\t\t *\r\n\t\t * \"If the RST bit is set\r\n\t\t *    If the ACK was acceptable then signal the user \"error:\r\n\t\t *    connection reset\", drop the segment, enter CLOSED state,\r\n\t\t *    delete TCB, and return.\"\r\n\t\t */\r\n\r\n\t\tif (th->rst) {\r\n\t\t\ttcp_reset(sk, skb);\r\nconsume:\r\n\t\t\t__kfree_skb(skb);\r\n\t\t\treturn 0;\r\n\t\t}\r\n\r\n\t\t/* rfc793:\r\n\t\t *   \"fifth, if neither of the SYN or RST bits is set then\r\n\t\t *    drop the segment and return.\"\r\n\t\t *\r\n\t\t *    See note below!\r\n\t\t *                                        --ANK(990513)\r\n\t\t */\r\n\t\tif (!th->syn) {\r\n\t\t\tSKB_DR_SET(reason, TCP_FLAGS);\r\n\t\t\tgoto discard_and_undo;\r\n\t\t}\r\n\t\t/* rfc793:\r\n\t\t *   \"If the SYN bit is on ...\r\n\t\t *    are acceptable then ...\r\n\t\t *    (our SYN has been ACKed), change the connection\r\n\t\t *    state to ESTABLISHED...\"\r\n\t\t */\r\n\r\n\t\tif (tcp_ecn_mode_any(tp))\r\n\t\t\ttcp_ecn_rcv_synack(sk, skb, th,\r\n\t\t\t\t\t   TCP_SKB_CB(skb)->ip_dsfield);\r\n\r\n\t\ttcp_init_wl(tp, TCP_SKB_CB(skb)->seq);\r\n\t\ttcp_try_undo_spurious_syn(sk);\r\n\t\ttcp_ack(sk, skb, FLAG_SLOWPATH);\r\n\r\n\t\t/* Ok.. it's good. Set up sequence numbers and\r\n\t\t * move to established.\r\n\t\t */\r\n\t\tWRITE_ONCE(tp->rcv_nxt, TCP_SKB_CB(skb)->seq + 1);\r\n\t\ttp->rcv_wup = TCP_SKB_CB(skb)->seq + 1;\r\n\r\n\t\t/* RFC1323: The window in SYN & SYN/ACK segments is\r\n\t\t * never scaled.\r\n\t\t */\r\n\t\ttp->snd_wnd = ntohs(th->window);\r\n\r\n\t\tif (!tp->rx_opt.wscale_ok) {\r\n\t\t\ttp->rx_opt.snd_wscale = tp->rx_opt.rcv_wscale = 0;\r\n\t\t\tWRITE_ONCE(tp->window_clamp,\r\n\t\t\t\t   min(tp->window_clamp, 65535U));\r\n\t\t}\r\n\r\n\t\tif (tp->rx_opt.saw_tstamp) {\r\n\t\t\ttp->rx_opt.tstamp_ok\t   = 1;\r\n\t\t\ttp->tcp_header_len =\r\n\t\t\t\tsizeof(struct tcphdr) + TCPOLEN_TSTAMP_ALIGNED;\r\n\t\t\ttp->advmss\t    -= TCPOLEN_TSTAMP_ALIGNED;\r\n\t\t\ttcp_store_ts_recent(tp);\r\n\t\t} else {\r\n\t\t\ttp->tcp_header_len = sizeof(struct tcphdr);\r\n\t\t}\r\n\r\n\t\ttcp_sync_mss(sk, icsk->icsk_pmtu_cookie);\r\n\t\ttcp_initialize_rcv_mss(sk);\r\n\r\n\t\t/* Remember, tcp_poll() does not lock socket!\r\n\t\t * Change state from SYN-SENT only after copied_seq\r\n\t\t * is initialized. */\r\n\t\tWRITE_ONCE(tp->copied_seq, tp->rcv_nxt);\r\n\r\n\t\tsmc_check_reset_syn(tp);\r\n\r\n\t\tsmp_mb();\r\n\r\n\t\ttcp_finish_connect(sk, skb);\r\n\r\n\t\tfastopen_fail = (tp->syn_fastopen || tp->syn_data) &&\r\n\t\t\t\ttcp_rcv_fastopen_synack(sk, skb, &foc);\r\n\r\n\t\tif (!sock_flag(sk, SOCK_DEAD)) {\r\n\t\t\tsk->sk_state_change(sk);\r\n\t\t\tsk_wake_async(sk, SOCK_WAKE_IO, POLL_OUT);\r\n\t\t}\r\n\t\tif (fastopen_fail)\r\n\t\t\treturn -1;\r\n\t\tif (sk->sk_write_pending ||\r\n\t\t    READ_ONCE(icsk->icsk_accept_queue.rskq_defer_accept) ||\r\n\t\t    inet_csk_in_pingpong_mode(sk)) {\r\n\t\t\t/* Save one ACK. Data will be ready after\r\n\t\t\t * several ticks, if write_pending is set.\r\n\t\t\t *\r\n\t\t\t * It may be deleted, but with this feature tcpdumps\r\n\t\t\t * look so _wonderfully_ clever, that I was not able\r\n\t\t\t * to stand against the temptation 8)     --ANK\r\n\t\t\t */\r\n\t\t\tinet_csk_schedule_ack(sk);\r\n\t\t\ttcp_enter_quickack_mode(sk, TCP_MAX_QUICKACKS);\r\n\t\t\ttcp_reset_xmit_timer(sk, ICSK_TIME_DACK,\r\n\t\t\t\t\t     TCP_DELACK_MAX, false);\r\n\t\t\tgoto consume;\r\n\t\t}\r\n\t\ttcp_send_ack_reflect_ect(sk, tcp_ecn_mode_accecn(tp));\r\n\t\treturn -1;\r\n\t}\r\n\r\n\t/* No ACK in the segment */\r\n\r\n\tif (th->rst) {\r\n\t\t/* rfc793:\r\n\t\t * \"If the RST bit is set\r\n\t\t *\r\n\t\t *      Otherwise (no ACK) drop the segment and return.\"\r\n\t\t */\r\n\t\tSKB_DR_SET(reason, TCP_RESET);\r\n\t\tgoto discard_and_undo;\r\n\t}\r\n\r\n\t/* PAWS check. */\r\n\tif (tp->rx_opt.ts_recent_stamp && tp->rx_opt.saw_tstamp &&\r\n\t    tcp_paws_reject(&tp->rx_opt, 0)) {\r\n\t\tSKB_DR_SET(reason, TCP_RFC7323_PAWS);\r\n\t\tgoto discard_and_undo;\r\n\t}\r\n\tif (th->syn) {\r\n\t\t/* We see SYN without ACK. It is attempt of\r\n\t\t * simultaneous connect with crossed SYNs.\r\n\t\t * Particularly, it can be connect to self.\r\n\t\t */\r\n#ifdef CONFIG_TCP_AO\r\n\t\tstruct tcp_ao_info *ao;\r\n\r\n\t\tao = rcu_dereference_protected(tp->ao_info,\r\n\t\t\t\t\t       lockdep_sock_is_held(sk));\r\n\t\tif (ao) {\r\n\t\t\tWRITE_ONCE(ao->risn, th->seq);\r\n\t\t\tao->rcv_sne = 0;\r\n\t\t}\r\n#endif\r\n\t\ttcp_set_state(sk, TCP_SYN_RECV);\r\n\r\n\t\tif (tp->rx_opt.saw_tstamp) {\r\n\t\t\ttp->rx_opt.tstamp_ok = 1;\r\n\t\t\ttcp_store_ts_recent(tp);\r\n\t\t\ttp->tcp_header_len =\r\n\t\t\t\tsizeof(struct tcphdr) + TCPOLEN_TSTAMP_ALIGNED;\r\n\t\t} else {\r\n\t\t\ttp->tcp_header_len = sizeof(struct tcphdr);\r\n\t\t}\r\n\r\n\t\tWRITE_ONCE(tp->rcv_nxt, TCP_SKB_CB(skb)->seq + 1);\r\n\t\tWRITE_ONCE(tp->copied_seq, tp->rcv_nxt);\r\n\t\ttp->rcv_wup = TCP_SKB_CB(skb)->seq + 1;\r\n\r\n\t\t/* RFC1323: The window in SYN & SYN/ACK segments is\r\n\t\t * never scaled.\r\n\t\t */\r\n\t\ttp->snd_wnd    = ntohs(th->window);\r\n\t\ttp->snd_wl1    = TCP_SKB_CB(skb)->seq;\r\n\t\ttp->max_window = tp->snd_wnd;\r\n\r\n\t\ttcp_ecn_rcv_syn(tp, th, skb);\r\n\r\n\t\ttcp_mtup_init(sk);\r\n\t\ttcp_sync_mss(sk, icsk->icsk_pmtu_cookie);\r\n\t\ttcp_initialize_rcv_mss(sk);\r\n\r\n\t\ttcp_send_synack(sk);\r\n#if 0\r\n\t\t/* Note, we could accept data and URG from this segment.\r\n\t\t * There are no obstacles to make this (except that we must\r\n\t\t * either change tcp_recvmsg() to prevent it from returning data\r\n\t\t * before 3WHS completes per RFC793, or employ TCP Fast Open).\r\n\t\t *\r\n\t\t * However, if we ignore data in ACKless segments sometimes,\r\n\t\t * we have no reasons to accept it sometimes.\r\n\t\t * Also, seems the code doing it in step6 of tcp_rcv_state_process\r\n\t\t * is not flawless. So, discard packet for sanity.\r\n\t\t * Uncomment this return to process the data.\r\n\t\t */\r\n\t\treturn -1;\r\n#else\r\n\t\tgoto consume;\r\n#endif\r\n\t}\r\n\t/* \"fifth, if neither of the SYN or RST bits is set then\r\n\t * drop the segment and return.\"\r\n\t */\r\n\r\ndiscard_and_undo:\r\n\ttcp_clear_options(&tp->rx_opt);\r\n\ttp->rx_opt.mss_clamp = saved_clamp;\r\n\ttcp_drop_reason(sk, skb, reason);\r\n\treturn 0;\r\n\r\nreset_and_undo:\r\n\ttcp_clear_options(&tp->rx_opt);\r\n\ttp->rx_opt.mss_clamp = saved_clamp;\r\n\t/* we can reuse/return @reason to its caller to handle the exception */\r\n\treturn reason;\r\n}", ".cp_synack_rtt_meas": "void tcp_synack_rtt_meas(struct sock *sk, struct request_sock *req)\r\n{\r\n\tstruct rate_sample rs;\r\n\tlong rtt_us = -1L;\r\n\r\n\tif (req && !req->num_retrans && tcp_rsk(req)->snt_synack)\r\n\t\trtt_us = tcp_stamp_us_delta(tcp_clock_us(), tcp_rsk(req)->snt_synack);\r\n\r\n\ttcp_ack_update_rtt(sk, FLAG_SYN_ACKED, rtt_us, -1L, rtt_us, &rs);\r\n}", ".cp_rcv_synrecv_state_fastopen": "static void tcp_rcv_synrecv_state_fastopen(struct sock *sk)\r\n{\r\n\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\tstruct request_sock *req;\r\n\r\n\t/* If we are still handling the SYNACK RTO, see if timestamp ECR allows\r\n\t * undo. If peer SACKs triggered fast recovery, we can't undo here.\r\n\t */\r\n\tif (inet_csk(sk)->icsk_ca_state == TCP_CA_Loss && !tp->packets_out)\r\n\t\ttcp_try_undo_recovery(sk);\r\n\r\n\ttcp_update_rto_time(tp);\r\n\tWRITE_ONCE(inet_csk(sk)->icsk_retransmits, 0);\r\n\t/* In tcp_fastopen_synack_timer() on the first SYNACK RTO we set\r\n\t * retrans_stamp but don't enter CA_Loss, so in case that happened we\r\n\t * need to zero retrans_stamp here to prevent spurious\r\n\t * retransmits_timed_out(). However, if the ACK of our SYNACK caused us\r\n\t * to enter CA_Recovery then we need to leave retrans_stamp as it was\r\n\t * set entering CA_Recovery, for correct retransmits_timed_out() and\r\n\t * undo behavior.\r\n\t */\r\n\ttcp_retrans_stamp_cleanup(sk);\r\n\r\n\t/* Once we leave TCP_SYN_RECV or TCP_FIN_WAIT_1,\r\n\t * we no longer need req so release it.\r\n\t */\r\n\treq = rcu_dereference_protected(tp->fastopen_rsk,\r\n\t\t\t\t\tlockdep_sock_is_held(sk));\r\n\treqsk_fastopen_remove(sk, req, false);\r\n\r\n\t/* Re-arm the timer because data may have been sent out.\r\n\t * This is similar to the regular data transmission case\r\n\t * when new data has just been ack'ed.\r\n\t *\r\n\t * (TFO) - we could try to be more aggressive and\r\n\t * retransmitting any data sooner based on when they\r\n\t * are sent out.\r\n\t */\r\n\ttcp_rearm_rto(sk);\r\n}", ".cp_syn_flood_action": "static bool tcp_syn_flood_action(struct sock *sk, const char *proto)\r\n{\r\n\tstruct request_sock_queue *queue = &inet_csk(sk)->icsk_accept_queue;\r\n\tconst char *msg = \"Dropping request\";\r\n\tstruct net *net = sock_net(sk);\r\n\tbool want_cookie = false;\r\n\tu8 syncookies;\r\n\r\n\tsyncookies = READ_ONCE(net->ipv4.sysctl_tcp_syncookies);\r\n\r\n#ifdef CONFIG_SYN_COOKIES\r\n\tif (syncookies) {\r\n\t\tmsg = \"Sending cookies\";\r\n\t\twant_cookie = true;\r\n\t\t__NET_INC_STATS(sock_net(sk), LINUX_MIB_TCPREQQFULLDOCOOKIES);\r\n\t} else\r\n#endif\r\n\t\t__NET_INC_STATS(sock_net(sk), LINUX_MIB_TCPREQQFULLDROP);\r\n\r\n\tif (syncookies != 2 && !READ_ONCE(queue->synflood_warned)) {\r\n\t\tWRITE_ONCE(queue->synflood_warned, 1);\r\n\t\tif (IS_ENABLED(CONFIG_IPV6) && sk->sk_family == AF_INET6) {\r\n\t\t\tnet_info_ratelimited(\"%s: Possible SYN flooding on port [%pI6c]:%u. %s.\\n\",\r\n\t\t\t\t\tproto, inet6_rcv_saddr(sk),\r\n\t\t\t\t\tsk->sk_num, msg);\r\n\t\t} else {\r\n\t\t\tnet_info_ratelimited(\"%s: Possible SYN flooding on port %pI4:%u. %s.\\n\",\r\n\t\t\t\t\tproto, &sk->sk_rcv_saddr,\r\n\t\t\t\t\tsk->sk_num, msg);\r\n\t\t}\r\n\t}\r\n\r\n\treturn want_cookie;\r\n}", ".cp_parse_mss_option": "u16 tcp_parse_mss_option(const struct tcphdr *th, u16 user_mss)\r\n{\r\n\tconst unsigned char *ptr = (const unsigned char *)(th + 1);\r\n\tint length = (th->doff * 4) - sizeof(struct tcphdr);\r\n\tu16 mss = 0;\r\n\r\n\twhile (length > 0) {\r\n\t\tint opcode = *ptr++;\r\n\t\tint opsize;\r\n\r\n\t\tswitch (opcode) {\r\n\t\tcase TCPOPT_EOL:\r\n\t\t\treturn mss;\r\n\t\tcase TCPOPT_NOP:\t/* Ref: RFC 793 section 3.1 */\r\n\t\t\tlength--;\r\n\t\t\tcontinue;\r\n\t\tdefault:\r\n\t\t\tif (length < 2)\r\n\t\t\t\treturn mss;\r\n\t\t\topsize = *ptr++;\r\n\t\t\tif (opsize < 2) /* \"silly options\" */\r\n\t\t\t\treturn mss;\r\n\t\t\tif (opsize > length)\r\n\t\t\t\treturn mss;\t/* fail on partial options */\r\n\t\t\tif (opcode == TCPOPT_MSS && opsize == TCPOLEN_MSS) {\r\n\t\t\t\tu16 in_mss = get_unaligned_be16(ptr);\r\n\r\n\t\t\t\tif (in_mss) {\r\n\t\t\t\t\tif (user_mss && user_mss < in_mss)\r\n\t\t\t\t\t\tin_mss = user_mss;\r\n\t\t\t\t\tmss = in_mss;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tptr += opsize - 2;\r\n\t\t\tlength -= opsize;\r\n\t\t}\r\n\t}\r\n\treturn mss;\r\n}", ".cp_openreq_init": "static void tcp_openreq_init(struct request_sock *req,\r\n\t\t\t     const struct tcp_options_received *rx_opt,\r\n\t\t\t     struct sk_buff *skb, const struct sock *sk)\r\n{\r\n\tstruct inet_request_sock *ireq = inet_rsk(req);\r\n\r\n\treq->rsk_rcv_wnd = 0;\t\t/* So that tcp_send_synack() knows! */\r\n\ttcp_rsk(req)->rcv_isn = TCP_SKB_CB(skb)->seq;\r\n\ttcp_rsk(req)->rcv_nxt = TCP_SKB_CB(skb)->seq + 1;\r\n\ttcp_rsk(req)->snt_synack = 0;\r\n\ttcp_rsk(req)->snt_tsval_first = 0;\r\n\ttcp_rsk(req)->last_oow_ack_time = 0;\r\n\ttcp_rsk(req)->accecn_ok = 0;\r\n\ttcp_rsk(req)->saw_accecn_opt = TCP_ACCECN_OPT_NOT_SEEN;\r\n\ttcp_rsk(req)->accecn_fail_mode = 0;\r\n\ttcp_rsk(req)->syn_ect_rcv = 0;\r\n\ttcp_rsk(req)->syn_ect_snt = 0;\r\n\treq->mss = rx_opt->mss_clamp;\r\n\treq->ts_recent = rx_opt->saw_tstamp ? rx_opt->rcv_tsval : 0;\r\n\tireq->tstamp_ok = rx_opt->tstamp_ok;\r\n\tireq->sack_ok = rx_opt->sack_ok;\r\n\tireq->snd_wscale = rx_opt->snd_wscale;\r\n\tireq->wscale_ok = rx_opt->wscale_ok;\r\n\tireq->acked = 0;\r\n\tireq->ecn_ok = 0;\r\n\tireq->ir_rmt_port = tcp_hdr(skb)->source;\r\n\tireq->ir_num = ntohs(tcp_hdr(skb)->dest);\r\n\tireq->ir_mark = inet_request_mark(sk, skb);\r\n#if IS_ENABLED(CONFIG_SMC)\r\n\tireq->smc_ok = rx_opt->smc_ok && !(tcp_sk(sk)->smc_hs_congested &&\r\n\t\t\ttcp_sk(sk)->smc_hs_congested(sk));\r\n#endif\r\n}", ".r_drop_req": "static inline void pr_drop_req(struct request_sock *req, __u16 port, int family)\r\n{\r\n\tstruct inet_request_sock *ireq = inet_rsk(req);\r\n\r\n\tif (family == AF_INET)\r\n\t\tnet_dbg_ratelimited(\"drop open request from %pI4/%u\\n\",\r\n\t\t\t\t    &ireq->ir_rmt_addr, port);\r\n#if IS_ENABLED(CONFIG_IPV6)\r\n\telse if (family == AF_INET6)\r\n\t\tnet_dbg_ratelimited(\"drop open request from %pI6/%u\\n\",\r\n\t\t\t\t    &ireq->ir_v6_rmt_addr, port);\r\n#endif\r\n}", ".cp_ecn_create_request": "static void tcp_ecn_create_request(struct request_sock *req,\r\n\t\t\t\t   const struct sk_buff *skb,\r\n\t\t\t\t   const struct sock *listen_sk,\r\n\t\t\t\t   const struct dst_entry *dst)\r\n{\r\n\tconst struct tcphdr *th = tcp_hdr(skb);\r\n\tconst struct net *net = sock_net(listen_sk);\r\n\tbool th_ecn = th->ece && th->cwr;\r\n\tbool ect, ecn_ok;\r\n\tu32 ecn_ok_dst;\r\n\r\n\tif (tcp_accecn_syn_requested(th) &&\r\n\t    READ_ONCE(net->ipv4.sysctl_tcp_ecn) >= 3) {\r\n\t\tinet_rsk(req)->ecn_ok = 1;\r\n\t\ttcp_rsk(req)->accecn_ok = 1;\r\n\t\ttcp_rsk(req)->syn_ect_rcv = TCP_SKB_CB(skb)->ip_dsfield &\r\n\t\t\t\t\t    INET_ECN_MASK;\r\n\t\treturn;\r\n\t}\r\n\r\n\tif (!th_ecn)\r\n\t\treturn;\r\n\r\n\tect = !INET_ECN_is_not_ect(TCP_SKB_CB(skb)->ip_dsfield);\r\n\tecn_ok_dst = dst_feature(dst, DST_FEATURE_ECN_MASK);\r\n\tecn_ok = READ_ONCE(net->ipv4.sysctl_tcp_ecn) || ecn_ok_dst;\r\n\r\n\tif (((!ect || th->res1 || th->ae) && ecn_ok) ||\r\n\t    tcp_ca_needs_ecn(listen_sk) ||\r\n\t    (ecn_ok_dst & DST_FEATURE_ECN_CA) ||\r\n\t    tcp_bpf_ca_needs_ecn((struct sock *)req))\r\n\t\tinet_rsk(req)->ecn_ok = 1;\r\n}", ".cp_reqsk_record_syn": "static void tcp_reqsk_record_syn(const struct sock *sk,\r\n\t\t\t\t struct request_sock *req,\r\n\t\t\t\t const struct sk_buff *skb)\r\n{\r\n\tif (tcp_sk(sk)->save_syn) {\r\n\t\tu32 len = skb_network_header_len(skb) + tcp_hdrlen(skb);\r\n\t\tstruct saved_syn *saved_syn;\r\n\t\tu32 mac_hdrlen;\r\n\t\tvoid *base;\r\n\r\n\t\tif (tcp_sk(sk)->save_syn == 2) {  /* Save full header. */\r\n\t\t\tbase = skb_mac_header(skb);\r\n\t\t\tmac_hdrlen = skb_mac_header_len(skb);\r\n\t\t\tlen += mac_hdrlen;\r\n\t\t} else {\r\n\t\t\tbase = skb_network_header(skb);\r\n\t\t\tmac_hdrlen = 0;\r\n\t\t}\r\n\r\n\t\tsaved_syn = kmalloc(struct_size(saved_syn, data, len),\r\n\t\t\t\t    GFP_ATOMIC);\r\n\t\tif (saved_syn) {\r\n\t\t\tsaved_syn->mac_hdrlen = mac_hdrlen;\r\n\t\t\tsaved_syn->network_hdrlen = skb_network_header_len(skb);\r\n\t\t\tsaved_syn->tcp_hdrlen = tcp_hdrlen(skb);\r\n\t\t\tmemcpy(saved_syn->data, base, len);\r\n\t\t\treq->saved_syn = saved_syn;\r\n\t\t}\r\n\t}\r\n}"}, "callee": {".cp_validate_incoming": "static bool tcp_validate_incoming(struct sock *sk, struct sk_buff *skb,\r\n\t\t\t\t  const struct tcphdr *th, int syn_inerr)\r\n{\r\n\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\tbool accecn_reflector = false;\r\n\tSKB_DR(reason);\r\n\r\n\t/* RFC1323: H1. Apply PAWS check first. */\r\n\tif (!tcp_fast_parse_options(sock_net(sk), skb, th, tp) ||\r\n\t    !tp->rx_opt.saw_tstamp ||\r\n\t    tcp_paws_check(&tp->rx_opt, TCP_PAWS_WINDOW))\r\n\t\tgoto step1;\r\n\r\n\treason = tcp_disordered_ack_check(sk, skb);\r\n\tif (!reason)\r\n\t\tgoto step1;\r\n\t/* Reset is accepted even if it did not pass PAWS. */\r\n\tif (th->rst)\r\n\t\tgoto step1;\r\n\tif (unlikely(th->syn))\r\n\t\tgoto syn_challenge;\r\n\r\n\t/* Old ACK are common, increment PAWS_OLD_ACK\r\n\t * and do not send a dupack.\r\n\t */\r\n\tif (reason == SKB_DROP_REASON_TCP_RFC7323_PAWS_ACK) {\r\n\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_PAWS_OLD_ACK);\r\n\t\tgoto discard;\r\n\t}\r\n\tNET_INC_STATS(sock_net(sk), LINUX_MIB_PAWSESTABREJECTED);\r\n\tif (!tcp_oow_rate_limited(sock_net(sk), skb,\r\n\t\t\t\t  LINUX_MIB_TCPACKSKIPPEDPAWS,\r\n\t\t\t\t  &tp->last_oow_ack_time))\r\n\t\ttcp_send_dupack(sk, skb);\r\n\tgoto discard;\r\n\r\nstep1:\r\n\t/* Step 1: check sequence number */\r\n\treason = tcp_sequence(sk, TCP_SKB_CB(skb)->seq, TCP_SKB_CB(skb)->end_seq);\r\n\tif (reason) {\r\n\t\t/* RFC793, page 37: \"In all states except SYN-SENT, all reset\r\n\t\t * (RST) segments are validated by checking their SEQ-fields.\"\r\n\t\t * And page 69: \"If an incoming segment is not acceptable,\r\n\t\t * an acknowledgment should be sent in reply (unless the RST\r\n\t\t * bit is set, if so drop the segment and return)\".\r\n\t\t */\r\n\t\tif (!th->rst) {\r\n\t\t\tif (th->syn)\r\n\t\t\t\tgoto syn_challenge;\r\n\r\n\t\t\tif (reason == SKB_DROP_REASON_TCP_INVALID_SEQUENCE ||\r\n\t\t\t    reason == SKB_DROP_REASON_TCP_INVALID_END_SEQUENCE)\r\n\t\t\t\tNET_INC_STATS(sock_net(sk),\r\n\t\t\t\t\t      LINUX_MIB_BEYOND_WINDOW);\r\n\t\t\tif (!tcp_oow_rate_limited(sock_net(sk), skb,\r\n\t\t\t\t\t\t  LINUX_MIB_TCPACKSKIPPEDSEQ,\r\n\t\t\t\t\t\t  &tp->last_oow_ack_time))\r\n\t\t\t\ttcp_send_dupack(sk, skb);\r\n\t\t} else if (tcp_reset_check(sk, skb)) {\r\n\t\t\tgoto reset;\r\n\t\t}\r\n\t\tgoto discard;\r\n\t}\r\n\r\n\t/* Step 2: check RST bit */\r\n\tif (th->rst) {\r\n\t\t/* RFC 5961 3.2 (extend to match against (RCV.NXT - 1) after a\r\n\t\t * FIN and SACK too if available):\r\n\t\t * If seq num matches RCV.NXT or (RCV.NXT - 1) after a FIN, or\r\n\t\t * the right-most SACK block,\r\n\t\t * then\r\n\t\t *     RESET the connection\r\n\t\t * else\r\n\t\t *     Send a challenge ACK\r\n\t\t */\r\n\t\tif (TCP_SKB_CB(skb)->seq == tp->rcv_nxt ||\r\n\t\t    tcp_reset_check(sk, skb))\r\n\t\t\tgoto reset;\r\n\r\n\t\tif (tcp_is_sack(tp) && tp->rx_opt.num_sacks > 0) {\r\n\t\t\tstruct tcp_sack_block *sp = &tp->selective_acks[0];\r\n\t\t\tint max_sack = sp[0].end_seq;\r\n\t\t\tint this_sack;\r\n\r\n\t\t\tfor (this_sack = 1; this_sack < tp->rx_opt.num_sacks;\r\n\t\t\t     ++this_sack) {\r\n\t\t\t\tmax_sack = after(sp[this_sack].end_seq,\r\n\t\t\t\t\t\t max_sack) ?\r\n\t\t\t\t\tsp[this_sack].end_seq : max_sack;\r\n\t\t\t}\r\n\r\n\t\t\tif (TCP_SKB_CB(skb)->seq == max_sack)\r\n\t\t\t\tgoto reset;\r\n\t\t}\r\n\r\n\t\t/* Disable TFO if RST is out-of-order\r\n\t\t * and no data has been received\r\n\t\t * for current active TFO socket\r\n\t\t */\r\n\t\tif (tp->syn_fastopen && !tp->data_segs_in &&\r\n\t\t    sk->sk_state == TCP_ESTABLISHED)\r\n\t\t\ttcp_fastopen_active_disable(sk);\r\n\t\ttcp_send_challenge_ack(sk, false);\r\n\t\tSKB_DR_SET(reason, TCP_RESET);\r\n\t\tgoto discard;\r\n\t}\r\n\r\n\t/* step 3: check security and precedence [ignored] */\r\n\r\n\t/* step 4: Check for a SYN\r\n\t * RFC 5961 4.2 : Send a challenge ack\r\n\t */\r\n\tif (th->syn) {\r\n\t\tif (tcp_ecn_mode_accecn(tp)) {\r\n\t\t\taccecn_reflector = true;\r\n\t\t\tif (tp->rx_opt.accecn &&\r\n\t\t\t    tp->saw_accecn_opt < TCP_ACCECN_OPT_COUNTER_SEEN) {\r\n\t\t\t\tu8 saw_opt = tcp_accecn_option_init(skb, tp->rx_opt.accecn);\r\n\r\n\t\t\t\ttcp_accecn_saw_opt_fail_recv(tp, saw_opt);\r\n\t\t\t\ttcp_accecn_opt_demand_min(sk, 1);\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (sk->sk_state == TCP_SYN_RECV && sk->sk_socket && th->ack &&\r\n\t\t    TCP_SKB_CB(skb)->seq + 1 == TCP_SKB_CB(skb)->end_seq &&\r\n\t\t    TCP_SKB_CB(skb)->seq + 1 == tp->rcv_nxt &&\r\n\t\t    TCP_SKB_CB(skb)->ack_seq == tp->snd_nxt)\r\n\t\t\tgoto pass;\r\nsyn_challenge:\r\n\t\tif (syn_inerr)\r\n\t\t\tTCP_INC_STATS(sock_net(sk), TCP_MIB_INERRS);\r\n\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPSYNCHALLENGE);\r\n\t\ttcp_send_challenge_ack(sk, accecn_reflector);\r\n\t\tSKB_DR_SET(reason, TCP_INVALID_SYN);\r\n\t\tgoto discard;\r\n\t}\r\n\r\npass:\r\n\tbpf_skops_parse_hdr(sk, skb);\r\n\r\n\treturn true;\r\n\r\ndiscard:\r\n\ttcp_drop_reason(sk, skb, reason);\r\n\treturn false;\r\n\r\nreset:\r\n\ttcp_reset(sk, skb);\r\n\t__kfree_skb(skb);\r\n\treturn false;\r\n}", ".cp_init_transfer": "void tcp_init_transfer(struct sock *sk, int bpf_op, struct sk_buff *skb)\r\n{\r\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\r\n\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\r\n\ttcp_mtup_init(sk);\r\n\ticsk->icsk_af_ops->rebuild_header(sk);\r\n\ttcp_init_metrics(sk);\r\n\r\n\t/* Initialize the congestion window to start the transfer.\r\n\t * Cut cwnd down to 1 per RFC5681 if SYN or SYN-ACK has been\r\n\t * retransmitted. In light of RFC6298 more aggressive 1sec\r\n\t * initRTO, we only reset cwnd when more than 1 SYN/SYN-ACK\r\n\t * retransmission has occurred.\r\n\t */\r\n\tif (tp->total_retrans > 1 && tp->undo_marker)\r\n\t\ttcp_snd_cwnd_set(tp, 1);\r\n\telse\r\n\t\ttcp_snd_cwnd_set(tp, tcp_init_cwnd(tp, __sk_dst_get(sk)));\r\n\ttp->snd_cwnd_stamp = tcp_jiffies32;\r\n\r\n\tbpf_skops_established(sk, bpf_op, skb);\r\n\t/* Initialize congestion control unless BPF initialized it already: */\r\n\tif (!icsk->icsk_ca_initialized)\r\n\t\ttcp_init_congestion_control(sk);\r\n\ttcp_init_buffer_space(sk);\r\n}", ".cp_measure_rcv_mss": "static void tcp_measure_rcv_mss(struct sock *sk, const struct sk_buff *skb)\r\n{\r\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\r\n\tconst unsigned int lss = icsk->icsk_ack.last_seg_size;\r\n\tunsigned int len;\r\n\r\n\ticsk->icsk_ack.last_seg_size = 0;\r\n\r\n\t/* skb->len may jitter because of SACKs, even if peer\r\n\t * sends good full-sized frames.\r\n\t */\r\n\tlen = skb_shinfo(skb)->gso_size ? : skb->len;\r\n\tif (len >= icsk->icsk_ack.rcv_mss) {\r\n\t\t/* Note: divides are still a bit expensive.\r\n\t\t * For the moment, only adjust scaling_ratio\r\n\t\t * when we update icsk_ack.rcv_mss.\r\n\t\t */\r\n\t\tif (unlikely(len != icsk->icsk_ack.rcv_mss)) {\r\n\t\t\tu64 val = (u64)skb->len << TCP_RMEM_TO_WIN_SCALE;\r\n\t\t\tu8 old_ratio = tcp_sk(sk)->scaling_ratio;\r\n\r\n\t\t\tdo_div(val, skb->truesize);\r\n\t\t\ttcp_sk(sk)->scaling_ratio = val ? val : 1;\r\n\r\n\t\t\tif (old_ratio != tcp_sk(sk)->scaling_ratio) {\r\n\t\t\t\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\r\n\t\t\t\tval = tcp_win_from_space(sk, sk->sk_rcvbuf);\r\n\t\t\t\ttcp_set_window_clamp(sk, val);\r\n\r\n\t\t\t\tif (tp->window_clamp < tp->rcvq_space.space)\r\n\t\t\t\t\ttp->rcvq_space.space = tp->window_clamp;\r\n\t\t\t}\r\n\t\t}\r\n\t\ticsk->icsk_ack.rcv_mss = min_t(unsigned int, len,\r\n\t\t\t\t\t       tcp_sk(sk)->advmss);\r\n\t\t/* Account for possibly-removed options */\r\n\t\tDO_ONCE_LITE_IF(len > icsk->icsk_ack.rcv_mss + MAX_TCP_OPTION_SPACE,\r\n\t\t\t\ttcp_gro_dev_warn, sk, skb, len);\r\n\t\t/* If the skb has a len of exactly 1*MSS and has the PSH bit\r\n\t\t * set then it is likely the end of an application write. So\r\n\t\t * more data may not be arriving soon, and yet the data sender\r\n\t\t * may be waiting for an ACK if cwnd-bound or using TX zero\r\n\t\t * copy. So we set ICSK_ACK_PUSHED here so that\r\n\t\t * tcp_cleanup_rbuf() will send an ACK immediately if the app\r\n\t\t * reads all of the data and is not ping-pong. If len > MSS\r\n\t\t * then this logic does not matter (and does not hurt) because\r\n\t\t * tcp_cleanup_rbuf() will always ACK immediately if the app\r\n\t\t * reads data and there is more than an MSS of unACKed data.\r\n\t\t */\r\n\t\tif (TCP_SKB_CB(skb)->tcp_flags & TCPHDR_PSH)\r\n\t\t\ticsk->icsk_ack.pending |= ICSK_ACK_PUSHED;\r\n\t} else {\r\n\t\t/* Otherwise, we make more careful check taking into account,\r\n\t\t * that SACKs block is variable.\r\n\t\t *\r\n\t\t * \"len\" is invariant segment length, including TCP header.\r\n\t\t */\r\n\t\tlen += skb->data - skb_transport_header(skb);\r\n\t\tif (len >= TCP_MSS_DEFAULT + sizeof(struct tcphdr) ||\r\n\t\t    /* If PSH is not set, packet should be\r\n\t\t     * full sized, provided peer TCP is not badly broken.\r\n\t\t     * This observation (if it is correct 8)) allows\r\n\t\t     * to handle super-low mtu links fairly.\r\n\t\t     */\r\n\t\t    (len >= TCP_MIN_MSS + sizeof(struct tcphdr) &&\r\n\t\t     !(tcp_flag_word(tcp_hdr(skb)) & TCP_REMNANT))) {\r\n\t\t\t/* Subtract also invariant (if peer is RFC compliant),\r\n\t\t\t * tcp header plus fixed timestamp option length.\r\n\t\t\t * Resulting \"len\" is MSS free of SACK jitter.\r\n\t\t\t */\r\n\t\t\tlen -= tcp_sk(sk)->tcp_header_len;\r\n\t\t\ticsk->icsk_ack.last_seg_size = len;\r\n\t\t\tif (len == lss) {\r\n\t\t\t\ticsk->icsk_ack.rcv_mss = len;\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (icsk->icsk_ack.pending & ICSK_ACK_PUSHED)\r\n\t\t\ticsk->icsk_ack.pending |= ICSK_ACK_PUSHED2;\r\n\t\ticsk->icsk_ack.pending |= ICSK_ACK_PUSHED;\r\n\t}\r\n}", ".cp_event_data_recv": "static void tcp_event_data_recv(struct sock *sk, struct sk_buff *skb)\r\n{\r\n\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\r\n\tu32 now;\r\n\r\n\tinet_csk_schedule_ack(sk);\r\n\r\n\ttcp_measure_rcv_mss(sk, skb);\r\n\r\n\ttcp_rcv_rtt_measure(tp);\r\n\r\n\tnow = tcp_jiffies32;\r\n\r\n\tif (!icsk->icsk_ack.ato) {\r\n\t\t/* The _first_ data packet received, initialize\r\n\t\t * delayed ACK engine.\r\n\t\t */\r\n\t\ttcp_incr_quickack(sk, TCP_MAX_QUICKACKS);\r\n\t\ticsk->icsk_ack.ato = TCP_ATO_MIN;\r\n\t} else {\r\n\t\tint m = now - icsk->icsk_ack.lrcvtime;\r\n\r\n\t\tif (m <= TCP_ATO_MIN / 2) {\r\n\t\t\t/* The fastest case is the first. */\r\n\t\t\ticsk->icsk_ack.ato = (icsk->icsk_ack.ato >> 1) + TCP_ATO_MIN / 2;\r\n\t\t} else if (m < icsk->icsk_ack.ato) {\r\n\t\t\ticsk->icsk_ack.ato = (icsk->icsk_ack.ato >> 1) + m;\r\n\t\t\tif (icsk->icsk_ack.ato > icsk->icsk_rto)\r\n\t\t\t\ticsk->icsk_ack.ato = icsk->icsk_rto;\r\n\t\t} else if (m > icsk->icsk_rto) {\r\n\t\t\t/* Too long gap. Apparently sender failed to\r\n\t\t\t * restart window, so that we send ACKs quickly.\r\n\t\t\t */\r\n\t\t\ttcp_incr_quickack(sk, TCP_MAX_QUICKACKS);\r\n\t\t}\r\n\t}\r\n\ticsk->icsk_ack.lrcvtime = now;\r\n\ttcp_save_lrcv_flowlabel(sk, skb);\r\n\r\n\ttcp_data_ecn_check(sk, skb);\r\n\r\n\tif (skb->len >= 128)\r\n\t\ttcp_grow_window(sk, skb, true);\r\n}", ".cp_data_queue_ofo": "static void tcp_data_queue_ofo(struct sock *sk, struct sk_buff *skb)\r\n{\r\n\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\tstruct rb_node **p, *parent;\r\n\tstruct sk_buff *skb1;\r\n\tu32 seq, end_seq;\r\n\tbool fragstolen;\r\n\r\n\ttcp_save_lrcv_flowlabel(sk, skb);\r\n\ttcp_data_ecn_check(sk, skb);\r\n\r\n\tif (unlikely(tcp_try_rmem_schedule(sk, skb, skb->truesize))) {\r\n\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPOFODROP);\r\n\t\tsk->sk_data_ready(sk);\r\n\t\ttcp_drop_reason(sk, skb, SKB_DROP_REASON_PROTO_MEM);\r\n\t\treturn;\r\n\t}\r\n\r\n\ttcp_measure_rcv_mss(sk, skb);\r\n\t/* Disable header prediction. */\r\n\ttp->pred_flags = 0;\r\n\tinet_csk_schedule_ack(sk);\r\n\r\n\ttp->rcv_ooopack += max_t(u16, 1, skb_shinfo(skb)->gso_segs);\r\n\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPOFOQUEUE);\r\n\tseq = TCP_SKB_CB(skb)->seq;\r\n\tend_seq = TCP_SKB_CB(skb)->end_seq;\r\n\r\n\tp = &tp->out_of_order_queue.rb_node;\r\n\tif (RB_EMPTY_ROOT(&tp->out_of_order_queue)) {\r\n\t\t/* Initial out of order segment, build 1 SACK. */\r\n\t\tif (tcp_is_sack(tp)) {\r\n\t\t\ttp->rx_opt.num_sacks = 1;\r\n\t\t\ttp->selective_acks[0].start_seq = seq;\r\n\t\t\ttp->selective_acks[0].end_seq = end_seq;\r\n\t\t}\r\n\t\trb_link_node(&skb->rbnode, NULL, p);\r\n\t\trb_insert_color(&skb->rbnode, &tp->out_of_order_queue);\r\n\t\ttp->ooo_last_skb = skb;\r\n\t\tgoto end;\r\n\t}\r\n\r\n\t/* In the typical case, we are adding an skb to the end of the list.\r\n\t * Use of ooo_last_skb avoids the O(Log(N)) rbtree lookup.\r\n\t */\r\n\tif (tcp_ooo_try_coalesce(sk, tp->ooo_last_skb,\r\n\t\t\t\t skb, &fragstolen)) {\r\ncoalesce_done:\r\n\t\t/* For non sack flows, do not grow window to force DUPACK\r\n\t\t * and trigger fast retransmit.\r\n\t\t */\r\n\t\tif (tcp_is_sack(tp))\r\n\t\t\ttcp_grow_window(sk, skb, true);\r\n\t\tkfree_skb_partial(skb, fragstolen);\r\n\t\tskb = NULL;\r\n\t\tgoto add_sack;\r\n\t}\r\n\t/* Can avoid an rbtree lookup if we are adding skb after ooo_last_skb */\r\n\tif (!before(seq, TCP_SKB_CB(tp->ooo_last_skb)->end_seq)) {\r\n\t\tparent = &tp->ooo_last_skb->rbnode;\r\n\t\tp = &parent->rb_right;\r\n\t\tgoto insert;\r\n\t}\r\n\r\n\t/* Find place to insert this segment. Handle overlaps on the way. */\r\n\tparent = NULL;\r\n\twhile (*p) {\r\n\t\tparent = *p;\r\n\t\tskb1 = rb_to_skb(parent);\r\n\t\tif (before(seq, TCP_SKB_CB(skb1)->seq)) {\r\n\t\t\tp = &parent->rb_left;\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tif (before(seq, TCP_SKB_CB(skb1)->end_seq)) {\r\n\t\t\tif (!after(end_seq, TCP_SKB_CB(skb1)->end_seq)) {\r\n\t\t\t\t/* All the bits are present. Drop. */\r\n\t\t\t\tNET_INC_STATS(sock_net(sk),\r\n\t\t\t\t\t      LINUX_MIB_TCPOFOMERGE);\r\n\t\t\t\ttcp_drop_reason(sk, skb,\r\n\t\t\t\t\t\tSKB_DROP_REASON_TCP_OFOMERGE);\r\n\t\t\t\tskb = NULL;\r\n\t\t\t\ttcp_dsack_set(sk, seq, end_seq);\r\n\t\t\t\tgoto add_sack;\r\n\t\t\t}\r\n\t\t\tif (after(seq, TCP_SKB_CB(skb1)->seq)) {\r\n\t\t\t\t/* Partial overlap. */\r\n\t\t\t\ttcp_dsack_set(sk, seq, TCP_SKB_CB(skb1)->end_seq);\r\n\t\t\t} else {\r\n\t\t\t\t/* skb's seq == skb1's seq and skb covers skb1.\r\n\t\t\t\t * Replace skb1 with skb.\r\n\t\t\t\t */\r\n\t\t\t\trb_replace_node(&skb1->rbnode, &skb->rbnode,\r\n\t\t\t\t\t\t&tp->out_of_order_queue);\r\n\t\t\t\ttcp_dsack_extend(sk,\r\n\t\t\t\t\t\t TCP_SKB_CB(skb1)->seq,\r\n\t\t\t\t\t\t TCP_SKB_CB(skb1)->end_seq);\r\n\t\t\t\tNET_INC_STATS(sock_net(sk),\r\n\t\t\t\t\t      LINUX_MIB_TCPOFOMERGE);\r\n\t\t\t\ttcp_drop_reason(sk, skb1,\r\n\t\t\t\t\t\tSKB_DROP_REASON_TCP_OFOMERGE);\r\n\t\t\t\tgoto merge_right;\r\n\t\t\t}\r\n\t\t} else if (tcp_ooo_try_coalesce(sk, skb1,\r\n\t\t\t\t\t\tskb, &fragstolen)) {\r\n\t\t\tgoto coalesce_done;\r\n\t\t}\r\n\t\tp = &parent->rb_right;\r\n\t}\r\ninsert:\r\n\t/* Insert segment into RB tree. */\r\n\trb_link_node(&skb->rbnode, parent, p);\r\n\trb_insert_color(&skb->rbnode, &tp->out_of_order_queue);\r\n\r\nmerge_right:\r\n\t/* Remove other segments covered by skb. */\r\n\twhile ((skb1 = skb_rb_next(skb)) != NULL) {\r\n\t\tif (!after(end_seq, TCP_SKB_CB(skb1)->seq))\r\n\t\t\tbreak;\r\n\t\tif (before(end_seq, TCP_SKB_CB(skb1)->end_seq)) {\r\n\t\t\ttcp_dsack_extend(sk, TCP_SKB_CB(skb1)->seq,\r\n\t\t\t\t\t end_seq);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\trb_erase(&skb1->rbnode, &tp->out_of_order_queue);\r\n\t\ttcp_dsack_extend(sk, TCP_SKB_CB(skb1)->seq,\r\n\t\t\t\t TCP_SKB_CB(skb1)->end_seq);\r\n\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPOFOMERGE);\r\n\t\ttcp_drop_reason(sk, skb1, SKB_DROP_REASON_TCP_OFOMERGE);\r\n\t}\r\n\t/* If there is no skb after us, we are the last_skb ! */\r\n\tif (!skb1)\r\n\t\ttp->ooo_last_skb = skb;\r\n\r\nadd_sack:\r\n\tif (tcp_is_sack(tp))\r\n\t\ttcp_sack_new_ofo_skb(sk, seq, end_seq);\r\nend:\r\n\tif (skb) {\r\n\t\t/* For non sack flows, do not grow window to force DUPACK\r\n\t\t * and trigger fast retransmit.\r\n\t\t */\r\n\t\tif (tcp_is_sack(tp))\r\n\t\t\ttcp_grow_window(sk, skb, false);\r\n\t\tskb_condense(skb);\r\n\t\tskb_set_owner_r(skb, sk);\r\n\t}\r\n\t/* do not grow rcvbuf for not-yet-accepted or orphaned sockets. */\r\n\tif (sk->sk_socket)\r\n\t\ttcp_rcvbuf_grow(sk);\r\n}", ".cp_enter_quickack_mode": "static void tcp_enter_quickack_mode(struct sock *sk, unsigned int max_quickacks)\r\n{\r\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\r\n\r\n\ttcp_incr_quickack(sk, max_quickacks);\r\n\tinet_csk_exit_pingpong_mode(sk);\r\n\ticsk->icsk_ack.ato = TCP_ATO_MIN;\r\n}", ".cp_data_ecn_check": "static void tcp_data_ecn_check(struct sock *sk, const struct sk_buff *skb)\r\n{\r\n\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\r\n\tif (tcp_ecn_disabled(tp))\r\n\t\treturn;\r\n\r\n\tswitch (TCP_SKB_CB(skb)->ip_dsfield & INET_ECN_MASK) {\r\n\tcase INET_ECN_NOT_ECT:\r\n\t\t/* Funny extension: if ECT is not set on a segment,\r\n\t\t * and we already seen ECT on a previous segment,\r\n\t\t * it is probably a retransmit.\r\n\t\t */\r\n\t\tif (tp->ecn_flags & TCP_ECN_SEEN)\r\n\t\t\ttcp_enter_quickack_mode(sk, 2);\r\n\t\tbreak;\r\n\tcase INET_ECN_CE:\r\n\t\tif (tcp_ca_needs_ecn(sk))\r\n\t\t\ttcp_ca_event(sk, CA_EVENT_ECN_IS_CE);\r\n\r\n\t\tif (!(tp->ecn_flags & TCP_ECN_DEMAND_CWR) &&\r\n\t\t    tcp_ecn_mode_rfc3168(tp)) {\r\n\t\t\t/* Better not delay acks, sender can have a very low cwnd */\r\n\t\t\ttcp_enter_quickack_mode(sk, 2);\r\n\t\t\ttp->ecn_flags |= TCP_ECN_DEMAND_CWR;\r\n\t\t}\r\n\t\t/* As for RFC3168 ECN, the TCP_ECN_SEEN flag is set by\r\n\t\t * tcp_data_ecn_check() when the ECN codepoint of\r\n\t\t * received TCP data contains ECT(0), ECT(1), or CE.\r\n\t\t */\r\n\t\tif (!tcp_ecn_mode_rfc3168(tp))\r\n\t\t\tbreak;\r\n\t\ttp->ecn_flags |= TCP_ECN_SEEN;\r\n\t\tbreak;\r\n\tdefault:\r\n\t\tif (tcp_ca_needs_ecn(sk))\r\n\t\t\ttcp_ca_event(sk, CA_EVENT_ECN_NO_CE);\r\n\t\tif (!tcp_ecn_mode_rfc3168(tp))\r\n\t\t\tbreak;\r\n\t\ttp->ecn_flags |= TCP_ECN_SEEN;\r\n\t\tbreak;\r\n\t}\r\n}", ".cp_send_dupack": "static void tcp_send_dupack(struct sock *sk, const struct sk_buff *skb)\r\n{\r\n\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\r\n\tif (TCP_SKB_CB(skb)->end_seq != TCP_SKB_CB(skb)->seq &&\r\n\t    before(TCP_SKB_CB(skb)->seq, tp->rcv_nxt)) {\r\n\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_DELAYEDACKLOST);\r\n\t\ttcp_enter_quickack_mode(sk, TCP_MAX_QUICKACKS);\r\n\r\n\t\tif (tcp_is_sack(tp) && READ_ONCE(sock_net(sk)->ipv4.sysctl_tcp_dsack)) {\r\n\t\t\tu32 end_seq = TCP_SKB_CB(skb)->end_seq;\r\n\r\n\t\t\ttcp_rcv_spurious_retrans(sk, skb);\r\n\t\t\tif (after(TCP_SKB_CB(skb)->end_seq, tp->rcv_nxt))\r\n\t\t\t\tend_seq = tp->rcv_nxt;\r\n\t\t\ttcp_dsack_set(sk, TCP_SKB_CB(skb)->seq, end_seq);\r\n\t\t}\r\n\t}\r\n\r\n\ttcp_send_ack(sk);\r\n}", ".cp_data_queue": "static void tcp_data_queue(struct sock *sk, struct sk_buff *skb)\r\n{\r\n\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\tenum skb_drop_reason reason;\r\n\tbool fragstolen;\r\n\tint eaten;\r\n\r\n\t/* If a subflow has been reset, the packet should not continue\r\n\t * to be processed, drop the packet.\r\n\t */\r\n\tif (sk_is_mptcp(sk) && !mptcp_incoming_options(sk, skb)) {\r\n\t\t__kfree_skb(skb);\r\n\t\treturn;\r\n\t}\r\n\r\n\tif (TCP_SKB_CB(skb)->seq == TCP_SKB_CB(skb)->end_seq) {\r\n\t\t__kfree_skb(skb);\r\n\t\treturn;\r\n\t}\r\n\ttcp_cleanup_skb(skb);\r\n\t__skb_pull(skb, tcp_hdr(skb)->doff * 4);\r\n\r\n\treason = SKB_DROP_REASON_NOT_SPECIFIED;\r\n\ttp->rx_opt.dsack = 0;\r\n\r\n\t/*  Queue data for delivery to the user.\r\n\t *  Packets in sequence go to the receive queue.\r\n\t *  Out of sequence packets to the out_of_order_queue.\r\n\t */\r\n\tif (TCP_SKB_CB(skb)->seq == tp->rcv_nxt) {\r\n\t\tif (tcp_receive_window(tp) == 0) {\r\n\t\t\t/* Some stacks are known to send bare FIN packets\r\n\t\t\t * in a loop even if we send RWIN 0 in our ACK.\r\n\t\t\t * Accepting this FIN does not hurt memory pressure\r\n\t\t\t * because the FIN flag will simply be merged to the\r\n\t\t\t * receive queue tail skb in most cases.\r\n\t\t\t */\r\n\t\t\tif (!skb->len &&\r\n\t\t\t    (TCP_SKB_CB(skb)->tcp_flags & TCPHDR_FIN))\r\n\t\t\t\tgoto queue_and_out;\r\n\r\n\t\t\treason = SKB_DROP_REASON_TCP_ZEROWINDOW;\r\n\t\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPZEROWINDOWDROP);\r\n\t\t\tgoto out_of_window;\r\n\t\t}\r\n\r\n\t\t/* Ok. In sequence. In window. */\r\nqueue_and_out:\r\n\t\tif (tcp_try_rmem_schedule(sk, skb, skb->truesize)) {\r\n\t\t\t/* TODO: maybe ratelimit these WIN 0 ACK ? */\r\n\t\t\tinet_csk(sk)->icsk_ack.pending |=\r\n\t\t\t\t\t(ICSK_ACK_NOMEM | ICSK_ACK_NOW);\r\n\t\t\tinet_csk_schedule_ack(sk);\r\n\t\t\tsk->sk_data_ready(sk);\r\n\r\n\t\t\tif (skb_queue_len(&sk->sk_receive_queue) && skb->len) {\r\n\t\t\t\treason = SKB_DROP_REASON_PROTO_MEM;\r\n\t\t\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPRCVQDROP);\r\n\t\t\t\tgoto drop;\r\n\t\t\t}\r\n\t\t\tsk_forced_mem_schedule(sk, skb->truesize);\r\n\t\t}\r\n\r\n\t\teaten = tcp_queue_rcv(sk, skb, &fragstolen);\r\n\t\tif (skb->len)\r\n\t\t\ttcp_event_data_recv(sk, skb);\r\n\t\tif (TCP_SKB_CB(skb)->tcp_flags & TCPHDR_FIN)\r\n\t\t\ttcp_fin(sk);\r\n\r\n\t\tif (!RB_EMPTY_ROOT(&tp->out_of_order_queue)) {\r\n\t\t\ttcp_ofo_queue(sk);\r\n\r\n\t\t\t/* RFC5681. 4.2. SHOULD send immediate ACK, when\r\n\t\t\t * gap in queue is filled.\r\n\t\t\t */\r\n\t\t\tif (RB_EMPTY_ROOT(&tp->out_of_order_queue))\r\n\t\t\t\tinet_csk(sk)->icsk_ack.pending |= ICSK_ACK_NOW;\r\n\t\t}\r\n\r\n\t\tif (tp->rx_opt.num_sacks)\r\n\t\t\ttcp_sack_remove(tp);\r\n\r\n\t\ttcp_fast_path_check(sk);\r\n\r\n\t\tif (eaten > 0)\r\n\t\t\tkfree_skb_partial(skb, fragstolen);\r\n\t\tif (!sock_flag(sk, SOCK_DEAD))\r\n\t\t\ttcp_data_ready(sk);\r\n\t\treturn;\r\n\t}\r\n\r\n\tif (!after(TCP_SKB_CB(skb)->end_seq, tp->rcv_nxt)) {\r\n\t\ttcp_rcv_spurious_retrans(sk, skb);\r\n\t\t/* A retransmit, 2nd most common case.  Force an immediate ack. */\r\n\t\treason = SKB_DROP_REASON_TCP_OLD_DATA;\r\n\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_DELAYEDACKLOST);\r\n\t\ttcp_dsack_set(sk, TCP_SKB_CB(skb)->seq, TCP_SKB_CB(skb)->end_seq);\r\n\r\nout_of_window:\r\n\t\ttcp_enter_quickack_mode(sk, TCP_MAX_QUICKACKS);\r\n\t\tinet_csk_schedule_ack(sk);\r\ndrop:\r\n\t\ttcp_drop_reason(sk, skb, reason);\r\n\t\treturn;\r\n\t}\r\n\r\n\t/* Out of window. F.e. zero window probe. */\r\n\tif (!before(TCP_SKB_CB(skb)->seq,\r\n\t\t    tp->rcv_nxt + tcp_receive_window(tp))) {\r\n\t\treason = SKB_DROP_REASON_TCP_OVERWINDOW;\r\n\t\tgoto out_of_window;\r\n\t}\r\n\r\n\tif (before(TCP_SKB_CB(skb)->seq, tp->rcv_nxt)) {\r\n\t\t/* Partial packet, seq < rcv_next < end_seq */\r\n\t\ttcp_dsack_set(sk, TCP_SKB_CB(skb)->seq, tp->rcv_nxt);\r\n\r\n\t\t/* If window is closed, drop tail of packet. But after\r\n\t\t * remembering D-SACK for its head made in previous line.\r\n\t\t */\r\n\t\tif (!tcp_receive_window(tp)) {\r\n\t\t\treason = SKB_DROP_REASON_TCP_ZEROWINDOW;\r\n\t\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPZEROWINDOWDROP);\r\n\t\t\tgoto out_of_window;\r\n\t\t}\r\n\t\tgoto queue_and_out;\r\n\t}\r\n\r\n\ttcp_data_queue_ofo(sk, skb);\r\n}", ".cp_rcv_synsent_state_process": "static int tcp_rcv_synsent_state_process(struct sock *sk, struct sk_buff *skb,\r\n\t\t\t\t\t const struct tcphdr *th)\r\n{\r\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\r\n\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\tstruct tcp_fastopen_cookie foc = { .len = -1 };\r\n\tint saved_clamp = tp->rx_opt.mss_clamp;\r\n\tbool fastopen_fail;\r\n\tSKB_DR(reason);\r\n\r\n\ttcp_parse_options(sock_net(sk), skb, &tp->rx_opt, 0, &foc);\r\n\tif (tp->rx_opt.saw_tstamp && tp->rx_opt.rcv_tsecr)\r\n\t\ttp->rx_opt.rcv_tsecr -= tp->tsoffset;\r\n\r\n\tif (th->ack) {\r\n\t\t/* rfc793:\r\n\t\t * \"If the state is SYN-SENT then\r\n\t\t *    first check the ACK bit\r\n\t\t *      If the ACK bit is set\r\n\t\t *\t  If SEG.ACK =< ISS, or SEG.ACK > SND.NXT, send\r\n\t\t *        a reset (unless the RST bit is set, if so drop\r\n\t\t *        the segment and return)\"\r\n\t\t */\r\n\t\tif (!after(TCP_SKB_CB(skb)->ack_seq, tp->snd_una) ||\r\n\t\t    after(TCP_SKB_CB(skb)->ack_seq, tp->snd_nxt)) {\r\n\t\t\t/* Previous FIN/ACK or RST/ACK might be ignored. */\r\n\t\t\tif (icsk->icsk_retransmits == 0)\r\n\t\t\t\ttcp_reset_xmit_timer(sk, ICSK_TIME_RETRANS,\r\n\t\t\t\t\t\t     TCP_TIMEOUT_MIN, false);\r\n\t\t\tSKB_DR_SET(reason, TCP_INVALID_ACK_SEQUENCE);\r\n\t\t\tgoto reset_and_undo;\r\n\t\t}\r\n\r\n\t\tif (tp->rx_opt.saw_tstamp && tp->rx_opt.rcv_tsecr &&\r\n\t\t    !between(tp->rx_opt.rcv_tsecr, tp->retrans_stamp,\r\n\t\t\t     tcp_time_stamp_ts(tp))) {\r\n\t\t\tNET_INC_STATS(sock_net(sk),\r\n\t\t\t\t\tLINUX_MIB_PAWSACTIVEREJECTED);\r\n\t\t\tSKB_DR_SET(reason, TCP_RFC7323_PAWS);\r\n\t\t\tgoto reset_and_undo;\r\n\t\t}\r\n\r\n\t\t/* Now ACK is acceptable.\r\n\t\t *\r\n\t\t * \"If the RST bit is set\r\n\t\t *    If the ACK was acceptable then signal the user \"error:\r\n\t\t *    connection reset\", drop the segment, enter CLOSED state,\r\n\t\t *    delete TCB, and return.\"\r\n\t\t */\r\n\r\n\t\tif (th->rst) {\r\n\t\t\ttcp_reset(sk, skb);\r\nconsume:\r\n\t\t\t__kfree_skb(skb);\r\n\t\t\treturn 0;\r\n\t\t}\r\n\r\n\t\t/* rfc793:\r\n\t\t *   \"fifth, if neither of the SYN or RST bits is set then\r\n\t\t *    drop the segment and return.\"\r\n\t\t *\r\n\t\t *    See note below!\r\n\t\t *                                        --ANK(990513)\r\n\t\t */\r\n\t\tif (!th->syn) {\r\n\t\t\tSKB_DR_SET(reason, TCP_FLAGS);\r\n\t\t\tgoto discard_and_undo;\r\n\t\t}\r\n\t\t/* rfc793:\r\n\t\t *   \"If the SYN bit is on ...\r\n\t\t *    are acceptable then ...\r\n\t\t *    (our SYN has been ACKed), change the connection\r\n\t\t *    state to ESTABLISHED...\"\r\n\t\t */\r\n\r\n\t\tif (tcp_ecn_mode_any(tp))\r\n\t\t\ttcp_ecn_rcv_synack(sk, skb, th,\r\n\t\t\t\t\t   TCP_SKB_CB(skb)->ip_dsfield);\r\n\r\n\t\ttcp_init_wl(tp, TCP_SKB_CB(skb)->seq);\r\n\t\ttcp_try_undo_spurious_syn(sk);\r\n\t\ttcp_ack(sk, skb, FLAG_SLOWPATH);\r\n\r\n\t\t/* Ok.. it's good. Set up sequence numbers and\r\n\t\t * move to established.\r\n\t\t */\r\n\t\tWRITE_ONCE(tp->rcv_nxt, TCP_SKB_CB(skb)->seq + 1);\r\n\t\ttp->rcv_wup = TCP_SKB_CB(skb)->seq + 1;\r\n\r\n\t\t/* RFC1323: The window in SYN & SYN/ACK segments is\r\n\t\t * never scaled.\r\n\t\t */\r\n\t\ttp->snd_wnd = ntohs(th->window);\r\n\r\n\t\tif (!tp->rx_opt.wscale_ok) {\r\n\t\t\ttp->rx_opt.snd_wscale = tp->rx_opt.rcv_wscale = 0;\r\n\t\t\tWRITE_ONCE(tp->window_clamp,\r\n\t\t\t\t   min(tp->window_clamp, 65535U));\r\n\t\t}\r\n\r\n\t\tif (tp->rx_opt.saw_tstamp) {\r\n\t\t\ttp->rx_opt.tstamp_ok\t   = 1;\r\n\t\t\ttp->tcp_header_len =\r\n\t\t\t\tsizeof(struct tcphdr) + TCPOLEN_TSTAMP_ALIGNED;\r\n\t\t\ttp->advmss\t    -= TCPOLEN_TSTAMP_ALIGNED;\r\n\t\t\ttcp_store_ts_recent(tp);\r\n\t\t} else {\r\n\t\t\ttp->tcp_header_len = sizeof(struct tcphdr);\r\n\t\t}\r\n\r\n\t\ttcp_sync_mss(sk, icsk->icsk_pmtu_cookie);\r\n\t\ttcp_initialize_rcv_mss(sk);\r\n\r\n\t\t/* Remember, tcp_poll() does not lock socket!\r\n\t\t * Change state from SYN-SENT only after copied_seq\r\n\t\t * is initialized. */\r\n\t\tWRITE_ONCE(tp->copied_seq, tp->rcv_nxt);\r\n\r\n\t\tsmc_check_reset_syn(tp);\r\n\r\n\t\tsmp_mb();\r\n\r\n\t\ttcp_finish_connect(sk, skb);\r\n\r\n\t\tfastopen_fail = (tp->syn_fastopen || tp->syn_data) &&\r\n\t\t\t\ttcp_rcv_fastopen_synack(sk, skb, &foc);\r\n\r\n\t\tif (!sock_flag(sk, SOCK_DEAD)) {\r\n\t\t\tsk->sk_state_change(sk);\r\n\t\t\tsk_wake_async(sk, SOCK_WAKE_IO, POLL_OUT);\r\n\t\t}\r\n\t\tif (fastopen_fail)\r\n\t\t\treturn -1;\r\n\t\tif (sk->sk_write_pending ||\r\n\t\t    READ_ONCE(icsk->icsk_accept_queue.rskq_defer_accept) ||\r\n\t\t    inet_csk_in_pingpong_mode(sk)) {\r\n\t\t\t/* Save one ACK. Data will be ready after\r\n\t\t\t * several ticks, if write_pending is set.\r\n\t\t\t *\r\n\t\t\t * It may be deleted, but with this feature tcpdumps\r\n\t\t\t * look so _wonderfully_ clever, that I was not able\r\n\t\t\t * to stand against the temptation 8)     --ANK\r\n\t\t\t */\r\n\t\t\tinet_csk_schedule_ack(sk);\r\n\t\t\ttcp_enter_quickack_mode(sk, TCP_MAX_QUICKACKS);\r\n\t\t\ttcp_reset_xmit_timer(sk, ICSK_TIME_DACK,\r\n\t\t\t\t\t     TCP_DELACK_MAX, false);\r\n\t\t\tgoto consume;\r\n\t\t}\r\n\t\ttcp_send_ack_reflect_ect(sk, tcp_ecn_mode_accecn(tp));\r\n\t\treturn -1;\r\n\t}\r\n\r\n\t/* No ACK in the segment */\r\n\r\n\tif (th->rst) {\r\n\t\t/* rfc793:\r\n\t\t * \"If the RST bit is set\r\n\t\t *\r\n\t\t *      Otherwise (no ACK) drop the segment and return.\"\r\n\t\t */\r\n\t\tSKB_DR_SET(reason, TCP_RESET);\r\n\t\tgoto discard_and_undo;\r\n\t}\r\n\r\n\t/* PAWS check. */\r\n\tif (tp->rx_opt.ts_recent_stamp && tp->rx_opt.saw_tstamp &&\r\n\t    tcp_paws_reject(&tp->rx_opt, 0)) {\r\n\t\tSKB_DR_SET(reason, TCP_RFC7323_PAWS);\r\n\t\tgoto discard_and_undo;\r\n\t}\r\n\tif (th->syn) {\r\n\t\t/* We see SYN without ACK. It is attempt of\r\n\t\t * simultaneous connect with crossed SYNs.\r\n\t\t * Particularly, it can be connect to self.\r\n\t\t */\r\n#ifdef CONFIG_TCP_AO\r\n\t\tstruct tcp_ao_info *ao;\r\n\r\n\t\tao = rcu_dereference_protected(tp->ao_info,\r\n\t\t\t\t\t       lockdep_sock_is_held(sk));\r\n\t\tif (ao) {\r\n\t\t\tWRITE_ONCE(ao->risn, th->seq);\r\n\t\t\tao->rcv_sne = 0;\r\n\t\t}\r\n#endif\r\n\t\ttcp_set_state(sk, TCP_SYN_RECV);\r\n\r\n\t\tif (tp->rx_opt.saw_tstamp) {\r\n\t\t\ttp->rx_opt.tstamp_ok = 1;\r\n\t\t\ttcp_store_ts_recent(tp);\r\n\t\t\ttp->tcp_header_len =\r\n\t\t\t\tsizeof(struct tcphdr) + TCPOLEN_TSTAMP_ALIGNED;\r\n\t\t} else {\r\n\t\t\ttp->tcp_header_len = sizeof(struct tcphdr);\r\n\t\t}\r\n\r\n\t\tWRITE_ONCE(tp->rcv_nxt, TCP_SKB_CB(skb)->seq + 1);\r\n\t\tWRITE_ONCE(tp->copied_seq, tp->rcv_nxt);\r\n\t\ttp->rcv_wup = TCP_SKB_CB(skb)->seq + 1;\r\n\r\n\t\t/* RFC1323: The window in SYN & SYN/ACK segments is\r\n\t\t * never scaled.\r\n\t\t */\r\n\t\ttp->snd_wnd    = ntohs(th->window);\r\n\t\ttp->snd_wl1    = TCP_SKB_CB(skb)->seq;\r\n\t\ttp->max_window = tp->snd_wnd;\r\n\r\n\t\ttcp_ecn_rcv_syn(tp, th, skb);\r\n\r\n\t\ttcp_mtup_init(sk);\r\n\t\ttcp_sync_mss(sk, icsk->icsk_pmtu_cookie);\r\n\t\ttcp_initialize_rcv_mss(sk);\r\n\r\n\t\ttcp_send_synack(sk);\r\n#if 0\r\n\t\t/* Note, we could accept data and URG from this segment.\r\n\t\t * There are no obstacles to make this (except that we must\r\n\t\t * either change tcp_recvmsg() to prevent it from returning data\r\n\t\t * before 3WHS completes per RFC793, or employ TCP Fast Open).\r\n\t\t *\r\n\t\t * However, if we ignore data in ACKless segments sometimes,\r\n\t\t * we have no reasons to accept it sometimes.\r\n\t\t * Also, seems the code doing it in step6 of tcp_rcv_state_process\r\n\t\t * is not flawless. So, discard packet for sanity.\r\n\t\t * Uncomment this return to process the data.\r\n\t\t */\r\n\t\treturn -1;\r\n#else\r\n\t\tgoto consume;\r\n#endif\r\n\t}\r\n\t/* \"fifth, if neither of the SYN or RST bits is set then\r\n\t * drop the segment and return.\"\r\n\t */\r\n\r\ndiscard_and_undo:\r\n\ttcp_clear_options(&tp->rx_opt);\r\n\ttp->rx_opt.mss_clamp = saved_clamp;\r\n\ttcp_drop_reason(sk, skb, reason);\r\n\treturn 0;\r\n\r\nreset_and_undo:\r\n\ttcp_clear_options(&tp->rx_opt);\r\n\ttp->rx_opt.mss_clamp = saved_clamp;\r\n\t/* we can reuse/return @reason to its caller to handle the exception */\r\n\treturn reason;\r\n}", ".cp_count_delivered": "static void tcp_count_delivered(struct tcp_sock *tp, u32 delivered,\r\n\t\t\t\tbool ece_ack)\r\n{\r\n\ttp->delivered += delivered;\r\n\tif (tcp_ecn_mode_rfc3168(tp) && ece_ack)\r\n\t\ttcp_count_delivered_ce(tp, delivered);\r\n}", ".cp_accecn_process": "static u32 tcp_accecn_process(struct sock *sk, const struct sk_buff *skb,\r\n\t\t\t      u32 delivered_pkts, u32 delivered_bytes,\r\n\t\t\t      int *flag)\r\n{\r\n\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\tu32 delta;\r\n\r\n\tdelta = __tcp_accecn_process(sk, skb, delivered_pkts,\r\n\t\t\t\t     delivered_bytes, *flag);\r\n\tif (delta > 0) {\r\n\t\ttcp_count_delivered_ce(tp, delta);\r\n\t\t*flag |= FLAG_ECE;\r\n\t\t/* Recalculate header predictor */\r\n\t\tif (tp->pred_flags)\r\n\t\t\ttcp_fast_path_on(tp);\r\n\t}\r\n\treturn delta;\r\n}", ".cp_add_reno_sack": "static void tcp_add_reno_sack(struct sock *sk, int num_dupack, bool ece_ack)\r\n{\r\n\tif (num_dupack) {\r\n\t\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\t\tu32 prior_sacked = tp->sacked_out;\r\n\t\ts32 delivered;\r\n\r\n\t\ttp->sacked_out += num_dupack;\r\n\t\ttcp_check_reno_reordering(sk, 0);\r\n\t\tdelivered = tp->sacked_out - prior_sacked;\r\n\t\tif (delivered > 0)\r\n\t\t\ttcp_count_delivered(tp, delivered, ece_ack);\r\n\t\ttcp_verify_left_out(tp);\r\n\t}\r\n}", ".cp_remove_reno_sacks": "static void tcp_remove_reno_sacks(struct sock *sk, int acked, bool ece_ack)\r\n{\r\n\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\r\n\tif (acked > 0) {\r\n\t\t/* One ACK acked hole. The rest eat duplicate ACKs. */\r\n\t\ttcp_count_delivered(tp, max_t(int, acked - tp->sacked_out, 1),\r\n\t\t\t\t    ece_ack);\r\n\t\tif (acked - 1 >= tp->sacked_out)\r\n\t\t\ttp->sacked_out = 0;\r\n\t\telse\r\n\t\t\ttp->sacked_out -= acked - 1;\r\n\t}\r\n\ttcp_check_reno_reordering(sk, acked);\r\n\ttcp_verify_left_out(tp);\r\n}", ".cp_clean_rtx_queue": "static int tcp_clean_rtx_queue(struct sock *sk, const struct sk_buff *ack_skb,\r\n\t\t\t       u32 prior_fack, u32 prior_snd_una,\r\n\t\t\t       struct tcp_sacktag_state *sack, bool ece_ack)\r\n{\r\n\tconst struct inet_connection_sock *icsk = inet_csk(sk);\r\n\tu64 first_ackt, last_ackt;\r\n\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\tu32 prior_sacked = tp->sacked_out;\r\n\tu32 reord = tp->snd_nxt; /* lowest acked un-retx un-sacked seq */\r\n\tstruct sk_buff *skb, *next;\r\n\tbool fully_acked = true;\r\n\tlong sack_rtt_us = -1L;\r\n\tlong seq_rtt_us = -1L;\r\n\tlong ca_rtt_us = -1L;\r\n\tu32 pkts_acked = 0;\r\n\tbool rtt_update;\r\n\tint flag = 0;\r\n\r\n\tfirst_ackt = 0;\r\n\r\n\tfor (skb = skb_rb_first(&sk->tcp_rtx_queue); skb; skb = next) {\r\n\t\tstruct tcp_skb_cb *scb = TCP_SKB_CB(skb);\r\n\t\tconst u32 start_seq = scb->seq;\r\n\t\tu8 sacked = scb->sacked;\r\n\t\tu32 acked_pcount;\r\n\r\n\t\t/* Determine how many packets and what bytes were acked, tso and else */\r\n\t\tif (after(scb->end_seq, tp->snd_una)) {\r\n\t\t\tif (tcp_skb_pcount(skb) == 1 ||\r\n\t\t\t    !after(tp->snd_una, scb->seq))\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tacked_pcount = tcp_tso_acked(sk, skb);\r\n\t\t\tif (!acked_pcount)\r\n\t\t\t\tbreak;\r\n\t\t\tfully_acked = false;\r\n\t\t} else {\r\n\t\t\tacked_pcount = tcp_skb_pcount(skb);\r\n\t\t}\r\n\r\n\t\tif (unlikely(sacked & TCPCB_RETRANS)) {\r\n\t\t\tif (sacked & TCPCB_SACKED_RETRANS)\r\n\t\t\t\ttp->retrans_out -= acked_pcount;\r\n\t\t\tflag |= FLAG_RETRANS_DATA_ACKED;\r\n\t\t} else if (!(sacked & TCPCB_SACKED_ACKED)) {\r\n\t\t\tlast_ackt = tcp_skb_timestamp_us(skb);\r\n\t\t\tWARN_ON_ONCE(last_ackt == 0);\r\n\t\t\tif (!first_ackt)\r\n\t\t\t\tfirst_ackt = last_ackt;\r\n\r\n\t\t\tif (before(start_seq, reord))\r\n\t\t\t\treord = start_seq;\r\n\t\t\tif (!after(scb->end_seq, tp->high_seq))\r\n\t\t\t\tflag |= FLAG_ORIG_SACK_ACKED;\r\n\t\t}\r\n\r\n\t\tif (sacked & TCPCB_SACKED_ACKED) {\r\n\t\t\ttp->sacked_out -= acked_pcount;\r\n\t\t\t/* snd_una delta covers these skbs */\r\n\t\t\tsack->delivered_bytes -= skb->len;\r\n\t\t} else if (tcp_is_sack(tp)) {\r\n\t\t\ttcp_count_delivered(tp, acked_pcount, ece_ack);\r\n\t\t\tif (!tcp_skb_spurious_retrans(tp, skb))\r\n\t\t\t\ttcp_rack_advance(tp, sacked, scb->end_seq,\r\n\t\t\t\t\t\t tcp_skb_timestamp_us(skb));\r\n\t\t}\r\n\t\tif (sacked & TCPCB_LOST)\r\n\t\t\ttp->lost_out -= acked_pcount;\r\n\r\n\t\ttp->packets_out -= acked_pcount;\r\n\t\tpkts_acked += acked_pcount;\r\n\t\ttcp_rate_skb_delivered(sk, skb, sack->rate);\r\n\r\n\t\t/* Initial outgoing SYN's get put onto the write_queue\r\n\t\t * just like anything else we transmit.  It is not\r\n\t\t * true data, and if we misinform our callers that\r\n\t\t * this ACK acks real data, we will erroneously exit\r\n\t\t * connection startup slow start one packet too\r\n\t\t * quickly.  This is severely frowned upon behavior.\r\n\t\t */\r\n\t\tif (likely(!(scb->tcp_flags & TCPHDR_SYN))) {\r\n\t\t\tflag |= FLAG_DATA_ACKED;\r\n\t\t} else {\r\n\t\t\tflag |= FLAG_SYN_ACKED;\r\n\t\t\ttp->retrans_stamp = 0;\r\n\t\t}\r\n\r\n\t\tif (!fully_acked)\r\n\t\t\tbreak;\r\n\r\n\t\ttcp_ack_tstamp(sk, skb, ack_skb, prior_snd_una);\r\n\r\n\t\tnext = skb_rb_next(skb);\r\n\t\tif (unlikely(skb == tp->retransmit_skb_hint))\r\n\t\t\ttp->retransmit_skb_hint = NULL;\r\n\t\ttcp_highest_sack_replace(sk, skb, next);\r\n\t\ttcp_rtx_queue_unlink_and_free(skb, sk);\r\n\t}\r\n\r\n\tif (!skb)\r\n\t\ttcp_chrono_stop(sk, TCP_CHRONO_BUSY);\r\n\r\n\tif (likely(between(tp->snd_up, prior_snd_una, tp->snd_una)))\r\n\t\ttp->snd_up = tp->snd_una;\r\n\r\n\tif (skb) {\r\n\t\ttcp_ack_tstamp(sk, skb, ack_skb, prior_snd_una);\r\n\t\tif (TCP_SKB_CB(skb)->sacked & TCPCB_SACKED_ACKED)\r\n\t\t\tflag |= FLAG_SACK_RENEGING;\r\n\t}\r\n\r\n\tif (likely(first_ackt) && !(flag & FLAG_RETRANS_DATA_ACKED)) {\r\n\t\tseq_rtt_us = tcp_stamp_us_delta(tp->tcp_mstamp, first_ackt);\r\n\t\tca_rtt_us = tcp_stamp_us_delta(tp->tcp_mstamp, last_ackt);\r\n\r\n\t\tif (pkts_acked == 1 && fully_acked && !prior_sacked &&\r\n\t\t    (tp->snd_una - prior_snd_una) < tp->mss_cache &&\r\n\t\t    sack->rate->prior_delivered + 1 == tp->delivered &&\r\n\t\t    !(flag & (FLAG_CA_ALERT | FLAG_SYN_ACKED))) {\r\n\t\t\t/* Conservatively mark a delayed ACK. It's typically\r\n\t\t\t * from a lone runt packet over the round trip to\r\n\t\t\t * a receiver w/o out-of-order or CE events.\r\n\t\t\t */\r\n\t\t\tflag |= FLAG_ACK_MAYBE_DELAYED;\r\n\t\t}\r\n\t}\r\n\tif (sack->first_sackt) {\r\n\t\tsack_rtt_us = tcp_stamp_us_delta(tp->tcp_mstamp, sack->first_sackt);\r\n\t\tca_rtt_us = tcp_stamp_us_delta(tp->tcp_mstamp, sack->last_sackt);\r\n\t}\r\n\trtt_update = tcp_ack_update_rtt(sk, flag, seq_rtt_us, sack_rtt_us,\r\n\t\t\t\t\tca_rtt_us, sack->rate);\r\n\r\n\tif (flag & FLAG_ACKED) {\r\n\t\tflag |= FLAG_SET_XMIT_TIMER;  /* set TLP or RTO timer */\r\n\t\tif (unlikely(icsk->icsk_mtup.probe_size &&\r\n\t\t\t     !after(tp->mtu_probe.probe_seq_end, tp->snd_una))) {\r\n\t\t\ttcp_mtup_probe_success(sk);\r\n\t\t}\r\n\r\n\t\tif (tcp_is_reno(tp)) {\r\n\t\t\ttcp_remove_reno_sacks(sk, pkts_acked, ece_ack);\r\n\r\n\t\t\t/* If any of the cumulatively ACKed segments was\r\n\t\t\t * retransmitted, non-SACK case cannot confirm that\r\n\t\t\t * progress was due to original transmission due to\r\n\t\t\t * lack of TCPCB_SACKED_ACKED bits even if some of\r\n\t\t\t * the packets may have been never retransmitted.\r\n\t\t\t */\r\n\t\t\tif (flag & FLAG_RETRANS_DATA_ACKED)\r\n\t\t\t\tflag &= ~FLAG_ORIG_SACK_ACKED;\r\n\t\t} else {\r\n\t\t\t/* Non-retransmitted hole got filled? That's reordering */\r\n\t\t\tif (before(reord, prior_fack))\r\n\t\t\t\ttcp_check_sack_reordering(sk, reord, 0);\r\n\t\t}\r\n\r\n\t\tsack->delivered_bytes = (skb ?\r\n\t\t\t\t\t TCP_SKB_CB(skb)->seq : tp->snd_una) -\r\n\t\t\t\t\t prior_snd_una;\r\n\t} else if (skb && rtt_update && sack_rtt_us >= 0 &&\r\n\t\t   sack_rtt_us > tcp_stamp_us_delta(tp->tcp_mstamp,\r\n\t\t\t\t\t\t    tcp_skb_timestamp_us(skb))) {\r\n\t\t/* Do not re-arm RTO if the sack RTT is measured from data sent\r\n\t\t * after when the head was last (re)transmitted. Otherwise the\r\n\t\t * timeout may continue to extend in loss recovery.\r\n\t\t */\r\n\t\tflag |= FLAG_SET_XMIT_TIMER;  /* set TLP or RTO timer */\r\n\t}\r\n\r\n\tif (icsk->icsk_ca_ops->pkts_acked) {\r\n\t\tstruct ack_sample sample = { .pkts_acked = pkts_acked,\r\n\t\t\t\t\t     .rtt_us = sack->rate->rtt_us };\r\n\r\n\t\tsample.in_flight = tp->mss_cache *\r\n\t\t\t(tp->delivered - sack->rate->prior_delivered);\r\n\t\ticsk->icsk_ca_ops->pkts_acked(sk, &sample);\r\n\t}\r\n\r\n#if FASTRETRANS_DEBUG > 0\r\n\tWARN_ON((int)tp->sacked_out < 0);\r\n\tWARN_ON((int)tp->lost_out < 0);\r\n\tWARN_ON((int)tp->retrans_out < 0);\r\n\tif (!tp->packets_out && tcp_is_sack(tp)) {\r\n\t\ticsk = inet_csk(sk);\r\n\t\tif (tp->lost_out) {\r\n\t\t\tpr_debug(\"Leak l=%u %d\\n\",\r\n\t\t\t\t tp->lost_out, icsk->icsk_ca_state);\r\n\t\t\ttp->lost_out = 0;\r\n\t\t}\r\n\t\tif (tp->sacked_out) {\r\n\t\t\tpr_debug(\"Leak s=%u %d\\n\",\r\n\t\t\t\t tp->sacked_out, icsk->icsk_ca_state);\r\n\t\t\ttp->sacked_out = 0;\r\n\t\t}\r\n\t\tif (tp->retrans_out) {\r\n\t\t\tpr_debug(\"Leak r=%u %d\\n\",\r\n\t\t\t\t tp->retrans_out, icsk->icsk_ca_state);\r\n\t\t\ttp->retrans_out = 0;\r\n\t\t}\r\n\t}\r\n#endif\r\n\treturn flag;\r\n}", ".cp_ack": "static int tcp_ack(struct sock *sk, const struct sk_buff *skb, int flag)\r\n{\r\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\r\n\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\tstruct tcp_sacktag_state sack_state;\r\n\tstruct rate_sample rs = { .prior_delivered = 0 };\r\n\tu32 prior_snd_una = tp->snd_una;\r\n\tbool is_sack_reneg = tp->is_sack_reneg;\r\n\tu32 ack_seq = TCP_SKB_CB(skb)->seq;\r\n\tu32 ack = TCP_SKB_CB(skb)->ack_seq;\r\n\tint num_dupack = 0;\r\n\tint prior_packets = tp->packets_out;\r\n\tu32 delivered = tp->delivered;\r\n\tu32 lost = tp->lost;\r\n\tint rexmit = REXMIT_NONE; /* Flag to (re)transmit to recover losses */\r\n\tu32 ecn_count = 0;\t  /* Did we receive ECE/an AccECN ACE update? */\r\n\tu32 prior_fack;\r\n\r\n\tsack_state.first_sackt = 0;\r\n\tsack_state.rate = &rs;\r\n\tsack_state.sack_delivered = 0;\r\n\tsack_state.delivered_bytes = 0;\r\n\r\n\t/* We very likely will need to access rtx queue. */\r\n\tprefetch(sk->tcp_rtx_queue.rb_node);\r\n\r\n\t/* If the ack is older than previous acks\r\n\t * then we can probably ignore it.\r\n\t */\r\n\tif (before(ack, prior_snd_una)) {\r\n\t\tu32 max_window;\r\n\r\n\t\t/* do not accept ACK for bytes we never sent. */\r\n\t\tmax_window = min_t(u64, tp->max_window, tp->bytes_acked);\r\n\t\t/* RFC 5961 5.2 [Blind Data Injection Attack].[Mitigation] */\r\n\t\tif (before(ack, prior_snd_una - max_window)) {\r\n\t\t\tif (!(flag & FLAG_NO_CHALLENGE_ACK))\r\n\t\t\t\ttcp_send_challenge_ack(sk, false);\r\n\t\t\treturn -SKB_DROP_REASON_TCP_TOO_OLD_ACK;\r\n\t\t}\r\n\t\tgoto old_ack;\r\n\t}\r\n\r\n\t/* If the ack includes data we haven't sent yet, discard\r\n\t * this segment (RFC793 Section 3.9).\r\n\t */\r\n\tif (after(ack, tp->snd_nxt))\r\n\t\treturn -SKB_DROP_REASON_TCP_ACK_UNSENT_DATA;\r\n\r\n\tif (after(ack, prior_snd_una)) {\r\n\t\tflag |= FLAG_SND_UNA_ADVANCED;\r\n\t\tWRITE_ONCE(icsk->icsk_retransmits, 0);\r\n\r\n#if IS_ENABLED(CONFIG_TLS_DEVICE)\r\n\t\tif (static_branch_unlikely(&clean_acked_data_enabled.key))\r\n\t\t\tif (tp->tcp_clean_acked)\r\n\t\t\t\ttp->tcp_clean_acked(sk, ack);\r\n#endif\r\n\t}\r\n\r\n\tprior_fack = tcp_is_sack(tp) ? tcp_highest_sack_seq(tp) : tp->snd_una;\r\n\trs.prior_in_flight = tcp_packets_in_flight(tp);\r\n\r\n\t/* ts_recent update must be made after we are sure that the packet\r\n\t * is in window.\r\n\t */\r\n\tif (flag & FLAG_UPDATE_TS_RECENT)\r\n\t\tflag |= tcp_replace_ts_recent(tp, TCP_SKB_CB(skb)->seq);\r\n\r\n\tif ((flag & (FLAG_SLOWPATH | FLAG_SND_UNA_ADVANCED)) ==\r\n\t    FLAG_SND_UNA_ADVANCED) {\r\n\t\t/* Window is constant, pure forward advance.\r\n\t\t * No more checks are required.\r\n\t\t * Note, we use the fact that SND.UNA>=SND.WL2.\r\n\t\t */\r\n\t\ttcp_update_wl(tp, ack_seq);\r\n\t\ttcp_snd_una_update(tp, ack);\r\n\t\tflag |= FLAG_WIN_UPDATE;\r\n\r\n\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPHPACKS);\r\n\t} else {\r\n\t\tif (ack_seq != TCP_SKB_CB(skb)->end_seq)\r\n\t\t\tflag |= FLAG_DATA;\r\n\t\telse\r\n\t\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPPUREACKS);\r\n\r\n\t\tflag |= tcp_ack_update_window(sk, skb, ack, ack_seq);\r\n\r\n\t\tif (TCP_SKB_CB(skb)->sacked)\r\n\t\t\tflag |= tcp_sacktag_write_queue(sk, skb, prior_snd_una,\r\n\t\t\t\t\t\t\t&sack_state);\r\n\r\n\t\tif (tcp_ecn_rcv_ecn_echo(tp, tcp_hdr(skb)))\r\n\t\t\tflag |= FLAG_ECE;\r\n\r\n\t\tif (sack_state.sack_delivered)\r\n\t\t\ttcp_count_delivered(tp, sack_state.sack_delivered,\r\n\t\t\t\t\t    flag & FLAG_ECE);\r\n\t}\r\n\r\n\t/* This is a deviation from RFC3168 since it states that:\r\n\t * \"When the TCP data sender is ready to set the CWR bit after reducing\r\n\t * the congestion window, it SHOULD set the CWR bit only on the first\r\n\t * new data packet that it transmits.\"\r\n\t * We accept CWR on pure ACKs to be more robust\r\n\t * with widely-deployed TCP implementations that do this.\r\n\t */\r\n\ttcp_ecn_accept_cwr(sk, skb);\r\n\r\n\t/* We passed data and got it acked, remove any soft error\r\n\t * log. Something worked...\r\n\t */\r\n\tif (READ_ONCE(sk->sk_err_soft))\r\n\t\tWRITE_ONCE(sk->sk_err_soft, 0);\r\n\tWRITE_ONCE(icsk->icsk_probes_out, 0);\r\n\ttp->rcv_tstamp = tcp_jiffies32;\r\n\tif (!prior_packets)\r\n\t\tgoto no_queue;\r\n\r\n\t/* See if we can take anything off of the retransmit queue. */\r\n\tflag |= tcp_clean_rtx_queue(sk, skb, prior_fack, prior_snd_una,\r\n\t\t\t\t    &sack_state, flag & FLAG_ECE);\r\n\r\n\ttcp_rack_update_reo_wnd(sk, &rs);\r\n\r\n\tif (tcp_ecn_mode_accecn(tp))\r\n\t\tecn_count = tcp_accecn_process(sk, skb,\r\n\t\t\t\t\t       tp->delivered - delivered,\r\n\t\t\t\t\t       sack_state.delivered_bytes,\r\n\t\t\t\t\t       &flag);\r\n\r\n\ttcp_in_ack_event(sk, flag);\r\n\r\n\tif (tp->tlp_high_seq)\r\n\t\ttcp_process_tlp_ack(sk, ack, flag);\r\n\r\n\tif (tcp_ack_is_dubious(sk, flag)) {\r\n\t\tif (!(flag & (FLAG_SND_UNA_ADVANCED |\r\n\t\t\t      FLAG_NOT_DUP | FLAG_DSACKING_ACK))) {\r\n\t\t\tnum_dupack = 1;\r\n\t\t\t/* Consider if pure acks were aggregated in tcp_add_backlog() */\r\n\t\t\tif (!(flag & FLAG_DATA))\r\n\t\t\t\tnum_dupack = max_t(u16, 1, skb_shinfo(skb)->gso_segs);\r\n\t\t}\r\n\t\ttcp_fastretrans_alert(sk, prior_snd_una, num_dupack, &flag,\r\n\t\t\t\t      &rexmit);\r\n\t}\r\n\r\n\t/* If needed, reset TLP/RTO timer when RACK doesn't set. */\r\n\tif (flag & FLAG_SET_XMIT_TIMER)\r\n\t\ttcp_set_xmit_timer(sk);\r\n\r\n\tif ((flag & FLAG_FORWARD_PROGRESS) || !(flag & FLAG_NOT_DUP))\r\n\t\tsk_dst_confirm(sk);\r\n\r\n\tdelivered = tcp_newly_delivered(sk, delivered, ecn_count, flag);\r\n\r\n\tlost = tp->lost - lost;\t\t\t/* freshly marked lost */\r\n\trs.is_ack_delayed = !!(flag & FLAG_ACK_MAYBE_DELAYED);\r\n\ttcp_rate_gen(sk, delivered, lost, is_sack_reneg, sack_state.rate);\r\n\ttcp_cong_control(sk, ack, delivered, flag, sack_state.rate);\r\n\ttcp_xmit_recovery(sk, rexmit);\r\n\treturn 1;\r\n\r\nno_queue:\r\n\tif (tcp_ecn_mode_accecn(tp))\r\n\t\tecn_count = tcp_accecn_process(sk, skb,\r\n\t\t\t\t\t       tp->delivered - delivered,\r\n\t\t\t\t\t       sack_state.delivered_bytes,\r\n\t\t\t\t\t       &flag);\r\n\ttcp_in_ack_event(sk, flag);\r\n\t/* If data was DSACKed, see if we can undo a cwnd reduction. */\r\n\tif (flag & FLAG_DSACKING_ACK) {\r\n\t\ttcp_fastretrans_alert(sk, prior_snd_una, num_dupack, &flag,\r\n\t\t\t\t      &rexmit);\r\n\t\ttcp_newly_delivered(sk, delivered, ecn_count, flag);\r\n\t}\r\n\t/* If this ack opens up a zero window, clear backoff.  It was\r\n\t * being used to time the probes, and is probably far higher than\r\n\t * it needs to be for normal retransmission.\r\n\t */\r\n\ttcp_ack_probe(sk);\r\n\r\n\tif (tp->tlp_high_seq)\r\n\t\ttcp_process_tlp_ack(sk, ack, flag);\r\n\treturn 1;\r\n\r\nold_ack:\r\n\t/* If data was SACKed, tag it and see if we should send more data.\r\n\t * If data was DSACKed, see if we can undo a cwnd reduction.\r\n\t */\r\n\tif (TCP_SKB_CB(skb)->sacked) {\r\n\t\tflag |= tcp_sacktag_write_queue(sk, skb, prior_snd_una,\r\n\t\t\t\t\t\t&sack_state);\r\n\t\ttcp_fastretrans_alert(sk, prior_snd_una, num_dupack, &flag,\r\n\t\t\t\t      &rexmit);\r\n\t\ttcp_newly_delivered(sk, delivered, ecn_count, flag);\r\n\t\ttcp_xmit_recovery(sk, rexmit);\r\n\t}\r\n\r\n\treturn 0;\r\n}", ".cp_init_buffer_space": "static void tcp_init_buffer_space(struct sock *sk)\r\n{\r\n\tint tcp_app_win = READ_ONCE(sock_net(sk)->ipv4.sysctl_tcp_app_win);\r\n\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\tint maxwin;\r\n\r\n\tif (!(sk->sk_userlocks & SOCK_SNDBUF_LOCK))\r\n\t\ttcp_sndbuf_expand(sk);\r\n\r\n\ttcp_mstamp_refresh(tp);\r\n\ttp->rcvq_space.time = tp->tcp_mstamp;\r\n\ttp->rcvq_space.seq = tp->copied_seq;\r\n\r\n\tmaxwin = tcp_full_space(sk);\r\n\r\n\tif (tp->window_clamp >= maxwin) {\r\n\t\tWRITE_ONCE(tp->window_clamp, maxwin);\r\n\r\n\t\tif (tcp_app_win && maxwin > 4 * tp->advmss)\r\n\t\t\tWRITE_ONCE(tp->window_clamp,\r\n\t\t\t\t   max(maxwin - (maxwin >> tcp_app_win),\r\n\t\t\t\t       4 * tp->advmss));\r\n\t}\r\n\r\n\t/* Force reservation of one segment. */\r\n\tif (tcp_app_win &&\r\n\t    tp->window_clamp > 2 * tp->advmss &&\r\n\t    tp->window_clamp + tp->advmss > maxwin)\r\n\t\tWRITE_ONCE(tp->window_clamp,\r\n\t\t\t   max(2 * tp->advmss, maxwin - tp->advmss));\r\n\r\n\ttp->rcv_ssthresh = min(tp->rcv_ssthresh, tp->window_clamp);\r\n\ttp->snd_cwnd_stamp = tcp_jiffies32;\r\n\ttp->rcvq_space.space = min3(tp->rcv_ssthresh, tp->rcv_wnd,\r\n\t\t\t\t    (u32)TCP_INIT_CWND * tp->advmss);\r\n}", ".cp_new_space": "static void tcp_new_space(struct sock *sk)\r\n{\r\n\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\r\n\tif (tcp_should_expand_sndbuf(sk)) {\r\n\t\ttcp_sndbuf_expand(sk);\r\n\t\ttp->snd_cwnd_stamp = tcp_jiffies32;\r\n\t}\r\n\r\n\tINDIRECT_CALL_1(sk->sk_write_space, sk_stream_write_space, sk);\r\n}", ".cp_grow_window": "static void tcp_grow_window(struct sock *sk, const struct sk_buff *skb,\r\n\t\t\t    bool adjust)\r\n{\r\n\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\tint room;\r\n\r\n\troom = min_t(int, tp->window_clamp, tcp_space(sk)) - tp->rcv_ssthresh;\r\n\r\n\tif (room <= 0)\r\n\t\treturn;\r\n\r\n\t/* Check #1 */\r\n\tif (!tcp_under_memory_pressure(sk)) {\r\n\t\tunsigned int truesize = truesize_adjust(adjust, skb);\r\n\t\tint incr;\r\n\r\n\t\t/* Check #2. Increase window, if skb with such overhead\r\n\t\t * will fit to rcvbuf in future.\r\n\t\t */\r\n\t\tif (tcp_win_from_space(sk, truesize) <= skb->len)\r\n\t\t\tincr = 2 * tp->advmss;\r\n\t\telse\r\n\t\t\tincr = __tcp_grow_window(sk, skb, truesize);\r\n\r\n\t\tif (incr) {\r\n\t\t\tincr = max_t(int, incr, 2 * skb->len);\r\n\t\t\ttp->rcv_ssthresh += min(room, incr);\r\n\t\t\tinet_csk(sk)->icsk_ack.quick |= 1;\r\n\t\t}\r\n\t} else {\r\n\t\t/* Under pressure:\r\n\t\t * Adjust rcv_ssthresh according to reserved mem\r\n\t\t */\r\n\t\ttcp_adjust_rcv_ssthresh(sk);\r\n\t}\r\n}", ".cp_prune_queue": "static int tcp_prune_queue(struct sock *sk, const struct sk_buff *in_skb)\r\n{\r\n\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\r\n\t/* Do nothing if our queues are empty. */\r\n\tif (!atomic_read(&sk->sk_rmem_alloc))\r\n\t\treturn -1;\r\n\r\n\tNET_INC_STATS(sock_net(sk), LINUX_MIB_PRUNECALLED);\r\n\r\n\tif (!tcp_can_ingest(sk, in_skb))\r\n\t\ttcp_clamp_window(sk);\r\n\telse if (tcp_under_memory_pressure(sk))\r\n\t\ttcp_adjust_rcv_ssthresh(sk);\r\n\r\n\tif (tcp_can_ingest(sk, in_skb))\r\n\t\treturn 0;\r\n\r\n\ttcp_collapse_ofo_queue(sk);\r\n\tif (!skb_queue_empty(&sk->sk_receive_queue))\r\n\t\ttcp_collapse(sk, &sk->sk_receive_queue, NULL,\r\n\t\t\t     skb_peek(&sk->sk_receive_queue),\r\n\t\t\t     NULL,\r\n\t\t\t     tp->copied_seq, tp->rcv_nxt);\r\n\r\n\tif (tcp_can_ingest(sk, in_skb))\r\n\t\treturn 0;\r\n\r\n\t/* Collapsing did not help, destructive actions follow.\r\n\t * This must not ever occur. */\r\n\r\n\ttcp_prune_ofo_queue(sk, in_skb);\r\n\r\n\tif (tcp_can_ingest(sk, in_skb))\r\n\t\treturn 0;\r\n\r\n\t/* If we are really being abused, tell the caller to silently\r\n\t * drop receive data on the floor.  It will get retransmitted\r\n\t * and hopefully then we'll have sufficient space.\r\n\t */\r\n\tNET_INC_STATS(sock_net(sk), LINUX_MIB_RCVPRUNED);\r\n\r\n\t/* Massive buffer overcommit. */\r\n\ttp->pred_flags = 0;\r\n\treturn -1;\r\n}", ".cp_rcv_state_process": "enum skb_drop_reason\r\ntcp_rcv_state_process(struct sock *sk, struct sk_buff *skb)\r\n{\r\n\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\r\n\tconst struct tcphdr *th = tcp_hdr(skb);\r\n\tstruct request_sock *req;\r\n\tint queued = 0;\r\n\tSKB_DR(reason);\r\n\r\n\tswitch (sk->sk_state) {\r\n\tcase TCP_CLOSE:\r\n\t\tSKB_DR_SET(reason, TCP_CLOSE);\r\n\t\tgoto discard;\r\n\r\n\tcase TCP_LISTEN:\r\n\t\tif (th->ack)\r\n\t\t\treturn SKB_DROP_REASON_TCP_FLAGS;\r\n\r\n\t\tif (th->rst) {\r\n\t\t\tSKB_DR_SET(reason, TCP_RESET);\r\n\t\t\tgoto discard;\r\n\t\t}\r\n\t\tif (th->syn) {\r\n\t\t\tif (th->fin) {\r\n\t\t\t\tSKB_DR_SET(reason, TCP_FLAGS);\r\n\t\t\t\tgoto discard;\r\n\t\t\t}\r\n\t\t\t/* It is possible that we process SYN packets from backlog,\r\n\t\t\t * so we need to make sure to disable BH and RCU right there.\r\n\t\t\t */\r\n\t\t\trcu_read_lock();\r\n\t\t\tlocal_bh_disable();\r\n\t\t\ticsk->icsk_af_ops->conn_request(sk, skb);\r\n\t\t\tlocal_bh_enable();\r\n\t\t\trcu_read_unlock();\r\n\r\n\t\t\tconsume_skb(skb);\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t\tSKB_DR_SET(reason, TCP_FLAGS);\r\n\t\tgoto discard;\r\n\r\n\tcase TCP_SYN_SENT:\r\n\t\ttp->rx_opt.saw_tstamp = 0;\r\n\t\ttcp_mstamp_refresh(tp);\r\n\t\tqueued = tcp_rcv_synsent_state_process(sk, skb, th);\r\n\t\tif (queued >= 0)\r\n\t\t\treturn queued;\r\n\r\n\t\t/* Do step6 onward by hand. */\r\n\t\ttcp_urg(sk, skb, th);\r\n\t\t__kfree_skb(skb);\r\n\t\ttcp_data_snd_check(sk);\r\n\t\treturn 0;\r\n\t}\r\n\r\n\ttcp_mstamp_refresh(tp);\r\n\ttp->rx_opt.saw_tstamp = 0;\r\n\treq = rcu_dereference_protected(tp->fastopen_rsk,\r\n\t\t\t\t\tlockdep_sock_is_held(sk));\r\n\tif (req) {\r\n\t\tbool req_stolen;\r\n\r\n\t\tWARN_ON_ONCE(sk->sk_state != TCP_SYN_RECV &&\r\n\t\t    sk->sk_state != TCP_FIN_WAIT1);\r\n\r\n\t\tSKB_DR_SET(reason, TCP_FASTOPEN);\r\n\t\tif (!tcp_check_req(sk, skb, req, true, &req_stolen, &reason))\r\n\t\t\tgoto discard;\r\n\t}\r\n\r\n\tif (!th->ack && !th->rst && !th->syn) {\r\n\t\tSKB_DR_SET(reason, TCP_FLAGS);\r\n\t\tgoto discard;\r\n\t}\r\n\tif (!tcp_validate_incoming(sk, skb, th, 0))\r\n\t\treturn 0;\r\n\r\n\t/* step 5: check the ACK field */\r\n\treason = tcp_ack(sk, skb, FLAG_SLOWPATH |\r\n\t\t\t\t  FLAG_UPDATE_TS_RECENT |\r\n\t\t\t\t  FLAG_NO_CHALLENGE_ACK);\r\n\r\n\tif ((int)reason <= 0) {\r\n\t\tif (sk->sk_state == TCP_SYN_RECV) {\r\n\t\t\t/* send one RST */\r\n\t\t\tif (!reason)\r\n\t\t\t\treturn SKB_DROP_REASON_TCP_OLD_ACK;\r\n\t\t\treturn -reason;\r\n\t\t}\r\n\t\t/* accept old ack during closing */\r\n\t\tif ((int)reason < 0) {\r\n\t\t\ttcp_send_challenge_ack(sk, false);\r\n\t\t\treason = -reason;\r\n\t\t\tgoto discard;\r\n\t\t}\r\n\t}\r\n\tSKB_DR_SET(reason, NOT_SPECIFIED);\r\n\tswitch (sk->sk_state) {\r\n\tcase TCP_SYN_RECV:\r\n\t\ttp->delivered++; /* SYN-ACK delivery isn't tracked in tcp_ack */\r\n\t\tif (!tp->srtt_us)\r\n\t\t\ttcp_synack_rtt_meas(sk, req);\r\n\r\n\t\tif (tp->rx_opt.tstamp_ok)\r\n\t\t\ttp->advmss -= TCPOLEN_TSTAMP_ALIGNED;\r\n\r\n\t\tif (req) {\r\n\t\t\ttcp_rcv_synrecv_state_fastopen(sk);\r\n\t\t} else {\r\n\t\t\ttcp_try_undo_spurious_syn(sk);\r\n\t\t\ttp->retrans_stamp = 0;\r\n\t\t\ttcp_init_transfer(sk, BPF_SOCK_OPS_PASSIVE_ESTABLISHED_CB,\r\n\t\t\t\t\t  skb);\r\n\t\t\tWRITE_ONCE(tp->copied_seq, tp->rcv_nxt);\r\n\t\t}\r\n\t\ttcp_ao_established(sk);\r\n\t\tsmp_mb();\r\n\t\ttcp_set_state(sk, TCP_ESTABLISHED);\r\n\t\tsk->sk_state_change(sk);\r\n\r\n\t\t/* Note, that this wakeup is only for marginal crossed SYN case.\r\n\t\t * Passively open sockets are not waked up, because\r\n\t\t * sk->sk_sleep == NULL and sk->sk_socket == NULL.\r\n\t\t */\r\n\t\tif (sk->sk_socket)\r\n\t\t\tsk_wake_async(sk, SOCK_WAKE_IO, POLL_OUT);\r\n\r\n\t\ttp->snd_una = TCP_SKB_CB(skb)->ack_seq;\r\n\t\ttp->snd_wnd = ntohs(th->window) << tp->rx_opt.snd_wscale;\r\n\t\ttcp_init_wl(tp, TCP_SKB_CB(skb)->seq);\r\n\r\n\t\tif (!inet_csk(sk)->icsk_ca_ops->cong_control)\r\n\t\t\ttcp_update_pacing_rate(sk);\r\n\r\n\t\t/* Prevent spurious tcp_cwnd_restart() on first data packet */\r\n\t\ttp->lsndtime = tcp_jiffies32;\r\n\r\n\t\ttcp_initialize_rcv_mss(sk);\r\n\t\tif (tcp_ecn_mode_accecn(tp))\r\n\t\t\ttcp_accecn_third_ack(sk, skb, tp->syn_ect_snt);\r\n\t\ttcp_fast_path_on(tp);\r\n\t\tif (sk->sk_shutdown & SEND_SHUTDOWN)\r\n\t\t\ttcp_shutdown(sk, SEND_SHUTDOWN);\r\n\r\n\t\tbreak;\r\n\r\n\tcase TCP_FIN_WAIT1: {\r\n\t\tint tmo;\r\n\r\n\t\tif (req)\r\n\t\t\ttcp_rcv_synrecv_state_fastopen(sk);\r\n\r\n\t\tif (tp->snd_una != tp->write_seq)\r\n\t\t\tbreak;\r\n\r\n\t\ttcp_set_state(sk, TCP_FIN_WAIT2);\r\n\t\tWRITE_ONCE(sk->sk_shutdown, sk->sk_shutdown | SEND_SHUTDOWN);\r\n\r\n\t\tsk_dst_confirm(sk);\r\n\r\n\t\tif (!sock_flag(sk, SOCK_DEAD)) {\r\n\t\t\t/* Wake up lingering close() */\r\n\t\t\tsk->sk_state_change(sk);\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\tif (READ_ONCE(tp->linger2) < 0) {\r\n\t\t\ttcp_done(sk);\r\n\t\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPABORTONDATA);\r\n\t\t\treturn SKB_DROP_REASON_TCP_ABORT_ON_DATA;\r\n\t\t}\r\n\t\tif (TCP_SKB_CB(skb)->end_seq != TCP_SKB_CB(skb)->seq &&\r\n\t\t    after(TCP_SKB_CB(skb)->end_seq - th->fin, tp->rcv_nxt)) {\r\n\t\t\t/* Receive out of order FIN after close() */\r\n\t\t\tif (tp->syn_fastopen && th->fin)\r\n\t\t\t\ttcp_fastopen_active_disable(sk);\r\n\t\t\ttcp_done(sk);\r\n\t\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPABORTONDATA);\r\n\t\t\treturn SKB_DROP_REASON_TCP_ABORT_ON_DATA;\r\n\t\t}\r\n\r\n\t\ttmo = tcp_fin_time(sk);\r\n\t\tif (tmo > TCP_TIMEWAIT_LEN) {\r\n\t\t\ttcp_reset_keepalive_timer(sk, tmo - TCP_TIMEWAIT_LEN);\r\n\t\t} else if (th->fin || sock_owned_by_user(sk)) {\r\n\t\t\t/* Bad case. We could lose such FIN otherwise.\r\n\t\t\t * It is not a big problem, but it looks confusing\r\n\t\t\t * and not so rare event. We still can lose it now,\r\n\t\t\t * if it spins in bh_lock_sock(), but it is really\r\n\t\t\t * marginal case.\r\n\t\t\t */\r\n\t\t\ttcp_reset_keepalive_timer(sk, tmo);\r\n\t\t} else {\r\n\t\t\ttcp_time_wait(sk, TCP_FIN_WAIT2, tmo);\r\n\t\t\tgoto consume;\r\n\t\t}\r\n\t\tbreak;\r\n\t}\r\n\r\n\tcase TCP_CLOSING:\r\n\t\tif (tp->snd_una == tp->write_seq) {\r\n\t\t\ttcp_time_wait(sk, TCP_TIME_WAIT, 0);\r\n\t\t\tgoto consume;\r\n\t\t}\r\n\t\tbreak;\r\n\r\n\tcase TCP_LAST_ACK:\r\n\t\tif (tp->snd_una == tp->write_seq) {\r\n\t\t\ttcp_update_metrics(sk);\r\n\t\t\ttcp_done(sk);\r\n\t\t\tgoto consume;\r\n\t\t}\r\n\t\tbreak;\r\n\t}\r\n\r\n\t/* step 6: check the URG bit */\r\n\ttcp_urg(sk, skb, th);\r\n\r\n\t/* step 7: process the segment text */\r\n\tswitch (sk->sk_state) {\r\n\tcase TCP_CLOSE_WAIT:\r\n\tcase TCP_CLOSING:\r\n\tcase TCP_LAST_ACK:\r\n\t\tif (!before(TCP_SKB_CB(skb)->seq, tp->rcv_nxt)) {\r\n\t\t\t/* If a subflow has been reset, the packet should not\r\n\t\t\t * continue to be processed, drop the packet.\r\n\t\t\t */\r\n\t\t\tif (sk_is_mptcp(sk) && !mptcp_incoming_options(sk, skb))\r\n\t\t\t\tgoto discard;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tfallthrough;\r\n\tcase TCP_FIN_WAIT1:\r\n\tcase TCP_FIN_WAIT2:\r\n\t\t/* RFC 793 says to queue data in these states,\r\n\t\t * RFC 1122 says we MUST send a reset.\r\n\t\t * BSD 4.4 also does reset.\r\n\t\t */\r\n\t\tif (sk->sk_shutdown & RCV_SHUTDOWN) {\r\n\t\t\tif (TCP_SKB_CB(skb)->end_seq != TCP_SKB_CB(skb)->seq &&\r\n\t\t\t    after(TCP_SKB_CB(skb)->end_seq - th->fin, tp->rcv_nxt)) {\r\n\t\t\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPABORTONDATA);\r\n\t\t\t\ttcp_reset(sk, skb);\r\n\t\t\t\treturn SKB_DROP_REASON_TCP_ABORT_ON_DATA;\r\n\t\t\t}\r\n\t\t}\r\n\t\tfallthrough;\r\n\tcase TCP_ESTABLISHED:\r\n\t\ttcp_data_queue(sk, skb);\r\n\t\tqueued = 1;\r\n\t\tbreak;\r\n\t}\r\n\r\n\t/* tcp_data could move socket to TIME-WAIT */\r\n\tif (sk->sk_state != TCP_CLOSE) {\r\n\t\ttcp_data_snd_check(sk);\r\n\t\ttcp_ack_snd_check(sk);\r\n\t}\r\n\r\n\tif (!queued) {\r\ndiscard:\r\n\t\ttcp_drop_reason(sk, skb, reason);\r\n\t}\r\n\treturn 0;\r\n\r\nconsume:\r\n\t__kfree_skb(skb);\r\n\treturn 0;\r\n}", ".cp_rcv_rtt_measure": "static inline void tcp_rcv_rtt_measure(struct tcp_sock *tp)\r\n{\r\n\tu32 delta_us;\r\n\r\n\tif (tp->rcv_rtt_est.time == 0)\r\n\t\tgoto new_measure;\r\n\tif (before(tp->rcv_nxt, tp->rcv_rtt_est.seq))\r\n\t\treturn;\r\n\tdelta_us = tcp_stamp_us_delta(tp->tcp_mstamp, tp->rcv_rtt_est.time);\r\n\tif (!delta_us)\r\n\t\tdelta_us = 1;\r\n\ttcp_rcv_rtt_update(tp, delta_us, 1);\r\n\r\nnew_measure:\r\n\ttp->rcv_rtt_est.seq = tp->rcv_nxt + tp->rcv_wnd;\r\n\ttp->rcv_rtt_est.time = tp->tcp_mstamp;\r\n}", ".cp_rcv_rtt_measure_ts": "static inline void tcp_rcv_rtt_measure_ts(struct sock *sk,\r\n\t\t\t\t\t  const struct sk_buff *skb)\r\n{\r\n\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\r\n\tif (tp->rx_opt.rcv_tsecr == tp->rcv_rtt_last_tsecr)\r\n\t\treturn;\r\n\ttp->rcv_rtt_last_tsecr = tp->rx_opt.rcv_tsecr;\r\n\r\n\tif (TCP_SKB_CB(skb)->end_seq -\r\n\t    TCP_SKB_CB(skb)->seq >= inet_csk(sk)->icsk_ack.rcv_mss) {\r\n\t\ts32 delta = tcp_rtt_tsopt_us(tp, 0);\r\n\r\n\t\tif (delta > 0)\r\n\t\t\ttcp_rcv_rtt_update(tp, delta, 0);\r\n\t}\r\n}", ".cp_rcv_established": "void tcp_rcv_established(struct sock *sk, struct sk_buff *skb)\r\n{\r\n\tenum skb_drop_reason reason = SKB_DROP_REASON_NOT_SPECIFIED;\r\n\tconst struct tcphdr *th = (const struct tcphdr *)skb->data;\r\n\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\tunsigned int len = skb->len;\r\n\r\n\t/* TCP congestion window tracking */\r\n\ttrace_tcp_probe(sk, skb);\r\n\r\n\ttcp_mstamp_refresh(tp);\r\n\tif (unlikely(!rcu_access_pointer(sk->sk_rx_dst)))\r\n\t\tinet_csk(sk)->icsk_af_ops->sk_rx_dst_set(sk, skb);\r\n\t/*\r\n\t *\tHeader prediction.\r\n\t *\tThe code loosely follows the one in the famous\r\n\t *\t\"30 instruction TCP receive\" Van Jacobson mail.\r\n\t *\r\n\t *\tVan's trick is to deposit buffers into socket queue\r\n\t *\ton a device interrupt, to call tcp_recv function\r\n\t *\ton the receive process context and checksum and copy\r\n\t *\tthe buffer to user space. smart...\r\n\t *\r\n\t *\tOur current scheme is not silly either but we take the\r\n\t *\textra cost of the net_bh soft interrupt processing...\r\n\t *\tWe do checksum and copy also but from device to kernel.\r\n\t */\r\n\r\n\ttp->rx_opt.saw_tstamp = 0;\r\n\ttp->rx_opt.accecn = 0;\r\n\r\n\t/*\tpred_flags is 0xS?10 << 16 + snd_wnd\r\n\t *\tif header_prediction is to be made\r\n\t *\t'S' will always be tp->tcp_header_len >> 2\r\n\t *\t'?' will be 0 for the fast path, otherwise pred_flags is 0 to\r\n\t *  turn it off\t(when there are holes in the receive\r\n\t *\t space for instance)\r\n\t *\tPSH flag is ignored.\r\n\t */\r\n\r\n\tif ((tcp_flag_word(th) & TCP_HP_BITS) == tp->pred_flags &&\r\n\t    TCP_SKB_CB(skb)->seq == tp->rcv_nxt &&\r\n\t    !after(TCP_SKB_CB(skb)->ack_seq, tp->snd_nxt)) {\r\n\t\tint tcp_header_len = tp->tcp_header_len;\r\n\t\ts32 delta = 0;\r\n\t\tint flag = 0;\r\n\r\n\t\t/* Timestamp header prediction: tcp_header_len\r\n\t\t * is automatically equal to th->doff*4 due to pred_flags\r\n\t\t * match.\r\n\t\t */\r\n\r\n\t\t/* Check timestamp */\r\n\t\tif (tcp_header_len == sizeof(struct tcphdr) + TCPOLEN_TSTAMP_ALIGNED) {\r\n\t\t\t/* No? Slow path! */\r\n\t\t\tif (!tcp_parse_aligned_timestamp(tp, th))\r\n\t\t\t\tgoto slow_path;\r\n\r\n\t\t\tdelta = tp->rx_opt.rcv_tsval -\r\n\t\t\t\ttp->rx_opt.ts_recent;\r\n\t\t\t/* If PAWS failed, check it more carefully in slow path */\r\n\t\t\tif (delta < 0)\r\n\t\t\t\tgoto slow_path;\r\n\r\n\t\t\t/* DO NOT update ts_recent here, if checksum fails\r\n\t\t\t * and timestamp was corrupted part, it will result\r\n\t\t\t * in a hung connection since we will drop all\r\n\t\t\t * future packets due to the PAWS test.\r\n\t\t\t */\r\n\t\t}\r\n\r\n\t\tif (len <= tcp_header_len) {\r\n\t\t\t/* Bulk data transfer: sender */\r\n\t\t\tif (len == tcp_header_len) {\r\n\t\t\t\t/* Predicted packet is in window by definition.\r\n\t\t\t\t * seq == rcv_nxt and rcv_wup <= rcv_nxt.\r\n\t\t\t\t * Hence, check seq<=rcv_wup reduces to:\r\n\t\t\t\t */\r\n\t\t\t\tif (tcp_header_len ==\r\n\t\t\t\t    (sizeof(struct tcphdr) + TCPOLEN_TSTAMP_ALIGNED) &&\r\n\t\t\t\t    tp->rcv_nxt == tp->rcv_wup)\r\n\t\t\t\t\tflag |= __tcp_replace_ts_recent(tp,\r\n\t\t\t\t\t\t\t\t\tdelta);\r\n\r\n\t\t\t\ttcp_ecn_received_counters(sk, skb, 0);\r\n\r\n\t\t\t\t/* We know that such packets are checksummed\r\n\t\t\t\t * on entry.\r\n\t\t\t\t */\r\n\t\t\t\ttcp_ack(sk, skb, flag);\r\n\t\t\t\t__kfree_skb(skb);\r\n\t\t\t\ttcp_data_snd_check(sk);\r\n\t\t\t\t/* When receiving pure ack in fast path, update\r\n\t\t\t\t * last ts ecr directly instead of calling\r\n\t\t\t\t * tcp_rcv_rtt_measure_ts()\r\n\t\t\t\t */\r\n\t\t\t\ttp->rcv_rtt_last_tsecr = tp->rx_opt.rcv_tsecr;\r\n\t\t\t\treturn;\r\n\t\t\t} else { /* Header too small */\r\n\t\t\t\treason = SKB_DROP_REASON_PKT_TOO_SMALL;\r\n\t\t\t\tTCP_INC_STATS(sock_net(sk), TCP_MIB_INERRS);\r\n\t\t\t\tgoto discard;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tint eaten = 0;\r\n\t\t\tbool fragstolen = false;\r\n\r\n\t\t\tif (tcp_checksum_complete(skb))\r\n\t\t\t\tgoto csum_error;\r\n\r\n\t\t\tif (after(TCP_SKB_CB(skb)->end_seq,\r\n\t\t\t\t  tp->rcv_nxt + tcp_receive_window(tp)))\r\n\t\t\t\tgoto validate;\r\n\r\n\t\t\tif ((int)skb->truesize > sk->sk_forward_alloc)\r\n\t\t\t\tgoto step5;\r\n\r\n\t\t\t/* Predicted packet is in window by definition.\r\n\t\t\t * seq == rcv_nxt and rcv_wup <= rcv_nxt.\r\n\t\t\t * Hence, check seq<=rcv_wup reduces to:\r\n\t\t\t */\r\n\t\t\tif (tcp_header_len ==\r\n\t\t\t    (sizeof(struct tcphdr) + TCPOLEN_TSTAMP_ALIGNED) &&\r\n\t\t\t    tp->rcv_nxt == tp->rcv_wup)\r\n\t\t\t\tflag |= __tcp_replace_ts_recent(tp,\r\n\t\t\t\t\t\t\t\tdelta);\r\n\r\n\t\t\ttcp_rcv_rtt_measure_ts(sk, skb);\r\n\r\n\t\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPHPHITS);\r\n\r\n\t\t\t/* Bulk data transfer: receiver */\r\n\t\t\ttcp_cleanup_skb(skb);\r\n\t\t\t__skb_pull(skb, tcp_header_len);\r\n\t\t\ttcp_ecn_received_counters(sk, skb,\r\n\t\t\t\t\t\t  len - tcp_header_len);\r\n\t\t\teaten = tcp_queue_rcv(sk, skb, &fragstolen);\r\n\r\n\t\t\ttcp_event_data_recv(sk, skb);\r\n\r\n\t\t\tif (TCP_SKB_CB(skb)->ack_seq != tp->snd_una) {\r\n\t\t\t\t/* Well, only one small jumplet in fast path... */\r\n\t\t\t\ttcp_ack(sk, skb, flag | FLAG_DATA);\r\n\t\t\t\ttcp_data_snd_check(sk);\r\n\t\t\t\tif (!inet_csk_ack_scheduled(sk))\r\n\t\t\t\t\tgoto no_ack;\r\n\t\t\t} else {\r\n\t\t\t\ttcp_update_wl(tp, TCP_SKB_CB(skb)->seq);\r\n\t\t\t}\r\n\r\n\t\t\t__tcp_ack_snd_check(sk, 0);\r\nno_ack:\r\n\t\t\tif (eaten)\r\n\t\t\t\tkfree_skb_partial(skb, fragstolen);\r\n\t\t\ttcp_data_ready(sk);\r\n\t\t\treturn;\r\n\t\t}\r\n\t}\r\n\r\nslow_path:\r\n\tif (len < (th->doff << 2) || tcp_checksum_complete(skb))\r\n\t\tgoto csum_error;\r\n\r\n\tif (!th->ack && !th->rst && !th->syn) {\r\n\t\treason = SKB_DROP_REASON_TCP_FLAGS;\r\n\t\tgoto discard;\r\n\t}\r\n\r\n\t/*\r\n\t *\tStandard slow path.\r\n\t */\r\nvalidate:\r\n\tif (!tcp_validate_incoming(sk, skb, th, 1))\r\n\t\treturn;\r\n\r\nstep5:\r\n\ttcp_ecn_received_counters_payload(sk, skb);\r\n\r\n\treason = tcp_ack(sk, skb, FLAG_SLOWPATH | FLAG_UPDATE_TS_RECENT);\r\n\tif ((int)reason < 0) {\r\n\t\treason = -reason;\r\n\t\tgoto discard;\r\n\t}\r\n\ttcp_rcv_rtt_measure_ts(sk, skb);\r\n\r\n\t/* Process urgent data. */\r\n\ttcp_urg(sk, skb, th);\r\n\r\n\t/* step 7: process the segment text */\r\n\ttcp_data_queue(sk, skb);\r\n\r\n\ttcp_data_snd_check(sk);\r\n\ttcp_ack_snd_check(sk);\r\n\treturn;\r\n\r\ncsum_error:\r\n\treason = SKB_DROP_REASON_TCP_CSUM;\r\n\ttrace_tcp_bad_csum(skb);\r\n\tTCP_INC_STATS(sock_net(sk), TCP_MIB_CSUMERRORS);\r\n\tTCP_INC_STATS(sock_net(sk), TCP_MIB_INERRS);\r\n\r\ndiscard:\r\n\ttcp_drop_reason(sk, skb, reason);\r\n}", ".cp_ack_update_rtt": "static bool tcp_ack_update_rtt(struct sock *sk, const int flag,\r\n\t\t\t       long seq_rtt_us, long sack_rtt_us,\r\n\t\t\t       long ca_rtt_us, struct rate_sample *rs)\r\n{\r\n\tconst struct tcp_sock *tp = tcp_sk(sk);\r\n\r\n\t/* Prefer RTT measured from ACK's timing to TS-ECR. This is because\r\n\t * broken middle-boxes or peers may corrupt TS-ECR fields. But\r\n\t * Karn's algorithm forbids taking RTT if some retransmitted data\r\n\t * is acked (RFC6298).\r\n\t */\r\n\tif (seq_rtt_us < 0)\r\n\t\tseq_rtt_us = sack_rtt_us;\r\n\r\n\t/* RTTM Rule: A TSecr value received in a segment is used to\r\n\t * update the averaged RTT measurement only if the segment\r\n\t * acknowledges some new data, i.e., only if it advances the\r\n\t * left edge of the send window.\r\n\t * See draft-ietf-tcplw-high-performance-00, section 3.3.\r\n\t */\r\n\tif (seq_rtt_us < 0 && tp->rx_opt.saw_tstamp &&\r\n\t    tp->rx_opt.rcv_tsecr && flag & FLAG_ACKED)\r\n\t\tseq_rtt_us = ca_rtt_us = tcp_rtt_tsopt_us(tp, 1);\r\n\r\n\trs->rtt_us = ca_rtt_us; /* RTT of last (S)ACKed packet (or -1) */\r\n\tif (seq_rtt_us < 0)\r\n\t\treturn false;\r\n\r\n\t/* ca_rtt_us >= 0 is counting on the invariant that ca_rtt_us is\r\n\t * always taken together with ACK, SACK, or TS-opts. Any negative\r\n\t * values will be skipped with the seq_rtt_us < 0 check above.\r\n\t */\r\n\ttcp_update_rtt_min(sk, ca_rtt_us, flag);\r\n\ttcp_rtt_estimator(sk, seq_rtt_us);\r\n\ttcp_set_rto(sk);\r\n\r\n\t/* RFC6298: only reset backoff on valid RTT measurement. */\r\n\tinet_csk(sk)->icsk_backoff = 0;\r\n\treturn true;\r\n}", ".cp_rcv_space_adjust": "void tcp_rcv_space_adjust(struct sock *sk)\r\n{\r\n\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\tint time, inq, copied;\r\n\r\n\ttrace_tcp_rcv_space_adjust(sk);\r\n\r\n\ttcp_mstamp_refresh(tp);\r\n\ttime = tcp_stamp_us_delta(tp->tcp_mstamp, tp->rcvq_space.time);\r\n\tif (time < (tp->rcv_rtt_est.rtt_us >> 3) || tp->rcv_rtt_est.rtt_us == 0)\r\n\t\treturn;\r\n\r\n\t/* Number of bytes copied to user in last RTT */\r\n\tcopied = tp->copied_seq - tp->rcvq_space.seq;\r\n\t/* Number of bytes in receive queue. */\r\n\tinq = tp->rcv_nxt - tp->copied_seq;\r\n\tcopied -= inq;\r\n\tif (copied <= tp->rcvq_space.space)\r\n\t\tgoto new_measure;\r\n\r\n\ttrace_tcp_rcvbuf_grow(sk, time);\r\n\r\n\ttp->rcvq_space.space = copied;\r\n\r\n\ttcp_rcvbuf_grow(sk);\r\n\r\nnew_measure:\r\n\ttp->rcvq_space.seq = tp->copied_seq;\r\n\ttp->rcvq_space.time = tp->tcp_mstamp;\r\n}", ".cp_rcv_spurious_retrans": "static void tcp_rcv_spurious_retrans(struct sock *sk, const struct sk_buff *skb)\r\n{\r\n\t/* When the ACK path fails or drops most ACKs, the sender would\r\n\t * timeout and spuriously retransmit the same segment repeatedly.\r\n\t * If it seems our ACKs are not reaching the other side,\r\n\t * based on receiving a duplicate data segment with new flowlabel\r\n\t * (suggesting the sender suffered an RTO), and we are not already\r\n\t * repathing due to our own RTO, then rehash the socket to repath our\r\n\t * packets.\r\n\t */\r\n#if IS_ENABLED(CONFIG_IPV6)\r\n\tif (inet_csk(sk)->icsk_ca_state != TCP_CA_Loss &&\r\n\t    skb->protocol == htons(ETH_P_IPV6) &&\r\n\t    (tcp_sk(sk)->inet_conn.icsk_ack.lrcv_flowlabel !=\r\n\t     ntohl(ip6_flowlabel(ipv6_hdr(skb)))) &&\r\n\t    sk_rethink_txhash(sk))\r\n\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPDUPLICATEDATAREHASH);\r\n\r\n\t/* Save last flowlabel after a spurious retrans. */\r\n\ttcp_save_lrcv_flowlabel(sk, skb);\r\n#endif\r\n}", ".cp_cong_control": "static void tcp_cong_control(struct sock *sk, u32 ack, u32 acked_sacked,\r\n\t\t\t     int flag, const struct rate_sample *rs)\r\n{\r\n\tconst struct inet_connection_sock *icsk = inet_csk(sk);\r\n\r\n\tif (icsk->icsk_ca_ops->cong_control) {\r\n\t\ticsk->icsk_ca_ops->cong_control(sk, ack, flag, rs);\r\n\t\treturn;\r\n\t}\r\n\r\n\tif (tcp_in_cwnd_reduction(sk)) {\r\n\t\t/* Reduce cwnd if state mandates */\r\n\t\ttcp_cwnd_reduction(sk, acked_sacked, rs->losses, flag);\r\n\t} else if (tcp_may_raise_cwnd(sk, flag)) {\r\n\t\t/* Advance cwnd if state allows */\r\n\t\ttcp_cong_avoid(sk, ack, acked_sacked);\r\n\t}\r\n\ttcp_update_pacing_rate(sk);\r\n}", ".cp_enter_cwr": "void tcp_enter_cwr(struct sock *sk)\r\n{\r\n\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\r\n\ttp->prior_ssthresh = 0;\r\n\tif (inet_csk(sk)->icsk_ca_state < TCP_CA_CWR) {\r\n\t\ttp->undo_marker = 0;\r\n\t\ttcp_init_cwnd_reduction(sk);\r\n\t\ttcp_set_ca_state(sk, TCP_CA_CWR);\r\n\t}\r\n}", ".cp_enter_recovery": "void tcp_enter_recovery(struct sock *sk, bool ece_ack)\r\n{\r\n\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\tint mib_idx;\r\n\r\n\t/* Start the clock with our fast retransmit, for undo and ETIMEDOUT. */\r\n\ttcp_retrans_stamp_cleanup(sk);\r\n\r\n\tif (tcp_is_reno(tp))\r\n\t\tmib_idx = LINUX_MIB_TCPRENORECOVERY;\r\n\telse\r\n\t\tmib_idx = LINUX_MIB_TCPSACKRECOVERY;\r\n\r\n\tNET_INC_STATS(sock_net(sk), mib_idx);\r\n\r\n\ttp->prior_ssthresh = 0;\r\n\ttcp_init_undo(tp);\r\n\r\n\tif (!tcp_in_cwnd_reduction(sk)) {\r\n\t\tif (!ece_ack)\r\n\t\t\ttp->prior_ssthresh = tcp_current_ssthresh(sk);\r\n\t\ttcp_init_cwnd_reduction(sk);\r\n\t}\r\n\ttcp_set_ca_state(sk, TCP_CA_Recovery);\r\n}", ".cp_process_tlp_ack": "static void tcp_process_tlp_ack(struct sock *sk, u32 ack, int flag)\r\n{\r\n\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\r\n\tif (before(ack, tp->tlp_high_seq))\r\n\t\treturn;\r\n\r\n\tif (!tp->tlp_retrans) {\r\n\t\t/* TLP of new data has been acknowledged */\r\n\t\ttp->tlp_high_seq = 0;\r\n\t} else if (flag & FLAG_DSACK_TLP) {\r\n\t\t/* This DSACK means original and TLP probe arrived; no loss */\r\n\t\ttp->tlp_high_seq = 0;\r\n\t} else if (after(ack, tp->tlp_high_seq)) {\r\n\t\t/* ACK advances: there was a loss, so reduce cwnd. Reset\r\n\t\t * tlp_high_seq in tcp_init_cwnd_reduction()\r\n\t\t */\r\n\t\ttcp_init_cwnd_reduction(sk);\r\n\t\ttcp_set_ca_state(sk, TCP_CA_CWR);\r\n\t\ttcp_end_cwnd_reduction(sk);\r\n\t\ttcp_try_keep_open(sk);\r\n\t\tNET_INC_STATS(sock_net(sk),\r\n\t\t\t\tLINUX_MIB_TCPLOSSPROBERECOVERY);\r\n\t} else if (!(flag & (FLAG_SND_UNA_ADVANCED |\r\n\t\t\t     FLAG_NOT_DUP | FLAG_DATA_SACKED))) {\r\n\t\t/* Pure dupack: original and TLP probe arrived; no loss */\r\n\t\ttp->tlp_high_seq = 0;\r\n\t}\r\n}", ".cp_check_dsack": "static bool tcp_check_dsack(struct sock *sk, const struct sk_buff *ack_skb,\r\n\t\t\t    struct tcp_sack_block_wire *sp, int num_sacks,\r\n\t\t\t    u32 prior_snd_una, struct tcp_sacktag_state *state)\r\n{\r\n\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\tu32 start_seq_0 = get_unaligned_be32(&sp[0].start_seq);\r\n\tu32 end_seq_0 = get_unaligned_be32(&sp[0].end_seq);\r\n\tu32 dup_segs;\r\n\r\n\tif (before(start_seq_0, TCP_SKB_CB(ack_skb)->ack_seq)) {\r\n\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPDSACKRECV);\r\n\t} else if (num_sacks > 1) {\r\n\t\tu32 end_seq_1 = get_unaligned_be32(&sp[1].end_seq);\r\n\t\tu32 start_seq_1 = get_unaligned_be32(&sp[1].start_seq);\r\n\r\n\t\tif (after(end_seq_0, end_seq_1) || before(start_seq_0, start_seq_1))\r\n\t\t\treturn false;\r\n\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPDSACKOFORECV);\r\n\t} else {\r\n\t\treturn false;\r\n\t}\r\n\r\n\tdup_segs = tcp_dsack_seen(tp, start_seq_0, end_seq_0, state);\r\n\tif (!dup_segs) {\t/* Skip dubious DSACK */\r\n\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPDSACKIGNOREDDUBIOUS);\r\n\t\treturn false;\r\n\t}\r\n\r\n\tNET_ADD_STATS(sock_net(sk), LINUX_MIB_TCPDSACKRECVSEGS, dup_segs);\r\n\r\n\t/* D-SACK for already forgotten data... Do dumb counting. */\r\n\tif (tp->undo_marker && tp->undo_retrans > 0 &&\r\n\t    !after(end_seq_0, prior_snd_una) &&\r\n\t    after(end_seq_0, tp->undo_marker))\r\n\t\ttp->undo_retrans = max_t(int, 0, tp->undo_retrans - dup_segs);\r\n\r\n\treturn true;\r\n}", ".cp_sacktag_write_queue": "static int\r\ntcp_sacktag_write_queue(struct sock *sk, const struct sk_buff *ack_skb,\r\n\t\t\tu32 prior_snd_una, struct tcp_sacktag_state *state)\r\n{\r\n\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\tconst unsigned char *ptr = (skb_transport_header(ack_skb) +\r\n\t\t\t\t    TCP_SKB_CB(ack_skb)->sacked);\r\n\tstruct tcp_sack_block_wire *sp_wire = (struct tcp_sack_block_wire *)(ptr+2);\r\n\tstruct tcp_sack_block sp[TCP_NUM_SACKS];\r\n\tstruct tcp_sack_block *cache;\r\n\tstruct sk_buff *skb;\r\n\tint num_sacks = min(TCP_NUM_SACKS, (ptr[1] - TCPOLEN_SACK_BASE) >> 3);\r\n\tint used_sacks;\r\n\tbool found_dup_sack = false;\r\n\tint i, j;\r\n\tint first_sack_index;\r\n\r\n\tstate->flag = 0;\r\n\tstate->reord = tp->snd_nxt;\r\n\r\n\tif (!tp->sacked_out)\r\n\t\ttcp_highest_sack_reset(sk);\r\n\r\n\tfound_dup_sack = tcp_check_dsack(sk, ack_skb, sp_wire,\r\n\t\t\t\t\t num_sacks, prior_snd_una, state);\r\n\r\n\t/* Eliminate too old ACKs, but take into\r\n\t * account more or less fresh ones, they can\r\n\t * contain valid SACK info.\r\n\t */\r\n\tif (before(TCP_SKB_CB(ack_skb)->ack_seq, prior_snd_una - tp->max_window))\r\n\t\treturn 0;\r\n\r\n\tif (!tp->packets_out)\r\n\t\tgoto out;\r\n\r\n\tused_sacks = 0;\r\n\tfirst_sack_index = 0;\r\n\tfor (i = 0; i < num_sacks; i++) {\r\n\t\tbool dup_sack = !i && found_dup_sack;\r\n\r\n\t\tsp[used_sacks].start_seq = get_unaligned_be32(&sp_wire[i].start_seq);\r\n\t\tsp[used_sacks].end_seq = get_unaligned_be32(&sp_wire[i].end_seq);\r\n\r\n\t\tif (!tcp_is_sackblock_valid(tp, dup_sack,\r\n\t\t\t\t\t    sp[used_sacks].start_seq,\r\n\t\t\t\t\t    sp[used_sacks].end_seq)) {\r\n\t\t\tint mib_idx;\r\n\r\n\t\t\tif (dup_sack) {\r\n\t\t\t\tif (!tp->undo_marker)\r\n\t\t\t\t\tmib_idx = LINUX_MIB_TCPDSACKIGNOREDNOUNDO;\r\n\t\t\t\telse\r\n\t\t\t\t\tmib_idx = LINUX_MIB_TCPDSACKIGNOREDOLD;\r\n\t\t\t} else {\r\n\t\t\t\t/* Don't count olds caused by ACK reordering */\r\n\t\t\t\tif ((TCP_SKB_CB(ack_skb)->ack_seq != tp->snd_una) &&\r\n\t\t\t\t    !after(sp[used_sacks].end_seq, tp->snd_una))\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\tmib_idx = LINUX_MIB_TCPSACKDISCARD;\r\n\t\t\t}\r\n\r\n\t\t\tNET_INC_STATS(sock_net(sk), mib_idx);\r\n\t\t\tif (i == 0)\r\n\t\t\t\tfirst_sack_index = -1;\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\t/* Ignore very old stuff early */\r\n\t\tif (!after(sp[used_sacks].end_seq, prior_snd_una)) {\r\n\t\t\tif (i == 0)\r\n\t\t\t\tfirst_sack_index = -1;\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\tused_sacks++;\r\n\t}\r\n\r\n\t/* order SACK blocks to allow in order walk of the retrans queue */\r\n\tfor (i = used_sacks - 1; i > 0; i--) {\r\n\t\tfor (j = 0; j < i; j++) {\r\n\t\t\tif (after(sp[j].start_seq, sp[j + 1].start_seq)) {\r\n\t\t\t\tswap(sp[j], sp[j + 1]);\r\n\r\n\t\t\t\t/* Track where the first SACK block goes to */\r\n\t\t\t\tif (j == first_sack_index)\r\n\t\t\t\t\tfirst_sack_index = j + 1;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tstate->mss_now = tcp_current_mss(sk);\r\n\tskb = NULL;\r\n\ti = 0;\r\n\r\n\tif (!tp->sacked_out) {\r\n\t\t/* It's already past, so skip checking against it */\r\n\t\tcache = tp->recv_sack_cache + ARRAY_SIZE(tp->recv_sack_cache);\r\n\t} else {\r\n\t\tcache = tp->recv_sack_cache;\r\n\t\t/* Skip empty blocks in at head of the cache */\r\n\t\twhile (tcp_sack_cache_ok(tp, cache) && !cache->start_seq &&\r\n\t\t       !cache->end_seq)\r\n\t\t\tcache++;\r\n\t}\r\n\r\n\twhile (i < used_sacks) {\r\n\t\tu32 start_seq = sp[i].start_seq;\r\n\t\tu32 end_seq = sp[i].end_seq;\r\n\t\tbool dup_sack = (found_dup_sack && (i == first_sack_index));\r\n\t\tstruct tcp_sack_block *next_dup = NULL;\r\n\r\n\t\tif (found_dup_sack && ((i + 1) == first_sack_index))\r\n\t\t\tnext_dup = &sp[i + 1];\r\n\r\n\t\t/* Skip too early cached blocks */\r\n\t\twhile (tcp_sack_cache_ok(tp, cache) &&\r\n\t\t       !before(start_seq, cache->end_seq))\r\n\t\t\tcache++;\r\n\r\n\t\t/* Can skip some work by looking recv_sack_cache? */\r\n\t\tif (tcp_sack_cache_ok(tp, cache) && !dup_sack &&\r\n\t\t    after(end_seq, cache->start_seq)) {\r\n\r\n\t\t\t/* Head todo? */\r\n\t\t\tif (before(start_seq, cache->start_seq)) {\r\n\t\t\t\tskb = tcp_sacktag_skip(skb, sk, start_seq);\r\n\t\t\t\tskb = tcp_sacktag_walk(skb, sk, next_dup,\r\n\t\t\t\t\t\t       state,\r\n\t\t\t\t\t\t       start_seq,\r\n\t\t\t\t\t\t       cache->start_seq,\r\n\t\t\t\t\t\t       dup_sack);\r\n\t\t\t}\r\n\r\n\t\t\t/* Rest of the block already fully processed? */\r\n\t\t\tif (!after(end_seq, cache->end_seq))\r\n\t\t\t\tgoto advance_sp;\r\n\r\n\t\t\tskb = tcp_maybe_skipping_dsack(skb, sk, next_dup,\r\n\t\t\t\t\t\t       state,\r\n\t\t\t\t\t\t       cache->end_seq);\r\n\r\n\t\t\t/* ...tail remains todo... */\r\n\t\t\tif (tcp_highest_sack_seq(tp) == cache->end_seq) {\r\n\t\t\t\t/* ...but better entrypoint exists! */\r\n\t\t\t\tskb = tcp_highest_sack(sk);\r\n\t\t\t\tif (!skb)\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcache++;\r\n\t\t\t\tgoto walk;\r\n\t\t\t}\r\n\r\n\t\t\tskb = tcp_sacktag_skip(skb, sk, cache->end_seq);\r\n\t\t\t/* Check overlap against next cached too (past this one already) */\r\n\t\t\tcache++;\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\tif (!before(start_seq, tcp_highest_sack_seq(tp))) {\r\n\t\t\tskb = tcp_highest_sack(sk);\r\n\t\t\tif (!skb)\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\t\tskb = tcp_sacktag_skip(skb, sk, start_seq);\r\n\r\nwalk:\r\n\t\tskb = tcp_sacktag_walk(skb, sk, next_dup, state,\r\n\t\t\t\t       start_seq, end_seq, dup_sack);\r\n\r\nadvance_sp:\r\n\t\ti++;\r\n\t}\r\n\r\n\t/* Clear the head of the cache sack blocks so we can skip it next time */\r\n\tfor (i = 0; i < ARRAY_SIZE(tp->recv_sack_cache) - used_sacks; i++) {\r\n\t\ttp->recv_sack_cache[i].start_seq = 0;\r\n\t\ttp->recv_sack_cache[i].end_seq = 0;\r\n\t}\r\n\tfor (j = 0; j < used_sacks; j++)\r\n\t\ttp->recv_sack_cache[i++] = sp[j];\r\n\r\n\tif (inet_csk(sk)->icsk_ca_state != TCP_CA_Loss || tp->undo_marker)\r\n\t\ttcp_check_sack_reordering(sk, state->reord, 0);\r\n\r\n\ttcp_verify_left_out(tp);\r\nout:\r\n\r\n#if FASTRETRANS_DEBUG > 0\r\n\tWARN_ON((int)tp->sacked_out < 0);\r\n\tWARN_ON((int)tp->lost_out < 0);\r\n\tWARN_ON((int)tp->retrans_out < 0);\r\n\tWARN_ON((int)tcp_packets_in_flight(tp) < 0);\r\n#endif\r\n\treturn state->flag;\r\n}", ".cp_try_undo_partial": "static bool tcp_try_undo_partial(struct sock *sk, u32 prior_snd_una)\r\n{\r\n\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\r\n\tif (tp->undo_marker && tcp_packet_delayed(tp)) {\r\n\t\t/* Plain luck! Hole if filled with delayed\r\n\t\t * packet, rather than with a retransmit. Check reordering.\r\n\t\t */\r\n\t\ttcp_check_sack_reordering(sk, prior_snd_una, 1);\r\n\r\n\t\t/* We are getting evidence that the reordering degree is higher\r\n\t\t * than we realized. If there are no retransmits out then we\r\n\t\t * can undo. Otherwise we clock out new packets but do not\r\n\t\t * mark more packets lost or retransmit more.\r\n\t\t */\r\n\t\tif (tp->retrans_out)\r\n\t\t\treturn true;\r\n\r\n\t\tif (!tcp_any_retrans_done(sk))\r\n\t\t\ttp->retrans_stamp = 0;\r\n\r\n\t\tDBGUNDO(sk, \"partial recovery\");\r\n\t\ttcp_undo_cwnd_reduction(sk, true);\r\n\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPPARTIALUNDO);\r\n\t\ttcp_try_keep_open(sk);\r\n\t}\r\n\treturn false;\r\n}", ".cp_mark_skb_lost": "void tcp_mark_skb_lost(struct sock *sk, struct sk_buff *skb)\r\n{\r\n\t__u8 sacked = TCP_SKB_CB(skb)->sacked;\r\n\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\r\n\tif (sacked & TCPCB_SACKED_ACKED)\r\n\t\treturn;\r\n\r\n\ttcp_verify_retransmit_hint(tp, skb);\r\n\tif (sacked & TCPCB_LOST) {\r\n\t\tif (sacked & TCPCB_SACKED_RETRANS) {\r\n\t\t\t/* Account for retransmits that are lost again */\r\n\t\t\tTCP_SKB_CB(skb)->sacked &= ~TCPCB_SACKED_RETRANS;\r\n\t\t\ttp->retrans_out -= tcp_skb_pcount(skb);\r\n\t\t\tNET_ADD_STATS(sock_net(sk), LINUX_MIB_TCPLOSTRETRANSMIT,\r\n\t\t\t\t      tcp_skb_pcount(skb));\r\n\t\t\ttcp_notify_skb_loss_event(tp, skb);\r\n\t\t}\r\n\t} else {\r\n\t\ttp->lost_out += tcp_skb_pcount(skb);\r\n\t\tTCP_SKB_CB(skb)->sacked |= TCPCB_LOST;\r\n\t\ttcp_notify_skb_loss_event(tp, skb);\r\n\t}\r\n}", ".cp_timeout_mark_lost": "static void tcp_timeout_mark_lost(struct sock *sk)\r\n{\r\n\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\tstruct sk_buff *skb, *head;\r\n\tbool is_reneg;\t\t\t/* is receiver reneging on SACKs? */\r\n\r\n\thead = tcp_rtx_queue_head(sk);\r\n\tis_reneg = head && (TCP_SKB_CB(head)->sacked & TCPCB_SACKED_ACKED);\r\n\tif (is_reneg) {\r\n\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPSACKRENEGING);\r\n\t\ttp->sacked_out = 0;\r\n\t\t/* Mark SACK reneging until we recover from this loss event. */\r\n\t\ttp->is_sack_reneg = 1;\r\n\t} else if (tcp_is_reno(tp)) {\r\n\t\ttcp_reset_reno_sack(tp);\r\n\t}\r\n\r\n\tskb = head;\r\n\tskb_rbtree_walk_from(skb) {\r\n\t\tif (is_reneg)\r\n\t\t\tTCP_SKB_CB(skb)->sacked &= ~TCPCB_SACKED_ACKED;\r\n\t\telse if (skb != head && tcp_rack_skb_timeout(tp, skb, 0) > 0)\r\n\t\t\tcontinue; /* Don't mark recently sent ones lost yet */\r\n\t\ttcp_mark_skb_lost(sk, skb);\r\n\t}\r\n\ttcp_verify_left_out(tp);\r\n\ttcp_clear_all_retrans_hints(tp);\r\n}", ".cp_simple_retransmit": "void tcp_simple_retransmit(struct sock *sk)\r\n{\r\n\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\tstruct sk_buff *skb;\r\n\tint mss;\r\n\r\n\t/* A fastopen SYN request is stored as two separate packets within\r\n\t * the retransmit queue, this is done by tcp_send_syn_data().\r\n\t * As a result simply checking the MSS of the frames in the queue\r\n\t * will not work for the SYN packet.\r\n\t *\r\n\t * Us being here is an indication of a path MTU issue so we can\r\n\t * assume that the fastopen SYN was lost and just mark all the\r\n\t * frames in the retransmit queue as lost. We will use an MSS of\r\n\t * -1 to mark all frames as lost, otherwise compute the current MSS.\r\n\t */\r\n\tif (tp->syn_data && sk->sk_state == TCP_SYN_SENT)\r\n\t\tmss = -1;\r\n\telse\r\n\t\tmss = tcp_current_mss(sk);\r\n\r\n\tskb_rbtree_walk(skb, &sk->tcp_rtx_queue) {\r\n\t\tif (tcp_skb_seglen(skb) > mss)\r\n\t\t\ttcp_mark_skb_lost(sk, skb);\r\n\t}\r\n\r\n\tif (!tp->lost_out)\r\n\t\treturn;\r\n\r\n\tif (tcp_is_reno(tp))\r\n\t\ttcp_limit_reno_sacked(tp);\r\n\r\n\ttcp_verify_left_out(tp);\r\n\r\n\t/* Don't muck with the congestion window here.\r\n\t * Reason is that we do not increase amount of _data_\r\n\t * in network, but units changed and effective\r\n\t * cwnd/ssthresh really reduced now.\r\n\t */\r\n\ttcp_non_congestion_loss_retransmit(sk);\r\n}", ".cp_rcv_fastopen_synack": "static bool tcp_rcv_fastopen_synack(struct sock *sk, struct sk_buff *synack,\r\n\t\t\t\t    struct tcp_fastopen_cookie *cookie)\r\n{\r\n\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\tstruct sk_buff *data = tp->syn_data ? tcp_rtx_queue_head(sk) : NULL;\r\n\tu16 mss = tp->rx_opt.mss_clamp, try_exp = 0;\r\n\tbool syn_drop = false;\r\n\r\n\tif (mss == READ_ONCE(tp->rx_opt.user_mss)) {\r\n\t\tstruct tcp_options_received opt;\r\n\r\n\t\t/* Get original SYNACK MSS value if user MSS sets mss_clamp */\r\n\t\ttcp_clear_options(&opt);\r\n\t\topt.user_mss = opt.mss_clamp = 0;\r\n\t\ttcp_parse_options(sock_net(sk), synack, &opt, 0, NULL);\r\n\t\tmss = opt.mss_clamp;\r\n\t}\r\n\r\n\tif (!tp->syn_fastopen) {\r\n\t\t/* Ignore an unsolicited cookie */\r\n\t\tcookie->len = -1;\r\n\t} else if (tp->total_retrans) {\r\n\t\t/* SYN timed out and the SYN-ACK neither has a cookie nor\r\n\t\t * acknowledges data. Presumably the remote received only\r\n\t\t * the retransmitted (regular) SYNs: either the original\r\n\t\t * SYN-data or the corresponding SYN-ACK was dropped.\r\n\t\t */\r\n\t\tsyn_drop = (cookie->len < 0 && data);\r\n\t} else if (cookie->len < 0 && !tp->syn_data) {\r\n\t\t/* We requested a cookie but didn't get it. If we did not use\r\n\t\t * the (old) exp opt format then try so next time (try_exp=1).\r\n\t\t * Otherwise we go back to use the RFC7413 opt (try_exp=2).\r\n\t\t */\r\n\t\ttry_exp = tp->syn_fastopen_exp ? 2 : 1;\r\n\t}\r\n\r\n\ttcp_fastopen_cache_set(sk, mss, cookie, syn_drop, try_exp);\r\n\r\n\tif (data) { /* Retransmit unacked data in SYN */\r\n\t\tif (tp->total_retrans)\r\n\t\t\ttp->fastopen_client_fail = TFO_SYN_RETRANSMITTED;\r\n\t\telse\r\n\t\t\ttp->fastopen_client_fail = TFO_DATA_NOT_ACKED;\r\n\t\tskb_rbtree_walk_from(data)\r\n\t\t\t tcp_mark_skb_lost(sk, data);\r\n\t\ttcp_non_congestion_loss_retransmit(sk);\r\n\t\tNET_INC_STATS(sock_net(sk),\r\n\t\t\t\tLINUX_MIB_TCPFASTOPENACTIVEFAIL);\r\n\t\treturn true;\r\n\t}\r\n\ttp->syn_data_acked = tp->syn_data;\r\n\tif (tp->syn_data_acked) {\r\n\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPFASTOPENACTIVE);\r\n\t\t/* SYN-data is counted as two separate packets in tcp_ack() */\r\n\t\tif (tp->delivered > 1)\r\n\t\t\t--tp->delivered;\r\n\t}\r\n\r\n\ttcp_fastopen_add_skb(sk, synack);\r\n\r\n\treturn false;\r\n}", ".cp_shifted_skb": "static bool tcp_shifted_skb(struct sock *sk, struct sk_buff *prev,\r\n\t\t\t    struct sk_buff *skb,\r\n\t\t\t    struct tcp_sacktag_state *state,\r\n\t\t\t    unsigned int pcount, int shifted, int mss,\r\n\t\t\t    bool dup_sack)\r\n{\r\n\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\tu32 start_seq = TCP_SKB_CB(skb)->seq;\t/* start of newly-SACKed */\r\n\tu32 end_seq = start_seq + shifted;\t/* end of newly-SACKed */\r\n\r\n\tBUG_ON(!pcount);\r\n\r\n\t/* Adjust counters and hints for the newly sacked sequence\r\n\t * range but discard the return value since prev is already\r\n\t * marked. We must tag the range first because the seq\r\n\t * advancement below implicitly advances\r\n\t * tcp_highest_sack_seq() when skb is highest_sack.\r\n\t */\r\n\ttcp_sacktag_one(sk, state, TCP_SKB_CB(skb)->sacked,\r\n\t\t\tstart_seq, end_seq, dup_sack, pcount, skb->len,\r\n\t\t\ttcp_skb_timestamp_us(skb));\r\n\ttcp_rate_skb_delivered(sk, skb, state->rate);\r\n\r\n\tTCP_SKB_CB(prev)->end_seq += shifted;\r\n\tTCP_SKB_CB(skb)->seq += shifted;\r\n\r\n\ttcp_skb_pcount_add(prev, pcount);\r\n\tWARN_ON_ONCE(tcp_skb_pcount(skb) < pcount);\r\n\ttcp_skb_pcount_add(skb, -pcount);\r\n\r\n\t/* When we're adding to gso_segs == 1, gso_size will be zero,\r\n\t * in theory this shouldn't be necessary but as long as DSACK\r\n\t * code can come after this skb later on it's better to keep\r\n\t * setting gso_size to something.\r\n\t */\r\n\tif (!TCP_SKB_CB(prev)->tcp_gso_size)\r\n\t\tTCP_SKB_CB(prev)->tcp_gso_size = mss;\r\n\r\n\t/* CHECKME: To clear or not to clear? Mimics normal skb currently */\r\n\tif (tcp_skb_pcount(skb) <= 1)\r\n\t\tTCP_SKB_CB(skb)->tcp_gso_size = 0;\r\n\r\n\t/* Difference in this won't matter, both ACKed by the same cumul. ACK */\r\n\tTCP_SKB_CB(prev)->sacked |= (TCP_SKB_CB(skb)->sacked & TCPCB_EVER_RETRANS);\r\n\r\n\tif (skb->len > 0) {\r\n\t\tBUG_ON(!tcp_skb_pcount(skb));\r\n\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_SACKSHIFTED);\r\n\t\treturn false;\r\n\t}\r\n\r\n\t/* Whole SKB was eaten :-) */\r\n\r\n\tif (skb == tp->retransmit_skb_hint)\r\n\t\ttp->retransmit_skb_hint = prev;\r\n\r\n\tTCP_SKB_CB(prev)->tcp_flags |= TCP_SKB_CB(skb)->tcp_flags;\r\n\tTCP_SKB_CB(prev)->eor = TCP_SKB_CB(skb)->eor;\r\n\tif (TCP_SKB_CB(skb)->tcp_flags & TCPHDR_FIN)\r\n\t\tTCP_SKB_CB(prev)->end_seq++;\r\n\r\n\tif (skb == tcp_highest_sack(sk))\r\n\t\ttcp_advance_highest_sack(sk, skb);\r\n\r\n\ttcp_skb_collapse_tstamp(prev, skb);\r\n\tif (unlikely(TCP_SKB_CB(prev)->tx.delivered_mstamp))\r\n\t\tTCP_SKB_CB(prev)->tx.delivered_mstamp = 0;\r\n\r\n\ttcp_rtx_queue_unlink_and_free(skb, sk);\r\n\r\n\tNET_INC_STATS(sock_net(sk), LINUX_MIB_SACKMERGED);\r\n\r\n\treturn true;\r\n}", ".cp_check_reno_reordering": "static void tcp_check_reno_reordering(struct sock *sk, const int addend)\r\n{\r\n\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\r\n\tif (!tcp_limit_reno_sacked(tp))\r\n\t\treturn;\r\n\r\n\ttp->reordering = min_t(u32, tp->packets_out + addend,\r\n\t\t\t       READ_ONCE(sock_net(sk)->ipv4.sysctl_tcp_max_reordering));\r\n\ttp->reord_seen++;\r\n\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPRENOREORDER);\r\n}", ".cp_process_loss": "static void tcp_process_loss(struct sock *sk, int flag, int num_dupack,\r\n\t\t\t     int *rexmit)\r\n{\r\n\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\tbool recovered = !before(tp->snd_una, tp->high_seq);\r\n\r\n\tif ((flag & FLAG_SND_UNA_ADVANCED || rcu_access_pointer(tp->fastopen_rsk)) &&\r\n\t    tcp_try_undo_loss(sk, false))\r\n\t\treturn;\r\n\r\n\tif (tp->frto) { /* F-RTO RFC5682 sec 3.1 (sack enhanced version). */\r\n\t\t/* Step 3.b. A timeout is spurious if not all data are\r\n\t\t * lost, i.e., never-retransmitted data are (s)acked.\r\n\t\t */\r\n\t\tif ((flag & FLAG_ORIG_SACK_ACKED) &&\r\n\t\t    tcp_try_undo_loss(sk, true))\r\n\t\t\treturn;\r\n\r\n\t\tif (after(tp->snd_nxt, tp->high_seq)) {\r\n\t\t\tif (flag & FLAG_DATA_SACKED || num_dupack)\r\n\t\t\t\ttp->frto = 0; /* Step 3.a. loss was real */\r\n\t\t} else if (flag & FLAG_SND_UNA_ADVANCED && !recovered) {\r\n\t\t\ttp->high_seq = tp->snd_nxt;\r\n\t\t\t/* Step 2.b. Try send new data (but deferred until cwnd\r\n\t\t\t * is updated in tcp_ack()). Otherwise fall back to\r\n\t\t\t * the conventional recovery.\r\n\t\t\t */\r\n\t\t\tif (!tcp_write_queue_empty(sk) &&\r\n\t\t\t    after(tcp_wnd_end(tp), tp->snd_nxt)) {\r\n\t\t\t\t*rexmit = REXMIT_NEW;\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\ttp->frto = 0;\r\n\t\t}\r\n\t}\r\n\r\n\tif (recovered) {\r\n\t\t/* F-RTO RFC5682 sec 3.1 step 2.a and 1st part of step 3.a */\r\n\t\ttcp_try_undo_recovery(sk);\r\n\t\treturn;\r\n\t}\r\n\tif (tcp_is_reno(tp)) {\r\n\t\t/* A Reno DUPACK means new data in F-RTO step 2.b above are\r\n\t\t * delivered. Lower inflight to clock out (re)transmissions.\r\n\t\t */\r\n\t\tif (after(tp->snd_nxt, tp->high_seq) && num_dupack)\r\n\t\t\ttcp_add_reno_sack(sk, num_dupack, flag & FLAG_ECE);\r\n\t\telse if (flag & FLAG_SND_UNA_ADVANCED)\r\n\t\t\ttcp_reset_reno_sack(tp);\r\n\t}\r\n\t*rexmit = REXMIT_LOST;\r\n}", ".cp_fastretrans_alert": "static void tcp_fastretrans_alert(struct sock *sk, const u32 prior_snd_una,\r\n\t\t\t\t  int num_dupack, int *ack_flag, int *rexmit)\r\n{\r\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\r\n\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\tint flag = *ack_flag;\r\n\tbool ece_ack = flag & FLAG_ECE;\r\n\r\n\tif (!tp->packets_out && tp->sacked_out)\r\n\t\ttp->sacked_out = 0;\r\n\r\n\t/* Now state machine starts.\r\n\t * A. ECE, hence prohibit cwnd undoing, the reduction is required. */\r\n\tif (ece_ack)\r\n\t\ttp->prior_ssthresh = 0;\r\n\r\n\t/* B. In all the states check for reneging SACKs. */\r\n\tif (tcp_check_sack_reneging(sk, ack_flag))\r\n\t\treturn;\r\n\r\n\t/* C. Check consistency of the current state. */\r\n\ttcp_verify_left_out(tp);\r\n\r\n\t/* D. Check state exit conditions. State can be terminated\r\n\t *    when high_seq is ACKed. */\r\n\tif (icsk->icsk_ca_state == TCP_CA_Open) {\r\n\t\tWARN_ON(tp->retrans_out != 0 && !tp->syn_data);\r\n\t\ttp->retrans_stamp = 0;\r\n\t} else if (!before(tp->snd_una, tp->high_seq)) {\r\n\t\tswitch (icsk->icsk_ca_state) {\r\n\t\tcase TCP_CA_CWR:\r\n\t\t\t/* CWR is to be held something *above* high_seq\r\n\t\t\t * is ACKed for CWR bit to reach receiver. */\r\n\t\t\tif (tp->snd_una != tp->high_seq) {\r\n\t\t\t\ttcp_end_cwnd_reduction(sk);\r\n\t\t\t\ttcp_set_ca_state(sk, TCP_CA_Open);\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\r\n\t\tcase TCP_CA_Recovery:\r\n\t\t\tif (tcp_is_reno(tp))\r\n\t\t\t\ttcp_reset_reno_sack(tp);\r\n\t\t\tif (tcp_try_undo_recovery(sk))\r\n\t\t\t\treturn;\r\n\t\t\ttcp_end_cwnd_reduction(sk);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\r\n\t/* E. Process state. */\r\n\tswitch (icsk->icsk_ca_state) {\r\n\tcase TCP_CA_Recovery:\r\n\t\tif (!(flag & FLAG_SND_UNA_ADVANCED)) {\r\n\t\t\tif (tcp_is_reno(tp))\r\n\t\t\t\ttcp_add_reno_sack(sk, num_dupack, ece_ack);\r\n\t\t} else if (tcp_try_undo_partial(sk, prior_snd_una))\r\n\t\t\treturn;\r\n\r\n\t\tif (tcp_try_undo_dsack(sk))\r\n\t\t\ttcp_try_to_open(sk, flag);\r\n\r\n\t\ttcp_identify_packet_loss(sk, ack_flag);\r\n\t\tif (icsk->icsk_ca_state != TCP_CA_Recovery) {\r\n\t\t\tif (!tcp_time_to_recover(tp))\r\n\t\t\t\treturn;\r\n\t\t\t/* Undo reverts the recovery state. If loss is evident,\r\n\t\t\t * starts a new recovery (e.g. reordering then loss);\r\n\t\t\t */\r\n\t\t\ttcp_enter_recovery(sk, ece_ack);\r\n\t\t}\r\n\t\tbreak;\r\n\tcase TCP_CA_Loss:\r\n\t\ttcp_process_loss(sk, flag, num_dupack, rexmit);\r\n\t\tif (icsk->icsk_ca_state != TCP_CA_Loss)\r\n\t\t\ttcp_update_rto_time(tp);\r\n\t\ttcp_identify_packet_loss(sk, ack_flag);\r\n\t\tif (!(icsk->icsk_ca_state == TCP_CA_Open ||\r\n\t\t      (*ack_flag & FLAG_LOST_RETRANS)))\r\n\t\t\treturn;\r\n\t\t/* Change state if cwnd is undone or retransmits are lost */\r\n\t\tfallthrough;\r\n\tdefault:\r\n\t\tif (tcp_is_reno(tp)) {\r\n\t\t\tif (flag & FLAG_SND_UNA_ADVANCED)\r\n\t\t\t\ttcp_reset_reno_sack(tp);\r\n\t\t\ttcp_add_reno_sack(sk, num_dupack, ece_ack);\r\n\t\t}\r\n\r\n\t\tif (icsk->icsk_ca_state <= TCP_CA_Disorder)\r\n\t\t\ttcp_try_undo_dsack(sk);\r\n\r\n\t\ttcp_identify_packet_loss(sk, ack_flag);\r\n\t\tif (!tcp_time_to_recover(tp)) {\r\n\t\t\ttcp_try_to_open(sk, flag);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t/* MTU probe failure: don't reduce cwnd */\r\n\t\tif (icsk->icsk_ca_state < TCP_CA_CWR &&\r\n\t\t    icsk->icsk_mtup.probe_size &&\r\n\t\t    tp->snd_una == tp->mtu_probe.probe_seq_start) {\r\n\t\t\ttcp_mtup_probe_failed(sk);\r\n\t\t\t/* Restores the reduction we did in tcp_mtup_probe() */\r\n\t\t\ttcp_snd_cwnd_set(tp, tcp_snd_cwnd(tp) + 1);\r\n\t\t\ttcp_simple_retransmit(sk);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t/* Otherwise enter Recovery state */\r\n\t\ttcp_enter_recovery(sk, ece_ack);\r\n\t}\r\n\r\n\t*rexmit = REXMIT_LOST;\r\n}", ".cp_enter_loss": "void tcp_enter_loss(struct sock *sk)\r\n{\r\n\tconst struct inet_connection_sock *icsk = inet_csk(sk);\r\n\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\tstruct net *net = sock_net(sk);\r\n\tbool new_recovery = icsk->icsk_ca_state < TCP_CA_Recovery;\r\n\tu8 reordering;\r\n\r\n\ttcp_timeout_mark_lost(sk);\r\n\r\n\t/* Reduce ssthresh if it has not yet been made inside this window. */\r\n\tif (icsk->icsk_ca_state <= TCP_CA_Disorder ||\r\n\t    !after(tp->high_seq, tp->snd_una) ||\r\n\t    (icsk->icsk_ca_state == TCP_CA_Loss && !icsk->icsk_retransmits)) {\r\n\t\ttp->prior_ssthresh = tcp_current_ssthresh(sk);\r\n\t\ttp->prior_cwnd = tcp_snd_cwnd(tp);\r\n\t\ttp->snd_ssthresh = icsk->icsk_ca_ops->ssthresh(sk);\r\n\t\ttcp_ca_event(sk, CA_EVENT_LOSS);\r\n\t\ttcp_init_undo(tp);\r\n\t}\r\n\ttcp_snd_cwnd_set(tp, tcp_packets_in_flight(tp) + 1);\r\n\ttp->snd_cwnd_cnt   = 0;\r\n\ttp->snd_cwnd_stamp = tcp_jiffies32;\r\n\r\n\t/* Timeout in disordered state after receiving substantial DUPACKs\r\n\t * suggests that the degree of reordering is over-estimated.\r\n\t */\r\n\treordering = READ_ONCE(net->ipv4.sysctl_tcp_reordering);\r\n\tif (icsk->icsk_ca_state <= TCP_CA_Disorder &&\r\n\t    tp->sacked_out >= reordering)\r\n\t\ttp->reordering = min_t(unsigned int, tp->reordering,\r\n\t\t\t\t       reordering);\r\n\r\n\ttcp_set_ca_state(sk, TCP_CA_Loss);\r\n\ttp->high_seq = tp->snd_nxt;\r\n\ttp->tlp_high_seq = 0;\r\n\ttcp_ecn_queue_cwr(tp);\r\n\r\n\t/* F-RTO RFC5682 sec 3.1 step 1: retransmit SND.UNA if no previous\r\n\t * loss recovery is underway except recurring timeout(s) on\r\n\t * the same SND.UNA (sec 3.2). Disable F-RTO on path MTU probing\r\n\t */\r\n\ttp->frto = READ_ONCE(net->ipv4.sysctl_tcp_frto) &&\r\n\t\t   (new_recovery || icsk->icsk_retransmits) &&\r\n\t\t   !inet_csk(sk)->icsk_mtup.probe_size;\r\n}", ".cp_skb_spurious_retrans": "static bool tcp_skb_spurious_retrans(const struct tcp_sock *tp,\r\n\t\t\t\t     const struct sk_buff *skb)\r\n{\r\n\treturn (TCP_SKB_CB(skb)->sacked & TCPCB_RETRANS) &&\r\n\t       tcp_tsopt_ecr_before(tp, tcp_skb_timestamp_ts(tp->tcp_usec_ts, skb));\r\n}", ".cp_packet_delayed": "static inline bool tcp_packet_delayed(const struct tcp_sock *tp)\r\n{\r\n\tconst struct sock *sk = (const struct sock *)tp;\r\n\r\n\t/* Received an echoed timestamp before the first retransmission? */\r\n\tif (tp->retrans_stamp)\r\n\t\treturn tcp_tsopt_ecr_before(tp, tp->retrans_stamp);\r\n\r\n\t/* We set tp->retrans_stamp upon the first retransmission of a loss\r\n\t * recovery episode, so normally if tp->retrans_stamp is 0 then no\r\n\t * retransmission has happened yet (likely due to TSQ, which can cause\r\n\t * fast retransmits to be delayed). So if snd_una advanced while\r\n\t * (tp->retrans_stamp is 0 then apparently a packet was merely delayed,\r\n\t * not lost. But there are exceptions where we retransmit but then\r\n\t * clear tp->retrans_stamp, so we check for those exceptions.\r\n\t */\r\n\r\n\t/* (1) For non-SACK connections, tcp_is_non_sack_preventing_reopen()\r\n\t * clears tp->retrans_stamp when snd_una == high_seq.\r\n\t */\r\n\tif (!tcp_is_sack(tp) && !before(tp->snd_una, tp->high_seq))\r\n\t\treturn false;\r\n\r\n\t/* (2) In TCP_SYN_SENT tcp_clean_rtx_queue() clears tp->retrans_stamp\r\n\t * when setting FLAG_SYN_ACKED is set, even if the SYN was\r\n\t * retransmitted.\r\n\t */\r\n\tif (sk->sk_state == TCP_SYN_SENT)\r\n\t\treturn false;\r\n\r\n\treturn true;\t/* tp->retrans_stamp is zero; no retransmit yet */\r\n}", ".cp_may_undo": "static inline bool tcp_may_undo(const struct tcp_sock *tp)\r\n{\r\n\treturn tp->undo_marker && (!tp->undo_retrans || tcp_packet_delayed(tp));\r\n}", ".cp_retrans_stamp_cleanup": "static void tcp_retrans_stamp_cleanup(struct sock *sk)\r\n{\r\n\tif (!tcp_any_retrans_done(sk))\r\n\t\ttcp_sk(sk)->retrans_stamp = 0;\r\n}", ".cp_is_non_sack_preventing_reopen": "static bool tcp_is_non_sack_preventing_reopen(struct sock *sk)\r\n{\r\n\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\r\n\tif (tp->snd_una == tp->high_seq && tcp_is_reno(tp)) {\r\n\t\t/* Hold old state until something *above* high_seq\r\n\t\t * is ACKed. For Reno it is MUST to prevent false\r\n\t\t * fast retransmits (RFC2582). SACK TCP is safe. */\r\n\t\tif (!tcp_any_retrans_done(sk))\r\n\t\t\ttp->retrans_stamp = 0;\r\n\t\treturn true;\r\n\t}\r\n\treturn false;\r\n}", ".cp_try_keep_open": "static void tcp_try_keep_open(struct sock *sk)\r\n{\r\n\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\tint state = TCP_CA_Open;\r\n\r\n\tif (tcp_left_out(tp) || tcp_any_retrans_done(sk))\r\n\t\tstate = TCP_CA_Disorder;\r\n\r\n\tif (inet_csk(sk)->icsk_ca_state != state) {\r\n\t\ttcp_set_ca_state(sk, state);\r\n\t\ttp->high_seq = tp->snd_nxt;\r\n\t}\r\n}", ".cp_try_to_open": "static void tcp_try_to_open(struct sock *sk, int flag)\r\n{\r\n\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\r\n\ttcp_verify_left_out(tp);\r\n\r\n\tif (!tcp_any_retrans_done(sk))\r\n\t\ttp->retrans_stamp = 0;\r\n\r\n\tif (flag & FLAG_ECE)\r\n\t\ttcp_enter_cwr(sk);\r\n\r\n\tif (inet_csk(sk)->icsk_ca_state != TCP_CA_CWR) {\r\n\t\ttcp_try_keep_open(sk);\r\n\t}\r\n}", ".cp_rcv_synrecv_state_fastopen": "static void tcp_rcv_synrecv_state_fastopen(struct sock *sk)\r\n{\r\n\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\tstruct request_sock *req;\r\n\r\n\t/* If we are still handling the SYNACK RTO, see if timestamp ECR allows\r\n\t * undo. If peer SACKs triggered fast recovery, we can't undo here.\r\n\t */\r\n\tif (inet_csk(sk)->icsk_ca_state == TCP_CA_Loss && !tp->packets_out)\r\n\t\ttcp_try_undo_recovery(sk);\r\n\r\n\ttcp_update_rto_time(tp);\r\n\tWRITE_ONCE(inet_csk(sk)->icsk_retransmits, 0);\r\n\t/* In tcp_fastopen_synack_timer() on the first SYNACK RTO we set\r\n\t * retrans_stamp but don't enter CA_Loss, so in case that happened we\r\n\t * need to zero retrans_stamp here to prevent spurious\r\n\t * retransmits_timed_out(). However, if the ACK of our SYNACK caused us\r\n\t * to enter CA_Recovery then we need to leave retrans_stamp as it was\r\n\t * set entering CA_Recovery, for correct retransmits_timed_out() and\r\n\t * undo behavior.\r\n\t */\r\n\ttcp_retrans_stamp_cleanup(sk);\r\n\r\n\t/* Once we leave TCP_SYN_RECV or TCP_FIN_WAIT_1,\r\n\t * we no longer need req so release it.\r\n\t */\r\n\treq = rcu_dereference_protected(tp->fastopen_rsk,\r\n\t\t\t\t\tlockdep_sock_is_held(sk));\r\n\treqsk_fastopen_remove(sk, req, false);\r\n\r\n\t/* Re-arm the timer because data may have been sent out.\r\n\t * This is similar to the regular data transmission case\r\n\t * when new data has just been ack'ed.\r\n\t *\r\n\t * (TFO) - we could try to be more aggressive and\r\n\t * retransmitting any data sooner based on when they\r\n\t * are sent out.\r\n\t */\r\n\ttcp_rearm_rto(sk);\r\n}", ".cp_try_undo_recovery": "static bool tcp_try_undo_recovery(struct sock *sk)\r\n{\r\n\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\r\n\tif (tcp_may_undo(tp)) {\r\n\t\tint mib_idx;\r\n\r\n\t\t/* Happy end! We did not retransmit anything\r\n\t\t * or our original transmission succeeded.\r\n\t\t */\r\n\t\tDBGUNDO(sk, inet_csk(sk)->icsk_ca_state == TCP_CA_Loss ? \"loss\" : \"retrans\");\r\n\t\ttcp_undo_cwnd_reduction(sk, false);\r\n\t\tif (inet_csk(sk)->icsk_ca_state == TCP_CA_Loss)\r\n\t\t\tmib_idx = LINUX_MIB_TCPLOSSUNDO;\r\n\t\telse\r\n\t\t\tmib_idx = LINUX_MIB_TCPFULLUNDO;\r\n\r\n\t\tNET_INC_STATS(sock_net(sk), mib_idx);\r\n\t} else if (tp->rack.reo_wnd_persist) {\r\n\t\ttp->rack.reo_wnd_persist--;\r\n\t}\r\n\tif (tcp_is_non_sack_preventing_reopen(sk))\r\n\t\treturn true;\r\n\ttcp_set_ca_state(sk, TCP_CA_Open);\r\n\ttp->is_sack_reneg = 0;\r\n\treturn false;\r\n}", ".cp_try_undo_dsack": "static bool tcp_try_undo_dsack(struct sock *sk)\r\n{\r\n\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\r\n\tif (tp->undo_marker && !tp->undo_retrans) {\r\n\t\ttp->rack.reo_wnd_persist = min(TCP_RACK_RECOVERY_THRESH,\r\n\t\t\t\t\t       tp->rack.reo_wnd_persist + 1);\r\n\t\tDBGUNDO(sk, \"D-SACK\");\r\n\t\ttcp_undo_cwnd_reduction(sk, false);\r\n\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPDSACKUNDO);\r\n\t\treturn true;\r\n\t}\r\n\treturn false;\r\n}", ".cp_try_undo_loss": "static bool tcp_try_undo_loss(struct sock *sk, bool frto_undo)\r\n{\r\n\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\r\n\tif (frto_undo || tcp_may_undo(tp)) {\r\n\t\ttcp_undo_cwnd_reduction(sk, true);\r\n\r\n\t\tDBGUNDO(sk, \"partial loss\");\r\n\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPLOSSUNDO);\r\n\t\tif (frto_undo)\r\n\t\t\tNET_INC_STATS(sock_net(sk),\r\n\t\t\t\t\tLINUX_MIB_TCPSPURIOUSRTOS);\r\n\t\tWRITE_ONCE(inet_csk(sk)->icsk_retransmits, 0);\r\n\t\tif (tcp_is_non_sack_preventing_reopen(sk))\r\n\t\t\treturn true;\r\n\t\tif (frto_undo || tcp_is_sack(tp)) {\r\n\t\t\ttcp_set_ca_state(sk, TCP_CA_Open);\r\n\t\t\ttp->is_sack_reneg = 0;\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\treturn false;\r\n}", ".cp_synack_rtt_meas": "void tcp_synack_rtt_meas(struct sock *sk, struct request_sock *req)\r\n{\r\n\tstruct rate_sample rs;\r\n\tlong rtt_us = -1L;\r\n\r\n\tif (req && !req->num_retrans && tcp_rsk(req)->snt_synack)\r\n\t\trtt_us = tcp_stamp_us_delta(tcp_clock_us(), tcp_rsk(req)->snt_synack);\r\n\r\n\ttcp_ack_update_rtt(sk, FLAG_SYN_ACKED, rtt_us, -1L, rtt_us, &rs);\r\n}", ".cp_set_xmit_timer": "static void tcp_set_xmit_timer(struct sock *sk)\r\n{\r\n\tif (!tcp_schedule_loss_probe(sk, true))\r\n\t\ttcp_rearm_rto(sk);\r\n}", ".cp_ack_update_window": "static int tcp_ack_update_window(struct sock *sk, const struct sk_buff *skb, u32 ack,\r\n\t\t\t\t u32 ack_seq)\r\n{\r\n\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\tint flag = 0;\r\n\tu32 nwin = ntohs(tcp_hdr(skb)->window);\r\n\r\n\tif (likely(!tcp_hdr(skb)->syn))\r\n\t\tnwin <<= tp->rx_opt.snd_wscale;\r\n\r\n\tif (tcp_may_update_window(tp, ack, ack_seq, nwin)) {\r\n\t\tflag |= FLAG_WIN_UPDATE;\r\n\t\ttcp_update_wl(tp, ack_seq);\r\n\r\n\t\tif (tp->snd_wnd != nwin) {\r\n\t\t\ttp->snd_wnd = nwin;\r\n\r\n\t\t\t/* Note, it is the only place, where\r\n\t\t\t * fast path is recovered for sending TCP.\r\n\t\t\t */\r\n\t\t\ttp->pred_flags = 0;\r\n\t\t\ttcp_fast_path_check(sk);\r\n\r\n\t\t\tif (!tcp_write_queue_empty(sk))\r\n\t\t\t\ttcp_slow_start_after_idle_check(sk);\r\n\r\n\t\t\tif (nwin > tp->max_window) {\r\n\t\t\t\ttp->max_window = nwin;\r\n\t\t\t\ttcp_sync_mss(sk, inet_csk(sk)->icsk_pmtu_cookie);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\ttcp_snd_una_update(tp, ack);\r\n\r\n\treturn flag;\r\n}", ".cp_disordered_ack_check": "static enum skb_drop_reason tcp_disordered_ack_check(const struct sock *sk,\r\n\t\t\t\t\t\t     const struct sk_buff *skb)\r\n{\r\n\tconst struct tcp_sock *tp = tcp_sk(sk);\r\n\tconst struct tcphdr *th = tcp_hdr(skb);\r\n\tSKB_DR_INIT(reason, TCP_RFC7323_PAWS);\r\n\tu32 ack = TCP_SKB_CB(skb)->ack_seq;\r\n\tu32 seq = TCP_SKB_CB(skb)->seq;\r\n\r\n\t/* 1. Is this not a pure ACK ? */\r\n\tif (!th->ack || seq != TCP_SKB_CB(skb)->end_seq)\r\n\t\treturn reason;\r\n\r\n\t/* 2. Is its sequence not the expected one ? */\r\n\tif (seq != tp->rcv_nxt)\r\n\t\treturn before(seq, tp->rcv_nxt) ?\r\n\t\t\tSKB_DROP_REASON_TCP_RFC7323_PAWS_ACK :\r\n\t\t\treason;\r\n\r\n\t/* 3. Is this not a duplicate ACK ? */\r\n\tif (ack != tp->snd_una)\r\n\t\treturn reason;\r\n\r\n\t/* 4. Is this updating the window ? */\r\n\tif (tcp_may_update_window(tp, ack, seq, ntohs(th->window) <<\r\n\t\t\t\t\t\ttp->rx_opt.snd_wscale))\r\n\t\treturn reason;\r\n\r\n\t/* 5. Is this not in the replay window ? */\r\n\tif ((s32)(tp->rx_opt.ts_recent - tp->rx_opt.rcv_tsval) >\r\n\t    tcp_tsval_replay(sk))\r\n\t\treturn reason;\r\n\r\n\treturn 0;\r\n}", ".cp_snd_una_update": "static void tcp_snd_una_update(struct tcp_sock *tp, u32 ack)\r\n{\r\n\tu32 delta = ack - tp->snd_una;\r\n\r\n\tsock_owned_by_me((struct sock *)tp);\r\n\ttp->bytes_acked += delta;\r\n\ttcp_snd_sne_update(tp, ack);\r\n\ttp->snd_una = ack;\r\n}", ".cp_rcv_nxt_update": "static void tcp_rcv_nxt_update(struct tcp_sock *tp, u32 seq)\r\n{\r\n\tu32 delta = seq - tp->rcv_nxt;\r\n\r\n\tsock_owned_by_me((struct sock *)tp);\r\n\ttp->bytes_received += delta;\r\n\ttcp_rcv_sne_update(tp, seq);\r\n\tWRITE_ONCE(tp->rcv_nxt, seq);\r\n}", ".cp_queue_rcv": "static int __must_check tcp_queue_rcv(struct sock *sk, struct sk_buff *skb,\r\n\t\t\t\t      bool *fragstolen)\r\n{\r\n\tint eaten;\r\n\tstruct sk_buff *tail = skb_peek_tail(&sk->sk_receive_queue);\r\n\r\n\teaten = (tail &&\r\n\t\t tcp_try_coalesce(sk, tail,\r\n\t\t\t\t  skb, fragstolen)) ? 1 : 0;\r\n\ttcp_rcv_nxt_update(tcp_sk(sk), TCP_SKB_CB(skb)->end_seq);\r\n\tif (!eaten) {\r\n\t\ttcp_add_receive_queue(sk, skb);\r\n\t\tskb_set_owner_r(skb, sk);\r\n\t}\r\n\treturn eaten;\r\n}", ".cp_send_challenge_ack": "static void tcp_send_challenge_ack(struct sock *sk, bool accecn_reflector)\r\n{\r\n\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\tstruct net *net = sock_net(sk);\r\n\tu32 count, now, ack_limit;\r\n\r\n\t/* First check our per-socket dupack rate limit. */\r\n\tif (__tcp_oow_rate_limited(net,\r\n\t\t\t\t   LINUX_MIB_TCPACKSKIPPEDCHALLENGE,\r\n\t\t\t\t   &tp->last_oow_ack_time))\r\n\t\treturn;\r\n\r\n\tack_limit = READ_ONCE(net->ipv4.sysctl_tcp_challenge_ack_limit);\r\n\tif (ack_limit == INT_MAX)\r\n\t\tgoto send_ack;\r\n\r\n\t/* Then check host-wide RFC 5961 rate limit. */\r\n\tnow = jiffies / HZ;\r\n\tif (now != READ_ONCE(net->ipv4.tcp_challenge_timestamp)) {\r\n\t\tu32 half = (ack_limit + 1) >> 1;\r\n\r\n\t\tWRITE_ONCE(net->ipv4.tcp_challenge_timestamp, now);\r\n\t\tWRITE_ONCE(net->ipv4.tcp_challenge_count,\r\n\t\t\t   get_random_u32_inclusive(half, ack_limit + half - 1));\r\n\t}\r\n\tcount = READ_ONCE(net->ipv4.tcp_challenge_count);\r\n\tif (count > 0) {\r\n\t\tWRITE_ONCE(net->ipv4.tcp_challenge_count, count - 1);\r\nsend_ack:\r\n\t\tNET_INC_STATS(net, LINUX_MIB_TCPCHALLENGEACK);\r\n\t\ttcp_send_ack_reflect_ect(sk, accecn_reflector);\r\n\t}\r\n}", ".cp_parse_options": "void tcp_parse_options(const struct net *net,\r\n\t\t       const struct sk_buff *skb,\r\n\t\t       struct tcp_options_received *opt_rx, int estab,\r\n\t\t       struct tcp_fastopen_cookie *foc)\r\n{\r\n\tconst unsigned char *ptr;\r\n\tconst struct tcphdr *th = tcp_hdr(skb);\r\n\tint length = (th->doff * 4) - sizeof(struct tcphdr);\r\n\r\n\tptr = (const unsigned char *)(th + 1);\r\n\topt_rx->saw_tstamp = 0;\r\n\topt_rx->accecn = 0;\r\n\topt_rx->saw_unknown = 0;\r\n\r\n\twhile (length > 0) {\r\n\t\tint opcode = *ptr++;\r\n\t\tint opsize;\r\n\r\n\t\tswitch (opcode) {\r\n\t\tcase TCPOPT_EOL:\r\n\t\t\treturn;\r\n\t\tcase TCPOPT_NOP:\t/* Ref: RFC 793 section 3.1 */\r\n\t\t\tlength--;\r\n\t\t\tcontinue;\r\n\t\tdefault:\r\n\t\t\tif (length < 2)\r\n\t\t\t\treturn;\r\n\t\t\topsize = *ptr++;\r\n\t\t\tif (opsize < 2) /* \"silly options\" */\r\n\t\t\t\treturn;\r\n\t\t\tif (opsize > length)\r\n\t\t\t\treturn;\t/* don't parse partial options */\r\n\t\t\tswitch (opcode) {\r\n\t\t\tcase TCPOPT_MSS:\r\n\t\t\t\tif (opsize == TCPOLEN_MSS && th->syn && !estab) {\r\n\t\t\t\t\tu16 in_mss = get_unaligned_be16(ptr);\r\n\t\t\t\t\tif (in_mss) {\r\n\t\t\t\t\t\tif (opt_rx->user_mss &&\r\n\t\t\t\t\t\t    opt_rx->user_mss < in_mss)\r\n\t\t\t\t\t\t\tin_mss = opt_rx->user_mss;\r\n\t\t\t\t\t\topt_rx->mss_clamp = in_mss;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase TCPOPT_WINDOW:\r\n\t\t\t\tif (opsize == TCPOLEN_WINDOW && th->syn &&\r\n\t\t\t\t    !estab && READ_ONCE(net->ipv4.sysctl_tcp_window_scaling)) {\r\n\t\t\t\t\t__u8 snd_wscale = *(__u8 *)ptr;\r\n\t\t\t\t\topt_rx->wscale_ok = 1;\r\n\t\t\t\t\tif (snd_wscale > TCP_MAX_WSCALE) {\r\n\t\t\t\t\t\tnet_info_ratelimited(\"%s: Illegal window scaling value %d > %u received\\n\",\r\n\t\t\t\t\t\t\t\t     __func__,\r\n\t\t\t\t\t\t\t\t     snd_wscale,\r\n\t\t\t\t\t\t\t\t     TCP_MAX_WSCALE);\r\n\t\t\t\t\t\tsnd_wscale = TCP_MAX_WSCALE;\r\n\t\t\t\t\t}\r\n\t\t\t\t\topt_rx->snd_wscale = snd_wscale;\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase TCPOPT_TIMESTAMP:\r\n\t\t\t\tif ((opsize == TCPOLEN_TIMESTAMP) &&\r\n\t\t\t\t    ((estab && opt_rx->tstamp_ok) ||\r\n\t\t\t\t     (!estab && READ_ONCE(net->ipv4.sysctl_tcp_timestamps)))) {\r\n\t\t\t\t\topt_rx->saw_tstamp = 1;\r\n\t\t\t\t\topt_rx->rcv_tsval = get_unaligned_be32(ptr);\r\n\t\t\t\t\topt_rx->rcv_tsecr = get_unaligned_be32(ptr + 4);\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase TCPOPT_SACK_PERM:\r\n\t\t\t\tif (opsize == TCPOLEN_SACK_PERM && th->syn &&\r\n\t\t\t\t    !estab && READ_ONCE(net->ipv4.sysctl_tcp_sack)) {\r\n\t\t\t\t\topt_rx->sack_ok = TCP_SACK_SEEN;\r\n\t\t\t\t\ttcp_sack_reset(opt_rx);\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase TCPOPT_SACK:\r\n\t\t\t\tif ((opsize >= (TCPOLEN_SACK_BASE + TCPOLEN_SACK_PERBLOCK)) &&\r\n\t\t\t\t   !((opsize - TCPOLEN_SACK_BASE) % TCPOLEN_SACK_PERBLOCK) &&\r\n\t\t\t\t   opt_rx->sack_ok) {\r\n\t\t\t\t\tTCP_SKB_CB(skb)->sacked = (ptr - 2) - (unsigned char *)th;\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n#ifdef CONFIG_TCP_MD5SIG\r\n\t\t\tcase TCPOPT_MD5SIG:\r\n\t\t\t\t/* The MD5 Hash has already been\r\n\t\t\t\t * checked (see tcp_v{4,6}_rcv()).\r\n\t\t\t\t */\r\n\t\t\t\tbreak;\r\n#endif\r\n#ifdef CONFIG_TCP_AO\r\n\t\t\tcase TCPOPT_AO:\r\n\t\t\t\t/* TCP AO has already been checked\r\n\t\t\t\t * (see tcp_inbound_ao_hash()).\r\n\t\t\t\t */\r\n\t\t\t\tbreak;\r\n#endif\r\n\t\t\tcase TCPOPT_FASTOPEN:\r\n\t\t\t\ttcp_parse_fastopen_option(\r\n\t\t\t\t\topsize - TCPOLEN_FASTOPEN_BASE,\r\n\t\t\t\t\tptr, th->syn, foc, false);\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase TCPOPT_ACCECN0:\r\n\t\t\tcase TCPOPT_ACCECN1:\r\n\t\t\t\t/* Save offset of AccECN option in TCP header */\r\n\t\t\t\topt_rx->accecn = (ptr - 2) - (__u8 *)th;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase TCPOPT_EXP:\r\n\t\t\t\t/* Fast Open option shares code 254 using a\r\n\t\t\t\t * 16 bits magic number.\r\n\t\t\t\t */\r\n\t\t\t\tif (opsize >= TCPOLEN_EXP_FASTOPEN_BASE &&\r\n\t\t\t\t    get_unaligned_be16(ptr) ==\r\n\t\t\t\t    TCPOPT_FASTOPEN_MAGIC) {\r\n\t\t\t\t\ttcp_parse_fastopen_option(opsize -\r\n\t\t\t\t\t\tTCPOLEN_EXP_FASTOPEN_BASE,\r\n\t\t\t\t\t\tptr + 2, th->syn, foc, true);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (smc_parse_options(th, opt_rx, ptr, opsize))\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\topt_rx->saw_unknown = 1;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tdefault:\r\n\t\t\t\topt_rx->saw_unknown = 1;\r\n\t\t\t}\r\n\t\t\tptr += opsize-2;\r\n\t\t\tlength -= opsize;\r\n\t\t}\r\n\t}\r\n}", ".cp_get_syncookie_mss": "u16 tcp_get_syncookie_mss(struct request_sock_ops *rsk_ops,\r\n\t\t\t  const struct tcp_request_sock_ops *af_ops,\r\n\t\t\t  struct sock *sk, struct tcphdr *th)\r\n{\r\n\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\tu16 mss;\r\n\r\n\tif (READ_ONCE(sock_net(sk)->ipv4.sysctl_tcp_syncookies) != 2 &&\r\n\t    !inet_csk_reqsk_queue_is_full(sk))\r\n\t\treturn 0;\r\n\r\n\tif (!tcp_syn_flood_action(sk, rsk_ops->slab_name))\r\n\t\treturn 0;\r\n\r\n\tif (sk_acceptq_is_full(sk)) {\r\n\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_LISTENOVERFLOWS);\r\n\t\treturn 0;\r\n\t}\r\n\r\n\tmss = tcp_parse_mss_option(th, READ_ONCE(tp->rx_opt.user_mss));\r\n\tif (!mss)\r\n\t\tmss = af_ops->mss_clamp;\r\n\r\n\treturn mss;\r\n}", ".cp_fast_parse_options": "static bool tcp_fast_parse_options(const struct net *net,\r\n\t\t\t\t   const struct sk_buff *skb,\r\n\t\t\t\t   const struct tcphdr *th, struct tcp_sock *tp)\r\n{\r\n\t/* In the spirit of fast parsing, compare doff directly to constant\r\n\t * values.  Because equality is used, short doff can be ignored here.\r\n\t */\r\n\tif (th->doff == (sizeof(*th) / 4)) {\r\n\t\ttp->rx_opt.saw_tstamp = 0;\r\n\t\ttp->rx_opt.accecn = 0;\r\n\t\treturn false;\r\n\t} else if (tp->rx_opt.tstamp_ok &&\r\n\t\t   th->doff == ((sizeof(*th) + TCPOLEN_TSTAMP_ALIGNED) / 4)) {\r\n\t\tif (tcp_parse_aligned_timestamp(tp, th)) {\r\n\t\t\ttp->rx_opt.accecn = 0;\r\n\t\t\treturn true;\r\n\t\t}\r\n\t}\r\n\r\n\ttcp_parse_options(net, skb, &tp->rx_opt, 1, NULL);\r\n\tif (tp->rx_opt.saw_tstamp && tp->rx_opt.rcv_tsecr)\r\n\t\ttp->rx_opt.rcv_tsecr -= tp->tsoffset;\r\n\r\n\treturn true;\r\n}", ".cp_conn_request": "int tcp_conn_request(struct request_sock_ops *rsk_ops,\r\n\t\t     const struct tcp_request_sock_ops *af_ops,\r\n\t\t     struct sock *sk, struct sk_buff *skb)\r\n{\r\n\tstruct tcp_fastopen_cookie foc = { .len = -1 };\r\n\tstruct tcp_options_received tmp_opt;\r\n\tconst struct tcp_sock *tp = tcp_sk(sk);\r\n\tstruct net *net = sock_net(sk);\r\n\tstruct sock *fastopen_sk = NULL;\r\n\tstruct request_sock *req;\r\n\tbool want_cookie = false;\r\n\tstruct dst_entry *dst;\r\n\tstruct flowi fl;\r\n\tu8 syncookies;\r\n\tu32 isn;\r\n\r\n#ifdef CONFIG_TCP_AO\r\n\tconst struct tcp_ao_hdr *aoh;\r\n#endif\r\n\r\n\tisn = __this_cpu_read(tcp_tw_isn);\r\n\tif (isn) {\r\n\t\t/* TW buckets are converted to open requests without\r\n\t\t * limitations, they conserve resources and peer is\r\n\t\t * evidently real one.\r\n\t\t */\r\n\t\t__this_cpu_write(tcp_tw_isn, 0);\r\n\t} else {\r\n\t\tsyncookies = READ_ONCE(net->ipv4.sysctl_tcp_syncookies);\r\n\r\n\t\tif (syncookies == 2 || inet_csk_reqsk_queue_is_full(sk)) {\r\n\t\t\twant_cookie = tcp_syn_flood_action(sk,\r\n\t\t\t\t\t\t\t   rsk_ops->slab_name);\r\n\t\t\tif (!want_cookie)\r\n\t\t\t\tgoto drop;\r\n\t\t}\r\n\t}\r\n\r\n\tif (sk_acceptq_is_full(sk)) {\r\n\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_LISTENOVERFLOWS);\r\n\t\tgoto drop;\r\n\t}\r\n\r\n\treq = inet_reqsk_alloc(rsk_ops, sk, !want_cookie);\r\n\tif (!req)\r\n\t\tgoto drop;\r\n\r\n\treq->syncookie = want_cookie;\r\n\ttcp_rsk(req)->af_specific = af_ops;\r\n\ttcp_rsk(req)->ts_off = 0;\r\n\ttcp_rsk(req)->req_usec_ts = false;\r\n#if IS_ENABLED(CONFIG_MPTCP)\r\n\ttcp_rsk(req)->is_mptcp = 0;\r\n#endif\r\n\r\n\ttcp_clear_options(&tmp_opt);\r\n\ttmp_opt.mss_clamp = af_ops->mss_clamp;\r\n\ttmp_opt.user_mss  = READ_ONCE(tp->rx_opt.user_mss);\r\n\ttcp_parse_options(sock_net(sk), skb, &tmp_opt, 0,\r\n\t\t\t  want_cookie ? NULL : &foc);\r\n\r\n\tif (want_cookie && !tmp_opt.saw_tstamp)\r\n\t\ttcp_clear_options(&tmp_opt);\r\n\r\n\tif (IS_ENABLED(CONFIG_SMC) && want_cookie)\r\n\t\ttmp_opt.smc_ok = 0;\r\n\r\n\ttmp_opt.tstamp_ok = tmp_opt.saw_tstamp;\r\n\ttcp_openreq_init(req, &tmp_opt, skb, sk);\r\n\tinet_rsk(req)->no_srccheck = inet_test_bit(TRANSPARENT, sk);\r\n\r\n\t/* Note: tcp_v6_init_req() might override ir_iif for link locals */\r\n\tinet_rsk(req)->ir_iif = inet_request_bound_dev_if(sk, skb);\r\n\r\n\tdst = af_ops->route_req(sk, skb, &fl, req, isn);\r\n\tif (!dst)\r\n\t\tgoto drop_and_free;\r\n\r\n\tif (tmp_opt.tstamp_ok) {\r\n\t\ttcp_rsk(req)->req_usec_ts = dst_tcp_usec_ts(dst);\r\n\t\ttcp_rsk(req)->ts_off = af_ops->init_ts_off(net, skb);\r\n\t}\r\n\tif (!want_cookie && !isn) {\r\n\t\tint max_syn_backlog = READ_ONCE(net->ipv4.sysctl_max_syn_backlog);\r\n\r\n\t\t/* Kill the following clause, if you dislike this way. */\r\n\t\tif (!syncookies &&\r\n\t\t    (max_syn_backlog - inet_csk_reqsk_queue_len(sk) <\r\n\t\t     (max_syn_backlog >> 2)) &&\r\n\t\t    !tcp_peer_is_proven(req, dst)) {\r\n\t\t\t/* Without syncookies last quarter of\r\n\t\t\t * backlog is filled with destinations,\r\n\t\t\t * proven to be alive.\r\n\t\t\t * It means that we continue to communicate\r\n\t\t\t * to destinations, already remembered\r\n\t\t\t * to the moment of synflood.\r\n\t\t\t */\r\n\t\t\tpr_drop_req(req, ntohs(tcp_hdr(skb)->source),\r\n\t\t\t\t    rsk_ops->family);\r\n\t\t\tgoto drop_and_release;\r\n\t\t}\r\n\r\n\t\tisn = af_ops->init_seq(skb);\r\n\t}\r\n\r\n\ttcp_ecn_create_request(req, skb, sk, dst);\r\n\r\n\tif (want_cookie) {\r\n\t\tisn = cookie_init_sequence(af_ops, sk, skb, &req->mss);\r\n\t\tif (!tmp_opt.tstamp_ok)\r\n\t\t\tinet_rsk(req)->ecn_ok = 0;\r\n\t}\r\n\r\n#ifdef CONFIG_TCP_AO\r\n\tif (tcp_parse_auth_options(tcp_hdr(skb), NULL, &aoh))\r\n\t\tgoto drop_and_release; /* Invalid TCP options */\r\n\tif (aoh) {\r\n\t\ttcp_rsk(req)->used_tcp_ao = true;\r\n\t\ttcp_rsk(req)->ao_rcv_next = aoh->keyid;\r\n\t\ttcp_rsk(req)->ao_keyid = aoh->rnext_keyid;\r\n\r\n\t} else {\r\n\t\ttcp_rsk(req)->used_tcp_ao = false;\r\n\t}\r\n#endif\r\n\ttcp_rsk(req)->snt_isn = isn;\r\n\ttcp_rsk(req)->txhash = net_tx_rndhash();\r\n\ttcp_rsk(req)->syn_tos = TCP_SKB_CB(skb)->ip_dsfield;\r\n\ttcp_openreq_init_rwin(req, sk, dst);\r\n\tsk_rx_queue_set(req_to_sk(req), skb);\r\n\tif (!want_cookie) {\r\n\t\ttcp_reqsk_record_syn(sk, req, skb);\r\n\t\tfastopen_sk = tcp_try_fastopen(sk, skb, req, &foc, dst);\r\n\t}\r\n\tif (fastopen_sk) {\r\n\t\taf_ops->send_synack(fastopen_sk, dst, &fl, req,\r\n\t\t\t\t    &foc, TCP_SYNACK_FASTOPEN, skb);\r\n\t\t/* Add the child socket directly into the accept queue */\r\n\t\tif (!inet_csk_reqsk_queue_add(sk, req, fastopen_sk)) {\r\n\t\t\treqsk_fastopen_remove(fastopen_sk, req, false);\r\n\t\t\tbh_unlock_sock(fastopen_sk);\r\n\t\t\tsock_put(fastopen_sk);\r\n\t\t\tgoto drop_and_free;\r\n\t\t}\r\n\t\tsk->sk_data_ready(sk);\r\n\t\tbh_unlock_sock(fastopen_sk);\r\n\t\tsock_put(fastopen_sk);\r\n\t} else {\r\n\t\ttcp_rsk(req)->tfo_listener = false;\r\n\t\tif (!want_cookie) {\r\n\t\t\treq->timeout = tcp_timeout_init((struct sock *)req);\r\n\t\t\tif (unlikely(!inet_csk_reqsk_queue_hash_add(sk, req,\r\n\t\t\t\t\t\t\t\t    req->timeout))) {\r\n\t\t\t\treqsk_free(req);\r\n\t\t\t\tdst_release(dst);\r\n\t\t\t\treturn 0;\r\n\t\t\t}\r\n\r\n\t\t}\r\n\t\taf_ops->send_synack(sk, dst, &fl, req, &foc,\r\n\t\t\t\t    !want_cookie ? TCP_SYNACK_NORMAL :\r\n\t\t\t\t\t\t   TCP_SYNACK_COOKIE,\r\n\t\t\t\t    skb);\r\n\t\tif (want_cookie) {\r\n\t\t\treqsk_free(req);\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t}\r\n\treqsk_put(req);\r\n\treturn 0;\r\n\r\ndrop_and_release:\r\n\tdst_release(dst);\r\ndrop_and_free:\r\n\t__reqsk_free(req);\r\ndrop:\r\n\ttcp_listendrop(sk);\r\n\treturn 0;\r\n}", ".cp_reset": "void tcp_reset(struct sock *sk, struct sk_buff *skb)\r\n{\r\n\tint err;\r\n\r\n\ttrace_tcp_receive_reset(sk);\r\n\r\n\t/* mptcp can't tell us to ignore reset pkts,\r\n\t * so just ignore the return value of mptcp_incoming_options().\r\n\t */\r\n\tif (sk_is_mptcp(sk))\r\n\t\tmptcp_incoming_options(sk, skb);\r\n\r\n\t/* We want the right error as BSD sees it (and indeed as we do). */\r\n\tswitch (sk->sk_state) {\r\n\tcase TCP_SYN_SENT:\r\n\t\terr = ECONNREFUSED;\r\n\t\tbreak;\r\n\tcase TCP_CLOSE_WAIT:\r\n\t\terr = EPIPE;\r\n\t\tbreak;\r\n\tcase TCP_CLOSE:\r\n\t\treturn;\r\n\tdefault:\r\n\t\terr = ECONNRESET;\r\n\t}\r\n\ttcp_done_with_error(sk, err);\r\n}", ".cp_dsack_extend": "static void tcp_dsack_extend(struct sock *sk, u32 seq, u32 end_seq)\r\n{\r\n\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\r\n\tif (!tp->rx_opt.dsack)\r\n\t\ttcp_dsack_set(sk, seq, end_seq);\r\n\telse\r\n\t\ttcp_sack_extend(tp->duplicate_sack, seq, end_seq);\r\n}", ".cp_sack_maybe_coalesce": "static void tcp_sack_maybe_coalesce(struct tcp_sock *tp)\r\n{\r\n\tint this_sack;\r\n\tstruct tcp_sack_block *sp = &tp->selective_acks[0];\r\n\tstruct tcp_sack_block *swalk = sp + 1;\r\n\r\n\t/* See if the recent change to the first SACK eats into\r\n\t * or hits the sequence space of other SACK blocks, if so coalesce.\r\n\t */\r\n\tfor (this_sack = 1; this_sack < tp->rx_opt.num_sacks;) {\r\n\t\tif (tcp_sack_extend(sp, swalk->start_seq, swalk->end_seq)) {\r\n\t\t\tint i;\r\n\r\n\t\t\t/* Zap SWALK, by moving every further SACK up by one slot.\r\n\t\t\t * Decrease num_sacks.\r\n\t\t\t */\r\n\t\t\ttp->rx_opt.num_sacks--;\r\n\t\t\tfor (i = this_sack; i < tp->rx_opt.num_sacks; i++)\r\n\t\t\t\tsp[i] = sp[i + 1];\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tthis_sack++;\r\n\t\tswalk++;\r\n\t}\r\n}", ".cp_sack_new_ofo_skb": "static void tcp_sack_new_ofo_skb(struct sock *sk, u32 seq, u32 end_seq)\r\n{\r\n\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\tstruct tcp_sack_block *sp = &tp->selective_acks[0];\r\n\tint cur_sacks = tp->rx_opt.num_sacks;\r\n\tint this_sack;\r\n\r\n\tif (!cur_sacks)\r\n\t\tgoto new_sack;\r\n\r\n\tfor (this_sack = 0; this_sack < cur_sacks; this_sack++, sp++) {\r\n\t\tif (tcp_sack_extend(sp, seq, end_seq)) {\r\n\t\t\tif (this_sack >= TCP_SACK_BLOCKS_EXPECTED)\r\n\t\t\t\ttcp_sack_compress_send_ack(sk);\r\n\t\t\t/* Rotate this_sack to the first one. */\r\n\t\t\tfor (; this_sack > 0; this_sack--, sp--)\r\n\t\t\t\tswap(*sp, *(sp - 1));\r\n\t\t\tif (cur_sacks > 1)\r\n\t\t\t\ttcp_sack_maybe_coalesce(tp);\r\n\t\t\treturn;\r\n\t\t}\r\n\t}\r\n\r\n\tif (this_sack >= TCP_SACK_BLOCKS_EXPECTED)\r\n\t\ttcp_sack_compress_send_ack(sk);\r\n\r\n\t/* Could not find an adjacent existing SACK, build a new one,\r\n\t * put it at the front, and shift everyone else down.  We\r\n\t * always know there is at least one SACK present already here.\r\n\t *\r\n\t * If the sack array is full, forget about the last one.\r\n\t */\r\n\tif (this_sack >= TCP_NUM_SACKS) {\r\n\t\tthis_sack--;\r\n\t\ttp->rx_opt.num_sacks--;\r\n\t\tsp--;\r\n\t}\r\n\tfor (; this_sack > 0; this_sack--, sp--)\r\n\t\t*sp = *(sp - 1);\r\n\r\nnew_sack:\r\n\t/* Build the new head SACK, and we're done. */\r\n\tsp->start_seq = seq;\r\n\tsp->end_seq = end_seq;\r\n\ttp->rx_opt.num_sacks++;\r\n}", ".cp_ooo_try_coalesce": "static bool tcp_ooo_try_coalesce(struct sock *sk,\r\n\t\t\t     struct sk_buff *to,\r\n\t\t\t     struct sk_buff *from,\r\n\t\t\t     bool *fragstolen)\r\n{\r\n\tbool res = tcp_try_coalesce(sk, to, from, fragstolen);\r\n\r\n\t/* In case tcp_drop_reason() is called later, update to->gso_segs */\r\n\tif (res) {\r\n\t\tu32 gso_segs = max_t(u16, 1, skb_shinfo(to)->gso_segs) +\r\n\t\t\t       max_t(u16, 1, skb_shinfo(from)->gso_segs);\r\n\r\n\t\tskb_shinfo(to)->gso_segs = min_t(u32, gso_segs, 0xFFFF);\r\n\t}\r\n\treturn res;\r\n}", ".cp_try_rmem_schedule": "static int tcp_try_rmem_schedule(struct sock *sk, const struct sk_buff *skb,\r\n\t\t\t\t unsigned int size)\r\n{\r\n\tif (!tcp_can_ingest(sk, skb) ||\r\n\t    !sk_rmem_schedule(sk, skb, size)) {\r\n\r\n\t\tif (tcp_prune_queue(sk, skb) < 0)\r\n\t\t\treturn -1;\r\n\r\n\t\twhile (!sk_rmem_schedule(sk, skb, size)) {\r\n\t\t\tif (!tcp_prune_ofo_queue(sk, skb))\r\n\t\t\t\treturn -1;\r\n\t\t}\r\n\t}\r\n\treturn 0;\r\n}", ".cp_prune_ofo_queue": "static bool tcp_prune_ofo_queue(struct sock *sk, const struct sk_buff *in_skb)\r\n{\r\n\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\tstruct rb_node *node, *prev;\r\n\tbool pruned = false;\r\n\tint goal;\r\n\r\n\tif (RB_EMPTY_ROOT(&tp->out_of_order_queue))\r\n\t\treturn false;\r\n\r\n\tgoal = sk->sk_rcvbuf >> 3;\r\n\tnode = &tp->ooo_last_skb->rbnode;\r\n\r\n\tdo {\r\n\t\tstruct sk_buff *skb = rb_to_skb(node);\r\n\r\n\t\t/* If incoming skb would land last in ofo queue, stop pruning. */\r\n\t\tif (after(TCP_SKB_CB(in_skb)->seq, TCP_SKB_CB(skb)->seq))\r\n\t\t\tbreak;\r\n\t\tpruned = true;\r\n\t\tprev = rb_prev(node);\r\n\t\trb_erase(node, &tp->out_of_order_queue);\r\n\t\tgoal -= skb->truesize;\r\n\t\ttcp_drop_reason(sk, skb, SKB_DROP_REASON_TCP_OFO_QUEUE_PRUNE);\r\n\t\ttp->ooo_last_skb = rb_to_skb(prev);\r\n\t\tif (!prev || goal <= 0) {\r\n\t\t\tif (tcp_can_ingest(sk, in_skb) &&\r\n\t\t\t    !tcp_under_memory_pressure(sk))\r\n\t\t\t\tbreak;\r\n\t\t\tgoal = sk->sk_rcvbuf >> 3;\r\n\t\t}\r\n\t\tnode = prev;\r\n\t} while (node);\r\n\r\n\tif (pruned) {\r\n\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_OFOPRUNED);\r\n\t\t/* Reset SACK state.  A conforming SACK implementation will\r\n\t\t * do the same at a timeout based retransmit.  When a connection\r\n\t\t * is in a sad state like this, we care only about integrity\r\n\t\t * of the connection not performance.\r\n\t\t */\r\n\t\tif (tp->rx_opt.sack_ok)\r\n\t\t\ttcp_sack_reset(&tp->rx_opt);\r\n\t}\r\n\treturn pruned;\r\n}", ".cp_send_rcvq": "int tcp_send_rcvq(struct sock *sk, struct msghdr *msg, size_t size)\r\n{\r\n\tstruct sk_buff *skb;\r\n\tint err = -ENOMEM;\r\n\tint data_len = 0;\r\n\tbool fragstolen;\r\n\r\n\tif (size == 0)\r\n\t\treturn 0;\r\n\r\n\tif (size > PAGE_SIZE) {\r\n\t\tint npages = min_t(size_t, size >> PAGE_SHIFT, MAX_SKB_FRAGS);\r\n\r\n\t\tdata_len = npages << PAGE_SHIFT;\r\n\t\tsize = data_len + (size & ~PAGE_MASK);\r\n\t}\r\n\tskb = alloc_skb_with_frags(size - data_len, data_len,\r\n\t\t\t\t   PAGE_ALLOC_COSTLY_ORDER,\r\n\t\t\t\t   &err, sk->sk_allocation);\r\n\tif (!skb)\r\n\t\tgoto err;\r\n\r\n\tskb_put(skb, size - data_len);\r\n\tskb->data_len = data_len;\r\n\tskb->len = size;\r\n\r\n\tif (tcp_try_rmem_schedule(sk, skb, skb->truesize)) {\r\n\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPRCVQDROP);\r\n\t\tgoto err_free;\r\n\t}\r\n\r\n\terr = skb_copy_datagram_from_iter(skb, 0, &msg->msg_iter, size);\r\n\tif (err)\r\n\t\tgoto err_free;\r\n\r\n\tTCP_SKB_CB(skb)->seq = tcp_sk(sk)->rcv_nxt;\r\n\tTCP_SKB_CB(skb)->end_seq = TCP_SKB_CB(skb)->seq + size;\r\n\tTCP_SKB_CB(skb)->ack_seq = tcp_sk(sk)->snd_una - 1;\r\n\r\n\tif (tcp_queue_rcv(sk, skb, &fragstolen)) {\r\n\t\tWARN_ON_ONCE(fragstolen); /* should not happen */\r\n\t\t__kfree_skb(skb);\r\n\t}\r\n\treturn size;\r\n\r\nerr_free:\r\n\tkfree_skb(skb);\r\nerr:\r\n\treturn err;\r\n\r\n}", ".cp_collapse": "static void\r\ntcp_collapse(struct sock *sk, struct sk_buff_head *list, struct rb_root *root,\r\n\t     struct sk_buff *head, struct sk_buff *tail, u32 start, u32 end)\r\n{\r\n\tstruct sk_buff *skb = head, *n;\r\n\tstruct sk_buff_head tmp;\r\n\tbool end_of_skbs;\r\n\r\n\t/* First, check that queue is collapsible and find\r\n\t * the point where collapsing can be useful.\r\n\t */\r\nrestart:\r\n\tfor (end_of_skbs = true; skb != NULL && skb != tail; skb = n) {\r\n\t\tn = tcp_skb_next(skb, list);\r\n\r\n\t\tif (!skb_frags_readable(skb))\r\n\t\t\tgoto skip_this;\r\n\r\n\t\t/* No new bits? It is possible on ofo queue. */\r\n\t\tif (!before(start, TCP_SKB_CB(skb)->end_seq)) {\r\n\t\t\tskb = tcp_collapse_one(sk, skb, list, root);\r\n\t\t\tif (!skb)\r\n\t\t\t\tbreak;\r\n\t\t\tgoto restart;\r\n\t\t}\r\n\r\n\t\t/* The first skb to collapse is:\r\n\t\t * - not SYN/FIN and\r\n\t\t * - bloated or contains data before \"start\" or\r\n\t\t *   overlaps to the next one and mptcp allow collapsing.\r\n\t\t */\r\n\t\tif (!(TCP_SKB_CB(skb)->tcp_flags & (TCPHDR_SYN | TCPHDR_FIN)) &&\r\n\t\t    (tcp_win_from_space(sk, skb->truesize) > skb->len ||\r\n\t\t     before(TCP_SKB_CB(skb)->seq, start))) {\r\n\t\t\tend_of_skbs = false;\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\tif (n && n != tail && skb_frags_readable(n) &&\r\n\t\t    tcp_skb_can_collapse_rx(skb, n) &&\r\n\t\t    TCP_SKB_CB(skb)->end_seq != TCP_SKB_CB(n)->seq) {\r\n\t\t\tend_of_skbs = false;\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\nskip_this:\r\n\t\t/* Decided to skip this, advance start seq. */\r\n\t\tstart = TCP_SKB_CB(skb)->end_seq;\r\n\t}\r\n\tif (end_of_skbs ||\r\n\t    (TCP_SKB_CB(skb)->tcp_flags & (TCPHDR_SYN | TCPHDR_FIN)) ||\r\n\t    !skb_frags_readable(skb))\r\n\t\treturn;\r\n\r\n\t__skb_queue_head_init(&tmp);\r\n\r\n\twhile (before(start, end)) {\r\n\t\tint copy = min_t(int, SKB_MAX_ORDER(0, 0), end - start);\r\n\t\tstruct sk_buff *nskb;\r\n\r\n\t\tnskb = alloc_skb(copy, GFP_ATOMIC);\r\n\t\tif (!nskb)\r\n\t\t\tbreak;\r\n\r\n\t\tmemcpy(nskb->cb, skb->cb, sizeof(skb->cb));\r\n\t\tskb_copy_decrypted(nskb, skb);\r\n\t\tTCP_SKB_CB(nskb)->seq = TCP_SKB_CB(nskb)->end_seq = start;\r\n\t\tif (list)\r\n\t\t\t__skb_queue_before(list, skb, nskb);\r\n\t\telse\r\n\t\t\t__skb_queue_tail(&tmp, nskb); /* defer rbtree insertion */\r\n\t\tskb_set_owner_r(nskb, sk);\r\n\t\tmptcp_skb_ext_move(nskb, skb);\r\n\r\n\t\t/* Copy data, releasing collapsed skbs. */\r\n\t\twhile (copy > 0) {\r\n\t\t\tint offset = start - TCP_SKB_CB(skb)->seq;\r\n\t\t\tint size = TCP_SKB_CB(skb)->end_seq - start;\r\n\r\n\t\t\tBUG_ON(offset < 0);\r\n\t\t\tif (size > 0) {\r\n\t\t\t\tsize = min(copy, size);\r\n\t\t\t\tif (skb_copy_bits(skb, offset, skb_put(nskb, size), size))\r\n\t\t\t\t\tBUG();\r\n\t\t\t\tTCP_SKB_CB(nskb)->end_seq += size;\r\n\t\t\t\tcopy -= size;\r\n\t\t\t\tstart += size;\r\n\t\t\t}\r\n\t\t\tif (!before(start, TCP_SKB_CB(skb)->end_seq)) {\r\n\t\t\t\tskb = tcp_collapse_one(sk, skb, list, root);\r\n\t\t\t\tif (!skb ||\r\n\t\t\t\t    skb == tail ||\r\n\t\t\t\t    !tcp_skb_can_collapse_rx(nskb, skb) ||\r\n\t\t\t\t    (TCP_SKB_CB(skb)->tcp_flags & (TCPHDR_SYN | TCPHDR_FIN)) ||\r\n\t\t\t\t    !skb_frags_readable(skb))\r\n\t\t\t\t\tgoto end;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\nend:\r\n\tskb_queue_walk_safe(&tmp, skb, n)\r\n\t\ttcp_rbtree_insert(root, skb);\r\n}", ".cp_collapse_ofo_queue": "static void tcp_collapse_ofo_queue(struct sock *sk)\r\n{\r\n\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\tu32 range_truesize, sum_tiny = 0;\r\n\tstruct sk_buff *skb, *head;\r\n\tu32 start, end;\r\n\r\n\tskb = skb_rb_first(&tp->out_of_order_queue);\r\nnew_range:\r\n\tif (!skb) {\r\n\t\ttp->ooo_last_skb = skb_rb_last(&tp->out_of_order_queue);\r\n\t\treturn;\r\n\t}\r\n\tstart = TCP_SKB_CB(skb)->seq;\r\n\tend = TCP_SKB_CB(skb)->end_seq;\r\n\trange_truesize = skb->truesize;\r\n\r\n\tfor (head = skb;;) {\r\n\t\tskb = skb_rb_next(skb);\r\n\r\n\t\t/* Range is terminated when we see a gap or when\r\n\t\t * we are at the queue end.\r\n\t\t */\r\n\t\tif (!skb ||\r\n\t\t    after(TCP_SKB_CB(skb)->seq, end) ||\r\n\t\t    before(TCP_SKB_CB(skb)->end_seq, start)) {\r\n\t\t\t/* Do not attempt collapsing tiny skbs */\r\n\t\t\tif (range_truesize != head->truesize ||\r\n\t\t\t    end - start >= SKB_WITH_OVERHEAD(PAGE_SIZE)) {\r\n\t\t\t\ttcp_collapse(sk, NULL, &tp->out_of_order_queue,\r\n\t\t\t\t\t     head, skb, start, end);\r\n\t\t\t} else {\r\n\t\t\t\tsum_tiny += range_truesize;\r\n\t\t\t\tif (sum_tiny > sk->sk_rcvbuf >> 3)\r\n\t\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tgoto new_range;\r\n\t\t}\r\n\r\n\t\trange_truesize += skb->truesize;\r\n\t\tif (unlikely(before(TCP_SKB_CB(skb)->seq, start)))\r\n\t\t\tstart = TCP_SKB_CB(skb)->seq;\r\n\t\tif (after(TCP_SKB_CB(skb)->end_seq, end))\r\n\t\t\tend = TCP_SKB_CB(skb)->end_seq;\r\n\t}\r\n}", ".cp_check_space": "void tcp_check_space(struct sock *sk)\r\n{\r\n\t/* pairs with tcp_poll() */\r\n\tsmp_mb();\r\n\tif (sk->sk_socket &&\r\n\t    test_bit(SOCK_NOSPACE, &sk->sk_socket->flags)) {\r\n\t\ttcp_new_space(sk);\r\n\t\tif (!test_bit(SOCK_NOSPACE, &sk->sk_socket->flags))\r\n\t\t\ttcp_chrono_stop(sk, TCP_CHRONO_SNDBUF_LIMITED);\r\n\t}\r\n}", ".cp_data_snd_check": "static inline void tcp_data_snd_check(struct sock *sk)\r\n{\r\n\ttcp_push_pending_frames(sk);\r\n\ttcp_check_space(sk);\r\n}", ".cp_urg": "static void tcp_urg(struct sock *sk, struct sk_buff *skb, const struct tcphdr *th)\r\n{\r\n\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\r\n\t/* Check if we get a new urgent pointer - normally not. */\r\n\tif (unlikely(th->urg))\r\n\t\ttcp_check_urg(sk, th);\r\n\r\n\t/* Do we wait for any urgent data? - normally not... */\r\n\tif (unlikely(tp->urg_data == TCP_URG_NOTYET)) {\r\n\t\tu32 ptr = tp->urg_seq - ntohl(th->seq) + (th->doff * 4) -\r\n\t\t\t  th->syn;\r\n\r\n\t\t/* Is the urgent pointer pointing into this packet? */\r\n\t\tif (ptr < skb->len) {\r\n\t\t\tu8 tmp;\r\n\t\t\tif (skb_copy_bits(skb, ptr, &tmp, 1))\r\n\t\t\t\tBUG();\r\n\t\t\tWRITE_ONCE(tp->urg_data, TCP_URG_VALID | tmp);\r\n\t\t\tif (!sock_flag(sk, SOCK_DEAD))\r\n\t\t\t\tsk->sk_data_ready(sk);\r\n\t\t}\r\n\t}\r\n}", ".cp_finish_connect": "void tcp_finish_connect(struct sock *sk, struct sk_buff *skb)\r\n{\r\n\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\r\n\r\n\ttcp_ao_finish_connect(sk, skb);\r\n\ttcp_set_state(sk, TCP_ESTABLISHED);\r\n\ticsk->icsk_ack.lrcvtime = tcp_jiffies32;\r\n\r\n\tif (skb) {\r\n\t\ticsk->icsk_af_ops->sk_rx_dst_set(sk, skb);\r\n\t\tsecurity_inet_conn_established(sk, skb);\r\n\t\tsk_mark_napi_id(sk, skb);\r\n\t}\r\n\r\n\ttcp_init_transfer(sk, BPF_SOCK_OPS_ACTIVE_ESTABLISHED_CB, skb);\r\n\r\n\t/* Prevent spurious tcp_cwnd_restart() on first data\r\n\t * packet.\r\n\t */\r\n\ttp->lsndtime = tcp_jiffies32;\r\n\r\n\tif (sock_flag(sk, SOCK_KEEPOPEN))\r\n\t\ttcp_reset_keepalive_timer(sk, keepalive_time_when(tp));\r\n\r\n\tif (!tp->rx_opt.snd_wscale)\r\n\t\t__tcp_fast_path_on(tp, tp->snd_wnd);\r\n\telse\r\n\t\ttp->pred_flags = 0;\r\n}"}, "function_name": "tcp_conn_request"}
{"function_id": null, "caller": {}, "callee": {}, "function_name": "free_tga"}
{"function_id": null, "caller": {".y_login": "static int my_login(pTHX_ SV* dbh, imp_dbh_t *imp_dbh)\r\n{\r\n  SV* sv;\r\n  HV* hv;\r\n  char* dbname;\r\n  char* host;\r\n  char* port;\r\n  char* user;\r\n  char* password;\r\n  char* mysql_socket;\r\n  int   result;\r\n  D_imp_xxh(dbh);\r\n\r\n  /* TODO- resolve this so that it is set only if DBI is 1.607 */\r\n#define TAKE_IMP_DATA_VERSION 1\r\n#if TAKE_IMP_DATA_VERSION\r\n  if (DBIc_has(imp_dbh, DBIcf_IMPSET))\r\n  { /* eg from take_imp_data() */\r\n    if (DBIc_has(imp_dbh, DBIcf_ACTIVE))\r\n    {\r\n      if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n        PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"my_login skip connect\\n\");\r\n      /* tell our parent we've adopted an active child */\r\n      ++DBIc_ACTIVE_KIDS(DBIc_PARENT_COM(imp_dbh));\r\n      return TRUE;\r\n    }\r\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                    \"my_login IMPSET but not ACTIVE so connect not skipped\\n\");\r\n  }\r\n#endif\r\n\r\n  sv = DBIc_IMP_DATA(imp_dbh);\r\n\r\n  if (!sv  ||  !SvROK(sv))\r\n    return FALSE;\r\n\r\n  hv = (HV*) SvRV(sv);\r\n  if (SvTYPE(hv) != SVt_PVHV)\r\n    return FALSE;\r\n\r\n  host=\t\tsafe_hv_fetch(aTHX_ hv, \"host\", 4);\r\n  port=\t\tsafe_hv_fetch(aTHX_ hv, \"port\", 4);\r\n  user=\t\tsafe_hv_fetch(aTHX_ hv, \"user\", 4);\r\n  password=\tsafe_hv_fetch(aTHX_ hv, \"password\", 8);\r\n  dbname=\tsafe_hv_fetch(aTHX_ hv, \"database\", 8);\r\n  mysql_socket=\tsafe_hv_fetch(aTHX_ hv, \"mysql_socket\", 12);\r\n\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n\t\t  \"imp_dbh->my_login : dbname = %s, uid = %s, pwd = %s,\" \\\r\n\t\t  \"host = %s, port = %s\\n\",\r\n\t\t  dbname ? dbname : \"NULL\",\r\n\t\t  user ? user : \"NULL\",\r\n\t\t  password ? password : \"NULL\",\r\n\t\t  host ? host : \"NULL\",\r\n\t\t  port ? port : \"NULL\");\r\n\r\n  if (!imp_dbh->pmysql) {\r\n     Newz(908, imp_dbh->pmysql, 1, MYSQL);\r\n     imp_dbh->pmysql->net.fd = -1;\r\n  }\r\n  result = mysql_dr_connect(dbh, imp_dbh->pmysql, mysql_socket, host, port, user,\r\n\t\t\t  password, dbname, imp_dbh) ? TRUE : FALSE;\r\n  return result;\r\n}", ".o_error": "void do_error(SV* h, int rc, const char* what, const char* sqlstate)\r\n{\r\n  dTHX;\r\n  D_imp_xxh(h);\r\n  SV *errstr;\r\n  SV *errstate;\r\n\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\t--> do_error\\n\");\r\n  errstr= DBIc_ERRSTR(imp_xxh);\r\n  sv_setiv(DBIc_ERR(imp_xxh), (IV)rc);\t/* set err early\t*/\r\n  sv_setpv(errstr, what);\r\n\r\n  if (sqlstate)\r\n  {\r\n    errstate= DBIc_STATE(imp_xxh);\r\n    sv_setpvn(errstate, sqlstate, 5);\r\n  }\r\n\r\n  /* NO EFFECT DBIh_EVENT2(h, ERROR_event, DBIc_ERR(imp_xxh), errstr); */\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"%s error %d recorded: %s\\n\",\r\n    what, rc, SvPV_nolen(errstr));\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\t<-- do_error\\n\");\r\n}", ".o_warn": "void do_warn(SV* h, int rc, char* what)\r\n{\r\n  dTHX;\r\n  D_imp_xxh(h);\r\n\r\n  SV *errstr = DBIc_ERRSTR(imp_xxh);\r\n  sv_setiv(DBIc_ERR(imp_xxh), (IV)rc);\t/* set err early\t*/\r\n  sv_setpv(errstr, what);\r\n  /* NO EFFECT DBIh_EVENT2(h, WARN_event, DBIc_ERR(imp_xxh), errstr);*/\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"%s warning %d recorded: %s\\n\",\r\n    what, rc, SvPV_nolen(errstr));\r\n  warn(\"%s\", what);\r\n}", ".bd_db_disconnect": "int dbd_db_disconnect(SV* dbh, imp_dbh_t* imp_dbh)\r\n{\r\n#ifdef dTHR\r\n  dTHR;\r\n#endif\r\n  dTHX;\r\n  D_imp_xxh(dbh);\r\n\r\n  /* We assume that disconnect will always work       */\r\n  /* since most errors imply already disconnected.    */\r\n  DBIc_ACTIVE_off(imp_dbh);\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"imp_dbh->pmysql: %p\\n\",\r\n\t\t              imp_dbh->pmysql);\r\n  mysql_close(imp_dbh->pmysql );\r\n  imp_dbh->pmysql->net.fd = -1;\r\n\r\n  /* We don't free imp_dbh since a reference still exists    */\r\n  /* The DESTROY method is the only one to 'free' memory.    */\r\n  return TRUE;\r\n}", ".ysql_st_free_result_sets": "int mysql_st_free_result_sets (SV * sth, imp_sth_t * imp_sth)\r\n{\r\n  dTHX;\r\n  D_imp_dbh_from_sth;\r\n  D_imp_xxh(sth);\r\n  int next_result_rc= -1;\r\n\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t>- dbd_st_free_result_sets\\n\");\r\n\r\n  do\r\n  {\r\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t<- dbd_st_free_result_sets RC %d\\n\", next_result_rc);\r\n\r\n    if (next_result_rc == 0)\r\n    {\r\n      if (!(imp_sth->result = mysql_use_result(imp_dbh->pmysql)))\r\n      {\r\n        /* Check for possible error */\r\n        if (mysql_field_count(imp_dbh->pmysql))\r\n        {\r\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n          PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t<- dbd_st_free_result_sets ERROR: %s\\n\",\r\n                                  mysql_error(imp_dbh->pmysql));\r\n\r\n          do_error(sth, mysql_errno(imp_dbh->pmysql), mysql_error(imp_dbh->pmysql),\r\n                   mysql_sqlstate(imp_dbh->pmysql));\r\n          return 0;\r\n        }\r\n      }\r\n    }\r\n    if (imp_sth->result)\r\n    {\r\n      mysql_free_result(imp_sth->result);\r\n      imp_sth->result=NULL;\r\n    }\r\n  } while ((next_result_rc=mysql_next_result(imp_dbh->pmysql))==0);\r\n\r\n  if (next_result_rc > 0)\r\n  {\r\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t<- dbd_st_free_result_sets: Error while processing multi-result set: %s\\n\",\r\n                    mysql_error(imp_dbh->pmysql));\r\n\r\n    do_error(sth, mysql_errno(imp_dbh->pmysql), mysql_error(imp_dbh->pmysql),\r\n             mysql_sqlstate(imp_dbh->pmysql));\r\n  }\r\n\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t<- dbd_st_free_result_sets\\n\");\r\n\r\n  return 1;\r\n}", ".ount_params": "static int\r\ncount_params(imp_xxh_t *imp_xxh, pTHX_ char *statement, bool bind_comment_placeholders)\r\n{\r\n  bool comment_end= false;\r\n  char* ptr= statement;\r\n  int num_params= 0;\r\n  int comment_length= 0;\r\n  char c;\r\n\r\n  if (DBIc_DBISTATE(imp_xxh)->debug >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \">count_params statement %s\\n\", statement);\r\n\r\n  while ( (c = *ptr++) )\r\n  {\r\n    switch (c) {\r\n      /* so, this is a -- comment, so let's burn up characters */\r\n    case '-':\r\n      {\r\n          if (bind_comment_placeholders)\r\n          {\r\n              c = *ptr++;\r\n              break;\r\n          }\r\n          else\r\n          {\r\n              comment_length= 1;\r\n              /* let's see if the next one is a dash */\r\n              c = *ptr++;\r\n\r\n              if  (c == '-') {\r\n                  /* if two dashes, ignore everything until newline */\r\n                  while ((c = *ptr))\r\n                  {\r\n                      if (DBIc_DBISTATE(imp_xxh)->debug >= 2)\r\n                          PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"%c\\n\", c);\r\n                      ptr++;\r\n                      comment_length++;\r\n                      if (c == '\\n')\r\n                      {\r\n                          comment_end= true;\r\n                          break;\r\n                      }\r\n                  }\r\n                  /*\r\n                    if not comment_end, the comment never ended and we need to iterate\r\n                    back to the beginning of where we started and let the database \r\n                    handle whatever is in the statement\r\n                */\r\n                  if (! comment_end)\r\n                      ptr-= comment_length;\r\n              }\r\n              /* otherwise, only one dash/hyphen, backtrack by one */\r\n              else\r\n                  ptr--;\r\n              break;\r\n          }\r\n      }\r\n    /* c-type comments */\r\n    case '/':\r\n      {\r\n          if (bind_comment_placeholders)\r\n          {\r\n              c = *ptr++;\r\n              break;\r\n          }\r\n          else\r\n          {\r\n              c = *ptr++;\r\n              /* let's check if the next one is an asterisk */\r\n              if  (c == '*')\r\n              {\r\n                  comment_length= 0;\r\n                  comment_end= false;\r\n                  /* ignore everything until closing comment */\r\n                  while ((c= *ptr))\r\n                  {\r\n                      ptr++;\r\n                      comment_length++;\r\n\r\n                      if (c == '*')\r\n                      {\r\n                          c = *ptr++;\r\n                          /* alas, end of comment */\r\n                          if (c == '/')\r\n                          {\r\n                              comment_end= true;\r\n                              break;\r\n                          }\r\n                          /*\r\n                            nope, just an asterisk, not so fast, not\r\n                            end of comment, go back one\r\n                        */\r\n                          else\r\n                              ptr--;\r\n                      }\r\n                  }\r\n                  /*\r\n                    if the end of the comment was never found, we have\r\n                    to backtrack to wherever we first started skipping\r\n                    over the possible comment.\r\n                    This means we will pass the statement to the database\r\n                    to see its own fate and issue the error\r\n                */\r\n                  if (!comment_end)\r\n                      ptr -= comment_length;\r\n              }\r\n              else\r\n                  ptr--;\r\n              break;\r\n          }\r\n      }\r\n    case '`':\r\n    case '\"':\r\n    case '\\'':\r\n      /* Skip string */\r\n      {\r\n        char end_token = c;\r\n        while ((c = *ptr)  &&  c != end_token)\r\n        {\r\n          if (c == '\\\\')\r\n            if (! *(++ptr))\r\n              continue;\r\n\r\n          ++ptr;\r\n        }\r\n        if (c)\r\n          ++ptr;\r\n        break;\r\n      }\r\n\r\n    case '?':\r\n      ++num_params;\r\n      break;\r\n\r\n    default:\r\n      break;\r\n    }\r\n  }\r\n  return num_params;\r\n}", ".ysql_db_reconnect": "int mysql_db_reconnect(SV* h)\r\n{\r\n  dTHX;\r\n  D_imp_xxh(h);\r\n  imp_dbh_t* imp_dbh;\r\n  MYSQL save_socket;\r\n\r\n  if (DBIc_DBISTATE(imp_xxh)->debug >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"reconnecting\\n\");\r\n\r\n  if (DBIc_TYPE(imp_xxh) == DBIt_ST)\r\n  {\r\n    imp_dbh = (imp_dbh_t*) DBIc_PARENT_COM(imp_xxh);\r\n    h = DBIc_PARENT_H(imp_xxh);\r\n  }\r\n  else\r\n    imp_dbh= (imp_dbh_t*) imp_xxh;\r\n\r\n  /* reconnect a closed connection, used in do() for implicit reconnect */\r\n  if (!DBIc_has(imp_dbh, DBIcf_ACTIVE) && DBIc_has(imp_dbh, DBIcf_AutoCommit)) {\r\n    if (my_login(aTHX_ h, imp_dbh)) {\r\n      DBIc_ACTIVE_on(imp_dbh);\r\n      DBIc_set(imp_dbh, DBIcf_AutoCommit, TRUE);\r\n      return TRUE;\r\n    }\r\n    return FALSE;\r\n  }\r\n\r\n  if (mysql_errno(imp_dbh->pmysql) != CR_SERVER_GONE_ERROR &&\r\n#ifdef ER_CLIENT_INTERACTION_TIMEOUT /* Added in 8.0.24 */\r\n          mysql_errno(imp_dbh->pmysql) != ER_CLIENT_INTERACTION_TIMEOUT &&\r\n#endif\r\n          mysql_errno(imp_dbh->pmysql) != CR_SERVER_LOST) {\r\n    /* Other error */\r\n    if (DBIc_DBISTATE(imp_xxh)->debug >= 2)\r\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"Can't reconnect on unexpected error %d\\n\",\r\n          mysql_errno(imp_dbh->pmysql));\r\n    return FALSE;\r\n  }\r\n\r\n  if (!DBIc_has(imp_dbh, DBIcf_AutoCommit) || !imp_dbh->auto_reconnect)\r\n  {\r\n    /* We never reconnect if AutoCommit is turned off.\r\n     * Otherwise we might get an inconsistent transaction\r\n     * state.\r\n     */\r\n    if (DBIc_DBISTATE(imp_xxh)->debug >= 2)\r\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"Can't reconnect as AutoCommit is turned off\\n\");\r\n    return FALSE;\r\n  }\r\n\r\n  /* my_login will blow away imp_dbh->mysql so we save a copy of\r\n   * imp_dbh->mysql and put it back where it belongs if the reconnect\r\n   * fail.  Think server is down & reconnect fails but the application eval{}s\r\n   * the execute, so next time $dbh->quote() gets called, instant SIGSEGV!\r\n   */\r\n  save_socket= *(imp_dbh->pmysql);\r\n  memcpy (&save_socket, imp_dbh->pmysql,sizeof(save_socket));\r\n  memset (imp_dbh->pmysql,0,sizeof(*(imp_dbh->pmysql)));\r\n\r\n  /* we should disconnect the db handle before reconnecting, this will\r\n   * prevent my_login from thinking it's adopting an active child which\r\n   * would prevent the handle from actually reconnecting\r\n   */\r\n  if (!dbd_db_disconnect(h, imp_dbh) || !my_login(aTHX_ h, imp_dbh))\r\n  {\r\n    do_error(h, mysql_errno(imp_dbh->pmysql), mysql_error(imp_dbh->pmysql),\r\n             mysql_sqlstate(imp_dbh->pmysql));\r\n    memcpy (imp_dbh->pmysql, &save_socket, sizeof(save_socket));\r\n    ++imp_dbh->stats.auto_reconnects_failed;\r\n    return FALSE;\r\n  }\r\n\r\n  /*\r\n   *  Tell DBI, that dbh->disconnect should be called for this handle\r\n   */\r\n  DBIc_ACTIVE_on(imp_dbh);\r\n\r\n  ++imp_dbh->stats.auto_reconnects_ok;\r\n  return TRUE;\r\n}", ".ysql_to_perl_type": "static enum enum_field_types mysql_to_perl_type(enum enum_field_types type)\r\n{\r\n  enum enum_field_types enum_type;\r\n\r\n  switch (type) {\r\n  case MYSQL_TYPE_DOUBLE:\r\n  case MYSQL_TYPE_FLOAT:\r\n    enum_type= MYSQL_TYPE_DOUBLE;\r\n    break;\r\n\r\n  case MYSQL_TYPE_SHORT:\r\n  case MYSQL_TYPE_TINY:\r\n  case MYSQL_TYPE_LONG:\r\n  case MYSQL_TYPE_INT24:\r\n  case MYSQL_TYPE_YEAR:\r\n#if IVSIZE >= 8\r\n  case MYSQL_TYPE_LONGLONG:\r\n    enum_type= MYSQL_TYPE_LONGLONG;\r\n#else\r\n    enum_type= MYSQL_TYPE_LONG;\r\n#endif\r\n    break;\r\n\r\n  case MYSQL_TYPE_BIT:\r\n    enum_type= MYSQL_TYPE_BIT;\r\n    break;\r\n\r\n  case MYSQL_TYPE_NEWDECIMAL:\r\n  case MYSQL_TYPE_DECIMAL:\r\n    enum_type= MYSQL_TYPE_DECIMAL;\r\n    break;\r\n\r\n#if IVSIZE < 8\r\n  case MYSQL_TYPE_LONGLONG:\r\n#endif\r\n  case MYSQL_TYPE_DATE:\r\n  case MYSQL_TYPE_TIME:\r\n  case MYSQL_TYPE_DATETIME:\r\n  case MYSQL_TYPE_NEWDATE:\r\n  case MYSQL_TYPE_TIMESTAMP:\r\n  case MYSQL_TYPE_VAR_STRING:\r\n  case MYSQL_TYPE_VARCHAR:\r\n  case MYSQL_TYPE_STRING:\r\n    enum_type= MYSQL_TYPE_STRING;\r\n    break;\r\n\r\n  case MYSQL_TYPE_GEOMETRY:\r\n  case MYSQL_TYPE_BLOB:\r\n  case MYSQL_TYPE_TINY_BLOB:\r\n    enum_type= MYSQL_TYPE_BLOB;\r\n    break;\r\n\r\n  default:\r\n    enum_type= MYSQL_TYPE_STRING;    /* MySQL can handle all types as strings */\r\n  }\r\n  return(enum_type);\r\n}", ".ysql_st_internal_execute41": "my_ulonglong mysql_st_internal_execute41(\r\n                                         SV *sth,\r\n                                         int num_params,\r\n                                         MYSQL_RES **result,\r\n                                         MYSQL_STMT *stmt,\r\n                                         MYSQL_BIND *bind,\r\n                                         int *has_been_bound\r\n                                        )\r\n{\r\n  int i;\r\n  enum enum_field_types enum_type;\r\n  dTHX;\r\n  int execute_retval;\r\n  my_ulonglong rows=0;\r\n  D_imp_xxh(sth);\r\n\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                  \"\\t-> mysql_st_internal_execute41\\n\");\r\n\r\n  /* free result if exists */\r\n  if (*result)\r\n  {\r\n    mysql_free_result(*result);\r\n    *result= 0;\r\n  }\r\n\r\n  /*\r\n    If were performed any changes with ph variables\r\n    we have to rebind them\r\n  */\r\n\r\n  if (num_params > 0 && !(*has_been_bound))\r\n  {\r\n#if MYSQL_VERSION_ID >= 80300\r\n    if (mysql_stmt_bind_named_param(stmt,bind,num_params, NULL))\r\n#else\r\n    if (mysql_stmt_bind_param(stmt,bind))\r\n#endif\r\n      goto error;\r\n\r\n    *has_been_bound= 1;\r\n  }\r\n\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                  \"\\t\\tmysql_st_internal_execute41 calling mysql_execute with %d num_params\\n\",\r\n                  num_params);\r\n\r\n  execute_retval= mysql_stmt_execute(stmt);\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                  \"\\t\\tmysql_stmt_execute returned %d\\n\",\r\n                  execute_retval);\r\n  if (execute_retval)\r\n    goto error;\r\n\r\n  /*\r\n   This statement does not return a result set (INSERT, UPDATE...)\r\n  */\r\n  if (!(*result= mysql_stmt_result_metadata(stmt)))\r\n  {\r\n    if (mysql_stmt_errno(stmt))\r\n      goto error;\r\n\r\n    rows= mysql_stmt_affected_rows(stmt);\r\n\r\n    /* mysql_stmt_affected_rows(): -1 indicates that the query returned an error */\r\n    if (rows == (my_ulonglong)-1)\r\n      goto error;\r\n  }\r\n  /*\r\n    This statement returns a result set (SELECT...)\r\n  */\r\n  else\r\n  {\r\n    for (i = mysql_stmt_field_count(stmt) - 1; i >=0; --i) {\r\n        enum_type = mysql_to_perl_type(stmt->fields[i].type);\r\n        if (enum_type != MYSQL_TYPE_DOUBLE && enum_type != MYSQL_TYPE_LONG && enum_type != MYSQL_TYPE_LONGLONG && enum_type != MYSQL_TYPE_BIT)\r\n        {\r\n            /* mysql_stmt_store_result to update MYSQL_FIELD->max_length */\r\n            bool on = 1;\r\n            mysql_stmt_attr_set(stmt, STMT_ATTR_UPDATE_MAX_LENGTH, &on);\r\n            break;\r\n        }\r\n    }\r\n    /* Get the total rows affected and return */\r\n    if (mysql_stmt_store_result(stmt))\r\n      goto error;\r\n    else\r\n      rows= mysql_stmt_num_rows(stmt);\r\n  }\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                  \"\\t<- mysql_internal_execute_41 returning %lu rows\\n\",\r\n                  rows);\r\n  return(rows);\r\n\r\nerror:\r\n  if (*result)\r\n  {\r\n    mysql_free_result(*result);\r\n    *result= 0;\r\n  }\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                  \"     errno %d err message %s\\n\",\r\n                  mysql_stmt_errno(stmt),\r\n                  mysql_stmt_error(stmt));\r\n  do_error(sth, mysql_stmt_errno(stmt), mysql_stmt_error(stmt),\r\n           mysql_stmt_sqlstate(stmt));\r\n  mysql_stmt_reset(stmt);\r\n\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                  \"\\t<- mysql_st_internal_execute41\\n\");\r\n  return -2;\r\n\r\n}", ".ysql_st_internal_execute": "my_ulonglong mysql_st_internal_execute(\r\n                                       SV *h, /* could be sth or dbh */\r\n                                       SV *statement,\r\n                                       SV *attribs,\r\n                                       int num_params,\r\n                                       imp_sth_ph_t *params,\r\n                                       MYSQL_RES **result,\r\n                                       MYSQL *svsock,\r\n                                       int use_mysql_use_result\r\n                                      )\r\n{\r\n  dTHX;\r\n  bool bind_type_guessing= FALSE;\r\n  bool bind_comment_placeholders= TRUE;\r\n  STRLEN slen;\r\n  char *sbuf = SvPV(statement, slen);\r\n  char *salloc;\r\n  int htype;\r\n  bool async = FALSE;\r\n  my_ulonglong rows= 0;\r\n  /* thank you DBI.c for this info! */\r\n  D_imp_xxh(h);\r\n  attribs= attribs;\r\n\r\n  htype= DBIc_TYPE(imp_xxh);\r\n  /*\r\n    It is important to import imp_dbh properly according to the htype\r\n    that it is! Also, one might ask why bind_type_guessing is assigned\r\n    in each block. Well, it's because D_imp_ macros called in these\r\n    blocks make it so imp_dbh is not \"visible\" or defined outside of the\r\n    if/else (when compiled, it fails for imp_dbh not being defined).\r\n  */\r\n  /* h is a dbh */\r\n  if (htype == DBIt_DB)\r\n  {\r\n    D_imp_dbh(h);\r\n    /* if imp_dbh is not available, it causes segfault (proper) on OpenBSD */\r\n    if (imp_dbh)\r\n    {\r\n      bind_type_guessing= imp_dbh->bind_type_guessing;\r\n      bind_comment_placeholders= imp_dbh->bind_comment_placeholders;\r\n    }\r\n    async = (bool) (imp_dbh->async_query_in_flight != NULL);\r\n  }\r\n  /* h is a sth */\r\n  else\r\n  {\r\n    D_imp_sth(h);\r\n    D_imp_dbh_from_sth;\r\n    /* if imp_dbh is not available, it causes segfault (proper) on OpenBSD */\r\n    if (imp_dbh)\r\n    {\r\n      bind_type_guessing= imp_dbh->bind_type_guessing;\r\n      bind_comment_placeholders= imp_dbh->bind_comment_placeholders;\r\n    }\r\n    async = imp_sth->is_async;\r\n    if(async) {\r\n        imp_dbh->async_query_in_flight = imp_sth;\r\n    } else {\r\n        imp_dbh->async_query_in_flight = NULL;\r\n    }\r\n  }\r\n\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"mysql_st_internal_execute MYSQL_VERSION_ID %d\\n\",\r\n                  MYSQL_VERSION_ID );\r\n\r\n  salloc= parse_params(imp_xxh,\r\n                              aTHX_ svsock,\r\n                              sbuf,\r\n                              &slen,\r\n                              params,\r\n                              num_params,\r\n                              bind_type_guessing,\r\n                              bind_comment_placeholders);\r\n\r\n  if (salloc)\r\n  {\r\n    sbuf= salloc;\r\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"Binding parameters: %s\\n\", sbuf);\r\n  }\r\n\r\n  if(async) {\r\n    if((mysql_send_query(svsock, sbuf, slen)) &&\r\n       (!mysql_db_reconnect(h) ||\r\n        (mysql_send_query(svsock, sbuf, slen))))\r\n    {\r\n        rows = -2;\r\n    } else {\r\n        rows = 0;\r\n    }\r\n  } else {\r\n      if ((mysql_real_query(svsock, sbuf, slen))  &&\r\n          (!mysql_db_reconnect(h)  ||\r\n           (mysql_real_query(svsock, sbuf, slen))))\r\n      {\r\n        rows = -2;\r\n      } else {\r\n          /** Store the result from the Query */\r\n          *result= use_mysql_use_result ?\r\n            mysql_use_result(svsock) : mysql_store_result(svsock);\r\n\r\n          if (mysql_errno(svsock))\r\n            rows = -2;\r\n          else if (*result)\r\n            rows = mysql_num_rows(*result);\r\n          else {\r\n            rows = mysql_affected_rows(svsock);\r\n            /* mysql_affected_rows(): -1 indicates that the query returned an error */\r\n            if (rows == (my_ulonglong)-1)\r\n              rows = -2;\r\n          }\r\n      }\r\n  }\r\n\r\n  if (salloc)\r\n    Safefree(salloc);\r\n\r\n  if(rows == (my_ulonglong)-2) {\r\n    do_error(h, mysql_errno(svsock), mysql_error(svsock), \r\n             mysql_sqlstate(svsock));\r\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"IGNORING ERROR errno %d\\n\", mysql_errno(svsock));\r\n  }\r\n  return(rows);\r\n}", ".bd_describe": "int dbd_describe(SV* sth, imp_sth_t* imp_sth)\r\n{\r\n  dTHX;\r\n  D_imp_xxh(sth);\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t--> dbd_describe\\n\");\r\n\r\n\r\n  if (imp_sth->use_server_side_prepare)\r\n  {\r\n    int i;\r\n    int col_type;\r\n    int num_fields= DBIc_NUM_FIELDS(imp_sth);\r\n    imp_sth_fbh_t *fbh;\r\n    MYSQL_BIND *buffer;\r\n    MYSQL_FIELD *fields;\r\n\r\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tdbd_describe() num_fields %d\\n\",\r\n                    num_fields);\r\n\r\n    if (imp_sth->done_desc)\r\n      return TRUE;\r\n\r\n    if (!num_fields || !imp_sth->result)\r\n    {\r\n      /* no metadata */\r\n      do_error(sth, JW_ERR_SEQUENCE,\r\n               \"no metadata information while trying describe result set\",\r\n               NULL);\r\n      return 0;\r\n    }\r\n\r\n    /* allocate fields buffers  */\r\n    if (  !(imp_sth->fbh= alloc_fbuffer(num_fields))\r\n          || !(imp_sth->buffer= alloc_bind(num_fields)) )\r\n    {\r\n      /* Out of memory */\r\n      do_error(sth, JW_ERR_SEQUENCE,\r\n               \"Out of memory in dbd_sescribe()\",NULL);\r\n      return 0;\r\n    }\r\n\r\n    fields= mysql_fetch_fields(imp_sth->result);\r\n\r\n    for (\r\n         fbh= imp_sth->fbh, buffer= (MYSQL_BIND*)imp_sth->buffer, i= 0;\r\n         i < num_fields;\r\n         i++, fbh++, buffer++\r\n        )\r\n    {\r\n      /* get the column type */\r\n      col_type = fields ? fields[i].type : MYSQL_TYPE_STRING;\r\n\r\n      if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n      {\r\n        PerlIO_printf(DBIc_LOGPIO(imp_xxh),\"\\t\\ti %d col_type %d fbh->length %lu\\n\",\r\n                      i, col_type, fbh->length);\r\n        PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                      \"\\t\\tfields[i].length %lu fields[i].max_length %lu fields[i].type %d fields[i].charsetnr %d\\n\",\r\n                      fields[i].length, fields[i].max_length, fields[i].type,\r\n                      fields[i].charsetnr);\r\n      }\r\n      fbh->charsetnr = fields[i].charsetnr;\r\n\r\n      buffer->buffer_type= mysql_to_perl_type(col_type);\r\n      if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n        PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tmysql_to_perl_type returned %d\\n\",\r\n                      col_type);\r\n      buffer->length= &(fbh->length);\r\n      buffer->is_null= &(fbh->is_null);\r\n      buffer->error= (bool*) &(fbh->error);\r\n\r\n      if (fields[i].flags & ZEROFILL_FLAG)\r\n        buffer->buffer_type = MYSQL_TYPE_STRING;\r\n\r\n      switch (buffer->buffer_type) {\r\n      case MYSQL_TYPE_DOUBLE:\r\n        buffer->buffer_length= sizeof(fbh->ddata);\r\n        buffer->buffer= (char*) &fbh->ddata;\r\n        break;\r\n\r\n      case MYSQL_TYPE_LONG:\r\n      case MYSQL_TYPE_LONGLONG:\r\n        buffer->buffer_length= sizeof(fbh->ldata);\r\n        buffer->buffer= (char*) &fbh->ldata;\r\n        buffer->is_unsigned= (fields[i].flags & UNSIGNED_FLAG) ? 1 : 0;\r\n        break;\r\n\r\n      case MYSQL_TYPE_BIT:\r\n        buffer->buffer_length= 8;\r\n        Newz(908, fbh->data, buffer->buffer_length, char);\r\n        buffer->buffer= (char *) fbh->data;\r\n        break;\r\n\r\n      default:\r\n        buffer->buffer_length= fields[i].max_length ? fields[i].max_length : 1;\r\n        Newz(908, fbh->data, buffer->buffer_length, char);\r\n        buffer->buffer= (char *) fbh->data;\r\n      }\r\n    }\r\n\r\n    if (mysql_stmt_bind_result(imp_sth->stmt, imp_sth->buffer))\r\n    {\r\n      do_error(sth, mysql_stmt_errno(imp_sth->stmt),\r\n               mysql_stmt_error(imp_sth->stmt),\r\n               mysql_stmt_sqlstate(imp_sth->stmt));\r\n      return 0;\r\n    }\r\n  }\r\n\r\n  imp_sth->done_desc= 1;\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t<- dbd_describe\\n\");\r\n  return TRUE;\r\n}", ".ysql_db_async_result": "int mysql_db_async_result(SV* h, MYSQL_RES** resp)\r\n{\r\n  dTHX;\r\n  D_imp_xxh(h);\r\n  imp_dbh_t* dbh;\r\n  MYSQL* svsock = NULL;\r\n  MYSQL_RES* _res;\r\n  int retval = 0;\r\n  int htype;\r\n  bool async_sth = FALSE;\r\n\r\n  if(! resp) {\r\n      resp = &_res;\r\n  }\r\n  htype = DBIc_TYPE(imp_xxh);\r\n\r\n\r\n  if(htype == DBIt_DB) {\r\n      D_imp_dbh(h);\r\n      dbh = imp_dbh;\r\n  } else {\r\n      D_imp_sth(h);\r\n      D_imp_dbh_from_sth;\r\n      dbh = imp_dbh;\r\n      async_sth = imp_sth->is_async;\r\n      retval = imp_sth->row_num;\r\n  }\r\n\r\n  if(! dbh->async_query_in_flight) {\r\n      if (async_sth)\r\n          return retval;\r\n      do_error(h, 2000, \"Gathering asynchronous results for a synchronous handle\", \"HY000\");\r\n      return -1;\r\n  }\r\n  if(dbh->async_query_in_flight != imp_xxh) {\r\n      do_error(h, 2000, \"Gathering async_query_in_flight results for the wrong handle\", \"HY000\");\r\n      return -1;\r\n  }\r\n  dbh->async_query_in_flight = NULL;\r\n\r\n  svsock= dbh->pmysql;\r\n  retval= mysql_read_query_result(svsock);\r\n  if(! retval) {\r\n    *resp= mysql_store_result(svsock);\r\n\r\n    if (mysql_errno(svsock))\r\n      do_error(h, mysql_errno(svsock), mysql_error(svsock), mysql_sqlstate(svsock));\r\n    if (!*resp)\r\n      retval= mysql_affected_rows(svsock);\r\n    else {\r\n      retval= mysql_num_rows(*resp);\r\n      if(resp == &_res) {\r\n        mysql_free_result(*resp);\r\n        *resp= NULL;\r\n      }\r\n    }\r\n    if(htype == DBIt_ST) {\r\n      D_imp_sth(h);\r\n      D_imp_dbh_from_sth;\r\n\r\n      if((my_ulonglong)retval+1 != (my_ulonglong)-1) {\r\n        if(! *resp) {\r\n          imp_sth->insertid= mysql_insert_id(svsock);\r\n          if(! mysql_more_results(svsock))\r\n            DBIc_ACTIVE_off(imp_sth);\r\n        } else {\r\n          DBIc_NUM_FIELDS(imp_sth)= mysql_num_fields(imp_sth->result);\r\n          imp_sth->done_desc= 0;\r\n          imp_sth->fetch_done= 0;\r\n        }\r\n      }\r\n      imp_sth->warning_count = mysql_warning_count(imp_dbh->pmysql);\r\n    }\r\n  } else {\r\n     do_error(h, mysql_errno(svsock), mysql_error(svsock),\r\n              mysql_sqlstate(svsock));\r\n     return -1;\r\n  }\r\n return retval;\r\n}", ".ysql_st_clean_cursor": "int mysql_st_clean_cursor(SV* sth, imp_sth_t* imp_sth) {\r\n\r\n  if (DBIc_ACTIVE(imp_sth) && dbd_describe(sth, imp_sth) &&\r\n      !imp_sth->fetch_done)\r\n    mysql_stmt_free_result(imp_sth->stmt);\r\n  return 1;\r\n}", ".ree_bind": "static void free_bind(MYSQL_BIND *bind)\r\n{\r\n  if (bind)\r\n    Safefree(bind);\r\n}", ".ree_fbind": "static void free_fbind(imp_sth_phb_t *fbind)\r\n{\r\n  if (fbind)\r\n    Safefree(fbind);\r\n}", ".ree_fbuffer": "static void free_fbuffer(imp_sth_fbh_t *fbh)\r\n{\r\n  if (fbh)\r\n    Safefree(fbh);\r\n}", ".ree_param": "static void\r\nfree_param(pTHX_ imp_sth_ph_t *params, int num_params)\r\n{\r\n  if (params)\r\n  {\r\n    int i;\r\n    for (i= 0;  i < num_params;  i++)\r\n    {\r\n      imp_sth_ph_t *ph= params+i;\r\n      if (ph->value)\r\n      {\r\n        (void) SvREFCNT_dec(ph->value);\r\n        ph->value= NULL;\r\n      }\r\n    }\r\n    Safefree(params);\r\n  }\r\n}", ".ind_param": "int bind_param(imp_sth_ph_t *ph, SV *value, IV sql_type)\r\n{\r\n  dTHX;\r\n  if (ph->value)\r\n  {\r\n    if (SvMAGICAL(ph->value))\r\n      mg_get(ph->value);\r\n    (void) SvREFCNT_dec(ph->value);\r\n  }\r\n\r\n  ph->value= newSVsv(value);\r\n\r\n  if (sql_type)\r\n    ph->type = sql_type;\r\n\r\n  return TRUE;\r\n}"}, "callee": {".bd_st_prepare": "int\r\ndbd_st_prepare(\r\n  SV *sth,\r\n  imp_sth_t *imp_sth,\r\n  char *statement,\r\n  SV *attribs)\r\n{\r\n  int i;\r\n  SV **svp;\r\n  dTHX;\r\n  int prepare_retval;\r\n  MYSQL_BIND *bind, *bind_end;\r\n  imp_sth_phb_t *fbind;\r\n  D_imp_xxh(sth);\r\n  D_imp_dbh_from_sth;\r\n\r\n  if (!DBIc_ACTIVE(imp_dbh)) {\r\n    do_error(sth, JW_ERR_NOT_ACTIVE, \"Statement not active\" ,NULL);\r\n    return FALSE;\r\n  }\r\n\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                 \"\\t-> dbd_st_prepare MYSQL_VERSION_ID %d, SQL statement: %s\\n\",\r\n                  MYSQL_VERSION_ID, statement);\r\n\r\n /* Set default value of 'mysql_server_prepare' attribute for sth from dbh */\r\n  imp_sth->use_server_side_prepare= imp_dbh->use_server_side_prepare;\r\n  imp_sth->disable_fallback_for_server_prepare= imp_dbh->disable_fallback_for_server_prepare;\r\n  if (attribs)\r\n  {\r\n    svp= DBD_ATTRIB_GET_SVP(attribs, \"mysql_server_prepare\", 20);\r\n    imp_sth->use_server_side_prepare = (svp) ?\r\n      SvTRUE(*svp) : imp_dbh->use_server_side_prepare;\r\n\r\n    svp= DBD_ATTRIB_GET_SVP(attribs, \"mysql_server_prepare_disable_fallback\", 37);\r\n    imp_sth->disable_fallback_for_server_prepare = (svp) ?\r\n      SvTRUE(*svp) : imp_dbh->disable_fallback_for_server_prepare;\r\n\r\n    svp = DBD_ATTRIB_GET_SVP(attribs, \"async\", 5);\r\n\r\n    if(svp && SvTRUE(*svp)) {\r\n        imp_sth->is_async = TRUE;\r\n        if (imp_sth->disable_fallback_for_server_prepare)\r\n        {\r\n          do_error(sth, ER_UNSUPPORTED_PS,\r\n                   \"Async option not supported with server side prepare\", \"HY000\");\r\n          return 0;\r\n        }\r\n        imp_sth->use_server_side_prepare = FALSE;\r\n    }\r\n  }\r\n\r\n  imp_sth->fetch_done= 0;\r\n  imp_sth->done_desc= 0;\r\n  imp_sth->result= NULL;\r\n  imp_sth->currow= 0;\r\n\r\n  /* Set default value of 'mysql_use_result' attribute for sth from dbh */\r\n  svp= DBD_ATTRIB_GET_SVP(attribs, \"mysql_use_result\", 16);\r\n  imp_sth->use_mysql_use_result= svp ?\r\n    SvTRUE(*svp) : imp_dbh->use_mysql_use_result;\r\n\r\n  for (i= 0; i < AV_ATTRIB_LAST; i++)\r\n    imp_sth->av_attr[i]= Nullav;\r\n\r\n  /*\r\n     Clean-up previous result set(s) for sth to prevent\r\n     'Commands out of sync' error \r\n  */\r\n  mysql_st_free_result_sets(sth, imp_sth);\r\n\r\n\r\n  if (imp_sth->use_server_side_prepare)\r\n  {\r\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                    \"\\t\\tuse_server_side_prepare set\\n\");\r\n    /* do we really need this? If we do, we should return, not just continue */\r\n    if (imp_sth->stmt)\r\n      fprintf(stderr,\r\n              \"ERROR: Trying to prepare new stmt while we have \\\r\n              already not closed one \\n\");\r\n\r\n    imp_sth->stmt= mysql_stmt_init(imp_dbh->pmysql);\r\n\r\n    if (! imp_sth->stmt)\r\n    {\r\n      if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n        PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                      \"\\t\\tERROR: Unable to return MYSQL_STMT structure \\\r\n                      from mysql_stmt_init(): ERROR NO: %d ERROR MSG:%s\\n\",\r\n                      mysql_errno(imp_dbh->pmysql),\r\n                      mysql_error(imp_dbh->pmysql));\r\n    }\r\n\r\n    prepare_retval= mysql_stmt_prepare(imp_sth->stmt,\r\n                                       statement,\r\n                                       strlen(statement));\r\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n        PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                      \"\\t\\tmysql_stmt_prepare returned %d\\n\",\r\n                      prepare_retval);\r\n\r\n    if (prepare_retval)\r\n    {\r\n      if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n        PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                      \"\\t\\tmysql_stmt_prepare %d %s\\n\",\r\n                      mysql_stmt_errno(imp_sth->stmt),\r\n                      mysql_stmt_error(imp_sth->stmt));\r\n\r\n      /* For commands that are not supported by server side prepared statement\r\n         mechanism lets try to pass them through regular API */\r\n      if (!imp_sth->disable_fallback_for_server_prepare && mysql_stmt_errno(imp_sth->stmt) == ER_UNSUPPORTED_PS)\r\n      {\r\n        if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n          PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                    \"\\t\\tSETTING imp_sth->use_server_side_prepare to 0\\n\");\r\n        imp_sth->use_server_side_prepare= 0;\r\n      }\r\n      else\r\n      {\r\n        do_error(sth, mysql_stmt_errno(imp_sth->stmt),\r\n                 mysql_stmt_error(imp_sth->stmt),\r\n                mysql_sqlstate(imp_dbh->pmysql));\r\n        mysql_stmt_close(imp_sth->stmt);\r\n        imp_sth->stmt= NULL;\r\n        return FALSE;\r\n      }\r\n    }\r\n    else\r\n    {\r\n      DBIc_NUM_PARAMS(imp_sth)= mysql_stmt_param_count(imp_sth->stmt);\r\n      /* mysql_stmt_param_count */\r\n\r\n      if (DBIc_NUM_PARAMS(imp_sth) > 0)\r\n      {\r\n        /* Allocate memory for bind variables */\r\n        imp_sth->bind=            alloc_bind(DBIc_NUM_PARAMS(imp_sth));\r\n        imp_sth->fbind=           alloc_fbind(DBIc_NUM_PARAMS(imp_sth));\r\n        imp_sth->has_been_bound=  0;\r\n\r\n        /* Initialize ph variables with  NULL values */\r\n        for (i= 0,\r\n             bind=      imp_sth->bind,\r\n             fbind=     imp_sth->fbind,\r\n             bind_end=  bind+DBIc_NUM_PARAMS(imp_sth);\r\n             bind < bind_end ;\r\n             bind++, fbind++, i++ )\r\n        {\r\n          bind->buffer_type=  MYSQL_TYPE_STRING;\r\n          bind->buffer=       NULL;\r\n          bind->length=       &(fbind->length);\r\n          bind->is_null=      &(fbind->is_null);\r\n          fbind->is_null=     1;\r\n          fbind->length=      0;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /* Count the number of parameters (driver, vs server-side) */\r\n  if (imp_sth->use_server_side_prepare == 0)\r\n    DBIc_NUM_PARAMS(imp_sth) = count_params((imp_xxh_t *)imp_dbh, aTHX_ statement,\r\n                                            imp_dbh->bind_comment_placeholders);\r\n\r\n  /* Allocate memory for parameters */\r\n  imp_sth->params= alloc_param(DBIc_NUM_PARAMS(imp_sth));\r\n  DBIc_IMPSET_on(imp_sth);\r\n\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t<- dbd_st_prepare\\n\");\r\n  return 1;\r\n}", ".bd_st_destroy": "void dbd_st_destroy(SV *sth, imp_sth_t *imp_sth) {\r\n  dTHX;\r\n  D_imp_xxh(sth);\r\n\r\n#if defined (dTHR)\r\n  dTHR;\r\n#endif\r\n\r\n  int i;\r\n\r\n  imp_sth_fbh_t *fbh;\r\n  int n;\r\n\r\n  n= DBIc_NUM_PARAMS(imp_sth);\r\n  if (n)\r\n  {\r\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\tFreeing %d parameters, bind %p fbind %p\\n\",\r\n          n, imp_sth->bind, imp_sth->fbind);\r\n\r\n    free_bind(imp_sth->bind);\r\n    free_fbind(imp_sth->fbind);\r\n  }\r\n\r\n  fbh= imp_sth->fbh;\r\n  if (fbh)\r\n  {\r\n    n = DBIc_NUM_FIELDS(imp_sth);\r\n    i = 0;\r\n    while (i < n)\r\n    {\r\n      if (fbh[i].data) Safefree(fbh[i].data);\r\n      ++i;\r\n    }\r\n\r\n    free_fbuffer(fbh);\r\n    if (imp_sth->buffer)\r\n      free_bind(imp_sth->buffer);\r\n  }\r\n\r\n  if (imp_sth->stmt)\r\n  {\r\n    mysql_stmt_close(imp_sth->stmt);\r\n    imp_sth->stmt= NULL;\r\n  }\r\n\r\n  /* dbd_st_finish has already been called by .xs code if needed.\t*/\r\n\r\n  /* Free values allocated by dbd_bind_ph */\r\n  if (imp_sth->params)\r\n  {\r\n    free_param(aTHX_ imp_sth->params, DBIc_NUM_PARAMS(imp_sth));\r\n    imp_sth->params= NULL;\r\n  }\r\n\r\n  /* Free cached array attributes */\r\n  for (i= 0; i < AV_ATTRIB_LAST; i++)\r\n  {\r\n    if (imp_sth->av_attr[i])\r\n      SvREFCNT_dec(imp_sth->av_attr[i]);\r\n    imp_sth->av_attr[i]= Nullav;\r\n  }\r\n  /* let DBI know we've done it   */\r\n  DBIc_IMPSET_off(imp_sth);\r\n}", ".ysql_st_internal_execute41": "my_ulonglong mysql_st_internal_execute41(\r\n                                         SV *sth,\r\n                                         int num_params,\r\n                                         MYSQL_RES **result,\r\n                                         MYSQL_STMT *stmt,\r\n                                         MYSQL_BIND *bind,\r\n                                         int *has_been_bound\r\n                                        )\r\n{\r\n  int i;\r\n  enum enum_field_types enum_type;\r\n  dTHX;\r\n  int execute_retval;\r\n  my_ulonglong rows=0;\r\n  D_imp_xxh(sth);\r\n\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                  \"\\t-> mysql_st_internal_execute41\\n\");\r\n\r\n  /* free result if exists */\r\n  if (*result)\r\n  {\r\n    mysql_free_result(*result);\r\n    *result= 0;\r\n  }\r\n\r\n  /*\r\n    If were performed any changes with ph variables\r\n    we have to rebind them\r\n  */\r\n\r\n  if (num_params > 0 && !(*has_been_bound))\r\n  {\r\n#if MYSQL_VERSION_ID >= 80300\r\n    if (mysql_stmt_bind_named_param(stmt,bind,num_params, NULL))\r\n#else\r\n    if (mysql_stmt_bind_param(stmt,bind))\r\n#endif\r\n      goto error;\r\n\r\n    *has_been_bound= 1;\r\n  }\r\n\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                  \"\\t\\tmysql_st_internal_execute41 calling mysql_execute with %d num_params\\n\",\r\n                  num_params);\r\n\r\n  execute_retval= mysql_stmt_execute(stmt);\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                  \"\\t\\tmysql_stmt_execute returned %d\\n\",\r\n                  execute_retval);\r\n  if (execute_retval)\r\n    goto error;\r\n\r\n  /*\r\n   This statement does not return a result set (INSERT, UPDATE...)\r\n  */\r\n  if (!(*result= mysql_stmt_result_metadata(stmt)))\r\n  {\r\n    if (mysql_stmt_errno(stmt))\r\n      goto error;\r\n\r\n    rows= mysql_stmt_affected_rows(stmt);\r\n\r\n    /* mysql_stmt_affected_rows(): -1 indicates that the query returned an error */\r\n    if (rows == (my_ulonglong)-1)\r\n      goto error;\r\n  }\r\n  /*\r\n    This statement returns a result set (SELECT...)\r\n  */\r\n  else\r\n  {\r\n    for (i = mysql_stmt_field_count(stmt) - 1; i >=0; --i) {\r\n        enum_type = mysql_to_perl_type(stmt->fields[i].type);\r\n        if (enum_type != MYSQL_TYPE_DOUBLE && enum_type != MYSQL_TYPE_LONG && enum_type != MYSQL_TYPE_LONGLONG && enum_type != MYSQL_TYPE_BIT)\r\n        {\r\n            /* mysql_stmt_store_result to update MYSQL_FIELD->max_length */\r\n            bool on = 1;\r\n            mysql_stmt_attr_set(stmt, STMT_ATTR_UPDATE_MAX_LENGTH, &on);\r\n            break;\r\n        }\r\n    }\r\n    /* Get the total rows affected and return */\r\n    if (mysql_stmt_store_result(stmt))\r\n      goto error;\r\n    else\r\n      rows= mysql_stmt_num_rows(stmt);\r\n  }\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                  \"\\t<- mysql_internal_execute_41 returning %lu rows\\n\",\r\n                  rows);\r\n  return(rows);\r\n\r\nerror:\r\n  if (*result)\r\n  {\r\n    mysql_free_result(*result);\r\n    *result= 0;\r\n  }\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                  \"     errno %d err message %s\\n\",\r\n                  mysql_stmt_errno(stmt),\r\n                  mysql_stmt_error(stmt));\r\n  do_error(sth, mysql_stmt_errno(stmt), mysql_stmt_error(stmt),\r\n           mysql_stmt_sqlstate(stmt));\r\n  mysql_stmt_reset(stmt);\r\n\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                  \"\\t<- mysql_st_internal_execute41\\n\");\r\n  return -2;\r\n\r\n}", ".bd_describe": "int dbd_describe(SV* sth, imp_sth_t* imp_sth)\r\n{\r\n  dTHX;\r\n  D_imp_xxh(sth);\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t--> dbd_describe\\n\");\r\n\r\n\r\n  if (imp_sth->use_server_side_prepare)\r\n  {\r\n    int i;\r\n    int col_type;\r\n    int num_fields= DBIc_NUM_FIELDS(imp_sth);\r\n    imp_sth_fbh_t *fbh;\r\n    MYSQL_BIND *buffer;\r\n    MYSQL_FIELD *fields;\r\n\r\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tdbd_describe() num_fields %d\\n\",\r\n                    num_fields);\r\n\r\n    if (imp_sth->done_desc)\r\n      return TRUE;\r\n\r\n    if (!num_fields || !imp_sth->result)\r\n    {\r\n      /* no metadata */\r\n      do_error(sth, JW_ERR_SEQUENCE,\r\n               \"no metadata information while trying describe result set\",\r\n               NULL);\r\n      return 0;\r\n    }\r\n\r\n    /* allocate fields buffers  */\r\n    if (  !(imp_sth->fbh= alloc_fbuffer(num_fields))\r\n          || !(imp_sth->buffer= alloc_bind(num_fields)) )\r\n    {\r\n      /* Out of memory */\r\n      do_error(sth, JW_ERR_SEQUENCE,\r\n               \"Out of memory in dbd_sescribe()\",NULL);\r\n      return 0;\r\n    }\r\n\r\n    fields= mysql_fetch_fields(imp_sth->result);\r\n\r\n    for (\r\n         fbh= imp_sth->fbh, buffer= (MYSQL_BIND*)imp_sth->buffer, i= 0;\r\n         i < num_fields;\r\n         i++, fbh++, buffer++\r\n        )\r\n    {\r\n      /* get the column type */\r\n      col_type = fields ? fields[i].type : MYSQL_TYPE_STRING;\r\n\r\n      if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n      {\r\n        PerlIO_printf(DBIc_LOGPIO(imp_xxh),\"\\t\\ti %d col_type %d fbh->length %lu\\n\",\r\n                      i, col_type, fbh->length);\r\n        PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                      \"\\t\\tfields[i].length %lu fields[i].max_length %lu fields[i].type %d fields[i].charsetnr %d\\n\",\r\n                      fields[i].length, fields[i].max_length, fields[i].type,\r\n                      fields[i].charsetnr);\r\n      }\r\n      fbh->charsetnr = fields[i].charsetnr;\r\n\r\n      buffer->buffer_type= mysql_to_perl_type(col_type);\r\n      if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n        PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tmysql_to_perl_type returned %d\\n\",\r\n                      col_type);\r\n      buffer->length= &(fbh->length);\r\n      buffer->is_null= &(fbh->is_null);\r\n      buffer->error= (bool*) &(fbh->error);\r\n\r\n      if (fields[i].flags & ZEROFILL_FLAG)\r\n        buffer->buffer_type = MYSQL_TYPE_STRING;\r\n\r\n      switch (buffer->buffer_type) {\r\n      case MYSQL_TYPE_DOUBLE:\r\n        buffer->buffer_length= sizeof(fbh->ddata);\r\n        buffer->buffer= (char*) &fbh->ddata;\r\n        break;\r\n\r\n      case MYSQL_TYPE_LONG:\r\n      case MYSQL_TYPE_LONGLONG:\r\n        buffer->buffer_length= sizeof(fbh->ldata);\r\n        buffer->buffer= (char*) &fbh->ldata;\r\n        buffer->is_unsigned= (fields[i].flags & UNSIGNED_FLAG) ? 1 : 0;\r\n        break;\r\n\r\n      case MYSQL_TYPE_BIT:\r\n        buffer->buffer_length= 8;\r\n        Newz(908, fbh->data, buffer->buffer_length, char);\r\n        buffer->buffer= (char *) fbh->data;\r\n        break;\r\n\r\n      default:\r\n        buffer->buffer_length= fields[i].max_length ? fields[i].max_length : 1;\r\n        Newz(908, fbh->data, buffer->buffer_length, char);\r\n        buffer->buffer= (char *) fbh->data;\r\n      }\r\n    }\r\n\r\n    if (mysql_stmt_bind_result(imp_sth->stmt, imp_sth->buffer))\r\n    {\r\n      do_error(sth, mysql_stmt_errno(imp_sth->stmt),\r\n               mysql_stmt_error(imp_sth->stmt),\r\n               mysql_stmt_sqlstate(imp_sth->stmt));\r\n      return 0;\r\n    }\r\n  }\r\n\r\n  imp_sth->done_desc= 1;\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t<- dbd_describe\\n\");\r\n  return TRUE;\r\n}", ".bd_bind_ph": "int dbd_bind_ph(SV *sth, imp_sth_t *imp_sth, SV *param, SV *value,\r\n\t\t IV sql_type, SV *attribs, int is_inout, IV maxlen) {\r\n  dTHX;\r\n  int rc;\r\n  int param_num= SvIV(param);\r\n  int idx= param_num - 1;\r\n  char *err_msg;\r\n  D_imp_xxh(sth);\r\n\r\n  STRLEN slen;\r\n  char *buffer= NULL;\r\n  int buffer_is_null= 0;\r\n  int buffer_is_unsigned= 0;\r\n  int buffer_length= 0;\r\n  unsigned int buffer_type= 0;\r\n\r\n  D_imp_dbh_from_sth;\r\n  ASYNC_CHECK_RETURN(sth, FALSE);\r\n\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                  \"   Called: dbd_bind_ph\\n\");\r\n\r\n  attribs= attribs;\r\n  maxlen= maxlen;\r\n\r\n  if (param_num <= 0  ||  param_num > DBIc_NUM_PARAMS(imp_sth))\r\n  {\r\n    do_error(sth, JW_ERR_ILLEGAL_PARAM_NUM, \"Illegal parameter number\", NULL);\r\n    return FALSE;\r\n  }\r\n\r\n  /*\r\n     This fixes the bug whereby no warning was issued upon binding a\r\n     defined non-numeric as numeric\r\n   */\r\n  if (SvOK(value) &&\r\n      (sql_type == SQL_NUMERIC  ||\r\n       sql_type == SQL_DECIMAL  ||\r\n       sql_type == SQL_INTEGER  ||\r\n       sql_type == SQL_SMALLINT ||\r\n       sql_type == SQL_FLOAT    ||\r\n       sql_type == SQL_REAL     ||\r\n       sql_type == SQL_DOUBLE) )\r\n  {\r\n    if (! looks_like_number(value))\r\n    {\r\n      err_msg = SvPVX(sv_2mortal(newSVpvf(\r\n              \"Binding non-numeric field %d, value %s as a numeric!\",\r\n              param_num, neatsvpv(value,0))));\r\n      do_error(sth, JW_ERR_ILLEGAL_PARAM_NUM, err_msg, NULL);\r\n    }\r\n  }\r\n\r\n  if (is_inout)\r\n  {\r\n    do_error(sth, JW_ERR_NOT_IMPLEMENTED, \"Output parameters not implemented\", NULL);\r\n    return FALSE;\r\n  }\r\n\r\n  rc = bind_param(&imp_sth->params[idx], value, sql_type);\r\n\r\n  if (imp_sth->use_server_side_prepare)\r\n  {\r\n      switch(sql_type) {\r\n      case SQL_NUMERIC:\r\n      case SQL_INTEGER:\r\n      case SQL_SMALLINT:\r\n      case SQL_TINYINT:\r\n#if IVSIZE >= 8\r\n      case SQL_BIGINT:\r\n          buffer_type= MYSQL_TYPE_LONGLONG;\r\n#else\r\n          buffer_type= MYSQL_TYPE_LONG;\r\n#endif\r\n          break;\r\n      case SQL_DOUBLE:\r\n      case SQL_DECIMAL: \r\n      case SQL_FLOAT: \r\n      case SQL_REAL:\r\n          buffer_type= MYSQL_TYPE_DOUBLE;\r\n          break;\r\n      case SQL_CHAR: \r\n      case SQL_VARCHAR: \r\n      case SQL_DATE: \r\n      case SQL_TIME: \r\n      case SQL_TIMESTAMP: \r\n      case SQL_LONGVARCHAR: \r\n      case SQL_BINARY: \r\n      case SQL_VARBINARY: \r\n      case SQL_LONGVARBINARY:\r\n          buffer_type= MYSQL_TYPE_BLOB;\r\n          break;\r\n      default:\r\n          buffer_type= MYSQL_TYPE_STRING;\r\n    }\r\n    buffer_is_null = !(SvOK(imp_sth->params[idx].value) && imp_sth->params[idx].value);\r\n    if (! buffer_is_null) {\r\n      switch(buffer_type) {\r\n        case MYSQL_TYPE_LONG:\r\n        case MYSQL_TYPE_LONGLONG:\r\n          /* INT */\r\n          if (!SvIOK(imp_sth->params[idx].value) && DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tTRY TO BIND AN INT NUMBER\\n\");\r\n          buffer_length = sizeof imp_sth->fbind[idx].numeric_val.lval;\r\n          imp_sth->fbind[idx].numeric_val.lval= SvIV(imp_sth->params[idx].value);\r\n          buffer=(void*)&(imp_sth->fbind[idx].numeric_val.lval);\r\n          if (!SvIOK(imp_sth->params[idx].value))\r\n          {\r\n            if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n              PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                            \"   Conversion to INT NUMBER was not successful -> '%s' --> (unsigned) '%\"UVuf\"' / (signed) '%\"IVdf\"' <- fallback to STRING\\n\",\r\n                            SvPV_nolen(imp_sth->params[idx].value), imp_sth->fbind[idx].numeric_val.lval, imp_sth->fbind[idx].numeric_val.lval);\r\n            buffer_type = MYSQL_TYPE_STRING;\r\n            break;\r\n          }\r\n          if (SvIsUV(imp_sth->params[idx].value))\r\n            buffer_is_unsigned= 1;\r\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                          \"   SCALAR type %\"IVdf\" ->%\"IVdf\"<- IS AN INT NUMBER\\n\",\r\n                          sql_type, *(IV *)buffer);\r\n          break;\r\n\r\n        case MYSQL_TYPE_DOUBLE:\r\n          if (!SvNOK(imp_sth->params[idx].value) && DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tTRY TO BIND A FLOAT NUMBER\\n\");\r\n          buffer_length = sizeof imp_sth->fbind[idx].numeric_val.dval;\r\n          imp_sth->fbind[idx].numeric_val.dval= SvNV(imp_sth->params[idx].value);\r\n          buffer=(char*)&(imp_sth->fbind[idx].numeric_val.dval);\r\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                          \"   SCALAR type %\"IVdf\" ->%f<- IS A FLOAT NUMBER\\n\",\r\n                          sql_type, (double)(*buffer));\r\n          break;\r\n\r\n        case MYSQL_TYPE_BLOB:\r\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                          \"   SCALAR type BLOB\\n\");\r\n          break;\r\n\r\n        case MYSQL_TYPE_STRING:\r\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                          \"   SCALAR type STRING %\"IVdf\", buffertype=%d\\n\", sql_type, buffer_type);\r\n          break;\r\n\r\n        default:\r\n          croak(\"Bug in DBD::Mysql file dbdimp.c#dbd_bind_ph: do not know how to handle unknown buffer type.\");\r\n      }\r\n\r\n      if (buffer_type == MYSQL_TYPE_STRING || buffer_type == MYSQL_TYPE_BLOB)\r\n      {\r\n        buffer= SvPV(imp_sth->params[idx].value, slen);\r\n        buffer_length= slen;\r\n        if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n          PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                        \" SCALAR type %\"IVdf\" ->length %d<- IS A STRING or BLOB\\n\",\r\n                        sql_type, buffer_length);\r\n      }\r\n    }\r\n    else\r\n    {\r\n      /*case: buffer_is_null != 0*/\r\n      buffer= NULL;\r\n      if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n        PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                      \"   SCALAR NULL VALUE: buffer type is: %d\\n\", buffer_type);\r\n    }\r\n\r\n    /* Type of column was changed. Force to rebind */\r\n    if (imp_sth->bind[idx].buffer_type != buffer_type || imp_sth->bind[idx].is_unsigned != buffer_is_unsigned) {\r\n      if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n          PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                        \"   FORCE REBIND: buffer type changed from %d to %d, sql-type=%\"IVdf\"\\n\",\r\n                        (int) imp_sth->bind[idx].buffer_type, buffer_type, sql_type);\r\n      imp_sth->has_been_bound = 0;\r\n    }\r\n\r\n    /* prepare has been called */\r\n    if (imp_sth->has_been_bound)\r\n    {\r\n      imp_sth->stmt->params[idx].buffer= buffer;\r\n      imp_sth->stmt->params[idx].buffer_length= buffer_length;\r\n    }\r\n\r\n    imp_sth->bind[idx].buffer_type= buffer_type;\r\n    imp_sth->bind[idx].buffer= buffer;\r\n    imp_sth->bind[idx].buffer_length= buffer_length;\r\n    imp_sth->bind[idx].is_unsigned= buffer_is_unsigned;\r\n\r\n    imp_sth->fbind[idx].length= buffer_length;\r\n    imp_sth->fbind[idx].is_null= buffer_is_null;\r\n  }\r\n  return rc;\r\n}", ".bd_db_login": "int dbd_db_login(SV* dbh, imp_dbh_t* imp_dbh, char* dbname, char* user,\r\n\t\t char* password) {\r\n#ifdef dTHR\r\n  dTHR;\r\n#endif\r\n  dTHX; \r\n  D_imp_xxh(dbh);\r\n\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n\t\t  \"imp_dbh->connect: dsn = %s, uid = %s, pwd = %s\\n\",\r\n\t\t  dbname ? dbname : \"NULL\",\r\n\t\t  user ? user : \"NULL\",\r\n\t\t  password ? password : \"NULL\");\r\n\r\n  imp_dbh->stats.auto_reconnects_ok= 0;\r\n  imp_dbh->stats.auto_reconnects_failed= 0;\r\n  imp_dbh->bind_type_guessing= FALSE;\r\n  imp_dbh->bind_comment_placeholders= FALSE;\r\n  imp_dbh->has_transactions= TRUE;\r\n /* Safer we flip this to TRUE perl side if we detect a mod_perl env. */\r\n  imp_dbh->auto_reconnect = FALSE;\r\n\r\n  imp_dbh->enable_utf8 = FALSE;     /* initialize mysql_enable_utf8 */\r\n  imp_dbh->enable_utf8mb4 = FALSE;  /* initialize mysql_enable_utf8mb4 */\r\n\r\n  if (!my_login(aTHX_ dbh, imp_dbh))\r\n  {\r\n    if(imp_dbh->pmysql) {\r\n        do_error(dbh, mysql_errno(imp_dbh->pmysql),\r\n                mysql_error(imp_dbh->pmysql) ,mysql_sqlstate(imp_dbh->pmysql));\r\n        Safefree(imp_dbh->pmysql);\r\n\r\n    }\r\n    return FALSE;\r\n  }\r\n\r\n    /*\r\n     *  Tell DBI, that dbh->disconnect should be called for this handle\r\n     */\r\n    DBIc_ACTIVE_on(imp_dbh);\r\n\r\n    /* Tell DBI, that dbh->destroy should be called for this handle */\r\n    DBIc_on(imp_dbh, DBIcf_IMPSET);\r\n\r\n    return TRUE;\r\n}", ".bd_db_commit": "int\r\ndbd_db_commit(SV* dbh, imp_dbh_t* imp_dbh)\r\n{\r\n  if (DBIc_has(imp_dbh, DBIcf_AutoCommit))\r\n    return FALSE;\r\n\r\n  ASYNC_CHECK_RETURN(dbh, FALSE);\r\n\r\n  if (imp_dbh->has_transactions)\r\n  {\r\n    if (mysql_commit(imp_dbh->pmysql))\r\n    {\r\n      do_error(dbh, mysql_errno(imp_dbh->pmysql), mysql_error(imp_dbh->pmysql)\r\n               ,mysql_sqlstate(imp_dbh->pmysql));\r\n      return FALSE;\r\n    }\r\n  }\r\n  else\r\n    do_warn(dbh, JW_ERR_NOT_IMPLEMENTED,\r\n            \"Commit ineffective because transactions are not available\");\r\n  return TRUE;\r\n}", ".bd_db_rollback": "int\r\ndbd_db_rollback(SV* dbh, imp_dbh_t* imp_dbh) {\r\n  /* croak, if not in AutoCommit mode */\r\n  if (DBIc_has(imp_dbh, DBIcf_AutoCommit))\r\n    return FALSE;\r\n\r\n  ASYNC_CHECK_RETURN(dbh, FALSE);\r\n\r\n  if (imp_dbh->has_transactions)\r\n  {\r\n      if (mysql_rollback(imp_dbh->pmysql))\r\n      {\r\n        do_error(dbh, mysql_errno(imp_dbh->pmysql),\r\n                 mysql_error(imp_dbh->pmysql) ,mysql_sqlstate(imp_dbh->pmysql));\r\n        return FALSE;\r\n      }\r\n  }\r\n  else\r\n    do_error(dbh, JW_ERR_NOT_IMPLEMENTED,\r\n             \"Rollback ineffective because transactions are not available\" ,NULL);\r\n  return TRUE;\r\n}", ".bd_db_destroy": "void dbd_db_destroy(SV* dbh, imp_dbh_t* imp_dbh) {\r\n\r\n    /*\r\n     *  Being on the safe side never hurts ...\r\n     */\r\n  if (DBIc_ACTIVE(imp_dbh))\r\n  {\r\n    if (imp_dbh->has_transactions)\r\n    {\r\n      if (!DBIc_has(imp_dbh, DBIcf_AutoCommit))\r\n        if (mysql_rollback(imp_dbh->pmysql))\r\n            do_error(dbh, TX_ERR_ROLLBACK,\"ROLLBACK failed\" ,NULL);\r\n    }\r\n    dbd_db_disconnect(dbh, imp_dbh);\r\n  }\r\n  Safefree(imp_dbh->pmysql);\r\n\r\n  /* Tell DBI, that dbh->destroy must no longer be called */\r\n  DBIc_off(imp_dbh, DBIcf_IMPSET);\r\n}", ".bd_db_STORE_attrib": "int\r\ndbd_db_STORE_attrib(\r\n                    SV* dbh,\r\n                    imp_dbh_t* imp_dbh,\r\n                    SV* keysv,\r\n                    SV* valuesv\r\n                   )\r\n{\r\n  dTHX;\r\n  STRLEN kl;\r\n  char *key = SvPV(keysv, kl);\r\n  SV *cachesv = Nullsv;\r\n  int cacheit = FALSE;\r\n  const bool bool_value = SvTRUE(valuesv);\r\n\r\n  if (kl==10 && strEQ(key, \"AutoCommit\"))\r\n  {\r\n    if (imp_dbh->has_transactions)\r\n    {\r\n      bool oldval = DBIc_has(imp_dbh,DBIcf_AutoCommit) ? 1 : 0;\r\n\r\n      if (bool_value == oldval)\r\n        return TRUE;\r\n\r\n      /* if setting AutoCommit on ... */\r\n      if (!imp_dbh->no_autocommit_cmd)\r\n      {\r\n        if (\r\n            mysql_autocommit(imp_dbh->pmysql, bool_value)\r\n           )\r\n        {\r\n          do_error(dbh, TX_ERR_AUTOCOMMIT,\r\n                   bool_value ?\r\n                   \"Turning on AutoCommit failed\" :\r\n                   \"Turning off AutoCommit failed\"\r\n                   ,NULL);\r\n          return TRUE;  /* TRUE means we handled it - important to avoid spurious errors */\r\n        }\r\n      }\r\n      DBIc_set(imp_dbh, DBIcf_AutoCommit, bool_value);\r\n    }\r\n    else\r\n    {\r\n      /*\r\n       *  We do support neither transactions nor \"AutoCommit\".\r\n       *  But we stub it. :-)\r\n      */\r\n      if (!bool_value)\r\n      {\r\n        do_error(dbh, JW_ERR_NOT_IMPLEMENTED,\r\n                 \"Transactions not supported by database\" ,NULL);\r\n        croak(\"Transactions not supported by database\");\r\n      }\r\n    }\r\n  }\r\n  else if (kl == 16 && strEQ(key,\"mysql_use_result\"))\r\n    imp_dbh->use_mysql_use_result = bool_value;\r\n  else if (kl == 20 && strEQ(key,\"mysql_auto_reconnect\"))\r\n    imp_dbh->auto_reconnect = bool_value;\r\n  else if (kl == 20 && strEQ(key, \"mysql_server_prepare\"))\r\n    imp_dbh->use_server_side_prepare = bool_value;\r\n  else if (kl == 37 && strEQ(key, \"mysql_server_prepare_disable_fallback\"))\r\n    imp_dbh->disable_fallback_for_server_prepare = bool_value;\r\n  else if (kl == 23 && strEQ(key,\"mysql_no_autocommit_cmd\"))\r\n    imp_dbh->no_autocommit_cmd = bool_value;\r\n  else if (kl == 24 && strEQ(key,\"mysql_bind_type_guessing\"))\r\n    imp_dbh->bind_type_guessing = bool_value;\r\n  else if (kl == 31 && strEQ(key,\"mysql_bind_comment_placeholders\"))\r\n    imp_dbh->bind_type_guessing = bool_value;\r\n  else if (kl == 17 && strEQ(key, \"mysql_enable_utf8\"))\r\n    imp_dbh->enable_utf8 = bool_value;\r\n  else if (kl == 20 && strEQ(key, \"mysql_enable_utf8mb4\"))\r\n    imp_dbh->enable_utf8mb4 = bool_value;\r\n  else\r\n    return FALSE;\t\t\t\t/* Unknown key */\r\n\r\n  if (cacheit) /* cache value for later DBI 'quick' fetch? */\r\n    (void)hv_store((HV*)SvRV(dbh), key, kl, cachesv, 0);\r\n  return TRUE;\r\n}", ".ysql_st_free_result_sets": "int mysql_st_free_result_sets (SV * sth, imp_sth_t * imp_sth)\r\n{\r\n  dTHX;\r\n  D_imp_dbh_from_sth;\r\n  D_imp_xxh(sth);\r\n  int next_result_rc= -1;\r\n\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t>- dbd_st_free_result_sets\\n\");\r\n\r\n  do\r\n  {\r\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t<- dbd_st_free_result_sets RC %d\\n\", next_result_rc);\r\n\r\n    if (next_result_rc == 0)\r\n    {\r\n      if (!(imp_sth->result = mysql_use_result(imp_dbh->pmysql)))\r\n      {\r\n        /* Check for possible error */\r\n        if (mysql_field_count(imp_dbh->pmysql))\r\n        {\r\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n          PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t<- dbd_st_free_result_sets ERROR: %s\\n\",\r\n                                  mysql_error(imp_dbh->pmysql));\r\n\r\n          do_error(sth, mysql_errno(imp_dbh->pmysql), mysql_error(imp_dbh->pmysql),\r\n                   mysql_sqlstate(imp_dbh->pmysql));\r\n          return 0;\r\n        }\r\n      }\r\n    }\r\n    if (imp_sth->result)\r\n    {\r\n      mysql_free_result(imp_sth->result);\r\n      imp_sth->result=NULL;\r\n    }\r\n  } while ((next_result_rc=mysql_next_result(imp_dbh->pmysql))==0);\r\n\r\n  if (next_result_rc > 0)\r\n  {\r\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t<- dbd_st_free_result_sets: Error while processing multi-result set: %s\\n\",\r\n                    mysql_error(imp_dbh->pmysql));\r\n\r\n    do_error(sth, mysql_errno(imp_dbh->pmysql), mysql_error(imp_dbh->pmysql),\r\n             mysql_sqlstate(imp_dbh->pmysql));\r\n  }\r\n\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t<- dbd_st_free_result_sets\\n\");\r\n\r\n  return 1;\r\n}", ".bd_st_more_results": "int dbd_st_more_results(SV* sth, imp_sth_t* imp_sth)\r\n{\r\n  dTHX;\r\n  D_imp_dbh_from_sth;\r\n  D_imp_xxh(sth);\r\n\r\n  int use_mysql_use_result=imp_sth->use_mysql_use_result;\r\n  int next_result_return_code, i;\r\n  MYSQL* svsock= imp_dbh->pmysql;\r\n\r\n  if (!SvROK(sth) || SvTYPE(SvRV(sth)) != SVt_PVHV)\r\n    croak(\"Expected hash array\");\r\n\r\n  if (!mysql_more_results(svsock))\r\n  {\r\n    /* No more pending result set(s)*/\r\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n\t\t    \"\\n      <- dbs_st_more_results no more results\\n\");\r\n    return 0;\r\n  }\r\n\r\n  if (imp_sth->use_server_side_prepare)\r\n  {\r\n    do_warn(sth, JW_ERR_NOT_IMPLEMENTED,\r\n            \"Processing of multiple result set is not possible with server side prepare\");\r\n    return 0;\r\n  }\r\n\r\n  /*\r\n   *  Free cached array attributes\r\n   */\r\n  for (i= 0; i < AV_ATTRIB_LAST;  i++)\r\n  {\r\n    if (imp_sth->av_attr[i])\r\n      SvREFCNT_dec(imp_sth->av_attr[i]);\r\n\r\n    imp_sth->av_attr[i]= Nullav;\r\n  }\r\n\r\n  /* Release previous MySQL result*/\r\n  if (imp_sth->result)\r\n  {\r\n    mysql_free_result(imp_sth->result);\r\n    imp_sth->result= NULL;\r\n  }\r\n\r\n  if (DBIc_ACTIVE(imp_sth))\r\n    DBIc_ACTIVE_off(imp_sth);\r\n\r\n  next_result_return_code= mysql_next_result(svsock);\r\n\r\n  imp_sth->warning_count = mysql_warning_count(imp_dbh->pmysql);\r\n\r\n  /*\r\n    mysql_next_result returns\r\n      0 if there are more results\r\n     -1 if there are no more results\r\n     >0 if there was an error\r\n   */\r\n  if (next_result_return_code > 0)\r\n  {\r\n    do_error(sth, mysql_errno(svsock), mysql_error(svsock),\r\n             mysql_sqlstate(svsock));\r\n\r\n    return 0;\r\n  }\r\n  else if(next_result_return_code == -1)                                                                                                                  \r\n  {                                                                                                                                                       \r\n    return 0;                                                                                                                                             \r\n  }  \r\n  else\r\n  {\r\n    /* Store the result from the Query */\r\n    imp_sth->result = use_mysql_use_result ?\r\n     mysql_use_result(svsock) : mysql_store_result(svsock);\r\n\r\n    if (mysql_errno(svsock))\r\n    {\r\n      do_error(sth, mysql_errno(svsock), mysql_error(svsock), \r\n               mysql_sqlstate(svsock));\r\n      return 0;\r\n    }\r\n\r\n    imp_sth->row_num= mysql_affected_rows(imp_dbh->pmysql);\r\n\r\n    if (imp_sth->result == NULL)\r\n    {\r\n      /* No \"real\" rowset*/\r\n      DBIc_NUM_FIELDS(imp_sth)= 0; /* for DBI <= 1.53 */\r\n      DBIS->set_attr_k(sth, sv_2mortal(newSVpvn(\"NUM_OF_FIELDS\",13)), 0,\r\n\t\t\t               sv_2mortal(newSViv(0)));\r\n      return 1;\r\n    }\r\n    else\r\n    {\r\n      /* We have a new rowset */\r\n      imp_sth->currow=0;\r\n\r\n\r\n      /* delete cached handle attributes */\r\n      /* XXX should be driven by a list to ease maintenance */\r\n      (void)hv_delete((HV*)SvRV(sth), \"NAME\", 4, G_DISCARD);\r\n      (void)hv_delete((HV*)SvRV(sth), \"NULLABLE\", 8, G_DISCARD);\r\n      (void)hv_delete((HV*)SvRV(sth), \"NUM_OF_FIELDS\", 13, G_DISCARD);\r\n      (void)hv_delete((HV*)SvRV(sth), \"PRECISION\", 9, G_DISCARD);\r\n      (void)hv_delete((HV*)SvRV(sth), \"SCALE\", 5, G_DISCARD);\r\n      (void)hv_delete((HV*)SvRV(sth), \"TYPE\", 4, G_DISCARD);\r\n      (void)hv_delete((HV*)SvRV(sth), \"mysql_insertid\", 14, G_DISCARD);\r\n      (void)hv_delete((HV*)SvRV(sth), \"mysql_is_auto_increment\", 23, G_DISCARD);\r\n      (void)hv_delete((HV*)SvRV(sth), \"mysql_is_blob\", 13, G_DISCARD);\r\n      (void)hv_delete((HV*)SvRV(sth), \"mysql_is_key\", 12, G_DISCARD);\r\n      (void)hv_delete((HV*)SvRV(sth), \"mysql_is_num\", 12, G_DISCARD);\r\n      (void)hv_delete((HV*)SvRV(sth), \"mysql_is_pri_key\", 16, G_DISCARD);\r\n      (void)hv_delete((HV*)SvRV(sth), \"mysql_length\", 12, G_DISCARD);\r\n      (void)hv_delete((HV*)SvRV(sth), \"mysql_max_length\", 16, G_DISCARD);\r\n      (void)hv_delete((HV*)SvRV(sth), \"mysql_table\", 11, G_DISCARD);\r\n      (void)hv_delete((HV*)SvRV(sth), \"mysql_type\", 10, G_DISCARD);\r\n      (void)hv_delete((HV*)SvRV(sth), \"mysql_type_name\", 15, G_DISCARD);\r\n      (void)hv_delete((HV*)SvRV(sth), \"mysql_warning_count\", 20, G_DISCARD);\r\n\r\n      /* Adjust NUM_OF_FIELDS - which also adjusts the row buffer size */\r\n      DBIc_NUM_FIELDS(imp_sth)= 0; /* for DBI <= 1.53 */\r\n      DBIc_DBISTATE(imp_sth)->set_attr_k(sth, sv_2mortal(newSVpvn(\"NUM_OF_FIELDS\",13)), 0,\r\n          sv_2mortal(newSViv(mysql_num_fields(imp_sth->result)))\r\n      );\r\n\r\n      DBIc_ACTIVE_on(imp_sth);\r\n\r\n      imp_sth->done_desc = 0;\r\n    }\r\n    imp_dbh->pmysql->net.last_errno= 0;\r\n    return 1;\r\n  }\r\n}", ".ysql_st_internal_execute": "my_ulonglong mysql_st_internal_execute(\r\n                                       SV *h, /* could be sth or dbh */\r\n                                       SV *statement,\r\n                                       SV *attribs,\r\n                                       int num_params,\r\n                                       imp_sth_ph_t *params,\r\n                                       MYSQL_RES **result,\r\n                                       MYSQL *svsock,\r\n                                       int use_mysql_use_result\r\n                                      )\r\n{\r\n  dTHX;\r\n  bool bind_type_guessing= FALSE;\r\n  bool bind_comment_placeholders= TRUE;\r\n  STRLEN slen;\r\n  char *sbuf = SvPV(statement, slen);\r\n  char *salloc;\r\n  int htype;\r\n  bool async = FALSE;\r\n  my_ulonglong rows= 0;\r\n  /* thank you DBI.c for this info! */\r\n  D_imp_xxh(h);\r\n  attribs= attribs;\r\n\r\n  htype= DBIc_TYPE(imp_xxh);\r\n  /*\r\n    It is important to import imp_dbh properly according to the htype\r\n    that it is! Also, one might ask why bind_type_guessing is assigned\r\n    in each block. Well, it's because D_imp_ macros called in these\r\n    blocks make it so imp_dbh is not \"visible\" or defined outside of the\r\n    if/else (when compiled, it fails for imp_dbh not being defined).\r\n  */\r\n  /* h is a dbh */\r\n  if (htype == DBIt_DB)\r\n  {\r\n    D_imp_dbh(h);\r\n    /* if imp_dbh is not available, it causes segfault (proper) on OpenBSD */\r\n    if (imp_dbh)\r\n    {\r\n      bind_type_guessing= imp_dbh->bind_type_guessing;\r\n      bind_comment_placeholders= imp_dbh->bind_comment_placeholders;\r\n    }\r\n    async = (bool) (imp_dbh->async_query_in_flight != NULL);\r\n  }\r\n  /* h is a sth */\r\n  else\r\n  {\r\n    D_imp_sth(h);\r\n    D_imp_dbh_from_sth;\r\n    /* if imp_dbh is not available, it causes segfault (proper) on OpenBSD */\r\n    if (imp_dbh)\r\n    {\r\n      bind_type_guessing= imp_dbh->bind_type_guessing;\r\n      bind_comment_placeholders= imp_dbh->bind_comment_placeholders;\r\n    }\r\n    async = imp_sth->is_async;\r\n    if(async) {\r\n        imp_dbh->async_query_in_flight = imp_sth;\r\n    } else {\r\n        imp_dbh->async_query_in_flight = NULL;\r\n    }\r\n  }\r\n\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"mysql_st_internal_execute MYSQL_VERSION_ID %d\\n\",\r\n                  MYSQL_VERSION_ID );\r\n\r\n  salloc= parse_params(imp_xxh,\r\n                              aTHX_ svsock,\r\n                              sbuf,\r\n                              &slen,\r\n                              params,\r\n                              num_params,\r\n                              bind_type_guessing,\r\n                              bind_comment_placeholders);\r\n\r\n  if (salloc)\r\n  {\r\n    sbuf= salloc;\r\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"Binding parameters: %s\\n\", sbuf);\r\n  }\r\n\r\n  if(async) {\r\n    if((mysql_send_query(svsock, sbuf, slen)) &&\r\n       (!mysql_db_reconnect(h) ||\r\n        (mysql_send_query(svsock, sbuf, slen))))\r\n    {\r\n        rows = -2;\r\n    } else {\r\n        rows = 0;\r\n    }\r\n  } else {\r\n      if ((mysql_real_query(svsock, sbuf, slen))  &&\r\n          (!mysql_db_reconnect(h)  ||\r\n           (mysql_real_query(svsock, sbuf, slen))))\r\n      {\r\n        rows = -2;\r\n      } else {\r\n          /** Store the result from the Query */\r\n          *result= use_mysql_use_result ?\r\n            mysql_use_result(svsock) : mysql_store_result(svsock);\r\n\r\n          if (mysql_errno(svsock))\r\n            rows = -2;\r\n          else if (*result)\r\n            rows = mysql_num_rows(*result);\r\n          else {\r\n            rows = mysql_affected_rows(svsock);\r\n            /* mysql_affected_rows(): -1 indicates that the query returned an error */\r\n            if (rows == (my_ulonglong)-1)\r\n              rows = -2;\r\n          }\r\n      }\r\n  }\r\n\r\n  if (salloc)\r\n    Safefree(salloc);\r\n\r\n  if(rows == (my_ulonglong)-2) {\r\n    do_error(h, mysql_errno(svsock), mysql_error(svsock), \r\n             mysql_sqlstate(svsock));\r\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"IGNORING ERROR errno %d\\n\", mysql_errno(svsock));\r\n  }\r\n  return(rows);\r\n}", ".bd_st_execute": "int dbd_st_execute(SV* sth, imp_sth_t* imp_sth)\r\n{\r\n  dTHX;\r\n  char actual_row_num[64];\r\n  int i;\r\n  SV **statement;\r\n  D_imp_dbh_from_sth;\r\n  D_imp_xxh(sth);\r\n#if defined (dTHR)\r\n  dTHR;\r\n#endif\r\n  int use_server_side_prepare = imp_sth->use_server_side_prepare;\r\n  int disable_fallback_for_server_prepare = imp_sth->disable_fallback_for_server_prepare;\r\n\r\n  ASYNC_CHECK_RETURN(sth, -2);\r\n\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n      \" -> dbd_st_execute for %p\\n\", sth);\r\n\r\n  if (!SvROK(sth)  ||  SvTYPE(SvRV(sth)) != SVt_PVHV)\r\n    croak(\"Expected hash array\");\r\n\r\n  /* Free cached array attributes */\r\n  for (i= 0;  i < AV_ATTRIB_LAST;  i++)\r\n  {\r\n    if (imp_sth->av_attr[i])\r\n      SvREFCNT_dec(imp_sth->av_attr[i]);\r\n\r\n    imp_sth->av_attr[i]= Nullav;\r\n  }\r\n\r\n  statement= hv_fetch((HV*) SvRV(sth), \"Statement\", 9, FALSE);\r\n\r\n  /* \r\n     Clean-up previous result set(s) for sth to prevent\r\n     'Commands out of sync' error \r\n  */\r\n  mysql_st_free_result_sets (sth, imp_sth);\r\n\r\n  if (use_server_side_prepare)\r\n  {\r\n    if (imp_sth->use_mysql_use_result)\r\n    {\r\n      if (disable_fallback_for_server_prepare)\r\n      {\r\n        do_error(sth, ER_UNSUPPORTED_PS,\r\n                 \"\\\"mysql_use_result\\\" not supported with server side prepare\",\r\n                 \"HY000\");\r\n        return 0;\r\n      }\r\n      use_server_side_prepare = 0;\r\n    }\r\n\r\n    if (use_server_side_prepare)\r\n    {\r\n      imp_sth->row_num= mysql_st_internal_execute41(\r\n                                                    sth,\r\n                                                    DBIc_NUM_PARAMS(imp_sth),\r\n                                                    &imp_sth->result,\r\n                                                    imp_sth->stmt,\r\n                                                    imp_sth->bind,\r\n                                                    &imp_sth->has_been_bound\r\n                                                   );\r\n      if (imp_sth->row_num == (my_ulonglong)-2) /* -2 means error */\r\n      {\r\n        SV *err = DBIc_ERR(imp_xxh);\r\n        if (!disable_fallback_for_server_prepare && SvIV(err) == ER_UNSUPPORTED_PS)\r\n        {\r\n          use_server_side_prepare = 0;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  if (!use_server_side_prepare)\r\n  {\r\n    imp_sth->row_num= mysql_st_internal_execute(\r\n                                                sth,\r\n                                                *statement,\r\n                                                NULL,\r\n                                                DBIc_NUM_PARAMS(imp_sth),\r\n                                                imp_sth->params,\r\n                                                &imp_sth->result,\r\n                                                imp_dbh->pmysql,\r\n                                                imp_sth->use_mysql_use_result\r\n                                               );\r\n    if(imp_dbh->async_query_in_flight) {\r\n        DBIc_ACTIVE_on(imp_sth);\r\n        return 0;\r\n    }\r\n  }\r\n\r\n  if (imp_sth->row_num+1 != (my_ulonglong)-1)\r\n  {\r\n    if (!imp_sth->result)\r\n    {\r\n      imp_sth->insertid= mysql_insert_id(imp_dbh->pmysql);\r\n      if (mysql_more_results(imp_dbh->pmysql))\r\n        DBIc_ACTIVE_on(imp_sth);\r\n    }\r\n    else\r\n    {\r\n      /** Store the result in the current statement handle */\r\n      DBIc_NUM_FIELDS(imp_sth)= mysql_num_fields(imp_sth->result);\r\n      DBIc_ACTIVE_on(imp_sth);\r\n      if (!use_server_side_prepare)\r\n        imp_sth->done_desc= 0;\r\n      imp_sth->fetch_done= 0;\r\n    }\r\n  }\r\n\r\n  imp_sth->warning_count = mysql_warning_count(imp_dbh->pmysql);\r\n\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n  {\r\n    /* \r\n      PerlIO_printf doesn't always handle imp_sth->row_num %llu \r\n      consistently!!\r\n    */\r\n    sprintf(actual_row_num, \"%lu\", imp_sth->row_num);\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\r\n                  \" <- dbd_st_execute returning imp_sth->row_num %s\\n\",\r\n                  actual_row_num);\r\n  }\r\n\r\n  return (int)imp_sth->row_num;\r\n}", ".bd_st_finish": "int dbd_st_finish(SV* sth, imp_sth_t* imp_sth) {\r\n  dTHX;\r\n  D_imp_xxh(sth);\r\n\r\n#if defined (dTHR)\r\n  dTHR;\r\n#endif\r\n\r\n  D_imp_dbh_from_sth;\r\n  if(imp_dbh->async_query_in_flight) {\r\n    mysql_db_async_result(sth, &imp_sth->result);\r\n  }\r\n\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n  {\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\n--> dbd_st_finish\\n\");\r\n  }\r\n\r\n  if (imp_sth->use_server_side_prepare)\r\n  {\r\n    if (imp_sth && imp_sth->stmt)\r\n    {\r\n      if (!mysql_st_clean_cursor(sth, imp_sth))\r\n      {\r\n        do_error(sth, JW_ERR_SEQUENCE,\r\n                 \"Error happened while tried to clean up stmt\",NULL);\r\n        return 0;\r\n      }\r\n    }\r\n  }\r\n\r\n  /*\r\n    Cancel further fetches from this cursor.\r\n    We don't close the cursor till DESTROY.\r\n    The application may re execute it.\r\n  */\r\n  if (imp_sth && DBIc_ACTIVE(imp_sth))\r\n  {\r\n    /*\r\n      Clean-up previous result set(s) for sth to prevent\r\n      'Commands out of sync' error\r\n    */\r\n    mysql_st_free_result_sets(sth, imp_sth);\r\n  }\r\n  DBIc_ACTIVE_off(imp_sth);\r\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\r\n  {\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\n<-- dbd_st_finish\\n\");\r\n  }\r\n  return 1;\r\n}", ".ysql_db_reconnect": "int mysql_db_reconnect(SV* h)\r\n{\r\n  dTHX;\r\n  D_imp_xxh(h);\r\n  imp_dbh_t* imp_dbh;\r\n  MYSQL save_socket;\r\n\r\n  if (DBIc_DBISTATE(imp_xxh)->debug >= 2)\r\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"reconnecting\\n\");\r\n\r\n  if (DBIc_TYPE(imp_xxh) == DBIt_ST)\r\n  {\r\n    imp_dbh = (imp_dbh_t*) DBIc_PARENT_COM(imp_xxh);\r\n    h = DBIc_PARENT_H(imp_xxh);\r\n  }\r\n  else\r\n    imp_dbh= (imp_dbh_t*) imp_xxh;\r\n\r\n  /* reconnect a closed connection, used in do() for implicit reconnect */\r\n  if (!DBIc_has(imp_dbh, DBIcf_ACTIVE) && DBIc_has(imp_dbh, DBIcf_AutoCommit)) {\r\n    if (my_login(aTHX_ h, imp_dbh)) {\r\n      DBIc_ACTIVE_on(imp_dbh);\r\n      DBIc_set(imp_dbh, DBIcf_AutoCommit, TRUE);\r\n      return TRUE;\r\n    }\r\n    return FALSE;\r\n  }\r\n\r\n  if (mysql_errno(imp_dbh->pmysql) != CR_SERVER_GONE_ERROR &&\r\n#ifdef ER_CLIENT_INTERACTION_TIMEOUT /* Added in 8.0.24 */\r\n          mysql_errno(imp_dbh->pmysql) != ER_CLIENT_INTERACTION_TIMEOUT &&\r\n#endif\r\n          mysql_errno(imp_dbh->pmysql) != CR_SERVER_LOST) {\r\n    /* Other error */\r\n    if (DBIc_DBISTATE(imp_xxh)->debug >= 2)\r\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"Can't reconnect on unexpected error %d\\n\",\r\n          mysql_errno(imp_dbh->pmysql));\r\n    return FALSE;\r\n  }\r\n\r\n  if (!DBIc_has(imp_dbh, DBIcf_AutoCommit) || !imp_dbh->auto_reconnect)\r\n  {\r\n    /* We never reconnect if AutoCommit is turned off.\r\n     * Otherwise we might get an inconsistent transaction\r\n     * state.\r\n     */\r\n    if (DBIc_DBISTATE(imp_xxh)->debug >= 2)\r\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"Can't reconnect as AutoCommit is turned off\\n\");\r\n    return FALSE;\r\n  }\r\n\r\n  /* my_login will blow away imp_dbh->mysql so we save a copy of\r\n   * imp_dbh->mysql and put it back where it belongs if the reconnect\r\n   * fail.  Think server is down & reconnect fails but the application eval{}s\r\n   * the execute, so next time $dbh->quote() gets called, instant SIGSEGV!\r\n   */\r\n  save_socket= *(imp_dbh->pmysql);\r\n  memcpy (&save_socket, imp_dbh->pmysql,sizeof(save_socket));\r\n  memset (imp_dbh->pmysql,0,sizeof(*(imp_dbh->pmysql)));\r\n\r\n  /* we should disconnect the db handle before reconnecting, this will\r\n   * prevent my_login from thinking it's adopting an active child which\r\n   * would prevent the handle from actually reconnecting\r\n   */\r\n  if (!dbd_db_disconnect(h, imp_dbh) || !my_login(aTHX_ h, imp_dbh))\r\n  {\r\n    do_error(h, mysql_errno(imp_dbh->pmysql), mysql_error(imp_dbh->pmysql),\r\n             mysql_sqlstate(imp_dbh->pmysql));\r\n    memcpy (imp_dbh->pmysql, &save_socket, sizeof(save_socket));\r\n    ++imp_dbh->stats.auto_reconnects_failed;\r\n    return FALSE;\r\n  }\r\n\r\n  /*\r\n   *  Tell DBI, that dbh->disconnect should be called for this handle\r\n   */\r\n  DBIc_ACTIVE_on(imp_dbh);\r\n\r\n  ++imp_dbh->stats.auto_reconnects_ok;\r\n  return TRUE;\r\n}", ".ysql_db_async_result": "int mysql_db_async_result(SV* h, MYSQL_RES** resp)\r\n{\r\n  dTHX;\r\n  D_imp_xxh(h);\r\n  imp_dbh_t* dbh;\r\n  MYSQL* svsock = NULL;\r\n  MYSQL_RES* _res;\r\n  int retval = 0;\r\n  int htype;\r\n  bool async_sth = FALSE;\r\n\r\n  if(! resp) {\r\n      resp = &_res;\r\n  }\r\n  htype = DBIc_TYPE(imp_xxh);\r\n\r\n\r\n  if(htype == DBIt_DB) {\r\n      D_imp_dbh(h);\r\n      dbh = imp_dbh;\r\n  } else {\r\n      D_imp_sth(h);\r\n      D_imp_dbh_from_sth;\r\n      dbh = imp_dbh;\r\n      async_sth = imp_sth->is_async;\r\n      retval = imp_sth->row_num;\r\n  }\r\n\r\n  if(! dbh->async_query_in_flight) {\r\n      if (async_sth)\r\n          return retval;\r\n      do_error(h, 2000, \"Gathering asynchronous results for a synchronous handle\", \"HY000\");\r\n      return -1;\r\n  }\r\n  if(dbh->async_query_in_flight != imp_xxh) {\r\n      do_error(h, 2000, \"Gathering async_query_in_flight results for the wrong handle\", \"HY000\");\r\n      return -1;\r\n  }\r\n  dbh->async_query_in_flight = NULL;\r\n\r\n  svsock= dbh->pmysql;\r\n  retval= mysql_read_query_result(svsock);\r\n  if(! retval) {\r\n    *resp= mysql_store_result(svsock);\r\n\r\n    if (mysql_errno(svsock))\r\n      do_error(h, mysql_errno(svsock), mysql_error(svsock), mysql_sqlstate(svsock));\r\n    if (!*resp)\r\n      retval= mysql_affected_rows(svsock);\r\n    else {\r\n      retval= mysql_num_rows(*resp);\r\n      if(resp == &_res) {\r\n        mysql_free_result(*resp);\r\n        *resp= NULL;\r\n      }\r\n    }\r\n    if(htype == DBIt_ST) {\r\n      D_imp_sth(h);\r\n      D_imp_dbh_from_sth;\r\n\r\n      if((my_ulonglong)retval+1 != (my_ulonglong)-1) {\r\n        if(! *resp) {\r\n          imp_sth->insertid= mysql_insert_id(svsock);\r\n          if(! mysql_more_results(svsock))\r\n            DBIc_ACTIVE_off(imp_sth);\r\n        } else {\r\n          DBIc_NUM_FIELDS(imp_sth)= mysql_num_fields(imp_sth->result);\r\n          imp_sth->done_desc= 0;\r\n          imp_sth->fetch_done= 0;\r\n        }\r\n      }\r\n      imp_sth->warning_count = mysql_warning_count(imp_dbh->pmysql);\r\n    }\r\n  } else {\r\n     do_error(h, mysql_errno(svsock), mysql_error(svsock),\r\n              mysql_sqlstate(svsock));\r\n     return -1;\r\n  }\r\n return retval;\r\n}", ".ysql_db_async_ready": "int mysql_db_async_ready(SV* h)\r\n{\r\n  dTHX;\r\n  D_imp_xxh(h);\r\n  imp_dbh_t* dbh;\r\n  int htype;\r\n  bool async_sth = FALSE;\r\n  bool async_active = FALSE;\r\n\r\n  htype = DBIc_TYPE(imp_xxh);\r\n  \r\n  if(htype == DBIt_DB) {\r\n      D_imp_dbh(h);\r\n      dbh = imp_dbh;\r\n  } else {\r\n      D_imp_sth(h);\r\n      D_imp_dbh_from_sth;\r\n      dbh = imp_dbh;\r\n      async_sth = imp_sth->is_async;\r\n      async_active = !!DBIc_ACTIVE(imp_sth);\r\n  }\r\n\r\n  if(dbh->async_query_in_flight) {\r\n      if(dbh->async_query_in_flight == imp_xxh && dbh->pmysql->net.fd != -1) {\r\n          int retval = mysql_socket_ready(dbh->pmysql->net.fd);\r\n          if(retval < 0) {\r\n              do_error(h, -retval, strerror(-retval), \"HY000\");\r\n          }\r\n          return retval;\r\n      } else {\r\n          do_error(h, 2000, \"Calling mysql_async_ready on the wrong handle\", \"HY000\");\r\n          return -1;\r\n      }\r\n  } else {\r\n      if (async_sth) {\r\n          if (async_active)\r\n              return 1;\r\n          do_error(h, 2000, \"Asynchronous handle was not executed yet\", \"HY000\");\r\n          return -1;\r\n      }\r\n      do_error(h, 2000, \"Handle is not in asynchronous mode\", \"HY000\");\r\n      return -1;\r\n  }\r\n}", ".ysql_st_clean_cursor": "int mysql_st_clean_cursor(SV* sth, imp_sth_t* imp_sth) {\r\n\r\n  if (DBIc_ACTIVE(imp_sth) && dbd_describe(sth, imp_sth) &&\r\n      !imp_sth->fetch_done)\r\n    mysql_stmt_free_result(imp_sth->stmt);\r\n  return 1;\r\n}"}, "function_name": "parse_number"}
{"function_id": null, "caller": {".irPDcapGetSa": "static INT\r\nAirPDcapGetSa(\r\n    PAIRPDCAP_CONTEXT ctx,\r\n    AIRPDCAP_SEC_ASSOCIATION_ID *id)\r\n{\r\n    INT sa_index;\r\n    if (ctx->sa_index!=-1) {\r\n        /* at least one association was stored                               */\r\n        /* search for the association from sa_index to 0 (most recent added) */\r\n        for (sa_index=ctx->sa_index; sa_index>=0; sa_index--) {\r\n            if (ctx->sa[sa_index].used) {\r\n                if (memcmp(id, &(ctx->sa[sa_index].saId), sizeof(AIRPDCAP_SEC_ASSOCIATION_ID))==0) {\r\n                    ctx->index=sa_index;\r\n                    return sa_index;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    return -1;\r\n}", ".irPDcapStoreSa": "static INT\r\nAirPDcapStoreSa(\r\n    PAIRPDCAP_CONTEXT ctx,\r\n    AIRPDCAP_SEC_ASSOCIATION_ID *id)\r\n{\r\n    INT last_free;\r\n    if (ctx->first_free_index>=AIRPDCAP_MAX_SEC_ASSOCIATIONS_NR) {\r\n        /* there is no empty space available. FAILURE */\r\n        return -1;\r\n    }\r\n    if (ctx->sa[ctx->first_free_index].used) {\r\n        /* last addition was in the middle of the array (and the first_free_index was just incremented by 1)   */\r\n        /* search for a free space from the first_free_index to AIRPDCAP_STA_INFOS_NR (to avoid free blocks in */\r\n        /*              the middle)                                                                            */\r\n        for (last_free=ctx->first_free_index; last_free<AIRPDCAP_MAX_SEC_ASSOCIATIONS_NR; last_free++)\r\n            if (!ctx->sa[last_free].used)\r\n                break;\r\n\r\n        if (last_free>=AIRPDCAP_MAX_SEC_ASSOCIATIONS_NR) {\r\n            /* there is no empty space available. FAILURE */\r\n            return -1;\r\n        }\r\n\r\n        /* store first free space index */\r\n        ctx->first_free_index=last_free;\r\n    }\r\n\r\n    /* use this info */\r\n    ctx->index=ctx->first_free_index;\r\n\r\n    /* reset the info structure */\r\n    memset(ctx->sa+ctx->index, 0, sizeof(AIRPDCAP_SEC_ASSOCIATION));\r\n\r\n    ctx->sa[ctx->index].used=1;\r\n\r\n    /* set the info structure */\r\n    memcpy(&(ctx->sa[ctx->index].saId), id, sizeof(AIRPDCAP_SEC_ASSOCIATION_ID));\r\n\r\n    /* increment by 1 the first_free_index (heuristic) */\r\n    ctx->first_free_index++;\r\n\r\n    /* set the sa_index if the added index is greater the the sa_index */\r\n    if (ctx->index > ctx->sa_index)\r\n        ctx->sa_index=ctx->index;\r\n\r\n    return ctx->index;\r\n}", ".irPDcapGetSaPtr": "static PAIRPDCAP_SEC_ASSOCIATION\r\nAirPDcapGetSaPtr(\r\n    PAIRPDCAP_CONTEXT ctx,\r\n    AIRPDCAP_SEC_ASSOCIATION_ID *id)\r\n{\r\n    int sa_index;\r\n\r\n    /* search for a cached Security Association for supplied BSSID and STA MAC  */\r\n    if ((sa_index=AirPDcapGetSa(ctx, id))==-1) {\r\n        /* create a new Security Association if it doesn't currently exist      */\r\n        if ((sa_index=AirPDcapStoreSa(ctx, id))==-1) {\r\n            return NULL;\r\n        }\r\n    }\r\n    /* get the Security Association structure   */\r\n    return &ctx->sa[sa_index];\r\n}", ".irPDcapRsna4WHandshake": "static INT\r\nAirPDcapRsna4WHandshake(\r\n    PAIRPDCAP_CONTEXT ctx,\r\n    const UCHAR *data,\r\n    AIRPDCAP_SEC_ASSOCIATION *sa,\r\n    INT offset,\r\n    const guint tot_len)\r\n{\r\n    AIRPDCAP_KEY_ITEM *tmp_key, *tmp_pkt_key, pkt_key;\r\n    AIRPDCAP_SEC_ASSOCIATION *tmp_sa;\r\n    INT key_index;\r\n    INT ret_value=1;\r\n    UCHAR useCache=FALSE;\r\n    UCHAR eapol[AIRPDCAP_EAPOL_MAX_LEN];\r\n    USHORT eapol_len;\r\n\r\n    if (sa->key!=NULL)\r\n        useCache=TRUE;\r\n\r\n    /* a 4-way handshake packet use a Pairwise key type (IEEE 802.11i-2004, pg. 79) */\r\n    if (AIRPDCAP_EAP_KEY(data[offset+1])!=1) {\r\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsna4WHandshake\", \"Group/STAKey message (not used)\", AIRPDCAP_DEBUG_LEVEL_5);\r\n        return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\r\n    }\r\n\r\n    /* TODO timeouts? */\r\n\r\n    /* TODO consider key-index */\r\n\r\n    /* TODO considera Deauthentications */\r\n\r\n    AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsna4WHandshake\", \"4-way handshake...\", AIRPDCAP_DEBUG_LEVEL_5);\r\n\r\n    /* manage 4-way handshake packets; this step completes the 802.1X authentication process (IEEE 802.11i-2004, pag. 85) */\r\n\r\n    /* message 1: Authenticator->Supplicant (Sec=0, Mic=0, Ack=1, Inst=0, Key=1(pairwise), KeyRSC=0, Nonce=ANonce, MIC=0) */\r\n    if (AIRPDCAP_EAP_INST(data[offset+1])==0 &&\r\n        AIRPDCAP_EAP_ACK(data[offset+1])==1 &&\r\n        AIRPDCAP_EAP_MIC(data[offset])==0)\r\n    {\r\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsna4WHandshake\", \"4-way handshake message 1\", AIRPDCAP_DEBUG_LEVEL_3);\r\n\r\n        /* On reception of Message 1, the Supplicant determines whether the Key Replay Counter field value has been        */\r\n        /* used before with the current PMKSA. If the Key Replay Counter field value is less than or equal to the current  */\r\n        /* local value, the Supplicant discards the message.                                                               */\r\n        /* -> not checked, the Authenticator will be send another Message 1 (hopefully!)                                   */\r\n\r\n        /* This saves the sa since we are reauthenticating which will overwrite our current sa GCS*/\r\n        if( sa->handshake >= 2) {\r\n            tmp_sa= g_new(AIRPDCAP_SEC_ASSOCIATION, 1);\r\n            memcpy(tmp_sa, sa, sizeof(AIRPDCAP_SEC_ASSOCIATION));\r\n            sa->validKey=FALSE;\r\n            sa->next=tmp_sa;\r\n        }\r\n\r\n        /* save ANonce (from authenticator) to derive the PTK with the SNonce (from the 2 message) */\r\n        memcpy(sa->wpa.nonce, data+offset+12, 32);\r\n\r\n        /* get the Key Descriptor Version (to select algorithm used in decryption -CCMP or TKIP-) */\r\n        sa->wpa.key_ver=AIRPDCAP_EAP_KEY_DESCR_VER(data[offset+1]);\r\n\r\n        sa->handshake=1;\r\n\r\n        return AIRPDCAP_RET_SUCCESS_HANDSHAKE;\r\n    }\r\n\r\n    /* message 2|4: Supplicant->Authenticator (Sec=0|1, Mic=1, Ack=0, Inst=0, Key=1(pairwise), KeyRSC=0, Nonce=SNonce|0, MIC=MIC(KCK,EAPOL)) */\r\n    if (AIRPDCAP_EAP_INST(data[offset+1])==0 &&\r\n        AIRPDCAP_EAP_ACK(data[offset+1])==0 &&\r\n        AIRPDCAP_EAP_MIC(data[offset])==1)\r\n    {\r\n        /* Check key data length to differentiate between message 2 or 4, same as in epan/dissectors/packet-ieee80211.c */\r\n        if (pntoh16(data+offset+92)) {\r\n            /* message 2 */\r\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsna4WHandshake\", \"4-way handshake message 2\", AIRPDCAP_DEBUG_LEVEL_3);\r\n\r\n            /* On reception of Message 2, the Authenticator checks that the key replay counter corresponds to the */\r\n            /* outstanding Message 1. If not, it silently discards the message.                                   */\r\n            /* If the calculated MIC does not match the MIC that the Supplicant included in the EAPOL-Key frame,  */\r\n            /* the Authenticator silently discards Message 2.                                                     */\r\n            /* -> not checked; the Supplicant will send another message 2 (hopefully!)                            */\r\n\r\n            /* now you can derive the PTK */\r\n            for (key_index=0; key_index<(INT)ctx->keys_nr || useCache; key_index++) {\r\n                /* use the cached one, or try all keys */\r\n                if (!useCache) {\r\n                    AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsna4WHandshake\", \"Try WPA key...\", AIRPDCAP_DEBUG_LEVEL_3);\r\n                    tmp_key=&ctx->keys[key_index];\r\n                } else {\r\n                    /* there is a cached key in the security association, if it's a WPA key try it... */\r\n                    if (sa->key!=NULL &&\r\n                        (sa->key->KeyType==AIRPDCAP_KEY_TYPE_WPA_PWD ||\r\n                         sa->key->KeyType==AIRPDCAP_KEY_TYPE_WPA_PSK ||\r\n                         sa->key->KeyType==AIRPDCAP_KEY_TYPE_WPA_PMK)) {\r\n                            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsna4WHandshake\", \"Try cached WPA key...\", AIRPDCAP_DEBUG_LEVEL_3);\r\n                            tmp_key=sa->key;\r\n                    } else {\r\n                        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsna4WHandshake\", \"Cached key is of a wrong type, try WPA key...\", AIRPDCAP_DEBUG_LEVEL_3);\r\n                        tmp_key=&ctx->keys[key_index];\r\n                    }\r\n                }\r\n\r\n                /* obviously, try only WPA keys... */\r\n                if (tmp_key->KeyType==AIRPDCAP_KEY_TYPE_WPA_PWD ||\r\n                    tmp_key->KeyType==AIRPDCAP_KEY_TYPE_WPA_PSK ||\r\n                    tmp_key->KeyType==AIRPDCAP_KEY_TYPE_WPA_PMK)\r\n                {\r\n                    if (tmp_key->KeyType == AIRPDCAP_KEY_TYPE_WPA_PWD && tmp_key->UserPwd.SsidLen == 0 && ctx->pkt_ssid_len > 0 && ctx->pkt_ssid_len <= AIRPDCAP_WPA_SSID_MAX_LEN) {\r\n                        /* We have a \"wildcard\" SSID.  Use the one from the packet. */\r\n                        memcpy(&pkt_key, tmp_key, sizeof(pkt_key));\r\n                        memcpy(&pkt_key.UserPwd.Ssid, ctx->pkt_ssid, ctx->pkt_ssid_len);\r\n                         pkt_key.UserPwd.SsidLen = ctx->pkt_ssid_len;\r\n                        AirPDcapRsnaPwd2Psk(pkt_key.UserPwd.Passphrase, pkt_key.UserPwd.Ssid,\r\n                            pkt_key.UserPwd.SsidLen, pkt_key.KeyData.Wpa.Psk);\r\n                        tmp_pkt_key = &pkt_key;\r\n                    } else {\r\n                        tmp_pkt_key = tmp_key;\r\n                    }\r\n\r\n                    /* derive the PTK from the BSSID, STA MAC, PMK, SNonce, ANonce */\r\n                    AirPDcapRsnaPrfX(sa,                            /* authenticator nonce, bssid, station mac */\r\n                                     tmp_pkt_key->KeyData.Wpa.Psk,      /* PSK == PMK */\r\n                                     data+offset+12,                /* supplicant nonce */\r\n                                     512,\r\n                                     sa->wpa.ptk);\r\n\r\n                    /* verify the MIC (compare the MIC in the packet included in this message with a MIC calculated with the PTK) */\r\n                    eapol_len=pntoh16(data+offset-3)+4;\r\n                    memcpy(eapol, &data[offset-5], (eapol_len<AIRPDCAP_EAPOL_MAX_LEN?eapol_len:AIRPDCAP_EAPOL_MAX_LEN));\r\n                    ret_value=AirPDcapRsnaMicCheck(eapol,           /*      eapol frame (header also) */\r\n                                                   eapol_len,       /*      eapol frame length        */\r\n                                                   sa->wpa.ptk,     /*      Key Confirmation Key      */\r\n                                                   AIRPDCAP_EAP_KEY_DESCR_VER(data[offset+1])); /*  EAPOL-Key description version */\r\n\r\n                    /* If the MIC is valid, the Authenticator checks that the RSN information element bit-wise matches       */\r\n                    /* that from the (Re)Association Request message.                                                        */\r\n                    /*              i) TODO If these are not exactly the same, the Authenticator uses MLME-DEAUTHENTICATE.request */\r\n                    /* primitive to terminate the association.                                                               */\r\n                    /*              ii) If they do match bit-wise, the Authenticator constructs Message 3.                   */\r\n                }\r\n\r\n                if (!ret_value &&\r\n                    (tmp_key->KeyType==AIRPDCAP_KEY_TYPE_WPA_PWD ||\r\n                    tmp_key->KeyType==AIRPDCAP_KEY_TYPE_WPA_PSK ||\r\n                    tmp_key->KeyType==AIRPDCAP_KEY_TYPE_WPA_PMK))\r\n                {\r\n                    /* the temporary key is the correct one, cached in the Security Association */\r\n\r\n                    sa->key=tmp_key;\r\n                    break;\r\n                } else {\r\n                    /* the cached key was not valid, try other keys */\r\n\r\n                    if (useCache==TRUE) {\r\n                        useCache=FALSE;\r\n                        key_index--;\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (ret_value) {\r\n                AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsna4WHandshake\", \"handshake step failed\", AIRPDCAP_DEBUG_LEVEL_3);\r\n                return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\r\n            }\r\n\r\n            sa->handshake=2;\r\n            sa->validKey=TRUE; /* we can use the key to decode, even if we have not captured the other eapol packets */\r\n\r\n            return AIRPDCAP_RET_SUCCESS_HANDSHAKE;\r\n        } else {\r\n        /* message 4 */\r\n\r\n            /* TODO \"Note that when the 4-Way Handshake is first used Message 4 is sent in the clear.\" */\r\n\r\n            /* TODO check MIC and Replay Counter                                                                     */\r\n            /* On reception of Message 4, the Authenticator verifies that the Key Replay Counter field value is one  */\r\n            /* that it used on this 4-Way Handshake; if it is not, it silently discards the message.                 */\r\n            /* If the calculated MIC does not match the MIC that the Supplicant included in the EAPOL-Key frame, the */\r\n            /* Authenticator silently discards Message 4.                                                            */\r\n\r\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsna4WHandshake\", \"4-way handshake message 4\", AIRPDCAP_DEBUG_LEVEL_3);\r\n\r\n            sa->handshake=4;\r\n\r\n            return AIRPDCAP_RET_SUCCESS_HANDSHAKE;\r\n        }\r\n    }\r\n\r\n    /* message 3: Authenticator->Supplicant (Sec=1, Mic=1, Ack=1, Inst=0/1, Key=1(pairwise), KeyRSC=???, Nonce=ANonce, MIC=1) */\r\n    if (AIRPDCAP_EAP_ACK(data[offset+1])==1 &&\r\n        AIRPDCAP_EAP_MIC(data[offset])==1)\r\n    {\r\n        const EAPOL_RSN_KEY *pEAPKey;\r\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsna4WHandshake\", \"4-way handshake message 3\", AIRPDCAP_DEBUG_LEVEL_3);\r\n\r\n        /* On reception of Message 3, the Supplicant silently discards the message if the Key Replay Counter field     */\r\n        /* value has already been used or if the ANonce value in Message 3 differs from the ANonce value in Message 1. */\r\n        /* -> not checked, the Authenticator will send another message 3 (hopefully!)                                  */\r\n\r\n        /* TODO check page 88 (RNS) */\r\n\r\n        /* If using WPA2 PSK, message 3 will contain an RSN for the group key (GTK KDE).\r\n           In order to properly support decrypting WPA2-PSK packets, we need to parse this to get the group key. */\r\n        pEAPKey = (const EAPOL_RSN_KEY *)(&(data[offset-1]));\r\n        if (pEAPKey->type == AIRPDCAP_RSN_WPA2_KEY_DESCRIPTOR){\r\n            PAIRPDCAP_SEC_ASSOCIATION broadcast_sa;\r\n            AIRPDCAP_SEC_ASSOCIATION_ID id;\r\n\r\n            /* Get broadcacst SA for the current BSSID */\r\n            memcpy(id.sta, broadcast_mac, AIRPDCAP_MAC_LEN);\r\n            memcpy(id.bssid, sa->saId.bssid, AIRPDCAP_MAC_LEN);\r\n            broadcast_sa = AirPDcapGetSaPtr(ctx, &id);\r\n\r\n            if (broadcast_sa == NULL){\r\n                return AIRPDCAP_RET_REQ_DATA;\r\n            }\r\n            return (AirPDcapDecryptWPABroadcastKey(pEAPKey, sa->wpa.ptk+16, broadcast_sa, tot_len-offset+1));\r\n        }\r\n    }\r\n\r\n    return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\r\n}", ".irPDcapDecryptWPABroadcastKey": "static INT\r\nAirPDcapDecryptWPABroadcastKey(const EAPOL_RSN_KEY *pEAPKey, guint8 *decryption_key, PAIRPDCAP_SEC_ASSOCIATION sa, guint eapol_len)\r\n{\r\n    guint8 key_version;\r\n    const guint8 *key_data;\r\n    guint8  *szEncryptedKey;\r\n    guint16 key_bytes_len = 0; /* Length of the total key data field */\r\n    guint16 key_len;           /* Actual group key length */\r\n    static AIRPDCAP_KEY_ITEM dummy_key; /* needed in case AirPDcapRsnaMng() wants the key structure */\r\n    AIRPDCAP_SEC_ASSOCIATION *tmp_sa;\r\n\r\n    /* We skip verifying the MIC of the key. If we were implementing a WPA supplicant we'd want to verify, but for a sniffer it's not needed. */\r\n\r\n    /* Preparation for decrypting the group key -  determine group key data length */\r\n    /* depending on whether the pairwise key is TKIP or AES encryption key */\r\n    key_version = AIRPDCAP_EAP_KEY_DESCR_VER(pEAPKey->key_information[1]);\r\n    if (key_version == AIRPDCAP_WPA_KEY_VER_NOT_CCMP){\r\n        /* TKIP */\r\n        key_bytes_len = pntoh16(pEAPKey->key_length);\r\n    }else if (key_version == AIRPDCAP_WPA_KEY_VER_AES_CCMP){\r\n        /* AES */\r\n        key_bytes_len = pntoh16(pEAPKey->key_data_len);\r\n\r\n        /* AES keys must be at least 128 bits = 16 bytes. */\r\n        if (key_bytes_len < 16) {\r\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\r\n        }\r\n    }\r\n\r\n    if ((key_bytes_len < GROUP_KEY_MIN_LEN) ||\r\n        (eapol_len < sizeof(EAPOL_RSN_KEY)) ||\r\n        (key_bytes_len > eapol_len - sizeof(EAPOL_RSN_KEY))) {\r\n        return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\r\n    }\r\n\r\n    /* Encrypted key is in the information element field of the EAPOL key packet */\r\n    key_data = (const guint8 *)pEAPKey + sizeof(EAPOL_RSN_KEY);\r\n    szEncryptedKey = (guint8 *)g_memdup(key_data, key_bytes_len);\r\n\r\n    DEBUG_DUMP(\"Encrypted Broadcast key:\", szEncryptedKey, key_bytes_len);\r\n    DEBUG_DUMP(\"KeyIV:\", pEAPKey->key_iv, 16);\r\n    DEBUG_DUMP(\"decryption_key:\", decryption_key, 16);\r\n\r\n    /* We are rekeying, save old sa */\r\n    tmp_sa=(AIRPDCAP_SEC_ASSOCIATION *)g_malloc(sizeof(AIRPDCAP_SEC_ASSOCIATION));\r\n    memcpy(tmp_sa, sa, sizeof(AIRPDCAP_SEC_ASSOCIATION));\r\n    sa->next=tmp_sa;\r\n\r\n    /* As we have no concept of the prior association request at this point, we need to deduce the     */\r\n    /* group key cipher from the length of the key bytes. In WPA this is straightforward as the        */\r\n    /* keybytes just contain the GTK, and the GTK is only in the group handshake, NOT the M3.          */\r\n    /* In WPA2 its a little more tricky as the M3 keybytes contain an RSN_IE, but the group handshake  */\r\n    /* does not. Also there are other (variable length) items in the keybytes which we need to account */\r\n    /* for to determine the true key length, and thus the group cipher.                                */\r\n\r\n    if (key_version == AIRPDCAP_WPA_KEY_VER_NOT_CCMP){\r\n        guint8 new_key[32];\r\n        guint8 dummy[256] = { 0 };\r\n        /* TKIP key */\r\n        /* Per 802.11i, Draft 3.0 spec, section 8.5.2, p. 97, line 4-8, */\r\n        /* group key is decrypted using RC4.  Concatenate the IV with the 16 byte EK (PTK+16) to get the decryption key */\r\n\r\n        gcry_cipher_hd_t  rc4_handle;\r\n\r\n        /* The WPA group key just contains the GTK bytes so deducing the type is straightforward   */\r\n        /* Note - WPA M3 doesn't contain a group key so we'll only be here for the group handshake */\r\n        sa->wpa.key_ver = (key_bytes_len >=TKIP_GROUP_KEY_LEN)?AIRPDCAP_WPA_KEY_VER_NOT_CCMP:AIRPDCAP_WPA_KEY_VER_AES_CCMP;\r\n\r\n        /* Build the full decryption key based on the IV and part of the pairwise key */\r\n        memcpy(new_key, pEAPKey->key_iv, 16);\r\n        memcpy(new_key+16, decryption_key, 16);\r\n        DEBUG_DUMP(\"FullDecrKey:\", new_key, 32);\r\n\r\n        if (gcry_cipher_open (&rc4_handle, GCRY_CIPHER_ARCFOUR, GCRY_CIPHER_MODE_STREAM, 0)) {\r\n          return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\r\n        }\r\n        if (gcry_cipher_setkey(rc4_handle, new_key, sizeof(new_key))) {\r\n          gcry_cipher_close(rc4_handle);\r\n          return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\r\n        }\r\n\r\n        /* Do dummy 256 iterations of the RC4 algorithm (per 802.11i, Draft 3.0, p. 97 line 6) */\r\n        gcry_cipher_decrypt(rc4_handle, dummy, 256, NULL, 0);\r\n        gcry_cipher_decrypt(rc4_handle, szEncryptedKey, key_bytes_len, NULL, 0);\r\n        gcry_cipher_close(rc4_handle);\r\n\r\n    } else if (key_version == AIRPDCAP_WPA_KEY_VER_AES_CCMP){\r\n        /* AES CCMP key */\r\n\r\n        guint8 key_found;\r\n        guint8 key_length;\r\n        guint16 key_index;\r\n        guint8 *decrypted_data;\r\n\r\n        /* Unwrap the key; the result is key_bytes_len in length */\r\n        decrypted_data = AES_unwrap(decryption_key, 16, szEncryptedKey,  key_bytes_len);\r\n\r\n        /* With WPA2 what we get after Broadcast Key decryption is an actual RSN structure.\r\n           The key itself is stored as a GTK KDE\r\n           WPA2 IE (1 byte) id = 0xdd, length (1 byte), GTK OUI (4 bytes), key index (1 byte) and 1 reserved byte. Thus we have to\r\n           pass pointer to the actual key with 8 bytes offset */\r\n\r\n        key_found = FALSE;\r\n        key_index = 0;\r\n\r\n        /* Parse Key data until we found GTK KDE */\r\n        /* GTK KDE = 00-0F-AC 01 */\r\n        while(key_index < (key_bytes_len - 6) && !key_found){\r\n            guint8 rsn_id;\r\n            guint32 type;\r\n\r\n            /* Get RSN ID */\r\n            rsn_id = decrypted_data[key_index];\r\n            type = ((decrypted_data[key_index + 2] << 24) +\r\n                    (decrypted_data[key_index + 3] << 16) +\r\n                    (decrypted_data[key_index + 4] << 8) +\r\n                     (decrypted_data[key_index + 5]));\r\n\r\n            if (rsn_id == 0xdd && type == 0x000fac01) {\r\n                key_found = TRUE;\r\n            } else {\r\n                key_index += decrypted_data[key_index+1]+2;\r\n            }\r\n        }\r\n\r\n        if (key_found){\r\n            if (decrypted_data[key_index+1] <= 6) {\r\n                g_free(decrypted_data);\r\n                g_free(szEncryptedKey);\r\n                return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\r\n            }\r\n            key_length = decrypted_data[key_index+1] - 6;\r\n\r\n            if (key_index+8 >= key_bytes_len ||\r\n                key_length > key_bytes_len - key_index - 8) {\r\n                g_free(decrypted_data);\r\n                g_free(szEncryptedKey);\r\n                return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\r\n            }\r\n\r\n            /* Skip over the GTK header info, and don't copy past the end of the encrypted data */\r\n            memcpy(szEncryptedKey, decrypted_data+key_index+8, key_length);\r\n        } else {\r\n            g_free(decrypted_data);\r\n            g_free(szEncryptedKey);\r\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\r\n        }\r\n\r\n        if (key_length == TKIP_GROUP_KEY_LEN)\r\n            sa->wpa.key_ver = AIRPDCAP_WPA_KEY_VER_NOT_CCMP;\r\n        else\r\n            sa->wpa.key_ver = AIRPDCAP_WPA_KEY_VER_AES_CCMP;\r\n\r\n        g_free(decrypted_data);\r\n    }\r\n\r\n    key_len = (sa->wpa.key_ver==AIRPDCAP_WPA_KEY_VER_NOT_CCMP)?TKIP_GROUP_KEY_LEN:CCMP_GROUP_KEY_LEN;\r\n    if (key_len > key_bytes_len) {\r\n        /* the key required for this protocol is longer than the key that we just calculated */\r\n        g_free(szEncryptedKey);\r\n        return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\r\n    }\r\n\r\n    /* Decrypted key is now in szEncryptedKey with len of key_len */\r\n    DEBUG_DUMP(\"Broadcast key:\", szEncryptedKey, key_len);\r\n\r\n    /* Load the proper key material info into the SA */\r\n    sa->key = &dummy_key;  /* we just need key to be not null because it is checked in AirPDcapRsnaMng().  The WPA key materials are actually in the .wpa structure */\r\n    sa->validKey = TRUE;\r\n\r\n    /* Since this is a GTK and its size is only 32 bytes (vs. the 64 byte size of a PTK), we fake it and put it in at a 32-byte offset so the  */\r\n    /* AirPDcapRsnaMng() function will extract the right piece of the GTK for decryption. (The first 16 bytes of the GTK are used for decryption.) */\r\n    memset(sa->wpa.ptk, 0, sizeof(sa->wpa.ptk));\r\n    memcpy(sa->wpa.ptk+32, szEncryptedKey, key_len);\r\n    g_free(szEncryptedKey);\r\n    return AIRPDCAP_RET_SUCCESS_HANDSHAKE;\r\n}", ".irPDcapTDLSDeriveKey": "static INT\r\nAirPDcapTDLSDeriveKey(\r\n    PAIRPDCAP_SEC_ASSOCIATION sa,\r\n    const guint8 *data,\r\n#if GCRYPT_VERSION_NUMBER >= 0x010600\r\n    guint offset_rsne,\r\n#else\r\n    guint offset_rsne _U_,\r\n#endif\r\n    guint offset_fte,\r\n#if GCRYPT_VERSION_NUMBER >= 0x010600\r\n    guint offset_timeout,\r\n#else\r\n    guint offset_timeout _U_,\r\n#endif\r\n    guint offset_link,\r\n#if GCRYPT_VERSION_NUMBER >= 0x010600\r\n    guint8 action)\r\n#else\r\n    guint8 action _U_)\r\n#endif\r\n{\r\n\r\n    gcry_md_hd_t sha256_handle;\r\n    gcry_md_hd_t hmac_handle;\r\n    const guint8 *snonce, *anonce, *initiator, *responder, *bssid;\r\n    guint8 key_input[32];\r\n#if GCRYPT_VERSION_NUMBER >= 0x010600\r\n    guint8 mic[16], seq_num = action + 1;\r\n    guint8 zeros[16] = { 0 };\r\n    gcry_mac_hd_t cmac_handle;\r\n    size_t cmac_len = 16;\r\n    size_t cmac_write_len;\r\n#endif\r\n\r\n    /* Get key input */\r\n    anonce = &data[offset_fte + 20];\r\n    snonce = &data[offset_fte + 52];\r\n\r\n    gcry_md_open (&sha256_handle, GCRY_MD_SHA256, 0);\r\n    if (memcmp(anonce, snonce, AIRPDCAP_WPA_NONCE_LEN) < 0) {\r\n        gcry_md_write(sha256_handle, anonce, AIRPDCAP_WPA_NONCE_LEN);\r\n        gcry_md_write(sha256_handle, snonce, AIRPDCAP_WPA_NONCE_LEN);\r\n    } else {\r\n        gcry_md_write(sha256_handle, snonce, AIRPDCAP_WPA_NONCE_LEN);\r\n        gcry_md_write(sha256_handle, anonce, AIRPDCAP_WPA_NONCE_LEN);\r\n    }\r\n    memcpy(key_input, gcry_md_read(sha256_handle, 0), 32);\r\n    gcry_md_close(sha256_handle);\r\n\r\n    /* Derive key */\r\n    bssid = &data[offset_link + 2];\r\n    initiator = &data[offset_link + 8];\r\n    responder = &data[offset_link + 14];\r\n    if (gcry_md_open(&hmac_handle, GCRY_MD_SHA256, GCRY_MD_FLAG_HMAC)) {\r\n        return AIRPDCAP_RET_UNSUCCESS;\r\n    }\r\n    if (gcry_md_setkey(hmac_handle, key_input, 32)) {\r\n        gcry_md_close(hmac_handle);\r\n        return AIRPDCAP_RET_UNSUCCESS;\r\n    }\r\n    gcry_md_putc(hmac_handle, 1);\r\n    gcry_md_putc(hmac_handle, 0);\r\n    gcry_md_write(hmac_handle, \"TDLS PMK\", 8);\r\n    if (memcmp(initiator, responder, AIRPDCAP_MAC_LEN) < 0) {\r\n          gcry_md_write(hmac_handle, initiator, AIRPDCAP_MAC_LEN);\r\n          gcry_md_write(hmac_handle, responder, AIRPDCAP_MAC_LEN);\r\n    } else {\r\n          gcry_md_write(hmac_handle, responder, AIRPDCAP_MAC_LEN);\r\n          gcry_md_write(hmac_handle, initiator, AIRPDCAP_MAC_LEN);\r\n    }\r\n    gcry_md_write(hmac_handle, bssid, AIRPDCAP_MAC_LEN);\r\n    gcry_md_putc(hmac_handle, 0);\r\n    gcry_md_putc(hmac_handle, 1);\r\n    memcpy(key_input, gcry_md_read(hmac_handle, 0), 32);\r\n    gcry_md_close(hmac_handle);\r\n\r\n    /* Check MIC */\r\n#if GCRYPT_VERSION_NUMBER >= 0x010600\r\n    if (gcry_mac_open(&cmac_handle, GCRY_MAC_CMAC_AES, 0, NULL)) {\r\n        return AIRPDCAP_RET_UNSUCCESS;\r\n    }\r\n    if (gcry_mac_setkey(cmac_handle, key_input, 16)) {\r\n        gcry_mac_close(cmac_handle);\r\n        return AIRPDCAP_RET_UNSUCCESS;\r\n    }\r\n    gcry_mac_write(cmac_handle, initiator, AIRPDCAP_MAC_LEN);\r\n    gcry_mac_write(cmac_handle, responder, AIRPDCAP_MAC_LEN);\r\n    gcry_mac_write(cmac_handle, &seq_num, 1);\r\n    gcry_mac_write(cmac_handle, &data[offset_link], data[offset_link + 1] + 2);\r\n    gcry_mac_write(cmac_handle, &data[offset_rsne], data[offset_rsne + 1] + 2);\r\n    gcry_mac_write(cmac_handle, &data[offset_timeout], data[offset_timeout + 1] + 2);\r\n    gcry_mac_write(cmac_handle, &data[offset_fte], 4);\r\n    gcry_mac_write(cmac_handle, zeros, 16);\r\n    cmac_write_len = data[offset_fte + 1] + 2;\r\n    if (cmac_write_len < 20) {\r\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapTDLSDeriveKey\", \"Bad MAC len\", AIRPDCAP_DEBUG_LEVEL_3);\r\n        gcry_mac_close(cmac_handle);\r\n        return AIRPDCAP_RET_UNSUCCESS;\r\n    }\r\n    gcry_mac_write(cmac_handle, &data[offset_fte + 20], cmac_write_len - 20);\r\n    if (gcry_mac_read(cmac_handle, mic, &cmac_len) != GPG_ERR_NO_ERROR) {\r\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapTDLSDeriveKey\", \"MAC read error\", AIRPDCAP_DEBUG_LEVEL_3);\r\n        gcry_mac_close(cmac_handle);\r\n        return AIRPDCAP_RET_UNSUCCESS;\r\n    }\r\n    if (memcmp(mic, &data[offset_fte + 4], 16)) {\r\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapTDLSDeriveKey\", \"MIC verification failed\", AIRPDCAP_DEBUG_LEVEL_3);\r\n        gcry_mac_close(cmac_handle);\r\n        return AIRPDCAP_RET_UNSUCCESS;\r\n    }\r\n    gcry_mac_close(cmac_handle);\r\n#else\r\n    AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapTDLSDeriveKey\", \"MIC verification failed, need libgcrypt >= 1.6\", AIRPDCAP_DEBUG_LEVEL_3);\r\n    return AIRPDCAP_RET_UNSUCCESS;\r\n#endif\r\n    memcpy(AIRPDCAP_GET_TK(sa->wpa.ptk), &key_input[16], 16);\r\n    memcpy(sa->wpa.nonce, snonce, AIRPDCAP_WPA_NONCE_LEN);\r\n    sa->validKey = TRUE;\r\n    sa->wpa.key_ver = AIRPDCAP_WPA_KEY_VER_AES_CCMP;\r\n    AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapTDLSDeriveKey\", \"MIC verified\", AIRPDCAP_DEBUG_LEVEL_3);\r\n    return  AIRPDCAP_RET_SUCCESS;\r\n}", ".irPDcapGetSaAddress": "static INT\r\nAirPDcapGetSaAddress(\r\n    const AIRPDCAP_MAC_FRAME_ADDR4 *frame,\r\n    AIRPDCAP_SEC_ASSOCIATION_ID *id)\r\n{\r\n#ifdef AIRPDCAP_DEBUG\r\n#define MSGBUF_LEN 255\r\n    CHAR msgbuf[MSGBUF_LEN];\r\n#endif\r\n\r\n    if ((AIRPDCAP_TYPE(frame->fc[0])==AIRPDCAP_TYPE_DATA) &&\r\n        (AIRPDCAP_DS_BITS(frame->fc[1]) == 0) &&\r\n        (memcmp(frame->addr2, frame->addr3, AIRPDCAP_MAC_LEN) != 0) &&\r\n        (memcmp(frame->addr1, frame->addr3, AIRPDCAP_MAC_LEN) != 0)) {\r\n        /* DATA frame with fromDS=0 ToDS=0 and neither RA or SA is BSSID\r\n           => TDLS traffic. Use highest MAC address for bssid */\r\n        if (memcmp(frame->addr1, frame->addr2, AIRPDCAP_MAC_LEN) < 0) {\r\n            memcpy(id->sta, frame->addr1, AIRPDCAP_MAC_LEN);\r\n            memcpy(id->bssid, frame->addr2, AIRPDCAP_MAC_LEN);\r\n        } else {\r\n            memcpy(id->sta, frame->addr2, AIRPDCAP_MAC_LEN);\r\n            memcpy(id->bssid, frame->addr1, AIRPDCAP_MAC_LEN);\r\n        }\r\n    } else {\r\n        const UCHAR *addr;\r\n\r\n        /* Normal Case: SA between STA and AP */\r\n        if ((addr = AirPDcapGetBssidAddress(frame)) != NULL) {\r\n            memcpy(id->bssid, addr, AIRPDCAP_MAC_LEN);\r\n        } else {\r\n            return AIRPDCAP_RET_UNSUCCESS;\r\n        }\r\n\r\n        if ((addr = AirPDcapGetStaAddress(frame)) != NULL) {\r\n            memcpy(id->sta, addr, AIRPDCAP_MAC_LEN);\r\n        } else {\r\n            return AIRPDCAP_RET_UNSUCCESS;\r\n        }\r\n    }\r\n\r\n#ifdef AIRPDCAP_DEBUG\r\n    g_snprintf(msgbuf, MSGBUF_LEN, \"BSSID_MAC: %02X.%02X.%02X.%02X.%02X.%02X\\t\",\r\n               id->bssid[0],id->bssid[1],id->bssid[2],id->bssid[3],id->bssid[4],id->bssid[5]);\r\n    AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapGetSaAddress\", msgbuf, AIRPDCAP_DEBUG_LEVEL_3);\r\n    g_snprintf(msgbuf, MSGBUF_LEN, \"STA_MAC: %02X.%02X.%02X.%02X.%02X.%02X\\t\",\r\n               id->sta[0],id->sta[1],id->sta[2],id->sta[3],id->sta[4],id->sta[5]);\r\n    AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapGetSaAddress\", msgbuf, AIRPDCAP_DEBUG_LEVEL_3);\r\n#endif\r\n\r\n    return AIRPDCAP_RET_SUCCESS;\r\n}", ".irPDcapScanForKeys": "static INT AirPDcapScanForKeys(\r\n    PAIRPDCAP_CONTEXT ctx,\r\n    const guint8 *data,\r\n    const guint mac_header_len,\r\n    const guint tot_len,\r\n    AIRPDCAP_SEC_ASSOCIATION_ID id\r\n)\r\n{\r\n    const UCHAR *addr;\r\n    guint bodyLength;\r\n    PAIRPDCAP_SEC_ASSOCIATION sta_sa;\r\n    PAIRPDCAP_SEC_ASSOCIATION sa;\r\n    guint offset = 0;\r\n    const guint8 dot1x_header[] = {\r\n        0xAA,             /* DSAP=SNAP */\r\n        0xAA,             /* SSAP=SNAP */\r\n        0x03,             /* Control field=Unnumbered frame */\r\n        0x00, 0x00, 0x00, /* Org. code=encaps. Ethernet */\r\n        0x88, 0x8E        /* Type: 802.1X authentication */\r\n    };\r\n    const guint8 bt_dot1x_header[] = {\r\n        0xAA,             /* DSAP=SNAP */\r\n        0xAA,             /* SSAP=SNAP */\r\n        0x03,             /* Control field=Unnumbered frame */\r\n        0x00, 0x19, 0x58, /* Org. code=Bluetooth SIG */\r\n        0x00, 0x03        /* Type: Bluetooth Security */\r\n    };\r\n    const guint8 tdls_header[] = {\r\n        0xAA,             /* DSAP=SNAP */\r\n        0xAA,             /* SSAP=SNAP */\r\n        0x03,             /* Control field=Unnumbered frame */\r\n        0x00, 0x00, 0x00, /* Org. code=encaps. Ethernet */\r\n        0x89, 0x0D,       /* Type: 802.11 - Fast Roaming Remote Request */\r\n        0x02,             /* Payload Type: TDLS */\r\n        0X0C              /* Action Category: TDLS */\r\n    };\r\n\r\n    const EAPOL_RSN_KEY *pEAPKey;\r\n#ifdef AIRPDCAP_DEBUG\r\n#define MSGBUF_LEN 255\r\n    CHAR msgbuf[MSGBUF_LEN];\r\n#endif\r\n    AIRPDCAP_DEBUG_TRACE_START(\"AirPDcapScanForKeys\");\r\n\r\n    /* cache offset in the packet data */\r\n    offset = mac_header_len;\r\n\r\n    /* check if the packet has an LLC header and the packet is 802.1X authentication (IEEE 802.1X-2004, pg. 24) */\r\n    if (memcmp(data+offset, dot1x_header, 8) == 0 || memcmp(data+offset, bt_dot1x_header, 8) == 0) {\r\n\r\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Authentication: EAPOL packet\", AIRPDCAP_DEBUG_LEVEL_3);\r\n\r\n        /* skip LLC header */\r\n        offset+=8;\r\n\r\n        /* check if the packet is a EAPOL-Key (0x03) (IEEE 802.1X-2004, pg. 25) */\r\n        if (data[offset+1]!=3) {\r\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Not EAPOL-Key\", AIRPDCAP_DEBUG_LEVEL_3);\r\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\r\n        }\r\n\r\n        /* get and check the body length (IEEE 802.1X-2004, pg. 25) */\r\n        bodyLength=pntoh16(data+offset+2);\r\n        if (((tot_len-offset-4) < bodyLength) || (bodyLength < sizeof(EAPOL_RSN_KEY))) { /* Only check if frame is long enough for eapol header, ignore tailing garbage, see bug 9065 */\r\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"EAPOL body too short\", AIRPDCAP_DEBUG_LEVEL_3);\r\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\r\n        }\r\n\r\n        /* skip EAPOL MPDU and go to the first byte of the body */\r\n        offset+=4;\r\n\r\n        pEAPKey = (const EAPOL_RSN_KEY *) (data+offset);\r\n\r\n        /* check if the key descriptor type is valid (IEEE 802.1X-2004, pg. 27) */\r\n        if (/*pEAPKey->type!=0x1 &&*/ /* RC4 Key Descriptor Type (deprecated) */\r\n            pEAPKey->type != AIRPDCAP_RSN_WPA2_KEY_DESCRIPTOR &&             /* IEEE 802.11 Key Descriptor Type  (WPA2) */\r\n            pEAPKey->type != AIRPDCAP_RSN_WPA_KEY_DESCRIPTOR)           /* 254 = RSN_KEY_DESCRIPTOR - WPA,              */\r\n        {\r\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Not valid key descriptor type\", AIRPDCAP_DEBUG_LEVEL_3);\r\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\r\n        }\r\n\r\n        /* start with descriptor body */\r\n        offset+=1;\r\n\r\n        /* search for a cached Security Association for current BSSID and AP */\r\n        sa = AirPDcapGetSaPtr(ctx, &id);\r\n        if (sa == NULL){\r\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"No SA for BSSID found\", AIRPDCAP_DEBUG_LEVEL_3);\r\n            return AIRPDCAP_RET_REQ_DATA;\r\n        }\r\n\r\n        /* It could be a Pairwise Key exchange, check */\r\n        if (AirPDcapRsna4WHandshake(ctx, data, sa, offset, tot_len) == AIRPDCAP_RET_SUCCESS_HANDSHAKE)\r\n            return AIRPDCAP_RET_SUCCESS_HANDSHAKE;\r\n\r\n        if (mac_header_len + GROUP_KEY_PAYLOAD_LEN_MIN > tot_len) {\r\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Message too short for Group Key\", AIRPDCAP_DEBUG_LEVEL_3);\r\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\r\n        }\r\n\r\n        /* Verify the bitfields: Key = 0(groupwise) Mic = 1 Ack = 1 Secure = 1 */\r\n        if (AIRPDCAP_EAP_KEY(data[offset+1])!=0 ||\r\n            AIRPDCAP_EAP_ACK(data[offset+1])!=1 ||\r\n            AIRPDCAP_EAP_MIC(data[offset]) != 1 ||\r\n            AIRPDCAP_EAP_SEC(data[offset]) != 1){\r\n\r\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Key bitfields not correct for Group Key\", AIRPDCAP_DEBUG_LEVEL_3);\r\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\r\n        }\r\n\r\n        /* force STA address to be the broadcast MAC so we create an SA for the groupkey */\r\n        memcpy(id.sta, broadcast_mac, AIRPDCAP_MAC_LEN);\r\n\r\n        /* get the Security Association structure for the broadcast MAC and AP */\r\n        sa = AirPDcapGetSaPtr(ctx, &id);\r\n        if (sa == NULL){\r\n            return AIRPDCAP_RET_REQ_DATA;\r\n        }\r\n\r\n        /* Get the SA for the STA, since we need its pairwise key to decrpyt the group key */\r\n\r\n        /* get STA address */\r\n        if ( (addr=AirPDcapGetStaAddress((const AIRPDCAP_MAC_FRAME_ADDR4 *)(data))) != NULL) {\r\n            memcpy(id.sta, addr, AIRPDCAP_MAC_LEN);\r\n#ifdef AIRPDCAP_DEBUG\r\n            g_snprintf(msgbuf, MSGBUF_LEN, \"ST_MAC: %2X.%2X.%2X.%2X.%2X.%2X\\t\", id.sta[0],id.sta[1],id.sta[2],id.sta[3],id.sta[4],id.sta[5]);\r\n#endif\r\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", msgbuf, AIRPDCAP_DEBUG_LEVEL_3);\r\n        } else {\r\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"SA not found\", AIRPDCAP_DEBUG_LEVEL_5);\r\n            return AIRPDCAP_RET_REQ_DATA;\r\n        }\r\n\r\n        sta_sa = AirPDcapGetSaPtr(ctx, &id);\r\n        if (sta_sa == NULL){\r\n            return AIRPDCAP_RET_REQ_DATA;\r\n        }\r\n\r\n        /* Try to extract the group key and install it in the SA */\r\n        return (AirPDcapDecryptWPABroadcastKey(pEAPKey, sta_sa->wpa.ptk+16, sa, tot_len-offset+1));\r\n\r\n    } else if (memcmp(data+offset, tdls_header, 10) == 0) {\r\n        const guint8 *initiator, *responder;\r\n        guint8 action;\r\n        guint status, offset_rsne = 0, offset_fte = 0, offset_link = 0, offset_timeout = 0;\r\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Authentication: TDLS Action Frame\", AIRPDCAP_DEBUG_LEVEL_3);\r\n\r\n        /* skip LLC header */\r\n        offset+=10;\r\n\r\n        /* check if the packet is a TDLS response or confirm */\r\n        action = data[offset];\r\n        if (action!=1 && action!=2) {\r\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Not Response nor confirm\", AIRPDCAP_DEBUG_LEVEL_3);\r\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\r\n        }\r\n\r\n        /* check status */\r\n        offset++;\r\n        status=pntoh16(data+offset);\r\n        if (status!=0) {\r\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"TDLS setup not successfull\", AIRPDCAP_DEBUG_LEVEL_3);\r\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\r\n        }\r\n\r\n        /* skip Token + capabilities */\r\n        offset+=5;\r\n\r\n        /* search for RSN, Fast BSS Transition, Link Identifier and Timeout Interval IEs */\r\n\r\n        while(offset < (tot_len - 2)) {\r\n            if (data[offset] == 48) {\r\n                offset_rsne = offset;\r\n            } else if (data[offset] == 55) {\r\n                offset_fte = offset;\r\n            } else if (data[offset] == 56) {\r\n                offset_timeout = offset;\r\n            } else if (data[offset] == 101) {\r\n                offset_link = offset;\r\n            }\r\n\r\n            if (tot_len < offset + data[offset + 1] + 2) {\r\n                return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\r\n            }\r\n            offset += data[offset + 1] + 2;\r\n        }\r\n\r\n        if (offset_rsne == 0 || offset_fte == 0 ||\r\n            offset_timeout == 0 || offset_link == 0)\r\n        {\r\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Cannot Find all necessary IEs\", AIRPDCAP_DEBUG_LEVEL_3);\r\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\r\n        }\r\n\r\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Found RSNE/Fast BSS/Timeout Interval/Link IEs\", AIRPDCAP_DEBUG_LEVEL_3);\r\n\r\n        /* Will create a Security Association between 2 STA. Need to get both MAC address */\r\n        initiator = &data[offset_link + 8];\r\n        responder = &data[offset_link + 14];\r\n\r\n        if (memcmp(initiator, responder, AIRPDCAP_MAC_LEN) < 0) {\r\n            memcpy(id.sta, initiator, AIRPDCAP_MAC_LEN);\r\n            memcpy(id.bssid, responder, AIRPDCAP_MAC_LEN);\r\n        } else {\r\n            memcpy(id.sta, responder, AIRPDCAP_MAC_LEN);\r\n            memcpy(id.bssid, initiator, AIRPDCAP_MAC_LEN);\r\n        }\r\n\r\n        sa = AirPDcapGetSaPtr(ctx, &id);\r\n        if (sa == NULL){\r\n            return AIRPDCAP_RET_REQ_DATA;\r\n        }\r\n\r\n        if (sa->validKey) {\r\n            if (memcmp(sa->wpa.nonce, data + offset_fte + 52, AIRPDCAP_WPA_NONCE_LEN) == 0) {\r\n                /* Already have valid key for this SA, no need to redo key derivation */\r\n                return AIRPDCAP_RET_SUCCESS_HANDSHAKE;\r\n            } else {\r\n                /* We are opening a new session with the same two STA, save previous sa  */\r\n                AIRPDCAP_SEC_ASSOCIATION *tmp_sa = g_new(AIRPDCAP_SEC_ASSOCIATION, 1);\r\n                memcpy(tmp_sa, sa, sizeof(AIRPDCAP_SEC_ASSOCIATION));\r\n                sa->next=tmp_sa;\r\n                sa->validKey = FALSE;\r\n            }\r\n        }\r\n\r\n        if (AirPDcapTDLSDeriveKey(sa, data, offset_rsne, offset_fte, offset_timeout, offset_link, action)\r\n            == AIRPDCAP_RET_SUCCESS) {\r\n            AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapScanForKeys\");\r\n            return AIRPDCAP_RET_SUCCESS_HANDSHAKE;\r\n        }\r\n    } else {\r\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Skipping: not an EAPOL packet\", AIRPDCAP_DEBUG_LEVEL_3);\r\n    }\r\n\r\n    AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapScanForKeys\");\r\n    return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\r\n}", ".irPDcapWepMng": "static INT\r\nAirPDcapWepMng(\r\n    PAIRPDCAP_CONTEXT ctx,\r\n    UCHAR *decrypt_data,\r\n    guint mac_header_len,\r\n    guint *decrypt_len,\r\n    PAIRPDCAP_KEY_ITEM key,\r\n    AIRPDCAP_SEC_ASSOCIATION *sa,\r\n    INT offset)\r\n{\r\n    UCHAR wep_key[AIRPDCAP_WEP_KEY_MAXLEN+AIRPDCAP_WEP_IVLEN];\r\n    size_t keylen;\r\n    INT ret_value=1;\r\n    INT key_index;\r\n    AIRPDCAP_KEY_ITEM *tmp_key;\r\n    UINT8 useCache=FALSE;\r\n    UCHAR *try_data;\r\n    guint try_data_len = *decrypt_len;\r\n\r\n    try_data = (UCHAR *)g_malloc(try_data_len);\r\n\r\n    if (sa->key!=NULL)\r\n        useCache=TRUE;\r\n\r\n    for (key_index=0; key_index<(INT)ctx->keys_nr; key_index++) {\r\n        /* use the cached one, or try all keys */\r\n        if (!useCache) {\r\n            tmp_key=&ctx->keys[key_index];\r\n        } else {\r\n            if (sa->key!=NULL && sa->key->KeyType==AIRPDCAP_KEY_TYPE_WEP) {\r\n                AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapWepMng\", \"Try cached WEP key...\", AIRPDCAP_DEBUG_LEVEL_3);\r\n                tmp_key=sa->key;\r\n            } else {\r\n                AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapWepMng\", \"Cached key is not valid, try another WEP key...\", AIRPDCAP_DEBUG_LEVEL_3);\r\n                tmp_key=&ctx->keys[key_index];\r\n            }\r\n        }\r\n\r\n        /* obviously, try only WEP keys... */\r\n        if (tmp_key->KeyType==AIRPDCAP_KEY_TYPE_WEP) {\r\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapWepMng\", \"Try WEP key...\", AIRPDCAP_DEBUG_LEVEL_3);\r\n\r\n            memset(wep_key, 0, sizeof(wep_key));\r\n            memcpy(try_data, decrypt_data, *decrypt_len);\r\n\r\n            /* Costruct the WEP seed: copy the IV in first 3 bytes and then the WEP key (refer to 802-11i-2004, 8.2.1.4.3, pag. 36) */\r\n            memcpy(wep_key, try_data+mac_header_len, AIRPDCAP_WEP_IVLEN);\r\n            keylen=tmp_key->KeyData.Wep.WepKeyLen;\r\n            memcpy(wep_key+AIRPDCAP_WEP_IVLEN, tmp_key->KeyData.Wep.WepKey, keylen);\r\n\r\n            ret_value=AirPDcapWepDecrypt(wep_key,\r\n                keylen+AIRPDCAP_WEP_IVLEN,\r\n                try_data + (mac_header_len+AIRPDCAP_WEP_IVLEN+AIRPDCAP_WEP_KIDLEN),\r\n                *decrypt_len-(mac_header_len+AIRPDCAP_WEP_IVLEN+AIRPDCAP_WEP_KIDLEN+AIRPDCAP_CRC_LEN));\r\n\r\n            if (ret_value == AIRPDCAP_RET_SUCCESS)\r\n                memcpy(decrypt_data, try_data, *decrypt_len);\r\n        }\r\n\r\n        if (!ret_value && tmp_key->KeyType==AIRPDCAP_KEY_TYPE_WEP) {\r\n            /* the tried key is the correct one, cached in the Security Association */\r\n\r\n            sa->key=tmp_key;\r\n\r\n            if (key!=NULL) {\r\n                memcpy(key, sa->key, sizeof(AIRPDCAP_KEY_ITEM));\r\n                key->KeyType=AIRPDCAP_KEY_TYPE_WEP;\r\n            }\r\n\r\n            break;\r\n        } else {\r\n            /* the cached key was not valid, try other keys */\r\n\r\n            if (useCache==TRUE) {\r\n                useCache=FALSE;\r\n                key_index--;\r\n            }\r\n        }\r\n    }\r\n\r\n    g_free(try_data);\r\n    if (ret_value)\r\n        return AIRPDCAP_RET_UNSUCCESS;\r\n\r\n    AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapWepMng\", \"WEP DECRYPTED!!!\", AIRPDCAP_DEBUG_LEVEL_3);\r\n\r\n    /* remove ICV (4bytes) from the end of packet */\r\n    *decrypt_len-=4;\r\n\r\n    if (*decrypt_len < 4) {\r\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapWepMng\", \"Decryption length too short\", AIRPDCAP_DEBUG_LEVEL_3);\r\n        return AIRPDCAP_RET_UNSUCCESS;\r\n    }\r\n\r\n    /* remove protection bit */\r\n    decrypt_data[1]&=0xBF;\r\n\r\n    /* remove IC header */\r\n    offset = mac_header_len;\r\n    *decrypt_len-=4;\r\n    memmove(decrypt_data+offset, decrypt_data+offset+AIRPDCAP_WEP_IVLEN+AIRPDCAP_WEP_KIDLEN, *decrypt_len-offset);\r\n\r\n    return AIRPDCAP_RET_SUCCESS;\r\n}", ".irPDcapRsnaMng": "static INT\r\nAirPDcapRsnaMng(\r\n    UCHAR *decrypt_data,\r\n    guint mac_header_len,\r\n    guint *decrypt_len,\r\n    PAIRPDCAP_KEY_ITEM key,\r\n    AIRPDCAP_SEC_ASSOCIATION *sa,\r\n    INT offset)\r\n{\r\n    INT ret_value=1;\r\n    UCHAR *try_data;\r\n    guint try_data_len = *decrypt_len;\r\n\r\n    if (*decrypt_len > try_data_len) {\r\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsnaMng\", \"Invalid decryption length\", AIRPDCAP_DEBUG_LEVEL_3);\r\n        return AIRPDCAP_RET_UNSUCCESS;\r\n    }\r\n\r\n    /* allocate a temp buffer for the decryption loop */\r\n    try_data=(UCHAR *)g_malloc(try_data_len);\r\n\r\n    /* start of loop added by GCS */\r\n    for(/* sa */; sa != NULL ;sa=sa->next) {\r\n\r\n       if (sa->validKey==FALSE) {\r\n           AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsnaMng\", \"Key not yet valid\", AIRPDCAP_DEBUG_LEVEL_3);\r\n           continue;\r\n       }\r\n\r\n       /* copy the encrypted data into a temp buffer */\r\n       memcpy(try_data, decrypt_data, *decrypt_len);\r\n\r\n       if (sa->wpa.key_ver==1) {\r\n           /* CCMP -> HMAC-MD5 is the EAPOL-Key MIC, RC4 is the EAPOL-Key encryption algorithm */\r\n           AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsnaMng\", \"TKIP\", AIRPDCAP_DEBUG_LEVEL_3);\r\n           DEBUG_DUMP(\"ptk\", sa->wpa.ptk, 64);\r\n           DEBUG_DUMP(\"ptk portion used\", AIRPDCAP_GET_TK(sa->wpa.ptk), 16);\r\n\r\n           ret_value=AirPDcapTkipDecrypt(try_data+offset, *decrypt_len-offset, try_data+AIRPDCAP_TA_OFFSET, AIRPDCAP_GET_TK(sa->wpa.ptk));\r\n           if (ret_value){\r\n               AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsnaMng\", \"TKIP failed!\", AIRPDCAP_DEBUG_LEVEL_3);\r\n               continue;\r\n           }\r\n\r\n           AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsnaMng\", \"TKIP DECRYPTED!!!\", AIRPDCAP_DEBUG_LEVEL_3);\r\n           /* remove MIC (8bytes) and ICV (4bytes) from the end of packet */\r\n           *decrypt_len-=12;\r\n           break;\r\n       } else {\r\n           /* AES-CCMP -> HMAC-SHA1-128 is the EAPOL-Key MIC, AES wep_key wrap is the EAPOL-Key encryption algorithm */\r\n           AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsnaMng\", \"CCMP\", AIRPDCAP_DEBUG_LEVEL_3);\r\n\r\n           ret_value=AirPDcapCcmpDecrypt(try_data, mac_header_len, (INT)*decrypt_len, AIRPDCAP_GET_TK(sa->wpa.ptk));\r\n           if (ret_value)\r\n              continue;\r\n\r\n           AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsnaMng\", \"CCMP DECRYPTED!!!\", AIRPDCAP_DEBUG_LEVEL_3);\r\n           /* remove MIC (8bytes) from the end of packet */\r\n           *decrypt_len-=8;\r\n           break;\r\n       }\r\n    }\r\n    /* end of loop */\r\n\r\n    /* none of the keys worked */\r\n    if(sa == NULL) {\r\n        g_free(try_data);\r\n        return ret_value;\r\n    }\r\n\r\n    if (*decrypt_len > try_data_len || *decrypt_len < 8) {\r\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsnaMng\", \"Invalid decryption length\", AIRPDCAP_DEBUG_LEVEL_3);\r\n        g_free(try_data);\r\n        return AIRPDCAP_RET_UNSUCCESS;\r\n    }\r\n\r\n    /* copy the decrypted data into the decrypt buffer GCS*/\r\n    memcpy(decrypt_data, try_data, *decrypt_len);\r\n    g_free(try_data);\r\n\r\n    /* remove protection bit */\r\n    decrypt_data[1]&=0xBF;\r\n\r\n    /* remove TKIP/CCMP header */\r\n    offset = mac_header_len;\r\n    *decrypt_len-=8;\r\n    memmove(decrypt_data+offset, decrypt_data+offset+8, *decrypt_len-offset);\r\n\r\n    if (key!=NULL) {\r\n        if (sa->key!=NULL)\r\n            memcpy(key, sa->key, sizeof(AIRPDCAP_KEY_ITEM));\r\n        else\r\n            memset(key, 0, sizeof(AIRPDCAP_KEY_ITEM));\r\n        memcpy(key->KeyData.Wpa.Ptk, sa->wpa.ptk, AIRPDCAP_WPA_PTK_LEN); /* copy the PTK to the key structure for future use by wireshark */\r\n        if (sa->wpa.key_ver==AIRPDCAP_WPA_KEY_VER_NOT_CCMP)\r\n            key->KeyType=AIRPDCAP_KEY_TYPE_TKIP;\r\n        else if (sa->wpa.key_ver==AIRPDCAP_WPA_KEY_VER_AES_CCMP)\r\n            key->KeyType=AIRPDCAP_KEY_TYPE_CCMP;\r\n    }\r\n\r\n    return AIRPDCAP_RET_SUCCESS;\r\n}", ".irPDcapInitContext": "INT AirPDcapInitContext(\r\n    PAIRPDCAP_CONTEXT ctx)\r\n{\r\n    AIRPDCAP_DEBUG_TRACE_START(\"AirPDcapInitContext\");\r\n\r\n    if (ctx==NULL) {\r\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapInitContext\", \"NULL context\", AIRPDCAP_DEBUG_LEVEL_5);\r\n        AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapInitContext\");\r\n        return AIRPDCAP_RET_UNSUCCESS;\r\n    }\r\n\r\n    AirPDcapCleanKeys(ctx);\r\n\r\n    ctx->first_free_index=0;\r\n    ctx->index=-1;\r\n    ctx->sa_index=-1;\r\n    ctx->pkt_ssid_len = 0;\r\n\r\n    memset(ctx->sa, 0, AIRPDCAP_MAX_SEC_ASSOCIATIONS_NR * sizeof(AIRPDCAP_SEC_ASSOCIATION));\r\n\r\n    AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapInitContext\", \"Context initialized!\", AIRPDCAP_DEBUG_LEVEL_5);\r\n    AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapInitContext\");\r\n    return AIRPDCAP_RET_SUCCESS;\r\n}", ".irPDcapValidateKey": "static INT\r\nAirPDcapValidateKey(\r\n    PAIRPDCAP_KEY_ITEM key)\r\n{\r\n    size_t len;\r\n    UCHAR ret=TRUE;\r\n    AIRPDCAP_DEBUG_TRACE_START(\"AirPDcapValidateKey\");\r\n\r\n    if (key==NULL) {\r\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapValidateKey\", \"NULL key\", AIRPDCAP_DEBUG_LEVEL_5);\r\n        AIRPDCAP_DEBUG_TRACE_START(\"AirPDcapValidateKey\");\r\n        return FALSE;\r\n    }\r\n\r\n    switch (key->KeyType) {\r\n        case AIRPDCAP_KEY_TYPE_WEP:\r\n            /* check key size limits */\r\n            len=key->KeyData.Wep.WepKeyLen;\r\n            if (len<AIRPDCAP_WEP_KEY_MINLEN || len>AIRPDCAP_WEP_KEY_MAXLEN) {\r\n                AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapValidateKey\", \"WEP key: key length not accepted\", AIRPDCAP_DEBUG_LEVEL_5);\r\n                ret=FALSE;\r\n            }\r\n            break;\r\n\r\n        case AIRPDCAP_KEY_TYPE_WEP_40:\r\n            /* set the standard length and use a generic WEP key type */\r\n            key->KeyData.Wep.WepKeyLen=AIRPDCAP_WEP_40_KEY_LEN;\r\n            key->KeyType=AIRPDCAP_KEY_TYPE_WEP;\r\n            break;\r\n\r\n        case AIRPDCAP_KEY_TYPE_WEP_104:\r\n            /* set the standard length and use a generic WEP key type */\r\n            key->KeyData.Wep.WepKeyLen=AIRPDCAP_WEP_104_KEY_LEN;\r\n            key->KeyType=AIRPDCAP_KEY_TYPE_WEP;\r\n            break;\r\n\r\n        case AIRPDCAP_KEY_TYPE_WPA_PWD:\r\n            /* check passphrase and SSID size limits */\r\n            len=strlen(key->UserPwd.Passphrase);\r\n            if (len<AIRPDCAP_WPA_PASSPHRASE_MIN_LEN || len>AIRPDCAP_WPA_PASSPHRASE_MAX_LEN) {\r\n                AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapValidateKey\", \"WPA-PWD key: passphrase length not accepted\", AIRPDCAP_DEBUG_LEVEL_5);\r\n                ret=FALSE;\r\n            }\r\n\r\n            len=key->UserPwd.SsidLen;\r\n            if (len>AIRPDCAP_WPA_SSID_MAX_LEN) {\r\n                AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapValidateKey\", \"WPA-PWD key: ssid length not accepted\", AIRPDCAP_DEBUG_LEVEL_5);\r\n                ret=FALSE;\r\n            }\r\n\r\n            break;\r\n\r\n        case AIRPDCAP_KEY_TYPE_WPA_PSK:\r\n            break;\r\n\r\n        case AIRPDCAP_KEY_TYPE_WPA_PMK:\r\n            break;\r\n\r\n        default:\r\n            ret=FALSE;\r\n    }\r\n\r\n    AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapValidateKey\");\r\n    return ret;\r\n}", ".irPDcapRsnaPwd2Psk": "static INT\r\nAirPDcapRsnaPwd2Psk(\r\n    const CHAR *passphrase,\r\n    const CHAR *ssid,\r\n    const size_t ssidLength,\r\n    UCHAR *output)\r\n{\r\n    UCHAR m_output[40] = { 0 };\r\n    GByteArray *pp_ba = g_byte_array_new();\r\n\r\n    if (!uri_str_to_bytes(passphrase, pp_ba)) {\r\n        g_byte_array_free(pp_ba, TRUE);\r\n        return 0;\r\n    }\r\n\r\n    AirPDcapRsnaPwd2PskStep(pp_ba->data, pp_ba->len, ssid, ssidLength, 4096, 1, m_output);\r\n    AirPDcapRsnaPwd2PskStep(pp_ba->data, pp_ba->len, ssid, ssidLength, 4096, 2, &m_output[20]);\r\n\r\n    memcpy(output, m_output, AIRPDCAP_WPA_PSK_LEN);\r\n    g_byte_array_free(pp_ba, TRUE);\r\n\r\n    return 0;\r\n}", ".irPDcapRecurseCleanSA": "static void\r\nAirPDcapRecurseCleanSA(\r\n    PAIRPDCAP_SEC_ASSOCIATION sa)\r\n{\r\n    if (sa->next != NULL) {\r\n        AirPDcapRecurseCleanSA(sa->next);\r\n        g_free(sa->next);\r\n        sa->next = NULL;\r\n    }\r\n}", ".irPDcapCleanKeys": "static void\r\nAirPDcapCleanKeys(\r\n    PAIRPDCAP_CONTEXT ctx)\r\n{\r\n    AIRPDCAP_DEBUG_TRACE_START(\"AirPDcapCleanKeys\");\r\n\r\n    if (ctx==NULL) {\r\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapCleanKeys\", \"NULL context\", AIRPDCAP_DEBUG_LEVEL_5);\r\n        AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapCleanKeys\");\r\n        return;\r\n    }\r\n\r\n    memset(ctx->keys, 0, sizeof(AIRPDCAP_KEY_ITEM) * AIRPDCAP_MAX_KEYS_NR);\r\n\r\n    ctx->keys_nr=0;\r\n\r\n    AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapCleanKeys\", \"Keys collection cleaned!\", AIRPDCAP_DEBUG_LEVEL_5);\r\n    AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapCleanKeys\");\r\n}", ".irPDcapCleanSecAssoc": "static void\r\nAirPDcapCleanSecAssoc(\r\n    PAIRPDCAP_CONTEXT ctx)\r\n{\r\n    PAIRPDCAP_SEC_ASSOCIATION psa;\r\n    int i;\r\n\r\n    for (psa = ctx->sa, i = 0; i < AIRPDCAP_MAX_SEC_ASSOCIATIONS_NR; i++, psa++) {\r\n        /* To iterate is human, to recurse, divine */\r\n        AirPDcapRecurseCleanSA(psa);\r\n    }\r\n}", ".irPDcapRsnaPrfX": "static void\r\nAirPDcapRsnaPrfX(\r\n    AIRPDCAP_SEC_ASSOCIATION *sa,\r\n    const UCHAR pmk[32],\r\n    const UCHAR snonce[32],\r\n    const INT x,        /*      for TKIP 512, for CCMP 384 */\r\n    UCHAR *ptk)\r\n{\r\n    UINT8 i;\r\n    UCHAR R[100];\r\n    INT offset=sizeof(\"Pairwise key expansion\");\r\n    UCHAR output[80]; /* allow for sha1 overflow. */\r\n\r\n    memset(R, 0, 100);\r\n\r\n    memcpy(R, \"Pairwise key expansion\", offset);\r\n\r\n    /* Min(AA, SPA) || Max(AA, SPA) */\r\n    if (memcmp(sa->saId.sta, sa->saId.bssid, AIRPDCAP_MAC_LEN) < 0)\r\n    {\r\n        memcpy(R + offset, sa->saId.sta, AIRPDCAP_MAC_LEN);\r\n        memcpy(R + offset+AIRPDCAP_MAC_LEN, sa->saId.bssid, AIRPDCAP_MAC_LEN);\r\n    }\r\n    else\r\n    {\r\n        memcpy(R + offset, sa->saId.bssid, AIRPDCAP_MAC_LEN);\r\n        memcpy(R + offset+AIRPDCAP_MAC_LEN, sa->saId.sta, AIRPDCAP_MAC_LEN);\r\n    }\r\n\r\n    offset+=AIRPDCAP_MAC_LEN*2;\r\n\r\n    /* Min(ANonce,SNonce) || Max(ANonce,SNonce) */\r\n    if( memcmp(snonce, sa->wpa.nonce, 32) < 0 )\r\n    {\r\n        memcpy(R + offset, snonce, 32);\r\n        memcpy(R + offset + 32, sa->wpa.nonce, 32);\r\n    }\r\n    else\r\n    {\r\n        memcpy(R + offset, sa->wpa.nonce, 32);\r\n        memcpy(R + offset + 32, snonce, 32);\r\n    }\r\n\r\n    offset+=32*2;\r\n\r\n    for(i = 0; i < (x+159)/160; i++)\r\n    {\r\n        R[offset] = i;\r\n        if (ws_hmac_buffer(GCRY_MD_SHA1, &output[HASH_SHA1_LENGTH * i], R, 100, pmk, 32)) {\r\n          return;\r\n        }\r\n    }\r\n    memcpy(ptk, output, x/8);\r\n}", ".irPDcapRsnaMicCheck": "static INT\r\nAirPDcapRsnaMicCheck(\r\n    UCHAR *eapol,\r\n    USHORT eapol_len,\r\n    UCHAR KCK[AIRPDCAP_WPA_KCK_LEN],\r\n    USHORT key_ver)\r\n{\r\n    UCHAR mic[AIRPDCAP_WPA_MICKEY_LEN];\r\n    UCHAR c_mic[HASH_SHA1_LENGTH] = { 0 };  /* MIC 16 byte, the HMAC-SHA1 use a buffer of 20 bytes */\r\n    int algo;\r\n\r\n    /* copy the MIC from the EAPOL packet */\r\n    memcpy(mic, eapol+AIRPDCAP_WPA_MICKEY_OFFSET+4, AIRPDCAP_WPA_MICKEY_LEN);\r\n\r\n    /* set to 0 the MIC in the EAPOL packet (to calculate the MIC) */\r\n    memset(eapol+AIRPDCAP_WPA_MICKEY_OFFSET+4, 0, AIRPDCAP_WPA_MICKEY_LEN);\r\n\r\n    if (key_ver==AIRPDCAP_WPA_KEY_VER_NOT_CCMP) {\r\n        /* use HMAC-MD5 for the EAPOL-Key MIC */\r\n        algo = GCRY_MD_MD5;\r\n    } else if (key_ver==AIRPDCAP_WPA_KEY_VER_AES_CCMP) {\r\n        /* use HMAC-SHA1-128 for the EAPOL-Key MIC */\r\n        algo = GCRY_MD_SHA1;\r\n    } else {\r\n        /* key descriptor version not recognized */\r\n        return AIRPDCAP_RET_UNSUCCESS;\r\n    }\r\n\r\n    if (ws_hmac_buffer(algo, c_mic, eapol, eapol_len, KCK, AIRPDCAP_WPA_KCK_LEN)) {\r\n        return AIRPDCAP_RET_UNSUCCESS;\r\n    }\r\n\r\n    /* compare calculated MIC with the Key MIC and return result (0 means success) */\r\n    return memcmp(mic, c_mic, AIRPDCAP_WPA_MICKEY_LEN);\r\n}", ".irPDcapRsnaPwd2PskStep": "static INT\r\nAirPDcapRsnaPwd2PskStep(\r\n    const guint8 *ppBytes,\r\n    const guint ppLength,\r\n    const CHAR *ssid,\r\n    const size_t ssidLength,\r\n    const INT iterations,\r\n    const INT count,\r\n    UCHAR *output)\r\n{\r\n    UCHAR digest[MAX_SSID_LENGTH+4] = { 0 };  /* SSID plus 4 bytes of count */\r\n    INT i, j;\r\n\r\n    if (ssidLength > MAX_SSID_LENGTH) {\r\n        /* This \"should not happen\" */\r\n        return AIRPDCAP_RET_UNSUCCESS;\r\n    }\r\n\r\n    /* U1 = PRF(P, S || INT(i)) */\r\n    memcpy(digest, ssid, ssidLength);\r\n    digest[ssidLength] = (UCHAR)((count>>24) & 0xff);\r\n    digest[ssidLength+1] = (UCHAR)((count>>16) & 0xff);\r\n    digest[ssidLength+2] = (UCHAR)((count>>8) & 0xff);\r\n    digest[ssidLength+3] = (UCHAR)(count & 0xff);\r\n    if (ws_hmac_buffer(GCRY_MD_SHA1, digest, digest, (guint32) ssidLength + 4, ppBytes, ppLength)) {\r\n      return AIRPDCAP_RET_UNSUCCESS;\r\n    }\r\n\r\n    /* output = U1 */\r\n    memcpy(output, digest, 20);\r\n    for (i = 1; i < iterations; i++) {\r\n        /* Un = PRF(P, Un-1) */\r\n        if (ws_hmac_buffer(GCRY_MD_SHA1, digest, digest, HASH_SHA1_LENGTH, ppBytes, ppLength)) {\r\n          return AIRPDCAP_RET_UNSUCCESS;\r\n        }\r\n\r\n        /* output = output xor Un */\r\n        for (j = 0; j < 20; j++) {\r\n            output[j] ^= digest[j];\r\n        }\r\n    }\r\n\r\n    return AIRPDCAP_RET_SUCCESS;\r\n}"}, "callee": {".irPDcapScanForKeys": "static INT AirPDcapScanForKeys(\r\n    PAIRPDCAP_CONTEXT ctx,\r\n    const guint8 *data,\r\n    const guint mac_header_len,\r\n    const guint tot_len,\r\n    AIRPDCAP_SEC_ASSOCIATION_ID id\r\n)\r\n{\r\n    const UCHAR *addr;\r\n    guint bodyLength;\r\n    PAIRPDCAP_SEC_ASSOCIATION sta_sa;\r\n    PAIRPDCAP_SEC_ASSOCIATION sa;\r\n    guint offset = 0;\r\n    const guint8 dot1x_header[] = {\r\n        0xAA,             /* DSAP=SNAP */\r\n        0xAA,             /* SSAP=SNAP */\r\n        0x03,             /* Control field=Unnumbered frame */\r\n        0x00, 0x00, 0x00, /* Org. code=encaps. Ethernet */\r\n        0x88, 0x8E        /* Type: 802.1X authentication */\r\n    };\r\n    const guint8 bt_dot1x_header[] = {\r\n        0xAA,             /* DSAP=SNAP */\r\n        0xAA,             /* SSAP=SNAP */\r\n        0x03,             /* Control field=Unnumbered frame */\r\n        0x00, 0x19, 0x58, /* Org. code=Bluetooth SIG */\r\n        0x00, 0x03        /* Type: Bluetooth Security */\r\n    };\r\n    const guint8 tdls_header[] = {\r\n        0xAA,             /* DSAP=SNAP */\r\n        0xAA,             /* SSAP=SNAP */\r\n        0x03,             /* Control field=Unnumbered frame */\r\n        0x00, 0x00, 0x00, /* Org. code=encaps. Ethernet */\r\n        0x89, 0x0D,       /* Type: 802.11 - Fast Roaming Remote Request */\r\n        0x02,             /* Payload Type: TDLS */\r\n        0X0C              /* Action Category: TDLS */\r\n    };\r\n\r\n    const EAPOL_RSN_KEY *pEAPKey;\r\n#ifdef AIRPDCAP_DEBUG\r\n#define MSGBUF_LEN 255\r\n    CHAR msgbuf[MSGBUF_LEN];\r\n#endif\r\n    AIRPDCAP_DEBUG_TRACE_START(\"AirPDcapScanForKeys\");\r\n\r\n    /* cache offset in the packet data */\r\n    offset = mac_header_len;\r\n\r\n    /* check if the packet has an LLC header and the packet is 802.1X authentication (IEEE 802.1X-2004, pg. 24) */\r\n    if (memcmp(data+offset, dot1x_header, 8) == 0 || memcmp(data+offset, bt_dot1x_header, 8) == 0) {\r\n\r\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Authentication: EAPOL packet\", AIRPDCAP_DEBUG_LEVEL_3);\r\n\r\n        /* skip LLC header */\r\n        offset+=8;\r\n\r\n        /* check if the packet is a EAPOL-Key (0x03) (IEEE 802.1X-2004, pg. 25) */\r\n        if (data[offset+1]!=3) {\r\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Not EAPOL-Key\", AIRPDCAP_DEBUG_LEVEL_3);\r\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\r\n        }\r\n\r\n        /* get and check the body length (IEEE 802.1X-2004, pg. 25) */\r\n        bodyLength=pntoh16(data+offset+2);\r\n        if (((tot_len-offset-4) < bodyLength) || (bodyLength < sizeof(EAPOL_RSN_KEY))) { /* Only check if frame is long enough for eapol header, ignore tailing garbage, see bug 9065 */\r\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"EAPOL body too short\", AIRPDCAP_DEBUG_LEVEL_3);\r\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\r\n        }\r\n\r\n        /* skip EAPOL MPDU and go to the first byte of the body */\r\n        offset+=4;\r\n\r\n        pEAPKey = (const EAPOL_RSN_KEY *) (data+offset);\r\n\r\n        /* check if the key descriptor type is valid (IEEE 802.1X-2004, pg. 27) */\r\n        if (/*pEAPKey->type!=0x1 &&*/ /* RC4 Key Descriptor Type (deprecated) */\r\n            pEAPKey->type != AIRPDCAP_RSN_WPA2_KEY_DESCRIPTOR &&             /* IEEE 802.11 Key Descriptor Type  (WPA2) */\r\n            pEAPKey->type != AIRPDCAP_RSN_WPA_KEY_DESCRIPTOR)           /* 254 = RSN_KEY_DESCRIPTOR - WPA,              */\r\n        {\r\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Not valid key descriptor type\", AIRPDCAP_DEBUG_LEVEL_3);\r\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\r\n        }\r\n\r\n        /* start with descriptor body */\r\n        offset+=1;\r\n\r\n        /* search for a cached Security Association for current BSSID and AP */\r\n        sa = AirPDcapGetSaPtr(ctx, &id);\r\n        if (sa == NULL){\r\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"No SA for BSSID found\", AIRPDCAP_DEBUG_LEVEL_3);\r\n            return AIRPDCAP_RET_REQ_DATA;\r\n        }\r\n\r\n        /* It could be a Pairwise Key exchange, check */\r\n        if (AirPDcapRsna4WHandshake(ctx, data, sa, offset, tot_len) == AIRPDCAP_RET_SUCCESS_HANDSHAKE)\r\n            return AIRPDCAP_RET_SUCCESS_HANDSHAKE;\r\n\r\n        if (mac_header_len + GROUP_KEY_PAYLOAD_LEN_MIN > tot_len) {\r\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Message too short for Group Key\", AIRPDCAP_DEBUG_LEVEL_3);\r\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\r\n        }\r\n\r\n        /* Verify the bitfields: Key = 0(groupwise) Mic = 1 Ack = 1 Secure = 1 */\r\n        if (AIRPDCAP_EAP_KEY(data[offset+1])!=0 ||\r\n            AIRPDCAP_EAP_ACK(data[offset+1])!=1 ||\r\n            AIRPDCAP_EAP_MIC(data[offset]) != 1 ||\r\n            AIRPDCAP_EAP_SEC(data[offset]) != 1){\r\n\r\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Key bitfields not correct for Group Key\", AIRPDCAP_DEBUG_LEVEL_3);\r\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\r\n        }\r\n\r\n        /* force STA address to be the broadcast MAC so we create an SA for the groupkey */\r\n        memcpy(id.sta, broadcast_mac, AIRPDCAP_MAC_LEN);\r\n\r\n        /* get the Security Association structure for the broadcast MAC and AP */\r\n        sa = AirPDcapGetSaPtr(ctx, &id);\r\n        if (sa == NULL){\r\n            return AIRPDCAP_RET_REQ_DATA;\r\n        }\r\n\r\n        /* Get the SA for the STA, since we need its pairwise key to decrpyt the group key */\r\n\r\n        /* get STA address */\r\n        if ( (addr=AirPDcapGetStaAddress((const AIRPDCAP_MAC_FRAME_ADDR4 *)(data))) != NULL) {\r\n            memcpy(id.sta, addr, AIRPDCAP_MAC_LEN);\r\n#ifdef AIRPDCAP_DEBUG\r\n            g_snprintf(msgbuf, MSGBUF_LEN, \"ST_MAC: %2X.%2X.%2X.%2X.%2X.%2X\\t\", id.sta[0],id.sta[1],id.sta[2],id.sta[3],id.sta[4],id.sta[5]);\r\n#endif\r\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", msgbuf, AIRPDCAP_DEBUG_LEVEL_3);\r\n        } else {\r\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"SA not found\", AIRPDCAP_DEBUG_LEVEL_5);\r\n            return AIRPDCAP_RET_REQ_DATA;\r\n        }\r\n\r\n        sta_sa = AirPDcapGetSaPtr(ctx, &id);\r\n        if (sta_sa == NULL){\r\n            return AIRPDCAP_RET_REQ_DATA;\r\n        }\r\n\r\n        /* Try to extract the group key and install it in the SA */\r\n        return (AirPDcapDecryptWPABroadcastKey(pEAPKey, sta_sa->wpa.ptk+16, sa, tot_len-offset+1));\r\n\r\n    } else if (memcmp(data+offset, tdls_header, 10) == 0) {\r\n        const guint8 *initiator, *responder;\r\n        guint8 action;\r\n        guint status, offset_rsne = 0, offset_fte = 0, offset_link = 0, offset_timeout = 0;\r\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Authentication: TDLS Action Frame\", AIRPDCAP_DEBUG_LEVEL_3);\r\n\r\n        /* skip LLC header */\r\n        offset+=10;\r\n\r\n        /* check if the packet is a TDLS response or confirm */\r\n        action = data[offset];\r\n        if (action!=1 && action!=2) {\r\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Not Response nor confirm\", AIRPDCAP_DEBUG_LEVEL_3);\r\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\r\n        }\r\n\r\n        /* check status */\r\n        offset++;\r\n        status=pntoh16(data+offset);\r\n        if (status!=0) {\r\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"TDLS setup not successfull\", AIRPDCAP_DEBUG_LEVEL_3);\r\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\r\n        }\r\n\r\n        /* skip Token + capabilities */\r\n        offset+=5;\r\n\r\n        /* search for RSN, Fast BSS Transition, Link Identifier and Timeout Interval IEs */\r\n\r\n        while(offset < (tot_len - 2)) {\r\n            if (data[offset] == 48) {\r\n                offset_rsne = offset;\r\n            } else if (data[offset] == 55) {\r\n                offset_fte = offset;\r\n            } else if (data[offset] == 56) {\r\n                offset_timeout = offset;\r\n            } else if (data[offset] == 101) {\r\n                offset_link = offset;\r\n            }\r\n\r\n            if (tot_len < offset + data[offset + 1] + 2) {\r\n                return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\r\n            }\r\n            offset += data[offset + 1] + 2;\r\n        }\r\n\r\n        if (offset_rsne == 0 || offset_fte == 0 ||\r\n            offset_timeout == 0 || offset_link == 0)\r\n        {\r\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Cannot Find all necessary IEs\", AIRPDCAP_DEBUG_LEVEL_3);\r\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\r\n        }\r\n\r\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Found RSNE/Fast BSS/Timeout Interval/Link IEs\", AIRPDCAP_DEBUG_LEVEL_3);\r\n\r\n        /* Will create a Security Association between 2 STA. Need to get both MAC address */\r\n        initiator = &data[offset_link + 8];\r\n        responder = &data[offset_link + 14];\r\n\r\n        if (memcmp(initiator, responder, AIRPDCAP_MAC_LEN) < 0) {\r\n            memcpy(id.sta, initiator, AIRPDCAP_MAC_LEN);\r\n            memcpy(id.bssid, responder, AIRPDCAP_MAC_LEN);\r\n        } else {\r\n            memcpy(id.sta, responder, AIRPDCAP_MAC_LEN);\r\n            memcpy(id.bssid, initiator, AIRPDCAP_MAC_LEN);\r\n        }\r\n\r\n        sa = AirPDcapGetSaPtr(ctx, &id);\r\n        if (sa == NULL){\r\n            return AIRPDCAP_RET_REQ_DATA;\r\n        }\r\n\r\n        if (sa->validKey) {\r\n            if (memcmp(sa->wpa.nonce, data + offset_fte + 52, AIRPDCAP_WPA_NONCE_LEN) == 0) {\r\n                /* Already have valid key for this SA, no need to redo key derivation */\r\n                return AIRPDCAP_RET_SUCCESS_HANDSHAKE;\r\n            } else {\r\n                /* We are opening a new session with the same two STA, save previous sa  */\r\n                AIRPDCAP_SEC_ASSOCIATION *tmp_sa = g_new(AIRPDCAP_SEC_ASSOCIATION, 1);\r\n                memcpy(tmp_sa, sa, sizeof(AIRPDCAP_SEC_ASSOCIATION));\r\n                sa->next=tmp_sa;\r\n                sa->validKey = FALSE;\r\n            }\r\n        }\r\n\r\n        if (AirPDcapTDLSDeriveKey(sa, data, offset_rsne, offset_fte, offset_timeout, offset_link, action)\r\n            == AIRPDCAP_RET_SUCCESS) {\r\n            AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapScanForKeys\");\r\n            return AIRPDCAP_RET_SUCCESS_HANDSHAKE;\r\n        }\r\n    } else {\r\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Skipping: not an EAPOL packet\", AIRPDCAP_DEBUG_LEVEL_3);\r\n    }\r\n\r\n    AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapScanForKeys\");\r\n    return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\r\n}", ".irPDcapRsna4WHandshake": "static INT\r\nAirPDcapRsna4WHandshake(\r\n    PAIRPDCAP_CONTEXT ctx,\r\n    const UCHAR *data,\r\n    AIRPDCAP_SEC_ASSOCIATION *sa,\r\n    INT offset,\r\n    const guint tot_len)\r\n{\r\n    AIRPDCAP_KEY_ITEM *tmp_key, *tmp_pkt_key, pkt_key;\r\n    AIRPDCAP_SEC_ASSOCIATION *tmp_sa;\r\n    INT key_index;\r\n    INT ret_value=1;\r\n    UCHAR useCache=FALSE;\r\n    UCHAR eapol[AIRPDCAP_EAPOL_MAX_LEN];\r\n    USHORT eapol_len;\r\n\r\n    if (sa->key!=NULL)\r\n        useCache=TRUE;\r\n\r\n    /* a 4-way handshake packet use a Pairwise key type (IEEE 802.11i-2004, pg. 79) */\r\n    if (AIRPDCAP_EAP_KEY(data[offset+1])!=1) {\r\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsna4WHandshake\", \"Group/STAKey message (not used)\", AIRPDCAP_DEBUG_LEVEL_5);\r\n        return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\r\n    }\r\n\r\n    /* TODO timeouts? */\r\n\r\n    /* TODO consider key-index */\r\n\r\n    /* TODO considera Deauthentications */\r\n\r\n    AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsna4WHandshake\", \"4-way handshake...\", AIRPDCAP_DEBUG_LEVEL_5);\r\n\r\n    /* manage 4-way handshake packets; this step completes the 802.1X authentication process (IEEE 802.11i-2004, pag. 85) */\r\n\r\n    /* message 1: Authenticator->Supplicant (Sec=0, Mic=0, Ack=1, Inst=0, Key=1(pairwise), KeyRSC=0, Nonce=ANonce, MIC=0) */\r\n    if (AIRPDCAP_EAP_INST(data[offset+1])==0 &&\r\n        AIRPDCAP_EAP_ACK(data[offset+1])==1 &&\r\n        AIRPDCAP_EAP_MIC(data[offset])==0)\r\n    {\r\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsna4WHandshake\", \"4-way handshake message 1\", AIRPDCAP_DEBUG_LEVEL_3);\r\n\r\n        /* On reception of Message 1, the Supplicant determines whether the Key Replay Counter field value has been        */\r\n        /* used before with the current PMKSA. If the Key Replay Counter field value is less than or equal to the current  */\r\n        /* local value, the Supplicant discards the message.                                                               */\r\n        /* -> not checked, the Authenticator will be send another Message 1 (hopefully!)                                   */\r\n\r\n        /* This saves the sa since we are reauthenticating which will overwrite our current sa GCS*/\r\n        if( sa->handshake >= 2) {\r\n            tmp_sa= g_new(AIRPDCAP_SEC_ASSOCIATION, 1);\r\n            memcpy(tmp_sa, sa, sizeof(AIRPDCAP_SEC_ASSOCIATION));\r\n            sa->validKey=FALSE;\r\n            sa->next=tmp_sa;\r\n        }\r\n\r\n        /* save ANonce (from authenticator) to derive the PTK with the SNonce (from the 2 message) */\r\n        memcpy(sa->wpa.nonce, data+offset+12, 32);\r\n\r\n        /* get the Key Descriptor Version (to select algorithm used in decryption -CCMP or TKIP-) */\r\n        sa->wpa.key_ver=AIRPDCAP_EAP_KEY_DESCR_VER(data[offset+1]);\r\n\r\n        sa->handshake=1;\r\n\r\n        return AIRPDCAP_RET_SUCCESS_HANDSHAKE;\r\n    }\r\n\r\n    /* message 2|4: Supplicant->Authenticator (Sec=0|1, Mic=1, Ack=0, Inst=0, Key=1(pairwise), KeyRSC=0, Nonce=SNonce|0, MIC=MIC(KCK,EAPOL)) */\r\n    if (AIRPDCAP_EAP_INST(data[offset+1])==0 &&\r\n        AIRPDCAP_EAP_ACK(data[offset+1])==0 &&\r\n        AIRPDCAP_EAP_MIC(data[offset])==1)\r\n    {\r\n        /* Check key data length to differentiate between message 2 or 4, same as in epan/dissectors/packet-ieee80211.c */\r\n        if (pntoh16(data+offset+92)) {\r\n            /* message 2 */\r\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsna4WHandshake\", \"4-way handshake message 2\", AIRPDCAP_DEBUG_LEVEL_3);\r\n\r\n            /* On reception of Message 2, the Authenticator checks that the key replay counter corresponds to the */\r\n            /* outstanding Message 1. If not, it silently discards the message.                                   */\r\n            /* If the calculated MIC does not match the MIC that the Supplicant included in the EAPOL-Key frame,  */\r\n            /* the Authenticator silently discards Message 2.                                                     */\r\n            /* -> not checked; the Supplicant will send another message 2 (hopefully!)                            */\r\n\r\n            /* now you can derive the PTK */\r\n            for (key_index=0; key_index<(INT)ctx->keys_nr || useCache; key_index++) {\r\n                /* use the cached one, or try all keys */\r\n                if (!useCache) {\r\n                    AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsna4WHandshake\", \"Try WPA key...\", AIRPDCAP_DEBUG_LEVEL_3);\r\n                    tmp_key=&ctx->keys[key_index];\r\n                } else {\r\n                    /* there is a cached key in the security association, if it's a WPA key try it... */\r\n                    if (sa->key!=NULL &&\r\n                        (sa->key->KeyType==AIRPDCAP_KEY_TYPE_WPA_PWD ||\r\n                         sa->key->KeyType==AIRPDCAP_KEY_TYPE_WPA_PSK ||\r\n                         sa->key->KeyType==AIRPDCAP_KEY_TYPE_WPA_PMK)) {\r\n                            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsna4WHandshake\", \"Try cached WPA key...\", AIRPDCAP_DEBUG_LEVEL_3);\r\n                            tmp_key=sa->key;\r\n                    } else {\r\n                        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsna4WHandshake\", \"Cached key is of a wrong type, try WPA key...\", AIRPDCAP_DEBUG_LEVEL_3);\r\n                        tmp_key=&ctx->keys[key_index];\r\n                    }\r\n                }\r\n\r\n                /* obviously, try only WPA keys... */\r\n                if (tmp_key->KeyType==AIRPDCAP_KEY_TYPE_WPA_PWD ||\r\n                    tmp_key->KeyType==AIRPDCAP_KEY_TYPE_WPA_PSK ||\r\n                    tmp_key->KeyType==AIRPDCAP_KEY_TYPE_WPA_PMK)\r\n                {\r\n                    if (tmp_key->KeyType == AIRPDCAP_KEY_TYPE_WPA_PWD && tmp_key->UserPwd.SsidLen == 0 && ctx->pkt_ssid_len > 0 && ctx->pkt_ssid_len <= AIRPDCAP_WPA_SSID_MAX_LEN) {\r\n                        /* We have a \"wildcard\" SSID.  Use the one from the packet. */\r\n                        memcpy(&pkt_key, tmp_key, sizeof(pkt_key));\r\n                        memcpy(&pkt_key.UserPwd.Ssid, ctx->pkt_ssid, ctx->pkt_ssid_len);\r\n                         pkt_key.UserPwd.SsidLen = ctx->pkt_ssid_len;\r\n                        AirPDcapRsnaPwd2Psk(pkt_key.UserPwd.Passphrase, pkt_key.UserPwd.Ssid,\r\n                            pkt_key.UserPwd.SsidLen, pkt_key.KeyData.Wpa.Psk);\r\n                        tmp_pkt_key = &pkt_key;\r\n                    } else {\r\n                        tmp_pkt_key = tmp_key;\r\n                    }\r\n\r\n                    /* derive the PTK from the BSSID, STA MAC, PMK, SNonce, ANonce */\r\n                    AirPDcapRsnaPrfX(sa,                            /* authenticator nonce, bssid, station mac */\r\n                                     tmp_pkt_key->KeyData.Wpa.Psk,      /* PSK == PMK */\r\n                                     data+offset+12,                /* supplicant nonce */\r\n                                     512,\r\n                                     sa->wpa.ptk);\r\n\r\n                    /* verify the MIC (compare the MIC in the packet included in this message with a MIC calculated with the PTK) */\r\n                    eapol_len=pntoh16(data+offset-3)+4;\r\n                    memcpy(eapol, &data[offset-5], (eapol_len<AIRPDCAP_EAPOL_MAX_LEN?eapol_len:AIRPDCAP_EAPOL_MAX_LEN));\r\n                    ret_value=AirPDcapRsnaMicCheck(eapol,           /*      eapol frame (header also) */\r\n                                                   eapol_len,       /*      eapol frame length        */\r\n                                                   sa->wpa.ptk,     /*      Key Confirmation Key      */\r\n                                                   AIRPDCAP_EAP_KEY_DESCR_VER(data[offset+1])); /*  EAPOL-Key description version */\r\n\r\n                    /* If the MIC is valid, the Authenticator checks that the RSN information element bit-wise matches       */\r\n                    /* that from the (Re)Association Request message.                                                        */\r\n                    /*              i) TODO If these are not exactly the same, the Authenticator uses MLME-DEAUTHENTICATE.request */\r\n                    /* primitive to terminate the association.                                                               */\r\n                    /*              ii) If they do match bit-wise, the Authenticator constructs Message 3.                   */\r\n                }\r\n\r\n                if (!ret_value &&\r\n                    (tmp_key->KeyType==AIRPDCAP_KEY_TYPE_WPA_PWD ||\r\n                    tmp_key->KeyType==AIRPDCAP_KEY_TYPE_WPA_PSK ||\r\n                    tmp_key->KeyType==AIRPDCAP_KEY_TYPE_WPA_PMK))\r\n                {\r\n                    /* the temporary key is the correct one, cached in the Security Association */\r\n\r\n                    sa->key=tmp_key;\r\n                    break;\r\n                } else {\r\n                    /* the cached key was not valid, try other keys */\r\n\r\n                    if (useCache==TRUE) {\r\n                        useCache=FALSE;\r\n                        key_index--;\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (ret_value) {\r\n                AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsna4WHandshake\", \"handshake step failed\", AIRPDCAP_DEBUG_LEVEL_3);\r\n                return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\r\n            }\r\n\r\n            sa->handshake=2;\r\n            sa->validKey=TRUE; /* we can use the key to decode, even if we have not captured the other eapol packets */\r\n\r\n            return AIRPDCAP_RET_SUCCESS_HANDSHAKE;\r\n        } else {\r\n        /* message 4 */\r\n\r\n            /* TODO \"Note that when the 4-Way Handshake is first used Message 4 is sent in the clear.\" */\r\n\r\n            /* TODO check MIC and Replay Counter                                                                     */\r\n            /* On reception of Message 4, the Authenticator verifies that the Key Replay Counter field value is one  */\r\n            /* that it used on this 4-Way Handshake; if it is not, it silently discards the message.                 */\r\n            /* If the calculated MIC does not match the MIC that the Supplicant included in the EAPOL-Key frame, the */\r\n            /* Authenticator silently discards Message 4.                                                            */\r\n\r\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsna4WHandshake\", \"4-way handshake message 4\", AIRPDCAP_DEBUG_LEVEL_3);\r\n\r\n            sa->handshake=4;\r\n\r\n            return AIRPDCAP_RET_SUCCESS_HANDSHAKE;\r\n        }\r\n    }\r\n\r\n    /* message 3: Authenticator->Supplicant (Sec=1, Mic=1, Ack=1, Inst=0/1, Key=1(pairwise), KeyRSC=???, Nonce=ANonce, MIC=1) */\r\n    if (AIRPDCAP_EAP_ACK(data[offset+1])==1 &&\r\n        AIRPDCAP_EAP_MIC(data[offset])==1)\r\n    {\r\n        const EAPOL_RSN_KEY *pEAPKey;\r\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapRsna4WHandshake\", \"4-way handshake message 3\", AIRPDCAP_DEBUG_LEVEL_3);\r\n\r\n        /* On reception of Message 3, the Supplicant silently discards the message if the Key Replay Counter field     */\r\n        /* value has already been used or if the ANonce value in Message 3 differs from the ANonce value in Message 1. */\r\n        /* -> not checked, the Authenticator will send another message 3 (hopefully!)                                  */\r\n\r\n        /* TODO check page 88 (RNS) */\r\n\r\n        /* If using WPA2 PSK, message 3 will contain an RSN for the group key (GTK KDE).\r\n           In order to properly support decrypting WPA2-PSK packets, we need to parse this to get the group key. */\r\n        pEAPKey = (const EAPOL_RSN_KEY *)(&(data[offset-1]));\r\n        if (pEAPKey->type == AIRPDCAP_RSN_WPA2_KEY_DESCRIPTOR){\r\n            PAIRPDCAP_SEC_ASSOCIATION broadcast_sa;\r\n            AIRPDCAP_SEC_ASSOCIATION_ID id;\r\n\r\n            /* Get broadcacst SA for the current BSSID */\r\n            memcpy(id.sta, broadcast_mac, AIRPDCAP_MAC_LEN);\r\n            memcpy(id.bssid, sa->saId.bssid, AIRPDCAP_MAC_LEN);\r\n            broadcast_sa = AirPDcapGetSaPtr(ctx, &id);\r\n\r\n            if (broadcast_sa == NULL){\r\n                return AIRPDCAP_RET_REQ_DATA;\r\n            }\r\n            return (AirPDcapDecryptWPABroadcastKey(pEAPKey, sa->wpa.ptk+16, broadcast_sa, tot_len-offset+1));\r\n        }\r\n    }\r\n\r\n    return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\r\n}", ".irPDcapPacketProcess": "INT AirPDcapPacketProcess(\r\n    PAIRPDCAP_CONTEXT ctx,\r\n    const guint8 *data,\r\n    const guint mac_header_len,\r\n    const guint tot_len,\r\n    UCHAR *decrypt_data,\r\n    guint *decrypt_len,\r\n    PAIRPDCAP_KEY_ITEM key,\r\n    gboolean scanHandshake)\r\n{\r\n    AIRPDCAP_SEC_ASSOCIATION_ID id;\r\n    UCHAR tmp_data[AIRPDCAP_MAX_CAPLEN];\r\n    guint tmp_len;\r\n\r\n#ifdef AIRPDCAP_DEBUG\r\n#define MSGBUF_LEN 255\r\n    CHAR msgbuf[MSGBUF_LEN];\r\n#endif\r\n\r\n    AIRPDCAP_DEBUG_TRACE_START(\"AirPDcapPacketProcess\");\r\n\r\n    if (ctx==NULL) {\r\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapPacketProcess\", \"NULL context\", AIRPDCAP_DEBUG_LEVEL_5);\r\n        AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapPacketProcess\");\r\n        return AIRPDCAP_RET_REQ_DATA;\r\n    }\r\n    if (data==NULL || tot_len==0) {\r\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapPacketProcess\", \"NULL data or length=0\", AIRPDCAP_DEBUG_LEVEL_5);\r\n        AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapPacketProcess\");\r\n        return AIRPDCAP_RET_REQ_DATA;\r\n    }\r\n\r\n    /* check if the packet is of data or robust managment type */\r\n    if (!((AIRPDCAP_TYPE(data[0])==AIRPDCAP_TYPE_DATA) ||\r\n          (AIRPDCAP_TYPE(data[0])==AIRPDCAP_TYPE_MANAGEMENT &&\r\n           (AIRPDCAP_SUBTYPE(data[0])==AIRPDCAP_SUBTYPE_DISASS ||\r\n            AIRPDCAP_SUBTYPE(data[0])==AIRPDCAP_SUBTYPE_DEAUTHENTICATION ||\r\n            AIRPDCAP_SUBTYPE(data[0])==AIRPDCAP_SUBTYPE_ACTION)))) {\r\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapPacketProcess\", \"not data nor robust mgmt packet\", AIRPDCAP_DEBUG_LEVEL_5);\r\n        return AIRPDCAP_RET_NO_DATA;\r\n    }\r\n\r\n    /* check correct packet size, to avoid wrong elaboration of encryption algorithms */\r\n    if (tot_len < (UINT)(mac_header_len+AIRPDCAP_CRYPTED_DATA_MINLEN)) {\r\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapPacketProcess\", \"minimum length violated\", AIRPDCAP_DEBUG_LEVEL_5);\r\n        return AIRPDCAP_RET_WRONG_DATA_SIZE;\r\n    }\r\n\r\n    /* Assume that the decrypt_data field is at least this size. */\r\n    if (tot_len > AIRPDCAP_MAX_CAPLEN) {\r\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapPacketProcess\", \"length too large\", AIRPDCAP_DEBUG_LEVEL_3);\r\n        return AIRPDCAP_RET_UNSUCCESS;\r\n    }\r\n\r\n    /* get STA/BSSID address */\r\n    if (AirPDcapGetSaAddress((const AIRPDCAP_MAC_FRAME_ADDR4 *)(data), &id) != AIRPDCAP_RET_SUCCESS) {\r\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapPacketProcess\", \"STA/BSSID not found\", AIRPDCAP_DEBUG_LEVEL_5);\r\n        return AIRPDCAP_RET_REQ_DATA;\r\n    }\r\n\r\n    /* check if data is encrypted (use the WEP bit in the Frame Control field) */\r\n    if (AIRPDCAP_WEP(data[1])==0) {\r\n        if (scanHandshake) {\r\n            /* data is sent in cleartext, check if is an authentication message or end the process */\r\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapPacketProcess\", \"Unencrypted data\", AIRPDCAP_DEBUG_LEVEL_3);\r\n            return (AirPDcapScanForKeys(ctx, data, mac_header_len, tot_len, id));\r\n        }\r\n        return AIRPDCAP_RET_NO_DATA_ENCRYPTED;\r\n    } else {\r\n        PAIRPDCAP_SEC_ASSOCIATION sa;\r\n        int offset = 0;\r\n\r\n        /* get the Security Association structure for the STA and AP */\r\n        sa = AirPDcapGetSaPtr(ctx, &id);\r\n        if (sa == NULL){\r\n            return AIRPDCAP_RET_REQ_DATA;\r\n        }\r\n\r\n        /* cache offset in the packet data (to scan encryption data) */\r\n        offset = mac_header_len;\r\n\r\n        if (decrypt_data==NULL) {\r\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapPacketProcess\", \"no decrypt buffer, use local\", AIRPDCAP_DEBUG_LEVEL_3);\r\n            decrypt_data=tmp_data;\r\n            decrypt_len=&tmp_len;\r\n        }\r\n\r\n        /* create new header and data to modify */\r\n        *decrypt_len = tot_len;\r\n        memcpy(decrypt_data, data, *decrypt_len);\r\n\r\n        /* encrypted data */\r\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapPacketProcess\", \"Encrypted data\", AIRPDCAP_DEBUG_LEVEL_3);\r\n\r\n        /* check the Extension IV to distinguish between WEP encryption and WPA encryption */\r\n        /* refer to IEEE 802.11i-2004, 8.2.1.2, pag.35 for WEP,    */\r\n        /*          IEEE 802.11i-2004, 8.3.2.2, pag. 45 for TKIP,  */\r\n        /*          IEEE 802.11i-2004, 8.3.3.2, pag. 57 for CCMP   */\r\n        if (AIRPDCAP_EXTIV(data[offset+3])==0) {\r\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapPacketProcess\", \"WEP encryption\", AIRPDCAP_DEBUG_LEVEL_3);\r\n            return AirPDcapWepMng(ctx, decrypt_data, mac_header_len, decrypt_len, key, sa, offset);\r\n        } else {\r\n            AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapPacketProcess\", \"TKIP or CCMP encryption\", AIRPDCAP_DEBUG_LEVEL_3);\r\n\r\n            /* If index >= 1, then use the group key.  This will not work if the AP is using\r\n               more than one group key simultaneously.  I've not seen this in practice, however.\r\n               Usually an AP will rotate between the two key index values of 1 and 2 whenever\r\n               it needs to change the group key to be used. */\r\n            if (AIRPDCAP_KEY_INDEX(data[offset+3])>=1){\r\n\r\n                AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapPacketProcess\", \"The key index >= 1. This is encrypted with a group key.\", AIRPDCAP_DEBUG_LEVEL_3);\r\n\r\n                /* force STA address to broadcast MAC so we load the SA for the groupkey */\r\n                memcpy(id.sta, broadcast_mac, AIRPDCAP_MAC_LEN);\r\n\r\n#ifdef AIRPDCAP_DEBUG\r\n                g_snprintf(msgbuf, MSGBUF_LEN, \"ST_MAC: %2X.%2X.%2X.%2X.%2X.%2X\\t\", id.sta[0],id.sta[1],id.sta[2],id.sta[3],id.sta[4],id.sta[5]);\r\n                AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapPacketProcess\", msgbuf, AIRPDCAP_DEBUG_LEVEL_3);\r\n#endif\r\n\r\n                /* search for a cached Security Association for current BSSID and broadcast MAC */\r\n                sa = AirPDcapGetSaPtr(ctx, &id);\r\n                if (sa == NULL)\r\n                    return AIRPDCAP_RET_REQ_DATA;\r\n            }\r\n\r\n            /* Decrypt the packet using the appropriate SA */\r\n            if (AirPDcapRsnaMng(decrypt_data, mac_header_len, decrypt_len, key, sa, offset) == AIRPDCAP_RET_SUCCESS) {\r\n                /* If we successfully decrypted a packet, scan it to see if it contains a key handshake.\r\n                   The group key handshake could be sent at any time the AP wants to change the key (such as when\r\n                   it is using key rotation) and it also could be a rekey for the Pairwise key. So we must scan every packet. */\r\n                if (scanHandshake) {\r\n                    return (AirPDcapScanForKeys(ctx, decrypt_data, mac_header_len, *decrypt_len, id));\r\n                } else {\r\n                    return AIRPDCAP_RET_SUCCESS;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return AIRPDCAP_RET_UNSUCCESS;\r\n}", ".irPDcapInitContext": "INT AirPDcapInitContext(\r\n    PAIRPDCAP_CONTEXT ctx)\r\n{\r\n    AIRPDCAP_DEBUG_TRACE_START(\"AirPDcapInitContext\");\r\n\r\n    if (ctx==NULL) {\r\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapInitContext\", \"NULL context\", AIRPDCAP_DEBUG_LEVEL_5);\r\n        AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapInitContext\");\r\n        return AIRPDCAP_RET_UNSUCCESS;\r\n    }\r\n\r\n    AirPDcapCleanKeys(ctx);\r\n\r\n    ctx->first_free_index=0;\r\n    ctx->index=-1;\r\n    ctx->sa_index=-1;\r\n    ctx->pkt_ssid_len = 0;\r\n\r\n    memset(ctx->sa, 0, AIRPDCAP_MAX_SEC_ASSOCIATIONS_NR * sizeof(AIRPDCAP_SEC_ASSOCIATION));\r\n\r\n    AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapInitContext\", \"Context initialized!\", AIRPDCAP_DEBUG_LEVEL_5);\r\n    AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapInitContext\");\r\n    return AIRPDCAP_RET_SUCCESS;\r\n}", ".irPDcapDestroyContext": "INT AirPDcapDestroyContext(\r\n    PAIRPDCAP_CONTEXT ctx)\r\n{\r\n    AIRPDCAP_DEBUG_TRACE_START(\"AirPDcapDestroyContext\");\r\n\r\n    if (ctx==NULL) {\r\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapDestroyContext\", \"NULL context\", AIRPDCAP_DEBUG_LEVEL_5);\r\n        AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapDestroyContext\");\r\n        return AIRPDCAP_RET_UNSUCCESS;\r\n    }\r\n\r\n    AirPDcapCleanKeys(ctx);\r\n    AirPDcapCleanSecAssoc(ctx);\r\n\r\n    ctx->first_free_index=0;\r\n    ctx->index=-1;\r\n    ctx->sa_index=-1;\r\n\r\n    AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapDestroyContext\", \"Context destroyed!\", AIRPDCAP_DEBUG_LEVEL_5);\r\n    AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapDestroyContext\");\r\n    return AIRPDCAP_RET_SUCCESS;\r\n}", ".irPDcapCleanSecAssoc": "static void\r\nAirPDcapCleanSecAssoc(\r\n    PAIRPDCAP_CONTEXT ctx)\r\n{\r\n    PAIRPDCAP_SEC_ASSOCIATION psa;\r\n    int i;\r\n\r\n    for (psa = ctx->sa, i = 0; i < AIRPDCAP_MAX_SEC_ASSOCIATIONS_NR; i++, psa++) {\r\n        /* To iterate is human, to recurse, divine */\r\n        AirPDcapRecurseCleanSA(psa);\r\n    }\r\n}", ".irPDcapSetKeys": "INT AirPDcapSetKeys(\r\n    PAIRPDCAP_CONTEXT ctx,\r\n    AIRPDCAP_KEY_ITEM keys[],\r\n    const size_t keys_nr)\r\n{\r\n    INT i;\r\n    INT success;\r\n    AIRPDCAP_DEBUG_TRACE_START(\"AirPDcapSetKeys\");\r\n\r\n    if (ctx==NULL || keys==NULL) {\r\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapSetKeys\", \"NULL context or NULL keys array\", AIRPDCAP_DEBUG_LEVEL_3);\r\n        AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapSetKeys\");\r\n        return 0;\r\n    }\r\n\r\n    if (keys_nr>AIRPDCAP_MAX_KEYS_NR) {\r\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapSetKeys\", \"Keys number greater than maximum\", AIRPDCAP_DEBUG_LEVEL_3);\r\n        AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapSetKeys\");\r\n        return 0;\r\n    }\r\n\r\n    /* clean key and SA collections before setting new ones */\r\n    AirPDcapInitContext(ctx);\r\n\r\n    /* check and insert keys */\r\n    for (i=0, success=0; i<(INT)keys_nr; i++) {\r\n        if (AirPDcapValidateKey(keys+i)==TRUE) {\r\n            if (keys[i].KeyType==AIRPDCAP_KEY_TYPE_WPA_PWD) {\r\n                AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapSetKeys\", \"Set a WPA-PWD key\", AIRPDCAP_DEBUG_LEVEL_4);\r\n                AirPDcapRsnaPwd2Psk(keys[i].UserPwd.Passphrase, keys[i].UserPwd.Ssid, keys[i].UserPwd.SsidLen, keys[i].KeyData.Wpa.Psk);\r\n            }\r\n#ifdef AIRPDCAP_DEBUG\r\n            else if (keys[i].KeyType==AIRPDCAP_KEY_TYPE_WPA_PMK) {\r\n                AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapSetKeys\", \"Set a WPA-PMK key\", AIRPDCAP_DEBUG_LEVEL_4);\r\n            } else if (keys[i].KeyType==AIRPDCAP_KEY_TYPE_WEP) {\r\n                AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapSetKeys\", \"Set a WEP key\", AIRPDCAP_DEBUG_LEVEL_4);\r\n            } else {\r\n                AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapSetKeys\", \"Set a key\", AIRPDCAP_DEBUG_LEVEL_4);\r\n            }\r\n#endif\r\n            memcpy(&ctx->keys[success], &keys[i], sizeof(keys[i]));\r\n            success++;\r\n        }\r\n    }\r\n\r\n    ctx->keys_nr=success;\r\n\r\n    AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapSetKeys\");\r\n    return success;\r\n}", ".irPDcapGetSaPtr": "static PAIRPDCAP_SEC_ASSOCIATION\r\nAirPDcapGetSaPtr(\r\n    PAIRPDCAP_CONTEXT ctx,\r\n    AIRPDCAP_SEC_ASSOCIATION_ID *id)\r\n{\r\n    int sa_index;\r\n\r\n    /* search for a cached Security Association for supplied BSSID and STA MAC  */\r\n    if ((sa_index=AirPDcapGetSa(ctx, id))==-1) {\r\n        /* create a new Security Association if it doesn't currently exist      */\r\n        if ((sa_index=AirPDcapStoreSa(ctx, id))==-1) {\r\n            return NULL;\r\n        }\r\n    }\r\n    /* get the Security Association structure   */\r\n    return &ctx->sa[sa_index];\r\n}", ".irPDcapRsnaPwd2Psk": "static INT\r\nAirPDcapRsnaPwd2Psk(\r\n    const CHAR *passphrase,\r\n    const CHAR *ssid,\r\n    const size_t ssidLength,\r\n    UCHAR *output)\r\n{\r\n    UCHAR m_output[40] = { 0 };\r\n    GByteArray *pp_ba = g_byte_array_new();\r\n\r\n    if (!uri_str_to_bytes(passphrase, pp_ba)) {\r\n        g_byte_array_free(pp_ba, TRUE);\r\n        return 0;\r\n    }\r\n\r\n    AirPDcapRsnaPwd2PskStep(pp_ba->data, pp_ba->len, ssid, ssidLength, 4096, 1, m_output);\r\n    AirPDcapRsnaPwd2PskStep(pp_ba->data, pp_ba->len, ssid, ssidLength, 4096, 2, &m_output[20]);\r\n\r\n    memcpy(output, m_output, AIRPDCAP_WPA_PSK_LEN);\r\n    g_byte_array_free(pp_ba, TRUE);\r\n\r\n    return 0;\r\n}"}, "function_name": "AirPDcapTDLSDeriveKey"}
{"function_id": null, "caller": {".heck_notify_received": "static bool check_notify_received(const notification_t *n) /* {{{ */\r\n{\r\n  for (notification_meta_t *ptr = n->meta; ptr != NULL; ptr = ptr->next)\r\n    if ((strcmp(\"network:received\", ptr->name) == 0) &&\r\n        (ptr->type == NM_TYPE_BOOLEAN))\r\n      return (bool)ptr->nm_value.nm_boolean;\r\n\r\n  return 0;\r\n}", ".heck_receive_okay": "static bool check_receive_okay(const value_list_t *vl) /* {{{ */\r\n{\r\n  uint64_t time_sent = 0;\r\n  int status;\r\n\r\n  status = uc_meta_data_get_unsigned_int(vl, \"network:time_sent\", &time_sent);\r\n\r\n  /* This is a value we already sent. Don't allow it to be received again in\r\n   * order to avoid looping. */\r\n  if ((status == 0) && (time_sent >= ((uint64_t)vl->time)))\r\n    return 0;\r\n\r\n  return 1;\r\n}", ".arse_packet": "static int parse_packet(sockent_t *se, /* {{{ */\r\n                        void *buffer, size_t buffer_size, int flags,\r\n                        const char *username,\r\n                        struct sockaddr_storage *address) {\r\n  int status;\r\n\r\n  value_list_t vl = VALUE_LIST_INIT;\r\n  notification_t n = {0};\r\n\r\n#if HAVE_GCRYPT_H\r\n  int packet_was_signed = (flags & PP_SIGNED);\r\n  int packet_was_encrypted = (flags & PP_ENCRYPTED);\r\n  int printed_ignore_warning = 0;\r\n#endif /* HAVE_GCRYPT_H */\r\n\r\n  memset(&vl, '\\0', sizeof(vl));\r\n  status = 0;\r\n\r\n  while ((status == 0) && (0 < buffer_size) &&\r\n         ((unsigned int)buffer_size > sizeof(part_header_t))) {\r\n    uint16_t pkg_length;\r\n    uint16_t pkg_type;\r\n\r\n    memcpy((void *)&pkg_type, (void *)buffer, sizeof(pkg_type));\r\n    memcpy((void *)&pkg_length, (void *)(((char *)buffer) + sizeof(pkg_type)),\r\n           sizeof(pkg_length));\r\n\r\n    pkg_length = ntohs(pkg_length);\r\n    pkg_type = ntohs(pkg_type);\r\n\r\n    if (pkg_length > buffer_size)\r\n      break;\r\n    /* Ensure that this loop terminates eventually */\r\n    if (pkg_length < (2 * sizeof(uint16_t)))\r\n      break;\r\n\r\n    if (pkg_type == TYPE_ENCR_AES256) {\r\n      status =\r\n          parse_part_encr_aes256(se, &buffer, &buffer_size, flags, address);\r\n      if (status != 0) {\r\n        ERROR(\"network plugin: Decrypting AES256 \"\r\n              \"part failed \"\r\n              \"with status %i.\",\r\n              status);\r\n        break;\r\n      }\r\n    }\r\n#if HAVE_GCRYPT_H\r\n    else if ((se->data.server.security_level == SECURITY_LEVEL_ENCRYPT) &&\r\n             (packet_was_encrypted == 0)) {\r\n      if (printed_ignore_warning == 0) {\r\n        INFO(\"network plugin: Unencrypted packet or \"\r\n             \"part has been ignored.\");\r\n        printed_ignore_warning = 1;\r\n      }\r\n      buffer = ((char *)buffer) + pkg_length;\r\n      buffer_size -= (size_t)pkg_length;\r\n      continue;\r\n    }\r\n#endif /* HAVE_GCRYPT_H */\r\n    else if (pkg_type == TYPE_SIGN_SHA256) {\r\n      status =\r\n          parse_part_sign_sha256(se, &buffer, &buffer_size, flags, address);\r\n      if (status != 0) {\r\n        ERROR(\"network plugin: Verifying HMAC-SHA-256 \"\r\n              \"signature failed \"\r\n              \"with status %i.\",\r\n              status);\r\n        break;\r\n      }\r\n    }\r\n#if HAVE_GCRYPT_H\r\n    else if ((se->data.server.security_level == SECURITY_LEVEL_SIGN) &&\r\n             (packet_was_encrypted == 0) && (packet_was_signed == 0)) {\r\n      if (printed_ignore_warning == 0) {\r\n        INFO(\"network plugin: Unsigned packet or \"\r\n             \"part has been ignored.\");\r\n        printed_ignore_warning = 1;\r\n      }\r\n      buffer = ((char *)buffer) + pkg_length;\r\n      buffer_size -= (size_t)pkg_length;\r\n      continue;\r\n    }\r\n#endif /* HAVE_GCRYPT_H */\r\n    else if (pkg_type == TYPE_VALUES) {\r\n      status =\r\n          parse_part_values(&buffer, &buffer_size, &vl.values, &vl.values_len);\r\n      if (status != 0)\r\n        break;\r\n\r\n      network_dispatch_values(&vl, username, address);\r\n\r\n      sfree(vl.values);\r\n    } else if (pkg_type == TYPE_TIME) {\r\n      uint64_t tmp = 0;\r\n      status = parse_part_number(&buffer, &buffer_size, &tmp);\r\n      if (status == 0) {\r\n        vl.time = TIME_T_TO_CDTIME_T(tmp);\r\n        n.time = TIME_T_TO_CDTIME_T(tmp);\r\n      }\r\n    } else if (pkg_type == TYPE_TIME_HR) {\r\n      uint64_t tmp = 0;\r\n      status = parse_part_number(&buffer, &buffer_size, &tmp);\r\n      if (status == 0) {\r\n        vl.time = (cdtime_t)tmp;\r\n        n.time = (cdtime_t)tmp;\r\n      }\r\n    } else if (pkg_type == TYPE_INTERVAL) {\r\n      uint64_t tmp = 0;\r\n      status = parse_part_number(&buffer, &buffer_size, &tmp);\r\n      if (status == 0)\r\n        vl.interval = TIME_T_TO_CDTIME_T(tmp);\r\n    } else if (pkg_type == TYPE_INTERVAL_HR) {\r\n      uint64_t tmp = 0;\r\n      status = parse_part_number(&buffer, &buffer_size, &tmp);\r\n      if (status == 0)\r\n        vl.interval = (cdtime_t)tmp;\r\n    } else if (pkg_type == TYPE_HOST) {\r\n      status =\r\n          parse_part_string(&buffer, &buffer_size, vl.host, sizeof(vl.host));\r\n      if (status == 0)\r\n        sstrncpy(n.host, vl.host, sizeof(n.host));\r\n    } else if (pkg_type == TYPE_PLUGIN) {\r\n      status = parse_part_string(&buffer, &buffer_size, vl.plugin,\r\n                                 sizeof(vl.plugin));\r\n      if (status == 0)\r\n        sstrncpy(n.plugin, vl.plugin, sizeof(n.plugin));\r\n    } else if (pkg_type == TYPE_PLUGIN_INSTANCE) {\r\n      status = parse_part_string(&buffer, &buffer_size, vl.plugin_instance,\r\n                                 sizeof(vl.plugin_instance));\r\n      if (status == 0)\r\n        sstrncpy(n.plugin_instance, vl.plugin_instance,\r\n                 sizeof(n.plugin_instance));\r\n    } else if (pkg_type == TYPE_TYPE) {\r\n      status =\r\n          parse_part_string(&buffer, &buffer_size, vl.type, sizeof(vl.type));\r\n      if (status == 0)\r\n        sstrncpy(n.type, vl.type, sizeof(n.type));\r\n    } else if (pkg_type == TYPE_TYPE_INSTANCE) {\r\n      status = parse_part_string(&buffer, &buffer_size, vl.type_instance,\r\n                                 sizeof(vl.type_instance));\r\n      if (status == 0)\r\n        sstrncpy(n.type_instance, vl.type_instance, sizeof(n.type_instance));\r\n    } else if (pkg_type == TYPE_MESSAGE) {\r\n      status = parse_part_string(&buffer, &buffer_size, n.message,\r\n                                 sizeof(n.message));\r\n\r\n      if (status != 0) {\r\n        /* do nothing */\r\n      } else if ((n.severity != NOTIF_FAILURE) &&\r\n                 (n.severity != NOTIF_WARNING) && (n.severity != NOTIF_OKAY)) {\r\n        INFO(\"network plugin: \"\r\n             \"Ignoring notification with \"\r\n             \"unknown severity %i.\",\r\n             n.severity);\r\n      } else if (n.time == 0) {\r\n        INFO(\"network plugin: \"\r\n             \"Ignoring notification with \"\r\n             \"time == 0.\");\r\n      } else if (strlen(n.message) == 0) {\r\n        INFO(\"network plugin: \"\r\n             \"Ignoring notification with \"\r\n             \"an empty message.\");\r\n      } else {\r\n        network_dispatch_notification(&n);\r\n      }\r\n    } else if (pkg_type == TYPE_SEVERITY) {\r\n      uint64_t tmp = 0;\r\n      status = parse_part_number(&buffer, &buffer_size, &tmp);\r\n      if (status == 0)\r\n        n.severity = (int)tmp;\r\n    } else {\r\n      DEBUG(\"network plugin: parse_packet: Unknown part\"\r\n            \" type: 0x%04hx\",\r\n            pkg_type);\r\n      buffer = ((char *)buffer) + pkg_length;\r\n      buffer_size -= (size_t)pkg_length;\r\n    }\r\n  } /* while (buffer_size > sizeof (part_header_t)) */\r\n\r\n  if (status == 0 && buffer_size > 0)\r\n    WARNING(\"network plugin: parse_packet: Received truncated \"\r\n            \"packet, try increasing `MaxPacketSize'\");\r\n\r\n  return status;\r\n}", ".etwork_get_aes256_cypher": "static gcry_cipher_hd_t network_get_aes256_cypher(sockent_t *se, /* {{{ */\r\n                                                  const void *iv,\r\n                                                  size_t iv_size,\r\n                                                  const char *username) {\r\n  gcry_error_t err;\r\n  gcry_cipher_hd_t *cyper_ptr;\r\n  unsigned char password_hash[32];\r\n\r\n  if (se->type == SOCKENT_TYPE_CLIENT) {\r\n    cyper_ptr = &se->data.client.cypher;\r\n    memcpy(password_hash, se->data.client.password_hash, sizeof(password_hash));\r\n  } else {\r\n    char *secret;\r\n\r\n    cyper_ptr = &se->data.server.cypher;\r\n\r\n    if (username == NULL)\r\n      return NULL;\r\n\r\n    secret = fbh_get(se->data.server.userdb, username);\r\n    if (secret == NULL)\r\n      return NULL;\r\n\r\n    gcry_md_hash_buffer(GCRY_MD_SHA256, password_hash, secret, strlen(secret));\r\n\r\n    sfree(secret);\r\n  }\r\n\r\n  if (*cyper_ptr == NULL) {\r\n    err = gcry_cipher_open(cyper_ptr, GCRY_CIPHER_AES256, GCRY_CIPHER_MODE_OFB,\r\n                           /* flags = */ 0);\r\n    if (err != 0) {\r\n      ERROR(\"network plugin: gcry_cipher_open returned: %s\",\r\n            gcry_strerror(err));\r\n      *cyper_ptr = NULL;\r\n      return NULL;\r\n    }\r\n  } else {\r\n    gcry_cipher_reset(*cyper_ptr);\r\n  }\r\n  assert(*cyper_ptr != NULL);\r\n\r\n  err = gcry_cipher_setkey(*cyper_ptr, password_hash, sizeof(password_hash));\r\n  if (err != 0) {\r\n    ERROR(\"network plugin: gcry_cipher_setkey returned: %s\",\r\n          gcry_strerror(err));\r\n    gcry_cipher_close(*cyper_ptr);\r\n    *cyper_ptr = NULL;\r\n    return NULL;\r\n  }\r\n\r\n  err = gcry_cipher_setiv(*cyper_ptr, iv, iv_size);\r\n  if (err != 0) {\r\n    ERROR(\"network plugin: gcry_cipher_setkey returned: %s\",\r\n          gcry_strerror(err));\r\n    gcry_cipher_close(*cyper_ptr);\r\n    *cyper_ptr = NULL;\r\n    return NULL;\r\n  }\r\n\r\n  return *cyper_ptr;\r\n}", ".arse_part_encr_aes256": "static int parse_part_encr_aes256(sockent_t *se, /* {{{ */\r\n                                  void **ret_buffer, size_t *ret_buffer_len,\r\n                                  int flags, struct sockaddr_storage *sender) {\r\n  char *buffer = *ret_buffer;\r\n  size_t buffer_len = *ret_buffer_len;\r\n  size_t payload_len;\r\n  size_t part_size;\r\n  size_t buffer_offset;\r\n  uint16_t username_len;\r\n  part_encryption_aes256_t pea;\r\n  unsigned char hash[sizeof(pea.hash)] = {0};\r\n\r\n  gcry_cipher_hd_t cypher;\r\n  gcry_error_t err;\r\n\r\n  /* Make sure at least the header if available. */\r\n  if (buffer_len <= PART_ENCRYPTION_AES256_SIZE) {\r\n    NOTICE(\"network plugin: parse_part_encr_aes256: \"\r\n           \"Discarding short packet.\");\r\n    return -1;\r\n  }\r\n\r\n  buffer_offset = 0;\r\n\r\n  /* Copy the unencrypted information into `pea'. */\r\n  BUFFER_READ(&pea.head.type, sizeof(pea.head.type));\r\n  BUFFER_READ(&pea.head.length, sizeof(pea.head.length));\r\n\r\n  /* Check the `part size'. */\r\n  part_size = ntohs(pea.head.length);\r\n  if ((part_size <= PART_ENCRYPTION_AES256_SIZE) || (part_size > buffer_len)) {\r\n    NOTICE(\"network plugin: parse_part_encr_aes256: \"\r\n           \"Discarding part with invalid size.\");\r\n    return -1;\r\n  }\r\n\r\n  /* Read the username */\r\n  BUFFER_READ(&username_len, sizeof(username_len));\r\n  username_len = ntohs(username_len);\r\n\r\n  if ((username_len == 0) ||\r\n      (username_len > (part_size - (PART_ENCRYPTION_AES256_SIZE + 1)))) {\r\n    NOTICE(\"network plugin: parse_part_encr_aes256: \"\r\n           \"Discarding part with invalid username length.\");\r\n    return -1;\r\n  }\r\n\r\n  assert(username_len > 0);\r\n  pea.username = malloc(username_len + 1);\r\n  if (pea.username == NULL)\r\n    return -ENOMEM;\r\n  BUFFER_READ(pea.username, username_len);\r\n  pea.username[username_len] = 0;\r\n\r\n  /* Last but not least, the initialization vector */\r\n  BUFFER_READ(pea.iv, sizeof(pea.iv));\r\n\r\n  /* Make sure we are at the right position */\r\n  assert(buffer_offset ==\r\n         (username_len + PART_ENCRYPTION_AES256_SIZE - sizeof(pea.hash)));\r\n\r\n  cypher = network_get_aes256_cypher(se, pea.iv, sizeof(pea.iv), pea.username);\r\n  if (cypher == NULL) {\r\n    ERROR(\"network plugin: Failed to get cypher. Username: %s\", pea.username);\r\n    sfree(pea.username);\r\n    return -1;\r\n  }\r\n\r\n  payload_len = part_size - (PART_ENCRYPTION_AES256_SIZE + username_len);\r\n  assert(payload_len > 0);\r\n\r\n  /* Decrypt the packet in-place */\r\n  err = gcry_cipher_decrypt(cypher, buffer + buffer_offset,\r\n                            part_size - buffer_offset,\r\n                            /* in = */ NULL, /* in len = */ 0);\r\n  if (err != 0) {\r\n    ERROR(\"network plugin: gcry_cipher_decrypt returned: %s. Username: %s\",\r\n          gcry_strerror(err), pea.username);\r\n    sfree(pea.username);\r\n    return -1;\r\n  }\r\n\r\n  /* Read the hash */\r\n  BUFFER_READ(pea.hash, sizeof(pea.hash));\r\n\r\n  /* Make sure we're at the right position - again */\r\n  assert(buffer_offset == (username_len + PART_ENCRYPTION_AES256_SIZE));\r\n  assert(buffer_offset == (part_size - payload_len));\r\n\r\n  /* Check hash sum */\r\n  gcry_md_hash_buffer(GCRY_MD_SHA1, hash, buffer + buffer_offset, payload_len);\r\n  if (memcmp(hash, pea.hash, sizeof(hash)) != 0) {\r\n    ERROR(\"network plugin: Checksum mismatch. Username: %s\", pea.username);\r\n    sfree(pea.username);\r\n    return -1;\r\n  }\r\n\r\n  parse_packet(se, buffer + buffer_offset, payload_len, flags | PP_ENCRYPTED,\r\n               pea.username, sender);\r\n\r\n  /* Update return values */\r\n  *ret_buffer = buffer + part_size;\r\n  *ret_buffer_len = buffer_len - part_size;\r\n\r\n  sfree(pea.username);\r\n\r\n  return 0;\r\n}", ".arse_part_sign_sha256": "static int parse_part_sign_sha256(sockent_t *se, /* {{{ */\r\n                                  void **ret_buffer, size_t *ret_buffer_len,\r\n                                  int flags, struct sockaddr_storage *sender) {\r\n  static c_complain_t complain_no_users = C_COMPLAIN_INIT_STATIC;\r\n\r\n  char *buffer;\r\n  size_t buffer_len;\r\n  size_t buffer_offset;\r\n\r\n  size_t username_len;\r\n  char *secret;\r\n\r\n  part_signature_sha256_t pss;\r\n  uint16_t pss_head_length;\r\n  char hash[sizeof(pss.hash)];\r\n\r\n  gcry_md_hd_t hd;\r\n  gcry_error_t err;\r\n  unsigned char *hash_ptr;\r\n\r\n  buffer = *ret_buffer;\r\n  buffer_len = *ret_buffer_len;\r\n  buffer_offset = 0;\r\n\r\n  /* Check if the buffer has enough data for this structure. */\r\n  if (buffer_len <= PART_SIGNATURE_SHA256_SIZE)\r\n    return -ENOMEM;\r\n\r\n  /* Read type and length header */\r\n  BUFFER_READ(&pss.head.type, sizeof(pss.head.type));\r\n  BUFFER_READ(&pss.head.length, sizeof(pss.head.length));\r\n  pss_head_length = ntohs(pss.head.length);\r\n\r\n  /* Check if the `pss_head_length' is within bounds. */\r\n  if ((pss_head_length <= PART_SIGNATURE_SHA256_SIZE) ||\r\n      (pss_head_length > buffer_len)) {\r\n    ERROR(\"network plugin: HMAC-SHA-256 with invalid length received.\");\r\n    return -1;\r\n  }\r\n\r\n  if (se->data.server.userdb == NULL) {\r\n    c_complain(\r\n        LOG_NOTICE, &complain_no_users,\r\n        \"network plugin: Received signed network packet but can't verify it \"\r\n        \"because no user DB has been configured. Will accept it.\");\r\n\r\n    *ret_buffer = buffer + pss_head_length;\r\n    *ret_buffer_len -= pss_head_length;\r\n\r\n    return 0;\r\n  }\r\n\r\n  /* Copy the hash. */\r\n  BUFFER_READ(pss.hash, sizeof(pss.hash));\r\n\r\n  /* Calculate username length (without null byte) and allocate memory */\r\n  username_len = pss_head_length - PART_SIGNATURE_SHA256_SIZE;\r\n  pss.username = malloc(username_len + 1);\r\n  if (pss.username == NULL)\r\n    return -ENOMEM;\r\n\r\n  /* Read the username */\r\n  BUFFER_READ(pss.username, username_len);\r\n  pss.username[username_len] = 0;\r\n\r\n  assert(buffer_offset == pss_head_length);\r\n\r\n  /* Query the password */\r\n  secret = fbh_get(se->data.server.userdb, pss.username);\r\n  if (secret == NULL) {\r\n    ERROR(\"network plugin: Unknown user: %s\", pss.username);\r\n    sfree(pss.username);\r\n    return -ENOENT;\r\n  }\r\n\r\n  /* Create a hash device and check the HMAC */\r\n  hd = NULL;\r\n  err = gcry_md_open(&hd, GCRY_MD_SHA256, GCRY_MD_FLAG_HMAC);\r\n  if (err != 0) {\r\n    ERROR(\"network plugin: Creating HMAC-SHA-256 object failed: %s\",\r\n          gcry_strerror(err));\r\n    sfree(secret);\r\n    sfree(pss.username);\r\n    return -1;\r\n  }\r\n\r\n  err = gcry_md_setkey(hd, secret, strlen(secret));\r\n  if (err != 0) {\r\n    ERROR(\"network plugin: gcry_md_setkey failed: %s\", gcry_strerror(err));\r\n    gcry_md_close(hd);\r\n    sfree(secret);\r\n    sfree(pss.username);\r\n    return -1;\r\n  }\r\n\r\n  gcry_md_write(hd, buffer + PART_SIGNATURE_SHA256_SIZE,\r\n                buffer_len - PART_SIGNATURE_SHA256_SIZE);\r\n  hash_ptr = gcry_md_read(hd, GCRY_MD_SHA256);\r\n  if (hash_ptr == NULL) {\r\n    ERROR(\"network plugin: gcry_md_read failed.\");\r\n    gcry_md_close(hd);\r\n    sfree(secret);\r\n    sfree(pss.username);\r\n    return -1;\r\n  }\r\n  memcpy(hash, hash_ptr, sizeof(hash));\r\n\r\n  /* Clean up */\r\n  gcry_md_close(hd);\r\n  hd = NULL;\r\n\r\n  if (memcmp(pss.hash, hash, sizeof(pss.hash)) != 0) {\r\n    WARNING(\"network plugin: Verifying HMAC-SHA-256 signature failed: \"\r\n            \"Hash mismatch. Username: %s\",\r\n            pss.username);\r\n  } else {\r\n    parse_packet(se, buffer + buffer_offset, buffer_len - buffer_offset,\r\n                 flags | PP_SIGNED, pss.username, sender);\r\n  }\r\n\r\n  sfree(secret);\r\n  sfree(pss.username);\r\n\r\n  *ret_buffer = buffer + buffer_len;\r\n  *ret_buffer_len = 0;\r\n\r\n  return 0;\r\n}", ".arse_part_values": "static int parse_part_values(void **ret_buffer, size_t *ret_buffer_len,\r\n                             value_t **ret_values, size_t *ret_num_values) {\r\n  char *buffer = *ret_buffer;\r\n  size_t buffer_len = *ret_buffer_len;\r\n\r\n  uint16_t tmp16;\r\n  size_t exp_size;\r\n\r\n  uint16_t pkg_length;\r\n  uint16_t pkg_type;\r\n  size_t pkg_numval;\r\n\r\n  uint8_t *pkg_types;\r\n  value_t *pkg_values;\r\n\r\n  if (buffer_len < 15) {\r\n    NOTICE(\"network plugin: packet is too short: \"\r\n           \"buffer_len = %\" PRIsz,\r\n           buffer_len);\r\n    return -1;\r\n  }\r\n\r\n  memcpy((void *)&tmp16, buffer, sizeof(tmp16));\r\n  buffer += sizeof(tmp16);\r\n  pkg_type = ntohs(tmp16);\r\n\r\n  memcpy((void *)&tmp16, buffer, sizeof(tmp16));\r\n  buffer += sizeof(tmp16);\r\n  pkg_length = ntohs(tmp16);\r\n\r\n  memcpy((void *)&tmp16, buffer, sizeof(tmp16));\r\n  buffer += sizeof(tmp16);\r\n  pkg_numval = (size_t)ntohs(tmp16);\r\n\r\n  assert(pkg_type == TYPE_VALUES);\r\n\r\n  exp_size =\r\n      3 * sizeof(uint16_t) + pkg_numval * (sizeof(uint8_t) + sizeof(value_t));\r\n  if (buffer_len < exp_size) {\r\n    WARNING(\"network plugin: parse_part_values: \"\r\n            \"Packet too short: \"\r\n            \"Chunk of size %\" PRIsz \" expected, \"\r\n            \"but buffer has only %\" PRIsz \" bytes left.\",\r\n            exp_size, buffer_len);\r\n    return -1;\r\n  }\r\n  assert(pkg_numval <= ((buffer_len - 6) / 9));\r\n\r\n  if (pkg_length != exp_size) {\r\n    WARNING(\"network plugin: parse_part_values: \"\r\n            \"Length and number of values \"\r\n            \"in the packet don't match.\");\r\n    return -1;\r\n  }\r\n\r\n  pkg_types = calloc(pkg_numval, sizeof(*pkg_types));\r\n  pkg_values = calloc(pkg_numval, sizeof(*pkg_values));\r\n  if ((pkg_types == NULL) || (pkg_values == NULL)) {\r\n    sfree(pkg_types);\r\n    sfree(pkg_values);\r\n    ERROR(\"network plugin: parse_part_values: calloc failed.\");\r\n    return -1;\r\n  }\r\n\r\n  memcpy(pkg_types, buffer, pkg_numval * sizeof(*pkg_types));\r\n  buffer += pkg_numval * sizeof(*pkg_types);\r\n  memcpy(pkg_values, buffer, pkg_numval * sizeof(*pkg_values));\r\n  buffer += pkg_numval * sizeof(*pkg_values);\r\n\r\n  for (size_t i = 0; i < pkg_numval; i++) {\r\n    switch (pkg_types[i]) {\r\n    case DS_TYPE_COUNTER:\r\n      pkg_values[i].counter = (counter_t)ntohll(pkg_values[i].counter);\r\n      break;\r\n\r\n    case DS_TYPE_GAUGE:\r\n      pkg_values[i].gauge = (gauge_t)ntohd(pkg_values[i].gauge);\r\n      break;\r\n\r\n    case DS_TYPE_DERIVE:\r\n      pkg_values[i].derive = (derive_t)ntohll(pkg_values[i].derive);\r\n      break;\r\n\r\n    case DS_TYPE_ABSOLUTE:\r\n      pkg_values[i].absolute = (absolute_t)ntohll(pkg_values[i].absolute);\r\n      break;\r\n\r\n    default:\r\n      NOTICE(\"network plugin: parse_part_values: \"\r\n             \"Don't know how to handle data source type %\" PRIu8,\r\n             pkg_types[i]);\r\n      sfree(pkg_types);\r\n      sfree(pkg_values);\r\n      return -1;\r\n    } /* switch (pkg_types[i]) */\r\n  }\r\n\r\n  *ret_buffer = buffer;\r\n  *ret_buffer_len = buffer_len - pkg_length;\r\n  *ret_num_values = pkg_numval;\r\n  *ret_values = pkg_values;\r\n\r\n  sfree(pkg_types);\r\n\r\n  return 0;\r\n}", ".etwork_dispatch_values": "static int network_dispatch_values(value_list_t *vl, /* {{{ */\r\n                                   const char *username,\r\n                                   struct sockaddr_storage *address) {\r\n  int status;\r\n\r\n  if ((vl->time == 0) || (strlen(vl->host) == 0) || (strlen(vl->plugin) == 0) ||\r\n      (strlen(vl->type) == 0))\r\n    return -EINVAL;\r\n\r\n  if (!check_receive_okay(vl)) {\r\n#if COLLECT_DEBUG\r\n    char name[6 * DATA_MAX_NAME_LEN];\r\n    FORMAT_VL(name, sizeof(name), vl);\r\n    name[sizeof(name) - 1] = '\\0';\r\n    DEBUG(\"network plugin: network_dispatch_values: \"\r\n          \"NOT dispatching %s.\",\r\n          name);\r\n#endif\r\n    stats_values_not_dispatched++;\r\n    return 0;\r\n  }\r\n\r\n  assert(vl->meta == NULL);\r\n\r\n  vl->meta = meta_data_create();\r\n  if (vl->meta == NULL) {\r\n    ERROR(\"network plugin: meta_data_create failed.\");\r\n    return -ENOMEM;\r\n  }\r\n\r\n  status = meta_data_add_boolean(vl->meta, \"network:received\", 1);\r\n  if (status != 0) {\r\n    ERROR(\"network plugin: meta_data_add_boolean failed.\");\r\n    meta_data_destroy(vl->meta);\r\n    vl->meta = NULL;\r\n    return status;\r\n  }\r\n\r\n  if (username != NULL) {\r\n    status = meta_data_add_string(vl->meta, \"network:username\", username);\r\n    if (status != 0) {\r\n      ERROR(\"network plugin: meta_data_add_string failed.\");\r\n      meta_data_destroy(vl->meta);\r\n      vl->meta = NULL;\r\n      return status;\r\n    }\r\n  }\r\n\r\n  if (address != NULL) {\r\n    char host[48];\r\n    size_t len = sizeof(struct sockaddr_storage);\r\n\r\n#ifdef __NetBSD__\r\n    if (address->ss_family == AF_INET) {\r\n      len = sizeof(struct sockaddr_in);\r\n    } else if (address->ss_family == AF_INET6) {\r\n      len = sizeof(struct sockaddr_in6);\r\n    }\r\n#endif\r\n\r\n    status = getnameinfo((struct sockaddr *)address, len, host, sizeof(host),\r\n                         NULL, 0, NI_NUMERICHOST | NI_NUMERICSERV);\r\n    if (status != 0) {\r\n      ERROR(\"network plugin: getnameinfo failed: %s\", gai_strerror(status));\r\n      meta_data_destroy(vl->meta);\r\n      vl->meta = NULL;\r\n      return status;\r\n    }\r\n\r\n    status = meta_data_add_string(vl->meta, \"network:ip_address\", host);\r\n    if (status != 0) {\r\n      ERROR(\"network plugin: meta_data_add_string failed.\");\r\n      meta_data_destroy(vl->meta);\r\n      vl->meta = NULL;\r\n      return status;\r\n    }\r\n  }\r\n\r\n  plugin_dispatch_values(vl);\r\n  stats_values_dispatched++;\r\n\r\n  meta_data_destroy(vl->meta);\r\n  vl->meta = NULL;\r\n\r\n  return 0;\r\n}", ".arse_part_number": "static int parse_part_number(void **ret_buffer, size_t *ret_buffer_len,\r\n                             uint64_t *value) {\r\n  char *buffer = *ret_buffer;\r\n  size_t buffer_len = *ret_buffer_len;\r\n\r\n  uint16_t tmp16;\r\n  uint64_t tmp64;\r\n  size_t exp_size = 2 * sizeof(uint16_t) + sizeof(uint64_t);\r\n\r\n  uint16_t pkg_length;\r\n\r\n  if (buffer_len < exp_size) {\r\n    WARNING(\"network plugin: parse_part_number: \"\r\n            \"Packet too short: \"\r\n            \"Chunk of size %\" PRIsz \" expected, \"\r\n            \"but buffer has only %\" PRIsz \" bytes left.\",\r\n            exp_size, buffer_len);\r\n    return -1;\r\n  }\r\n\r\n  memcpy((void *)&tmp16, buffer, sizeof(tmp16));\r\n  buffer += sizeof(tmp16);\r\n  /* pkg_type = ntohs (tmp16); */\r\n\r\n  memcpy((void *)&tmp16, buffer, sizeof(tmp16));\r\n  buffer += sizeof(tmp16);\r\n  pkg_length = ntohs(tmp16);\r\n\r\n  memcpy((void *)&tmp64, buffer, sizeof(tmp64));\r\n  buffer += sizeof(tmp64);\r\n  *value = ntohll(tmp64);\r\n\r\n  *ret_buffer = buffer;\r\n  *ret_buffer_len = buffer_len - pkg_length;\r\n\r\n  return 0;\r\n}", ".arse_part_string": "static int parse_part_string(void **ret_buffer, size_t *ret_buffer_len,\r\n                             char *output, size_t const output_len) {\r\n  char *buffer = *ret_buffer;\r\n  size_t buffer_len = *ret_buffer_len;\r\n\r\n  uint16_t tmp16;\r\n  size_t const header_size = 2 * sizeof(uint16_t);\r\n\r\n  uint16_t pkg_length;\r\n  size_t payload_size;\r\n\r\n  if (output_len == 0)\r\n    return EINVAL;\r\n\r\n  if (buffer_len < header_size) {\r\n    WARNING(\"network plugin: parse_part_string: \"\r\n            \"Packet too short: \"\r\n            \"Chunk of at least size %\" PRIsz \" expected, \"\r\n            \"but buffer has only %\" PRIsz \" bytes left.\",\r\n            header_size, buffer_len);\r\n    return -1;\r\n  }\r\n\r\n  memcpy((void *)&tmp16, buffer, sizeof(tmp16));\r\n  buffer += sizeof(tmp16);\r\n  /* pkg_type = ntohs (tmp16); */\r\n\r\n  memcpy((void *)&tmp16, buffer, sizeof(tmp16));\r\n  buffer += sizeof(tmp16);\r\n  pkg_length = ntohs(tmp16);\r\n  payload_size = ((size_t)pkg_length) - header_size;\r\n\r\n  /* Check that packet fits in the input buffer */\r\n  if (pkg_length > buffer_len) {\r\n    WARNING(\"network plugin: parse_part_string: \"\r\n            \"Packet too big: \"\r\n            \"Chunk of size %\" PRIu16 \" received, \"\r\n            \"but buffer has only %\" PRIsz \" bytes left.\",\r\n            pkg_length, buffer_len);\r\n    return -1;\r\n  }\r\n\r\n  /* Check that pkg_length is in the valid range */\r\n  if (pkg_length <= header_size) {\r\n    WARNING(\"network plugin: parse_part_string: \"\r\n            \"Packet too short: \"\r\n            \"Header claims this packet is only %hu \"\r\n            \"bytes long.\",\r\n            pkg_length);\r\n    return -1;\r\n  }\r\n\r\n  /* Check that the package data fits into the output buffer.\r\n   * The previous if-statement ensures that:\r\n   * `pkg_length > header_size' */\r\n  if (output_len < payload_size) {\r\n    WARNING(\"network plugin: parse_part_string: \"\r\n            \"Buffer too small: \"\r\n            \"Output buffer holds %\" PRIsz \" bytes, \"\r\n            \"which is too small to hold the received \"\r\n            \"%\" PRIsz \" byte string.\",\r\n            output_len, payload_size);\r\n    return -1;\r\n  }\r\n\r\n  /* All sanity checks successfull, let's copy the data over */\r\n  memcpy((void *)output, (void *)buffer, payload_size);\r\n  buffer += payload_size;\r\n\r\n  /* For some very weird reason '\\0' doesn't do the trick on SPARC in\r\n   * this statement. */\r\n  if (output[payload_size - 1] != 0) {\r\n    WARNING(\"network plugin: parse_part_string: \"\r\n            \"Received string does not end \"\r\n            \"with a NULL-byte.\");\r\n    return -1;\r\n  }\r\n\r\n  *ret_buffer = buffer;\r\n  *ret_buffer_len = buffer_len - pkg_length;\r\n\r\n  return 0;\r\n}", ".etwork_dispatch_notification": "static int network_dispatch_notification(notification_t *n) /* {{{ */\r\n{\r\n  int status;\r\n\r\n  assert(n->meta == NULL);\r\n\r\n  status = plugin_notification_meta_add_boolean(n, \"network:received\", 1);\r\n  if (status != 0) {\r\n    ERROR(\"network plugin: plugin_notification_meta_add_boolean failed.\");\r\n    plugin_notification_meta_free(n->meta);\r\n    n->meta = NULL;\r\n    return status;\r\n  }\r\n\r\n  status = plugin_dispatch_notification(n);\r\n\r\n  plugin_notification_meta_free(n->meta);\r\n  n->meta = NULL;\r\n\r\n  return status;\r\n}", ".ree_sockent_client": "static void free_sockent_client(struct sockent_client *sec) /* {{{ */\r\n{\r\n  if (sec->fd >= 0) {\r\n    close(sec->fd);\r\n    sec->fd = -1;\r\n  }\r\n  sfree(sec->addr);\r\n  sfree(sec->bind_addr);\r\n#if HAVE_GCRYPT_H\r\n  sfree(sec->username);\r\n  sfree(sec->password);\r\n  if (sec->cypher != NULL)\r\n    gcry_cipher_close(sec->cypher);\r\n#endif\r\n}", ".ree_sockent_server": "static void free_sockent_server(struct sockent_server *ses) /* {{{ */\r\n{\r\n  for (size_t i = 0; i < ses->fd_num; i++) {\r\n    if (ses->fd[i] >= 0) {\r\n      close(ses->fd[i]);\r\n      ses->fd[i] = -1;\r\n    }\r\n  }\r\n\r\n  sfree(ses->fd);\r\n#if HAVE_GCRYPT_H\r\n  sfree(ses->auth_file);\r\n  fbh_destroy(ses->userdb);\r\n  if (ses->cypher != NULL)\r\n    gcry_cipher_close(ses->cypher);\r\n#endif\r\n}", ".etwork_init_gcrypt": "static int network_init_gcrypt(void) /* {{{ */\r\n{\r\n  gcry_error_t err;\r\n\r\n  /* http://lists.gnupg.org/pipermail/gcrypt-devel/2003-August/000458.html\r\n   * Because you can't know in a library whether another library has\r\n   * already initialized the library */\r\n  if (gcry_control(GCRYCTL_ANY_INITIALIZATION_P))\r\n    return 0;\r\n\r\n/* http://www.gnupg.org/documentation/manuals/gcrypt/Multi_002dThreading.html\r\n * To ensure thread-safety, it's important to set GCRYCTL_SET_THREAD_CBS\r\n * *before* initalizing Libgcrypt with gcry_check_version(), which itself must\r\n * be called before any other gcry_* function. GCRYCTL_ANY_INITIALIZATION_P\r\n * above doesn't count, as it doesn't implicitly initalize Libgcrypt.\r\n *\r\n * tl;dr: keep all these gry_* statements in this exact order please. */\r\n#if GCRYPT_VERSION_NUMBER < 0x010600\r\n  err = gcry_control(GCRYCTL_SET_THREAD_CBS, &gcry_threads_pthread);\r\n  if (err) {\r\n    ERROR(\"network plugin: gcry_control (GCRYCTL_SET_THREAD_CBS) failed: %s\",\r\n          gcry_strerror(err));\r\n    return -1;\r\n  }\r\n#endif\r\n\r\n  gcry_check_version(NULL);\r\n\r\n  err = gcry_control(GCRYCTL_INIT_SECMEM, 32768);\r\n  if (err) {\r\n    ERROR(\"network plugin: gcry_control (GCRYCTL_INIT_SECMEM) failed: %s\",\r\n          gcry_strerror(err));\r\n    return -1;\r\n  }\r\n\r\n  gcry_control(GCRYCTL_INITIALIZATION_FINISHED);\r\n  return 0;\r\n}", ".ockent_client_connect": "static int sockent_client_connect(sockent_t *se) /* {{{ */\r\n{\r\n  static c_complain_t complaint = C_COMPLAIN_INIT_STATIC;\r\n\r\n  struct sockent_client *client;\r\n  struct addrinfo *ai_list;\r\n  int status;\r\n  bool reconnect = false;\r\n  cdtime_t now;\r\n\r\n  if ((se == NULL) || (se->type != SOCKENT_TYPE_CLIENT))\r\n    return EINVAL;\r\n\r\n  client = &se->data.client;\r\n\r\n  now = cdtime();\r\n  if (client->resolve_interval != 0 && client->next_resolve_reconnect < now) {\r\n    DEBUG(\"network plugin: Reconnecting socket, resolve_interval = %lf, \"\r\n          \"next_resolve_reconnect = %lf\",\r\n          CDTIME_T_TO_DOUBLE(client->resolve_interval),\r\n          CDTIME_T_TO_DOUBLE(client->next_resolve_reconnect));\r\n    reconnect = true;\r\n  }\r\n\r\n  if (client->fd >= 0 && !reconnect) /* already connected and not stale*/\r\n    return 0;\r\n\r\n  struct addrinfo ai_hints = {.ai_family = AF_UNSPEC,\r\n                              .ai_flags = AI_ADDRCONFIG,\r\n                              .ai_protocol = IPPROTO_UDP,\r\n                              .ai_socktype = SOCK_DGRAM};\r\n\r\n  status = getaddrinfo(se->node,\r\n                       (se->service != NULL) ? se->service : NET_DEFAULT_PORT,\r\n                       &ai_hints, &ai_list);\r\n  if (status != 0) {\r\n    c_complain(\r\n        LOG_ERR, &complaint, \"network plugin: getaddrinfo (%s, %s) failed: %s\",\r\n        (se->node == NULL) ? \"(null)\" : se->node,\r\n        (se->service == NULL) ? \"(null)\" : se->service, gai_strerror(status));\r\n    return -1;\r\n  } else {\r\n    c_release(LOG_NOTICE, &complaint,\r\n              \"network plugin: Successfully resolved \\\"%s\\\".\", se->node);\r\n  }\r\n\r\n  for (struct addrinfo *ai_ptr = ai_list; ai_ptr != NULL;\r\n       ai_ptr = ai_ptr->ai_next) {\r\n    if (client->fd >= 0) /* when we reconnect */\r\n      sockent_client_disconnect(se);\r\n\r\n    client->fd =\r\n        socket(ai_ptr->ai_family, ai_ptr->ai_socktype, ai_ptr->ai_protocol);\r\n    if (client->fd < 0) {\r\n      ERROR(\"network plugin: socket(2) failed: %s\", STRERRNO);\r\n      continue;\r\n    }\r\n\r\n    client->addr = calloc(1, sizeof(*client->addr));\r\n    if (client->addr == NULL) {\r\n      ERROR(\"network plugin: calloc failed.\");\r\n      close(client->fd);\r\n      client->fd = -1;\r\n      continue;\r\n    }\r\n    DEBUG(\"network plugin: alloc (se = %p, addr = %p);\", (void *)se,\r\n          (void *)client->addr);\r\n\r\n    assert(sizeof(*client->addr) >= ai_ptr->ai_addrlen);\r\n    memcpy(client->addr, ai_ptr->ai_addr, ai_ptr->ai_addrlen);\r\n    client->addrlen = ai_ptr->ai_addrlen;\r\n\r\n    network_set_ttl(se, ai_ptr);\r\n    network_set_interface(se, ai_ptr);\r\n    network_bind_socket_to_addr(se, ai_ptr);\r\n\r\n    /* We don't open more than one write-socket per\r\n     * node/service pair.. */\r\n    break;\r\n  }\r\n\r\n  freeaddrinfo(ai_list);\r\n  if (client->fd < 0)\r\n    return -1;\r\n\r\n  if (client->resolve_interval > 0)\r\n    client->next_resolve_reconnect = now + client->resolve_interval;\r\n  return 0;\r\n}", ".ockent_client_disconnect": "static int sockent_client_disconnect(sockent_t *se) /* {{{ */\r\n{\r\n  struct sockent_client *client;\r\n\r\n  if ((se == NULL) || (se->type != SOCKENT_TYPE_CLIENT))\r\n    return EINVAL;\r\n\r\n  client = &se->data.client;\r\n  if (client->fd >= 0) /* connected */\r\n  {\r\n    close(client->fd);\r\n    client->fd = -1;\r\n  }\r\n\r\n  DEBUG(\"network plugin: free (se = %p, addr = %p);\", (void *)se,\r\n        (void *)client->addr);\r\n  sfree(client->addr);\r\n  client->addrlen = 0;\r\n\r\n  return 0;\r\n}", ".etwork_send_buffer_plain": "static void network_send_buffer_plain(sockent_t *se, /* {{{ */\r\n                                      const char *buffer, size_t buffer_size) {\r\n  int status;\r\n\r\n  while (42) {\r\n    status = sockent_client_connect(se);\r\n    if (status != 0)\r\n      return;\r\n\r\n    status = sendto(se->data.client.fd, buffer, buffer_size,\r\n                    /* flags = */ 0, (struct sockaddr *)se->data.client.addr,\r\n                    se->data.client.addrlen);\r\n    if (status < 0) {\r\n      if ((errno == EINTR) || (errno == EAGAIN))\r\n        continue;\r\n\r\n      ERROR(\"network plugin: sendto failed: %s. Closing sending socket.\",\r\n            STRERRNO);\r\n      sockent_client_disconnect(se);\r\n      return;\r\n    }\r\n\r\n    break;\r\n  } /* while (42) */\r\n}", ".rite_part_string": "static int write_part_string(char **ret_buffer, size_t *ret_buffer_len,\r\n                             int type, const char *str, size_t str_len) {\r\n  char *buffer;\r\n  size_t buffer_len;\r\n\r\n  uint16_t pkg_type;\r\n  uint16_t pkg_length;\r\n\r\n  size_t offset;\r\n\r\n  buffer_len = 2 * sizeof(uint16_t) + str_len + 1;\r\n  if (*ret_buffer_len < buffer_len)\r\n    return -1;\r\n\r\n  pkg_type = htons(type);\r\n  pkg_length = htons(buffer_len);\r\n\r\n  buffer = *ret_buffer;\r\n  offset = 0;\r\n  memcpy(buffer + offset, (void *)&pkg_type, sizeof(pkg_type));\r\n  offset += sizeof(pkg_type);\r\n  memcpy(buffer + offset, (void *)&pkg_length, sizeof(pkg_length));\r\n  offset += sizeof(pkg_length);\r\n  memcpy(buffer + offset, str, str_len);\r\n  offset += str_len;\r\n  memset(buffer + offset, '\\0', 1);\r\n  offset += 1;\r\n\r\n  assert(offset == buffer_len);\r\n\r\n  *ret_buffer = buffer + buffer_len;\r\n  *ret_buffer_len -= buffer_len;\r\n\r\n  return 0;\r\n}", ".rite_part_number": "static int write_part_number(char **ret_buffer, size_t *ret_buffer_len,\r\n                             int type, uint64_t value) {\r\n  char *packet_ptr;\r\n  size_t packet_len;\r\n\r\n  part_header_t pkg_head;\r\n  uint64_t pkg_value;\r\n\r\n  size_t offset;\r\n\r\n  packet_len = sizeof(pkg_head) + sizeof(pkg_value);\r\n\r\n  if (*ret_buffer_len < packet_len)\r\n    return -1;\r\n\r\n  pkg_head.type = htons(type);\r\n  pkg_head.length = htons(packet_len);\r\n  pkg_value = htonll(value);\r\n\r\n  packet_ptr = *ret_buffer;\r\n  offset = 0;\r\n  memcpy(packet_ptr + offset, &pkg_head, sizeof(pkg_head));\r\n  offset += sizeof(pkg_head);\r\n  memcpy(packet_ptr + offset, &pkg_value, sizeof(pkg_value));\r\n  offset += sizeof(pkg_value);\r\n\r\n  assert(offset == packet_len);\r\n\r\n  *ret_buffer = packet_ptr + packet_len;\r\n  *ret_buffer_len -= packet_len;\r\n\r\n  return 0;\r\n}", ".rite_part_values": "static int write_part_values(char **ret_buffer, size_t *ret_buffer_len,\r\n                             const data_set_t *ds, const value_list_t *vl) {\r\n  char *packet_ptr;\r\n  size_t packet_len;\r\n  int num_values;\r\n\r\n  part_header_t pkg_ph;\r\n  uint16_t pkg_num_values;\r\n  uint8_t *pkg_values_types;\r\n  value_t *pkg_values;\r\n\r\n  size_t offset;\r\n\r\n  num_values = vl->values_len;\r\n  packet_len = sizeof(part_header_t) + sizeof(uint16_t) +\r\n               (num_values * sizeof(uint8_t)) + (num_values * sizeof(value_t));\r\n\r\n  if (*ret_buffer_len < packet_len)\r\n    return -1;\r\n\r\n  pkg_values_types = malloc(num_values * sizeof(*pkg_values_types));\r\n  if (pkg_values_types == NULL) {\r\n    ERROR(\"network plugin: write_part_values: malloc failed.\");\r\n    return -1;\r\n  }\r\n\r\n  pkg_values = malloc(num_values * sizeof(*pkg_values));\r\n  if (pkg_values == NULL) {\r\n    free(pkg_values_types);\r\n    ERROR(\"network plugin: write_part_values: malloc failed.\");\r\n    return -1;\r\n  }\r\n\r\n  pkg_ph.type = htons(TYPE_VALUES);\r\n  pkg_ph.length = htons(packet_len);\r\n\r\n  pkg_num_values = htons((uint16_t)vl->values_len);\r\n\r\n  for (int i = 0; i < num_values; i++) {\r\n    pkg_values_types[i] = (uint8_t)ds->ds[i].type;\r\n    switch (ds->ds[i].type) {\r\n    case DS_TYPE_COUNTER:\r\n      pkg_values[i].counter = htonll(vl->values[i].counter);\r\n      break;\r\n\r\n    case DS_TYPE_GAUGE:\r\n      pkg_values[i].gauge = htond(vl->values[i].gauge);\r\n      break;\r\n\r\n    case DS_TYPE_DERIVE:\r\n      pkg_values[i].derive = htonll(vl->values[i].derive);\r\n      break;\r\n\r\n    case DS_TYPE_ABSOLUTE:\r\n      pkg_values[i].absolute = htonll(vl->values[i].absolute);\r\n      break;\r\n\r\n    default:\r\n      free(pkg_values_types);\r\n      free(pkg_values);\r\n      ERROR(\"network plugin: write_part_values: \"\r\n            \"Unknown data source type: %i\",\r\n            ds->ds[i].type);\r\n      return -1;\r\n    } /* switch (ds->ds[i].type) */\r\n  }   /* for (num_values) */\r\n\r\n  /*\r\n   * Use `memcpy' to write everything to the buffer, because the pointer\r\n   * may be unaligned and some architectures, such as SPARC, can't handle\r\n   * that.\r\n   */\r\n  packet_ptr = *ret_buffer;\r\n  offset = 0;\r\n  memcpy(packet_ptr + offset, &pkg_ph, sizeof(pkg_ph));\r\n  offset += sizeof(pkg_ph);\r\n  memcpy(packet_ptr + offset, &pkg_num_values, sizeof(pkg_num_values));\r\n  offset += sizeof(pkg_num_values);\r\n  memcpy(packet_ptr + offset, pkg_values_types, num_values * sizeof(uint8_t));\r\n  offset += num_values * sizeof(uint8_t);\r\n  memcpy(packet_ptr + offset, pkg_values, num_values * sizeof(value_t));\r\n  offset += num_values * sizeof(value_t);\r\n\r\n  assert(offset == packet_len);\r\n\r\n  *ret_buffer = packet_ptr + packet_len;\r\n  *ret_buffer_len -= packet_len;\r\n\r\n  free(pkg_values_types);\r\n  free(pkg_values);\r\n\r\n  return 0;\r\n}", ".etwork_send_buffer": "static void network_send_buffer(char *buffer, size_t buffer_len) /* {{{ */\r\n{\r\n  DEBUG(\"network plugin: network_send_buffer: buffer_len = %\" PRIsz,\r\n        buffer_len);\r\n\r\n  for (sockent_t *se = sending_sockets; se != NULL; se = se->next) {\r\n    pthread_mutex_lock(&se->lock);\r\n#if HAVE_GCRYPT_H\r\n    if (se->data.client.security_level == SECURITY_LEVEL_ENCRYPT)\r\n      network_send_buffer_encrypted(se, buffer, buffer_len);\r\n    else if (se->data.client.security_level == SECURITY_LEVEL_SIGN)\r\n      network_send_buffer_signed(se, buffer, buffer_len);\r\n    else /* if (se->data.client.security_level == SECURITY_LEVEL_NONE) */\r\n#endif   /* HAVE_GCRYPT_H */\r\n      network_send_buffer_plain(se, buffer, buffer_len);\r\n    pthread_mutex_unlock(&se->lock);\r\n  } /* for (sending_sockets) */\r\n}", ".etwork_init_buffer": "static void network_init_buffer(void) {\r\n  memset(send_buffer, 0, network_config_packet_size);\r\n  send_buffer_ptr = send_buffer;\r\n  send_buffer_fill = 0;\r\n  send_buffer_last_update = 0;\r\n\r\n  memset(&send_buffer_vl, 0, sizeof(send_buffer_vl));\r\n}", ".heck_send_okay": "static bool check_send_okay(const value_list_t *vl) /* {{{ */\r\n{\r\n  bool received = 0;\r\n  int status;\r\n\r\n  if (network_config_forward)\r\n    return 1;\r\n\r\n  if (vl->meta == NULL)\r\n    return 1;\r\n\r\n  status = meta_data_get_boolean(vl->meta, \"network:received\", &received);\r\n  if (status == -ENOENT)\r\n    return 1;\r\n  else if (status != 0) {\r\n    ERROR(\"network plugin: check_send_okay: meta_data_get_boolean failed \"\r\n          \"with status %i.\",\r\n          status);\r\n    return 1;\r\n  }\r\n\r\n  /* By default, only *send* value lists that were not *received* by the\r\n   * network plugin. */\r\n  return !received;\r\n}", ".dd_to_buffer": "static int add_to_buffer(char *buffer, size_t buffer_size, /* {{{ */\r\n                         value_list_t *vl_def, const data_set_t *ds,\r\n                         const value_list_t *vl) {\r\n  char *buffer_orig = buffer;\r\n\r\n  if (strcmp(vl_def->host, vl->host) != 0) {\r\n    if (write_part_string(&buffer, &buffer_size, TYPE_HOST, vl->host,\r\n                          strlen(vl->host)) != 0)\r\n      return -1;\r\n    sstrncpy(vl_def->host, vl->host, sizeof(vl_def->host));\r\n  }\r\n\r\n  if (vl_def->time != vl->time) {\r\n    if (write_part_number(&buffer, &buffer_size, TYPE_TIME_HR,\r\n                          (uint64_t)vl->time))\r\n      return -1;\r\n    vl_def->time = vl->time;\r\n  }\r\n\r\n  if (vl_def->interval != vl->interval) {\r\n    if (write_part_number(&buffer, &buffer_size, TYPE_INTERVAL_HR,\r\n                          (uint64_t)vl->interval))\r\n      return -1;\r\n    vl_def->interval = vl->interval;\r\n  }\r\n\r\n  if (strcmp(vl_def->plugin, vl->plugin) != 0) {\r\n    if (write_part_string(&buffer, &buffer_size, TYPE_PLUGIN, vl->plugin,\r\n                          strlen(vl->plugin)) != 0)\r\n      return -1;\r\n    sstrncpy(vl_def->plugin, vl->plugin, sizeof(vl_def->plugin));\r\n  }\r\n\r\n  if (strcmp(vl_def->plugin_instance, vl->plugin_instance) != 0) {\r\n    if (write_part_string(&buffer, &buffer_size, TYPE_PLUGIN_INSTANCE,\r\n                          vl->plugin_instance,\r\n                          strlen(vl->plugin_instance)) != 0)\r\n      return -1;\r\n    sstrncpy(vl_def->plugin_instance, vl->plugin_instance,\r\n             sizeof(vl_def->plugin_instance));\r\n  }\r\n\r\n  if (strcmp(vl_def->type, vl->type) != 0) {\r\n    if (write_part_string(&buffer, &buffer_size, TYPE_TYPE, vl->type,\r\n                          strlen(vl->type)) != 0)\r\n      return -1;\r\n    sstrncpy(vl_def->type, ds->type, sizeof(vl_def->type));\r\n  }\r\n\r\n  if (strcmp(vl_def->type_instance, vl->type_instance) != 0) {\r\n    if (write_part_string(&buffer, &buffer_size, TYPE_TYPE_INSTANCE,\r\n                          vl->type_instance, strlen(vl->type_instance)) != 0)\r\n      return -1;\r\n    sstrncpy(vl_def->type_instance, vl->type_instance,\r\n             sizeof(vl_def->type_instance));\r\n  }\r\n\r\n  if (write_part_values(&buffer, &buffer_size, ds, vl) != 0)\r\n    return -1;\r\n\r\n  return buffer - buffer_orig;\r\n}", ".lush_buffer": "static void flush_buffer(void) {\r\n  DEBUG(\"network plugin: flush_buffer: send_buffer_fill = %i\",\r\n        send_buffer_fill);\r\n\r\n  network_send_buffer(send_buffer, (size_t)send_buffer_fill);\r\n\r\n  stats_octets_tx += ((uint64_t)send_buffer_fill);\r\n  stats_packets_tx++;\r\n\r\n  network_init_buffer();\r\n}", ".ockent_destroy": "static void sockent_destroy(sockent_t *se) /* {{{ */\r\n{\r\n  sockent_t *next;\r\n\r\n  DEBUG(\"network plugin: sockent_destroy (se = %p);\", (void *)se);\r\n\r\n  while (se != NULL) {\r\n    next = se->next;\r\n\r\n    sfree(se->node);\r\n    sfree(se->service);\r\n    pthread_mutex_destroy(&se->lock);\r\n\r\n    if (se->type == SOCKENT_TYPE_CLIENT)\r\n      free_sockent_client(&se->data.client);\r\n    else\r\n      free_sockent_server(&se->data.server);\r\n\r\n    sfree(se);\r\n    se = next;\r\n  }\r\n}", ".ockent_init_crypto": "static int sockent_init_crypto(sockent_t *se) /* {{{ */\r\n{\r\n#if HAVE_GCRYPT_H /* {{{ */\r\n  if (se->type == SOCKENT_TYPE_CLIENT) {\r\n    if (se->data.client.security_level > SECURITY_LEVEL_NONE) {\r\n      if (network_init_gcrypt() < 0) {\r\n        ERROR(\"network plugin: Cannot configure client socket with \"\r\n              \"security: Failed to initialize crypto library.\");\r\n        return -1;\r\n      }\r\n\r\n      if ((se->data.client.username == NULL) ||\r\n          (se->data.client.password == NULL)) {\r\n        ERROR(\"network plugin: Client socket with \"\r\n              \"security requested, but no \"\r\n              \"credentials are configured.\");\r\n        return -1;\r\n      }\r\n      gcry_md_hash_buffer(GCRY_MD_SHA256, se->data.client.password_hash,\r\n                          se->data.client.password,\r\n                          strlen(se->data.client.password));\r\n    }\r\n  } else /* (se->type == SOCKENT_TYPE_SERVER) */\r\n  {\r\n    if ((se->data.server.security_level > SECURITY_LEVEL_NONE) &&\r\n        (se->data.server.auth_file == NULL)) {\r\n      ERROR(\"network plugin: Server socket with security requested, \"\r\n            \"but no \\\"AuthFile\\\" is configured.\");\r\n      return -1;\r\n    }\r\n    if (se->data.server.auth_file != NULL) {\r\n      if (network_init_gcrypt() < 0) {\r\n        ERROR(\"network plugin: Cannot configure server socket with security: \"\r\n              \"Failed to initialize crypto library.\");\r\n        return -1;\r\n      }\r\n\r\n      se->data.server.userdb = fbh_create(se->data.server.auth_file);\r\n      if (se->data.server.userdb == NULL) {\r\n        ERROR(\"network plugin: Reading password file \\\"%s\\\" failed.\",\r\n              se->data.server.auth_file);\r\n        return -1;\r\n      }\r\n    }\r\n  }\r\n#endif /* }}} HAVE_GCRYPT_H */\r\n\r\n  return 0;\r\n}", ".ockent_server_listen": "static int sockent_server_listen(sockent_t *se) /* {{{ */\r\n{\r\n  struct addrinfo *ai_list;\r\n  int status;\r\n\r\n  const char *node;\r\n  const char *service;\r\n\r\n  if (se == NULL)\r\n    return -1;\r\n\r\n  assert(se->data.server.fd == NULL);\r\n  assert(se->data.server.fd_num == 0);\r\n\r\n  node = se->node;\r\n  service = se->service;\r\n\r\n  if (service == NULL)\r\n    service = NET_DEFAULT_PORT;\r\n\r\n  DEBUG(\"network plugin: sockent_server_listen: node = %s; service = %s;\", node,\r\n        service);\r\n\r\n  struct addrinfo ai_hints = {.ai_family = AF_UNSPEC,\r\n                              .ai_flags = AI_ADDRCONFIG | AI_PASSIVE,\r\n                              .ai_protocol = IPPROTO_UDP,\r\n                              .ai_socktype = SOCK_DGRAM};\r\n\r\n  status = getaddrinfo(node, service, &ai_hints, &ai_list);\r\n  if (status != 0) {\r\n    ERROR(\"network plugin: getaddrinfo (%s, %s) failed: %s\",\r\n          (se->node == NULL) ? \"(null)\" : se->node,\r\n          (se->service == NULL) ? \"(null)\" : se->service, gai_strerror(status));\r\n    return -1;\r\n  }\r\n\r\n  for (struct addrinfo *ai_ptr = ai_list; ai_ptr != NULL;\r\n       ai_ptr = ai_ptr->ai_next) {\r\n    int *tmp;\r\n\r\n    tmp = realloc(se->data.server.fd,\r\n                  sizeof(*tmp) * (se->data.server.fd_num + 1));\r\n    if (tmp == NULL) {\r\n      ERROR(\"network plugin: realloc failed.\");\r\n      continue;\r\n    }\r\n    se->data.server.fd = tmp;\r\n    tmp = se->data.server.fd + se->data.server.fd_num;\r\n\r\n    *tmp = socket(ai_ptr->ai_family, ai_ptr->ai_socktype, ai_ptr->ai_protocol);\r\n    if (*tmp < 0) {\r\n      ERROR(\"network plugin: socket(2) failed: %s\", STRERRNO);\r\n      continue;\r\n    }\r\n\r\n    status = network_bind_socket(*tmp, ai_ptr, se->interface);\r\n    if (status != 0) {\r\n      close(*tmp);\r\n      *tmp = -1;\r\n      continue;\r\n    }\r\n\r\n    se->data.server.fd_num++;\r\n    continue;\r\n  } /* for (ai_list) */\r\n\r\n  freeaddrinfo(ai_list);\r\n\r\n  if (se->data.server.fd_num == 0)\r\n    return -1;\r\n  return 0;\r\n}", ".ockent_add": "static int sockent_add(sockent_t *se) /* {{{ */\r\n{\r\n  sockent_t *last_ptr;\r\n\r\n  if (se == NULL)\r\n    return -1;\r\n\r\n  if (se->type == SOCKENT_TYPE_SERVER) {\r\n    struct pollfd *tmp;\r\n\r\n    tmp = realloc(listen_sockets_pollfd,\r\n                  sizeof(*tmp) * (listen_sockets_num + se->data.server.fd_num));\r\n    if (tmp == NULL) {\r\n      ERROR(\"network plugin: realloc failed.\");\r\n      return -1;\r\n    }\r\n    listen_sockets_pollfd = tmp;\r\n    tmp = listen_sockets_pollfd + listen_sockets_num;\r\n\r\n    for (size_t i = 0; i < se->data.server.fd_num; i++) {\r\n      memset(tmp + i, 0, sizeof(*tmp));\r\n      tmp[i].fd = se->data.server.fd[i];\r\n      tmp[i].events = POLLIN | POLLPRI;\r\n      tmp[i].revents = 0;\r\n    }\r\n\r\n    listen_sockets_num += se->data.server.fd_num;\r\n\r\n    if (listen_sockets == NULL) {\r\n      listen_sockets = se;\r\n      return 0;\r\n    }\r\n    last_ptr = listen_sockets;\r\n  } else /* if (se->type == SOCKENT_TYPE_CLIENT) */\r\n  {\r\n    if (sending_sockets == NULL) {\r\n      sending_sockets = se;\r\n      return 0;\r\n    }\r\n    last_ptr = sending_sockets;\r\n  }\r\n\r\n  while (last_ptr->next != NULL)\r\n    last_ptr = last_ptr->next;\r\n  last_ptr->next = se;\r\n\r\n  return 0;\r\n}", ".heck_send_notify_okay": "static bool check_send_notify_okay(const notification_t *n) /* {{{ */\r\n{\r\n  static c_complain_t complain_forwarding = C_COMPLAIN_INIT_STATIC;\r\n  bool received = 0;\r\n\r\n  if (n->meta == NULL)\r\n    return 1;\r\n\r\n  received = check_notify_received(n);\r\n\r\n  if (network_config_forward && received) {\r\n    c_complain_once(\r\n        LOG_ERR, &complain_forwarding,\r\n        \"network plugin: A notification has been received via the network \"\r\n        \"and forwarding is enabled. Forwarding of notifications is currently \"\r\n        \"not supported, because there is not loop-detection available. \"\r\n        \"Please contact the collectd mailing list if you need this \"\r\n        \"feature.\");\r\n  }\r\n\r\n  /* By default, only *send* value lists that were not *received* by the\r\n   * network plugin. */\r\n  return !received;\r\n}", ".etwork_stats_read": "static int network_stats_read(void) /* {{{ */\r\n{\r\n  derive_t copy_octets_rx;\r\n  derive_t copy_octets_tx;\r\n  derive_t copy_packets_rx;\r\n  derive_t copy_packets_tx;\r\n  derive_t copy_values_dispatched;\r\n  derive_t copy_values_not_dispatched;\r\n  derive_t copy_values_sent;\r\n  derive_t copy_values_not_sent;\r\n  derive_t copy_receive_list_length;\r\n  value_list_t vl = VALUE_LIST_INIT;\r\n  value_t values[2];\r\n\r\n  copy_octets_rx = stats_octets_rx;\r\n  copy_octets_tx = stats_octets_tx;\r\n  copy_packets_rx = stats_packets_rx;\r\n  copy_packets_tx = stats_packets_tx;\r\n  copy_values_dispatched = stats_values_dispatched;\r\n  copy_values_not_dispatched = stats_values_not_dispatched;\r\n  copy_values_sent = stats_values_sent;\r\n  copy_values_not_sent = stats_values_not_sent;\r\n  copy_receive_list_length = receive_list_length;\r\n\r\n  /* Initialize `vl' */\r\n  vl.values = values;\r\n  vl.values_len = 2;\r\n  vl.time = 0;\r\n  sstrncpy(vl.plugin, \"network\", sizeof(vl.plugin));\r\n\r\n  /* Octets received / sent */\r\n  vl.values[0].derive = (derive_t)copy_octets_rx;\r\n  vl.values[1].derive = (derive_t)copy_octets_tx;\r\n  sstrncpy(vl.type, \"if_octets\", sizeof(vl.type));\r\n  plugin_dispatch_values(&vl);\r\n\r\n  /* Packets received / send */\r\n  vl.values[0].derive = (derive_t)copy_packets_rx;\r\n  vl.values[1].derive = (derive_t)copy_packets_tx;\r\n  sstrncpy(vl.type, \"if_packets\", sizeof(vl.type));\r\n  plugin_dispatch_values(&vl);\r\n\r\n  /* Values (not) dispatched and (not) send */\r\n  sstrncpy(vl.type, \"total_values\", sizeof(vl.type));\r\n  vl.values_len = 1;\r\n\r\n  vl.values[0].derive = (derive_t)copy_values_dispatched;\r\n  sstrncpy(vl.type_instance, \"dispatch-accepted\", sizeof(vl.type_instance));\r\n  plugin_dispatch_values(&vl);\r\n\r\n  vl.values[0].derive = (derive_t)copy_values_not_dispatched;\r\n  sstrncpy(vl.type_instance, \"dispatch-rejected\", sizeof(vl.type_instance));\r\n  plugin_dispatch_values(&vl);\r\n\r\n  vl.values[0].derive = (derive_t)copy_values_sent;\r\n  sstrncpy(vl.type_instance, \"send-accepted\", sizeof(vl.type_instance));\r\n  plugin_dispatch_values(&vl);\r\n\r\n  vl.values[0].derive = (derive_t)copy_values_not_sent;\r\n  sstrncpy(vl.type_instance, \"send-rejected\", sizeof(vl.type_instance));\r\n  plugin_dispatch_values(&vl);\r\n\r\n  /* Receive queue length */\r\n  vl.values[0].gauge = (gauge_t)copy_receive_list_length;\r\n  sstrncpy(vl.type, \"queue_length\", sizeof(vl.type));\r\n  vl.type_instance[0] = 0;\r\n  plugin_dispatch_values(&vl);\r\n\r\n  return 0;\r\n}", ".etwork_shutdown": "static int network_shutdown(void) {\r\n  listen_loop++;\r\n\r\n  /* Kill the listening thread */\r\n  if (receive_thread_running != 0) {\r\n    INFO(\"network plugin: Stopping receive thread.\");\r\n    pthread_kill(receive_thread_id, SIGTERM);\r\n    pthread_join(receive_thread_id, NULL /* no return value */);\r\n    memset(&receive_thread_id, 0, sizeof(receive_thread_id));\r\n    receive_thread_running = 0;\r\n  }\r\n\r\n  /* Shutdown the dispatching thread */\r\n  if (dispatch_thread_running != 0) {\r\n    INFO(\"network plugin: Stopping dispatch thread.\");\r\n    pthread_mutex_lock(&receive_list_lock);\r\n    pthread_cond_broadcast(&receive_list_cond);\r\n    pthread_mutex_unlock(&receive_list_lock);\r\n    pthread_join(dispatch_thread_id, /* ret = */ NULL);\r\n    dispatch_thread_running = 0;\r\n  }\r\n\r\n  sockent_destroy(listen_sockets);\r\n\r\n  if (send_buffer_fill > 0)\r\n    flush_buffer();\r\n\r\n  sfree(send_buffer);\r\n\r\n  for (sockent_t *se = sending_sockets; se != NULL; se = se->next)\r\n    sockent_client_disconnect(se);\r\n  sockent_destroy(sending_sockets);\r\n\r\n  plugin_unregister_config(\"network\");\r\n  plugin_unregister_init(\"network\");\r\n  plugin_unregister_write(\"network\");\r\n  plugin_unregister_shutdown(\"network\");\r\n\r\n  return 0;\r\n}", ".etwork_write": "static int network_write(const data_set_t *ds, const value_list_t *vl,\r\n                         user_data_t __attribute__((unused)) * user_data) {\r\n  int status;\r\n\r\n  /* listen_loop is set to non-zero in the shutdown callback, which is\r\n   * guaranteed to be called *after* all the write threads have been shut\r\n   * down. */\r\n  assert(listen_loop == 0);\r\n\r\n  if (!check_send_okay(vl)) {\r\n#if COLLECT_DEBUG\r\n    char name[6 * DATA_MAX_NAME_LEN];\r\n    FORMAT_VL(name, sizeof(name), vl);\r\n    name[sizeof(name) - 1] = '\\0';\r\n    DEBUG(\"network plugin: network_write: \"\r\n          \"NOT sending %s.\",\r\n          name);\r\n#endif\r\n    /* Counter is not protected by another lock and may be reached by\r\n     * multiple threads */\r\n    pthread_mutex_lock(&stats_lock);\r\n    stats_values_not_sent++;\r\n    pthread_mutex_unlock(&stats_lock);\r\n    return 0;\r\n  }\r\n\r\n  uc_meta_data_add_unsigned_int(vl, \"network:time_sent\", (uint64_t)vl->time);\r\n\r\n  pthread_mutex_lock(&send_buffer_lock);\r\n\r\n  status = add_to_buffer(send_buffer_ptr,\r\n                         network_config_packet_size -\r\n                             (send_buffer_fill + BUFF_SIG_SIZE),\r\n                         &send_buffer_vl, ds, vl);\r\n  if (status >= 0) {\r\n    /* status == bytes added to the buffer */\r\n    send_buffer_fill += status;\r\n    send_buffer_ptr += status;\r\n    send_buffer_last_update = cdtime();\r\n\r\n    stats_values_sent++;\r\n  } else {\r\n    flush_buffer();\r\n\r\n    status = add_to_buffer(send_buffer_ptr,\r\n                           network_config_packet_size -\r\n                               (send_buffer_fill + BUFF_SIG_SIZE),\r\n                           &send_buffer_vl, ds, vl);\r\n\r\n    if (status >= 0) {\r\n      send_buffer_fill += status;\r\n      send_buffer_ptr += status;\r\n\r\n      stats_values_sent++;\r\n    }\r\n  }\r\n\r\n  if (status < 0) {\r\n    ERROR(\"network plugin: Unable to append to the \"\r\n          \"buffer for some weird reason\");\r\n  } else if ((network_config_packet_size - send_buffer_fill) < 15) {\r\n    flush_buffer();\r\n  }\r\n\r\n  pthread_mutex_unlock(&send_buffer_lock);\r\n\r\n  return (status < 0) ? -1 : 0;\r\n}", ".etwork_notification": "static int network_notification(const notification_t *n,\r\n                                user_data_t __attribute__((unused)) *\r\n                                    user_data) {\r\n  char buffer[network_config_packet_size];\r\n  char *buffer_ptr = buffer;\r\n  size_t buffer_free = sizeof(buffer);\r\n  int status;\r\n\r\n  if (!check_send_notify_okay(n))\r\n    return 0;\r\n\r\n  memset(buffer, 0, sizeof(buffer));\r\n\r\n  status = write_part_number(&buffer_ptr, &buffer_free, TYPE_TIME_HR,\r\n                             (uint64_t)n->time);\r\n  if (status != 0)\r\n    return -1;\r\n\r\n  status = write_part_number(&buffer_ptr, &buffer_free, TYPE_SEVERITY,\r\n                             (uint64_t)n->severity);\r\n  if (status != 0)\r\n    return -1;\r\n\r\n  if (strlen(n->host) > 0) {\r\n    status = write_part_string(&buffer_ptr, &buffer_free, TYPE_HOST, n->host,\r\n                               strlen(n->host));\r\n    if (status != 0)\r\n      return -1;\r\n  }\r\n\r\n  if (strlen(n->plugin) > 0) {\r\n    status = write_part_string(&buffer_ptr, &buffer_free, TYPE_PLUGIN,\r\n                               n->plugin, strlen(n->plugin));\r\n    if (status != 0)\r\n      return -1;\r\n  }\r\n\r\n  if (strlen(n->plugin_instance) > 0) {\r\n    status = write_part_string(&buffer_ptr, &buffer_free, TYPE_PLUGIN_INSTANCE,\r\n                               n->plugin_instance, strlen(n->plugin_instance));\r\n    if (status != 0)\r\n      return -1;\r\n  }\r\n\r\n  if (strlen(n->type) > 0) {\r\n    status = write_part_string(&buffer_ptr, &buffer_free, TYPE_TYPE, n->type,\r\n                               strlen(n->type));\r\n    if (status != 0)\r\n      return -1;\r\n  }\r\n\r\n  if (strlen(n->type_instance) > 0) {\r\n    status = write_part_string(&buffer_ptr, &buffer_free, TYPE_TYPE_INSTANCE,\r\n                               n->type_instance, strlen(n->type_instance));\r\n    if (status != 0)\r\n      return -1;\r\n  }\r\n\r\n  status = write_part_string(&buffer_ptr, &buffer_free, TYPE_MESSAGE,\r\n                             n->message, strlen(n->message));\r\n  if (status != 0)\r\n    return -1;\r\n\r\n  network_send_buffer(buffer, sizeof(buffer) - buffer_free);\r\n\r\n  return 0;\r\n}", ".etwork_config": "static int network_config(oconfig_item_t *ci) /* {{{ */\r\n{\r\n  /* The options need to be applied first */\r\n  for (int i = 0; i < ci->children_num; i++) {\r\n    oconfig_item_t *child = ci->children + i;\r\n    if (strcasecmp(\"TimeToLive\", child->key) == 0)\r\n      network_config_set_ttl(child);\r\n  }\r\n\r\n  for (int i = 0; i < ci->children_num; i++) {\r\n    oconfig_item_t *child = ci->children + i;\r\n\r\n    if (strcasecmp(\"Listen\", child->key) == 0)\r\n      network_config_add_listen(child);\r\n    else if (strcasecmp(\"Server\", child->key) == 0)\r\n      network_config_add_server(child);\r\n    else if (strcasecmp(\"TimeToLive\", child->key) == 0) {\r\n      /* Handled earlier */\r\n    } else if (strcasecmp(\"MaxPacketSize\", child->key) == 0)\r\n      network_config_set_buffer_size(child);\r\n    else if (strcasecmp(\"Forward\", child->key) == 0)\r\n      cf_util_get_boolean(child, &network_config_forward);\r\n    else if (strcasecmp(\"ReportStats\", child->key) == 0)\r\n      cf_util_get_boolean(child, &network_config_stats);\r\n    else {\r\n      WARNING(\"network plugin: Option `%s' is not allowed here.\", child->key);\r\n    }\r\n  }\r\n\r\n  return 0;\r\n}", ".etwork_init": "static int network_init(void) {\r\n  static bool have_init;\r\n\r\n  /* Check if we were already initialized. If so, just return - there's\r\n   * nothing more to do (for now, that is). */\r\n  if (have_init)\r\n    return 0;\r\n  have_init = true;\r\n\r\n  if (network_config_stats)\r\n    plugin_register_read(\"network\", network_stats_read);\r\n\r\n  plugin_register_shutdown(\"network\", network_shutdown);\r\n\r\n  send_buffer = malloc(network_config_packet_size);\r\n  if (send_buffer == NULL) {\r\n    ERROR(\"network plugin: malloc failed.\");\r\n    return -1;\r\n  }\r\n  network_init_buffer();\r\n\r\n  /* setup socket(s) and so on */\r\n  if (sending_sockets != NULL) {\r\n    plugin_register_write(\"network\", network_write,\r\n                          /* user_data = */ NULL);\r\n    plugin_register_notification(\"network\", network_notification,\r\n                                 /* user_data = */ NULL);\r\n  }\r\n\r\n  /* If no threads need to be started, return here. */\r\n  if ((listen_sockets_num == 0) ||\r\n      ((dispatch_thread_running != 0) && (receive_thread_running != 0)))\r\n    return 0;\r\n\r\n  if (dispatch_thread_running == 0) {\r\n    int status;\r\n    status = plugin_thread_create(&dispatch_thread_id, dispatch_thread,\r\n                                  NULL /* no argument */, \"network disp\");\r\n    if (status != 0) {\r\n      ERROR(\"network: pthread_create failed: %s\", STRERRNO);\r\n    } else {\r\n      dispatch_thread_running = 1;\r\n    }\r\n  }\r\n\r\n  if (receive_thread_running == 0) {\r\n    int status;\r\n    status = plugin_thread_create(&receive_thread_id, receive_thread,\r\n                                  NULL /* no argument */, \"network recv\");\r\n    if (status != 0) {\r\n      ERROR(\"network: pthread_create failed: %s\", STRERRNO);\r\n    } else {\r\n      receive_thread_running = 1;\r\n    }\r\n  }\r\n\r\n  return 0;\r\n}", ".etwork_flush": "static int network_flush(cdtime_t timeout,\r\n                         __attribute__((unused)) const char *identifier,\r\n                         __attribute__((unused)) user_data_t *user_data) {\r\n  pthread_mutex_lock(&send_buffer_lock);\r\n\r\n  if (send_buffer_fill > 0) {\r\n    if (timeout > 0) {\r\n      cdtime_t now = cdtime();\r\n      if ((send_buffer_last_update + timeout) > now) {\r\n        pthread_mutex_unlock(&send_buffer_lock);\r\n        return 0;\r\n      }\r\n    }\r\n    flush_buffer();\r\n  }\r\n  pthread_mutex_unlock(&send_buffer_lock);\r\n\r\n  return 0;\r\n}"}, "callee": {".etwork_dispatch_values": "static int network_dispatch_values(value_list_t *vl, /* {{{ */\r\n                                   const char *username,\r\n                                   struct sockaddr_storage *address) {\r\n  int status;\r\n\r\n  if ((vl->time == 0) || (strlen(vl->host) == 0) || (strlen(vl->plugin) == 0) ||\r\n      (strlen(vl->type) == 0))\r\n    return -EINVAL;\r\n\r\n  if (!check_receive_okay(vl)) {\r\n#if COLLECT_DEBUG\r\n    char name[6 * DATA_MAX_NAME_LEN];\r\n    FORMAT_VL(name, sizeof(name), vl);\r\n    name[sizeof(name) - 1] = '\\0';\r\n    DEBUG(\"network plugin: network_dispatch_values: \"\r\n          \"NOT dispatching %s.\",\r\n          name);\r\n#endif\r\n    stats_values_not_dispatched++;\r\n    return 0;\r\n  }\r\n\r\n  assert(vl->meta == NULL);\r\n\r\n  vl->meta = meta_data_create();\r\n  if (vl->meta == NULL) {\r\n    ERROR(\"network plugin: meta_data_create failed.\");\r\n    return -ENOMEM;\r\n  }\r\n\r\n  status = meta_data_add_boolean(vl->meta, \"network:received\", 1);\r\n  if (status != 0) {\r\n    ERROR(\"network plugin: meta_data_add_boolean failed.\");\r\n    meta_data_destroy(vl->meta);\r\n    vl->meta = NULL;\r\n    return status;\r\n  }\r\n\r\n  if (username != NULL) {\r\n    status = meta_data_add_string(vl->meta, \"network:username\", username);\r\n    if (status != 0) {\r\n      ERROR(\"network plugin: meta_data_add_string failed.\");\r\n      meta_data_destroy(vl->meta);\r\n      vl->meta = NULL;\r\n      return status;\r\n    }\r\n  }\r\n\r\n  if (address != NULL) {\r\n    char host[48];\r\n    size_t len = sizeof(struct sockaddr_storage);\r\n\r\n#ifdef __NetBSD__\r\n    if (address->ss_family == AF_INET) {\r\n      len = sizeof(struct sockaddr_in);\r\n    } else if (address->ss_family == AF_INET6) {\r\n      len = sizeof(struct sockaddr_in6);\r\n    }\r\n#endif\r\n\r\n    status = getnameinfo((struct sockaddr *)address, len, host, sizeof(host),\r\n                         NULL, 0, NI_NUMERICHOST | NI_NUMERICSERV);\r\n    if (status != 0) {\r\n      ERROR(\"network plugin: getnameinfo failed: %s\", gai_strerror(status));\r\n      meta_data_destroy(vl->meta);\r\n      vl->meta = NULL;\r\n      return status;\r\n    }\r\n\r\n    status = meta_data_add_string(vl->meta, \"network:ip_address\", host);\r\n    if (status != 0) {\r\n      ERROR(\"network plugin: meta_data_add_string failed.\");\r\n      meta_data_destroy(vl->meta);\r\n      vl->meta = NULL;\r\n      return status;\r\n    }\r\n  }\r\n\r\n  plugin_dispatch_values(vl);\r\n  stats_values_dispatched++;\r\n\r\n  meta_data_destroy(vl->meta);\r\n  vl->meta = NULL;\r\n\r\n  return 0;\r\n}", ".etwork_write": "static int network_write(const data_set_t *ds, const value_list_t *vl,\r\n                         user_data_t __attribute__((unused)) * user_data) {\r\n  int status;\r\n\r\n  /* listen_loop is set to non-zero in the shutdown callback, which is\r\n   * guaranteed to be called *after* all the write threads have been shut\r\n   * down. */\r\n  assert(listen_loop == 0);\r\n\r\n  if (!check_send_okay(vl)) {\r\n#if COLLECT_DEBUG\r\n    char name[6 * DATA_MAX_NAME_LEN];\r\n    FORMAT_VL(name, sizeof(name), vl);\r\n    name[sizeof(name) - 1] = '\\0';\r\n    DEBUG(\"network plugin: network_write: \"\r\n          \"NOT sending %s.\",\r\n          name);\r\n#endif\r\n    /* Counter is not protected by another lock and may be reached by\r\n     * multiple threads */\r\n    pthread_mutex_lock(&stats_lock);\r\n    stats_values_not_sent++;\r\n    pthread_mutex_unlock(&stats_lock);\r\n    return 0;\r\n  }\r\n\r\n  uc_meta_data_add_unsigned_int(vl, \"network:time_sent\", (uint64_t)vl->time);\r\n\r\n  pthread_mutex_lock(&send_buffer_lock);\r\n\r\n  status = add_to_buffer(send_buffer_ptr,\r\n                         network_config_packet_size -\r\n                             (send_buffer_fill + BUFF_SIG_SIZE),\r\n                         &send_buffer_vl, ds, vl);\r\n  if (status >= 0) {\r\n    /* status == bytes added to the buffer */\r\n    send_buffer_fill += status;\r\n    send_buffer_ptr += status;\r\n    send_buffer_last_update = cdtime();\r\n\r\n    stats_values_sent++;\r\n  } else {\r\n    flush_buffer();\r\n\r\n    status = add_to_buffer(send_buffer_ptr,\r\n                           network_config_packet_size -\r\n                               (send_buffer_fill + BUFF_SIG_SIZE),\r\n                           &send_buffer_vl, ds, vl);\r\n\r\n    if (status >= 0) {\r\n      send_buffer_fill += status;\r\n      send_buffer_ptr += status;\r\n\r\n      stats_values_sent++;\r\n    }\r\n  }\r\n\r\n  if (status < 0) {\r\n    ERROR(\"network plugin: Unable to append to the \"\r\n          \"buffer for some weird reason\");\r\n  } else if ((network_config_packet_size - send_buffer_fill) < 15) {\r\n    flush_buffer();\r\n  }\r\n\r\n  pthread_mutex_unlock(&send_buffer_lock);\r\n\r\n  return (status < 0) ? -1 : 0;\r\n}", ".heck_send_notify_okay": "static bool check_send_notify_okay(const notification_t *n) /* {{{ */\r\n{\r\n  static c_complain_t complain_forwarding = C_COMPLAIN_INIT_STATIC;\r\n  bool received = 0;\r\n\r\n  if (n->meta == NULL)\r\n    return 1;\r\n\r\n  received = check_notify_received(n);\r\n\r\n  if (network_config_forward && received) {\r\n    c_complain_once(\r\n        LOG_ERR, &complain_forwarding,\r\n        \"network plugin: A notification has been received via the network \"\r\n        \"and forwarding is enabled. Forwarding of notifications is currently \"\r\n        \"not supported, because there is not loop-detection available. \"\r\n        \"Please contact the collectd mailing list if you need this \"\r\n        \"feature.\");\r\n  }\r\n\r\n  /* By default, only *send* value lists that were not *received* by the\r\n   * network plugin. */\r\n  return !received;\r\n}", ".etwork_notification": "static int network_notification(const notification_t *n,\r\n                                user_data_t __attribute__((unused)) *\r\n                                    user_data) {\r\n  char buffer[network_config_packet_size];\r\n  char *buffer_ptr = buffer;\r\n  size_t buffer_free = sizeof(buffer);\r\n  int status;\r\n\r\n  if (!check_send_notify_okay(n))\r\n    return 0;\r\n\r\n  memset(buffer, 0, sizeof(buffer));\r\n\r\n  status = write_part_number(&buffer_ptr, &buffer_free, TYPE_TIME_HR,\r\n                             (uint64_t)n->time);\r\n  if (status != 0)\r\n    return -1;\r\n\r\n  status = write_part_number(&buffer_ptr, &buffer_free, TYPE_SEVERITY,\r\n                             (uint64_t)n->severity);\r\n  if (status != 0)\r\n    return -1;\r\n\r\n  if (strlen(n->host) > 0) {\r\n    status = write_part_string(&buffer_ptr, &buffer_free, TYPE_HOST, n->host,\r\n                               strlen(n->host));\r\n    if (status != 0)\r\n      return -1;\r\n  }\r\n\r\n  if (strlen(n->plugin) > 0) {\r\n    status = write_part_string(&buffer_ptr, &buffer_free, TYPE_PLUGIN,\r\n                               n->plugin, strlen(n->plugin));\r\n    if (status != 0)\r\n      return -1;\r\n  }\r\n\r\n  if (strlen(n->plugin_instance) > 0) {\r\n    status = write_part_string(&buffer_ptr, &buffer_free, TYPE_PLUGIN_INSTANCE,\r\n                               n->plugin_instance, strlen(n->plugin_instance));\r\n    if (status != 0)\r\n      return -1;\r\n  }\r\n\r\n  if (strlen(n->type) > 0) {\r\n    status = write_part_string(&buffer_ptr, &buffer_free, TYPE_TYPE, n->type,\r\n                               strlen(n->type));\r\n    if (status != 0)\r\n      return -1;\r\n  }\r\n\r\n  if (strlen(n->type_instance) > 0) {\r\n    status = write_part_string(&buffer_ptr, &buffer_free, TYPE_TYPE_INSTANCE,\r\n                               n->type_instance, strlen(n->type_instance));\r\n    if (status != 0)\r\n      return -1;\r\n  }\r\n\r\n  status = write_part_string(&buffer_ptr, &buffer_free, TYPE_MESSAGE,\r\n                             n->message, strlen(n->message));\r\n  if (status != 0)\r\n    return -1;\r\n\r\n  network_send_buffer(buffer, sizeof(buffer) - buffer_free);\r\n\r\n  return 0;\r\n}", ".arse_packet": "static int parse_packet(sockent_t *se, /* {{{ */\r\n                        void *buffer, size_t buffer_size, int flags,\r\n                        const char *username,\r\n                        struct sockaddr_storage *address) {\r\n  int status;\r\n\r\n  value_list_t vl = VALUE_LIST_INIT;\r\n  notification_t n = {0};\r\n\r\n#if HAVE_GCRYPT_H\r\n  int packet_was_signed = (flags & PP_SIGNED);\r\n  int packet_was_encrypted = (flags & PP_ENCRYPTED);\r\n  int printed_ignore_warning = 0;\r\n#endif /* HAVE_GCRYPT_H */\r\n\r\n  memset(&vl, '\\0', sizeof(vl));\r\n  status = 0;\r\n\r\n  while ((status == 0) && (0 < buffer_size) &&\r\n         ((unsigned int)buffer_size > sizeof(part_header_t))) {\r\n    uint16_t pkg_length;\r\n    uint16_t pkg_type;\r\n\r\n    memcpy((void *)&pkg_type, (void *)buffer, sizeof(pkg_type));\r\n    memcpy((void *)&pkg_length, (void *)(((char *)buffer) + sizeof(pkg_type)),\r\n           sizeof(pkg_length));\r\n\r\n    pkg_length = ntohs(pkg_length);\r\n    pkg_type = ntohs(pkg_type);\r\n\r\n    if (pkg_length > buffer_size)\r\n      break;\r\n    /* Ensure that this loop terminates eventually */\r\n    if (pkg_length < (2 * sizeof(uint16_t)))\r\n      break;\r\n\r\n    if (pkg_type == TYPE_ENCR_AES256) {\r\n      status =\r\n          parse_part_encr_aes256(se, &buffer, &buffer_size, flags, address);\r\n      if (status != 0) {\r\n        ERROR(\"network plugin: Decrypting AES256 \"\r\n              \"part failed \"\r\n              \"with status %i.\",\r\n              status);\r\n        break;\r\n      }\r\n    }\r\n#if HAVE_GCRYPT_H\r\n    else if ((se->data.server.security_level == SECURITY_LEVEL_ENCRYPT) &&\r\n             (packet_was_encrypted == 0)) {\r\n      if (printed_ignore_warning == 0) {\r\n        INFO(\"network plugin: Unencrypted packet or \"\r\n             \"part has been ignored.\");\r\n        printed_ignore_warning = 1;\r\n      }\r\n      buffer = ((char *)buffer) + pkg_length;\r\n      buffer_size -= (size_t)pkg_length;\r\n      continue;\r\n    }\r\n#endif /* HAVE_GCRYPT_H */\r\n    else if (pkg_type == TYPE_SIGN_SHA256) {\r\n      status =\r\n          parse_part_sign_sha256(se, &buffer, &buffer_size, flags, address);\r\n      if (status != 0) {\r\n        ERROR(\"network plugin: Verifying HMAC-SHA-256 \"\r\n              \"signature failed \"\r\n              \"with status %i.\",\r\n              status);\r\n        break;\r\n      }\r\n    }\r\n#if HAVE_GCRYPT_H\r\n    else if ((se->data.server.security_level == SECURITY_LEVEL_SIGN) &&\r\n             (packet_was_encrypted == 0) && (packet_was_signed == 0)) {\r\n      if (printed_ignore_warning == 0) {\r\n        INFO(\"network plugin: Unsigned packet or \"\r\n             \"part has been ignored.\");\r\n        printed_ignore_warning = 1;\r\n      }\r\n      buffer = ((char *)buffer) + pkg_length;\r\n      buffer_size -= (size_t)pkg_length;\r\n      continue;\r\n    }\r\n#endif /* HAVE_GCRYPT_H */\r\n    else if (pkg_type == TYPE_VALUES) {\r\n      status =\r\n          parse_part_values(&buffer, &buffer_size, &vl.values, &vl.values_len);\r\n      if (status != 0)\r\n        break;\r\n\r\n      network_dispatch_values(&vl, username, address);\r\n\r\n      sfree(vl.values);\r\n    } else if (pkg_type == TYPE_TIME) {\r\n      uint64_t tmp = 0;\r\n      status = parse_part_number(&buffer, &buffer_size, &tmp);\r\n      if (status == 0) {\r\n        vl.time = TIME_T_TO_CDTIME_T(tmp);\r\n        n.time = TIME_T_TO_CDTIME_T(tmp);\r\n      }\r\n    } else if (pkg_type == TYPE_TIME_HR) {\r\n      uint64_t tmp = 0;\r\n      status = parse_part_number(&buffer, &buffer_size, &tmp);\r\n      if (status == 0) {\r\n        vl.time = (cdtime_t)tmp;\r\n        n.time = (cdtime_t)tmp;\r\n      }\r\n    } else if (pkg_type == TYPE_INTERVAL) {\r\n      uint64_t tmp = 0;\r\n      status = parse_part_number(&buffer, &buffer_size, &tmp);\r\n      if (status == 0)\r\n        vl.interval = TIME_T_TO_CDTIME_T(tmp);\r\n    } else if (pkg_type == TYPE_INTERVAL_HR) {\r\n      uint64_t tmp = 0;\r\n      status = parse_part_number(&buffer, &buffer_size, &tmp);\r\n      if (status == 0)\r\n        vl.interval = (cdtime_t)tmp;\r\n    } else if (pkg_type == TYPE_HOST) {\r\n      status =\r\n          parse_part_string(&buffer, &buffer_size, vl.host, sizeof(vl.host));\r\n      if (status == 0)\r\n        sstrncpy(n.host, vl.host, sizeof(n.host));\r\n    } else if (pkg_type == TYPE_PLUGIN) {\r\n      status = parse_part_string(&buffer, &buffer_size, vl.plugin,\r\n                                 sizeof(vl.plugin));\r\n      if (status == 0)\r\n        sstrncpy(n.plugin, vl.plugin, sizeof(n.plugin));\r\n    } else if (pkg_type == TYPE_PLUGIN_INSTANCE) {\r\n      status = parse_part_string(&buffer, &buffer_size, vl.plugin_instance,\r\n                                 sizeof(vl.plugin_instance));\r\n      if (status == 0)\r\n        sstrncpy(n.plugin_instance, vl.plugin_instance,\r\n                 sizeof(n.plugin_instance));\r\n    } else if (pkg_type == TYPE_TYPE) {\r\n      status =\r\n          parse_part_string(&buffer, &buffer_size, vl.type, sizeof(vl.type));\r\n      if (status == 0)\r\n        sstrncpy(n.type, vl.type, sizeof(n.type));\r\n    } else if (pkg_type == TYPE_TYPE_INSTANCE) {\r\n      status = parse_part_string(&buffer, &buffer_size, vl.type_instance,\r\n                                 sizeof(vl.type_instance));\r\n      if (status == 0)\r\n        sstrncpy(n.type_instance, vl.type_instance, sizeof(n.type_instance));\r\n    } else if (pkg_type == TYPE_MESSAGE) {\r\n      status = parse_part_string(&buffer, &buffer_size, n.message,\r\n                                 sizeof(n.message));\r\n\r\n      if (status != 0) {\r\n        /* do nothing */\r\n      } else if ((n.severity != NOTIF_FAILURE) &&\r\n                 (n.severity != NOTIF_WARNING) && (n.severity != NOTIF_OKAY)) {\r\n        INFO(\"network plugin: \"\r\n             \"Ignoring notification with \"\r\n             \"unknown severity %i.\",\r\n             n.severity);\r\n      } else if (n.time == 0) {\r\n        INFO(\"network plugin: \"\r\n             \"Ignoring notification with \"\r\n             \"time == 0.\");\r\n      } else if (strlen(n.message) == 0) {\r\n        INFO(\"network plugin: \"\r\n             \"Ignoring notification with \"\r\n             \"an empty message.\");\r\n      } else {\r\n        network_dispatch_notification(&n);\r\n      }\r\n    } else if (pkg_type == TYPE_SEVERITY) {\r\n      uint64_t tmp = 0;\r\n      status = parse_part_number(&buffer, &buffer_size, &tmp);\r\n      if (status == 0)\r\n        n.severity = (int)tmp;\r\n    } else {\r\n      DEBUG(\"network plugin: parse_packet: Unknown part\"\r\n            \" type: 0x%04hx\",\r\n            pkg_type);\r\n      buffer = ((char *)buffer) + pkg_length;\r\n      buffer_size -= (size_t)pkg_length;\r\n    }\r\n  } /* while (buffer_size > sizeof (part_header_t)) */\r\n\r\n  if (status == 0 && buffer_size > 0)\r\n    WARNING(\"network plugin: parse_packet: Received truncated \"\r\n            \"packet, try increasing `MaxPacketSize'\");\r\n\r\n  return status;\r\n}", ".ockent_init_crypto": "static int sockent_init_crypto(sockent_t *se) /* {{{ */\r\n{\r\n#if HAVE_GCRYPT_H /* {{{ */\r\n  if (se->type == SOCKENT_TYPE_CLIENT) {\r\n    if (se->data.client.security_level > SECURITY_LEVEL_NONE) {\r\n      if (network_init_gcrypt() < 0) {\r\n        ERROR(\"network plugin: Cannot configure client socket with \"\r\n              \"security: Failed to initialize crypto library.\");\r\n        return -1;\r\n      }\r\n\r\n      if ((se->data.client.username == NULL) ||\r\n          (se->data.client.password == NULL)) {\r\n        ERROR(\"network plugin: Client socket with \"\r\n              \"security requested, but no \"\r\n              \"credentials are configured.\");\r\n        return -1;\r\n      }\r\n      gcry_md_hash_buffer(GCRY_MD_SHA256, se->data.client.password_hash,\r\n                          se->data.client.password,\r\n                          strlen(se->data.client.password));\r\n    }\r\n  } else /* (se->type == SOCKENT_TYPE_SERVER) */\r\n  {\r\n    if ((se->data.server.security_level > SECURITY_LEVEL_NONE) &&\r\n        (se->data.server.auth_file == NULL)) {\r\n      ERROR(\"network plugin: Server socket with security requested, \"\r\n            \"but no \\\"AuthFile\\\" is configured.\");\r\n      return -1;\r\n    }\r\n    if (se->data.server.auth_file != NULL) {\r\n      if (network_init_gcrypt() < 0) {\r\n        ERROR(\"network plugin: Cannot configure server socket with security: \"\r\n              \"Failed to initialize crypto library.\");\r\n        return -1;\r\n      }\r\n\r\n      se->data.server.userdb = fbh_create(se->data.server.auth_file);\r\n      if (se->data.server.userdb == NULL) {\r\n        ERROR(\"network plugin: Reading password file \\\"%s\\\" failed.\",\r\n              se->data.server.auth_file);\r\n        return -1;\r\n      }\r\n    }\r\n  }\r\n#endif /* }}} HAVE_GCRYPT_H */\r\n\r\n  return 0;\r\n}", ".arse_part_encr_aes256": "static int parse_part_encr_aes256(sockent_t *se, /* {{{ */\r\n                                  void **ret_buffer, size_t *ret_buffer_len,\r\n                                  int flags, struct sockaddr_storage *sender) {\r\n  char *buffer = *ret_buffer;\r\n  size_t buffer_len = *ret_buffer_len;\r\n  size_t payload_len;\r\n  size_t part_size;\r\n  size_t buffer_offset;\r\n  uint16_t username_len;\r\n  part_encryption_aes256_t pea;\r\n  unsigned char hash[sizeof(pea.hash)] = {0};\r\n\r\n  gcry_cipher_hd_t cypher;\r\n  gcry_error_t err;\r\n\r\n  /* Make sure at least the header if available. */\r\n  if (buffer_len <= PART_ENCRYPTION_AES256_SIZE) {\r\n    NOTICE(\"network plugin: parse_part_encr_aes256: \"\r\n           \"Discarding short packet.\");\r\n    return -1;\r\n  }\r\n\r\n  buffer_offset = 0;\r\n\r\n  /* Copy the unencrypted information into `pea'. */\r\n  BUFFER_READ(&pea.head.type, sizeof(pea.head.type));\r\n  BUFFER_READ(&pea.head.length, sizeof(pea.head.length));\r\n\r\n  /* Check the `part size'. */\r\n  part_size = ntohs(pea.head.length);\r\n  if ((part_size <= PART_ENCRYPTION_AES256_SIZE) || (part_size > buffer_len)) {\r\n    NOTICE(\"network plugin: parse_part_encr_aes256: \"\r\n           \"Discarding part with invalid size.\");\r\n    return -1;\r\n  }\r\n\r\n  /* Read the username */\r\n  BUFFER_READ(&username_len, sizeof(username_len));\r\n  username_len = ntohs(username_len);\r\n\r\n  if ((username_len == 0) ||\r\n      (username_len > (part_size - (PART_ENCRYPTION_AES256_SIZE + 1)))) {\r\n    NOTICE(\"network plugin: parse_part_encr_aes256: \"\r\n           \"Discarding part with invalid username length.\");\r\n    return -1;\r\n  }\r\n\r\n  assert(username_len > 0);\r\n  pea.username = malloc(username_len + 1);\r\n  if (pea.username == NULL)\r\n    return -ENOMEM;\r\n  BUFFER_READ(pea.username, username_len);\r\n  pea.username[username_len] = 0;\r\n\r\n  /* Last but not least, the initialization vector */\r\n  BUFFER_READ(pea.iv, sizeof(pea.iv));\r\n\r\n  /* Make sure we are at the right position */\r\n  assert(buffer_offset ==\r\n         (username_len + PART_ENCRYPTION_AES256_SIZE - sizeof(pea.hash)));\r\n\r\n  cypher = network_get_aes256_cypher(se, pea.iv, sizeof(pea.iv), pea.username);\r\n  if (cypher == NULL) {\r\n    ERROR(\"network plugin: Failed to get cypher. Username: %s\", pea.username);\r\n    sfree(pea.username);\r\n    return -1;\r\n  }\r\n\r\n  payload_len = part_size - (PART_ENCRYPTION_AES256_SIZE + username_len);\r\n  assert(payload_len > 0);\r\n\r\n  /* Decrypt the packet in-place */\r\n  err = gcry_cipher_decrypt(cypher, buffer + buffer_offset,\r\n                            part_size - buffer_offset,\r\n                            /* in = */ NULL, /* in len = */ 0);\r\n  if (err != 0) {\r\n    ERROR(\"network plugin: gcry_cipher_decrypt returned: %s. Username: %s\",\r\n          gcry_strerror(err), pea.username);\r\n    sfree(pea.username);\r\n    return -1;\r\n  }\r\n\r\n  /* Read the hash */\r\n  BUFFER_READ(pea.hash, sizeof(pea.hash));\r\n\r\n  /* Make sure we're at the right position - again */\r\n  assert(buffer_offset == (username_len + PART_ENCRYPTION_AES256_SIZE));\r\n  assert(buffer_offset == (part_size - payload_len));\r\n\r\n  /* Check hash sum */\r\n  gcry_md_hash_buffer(GCRY_MD_SHA1, hash, buffer + buffer_offset, payload_len);\r\n  if (memcmp(hash, pea.hash, sizeof(hash)) != 0) {\r\n    ERROR(\"network plugin: Checksum mismatch. Username: %s\", pea.username);\r\n    sfree(pea.username);\r\n    return -1;\r\n  }\r\n\r\n  parse_packet(se, buffer + buffer_offset, payload_len, flags | PP_ENCRYPTED,\r\n               pea.username, sender);\r\n\r\n  /* Update return values */\r\n  *ret_buffer = buffer + part_size;\r\n  *ret_buffer_len = buffer_len - part_size;\r\n\r\n  sfree(pea.username);\r\n\r\n  return 0;\r\n}", ".etwork_send_buffer_encrypted": "static void network_send_buffer_encrypted(sockent_t *se, /* {{{ */\r\n                                          const char *in_buffer,\r\n                                          size_t in_buffer_size) {\r\n  char buffer[BUFF_SIG_SIZE + in_buffer_size];\r\n  size_t buffer_size;\r\n  size_t buffer_offset;\r\n  size_t header_size;\r\n  size_t username_len;\r\n  gcry_error_t err;\r\n  gcry_cipher_hd_t cypher;\r\n\r\n  /* Initialize the header fields */\r\n  part_encryption_aes256_t pea = {.head.type = htons(TYPE_ENCR_AES256),\r\n                                  .username = se->data.client.username};\r\n\r\n  username_len = strlen(pea.username);\r\n  if ((PART_ENCRYPTION_AES256_SIZE + username_len) > BUFF_SIG_SIZE) {\r\n    ERROR(\"network plugin: Username too long: %s\", pea.username);\r\n    return;\r\n  }\r\n\r\n  buffer_size = PART_ENCRYPTION_AES256_SIZE + username_len + in_buffer_size;\r\n  header_size = PART_ENCRYPTION_AES256_SIZE + username_len - sizeof(pea.hash);\r\n\r\n  assert(buffer_size <= sizeof(buffer));\r\n  DEBUG(\"network plugin: network_send_buffer_encrypted: \"\r\n        \"buffer_size = %\" PRIsz \";\",\r\n        buffer_size);\r\n\r\n  pea.head.length = htons(\r\n      (uint16_t)(PART_ENCRYPTION_AES256_SIZE + username_len + in_buffer_size));\r\n  pea.username_length = htons((uint16_t)username_len);\r\n\r\n  /* Chose a random initialization vector. */\r\n  gcry_randomize((void *)&pea.iv, sizeof(pea.iv), GCRY_STRONG_RANDOM);\r\n\r\n  /* Create hash of the payload */\r\n  gcry_md_hash_buffer(GCRY_MD_SHA1, pea.hash, in_buffer, in_buffer_size);\r\n\r\n  /* Initialize the buffer */\r\n  buffer_offset = 0;\r\n  memset(buffer, 0, sizeof(buffer));\r\n\r\n  BUFFER_ADD(&pea.head.type, sizeof(pea.head.type));\r\n  BUFFER_ADD(&pea.head.length, sizeof(pea.head.length));\r\n  BUFFER_ADD(&pea.username_length, sizeof(pea.username_length));\r\n  BUFFER_ADD(pea.username, username_len);\r\n  BUFFER_ADD(pea.iv, sizeof(pea.iv));\r\n  assert(buffer_offset == header_size);\r\n  BUFFER_ADD(pea.hash, sizeof(pea.hash));\r\n  BUFFER_ADD(in_buffer, in_buffer_size);\r\n\r\n  assert(buffer_offset == buffer_size);\r\n\r\n  cypher = network_get_aes256_cypher(se, pea.iv, sizeof(pea.iv),\r\n                                     se->data.client.password);\r\n  if (cypher == NULL)\r\n    return;\r\n\r\n  /* Encrypt the buffer in-place */\r\n  err = gcry_cipher_encrypt(cypher, buffer + header_size,\r\n                            buffer_size - header_size,\r\n                            /* in = */ NULL, /* in len = */ 0);\r\n  if (err != 0) {\r\n    ERROR(\"network plugin: gcry_cipher_encrypt returned: %s\",\r\n          gcry_strerror(err));\r\n    return;\r\n  }\r\n\r\n  /* Send it out without further modifications */\r\n  network_send_buffer_plain(se, buffer, buffer_size);\r\n}", ".dd_to_buffer": "static int add_to_buffer(char *buffer, size_t buffer_size, /* {{{ */\r\n                         value_list_t *vl_def, const data_set_t *ds,\r\n                         const value_list_t *vl) {\r\n  char *buffer_orig = buffer;\r\n\r\n  if (strcmp(vl_def->host, vl->host) != 0) {\r\n    if (write_part_string(&buffer, &buffer_size, TYPE_HOST, vl->host,\r\n                          strlen(vl->host)) != 0)\r\n      return -1;\r\n    sstrncpy(vl_def->host, vl->host, sizeof(vl_def->host));\r\n  }\r\n\r\n  if (vl_def->time != vl->time) {\r\n    if (write_part_number(&buffer, &buffer_size, TYPE_TIME_HR,\r\n                          (uint64_t)vl->time))\r\n      return -1;\r\n    vl_def->time = vl->time;\r\n  }\r\n\r\n  if (vl_def->interval != vl->interval) {\r\n    if (write_part_number(&buffer, &buffer_size, TYPE_INTERVAL_HR,\r\n                          (uint64_t)vl->interval))\r\n      return -1;\r\n    vl_def->interval = vl->interval;\r\n  }\r\n\r\n  if (strcmp(vl_def->plugin, vl->plugin) != 0) {\r\n    if (write_part_string(&buffer, &buffer_size, TYPE_PLUGIN, vl->plugin,\r\n                          strlen(vl->plugin)) != 0)\r\n      return -1;\r\n    sstrncpy(vl_def->plugin, vl->plugin, sizeof(vl_def->plugin));\r\n  }\r\n\r\n  if (strcmp(vl_def->plugin_instance, vl->plugin_instance) != 0) {\r\n    if (write_part_string(&buffer, &buffer_size, TYPE_PLUGIN_INSTANCE,\r\n                          vl->plugin_instance,\r\n                          strlen(vl->plugin_instance)) != 0)\r\n      return -1;\r\n    sstrncpy(vl_def->plugin_instance, vl->plugin_instance,\r\n             sizeof(vl_def->plugin_instance));\r\n  }\r\n\r\n  if (strcmp(vl_def->type, vl->type) != 0) {\r\n    if (write_part_string(&buffer, &buffer_size, TYPE_TYPE, vl->type,\r\n                          strlen(vl->type)) != 0)\r\n      return -1;\r\n    sstrncpy(vl_def->type, ds->type, sizeof(vl_def->type));\r\n  }\r\n\r\n  if (strcmp(vl_def->type_instance, vl->type_instance) != 0) {\r\n    if (write_part_string(&buffer, &buffer_size, TYPE_TYPE_INSTANCE,\r\n                          vl->type_instance, strlen(vl->type_instance)) != 0)\r\n      return -1;\r\n    sstrncpy(vl_def->type_instance, vl->type_instance,\r\n             sizeof(vl_def->type_instance));\r\n  }\r\n\r\n  if (write_part_values(&buffer, &buffer_size, ds, vl) != 0)\r\n    return -1;\r\n\r\n  return buffer - buffer_orig;\r\n}", ".arse_part_sign_sha256": "static int parse_part_sign_sha256(sockent_t *se, /* {{{ */\r\n                                  void **ret_buffer, size_t *ret_buffer_len,\r\n                                  int flags, struct sockaddr_storage *sender) {\r\n  static c_complain_t complain_no_users = C_COMPLAIN_INIT_STATIC;\r\n\r\n  char *buffer;\r\n  size_t buffer_len;\r\n  size_t buffer_offset;\r\n\r\n  size_t username_len;\r\n  char *secret;\r\n\r\n  part_signature_sha256_t pss;\r\n  uint16_t pss_head_length;\r\n  char hash[sizeof(pss.hash)];\r\n\r\n  gcry_md_hd_t hd;\r\n  gcry_error_t err;\r\n  unsigned char *hash_ptr;\r\n\r\n  buffer = *ret_buffer;\r\n  buffer_len = *ret_buffer_len;\r\n  buffer_offset = 0;\r\n\r\n  /* Check if the buffer has enough data for this structure. */\r\n  if (buffer_len <= PART_SIGNATURE_SHA256_SIZE)\r\n    return -ENOMEM;\r\n\r\n  /* Read type and length header */\r\n  BUFFER_READ(&pss.head.type, sizeof(pss.head.type));\r\n  BUFFER_READ(&pss.head.length, sizeof(pss.head.length));\r\n  pss_head_length = ntohs(pss.head.length);\r\n\r\n  /* Check if the `pss_head_length' is within bounds. */\r\n  if ((pss_head_length <= PART_SIGNATURE_SHA256_SIZE) ||\r\n      (pss_head_length > buffer_len)) {\r\n    ERROR(\"network plugin: HMAC-SHA-256 with invalid length received.\");\r\n    return -1;\r\n  }\r\n\r\n  if (se->data.server.userdb == NULL) {\r\n    c_complain(\r\n        LOG_NOTICE, &complain_no_users,\r\n        \"network plugin: Received signed network packet but can't verify it \"\r\n        \"because no user DB has been configured. Will accept it.\");\r\n\r\n    *ret_buffer = buffer + pss_head_length;\r\n    *ret_buffer_len -= pss_head_length;\r\n\r\n    return 0;\r\n  }\r\n\r\n  /* Copy the hash. */\r\n  BUFFER_READ(pss.hash, sizeof(pss.hash));\r\n\r\n  /* Calculate username length (without null byte) and allocate memory */\r\n  username_len = pss_head_length - PART_SIGNATURE_SHA256_SIZE;\r\n  pss.username = malloc(username_len + 1);\r\n  if (pss.username == NULL)\r\n    return -ENOMEM;\r\n\r\n  /* Read the username */\r\n  BUFFER_READ(pss.username, username_len);\r\n  pss.username[username_len] = 0;\r\n\r\n  assert(buffer_offset == pss_head_length);\r\n\r\n  /* Query the password */\r\n  secret = fbh_get(se->data.server.userdb, pss.username);\r\n  if (secret == NULL) {\r\n    ERROR(\"network plugin: Unknown user: %s\", pss.username);\r\n    sfree(pss.username);\r\n    return -ENOENT;\r\n  }\r\n\r\n  /* Create a hash device and check the HMAC */\r\n  hd = NULL;\r\n  err = gcry_md_open(&hd, GCRY_MD_SHA256, GCRY_MD_FLAG_HMAC);\r\n  if (err != 0) {\r\n    ERROR(\"network plugin: Creating HMAC-SHA-256 object failed: %s\",\r\n          gcry_strerror(err));\r\n    sfree(secret);\r\n    sfree(pss.username);\r\n    return -1;\r\n  }\r\n\r\n  err = gcry_md_setkey(hd, secret, strlen(secret));\r\n  if (err != 0) {\r\n    ERROR(\"network plugin: gcry_md_setkey failed: %s\", gcry_strerror(err));\r\n    gcry_md_close(hd);\r\n    sfree(secret);\r\n    sfree(pss.username);\r\n    return -1;\r\n  }\r\n\r\n  gcry_md_write(hd, buffer + PART_SIGNATURE_SHA256_SIZE,\r\n                buffer_len - PART_SIGNATURE_SHA256_SIZE);\r\n  hash_ptr = gcry_md_read(hd, GCRY_MD_SHA256);\r\n  if (hash_ptr == NULL) {\r\n    ERROR(\"network plugin: gcry_md_read failed.\");\r\n    gcry_md_close(hd);\r\n    sfree(secret);\r\n    sfree(pss.username);\r\n    return -1;\r\n  }\r\n  memcpy(hash, hash_ptr, sizeof(hash));\r\n\r\n  /* Clean up */\r\n  gcry_md_close(hd);\r\n  hd = NULL;\r\n\r\n  if (memcmp(pss.hash, hash, sizeof(pss.hash)) != 0) {\r\n    WARNING(\"network plugin: Verifying HMAC-SHA-256 signature failed: \"\r\n            \"Hash mismatch. Username: %s\",\r\n            pss.username);\r\n  } else {\r\n    parse_packet(se, buffer + buffer_offset, buffer_len - buffer_offset,\r\n                 flags | PP_SIGNED, pss.username, sender);\r\n  }\r\n\r\n  sfree(secret);\r\n  sfree(pss.username);\r\n\r\n  *ret_buffer = buffer + buffer_len;\r\n  *ret_buffer_len = 0;\r\n\r\n  return 0;\r\n}", ".ockent_destroy": "static void sockent_destroy(sockent_t *se) /* {{{ */\r\n{\r\n  sockent_t *next;\r\n\r\n  DEBUG(\"network plugin: sockent_destroy (se = %p);\", (void *)se);\r\n\r\n  while (se != NULL) {\r\n    next = se->next;\r\n\r\n    sfree(se->node);\r\n    sfree(se->service);\r\n    pthread_mutex_destroy(&se->lock);\r\n\r\n    if (se->type == SOCKENT_TYPE_CLIENT)\r\n      free_sockent_client(&se->data.client);\r\n    else\r\n      free_sockent_server(&se->data.server);\r\n\r\n    sfree(se);\r\n    se = next;\r\n  }\r\n}", ".etwork_config_add_listen": "static int network_config_add_listen(const oconfig_item_t *ci) /* {{{ */\r\n{\r\n  sockent_t *se;\r\n  int status;\r\n\r\n  if ((ci->values_num < 1) || (ci->values_num > 2) ||\r\n      (ci->values[0].type != OCONFIG_TYPE_STRING) ||\r\n      ((ci->values_num > 1) && (ci->values[1].type != OCONFIG_TYPE_STRING))) {\r\n    ERROR(\"network plugin: The `%s' config option needs \"\r\n          \"one or two string arguments.\",\r\n          ci->key);\r\n    return -1;\r\n  }\r\n\r\n  se = sockent_create(SOCKENT_TYPE_SERVER);\r\n  if (se == NULL) {\r\n    ERROR(\"network plugin: sockent_create failed.\");\r\n    return -1;\r\n  }\r\n\r\n  se->node = strdup(ci->values[0].value.string);\r\n  if (ci->values_num >= 2)\r\n    se->service = strdup(ci->values[1].value.string);\r\n\r\n  for (int i = 0; i < ci->children_num; i++) {\r\n    oconfig_item_t *child = ci->children + i;\r\n\r\n#if HAVE_GCRYPT_H\r\n    if (strcasecmp(\"AuthFile\", child->key) == 0)\r\n      cf_util_get_string(child, &se->data.server.auth_file);\r\n    else if (strcasecmp(\"SecurityLevel\", child->key) == 0)\r\n      network_config_set_security_level(child, &se->data.server.security_level);\r\n    else\r\n#endif /* HAVE_GCRYPT_H */\r\n        if (strcasecmp(\"Interface\", child->key) == 0)\r\n      network_config_set_interface(child, &se->interface);\r\n    else {\r\n      WARNING(\"network plugin: Option `%s' is not allowed here.\", child->key);\r\n    }\r\n  }\r\n\r\n#if HAVE_GCRYPT_H\r\n  if ((se->data.server.security_level > SECURITY_LEVEL_NONE) &&\r\n      (se->data.server.auth_file == NULL)) {\r\n    ERROR(\"network plugin: A security level higher than `none' was \"\r\n          \"requested, but no AuthFile option was given. Cowardly refusing to \"\r\n          \"open this socket!\");\r\n    sockent_destroy(se);\r\n    return -1;\r\n  }\r\n#endif /* HAVE_GCRYPT_H */\r\n\r\n  status = sockent_init_crypto(se);\r\n  if (status != 0) {\r\n    ERROR(\"network plugin: network_config_add_listen: sockent_init_crypto() \"\r\n          \"failed.\");\r\n    sockent_destroy(se);\r\n    return -1;\r\n  }\r\n\r\n  status = sockent_server_listen(se);\r\n  if (status != 0) {\r\n    ERROR(\"network plugin: network_config_add_listen: sockent_server_listen \"\r\n          \"failed.\");\r\n    sockent_destroy(se);\r\n    return -1;\r\n  }\r\n\r\n  status = sockent_add(se);\r\n  if (status != 0) {\r\n    ERROR(\"network plugin: network_config_add_listen: sockent_add failed.\");\r\n    sockent_destroy(se);\r\n    return -1;\r\n  }\r\n\r\n  return 0;\r\n}", ".etwork_config_add_server": "static int network_config_add_server(const oconfig_item_t *ci) /* {{{ */\r\n{\r\n  sockent_t *se;\r\n  int status;\r\n\r\n  if ((ci->values_num < 1) || (ci->values_num > 2) ||\r\n      (ci->values[0].type != OCONFIG_TYPE_STRING) ||\r\n      ((ci->values_num > 1) && (ci->values[1].type != OCONFIG_TYPE_STRING))) {\r\n    ERROR(\"network plugin: The `%s' config option needs \"\r\n          \"one or two string arguments.\",\r\n          ci->key);\r\n    return -1;\r\n  }\r\n\r\n  se = sockent_create(SOCKENT_TYPE_CLIENT);\r\n  if (se == NULL) {\r\n    ERROR(\"network plugin: sockent_create failed.\");\r\n    return -1;\r\n  }\r\n\r\n  se->node = strdup(ci->values[0].value.string);\r\n  if (ci->values_num >= 2)\r\n    se->service = strdup(ci->values[1].value.string);\r\n\r\n  for (int i = 0; i < ci->children_num; i++) {\r\n    oconfig_item_t *child = ci->children + i;\r\n\r\n#if HAVE_GCRYPT_H\r\n    if (strcasecmp(\"Username\", child->key) == 0)\r\n      cf_util_get_string(child, &se->data.client.username);\r\n    else if (strcasecmp(\"Password\", child->key) == 0)\r\n      cf_util_get_string(child, &se->data.client.password);\r\n    else if (strcasecmp(\"SecurityLevel\", child->key) == 0)\r\n      network_config_set_security_level(child, &se->data.client.security_level);\r\n    else\r\n#endif /* HAVE_GCRYPT_H */\r\n        if (strcasecmp(\"Interface\", child->key) == 0)\r\n      network_config_set_interface(child, &se->interface);\r\n    else if (strcasecmp(\"BindAddress\", child->key) == 0)\r\n      network_config_set_bind_address(child, &se->data.client.bind_addr);\r\n    else if (strcasecmp(\"ResolveInterval\", child->key) == 0)\r\n      cf_util_get_cdtime(child, &se->data.client.resolve_interval);\r\n    else {\r\n      WARNING(\"network plugin: Option `%s' is not allowed here.\", child->key);\r\n    }\r\n  }\r\n\r\n#if HAVE_GCRYPT_H\r\n  if ((se->data.client.security_level > SECURITY_LEVEL_NONE) &&\r\n      ((se->data.client.username == NULL) ||\r\n       (se->data.client.password == NULL))) {\r\n    ERROR(\"network plugin: A security level higher than `none' was \"\r\n          \"requested, but no Username or Password option was given. \"\r\n          \"Cowardly refusing to open this socket!\");\r\n    sockent_destroy(se);\r\n    return -1;\r\n  }\r\n#endif /* HAVE_GCRYPT_H */\r\n\r\n  status = sockent_init_crypto(se);\r\n  if (status != 0) {\r\n    ERROR(\"network plugin: network_config_add_server: sockent_init_crypto() \"\r\n          \"failed.\");\r\n    sockent_destroy(se);\r\n    return -1;\r\n  }\r\n\r\n  /* No call to sockent_client_connect() here -- it is called from\r\n   * network_send_buffer_plain(). */\r\n\r\n  status = sockent_add(se);\r\n  if (status != 0) {\r\n    ERROR(\"network plugin: network_config_add_server: sockent_add failed.\");\r\n    sockent_destroy(se);\r\n    return -1;\r\n  }\r\n\r\n  return 0;\r\n}", ".etwork_shutdown": "static int network_shutdown(void) {\r\n  listen_loop++;\r\n\r\n  /* Kill the listening thread */\r\n  if (receive_thread_running != 0) {\r\n    INFO(\"network plugin: Stopping receive thread.\");\r\n    pthread_kill(receive_thread_id, SIGTERM);\r\n    pthread_join(receive_thread_id, NULL /* no return value */);\r\n    memset(&receive_thread_id, 0, sizeof(receive_thread_id));\r\n    receive_thread_running = 0;\r\n  }\r\n\r\n  /* Shutdown the dispatching thread */\r\n  if (dispatch_thread_running != 0) {\r\n    INFO(\"network plugin: Stopping dispatch thread.\");\r\n    pthread_mutex_lock(&receive_list_lock);\r\n    pthread_cond_broadcast(&receive_list_cond);\r\n    pthread_mutex_unlock(&receive_list_lock);\r\n    pthread_join(dispatch_thread_id, /* ret = */ NULL);\r\n    dispatch_thread_running = 0;\r\n  }\r\n\r\n  sockent_destroy(listen_sockets);\r\n\r\n  if (send_buffer_fill > 0)\r\n    flush_buffer();\r\n\r\n  sfree(send_buffer);\r\n\r\n  for (sockent_t *se = sending_sockets; se != NULL; se = se->next)\r\n    sockent_client_disconnect(se);\r\n  sockent_destroy(sending_sockets);\r\n\r\n  plugin_unregister_config(\"network\");\r\n  plugin_unregister_init(\"network\");\r\n  plugin_unregister_write(\"network\");\r\n  plugin_unregister_shutdown(\"network\");\r\n\r\n  return 0;\r\n}", ".etwork_send_buffer_plain": "static void network_send_buffer_plain(sockent_t *se, /* {{{ */\r\n                                      const char *buffer, size_t buffer_size) {\r\n  int status;\r\n\r\n  while (42) {\r\n    status = sockent_client_connect(se);\r\n    if (status != 0)\r\n      return;\r\n\r\n    status = sendto(se->data.client.fd, buffer, buffer_size,\r\n                    /* flags = */ 0, (struct sockaddr *)se->data.client.addr,\r\n                    se->data.client.addrlen);\r\n    if (status < 0) {\r\n      if ((errno == EINTR) || (errno == EAGAIN))\r\n        continue;\r\n\r\n      ERROR(\"network plugin: sendto failed: %s. Closing sending socket.\",\r\n            STRERRNO);\r\n      sockent_client_disconnect(se);\r\n      return;\r\n    }\r\n\r\n    break;\r\n  } /* while (42) */\r\n}", ".lush_buffer": "static void flush_buffer(void) {\r\n  DEBUG(\"network plugin: flush_buffer: send_buffer_fill = %i\",\r\n        send_buffer_fill);\r\n\r\n  network_send_buffer(send_buffer, (size_t)send_buffer_fill);\r\n\r\n  stats_octets_tx += ((uint64_t)send_buffer_fill);\r\n  stats_packets_tx++;\r\n\r\n  network_init_buffer();\r\n}", ".etwork_init": "static int network_init(void) {\r\n  static bool have_init;\r\n\r\n  /* Check if we were already initialized. If so, just return - there's\r\n   * nothing more to do (for now, that is). */\r\n  if (have_init)\r\n    return 0;\r\n  have_init = true;\r\n\r\n  if (network_config_stats)\r\n    plugin_register_read(\"network\", network_stats_read);\r\n\r\n  plugin_register_shutdown(\"network\", network_shutdown);\r\n\r\n  send_buffer = malloc(network_config_packet_size);\r\n  if (send_buffer == NULL) {\r\n    ERROR(\"network plugin: malloc failed.\");\r\n    return -1;\r\n  }\r\n  network_init_buffer();\r\n\r\n  /* setup socket(s) and so on */\r\n  if (sending_sockets != NULL) {\r\n    plugin_register_write(\"network\", network_write,\r\n                          /* user_data = */ NULL);\r\n    plugin_register_notification(\"network\", network_notification,\r\n                                 /* user_data = */ NULL);\r\n  }\r\n\r\n  /* If no threads need to be started, return here. */\r\n  if ((listen_sockets_num == 0) ||\r\n      ((dispatch_thread_running != 0) && (receive_thread_running != 0)))\r\n    return 0;\r\n\r\n  if (dispatch_thread_running == 0) {\r\n    int status;\r\n    status = plugin_thread_create(&dispatch_thread_id, dispatch_thread,\r\n                                  NULL /* no argument */, \"network disp\");\r\n    if (status != 0) {\r\n      ERROR(\"network: pthread_create failed: %s\", STRERRNO);\r\n    } else {\r\n      dispatch_thread_running = 1;\r\n    }\r\n  }\r\n\r\n  if (receive_thread_running == 0) {\r\n    int status;\r\n    status = plugin_thread_create(&receive_thread_id, receive_thread,\r\n                                  NULL /* no argument */, \"network recv\");\r\n    if (status != 0) {\r\n      ERROR(\"network: pthread_create failed: %s\", STRERRNO);\r\n    } else {\r\n      receive_thread_running = 1;\r\n    }\r\n  }\r\n\r\n  return 0;\r\n}", ".etwork_send_buffer_signed": "static void network_send_buffer_signed(sockent_t *se, /* {{{ */\r\n                                       const char *in_buffer,\r\n                                       size_t in_buffer_size) {\r\n  char buffer[BUFF_SIG_SIZE + in_buffer_size];\r\n  size_t buffer_offset;\r\n  size_t username_len;\r\n\r\n  gcry_md_hd_t hd;\r\n  gcry_error_t err;\r\n  unsigned char *hash;\r\n\r\n  hd = NULL;\r\n  err = gcry_md_open(&hd, GCRY_MD_SHA256, GCRY_MD_FLAG_HMAC);\r\n  if (err != 0) {\r\n    ERROR(\"network plugin: Creating HMAC object failed: %s\",\r\n          gcry_strerror(err));\r\n    return;\r\n  }\r\n\r\n  err = gcry_md_setkey(hd, se->data.client.password,\r\n                       strlen(se->data.client.password));\r\n  if (err != 0) {\r\n    ERROR(\"network plugin: gcry_md_setkey failed: %s\", gcry_strerror(err));\r\n    gcry_md_close(hd);\r\n    return;\r\n  }\r\n\r\n  username_len = strlen(se->data.client.username);\r\n  if (username_len > (BUFF_SIG_SIZE - PART_SIGNATURE_SHA256_SIZE)) {\r\n    ERROR(\"network plugin: Username too long: %s\", se->data.client.username);\r\n    return;\r\n  }\r\n\r\n  memcpy(buffer + PART_SIGNATURE_SHA256_SIZE, se->data.client.username,\r\n         username_len);\r\n  memcpy(buffer + PART_SIGNATURE_SHA256_SIZE + username_len, in_buffer,\r\n         in_buffer_size);\r\n\r\n  /* Initialize the `ps' structure. */\r\n  part_signature_sha256_t ps = {\r\n      .head.type = htons(TYPE_SIGN_SHA256),\r\n      .head.length = htons(PART_SIGNATURE_SHA256_SIZE + username_len)};\r\n\r\n  /* Calculate the hash value. */\r\n  gcry_md_write(hd, buffer + PART_SIGNATURE_SHA256_SIZE,\r\n                username_len + in_buffer_size);\r\n  hash = gcry_md_read(hd, GCRY_MD_SHA256);\r\n  if (hash == NULL) {\r\n    ERROR(\"network plugin: gcry_md_read failed.\");\r\n    gcry_md_close(hd);\r\n    return;\r\n  }\r\n  memcpy(ps.hash, hash, sizeof(ps.hash));\r\n\r\n  /* Add the header */\r\n  buffer_offset = 0;\r\n\r\n  BUFFER_ADD(&ps.head.type, sizeof(ps.head.type));\r\n  BUFFER_ADD(&ps.head.length, sizeof(ps.head.length));\r\n  BUFFER_ADD(ps.hash, sizeof(ps.hash));\r\n\r\n  assert(buffer_offset == PART_SIGNATURE_SHA256_SIZE);\r\n\r\n  gcry_md_close(hd);\r\n  hd = NULL;\r\n\r\n  buffer_offset = PART_SIGNATURE_SHA256_SIZE + username_len + in_buffer_size;\r\n  network_send_buffer_plain(se, buffer, buffer_offset);\r\n}", ".etwork_flush": "static int network_flush(cdtime_t timeout,\r\n                         __attribute__((unused)) const char *identifier,\r\n                         __attribute__((unused)) user_data_t *user_data) {\r\n  pthread_mutex_lock(&send_buffer_lock);\r\n\r\n  if (send_buffer_fill > 0) {\r\n    if (timeout > 0) {\r\n      cdtime_t now = cdtime();\r\n      if ((send_buffer_last_update + timeout) > now) {\r\n        pthread_mutex_unlock(&send_buffer_lock);\r\n        return 0;\r\n      }\r\n    }\r\n    flush_buffer();\r\n  }\r\n  pthread_mutex_unlock(&send_buffer_lock);\r\n\r\n  return 0;\r\n}", ".odule_register": "void module_register(void) {\r\n  plugin_register_complex_config(\"network\", network_config);\r\n  plugin_register_init(\"network\", network_init);\r\n  plugin_register_flush(\"network\", network_flush,\r\n                        /* user_data = */ NULL);\r\n}"}, "function_name": "module_register"}
{"function_id": null, "caller": {".arse_wbxml_attribute_list_defined": "static uint32_t\r\nparse_wbxml_attribute_list_defined (proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo,\r\n\t\t\t\t    uint32_t offset, uint32_t str_tbl, uint8_t *codepage_attr,\r\n\t\t\t\t    const wbxml_decoding *map)\r\n{\r\n\tuint32_t     tvb_len = tvb_reported_length (tvb);\r\n\tuint32_t     off     = offset;\r\n\tuint32_t     len;\r\n\tunsigned     str_len;\r\n\tuint32_t     ent;\r\n\tuint32_t     idx;\r\n\tuint8_t      peek;\r\n\tuint8_t      attr_save_known   = 0; /* Will contain peek & 0x3F (attr identity) */\r\n\tconst char  *attr_save_literal = NULL; /* Will contain the LITERAL attr identity */\r\n\tconst char *str;\r\n\tunsigned     recursion_level = p_get_proto_depth(pinfo, proto_wbxml);\r\n\tunsigned     encoding = GPOINTER_TO_UINT(p_get_proto_data(pinfo->pool, pinfo, proto_wbxml, 0));\r\n\r\n\tDebugLog((\"parse_wbxml_attr_defined (level = %u, offset = %u)\\n\", recursion_level, offset));\r\n\t/* Parse attributes */\r\n\twhile (off < tvb_len) {\r\n\t\tpeek = tvb_get_uint8 (tvb, off);\r\n\t\tDebugLog((\"ATTR: (top of while) level = %3u, peek = 0x%02X, \"\r\n\t\t\t  \"off = %u, tvb_len = %u\\n\", recursion_level, peek, off, tvb_len));\r\n\t\tif ((peek & 0x3F) < 5) switch (peek) { /* Global tokens\r\n\t\t\t\t\t\t\t  in state = ATTR */\r\n\t\tcase 0x00: /* SWITCH_PAGE */\r\n\t\t\t*codepage_attr = tvb_get_uint8 (tvb, off+1);\r\n\t\t\tproto_tree_add_uint_format(tree, hf_wbxml_switch_page, tvb, off, 2, *codepage_attr,\r\n                         \"      |  Attr | A -->%3d | SWITCH_PAGE (Attr code page)    |\",\r\n\t\t\t\t\t     *codepage_attr);\r\n\t\t\toff += 2;\r\n\t\t\tbreak;\r\n\t\tcase 0x01: /* END */\r\n\t\t\t/* BEWARE\r\n\t\t\t *   The Attribute END token means either \">\" or \"/>\"\r\n\t\t\t *   and as a consequence both must be treated separately.\r\n\t\t\t *   This is done in the TAG state parser.\r\n\t\t\t */\r\n\t\t\toff++;\r\n\t\t\tDebugLog((\"ATTR: level = %u, Return: len = %u\\n\",\r\n\t\t\t\t  recursion_level, off - offset));\r\n\t\t\treturn (off - offset);\r\n\t\tcase 0x02: /* ENTITY */\r\n\t\t\tent = tvb_get_uintvar (tvb, off+1, &len, pinfo, &ei_wbxml_oversized_uintvar);\r\n\t\t\tif (len <= tvb_len) {\r\n\t\t\t\tproto_tree_add_uint_format(tree, hf_wbxml_entity, tvb, off, 1+len, ent,\r\n\t\t\t\t\t         \"  %3d |  Attr | A %3d    | ENTITY                          |     %s'&#%u;'\",\r\n\t\t\t\t\t         recursion_level, *codepage_attr, Indent (recursion_level), ent);\r\n\t\t\t\toff += 1+len;\r\n\t\t\t} else {\r\n\t\t\t\t/* Stop processing as it is impossible to parse now */\r\n\t\t\t\toff = tvb_len;\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\tcase 0x03: /* STR_I */\r\n\t\t\tstr = tvb_get_stringz_enc(pinfo->pool, tvb, off+1, &len, encoding);\r\n\t\t\tproto_tree_add_string_format(tree, hf_wbxml_str_i, tvb, off, 1+len, str,\r\n\t\t\t\t\t     \"  %3d |  Attr | A %3d    | STR_I (Inline string)           |     %s\\'%s\\'\",\r\n\t\t\t\t\t     recursion_level, *codepage_attr, Indent (recursion_level), str);\r\n\t\t\toff += 1+len;\r\n\t\t\tbreak;\r\n\t\tcase 0x04: /* LITERAL */\r\n\t\t\t/* ALWAYS means the start of a new attribute,\r\n\t\t\t * and may only contain the NAME of the attribute.\r\n\t\t\t */\r\n\t\t\tidx = tvb_get_uintvar (tvb, off+1, &len, pinfo, &ei_wbxml_oversized_uintvar);\r\n\t\t\tif (len <= tvb_len) {\r\n\t\t\t\tattr_save_known = 0;\r\n\t\t\t\tattr_save_literal = tvb_get_stringz_enc(pinfo->pool, tvb, str_tbl+idx, &str_len, encoding);\r\n\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_literal, tvb, off, 1+len, attr_save_literal,\r\n\t\t\t\t\t         \"  %3d |  Attr | A %3d    | LITERAL (Literal Attribute)     |   %s<%s />\",\r\n\t\t\t\t\t         recursion_level, *codepage_attr, Indent (recursion_level), attr_save_literal);\r\n\t\t\t\toff += 1+len;\r\n\t\t\t} else {\r\n\t\t\t\t/* Stop processing as it is impossible to parse now */\r\n\t\t\t\toff = tvb_len;\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\tcase 0x40: /* EXT_I_0 */\r\n\t\tcase 0x41: /* EXT_I_1 */\r\n\t\tcase 0x42: /* EXT_I_2 */\r\n\t\t\t/* Extension tokens */\r\n\t\t\tstr = tvb_get_stringz_enc(pinfo->pool, tvb, off+1, &len, encoding);\r\n\t\t\tproto_tree_add_string_format(tree, hf_wbxml_ext_i, tvb, off, 1+len, str,\r\n\t\t\t\t\t     \"  %3d |  Attr | A %3d    | EXT_I_%1x    (Extension Token)    |     %s(%s: \\'%s\\')\",\r\n\t\t\t\t\t     recursion_level, *codepage_attr, peek & 0x0f, Indent (recursion_level),\r\n\t\t\t\t\t     ((map != NULL) ? map_token (map->global, 0, peek) : \"Inline string extension\"), str);\r\n\t\t\toff += 1+len;\r\n\t\t\tbreak;\r\n\t\t\t/* 0x43 impossible in ATTR state */\r\n\t\t\t/* 0x44 impossible in ATTR state */\r\n\t\tcase 0x80: /* EXT_T_0 */\r\n\t\tcase 0x81: /* EXT_T_1 */\r\n\t\tcase 0x82: /* EXT_T_2 */\r\n\t\t\t/* Extension tokens */\r\n\t\t\tidx = tvb_get_uintvar (tvb, off+1, &len, pinfo, &ei_wbxml_oversized_uintvar);\r\n\t\t\t{\r\n\t\t\t\tchar *s;\r\n\t\t\t\tif (map != NULL) {\r\n\r\n\t\t\t\t\tif (map->ext_t[peek & 0x03])\r\n\t\t\t\t\t\ts = (map->ext_t[peek & 0x03])(pinfo->pool, tvb, idx, str_tbl);\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\ts = wmem_strdup_printf(pinfo->pool, \"EXT_T_%1x (%s)\", peek & 0x03,\r\n\t\t\t\t\t\t\t\t    map_token (map->global, 0, peek));\r\n\t\t\t\t} else {\r\n\t\t\t\t\ts = wmem_strdup_printf(pinfo->pool, \"Extension Token, integer value: (%u\", idx);\r\n\t\t\t\t}\r\n\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_ext_t, tvb, off, 1+len, s,\r\n\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    | EXT_T_%1x    (Extension Token)    | %s%s)\",\r\n\t\t\t\t\t\t     recursion_level, *codepage_attr, peek & 0x0f, Indent (recursion_level),\r\n\t\t\t\t\t\t     s);\r\n\t\t\t}\r\n\t\t\tif (len <= tvb_len) {\r\n\t\t\t\toff += 1+len;\r\n\t\t\t} else {\r\n\t\t\t\t/* Stop processing as it is impossible to parse now */\r\n\t\t\t\toff = tvb_len;\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\tcase 0x83: /* STR_T */\r\n\t\t\tidx = tvb_get_uintvar (tvb, off+1, &len, pinfo, &ei_wbxml_oversized_uintvar);\r\n\t\t\tif (len <= tvb_len) {\r\n\t\t\t\tstr = tvb_get_stringz_enc(pinfo->pool, tvb, str_tbl+idx, &str_len, encoding);\r\n\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_str_t, tvb, off, 1+len, str,\r\n\t\t\t\t\t         \"  %3d |  Attr | A %3d    | STR_T (Tableref string)         |     %s\\'%s\\'\",\r\n\t\t\t\t\t         recursion_level, *codepage_attr, Indent (recursion_level), str);\r\n\t\t\t\toff += 1+len;\r\n\t\t\t} else {\r\n\t\t\t\t/* Stop processing as it is impossible to parse now */\r\n\t\t\t\toff = tvb_len;\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\t\t/* 0x84 impossible in ATTR state */\r\n\t\tcase 0xC0: /* EXT_0 */\r\n\t\tcase 0xC1: /* EXT_1 */\r\n\t\tcase 0xC2: /* EXT_2 */\r\n\t\t\t/* Extension tokens */\r\n\t\t\tstr = (map != NULL) ? map_token (map->global, 0, peek) : \"Single-byte extension\";\r\n\t\t\tproto_tree_add_string_format(tree, hf_wbxml_extension_token, tvb, off, 1, str,\r\n\t\t\t\t\t     \"  %3d |  Attr | A %3d    | EXT_%1x      (Extension Token)    |     %s(%s)\",\r\n\t\t\t\t\t     recursion_level, *codepage_attr, peek & 0x0f, Indent (recursion_level), str);\r\n\t\t\toff++;\r\n\t\t\tbreak;\r\n\t\tcase 0xC3: /* OPAQUE - WBXML 1.1 and newer */\r\n\t\t\tif (tvb_get_uint8 (tvb, 0)) { /* WBXML 1.x (x > 0) */\r\n\t\t\t\tif (map != NULL) {\r\n\t\t\t\t\tchar *tmp_str;\r\n\t\t\t\t\tif (attr_save_known) { /* Knwon attribute */\r\n\t\t\t\t\t\tif (map->opaque_binary_attr) {\r\n\t\t\t\t\t\t\ttmp_str = map->opaque_binary_attr(tvb, off + 1,\r\n\t\t\t\t\t\t\t\t\t      attr_save_known, *codepage_attr, &len, pinfo);\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\ttmp_str = default_opaque_binary_attr(tvb, off + 1,\r\n\t\t\t\t\t\t\t\t\t\t attr_save_known, *codepage_attr, &len, pinfo);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else { /* lITERAL attribute */\r\n\t\t\t\t\t\tif (map->opaque_literal_tag) {\r\n\t\t\t\t\t\t\ttmp_str = map->opaque_literal_attr(tvb, off + 1,\r\n\t\t\t\t\t\t\t\t\t       attr_save_literal, *codepage_attr, &len, pinfo);\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\ttmp_str = default_opaque_literal_attr(tvb, off + 1,\r\n\t\t\t\t\t\t\t\t\t\t  attr_save_literal, *codepage_attr, &len, pinfo);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (len <= tvb_len) {\r\n\t\t\t\t\t\tproto_tree_add_bytes_format(tree, hf_wbxml_opaque_data, tvb, off, 1 + len, NULL,\r\n\t\t\t\t\t\t\t         \"  %3d |  Attr | A %3d    | OPAQUE (Opaque data)            |       %s%s\",\r\n\t\t\t\t\t\t\t         recursion_level, *codepage_attr, Indent (recursion_level), tmp_str);\r\n\t\t\t\t\t\toff += 1 + len;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t/* Stop processing as it is impossible to parse now */\r\n\t\t\t\t\t\toff = tvb_len;\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tidx = tvb_get_uintvar (tvb, off+1, &len, pinfo, &ei_wbxml_oversized_uintvar);\r\n\t\t\t\t\tif ((len <= tvb_len) && (idx < tvb_len)) {\r\n\t\t\t\t\t\tproto_tree_add_bytes_format(tree, hf_wbxml_opaque_data, tvb, off, 1 + len + idx, NULL,\r\n\t\t\t\t\t\t\t     \"  %3d |  Attr | A %3d    | OPAQUE (Opaque data)            |       %s(%u bytes of opaque data)\",\r\n\t\t\t\t\t\t\t     recursion_level, *codepage_attr, Indent (recursion_level), idx);\r\n\t\t\t\t\t\toff += 1+len+idx;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t/* Stop processing as it is impossible to parse now */\r\n\t\t\t\t\t\toff = tvb_len;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} else { /* WBXML 1.0 - RESERVED_2 token (invalid) */\r\n\t\t\t\tproto_tree_add_none_format(tree, hf_wbxml_reserved_2, tvb, off, 1,\r\n\t\t\t\t\t\t\t     \"  %3d |  Attr | A %3d    | RESERVED_2     (Invalid Token!) | WBXML 1.0 parsing stops here.\",\r\n\t\t\t\t\t\t\t     recursion_level, *codepage_attr);\r\n\t\t\t\t/* Stop processing as it is impossible to parse now */\r\n\t\t\t\toff = tvb_len;\r\n\t\t\t\tDebugLog((\"ATTR: level = %u, Return: len = %u\\n\",\r\n\t\t\t\t\t  recursion_level, off - offset));\r\n\t\t\t\treturn (off - offset);\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\t\t/* 0xC4 impossible in ATTR state */\r\n\t\tdefault:\r\n\t\t\tproto_tree_add_none_format(tree, hf_wbxml_invalid_token, tvb, off, 1,\r\n\t\t\t\t\t     \"  %3d |  Attr | A %3d    | %-10s     (Invalid Token!) | WBXML parsing stops here.\",\r\n\t\t\t\t\t     recursion_level, *codepage_attr, val_to_str_ext(pinfo->pool, peek, &vals_wbxml1x_global_tokens_ext, \"(unknown 0x%x)\"));\r\n\t\t\t/* Move to end of buffer */\r\n\t\t\toff = tvb_len;\r\n\t\t\tbreak;\r\n\t\t} else { /* Known attribute token */\r\n\t\t\tconst char* s;\r\n\t\t\tif (peek & 0x80) { /* attrValue */\r\n\t\t\t\tif (map != NULL) {\r\n\t\t\t\t\ts = map_token (map->attrValue, *codepage_attr, peek);\r\n\t\t\t\t} else {\r\n\t\t\t\t\ts = wmem_strdup_printf(pinfo->pool, \"attrValue_0x%02X\", peek);\r\n\t\t\t\t}\r\n\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_known_attrvalue, tvb, off, 1, s,\r\n\t\t\t\t\t\t     \"  %3d |  Attr | A %3d    |   Known attrValue 0x%02X          |       %s%s\",\r\n\t\t\t\t\t\t     recursion_level, *codepage_attr, peek & 0x7f, Indent (recursion_level),\r\n\t\t\t\t\t\t     s);\r\n\t\t\t\toff++;\r\n\t\t\t} else { /* attrStart */\r\n\t\t\t\tattr_save_known = peek & 0x7f;\r\n\t\t\t\tif (map != NULL) {\r\n\t\t\t\t\ts = map_token (map->attrStart, *codepage_attr, peek);\r\n\t\t\t\t} else {\r\n\t\t\t\t\ts = wmem_strdup_printf(pinfo->pool, \"attrStart_0x%02X\", peek);\r\n\t\t\t\t}\r\n\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_known_attrstart, tvb, off, 1, s,\r\n\t\t\t\t\t\t     \"  %3d |  Attr | A %3d    |   Known attrStart 0x%02X          |   %s%s\",\r\n\t\t\t\t\t\t     recursion_level, *codepage_attr, attr_save_known, Indent (recursion_level),\r\n\t\t\t\t\t\t     s);\r\n\t\t\t\toff++;\r\n\t\t\t}\r\n\t\t}\r\n\t} /* End WHILE */\r\n\tDebugLog((\"ATTR: level = %u, Return: len = %u (end of function body)\\n\",\r\n\t\t  recursion_level, off - offset));\r\n\treturn (off - offset);\r\n}", ".how_wbxml_string_table": "static void\r\nshow_wbxml_string_table (proto_tree *tree, packet_info* pinfo, tvbuff_t *tvb, uint32_t str_tbl,\r\n\t\t\t uint32_t str_tbl_len, unsigned charset)\r\n{\r\n\tunsigned encoding = mibenum_charset_to_encoding(charset);\r\n\tuint32_t off = str_tbl;\r\n\tuint32_t end = str_tbl + str_tbl_len;\r\n\tproto_tree *item_tree;\r\n\tproto_item *ti;\r\n\tconst uint8_t *str;\r\n\tint len;\r\n\r\n\twhile (off < end) {\r\n\t\t/*\r\n\t\t * XXX - use the string encoding.\r\n\t\t */\r\n\t\titem_tree = proto_tree_add_subtree_format (tree, tvb, off, 0,\r\n\t\t\t\t\t\t\t   ett_wbxml_string_table_item,\r\n\t\t\t\t\t\t\t   &ti,\r\n\t\t\t\t\t\t\t   \"%u:\",\r\n\t\t\t\t\t\t\t   off - str_tbl);\r\n\t\tproto_tree_add_uint (item_tree,\r\n\t\t    hf_wbxml_string_table_item_offset,\r\n\t\t    tvb, 0, 0, off - str_tbl);\r\n\t\tproto_tree_add_item_ret_string_and_length (item_tree,\r\n\t\t    hf_wbxml_string_table_item_string,\r\n\t\t    tvb, off, -1, encoding, pinfo->pool, &str, &len);\r\n\t\tproto_item_append_text(ti, \" '%s'\", format_text(pinfo->pool, str, strlen(str)));\r\n\t\tproto_item_set_len(ti, len);\r\n\t\toff += len;\r\n\t}\r\n}", ".arse_wbxml_tag_defined": "static uint32_t\r\n// NOLINTNEXTLINE(misc-no-recursion)\r\nparse_wbxml_tag_defined (proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo, uint32_t offset,\r\n\t\t\t uint32_t str_tbl, uint8_t *codepage_stag, uint8_t *codepage_attr,\r\n\t\t\t const wbxml_decoding *map)\r\n{\r\n\tuint32_t     tvb_len  = tvb_reported_length (tvb);\r\n\tuint32_t     off      = offset;\r\n\tuint32_t     len;\r\n\tunsigned     str_len;\r\n\tuint32_t     ent;\r\n\tuint32_t     idx;\r\n\tuint8_t      peek;\r\n\tuint32_t     tag_len;                     /* Length of the index (uintvar) from a LITERAL tag */\r\n\tuint8_t      tag_save_known      = 0;     /* Will contain peek & 0x3F (tag identity) */\r\n\tuint8_t      tag_new_known       = 0;     /* Will contain peek & 0x3F (tag identity) */\r\n\tconst char  *tag_save_literal    = NULL;  /* Will contain the LITERAL tag identity */\r\n\tconst char  *tag_new_literal;             /* Will contain the LITERAL tag identity */\r\n\tconst char *str;\r\n\tuint8_t      parsing_tag_content = false; /* Are we parsing content from a\r\n\t\t\t\t\t\t     tag with content: <x>Content</x>\r\n\r\n\t\t\t\t\t\t     The initial state is false.\r\n\t\t\t\t\t\t     This state will trigger recursion. */\r\n\r\n\tunsigned     recursion_level = p_get_proto_depth(pinfo, proto_wbxml);\r\n\tunsigned     encoding = GPOINTER_TO_UINT(p_get_proto_data(pinfo->pool, pinfo, proto_wbxml, 0));\r\n\tif (recursion_level >= WBXML_MAX_RECURSION_LEVEL) {\r\n\t\tproto_tree_add_expert(tree, pinfo, &ei_wbxml_too_much_recursion, tvb, offset, tvb_captured_length_remaining(tvb, offset));\r\n\t\treturn tvb_len;\r\n\t}\r\n\tDebugLog((\"parse_wbxml_tag_defined (level = %u, offset = %u)\\n\", recursion_level, offset));\r\n\twhile (off < tvb_len) {\r\n\t\tpeek = tvb_get_uint8 (tvb, off);\r\n\t\tDebugLog((\"STAG: (top of while) level = %3u, peek = 0x%02X, off = %u, tvb_len = %u\\n\", recursion_level, peek, off, tvb_len));\r\n\t\tif ((peek & 0x3F) < 4) switch (peek) { /* Global tokens in state = STAG\r\n\t\t\t\t\t\t\t  but not the LITERAL tokens */\r\n\t\tcase 0x00: /* SWITCH_PAGE */\r\n\t\t\t*codepage_stag = tvb_get_uint8 (tvb, off+1);\r\n\t\t\tproto_tree_add_uint_format(tree, hf_wbxml_switch_page, tvb, off, 2, *codepage_stag,\r\n\t\t\t\t\t     \"      | Tag   | T -->%3d | SWITCH_PAGE (Tag code page)     |\",\r\n\t\t\t\t\t     *codepage_stag);\r\n\t\t\toff += 2;\r\n\t\t\tbreak;\r\n\t\tcase 0x01: /* END: only possible for Tag with Content */\r\n\t\t\tif (tag_save_known) { /* Known TAG */\r\n\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_end_known_tag, tvb, off, 1, tag_save_literal,\r\n\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    | END (Known Tag 0x%02X)            | %s</%s>\",\r\n\t\t\t\t\t\t     recursion_level, *codepage_stag,\r\n\t\t\t\t\t\t     tag_save_known, Indent (recursion_level),\r\n\t\t\t\t\t\t     tag_save_literal); /* We already looked it up! */\r\n\t\t\t} else { /* Literal TAG */\r\n\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_end_literal_tag, tvb, off, 1, tag_save_literal ? tag_save_literal : \"\",\r\n\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    | END (Literal Tag)               | %s</%s>\",\r\n\t\t\t\t\t\t     recursion_level, *codepage_stag, Indent (recursion_level), tag_save_literal ? tag_save_literal : \"\");\r\n\t\t\t}\r\n\t\t\trecursion_level--;\r\n\t\t\tp_set_proto_depth(pinfo, proto_wbxml, recursion_level);\r\n\t\t\toff++;\r\n\t\t\t/* Reset code page: not needed as return from recursion */\r\n\t\t\tDebugLog((\"STAG: level = %u, Return: len = %u\\n\", recursion_level, off - offset));\r\n\t\t\treturn (off - offset);\r\n\t\tcase 0x02: /* ENTITY */\r\n\t\t\tent = tvb_get_uintvar (tvb, off+1, &len, pinfo, &ei_wbxml_oversized_uintvar);\r\n\t\t\tproto_tree_add_uint_format(tree, hf_wbxml_entity, tvb, off, 1+len, ent,\r\n\t\t\t\t\t     \"  %3d | Tag   | T %3d    | ENTITY                          | %s'&#%u;'\",\r\n\t\t\t\t\t     recursion_level, *codepage_stag, Indent (recursion_level), ent);\r\n\t\t\toff += 1+len;\r\n\t\t\tbreak;\r\n\t\tcase 0x03: /* STR_I */\r\n\t\t\tstr = tvb_get_stringz_enc(pinfo->pool, tvb, off+1, &len, encoding);\r\n\t\t\tproto_tree_add_string_format(tree, hf_wbxml_str_i, tvb, off, 1+len, str,\r\n\t\t\t\t\t     \"  %3d | Tag   | T %3d    | STR_I (Inline string)           | %s\\'%s\\'\",\r\n\t\t\t\t\t     recursion_level, *codepage_stag, Indent(recursion_level),\r\n\t\t\t\t\t     str);\r\n\t\t\toff += 1+len;\r\n\t\t\tbreak;\r\n\t\tcase 0x40: /* EXT_I_0 */\r\n\t\tcase 0x41: /* EXT_I_1 */\r\n\t\tcase 0x42: /* EXT_I_2 */\r\n\t\t\t/* Extension tokens */\r\n\t\t\tstr = tvb_get_stringz_enc(pinfo->pool, tvb, off+1, &len, encoding);\r\n\t\t\tproto_tree_add_string_format(tree, hf_wbxml_ext_i, tvb, off, 1+len, str,\r\n\t\t\t\t\t     \"  %3d | Tag   | T %3d    | EXT_I_%1x    (Extension Token)    | %s(%s: \\'%s\\')\",\r\n\t\t\t\t\t     recursion_level, *codepage_stag,\r\n\t\t\t\t\t     peek & 0x0f, Indent (recursion_level),\r\n\t\t\t\t\t     ((map != NULL) ? map_token (map->global, 0, peek) : \"Inline string extension\"),\r\n\t\t\t\t\t     str);\r\n\t\t\toff += 1+len;\r\n\t\t\tbreak;\r\n\t\tcase 0x43: /* PI */\r\n\t\t\tproto_tree_add_none_format(tree, hf_wbxml_pi_xml, tvb, off, 1,\r\n\t\t\t\t\t     \"  %3d | Tag   | T %3d    | PI (XML Processing Instruction) | %s<?xml\",\r\n\t\t\t\t\t     recursion_level, *codepage_stag, Indent (recursion_level));\r\n\t\t\tlen = parse_wbxml_attribute_list_defined (tree, tvb, pinfo, off,\r\n\t\t\t\t\t\t\t\t  str_tbl, codepage_attr, map);\r\n\t\t\t/* Check that there is still room in packet */\r\n\t\t\toff += len;\r\n\t\t\tif (off >= tvb_len) {\r\n\t\t\t\tDebugLog((\"STAG: level = %u, ThrowException: len = %u (short frame)\\n\",\r\n\t\t\t\t\t\t\trecursion_level, off - offset));\r\n\t\t\t}\r\n\r\n\t\t\tproto_tree_add_none_format(tree, hf_wbxml_end_pi, tvb, off-1, 1,\r\n\t\t\t\t\t     \"  %3d | Tag   | T %3d    | END (PI)                        | %s?>\",\r\n\t\t\t\t\t     recursion_level, *codepage_stag, Indent (recursion_level));\r\n\t\t\tbreak;\r\n\t\tcase 0x80: /* EXT_T_0 */\r\n\t\tcase 0x81: /* EXT_T_1 */\r\n\t\tcase 0x82: /* EXT_T_2 */\r\n\t\t\t/* Extension tokens */\r\n\t\t\tidx = tvb_get_uintvar (tvb, off+1, &len, pinfo, &ei_wbxml_oversized_uintvar);\r\n\t\t\t{\r\n\t\t\t\tchar *s;\r\n\t\t\t\tif (map)\r\n\t\t\t\t{\r\n\t\t\t\t\tif (map->ext_t[peek & 0x03])\r\n\t\t\t\t\t\ts = (map->ext_t[peek & 0x03])(pinfo->pool, tvb, idx, str_tbl);\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\ts = wmem_strdup_printf(pinfo->pool, \"EXT_T_%1x (%s)\", peek & 0x03,\r\n\t\t\t\t\t\t\t        map_token (map->global, 0, peek));\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\ts = wmem_strdup_printf(pinfo->pool, \"(Extension Token, integer value: %u)\", idx);\r\n\t\t\t\t}\r\n\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_ext_t, tvb, off, 1+len, s,\r\n\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    | EXT_T_%1x    (Extension Token)    | %s%s\",\r\n\t\t\t\t\t\t     recursion_level, *codepage_stag, peek & 0x0f, Indent (recursion_level), s);\r\n\t\t\t}\r\n\t\t\toff += 1+len;\r\n\t\t\tbreak;\r\n\t\tcase 0x83: /* STR_T */\r\n\t\t\tidx = tvb_get_uintvar (tvb, off+1, &len, pinfo, &ei_wbxml_oversized_uintvar);\r\n\t\t\tstr = tvb_get_stringz_enc(pinfo->pool, tvb, str_tbl+idx, &str_len, encoding);\r\n\t\t\tproto_tree_add_string_format(tree, hf_wbxml_str_t, tvb, off, 1+len, str,\r\n\t\t\t\t\t     \"  %3d | Tag   | T %3d    | STR_T (Tableref string)         | %s\\'%s\\'\",\r\n\t\t\t\t\t     recursion_level, *codepage_stag, Indent (recursion_level), str);\r\n\t\t\toff += 1+len;\r\n\t\t\tbreak;\r\n\t\tcase 0xC0: /* EXT_0 */\r\n\t\tcase 0xC1: /* EXT_1 */\r\n\t\tcase 0xC2: /* EXT_2 */\r\n\t\t\t/* Extension tokens */\r\n\t\t\tstr = (map != NULL) ? map_token (map->global, 0, peek) : \"Single-byte extension\";\r\n\t\t\tproto_tree_add_string_format(tree, hf_wbxml_extension_token, tvb, off, 1, str,\r\n\t\t\t\t\t     \"  %3d | Tag   | T %3d    | EXT_%1x      (Extension Token)    | %s(%s)\",\r\n\t\t\t\t\t     recursion_level, *codepage_stag, peek & 0x0f, Indent (recursion_level), str);\r\n\t\t\toff++;\r\n\t\t\tbreak;\r\n\t\tcase 0xC3: /* OPAQUE - WBXML 1.1 and newer */\r\n\t\t\tif (tvb_get_uint8 (tvb, 0)) { /* WBXML 1.x (x > 0) */\r\n\t\t\t\tif (map != NULL)\r\n\t\t\t\t{\r\n\t\t\t\t\tchar *tmp_str;\r\n\t\t\t\t\tif (tag_save_known) { /* Known tag */\r\n\t\t\t\t\t\tif (map->opaque_binary_tag) {\r\n\t\t\t\t\t\t\ttmp_str = map->opaque_binary_tag(tvb, off + 1,\r\n\t\t\t\t\t\t\t\t\t\t     tag_save_known, *codepage_stag, &len, pinfo);\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\ttmp_str = default_opaque_binary_tag(tvb, off + 1,\r\n\t\t\t\t\t\t\t\t\t\t\ttag_save_known, *codepage_stag, &len, pinfo);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else { /* lITERAL tag */\r\n\t\t\t\t\t\tif (map->opaque_literal_tag) {\r\n\t\t\t\t\t\t\ttmp_str = map->opaque_literal_tag(tvb, off + 1,\r\n\t\t\t\t\t\t\t\t\t\t      tag_save_literal, *codepage_stag, &len, pinfo);\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\ttmp_str = default_opaque_literal_tag(tvb, off + 1,\r\n\t\t\t\t\t\t\t\t\t\t\t tag_save_literal, *codepage_stag, &len, pinfo);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tproto_tree_add_bytes_format(tree, hf_wbxml_opaque_data, tvb, off, 1 + len, NULL,\r\n\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    | OPAQUE (Opaque data)            | %s%s\",\r\n\t\t\t\t\t\t     recursion_level, *codepage_stag, Indent (recursion_level), tmp_str);\r\n\t\t\t\t\toff += 1 + len;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tidx = tvb_get_uintvar (tvb, off+1, &len, pinfo, &ei_wbxml_oversized_uintvar);\r\n\t\t\t\t\tif ((len <= tvb_len) && (idx < tvb_len))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tproto_tree_add_bytes_format(tree, hf_wbxml_opaque_data, tvb, off, 1 + len + idx, NULL,\r\n\t\t\t\t\t\t         \"  %3d | Tag   | T %3d    | OPAQUE (Opaque data)            | %s(%u bytes of opaque data)\",\r\n\t\t\t\t\t\t         recursion_level, *codepage_stag, Indent (recursion_level), idx);\r\n\t\t\t\t\t\toff += 1+len+idx;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t/* Stop processing as it is impossible to parse now */\r\n\t\t\t\t\t\toff = tvb_len;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} else { /* WBXML 1.0 - RESERVED_2 token (invalid) */\r\n\t\t\t\tproto_tree_add_none_format(tree, hf_wbxml_reserved_2, tvb, off, 1,\r\n\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    | RESERVED_2     (Invalid Token!) | WBXML 1.0 parsing stops here.\",\r\n\t\t\t\t\t\t     recursion_level, *codepage_stag);\r\n\t\t\t\t/* Stop processing as it is impossible to parse now */\r\n\t\t\t\toff = tvb_len;\r\n\t\t\t\tDebugLog((\"STAG: level = %u, Return: len = %u\\n\", recursion_level, off - offset));\r\n\t\t\t\treturn (off - offset);\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\r\n\t\t\t/* No default clause, as all cases have been treated */\r\n\t\t} else { /* LITERAL or Known TAG */\r\n\t\t\t/* We must store the initial tag, and also retrieve the new tag.\r\n\t\t\t * For efficiency reasons, we store the literal tag representation\r\n\t\t\t * for known tags too, so we can easily close the tag without the\r\n\t\t\t * need of a new lookup and avoiding storage of token codepage.\r\n\t\t\t *\r\n\t\t\t * There are 4 possibilities:\r\n\t\t\t *\r\n\t\t\t *  1. Known tag followed by a known tag\r\n\t\t\t *  2. Known tag followed by a LITERAL tag\r\n\t\t\t *  3. LITERAL tag followed by Known tag\r\n\t\t\t *  4. LITERAL tag followed by LITERAL tag\r\n\t\t\t */\r\n\r\n\t\t\t/* Store the new tag */\r\n\t\t\ttag_len = 0;\r\n\t\t\tif ((peek & 0x3F) == 4) { /* LITERAL */\r\n\t\t\t\tDebugLog((\"STAG: LITERAL tag (peek = 0x%02X, off = %u) - TableRef follows!\\n\", peek, off));\r\n\t\t\t\tidx = tvb_get_uintvar (tvb, off+1, &tag_len, pinfo, &ei_wbxml_oversized_uintvar);\r\n\t\t\t\ttag_new_literal = tvb_get_stringz_enc(pinfo->pool, tvb, str_tbl+idx, &str_len, encoding);\r\n\t\t\t\ttag_new_known = 0; /* invalidate known tag_new */\r\n\t\t\t} else { /* Known tag */\r\n\t\t\t\ttag_new_known = peek & 0x3F;\r\n\t\t\t\tif (map != NULL) {\r\n\t\t\t\t\ttag_new_literal = map_token (map->tags, *codepage_stag,\r\n\t\t\t\t\t\t\t     tag_new_known);\r\n\t\t\t\t} else {\r\n\t\t\t\t\ttag_new_literal = wmem_strdup_printf(pinfo->pool, \"Tag_0x%02X\",\r\n\t\t\t\t\t\t\ttag_new_known);\r\n\t\t\t\t}\r\n\t\t\t\t/* Stored looked up tag name string */\r\n\t\t\t}\r\n\r\n\t\t\t/* Parsing of TAG starts HERE */\r\n\t\t\tif (peek & 0x40) { /* Content present */\r\n\t\t\t\t/* Content follows\r\n\t\t\t\t * [!] An explicit END token is expected in these cases!\r\n\t\t\t\t * ==> Recursion possible if we encounter a tag with content;\r\n\t\t\t\t *     recursion will return at the explicit END token.\r\n\t\t\t\t */\r\n\t\t\t\tif (parsing_tag_content) { /* Recurse */\r\n\t\t\t\t\tDebugLog((\"STAG: Tag in Tag - RECURSE! (off = %u)\\n\", off));\r\n\t\t\t\t\t/* Do not process the attribute list:\r\n\t\t\t\t\t * recursion will take care of it */\r\n\t\t\t\t\tp_set_proto_depth(pinfo, proto_wbxml, recursion_level + 1);\r\n\t\t\t\t\tlen = parse_wbxml_tag_defined (tree, tvb, pinfo, off, str_tbl,\r\n\t\t\t\t\t\t\t\t       codepage_stag, codepage_attr, map);\r\n\t\t\t\t\toff += len;\r\n\t\t\t\t} else { /* Now we will have content to parse */\r\n\t\t\t\t\t/* Save the start tag so we can properly close it later. */\r\n\t\t\t\t\tif ((peek & 0x3F) == 4) { /* Literal tag */\r\n\t\t\t\t\t\ttag_save_literal = tag_new_literal;\r\n\t\t\t\t\t\ttag_save_known = 0;\r\n\t\t\t\t\t} else { /* Known tag */\r\n\t\t\t\t\t\ttag_save_known = tag_new_known;\r\n\t\t\t\t\t\ttag_save_literal = tag_new_literal;\r\n\t\t\t\t\t\t/* The last statement avoids needless lookups */\r\n\t\t\t\t\t}\r\n\t\t\t\t\t/* Process the attribute list if present */\r\n\t\t\t\t\tif (peek & 0x80) { /* Content and Attribute list present */\r\n\t\t\t\t\t\tif (tag_new_known) { /* Known tag */\r\n\t\t\t\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_known_tag, tvb, off, 1, tag_new_literal,\r\n\t\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    |   Known Tag 0x%02X           (AC) | %s<%s\",\r\n\t\t\t\t\t\t\t\t\t     recursion_level, *codepage_stag, tag_new_known,\r\n\t\t\t\t\t\t\t\t\t     Indent (recursion_level), tag_new_literal);\r\n\t\t\t\t\t\t\t/* Tag string already looked up earlier! */\r\n\t\t\t\t\t\t\toff++;\r\n\t\t\t\t\t\t} else { /* LITERAL tag */\r\n\t\t\t\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_literal_ac, tvb, off, 1, tag_new_literal,\r\n\t\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    | LITERAL_AC (Literal tag)   (AC) | %s<%s\",\r\n\t\t\t\t\t\t\t\t\t     recursion_level, *codepage_stag, Indent (recursion_level), tag_new_literal);\r\n\t\t\t\t\t\t\toff += 1 + tag_len;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tlen = parse_wbxml_attribute_list_defined (tree, tvb, pinfo,\r\n\t\t\t\t\t\t\t\t\t\t\t  off, str_tbl, codepage_attr, map);\r\n\t\t\t\t\t\t/* Check that there is still room in packet */\r\n\t\t\t\t\t\toff += len;\r\n\t\t\t\t\t\tif (off >= tvb_len) {\r\n\t\t\t\t\t\t\tDebugLog((\"STAG: level = %u, ThrowException: len = %u (short frame)\\n\",\r\n\t\t\t\t\t\t\t\t  recursion_level, off - offset));\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tproto_tree_add_none_format(tree, hf_wbxml_end_attribute_list, tvb, off-1, 1,\r\n\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    | END (attribute list)            | %s>\",\r\n\t\t\t\t\t\t\t\t     recursion_level, *codepage_stag, Indent (recursion_level));\r\n\t\t\t\t\t} else { /* Content, no Attribute list */\r\n\t\t\t\t\t\tif (tag_new_known) { /* Known tag */\r\n\t\t\t\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_known_tag, tvb, off, 1, tag_new_literal,\r\n\t\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    |   Known Tag 0x%02X           (.C) | %s<%s>\",\r\n\t\t\t\t\t\t\t\t\t     recursion_level, *codepage_stag, tag_new_known,\r\n\t\t\t\t\t\t\t\t\t     Indent (recursion_level), tag_new_literal);\r\n\t\t\t\t\t\t\t/* Tag string already looked up earlier! */\r\n\t\t\t\t\t\t\toff++;\r\n\t\t\t\t\t\t} else { /* LITERAL tag */\r\n\t\t\t\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_literal_c, tvb, off, 1, tag_new_literal,\r\n\t\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    | LITERAL_C  (Literal Tag)   (.C) | %s<%s>\",\r\n\t\t\t\t\t\t\t\t\t     recursion_level, *codepage_stag, Indent (recursion_level), tag_new_literal);\r\n\t\t\t\t\t\t\toff += 1 + tag_len;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\t/* The data that follows in the parsing process\r\n\t\t\t\t\t * represents content for the opening tag\r\n\t\t\t\t\t * we've just processed in the lines above.\r\n\t\t\t\t\t * Next time we encounter a tag with content: recurse\r\n\t\t\t\t\t */\r\n\t\t\t\t\tparsing_tag_content = true;\r\n\t\t\t\t\tDebugLog((\"Tag in Tag - No recursion this time! (off = %u)\\n\", off));\r\n\t\t\t\t}\r\n\t\t\t} else { /* No Content */\r\n\t\t\t\tDebugLog((\"<Tag/> in Tag - No recursion! (off = %u)\\n\", off));\r\n\t\t\t\trecursion_level++;\r\n\t\t\t\tp_set_proto_depth(pinfo, proto_wbxml, recursion_level);\r\n\t\t\t\tif (peek & 0x80) { /* No Content, Attribute list present */\r\n\t\t\t\t\tif (tag_new_known) { /* Known tag */\r\n\t\t\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_known_tag, tvb, off, 1, tag_new_literal,\r\n\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    |   Known Tag 0x%02X           (A.) | %s<%s\",\r\n\t\t\t\t\t\t\t\t     recursion_level, *codepage_stag, tag_new_known,\r\n\t\t\t\t\t\t\t\t     Indent (recursion_level), tag_new_literal);\r\n\t\t\t\t\t\t/* Tag string already looked up earlier! */\r\n\t\t\t\t\t\toff++;\r\n\t\t\t\t\t\tlen = parse_wbxml_attribute_list_defined (tree, tvb, pinfo,\r\n\t\t\t\t\t\t\t\t\t\t\t  off, str_tbl, codepage_attr, map);\r\n\t\t\t\t\t\t/* Check that there is still room in packet */\r\n\t\t\t\t\t\toff += len;\r\n\t\t\t\t\t\tif (off > tvb_len) {\r\n\t\t\t\t\t\t\tDebugLog((\"STAG: level = %u, ThrowException: len = %u (short frame)\\n\",\r\n\t\t\t\t\t\t\t\t\t\trecursion_level, off - offset));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tproto_tree_add_uint_format(tree, hf_wbxml_end_known_tag_uint, tvb, off-1, 1, *codepage_stag,\r\n\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    | END (Known Tag)                 | %s/>\",\r\n\t\t\t\t\t\t\t\t     recursion_level, *codepage_stag, Indent (recursion_level));\r\n\t\t\t\t\t} else { /* LITERAL tag */\r\n\t\t\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_literal_a, tvb, off, 1, tag_new_literal,\r\n\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    | LITERAL_A  (Literal Tag)   (A.) | %s<%s\",\r\n\t\t\t\t\t\t\t\t     recursion_level, *codepage_stag, Indent (recursion_level), tag_new_literal);\r\n\t\t\t\t\t\toff += 1 + tag_len;\r\n\t\t\t\t\t\tlen = parse_wbxml_attribute_list_defined (tree, tvb, pinfo,\r\n\t\t\t\t\t\t\t\t\t\t\t  off, str_tbl, codepage_attr, map);\r\n\t\t\t\t\t\t/* Check that there is still room in packet */\r\n\t\t\t\t\t\toff += len;\r\n\t\t\t\t\t\tif (off >= tvb_len) {\r\n\t\t\t\t\t\t\tDebugLog((\"STAG: level = %u, ThrowException: len = %u (short frame)\\n\",\r\n\t\t\t\t\t\t\t\t\t\trecursion_level, off - offset));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_end_literal_tag, tvb, off-1, 1, \"\",\r\n\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    | END (Literal Tag)               | %s/>\",\r\n\t\t\t\t\t\t\t\t     recursion_level, *codepage_stag, Indent (recursion_level));\r\n\t\t\t\t\t}\r\n\t\t\t\t} else { /* No Content, No Attribute list */\r\n\t\t\t\t\tif (tag_new_known) { /* Known tag */\r\n\t\t\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_known_tag, tvb, off, 1, tag_new_literal,\r\n\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    |   Known Tag 0x%02x           (..) | %s<%s />\",\r\n\t\t\t\t\t\t\t\t     recursion_level, *codepage_stag, tag_new_known,\r\n\t\t\t\t\t\t\t\t     Indent (recursion_level), tag_new_literal);\r\n\t\t\t\t\t\t/* Tag string already looked up earlier! */\r\n\t\t\t\t\t\toff++;\r\n\t\t\t\t\t} else { /* LITERAL tag */\r\n\t\t\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_literal, tvb, off, 1, tag_new_literal,\r\n\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    | LITERAL    (Literal Tag)   (..) | %s<%s />\",\r\n\t\t\t\t\t\t\t\t     recursion_level, *codepage_stag, Indent (recursion_level),\r\n\t\t\t\t\t\t\t\t     tag_new_literal);\r\n\t\t\t\t\t\toff += 1 + tag_len;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\trecursion_level--;\r\n\t\t\t\tp_set_proto_depth(pinfo, proto_wbxml, recursion_level);\r\n\t\t\t\t/* TODO: Do I have to reset code page here? */\r\n\t\t\t}\r\n\t\t} /* if (tag & 0x3F) >= 5 */\r\n\t} /* while */\r\n\tDebugLog((\"STAG: level = %u, Return: len = %u (end of function body)\\n\", recursion_level, off - offset));\r\n\treturn (off - offset);\r\n}", ".issect_wbxml_common": "static void\r\ndissect_wbxml_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\r\n\t\t     const wbxml_decoding *override_content_map)\r\n{\r\n\t/* Set up structures needed to add the protocol subtree and manage it */\r\n\tproto_item           *ti;\r\n\tproto_tree           *wbxml_tree;          /* Main WBXML tree */\r\n\tproto_tree           *wbxml_str_tbl_tree;  /* String table subtree */\r\n\tproto_tree           *wbxml_content_tree;  /* Content subtree */\r\n\tproto_tree           *tag_tree;\r\n\tuint8_t               version;\r\n\tunsigned              offset          = 0;\r\n\tuint32_t              len;\r\n\tuint32_t              charset         = 0;\r\n\tuint32_t              charset_len     = 0;\r\n\tunsigned              encoding;\r\n\tuint32_t              publicid;\r\n\tuint32_t              publicid_index  = 0;\r\n\tuint32_t              publicid_len;\r\n\tuint32_t              str_tbl;\r\n\tuint32_t              str_tbl_len;\r\n\tuint32_t              str_tbl_len_len = 0;\r\n\tconst wbxml_decoding *content_map     = NULL;\r\n\tchar                 *summary         = NULL;\r\n\tuint8_t               codepage_stag   = 0;\r\n\tuint8_t               codepage_attr   = 0;\r\n\r\n\tDebugLog((\"dissect_wbxml: Dissecting packet %u\\n\", pinfo->num));\r\n\t/* WBXML format\r\n\t *\r\n\t * Version 1.0: version publicid         strtbl BODY\r\n\t * Version 1.x: version publicid charset strtbl BODY\r\n\t *\r\n\t * Last valid format: WBXML 1.3\r\n\t */\r\n\tswitch ( version = tvb_get_uint8 (tvb, 0) ) {\r\n\tcase 0x00: /* WBXML/1.0 */\r\n\t\tbreak;\r\n\r\n\tcase 0x01: /* WBXML/1.1 */\r\n\tcase 0x02: /* WBXML/1.2 */\r\n\tcase 0x03: /* WBXML/1.3 */\r\n\t\tbreak;\r\n\r\n\tdefault:\r\n\t\t/* Put some information here, so that the user knows what's going on. */\r\n\r\n\t\t/* Add summary to INFO column if it is enabled */\r\n\t\tcol_append_fstr(pinfo->cinfo, COL_INFO, \" (Unknown WBXML version 0x%02x)\", version);\r\n\t\tti = proto_tree_add_item (tree, proto_wbxml, tvb, 0, -1, ENC_NA);\r\n\t\tproto_item_append_text(ti, \", Unknown version 0x%02x\", version);\r\n\t\treturn;\r\n\t}\r\n\r\n\t/* In order to properly construct the packet summary,\r\n\t * I need to read the entire WBXML header\r\n\t * up to the string table length.\r\n\t */\r\n\r\n\t/* Public ID */\r\n\tpublicid = tvb_get_uintvar(tvb, 1, &publicid_len, pinfo, &ei_wbxml_oversized_uintvar);\r\n\tif (! publicid) {\r\n\t\t/* Public identifier in string table */\r\n\t\tpublicid_index = tvb_get_uintvar (tvb, 1+publicid_len, &len, pinfo, &ei_wbxml_oversized_uintvar);\r\n\t\tpublicid_len += len;\r\n\t}\r\n\toffset = 1 + publicid_len;\r\n\r\n\t/* Version-specific handling of Charset */\r\n\tswitch ( version ) {\r\n\tcase 0x00: /* WBXML/1.0 */\r\n\t\t/* No charset */\r\n\t\tbreak;\r\n\r\n\tcase 0x01: /* WBXML/1.1 */\r\n\tcase 0x02: /* WBXML/1.2 */\r\n\tcase 0x03: /* WBXML/1.3 */\r\n\t\t/* Get charset */\r\n\t\tcharset = tvb_get_uintvar (tvb, offset, &charset_len, pinfo, &ei_wbxml_oversized_uintvar);\r\n\t\toffset += charset_len;\r\n\t\tbreak;\r\n\r\n\tdefault: /* Impossible since we returned already earlier */\r\n\t\tDISSECTOR_ASSERT_NOT_REACHED();\r\n\t\tbreak;\r\n\t}\r\n\r\n\tif (charset) {\r\n\t\tencoding = mibenum_charset_to_encoding(charset);\r\n\t} else {\r\n\t\t/* XXX: If the charset is 0 we should look if there is a charset\r\n\t\t * parameter in the Content-Type / media_type if passed to\r\n\t\t * the dissector. Otherwise the default is UTF-8.\r\n\t\t */\r\n\t\tencoding = ENC_UTF_8;\r\n\t}\r\n\tp_add_proto_data(pinfo->pool, pinfo, proto_wbxml, 0, GUINT_TO_POINTER(encoding));\r\n\r\n\t/* String table: read string table length in bytes */\r\n\ttvb_get_uintvar (tvb, offset, &str_tbl_len_len, pinfo, &ei_wbxml_oversized_uintvar);\r\n\tstr_tbl = offset + str_tbl_len_len; /* Start of 1st string in string table */\r\n\r\n\t/* Compose the summary line */\r\n\tif ( publicid ) {\r\n\t\tsummary = wmem_strdup_printf(pinfo->pool, \"%s, Public ID: \\\"%s\\\"\",\r\n\t\t\t\t\t  val_to_str_ext(pinfo->pool, version, &vals_wbxml_versions_ext, \"(unknown 0x%x)\"),\r\n\t\t\t\t\t  val_to_str_ext(pinfo->pool, publicid, &vals_wbxml_public_ids_ext, \"(unknown 0x%x)\"));\r\n\t} else {\r\n\t\t/* Read length of Public ID from string table */\r\n\t\tsummary = wmem_strdup_printf(pinfo->pool, \"%s, Public ID: \\\"%s\\\"\",\r\n\t\t\t\t\t  val_to_str_ext(pinfo->pool, version, &vals_wbxml_versions_ext, \"(unknown 0x%x)\"),\r\n\t\t\t\t\t  tvb_get_stringz_enc(pinfo->pool, tvb, str_tbl + publicid_index, &len, encoding));\r\n\t}\r\n\r\n\t/* Add summary to INFO column if it is enabled */\r\n\tcol_append_fstr(pinfo->cinfo, COL_INFO, \" (WBXML %s)\", summary);\r\n\r\n\t/* create display subtree for the protocol */\r\n\tti = proto_tree_add_item (tree, proto_wbxml, tvb, 0, -1, ENC_NA);\r\n\tproto_item_append_text(ti, \", Version: %s\", summary);\r\n\r\n\t/*\r\n\t * Now show the protocol subtree, if tree is set.\r\n\t */\r\n\twbxml_tree = proto_item_add_subtree(ti, ett_wbxml);\r\n\r\n\t/* WBXML Version */\r\n\tproto_tree_add_uint (wbxml_tree, hf_wbxml_version,\r\n\t\t\t\t    tvb, 0, 1, version);\r\n\r\n\t/* Public ID */\r\n\tif (publicid) { /* Known Public ID */\r\n\t\tproto_tree_add_uint(wbxml_tree, hf_wbxml_public_id_known,\r\n\t\t\t\t\ttvb, 1, publicid_len, publicid);\r\n\t} else { /* Public identifier in string table */\r\n\t\tproto_tree_add_item (wbxml_tree, hf_wbxml_public_id_literal,\r\n\t\t\t\t\t    tvb, 1, publicid_len, ENC_ASCII);\r\n\t}\r\n\toffset = 1 + publicid_len;\r\n\r\n\tif ( charset ) { /* Charset */\r\n\t\tproto_tree_add_uint (wbxml_tree, hf_wbxml_charset,\r\n\t\t\t\t\t    tvb, 1 + publicid_len, charset_len, charset);\r\n\t\toffset += charset_len;\r\n\t}\r\n\r\n\tstr_tbl_len = tvb_get_uintvar (tvb, offset, &len, pinfo, &ei_wbxml_oversized_uintvar);\r\n\tstr_tbl = offset + len; /* Start of 1st string in string table */\r\n\r\n\t/* String Table */\r\n\twbxml_str_tbl_tree = proto_tree_add_subtree_format(wbxml_tree,\r\n\t\t\t\t\ttvb, offset, len + str_tbl_len, ett_wbxml_str_tbl, NULL, \"String table: %u bytes\",\r\n\t\t\t\t\tstr_tbl_len);\r\n\r\n\tif (str_tbl_len) { /* Display string table as subtree */\r\n\t\tshow_wbxml_string_table (wbxml_str_tbl_tree, pinfo, tvb,\r\n\t\t\t\t\t\tstr_tbl, str_tbl_len,\r\n\t\t\t\t\t\tcharset);\r\n\t}\r\n\r\n\t/* Data starts HERE */\r\n\toffset += len + str_tbl_len;\r\n\r\n\twbxml_content_tree = proto_tree_add_subtree(wbxml_tree, tvb, offset, -1,\r\n\t\t\t\t\tett_wbxml_content, &ti, \"Data representation\");\r\n\t/* The WBXML BODY starts here */\r\n\tif (disable_wbxml_token_parsing) {\r\n\t\texpert_add_info(pinfo, ti, &ei_wbxml_data_not_shown);\r\n\t\treturn;\r\n\t}\r\n\r\n\t/* The parse_wbxml_X() functions will process the content correctly,\r\n\t\t* irrespective of the WBXML version used. For the WBXML body, this\r\n\t\t* means that there is a different processing for the global token\r\n\t\t* RESERVED_2 (WBXML 1.0) or OPAQUE (WBXML 1.x with x > 0).  */\r\n\tif (override_content_map != NULL) {\r\n\t\tcontent_map = override_content_map;\r\n\t\tproto_item_append_text(ti,\r\n\t\t\t\t\t\t\" is based on: %s\",\r\n\t\t\t\t\t\tcontent_map->name);\r\n\t} else {\r\n\t\t/* Retrieve the content token mapping if available */\r\n\t\tcontent_map = get_wbxml_decoding_from_public_id (publicid);\r\n\t\tif (! content_map) {\r\n\t\t\tcontent_map = get_wbxml_decoding_from_content_type(\r\n\t\t\t\t\t\t\t\t\t\tpinfo->match_string, tvb, offset);\r\n\t\t\tif (! content_map) {\r\n\t\t\t\texpert_add_info(pinfo, ti, &ei_wbxml_content_type_not_supported);\r\n\t\t\t} else {\r\n\t\t\t\tproto_item_append_text(ti,\r\n\t\t\t\t\t\t\t\t\" is based on Content-Type: %s \"\r\n\t\t\t\t\t\t\t\t\"(chosen decoding: %s)\",\r\n\t\t\t\t\t\t\t\tpinfo->match_string, content_map->name);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tif (content_map && skip_wbxml_token_mapping) {\r\n\t\texpert_add_info(pinfo, ti, &ei_wbxml_content_type_disabled);\r\n\t\tcontent_map = NULL;\r\n\t}\r\n\ttag_tree = proto_tree_add_subtree(wbxml_content_tree, tvb, offset, -1, ett_wbxml_tags, NULL,\r\n\t\t\t\t\t\"Level | State | Codepage | WBXML Token Description         | Rendering\");\r\n\r\n\t/* If content_map == NULL, WBXML only, no interpretation of the content */\r\n\tparse_wbxml_tag_defined (tag_tree,\r\n\t\t\t\t\t\t\ttvb, pinfo, offset, str_tbl, &codepage_stag,\r\n\t\t\t\t\t\t\t&codepage_attr, content_map);\r\n}", ".issect_wbxml": "static int\r\ndissect_wbxml(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\n\tdissect_wbxml_common(tvb, pinfo, tree, NULL);\r\n\treturn tvb_captured_length(tvb);\r\n}", ".issect_uaprof": "static int\r\ndissect_uaprof(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\n\tdissect_wbxml_common(tvb, pinfo, tree, &decode_uaprof_wap_248);\r\n\treturn tvb_captured_length(tvb);\r\n}"}, "callee": {".issect_wbxml_common": "static void\r\ndissect_wbxml_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\r\n\t\t     const wbxml_decoding *override_content_map)\r\n{\r\n\t/* Set up structures needed to add the protocol subtree and manage it */\r\n\tproto_item           *ti;\r\n\tproto_tree           *wbxml_tree;          /* Main WBXML tree */\r\n\tproto_tree           *wbxml_str_tbl_tree;  /* String table subtree */\r\n\tproto_tree           *wbxml_content_tree;  /* Content subtree */\r\n\tproto_tree           *tag_tree;\r\n\tuint8_t               version;\r\n\tunsigned              offset          = 0;\r\n\tuint32_t              len;\r\n\tuint32_t              charset         = 0;\r\n\tuint32_t              charset_len     = 0;\r\n\tunsigned              encoding;\r\n\tuint32_t              publicid;\r\n\tuint32_t              publicid_index  = 0;\r\n\tuint32_t              publicid_len;\r\n\tuint32_t              str_tbl;\r\n\tuint32_t              str_tbl_len;\r\n\tuint32_t              str_tbl_len_len = 0;\r\n\tconst wbxml_decoding *content_map     = NULL;\r\n\tchar                 *summary         = NULL;\r\n\tuint8_t               codepage_stag   = 0;\r\n\tuint8_t               codepage_attr   = 0;\r\n\r\n\tDebugLog((\"dissect_wbxml: Dissecting packet %u\\n\", pinfo->num));\r\n\t/* WBXML format\r\n\t *\r\n\t * Version 1.0: version publicid         strtbl BODY\r\n\t * Version 1.x: version publicid charset strtbl BODY\r\n\t *\r\n\t * Last valid format: WBXML 1.3\r\n\t */\r\n\tswitch ( version = tvb_get_uint8 (tvb, 0) ) {\r\n\tcase 0x00: /* WBXML/1.0 */\r\n\t\tbreak;\r\n\r\n\tcase 0x01: /* WBXML/1.1 */\r\n\tcase 0x02: /* WBXML/1.2 */\r\n\tcase 0x03: /* WBXML/1.3 */\r\n\t\tbreak;\r\n\r\n\tdefault:\r\n\t\t/* Put some information here, so that the user knows what's going on. */\r\n\r\n\t\t/* Add summary to INFO column if it is enabled */\r\n\t\tcol_append_fstr(pinfo->cinfo, COL_INFO, \" (Unknown WBXML version 0x%02x)\", version);\r\n\t\tti = proto_tree_add_item (tree, proto_wbxml, tvb, 0, -1, ENC_NA);\r\n\t\tproto_item_append_text(ti, \", Unknown version 0x%02x\", version);\r\n\t\treturn;\r\n\t}\r\n\r\n\t/* In order to properly construct the packet summary,\r\n\t * I need to read the entire WBXML header\r\n\t * up to the string table length.\r\n\t */\r\n\r\n\t/* Public ID */\r\n\tpublicid = tvb_get_uintvar(tvb, 1, &publicid_len, pinfo, &ei_wbxml_oversized_uintvar);\r\n\tif (! publicid) {\r\n\t\t/* Public identifier in string table */\r\n\t\tpublicid_index = tvb_get_uintvar (tvb, 1+publicid_len, &len, pinfo, &ei_wbxml_oversized_uintvar);\r\n\t\tpublicid_len += len;\r\n\t}\r\n\toffset = 1 + publicid_len;\r\n\r\n\t/* Version-specific handling of Charset */\r\n\tswitch ( version ) {\r\n\tcase 0x00: /* WBXML/1.0 */\r\n\t\t/* No charset */\r\n\t\tbreak;\r\n\r\n\tcase 0x01: /* WBXML/1.1 */\r\n\tcase 0x02: /* WBXML/1.2 */\r\n\tcase 0x03: /* WBXML/1.3 */\r\n\t\t/* Get charset */\r\n\t\tcharset = tvb_get_uintvar (tvb, offset, &charset_len, pinfo, &ei_wbxml_oversized_uintvar);\r\n\t\toffset += charset_len;\r\n\t\tbreak;\r\n\r\n\tdefault: /* Impossible since we returned already earlier */\r\n\t\tDISSECTOR_ASSERT_NOT_REACHED();\r\n\t\tbreak;\r\n\t}\r\n\r\n\tif (charset) {\r\n\t\tencoding = mibenum_charset_to_encoding(charset);\r\n\t} else {\r\n\t\t/* XXX: If the charset is 0 we should look if there is a charset\r\n\t\t * parameter in the Content-Type / media_type if passed to\r\n\t\t * the dissector. Otherwise the default is UTF-8.\r\n\t\t */\r\n\t\tencoding = ENC_UTF_8;\r\n\t}\r\n\tp_add_proto_data(pinfo->pool, pinfo, proto_wbxml, 0, GUINT_TO_POINTER(encoding));\r\n\r\n\t/* String table: read string table length in bytes */\r\n\ttvb_get_uintvar (tvb, offset, &str_tbl_len_len, pinfo, &ei_wbxml_oversized_uintvar);\r\n\tstr_tbl = offset + str_tbl_len_len; /* Start of 1st string in string table */\r\n\r\n\t/* Compose the summary line */\r\n\tif ( publicid ) {\r\n\t\tsummary = wmem_strdup_printf(pinfo->pool, \"%s, Public ID: \\\"%s\\\"\",\r\n\t\t\t\t\t  val_to_str_ext(pinfo->pool, version, &vals_wbxml_versions_ext, \"(unknown 0x%x)\"),\r\n\t\t\t\t\t  val_to_str_ext(pinfo->pool, publicid, &vals_wbxml_public_ids_ext, \"(unknown 0x%x)\"));\r\n\t} else {\r\n\t\t/* Read length of Public ID from string table */\r\n\t\tsummary = wmem_strdup_printf(pinfo->pool, \"%s, Public ID: \\\"%s\\\"\",\r\n\t\t\t\t\t  val_to_str_ext(pinfo->pool, version, &vals_wbxml_versions_ext, \"(unknown 0x%x)\"),\r\n\t\t\t\t\t  tvb_get_stringz_enc(pinfo->pool, tvb, str_tbl + publicid_index, &len, encoding));\r\n\t}\r\n\r\n\t/* Add summary to INFO column if it is enabled */\r\n\tcol_append_fstr(pinfo->cinfo, COL_INFO, \" (WBXML %s)\", summary);\r\n\r\n\t/* create display subtree for the protocol */\r\n\tti = proto_tree_add_item (tree, proto_wbxml, tvb, 0, -1, ENC_NA);\r\n\tproto_item_append_text(ti, \", Version: %s\", summary);\r\n\r\n\t/*\r\n\t * Now show the protocol subtree, if tree is set.\r\n\t */\r\n\twbxml_tree = proto_item_add_subtree(ti, ett_wbxml);\r\n\r\n\t/* WBXML Version */\r\n\tproto_tree_add_uint (wbxml_tree, hf_wbxml_version,\r\n\t\t\t\t    tvb, 0, 1, version);\r\n\r\n\t/* Public ID */\r\n\tif (publicid) { /* Known Public ID */\r\n\t\tproto_tree_add_uint(wbxml_tree, hf_wbxml_public_id_known,\r\n\t\t\t\t\ttvb, 1, publicid_len, publicid);\r\n\t} else { /* Public identifier in string table */\r\n\t\tproto_tree_add_item (wbxml_tree, hf_wbxml_public_id_literal,\r\n\t\t\t\t\t    tvb, 1, publicid_len, ENC_ASCII);\r\n\t}\r\n\toffset = 1 + publicid_len;\r\n\r\n\tif ( charset ) { /* Charset */\r\n\t\tproto_tree_add_uint (wbxml_tree, hf_wbxml_charset,\r\n\t\t\t\t\t    tvb, 1 + publicid_len, charset_len, charset);\r\n\t\toffset += charset_len;\r\n\t}\r\n\r\n\tstr_tbl_len = tvb_get_uintvar (tvb, offset, &len, pinfo, &ei_wbxml_oversized_uintvar);\r\n\tstr_tbl = offset + len; /* Start of 1st string in string table */\r\n\r\n\t/* String Table */\r\n\twbxml_str_tbl_tree = proto_tree_add_subtree_format(wbxml_tree,\r\n\t\t\t\t\ttvb, offset, len + str_tbl_len, ett_wbxml_str_tbl, NULL, \"String table: %u bytes\",\r\n\t\t\t\t\tstr_tbl_len);\r\n\r\n\tif (str_tbl_len) { /* Display string table as subtree */\r\n\t\tshow_wbxml_string_table (wbxml_str_tbl_tree, pinfo, tvb,\r\n\t\t\t\t\t\tstr_tbl, str_tbl_len,\r\n\t\t\t\t\t\tcharset);\r\n\t}\r\n\r\n\t/* Data starts HERE */\r\n\toffset += len + str_tbl_len;\r\n\r\n\twbxml_content_tree = proto_tree_add_subtree(wbxml_tree, tvb, offset, -1,\r\n\t\t\t\t\tett_wbxml_content, &ti, \"Data representation\");\r\n\t/* The WBXML BODY starts here */\r\n\tif (disable_wbxml_token_parsing) {\r\n\t\texpert_add_info(pinfo, ti, &ei_wbxml_data_not_shown);\r\n\t\treturn;\r\n\t}\r\n\r\n\t/* The parse_wbxml_X() functions will process the content correctly,\r\n\t\t* irrespective of the WBXML version used. For the WBXML body, this\r\n\t\t* means that there is a different processing for the global token\r\n\t\t* RESERVED_2 (WBXML 1.0) or OPAQUE (WBXML 1.x with x > 0).  */\r\n\tif (override_content_map != NULL) {\r\n\t\tcontent_map = override_content_map;\r\n\t\tproto_item_append_text(ti,\r\n\t\t\t\t\t\t\" is based on: %s\",\r\n\t\t\t\t\t\tcontent_map->name);\r\n\t} else {\r\n\t\t/* Retrieve the content token mapping if available */\r\n\t\tcontent_map = get_wbxml_decoding_from_public_id (publicid);\r\n\t\tif (! content_map) {\r\n\t\t\tcontent_map = get_wbxml_decoding_from_content_type(\r\n\t\t\t\t\t\t\t\t\t\tpinfo->match_string, tvb, offset);\r\n\t\t\tif (! content_map) {\r\n\t\t\t\texpert_add_info(pinfo, ti, &ei_wbxml_content_type_not_supported);\r\n\t\t\t} else {\r\n\t\t\t\tproto_item_append_text(ti,\r\n\t\t\t\t\t\t\t\t\" is based on Content-Type: %s \"\r\n\t\t\t\t\t\t\t\t\"(chosen decoding: %s)\",\r\n\t\t\t\t\t\t\t\tpinfo->match_string, content_map->name);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tif (content_map && skip_wbxml_token_mapping) {\r\n\t\texpert_add_info(pinfo, ti, &ei_wbxml_content_type_disabled);\r\n\t\tcontent_map = NULL;\r\n\t}\r\n\ttag_tree = proto_tree_add_subtree(wbxml_content_tree, tvb, offset, -1, ett_wbxml_tags, NULL,\r\n\t\t\t\t\t\"Level | State | Codepage | WBXML Token Description         | Rendering\");\r\n\r\n\t/* If content_map == NULL, WBXML only, no interpretation of the content */\r\n\tparse_wbxml_tag_defined (tag_tree,\r\n\t\t\t\t\t\t\ttvb, pinfo, offset, str_tbl, &codepage_stag,\r\n\t\t\t\t\t\t\t&codepage_attr, content_map);\r\n}", ".arse_wbxml_tag_defined": "static uint32_t\r\n// NOLINTNEXTLINE(misc-no-recursion)\r\nparse_wbxml_tag_defined (proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo, uint32_t offset,\r\n\t\t\t uint32_t str_tbl, uint8_t *codepage_stag, uint8_t *codepage_attr,\r\n\t\t\t const wbxml_decoding *map)\r\n{\r\n\tuint32_t     tvb_len  = tvb_reported_length (tvb);\r\n\tuint32_t     off      = offset;\r\n\tuint32_t     len;\r\n\tunsigned     str_len;\r\n\tuint32_t     ent;\r\n\tuint32_t     idx;\r\n\tuint8_t      peek;\r\n\tuint32_t     tag_len;                     /* Length of the index (uintvar) from a LITERAL tag */\r\n\tuint8_t      tag_save_known      = 0;     /* Will contain peek & 0x3F (tag identity) */\r\n\tuint8_t      tag_new_known       = 0;     /* Will contain peek & 0x3F (tag identity) */\r\n\tconst char  *tag_save_literal    = NULL;  /* Will contain the LITERAL tag identity */\r\n\tconst char  *tag_new_literal;             /* Will contain the LITERAL tag identity */\r\n\tconst char *str;\r\n\tuint8_t      parsing_tag_content = false; /* Are we parsing content from a\r\n\t\t\t\t\t\t     tag with content: <x>Content</x>\r\n\r\n\t\t\t\t\t\t     The initial state is false.\r\n\t\t\t\t\t\t     This state will trigger recursion. */\r\n\r\n\tunsigned     recursion_level = p_get_proto_depth(pinfo, proto_wbxml);\r\n\tunsigned     encoding = GPOINTER_TO_UINT(p_get_proto_data(pinfo->pool, pinfo, proto_wbxml, 0));\r\n\tif (recursion_level >= WBXML_MAX_RECURSION_LEVEL) {\r\n\t\tproto_tree_add_expert(tree, pinfo, &ei_wbxml_too_much_recursion, tvb, offset, tvb_captured_length_remaining(tvb, offset));\r\n\t\treturn tvb_len;\r\n\t}\r\n\tDebugLog((\"parse_wbxml_tag_defined (level = %u, offset = %u)\\n\", recursion_level, offset));\r\n\twhile (off < tvb_len) {\r\n\t\tpeek = tvb_get_uint8 (tvb, off);\r\n\t\tDebugLog((\"STAG: (top of while) level = %3u, peek = 0x%02X, off = %u, tvb_len = %u\\n\", recursion_level, peek, off, tvb_len));\r\n\t\tif ((peek & 0x3F) < 4) switch (peek) { /* Global tokens in state = STAG\r\n\t\t\t\t\t\t\t  but not the LITERAL tokens */\r\n\t\tcase 0x00: /* SWITCH_PAGE */\r\n\t\t\t*codepage_stag = tvb_get_uint8 (tvb, off+1);\r\n\t\t\tproto_tree_add_uint_format(tree, hf_wbxml_switch_page, tvb, off, 2, *codepage_stag,\r\n\t\t\t\t\t     \"      | Tag   | T -->%3d | SWITCH_PAGE (Tag code page)     |\",\r\n\t\t\t\t\t     *codepage_stag);\r\n\t\t\toff += 2;\r\n\t\t\tbreak;\r\n\t\tcase 0x01: /* END: only possible for Tag with Content */\r\n\t\t\tif (tag_save_known) { /* Known TAG */\r\n\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_end_known_tag, tvb, off, 1, tag_save_literal,\r\n\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    | END (Known Tag 0x%02X)            | %s</%s>\",\r\n\t\t\t\t\t\t     recursion_level, *codepage_stag,\r\n\t\t\t\t\t\t     tag_save_known, Indent (recursion_level),\r\n\t\t\t\t\t\t     tag_save_literal); /* We already looked it up! */\r\n\t\t\t} else { /* Literal TAG */\r\n\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_end_literal_tag, tvb, off, 1, tag_save_literal ? tag_save_literal : \"\",\r\n\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    | END (Literal Tag)               | %s</%s>\",\r\n\t\t\t\t\t\t     recursion_level, *codepage_stag, Indent (recursion_level), tag_save_literal ? tag_save_literal : \"\");\r\n\t\t\t}\r\n\t\t\trecursion_level--;\r\n\t\t\tp_set_proto_depth(pinfo, proto_wbxml, recursion_level);\r\n\t\t\toff++;\r\n\t\t\t/* Reset code page: not needed as return from recursion */\r\n\t\t\tDebugLog((\"STAG: level = %u, Return: len = %u\\n\", recursion_level, off - offset));\r\n\t\t\treturn (off - offset);\r\n\t\tcase 0x02: /* ENTITY */\r\n\t\t\tent = tvb_get_uintvar (tvb, off+1, &len, pinfo, &ei_wbxml_oversized_uintvar);\r\n\t\t\tproto_tree_add_uint_format(tree, hf_wbxml_entity, tvb, off, 1+len, ent,\r\n\t\t\t\t\t     \"  %3d | Tag   | T %3d    | ENTITY                          | %s'&#%u;'\",\r\n\t\t\t\t\t     recursion_level, *codepage_stag, Indent (recursion_level), ent);\r\n\t\t\toff += 1+len;\r\n\t\t\tbreak;\r\n\t\tcase 0x03: /* STR_I */\r\n\t\t\tstr = tvb_get_stringz_enc(pinfo->pool, tvb, off+1, &len, encoding);\r\n\t\t\tproto_tree_add_string_format(tree, hf_wbxml_str_i, tvb, off, 1+len, str,\r\n\t\t\t\t\t     \"  %3d | Tag   | T %3d    | STR_I (Inline string)           | %s\\'%s\\'\",\r\n\t\t\t\t\t     recursion_level, *codepage_stag, Indent(recursion_level),\r\n\t\t\t\t\t     str);\r\n\t\t\toff += 1+len;\r\n\t\t\tbreak;\r\n\t\tcase 0x40: /* EXT_I_0 */\r\n\t\tcase 0x41: /* EXT_I_1 */\r\n\t\tcase 0x42: /* EXT_I_2 */\r\n\t\t\t/* Extension tokens */\r\n\t\t\tstr = tvb_get_stringz_enc(pinfo->pool, tvb, off+1, &len, encoding);\r\n\t\t\tproto_tree_add_string_format(tree, hf_wbxml_ext_i, tvb, off, 1+len, str,\r\n\t\t\t\t\t     \"  %3d | Tag   | T %3d    | EXT_I_%1x    (Extension Token)    | %s(%s: \\'%s\\')\",\r\n\t\t\t\t\t     recursion_level, *codepage_stag,\r\n\t\t\t\t\t     peek & 0x0f, Indent (recursion_level),\r\n\t\t\t\t\t     ((map != NULL) ? map_token (map->global, 0, peek) : \"Inline string extension\"),\r\n\t\t\t\t\t     str);\r\n\t\t\toff += 1+len;\r\n\t\t\tbreak;\r\n\t\tcase 0x43: /* PI */\r\n\t\t\tproto_tree_add_none_format(tree, hf_wbxml_pi_xml, tvb, off, 1,\r\n\t\t\t\t\t     \"  %3d | Tag   | T %3d    | PI (XML Processing Instruction) | %s<?xml\",\r\n\t\t\t\t\t     recursion_level, *codepage_stag, Indent (recursion_level));\r\n\t\t\tlen = parse_wbxml_attribute_list_defined (tree, tvb, pinfo, off,\r\n\t\t\t\t\t\t\t\t  str_tbl, codepage_attr, map);\r\n\t\t\t/* Check that there is still room in packet */\r\n\t\t\toff += len;\r\n\t\t\tif (off >= tvb_len) {\r\n\t\t\t\tDebugLog((\"STAG: level = %u, ThrowException: len = %u (short frame)\\n\",\r\n\t\t\t\t\t\t\trecursion_level, off - offset));\r\n\t\t\t}\r\n\r\n\t\t\tproto_tree_add_none_format(tree, hf_wbxml_end_pi, tvb, off-1, 1,\r\n\t\t\t\t\t     \"  %3d | Tag   | T %3d    | END (PI)                        | %s?>\",\r\n\t\t\t\t\t     recursion_level, *codepage_stag, Indent (recursion_level));\r\n\t\t\tbreak;\r\n\t\tcase 0x80: /* EXT_T_0 */\r\n\t\tcase 0x81: /* EXT_T_1 */\r\n\t\tcase 0x82: /* EXT_T_2 */\r\n\t\t\t/* Extension tokens */\r\n\t\t\tidx = tvb_get_uintvar (tvb, off+1, &len, pinfo, &ei_wbxml_oversized_uintvar);\r\n\t\t\t{\r\n\t\t\t\tchar *s;\r\n\t\t\t\tif (map)\r\n\t\t\t\t{\r\n\t\t\t\t\tif (map->ext_t[peek & 0x03])\r\n\t\t\t\t\t\ts = (map->ext_t[peek & 0x03])(pinfo->pool, tvb, idx, str_tbl);\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\ts = wmem_strdup_printf(pinfo->pool, \"EXT_T_%1x (%s)\", peek & 0x03,\r\n\t\t\t\t\t\t\t        map_token (map->global, 0, peek));\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\ts = wmem_strdup_printf(pinfo->pool, \"(Extension Token, integer value: %u)\", idx);\r\n\t\t\t\t}\r\n\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_ext_t, tvb, off, 1+len, s,\r\n\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    | EXT_T_%1x    (Extension Token)    | %s%s\",\r\n\t\t\t\t\t\t     recursion_level, *codepage_stag, peek & 0x0f, Indent (recursion_level), s);\r\n\t\t\t}\r\n\t\t\toff += 1+len;\r\n\t\t\tbreak;\r\n\t\tcase 0x83: /* STR_T */\r\n\t\t\tidx = tvb_get_uintvar (tvb, off+1, &len, pinfo, &ei_wbxml_oversized_uintvar);\r\n\t\t\tstr = tvb_get_stringz_enc(pinfo->pool, tvb, str_tbl+idx, &str_len, encoding);\r\n\t\t\tproto_tree_add_string_format(tree, hf_wbxml_str_t, tvb, off, 1+len, str,\r\n\t\t\t\t\t     \"  %3d | Tag   | T %3d    | STR_T (Tableref string)         | %s\\'%s\\'\",\r\n\t\t\t\t\t     recursion_level, *codepage_stag, Indent (recursion_level), str);\r\n\t\t\toff += 1+len;\r\n\t\t\tbreak;\r\n\t\tcase 0xC0: /* EXT_0 */\r\n\t\tcase 0xC1: /* EXT_1 */\r\n\t\tcase 0xC2: /* EXT_2 */\r\n\t\t\t/* Extension tokens */\r\n\t\t\tstr = (map != NULL) ? map_token (map->global, 0, peek) : \"Single-byte extension\";\r\n\t\t\tproto_tree_add_string_format(tree, hf_wbxml_extension_token, tvb, off, 1, str,\r\n\t\t\t\t\t     \"  %3d | Tag   | T %3d    | EXT_%1x      (Extension Token)    | %s(%s)\",\r\n\t\t\t\t\t     recursion_level, *codepage_stag, peek & 0x0f, Indent (recursion_level), str);\r\n\t\t\toff++;\r\n\t\t\tbreak;\r\n\t\tcase 0xC3: /* OPAQUE - WBXML 1.1 and newer */\r\n\t\t\tif (tvb_get_uint8 (tvb, 0)) { /* WBXML 1.x (x > 0) */\r\n\t\t\t\tif (map != NULL)\r\n\t\t\t\t{\r\n\t\t\t\t\tchar *tmp_str;\r\n\t\t\t\t\tif (tag_save_known) { /* Known tag */\r\n\t\t\t\t\t\tif (map->opaque_binary_tag) {\r\n\t\t\t\t\t\t\ttmp_str = map->opaque_binary_tag(tvb, off + 1,\r\n\t\t\t\t\t\t\t\t\t\t     tag_save_known, *codepage_stag, &len, pinfo);\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\ttmp_str = default_opaque_binary_tag(tvb, off + 1,\r\n\t\t\t\t\t\t\t\t\t\t\ttag_save_known, *codepage_stag, &len, pinfo);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else { /* lITERAL tag */\r\n\t\t\t\t\t\tif (map->opaque_literal_tag) {\r\n\t\t\t\t\t\t\ttmp_str = map->opaque_literal_tag(tvb, off + 1,\r\n\t\t\t\t\t\t\t\t\t\t      tag_save_literal, *codepage_stag, &len, pinfo);\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\ttmp_str = default_opaque_literal_tag(tvb, off + 1,\r\n\t\t\t\t\t\t\t\t\t\t\t tag_save_literal, *codepage_stag, &len, pinfo);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tproto_tree_add_bytes_format(tree, hf_wbxml_opaque_data, tvb, off, 1 + len, NULL,\r\n\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    | OPAQUE (Opaque data)            | %s%s\",\r\n\t\t\t\t\t\t     recursion_level, *codepage_stag, Indent (recursion_level), tmp_str);\r\n\t\t\t\t\toff += 1 + len;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tidx = tvb_get_uintvar (tvb, off+1, &len, pinfo, &ei_wbxml_oversized_uintvar);\r\n\t\t\t\t\tif ((len <= tvb_len) && (idx < tvb_len))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tproto_tree_add_bytes_format(tree, hf_wbxml_opaque_data, tvb, off, 1 + len + idx, NULL,\r\n\t\t\t\t\t\t         \"  %3d | Tag   | T %3d    | OPAQUE (Opaque data)            | %s(%u bytes of opaque data)\",\r\n\t\t\t\t\t\t         recursion_level, *codepage_stag, Indent (recursion_level), idx);\r\n\t\t\t\t\t\toff += 1+len+idx;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t/* Stop processing as it is impossible to parse now */\r\n\t\t\t\t\t\toff = tvb_len;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} else { /* WBXML 1.0 - RESERVED_2 token (invalid) */\r\n\t\t\t\tproto_tree_add_none_format(tree, hf_wbxml_reserved_2, tvb, off, 1,\r\n\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    | RESERVED_2     (Invalid Token!) | WBXML 1.0 parsing stops here.\",\r\n\t\t\t\t\t\t     recursion_level, *codepage_stag);\r\n\t\t\t\t/* Stop processing as it is impossible to parse now */\r\n\t\t\t\toff = tvb_len;\r\n\t\t\t\tDebugLog((\"STAG: level = %u, Return: len = %u\\n\", recursion_level, off - offset));\r\n\t\t\t\treturn (off - offset);\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\r\n\t\t\t/* No default clause, as all cases have been treated */\r\n\t\t} else { /* LITERAL or Known TAG */\r\n\t\t\t/* We must store the initial tag, and also retrieve the new tag.\r\n\t\t\t * For efficiency reasons, we store the literal tag representation\r\n\t\t\t * for known tags too, so we can easily close the tag without the\r\n\t\t\t * need of a new lookup and avoiding storage of token codepage.\r\n\t\t\t *\r\n\t\t\t * There are 4 possibilities:\r\n\t\t\t *\r\n\t\t\t *  1. Known tag followed by a known tag\r\n\t\t\t *  2. Known tag followed by a LITERAL tag\r\n\t\t\t *  3. LITERAL tag followed by Known tag\r\n\t\t\t *  4. LITERAL tag followed by LITERAL tag\r\n\t\t\t */\r\n\r\n\t\t\t/* Store the new tag */\r\n\t\t\ttag_len = 0;\r\n\t\t\tif ((peek & 0x3F) == 4) { /* LITERAL */\r\n\t\t\t\tDebugLog((\"STAG: LITERAL tag (peek = 0x%02X, off = %u) - TableRef follows!\\n\", peek, off));\r\n\t\t\t\tidx = tvb_get_uintvar (tvb, off+1, &tag_len, pinfo, &ei_wbxml_oversized_uintvar);\r\n\t\t\t\ttag_new_literal = tvb_get_stringz_enc(pinfo->pool, tvb, str_tbl+idx, &str_len, encoding);\r\n\t\t\t\ttag_new_known = 0; /* invalidate known tag_new */\r\n\t\t\t} else { /* Known tag */\r\n\t\t\t\ttag_new_known = peek & 0x3F;\r\n\t\t\t\tif (map != NULL) {\r\n\t\t\t\t\ttag_new_literal = map_token (map->tags, *codepage_stag,\r\n\t\t\t\t\t\t\t     tag_new_known);\r\n\t\t\t\t} else {\r\n\t\t\t\t\ttag_new_literal = wmem_strdup_printf(pinfo->pool, \"Tag_0x%02X\",\r\n\t\t\t\t\t\t\ttag_new_known);\r\n\t\t\t\t}\r\n\t\t\t\t/* Stored looked up tag name string */\r\n\t\t\t}\r\n\r\n\t\t\t/* Parsing of TAG starts HERE */\r\n\t\t\tif (peek & 0x40) { /* Content present */\r\n\t\t\t\t/* Content follows\r\n\t\t\t\t * [!] An explicit END token is expected in these cases!\r\n\t\t\t\t * ==> Recursion possible if we encounter a tag with content;\r\n\t\t\t\t *     recursion will return at the explicit END token.\r\n\t\t\t\t */\r\n\t\t\t\tif (parsing_tag_content) { /* Recurse */\r\n\t\t\t\t\tDebugLog((\"STAG: Tag in Tag - RECURSE! (off = %u)\\n\", off));\r\n\t\t\t\t\t/* Do not process the attribute list:\r\n\t\t\t\t\t * recursion will take care of it */\r\n\t\t\t\t\tp_set_proto_depth(pinfo, proto_wbxml, recursion_level + 1);\r\n\t\t\t\t\tlen = parse_wbxml_tag_defined (tree, tvb, pinfo, off, str_tbl,\r\n\t\t\t\t\t\t\t\t       codepage_stag, codepage_attr, map);\r\n\t\t\t\t\toff += len;\r\n\t\t\t\t} else { /* Now we will have content to parse */\r\n\t\t\t\t\t/* Save the start tag so we can properly close it later. */\r\n\t\t\t\t\tif ((peek & 0x3F) == 4) { /* Literal tag */\r\n\t\t\t\t\t\ttag_save_literal = tag_new_literal;\r\n\t\t\t\t\t\ttag_save_known = 0;\r\n\t\t\t\t\t} else { /* Known tag */\r\n\t\t\t\t\t\ttag_save_known = tag_new_known;\r\n\t\t\t\t\t\ttag_save_literal = tag_new_literal;\r\n\t\t\t\t\t\t/* The last statement avoids needless lookups */\r\n\t\t\t\t\t}\r\n\t\t\t\t\t/* Process the attribute list if present */\r\n\t\t\t\t\tif (peek & 0x80) { /* Content and Attribute list present */\r\n\t\t\t\t\t\tif (tag_new_known) { /* Known tag */\r\n\t\t\t\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_known_tag, tvb, off, 1, tag_new_literal,\r\n\t\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    |   Known Tag 0x%02X           (AC) | %s<%s\",\r\n\t\t\t\t\t\t\t\t\t     recursion_level, *codepage_stag, tag_new_known,\r\n\t\t\t\t\t\t\t\t\t     Indent (recursion_level), tag_new_literal);\r\n\t\t\t\t\t\t\t/* Tag string already looked up earlier! */\r\n\t\t\t\t\t\t\toff++;\r\n\t\t\t\t\t\t} else { /* LITERAL tag */\r\n\t\t\t\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_literal_ac, tvb, off, 1, tag_new_literal,\r\n\t\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    | LITERAL_AC (Literal tag)   (AC) | %s<%s\",\r\n\t\t\t\t\t\t\t\t\t     recursion_level, *codepage_stag, Indent (recursion_level), tag_new_literal);\r\n\t\t\t\t\t\t\toff += 1 + tag_len;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tlen = parse_wbxml_attribute_list_defined (tree, tvb, pinfo,\r\n\t\t\t\t\t\t\t\t\t\t\t  off, str_tbl, codepage_attr, map);\r\n\t\t\t\t\t\t/* Check that there is still room in packet */\r\n\t\t\t\t\t\toff += len;\r\n\t\t\t\t\t\tif (off >= tvb_len) {\r\n\t\t\t\t\t\t\tDebugLog((\"STAG: level = %u, ThrowException: len = %u (short frame)\\n\",\r\n\t\t\t\t\t\t\t\t  recursion_level, off - offset));\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tproto_tree_add_none_format(tree, hf_wbxml_end_attribute_list, tvb, off-1, 1,\r\n\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    | END (attribute list)            | %s>\",\r\n\t\t\t\t\t\t\t\t     recursion_level, *codepage_stag, Indent (recursion_level));\r\n\t\t\t\t\t} else { /* Content, no Attribute list */\r\n\t\t\t\t\t\tif (tag_new_known) { /* Known tag */\r\n\t\t\t\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_known_tag, tvb, off, 1, tag_new_literal,\r\n\t\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    |   Known Tag 0x%02X           (.C) | %s<%s>\",\r\n\t\t\t\t\t\t\t\t\t     recursion_level, *codepage_stag, tag_new_known,\r\n\t\t\t\t\t\t\t\t\t     Indent (recursion_level), tag_new_literal);\r\n\t\t\t\t\t\t\t/* Tag string already looked up earlier! */\r\n\t\t\t\t\t\t\toff++;\r\n\t\t\t\t\t\t} else { /* LITERAL tag */\r\n\t\t\t\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_literal_c, tvb, off, 1, tag_new_literal,\r\n\t\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    | LITERAL_C  (Literal Tag)   (.C) | %s<%s>\",\r\n\t\t\t\t\t\t\t\t\t     recursion_level, *codepage_stag, Indent (recursion_level), tag_new_literal);\r\n\t\t\t\t\t\t\toff += 1 + tag_len;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\t/* The data that follows in the parsing process\r\n\t\t\t\t\t * represents content for the opening tag\r\n\t\t\t\t\t * we've just processed in the lines above.\r\n\t\t\t\t\t * Next time we encounter a tag with content: recurse\r\n\t\t\t\t\t */\r\n\t\t\t\t\tparsing_tag_content = true;\r\n\t\t\t\t\tDebugLog((\"Tag in Tag - No recursion this time! (off = %u)\\n\", off));\r\n\t\t\t\t}\r\n\t\t\t} else { /* No Content */\r\n\t\t\t\tDebugLog((\"<Tag/> in Tag - No recursion! (off = %u)\\n\", off));\r\n\t\t\t\trecursion_level++;\r\n\t\t\t\tp_set_proto_depth(pinfo, proto_wbxml, recursion_level);\r\n\t\t\t\tif (peek & 0x80) { /* No Content, Attribute list present */\r\n\t\t\t\t\tif (tag_new_known) { /* Known tag */\r\n\t\t\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_known_tag, tvb, off, 1, tag_new_literal,\r\n\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    |   Known Tag 0x%02X           (A.) | %s<%s\",\r\n\t\t\t\t\t\t\t\t     recursion_level, *codepage_stag, tag_new_known,\r\n\t\t\t\t\t\t\t\t     Indent (recursion_level), tag_new_literal);\r\n\t\t\t\t\t\t/* Tag string already looked up earlier! */\r\n\t\t\t\t\t\toff++;\r\n\t\t\t\t\t\tlen = parse_wbxml_attribute_list_defined (tree, tvb, pinfo,\r\n\t\t\t\t\t\t\t\t\t\t\t  off, str_tbl, codepage_attr, map);\r\n\t\t\t\t\t\t/* Check that there is still room in packet */\r\n\t\t\t\t\t\toff += len;\r\n\t\t\t\t\t\tif (off > tvb_len) {\r\n\t\t\t\t\t\t\tDebugLog((\"STAG: level = %u, ThrowException: len = %u (short frame)\\n\",\r\n\t\t\t\t\t\t\t\t\t\trecursion_level, off - offset));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tproto_tree_add_uint_format(tree, hf_wbxml_end_known_tag_uint, tvb, off-1, 1, *codepage_stag,\r\n\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    | END (Known Tag)                 | %s/>\",\r\n\t\t\t\t\t\t\t\t     recursion_level, *codepage_stag, Indent (recursion_level));\r\n\t\t\t\t\t} else { /* LITERAL tag */\r\n\t\t\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_literal_a, tvb, off, 1, tag_new_literal,\r\n\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    | LITERAL_A  (Literal Tag)   (A.) | %s<%s\",\r\n\t\t\t\t\t\t\t\t     recursion_level, *codepage_stag, Indent (recursion_level), tag_new_literal);\r\n\t\t\t\t\t\toff += 1 + tag_len;\r\n\t\t\t\t\t\tlen = parse_wbxml_attribute_list_defined (tree, tvb, pinfo,\r\n\t\t\t\t\t\t\t\t\t\t\t  off, str_tbl, codepage_attr, map);\r\n\t\t\t\t\t\t/* Check that there is still room in packet */\r\n\t\t\t\t\t\toff += len;\r\n\t\t\t\t\t\tif (off >= tvb_len) {\r\n\t\t\t\t\t\t\tDebugLog((\"STAG: level = %u, ThrowException: len = %u (short frame)\\n\",\r\n\t\t\t\t\t\t\t\t\t\trecursion_level, off - offset));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_end_literal_tag, tvb, off-1, 1, \"\",\r\n\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    | END (Literal Tag)               | %s/>\",\r\n\t\t\t\t\t\t\t\t     recursion_level, *codepage_stag, Indent (recursion_level));\r\n\t\t\t\t\t}\r\n\t\t\t\t} else { /* No Content, No Attribute list */\r\n\t\t\t\t\tif (tag_new_known) { /* Known tag */\r\n\t\t\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_known_tag, tvb, off, 1, tag_new_literal,\r\n\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    |   Known Tag 0x%02x           (..) | %s<%s />\",\r\n\t\t\t\t\t\t\t\t     recursion_level, *codepage_stag, tag_new_known,\r\n\t\t\t\t\t\t\t\t     Indent (recursion_level), tag_new_literal);\r\n\t\t\t\t\t\t/* Tag string already looked up earlier! */\r\n\t\t\t\t\t\toff++;\r\n\t\t\t\t\t} else { /* LITERAL tag */\r\n\t\t\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_literal, tvb, off, 1, tag_new_literal,\r\n\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    | LITERAL    (Literal Tag)   (..) | %s<%s />\",\r\n\t\t\t\t\t\t\t\t     recursion_level, *codepage_stag, Indent (recursion_level),\r\n\t\t\t\t\t\t\t\t     tag_new_literal);\r\n\t\t\t\t\t\toff += 1 + tag_len;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\trecursion_level--;\r\n\t\t\t\tp_set_proto_depth(pinfo, proto_wbxml, recursion_level);\r\n\t\t\t\t/* TODO: Do I have to reset code page here? */\r\n\t\t\t}\r\n\t\t} /* if (tag & 0x3F) >= 5 */\r\n\t} /* while */\r\n\tDebugLog((\"STAG: level = %u, Return: len = %u (end of function body)\\n\", recursion_level, off - offset));\r\n\treturn (off - offset);\r\n}", ".issect_wbxml": "static int\r\ndissect_wbxml(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\n\tdissect_wbxml_common(tvb, pinfo, tree, NULL);\r\n\treturn tvb_captured_length(tvb);\r\n}", ".issect_uaprof": "static int\r\ndissect_uaprof(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\n\tdissect_wbxml_common(tvb, pinfo, tree, &decode_uaprof_wap_248);\r\n\treturn tvb_captured_length(tvb);\r\n}", ".roto_register_wbxml": "void\r\nproto_register_wbxml(void)\r\n{\r\n\tmodule_t *wbxml_module;\t/* WBXML Preferences */\r\n\r\n\t/* Setup list of header fields. */\r\n\tstatic hf_register_info hf[] = {\r\n\t\t{ &hf_wbxml_version,\r\n\t\t  { \"Version\",\r\n\t\t    \"wbxml.version\",\r\n\t\t    FT_UINT8, BASE_HEX|BASE_EXT_STRING,\r\n\t\t    &vals_wbxml_versions_ext, 0x00,\r\n\t\t    \"WBXML Version\", HFILL }\r\n\t\t},\r\n\t\t{ &hf_wbxml_public_id_known,\r\n\t\t  { \"Public Identifier (known)\",\r\n\t\t    \"wbxml.public_id.known\",\r\n\t\t    FT_UINT32, BASE_HEX|BASE_EXT_STRING,\r\n\t\t    &vals_wbxml_public_ids_ext, 0x00,\r\n\t\t    \"WBXML Known Public Identifier (integer)\", HFILL }\r\n\t\t},\r\n\t\t{ &hf_wbxml_public_id_literal,\r\n\t\t  { \"Public Identifier (literal)\",\r\n\t\t    \"wbxml.public_id.literal\",\r\n\t\t    FT_STRING, BASE_NONE,\r\n\t\t    NULL, 0x00,\r\n\t\t    \"WBXML Literal Public Identifier (text string)\", HFILL }\r\n\t\t},\r\n\t\t{ &hf_wbxml_charset,\r\n\t\t  { \"Character Set\",\r\n\t\t    \"wbxml.charset\",\r\n\t\t    FT_UINT32, BASE_DEC|BASE_EXT_STRING,\r\n\t\t    &mibenum_vals_character_sets_ext, 0x00,\r\n\t\t    \"WBXML Character Set\", HFILL }\r\n\t\t},\r\n\t\t{ &hf_wbxml_string_table_item_offset,\r\n\t\t  { \"Offset\",\r\n\t\t    \"wbxml.string_table_item_offset\",\r\n\t\t    FT_UINT32, BASE_DEC,\r\n\t\t    NULL, 0x00,\r\n\t\t    NULL, HFILL }\r\n\t\t},\r\n\t\t{ &hf_wbxml_string_table_item_string,\r\n\t\t  { \"String\",\r\n\t\t    \"wbxml.string_table_item_string\",\r\n\t\t    FT_STRINGZ, BASE_NONE,\r\n\t\t    NULL, 0x00,\r\n\t\t    NULL, HFILL }\r\n\t\t},\r\n\t\t{ &hf_wbxml_switch_page,\r\n\t\t  { \"SWITCH_PAGE\",\r\n\t\t    \"wbxml.switch_page\",\r\n\t\t    FT_UINT32, BASE_DEC,\r\n\t\t    NULL, 0x00,\r\n\t\t    NULL, HFILL }\r\n\t\t},\r\n\t\t{ &hf_wbxml_known_tag,\r\n\t\t  { \"Known Tag\",\r\n\t\t    \"wbxml.known_tag\",\r\n\t\t    FT_STRING, BASE_NONE,\r\n\t\t    NULL, 0x00,\r\n\t\t    NULL, HFILL }\r\n\t\t},\r\n\t\t{ &hf_wbxml_end_known_tag,\r\n\t\t  { \"END Known Tag\",\r\n\t\t    \"wbxml.end_known_tag\",\r\n\t\t    FT_STRING, BASE_NONE,\r\n\t\t    NULL, 0x00,\r\n\t\t    NULL, HFILL }\r\n\t\t},\r\n\t\t{ &hf_wbxml_end_known_tag_uint,\r\n\t\t  { \"END Known Tag\",\r\n\t\t    \"wbxml.end_known_tag.uint\",\r\n\t\t    FT_UINT32, BASE_DEC,\r\n\t\t    NULL, 0x00,\r\n\t\t    NULL, HFILL }\r\n\t\t},\r\n\t\t{ &hf_wbxml_str_i,\r\n\t\t  { \"STR_I\",\r\n\t\t    \"wbxml.str_i\",\r\n\t\t    FT_STRING, BASE_NONE,\r\n\t\t    NULL, 0x00,\r\n\t\t    NULL, HFILL }\r\n\t\t},\r\n\t\t{ &hf_wbxml_str_t,\r\n\t\t  { \"STR_T\",\r\n\t\t    \"wbxml.str_t\",\r\n\t\t    FT_STRING, BASE_NONE,\r\n\t\t    NULL, 0x00,\r\n\t\t    NULL, HFILL }\r\n\t\t},\r\n\t\t{ &hf_wbxml_opaque_data,\r\n\t\t  { \"Opaque Data\",\r\n\t\t    \"wbxml.opaque_data\",\r\n\t\t    FT_BYTES, BASE_NONE,\r\n\t\t    NULL, 0x00,\r\n\t\t    NULL, HFILL }\r\n\t\t},\r\n\t\t{ &hf_wbxml_entity,\r\n\t\t  { \"ENTITY\",\r\n\t\t    \"wbxml.entity\",\r\n\t\t    FT_UINT32, BASE_DEC,\r\n\t\t    NULL, 0x00,\r\n\t\t    NULL, HFILL }\r\n\t\t},\r\n\t\t{ &hf_wbxml_literal,\r\n\t\t  { \"LITERAL\",\r\n\t\t    \"wbxml.literal\",\r\n\t\t    FT_STRING, BASE_NONE,\r\n\t\t    NULL, 0x00,\r\n\t\t    NULL, HFILL }\r\n\t\t},\r\n\t\t{ &hf_wbxml_ext_i,\r\n\t\t  { \"EXT_I\",\r\n\t\t    \"wbxml.ext_i\",\r\n\t\t    FT_STRING, BASE_NONE,\r\n\t\t    NULL, 0x00,\r\n\t\t    NULL, HFILL }\r\n\t\t},\r\n\t\t{ &hf_wbxml_ext_t,\r\n\t\t  { \"EXT_T\",\r\n\t\t    \"wbxml.ext_t\",\r\n\t\t    FT_STRING, BASE_NONE,\r\n\t\t    NULL, 0x00,\r\n\t\t    NULL, HFILL }\r\n\t\t},\r\n\t\t{ &hf_wbxml_extension_token,\r\n\t\t  { \"Extension Token\",\r\n\t\t    \"wbxml.extension_token\",\r\n\t\t    FT_STRING, BASE_NONE,\r\n\t\t    NULL, 0x00,\r\n\t\t    NULL, HFILL }\r\n\t\t},\r\n\t\t{ &hf_wbxml_reserved_2,\r\n\t\t  { \"RESERVED_2\",\r\n\t\t    \"wbxml.reserved_2\",\r\n\t\t    FT_NONE, BASE_NONE,\r\n\t\t    NULL, 0x00,\r\n\t\t    NULL, HFILL }\r\n\t\t},\r\n\t\t{ &hf_wbxml_invalid_token,\r\n\t\t  { \"Invalid token\",\r\n\t\t    \"wbxml.invalid_token\",\r\n\t\t    FT_NONE, BASE_NONE,\r\n\t\t    NULL, 0x00,\r\n\t\t    NULL, HFILL }\r\n\t\t},\r\n\t\t{ &hf_wbxml_known_attrvalue,\r\n\t\t  { \"Known attrValue\",\r\n\t\t    \"wbxml.known_attrvalue\",\r\n\t\t    FT_STRING, BASE_NONE,\r\n\t\t    NULL, 0x00,\r\n\t\t    NULL, HFILL }\r\n\t\t},\r\n\t\t{ &hf_wbxml_known_attrstart,\r\n\t\t  { \"Known attrStart\",\r\n\t\t    \"wbxml.known_attrstart\",\r\n\t\t    FT_STRING, BASE_NONE,\r\n\t\t    NULL, 0x00,\r\n\t\t    NULL, HFILL }\r\n\t\t},\r\n\t\t{ &hf_wbxml_end_literal_tag,\r\n\t\t  { \"END (Literal Tag)\",\r\n\t\t    \"wbxml.end_literal_tag\",\r\n\t\t    FT_STRING, BASE_NONE,\r\n\t\t    NULL, 0x00,\r\n\t\t    NULL, HFILL }\r\n\t\t},\r\n\t\t{ &hf_wbxml_literal_a,\r\n\t\t  { \"LITERAL_A\",\r\n\t\t    \"wbxml.literal_a\",\r\n\t\t    FT_STRING, BASE_NONE,\r\n\t\t    NULL, 0x00,\r\n\t\t    NULL, HFILL }\r\n\t\t},\r\n\t\t{ &hf_wbxml_literal_c,\r\n\t\t  { \"LITERAL_C\",\r\n\t\t    \"wbxml.literal_c\",\r\n\t\t    FT_STRING, BASE_NONE,\r\n\t\t    NULL, 0x00,\r\n\t\t    NULL, HFILL }\r\n\t\t},\r\n\t\t{ &hf_wbxml_literal_ac,\r\n\t\t  { \"LITERAL_AC\",\r\n\t\t    \"wbxml.literal_ac\",\r\n\t\t    FT_STRING, BASE_NONE,\r\n\t\t    NULL, 0x00,\r\n\t\t    NULL, HFILL }\r\n\t\t},\r\n\t\t{ &hf_wbxml_end_pi,\r\n\t\t  { \"END (PI)\",\r\n\t\t    \"wbxml.end_pi\",\r\n\t\t    FT_NONE, BASE_NONE,\r\n\t\t    NULL, 0x00,\r\n\t\t    NULL, HFILL }\r\n\t\t},\r\n\t\t{ &hf_wbxml_end_attribute_list,\r\n\t\t  { \"END (attribute list)\",\r\n\t\t    \"wbxml.end_attribute_list\",\r\n\t\t    FT_NONE, BASE_NONE,\r\n\t\t    NULL, 0x00,\r\n\t\t    NULL, HFILL }\r\n\t\t},\r\n\t\t{ &hf_wbxml_pi_xml,\r\n\t\t  { \"PI (XML Processing Instruction)\",\r\n\t\t    \"wbxml.pi_xml\",\r\n\t\t    FT_NONE, BASE_NONE,\r\n\t\t    NULL, 0x00,\r\n\t\t    NULL, HFILL }\r\n\t\t},\r\n\t};\r\n\r\n\t/* Setup protocol subtree array */\r\n\tstatic int *ett[] = {\r\n\t\t&ett_wbxml,\r\n\t\t&ett_wbxml_str_tbl,\r\n\t\t&ett_wbxml_content,\r\n\t\t&ett_wbxml_tags,\r\n\t\t&ett_wbxml_string_table_item,\r\n\t};\r\n\r\n\tstatic ei_register_info ei[] = {\r\n\t\t{ &ei_wbxml_data_not_shown, { \"wbxml.data_not_shown\", PI_PROTOCOL, PI_NOTE, \"Data representation not shown (edit WBXML preferences to show)\", EXPFILL }},\r\n\t\t{ &ei_wbxml_content_type_not_supported, { \"wbxml.content_type.not_supported\", PI_UNDECODED, PI_WARN, \"Rendering of this content type not (yet) supported\", EXPFILL }},\r\n\t\t{ &ei_wbxml_content_type_disabled, { \"wbxml.content_type.disabled\", PI_PROTOCOL, PI_NOTE, \"Rendering of this content type has been disabled (edit WBXML preferences to enable)\", EXPFILL }},\r\n\t\t{ &ei_wbxml_oversized_uintvar, { \"wbxml.oversized_uintvar\", PI_MALFORMED, PI_ERROR, \"Uintvar is oversized\", EXPFILL }},\r\n\t\t{ &ei_wbxml_too_much_recursion, { \"wbxml.too_much_recursion\", PI_UNDECODED, PI_WARN, \"Too much recursion\", EXPFILL }}\r\n\t};\r\n\r\n\texpert_module_t* expert_wbxml;\r\n\r\n\t/* Register the protocol name and description */\r\n\tproto_wbxml = proto_register_protocol(\"WAP Binary XML\", \"WBXML\", \"wbxml\");\r\n\r\n\t/* Required function calls to register the header fields\r\n\t * and subtrees used */\r\n\tproto_register_field_array(proto_wbxml, hf, array_length(hf));\r\n\tproto_register_subtree_array(ett, array_length(ett));\r\n\texpert_wbxml = expert_register_protocol(proto_wbxml);\r\n\texpert_register_field_array(expert_wbxml, ei, array_length(ei));\r\n\r\n\t/* Preferences */\r\n\twbxml_module = prefs_register_protocol(proto_wbxml, NULL);\r\n\tprefs_register_bool_preference(wbxml_module,\r\n\t\t\t\t       \"skip_wbxml_token_mapping\",\r\n\t\t\t\t       \"Skip the mapping of WBXML tokens to media type tokens.\",\r\n\t\t\t\t       \"Enable this preference if you want to view the WBXML \"\r\n\t\t\t\t       \"tokens without the representation in a media type \"\r\n\t\t\t\t       \"(e.g., WML). Tokens will show up as Tag_0x12, \"\r\n\t\t\t\t       \"attrStart_0x08 or attrValue_0x0B for example.\",\r\n\t\t\t\t       &skip_wbxml_token_mapping);\r\n\tprefs_register_bool_preference(wbxml_module,\r\n\t\t\t\t       \"disable_wbxml_token_parsing\",\r\n\t\t\t\t       \"Disable the parsing of the WBXML tokens.\",\r\n\t\t\t\t       \"Enable this preference if you want to skip the \"\r\n\t\t\t\t       \"parsing of the WBXML tokens that constitute the body \"\r\n\t\t\t\t       \"of the WBXML document. Only the WBXML header will be \"\r\n\t\t\t\t       \"dissected (and visualized) then.\",\r\n\t\t\t\t       &disable_wbxml_token_parsing);\r\n\r\n\tregister_dissector(\"wbxml\", dissect_wbxml, proto_wbxml);\r\n\tregister_dissector(\"wbxml-uaprof\", dissect_uaprof, proto_wbxml);\r\n}"}, "function_name": "proto_reg_handoff_wbxml"}
