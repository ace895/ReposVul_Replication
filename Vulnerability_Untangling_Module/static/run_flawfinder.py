from pathlib import Path
import json
import re
import subprocess
import os
import shutil

#Set up project directories and paths
project_root = Path(__file__).resolve().parents[2]
module_path = project_root / "Vulnerability_Untangling_Module"
root_path = module_path / "static"
data_path = project_root / "Raw_Data_Crawling" / "github" / "files_before"

def extract_addresses(input_str, language='c'):
    """
    Extracts individual flawfinder findings grouped by file path.

    Parameters:
        input_str (str): raw flawfinder stdout containing analysis results
        language (str): programming language of analyzed file (default 'c')

    Returns:
        list[str]: list of substrings corresponding to each detected issue
    """
    input_str = input_str.replace('\\', '/')
    root_path_norm = root_path.replace('\\', '/')

    lines = input_str.strip().split('\n')
    result = []
    true_i = 0
    for i in range(1, len(lines)):
        if lines[i].startswith(f'{root_path_norm}/tmp'):
            tmp = lines[i]
            for j in range(i + 1, len(lines)):
                if not lines[j].startswith(f'{root_path_norm}/tmp'):
                    tmp += '\n' + lines[j]
                else:
                    true_i = j
                    break
            result.append(tmp)
    return result

def extract_number_from_string(input_str, after_real_path, language='c'):
    """
    Extracts line number from a flawfinder message string for a given file.

    Parameters:
        input_str (str): flawfinder output message
        after_real_path (str): path to temporary file used for analysis
        language (str): language of the file (default 'c')

    Returns:
        str or None: extracted line number, or None if not found
    """
    after_real_path_norm = after_real_path.replace('\\', '/')
    after_real_path_esc = re.escape(after_real_path_norm)

    pattern = f'{after_real_path_esc}:(\\d+)'
    match = re.search(pattern, input_str)

    if match:
        return match.group(1)
    else:
        return None

def process_content(lock, language, file_name, write_name, idx, content_line):
    """
    Processes a single record from the JSONL file by running cppcheck on each file,
    checking if detected issues fall within modified lines, and saving results.

    Parameters:
        lock (threading.Lock): Lock object for thread-safe writing to output file.
        language (str): Programming language of the analyzed files (e.g., 'c', 'cpp', 'java').
        file_name (str | Path): Path to the input JSONL file containing code details and patches.
        write_name (str | Path): Path to the output JSONL file where analysis results are appended.
        idx (int): Index of the current record being processed, used for tracking progress.
        content_line (str): A single line from the JSONL file representing one record.

    Input files:
        Raw_Data_Crawling/github/files_before/<file_path> - original version of source code

    Output files:
        Vulnerability_Untangling_Module/output/cppcheck/<language>_new.jsonl - updated JSON with static analysis results
    """


def func(language, file_name, write_name): 
    """
    Runs flawfinder static analysis for all source files in the input dataset,
    matches detected warnings to changed lines in patches, and writes updated
    JSON records to the output file.

    Parameters:
        language (str): Programming language of the analyzed files (e.g., 'c', 'cpp', 'java', 'python').
        file_name (str | Path): Path to the input JSONL file containing merged vulnerability data.
        write_name (str | Path): Path to the output JSONL file where annotated results are saved.

    Input files:
        <Raw_Data_Crawling/github/merge_result_new/language/merge_<lang>.jsonl>

    Output files:
        <Vulnerability_Untangling_Module/output/flawfinder/merge_<lang>_new.jsonl>
    """

    #Determine file extensions for each language
    if language == 'c':
        language_choice = ['c', 'h']
    elif language == 'cpp':
        language_choice = ['cpp', 'h', 'cc']
    elif language == 'java':
        language_choice = ['java']
    elif language == 'python':
        language_choice = ['py']

    #Read JSONL file containing patch details
    with open(file_name, "r", encoding="utf-8") as r:
        content = r.readlines()

    #Process each record in the dataset
    for idx in range(len(content)):
        record_dict = json.loads(content[idx])
        details = record_dict['details']

        #Iterate through files within a single patch record
        for idx1, detail in enumerate(details):
            if not detail['file_language'].lower().strip() in language_choice:
                continue

            code = detail['code']
            code_before = detail['code_before']
            file_path = detail['file_path']
            file_language = detail['file_language']
            patch = detail['patch']

            #Extract modified line ranges from patch
            pattern = re.compile(r'@@ -(\d+),?(\d*) \+(\d+),?(\d*) @@')
            matches = pattern.findall(patch)

            patch_old_line = []
            for match in matches:
                old_start, old_lines, new_start, new_lines = int(match[0]), match[1], int(match[2]), match[3]
                old_lines = int(old_lines) if old_lines else 0
                new_lines = int(new_lines) if new_lines else 0
                patch_old_line.append([old_start, old_lines])

            #Prepare file paths for analysis
            if file_path.startswith("files/") or file_path.startswith("files\\"):
                real_path = os.path.join(data_path, file_path[6:]).replace('\\', '/')
            else:
                real_path = file_path.replace('\\', '/')
            after_real_path = "{}/tmp/{}.{}".format(
                root_path,
                file_path[6:].replace('\\', '_').replace('/', '_'),
                file_language
            )

            #Skip if source file not found
            if not os.path.exists(real_path):
                print('No path exists!')
                continue

            #Copy file to temporary directory for flawfinder analysis
            shutil.copy(real_path, after_real_path)

            #Run flawfinder for supported languages
            if file_language in ['c', 'cpp', 'h', 'cc']:
                is_find = False
                find_message = list()

                #Execute flawfinder subprocess
                cppcheck_result = subprocess.run(
                    ["flawfinder", "--context", "--dataonly", after_real_path],
                    stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE,
                    text=True,
                    errors='ignore'
                )

                #Remove temp file after processing
                if os.path.exists(after_real_path):
                    os.remove(after_real_path)

                #Parse flawfinder output
                if cppcheck_result.returncode == 0:
                    error_message = cppcheck_result.stdout
                    print("Command output:\n", cppcheck_result.stdout)
                    if not error_message.strip() == '':
                        result_array = extract_addresses(error_message, file_language)
                        print(result_array)

                        #Check if detected issues fall within modified lines
                        for result in result_array:
                            print('------------------------')
                            print(result)
                            print(patch_old_line)
                            line_no = int(extract_number_from_string(result, after_real_path, file_language))
                            for i in range(len(patch_old_line)):
                                if line_no >= patch_old_line[i][0] and line_no < patch_old_line[i][0] + patch_old_line[i][1]:
                                    is_find = True
                                    find_message.append(result)
                                    print(result)
                else:
                    print('Execute Error!')

                #Store flawfinder findings in the JSON structure
                if 'static' not in details[idx1]:
                    details[idx1]['static'] = dict()
                if 'flawfinder' not in details[idx1]['static']:
                    details[idx1]['static']['flawfinder'] = list()
                details[idx1]['static']['flawfinder'] = [is_find, find_message]

                record_dict['details'] = details

        #Write updated record to output file
        with open(write_name, "a", encoding="utf-8") as rf:
            rf.write(json.dumps(record_dict) + '\n')

def main():
    """
    Entry point for running flawfinder static analysis on C and C++ projects.

    Input files:
        Raw_Data_Crawling/github/merge_result_new/language/merge_C.jsonl
        Raw_Data_Crawling/github/merge_result_new/language/merge_cpp.jsonl

    Output files:
        Vulnerability_Untangling_Module/output/flawfinder/merge_C_new.jsonl
        Vulnerability_Untangling_Module/output/flawfinder/merge_cpp_new.jsonl
    """
    #Run flawfinder for C files
    language = "c"
    file_name = project_root / "Raw_Data_Crawling" / "github" / "merge_result_new" / "language" / "merge_C.jsonl"
    write_name = f'{module_path}/output/flawfinder/merge_C_new.jsonl'
    if not os.path.exists(write_name):
        open(write_name, 'a').close()
    func(language, file_name, write_name)
    print("Finished flawfinder evaluation for C files")

    #Run flawfinder for C++ files
    language = "cpp"
    file_name = project_root / "Raw_Data_Crawling" / "github" / "merge_result_new" / "language" / "merge_cpp.jsonl"
    write_name = f'{module_path}/output/flawfinder/merge_cpp_new.jsonl'
    func(language, file_name, write_name)
    print("Finished flawfinder evaluation for C++ files")

if __name__ == "__main__":
    main()
