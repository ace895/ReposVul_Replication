{"repo_after": "10ef1dca63d62433fda13309b4a228782db823f7", "repo_before": "e6399f5a470f50285cef173e438638ae5bc741e0", "functions_before": [{"name": "gdImageCreateFromTgaCtx", "content": "BGD_DECLARE(gdImagePtr) gdImageCreateFromTgaCtx(gdIOCtx* ctx)\n{\n\tint bitmap_caret = 0;\n\toTga *tga = NULL;\n\t/*\tint pixel_block_size = 0;\n\t\tint image_block_size = 0; */\n\tvolatile gdImagePtr image = NULL;\n\tint x = 0;\n\tint y = 0;\n\n\ttga = (oTga *) gdMalloc(sizeof(oTga));\n\tif (!tga) {\n\t\treturn NULL;\n\t}\n\n\ttga->bitmap = NULL;\n\ttga->ident = NULL;\n\n\tif (read_header_tga(ctx, tga) < 0) {\n\t\tfree_tga(tga);\n\t\treturn NULL;\n\t}\n\n\t/*TODO: Will this be used?\n\t\tpixel_block_size = tga->bits / 8;\n\t\timage_block_size = (tga->width * tga->height) * pixel_block_size;\n\t*/\n\n\tif (read_image_tga(ctx, tga) < 0) {\n\t\tfree_tga(tga);\n\t\treturn NULL;\n\t}\n\n\timage = gdImageCreateTrueColor((int)tga->width, (int)tga->height );\n\n\tif (image == 0) {\n\t\tfree_tga( tga );\n\t\treturn NULL;\n\t}\n\n\t/*!\t\\brief Populate GD image object\n\t *  Copy the pixel data from our tga bitmap buffer into the GD image\n\t *  Disable blending and save the alpha channel per default\n\t */\n\tif (tga->alphabits) {\n\t\tgdImageAlphaBlending(image, 0);\n\t\tgdImageSaveAlpha(image, 1);\n\t}\n\n\t/* TODO: use alphabits as soon as we support 24bit and other alpha bps (ie != 8bits) */\n\tfor (y = 0; y < tga->height; y++) {\n\t\tregister int *tpix = image->tpixels[y];\n\t\tfor ( x = 0; x < tga->width; x++, tpix++) {\n\t\t\tif (tga->bits == TGA_BPP_24) {\n\t\t\t\t*tpix = gdTrueColor(tga->bitmap[bitmap_caret + 2], tga->bitmap[bitmap_caret + 1], tga->bitmap[bitmap_caret]);\n\t\t\t\tbitmap_caret += 3;\n\t\t\t} else if (tga->bits == TGA_BPP_32 || tga->alphabits) {\n\t\t\t\tregister int a = tga->bitmap[bitmap_caret + 3];\n\n\t\t\t\t*tpix = gdTrueColorAlpha(tga->bitmap[bitmap_caret + 2], tga->bitmap[bitmap_caret + 1], tga->bitmap[bitmap_caret], gdAlphaMax - (a >> 1));\n\t\t\t\tbitmap_caret += 4;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (tga->flipv && tga->fliph) {\n\t\tgdImageFlipBoth(image);\n\t} else if (tga->flipv) {\n\t\tgdImageFlipVertical(image);\n\t} else if (tga->fliph) {\n\t\tgdImageFlipHorizontal(image);\n\t}\n\n\tfree_tga(tga);\n\n\treturn image;\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos_before\\2016_8\\e6399f5a470f50285cef173e438638ae5bc741e0_before\\libgd-e6399f5a470f50285cef173e438638ae5bc741e0\\src\\gd_tga.c", "callees": [], "callers": []}, {"name": "read_header_tga", "content": "int read_header_tga(gdIOCtx *ctx, oTga *tga)\n{\n\n\tunsigned char header[18];\n\n\tif (gdGetBuf(header, sizeof(header), ctx) < 18) {\n\t\tgd_error(\"fail to read header\");\n\t\treturn -1;\n\t}\n\n\ttga->identsize = header[0];\n\ttga->colormaptype = header[1];\n\ttga->imagetype = header[2];\n\ttga->colormapstart = header[3] + (header[4] << 8);\n\ttga->colormaplength = header[5] + (header[6] << 8);\n\ttga->colormapbits = header[7];\n\ttga->xstart = header[8] + (header[9] << 8);\n\ttga->ystart = header[10] + (header[11] << 8);\n\ttga->width = header[12] + (header[13] << 8);\n\ttga->height = header[14] + (header[15] << 8);\n\ttga->bits = header[16];\n\ttga->alphabits = header[17] & 0x0f;\n\ttga->fliph = (header[17] & 0x10) ? 1 : 0;\n\ttga->flipv = (header[17] & 0x20) ? 0 : 1;\n\n#if DEBUG\n\tprintf(\"format bps: %i\\n\", tga->bits);\n\tprintf(\"flip h/v: %i / %i\\n\", tga->fliph, tga->flipv);\n\tprintf(\"alpha: %i\\n\", tga->alphabits);\n\tprintf(\"wxh: %i %i\\n\", tga->width, tga->height);\n#endif\n\n\tswitch(tga->bits) {\n\tcase 8:\n\tcase 16:\n\tcase 24:\n\tcase 32:\n\t\tbreak;\n\tdefault:\n\t\tgd_error(\"bps %i not supported\", tga->bits);\n\t\treturn -1;\n\t\tbreak;\n\t}\n\n\ttga->ident = NULL;\n\n\tif (tga->identsize > 0) {\n\t\ttga->ident = (char *) gdMalloc(tga->identsize * sizeof(char));\n\t\tif(tga->ident == NULL) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tgdGetBuf(tga->ident, tga->identsize, ctx);\n\t}\n\n\treturn 1;\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos_before\\2016_8\\e6399f5a470f50285cef173e438638ae5bc741e0_before\\libgd-e6399f5a470f50285cef173e438638ae5bc741e0\\src\\gd_tga.c", "callees": ["printf", "gd_error", "gdGetBuf", "gdMalloc"], "callers": []}], "functions_after": [{"name": "gdImageCreateFromTgaCtx", "content": "BGD_DECLARE(gdImagePtr) gdImageCreateFromTgaCtx(gdIOCtx* ctx)\n{\n\tint bitmap_caret = 0;\n\toTga *tga = NULL;\n\t/*\tint pixel_block_size = 0;\n\t\tint image_block_size = 0; */\n\tvolatile gdImagePtr image = NULL;\n\tint x = 0;\n\tint y = 0;\n\n\ttga = (oTga *) gdMalloc(sizeof(oTga));\n\tif (!tga) {\n\t\treturn NULL;\n\t}\n\n\ttga->bitmap = NULL;\n\ttga->ident = NULL;\n\n\tif (read_header_tga(ctx, tga) < 0) {\n\t\tfree_tga(tga);\n\t\treturn NULL;\n\t}\n\n\t/*TODO: Will this be used?\n\t\tpixel_block_size = tga->bits / 8;\n\t\timage_block_size = (tga->width * tga->height) * pixel_block_size;\n\t*/\n\n\tif (read_image_tga(ctx, tga) < 0) {\n\t\tfree_tga(tga);\n\t\treturn NULL;\n\t}\n\n\timage = gdImageCreateTrueColor((int)tga->width, (int)tga->height );\n\n\tif (image == 0) {\n\t\tfree_tga( tga );\n\t\treturn NULL;\n\t}\n\n\t/*!\t\\brief Populate GD image object\n\t *  Copy the pixel data from our tga bitmap buffer into the GD image\n\t *  Disable blending and save the alpha channel per default\n\t */\n\tif (tga->alphabits) {\n\t\tgdImageAlphaBlending(image, 0);\n\t\tgdImageSaveAlpha(image, 1);\n\t}\n\n\t/* TODO: use alphabits as soon as we support 24bit and other alpha bps (ie != 8bits) */\n\tfor (y = 0; y < tga->height; y++) {\n\t\tregister int *tpix = image->tpixels[y];\n\t\tfor ( x = 0; x < tga->width; x++, tpix++) {\n\t\t\tif (tga->bits == TGA_BPP_24) {\n\t\t\t\t*tpix = gdTrueColor(tga->bitmap[bitmap_caret + 2], tga->bitmap[bitmap_caret + 1], tga->bitmap[bitmap_caret]);\n\t\t\t\tbitmap_caret += 3;\n\t\t\t} else if (tga->bits == TGA_BPP_32 && tga->alphabits) {\n\t\t\t\tregister int a = tga->bitmap[bitmap_caret + 3];\n\n\t\t\t\t*tpix = gdTrueColorAlpha(tga->bitmap[bitmap_caret + 2], tga->bitmap[bitmap_caret + 1], tga->bitmap[bitmap_caret], gdAlphaMax - (a >> 1));\n\t\t\t\tbitmap_caret += 4;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (tga->flipv && tga->fliph) {\n\t\tgdImageFlipBoth(image);\n\t} else if (tga->flipv) {\n\t\tgdImageFlipVertical(image);\n\t} else if (tga->fliph) {\n\t\tgdImageFlipHorizontal(image);\n\t}\n\n\tfree_tga(tga);\n\n\treturn image;\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos\\2016_8\\10ef1dca63d62433fda13309b4a228782db823f7_after\\libgd-10ef1dca63d62433fda13309b4a228782db823f7\\src\\gd_tga.c", "callees": [], "callers": []}, {"name": "read_header_tga", "content": "int read_header_tga(gdIOCtx *ctx, oTga *tga)\n{\n\n\tunsigned char header[18];\n\n\tif (gdGetBuf(header, sizeof(header), ctx) < 18) {\n\t\tgd_error(\"fail to read header\");\n\t\treturn -1;\n\t}\n\n\ttga->identsize = header[0];\n\ttga->colormaptype = header[1];\n\ttga->imagetype = header[2];\n\ttga->colormapstart = header[3] + (header[4] << 8);\n\ttga->colormaplength = header[5] + (header[6] << 8);\n\ttga->colormapbits = header[7];\n\ttga->xstart = header[8] + (header[9] << 8);\n\ttga->ystart = header[10] + (header[11] << 8);\n\ttga->width = header[12] + (header[13] << 8);\n\ttga->height = header[14] + (header[15] << 8);\n\ttga->bits = header[16];\n\ttga->alphabits = header[17] & 0x0f;\n\ttga->fliph = (header[17] & 0x10) ? 1 : 0;\n\ttga->flipv = (header[17] & 0x20) ? 0 : 1;\n\n#if DEBUG\n\tprintf(\"format bps: %i\\n\", tga->bits);\n\tprintf(\"flip h/v: %i / %i\\n\", tga->fliph, tga->flipv);\n\tprintf(\"alpha: %i\\n\", tga->alphabits);\n\tprintf(\"wxh: %i %i\\n\", tga->width, tga->height);\n#endif\n\n\tif (!((tga->bits == TGA_BPP_24 && tga->alphabits == 0)\n\t\t|| (tga->bits == TGA_BPP_32 && tga->alphabits == 8)))\n\t{\n\t\tgd_error_ex(GD_WARNING, \"gd-tga: %u bits per pixel with %u alpha bits not supported\\n\",\n\t\t\ttga->bits, tga->alphabits);\n\t\treturn -1;\n\t}\n\n\ttga->ident = NULL;\n\n\tif (tga->identsize > 0) {\n\t\ttga->ident = (char *) gdMalloc(tga->identsize * sizeof(char));\n\t\tif(tga->ident == NULL) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tgdGetBuf(tga->ident, tga->identsize, ctx);\n\t}\n\n\treturn 1;\n}", "file": "C:\\Users\\patha\\Documents\\University\\Year 4\\CSI 4900\\ReposVul\\Raw_Data_Crawling\\github\\repos\\2016_8\\10ef1dca63d62433fda13309b4a228782db823f7_after\\libgd-10ef1dca63d62433fda13309b4a228782db823f7\\src\\gd_tga.c", "callees": ["gd_error", "gdGetBuf", "printf", "gdMalloc", "gd_error_ex"], "callers": []}], "callerTree_before": {"read_header_tga": ["printf", "gd_error", "gdGetBuf", "gdMalloc"]}, "calleeTree_before": {"gdGetBuf": ["read_header_tga"], "gd_error": ["read_header_tga"], "printf": ["read_header_tga"], "gdMalloc": ["read_header_tga"]}, "callerTree_after": {"read_header_tga": ["gd_error", "gdGetBuf", "printf", "gdMalloc", "gd_error_ex"]}, "calleeTree_after": {"gdGetBuf": ["read_header_tga"], "gd_error": ["read_header_tga"], "printf": ["read_header_tga"], "gd_error_ex": ["read_header_tga"], "gdMalloc": ["read_header_tga"]}}
